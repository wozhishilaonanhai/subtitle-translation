1
00:00:00.000 --> 00:00:03.284
如果你对区块链感兴趣，这门课很适合你。

2
00:00:03.284 --> 00:00:08.948
帕特里克·柯林斯是一位资深的软件工程师和长期的金融行业开发人员。

3
00:00:08.948 --> 00:00:12.089
一定要留下你从这门课中学到的东西的评论。

4
00:00:12.128 --> 00:00:28.984
欢迎来到终极可靠的智能合约和区块链开发人员课程，除了JavaScript，我们最近用Python做了这个视频的一个版本，现在有超过200万的点击量，使它成为这个星球上观看人数最多的智能合约教程。

5
00:00:28.984 --> 00:00:31.623
我们从第一门课中学到了很多东西。

6
00:00:31.623 --> 00:00:35.263
如果你喜欢Python语言，一定要看看那本。

7
00:00:35.263 --> 00:00:41.114
我们总结了从制作第一门课程中学到的所有知识，并将其整合到这个JavaScript视频中。

8
00:00:41.114 --> 00:00:48.721
如果你想开始学习web3区块链智能合约或任何这些术语，这门课程很适合你。

9
00:00:48.721 --> 00:00:54.560
它适合所有人，无论你在编程或区块链方面的经验水平如何。

10
00:00:54.560 --> 00:00:58.520
理想情况下，你知道，在开始之前，有一点JavaScript。

11
00:00:58.520 --> 00:01:01.465
但如果你没有，不用担心，我们会一路帮助你。

12
00:01:01.465 --> 00:01:10.886
如果你真的想在开始之前学习一点JavaScript, Free Code Camp上有一些很棒的课程可以让你学习更多，但你绝对不需要。

13
00:01:10.886 --> 00:01:15.401
实际上，任何有面向对象编程语言经验的人都可以。

14
00:01:15.401 --> 00:01:21.998
如果你是编码新手，或者你是区块链新手，这就是你应该做的。

15
00:01:21.998 --> 00:01:29.809
如果您已经对区块链或编码有了很多了解，本课程将为您提供更深入的基础知识。

16
00:01:29.891 --> 00:01:31.899
欢迎来到兔子洞的边缘。

17
00:01:32.928 --> 00:01:35.238
谁不知道，我叫帕特里克·柯林斯。

18
00:01:35.953 --> 00:01:39.551
合同工程师，开发人员提倡链连接协议。

19
00:01:39.551 --> 00:01:42.108
我生活在智能合约时代。

20
00:01:42.108 --> 00:01:46.481
我还在自己的频道上制作YouTube视频，在Twitter上发布中型帖子等等。

21
00:01:46.481 --> 00:01:50.805
教授人们关于智能合约、编码和这项新技术的知识。

22
00:01:50.805 --> 00:01:54.945
我喜欢帮助开发人员学习，成长和了解这个新的降临。

23
00:01:54.945 --> 00:01:56.892
这就是区块链和智能合约。

24
00:01:56.892 --> 00:02:03.981
我将带您踏上成为区块链专家和智能合约开发领域的向导的旅程。

25
00:02:03.981 --> 00:02:15.445
即使你不想成为一名开发人员，第一部分我们的区块链基础知识，会给你很多关于区块链和智能合约如何工作的基本知识。

26
00:02:15.445 --> 00:02:17.742
你能来我太激动了。

27
00:02:17.742 --> 00:02:19.587
我希望你们享受这段旅程。

28
00:02:19.587 --> 00:02:25.090
这是一个数据转储，是我在这个领域学到的所有东西的激情教育项目。

29
00:02:25.090 --> 00:02:47.466
我100%肯定，如果你跟着做，你会走到另一边，武装知识，成为这个不可思议的行业的积极力量，稳定和智能合约开发人员是大量的需求，平均年薪约14.5万美元，学习这门课程有巨大的经济机会。

30
00:02:47.466 --> 00:02:56.340
这项技术有能力彻底改变我们接触的一切，你可以成为引领这个新时代的先驱者之一。

31
00:02:56.340 --> 00:02:57.324
在我们的课程中。

32
00:02:57.324 --> 00:03:05.496
我们已经为人们提供了这些教育需求，并将他们送入区块链和智能合约领域的职业生涯。

33
00:03:05.496 --> 00:03:17.178
我们将为您提供所有的尖端工具以及如何使用它们，包括使用像D phi NF TS Dows、ERC 20可升级、智能合约等东西。

34
00:03:17.178 --> 00:03:31.017
我们将教你们必要的技能，来构建像Ave合成和复合这样的应用程序，数十亿美元的分散应用程序，或者像crypto punks或board apes这样巨大成功的非ft项目。

35
00:03:31.017 --> 00:03:38.023
陶氏就像制造商陶氏或开发商，陶氏和你在加密货币世界中看到的任何令人惊奇的东西。

36
00:03:38.023 --> 00:03:47.968
通过学习这些技能，你将拥有所有这些唾手可得的经济机会，并有能力成为彻底改变我们相互交往方式的先锋。

37
00:03:47.968 --> 00:03:49.138
从根本上讲。

38
00:03:49.138 --> 00:04:04.910
构建去中心化的智能合约应用程序正在构建一个更负责任的世界一个承诺牢不可破的世界，一个更快、更高效、财务自由的世界，一个协作的社区，将哲学和技术的威力结合到一个新系统中。

39
00:04:04.910 --> 00:04:13.866
我们将在本课程的第一课中更多地了解智能合约和去中心化应用的目的和价值，以及为什么它们如此令人兴奋。

40
00:04:13.866 --> 00:04:14.823
完成本课程。

41
00:04:14.823 --> 00:04:15.858
你就会准备好。

42
00:04:15.858 --> 00:04:22.974
所以，我想再次向你们表示衷心的感谢和崇高的敬意，因为你们迈出了进入这个领域的第一步。

43
00:04:22.974 --> 00:04:24.464
欢迎来到Web 3。

44
00:04:24.464 --> 00:04:25.505
欢迎来到区块链。

45
00:04:25.505 --> 00:04:26.709
欢迎来到智能合约。

46
00:04:26.709 --> 00:04:29.170
我们在兔子洞的尽头见。

47
00:04:29.269 --> 00:04:40.105
让我们来看看这门课的一些最佳实践，这样你就能最有效地学习，并尽可能地学习这门课。

48
00:04:40.280 --> 00:04:41.724
您不希望跳过此部分。

49
00:04:41.724 --> 00:04:43.643
它能帮你解决80%的问题。

50
00:04:43.643 --> 00:05:05.757
现在，在学习这门课程的过程中，百分百确定要跟随与这门课程相关的GitHub知识库，我们在视频描述中有一个链接，你可以完全点击跟随，并在选项卡中打开，因为它有Sam查询的所有代码，时间戳，可以与之互动的社区等等，它将是你观看这门课程的圣经。

51
00:05:05.757 --> 00:05:07.473
是的，我们有一个讨论标签。

52
00:05:07.473 --> 00:05:14.602
“讨论”标签是一个你可以提问的地方，与其他正在学习这门课程的开发人员进行交流。

53
00:05:14.602 --> 00:05:16.162
寻求帮助，等等。

54
00:05:16.162 --> 00:05:20.269
一定要和别人打个招呼，认识和你有相同想法的人。

55
00:05:20.319 --> 00:05:22.286
现在，区块链和智能合约运行得非常快。

56
00:05:22.322 --> 00:05:24.181
事物在不断更新。

57
00:05:25.325 --> 00:05:31.658
总是更新最新的，当我打开一些文档时，试着为你自己也打开文档。

58
00:05:31.658 --> 00:05:33.911
甚至可能把代码示例放在你旁边。

59
00:05:33.911 --> 00:05:45.296
当你写代码的时候，一定要回顾以确保你跟上进度，然后你有最新的样本，有时技术可能会改变，可能会有更好的方法来做一些事情。

60
00:05:45.296 --> 00:05:54.692
我们有一个文件叫时间更新，确保这是你遇到问题时第一个检查的地方看看是否有你错过的东西被更新了，它会按时间顺序排列。

61
00:05:54.692 --> 00:05:56.193
所以更容易找到更新。

62
00:05:56.193 --> 00:05:59.633
基本上，这就是说，总是首先参考GitHub回购。

63
00:05:59.633 --> 00:06:19.695
如果你发现了一个错误，或者有些事情没有按照你预期的方式进行，加入对话，结束讨论，留下一个问题，在这里提问，休息一下，我无法告诉你有多少人在一种情况下匆忙读完我们的第一节课却没有记住那么多的信息，如果你休息一下，你的大脑记住的信息会更好。

64
00:06:19.695 --> 00:06:23.104
所以每25分钟或半小时，也许走5分钟。

65
00:06:23.104 --> 00:06:25.565
然后每两个小时休息一次。

66
00:06:25.565 --> 00:06:32.357
如果你真的想确保有什么东西深入学习了，在继续下一课之前，试着回顾并反思你在上一课上做了什么。

67
00:06:32.392 --> 00:06:35.928
但与此同时，要以自己的速度学习。

68
00:06:36.396 --> 00:06:39.194
这条航线没有合适的速度。

69
00:06:41.400 --> 00:06:44.485
一周，一个月，甚至一年，都无所谓。

70
00:06:45.404 --> 00:06:52.134
适合你的速度，你可以用YouTube视频里的小齿轮图标来改变速度。

71
00:06:52.134 --> 00:06:55.160
如果我说得太快了，你可以让我说慢一点。

72
00:06:55.160 --> 00:07:01.307
与此同时，如果我说得太慢了，你可以加快我的语速，你甚至不需要按顺序讲。

73
00:07:01.307 --> 00:07:06.443
你可以从一个话题跳到另一个话题，如果你不想学习全栈，你可以跳过全栈的东西。

74
00:07:06.443 --> 00:07:09.142
如果你不想学编码，我们可以跳过编码的部分。

75
00:07:09.142 --> 00:07:12.631
如果你只想去高级课程，那就去高级课程。

76
00:07:12.631 --> 00:07:16.152
我们非常鼓励你们停下来，回来问问题。

77
00:07:16.152 --> 00:07:19.264
区块链和智能合约世界是不可思议的协作。

78
00:07:19.264 --> 00:07:39.858
所以一定要使用像我们的GitHub知识库的讨论标签这样的工具，在Stack Overflow和Aetherium Stack Exchange上提问，并标记相关技术，在不同的GitHub知识库上提出问题，你正在工作，进入不和，Reddit, Twitter和任何其他这些社区和技术聚集的地方。

79
00:07:39.858 --> 00:07:47.677
我如此强调这些社区方面的原因是，成为一个稳定的区块链工程师不仅仅是稳定的部分。

80
00:07:47.677 --> 00:07:56.784
熟练使用这个领域的所有工具，包括获取帮助和提供帮助的工具，是在这里获得成功的必要条件。

81
00:07:56.784 --> 00:07:59.545
网络是庞大的，它让它充满了乐趣。

82
00:07:59.545 --> 00:08:04.150
当你继续你的旅程，你会变得更高级，你会寻找遇见其他开发者的地方。

83
00:08:04.150 --> 00:08:14.759
Hackathons是与其他工程师联系的最佳场所之一，chainlink Hackathons eath、global Hackathons和Dev folio Hackathons是三个很棒的Hackathons套件。

84
00:08:14.759 --> 00:08:19.447
无论你处在人生的哪个阶段，它们都是你学习的好地方。

85
00:08:19.499 --> 00:08:22.882
好了，以上就是这门课的一些最佳实践。

86
00:08:22.882 --> 00:08:31.187
你正站在兔子洞的边缘，往下看，凝视着web 3、智能合约和区块链的世界。

87
00:08:31.187 --> 00:08:34.693
如果你像我一样想要投入其中，你想要继续前进。

88
00:08:34.693 --> 00:08:38.350
让我们开始进入智能合约世界的旅程。

89
00:08:38.350 --> 00:08:43.093
这一切都从区块链的基础开始。

90
00:08:43.523 --> 00:08:45.185
我知道你很兴奋要开始编程了。

91
00:08:45.185 --> 00:08:50.475
但在我们开始之前，我们想学习一些区块链和智能合约的基础知识。

92
00:08:50.530 --> 00:09:01.450
理解这些意识形态和这些基础是如此重要，因为它将决定如何构建去中心化应用程序，学习区块链和坚实性的基础是至关重要的。

93
00:09:01.450 --> 00:09:07.796
但如果你已经知道区块链的基本知识，请随意跳到第二课。

94
00:09:08.547 --> 00:09:11.407
既然你来了，你可能听说过比特币。

95
00:09:11.407 --> 00:09:17.047
比特币是第一个使用称为区块链的革命性技术的协议之一。

96
00:09:17.047 --> 00:09:24.834
比特币白皮书由伪匿名的中本聪(Satoshi Nakamoto)撰写，概述了比特币如何进行点对点交易。

97
00:09:24.834 --> 00:09:26.208
在去中心化的网络中。

98
00:09:26.208 --> 00:09:38.702
这个网络由密码学，像样的日食提供动力，允许人们以去中心化的方式从事抵制审查的金融，这是由于它的特点，我们稍后会讲到。

99
00:09:38.702 --> 00:09:51.525
人们认为它是一种更高级的数字价值储存方式，比黄金之类的价值储存方式更好，这就是为什么你会听到人们通常把它称为类似黄金的数字黄金。

100
00:09:51.590 --> 00:09:57.138
在这个星球上，比特币的数量是稀缺的，或者说数量是固定的，只有你可以买卖的数量。

101
00:09:57.138 --> 00:10:04.416
你可以在白皮书中阅读更多关于最初愿景的内容，我们已经在与本课程相关的GitHub回购中链接到白皮书。

102
00:10:04.416 --> 00:10:11.137
现在，这是一个疯狂的突破，我们将学习这一切是如何实现的以及它是如何工作的。

103
00:10:11.137 --> 00:10:18.375
不过，有些人看到了这项技术，想把它做得更远一点，用这个区块链技术做更多的事情。

104
00:10:18.375 --> 00:10:30.306
几年后，一个名叫Vitalik Buterin的人，发布了一份名为Aetherium的新协议白皮书，该协议使用相同的区块链基础设施，但有一个额外的功能。

105
00:10:30.306 --> 00:10:48.542
2015年，他和其他一些联合创始人发布了Aetherium项目，在这个项目中，人们不仅可以进行去中心化的交易，还可以进行去中心化的协议，去中心化的组织，以及所有这些没有中央中介或中央治理力量的相互作用的方式。

106
00:10:48.542 --> 00:10:57.562
基本上，他们的想法是把这个让比特币如此伟大的东西，添加去中心化协议，或智能合约。

107
00:10:57.562 --> 00:11:01.338
事实上，从技术上讲，这些智能合约并不是什么新想法。

108
00:11:01.338 --> 00:11:16.882
早在1994年，一个叫尼克·扎博的人就提出了智能合约是一组指令以去中心化的自治方式执行，不需要第三方或中央机构来运行它们。

109
00:11:16.882 --> 00:11:21.680
它们在这些区块链或智能合约平台上诞生，比如Aetherium。

110
00:11:21.680 --> 00:11:32.167
智能合约将是我们这门课的核心内容，也是我们要发展的内容，你可以像看待传统合约或传统协议一样看待智能合约。

111
00:11:32.167 --> 00:11:43.491
它们只是双方之间的一套指令，只是它们不是写在纸上或用微软Word打印出来的，而是用代码写在这些去中心化的区块链平台上。

112
00:11:43.491 --> 00:11:45.592
这也是他们被处决的地方。

113
00:11:45.592 --> 00:11:50.280
而不是由两方，或三方，或任何涉及的多方来执行。

114
00:11:50.280 --> 00:11:54.692
这消除了中心化的问题，我们稍后会详细讨论这个问题。

115
00:11:54.692 --> 00:11:59.677
这是以太协议和比特币协议的主要区别之一。

116
00:11:59.677 --> 00:12:01.298
就是这些智能合约。

117
00:12:01.298 --> 00:12:10.939
从技术上讲，比特币确实有智能合约，但它们是图灵不完全的，这意味着它们没有编程语言赋予它们的所有功能。

118
00:12:10.939 --> 00:12:13.625
这是比特币开发者有意为之。

119
00:12:13.732 --> 00:12:26.270
比特币开发者将比特币视为与Aetherium相比的价值储存工具，而Aetherium则既是一种价值储存工具，也是促进这些去中心化协议的工具。

120
00:12:26.270 --> 00:12:30.112
现在，单是区块链上的智能合约就绝对令人难以置信。

121
00:12:30.112 --> 00:12:32.267
然而，它们也带来了一个巨大的问题。

122
00:12:32.267 --> 00:12:45.800
如果我们想让这些数字协议取代我们日常生活中的协议，它们可能需要来自现实世界区块链本身的数据，这些数据实际上无法与现实世界的数据进行交互，也无法读取或收听来自现实世界的数据。

123
00:12:45.800 --> 00:12:48.141
这就是所谓的甲骨文问题。

124
00:12:48.141 --> 00:12:51.933
这些区块链是确定的系统，它们是故意确定的。

125
00:12:51.933 --> 00:12:55.070
我们将在接下来的课程中更多地了解这是如何运作的。

126
00:12:55.070 --> 00:12:58.376
所以发生在他们身上的一切都发生在他们的小世界里。

127
00:12:58.376 --> 00:13:02.798
但如果要达成这些协议，就需要外部数据和外部计算。

128
00:13:02.798 --> 00:13:05.085
这就是甲骨文发挥作用的地方。

129
00:13:05.085 --> 00:13:10.772
Oracle的是任何向这些分散的区块链发送数据或运行外部计算的设备。

130
00:13:10.772 --> 00:13:22.542
然而，如果我们想让我们的应用程序保持真正的去中心化，我们就不能只使用一个Oracle、一个数据提供商或一个源来运行这些外部计算。

131
00:13:22.542 --> 00:13:25.095
所以我们需要一个去中心化的Oracle网络。

132
00:13:25.095 --> 00:13:36.439
类似于我们去中心化的区块链网络，你在链上的逻辑将是去中心化的，但你也需要你的链外数据和计算是去中心化的，结合链上的去中心化逻辑。

133
00:13:36.439 --> 00:13:43.340
有了这种下链，去中心化数据和去中心化计算产生了所谓的混合智能合约。

134
00:13:43.340 --> 00:13:51.692
我们现在使用的大多数最大的协议都是某种类型的混合智能合约或与混合智能合约交互。

135
00:13:51.692 --> 00:13:55.342
在某种程度上，这就是协议链接发挥作用的地方。

136
00:13:55.342 --> 00:14:09.786
它是一个模块化、去中心化的Oracle网络，可以将外部数据和外部计算引入我们的智能合约，以确保它们是端到端去中心化的，同时赋予它们协议所需的丰富特性。

137
00:14:09.848 --> 00:14:17.307
Chainlink允许我们获取数据进行维护，获取随机数或以任何有意义的方式定制我们的智能合约。

138
00:14:17.307 --> 00:14:20.794
在整个课程中，我们会用到智能合约这个术语。

139
00:14:20.794 --> 00:14:35.349
然而，每当我们说到智能合约时，我们通常会把它和混合智能合约互换使用，但要知道，当我们说到混合智能合约时，我们具体指的是具有某种链外组件的智能合约。

140
00:14:35.349 --> 00:14:44.148
现在，自从这些定理发布以来，许多不同的区块链或智能合约平台已经出现，如雪崩多边形、幻影和谐等。

141
00:14:44.148 --> 00:14:49.721
在本课程的大部分时间里，我们将假设我们将部署到以太坊网络。

142
00:14:49.721 --> 00:15:06.243
然而，我们在这里学到的一切都将适用于绝大多数的区块链，如多边形、雪崩、幻影和谐等，从理论和融资心理了解一切将给你所需的技能，你需要非常轻松地切换链，只需要一行代码。

143
00:15:06.243 --> 00:15:12.847
所以不要担心学习一种特定的工具或特定的链，因为它们大多数都可以无缝地结合在一起。

144
00:15:12.911 --> 00:15:16.477
现在，有几个智能合约平台不使用稳固性。

145
00:15:16.477 --> 00:15:20.602
但在这里学习基础知识也会让你在这些方面做得更好。

146
00:15:20.602 --> 00:15:26.082
到目前为止，以太坊拥有最多的锁定价值，是使用最多的区块链和智能合约平台。

147
00:15:26.082 --> 00:15:29.870
你也会听到这两个词交替使用。

148
00:15:29.928 --> 00:15:34.880
有时他们会说智能合约平台，有时他们会说区块链，意思差不多。

149
00:15:34.933 --> 00:15:40.495
显然，区块链可能意味着价值存储和智能合约平台，但你明白我的意思。

150
00:15:40.495 --> 00:15:47.237
同样，chainlink是最流行和最强大的去中心化Oracle网络，也是我们这门课的重点。

151
00:15:47.237 --> 00:15:50.002
Chainlink也是区块链不可知论者。

152
00:15:50.002 --> 00:15:55.779
所以在Aetherium, avalanche, Polygon Solana Terra或其他区块链上工作。

153
00:15:55.779 --> 00:16:03.673
在整个课程中，你会听到DAP或去中心化协议，或智能合约协议，或去中心化应用。

154
00:16:03.673 --> 00:16:06.001
它们的意思差不多是一样的。

155
00:16:06.001 --> 00:16:09.425
去中心化的应用程序通常是许多智能合约的组合。

156
00:16:09.425 --> 00:16:14.056
当我们讲到坚固性的时候，你会看到一个单一的智能合约是什么样子的。

157
00:16:14.056 --> 00:16:23.382
就像我说的，学习所有这些核心基础知识将使你成为一个更好的稳定性和更好的智能合约开发人员，在这个视频中你也会经常听到web 3这个术语。

158
00:16:23.382 --> 00:16:42.261
在这个行业中，web三是指区块链和智能合约是web的下一个迭代web一是指静态内容的无许可开源世界，web二是指动态内容的有许可的web，但所有的协议和逻辑都来自于控制你的信息的中央服务器。

159
00:16:42.261 --> 00:16:45.280
然后web 3又回到了无许可的web。

160
00:16:45.280 --> 00:17:04.052
但再一次，使用动态内容，而不是集中的服务器，运行你的逻辑，去中心化的网络，运行逻辑创建这些抵制审查的协议，这是智能合约所支持的通常也伴随着用户拥有他们使用的协议的想法，这是一种所有权经济。

161
00:17:04.102 --> 00:17:05.467
在这门课后面你会明白我的意思。

162
00:17:06.102 --> 00:17:12.051
很多关于这些协议和智能合约的历史和高水平，以及它们可以做什么。

163
00:17:12.103 --> 00:17:25.461
但这些智能合约到底意味着什么?我说的信任、最小化协议或牢不可破的承诺是什么?这些智能合约的真正增值是什么?在我们深入了解它之前，先来看看它是如何工作的。

164
00:17:25.461 --> 00:17:27.461
从技术角度来看。

165
00:17:27.461 --> 00:17:30.104
我们来看看这些的值是多少。

166
00:17:30.104 --> 00:17:40.044
我们开发所有这些技术的目的是什么?你修过这门课吗?这项技术解决了什么问题?在我看来，一项技术的好坏取决于它所解决的问题。

167
00:17:40.044 --> 00:17:52.507
如果它不能解决问题，那为什么还要去麻烦Mark合约，区块链web三种加密货币，这些都是不同的词，它们封装了我们在这样一个独特的范式中所做的事情的想法。

168
00:17:52.507 --> 00:17:58.794
我认为最简单的方法来总结这些智能合约的作用是，它们创建了信任最小化协议。

169
00:17:58.794 --> 00:18:01.202
如果你可能会挠头的话。

170
00:18:01.202 --> 00:18:06.650
一个简单得多的思考方式是，产生牢不可破的承诺。

171
00:18:06.650 --> 00:18:08.412
是的，你没听错。

172
00:18:08.412 --> 00:18:10.679
牢不可破的协议和承诺。

173
00:18:10.679 --> 00:18:16.076
此外，它们还提高了速度、效率和透明度，以及其他一些东西。

174
00:18:16.076 --> 00:18:19.339
我最近做了一个视频就是关于这个的。

175
00:18:19.339 --> 00:18:33.053
让我们来听听智能合约加密货币不可否认的价值的目的，从根本上重新定义我们所知道的市场和协议。

176
00:18:33.111 --> 00:18:37.268
不幸的是，你可能只听到过人们对空瓶子和钱的尖叫。

177
00:18:37.268 --> 00:18:42.094
现在，有些表情包是有趣的，但让我们忘记子弹，回到空间的本质。

178
00:18:42.094 --> 00:18:43.619
如果你已经在web 3了。

179
00:18:43.619 --> 00:18:49.620
这段视频可以发给你的朋友，解释你为什么对这个空间如此兴奋，解释我们为什么在这里。

180
00:18:49.620 --> 00:18:53.061
如果你不喜欢加密货币，那你就来对地方了。

181
00:18:53.113 --> 00:18:56.663
是的，有有趣的表情包和市场，还有一些与金钱有关的东西，所有这些东西。

182
00:18:56.663 --> 00:19:06.468
但在所有这些之外，区块链的目的与古老的小学牢不可破有关，承诺小指发誓，让我们得到青蛙。

183
00:19:06.468 --> 00:19:10.665
你在生活中所做的几乎每一件事都是协议或合同的结果。

184
00:19:10.665 --> 00:19:16.580
你的椅子是一个协议的结果，买卖木材组装，然后把椅子卖给一个真正的裁缝在亚马逊。

185
00:19:16.580 --> 00:19:19.325
然后你们达成协议，以40美元的价格买下这把椅子。

186
00:19:19.325 --> 00:19:47.704
你家里的灯是由电力驱动的，这是你和电力公司的协议你同意支付给他们作为回报他们会让灯继续亮着他们产生的电这是他们和建造涡轮机发电的工程师之间的协议你同意每个月付给他们一笔钱，作为回报，他们什么都不做或者我的意思是，他们会支付你的医疗费用，几乎你所做的每一件事，你与之互动的每一件事，都是某种形式的协议或契约在某些方面的结果。

187
00:19:47.704 --> 00:19:56.032
现在，协议和契约可能会让人觉得抽象和无聊，如果要真正理解和简化的话，我们也可以把它们称为承诺。

188
00:19:56.032 --> 00:19:57.309
当你换机油的时候。

189
00:19:57.309 --> 00:20:07.289
他们承诺会忠实地为你更换石油作为交换，当你把钱存入银行时，他们承诺保管好钱作为交换，他们会用你的钱发放贷款。

190
00:20:07.289 --> 00:20:14.201
当你买彩票的时候，彩票承诺给你一个公平的机会，让你买彩票来换取一大笔钱。

191
00:20:14.201 --> 00:20:16.604
当你达成这些协议的时候。

192
00:20:16.604 --> 00:20:21.630
在某种程度上，你是在要求他们小指发誓不欺骗你，公平地对待你。

193
00:20:21.630 --> 00:20:23.172
但这并不总是发生。

194
00:20:23.172 --> 00:20:32.075
让我们看看现实世界中有人打破小手指誓言的例子，早在80年代和90年代，麦当劳就开展了一项促销活动，让人们通过收集麦当劳的大富翁游戏卡来赢钱。

195
00:20:32.075 --> 00:20:33.027
这个想法很简单。

196
00:20:33.123 --> 00:20:36.748
你买麦当劳作为回报，就有机会赢得100万美元。

197
00:20:36.748 --> 00:20:54.999
你可以想象麦当劳会说嘿，大家，我保证如果你买我们的MC食品和麦乐鸡，我们会给你一个公平的机会赢得这笔钱，但我们最终打破了这个承诺，你没有一个公平的机会赢得这笔钱你的机会实际上在90年代中期是零。

198
00:20:54.999 --> 00:21:01.040
说实话，有1300万到2400万美元流入了那些不玩游戏的人的口袋。

199
00:21:01.040 --> 00:21:11.707
但一群腐败的内部人士操纵了游戏，这意味着当你在玩麦当劳的大富翁游戏时，你就相信了一系列的谎言和承诺，而这些谎言和承诺100%都会被打破。

200
00:21:11.707 --> 00:21:16.075
问题是，这到底是不是麦当劳的错并不重要。

201
00:21:16.127 --> 00:21:19.593
是他们做出了最终无法兑现的承诺。

202
00:21:19.593 --> 00:21:40.555
另一种思考方式是他们从你我那里偷走了2400万美元如果这个系统部署在区块链上是一种叫做智能合约的东西，它不可能欺骗这2400万美元因为智能合约是不可变的，去中心化的和透明的。

203
00:21:40.555 --> 00:21:42.630
但我马上就会回到这个问题上。

204
00:21:42.630 --> 00:21:51.951
在我们签订的所有协议和合同中，想象一下和一个10岁的孩子对着小指发誓，想象一下这个协议将如何执行。

205
00:21:51.951 --> 00:21:57.199
伙计，你能帮我保管好我的钱吗?如果你喜欢，你可以玩，但请在我回来的时候拿着它。

206
00:21:57.199 --> 00:21:57.819
立即。

207
00:21:57.819 --> 00:22:01.389
你可能会感到焦虑，可能会出问题。

208
00:22:01.389 --> 00:22:02.647
这个10岁的孩子可能会失去你的钱。

209
00:22:02.647 --> 00:22:13.775
你可能会想，我怎么能相信他们?他们是否会违背诺言，因为不值得信任的情况而感到无法呼吸?总是一次。

210
00:22:13.775 --> 00:22:27.607
我能相信这个二手车推销员给我一辆好车吗?我能相信这个写着可机洗的标签吗?还是会让我的衬衫缩水?我的保险公司会违背他们为我支付医疗费的承诺吗?我是帕特里克，他答应和我一起去远足。

211
00:22:27.607 --> 00:22:29.848
他，我真的会的。

212
00:22:29.848 --> 00:22:34.796
但我们目前的协议和合同的问题是，我们必须信任人民。

213
00:22:34.796 --> 00:22:36.902
我们让他们做正确的事。

214
00:22:36.902 --> 00:22:40.566
然而，他们经常被激励去做不正确的事情。

215
00:22:40.566 --> 00:22:42.539
保险公司不想赔钱。

216
00:22:42.539 --> 00:22:48.316
有时候销售人员只是想把东西从货架上拿下来，我答应和我的女朋友去远足。

217
00:22:48.316 --> 00:22:49.152
但我需要徒步旅行。

218
00:22:49.152 --> 00:22:50.427
其他地方也发生过。

219
00:22:50.427 --> 00:22:52.771
现在你可能会想，帕特里克，这看起来很酷。

220
00:22:52.771 --> 00:23:06.105
但这对我有什么影响?我们刚刚说过的麦当劳彩票在大萧条时期银行挤兑银行承诺保管好我们的钱当我们回去取钱的时候他们会把钱存在那里。

221
00:23:06.105 --> 00:23:13.863
当然，他们有时没有钱就像去年罗宾汉画了这幅神奇的画。

222
00:23:13.863 --> 00:23:26.663
在用户应用中，我们会给你进入市场的机会，我们承诺会给你一个与世界金融方面互动的公平机会，但不是这个资产。

223
00:23:26.663 --> 00:23:41.521
这个资产，这个资产还是这个资产，2008年的金融危机还记得关起门来的黑幕交易加上关于金融产品的谎言让世界经济陷入困境吗，你好吗?津巴布韦的恶性通货膨胀，巴西的恶性通货膨胀，有道理。

224
00:23:41.521 --> 00:23:50.318
美国的历史是一个无情的教训，值得信任的实体是臭名昭著的守信用者，我们终于有办法用智能合约来解决这个问题。

225
00:23:50.318 --> 00:24:02.318
现在，在我开始讲智能合约之前，很多人可能会想，嘿，总之很酷，但是，我们有适当的系统来防止这些事情，这是真的，这是伟大的。

226
00:24:02.318 --> 00:24:04.409
这是向前迈出的非常有益的一步。

227
00:24:04.409 --> 00:24:07.644
但是这些系统经常会崩溃2008年的系统就没起作用。

228
00:24:07.644 --> 00:24:10.525
有罗宾汉危机的那些肯定不起作用。

229
00:24:10.525 --> 00:24:22.178
即使这些制度适用，你去法庭试图解决它们，也许在你真正看到解决方案之前，你要在法庭上待上好几年，到那时，你需要钱的时间就更长了。

230
00:24:22.178 --> 00:24:33.294
那么这项技术是什么呢?这个工具能解决我们今天协议中的基本问题，这个工具就是智能合约区块链就是为这个工具而建的。

231
00:24:33.294 --> 00:24:36.794
现在，我将快速概述什么是智能合约。

232
00:24:36.794 --> 00:24:48.880
不过，我在描述中留下了一些链接，以便进行更深入的解释，但它们的基本内容是，智能合约是部署在去中心化区块链上的协议合约或一组指令。

233
00:24:48.880 --> 00:24:58.229
一旦部署了合同或指令集，它就不能被更改，它会自动执行，每个人都可以看到协议的条款。

234
00:24:58.229 --> 00:25:05.537
它真正的基础是代码是由分散的集体执行的，就像一群人，但一群人运行某种软件。

235
00:25:05.537 --> 00:25:13.265
这意味着任何个人或实体实际上都不能改变这些协议或改变这些传统协议中的安排条款。

236
00:25:13.265 --> 00:25:19.954
谁拥有合同，谁拥有合同的执行权，谁就可以按下开关，说，我们不会再那样做了。

237
00:25:19.954 --> 00:25:24.283
在智能合约和区块链中的web 3中，你再也不能这样做了。

238
00:25:24.283 --> 00:25:32.102
通常，这些智能合约位于去中心化的区块链上，并与去中心化的Oracle网络结合使用，以获取真实世界的资产和信息。

239
00:25:32.153 --> 00:25:36.645
如果这些话听起来像我在变出一个魔法咒语，那么，再一次，检查描述中的链接。

240
00:25:36.645 --> 00:25:38.586
如果您想了解更多关于技术含义的信息。

241
00:25:38.586 --> 00:25:48.106
如果你不是技术人员，那么你对细节不感兴趣，你可以把它想象成HTTPS，我打赌你们中的绝大多数人甚至不知道HTTPS代表什么。

242
00:25:48.154 --> 00:25:51.547
但你每天只要一上网就会用到它。

243
00:25:51.547 --> 00:26:04.850
那么这将如何解决麦当劳的大富翁问题呢?在传统的彩票形式中，彩票是关起门来执行的，有人操作并拥有彩票的代码，合同和协议，他们有权修改它。

244
00:26:04.850 --> 00:26:10.106
除了彩票公司内部的人，没有人能审计这种变化的发生。

245
00:26:10.156 --> 00:26:18.532
如果这个彩票的代码被部署到区块链上，每次黑客试图修改它，所有人都会收到通知。

246
00:26:18.532 --> 00:26:22.931
不仅如此，你甚至不能更改它，因为智能合约的条款不能更改。

247
00:26:22.931 --> 00:26:28.965
一旦部署，将该智能合约与链链接VRF Oracle结合起来，得到一个可验证的随机数。

248
00:26:28.965 --> 00:26:44.004
很快，你就有了一个完全去中心化的，不可改变的协议，不可能被黑，欺诈或操纵我们刚刚通过解决信任问题为公众节省了13,000,020万美元。

249
00:26:44.004 --> 00:26:48.124
这将如何解决罗宾汉的问题?罗宾汉的问题已经解决了。

250
00:26:48.160 --> 00:26:56.193
对吧?问题是，有一个中央机构可以在任何时候拨动开关，说你不能再进入这些市场了。

251
00:26:56.193 --> 00:26:59.906
我们违背了让你进入市场的承诺。

252
00:26:59.906 --> 00:27:02.961
这个问题已经通过去中心化交易解决了。

253
00:27:02.961 --> 00:27:07.099
现在已经有了，其中一个交换叫做uniswap。

254
00:27:07.162 --> 00:27:13.012
你可以交换ERC 20代币，它相当于股票，但有些是有些是，有点让人困惑。

255
00:27:13.012 --> 00:27:14.250
这个我也不讲了。

256
00:27:14.250 --> 00:27:19.538
但它没有一个中央集权的机构，可以拨动开关，破坏市场准入。

257
00:27:19.538 --> 00:27:29.634
如果这些投资者是在一个去中心化的交易所，这将为他们节省数亿美元，并将防止欺诈性的市场操纵。

258
00:27:29.634 --> 00:28:03.761
如何用内置在自动偿付能力检查中的透明度来解决银行的运行问题，你可以建立一个像智能合约一样的银行，它内置了偿付能力检查，这样就不可能到达那里，解决它意味着经纪人任何协议或任何历史教训，当信任假设被打破时，智能合约可以被应用，也应该被应用，特别是在一个大钱运行，拥有和控制一切的时代，我们迫切需要进入这样一个世界，在这个世界里，一些自私自利的中心化实体不能随意拨动开关，破坏人们获得所需服务的途径。

259
00:28:03.761 --> 00:28:08.652
我们可以从一个以品牌为基础的世界转移到一个以数学为基础的世界。

260
00:28:08.652 --> 00:28:19.620
现在，如果你与一个你不喜欢的服务互动，或者他们违背了他们的承诺，你唯一能做的就是走到街上的下一个服务，它会做出同样的承诺。

261
00:28:19.620 --> 00:28:28.170
你必须希望和祈祷他们真的会保留它。我们可以从那种情况发展到另一个世界，我们可以看着地图说，哦，好吧，一加一等于二。

262
00:28:28.170 --> 00:28:40.949
这就是这个协议将为我做的每一次保证，因为它是一个去中心化的自主代理没有动机去作恶，所有事情都是透明的，在一个大公司的公开。

263
00:28:40.949 --> 00:28:51.120
如果1 + 1 = 3对我来说更好的话，我可能会关起门来，大量输入一些数字，然后回来，用智能合约说，嘿，1 + 1 = 3。

264
00:28:51.172 --> 00:28:52.324
这是不可能的。

265
00:28:55.173 --> 00:29:08.124
现在，在两个协议之间做选择，一个是你必须信任一个集中的实体相信他们会为你做正确的事，另一个是去中心化的未被篡改的双集体，你会选择哪个。

266
00:29:08.124 --> 00:29:11.596
我要选一个不能每次都耍我的人。

267
00:29:11.596 --> 00:29:26.496
对于我所能应用的每一项协议，这项技术都是相对较新的，但我们已经看到它重塑了整个市场，并在继续这样做，传统的金融世界已经被反金融或去中心化的金融吃掉了。

268
00:29:26.496 --> 00:29:35.531
在这些协议中，已经有超过2000亿美元的资金用于帮助建立一个更公平、更负责、更透明的金融体系。

269
00:29:35.531 --> 00:29:43.034
这种反抗运动是我进入这个领域的主要原因之一，因为我们迫切需要离开我们现在的状态。

270
00:29:43.034 --> 00:29:51.146
人们获得财富的机会被某些群体吞噬了他们为了自己的利益而扭曲规则智能合约是我们通往更美好世界的门票。

271
00:29:51.146 --> 00:30:06.111
越来越多的行业也开始使用智能合约和区块链因为所有的创新和它的优势随着我们的发展和进步我们越来越接近实现这个概念的愿景，信任最小化协议。

272
00:30:06.180 --> 00:30:12.581
这些智能合约正在将我们需要给予他人的信任最小化，以使这些协议得以执行。

273
00:30:12.581 --> 00:30:16.948
如果信任最小化协议对你来说太困惑了，那就说不可打破的承诺。

274
00:30:16.948 --> 00:30:18.961
现在我得跟你们说实话了。

275
00:30:18.961 --> 00:30:23.708
区块链、智能合约和加密货币实际上可以做的不仅仅是信任、最小化协议。

276
00:30:23.708 --> 00:30:28.420
它们有安全方面的好处、正常运行时间方面的好处、执行方面的好处、速度方面的好处等等。

277
00:30:28.420 --> 00:30:31.445
但是先学一个再学其他的要容易得多，对吧。

278
00:30:31.445 --> 00:30:33.287
就像洒在上面的糖屑。

279
00:30:33.287 --> 00:30:34.532
这就是我们在这里的原因。

280
00:30:34.532 --> 00:30:41.990
这就是为什么我们要建设这样的未来，这就是为什么我们对此如此兴奋。

281
00:30:42.184 --> 00:30:45.917
即使只是在介绍部分，我们也学到了很多东西。

282
00:30:46.184 --> 00:30:48.748
让我们快速总结一下目前所学到的内容。

283
00:30:49.184 --> 00:31:02.501
比特币是一种数字黄金或一种价值存储方式，能够在用户之间以去中心化的方式进行交易。

284
00:31:02.501 --> 00:31:20.224
Aetherium和其他智能合约平台将区块链技术进一步推进，使人们能够制定智能合约和去中心化信任最小化协议，智能合约和去中心化应用程序可以使用所谓的去中心化Oracle网络访问和与现实世界交互。

285
00:31:20.224 --> 00:31:43.555
链链是一个去中心化的网络，它允许我们构建这些混合智能合约，它将链上逻辑与链下逻辑、去中心化数据和去中心化计算结合起来，使我们的逻辑完全去中心化，我们的数据和外部计算也完全去中心化，使我们拥有传统协议和传统合约的所有特征。

286
00:31:43.555 --> 00:31:46.567
现在像Aetherium和比特币这样的数字货币有了价值。

287
00:31:46.567 --> 00:32:01.546
即使没有智能合约部分，拥有一个抗审查的去中心化价值存储本身自然是强大的，我们在GitHub存储库中有一些链接，将教你这种去中心化价值存储如何颠覆传统金融。

288
00:32:01.546 --> 00:32:04.159
这也是构建智能合约的另一个重要原因。

289
00:32:04.192 --> 00:32:09.971
但同样，最简单的方法是信任最小化协议，或不可打破的承诺。

290
00:32:09.971 --> 00:32:14.520
但我们也来看看智能合约相比传统环境的其他一些特性。

291
00:32:14.520 --> 00:32:17.614
当然，第一个特征是它们是分散的。

292
00:32:17.614 --> 00:32:23.481
它们没有中央中介，运行这些区块链的不同个体被称为节点操作员。

293
00:32:23.481 --> 00:32:33.304
它是所有这1000个节点操作员的组合运行相同的软件运行这些算法运行这些智能合约使网络分散。

294
00:32:33.304 --> 00:32:35.782
我们将在后面深入研究它是如何工作的。

295
00:32:35.782 --> 00:32:40.775
下一个特点是这些去中心化网络的透明度和灵活性。

296
00:32:40.775 --> 00:32:49.786
因为所有这些单独的节点操作员运行软件，每个人都能看到链上发生的一切，这意味着没有黑幕交易，没有奇怪的事情发生。

297
00:32:49.786 --> 00:32:59.797
任何不公平的东西，人们都能看到，但不用，每个人都有完整的信息，必须遵守同样的规则。

298
00:32:59.797 --> 00:33:10.674
另外，这并不意味着没有隐私，区块链是伪匿名的，这意味着你在现实生活中不一定与某个身份挂钩，它们也有速度和效率的特点。

299
00:33:10.674 --> 00:33:21.708
对于那些曾经尝试过通过银行转账或跨海汇款的人来说，你知道，这有时需要两到三周的时间，而实际上，所有这些银行真正做的只是基本的数学运算。

300
00:33:21.708 --> 00:33:26.819
他们从你的结余中减去钱然后把它加到其他结余中。

301
00:33:26.819 --> 00:33:31.733
为什么要花这么长时间，在区块链中，所有的交易都是瞬间发生的。

302
00:33:31.733 --> 00:33:37.867
另一个例子是，今天在金融界工作的人都知道，清算所和结算日可能需要很长时间。

303
00:33:37.867 --> 00:33:42.154
在区块链中，不需要这些，因为它们是瞬间发生的。

304
00:33:42.202 --> 00:33:48.155
这显然要快得多，但它也使彼此之间的交互更加有效，安全和不可变。

305
00:33:48.202 --> 00:33:51.284
同样，不可变意味着它不能被改变。

306
00:33:52.203 --> 00:33:59.940
契约被部署了，就是这样，无论代码中有什么都将永远存在于代码中，它们不能以任何方式被修改或篡改。

307
00:33:59.940 --> 00:34:02.104
这意味着安全性要容易得多。

308
00:34:02.204 --> 00:34:07.865
而在一个中心化的世界里，有人可以黑进服务器，跳进数据库，改变一些数字。

309
00:34:07.865 --> 00:34:09.600
你在区块链的世界里做不到。

310
00:34:09.600 --> 00:34:20.439
由于它是去中心化的，为了黑进区块链，你必须接管一半的节点，而在中心化的世界里，你只需要接管一个普通的节点。

311
00:34:20.439 --> 00:34:24.539
如果你的电脑和备份电脑都坏了，你所有的数据都没了。

312
00:34:24.539 --> 00:34:34.557
在区块链的世界里，如果你的电脑和备份电脑瘫痪了，你所有的数据都是安全的，因为它们是在所有这些分散的节点上运行的。

313
00:34:34.557 --> 00:34:38.400
即使有100个节点或者1000个节点宕掉。

314
00:34:38.400 --> 00:34:50.563
这并不重要，因为只要一个节点拥有区块链的副本，就可以轻松入侵区块链，这几乎是不可能的，而且比入侵集中式服务器要困难得多。

315
00:34:50.563 --> 00:34:54.099
不仅如此，从资产的角度来说，这也更安全。

316
00:34:54.099 --> 00:34:59.405
所有您需要访问您的凭证和您资产中的信息的是您的私钥。

317
00:34:59.405 --> 00:35:02.618
这基本上就是你所有这些的密码。

318
00:35:02.618 --> 00:35:12.600
正如我们在视频中讨论的，智能合约消除了交易对手风险，消除了集中式中介，消除了我们在web 2中必须做的信任网关。

319
00:35:12.600 --> 00:35:23.703
当我们与用户和个人接触时，他们并不总是把我们的最佳利益放在心上智能合约，消除了交易对手的风险，因为一旦这些合约被创建，他们不能进入也不能修改它。

320
00:35:23.703 --> 00:35:28.899
他们不能让贪婪、自负或其他任何东西占了上风，改变协议的条款。

321
00:35:28.899 --> 00:35:35.503
就像我们说的，这就产生了信任最小化协议或者是不可打破的计划承诺。

322
00:35:35.503 --> 00:35:53.846
我们从基于品牌的协议转移到基于数学的协议，我们可以研究密码学，可以直接研究代码，并确切地知道某些东西将会做什么，以及它将如何执行，而不是必须依赖人类用智能合约和去中心化混合智能合约做正确的事情。

323
00:35:53.846 --> 00:36:11.904
做正确的事是基础设施所有这些都归结为我们可以自由地以我们想要的方式互动而不必担心这样的互动会毁了我们的信任最小化的部分，这些不可打破的承诺，让互动变得更好。

324
00:36:11.904 --> 00:36:21.694
在一个纯web - two的世界里，我们不断被项目和协议的信息轰炸，迫使我们朝着更有利可图的方向前进或行动。

325
00:36:21.694 --> 00:36:25.237
与智能合约相比，我们可以透明地看到一切。

326
00:36:25.237 --> 00:36:33.589
我们甚至可以参与互动成为协议和互动的部分所有者我们决定要成为其中的一部分。

327
00:36:33.589 --> 00:36:39.695
智能合约已经出现几年了。

328
00:36:39.695 --> 00:36:53.721
由于这些智能合约平台的出现，它们为哪些行业带来了什么?你可能听说过其中一些我们已经提到过，但让我们快速复习一下，d d代表去中心化金融。

329
00:36:53.721 --> 00:36:59.484
它让用户能够与金融和市场打交道，而不必经过一个集中的中介。

330
00:36:59.484 --> 00:37:09.052
例如，就像我们说的，有了罗宾汉，你不再需要相信罗宾汉会继续让你进入市场，相反，你可以在智能合约中看到。

331
00:37:09.052 --> 00:37:12.409
是的，我在2008年的金融危机中还是进入了市场。

332
00:37:12.409 --> 00:37:17.889
你永远不需要相信这些团体和机构在后台会给你正确的东西。

333
00:37:17.889 --> 00:37:29.442
你可以在区块链上透明地看到一切，你可以在记录的时候轻松、有效、安全地接触货币市场和复杂的金融产品。

334
00:37:29.442 --> 00:37:34.587
德飞管理的资产约为2,000亿美元，而且还在快速增长。

335
00:37:34.587 --> 00:37:40.744
如果你真的对defy感到兴奋，我们有大量的defy示例向你展示如何构建和与这些协议交互。

336
00:37:40.744 --> 00:37:41.782
在接下来的课程中。

337
00:37:41.782 --> 00:37:43.051
Dows或去中心化。

338
00:37:43.226 --> 00:37:46.716
自治组织是我们已经提到过的另一个组织。

339
00:37:46.716 --> 00:37:52.734
Dows是由链上的一组指令或智能合约完全去中心化管理的组。

340
00:37:52.734 --> 00:37:56.678
这有一些巨大的好处，让参与变得更容易。

341
00:37:56.678 --> 00:37:57.645
规则是非黑即白的。

342
00:37:57.645 --> 00:38:10.657
你可以直接在连锁投票和区块链空间中完全去中心化的治理技术上看到一切，这是推动我们如何发展政治和如何发展治理使其更有效，公平和合理的重要因素之一。

343
00:38:10.657 --> 00:38:15.990
你最好知道它，我们有一些例子，如何建立Dows和如何与Dows来的教训工作。

344
00:38:15.990 --> 00:38:27.622
所以一定要关注那些NF T的斯坦福不可替代代币，它们真的可以被描述为数字艺术或只是一种独特的资产，它们可以做更多，但我们现在将保持它的高水平。

345
00:38:27.622 --> 00:38:35.431
像董事会猿和加密朋克这样的项目彻底改变了人们获得工作报酬的方式，展示他们的创造力、地位和其他很多东西。

346
00:38:35.431 --> 00:38:45.477
是的，当然，我们也有课程向你展示如何创造和与NF - T的互动，如此多的其他团体和如此多的其他行业正因为这个疯狂的技术而被创造出来。

347
00:38:45.477 --> 00:38:55.648
也许在这里和我们一起结束旅程后，你们走出去，你们将成为下一个行业或下一个数十亿美元的想法的先驱，你们已经学到了很多。

348
00:38:55.648 --> 00:39:06.934
但是现在我们已经了解了很多高级信息，让我们最后开始，让我们进行第一次交易让我们准备好与这个新世界进行交互。

349
00:39:06.934 --> 00:39:15.409
在下一节中，我们将为您准备一个钱包，并向您展示交易到底是什么样子和感觉。

350
00:39:15.409 --> 00:39:17.186
让我们开始吧。

351
00:39:17.186 --> 00:39:21.350
这是Aetherium网站Aetherium。

352
00:39:21.350 --> 00:39:28.736
我们将在一个测试Aetherium区块链上进行交易，我会稍微解释一下这是什么意思。

353
00:39:28.736 --> 00:39:32.374
这将是区块链上的第一笔交易。

354
00:39:32.374 --> 00:39:41.796
现在，我们将遵循的这个过程将与多边形、雪崩幻影和所有其他与EVM兼容的区块链完全相同。

355
00:39:41.796 --> 00:39:43.932
我稍后也会解释这是什么意思。

356
00:39:43.932 --> 00:39:49.327
现在，只要跟着做，在这些区块链上进行交易就可以了。

357
00:39:49.327 --> 00:39:53.931
我们要做的第一件事是建立一个钱包。

358
00:39:53.931 --> 00:40:01.419
我要选择meta mask因为它是最受欢迎的钱包之一也是最容易使用的钱包之一，我们要下载它。

359
00:40:01.419 --> 00:40:06.901
我用的是brave浏览器，但它适用于Chrome、Firefox或其他任何浏览器。

360
00:40:06.901 --> 00:40:12.016
它只是浏览器右上角的一个小扩展。

361
00:40:12.016 --> 00:40:19.346
通过这种方式，我们可以在任何时候轻松地看到我们钱包里的货币，仍然是基于Aetherium的货币。

362
00:40:19.346 --> 00:40:25.592
我要为brave安装meta mask，添加到brave，添加扩展。

363
00:40:25.592 --> 00:40:35.105
现在我们可以开始与Brave合作了，这是你在开始你的旅程时绝对需要采取的第一步，也是最容易采取的步骤之一。

364
00:40:35.105 --> 00:40:36.734
所以我们要开始了。

365
00:40:36.734 --> 00:40:39.891
我们将创造一种全新的钱包。

366
00:40:39.891 --> 00:40:41.692
我们会点击创建钱包。

367
00:40:41.692 --> 00:40:50.044
如果你已经有了一个钱包，你可以通过我有一个种子短语来导入它，我们稍后会讨论种子短语或秘密短语。

368
00:40:50.044 --> 00:40:52.844
让我们继续创建一个新的钱包。

369
00:40:52.844 --> 00:40:59.148
当然，我们会同意帮助超掩模现在我们会创建我们的密码确保它是安全的。

370
00:40:59.148 --> 00:41:02.987
在这个演示中，我的密码就是密码。

371
00:41:02.987 --> 00:41:05.229
但请不要把它作为你的密码。

372
00:41:05.229 --> 00:41:08.633
你也可以通过这样的视频了解你的秘密恢复短语。

373
00:41:08.633 --> 00:41:11.278
这和你的肺炎是一样的。

374
00:41:11.278 --> 00:41:14.983
但是看看你的恢复短语，你会更清楚它是什么。

375
00:41:14.983 --> 00:41:19.591
再一次，他给了我们很多不同的关于如何储存和保护它的建议。

376
00:41:19.591 --> 00:41:24.041
我想说的是永远不要分享这个，绝对不要分享这个。

377
00:41:24.041 --> 00:41:27.903
我们继续，点击显示暗语。

378
00:41:27.903 --> 00:41:32.048
我在这里给你们看，因为这只是一个演示，我并不在乎。

379
00:41:32.048 --> 00:41:38.827
但是，如果您将这个秘密短语显示给其他人，他们将有权访问您的申请中的所有资金。

380
00:41:38.827 --> 00:41:46.020
这一课我们要做的是，我们要用假币，我们要用非真钱，所以没关系。

381
00:41:46.020 --> 00:41:53.573
现在为了测试和开发的目的，我总是建议使用一个完全独立的元掩码，一个完全独立的钱包。

382
00:41:53.573 --> 00:42:06.216
在整个课程中，如果你已经有了一个钱包，或者你已经有了一个元掩码，请新建一个，新建一个配置文件，新建一个元掩码，这将是你在整个课程中使用的钱包。

383
00:42:06.252 --> 00:42:10.690
然而，如果你真的要把钱放在这里，你绝对需要把它写下来。

384
00:42:10.690 --> 00:42:19.318
因为如果你失去了访问这个的权限，以及你所有的私钥，我们稍后会讲到，你将失去访问你的钱包的权限，你将失去访问你所有资金的权限。

385
00:42:19.318 --> 00:42:40.058
所以他们给一些建议存储这个短语和密码管理器就像一个密码,把这句话写在一张纸上,把它放在一个安全的位置,记住它,无论你想做什么,只要确保你有一个备份,我只是点击下载这个,这不是最佳实践保存到你的电脑,最好是使用密码管理器或把它写在一张纸上。

386
00:42:40.058 --> 00:42:42.492
所以我们要继续下一个。

387
00:42:42.492 --> 00:42:47.927
它会要求我们验证我们是否真的把它写下来了。

388
00:42:47.927 --> 00:42:52.725
我们继续点击确认，很好，他给了我们一些其他的建议。

389
00:42:52.725 --> 00:42:57.843
记住，一定要认真对待这些建议，特别是如果你打算用它来赚真金白银的话。

390
00:42:57.843 --> 00:43:00.835
就像我说的，对于这个演示，我们将使用测试资金。

391
00:43:00.835 --> 00:43:02.348
所以这没什么大不了的。

392
00:43:02.348 --> 00:43:10.758
但如果你投入了真正的钱，你绝对需要备份这个种子短语或秘密短语否则我们将把它称为肺炎短语。

393
00:43:10.758 --> 00:43:11.158
太棒了。

394
00:43:11.258 --> 00:43:15.868
现在我们可以看到我们钱包的界面在这里全屏显示。

395
00:43:16.259 --> 00:43:36.209
根据你的浏览器，你可以把它固定在你的浏览器上你可以点击它在右上角，它会下拉，你可以看到相同的界面我们的肺炎短语那个秘密短语，他们给我们的秘密12个单词让我们进入一个新账户，我们的账户地址就在这里。

396
00:43:36.261 --> 00:43:49.612
实际上，如果我们点击它，把它复制到剪贴板上，然后找到一个叫以太扫描的块资源管理器，我们可以把我们的地址粘贴到这里，查看我们账户的详细信息。

397
00:43:49.612 --> 00:43:52.631
以太扫描，就像我说的，就是所谓的块浏览器。

398
00:43:52.631 --> 00:43:58.339
它是一种查看不同地址的交易和发生在区块链上的其他事件的方法。

399
00:43:58.339 --> 00:44:06.197
如果我们看一下我们刚刚在以太扫描以太主网上创建的地址，我们可以看到没有交易发生。

400
00:44:06.264 --> 00:44:22.511
没有分析，没有评论，没有平衡，没有价值，因为这是一个全新的钱包，我们刚刚输入以太扫描的地址代表我们唯一的地址我们唯一的钱包只能被我们识别。

401
00:44:22.511 --> 00:44:33.097
我们会再多讲一点以太扫描因为它是我们在钱包中经常使用的工具比如元掩码，你甚至可以点击这里创建更多的账户。

402
00:44:33.097 --> 00:44:36.608
让我们继续创建一个新帐户。

403
00:44:36.608 --> 00:44:41.017
我们称这个账户为2。

404
00:44:41.267 --> 00:44:43.750
如你所见，这个有不同的地址。

405
00:44:44.268 --> 00:44:47.493
点击这个，我们回到以太扫描。

406
00:44:49.268 --> 00:44:49.719
在这里。

407
00:44:49.719 --> 00:44:50.557
我们按回车键。

408
00:44:53.269 --> 00:44:55.869
唯一能被我们识别的，就在这里。

409
00:44:57.269 --> 00:45:05.746
没有价值，没有交易如果我们回到Metamask，点击这个小按钮，我们可以看到这里有两个不同的账户，是一样的。

410
00:45:05.746 --> 00:45:11.879
如果我们点击右上角的扩展，点击按钮，我们有两个不同的帐户。

411
00:45:11.879 --> 00:45:19.660
12字秘密恢复短语允许我们创建多个帐户，所有与相同的秘密恢复短语。

412
00:45:19.660 --> 00:45:33.415
这个秘密恢复短语会让我们访问账号1和账号2以及通过点击create account按钮创建的任何其他账号，因为它让你访问元掩码中的所有账号。

413
00:45:33.415 --> 00:45:44.416
我们两个账户的地址都是公开的唯一标识符，但它们也有一个只有我们可以识别的私人唯一标识符。

414
00:45:44.416 --> 00:45:55.024
类似于肺炎，这些是私人标识符我们不想分享也不想泄露他们的私人信息这就是你的账户私钥。

415
00:45:55.024 --> 00:46:10.534
助记符会让你访问多个账户，私钥只让你访问其中一个账户，点击这三个小点就能看到，进入账户详情，导出私钥，你只需要在这里输入密码。

416
00:46:10.534 --> 00:46:13.292
你就能看到你的私钥。

417
00:46:13.292 --> 00:46:22.623
这是你账户的私钥，你可以把私钥想象成你账户的密码，用来创建交易。

418
00:46:22.623 --> 00:46:27.228
我之所以在屏幕上显示我的钱是因为我不会在这里放真钱。

419
00:46:27.228 --> 00:46:30.563
这将是本教程的一次性账户。

420
00:46:30.563 --> 00:46:36.985
我再次强烈建议，你使用一次性账户，你使用的账户，你从来没有存入任何真正的钱。

421
00:46:36.985 --> 00:46:41.326
在此过程中，我将向你展示如何确保你不会那样做。

422
00:46:41.326 --> 00:46:53.205
但通常情况下，展示或分享你的私钥或你的秘密恢复短语不是一个好主意，如果有人得到了这个私钥，他们就能访问我的账号1。

423
00:46:53.281 --> 00:47:01.789
但是，他们无法进入我的账户如果他们拿到了我的12字康复词组或者肺炎他们就能进入两个账户。

424
00:47:01.789 --> 00:47:13.088
这就是为什么当人们说保管好你的私钥，你的比特币，你的密钥，你的Aetherium，他们说的是你的助记术或秘密恢复短语。

425
00:47:13.088 --> 00:47:18.444
你的私钥是私有的，你的公共地址是完全公开的。

426
00:47:18.444 --> 00:47:23.133
任何人都可以通过以太扫描或其他方式查看你的账户。

427
00:47:23.133 --> 00:47:26.348
人们分享他们的公共地址是完全可以的。

428
00:47:26.348 --> 00:47:29.735
如果您丢失了私钥，您将失去对其中一个帐户的访问权限。

429
00:47:29.735 --> 00:47:33.704
如果你失去了助记功能，你可能会失去访问所有账户的权限。

430
00:47:33.704 --> 00:47:42.737
基本上，我想说的是把它们备份起来，放在安全的地方，因为这门课你丢了也没关系，因为我们不会往里面投真钱。

431
00:47:42.737 --> 00:47:44.630
但在现实世界中，一定要这样做。

432
00:47:44.630 --> 00:47:44.974
和伟大的。

433
00:47:44.974 --> 00:47:47.176
这些都是主要的安全考虑因素。

434
00:47:47.176 --> 00:47:57.429
现在，如果你看右上方，就在我们点击的帐户按钮旁边，你会看到这个东西写着以太主网，这是我们的网络选项卡。

435
00:47:57.429 --> 00:48:07.158
如果我们点击它，我们可以看到一个列表，上面有我们目前可以访问的所有不同的网络，一个以太主网就是以太的主网。

436
00:48:07.158 --> 00:48:11.196
这是真正的钱被花费和用于交易的地方。

437
00:48:11.196 --> 00:48:17.592
在这门课上，我们不会使用以太主网，我们会使用一个叫做测试网的东西。

438
00:48:17.592 --> 00:48:25.401
因为我们是工程师，我们经常想要测试，看看我们的代码实际上要做什么，以及如何与它交互。

439
00:48:25.401 --> 00:48:32.725
我们将结合使用本地网络和测试网络来测试我们的智能合约。

440
00:48:32.725 --> 00:48:34.709
我们将主要使用本地网络。

441
00:48:34.709 --> 00:48:45.046
但我们会讲到这点，看看一些测试网络默认带有元掩码，我们点击show / hide测试网络，这将带我们进入设置页面。

442
00:48:45.046 --> 00:48:48.050
我们点击选择这个来显示列表中的测试网络。

443
00:48:48.050 --> 00:48:55.467
我们点击现在，如果我们向上滚动，我们会关闭设置，我们再次点击网络选项卡。

444
00:48:55.467 --> 00:49:01.682
现在我们可以看到所有其他的网络，如ropsten, Koven, Rinkeby和Garelli。

445
00:49:01.682 --> 00:49:09.372
这些测试网络或网络类似于Aetherium，或polygon，或Avalanche或phantom或任何其他区块链。

446
00:49:09.372 --> 00:49:13.169
我们可以把我们的账户切换到其他的测试网络。

447
00:49:13.169 --> 00:49:18.095
例如，我们点击溜冰场B，我们可以在Rinkeby测试网络上看到它。

448
00:49:18.095 --> 00:49:24.224
我们也没有Aetherium我们这里没有钱或者什么都没有，我们有一个空白的Rinkeby钱包。

449
00:49:24.224 --> 00:49:30.542
这些测试网的工作方式与Aetherium的主网络几乎相同，除了它们不是用真钱运行。

450
00:49:30.542 --> 00:49:38.916
他们使用假币作为一种学习和互动的方式，让我们看到这些不同的智能合约在拍摄时是如何一起工作的。

451
00:49:38.916 --> 00:49:43.035
溜冰场B和新冠病毒一样是最受欢迎的测试网络之一。

452
00:49:43.035 --> 00:50:00.594
然而，在本教程中，一定要检查我们的GitHub存储库，以确保你总是跟上最好的测试网络，因为他们的测试网络是人们出于好心运行的。

453
00:50:00.594 --> 00:50:05.574
有时候最好的版本会改变，所以一定要跟随GitHub仓库。

454
00:50:05.574 --> 00:50:09.610
我们有时也会使用COVID，或者甚至使用Grilli。

455
00:50:09.610 --> 00:50:12.490
我们将向你们展示如何使用这些不同的测试网。

456
00:50:12.490 --> 00:50:19.651
事实上，如果我们去到与这门课程相关的GitHub回购，我们可以看到推荐测试网确实是当前排名。

457
00:50:19.651 --> 00:50:25.252
这就是我们要做的，如果这个改变了，你们应该能跟上另一个测试。

458
00:50:25.302 --> 00:50:27.349
我们会留下关于如何继续的笔记。

459
00:50:28.302 --> 00:50:40.793
我们可以去里格比以太扫描，我们可以去，你可以去，林库以太扫描，它似乎是第一个出现在林克比点以太扫描上的东西。

460
00:50:40.793 --> 00:50:46.123
伊奥，我们可以输入相同的地址，复制粘贴。

461
00:50:46.123 --> 00:50:50.526
我们可以在林克比以太扫描上看到这个地址的一些细节。

462
00:50:50.526 --> 00:50:52.915
就像我说的，现在，它完全空白。

463
00:50:52.915 --> 00:51:00.680
这个网络接口稍后也是我们如何能够与多边形，雪崩等，我们只需要添加网络。

464
00:51:00.680 --> 00:51:02.133
但我们一会儿就会讲到。

465
00:51:02.133 --> 00:51:10.368
重申一下，测试网是免费的，用于测试我们的智能合约和主网需要花钱，而且被认为是实时的。

466
00:51:10.368 --> 00:51:17.612
现在我也想在这里提出一个警告，我们要记住，这些测试网是为了人们的心的善良而运行的。

467
00:51:17.612 --> 00:51:21.671
所以我们不想滥用它们，我们想利用它们来学习，然后继续前进。

468
00:51:21.671 --> 00:51:25.240
所以尽量不要在这些测试网络上发送十亿次交易。

469
00:51:25.240 --> 00:51:31.325
事实上，我们现在要做的是在Rinkeby测试网上发送一个交易。

470
00:51:31.325 --> 00:51:35.176
这将向我们展示它在主网上是什么样子的。

471
00:51:35.176 --> 00:51:40.697
为了让我们模拟其中的一个交易，我们要用到一个叫做水龙头的东西。

472
00:51:40.697 --> 00:51:55.214
如果你去和这门课相关的GitHub存储库，在推荐测试网的下面会有一个测试网水龙头，它会告诉我们最新的水龙头位置在哪里我们可以得到测试网Aetherium。

473
00:51:55.214 --> 00:52:07.921
这里是faucets。chain。link，这也是推荐的水龙头，我们可以把钱包地址放进去，得到一些测试网链接或测试网Aetherium。

474
00:52:07.921 --> 00:52:13.278
现在我们要做的就是把我们的钱包和瑞克比的网络连接起来。

475
00:52:13.278 --> 00:52:19.640
所以我们要下来，我们要从COVID转换到以太。

476
00:52:19.640 --> 00:52:25.867
然后我们要确保我们的元掩码在这里的Rinkeby测试网络上。

477
00:52:25.867 --> 00:52:30.147
一旦这两个都设置好了，我们将继续并点击连接钱包。

478
00:52:30.147 --> 00:52:33.147
我们要选择元蒙版。

479
00:52:33.315 --> 00:52:46.265
一旦我们这样做了，我们的元掩码实际上会弹出并说，你想连接到这个网站吗，连接到一个网站是我们如何让这些网站在界面上与我们的钱包和我们的元掩码互动。

480
00:52:46.316 --> 00:52:50.594
别担心，我们不会发送任何这样的事务，我们稍后会讲到这个。

481
00:52:50.594 --> 00:52:53.423
我们可以选择一个想要连接的账户。

482
00:52:53.423 --> 00:52:56.192
选择账号1，点击Next。

483
00:52:57.317 --> 00:52:59.375
然后我们继续连接。

484
00:53:00.317 --> 00:53:04.252
连接，我们可以看到我们的账户连接在这里。

485
00:53:04.318 --> 00:53:06.011
而那个小小的警告现在消失了。

486
00:53:07.318 --> 00:53:11.697
自动放到这里，我们将进行第一个测试事务。

487
00:53:11.697 --> 00:53:14.887
现在，我们不需要test link。

488
00:53:14.887 --> 00:53:16.302
所以我们把它放在一边。

489
00:53:16.302 --> 00:53:18.974
但稍后，我们会回来得到那个测试链接。

490
00:53:18.974 --> 00:53:21.652
现在我们只需要0。

491
00:53:21.652 --> 00:53:24.022
1 .测试Aetherium。

492
00:53:24.320 --> 00:53:28.223
让我们继续，通过选择红绿灯来完成安全。

493
00:53:28.223 --> 00:53:30.545
然后点击发送请求。

494
00:53:30.545 --> 00:53:36.643
这将会做的是我们要求这个水龙头给我们0。

495
00:53:36.643 --> 00:53:42.660
Aetherium测试网水龙头是我们通过测试网把钱放进钱包的一种方式。

496
00:53:42.660 --> 00:53:46.131
这就是为什么这个测试和Aetherium一文不值的原因。

497
00:53:46.131 --> 00:53:47.612
因为我们可以免费得到。

498
00:53:47.612 --> 00:53:54.497
这些在主网上是不存在的，你无法在主网上免费获得真正的Aetherium或真钱。

499
00:53:54.497 --> 00:53:57.723
所以我们在林克比我们得到了假冒的林克乙醚。

500
00:53:57.723 --> 00:53:59.643
然后点击发送请求。

501
00:53:59.643 --> 00:54:08.137
一旦我们点击Send Request，这个事务散列就会在这里弹出，它说事务已经启动，等待确认。

502
00:54:08.137 --> 00:54:12.449
这意味着其他钱包实际上会给我们发送0。

503
00:54:12.449 --> 00:54:13.136
1 .测试。

504
00:54:13.136 --> 00:54:21.825
这就是它正在进行的交易现在我们只需要等待我们的交易完成验证并通过。

505
00:54:21.825 --> 00:54:25.584
现在，如果这不能立即工作，我建议等一分钟，然后再试一次。

506
00:54:25.584 --> 00:54:28.680
但我们能做的是点击这个事务哈希。

507
00:54:28.680 --> 00:54:32.850
如果交易没有显示，我们也可以关闭这个。

508
00:54:32.850 --> 00:54:34.945
我们可以在这里复制我们的地址。

509
00:54:34.945 --> 00:54:36.889
实际上我们已经看到0了。

510
00:54:36.889 --> 00:54:38.514
在我们的钱包里。

511
00:54:38.514 --> 00:54:46.629
但我们可以回到Rinkeby以太扫描，粘贴我们的地址，我们可以看到我们现在有0。

512
00:54:46.629 --> 00:54:48.216
1个乙醚作为平衡。

513
00:54:48.216 --> 00:54:54.079
我们还可以看到，我们有一个交易，所有这些信息进入我们的钱包。

514
00:54:54.079 --> 00:54:55.579
这就是绿色的含义。

515
00:54:55.579 --> 00:55:08.710
如果你点击交易链接，你会看到类似这样的东西，但如果你没有，不用担心，因为在以太扫描中，如果你点击交易列表中的交易哈希，你也可以看到所有的细节。

516
00:55:08.710 --> 00:55:10.422
现在在元掩码中，我们有0。

517
00:55:10.422 --> 00:55:10.977
1容易的。

518
00:55:10.977 --> 00:55:13.755
再说一次，这是假的Aetherium。

519
00:55:13.755 --> 00:55:18.281
我们现在有了一个与钱包相关的交易，这太棒了。

520
00:55:18.331 --> 00:55:26.568
但是，如果我们切换网络，如果我们把网络切换回以太主网，你可以看到我们在理论主网上什么都没有。

521
00:55:26.568 --> 00:55:31.332
如果是ropsten，也什么都没有，只有这个0。

522
00:55:31.332 --> 00:55:31.760
1容易的。

523
00:55:31.760 --> 00:55:39.871
在Rinkeby测试网络上，如果你想练习使用另一个测试网，我们正在使用的水龙头有多个测试网。

524
00:55:39.871 --> 00:55:45.851
让我们在这一节中尝试一下这是完全可选的，你可以观看，也可以跟着做。

525
00:55:45.851 --> 00:55:51.873
但例如，我可以在我的钱包里看到，我们已经支持COVID，所以也许我会切换到COVID。

526
00:55:51.873 --> 00:55:53.691
也许我们会转向COVID。

527
00:55:53.691 --> 00:55:59.270
在下拉菜单中，我们将删除测试10 Link，因为我们只需要测试eath。

528
00:55:59.270 --> 00:56:07.336
我们会点击“我不是机器人”，然后我们会发送请求，这次会弹出相同的内容，这将是针对COVID检测网的。

529
00:56:07.336 --> 00:56:10.224
一旦我们的交易完成。

530
00:56:10.224 --> 00:56:11.630
现在，COVID也是一样。

531
00:56:11.630 --> 00:56:17.523
这里，就像我们在溜冰场B上做的一样，一旦我们的交易完成，我们会看到0。

532
00:56:17.523 --> 00:56:23.613
如果你想尝试使用另一个测试网络，请在COVID网络上进行测试。

533
00:56:23.613 --> 00:56:27.820
比如，COVID建议你去尝试一下。

534
00:56:27.820 --> 00:56:29.228
但这是完全可选的。

535
00:56:29.228 --> 00:56:34.993
我总是会参考GitHub回购，以确保您正在使用最新的水龙头和测试网。

536
00:56:34.993 --> 00:56:41.271
如果我们回头看以太扫描，我们实际上可以看到更多关于刚刚发生的事情的细节。

537
00:56:41.339 --> 00:56:45.540
到底发生了什么，我们的超面具是怎么得到0的余额的。

538
00:56:45.540 --> 00:56:45.840
1容易的。

539
00:56:45.840 --> 00:56:55.086
突然之间?如果我们向下看事务部分，我们可以看到这里有一个事务，某个地址给我们发送了0。

540
00:56:55.086 --> 00:56:55.641
1醚。

541
00:56:55.641 --> 00:57:03.409
如果我们单击事务散列，我们可以看到关于这个事务实际发生的更多细节。

542
00:57:03.409 --> 00:57:12.135
现在，了解这个交易中发生了什么对于学习和成为一名智能合约开发人员或仅仅参与到生态系统中是至关重要的。

543
00:57:12.135 --> 00:57:16.278
我们来看看最上面的第一点是这个事务哈希。

544
00:57:16.343 --> 00:57:23.379
这是这个区块链或这个测试网的唯一标识符，它标识这个确切的事务。

545
00:57:23.379 --> 00:57:27.078
此事务散列标识发送0。

546
00:57:27.078 --> 00:57:34.297
看到我们的地址，我们可以看到这个交易的状态是成功的，它没有中断。

547
00:57:34.345 --> 00:57:56.474
无论如何，我们可以看到交易所在的区块号我们会讲到区块，我们可以看到时间戳当然是交易发生的时间，我们可以看到它来自哪个账户如果我们继续，打开一个新选项卡，我们可以看到这是交易来自的账户。

548
00:57:56.474 --> 00:57:58.228
它有300万以太。

549
00:57:58.228 --> 00:58:00.804
当然，这是假的林基醚。

550
00:58:00.804 --> 00:58:06.048
所以这并不重要，我们都能看到是给谁的，也就是我们自己。

551
00:58:06.048 --> 00:58:17.478
这是我们的钱包地址0x106x，等等，等等，cero x1066，等等，等等，对了，这笔交易的价值，当然是0。

552
00:58:17.478 --> 00:58:17.929
1醚。

553
00:58:17.929 --> 00:58:22.188
那么我们看到的这些值是什么?很明显，这个值是0。

554
00:58:22.188 --> 00:58:23.695
1，因为这是我们发送的模式。

555
00:58:23.695 --> 00:58:25.482
但是我们看到这个交易费用。

556
00:58:25.482 --> 00:58:35.017
在这个天然气价格，我们悬停在工具提示，我们可以看到，如果你放大你的以太扫描，你可以看到支付给矿工处理交易的金额。

557
00:58:35.017 --> 00:58:42.023
我们看到一个天然气价格，这是每单位天然气的成本，具体为交易，以太和灰色。

558
00:58:42.023 --> 00:58:45.844
天然气价格越高，被纳入区块的几率就越高。

559
00:58:45.844 --> 00:58:51.902
现在，如果我们再往下滚动，点击“查看更多”，我们还可以在这里看到很多其他信息。

560
00:58:51.902 --> 00:58:56.209
现在我们只需要点击看更少的东西，只关注这两个。

561
00:58:56.209 --> 00:59:01.210
我将在后面的部分中解释所有这些。

562
00:59:01.353 --> 00:59:05.708
我们先来谈谈交易费用和汽油的概念。

563
00:59:05.708 --> 00:59:34.291
还记得我说过区块链是由所有这些不同的节点运行的吗所有这些不同的节点运行区块链因为它们实际上从这些区块链上发生的所有交易中获得了报酬每当你进行交易时，就会有一个节点或矿工或验证者运行区块链软件的人会得到一丁点Aetherium或polygon或任何你运行的区块链，他们会从本地的区块链货币中得到一点报酬。

564
00:59:34.357 --> 00:59:43.641
这种支付显然是为了激励人们继续运行节点，他们计算你支付了多少钱，节点操作员得到了多少报酬，这是基于你使用了多少天然气。

565
00:59:43.641 --> 00:59:46.565
这就是气体的概念。

566
00:59:46.565 --> 00:59:49.691
气体是一种计算计量单位。

567
00:59:49.691 --> 00:59:54.703
交易使用的计算量越多，你需要支付的汽油就越多。

568
00:59:54.703 --> 00:59:58.326
例如，我们会快速点击更多。

569
00:59:58.326 --> 01:00:10.693
我们可以看到这部分写着A气体限制和气体使用情况，在这个交易中有60,000单位的气体限制，而实际使用的是21,000单位。

570
01:00:10.693 --> 01:00:15.138
这个交易用了21单位气体。

571
01:00:15.361 --> 01:00:20.581
对于像发送以太这样非常简单的事情来说，单位气体通常非常便宜。

572
01:00:20.581 --> 01:00:31.813
但也许对于更复杂的事情，比如铸造非ft，向一些违反合同的银行存款，等等，这些可能会消耗更多的汽油，因为它们的计算成本更高。

573
01:00:31.813 --> 01:00:34.632
这现在有点让人困惑，不要太担心。

574
01:00:34.632 --> 01:00:36.608
但要知道，我们这里用了21000汽油。

575
01:00:36.608 --> 01:00:49.697
如果我们拿出计算器21000汽油乘以这个价格，乘以价格，我们得到和交易费完全一样的结果。

576
01:00:49.697 --> 01:00:55.042
汽油价格乘以你用了多少汽油，就是交易费。

577
01:00:55.042 --> 01:00:58.459
不管是谁给我们这个0。

578
01:00:58.459 --> 01:01:01.271
1以太，也支付0。

579
01:01:01.271 --> 01:01:05.917
0000525，等等来进行此交易。

580
01:01:05.917 --> 01:01:11.604
每个区块链都有不同的方法来计算气体的工作原理。

581
01:01:11.604 --> 01:01:14.128
这基本上就是它的高水平了。

582
01:01:14.128 --> 01:01:17.142
我们现在只关注总交易费。

583
01:01:17.142 --> 01:01:19.262
当然还有汽油价格。

584
01:01:19.367 --> 01:01:24.899
在我们讲完区块链的工作原理后，我会解释什么是燃烧，煤气费和其他的东西。

585
01:01:24.899 --> 01:01:31.816
现在，只要知道任何时候你在链上进行交易，你必须支付一点我称之为交易气的东西。

586
01:01:31.816 --> 01:01:37.920
例如，如果我们到Metamask，这里有两个账户，第一个账户是0。

587
01:01:37.920 --> 01:01:41.742
1，林基，第二个账户是零。

588
01:01:41.742 --> 01:01:42.453
里格比。

589
01:01:42.453 --> 01:01:44.826
如果我输入0。

590
01:01:44.826 --> 01:01:46.641
05林基·伊思。

591
01:01:46.641 --> 01:01:59.518
从这个账户到另一个账户，你觉得我还剩多少钱?让我们试一下，这将是你实际创建的第一个交易你将为它花费汽油。

592
01:01:59.518 --> 01:02:03.320
点击发送，我们会点击账户间转账。

593
01:02:03.371 --> 01:02:06.731
数到二，0。

594
01:02:07.372 --> 01:02:23.560
接下来，我们可以在这里看到一些信息关于Metamask有一些新的高级气体UI和设置，我们也会打开歌曲，所以继续点击启用增强气体UI，打开它，然后返回。

595
01:02:23.560 --> 01:02:26.596
这还是实验选项卡。

596
01:02:26.596 --> 01:02:28.729
但它也可以在“常规设置”选项卡中。

597
01:02:28.729 --> 01:02:32.324
取决于你什么时候运行这个，我们能在这里看到一个小通知。

598
01:02:32.374 --> 01:02:35.324
同样，这取决于我们使用的Metamask的版本。

599
01:02:35.375 --> 01:02:40.812
我们看到这个小的下拉框上面写着，这是你实际可以支付的一些不同类型的汽油费用。

600
01:02:40.812 --> 01:02:47.991
汽油费用可能会改变的原因，正如你在这里看到的，根据区块链的繁忙程度，你必须支付更多的汽油。

601
01:02:47.991 --> 01:02:56.043
如果很多人都在发送事务，这意味着没有足够的空间让每个人的事务通过。

602
01:02:56.043 --> 01:02:58.672
这对正在发生的事情有点过于简单化了。

603
01:02:58.672 --> 01:03:00.049
但现在不用太担心。

604
01:03:00.049 --> 01:03:01.777
现在，如果我们想发送0。

605
01:03:01.777 --> 01:03:10.711
第二个账户是0ether，我们可以看到这个气体估计部分，它表示估计，我们将支付0。

606
01:03:10.711 --> 01:03:15.445
00004792气体除了发送0。

607
01:03:15.445 --> 01:03:15.845
5容易的。

608
01:03:15.845 --> 01:03:18.911
所以在底部，我们有金额加上汽油费。

609
01:03:18.911 --> 01:03:24.379
这将是我们在这笔交易上花费的总金额0。

610
01:03:24.379 --> 01:03:25.979
我们发送的是05。

611
01:03:25.979 --> 01:03:28.094
还有这个气体部分。

612
01:03:28.094 --> 01:03:34.312
我们继续确认，我们现在看到里格比以太扫描中有一个待处理的事务。

613
01:03:34.381 --> 01:03:39.300
如果我们点击它，我们甚至能在block Explorer上点击视图。

614
01:03:39.381 --> 01:03:49.818
Rigby交易哈希会弹出根据你点击它的时间，它可能会显示索引，这意味着以太扫描已经接收到你的交易并试图放置它。

615
01:03:49.818 --> 01:03:53.858
如果您在这里没有看到任何东西，这意味着可能交易还没有完成。

616
01:03:53.858 --> 01:03:55.592
也许你需要再等一会儿。

617
01:03:55.592 --> 01:04:00.683
或者您可能需要回到GitHub回购并选择推荐的遗嘱和水龙头。

618
01:04:00.683 --> 01:04:04.544
你可能需要等一分钟左右，让这个完成索引。

619
01:04:04.544 --> 01:04:08.112
大约一分钟后，我们可以看到这个事务确实已经通过了。

620
01:04:08.112 --> 01:04:13.465
我们可以看到很多和上一题相同的信息，这次是0。

621
01:04:13.465 --> 01:04:14.120
05年醚。

622
01:04:14.120 --> 01:04:20.079
现在如果我们看元掩码，我们会看到账户1有0。

623
01:04:20.079 --> 01:04:24.489
它四舍五入了一点，我们点击大按钮，我们可以看到它实际上是0。

624
01:04:24.489 --> 01:04:25.626
049953年,等等。

625
01:04:25.626 --> 01:04:31.089
而另一个账户账户2正好是0。

626
01:04:31.089 --> 01:04:31.245
05.

627
01:04:31.245 --> 01:04:37.387
这是因为我们花了一些Aetherium在gas上来发送这个交易。

628
01:04:37.387 --> 01:04:48.120
现在，有了这一点信息，您就知道了如何与使用区块链的应用程序进行实际交互，如何发送事务以及许多非技术细节。

629
01:04:48.120 --> 01:04:51.888
这里有一些非常令人兴奋的东西，仅仅是这一点信息。

630
01:04:51.888 --> 01:04:56.188
你现在知道了如何与区块链和以太坊协议交互。

631
01:04:56.188 --> 01:05:04.478
所以如果你不想学习如何编码任何东西，你可以去如果你可以开始与Aetherium交互和与协议交互同样多的信息。

632
01:05:04.478 --> 01:05:07.898
然而，我知道你们大多数人是来学习如何编程的。

633
01:05:07.898 --> 01:05:09.675
让我们来看看Aetherium的内部结构。

634
01:05:09.675 --> 01:05:14.123
这些交易实际上发生了什么，这些气体和这些区块链是什么。

635
01:05:14.123 --> 01:05:18.373
我们来学习一下区块链的基本原理。

636
01:05:18.373 --> 01:05:23.845
现在，如果你想直接进入编码，直接从描述中获取时间戳。

637
01:05:23.845 --> 01:05:29.292
然而，确切了解区块链是如何工作的将使您成为一个非常强大的开发人员。

638
01:05:29.392 --> 01:05:31.958
我们先来看看这个。

639
01:05:33.393 --> 01:05:36.344
在这个网站上观看区块链的演示。

640
01:05:36.393 --> 01:05:42.468
现在，这个网站的创建者有一个精彩的视频和区块链一对一的精彩介绍，就在他们的网站上。

641
01:05:42.468 --> 01:05:47.699
所以如果你在寻找另一种解释，一定要看看他的视频，它绝对非常棒。

642
01:05:47.699 --> 01:06:00.733
但我们真正需要做的第一件事是为了理解区块链或者任何东西，以及这里的所有工作首先需要理解Sha 256，散列，或者一般的散列，让我们先理解什么是散列。

643
01:06:00.733 --> 01:06:10.486
哈希是一个唯一的固定长度的字符串，用于标识任何数据片段，它们是通过将一些数据片段放入哈希函数来创建的。

644
01:06:10.486 --> 01:06:14.646
在本例中，使用的哈希算法是Sha 256。

645
01:06:14.646 --> 01:06:24.238
以太坊实际上用的是这个哈希算法，不是Sha 256，而是Sha家族的一种。

646
01:06:24.238 --> 01:06:27.259
但这只是另一种哈希的方法。

647
01:06:27.259 --> 01:06:30.669
具体的哈希算法并不重要。

648
01:06:30.669 --> 01:06:35.697
所以在这个例子中，你只增加到6，但你可以想象它和以太一样。

649
01:06:35.697 --> 01:06:38.657
哈希，它们会得到一个不同的哈希值。

650
01:06:38.657 --> 01:06:50.931
这个应用程序中会发生的是不管我们把什么数据或信息放入这个数据区，你可以看到下面这个散列会发生变化。

651
01:06:50.931 --> 01:06:57.682
这些数据通过sha256哈希算法进行运算。

652
01:06:57.682 --> 01:07:00.671
它输出的是这个唯一的哈希值。

653
01:07:00.671 --> 01:07:07.214
这个散列是一个唯一的固定长度的字符串，它会像一个空白的数据块一样识别出来。

654
01:07:07.214 --> 01:07:14.741
如果我输入我的名字，比如帕特里克·柯林斯，这就是代表帕特里克·柯林斯的哈希值。

655
01:07:14.741 --> 01:07:24.807
你可以看到，即使我在这里放了很多很多的数据，字符串的长度不会改变，对吧。

656
01:07:24.807 --> 01:07:33.081
它总是一样的，我们几乎可以放入任何数量的数据，数据的最大大小有一个上限。

657
01:07:33.081 --> 01:07:37.262
但出于所有的目的，我们几乎可以在这里放入任何长度。

658
01:07:37.262 --> 01:07:54.567
你会注意到每次我输入Patrick Collins的时候，这个散列总是这个7e5d，对吧?我要删除，我要用Patrick Collins，再说一次，你是75b总是这个，这个唯一哈希总是唯一的，它总是这个固定长度的字符串。

659
01:07:54.567 --> 01:08:01.341
现在我们可以把这个想法放在这里，我们可以继续这个块的概念。

660
01:08:01.407 --> 01:08:14.249
有了这个块的概念，我们将对这个哈希进行完全相同的处理这个数据部分，但不是所有东西都在这里，这个单一的数据区域，我们将把这些数据分成块，修女和数据。

661
01:08:14.249 --> 01:08:23.331
所以我们要做的是我们实际上要哈希这三个来得到这个哈希值，我们要把这三个都放进去，我们会说这三个都是组合的。

662
01:08:23.331 --> 01:08:28.715
我们要把这三个都放到这个哈希算法里来求。

663
01:08:28.715 --> 01:08:37.568
如果我在这里输入一堆东西，我们可以看到block 1和nonce，你知道，这个nonce，和这个数据，我们会得到这个散列。

664
01:08:37.568 --> 01:08:42.773
你可以看到，屏幕变成了红色，这个方块变成了红色。

665
01:08:42.773 --> 01:08:50.037
现在，当我按下这个思维键会发生什么?当我按下这个思维键时，它会花一些时间，它会思考一会儿。

666
01:08:50.037 --> 01:08:57.068
我们可以看到这里的nonce实际上改变了，对吧?现在和以前不一样了。

667
01:08:57.068 --> 01:09:00.363
这个哈希值从4个0开始。

668
01:09:00.363 --> 01:09:02.758
好，然后后面变成绿色。

669
01:09:02.758 --> 01:09:25.088
当我们谈论挖矿的时候，我们谈论的是矿工要解决一些非常困难的问题需要花费大量的时间在这个例子中，矿工要解决的问题是他们必须找到一个nonce，或者在这个nonce部分找到一个值当在第一块用这个数据哈希时，它会从4个0开始。

670
01:09:25.088 --> 01:09:35.137
所以矿工们要解决的问题就是从4个0开始他们要做到这一点的唯一方法就是用蛮力，你知道，尝试一些东西所以他们尝试了一个好吧，一个没用。

671
01:09:35.137 --> 01:09:37.842
好吧，两个，不，两个没用。

672
01:09:37.842 --> 01:09:40.623
好的，5，它是从0开始的，但不是4。

673
01:09:40.623 --> 01:09:50.297
他们必须不断地尝试所有这些数字，直到他们到达这个数字，让我们再次点击我的数字。

674
01:09:50.418 --> 01:09:53.660
它开始的时候顶部有4个0。

675
01:09:54.419 --> 01:09:56.619
具体的问题将区块链变为区块链。

676
01:09:56.619 --> 01:10:04.274
Aetherium对矿工来说有不同的问题要解决，比特币和你的问题是不同的，但这个概念是一样的。

677
01:10:04.274 --> 01:10:12.338
所以他们必须把它，一个区块将是这个，这个概念将是所有这些数据，它将是区块号。

678
01:10:12.338 --> 01:10:14.813
就在这个瞬间，对吧。

679
01:10:14.813 --> 01:10:27.866
所以这个nonce就是解就是他们用来得到这个问题的解的数字，对吧?如果我去到这里，你知道，我再做一次，点击我的。

680
01:10:27.866 --> 01:10:31.453
nonces变了，对吧?从1到33128。

681
01:10:31.453 --> 01:10:37.358
因为这是允许哈希以4个0开始的nonce。

682
01:10:37.358 --> 01:10:39.858
这就是正在发生的事情。

683
01:10:39.858 --> 01:10:50.127
当区块链矿工在采矿时，他们要经历一个计算非常密集的过程，试图找到一个能满足任何问题的nonce。

684
01:10:50.127 --> 01:10:51.336
实际上就是这样。

685
01:10:51.336 --> 01:10:51.967
这是一个方块。

686
01:10:51.967 --> 01:10:53.958
这就是矿工们开采时所发生的事情。

687
01:10:53.958 --> 01:11:03.863
他们只是在看，试错，用蛮力试图找到这个坚果现在我们知道了什么是区块，让我们进入下一步，弄清楚什么是区块链。

688
01:11:03.863 --> 01:11:09.296
这里我们有一个区块链的例子。

689
01:11:09.296 --> 01:11:14.458
好的，我们有一个组合，你知道，我们在后面的方块部分，我们有一个方块的样子。

690
01:11:14.458 --> 01:11:24.077
现在这里，我们有多个不同的块，对吧，每一个都代表一个不同的块，但是我们在这里有一个额外的列，我们在这里有一个额外的变量。

691
01:11:24.077 --> 01:11:37.100
就像之前一样，我们有block nonce和data，对吧，我们有block nonce data，我们还有这个东西叫做previous right，这实际上会指向上一个block的上一个哈希值。

692
01:11:37.100 --> 01:11:42.203
例如，如果我们到区块链的最后一个块，它说前008。

693
01:11:42.203 --> 01:11:46.085
如果我们看第4块的哈希值，是00008。

694
01:11:46.085 --> 01:11:58.743
然后我们看它的前一个它是4个0,b9，我们有4个0,B, 9，以此类推，一直到第一个方块，它的前一个都是0，对吧。

695
01:11:58.743 --> 01:12:03.535
所以前面全是0的那块，就叫做创世纪块。

696
01:12:03.535 --> 01:12:11.532
你可能听说过在创世块之前，区块链中的第一个块是之前的哈希点指向一个实际上并不存在的哈希。

697
01:12:11.532 --> 01:12:42.015
现在，你可以想象，和这个块的工作原理差不多，块螺母和日期都要经过哈希算法在区块链中，块nonce数据，以及之前的哈希都要经过这个哈希算法来计算哈希值?如果我们到这里，比如说，如果我输入Patrick，很明显，这就不再有效了，对吧?因为这个修女和之前哈希中的数据块结合起来，并不能解决一开始有4个0的问题。

698
01:12:42.015 --> 01:12:43.418
所以我要去把它修好。

699
01:12:43.418 --> 01:12:46.608
这是一种很容易看出它被破坏的方式。

700
01:12:46.608 --> 01:13:18.455
但是，让我们看一下，如果我破坏了这个块，就在这里，如果我破坏了这里的数据，如果我像帕特里克一样在这里，你可以看到这两个现在都被读取了，这两个现在都无效了，对吧?因为带nonce哈希的块哈希加上新数据，也就是我的名字，帕特里克已经用前一个块哈希了现在是一个全新的哈希，这个块仍然指向这个前一个哈希，指向这个前一个块。

701
01:13:18.455 --> 01:13:26.209
现在它是错误的，它是混乱的，现在它是疯狂的，之前的哈希也是错误的。

702
01:13:26.209 --> 01:13:40.844
对吧?这就是为什么我们说区块链是不可变的，这就是为什么它是不可变的，对吧?因为我返回并修改了任何东西，如果我在这里输入了a，整个区块链现在就无效了。

703
01:13:40.844 --> 01:13:46.171
因为这些都不再有nonc来解这个方程了。

704
01:13:46.171 --> 01:14:07.927
这就是为什么区块链是不可变的，因为任何时候你改变了一件事，你就会破坏其余的区块链，明白吗?尽管如此，如果它本来在这里，我们可以继续挖掘这些，挖掘所有这些但你可以看到，这将开始变得计算非常昂贵，因为我必须重做整个区块链。

705
01:14:07.927 --> 01:14:15.206
你走得越远，就越难，你知道，重新哈希和重做所有这些不同的区块链。

706
01:14:15.206 --> 01:14:20.462
这很有道理，对吧?我们有这个区块链，要改变过去的东西真的很难，但如果我们要改变，我们可以直接提醒它。

707
01:14:20.462 --> 01:14:27.287
如果我是控制区块链的人，对吧，如果我是控制这个的人，你知道，我想改变什么，过去会，好吧，很好。

708
01:14:27.287 --> 01:14:29.429
我要做的就是改变这里的状态。

709
01:14:29.429 --> 01:14:39.362
然后你知道，我的每一个，你知道，显然，这将是非常昂贵的计算，但这是我可以做对的如果我是区块链的拥有者。

710
01:14:39.447 --> 01:14:46.666
现在，这就是去中心化的本质或者说分布式的本质让它变得非常强大的地方。

711
01:14:46.666 --> 01:14:56.635
我们要转到分布式标签，它也被称为去中心化标签，它会向我们展示去中心化方式下的区块链是什么样的。

712
01:14:56.635 --> 01:15:04.285
我们有完全相同的初始设置我们要发射一个区块链，我们有第一个区块链，它和这里的一模一样。

713
01:15:04.285 --> 01:15:16.093
但我们也不止一次地有peer, peer beam和PRC当人们在谈论peer to peer，通过交谈进行的peer to peer交易时，这就是他们谈论的概念，对吧。

714
01:15:16.093 --> 01:15:31.435
所以我们有许多运行区块链技术的不同的对等体，它们的权重都是相等的，对吧，每一个这些对等体或每一个这些节点，每一个运行区块链的实体都和其他人拥有完全相同的权力，对吧。

715
01:15:31.435 --> 01:16:01.713
所以我们很容易可以告诉这区块链是正确的,或者哪些是正确的,或通过观察这个目的,散列在这里,正确的,或通过观察我们的区块链,因为,记住,因为,记住这一点,这个散列在这最后一块,将包含所有的街区,对吧,因为最后一个散列将前面的散列,包括以前的散列在这里,这个哈希包含了之前的哈希。

716
01:16:01.713 --> 01:16:17.857
最后这个哈希包含了这里的所有东西?我们可以看一下Piercey的哈希，它是4个0，然后是e4b，我们可以看最新的哈希B，它是4个0,E代表B，然后纯A，它是4个0,E代表B。

717
01:16:17.857 --> 01:16:33.958
所以所有这些对等点，所有这些节点，所有这些去中心化的，你知道这些独立的，所有这些运行区块链软件的独立用户，他们都是匹配的，他们的节点很容易看到彼此然后说，嗨，很好，我们都是匹配的。

718
01:16:33.958 --> 01:16:43.271
现在，我们假设a决定，你知道，在区块链上发生了一些他们不喜欢的事情，他们想回去改变一些东西。

719
01:16:43.271 --> 01:16:47.913
假设它们在这里改变了，很明显，它们其余的区块链无效。

720
01:16:47.913 --> 01:16:51.364
他们必须花费大量的计算能力来追赶速度。

721
01:16:51.364 --> 01:16:52.853
所以让我们继续幽默一下吧。

722
01:16:52.853 --> 01:16:55.362
假设他们做了，他们最终赶上了。

723
01:16:55.461 --> 01:16:58.138
他们最终赶上了，你知道，他们最终挖掘了所有东西。

724
01:16:58.138 --> 01:17:00.646
现在他们有一个有效的区块链。

725
01:17:00.646 --> 01:17:03.018
对吧?它解了方程。

726
01:17:03.018 --> 01:17:03.673
太棒了。

727
01:17:03.673 --> 01:17:13.388
然而，在三号街区，有了新发现，对吧?这是这里，它不应该在这里，这是Peer A自己放进去的。

728
01:17:13.388 --> 01:17:24.213
现在所发生的就是我们观察所有运行软件的区块链，我们观察所有的哈希和第5个区块的哈希。

729
01:17:24.213 --> 01:17:26.225
纯A有新的哈希值。

730
01:17:26.225 --> 01:17:28.225
这是公元前09年。

731
01:17:28.225 --> 01:17:39.947
但是纯B有不同的哈希00 e代表B，对吧?那么谁是对的呢?它会随着他们的新东西消失吗?还是纯B?这就是去中心化数据的用武之地。

732
01:17:39.947 --> 01:17:43.542
因为我们可以看看皮尔西皮尔西，也叫E forby。

733
01:17:43.542 --> 01:17:50.385
所以如果你是皮尔斯会说，嘿，你错了，滚出去，对的。

734
01:17:50.466 --> 01:18:08.657
纯A将不再能够参与挖矿奖励因为他们已经分叉了区块链并开始了他们自己的区块链就在他们自己的历史中，因为他们是唯一拥有这块数据的，这块数据在区块3中，而纯B和纯C什么都没有。

735
01:18:08.657 --> 01:18:17.900
这就说明了为什么在这些区块链世界中在这个去中心化的世界中，真的没有一个中心化的实体，你知道，纯A，你知道，可能有恶意的动机去改变。

736
01:18:17.900 --> 01:18:27.282
你知道，这是3号街区，然而，民主规则，对吧，在区块链中多数规则，纯vmpfc会说，嘿，你知道，这很可爱，都是泥。

737
01:18:27.282 --> 01:18:29.531
但你错了，对吧?这不对。

738
01:18:29.531 --> 01:18:40.962
现在，这可能有点抽象，你只是看着数据，你知道，在这里输入随机的东西，然后想，好吧，是的，那是数据，对吧?这是有道理的，你知道，只是随机的字符串在这里对我们没有任何帮助。

739
01:18:40.962 --> 01:18:46.709
如果我们到这里的令牌部分，这才是真正开始有意义的地方。

740
01:18:46.709 --> 01:18:51.222
我们在纯a纯B皮尔西有完全相同的设置。

741
01:18:51.222 --> 01:19:12.067
不同之处在于，我们没有这个数据部分，而是有这个TX this事务部分?这代表了这个区块中发生的所有交易，对吧?所以我们从达西寄25美元到彬格莱，或者说寄彬格莱一共是27美分。

742
01:19:12.067 --> 01:19:13.004
1922,对吧。

743
01:19:13.004 --> 01:19:15.087
这是完全一样的。

744
01:19:15.087 --> 01:19:21.114
所有这些事务都将以和数据相同的方式进行哈希。

745
01:19:21.114 --> 01:19:33.426
这就是它如此强大的原因，因为，你知道，如果我想恶意，如果，如果我想说，嘿，我真的想从伊丽莎白那里给简更多的钱，所以我是泥，我回去把它换成100。

746
01:19:33.476 --> 01:19:42.784
现在，你知道，不仅我的整个区块链会失效因为那是很久很久以前的事了，而且我不会匹配任何其他的链。

747
01:19:42.784 --> 01:19:47.123
对吧?所以我的区块链将被整体区块链排除在外。

748
01:19:47.123 --> 01:19:49.768
那么，让我们继续来修正这个。

749
01:19:49.768 --> 01:19:57.885
这是一样的，如果在这里如果我变得恶意，我想送你知道，我想让奥黛丽小姐的钱少一些。

750
01:19:57.885 --> 01:20:10.896
也许我想送1美元，他们想的是一样的，这个哈希现在这个2,1不匹配BBA的哈希。

751
01:20:10.896 --> 01:20:13.917
而且跟皮尔斯的工商管理学位也不匹配。

752
01:20:13.917 --> 01:20:20.904
所以他们两个会说，嘿，你的区块链无效，它不符合多数，你知道，你出局了，对吧。

753
01:20:20.904 --> 01:20:25.732
这就是这些区块链在低水平上的工作方式。

754
01:20:25.732 --> 01:20:36.631
这一切都回到了这个，理解这个哈希思想，并以这种非常复杂的方式使用它，以某种密码学的方式证明，你知道，东西在哪里。

755
01:20:36.631 --> 01:20:51.516
现在，区块链的工作方式是，它不是随机的东西，放在状态部分，它实际上是在这里寻找与链上不同区块和不同协议交互的方法，或者，如我们之前所说，不同的智能合约。

756
01:20:51.516 --> 01:21:06.243
现在，你可能会问的下一个问题是，好吧，我怎么知道我怎么确定我就是那个人?比方说，我是达西，对吧?我怎么能确定是我是达西真的把钱寄到这里来了。

757
01:21:06.243 --> 01:21:08.866
我们怎么知道达西寄了25美元。

758
01:21:08.866 --> 01:21:14.293
彬格莱先生?这就是我们讨论私钥和公钥的地方。

759
01:21:14.293 --> 01:21:16.605
这就是我们要研究的。

760
01:21:16.605 --> 01:21:16.808
现在。

761
01:21:16.808 --> 01:21:19.701
让我们快速回顾一下本节所学的内容。

762
01:21:19.701 --> 01:21:25.091
到目前为止，对吧?我们已经了解到Aetherium实际上运行在这个点击检查256。

763
01:21:25.091 --> 01:21:26.165
但是我们使用Sha 256。

764
01:21:26.165 --> 01:21:28.100
对于这个演示，这并不重要。

765
01:21:28.100 --> 01:21:31.677
我们只是在讨论哈希算法。

766
01:21:31.677 --> 01:21:38.258
哈希是一个唯一的固定长度的字符串，用来标识任何数据。

767
01:21:38.258 --> 01:21:47.406
哈希算法或哈希函数是将任何类型的数据计算为唯一哈希的函数或算法。

768
01:21:47.490 --> 01:21:51.783
挖掘将是找到区块链问题解决方案的过程。

769
01:21:51.783 --> 01:21:56.200
在我们的例子中，问题是找到一个以4个0开头的散列。

770
01:21:56.200 --> 01:21:58.552
节点通过挖掘不同的区块获得报酬。

771
01:21:58.552 --> 01:22:09.904
问题是不同的区块链和区块链是一个块区块链基本上是块，nonce事务和之前的哈希的组合为这个块创建唯一的哈希。

772
01:22:09.904 --> 01:22:15.282
这取决于区块链实现，它可能有两个其他字段或不同的字段。

773
01:22:15.282 --> 01:22:22.893
区块链是去中心化和分布式的，因为许多独立用户将运行这个区块链软件。

774
01:22:22.893 --> 01:22:32.107
他们会检查，然后我们会互相比较，看看哪些区块链是诚实的，哪些是恶意的，在区块链世界多数规则中。

775
01:22:32.107 --> 01:22:37.608
这里的nonce是用来得到这个散列的答案或数字。

776
01:22:37.608 --> 01:22:41.850
现在nonce是一个超负荷的术语，它实际上被用于许多不同的原因。

777
01:22:41.850 --> 01:22:47.860
在这种情况下，我们用它来解决在停止或散列处得到4或5个0的问题。

778
01:22:47.860 --> 01:22:56.349
然而，在Aetherium中，它也经常被用作来自给定地址的交易数量。

779
01:22:56.497 --> 01:23:16.212
现在我们来讨论一下签名这些交易和私钥以及其他一些密码学内容?因为在区块链演示中，我们可以看到所有这些奇妙的交易，对吧?这一切都过去了，可我们怎么知道是达西干的呢?是谁送的25美元?bangli吗?对吧?我们怎么知道那真的发生了。

780
01:23:16.212 --> 01:23:26.423
这就是我们刚刚在测试网中学到的所有东西，在我们的元掩码账户中真正开始，在这里一点点变得有活力。

781
01:23:26.423 --> 01:23:35.270
这里我们有一个关于公钥和私钥的例子，在顶部，我们有这个私钥，这是随机生成的。

782
01:23:35.270 --> 01:23:49.872
私钥是你想要保密的密钥，因为你会用它作为你所有交易的秘密密码我可以任意选择任何私钥，任何我想要的。

783
01:23:49.872 --> 01:23:55.519
有了它，这个算法，或者说他们会用Aetherium的算法。

784
01:23:55.519 --> 01:24:02.957
比特币，它们都使用椭圆曲线，数字签名算法，这是数字签名算法的一个变体。

785
01:24:02.957 --> 01:24:09.186
它会创建这个这个公钥，我真的不打算深入研究这个数字签名算法。

786
01:24:09.186 --> 01:24:17.685
但是要知道，它确实使用了一些，一些我们刚学过的哈希知识结合了一些其他的东西来得到这个公数。

787
01:24:17.685 --> 01:24:19.279
所以我不会讲得太深。

788
01:24:19.279 --> 01:24:22.117
但我们有这个我们创建的私钥。

789
01:24:22.117 --> 01:24:23.880
我们得到这个公钥。

790
01:24:23.880 --> 01:24:43.460
我们希望每个人都能访问这个公钥，是的，全世界都能看到这个，这个私钥，我们希望它是私有的，我们不希望人们看到这个，我们将把这个私钥当做密码，对交易进行数字签名，然后人们可以用这个公钥进行验证。

791
01:24:43.460 --> 01:24:45.589
让我们看看这到底是什么样子的。

792
01:24:45.589 --> 01:24:51.333
我们随便选一个，更安全的，对吧?因为时间越长，就越安全。

793
01:24:51.333 --> 01:25:14.447
如果我们现在去签名，对吧?假设我们有这个，我们想要的信息，对吧?我们会说嗨，世界，对吧?我们希望这是消息，我们创建的私钥，可以用来签署数据，对吧?记得在区块链的演示中，我们是我们是在哈希东西，对吧?我们用这个Shea 256哈希值来得到这个哈希值。

794
01:25:14.510 --> 01:25:16.260
我们正在做类似的事情。

795
01:25:17.511 --> 01:25:21.953
我们正在使用这个数字签名算法来创建这个消息签名。

796
01:25:21.953 --> 01:25:35.858
这个算法的真正强大之处在于，你可以用你的私钥创建这个消息签名，但是其他人不能从消息签名中获得你的私钥。

797
01:25:35.858 --> 01:25:38.431
这就是它的强大之处。

798
01:25:38.431 --> 01:25:44.598
但是，如果我们用这个公钥进行验证，那么这是这是那个，哦，403。

799
01:25:44.598 --> 01:26:01.243
这是相同的公钥，使用这个，使用这个公钥，任何人都可以验证，让我们再次签名，任何人都可以验证签名是你的，对吧?你有一个公钥一个专属于你的私钥。

800
01:26:01.243 --> 01:26:05.328
所以你可以签署东西和公钥，任何人都可以验证一些东西。

801
01:26:05.328 --> 01:26:27.851
任何人都可以验证这个，假设有人想从你这里伪造一笔交易，他们说，嘿，你知道，这是这是这是他们的交易，他们所要做的就是验证这个签名与你的公钥是否一致很容易，整个东西变成红色，因为它没有被验证，对，算法说，嘿，这是错的。

802
01:26:27.851 --> 01:26:32.763
我们可以用同样的方式把它引入到事务中。

803
01:26:32.763 --> 01:26:45.123
所以如果我想汇款，你知道，如果我想汇款400美元，从我的地址到另一个地址，用我的私钥，我可以签署交易。

804
01:26:45.123 --> 01:26:49.770
世界上的任何人都可以验证这笔交易。

805
01:26:49.770 --> 01:26:56.551
这就是为什么当人们说九头蛇的钥匙，你知道，保护你的钥匙，这就是我们在我们的帐户中谈论的。

806
01:26:56.551 --> 01:27:13.072
对吧?如果我们进入设置，我给你们看我的肺炎和私钥的唯一原因是因为这是一个，这是一个垃圾箱账户，我会在这集视频结束时把它扔掉，或者我不会往里面放真钱。

807
01:27:13.072 --> 01:27:30.097
但当我们看Metamask，这里，我们有这个肺炎短语，它允许我们很容易地得到这些不同的私钥，对吧?所以肺炎短语加上，你知道的，随便什么账号就能给我们一个私钥。

808
01:27:30.097 --> 01:27:33.524
记住短语和1的组合，我们会得到这个私钥。

809
01:27:33.524 --> 01:27:40.388
这是我们查看账户细节时，导出私钥。

810
01:27:40.525 --> 01:27:54.458
这就是它确认的地方，这将是我们用来签署交易的私钥，如果其他人获得了这个私钥的访问权，他们就可以为我们签署交易，也可以为我们发送交易。

811
01:27:54.526 --> 01:27:58.717
这就是为什么我们想要保持这些隐私，这样它就能以完全相同的方式工作。

812
01:27:58.717 --> 01:28:12.511
这就是为什么隐藏你的私钥和助记法很重要现在，你的Aetherium地址实际上是你的公钥的一部分。

813
01:28:12.511 --> 01:28:22.977
现在，要在Aetherium中获取我们的地址，我们所要做的就是获取我们用私钥创建的公钥，使用相同的Aetherium哈希算法对其进行哈希，然后获取最后20个字节。

814
01:28:22.977 --> 01:28:27.400
这就是我们如何推导到我们的地址。

815
01:28:27.400 --> 01:28:35.453
现在，知道如何获得地址的确切方法并不重要，因为它可以将区块链变为区块链，甚至也可以改变区块链。

816
01:28:35.453 --> 01:28:44.170
但这基本上就是这些地址的衍生方式或者说公钥的衍生方式，因为公钥是公共的。

817
01:28:44.170 --> 01:28:49.969
使用公钥和任何公开方式都没问题，但私钥不行。

818
01:28:49.969 --> 01:28:52.008
这就是我们签署事务的方式。

819
01:28:52.008 --> 01:28:54.549
但是请注意，这不是我们发送事务的方式。

820
01:28:54.549 --> 01:29:01.495
这只是分配给它创建一个事务来发送，我们稍后会学习如何发送这些事务。

821
01:29:01.495 --> 01:29:01.680
酷。

822
01:29:01.680 --> 01:29:03.888
所以那里也有很多信息。

823
01:29:03.888 --> 01:29:17.727
让我们快速回顾一下，你的公钥是通过在你的私钥上使用数字签名算法得到的，对吧，你想要一直保持你的私钥是私有的，因为你要用你的私钥来签署交易。

824
01:29:17.727 --> 01:29:26.869
使用您的私钥对事务进行签名时，您是唯一能够实际执行此操作的人，因为您无法从消息签名获得私钥。

825
01:29:26.869 --> 01:29:36.418
然而，使用你的公钥，你可以任何人都可以很容易地验证你签署的签名实际上是你在元掩码中签署的。

826
01:29:36.418 --> 01:29:44.198
我们的私钥位于这个帐户详细信息部分，您只需点击显示私钥并输入您的密码。

827
01:29:44.198 --> 01:29:46.334
你会在这里得到你的私钥。

828
01:29:46.334 --> 01:29:51.841
这里需要注意的是，在使用私钥时，通常需要十六进制形式的私钥。

829
01:29:51.841 --> 01:30:01.872
如果我们要用私钥，比如brownie，我们稍后会讲到，我们需要在前面加上0x这个我们稍后会讲到。

830
01:30:01.872 --> 01:30:05.289
你的账户地址就是由此而来的。

831
01:30:05.289 --> 01:30:12.123
私钥可以创建公钥，公钥可以创建地址。

832
01:30:12.123 --> 01:30:16.373
这里有一个小的或大的障碍。

833
01:30:16.541 --> 01:30:27.386
因为你的私钥，你想保持私有而你的公钥和地址都可以是公开信息。

834
01:30:27.542 --> 01:30:41.067
现在我们对这些区块链的底层发生了什么有了更多的了解，让我们回到我们的交易，再看看这个天然气的事情，我们将看看这里实际发生了什么，特别是天然气，可能有点棘手，让你的头脑理解。

835
01:30:41.067 --> 01:30:43.393
所以如果你不能马上得到它，也不要担心。

836
01:30:43.393 --> 01:30:46.246
当我们看例子的时候，它会变得更有意义。

837
01:30:46.246 --> 01:30:52.705
在我讲之前，我们先来看交易费竞价，它是与运行交易相关的成本。

838
01:30:52.705 --> 01:31:07.234
如果我在以太扫描上滚动这个，我可以看到这个东西，说的是区块基础费每气加最大派对费每气乘以气的使用量，这可能有点令人困惑，让我们实际分解Aetherium上的情况，ERP 15, 5 9。

839
01:31:07.234 --> 01:31:11.831
再次强调，这是特定于Aetherium的，因为每个区块链可能会有一点不同。

840
01:31:11.831 --> 01:31:17.415
但如果我们点击查看更多，我们可以看到一些有用的值，我们可以看到气体上限是21,000。

841
01:31:17.415 --> 01:31:19.382
使用量是21,000。

842
01:31:19.382 --> 01:31:26.455
这个交易用了21,000汽油，我们也送了21,000汽油。

843
01:31:26.548 --> 01:31:29.976
有时在发送事务时，这取决于它是何时发送的。

844
01:31:29.976 --> 01:31:35.695
根据具体的说明，它可能会比你想要的消耗更多的气体。

845
01:31:35.695 --> 01:31:44.909
在你的交易中，你可以设置一个限制，嘿，我不想用超过x的气体，我不想用超过x的计算单位。

846
01:31:44.909 --> 01:31:47.411
事实上，我们去了我们的Metamask。

847
01:31:47.411 --> 01:31:52.736
然后我们点击发送再次在账户之间转账，然后我们选择0。

848
01:31:52.736 --> 01:32:15.776
01 eath，或者下一步可以点击这个小按钮，进入高级，我们可以编辑这个交易的一些细节，其中一个是气体限制，我们可以将这个气体限制修改为2200 2300，或更多或更少，因为发送Aetherium需要21000 gas Metamask默认设置为这个。

849
01:32:15.776 --> 01:32:20.937
我们还看到了其他有趣的东西，我们看到了优先费，和最大基础费。

850
01:32:20.937 --> 01:32:23.244
让我们拒绝这笔交易。

851
01:32:23.244 --> 01:32:26.626
让我们回顾一下以太扫描来讨论这些。

852
01:32:26.626 --> 01:32:35.729
所以目前在Aetherium中，根据EE IP 1559, Aetherium上的每笔交易都有一个叫做基础费的东西。

853
01:32:35.729 --> 01:32:40.490
这是您需要设置的最低汽油价格，以包括您的交易。

854
01:32:40.555 --> 01:32:44.037
你会注意到这些都是以网关来定价的。

855
01:32:44.037 --> 01:32:48.046
那么什么是网关呢?如果我们来到网站eath转换器。

856
01:32:48.046 --> 01:32:48.209
com。

857
01:32:48.209 --> 01:33:02.033
同样，在GitHub存储库中有一个链接，我们向下滚动，可以看到路网关和以太5把一个以太放在这里，我可以看到一个以太有多少路。

858
01:33:02.033 --> 01:33:06.786
从方式上来说，一个以太等于1-234-567-8990。

859
01:33:06.786 --> 01:33:13.891
所以这是这是10亿路就是一个以太。

860
01:33:13.891 --> 01:33:22.203
然后1-234-567-8910 1112 1314做了16 7,8队，然后18零就走了。

861
01:33:22.203 --> 01:33:28.140
这些都是指非常非常少量的Aetherium的更简单的方法。

862
01:33:28.140 --> 01:33:32.463
看看汽油费，基本费用是0。

863
01:33:32.463 --> 01:33:34.269
00000004走开。

864
01:33:34.269 --> 01:33:41.544
如果以重量为单位这个数字显然会更小。

865
01:33:41.544 --> 01:33:49.148
如果我们取这个数，把它输入计算器，我们可以看到它等于40的重量或0。

866
01:33:49.148 --> 01:33:52.193
0000，以太的一堆零。

867
01:33:52.193 --> 01:33:58.681
这里的最高费用是指我们愿意为这笔交易支付的最高汽油费。

868
01:33:58.681 --> 01:34:06.218
你可以看到我们的最高费用比我们最终支付的稍微高一些。

869
01:34:06.218 --> 01:34:07.459
最大值是2。

870
01:34:07.459 --> 01:34:12.236
2132什么的，我们实际支付的汽油价格在这里。

871
01:34:12.236 --> 01:34:17.617
现在你的交易可能会有一点不同另外我们有一个最高优先费。

872
01:34:17.617 --> 01:34:22.898
这将是我们愿意支付的最大煤气费加上我们愿意给矿工的最大小费。

873
01:34:22.898 --> 01:34:31.016
现在在以太币中，这个基本费用最终会被消耗掉，我们可以在以太币扫描上看到消耗掉的确切数量。

874
01:34:31.016 --> 01:34:44.107
如果我们再打开计算器，我们可以取这个汽油费，乘以我们使用的汽油量，我们可以看到这确实是我们最终燃烧的Aetherium。

875
01:34:44.107 --> 01:34:49.873
我们回到以太坊转换器，把它粘贴进去，我们可以看到这两个数字确实是相等的。

876
01:34:49.873 --> 01:34:58.568
这意味着无论何时你发送一笔交易，都有一小部分Aetherium将永远退出流通，或者被视为烧毁。

877
01:34:58.568 --> 01:35:03.902
所以目前，理论上作为Aetherium的一部分你的交易费用的一部分实际上会被烧掉。

878
01:35:03.902 --> 01:35:06.664
另外一部分直接给了矿工。

879
01:35:06.664 --> 01:35:14.466
为了算出矿工得到了多少钱，我们可以用这个数字减去燃烧的量。

880
01:35:14.570 --> 01:35:27.162
这是Etherium为这笔交易支付给Aetherium矿工的金额，你会在下面看到你的交易类型到ERP 15 5 9，这是这些交易的eip 15 5 9版本。

881
01:35:27.162 --> 01:35:31.772
就像我说的，每个区块链都有不同的燃烧费用和燃气过程。

882
01:35:31.772 --> 01:35:56.284
它们都有一些不同，但其中一些是区块链有有限的区块空间进行交易，你的交易被包含在这些区块中的天然气价格会根据需求的多少而变化，Aetherium的基础天然气费会上下变化，取决于有多少人发送交易，以及有多少人想被包含在一个区块中。

883
01:35:56.284 --> 01:35:59.643
如果大量的人想要被包含在一个区块中。

884
01:35:59.643 --> 01:36:02.952
这意味着大量的天然气将会被燃烧。

885
01:36:02.952 --> 01:36:15.836
我们在GitHub存储库中留下了一个视频链接，该视频来自一位youtube用户，他出色地分解了EIP 15、5、9以及更多关于气体模型实际如何工作的内容。

886
01:36:15.836 --> 01:36:18.431
我强烈建议大家暂停这个视频，看看那个视频。

887
01:36:18.431 --> 01:36:27.349
为了更好地理解，基本费用将通过编程算法进行调整，以尽量使所有区块的满率达到50%。

888
01:36:27.349 --> 01:36:32.026
如果他们的客座率超过50%，这个基本费用就会自动上升。

889
01:36:32.026 --> 01:36:35.721
如果入住率低于50%，基本费用就会下降。

890
01:36:35.721 --> 01:36:39.110
这就是这个交易的基本原理。

891
01:36:39.110 --> 01:36:40.141
这可能会让人有点困惑。

892
01:36:40.141 --> 01:36:42.631
让我们快速回顾一下这里的内容。

893
01:36:42.631 --> 01:36:48.257
有一个惟一的事务哈希，它惟一地标识这个事务。

894
01:36:48.257 --> 01:36:54.451
在这个区块链上，我们可以看到状态，我们可以看到它被确认的区块号。

895
01:36:54.451 --> 01:36:56.661
我们还想看一件事。

896
01:36:56.661 --> 01:36:59.646
如果我们向上滚动，我们会看到块号和块确认。

897
01:36:59.646 --> 01:37:02.924
这是被开采的区块数。

898
01:37:02.924 --> 01:37:05.065
因为包含了这个块。

899
01:37:05.065 --> 01:37:19.725
就像我们在区块链演示中看到的，区块链变得越长，它就越难被篡改，它通常越安全，你会看到一些进程说他们只会在20个Block确认，30个Block确认或等等之后做一些事情。

900
01:37:19.725 --> 01:37:26.044
他们等待这些块确认的原因是因为他们想要确保该事务实际上被包括在内。

901
01:37:26.044 --> 01:37:36.229
我们可以看到我们的交易所在的区块以及所有与之相关的交易，不同的气体使用量，气体限制等细节。

902
01:37:36.229 --> 01:37:42.535
时间戳是事务发生的时间，我们可以看到从和到我们可以看到的值。

903
01:37:42.535 --> 01:37:51.520
然后我们可以看到交易费用，我们在这里看到的是阻塞的基础费用每气体加上最大优先费用每气体乘以使用的气体。

904
01:37:51.586 --> 01:38:09.397
下面是气体的详细信息，气体价格是每单位气体的成本，气体上限是我们在交易中愿意支付的最大单位气体数量，使用量是我们实际得到的基本费用是每单位气体的基本网络费用。

905
01:38:09.397 --> 01:38:16.808
所以每消耗一种汽油，最大汽油是我们愿意支付的最大汽油价格。

906
01:38:16.808 --> 01:38:22.959
最高优先级是最高天然气价格，加上我们给矿工的小费，然后我们就能看到有多少被烧了。

907
01:38:22.959 --> 01:38:31.056
然后我们看到交易储蓄，这是实际使用或支付的金额和返回的金额之间的差额。

908
01:38:31.056 --> 01:38:38.066
例如，在这个交易中，我们最终选择的汽油价格比这里的最大汽油价格略低。

909
01:38:38.066 --> 01:38:42.743
所以我们最终使用的汽油价格略低于这里的最大优先费。

910
01:38:42.743 --> 01:38:55.942
相比之下，我们节省了一些，我们还可以看到这是一个ERP 15 59的交易，我们可以看到这里的nonce，它不是0因为我展示的交易是我们的第一个none。

911
01:38:55.942 --> 01:39:02.543
当然，我们还可以看到，发送Aetherium的交易的输入数据，输入数据是空白的。

912
01:39:02.593 --> 01:39:06.528
但你会看到，当我们讲到智能合约时，输入数据不会是空的。

913
01:39:06.528 --> 01:39:10.363
这将是这些交易最重要的特征之一。

914
01:39:10.363 --> 01:39:13.117
您还会注意到，这里有一个状态选项卡。

915
01:39:13.117 --> 01:39:19.184
这是一个高级选项卡，它显示了基于此事务更改的不同状态。

916
01:39:19.184 --> 01:39:21.273
我们先忽略这个。

917
01:39:21.273 --> 01:39:27.498
既然我们已经知道了区块链本身的工作原理，让我们来谈谈区块链的一些基本原理。

918
01:39:27.498 --> 01:39:31.396
事实上，我们在之前的Freako夏令营视频中讨论过所有这些话题。

919
01:39:31.396 --> 01:39:34.419
我们来看看这个。

920
01:39:34.596 --> 01:39:39.449
如果你第一次听这个，有些概念似乎有点难以理解。

921
01:39:39.449 --> 01:39:40.826
别担心。

922
01:39:40.826 --> 01:39:47.580
随着课程的继续，当你在实际例子中看到它们时，它们会变得更有意义。

923
01:39:47.580 --> 01:39:57.534
我绝对建议你回去重新看一看，重新听一听那些你在GitHub库的讨论标签中没有得到问题的部分。

924
01:39:57.534 --> 01:39:57.921
太棒了。

925
01:39:57.921 --> 01:40:06.560
现在我们知道了所有的密码学部分以及所有区块链如何工作的细节，以及我们的签名是如何工作的以及所有东西是如何连接在一起的。

926
01:40:06.600 --> 01:40:11.545
让我们来谈谈它是如何工作的，以及到底发生了什么。

927
01:40:11.545 --> 01:40:19.156
对于很多这样的东西，每个不同的区块链都有稍微不同的算法和稍微不同的度量和标准来做很多这样的事情。

928
01:40:19.156 --> 01:40:28.478
所以当我们讨论这些具体的实现时，请记住，确切的算法可能会有一点不同，但概念仍然是完全相同的。

929
01:40:28.478 --> 01:40:30.873
哈希和哈希函数是一样的。

930
01:40:30.873 --> 01:40:39.553
不管你从哪里看去中心化区块链，它都是一样的不管你从哪里看，它是如何实现的，都有一点不同。

931
01:40:39.603 --> 01:40:48.070
传统上，当你运行一个应用程序时，你会是一个连接到服务器的网站或其他东西，你会与一个集中的实体进行交互。

932
01:40:48.070 --> 01:40:55.604
不像我们看到的区块链有多个不同的对等点，它将由一个集中的组运行。

933
01:40:55.604 --> 01:41:07.873
现在，它仍然可以在许多不同的服务器上运行，但所有这些服务器仍将由相同的集中式区块链组控制，就像我们看到的在不同独立节点的网络上运行一样。

934
01:41:07.873 --> 01:41:09.908
当我们看到一个同行，一个同行，B·皮尔西。

935
01:41:09.908 --> 01:41:16.556
这些是不同的独立用户在他们自己的节点上运行区块链技术的不同例子。

936
01:41:16.556 --> 01:41:21.623
现在，当我使用节点这个术语时，我通常是指一个去中心化系统的单个实例。

937
01:41:21.623 --> 01:41:32.561
当我说单个节点时，当我说区块链时，我指的是运行区块链软件的纯a纯b纯C的一个节点，我指的是运行这项技术的一台服务器。

938
01:41:32.561 --> 01:41:34.088
再说一次，就是这个网络。

939
01:41:34.088 --> 01:41:39.085
正是这些节点相互作用的组合，创造了整个区块链。

940
01:41:39.085 --> 01:41:42.436
让这些网络如此强大的是，任何人都可以加入这个网络。

941
01:41:42.436 --> 01:41:49.943
这就是为什么要去中心化进入的障碍是一些硬件要求来获得正确的材料来运行软件。

942
01:41:49.943 --> 01:41:53.150
然后你运行软件，任何人都可以加入这些网络并参与其中。

943
01:41:53.150 --> 01:41:55.363
这就是它真正去中心化的原因。

944
01:41:55.363 --> 01:42:00.226
事实上，你现在就可以到GitHub，并在几秒钟内运行你自己的Aetherium节点。

945
01:42:00.226 --> 01:42:05.149
现在在传统世界中，应用程序由集中的实体运行。

946
01:42:05.149 --> 01:42:14.448
如果这个实体倒闭了，或者被恶意贿赂了，或者他们想要关闭，他们就是不能，因为他们是控制着一切的人。

947
01:42:14.448 --> 01:42:17.709
相比之下，区块链就没有这个问题。

948
01:42:17.709 --> 01:42:31.080
如果运行多个节点的一个节点或一个实体发生故障(因为有很多其他独立的节点在运行，所以没关系)，只要至少有一个节点一直在运行，区块链和系统就会持续存在。

949
01:42:31.080 --> 01:42:38.122
幸运的是，大多数最受欢迎的链，如比特币和以太坊，都有1000个或1000个节点。

950
01:42:38.122 --> 01:42:53.480
正如我们在演示中所展示的，如果一个节点恶意操作，在某些系统中，所有其他节点都会忽略这个节点并将其踢出，甚至惩罚它，因为它们可以很容易地检查其他节点并发现，好吧，这个节点与大多数节点不同步。

951
01:42:53.480 --> 01:42:56.340
是的，当涉及到区块链时，多数决定一切。

952
01:42:56.340 --> 01:43:09.118
每个区块链都有一个完整的列表记录了在区块链上发生的所有交易和交互我们知道如果一个节点试图恶意操作，那么所有的哈希值都将不正常它们不会与其他节点匹配。

953
01:43:09.118 --> 01:43:14.729
这赋予了区块链难以置信的强大的不可变特性，任何东西都无法改变或破坏。

954
01:43:14.729 --> 01:43:19.070
所以本质上，我们可以把区块链看作一个去中心化的数据库。

955
01:43:19.070 --> 01:43:25.848
对于Aetherium，它有一个额外的特性，它也可以以分散的方式进行计算。

956
01:43:25.848 --> 01:43:30.987
现在让我们谈谈共识，工作证明和利益证明因为你们之前可能听过这些。

957
01:43:30.987 --> 01:43:34.482
它们对区块链的实际工作方式非常重要。

958
01:43:34.482 --> 01:43:38.058
我们通过了区块链的例子，我们做了挖掘特性。

959
01:43:38.058 --> 01:43:40.446
这就是所谓的功的证明。

960
01:43:40.446 --> 01:43:49.038
工作证明和牛排证明都属于共识这一范畴，而在区块链方面，共识是一个非常重要的话题。

961
01:43:49.038 --> 01:43:57.675
共识被定义为一种机制，用于就国家或区块链的单一值达成协议，尤其是在去中心化系统中。

962
01:43:57.675 --> 01:44:08.100
我在区块链的例子中简要地提到了这种共识机制，当我说，如果一个改变是值得的，而其他两个不是，那么大多数人就会统治并把它踢出去。

963
01:44:08.100 --> 01:44:10.303
这是共识机制的一部分。

964
01:44:10.303 --> 01:44:26.970
一个区块链或分散系统中的共识协议大致可以被分解成两个部分，一个是链选择算法，一个是内部阻力机制，就是我们正在做的挖掘部分，或者说功的证明算法就是所谓的内部阻力机制。

965
01:44:26.970 --> 01:44:29.731
这是Aetherium和比特币目前使用的。

966
01:44:29.731 --> 01:44:35.362
请注意，这取决于你看这段视频的时间，如果两个都出来了，那么它就不再是作品的证明。

967
01:44:35.362 --> 01:45:01.306
现在,证明的工作被称为公民抵抗机制,因为它定义了一个方法找出块作者是谁,哪个节点是节点工作我发现是谁干的,是作者阻止所有其他节点可以验证它的准确的公民抵抗blockchains能力抵御用户创建大量的伪匿名身份获得不成比例的有利影响是在组系统。

968
01:45:01.306 --> 01:45:09.329
通俗地说，这基本上是一个区块链的一种方式，以防止有人创建一堆假的区块链，以便他们可以获得越来越多的奖励。

969
01:45:09.329 --> 01:45:13.257
现在，有两种类型的公民抵抗机制我们将在这里讨论。

970
01:45:13.257 --> 01:45:15.864
即工作证明和权益证明。

971
01:45:15.864 --> 01:45:19.800
让我们先更深入地谈谈功的证明，功的证明。

972
01:45:19.800 --> 01:45:33.615
这是民事抵抗，因为单个节点必须经过一个非常昂贵的计算过程，称为挖矿，这是我们之前演示过的，以找出区块链的答案，找到正确的nonce，或，或任何区块链系统已有的。

973
01:45:33.615 --> 01:45:34.205
还有工作证明。

974
01:45:34.205 --> 01:45:51.683
这是可行的，因为无论你创建了多少个伪匿名账户，每个账户都必须经历这个计算非常昂贵的活动来寻找功的证明问题的答案，或者功的证明谜题的答案，在我们的演示中，它是找到一个有前四个零的nonce。

975
01:45:51.683 --> 01:45:56.125
但同样的，每个区块链可能会改变谜题的工作或把问题改变得有点不同。

976
01:45:56.125 --> 01:46:05.855
事实上，有些区块链故意让这个谜变得困难或容易，来改变所谓的区块时间，区块时间是指区块发布之间的间隔时间。

977
01:46:05.855 --> 01:46:08.769
它与这些算法的难度成正比。

978
01:46:08.769 --> 01:46:11.127
所以这些问题是可以改变的。

979
01:46:11.127 --> 01:46:13.763
这取决于他们想要区块链多长。

980
01:46:13.763 --> 01:46:19.371
如果一个系统想把时间限制得非常非常长，他们只会让问题变得非常非常难。

981
01:46:19.371 --> 01:46:22.721
如果他们想要非常短，他们会让问题变得容易很多。

982
01:46:22.721 --> 01:46:25.922
我们会稍微讨论一下民事攻击以及它们如何影响系统。

983
01:46:25.922 --> 01:46:31.971
但有了工作证明，这是一种可验证的方法，可以找出区块作者是谁，并进行民事抵抗。

984
01:46:31.971 --> 01:46:35.948
现在，你需要把它和链式选择规则结合起来，形成共识。

985
01:46:35.948 --> 01:46:42.232
现在，有一些共识协议有更多的特性，但非常非常粗略，这是我们将要看的两个部分。

986
01:46:42.232 --> 01:46:45.278
第二部分是链式选择法则。

987
01:46:45.278 --> 01:46:54.801
我们怎么知道哪个区块链是真正的区块链，哪个是真正的区块链在比特币和Aetherium上，它们都使用一种叫做中本共识的共识形式。

988
01:46:54.801 --> 01:47:07.577
这是功的证明和最长链式法则的结合，去中心化网络的那一边，哪个区块链的链最长，或者上面的区块数最多就是他们使用的链。

989
01:47:07.642 --> 01:47:14.575
这是很有意义的，因为每一个区块后面的链，它将需要越来越多的计算出来。

990
01:47:14.575 --> 01:47:18.853
这就是为什么在我们的交易中，我们实际上看到了确认。

991
01:47:18.853 --> 01:47:25.850
确认的数量是在我们的事务在一个块中通过后添加的额外块的数量。

992
01:47:25.850 --> 01:47:33.263
所以如果我们看到确认，这意味着我们的交易所在的区块在最长的链中有两个区块在它前面。

993
01:47:33.263 --> 01:47:37.597
现在，我想指出的是，很多人使用功的证明作为共识协议。

994
01:47:37.597 --> 01:47:43.041
我想说的是，这有一点不准确，但有时人们会互换使用它。

995
01:47:43.041 --> 01:47:48.373
工作量证明是整体共识协议的一部分，在比特币和以太坊中。

996
01:47:48.373 --> 01:47:59.243
目前的一个例子是中本共识，中本共识是工作证明和最长链式法则的结合，两者都非常非常重要。

997
01:47:59.243 --> 01:48:10.035
功的证明还告诉我们这些交易费和区块奖励的去向记住，当我们进行交易时，我们必须讨论天然气和交易费。

998
01:48:10.035 --> 01:48:24.105
那么谁得到了报酬谁得到了这笔交易，这笔交易费将流向矿工或工作证明网络中的验证者?他们被称为矿工在权益证明网络中，他们被称为验证者有一点不同。

999
01:48:24.105 --> 01:48:27.665
当我们讲到功证明系统中的权益证明时我们会讲到这个。

1000
01:48:27.665 --> 01:48:32.486
所有这些节点都在相互竞争，以寻找区块链谜题的答案。

1001
01:48:32.486 --> 01:48:37.037
记住，在我们的例子中，它是要找到一个开头有4个0的散列。

1002
01:48:37.037 --> 01:48:41.962
同样，根据区块链的实现，这个谜语会有一点不同。

1003
01:48:41.962 --> 01:48:47.410
但所有的节点都在尽可能多地尝试先得到这个答案。

1004
01:48:47.410 --> 01:48:53.855
为什么?因为第一个算出区块链雷亚尔答案的节点将获得交易费，他们将从中获得报酬。

1005
01:48:53.855 --> 01:48:57.523
当一个节点得到报酬时，它们实际上是通过两种不同的方式得到报酬的。

1006
01:48:57.523 --> 01:48:59.555
一种是交易费。

1007
01:48:59.653 --> 01:49:01.986
另一块是方块奖励。

1008
01:49:02.653 --> 01:49:16.583
我们在交易中讨论过汽油价格或灰色交易?这是我们要支付给这些区块链节点的交易费，这是区块链协议本身给这些节点的区块奖励。

1009
01:49:16.583 --> 01:49:27.036
你可能听说过比特币腰斩，腰斩指的是区块奖励腰斩，大约每四年腰斩一次。

1010
01:49:27.036 --> 01:49:32.946
这个区块奖励增加了任何被奖励的加密货币的流通数量。

1011
01:49:32.946 --> 01:49:38.542
例如，在Aetherium中，区块奖励是提供Aetherium，而在比特币中，区块奖励是提供比特币。

1012
01:49:38.542 --> 01:49:50.523
所以这些节点相互竞争成为第一个找到交易的节点成为第一个找到问题答案的节点，这样它们就能赢得区块奖励和交易费。

1013
01:49:50.523 --> 01:49:59.970
例如，像比特币这样的区块链有一个固定的时间，当它们不再发放区块奖励时，矿工或节点只会从趋势中获得报酬。

1014
01:49:59.970 --> 01:50:00.756
操作费用。

1015
01:50:00.756 --> 01:50:05.506
这个油费，还是由初始交易的人支付。

1016
01:50:05.506 --> 01:50:12.126
当我们从水龙头取钱的时候，有一个服务器，另一个人为我们支付交易费用。

1017
01:50:12.126 --> 01:50:20.026
然而，当我们从一个帐户向另一个帐户发送以太币时，我们的第一个帐户实际上支付了一些交易费用来发送以太币。

1018
01:50:20.026 --> 01:50:21.105
为了证明牛排。

1019
01:50:21.105 --> 01:50:25.061
还有一笔汽油费，但这笔钱支付给了验证者，而不是矿工。

1020
01:50:25.061 --> 01:50:27.145
我们一会儿会讲到这个。

1021
01:50:27.145 --> 01:50:30.862
现在让我们谈谈在这些区块链世界中可能发生的两种类型的攻击。

1022
01:50:30.862 --> 01:50:33.317
我们先来谈谈西比尔袭击案。

1023
01:50:33.317 --> 01:50:39.292
Sybil攻击是指用户创建一大堆伪匿名账户，试图影响网络。

1024
01:50:39.292 --> 01:50:49.981
现在，很明显，在比特币和以太币上，这是非常非常困难的，因为用户需要做所有这些工作来证明工作，或者有大量的抵押品和股份证明，我们再一次讨论一下。

1025
01:50:49.981 --> 01:50:53.949
另一种更普遍的攻击是51%攻击。

1026
01:50:53.949 --> 01:51:06.038
现在，正如我们看到的，作为我们共识协议的一部分，这些区块链将同意最长的链是他们将要使用的链，只要它匹配网络其余51%的链。

1027
01:51:06.038 --> 01:51:16.428
这意味着如果你有最长的链，并且你有超过51%的网络剩余部分，你可以在网络中做一个所谓的分叉，把网络带到你现在最长的链上。

1028
01:51:16.428 --> 01:51:27.536
显然，当单个节点或单个实体试图通过伪装成多个不同的人来影响网络的正常运行，尽管他们只是同一个人或实体。

1029
01:51:27.536 --> 01:51:31.474
就像我说的，在功的证明和牛排的证明中很难做到。

1030
01:51:31.474 --> 01:51:40.378
所以你现在可以看到，区块链是非常民主的，哪个区块链有最多的购买量，是最长的区块链，整个系统将证实。

1031
01:51:40.378 --> 01:51:49.354
当节点产生一个新的块并添加到最长链中时，其他节点将遵循这个网络中其他节点都同意的最长链，将这些块添加到自己的链中并进行后续操作。

1032
01:51:49.354 --> 01:52:01.202
所以非常小的重组实际上是很常见的，当一个区块链从不同的最长链中选择一个区块，把它放在上面，然后必须将它交换到另一个区块，然后继续使用不同的区块链。

1033
01:52:01.202 --> 01:52:10.350
然而，如果一组节点有足够的节点或足够的能量，它们基本上可以占据网络的51%，并向它们想要的任何方向影响网络。

1034
01:52:10.350 --> 01:52:12.478
这就是所谓的51%攻击。

1035
01:52:12.478 --> 01:52:16.850
这种情况发生在以太坊这样的区块链上，而不是以太坊。

1036
01:52:16.850 --> 01:52:21.617
这就是为什么区块链越大，就越去中心化，越安全。

1037
01:52:21.673 --> 01:52:31.568
在你看完这个视频，成为一个区块链工程专家之后，我绝对建议你运行一个节点，因为你将通过运行一个节点来提高整个网络的安全性。

1038
01:52:31.568 --> 01:52:39.068
因此，工作证明是了不起的，因为它使我们能够非常容易地抵御Sybil的攻击，并保持我们的区块链是去中心化和安全的。

1039
01:52:39.068 --> 01:52:41.625
然而，它也有一些缺点。

1040
01:52:41.625 --> 01:52:49.135
功的证明需要消耗大量的电力，因为每个节点都在以最快的速度运行，以赢得这场竞赛，获得奖励。

1041
01:52:49.135 --> 01:52:52.282
这显然会对环境造成影响。

1042
01:52:52.282 --> 01:53:04.057
自从“工作证明”和“中本共识”之后，许多其他的协议都采用了这个想法，朝着不同的方向发展，采用了不同的民间抵抗协议，其中很多协议的目的都是要更加环保。

1043
01:53:04.057 --> 01:53:06.580
现在最流行的是股权证明。

1044
01:53:06.677 --> 01:53:11.978
有一些连锁店已经在使用这种权益证明协议，而且很活跃，很兴旺。

1045
01:53:11.978 --> 01:53:20.265
其中一些像雪崩，拉拉纳，Polygon, polka dot和Terra，另外Aetherium决定升级到eath。

1046
01:53:20.265 --> 01:53:26.632
第二，它也有权益证明算法，它还有一些其他的特征，我们稍后会讲到。

1047
01:53:26.680 --> 01:53:31.394
说句题外话，我们要学的所有工具在地球上都是有用的。

1048
01:53:31.394 --> 01:53:34.188
第二，这取决于你什么时候看，这里所有的都是有效的。

1049
01:53:34.188 --> 01:53:35.697
我们来谈谈权益证明。

1050
01:53:35.697 --> 01:53:38.618
这又是一种不同的民间抵抗机制。

1051
01:53:38.618 --> 01:53:49.297
权益节点的证明并没有解决这个难题，而是提供了一些他们将诚实行事的抵押品，也就是说，他们以Aetherium为例进行了担保。

1052
01:53:49.297 --> 01:53:58.913
两个节点放置一些Aetherium作为赌注，表示它们将在网络中诚实行事，如果它们在网络中行为不当，它们将被砍掉或删除一些牛排。

1053
01:53:58.913 --> 01:54:01.589
显然，这是一种非常好的民间抵抗机制。

1054
01:54:01.683 --> 01:54:08.250
因为如果你想创建一大堆匿名账户，那么每一个账户，你都需要投入一些资金。

1055
01:54:08.250 --> 01:54:13.636
如果你行为不端，你就有可能失去所有作为抵押品的钱。

1056
01:54:13.684 --> 01:54:20.547
在这个系统中，矿工实际上被称为验证器，因为他们不再绑定任何东西，他们实际上只是验证其他节点。

1057
01:54:20.547 --> 01:54:34.720
现在，不同于工作量证明，每个节点都在竞相成为第一个找到块的节点，利害关系证明节点实际上是随机选择来提出新的块，然后其余的验证器将验证该节点是否提出了块。

1058
01:54:34.720 --> 01:54:43.014
老实说，就像我们在密码学课上看到的那样，其他节点通常很容易验证一个提议或交易是否诚实。

1059
01:54:43.014 --> 01:54:46.720
当我们谈论区块链时，随机性是一个非常重要的话题。

1060
01:54:46.720 --> 01:54:50.114
因为请记住，这些区块链是确定性系统。

1061
01:54:50.114 --> 01:54:52.988
他们是与世隔绝的围墙花园。

1062
01:54:52.988 --> 01:54:57.755
正如你们所知，根据定义，确定性系统不能有随机数。

1063
01:54:57.755 --> 01:55:10.530
那么我们如何选择系统中的随机验证器呢?当它从区块链变到区块链时，实际上选择节点会把区块链变到区块链，但这两个，他们使用的是兰德怀疑，至少在最初的实现中是这样。

1064
01:55:10.530 --> 01:55:17.893
这是一个分散的自治组织，它共同选择随机数并共同选择哪个节点将运行。

1065
01:55:17.893 --> 01:55:22.585
接下来，我们不打算深入讨论这个问题，因为这很有可能在未来发生改变。

1066
01:55:22.585 --> 01:55:25.991
但我们在这门课后面会讲到随机解和区块链。

1067
01:55:25.991 --> 01:55:31.992
权益证明显然也有优点和缺点，优点是，这是一个很好的公民抵抗机制。

1068
01:55:31.992 --> 01:55:34.803
这是一个很好的方法来找出一个块的作者应该是谁。

1069
01:55:34.803 --> 01:55:45.015
另一个优点是计算出新块的计算成本更低，因为不是网络上的每个节点都要做这个，只需要一个节点做这个。

1070
01:55:45.015 --> 01:55:48.145
然后剩下的节点只需要验证它。

1071
01:55:48.145 --> 01:55:55.134
缺点是，它通常被认为是一个不太分散的网络，因为它的前期参与成本。

1072
01:55:55.134 --> 01:56:00.456
现在，这就进入了一场哲学之争，关于如何去中心化才算足够的去中心化。

1073
01:56:00.456 --> 01:56:02.773
我认为这应该由社区来决定。

1074
01:56:02.773 --> 01:56:07.000
随着我们的进步，我想我们会越来越多地了解到去中心化是如何足够去中心化的。

1075
01:56:07.000 --> 01:56:14.264
不过，区块链工程师之间的普遍共识是，股权证明非常非常分散，非常安全。

1076
01:56:14.264 --> 01:56:19.646
这种大规模的环境影响改善是地球转向地球的两个主要原因之一。

1077
01:56:19.697 --> 01:56:21.911
第二，它减少了高达99%的环境影响。

1078
01:56:21.911 --> 01:56:26.397
现在，这些是工作量证明和权益证明的主要部分。

1079
01:56:26.397 --> 01:56:31.001
但我确实想谈谈另一个概念，它在这些生态系统中非常重要。

1080
01:56:31.001 --> 01:56:32.309
这就是可扩展性。

1081
01:56:32.309 --> 01:56:44.190
当我们讨论汽油价格时，我们说过如果很多人想要发送一个交易，汽油价格会非常高，因为一个区块只有这么多的黑空间，节点只能添加这么多的音符。

1082
01:56:44.190 --> 01:56:48.604
所以当很多人想使用区块链时，汽油价格就会飙升。

1083
01:56:48.604 --> 01:56:57.278
这不是很有伸缩性，因为如果我们想把越来越多的人加入到这些区块链中，使用区块链的成本就会越来越高。

1084
01:56:57.278 --> 01:57:00.401
因为越来越多的人想要进入这些街区。

1085
01:57:00.401 --> 01:57:07.210
这意味着有多少人可以使用这个系统是有上限的，因为随着天然气价格的不断上涨，财政限制会强加给他们。

1086
01:57:07.210 --> 01:57:16.202
Aetherium也在通过转换为牛排证明来攻击工作证明对环境的影响，而且他们还在实施一种叫做分片的新方法。

1087
01:57:16.202 --> 01:57:31.780
而切分是可扩展性问题的解决方案，切分的区块链实际上只是意味着它将是区块链的区块链，有一个主链，它将协调连接到这个主链上的多个链之间的一切。

1088
01:57:31.780 --> 01:57:51.838
这意味着有更多的链供人们进行交易有效地增加块空间的数量分片可以大大增加区块链第一层的交易数量现在还有一个术语可能是你第一次听到，第一层，我们将很快讨论第一层和第二层的可伸缩性。

1089
01:57:51.838 --> 01:58:03.948
第一层是指基础层区块链实现比特币，第一层是Aetherium，第一层是雪崩，第一层是基础层区块链解决方案。

1090
01:58:03.948 --> 01:58:10.199
第二层是添加在区块链上的第二层之上的任何应用程序。

1091
01:58:10.199 --> 01:58:14.508
第二层的一些例子是链条套利，或者乐观主义。

1092
01:58:14.508 --> 01:58:21.209
套利和乐观主义非常有趣，因为它们是第二层，也希望解决可伸缩性问题。

1093
01:58:21.209 --> 01:58:32.219
套利和乐观就是所谓的卷升，他们把交易卷成一层，就像Aetherium，我们不打算深入讲卷升以及它们是如何运作的。

1094
01:58:32.219 --> 01:58:40.578
但你真正需要知道的是，上卷有点像分片链，它们的安全性来自基础层来自第1层，就像Aetherium。

1095
01:58:40.578 --> 01:58:51.966
它们将事务批量发送到第一层，它们通过成为另一个区块链解决了一些可伸缩性问题人们可以在上面进行事务，仍然是在这个基础的Aetherium层上。

1096
01:58:51.966 --> 01:58:53.949
它们和侧链不同。

1097
01:58:53.949 --> 01:59:01.024
因为侧链的安全性来自它们自己的协议，卷集，它们的安全性来自底层。

1098
01:59:01.024 --> 01:59:05.126
举例来说，套利和乐观主义将和Aetherium一样安全。

1099
01:59:05.126 --> 01:59:10.604
这里有一些很棒的家伙，他们更深入地研究了翻滚，我在描述中给你留了一个链接。

1100
01:59:10.604 --> 01:59:13.026
好了，我们刚刚谈了很多东西。

1101
01:59:13.026 --> 01:59:15.713
在继续之前，让我们快速回顾一下。

1102
01:59:15.713 --> 01:59:34.979
Aetherium和比特币目前都是遵循中本共识的工作量证明区块链，然而，Aetherium正在转移到Aetherium 2，这将是股权分片的区块链的证明，由于工作证明和牛排证明等协议，Sybil攻击被阻止了51%的攻击随着区块链的大小越来越难。

1103
01:59:34.979 --> 01:59:47.289
所以你应该运行一个节点共识机制，它允许区块链对区块链的状态达成一致，分片和卷集是第一层可伸缩性问题的解决方案。

1104
01:59:47.289 --> 01:59:51.568
第一层是任何基于区块链的实现，如比特币或Aetherium。

1105
01:59:51.568 --> 01:59:57.468
区块链可伸缩性的一个问题是，对于想要进入其中的事务数量，总是没有足够的块空间。

1106
01:59:57.468 --> 02:00:04.628
这导致了非常高的汽油价格，再一次，汽油价格或与区块链互动的成本。

1107
02:00:04.719 --> 02:00:09.409
以上就是区块链的基础知识和区块链的解释。

1108
02:00:09.409 --> 02:00:16.769
有了这些信息，你现在就可以进入世界，开始与区块链打交道，并与区块链进行交互。

1109
02:00:16.769 --> 02:00:24.524
至少对发生的事情有一定程度的了解，你应该为自己能走到这一步而感到无比自豪。

1110
02:00:24.524 --> 02:00:29.221
一定要给自己一个表扬和一轮掌声。

1111
02:00:29.221 --> 02:00:34.932
现在我们已经掌握了很多基础知识和基本方法，让我们开始进入编码方面。

1112
02:00:34.932 --> 02:00:43.573
在这里，你将学习如何在这些区块链中构建智能合约，如何构建信任最小化协议。

1113
02:00:43.573 --> 02:00:45.373
并且在智能合约平台上。

1114
02:00:45.373 --> 02:00:58.649
下一节，稳定性基础，稳定性基础这一节将教给你所有的技能，让你开始实际编写稳定性代码，并理解这些智能合约是如何在底层工作的。

1115
02:00:58.649 --> 02:01:12.797
所以在这一点上，绝对要给自己一个击掌，也许在GitHub的讨论中打招呼，也许在社区中打招呼，在Twitter上，在Reddit上，等等，并为走到这一步感到自豪，旅程真的才刚刚开始，但你已经学到了很多。

1116
02:01:12.797 --> 02:01:14.868
让我们开始下一节。

1117
02:01:14.868 --> 02:01:19.516
让我们进入代码。

1118
02:01:19.727 --> 02:01:26.477
现在我们进入了编码部分，我需要强调绝对要使用与本课程相关的GitHub存储库。

1119
02:01:26.477 --> 02:01:32.540
如果你来到GitHub回购，向下滚动，点击我们正在上的课程，我们正在上第二课。

1120
02:01:32.540 --> 02:01:34.602
欢迎混音，简单收纳。

1121
02:01:34.602 --> 02:01:41.462
如果你点击它，它会给你大量的时间戳和其他与本课相关的有用链接。

1122
02:01:41.462 --> 02:01:47.499
此外，最大的一点是，所有的代码都将在课程标题的正下方可用。

1123
02:01:47.499 --> 02:01:54.697
这将包含我们将要使用的所有代码，以及关于如何使用这些代码的更多附加信息。

1124
02:01:54.697 --> 02:02:02.108
不过，在提问和参与讨论时，请提问和完整的区块链坚实性课程库。

1125
02:02:02.108 --> 02:02:02.485
谢谢你！

1126
02:02:02.485 --> 02:02:07.431
如果我们在资源库的顶部，向下滚动，我们有这部分的资源。

1127
02:02:07.431 --> 02:02:13.619
这就引出了GitHub讨论，你可以在本课程的GitHub讨论部分提问。

1128
02:02:13.619 --> 02:02:18.698
此外，在Stack Exchange、Aetherium或Stack Overflow上。

1129
02:02:18.698 --> 02:02:39.887
我会讲一点关于如何格式化问题和提问的最佳方式，这样你就有最高的机会在后面的课程中得到一个好的答案，我强烈建议你暂停，现在就为Stack Exchange Aetherium, Stack Overflow和GitHub创建帐户，如果你还没有，当然，可以在我们的GitHub存储库中找到它们的链接。

1130
02:02:39.887 --> 02:02:50.529
通常，对于每个编码部分，我将以快速概述我们将要使用的代码和我们将要构建的内容作为开始，因为我们所做的一切都将基于项目。

1131
02:02:50.529 --> 02:02:51.671
这就是我们学习的方法。

1132
02:02:51.736 --> 02:02:58.323
对于我们的第一首和混音，我们会跳过它因为有很多东西要习惯。

1133
02:02:58.323 --> 02:03:00.805
现在，我强烈建议在我编写代码的时候。

1134
02:03:00.805 --> 02:03:06.112
当我在混音中做这些的时候，你们跟着我一起写代码。

1135
02:03:06.112 --> 02:03:09.885
记住，如果我编码太快或太慢，你可以改变我的速度。

1136
02:03:09.885 --> 02:03:12.238
首先，我们将跳到一个叫做remix的工具。

1137
02:03:12.238 --> 02:03:17.345
如果你不确定怎么做，在我们的GitHub知识库中有一个混合链接。

1138
02:03:17.345 --> 02:03:20.771
这是我们要写所有代码的地方。

1139
02:03:20.771 --> 02:03:25.148
欢迎来到混合IDE，或集成开发环境。

1140
02:03:25.148 --> 02:03:29.707
我们将在这里学习如何编写代码并与智能合约交互。

1141
02:03:29.707 --> 02:03:33.182
如果你愿意，你可以继续并接受帮助的混音。

1142
02:03:33.182 --> 02:03:40.062
如果你以前从未上过这门课，它会给你一个快速的回顾，一些混音的工具，我们现在会跳过它们。

1143
02:03:40.062 --> 02:03:41.874
因为我会解释所有上升的东西。

1144
02:03:41.874 --> 02:03:48.791
Remix是一个非常强大的工具，因为它有很多特性，可以让我们真正地看到并与智能合约进行交互。

1145
02:03:48.791 --> 02:03:53.542
最终，我们会离开混音，转向本地开发环境。

1146
02:03:53.542 --> 02:03:57.955
然而，混音对于学习固体的基本原理是非常棒的。

1147
02:03:57.955 --> 02:04:01.447
我强烈建议大家在开始的时候先从混音开始。

1148
02:04:01.447 --> 02:04:06.366
当你使用混合集成开发环境时，会有很多不同的东西向我们蹦出来。

1149
02:04:06.366 --> 02:04:08.310
还有很多不同的插件。

1150
02:04:08.310 --> 02:04:14.029
因为我们将使用坚固性，这将是我们用来开发智能合约的语言。

1151
02:04:14.029 --> 02:04:19.914
我们可以点击solididity插件开始，一些其他的工具会出现在旁边。

1152
02:04:19.914 --> 02:04:28.697
即使你不点击solididity插件，你仍然可以编写solididity智能合约，左手边是我们开始实际与事物交互的地方。

1153
02:04:28.697 --> 02:04:42.484
左上方最上方的按钮是我们的文件或探索目录，remix是带有不同契约、不同脚本、不同测试和不同依赖关系的样板。

1154
02:04:42.484 --> 02:04:44.665
我们要把它最小化一点。

1155
02:04:44.665 --> 02:04:50.640
因此，如果你想继续，右键点击并删除除合同文件夹之外的其他文件夹，请随意。

1156
02:04:50.640 --> 02:04:54.663
或者如果你喜欢他们，也可以把他们留下。

1157
02:04:54.663 --> 02:05:02.099
我们会留下合约文件夹然后删除里面的不同文件这样我们就可以从头开始了。

1158
02:05:02.099 --> 02:05:08.132
大多数项目都带有自述文件。

1159
02:05:08.132 --> 02:05:09.536
通常是自述。

1160
02:05:09.536 --> 02:05:12.637
Md，它通常解释如何实际使用代码。

1161
02:05:12.637 --> 02:05:14.902
但为了我们的目的，我们要把这个也删掉。

1162
02:05:14.902 --> 02:05:16.184
你可以跟着我走。

1163
02:05:16.184 --> 02:05:29.571
现在我们有一个空白的混音设置，点击合同文件夹，点击小页面图标创建一个新文件，一个小框会弹出，你可以开始输入文本。

1164
02:05:29.571 --> 02:05:44.203
我们会输入simple storage。Sol，。Sol告诉编译器这将是一个固态文件，我们将用这个固态是智能合约的主要编码语言。

1165
02:05:44.203 --> 02:05:47.015
还有其他一些智能合约语言。

1166
02:05:47.015 --> 02:05:51.944
但到目前为止，稳固性是最主要的智能合约编码语言。

1167
02:05:51.944 --> 02:05:57.592
现在我们有了一个简单的存储。灵魂契约在右边我们可以开始用它来编码我们的固体。

1168
02:05:57.592 --> 02:05:59.915
让我们开始编码一些固体。

1169
02:05:59.915 --> 02:06:08.691
如果你点击文件按钮正下方的这个按钮它看起来像固体标志，你会看到一堆东西弹出在这里。

1170
02:06:08.756 --> 02:06:13.506
这些是我们编译固体性代码的不同参数，这样我们就可以运行它。

1171
02:06:13.506 --> 02:06:20.502
所以在任何可靠智能合约中，你首先需要的是你将要使用的可靠版本。

1172
02:06:20.502 --> 02:06:27.554
这应该总是在你的实体代码的顶部，实体是一种不断变化的语言，它会不断更新。

1173
02:06:27.554 --> 02:06:36.681
因为与其他语言相比，它相对较新，我们需要告诉我们的代码，嘿，这是我想让你使用的版本，我们可以通过pragma添加固体版本。

1174
02:06:36.681 --> 02:06:37.373
坚固。

1175
02:06:37.373 --> 02:06:44.127
然后我们想用的版本，如果我们想选择一个非常具体的版本，我们可以说(0,8)

1176
02:06:44.127 --> 02:06:44.232
7.

1177
02:06:44.232 --> 02:06:48.232
到目前为止的最新版本是0。

1178
02:06:48.232 --> 02:06:48.337
8.

1179
02:06:48.760 --> 02:06:49.160
12点。

1180
02:06:51.760 --> 02:06:56.460
是很好的实践，不同版本的坚固性被认为比其他版本更稳定。

1181
02:06:56.460 --> 02:06:57.110
零点8。

1182
02:06:57.110 --> 02:07:00.357
7是被认为更稳定的版本之一。

1183
02:07:00.357 --> 02:07:10.079
这里的双斜杠被称为注释，在这些地方你可以输入一些实际上不会被执行的东西不会被编译，不会被真正视为代码的一部分。

1184
02:07:10.079 --> 02:07:13.015
例如，我可以写Hello all。

1185
02:07:13.015 --> 02:07:13.967
我是帕特里克。

1186
02:07:13.967 --> 02:07:18.709
如果我们要运行这段代码，这部分代码会被完全忽略。

1187
02:07:18.709 --> 02:07:21.920
双反斜杠就是我们做注释的方式。

1188
02:07:21.920 --> 02:07:46.265
和我们的编码,我们建筑项目,一定要充分利用这个评论工具每次写一个新函数,或者你学的东西你不懂,或者你学到了新的东西,你要记住,把它放在一个评论在你的代码中,你将是最有效的记笔记在本课程中,通过他们的评论在你的代码,然后保存你的代码,这样你可以参考回来。

1189
02:07:46.265 --> 02:07:49.239
所以在代码中留下注释，在代码中留下注释。

1190
02:07:49.239 --> 02:07:54.104
当你以后想要引用它的时候这将是理解你在写什么的最好的方法之一。

1191
02:07:54.104 --> 02:08:01.488
现在当涉及到固体度的形式时，实际上有几种不同的写法，我们可以说我们只想用零点8。

1192
02:08:01.488 --> 02:08:01.569
7.

1193
02:08:01.569 --> 02:08:04.519
这就是我们的写法。

1194
02:08:04.767 --> 02:08:08.830
但是如果我们用一个比0。8更新版本的固体度，也许可以。

1195
02:08:08.830 --> 02:08:14.498
7告诉我们的代码我们可以接受更多的新版本，我们可以在这里放一个小插入。

1196
02:08:14.498 --> 02:08:16.816
这就是我们分辨固体的方法。

1197
02:08:16.816 --> 02:08:19.477
嘿，零点8的任何版本。

1198
02:08:19.477 --> 02:08:22.235
就这份合同而言，以上内容就可以了。

1199
02:08:22.235 --> 02:08:23.835
这意味着0,8。

1200
02:08:23.835 --> 02:08:25.821
等于0。

1201
02:08:25.821 --> 02:08:26.084
９ ０．

1202
02:08:26.084 --> 02:08:27.400
8点10点等等。

1203
02:08:27.400 --> 02:08:30.145
但如果我们想只用0。

1204
02:08:30.145 --> 02:08:42.623
17，我们可以这样输入如果我们想在特定范围内使用固体度版本，我们可以这样做，我们可以说我们想要固体度版本大于或等于0。

1205
02:08:42.623 --> 02:08:45.377
但小于0,9。

1206
02:08:45.377 --> 02:08:45.475
0.

1207
02:08:45.771 --> 02:08:49.855
这意味着从0到8之间的任何编译器。

1208
02:08:50.772 --> 02:08:51.318
9点。

1209
02:08:51.318 --> 02:08:52.255
0可以。

1210
02:08:52.255 --> 02:08:54.130
这意味着0,8。

1211
02:08:54.130 --> 02:08:55.067
8行。

1212
02:08:55.772 --> 02:08:56.355
8点。

1213
02:08:56.355 --> 02:08:57.521
9可以等于0。

1214
02:08:57.521 --> 02:08:59.271
8点10就可以了。

1215
02:09:00.773 --> 02:09:00.865
9.

1216
02:09:00.865 --> 02:09:05.941
0不成立，因为它不是严格小于0。

1217
02:09:06.773 --> 02:09:07.281
00点9分。

1218
02:09:07.281 --> 02:09:08.349
1也不行。

1219
02:09:09.774 --> 02:09:12.274
我们用(0,8)

1220
02:09:12.274 --> 02:09:12.345
8.

1221
02:09:13.774 --> 02:09:21.936
完成的固体，每一个完成的部分都需要以分号结束这就是你告诉固体它是行结束的方式。

1222
02:09:21.936 --> 02:09:27.464
此外，在代码的顶部，您还需要放置所谓的spdx许可标识符。

1223
02:09:27.464 --> 02:09:32.490
这是可选的，但是一些编译器会标记你没有这样的警告。

1224
02:09:32.490 --> 02:09:35.617
这使得授权和共享代码更加容易。

1225
02:09:35.617 --> 02:09:54.727
本节课的GitHub知识库中有一个关于许可证如何工作的链接来做spdx许可证标识符，我们就说spdx许可证标识符，我们选择MIT, MIT许可证是限制最少的许可证之一。

1226
02:09:54.778 --> 02:10:08.429
我们的大部分代码样本都使用MIT许可一旦你有了一个版本一旦你写了这么多，我们就可以继续写到编译器选项卡下拉，点击编译，这个小转折就会出现。

1227
02:10:08.429 --> 02:10:12.180
我们马上就会看到，这个契约正在被编译。

1228
02:10:12.180 --> 02:10:19.408
因为我们实际上没有合约，所以我们还没有看到合约被编译，但是我们看到编译器自动切换到零点8。

1229
02:10:19.408 --> 02:10:19.475
8.

1230
02:10:19.475 --> 02:10:31.443
编译我们的代码意味着把我们更容易读懂的代码，比如pragma, solidity，并把它转换成计算机代码，或者非常具体的计算机使用指令。

1231
02:10:31.443 --> 02:10:37.485
我们将在后面的部分中讨论很多机器级代码或计算机级代码的作用。

1232
02:10:37.485 --> 02:10:42.021
如果你用的是Mac，你也可以点击S命令，它也会为你运行编译器。

1233
02:10:42.021 --> 02:10:47.449
在Windows上，它可能是Ctrl S，我们可以选择我们想要使用的编译器版本。

1234
02:10:47.449 --> 02:10:50.976
但是，如果我们在代码中指定使用0，点8。

1235
02:10:50.976 --> 02:10:55.646
8，我们点击编译按钮，它会自动切换到0点8。

1236
02:10:55.646 --> 02:10:55.697
8.

1237
02:10:55.697 --> 02:11:00.879
然而，如果我们用胡萝卜的东西，我们会明确地说，嘿，我们想要0。

1238
02:11:00.879 --> 02:11:06.191
8点10，我们可以点击编译，它会编译为0。

1239
02:11:06.191 --> 02:11:06.869
8点10。

1240
02:11:06.869 --> 02:11:15.703
因为，记住，胡萝卜说我们至少要用0，点8，一直到0的最新版本。

1241
02:11:15.703 --> 02:11:15.786
8.

1242
02:11:15.786 --> 02:11:18.369
现在让我们停留在(0,8)上。

1243
02:11:18.369 --> 02:11:18.452
8.

1244
02:11:18.787 --> 02:11:21.208
我们在代码中要做的下一件事是定义契约。

1245
02:11:21.208 --> 02:11:25.453
要获得全屏视图，你可以点击编译器按钮把它去掉。

1246
02:11:25.453 --> 02:11:28.684
要开始定义我们的合同，我们要写contract这个词。

1247
02:11:28.684 --> 02:11:40.498
这告诉稳固性下一段代码将是一个契约契约是稳固性中的一个关键词，它告诉编译器这段代码的下一段将定义一个契约。

1248
02:11:40.498 --> 02:11:46.249
您可以将契约视为任何面向对象编程(如Java或JavaScript)中的类。

1249
02:11:46.249 --> 02:11:52.724
我们给契约起个名字，RS简单存储。

1250
02:11:52.724 --> 02:11:56.947
然后加上这个左右花括号。

1251
02:11:56.947 --> 02:12:02.130
左右花括号内的所有内容都是合约的内容。

1252
02:12:02.130 --> 02:12:02.933
简单的存储。

1253
02:12:02.933 --> 02:12:07.613
现在，如果我们继续，点击命令S或Ctrl S，我们可以看到这个绿色的小标记出现了。

1254
02:12:07.613 --> 02:12:14.949
如果您没有，您总是可以返回到编译器选项卡，向下滚动并点击Compile，看到小的绿色复选标记。

1255
02:12:14.949 --> 02:12:18.809
那个绿色的小标记意味着我们的代码编译成功了。

1256
02:12:18.809 --> 02:12:23.078
如果没有任何错误，我们可以假设现在就部署这个合同。

1257
02:12:23.078 --> 02:12:25.435
这将是一份有效的合同。

1258
02:12:25.435 --> 02:12:30.687
恭喜你写了第一份合同。

1259
02:12:30.794 --> 02:12:34.277
现在，实体性具有多个不同的类型或基本数据类型。

1260
02:12:34.277 --> 02:12:42.080
如果你去看稳定性文档，它在我们的GitHub仓库里，你可以读到更多关于不同类型的信息。

1261
02:12:42.080 --> 02:12:53.609
四种最基本的类型是布尔型，int型，int型，还有一个地址或字节型，这是一种较低级别的类型，我们稍后会讲到。

1262
02:12:53.609 --> 02:13:01.750
一个布尔型定义了一些true false类型，一个int将是一个无符号整数，这意味着它将是一个不正不负的整数。

1263
02:13:01.797 --> 02:13:07.630
它是正的，我们有一个整数，它可以是正的或负的整数。

1264
02:13:07.630 --> 02:13:13.475
然后我们有一个地址，它将是一个地址，就像我们在元掩码中看到的。

1265
02:13:13.475 --> 02:13:16.486
还有一些其他类型的，稍后你们会学到。

1266
02:13:16.486 --> 02:13:21.764
我们有这些类型的原因是我们用它们来定义不同的变量。

1267
02:13:21.764 --> 02:13:24.667
变量基本上是不同值的持有者。

1268
02:13:24.667 --> 02:13:33.868
例如，我们可以创建一个名为“有最喜欢的数字”的变量来表示某人是否有最喜欢的数字。

1269
02:13:33.868 --> 02:13:44.210
我们会把这个bull关键字放在has to renumber之前比如，我们有一个变量叫做hasfavorite number，它的类型是布尔。

1270
02:13:44.210 --> 02:13:52.411
所以这个favorites number将表示true或false来设置它的值，我们可以说has favorite number = true。

1271
02:13:52.411 --> 02:13:55.318
现在最喜欢的数是真。

1272
02:13:55.318 --> 02:13:58.525
我们也可以说，has favorite number = false。

1273
02:13:58.525 --> 02:14:02.524
这个布尔值已经消褪，现在是假的。

1274
02:14:02.524 --> 02:14:09.703
对于uns，我们可以说你选择了最喜欢的数字等于，然后设置一个数字123。

1275
02:14:09.703 --> 02:14:23.968
这意味着我们最喜欢的数字是123你输入的是特殊的因为我们可以指定要分配多少位给这个数字位和字节是计算机科学中非常基本的信息。

1276
02:14:23.968 --> 02:14:25.385
我们不打算在这里细讲。

1277
02:14:25.385 --> 02:14:29.460
然而，在GitHub知识库中有一个很棒的视频对它做了更多的解释。

1278
02:14:29.460 --> 02:14:33.513
基本上，它是分配给这个数字多少存储空间或内存。

1279
02:14:33.513 --> 02:14:39.999
它能有多大呢，如果我们说一个你int 8可以有8位一直到56。

1280
02:14:39.999 --> 02:14:45.521
如果你不指定它的大小，它会自动默认为256。

1281
02:14:45.521 --> 02:14:49.207
通常情况下，在编写代码时非常明确会更好。

1282
02:14:49.207 --> 02:14:53.536
通常你会看到我用int 256来表示un256。

1283
02:14:53.536 --> 02:14:59.712
我们也可以让一个int型的喜爱数等于123或int型的256。

1284
02:14:59.809 --> 02:15:04.647
我要继续，把这个布尔值加回来，我们要把它改回UNT为36。

1285
02:15:04.647 --> 02:15:31.713
让我们把最喜欢的数字改成5，我们还可以做一些叫做字符串的东西，字符串，文本中最喜欢的数字等于5个字符串代表单词，你可以把它们放在引号里来表示它们，它可以是一些单词或短语，或者真的，真的只是键盘敲击的任何组合，结尾可以是正的或负的。

1286
02:15:31.713 --> 02:15:45.707
我们可以说- 5或+ 5，两者都是有效的，因为我们也可以做addresmaddress =并从Metamask获取我们的地址。

1287
02:15:45.813 --> 02:15:50.980
然后粘贴进去，你会注意到我们用分号来结束这些代码行。

1288
02:15:50.980 --> 02:15:57.068
我们也有bytes对象，或者bytes 32，同样，表示我们希望它们是多少个字节。

1289
02:15:57.068 --> 02:16:06.266
这表示我们调用了favorites bytes，我们将它设为cat。

1290
02:16:06.266 --> 02:16:21.160
字符串实际上很有趣，因为字符串实际上只是字节对象，但只有text to a cat才是字符串，但可以自动转换为这些字节对象字节，对象通常看起来像0x。

1291
02:16:21.160 --> 02:16:28.709
然后是一些表示bytes对象的随机字母和数字，但cat可以自动转换为bytes。

1292
02:16:28.709 --> 02:16:42.475
我们会在以后的课程中更多地讨论字节，你们也可以做字节，2字节，3字节，5字节22，你们知道我们的un的图片了我们的第六低是8位，因为8位是一个字节。

1293
02:16:42.475 --> 02:16:44.115
我们可以上升8阶。

1294
02:16:44.115 --> 02:16:48.157
我们可以做816 32，等等，一直到256。

1295
02:16:48.157 --> 02:16:53.042
例如，在下面这里，我们不能做字节64。

1296
02:16:53.042 --> 02:17:00.463
如果我们继续编译这个，我们会得到一个红色的东西。

1297
02:17:00.463 --> 02:17:06.175
如果向下滚动，我们会得到一个声明错误标识符，没有找到或不是唯一的。

1298
02:17:06.175 --> 02:17:08.446
字节64个最喜欢的字节等于猫。

1299
02:17:08.446 --> 02:17:12.000
我们甚至在我们的混音中得到了一个红色的警告标志。

1300
02:17:12.000 --> 02:17:15.297
这是混音告诉我们这一行有问题。

1301
02:17:15.297 --> 02:17:16.951
所以我们可以换回第32口。

1302
02:17:16.951 --> 02:17:26.013
因为字节32是字节所能达到的最大大小，所以您也可以只做一个字节对象，这意味着它可以有任何大小，但我们通常希望是显式的。

1303
02:17:26.013 --> 02:17:35.485
现在想要了解更多关于不同类型以及如何使用它们以及它们的所有不同特性的知识，请务必查看solididity文档。

1304
02:17:35.485 --> 02:17:39.217
现在，对于我们的简单存储，假设我们只想存储数字。

1305
02:17:39.217 --> 02:17:45.725
我们删掉除收藏号部分外的所有内容。

1306
02:17:45.825 --> 02:17:59.969
现在在固体性中，如果我这样做，我把等于5去掉，这个最喜欢的数字实际上会被设置为一个默认值，固体性的默认值将是空值，在固体性中是零情况。

1307
02:17:59.969 --> 02:18:09.038
所以说你的intuit6个最喜欢的数字和你的256个最喜欢的数字等于0是一样的因为它被初始化为0。

1308
02:18:09.038 --> 02:18:11.564
现在，我们不初始化它。

1309
02:18:11.564 --> 02:18:15.759
所以最喜欢的数字会自动从0开始。

1310
02:18:15.828 --> 02:18:23.201
现在，如果你在写代码的时候感到困惑，一定要在代码中写注释，这样你就知道发生了什么。

1311
02:18:23.201 --> 02:18:30.338
也许，举个例子，一个很好的注释是它最初被化为0。

1312
02:18:30.338 --> 02:18:39.709
如果这让你感到困惑，你可以说，这意味着这部分是注释。

1313
02:18:39.709 --> 02:19:08.433
现在我们来创建一个函数函数或方法是自包含的模块它会在我们调用它的时候为我们执行一组特定的指令如果你熟悉Java, Python, JavaScript或其他类似的东西函数的工作方式是完全相同的函数通过关键字function来识别，让我们创建一个叫store的函数它会将收藏号的值更改为一些新值。

1314
02:19:08.433 --> 02:19:14.889
而我们要改变它的数字将是传递给我们的store函数的变量。

1315
02:19:14.889 --> 02:19:20.965
我们允许store函数取一个类型为un 256的变量。

1316
02:19:20.965 --> 02:19:29.116
我们将它命名为下划线收藏号，我们将它设为公共函数，我们马上就会讲到。

1317
02:19:29.116 --> 02:19:35.353
我们要做的就是将喜爱数设置为我们刚刚传递的变量。

1318
02:19:35.353 --> 02:19:47.722
现在我们有了这个叫store的函数，它接受一些我们要给它的形参它将这个喜爱号变量设为我们给这个函数的任何数字。

1319
02:19:47.722 --> 02:19:52.786
现在，让我们把它部署到一个比测试网更厚的区块链上，看看它的实际效果。

1320
02:19:52.838 --> 02:19:56.663
我们将把它部署到本地网络或JavaScript VM。

1321
02:19:56.663 --> 02:20:03.714
在我们这样做之前，首先我们要确保编译过程是正确的看起来我们有一个绿色的选中标记，这很好。

1322
02:20:03.714 --> 02:20:08.776
我们会看到这个按钮，这是我们的部署和运行事务选项卡。

1323
02:20:08.840 --> 02:20:15.332
我们的部署和运行事务选项卡为实际部署该契约提供了大量不同的配置部分。

1324
02:20:15.332 --> 02:20:25.203
首先，我们要确保我们在JavaScript VM伦敦这一块，JavaScript VM意味着我们要部署到一个伪本地JavaScript VM。

1325
02:20:25.203 --> 02:20:40.859
JavaScript VM是一个假的本地区块链在这里我们可以快速模拟事务而不需要等待它们通过测试网，现在不要担心伦敦和柏林的对比，注入web 3和web 3提供者我们稍后会讲到。

1326
02:20:40.859 --> 02:20:42.746
我们这里也有这个账户区。

1327
02:20:42.843 --> 02:20:51.134
当我们在假的JavaScript VM上运行时，我们得到了一大堆假的帐户，从哪里部署，我们每人得到100。

1328
02:20:51.134 --> 02:21:04.293
对于每一个假账户，你可以认为它类似于我们的元掩码账户中的元掩码，不同的是，这是我们给出的假JavaScript VM Aetherium。

1329
02:21:04.293 --> 02:21:11.422
对于我们的交易，包括部署契约，我们实际上有一个气体限制，还有我们可以发送的值，我们可以选择我们的契约。

1330
02:21:11.422 --> 02:21:16.846
现在我们只有一个契约，简单存储，这将是我们将要部署的。

1331
02:21:16.846 --> 02:21:23.259
在左边，要将这个部署到假的JavaScript VM，我们会点击deploy按钮。

1332
02:21:23.259 --> 02:21:28.561
如果我们一直滚动到底部，现在，我们可以看到一个契约被部署了。

1333
02:21:28.561 --> 02:21:33.192
它说x处的简单存储，等等等等。

1334
02:21:33.192 --> 02:21:51.235
我们看到这个橙色的按钮商店在256中有这个等级文本，在我们的假本地区块链上下划线，我们实际上给了每个智能合约一个地址，它有一个地址，就像我们的钱包有一个地址一样。

1335
02:21:51.235 --> 02:22:03.325
如果我们点击这个复制按钮，把它放到注释中，把它放大一点，我们可以看到我们刚刚部署的契约的地址，位于这个地址。

1336
02:22:03.325 --> 02:22:10.783
另外，如果你拉起这里的滑块，你会看到这个绿色的小标记上面有关于这个部署的所有信息。

1337
02:22:10.783 --> 02:22:14.805
你可以点击下拉菜单看到更多关于这个的信息。

1338
02:22:14.852 --> 02:22:23.116
您可能会注意到，您将看到一些熟悉的关键字，如状态、事务散列、从到气体等。

1339
02:22:23.116 --> 02:22:28.869
当我们部署契约时，它实际上与发送事务相同。

1340
02:22:28.869 --> 02:22:36.484
记住，任何时候我们在区块链上做任何事情，我们修改任何值，我们发送一个事务。

1341
02:22:36.484 --> 02:22:43.613
部署契约就是修改区块链来拥有这个契约，它就是修改区块链的状态。

1342
02:22:43.613 --> 02:22:50.708
如果我们通过Rinkeby，或者COVID，或者主网络发送这个信息，我们将不得不花费大量的汽油来实际部署这个合同。

1343
02:22:50.708 --> 02:23:00.260
这是对gas和事务哈希值的模拟我们的事务有多少，我们把它部署到一个真实的网络中。

1344
02:23:00.260 --> 02:23:03.416
但因为是JavaScript VM，所以都是假信息。

1345
02:23:03.416 --> 02:23:09.367
现在我们有了这个大的橙色按钮商店，这个大的橙色按钮类似于我们刚创建的商店函数。

1346
02:23:09.367 --> 02:23:17.478
如果我们在这个store中添加一些数字，比如123，然后点击store按钮，我们实际上调用这个store按钮。

1347
02:23:17.478 --> 02:23:20.874
我们用假的贾西卡进行交易。

1348
02:23:20.874 --> 02:23:25.674
区块链存储号码1234收藏号码。

1349
02:23:25.859 --> 02:23:32.569
如果我们一直滚动到我们的账户，现在，你会看到我们的假账户中以太币少了一点。

1350
02:23:32.569 --> 02:23:37.463
这是因为我们花了很多时间调用这个合约。

1351
02:23:37.463 --> 02:23:48.710
如果我们把底部的这个，我用5来调用它，我调用store，你会看到它闪了一秒钟，我们发送了另一个事务将值5存储在我们喜爱的数字中。

1352
02:23:48.710 --> 02:24:04.175
现在的问题可能是，这真的很酷，帕特里克，但我看不出最喜欢的数字是什么，我怎么知道这些交易实际上在进行?现在，我们最喜欢的数字的可见性被设为私有，所以我们实际上看不到它。

1353
02:24:04.175 --> 02:24:06.731
我们马上会讲到可见性。

1354
02:24:06.731 --> 02:24:08.371
为了让我们能看到它。

1355
02:24:08.371 --> 02:24:11.244
我们将改变我们最喜欢的数字能见度为公共。

1356
02:24:11.244 --> 02:24:15.553
我们继续，重新编译回到deploy选项卡。

1357
02:24:15.553 --> 02:24:20.293
我们点这里的小x，表示取消合约。

1358
02:24:20.293 --> 02:24:22.373
它只是把它从窗口移走了。

1359
02:24:22.373 --> 02:24:30.818
它并没有从区块链中去除它，因为它们是不可变的，有点不可变，因为这是一个假的模拟链。

1360
02:24:30.866 --> 02:24:34.366
但是我们继续编译，现在我们再次点击Deploy。

1361
02:24:34.866 --> 02:24:38.375
向下滚动，我们的新合约现在有两个按钮。

1362
02:24:38.375 --> 02:24:40.921
一个是橙色的store按钮。

1363
02:24:40.921 --> 02:24:43.544
但是现在我们有了一个新收藏按钮。

1364
02:24:43.544 --> 02:24:51.308
这个按钮代表公共变量收藏号，它就像一个函数，告诉我收藏号是什么。

1365
02:24:51.308 --> 02:24:59.642
如果我点喜欢的数字按钮，你觉得会出现什么?还记得它初始化为什么吗?好了，让我们现在点击它。

1366
02:24:59.642 --> 02:25:06.803
我们确实看到了0，我们看到这是一个YouTube ID 6，它存储的值是0。

1367
02:25:06.869 --> 02:25:24.905
现在，如果我通过调用store函数把这个数改成5，然后点击收藏号，我们确实看到，收藏号被更新为5个函数变量可以有一个作为可见性说明符，我们有public, private, external和internal。

1368
02:25:24.905 --> 02:25:35.014
Public在外部和内部都是可见的，这意味着任何与这个契约交互或看到这个契约的人都能看到这个收藏数函数中存储的内容。

1369
02:25:35.014 --> 02:25:40.813
你会看到在这里的固体性文档中，它说它为存储斜杠状态变量创建了一个getter函数。

1370
02:25:40.813 --> 02:25:55.585
当我们添加关键字public到收藏号时，我们实际上是在为收藏号创建一个getter函数，我们基本上是在创建一个函数来返回收藏号的值，这就是这个蓝色按钮跳出来的原因。

1371
02:25:55.585 --> 02:26:05.417
因为这个蓝色按钮是一个函数，它说，嘿，返回收藏号的值private意味着只有这个特定的契约才能调用这个函数。

1372
02:26:05.417 --> 02:26:11.399
至于存储，这并不意味着只有这个契约可以读取存储在这里的内容。

1373
02:26:11.399 --> 02:26:13.446
我们稍后会讲到这个。

1374
02:26:13.446 --> 02:26:17.260
通过这种方式，这是唯一可以调用收藏号函数的契约。

1375
02:26:17.260 --> 02:26:20.426
私有函数仅对当前契约可见。

1376
02:26:20.426 --> 02:26:27.296
外部函数仅在外部可见，这意味着契约之外的人可以调用该函数。

1377
02:26:27.296 --> 02:26:35.770
内部的意思是只有这个契约和它的子契约能读取它，我们稍后会讲到这个。

1378
02:26:35.770 --> 02:26:38.585
奇怪的是，变量只是函数调用。

1379
02:26:38.585 --> 02:26:45.413
当我们第一次在没有public关键字的情况下部署这个时，我们没有看到收藏号码出现在左边的原因。

1380
02:26:45.413 --> 02:26:51.363
当我们没有为函数或变量提供可见性说明符时，它们会自动作为内部部署。

1381
02:26:51.363 --> 02:26:59.213
正如我们所知，内部函数和变量只能通过这个特定的契约或派生契约调用，我们稍后会讲到。

1382
02:26:59.213 --> 02:27:01.146
我们还是公开吧。

1383
02:27:01.146 --> 02:27:14.830
现在，我们在形参前面加上下划线的原因是告诉我们，这个变量不同于全局喜爱号，形参有一些不同的命名约定。

1384
02:27:14.882 --> 02:27:22.063
随着课程的深入，我们会越来越理解好的参数名称是什么，每次调用这个store函数时。

1385
02:27:22.063 --> 02:27:31.399
我们在这里改变值，我们实际上是在发送一个事务因为记住，每次我们改变区块链的状态，我们都是在一个事务中做的。

1386
02:27:31.399 --> 02:27:33.086
我们可以在这里看到所有的细节。

1387
02:27:33.086 --> 02:27:44.836
如果你转到你的混音的日志记录区域的交易细节，你可以向下滚动，你可以看到以单位汽油为单位的交易成本，你会看到这个周围的一些东西。

1388
02:27:44.885 --> 02:27:49.231
你会注意到，发送Aetherium的数字超过21,000。

1389
02:27:49.231 --> 02:27:52.870
那是因为我们正在做一些计算成本更高的事情。

1390
02:27:52.870 --> 02:27:56.140
我们实际上在这里存储了一个数字。

1391
02:27:56.140 --> 02:28:00.768
如果我们在商店功能内部做更多，你认为会发生什么。

1392
02:28:00.768 --> 02:28:06.807
我们不只是存储这个数，我们还可以把这个数存储在这里。

1393
02:28:06.887 --> 02:28:11.237
然后我们会更新收藏数它会说收藏数等于收藏数加1。

1394
02:28:11.237 --> 02:28:17.221
因为我们要做更多的东西，现在我们应该看到这个store函数变得更贵了。

1395
02:28:17.221 --> 02:28:22.044
让我们重新编译，我们会删除这将重新部署。

1396
02:28:22.044 --> 02:28:26.343
我们现在有一个新的契约将再次存储5。

1397
02:28:26.343 --> 02:28:36.235
现在，如果我们看一下这个交易的细节，我们向下滚动到执行成本，我们确实看到天然气的数量大大增加了。

1398
02:28:36.235 --> 02:28:42.478
这是因为我们要做更多的事情，这个存储函数现在的计算成本更高了。

1399
02:28:42.478 --> 02:28:46.729
就像我说的，每个区块链计算气体的方法都有所不同。

1400
02:28:46.729 --> 02:28:54.606
但最简单的思考方式是，你做的东西越多，交易的成本就越高。

1401
02:28:54.606 --> 02:28:57.842
让我们继续，删除这一行来继续我们的例子。

1402
02:28:57.892 --> 02:29:10.721
现在我们来谈谈作用域，我们最喜欢的数字基本上在一个叫做全局作用域的东西里，这意味着括号里面的任何东西都可以访问这个最喜欢的数字变量。

1403
02:29:10.721 --> 02:29:35.439
但如果我做了这样的事呢?如果我创建一个un256，叫Test var呢?我设它等于5 ?然后我创建了一个新函数，叫做什么它会不带参数，是公共的吗?我可以访问test var，然后将它更改为6之类的东西吗?我们能做到吗?让我们继续，看看编译这个时会发生什么。

1404
02:29:35.439 --> 02:29:37.544
我们实际上遇到了一个错误。

1405
02:29:37.544 --> 02:29:40.696
我们期望的初等表达式在这里。

1406
02:29:40.696 --> 02:29:43.914
那是因为我有个双问号。

1407
02:29:43.914 --> 02:29:44.638
我们现在就试试。

1408
02:29:44.638 --> 02:29:46.509
我们得到未声明的标识符。

1409
02:29:46.509 --> 02:29:54.398
当你创建变量时，我们的something函数不知道test var，它们只能在它们所在的范围内被查看。

1410
02:29:54.398 --> 02:29:57.331
如果你觉得有点困惑，就找花括号。

1411
02:29:57.331 --> 02:30:04.543
这两个花括号包含了这个部分，开头的在上面，结尾的在下面。

1412
02:30:04.543 --> 02:30:11.673
如果我直接在这些花括号里面创建一个变量，这意味着这里的所有东西都可以访问它。

1413
02:30:11.673 --> 02:30:26.884
然而，test var是在这些花括号里面创建的，这意味着只有花括号里面的东西才能访问test var，因为我们的函数有些东西不在store里面，或者函数不知道test var。

1414
02:30:26.884 --> 02:30:32.794
这就是作用域的工作原理，你要看你创建的变量是否在这些花括号内。

1415
02:30:32.794 --> 02:30:37.235
这就是你如何知道其他函数是否可以用它们。

1416
02:30:37.235 --> 02:30:39.144
这就是失败的原因。

1417
02:30:39.144 --> 02:30:53.870
就像我们在文档中看到的，当我们将这个公共变量添加到收藏号时，我们暗中添加了一个函数它只返回收藏号，我们也可以添加自己的函数它也返回收藏号来类似于在后端创建的函数。

1418
02:30:53.904 --> 02:31:00.255
我们可以说function，我们叫它retrieve，我们把它设为公共视图。

1419
02:31:00.255 --> 02:31:05.290
我们说它返回到56。

1420
02:31:05.290 --> 02:31:07.840
或者马上解释一下这是什么意思。

1421
02:31:07.840 --> 02:31:10.114
我们会说，返回最喜欢的数字。

1422
02:31:10.114 --> 02:31:16.633
现在，我要点击命令S，同样的，我在这一节中会做很多次。

1423
02:31:16.633 --> 02:31:21.360
记住，这相当于我到编译选项卡，点击编译。

1424
02:31:21.360 --> 02:31:32.095
如果我们到deploy选项卡，删除上一个，部署一个新的，我们就有了一个检索函数，它会返回和我们最喜欢的数字返回的完全一样的东西。

1425
02:31:32.095 --> 02:31:37.629
如果我们把这个更新为5，叫做favorites number然后检索它们现在都返回5。

1426
02:31:37.629 --> 02:31:43.224
现在你可以看到，这两个函数是蓝色的，但这个函数是橙色的。

1427
02:31:43.224 --> 02:31:56.565
有什么区别?为什么这些有不同的颜色?关键在于这个视图关键字，实际上在固体度中有两个关键字它们表示一个不需要消耗汽油来运行的函数。

1428
02:31:56.565 --> 02:31:59.168
这些关键词是view和pure。

1429
02:31:59.168 --> 02:32:02.071
我们也把这个变量消掉。

1430
02:32:02.071 --> 02:32:09.540
视图函数意味着我们会从这个契约中读取状态，我们会从这个契约中读取一些东西。

1431
02:32:09.540 --> 02:32:17.828
例如，我们的检索函数现在只读取收藏夹号码是多少，视图函数不允许任何状态修改。

1432
02:32:17.828 --> 02:32:21.844
你不能用视图函数更新区块链。

1433
02:32:21.844 --> 02:32:25.142
纯函数也不允许任何状态修改。

1434
02:32:25.142 --> 02:32:27.639
我们不能更新最爱的数字。

1435
02:32:27.639 --> 02:32:30.931
不仅如此，他们还禁止从区块链读取数据。

1436
02:32:30.931 --> 02:32:33.289
所以我们也无法读取最喜欢的数字。

1437
02:32:33.289 --> 02:33:00.983
相反，你可能会对一个纯函数做的是像function，在这里加上public, 1 + 1，或者返回，1 + 1，这将会把你变成36，也许像这样，也许有一些你想要反复使用的数学运算，也许有一些你想要实现的特定算法实际上不需要读取任何存储，等等。

1438
02:33:00.983 --> 02:33:07.850
现在，如果我们调用一个视图函数，或者一个纯函数，我们实际上不需要花费任何精力。

1439
02:33:07.917 --> 02:33:09.435
因为我们只是从区块链读取数据。

1440
02:33:09.918 --> 02:33:15.060
只花汽油，我们只做一个交易，如果我们修改区块链状态。

1441
02:33:15.060 --> 02:33:22.020
你会注意到，在我们下面的小控制台，如果我调用检索，这个调用就会出现。

1442
02:33:22.020 --> 02:33:25.185
但是，它看起来与调用store函数时不同。

1443
02:33:25.185 --> 02:33:30.851
我们调用store函数，我们得到这个小的选中标记，我们得到一个散列，我们没有得到一个小的选中标记。

1444
02:33:30.920 --> 02:33:32.729
我们不会得到调用的哈希值。

1445
02:33:33.920 --> 02:33:36.823
这些蓝色按钮不进行交易。

1446
02:33:37.920 --> 02:33:40.921
嘿，我们要读的是off chain，我们要读的是这个值。

1447
02:33:40.921 --> 02:33:46.056
但是，如果你看一下这个调用的细节，这里有一个执行成本。

1448
02:33:46.056 --> 02:33:52.455
这是怎么回事?我们可以看这部分，成本只适用于契约调用。

1449
02:33:52.455 --> 02:34:02.133
如果我们有一个调用检索的函数，如果有一个更新状态的函数调用一个视图或一个纯函数，这是唯一会消耗汽油的时间。

1450
02:34:02.133 --> 02:34:24.653
举个例子，如果我们的store函数不是视图函数，要在某个点调用检索，那么我们就必须支付检索的代价因为从区块链读取会消耗这个计算和消耗气体调用视图函数是免费的，除非你在一个消耗气体的函数中调用它，在这种情况下它会消耗气体。

1451
02:34:24.653 --> 02:34:31.022
如果我们把它留在这里，我们删除这个recompile redeploy。

1452
02:34:31.022 --> 02:34:34.545
我们找回了最喜欢的号码，它们都是免费的。

1453
02:34:34.545 --> 02:34:48.177
但如果我们在这里添加，恢复8，我们可以看到，我们的执行成本比没有检索时增加了，我们可以继续，我们可以编译，我点击命令我们在这里编译，我们可以部署。

1454
02:34:48.177 --> 02:34:50.760
让我们继续并再次存储。

1455
02:34:50.928 --> 02:34:56.317
我们会点击那个事务，我们会看到没有检索函数，它更便宜。

1456
02:34:56.317 --> 02:35:06.071
同样，我们最喜欢的number变量只要它有这个公共可见实度，它也被计算为返回un 256的视图函数。

1457
02:35:06.071 --> 02:35:16.555
returns关键字的意思是，在我们调用它之后这个函数会给我们什么我们说这个函数会给我们这个函数会返回一个un 256。

1458
02:35:16.555 --> 02:35:22.071
当我们调用检索时，它会返回或给我们一个效用6。

1459
02:35:22.071 --> 02:35:31.818
这是调用函数的结果这是调用任意函数的结果。

1460
02:35:31.932 --> 02:35:35.883
现在我们的契约已经很好了，它允许我们存储单个喜爱号码。

1461
02:35:35.932 --> 02:35:51.088
但如果我们想存储一系列喜爱的数字呢?或者我们想要存储一堆不同的人他们有不同的喜爱数字?我们怎么做呢我们有几种不同的方法来处理这个问题，其中一种方法是通过创建一个所谓的人的结构。

1462
02:35:51.088 --> 02:35:53.157
或者我们创建一个新的类型。

1463
02:35:53.157 --> 02:36:00.606
在我们的实体中，我们可以创建一个people对象，它同时包含某人的姓名和他们最喜欢的数字。

1464
02:36:00.606 --> 02:36:11.221
要做到这一点，我们说struct people，你去56，最喜欢的数字，和一个字符串名。

1465
02:36:11.221 --> 02:36:17.641
现在我们创建了一个新的类型，叫做people，有点像你们直觉的6，或者布尔值，或者字符串。

1466
02:36:17.641 --> 02:36:20.381
现在我们有了一个可以使用的people类型。

1467
02:36:20.381 --> 02:36:27.051
类似于我们创建一个un256的公众收藏号，我们可以做完全一样的事情。

1468
02:36:27.051 --> 02:36:37.034
但是对于people，我们可以说people public，我们叫这个person，我们可以创建一个新的people并把它分配给这个变量person。

1469
02:36:37.034 --> 02:36:46.605
我们写上，等号people，公共person，等号，我们在这里加上括号表示我们要创建一个新的person。

1470
02:36:46.605 --> 02:37:07.241
因为我们把它做成了一个结构体，我们在这里加了小花括号让实体知道我们会从这些结构体变量中抓取，我们会说，favorites number将是2，名字将是Patrick分号，然后我们可以按Ctrl S，或者我们可以继续编译。

1471
02:37:07.241 --> 02:37:20.355
如果我们继续部署这个我们现在有了一个新的person，因为这是一个公共变量，它有一个getter函数叫person。

1472
02:37:20.355 --> 02:37:25.385
点击person，我们会看到新对象，最喜欢的数字是2。

1473
02:37:25.385 --> 02:37:32.751
然后名字是Patrick，看到这个0和这个1了吗，因为它们表示不同变量的下标。

1474
02:37:32.751 --> 02:37:37.485
但是对于刚接触计算机科学的人来说，特别是在计算机科学中，让我们从数字0开始。

1475
02:37:37.485 --> 02:37:42.757
索引为0的是什么呢，我们有256，叫做收藏号，保存在2。

1476
02:37:42.757 --> 02:37:53.407
然后在索引1处，我们有一个字符串，它代表Patrick的名字，当你在一个实体对象中有一个变量列表时，它们会自动被索引。

1477
02:37:53.407 --> 02:37:57.946
最喜欢的数字索引为0，名字索引为1。

1478
02:37:57.946 --> 02:38:10.509
有趣的是，如果你在契约中有一大堆变量，比如我们有公共收藏号，这个收藏号，实际上，从技术上讲，在存储槽的0处被索引。

1479
02:38:10.509 --> 02:38:19.173
如果我们再做一个这样的，也许你想得到6个公共兄弟最喜欢的数字，从技术上讲，这将在第一个槽被索引。

1480
02:38:19.173 --> 02:38:25.182
如果我们再做一个，也许是妹妹最喜欢的数字，这就是下一个加第二个槽。

1481
02:38:25.182 --> 02:38:31.882
最喜欢的数字是0，这个加1，这个加2，但我们在后面的课程中会学到更多。

1482
02:38:31.882 --> 02:38:35.918
类似地，最喜欢的数字是索引0名称是索引1。

1483
02:38:35.918 --> 02:38:48.867
现在我们已经做得很好了，但如果我们想要很多人我们就必须不断复制粘贴并将人们的名字person改为他们最喜欢的一个，1号，3号，将他们命名为ally。

1484
02:38:48.951 --> 02:38:52.968
第三个人，他们最喜欢的数字是7。

1485
02:38:53.952 --> 02:38:56.035
会是查德之类的。

1486
02:38:58.952 --> 02:39:02.828
创建列表和大量的人，因为我们必须静态地输入他们。

1487
02:39:02.828 --> 02:39:05.211
这是一个更好的创建列表的方法。

1488
02:39:05.211 --> 02:39:13.025
让我们删掉Patrick一个更好的创建列表的方法是使用一种叫做数组的数据结构。

1489
02:39:13.025 --> 02:39:22.136
数组是一种存储列表或对象序列的方法，创建数组的工作原理与初始化其他不同类型完全相同。

1490
02:39:22.136 --> 02:39:28.155
通常，我们处理对象的类型、对象的可见性，然后是变量名。

1491
02:39:28.155 --> 02:39:30.399
我们对数组做同样的事情。

1492
02:39:30.399 --> 02:39:32.844
我们想要一个people数组。

1493
02:39:32.844 --> 02:39:37.181
这些小括号表示我们想要一个人的数组。

1494
02:39:37.181 --> 02:39:57.010
我们给它一个可见性public，我们叫它people你也可以对你做同样的事情比如256，你可以去56个公共收藏号码列表然后在这里加上这个数组键。

1495
02:39:57.010 --> 02:40:02.120
现在收藏号码列表将是一个数组或列表，我们先把它注释掉。

1496
02:40:02.120 --> 02:40:07.614
现在，如果我要部署这个契约，删除最后一个，重新部署。

1497
02:40:07.614 --> 02:40:10.975
这里有蓝色的people按钮。

1498
02:40:10.975 --> 02:40:18.893
记住，因为它是公共的，它是一个变量，它自动被赋予一个视图函数，它被赋予一个蓝色按钮。

1499
02:40:18.960 --> 02:40:28.256
而不是只有一个显示值的按钮，它给我们一个要填写的表格，它想把un256作为输入参数。

1500
02:40:28.256 --> 02:40:32.927
如果输入0，什么也得不到，如果输入1，什么也得不到。

1501
02:40:32.927 --> 02:40:36.909
不管你在盒子里放什么，对吧?现在我们什么都拿不回来了。

1502
02:40:36.962 --> 02:40:41.217
这是因为我们的人员数组或人员列表当前为空。

1503
02:40:41.217 --> 02:40:45.650
它想要的值就是你想要的对象的索引。

1504
02:40:45.650 --> 02:40:56.846
举个例子，如果在索引0处，我有帕特里克，它会显示为0的帕特里克，如果不是x 1，我有约翰，或者更好一点，是帕特里克。

1505
02:40:57.964 --> 02:41:00.148
七，约翰，等等。

1506
02:41:00.148 --> 02:41:01.809
这就是它所显示的。

1507
02:41:01.809 --> 02:41:04.754
但因为它是空的，所以什么也显示不出来。

1508
02:41:04.754 --> 02:41:15.688
让我们从收藏号中移除公共变量这样我们就不会得到重复的函数，我们只会得到检索函数，我们马上会演示如何添加到这个数组中。

1509
02:41:15.688 --> 02:41:24.197
这种类型的数组被称为动态数组，因为数组的大小在数组初始化时没有给定。

1510
02:41:24.197 --> 02:41:50.923
如果我们说,一个人数组并添加一个三在括号中,这意味着这个列表,或者这个数组的人只能三个人,如果我们不给它一个大小,这意味着它可以是任何大小和数组的大小可以是我们增长和收缩加减的人,如果我添加三个,最多只能有三个数组中,我们将使用一个动态数组,因为我们要想添加任意数量的人们这个数组。

1511
02:41:50.970 --> 02:41:59.560
我们来创建一个函数来添加people people数组，我们写入function, addperson。

1512
02:41:59.560 --> 02:42:08.005
我们会取string memory name作为输入参数，我待会再解释。

1513
02:42:08.005 --> 02:42:21.317
一个un256下划线收藏号，我们会让它成为一个公共函数，或者我们会调用一个push函数这在people对象上是可用的。

1514
02:42:21.317 --> 02:42:31.786
我们会说people。push，然后我们会创建一个新的people对象，它会接收收藏夹号码。

1515
02:42:31.974 --> 02:42:34.743
还有名字。

1516
02:42:34.974 --> 02:42:36.449
现在，这对你们来说可能有点棘手。

1517
02:42:36.974 --> 02:42:37.640
下来。

1518
02:42:37.640 --> 02:42:39.640
这里的人都是大写的。

1519
02:42:40.975 --> 02:42:49.725
因为大写，它指的是结构people而不是变量people，小写people指的是这个小写数组。

1520
02:42:49.725 --> 02:42:59.123
我们说我们的数组。push，或者说push相当于添加，一个新的people获取喜爱的号码和名字。

1521
02:42:59.123 --> 02:43:06.164
另一种方法是我们可以创建一个人类型的变量然后像这样添加。

1522
02:43:06.164 --> 02:43:09.616
所以我们可以说，新人等于人。

1523
02:43:09.616 --> 02:43:14.469
然后我们像之前一样把括号括起来。

1524
02:43:14.469 --> 02:43:24.849
你说收藏号码将是这个输入值，这个参数，我们可以说名称将是这个参数。

1525
02:43:24.849 --> 02:43:32.725
点击保存，你会得到这个错误设置，说数据位置必须存储在内存中，或者叫data for variable但没有给出。

1526
02:43:32.725 --> 02:43:37.087
现在，我们只在这里添加memory关键字，我稍后会解释它的作用。

1527
02:43:37.087 --> 02:43:40.784
当然，我们还需要将新的person添加到people。push中。

1528
02:43:40.784 --> 02:43:45.235
这就是我们将人推入people数组的方式。

1529
02:43:45.235 --> 02:43:47.523
我马上就会讲到这个记忆关键字。

1530
02:43:47.523 --> 02:43:52.435
现在回到deploy选项卡，删除最后一个契约。

1531
02:43:52.435 --> 02:43:54.227
让我们部署这个新的。

1532
02:43:54.227 --> 02:44:07.054
现在，如果我们试图查看person在people数组中的0，我们什么也得不到，但我们继续添加一个人，我们将其命名为Patrick, 7将是最受欢迎的数字。

1533
02:44:07.054 --> 02:44:09.516
我们加了帕特里克，加了7。

1534
02:44:09.516 --> 02:44:16.951
现在如果我们看一下人们的0，我们应该会看到第0个人的名字叫帕特里克，最喜欢的数字是7，砰。

1535
02:44:16.951 --> 02:44:25.894
这正是我们所看到的，我们看到一个最喜欢的数字7，我们看到一个名为Patrick的字符串，我们试图加上John，然后是他的16。

1536
02:44:25.894 --> 02:44:29.485
点击添加人员，我们可以看到交易通过。

1537
02:44:29.485 --> 02:44:34.923
现在如果我们选择0的人，仍然是帕特里克，他最喜欢的数字是7。

1538
02:44:34.923 --> 02:44:40.096
但是如果我们看看指数1的人，会是约翰，他最喜欢的数字是16。

1539
02:44:40.096 --> 02:44:43.495
如果我们看两个，当然，这个应该是空白的。

1540
02:44:43.495 --> 02:44:46.390
我们确实看到这里什么都没有发生。

1541
02:44:46.390 --> 02:44:46.777
完美的。

1542
02:44:46.777 --> 02:44:59.730
这里其实有几种不同的方法来创建这个新人，就像我们之前展示的，我们可以用这个括号符号，或者我们可以做的是我们可以按照参数显示的顺序添加参数。

1543
02:44:59.730 --> 02:45:03.540
人们的第一个参数是最喜欢的数字。

1544
02:45:03.540 --> 02:45:10.924
我们可以写最喜欢的数字，逗号，第二个是名字，第二个是名字。

1545
02:45:10.924 --> 02:45:18.104
如果我们保存这条，这条，我们刚创建的这条直线和上一条直线是完全一样的，我们在这里没有那么明确。

1546
02:45:18.104 --> 02:45:34.974
另一种方法通常会更好一些因为它更明确地说明了变量是什么我们甚至不需要保存到这个变量，我们可以去掉整行，用我们刚刚看到的替换new person现在我们甚至不需要memory关键字。

1547
02:45:34.974 --> 02:45:38.155
现在，你可能已经看到了这个。

1548
02:45:38.155 --> 02:45:43.320
但如果我继续编译，我在这里看到一个小红色的，我就翻过去。

1549
02:45:43.320 --> 02:45:51.660
它说了一些错误，期望是分号，但得到了括号，所有这些错误都意味着你的代码没有编译。

1550
02:45:51.660 --> 02:45:53.518
它没有像预期的那样工作。

1551
02:45:53.518 --> 02:45:58.394
现在我可以到这里做一个分号重新编译，我得到一个绿色。

1552
02:45:58.394 --> 02:46:04.910
如果我删除上面这一行，然后编译它，就会得到一个黄色的东西。

1553
02:46:04.995 --> 02:46:12.724
黄色代表警告，我得到的警告是警告SPX许可证标识符，没有提供，你应该添加它。

1554
02:46:12.724 --> 02:46:14.596
我们把它加回来。

1555
02:46:14.596 --> 02:46:15.096
编译。

1556
02:46:15.096 --> 02:46:16.431
警告消失了。

1557
02:46:16.431 --> 02:46:18.608
不要停止编译你的代码。

1558
02:46:18.608 --> 02:46:19.896
所以如果你收到警告，没关系。

1559
02:46:19.896 --> 02:46:26.950
但是，听取警告通常是一个好主意，因为它们通常会提供关于如何改进智能合约的非常有见地的信息。

1560
02:46:26.997 --> 02:46:29.642
总结一下，如果它是红色的，它就坏了。

1561
02:46:30.998 --> 02:46:31.960
也许你该去看看。

1562
02:46:32.998 --> 02:46:36.935
继续编码。

1563
02:46:39.998 --> 02:46:42.764
你会注意到这里有一个记忆关键字。

1564
02:46:42.999 --> 02:46:51.051
你会注意到，如果你试图从函数中删除它，你试图编译，你实际上会遇到错误数据位置必须是内存或调用数据为参数和函数。

1565
02:46:51.100 --> 02:47:00.475
现在实际上有六个地方你可以存储数据，你有堆栈，内存，存储，调用数据，代码和日志。

1566
02:47:00.475 --> 02:47:02.490
我们现在不打算细说这些。

1567
02:47:02.490 --> 02:47:10.515
但是我们将关注其中的三个大的，或者是这一节中三个重要的，它们被称为数据，内存和存储。

1568
02:47:10.515 --> 02:47:13.921
这一节，我们将讨论调用数据内存和存储。

1569
02:47:13.921 --> 02:47:15.680
这有点高级。

1570
02:47:15.680 --> 02:47:19.155
所以如果你第一次没有完全理解，那也没关系。

1571
02:47:19.155 --> 02:47:20.043
请继续。

1572
02:47:20.043 --> 02:47:28.362
即使不清楚这里发生了什么，调用数据和内存意味着变量只会暂时存在。

1573
02:47:28.362 --> 02:47:41.018
因此，这个name变量只在被称为Add Person函数的事务中临时存在，甚至在函数执行之外也存在存储变量。

1574
02:47:41.100 --> 02:47:47.286
即使我们没有在上面指定它，我们最喜欢的数字也会自动转换为存储变量。

1575
02:47:47.286 --> 02:47:51.033
因为它没有在这些函数中明确定义。

1576
02:47:51.033 --> 02:48:03.661
因为在这个函数运行后我们不再需要这个name变量，我们可以将它保留为内存，或者我们可以将它保留为called data，如果你不修改名字，你可以将一个参数保留为called data。

1577
02:48:03.661 --> 02:48:10.134
例如，我们不能在这里将name重新赋值给equal cat，如果我们编译，就会遇到错误。

1578
02:48:10.134 --> 02:48:15.261
类型字面值字符串cat不能隐式转换为期望名为data的类型字符串。

1579
02:48:15.261 --> 02:48:23.911
但是，如果我们把它作为内存，编译并保存它，错误就会消失调用数据是临时变量，不能被修改。

1580
02:48:23.911 --> 02:48:27.242
内存是可以修改的临时变量。

1581
02:48:27.242 --> 02:48:30.625
存储是可以修改的永久变量。

1582
02:48:30.625 --> 02:48:44.629
现在，尽管我刚刚说了实际上有六个地方我们可以访问和存储信息，我们不能说一个变量是堆栈代码或日志，我们只能说内存存储称为数据，你将在后面的部分了解为什么。

1583
02:48:44.629 --> 02:48:47.339
现在，这有点过于简单化了。

1584
02:48:47.339 --> 02:48:49.227
但本质上就是这样。

1585
02:48:49.227 --> 02:48:57.507
下一个问题你可能会问，为什么我需要在这里说内存，但我不需要在这里说内存。

1586
02:48:57.507 --> 02:49:02.035
我们把内存放在这里，然后按CTRL S或编译。

1587
02:49:02.101 --> 02:49:08.051
让我们看看会发生什么，我们从固体数据位置只能指定为数组，结构或映射类型。

1588
02:49:08.101 --> 02:49:13.920
数组结构和映射被认为是内存的特殊类型和稳固性。

1589
02:49:13.920 --> 02:49:24.017
固体性自动知道你在256中的位置慢慢地知道对于这个函数，UN 256只存在于内存中。

1590
02:49:24.101 --> 02:49:26.651
然而，它不确定字符串将是什么。

1591
02:49:27.101 --> 02:49:28.947
其实是很复杂的。

1592
02:49:30.101 --> 02:49:32.476
字符串实际上是一个字节数组。

1593
02:49:34.101 --> 02:49:44.048
数组，我们需要添加这个内存位因为我们需要告诉它坚固性，数组结构的数据位置，或者映射字符串是一个数组。

1594
02:49:44.048 --> 02:49:46.837
这就是为什么我们需要告诉它它在内存中。

1595
02:49:46.837 --> 02:49:53.804
你会注意到我们不能在这里添加storage关键字因为这是一个函数，name变量不会被存储到任何地方。

1596
02:49:53.804 --> 02:50:02.583
它说，嘿，你不能有那个你需要让它打败内存或调用数据这是它唯一接受的两个这就是我们想要的函数在这里的样子。

1597
02:50:02.583 --> 02:50:11.757
总结一下，当把结构映射和数组作为参数添加到不同的函数时需要给它们Data关键字。

1598
02:50:11.757 --> 02:50:16.435
我们将在后面的会话中了解更多关于存储内存和调用数据的知识。

1599
02:50:16.435 --> 02:50:28.051
这个列表很棒，但如果我们知道某人的名字，却不知道他们最喜欢的数字呢?我们能做的就是在整个数组中寻找那个人。

1600
02:50:28.102 --> 02:50:32.368
例如，在我们的合同中，我们可以说，好的，我在找约翰。

1601
02:50:32.368 --> 02:50:34.234
好吧，我们从0开始。

1602
02:50:34.234 --> 02:50:35.900
不，那是帕特里克。

1603
02:50:36.102 --> 02:50:37.227
好吧，让我们看一个。

1604
02:50:37.227 --> 02:50:37.494
好的。

1605
02:50:37.494 --> 02:50:38.136
这是约翰。

1606
02:50:38.136 --> 02:50:38.671
哦,太棒了。

1607
02:50:39.102 --> 02:50:42.790
你最喜欢16号吗?这真的很简单，因为我们只有两个人。

1608
02:50:42.790 --> 02:50:51.652
但如果我们有数百人在这个队列中呢?我们必须一直迭代到那个人所在的索引，这显然是非常低效的。

1609
02:50:51.652 --> 02:51:08.876
还有什么方法可以存储这些信息，使其更容易和更快地访问呢?我们可以使用的另一个数据结构叫做映射，你可以把映射想象成一个字典，它是一组键，每个键返回一个与该键相关的特定值。

1610
02:51:08.876 --> 02:51:13.502
我们创建一个映射变量和我们创建其他变量的方法完全一样。

1611
02:51:13.502 --> 02:51:26.152
这将是string给你的类型映射而tivity，这将是我们的可见性类型关键字将是public。

1612
02:51:26.152 --> 02:51:31.052
我们叫它名字到最喜欢的数字。

1613
02:51:31.052 --> 02:51:36.905
现在我们有了一个字典，每个名字都映射到一个特定的数字。

1614
02:51:36.905 --> 02:51:40.273
让我们为add Person函数添加一些功能。

1615
02:51:40.273 --> 02:51:43.944
我们要把人加到数组中。

1616
02:51:44.102 --> 02:51:50.899
但我们也把它们添加到映射中，我们要做的是说name to favorite number。

1617
02:51:50.899 --> 02:51:58.939
App键名将等于收藏夹号码。

1618
02:51:58.939 --> 02:52:02.857
让我们继续，编译这个。

1619
02:52:03.103 --> 02:52:11.153
我们到部署屏幕，部署这个click，我们有一个新按钮，命名为收藏夹号码。

1620
02:52:11.153 --> 02:52:14.206
如果我输入帕特里克，什么都没出现。

1621
02:52:14.206 --> 02:52:17.610
输入Patrick，你会看到我得到零响应。

1622
02:52:17.610 --> 02:52:20.340
输入John，我也得到了零响应。

1623
02:52:20.340 --> 02:52:23.836
如果我输入贝卡，我也会得到零回应。

1624
02:52:23.836 --> 02:52:34.272
当你创建一个映射时，你把所有东西都初始化为它的空值，地球上每一个可能的字符串现在都初始化为最喜欢的数字为0。

1625
02:52:34.272 --> 02:52:37.634
如果我们想要改变它，我们需要手动添加它。

1626
02:52:37.634 --> 02:52:41.916
让我们在映射中添加一个人。

1627
02:52:41.916 --> 02:52:43.612
我们加上帕特里克。

1628
02:52:43.612 --> 02:52:46.666
我们会说我最喜欢的数字是7。

1629
02:52:46.666 --> 02:52:53.880
看来这笔交易完成了贝卡，她最喜欢的数字是13。

1630
02:52:53.880 --> 02:52:58.012
让约翰，我们说他最喜欢的数字是16。

1631
02:52:58.012 --> 02:53:05.036
现在，如果我往上看，帕特里克，我马上就会得到帕特里克最喜欢的数字是什么，我得到了7。

1632
02:53:05.036 --> 02:53:08.243
如果我们往上看，约翰，我们马上就能回到16。

1633
02:53:08.243 --> 02:53:10.558
退后，我们可能只能回到13。

1634
02:53:10.558 --> 02:53:13.255
我们也可以在数组中看到它们。

1635
02:53:13.255 --> 02:53:19.357
因为我们一直在推零位的人，我们看到帕特里克在那里。

1636
02:53:19.357 --> 02:53:21.492
在一点钟，我们看到了贝卡。

1637
02:53:21.492 --> 02:53:30.202
在第二点，我们看到John，在我们的映射中，我们说字符串名被映射到UN 256最喜欢的数字。

1638
02:53:30.202 --> 02:53:34.057
我的很多变量，我喜欢这样显式命名。

1639
02:53:34.104 --> 02:53:38.261
这是名字到喜爱的数字。

1640
02:53:38.261 --> 02:53:44.199
现在我们处在这样一个空间假设我们非常喜欢简单的储存合同。

1641
02:53:44.199 --> 02:54:04.578
现在我们有一个收藏号，一个全局变量我们可以用store函数保存收藏号，我们有一个name到收藏号的映射，我们有一个新类型的数组叫做people，我们可以添加到数组和映射中。

1642
02:54:04.578 --> 02:54:13.722
使用我们创建的这个添加人功能，我们能够保存多人最喜欢的号码以及一个全局最喜欢的号码。

1643
02:54:13.722 --> 02:54:20.054
假设我们非常喜欢这个合同，我们准备将它发送到测试网络，让其他人与它进行交互。

1644
02:54:20.104 --> 02:54:26.484
在以后的部分中，你会听到我说你不应该这样做直到你写了测试直到你做了一些真正简单的审计。

1645
02:54:26.484 --> 02:54:32.874
但现在，让我们继续学习如何将它部署到测试网或真实的网络中。

1646
02:54:32.874 --> 02:54:35.970
记住，测试网是用人们内心的善意来运行的。

1647
02:54:35.970 --> 02:54:40.500
如果它有点古怪，或者可能不完全像我们在这里展示的那样工作，那也没关系。

1648
02:54:40.500 --> 02:54:48.041
只要它能与JavaScript VM一起工作，您就万事俱备了，但学习如何将它们部署到真正的测试网络是一个很好的实践。

1649
02:54:48.041 --> 02:54:49.728
我们来做一下。

1650
02:54:49.728 --> 02:54:51.226
我们的合同在这里。

1651
02:54:51.226 --> 02:54:52.910
简单的存储点灵魂。

1652
02:54:52.910 --> 02:54:58.284
它被编译，编译被传递我们得到这个绿色的小标记我们进入部署部分。

1653
02:54:58.284 --> 02:54:59.808
让我们继续做拿着这个。

1654
02:54:59.808 --> 02:55:02.120
现在我们要改变环境。

1655
02:55:02.120 --> 02:55:11.505
我们在JavaScript虚拟机中工作或者类似于这种模拟环境，我们现在想转移到注入web 3，或者web 3提供者。

1656
02:55:11.505 --> 02:55:16.040
如果你把鼠标悬停在inject web3上面，这里有一个非常非常小的文本。

1657
02:55:16.040 --> 02:55:27.073
但这基本上意味着我们会将元掩码或webthree钱包注入到浏览器中使用就像我们对水龙头所做的一样，我们会选择我们想要使用的账户。

1658
02:55:27.073 --> 02:55:29.978
所以我要选择账户1。

1659
02:55:29.978 --> 02:55:44.846
现在我们在remix的account部分看到我们的账户，注入web 3意味着我们在使用元掩码或web 3钱包，web 3提供者，当我们稍微手动地选择端点时。

1660
02:55:44.846 --> 02:55:47.088
我们现在不打算讨论这个。

1661
02:55:47.088 --> 02:55:49.956
但随着课程的深入，你会明白这是什么意思。

1662
02:55:49.956 --> 02:55:59.420
我们选择注入web 3，无论注入web 3是什么网络，或者在这种情况下，我们的钱包连接到的网络将是我们部署到的网络。

1663
02:55:59.420 --> 02:56:02.494
所以这一部分，我们将部署到林克比。

1664
02:56:02.494 --> 02:56:10.334
但是，这取决于推荐的测试网和推荐的水龙头是什么，这将决定你应该部署哪个测试网。

1665
02:56:10.334 --> 02:56:11.858
对我们来说，是里格比。

1666
02:56:11.858 --> 02:56:16.980
为了进行测试记住，我们需要气体，所以我们需要一些经过测试的以太。

1667
02:56:16.980 --> 02:56:31.850
或者如果你部署到一个主网主Aetherium，你不应该来到GitHub回购的顶部，以确保你有最新的水龙头，另一个地方，你可以去链接令牌合约页的链链接文档，并向下滚动排名。

1668
02:56:31.850 --> 02:56:36.531
你可以在这里测试链接，在这里测试每个链接。

1669
02:56:36.531 --> 02:56:43.334
这是另一个位置，你总是可以找到最新的水龙头，它们都指向这里。

1670
02:56:43.334 --> 02:56:53.012
现在我们正在使用注入web 3，我们可以通过部署到测试网和部署到虚拟机的完全相同的步骤。

1671
02:56:53.106 --> 02:56:57.767
记住，如果你没油开这个，一定要检查水龙头是否真的开了。

1672
02:56:57.767 --> 02:57:00.582
我们会做同样的事情，我们会点击部署。

1673
02:57:00.582 --> 02:57:33.976
这次Metamask会弹出来问我们是否要部署这个，这和我们在区块链例子中看到的完全一样，我们签署了交易，我们签署并发送了这个交易，这个交易的数据是这个巨大的数据，它代表我们刚刚创建的合约，我们可以看到这个交易的所有支付信息部署这个合约，我们发现部署它需要大约这么多的Aetherium。

1674
02:57:33.976 --> 02:57:36.519
但是，我们是在林克比测试网络上。

1675
02:57:36.519 --> 02:57:37.829
这是假的Aetherium。

1676
02:57:37.829 --> 02:57:40.215
继续，点击确认。

1677
02:57:40.215 --> 02:57:57.817
如果你弹出一个小控制台，进行混合，你会看到稍等片刻后，它会显示有这个绿色的复选标记它确认了它确实通过了，我们可以继续右击，打开一个新选项卡，在以太扫描中查看这个。

1678
02:57:57.817 --> 02:58:17.058
稍等片刻后，我们就能看到交易细节了，和发送Aetherium时的交易细节完全一样我们有散列，有状态，有阻塞，有确认，还有时间戳这是我们两个，这是我们刚创建的合约的平均值。

1679
02:58:17.058 --> 02:58:19.280
我们没有用这个发送任何值。

1680
02:58:19.280 --> 02:58:20.920
所以这是零以太。

1681
02:58:20.920 --> 02:58:25.056
当然，我们还会看到交易费用，以及汽油价格。

1682
02:58:25.056 --> 02:58:30.219
因为，将合约部署到区块链就是在修改区块链的状态。

1683
02:58:30.219 --> 02:58:33.948
我们需要支付汽油，我们可以看到所有不同的部分。

1684
02:58:33.948 --> 02:58:44.027
正如我们所看到的，气体限制和气体使用量比发送Aetherium要高得多，因为我们在链上放置了大量的数据并添加了大量的计算。

1685
02:58:44.107 --> 02:58:49.017
所以这个数字远远高于仅仅发送Aetherium的21000个数字。

1686
02:58:49.017 --> 02:58:55.934
现在，如果我们回到我们的混音并向下滚动，我们可以在这个地址看到我们的简单存储合同。

1687
02:58:55.934 --> 02:59:04.896
如果我们点击这个复制按钮，我们到溜冰场进行以太扫描，我们把它粘贴到搜索栏，我们会得到我们刚刚部署的合同。

1688
02:59:04.896 --> 02:59:10.041
我们看到第一个交易将是合同创建交易。

1689
02:59:10.107 --> 02:59:15.011
我们刚刚创建了一个交易，这是合同创建。

1690
02:59:15.011 --> 02:59:24.172
现在我们已经创建了这个契约，我们有了所有与JavaScript虚拟机，或我们的伪环境，或超级伪环境完全相同的函数。

1691
02:59:24.172 --> 02:59:29.707
现在我们可以在一个真实的测试网络上做和JavaScript VM完全相同的事情。

1692
02:59:29.707 --> 02:59:33.666
你会看到如果我点击检索Metamask没有弹出。

1693
02:59:33.666 --> 02:59:36.535
因为这是一个蓝色的视图函数。

1694
02:59:36.535 --> 02:59:42.528
如果我们看0的人，这也是一个视图函数，没有弹出任何东西，命名喜爱的数字应该是空白的。

1695
02:59:42.528 --> 02:59:54.639
所以如果我现在输入帕特里克，绝对什么都不会发生，对吧?返回0，因为映射用空值或空值初始化每个键，256就是0。

1696
02:59:54.639 --> 03:00:10.894
现在，我们可以继续存储一个收藏号存储当你的收藏号要修改区块链时，我们的元掩码应该会弹出来让我们确认交易并签署该交易来修改区块链状态。

1697
03:00:10.894 --> 03:00:25.836
我要存储我最喜欢的数字16，点击store，元掩码会弹出，然后我们要确认这个没有确认等同于US签署这个交易并将它发送给区块链来修改状态。

1698
03:00:25.836 --> 03:00:31.044
所以我们要继续确认这个，我们应该可以在以太扫描上看到这个。

1699
03:00:31.108 --> 03:00:35.561
同样，它可能需要一点时间才能真正索引或真正开始工作。

1700
03:00:35.561 --> 03:00:37.627
所以请耐心使用这些测试网。

1701
03:00:37.627 --> 03:00:47.044
再说一遍，这就是为什么在构建应用程序时，你希望测试网绝对是你的最后一步，因为你必须等很长时间。

1702
03:00:47.108 --> 03:00:51.536
这给那些做这些测试的人带来了负担，让他们不得不出于好心去做这些测试。

1703
03:00:51.536 --> 03:00:55.600
因此，请尝试将此作为您实际构建过程的最后一步。

1704
03:00:55.600 --> 03:00:58.043
对我们来说，在这里学习，没关系。

1705
03:00:58.043 --> 03:01:09.465
稍等片刻后，一旦我们点击刷新，它看起来像是在以太扫描上建立索引，以太扫描网站仍然在计算交易将在哪里进行混合，看起来在区块链上，这实际上已经完成了。

1706
03:01:09.465 --> 03:01:13.827
如果我们点击检索，我们确实会看到，我们最喜欢的数字是16。

1707
03:01:13.827 --> 03:01:16.396
当然，这两个仍然是空的。

1708
03:01:16.396 --> 03:01:20.483
看起来交易已经完成，以太扫描已经建立了索引。

1709
03:01:20.483 --> 03:01:26.430
现在我们继续，加一个人加上帕特里克，我最喜欢的数字是16。

1710
03:01:26.430 --> 03:01:28.284
我们将继续添加person。

1711
03:01:28.284 --> 03:01:35.323
橙色事务会弹出因为我们修改了区块链状态，点击确认。

1712
03:01:35.323 --> 03:01:39.785
我们要耐心一点等待交易完成。

1713
03:01:39.785 --> 03:01:41.818
我们应该看到这个更新。

1714
03:01:41.818 --> 03:01:42.902
还有这次更新。

1715
03:01:43.108 --> 03:01:46.785
如果我点击帕特里克最喜欢的数字，我得到16。

1716
03:01:47.108 --> 03:01:49.441
如果我打0的人，我就得到最喜欢的16号。

1717
03:01:50.108 --> 03:01:50.743
帕特里克。

1718
03:01:50.743 --> 03:01:51.251
太棒了。

1719
03:01:54.109 --> 03:02:06.786
到一个真实的测试网络，在以太网上看到这些交易是什么样子的，你应该为自己感到无比自豪，一定要给自己击掌，拍拍后背，发一条推特说你有多兴奋。

1720
03:02:06.786 --> 03:02:15.381
但一定要庆祝这些小胜利，庆祝这些小胜利会给你继续前进的动力，真正激发你学习每一个新事物。

1721
03:02:15.381 --> 03:02:15.962
如此巨大的。

1722
03:02:16.109 --> 03:02:16.812
祝贺你。

1723
03:02:19.109 --> 03:02:21.198
合同到测试网，恭喜你。

1724
03:02:22.109 --> 03:02:29.493
要查看部署到不同的网络是什么样子，你需要在Metamask中做的就是切换到不同的测试网络。

1725
03:02:29.493 --> 03:02:36.505
看，如果我们切换到新冠混合自动更新，然后说，啊，注入的web 3现在是新冠测试网络。

1726
03:02:36.505 --> 03:02:42.055
我们可以再次切换到格里利，我们说，啊，注射网3现在在格里利。

1727
03:02:42.109 --> 03:02:49.216
这是我们将要部署的测试网，当然，我们需要真正的测试网Aetherium来做任何部署，所以我们不能在这里。

1728
03:02:49.216 --> 03:02:52.420
如果我们现在点击部署，Metamask就会弹出。

1729
03:02:52.420 --> 03:02:56.251
但是我们看到这个红色的小标记表示资金不足。

1730
03:02:56.251 --> 03:03:03.449
当然，稍后，我们将学习如何添加新的网络像多边形雪崩像幻影到我们的Metamask。

1731
03:03:03.449 --> 03:03:07.734
所以我们也可以从其中任何一个部署。

1732
03:03:08.109 --> 03:03:18.515
我之前提到过这个术语，但我们写的所有这些代码，当我们按下这个编译按钮时，它就会编译到EVM或以太坊虚拟机。

1733
03:03:18.515 --> 03:03:21.786
不要太担心这意味着什么。

1734
03:03:21.786 --> 03:03:27.442
EVM是一种将智能合约像区块链一样部署到Aetherium的标准。

1735
03:03:27.442 --> 03:03:30.966
以及实现某种类型EVM的任何区块链。

1736
03:03:30.966 --> 03:03:40.461
你可以将固态代码部署到一些与EVM兼容的区块链的例子中，比如avalanche、Phantom和polygon。

1737
03:03:40.461 --> 03:03:50.485
因为这些都是EVM兼容的，这意味着我们可以编写我们的坚固性代码，并部署到这些区块链上，我稍后会向您展示如何将这些新网络添加到您的Metamask中。

1738
03:03:50.485 --> 03:03:51.797
然后是如何部署它们。

1739
03:03:51.797 --> 03:03:54.290
让我们快速回顾一下我们的第一个智能合约。

1740
03:03:54.290 --> 03:04:00.427
然后你应该休息一下，吃点冰淇淋或咖啡，因为这是你应得的。

1741
03:04:00.427 --> 03:04:00.934
祝贺你。

1742
03:04:00.934 --> 03:04:07.978
在智能合约中，你要做的第一件事就是告诉合约的稳固性，你要使用哪种版本的稳固性。

1743
03:04:07.978 --> 03:04:15.453
此外，您还需要添加spdx许可证标识符，然后必须创建契约对象并为契约命名。

1744
03:04:15.453 --> 03:04:23.848
坚固性中的契约类似于其他编程语言中的类，弯弯曲曲的括号内的所有内容都是该契约的一部分。

1745
03:04:23.848 --> 03:04:31.410
固体性中有许多不同的类型，如无符号整数、256、布尔字符串、字节、32等。

1746
03:04:31.410 --> 03:04:36.128
如果我们想创建一个新类型，我们可以创建一个叫做固体结构的东西。

1747
03:04:36.128 --> 03:04:48.593
你可以在实体中创建数组或列表，你可以在实体中创建字典，或者所谓的映射或散列表，当你给它一个键时，它会吐出键所代表的值。

1748
03:04:48.593 --> 03:04:52.586
我们可以在固体中创建函数来修改区块链的状态。

1749
03:04:52.586 --> 03:05:11.637
我们还可以在实体中创建函数，它不会在纯函数中修改区块链视图的状态，也不会通过区块链的状态进行修改，我们还可以在函数中指定不同的数据位置，称为数据和内存，意味着数据只是临时的，只会在函数运行期间存在。

1750
03:05:11.637 --> 03:05:14.575
存储变量是永久的，永远停留在那里。

1751
03:05:14.575 --> 03:05:19.628
函数形参不能作为存储变量，因为它们只会在函数运行期间存在。

1752
03:05:19.628 --> 03:05:28.031
我们使用的所有固体性代码，当我们点击编译时，它实际上编译到这个Aetherium虚拟机规范。

1753
03:05:28.111 --> 03:05:29.744
稍后我们将进一步了解这些规范。

1754
03:05:30.111 --> 03:05:36.825
但最重要的是，再次恭喜你签了第一份合同。

1755
03:05:37.111 --> 03:05:37.111
太棒了。

1756
03:05:37.111 --> 03:05:42.444
好，我们开始讲第三课，记住，所有东西都在GitHub存储库中。

1757
03:05:42.444 --> 03:05:46.207
我们可以向下滚动，点击第三课，查看所有代码。

1758
03:05:46.207 --> 03:05:48.248
我一边拍，一边在积累这个记录。

1759
03:05:48.248 --> 03:05:58.282
在这第三课下面将会有更多的信息，而不仅仅是这里的代码，我们所有的代码样本都以破折号f f c结尾，这是破折号自由代码营的意思。

1760
03:05:58.282 --> 03:06:10.062
如果你看到一个以F F C结尾的GitHub回购，知道这个仓库与这门课相关，我将做一个快速的高水平的演练，我们将在这门课中构建什么。

1761
03:06:10.111 --> 03:06:14.289
所以您现在不需要编写代码，只需坐下来观看并享受。

1762
03:06:14.289 --> 03:06:17.888
在这节课中，我们将扩展到三种不同的契约。

1763
03:06:17.888 --> 03:06:23.628
假设我们希望能够从契约本身部署简单的存储契约。

1764
03:06:23.628 --> 03:06:35.195
是的，合约确实可以部署合约，我们将创建一个名为storage factory。sole的合约，它将能够部署并与其他合约本身交互。

1765
03:06:35.195 --> 03:06:44.029
我们可以把它部署到JavaScript虚拟机，我们选择存储工厂，然后点击部署。

1766
03:06:44.029 --> 03:06:47.620
在我们下面的合同中，我们有很多不同的功能。

1767
03:06:47.620 --> 03:07:02.554
我们最上面的函数是这个叫crate simple storage contract的函数，我们可以点击它，它会为我们创建一个简单的storage contract，然后我们可以继续与它交互，在IG 0处，它会保存一个喜爱的数字为1。

1768
03:07:02.554 --> 03:07:08.362
如果我们点击SF，得到0，就会得到1。

1769
03:07:08.362 --> 03:07:12.568
我们可以看到我们刚刚部署的简单存储契约的地址。

1770
03:07:12.568 --> 03:07:19.161
此外，我们还将学习一些坚固性特性，例如导入继承等等。

1771
03:07:19.161 --> 03:07:21.128
让我们开始吧。

1772
03:07:21.128 --> 03:07:24.915
记住，所有的代码都可以从GitHub存储库中获得。

1773
03:07:24.915 --> 03:07:31.006
所以，如果你迷路了，一定要回头看看这些合同。

1774
03:07:31.112 --> 03:07:34.724
现在我们回到了remix，我们有了简单的storage。soul。

1775
03:07:34.724 --> 03:07:40.080
如果你跳过了上一节，一定要去上完整的区块链固体课程，Jas。

1776
03:07:40.080 --> 03:07:44.568
向下滚动到第二课，欢迎混合并获取这段代码。

1777
03:07:44.568 --> 03:07:46.571
去简单的存储大底。

1778
03:07:46.571 --> 03:07:48.931
并复制粘贴这段代码到混音。

1779
03:07:48.931 --> 03:07:54.796
因为这就是我们要开始的地方，我们有一个简单的储存合同，这很好。

1780
03:07:54.796 --> 03:07:56.874
它允许我们存储最喜欢的号码。

1781
03:07:56.874 --> 03:08:01.579
它还允许我们在映射和数组中存储不同人的最喜欢的数字。

1782
03:08:01.579 --> 03:08:10.027
但如果我们想在这方面做得更深入，我们可以让合约为我们部署其他合约。

1783
03:08:10.112 --> 03:08:19.722
然后继续与其他合约中的合约进行交互，合约之间的交互是稳健合约和智能合约的重要组成部分。

1784
03:08:19.722 --> 03:08:25.730
契约之间无缝交互的能力被称为可组合性。

1785
03:08:25.730 --> 03:08:28.901
智能合约是可组合的，因为它们可以很容易地相互交互。

1786
03:08:28.901 --> 03:08:40.536
当涉及到像defy这样的东西时，你可以让非常复杂的金融产品非常容易地相互交互，因为它们的所有代码都在链上可用。

1787
03:08:40.536 --> 03:08:42.033
我们将学习如何做到这一点。

1788
03:08:42.033 --> 03:08:47.613
让我们保持简单的存储契约不变，我们创建一个新的契约，叫做存储工厂。

1789
03:08:47.613 --> 03:08:54.829
点击新建文件按钮输入storage, factory。salt。

1790
03:08:54.829 --> 03:08:57.160
我们先把这个关了。

1791
03:08:57.160 --> 03:09:00.250
让我们根据之前学过的知识来建立这个契约。

1792
03:09:00.250 --> 03:09:08.838
我们要做的第一件事是spdx许可标识符，我们要做MIT。

1793
03:09:08.838 --> 03:09:13.044
接下来我们总是需要的是固体版本。

1794
03:09:13.113 --> 03:09:18.890
我们会用pragma solidity我们可以用0。

1795
03:09:18.890 --> 03:09:18.953
7.

1796
03:09:18.953 --> 03:09:21.564
但对于这个，我们用(0,8)

1797
03:09:21.564 --> 03:09:25.161
然后加上胡萝卜，表示任何形式的。

1798
03:09:25.161 --> 03:09:26.467
8点左右就可以了。

1799
03:09:26.467 --> 03:09:31.672
然后加上合同名称，也就是存储工厂。

1800
03:09:31.672 --> 03:09:38.988
现在按下command S或者ctrl S或者到compile选项卡，点击compile，我们就有了常规的设置。

1801
03:09:38.988 --> 03:09:43.898
现在我们要创建一个函数，它可以实际部署简单的存储契约。

1802
03:09:43.898 --> 03:09:47.258
我们将创建一个函数，叫做function。

1803
03:09:47.258 --> 03:09:57.935
创建一个简单的存储契约，我们会让它是公共的，所以任何人都需要部署一个简单的存储契约并将其保存到全局变量中。

1804
03:09:57.935 --> 03:10:11.964
但是在我们这样做之前我们的储存工厂合同怎么知道我们的简单储存合同是什么样的呢?为了部署它，如果我们的存储工厂合同要部署简单存储，它就需要知道简单存储的代码。

1805
03:10:11.964 --> 03:10:27.043
一种方法是我们可以到简单的storage。soul复制pragma, solidity下面的所有东西然后粘贴到我们的storage factory。soul里pragma, solidity下面的所有东西。

1806
03:10:27.114 --> 03:10:33.876
如果我们编译并保存它，它会运行在我们的存储工厂中，灵魂契约里面有两个契约。

1807
03:10:33.876 --> 03:10:55.232
它有一个简单的存储契约，里面有一个存储工厂契约，你可以到deploy选项卡，向下滚动到deploy当你在存储工厂。soul上时，而不是在存储工厂上的简单存储，你可以看到你可以选择部署其中一个契约，一个solidity文件可以容纳多个不同的契约。

1808
03:10:55.232 --> 03:11:15.271
现在我们有了简单的存储，这些都在存储工厂中，我们可以继续创建这个函数来部署一个简单的存储控制台，我们会创建一个全局变量和创建其他全局变量的方法一样，我们会做这个类型，它将是type simple storage contract，我们会给它一个可见性public。

1809
03:11:15.271 --> 03:11:17.823
我们给它一个变量名。

1810
03:11:17.823 --> 03:11:24.050
Type simple storage contract将为public，变量名将为simple storage。

1811
03:11:24.114 --> 03:11:33.864
在我们的函数中，创建简单存储契约，我们会说simple storage = new, simple storage。

1812
03:11:34.114 --> 03:11:39.685
这个新关键词是，实体如何知道啊，好吧，我们将部署一个新的简单的存储合同。

1813
03:11:39.685 --> 03:11:47.415
我们继续编译这个，到deploy选项卡，确保我们在JavaScript VM上，向下滚动到契约。

1814
03:11:47.415 --> 03:11:49.336
我们会选择储存工厂。

1815
03:11:49.336 --> 03:11:52.915
记住，你需要选择存储工厂。灵魂。

1816
03:11:52.915 --> 03:11:59.257
为了显示存储工厂，我们将继续并点击Deploy。

1817
03:11:59.257 --> 03:12:03.572
现在我们看到我们的储存工厂合同有两个按钮。

1818
03:12:03.572 --> 03:12:09.050
一个是创建简单存储，另一个是简单存储契约的视图。

1819
03:12:09.050 --> 03:12:15.180
如果我们现在点击它，它会显示它目前在地址0处，因为它被初始化为空白。

1820
03:12:15.180 --> 03:12:18.555
它说目前没有部署简单的存储合同。

1821
03:12:18.555 --> 03:12:28.193
现在，如果我们打开控制台并单击create simple storage，可以看到我们创建了一个名为storage factory。create simple storage contract的新函数。

1822
03:12:28.193 --> 03:12:39.985
在此过程中，我们调用了这个函数它创建并部署了一个新的简单存储契约，我们现在可以看到简单存储契约的地址通过点击简单存储按钮我们可以看到与之关联的地址。

1823
03:12:39.985 --> 03:12:43.598
现在我们知道了契约是如何部署另一个契约的。

1824
03:12:43.598 --> 03:12:53.729
但问题是，在我们的存储工厂上面放这么多代码有点多余，特别是我们还有一个名为Simple storage。soul的文件。

1825
03:12:53.729 --> 03:12:58.418
假设我们有一个合同里面有很多其他的合同。

1826
03:12:58.418 --> 03:13:01.915
总是复制粘贴所有这些合同将是大量的工作。

1827
03:13:01.915 --> 03:13:05.839
相反，我们能做的是使用所谓的导入。

1828
03:13:05.839 --> 03:13:08.860
我们删掉合约简单存储。

1829
03:13:08.860 --> 03:13:15.622
然后输入import。斜杠simple storage。soul。

1830
03:13:15.622 --> 03:13:22.061
这个import。slash simple storage。Seoul和复制粘贴版本的simple storage完全一样。

1831
03:13:22.115 --> 03:13:22.896
这是所有。

1832
03:13:27.115 --> 03:13:47.191
package或GitHub，我们待会再看另一个文件然后说，我们要把合同粘贴到这个合同的顶部我们回到编译，然后部署，删除旧的合同，我们可以再次看到storage factory。soul，我们可以部署，点击下拉菜单。

1833
03:13:47.191 --> 03:13:50.508
同样，我们可以运行完全相同的函数。

1834
03:13:50.508 --> 03:13:55.417
像这样导入我们的契约比总是复制粘贴代码要好得多。

1835
03:13:55.417 --> 03:14:02.303
通过这种方式，如果我们想要在简单存储中更改某些内容，我们只需在一个规范的位置进行更改，而不必在多个不同的位置进行更改。

1836
03:14:02.303 --> 03:14:13.202
另外，你会注意到pragma和soidity如果我们的合约在两个单独的文件中，我们实际上可以有不同版本的soidity现在我们的存储工厂有胡萝卜零点8。

1837
03:14:13.202 --> 03:14:16.650
这意味着任何在。

1838
03:14:16.650 --> 03:14:19.200
这份合同的8个范围是可以的。

1839
03:14:19.200 --> 03:14:23.952
但对于简单的储存，它说的是零点8。

1840
03:14:23.952 --> 03:14:25.591
8及以上范围都可以。

1841
03:14:25.591 --> 03:14:30.197
如果我们要改变编译器版本8。

1842
03:14:30.197 --> 03:14:38.689
然后继续编译，一个混音会自动把它提升到一个更好的版本，与它们都兼容，在这种情况下是8点13。

1843
03:14:38.689 --> 03:14:45.589
但如果我们，例如，把存储工厂的固态版本改成零点7。

1844
03:14:45.589 --> 03:14:48.179
然后尝试编译它们。

1845
03:14:48.179 --> 03:14:54.590
我们实际上最终得到一个问题解析器错误源文件需要一个不同的编译器版本。

1846
03:14:54.590 --> 03:14:59.181
这是因为我们的存储工厂说，0中的任何东西。

1847
03:14:59.181 --> 03:15:00.410
7表示可以。

1848
03:15:00.410 --> 03:15:05.488
然而，我们的简单存储表示的是0点8内的任何值。

1849
03:15:05.488 --> 03:15:06.776
8及以上都可以。

1850
03:15:06.776 --> 03:15:09.063
所以这两个版本是不兼容的。

1851
03:15:09.063 --> 03:15:13.751
所以我们需要做的是我们需要确保我们的固体版本确实是兼容的。

1852
03:15:13.751 --> 03:15:16.481
让我们把版本改回来重新编译。

1853
03:15:16.481 --> 03:15:18.278
现在我们看起来又不错了。

1854
03:15:18.278 --> 03:15:26.878
既然我们有这个创建简单存储契约，每次我们调用它，它就会替换当前在公共简单存储变量中的东西。

1855
03:15:26.878 --> 03:15:33.027
让我们继续并更新它，这样我们就可以实际保持所有已部署的简单存储契约的运行列表。

1856
03:15:33.027 --> 03:15:41.444
这不是一个单独的变量，而是一个简单存储数组或列表公共简单存储数组。

1857
03:15:41.444 --> 03:15:56.591
现在，每当我们创建一个新的简单存储契约时，我们不会像这样保存它，我们要做的是我们将它保存为一个内存变量通过说简单存储，简单存储等于新的简单存储。

1858
03:15:56.591 --> 03:16:00.942
我们要把这个变量加到简单的存储数组中。

1859
03:16:00.942 --> 03:16:09.548
和之前一样，这里是简单的存储数组。push，简单的存储。

1860
03:16:09.548 --> 03:16:14.450
所以我应该拼写storage，对吧?让我们继续编译，看起来不错。

1861
03:16:14.450 --> 03:16:17.783
我们将部署存储工厂部署。

1862
03:16:17.783 --> 03:16:24.828
就像这里，我们有简单的存储阵列视图按钮，我们会创建简单的存储。

1863
03:16:24.828 --> 03:16:27.367
现在我们可以查看简单的存储契约0。

1864
03:16:27.367 --> 03:16:29.429
现在一点钟什么都没有。

1865
03:16:29.429 --> 03:16:37.950
但是如果我们创建另一个简单存储契约，我们可以在索引1处看到新的简单存储契约地址。

1866
03:16:38.117 --> 03:16:43.053
好的，这很好，我们现在可以跟踪我们所有的简单存储部署。

1867
03:16:43.117 --> 03:16:55.868
但我们如何与它们交互呢，假设我们想在所有的简单存储器上调用store函数从我们的存储工厂，你可以把存储工厂想象成所有简单存储器的管理者。

1868
03:16:55.868 --> 03:16:59.052
这就是我们要做的，我们来创建一个新函数。

1869
03:16:59.052 --> 03:17:07.024
我们创建一个函数，叫它sf store，它代表存储工厂商店。

1870
03:17:07.118 --> 03:17:20.760
它将花费你256，简单存储索引，和一个UNT 256，下划线简单存储号。

1871
03:17:20.760 --> 03:17:23.893
还会有公开拍卖。

1872
03:17:23.893 --> 03:17:29.071
为了让你与任何合同互动，你总是需要两个东西。

1873
03:17:29.071 --> 03:17:31.514
我们会经常用到它。

1874
03:17:31.514 --> 03:17:38.243
您总是需要合同的地址和合同的ABI。

1875
03:17:38.243 --> 03:17:49.537
API代表应用程序二进制接口，API会精确地告诉我们的代码如何与契约交互，我们将在后面深入讨论API。

1876
03:17:49.537 --> 03:17:53.790
但如果你到编译选项卡，点击编译，东西就在编译。

1877
03:17:53.790 --> 03:17:57.265
您可以向下滚动，并可以看到编译细节。

1878
03:17:57.265 --> 03:18:01.810
你可以在不同的合同上看到一大堆信息。

1879
03:18:01.810 --> 03:18:13.569
你可以看到合约的名称，对于我们的简单存储合约就是简单存储，你可以看到一大堆元数据，比如编译器，语言输出设置，所有这些东西。

1880
03:18:13.569 --> 03:18:17.660
您可以看到确切的字节码和操作码，我们将在稍后讨论这些内容。

1881
03:18:17.660 --> 03:18:24.970
你还可以看到这个API，这个API告诉你所有不同的输入和输出以及你可以用这个契约做的所有事情。

1882
03:18:24.970 --> 03:18:32.506
例如，在我们的简单存储中，如果我们查看API索引的0，我们有一个函数add person。

1883
03:18:32.506 --> 03:18:44.998
第一个是name to favorite number，第二个是people，第三个是retrieve for store，它告诉我们所有与合约交互的不同方式。

1884
03:18:44.998 --> 03:19:00.086
我们可以调用的不同函数，我们知道地址在哪里，因为我们把它们存储在这个数组中，我们的简单存储数组，我们还能得到API因为我们导入simple storage。soul当你编译simple storage时。

1885
03:19:00.086 --> 03:19:09.584
正如您在编译详细信息中看到的，无论何时编译它，它都预先打包了ABI，我们只需像这样导入它就可以自动获得ABI。

1886
03:19:09.584 --> 03:19:13.896
在未来，我们会看到其他方法我们可以很容易地获得API。

1887
03:19:13.896 --> 03:19:19.803
要在某个契约上调用store函数，我们首先需要获取契约对象。

1888
03:19:19.803 --> 03:19:26.151
我们能做的是，我们可以说simple storage变量叫做simple storage。

1889
03:19:26.151 --> 03:19:34.532
变量名simple storage类型的simple storage将等于一个simple storage对象。

1890
03:19:34.532 --> 03:19:46.864
不像我们上次做的那样，我们只需要把这个简单存储对象的地址放在这里，同样，我们可以从数组中获取。

1891
03:19:46.864 --> 03:19:50.085
在这个函数中，我们传递的是数组下标。

1892
03:19:50.085 --> 03:19:57.031
我们可以说简单存储契约在地址简单存储阵列。

1893
03:19:57.031 --> 03:20:01.220
At index simple存储索引。

1894
03:20:01.220 --> 03:20:06.452
这个括号表示的是访问数组中不同元素的方式。

1895
03:20:06.452 --> 03:20:19.008
如果我们想让列表的第0个元素在这里，简单存储索引就会是0，我们把它传递到这里，这就会给我们简单存储契约的地址，我们把它传递到这里的简单存储。

1896
03:20:19.008 --> 03:20:26.841
因为这是一个简单存储契约数组，所以我们可以使用索引访问这个简单存储契约。

1897
03:20:26.841 --> 03:20:37.136
简单存储，边数组下标下划线简单存储下标。

1898
03:20:37.136 --> 03:20:44.977
现在我们将契约对象保存在index simple storage index到我们的simple storage变量。

1899
03:20:44.977 --> 03:20:48.523
我们的数组在为我们记录地址。

1900
03:20:48.523 --> 03:20:52.638
它会自动伴随ABI在这里。

1901
03:20:52.638 --> 03:21:02.370
如果这只是契约对象的地址数组，那么我们就必须像这样将地址包装在一个简单的存储对象中。

1902
03:21:02.370 --> 03:21:04.361
但我们以后会讲到。

1903
03:21:04.361 --> 03:21:08.995
现在，我们要做的就是这个我们现在有了一个简单的存储契约对象。

1904
03:21:08.995 --> 03:21:14.182
现在我们有了它，就可以在简单存储契约上调用store函数了。

1905
03:21:14.182 --> 03:21:18.320
我们称之为simple storage。store。

1906
03:21:18.320 --> 03:21:23.691
我们会把简单存储号存储到它里面。

1907
03:21:23.691 --> 03:21:24.453
这太完美了。

1908
03:21:24.453 --> 03:21:28.310
如果我们现在部署这个，我们就不能读取store函数。

1909
03:21:28.310 --> 03:21:33.693
因此，让我们创建另一个函数，它可以从存储工厂的简单存储契约中读取数据。

1910
03:21:33.693 --> 03:21:44.747
我们会创建一个名为sfget的函数，它代表存储工厂get，它会取一个un256下划线的简单存储索引。

1911
03:21:44.747 --> 03:21:51.136
这将是一个公共视图函数，因为我们将从简单存储契约中读取数据。

1912
03:21:51.136 --> 03:21:53.358
它会返回一个unt256。

1913
03:21:53.358 --> 03:21:56.963
我们说简单存储。

1914
03:21:57.121 --> 03:21:59.666
简单的存储。

1915
03:22:01.121 --> 03:22:06.603
当你从上面这里使用同样的语法在简单存储索引处获取契约简单存储数组时。

1916
03:22:06.603 --> 03:22:13.351
然后我们会做返回，简单的存储。

1917
03:22:13.351 --> 03:22:19.187
重新检索得到我们刚刚存储在这里的数字。

1918
03:22:19.187 --> 03:22:23.041
我应该拼写正确，这样就不会出问题了。

1919
03:22:23.041 --> 03:22:23.548
完美的。

1920
03:22:23.548 --> 03:22:34.443
现在我们要编译，部署JAVA脚本，我们要处理一个假账户，我们要使用我们的存储工厂，删除目前所有的合约。

1921
03:22:34.443 --> 03:22:37.580
让我们继续部署下拉速率。

1922
03:22:37.580 --> 03:22:42.465
现在如果SF get在0处，我们什么都得不到。

1923
03:22:42.465 --> 03:22:45.261
简单存储地址0将是零。

1924
03:22:45.261 --> 03:22:47.822
让我们创建一个简单的存储合同。

1925
03:22:47.822 --> 03:22:52.667
这是一个简单的存储列表，我们得到的地址是0。

1926
03:22:52.667 --> 03:22:56.963
如果我们现在按SF，它不是0，我们得到0。

1927
03:22:57.121 --> 03:23:00.727
让我们在这个合约上存储一个值。

1928
03:23:02.121 --> 03:23:03.137
这个契约是零。

1929
03:23:05.121 --> 03:23:06.002
存储索引。

1930
03:23:06.002 --> 03:23:08.781
我们要拯救数字7。

1931
03:23:09.121 --> 03:23:11.025
我们就开顺丰店吧。

1932
03:23:13.121 --> 03:23:17.527
将值7存储到契约中。

1933
03:23:18.121 --> 03:23:22.537
我们现在SF得到0，它确实返回7。

1934
03:23:23.121 --> 03:23:26.803
如果用SF，我们什么都不会发生。

1935
03:23:27.121 --> 03:23:29.621
我们会得到这个revert error。

1936
03:23:30.121 --> 03:23:32.053
创建另一个简单的存储契约。

1937
03:23:33.122 --> 03:23:37.056
一，我们得到0，因为我们会得到默认值。

1938
03:23:37.122 --> 03:23:43.681
让我们继续简单的存储合同，索引1将存储数字16将进入顺丰商店。

1939
03:23:43.681 --> 03:23:46.522
现在我们做SF，得到一个，得到16个。

1940
03:23:46.522 --> 03:23:50.755
现在请随意暂停，尝试一下，这样你就能真正理解它。

1941
03:23:50.755 --> 03:24:05.758
快速回顾一下，我们的存储工厂契约允许我们创建简单的存储契约，然后将它保存到我们的简单存储阵列中，然后我们可以调用不同的函数，我们可以从存储工厂契约中存储值。

1942
03:24:05.758 --> 03:24:12.511
然后我们可以从我们的存储工厂合同中读取我们创建的任何简单存储合同的值。

1943
03:24:12.511 --> 03:24:17.622
这是非常强大的，我们可以使这两个函数更加简单。

1944
03:24:17.622 --> 03:24:23.455
当我们调用简单存储阵列时，我们可以直接在此调用Retrieve函数。

1945
03:24:23.455 --> 03:24:27.728
然后我们用括号加上简单存储索引。

1946
03:24:27.728 --> 03:24:29.575
这将返回一个简单的存储对象。

1947
03:24:29.575 --> 03:24:42.415
我们能做的是删除这整部分然后在这里做点检索，然后删除这一行，然后返回，就像这样。

1948
03:24:42.415 --> 03:24:46.372
如果您继续并保存或点击Compile，您将在那里看到绿色的复选标记。

1949
03:24:46.372 --> 03:24:50.103
我们调用的是检索函数。

1950
03:24:50.103 --> 03:24:53.535
不管这是什么，都是一个简单的存储对象。

1951
03:24:53.535 --> 03:24:54.293
如此完美。

1952
03:24:54.293 --> 03:25:08.490
我们可以在上面做同样的事情删除这部分然后点。store，下划线，简单存储边号，然后保存。

1953
03:25:08.490 --> 03:25:10.384
这是完全一样的。

1954
03:25:10.384 --> 03:25:20.649
太棒了，我们现在有了一个简单的存储契约，它可以在存储工厂契约中存储变量，这个存储工厂契约几乎可以像这些简单存储契约的管理器一样，部署并与它们本身交互。

1955
03:25:20.649 --> 03:25:22.623
这太棒了。

1956
03:25:22.623 --> 03:25:30.418
现在，假设我们非常喜欢这个简单的存储契约，但它不能完全满足我们的要求。

1957
03:25:30.418 --> 03:25:43.384
也许我们想要这样，当我们实际存储值不存储喜爱的数字时，它存储喜爱的数字加5，出于某种原因，你想要一个契约每个人的喜爱的数字比他们想象的大5个数字。

1958
03:25:43.384 --> 03:25:46.767
但你真的很喜欢这份合同的其他条款。

1959
03:25:46.767 --> 03:25:48.778
让我们创建这个新契约。

1960
03:25:48.778 --> 03:25:50.984
我们称之为额外存储空间。

1961
03:25:51.123 --> 03:25:55.984
我们写入extra storage。soul。

1962
03:25:56.123 --> 03:26:08.539
我们会创建这个新合约，我们会像通常一样设置spdx许可标识符，我们会给它pragma solidity。

1963
03:26:08.539 --> 03:26:12.748
我们用(0,8)

1964
03:26:12.748 --> 03:26:14.265
胡萝卜是0。

1965
03:26:14.265 --> 03:26:22.694
我们会说契约，额外存储如果你保存或编译，你会得到绿色的勾选标记。

1966
03:26:22.694 --> 03:26:31.759
那么我们能做什么呢?我们能做的第一件事就是复制粘贴所有这些代码到这里，然后修改额外的存储契约。

1967
03:26:31.759 --> 03:26:33.565
这看起来有点多余。

1968
03:26:33.565 --> 03:26:34.794
不过还有很多工作要做。

1969
03:26:34.794 --> 03:26:51.189
还有什么方法能让额外的存储合同和简单的存储合同一样呢?这里我们可以做继承，我们可以有额外的存储契约，也就是简单存储契约的子契约。

1970
03:26:51.189 --> 03:26:59.039
我们可以有额外的存储空间，用两行代码继承简单存储的所有功能。

1971
03:26:59.124 --> 03:27:05.435
因此，首先，为了让额外的存储契约了解简单存储，我们再次需要导入它。

1972
03:27:05.435 --> 03:27:10.224
我们写入import。斜杠，simple storage。soul。

1973
03:27:10.224 --> 03:27:17.047
我们的合同额外存储是简单存储。

1974
03:27:17.047 --> 03:27:19.877
我们保存或编译。

1975
03:27:20.124 --> 03:27:25.801
额外的存储契约和简单的存储契约是一样的。

1976
03:27:25.801 --> 03:27:29.374
它会继承简单存储的所有功能。

1977
03:27:29.374 --> 03:27:34.058
我们甚至可以看到，让我们继续，确保这是编译好的。

1978
03:27:34.124 --> 03:27:35.708
我们将部署它。

1979
03:27:37.124 --> 03:27:53.073
我们可以看到我们有额外的存储部署了所有简单存储的功能，如果你想要一个契约继承另一个契约的所有功能，你可以导入它，说你的契约是另一个契约。

1980
03:27:53.073 --> 03:27:57.470
现在，我们可以向额外的存储契约添加额外的函数。

1981
03:27:57.470 --> 03:28:00.600
这将包括简单存储的所有功能。

1982
03:28:00.600 --> 03:28:04.031
现在，假设我们将简单存储继承为额外存储。

1983
03:28:04.031 --> 03:28:08.253
然而，简单存储中的一个函数我们并不喜欢。

1984
03:28:08.253 --> 03:28:19.398
如果我们回到我们的简单存储契约，我们的存储函数，它所做的就是取一个喜爱号，然后将全局喜爱号赋值给我们在额外存储中赋予它的新号码。

1985
03:28:19.398 --> 03:28:21.861
我们希望store函数做一些不同的事情。

1986
03:28:21.861 --> 03:28:26.222
我们想让它加5，给它的任何数。

1987
03:28:26.222 --> 03:28:30.387
我们怎样才能做到这一点呢?我们可以重写函数。

1988
03:28:30.387 --> 03:28:33.366
我们会用到两个关键词。

1989
03:28:33.366 --> 03:28:35.572
它们是虚拟的，和覆盖。

1990
03:28:35.572 --> 03:28:41.072
现在，如果我要实现一个存储函数来增加存储空间，让我们看看会发生什么。

1991
03:28:41.072 --> 03:28:46.546
我们说函数商店，你到最喜欢的数字6。

1992
03:28:46.546 --> 03:28:49.315
会有一个公共活动。

1993
03:28:49.315 --> 03:28:59.705
我们不只是存储最喜欢的数字，我们说最喜欢的数字等于最喜欢的数字，加5。

1994
03:28:59.705 --> 03:29:05.196
如果我们现在编译这个，我们会遇到两个不同的错误。

1995
03:29:05.196 --> 03:29:09.711
第一个会说，override function is missing, override specifier。

1996
03:29:09.711 --> 03:29:22.948
如果父契约，也就是简单存储有相同的函数，我们需要告诉实体我们要重写这个store函数取而代之的是这个store函数。

1997
03:29:22.948 --> 03:29:27.682
另外，我们会得到另一个错误说试图重写非虚函数。

1998
03:29:27.682 --> 03:29:37.056
为了使函数可覆盖，您是否忘记添加virtual，您需要向store函数添加virtual关键字。

1999
03:29:37.125 --> 03:29:38.819
现在它可以被重写了。

2000
03:29:41.125 --> 03:29:45.232
我们仍然有这个问题覆盖函数缺少覆盖说明符。

2001
03:29:45.232 --> 03:29:49.140
然后我们需要做的就是添加override来恢复功能。

2002
03:29:49.140 --> 03:29:54.029
现在，如果我们正确地保存所有编译文件，让我们继续并部署它。

2003
03:29:54.029 --> 03:29:55.997
我们把旧合同删掉吧。

2004
03:29:56.125 --> 03:29:57.571
JavaScript虚拟机权限帐户。

2005
03:29:59.125 --> 03:30:01.093
额外的store Reg，让我们继续部署。

2006
03:30:02.125 --> 03:30:03.267
存储合同。

2007
03:30:06.125 --> 03:30:09.075
以前，我们的store函数将存储确切的数字。

2008
03:30:09.125 --> 03:30:13.397
然而，如果我要存储5，它将存储5，加上5。

2009
03:30:13.397 --> 03:30:15.634
所以这里应该有10个。

2010
03:30:15.634 --> 03:30:21.322
让我们继续调用store，然后点击检索。

2011
03:30:21.322 --> 03:30:23.617
我们确实看到10在这里。

2012
03:30:23.617 --> 03:30:28.449
这就是我们如何进行继承，重写函数。

2013
03:30:28.449 --> 03:30:30.507
就是这样。

2014
03:30:30.507 --> 03:30:37.355
在本节中，您已经学习了大量用于拥有多个文件的非常强大的可靠性。

2015
03:30:37.355 --> 03:30:52.862
让我们快速概述一下我们所学到的内容，我们了解到我们可以使用new关键字从其他合同部署合同，我们还了解到我们可以使用import关键字将其他合同导入到我们的合同和代码中。

2016
03:30:52.862 --> 03:31:00.376
import关键字与复制粘贴该文件到导入行位置相同，我们知道我们可以与其他契约交互。

2017
03:31:00.376 --> 03:31:02.813
只要我们有ABI和地址。

2018
03:31:02.813 --> 03:31:04.766
我们对ABI了解不多。

2019
03:31:04.766 --> 03:31:13.741
之后我们会学到更多，如果我们想要创建子契约并继承其他契约的功能，我们可以做继承。

2020
03:31:13.741 --> 03:31:20.190
继承功能的方法是使用is关键字并说我们的契约是另一个契约。

2021
03:31:20.190 --> 03:31:26.745
然而，如果我们想从父契约的功能进行更改，就必须重写该功能。

2022
03:31:26.745 --> 03:31:34.538
另外，我们必须将我们想要覆盖的函数设为虚拟现在我们可以有自己的store函数，做任何我们想要它做的事。

2023
03:31:34.538 --> 03:31:36.370
本节课到此结束。

2024
03:31:36.370 --> 03:31:40.660
再一次，给自己热烈的掌声，鼓励自己走到今天。

2025
03:31:40.660 --> 03:31:42.207
完成这一节。

2026
03:31:42.207 --> 03:31:51.598
你很快就得到了越来越先进的设备，所以一定要通过吃冰淇淋、散步、发推特或在Reddit上发帖来庆祝小胜利。

2027
03:31:51.598 --> 03:31:56.953
恭喜你，你已经完成了这一部分。

2028
03:31:57.127 --> 03:31:58.161
好了，各位。

2029
03:31:58.161 --> 03:31:58.833
欢迎回来。

2030
03:32:00.127 --> 03:32:02.076
第四课混音Funmi。

2031
03:32:06.127 --> 03:32:09.076
可以在与本课程相关的GitHub知识库中找到。

2032
03:32:09.127 --> 03:32:13.110
我们将在这里与两个合同工作，其中一个是基础大底。

2033
03:32:13.110 --> 03:32:21.323
其中一个是价格转换Funmi。Sol将是一个合同，允许人们实际为集体商品提供资金。

2034
03:32:21.323 --> 03:32:34.280
人们可以将Aetherium，或polygon，或Avalanche，或Phantom，或任何区块链原生代币发送到合同中，然后合同的所有者可以提取这些资金，做任何他们想做的事。

2035
03:32:34.280 --> 03:32:47.241
在将其部署到测试网络后，我们可以看到该合同的功能列表，这将有两个红色按钮，用于标记我们的基金功能中的基金支付功能。

2036
03:32:47.241 --> 03:33:01.506
在我们的取款功能中，取款允许用户提取资金而基金允许用户向合约中汇款，我们能做的是在交易中发送一些价值。

2037
03:33:01.506 --> 03:33:11.437
当我们调用这个基金函数时，我们能做的就是通过将一些值粘贴到方法值部分来为这个合约提供一定数量的资金。

2038
03:33:11.437 --> 03:33:16.634
然后点击fund，我们将把钱送到部署合同中。

2039
03:33:16.634 --> 03:33:27.061
我们可以看到资助者的名单和这些地址的映射以及他们实际向合同中投入了多少钱，然后我们可以从合同中提取资金。

2040
03:33:27.127 --> 03:33:33.073
但有一个特殊的例外情况只有部署这个合同的人可以把资金取出来。

2041
03:33:33.128 --> 03:33:36.075
一旦资金被取出，所有资金的金额将重置为零。

2042
03:33:36.075 --> 03:33:38.022
你兴奋吗?嗯，你应该害怕。

2043
03:33:38.128 --> 03:33:56.576
如果你已经完成了这一节，你已经完成了大部分的基础，你将准备好开始制作更强大的智能合约，我们将使用通道价格feed来实际设置这些人应该能够获得多少美元的资金而不是以太币，我们将在这里复习很多高级部分。

2044
03:33:56.576 --> 03:33:59.478
我会告诉你们哪些部分比较难消化。

2045
03:33:59.478 --> 03:34:02.851
所以你不需要把所有的时间都花在试图弄清楚到底发生了什么。

2046
03:34:02.851 --> 03:34:09.898
一定要使用GitHub回购为你的优势在这里和讨论选项卡保持与其他学习这一课的人联系。

2047
03:34:09.898 --> 03:34:12.160
好了，我们开始吧。

2048
03:34:12.160 --> 03:34:21.581
在这一点上，在混音中，你会有一些契约，简单的存储，存储，工厂额外的存储，也许你刷新了混音，这些都消失了。

2049
03:34:21.581 --> 03:34:28.628
在这种情况下，确保你没有打开任何标签，我们将创建一个新的合同，叫做融资。

2050
03:34:28.628 --> 03:34:32.998
让我们开始创建我们的融资合同。

2051
03:34:32.998 --> 03:34:42.531
同样，我们希望它能够从用户那里获得资金和提取资金，并设置以美元为单位的最低资金价值。

2052
03:34:42.531 --> 03:34:46.440
这就是我们在合同中要做的。

2053
03:34:46.440 --> 03:34:58.240
首先，让我们设置spdx许可我倾向于用MIT做pragma solidity做插入0点8。

2054
03:34:58.240 --> 03:34:58.385
8.

2055
03:34:58.385 --> 03:35:01.603
我们会做bunbee。

2056
03:35:01.603 --> 03:35:02.258
太棒了。

2057
03:35:02.258 --> 03:35:05.718
我们会编译，看看效果是否不错。

2058
03:35:05.718 --> 03:35:06.504
他们确实做到了。

2059
03:35:06.504 --> 03:35:06.897
太好了。

2060
03:35:06.897 --> 03:35:08.011
让我们继续。

2061
03:35:08.011 --> 03:35:14.081
在我们开始创建所有的函数之前，让我们先加入我们要实现的不同的函数。

2062
03:35:14.129 --> 03:35:25.255
所以我们想要一个功能基金，让人们把钱投进去，我们想要一个功能提取，或者这个合同的所有者实际上提取不同的出资人给我们的资金。

2063
03:35:25.255 --> 03:35:26.905
差不多就是这样了。

2064
03:35:26.905 --> 03:35:35.383
这是我们希望这个合同实现的两个主要功能，我们将实现更多的功能来帮助促进这两个功能。

2065
03:35:35.383 --> 03:35:37.535
我们先来看看基金。

2066
03:35:37.535 --> 03:35:39.279
让我们暂时取消取款。

2067
03:35:39.279 --> 03:35:40.779
让我们从乐趣开始。

2068
03:35:40.779 --> 03:35:44.004
我们希望任何人都能调用这个有趣的函数。

2069
03:35:44.004 --> 03:35:45.629
所以我们要公开这个。

2070
03:35:45.629 --> 03:35:52.269
如前所述，我们希望能够设置以美元为单位的最小字体数量。

2071
03:35:52.269 --> 03:35:54.472
这里有很多东西要考虑。

2072
03:35:54.472 --> 03:36:09.970
首先，我们可能要考虑的是，当我们在任何这些EVM区块链上创建交易时，我们如何向这个合同发送eath，我们可以设置这个值字段，该值表示我们将在交易中发送多少Aetherium。

2073
03:36:09.970 --> 03:36:12.586
例如，当我们转让Aetherium时。

2074
03:36:12.586 --> 03:36:19.557
在我们不同的账户之间，我们实际上用不同数量的Aetherium填充了这个值参数。

2075
03:36:19.557 --> 03:36:37.387
事实上，我们发送的每一笔交易，都会有这些字段，它会有nonce或交易计数，帐户，汽油价格，我们在以太上看到的汽油限额，扫描a，也就是交易发送到的地址，一个值就是我们正在讨论的这个值。

2076
03:36:37.387 --> 03:36:46.049
它们还会有我们发送的数据如果我们进行函数调用或部署契约，然后我们会有这个v r s组件。

2077
03:36:46.049 --> 03:37:03.812
我们不打算讲这些v r和s因为这是交易签署时发生的加密魔法，但要知道就是这样，对于发送值，我们可以填充其中一些字段，例如气体限制，填充到21,000数据将为空。

2078
03:37:03.812 --> 03:37:13.880
然后这2将是我们想要发送到的事务的地址，对于函数调用，我们仍然可以按照我们想要发送的方式填充。

2079
03:37:13.880 --> 03:37:23.458
我们可以调用一个函数，同时在remix中发送一个值这里有一个小的下拉，是way Feeny和ether，我们现在先忽略Feeny。

2080
03:37:23.458 --> 03:37:25.708
但当然，我们有自己的方式，伟大的，伟大的。

2081
03:37:25.708 --> 03:37:28.581
我们是一个以太值这么多。

2082
03:37:28.581 --> 03:37:38.093
这样一来，为了让一个函数可以用Aetherium或任何其他原生区块链货币支付，我们需要做的第一件事就是将该函数标记为可支付。

2083
03:37:38.093 --> 03:37:57.664
正是这个payable关键字让我们的字体功能变成了红色，而不是普通的橙色，就像我们的钱包可以容纳资金一样，合同地址也可以容纳资金，因为每次你部署一个合同，他们就会得到一个合同地址，它几乎与钱包地址完全相同。

2084
03:37:57.664 --> 03:38:04.049
所以钱包和合同都可以像Aetherium一样持有原生区块链代币。

2085
03:38:04.130 --> 03:38:10.505
你们会看到，当我们在后面的课程中使用这个时，它实际上会获得一个Aetherium的平衡。

2086
03:38:10.505 --> 03:38:21.487
既然它是可支付的，我们就可以通过使用带有message dot value的solididity中的一个全局关键字来访问这个值属性，以获得某人发送的值的多少。

2087
03:38:21.487 --> 03:38:23.919
在函数中使用message。value。

2088
03:38:23.919 --> 03:38:29.064
现在，假设我们想将消息的add value设置为Aetherium的某个值。

2089
03:38:29.130 --> 03:38:36.791
假设我们想让它。假设我们想让人们用所有的交易发送至少一个以太。

2090
03:38:36.791 --> 03:38:41.416
换句话说，如果他们发送了Aetherium，他们至少需要发送一个Aetherium。

2091
03:38:41.416 --> 03:38:51.946
我们如何实现它?我们可以调用require，我们会说我们想要求message。value大于1e18。

2092
03:38:51.946 --> 03:38:56.037
这里有几样东西要整理。

2093
03:38:56.037 --> 03:39:07.499
1 e18等于1乘以10的18次方，也等于112345 678-910-1234 5678。

2094
03:39:07.499 --> 03:39:14.631
这是一个以太的价值，这是一个以太的价值。

2095
03:39:14.631 --> 03:39:25.115
如果我们想让message。value至少是一个eath，或者一个polygon，或者什么ranch等等，我们会这样设置它，要求message。value大于1。

2096
03:39:25.115 --> 03:39:31.983
这个require关键字是一个检查器，它说，嘿，是否message。value大于1。

2097
03:39:31.983 --> 03:39:36.196
如果没有，它就会恢复，它会做所谓的带错误消息的恢复。

2098
03:39:36.196 --> 03:39:47.365
我们可以说，没有发送足够多，我们会试着在JavaScript VM上部署这个，部署Funmi，点击部署，看Funmi我们看到这个fun按钮现在是红色的。

2099
03:39:47.365 --> 03:40:00.900
如果我们现在调用Funmi，我们看控制台，你可以看到我们在这里得到一个错误，再调用它，我们得到一个错误，我们在这里得到一个错误，我们知道空气将是这个没有发送足够多。

2100
03:40:00.900 --> 03:40:09.669
所以我们需要做的是在这个有趣的事务中至少发送一个以太，以便这个require语句被实现。

2101
03:40:09.669 --> 03:40:14.359
回到值部分，我们可以把这个值改为1。

2102
03:40:14.359 --> 03:40:19.208
所以这是一个乙醚，或者这个方向，或者这个方向。

2103
03:40:19.208 --> 03:40:23.072
现在我们可以点击fundoh实际上需要大于1。

2104
03:40:23.132 --> 03:40:25.465
举个例子。

2105
03:40:25.465 --> 03:40:27.298
现在我们向下滚动。

2106
03:40:28.132 --> 03:40:29.007
我们会找到资金的。

2107
03:40:32.132 --> 03:40:37.390
语句表示，如果第一部分为false，则继续执行并返回此错误。

2108
03:40:37.390 --> 03:40:42.674
什么是还原?Revert可能有点令人困惑，所以我不会让这一节阻碍您的学习。

2109
03:40:42.674 --> 03:40:44.775
如果这有点让人困惑的话。

2110
03:40:44.775 --> 03:40:49.674
Revert是指撤销之前发生的任何操作，并将剩余的气体发送回。

2111
03:40:49.674 --> 03:40:56.386
那它到底是什么样子的呢?举个例子，我们有一个un 256。

2112
03:40:56.386 --> 03:40:57.809
公众的数量。

2113
03:40:57.809 --> 03:41:02.606
在基金函数中，数字等于5。

2114
03:41:02.606 --> 03:41:07.075
如果我们要继续部署它，让我们删除旧的契约。

2115
03:41:07.132 --> 03:41:10.615
部署这个新合同的数字现在是零。

2116
03:41:11.132 --> 03:41:14.439
我们把基金函数号设为5。

2117
03:41:14.439 --> 03:41:22.865
然而，如果我们调用一个基金，而这个要求没有得到满足，这个交易将恢复一个不适当的设置数字到5。

2118
03:41:22.865 --> 03:41:25.671
我们来看看这里的对数。

2119
03:41:25.671 --> 03:41:29.502
我们将值保持为0，这样我们的fun函数就会恢复。

2120
03:41:29.502 --> 03:41:36.953
我们调用fund会看到这个交易失败因为这个请求最终会返回，而number仍然是0。

2121
03:41:36.953 --> 03:41:59.266
那么问题就变成了，我们真的消耗了气体吗是的，我们消耗了气体把数字变成5然后剩下的气体我们将通过这个要求返回例如，如果我们在这里有大量的计算，在这里的计算中，我们需要用fun函数发送大量的气体。

2122
03:41:59.266 --> 03:42:12.296
但所有我们发送的额外气体，在这个require被返回后原始用户在它被还原后，如果还原对你们来说有点困惑，不用太担心，我们会在以后的模块中讲到。

2123
03:42:12.296 --> 03:42:23.563
现在您所需要知道的是，当您执行require语句时，如果第一部分没有得到满足，事务将被取消，之前的所有工作将被撤消，并且它将发送一个错误消息。

2124
03:42:23.563 --> 03:42:23.870
酷。

2125
03:42:23.870 --> 03:42:25.900
我们先把这个号码删掉。

2126
03:42:25.900 --> 03:42:28.396
我们会从全局作用域中删除它。

2127
03:42:28.396 --> 03:42:34.370
其实还有另一种方法来做这些还原，我们会在合同后面讲到。

2128
03:42:34.370 --> 03:42:37.929
到目前为止，我们做的很好。

2129
03:42:38.133 --> 03:42:53.116
然而，我们正在根据Aetherium检查消息的点值，我们正在寻找一个完整的Aetherium而不是$50，我们想要检查消息的增加值大于某些数字，如$50。

2130
03:42:53.116 --> 03:43:08.976
让我们先设定我们希望人们随基金函数一起发送的最低美元价值，我们可以在合同的顶部这样做，我们可以说你去了56个公共场所，最低美元等于50。

2131
03:43:08.976 --> 03:43:20.098
现在我们有一些地方可以检查最低美元，我们将更新这个最低美元，使它更省油。

2132
03:43:20.098 --> 03:43:29.180
现在我们已经设置了最小USD，我们希望能够要求value大于或者我们说大于或等于最小USD的消息。

2133
03:43:29.180 --> 03:43:36.134
但是最低美元是用美元来表示的，价值是用Aetherium来表示的。

2134
03:43:36.134 --> 03:43:43.899
所以我们如何将Aetherium转换成美元，这就是Oracle和chainlink将要发挥作用的地方。

2135
03:43:43.899 --> 03:43:54.540
Aetherium的美元价值是我们在区块链之外分配给Aetherium的，或者任何其他一层货币或任何其他本地智能合约平台货币。

2136
03:43:54.540 --> 03:44:03.634
因此，为了得到这个在区块链之外的值，我们必须使用去中心化的Oracle网络来获得以美元表示的一个以太币的价格。

2137
03:44:03.634 --> 03:44:12.426
所以在我们继续之前，让我们更多地了解一下这些去中心化Oracle网络的体系结构以及它们所拥有的不同解决方案。

2138
03:44:12.426 --> 03:44:24.201
所以我们可以用最先进的方式创建Funmi契约，因为我们已经讨论过区块链是确定性系统，这意味着它们本身不能与现实世界的数据和事件交互。

2139
03:44:24.201 --> 03:44:28.828
他们不知道Aetherium的价值，他们不知道随机数是什么。

2140
03:44:28.828 --> 03:44:34.667
他们不知道外面是不是晴天，他们不知道温度，他们不知道谁是总统，他们不知道这些信息。

2141
03:44:34.667 --> 03:44:38.134
这些区块链也不能进行任何外部计算。

2142
03:44:38.134 --> 03:44:43.555
也许您有一些了不起的人工智能模型，希望将其集成到智能合约中。

2143
03:44:43.555 --> 03:44:46.569
智能合约本身不能做任何事情。

2144
03:44:46.569 --> 03:44:50.212
正如我们所提到的，这是因为区块链在设计上是确定的。

2145
03:44:50.212 --> 03:44:52.848
这样所有的节点都能达成共识。

2146
03:44:52.848 --> 03:45:03.591
如果开始添加变量数据或随机数据，或从API调用返回的值，不同的节点可能得到不同的结果，它们永远无法达成一致。

2147
03:45:03.591 --> 03:45:08.009
这被称为智能合约连接问题，或Oracle问题。

2148
03:45:08.009 --> 03:45:13.661
这是个坏消息，因为我们希望我们的智能合约能够取代传统的协议。

2149
03:45:13.661 --> 03:45:18.135
传统的协议需要数据，需要与现实世界互动。

2150
03:45:18.135 --> 03:45:21.965
这就是chainlink和区块链，Oracle的作用所在。

2151
03:45:21.965 --> 03:45:28.924
区块链Oracle将是任何与日常世界交互的设备，为智能合约提供外部数据或计算。

2152
03:45:28.924 --> 03:45:31.544
然而，整个故事甚至没有在那里。

2153
03:45:31.544 --> 03:45:36.935
如果我们使用集中式Oracle，就会重新引入一个故障点。

2154
03:45:36.935 --> 03:45:40.210
我们已经做了所有这些工作，使我们的逻辑层去中心化。

2155
03:45:40.210 --> 03:45:47.977
但是，如果我们通过集中的节点或集中的API获取数据，我们就会决定自己调用API。

2156
03:45:47.977 --> 03:45:56.023
我们正在重新引入这些信任假设，我们一直在努力摆脱这些假设，我们实际上正在破坏构建智能合约的整个目的。

2157
03:45:56.023 --> 03:46:01.447
所以我们不想通过集中的节点来获取数据或进行外部计算。

2158
03:46:01.447 --> 03:46:02.634
这些都是坏消息。

2159
03:46:02.634 --> 03:46:04.325
链条是解决方案。

2160
03:46:04.325 --> 03:46:10.827
chain link是一个分散的Oracle网络，用于将数据和外部计算引入我们的智能合约。

2161
03:46:10.827 --> 03:46:19.790
正如我们前面提到的，这产生了这些混合智能合约，它们结合了链上和链下，形成了功能丰富、功能强大的应用程序。

2162
03:46:19.790 --> 03:46:27.987
chain link是一个模块化、去中心化的Oracle网络，可以定制它来交付任何数据或进行任何您喜欢的外部计算。

2163
03:46:27.987 --> 03:46:36.053
例如，很多人说，哦，我可以对一些API进行HTTPS调用，然后我们就可以很好地进行了。

2164
03:46:36.135 --> 03:46:41.407
区块链节点不能进行这些HTTPS调用，因为它们无法达成共识。

2165
03:46:41.407 --> 03:46:44.685
如果它们在不同的时间调用节点，或者它们做了其他事情。

2166
03:46:44.685 --> 03:46:46.747
所有的共识都将被打破。

2167
03:46:46.747 --> 03:46:57.504
因此，我们需要一个分散的链链网络Oracle来做这件事，然后在交易中，这个节点网络将为我们把数据转化为智能合约。

2168
03:46:57.504 --> 03:47:03.830
现在链链网络可以完全定制，带来任何你想要的数据或任何外部计算。

2169
03:47:03.830 --> 03:47:15.086
然而，进行定制可能需要一些额外的工作，有大量的链连接特性可以完全去中心化，随时可以插入和使用到智能合约应用程序中。

2170
03:47:15.136 --> 03:47:20.656
这些特性是什么，第一个是数据传输通道，这是我们在应用中要用到的。

2171
03:47:20.656 --> 03:47:25.023
目前在记录的时候传输的数据超过了500亿美元。

2172
03:47:25.023 --> 03:47:51.785
在对抗世界,他们的工作方式是一个网络的链条节点获得数据从不同的交流和数据的提供者和将数据通过网络分散链像笔记,链条节点使用一个值求出资产的实际价格是什么,然后交付在单个事务中所谓的参考合同,饲料价格合同或者合同数据链,其他聪明的合同可以使用。

2173
03:47:51.785 --> 03:47:57.564
然后这些智能合约使用这些定价信息来支持它们的违抗程序，我们可以看到一个例子。

2174
03:47:57.564 --> 03:48:00.732
我们可以在data。chain。link看到一个例子。

2175
03:48:00.732 --> 03:48:07.823
你可以改变网络，你可以改变价格来源，你可以改变一大堆不同的信息来查看一些流行的价格来源。

2176
03:48:07.823 --> 03:48:10.010
让我们以每一美元为例。

2177
03:48:10.010 --> 03:48:24.071
在每一个美元上，我们可以看到这个由独立的链节点操作者组成的整个网络每个结点都得到不同的答案，它们被网络聚合，然后在链上传递，我们可以看到它们更新的频率。

2178
03:48:24.136 --> 03:48:25.881
这些是更新的。

2179
03:48:28.136 --> 03:48:29.781
心跳一小时，看哪一个。

2180
03:48:31.136 --> 03:48:46.550
上次更新是我们可以看到Oracle的响应数量等，我们可以直接在链上看到合同地址，我们甚至可以在以太扫描上查看合同，我们可以看到一些历史，我们可以看到不同Oracle的所有响应。

2181
03:48:46.550 --> 03:48:53.046
然后在底部，我们可以看到不同的用户和赞助商，保持这个网络。

2182
03:48:53.046 --> 03:49:03.257
与事务气体类似，每当节点操作符向智能合约交付数据时，链链接节点操作符都会在链链接令牌中获得一点Oracle气体。

2183
03:49:03.257 --> 03:49:10.821
现在，协议的这些用户正在赞助保持这些提要，并支付与在链上传输数据相关的Oracle gas。

2184
03:49:10.821 --> 03:49:29.530
这里展示了这些数据提要的当前模型是什么样子的这些链连接节点组成的网络，每个节点伸出手，获取关于资产的信息，然后在单个交易中用自己的私钥签署数据，然后，一个节点将所有具有不同签名的数据交付到一个参考契约。

2185
03:49:29.530 --> 03:49:33.120
如果该节点不发送数据，则由另一个节点发送。

2186
03:49:33.120 --> 03:49:43.298
信誉是非常重要的，当你的链节点运营商如果你错过数据更新，如果你忘记发送交易，你可能会很快被踢出这些网络，并没有机会在未来赚更多的钱。

2187
03:49:43.298 --> 03:50:01.298
这些数据源被该领域一些最大的协议所使用，例如合成，寿司交换化合物，和Avi，每个协议都有数十亿美元，我们可以看看Doc的。链。链工作与EVM合同的例子，我们将触及EVM链，向下滚动到数据源。

2188
03:50:01.298 --> 03:50:04.007
我们将向下滚动到固体部分。

2189
03:50:04.137 --> 03:50:10.975
我们可以看到一个完整的合同的例子，它使用并读取这些趋势价格提要中的一个。

2190
03:50:10.975 --> 03:50:15.575
我们甚至可以把它打开，然后混音，用它来混音。

2191
03:50:15.575 --> 03:50:19.280
看起来这个例子是从COVID的价格提要中读取的。

2192
03:50:19.280 --> 03:50:25.100
我们要用一个测试网络来观察这个工作的原因是有一组链接节点在监控测试网络。

2193
03:50:25.138 --> 03:50:27.441
让你们看看这到底是怎么回事。

2194
03:50:28.138 --> 03:50:35.915
深入本课程，我们将向您展示如何实际运行测试和使用链连接节点，而无需实际在测试网络上，这将使您的开发更快。

2195
03:50:35.915 --> 03:50:43.312
但是我强烈建议您和我一起浏览这一节，这样您就可以亲眼看到它是如何工作的。

2196
03:50:43.312 --> 03:50:46.388
让我们继续，水龙头。链条。链接斜线COVID。

2197
03:50:46.388 --> 03:50:51.400
我们将切换到新冠肺炎网络，我们将获得一些新冠肺炎的信息。

2198
03:50:51.400 --> 03:50:57.204
但请记住，查看网络标志并使用文档中的任何网络。

2199
03:50:57.204 --> 03:51:07.471
因此，为了获得COVID病毒，我们将来到水龙头，我们将关闭测试链接，我们只需要和每个人呆在一起，我不是机器人，然后发送请求。

2200
03:51:07.471 --> 03:51:16.695
一旦我们的COVID Aetherium到达我们的钱包，我们可以继续并关闭。我们可以查看我们的钱包，看到我们确实有0。

2201
03:51:16.695 --> 03:51:17.744
开尔文是1比1。

2202
03:51:17.744 --> 03:51:23.988
现在让我们回到我们的混合，我们将编译这个契约，并在注入的web 3上部署它。

2203
03:51:23.988 --> 03:51:33.388
我们使用注入web 3而不是JavaScript VM的原因是没有链接节点的网络来监视我们的伪JavaScript VM。

2204
03:51:33.388 --> 03:51:36.852
有一个由链状节点组成的网络监视着测试网。

2205
03:51:36.852 --> 03:51:38.185
我们向下滚动。

2206
03:51:38.185 --> 03:51:56.839
我们将合同切换到价格消费者v3，然后点击部署，大量会弹出，在短暂的延迟之后，我们可以看到价格供给消费者在这里，我们可以点击获取最新价格，这显示了以美元计算的Aetherium的最新价格你可能会好奇为什么这个数字看起来如此奇怪。

2207
03:51:56.839 --> 03:52:06.289
对于以美元计算的Aetherium价格来说，这似乎是一个很大的数字，这是因为小数在固体中并不是很有效，我们稍后会讲到这个问题。

2208
03:52:06.289 --> 03:52:13.416
有一个与这个价格提要地址相关联的小数标记，它告诉我们这个价格包含多少小数。

2209
03:52:13.416 --> 03:52:15.138
文档中也有。

2210
03:52:15.138 --> 03:52:17.884
但是，我知道这个有8个小数点。

2211
03:52:17.884 --> 03:52:22.359
也就是说，Aetherium现在的价值是3262美元。

2212
03:52:22.359 --> 03:52:26.074
当然，当你继续尝试时，情况可能会有所不同。

2213
03:52:26.074 --> 03:52:30.696
在这个合同中发生了很多事情我会在Funmi的例子中解释。

2214
03:52:30.696 --> 03:52:35.089
但如果你现在想看一看，看看你是否能弄明白发生了什么，我建议你这样做。

2215
03:52:35.139 --> 03:52:43.549
价格信息是最强大的开箱即用的去中心化功能之一，您可以使用智能合约来升级它们，特别是对于去中心化金融。

2216
03:52:43.549 --> 03:52:55.456
如果您正在寻找不同价格提要的不同地址，您可以查看文档中的合同地址部分，选择您想要的网络，然后向下滚动查看不同价格提要的一些不同地址。

2217
03:52:55.456 --> 03:53:01.021
例如，这个地址将给你一个英寸代币的价格，以Aetherium。

2218
03:53:01.021 --> 03:53:07.805
这个地址会告诉你苹果股票以美元计的价格，等等。

2219
03:53:07.805 --> 03:53:14.980
下一个开箱即用的去中心化应用将是引导VRF或引导可验证的随机功能障碍。

2220
03:53:14.980 --> 03:53:21.031
等我们做完彩票的例子后，我们将讨论如何在区块链中操纵随机性。

2221
03:53:21.031 --> 03:53:25.622
区块链是确定性系统，根据定义，这意味着它们不能有随机性。

2222
03:53:25.622 --> 03:53:37.806
如果你能确定一个随机数是什么，它就不再是随机的了，不是吗?因此，我们需要等待，通过查看区块链之外的数据来得到一个可证明的随机数，而Oracle的数据正好可以做到这一点。

2223
03:53:37.806 --> 03:53:46.953
链链可验证随机函数是一种将可证明随机数引入智能合约的方法，以保证应用程序的公平性和随机性。

2224
03:53:46.953 --> 03:54:01.377
许多协议，如将x∞组合在一起，以太卡，牛油果奶酪等，在彩票中使用通道VRF，在游戏中使用随机NF T等等，我们将在后面的部分中做一个通道VRF的例子。

2225
03:54:01.377 --> 03:54:10.868
一旦我们进入彩票部分，如果你想看看你现在是否可以自己玩随机性，我建议你进入Doc的链链接EVM链，并向下滚动获得一个随机数。

2226
03:54:10.868 --> 03:54:15.089
这将教你如何在应用程序中引入可证明的随机数。

2227
03:54:15.140 --> 03:54:22.597
下一个去中心化的开箱即用的链链特性是链式的保持器，它是去中心化的事件驱动执行。

2228
03:54:22.597 --> 03:54:32.864
正如我们所见，为了启动某种类型的交易，有人需要花汽油，有人需要坐下来，按下开始按钮，按下交易按钮，或按下太阳。

2229
03:54:32.864 --> 03:54:34.486
但这显然是一个集中向量。

2230
03:54:34.486 --> 03:54:40.473
如果您有一个去中心化的应用程序，需要在特定时间运行，或者在特定事件触发后运行。

2231
03:54:40.473 --> 03:54:49.092
Channeling keepers是这种情况的解决方案，Channeling keepers是链式链接节点，侦听您指定要触发的不同事件的注册契约。

2232
03:54:49.092 --> 03:55:09.381
也许你说每隔10分钟，你想做点什么，或者一周做一次，或者如果某种酸的价格达到某个数字，或者也许流动性池达到某个水平，无论你想编码什么事件，你绝对可以让链连接节点不断监听这些触发发生并检查这些触发的不同合约。

2233
03:55:09.381 --> 03:55:22.263
一旦触发器返回true，链结节点就会执行你让链结节点做的任何动作，我们现在也不打算复习链结keepers的例子，因为我们将在后面的模块中讲到它们。

2234
03:55:22.263 --> 03:55:26.761
然而，如果你想尝试一下，去Doc's触摸链接斜杠Aetherium。

2235
03:55:26.761 --> 03:55:31.630
去制作兼容的合同你们可以随意阅读文档。

2236
03:55:31.630 --> 03:55:32.528
你自己试试。

2237
03:55:32.528 --> 03:55:41.093
链条的最后一个开箱即用特性是最可定制的，但也是最难获得正确的端到端可靠性，这是我们智能合约的最终承诺。

2238
03:55:41.141 --> 03:55:54.665
我们希望它们能够做任何事情，我们希望能够接受任何输入并获得任何输出使HTTP get HTTP POST请求是一种简单的方法来定制我们的链节点使其能够做任何事情。

2239
03:55:54.665 --> 03:56:06.327
还记得我们讲过如何使用API调用区块链节点本身可以做到吗?链链接节点可以做到这一点，链链接节点可以直接向您指定的任何API发出请求。

2240
03:56:06.327 --> 03:56:25.074
为了做到这一点，您必须同时选择链接节点和URL斜杠数据来发送请求，这比链接VRF保存器或价格提要要稍微复杂一些，因为您必须负责创建从许多不同的链接节点和许多不同的数据提供者获取数据的链接网络。

2241
03:56:25.141 --> 03:56:27.953
但让我们看一个混音的例子。

2242
03:56:29.141 --> 03:56:31.341
请随意观看，因为我们正在使用一个测试网。

2243
03:56:31.341 --> 03:56:34.272
正如我们所见，测试网需要一点时间。

2244
03:56:34.272 --> 03:56:36.334
只要你熟悉这个过程是怎样的。

2245
03:56:36.334 --> 03:56:37.253
这就足够了。

2246
03:56:37.253 --> 03:56:40.203
如果你不想，你可以不去尝试。

2247
03:56:40.203 --> 03:56:43.015
我们会打开，remix会通读。

2248
03:56:43.141 --> 03:56:45.521
看起来这个例子在COVID网络上。

2249
03:56:46.141 --> 03:56:48.045
编译API消费者。

2250
03:56:50.141 --> 03:56:55.046
在注射的网络3上，我们要确保我们回到了COVID检测网络。

2251
03:56:55.046 --> 03:56:56.760
我们向下滚动。

2252
03:56:56.760 --> 03:56:59.105
我们将改变API消费者的契约。

2253
03:56:59.142 --> 03:57:04.379
我们将继续并点击部署，我们将部署这个合同到COVID。

2254
03:57:04.379 --> 03:57:04.989
测试网络。

2255
03:57:04.989 --> 03:57:09.955
现在我们可以调用这个函数称为请求体积数据做一个API调用。

2256
03:57:09.955 --> 03:57:24.122
现在，就像我之前提到的，每当我们从链链接节点请求数据时，我们必须支付一点Oracle gas，或者链接令牌，为了支付一些链接令牌，我们需要在API消费者契约中有链接令牌。

2257
03:57:24.122 --> 03:57:32.563
这就是所谓的获取链接令牌的基本请求和接收模型，我们回到我们的水龙头，这一次，我们将为我们的契约选择10个测试链接。

2258
03:57:32.563 --> 03:57:34.826
让我们来验证一下我们是否是人类。

2259
03:57:34.826 --> 03:57:36.320
点击发送请求。

2260
03:57:36.320 --> 03:57:38.695
这次，不是送我们Aetherium。

2261
03:57:38.695 --> 03:57:43.642
他们给我们发送了10个测试链接，这就是所谓的ERC 20令牌。

2262
03:57:43.642 --> 03:57:51.142
或者更准确地说，在ERC 677中，我们稍后会了解到这一点，我们可以在Metamask中看到资产。

2263
03:57:51.142 --> 03:57:56.618
通过导入令牌，为了获得令牌，我们将回到文档。

2264
03:57:56.618 --> 03:58:06.411
我们将查找这样的链接令牌合约，我们将访问我们刚刚获得令牌的网络，对我们来说就是COVID。

2265
03:58:06.411 --> 03:58:17.808
复制这个地址，到Metamask，点击导入令牌，粘贴那个地址，点击添加自定义令牌，然后导入令牌。

2266
03:58:17.808 --> 03:58:23.282
现在我们可以看到在账户1中，我们都有Aetherium和10。

2267
03:58:23.282 --> 03:58:39.971
链接，现在我们有了链接或Oracle gas，我们要把它发送给API消费者，我们要复制API消费者的地址，打开元掩码，点击发送，粘贴合同地址，把资产切换到Link。

2268
03:58:39.971 --> 03:58:42.143
现在我们只发送0。

2269
03:58:42.143 --> 03:58:42.688
2个链接。

2270
03:58:42.688 --> 03:58:44.597
下一个，下一个。

2271
03:58:44.597 --> 03:58:46.487
点击确认。

2272
03:58:46.487 --> 03:58:48.946
我们会等待这笔交易完成。

2273
03:58:48.946 --> 03:58:49.779
我选0。

2274
03:58:49.779 --> 03:59:00.209
2链接，因为在这个合同中，有一个费用字符，它告诉我们做一个API调用要花费多少。

2275
03:59:00.209 --> 03:59:01.742
这个实际上是0。

2276
03:59:01.742 --> 03:59:02.808
1个链接，我发送0个。

2277
03:59:02.808 --> 03:59:02.874
2.

2278
03:59:03.143 --> 03:59:04.749
为了以防万一，我们需要两次调用那个API。

2279
03:59:05.143 --> 03:59:08.583
这个函数会在后面的部分中解释。

2280
03:59:08.583 --> 03:59:30.455
但是现在,我只是想告诉你它是什么样子,做的是,一旦我们发送链接到我们的合同,我们可以先检查看看体积体积为零,我们希望能获得红杉中Aetherium资产的最后24小时,我们将调用此API拥有大量的原始数据,其中包括在特定的体积在过去24小时内,可这个数。

2281
03:59:30.455 --> 03:59:36.412
假设我们想从这个API将它放入我们的契约中，我们会对这个API进行HTTP get调用。

2282
03:59:36.412 --> 03:59:41.906
我们会在一个事务中发出请求。

2283
03:59:41.906 --> 03:59:50.143
在第二个事务中，chain link节点会返回值并将它存储在全局作用域中的volume变量中。

2284
03:59:50.143 --> 03:59:56.361
点击request volume data Metamask会弹出，点击确认。

2285
03:59:56.361 --> 03:59:58.820
你马上就会注意到音量没有更新。

2286
03:59:58.820 --> 04:00:05.732
这也是，因为我们需要等待两个事务，我们为请求发送一个事务。

2287
04:00:05.732 --> 04:00:10.108
然后在第二个事务中，链节点会做出响应。

2288
04:00:10.108 --> 04:00:16.894
在稍微延迟之后，链链接节点确实做出了响应，使API回调到我们的契约。

2289
04:00:16.894 --> 04:00:19.968
我们将在后面的部分中更深入地讨论这个过程。

2290
04:00:19.968 --> 04:00:32.059
我之所以想专门向您展示API调用，是因为我们将在后面的课程中向您展示如何使用链接VRF和链接保存器的真实示例。

2291
04:00:32.144 --> 04:00:34.111
我知道我们已经说了很多了。

2292
04:00:35.144 --> 04:00:35.596
审查。

2293
04:00:39.144 --> 04:00:42.890
带功能的区块链令牌需要将其标记为可支付。

2294
04:00:43.144 --> 04:00:47.547
你需要合同中的某些事情发生，你希望整个交易失败。

2295
04:00:47.547 --> 04:00:50.398
如果没有发生这种情况，可以使用require语句。

2296
04:00:50.398 --> 04:00:57.756
要获取事务的Aetherium或原生区块链令牌值，可以使用全局关键字message dot value。

2297
04:00:57.756 --> 04:01:06.080
链链接是一种在智能合约去中心化环境中获取外部数据并进行外部计算的技术。

2298
04:01:06.144 --> 04:01:20.572
引导数据源或价格源是从现实世界中读取价格信息或其他数据的方法，这些数据已经为我们聚合和去中心化了，引导VRF是从现实世界中获取可证明的随机数到我们的智能合约的方法。

2299
04:01:20.572 --> 04:01:24.971
Channeling keepers是一种去中心化事件驱动计算的方法。

2300
04:01:24.971 --> 04:01:39.465
我们可以设置一些触发器，比如如果这个触发器被击中，我们就可以定义这个触发器是什么，我们要做的是引导任何API都是引导节点的终极定制，允许我们连接到地球上的任何东西。

2301
04:01:39.465 --> 04:01:41.286
让这个产品做好准备。

2302
04:01:41.286 --> 04:01:47.684
我们必须做最多的工作，因为它还没有一个去中心化的Oracle网络，比如链接管理员和价格提要。

2303
04:01:47.684 --> 04:01:53.044
我们将在本课程中继续学习更多关于这些通灵服务的知识。

2304
04:01:53.044 --> 04:02:09.662
现在为了弄清楚我们的消息点值是否大于我们设置的最小美元值，我们实际上必须将消息点值从其第一层斜杠Aetherium转换为等值的美元。

2305
04:02:09.662 --> 04:02:19.334
那么我们要怎么做呢?首先，我们需要知道Aetherium的价格，或者幻影，或者雪崩，或者任何一层，一个我们正在使用的区块链。

2306
04:02:19.334 --> 04:02:23.380
我们来创建一个函数来得到价格和转化率。

2307
04:02:23.380 --> 04:02:35.430
我们会做一个函数，得到价格，这将是我们用来得到以美元表示的房间价格的函数，因此我们可以将message。value转换成美元。

2308
04:02:35.430 --> 04:02:42.975
然后我们还会做一个函数，Get转化率。

2309
04:02:42.975 --> 04:02:49.930
这些都是公共函数，我们可以调用它们，测试它们，做任何我们想做的事。

2310
04:02:49.930 --> 04:02:55.827
为了得到价格，我们需要使用其中一个链链数据源来获得定价信息。

2311
04:02:55.827 --> 04:03:02.145
我们可以看看这个合约看看使用这些价格通道是什么样子的。

2312
04:03:02.145 --> 04:03:16.176
当我们与这个价格信息交互时我们实际上是在读取其中一个合约，有一个合约叫做聚合器合约它有一个函数叫做最新一轮数据，它会返回一大堆数据。

2313
04:03:16.176 --> 04:03:18.318
也就是说，这个int价格。

2314
04:03:18.318 --> 04:03:21.732
这是我们感兴趣的价格。

2315
04:03:21.732 --> 04:03:32.789
让我们看一下get价格函数看看如何调用它因为这是我们在项目外与合约交互的实例，我们需要两个东西。

2316
04:03:32.789 --> 04:03:40.583
这两件事是什么，我们需要合同的ABI，还有合同的地址。

2317
04:03:40.583 --> 04:03:49.715
所以合同地址很简单，我们可以从合同地址中得到合同地址这部分的链链数据供给。

2318
04:03:49.715 --> 04:03:52.361
让我们向下滚动到B银行。

2319
04:03:52.361 --> 04:03:59.379
我们可以在瑞格比上找到那个美元地址然后我们就可以在瑞格比上创建这个合同。

2320
04:03:59.379 --> 04:04:01.597
我们要抓取这个地址，复制它。

2321
04:04:01.597 --> 04:04:05.016
我们要回到我们的代码。

2322
04:04:05.146 --> 04:04:07.196
我们把地址粘贴到这里。

2323
04:04:08.146 --> 04:04:08.525
地址。

2324
04:04:10.146 --> 04:04:11.671
我们不想互动。

2325
04:04:13.146 --> 04:04:18.014
我们之前做的是简单存储我们把整个合约导入到代码中。

2326
04:04:18.014 --> 04:04:19.724
这是我们可以做的。

2327
04:04:19.724 --> 04:04:21.513
但这其实是很多代码。

2328
04:04:21.513 --> 04:04:36.521
那么我们可以做些什么呢，记住，如果我们看的是混合，我们看的是我们之前编译的契约之一，ABI实际上是一种契约的不同功能和交互的列表。

2329
04:04:36.521 --> 04:04:55.583
ABI本身实际上不需要包含任何逻辑，它只需要包含，嘿，这里有你可以调用的不同函数，例如，在这个合约中，我们可以调用基金，我们可以获得转化率，我们可以获得价格，它们还没有实现，但最终会实现从技术上讲，有另一种不需要API就可以与合约交互的方法。

2330
04:04:55.583 --> 04:04:58.180
但是现在，我们要忽略它。

2331
04:04:58.180 --> 04:05:02.064
我们如何获得API，在实体中有一个概念叫做接口。

2332
04:05:02.064 --> 04:05:04.606
让我们看一个接口的例子。

2333
04:05:04.606 --> 04:05:05.812
如果我们去github。

2334
04:05:05.812 --> 04:05:16.851
com/smart，合约套件，链链，我们可以在链链库中看到很多不同的合约，我们可以去合约，src, V 0。

2335
04:05:16.851 --> 04:05:22.353
8, interfaces，我们会到aggregator v3 interface。soul。

2336
04:05:22.353 --> 04:05:30.423
如果我们看这里的实体性，我们可以看到一大堆函数声明，但没有一个逻辑在这里实现。

2337
04:05:30.423 --> 04:05:32.727
这就是所谓的接口。

2338
04:05:32.727 --> 04:05:41.385
如果我们编译它，我们实际上将得到契约的ABI，因为它定义了我们可以与契约交互的所有不同方式。

2339
04:05:41.385 --> 04:05:50.318
它并没有说，这些函数是干什么的，这很好，因为我们不需要知道这些函数是干什么的，它们会存储在契约中。

2340
04:05:50.318 --> 04:05:56.974
所以我们能做的是从代码中抓取这个接口，并将它粘贴到我们的混音中。

2341
04:05:56.974 --> 04:06:02.442
等等，如果你跟着我学，你不需要和我一起复制粘贴这个，因为我马上会给你展示一个更简单的方法。

2342
04:06:02.442 --> 04:06:04.851
所以现在，大家可以看了。

2343
04:06:04.851 --> 04:06:11.527
但是一旦我们有了这个接口聚合器v3接口，我们现在就可以使用它来进行API调用。

2344
04:06:11.527 --> 04:06:16.560
现在我们可以说，aggregator v3接口在这个地址。

2345
04:06:16.560 --> 04:06:24.387
这两者的结合，就得到了聚合器v3契约和这里的任何代码。

2346
04:06:24.387 --> 04:06:31.074
如果在这个契约地址是聚合器v3接口有效，我们可以做点版本。

2347
04:06:31.147 --> 04:06:32.459
让我们看看这个界面。

2348
04:06:34.147 --> 04:06:34.750
肯定是。

2349
04:06:39.147 --> 04:06:39.776
这份合同。

2350
04:06:42.147 --> 04:06:42.943
不同的部分。

2351
04:06:45.147 --> 04:06:47.687
版本来说明一下。

2352
04:06:47.687 --> 04:06:49.572
我要公开上市。

2353
04:06:50.147 --> 04:06:57.298
会是一个视图，它会返回un256，我们会把它分成两个步骤。

2354
04:06:57.298 --> 04:07:02.082
我们会说聚合旅游，v3接口，价格feed。

2355
04:07:02.082 --> 04:07:13.322
我们创建了一个类型为aggregator v3 interface = aggregator v3 interface的变量。

2356
04:07:13.322 --> 04:07:19.281
然后我们会返回那个版本的价格。

2357
04:07:19.281 --> 04:07:25.862
现在我将把这个契约部署到Rigby来展示这个git版本将返回什么。

2358
04:07:25.862 --> 04:07:34.574
但如果你不想的话，你可以不跟着做因为我们是在使用测试网，如果你愿意，你可以观看这一节，我们会进行更稀疏的测试。

2359
04:07:34.574 --> 04:07:50.535
因为我们将主要使用测试网，因为我们将使用一个实际的Oracle链链网络，一旦你转到硬帽和JavaScript，所有这些本地测试将会更容易更快，非常欢迎你继续，尝试和测试这些东西。

2360
04:07:50.535 --> 04:08:05.068
但是要知道，在测试网上做一些测试可能要花更长的时间，让我们删除最后一个资金合同，我们将部署这个，我们将滚动，我们将切换到注入网络3，我们将从COVID切换到溜冰场B。

2361
04:08:05.148 --> 04:08:24.574
我们要确保我们在溜冰场梁上的原因是这个地址是特定于溜冰场B的，我们要交互的合约可能不是在每条链上的这个地址，我们要确保我们在溜冰场B的链上，因为其他合约在不同的链上，这个版本函数显然不存在，这个函数可能出错。

2362
04:08:24.574 --> 04:08:30.513
我们继续，我们要找到我，我们要把它部署到溜冰场的V链上。

2363
04:08:30.513 --> 04:08:33.390
再说一次，你不需要跟着我，你可以看。

2364
04:08:33.390 --> 04:08:37.960
一旦契约被部署，我们现在有一个视图函数，叫做Get version。

2365
04:08:37.960 --> 04:08:44.492
我们可以看到它返回了一个变量来显示这是价格提要的第四个版本。

2366
04:08:44.492 --> 04:08:49.291
这是一种非常简单的方式来与现有的契约进行交互。

2367
04:08:49.291 --> 04:08:58.449
在我们的项目之外，我们使用这些接口之一，它可以编译到API，然后将该ABI与地址结合起来调用函数。

2368
04:08:58.449 --> 04:09:02.815
随着我们越来越多地使用这些接口，它们将变得越来越有意义。

2369
04:09:02.815 --> 04:09:08.610
所以如果你现在对它有点困惑，不要气馁，你做得越多，它就会变得越容易。

2370
04:09:08.610 --> 04:09:16.310
现在，我们知道了如何调用这些函数，我们可以开始使用这个接口。

2371
04:09:16.310 --> 04:09:22.990
然而，如你所知，如果我们有一大堆接口，我们将不得不把一大堆接口放在我们代码的顶部，这看起来很难看。

2372
04:09:22.990 --> 04:09:30.260
还有什么更好的方法吗?在我们使用导入之前，我们从简单存储中导入。

2373
04:09:30.260 --> 04:09:37.296
这就是这个的全部内容，我们能做的是，我们能从数组中导入同性恋Tore v3接口。

2374
04:09:37.296 --> 04:09:42.711
以上就是全部内容，我们可以继续使用这个聚合器v3接口创建一个新契约。

2375
04:09:42.711 --> 04:09:46.542
或者我们可以直接从GitHub导入这个。

2376
04:09:46.542 --> 04:10:19.550
如果我们回到这些chainlink数据源的文档使用数据源,我们向下滚动,我们看到,我们有这个导入语句,在链条削减进口合同削减证监会签证接口聚合器v3接口,这个,这个导入相同的路径设置链条的GitHub库代码,而不是直接将所有代码添加到我们的心情,我们能做的是我们可以从GitHub直接进口,也就是所谓的NPM包。

2377
04:10:19.550 --> 04:10:42.869
Remix很聪明，它指的是NPM包，我们以后会讲到NPM，它被称为包管理器，它可以保存不同合同的版本，让我们直接导入到代码库中，它直接从GitHub库创建。

2378
04:10:42.869 --> 04:10:47.450
所以remix从NPM下载这段代码，它是从这个GitHub创建的。

2379
04:10:47.450 --> 04:10:51.416
现在我们知道，如果我们导入，在，chain, link， /，收缩，src, v0。

2380
04:10:51.416 --> 04:11:03.379
8个接口聚合器v3接口。灵魂，这就像我们把整个合同贴在我们的融资合同的顶部一样，这让我们的代码看起来更好。

2381
04:11:03.379 --> 04:11:08.011
现在我们有了这个可以使用的聚合器v3接口。

2382
04:11:08.011 --> 04:11:09.118
好了,好了。

2383
04:11:09.118 --> 04:11:20.035
现在我们有了一个极简的界面，它会给我们API，我们如何得到这里的价格呢?文档有一个很好的例子，如果您想要使用它并尝试反向工程的话。

2384
04:11:20.035 --> 04:11:21.084
这就是我们要做的。

2385
04:11:21.150 --> 04:11:22.012
在我们的代码中。

2386
04:11:25.150 --> 04:11:43.007
接口对象叫做price feed一个aggregator v3变量叫做price feed，它将等于aggregator v3 Interface contract at address这个地址和我们在下面做的完全一样。

2387
04:11:43.007 --> 04:11:54.900
我们假设这个地址的合约将拥有这个聚合器v3接口的所有功能，这意味着它有这个小数函数，这个描述函数版本，获取舍入数据。

2388
04:11:54.900 --> 04:12:05.401
重要的是最新一轮数据，它在答案部分有最新的价格，我们现在能做的是调用价格提要上的最新一轮数据函数。

2389
04:12:05.401 --> 04:12:09.369
我们写price feed。最新一轮数据。

2390
04:12:09.369 --> 04:12:19.293
现在如果我们看一下接口，我们会看到最新一轮数据实际上并没有返回一个变量，它返回了一堆不同的变量。

2391
04:12:19.293 --> 04:12:21.528
这就是我们在合同中要返还的。

2392
04:12:21.528 --> 04:12:41.865
我们会放这些括号，我们会说，你去round ID，我们甚至可以直接看文档看它还返回了什么int price，你去了started out，你去了timestamp。

2393
04:12:41.865 --> 04:12:46.892
然后你去广告，回答了一遍。

2394
04:12:46.892 --> 04:12:49.892
这里有很多代码。

2395
04:12:49.892 --> 04:12:55.751
因为这个函数返回这么多不同的变量，我们必须设置一些东西来捕获它们。

2396
04:12:55.751 --> 04:12:57.667
然而，我们只关心价格。

2397
04:12:57.667 --> 04:13:01.717
我们不关心从timestamp开始的Id或在round中回答的Id。

2398
04:13:01.717 --> 04:13:09.832
所以我们能做的就是去掉它们，只留下逗号。

2399
04:13:10.151 --> 04:13:15.409
现在我们有int price = price提供最新一轮数据。

2400
04:13:15.409 --> 04:13:17.731
price是int 256的原因。

2401
04:13:17.731 --> 04:13:24.103
而不是un 256是因为一些价格或数据输入可能是负数，所以它是一个int 256。

2402
04:13:24.103 --> 04:13:25.245
所以它可以保持灵活性。

2403
04:13:25.245 --> 04:13:32.052
现在我们有了价格，这将是用美元表示的价格。

2404
04:13:32.151 --> 04:13:34.906
我们之前看过一个例子，大概是3000。

2405
04:13:35.152 --> 04:13:40.359
它返回了这个数字，因为由于多种原因，固体性对小数不起作用。

2406
04:13:40.359 --> 04:13:44.877
但我们只需要知道，这个价格提要有小数点后8位。

2407
04:13:44.877 --> 04:13:54.119
如果你想再次确认有多少小数，这个合约也有一个小数函数，它会告诉你价格提要中有多少小数。

2408
04:13:54.119 --> 04:13:58.167
我们知道，message。value有小数点后18位。

2409
04:13:58.167 --> 04:14:12.285
为什么小数点后有18位?因为一个以太等于1-234-567-8910 12345678这个有18个0，等于1的大数。

2410
04:14:12.285 --> 04:14:15.351
12345 678-910-1234 5678。

2411
04:14:15.351 --> 04:14:22.490
我们想让它们的小数点位置相同，对吧?因为现在这个是8，这个是18。

2412
04:14:22.490 --> 04:14:24.795
他们现在是不同的单位。

2413
04:14:24.795 --> 04:14:40.050
因此，为了使它们匹配，我们需要做的就是返回价格乘以1，也就是10，或者1的10次方，等于1123456789 10。

2414
04:14:40.152 --> 04:14:44.264
Message。value，将是一个unt256。

2415
04:14:45.152 --> 04:14:47.285
price是6点的一个区间。

2416
04:14:49.152 --> 04:14:50.764
取值从n到56。

2417
04:14:54.152 --> 04:14:57.824
我们要做的就是把你加到56里。

2418
04:14:58.152 --> 04:15:02.459
把这整个括在这两个括号里，就不能进行类型转换了。

2419
04:15:02.459 --> 04:15:08.893
但有一些值，比如56和56，可以很容易地在两者之间转换。

2420
04:15:08.893 --> 04:15:18.419
当然，因为我们没有用这个get价格函数修改任何状态，我们可以让这个视图返回到36。

2421
04:15:18.419 --> 04:15:21.946
如果我们保存并编译，我们就会得到那个选中标记。

2422
04:15:21.946 --> 04:15:23.088
数学可能有点棘手。

2423
04:15:23.153 --> 04:15:25.183
前几次是在固体中做的。

2424
04:15:26.153 --> 04:15:27.000
它就变得越容易。

2425
04:15:28.153 --> 04:15:33.943
引用一个这样的函数来算好，这是得到这个数最简单的方法。

2426
04:15:33.943 --> 04:15:34.330
太棒了。

2427
04:15:34.330 --> 04:15:41.034
现在我们有一个get价格函数，它将返回一个un 256，这将是Aetherium的价格。

2428
04:15:41.034 --> 04:15:46.856
就美元而言，我们所需要做的就是从Aetherium转换消息点值。

2429
04:15:46.856 --> 04:15:51.849
以美元为单位，我们来创建这个get转化率函数。

2430
04:15:51.849 --> 04:16:00.088
这个，我们将取一个输入参数un 256，它将是一个公共视图函数。

2431
04:16:00.088 --> 04:16:06.629
它将返回你到56，我们将传递给它一些eamount。

2432
04:16:06.629 --> 04:16:11.105
在另一边，我们将得到以美元表示的每一份的价值。

2433
04:16:11.153 --> 04:16:14.062
我们要做一个u。

2434
04:16:16.153 --> 04:16:16.867
得到价格。

2435
04:16:21.153 --> 04:16:23.572
这是我们为了得到Aetherium的价格而创造的。

2436
04:16:24.153 --> 04:16:37.069
u和256每笔钱的单位是美元等于每笔钱的价格乘以每笔钱，然后除以118。

2437
04:16:37.153 --> 04:16:56.090
当你在做固体的乘法和除法运算时，你总是想先做乘法和加法，然后再做除法，因为每个价格和每个数量都有18个额外的小数点后位如果我们让它们不动的话，他们将会有36个额外的零税附加在最后。

2438
04:16:56.154 --> 04:16:57.340
所以我们需要除以一个EA团队。

2439
04:16:58.154 --> 04:17:02.118
这门课的硬帽部分测试所有的数学将会容易得多。

2440
04:17:02.118 --> 04:17:06.291
如果你现在真的在为一些数学问题而挣扎，我不会让它拖累你。

2441
04:17:06.291 --> 04:17:11.841
因为一旦我们深入人心，实际测试就会变得比在测试网上工作容易得多。

2442
04:17:11.841 --> 04:17:15.392
这个以美元表示的金额就是我们要找的数字。

2443
04:17:15.392 --> 04:17:25.677
所以我们可以继续，以美元为单位返回每一笔钱，CSB在这里返回，现在我们有了一个很好的转化率函数可以快速地帮你完成数学运算。

2444
04:17:25.677 --> 04:17:27.965
假设每个人的价格是3000美元。

2445
04:17:27.965 --> 04:17:29.416
所以是3000。

2446
04:17:29.416 --> 04:17:36.444
但它会在末尾附加18个0，它匹配消息。value方式单位。

2447
04:17:36.444 --> 04:17:50.454
举个例子，我们寄一张或112345 678-910-1234 5678一张到这个合同中，每张应该等于3000美元。

2448
04:17:50.454 --> 04:18:00.868
为了得到价格，我们现在要算出每块价格，也就是3000乘以每块的数量，也就是这个，然后除以1的18次方。

2449
04:18:00.868 --> 04:18:19.967
方法out是3123 1-234-567-8910 12345678乘以1001 2345678 1-234-567-8910乘以112345678 1-234-567-8910。

2450
04:18:20.154 --> 04:18:27.799
现在除以112345678 1-234-567-8910，等于2。

2451
04:18:27.799 --> 04:18:27.879
9.

2452
04:18:27.879 --> 04:18:34.515
是II 21，计算器算错了，是2。

2453
04:18:34.515 --> 04:18:35.302
9，不是2。

2454
04:18:35.302 --> 04:18:40.086
99，即21表示这个数小数点后有21位。

2455
04:18:40.086 --> 04:18:41.879
所以是2。

2456
04:18:41.879 --> 04:18:53.238
1 234-567-8910 1-234-567-8910 1或1-234-567-8910 12345678 2900 I

2457
04:18:53.238 --> 04:18:54.321
99和一个9。

2458
04:18:54.321 --> 04:19:03.805
这就是为什么我们不用固体做小数运算的原因，我们的计算器发现这个巨大的数很难算出来。

2459
04:19:03.805 --> 04:19:05.800
所以结果是四舍五入到2。

2460
04:19:05.800 --> 04:19:05.945
999.

2461
04:19:05.945 --> 04:19:12.631
第九，当我们只研究固体整数时，我们不可能失去这种精确性。

2462
04:19:12.631 --> 04:19:22.655
在固体中，这将刚好返回3000美元，这是正确的一个Aetherium在3000美元的情况下每个Aetherium将是3000美元。

2463
04:19:22.655 --> 04:19:32.983
就像我说的，既然我们要建立这个契约，假设我们要在这个测试网上工作，我们不会在测试网上测试这个函数，因为我们要等待交易完成。

2464
04:19:32.983 --> 04:19:45.712
如果你想继续部署这个，自己摆弄它，非常欢迎现在我们有了一个叫Get转化率的函数我们可以在基金函数上使用它来确保我们在基金中发送了足够的message。value。

2465
04:19:45.712 --> 04:19:52.961
我们现在能做的是我们需要做的是得到message。value的转化率需要大于最小USD。

2466
04:19:52.961 --> 04:19:56.827
当然，现在我们的最低美元是50美元。

2467
04:19:56.827 --> 04:20:09.663
我们知道转化率将返回18个0来表示小数点后的数位，我们的最低美元金额需要升级为10到50乘以1e18。

2468
04:20:09.663 --> 04:20:17.006
或者再一次，1乘以10，举18，我将把它部署到一个测试网中演示一下。

2469
04:20:17.006 --> 04:20:20.206
但是，如果你不想等的话，你可以不这样做。

2470
04:20:20.206 --> 04:20:22.506
所以我要继续部署这个确认。

2471
04:20:22.506 --> 04:20:24.306
现在我们有了这个有趣的契约。

2472
04:20:24.306 --> 04:20:29.926
如果我不输入数值，点击有趣的按钮，气体估计误差就会失败。

2473
04:20:29.926 --> 04:20:36.852
这是一个笼统的错误，意思是，嘿，你可以发送这个事务，如果你想，它很可能无法工作。

2474
04:20:36.852 --> 04:20:45.346
remix知道这可能行不通的原因是因为它可以看到这个请求并模拟交易，然后说，嘿，你没有用这个汇足够的钱。

2475
04:20:45.346 --> 04:20:51.065
然而，即使我们汇了一些钱，比如5000，它仍然会给我们这个错误。

2476
04:20:51.065 --> 04:20:52.456
因为这还不够。

2477
04:20:52.456 --> 04:20:56.278
我们现在根据每个人的价格来计算。

2478
04:20:56.278 --> 04:21:02.105
我们可以去data。chain这个链接，看看价格大概是多少。

2479
04:21:02.156 --> 04:21:04.477
所以看起来Aetherium现在的价格是3000美元。

2480
04:21:04.477 --> 04:21:07.998
这因人而异取决于你什么时候做。

2481
04:21:07.998 --> 04:21:12.787
如果Aetherium的价格是3000美元，我们的最低价格至少是50美元。

2482
04:21:12.787 --> 04:21:15.798
我们可以用50除以30000。

2483
04:21:15.798 --> 04:21:19.976
每个大概就够了。

2484
04:21:19.976 --> 04:21:25.287
如果我们用Aetherium转换器，我们用0。

2485
04:21:25.287 --> 04:21:30.419
016，我们会知道它是多少，我们用0。

2486
04:21:30.419 --> 04:21:34.862
只是为了确保我们会超过规定的数量。

2487
04:21:34.862 --> 04:21:36.051
我们把它粘贴进来。

2488
04:21:36.156 --> 04:21:37.811
我们把这个改成。

2489
04:21:40.156 --> 04:21:47.632
而不是弹出那个错误，它会继续让我们执行有趣的函数我们可以确认它，它不会失败。

2490
04:21:47.632 --> 04:21:51.878
我现在将拒绝它，因为我真的不想等待交易完成。

2491
04:21:51.878 --> 04:21:52.433
但是很好。

2492
04:21:52.433 --> 04:21:59.557
我们已经确认，我们的get转化率是一个工作的预期，了不起，伟大的工作。

2493
04:22:00.157 --> 04:22:08.950
那么接下来我们想做的是什么呢?当人们向这个合同汇钱时，我们要跟踪所有给我们汇钱的人。

2494
04:22:08.950 --> 04:22:10.957
让我们创建一些数据结构。

2495
04:22:10.957 --> 04:22:11.720
为了跟踪。

2496
04:22:11.720 --> 04:22:15.072
让我们创建一个名为funders的地址数组。

2497
04:22:15.072 --> 04:22:19.023
我们会不断增加所有给我们汇款的资助者。

2498
04:22:19.023 --> 04:22:23.157
我们说一个地址数组，或者地址列表。

2499
04:22:23.157 --> 04:22:25.675
我们会让它成为公共基金。

2500
04:22:25.675 --> 04:22:32.490
只要有人给我们寄钱，而且确实通过了，我们就会增加这个有资金的服务器列表。

2501
04:22:32.490 --> 04:22:38.290
我们说funders。push。message。sender，就像message。value。

2502
04:22:38.290 --> 04:22:47.460
Message dot sender是一个始终可用的全局关键字Message dot value表示发送了多少Aetherium或多少原生区块链货币。

2503
04:22:47.460 --> 04:22:52.601
Message。sender是调用字体函数的人的地址。

2504
04:22:52.601 --> 04:22:58.760
如果我们在Rigby上message。sender将等于调用该函数的任何地址。

2505
04:22:58.760 --> 04:23:04.747
因为我们的地址在发送以太，我们要把我们的地址添加到这个资助者列表中。

2506
04:23:04.747 --> 04:23:21.549
这样我们就能追踪到所有为我们的合同捐款的了不起的捐赠者，然后也许我们甚至不用把你的地址和每个人实际捐了多少钱的250个6的地址做一个映射。

2507
04:23:21.549 --> 04:23:28.092
所以我们会给你写一个地址和256个公共地址。

2508
04:23:28.092 --> 04:23:37.634
当有人为我们的合同提供资金时，会说地址对资金额message。sender等于message。value。

2509
04:23:37.634 --> 04:23:41.272
现在我们有了一个功能，人们可以为我们的合同提供资金。

2510
04:23:41.272 --> 04:23:48.033
我们可以用美元来设定一个价值，我们跟踪不同的资助者，他们为我们的合同提供资金。

2511
04:23:48.033 --> 04:23:50.001
这太棒了。

2512
04:23:50.001 --> 04:23:56.258
我知道我们已经讲了很多非常复杂的数学和复杂的东西。

2513
04:23:56.258 --> 04:23:59.287
让我们快速回顾一下目前所学的内容。

2514
04:23:59.287 --> 04:24:11.033
每当我们使用契约时，我们总是需要API和地址，当编译接口时，它为我们提供了与项目外部契约交互的最简单的API。

2515
04:24:11.033 --> 04:24:17.996
当您将这些编译后的接口与地址组合在一起时，我们就可以在该契约上调用该接口上的函数。

2516
04:24:17.996 --> 04:24:18.705
链链接。

2517
04:24:18.705 --> 04:24:22.421
数据提要是一种去中心化的获取真实世界信息的方式。

2518
04:24:22.421 --> 04:24:29.919
在这种情况下，我们从分散的链条节点集合中得到以美元为单位的Aetherium的价格。

2519
04:24:29.919 --> 04:24:31.633
当工作与数学和固体。

2520
04:24:31.633 --> 04:24:32.634
小数不行。

2521
04:24:32.634 --> 04:24:36.048
所以我们在做任何形式的固体数学运算时都要记住这一点。

2522
04:24:36.048 --> 04:24:40.888
我们需要确保我们的单位总是正确的，这样我们的数学运算才有意义。

2523
04:24:40.888 --> 04:24:50.258
Message。value和Message。sender，我们的全局可用变量Message。sender表示消息或事务的发送方。

2524
04:24:50.258 --> 04:24:53.988
message。value表示与消息一起发送的方式的数量。

2525
04:24:53.988 --> 04:24:58.581
有一大堆不同的特殊变量和函数我们可以在任何时候访问。

2526
04:24:58.581 --> 04:25:01.458
这些在稳定性文档中都有。

2527
04:25:01.458 --> 04:25:08.076
好的，很好，我们有了一个很好的方法可以开始为我们的合同提供资金。

2528
04:25:08.076 --> 04:25:20.372
但我们的代码看起来有点乱，我们有几个不同的函数来获取价格和处理这些价格，有没有办法让这个数学运算更容易使用，这就是我们要引入库概念的地方。

2529
04:25:20.372 --> 04:25:23.784
所以什么是库，我绝对推荐通过例子来检查固体性。

2530
04:25:23.784 --> 04:25:28.938
Org，在你们学习这门课程的过程中，他们也有一些很棒的例子。

2531
04:25:28.938 --> 04:25:33.459
其中一个例子是关于库的，库类似于契约。

2532
04:25:33.459 --> 04:25:36.322
但你不能声明任何状态变量也不能发送以太。

2533
04:25:36.322 --> 04:25:41.434
我们还可以使用库向不同的值添加更多的功能。

2534
04:25:41.434 --> 04:25:49.539
这是什么意思呢?我们能做的是我们能让转化率是aun 256的函数。

2535
04:25:49.539 --> 04:25:57.635
我们可以用Messer。value。get convert John，转化率。

2536
04:25:57.635 --> 04:26:04.926
我们可以添加函数，就像36是我们实际创建的对象或结构或契约。

2537
04:26:04.926 --> 04:26:10.982
那么我们该怎么做呢?好，让我们在合同文件夹中创建一个新合同，并创建一个新文件。

2538
04:26:10.982 --> 04:26:13.716
我们叫它price converter。salt。

2539
04:26:13.716 --> 04:26:20.482
我们的价格转换大底将是一个库我们将附加到un256。

2540
04:26:20.482 --> 04:26:28.108
如何创建库，什么是库?库将非常非常类似于智能合约。

2541
04:26:28.108 --> 04:26:33.565
从spdx许可证标识符开始。

2542
04:26:33.565 --> 04:26:39.859
我的团队，我们会给它一个实用度，稳定性零点八。

2543
04:26:39.859 --> 04:26:39.959
0.

2544
04:26:40.159 --> 04:26:45.809
而不是输入contract作为合同的名称，而是用library作为库的名称。

2545
04:26:45.809 --> 04:26:47.970
我们称它为价格转换器。

2546
04:26:47.970 --> 04:26:55.105
库不能有任何状态变量，也不能发送以太，库中所有的函数都在那里。

2547
04:26:55.159 --> 04:26:55.534
内核。

2548
04:26:59.160 --> 04:27:08.910
我们可以获取价格，获取版本，获取转化率，复制它们，从Funmi . soul删除它们，并粘贴到我们的库中。

2549
04:27:08.910 --> 04:27:16.676
当然，因为我们在这里使用aggregator v3接口，我们也可以从Funmi复制导入。

2550
04:27:16.676 --> 04:27:25.107
因为我们不再使用三个接口和合约的集合，我们使用价格转换器，我们可以粘贴到价格转换器中。

2551
04:27:25.107 --> 04:27:29.597
现在，如果我们编译price convert at soul，我们会看到它实际上通过了。

2552
04:27:29.597 --> 04:27:32.910
现在库中的所有函数都需要是内部的。

2553
04:27:32.910 --> 04:27:50.805
我们会让这个库价格转换器有不同的功能，我们会调用活动六，例如，我们会做message。value。get转化率，我们会直接得到U和256的转化率就好像这一直是它的函数一样。

2554
04:27:50.805 --> 04:27:53.063
首先，让我们把它放在内部。

2555
04:27:53.063 --> 04:27:55.518
让我们把转化率设为内部。

2556
04:27:55.518 --> 04:27:57.540
我们会在内部做一个好的版本。

2557
04:27:57.540 --> 04:28:05.367
现在我们在Funmi中有了这个库价格转换器，我们现在可以导入这个价格转换器，并在256中将它附加给您。

2558
04:28:05.367 --> 04:28:11.010
导入斜杠价格转换器。soul。

2559
04:28:11.160 --> 04:28:18.626
在Funmi中，我们将使用价格转换器为UNT 256。

2560
04:28:19.160 --> 04:28:21.192
当然，如果我们编译Funmi。

2561
04:28:23.160 --> 04:28:26.110
问题在于，转化率没有定义。

2562
04:28:26.160 --> 04:28:33.560
在库中，传递给函数的第一个变量将是它自己调用的对象。

2563
04:28:33.560 --> 04:28:38.123
在Funmi。soul中，我们先注释掉这一行。

2564
04:28:38.123 --> 04:28:55.684
如果我们用message。value。get转化率，这其实和我们在价格转换库中获取转化率或者message。value是一样的，message。value将被作为输入参数传递来获取转化率，忘掉价格和版本吧我们并不关心数字。

2565
04:28:55.684 --> 04:28:58.446
我们先把它留空。

2566
04:28:58.446 --> 04:29:07.922
不需要获取转化率，我们现在可以用，message。value。get转化率。

2567
04:29:07.922 --> 04:29:17.111
编译它，你会看到这里我们没有传递一个变量，尽管我们的get转化率函数说，嘿，我需要一个变量。

2568
04:29:17.161 --> 04:29:23.643
同样，这样做的原因是，这个消息add value被认为是这些库函数的第一个形参。

2569
04:29:23.643 --> 04:29:24.928
这就是它的工作原理。

2570
04:29:24.928 --> 04:29:31.374
如果我们想在这里再加一个变量，比如56。

2571
04:29:31.374 --> 04:29:35.974
现在我们要传入另一个值123。

2572
04:29:35.974 --> 04:29:38.574
这个123会被赋值给这个别的东西。

2573
04:29:38.574 --> 04:29:40.964
但我们现在要把它删掉。

2574
04:29:40.964 --> 04:29:41.947
好了,好了。

2575
04:29:41.947 --> 04:29:52.415
在这样做的过程中，我们通过将大量的数学计算和价格转换内容转移到我们的价格转换库。Sol中，将Funmi合同最小化。

2576
04:29:52.415 --> 04:30:01.737
其中一个最常用的，使用时间最长的库叫做Safe math。Sol。

2577
04:30:01.737 --> 04:30:08.364
你可能会在很多不同的地方看到它，我们将在这里快速地切线教你安全数学。

2578
04:30:08.364 --> 04:30:10.550
让我们关闭Funmi关闭价格转换器。

2579
04:30:10.550 --> 04:30:15.403
让我们创建一个名为Safe math tester的新文件。

2580
04:30:15.403 --> 04:30:16.541
这是所有。

2581
04:30:16.541 --> 04:30:19.212
让我们从一些基本的东西开始。

2582
04:30:19.212 --> 04:30:22.263
在0版本之前，安全数学到处都是。

2583
04:30:22.263 --> 04:30:23.144
8的固体度。

2584
04:30:23.144 --> 04:30:25.679
现在几乎没有合同了。

2585
04:30:25.679 --> 04:30:31.781
发生了什么，为什么安全数学不再被广泛使用?好吧，让我们创建一个样本合同。

2586
04:30:31.781 --> 04:30:35.866
如果你不想和我一起编写代码，你可以不跟随这部分内容。

2587
04:30:35.866 --> 04:30:38.443
但如果你想，你完全可以。

2588
04:30:38.443 --> 04:30:45.749
这将是一个我们将部署在JavaScript虚拟机上的契约，我们可以使用0版本之前的任何版本。

2589
04:30:45.749 --> 04:30:46.574
8的固体度。

2590
04:30:46.574 --> 04:30:50.923
例如，我们用pragma, carrot, 0, point 6。

2591
04:30:50.923 --> 04:30:51.018
0.

2592
04:30:51.018 --> 04:30:56.066
我们会创建合同安全数学测试，点索尔。

2593
04:30:56.066 --> 04:31:02.230
现在，如果我创建一个yint 8，我将它设为公共大数。

2594
04:31:02.230 --> 04:31:06.697
我把它设为255哦，安全数学测试。

2595
04:31:06.697 --> 04:31:12.323
让我们继续，编译安全的数学测试0点6。

2596
04:31:12.323 --> 04:31:18.846
7pragma，结实度，Yewande 8的最大尺寸是255。

2597
04:31:18.846 --> 04:31:23.276
这将是我们在新的int 8中所能容纳的最大的数。

2598
04:31:23.276 --> 04:31:32.328
如果我要把它部署到一个JavaScript VM或者一个测试网络，安全的数学测试器，让我们继续。

2599
04:31:32.328 --> 04:31:35.694
如果是大数字，就会得到255。

2600
04:31:35.694 --> 04:31:47.114
如果我创建一个叫ADD的函数会发生什么?让大数等于大数加1 ?让我们保存它。

2601
04:31:47.114 --> 04:31:49.399
删除旧契约并进行部署。

2602
04:31:49.399 --> 04:31:56.069
好了，大数字255加1 2会怎样?很大的数字。

2603
04:31:56.162 --> 04:32:01.404
当255是a的最大值时，UNT 8可以是?点击添加。

2604
04:32:01.404 --> 04:32:04.226
现在我们来看看大的数是多少。

2605
04:32:04.226 --> 04:32:06.637
大数字被重置为零。

2606
04:32:06.637 --> 04:32:09.687
这是怎么回事?在版本0之前。

2607
04:32:09.687 --> 04:32:23.589
无符号整数和整数都是基于未检查的概念运行的，这意味着如果你超过了一个数字的上限，它就会绕一圈，从它可能的最低数字开始返回。

2608
04:32:23.589 --> 04:32:33.086
如果我再多次调用加法，然后点击一个大数字，假设我再多次点击加法按钮把它变回2和55。

2609
04:32:33.163 --> 04:32:35.210
然后它会继续绕到0。

2610
04:32:36.163 --> 04:32:52.956
当时流行的库是这个安全的数学库，它会检查你是否超过UN 256或直观的6，基本上，它是一种方式，告诉你，嘿，你已经达到了这个数字的最大值，现在你的交易将会失败。

2611
04:32:52.956 --> 04:32:54.543
如果我们把它换成0。

2612
04:32:54.543 --> 04:33:00.244
8、稳固度，删除旧合同，去把这个换成0。

2613
04:33:00.244 --> 04:33:00.325
8.

2614
04:33:00.325 --> 04:33:02.784
我们将继续编译它。

2615
04:33:02.784 --> 04:33:07.020
现在我们把它部署到JavaScript VM。

2616
04:33:07.163 --> 04:33:09.679
如果我击中大数字，我们就能降到55以下。

2617
04:33:11.163 --> 04:33:12.256
其实失败。

2618
04:33:12.256 --> 04:33:14.521
我们还是会达到55岁以下。

2619
04:33:14.521 --> 04:33:15.536
在0版本中。

2620
04:33:16.163 --> 04:33:29.195
Solidity，他们加了这一点，它会自动检查你是否要对变量做所谓的溢出或下溢，我们实际上可以通过使用unchecked关键字恢复到未检查版本。

2621
04:33:29.195 --> 04:33:39.092
如果我们把这个大数=大数+ 1括在这个未选中的括号里，我们删除旧契约will compile will redeploy。

2622
04:33:39.092 --> 04:33:40.877
我们有很大的数字是55。

2623
04:33:40.877 --> 04:33:46.247
现在我们点击加法，我们再次点击大数，它又回到了零。

2624
04:33:46.247 --> 04:33:49.964
这是关于安全数学的一些内容，检查和未检查。

2625
04:33:49.964 --> 04:33:50.950
所以在版本0中。

2626
04:33:50.950 --> 04:33:59.452
76，在你们前面看到的这段代码下面，和0的代码是完全一样的。

2627
04:33:59.452 --> 04:33:59.553
8.

2628
04:33:59.553 --> 04:34:01.458
以上使用这个未选中的关键字。

2629
04:34:01.458 --> 04:34:14.503
现在你可能会想，在新版本的坚固性中，为什么我要使用这个unchecked关键字?稍后您将发现，这个未选中的关键字使您的代码更省油。

2630
04:34:14.503 --> 04:34:22.594
因此，如果你绝对肯定你的数学永远不会达到一个数字的上限或下限，那么使用unchecked关键字可能是有意义的。

2631
04:34:22.594 --> 04:34:31.079
让我们回到我们的Funmi合同，在那里我们现在使用我们刚刚创建的价格转换库。

2632
04:34:31.164 --> 04:34:31.830
好了,好了。

2633
04:34:34.164 --> 04:34:35.943
这里是真正的资助。

2634
04:34:37.164 --> 04:34:45.113
在我们的库价格转换器中完成转化率的数学，我们将在Funmi的顶部导入它。

2635
04:34:45.164 --> 04:34:45.422
酷。

2636
04:34:45.422 --> 04:34:48.196
现在，我们有了有趣的方法。

2637
04:34:48.196 --> 04:34:48.712
太棒了。

2638
04:34:49.164 --> 04:34:58.902
所以我们可以允许任何人继续为这个合同提供资金，并将Aetherium或任何本地区块链货币发送到这个合同。

2639
04:34:58.902 --> 04:35:08.099
现在我们要做什么?好吧，一旦所有的资助者都进行了投资，我们将希望这个项目能够从合同中提取资金。

2640
04:35:08.164 --> 04:35:13.836
所以他们可以继续用这些资金为这个项目买东西。

2641
04:35:13.836 --> 04:35:17.410
我们来创建一个取款函数。

2642
04:35:17.410 --> 04:35:19.771
我们会创建一个取款函数。

2643
04:35:19.771 --> 04:35:21.283
我们会把这个公之于众。

2644
04:35:21.283 --> 04:35:31.083
因为我们将从这个合同中提取所有的资金，我们可能还需要重置我们的资助者数组，并将我们的地址设置为被资助金额。

2645
04:35:31.165 --> 04:35:36.498
既然我们要把所有的资金都取出来，那笔钱应该归零了。

2646
04:35:36.498 --> 04:35:49.418
我们继续遍历供资者数组并更新映射对象这样每个供资者现在都是0，因为马上，我们将从他们那里取出所有的钱。

2647
04:35:49.418 --> 04:35:53.040
为了做到这一点，我们将使用一个叫做for循环的东西。

2648
04:35:53.040 --> 04:36:03.704
什么是for循环?for循环是一种遍历某种类型的索引对象的方法，或遍历某些数字范围的方法，或只是重复执行某个任务一定次数的方法。

2649
04:36:03.704 --> 04:36:08.378
例如，我们有一个数组或列表。

2650
04:36:08.378 --> 04:36:11.935
在这个名单上，我们有1234个。

2651
04:36:12.165 --> 04:36:18.230
如果我们想要得到这个数组中的所有元素，或者这个列表中的所有元素，1234。

2652
04:36:18.230 --> 04:36:29.213
我们如何得到列表中的所有元素?我们会用for循环循环遍历每一个对象。

2653
04:36:29.213 --> 04:36:38.613
所以在0处，下标为1第一个下标为2，第二个下标为3，最后一个下标为4。

2654
04:36:38.613 --> 04:36:44.358
所以我们将遍历索引0到3来得到所有这些元素。

2655
04:36:44.358 --> 04:36:58.116
或者也许另一个例子是如果这是A B C D, A在0处，下标B在第一个下标看到第二个Indy在第三个我们将循环0到3。

2656
04:36:58.116 --> 04:37:02.116
要得到这些元素中的每一个，我们要做完全相同的事情。

2657
04:37:02.166 --> 04:37:03.959
但随着资助者的排列。

2658
04:37:06.166 --> 04:37:13.116
我们首先从for关键字开始，for关键字说，好，我们要开始一个循环。

2659
04:37:13.116 --> 04:37:17.759
在这些括号里面，我们定义了如何循环它。

2660
04:37:17.759 --> 04:37:22.859
还有反斜杠，反斜杠有点像注释的括号。

2661
04:37:22.859 --> 04:37:26.534
在这两者之间的任何内容都将是注释。

2662
04:37:26.534 --> 04:37:35.666
在for循环中，首先，我们给它一个起始索引，然后我们给它一个结束索引，然后我们给它一个步长。

2663
04:37:35.666 --> 04:37:40.860
例如，我们想从0开始，到10。

2664
04:37:40.860 --> 04:37:43.492
每次都要增加1。

2665
04:37:43.492 --> 04:37:46.022
我们拨打01 234-567-8910。

2666
04:37:46.022 --> 04:37:49.461
或者从0开始，到10结束。

2667
04:37:49.461 --> 04:37:51.553
每次增加2。

2668
04:37:51.553 --> 04:37:53.488
所以是02468 10。

2669
04:37:53.488 --> 04:38:03.308
或者我们想从0到5，我们想从2到5，每一步是1，我们会走2345，等等。

2670
04:38:03.308 --> 04:38:08.690
这就是这个4位的内容。

2671
04:38:08.690 --> 04:38:13.558
对于我们的起始下标，我把它放在上面，这样你们就可以引用它了。

2672
04:38:13.558 --> 04:38:18.869
我们的起始指数是你的v6变量，我们称之为投资人指数。

2673
04:38:18.869 --> 04:38:23.481
我们从雷指数等于零开始。

2674
04:38:23.481 --> 04:38:25.808
我们从0开始。

2675
04:38:25.808 --> 04:38:33.119
我们会以出资人数组的长度结束，因为我们想循环所有的出资人。

2676
04:38:33.166 --> 04:38:41.500
我们会说，funder index需要小于funders。length。

2677
04:38:41.500 --> 04:38:49.658
因此，我们的最终指数将是，只要出资人指数不再小于出资人。长度。

2678
04:38:49.658 --> 04:39:03.928
最后，我们会说funder index = funder index + 1，这意味着每次循环里面的代码结束，我们会把funder index加1。

2679
04:39:03.928 --> 04:39:08.522
这就是我们如何从0到1到2到3到4到5，等等。

2680
04:39:08.522 --> 04:39:21.691
另一种输入funder index = funder index + 1的方法是你可以直接输入funder index + +，这个+ +语法的意思是funder index =本身+ 1。

2681
04:39:21.691 --> 04:39:31.747
让我们开始遍历我们的funders数组来访问0 with元素或者第一个元素，我们会说，funders of funder index。

2682
04:39:31.747 --> 04:39:37.532
我们说我们想用我们的funders对象的元素访问0。

2683
04:39:37.532 --> 04:39:48.517
这将返回一个地址给我们使用，我们会继续说，address under = funders at funder index。

2684
04:39:48.517 --> 04:39:50.973
现在我们有了这个资助者地址。

2685
04:39:50.973 --> 04:39:55.019
我们想用这个来重置映射。

2686
04:39:55.019 --> 04:40:07.014
我们会说，address to amount被资助的金额在funder键处现在等于0。

2687
04:40:07.167 --> 04:40:11.844
因为记住，在基金中我们会更新金额。

2688
04:40:13.167 --> 04:40:20.135
为合同提供资金，当我们从合同中提取资金时，我们会将其重置为零。

2689
04:40:20.135 --> 04:40:23.752
现在我们来看看这个投资人指数从0开始。

2690
04:40:23.752 --> 04:40:45.929
我们会得到funder的0，我们会在0和index处找到那个funder我们会把那个funder的男性资助地址重置为0，然后这个for循环会更新1，它会从0移动到1，它会检查funder index是否小于长度，假设funder里面有10个人。

2691
04:40:45.929 --> 04:40:48.930
如果资助者有10个人，它仍然会更少。

2692
04:40:48.930 --> 04:41:07.105
现在资助者链接将是一个地址资助者将等于资助者1，而不是0，我们会获取那个地址，我们会重置那个关于被资助的地址为0，然后我们会继续到2到3到4一直到我们的资助者数组的长度。

2693
04:41:07.168 --> 04:41:09.599
这就是我们在对象中循环的方式。

2694
04:41:10.168 --> 04:41:19.739
中间这个是结束索引不完全正确，因为我们实际上是在检查布尔值，看它是否仍然正确，但希望你能理解。

2695
04:41:19.739 --> 04:41:22.422
所以我们重置了映射的平衡。

2696
04:41:22.422 --> 04:41:30.043
然而，我们仍然没有做两件事，我们仍然需要重置数组，使资助者为空数组。

2697
04:41:30.043 --> 04:41:34.909
然后我们还需要取出资金。

2698
04:41:34.909 --> 04:41:43.868
从我们资助这个开始，我们在调用这个基金函数的同时发送了message。value。

2699
04:41:43.868 --> 04:41:46.840
然而，我们实际上并没有取出资金。

2700
04:41:46.840 --> 04:41:54.075
要重置数组，我们可以遍历它并从这个地址数组中删除对象。

2701
04:41:54.168 --> 04:41:58.513
或者我们可以完全刷新这个变量。

2702
04:41:58.513 --> 04:42:42.187
而不是数组遍历和删除对象,我们只需要说资助者等于一系列的新地址,我们将完全重置数组现在说这个字体变量等于一个品牌新地址与零对象数组开始,如果我们把一个放在这里,这将会有一个元素数组中开始,两个两个,三个三个,等,我们将它作为一个完全空白的新数组。

2703
04:42:42.187 --> 04:42:45.393
很好，我们已经重置了数组。

2704
04:42:45.393 --> 04:43:11.316
但是我们现在如何从合同中提取资金呢?我们如何将资金寄回给调用它的人来发送以太币或原生区块链货币，实际上有三种不同的方式来做这件事，我们将会研究这三种方式，并说明这三种方式的区别，这三种不同的方式分别是转移，发送和调用。

2705
04:43:11.316 --> 04:43:14.512
让我们从转移开始。

2706
04:43:14.512 --> 04:43:19.902
因为转移是最简单的，而且在表面上对我们来说最有意义。

2707
04:43:19.902 --> 04:43:30.219
如果我们想把钱转移到调用取款函数的人那里，我们会说message。sender。transfer。

2708
04:43:30.219 --> 04:43:48.202
然后我们可以通过address this得到合约的余额，这个关键字指的是整个合约。balance，我们可以得到这个地址的原生区块链货币或Aetherium货币余额，像这样。

2709
04:43:48.202 --> 04:44:01.915
我们只需要做一件事就是我们需要类型转换我们需要将message。sender从地址类型转换为可支付地址类型。

2710
04:44:01.915 --> 04:44:07.878
message。sender的类型是address。

2711
04:44:08.170 --> 04:44:21.780
对于可支付的消息，发送者的类型是可支付地址，为了像Aetherium一样发送本机区块链令牌，您只能使用可支付地址。

2712
04:44:21.780 --> 04:44:25.545
要做到这一点，我们只需要把它包装在这个可支付类型的脚轮。

2713
04:44:25.545 --> 04:44:41.721
这是我们发送Aetherium的第一种方式，或者说从不同的合同中发送代币，我们把我们想要发送的地址包装起来，在这个payable关键字中，我们做点转移，然后我们说我们想要转移多少钱。

2714
04:44:41.721 --> 04:44:44.479
但是在转帐方面有一些问题。

2715
04:44:44.479 --> 04:44:57.790
这是一个固体性的例子，用来发送以太，这也是一个很好的参考资源，如果你迷路了，我们刚刚看到的方法就是传输方法。

2716
04:44:57.790 --> 04:45:08.301
我们在之前的课程中看到，如果我把Aetherium，从一个地址发送到另一个地址，它大约花费2100汽油或2100汽油。

2717
04:45:08.301 --> 04:45:13.220
气体，我们的传递函数上限是2300气体。

2718
04:45:13.220 --> 04:45:16.907
如果使用了更多的气体，则抛出一个错误。

2719
04:45:16.907 --> 04:45:22.203
我们使用的下一个将被发送，它的上限也是2300气体。

2720
04:45:22.203 --> 04:45:25.334
如果失败，它会返回一个布尔值。

2721
04:45:25.334 --> 04:45:37.154
对于transfer，如果这一行失败了，它会用send传递并恢复事务，它不会传递，它会返回一个布尔值判断它是否成功。

2722
04:45:37.154 --> 04:45:45.980
所以使用send将做应付的消息发送者发送地址这个余额。

2723
04:45:45.980 --> 04:45:50.724
但我们不想在这里结束通话。

2724
04:45:50.724 --> 04:45:57.409
如果这失败了，合同将不会恢复交易，而我们只想将钱发送出去。

2725
04:45:57.409 --> 04:46:04.567
我们想要布尔发送成功等于这整部分。

2726
04:46:04.567 --> 04:46:08.271
然后我们想要成功。

2727
04:46:08.271 --> 04:46:15.049
如果这个send失败，就会抛出一个错误，说sin failed。

2728
04:46:15.171 --> 04:46:21.252
这样，如果失败了，我们仍然会通过在这里添加require语句来恢复。

2729
04:46:21.252 --> 04:46:29.858
Transfer会在传输失败时自动恢复，send只会在这里添加require语句时恢复事务。

2730
04:46:29.858 --> 04:46:30.420
太好了。

2731
04:46:30.420 --> 04:46:37.323
我们用这个调用命令发送以太币或本地货币钱包的第三种方式是什么?

2732
04:46:37.323 --> 04:46:48.094
call将是我们在稳定性代码中使用的第一个较低级别的命令，因为这个调用函数实际上非常强大。

2733
04:46:48.171 --> 04:46:59.155
我们可以使用它来调用所有Aetherium中的任何函数，甚至不需要有API，我们将在很久以后学习使用这个调用的高级方法。

2734
04:46:59.155 --> 04:47:14.059
现在，我们只学习如何使用它来发送Aetherium，或者你的原生区块链货币调用看起来与send非常相似，我们将做payable, message。sender。call。

2735
04:47:14.172 --> 04:47:23.680
这是我们放置函数信息或关于函数的信息的地方，我们想调用其他契约，实际上我们不想调用函数。

2736
04:47:23.680 --> 04:47:32.047
我们让它空着，我们可以用这两个引号来表示我们让它空着，我们想把它当作一个事务来使用。

2737
04:47:32.047 --> 04:47:43.417
正如我们在部署中看到的，总是有这个message。value bid，我们将使用这个调用函数，就像它是一个常规事务一样，我们可以添加像message。value这样的东西。

2738
04:47:43.417 --> 04:47:48.614
在这里，我们要加上这些弯弯曲曲的括号。

2739
04:47:48.614 --> 04:48:00.856
我们会说，value address this。balance，这个调用函数返回两个变量。

2740
04:48:00.856 --> 04:48:14.137
当一个函数返回两个变量时，我们可以把它们放在左边的括号里，这两个变量，它返回的是一个布尔值，我们会调用调用success。

2741
04:48:14.137 --> 04:48:22.172
还有一个bytes对象叫做data returned，因为call允许我们调用不同的函数。

2742
04:48:22.172 --> 04:48:30.105
如果那个函数返回一些数据或返回值，我们会把它保存在数据返回变量中。

2743
04:48:30.105 --> 04:48:36.522
它还返回调用成功，如果函数被成功调用，则为真。

2744
04:48:36.522 --> 04:48:38.890
如果不是，这将是错误的。

2745
04:48:38.890 --> 04:48:45.071
由于字节对象是数组，数据返回需要在内存中。

2746
04:48:45.071 --> 04:48:51.141
对于这里的代码，我们实际上没有调用函数，所以我们不关心返回的数据。

2747
04:48:51.141 --> 04:49:02.664
和价格合约类似，我们可以删掉它，留下逗号来表示实数，我们知道这个函数返回两个变量，但我们只关心一个。

2748
04:49:02.664 --> 04:49:13.011
然后类似于上面的中心部分，我们将做require cost access call failed，这意味着我们要求cost access为true。

2749
04:49:13.011 --> 04:49:16.696
否则，我们将返回一个错误，表示调用失败。

2750
04:49:16.696 --> 04:49:21.156
现在学习这三者之间的区别对你们来说有点复杂。

2751
04:49:21.156 --> 04:49:22.697
不要让这拖累你的脚步。

2752
04:49:22.697 --> 04:49:28.006
在您进一步了解了一些较低级别的函数是如何工作的之后，请继续讨论这个问题。

2753
04:49:28.006 --> 04:49:49.792
再举个例子，讲一下气体是如何工作的，它很好地说明了三者之间的区别，我们的传输最大值是2300气体如果失败就会抛出错误，发送最大值是2300气体返回一个布尔值，如果失败，调用所有气体，所以没有封顶气体。

2754
04:49:49.792 --> 04:50:16.449
类似于send返回一个布尔值，如果它成功，或失败，就目前记录而言，使用call是实际发送和接收Aetherium或你的区块链原生代币的推荐方式，如果这部分对你来说有点困惑，现在，只要看看这个，看啊，这就是我们如何发送和转移Aetherium或原生区块链货币代币。

2755
04:50:16.449 --> 04:50:25.951
我会把视频的这部分删掉，但我会把这些注释保留在与这门课相关的代码库中。

2756
04:50:25.951 --> 04:50:27.951
好的，很好。

2757
04:50:28.174 --> 04:50:33.951
如果我们点击编译一个有趣的肉大底，我们确实看到它是通过合规。

2758
04:50:33.951 --> 04:50:41.370
然而，这里有一个小问题，现在，任何人都可以退出这个合同。

2759
04:50:41.370 --> 04:50:44.206
所以任何人都可以投资，这是我们想要的。

2760
04:50:44.206 --> 04:50:46.766
但我们不希望任何人能够撤资。

2761
04:50:46.766 --> 04:50:52.485
我们只希望筹集资金的人能够真正提取资金。

2762
04:50:52.485 --> 04:51:02.404
我们如何设置取款函数只由合约的所有者调用呢?为了做到这一点，我们要建立一些新的函数。

2763
04:51:02.404 --> 04:51:11.190
当我们部署这个合同时，我们希望自动设置它以便任何部署这个合同的人都将是这个合同的所有者。

2764
04:51:11.190 --> 04:51:17.518
然后我们可以用一些参数来设置它这样只有契约的所有者才能调用取款函数。

2765
04:51:17.518 --> 04:51:24.007
我们怎么做呢?也许我们可以创建一个函数叫做，马上给我打电话。

2766
04:51:24.007 --> 04:51:31.974
在我们部署这个契约之后，我们调用这个call me right away函数，它会将我们设置为所有者。

2767
04:51:31.974 --> 04:51:34.774
这将需要两个事务。

2768
04:51:34.774 --> 04:51:37.554
如果我们要这么做，那就太烦人了。

2769
04:51:37.554 --> 04:51:42.622
相反，固体有一个构造函数。

2770
04:51:42.622 --> 04:51:50.090
如果您熟悉其他编程语言，构造函数与其他编程语言完全相同。

2771
04:51:50.174 --> 04:51:56.224
构造函数将是在部署契约时立即调用的函数。

2772
04:51:56.224 --> 04:52:10.550
所以如果我部署Funmi。Sol，我说，最低美元等于最低美元不再是50乘以1 e的18次方，它会立即更新为2。

2773
04:52:10.550 --> 04:52:26.060
因为构造函数是在同一个事务中立即被调用的函数，我们创建了这个契约，这个构造函数将对我们非常有帮助，因为它允许我们按我们想要的方式设置契约。

2774
04:52:26.060 --> 04:52:37.519
例如，如果我们希望取款函数只能由契约的所有者调用，我们可以让构造函数设置契约的所有者是谁。

2775
04:52:37.519 --> 04:52:42.381
我们创建一个全局变量，地址，公共所有者。

2776
04:52:42.381 --> 04:52:49.367
然后在构造函数中，我们会说owner将等于message。sender。

2777
04:52:49.367 --> 04:52:56.717
构造函数的发送方的消息将是部署契约的任何人。

2778
04:52:56.717 --> 04:53:00.667
所有者就是部署合同的人。

2779
04:53:00.667 --> 04:53:12.255
别担心，我们很快就会演示给你们看以太扫描的所有情况，现在演示可能要花点时间，因为我们用的是测试网。

2780
04:53:12.255 --> 04:53:20.126
如果你现在就想测试它，那就去做吧，但是要知道，这将会花费你更多的时间。

2781
04:53:20.126 --> 04:53:30.094
现在我们已经设置了所有者，我们可以修改提款函数，以便只有所有者才能真正调用这个提款函数。

2782
04:53:30.094 --> 04:53:49.241
在取款函数的顶部，也许我们想添加一个section，也许我们想说，require message。sender = the owner，一个关于双等号和等号的注意事项，你可以把这个单等号看作一个集合参数。

2783
04:53:49.241 --> 04:53:59.890
当我说owner，现在设置为message。sender时，double =是检查这两个变量是否相等的方法。

2784
04:53:59.890 --> 04:54:04.062
我们说的是ismessage。sender，和owner一样。

2785
04:54:04.062 --> 04:54:06.961
这就是检验等价性。

2786
04:54:06.961 --> 04:54:10.667
这是设置检查，以查看等价设置。

2787
04:54:10.667 --> 04:54:19.733
我们会说，require message。sender = = owner，否则，我们会抛出一个错误，说，sender不是owner。

2788
04:54:19.733 --> 04:54:20.388
完美的。

2789
04:54:20.388 --> 04:54:28.569
现在我们有了一种快速的方法来确保撤回函数只由该契约的所有者调用。

2790
04:54:28.569 --> 04:54:43.633
假设契约中有很多函数需要成为所有者，也许契约中有很多函数需要很多不同的要求，我们不想复制粘贴这一行到每一个函数。

2791
04:54:43.633 --> 04:54:47.724
那么我们能做什么呢?这时就要用到修饰语了。

2792
04:54:47.724 --> 04:54:51.242
现在，我们要删除这一行。

2793
04:54:51.242 --> 04:55:02.159
下面，我们将创建一个叫做修饰符的东西，我们的修饰符将是一个关键字我们可以在函数声明中添加它。

2794
04:55:02.159 --> 04:55:08.509
要使用该功能修改函数，我们将创建一个修饰符并将其命名为惟一的owner。

2795
04:55:08.509 --> 04:55:13.864
我们要粘贴我们在取款中做的那一行。

2796
04:55:13.864 --> 04:55:24.455
在这下面，我们会加一个下划线，我现在能做的是取这个唯一的所有者修饰符，把它插入到取款函数的函数声明中。

2797
04:55:24.455 --> 04:55:46.211
这个只有owner的修饰符在函数声明中发生了什么呢，我们说，对于这个取款函数，在你读里面的所有代码之前，先看看唯一的owner修饰符，先做里面的内容，然后再做下划线中的内容，这个下划线表示完成剩下的代码。

2798
04:55:46.211 --> 04:55:55.052
现在，当我们调用withdraw函数时，我们先执行这个require语句，然后调用剩下的代码。

2799
04:55:55.052 --> 04:56:03.881
如果这个require语句，我们在下划线下面，这将告诉我们的函数继续，并先执行所有这些代码。

2800
04:56:03.881 --> 04:56:05.520
然后运行require。

2801
04:56:05.520 --> 04:56:13.015
因为我们有这个only关键字，我们说，很好，我们有一个函数，它收回它的公共，哦，only气味修饰符。

2802
04:56:13.015 --> 04:56:14.885
让我们看看这是如何工作的。

2803
04:56:14.885 --> 04:56:18.966
它告诉我们如何先完成原始函数的所有代码。

2804
04:56:18.966 --> 04:56:20.499
我们来做一下。

2805
04:56:20.499 --> 04:56:21.566
好了，现在我们完成了。

2806
04:56:21.566 --> 04:56:27.596
现在，我们该怎么做?好，现在我们要运行require，我们要先把require放在这里。

2807
04:56:27.596 --> 04:56:34.738
这就是修饰符的工作原理，以及我们如何使用它们来提高我们的功能。

2808
04:56:34.738 --> 04:56:36.142
好吧，太棒了。

2809
04:56:36.142 --> 04:56:40.415
我们已经具备了合同的所有基本功能。

2810
04:56:40.415 --> 04:56:46.792
现在我们终于要在一个测试中运行所有的东西，并在我们眼前看到所有发生的事情。

2811
04:56:46.792 --> 04:56:49.022
你准备好了吗?让我们开始吧。

2812
04:56:49.177 --> 04:56:50.849
我们转到deploy选项卡。

2813
04:56:52.177 --> 04:56:53.808
当然要注射网三。

2814
04:56:55.177 --> 04:57:04.125
注入web 3，因为我们的价格转换器点灵魂使用的是链链甲骨文的，实际上存在，并为我们监控林克比网络。

2815
04:57:04.125 --> 04:57:09.112
现在我们向下滚动到，我们会选择Funmi合约。

2816
04:57:09.178 --> 04:57:11.016
我们将继续进行部署。

2817
04:57:12.178 --> 04:57:14.735
确保我们在林克比测试网上。

2818
04:57:16.178 --> 04:57:20.629
我们的钱包里有些垃圾，让我们继续部署，确认。

2819
04:57:20.629 --> 04:57:22.435
我们再等一会儿。

2820
04:57:22.435 --> 04:57:24.458
我把我们的日志调出来。

2821
04:57:24.458 --> 04:57:28.606
我们会等待一段时间，等待我们的合同被部署。

2822
04:57:28.606 --> 04:57:29.409
好了,好了。

2823
04:57:29.409 --> 04:57:32.557
看来我们的合同已经部署好了。

2824
04:57:32.557 --> 04:57:39.754
如果我们向下滚动，我们可以看到所有的功能，最低美元将是50美元。

2825
04:57:39.754 --> 04:57:54.817
但是有18个0，所以单位与Aetherium相同，我们的合同所有者被设置为我们的地址，我们部署这个合同的瞬间，它是通过调用构造函数部署的。

2826
04:57:54.817 --> 04:58:10.716
这个地址0x106x和元掩码中的地址是一样的，当然，你的地址和我的有一点不同，我们有一个funders数组，它当然是空白的，我们有一个地址数组，它也是空白的。

2827
04:58:10.716 --> 04:58:34.278
然后我们有两个函数可以用来修改区块链提现的状态它是橙色的，因为我们没有支付任何Aetherium我们实际上获得了Aetherium或任何原生区块链货币基金，因为fun是一个可支付函数我们将把Aetherium发送到或发送任何原生区块链货币。

2828
04:58:34.278 --> 04:58:36.419
让我们继续，看看这是如何工作的。

2829
04:58:36.419 --> 04:58:39.712
首先，让我们为这个合同提供资金。

2830
04:58:39.712 --> 04:58:46.469
再说一次，资金问题，我们得做点数学计算，因为每个人的价格在3000美元左右。

2831
04:58:46.469 --> 04:58:48.654
我们要50美元。

2832
04:58:48.654 --> 04:58:51.998
最小值是50除以3000。

2833
04:58:51.998 --> 04:58:56.871
可以用3000除以50，也可以用50除以3000。

2834
04:58:56.871 --> 04:58:58.979
我们知道在0附近。

2835
04:58:58.979 --> 04:59:04.721
02 Aetherium，应该足够本合同生效。

2836
04:59:04.721 --> 04:59:05.398
所以0。

2837
04:59:05.398 --> 04:59:13.490
02 Aetherium在这里，我们可以复制粘贴到这里。

2838
04:59:13.490 --> 04:59:16.429
当我们碰到资金时，它应该会通过。

2839
04:59:16.429 --> 04:59:18.866
我们确实看到元遮罩弹出。

2840
04:59:18.866 --> 04:59:20.790
我们将继续进行确认。

2841
04:59:20.790 --> 04:59:28.100
一旦交易完成，我们就能在以太网上看到这份合同里面有钱。

2842
04:59:28.179 --> 04:59:36.738
如果我们不加，如果我们不加一个值，我们的基金会说，气体估计失败了因为我们在这里输入的量不够。

2843
04:59:36.738 --> 04:59:44.655
事实上，我们甚至看到execution reverted没有发送足够的数据，我们完全可以发送这个事务但是，它会失败。

2844
04:59:44.655 --> 04:59:45.035
太好了。

2845
04:59:45.035 --> 05:00:03.369
现在我们的交易已经完成了，如果我们继续到溜冰场以太扫描，一旦我们等待它完成在这里的索引在溜冰场以太扫描上，我们可以看到这个交易实际上已经完成了资金，我们可以看到这个交易中有很多不同的细节。

2846
05:00:03.369 --> 05:00:20.645
向下滚动，你能看到所有调用fun函数的信息，气体限制气体，燃气费，燃气价格，我们还能看到输入数据，我们在这里调用了基金函数。

2847
05:00:20.645 --> 05:00:22.920
稍后我们将进一步了解输入数据。

2848
05:00:22.920 --> 05:00:32.093
如果我们转到我们部署的契约，我们现在可以看到两个事务，我们可以看到契约创建的事务。

2849
05:00:32.180 --> 05:00:34.954
我们还调用了一个字体方法。

2850
05:00:36.180 --> 05:00:38.805
合同的余额，现在是0。

2851
05:00:40.180 --> 05:00:43.230
因为我们发送的是0。

2852
05:00:43.230 --> 05:00:43.433
02.

2853
05:00:43.433 --> 05:00:45.161
如果代入0。

2854
05:00:46.180 --> 05:00:58.930
回到值部分，我们再次调用字体，在这个事务完成后，我们应该看到这个数字从0开始。

2855
05:00:58.930 --> 05:00:59.695
02到0。

2856
05:00:59.695 --> 05:00:59.913
04.

2857
05:00:59.913 --> 05:01:07.998
现在，在我们等待一个短暂的延迟之后，我们确实看到余额已经上升到0。

2858
05:01:07.998 --> 05:01:10.649
04，这正是我们所期望的。

2859
05:01:10.649 --> 05:01:11.138
太棒了。

2860
05:01:11.138 --> 05:01:14.248
所以我们的融资机制运转正常。

2861
05:01:14.248 --> 05:01:26.656
如果我们向下到数组中，我们的地址到数组的映射，我们粘贴地址，我们应该会看到电话号码显示出来。

2862
05:01:26.656 --> 05:01:29.913
如果我们去找零资助者，我们会看到我们的地址。

2863
05:01:29.913 --> 05:01:51.443
如果我们去找一家的资助者，我们也会看到我们的地址我们会看到这个调用如果我们去找资助者，在我们的日志中，我们实际上会看到我们会得到一个错误我们可以在未来对我们的合同做的优化是检查一个地址是否已经在资助者数组中如果它已经在那里就不添加它。

2864
05:01:51.443 --> 05:01:54.680
现在我们试着调用这个取款函数。

2865
05:01:54.680 --> 05:02:00.040
我们用一个不同的地址来调用它而不是我们最初部署契约的地址。

2866
05:02:00.040 --> 05:02:04.466
要做到这一点，滚动到这里的顶部。

2867
05:02:04.466 --> 05:02:07.657
我要去找我的超元面具了。

2868
05:02:07.657 --> 05:02:13.130
我要切换到另一个账户，点击连接。

2869
05:02:13.130 --> 05:02:32.388
现在，我们的混音应该会随着这里的新帐户而更新，你会看到如果我切换回帐户1，它也会切换回帐户1，只要它们都是连接的，你可以通过点击连接按钮看到哪些帐户连接到应用程序，看看哪些已经连接。

2870
05:02:32.388 --> 05:02:37.768
如果你想断开该帐户，你可以点击这三个小点，它就会断开该帐户。

2871
05:02:37.768 --> 05:02:41.431
现在我们可以看到这个账户没有连接。

2872
05:02:41.431 --> 05:02:43.931
然而，计数二是连接的。

2873
05:02:43.931 --> 05:02:50.373
让我们回到帐户1，连接帐户1，这样它们现在都是连接的。

2874
05:02:50.373 --> 05:02:59.045
但我们要切换到账户2，切换到账户2，因为账户2不是合同的所有者。

2875
05:02:59.045 --> 05:03:07.602
我们向下滚动到所有者，我们可以看到所有者的0x 1066某某账户2是0x 043。

2876
05:03:07.602 --> 05:03:09.566
一些很棒的东西。

2877
05:03:09.566 --> 05:03:16.536
当我们点击这里的取款，你认为会发生什么?好吧，我们的修改器的唯一所有者应该踢。

2878
05:03:16.536 --> 05:03:23.117
我们会得到通知如果我们发送事务，我们会得到这个错误sender不是owner。

2879
05:03:23.181 --> 05:03:24.334
我们来试试。

2880
05:03:27.181 --> 05:03:27.870
这个错误。

2881
05:03:27.870 --> 05:03:30.490
发送者不是所有者，这很完美。

2882
05:03:31.181 --> 05:03:34.906
如果我们想，我们完全可以发送这个事务。

2883
05:03:34.906 --> 05:03:39.886
但这只是浪费汽油，因为交易将会失败。

2884
05:03:39.886 --> 05:03:54.248
但是，如果我们切换回账号1，点击取款，元掩码就会弹出，使我们能够确认并从这个合同地址中提取以太币。

2885
05:03:54.248 --> 05:04:01.283
现在，如果我们通过以太扫描查看合同地址，经过短暂的延迟后，我们会看到余额从0变为0。

2886
05:04:01.283 --> 05:04:03.316
回到0。

2887
05:04:03.316 --> 05:04:09.018
我们会看到我们的钱包余额从原来的增加到0。

2888
05:04:09.018 --> 05:04:10.263
04加上它是多少。

2889
05:04:10.263 --> 05:04:16.821
在短暂的延迟之后，你可以看到我们合同上的余额实际上已经回到了零。

2890
05:04:16.821 --> 05:04:22.515
现在，如果我们对正在进行融资的钱包地址进行地址到金额的操作，它就会回到0。

2891
05:04:22.515 --> 05:04:39.070
如果我们试图检查指数为0的资助者的地址，我们会被呼叫到那些执行错误的资助者。

2892
05:04:40.182 --> 05:04:43.665
我们已经完成了这一节中我想讲的所有基础知识。

2893
05:04:43.665 --> 05:05:00.165
你应该为自己走到这一步而感到无比自豪，你刚刚部署了一个非常先进的智能合约，我们正在使用库和链链合约来构建一些地球上最强大的应用程序，我们已经学会在智能合约中使用库来实现我们想要的任何类型。

2894
05:05:00.165 --> 05:05:06.126
我们已经学习了更多关于乘法的知识，以及稳定性和智能合约的计量单位。

2895
05:05:06.182 --> 05:05:17.603
我们已经学习了映射更多的关于数组的构造函数是做什么的，我们已经学习了如何送钱我们已经学习了for循环，我们已经学习了我们实际上可以送钱的不同方式，至少从低层次上。

2896
05:05:17.603 --> 05:05:18.962
我们学了修饰语。

2897
05:05:18.962 --> 05:05:21.314
这部分是本课程中比较难的部分。

2898
05:05:21.314 --> 05:05:24.288
所以如果你完成了这个，你应该非常兴奋。

2899
05:05:24.288 --> 05:05:26.340
我们现在要过一遍代码。

2900
05:05:26.340 --> 05:05:28.603
我们会做一些调整。

2901
05:05:28.603 --> 05:05:33.021
这一节，我们要讲一些更高级的固体性。

2902
05:05:33.021 --> 05:05:36.563
所以如果你有点迷路了，不要太担心。

2903
05:05:36.563 --> 05:05:40.115
你们将来也可以自己尝试这些东西。

2904
05:05:40.115 --> 05:05:45.611
我们要修改这份合同，使它更专业一点。

2905
05:05:45.611 --> 05:05:48.789
这不会是从头到尾的惊人，但会好一点。

2906
05:05:48.789 --> 05:05:49.827
你马上就会知道为什么了。

2907
05:05:49.827 --> 05:05:54.389
我们要做的第一件事是我们要看我们要看这里的一些变量。

2908
05:05:54.389 --> 05:06:00.849
特别是业主和最低美元，业主在我们的合同中只得到一次。

2909
05:06:00.849 --> 05:06:02.860
它永远不会改变。

2910
05:06:02.860 --> 05:06:09.199
同样，最小USD只设置一次，即使在构造函数之外也是如此。

2911
05:06:09.199 --> 05:06:17.241
如果我们的变量只设置一次，我们可以用一些固体的工具让它们更省气。

2912
05:06:17.241 --> 05:06:22.133
现在，让我们编译Funmi契约，然后将其部署到一个JavaScript虚拟机上。

2913
05:06:22.183 --> 05:06:25.505
记住，我们现在就可以部署它。

2914
05:06:26.183 --> 05:06:29.792
融资，撤资，用钱做这些事是行不通的。

2915
05:06:29.792 --> 05:06:34.183
因为我们的JavaScript虚拟机上没有链式链接网络。

2916
05:06:34.183 --> 05:06:36.083
所以这些不会很好地工作。

2917
05:06:36.183 --> 05:06:38.649
但对于我们现在要做的，我们并不太在意。

2918
05:06:38.649 --> 05:06:40.582
这是我们真正关心的。

2919
05:06:40.582 --> 05:06:44.468
你肯定很在意这车到底要花多少汽油。

2920
05:06:44.468 --> 05:06:56.083
我们关心的是现在创建这个合同需要多少汽油，大约859,000汽油，我们将添加一些技巧。

2921
05:06:56.183 --> 05:07:01.748
现在，为了降低这个数字，我们将在出价中添加一些东西，这将使它上升。

2922
05:07:01.748 --> 05:07:04.374
但现在，我们要学习一些技巧来降低这个数字。

2923
05:07:04.374 --> 05:07:10.127
我们要学的两个技巧是常量关键字和不可变关键字，它们的稳定性。

2924
05:07:10.184 --> 05:07:14.829
有两个关键字使得你的变量不能被改变。

2925
05:07:14.829 --> 05:07:17.796
这些关键字是常量和不可变的。

2926
05:07:17.796 --> 05:07:31.238
您可以在稳定性文档中了解更多关于它们的内容，如果您在函数外部赋值一个变量，然后永远不更改它，所以如果如果它在编译时赋值，您可以继续并添加这个常量关键字。

2927
05:07:31.238 --> 05:07:33.103
我们稍后将学习存储。

2928
05:07:33.103 --> 05:07:40.724
但是，当您添加一个常量关键字时，这个最低美元不再占用存储点，也更容易读取。

2929
05:07:40.724 --> 05:07:43.911
现在我们重新编译这个，部署这个新契约。

2930
05:07:43.911 --> 05:07:46.638
看看能不能省点油。

2931
05:07:46.638 --> 05:07:55.701
我们查看事务日志，现在，我们可以获取部署成本的事务成本，让我们将其与之前的成本进行比较。

2932
05:07:55.701 --> 05:08:02.078
我们节省了近19,000汽油，这几乎和运送Aetherium的成本一样多。

2933
05:08:02.078 --> 05:08:05.541
通常，常量变量有不同的命名约定。

2934
05:08:05.541 --> 05:08:09.834
通常情况下，你会像Min imaam那样把它们都大写。

2935
05:08:09.834 --> 05:08:13.802
下划线，他是CIO，所有的大写都是下划线。

2936
05:08:13.802 --> 05:08:17.902
现在我们求最小使用量D，用大写字母替换。

2937
05:08:17.902 --> 05:08:27.684
通过这种交互，我们知道这个变量是一个常数变量，如果我们继续编译它并重新部署它，从现在开始读取它会便宜得多。

2938
05:08:27.684 --> 05:08:43.791
在Funmi契约中，尽管这是一个视图函数，记住，视图函数是有气体成本的当被契约作为常量变量调用时，我们可以看到这个变量的执行成本21415气体。

2939
05:08:43.791 --> 05:08:47.106
让我们用内森来表示。

2940
05:08:47.185 --> 05:08:50.971
如果我们删除常量变量，我们就删除了这个契约。

2941
05:08:50.971 --> 05:08:53.725
我们重新部署，就像Funmi。

2942
05:08:53.725 --> 05:08:58.507
我们再次到达最小值ust，我们可以看到这花费了多少汽油。

2943
05:08:58.507 --> 05:09:03.136
如果它不是一个常数变量，我们可以看到汽油成本确实上升了。

2944
05:09:03.185 --> 05:09:07.736
现在在更便宜的链条上，这种气体差异可能不会有太大的区别。

2945
05:09:07.736 --> 05:09:11.874
但在像Aetherium这样更昂贵的连锁店，这将带来很大的不同。

2946
05:09:11.874 --> 05:09:17.092
例如，在Aetherium上，我们可以看到当前的天然气价格。

2947
05:09:17.092 --> 05:09:39.768
这里，我们可以看到Aetherium当前的天然气价格大约是141路，所以我们将转到转换器，我们将价格乘以这个方式，我们将得到天然气价格调用我们的最小美元，就是这个数字，如果我们把这个数字放回Aetherium单转换器，我们可以看到天然气价格是这么多。

2948
05:09:39.768 --> 05:09:46.023
如果我们用这个乘以Aetherium的当前价格，也就是3000美元左右。

2949
05:09:46.023 --> 05:10:01.495
将最小使用量D设为常数将花费9美元而在非常数情况下将花费几乎整整一美元，你可以看到所有这些气体优化技巧将如何使你的生活变得更好。

2950
05:10:01.495 --> 05:10:03.770
我们把这个常量关键字保留在这里。

2951
05:10:03.770 --> 05:10:07.753
我们将在本课程后面的部分学习更多关于常数和存储的知识。

2952
05:10:07.753 --> 05:10:13.338
现在，当你刚刚开始学习这门课的时候，在滑倒的时候不要挣扎。

2953
05:10:13.338 --> 05:10:20.879
在一开始，特别是现在，不要担心如何使你的合同尽可能的省油。

2954
05:10:20.879 --> 05:10:23.293
尽你所能把合同写好。

2955
05:10:23.293 --> 05:10:25.262
一旦你对汽油很在行。

2956
05:10:25.262 --> 05:10:34.024
一旦你在这门课上走得更远，在固体性方面走得更深入了，你就可以回去研究气体优化了。

2957
05:10:34.024 --> 05:10:37.056
但不要让气体优化阻碍你的发展。

2958
05:10:37.186 --> 05:10:40.347
或者如果你开始为此感到压力，就随它去吧。

2959
05:10:41.186 --> 05:10:43.720
你只需要尽可能地编写你的代码。

2960
05:10:44.186 --> 05:10:47.878
简而言之，现在不要担心气体优化。

2961
05:10:48.186 --> 05:10:51.820
另一个只设置一次的变量是我们的所有者变量。

2962
05:10:51.820 --> 05:10:54.359
所有者等于消息点发送方。

2963
05:10:54.359 --> 05:11:01.474
我们在构造函数变量中设置了一次但在声明的同一行之外。

2964
05:11:01.474 --> 05:11:17.028
例如，我们在构造函数中设置它们，我们可以标记为可变的通常标记不可变变量的一个很好的惯例是，我用下划线标记，这样我们就知道这些是不可变变量，它们和常量关键字节省的时间非常相似。

2965
05:11:17.028 --> 05:11:25.186
当然，Owner是一个我们不能在这一行上设置的变量因为在全局作用域内，没有函数。

2966
05:11:25.186 --> 05:11:33.979
不过，在函数内部，因为在全局作用域内，没有message sender，只有message。sender当我们在函数内部时。

2967
05:11:33.979 --> 05:11:37.616
在这里，我们可以说iowner = message。sender。

2968
05:11:37.616 --> 05:11:44.686
当然，我们会向下滚动我们会改变这个require only owner now = iowner。

2969
05:11:44.686 --> 05:11:59.907
如果我们编译这个deploy，我们可以看到有多少gas我们可以看到调用I owner会有多少gas通过不可变通知，我们得到21508，我们现在继续复制。

2970
05:11:59.907 --> 05:12:03.044
我们在这里写上，不可变。

2971
05:12:03.044 --> 05:12:09.218
现在，如果我们删除immutable关键字，让我们关闭这个重新部署。

2972
05:12:09.218 --> 05:12:18.631
如果我们向下滚动到I所有者，把日志弄乱，我们向下滚动到调用，向下滚动，我们看到执行成本要多得多。

2973
05:12:18.631 --> 05:12:25.083
我们用反斜杠，这里是7，或者是非不可变的。

2974
05:12:25.083 --> 05:12:30.726
在存储变量时，你们要记住这些技巧。

2975
05:12:30.726 --> 05:12:40.344
这两个节省时间的原因是，我们不是将这些变量存储在存储槽中，而是将它们直接存储在契约的字节码中。

2976
05:12:40.344 --> 05:12:49.237
就像我说的，现在不要太担心这个，在后面的课程中，我们会教你们更多关于存储的知识以及很多与这些契约相关的低级知识。

2977
05:12:49.237 --> 05:12:51.742
但现在，只需要知道它们的存在。

2978
05:12:51.742 --> 05:12:57.669
如果你只设置一次变量，它们是很好的省油器。

2979
05:12:57.669 --> 05:12:59.008
好了,好了。

2980
05:12:59.187 --> 05:13:06.219
我们让合同更节能了一点，我在这门课中会讲到一些节能的概念。

2981
05:13:06.219 --> 05:13:16.237
当我们讲到更高级的部分时，我会详细分析到底发生了什么，为什么会有这些气体效率以及这些气体效率产生的背后发生了什么。

2982
05:13:16.237 --> 05:13:20.141
这是一个有点杂草，这就是为什么我现在要掩盖它。

2983
05:13:20.187 --> 05:13:25.387
如果你感到困惑，别担心，我不会让气体效率影响你的速度。

2984
05:13:25.387 --> 05:13:25.787
太棒了。

2985
05:13:25.787 --> 05:13:53.394
我们有这两种气体优化?我们还能怎样让这份合同更省油呢?我们有一种更节省气体的方法，就是用require语句更新require，我们需要将sender不是owner存储为字符串数组，errorlog中的每一个字符都需要单独存储，这个字符串看起来不是很大，但它比另一种方法要大得多。

2986
05:13:53.394 --> 05:13:54.663
从零点开始，点8。

2987
05:13:54.663 --> 05:13:58.489
4的稳定性，你现在可以定制误差。

2988
05:13:58.489 --> 05:14:06.774
对于我们的还原，我们在顶部声明它们，然后使用if，而不是require，然后只添加一个还原语句。

2989
05:14:06.774 --> 05:14:15.323
这最终节省了很多气体，因为我们只是调用错误代码，而不是调用与空气相关的整个字符串。

2990
05:14:15.323 --> 05:14:25.568
举个例子，下面的require，还有所有的require，我们可以不写这个require我们可以创建一个自定义错误。

2991
05:14:25.568 --> 05:14:32.188
在顶部，我们可以写error，而不是owner。

2992
05:14:32.188 --> 05:14:38.091
你会注意到这实际上是在合同之外的。

2993
05:14:38.091 --> 05:15:00.067
现在我们能做的是将这个error not owner向下滚动到我们唯一的所有者，而不是require我们会做一个if语句，我们会说if message。sender不是owner，然后我们会用一个非所有者错误进行恢复。

2994
05:15:00.188 --> 05:15:05.670
这为我们节省了很多气体，因为我们不需要储存和释放这么长的绳子。

2995
05:15:05.670 --> 05:15:12.413
在现在的很多代码中，你仍然会看到require有很多地方因为这些自定义错误在坚固性方面是很新的。

2996
05:15:12.413 --> 05:15:14.854
所以你要习惯两种写法。

2997
05:15:14.854 --> 05:15:20.619
如果在未来，这些错误的语法看起来像这样，我不会感到惊讶，因此它更可读。

2998
05:15:20.619 --> 05:15:28.654
但是现在，如果你想用一种比要求的更省油的方法，你可以用这样的方法，我们可以为这些客户更新所有的要求。

2999
05:15:28.654 --> 05:15:32.389
但现在，我把两者都留在这里，给你们看看它们的区别。

3000
05:15:32.389 --> 05:15:37.734
这个revert关键字所做的事情与要求我们做的完全相同，但没有预先设置条件。

3001
05:15:37.734 --> 05:15:43.576
你可以在函数调用中间恢复任何事务或任何函数调用。

3002
05:15:43.576 --> 05:15:48.995
现在让我们看看另一种改进合同的方法。

3003
05:15:49.189 --> 05:15:58.141
有时，人们会尝试与接受Aetherium或原生区块链令牌的合约进行交互，而不实际执行所需的函数调用。

3004
05:15:58.141 --> 05:16:05.322
例如，在JavaScript EVM中，我可以在不调用fund函数的情况下发送合约资金。

3005
05:16:05.322 --> 05:16:17.564
但是，如果我这样做，我们的基金函数会被触发吗?不，它不会被触发，我们不会跟踪那个资助者，我们不会在合同中更新那个人的信息。

3006
05:16:17.564 --> 05:16:21.989
所以如果以后我们想要给予奖励或其他我们不知道的资助者的信息。

3007
05:16:21.989 --> 05:16:28.722
这并不是什么好事，因为人们会在我们不知情的情况下把合同款项寄给我们，我们就无法给他们任何信用或其他东西。

3008
05:16:28.722 --> 05:16:34.680
另外，也许他们不小心调用了错误的函数，他们他们没有使用Metamask。

3009
05:16:34.680 --> 05:16:39.223
他们没有使用工具来告诉他们，嘿，这个交易可能会失败。

3010
05:16:39.223 --> 05:16:57.911
在这种情况下我们能做什么?如果有人没有调用fun函数就发送了这个合约，会发生什么?现在，如果我们要发送这份Funmi合同，也就是说，它只会进入合同，而这个合同不会记录那些人的信息。

3011
05:16:57.911 --> 05:17:05.640
但实际上有一种方法，当人们向这个合约汇钱，或调用一个我们不存在的函数时，仍然会触发一些代码。

3012
05:17:05.640 --> 05:17:13.500
固体中有两个特殊的函数一个叫接收，一个叫回退。

3013
05:17:13.500 --> 05:17:21.750
在固性中，实际上有很多特殊函数其中两个是接收特殊函数。

3014
05:17:21.750 --> 05:17:29.134
以及备用的特殊功能，一个合同最多可以有一个使用已收到的外部应付款项声明的接收功能。

3015
05:17:29.190 --> 05:17:30.717
没有function关键字。

3016
05:17:32.190 --> 05:17:37.086
参数不能返回任何东西，必须具有外部可见性和可支付状态可变性。

3017
05:17:37.086 --> 05:17:43.534
这到底是什么意思?和或看起来像?让我们创建一个单独的契约来处理这个。

3018
05:17:43.534 --> 05:17:48.461
在这里，我们要创建一个新文件叫做fallback example。soul。

3019
05:17:48.461 --> 05:17:59.271
在这里，我们将添加我们的基本部分，SPX许可标识符，MIT pragma, solidity 0，点8。

3020
05:17:59.271 --> 05:17:59.402
7.

3021
05:17:59.402 --> 05:18:17.577
我们会做一个契约回退的例子，就像这样，可以暂停视频来复习这一点，让我们重新创建回退契约，让我们创建一个变量来测试这个函数，我们会创建一个un256 public result变量。

3022
05:18:17.577 --> 05:18:19.464
我们来创建这个receive函数。

3023
05:18:19.464 --> 05:18:25.081
我们写上receive，它是外部应付账款。

3024
05:18:25.190 --> 05:18:38.611
函数，我们没有为receive添加function关键字，因为solid知道receive是一个特殊的函数，无论何时我们发送Aetherium或在此合同中进行交易。

3025
05:18:38.611 --> 05:18:45.123
现在，只要没有与该事务相关的数据，这个receive函数就会被触发。

3026
05:18:45.191 --> 05:18:49.868
我们现在能做的是我们可以说result = 1。

3027
05:18:50.191 --> 05:18:56.444
让我们在JavaScript虚拟机上测试一下，我们编译这个，我们会编译这个。

3028
05:18:56.444 --> 05:19:02.591
我们会把它部署到Java虚拟机上，我们会部署我们的备胎例子。

3029
05:19:02.591 --> 05:19:11.159
我们会看到result被初始化为什么，因为我们还没有为result设置任何东西，当然，result被初始化为0。

3030
05:19:11.159 --> 05:19:22.771
但如果我们给这个合同送点Aetherium呢?接收将继续并在这里被触发，我们实际上可以通过这种低级交互直接向这个合约发送一些材料。

3031
05:19:22.771 --> 05:19:31.005
但在这里，现在不要担心调用数据意味着什么，只需要知道下面这个区域是我们可以发送和处理不同函数的方式。

3032
05:19:31.005 --> 05:19:36.568
我们可以给这个事务添加参数，通过在上面这里调整上面这里的变量。

3033
05:19:36.568 --> 05:19:40.980
如果我们保持调用Data为空，它将和我们在Metamask中一样。

3034
05:19:40.980 --> 05:19:44.246
点击发送，选择合同地址。

3035
05:19:44.246 --> 05:19:50.541
同样，我们不能使用Metamask，因为这是一个虚拟机，而不是我们正在使用的网络之一。

3036
05:19:50.541 --> 05:19:56.175
如果我这样做了，例如，我把这个值改为单向的，所有的都保持为空。

3037
05:19:56.175 --> 05:20:03.905
然后我点击这个事务按钮，它和点击这个发送按钮是一样的，但只是单向发送。

3038
05:20:03.905 --> 05:20:07.287
你认为会发生什么?好吧，让我们试试。

3039
05:20:07.287 --> 05:20:12.379
我们可以在日志区域看到我们确实发送了一个事务。

3040
05:20:12.379 --> 05:20:26.128
如果你看这里的描述，你甚至可以看到它说从某某返回例子，点接收，它好像调用了我们的received函数，它应该把结果更新为1。

3041
05:20:26.192 --> 05:20:31.542
如果我们点击result，现在我们可以看到结果被更新为值1。

3042
05:20:31.542 --> 05:20:33.499
我们把这个删掉。

3043
05:20:33.499 --> 05:20:36.037
让我们再次部署这个契约。

3044
05:20:36.037 --> 05:20:41.925
这一次，设这个值为0,receive会被触发。

3045
05:20:41.925 --> 05:20:43.159
我们把它拉下来。

3046
05:20:43.159 --> 05:20:44.078
点击交易。

3047
05:20:44.078 --> 05:20:48.128
让我们让调用数据为空，让值为零。

3048
05:20:48.128 --> 05:20:54.275
所以这和我们向合同中发送零Aetherium是一样的。

3049
05:20:54.275 --> 05:20:55.628
点击交易。

3050
05:20:55.628 --> 05:21:09.699
看起来已经通过了，你认为结果会是1还是0 ?你认为一个你是正确的或者接收函数被触发我们现在向这个合约发送一个事务，我们不指定函数。

3051
05:21:09.699 --> 05:21:14.463
当与Funmi等其他合同合作时，我们保持通话数据为空。

3052
05:21:14.463 --> 05:21:22.730
例如，当我们调用其中一个函数时，我们实际上只是用特定的数据填充调用数据位指向上面这些函数中的一个。

3053
05:21:22.730 --> 05:21:28.642
如果我们发送一个事务并向它添加数据，我们实际上可以调用其中一个函数。

3054
05:21:28.642 --> 05:21:29.869
现在我们再试一次。

3055
05:21:29.869 --> 05:21:39.345
让我们再次删除契约，我们将重新部署打开它，结果是0接收，就像我说的，只有当调用数据为空时才会触发。

3056
05:21:39.345 --> 05:21:50.588
这次如果我有一些调用数据到这个事务，你认为接收会被触发吗?如果我们点击transaction和remix我们会弹出一个提示说，回退函数没有定义。

3057
05:21:50.588 --> 05:22:00.744
这是因为，当数据通过事务可靠度发送时，就会说，哦，好吧，既然你在发送数据，你就不寻找接收，而是寻找某个函数。

3058
05:22:00.744 --> 05:22:03.571
我来帮你们找找这个函数。

3059
05:22:03.571 --> 05:22:07.243
我没有看到任何函数匹配0x00。

3060
05:22:07.243 --> 05:22:09.982
我要找你的备用函数。

3061
05:22:09.982 --> 05:22:13.572
Remix很聪明，知道我们没有备用函数。

3062
05:22:13.572 --> 05:22:17.143
固体中的第二个特殊函数叫做回退函数。

3063
05:22:17.193 --> 05:22:24.761
这与接收函数非常相似，不同之处在于，即使数据随事务一起发送，它也可以工作。

3064
05:22:24.761 --> 05:22:31.553
我们的后备方案就像这个回调，外部应付。

3065
05:22:31.553 --> 05:22:48.783
Fallback是另一个我们不打算放函数选择器的函数因为固位性期望这个，实际上，你们已经熟悉了另一个特殊函数，我们回到Funmi。

3066
05:22:48.783 --> 05:22:53.242
例如，构造函数是另一种类型的特殊函数。

3067
05:22:53.242 --> 05:22:55.078
没有函数关键字。

3068
05:22:55.078 --> 05:22:59.548
坚固性知道，当我们部署这个契约时，这个构造函数会立即被调用。

3069
05:22:59.548 --> 05:23:02.056
现在我们有了回退函数。

3070
05:23:02.193 --> 05:23:04.161
让我们继续编译它。

3071
05:23:06.193 --> 05:23:09.660
让我们继续部署这个新契约。

3072
05:23:11.193 --> 05:23:13.923
结果，我们确实看到了，它被设为零。

3073
05:23:15.193 --> 05:23:24.668
0x00，我发送这个，然后点击交易，这相当于调用合约，但没有有效函数。

3074
05:23:24.668 --> 05:23:29.630
所以我们的合同是这样的，嗯，我不明白你想告诉我什么，我建议你参考我们的备用方案。

3075
05:23:29.630 --> 05:23:33.431
如果我们点击result，我们会看到它被更新为2。

3076
05:23:33.431 --> 05:23:41.144
如果我们把这个拿走，固体就会消失，嗯，看起来你在试图发送一些Aetherium，或者调用这个合同，但没有说明你想做什么。

3077
05:23:41.144 --> 05:23:42.744
我有一个接收函数。

3078
05:23:42.744 --> 05:23:45.418
所以我要把它转发给你。

3079
05:23:45.418 --> 05:24:05.732
如果我们调用transact，我们会看到它更新回1，添加一些数据，点击transact，我们会看到它更新到无数据，慢慢地更新到1例如，org有一个很好的图表我们可以用它来判断是否会触发receive，或者触发Fallback。

3080
05:24:05.732 --> 05:24:09.755
如果它是空的，并且有一个receive函数，它会调用receive函数。

3081
05:24:09.755 --> 05:24:15.194
如果是data，而没有receive函数，它就会去回退函数。

3082
05:24:15.194 --> 05:24:18.527
如果没有备用功能，它可能它可能会被空气排出。

3083
05:24:18.527 --> 05:24:21.501
这里有很多非常棒的信息。

3084
05:24:21.501 --> 05:24:35.780
如何将其应用到fund mi合约中呢，Funmi中我们能做的是添加这些回退和接收函数，以防有人给我们发送合约资金而不是正确调用fund函数。

3085
05:24:35.780 --> 05:24:39.008
我们能做的是添加一个接收函数。

3086
05:24:39.008 --> 05:24:48.095
如果有人不小心给它寄了钱，我们仍然可以处理这个交易说，接收将是外部支付。

3087
05:24:48.194 --> 05:24:51.319
我们会有receive函数调用基金。

3088
05:24:52.194 --> 05:24:59.030
与我们的fallback函数相同的事情将有fallback external payable。

3089
05:24:59.030 --> 05:25:03.964
我们会让它自动调用基金。

3090
05:25:04.194 --> 05:25:13.240
现在，如果有人不小心给我们汇了钱而没有调用我们的fund函数，它仍然会自动把钱路由到fund函数。

3091
05:25:13.240 --> 05:25:19.581
这意味着，如果有人没有给我们提供足够的资金，这笔交易仍然会被退回。

3092
05:25:19.581 --> 05:25:20.645
现在我们继续。

3093
05:25:20.645 --> 05:25:26.127
让我们切换到溜冰场B，在一个真实的测试网上进行测试，安曼溜冰场B和我的Metamask。

3094
05:25:26.195 --> 05:25:29.340
让我们切换到注射网3号。

3095
05:25:31.195 --> 05:25:32.695
我们会选择Funmi合同

3096
05:25:34.195 --> 05:25:38.928
如果超掩码出现，我就去确认这笔交易。

3097
05:25:38.928 --> 05:25:45.391
我们看到我们的Funmi合同现在我们可以看到所有者我们可以看到我是所有者，我们可以看到最低美元。

3098
05:25:45.391 --> 05:25:50.623
我们可以看到这是一个空白合同，里面没有任何资金。

3099
05:25:50.623 --> 05:25:59.776
如果我们复制地址，然后进行以太扫描，将地址粘贴进去，我们可以看到这里没有以太。

3100
05:25:59.776 --> 05:26:02.923
与此相关的唯一交易就是合同的订立。

3101
05:26:02.923 --> 05:26:11.719
当我们遇到fun函数时，我们看到了之前发生的事情，我们的合同更新了一个新的余额，而资助者被添加到我们的数组中。

3102
05:26:11.719 --> 05:26:19.127
看看如果不调用基金函数直接给合约钱会怎样。

3103
05:26:19.195 --> 05:26:26.555
如果我们这样做正确，那么receive函数应该会接收它并将事务踢过字体。

3104
05:26:26.555 --> 05:26:28.768
我们复制这个地址。

3105
05:26:28.768 --> 05:26:30.899
转到元蒙版。

3106
05:26:30.899 --> 05:26:34.998
点击发送，把地址和0粘贴到这里。

3107
05:26:34.998 --> 05:26:35.571
02容易的。

3108
05:26:35.571 --> 05:26:42.445
同样，因为这应该超过以美元计算的最低金额，所以我们将进行下一个操作。

3109
05:26:42.445 --> 05:26:44.661
我来确认一下。

3110
05:26:44.661 --> 05:27:01.283
在稍微延迟之后，如果我们这样做是正确的，我们应该看到事务已经调用了这里的基金函数，现在我们的事务已经完成了。在等待醚可以更新的短暂延迟之后，我们确实看到我们的余额已经更新为0。

3111
05:27:01.283 --> 05:27:03.769
02，当然，这是有道理的。

3112
05:27:03.769 --> 05:27:11.179
在这里的交易列表中，我们看到这实际上是作为一个转移而不是调用基金函数。

3113
05:27:11.179 --> 05:27:16.098
我们继续混合看看资助者是否更新了。

3114
05:27:16.196 --> 05:27:20.996
看起来它是在0和资助者的位置，我们有我们的地址。

3115
05:27:20.996 --> 05:27:27.481
如果我们把我们的地址输入到“地址”和“资助金额”中，我们就能看到我们到底资助了多少。

3116
05:27:27.481 --> 05:27:34.129
这意味着，既然我们在这里添加了receive函数，我们就必须自动调用这里的fun函数。

3117
05:27:34.196 --> 05:27:45.862
非常棒的工作，我们能够添加一个receive函数来帮助那些不小心调用了错误的函数或不小心发送了合同资金，而不是正确调用了fun函数的人。

3118
05:27:45.862 --> 05:27:59.114
现在，如果他们直接调用fun函数，他们会少花一点油，但至少这次，他们会得到信用，并把它添加到我们的资助者数组中因为他们发送了我们的融资合同资金。

3119
05:27:59.196 --> 05:28:02.561
我们甚至学习了固体的一些高级部分。

3120
05:28:03.196 --> 05:28:13.147
这将是我们最后一次在remix中开始我们的项目，我们现在将转移到代码编辑器，在那里我们可以得到更高级的我们的设置的稳固性。

3121
05:28:13.196 --> 05:28:19.851
在很大程度上，你们已经学习了绝大多数的固体基础知识，还有很多东西我们还没有学到。

3122
05:28:19.851 --> 05:28:23.064
我们没有深入研究它们的原因是它们更高级。

3123
05:28:23.064 --> 05:28:27.434
理解它的真正用途并没有太大意义，直到后来。

3124
05:28:27.434 --> 05:28:36.609
我们会讲到itams事件，try catch函数选择器，abi编码，哈希，然后是斜杠，然后是斜杠汇编。

3125
05:28:36.609 --> 05:28:43.647
然而，如果你已经走到这一步，你可能可以阅读大多数的固体代码并理解发生了什么，这绝对是非常棒的。

3126
05:28:43.647 --> 05:28:47.585
所以你应该为自己赢得热烈的掌声，因为你走到了这一步。

3127
05:28:47.585 --> 05:28:48.397
做这个。

3128
05:28:48.397 --> 05:28:55.874
让我们快速总结一下这个更高级的部分确保我们理解了我们在固体学过的东西有几个特殊的函数。

3129
05:28:55.874 --> 05:28:59.368
其中一些是接收回退和构造函数。

3130
05:28:59.368 --> 05:29:03.641
这些函数不需要function关键字。

3131
05:29:03.641 --> 05:29:06.307
相反，它可以这样叫。

3132
05:29:06.307 --> 05:29:09.115
接收和回退是两个非常特殊的函数。

3133
05:29:09.115 --> 05:29:18.000
如果数据与事务一起发送，且未指定函数，则如果存在回退函数，则事务将默认使用回退函数。

3134
05:29:18.000 --> 05:29:22.759
如果data为空，并且有一个receive函数，它会调用receive函数。

3135
05:29:22.759 --> 05:29:27.586
从长远来看，有几个关键词可以帮助我们节省汽油。

3136
05:29:27.586 --> 05:29:30.720
其中一些关键字将是常量和不可变的。

3137
05:29:30.720 --> 05:29:35.308
常量和不可变用于只能声明和更新一次的变量。

3138
05:29:35.308 --> 05:29:39.011
一旦我们说最低美元是50乘以118。

3139
05:29:39.197 --> 05:29:41.971
这个最低美元不能再改变了。

3140
05:29:43.197 --> 05:29:43.748
节省汽油。

3141
05:29:47.197 --> 05:29:56.163
然而，不可变变量只能在构造函数中声明一次，一旦声明了不可变变量，以后就不能更改它了。

3142
05:29:56.163 --> 05:30:06.509
事实上，如果我们试图更新一个不可变变量或常量变量，然后进行编译，编译器会给我们一个错误，说，不能在这里写入一个可变变量。

3143
05:30:06.509 --> 05:30:10.024
或者我们试着改变一个常变量。

3144
05:30:10.024 --> 05:30:14.149
我们的编译器会说，嘿，你不能赋值给一个常数变量，抱歉。

3145
05:30:14.197 --> 05:30:20.885
在remix中，如果我们想向JavaScript虚拟机上的合约发送以太，我们可以部署该合约。

3146
05:30:20.885 --> 05:30:27.798
然后在合约中，我们只需要点击事务按钮而不需要任何调用数据并更新与事务一起发送的值。

3147
05:30:27.798 --> 05:30:32.039
如果调用数据为空，它将触发receive函数(如果它存在)。

3148
05:30:32.039 --> 05:30:50.139
但如果有数据没有指定任何其他函数，它会触发回退函数太棒了，你做得非常好。

3149
05:30:50.198 --> 05:30:54.713
在我们开始讲Hardhead之前，我们先来看看这一部分。

3150
05:30:54.713 --> 05:30:58.179
现在我们来看看JavaScript，理解为什么我们需要这样做。

3151
05:30:58.179 --> 05:31:02.098
让我们来了解一下如何获得帮助和遇到问题。

3152
05:31:02.098 --> 05:31:06.118
假设我们有一个Funmi合约我们刚刚完成了。

3153
05:31:06.118 --> 05:31:07.705
我们遇到了一个错误。

3154
05:31:07.705 --> 05:31:15.493
举个例子，我们忘记了payable关键字，然后我们继续编译这个compile fund，我们这样做了。

3155
05:31:15.493 --> 05:31:16.427
向下滚动。

3156
05:31:16.427 --> 05:31:21.099
很明显，这里有两个错误，我们得到了一些错误，我们向下滚动。

3157
05:31:21.099 --> 05:31:31.470
而我们看到类型错误消息点值和调用值只能是使用和可支付的公共函数，使函数可支付或使用内部函数避免这种错误。

3158
05:31:31.470 --> 05:31:34.567
然后它继续播放正在播放的节目。

3159
05:31:34.567 --> 05:31:38.439
这个错误很清楚，这个错误代码很清楚。

3160
05:31:38.439 --> 05:31:48.443
它说，嘿，让函数可支付，或者使用内部函数来避免这个错误，对吧?这应该很容易添加payable，然后重新编译就可以了。

3161
05:31:48.443 --> 05:31:51.810
这实际上是一个很好的例子当你遇到错误时该怎么做。

3162
05:31:51.810 --> 05:31:52.616
当你遇到错误的时候。

3163
05:31:52.616 --> 05:31:59.424
你要做的第一件事是你要试着根据错误信息找出到底发生了什么。

3164
05:31:59.424 --> 05:32:13.865
这个很直接，但有些可能会比较模糊第一步是当你试图解除阻塞试图自己修补和找出错误时，对吧?因为你可能会说好吧，我会把它变成可支付的，对吧?然后你去存钱。

3165
05:32:13.865 --> 05:32:18.182
然后它给出一个不同的错误说，嘿，你知道，应付的不在这里。

3166
05:32:18.182 --> 05:32:22.976
你重新保存，重新编译，它会说，嘿，我们仍然缺少那个应付的东西。

3167
05:32:22.976 --> 05:32:26.737
第一步总是要试着自己修补和弄清楚。

3168
05:32:26.737 --> 05:32:38.100
对于这门课，我希望你们限制修补，将分类缩减到20分钟，如果你修补和分类的时间超过20分钟，那就进入下一步。

3169
05:32:38.100 --> 05:32:50.149
但我也希望你自己至少花15分钟，或者100%肯定，你用尽了所有的选择，你完全没有主意了。

3170
05:32:50.149 --> 05:32:53.599
所以一般来说，试着用15分钟来修补一些东西。

3171
05:32:53.599 --> 05:33:01.392
如果你在15分钟之内，你说，嘿，我百分百确定我已经尝试了我能想到的所有方法，然后你就可以进入下一步了。

3172
05:33:01.392 --> 05:33:10.280
第一步，当你遇到错误的时候你总是要做修补者，试着找出到底发生了什么。

3173
05:33:10.280 --> 05:33:12.949
试着找出到底哪里出了问题。

3174
05:33:12.949 --> 05:33:19.516
第二步，假设你修补了所有地方，都尝试了应付，你不知道这个错误是什么，也不知道如何调试。

3175
05:33:19.516 --> 05:33:25.650
第二步总是谷歌精确的误差看你能不能从中学到东西。

3176
05:33:25.650 --> 05:33:43.463
缩小一点，我把鼠标移到上面，抓取它，复制它，或者引号周围，在谷歌中搜索准确的错误花点时间浏览谷歌，Stack Overflow, Stack Exchange eath，看看是否有人已经问过这个问题。

3177
05:33:43.463 --> 05:33:49.820
下面这里看起来像是有人输入错误，错过了一个值，调用虽然只能在贝宝公共函数上使用。

3178
05:33:49.820 --> 05:33:53.996
如果我们向下滚动，我们会看到有人正好碰到了这个。

3179
05:33:53.996 --> 05:33:55.589
他们继续解决了这个问题。

3180
05:33:55.589 --> 05:33:59.911
他们说，我意识到我的错误，我需要添加PayPal关键字到我自己的实现。

3181
05:33:59.911 --> 05:34:02.996
题目继续，他们加了应付账款。

3182
05:34:02.996 --> 05:34:06.350
希望这能给你启发说，啊，好，很好。

3183
05:34:06.350 --> 05:34:08.596
我需要回到这里，加上应付账款。

3184
05:34:08.596 --> 05:34:11.555
假设这个StackOverflow问题没有出现。

3185
05:34:11.555 --> 05:34:13.080
对吧?这个论坛不在这里。

3186
05:34:13.080 --> 05:34:15.837
接下来我们做什么?第一步，修补匠。

3187
05:34:15.837 --> 05:34:21.167
第二步，准确的误差，我要做第二步。

3188
05:34:21.167 --> 05:34:36.450
这门课的唯一内容是，去GitHub上的回购讨论，或者这门课的更新，具体来说，去GitHub上的回购，完整的区块链固体性课程，Jas，当你们接触它的时候，它看起来会有点不同。

3189
05:34:36.450 --> 05:34:43.771
但是看看这个回购，看看这个按时间顺序更新的部分，看看你正在做的部分是否有更新。

3190
05:34:43.771 --> 05:34:46.762
显然，因为我现在在录音，所以没有更新。

3191
05:34:46.762 --> 05:34:50.958
如果你没有得到任何答案，请随时进入讨论区。

3192
05:34:50.958 --> 05:34:57.717
在这里问一个问题，对吧，这里会有一个社区的人互相帮助，希望让这变得很有趣。

3193
05:34:57.717 --> 05:34:59.088
我之所以说2。

3194
05:34:59.088 --> 05:35:08.215
5是因为在现实世界中，你不会用到我们的GitHub回购，在这门课以外的课程中，你不会用到这个GitHub回购。

3195
05:35:08.215 --> 05:35:15.707
所以，在现实世界中，我仍然会给你钥匙，我会给你在任何事情上都能解除障碍的东西。

3196
05:35:15.707 --> 05:35:16.024
好的。

3197
05:35:16.024 --> 05:35:26.312
第三位将在论坛上被问到一个问题，比如stack, exchange eath和stack Overflow。

3198
05:35:26.312 --> 05:35:36.151
Stack Overflow是一个像这样的问答技术论坛，对吧?你可以问技术问题，然后你也可以回答它们。

3199
05:35:36.151 --> 05:36:02.942
如你所见，当你搜索这些问题时，它们会显示出来所以Stack Overflow更多是针对一般的角色编程问题Stack Exchange Aetherium或Stack Exchange eath Aetherium Stack Exchange，这是针对更多的基于Aetherium或EVM的问题以及所有我们要处理的固体性代码，无论是多边形，还是雪崩，无论什么，这些问题在这里都是有效的，你可以在这里提问。

3200
05:36:02.942 --> 05:36:14.915
所以你要做的就是注册或登录，在这些表单上提问并格式化你的问题，你要注册GitHub，你要注册Stack Exchange，你要注册Stack Overflow，这样你就可以参与这些论坛。

3201
05:36:14.915 --> 05:36:18.138
事实上，如果你还没有，让我们现在就注册GitHub。

3202
05:36:18.138 --> 05:36:25.431
让我来给你们介绍一下这些问题的格式，因为你的问题格式越好，你得到答案的机会就越大。

3203
05:36:25.431 --> 05:36:41.513
记住，当在这些论坛上提问时，当在这些讨论社区中提问时，人们回答这些问题是出于他们的善意，对吗?所以如果你没有得到回复，很有可能没有人知道，也许是你的问题格式不太好，等等。

3204
05:36:41.513 --> 05:36:44.439
所以我们将学习如何提出真正的好问题。

3205
05:36:44.439 --> 05:36:47.268
如果你是区块链的新手，不要跳过这部分。

3206
05:36:47.268 --> 05:36:53.089
好了，这就是那件能给你超能力的东西让你从任何遇到的编码问题中解脱出来。

3207
05:36:53.089 --> 05:36:54.582
所以不要跳过这个升级。

3208
05:36:54.582 --> 05:36:55.891
一定要跟着做。

3209
05:36:55.891 --> 05:36:56.163
好的。

3210
05:36:56.163 --> 05:37:00.007
所以，如果你还没有一个GitHub，你确实需要一封电子邮件开始。

3211
05:37:00.007 --> 05:37:03.668
我要登录了，我为这个视频创建了一个一次性账户。

3212
05:37:03.668 --> 05:37:18.371
我们要做的是，注册GitHub，输入你的邮箱，点击创建账号，他们会给我们发邮件。

3213
05:37:18.371 --> 05:37:23.096
回到我们的电子邮件，我们有发射代码，把它粘贴进来。

3214
05:37:23.096 --> 05:37:26.577
这是一些信息。

3215
05:37:26.577 --> 05:37:31.452
我们将选择免费版本。

3216
05:37:31.452 --> 05:37:32.630
和美妙的。

3217
05:37:32.630 --> 05:37:34.296
现在我们已经创建了一个GitHub配置文件。

3218
05:37:34.296 --> 05:37:45.833
现在回到智能合约孩子完整区块链的课程，Jas，我将创建一个新的讨论，一个新的线程，我希望你们都在上面评论，以确保你们理解如何格式化和如何提问。

3219
05:37:45.833 --> 05:37:48.125
好了，练习的主线。

3220
05:37:48.125 --> 05:37:49.971
格式的问题。

3221
05:37:49.971 --> 05:37:50.432
哦。

3222
05:37:50.432 --> 05:37:52.832
我们回到这里。

3223
05:37:53.202 --> 05:37:59.788
首先，我要把这个问题用两种方式来表达，然后我们要把它表达得非常非常好。

3224
05:37:59.788 --> 05:38:04.443
第一种格式不好的方式，就是没有提供足够的信息。

3225
05:38:04.443 --> 05:38:17.468
我们要做的是复制这一期我们要做的是我们会说，嘿，我在混音方面遇到了麻烦，出现了错误。

3226
05:38:17.468 --> 05:38:29.540
有人能帮帮我吗?为什么这不是一个很好的格式问题?如果这是我的问题，这里没有足够的信息，我，作为一个帮手，不知道这个人在问什么。

3227
05:38:29.540 --> 05:38:31.105
我们来做点别的。

3228
05:38:31.105 --> 05:38:42.781
我要做的是复制整个合同所有的乐趣，读取大底，粘贴到这里，然后说，嗨，我这里有问题。

3229
05:38:42.781 --> 05:38:50.218
有人能帮忙吗?我要在这里开始讨论点击开始讨论，它的格式很奇怪。

3230
05:38:50.218 --> 05:38:53.235
再说一次，这里没有足够的信息。

3231
05:38:53.235 --> 05:38:55.235
我不知道是什么问题。

3232
05:38:55.235 --> 05:38:58.703
但至少对于这个，我们有一些代码，我们有一些方法来进行调试。

3233
05:38:58.703 --> 05:38:59.810
这就好一点了。

3234
05:38:59.810 --> 05:39:01.185
但还是没有那么好。

3235
05:39:01.185 --> 05:39:02.685
我们来编辑这个。

3236
05:39:02.685 --> 05:39:03.989
为了让它变得更好。

3237
05:39:03.989 --> 05:39:16.515
点击三点，点击编辑，我们能做的就是使用Markdown语法，强烈建议大家学习一点Markdown语法，这基本上是一些语法帮助我们在GitHub上进行讨论。

3238
05:39:16.515 --> 05:39:20.949
另外，Stack Overflow和Stack Exchange的问题也简单多了。

3239
05:39:20.949 --> 05:39:30.203
所以我们要格式化这段代码通过在开头加上这三个反勾，然后在代码末尾也加。

3240
05:39:30.203 --> 05:39:41.703
另外，接下来，前三个反勾，我们要输入所以lid did T它告诉格式或者用固体度来格式化这里的代码。

3241
05:39:41.703 --> 05:39:46.944
现在如果我们更新讨论，我们会注意到这里有一些很好的突出显示。

3242
05:39:46.944 --> 05:39:50.091
这样就更容易理解了。

3243
05:39:50.091 --> 05:39:54.055
对吧?这比以前更容易读了。

3244
05:39:54.055 --> 05:39:56.677
然而，它仍然不够具体。

3245
05:39:56.677 --> 05:40:00.530
我们已经给出了大量的代码，但我们还没有给出具体的答案。

3246
05:40:00.530 --> 05:40:03.503
所以这个问题很难回答。

3247
05:40:03.503 --> 05:40:05.153
让我们说得更具体一些。

3248
05:40:05.153 --> 05:40:07.240
让我们再来编辑一下这个问题。

3249
05:40:07.240 --> 05:40:13.423
我们来具体说明一下，看这里，我们的问题是关于这个函数的。

3250
05:40:13.423 --> 05:40:19.140
我们要复制这个函数然后删除这里的所有东西。

3251
05:40:19.203 --> 05:40:22.106
现在我们有了这段代码。

3252
05:40:23.204 --> 05:40:24.677
让它变得更具体。

3253
05:40:26.204 --> 05:40:29.026
函数，我遇到了一个错误。

3254
05:40:31.204 --> 05:40:33.833
我们要做的是回到这里，我们要把它翻转过来。

3255
05:40:33.833 --> 05:40:39.156
我们要复制这个如果想的话，我们可以提取代码但是我们要把这个错误格式化成这样。

3256
05:40:39.204 --> 05:40:48.588
然后我们会说谁能告诉我这是怎么回事?更新?这是一个非常非常容易调试的问题。

3257
05:40:48.588 --> 05:40:52.695
对吧?我们有一些极简的代码，我们有我们得到的错误。

3258
05:40:52.695 --> 05:41:00.139
谁能告诉我这是怎么回事?很明显，这个问题的答案是加上应付。

3259
05:41:00.204 --> 05:41:09.089
有人可能会说，嘿，比如，你需要在这里加上应付，我希望你们都练习一下如何格式化，用你们自己的格式化问题对它进行评论。

3260
05:41:09.089 --> 05:41:12.027
这样你们就能理解如何进行格式化。

3261
05:41:12.027 --> 05:41:13.497
还有这个减记格式。

3262
05:41:13.497 --> 05:41:26.113
就是这种格式，这门课在Stack Overflow或Stack Exchange上提问时也是一样的，继续练习，如果你想创建更多的讨论，请随意创建新的讨论。

3263
05:41:26.113 --> 05:41:37.135
如果你想用Stack Overflow或Stack Exchange eath强烈推荐你也用Stack Overflow或Stack Exchange eath，因为它们的索引比GitHub好得多。

3264
05:41:37.204 --> 05:41:39.928
当然，大家也可以在这个GitHub里随意提问。

3265
05:41:39.928 --> 05:41:48.937
现在我已经给了你们一些基本的纲要，我们将观看一个我制作的视频，它将更深入地讲解为什么以及如何格式化所有这些问题以及使用什么。

3266
05:41:48.937 --> 05:41:52.537
我们来看一下。

3267
05:41:52.537 --> 05:41:58.203
每个开发者都遇到过这种情况。

3268
05:41:58.203 --> 05:42:02.505
有东西坏了，或者你不知道什么，但你没有时间让这些阻止你。

3269
05:42:02.505 --> 05:42:16.174
人们应该采取一系列步骤来最大化解决任何编码问题的机会，但你会惊讶地发现，目前很少有开发人员有效地使用这个超级功能，我们在第一个方面花的时间最少，因为它只是修补和实验。

3270
05:42:16.205 --> 05:42:17.505
当你遇到问题的时候。

3271
05:42:19.205 --> 05:42:25.825
想想可能会有用，也许可以尝试在整个文件中打印语句，学习一些调试技巧，但不要太骄傲，只做了第一步。

3272
05:42:25.825 --> 05:42:28.786
这不应该是随便乱跑。

3273
05:42:28.786 --> 05:42:36.626
这应该是试图准确指出代码中哪里出了问题，这样您就可以提出一个有效的问题，或者自己找出问题所在。

3274
05:42:36.626 --> 05:42:40.882
所以要准确地指出哪里出了问题，因为在接下来的步骤中您将需要它。

3275
05:42:40.882 --> 05:42:43.117
不管怎样，接下来，检查文档。

3276
05:42:43.117 --> 05:42:45.783
不是所有的工具都有很好的文档。

3277
05:42:45.783 --> 05:42:53.677
但是花点时间浏览文档是找到答案的快速方法，你会想要学习如何用Command F或Control F搜索网页。

3278
05:42:53.677 --> 05:42:59.549
这样，你就可以在页面上查找特定的关键词，或者希望他们有一个很好的搜索栏。

3279
05:42:59.549 --> 05:43:01.598
有时文档可能非常密集。

3280
05:43:01.598 --> 05:43:04.169
所以也许你会进入下一步，那就是做一个网络搜索。

3281
05:43:04.169 --> 05:43:08.696
在一天结束的时候，好的软件工程师私下里只是专业的谷歌人。

3282
05:43:08.696 --> 05:43:16.756
这是他们最强大的工具之一，能够在网上搜索已经遇到过你刚刚遇到的问题的人，然后解决它。

3283
05:43:16.756 --> 05:43:22.170
大多数像谷歌这样的搜索引擎都有一些工具，你可以使用这些工具来更具体地了解你要找的东西。

3284
05:43:22.170 --> 05:43:31.747
通常对于特定的错误，最好的做法是复制准确的错误，并将其与引号粘贴到搜索栏中，或者在位置上使用Asterix，你的错误可能太具体了。

3285
05:43:31.747 --> 05:43:39.057
你将从论坛和问答网站中获得大部分的结果，这将引导我们进入下一步，在这些论坛和问答网站中提问。

3286
05:43:39.057 --> 05:43:45.831
只要确保在你提问之前，你已经在谷歌上做了充足的搜索。

3287
05:43:45.831 --> 05:43:48.784
这样你就不会浪费自己和别人的时间。

3288
05:43:48.784 --> 05:43:56.529
通过问问题，你发誓你会向我保证，在某个时刻，你会回去帮助其他人学习，也很好。

3289
05:43:56.529 --> 05:44:02.006
在问问题之前，我们应该知道哪里是最好的提问地点。

3290
05:44:02.006 --> 05:44:08.837
这就是为什么我将不同类型的论坛和QA网站进行分类，请随时暂停阅读。

3291
05:44:08.837 --> 05:44:28.144
这里有一些具体的例子，这些索引代码基础形式，如Stack Overflow，索引仓库，如GitHub问题，索引技术，特定的论坛，如我们的slash eat dev或未索引的讨论平台，如chainlink discord，这些类别的关键区别之一是索引关键字。

3292
05:44:28.206 --> 05:44:35.140
我们通常希望在论坛上问问题，网络爬虫已经通过，并将他们插入他们的数据库或以这种方式索引他们。

3293
05:44:35.140 --> 05:44:41.156
三周后，当我们回头看我们写的代码时，当我们忘记它是做什么的时候，我们可以不知道发生了什么。

3294
05:44:41.156 --> 05:44:47.583
这将帮助其他遇到相同问题的开发人员，反过来，他们可能会在后面帮助您解决问题。

3295
05:44:47.583 --> 05:44:53.706
理想情况下，您的大多数问题都应该在这些索引表单中提出，因为它们具有可搜索性和可发现性。

3296
05:44:53.706 --> 05:45:07.175
然而，有些问题更适合DMS, Twitter或discord，它们不是索引，我们在这里做了一个小图表，找出张贴你的问题的最佳位置，请随意暂停视频看一看或阅读我们的博客和描述的图片以及另一个看它。

3297
05:45:07.206 --> 05:45:15.013
当然，在这些论坛发布之前，一定要阅读他们的规则，因为他们可能会声明某些问题是专门为本准备的。

3298
05:45:15.013 --> 05:45:17.991
但基本上分解是这样的。

3299
05:45:17.991 --> 05:45:45.391
理论的大方向或观点的问题可以在一般的问答论坛，如Quora或特定的技术论坛，如特定的reddits或discord论坛，具体的编码问题也可以在这些论坛，但通常会得到更多的关注在编码论坛，如Stack Overflow或Stack Exchange社区，通常的问题是，哦，我应该把这张贴在堆栈URL?flow或者Stack Exchange社区是非常模糊的。

3300
05:45:45.391 --> 05:45:47.340
有时候你在哪个网站上发帖并不重要。

3301
05:45:47.340 --> 05:46:00.153
现在，如果您在非常熟悉的技术上遇到bug或问题，并且您认为它不应该出现故障，那么这就是您将问题放入他们的开放源代码存储库并可能改进工具的机会。

3302
05:46:00.207 --> 05:46:08.514
他们没有开放源代码库，你把封闭源代码扔进垃圾桶，但开玩笑的是，封闭源代码技术在我们的生活中也有一席之地。

3303
05:46:08.514 --> 05:46:18.016
此外，如果你正在学习一个教程，他们有一个Git回购与它相关联，就像我所有的视频一样，这将是最好的地方留下你的问题。

3304
05:46:18.016 --> 05:46:27.592
所以尽管我很讨厌这么说，但把你的问题放到我的GitHub知识库中比把它放在YouTube评论中更有效地回答你的问题。

3305
05:46:27.592 --> 05:46:37.239
现在，最后，Discord，元素，电子邮件，短信或任何其他这些未被索引的聊天仍然是问问题的好地方，但请尝试使用它们作为最后的手段。

3306
05:46:37.239 --> 05:46:53.457
如果他们确实回答了你的一个问题，也许回去把这个问题和答案添加到我们刚才讨论过的其他论坛中，下次你或别人的时候它就会被索引，现在这些更快的聊天论坛更适合社区聚集和彼此进行快速对话。

3307
05:46:53.457 --> 05:47:01.600
它们是理论工艺，讨论新事物的地方新想法，事件和其他不应该被网络爬虫索引的东西。

3308
05:47:01.600 --> 05:47:10.333
它们也是与人见面和交流的好地方，你可以在彼此了解的过程中直接交流想法，这就引出了我们的最后一部分。

3309
05:47:10.333 --> 05:47:17.558
但在那之前，你听到了吗?这是另一个视频警报里的视频。

3310
05:47:17.558 --> 05:47:24.096
当你在这些论坛中提问时，你的问题格式越好，你得到答案的机会就越大。

3311
05:47:24.096 --> 05:47:26.127
现在没有不好的问题了。

3312
05:47:26.127 --> 05:47:28.110
但有些问题格式很糟糕。

3313
05:47:28.208 --> 05:47:35.072
所以，让我们来教大家如何尽可能以最好的格式提问，这样你就有最大的机会确保问题得到回答。

3314
05:47:35.072 --> 05:47:39.962
第一，在问问题之前，确保你遵循了家长视频中的所有步骤。

3315
05:47:39.962 --> 05:47:44.908
你们已经对此做了一些研究确保这个问题还没有被问过。

3316
05:47:44.908 --> 05:47:58.386
第二，做一个标题总结问题的细节第三，在你写任何代码之前介绍问题，添加极简的，可复制的代码极简的代码意味着它不只是复制粘贴你的整个文件。

3317
05:47:58.386 --> 05:48:11.303
如果你在某一行上有问题，也许就发布这一行可复制的代码，这意味着其他人应该能够运行与你遇到的完全相同的错误，或者至少发布他们这样做的步骤。

3318
05:48:11.303 --> 05:48:18.949
这并不意味着你应该把我跟着Patrick的视频，在我们5点的时候，我遇到了这个问题，只要看他的视频，你就会明白。

3319
05:48:18.949 --> 05:48:27.953
虽然这很让人高兴但并不是所有人都看了我的视频，尽管他们应该你想要给出达到你所达到的误差的技术步骤。

3320
05:48:27.953 --> 05:48:39.896
对于那些观看我的免费代码营视频的人来说，你可以不受此影响，但你只能说，嘿，我在与这门课程相关的GitHub回购的讨论选项卡中对你视频的这部分内容进行了讨论。

3321
05:48:39.896 --> 05:48:41.083
你可以这样做。

3322
05:48:41.209 --> 05:48:51.646
但只有在与本课程相关的GitHub回购中，学习标记来格式化你的代码，特别是使用这三个反引号和标记语言。

3323
05:48:51.646 --> 05:48:58.471
这是格式化代码的关键部分，将大大提高回答您问题的人数。

3324
05:48:58.471 --> 05:49:02.886
任何错误或代码都应该使用这三个反引号语法进行格式化。

3325
05:49:02.886 --> 05:49:11.831
最后，通常那些关注某些技术的人，会关注特定的标签和他们喜欢的技术被问到的特定问题。

3326
05:49:11.831 --> 05:49:19.612
最后，再次强调，在发帖之前一定要阅读论坛的指南，不同的论坛对他们想要什么和不想要什么有不同的规定。

3327
05:49:19.612 --> 05:49:22.945
所以熟悉会增加你得到答案的机会。

3328
05:49:22.945 --> 05:49:23.471
好吧。

3329
05:49:23.471 --> 05:49:24.838
现在回到主视频。

3330
05:49:24.838 --> 05:49:34.780
现在有一个关于Stack Overflow的注意事项，Stack Overflow可能有点咄咄逼人，这就是为什么有时候在特定的社区论坛上发帖可能对你的特定技术问题更好。

3331
05:49:34.780 --> 05:49:38.630
如果你在Stack Overflow上发帖，你的问题会得到大量的支持票。

3332
05:49:38.630 --> 05:49:39.848
别让这个困扰你。

3333
05:49:39.848 --> 05:49:48.142
就把它当作一个学习的机会，去了解Stack Overflow喜欢什么，不喜欢什么，然后继续前进，但不要因此而气馁。

3334
05:49:48.209 --> 05:49:54.726
好了，现在我们知道东西应该放在哪里，问题应该放在哪里以及如何编排它们。

3335
05:49:54.726 --> 05:49:57.342
让我们练习让我们看一些你们可能会有的例题。

3336
05:49:57.342 --> 05:49:58.908
我们会想办法把它们放在哪里。

3337
05:49:58.908 --> 05:50:02.609
第一个呢，这个呢?你也可以暂停一下自己猜一猜。

3338
05:50:02.609 --> 05:50:08.243
所以像这样的问题对Reddit或不和会很好吗?更可能是不和。

3339
05:50:08.243 --> 05:50:11.446
这绝对是你可以搜索的东西。

3340
05:50:11.446 --> 05:50:15.362
对吧?所以你也许可以搜索这个，找到一个答案，然后从那里开始。

3341
05:50:15.362 --> 05:50:19.735
但也许你想问一个朋友或者你想问一个非常特定的社区，比如我们的slash eat Dev。

3342
05:50:19.735 --> 05:50:24.460
当然，如果你看到这个问题，你肯定想推荐帕特里克·柯林斯的YouTube频道。

3343
05:50:24.460 --> 05:50:25.906
那么这个问题呢?

3344
05:50:25.906 --> 05:50:29.151
注意到它的格式了吧?标题又大又漂亮。

3345
05:50:29.151 --> 05:50:32.820
它们有一个格式化正确的技术命令。

3346
05:50:32.820 --> 05:50:43.548
他们有Git提交，它的格式是正确的，它会去哪里，这肯定会在Stack Overflow或基于索引代码的论坛上做得很好，很明显，尝试做一些技术上的事情。

3347
05:50:43.548 --> 05:50:45.410
问题已经说得很清楚了。

3348
05:50:45.410 --> 05:50:48.226
他们已经给出了他们想要做的命令。

3349
05:50:48.226 --> 05:50:51.531
那么这个呢，像这样的东西可以在StackOverflow上。

3350
05:50:51.531 --> 05:50:56.701
但它可能更有可能在GitHub的问题上为这个布朗尼包。

3351
05:50:56.701 --> 05:51:08.064
代码论坛和GitHub这样的Git回购之间的一个很大的区别是，当你在GitHub存储库上提出一个问题时，特别是当你认为有问题时，你确实希望尽可能深入。

3352
05:51:08.064 --> 05:51:19.114
所以，当你对回购提出问题时，他们甚至会问，你用的是什么版本?你能发布所有的代码吗?你能把你所有的文件都发布出来，而且要明确得多吗?那么像这样的东西怎么样。

3353
05:51:19.114 --> 05:51:27.599
这对于与本教程相关的GitHub回购非常有用，看起来这个人在询问一个非常特定的教程。

3354
05:51:27.599 --> 05:51:30.242
所以发布这个，就会有最好的。

3355
05:51:30.242 --> 05:51:35.505
如果你的问题是关于一个没有GitHub回购的教程，那么，他们可能应该这样做。

3356
05:51:35.505 --> 05:51:38.111
但也许在评论区留言会更好。

3357
05:51:38.210 --> 05:51:50.262
现在，再一次，这是这一切变得更像艺术而不是科学的地方，因为也许他们遇到的特定错误是很多人遇到的通用错误，也许在StackOverflow上更好。

3358
05:51:50.262 --> 05:51:52.822
或者是包装有问题。

3359
05:51:52.822 --> 05:51:54.886
所以也许在GitHub上更好。

3360
05:51:54.886 --> 05:51:57.260
或许解决这个问题的方法是固执己见的。

3361
05:51:57.260 --> 05:52:02.443
最后，这个呢?是的，这将是更好的不和或DM与你的朋友。

3362
05:52:02.443 --> 05:52:08.030
另外，我们阻止你回答任何问题的最后一步就是加入并加强你的工具的社区。

3363
05:52:08.030 --> 05:52:12.372
刚开始的时候，你们很难给出答案因为你们对这些工具不是很了解。

3364
05:52:12.372 --> 05:52:17.146
但当你在这些技术上做得更好的时候，你会想要尝试回答一些出现的新问题。

3365
05:52:17.146 --> 05:52:31.372
原因是，这将给你一个机会真正了解更多关于你喜欢的工具，它将加强你最喜欢的工具的社区，这意味着如果你帮助回答关于工具的问题，它实际上会鼓励其他人使用该工具，因为那里有很多追随者。

3366
05:52:31.372 --> 05:52:36.421
很有可能，他们在未来的某个时候真的会帮助你，你帮助别人会让你看起来像一个好人。

3367
05:52:36.421 --> 05:52:38.822
然后你也会觉得自己是个好人。

3368
05:52:38.822 --> 05:53:01.192
此外，在许多像Reddit这样的论坛中，通常mods会查看你发帖的频率与你帮助他人的频率以及对他人发帖的评论频率，一些mods可能会开始阻止你的帖子，因为你滥用论坛，不回馈社区，只尝试获取知识，如果你加入并帮助他人，而不是试图从他人那里榨取东西，你在社区中会更成功。

3369
05:53:01.192 --> 05:53:09.143
此外，通过与社区的接触，我无法告诉你我遇到了多少人，我学到了很多东西，并能够与他们一起进行头脑风暴。

3370
05:53:09.211 --> 05:53:11.456
最后一步是迭代这些步骤。

3371
05:53:11.456 --> 05:53:18.820
也许当你做完这些的时候，你会说，哦，我还是很困惑，但你可能会变得更有知识。

3372
05:53:18.820 --> 05:53:21.116
所以你想回去再试一遍这些步骤。

3373
05:53:21.211 --> 05:53:24.853
这就是整个过程更像是艺术而不是科学的地方。

3374
05:53:24.853 --> 05:53:27.922
因为有些问题可能还没有被发现。

3375
05:53:27.922 --> 05:53:34.372
只有很少的人知道，没有足够的人理解问题的重要性，或者人们不理解你的问题。

3376
05:53:34.372 --> 05:53:37.761
这就是为什么回过头来重复这些步骤很重要。

3377
05:53:37.761 --> 05:53:48.012
现在你们已经具备了这种不可思议的超能力的基本组成部分，我鼓励你们所有人走出去，尝试一下，然后告诉我进展如何。

3378
05:53:48.212 --> 05:53:49.025
好的,太棒了。

3379
05:53:51.212 --> 05:53:52.505
畅通无阻，我们可以继续前进。

3380
05:53:54.212 --> 05:53:59.434
学习如何解除封锁是因为区块链和web 3不仅仅是每个人自己的。

3381
05:53:59.434 --> 05:54:01.500
这是一个非常合作的空间。

3382
05:54:01.500 --> 05:54:13.605
所以，当你变得更好，当你学到更多，一个测试你学到了多少并回馈社区的重要方法就是去Stack Overflow，去堆栈交换，试着自己回答一些问题。

3383
05:54:13.605 --> 05:54:26.832
所以我强烈建议你们去Stack Overflow，然后去与分数相关的GitHub回购，你们试着回答一些讨论，试着回答一些问题并帮助其他人因为这将帮助你们成为一个更好的软件工程师。

3384
05:54:26.832 --> 05:54:36.597
我想讲这部分的另一个原因是当我们安装我将要展示给你们的一些工具时，有时安装过程是最难的部分。

3385
05:54:36.597 --> 05:54:40.962
一旦您通过了安装过程，它通常会变得非常非常容易。

3386
05:54:40.962 --> 05:54:47.162
但这通常是课程中最难的部分安装我们会给你们的这些工具。

3387
05:54:47.212 --> 05:54:49.856
这就是我们现在要学习的内容。

3388
05:54:50.212 --> 05:54:55.381
到目前为止，一直在使用混搭、混搭IDE或集成开发环境。

3389
05:54:55.381 --> 05:55:02.862
正如我们所见，这是一个很好的地方，在这里我们可以尝试代码，我们可以尝试稳定性，我们可以编译，我们可以部署，我们几乎可以做所有我们需要做的事情。

3390
05:55:02.862 --> 05:55:03.612
它是基于网络的。

3391
05:55:03.612 --> 05:55:11.022
它可以进行测试，调试，部署本地JavaScript虚拟机，它非常快速和容易地创建和测试我们的智能合约。

3392
05:55:11.022 --> 05:55:12.986
然而，它也有一些局限性。

3393
05:55:12.986 --> 05:55:17.824
它实际上只能处理智能合约，不能真正与项目的其他部分集成。

3394
05:55:17.824 --> 05:55:20.524
它对测试或自定义部署的支持有限。

3395
05:55:20.524 --> 05:55:27.634
你甚至需要一个网络连接来处理混音，做很多更高级的功能可能是棘手的。

3396
05:55:27.634 --> 05:55:39.213
这是一个了不起的工具如果你想快速地做一些事情，我绝对建议大家去remix去尝试一下现在我们要转到更专业的智能合约开发者设置。

3397
05:55:39.213 --> 05:55:40.946
这是戴着安全帽的。

3398
05:55:40.946 --> 05:55:48.900
这被称为智能合约开发人员框架，类似于brownie或foundry或类似的框架，有很多这样的框架。

3399
05:55:48.900 --> 05:55:52.570
我们之所以使用硬帽是因为硬帽是基于JavaScript的。

3400
05:55:52.570 --> 05:55:55.728
它是一个基于JavaScript的开发环境。

3401
05:55:55.728 --> 05:56:00.114
它有基于JavaScript的编译，环境，部署，测试，调试。

3402
05:56:00.114 --> 05:56:08.340
现在，对于那些喜欢TypeScript的人，我们也将为你提供每一个代码示例的TypeScript版本。

3403
05:56:08.340 --> 05:56:16.149
如果你喜欢JavaScript，我们有你，如果你喜欢TypeScript，我们也有你我们不会一直讲TypeScript。

3404
05:56:16.213 --> 05:56:22.141
但我们有时会这样做，TypeScript的所有代码将在GitHub回购中可用。

3405
05:56:22.141 --> 05:56:26.166
现在，在我们真正学习硬帽之前，我们必须先学习另一个软件包。

3406
05:56:26.213 --> 05:56:29.825
我们要学习如何处理所有关于醚的东西。

3407
05:56:30.213 --> 05:56:33.655
这是一个基于JavaScript的智能合约库。

3408
05:56:33.655 --> 05:56:39.498
这也是下一个我们将要使用的工具的动力所在，也就是“硬帽下的硬帽”。

3409
05:56:39.498 --> 05:56:40.498
有很多醚，Jas。

3410
05:56:40.498 --> 05:56:45.937
所以对我们来说，了解醚Jas是很重要的，这样我们就能理解硬帽的作用。

3411
05:56:45.937 --> 05:56:50.832
在接下来的课程中，我将使用一个叫做Visual Studio code的代码编辑器。

3412
05:56:50.832 --> 05:56:53.825
这是地球上最强大的代码编辑器之一。

3413
05:56:53.825 --> 05:56:57.641
如果你已经设置好了，可以直接跳过这部分。

3414
05:56:57.641 --> 05:57:05.158
如果您已经有了一个专业的编码设置，没有GS和VS代码，没有Git和其他东西，可以随意使用GitHub存储库中的时间戳。

3415
05:57:05.158 --> 05:57:07.214
要跳过此设置部分。

3416
05:57:07.214 --> 05:57:13.438
你会经常听到人们把它称为VS code，或者Visual Studio code，或者仅仅是Visual Studio。

3417
05:57:13.438 --> 05:57:21.938
然而，需要注意的是，Visual Studio代码与Visual Studio不同，你可能看到的是这样的。

3418
05:57:21.938 --> 05:57:30.414
Visual Studio代码是你想要的，而不是Visual Studio, Visual Studio是一个不同的应用程序，确保你用的是Visual Studio代码。

3419
05:57:30.414 --> 05:57:42.118
现在，如果你选择这样做，你完全是一个Harto，你完全可以只使用你的终端，或只使用PowerShell，或只使用任何你想要的编码环境，比如atom或Sublime。

3420
05:57:42.118 --> 05:57:45.886
然而，对于我们来说，我们将使用Visual Studio代码。

3421
05:57:45.886 --> 05:57:54.935
我会用我喜欢的方式来设置Visual Studio代码，你可以用你觉得舒服的方式来设置。

3422
05:57:54.935 --> 05:57:59.642
当然，在我们的第六课中，我们有一个安装和设置的链接。

3423
05:57:59.642 --> 05:58:02.464
我会在这里添加更多的链接。

3424
05:58:02.464 --> 05:58:09.117
再说一次，我们要用到的所有代码都在下面这个GitHub存储库中这里写着代码。

3425
05:58:09.117 --> 05:58:14.459
现在我们将经历三个不同的安装过程，并选择一个最适合你的。

3426
05:58:14.459 --> 05:58:17.935
第一个是针对Mac和Linux用户的。

3427
05:58:17.935 --> 05:58:21.082
第二个是为Windows用户准备的。

3428
05:58:21.214 --> 05:58:24.017
然后我们的第三个将是最后的努力。

3429
05:58:24.214 --> 05:58:31.804
不管什么原因，你不能让Windows或Linux或Mac指令工作，我们将使用Git pod安装。

3430
05:58:31.804 --> 05:58:37.568
现在，我强烈建议你尝试让所有东西都在本地工作，而不使用Git pod。

3431
05:58:37.568 --> 05:58:47.133
然而，如果出于某种原因，您无法让这些安装部件工作，我们将为我们在这里使用的所有回购使用Git pod指令。

3432
05:58:47.133 --> 05:58:54.092
但是在开始之前，我们将从Mac和Linux的安装说明开始。

3433
05:58:54.215 --> 05:59:02.215
你要做的第一件事是下载Mac或者如果你用的是Linux，下载Visual Studio代码的Linux安装。

3434
05:59:02.215 --> 05:59:05.919
一旦你把它安装好，它看起来就会像这样。

3435
05:59:05.919 --> 05:59:11.548
如果它是一个新安装，它甚至会给你一些提示和工具，让你真正开始。

3436
05:59:11.548 --> 05:59:21.148
如果你以前从未使用过Visual Studio代码，我强烈建议你阅读一下打开Visual Studio代码时附带的入门或指导提示。

3437
05:59:21.215 --> 05:59:27.133
此外，我们有一个Visual Studio Code速成课程在GitHub回购与本课程相关联。

3438
05:59:27.133 --> 05:59:32.834
一旦你安装了Visual Studio代码，接下来我们要安装的是节点j s。

3439
05:59:32.834 --> 05:59:43.599
同样的，我们在GitHub上有所有这些课程的链接，你可以直接点击Mac OS下载或者Linux下载，我推荐使用LTS版本。

3440
05:59:43.599 --> 05:59:50.040
LTS代表长期支持，这意味着他们将长期支持这个版本。

3441
05:59:50.040 --> 05:59:52.659
所以去下载Node js吧。

3442
05:59:52.659 --> 06:00:14.147
我已经下载了这个，所以我不打算再重新下载了Visual Studio代码的一个很棒的地方是它有一个叫做终端的东西，它是命令行提示符，允许我们运行脚本，基本上，这是我们将运行所有代码的地方我们可以打开终端我们可以点击终端，选择新终端你会得到这样的东西。

3443
06:00:14.215 --> 06:00:33.153
现在你可能有bash或zca或其他shell类型这并不重要因为在Mac和Linux上都是基于Linux的我们现在可以通过运行Node的破折号版本来测试我们的无Jess安装是否正确完成，你应该会看到像这样的东西。

3444
06:00:33.216 --> 06:00:37.434
节点的确切版本在这里并不重要。

3445
06:00:37.434 --> 06:00:40.516
但理想情况下，您至少使用Node版本14或更高的版本。

3446
06:00:40.516 --> 06:00:49.787
如果这样的东西没有显示出来，记得继续，并开始查看Stack Overflow，查看讨论选项卡中的GitHub回购，查看更新的部分，等等。

3447
06:00:49.787 --> 06:00:55.794
就像我说的，有时候安装这个是整个课程中最难的部分所以，不要气馁。

3448
06:00:55.794 --> 06:01:01.469
请使用Stack Overflow Stack Exchange ethereum和GitHub repo来解决您遇到的任何问题。

3449
06:01:01.469 --> 06:01:14.166
现在，如果你在Mac或Linux上，你可以按Ctrl back勾，来切换你的终端模式，这会让终端上下移动，让你熟悉键盘快捷键会让你的生活更容易。

3450
06:01:14.216 --> 06:01:21.154
因为你将能够更有效地移动Visual Studio代码，我们有一个链接到键盘快捷键列表。

3451
06:01:21.216 --> 06:01:36.675
此外，在与这一节相关的GitHub存储库中，随着我们的推进，我将给出不同的键盘快捷键提示，你可以选择使用其他方式，你可以继续并单击，你可以单击垃圾桶删除终端，回到终端新终端弹出它。

3452
06:01:36.675 --> 06:01:45.358
下一个我们稍后会用到的东西，本节不需要它，但最好现在安装它它是git, jazz被称为JavaScript运行时。

3453
06:01:45.358 --> 06:01:51.248
它是一个工具，我们将用来帮助在Visual Studio code插槽中运行JavaScript代码。

3454
06:01:51.248 --> 06:01:56.882
没有Jas和JavaScript之间的区别可能会让人有点困惑，但现在不要因此而停下脚步。

3455
06:01:56.882 --> 06:02:11.636
接下来，我们会继续安装Git，我们会在GitHub存储库中找到安装说明的链接，在Linux上安装Git，你会使用这两个命令中的一个在macOS上，如果你在命令行中输入Git，它会继续提示你安装它。

3456
06:02:11.636 --> 06:02:16.378
回到命令行，输入git，它会提示你，让它暂停。

3457
06:02:16.378 --> 06:02:20.505
如果你得到的是破折号版本，你应该得到像这样的东西。

3458
06:02:20.505 --> 06:02:25.486
你也可以通过点击这里的链接来使用Mac OS get安装程序。

3459
06:02:25.486 --> 06:02:32.592
好了，现在你还没有在Visual Studio代码中安装JS，我们可以继续下一节。

3460
06:02:32.592 --> 06:02:33.092
太棒了。

3461
06:02:33.092 --> 06:02:41.117
如果你不打算使用Windows或获得pod，请随意跳过接下来的两个部分。

3462
06:02:41.217 --> 06:02:42.645
我在Windows 11上运行它。

3463
06:02:44.217 --> 06:02:45.183
Windows的版本。

3464
06:02:47.217 --> 06:02:54.717
要安装的是Visual Studio Code，它看起来像这样，它应该会自动检测。

3465
06:02:54.717 --> 06:03:01.486
我们会在windows上下载这个在整个安装过程中。

3466
06:03:01.486 --> 06:03:07.298
继续创建一个桌面项目，我们将添加这个，以防我们想用代码打开。

3467
06:03:07.298 --> 06:03:09.369
然后我们继续安装。

3468
06:03:09.369 --> 06:03:11.741
然后我们继续，结束。

3469
06:03:11.741 --> 06:03:23.389
一旦你安装了Visual Studio代码，你会看到一些像这样的东西，它会给你这个VS code入门部分在这里你可以选择一些主题，你可以选择它看起来的方式随意定制它以你想要的方式。

3470
06:03:23.389 --> 06:03:32.911
如果您想了解更多关于Visual Studio代码的知识，我强烈建议您通过本节了解更多关于快捷方式的知识，并提高开发体验的效率。

3471
06:03:32.911 --> 06:03:36.322
当你完成后，你可以继续并关闭顶部的标签。

3472
06:03:36.322 --> 06:03:37.865
它看起来有点像这样。

3473
06:03:37.865 --> 06:03:40.050
一旦我们安装了Visual Studio代码。

3474
06:03:40.050 --> 06:03:43.283
接下来我们要安装的是节点js。

3475
06:03:43.283 --> 06:03:50.751
当然，我们有一个链接，可以在GitHub知识库中安装这个与这门课相关，我们要做的是，我们要继续，来到节点j s。

3476
06:03:50.751 --> 06:03:50.951
org。

3477
06:03:50.951 --> 06:03:53.060
下载此Windows节点。

3478
06:03:53.060 --> 06:03:56.483
JS是一个JavaScript运行时环境，它不完全是JavaScript。

3479
06:03:56.483 --> 06:04:02.958
这种区分可能会让人有点困惑，但这将帮助我们在开发环境中运行JavaScript代码。

3480
06:04:02.958 --> 06:04:08.791
让我们继续下载LTS或无GS的长期支持版本。

3481
06:04:08.791 --> 06:04:14.987
我们将继续并运行安装向导。

3482
06:04:15.218 --> 06:04:21.168
我们要确保这个被点击了以防我们想在设置中使用一些不同的工具。

3483
06:04:21.218 --> 06:04:26.983
然后我们继续点击安装，你会看到一个弹出窗口询问你是否真的想要在你的设备上安装这个。

3484
06:04:26.983 --> 06:04:28.436
然后点击yes。

3485
06:04:28.436 --> 06:04:36.030
然后点击完成，你可能会看到一个像这样的弹出框，点击任意按钮继续安装工具，再按任意键。

3486
06:04:36.030 --> 06:04:43.551
你可能会弹出一个Windows PowerShell屏幕，要求你继续安装一大堆不同的项目和文件。

3487
06:04:43.551 --> 06:04:45.862
如果你选择不安装这个，那完全没问题。

3488
06:04:45.862 --> 06:04:54.154
但在未来，这将非常有帮助，因为我们将使用这个包安装的许多工具，这可能需要一些时间来安装。

3489
06:04:54.218 --> 06:04:55.043
所以勇往直前，要有耐心。

3490
06:04:56.218 --> 06:04:58.381
等着你按回车键。

3491
06:04:59.218 --> 06:05:00.511
按回车键以获得任何提示。

3492
06:05:02.218 --> 06:05:04.562
它的安装速度会有点慢。

3493
06:05:04.562 --> 06:05:07.843
安装完所有这些之后，就可以回到Visual Studio代码中了。

3494
06:05:07.843 --> 06:05:10.818
我们要继续，开一个终点站。

3495
06:05:10.818 --> 06:05:19.489
要做到这一点，我们点击终端，我们点击新终端终端将是我们的命令行提示符在那里我们将运行所有的脚本来处理我们的代码。

3496
06:05:19.489 --> 06:05:27.352
如果你运行Node的虚线版本，你应该会看到类似这样的东西，以知道你已经正确安装了Node js。

3497
06:05:27.352 --> 06:05:30.719
现在，这个命令行被称为Windows PowerShell。

3498
06:05:30.719 --> 06:05:33.907
如果你想使用Windows PowerShell，你完全可以。

3499
06:05:33.907 --> 06:05:39.164
事实上，如果你想成为一个完全的Harto，并通过Windows PowerShell编写所有的代码，你完全可以这样做。

3500
06:05:39.164 --> 06:05:46.400
然而，我们实际上不会使用PowerShell，我们将使用一个工具，使我们的Windows环境更像Linux。

3501
06:05:46.400 --> 06:05:50.552
我们这样做的原因是Linux是大多数开发环境的标准。

3502
06:05:50.552 --> 06:06:00.444
让每个人都在一个非常相似的设置下工作将会使剩下的课程更容易让每个人相互交流，无论他们在什么编码环境下工作。

3503
06:06:00.444 --> 06:06:07.790
WsL代表Linux的Windows子系统，它允许Linux程序在我们的Windows环境中本机运行。

3504
06:06:07.790 --> 06:06:12.743
要得到这个设置，我们要继续，进入WsL安装。

3505
06:06:12.743 --> 06:06:17.989
我们在GitHub知识库中也会有这个链接。

3506
06:06:17.989 --> 06:06:23.943
我们要做的是，你必须运行Windows 10, 2004或更高版本，或者Windows 11。

3507
06:06:23.943 --> 06:06:27.955
如果你使用的是旧版本的Windows，你完全可以继续使用PowerShell。

3508
06:06:27.955 --> 06:06:32.324
但是您可能会遇到一些问题，即所有命令的工作方式并不完全相同。

3509
06:06:32.324 --> 06:06:36.579
因此，我强烈建议使用更新版本的Windows。

3510
06:06:36.579 --> 06:06:45.200
把它安装回你的Visual Studio Code, PowerShell，或者仅仅是PowerShell应用程序，或者运行WsL破折号安装。

3511
06:06:45.200 --> 06:06:56.924
如果你得到这个错误，请求的操作需要提升，这意味着我们必须以管理员身份运行我们的Visual Studio代码或PowerShell应用程序。

3512
06:06:56.924 --> 06:07:01.645
我们关闭Visual Studio代码。

3513
06:07:01.645 --> 06:07:12.153
右键点击它，说，以管理员身份运行，我们会弹出一个小窗口问，你想让这个应用改变你的设备吗，我们会点击是。

3514
06:07:12.153 --> 06:07:14.803
然后我们会重新开放候机楼。

3515
06:07:14.803 --> 06:07:18.803
然后我们可以运行WsL space dash - install。

3516
06:07:18.803 --> 06:07:21.719
我们将继续安装WsL。

3517
06:07:21.719 --> 06:07:25.157
这可能需要一点时间，所以请耐心等待。

3518
06:07:25.220 --> 06:07:30.070
一旦它完成了，你会看到像这样的东西，我们将和Ubuntu一起工作。

3519
06:07:30.070 --> 06:07:33.820
我们有一个不同的命令列表来改变您的Linux发行版。

3520
06:07:33.820 --> 06:07:34.720
如果你选择这样做的话。

3521
06:07:34.720 --> 06:07:40.600
您将看到请求集操作是成功的，更改直到重新启动系统才会生效。

3522
06:07:40.600 --> 06:07:43.123
所以你需要重新启动你的电脑。

3523
06:07:43.220 --> 06:07:46.171
在GitHub存储库中也有一个故障排除指南。

3524
06:07:46.220 --> 06:07:51.751
如果在重新启动计算机后遇到问题，系统会提示您输入新系统的名称和密码。

3525
06:07:51.751 --> 06:07:56.448
这可以与您的Windows用户名和密码不同，然后按照所有提示操作即可。

3526
06:07:56.448 --> 06:08:01.185
一旦你完成了，你就会被放到一个Ubuntu shell中，你就可以运行Linux命令了。

3527
06:08:01.185 --> 06:08:04.588
现在你的机器上就有了一个Ubuntu实例。

3528
06:08:04.588 --> 06:08:07.727
你将能够在你的终端上运行Linux命令。

3529
06:08:07.727 --> 06:08:13.580
现在我们已经正确设置了WsL，我们将返回到Visual Studio代码。

3530
06:08:13.580 --> 06:08:17.304
一旦我们有了WsL，我们就需要继续安装扩展。

3531
06:08:17.304 --> 06:08:38.827
在我们的Visual Studio代码中，我们会找到扩展，我们会找到远程开发你可以安装所有的东西或者只是远程WsL我们会安装所有的东西你可以跟着我开始远程WsL如果你喜欢，你也可以现在跟着我。

3532
06:08:38.827 --> 06:08:47.407
现在如果我到终端，点击新终端，我仍然会得到PowerShell我们希望这是我们的Linux shell。

3533
06:08:47.407 --> 06:08:52.268
在Linux环境中打开Visual Studio代码有几种方法。

3534
06:08:52.268 --> 06:08:57.506
一种方法是按Ctrl, Shift P，然后键入WsL。

3535
06:08:57.506 --> 06:09:09.033
然后单击远程WsL新WsL窗口，您将得到一个看起来像这样的新窗口，您也可以单击左下角并选择new WsL窗口。

3536
06:09:09.033 --> 06:09:16.627
如果我们到终端，点击新终端，我们会进入到bash shell中我们可以在这里运行Linux命令。

3537
06:09:16.627 --> 06:09:17.002
太棒了。

3538
06:09:17.002 --> 06:09:34.930
另一种打开带有WsL的Visual Studio代码的方法是我们可以进入你的boon to应用程序，我们可以通过输入mkdir文件夹来创建一个文件夹，我们可以输入CD或将目录更改为文件夹并键入代码周期。

3539
06:09:34.930 --> 06:09:37.833
我们继续，相信这里的作者。

3540
06:09:37.833 --> 06:09:43.144
这将打开已经连接到文件夹的Visual Studio代码。

3541
06:09:43.144 --> 06:09:50.368
我们可以在这个文件夹中创建文件，比如hi。txt，这些会在WsL的文件夹中创建。

3542
06:09:50.368 --> 06:09:55.792
现在我们在WsL环境中，您会注意到节点破折号版本不再工作了。

3543
06:09:55.792 --> 06:10:02.158
这是因为我们将它安装在常规的Windows机器上，而不是WsL或Linux环境上。

3544
06:10:02.158 --> 06:10:16.471
我们首先在Windows环境中安装它的原因是，如果你想继续使用PowerShell或用户Windows环境来运行一切你仍然可以记住，如果你使用Windows环境和PowerShell，我们使用的所有命令可能都不适合你。

3545
06:10:16.471 --> 06:10:20.877
我们会在Linux环境中安装Node js。

3546
06:10:20.877 --> 06:10:25.793
我们要写的所有命令都将在与这门课程相关的GitHub repo中。

3547
06:10:25.793 --> 06:10:43.879
我们将对nvm存储库执行一个curl命令，nvm存储库代表节点版本管理器。

3548
06:10:44.222 --> 06:10:46.958
我们将把安装脚本传输到bash中。

3549
06:10:47.222 --> 06:10:50.254
这将继续并安装虚拟机。

3550
06:10:52.222 --> 06:10:56.156
先销毁终端，然后再重新打开。

3551
06:10:57.222 --> 06:11:02.643
可以键入MBM的破折号版本，看看它是否实际安装正确。

3552
06:11:02.643 --> 06:11:07.189
一旦我们安装了nvm，我们就可以继续使用nvm安装任何GS。

3553
06:11:07.189 --> 06:11:13.323
只要输入npm install，我们就会得到16点14。

3554
06:11:13.323 --> 06:11:17.510
2是我们安装在Windows机器上的长期支持版本。

3555
06:11:17.510 --> 06:11:21.641
一旦我们安装了它，我们可以键入节点虚线S版本。

3556
06:11:21.641 --> 06:11:23.705
现在我们没有安装JS。

3557
06:11:23.705 --> 06:11:27.842
我知道这里有很多，但如果你能走到这一步，那就太棒了。

3558
06:11:27.842 --> 06:11:34.923
您已经完成了很好的工作，完成了所有的设置，以便您可以在最好的环境中编写代码。

3559
06:11:34.923 --> 06:11:37.040
如果你已经走到这一步，恭喜你。

3560
06:11:37.040 --> 06:11:39.933
接下来我们要安装的是Git。

3561
06:11:39.933 --> 06:11:42.555
这节课我们不打算使用Git。

3562
06:11:42.555 --> 06:11:45.643
然而，我们将来肯定会使用它。

3563
06:11:45.643 --> 06:11:54.003
看看是否安装了git，有时Linux会自动安装git，你会看到像这样的输出。

3564
06:11:54.003 --> 06:11:57.770
如果没有Git，我们可以查找get install。

3565
06:11:57.770 --> 06:12:00.205
再说一次，这个链接在描述中。

3566
06:12:00.205 --> 06:12:03.399
你会在Linux上运行安装程序。

3567
06:12:03.399 --> 06:12:23.256
如果你想使用PowerShell，你想在Windows上做所有事情，你完全可以按照Windows上的安装说明来做，当你在WsL中工作时，你会想使用Linux命令而不是Windows命令即使你在Windows上因为WsL使你基本上是在Linux环境中运行。

3568
06:12:23.256 --> 06:12:32.303
现在，如果你已经学到了这一步，你应该能够按照Mac和Linux的说明进行操作，就像你在Mac和Linux上运行一样即使你在Windows上运行。

3569
06:12:32.303 --> 06:12:38.699
只要确保你在编写VS代码时，看一下左下角，确保你是在WsL Ubuntu上。

3570
06:12:38.699 --> 06:12:43.651
如前所述，如果您想在PowerShell或Windows环境中运行，那么您可以自由地这样做。

3571
06:12:43.651 --> 06:12:49.348
但就像我说的，如果你能走到这一步，恭喜你。

3572
06:12:49.348 --> 06:12:50.973
很棒的工作。

3573
06:12:51.223 --> 06:12:56.328
最后，我们的最后一个设置将从第五课开始使用一个叫做Git pod的工具。

3574
06:12:56.328 --> 06:13:07.623
我们现在学习的课程，醚，爵士，简单存储，我们所有的代码回购都会有一个向下滚动的按钮，它们会有这个打开的get pod按钮。

3575
06:13:07.623 --> 06:13:24.129
gitpod是一个云开发环境你可以在远程服务器上运行你的代码，它有点类似于混合IDE，但它允许你在浏览器中运行Visual Studio代码或连接到另一个服务器。

3576
06:13:24.129 --> 06:13:28.175
这很好，因为这样你就不需要安装任何东西了。

3577
06:13:28.223 --> 06:13:32.626
因为所有您想要使用的工具都将在这个远程服务器上运行。

3578
06:13:32.626 --> 06:13:39.968
当然，这也有它的缺点，因为只有当git pod启动并为您工作时，您才能够进行编码。

3579
06:13:39.968 --> 06:13:48.090
此外，当涉及到私钥时，您绝对不希望运行任何带有私钥的代码，而私钥在良好的pop中有真正的金钱。

3580
06:13:48.090 --> 06:13:56.452
为什么?同样，由于您在远程服务器上运行脚本，这些服务器可以访问您的私钥。

3581
06:13:56.452 --> 06:14:04.601
但因为你有Pinky承诺，在这门课上，你不会使用元掩码或有实际钱的私钥，这应该是没问题的。

3582
06:14:04.601 --> 06:14:09.890
另一个缺点是，使用这些大麻通常要花钱，而且大麻不是免费的。

3583
06:14:09.890 --> 06:14:14.974
但如果你绝对不能让任何安装工作，这是一个选择。

3584
06:14:14.974 --> 06:14:19.465
如果你点击这个打开的获取豆荚按钮，你会得到一个欢迎，让豆荚显示出来。

3585
06:14:19.465 --> 06:14:21.851
我们将继续GitHub。

3586
06:14:21.851 --> 06:14:28.094
既然你已经在这里注册了GitHub，你想继续并授权get pod。

3587
06:14:28.094 --> 06:14:31.613
它会开始为你创建这个工作区。

3588
06:14:31.613 --> 06:14:35.581
你会发现它和Visual Studio Code很像。

3589
06:14:35.581 --> 06:14:46.366
因为我在Git荚中打开了repo，它附带了所有的代码，你甚至可以在VS code桌面中打开这个工作区。

3590
06:14:46.366 --> 06:14:49.112
这可能有点让人困惑。

3591
06:14:49.112 --> 06:14:54.156
但基本上，你可以使用本地的Visual Studio代码运行Git pod。

3592
06:14:54.224 --> 06:14:58.288
如果你在这里看到gitpod，这就是你知道你正在运行gitpod的方式。

3593
06:14:58.288 --> 06:15:03.896
如果你看到这个弹出，你想在VS code桌面打开这个工作区，你可以点击打开。

3594
06:15:03.896 --> 06:15:09.351
它会问你是否要打开Visual Studio Code，我要点击yes。

3595
06:15:09.351 --> 06:15:13.172
你会在你的Visual Studio代码中得到类似这样的东西。

3596
06:15:13.224 --> 06:15:18.128
它会告诉你它想要安装Git pod扩展，然后打开那个Git pod URL。

3597
06:15:18.128 --> 06:15:20.382
所以你可以继续安装它。

3598
06:15:20.382 --> 06:15:27.782
重新加载窗口，然后打开它就会开始连接到我们的Git pod工作区。

3599
06:15:27.782 --> 06:15:33.257
这和在浏览器中运行gitepod是一样的。

3600
06:15:33.257 --> 06:15:45.431
或者你也可以手动点击左下方的Git模块，然后键入open in VS code，然后你就可以在Visual Studio代码中运行它了。

3601
06:15:45.431 --> 06:15:54.172
现在，我建议如果你用的是Git pod，就待在浏览器里，这样你就知道，我是在远程服务器上运行这个。

3602
06:15:54.172 --> 06:15:58.917
提醒一下，你并不是在本地发展。

3603
06:15:58.917 --> 06:16:04.325
希望这能触发不放任何特殊私钥之类的东西。

3604
06:16:04.325 --> 06:16:12.356
但是你可以创建工作区，你可以创建新的文件夹，你应该能够在这里运行所有的命令，就像你在本地运行Visual Studio代码一样。

3605
06:16:12.356 --> 06:16:29.891
要打开终端，你可以点击左上角的这个小栏，进入终端，新终端，或者使用和Mac OS和Linux键盘快捷键一样的CTRL波浪号来创建一个新文件夹，我们可以更改目录，CD，点。

3606
06:16:29.891 --> 06:16:36.510
mkdir，新建文件夹，mkdir使新建目录称为新文件夹。

3607
06:16:36.510 --> 06:16:40.275
然后我们要把目录改为一个新文件夹，然后回车。

3608
06:16:40.275 --> 06:16:41.925
现在我们在那个新文件夹里。

3609
06:16:41.925 --> 06:16:52.015
对于每个部分，您可以直接将整个源代码打开到GitHub中，或者您可以自己为每个部分创建一个新文件夹，并从空白开始。

3610
06:16:52.015 --> 06:16:55.470
然后你只需输入代码句号。

3611
06:16:55.470 --> 06:17:00.382
你会在一个全新的文件夹里。

3612
06:17:00.382 --> 06:17:02.405
好吧，这太棒了。

3613
06:17:02.405 --> 06:17:07.446
此时，您应该使用Visual Studio Code no Jas进行设置并得到。

3614
06:17:07.446 --> 06:17:18.692
我要创建一个名为Hard Hat Free Code Camp的文件夹现在，你应该有节点，破折号版本，得到破折号版本。

3615
06:17:18.692 --> 06:17:24.484
如果你用的是Windows，这里应该写WsL或你的boon to之类的。

3616
06:17:24.484 --> 06:17:27.603
如果你有了这些，那就意味着我们可以出发了。

3617
06:17:27.603 --> 06:17:30.601
现在做一个简短的笔记你们会经常看到我做的事情。

3618
06:17:30.601 --> 06:17:32.351
你也可以这样做。

3619
06:17:32.351 --> 06:17:38.838
通常，当我的终端变得非常非常大，或者有大量的命令在这里，这对我来说有点不知所措。

3620
06:17:38.838 --> 06:17:42.851
你能做的一件事就是输入clear，然后按回车键清除。

3621
06:17:42.851 --> 06:17:54.506
如果你用的是Mac，你可以按Command K键，如果你用的是Linux或Windows，你可以按Ctrl K键，这是我最喜欢的快捷键之一，我一直在用。

3622
06:17:54.506 --> 06:17:58.816
此外，垃圾桶和这里的X是非常不同的。

3623
06:17:58.816 --> 06:18:12.419
如果我在这里有几个输入，我们在下面这里，如果我点击垃圾桶，然后把我的终端拉上来，通过切换，或者通过terminal new terminal，你会看到所有的线都在这里。

3624
06:18:12.419 --> 06:18:21.444
但如果我点击垃圾桶，然后把终端拉上来，你会看到它实际上刷新了我的一个特殊命令，打印出来的东西。

3625
06:18:21.444 --> 06:18:26.766
清除终端基本上就是删除运行在它里面的东西，而x只是隐藏它。

3626
06:18:26.766 --> 06:18:35.476
当按Ctrl波浪键或切换终端或环境中的任何命令时，这相当于点击隐藏，而不是垃圾。

3627
06:18:35.476 --> 06:18:41.129
因此，如果我们想要移除并重新启动一个终端，我们就敲击垃圾桶，然后把它拉上来。

3628
06:18:41.129 --> 06:18:43.401
好了，现在我们开始研究醚。

3629
06:18:43.401 --> 06:18:51.648
我们将开始学习编码，我们的交易，我们的合同部署和所有的东西都是在相对较低的水平上编程的。

3630
06:18:51.648 --> 06:18:56.872
我们将学习如何使用ethers JS包来部署和交互契约。

3631
06:18:56.872 --> 06:19:04.805
现在开始吧，我建议大家创建一个文件夹把所有的项目都放在里面，我要新建一个名为H H的目录。

3632
06:19:04.805 --> 06:19:08.735
连字符，FCC，代表硬帽自由代码营。

3633
06:19:08.735 --> 06:19:12.209
一旦我们运行这个命令，我们可以cd到hh FCC。

3634
06:19:12.209 --> 06:19:19.040
我们将在这里创建接下来这门课的所有项目，这样我们就能把它们都放在一个地方。

3635
06:19:19.040 --> 06:19:24.744
现在开始，无论什么时候创建一个新项目，你总是想要创建一个新文件夹。

3636
06:19:24.744 --> 06:19:33.602
要创建一个新文件夹，我们用mkdir，我们称它为乙醚，简单存储，就像这样。

3637
06:19:33.602 --> 06:19:42.001
现在，如果你输入ls，你会看到有一个名为ethers的文件夹，简单的存储。

3638
06:19:42.001 --> 06:19:45.948
Ls是列出文件夹中所有内容的方式。

3639
06:19:45.948 --> 06:19:52.560
这里可能有很多其他文件夹，我只有一个，因为我创建了这个新文件夹。

3640
06:19:52.560 --> 06:19:57.060
现在你能做的是，输入代码，醚，很简单。

3641
06:19:57.227 --> 06:20:00.893
如果你按tab键，它会自动完成。

3642
06:20:01.227 --> 06:20:08.443
如果你输入，Visual Studio code会为你打开一个新的Visual Studio代码。

3643
06:20:08.443 --> 06:20:20.164
这是在简单存储中如果你现在打开你的终端，你的工作空间的主目录将会通过简单存储，就像弹出的那样。

3644
06:20:20.164 --> 06:20:32.978
如果这对你不起作用，我们还可以点击文件，打开文件夹然后打开你刚创建的文件夹或者你想再次打开这个我们会打开VS code。

3645
06:20:32.978 --> 06:20:36.679
如果我们打开我们的终端，我们看到我们是在一个简单的存储中。

3646
06:20:36.679 --> 06:20:47.007
这个功能非常强大，因为当我们创建文件时我们可以在资源管理器中看到这些文件，这个按钮代表资源管理器。

3647
06:20:47.007 --> 06:20:49.728
如果我们点击它，我们可以在这里看到不同的文件。

3648
06:20:49.728 --> 06:20:55.024
我要删掉这个文件。txt，因为我们不会用到它。

3649
06:20:55.024 --> 06:21:00.478
现在是课程的这一部分，我们将开始学习一些JavaScript。

3650
06:21:00.478 --> 06:21:06.243
因为这门课是JavaScript课程，如果你不熟悉JavaScript，可能会有点棘手。

3651
06:21:06.243 --> 06:21:15.024
如果你想更好地理解JavaScript和Node js，你可以在YouTube上找到一个免费的代码训练营视频来教初学者No, Jas。

3652
06:21:15.024 --> 06:21:18.600
这个的链接会在与这门课相关的GitHub回购中。

3653
06:21:18.600 --> 06:21:27.143
还有一个JavaScript免费代码营的视频我也会放在这门课的描述里，记住JavaScript和Node js有一点不同。

3654
06:21:27.143 --> 06:21:31.543
我们会在编写代码的过程中讨论其中的一些差异。

3655
06:21:31.543 --> 06:21:35.482
但在大多数情况下，学习了其中一种意味着你已经学习了另一种的大部分内容。

3656
06:21:35.482 --> 06:21:45.389
如果你想暂停一下，看一遍这些视频，在继续之前，请随意，你不必这么做，你完全可以继续这门课。

3657
06:21:45.389 --> 06:21:53.299
如果你对某个JavaScript片段感到困惑或卡住，请随时暂停，跳过它然后回来。

3658
06:21:53.299 --> 06:21:56.634
但是重申一下，您可以查看JavaScript编程的完整课程。

3659
06:21:56.634 --> 06:22:01.123
还有Node js的全部课程，因为它们都对你有帮助。

3660
06:22:01.123 --> 06:22:04.704
就像我之前说的，Node js是一个JavaScript运行时。

3661
06:22:04.704 --> 06:22:07.244
所以它不完全是JavaScript。

3662
06:22:07.244 --> 06:22:09.652
但我们要用JavaScript写代码。

3663
06:22:09.652 --> 06:22:13.295
如果这让你感到困惑，现在不要担心。

3664
06:22:13.295 --> 06:22:17.179
随着我们学习这门课，我会告诉你们区别在哪里。

3665
06:22:17.229 --> 06:22:21.196
但基本上，你可以认为Jas和JavaScript不是一回事。

3666
06:22:21.196 --> 06:22:37.432
Node js最重要的一点是它允许我们在后端编写JavaScript代码，而不是在前端运行JavaScript, JavaScript是一种浏览器运行语言，就像在Chrome, brave Firefox等浏览器中运行一样。

3667
06:22:37.432 --> 06:22:50.361
不，Jas允许它成为一种脚本语言，一种后端语言，这就是为什么前端JavaScript和后端JavaScript或非JS JavaScript之间的语法会有一点不同。

3668
06:22:50.361 --> 06:22:58.562
此外，当我们在这段代码中进行的时候，如果你熟悉TypeScript，我们所有的代码都会附带一个TypeScript版本。

3669
06:22:58.562 --> 06:23:02.916
TypeScript是JavaScript的静态类型版本。

3670
06:23:02.916 --> 06:23:04.229
它会是它会是这个。

3671
06:23:04.229 --> 06:23:06.176
它将是TypeScript，而不是TypeScript版本。

3672
06:23:06.176 --> 06:23:09.671
我来修改一下，去掉这个，让它更清晰。

3673
06:23:09.671 --> 06:23:15.284
TypeScript是JavaScript的类型安全版本，这很让人困惑，不用太担心。

3674
06:23:15.284 --> 06:23:18.479
但我们所有的编程都是用JavaScript进行的。

3675
06:23:18.479 --> 06:23:22.193
如果代码足够不同，我还会演示如何在TypeScript中实现。

3676
06:23:22.229 --> 06:23:27.179
但是，对于其中的大多数，我们不会展示TypeScript版本，因为它们非常相似。

3677
06:23:27.229 --> 06:23:31.210
但是你总是可以参考GitHub存储库来查看TypeScript的所有代码。

3678
06:23:31.210 --> 06:23:39.454
如果你是这方面的新手，我建议你先从JavaScript开始，然后再学习如何使用TypeScript。

3679
06:23:39.454 --> 06:23:46.656
TypeScript实际上在早期就能捕捉到bug，从长远来看，这使得编写项目代码变得容易得多。

3680
06:23:46.656 --> 06:23:49.016
然而，这确实需要大量额外的输入。

3681
06:23:49.016 --> 06:24:00.296
对于初学者来说，学习类型是如何工作的可能会有点令人沮丧，JavaScript作为一种语言稍微宽松一些，它让我们做任何想做的事，但之后它可能会让人头疼。

3682
06:24:00.296 --> 06:24:07.404
所以，如果你确实遇到了一些问题，你确实遇到了一些bug，尝试TypeScript的大小可能是个好主意，看看效果如何。

3683
06:24:07.404 --> 06:24:07.721
好。

3684
06:24:07.721 --> 06:24:15.066
让我们继续，开始在我们的本地开发环境中工作，并准备好在醚Jas和JavaScript中完成所有工作。

3685
06:24:15.066 --> 06:24:15.311
哦。

3686
06:24:15.311 --> 06:24:20.508
我把这个文件夹重命名为以太符号存储破折号FCC。

3687
06:24:20.508 --> 06:24:33.176
我添加这个破折号FCC的原因是所有与这门课程相关的GitHub仓库，所有有这个破折号FCC的GitHub reppos都知道它是这门硬帽子JavaScript课程的一部分。

3688
06:24:33.230 --> 06:24:33.574
太棒了。

3689
06:24:33.574 --> 06:24:34.262
让我们开始吧。

3690
06:24:36.230 --> 06:24:41.941
我们的智能合约在Visual Studio代码的本地，你可以从这个文件夹的名字看出来。

3691
06:24:41.941 --> 06:24:51.145
当然，如果你看一下代码，这个项目将是我们简单的存储项目，但使用醚在本地开发。

3692
06:24:52.230 --> 06:24:55.134
我们要做的第一件事是进入智能合约代码。

3693
06:24:55.134 --> 06:25:05.515
我们要做的是确保我们选中了资源管理器，然后右键选择新文件，进行简单的存储。

3694
06:25:05.515 --> 06:25:09.372
先把这个关了。

3695
06:25:09.372 --> 06:25:15.134
我们还可以将上一节的简单存储代码复制粘贴到VS code中。

3696
06:25:15.230 --> 06:25:31.357
如果你关闭了remix或者你忘了它在哪里，你可以到ethers simple storage FCC repo，这是simple storage。Sol，我们可以把所有的代码复制到这里然后回到select Symbol storage, Saul，然后粘贴进去。

3697
06:25:31.357 --> 06:25:36.955
关于Visual Studio代码有一个重要的注意当你看到这个小白的时候。

3698
06:25:36.955 --> 06:25:42.476
在上面这里，它意味着这个文件不是用来保存Git文件的。

3699
06:25:42.476 --> 06:25:46.061
保存，然后就这样消失了。

3700
06:25:46.061 --> 06:25:54.867
你能做的是点击命令S或Ctrl S，这取决于你使用的是Windows, Mac还是Linux。

3701
06:25:54.867 --> 06:26:02.967
现在你会看到这段代码有点难读简单的storage。salt，它没有我们在remix中看到的语法高亮显示。

3702
06:26:02.967 --> 06:26:08.821
我们想要继续，添加一个Visual Studio Code扩展来突出显示语法。

3703
06:26:08.821 --> 06:26:12.198
我们能做的是，来到这个像这样的杆。

3704
06:26:12.198 --> 06:26:17.427
如果你在左边栏没有看到它，你应该点击这三个点，它应该在这里。

3705
06:26:17.427 --> 06:26:19.394
但我们还是点击扩展。

3706
06:26:19.394 --> 06:26:27.118
我们要做的是向上看，固体度加硬帽。

3707
06:26:27.231 --> 06:26:30.923
我们要安装这个固体加安全帽扩展。

3708
06:26:30.923 --> 06:26:31.846
对于VS code。

3709
06:26:31.846 --> 06:26:39.972
现在我们已经安装了这个，如果我们回到我们的简单存储点sole，你会看到所有的高亮都回来了。

3710
06:26:39.972 --> 06:26:42.101
现在阅读起来容易多了。

3711
06:26:42.231 --> 06:26:43.331
对吧?这很好。

3712
06:26:45.231 --> 06:26:46.437
语法高亮显示。

3713
06:26:49.231 --> 06:26:53.378
格式，或者现在我们的代码在它的格式化方式上很好。

3714
06:26:53.378 --> 06:27:07.982
但如果我们不小心做了这样或这样的事情，或者甚至像这样，我们添加了大量的新行，等等，我们的代码会开始看起来很恶心。

3715
06:27:07.982 --> 06:27:15.782
即使代码本身是好的，它会以完全相同的方式运行，所有这些额外的空格，它看起来不是很好，对吧。

3716
06:27:15.782 --> 06:27:18.485
正因为如此，它可能会有点难读。

3717
06:27:18.485 --> 06:27:37.294
我们想要做的是，打开设置调整vias代码让它在保存时自动格式化，无论何时保存，无论它从这里的小白点到没有白点，这整个都会自动格式化成看起来很漂亮的样子。

3718
06:27:37.294 --> 06:27:37.606
好的。

3719
06:27:37.606 --> 06:27:48.854
我们能做的是打开我们的命令面板打开我们的命令面板，你能点击查看命令面板，我们会得到一个像这样的小弹出框。

3720
06:27:48.854 --> 06:27:57.565
另一种打开命令面板的方法是点击command Shift P，或者Ctrl Shift P，这取决于你的Mac, Linux或者Windows。

3721
06:27:57.565 --> 06:28:04.544
我们要做的是输入设置，然后打开设置JSON，我们不想打开默认设置JSON。

3722
06:28:04.544 --> 06:28:06.356
我们不想碰这些。

3723
06:28:06.356 --> 06:28:08.595
但是我们希望打开JSON设置。

3724
06:28:08.595 --> 06:28:12.062
您还会注意到有用户设置和工作空间设置。

3725
06:28:12.062 --> 06:28:14.216
这些部分我们也可以调整。

3726
06:28:14.216 --> 06:28:17.113
我们将直接进入JSON设置。

3727
06:28:17.113 --> 06:28:21.215
所以所以我这里已经有一些东西了，但你的可能是空白的。

3728
06:28:21.215 --> 06:28:23.365
或者你这里也可能有一些东西。

3729
06:28:23.365 --> 06:28:31.306
所以我们要做的是如果你在这里已经有东西了，我们要加一个逗号，然后我们要做引号，固体。

3730
06:28:31.306 --> 06:28:38.062
闭上括号，我们要做一个小冒号，像这样。

3731
06:28:38.062 --> 06:28:41.763
这意味着我们将对Visual Studio代码应用一些设置。

3732
06:28:41.763 --> 06:28:50.741
当我们处理固体时，我们会在这里添加一个编辑器，这是Doc默认的物质编辑器。

3733
06:28:50.741 --> 06:29:05.333
你甚至可能会弹出一个窗口告诉你一些不同的东西我们可以使用默认格式或者我们的默认格式，或者是Nanak foundation。hard hat，连字符solidity。

3734
06:29:05.333 --> 06:29:23.299
这意味着任何时候我们要格式化我们的代码，它将使用硬帽固态性插件，作为它的默认格式，或者硬帽固态性插件自带一些格式，以及许多其他真正有用的工具，供我们编写代码。

3735
06:29:23.299 --> 06:29:28.483
现在我们有了这个部分，接下来我们要做的是在保存中添加format。

3736
06:29:28.483 --> 06:29:36.483
如果还没有，我们可以把它添加到JSON文件中，但我不会把它添加到JSON文件中，我会把它添加到整个文件中。

3737
06:29:36.483 --> 06:29:47.741
如果我们打开命令面板，输入设置，打开用户设置，这是另一个很好的地方我们可以在这里查看UI的添加设置。

3738
06:29:47.741 --> 06:29:49.939
所以这两个本质上是一样的。

3739
06:29:49.939 --> 06:29:56.448
只是这个有刻度盘和更多的上下文而JSON只会说，给我它的原始代码。

3740
06:29:56.448 --> 06:29:57.958
这告诉我们更多。

3741
06:29:57.958 --> 06:29:59.216
你可以用任何一个。

3742
06:29:59.216 --> 06:30:02.414
但我们要寻找格式，onsave。

3743
06:30:02.414 --> 06:30:07.200
如果你还没检查过的话，你会想要检查的。

3744
06:30:07.200 --> 06:30:13.587
这意味着每次我们保存VS code时，它都会试图为我们格式化代码。

3745
06:30:13.587 --> 06:30:16.200
现在我们已经检查了这个，我们添加了settings。JSON。

3746
06:30:16.233 --> 06:30:17.905
记住，我们要保存它。

3747
06:30:19.233 --> 06:30:20.686
白点，表示没得救。

3748
06:30:22.233 --> 06:30:22.995
然后结束。

3749
06:30:22.995 --> 06:30:24.233
让我把这个也画出来。

3750
06:30:25.234 --> 06:30:31.807
在这里，我们添加一些随机的新空格，你想让它看起来有点丑，然后保存它。

3751
06:30:31.807 --> 06:30:36.618
它会自动重新格式化，看起来更好。

3752
06:30:36.618 --> 06:30:46.487
如果我们这样做，我们会保存它，重新格式化它，让它看起来更好这个让你和其他看你代码的人更容易读。

3753
06:30:46.487 --> 06:30:48.137
这真的很好。

3754
06:30:48.137 --> 06:30:54.524
这行用于设置。JSON的代码位于完整的区块链学习课程中。

3755
06:30:54.524 --> 06:30:54.620
js。

3756
06:30:54.620 --> 06:31:03.141
你也可以复制粘贴它，我们会覆盖默认格式或者另一种叫做pretty的格式。

3757
06:31:03.141 --> 06:31:12.796
但最好有一个默认格式，如果将来不想添加更漂亮的代码，就可以使用默认的格式化器。

3758
06:31:12.796 --> 06:31:13.296
太棒了。

3759
06:31:13.296 --> 06:31:18.537
在进行格式化时，我们还要为JavaScript代码添加一个默认格式。

3760
06:31:18.537 --> 06:31:24.055
为了进行测试，让我们创建新文件，我们将其命名为deploy。Jas。

3761
06:31:24.055 --> 06:31:39.602
在这里，我们可以做一些函数Hi console。log, Hi，然后添加然后让它看起来有点恶心，也许像这样。

3762
06:31:39.602 --> 06:31:50.027
如果你点击保存，它会自动格式化，这很好，你可以通过返回命令面板来关闭它，说，保存不格式化。

3763
06:31:50.027 --> 06:31:53.122
这样它就会被保存而不被格式化。

3764
06:31:53.122 --> 06:32:00.332
添加其他格式的方法是安装另一个扩展名，这个名为pretty tier。

3765
06:32:00.332 --> 06:32:03.355
我们可以在这里查找更漂亮的和扩展。

3766
06:32:03.355 --> 06:32:06.924
你会想要安装这个漂亮的代码格式化器。

3767
06:32:06.924 --> 06:32:09.480
我们要安装这个。

3768
06:32:09.480 --> 06:32:18.178
很好，现在它安装得更漂亮了，它是一个表单，一种代码格式，它适用于很多语言，比如Python, JavaScript，甚至是solididity。

3769
06:32:19.235 --> 06:32:22.806
很快我们就会在JavaScript和solidity中使用pretty。

3770
06:32:22.806 --> 06:32:31.850
但现在，我们要用更漂亮的JavaScript，我们可以通过打开命令面板来启用它，我们会打开首选项，打开设置。

3771
06:32:31.850 --> 06:32:37.735
和我们添加固体性部分一样，我们将添加JavaScript部分。

3772
06:32:37.735 --> 06:32:47.328
我们会在这里加一个逗号，一些引号，括号，我们会输入JavaScript，结束冒号括号。

3773
06:32:47.328 --> 06:32:53.936
我们将在door。default或matter处做同样的事情。

3774
06:32:53.936 --> 06:33:04.520
Net，然后在这里，我们要做e s BENP，更漂亮的连字符VS code。

3775
06:33:04.520 --> 06:33:08.718
这将使JavaScript的默认编辑器更漂亮。

3776
06:33:08.718 --> 06:33:14.922
就像我说的，很快，我们就会有更好的覆盖这两个对于可靠性和JavaScript。

3777
06:33:14.922 --> 06:33:21.703
我们会给一些更漂亮的参数，这样无论谁使用你的代码，他们都会有完全相同的格式。

3778
06:33:21.703 --> 06:33:32.828
现在我们有了更漂亮的默认编辑器，如果我们返回来部署。js，然后点击保存，它的格式应该是这样的。

3779
06:33:32.828 --> 06:33:35.156
现在，我们继续做这样的事情。

3780
06:33:35.156 --> 06:33:39.510
如果我们继续这样做，它会重新格式化成像这样像这样。

3781
06:33:39.510 --> 06:33:57.586
另外，如果你想回到命令面板，打开用户设置，而不是JSON模式，我们会到默认格式，或者你甚至可以选择默认格式或所有语言，如果你想对所有格式化器使用更漂亮。

3782
06:33:57.586 --> 06:33:58.686
请随便说。

3783
06:33:58.686 --> 06:34:07.093
很好，得到了JavaScript格式，让我们开始写一些JavaScript代码。

3784
06:34:07.236 --> 06:34:07.569
太棒了。

3785
06:34:10.236 --> 06:34:15.155
学习如何使用JavaScript实际部署我们的契约。

3786
06:34:15.236 --> 06:34:26.558
这将教会我们很多关于事务的知识以及在底层发生了什么，甚至在混搭中底层发生了什么，混搭中，我们通常只需要点击编译按钮，然后点击部署按钮。

3787
06:34:26.558 --> 06:34:27.912
就是这样。

3788
06:34:27.912 --> 06:34:32.410
在JavaScript中，我们会创建自己的函数来帮助我们完成这两件事。

3789
06:34:32.410 --> 06:34:38.684
正如我提到的，这是课程的一部分我们将开始使用JavaScript，如果你喜欢，也可以选择TypeScript。

3790
06:34:38.684 --> 06:34:42.628
就像我说的，所有这些部分都有TypeScript版本。

3791
06:34:42.628 --> 06:34:49.460
让我们设置deployout js脚本来部署简单的storage。soul。

3792
06:34:49.460 --> 06:34:55.202
那么我们该如何开始呢?首先，让我们学习如何使用JavaScript和Node js运行脚本。

3793
06:34:55.202 --> 06:35:02.541
如果你想打印行，或者只是打印一些东西到你的终端，我们可以做一个叫做console。log的东西。

3794
06:35:02.541 --> 06:35:06.104
如果我点击console。log，嗨，点击保存。

3795
06:35:06.104 --> 06:35:08.661
我打开我的终端。

3796
06:35:08.661 --> 06:35:11.267
现在可以运行Node deploy了。

3797
06:35:11.267 --> 06:35:11.454
js。

3798
06:35:11.454 --> 06:35:20.611
它会打印出high node这是我们想用node js运行JavaScript代码的方式。

3799
06:35:20.611 --> 06:35:30.799
其他你可能熟悉的语言，有时我们会用Python，你知道，deployuppy，或者Java, C deploy。Java，等等。

3800
06:35:30.799 --> 06:35:35.362
但是对于JavaScript，由于前端和后端JavaScript是不同的。

3801
06:35:35.362 --> 06:35:37.143
我们在后端用node运行代码。

3802
06:35:37.237 --> 06:35:43.665
有了JavaScript，你可以做很多你会看到的东西，比如固体，稍微松散的结构。

3803
06:35:43.665 --> 06:35:54.537
如果我想创建一个变量，我可以说，让变量等于5，这类似于你和256，变量等于5。

3804
06:35:54.537 --> 06:35:58.503
但在JavaScript中，我们使用let或var或const。

3805
06:35:58.503 --> 06:36:03.862
然后我可以打印出来，我可以写console。log variable。

3806
06:36:03.862 --> 06:36:10.808
JavaScript是可选的你是否需要分号。

3807
06:36:10.808 --> 06:36:13.658
这里，我觉得更漂亮，默认使用分号。

3808
06:36:13.658 --> 06:36:16.926
我们会在不久的将来把这些东西在你的候机楼里处理掉。

3809
06:36:16.926 --> 06:36:32.253
一旦你开始输入文件名，如果你按tab键，它就会自动补全剩下的文件名按tab键，它就会自动补全如果我们按回车键，就会得到Hi，然后是5。

3810
06:36:32.253 --> 06:36:35.086
因为这个输出Hi，然后输出5。

3811
06:36:35.086 --> 06:36:39.605
JavaScript会自动从文件顶部的代码开始。

3812
06:36:39.605 --> 06:36:42.058
首先是console。log，然后是变量。

3813
06:36:42.058 --> 06:36:43.499
还有这个。

3814
06:36:43.499 --> 06:36:51.753
但是，一个好的实践是将所有您想要做的事情都打包到一个main函数中，然后运行那个main函数。

3815
06:36:51.753 --> 06:37:04.786
但我们能做的是在顶部这里，我们写上function，意思，添加括号和一些括号，在底部加上右括号，然后点击保存为自动格式。

3816
06:37:04.786 --> 06:37:10.134
现在，如果我们运行这个，什么也不会发生，因为我们已经把所有的代码包装在一个主函数中。

3817
06:37:10.134 --> 06:37:17.830
如果我现在运行node deployed to Jess，什么都不会发生，因为我需要调用main函数。

3818
06:37:17.830 --> 06:37:29.134
如果我取下面这个main函数，调用main，我们的代码中的job实际上会说，啊，脚本的第一行实际上是这个main函数。

3819
06:37:29.134 --> 06:37:33.452
现在如果我执行node deploy。j s，它会运行到high和5，这就是我们想要的。

3820
06:37:33.452 --> 06:37:42.641
现在，这将是我们大部分脚本的设置，包括我们写的脚本，当我们进入硬帽，然而，有一个主要的区别。

3821
06:37:42.641 --> 06:37:47.983
我们用的不是常规函数，而是async函数。

3822
06:37:47.983 --> 06:37:50.872
我们要用异步编程来实现这个。

3823
06:37:50.872 --> 06:37:59.303
现在，如果我接下来说的对你来说真的很困惑不要让它减慢你的速度，请继续观看JavaScript课程来了解更多关于这方面的知识。

3824
06:37:59.303 --> 06:38:02.113
但我也会告诉你们，这是一个async函数。

3825
06:38:02.113 --> 06:38:06.009
这是我们在使用它时需要注意的。

3826
06:38:06.009 --> 06:38:17.438
但我还是想给你们简单介绍一下异步编程的背景知识。

3827
06:38:17.438 --> 06:38:20.531
到目前为止，我们所做的编程都是同步的。

3828
06:38:20.531 --> 06:38:27.017
稳健性是编程语言的一个例子，同步，同步意味着它一行接一行。

3829
06:38:27.017 --> 06:38:34.145
如果我们的代码是这样的，这是同步写入，我们的main函数是第一个被调用的。

3830
06:38:34.145 --> 06:38:37.721
然后是console。log，变量等于5，然后是console。log。

3831
06:38:37.721 --> 06:38:42.566
这是JavaScript的同步编程，所有的实体都是同步编程的。

3832
06:38:42.566 --> 06:38:45.273
在使用神谕的时候会有一些例外。

3833
06:38:45.273 --> 06:38:46.972
但目前，一切都是同步的。

3834
06:38:46.972 --> 06:38:53.223
JavaScript可以是异步的，这意味着我们实际上可以让代码同时运行。

3835
06:38:53.223 --> 06:38:57.980
我喜欢用一个很好的例子来理解烹饪的区别。

3836
06:38:57.980 --> 06:39:06.239
在同步编程中，对于烹饪，你可能会把爆米花放进微波炉，等待爆米花完成。

3837
06:39:06.239 --> 06:39:10.294
然后，也许你会给大家倒酒。

3838
06:39:10.294 --> 06:39:12.317
这就是同步编程。

3839
06:39:12.317 --> 06:39:18.560
现在，对你来说，把爆米花放进微波炉里，然后盯着它，等着它吃完可能有点奇怪。

3840
06:39:18.560 --> 06:39:25.039
然后倒饮料，你通常可以在爆米花在微波炉里加热的时候倒饮料。

3841
06:39:25.039 --> 06:39:27.608
这就是异步编程的用得上的地方。

3842
06:39:27.608 --> 06:39:33.905
如果为这个电影之夜做准备，我们是异步的，你会做的就是把爆米花放进微波炉里。

3843
06:39:33.905 --> 06:39:52.690
当爆米花在微波炉里，或者给所有人喝的饮料，然后你会等爆米花吃完，因为你没有什么可做的，但你等爆米花吃完再倒饮料是没有意义的，你可以直接直接倒饮料，然后等爆米花吃完。

3844
06:39:52.690 --> 06:39:57.560
所以异步编程是一种不用等待任务完成就能完成任务的方式。

3845
06:39:57.560 --> 06:40:05.192
这在JavaScript中非常有利默认情况下允许我们进行异步编程，但有时我们需要等待爆米花完成。

3846
06:40:05.239 --> 06:40:13.916
例如，如果不只是倒饮料，那么下一件事可能就是在爆米花上撒盐而不是倒饮料。

3847
06:40:13.916 --> 06:40:19.489
当然，如果我们想在爆米花上放盐，我们必须等爆米花从微波炉里出来。

3848
06:40:19.489 --> 06:40:27.949
所以即使把爆米花放在微波炉里有这个等待时间我们需要能够告诉我们的代码我想让你等待它或者不，你很好。

3849
06:40:27.949 --> 06:40:30.142
你可以继续做另一个任务。

3850
06:40:30.142 --> 06:40:32.287
这就是区别所在。

3851
06:40:32.287 --> 06:40:42.336
我会在GitHub上留下一些与这门课相关的链接来更好地理解这个函数有这个等待期的函数返回一个叫做问题的东西。

3852
06:40:42.336 --> 06:40:48.453
如果把爆米花放进微波炉是JavaScript中的一个函数，那它就是一个基于承诺的函数。

3853
06:40:48.453 --> 06:40:52.593
承诺可以是待定的，可以是履行的，也可以是拒绝的。

3854
06:40:52.593 --> 06:40:55.450
这样我们就能知道爆米花是否做好了。

3855
06:40:55.450 --> 06:41:03.699
如果我们的爆米花是一个方法，把爆米花放进微波炉，是JavaScript中的一个函数，当我们在等待爆米花完成时，它处于挂起状态。

3856
06:41:03.699 --> 06:41:07.530
当爆米花吃完的时候，它就满足了。

3857
06:41:07.530 --> 06:41:11.646
如果我们中途中止，停止等待，它就会被拒绝。

3858
06:41:11.646 --> 06:41:14.699
所以把爆米花放进微波炉里是一个承诺。

3859
06:41:14.699 --> 06:41:23.418
有了这个承诺，我们必须告诉我们的代码，嘿，我们想让你等爆米花吃完或者你可以继续做一些事情。

3860
06:41:23.418 --> 06:41:26.324
让我们用一些JavaScript语法把这些放在一起。

3861
06:41:26.324 --> 06:41:29.453
再说一遍，我们要安排这个电影之夜。

3862
06:41:29.453 --> 06:41:32.840
我们要做爆米花，给大家倒饮料。

3863
06:41:32.840 --> 06:41:34.879
然后我们要开始看电影。

3864
06:41:34.879 --> 06:41:40.043
让我们写一些伪代码来假设如果这是一个函数这段代码是什么样的。

3865
06:41:40.043 --> 06:41:44.128
我们创建了一个函数叫setup, Movie Night。

3866
06:41:44.128 --> 06:41:49.076
在这里，我们会说，好的，我们首先要做什么?好了，我们要做爆米花了。

3867
06:41:49.076 --> 06:41:51.306
假设我们有一个煮爆米花的函数。

3868
06:41:51.306 --> 06:41:56.530
所以我们会说，好吧，做爆米花，然后我们要做的下一件事是我们要倒饮料，或者喝。

3869
06:41:56.530 --> 06:41:59.755
我们调用一些倒饮料函数。

3870
06:41:59.755 --> 06:42:04.944
事情是这样的，我们只想在爆米花煮熟后才开始看电影。

3871
06:42:04.944 --> 06:42:25.178
一旦我们的饮料被倒了，如果其中任何一个返回了一个承诺，如果其中任何一个返回了一个承诺，比如煮爆米花，我们就需要告诉这里的代码等待爆米花完成因为煮爆米花将是一个我们可以说，让状态等于煮爆米花的函数。

3872
06:42:25.241 --> 06:42:29.812
当爆米花在煮的时候，状态就会结束。

3873
06:42:29.812 --> 06:42:32.923
一旦爆米花煮熟了，它就满足了。

3874
06:42:32.923 --> 06:42:36.413
如果爆米花碎了，微波炉爆炸了，这个状态就会被拒绝。

3875
06:42:36.413 --> 06:42:40.105
但我们不希望状态处于挂起状态。

3876
06:42:40.105 --> 06:42:44.963
在我们继续之前，我们只想在这两个函数完成后开始我们的电影。

3877
06:42:44.963 --> 06:42:47.885
假设它们都返回这些承诺。

3878
06:42:47.885 --> 06:42:51.174
所以我们需要告诉我们的代码，嘿，你得等等。

3879
06:42:51.174 --> 06:42:55.641
或者你不得不等着爆米花和劣质的饮料喝完。

3880
06:42:55.641 --> 06:43:06.641
我们现在能做的是不用太深入了解这些是如何工作的，我们能做的最简单的事情之一你们会看到我们经常使用这种语法就是把这个函数变成异步函数。

3881
06:43:06.641 --> 06:43:19.150
当我们的函数是异步的，我们可以访问一个名为await的关键字。await关键字告诉任何基于承诺的函数等待该承诺被实现或拒绝。

3882
06:43:19.150 --> 06:43:22.553
所以我们说好，我们想等爆米花熟了。

3883
06:43:22.553 --> 06:43:24.952
然后我们要等着倒饮料。

3884
06:43:24.952 --> 06:43:27.579
然后我们就可以开始看电影了。

3885
06:43:27.579 --> 06:43:31.952
只有这两个都完成了，电影才会在这里开始。

3886
06:43:31.952 --> 06:43:36.241
这就是为什么在我们所有的代码中，你会看到await关键字被大量使用。

3887
06:43:36.241 --> 06:43:38.391
但它只能在异步函数中使用。

3888
06:43:38.391 --> 06:43:45.257
基本上，当你看到await关键字时，被调用的函数是基于承诺的。

3889
06:43:45.257 --> 06:43:49.487
在这个函数完成之前我们不想进行下一个步骤。

3890
06:43:49.487 --> 06:43:53.185
以上是关于承诺和异步编程的更多内容。

3891
06:43:53.242 --> 06:43:54.320
希望你们明白了。

3892
06:43:56.242 --> 06:43:59.195
在描述中了解更多关于异步编程的信息。

3893
06:43:59.242 --> 06:44:04.225
我之所以要讲这个是因为我们要用到的大部分函数都是异步的。

3894
06:44:04.225 --> 06:44:14.129
例如，当我们部署契约时，我们必须做什么?我们得等它被部署好。

3895
06:44:14.242 --> 06:44:25.511
如果我们不使用同步编程，只让函数main像这样，会发生的是我们会写一些像contract。deploy这样的代码，我们不会等它完成。

3896
06:44:25.511 --> 06:44:33.956
显然，如果我们不等待它完成，我们试图在一个尚未完成部署的契约上运行一些代码，它将无法工作。

3897
06:44:33.956 --> 06:44:50.136
我们想这样做，我们想让主函数是一个async函数，这样我们就可以等待契约部署，我们可以等待事情发生，我们可以等待爆米花完成，我们可以灵活地告诉代码是等待爆米花完成还是继续。

3898
06:44:50.136 --> 06:44:56.209
现在我们有了一个async函数的main函数，我们要往下面的main函数中添加一些代码。

3899
06:44:56.209 --> 06:45:00.527
这里添加的代码是一些用于处理异步函数的语法。

3900
06:45:00.527 --> 06:45:04.258
如果这部分让人困惑，我现在就说，绝对的，不用担心。

3901
06:45:04.258 --> 06:45:06.042
如果你以后想理解的话。

3902
06:45:06.042 --> 06:45:06.442
这很好。

3903
06:45:06.442 --> 06:45:28.187
但对于那些跟随我们的人，我们只会添加一个add然后抓住空气你可以自己跟随输入这个或者你可以复制粘贴到你的代码中。

3904
06:45:28.243 --> 06:45:32.874
基本上，这允许我们做的是我们的主函数，这是一个异步函数。

3905
06:45:32.874 --> 06:45:40.984
当我们调用main函数时，这是另一种语法用来等待它基本完成然后打印它得到的任何错误。

3906
06:45:40.984 --> 06:45:48.093
这就是我们这么做的原因，再说一次，如果这一大块代码，如果你想知道这一大块代码是怎么回事，老实说，现在，只需要复制粘贴它。

3907
06:45:48.093 --> 06:45:48.543
太好了。

3908
06:45:48.543 --> 06:45:51.385
我们有异步函数main，我们有一些代码。

3909
06:45:51.385 --> 06:45:56.275
然后我们有这段代码，它基本上调用了主异步函数。

3910
06:45:56.275 --> 06:45:56.865
好了,好了。

3911
06:45:56.865 --> 06:45:58.581
我先把这些都删掉。

3912
06:45:58.581 --> 06:46:02.639
但你仍然可以在与本课程相关的GitHub回购中找到常见的。

3913
06:46:02.639 --> 06:46:03.052
太棒了。

3914
06:46:03.052 --> 06:46:07.925
好的，现在我们有了真正的基本设置，让我们继续，开始编码。

3915
06:46:07.925 --> 06:46:13.147
如果这个set apart让人困惑，async await让人困惑，不要太担心。

3916
06:46:13.147 --> 06:46:15.354
随着我们的进步，它会变得更有意义。

3917
06:46:15.354 --> 06:46:35.461
我们所有的代码基本上都会在这个async函数main中，它将是我们部署简单存储。灵魂存储的主脚本deploy脚本将完全复制remix中发生的事情，在remix中，我们总是做的第一件事是什么?我们要做的第一件事是编译所有的代码。

3918
06:46:35.461 --> 06:46:40.036
我们还需要在JavaScript项目中编译代码。

3919
06:46:40.036 --> 06:46:51.293
为了编译我们的简单存储契约，我们将使用一个名为Silk Jas的工具，JavaScript实际上有一种方法可以直接将项目安装到我们的设置和文件夹中。

3920
06:46:51.293 --> 06:46:54.800
如果我们向下滚动这个丝绸Jas就是我们要找的。

3921
06:46:54.800 --> 06:47:07.177
因为它有一种通过相对路径来编译导入其他合约的方法，所以您可以在这个自述文件和大多数文档中看到类似这样的部分，如果它与JavaScript兼容的话。

3922
06:47:07.177 --> 06:47:15.444
对于Node js的使用，它说通过Node js使用最新的稳定版本的固体编译器，你可以通过NPM NPM install安装它。

3923
06:47:15.444 --> 06:47:19.340
NPM就是所谓的包管理器。

3924
06:47:19.340 --> 06:47:29.325
我们实际上通过安装没有Jess来安装NPM，对吧，如果我们没有破折号版本，你也应该能够安装NPM破折号版本。

3925
06:47:29.325 --> 06:47:32.604
它附带的另一个工具叫做core pack。

3926
06:47:32.604 --> 06:47:41.958
你可以输入核心包破折号版本，现在我们可以用NPM安装NPM安装丝绸，然而，我喜欢纱线包管理器稍微好一点。

3927
06:47:41.958 --> 06:47:47.899
我们实际上要安装yarn包管理器来做所有的包管理。

3928
06:47:47.899 --> 06:47:53.976
如果你进入安装页面，安装纱线的新方法是运行core pack enable。

3929
06:47:53.976 --> 06:47:56.604
旧的方法是用NPM安装。

3930
06:47:56.604 --> 06:48:03.888
如果你继续运行核心包启用后，完成，你应该能够运行纱线破折号版本。

3931
06:48:03.888 --> 06:48:12.163
或者，你可以只运行NPM i dash g core pack，然后你可以运行core pack enable。

3932
06:48:13.244 --> 06:48:17.519
最后的选择是你可以运行NPM i dash g纱。

3933
06:48:17.519 --> 06:48:20.829
这将为您的系统全局安装yarn。

3934
06:48:20.829 --> 06:48:24.431
但这被认为是过时的安装纱线的方式。

3935
06:48:24.431 --> 06:48:26.767
理想情况下，你运行core pack enable。

3936
06:48:26.767 --> 06:48:33.211
但在任何情况下，在你运行这些之后，如果你运行纱线破折号版本，你应该得到像这样的东西。

3937
06:48:33.211 --> 06:48:39.182
现在我们有了纱线，我们可以使用纱线来安装我们所有的项目，而不是NPM。

3938
06:48:39.244 --> 06:48:55.754
回到silk Jas中，上面写着npm install soak，我们可以做npm install sock的纱线等等物，也就是yarn, add sock，这实际上会继续并将solc安装到我们的项目中。

3939
06:48:55.754 --> 06:49:09.198
如果我们打开文件夹，你会看到它添加了几个不同的文件夹，它首先添加了一个包。JSON包。JSON是一个文件，它告诉我们很多关于项目的信息以及它所使用的依赖关系。

3940
06:49:09.245 --> 06:49:14.083
例如，我们已经安装了soap包0。

3941
06:49:15.245 --> 06:49:20.520
yarn点锁告诉我们项目中所有不同包的确切版本。

3942
06:49:20.520 --> 06:49:25.800
例如，这一点之所以如此重要，是因为solc也有大量的依赖项。

3943
06:49:25.800 --> 06:49:32.045
yarn dot lock告诉我们solc的确切版本以及solchen的所有不同依赖关系。

3944
06:49:32.045 --> 06:49:33.911
我们添加的任何其他项目。

3945
06:49:33.911 --> 06:49:37.402
这是自动生成的文件，不要直接编辑该文件。

3946
06:49:37.402 --> 06:49:40.517
最后一点是，我们有这个节点模块文件夹。

3947
06:49:40.517 --> 06:49:52.030
这个节点模块文件夹会是我们刚刚下载的所有安装代码所在的地方，例如，如果我们看节点模块，我们会看到有一个sock文件夹。

3948
06:49:52.030 --> 06:49:59.174
在这个sock文件夹中是所有与我们刚刚安装的soap包相关的代码。

3949
06:49:59.245 --> 06:50:02.122
因为我们是在(0,8)处工作。

3950
06:50:03.245 --> 06:50:05.470
想要安装那个特定的版本。

3951
06:50:06.245 --> 06:50:12.770
要做纱线，在0点8处加入solc。

3952
06:50:17.245 --> 06:50:20.800
在我们的package。JSON中，你现在可以看到零点8。

3953
06:50:21.245 --> 06:50:24.245
固定在我们的依赖部分生闷气。

3954
06:50:25.246 --> 06:50:28.865
可以只加盐版像纱线加零点八。

3955
06:50:29.246 --> 06:50:31.686
零点八有个问题。

3956
06:50:33.246 --> 06:50:34.246
8点。

3957
06:50:36.246 --> 06:50:42.934
你可以找到不同的版本，不同的版本，如果你去sulk Jas的版本，然后标签，好的，很好。

3958
06:50:42.934 --> 06:50:59.432
既然我们已经出售了合同，我们就有能力实际编译我们的契约，我们可以在代码中编译它们，并在点击Deploy时自动运行它，或者我们可以单独编译它们。

3959
06:50:59.432 --> 06:51:07.877
如果您想在此之后返回，本节是一个雕塑Jas存储库中的示例，它向您展示了如何在代码中实际编译silk。

3960
06:51:07.877 --> 06:51:12.371
实际上，我们将使用soap Jas命令分别编译它们。

3961
06:51:12.371 --> 06:51:18.164
yarn命令既可用于安装依赖项，也可用于运行脚本。

3962
06:51:18.164 --> 06:51:25.150
如果你打开sulk Jas向下滚动，它说为了使用命令行，你实际上需要全局安装它。

3963
06:51:25.150 --> 06:51:31.035
如果你想要全局安装它使用yarn全局添加solc在零点8。

3964
06:51:31.035 --> 06:51:34.263
7 Dash固定你可以绝对向前走。

3965
06:51:34.263 --> 06:51:46.659
然而，由于我们在这个文件夹中，它有yarn。lock package json和节点模块yarn将足够聪明，知道i你在这个文件夹中寻找的是浸泡。

3966
06:51:46.659 --> 06:51:56.277
因此，我们实际上可以继续使用yarn和solc Jess编译我们的合同，如果你想查看所有不同的命令，我们可以只运行yarn。

3967
06:51:56.277 --> 06:52:05.763
Jas帮助，你会看到它会吐出一个列表，列出了软Jas的所有不同选项。

3968
06:52:05.763 --> 06:52:14.747
你也可以运行纱线，所以Jas破折号版本只是为了确保我们是正确的版本，这确实是零点8。

3969
06:52:14.747 --> 06:52:14.818
7.

3970
06:52:14.818 --> 06:52:36.358
现在要真正编译我们在soul的简单存储，让我们运行遵从命令我们将运行yarn，所以J S，破折号bin因为我们想要二进制破折号ABI因为我们也想要ABI破折号包含路径节点模块。

3971
06:52:36.358 --> 06:53:00.715
因为我们想在节点模块中包含任何契约或文件，这个项目中我们不使用任何契约或文件，但在未来，您将需要包括这个破折号包含路径节点模块做破折号基本路径的period，这个period意味着基本路径将是这个文件夹破折号O period，这意味着我们将输出编译后的二进制文件和ABI到这个文件夹。

3972
06:53:00.715 --> 06:53:03.996
最后，简单的存储。灵魂。

3973
06:53:03.996 --> 06:53:10.617
因为这是我们想要编译的契约，所以可以从简单存储到简单存储自动完成它。

3974
06:53:10.617 --> 06:53:18.908
输入simple，然后按Tab键，然后回车，你会看到它在运行这个命令来编译合约。

3975
06:53:18.908 --> 06:53:21.707
您将看到两个文件得到输出。

3976
06:53:21.707 --> 06:53:34.385
一个叫做Simple Storage soul的API在Simple Storage Sol中强调Simple Storage dot bin，这个ABI显然是这个合同的ABI，它在未来会需要。

3977
06:53:34.385 --> 06:53:40.264
然后bin将是二进制，或者是这个代码的底层，然后重新混音。

3978
06:53:40.264 --> 06:53:59.112
如果你编译简单的存储，那就是灵魂，你可以看看遵从性细节，像我们刚得到的ABI，或者字节码，如果你看这个对象，它和二进制是一样的。

3979
06:53:59.248 --> 06:53:59.984
好了,好了。

3980
06:54:02.248 --> 06:54:08.755
现在，很明显，如果你点击你的键盘，你可以循环使用你最近的终端命令。

3981
06:54:08.755 --> 06:54:18.828
如果你能找到足够多的，我们可以看到刚才运行的这个命令每次都能找到一大堆，每当我们想要重新编译时，这是非常烦人的。

3982
06:54:18.828 --> 06:54:25.981
所以我们能做的就是在我们的package。JSON中添加一个脚本部分，为我们缩短一些yarn脚本。

3983
06:54:25.981 --> 06:54:34.829
我们要做的是回到我们的包中，点JSON，很多逗号，我们会添加一个叫做scripts的部分，添加冒号和括号。

3984
06:54:34.829 --> 06:54:40.414
在这里，我们会说只要我们说compile，我们就会运行这个长命令。

3985
06:54:40.414 --> 06:54:43.171
所以我要编译我们会加一些引号。

3986
06:54:43.171 --> 06:54:45.017
我们把它粘贴到这里。

3987
06:54:45.017 --> 06:54:53.441
现在不用把所有东西都敲出来，只要我们在和package json所在的文件夹里，我们就可以运行yarn compile。

3988
06:54:53.441 --> 06:55:02.037
这将为我们运行整个脚本而不需要我们把所有的东西都打出来脚本是一个非常有用的方法让我们更容易运行长命令。

3989
06:55:02.037 --> 06:55:02.931
好的，很好。

3990
06:55:02.931 --> 06:55:12.819
现在我们的代码已经编译好了，这就相当于US点击了这个编译按钮，我们就可以进行部署了。

3991
06:55:13.248 --> 06:55:15.048
现在我们有了简单的存储。

3992
06:55:16.248 --> 06:55:18.581
让我们学习一下如何部署这个东西。

3993
06:55:19.248 --> 06:55:29.715
我们把它部署到两个不同的地方，我们部署到一个JavaScript虚拟机，或者我们注入的web 3，和我们的Metamask。

3994
06:55:29.715 --> 06:55:32.301
我们先来学习一下，做JavaScript虚拟机。

3995
06:55:32.301 --> 06:55:39.011
然后我们将学习如何使用注入的web 3，或元掩码或连接到实际的测试网。

3996
06:55:39.011 --> 06:55:46.150
为了将这个部署到JavaScript虚拟邀请I'm in或假区块链，我们需要得到假区块链。

3997
06:55:46.150 --> 06:55:54.249
将来，我们将使用Hardhead运行时环境作为我们的JavaScript虚拟机，也就是我们的假区块链。

3998
06:55:54.249 --> 06:55:58.233
但在这一节中，我希望大家使用一个叫ganache的工具。

3999
06:55:58.233 --> 06:56:01.095
在GitHub存储库中有一个链接。

4000
06:56:01.095 --> 06:56:04.150
Ganache类似于混音中的虚拟机。

4001
06:56:04.150 --> 06:56:09.842
它是一个假的区块链，我们可以在本地运行它来实际测试、部署和运行代码。

4002
06:56:09.842 --> 06:56:14.732
这也是观察区块链中发生的事情的好方法。

4003
06:56:14.732 --> 06:56:21.982
让我们继续并在安装甘纳许应用程序后旋转它，甘纳许应用程序看起来有点像这样。

4004
06:56:21.982 --> 06:56:27.874
要想快速启动一个假区块链，你可以点击“快速开始”。

4005
06:56:27.874 --> 06:56:33.765
这将启动一个假的区块链在你的电脑上本地运行，这非常棒。

4006
06:56:33.765 --> 06:56:44.609
它有一大堆的假账户就像混音有一大堆的假账户有100以太币每个ganache有一大堆的假账户有100以太币。

4007
06:56:44.609 --> 06:56:52.749
它们还附带私钥，我们可以在应用程序中使用私钥来实际控制这些假账户。

4008
06:56:52.749 --> 06:56:55.767
记住，不要在公共区块链上使用这些私钥。

4009
06:56:55.767 --> 06:57:00.749
它们只是用于开发目的，因为很多人知道我们代码中的这些私钥。

4010
06:57:00.749 --> 06:57:13.964
我们需要做的第一件事是连接到区块链remix在幕后做这个，如果我们选择JavaScript虚拟机remix会选择它自己运行的假区块链。

4011
06:57:13.964 --> 06:57:23.627
如果我们选择注入web 3，我们知道，元掩码会弹出，它连接到我们的元掩码，这个连接remix所做的，实际上是在做一些非常有趣的事情。

4012
06:57:23.627 --> 06:57:27.456
它不只是通过某种神奇的力量连接到我们的元蒙版。

4013
06:57:27.456 --> 06:57:33.383
它实际上连接到我们的元掩码，它有一个连接到幕后的区块链。

4014
06:57:33.383 --> 06:57:42.758
如果你打开你的元掩码，向下选择网络选择广告网络，你会弹出一个像这样的UI。

4015
06:57:42.758 --> 06:57:49.583
如果我们返回并点击这里的选择网络，我们可以看到关于这些不同网络的信息。

4016
06:57:49.583 --> 06:57:55.500
我们可以看到的一件主要事情是，所有这些网络都有一个叫做RPC URL的东西。

4017
06:57:55.500 --> 06:57:58.650
RPC是远程过程调用的缩写。

4018
06:57:58.650 --> 06:58:02.750
URL是统一资源定位器。

4019
06:58:02.750 --> 06:58:13.853
这个RPC URL表示连接到某人正在运行的区块链节点，这个URL连接我们进行API调用并与区块链节点交互。

4020
06:58:13.853 --> 06:58:18.353
区块链节点与软件一起运行，其中一些节点公开API调用。

4021
06:58:18.353 --> 06:58:27.889
如果你看看非政府组织Aetherium的网站，实际上有指导你运行自己的区块链节点为一个真正的区块链像Aetherium。

4022
06:58:27.889 --> 06:58:34.250
其中大多数都有破折号HTTP点ADR等标志来公开这些RPC端点。

4023
06:58:34.250 --> 06:58:47.202
如果你想运行你自己的节点，你自己真正的区块链节点，而不是使用meta掩码或任何其他我们将通过的提供者，你可以使用go Aetherium，或任何你正在与软件合作的区块链来运行你自己的笔记。

4024
06:58:47.251 --> 06:58:54.870
但正是这个RPC URL允许我们连接到Rinkeby，如果在Rinkeby ropsten上，如果我们在ropsten主网上如果我们在主网上，等等。

4025
06:58:54.870 --> 06:59:02.529
这将是我们连接ganache区块链的方式我们将在这个应用程序中运行。

4026
06:59:02.529 --> 06:59:07.616
如果你看甘纳许的顶部，有一个部分叫做RPC服务器。

4027
06:59:07.616 --> 06:59:10.464
这是ganache节点的端点。

4028
06:59:10.464 --> 06:59:19.829
我们能做的是复制这个，回到VS代码，粘贴到这里，看看能不能连接而不是HTTP。

4029
06:59:19.829 --> 06:59:25.426
有了这些大写字母，我们用小写字母B代替大写字母B，因为小写字母更正确，看起来更好。

4030
06:59:25.426 --> 06:59:26.443
现在我们有了终点。

4031
06:59:26.443 --> 06:59:34.070
假设，有了这个，我们就可以开始对这个端点进行调用和API调用，进入这个JSON RPC规范。

4032
06:59:34.070 --> 06:59:41.876
链接会在GitHub repo中，我们可以看到不同的调用，我们可以直接对节点进行调用，获得不同的信息。

4033
06:59:41.876 --> 06:59:44.630
每个人都被哈希阻塞，每个人都被数字阻塞。

4034
06:59:44.630 --> 06:59:47.155
所有这些精彩的作品都在这里。

4035
06:59:47.155 --> 06:59:51.331
直接调用这些API是有点烦人的。

4036
06:59:51.331 --> 06:59:56.631
如果你想自己做，你完全可以使用像Axios或fetch这样的API端点。

4037
06:59:56.631 --> 07:00:04.691
不过，我们将使用rapper与节点交互并与区块链节点进行部署和交互等操作。

4038
07:00:04.691 --> 07:00:08.182
这就是醚最终发挥作用的地方。

4039
07:00:08.182 --> 07:00:26.151
Ethers js是最流行的基于JavaScript的工具包之一，它允许我们与不同的区块链交互，并有所有这些rapper进行所有这些API调用，并使用Aetherium、polygon、avalanche和任何EVM兼容的链做所有这些事情。

4040
07:00:26.151 --> 07:00:30.427
另一个做同样事情的非常受欢迎的包是web 3。

4041
07:00:30.427 --> 07:00:30.497
js。

4042
07:00:30.497 --> 07:00:35.430
你们可能听说过这个你们可能会在这门课和你们的网络三之旅中更多地看到它。

4043
07:00:35.430 --> 07:00:42.974
我们使用醚的原因是醚是驱动硬帽环境的主要工具，我自己也很喜欢它。

4044
07:00:42.974 --> 07:00:48.477
请记住，如果你对这些东西感到困惑，你可以回到他们的文档中去安装它。

4045
07:00:48.477 --> 07:00:56.078
你可以在这里看到，你可以运行npm install ethers，我们只需要做yarn，添加ethers。

4046
07:00:56.252 --> 07:01:01.902
现在你应该在你的package json中看到，我们在这里添加了醚。

4047
07:01:01.902 --> 07:01:02.302
太棒了。

4048
07:01:02.302 --> 07:01:06.040
现在回到代码中，我们将把醚导入到部署中。

4049
07:01:06.040 --> 07:01:13.355
Js脚本，这样我们就可以使用所有附带的工具所以我们说const ethers = require ethers。

4050
07:01:13.355 --> 07:01:24.284
对于上过这门课TypeScript版本的同学，这将是import而不是require因为这里有醚，我们可以在main函数中创建提供者对象。

4051
07:01:24.284 --> 07:01:30.832
我们把醚放到主函数外面的原因是我们想把包放到脚本里。

4052
07:01:30.832 --> 07:01:34.514
在调用main之前，我们要确保所有这些都是首先完成的。

4053
07:01:34.514 --> 07:01:37.845
你会看到这是我们脚本的正常设置。

4054
07:01:37.845 --> 07:01:45.886
在顶部，我们导入任何依赖项或外部包，我们有我们的main函数，然后我们在底部调用我们的main函数。

4055
07:01:45.886 --> 07:01:51.252
Const是一个类似于let的关键字，因此不能更改醚。

4056
07:01:51.252 --> 07:01:52.527
所以我们不能改变这个。

4057
07:01:52.527 --> 07:01:58.477
我们的ethers变量，任何时候我们使用const require都是一个导入ethers包的函数。

4058
07:01:58.477 --> 07:02:00.490
现在remix在幕后完成了所有这些工作。

4059
07:02:00.490 --> 07:02:13.321
但我们在代码中要做的是我们会说const provider = new醚。providers。JSON RPC provider。

4060
07:02:13.321 --> 07:02:18.506
然后我们会把这个字符串作为提供者传递。

4061
07:02:18.506 --> 07:02:23.110
我们说，我们要连接到这个URL。

4062
07:02:23.110 --> 07:02:23.617
太棒了。

4063
07:02:23.617 --> 07:02:29.173
这就是我们的脚本连接到区块链的方式，本地区块链。

4064
07:02:29.173 --> 07:02:31.217
现在让我们拿一个真正的钱包来。

4065
07:02:31.217 --> 07:02:38.039
有了私钥，余额和所有的东西，我们可以在甘纳许里看到我们所有的钱包和私钥。

4066
07:02:38.039 --> 07:02:40.846
建立这个的方法是使用const。

4067
07:02:40.846 --> 07:02:45.117
钱包等于新醚点钱包。

4068
07:02:45.117 --> 07:02:56.356
这个钱包函数有几个输入参数，比如私钥和提供者，私钥会到Kenosha，只选择其中一个私钥。

4069
07:02:56.356 --> 07:02:58.562
我们将把这个直接粘贴到代码中。

4070
07:02:58.562 --> 07:03:01.945
然后我们会输入逗号provider并保存。

4071
07:03:01.945 --> 07:03:06.873
现在，直接将私钥粘贴到代码中是一个巨大的禁忌。

4072
07:03:06.873 --> 07:03:10.134
我们以后会学习如何避免这种情况。

4073
07:03:10.134 --> 07:03:17.591
现在还好，因为我们只是使用ganache私钥中的一个，你没有任何与这个账户相关的资金风险。

4074
07:03:17.591 --> 07:03:29.586
仅这两条线就为我们提供了与智能合约交互所需的一切，它们为我们提供了与区块链的连接，并为我们提供了一个带私钥的钱包，以便我们可以签署不同的交易。

4075
07:03:29.586 --> 07:03:32.640
如果你还记得区块链基础部分的话。

4076
07:03:32.640 --> 07:03:37.815
这是我们用来签署所有交易的私钥，用来加密我们的交易。

4077
07:03:37.815 --> 07:03:44.456
现在我们有了提供者和钱包，让我们继续从这两个文件中获取契约对象。

4078
07:03:44.456 --> 07:03:52.629
为了部署我们的契约，我们需要ABI和契约的二进制编译代码。

4079
07:03:52.629 --> 07:03:58.991
我们需要从这两个文件中读取要从这两个文件中读取，我们需要使用一个叫Fs的包。

4080
07:03:58.991 --> 07:04:10.948
回到顶部，我们写入const f = require f，我一直自动保存，你会看到，我做了些什么然后我的白点就会消失很多。

4081
07:04:10.948 --> 07:04:22.192
这是因为我的手指有一个习惯，每当我停止打字，我就保存，所以请记住要尽早和经常保存，这个Fs额外应该直接与你的节点项目。

4082
07:04:22.254 --> 07:04:29.407
但如果没有，你总是可以用yarn添加它，额外添加Fs，你应该在我们的包。JSON中看到它。

4083
07:04:29.407 --> 07:04:45.111
现在我们可以得到ABI和二进制文件，我们可以说const, ABI = Fs。read file sync，这意味着我们要同步地从这个文件中读取，我们可以异步地进行。

4084
07:04:45.111 --> 07:04:47.254
但是我们想等待这个文件完成。

4085
07:04:47.254 --> 07:04:48.520
我们说读取文件同步。

4086
07:04:48.520 --> 07:05:00.044
取决于你的VS代码，如果你滚动，你甚至可能会得到一些关于这个函数弹出的信息，像这样，这非常有用，我们可以看到我们需要我们想要读取的文件的路径。

4087
07:05:00.044 --> 07:05:19.387
然后是任意选项，以及路径我们想要读取的文件在ABI中，位于。/ simple storage，下划线下划线simple storage。AVI然后我们要做一个逗号UT f8是UTF。

4088
07:05:19.387 --> 07:05:22.544
8是我们为这个文件所做的编码。

4089
07:05:22.544 --> 07:05:24.189
现在不要太担心这意味着什么。

4090
07:05:24.254 --> 07:05:25.754
所以我们需要ABI。

4091
07:05:29.255 --> 07:05:30.610
第二个文件。

4092
07:05:34.255 --> 07:05:35.608
简单的存储点bin。

4093
07:05:38.255 --> 07:05:39.683
点读文件同步。

4094
07:05:43.255 --> 07:05:56.032
这里是。/，simple storage soul, simple storage。bin，然后是编码选项，它应该是这样的。

4095
07:05:56.032 --> 07:06:05.105
现在我们有了二进制文件，也有了ABI，我们可以创建一个称为契约工厂的东西，不要将它与以太中的工厂模式混淆。

4096
07:06:05.105 --> 07:06:09.392
契约工厂只是一个可以用来部署契约的对象。

4097
07:06:09.392 --> 07:06:21.079
我们写入const，合约工厂= new醚。合约工厂。

4098
07:06:21.255 --> 07:06:25.996
我们会传递它，API二进制。

4099
07:06:28.255 --> 07:06:46.036
通过ABI，这样我们的代码就知道如何与合约进行交互，显然，因为这是我们钱包里的主要编译代码，所以我们有一个私钥，可以用来签署部署合约，然后我通常会写一些console。log，比如部署这些等待。

4100
07:06:46.036 --> 07:06:52.390
我们可以通过const将契约部署到醚。

4101
07:06:52.390 --> 07:06:59.570
合同等于等待，合同工厂点部署。

4102
07:06:59.570 --> 07:07:06.780
这是我们第一次看到await关键字，你只能在async函数中使用await关键字。

4103
07:07:06.780 --> 07:07:15.256
我们想要await关键字的原因是我们告诉代码在这里停止，等待契约部署。

4104
07:07:15.256 --> 07:07:24.874
这个await关键字意味着它将在这个契约工厂中解析承诺契约。deploy中使用await返回一个契约对象。

4105
07:07:24.874 --> 07:07:28.732
现在我可以写console。log contract。

4106
07:07:28.732 --> 07:07:39.319
让我们看看运行这段代码时会发生什么，我们向上滚动，看到正在部署，请稍等。

4107
07:07:39.319 --> 07:07:43.256
然后我们看到这个巨大的物体被打印出来。

4108
07:07:43.256 --> 07:07:45.890
这是我们刚刚部署的契约对象。

4109
07:07:45.890 --> 07:07:56.867
事实上，如果我们转到我们的ganache，我们可以看到我们用于钱包的地址余额略少，交易计数为1。

4110
07:07:56.867 --> 07:08:03.306
如果我们用的是松露，我们就能看到这里的契约我们用的是安全帽，所以你看不到这里的契约。

4111
07:08:03.306 --> 07:08:08.193
但如果你去事务，我们确实能看到我们刚刚创建的事务。

4112
07:08:08.193 --> 07:08:09.917
这类似于以太扫描。

4113
07:08:09.917 --> 07:08:18.385
但对于本地区块链，我们能看到发送者地址，创建地址，价值，汽油价格，所有这些与合同相关的东西。

4114
07:08:18.385 --> 07:08:20.272
您还可以看到不同的块。

4115
07:08:20.272 --> 07:08:23.636
因为我们只进行了一次交易，只有一个区块被挖出。

4116
07:08:23.636 --> 07:08:24.588
这太棒了。

4117
07:08:24.588 --> 07:08:27.948
我们还有其他与之相关的东西。

4118
07:08:27.948 --> 07:08:28.717
伟大的工作。

4119
07:08:28.717 --> 07:08:34.729
您刚刚部署了一个契约到您自己的本地区块链与醚。

4120
07:08:34.729 --> 07:08:35.079
雅。

4121
07:08:35.256 --> 07:08:38.117
这太棒了，太棒了。

4122
07:08:41.256 --> 07:08:43.922
如果这里不使用await关键字。

4123
07:08:45.256 --> 07:08:46.056
我们的代码停止。

4124
07:08:48.257 --> 07:08:49.257
然后继续前进。

4125
07:08:51.257 --> 07:08:52.207
部署函数完成。

4126
07:08:53.257 --> 07:08:54.444
我们用这个代替。

4127
07:08:57.257 --> 07:09:04.774
这一承诺处于待定状态，因为我们的代码实际上是在契约完成部署之前完成的。

4128
07:09:04.774 --> 07:09:10.426
这里我们看到promise pending，这就是await关键字如此重要的原因。

4129
07:09:10.426 --> 07:09:16.394
我们说，嘿，等待这个完成await关键字也解决了一个承诺。

4130
07:09:16.394 --> 07:09:20.555
它会等待承诺退出，这是待定状态。

4131
07:09:20.555 --> 07:09:24.030
然后它会返回挂起承诺返回的东西。

4132
07:09:24.030 --> 07:09:29.663
因此合同工厂部署返回一个返回合同的承诺。

4133
07:09:29.663 --> 07:09:33.190
事实上，如果我们去查看ethers文档，我们会找到deploy。

4134
07:09:33.190 --> 07:09:37.944
这里我们可以看到合同工厂的方法。

4135
07:09:37.944 --> 07:09:52.866
如果我们看一下函数的定义，它说契约工厂。deploy有一大堆参数，有些重写了这个箭头表示这是它返回的东西，它返回一个分解为契约的承诺。

4136
07:09:52.866 --> 07:09:59.190
这就是为什么我们需要await关键字因为合同工厂自己部署只是返回一个承诺。

4137
07:09:59.257 --> 07:10:05.973
但如果我们确实等待合同工厂点部署，我们说它返回一个承诺，该承诺解析为一个合同。

4138
07:10:05.973 --> 07:10:10.007
我们正在等待它完成部署以解析到契约对象。

4139
07:10:10.007 --> 07:10:12.157
这将是一个很大的不同。

4140
07:10:12.257 --> 07:10:12.847
很棒的工作。

4141
07:10:15.257 --> 07:10:15.722
重要的。

4142
07:10:18.257 --> 07:10:18.707
功能。

4143
07:10:21.257 --> 07:10:22.764
函数的名字。

4144
07:10:22.764 --> 07:10:24.164
很棒的工作。

4145
07:10:28.258 --> 07:10:28.639
巧克力酱。

4146
07:10:28.639 --> 07:10:30.002
肖恩，这太棒了。

4147
07:10:31.258 --> 07:10:32.054
再多一点。

4148
07:10:34.258 --> 07:10:37.612
在Metamask中，我们可以添加一大堆东西。

4149
07:10:38.258 --> 07:10:41.758
加上气体限制，我们就能在计算趋势时增加一些价值。

4150
07:10:41.758 --> 07:10:43.758
我们可以按下交易按钮。

4151
07:10:43.758 --> 07:10:56.786
我们知道，当我们使用Metamask时，我们想要在我们的账户之间转账，我们可以选择汽油价格，我们的优先费，所有这些东西，我们实际上也可以在醚中做这些。

4152
07:10:56.786 --> 07:11:05.369
如果我们想等待合同工厂进行部署，但有一定的天然气价格，我们可以在部署函数中添加这些覆盖。

4153
07:11:05.369 --> 07:11:19.258
Visual Studio代码的另一个很巧妙的技巧是如果你点击命令或控制，这取决于你的设置，你可以点击进入一个函数看它在哪里定义以及关于这个函数的一切。

4154
07:11:19.258 --> 07:11:27.008
如果我点击命令，我可以看到我现在在Node modules ethers project contract source of Ts，所有这些东西。

4155
07:11:27.008 --> 07:11:37.999
我可以准确地看到契约工厂对象上这个deploy函数的函数定义，它向我们展示了与我们在文档中看到的相同的代码。

4156
07:11:37.999 --> 07:11:48.664
我们有一个deploy函数，它接受一些参数，然后它返回这个小分号意味着它返回一个承诺，它分解为一个契约，这非常好。

4157
07:11:48.664 --> 07:11:53.991
这里的这些实际上是我们可以用括号指定的覆盖列表。

4158
07:11:53.991 --> 07:12:05.086
我们能做的是在deploy函数中加上括号指定一些东西例如，我们可以指定天然气价格为某个数字。

4159
07:12:05.086 --> 07:12:17.592
现在如果我们要运行这个，我们会部署这个合约它的价格是这样的，我们可以添加一个气体限制，我们可以在部署函数中添加一大堆不同的覆盖。

4160
07:12:17.592 --> 07:12:25.652
我们还能做什么?我们可以等待一定数量的块来完成我们的合同，所以我们已经部署了合同。

4161
07:12:25.652 --> 07:12:31.329
但也许我们想等一个区块以确保它真的连接到链上。

4162
07:12:31.329 --> 07:12:33.083
所以我们可以说const。

4163
07:12:33.259 --> 07:12:45.339
部署接收等于等待，契约点部署事务点等待，并指定我们实际想等待的确认的数量。

4164
07:12:45.339 --> 07:12:49.433
所以我们将等待一个街区确认，以确保这发生了。

4165
07:12:49.433 --> 07:12:54.685
然后我们可以做console。log，这个部署收据选项。

4166
07:12:54.685 --> 07:13:34.153
如果我们现在运行代码,我们可以看到所有这些信息对我们的交易,我们可以清楚地看到我们的交易是什么样子,我们可以看到有两个没有因为我们创建一个合同是这个巧克力酱我们得到了私钥的地址,我们看到我们创建的合同地址交易指数,我们可以看到气体使用气体使用事务日志块开花散列,我们可以看到所有这些信息对我们的交易,我想让你们注意的是部署收据和部署事务，我想让你们把这两者分开，因为这会让你们的生活容易得多。

4167
07:13:34.153 --> 07:13:40.965
我们来做一个快速的console。log，这是部署事务。

4168
07:13:40.965 --> 07:13:48.679
然后是console。logcontract。deploy transaction。

4169
07:13:48.679 --> 07:13:54.075
然后我要复制这一行只需要输入Command C或Ctrl。

4170
07:13:54.075 --> 07:13:55.224
C在这里。

4171
07:13:55.224 --> 07:13:58.031
这是部署。

4172
07:13:58.031 --> 07:14:00.870
这是交易收据。

4173
07:14:00.870 --> 07:14:05.410
然后这个部署是收据是交易收据。

4174
07:14:05.410 --> 07:14:08.150
我将把它重命名为transaction receipt。

4175
07:14:08.150 --> 07:14:13.805
为了让它更清楚一点，哪个是哪个，我们再运行一遍。

4176
07:14:13.805 --> 07:14:19.193
当你等待区块确认时，你只会得到一张交易收据。

4177
07:14:19.260 --> 07:14:25.103
否则，你将得到契约对象，它带有部署事务，这个区别稍后将更加重要。

4178
07:14:25.103 --> 07:14:40.417
但我想让你们知道两种事务接收的区别是你在等待块确认时得到的，部署事务或事务响应，事务响应是你在创建事务时得到的。

4179
07:14:40.417 --> 07:14:46.791
交易收据，交易响应，它们是不同的收据是你等待交易完成时得到的。

4180
07:14:46.791 --> 07:14:48.604
然后反应就是你最初得到的。

4181
07:14:48.604 --> 07:14:49.505
有意义吗?好了,好了。

4182
07:14:49.505 --> 07:14:51.373
我们要把这些删掉。

4183
07:14:51.373 --> 07:14:56.937
但这些行将在与GitHub相关的代码中。

4184
07:14:56.937 --> 07:15:18.993
当我们打印出这些收据时，所有这些都在这里，因为部署合约实际上就是发送一个交易，就像我们之前说过的，如果我们想知道背后到底发生了什么，我们可以自己创建一个交易通过指定交易信息，我们自己创建一个合约。

4185
07:15:18.993 --> 07:15:25.593
那么我们要怎么做呢?让我们再次部署这个契约，但只纯粹使用事务数据。

4186
07:15:25.593 --> 07:15:28.093
我们写一个console。log。

4187
07:15:28.261 --> 07:15:32.761
让我们只使用事务数据进行部署。

4188
07:15:34.261 --> 07:15:42.118
你可以部署或发送纯粹的事务数据，你可以发送任何事务，这给你无限的流量。

4189
07:15:42.118 --> 07:15:54.584
你想要发送的事务的能力，我们能做的是我们可以说const，或者说是让TX代表我们的事务等于，我们可以把所有的事务信息加到这里。

4190
07:15:54.584 --> 07:16:04.386
首先我们需要的是我们的坚果，或者我们只使用一次的数字回到我们的交易计数，这里有四笔交易。

4191
07:16:04.386 --> 07:16:08.448
所以我们要用现时5，因为这是一个我们以前没用过的现时。

4192
07:16:08.448 --> 07:16:12.761
每次您发送一个事务时，它都会附带其中一个nonces。

4193
07:16:12.761 --> 07:16:21.337
是的，nonce是一个被过度使用的术语，我们在区块链基础课程中看到过，我们用nonce来解决这个难题。

4194
07:16:21.337 --> 07:16:29.053
Nonces也被用在钱包和签名者中，用来发送交易，它们为每一笔交易使用不同的Nonces。

4195
07:16:29.053 --> 07:16:34.554
所以nonce，当我们谈论钱包时，我们谈论的是一个与唯一交易相关的数字。

4196
07:16:34.554 --> 07:16:41.244
当我们讨论区块链挖矿是用来解决这个困难问题的值时，它们的意思是一样的。

4197
07:16:41.244 --> 07:16:42.682
它们都表示只使用过一次的数字。

4198
07:16:42.682 --> 07:16:45.025
但是它们在不同的环境下是不同的。

4199
07:16:45.025 --> 07:17:14.745
所以我们要用这个号码只能使用一次这个独特的数量为一个事务发送,所以我们会说现时标志是五个,我们将选择一个天然气价格,这里,我们将用巧克力酱的天然气价格,我们要选择一个气体限制一些大数量,我们将使用1123456,我们就使用我们会说两个是没有,对,就像我们看到在我们的收据和响应。

4200
07:17:14.745 --> 07:17:18.181
因为我们正在创建一个合约值将是零。

4201
07:17:18.181 --> 07:17:23.762
因为我们正在创建一个契约，我们不想发送一个以太多边形或雪崩。

4202
07:17:23.762 --> 07:17:29.706
然后数据就是二进制位中的大量二进制对象。

4203
07:17:29.706 --> 07:17:39.325
在二进制部分，我们要复制这一大块二进制，在这里加一些引号，我们要写0x，然后粘贴到这里。

4204
07:17:39.325 --> 07:17:43.469
这个巨大的数据块就是我们发送的二进制数据。

4205
07:17:43.469 --> 07:17:58.200
当你发送事务时，你有这个数据对象你可以填充这个东西，我们用二进制代码填充我们的数据对象它告诉区块链部署智能合约的理论它看起来就像这样。

4206
07:17:58.262 --> 07:18:02.175
最后，我们要加上链ID。

4207
07:18:02.262 --> 07:18:10.033
正如我们之前在Metamask看到的，如果我们回到我们的网络，每一个EVM链都有一个不同的链ID Etherium。

4208
07:18:10.033 --> 07:18:14.928
主网为一ropsten为三Rinke, B网为四COVID为42等。

4209
07:18:14.928 --> 07:18:29.346
其他的EVM链，比如avalanche和polygon，也会有它们唯一的链ID，或者ganache，我们可以看到网络ID出现在一些人身上是1337，所以我们可以把它粘贴到这里。

4210
07:18:29.346 --> 07:18:33.976
有些人遇到了链ID和网络ID不同的问题。

4211
07:18:33.976 --> 07:18:36.753
链ID实际上是31337。

4212
07:18:36.753 --> 07:18:43.178
因此，如果您对此有问题，请尝试31337，但它应该是1337。

4213
07:18:43.262 --> 07:18:47.329
这是一个信息传播的交易，非常棒。

4214
07:18:47.329 --> 07:18:49.929
但是，这个事务没有签名。

4215
07:18:49.929 --> 07:19:01.635
现在没有人发送这个交易这只是某人想做的交易细节，我们需要签署这个交易，然后发送到区块链。

4216
07:19:01.635 --> 07:19:14.295
Cons sign, TX response = await, wallet。sign transaction，我们可以传递那个TX对象。

4217
07:19:14.295 --> 07:19:21.032
然后我们用JavaScript写一个console。log，记录sign TX的响应。

4218
07:19:21.032 --> 07:19:22.339
和固体一样。

4219
07:19:22.339 --> 07:19:27.463
如果你在一些代码之前输入两个反斜杠，它将不会运行该代码。

4220
07:19:27.463 --> 07:19:31.663
所以我要继续，注释掉上面的三行。

4221
07:19:31.663 --> 07:19:42.663
我这样做的方法是通过高亮部分然后按Command反斜杠，或者你也可以按Ctrl反斜杠，但这是一个键盘快捷键你可以用它快速注释掉整个部分。

4222
07:19:42.663 --> 07:19:54.572
我这样做的原因是我想让你们看看当我们运行scientex响应钱包签名交易回到nosh中会发生什么，我们看到这里有四个块。

4223
07:19:54.572 --> 07:20:03.739
我问一下，如果我们执行这个带符号事务并得到带符号事务响应，我们会传播另一个块吗?我们来看看run no deploy。

4224
07:20:03.739 --> 07:20:06.437
Js，我们得到这个巨大的东西。

4225
07:20:06.437 --> 07:20:13.534
但如果回到ganache刷新，我们不会看到另一个事务发送。

4226
07:20:13.534 --> 07:20:18.816
这是因为我们只是在这里签署一个事务，并没有真正发送它。

4227
07:20:18.816 --> 07:20:20.908
签名事务响应。

4228
07:20:20.908 --> 07:20:27.772
这里的这个大数字表示的是签名事务，而不是分币事务，这是不同的。

4229
07:20:27.772 --> 07:20:32.326
你可以通过稍微改变这一行来发送一个事务。

4230
07:20:32.326 --> 07:20:56.108
我们把scientex response改成sendtx response = await wallet。send transaction TX然后一旦我们在这里发送事务，我们可以做一个等待，发送事务响应，那个等待，一个，我们会等待一个块确认以确保事务实际通过。

4231
07:20:56.108 --> 07:20:57.832
我们可以运行node。

4232
07:20:57.832 --> 07:20:58.004
js。

4233
07:20:58.264 --> 07:20:59.591
看起来已经结束了。

4234
07:21:01.264 --> 07:21:02.914
这里有个错误。

4235
07:21:05.264 --> 07:21:05.576
在这里。

4236
07:21:10.264 --> 07:21:18.451
TX没有正确的螺母，这只是为了一些练习，让我们继续，把它输入谷歌，看看我们会得到什么。

4237
07:21:18.451 --> 07:21:25.535
我们实际上有一个四年前的三Jas的网，试图叫leaf chosen，等等，等等，等等，等等。

4238
07:21:25.535 --> 07:21:29.448
看起来这是他们遇到的元掩码问题。

4239
07:21:29.448 --> 07:21:33.174
他们说，你必须在元掩码中重置你的账户，我们可以这么做。

4240
07:21:33.174 --> 07:21:35.898
但让我们把它说得更具体一点。

4241
07:21:35.898 --> 07:21:37.247
比如说醚。

4242
07:21:37.247 --> 07:21:48.538
JS看起来我们没有。从这个记录来看，我们没有关于这个推车的Stack Exchange eath或Stack Overflow的问题，因为这很简单。

4243
07:21:48.538 --> 07:21:50.539
我们的交易没有正确的时间。

4244
07:21:50.539 --> 07:21:57.895
但这是一个在Stack Overflow或Stack Exchange Aetherium上提出这个问题的好时机，这样它就会首先出现。

4245
07:21:57.895 --> 07:22:05.199
所以我们实际上没有得到正确的坚果，我们要让这个变成四个你可以看到这里account有一个四个，TX有一个五个。

4246
07:22:05.199 --> 07:22:07.756
所以我们希望这个是4。

4247
07:22:07.756 --> 07:22:14.976
一个更简单的方法总是得到正确的nonce实际上是调用钱包中的交易计数。

4248
07:22:14.976 --> 07:22:22.989
回到ethers文档，这里有一些很好的例子关于如何分配消息以及如何发送这些消息。

4249
07:22:22.989 --> 07:22:26.693
我们可以用权重钱包。获取交易计数来获取坚果。

4250
07:22:26.693 --> 07:22:37.537
回到代码中，我们可以写const尼尼= await，哦，复制粘贴，await wallet。get transaction count。

4251
07:22:37.537 --> 07:22:40.155
然后我们可以把nonce放在这里。

4252
07:22:40.265 --> 07:22:42.580
现在，让我们再运行一次。

4253
07:22:44.265 --> 07:22:45.931
有一个确实通过了。

4254
07:22:45.931 --> 07:22:47.931
我们可以用甘纳许来验证。

4255
07:22:48.265 --> 07:22:52.144
确实看到了，我们现在在第5块，有一个额外的交易。

4256
07:22:52.144 --> 07:22:54.515
现在我们可以继续，再运行一次。

4257
07:22:54.515 --> 07:22:58.317
我们永远都不用担心自己更新这个nonce。

4258
07:22:58.317 --> 07:23:07.098
因为我们只是调用wallet。get transaction count来不断更新它，当前块是6，我们额外的事务确实经过了非常棒的过程。

4259
07:23:07.098 --> 07:23:09.788
我向你们展示了如何签署交易。

4260
07:23:09.788 --> 07:23:12.827
但我们没有签署中央注入的交易。

4261
07:23:12.827 --> 07:23:21.281
为什么不呢?如果你点击命令或控制点击，或者你去etherthers的文档，我们可以看到发送事务的代码。

4262
07:23:21.281 --> 07:23:23.428
首先，它做一些检查提供程序的事情。

4263
07:23:23.428 --> 07:23:24.968
有一些填充事务的东西。

4264
07:23:24.968 --> 07:23:35.846
但我们可以看到，在它发送事务之前，甚至在以太中，它先签署事务，然后调用这个。provider。send事务。

4265
07:23:35.846 --> 07:23:44.717
如果你像这里一样调用带有事务细节的send transaction，这和先签名然后用提供者发送它是一样的。

4266
07:23:44.717 --> 07:23:45.396
好了,好了。

4267
07:23:45.396 --> 07:23:50.618
我们已经学习了如何使用纯JavaScript和纯醚发送事务。

4268
07:23:50.618 --> 07:24:17.837
这其中的一个主要收获的每次改变区块链,每次我们改变状态,每次我们使用天然气,我们发送一个事务,看起来几乎一模一样,是区别的数据,这些数据对我们说这是数据创建一个新合同,当我们做交易,比如添加人或存储数据,我们将通过在我们的相关事务将是数据调用这些函数。

4269
07:24:17.837 --> 07:24:21.646
当我们在醚或Hardhead中调用函数时。

4270
07:24:21.646 --> 07:24:32.250
我们不会做这种原始const, TX，然后列出所有的东西就像这里列出原始数据，对吧?因为这是非常非常难的醚和硬帽会让这个过程容易很多。

4271
07:24:32.250 --> 07:24:43.516
现在，我们继续，注释掉这整个部分，如果我们复制这整个，然后点击Command，斜杠，或者control斜杠，或者其他快捷方式，这就会注释掉这个。

4272
07:24:43.516 --> 07:24:51.556
让我们继续，取消这一节的注释，这样我们就可以使用以太来部署我们的契约，这比这个奇怪的TX更容易阅读。

4273
07:24:51.556 --> 07:24:52.136
哦,很酷。

4274
07:24:52.266 --> 07:24:55.604
所以我们修改了脚本，像这样部署我们的契约。

4275
07:24:55.604 --> 07:25:08.141
现在我们已经部署了我们的契约，我们可以学习如何通过代码与我们的契约交互，就像我们在remix中点击这些按钮一样，我们将在这里为自己编写代码。

4276
07:25:08.141 --> 07:25:13.045
如果我们看符号存储，我们有一个add person for store的按钮。

4277
07:25:13.045 --> 07:25:15.199
然后我们还有这些视图函数。

4278
07:25:15.199 --> 07:25:21.551
最简单的是检索函数，它获取喜爱的数字，检索返回喜爱的数字。

4279
07:25:21.551 --> 07:25:26.066
我们可以在醚类中通过const调用它。

4280
07:25:26.066 --> 07:25:30.999
当前最喜欢的数字等于等待。

4281
07:25:31.267 --> 07:25:32.109
合同。

4282
07:25:32.109 --> 07:25:33.266
我们检索。

4283
07:25:37.267 --> 07:25:45.167
从契约工厂返回的东西，只要我们等待它，契约对象就会附带API中描述的所有功能。

4284
07:25:45.167 --> 07:25:49.317
这就是为什么我们必须把API传递给我们的合同工厂。

4285
07:25:49.317 --> 07:26:00.067
如果我们看一下我们的API部分，我们可以看到它有很多信息关于我们可以调用的不同函数以及它的类型和返回类型等等。

4286
07:26:00.067 --> 07:26:09.496
例如，如果我查检索，我可以看到下面这里，我们有检索，我们可以看到这个函数的名字将被检索。

4287
07:26:09.496 --> 07:26:13.939
输出是un256，类型为Nuun 256。

4288
07:26:13.939 --> 07:26:17.567
这个有点难读，因为它没有格式化。

4289
07:26:17.567 --> 07:26:20.974
因为我们调用这个。API，它会有点难读。

4290
07:26:20.974 --> 07:26:22.912
但我们可以改成。JSON。

4291
07:26:22.912 --> 07:26:30.683
然后你会看到它被高亮了一点，我甚至可以用pretty来设置format document。

4292
07:26:30.683 --> 07:26:36.183
你会看到它的格式现在更容易阅读了，然后返回去检索。

4293
07:26:36.183 --> 07:26:42.530
我们可以看到，这段代码定义了Retrieve函数能做什么和不能做什么。

4294
07:26:42.530 --> 07:26:44.353
我要把它改成艾比。

4295
07:26:44.353 --> 07:26:47.314
看起来我的格式还在，这很好。

4296
07:26:47.314 --> 07:26:49.557
这比以前容易读多了。

4297
07:26:49.557 --> 07:26:55.060
正如我所说，ABI或应用程序二进制接口对于处理我们的契约非常重要。

4298
07:26:55.060 --> 07:27:05.233
如果我们的代码只是这么大的字节码，任何处理器都很难反编译它或者理解这里的函数到底是什么。

4299
07:27:05.267 --> 07:27:10.302
有一些反编译器选项，比如以太VM, IO /反编译。

4300
07:27:10.302 --> 07:27:13.784
这可以将一些字节码反编译到实体中。

4301
07:27:13.784 --> 07:27:17.138
但是要做到完全正确是非常棘手的。

4302
07:27:17.268 --> 07:27:25.183
所以让ABI说，嘿，这一堆代码，这一堆数字和乱糟糟的废话就是这个，要容易得多。

4303
07:27:25.268 --> 07:27:32.203
当我们将这个字节码部署到区块链上，并在上面调用函数时，如果这些函数存在，代码将自动允许调用它们。

4304
07:27:32.203 --> 07:27:36.649
但是为了让我们的代码知道它们的存在，给它一个API要容易得多。

4305
07:27:36.649 --> 07:27:39.590
我们可以得到当前最喜欢的数字，像这样。

4306
07:27:39.590 --> 07:27:44.655
让我们继续，控制台。log，当前最喜欢的数字。

4307
07:27:44.655 --> 07:27:49.300
现在我们已经编辑了这段代码，我们将把它缩小一点。

4308
07:27:49.300 --> 07:28:07.583
现在我们已经编辑了这段代码，我们将连接organ nosh实例，我们将连接一个钱包和我们从ganache顶部获得的私钥，我们将获取ABI和合同的二进制文件，并将它们连接到一个新的合同工厂对象，该对象连接到那个钱包。

4309
07:28:07.583 --> 07:28:18.486
那个钱包将会是实际部署契约的那个，我们会用const contract = await contract factory。deploy来部署契约，我们会等待一个区块让事务完成。

4310
07:28:18.486 --> 07:28:20.705
事实上，我们不打算使用交易收据。

4311
07:28:20.705 --> 07:28:23.767
现在，我们把这部分删掉。

4312
07:28:23.767 --> 07:28:25.895
我们不打算在这里做这些。

4313
07:28:25.895 --> 07:28:27.509
我先把它删掉。

4314
07:28:27.509 --> 07:28:30.220
不过，我将在GitHub回购中将这部分注释掉。

4315
07:28:30.220 --> 07:28:35.471
然后我们会调用契约检索它会返回当前最喜爱的数字。

4316
07:28:35.471 --> 07:28:39.996
因为这是一个视图函数，这个契约调用不会花费我们任何汽油。

4317
07:28:39.996 --> 07:28:45.106
如果我们看一下简单的存储，我们可以看到检索是一个视图函数。

4318
07:28:45.106 --> 07:28:57.853
记住，视图和纯函数，如果在契约函数外部调用不会消耗任何能量，我们只是读取区块链，我们不会改变链上的任何变量，我们不会改变区块链的状态。

4319
07:28:57.853 --> 07:28:59.430
这样就不需要汽油了。

4320
07:28:59.430 --> 07:29:01.983
让我们继续运行这个。

4321
07:29:01.983 --> 07:29:05.697
太好了，我们要出动了，请稍等。

4322
07:29:05.697 --> 07:29:08.197
然后我们得到这个大数字的响应。

4323
07:29:08.197 --> 07:29:15.855
这个大数字的响应是什么?Big number是ethers应用程序附带的一个库，它帮助我们处理数字。

4324
07:29:15.855 --> 07:29:28.062
如果你向下滚动，他们甚至有一个部分说为什么我可以只用数字，你会期望当前最喜欢的数字是0，但它返回这个奇怪的十六进制表示他的大数字为真这个奇怪的大数字。

4325
07:29:28.062 --> 07:29:32.935
所以固体性不能使用小数点，而JavaScript在小数点方面有困难。

4326
07:29:32.935 --> 07:29:46.336
这就是为什么不使用数字的更具体的理由，你会看到很多时候你会看到像0这样的字符串，你会看到JavaScript使用这样的字符串，或者大数字。

4327
07:29:46.336 --> 07:29:53.031
现在，如果我试图在JavaScript中传递一个这样的数字，这个数字太大，JavaScript无法理解。

4328
07:29:53.031 --> 07:29:56.596
所以在处理醚的时候，我们想要使用大的数字或字符串。

4329
07:29:56.596 --> 07:29:59.050
现在我们可以通过添加使它更容易读。

4330
07:29:59.050 --> 07:30:04.075
到字符串的末尾，打印出这个大数字的字符串版本。

4331
07:30:04.075 --> 07:30:17.126
现在，如果我重新运行这段代码，我们可以看到我们得到0，这也是有道理的，因为我们的喜爱的数字被初始化为0值，如果没有指定，而我们还没有调用store。

4332
07:30:17.126 --> 07:30:17.715
所以太棒了。

4333
07:30:17.715 --> 07:30:19.734
所以，这是非常完美的。

4334
07:30:19.734 --> 07:30:22.165
这就是我们目前最喜欢的数字。

4335
07:30:22.269 --> 07:30:25.220
让我们让这个console。log更符合语法。

4336
07:30:25.269 --> 07:30:28.069
我们将使用一种叫做字符串插值的方法。

4337
07:30:28.270 --> 07:30:31.536
我们可以用变量来插值字符串。

4338
07:30:32.270 --> 07:30:34.236
在JavaScript中处理字符串时，使用双引号。

4339
07:30:34.270 --> 07:30:40.673
但是，如果您想将变量与实际字符串混合使用，则可以使用反引号。

4340
07:30:40.673 --> 07:30:47.975
我们会在这里使用一些反勾，我们会在这里说要调用的当前最喜欢的号码。

4341
07:30:47.975 --> 07:30:56.650
为了告诉JavaScript这是一个我们想要读取的变量，我们在它周围加了一个美元符号和一个括号，像这样。

4342
07:30:56.650 --> 07:31:15.320
现在，如果我们再次运行这段代码，它会说，部署，请等待，我们得到当前最喜欢的数字是0，因为JavaScript会说，好，这是一个字符串，美元符号，花括号看起来像是某个变量或者JavaScript你想让我解释它然后关闭它，然后回勾。

4343
07:31:15.320 --> 07:31:15.658
酷。

4344
07:31:15.658 --> 07:31:17.703
所以我们现在最喜欢的数字是0。

4345
07:31:17.703 --> 07:31:17.903
太好了。

4346
07:31:17.903 --> 07:31:22.112
让我们通过调用store函数来更新契约的编号。

4347
07:31:22.112 --> 07:31:30.920
我们写入const，事务响应= await，契约。store，然后加上7。

4348
07:31:30.920 --> 07:31:34.650
因为7是一个很小的数字，你可以像7一样传递它。

4349
07:31:34.650 --> 07:31:37.555
但是像一个字符串中的7一样传递它也可以。

4350
07:31:37.555 --> 07:31:44.056
再说一次，这是因为如果我们想传递一个疯狂的大数字，JavaScript会很混乱。

4351
07:31:44.056 --> 07:31:56.943
所以通常最好的做法是将变量作为字符串传递给契约函数，尽管这可能会有点混乱。醚足够聪明，知道第七个字符串实际上是7这个数字，然后我们可以使用const。

4352
07:31:56.943 --> 07:32:05.609
收到的事务等于等待事务响应，即等待，1。

4353
07:32:05.609 --> 07:32:08.558
我们在这里等一个街区。

4354
07:32:08.558 --> 07:32:16.406
这类似于契约。部署。事务。等等，这里的语法和上面的有点不同。

4355
07:32:16.406 --> 07:32:17.795
因为这是使用代工厂。

4356
07:32:17.795 --> 07:32:20.686
这是在契约上调用一个函数。

4357
07:32:20.686 --> 07:32:24.849
因此，当我们调用契约上的函数时，我们得到一个事务响应。

4358
07:32:24.849 --> 07:32:28.908
当我们等待事务响应完成时，我们将获得事务收据。

4359
07:32:28.908 --> 07:32:37.271
现在我可以用const, updated, favorites 2 = await on track。retrieve。

4360
07:32:37.271 --> 07:32:40.886
然后是console。log updated。

4361
07:32:40.886 --> 07:32:52.202
最喜欢的数字是，我们会做一点字符串插值，更新，最喜欢的数字是这样的?现在让我们继续运行它。

4362
07:32:52.202 --> 07:33:02.561
在这个过程中，我们会部署合约，获取初始值，我们会调用store来更新合约这将消耗gas。

4363
07:33:02.561 --> 07:33:18.287
这是一个交易，我们会得到交易响应，然后我们会得到交易收据，我们不会对交易收据做任何事情，我想让你们知道这两个是不同的交易响应和交易收据，你们以后会明白为什么。

4364
07:33:18.287 --> 07:33:21.754
然后我们会得到更新后的收藏夹号码，然后我们会把它打印出来。

4365
07:33:21.754 --> 07:33:23.124
我们来做这个。

4366
07:33:23.124 --> 07:33:24.575
嘣，完美。

4367
07:33:24.575 --> 07:33:30.554
正在部署中，请稍候，当前收藏编号为0，更新收藏编号为7。

4368
07:33:30.554 --> 07:33:45.969
到ganache实例，到交易，可以看到，顶部有合约调用，有sender，合约地址，汽油价格，所有这些，交易数据在这里。

4369
07:33:45.969 --> 07:33:50.714
这个事务数据是在事务对象的数据槽中发送的。

4370
07:33:50.714 --> 07:33:56.951
乙醚只是在后端为我们做这些所以我们不需要在那里创建大的事务对象。

4371
07:33:56.951 --> 07:33:58.026
好吧，太棒了。

4372
07:33:58.026 --> 07:34:07.532
您已经成功地将契约部署到自己的本地ganache实例或自己的JavaScript虚拟机。

4373
07:34:07.532 --> 07:34:09.053
这太棒了。

4374
07:34:09.272 --> 07:34:10.933
现在我们把它整理一下。

4375
07:34:12.272 --> 07:34:25.562
我们有我们的连接区块链和我们的私钥直接存储在我们的代码中，我们将这段代码推到GitHub或其他一些代码库，如果你愿意，将能够看到我们的代码。

4376
07:34:25.562 --> 07:34:33.126
如果我们查看我代码的ploy。js，这里还有别的东西，我们实际上没有看到私钥或RPC URL。

4377
07:34:33.126 --> 07:34:38.644
这是怎么回事?记住，如果你泄露了你的私钥，谁有你的私钥谁就拥有你的资金。

4378
07:34:38.644 --> 07:34:49.061
即使这是一个假的私钥，里面没有真正的钱，我们还是不想硬编码我们的私钥到代码中，以防我们不小心和别人共享代码。

4379
07:34:49.061 --> 07:34:55.647
那么我们能做什么呢?其中一个最流行的方法是创建一个叫做。EMV文件或环境变量的东西。

4380
07:34:55.647 --> 07:35:02.367
如果你熟悉环境变量，你可以在终端中设置它们，但我们会在。env中设置它们。

4381
07:35:02.367 --> 07:35:05.698
你要做的是创建一个。env文件。

4382
07:35:05.698 --> 07:35:09.322
这是一个你储存敏感信息的文件。

4383
07:35:09.322 --> 07:35:12.990
这将是一份文件，我们永远不会和任何人分享。

4384
07:35:12.990 --> 07:35:18.072
这个点env文件将把我们选择的变量插入到代码的环境中。

4385
07:35:18.072 --> 07:35:28.457
举个例子，如果我把终端拉上来，然后输入echo cat，这将反映cat环境变量的值。

4386
07:35:28.457 --> 07:35:31.273
现在还没有猫的环境变量。

4387
07:35:31.273 --> 07:35:41.950
然而，如果我输入export, cat = dog，然后我输入echo $ sign cat，我得到dog输出。

4388
07:35:41.950 --> 07:35:57.595
这就是环境变量，它是终端或脚本环境中的变量，因为我不想输入export，私钥等于等等，每次，我们要做的是将它们插入到这个。env文件中。

4389
07:35:57.595 --> 07:36:02.073
当这个。env，我们可以输入私钥等于。

4390
07:36:02.073 --> 07:36:07.813
我们可以从脚本中获取这个私钥，像这样粘贴进来。

4391
07:36:07.813 --> 07:36:20.580
注意，有些工具会在私钥醚的开头查找0x，而硬帽足够聪明，两者都可以，但如果你遇到了一些问题，要知道有时你可能需要把0x放在前面。

4392
07:36:20.580 --> 07:36:20.856
太好了。

4393
07:36:20.856 --> 07:36:22.873
现在我们在环境变量中有一个私钥。

4394
07:36:22.873 --> 07:36:25.382
我们现在怎么办?在我们的部署中。

4395
07:36:25.382 --> 07:36:33.606
Js，我们想抓取这个环境变量并把它插入到我们的脚本中，这样我们的脚本就能把它插入到我们的环境中。

4396
07:36:33.606 --> 07:36:35.885
我们要添加一个叫做。env的工具。

4397
07:36:35.885 --> 07:36:40.148
为了让它更简单，我们将使用yarn，添加。env。

4398
07:36:40.148 --> 07:36:47.220
如果我们看一下。env包，可以阅读更多关于它的内容，以及如何用NPM添加它。

4399
07:36:47.273 --> 07:36:49.442
同样，我们只是使用纱线添加。

4400
07:36:51.273 --> 07:36:53.083
这需要点E和V的点配置。

4401
07:36:54.273 --> 07:36:56.862
所有的环境变量。

4402
07:36:59.273 --> 07:37:04.527
点EMV配置，我们应该在我们的包中看到JSON，我们看到。

4403
07:37:04.527 --> 07:37:05.035
太好了。

4404
07:37:05.035 --> 07:37:14.636
现在我们把它拉进来了，我们实际上可以访问私钥环境变量，你可以在JavaScript中访问环境变量，使用process。EMV。

4405
07:37:14.636 --> 07:37:35.086
我们不把私钥放在这里，而是把整个都删掉用process。EMV替换私钥，然后保存，它会重新格式化以确保它能正常工作，我们可以在保存后点击，往上往上往上，回到no deploy to Jas。

4406
07:37:35.086 --> 07:37:37.523
我们看到我们得到了完全相同的设置。

4407
07:37:37.523 --> 07:37:41.515
如果我们回滚，你可以看到一个交易确实进行了。

4408
07:37:41.515 --> 07:37:54.601
如果你想再次检查这是否打印出了你的私钥，我们可以执行console。log，按study通过运行私钥，我们可以看到私钥确实来自于环境变量。

4409
07:37:54.601 --> 07:37:55.256
太棒了。

4410
07:37:55.256 --> 07:38:06.007
我们的RPC URL并不是我们需要保护的东西，也许我们会使用一个特定的API键或者一个只有我们想要访问的端点。

4411
07:38:06.007 --> 07:38:08.627
我们不希望任何人使用我们的RPC端点。

4412
07:38:08.627 --> 07:38:12.197
我们也要把这个添加到。env文件中。

4413
07:38:12.197 --> 07:38:13.581
在。env中。

4414
07:38:13.581 --> 07:38:22.177
复制这个时，我要说RPC URL =，然后粘贴到这里，就像这样。

4415
07:38:22.274 --> 07:38:23.580
我们把这里删掉。

4416
07:38:25.274 --> 07:38:28.369
例如，process。env。RPC URL。

4417
07:38:30.274 --> 07:38:30.940
再运行一次。

4418
07:38:33.274 --> 07:38:42.499
我们应该得到完全相同的响应，因为我们所做的只是用环境变量替换RPC URL，这将与之前完全相同。

4419
07:38:42.499 --> 07:38:45.379
所以我们继续运行这个，我们得到了完全相同的响应。

4420
07:38:45.379 --> 07:38:51.460
如果我们去ganache，我们看到我们确实得到了一个交易，这是完美的。

4421
07:38:51.460 --> 07:38:52.052
太棒了。

4422
07:38:52.052 --> 07:38:56.878
我们已经学习了如何向点环境文件中添加环境变量。

4423
07:38:56.878 --> 07:39:05.791
以防万一，我们想要共享我们的代码，或者我们把我们的代码推到GitHub，我们会在后面的章节中做，我们不会意外地暴露我们的私钥或RPC url。

4424
07:39:05.791 --> 07:39:15.597
现在我们项目中的所有代码，如果我们把它推到GitHub，或者和别人共享，所有这些代码都会被推到GitHub，包括我们的。env文件。

4425
07:39:15.597 --> 07:39:22.493
但是，如果你看一下我这门课的代码示例，你会发现这里没有。env文件。

4426
07:39:22.493 --> 07:39:30.190
这怎么可能呢?无论什么项目，我们都要创建一个。gitignore文件。

4427
07:39:30.275 --> 07:39:32.408
在这里，我们要代入v。

4428
07:39:34.275 --> 07:39:35.147
节点模块。

4429
07:39:38.275 --> 07:39:43.758
使用版本控制，这我们稍后会做，我们不会把。env文件推送到GitHub。

4430
07:39:43.758 --> 07:39:45.989
我们也不会推入已知的模块。

4431
07:39:45.989 --> 07:39:56.978
如果我们回到我的例子，我们没有看到。env文件，但是我们看到了一个。env。的例子，只是给你们展示一下它是什么样的。

4432
07:39:56.978 --> 07:40:01.118
所以我把它们放在这里并不重要。

4433
07:40:01.275 --> 07:40:05.681
现在，如果您非常偏执，那么在运行脚本和运行命令时，实际上还可以做一些其他事情。

4434
07:40:05.681 --> 07:40:12.560
假设您不想将私钥放入。env文件中，因为您担心会不小心将其推到上面。

4435
07:40:12.560 --> 07:40:18.647
您所能做的就是在RPC URL中添加您的私钥，作为命令行中的环境变量。

4436
07:40:18.647 --> 07:40:27.608
在运行Node deploy之前，你也可以这么做，你可以说RPC URL =，粘贴你的RPC。

4437
07:40:27.608 --> 07:40:31.275
然后你可以说私钥。

4438
07:40:31.275 --> 07:40:36.937
等于，然后粘贴您的私钥，然后执行节点部署。

4439
07:40:36.937 --> 07:40:37.106
js。

4440
07:40:37.276 --> 07:40:41.921
在运行脚本之前设置它们与在。env中设置它们完全相同。

4441
07:40:41.921 --> 07:40:48.294
如果我们点击run，我们会看到完全相同的输出，这意味着我们的RPC URL和私钥成功通过。

4442
07:40:48.294 --> 07:40:50.176
对于密钥管理来说，这种方式很好。

4443
07:40:50.176 --> 07:40:52.964
但我们这样做的权利，会更好。

4444
07:40:52.964 --> 07:41:04.974
但这还是让我有点紧张在我们的开发环境中用假私钥，把代码放在这样的。env文件中是可以的，对吧?因为我们不在乎这把钥匙是否被黑，就像没人用它一样。

4445
07:41:04.974 --> 07:41:08.663
但当我们搬到一个更专业的环境时，这可能会有点可怕。

4446
07:41:08.663 --> 07:41:17.226
那么，我们怎样才能使它更加安全呢?我们能做的是加密私钥并将加密密钥存储在本地。

4447
07:41:17.276 --> 07:41:24.259
这样的话，如果有人因为某种原因进入了我们的账户，我们的私钥就不会以纯文本的形式存在，而是被加密了。

4448
07:41:24.259 --> 07:41:27.568
你需要知道一个只有你知道的密码才能进入。

4449
07:41:27.568 --> 07:41:34.854
怎么加呢?首先，我们要创建一个名为encrypt key的新文件。

4450
07:41:34.854 --> 07:41:35.072
js。

4451
07:41:35.072 --> 07:41:39.228
这是一些我们将要用来加密密钥的代码。

4452
07:41:39.276 --> 07:41:41.977
我们会将它存储在本地而不是纯文本形式的私钥。

4453
07:41:41.977 --> 07:41:47.479
这将使我们更加安全，这样私钥就不会以纯文本的形式挂在这里。

4454
07:41:47.479 --> 07:41:50.636
因此，让我们继续构建脚本来加密我们的私钥。

4455
07:41:50.636 --> 07:41:53.485
因此，我们将使用与部署脚本完全相同的设置。

4456
07:41:53.485 --> 07:41:56.876
我们要做一个async函数main。

4457
07:41:57.276 --> 07:42:00.050
然后在下面这里，我将继续复制部署js。

4458
07:42:00.050 --> 07:42:03.405
我们将使用完全相同的设置，并粘贴它。

4459
07:42:03.405 --> 07:42:04.179
好了,好了。

4460
07:42:04.179 --> 07:42:07.799
我们要用醚J s r点乘E V。

4461
07:42:07.799 --> 07:42:18.552
所以我们要把这些加到const ethers = require ethers const FS = require FS extra。

4462
07:42:18.552 --> 07:42:22.221
然后require。env。

4463
07:42:22.221 --> 07:42:23.128
配置。

4464
07:42:23.128 --> 07:42:29.047
现在，在。env中，我们有这个私钥。

4465
07:42:29.047 --> 07:42:37.324
如果你不想以他们的方式获得私钥你可以这样做你可以输入私钥等于然后你知道，节点，任何你想运行的脚本。

4466
07:42:37.324 --> 07:42:41.277
我们将设置这个脚本来运行加密密钥一次。

4467
07:42:41.277 --> 07:42:46.975
然后我们可以从工作区的任何地方删除私钥这样它就不再是纯文本了。

4468
07:42:46.975 --> 07:42:54.358
我们想做的是我们想说const wallet，我们会创建一个新的wallet，但有一点不同。

4469
07:42:54.358 --> 07:43:01.131
我们写入= new醚。钱包，进程。E和V。私钥。

4470
07:43:01.131 --> 07:43:04.725
这里需要私钥。

4471
07:43:04.725 --> 07:43:10.018
但一旦我们创建了这个钱包，我们会说const。

4472
07:43:10.018 --> 07:43:25.218
Encrypted JSON key = await ethers。encrypt，这个encrypt函数会返回一个加密的JSON key我们可以在本地存储它我们只能用密码解密它。

4473
07:43:25.218 --> 07:43:26.922
它有两个参数。

4474
07:43:26.922 --> 07:43:30.147
它需要一个私钥密码和一个私钥。

4475
07:43:30.277 --> 07:43:35.023
在。EMV中，我们要创建一个私钥密码。

4476
07:43:35.023 --> 07:43:37.800
我要说这是密码。

4477
07:43:37.800 --> 07:43:39.543
但显然，这是一个糟糕的密码。

4478
07:43:39.543 --> 07:43:41.657
你不应该用密码作为你的密码。

4479
07:43:41.657 --> 07:43:46.229
但现在，我们还是把它作为密码吧因为我要加密这个大密钥。

4480
07:43:46.277 --> 07:43:51.760
我们将通过密码过程研究和v点私钥密码来加密它。

4481
07:43:51.760 --> 07:43:57.851
我们还会传递私钥，它是ethers，它是wallet。encrypt。

4482
07:43:57.851 --> 07:44:01.920
我们还会传递process。EMV。private key。

4483
07:44:01.920 --> 07:44:04.998
现在让我们继续运行它。

4484
07:44:04.998 --> 07:44:11.833
然后我们用console。log注销这个加密的JSON键看看运行时会发生什么。

4485
07:44:11.833 --> 07:44:15.435
要运行这个，我们要执行，node, encrypt key。

4486
07:44:15.435 --> 07:44:15.575
js。

4487
07:44:15.575 --> 07:44:16.545
然后回车。

4488
07:44:16.545 --> 07:44:23.932
我们会看到控制台注销后会发生什么这个JSON对象是密钥加密后的样子。

4489
07:44:23.932 --> 07:44:28.362
它有地址这个ID版本，所有这些东西。

4490
07:44:28.362 --> 07:44:32.182
所有这些都是这个密钥的加密版本。

4491
07:44:32.182 --> 07:44:42.900
如果有人进入我们的账户看到了这个，他们需要知道密码来解密这个私钥，他们需要知道密码来解密这个JSON对象到一个私钥。

4492
07:44:42.900 --> 07:44:47.084
现在我们要做的是，我们已经加密了，我们要保存它。

4493
07:44:47.084 --> 07:44:59.166
我们会写Fs。write，文件同步，我们会传递给。/。encrypted key。JSON，逗号encrypted JSON key。

4494
07:44:59.278 --> 07:45:02.528
我们将它保存到一个新文件名为。encrypted key。JSON。

4495
07:45:02.528 --> 07:45:06.153
然后传递给它我们刚做的加密密钥。

4496
07:45:06.278 --> 07:45:15.544
如果我们打开文件资源管理器，运行这个命令，你会看到我们得到一个新文件叫做。encrypted key。JSON。

4497
07:45:15.544 --> 07:45:18.944
就是这个加密密钥，太棒了。

4498
07:45:18.944 --> 07:45:28.850
现在我们要在。gitignore中做的是add。encrypted key。JSON，这样我们就不会不小心把这个推到GitHub。

4499
07:45:28.850 --> 07:45:34.754
现在我们有了加密密钥我们可以从。env文件中删除私钥。

4500
07:45:34.754 --> 07:45:41.244
我们还可以从WMV文件中删除私钥密码，这样密码就不会以纯文本的形式存在。

4501
07:45:41.279 --> 07:45:43.442
既然我们有加密的密钥。

4502
07:45:45.279 --> 07:45:48.569
我们可以改变我们实际获得钱包的方式。

4503
07:45:49.279 --> 07:45:56.691
Top，我们通过这样传递私钥来获取钱包，我们不会这样做，我们会使用我们刚创建的加密密钥。

4504
07:45:56.691 --> 07:46:05.379
我们要做的是写入const encrypted JSON = Fs。read file sync。

4505
07:46:05.379 --> 07:46:20.586
这个斜杠。encrypted key。JSON，逗号utf8，这个Fs。read file sync将从加密的key。JSON读取到加密的JSON变量中。

4506
07:46:20.586 --> 07:46:25.517
接下来，我们将用这个加密的密钥创建一个钱包。

4507
07:46:25.517 --> 07:46:35.079
我们写入，let wallet = new醚。wallet。fromencrypted JSON sync。

4508
07:46:35.079 --> 07:46:48.517
所有这些与醚相关的命令，我们都能在加密的JSON同步文档中找到它们同步获取加密的JSON和一个密码，并返回一个钱包对象。

4509
07:46:48.517 --> 07:46:52.589
我们将把刚读过的加密JSON传递给它。

4510
07:46:52.589 --> 07:47:00.769
然后我们要传递它password我们要做的是process。EMP。private key password。

4511
07:47:00.769 --> 07:47:07.725
最后，这里用let的原因是我们需要将这个钱包连接回提供者。

4512
07:47:07.725 --> 07:47:10.625
如果你看这里，我们并没有将钱包与供应商连接。

4513
07:47:10.625 --> 07:47:16.422
当我们与合同工厂进行交易时，我们需要确保钱包知道这里的提供者。

4514
07:47:16.422 --> 07:47:22.946
我们可以说，wallet = await wallet。connect provider。

4515
07:47:22.946 --> 07:47:30.555
现在，如果我们使用私钥密码作为环境变量运行deploy. j s，它仍然应该部署。

4516
07:47:30.555 --> 07:47:34.787
私钥密码=密码，这很糟糕。

4517
07:47:34.787 --> 07:47:50.002
这就是我们现在使用的，node deploy。js，我们得到的输出应该和我们一直以来看到的一样我们不再把私钥放在。env文件中不再是明文形式，而是这个加密密钥。

4518
07:47:50.002 --> 07:47:56.683
以防有人入侵我们的电脑，除非他们知道密码，否则他们仍然无法发送新的交易。

4519
07:47:56.683 --> 07:47:57.457
这太棒了。

4520
07:47:57.457 --> 07:48:07.618
还有一件事要知道，如果你输入历史，如果有人进入了你的电脑，黑客会在你的bash历史中看到私钥密码等于密码。

4521
07:48:07.618 --> 07:48:12.565
如果你运行历史，破折号c，你会清除历史。

4522
07:48:12.565 --> 07:48:20.589
现在如果我输入history，我只能看到我最近写的命令是history，这真的只是加密和保护密钥安全的最基本的一些。

4523
07:48:20.589 --> 07:48:25.873
有人能黑进你的电脑，读取你的加密私钥，这似乎很荒谬。

4524
07:48:25.873 --> 07:48:38.473
但随着项目越来越大，了解私钥安全性和私钥安全性非常重要，这门课只讲最基本的内容告诉大家如何加密密钥如何更安全。

4525
07:48:38.473 --> 07:48:46.192
在接下来的课程中，我们将只使用这种语法和。env文件中的私钥。

4526
07:48:46.280 --> 07:48:55.346
在接下来的课程中我们这样做的原因是它更简单，我真的希望Hardhead增加一些额外的特性使私钥加密更安全也更容易在未来使用。

4527
07:48:55.346 --> 07:48:56.412
他们很可能会。

4528
07:48:56.412 --> 07:49:09.055
我们可以这么做的另一个原因是你们已经郑重宣誓过在这门课期间你们不会使用一个有任何真钱的账户，你们只会使用在Aetherium上有测试的私钥或者像我们从ganache那里得到的这个假私钥。

4529
07:49:09.055 --> 07:49:22.131
事实上，我只是想在智能合约工具中进一步完善这个，在solidity课程中完全阻塞，Jas GitHub repo在讨论选项卡中，你去到公告，我创建了一个叫。end pledge。

4530
07:49:22.131 --> 07:49:29.246
因为最近我看到太多的人跟随一个教程，而这个教程并没有告诉他们这样做的安全风险。

4531
07:49:29.246 --> 07:49:33.229
我已经做了这个。EMV的承诺，我希望每个人都能跳上去阅读。

4532
07:49:33.281 --> 07:49:42.412
如果你同意，在下面留下评论，说我会很安全的，我会很安全的，确保你阅读了，你明白这里发生了什么。

4533
07:49:42.412 --> 07:49:44.182
我这么做不是为了吓你。

4534
07:49:44.281 --> 07:49:52.979
因为，在一天结束的时候，如果你使用Metamask，它只包含在这门课程期间资助的测试，你永远都不用担心你的密钥被泄露。

4535
07:49:52.979 --> 07:49:54.121
只是测试一下。

4536
07:49:54.121 --> 07:49:59.156
谁在乎呢?如果你使用的是元掩码或者你使用的是有资金的元掩码。

4537
07:49:59.156 --> 07:50:03.055
所以我要读一下誓言，因为它真的很重要。

4538
07:50:03.055 --> 07:50:05.603
当你和真正的基金打交道时，你就会明白这一点。

4539
07:50:05.603 --> 07:50:10.625
如果你说，嘿，我没有和真正的基金合作，我不在乎，很好，不管怎样。

4540
07:50:10.625 --> 07:50:16.471
但是当你用真正的资金工作时，当你决定，嘿，我真的想把它部署到一个真正的网络上。

4541
07:50:16.471 --> 07:50:18.330
现在我需要真钱。

4542
07:50:18.330 --> 07:50:19.969
回到这个誓言上来。

4543
07:50:19.969 --> 07:50:24.531
滚动底部，说我将是安全的，并确保你阅读和理解这一点。

4544
07:50:24.531 --> 07:50:35.197
好吧，我的承诺是，我郑重发誓我绝不会在任何与真正资金有关的。env文件中放入私钥或秘密短语或肺炎。

4545
07:50:35.197 --> 07:50:41.282
基本上，你基本上不会有你的私钥或你的肺炎短语，以纯文本的形式，在任何地方。

4546
07:50:41.282 --> 07:50:49.068
你们都只将私钥放在一个只测试过FF链接或其他加密货币的web文件中。

4547
07:50:49.068 --> 07:50:53.082
因为如果你的私钥只有测试净资金，那就太好了。

4548
07:50:53.082 --> 07:51:07.832
我不在乎，我们知道如果我们忘记了一个。Git忽略，我们把我们的关键短语推到GitHub，即使是一秒钟，或者甚至在互联网上显示我们的关键斜杠短语，无论它可能在一秒钟，它应该被认为是折衷的。

4549
07:51:07.832 --> 07:51:10.340
你应该立即取出所有资金。

4550
07:51:10.340 --> 07:51:21.427
所以即使你部署了你的私钥到一个网站，然后立即删除你的网站，你会想，哦，可能没有人访问过它，你应该认为私钥泄露了，你应该删除你所有的资金。

4551
07:51:21.427 --> 07:51:23.467
再说一次，这只是针对真正的基金。

4552
07:51:23.467 --> 07:51:25.832
如果只测试了您的私钥，资金就会受到损害。

4553
07:51:25.832 --> 07:51:30.832
谁在乎呢?我一直这么做，你们一直看到我这么做，因为它只包含测试基金。

4554
07:51:30.832 --> 07:51:37.413
如果在这门课结束的时候，你想偷走我所有的测试资金，我的意思是，尽情享受吧，这对我来说最坏的情况是很烦人的。

4555
07:51:37.413 --> 07:51:42.560
如果我不确定我的账户里是否有真正的资金，我会假设它有真正的资金。

4556
07:51:42.560 --> 07:51:47.904
所以如果你不知道它是否有真正的资金，假设它有真正的资金，你就不会把它用于开发目的。

4557
07:51:47.904 --> 07:52:02.710
最后，我意识到，即使我点击添加帐户在我的元掩码或其他eath钱包，我将得到一个新的私钥，但它将共享相同的秘密短语slash pneumonic在元掩码或其他eath钱包中生成的所有其他帐户。

4558
07:52:02.710 --> 07:52:09.734
如果我在元掩码中，点击创建账户，我会得到新账户的新私钥。

4559
07:52:09.734 --> 07:52:17.267
然而，我用“创建帐户”按钮创建的所有这些帐户都有完全相同的肺炎短语或秘密短语。

4560
07:52:17.267 --> 07:52:21.731
如果我导入一个有私钥的账户，它会有一个不同的肺炎短语。

4561
07:52:21.731 --> 07:52:25.861
但是我在钱包里生成的所有的都有相同的短语。

4562
07:52:25.861 --> 07:52:26.492
好了,好了。

4563
07:52:26.492 --> 07:52:28.018
希望这讲得通。

4564
07:52:28.018 --> 07:52:29.713
我这里有一些附加的承诺。

4565
07:52:29.713 --> 07:52:35.266
对于这个过程，我只会使用资金与一个全新的从未使用过元掩码或其他eath钱包。

4566
07:52:35.266 --> 07:52:45.057
再次强调，这并不是要吓到你，如果你只是使用一个全新的元掩码，你不必担心任何这些，只需要在你开始查看真正的钱和真正的私钥时参考它。

4567
07:52:45.057 --> 07:52:51.181
我知道我的帐户与我的私钥在测试网上是相同的，它是在主网上。

4568
07:52:51.181 --> 07:53:15.546
就像我告诉你,我的私钥Rinkeby是一样的我私钥主要净,如果我必须使用私钥与真正的基金在未来,直到我100%确定我做什么,我总是会使用其中一个加密的方法,帕特里克给你们一些更好的加密的东西我没有展示或使用命令行方式通过私钥,然后删除命令行历史之后。

4569
07:53:15.546 --> 07:53:19.655
如果我没有实际部署任何东西来实现它或者使用真正资金的私钥。

4570
07:53:19.655 --> 07:53:21.180
我不需要担心。

4571
07:53:21.283 --> 07:53:22.217
看看这个。

4572
07:53:24.283 --> 07:53:24.944
你有信心。

4573
07:53:27.283 --> 07:53:32.473
我说这些是为了给你们灌输信心这些是我们需要思考的问题。

4574
07:53:32.473 --> 07:53:33.044
好了,好了。

4575
07:53:33.044 --> 07:53:37.092
在这里，我会很安全。

4576
07:53:37.283 --> 07:53:38.638
砰，我就安全了。

4577
07:53:41.283 --> 07:53:43.425
推特，把这个放到一个巨大的推特线程里。

4578
07:53:43.425 --> 07:53:43.960
放手去做吧。

4579
07:53:44.283 --> 07:53:51.819
了解这一点的人越多，了解他们的WMV文件和私钥的安全风险的人越多，就越好。

4580
07:53:51.819 --> 07:53:53.694
感谢大家的聆听。

4581
07:53:53.694 --> 07:53:57.231
我知道我肯定夸大了这一点，但它真的很重要。

4582
07:53:57.284 --> 07:53:59.784
让我们继续这门课。

4583
07:54:02.284 --> 07:54:02.705
在这里完成。

4584
07:54:05.284 --> 07:54:10.431
现在把这些都清理一下当我们在自动保存时，VS code插件可以自动格式化。

4585
07:54:10.431 --> 07:54:17.801
但是，在将来，如果其他人遇到我们的存储库，他们可能没有Vyas代码的自动格式或开启。

4586
07:54:17.801 --> 07:54:20.534
所以我们想给用户一种格式化他们代码的方法。

4587
07:54:20.534 --> 07:54:22.827
所以它与我们使用的风格相匹配。

4588
07:54:22.827 --> 07:54:26.265
所以我们有漂亮的扩展安装。

4589
07:54:26.265 --> 07:54:38.227
我们还可以添加pretty tier作为Node js模块，它可以告诉其他没有Vyas代码的用户如何准确地格式化他们的JavaScript和坚固性。

4590
07:54:38.284 --> 07:54:43.336
这里有一个更漂亮的插件，在我们的GitHub回购中有一个链接。

4591
07:54:43.336 --> 07:54:58.939
向下滚动，我们可以看到如何使用npm install dash save Dev来安装，同样，我们将使用yarn，我们将使用yarn，然后添加更漂亮的插件solidity。

4592
07:54:58.939 --> 07:55:04.509
我们同时安装了pretty tier和solidity插件。

4593
07:55:04.509 --> 07:55:08.398
如果我们检查我们的包JSON，我们可以看到这两个已经被添加了。

4594
07:55:08.398 --> 07:55:15.606
我们现在能做的是创建一个新文件叫做。pretty, R。C。

4595
07:55:15.606 --> 07:55:20.122
在这个文件中，我们可以定义一些花括号。

4596
07:55:20.122 --> 07:55:31.962
在这里，我们可以为我们的实体性和JavaScript定义我们想要的东西，例如，我们的简单存储的制表符宽度为412344个空格。

4597
07:55:31.962 --> 07:55:35.703
也许我们应该改变这一点。

4598
07:55:35.703 --> 07:55:38.742
我们希望制表符宽度为2。

4599
07:55:38.742 --> 07:55:46.983
我们会把它保存在这里，然后回到简单存储，保存到这里，它会自动格式化为r。pretty RC。

4600
07:55:46.983 --> 07:55:57.427
在我们的设置中，我们有默认的solidity编辑器，我们的硬帽，solidity插件，默认的meta JavaScript是更漂亮的。

4601
07:55:57.427 --> 07:56:11.006
代码一，当我们在这里添加更漂亮的RC时，这个文件将优先于默认配置，只要我们下载了节点模块中的模块，我们可以在这里看到它。

4602
07:56:11.006 --> 07:56:14.120
我们有这个。pretty rc文件。

4603
07:56:14.285 --> 07:56:16.006
我要用表格结账。

4604
07:56:17.285 --> 07:56:34.538
我们现在有一件事我不喜欢那就是末尾的分号，所以我们要做semi - boss，我要保存它，回来部署保存你会看到分号自动消失了。

4605
07:56:34.538 --> 07:56:42.336
我还要加上use制表符false，因为我想使用空格，然后加上单引号false。

4606
07:56:42.336 --> 07:56:55.234
这样，我们总是用双引号，而不是单引号，在JavaScript中，你可以用单引号或双引号，来定义字符串，但我们要这样做，无论你用什么引号，它都是双引号。

4607
07:56:55.285 --> 07:57:01.300
然后，对于所有的开源回购，以及所有的项目，都需要自述文件。

4608
07:57:01.300 --> 07:57:07.285
Md自述文件通常是人们放置关于你的项目的指令或信息或类似东西的地方。

4609
07:57:07.285 --> 07:57:22.841
这样一来，当任何人看到你的项目时，他们就会知道你的readme。MDs，我们的Markdown语法是怎么回事，记得我们在试着讨论的时候，我们使用了一些有趣的技巧来格式化代码中的实体性。

4610
07:57:22.841 --> 07:57:26.389
格式化的过程是完全一样的。

4611
07:57:26.389 --> 07:57:27.786
Md文件进行记录。

4612
07:57:27.786 --> 07:57:29.973
他们都将使用降价。

4613
07:57:29.973 --> 07:57:37.995
事实上，如果我们按Ctrl, Shift V，你会进入标记的预览模式你会在我的头盔预览中看到#号。

4614
07:57:37.995 --> 07:57:40.730
这醚简单的存储FCC是巨大的。

4615
07:57:40.730 --> 07:57:43.714
它看起来像一个标题在顶部。

4616
07:57:43.714 --> 07:57:46.253
按Command Shift V查看你的。

4617
07:57:46.253 --> 07:57:53.163
Windows和Linux用户使用“Ctrl”、“Shift V”。

4618
07:57:53.286 --> 07:58:01.882
我们要做的最后一件事是我们要把它部署到一个测试网上并在测试网上与它交互，我们要使用林克比测试网上。

4619
07:58:01.882 --> 07:58:07.777
但是一定要使用GitHub仓库推荐的测试网。

4620
07:58:07.777 --> 07:58:14.692
现在看一下我们的代码，您可能已经对如何实际进行这个细微的更改有了很好的了解。

4621
07:58:14.692 --> 07:58:22.105
根据上一节的内容，我们知道我们只需要一个RPC URL和一个私钥，就可以开始在区块链上进行事务处理了。

4622
07:58:22.105 --> 07:58:27.436
我们可能需要一个rinkbrpc URL，和一个rink私钥。

4623
07:58:27.436 --> 07:58:41.777
我们在哪能找到这两个，如果你想自己做所有事情，在完全去中心化的环境中，我们可以运行一个rink B版本的geth，我们可以本地运行它，然后连接到我们的来宾节点，我们不打算在这里展示怎么做。

4624
07:58:41.777 --> 07:58:44.238
但是，这是100%可以做到的。

4625
07:58:44.238 --> 07:58:49.897
相反，我们将在与本课程相关的GitHub回购中使用第三方RPC URL。

4626
07:58:49.897 --> 07:58:56.008
转到第五课，我们可以向下滚动找到炼金术的链接。

4627
07:58:56.008 --> 07:59:05.565
Alchemy有一个节点作为服务，并允许我们连接到任何他们支持的区块链，两个替代方案可能是quick node、Morales或infura。

4628
07:59:05.565 --> 07:59:07.787
这些都有节点作为服务选项。

4629
07:59:07.787 --> 07:59:19.575
但我们将与Alchemy合作，因为它是我最喜欢的一个，我们可以继续，免费开始，或者登录或创建一个新帐户，我将继续，注册我们的硬帽free Code Camp用户。

4630
07:59:19.575 --> 07:59:23.254
我们将选择以太坊区块链生态系统。

4631
07:59:23.254 --> 07:59:25.189
让我们继续创建第一个应用程序。

4632
07:59:25.287 --> 07:59:28.434
这将是我们称之为自由代码营。

4633
07:59:28.434 --> 07:59:28.893
RT的帽子。

4634
07:59:29.287 --> 07:59:38.445
app的名字是以太，简单存储，FCC，网络是我们选择溜冰场B的地方。

4635
07:59:38.445 --> 07:59:45.703
但是你可以看到，我们实际上可以选择的不仅仅是溜冰场B，我们可以选择真正的科万，溜冰场B, ropsten。

4636
07:59:45.703 --> 07:59:50.382
第二层，套利和乐观，我们将使用溜冰场B。

4637
07:59:50.382 --> 07:59:52.474
我们来创建这个应用。

4638
07:59:52.474 --> 07:59:55.811
我们将选择免费计划并点击Continue。

4639
07:59:55.811 --> 07:59:58.171
我们将跳过增加支付。

4640
07:59:58.171 --> 08:00:02.483
如果您想tweet您的推荐代码，请随意tweet您的推荐代码。

4641
08:00:02.483 --> 08:00:03.860
我们先跳过。

4642
08:00:03.860 --> 08:00:06.172
我们会把它的容量保持在上限。

4643
08:00:06.172 --> 08:00:08.631
因为我们没有我们这里没有钥匙。

4644
08:00:08.631 --> 08:00:13.693
然后你是怎么知道我们的在Patrick And Free Code Camp上喊我的然后点击Let's go。

4645
08:00:13.693 --> 08:00:22.524
现在我们来到了炼金术仪表板，在这里我们可以看到大量关于节点的信息以及连接到节点的不同方式等等。

4646
08:00:22.524 --> 08:00:33.838
这和ganache的RPC服务器端点非常相似，只是它是一个连接，只是它是一个连接到真实测试网或真实主网的连接。

4647
08:00:33.838 --> 08:00:38.884
我们现在能做的是选择我们刚制作的app。

4648
08:00:38.884 --> 08:00:40.494
我们可以按View键。

4649
08:00:40.494 --> 08:00:45.716
我们可以看到这里我们得到一个API key key，我们添加一个HTTP端点我们也得到一个WebSocket。

4650
08:00:45.716 --> 08:00:48.703
我们只关心HTTP端点。

4651
08:00:48.703 --> 08:00:52.583
这将是连接到溜冰场B的RPC URL。

4652
08:00:52.583 --> 08:00:57.960
我们现在能做的就是复制这个到Visual Studio代码中。

4653
08:00:57.960 --> 08:01:03.771
在我们的。env中，我们可以把这些替换成它们的实际测试值和值。

4654
08:01:03.771 --> 08:01:09.042
对于RPC URL，我们会删除这个用Rigby RPC行替换它。

4655
08:01:09.042 --> 08:01:17.697
现在我们如何为一个有实际秩的测试集获取私钥呢?我们可以在这里使用元遮罩。

4656
08:01:17.697 --> 08:01:25.988
回到浏览器，到元掩码，选择三个点，到账户详细信息，导出私钥。

4657
08:01:25.988 --> 08:01:35.667
在这里你可以导出私钥，输入密码，你就有了元掩码账户的私钥。

4658
08:01:35.667 --> 08:01:43.046
现在，请记住，请不要继续使用一个真正有钱的元掩码。

4659
08:01:43.046 --> 08:01:53.088
一个快速的检查方法是打开你的网络选项卡，看看是否在任何一个主要的网络或有实际资金的网络上，你看到任何资金，我没有任何资金。

4660
08:01:53.088 --> 08:01:53.999
所以我知道我可以走了。

4661
08:01:53.999 --> 08:01:57.377
如果你有测试这些钱，那没关系，因为那反正是假钱。

4662
08:01:57.377 --> 08:02:03.021
而且，大多数浏览器都有一个配置文件机制，您可以在其中创建一个新的配置文件供您使用。

4663
08:02:03.021 --> 08:02:09.271
现在我已经复制了我的私钥，我们可以回到Visual Studio代码，把密钥粘贴到这里。

4664
08:02:09.271 --> 08:02:13.185
现在我有一个私钥，里面有实际的rink。

4665
08:02:13.185 --> 08:02:13.736
太棒了。

4666
08:02:13.736 --> 08:02:24.495
记住，如果你情绪低落，就到水龙头。链条。链接/里格比那里做些测试，我不是机器人，会发出请求的。

4667
08:02:24.495 --> 08:02:31.130
现在我们有了溜冰场的私钥，我们现在可以在实际测试中运行这个。

4668
08:02:31.130 --> 08:02:41.689
Net，我们看一下代码，我们看到我们从r。end获取一个RPC URL，我们从Yun V获取一个私钥，它指向我们的溜冰场D Metamask。

4669
08:02:41.689 --> 08:02:43.617
我们的溜冰场B区块链。

4670
08:02:43.617 --> 08:02:50.089
让我们在contract deployment下面添加一个console。log这样我们就知道它的地址了。

4671
08:02:50.089 --> 08:03:00.901
我们会做console。log，我们会做一些字符串插值，契合。address契合。address。

4672
08:03:00.901 --> 08:03:02.271
好的，很好。

4673
08:03:02.271 --> 08:03:04.966
现在让我们继续运行它。

4674
08:03:04.966 --> 08:03:07.508
我们用node deploy·J。

4675
08:03:07.508 --> 08:03:11.513
请稍等，你会发现这需要更长的时间。

4676
08:03:11.513 --> 08:03:24.082
因为我们部署到一个测试网络而不是我们自己的伪本地区块链，测试网络和真实网络通常会花更长的时间，因为它们需要等待块传播交易，等等。

4677
08:03:24.082 --> 08:03:29.224
但稍等片刻后，我们确实会看到我们在这里得到一个合同地址。

4678
08:03:29.289 --> 08:03:30.482
我们现在有一个最喜欢的数字。

4679
08:03:31.289 --> 08:03:38.715
又慢了，因为我们在等待下一个交易完成来更新数字，然后，看起来我们成功更新了它。

4680
08:03:38.715 --> 08:03:47.616
有一点很重要如果你运行命令，想要终止它，你可以按Ctrl C，它就会停止。

4681
08:03:47.616 --> 08:03:52.543
终端中任何你想要终止Ctrl的命令。

4682
08:03:52.543 --> 08:03:55.648
C是你的免费卡，这将会杀死它。

4683
08:03:55.648 --> 08:03:57.239
不管它在哪里，都能阻止它。

4684
08:03:57.239 --> 08:03:59.950
我们以后会经常使用Ctrl C。

4685
08:03:59.950 --> 08:04:14.647
抓取这个合同地址到Frank V，扫描粘贴进来，这里有两个交易，这里有一个合同创建。

4686
08:04:14.647 --> 08:04:17.605
我们还可以调用一个store函数。

4687
08:04:17.605 --> 08:04:18.727
这太棒了。

4688
08:04:18.727 --> 08:04:25.193
我们已经使用自己的代码成功地将合约部署到皱纹链中。

4689
08:04:25.193 --> 08:04:28.918
恭喜你，这是巨大的。

4690
08:04:28.918 --> 08:04:33.979
现在通过以太扫描，我们实际上可以验证并发布我们的合同代码。

4691
08:04:33.979 --> 08:04:41.090
什么是验证和发布代码?现在，我们的代码看起来像一个巨大的字节码沙鼠。

4692
08:04:41.090 --> 08:04:50.838
任何直接在链上看合约的人都会看到这一大堆字节码，我们可以用反编译器把字节码反编译成它实际的样子。

4693
08:04:50.838 --> 08:04:55.027
但这通常需要很长时间和大量的处理能力。

4694
08:04:55.027 --> 08:05:02.734
相反，我们可以通过验证和发布代码让它更简单，你可以点击验证和发布。

4695
08:05:02.734 --> 08:05:08.994
我们可以向下滚动，我们可以添加编译器信息在以太扫描和其他块探索器上编译它。

4696
08:05:08.994 --> 08:05:13.665
这是一个单文件编译器的版本是零点8。

4697
08:05:13.665 --> 08:05:13.754
7.

4698
08:05:13.754 --> 08:05:16.199
它是MIT授权的开源软件。

4699
08:05:16.199 --> 08:05:17.991
让我们继续。

4700
08:05:17.991 --> 08:05:23.798
我们要复制粘贴我们的固体度代码到这一大块。

4701
08:05:23.798 --> 08:05:24.191
粘贴。

4702
08:05:24.191 --> 08:05:28.933
我们没有任何构造函数参数，因此可以跳过此部分。

4703
08:05:28.933 --> 08:05:32.745
我们没有任何库或任何其他杂项设置。

4704
08:05:32.745 --> 08:05:37.874
我们会选择I'm not a robot然后点击verify and publish。

4705
08:05:37.874 --> 08:05:40.991
你可能得等几分钟，但太棒了。

4706
08:05:40.991 --> 08:05:43.719
我们的合同编制成功了。

4707
08:05:43.719 --> 08:05:49.431
现在如果我们回到合同源代码，我们可以在这里看到所有代码。

4708
08:05:49.431 --> 08:05:58.224
如果我们抓取合同地址，把它放到搜索中，然后进入合同，我们会得到一个绿色的勾号。

4709
08:05:58.291 --> 08:06:02.215
我们可以看到，任何人都可以阅读我们的源代码。

4710
08:06:02.291 --> 08:06:10.385
另外，那些我们看到并混合用于从合同中读取和写入的按钮，分别在这个读合同和这个写合同中。

4711
08:06:10.385 --> 08:06:17.613
如果我们读取契约，并检索最近的数字，我们确实会看到这里有7，因为我们最近存储了7。

4712
08:06:17.613 --> 08:06:29.711
很好，快速提示，这可能已经为您验证过了，因为以太扫描可能足够智能，可以注意到许多人正在部署相同的字节码，它已经为您验证过了，所以不管怎样，继续执行这些步骤。

4713
08:06:29.711 --> 08:06:36.541
我们刚刚做的代码验证非常简单直接，因为我们的代码非常简单直接。

4714
08:06:36.541 --> 08:06:42.087
使用更大更复杂的代码会使验证过程变得有点困难。

4715
08:06:42.087 --> 08:06:45.597
此外，我们并不总是想要在以太扫描上点击按钮。

4716
08:06:45.597 --> 08:06:48.225
为了验证我们的代码，我们希望以编程的方式进行验证。

4717
08:06:48.225 --> 08:07:02.629
因此，在后面的部分中，我们将学习如何直接通过代码编辑器验证所有的代码，您可以想象在我们的炼金术中部署到任何EVM链的过程是如此简单，我们可以轻松地创建一个新的应用程序和更改我们的网络。

4718
08:07:02.629 --> 08:07:09.325
您可以看到，将这个RPC URL和您的私钥切换到另一个链上工作是多么容易。

4719
08:07:09.325 --> 08:07:13.775
这个过程同样适用于和谐幻影，雪崩等。

4720
08:07:13.775 --> 08:07:24.818
如果我们想要切换链，我们只需切换RPC URL和私钥，其他的一切都将完全相同。

4721
08:07:24.818 --> 08:07:34.207
现在，Alchemy还向我们展示并教会了我们很多关于事务和幕后发生的事情的知识，包括一个称为mempool的概念。

4722
08:07:34.207 --> 08:07:39.647
为了帮助我们更多地了解我们刚刚发送的那些事务，以及如何与Alchemy一起工作。

4723
08:07:39.647 --> 08:07:45.238
为了更多地了解我们的事务，我们请了炼金术团队的Albert为我们做一些演示。

4724
08:07:45.292 --> 08:07:54.895
大家好，我是炼金术公司的Albert，我是推特上的科技界人士，如果你想参与其中并对这部分视频提出任何问题，请随时关注。

4725
08:07:54.895 --> 08:08:02.240
但是非常高兴能在这里加入Patrick，他将解释使用alchemy提交事务时幕后发生了什么。

4726
08:08:02.292 --> 08:08:15.201
我们有大量的工具来提供一个可以看到正在发生的事情的窗口，这样你就可以进行调试，以防你的网站出现使用错误，或者有挂起的事务被卡住。

4727
08:08:15.201 --> 08:08:19.625
不管是什么，我们提供了一个窗口，可以看到你所控制的数据。

4728
08:08:19.625 --> 08:08:22.662
请记住，您提交的所有事务都记录在区块链上。

4729
08:08:22.662 --> 08:08:26.529
它们不受炼金术的控制，也不受任何其他服务提供商的控制。

4730
08:08:26.529 --> 08:08:32.212
我们只是一扇窗户，我们只是管道管道对你有用。

4731
08:08:32.292 --> 08:08:34.324
让我来告诉你们这到底是什么意思。

4732
08:08:35.292 --> 08:08:36.525
仪表板上有一堆应用程序。

4733
08:08:37.292 --> 08:08:39.986
我用过很多不同的项目。

4734
08:08:40.292 --> 08:08:45.372
一个是最近激活的，它是我目前设置的连接到我的元掩码。

4735
08:08:45.372 --> 08:08:47.533
这里使用自定义RPC提供程序。

4736
08:08:47.533 --> 08:08:49.767
我把脸画小一点。

4737
08:08:49.767 --> 08:08:52.885
你们可以看到，我把Rinkeby拼错了。

4738
08:08:52.885 --> 08:08:58.708
但现在，我的我的网络通过炼金术连接到林克比测试网络。

4739
08:08:58.708 --> 08:09:00.800
这就是这个应用。

4740
08:09:00.800 --> 08:09:07.361
如果我点击仪表板上的这里，你可以看到这里，有很多非常有趣的统计数据，这是你可能会用到的第一个东西。

4741
08:09:07.361 --> 08:09:16.768
如果您想进一步了解您的应用程序，您可以到这里查看您的应用程序当前每秒使用多少计算单元。

4742
08:09:16.768 --> 08:09:21.072
这对于炼金术的使用和理解是非常有用的。

4743
08:09:21.072 --> 08:09:27.935
但这也很有用，比如，中值响应时间是多少，33毫秒已经很好了。

4744
08:09:27.935 --> 08:09:34.543
如果它开始增加，那么你可能想知道，你知道，这里发生了什么，成功率，它已经有点低了。

4745
08:09:34.543 --> 08:09:39.714
因此，这是一个提示，我可以点击这个选项卡查看最近的无效请求。

4746
08:09:39.714 --> 08:09:52.325
我可以看到，有一堆失败的事务，其中事务已经发送或者nonce太低，等等，我可以用这个选项卡来调试。

4747
08:09:52.325 --> 08:09:54.193
所以这个成功率非常有用。

4748
08:09:54.293 --> 08:09:56.228
吞吐量是有限的。

4749
08:09:58.293 --> 08:10:02.631
请求或你的网站正在被垃圾邮件发送，你可能会开始被阻止一些请求。

4750
08:10:02.631 --> 08:10:13.819
这就是在这里查看他们的并发请求的有用之处，过去24小时内的成功率与过去1小时相比，过去24小时内的请求总数。

4751
08:10:13.819 --> 08:10:19.879
这与计算单元不同，因为每个请求可以有不同级别的计算成本。

4752
08:10:19.879 --> 08:10:23.189
用计算单位来衡量计算成本。

4753
08:10:23.189 --> 08:10:27.143
总请求数就是绝对请求的实际数量。

4754
08:10:27.143 --> 08:10:29.793
当然，还有无效请求的数量。

4755
08:10:29.793 --> 08:10:30.150
酷。

4756
08:10:30.150 --> 08:10:44.055
有一件事很有趣当我提交一笔交易时，我这里就有一笔，我想发送让我们在我的账户之间转账，我只会将它发送到Rinkeby eath的一小部分。

4757
08:10:44.055 --> 08:10:56.228
但我有意地将我的气费编辑得非常非常低，这样节点就不会将交易发送到挖矿，否则就没有挖矿者会去捡它。

4758
08:10:56.228 --> 08:11:00.606
你可以看到我把优先费和最高费除以了一吨。

4759
08:11:00.606 --> 08:11:01.731
所以它非常低。

4760
08:11:01.731 --> 08:11:07.047
它可能会确认在MME Max UI中，你会看到事务已经挂起了一段时间。

4761
08:11:07.047 --> 08:11:09.015
我们会转到mempool选项卡。

4762
08:11:09.015 --> 08:11:11.900
这是另一个非常有用的可视化。

4763
08:11:11.900 --> 08:11:26.627
记忆池是一种等待场所，我喜欢把它想象成餐厅的候车室，如果你在那里进行交易，你在那里等待被挖掘，记忆池有点像你在那里等待入座的候车室。

4764
08:11:26.627 --> 08:11:36.484
每个交易都有不同的状态，你总想看到的是矿交易，因为这表示你的交易是成功的。

4765
08:11:36.484 --> 08:11:38.198
现在它是区块链的一部分。

4766
08:11:38.294 --> 08:11:42.494
mempool，每个节点都有自己的固定区域。

4767
08:11:42.494 --> 08:11:44.227
我可以给你们展示这个快速的可视化图。

4768
08:11:44.294 --> 08:11:47.638
记住，区块链是由节点网络运行的。

4769
08:11:48.294 --> 08:11:53.766
节点或运行定理的每台计算机，软件都维护了区块链的副本。

4770
08:11:53.766 --> 08:11:58.246
作为开发人员，您必须使用这些节点向区块链发出请求。

4771
08:11:58.294 --> 08:12:03.261
现在您可以使用炼金术，您可以使用另一个RPC提供程序，您可以旋转您自己的节点，如果您愿意的话。

4772
08:12:03.261 --> 08:12:07.010
但无论如何，您都需要使用节点与链通信。

4773
08:12:07.010 --> 08:12:14.711
现在每个节点除了拥有整个区块链状态的副本之外，还拥有事务的本地内存。

4774
08:12:14.711 --> 08:12:16.618
这叫做mempool。

4775
08:12:16.618 --> 08:12:22.961
因此，如果存在等待挖掘的挂起事务，则可以将它们视为在内存池中。

4776
08:12:22.961 --> 08:12:24.617
这就是我们现在看到的。

4777
08:12:24.617 --> 08:12:36.465
如果我们点开我目前用的Metamask RPC的应用，你可以看到这里有，这个不是正确的，这个是用于起皱的。

4778
08:12:36.465 --> 08:12:47.600
对于所有的事务，你可以看到在大脑的某个地方有更多的下落有一个是待处理的，这个是待处理的，它和这个是匹配的，它被发送到0x C BB。

4779
08:12:47.600 --> 08:12:52.622
如果我们点击这个事务散列，就会得到调试所需的所有信息。

4780
08:12:52.622 --> 08:12:59.491
你可以看到它来自我的当前地址，0x, 5f，然后是2x, C, BB。

4781
08:12:59.491 --> 08:13:02.778
这是我要发送的值。

4782
08:13:02.778 --> 08:13:06.214
这是我附上的这笔交易的汽油费。

4783
08:13:06.214 --> 08:13:10.095
你会注意到这是非常低的，即使对于Rinkeby测试网络。

4784
08:13:10.095 --> 08:13:18.617
知道这个，看到这个事务已经挂起了1分46秒，它是在这个时候发送的，我可能应该修复它。

4785
08:13:18.617 --> 08:13:24.456
在这里，你可以使用metamath RPC, meta - meta掩码API。

4786
08:13:24.456 --> 08:13:25.423
然后加速。

4787
08:13:25.423 --> 08:13:30.456
然后我要用自动高速来更新汽油费用。

4788
08:13:30.456 --> 08:13:38.645
如果我们回到仪表板回到我们的应用程序，你会看到最近有一些新的无效请求。

4789
08:13:38.645 --> 08:13:46.723
这是因为我们重新提交了一个事务，然后在他们最近的请求中，我们快速刷新一下。

4790
08:13:46.723 --> 08:13:50.618
你可以看到我们发送了一个原始事务，这个是已知的。

4791
08:13:50.618 --> 08:13:56.646
之前还有一个，但它的结果是get事务收据成功。

4792
08:13:56.646 --> 08:14:03.664
然后如果我们回到mempool，你会看到，没有更多挂起的事务，只有删除，替换和挖矿。

4793
08:14:03.664 --> 08:14:10.874
因此，第5个事务现在已经成功，您可以继续开发和维护应用程序的其余部分了。

4794
08:14:10.874 --> 08:14:12.821
谢谢，希望对大家有用。

4795
08:14:12.821 --> 08:14:19.102
如果有任何问题请告诉我。

4796
08:14:19.296 --> 08:14:25.594
现在，除了TypeScript部分(我将在最后完成)，您已经成功完成了本节。

4797
08:14:25.594 --> 08:14:27.233
哇，你学到了很多东西。

4798
08:14:27.233 --> 08:14:29.957
让我们快速回顾一下所学的内容。

4799
08:14:29.957 --> 08:14:37.876
首先，我们学习了如何用Node js创建新项目，我们学习了Node关键字的作用以及如何使用Node关键字。

4800
08:14:37.876 --> 08:14:47.635
为了在我们的本地开发环境中运行JavaScript，我们了解到可以使用yarn或NPM在本地包中添加不同的外部包依赖关系。

4801
08:14:47.635 --> 08:15:04.740
我们可以在package。JSON中看到这些依赖项，我们知道它们已经被安装了，因为它们被安装到node modules文件夹中，我们还可以创建一个脚本部分，在这里我们可以最小化需要运行到单个关键字中的长命令，例如compile，我们可以只运行yarn compile。

4802
08:15:04.740 --> 08:15:14.787
为了编译我们所有的代码，我们学习了JavaScript脚本的基本设置，我们在顶部导入包，在底部有一些主要的执行器函数。

4803
08:15:14.787 --> 08:15:29.881
然后我们在中间有main函数，我们使用async关键字让我们的函数可以使用异步编程，我们访问await关键字，意思是，嘿，等待这个承诺完成它的事情。

4804
08:15:29.881 --> 08:15:41.139
我们能够使用RPC URL连接到我们想要的任何区块链，然后我们能够通过这样做将我们的提供者连接到醚中的钱包或私钥。

4805
08:15:41.139 --> 08:15:58.055
说到这里，我们已经学习了ethers包，这是一个工具，让我们的生活更容易与JavaScript中的区块链交互，如果我们决定，我们还学习了我们可以加密我们的私钥，这样即使我们的电脑被黑客攻击，我们的私钥也不会以明文的形式到处乱放。

4806
08:15:58.055 --> 08:16:01.852
我们已经学会了如何通过加密密钥运行脚本。

4807
08:16:01.852 --> 08:16:12.035
我们已经学习了如何获取ABI或应用程序二进制接口，以及如何将我们的代码二进制部署到区块链，我们还学习了如何以编程方式将我们的契约部署到区块链。

4808
08:16:12.035 --> 08:16:15.533
然后我们还学习了如何以编程方式与契约交互。

4809
08:16:15.533 --> 08:16:21.230
此外，我们还学习了如何在VS代码的设置点JSON中添加默认编辑器。

4810
08:16:21.230 --> 08:16:32.649
但是我们也学习了如何通过使用一个。beautitier rc文件来覆盖这些设置，我们可以自动格式化我们的代码，使它看起来更好，更容易阅读。

4811
08:16:32.649 --> 08:16:38.756
最后，我们学习了如何将这些合同部署到一个真实的测试网或真实的网络中。

4812
08:16:38.756 --> 08:16:43.404
然后我们终于学会了手动验证合同源代码的方法。

4813
08:16:43.404 --> 08:16:45.690
就像我说的，我们会学到很多捷径。

4814
08:16:45.690 --> 08:16:48.909
在接下来的章节中，会有很多方法让这一切变得简单。

4815
08:16:48.909 --> 08:16:59.619
哦，你们已经取得了惊人的成绩，给自己一个表扬，休息一下，跑一圈，为自己走了这么远感到骄傲，我们还有很多路要走。

4816
08:16:59.619 --> 08:17:02.195
但你已经走了很长的路。

4817
08:17:02.195 --> 08:17:03.279
祝贺你。

4818
08:17:03.279 --> 08:17:09.207
或者休息5到10分钟，准备好了再回来。

4819
08:17:09.297 --> 08:17:13.125
现在我还想给大家展示的是TypeScript的附加内容。

4820
08:17:13.125 --> 08:17:21.598
然而，如果你对TypeScript版本不感兴趣(你不必感兴趣)，那么你就完了，我们只需要做一些改变来使这个TypeScript兼容。

4821
08:17:21.598 --> 08:17:24.647
当然，首先，我们要更改我们的部署。

4822
08:17:24.647 --> 08:17:31.765
Ts和加密密钥，我们要改变我们的部署和加密密钥从。js2。

4823
08:17:31.765 --> 08:17:31.926
ts。

4824
08:17:31.926 --> 08:17:36.996
然后我们也要把这些需求换成导入。

4825
08:17:36.996 --> 08:17:47.234
所以我们要从醚中导入醚，我们要从额外的f中导入f。

4826
08:17:47.234 --> 08:17:52.588
然后我们会导入。TMP / config。

4827
08:17:52.588 --> 08:18:02.072
然后我们要复制这些，我们要把它们粘贴到这里，删除或注释掉要求，好的，很好。

4828
08:18:02.072 --> 08:18:04.388
现在，如果我们尝试运行Node deploy。

4829
08:18:04.388 --> 08:18:09.199
Ts，我们会得到不能在模块外使用输入语句。

4830
08:18:09.199 --> 08:18:17.412
在JavaScript中，如果我们想在模块外部使用import语句，我们会在这里做一些类似于type module的事情。

4831
08:18:17.412 --> 08:18:21.139
但在TypeScript中，我们甚至不需要这些。

4832
08:18:21.139 --> 08:18:24.369
我们需要做的就是在TypeScript注释中运行它。

4833
08:18:24.369 --> 08:18:28.937
要添加TypeScript，我们要做yarn，添加TypeScript。

4834
08:18:28.937 --> 08:18:31.887
我们还要加上TS节点。

4835
08:18:31.887 --> 08:18:34.710
TS节点是node的TypeScript版本。

4836
08:18:34.710 --> 08:18:38.504
现在我们已经添加了，我们可以尝试TS节点部署。

4837
08:18:38.504 --> 08:18:38.641
ts。

4838
08:18:38.641 --> 08:18:41.609
我们仍然会遇到一个错误。

4839
08:18:41.609 --> 08:18:45.316
如果你向上滚动，我们会得到一些错误。

4840
08:18:45.316 --> 08:18:53.502
我们会说，找不到Module Fs额外的声明文件，我们需要添加它们的TypeScript版本。

4841
08:18:53.502 --> 08:18:57.392
所以我们要做斜杠f型的纱线。

4842
08:18:57.392 --> 08:19:01.447
如果我们再运行一次，应该还是不能用。

4843
08:19:01.447 --> 08:19:02.447
但原因不同。

4844
08:19:02.447 --> 08:19:04.584
是的，我们会买这种类型的。

4845
08:19:04.584 --> 08:19:06.944
Undefined不能赋值给类型字节。

4846
08:19:06.944 --> 08:19:16.061
比如我们得到这个的原因是因为TypeScript中的process。EMV私钥技术上来说，是字符串类型，或未定义的。

4847
08:19:16.061 --> 08:19:20.553
我们需要告诉Typescript和和钱包对象。

4848
08:19:20.553 --> 08:19:24.513
Encrypt函数寻找类型字符串，而不是字符串或未定义。

4849
08:19:24.513 --> 08:19:28.267
我们只需要告诉TypeScript这不是undefined。

4850
08:19:28.267 --> 08:19:29.899
所以我们可以在这里放一声巨响。

4851
08:19:29.899 --> 08:19:37.095
在我们使用处理，研究和成为的地方，哦，我也要在部署时这样做。

4852
08:19:37.095 --> 08:19:38.513
砰，看起来不错。

4853
08:19:38.513 --> 08:19:41.997
现在我们已经在这里添加了所有内容，我们运行TS node deploy。

4854
08:19:41.997 --> 08:19:46.699
t，我们会看到和使用正则节点时完全一样的输出。

4855
08:19:46.699 --> 08:19:50.365
只要私钥密码在。env文件中。

4856
08:19:50.365 --> 08:19:52.502
如果我们运行TS节点和加密密钥。

4857
08:19:52.502 --> 08:19:55.891
t，我们会得到和之前一样的设置。

4858
08:19:55.891 --> 08:19:58.361
我们会得到一个新的加密key。JSON。

4859
08:19:58.361 --> 08:20:01.799
这就是让TypeScript兼容所需要做的。

4860
08:20:01.799 --> 08:20:07.971
你应该为自己赢得热烈的掌声，因为你走了这么远，知道了安全帽下到底发生了什么。

4861
08:20:07.971 --> 08:20:17.600
我们将要学习的下一个工具是关于这些交易以及如何与这些区块链交互的，这绝对是巨大的，非常巨大。

4862
08:20:17.600 --> 08:20:19.109
祝贺你。

4863
08:20:19.299 --> 08:20:26.953
好了，现在我们已经学习了ethers js以及如何进行更多的原始JavaScript编码，现在我们将进入hardhat。

4864
08:20:26.953 --> 08:20:31.523
通过以太符号存储，我们看到部署合约可能需要大量代码。

4865
08:20:31.523 --> 08:20:34.300
还有很多事我们都没做。

4866
08:20:34.300 --> 08:20:37.146
就像我们没有保存合同的部署位置一样。

4867
08:20:37.146 --> 08:20:40.252
所以我们必须记住它每次被部署在哪里。

4868
08:20:40.252 --> 08:20:42.565
而不是通过编程方式添加它。

4869
08:20:42.565 --> 08:20:45.961
我们没有在这里编写任何测试，我们必须构建自己的测试基础设施。

4870
08:20:45.961 --> 08:20:48.414
也许我们想让它成为一个跨链应用。

4871
08:20:48.414 --> 08:20:56.987
我们想要的不仅仅是一个私钥和RPC URL，你完全可以通过以太和这样的小脚本在JavaScript中使用你的智能合约。

4872
08:20:56.987 --> 08:21:00.461
但是我们需要一个更健壮的框架来完成这一切。

4873
08:21:00.461 --> 08:21:03.170
这就是“安全帽”发挥作用的地方。

4874
08:21:03.300 --> 08:21:08.721
Hardhead很容易成为最流行的智能合约开发框架之一。

4875
08:21:08.721 --> 08:21:14.726
它被大量使用在数十亿美元的协议中，比如Ave uniswap，寿司交换等等。

4876
08:21:14.726 --> 08:21:16.791
事实上，我最近在Twitter上做了一个调查。

4877
08:21:16.791 --> 08:21:27.972
尽管我的很多内容更偏向于brownie和Pythonic, Hardhead远远超出了最流行的框架，Hardhead很快就成为了最先进的框架之一。

4878
08:21:27.972 --> 08:21:38.393
Hardhead是一个开发环境，它允许基于JavaScript的开发，有点像我们看到的乙醚，它给了我们更多的工具来集成我们的代码和我们想做的常见事情。

4879
08:21:38.393 --> 08:21:42.086
它具有不可思议的可扩展性，并且具有非常好的调试特性。

4880
08:21:42.086 --> 08:21:44.053
这是一个非常棒的工具。

4881
08:21:44.053 --> 08:21:45.873
我们继续，开始吧。

4882
08:21:45.873 --> 08:21:50.250
如果你想跟随代码，来到GitHub回购并向下滚动。

4883
08:21:50.300 --> 08:21:54.061
第六课的心脏有简单的存储，所有的代码都在这里。

4884
08:21:54.061 --> 08:22:06.900
提醒一下，你想要从这些存储库中下载所有的代码，你可以通过做一个git克隆，你要做的是找到你想要放代码的文件夹，然后运行git克隆。

4885
08:22:06.900 --> 08:22:11.419
然后获取要克隆的URL，粘贴进去。

4886
08:22:11.419 --> 08:22:23.059
现在，你可以CD到你的新文件夹，里面有所有直接从GitHub下载的东西，但只能作为备份或自己下载代码。

4887
08:22:23.059 --> 08:22:25.001
但现在，跟着我就行了。

4888
08:22:25.001 --> 08:22:26.201
好，我们开始吧。

4889
08:22:26.301 --> 08:22:29.139
让我们使用安全帽创建我们的下一个项目。

4890
08:22:30.301 --> 08:22:34.926
我们要做的叫做Hard Hat，简单的存储dash FCC或Free Code Camp。

4891
08:22:34.926 --> 08:22:39.037
我们又要用那个简单的储存合同合作了。

4892
08:22:39.037 --> 08:22:47.701
但是在“硬帽”中，我们将向你展示大量奇妙的工具，我们可以使用它们使我们的编码生活变得更容易。

4893
08:22:47.701 --> 08:22:53.497
我在一个全新的VS code中，我们会创建一个新文件夹来运行所有这些。

4894
08:22:53.497 --> 08:23:04.169
要创建一个全新的文件夹你可以使用mkdir，简单的CC存储。

4895
08:23:04.301 --> 08:23:09.301
现在我们可以把cd转换成硬帽简单存储的cd，并输入代码，句号。

4896
08:23:09.301 --> 08:23:14.916
这将在该文件夹中打开一个新的Visual Studio代码。

4897
08:23:14.916 --> 08:23:20.650
现在如果我们打开终端，你会看到我们确实在那个文件夹里。

4898
08:23:20.650 --> 08:23:27.775
如果这对你不起作用，你当然还可以点击“文件”，打开文件夹，选择你想要打开的文件夹。

4899
08:23:27.775 --> 08:23:29.507
你就在那个文件夹里。

4900
08:23:29.507 --> 08:23:44.846
现在我们有了使用硬帽工作的文件夹设置，我们可以开始设置我们的环境，使用硬帽框架非常专业，在我们整个区块链坚实性课程中获得硬帽文档的链接，是的，硬帽文档是现象级的。

4901
08:23:44.846 --> 08:23:48.268
我强烈建议大家在学习这部分的时候把它拿出来。

4902
08:23:48.268 --> 08:23:55.646
因为它将给你几乎所有你需要知道的工作与硬帽，你可以简单地继续到教程并开始。

4903
08:23:55.646 --> 08:24:03.474
如果您想在这里暂停视频并通读教程，我建议您这样做，它将为您提供许多关于如何使用hardhat的信息。

4904
08:24:03.474 --> 08:24:04.531
还有更多关于安全帽的。

4905
08:24:04.531 --> 08:24:07.340
然而，我们将直接跳到设置环境。

4906
08:24:07.340 --> 08:24:10.571
我们还没有在Linux或Mac OS上安装g。

4907
08:24:10.571 --> 08:24:15.492
对于使用Windows的人，我为你们设置了WsL。

4908
08:24:15.492 --> 08:24:19.142
因此，您只需遵循Linux的说明即可。

4909
08:24:19.302 --> 08:24:23.391
现在要创建一个新的安全帽项目，您实际上可以直接在这里运行这些步骤。

4910
08:24:23.391 --> 08:24:37.159
而不是NPM，我们会用yarn，但如果你想用NPM，你完全可以这样做，硬帽Doc会说，run NPM init，是的，我们会在里面运行yarn，这会在这个文件夹里为我们创建一个新项目。

4911
08:24:37.159 --> 08:24:44.682
我们给它一个名字，如果我们想让它设为这个硬帽符号存储FF FCC，我们只要按回车键，就会给它一个版本。

4912
08:24:44.682 --> 08:24:46.063
如果我们想要1。

4913
08:24:46.063 --> 08:24:47.904
0点哦，我们按回车键。

4914
08:24:47.904 --> 08:24:51.515
我们现在跳过描述，只要按回车键。

4915
08:24:51.515 --> 08:24:53.968
这里我们也要按回车键。

4916
08:24:53.968 --> 08:24:58.932
这个也可以输入这个也可以输入这个也可以输入这个也可以输入。

4917
08:24:58.932 --> 08:25:00.762
这些都是空的。

4918
08:25:00.762 --> 08:25:11.452
如果我们看package json，我们现在看到我们有一个名字Hardhead符号存储FCC我们有一个版本我们有一个main我们实际上要删除这个main然后我们还有一个许可证。

4919
08:25:11.452 --> 08:25:13.875
Yarn为我们设置了这个package json。

4920
08:25:13.875 --> 08:25:18.592
现在我们要做yarn，在app中添加破折号。

4921
08:25:18.592 --> 08:25:26.302
到目前为止，我们运行的都是yarn add，然后不管包的名字是什么。

4922
08:25:26.302 --> 08:25:30.477
但对于我们所做的大部分工作，我们真的想做纱线添加dash Dev。

4923
08:25:30.477 --> 08:25:33.017
这其中的原因有点微妙。

4924
08:25:33.017 --> 08:25:36.124
但是我们可以在这里看到关于StackOverflow问题的一些信息。

4925
08:25:36.124 --> 08:25:39.945
主要的区别是运行项目需要依赖项。

4926
08:25:39.945 --> 08:25:43.641
而开发依赖只需要开发。

4927
08:25:43.641 --> 08:25:51.771
大部分情况下，我们只会做开发，当我们讲到这门课的前端部分时，我们会安装更多的包不仅仅是开发需要的。

4928
08:25:51.771 --> 08:25:55.760
现在在我们安装硬帽的同一个目录中，你可以运行MPX硬帽。

4929
08:25:55.760 --> 08:26:01.795
因此，关于MPX的一个简单说明是，与NPM等价的纱线只是纱线。

4930
08:26:01.795 --> 08:26:06.139
所以纱线变成NPM，相当于MPX的纱线也是纱线。

4931
08:26:06.139 --> 08:26:13.909
所以几乎任何时候你看到MPX，做点什么，你可以用纱线替换MPX，它会做完全一样的事情。

4932
08:26:13.909 --> 08:26:17.754
如果你想用NPM或MPX运行这个，你完全可以这样做。

4933
08:26:17.754 --> 08:26:20.528
对我们来说，我们要运行纱线硬帽。

4934
08:26:20.528 --> 08:26:25.793
我们会看到我们会被提示开始创建一个hardhat项目，运行yarn hardhat。

4935
08:26:25.793 --> 08:26:30.593
我们会看到这个非常可爱的提示，说欢迎来到Hardhead。

4936
08:26:30.593 --> 08:26:38.641
你想做什么，创建一个基本的示例项目，创建一个高级的示例项目，可以推进一些项目使用类型脚本或创建一个空的硬帽。

4937
08:26:38.641 --> 08:26:38.931
配置。

4938
08:26:38.931 --> 08:26:39.027
js。

4939
08:26:39.027 --> 08:26:42.337
对于我们来说，我们只需要选择创建一个基本的示例项目。

4940
08:26:42.337 --> 08:26:47.384
这将为我们提供一个非常简单的硬帽子项目的所有样板。

4941
08:26:47.384 --> 08:26:50.472
安全帽项目路径就是我们现在所在的这个文件夹。

4942
08:26:50.472 --> 08:26:53.942
你想添加一个Git。gitignore吗?是的，我们当然需要。

4943
08:26:53.942 --> 08:26:56.204
因为我们将使用。env文件。

4944
08:26:56.303 --> 08:27:07.779
你想安装这个样本项目的依赖与纱线在nomic实验室硬帽在一个理论和华夫在柴?我们将继续说yes，然后我会稍微解释一下所有这些依赖关系是什么。

4945
08:27:07.779 --> 08:27:09.588
我们现在就同意吧。

4946
08:27:09.588 --> 08:27:14.350
我们会安装所有这些依赖项。

4947
08:27:14.350 --> 08:27:26.229
现在，如果我们查看我们的包JSON，我们可以看到我们添加了许多依赖项，如nomic labs, Hardhead ethers，而不是MacLeods, Hardhead，华夫饼，Chai, Aetherium，华夫饼和醚。

4948
08:27:26.304 --> 08:27:29.490
显然，我们已经对醚很熟悉了，但其他的可能有点新。

4949
08:27:29.490 --> 08:27:30.735
我们稍后再谈。

4950
08:27:30.735 --> 08:27:35.654
很好，我们现在有一个示例硬帽样板项目。

4951
08:27:35.654 --> 08:27:38.004
让我们来看看我们刚刚安装的东西。

4952
08:27:38.004 --> 08:27:45.116
首先我们有一个合同文件夹，它是预先填充与问候外底是真正的简约合同在这里。

4953
08:27:45.116 --> 08:27:49.649
接下来，您将看到节点模块，这当然是我们安装的JavaScript依赖项。

4954
08:27:49.649 --> 08:27:57.890
我想知道的是因为当我第一次开始研究这个的时候它真的让我很困惑有些节点模块以加号开始，然后很多没有。

4955
08:27:57.890 --> 08:28:07.437
这两者的区别是什么呢?这些外部节点模块被称为作用域包，它有效地允许NPM包成为命名空间或yarn包。

4956
08:28:07.437 --> 08:28:12.504
这允许组织明确哪些包是正式的，哪些不是。

4957
08:28:12.504 --> 08:28:17.507
例如，如果一个包在Angular中有作用域，那么它就是由Angular核心团队发布的。

4958
08:28:17.507 --> 08:28:27.240
这和我们知道的任何带有AP ens域的东西都是由ens域团队完成的，任何带有异常实验室的东西都是由创建安全帽的团队完成的。

4959
08:28:27.304 --> 08:28:37.659
这就是为什么这个在nomic实验室，硬帽醚在nomic实验室，华夫有@号，因为我们知道它是由nomic实验室团队发布的，然后我们有一个脚本部分。

4960
08:28:37.659 --> 08:28:44.757
我们将在这里添加我们想要编写的任何和所有脚本，比如部署契约，与契约交互等。

4961
08:28:44.757 --> 08:28:46.210
然后是一个测试文件夹。

4962
08:28:46.304 --> 08:28:48.500
我们还没有开始构建任何测试。

4963
08:28:49.304 --> 08:28:51.828
对于使用智能合约非常重要。

4964
08:28:52.305 --> 08:28:57.271
样本测试文件夹为我们提供了测试智能合约的最简单的测试。

4965
08:28:57.271 --> 08:29:03.371
我们当然有gitignore，它当然预先填充了一些重要的东西来忽略，比如Dotty和V。

4966
08:29:03.371 --> 08:29:08.105
还有节点模块因为节点模块可能会被推到GitHub上。

4967
08:29:08.105 --> 08:29:12.494
最大的变化之一就是增加了这个安全帽。

4968
08:29:12.494 --> 08:29:13.011
配置。

4969
08:29:13.011 --> 08:29:13.183
js。

4970
08:29:13.183 --> 08:29:25.250
这个文件虽然很简单，但是现在，你可以把它看作我们编写的所有脚本的入口点，它是一个配置文件，它决定了我们其余的代码如何工作，以及如何与区块链交互。

4971
08:29:25.305 --> 08:29:28.605
当然，我们还有package。JSON，我们从自述文件开始。

4972
08:29:28.605 --> 08:29:34.305
还记得我们第一次运行纱线硬帽时，我们被提示了这篇入门文章。

4973
08:29:34.305 --> 08:29:42.337
现在，如果我们运行yarn Hardhead，我们实际上会得到所有不同选项和命令的输出，我们可以用它来运行hard hat。

4974
08:29:42.337 --> 08:29:50.741
现在，如果你遇到一个问题，你运行纱线，安全帽，这弹出，但你没有看到安全帽。

4975
08:29:50.741 --> 08:29:51.068
配置。

4976
08:29:51.068 --> 08:30:01.662
Js在你的文件夹中，这可能意味着在更高级别的文件夹中有一个硬帽。config。js，或者在更高级别的文件夹中有一个带硬帽的节点模块。

4977
08:30:01.662 --> 08:30:07.535
如果发生了这种情况，也许可以CD到一个目录下，做一点LS，看看你是否有一个安全帽。

4978
08:30:07.535 --> 08:30:07.996
配置。

4979
08:30:07.996 --> 08:30:10.765
Js或节点模块在前面的文件夹。

4980
08:30:10.765 --> 08:30:15.474
因为我看到很多工程师在这方面都有一些不同的问题。

4981
08:30:15.474 --> 08:30:21.256
我的朋友CAMI将解释几个不同的故障排除提示，您可以尝试避免这些常见错误。

4982
08:30:21.305 --> 08:30:24.620
作为一个开发人员，最讨厌处理环境问题的是一组问题。

4983
08:30:24.620 --> 08:30:25.883
我叫卡米拉·拉莫斯。

4984
08:30:25.883 --> 08:30:30.237
我是支持图形协议的边缘节点的DevRel工程师。

4985
08:30:30.305 --> 08:30:34.406
我将向你们展示如何解决两个你们在做这个项目时可能会遇到的常见问题。

4986
08:30:34.406 --> 08:30:35.656
安装好安全帽后。

4987
08:30:35.656 --> 08:30:42.559
在新项目文件夹中运行命令和px hard hat，你会期望得到一个这样的选项菜单，但有时你不会得到它。

4988
08:30:42.559 --> 08:30:46.409
当你遇到这个错误时，有一个解决方法。

4989
08:30:46.409 --> 08:30:51.628
这通常意味着你有一个不应该在的配置文件，删除它会消除这个错误。

4990
08:30:51.628 --> 08:30:58.337
为了找到要删除的文件，你要做的是运行命令MPX hardhats space，连字符，连字符verbose。

4991
08:30:58.337 --> 08:31:04.560
如果你有文件，它会告诉你文件的位置，它会告诉你文件的确切位置，这样你就可以删除它。

4992
08:31:04.560 --> 08:31:12.240
在你删除了这个配置文件后，你应该能够在你的项目文件夹中运行MPX硬帽，并得到我们所期望的数量。

4993
08:31:12.306 --> 08:31:14.067
另一个很常见的问题。

4994
08:31:15.306 --> 08:31:21.256
时间是忘记npm安装，当你在处理别人在GitHub上做的回购时。

4995
08:31:21.306 --> 08:31:29.629
假设你正在拉下一些你和合作者一起做的代码，然后突然，它不适合你了，你可能只需要npm install。

4996
08:31:29.629 --> 08:31:36.034
所以在你的终端中，直接导航到这个项目所在的位置，然后运行npm install命令。

4997
08:31:36.034 --> 08:31:49.767
如果在您没有处理代码的时候安装了任何新的包，这些包将在本地为您安装，这样当您运行代码时，它将能够成功地运行。

4998
08:31:50.306 --> 08:32:00.358
在原始状态下，我们可以用hardhat做一些主要的事情，这些是我们可以用hardhat运行的一些主要任务不同的任务或者只是不同的命令，我们可以用hardhat运行。

4999
08:32:00.358 --> 08:32:07.967
例如，我们可以使用yarn hardhat计数，这将打印出我们可以使用Hardhead的假账户列表。

5000
08:32:07.967 --> 08:32:15.597
类似于我们使用ganache时使用的假账户列表，我们可以通过运行yarn Hardhead compile来编译我们的合同。

5001
08:32:15.597 --> 08:32:29.996
非常类似于我们对醚Jas和soap Jas所做的，你会看到，当我们运行compile时，我们会得到一个缓存，这将是访问固体文件的一种快速方式，我们也会得到一个工件部分。

5002
08:32:29.996 --> 08:32:42.751
这个artifacts文件夹包含我们在这里查看的关于编译后的代码的所有信息，例如，现在我们可以查看构建信息，并看到大量关于编译后的合同的信息。

5003
08:32:42.751 --> 08:32:46.576
如果你在看合同，我们可以看到更多的编译信息。

5004
08:32:46.576 --> 08:32:49.662
然后如果我们看一下安全帽，斜杠控制台。

5005
08:32:49.662 --> 08:32:51.695
因此，我们可以看到更多的编译信息。

5006
08:32:51.695 --> 08:32:55.687
所以我们所有的遵从性信息都将在这个artifacts文件夹中。

5007
08:32:55.687 --> 08:33:03.789
当你编译这个artifacts文件夹的时候你想看看底层发生了什么。

5008
08:33:03.789 --> 08:33:07.645
我们还可以运行一些其他的硬帽子任务。

5009
08:33:07.645 --> 08:33:10.797
但我们会边走边说的。

5010
08:33:10.797 --> 08:33:18.307
现在我们已经有了一些硬帽子的基础知识，让我们继续，试着做一些我们之前对醚做过的相同的事情，只不过是用硬帽子。

5011
08:33:18.307 --> 08:33:24.069
我们要做的第一件事就是编写智能合约并与之交互。

5012
08:33:24.069 --> 08:33:34.275
让我们把greeter。soul重命名为simple storage。soul，你可以点击文件并回车，然后就可以重命名了。

5013
08:33:34.275 --> 08:33:40.815
否则，你可以继续，右键点击，删除它，然后创建一个新文件并命名为simple storage。soul。

5014
08:33:40.815 --> 08:33:52.729
我们将从之前的简单存储中复制粘贴所有的代码到这个文件中，我们可以通过运行yarn hardhat compile来确保我们的简单存储正在正确编译。

5015
08:33:52.729 --> 08:33:57.721
哇，看起来我们遇到了一个项目无法编译的问题。

5016
08:33:57.721 --> 08:34:00.474
请参阅下面文件的实性编译版本的原因。

5017
08:34:00.474 --> 08:34:03.745
它与配置中的任何配置编译器都不匹配。

5018
08:34:03.745 --> 08:34:09.373
是这样的，合约/符号存储是Sol零点8。

5019
08:34:09.373 --> 08:34:09.438
8.

5020
08:34:09.438 --> 08:34:11.929
啊，好吧，让我们继续修复它们。

5021
08:34:11.929 --> 08:34:15.374
我们可以打开。config。js。

5022
08:34:15.374 --> 08:34:17.625
现在来简单介绍一下打开文件。

5023
08:34:17.625 --> 08:34:24.863
如果你在Mac上点击Command P，你就可以开始输入文件名以更快地获取文件。

5024
08:34:24.863 --> 08:34:35.292
如果你用的是Linux或Windows，你可以输入Ctrl p，这会弹出有趣的是，如果你输入man p或Ctrl p然后点击大于键。

5025
08:34:35.292 --> 08:34:44.242
这将把你拉到命令面板，知道命令面板，命令面板，搜索文件，搜索命令在我们的Hardhead点配置。

5026
08:34:44.242 --> 08:34:50.082
Jas，我要向下滚动到module。exports把这个改成0。8。

5027
08:34:50.082 --> 08:34:50.178
8.

5028
08:34:50.178 --> 08:34:57.574
我们要为简单存储编译的版本，它会是相同的版本而这个硬帽在寻找。

5029
08:34:57.574 --> 08:35:04.082
让我们通过点击yarn Hardhead compile来运行相同的命令，我们看到成功编译了一个固体文件。

5030
08:35:04.082 --> 08:35:06.404
我们现在应该在工件中看到这一点。

5031
08:35:06.404 --> 08:35:08.497
如果我们去找藏物和契约。

5032
08:35:08.497 --> 08:35:18.058
我们现在在这里看到两个合同，大存储和简单存储我们可以看到大量关于简单存储的信息我们还可以在信息和构建信息中看到更低级的信息。

5033
08:35:18.058 --> 08:35:23.808
好了，现在我们有了简单的存储契约，接下来我们可能要做的是学习如何部署它。

5034
08:35:23.808 --> 08:35:26.759
这是我们将要编写部署脚本的地方。

5035
08:35:26.759 --> 08:35:30.058
现在，在本节中，我将向您展示如何编写部署脚本。

5036
08:35:30.058 --> 08:35:33.262
但是在下一节，我们要做一些不同的事情。

5037
08:35:33.309 --> 08:35:36.936
但这仍然会教你如何写脚本以及如何在heart app中使用脚本。

5038
08:35:36.936 --> 08:35:44.324
我们会看到示例脚本。js，然后按回车键重命名它来部署。js。

5039
08:35:44.324 --> 08:35:50.145
如果你想阅读这里所有的评论，你完全可以，我们会把它们全部删除。

5040
08:35:50.145 --> 08:35:59.809
一个快速的键盘快捷键是，如果你按Command A或Ctrl A，你会高亮显示文件中的所有文本，我们会把它们全部删除。

5041
08:35:59.809 --> 08:36:01.696
现在我们要从头开始。

5042
08:36:01.696 --> 08:36:05.715
这里部署脚本的设置和部署脚本的设置非常相似。

5043
08:36:05.715 --> 08:36:13.260
在上一节中，我们将在顶部进行导入，我们将有async main函数，然后我们将调用main函数。

5044
08:36:13.309 --> 08:36:16.636
我们来定义main函数，称它为async。

5045
08:36:16.636 --> 08:36:20.722
函数main，像这样，然后我们调用main函数。

5046
08:36:20.722 --> 08:36:33.442
如果你想从上一节复制粘贴这个，你完全可以。

5047
08:36:33.442 --> 08:36:41.675
我们来定义域。

5048
08:36:42.309 --> 08:36:43.361
砰，就这样。

5049
08:36:45.309 --> 08:36:47.059
会把我逼疯的。

5050
08:36:48.309 --> 08:36:51.380
更漂亮，我们的坚固性更漂亮的插件。

5051
08:36:52.309 --> 08:37:03.212
纱线，添加破折号Dev，越来越漂亮，插入固体。

5052
08:37:03.212 --> 08:37:22.643
然后我们可以继续创建。pretty, rc文件，我们会添加制表符，带四个，使用制表符，假，半假，然后单引号，也是假。

5053
08:37:22.643 --> 08:37:27.310
现在我们将经常使用这个更漂亮的rc文件设置。

5054
08:37:27.310 --> 08:37:31.678
在以后的课程中，如果你想复制粘贴它，你也可以这么做。

5055
08:37:31.678 --> 08:37:43.960
我们还会添加一个。pretty tier, ignore，它告诉pretty tier不要格式化某些文件，我们不想让pretty tier花大量时间格式化所有文件，我将从GitHub repo复制粘贴。

5056
08:37:43.960 --> 08:37:51.276
所以你也可以从GitHub回购中复制粘贴，你会找到这部分的所有代码，就像我说的，在与这门课相关的GitHub回购中。

5057
08:37:51.310 --> 08:38:00.278
现在，与上一节不同的是，我们必须更手动地获取契约代码，使用硬帽，实际上有很多不同的方法来获取编译后的契约。

5058
08:38:00.310 --> 08:38:03.631
我们要做的第一种方法，实际上是使用醚。

5059
08:38:03.631 --> 08:38:08.465
这就是第一个令人困惑的变化。

5060
08:38:08.465 --> 08:38:12.950
之前，我们做了const ethers equals require ethers。

5061
08:38:12.950 --> 08:38:17.226
这就是我们继续研究乙醚的方法。

5062
08:38:17.226 --> 08:38:23.500
但是，您会注意到在我们的开发依赖项中，我们有一个称为Hard Hat醚的依赖项。

5063
08:38:23.500 --> 08:38:28.649
硬帽醚是一个包，实际上包装硬帽与它自己的内建醚。

5064
08:38:28.649 --> 08:38:35.738
这是非常有利的，因为它允许hard hat跟踪不同脚本的不同部署，以及为我们做的所有其他事情。

5065
08:38:35.738 --> 08:38:42.903
所以我们不是直接从醚中导入醚，而是直接从硬帽中导入醚。

5066
08:38:42.903 --> 08:38:53.884
这一开始可能会让人有点困惑，但如果我们想要用醚和心脏，通常最好从心脏取出来你仍然可以这样做，醚还是一样的工作。

5067
08:38:53.884 --> 08:38:59.953
但是“硬帽”不一定知道不同的合同工厂，你们马上就会看到这一点。

5068
08:38:59.953 --> 08:39:07.117
现在我们正在引进醚，我们实际上可以立即抓住一个使用醚的合同工厂。

5069
08:39:07.117 --> 08:39:19.111
我们可以说const simple storage factory = await醚。get contract。

5070
08:39:19.111 --> 08:39:22.829
工厂存储简单。

5071
08:39:22.829 --> 08:39:29.262
所以为了得到一个简单的仓库，代工厂，我们可以只做等待醚点代工厂。

5072
08:39:29.311 --> 08:39:38.573
如果我们直接从ethers中进行拉取，包ethers不知道这个契约文件夹ethers也不知道我们已经编译了simple storage。soul。

5073
08:39:38.573 --> 08:39:40.277
它存在于我们的文物中。

5074
08:39:40.277 --> 08:39:49.311
另一方面，Hard Hat确实知道契约文件夹，也确实知道它已经编译好了，这就是为什么这个简单的存储工厂抓取工作得如此好。

5075
08:39:49.311 --> 08:39:55.574
一旦我们有了我们的工厂，我们可以做我们在前一节中所做的相同的事情，并部署契约。

5076
08:39:55.574 --> 08:39:59.363
我们来做一个快速的console。log。

5077
08:39:59.363 --> 08:40:30.234
部署地板，契约完成，然后我们会用康德的简单存储= await simple store edge factory。Deploy，用这一小段代码，我们已经能够部署简单存储契约，然后等待确保它被部署，我们可以用await，简单存储，部署。

5078
08:40:30.311 --> 08:40:30.983
就是这样。

5079
08:40:33.312 --> 08:40:35.016
并运行这个部署脚本。

5080
08:40:37.312 --> 08:40:40.262
我们必须放入一个私钥，我们必须放入一个RPC URL。

5081
08:40:40.312 --> 08:40:43.562
现在，这两种情况我们都没有定义。

5082
08:40:44.312 --> 08:40:50.541
你认为这个脚本真的可以工作吗?或者你认为它会坏掉吗?因为我们没有定义我们要给你部署什么。

5083
08:40:50.541 --> 08:40:52.213
我们也没找到私钥。

5084
08:40:52.312 --> 08:40:54.778
好了，让我们来试试这个。

5085
08:40:56.312 --> 08:41:05.026
在我们的终端通过运行yarn, hard hat, run，脚本斜杠部署。j, s。

5086
08:41:05.026 --> 08:41:09.712
这里我按tab键，执行自动补全，看看会发生什么。

5087
08:41:09.712 --> 08:41:14.245
我们有部署合同，上面写着完成，但仅此而已。

5088
08:41:14.245 --> 08:41:18.249
那么到底发生了什么?我们在这里再加一行。

5089
08:41:18.312 --> 08:41:20.712
我们写console。log。

5090
08:41:24.312 --> 08:41:26.682
部署，契约到。

5091
08:41:26.682 --> 08:41:30.520
然后我们会添加简单的存储。

5092
08:41:31.312 --> 08:41:31.867
地址。

5093
08:41:31.867 --> 08:41:33.374
让我们现在运行这个。

5094
08:41:36.312 --> 08:41:40.249
我们得到了部署合同，然后我们得到了合同地址。

5095
08:41:40.312 --> 08:41:43.278
嗯，这是怎么回事。

5096
08:41:47.312 --> 08:42:00.279
Hard Hat Network是一个本地Aetherium网络节点，专为开发而设计，类似于ganache，它允许您部署您的合同，运行您的测试和调试您的代码。

5097
08:42:00.312 --> 08:42:09.139
每当我们在硬帽中运行一个命令，或者一个脚本和硬帽，或者一个任务和硬帽，我们默认部署到这个假的硬帽网络。

5098
08:42:09.139 --> 08:42:16.681
这个Hard Hat Network非常类似于ganache，除了它没有这个UI，而是在我们的脚本的后台运行。

5099
08:42:16.681 --> 08:42:18.531
事实上，如果我们用安全帽。

5100
08:42:18.531 --> 08:42:18.967
配置。

5101
08:42:18.967 --> 08:42:27.113
Js中，我们可以向下滚动到这个导出section的模块底部，并添加更多关于默认网络的信息。

5102
08:42:27.113 --> 08:42:35.872
现在，如果这个模块中没有任何东西可以导出，默认情况下，它会添加这个，default network hardhat。

5103
08:42:35.872 --> 08:42:43.201
所以当我们运行一个脚本时，不指定网络，它会自动使用这个假的Hard Hat network。

5104
08:42:43.201 --> 08:42:49.041
这个假的Hard Hat Network自动附带一个RPC URL和一个私钥。

5105
08:42:49.041 --> 08:42:50.990
所以你甚至不需要加一个。

5106
08:42:50.990 --> 08:42:54.726
这是与Hardhead合作的主要优势之一。

5107
08:42:54.726 --> 08:42:57.741
它会自动给你这个假区块链。

5108
08:42:57.741 --> 08:43:01.205
这些假私钥，如果你想更明确一点的话。

5109
08:43:01.205 --> 08:43:07.590
我总是建议更明确一点，我们可以将默认网络添加到专家模块中。

5110
08:43:07.590 --> 08:43:11.154
现在我们的默认网络被显式地声明为hard hat。

5111
08:43:11.154 --> 08:43:15.877
但是，在您运行的任何脚本中，您都可以选择想要使用的任何网络。

5112
08:43:15.877 --> 08:43:34.872
如果我想明确地说，我想在假的Hard Hat网络上运行我们的deploy脚本，我可以用yarn，运行脚本，deploy。js, dash, Network，这是我们告诉她，嘿，我们想在Hard Hat网络上运行这个脚本。

5113
08:43:34.872 --> 08:43:37.829
希望你们能明白这是怎么回事。

5114
08:43:37.829 --> 08:43:46.027
有了这个网络标志，在不同的链、不同的区块链、不同的私钥等之间切换变得非常容易。

5115
08:43:46.027 --> 08:43:51.264
我们在硬帽上设置了默认网络，我们还可以在这里添加其他网络。

5116
08:43:51.314 --> 08:43:56.230
我们要做的是增加一个网络部分。

5117
08:43:56.314 --> 08:43:58.536
我们要定义任何我们想要的网络部分。

5118
08:43:58.536 --> 08:44:03.434
记得在这里加个注释这样你的Visual Studio代码就不会对你发火了。

5119
08:44:03.434 --> 08:44:08.823
最近，我们和里格比合作我们在这里添加一个里格比网络。

5120
08:44:08.823 --> 08:44:13.001
所以我们会说另一家电视台会很酷。

5121
08:44:13.001 --> 08:44:21.035
现在我应该可以把网络标志改为Rigby了，对吧?嗯，不完全是。

5122
08:44:21.035 --> 08:44:28.830
如果你试着运行它，你会得到无效值未定义的硬帽配置网络。

5123
08:44:28.830 --> 08:44:38.614
Rigby，那个URL，它希望你告诉它，嘿，URL是什么，因为这不是硬帽网络，我们需要告诉硬帽我们要如何连接到溜冰场B。

5124
08:44:38.614 --> 08:44:44.720
这就是我们之前学过的很多东西会派上用场的地方，同样，和我们之前做的完全一样。

5125
08:44:44.720 --> 08:44:51.861
我们将创建一个新的Dotty v文件，我们将在这个。env文件中添加Rigby URL。

5126
08:44:51.861 --> 08:44:55.847
记住，。env是r。get忽略以防万一。

5127
08:44:55.847 --> 08:45:02.091
在我们的Dotty环境中，我们会从alcmi添加那个RPC URL在我们说RPC URL之前。

5128
08:45:02.091 --> 08:45:10.647
但由于我们可能希望跨多个网络工作，所以最好准确指定每个URL所代表的网络。

5129
08:45:10.647 --> 08:45:17.456
我们写入Rynkeby RPC URL =然后将URL粘贴到这里。

5130
08:45:17.456 --> 08:45:22.914
现在，你可能已经猜到了，我们可以把我们的URL添加到我们的Rinkeby网络。

5131
08:45:22.914 --> 08:45:28.126
为了可读性，我通常喜欢将它们作为变量添加到专家模块的正上方。

5132
08:45:28.126 --> 08:45:30.517
我写上const Rynkeby。

5133
08:45:30.517 --> 08:45:39.970
RPC URL等于进程点E和V点Rynkeby RPC URL。

5134
08:45:40.315 --> 08:45:45.695
再一次，我们会从环境变量中提取那个Rinckey RPC URL。

5135
08:45:45.695 --> 08:45:51.429
当然，为了把那个环境变量拉进来，我们需要再次使用那个。env包。

5136
08:45:51.429 --> 08:45:56.380
为了把它添加进去，我们要添加dash dev。EMV。

5137
08:45:56.380 --> 08:46:09.179
在Hardhead配置的顶部，我们会添加require。EMV，然后做。配置来启用配置。

5138
08:46:09.179 --> 08:46:13.781
现在这意味着我们应该能够从我们的点环境中拉我们的rink RPC URL。

5139
08:46:13.781 --> 08:46:21.205
现在我们有了在我们的Rinkeby网络，我们可以添加URL Rinckey RPC URL。

5140
08:46:21.315 --> 08:46:21.653
太棒了。

5141
08:46:21.653 --> 08:46:23.782
我们有一个用于不同网络的RPC URL。

5142
08:46:24.315 --> 08:46:37.625
我们通常还需要什么?嗯，我们通常需要一个私钥来使用一个实际的网络，或者它不会自动给我们一个橄榄球的私钥，因为Hardhead不能只给我们测试和以太，我们需要一个实际的帐户一个实际的测试网络。

5143
08:46:37.625 --> 08:46:39.762
硬脑党控制不了这些。

5144
08:46:39.762 --> 08:46:43.121
我们需要给它一个真实的URL和一个真实的私钥。

5145
08:46:43.121 --> 08:46:53.992
要添加私钥，你需要添加一个叫做账户的东西，你需要添加一个你想给硬帽的账户列表，我们只需要添加一个，这就是我们的私钥。

5146
08:46:53.992 --> 08:46:56.901
对于私钥，我们会做完全相同的事情。

5147
08:46:56.901 --> 08:47:03.569
我们说const private key = process。env。private key。

5148
08:47:03.569 --> 08:47:12.269
因为这个私钥是真实测试网的真实私钥，我们需要从元掩码中获取这个。

5149
08:47:12.316 --> 08:47:20.225
它会到元掩码，三个点，账户详细信息，导出私钥，然后在这里添加密码。

5150
08:47:20.316 --> 08:47:26.008
然后在。env中加上私钥=然后加上私钥。

5151
08:47:26.008 --> 08:47:37.758
现在我知道我已经说过100次了，但是为了学习这个，请不要使用连接任何真钱的真密钥，以防万一，请使用一个新的元掩码。

5152
08:47:37.758 --> 08:47:39.282
我知道我说过很多次了。

5153
08:47:39.282 --> 08:47:42.125
但有些人会说，不，我会没事的，我会很安全的。

5154
08:47:42.125 --> 08:47:46.231
为了超级超级安全，请使用全新的元遮罩。

5155
08:47:46.231 --> 08:47:50.848
现在我们有了私钥，我们要把它加到这里帐户私钥。

5156
08:47:50.848 --> 08:47:52.396
现在我们有了一个账户。

5157
08:47:52.396 --> 08:48:07.037
我还想做的一件事是给出网络的链ID，对于里格比来说，这将是每一个EVM基网络的新链ID EVM网络基本上意味着它的坚固性起作用。

5158
08:48:07.037 --> 08:48:11.066
这包括所有的测试网，有一个很好的网站叫chainless。

5159
08:48:11.066 --> 08:48:16.052
Org，它可能会关闭，也可能不会关闭，它有一个不同网络的列表。

5160
08:48:16.052 --> 08:48:27.399
例如，你可以在这里看到一个理论主网有一个字节的链ID和智能链是56，雪崩，4311幻影，歌剧250，多边形，137等等。

5161
08:48:27.399 --> 08:48:37.899
每一个与EVM兼容的链都有自己的链ID，等级为V，链ID用于添加链ID，对后面的内容很有帮助。

5162
08:48:37.899 --> 08:48:39.300
我们以后会讲到这个。

5163
08:48:39.300 --> 08:48:41.792
但现在，请确保添加了链id。

5164
08:48:41.792 --> 08:48:51.512
好的，现在我们有了RPC URL，我们有了私钥，我们可以继续测试将它部署到一个实际的测试网络，实际上在这里做了一些错误的事情。

5165
08:48:51.512 --> 08:48:53.184
我们会在这里得到一个错误。

5166
08:48:53.184 --> 08:48:58.248
我希望你们自己去找出并调试这个错误。

5167
08:48:58.317 --> 08:48:59.254
你准备好了。

5168
08:48:59.254 --> 08:49:00.894
好吧，我们开始吧。

5169
08:49:03.317 --> 08:49:09.768
脚本，部署点j s，破折号网络Rinkeby。

5170
08:49:11.317 --> 08:49:16.850
这个奇怪的错误，我们已经部署了契约。

5171
08:49:16.850 --> 08:49:31.768
我们知道，在部署脚本中，我们至少到达这一行，然后我们会得到一个错误，我很可能会听到，不能读取属性没有读取发送事务，如果你想，你完全可以到这里。

5172
08:49:31.768 --> 08:49:38.546
但它似乎很难理解私钥或账户是什么。

5173
08:49:38.546 --> 08:49:46.710
你觉得我会建议我们怎么做呢?如果不清楚的话，在做了一些分类和调试之后，我们将复制这个空气。

5174
08:49:46.710 --> 08:49:50.418
我们来到谷歌，把它粘贴进去。

5175
08:49:50.418 --> 08:49:55.398
看起来我们确实从stackexchange Etherium那里得到了一个问题。

5176
08:49:55.398 --> 08:49:58.523
看起来和我们现在做的很像。

5177
08:49:58.523 --> 08:49:59.475
我们向下滚动。

5178
08:49:59.475 --> 08:50:05.269
他们运行的脚本和我们几乎完全一样，他们使用MPX而不是yarn。

5179
08:50:05.269 --> 08:50:08.189
他们有一个非常简单的部署文件。

5180
08:50:08.317 --> 08:50:11.017
让我们向下滚动，看看答案都说了些什么。

5181
08:50:11.317 --> 08:50:14.178
看到我的私钥没有正确填充的错误。

5182
08:50:14.317 --> 08:50:18.575
也会使用环境变量我很确定环境变量有用吗

5183
08:50:18.575 --> 08:50:30.442
但是我们在你的脑海里有第二个想法，Jas，我认为它应该是帐户而不是帐户，这对我来说是有效的，让我们回到我们的头部配置，看看这是不是真的发生了。

5184
08:50:30.442 --> 08:50:33.280
嗯，我们把account放在这里，应该是account。

5185
08:50:33.280 --> 08:50:34.762
我们把它换到账户上。

5186
08:50:34.762 --> 08:50:36.150
我们会清空终点站。

5187
08:50:36.150 --> 08:50:37.675
我们再运行一遍。

5188
08:50:37.675 --> 08:50:38.175
嗯嗯。

5189
08:50:38.175 --> 08:50:41.937
现在它的读数变长了一点，这很好。

5190
08:50:41.937 --> 08:50:45.979
这意味着我们可能会把它部署到B溜冰场，这是我们想看到的。

5191
08:50:45.979 --> 08:50:46.348
太棒了。

5192
08:50:46.348 --> 08:50:51.055
现在我们可以看到部署合同到，这里有一个合同地址。

5193
08:50:51.055 --> 08:50:52.518
所以我们要拿到这份合同。

5194
08:50:52.518 --> 08:50:56.365
我们来看看以太扫描，这就是以太扫描的编号。

5195
08:50:56.365 --> 08:50:58.528
我们继续，把这个粘贴进去。

5196
08:50:58.528 --> 08:50:58.949
太棒了。

5197
08:50:58.949 --> 08:51:02.416
我们的合同是26秒前创建的。

5198
08:51:02.416 --> 08:51:02.940
完美的。

5199
08:51:02.940 --> 08:51:07.794
现在对于这部分，你不必把它部署到溜冰场跟我一起，如果你跟着我。

5200
08:51:07.794 --> 08:51:08.698
这就足够了。

5201
08:51:08.698 --> 08:51:11.603
所以请记住，飞行测试需要很长时间。

5202
08:51:11.603 --> 08:51:14.718
所以这次，你不用和我一起部署。

5203
08:51:14.718 --> 08:51:16.218
好了,好了。

5204
08:51:16.218 --> 08:51:20.068
所以我们在溜冰场部署了安全帽。

5205
08:51:20.068 --> 08:51:21.032
这太棒了。

5206
08:51:21.032 --> 08:51:33.518
现在我们注意到，我们的合同没有得到验证?我们是否需要重新检查并验证并发布所有这些内容?幸运的是，我们实际上不需要这样做。

5207
08:51:33.518 --> 08:51:40.753
那么我们能做什么呢?好了，回到部署脚本中，我们可以添加一些代码，以便在部署后立即进行自动验证。

5208
08:51:40.753 --> 08:51:42.204
我们来做一下。

5209
08:51:42.204 --> 08:51:50.484
在主函数的正下方，我们会创建一个新函数，叫verify，我们会写async function, verify。

5210
08:51:50.484 --> 08:52:00.644
我们要让这个函数通过一些参数，我们要通过契约，地址，和一些参数或契约。

5211
08:52:00.644 --> 08:52:05.645
因为简单存储没有构造函数，所以简单存储的参数是空的。

5212
08:52:05.645 --> 08:52:11.842
但在未来，当我们有契约有构造函数时，实参将被填充。

5213
08:52:11.842 --> 08:52:20.934
当我们到达那里时，你会明白我的意思，我们至少需要合同地址，我们会在这里添加一些代码来在部署后自动验证我们的合同。

5214
08:52:20.934 --> 08:52:30.247
这种自动验证过程适用于以太扫描等块探测器，但可能不适用于eath、pler或其他块探测器等块探测器。

5215
08:52:30.247 --> 08:52:35.652
但如果你想在这些其他的块探索器上进行验证，我相信它们也有一个API允许你这样做。

5216
08:52:35.652 --> 08:52:44.319
现在，ether scan在大多数其他区块探索者的网站上都有一个部分叫做API文档，或者与API相关的东西。

5217
08:52:44.319 --> 08:52:49.022
这些是我们通过编程与以太扫描交互的方法，并用它们来做一些事情。

5218
08:52:49.022 --> 08:52:55.284
我们能做的主要事情之一是我们能通过这个API验证我们的契约。

5219
08:52:55.284 --> 08:52:59.852
以太扫描在这里甚至有一个教程叫做以编程方式验证契约。

5220
08:52:59.852 --> 08:53:07.207
这个的链接会在GitHub回购中，他们有一个API端点我们可以向它发出一些请求来验证我们的合同。

5221
08:53:07.207 --> 08:53:11.533
现在，我们完全可以进行原始API调用并遵循这里的教程。

5222
08:53:11.533 --> 08:53:15.790
但实际上有一种比本教程更简单的方法。

5223
08:53:15.790 --> 08:53:21.254
Hardhead是一个可扩展的框架，这意味着您可以向其添加插件。

5224
08:53:21.319 --> 08:53:25.105
文档中甚至有一个高级部分叫做构建插件。

5225
08:53:25.105 --> 08:53:32.132
如果我们向下滚动到底部，我们可以看到nomic labs团队或Hardhead团队创建的一些流行插件。

5226
08:53:32.132 --> 08:53:34.456
还有一些社区插件。

5227
08:53:34.456 --> 08:53:42.013
最常用的Hardhead插件之一将是这个硬帽以太扫描插件，使这个验证过程非常非常容易。

5228
08:53:42.013 --> 08:53:50.384
安装它，你可以运行npm Install bash，把dev保存在nomic labs harden ether scan，然后把它添加到我们的hard hat。config中。

5229
08:53:50.384 --> 08:53:53.709
既然我们用的是纱线，我们就继续用纱线。

5230
08:53:53.709 --> 08:54:06.425
回到我们的代码，我们会做yarn，添加破折号Dev, at nomic, labs，斜杠硬帽斜杠连字符，以太扫描。

5231
08:54:06.425 --> 08:54:23.336
现在我们有了这个插件，我们可以去我们的硬帽点配置，滚动到顶部，添加这个插件do require at nomic labs / hard hat, ether scan。

5232
08:54:23.336 --> 08:54:33.658
现在我们有了这个插件，硬帽文档有更多关于用法的信息，如何实际使用这个插件，以及如何使用它运行不同的命令。

5233
08:54:33.658 --> 08:54:38.227
为了让我们使用这种验证，我们实际上需要一个来自以太扫描的API密钥。

5234
08:54:38.227 --> 08:54:42.746
这基本上是一个密码，允许我们使用以太扫描API。

5235
08:54:42.746 --> 08:54:44.981
接下来我们要讲以太扫描。

5236
08:54:44.981 --> 08:54:47.014
现在我们要去签到了。

5237
08:54:47.014 --> 08:54:51.256
我们要点击注册并创建一个账户。

5238
08:54:51.320 --> 08:54:53.320
我们将继续创建一个帐户。

5239
08:54:54.320 --> 08:54:57.268
通过单击验证链接来验证我们的注册。

5240
08:54:57.320 --> 08:54:58.591
然后点击登录。

5241
08:54:58.591 --> 08:54:59.862
现在我们已经登录了。

5242
08:55:00.320 --> 08:55:02.582
在左手边，我们可以向下滚动到API键。

5243
08:55:03.320 --> 08:55:06.320
，并创建一个新的API密钥。

5244
08:55:09.320 --> 08:55:11.270
它代表着硬帽自由代码营。

5245
08:55:12.320 --> 08:55:18.695
key会复制这个，然后回到我们的代码，我们会把这个添加到某个地方，因为API key基本上被认为是密码。

5246
08:55:18.695 --> 08:55:22.029
你觉得我们应该把这个加在哪里?它就在。env中。

5247
08:55:22.029 --> 08:55:27.739
在。env中，我们会添加一个新条目ether scan API key。

5248
08:55:27.739 --> 08:55:32.133
我们会添加刚得到的那个API键。

5249
08:55:32.133 --> 08:55:46.237
现在我们有了API键，回到Hardhead的配置中，我们要在模块。exports中创建一个新节，告诉hardhat我们有这个ether scan API键，或者新节叫ether scan。

5250
08:55:46.321 --> 08:55:56.880
在这里，我们会说API key is going to ether scan API key我们会在这里定义它和我们定义其他键的方式一样。

5251
08:55:56.880 --> 08:56:04.493
因此我们写入const, ether scan API key = process。env。ether scan API key。

5252
08:56:04.493 --> 08:56:11.633
如果出现这样的东西，你可以按回车键，它会自动补全，这很好。

5253
08:56:11.633 --> 08:56:12.008
太好了。

5254
08:56:12.008 --> 08:56:19.921
现在我们有一个以太扫描API键在心脏文档中，它告诉我们通过添加这个，我们得到一个新任务叫verify。

5255
08:56:19.921 --> 08:56:21.302
让我们试一下。

5256
08:56:21.302 --> 08:56:23.676
打开我们的终端。

5257
08:56:23.676 --> 08:56:25.879
我们会做纱线，RT帽。

5258
08:56:25.879 --> 08:56:27.894
让我们看看会出现什么。

5259
08:56:27.894 --> 08:56:31.172
哇，我们确实有了新的证据。

5260
08:56:31.172 --> 08:56:35.476
当我们使纱线硬帽更用力时，它实际上会看到我们的硬帽。

5261
08:56:35.476 --> 08:56:35.786
配置。

5262
08:56:35.786 --> 08:56:37.286
Js和检查任何插件。

5263
08:56:37.286 --> 08:56:42.003
如果有新的插件，它会添加它们作为我们可以做的新任务。

5264
08:56:42.003 --> 08:56:52.659
您可以通过执行yarn或MPX Harnett验证破折号网络、部署的合同地址和任何构造函数参数来手动验证您的合同。

5265
08:56:52.659 --> 08:56:55.830
但我们想要比这更程序化一点。

5266
08:56:55.830 --> 08:57:07.626
我们要做的是返回去创建这个验证函数，知道如何通过命令行来做是很好的如果你将来想手动验证某些东西，你可以，让我们来创建这个验证函数。

5267
08:57:07.626 --> 08:57:11.033
我们将使用我们的合同地址和一些论点。

5268
08:57:11.033 --> 08:57:20.655
为了我们的目的，我们要做console。log验证契约这样我们就知道我们可能需要等待一段时间。

5269
08:57:20.655 --> 08:57:27.644
在我们的代码中，我们可以使用运行包从硬帽运行任何任务。

5270
08:57:27.644 --> 08:57:35.966
在最上面，我们会从硬帽导入run run允许我们运行任何硬帽任务。

5271
08:57:35.966 --> 08:57:40.845
在我们的代码中，我们会做一个等待运行。

5272
08:57:40.845 --> 08:57:43.857
然后我们就可以这样做了。

5273
08:57:43.857 --> 08:57:47.773
现在它允许你在运行中添加不同的参数。

5274
08:57:47.773 --> 08:57:53.870
通常最好的做法是把它们加到这里这样我们就能清楚地知道我们在做什么。

5275
08:57:53.870 --> 08:58:00.795
如果我们做yarn hardhat验证破折号帮助，我们可以看到我们实际上可以传递什么参数。

5276
08:58:00.795 --> 08:58:03.625
看起来我们可以传递Verify参数。

5277
08:58:03.625 --> 08:58:05.303
我们用冒号来验证。

5278
08:58:05.303 --> 08:58:20.951
如果你去到GitHub的验证任务，你会发现你能做的不仅仅是验证，你能做验证，获取最小构建，验证，获取构造函数参数，验证，验证，这是我们要处理的，还有一些其他子任务。

5279
08:58:20.951 --> 08:58:26.016
进入run的第二个参数将是一个实际参数的列表。

5280
08:58:26.016 --> 08:58:29.949
第二个参数是验证任务的子任务。

5281
08:58:29.949 --> 08:58:33.550
这将是一个包含实际参数的对象。

5282
08:58:33.550 --> 08:58:47.877
这里我们传入一个地址，这将是我们的契约地址，然后是我们的构造或参数，这将是弧。

5283
08:58:47.877 --> 08:58:58.273
通常，这里的这个就足够我们在main函数中使用这个验证契约了，但我们还要再添加一个东西。

5284
08:58:58.323 --> 08:59:00.667
因为在实践中，有时会出现一些错误。

5285
08:59:00.667 --> 08:59:05.144
运行等待时经常出现的错误之一是契约已经经过了验证。

5286
08:59:05.144 --> 08:59:16.823
实际上你很可能会遇到这种情况，因为以太扫描会变得足够智能，通过看到足够多的字节码，这些字节码完全是简单的存储，它会开始自动验证任何看起来像简单存储的字节码。

5287
08:59:16.823 --> 08:59:20.751
然后这个await会抛出一个错误，这是我们想避免的。

5288
08:59:20.751 --> 08:59:26.886
我们能做的是在这个await上添加一个try catch。

5289
08:59:26.886 --> 08:59:29.385
在外面，我们要加一个try。

5290
08:59:29.385 --> 08:59:33.688
我们要加上这些小托架来包裹我们的重量。

5291
08:59:33.688 --> 08:59:36.880
然后我们要把球接住。

5292
08:59:36.880 --> 08:59:42.291
这被称为尝试，捕捉和固体也有尝试捕捉。

5293
08:59:42.291 --> 08:59:46.465
但基本上，这个e将是这部分抛出的任何错误。

5294
08:59:46.465 --> 08:59:52.688
所以我们要做的是我们会说如果这个消息已经被验证了，那么我们就继续。

5295
08:59:52.688 --> 08:59:53.797
我们说if e。

5296
08:59:53.797 --> 08:59:54.627
消息。

5297
08:59:54.627 --> 09:00:03.846
到小写，我们要确保它是小写那已经包含在那里了。

5298
09:00:03.846 --> 09:00:12.026
如果是5，我们就会用console。log这样。

5299
09:00:12.026 --> 09:00:15.854
否则，就写成console。log e。

5300
09:00:15.854 --> 09:00:22.909
我们这样做的原因是因为这些错误，我们的验证函数将中断，我们的整个脚本将结束。

5301
09:00:22.909 --> 09:00:28.909
我们不希望整个脚本结束，我们希望如果验证不成功，我们的脚本还能继续，因为这没什么大不了的。

5302
09:00:28.909 --> 09:00:35.291
我知道这看起来像很多代码，请随意从GitHub repo复制粘贴它，继续。

5303
09:00:35.291 --> 09:00:36.065
但是太棒了。

5304
09:00:36.065 --> 09:00:40.609
因此，我们现在有了一个使用hardhat中的verify任务的验证函数。

5305
09:00:40.609 --> 09:00:49.098
让我们在主函数中使用这个，就在deploy下面，我们写console。log deployte2，然后是契约地址。

5306
09:00:49.098 --> 09:00:53.609
但在我们调用这个main函数之前，让我们快速思考一下。

5307
09:00:53.609 --> 09:01:10.590
当我们部署到RT Hat网络时会发生什么?嗯，记住，如果我们部署到我们的硬帽网络，我们的合同需要验证我需要扫描吗?我们知道有一个我们知道有一个冰场以太扫描，我们知道有一个COVID以太扫描，我们知道有一个主网简易扫描。

5308
09:01:10.590 --> 09:01:14.190
但有硬头牌以太扫描吗?不，当然不是。

5309
09:01:14.324 --> 09:01:19.035
对吧?硬运行时环境是我们机器的本地网络。

5310
09:01:19.035 --> 09:01:23.942
因此，我们在以太扫描上验证硬帽网络部署合同是没有意义的。

5311
09:01:23.942 --> 09:01:29.799
当我们使用本地网络时，我们实际上不想调用这个verify函数。

5312
09:01:29.799 --> 09:01:33.001
这就是链id非常有用的地方。

5313
09:01:33.001 --> 09:01:47.544
我们能做的是检查我们运行的网络是一个活动网络还是一个测试网络，或者它是一个实际上可以被验证的网络，我们可以通过导入这样的网络来获得网络配置信息。

5314
09:01:47.544 --> 09:01:55.040
我们可以做console。log network。config。

5315
09:01:55.040 --> 09:01:59.569
现在，如果我运行yarn, art，点击运行脚本部署。

5316
09:01:59.569 --> 09:01:59.744
js。

5317
09:01:59.744 --> 09:02:07.696
在我们的硬帽网络中，因为我没有传递网络标志，我们得到了像这样的大量输出。

5318
09:02:07.696 --> 09:02:25.712
我们的网络点配置包含大量关于当前网络的信息，你会在这里看到Hardhead网络的链ID实际上是31337天然气价格，它被设置为自动阻塞天然气限制当前的Aetherium，我们正在工作，以及所有这些其他部分。

5319
09:02:25.712 --> 09:02:27.798
这个链ID非常重要。

5320
09:02:27.798 --> 09:02:33.158
因为我们可以用这个链ID来判断哪个是测试网，哪个是活动网络。

5321
09:02:33.158 --> 09:02:43.234
记住，运行这个脚本和运行破折号网络是一样的，你会看到我们的频道ID仍然是31337。

5322
09:02:43.234 --> 09:02:54.477
再说一次，那是因为我们心中的默认网络有配置，它是硬帽，也就是说，每次我们运行一个脚本时，我们都在偷偷地用破折号网络硬帽运行它。

5323
09:02:54.477 --> 09:02:56.815
现在我们只需要在测试网上验证。

5324
09:02:56.815 --> 09:03:08.228
我们能做的是，如果network。config，那个chain ID等于等于等于4，也就是B。ad。

5325
09:03:08.325 --> 09:03:28.769
JavaScript的等号和等号几乎是一样的，只是没有进行类型转换，这意味着在JavaScript中，4等于4,4等于字符串4，但如果你使用4等于等于4，这是错误的。

5326
09:03:28.769 --> 09:03:40.734
这是真的= = 4 = = =也为真，4 = = =字符串4也为真，但4 = = = =字符串4将为假。

5327
09:03:40.734 --> 09:03:43.954
你可以在这里做任何你想做的事。

5328
09:03:43.954 --> 09:03:53.786
我们想说，如果network。config。Trinity是4，如果我们在Rinkeby，那么我们可以继续进行验证。

5329
09:03:53.786 --> 09:03:59.611
但我们还希望确保只验证以太扫描API键是否存在。

5330
09:03:59.611 --> 09:04:09.801
所以我们也可以在这里是site，这个双&的意思是我们可以说process。env。ether scan API key。

5331
09:04:09.801 --> 09:04:31.067
这是我们在这里做的一些布尔技巧，基本上，我们的第一个条件我们说如果network。config chinati等于等于等于4，这个部分可以是真或假，很明显，对吧?我们运行的链ID可能是最难的网络，这意味着这个不等于4，或者是Rinckey，这意味着这个等于4。

5332
09:04:31.067 --> 09:04:33.136
但这一边没有条件。

5333
09:04:33.136 --> 09:04:40.402
那么这一边是怎么工作的呢?在JavaScript中，如果一个对象存在，并且您试图将其转换为布尔值，那么它将被转换为true。

5334
09:04:40.402 --> 09:04:43.289
如果它不存在，它将被转换为false。

5335
09:04:43.289 --> 09:04:51.563
在JavaScript中，如果任何一个scan API key存在，如果VI中的数据中有这个，这就成立。

5336
09:04:51.563 --> 09:04:53.676
如果不是，这就是假的。

5337
09:04:53.676 --> 09:05:06.808
另一种解读这一行的方式是如果network。config Trinity是为AKA准备的，如果我们在溜曲棍场B上，以太扫描API键存在，然后做一些事情。

5338
09:05:06.808 --> 09:05:08.459
这就是我们要做的。

5339
09:05:08.459 --> 09:05:23.084
在这里，我们要运行verify函数并将合约地址传递给它它将是Simple Storage。address构造函数参数我们知道它将是空的。

5340
09:05:23.084 --> 09:05:31.262
因为verify函数是async函数，它处理承诺之类的，我们要在这里添加await关键字。

5341
09:05:31.326 --> 09:05:31.664
太棒了。

5342
09:05:34.327 --> 09:05:35.850
但我们还没有完成。

5343
09:05:38.327 --> 09:05:52.432
在我们部署合同和发送合同的瞬间，以太扫描可能还不知道交易，以太扫描可能需要一秒钟才能跟上区块链的位置。

5344
09:05:52.432 --> 09:05:59.165
因此，最好的做法是等待几个区块被挖出，直到真正运行验证过程。

5345
09:05:59.165 --> 09:06:02.670
我们实际上已经学习了如何使用部署事务做到这一点。

5346
09:06:02.670 --> 09:06:10.233
在我们验证运行之前，我们想运行一个权值，简单的存储。

5347
09:06:10.327 --> 09:06:14.458
部署事务等等，6。

5348
09:06:19.327 --> 09:06:21.184
然后我们将运行我们的验证过程。

5349
09:06:22.327 --> 09:06:24.638
现在测试一下，你完全可以。

5350
09:06:25.327 --> 09:06:30.447
继续，因为再次强调，在测试网上测试所有这些需要额外的时间。

5351
09:06:30.447 --> 09:06:36.654
我要完成剩下的main函数，然后我要把所有的都运行起来。

5352
09:06:36.654 --> 09:06:37.602
好的,很酷。

5353
09:06:37.602 --> 09:06:43.704
我们已经部署了我们的契约，我们已经自动地通过编程验证了我们的契约。

5354
09:06:43.704 --> 09:06:49.445
接下来是什么?上次我们做了什么，我们开始与合约互动。

5355
09:06:49.445 --> 09:06:50.903
我们来做const。

5356
09:06:50.903 --> 09:06:57.016
当前值等于等待简单的存储点检索。

5357
09:06:57.016 --> 09:07:01.562
获取当前值，简单的存储，仅此而已。

5358
09:07:01.562 --> 09:07:08.408
我们有一个检索函数，它返回喜爱的数字，所以让我们获取当前值。

5359
09:07:08.408 --> 09:07:20.784
我们写console。log，当前值是然后是一些字符串插值，当前值。

5360
09:07:20.784 --> 09:07:28.394
然后我们继续通过做cons来更新当前值。

5361
09:07:28.394 --> 09:07:48.994
事务响应等于等待简单存储，该存储将存储数字7，然后我们将等待事务响应。等待，我们将等待一个块，让事务通过。

5362
09:07:48.994 --> 09:08:00.972
我们会通过说const updated value = await simple storage。retrieve来获取更新后的值。

5363
09:08:00.972 --> 09:08:06.700
然后我们将做控制台日志。

5364
09:08:06.700 --> 09:08:12.128
新增的值为更新后的值。

5365
09:08:12.128 --> 09:08:12.620
太棒了。

5366
09:08:12.620 --> 09:08:15.143
这就是我们的整个脚本。

5367
09:08:15.328 --> 09:08:24.972
如果我把它缩小一点，我知道这里会小一点，我们有一个巨大的主函数，它是做什么的?它部署了我们的契约。

5368
09:08:24.972 --> 09:08:28.182
如果我们在一个测试网上，它会验证我们的契约。

5369
09:08:28.182 --> 09:08:30.489
然后它将值更新为7。

5370
09:08:30.489 --> 09:08:33.198
下面是验证函数。

5371
09:08:33.328 --> 09:08:37.734
我们有一段代码调用main函数。

5372
09:08:37.734 --> 09:08:39.818
现在在硬帽网络上运行这个。

5373
09:08:39.818 --> 09:08:44.819
你认为会发生什么?让我们试试yarn，或者net run脚本。

5374
09:08:44.819 --> 09:08:45.871
部署点j s。

5375
09:08:45.871 --> 09:08:55.984
好了，很好，我们得到了之前看到的情况我们得到了部署契约部署契约到当前值为0，更新值为7。

5376
09:08:55.984 --> 09:08:57.777
这里没有关于验证的内容。

5377
09:08:57.777 --> 09:08:59.234
这正是我们想要的。

5378
09:08:59.234 --> 09:09:00.818
现在是关键时刻。

5379
09:09:00.818 --> 09:09:03.040
让我们在Rinkeby身上试试这个。

5380
09:09:03.040 --> 09:09:11.777
我们会做yarn, RT hat运行脚本，部署。j s, dash dash网络Rinkeby。

5381
09:09:11.777 --> 09:09:20.802
它的速度会慢很多，因为很明显，现在我们正在部署一个实际的测试网，在那里方块需要被挖掘。

5382
09:09:20.802 --> 09:09:22.910
我们看到我们还没有部署合同。

5383
09:09:22.910 --> 09:09:24.757
现在我们的合同已经部署好了。

5384
09:09:24.757 --> 09:09:29.515
我们知道，我们目前正在等待六个区块的确认，以便我们继续进行验证。

5385
09:09:29.515 --> 09:09:39.672
我应该加上console。log，等待阻塞x这样我们就不会有校园怪圈了。

5386
09:09:39.672 --> 09:09:49.040
等等，我们现在要做什么?看起来我们遇到了这个错误，没有这样的文件或目录，看起来我们的代码在这里没有正确编译。

5387
09:09:49.040 --> 09:09:50.463
这就是我要做的。

5388
09:09:50.463 --> 09:09:53.805
我们要把藏物删除，丢进垃圾桶。

5389
09:09:53.805 --> 09:09:55.968
我们也要删除我们的缓存。

5390
09:09:55.968 --> 09:10:05.432
当你用硬盘命令运行脚本时，我们会尝试重新运行它，Hardhead会自动为你重新编译它，特别是在没有artifacts文件夹的情况下。

5391
09:10:05.432 --> 09:10:12.391
我们会重新运行这个命令和心跳，它会先编译我们可以看到它确实这样做了。

5392
09:10:12.391 --> 09:10:15.203
然后它将继续进行重新部署。

5393
09:10:15.329 --> 09:10:30.507
希望这一次，它应该能够找到刚刚编译的契约，这一次在我删除artifacts文件夹之后，我们实际上确实获得了一些成功的编译。

5394
09:10:30.507 --> 09:10:46.435
我们可以在这里看到成功提交的源代码，在区块探索中等待验证结果，成功验证的合同简单存储在以太扫描，甚至给了我们一个链接，我们可以继续和命令点击或控制点击进入。

5395
09:10:46.435 --> 09:10:49.837
我们可以看到合同确实得到了验证。

5396
09:10:49.837 --> 09:10:51.560
这太棒了。

5397
09:10:51.560 --> 09:10:53.283
这太完美了。

5398
09:10:53.283 --> 09:11:02.100
现在我们已经获得了一个成功的deploy。j脚本，它可以部署、验证并与代码交互。

5399
09:11:02.100 --> 09:11:03.280
这太棒了。

5400
09:11:03.280 --> 09:11:05.123
这个安全帽看起来很酷。

5401
09:11:05.123 --> 09:11:08.265
我们还能像我之前展示的那样用安全帽做什么。

5402
09:11:08.265 --> 09:11:10.845
安全帽附带了这些任务。

5403
09:11:10.845 --> 09:11:18.472
Hardhead的任务数量可以通过我们编写插件来扩展，我们实际上可以在hardhat中编写我们自己的任务。

5404
09:11:18.472 --> 09:11:38.176
在我们的Hardhead。config中，它可以默认这个任务帐户，我们可以看到任务帐户，打印帐户列表，只打印帐户列表在这里实际上去心脏有文档了解更多关于创建我们自己的任务，你可以定义任务的方法之一是直接在我们的心脏。

5405
09:11:38.176 --> 09:11:38.637
配置。

5406
09:11:38.637 --> 09:11:38.790
js。

5407
09:11:38.790 --> 09:11:45.652
但通常情况下，人们会有一个叫做任务的新文件夹，他们把所有的任务都放在那里。

5408
09:11:45.652 --> 09:11:48.444
现在，我要把这部分删掉。

5409
09:11:48.444 --> 09:11:49.930
我们要创建我们自己的任务。

5410
09:11:49.930 --> 09:12:00.784
您会注意到，现在我们已经删除了该部分，如果我们运行yarn RDAP，我们将不再在这里看到accounts任务，因为我们已经删除了该任务。

5411
09:12:00.784 --> 09:12:03.969
让我们创建自己的新任务。

5412
09:12:03.969 --> 09:12:07.296
我们称它为街区号。

5413
09:12:07.296 --> 09:12:07.525
js。

5414
09:12:07.525 --> 09:12:12.524
我们会用这个来得到当前的块号或者我们正在处理的区块链。

5415
09:12:12.524 --> 09:12:14.201
让我们创建这个任务。

5416
09:12:14.331 --> 09:12:22.823
首先，我们需要导入任务函数，我们可以通过输入const task = require arhat / config来获得它。

5417
09:12:22.823 --> 09:12:26.759
hard hat斜杠配置具有任务功能。

5418
09:12:26.759 --> 09:12:36.231
要定义一个任务，我们现在可以说任务，给它一个名字和一个描述，这个名字将是block number。

5419
09:12:36.331 --> 09:12:41.314
然后描述会打印出当前的块号。

5420
09:12:41.314 --> 09:12:52.882
现在我们有了这个任务，我们可以对它做一些事情，我们可以通过使用。add命令向它添加不同的参数，它允许我们向任务传递参数。

5421
09:12:52.882 --> 09:13:01.314
然后我们还可以设置动作来定义任务应该为我们做什么，我们只需要做点设置动作。

5422
09:13:01.314 --> 09:13:04.664
然后定义我们想要这个函数做什么。

5423
09:13:04.664 --> 09:13:16.594
我们将使它成为一个async函数，它将接受一个输入，任务参数，它将为空，还有HR E，我马上会定义它。

5424
09:13:16.594 --> 09:13:19.706
现在，让我快速解释一下语法。

5425
09:13:19.706 --> 09:13:25.246
这看起来可能有点奇怪，但这就是所谓的JavaScript箭头函数。

5426
09:13:25.246 --> 09:13:30.158
在JavaScript中，实际上可以定义函数，甚至不需要使用function关键字。

5427
09:13:30.158 --> 09:13:37.238
例如，如果我们回到deploy函数，我们有async函数verify在这里。

5428
09:13:37.331 --> 09:13:58.332
然而，我们也可以用另一种方式来定义它就是完全不使用函数词，实际上把这整个东西变成一个变量，我们可以说，我们可以说const verify将是一个async函数它接受契约地址和实参。

5429
09:13:58.332 --> 09:14:01.428
这是函数的定义。

5430
09:14:01.428 --> 09:14:04.009
这两条线本质上是等价的。

5431
09:14:04.009 --> 09:14:10.776
使用function关键字和将函数作为变量之间有一些细微的区别。

5432
09:14:10.776 --> 09:14:14.457
但对于这门课来说，它们基本上是一样的。

5433
09:14:14.457 --> 09:14:19.935
这意味着，它本身是一个函数，只是没有赋值给变量。

5434
09:14:19.935 --> 09:14:23.019
但本质上，这两个是完全一样的。

5435
09:14:23.019 --> 09:14:25.174
这就是我们在这里做的语法。

5436
09:14:25.174 --> 09:14:37.647
你可以想象这有点像const block task = async function，它接受params，然后运行那个箭头函数。

5437
09:14:37.647 --> 09:14:40.204
或者你可以认为它是异步的。

5438
09:14:40.204 --> 09:14:48.998
函数，块任务参数，然后函数定义，这些本质上都是一样的。

5439
09:14:48.998 --> 09:14:55.849
主要的区别是我们没有给函数命名，我们没有给它这个block task变量。

5440
09:14:55.849 --> 09:15:00.251
这在JavaScript中称为匿名函数，因为它没有名称。

5441
09:15:00.251 --> 09:15:05.610
现在我们在这里有了函数，我们现在可以调用一些函数来获得块号。

5442
09:15:05.610 --> 09:15:18.253
我们如何在运行任务时获得块号呢，我们自动传递匿名函数，任务参数，在这里，我们没有，但我们也传递这个hrii对象。

5443
09:15:18.332 --> 09:15:22.211
这个HRV是核心运行时环境。

5444
09:15:23.332 --> 09:15:28.264
部署脚本，这和这里的要求基本相同。

5445
09:15:28.264 --> 09:15:38.078
所以这个HRV可以访问很多相同的东西，这个HRV可以访问很多和硬帽包一样的包。

5446
09:15:38.078 --> 09:15:43.434
所以我们可以用Hae点醚，就像从hard hat导入醚一样。

5447
09:15:43.434 --> 09:15:50.833
在我们的ethers包中，我们可以使用很多函数比如。Pro, biter。get block number。

5448
09:15:50.833 --> 09:16:02.087
我们把这个保存到一个变量const blocked number =中，这将是一个同步的，所以我们要在这里添加一个权重。

5449
09:16:02.087 --> 09:16:05.953
然后我们写console。log block number。

5450
09:16:05.953 --> 09:16:13.047
或者更好的是，我们将字符串插值这个，并像这样说当前块号。

5451
09:16:13.047 --> 09:16:22.252
现在，如果我试着运行这个任务，你会注意到它没有出现在任务的核心Atlas中，让我们来做yarn。

5452
09:16:22.333 --> 09:16:22.792
艺术的应用。

5453
09:16:22.792 --> 09:16:25.283
我没看到这里的街区号。

5454
09:16:26.333 --> 09:16:39.146
因为我们需要将它添加到我们的config。config将添加require。

5455
09:16:39.333 --> 09:16:46.761
为了导入它，我们添加一个导出模块我稍后会解释它是做什么的。

5456
09:16:46.761 --> 09:16:53.365
但现在我们已经要求它，如果我运行纱线硬帽，现在看到阻塞是我可以使用的任务之一。

5457
09:16:53.365 --> 09:16:59.618
现在对于一根纱线，艺术帽块数，我们得到当前块数为零。

5458
09:16:59.618 --> 09:17:07.942
这是有意义的因为这是我们的硬帽网络的默认值，每次运行它都会重置。

5459
09:17:07.942 --> 09:17:18.000
但如果我跑纱线，硬帽区A号破折号网络瑞克比，你觉得我会得到什么?同样，一个更大的数字，当前的区块编号在这里。

5460
09:17:18.000 --> 09:17:33.734
因为这是Rigby的实际区块数而我们的心脏广告网络的区块数将为零因为它每次都会重置，我们运行其中一个脚本现在脚本和任务基本上可以做相同的事情。

5461
09:17:33.734 --> 09:17:39.885
它们都可以与合约交互，它们都可以部署智能合约，它们几乎都可以做任何事情。

5462
09:17:39.885 --> 09:17:47.684
作为一般的经验法则，我更喜欢脚本，因为我并不总是认为从命令行添加特殊的东西是有意义的。

5463
09:17:47.684 --> 09:17:51.587
所以我更喜欢脚本，但你也会看到大量的任务和例子。

5464
09:17:51.587 --> 09:17:54.952
我认为任务对于特定的用例来说非常好。

5465
09:17:54.952 --> 09:18:01.944
但在大多数情况下，我们基本上只使用脚本，但最好了解任务是什么样子的以及如何使用它。

5466
09:18:01.944 --> 09:18:07.940
我认为任务更适合于插件，脚本更适合于您自己的本地开发环境。

5467
09:18:07.940 --> 09:18:13.934
但如果你想做任何事都有任务，你完全可以做到。

5468
09:18:13.934 --> 09:18:18.268
正如您开始看到的，这个配置块非常强大。

5469
09:18:18.334 --> 09:18:24.350
我们可以用它来修改我们的整个代码库和我们的整个项目，给我们的项目更多的功能。

5470
09:18:24.350 --> 09:18:35.798
它还能做什么?现在，正如你所看到的，每次我们使用一个硬帽网络，每次我们运行一个脚本，我们运行那个脚本，然后硬帽网络就被删除了，对吧?我们不能再和合同互动了。

5471
09:18:35.798 --> 09:18:39.318
其实我们有办法运作一个安全帽网络。

5472
09:18:39.318 --> 09:18:43.301
类似于我们运行带有用户界面的ganache网络。

5473
09:18:43.301 --> 09:18:48.398
我们能做的是在硬帽运行纱线，RT帽节点。

5474
09:18:48.398 --> 09:18:57.548
它会在本地网络上旋转一个节点，和ganache完全一样，只是在我们的终端上。

5475
09:18:57.548 --> 09:19:00.966
这里启动了HTTP和WebSocket。

5476
09:19:00.966 --> 09:19:03.211
JSON此地址的RPC服务器。

5477
09:19:03.211 --> 09:19:10.033
就像nosh一样，它包含了各种不同的帐户和私钥，这太棒了。

5478
09:19:10.033 --> 09:19:24.811
你会注意到，有趣的是，我们运行的这个节点不在硬帽网络上，我们可以创建一个新终端尝试与它交互，只需要点击这个小加号按钮，创建一个新终端。

5479
09:19:24.811 --> 09:19:30.949
同样，我使用bash，但基于您的操作系统，您可以使用不同的shell。

5480
09:19:30.949 --> 09:19:39.236
在这里，让我们继续运行yarn arhat运行脚本，部署。j s，看看会发生什么。

5481
09:19:39.335 --> 09:19:44.801
我们的典型设置发生了，我们部署一个契约，我们得到一个契约地址，我们更新值。

5482
09:19:44.801 --> 09:19:51.268
但如果我们看一下我们的节点，它看起来没有任何事务经过这里我们没有看到任何锁定。

5483
09:19:51.268 --> 09:19:59.690
这是怎么回事?我们的硬帽网络和这个本地运行的网络是不同的。

5484
09:19:59.690 --> 09:20:03.980
这个本地运行的网络通常被称为本地主机。

5485
09:20:03.980 --> 09:20:06.506
所以它和硬帽网络有点不同。

5486
09:20:06.506 --> 09:20:11.285
它仍然使用硬帽运行时环境，但不是默认的硬帽网络。

5487
09:20:11.335 --> 09:20:17.112
当我们运行一个节点时它被认为是独立的网络。

5488
09:20:17.112 --> 09:20:19.207
超过脚本持续时间的。

5489
09:20:19.335 --> 09:20:24.109
所以我们可以通过在硬机头上添加一个新网络来与它进行交互。

5490
09:20:24.109 --> 09:20:24.496
配置。

5491
09:20:24.496 --> 09:20:30.062
Js，我们将创建一个新网络并称之为local host。

5492
09:20:30.335 --> 09:20:36.198
和上面一样，我们给它一个URL账户和一个chain ID。

5493
09:20:36.198 --> 09:20:43.522
对于URL，我们可以从终端获得那个URL，我会放一个运行的yarn硬帽节点。

5494
09:20:43.522 --> 09:20:50.860
通过复制粘贴到这里，我们可以加一个逗号，我们会给它一个链ID 31337。

5495
09:20:50.860 --> 09:20:58.488
因为即使它被认为是不同的网络，它实际上和安全帽有相同的链ID。

5496
09:20:58.488 --> 09:21:03.887
有趣的是，我知道我刚刚说过我们要给它账户，但实际上我们不需要给它账户。

5497
09:21:03.887 --> 09:21:10.836
因为当我们运行这个localhost硬帽时它会自动给我们这10个假账户。

5498
09:21:10.836 --> 09:21:18.926
你可以把这个localhost的账户想成，已经把它们放在了，谢谢，硬帽子。

5499
09:21:18.926 --> 09:21:23.271
但现在，如果我们回到这里，让我们清空终端。

5500
09:21:23.336 --> 09:21:25.169
让我们重新运行脚本。

5501
09:21:28.336 --> 09:21:28.669
宿主

5502
09:21:28.669 --> 09:21:31.919
现在我们应该指向这个节点。

5503
09:21:33.336 --> 09:21:38.936
在这个脚本中，我们应该在这个节点的末尾看到一些日志输出。

5504
09:21:38.936 --> 09:21:41.069
按下回车键。

5505
09:21:41.069 --> 09:21:48.499
我们在部署脚本上看到正常的东西，我们翻回节点哇，我们在这里看到大量的日志记录。

5506
09:21:48.499 --> 09:22:01.129
与ganache类似，我们可以看到一大堆关于刚刚发生的事情的不同日志，我们可以看到一个合同被部署，我们可以看到地址，来自值的事务哈希，gas和块号等等。

5507
09:22:01.129 --> 09:22:08.736
我们还可以看到契约调用调用store函数来更新收藏号的值。

5508
09:22:08.736 --> 09:22:19.727
这对于在本地JavaScript VM或硬帽网络上快速测试和处理事物来说是非常强大的，能够看到您的契约如何在真实的测试网络上交互。

5509
09:22:19.727 --> 09:22:23.167
这比使用真正的测试网要快得多。

5510
09:22:23.167 --> 09:22:30.337
另外，和我们之前说的一样，任何在终端上运行的进程，我们可以用Ctrl C终止它。

5511
09:22:30.337 --> 09:22:36.067
因此，如果您想停止节点然后重新启动它，可以按Ctrl键。

5512
09:22:36.067 --> 09:22:42.949
C来停止它，然后再运行同样的命令来重新旋转你的节点Ctrl C停止它。

5513
09:22:42.949 --> 09:22:45.207
然后你就可以重新开始了。

5514
09:22:45.337 --> 09:22:53.227
另一种阻止它的方法，当然，是如果你点击垃圾桶，它会删除整个终端，我们把一个终端拉回来，我们可以再次运行它。

5515
09:22:53.227 --> 09:22:58.898
记住，如果你点击X，它不会删除终端，只是隐藏了它。

5516
09:22:58.898 --> 09:23:02.983
我们的硬帽节点现在还在运行因为我刚刚点击了它。

5517
09:23:02.983 --> 09:23:05.320
所以我把它拉上来，我可以看到它确实还在运行。

5518
09:23:05.320 --> 09:23:10.014
但如果我删除candidate，然后它把终端拉回来，我可以看到它不再运行了。

5519
09:23:10.014 --> 09:23:12.723
所以运行脚本非常好。

5520
09:23:12.723 --> 09:23:25.687
但是，如果我不想编写整个脚本来做一些事情呢?如果我只是想修补区块链呢?嗯，硬帽子里装着一个叫控制台的东西。

5521
09:23:25.687 --> 09:23:27.583
控制台是一个JavaScript环境。

5522
09:23:27.583 --> 09:23:41.527
为了运行JavaScript命令与任何区块链交互，我们可以通过运行yarn、hardhat、console跳转到控制台，然后如果我们想在溜冰场B、主网多边形、雪崩等上工作，可以运行任何网络标志。

5523
09:23:41.527 --> 09:23:43.495
这就是网络本地主机。

5524
09:23:43.495 --> 09:23:49.998
现在我们被放到了shell中在shell中，我们可以做所有在部署脚本中做的事情。

5525
09:23:49.998 --> 09:23:56.123
我们甚至不需要运行这些导入，因为所有带有硬帽的内容都会自动导入到我们的控制台。

5526
09:23:56.123 --> 09:24:00.814
举个例子，假设我想要一个简单的仓储合同工厂。

5527
09:24:00.814 --> 09:24:03.238
我可以画出这条直线。

5528
09:24:03.238 --> 09:24:16.202
我可以说const，简单存储，工厂等于等待醚。get合同工厂，有简单存储。

5529
09:24:16.338 --> 09:24:18.385
现在我可以部署这个了。

5530
09:24:19.338 --> 09:24:21.588
复制这一行，粘贴它。

5531
09:24:25.338 --> 09:24:27.872
我们刚刚部署了另一个简单的存储器。

5532
09:24:28.338 --> 09:24:35.671
我们可以做等待简单的存储。检索。

5533
09:24:36.338 --> 09:24:40.250
我得到的返回值将是一个值为0的大数字。

5534
09:24:40.250 --> 09:24:46.751
我还可以进行事务处理，这样我就可以做一个权重，简单的存储。

5535
09:24:46.751 --> 09:24:55.284
那个store让我们做55如果我点击两次，我可以回到简单的storage。retrieve。

5536
09:24:55.338 --> 09:24:59.276
调用这个函数，可以看到大数的值是55。

5537
09:24:59.338 --> 09:25:02.450
现在，这是一个很好的方法来快速与任何我们想要的区块链交互。

5538
09:25:02.450 --> 09:25:06.134
现在，您可以通过按Ctrl C两次退出shell。

5539
09:25:06.134 --> 09:25:11.285
或者你也可以你也可以垃圾箱你的终端，如果你感到困惑。

5540
09:25:11.285 --> 09:25:19.588
这个主机可以与任何网络，我们甚至可以做纱，硬帽主机破折号网络硬帽。

5541
09:25:19.588 --> 09:25:23.181
我们会被丢进一个安全帽网络。

5542
09:25:23.338 --> 09:25:30.948
这里运行的节点和这里不同，这里只在命令执行期间运行。

5543
09:25:30.948 --> 09:25:34.989
所以当我们取消这个命令时，这个硬帽网络就被取消了。

5544
09:25:34.989 --> 09:25:36.449
把这个也关了。

5545
09:25:36.449 --> 09:25:47.767
我们也可以做纱线，硬帽，控制台，破折号网络Rinkeby Rigby，或多边形或测试网或主网或任何我们想要的。

5546
09:25:47.767 --> 09:26:00.339
我们可以做ethers。provider这样的事情也可以做await ethers。provider。get block number，查看Rigby的block number。

5547
09:26:00.339 --> 09:26:11.787
我们还可以部署合同，更新合同，我们可以做任何我们想做的事情，你可以在这些控制台中做任何事情，它们是快速测试和修补与合同交互的好方法。

5548
09:26:11.787 --> 09:26:17.102
还有一些其他的任务真的很有帮助。

5549
09:26:17.102 --> 09:26:21.699
您将看到，在我删除工件和手动删除缓存之前。

5550
09:26:21.699 --> 09:26:27.855
好吧，要自己做，你也可以只运行纱线硬头，清洁。

5551
09:26:27.855 --> 09:26:31.289
这样就会删除藏物文件夹清空你的缓存。

5552
09:26:31.339 --> 09:26:33.097
我们已经知道编译是做什么的。

5553
09:26:34.339 --> 09:26:38.205
Hardhead最擅长的就是运行测试。

5554
09:26:38.205 --> 09:26:40.605
目前我们还没有进行测试。

5555
09:26:40.605 --> 09:26:46.258
然而，运行测试对于智能合约的开发过程绝对是至关重要的。

5556
09:26:46.258 --> 09:26:50.109
将来我们会花很多时间来写真正好的测试。

5557
09:26:50.109 --> 09:27:07.799
编写测试如此重要的原因是，我们想要确保我们的代码完全做我们想要它做的事情，特别是在挑战和去中心化的智能合约世界中，我们所有的代码都将是开源的，任何人都可以与之交互，并可能利用。

5558
09:27:07.799 --> 09:27:18.258
还有像req。news这样的网站，它们经历了大量之前的黑客攻击，以及它们是如何被黑客攻击的，以及智能合约中发生了什么使得这些黑客攻击得以发生。

5559
09:27:18.258 --> 09:27:24.427
所以测试，编写真正强大的测试总是我们的第一道防线。

5560
09:27:24.427 --> 09:27:26.114
我们有这个样本测试。

5561
09:27:26.114 --> 09:27:28.840
Js，它在hardhat的基本包中默认自带。

5562
09:27:28.840 --> 09:27:32.611
但你可能已经知道了，我们要重命名并改变它。

5563
09:27:32.611 --> 09:27:35.923
我们将重命名这个为test deploy。js。

5564
09:27:35.923 --> 09:27:41.081
我们要把这里所有的东西都删掉，重新开始。

5565
09:27:41.081 --> 09:27:46.710
我们希望能够在本地测试所有的稳定性代码，这样我们就能确切地知道它在做什么。

5566
09:27:46.710 --> 09:27:52.840
我们可以用一种程序化的方式来确保我们的代码做我们想要它做的事情。

5567
09:27:52.840 --> 09:27:56.740
因此，让我们为简单的存储契约编写一个基本测试。

5568
09:27:56.740 --> 09:28:01.684
这样我们就能确定它在做我们想要它做的事。

5569
09:28:01.684 --> 09:28:19.076
Hard Hat测试与Mocha框架一起工作，这是一个基于JavaScript的框架，用于运行我们的测试，你实际上可以直接在实体中编写测试，如果你愿意的话，关于纯实体测试更好还是用现代编程语言测试更好，有一点反复。

5570
09:28:19.076 --> 09:28:28.029
有观点认为，使用现代编程语言进行测试，可以更灵活地进行更多交互和测试智能合约的工作。

5571
09:28:28.029 --> 09:28:32.768
但是用我们进行测试的理由是我们想要尽可能接近代码。

5572
09:28:32.768 --> 09:28:40.043
在记录的时候，大多数项目使用现代编程语言(如JavaScript)进行绝大部分的测试。

5573
09:28:40.043 --> 09:28:42.105
这就是我们要用到的。

5574
09:28:42.105 --> 09:28:47.698
为了开始我们的摩卡测试，我们要写一个描述函数。

5575
09:28:47.698 --> 09:28:59.550
description是一个摩卡能识别的关键字，它有两个参数，一个字符串，我们现在只写简单存储。

5576
09:28:59.550 --> 09:29:12.091
然后也取一个函数，我们可以创建函数，测试func然后在这里写一些东西，然后把它传递给我们这里的描述。

5577
09:29:12.091 --> 09:29:24.912
但通常的做法是让它成为一个匿名函数，我们可以通过输入function来创建，在这里输入一个空形参，然后是这样的括号。

5578
09:29:24.912 --> 09:29:29.270
我们的describe函数接受一个名称，一个字符串和一个函数。

5579
09:29:29.341 --> 09:29:34.781
另一种经常在description中看到函数的方式是使用匿名函数语法。

5580
09:29:34.781 --> 09:29:44.864
你可能会看到这些括号，一个箭头，还有一些括号，这两个基本上是一样的，有一些不同。

5581
09:29:44.864 --> 09:29:51.716
第二个实际上是最佳实践，但你要知道，你可能在其他测试中也会看到这个箭头语法。

5582
09:29:51.716 --> 09:29:56.308
我们已经描述了一个样本存储和这里的函数，它将包含我们所有的测试。

5583
09:29:56.341 --> 09:29:58.376
在每个描述块中。

5584
09:29:59.341 --> 09:30:07.472
一个叫做a在每个函数之前，还有一堆It's Our在每个函数之前会告诉我们在每次命中之前要做什么。

5585
09:30:07.472 --> 09:30:10.695
所以我们会有大量的它然后在每一个之前都有a。

5586
09:30:10.695 --> 09:30:14.919
所有id都将是我们实际编写运行测试代码的地方。

5587
09:30:14.919 --> 09:30:36.075
在每一个都有一些代码告诉我们在每一个命中之前要做什么之前，我们还可以有描述，在描述的内部，在每一个都有更多之前有这些嵌套的描述对分离和模块化测试非常有帮助。

5588
09:30:36.075 --> 09:30:40.761
但是对于这一个，我们将有一个像这样的设置。

5589
09:30:40.761 --> 09:30:44.008
在这个演示中，我们只会有一个。

5590
09:30:44.008 --> 09:30:50.148
因此，在实际运行测试之前，为了测试我们的智能合约，我们可能需要首先部署智能合约。

5591
09:30:50.148 --> 09:30:57.859
在我们的before each内部，我们会传递一个函数给我们的before each，它会告诉我们的测试框架在每个测试之前做什么。

5592
09:30:57.859 --> 09:31:01.817
我们会像这样传递一个async函数给它。

5593
09:31:01.817 --> 09:31:06.103
在这里，我们希望部署简单的存储契约。

5594
09:31:06.103 --> 09:31:12.748
要做到这一点，我们需要获取ethers框架并执行我们在部署脚本中所做的操作。

5595
09:31:12.748 --> 09:31:16.205
在这里，我们在顶部我们会说const。

5596
09:31:16.342 --> 09:31:23.230
以太，等于要求艺术从安全帽进口以太。

5597
09:31:23.342 --> 09:31:34.942
然后在我们的每个函数之前，我们会说等待醚点获得简单存储的合同工厂。

5598
09:31:34.942 --> 09:31:39.630
我们会把这个赋值给const。

5599
09:31:39.630 --> 09:31:43.138
简单存储工厂。

5600
09:31:43.138 --> 09:31:50.178
然后我们会逃跑，简单的存储工厂。部署。

5601
09:31:50.178 --> 09:31:50.669
酷。

5602
09:31:50.669 --> 09:31:56.042
让我们把它赋给一个简单的可变成本。

5603
09:31:56.042 --> 09:32:10.306
现在，因为现在，我们的简单存储和简单存储工厂的作用域只是在每个之前的内部，我们实际上需要把这些变量粘在每个之前的外部，所以我们所有的事件都可以与它们交互。

5604
09:32:10.306 --> 09:32:20.277
与其让简单存储，工厂，和简单存储，成为常量变量，我们将在它们之外定义它们用let关键字。

5605
09:32:20.343 --> 09:32:27.205
然后我们说让简单存储工厂然后我们把它初始化为零。

5606
09:32:27.205 --> 09:32:29.739
然后我们会说led简易存储器。

5607
09:32:29.739 --> 09:32:40.390
现在，如果你有一大堆。我们用另一种方式初始化，你可以用JavaScript写它们，让简单存储工厂逗号，简单存储。

5608
09:32:40.390 --> 09:32:42.064
这是完全一样的。

5609
09:32:42.064 --> 09:32:43.817
然后我们可以去掉这个const关键字。

5610
09:32:43.817 --> 09:32:47.454
因为它不是常数，因为我们分配了它。

5611
09:32:47.454 --> 09:32:52.936
现在我们有了简单的存储，工厂和简单的存储我们可以在init函数中使用。

5612
09:32:52.936 --> 09:32:54.643
现在我们在每个部分之前都有一个。

5613
09:32:54.643 --> 09:32:57.898
因此，在每个测试之前，我们将部署简单的存储契约。

5614
09:32:57.898 --> 09:33:02.278
因此，我们有一个全新的合同来与我们的每一个测试进行交互。

5615
09:33:02.343 --> 09:33:11.549
在ID内部，这是我们想要这个特定测试做什么的地方，然后描述实际做那个的代码。

5616
09:33:11.549 --> 09:33:18.815
所以我们说它应该从一个最喜欢的数字0开始。

5617
09:33:18.815 --> 09:33:22.280
这说明了这个测试应该做什么。

5618
09:33:22.280 --> 09:33:26.861
然后我们会添加async函数来做这个。

5619
09:33:26.861 --> 09:33:29.129
我们说async function。

5620
09:33:29.129 --> 09:33:38.268
在这里，我们会写代码来确保合约能做到这一点。

5621
09:33:38.343 --> 09:33:40.247
我们说const。

5622
09:33:40.247 --> 09:33:45.834
当前值，等于等待，简单存储。

5623
09:33:46.343 --> 09:33:46.859
检索。

5624
09:33:50.343 --> 09:33:53.246
看看当前值是否为零。

5625
09:33:54.343 --> 09:33:59.666
了吗?我们可以说const，期望值等于0。

5626
09:33:59.666 --> 09:34:12.077
我们能做的是我们能使用断言关键字，或期望关键字，我们会从一个叫Chai的包导入这两个。

5627
09:34:12.077 --> 09:34:20.171
我们实际上是在下载基本参数时自动安装Chai的。

5628
09:34:20.171 --> 09:34:22.722
在顶部，我们会说const。

5629
09:34:22.722 --> 09:34:33.616
Chai，我非常喜欢尽可能多地使用断言，因为我认为这样的语法更有意义。

5630
09:34:33.616 --> 09:34:37.055
但是在某些情况下，我们需要使用expect来代替。

5631
09:34:37.055 --> 09:34:43.281
断言有很多内建的函数帮助我们确保这是我们期望的结果。

5632
09:34:43.344 --> 09:34:46.786
我可以断言。等于当前值。

5633
09:34:48.344 --> 09:34:52.277
记住，这是一个很大的数，逗号，期望值。

5634
09:34:52.277 --> 09:34:58.810
我断言这个检索将返回0，这将是我们的期望值。

5635
09:34:58.810 --> 09:35:03.934
现在要运行这个，我们要运行纱线，艺术帽测试。

5636
09:35:03.934 --> 09:35:09.950
我们看到我们得到了一个像这样的输出应该以最喜欢的数字0开始，它确实通过了。

5637
09:35:09.950 --> 09:35:22.312
你会注意到，如果我把这个改成1，这是不对的，它会崩溃它会说art Pass或不传递断言错误期望0等于1。

5638
09:35:22.312 --> 09:35:27.671
它期望0等于1，这不是我们想要的。

5639
09:35:27.671 --> 09:35:30.021
我们想让0等于0。

5640
09:35:30.021 --> 09:35:31.648
让我们再运行一遍。

5641
09:35:31.648 --> 09:35:35.183
多达应该从最喜欢的数字零开始，它已经过去了。

5642
09:35:35.183 --> 09:35:36.102
好的,太棒了。

5643
09:35:36.102 --> 09:35:42.183
这就是我们写一个测试的方法，让我们再写一个测试，以确保一切正常。

5644
09:35:42.183 --> 09:35:50.583
当我们调用store函数时，它应该更新，因为当我们调用store函数时，我们希望收藏号更新。

5645
09:35:50.583 --> 09:35:53.688
我们也会让它成为一个async函数。

5646
09:35:53.688 --> 09:35:56.188
把我们的东西加进去。

5647
09:35:56.345 --> 09:35:58.011
所以我们用const。

5648
09:36:01.345 --> 09:36:05.000
当我们调用store时，它会更新到7。

5649
09:36:05.345 --> 09:36:07.000
我们可以说const。

5650
09:36:11.345 --> 09:36:12.761
存储点存储。

5651
09:36:16.345 --> 09:36:17.126
值。

5652
09:36:21.345 --> 09:36:22.046
重量。

5653
09:36:22.046 --> 09:36:24.291
现在让我们得到当前值。

5654
09:36:25.345 --> 09:36:26.031
const。

5655
09:36:32.345 --> 09:36:33.046
检索。

5656
09:36:37.345 --> 09:36:37.918
价值。

5657
09:36:37.918 --> 09:36:41.475
到字符串，逗号期望的值。

5658
09:36:44.345 --> 09:36:46.395
这些试验通过跑纱硬头试验进行。

5659
09:36:47.345 --> 09:36:48.782
这两个测试都做了

5660
09:36:51.345 --> 09:36:59.657
只骗了一个测试，我实际上可以运行一个测试通过运行yarn, art app，测试，dash dash grep。

5661
09:36:59.657 --> 09:37:04.570
我可以在这里的任何文本中搜索任何关键词。

5662
09:37:04.570 --> 09:37:07.741
我要用grep来表示store函数。

5663
09:37:07.741 --> 09:37:13.583
因为store关键字不在这个tax中，它只在这个的文本中。

5664
09:37:13.583 --> 09:37:23.488
如果我使用grep store，它应该只运行我们的第二个测试，确实如此，我们可以只运行特定测试的另一种方法是使用only关键字。

5665
09:37:23.488 --> 09:37:27.011
我们可以这样输入。only。

5666
09:37:27.011 --> 09:37:30.409
然后我们可以运行纱线，艺术帽测试。

5667
09:37:30.409 --> 09:37:34.596
它应该只运行，这应该在调用store时更新。

5668
09:37:34.596 --> 09:37:40.613
确实是这样，然后我们删除这个保存，再运行，它也会运行。

5669
09:37:40.613 --> 09:37:41.505
太棒了。

5670
09:37:41.505 --> 09:37:49.749
现在，您将看到编写这些测试的另一种方式是使用expect关键字而不是assert。

5671
09:37:49.749 --> 09:37:52.919
所以你会看到期望的现值。

5672
09:37:52.919 --> 09:37:53.951
字符串。

5673
09:37:53.951 --> 09:38:01.346
点乘等于期望值，这两条线做完全相同的事情。

5674
09:38:01.346 --> 09:38:04.536
这取决于你想用哪一个。

5675
09:38:04.536 --> 09:38:07.524
这就是我们要做的所有测试。

5676
09:38:07.524 --> 09:38:07.952
现在。

5677
09:38:07.952 --> 09:38:11.059
这是一份很棒的工作。

5678
09:38:11.059 --> 09:38:18.821
现在我们有了一些测试，我们可以开始测试，看看每个功能实际消耗多少气体。

5679
09:38:18.821 --> 09:38:23.853
安全帽最流行的扩展之一是安全帽气体记者。

5680
09:38:23.853 --> 09:38:33.958
这是一个附加到我们所有测试的扩展，自动给我们一个像这样的输出，它告诉我们每个功能大约消耗多少气体。

5681
09:38:33.958 --> 09:38:41.853
我们向下滚动到这里，我们可以阅读如何安装npm安装Hardhead气体报告器的说明，我们将用它来安装纱线。

5682
09:38:41.853 --> 09:38:52.012
所以我们选纱线，加上安全帽，气体记者，冲刺戴夫。

5683
09:38:52.346 --> 09:39:01.918
现在这个包已经安装好了，我们可以进入我们的配置，在这里添加一些参数，这样我们就可以使用这个瓦斯坑了。

5684
09:39:01.918 --> 09:39:07.855
但是在以太扫描部分下面，我们要添加一个叫做gas reporter的新部分。

5685
09:39:07.855 --> 09:39:13.003
要让它运行，无论何时我们运行测试我们都会启用它都是true。

5686
09:39:13.003 --> 09:39:20.013
然后在最上面，我们可以添加它通过添加require hardhat gas reporter。

5687
09:39:20.013 --> 09:39:30.313
现在我们有了它，我们可以做纱线硬帽测试，在我们运行测试后，它会自动运行这个气体报告器。

5688
09:39:30.313 --> 09:39:32.966
所以我们看到我们的测试继续运行。

5689
09:39:32.966 --> 09:39:40.001
然后我们得到这样的输出它告诉我们契约和方法的成本是多少。

5690
09:39:40.001 --> 09:39:47.177
我们的存储函数大概消耗这么多汽油简单的存储大概消耗这么多汽油。

5691
09:39:47.177 --> 09:39:52.902
这对于弄清如何尽可能优化我们的气体非常有帮助。

5692
09:39:52.902 --> 09:39:55.560
现在我通常喜欢更进一步。

5693
09:39:55.560 --> 09:40:00.153
有这样的气体输出是很好的，但我们可以让它更好。

5694
09:40:00.153 --> 09:40:04.281
我喜欢通过输出文件把它输出到一个文件。

5695
09:40:04.281 --> 09:40:18.008
是的，report。txt然后我的。get ignore把它加到这里，但是做gas report。txt语句把gas report推到GitHub并不重要。

5696
09:40:18.008 --> 09:40:19.329
做没有颜色的事才是真。

5697
09:40:19.329 --> 09:40:26.019
我们添加这个的原因是，当我们输出到一个文件时，颜色基本上会变得混乱。

5698
09:40:26.019 --> 09:40:30.578
然后我们能做的最大的加法就是在这里加一种货币。

5699
09:40:30.578 --> 09:40:36.761
这样我们就可以得到像Aetherium这样的区块链每个功能的美元成本。

5700
09:40:36.761 --> 09:40:56.248
现在为了在这里得到货币，我们实际上需要从玉米市值中得到一个API密钥，就像我们在以太扫描中做的一样，你可以到硬币市值，玉米市值API，得到你的API密钥，然后我们就可以注册了。

5701
09:40:56.248 --> 09:40:59.248
选择一个基本的计划。

5702
09:40:59.248 --> 09:41:04.671
我们会同意并创建我的账户，我们会收到电子邮件验证。

5703
09:41:04.671 --> 09:41:06.905
我们来验证一下。

5704
09:41:06.905 --> 09:41:11.414
现在在硬币市值仪表盘上，我们可以复制密钥。

5705
09:41:11.414 --> 09:41:23.594
是的，你猜对了，我们要怎么处理这个键，我们要把它放到。env文件中，或者说，coin market cap, API key =然后像这样粘贴进去。

5706
09:41:23.594 --> 09:41:32.276
现在我们在这里有了玉米市值API键，我们可以返回我们的头点配置，并将其添加到玉米市值参数中。

5707
09:41:32.276 --> 09:41:48.648
我们和上面做的完全一样，我们用const，硬币，市值，API键= process。EMV，硬币市值，API键，然后我们把这个放在这里。

5708
09:41:48.648 --> 09:41:55.435
这实际上是对玉米市值进行API调用，每当我们运行气体报告时。

5709
09:41:55.435 --> 09:42:01.912
这就是为什么有时你会看到我把它注释掉，然后又取消注释，因为我不总是希望它进行这个API调用。

5710
09:42:01.912 --> 09:42:10.708
但现在我们能做的是现在它被启用了，我们有一个输出文件，我们可以看到货币，我们有API密钥，我们能做的就是运行yarn hardhat测试。

5711
09:42:10.708 --> 09:42:16.015
所有测试都通过后，我们会看到气体报告。

5712
09:42:16.015 --> 09:42:20.729
tx T，我们可以从它里面读取气体报告。

5713
09:42:20.729 --> 09:42:33.738
现在每笔交易都有了美元价格，看起来在当前的价格下，Aetherium是3000美元/人，天然气价格是43 Gwei，商店功能将花费6美元。

5714
09:42:33.738 --> 09:42:37.112
而简单的存储功能则需要64美元。

5715
09:42:37.112 --> 09:42:46.590
目前的Hardhead气体报告器实际上有一些不同的选择，尽管，如果你要部署到不同的网络，例如，与binance, Polygon, Avalanche或hecho。

5716
09:42:46.590 --> 09:43:00.693
例如，假设我们想要部署这个多边形，让我们看看在我们的WMV UHD广告令牌中部署这个多边形将花费多少钱，现在我们将重新运行这个测试。

5717
09:43:00.693 --> 09:43:09.806
如果我们看一下消耗T的汽油报告会看到polygon的汽油价格现在大约是37格雷/桶。

5718
09:43:09.806 --> 09:43:13.243
Matic的费用是自动147和美元。

5719
09:43:13.243 --> 09:43:18.494
现在我们可以看到调用简单存储方法的代价是0美元。

5720
09:43:18.494 --> 09:43:18.655
00.

5721
09:43:18.655 --> 09:43:33.296
这当然是四舍五入，但调用store会非常非常便宜而部署合约只需要3美分，我习惯为gas报告器选择false每当我不想使用gas时。

5722
09:43:33.349 --> 09:43:33.704
太棒了。

5723
09:43:36.349 --> 09:43:41.709
我们没有指定这些环境变量Hardhead可能会对我们有点不满。

5724
09:43:41.709 --> 09:43:44.411
通常我会在这里添加一些代码。

5725
09:43:44.411 --> 09:43:53.661
这些变量总是被填充，因为我们没有指定rink prpc URL, rringprpc URL将是未定义的。

5726
09:43:53.661 --> 09:43:56.036
这可能会造成一些错误。

5727
09:43:56.036 --> 09:44:14.725
通常，我们会在这里添加一个或参数，这些双管道的意思是或，在JavaScript中，如果我们说某个变量等于某物或某物，实际发生的是我们会说，rink, RPC URL将等于process。E和V。rink, RPC URL。

5728
09:44:14.725 --> 09:44:19.720
但如果这个rink, RPC URL不存在，它会是这里的其他东西。

5729
09:44:19.720 --> 09:44:23.914
我可能会写一些类似于HTTPS的东西。

5730
09:44:23.914 --> 09:44:30.178
举个例子，或者类似的例子，这样我就不会因为不使用B级而让安全帽抓狂。

5731
09:44:30.178 --> 09:44:33.604
我们可以对所有这些做类似的事情。

5732
09:44:33.604 --> 09:44:39.807
你会在很多代码设置中看到这种语法。

5733
09:44:39.807 --> 09:44:47.127
在进入This的TypeScript版本之前，我要展示的最后一件事是测试覆盖率。

5734
09:44:47.127 --> 09:44:55.492
随着课程的推进，我将向你们展示更多的工具，你们可以使用它们来确保我们的简单存储合同是安全的。

5735
09:44:55.492 --> 09:45:00.936
如果我们在现实生活中部署，我们会采取一切可能的措施来防止任何黑客攻击。

5736
09:45:00.936 --> 09:45:03.688
其中一个工具叫做固体覆盖率。

5737
09:45:03.688 --> 09:45:06.850
这也是一个我们可以在代码中使用的硬帽插件。

5738
09:45:06.850 --> 09:45:16.366
可靠性覆盖是一个经过所有测试并查看示例存储点Sol中实际覆盖了多少行代码的项目。

5739
09:45:16.366 --> 09:45:17.942
这是一个很好的提示。

5740
09:45:17.942 --> 09:45:24.462
如果我们不覆盖某一行代码，稳定性覆盖率就会说，嘿，你没有对这行代码进行任何测试，也许你应该为它编写一些测试。

5741
09:45:24.462 --> 09:45:28.242
我们可以用添加所有包的相同方式添加固体覆盖率。

5742
09:45:28.242 --> 09:45:36.269
npm安装破折号，保存Dev，或者因为我们使用的是纱线，纱线，添加破折号Dev，固体覆盖率。

5743
09:45:36.269 --> 09:45:47.919
然后我们可以把它添加到配置中，就像我们把所有东西都添加到配置中一样，进入我们的配置，我们会写requisolidity coverage。

5744
09:45:47.919 --> 09:45:56.421
我们可以在下面添加一些配置件，但我们只使用默认的现在我们可以做的是运行yarn, RT hat覆盖。

5745
09:45:56.421 --> 09:46:10.842
这将通过我们的测试并打印出一个像这样的文件，我们还会得到一个文件，叫做coverage。JSON，它基本上是这个图表的细分部分把coverage。JSON放到。get ignore中。

5746
09:46:10.842 --> 09:46:14.981
我知道我们还没见过。Git ignore，做它应该做的。

5747
09:46:14.981 --> 09:46:23.617
但是我们很快就会看到这里大约50%的代码simple storage。soul中50%的语句都被覆盖了。

5748
09:46:23.617 --> 09:46:41.951
大约三分之二的函数和50%的线，它甚至会告诉我们哪些线没有被测试，我们可以看到31和32简单的剑，大底没有被覆盖，这很有意义，因为31到32是添加人函数，我们没有调用，我们没有添加到我们的测试。

5749
09:46:41.951 --> 09:46:52.824
如果您想花点时间暂停一下，并通过编写更多的测试来实现100%的可靠性覆盖率，我强烈建议您这样做，这将是一个很好的学习练习。

5750
09:46:52.824 --> 09:46:54.661
我们还将添加coverage文件夹。

5751
09:46:54.661 --> 09:47:01.266
覆盖相邻和覆盖文件夹，我稍后会解释。get ignore文件夹的作用。

5752
09:47:01.266 --> 09:47:09.304
最后一件事，我们没有讲到这里是什么是nomic labs硬帽华夫饼。

5753
09:47:09.304 --> 09:47:13.629
我们谈论了爸爸和V心和以太扫描任务气体报告。

5754
09:47:13.629 --> 09:47:24.399
那么今天，这是什么?好吧，我们可以搜索这个并找出它到底是什么Hardhead华夫实际上是一个与华夫测试框架一起工作的插件。

5755
09:47:24.399 --> 09:47:32.574
华夫是其中一个框架它允许我们做一些非常高级的测试，我们很快就会使用一些看起来非常类似的语法。

5756
09:47:32.574 --> 09:47:36.775
随着我们的继续，我们会向你们展示更多的华夫饼工具。

5757
09:47:36.775 --> 09:47:43.188
好了，这一节的下一部分，我会讲一下它的TypeScript版本。

5758
09:47:43.188 --> 09:47:50.098
但无论如何，你已经成功创建了你的第一个Hardhead项目，你已经做了很多了不起的事情。

5759
09:47:50.098 --> 09:47:57.285
在这节课中，让我们快速复习一下到目前为止我们学过的内容，我们学习了如何启动我们自己的硬帽项目。

5760
09:47:57.352 --> 09:48:05.565
现在我们可以运行yarn, hardhat，并看到一个任务列表和不同的事情，我们可以用hardhat。

5761
09:48:05.565 --> 09:48:08.818
我们知道了安全帽会找这个安全帽。

5762
09:48:08.818 --> 09:48:09.218
配置。

5763
09:48:09.218 --> 09:48:09.351
js。

5764
09:48:09.351 --> 09:48:17.401
这是我们运行的任何任务的入口点从hard hat开始，我们知道我们可以把我们的合同添加到合同文件夹。

5765
09:48:17.401 --> 09:48:26.813
然后我们通过运行yarn来编译，art半编译，我们了解到所有的遵从都进入了工件，然后缓存也一样。

5766
09:48:26.813 --> 09:48:31.707
如果我们想要清除重置，我们可以删除这两个文件或者只运行yarn, hard hat clean。

5767
09:48:31.707 --> 09:48:38.860
因此我们了解到，我们可以使用脚本或任务来实际部署、交互和使用智能合约做事情。

5768
09:48:38.860 --> 09:48:42.194
我们还了解到，在本课程的其余部分中，我将使用脚本。

5769
09:48:42.194 --> 09:48:44.997
但如果你愿意，你也可以使用任务。

5770
09:48:44.997 --> 09:48:50.580
这个问题我已经问过无数次了有什么区别吗?似乎没有人真正知道它们的主要区别是什么。

5771
09:48:50.580 --> 09:48:53.319
但我认为主要的区别在于任务是为插件准备的。

5772
09:48:53.319 --> 09:49:12.210
脚本是为本地开发的，这是思维限制器，我们知道我们可以导入一大堆东西，包括从hardhat导入脚本的任务，我们可以使用async函数获取契约并部署它们，我们实际上可以通过编程验证它们使用hardhat和硬帽插件。

5773
09:49:12.210 --> 09:49:17.165
另外，我们还可以和我们和醚的相互作用非常相似。

5774
09:49:17.165 --> 09:49:19.203
我们编写了一个很棒的验证脚本。

5775
09:49:19.203 --> 09:49:24.014
我们也写了自己的任务，我们写了整个空间的第一个测试。

5776
09:49:24.014 --> 09:49:27.686
我们展示了我们的测试将会是什么样子。

5777
09:49:27.686 --> 09:49:30.066
我们讲了一点它们的重要性。

5778
09:49:30.066 --> 09:49:37.393
我真的应该强调写好测试将是真正的专业环境和业余项目的区别。

5779
09:49:37.393 --> 09:49:42.505
每当我审核智能合约时，或者每当我接到一个项目，有人让我看一看时。

5780
09:49:42.505 --> 09:49:45.788
当然，我首先看的是自述文件。

5781
09:49:45.788 --> 09:49:47.917
我看的第二件事是测试。

5782
09:49:47.917 --> 09:49:54.305
如果测试结果不好，我通常会告诉他们，嘿，你需要回到绘图板上，你需要升级你的测试。

5783
09:49:54.353 --> 09:50:00.708
所以测试真的非常非常重要，特别是在这个领域，我们学到了更多可以使用的环境变量。

5784
09:50:00.708 --> 09:50:05.892
我们学习了一些工具来了解我们的测试有多好，其中之一就是覆盖率。

5785
09:50:05.892 --> 09:50:12.089
我们还了解了一个气体报告器，以了解当我们实际部署到一个真实的网络时，它将花费多少。

5786
09:50:12.089 --> 09:50:26.304
我们学到了很多关于硬帽配置的知识，以及如何将多个网络添加到我们的硬头中，我们可以将我们的项目变成EVM代码，与任何网络一起工作，我们开始使用开发依赖而不是常规依赖。

5787
09:50:26.353 --> 09:50:30.553
readme是我不打算在这里深入讲解的东西。

5788
09:50:30.553 --> 09:50:38.124
readme有点像GitHub存储库的欢迎页面，它应该让你理解你的代码是做什么的。

5789
09:50:38.124 --> 09:50:39.983
成为太空网络的一部分。

5790
09:50:39.983 --> 09:50:44.892
成为区块链生态系统的一员不仅仅是你自己编写代码那么简单。

5791
09:50:44.892 --> 09:50:48.974
您希望其他人与您的代码和项目进行交互和参与。

5792
09:50:48.974 --> 09:50:50.509
我还没有向你展示如何使用GitHub。

5793
09:50:50.509 --> 09:50:54.784
但别担心，我们会但是如果你看我的心脏有简单的存储自述。

5794
09:50:54.784 --> 09:51:10.020
如果你向下滚动，通常，你会想要有一个入门部分在那里你定义如何设置所有的代码以及如何设置所有的东西一个快速入门部分，可能还有一个使用部分和一些测试部分，它教会人们如何实际使用和与你的代码交互。

5795
09:51:10.020 --> 09:51:13.830
因为我们只是学习更多的代码部分，而不是自述部分。

5796
09:51:13.830 --> 09:51:17.104
现在，我们不打算讨论如何制作一份出色的自述文件。

5797
09:51:17.104 --> 09:51:22.374
不过，我会在GitHub存储库中留下一个与这门课程相关的链接，链接到这个最佳自述模板。

5798
09:51:22.374 --> 09:51:35.654
它真的是一个非常棒的自述模板你可以复制到任何你的项目中使它们看起来非常好给它们一个非常好的设置，这样其他的开发人员就可以来到你的项目中，学习和参与你所编写的代码。

5799
09:51:35.654 --> 09:51:42.754
但好吧，你已经学到了很多东西，你应该为自己感到无比骄傲，为自己走到今天感到无比兴奋。

5800
09:51:42.754 --> 09:51:45.133
现在我要跳到TypeScript部分。

5801
09:51:45.133 --> 09:51:48.676
所以对于那些使用TypeScript进行编码的人，请随意跟随。

5802
09:51:48.676 --> 09:52:02.128
对于那些没有读过的人，你们刚刚完成了关于重击的基础部分，但请坚持下去，接下来的部分将是真正细化和磨练你的技能的部分，并为你提供使用这些框架的所有基本知识。

5803
09:52:02.128 --> 09:52:10.934
所以一定要关注接下来的两个部分，我们为你准备了更多精彩的内容，我们才刚刚开始深入智能合约生态系统。

5804
09:52:10.934 --> 09:52:14.741
坐好那一圈，喝好咖啡，回头见。

5805
09:52:14.741 --> 09:52:19.386
现在我们用TypeScript来做这个。

5806
09:52:19.386 --> 09:52:22.710
我将从JavaScript部分开始。

5807
09:52:22.710 --> 09:52:30.992
然而，如果在未来，你想开始一个新的Hardhead项目，你实际上可以开始一个新的项目与纱线，硬帽。

5808
09:52:30.992 --> 09:52:38.032
然后用TypeScript做一个优秀的高级示例项目，你会添加大量的插件。

5809
09:52:38.032 --> 09:52:41.082
你需要等待一段时间才能上传所有内容。

5810
09:52:41.082 --> 09:52:43.699
你等待，等待一段时间，直到所有东西都下载完成。

5811
09:52:43.699 --> 09:52:54.600
我们不会这么做，因为我将向你们展示如何将它转换成JavaScript，无论如何，如果在以后的章节中，当我们使用JavaScript进行编码时，如果你想使用TypeScript进行编码，你完全可以。

5812
09:52:54.600 --> 09:52:58.032
但让我们继续，告诉你们主要的区别是什么。

5813
09:52:58.032 --> 09:53:04.105
现在，高级TypeScript将添加一大堆包，你可能需要，也可能不需要，我将在下一课中讨论其中一些。

5814
09:53:04.105 --> 09:53:07.010
但有一些是你绝对需要的。

5815
09:53:07.010 --> 09:53:30.079
它们分别是attypechain / ethers / vfive, attypechain， / hard hat, attypescript, attypes， / Chai, attypes， / node, attypes / moko, TS节点，type chain和TypeScript。

5816
09:53:30.079 --> 09:53:40.064
我在GitHub上有一个与这门课相关的链接，我有一个纱线广告，你可以复制粘贴，如果你想复制粘贴到你的项目中去运行它。

5817
09:53:40.064 --> 09:53:42.116
哎呀，我应该把它们作为开发依赖项添加进去。

5818
09:53:42.116 --> 09:53:48.580
我们要让它们快速成为开发依赖项，只需要删除这两行，在这里加一个逗号。

5819
09:53:48.580 --> 09:53:50.644
太棒了，看起来好多了。

5820
09:53:50.644 --> 09:53:56.815
当然，我们要做的是将所有JavaScript转换为TypeScript。

5821
09:53:56.815 --> 09:54:03.581
任何有js的地方，我们都会放上Ts，显然，如果你用TypeScript从头开始编码，你会做。

5822
09:54:03.581 --> 09:54:04.482
ts从一开始。

5823
09:54:04.482 --> 09:54:08.974
这包括我们的hardhat。config，这也将是TypeScript。

5824
09:54:08.974 --> 09:54:11.784
另外，我们会添加一个TS config。JSON。

5825
09:54:11.784 --> 09:54:14.804
这将是我们的TypeScript配置。

5826
09:54:14.804 --> 09:54:17.260
通常情况下，我们会使用这样的设置。

5827
09:54:17.260 --> 09:54:20.414
你可以从与本课程相关的GitHub回购中复制这个。

5828
09:54:20.414 --> 09:54:26.265
它基本上是在告诉TypeScript, TypeScript的什么版本以及使用TypeScript需要包含什么文件。

5829
09:54:26.265 --> 09:54:29.356
现在让我们从deploy。TypeScript开始。

5830
09:54:29.356 --> 09:54:35.782
通常，我们不使用require，而是使用import，我们会做完全一样的事情。

5831
09:54:35.782 --> 09:54:40.822
我们将从安全帽导入醚运行网络。

5832
09:54:40.822 --> 09:54:48.956
然后在验证函数中，我们会添加我们会添加这些实参的类型。

5833
09:54:48.956 --> 09:54:51.956
合约地址是一个字符串。

5834
09:54:51.956 --> 09:54:55.044
args是一个参数数组。

5835
09:54:55.044 --> 09:55:01.784
我们会说它是任何数组，因为它可以是字符串，可以是数字，可以是气球，可以是任何东西。

5836
09:55:01.784 --> 09:55:08.990
我们还会说，对于IE，它可以是any，尽管这在技术上是一个错误类型，为了简单起见，我们将用any。

5837
09:55:08.990 --> 09:55:09.497
现在。

5838
09:55:09.497 --> 09:55:19.168
我们所有的TypeScript脚本都包含在TS配置中，或者任何TypeScript文件都是手动添加到这里的，我们的整个scripts文件夹都在这里，这很好。

5839
09:55:19.168 --> 09:55:21.480
现在我们要在这里加入醚。

5840
09:55:21.480 --> 09:55:23.943
如果我们看看我们的硬头。

5841
09:55:23.943 --> 09:55:24.419
配置。

5842
09:55:24.419 --> 09:55:33.721
ts，我们在这里仍然使用require，我们需要将它替换为导入，你可以使用。env / config来获取你的。env文件。

5843
09:55:33.721 --> 09:55:37.611
现在我们已经导入了所有内容，回到我们的部署。

5844
09:55:37.611 --> 09:55:40.136
t，我们可以看到绒毛已经消失了。

5845
09:55:40.136 --> 09:55:47.734
如果你想更明确，我们可以继续添加import at nomic labs slash hard hat醚，就像这样。

5846
09:55:47.734 --> 09:55:55.615
我们不需要在这里导入它的原因是这两个包也与Hardhead醚，所以他们自动导入它。

5847
09:55:55.615 --> 09:55:59.595
但如果你想要非常明确，你可以这样添加它。

5848
09:55:59.595 --> 09:56:01.166
现在，我们差不多可以开始了。

5849
09:56:01.166 --> 09:56:04.357
但是请记住，我们的Harnett点配置也导入了我们的任务。

5850
09:56:04.357 --> 09:56:10.063
我们需要更新我们的任务或块号为TypeScript fide。

5851
09:56:10.063 --> 09:56:17.221
当然，这里不是const require，而是从斜杠配置导入task。

5852
09:56:17.221 --> 09:56:21.839
我们要确保从locknumber导出任务为默认值。

5853
09:56:21.839 --> 09:56:25.433
我们会像这样执行export default task。

5854
09:56:25.433 --> 09:56:29.134
现在我们应该可以运行脚本了。

5855
09:56:29.134 --> 09:56:34.918
所以我们可以做纱线，艺术帽，运行脚本，员工。

5856
09:56:34.918 --> 09:56:35.058
ts。

5857
09:56:35.058 --> 09:56:37.865
如果我们愿意，我们可以做网络安全帽。

5858
09:56:37.865 --> 09:56:38.808
而可畏。

5859
09:56:38.808 --> 09:56:43.663
现在，当我们进行测试的时候，这里的情况就有点不同了。

5860
09:56:43.663 --> 09:56:46.741
让我们继续，改变这个required to import。

5861
09:56:46.741 --> 09:56:48.894
只是为了让它开心。

5862
09:56:48.894 --> 09:56:58.770
让我们试着运行纱线，艺术头测试，我们得到了一大堆错误，在VS code中实际上会继续从linter得到这些错误。

5863
09:56:58.770 --> 09:57:08.797
作为一名开发人员，在这个领域中遇到的最棘手的事情之一是调用契约中的函数，而这些函数并不存在，反之亦然。

5864
09:57:08.797 --> 09:57:11.594
我们不会调用确实存在的契约函数。

5865
09:57:11.594 --> 09:57:22.035
现在，契约的类型只是契约类型，这没什么用，因为契约类型不一定有我们想要的所有功能。

5866
09:57:22.035 --> 09:57:32.758
我们希望我们的契约是契约类型，但我们希望它们是我们的契约类型，因为如果它们是我们的契约类型，它们就可以具有我们希望它们具有的所有功能。

5867
09:57:32.758 --> 09:57:49.938
要让合约有正确的类型，我们可以使用这个叫type chain的工具，它能让合约有正确的类型type chain有一个强化的插件，它允许我们同时使用type chain和TypeScript, type chain / hard hat是我们已经安装过的东西之一。

5868
09:57:49.938 --> 09:57:59.675
要把它添加到我们的硬帽子，我们只需要进入硬帽子配置，并在import @ type chain / arhat中添加它。

5869
09:57:59.675 --> 09:58:16.358
一旦我们把它导入到我们的配置中，如果我们运行yarn hardhat，我们会得到一个叫做type chain的新任务，你读一下描述，它说为编译后的契约生成类型链类型，这将使我们所有的契约都有自己的类型。

5870
09:58:16.358 --> 09:58:25.989
我们可以有一个简单存储变量类型为简单存储契约，这样更好，因为我们总能准确地知道每个契约能做什么。

5871
09:58:25.989 --> 09:58:30.289
为了创造这个，我们运行纱线，罗汉式链条。

5872
09:58:30.289 --> 09:58:37.429
这将创建一个名为type chain / types的新文件夹。

5873
09:58:37.429 --> 09:58:52.273
有了所有契约的类型，你甚至可以进入简单存储子Ts，它将有所有不同的函数和所有与简单存储契约有关的东西自动编码为Typescript和JavaScript，这非常有帮助。

5874
09:58:52.273 --> 09:58:54.890
我还没有给你们展示这是什么。

5875
09:58:54.890 --> 09:59:02.909
但在。Git ignore中，我们通常想在。Git ignore中添加type chain和type chain dash类型，这样我们就不会把它们推到GitHub中。

5876
09:59:02.909 --> 09:59:09.046
现在回到我们的测试中，我们将在这里添加这些不同对象的确切类型。

5877
09:59:09.046 --> 09:59:12.973
我们会从刚创建的文件夹中导入它们。

5878
09:59:12.973 --> 09:59:34.063
我们会导入简单存储，逗号，简单存储下划线下划线工厂从。点斜杠类型，ain斜杠类型，简单存储工厂将是简单存储工厂然后民用存储当然，将是简单存储。

5879
09:59:34.063 --> 09:59:49.662
那么现在我们让简单存储工厂这是一种类型，简单存储，下划线工厂，然后是简单存储，这是一种类型的简单存储合同。

5880
09:59:49.662 --> 09:59:58.484
如果我们命令点击到简单存储，我们可以看到所有我们所知道和喜欢的契约函数，都在这里。

5881
09:59:58.484 --> 10:00:02.796
此外，我们拥有实际合同本身的所有功能。

5882
10:00:02.796 --> 10:00:07.971
一旦我们这样做了，我们就很好了我们只需要在这里有一些新的东西。

5883
10:00:07.971 --> 10:00:11.686
领代工厂还型醚点代工厂。

5884
10:00:11.686 --> 10:00:16.692
我们只需要把它包装成一个简单的存储工厂类型。

5885
10:00:16.692 --> 10:00:19.534
我们就像这样裹一下。

5886
10:00:19.534 --> 10:00:24.068
我们会说，作为简单的存储，我将会像工厂一样。

5887
10:00:24.068 --> 10:00:25.459
可以开始了。

5888
10:00:25.459 --> 10:00:28.676
现在我们已经添加了所有这些，我们可以运行纱线，硬头测试。

5889
10:00:28.676 --> 10:00:37.975
我们的测试运行是正常的，但是有了TypeScript和这些额外的输入，我们的生活大大改善了。

5890
10:00:37.975 --> 10:00:50.905
这就是你需要知道的关于TypeScript的所有知识，可重用，所有的分支都有一个可选的TypeScript分支，你可以使用它来引用和使用TypeScript。

5891
10:00:51.360 --> 10:00:54.886
我们已经学习了所有不同的事情的基础，我们可以用hardhat。

5892
10:00:54.886 --> 10:01:04.660
接下来的几堂课，硬帽趣味梗和硬帽智能合约彩票将成为我们在硬帽学习的所有工具的基础。

5893
10:01:04.660 --> 10:01:10.478
第八课将介绍全栈以及使用前端和构建全栈应用程序。

5894
10:01:10.478 --> 10:01:15.478
通过这门课程将给你所有的工具，开始你的web三旅程。

5895
10:01:15.478 --> 10:01:21.069
但如果你只是想学习基础知识，一定要把第九课学完。

5896
10:01:21.069 --> 10:01:26.601
如果你一直读到第十八课，你就会知道这个领域的所有前沿工具。

5897
10:01:26.601 --> 10:01:31.310
这样你就能轻松地成为该领域最优秀的开发人员之一。

5898
10:01:31.310 --> 10:01:33.835
所以希望你能坚持到最后。

5899
10:01:33.835 --> 10:01:47.160
这节课最重要的部分之一就是将我们的代码推送到GitHub，然后发一条推特庆祝我们将我们的第一个智能合约第一个web 3 GitHub仓库推送到GitHub。

5900
10:01:47.160 --> 10:01:54.851
所以在继续下一课之前，一定要把这段代码放到GitHub上。

5901
10:01:54.851 --> 10:02:12.310
如果你想发一条推特来庆祝，但一定要去GitHub部分，因为我说过，很多时候网络空间是一个难以置信的协作社区与GitHub或GitLab，或任何其他版本控制工具合作对你在这个领域的成功是必不可少的。

5902
10:02:12.360 --> 10:02:14.265
所以一定要做到这一点。

5903
10:02:14.265 --> 10:02:14.900
好吧。

5904
10:02:16.361 --> 10:02:19.694
我们课程的“资助我”部分。

5905
10:02:21.361 --> 10:02:35.615
我们将上传我们的第一个代码库到GitHub如果你从来没有做过这个，这一节我们将学习更多关于hardhat的知识使用我们已经使用过的熟悉的契约库，也就是fund me契约。

5906
10:02:35.615 --> 10:02:42.075
如果你正在使用与本课程相关的GitHub回购，你可以向下滚动到Hardhead Funmi。

5907
10:02:42.075 --> 10:02:45.884
所有的代码都在我们的回购单上。

5908
10:02:45.884 --> 10:02:57.180
如果你想做一个快速的开始，你可以把它克隆到CVU中，然后运行yarn，然后运行yarn hardhat部署这个，我将简要地向你展示它是什么样子的。

5909
10:02:57.180 --> 10:03:07.886
在VS code中，你可以做gitclone，抓取包，cd进去，然后输入code period。

5910
10:03:07.886 --> 10:03:10.161
在新的VS代码中打开它。

5911
10:03:10.161 --> 10:03:13.570
一旦你进入文件夹，你可以继续运行纱线。

5912
10:03:13.570 --> 10:03:26.619
要安装与此项目一起工作的所有依赖项，您计划使用测试网或以太扫描或货币市值，请随意使用私钥RPC URL、玉米市值密钥和以太扫描密钥填写您的Dotty和V。

5913
10:03:26.619 --> 10:03:34.264
然后你就可以跟着自述使用这个回购来运行纱线，硬帽部署。

5914
10:03:34.361 --> 10:03:37.651
它会展示如何部署一些契约和一些模拟等等。

5915
10:03:37.651 --> 10:03:42.199
所以让我们自己来建造它吧。

5916
10:03:42.199 --> 10:03:49.094
现在我们要为这个项目创建一个新目录，它的设置和我们之前见过的一样。

5917
10:03:49.094 --> 10:03:51.360
MK dir，安全帽。

5918
10:03:51.360 --> 10:03:56.683
我，FCC，我们将在Funmi cd到心脏，FCC，然后输入代码期。

5919
10:03:56.683 --> 10:04:05.299
如果代码段不适合你，你完全可以点击文件，打开文件夹，就像我们之前展示的那样。

5920
10:04:05.299 --> 10:04:07.080
现在，我们在一个全新的文件夹里。

5921
10:04:07.080 --> 10:04:09.497
我们要在这里加上安全帽。

5922
10:04:09.497 --> 10:04:15.912
我们要去跑纱线，加上冲刺戴夫，戴安全帽。

5923
10:04:15.912 --> 10:04:25.263
现在我们有了hardhat，在我们的包JSON和节点模块中，我们可以继续运行yarn，启动app。

5924
10:04:25.263 --> 10:04:32.200
它会说，你想做什么?我将在这里选择高级示例项目，向您展示如何进行。

5925
10:04:32.200 --> 10:04:35.395
我们要用一种我认为最有效的方式来设置。

5926
10:04:35.395 --> 10:04:37.598
我们继续做高级示例项目。

5927
10:04:37.598 --> 10:04:39.412
是的，我们要把它作为根结点。

5928
10:04:39.412 --> 10:04:41.062
是的，我们想添加一个Git忽略。

5929
10:04:41.062 --> 10:04:45.112
它还希望我们添加许多样例项目依赖项。

5930
10:04:45.112 --> 10:04:46.762
我们点击确定。

5931
10:04:46.762 --> 10:04:52.002
但我们最终不会用到所有这些我会告诉你们哪些是我们不会用到的以及为什么。

5932
10:04:52.002 --> 10:05:01.612
但现在，让我们继续并点击yes。

5933
10:05:02.362 --> 10:05:03.603
好吧，太棒了。

5934
10:05:06.362 --> 10:05:06.495
在这里。

5935
10:05:08.362 --> 10:05:08.808
在这里。

5936
10:05:11.362 --> 10:05:16.674
模块，也就是同样的脚本同样的测试也一样。

5937
10:05:16.674 --> 10:05:20.599
这里有一个。E和V。的例子。

5938
10:05:20.599 --> 10:05:21.806
它还附带。

5939
10:05:21.806 --> 10:05:23.250
Es lint文件。

5940
10:05:23.250 --> 10:05:25.361
es绒线，RC点j s。

5941
10:05:25.361 --> 10:05:25.583
es。

5942
10:05:25.583 --> 10:05:35.136
Lint被称为JavaScript linter，它可以帮助您查找并自动修复我使用的JavaScript代码中的问题。

5943
10:05:35.136 --> 10:05:37.963
我不是ES lint的大粉丝，所以我通常不使用它。

5944
10:05:37.963 --> 10:05:40.608
我要把这两个删掉。

5945
10:05:40.608 --> 10:05:43.658
如果你想保留它们，你完全可以忽略。Git。

5946
10:05:43.658 --> 10:05:53.922
我们将在这节课中最终理解这个文件的作用NPM ignore帮助忽略文件如果你想将你的项目升级为NPM包，我们不会这么做。

5947
10:05:53.922 --> 10:05:57.459
如果你想删除这个，你也可以pretty或忽略它，然后pretty DRC。

5948
10:05:57.459 --> 10:05:59.072
我们已经知道它们的作用了，小提示。

5949
10:05:59.072 --> 10:06:13.091
还有hint ignore，我们一会儿会讲到，还有Hardhead config，它已经包含了ropsten网络，gas报告器和ether扫描包。JSON以及所有附加包，自述文件更健壮一些。

5950
10:06:13.091 --> 10:06:14.982
当然，我们的纱线点锁定。

5951
10:06:14.982 --> 10:06:20.887
这个高级项目看起来和我们将要处理的很相似。

5952
10:06:20.887 --> 10:06:24.230
现在我想谈谈这个灵魂暗示。

5953
10:06:24.230 --> 10:06:35.130
溶剂溶剂被称为固体洗涤器我们可以用它来洗涤我们的代码洗涤是运行一个程序来分析代码的潜在错误的过程。

5954
10:06:35.130 --> 10:06:42.363
它也做一些格式化，通常情况下，Lint是对JavaScript代码进行Lint的一种方法。

5955
10:06:42.363 --> 10:06:55.363
hint是一种对固体性代码进行lint的方法，我们用pretty来格式化我们的代码，我们可以用soul hint来lint，我们的代码，它们经常互换使用，尽管这并不完全正确，因为它们有一点不同。

5956
10:06:55.363 --> 10:07:03.459
我们可以通过运行yarn、sole hint在代码上运行这个lint，然后输入我们想要lint的文件的名称。

5957
10:07:03.459 --> 10:07:10.903
我们做合同，斜杠然后你就可以开始了一切看起来都很好，什么都不会发生。

5958
10:07:10.903 --> 10:07:16.583
假设我们有一个变量我们没有明确说它的可见性。

5959
10:07:16.583 --> 10:07:23.815
这并不是最佳实践，因为在理想情况下，我们总是确切地说明某些变量的可见性。

5960
10:07:23.815 --> 10:07:25.266
这显然是默认的。

5961
10:07:25.364 --> 10:07:27.478
但通常更明确一点会更好。

5962
10:07:28.364 --> 10:07:42.739
yarn，所以hint，契约启动，它会给我们一个警告，说我们应该显式地标记状态的可见性，这个linter是检查运行代码的一些最佳实践的好方法。

5963
10:07:42.739 --> 10:07:47.801
所以我们肯定会在周围留一个小提示。

5964
10:07:47.801 --> 10:07:52.855
现在我们已经在这里得到了一个回购，让我们在这里添加一些常见的设置部件。

5965
10:07:52.855 --> 10:07:54.170
所以在pretty中。

5966
10:07:54.170 --> 10:07:59.073
Rc，我们要把这个换成我们一直用的那个。

5967
10:07:59.073 --> 10:08:03.538
表单us选项卡的选项卡为假，半假，单引号，也是假。

5968
10:08:03.538 --> 10:08:16.025
我们将更新更漂亮的。ignore node模块，package。JSON图像构件，缓存覆盖率ID。v。*，自述，覆盖率以及其他你想添加到这里的东西。

5969
10:08:16.025 --> 10:08:18.804
滚动到合约文件夹。

5970
10:08:18.804 --> 10:08:22.610
我们要把这个greeting。soul换成fund me。soul。

5971
10:08:22.610 --> 10:08:25.625
现在让我们在这里添加契约。

5972
10:08:25.625 --> 10:08:34.301
如果你跟着回购，你会进入合同文件夹，这里还有一个文件夹合同看起来有点不同。

5973
10:08:34.301 --> 10:08:41.030
如果你有这些契约，从remix中窃取，让我们从remix中获取它们因为我们要对它们做一些改变。

5974
10:08:41.030 --> 10:08:52.301
如果你没有再做混音了，也许你不应该，因为你应该休息一下，你可以跳到第四课的混音Funmi跳到这里，从里面拿到合约。

5975
10:08:52.364 --> 10:08:56.140
只要去乐趣v破折号免费代码营教程，并从那里获取代码。

5976
10:08:56.140 --> 10:08:59.490
我们会抓取fun me和price converter。soul。

5977
10:08:59.490 --> 10:09:05.429
删除旧文件，创建一个新文件，命名为fundme。song。

5978
10:09:05.429 --> 10:09:06.880
粘贴进去。

5979
10:09:06.880 --> 10:09:11.745
然后我们要创建价格转换器。

5980
10:09:11.745 --> 10:09:12.792
这是所有。

5981
10:09:12.792 --> 10:09:17.500
现在我们有我们的Funmi和我们的价格转换合同在这里。

5982
10:09:17.500 --> 10:09:24.882
现在我们要做的第一件事我们上次做的第一件事之一是我们运行yarn compile以确保我们的代码按我们想要的方式运行。

5983
10:09:24.882 --> 10:09:32.380
在我们点击编译之前，我们需要做的一件事是进入Hardhead。config，我们要确保我们在正确的固体度版本上。

5984
10:09:32.380 --> 10:09:34.538
所以是(0,8)

5985
10:09:34.538 --> 10:09:34.918
8在这里。

5986
10:09:34.918 --> 10:09:39.247
让我们继续尝试编译。

5987
10:09:39.365 --> 10:09:42.605
所以我们可以运行纱线硬头编译。

5988
10:09:44.365 --> 10:09:45.783
这里会有一个错误。

5989
10:09:47.365 --> 10:09:53.880
未安装从合约导入的合约，请尝试使用npm安装它。

5990
10:09:53.880 --> 10:10:00.069
在混音中，我们直接从NPM和GitHub导入chainlink slash合同。

5991
10:10:00.069 --> 10:10:22.233
但在我们的本地代码中，我们必须明确地告诉Hardhead，从哪里获得这个，我们想要从NPM包管理器下载这个，我们可以通过运行yarn，在chainlink slash contracts中添加破折号dev来下载它。

5992
10:10:23.365 --> 10:10:27.615
现在我们已经将它下载到我们的文件中，我们将能够在这里的Node模块中看到它。

5993
10:10:27.615 --> 10:10:34.235
Hardhead现在足够聪明，知道在chain link斜杠契约将指向我们所拥有的节点模块。

5994
10:10:34.235 --> 10:10:41.508
所以我们现在可以运行yarn Hardhead编译boom，现在我们可以看到编译成功的三个固体文件。

5995
10:10:41.508 --> 10:10:48.575
现在我们的契约在这里，代码编译成功了。

5996
10:10:48.575 --> 10:10:53.348
我们可能会想要部署我们的代码?在最后一节中，我们使用了脚本模块。

5997
10:10:53.348 --> 10:10:56.225
我们制作了自己的手动部署脚本。

5998
10:10:56.366 --> 10:11:04.866
然而，你会注意到，你越是使用原始醚，甚至只是使用硬帽跟踪我们所有的部署就会变得有点棘手。

5999
10:11:04.866 --> 10:11:08.753
如果只使用部署脚本，它不会将部署保存到任何文件中。

6000
10:11:08.753 --> 10:11:16.769
此外，在部署脚本中包含用于部署的所有内容可能会使测试和部署脚本不能完全协同工作。

6001
10:11:16.769 --> 10:11:26.015
还有一些其他的事情可能会有点棘手，我们实际上要用一个包来解决我刚才提到的所有问题，还有一些其他的事情会更容易。

6002
10:11:26.015 --> 10:11:30.313
我说的这个包就是硬帽部署包。

6003
10:11:30.313 --> 10:11:34.579
在与本课程相关的GitHub存储库中有这个包的链接。

6004
10:11:34.579 --> 10:11:38.307
它是一个用于可复制部署和易于测试的硬帽插件。

6005
10:11:38.366 --> 10:11:42.738
如果我们向下滚动到安装，我们可以看到我们用正常的方式安装它。

6006
10:11:42.738 --> 10:11:43.958
他们使用的是npm。

6007
10:11:43.958 --> 10:11:46.529
我们要继续用纱线。

6008
10:11:46.529 --> 10:11:51.384
为了添加它，我们会使用yarn，添加hardhat dash deploy。

6009
10:11:51.384 --> 10:11:56.075
当然，我们要做的是冲刺戴夫。

6010
10:11:56.075 --> 10:12:01.970
一旦完成部署这个require语句到我们的硬帽子。

6011
10:12:01.970 --> 10:12:02.595
配置。

6012
10:12:02.595 --> 10:12:02.803
js。

6013
10:12:02.803 --> 10:12:06.316
再一次，配置基本上是我们的入口点。

6014
10:12:06.316 --> 10:12:08.445
我们就从这里开始。

6015
10:12:08.445 --> 10:12:11.111
我们可以删除我们的deploy。

6016
10:12:11.111 --> 10:12:11.779
js脚本。

6017
10:12:11.779 --> 10:12:24.428
现在如果我们运行yarn hardhat，你会看到这里有一堆新任务，其中一个是这个部署任务，这个部署任务将是我们用来部署契约的主要任务。

6018
10:12:24.428 --> 10:12:32.754
我们不会在scripts文件夹中写入部署脚本，我们会创建一个新文件夹，我们可以通过mkdir deploy创建一个新文件夹。

6019
10:12:32.754 --> 10:12:35.915
或者你也可以右键点击，点击新建文件夹。

6020
10:12:35.915 --> 10:12:40.673
这个deploy文件夹将是许多硬帽部署模块用于部署代码的地方。

6021
10:12:40.673 --> 10:12:43.301
这将是我们写剧本的地方。

6022
10:12:43.301 --> 10:12:46.735
要编写脚本，我们通常需要在这里添加一个东西。

6023
10:12:46.735 --> 10:12:52.992
因为我们将在所有脚本中使用ethers JS，所以我们想在这里将Hardhead deploy ethers添加到包中。

6024
10:12:52.992 --> 10:12:59.367
现在，我们不只是做yarn，添加dash dev来部署醚，我们要做一些有点奇怪的事情。

6025
10:12:59.367 --> 10:13:04.817
我们会使用yarn add或npm install dash Dev，我们会像这样安装它。

6026
10:13:04.817 --> 10:13:06.055
我复制一下。

6027
10:13:06.055 --> 10:13:08.071
你可以直接从回购协议上抄下来。

6028
10:13:08.071 --> 10:13:12.296
我们会选择yarn，添加dash Dev，然后粘贴到这里。

6029
10:13:12.367 --> 10:13:20.500
我们所做的是在nomic实验室，我们用过的硬帽醚，我们用硬帽部署醚覆盖它。

6030
10:13:20.500 --> 10:13:24.334
记得我们在上一个项目中是如何使用硬帽醚的吗?

6031
10:13:24.334 --> 10:13:28.070
所以这个安全帽可以覆盖以太来使用安全帽部署。

6032
10:13:28.070 --> 10:13:35.167
我们使用硬帽部署醚，所以硬帽部署可以覆盖Hardhead, Hardhead会覆盖醚，这很有趣。

6033
10:13:35.167 --> 10:13:43.144
当你这样说的时候，这将使醚能够跟踪和记住我们在合同中实际做的所有不同的部署。

6034
10:13:43.144 --> 10:13:48.736
看看我们的JSON包，我们可以看到nomic labs仪表盘有醚。

6035
10:13:48.736 --> 10:13:51.259
现在它的版本是MPM。

6036
10:13:51.259 --> 10:13:52.747
Hardhead部署醚。

6037
10:13:52.747 --> 10:14:02.118
这是我们的package。JSON，意思是hardhat ethers包现在被hardhat deploy ethers包覆盖，这就是我们想要的。

6038
10:14:02.118 --> 10:14:03.055
好了,好了。

6039
10:14:03.055 --> 10:14:13.722
现在我们有了这个设置，我们可以开始写部署脚本了，Hart的工作方式是所有添加到deploy文件夹的脚本在我们运行yarn，硬帽部署时都会运行。

6040
10:14:13.722 --> 10:14:18.499
因此，一个好的实践通常是给它们编号，以便它们按照您希望的顺序运行。

6041
10:14:18.499 --> 10:14:32.810
因为我们只有一个合同，我们想要部署Funmi合同，我们将执行01 deploy Funmi Jas，在这个脚本中，我们将在这里定义如何部署基本合同。

6042
10:14:32.810 --> 10:14:35.819
好，我们在部署Funmi脚本中。

6043
10:14:35.819 --> 10:14:41.008
传统上，我们做了什么，我们做了导入，我们做了主函数。

6044
10:14:41.008 --> 10:14:50.253
然后我们调用main function, Hardhead deploy有点不同，我们仍然会导入库和包，但我们不会有main function。

6045
10:14:50.253 --> 10:14:59.141
当我们运行Hardhead deploy时，我们也不会调用main函数Harnett deploy实际上会调用我们指定的函数。

6046
10:14:59.141 --> 10:15:00.240
在这个脚本里。

6047
10:15:00.240 --> 10:15:06.279
我们要做的是创建一个函数，命名为deploy funk。

6048
10:15:06.368 --> 10:15:19.013
我们会导出这个deploy函数作为Hardhead deploy寻找的默认函数，因此我们可以说，module that exports。default = deploy funk。

6049
10:15:19.013 --> 10:15:24.284
为了测试它，我们可以继续执行console。log，嗨。

6050
10:15:24.284 --> 10:15:29.505
然后在我们的终端，运行纱线，安全帽，部署。

6051
10:15:29.505 --> 10:15:33.214
哎呀，把括号去掉。

6052
10:15:33.214 --> 10:15:33.767
对不起。

6053
10:15:33.767 --> 10:15:34.967
再运行一次。

6054
10:15:34.967 --> 10:15:39.175
我们可以看到它运行了这里的deploy func。

6055
10:15:39.175 --> 10:15:49.162
如果这个语法更容易理解，可以使用这个语法我们会在运行时环境中将心脏作为参数传递给这个函数。

6056
10:15:49.162 --> 10:15:57.758
但是，如果我们转到heart hat部署文档，向下滚动到示例脚本，语法看起来有点不同。

6057
10:15:57.758 --> 10:16:01.969
让我来解释一下这是怎么回事以及我们要怎么写我们的。

6058
10:16:01.969 --> 10:16:16.143
与其像这样定义所有东西，并定义函数名，就像我们之前做的那样，我们实际上要使用一个无名称的同步函数，我们要使它成为一个匿名函数，就像我们之前看到的那样。

6059
10:16:16.143 --> 10:16:23.877
相反，我们会像这样说async参数，我将在运行时环境中传递我们的参数。

6060
10:16:23.877 --> 10:16:26.335
这是一个箭头函数。

6061
10:16:26.335 --> 10:16:31.589
然后我们将把这整个东西包装在模块。exports中。

6062
10:16:31.589 --> 10:16:39.702
我们会说，module。exports，等于这个async函数，像这样。

6063
10:16:39.702 --> 10:16:47.190
这里的语法和上面的几乎一样，我们只是没有async函数的名字。

6064
10:16:47.190 --> 10:16:50.046
这就是我们要设置它的方法。

6065
10:16:50.046 --> 10:16:56.797
但是如果这个语法对你来说有一点困惑你可以随意使用上面的这个因为这两个是一样的。

6066
10:16:56.797 --> 10:17:04.569
接下来大部分文档做的是它从我们将要使用的HRV中取出变量和函数。

6067
10:17:04.569 --> 10:17:07.210
HRV是运行时环境的核心。

6068
10:17:07.210 --> 10:17:17.894
当我们运行部署脚本时，heart hat deploy会自动调用这个函数，并将硬帽对象传递给它，就像硬帽简单存储中的后面一样。

6069
10:17:17.894 --> 10:17:19.674
在我们的部署脚本中。

6070
10:17:19.674 --> 10:17:24.322
我们在网络中运行的以太来自于硬帽，而不是硬帽。

6071
10:17:24.370 --> 10:17:27.512
我们来自HRV，这基本上和安全帽是一样的。

6072
10:17:27.512 --> 10:17:34.735
对于我们的脚本，当使用const时，我们将只使用来自陪审团的两个变量。

6073
10:17:34.735 --> 10:17:38.052
获取命名帐户。

6074
10:17:38.052 --> 10:17:40.845
和部署。

6075
10:17:41.370 --> 10:17:43.666
这个语法可能看起来有点奇怪。

6076
10:17:44.370 --> 10:17:47.042
一种从树中提取这些变量的方法。

6077
10:17:47.370 --> 10:17:54.570
这和树。获取命名帐户和HRA。部署是一样的。

6078
10:17:54.570 --> 10:17:59.606
但像这样把它们拉出来意味着我们不需要再在一开始加树了。

6079
10:17:59.606 --> 10:18:04.644
此外，JavaScript还有一种叫做“语法糖”的东西。

6080
10:18:04.644 --> 10:18:11.314
所以我们不用像这样在两行上做，我们可以在一行上做整位。

6081
10:18:11.314 --> 10:18:18.094
相反，我们只是外推这两个变量，就在函数声明中。

6082
10:18:18.094 --> 10:18:21.956
这条线和这条线是一样的。

6083
10:18:21.956 --> 10:18:28.636
这是一个使用箭头符号的异步、无名称函数，或者使用这里的部署脚本。

6084
10:18:28.636 --> 10:18:31.658
我们默认用module。exports导出它。

6085
10:18:31.658 --> 10:18:33.036
我不知道那是不是很多。

6086
10:18:33.036 --> 10:18:35.588
另一个是这里有很多语法糖。

6087
10:18:35.588 --> 10:18:39.475
但如果这对你来说真的很困惑，请随意使用上面的方法。

6088
10:18:39.475 --> 10:18:50.423
当我们提到get named accounts时，你也可以只做一个3。get named accounts，或者一个3。deployment。

6089
10:18:50.423 --> 10:18:59.303
所以希望，这很清楚上面的部分和下面的部分是一样的，你觉得用哪个更舒服就用哪个。

6090
10:18:59.371 --> 10:19:02.799
但是好了，现在我们已经解决了所有的问题，让我们继续这个脚本。

6091
10:19:02.799 --> 10:19:12.002
我们使用这个部署对象，通过这个部署对象得到两个函数，这两个函数是deploy函数和log函数。

6092
10:19:12.002 --> 10:19:15.080
我们写入const，即部署日志=部署。

6093
10:19:15.080 --> 10:19:19.287
我们会把这两个函数从部署中取出来。

6094
10:19:19.287 --> 10:19:23.203
然后我们还会做const Deployer。

6095
10:19:23.371 --> 10:19:26.447
等号等待，获得命名帐户。

6096
10:19:28.371 --> 10:19:35.523
这个新的部署函数，这个新的日志函数，我们从这个奇怪的get named accounts函数获取部署者帐户。

6097
10:19:35.523 --> 10:19:42.306
这个get named accounts函数是什么呢，这个get named accounts是一种获取指定账户的方法。

6098
10:19:42.371 --> 10:19:52.246
在使用以太时，我们在使用以太时看到，我们实际上可以根据每个网络的Account部分中的数字获得我们的帐户。

6099
10:19:52.246 --> 10:20:10.746
举个例子，在这个私钥列表中，私钥0私钥1私钥2，记住哪个可能有点混乱所以我们可以在底部添加一个叫做命名帐户的部分我们可以在帐户数组中命名每个点。

6100
10:20:10.746 --> 10:20:12.467
我们用命名账户。

6101
10:20:12.467 --> 10:20:17.129
其中一个帐户将命名为Deployer。

6102
10:20:17.129 --> 10:20:22.725
默认情况下，带account的0是Deployer。

6103
10:20:22.725 --> 10:20:28.904
我们还可以指定哪个数字将是跨不同链的部署者帐户。

6104
10:20:28.904 --> 10:20:36.819
例如，在Rigby上，我们希望部署者帐户是第一个位置，我们可以这样做，在hard hat上，我们可以这样做。

6105
10:20:36.819 --> 10:20:38.404
我们可以创建多个用户。

6106
10:20:38.404 --> 10:20:46.657
例如，如果我们想为某个测试做一个用户，我们会在这里说default是1或任何我们想要的东西。

6107
10:20:46.657 --> 10:20:52.802
回到我们的部署，我们说我们要从命名账户中抓取部署者账户。

6108
10:20:52.802 --> 10:20:57.752
最后，我们要获取链ID原因很快就会清楚了。

6109
10:20:57.752 --> 10:21:04.277
我们写入const, chain ID = network。config。chain ID。

6110
10:21:04.277 --> 10:21:12.318
现在，我们如何实际部署这个资金我合同?我们想一下这个问题。

6111
10:21:12.372 --> 10:21:16.581
在做混音的时候，这很简单，对吧?我们刚把它部署到一个测试网上。

6112
10:21:16.581 --> 10:21:21.572
啊，这就是问题所在，把它部署到溜冰场上，测试网有点慢。

6113
10:21:21.572 --> 10:21:35.684
我们并不总是想要部署到这些慢速测试网甚至是一个主网当我们修补和摆弄我们的合同时，我们知道那将是非常糟糕的，我们真的想部署到一个测试网作为我们在本地完成所有测试后的最后一站。

6114
10:21:35.684 --> 10:21:42.635
或者我们可以将其部署到一个测试中，以查看一些非常特定的代码是否工作，例如，使用链链接文档。

6115
10:21:42.635 --> 10:21:45.597
所以理想情况下，我们先把它部署到本地网络。

6116
10:21:45.597 --> 10:22:00.073
但我们能这么做吗?如果我们看一下价格转换器，点Seoul，这里有这个硬编码地址，这个0x地址，如果我们去Doc的点chain链接EVM链，Aetherium数据供给的合同地址。

6117
10:22:00.073 --> 10:22:03.854
那个地址是第eth USD，是专门给Rinkeby的。

6118
10:22:03.854 --> 10:22:10.759
如果我们在安全帽网络工作呢?例子吗?默认网络吗?安全帽。

6119
10:22:10.759 --> 10:22:15.587
就像我之前说的，如果你不写这部分，它就会自动成为默认网络。

6120
10:22:15.587 --> 10:22:19.730
但如果我们指向硬帽子网络，硬网络是一个空白的区块链。

6121
10:22:19.730 --> 10:22:29.169
每次脚本完成时，它都会被销毁，即使我们使用本地节点，这个价格提要契约也不存在，其中一个代码不会用数据更新。

6122
10:22:29.169 --> 10:22:40.147
那么我们该怎么办呢?我们如何在本地测试和与代码交互?我们有办法做到这一点吗?我们可以这样做的一种方法我们稍后会学到一点实际上是fork一个区块链，你可以把东西硬编码。

6123
10:22:40.147 --> 10:22:45.741
但通常，最好还是弄清楚如何使用所谓的mock来完成所有事情。

6124
10:22:45.741 --> 10:22:53.717
Stack Overflow上有一个很好的问题，什么是mock，而mock主要用于单元测试，这个我们稍后会讲到。

6125
10:22:53.717 --> 10:22:57.760
被测试对象可能依赖于其他复杂对象。

6126
10:22:57.760 --> 10:23:06.601
为了隔离对象的行为，需要用模拟真实对象行为的mock替换其他对象。

6127
10:23:06.601 --> 10:23:10.891
简而言之，模拟就是创建模拟真实对象行为的对象。

6128
10:23:10.891 --> 10:23:13.928
现在，这可能看起来有很多单词。

6129
10:23:13.928 --> 10:23:20.717
但基本上，我们想做的是我们想做一个假的价格供给合同我们可以使用，我们可以在本地工作时控制它。

6130
10:23:20.717 --> 10:23:31.273
回到这里，我在这里留个便条说，当选择本地主机或硬帽网络时，我们想要使用mock。

6131
10:23:31.273 --> 10:23:36.017
好的，很好，我们可以用一个模拟，我们一会儿会学习如何制作一个。

6132
10:23:36.017 --> 10:23:51.023
好吧，当我们想要改变链，例如，回到点。点链链接EVM链，合同地址，有很多不同的区块链有价格供给。

6133
10:23:51.023 --> 10:23:56.109
在每一个区块链上，eth美元价格feed会有一点不同。

6134
10:23:56.109 --> 10:24:08.814
例如，我们在看ETH美元，Aetherium主网的ETH美元地址与Rigby的ETH美元地址是不同的，这是有意义的，它们是不同链上完全不同的合同，它们有非常相似的功能。

6135
10:24:08.814 --> 10:24:10.169
它们做着几乎完全相同的事情。

6136
10:24:10.169 --> 10:24:12.115
但它们仍然是不同的。

6137
10:24:12.115 --> 10:24:23.127
我们还需要一种方法来模块化或参数化，这里的这个地址，这样无论我们部署到哪个链，我们都不需要改变任何代码，我们总是可以让代码完全相同。

6138
10:24:23.127 --> 10:24:27.293
我们不需要到这里来翻转值翻转变量之类的。

6139
10:24:27.293 --> 10:24:30.986
下面的内容我们要记住这些。

6140
10:24:30.986 --> 10:24:32.856
现在为了参数化。

6141
10:24:32.856 --> 10:24:37.598
我们实际上想要分清轻重缓急，对我们的基本灵魂做一点重构。

6142
10:24:37.598 --> 10:24:42.675
重构基本上意味着回去改变代码的工作方式。

6143
10:24:42.675 --> 10:24:50.804
现在我们有这个构造函数构造函数是每当我们部署契约时自动被调用的函数。

6144
10:24:50.804 --> 10:24:56.357
现在它没有做很多事情它只是将owner变量更新为契约中发送的对象。

6145
10:24:56.357 --> 10:24:59.066
但实际上我们可以做的远不止这些。

6146
10:24:59.066 --> 10:25:11.111
因为这个构造函数和其他函数一样是一个函数，我们可以让它接受参数，我们希望它拥有的其中一个参数是价格提要的地址。

6147
10:25:11.111 --> 10:25:14.077
让我们继续，添加这个，看看如何重构所有这些代码。

6148
10:25:14.077 --> 10:25:19.701
我们会在这里为构造函数添加构造函数地址和价格提要。

6149
10:25:19.701 --> 10:25:21.078
当我们部署契约时。

6150
10:25:21.078 --> 10:25:25.511
现在我们将根据我们所处的链向它传递第eth个USD价格提要地址。

6151
10:25:25.511 --> 10:25:34.098
如果我们在溜冰场B，我们将使用这个地址如果一个多边形将使用不同的一个b&b，不同的一个，Gnosis hecho，雪崩等，你知道的。

6152
10:25:34.098 --> 10:25:36.582
我们要像这样把它边缘化。

6153
10:25:36.582 --> 10:25:56.375
现在，我们的构造函数接受了价格提要的参数，我们实际上可以在价格转换器中保存一个aggregator v3接口对象作为全局变量，我们只需创建一个aggregator v3 interface类型的价格提要变量，同样，我们从chainlink repo导入它，这是一个被编译到ABI的接口对象。

6154
10:25:56.375 --> 10:26:00.510
如果将ABI与up匹配到一个地址，就会得到一个可以与之交互的契约。

6155
10:26:00.510 --> 10:26:01.899
我们在这里做同样的事情。

6156
10:26:01.899 --> 10:26:14.287
我们会说，聚合Tor, v3接口，公共价格提要，配给然后调用这个价格提要地址这样它们就不会有相同的名称。

6157
10:26:14.287 --> 10:26:31.222
在构造函数中，我们会说，price feed =我们会做和价格转换器= aggregate一样的事情在价格feed地址的三个接口中。

6158
10:26:31.222 --> 10:26:42.273
就像现在，我们有这个可变的模块化的价格提要地址，取决于我们在哪个链上。

6159
10:26:42.273 --> 10:26:47.937
现在，我们能做的是获取这个价格提要地址，我们能把它用于我们的价格转换器。

6160
10:26:47.937 --> 10:26:55.585
那么我们在哪里使用价格转换器呢?提醒一下，我们用的价格转换器是256。

6161
10:26:55.585 --> 10:26:59.646
我们把它用作256单元类型上的一个库。

6162
10:26:59.646 --> 10:27:03.568
我们调用message。value。get转化率。

6163
10:27:03.568 --> 10:27:17.309
我们看一下价格转换器，我们有这个函数get conversion rate，它以FML作为初始参数，因为这是一个库，它会自动将message。value传递给这个get conversion rate函数。

6164
10:27:17.375 --> 10:27:24.907
但我们也可以传入这个价格提要，因此我们不再需要在get价格中硬编码它。

6165
10:27:24.907 --> 10:27:27.185
我们来看看怎么做。

6166
10:27:27.185 --> 10:27:32.323
我们能做的是，我们能做message。value。get转化率，我们会在这里插入价格feed。

6167
10:27:32.323 --> 10:27:42.876
然后我们需要更新get转换速率用逗号这样它有第二个参数，因为，记住，初始参数将是message。value。

6168
10:27:42.876 --> 10:27:47.328
第二个参数就是我们在这里定义的。

6169
10:27:47.328 --> 10:27:53.601
我们写s amount，逗号agreg gate torv3接口。

6170
10:27:53.601 --> 10:27:57.601
我们称之为价格供给。

6171
10:27:57.601 --> 10:28:05.409
现在，当我们调用get价格函数时，我们可以把价格信息传递给get价格函数。

6172
10:28:05.409 --> 10:28:08.010
上面这里是get price。

6173
10:28:08.010 --> 10:28:17.235
你猜它是一个集合或者三个接口叫做价格供给。

6174
10:28:17.235 --> 10:28:22.893
现在我们不再需要在价格提要中硬编码。

6175
10:28:22.893 --> 10:28:28.501
我们可以删除这些行，让它像这样编译，这太棒了。

6176
10:28:28.501 --> 10:28:46.998
快速复习一下，我们将价格提要地址参数化并通过构造函数将其作为全局变量保存到聚合器v3接口类型中，或者将其传递给get转化率函数，后者将其传递给get价格函数，然后调用最新一轮数据。

6177
10:28:46.998 --> 10:28:54.511
我们也许可以让它更简单，也许可以去掉get价格函数把这段代码放在get转化率中。

6178
10:28:54.511 --> 10:28:55.629
但我们先把它放在这里。

6179
10:28:55.629 --> 10:28:58.549
现在我们已经完成了重构，让我们确保它工作。

6180
10:28:58.549 --> 10:29:03.910
Yarn Hardhead，编译，无效值未定义hardhat。config。networks。

6181
10:29:03.910 --> 10:29:07.243
让我们快速进入配置。

6182
10:29:07.377 --> 10:29:10.011
这是因为默认网络需要在网络之外。

6183
10:29:10.011 --> 10:29:10.884
我的错误。

6184
10:29:10.884 --> 10:29:12.550
让我们再试一次。

6185
10:29:12.550 --> 10:29:15.803
我拼错了接口和价格转换器。

6186
10:29:15.803 --> 10:29:26.770
提醒一下，如果出现这样的错误，通常，你可以命令点击或控制点击在编辑器中打开文件，这会节省你很多时间，我们会定义行并找到文件。

6187
10:29:26.770 --> 10:29:28.589
但是，让我们把它拼写正确。

6188
10:29:28.589 --> 10:29:30.131
让我们再试一次。

6189
10:29:30.131 --> 10:29:31.036
而可畏。

6190
10:29:31.036 --> 10:29:33.812
看起来编译是正确的。

6191
10:29:33.812 --> 10:29:46.304
我们有一些警告，看起来这些警告是关于这个git版本的，因为我们跟踪了这个，我们在下面创建了一个新的价格变量，我们刚创建了一个全局价格自由变量。

6192
10:29:46.377 --> 10:29:50.996
让我们直接删除get版本函数因为我们并不需要它。

6193
10:29:50.996 --> 10:29:54.546
我们只使用Git版本来演示如何实际开始使用接口。

6194
10:29:54.546 --> 10:29:58.156
然后我们再编译一次。

6195
10:29:58.156 --> 10:30:00.444
Boom编译成功。

6196
10:30:00.444 --> 10:30:01.121
太棒了。

6197
10:30:01.377 --> 10:30:03.196
现在我们重构了代码。

6198
10:30:04.377 --> 10:30:07.894
发送地址取决于我们所在的网络。

6199
10:30:08.377 --> 10:30:08.699
太好了。

6200
10:30:12.377 --> 10:30:15.611
Funmi脚本，让我们学习如何实际部署它的其余部分。

6201
10:30:15.611 --> 10:30:24.627
为了部署契约，我们记得在上一节中，我们使用契约工厂(点击deploy)，我们只需使用这个deploy函数。

6202
10:30:24.627 --> 10:30:30.849
要使用部署函数，我们写入const Funmi，这是契约的名称，等于await。

6203
10:30:30.849 --> 10:30:39.584
我们会调用这个deploy函数，我们正在部署的契约的名字，然后是我们想在这里添加的覆盖列表。

6204
10:30:39.584 --> 10:30:45.015
我们会说谁在部署这个我们会说它来自部署者。

6205
10:30:45.015 --> 10:30:53.344
我们会把任何参数传递给构造函数在这个args片段中，我们刚添加了一个Argh。

6206
10:30:53.344 --> 10:31:01.878
这些括号，是参数列表，我们会把价格提要地址放在这里，我们马上会演示怎么做，把价格提要地址放在这里。

6207
10:31:01.878 --> 10:31:08.674
然后我们还会在这里做一些自定义日志记录这样我们就不需要做所有这些我们一直在做的console。log之类的东西。

6208
10:31:08.674 --> 10:31:11.414
我们需要在这里放点东西。

6209
10:31:11.414 --> 10:31:13.442
我们得把地址写在这里。

6210
10:31:13.442 --> 10:31:18.301
你可以用这个反斜杠*在你的代码中间放一个公共符号。

6211
10:31:18.378 --> 10:31:22.902
我们不能用const address =，你知道地址，然后把它放在这里。

6212
10:31:22.902 --> 10:31:25.139
我是说，我们可以，但我们现在没有优先考虑。

6213
10:31:25.139 --> 10:31:27.733
对吧?我们又回到了硬编码的阶段。

6214
10:31:27.733 --> 10:31:44.700
那么我们能做些什么呢?我们可以用链ID来做一些事情比如，如果链ID是x，用地址Y，如果链ID是Z，用地址A。

6215
10:31:44.700 --> 10:31:47.378
我们可以做这样的东西。

6216
10:31:47.378 --> 10:31:51.190
为了启用这个功能，我们实际上从Ave GitHub中取出了一个页面。

6217
10:31:51.190 --> 10:31:58.644
Ave是另一个在多条链上的协议它必须将它们的代码部署到多条链上并使用多个不同的地址。

6218
10:31:58.644 --> 10:32:02.473
所以它们所做的就是使用一些不同的有用的技巧。

6219
10:32:02.473 --> 10:32:05.503
但其中一个主要的是使用这个助手硬帽配置。

6220
10:32:05.503 --> 10:32:09.778
现在他们在使用TypeScript和JavaScript，但这是一样的。

6221
10:32:09.778 --> 10:32:15.926
通过这个配置，它们有不同的变量，这取决于它们实际所在的网络。

6222
10:32:15.926 --> 10:32:19.706
根据它们所在的网络，它们使用不同的变量。

6223
10:32:19.706 --> 10:32:24.632
所以他们使用这个网络配置来做我们想做的事情。

6224
10:32:24.632 --> 10:32:32.051
我们要做的是在根目录下创建一个新文件，点击这里，新建文件。

6225
10:32:32.051 --> 10:32:38.795
我们称它为helper, hard hat config。j s。

6226
10:32:38.795 --> 10:32:41.212
这就是我们要定义网络配置的地方。

6227
10:32:41.212 --> 10:32:48.056
这里我们会说，如果你在网络上，a，使用这个地址网络，是这个，使用这个地址，等等。

6228
10:32:48.056 --> 10:32:51.264
我们要创建一个叫const的对象。

6229
10:32:51.264 --> 10:32:52.247
网络配置。

6230
10:32:53.379 --> 10:32:55.120
等于我们要在这里加上一堆东西。

6231
10:32:55.379 --> 10:32:58.040
我们现在使用的主要网络是不稳定的。

6232
10:32:58.379 --> 10:33:00.409
链ID是4。

6233
10:33:04.379 --> 10:33:06.083
Rinkeby命名。

6234
10:33:12.379 --> 10:33:16.575
为第eth美元价格提要的B级价格提要地址。

6235
10:33:16.575 --> 10:33:22.009
我们会从文档或GitHub中复制，然后粘贴到这里。

6236
10:33:22.009 --> 10:33:29.772
现在我们有了一个简单的方法来跟踪不同的价格提供不同的合同地址在不同的链。

6237
10:33:29.772 --> 10:33:33.729
举个例子，我们也想部署到Polygon上。

6238
10:33:33.729 --> 10:33:38.361
首先，我们需要什么?我们需要一个多边形的链ID。

6239
10:33:38.361 --> 10:33:42.845
因此，一个快速的小谷歌搜索将我们带到多边形文档。

6240
10:33:42.845 --> 10:33:45.148
我们看到链ID是137。

6241
10:33:45.148 --> 10:33:46.301
所以我用137。

6242
10:33:46.301 --> 10:33:51.231
这里有个小括号，我们写上name polygon。

6243
10:33:51.231 --> 10:33:55.057
然后是逗号，USD，价格供给。

6244
10:33:55.057 --> 10:33:59.036
然后我们将在多边形上添加eth USD的价格饲料。

6245
10:33:59.036 --> 10:34:05.649
docstoc, chain link, polygon或Matic然后我们会查找eth, USD。

6246
10:34:05.649 --> 10:34:08.109
砰，我们看到它就在这里。

6247
10:34:08.109 --> 10:34:11.157
我们抓取了这个地址，然后粘贴进去。

6248
10:34:11.157 --> 10:34:15.625
那硬脑派呢?网络?我们马上就会讲到这个，别担心。

6249
10:34:15.625 --> 10:34:18.661
然后在底部，我们需要导出这个网络配置。

6250
10:34:18.661 --> 10:34:20.864
所以我们的其他脚本可以使用它。

6251
10:34:20.864 --> 10:34:26.396
我们会写module。exports = network config。

6252
10:34:26.396 --> 10:34:35.270
我们将从这个文件中导出一些东西，这就是为什么我们这样做而不是我之前展示的默认方式。

6253
10:34:35.270 --> 10:34:41.317
回到我们的脚本，现在，我们能做什么?首先，我们要导入网络配置。

6254
10:34:41.380 --> 10:34:43.210
所以我们用const。

6255
10:34:47.380 --> 10:34:52.560
我们会导入它，我们会找到目录来帮助我们的Hardhead配置和保存。

6256
10:34:52.560 --> 10:34:57.058
我想再提一遍，这样大家就不会困惑了。

6257
10:34:57.058 --> 10:35:07.960
这里的语法，带花括号的常量网络配置和使用const是一样的。

6258
10:35:07.960 --> 10:35:13.913
Helper config等于这个，这个Helper config是整个文件。

6259
10:35:13.913 --> 10:35:22.080
然后const network config等于Hopper config。network config。

6260
10:35:22.080 --> 10:35:28.822
这个索引是一种简单的方法来推断或从这个文件中提取网络配置。

6261
10:35:28.822 --> 10:35:30.051
这就是它的工作原理。

6262
10:35:30.051 --> 10:35:40.331
这就是为什么我们在底部导出它，这样我们就能做到，请使用GitHub存储库提问和讨论特别是关于JavaScript的东西。

6263
10:35:40.331 --> 10:35:40.822
好了,好了。

6264
10:35:40.822 --> 10:35:47.756
现在我们已经把这个网络配置好了，我们现在可以做这部分，我们说如果中国d z使用一个如果链ID是x使用y。

6265
10:35:47.756 --> 10:35:58.251
因为我们的helper配置很好地符合这种字典，键值对样式，我们能做的是我们可以说const。

6266
10:35:58.251 --> 10:35:59.154
乙美元。

6267
10:35:59.381 --> 10:36:23.781
价格提要地址等于链ID处的网络配置，因为如果Francina D，或者它是这个对象，French entity polygon，它将是这个位于第eth个美元价格提要的对象，我们将把这个保存到第eth个美元价格提要地址。

6268
10:36:23.781 --> 10:36:33.800
现在不管我们在哪个链上，只要我们运行硬帽部署，如果我运行yarn，硬帽部署dash dash network Rinkeby。

6269
10:36:33.800 --> 10:36:35.804
这个链ID是4。

6270
10:36:35.804 --> 10:36:38.881
它会使用这个价格提要地址。

6271
10:36:38.881 --> 10:36:47.181
如果我用破折号测试网络多边形，我记得把环P和多边形都加到网络中，就像这里，通道将是137。

6272
10:36:47.181 --> 10:36:49.523
它将使用这个价格提要地址。

6273
10:36:49.523 --> 10:36:50.729
这太棒了。

6274
10:36:50.729 --> 10:36:52.574
这正是我们想要的。

6275
10:36:52.574 --> 10:37:00.653
但这是我们想要的一切吗?当我在编程和演讲的时候，你们中那些一直在提问的人，你们可能会想，好吧，你谈到了这个标记的事情。

6276
10:37:00.653 --> 10:37:02.834
你谈到了localhost和硬帽。

6277
10:37:02.834 --> 10:37:07.092
我们如何在本地进行测试呢?就像我们如何去测试网和主网。

6278
10:37:07.092 --> 10:37:11.965
但是如果是本地网络呢?这正是我们现在要讨论的。

6279
10:37:11.965 --> 10:37:19.529
我们已经模块化了，我们的代码和参数化了我们的代码这样我们就会使用基于链的地址。

6280
10:37:19.529 --> 10:37:28.610
但如果我们使用一个连价格提要地址都没有的链呢?我们在那里做什么?这就是我们创建模拟契约的地方。

6281
10:37:28.610 --> 10:37:41.088
这里模拟契约的思想是，如果契约不存在，我们为本地测试部署它的最小版本，或者本地测试。

6282
10:37:41.088 --> 10:37:45.982
部署模拟在技术上是一个部署脚本。

6283
10:37:45.982 --> 10:37:59.144
回到deploy文件夹我们要做的是创建一个新文件，命名为00 Dash deploy mocks。js，我们从00开始。

6284
10:37:59.144 --> 10:38:17.106
因为这几乎就像预部署的东西，我们只这样做，有时我们并不总是部署模拟，我们不需要部署模拟到Rinkeby，或polygon或Aetherium主网，因为这些已经有这些价格提要，我们实际上将部署我们自己的模拟价格提要契约。

6285
10:38:17.106 --> 10:38:24.736
在我们的部署Funmi脚本中，我们将使用我们自己的契约，而不是已经建立的契约。

6286
10:38:24.736 --> 10:38:30.333
如果我们是在一个没有任何价格的网络上，那么就很少有合同，比如hard hat或loccos。

6287
10:38:30.382 --> 10:38:32.769
让我们编写部署模拟脚本。

6288
10:38:34.382 --> 10:38:36.801
看起来和我们部署的Funmi几乎一样。

6289
10:38:37.382 --> 10:38:41.043
如果你想把它设置成这样，完全可以。

6290
10:38:41.382 --> 10:38:46.335
我要复制这个，这部分，粘贴到这里，因为初始部分是完全相同的。

6291
10:38:47.382 --> 10:38:54.569
哦，这里，我刚刚意识到我们调用这个网络而没有定义，JavaScript会足够聪明，知道这个网络从哪里来。

6292
10:38:54.569 --> 10:38:56.303
但这可能会让人有点困惑。

6293
10:38:56.303 --> 10:39:00.244
所以最好是显式的，用const。

6294
10:39:00.244 --> 10:39:06.230
网络等于需要安全帽，这个网络的东西来自安全帽。

6295
10:39:06.230 --> 10:39:08.262
我们要抓住这条线。

6296
10:39:08.262 --> 10:39:11.398
我们也会在脚本的顶部使用它。

6297
10:39:11.398 --> 10:39:22.462
上面部分看起来也一样抓取这三行，粘贴到deploydeployer chain ID，这里都是一样的，因为我们准备部署一些东西。

6298
10:39:22.462 --> 10:39:24.811
现在我们要部署一个新契约。

6299
10:39:24.811 --> 10:39:28.335
但如果我们看看我们的合同文件夹，这是我们现在所有的。

6300
10:39:28.383 --> 10:39:33.383
我们需要将这个mock这个假合约添加到合约文件夹中。

6301
10:39:33.383 --> 10:39:42.317
现在我们能做的是，在合约文件夹中，我们想把这个文件和其他文件分开这样我们就知道，这不是项目的一部分，但它是测试的一部分。

6302
10:39:42.317 --> 10:39:44.859
右键点击创建新文件夹。

6303
10:39:44.859 --> 10:39:49.856
我们可以叫它mocks，或者test，我喜欢叫它test。

6304
10:39:49.856 --> 10:39:59.814
在这个文件夹中，我们可以右键创建一个新文件，我要创建一个新文件，命名为mock, v3聚合，撕下那个灵魂。

6305
10:39:59.814 --> 10:40:06.037
这就是我们自己定义模拟价格提要聚合器的地方。

6306
10:40:06.037 --> 10:40:26.261
那么我们如何创建自己的假价格饲料合同，以便在本地测试一切呢?我们能做的一件事是去链接GitHub回购，浏览合同找到其中一个价格反馈地址，源8，或者我们会回到源我们可能会检查v6。

6307
10:40:26.383 --> 10:40:35.334
看起来我们可以找到一些东西，四处看看然后复制粘贴所有这些代码，但复制所有这些代码看起来真的很痛苦。

6308
10:40:35.383 --> 10:40:40.103
现在我们完全可以复制粘贴代码到这里，但我们要做一些更聪明的事情。

6309
10:40:40.103 --> 10:40:43.487
链式回购实际上有一些模仿。

6310
10:40:43.487 --> 10:40:47.002
如果我们看合约，SRC V 0。

6311
10:40:47.002 --> 10:40:55.932
他们实际上有一个模拟v3 aggregator。soul在这里，我们可以使用我们的模拟。

6312
10:40:55.932 --> 10:41:02.250
我们可以复制粘贴所有东西，但我们需要修改一点因为它在做点。点的东西。

6313
10:41:02.250 --> 10:41:08.980
它与文件结构中本地的其他契约进行通信而这些契约不会在我们的文件结构中。

6314
10:41:08.980 --> 10:41:19.746
相反，我们能做的是利用这个节点模块包，我们可以说pragma, solidity，胡萝卜0，点6。

6315
10:41:19.746 --> 10:41:22.867
0，我们将使用那个包正在执行的相同版本。

6316
10:41:22.867 --> 10:41:30.600
然后在链上导入/收缩/ SRC / v0。

6317
10:41:30.600 --> 10:41:30.716
6.

6318
10:41:30.716 --> 10:41:37.437
斜杠测试斜杠嘲笑，B，三蛋，Reg，基佬撕裂了灵魂。

6319
10:41:37.437 --> 10:41:44.860
然后我们会添加，当然，我们会添加spdx，许可标识符，MIT。

6320
10:41:44.860 --> 10:41:47.867
这就是我们所需要的。

6321
10:41:47.867 --> 10:42:02.203
如果我们像这样导入代码，请记住，这与复制粘贴这个契约到我们的项目完全相同，当然，这个路径解析指向它在节点模块中的实际位置。

6322
10:42:02.203 --> 10:42:08.018
现在，实际上，我可以运行纱线硬帽编译，它也会编译这个合同。

6323
10:42:08.018 --> 10:42:13.384
当然，我们有一个问题，编译器版本不匹配。

6324
10:42:13.384 --> 10:42:24.005
对吧?这是怎么回事呢，你们将会遇到这样的情况，你们将会与合同工作，这与你们的可靠性不一样，因为合同一直在部署。

6325
10:42:24.005 --> 10:42:27.385
在版本0中有大量的契约。

6326
10:42:27.385 --> 10:42:28.940
4、固体度0。

6327
10:42:28.940 --> 10:42:29.273
5 0。

6328
10:42:29.273 --> 10:42:35.488
678，或者910亿，或者150亿，或者以后会有多少个固体版本。

6329
10:42:35.488 --> 10:42:42.654
在配置中，在hard hat。config中，滚动到底部时，我们可以滚动到定义固体度版本的地方。

6330
10:42:42.654 --> 10:42:50.000
我们可以添加多个固体版本，这样我们的编译器就能编译多个固体版本。

6331
10:42:50.000 --> 10:42:52.846
为了做到这一点，我们会说，Lyd, T。

6332
10:42:52.846 --> 10:42:57.150
我们会把它变成一个对象，我们会在这里加上逗号。

6333
10:42:57.150 --> 10:43:03.352
在我们的solidity对象中，我们会放入编译器我们会有一个编译器列表。

6334
10:43:03.352 --> 10:43:07.035
第一个是0点8点。

6335
10:43:07.035 --> 10:43:07.085
8.

6336
10:43:07.085 --> 10:43:10.255
第二个版本是0。

6337
10:43:10.255 --> 10:43:15.190
6，点6，然后保存。

6338
10:43:15.385 --> 10:43:17.723
我想把它格式化成这样，这很好。

6339
10:43:17.723 --> 10:43:25.623
现在，我们可以继续，重新运行，yarn, Hardhead，编译，然后成功编译了五个固体文件。

6340
10:43:25.623 --> 10:43:29.333
这意味着我们的Mark V聚合器也应该被编译。

6341
10:43:29.385 --> 10:43:37.978
如果我们看工件，在链链，确实看到这个在链链斜杠合同斜杠SRC投标，和一个v0。

6342
10:43:37.978 --> 10:43:38.045
6.

6343
10:43:38.045 --> 10:43:42.237
在测试中，我们看到这个模拟聚合器。soul，它已经编译过了。

6344
10:43:42.237 --> 10:43:42.761
太棒了。

6345
10:43:42.761 --> 10:43:51.729
现在我们已经编译了模拟契约，现在我们有了一个契约，可以用来将假价格提要部署到区块链。

6346
10:43:51.729 --> 10:43:57.051
那么我们要怎么做呢?这和我们在Funmi合约上的做法是一样的。

6347
10:43:57.051 --> 10:44:15.652
这里我们要添加一个if语句，我们不想把这个模拟合约部署到一个测试网络或一个有价格feed的网络上，我们可以这样做，如果链ID不等于某个链ID，然后部署标记。

6348
10:44:15.652 --> 10:44:17.736
这是一种伪代码。

6349
10:44:17.736 --> 10:44:19.174
显然，这段代码实际上无法工作。

6350
10:44:19.174 --> 10:44:31.756
相反，我喜欢的是指定哪些链将是我的开发链，哪些链将是我可以部署这些模拟到的链，在我的助手，hard hat配置中，我会定义这些链。

6351
10:44:31.756 --> 10:44:41.233
我写上const，开发链，等于，然后我写上hard hat，和本地主机。

6352
10:44:41.233 --> 10:44:43.368
我要导出这些。

6353
10:44:43.368 --> 10:44:49.450
回到我的deploy模拟中，我将用const导入它们。

6354
10:44:49.450 --> 10:44:57.336
开发链等于require。dot。slash helper Hardhead config。

6355
10:44:57.336 --> 10:45:05.558
现在我要说if development chains。includes chain ID。

6356
10:45:05.558 --> 10:45:16.519
这个includes keyword基本上是一个检查变量是否在数组内的函数，然后我们会继续部署Max，这就是我们想要做的。

6357
10:45:16.519 --> 10:45:21.052
我们会做log，这是从部署中得到的，基本上是console。log。

6358
10:45:21.052 --> 10:45:28.198
我们会说本地网络检测到，部署模拟。

6359
10:45:28.386 --> 10:45:38.812
我们会做一个权值策略，我们会部署我们新的模拟v3聚合器模拟v3聚合器会做一个逗号。

6360
10:45:38.812 --> 10:45:40.955
这里有个冒号。

6361
10:45:40.955 --> 10:45:53.290
如果我们想要更具体，我们可以说契约v3聚合器我们已经说过了我们会说从部署者我们会说日志记录是真的。

6362
10:45:53.387 --> 10:46:04.111
然后我们需要传递一些参数，我们需要传递模拟v3聚合器的构造函数参数，这是什么?好吧，让我们去docs chain去寻找答案。

6363
10:46:04.111 --> 10:46:13.340
或者您也可以直接访问Node modules chainlink, SRC v06, tests，然后一直到mock v3，聚合出来。

6364
10:46:13.387 --> 10:46:24.587
你也可以在这里找到构造函数，无论你喜欢哪个，有时我发现更容易读GitHub Ctrl + F或Command + F作为构造函数。

6365
10:46:24.587 --> 10:46:28.264
我们看到它需要一个小数和一个初值。

6366
10:46:28.264 --> 10:46:40.323
如果我们通读这段代码，我们就会知道小数对象等价于小数参数等价于小数函数和初始结果。

6367
10:46:40.387 --> 10:46:50.269
最初的答案基本上就是价格提要从什么开始，我们实际上要选择价格提要的价格，这很好，因为这很适合测试。

6368
10:46:50.269 --> 10:46:56.762
我通常喜欢把小数和初值定义在函数之外的地方这样我以后就可以用到它了。

6369
10:46:56.762 --> 10:47:00.967
你可以在我们的助手Hardhead配置中再次添加它。

6370
10:47:00.967 --> 10:47:01.160
js。

6371
10:47:01.160 --> 10:47:05.224
我可以用常量小数= 8。

6372
10:47:05.224 --> 10:47:09.490
然后const初始答案。

6373
10:47:09.490 --> 10:47:14.610
等于，我们用2000。

6374
10:47:14.610 --> 10:47:23.845
既然我们有小数，我们用2000，然后是123456788小数点位，然后我们也导出这些。

6375
10:47:23.845 --> 10:47:26.683
导出小数，并导出初始应答。

6376
10:47:26.683 --> 10:47:34.388
当然，我们可以，你知道，const小数在上面等于8然后初始答案，然后在下面用它们。

6377
10:47:34.388 --> 10:47:35.998
但我喜欢这样做。

6378
10:47:35.998 --> 10:47:36.608
所以让步。

6379
10:47:36.608 --> 10:47:39.184
现在我们要把它们导入这里。

6380
10:47:39.388 --> 10:47:40.911
Const开发链。

6381
10:47:40.911 --> 10:47:42.625
还有小数点。

6382
10:47:43.388 --> 10:47:45.814
获取了初始答案，我们将保存它。

6383
10:47:47.388 --> 10:47:50.165
构造函数看起来先写小数，再写初值。

6384
10:47:50.165 --> 10:47:55.638
在论证中，我们先做小数，再做初解，等等。

6385
10:47:55.638 --> 10:48:00.574
然后我们就完成了我们会做一个快速的日志箱部署。

6386
10:48:00.574 --> 10:48:09.084
然后，我还喜欢在所有部署脚本的末尾加一行，就像，嘿，部署脚本结束了。

6387
10:48:09.084 --> 10:48:12.557
在此之后的其他内容将是一个不同的部署脚本。

6388
10:48:12.557 --> 10:48:13.421
好的，很好。

6389
10:48:13.421 --> 10:48:15.888
现在我们部署的模拟脚本实际上已经完成。

6390
10:48:15.888 --> 10:48:18.472
但是我们的部署Funmi脚本还没有完全完成。

6391
10:48:18.472 --> 10:48:24.077
有没有一种方法可以让我们只运行部署模拟脚本?嗯，是的，有。

6392
10:48:24.077 --> 10:48:25.581
很好，谢谢关心。

6393
10:48:25.581 --> 10:48:37.441
我们可以在部署模拟脚本的底部做的是，添加一个导出点标记(=)的模块，我们将写入all和marks。

6394
10:48:37.441 --> 10:48:46.286
现在我们能做的是如果我们运行yarn, hardhat deploy，我们可以添加这个标志。

6395
10:48:46.388 --> 10:48:50.325
它将只运行具有特殊标记的部署脚本。

6396
10:48:50.388 --> 10:48:56.629
因此，我们将运行mock标记，这意味着它将只运行部署模拟脚本。

6397
10:48:56.629 --> 10:49:03.323
哦，实际上，在我们的助手配置开发链中是硬帽和localhost。

6398
10:49:03.389 --> 10:49:15.158
我说，我们要用链ID来做，抱歉，我们要这样做，我们要用development chains。includes network。name。

6399
10:49:15.389 --> 10:49:24.948
因为我们的helper配置使用的是名称而不是链id，所以如果开发链包含网络名称，那么我们将继续部署模拟。

6400
10:49:24.948 --> 10:49:28.711
让我们继续，运行这个故事点击部署破折号标签，mocks。

6401
10:49:28.711 --> 10:49:32.660
完美的是，我们确实看到我们的模拟被部署在这里。

6402
10:49:32.660 --> 10:49:36.839
这个对数为真意味着它会吐出这样的东西。

6403
10:49:36.839 --> 10:49:48.389
它会说契约，它正在部署，它正在进行的事务它会说它被部署在哪里，有多少气体，这意味着我们部署的Mach脚本运行得很好。

6404
10:49:48.389 --> 10:49:51.503
现在我们的部署模拟脚本已经完美地工作了。

6405
10:49:51.503 --> 10:49:57.339
那么我们如何将其应用到部署Funmi脚本中呢?我们在这里也要做同样的事。

6406
10:49:57.389 --> 10:50:05.889
我们不会让eth USD price feed address为常量，我们会说let at USD price you'd variable这样我们就能更新它。

6407
10:50:05.889 --> 10:50:21.353
我们会说，如果development chains。include network。name，我们可以用hardhat deploy做的是我们可以用一个叫get的命令获取最新的部署。

6408
10:50:21.353 --> 10:50:22.686
所以我们用const。

6409
10:50:22.686 --> 10:50:29.068
eth USD聚合器= await deployment dot get。

6410
10:50:29.068 --> 10:50:41.441
然后是我们部署的Mach v3聚合器的合约名称，如果你想用get代替deployment。get，我们完全可以，只需要这样做。

6411
10:50:41.441 --> 10:50:43.176
它们完全一样。

6412
10:50:43.176 --> 10:50:54.491
我们会得到这样的地址然后我们会说eth USD价格提要地址等于那个eth USD聚合器合约。address。

6413
10:50:54.491 --> 10:51:02.675
然后如果我们不在开发链上，如果我们没有部署一个mock，我们只会做我们之前做过的事情。

6414
10:51:02.675 --> 10:51:04.873
使用网络配置。

6415
10:51:04.873 --> 10:51:06.163
哦，我的天哪。

6416
10:51:06.163 --> 10:51:15.159
现在，我们已经完成了所有这些步骤，让我们在底部添加一个小的log东西，只有一些连字符。

6417
10:51:15.159 --> 10:51:28.523
现在，我们应该有一个非常健壮的脚本，可以在本地开发链、测试网链和主网链之间切换，并允许我们在不改变任何稳定性的情况下部署到任何地方。

6418
10:51:28.523 --> 10:51:35.323
然后我们用这个，这个USD价格输入地址，把它写进日志里。

6419
10:51:35.323 --> 10:51:45.439
然后在底部，我们可以做module。exports。tags =然后我们做所有的然后我们把这个叫做Funmi。

6420
10:51:45.439 --> 10:51:47.406
现在是关键时刻了。

6421
10:51:47.406 --> 10:51:52.898
如果我们都做到了，对吧，我们应该就能运行纱线，戴上安全帽。

6422
10:51:52.898 --> 10:51:57.644
它应该适用于我们的本地连锁店，我们的安全帽连锁店。

6423
10:51:57.644 --> 10:52:00.881
它应该也适用于我们提供的任何测试网。

6424
10:52:00.881 --> 10:52:02.635
让我们试一试。

6425
10:52:02.635 --> 10:52:04.178
纱，硬头部署。

6426
10:52:04.390 --> 10:52:05.622
让我们看看这是否有效。

6427
10:52:05.622 --> 10:52:06.050
太棒了。

6428
10:52:07.390 --> 10:52:15.325
部署到我们的硬帽网络，我们可以看到我们继续部署了模拟，我们在这里画了下划线。

6429
10:52:15.390 --> 10:52:18.999
然后我们部署了福米在这个地址部署了这么多毒气。

6430
10:52:18.999 --> 10:52:32.669
那么，关于安全帽部署还有什么了不起的地方呢?当我们运行我们的本地区块链，我们自己的区块链节点时，硬帽部署将自动运行所有的部署脚本并将它们添加到我们的节点。

6431
10:52:32.669 --> 10:52:43.046
现在如果我运行yarn, hard hat node，我们会自旋一个新的区块链节点，但它上面已经有所有已部署的契约。

6432
10:52:43.046 --> 10:52:51.100
每次我们旋转一个局部节点，它就会自动打包我们想要的契约。

6433
10:52:51.100 --> 10:52:55.817
我们将在林克比的一个测试网上演示这个过程。

6434
10:52:55.817 --> 10:53:03.950
但在我们在Rinkeby上进行测试之前，我要在这里添加一点自动验证，因为我们在上节课中做过。

6435
10:53:03.950 --> 10:53:07.079
我们也想展示如何在硬帽部署中做到这一点。

6436
10:53:07.079 --> 10:53:21.132
在我们部署Funmi之后，我们可以做类似的事情，我们会说，如果开发者链包含network。name，我们会说，如果开发者链不包含network。name，因为我们不想在本地网络上进行验证。

6437
10:53:21.132 --> 10:53:31.505
我们会说if not development chains。包括network。name，感叹号，也就是bang的意思是not当我们谈论布尔值时。

6438
10:53:31.505 --> 10:53:39.644
所以我们说，如果网络的名字不是开发链，我们想继续验证，和上次一样。

6439
10:53:39.644 --> 10:53:48.907
如果process。env。ether扫描API key，我们就会继续验证。

6440
10:53:48.907 --> 10:53:54.754
在我们有验证代码之前，在我们的部署代码中，我们要做一些不同的事情。

6441
10:53:54.754 --> 10:54:03.572
这里的部署脚本中没有验证代码，我们实际上要创建一个名为utils的新文件夹，它代表实用程序。

6442
10:54:03.572 --> 10:54:08.646
这就是我们要添加不同脚本的地方我们可以在不同的部署中使用。

6443
10:54:08.646 --> 10:54:23.582
因为假设我们有50个Deploy脚本，我们不会创建50个Deploy函数，我们只会将它们添加到utils文件夹，在utils文件夹中，或者创建一个名为verify。js的新文件，我们会将上一个项目的代码添加到这里。

6444
10:54:23.582 --> 10:54:31.002
如果你愿意，你可以从上一个项目复制粘贴到这个项目，或者你可以暂停视频自己打出来。

6445
10:54:31.002 --> 10:54:36.900
因为我们在这里使用的是run命令，我们将执行const run = require RT hat。

6446
10:54:36.900 --> 10:54:44.642
然后在底部，我们会做模块导出。

6447
10:54:44.642 --> 10:54:48.079
导出等于验证。

6448
10:54:48.392 --> 10:54:56.860
现在我们在utils文件夹中有了一个验证脚本，回到deploy Funmi中我们将写入const。

6449
10:54:56.860 --> 10:55:00.642
验证= require。dot。slash utils。

6450
10:55:00.642 --> 10:55:01.725
削减验证。

6451
10:55:01.725 --> 10:55:10.206
因为现在在我们的验证Jas中，我们有很多trycatch的东西，我们可以做一个等待。

6452
10:55:10.206 --> 10:55:17.497
Verify和Verify再次接受契约地址和参数列表。

6453
10:55:17.497 --> 10:55:24.004
我们写入await verify, fundme。address然后是参数列表。

6454
10:55:24.004 --> 10:55:26.737
为了使参数列表更容易输入。

6455
10:55:26.737 --> 10:55:42.806
你可以输入const args，等于然后我们会把我们的eth USD price feed放在这里然后用args替换这个然后把这个args放到下面的第二个参数中。

6456
10:55:42.806 --> 10:55:44.564
好的，很好。

6457
10:55:44.564 --> 10:55:54.496
现在让我们把它部署到Rinkeby测试网中，我们需要什么来部署到Rinkeby测试网中呢?好吧，让我们先进入我们的安全帽配置。

6458
10:55:54.496 --> 10:56:01.554
清理一下，我们不需要这个账户任务，我删掉它，我不需要这个注释。

6459
10:56:01.554 --> 10:56:03.102
我把这个也删掉。

6460
10:56:03.102 --> 10:56:07.345
让我们进入网络部分，我们不会使用ropsten。

6461
10:56:07.345 --> 10:56:09.154
所以我们要把它扔掉。

6462
10:56:09.154 --> 10:56:15.651
然而，我们将使用溜冰场B, URL将是相同的Rinkeby RPC URL。

6463
10:56:15.651 --> 10:56:19.500
我们将在这里定义它，就像我们之前做的那样。

6464
10:56:19.500 --> 10:56:37.309
如果你想从上一个项目复制粘贴，请随意，你也可以跟着我或者快进，计数是一样的。

6465
10:56:37.309 --> 10:56:42.293
我要复制粘贴之前的气体报告器。

6466
10:56:42.293 --> 10:56:50.151
所以我们要加上这个恒定的玉米市值API关键值等于过程。EMV。玉米市值API关键值。

6467
10:56:50.151 --> 10:56:56.952
对以太扫描API键Licious做同样的事情，把所有东西都添加到这里。

6468
10:56:56.952 --> 10:56:57.426
现在。

6469
10:56:57.426 --> 10:57:07.342
我们已经有了以太扫描部分，我们要让气体报告器为假，因为我现在真的不想用它。

6470
10:57:07.393 --> 10:57:10.343
最后，我们要在这里再加一个东西。

6471
10:57:10.393 --> 10:57:15.308
记得在我们上一个项目中，在我们实际验证之前，我们等待一些块确认。

6472
10:57:15.308 --> 10:57:18.020
这样，乙醚扫描就能确保赶上进度。

6473
10:57:18.020 --> 10:57:32.073
我们可以在hard hat。config中做同样的事情，我们可以为每个测试网添加一个区域来决定我们要等待多少块，我将添加6个块确认。

6474
10:57:32.073 --> 10:57:34.827
现在回到我们的部署Funmi。

6475
10:57:34.827 --> 10:57:43.875
在一个新的部分，我可以添加等待确认的网络点配置。

6476
10:57:43.875 --> 10:57:57.329
那块上的运动，或一个是或一个意味着如果没有块确认，在我们的Hardhead点配置将只等待一个块。

6477
10:57:57.394 --> 10:58:04.092
同样，我们想要等待大约6个区块确认的原因是我们想给以太扫描一个索引我们的交易的机会。

6478
10:58:04.092 --> 10:58:07.853
我添加了一个链ID 42，当它应该是我的错误。

6479
10:58:07.853 --> 10:58:18.590
当然，我们需要我们的。env文件，在那里我们添加了我们从上一个会话的所有东西，RIP ERP CRL私钥以太扫描API，然后是硬币市值API。

6480
10:58:18.590 --> 10:58:20.294
好了，关键时刻。

6481
10:58:20.294 --> 10:58:21.539
我们来试试这个。

6482
10:58:21.539 --> 10:58:28.672
如果我们运行纱线Hardhead部署破折号网络Rinkeby。

6483
10:58:28.672 --> 10:58:35.213
它不应该部署任何标记，因为在模拟部署中有这个if语句。

6484
10:58:35.213 --> 10:58:41.071
但它应该使用正确的价格提要地址部署我们的Funmi合同。

6485
10:58:41.071 --> 10:58:43.519
然后它会继续进行验证。

6486
10:58:43.519 --> 10:58:52.139
由于我们在等待六个区块的确认，我们甚至可以通过添加破折号标签和运行资金标签来超级安全。

6487
10:58:52.139 --> 10:58:56.306
但我们只打算做纱线部署网络Rigby。

6488
10:58:56.306 --> 10:58:58.201
让我们看看会发生什么。

6489
10:58:58.201 --> 10:59:00.855
好的，我们正在部署资金。

6490
10:59:00.855 --> 10:59:09.895
我们可以看到Funmi的事务，这是日志功能，部署Funmi时日志是true。

6491
10:59:09.895 --> 10:59:17.093
一旦它有了交易，它就会给我们交易，一旦我们有了地址，它就会给我们地址。

6492
10:59:17.093 --> 10:59:22.463
所以我们要等6个区块确认，让这个交易完成。

6493
10:59:22.463 --> 10:59:26.795
现在我们看到我们已经用X数量的天然气部署了这个合同地址。

6494
10:59:26.795 --> 10:59:29.233
现在我们正在进行验证程序。

6495
10:59:29.233 --> 10:59:39.775
在验证过程中，我们可以打开瑞克比以太扫描，把我们的地址贴在这里，看看我们确实创建了这份合同。

6496
10:59:39.775 --> 10:59:43.791
现在看来我们已经通过以太扫描成功验证了合同。

6497
10:59:43.791 --> 10:59:48.767
因此，如果我们点击刷新，我们确实可以看到契约已经得到验证。

6498
10:59:48.767 --> 10:59:49.309
太棒了。

6499
10:59:49.309 --> 10:59:49.986
好吧。

6500
10:59:49.986 --> 10:59:51.245
这太棒了。

6501
10:59:51.245 --> 11:00:05.655
我们的部署脚本看起来很棒，我们能够部署到本地链，我们能够部署到测试，如果我们想，我们可以部署到任何我们想要的网络，只需要更新我们的硬帽配置，然后更新我们的助手配置。

6502
11:00:05.655 --> 11:00:07.220
这太棒了。

6503
11:00:07.395 --> 11:00:09.153
到目前为止做得很好。

6504
11:00:13.395 --> 11:00:13.868
我们的测试。

6505
11:00:16.395 --> 11:00:20.179
我们的Funmi合同，让它看起来更专业一点。

6506
11:00:20.179 --> 11:00:24.854
我会讲一些语法以及一些惯例存在的原因。

6507
11:00:24.854 --> 11:00:29.331
我们不会对所有的项目都这么做。

6508
11:00:29.395 --> 11:00:34.569
但是知道这些是很好的，并且在我们继续工作和处理我们的合同时最好记住它们。

6509
11:00:34.569 --> 11:00:41.084
在我们学习的过程中，我们将学习为什么这些约定会存在包括学习一些低水平的固体性。

6510
11:00:41.084 --> 11:00:42.264
所以不要跳过这部分。

6511
11:00:42.264 --> 11:00:43.789
当我们讲到后面的部分时。

6512
11:00:43.789 --> 11:00:50.508
我们会稍微宽松一点，对代码样式指南不那么严格，但这基本上是我们现在要讲的。

6513
11:00:50.508 --> 11:00:57.953
现在，你可能会在这里看到这个事件资助的东西，请暂时忽略它，在之前的例子中，我很早之前就介绍了这些事件。

6514
11:00:57.953 --> 11:01:01.248
现在我们将在后面的课程中学习事件。

6515
11:01:01.248 --> 11:01:04.067
所以现在请忽略这个资助的活动。

6516
11:01:04.067 --> 11:01:06.525
我们来稍微调整一下契约。

6517
11:01:06.525 --> 11:01:17.879
现在我说的是调整它，让它看起来更专业一点，更专业一点，我说的是固体风格指南，有一些命名和排序的约定，我们可以遵循，让我们的代码看起来更好一点。

6518
11:01:17.879 --> 11:01:23.002
现在，就像我说的，这将是一点可选的，因为它可能有点啰嗦。

6519
11:01:23.002 --> 11:01:25.753
这并没有太大的区别。

6520
11:01:25.753 --> 11:01:30.750
但是它可以大大提高契约的可读性，使代码看起来更好。

6521
11:01:30.750 --> 11:01:38.157
所以，如果你想，你可以通过这个风格指南，了解更多关于什么类型的固体看起来很好，什么使它看起来不好。

6522
11:01:38.157 --> 11:01:42.819
但是，这是这里的一些风格指南，我们不会完全遵循风格指南。

6523
11:01:42.819 --> 11:01:52.707
但我们会尽最大努力让代码遵循样式指南，我们在GitHub仓库中有样式指南的链接，这一节我们可以读到更多关于布局的内容。

6524
11:01:52.707 --> 11:02:01.348
但我们主要想看的是布局的顺序，我们想从导入开始有pragma语句，导入，接口，库，然后是契约。

6525
11:02:01.348 --> 11:02:06.576
然后在每个契约类型声明、状态变量、事件、修饰符和函数内部。

6526
11:02:06.576 --> 11:02:11.706
回到这里，确保我们跟上了进度，我们先要pragma。

6527
11:02:11.706 --> 11:02:15.936
很好，我们确实做到了，然后我们需要导入。

6528
11:02:15.936 --> 11:02:17.814
好的，太棒了，我们也有。

6529
11:02:17.814 --> 11:02:22.735
样式指南中没有的是错误代码，这是我们接下来需要的。

6530
11:02:22.735 --> 11:02:25.701
接下来是错误代码。

6531
11:02:25.701 --> 11:02:30.052
现在我们将在这里遇到我们的第一个更新。

6532
11:02:30.052 --> 11:02:37.350
最近，添加合同名称、一些下划线以及错误名称已经成为一种最佳实践。

6533
11:02:38.397 --> 11:02:39.672
当你遇到错误的时候。

6534
11:02:40.397 --> 11:02:44.328
更容易理解哪个合约抛出了错误。

6535
11:02:44.397 --> 11:02:53.708
对于这个，我们会说error Funmi, two下划线not owner，然后我们会向下滚动到我们的revert，设置成这样。

6536
11:02:53.708 --> 11:03:03.724
这样，当我们遇到这个错误时，我们就知道错误来自Funmi契约，而不是来自聚合器v3接口、价格转换器或其他契约。

6537
11:03:03.724 --> 11:03:06.397
这就是我们要写错误代码的方式。

6538
11:03:06.397 --> 11:03:10.227
如果我们有任何没有导入的接口或库，我们将在这里添加它们。

6539
11:03:10.227 --> 11:03:12.708
最后，我们加入契约。

6540
11:03:12.708 --> 11:03:15.593
在这个文件中，我们只有一个合同。

6541
11:03:15.593 --> 11:03:16.773
这是我们的Funmi合同。

6542
11:03:16.773 --> 11:03:17.166
太棒了。

6543
11:03:17.166 --> 11:03:22.563
现在我们要学习的下一件事，就样式指南而言，是这个叫做natspec的东西。

6544
11:03:22.563 --> 11:03:27.708
natspec是以太自然语言规范格式的缩写。

6545
11:03:27.708 --> 11:03:41.052
它基本上是一种记录我们的代码的方法，受Doxygen的启发，使用Doxygen风格的注释和标签来帮助记录我们的代码，你可以点击这里的链接在固体文档了解更多关于Doxygen的信息。

6546
11:03:41.052 --> 11:03:45.167
如果我们向下滚动文档，在这里，我们可以看到一个使用natspec的示例。

6547
11:03:45.167 --> 11:03:51.968
每当我们有一个需要文档的契约或函数时，我们可以向它添加一些如下所示的语法。

6548
11:03:51.968 --> 11:04:07.053
举个例子，如果我们想把这个添加到代码中，我们可以添加一个注释来解释这个融资合同来开始一个natspec，你可以用三个反斜杠，或者一个反斜杠，两颗星，然后在这里再加一个结束星。

6549
11:04:07.053 --> 11:04:11.955
我们放在这个评论区的所有东西基本上都变成了评论。

6550
11:04:11.955 --> 11:04:25.064
在合同的开始，我们会用Add符号来解释，这个合同是什么，它很有趣，我们的合同将是一个众筹合同，我们会再加一颗星。

6551
11:04:25.064 --> 11:04:42.898
我们可以加上它的作者，也就是你的名字，当然我要写上帕特里克·柯林斯，然后我们会加上一个通知，这是给人们的一种提示我们可以说这个合同是演示一个样本融资合同。

6552
11:04:42.898 --> 11:04:49.064
我们还可以添加apt Dev，这是专门针对开发人员的说明。

6553
11:04:49.064 --> 11:04:52.785
我们可以说这实现了价格提要作为我们的库。

6554
11:04:52.785 --> 11:05:11.017
我们想在这里添加这些标记的原因实际上是因为我们可以使用natspec自动为我们创建文档，如果我们下载，那么我们可以实际运行solc dash的user doc, dash dash dev doc，和我们的文件名来自动生成文档。

6555
11:05:11.017 --> 11:05:17.512
因此，这对于以后与协议交互的其他开发人员自动创建文档也非常有帮助。

6556
11:05:17.512 --> 11:05:21.725
你可以使用这个natspec来实现任意多或任意少的函数。

6557
11:05:21.725 --> 11:05:24.698
我们中的大多数人可能不会制作文档。

6558
11:05:24.698 --> 11:05:31.914
因此，如果我们认为某些函数或代码的某些部分对其他开发人员来说有点棘手，我们就会遵循这些指导原则。

6559
11:05:31.914 --> 11:05:35.347
既然已经在合同内了，我们就可以按照合同的顺序行事了。

6560
11:05:35.347 --> 11:05:47.212
我们首先从类型声明开始，我们实际上没有任何类型声明，除非我们使用的是UN 256类型的价格转换器。

6561
11:05:47.212 --> 11:05:48.228
好了,好了。

6562
11:05:48.399 --> 11:05:52.136
接下来，在我们的类型声明之后，我们要做状态变量。

6563
11:05:52.136 --> 11:05:58.217
在这个状态变量部分，我们要改变一些状态变量的名称。

6564
11:05:58.217 --> 11:06:00.989
这里我们用一些常见的状态函数。

6565
11:06:00.989 --> 11:06:09.711
在实度样式指南中，有点坚持命名样式，我们用大写字母和小写字母，我们用大写字母加下划线。

6566
11:06:09.711 --> 11:06:13.617
但是，这些命名变量将在以后的本节中进行更改。

6567
11:06:13.617 --> 11:06:19.722
如果你看的是和这门课相关的GitHub回购，这些会和你看到的有些不同。

6568
11:06:19.722 --> 11:06:25.449
然而，现在，我们将让它们保持原样，因为我们要改变它们的原因还不是很清楚。

6569
11:06:25.449 --> 11:06:26.049
别担心。

6570
11:06:26.049 --> 11:06:29.229
所以这些名字很快就会改变，但不是现在。

6571
11:06:29.229 --> 11:06:32.664
好的，在状态变量之后是事件和修饰语。

6572
11:06:32.664 --> 11:06:35.589
我们没有任何事件，但我们有一个修饰语。

6573
11:06:35.589 --> 11:06:37.096
我们复制这个。

6574
11:06:37.096 --> 11:06:41.349
实际上，我们把这条注释删掉。

6575
11:06:41.349 --> 11:06:45.250
然后粘贴修改器到这里。

6576
11:06:45.250 --> 11:06:50.127
对了，看起来好像我们这里没有自动格式化。

6577
11:06:50.127 --> 11:06:53.870
我们要取消注释不可变，它会自动自动格式化。

6578
11:06:53.870 --> 11:06:54.549
好了,好了。

6579
11:06:54.549 --> 11:06:55.927
我们现在没有格式了。

6580
11:06:55.927 --> 11:06:56.266
和酷。

6581
11:06:56.266 --> 11:06:57.999
现在我们有了修饰语。

6582
11:06:57.999 --> 11:07:02.418
接下来，我们在这里，然后我们有所有的函数。

6583
11:07:02.418 --> 11:07:02.888
太好了。

6584
11:07:02.888 --> 11:07:07.624
我们实际上想要把函数按我刚才打印的顺序分组。

6585
11:07:07.624 --> 11:07:12.721
我们想要的构造函数是我们已经接收并返回的，我们确实有回落和接收。

6586
11:07:12.721 --> 11:07:17.161
我们要复制这些，然后删除这个注释。

6587
11:07:17.161 --> 11:07:23.111
我们要让那些退伍军人希斯看起来像是先接球的。

6588
11:07:23.111 --> 11:07:24.722
我们把它写在这里。

6589
11:07:24.722 --> 11:07:29.238
然后是外部功能，然后是公共功能，内部功能，私人功能。

6590
11:07:29.400 --> 11:07:30.685
我们有public public。

6591
11:07:30.685 --> 11:07:31.435
就是这样。

6592
11:07:32.400 --> 11:07:34.193
把下面这部分删掉。

6593
11:07:34.193 --> 11:07:34.537
好的。

6594
11:07:34.537 --> 11:07:34.881
酷。

6595
11:07:36.400 --> 11:07:40.336
我们可以在函数的网络规范中使用这种语法。

6596
11:07:40.400 --> 11:07:53.976
例如，对于资助它，我们甚至可以复制粘贴，我们会删除标题，我们会删除作者，我们只说添加，注意，这个功能，资助这个合同。

6597
11:07:53.976 --> 11:07:57.867
我们甚至可以在这里留下一些关于开发的内容。

6598
11:07:57.867 --> 11:08:00.866
如果我们有参数，你可以做apt puram。

6599
11:08:00.866 --> 11:08:03.305
比如参数是什么。

6600
11:08:03.305 --> 11:08:11.096
然后如果我们有返回，我们可以说返回，或者返回，然后它为文档返回什么。

6601
11:08:11.096 --> 11:08:15.835
因为这里没有任何参数，也不返回任何东西，我们可以让它像这样。

6602
11:08:15.835 --> 11:08:20.368
很好，我们刚刚修改了我们的合同使它的格式更漂亮。

6603
11:08:20.368 --> 11:08:20.836
伟大的工作。

6604
11:08:20.836 --> 11:08:26.945
现在，就像我说的，我们实际上要改变状态函数的名称，我们要在这里添加一些函数。

6605
11:08:26.945 --> 11:08:32.061
如果我们跟随GitHub回购，现在契约的状态看起来会有点不同。

6606
11:08:32.061 --> 11:08:37.127
但这就说得通了为什么要改变一下。

6607
11:08:37.400 --> 11:08:41.700
好了，现在我们已经清理好了，我们要部署标记，部署Funmi。

6608
11:08:41.700 --> 11:08:43.917
让我们继续并开始编写一些测试。

6609
11:08:43.917 --> 11:08:56.334
写完这些测试后，我们会运行那个气体估计器使用那个气体估计器，我们会返回，我们会再次更新这个契约使它使用和工作更便宜。

6610
11:08:56.400 --> 11:09:13.043
记住，这将是编写这些测试的优势之一，我们如何优化我们的合同，使其更快，更省油，等等，我们要确保我们编写真正好的测试，这将是我们进入这些更专业的测试设置的第一步。

6611
11:09:13.043 --> 11:09:16.226
我们要跳转到测试文件夹，删除这个样本测试。

6612
11:09:16.226 --> 11:09:16.384
js。

6613
11:09:16.384 --> 11:09:21.336
在上一节中，我们讲了一个非常简单的测试，这很好。

6614
11:09:21.336 --> 11:09:31.190
然而，当我们的项目越来越大时，我们会想要开始测试越来越多不同的东西，我们会越来越多地进行至少两种不同类型的测试。

6615
11:09:31.190 --> 11:09:34.949
如果cd到test文件夹，我们会创建一个名为staging的目录。

6616
11:09:34.949 --> 11:09:38.778
然后我们要创建另一个名为unit的目录。

6617
11:09:38.778 --> 11:09:44.137
现在如果我们看一下我们的测试文件夹，我们现在有一个登台文件夹，和一个单元测试文件夹。

6618
11:09:44.137 --> 11:09:47.146
现在我们要讨论两种不同类型的测试。

6619
11:09:47.146 --> 11:09:49.363
第一个是单元测试。

6620
11:09:49.401 --> 11:09:56.350
那么什么是单元测试呢?单元测试是一种软件测试方法，通过它可以测试源代码的各个单元。

6621
11:09:56.401 --> 11:10:03.972
基本上，我们想做的是在我们的合同中，我们想测试我们的代码的最小部分，以确保它们正常工作。

6622
11:10:03.972 --> 11:10:10.463
一旦我们的小块测试工作了，我们想要做一个分阶段测试或集成测试。

6623
11:10:10.463 --> 11:10:15.083
这可能是我们在测试网络或某些实际网络上运行代码的地方。

6624
11:10:15.083 --> 11:10:19.615
你可以想到一个阶段性测试，它是你部署到主网之前的最后一站。

6625
11:10:19.615 --> 11:10:24.341
它们并不总是100%必要的，但它们真的非常非常有帮助。

6626
11:10:24.401 --> 11:10:36.934
记住，我们确实想要认真对待我们使用测试网的程度，但我们绝对百分之百想要确保所有东西都在本地工作，我们进行单元测试，我们在本地运行所有代码。

6627
11:10:36.934 --> 11:10:45.205
然后，我们可以在实际的测试网络上使用分期测试，以确保我们的代码将与实际的其他契约一起工作。

6628
11:10:45.205 --> 11:11:01.090
单元测试可以在本地硬帽网络或分叉硬帽网络中完成，我们很快会讲到这个，现在，让我们来构建这些单元测试，这些单元测试基本上就是我们在上一节中看到的。

6629
11:11:01.090 --> 11:11:04.057
让我们开始写一些单元测试。

6630
11:11:04.057 --> 11:11:09.910
让我们创建一个新的测试，我们将它命名为。test。j s。

6631
11:11:09.910 --> 11:11:12.402
我们会在这里开始测试

6632
11:11:12.402 --> 11:11:23.635
现在，我们在之前的上一节中进行了测试，但这里的测试看起来有点不同，我们实际上将使用hardhat deploy，来自动设置我们的测试，就像这两个部署函数都已经运行了一样。

6633
11:11:23.635 --> 11:11:25.140
让我们开始吧。

6634
11:11:25.140 --> 11:11:31.336
所以我们还是会用我们将要描述的相同的设置，我们会说，资助我。

6635
11:11:31.336 --> 11:11:39.111
这个会像这样有一个async函数。

6636
11:11:39.111 --> 11:11:48.386
在这里，我们会在每一个之前有一个，我们会有一些hits和一些description等等。

6637
11:11:48.386 --> 11:11:56.918
既然我们要对它进行单元测试，这里的测试会稍微重一点，然后是我们的上一个项目，但在未来，我们会稍微轻一点用一些测试。

6638
11:11:56.918 --> 11:11:58.350
让我们开始吧。

6639
11:11:58.350 --> 11:12:04.565
如果我们现在做硬头纱测试，我们不会有一个合格的。

6640
11:12:04.565 --> 11:12:13.272
现在，如果我们使用纱线硬帽覆盖，我们会得到像这样的东西，说，嘿，你漏掉了很多东西。

6641
11:12:13.272 --> 11:12:16.402
所以让我们试着用我们的测试覆盖更多的行。

6642
11:12:16.402 --> 11:12:21.787
我们可以这样做的一种方法是我们可以根据不同的函数来分组测试。

6643
11:12:21.787 --> 11:12:25.936
因此，让我们在构造函数周围进行第一组测试。

6644
11:12:25.936 --> 11:12:37.130
为了在第一个描述中做到这一点，我们可以添加另一个描述，让这个描述只是构造函数，这个更大的作用域将用于整个Funmi契约。

6645
11:12:37.130 --> 11:12:41.149
这个里面的所有东西都是给构造函数的。

6646
11:12:41.149 --> 11:12:43.859
这也是一个async函数。

6647
11:12:43.859 --> 11:12:46.753
这些任务只针对构造函数。

6648
11:12:46.753 --> 11:12:51.199
但是在我们开始这个描述之前，我们可能需要部署我们的Funmi契约。

6649
11:12:51.199 --> 11:12:52.703
我们来学习一下怎么做。

6650
11:12:52.703 --> 11:12:56.822
我们会在每个之前做一个a，这将是一个async函数。

6651
11:12:56.822 --> 11:13:03.353
我们将使用硬帽部署来部署Funmi契约。

6652
11:13:03.353 --> 11:13:09.943
因为我们使用硬帽部署，我们的Funmi合同将与我们的模拟和一切。

6653
11:13:09.943 --> 11:13:13.816
在每个之前，我们来做HDMI。

6654
11:13:13.816 --> 11:13:24.979
然后这里，我们要部署Funmi，我们要在这里部署Funmi契约首先从Harnett deploy中拉入我们的部署对象。

6655
11:13:24.979 --> 11:13:29.903
我们写const deployment = require hardhat。

6656
11:13:29.903 --> 11:13:41.009
这个部署对象有一个叫fixture的功能它允许我们运行整个deploy文件夹带尽可能多的标签。

6657
11:13:41.009 --> 11:13:45.435
您会注意到，我在两个脚本中都添加了这个alt标记。

6658
11:13:45.435 --> 11:13:50.822
这意味着在这个部署东西fixture中，它将是一个等待的fixture部署。

6659
11:13:50.822 --> 11:14:05.371
如果我运行deployment。fixture，我将在本地网络上运行deploy脚本并部署所有可以在脚本和测试中使用的契约，我们可以部署deploy文件夹中的所有内容只需这一行。

6660
11:14:05.371 --> 11:14:06.616
这不是很有帮助吗?

6661
11:14:06.616 --> 11:14:17.692
现在，一旦我们所有的合同都部署好了，我们可以开始得到他们会说，基金我等于等待以太，我们也会拉一个以太一些硬帽子。

6662
11:14:17.692 --> 11:14:21.797
点，这就是安全帽部署有用的地方。

6663
11:14:21.797 --> 11:14:33.081
同样，很难部署rapt ether使用一个叫Get contract的函数，这个Get contract函数将获取我们告诉它的任何契约的最新部署。

6664
11:14:33.081 --> 11:14:35.725
我们会说，给我一个乐趣契约。

6665
11:14:35.725 --> 11:14:41.469
所以这将给我们最新的李部署的Funmi合同在这一行。

6666
11:14:41.469 --> 11:14:45.239
现在Funmi等于这条线。

6667
11:14:45.404 --> 11:14:48.216
现在我们要用Funmi做一些交易。

6668
11:14:48.404 --> 11:14:48.870
测试它。

6669
11:14:52.404 --> 11:14:54.453
想要连接资金我。

6670
11:14:57.404 --> 11:15:04.070
消失得到命名帐户，就像我们在部署脚本中所做的一样。

6671
11:15:04.070 --> 11:15:14.331
然后我们只需要从我们的tap导入它在我们的部署脚本中我们导入了在我们的部署函数的输入参数中获取命名帐户。

6672
11:15:14.404 --> 11:15:24.748
记住，获取命名帐户和部署是从硬帽运行时环境中抽象出来的，就像我说的，硬帽运行时环境基本上和硬帽是一样的。

6673
11:15:24.748 --> 11:15:28.617
我们可以像这样导入它，实际上像这样。

6674
11:15:28.617 --> 11:15:32.911
因为我们实际上只需要从获取命名帐户中抽象部署者。

6675
11:15:32.911 --> 11:15:37.522
现在我们能做的是将部署者连接到Fund Me账户。

6676
11:15:37.522 --> 11:15:44.129
每当我们调用一个带有fundme的函数时，它会自动从玩家账户中取出，这很好。

6677
11:15:44.129 --> 11:15:48.155
另一种方法是你可以直接从你心中的配置获得不同的账户。

6678
11:15:48.155 --> 11:15:59.594
你可以用const accounts = await ethers。get signers, ethers。get signers将返回网络中这个帐户部分中的任何东西。

6679
11:15:59.594 --> 11:16:06.940
如果你用的是默认的网络硬帽，它会给你一个10个假账户的列表我们可以用它，当然，可以用const。

6680
11:16:06.940 --> 11:16:09.940
账户1等于账户。

6681
11:16:09.940 --> 11:16:15.945
更正确的做法是账户0等于账户0，然后这样操作。

6682
11:16:15.945 --> 11:16:18.808
我们将把注释放在一边，以防将来需要引用它。

6683
11:16:18.808 --> 11:16:19.388
好了,好了。

6684
11:16:19.388 --> 11:16:21.071
现在我们有了Funmi合同。

6685
11:16:21.071 --> 11:16:23.940
让我们继续编写一些测试来测试构造函数。

6686
11:16:23.940 --> 11:16:27.785
我们可能需要使用下面这个deployer对象。

6687
11:16:27.785 --> 11:16:30.245
我们会让部署者在上面。

6688
11:16:30.405 --> 11:16:32.642
我们要在这里做一些繁琐的事情。

6689
11:16:33.405 --> 11:16:38.896
deployer =等，获取命名帐户，点部署者。

6690
11:16:39.405 --> 11:16:44.388
我们将把它包装起来这样我们就能获取这个部署者对象并将它赋值为这样的声明。

6691
11:16:44.388 --> 11:16:52.947
在这里，我们会创建第一个测试，我们会说它会正确设置Agra Gator地址。

6692
11:16:52.947 --> 11:16:57.354
逗号将使它成为一个async函数。

6693
11:16:57.354 --> 11:17:08.321
我们写入const response = await fundme。让我们在这里得到这个价格提要，fundme。price提要。

6694
11:17:08.405 --> 11:17:16.309
然后我们要确保这个价格提要将与我们的mkv 3聚合器相同因为我们将在本地运行这些测试。

6695
11:17:16.309 --> 11:17:21.139
我们应该把标记3v3聚合器放在最上面。

6696
11:17:21.139 --> 11:17:25.186
让我们模拟v3聚合存储。

6697
11:17:25.406 --> 11:17:37.897
我们会用同样的方式获取这个地址，mockbee Three aggregator = await ethers。get contract mockbee Three aggregator，我们也会把这个连接到部署者。

6698
11:17:37.897 --> 11:17:48.651
我们会说，cert。equals cert。equal response, lockv3 aggregator。address。

6699
11:17:48.651 --> 11:17:54.156
当然我们会说const。

6700
11:17:54.156 --> 11:17:57.281
断言= require gy。

6701
11:17:57.281 --> 11:17:59.406
从大疆导入。

6702
11:17:59.406 --> 11:18:00.252
好的,很酷。

6703
11:18:00.406 --> 11:18:03.175
现在，我们来试试这个。

6704
11:18:03.175 --> 11:18:04.175
纱线建筑工人。

6705
11:18:04.175 --> 11:18:04.559
测试。

6706
11:18:05.406 --> 11:18:07.180
response拼写错误。

6707
11:18:07.180 --> 11:18:08.873
让我们再试一次。

6708
11:18:08.873 --> 11:18:09.518
太棒了。

6709
11:18:10.406 --> 11:18:17.263
意味着我们确实正确地将价格提要地址分配给了Mach v3聚合器。

6710
11:18:17.263 --> 11:18:18.242
好了,好了。

6711
11:18:18.406 --> 11:18:18.729
太棒了。

6712
11:18:21.406 --> 11:18:21.929
构造函数。

6713
11:18:24.406 --> 11:18:28.371
它们更多的是演示它们的样子，我们现在将跳过为它们编写测试。

6714
11:18:28.371 --> 11:18:32.356
我们会直接从合同中删除它们。

6715
11:18:32.406 --> 11:18:35.889
如果您想继续为它们编写一些测试，并将它们留在示例中以供学习。

6716
11:18:35.889 --> 11:18:41.033
你完全可以暂停视频，写一些测试，如果你愿意的话，但我们会跳过这些。

6717
11:18:41.033 --> 11:18:46.130
接下来，我们将继续资助和运行一些有趣的测试。

6718
11:18:46.130 --> 11:18:48.478
我们来写描述基金。

6719
11:18:48.478 --> 11:18:50.854
这将是一个异步函数。

6720
11:18:50.854 --> 11:18:55.656
在这里，我们要做一些测试。

6721
11:18:55.656 --> 11:19:08.529
如果我们要一行一行地看，我们首先应该看什么?我们应该看看这个要求行我们应该写一个测试看看这个契约是否真的失败?如果不够，就发送。

6722
11:19:08.529 --> 11:19:29.273
如果没有发送足够的eath，它就会失败这是异步函数吗?现在，我们如何测试是否出现故障?现在我们已经完成了断言等于操作，但是如果某些操作失败，我们可能会遇到问题。

6723
11:19:29.273 --> 11:19:37.193
例如，如果我运行await fund me。fund，但我没有传递任何值给这个事务。

6724
11:19:37.193 --> 11:19:38.324
让我们看看会发生什么。

6725
11:19:38.324 --> 11:19:39.734
我进行纱线硬头试验。

6726
11:19:39.734 --> 11:19:44.242
我们的测试实际上是要打破VM异常。

6727
11:19:44.407 --> 11:19:49.519
在处理用原因字符串返回的事务时，您需要花费更多的时间。

6728
11:19:49.519 --> 11:19:51.990
所以我们的测试会中断，这很好。

6729
11:19:51.990 --> 11:19:53.823
我们想让它破裂。

6730
11:19:53.823 --> 11:19:57.540
但我们想告诉我们的测试，这是可以的。

6731
11:19:57.540 --> 11:20:00.073
对吧?我想告诉你这没什么。

6732
11:20:00.073 --> 11:20:05.182
我们可以这样做，这就是华夫饼测试发挥作用的地方。

6733
11:20:05.182 --> 11:20:15.140
通过华夫和测试，我们实际上可以做的是使用expect关键字并期望事务被恢复和事务失败。

6734
11:20:15.140 --> 11:20:23.084
这里我们不使用断言，而是运行一个wait expect fundme。fun 2。

6735
11:20:23.084 --> 11:20:37.734
2点乘B，那是还原的实际上我们在这里更具体地说要还原然后精确的还原误差，你需要花更多的时间。

6736
11:20:37.734 --> 11:20:41.997
如果我们运行我们的测试，哎呀，expect没有定义。

6737
11:20:41.997 --> 11:20:45.426
所以我们要从柴那里进口。

6738
11:20:45.426 --> 11:20:53.177
这chai被华夫饼覆盖了，我们看到它确实是Pass，这是完美的。

6739
11:20:53.177 --> 11:20:58.311
所以现在我们有了一种既断言事物又预期事物失败的方法。

6740
11:20:58.311 --> 11:21:01.278
太棒了，即使有特定的失败代码。

6741
11:21:01.408 --> 11:21:01.758
完美的。

6742
11:21:01.758 --> 11:21:03.408
让我们在这里编写更多的测试。

6743
11:21:04.408 --> 11:21:08.023
希望它正确地更新此数据结构。

6744
11:21:09.408 --> 11:21:17.541
它会更新资金数额的数据结构，这将是一个异步函数。

6745
11:21:17.541 --> 11:21:21.214
在这里，我们需要调用fund v。fund。

6746
11:21:21.214 --> 11:21:27.149
然而，我们需要在这个事务中传递一些值。

6747
11:21:27.149 --> 11:21:33.158
现在，我们只硬编码我们要发送的值，比如const。

6748
11:21:33.158 --> 11:21:41.469
发送值将是112345 678-910-1234 5678，这将是一个eath。

6749
11:21:41.469 --> 11:21:46.604
另一种写法是，我们可以使用ethers实用程序，让它更容易阅读。

6750
11:21:46.604 --> 11:21:51.908
因为所有这些0都有点让人困惑，很难第一眼看出这到底是什么。

6751
11:21:51.908 --> 11:22:07.178
我们将使用ethers。utils。parse ether，这个parse ethers实用程序将这个转换成那个有18个0的，这让事情变得简单多了。

6752
11:22:07.178 --> 11:22:15.534
如果你去乙醚文档，还有一个零件单位函数你可以转换任何单位，乙醚或Gwei。

6753
11:22:15.534 --> 11:22:20.588
或者不管你想做什么，你可以将任何数字转换为你输入的任何其他Aetherium。

6754
11:22:20.588 --> 11:22:23.599
这是基金的设定值。

6755
11:22:23.599 --> 11:22:28.195
这肯定会大于我们的最低50美元。

6756
11:22:28.195 --> 11:22:43.373
调用这个fun函数后，我们会说const response将等于一个权重，fundme。address to Mt funding address to Mt funding for部署者。address。

6757
11:22:43.373 --> 11:22:49.159
因为记住，这是每个地址和他们实际资助的金额的映射。

6758
11:22:49.159 --> 11:22:54.251
如果我们使用部署者地址，它会给我们实际发送的数量。

6759
11:22:54.251 --> 11:22:57.830
现在我们可以运行assert。equal response。

6760
11:22:57.830 --> 11:23:04.900
到字符串，对吧，因为这个响应将是那个帐户提供资金的大数字版本。

6761
11:23:04.900 --> 11:23:08.128
这应该和我们的发送值相同。

6762
11:23:08.128 --> 11:23:08.999
字符串。

6763
11:23:08.999 --> 11:23:21.857
既然发送价值，我们的一个应该是完全相同的金额，我们的资金，我们可以只运行这一个测试，或运行纱线，艺术帽子，测试，dash dash grep。

6764
11:23:21.857 --> 11:23:27.774
我们把它加在引号里允许为这个金额提供资金。

6765
11:23:27.774 --> 11:23:35.634
看起来我们在这里遇到了一个问题，因为我们不需要在地址处部署，我们可以在这里部署。

6766
11:23:35.634 --> 11:23:38.742
太好了，看来我们真的要过去了。

6767
11:23:38.742 --> 11:23:45.309
现在如果我们甚至运行纱线Hardhead覆盖现在会看到我们得到了至少一点更多的覆盖在这里。

6768
11:23:45.309 --> 11:23:46.959
还是不会很好。

6769
11:23:46.959 --> 11:23:48.748
但我们有更好的覆盖。

6770
11:23:48.748 --> 11:23:52.777
我们有一些语句，一些分支，至少有一些函数。

6771
11:23:52.777 --> 11:23:53.771
这太棒了。

6772
11:23:53.771 --> 11:23:54.650
让我们继续。

6773
11:23:54.650 --> 11:23:58.215
我们的有趣功能测试完成了吗?好吧，可能不是。

6774
11:23:58.215 --> 11:24:03.901
我们还能用fun函数做什么?我们也在把资助者添加到资助者数组中。

6775
11:24:03.901 --> 11:24:07.441
我们来测试一下。

6776
11:24:07.441 --> 11:24:15.442
所以它将资助者添加到资助者数组中一直是一个异步函数。

6777
11:24:15.442 --> 11:24:22.753
我们说await fund意思是基金值将是发送值。

6778
11:24:22.753 --> 11:24:32.901
我们会说const response = await fundme。在索引0处调用资助者数组。

6779
11:24:32.901 --> 11:24:39.767
这里是，fundunder = await fundme。funders为0。

6780
11:24:39.767 --> 11:24:44.972
然后我们会说断言。等于投资人应该和部署者一样。

6781
11:24:44.972 --> 11:24:47.060
让我们继续运行这个测试。

6782
11:24:47.060 --> 11:24:48.460
我们会见面几次。

6783
11:24:48.460 --> 11:24:55.845
我们会把GREP改到数组下面这样它就能找到这一行。

6784
11:24:55.845 --> 11:24:56.861
和完善。

6785
11:24:56.861 --> 11:24:59.377
看来那个也要过去了。

6786
11:24:59.377 --> 11:24:59.764
太好了。

6787
11:24:59.764 --> 11:25:06.237
因此，资金流入，最低金额流入，我们的数据结构也在更新。

6788
11:25:06.237 --> 11:25:06.788
太棒了。

6789
11:25:06.788 --> 11:25:11.143
现在我们可以再啰嗦一点用这个有趣的函数做更多的测试。

6790
11:25:11.143 --> 11:25:13.743
但我认为在大多数情况下，我们已经得到了要点，对吧。

6791
11:25:13.743 --> 11:25:17.246
现在让我们继续看取款函数。

6792
11:25:17.246 --> 11:25:21.076
我们要创建一个新的描述或提取。

6793
11:25:21.076 --> 11:25:26.142
这将是一个async函数。

6794
11:25:26.410 --> 11:25:29.070
我们来看看取款函数是怎么做的。

6795
11:25:29.410 --> 11:25:34.071
合同的所有者将能够得到余额，拿回钱。

6796
11:25:34.071 --> 11:25:38.770
我们还会重置每个用户完成的所有数量。

6797
11:25:38.770 --> 11:25:40.910
我们来做一些提取。

6798
11:25:40.910 --> 11:25:57.875
现在为了让我们测试提取，我们可能首先希望合同中确实有一些钱，所以我们实际上可以做的是在每个描述之前添加另一笔钱，在我们运行任何测试之前自动为合同提供资金。

6799
11:25:57.875 --> 11:26:02.536
我们可以在每个async函数之前说。

6800
11:26:02.536 --> 11:26:07.457
我们可以说await, fund me。fund。

6801
11:26:07.457 --> 11:26:09.988
值，发送值。

6802
11:26:10.411 --> 11:26:16.818
现在我们所有的测试都在这个提取范围内，我们首先要用每个人的资金。

6803
11:26:16.818 --> 11:26:20.927
假设它可以取钱，取钱。

6804
11:26:20.927 --> 11:26:27.185
从单个创建者，这将是一个异步函数。

6805
11:26:27.185 --> 11:26:31.926
这是一个稍微长一点的测试。

6806
11:26:31.926 --> 11:26:38.973
我将把它设置为一个安排，行动和断言测试。

6807
11:26:38.973 --> 11:26:45.169
arrange act assert是一种编写测试的方式，你想要安排测试，然后你想要操作。

6808
11:26:45.169 --> 11:26:48.478
然后你要运行断言，一会儿你就会明白我的意思。

6809
11:26:48.478 --> 11:26:56.220
所以我们要安排这个测试，我们要设置这个测试，我们要实际检查我们是否正确地从一个创建者提取以太。

6810
11:26:56.220 --> 11:27:02.533
首先，我们要得到融资合同的初始余额和部署者的初始余额。

6811
11:27:02.533 --> 11:27:05.199
所以我们用const。

6812
11:27:05.199 --> 11:27:17.344
从我开始，余额，等于等待，资助我。提供者，获取余额，资助我。地址。

6813
11:27:17.344 --> 11:27:23.724
我们从基金V合同的余额开始在它得到一些资金后。

6814
11:27:23.724 --> 11:27:39.356
我们也会开始花费，部署你的余额等待，资助我。提供者，得到部署雇主的余额。

6815
11:27:39.412 --> 11:27:50.089
我们得到了Funmi的初始余额，我们得到了雇主的初始余额这样我们就可以稍后测试这些数字有多少变化基于我们调用取款函数时发生的事情。

6816
11:27:50.089 --> 11:27:55.459
现在我们已经完成了一点设置，我们可以运行这个取款函数，我们可以在这里执行这个动作。

6817
11:27:55.459 --> 11:28:03.697
我们会说const, transactionresponse = await, fundme。withdraw。

6818
11:28:03.697 --> 11:28:16.300
然后我们可以说const，事务接收等于等待事务响应。

6819
11:28:16.300 --> 11:28:25.459
等待，一个，现在我们应该能够检查整个基金再平衡已经添加到部署者余额。

6820
11:28:25.459 --> 11:28:39.649
现在我们可以说const结束，基金我余额等于一个权重在我上提供者。get余额虚幻。地址。

6821
11:28:39.649 --> 11:28:55.258
然后我们可以说const ending deployer balance = await, fundme。provider。get balance of deployer。

6822
11:28:55.258 --> 11:29:00.300
现在我们可以看看这些数字是否正确。

6823
11:29:00.412 --> 11:29:13.347
所以我们可以说断言。equal = endfundme结余将是零，对吧，因为我们刚刚取出了所有的钱。

6824
11:29:13.413 --> 11:29:15.993
所以期末资金余额应该是零。

6825
11:29:17.413 --> 11:29:25.996
点等于初始资金余额加上初始部署余额。

6826
11:29:25.996 --> 11:29:34.344
初始资金余额加上初始雇主余额应该等于最终雇主余额。

6827
11:29:34.413 --> 11:29:45.263
因为我们取的是初始部署者的余额加上初始基金来平衡，因为我们刚刚取出了所有的初始基金，我们的余额应该等于最终部署者的机器人。

6828
11:29:45.263 --> 11:29:59.527
这里有几点注意，因为Funmi balance是从区块链调用的，它的类型是一个大数，我们想用大数。加，而不是这里的加号，因为它会它会让处理大数更容易一些。

6829
11:29:59.527 --> 11:30:05.413
我们不从Funmi balance开始，而是从balance。add开始。

6830
11:30:05.413 --> 11:30:06.038
像这样。

6831
11:30:06.038 --> 11:30:07.379
这应该是件好事。

6832
11:30:07.379 --> 11:30:16.235
关于这个还有一件事，当我们调用withdraw时，我们的Deployer做了我们的Deployer花了一点汽油。

6833
11:30:16.235 --> 11:30:19.847
所以这实际上是不准确的。

6834
11:30:19.847 --> 11:30:26.701
我们实际上还需要计算汽油成本，所以我们不需要做点加汽油成本。

6835
11:30:26.701 --> 11:30:28.480
我们也必须这么做。

6836
11:30:28.480 --> 11:30:34.671
字符串，因为大的数字是对象，所以恒等式有点奇怪。

6837
11:30:34.671 --> 11:30:39.302
为了测试它们是否相等，我们将它们都设为字符串。

6838
11:30:39.302 --> 11:30:42.413
现在我们没有汽油成本了。

6839
11:30:42.413 --> 11:30:47.476
我们来看看如何从这个交易中得到汽油成本。

6840
11:30:47.476 --> 11:30:51.610
我们可以把它添加到Are any deployer bounce，我们可以在这里运行这个断言。

6841
11:30:51.610 --> 11:30:55.887
我们能做的就是从交易收据中找到汽油成本。

6842
11:30:55.887 --> 11:31:00.880
我将向你们展示一些在VS code中可以使用的非凡技巧。

6843
11:31:00.880 --> 11:31:04.366
如果使用不同的编辑器，那么不必太担心这个。

6844
11:31:04.414 --> 11:31:08.299
我们可以在VS code中创建断点。

6845
11:31:08.299 --> 11:31:17.363
修改未验证的断点文件以重新启动错误会话，或者我们把它放在这里，放在事务接收创建后的这一行。

6846
11:31:17.414 --> 11:31:31.033
但是在结束Funmi带之前，这个断点的作用是它在这一行停止脚本，并允许我们进入一个叫做调试控制台的东西，查看正在发生的所有变量。

6847
11:31:31.033 --> 11:31:36.525
在这个时候，我们想看看交易收据，看看总汽油费用是否在里面。

6848
11:31:36.525 --> 11:31:44.142
这对于进入测试和脚本并查看到底哪里出了问题也非常有帮助。

6849
11:31:44.142 --> 11:31:47.758
我们能做的就是往下看遇到bug这一节。

6850
11:31:47.758 --> 11:31:50.315
如果它不在那里，你可以点击其他视图。

6851
11:31:50.414 --> 11:31:57.628
我们可以单击这个JavaScript调试终端，它将在我们的终端部分创建一个新终端。

6852
11:31:57.628 --> 11:32:04.461
现在发生的是，如果我们运行纱线，硬帽测试，它会运行我们的测试和一切。

6853
11:32:04.461 --> 11:32:06.610
但是当它到达这个断点时，它就会停止。

6854
11:32:06.610 --> 11:32:08.183
目前，没有汽油成本。

6855
11:32:08.183 --> 11:32:10.117
我们先把这个删掉。

6856
11:32:10.117 --> 11:32:12.233
这样我们就可以编译和工作。

6857
11:32:12.233 --> 11:32:21.091
但是如果我们运行yarn Hardhead test，它会说调试器已经附加，开始运行我们的测试。

6858
11:32:21.091 --> 11:32:23.814
它会在这条线上停下来。

6859
11:32:23.814 --> 11:32:32.351
如果我们看左边的变量部分，我们可以看到这里有很多变量。

6860
11:32:32.351 --> 11:32:35.866
我们可以读到更多关于发生了什么。

6861
11:32:35.866 --> 11:32:57.344
如果我们转到调试控制台，我们可以输入诸如事务收据之类的东西，我们可以看到大量关于事务收据对象的信息，我们要找的是这个事务收据，我们可以在调试控制台或这里查看，如果这里与gas有关的话。

6862
11:32:57.415 --> 11:33:01.344
看起来有一个很大的气体使用量。

6863
11:33:01.415 --> 11:33:03.972
还有一个有效的天然气价格。

6864
11:33:05.415 --> 11:33:11.200
用过的乘以汽油价格会得到我们支付的所有汽油钱。

6865
11:33:11.200 --> 11:33:21.300
现在我们已经算出了在这个交易收据中有使用过的汽油和有效的汽油价格变量，我们也可以在这里的文件中找到。

6866
11:33:21.300 --> 11:33:30.248
不过，有时自己找出我们能做什么会更快，我们可以通过点击这里这个小东西退出调试器。

6867
11:33:30.248 --> 11:33:36.526
返回终端将垃圾桶的JavaScript调试器，我们将删除断点。

6868
11:33:36.526 --> 11:33:48.316
我们会获取这两个变量我们可以通过输入const从事务接收对象中取出它们。

6869
11:33:48.415 --> 11:33:55.874
是的，使用逗号有效的汽油价格等于交易收据。

6870
11:33:55.874 --> 11:34:02.336
再一次，通过这个花括号语法，我们可以用它从另一个对象中取出对象。

6871
11:34:02.336 --> 11:34:14.016
现在我们有了这两个对象，我们可以创建一个const gas cost或总gas cost等于使用的gas乘以有效gas价格。

6872
11:34:14.016 --> 11:34:23.916
因为这两个都是大数，我们可以用一个叫做。mol的大数函数把它们相乘。

6873
11:34:23.916 --> 11:34:33.349
现在我们有了总天然气成本，我们可以下来我们可以说最终部署者余额加上用于串的天然气成本。

6874
11:34:33.349 --> 11:34:36.149
这两个应该是等价的。

6875
11:34:36.149 --> 11:34:40.350
我知道我们在这部分要做很多数学运算和很多新东西。

6876
11:34:40.350 --> 11:34:43.399
我想快速回顾一下我们刚刚学过的内容。

6877
11:34:43.399 --> 11:34:54.449
首先，合约的字体带有提供者，我们也可以用ethers。provider。get balance，但我们用fun v。provider因为我们用Funmi合约的提供者。

6878
11:34:54.449 --> 11:34:56.494
我们在这里用什么并不重要。

6879
11:34:56.494 --> 11:35:02.940
我们只是想使用provider对象的get balanced函数，它为我们获取任何契约的平衡。

6880
11:35:02.940 --> 11:35:06.284
我们做同样的事情开始痛惜平衡。

6881
11:35:06.416 --> 11:35:14.749
我们需要初始余额的原因是我们想将其与期末余额进行比较看看是否所有的钱都去了正确的地方，然后调用提款函数。

6882
11:35:14.749 --> 11:35:20.339
从交易收据上，我们查到了汽油使用量和价格。

6883
11:35:20.339 --> 11:35:33.216
如果你想调试你的JavaScript代码，你可以添加一个断点，比如go to run into bug，打开你的调试JavaScript终端，这与常规的bash终端不同。

6884
11:35:33.216 --> 11:35:38.899
当您在这里运行JavaScript命令时，它们将在断点所在的位置停止。

6885
11:35:38.899 --> 11:35:41.845
然后你可以读取不同的变量，看到不同的东西在哪里。

6886
11:35:41.845 --> 11:35:42.845
利用这些知识。

6887
11:35:42.845 --> 11:35:58.332
我们从交易收据中提取出天然气使用量和有效天然气价格，用它来计算该交易的天然气总成本，然后我们得到了最终基金，我们平衡了最终部署者余额，并使用所有这些变量来确保所有的钱都花在了正确的地方。

6888
11:35:58.332 --> 11:36:12.298
我们可以通过运行yarn Hardhead测试来检查，因为这里有空格，我们可以看到我们的测试确实通过了。

6889
11:36:12.298 --> 11:36:13.145
伟大的工作。

6890
11:36:13.145 --> 11:36:17.481
如果我们不加汽油成本，我们已经加了。

6891
11:36:17.481 --> 11:36:29.578
对于弦，我们会看到这样的东西，我们会看到数字有一点偏差，因为我们没有预测我们没有计算气体。

6892
11:36:29.578 --> 11:36:35.970
所以当我们做这样的计算时我们总是要确保我们用的是气体。

6893
11:36:35.970 --> 11:36:40.320
另一个非常强大的调试工具我们不打算在这里讲。

6894
11:36:40.320 --> 11:36:47.010
但了解它很重要因为它真的很有用你可以在你的solid with hard hat中使用console。log。

6895
11:36:47.010 --> 11:36:52.032
如果你在一个心形帽子项目中，你只需要导入hard hat斜杠/ console。soul。

6896
11:36:52.032 --> 11:36:58.899
然后在你的实体中，你可以输入console。log，然后输入你想要的任何东西。

6897
11:36:58.899 --> 11:37:06.269
当你执行这些函数时，类似于我们在JavaScript中做console。log，这些实际上会把console。log输出到你的终端。

6898
11:37:06.269 --> 11:37:13.820
这里有一个例子，如果你运行yarn，硬帽测试，你有那些console。log，你会看到像这样的东西被打印出来。

6899
11:37:13.820 --> 11:37:24.351
因此，除了Visual Studio Code调试器之外，导入硬帽斜杠console。Sol，以及在您的solidity中使用console。log也是一种有效的调试策略。

6900
11:37:24.351 --> 11:37:30.318
请暂停这个视频，在我们的一些合同中执行这个，并在我们的测试中尝试它。

6901
11:37:30.318 --> 11:37:48.618
我们测试了当只有一个出资人的情况下取款效果很好，让我们测试一下如果有多个出资人的情况下取款，我们会这样做，假设允许我们从多个出资人那里取款。

6902
11:37:48.618 --> 11:37:53.349
为什么这是一个异步函数。

6903
11:37:53.349 --> 11:38:01.327
让我们做这个等待Funmi不好玩，但与许多不同的帐户。

6904
11:38:01.327 --> 11:38:11.314
我们可以创建一大堆不同的账户，通过const accounts = await ethers。get signers。

6905
11:38:11.314 --> 11:38:16.871
我们可以遍历这些账户让每个账户调用基金函数。

6906
11:38:16.871 --> 11:38:19.547
我们要用一个for循环来做这个。

6907
11:38:19.547 --> 11:38:30.285
我们说，for let i =我们从账户的第一个索引开始因为带索引的0将是部署者。

6908
11:38:30.285 --> 11:38:35.306
假设i = 1小于6。

6909
11:38:35.306 --> 11:38:37.621
我们用i + +。

6910
11:38:37.621 --> 11:38:40.792
在这里，我们用const。

6911
11:38:40.792 --> 11:38:47.233
和我的合同Funmi连接的合同等于等待。

6912
11:38:47.233 --> 11:39:01.775
me点连接两个账户，I，我们需要调用这个连接函数因为现在如果我们滚动到顶部，Funmi合约连接到部署者账户。

6913
11:39:01.775 --> 11:39:13.034
当我们用Funmi调用一个事务时，部署者就是调用该事务的帐户，我们需要创建新的对象来连接到所有这些不同的帐户。

6914
11:39:13.034 --> 11:39:19.490
我们说，基金连接合约，它连接到其中一个不同账户。基金。

6915
11:39:19.490 --> 11:39:23.276
这就是我们做价值，发送价值的地方。

6916
11:39:23.276 --> 11:39:25.736
不好意思，我们用await。

6917
11:39:25.736 --> 11:39:26.116
太好了。

6918
11:39:26.116 --> 11:39:28.973
这就是我们的值域部分。

6919
11:39:28.973 --> 11:39:33.812
和上面一样，我们需要获取初始余额。

6920
11:39:33.812 --> 11:39:37.096
我们可以复制这两行，然后粘贴到这里。

6921
11:39:37.096 --> 11:39:41.919
现在我们进入行为，我将再次调用取款函数。

6922
11:39:41.919 --> 11:39:50.935
我们说const，事务操作response = await和MI。withdraw。

6923
11:39:50.935 --> 11:39:59.657
我们要做和上面做的完全一样的事情，得到交易收据和汽油费用，这样我们就能把一切都弄清楚。

6924
11:39:59.657 --> 11:40:02.128
一旦我们完成了行为，我们就进入断言。

6925
11:40:02.128 --> 11:40:10.704
我们要做一些和上面做的非常相似的事情，比如这个，整个第一部分是完全一样的。

6926
11:40:10.704 --> 11:40:15.419
我们还想确保资助者被正确重置。

6927
11:40:15.419 --> 11:40:20.387
我们要确保这个资助者数组被正确重置。

6928
11:40:20.387 --> 11:40:35.180
要做到这一点，我们实际上可以检查一下，如果查看带有位置的0会抛出一个错误我们可以运行wait expect fundme。get on me。funder on me。funders (0)

6929
11:40:35.180 --> 11:40:53.258
这应该会恢复所以我们写入await expect Funmi。funders。2。b。reverted然后我们要遍历所有这些账户并确保它确保或者说在映射中，所有的金额都为零。

6930
11:40:53.258 --> 11:41:08.816
我们会说，对于I = 1小于6,I + +，我们会说assert。equal。

6931
11:41:08.816 --> 11:41:22.003
等，基金我点地址到基金金额，我拿到地址的账户应该是零。

6932
11:41:22.003 --> 11:41:27.629
我们要确保所有这些映射都被正确地更新为零。

6933
11:41:27.629 --> 11:41:28.887
我们来测试一下。

6934
11:41:28.887 --> 11:41:38.520
我们有多个创建者，我们会回到终端，我们会点击，我们会改变这个或这个GREP。

6935
11:41:38.520 --> 11:41:41.020
我们看看这是否能通过。

6936
11:41:41.020 --> 11:41:50.640
确实如此，这意味着我们的提款功能在有多个资助者的情况下也能很好地运作知道了这一点我们就能开心地睡觉了。

6937
11:41:50.640 --> 11:42:00.182
现在我们绝对想要100%想要测试的另一件事是我们唯一的所有者修改器在工作，我们希望只有所有者能够从这里提取资金。

6938
11:42:00.182 --> 11:42:10.314
我们创建一个新会话，它只允许所有者提款只允许你提款。

6939
11:42:10.420 --> 11:42:13.862
这将是一个异步函数。

6940
11:42:17.420 --> 11:42:19.657
Accounts =醚。get signed再次。

6941
11:42:20.420 --> 11:42:24.666
Const攻击者等于一个账号。

6942
11:42:27.421 --> 11:42:42.421
帐户将会是某个随机的攻击者将这个攻击者连接到一个新的合约，我们说const攻击者连接的合约等于等待DB。connect。

6943
11:42:42.421 --> 11:42:47.674
攻击者。地址，不好意思是。连接攻击者。

6944
11:42:47.674 --> 11:42:55.695
因为我们不只是连接地址，而是连接攻击者是帐户对象的帐户。

6945
11:42:55.695 --> 11:43:14.524
然后我们会做一个等待，期望攻击者连接契约。撤回。2。b。返回，他们应该不能撤回。

6946
11:43:14.524 --> 11:43:22.813
让我们继续，我们甚至可以复制这整个如果我们想要点击，我们会删除这部分。

6947
11:43:22.813 --> 11:43:24.582
我们把它粘贴进去。

6948
11:43:24.582 --> 11:43:25.307
和繁荣。

6949
11:43:25.307 --> 11:43:32.711
这意味着当其他帐户试图调用取款时，会自动返回，这就是我们想要的。

6950
11:43:32.711 --> 11:43:39.921
现在我们可以更明确地确保抛出了正确的错误代码，而不仅仅是将其还原。

6951
11:43:39.921 --> 11:43:47.155
对，它可以被还原因为他们发送了以太他们做了一些奇怪的事情，我们要确保它被还原为我们特定的错误代码。

6952
11:43:47.155 --> 11:43:49.711
现在我们有这个非所有者错误代码。

6953
11:43:49.711 --> 11:43:56.959
但最好的做法是将合约名加上下划线，然后是自定义错误。

6954
11:43:56.959 --> 11:44:02.954
当您将来有大量不同的合同，并且不确定错误来自何处时，这使它变得容易得多。

6955
11:44:02.954 --> 11:44:18.470
我们要快速地更新这个把它改成，基金我下划线下划线，而不是所有者，现在我们能做的是现在我们有了这个自定义错误，我们可以说，撤回那个要用它进行还原，然后我们可以在这里添加自定义错误。

6956
11:44:18.470 --> 11:44:25.596
现在，如果我们重新运行我们的测试，只允许所有者提取，我们需要在这里做一个等待。

6957
11:44:25.596 --> 11:44:28.320
是我的错，等到周四，再找签名。

6958
11:44:28.320 --> 11:44:30.286
现在我们再试一次。

6959
11:44:30.422 --> 11:44:35.274
我们确实超越了完美。

6960
11:44:35.422 --> 11:44:35.937
好了,好了。

6961
11:44:35.937 --> 11:44:37.577
我们这里有一些基本的单元测试。

6962
11:44:38.422 --> 11:44:40.588
很快就能写一些分段测试。

6963
11:44:41.422 --> 11:44:46.025
这样做，让我们继续添加气体估计器。

6964
11:44:46.422 --> 11:44:49.732
我们会看到这些函数的收缩消耗了多少气体。

6965
11:44:49.732 --> 11:44:52.760
看来硬脑集团的气体记者已经到了。

6966
11:44:52.760 --> 11:44:54.539
让我们向下滚动。

6967
11:44:54.539 --> 11:44:56.827
我们会做真实的气体报告。

6968
11:44:56.827 --> 11:44:59.555
这里我们不考虑硬币市值。

6969
11:44:59.555 --> 11:45:01.772
我们只看GUI。

6970
11:45:01.772 --> 11:45:03.210
你可以像这样注释掉它。

6971
11:45:03.210 --> 11:45:05.452
现在重新运行我们所有的测试

6972
11:45:05.452 --> 11:45:08.036
所以我们说纱线，我们的测试。

6973
11:45:08.036 --> 11:45:13.993
这样我们就会得到气体输出在气体报告的破折号文本中。

6974
11:45:13.993 --> 11:45:17.896
看来我们所有的测试都通过了，太好了。

6975
11:45:17.896 --> 11:45:22.234
现在我们来看看气体报告看看发生了什么。

6976
11:45:22.234 --> 11:45:32.155
嗯，看起来筹款功能消耗了大量的汽油，取款功能，带一些客人去我们会看到最小值，最大值和平均值。

6977
11:45:32.155 --> 11:45:36.114
当然，我们可以看到每个合同的实际产出成本是多少。

6978
11:45:36.114 --> 11:45:40.385
当然，我们并不真正关心MOQ聚合器，因为我们从未真正使用过它。

6979
11:45:40.422 --> 11:45:45.798
假设我们看一下这些的平均气体量我们会说，嗯，这看起来比我们最初预期的要多很多。

6980
11:45:45.798 --> 11:45:48.329
有没有什么办法能让我们把价格降低一点。

6981
11:45:48.423 --> 11:45:52.711
如果我们回到我们的资金契约，我们看一下我们的取款函数。

6982
11:45:52.711 --> 11:45:57.507
我们注意到一件事，哦，实际上有一种方法可以让这个便宜很多。

6983
11:45:57.507 --> 11:46:05.368
它和一个叫做存储变量的东西有关，也就是我们一直在研究的全局变量。

6984
11:46:05.423 --> 11:46:12.009
让我给你们画一幅图，我们来看看第一个气体优化技术你可以用它来解决这些问题。

6985
11:46:12.009 --> 11:46:14.284
这和R Funmi有关。

6986
11:46:14.423 --> 11:46:25.216
缩并这些状态变量以及它们是如何存储的以及这个缩并是如何跟踪所有这些东西的，这一节将会更高级一些。

6987
11:46:25.216 --> 11:46:34.298
这里我要说明一下，这是高级的部分，如果你想跳过它，你可以，因为现在我们要讲到气体优化，知道这些信息还是很有用的。

6988
11:46:34.298 --> 11:46:38.177
所以如果你现在想跳过它，然后再回来，你完全可以。

6989
11:46:38.177 --> 11:46:44.914
我们来谈谈当我们保存或存储这些全局变量时会发生什么。

6990
11:46:44.914 --> 11:46:46.947
这些存储变量。

6991
11:46:46.947 --> 11:46:50.372
我接下来要讲的都在文档里了。

6992
11:46:50.423 --> 11:47:07.580
这里有一个链接，在与这门课相关的GitHub回购中，当我们有一个全局变量，或者这些变量永久存在时，它们会被卡在一个叫做存储的东西中，你可以把存储想象成一个巨大的数组，或者一个我们实际创建的所有变量的巨大列表。

6993
11:47:07.580 --> 11:47:27.762
当我们有一个叫Son of storage的契约，我们有一个叫收藏号的变量，我们基本上是说我们想让收藏号变量持久存在，对吧，我们在很多例子中看到过，我们有一个收藏号变量我们总是可以调用它来查看收藏号的契约是什么，它持久存在的方式是，它被存储在一个叫storage的地方。

6994
11:47:27.762 --> 11:47:40.203
存储框是一个与契约相关的巨大列表存储段中的每个变量和每个值都被插入到这个存储阵列中的一个32字节长的槽中。

6995
11:47:40.203 --> 11:47:47.392
例如，数字25在它的字节实现中是000加上一大堆的0 19。

6996
11:47:47.392 --> 11:47:49.820
这是人民币256的十六进制版本。

6997
11:47:49.820 --> 11:47:56.327
这就是为什么我们要做这么多十六进制的翻译，字节实现一个元256。

6998
11:47:56.424 --> 11:47:59.746
每个商店看到的增量就像一个数组从0开始。

6999
11:47:59.746 --> 11:48:09.342
例如，我们的下一个全局变量或者下一个存储变量被分配到下一个可用的槽位上。

7000
11:48:09.424 --> 11:48:21.281
举个例子，金条从它们的公牛版本2，十六进制中转换过来我们把bool变量修改为真值X版的真布尔值0x001。

7001
11:48:21.281 --> 11:48:29.620
每次保存一个额外的全局变量，或者更准确地说，保存一个存储变量时，它都会占用一个额外的存储槽。

7002
11:48:29.620 --> 11:48:44.714
那长度是动态的，或者可以改变长度的变量呢?那动态的东西呢?对于动态值，比如动态数组，或者映射数组中的元素或者映射中的元素实际上是用某种类型的哈希函数存储的。

7003
11:48:44.714 --> 11:48:53.281
你可以在文档中看到那些特定的函数，对象本身会占用一个存储槽，但它不会是整个数组。

7004
11:48:53.281 --> 11:49:06.282
例如，我的数组变量，在存储槽2处，并没有整个数组在存储槽2处，实际上只有数组的长度，数组的长度存储在存储槽2处。

7005
11:49:06.282 --> 11:49:17.591
但举个例子，如果我们用数组。push 222，我们会做一些哈希函数，你可以在文档中看到那是什么，我们会存储数字222。

7006
11:49:17.591 --> 11:49:26.328
在存储的那个位置，222的十六进制是0x0000d，所以它被存储在这个疯狂的位置。

7007
11:49:26.425 --> 11:49:32.780
这很好，这是有意的，因为32字节可能不足以存储数组如果数组变得很大。

7008
11:49:32.780 --> 11:49:42.691
把数组里的元素放在后面的数字里是没有意义的因为数组的大小是可以改变的你永远不知道你需要多少子序列。

7009
11:49:42.691 --> 11:49:46.942
对于我的数组，它有一个存储槽来存放映射的长度。

7010
11:49:46.942 --> 11:49:50.809
它也有一个存储点类似于数组，但它是空白的。

7011
11:49:50.809 --> 11:50:00.118
但它故意是空白的，这样固体就知道，这里有一个映射，它需要一个存储槽来正确地连接函数功。

7012
11:50:00.118 --> 11:50:06.070
有趣的是，常量变量和不可变变量不会在存储中占据位置。

7013
11:50:06.070 --> 11:50:14.358
这是因为常量变量实际上是契约字节码本身的一部分，这听起来有点奇怪。

7014
11:50:14.425 --> 11:50:23.065
但是你可以想象固体的作用是当它看到常量变量名称时它就会自动把它和它实际的数字交换。

7015
11:50:23.065 --> 11:50:29.186
你可以把not in storage看作是一个指向123的指针它不占用存储槽。

7016
11:50:29.186 --> 11:50:36.358
当函数中有变量时，这些变量只在函数的持续时间内存在。

7017
11:50:36.425 --> 11:50:38.334
他们不会停留在合同内。

7018
11:50:39.425 --> 11:50:40.511
它们不是永久的。

7019
11:50:42.425 --> 11:50:46.025
比如new var和其他var不会被添加到存储中。

7020
11:50:46.426 --> 11:50:48.783
被添加到自己的内存数据结构中。

7021
11:50:49.426 --> 11:50:51.700
在函数运行完成后删除。

7022
11:50:52.426 --> 11:51:00.587
我们会问，为什么我们需要这个memory关键字，特别是当它涉及到字符串时，我们之前看到我们必须说字符串内存。

7023
11:51:00.587 --> 11:51:06.360
字符串需要它的原因是字符串技术上是动态大小的数组。

7024
11:51:06.426 --> 11:51:13.019
我们需要告诉固体性，嘿，我们要在存储位置做这个，或者我们要把它做到内存位置在那里我们可以擦除它。

7025
11:51:13.019 --> 11:51:15.671
数组和映射会占用更多的空间。

7026
11:51:15.671 --> 11:51:26.171
所以慢慢地，只是想确定，我们在哪里处理它存储是一个内存，你必须告诉我，我需要知道我是否需要在我们的存储数据结构中为它分配空间。

7027
11:51:26.171 --> 11:51:29.104
再说一次，这里的所有东西你都可以在固体性文档中读到。

7028
11:51:29.104 --> 11:51:40.273
在与这门课相关的GitHub回购中，如果你去契约，我们实际上有一个契约示例部分叫做Fun with storage，在那里你可以玩和看很多东西。

7029
11:51:40.273 --> 11:51:59.926
我们甚至写了一个叫deploy storage fun的小脚本，它会打印出一些不同变量的存储位置，你可以试试，如果你想挑战任何人写一些函数来找到数组元素的存储槽，以及映射，然后找到其中的数据。

7030
11:51:59.926 --> 11:52:05.583
我们在这里使用一个叫Get storage app的函数，它允许我们在任意一个槽处获得存储。

7031
11:52:05.583 --> 11:52:10.942
这是为了加强这一点即使你有一个私有或内部的功能。

7032
11:52:10.942 --> 11:52:12.619
任何人都可以阅读。

7033
11:52:12.619 --> 11:52:15.551
任何人都能从区块链上读出任何东西。

7034
11:52:15.551 --> 11:52:21.376
你可以测试它如果你自己克隆或复制粘贴代码。

7035
11:52:21.426 --> 11:52:27.328
然后您可以运行纱线部分在部署破折号测试标签，存储。

7036
11:52:27.427 --> 11:52:30.367
您将为该存储运行deploy脚本。

7037
11:52:30.427 --> 11:52:39.880
你会看到打印出每个存储槽的存储位置用一个有趣的契约作为例子。

7038
11:52:39.880 --> 11:52:50.998
你当然可能会问，好吧，帕特里克，你为什么要告诉我这些?我们只是想把油价降下来?你为什么要告诉我仓库的事?我之所以告诉你仓库的事。

7039
11:52:50.998 --> 11:52:55.577
无论何时你读写存储，你都要消耗大量的汽油。

7040
11:52:55.577 --> 11:53:00.194
记得我说过，当我们编译代码时，我们把它编译成一些疯狂的奇怪的字节码。

7041
11:53:00.194 --> 11:53:03.268
让我在混音上给你们看看这是什么样子。

7042
11:53:03.268 --> 11:53:06.668
我们去遵从细节，我们可以去字节码。

7043
11:53:06.668 --> 11:53:10.284
我们看到这个奇怪的十六进制对象0，等等等等。

7044
11:53:10.284 --> 11:53:12.749
但我们也看到这些叫做操作码的东西。

7045
11:53:12.749 --> 11:53:15.974
这个字节码代表了这些操作码。

7046
11:53:15.974 --> 11:53:21.099
这些操作码中的每一个都代表这个字节码中所有内容的一小部分。

7047
11:53:21.099 --> 11:53:32.991
事实上，在我们的心帽中，我们可以去工件，构建信息，我们可以看到，我们可以在构建信息中看到这些操作代码，我们可以为操作代码执行命令F或控制F。

7048
11:53:32.991 --> 11:53:36.539
我们可以看到不同合同的操作代码。

7049
11:53:36.539 --> 11:53:39.891
这些操作代码表示机器代码正在做什么。

7050
11:53:39.891 --> 11:53:46.302
它们代表了实际运行代码和处理代码所需要的计算量。

7051
11:53:46.302 --> 11:53:49.314
计算气体的方法是通过这些操作码。

7052
11:53:49.314 --> 11:53:50.953
这里有几个列表。

7053
11:53:50.953 --> 11:53:53.656
但这里我要用这个EVM操作码。

7054
11:53:53.656 --> 11:53:57.777
同样的，在GitHub中有一个与这一课相关的链接。

7055
11:53:57.777 --> 11:54:03.362
如果我们向下滚动，我们可以确切地看到每一个操作码要花费多少。

7056
11:54:03.428 --> 11:54:20.412
举个例子，每次相加，它消耗3个气体，每次相乘，这是5个气体，减去3个气体，我们有所有这些操作代码在函数中消耗不同数量的气体，这是一个样本契约。

7057
11:54:20.412 --> 11:54:24.828
如果我们做加法，每次相加都要消耗3汽油。

7058
11:54:24.828 --> 11:54:29.858
任何时候我们保存到内存中，都会消耗其他操作码的汽油。

7059
11:54:29.858 --> 11:54:33.566
这些操作码加起来显示了我们实际使用了多少汽油。

7060
11:54:33.566 --> 11:54:41.561
现在，让我们来看看这些操作码它们花费了多少钱510 3 3，余额是700。

7061
11:54:41.561 --> 11:54:45.252
所以要达到平衡需要大量的气体。

7062
11:54:45.252 --> 11:54:46.444
让我们继续。

7063
11:54:46.444 --> 11:54:52.028
获取一个帐户代码的侧面是大量的气体复制和帐户代码到内存中。

7064
11:54:52.028 --> 11:55:06.250
但是，我的天啊，这是什么呢?从储存到储存要花一吨汽油，也就是2万汽油，从储存到装载要花800汽油。

7065
11:55:06.250 --> 11:55:14.261
这是两个最重要的操作码s load和s store, s store代表存储负载和存储存储。

7066
11:55:14.261 --> 11:55:19.234
只要其中一个操作码被触发，我们就得花上八万到两万。

7067
11:55:19.234 --> 11:55:23.615
你知道，这里有个大大的星号，因为这可能会改变很多。

7068
11:55:23.615 --> 11:55:28.348
但作为开发人员，我们每次使用存储都要消耗大量的汽油。

7069
11:55:28.348 --> 11:55:54.991
随时与我们合作在储存一些东西,我们想要男孩,这是花了我大量的气体和最好的惯例或确保我们知道我们正在与一个存储变量,我们要花大量的气体是附加一个年代强调正确的在他们面前代表存储正确所以我们说地址资助的数量将会是一个存储变量奇迹是一个存储变量。

7070
11:55:54.991 --> 11:55:57.479
Owner不会是一个存储变量。

7071
11:55:57.479 --> 11:55:58.229
它是不可变的。

7072
11:55:58.229 --> 11:56:01.515
不可变变量的最佳实践是前缀。

7073
11:56:01.515 --> 11:56:05.877
带有I下划线的常量值也不在存储中。

7074
11:56:05.877 --> 11:56:11.445
对于常值，我们希望它们保持上限，就像aggregator v3接口公共价格提要。

7075
11:56:11.445 --> 11:56:14.329
是的，你知道这是一个存储变量。

7076
11:56:14.329 --> 11:56:16.618
我们想在它后面加上一个S下划线。

7077
11:56:16.618 --> 11:56:22.074
我们要再做一点重构，我们适当地添加了这些来更新所有东西。

7078
11:56:22.074 --> 11:56:30.782
所以这里不是owner，而是I下划线owner，开发人员会读到这个，我们会说，这比普通变量便宜多了。

7079
11:56:30.782 --> 11:56:31.683
好的，太好了。

7080
11:56:31.683 --> 11:56:33.106
我要用这个。

7081
11:56:33.106 --> 11:56:35.481
我为我的修饰符下划线为owner。

7082
11:56:35.481 --> 11:56:36.042
太棒了。

7083
11:56:36.042 --> 11:56:40.534
主人在这里吗?在构造函数中。

7084
11:56:40.534 --> 11:56:43.286
我自己的下划线所有者是message。sender。

7085
11:56:43.286 --> 11:56:44.857
价格提要是一个存储变量。

7086
11:56:44.857 --> 11:56:53.357
作为开发者，我们应该在阅读时看到s下划线，然后说，好吧，我们花了很多汽油来存储这个。

7087
11:56:53.429 --> 11:56:53.866
完美的。

7088
11:56:53.866 --> 11:56:54.616
好了,好了。

7089
11:56:54.616 --> 11:56:55.678
让我们继续。

7090
11:56:55.678 --> 11:56:56.053
太好了。

7091
11:56:57.429 --> 11:56:58.095
业主。

7092
11:57:01.429 --> 11:57:14.842
在VS code中?如果你按Command F，或者Ctrl F，然后按下这个向下的箭头，你就能找到并替换所有这些地址，用s下划线地址，替换为Mt。

7093
11:57:14.842 --> 11:57:16.014
像这样打。

7094
11:57:16.014 --> 11:57:19.806
因为我更新了一个，我得到了一个退格，没有。

7095
11:57:19.806 --> 11:57:21.707
现在这些都更新了。

7096
11:57:21.707 --> 11:57:24.300
让我们对资助者做同样的事情。

7097
11:57:24.300 --> 11:57:25.848
让我们到处更新。

7098
11:57:25.848 --> 11:57:27.784
它的出资人就是出资人。

7099
11:57:27.784 --> 11:57:29.332
我们可能在这里加倍了。

7100
11:57:29.430 --> 11:57:30.180
是的。

7101
11:57:30.430 --> 11:57:31.219
让我们撤销它。

7102
11:57:31.219 --> 11:57:33.166
我们已经更新了所有的AI所有者。

7103
11:57:33.430 --> 11:57:35.200
现在它更新了所有的价格信息。

7104
11:57:36.430 --> 11:57:38.365
饲料，我们将更新它与ES价格饲料。

7105
11:57:39.430 --> 11:57:40.414
在这里蜷成一团。

7106
11:57:40.414 --> 11:57:41.304
我们把它撤销。

7107
11:57:41.304 --> 11:57:41.866
好了,好了。

7108
11:57:42.430 --> 11:57:47.938
我们已经更新了这里的所有内容，我们可以向下滚动哦，不好意思，这里也翻倍了。

7109
11:57:47.938 --> 11:57:48.344
对不起。

7110
11:57:48.344 --> 11:57:57.362
我们可以绿色地浏览代码，我们对存储进行读写的次数比我们需要的要多得多。

7111
11:57:57.430 --> 11:58:05.085
这就是我们要讲的取款功能，它似乎对读取和写入存储很可疑。

7112
11:58:05.085 --> 11:58:07.495
让我们看看我们在做什么。

7113
11:58:07.495 --> 11:58:12.160
首先，我可以看到我们在做一个for循环。

7114
11:58:12.160 --> 11:58:17.230
每次我们执行for循环时，我们只是不断地遍历所有这些代码。

7115
11:58:17.230 --> 11:58:35.643
每次我们在这里做一个比较选项时我们都会问，我们的funder index是否小于sfunders。length?S funders。length，这意味着我们的funders数组越长，我们从存储中读取的次数就越多，这非常昂贵。

7116
11:58:35.643 --> 11:58:44.591
我们还会调用这个，天哪，我们从存储中读取很多数据并保存到这个内存变量中，然后用它更新我们的存储变量。

7117
11:58:44.591 --> 11:58:44.784
哇。

7118
11:58:44.784 --> 11:58:52.912
我们从这里的存储中读取大量数据，我们从这里的存储中读取大量数据，然后我们必须重置我们的资助者数组，这是没有办法的。

7119
11:58:52.912 --> 11:58:59.881
这就是我们对存储的读写，我们还可以创建一个取款函数，这更便宜。

7120
11:58:59.881 --> 11:59:06.065
我们来创建一个函数，叫做cheap withdraw。

7121
11:59:06.065 --> 11:59:12.931
这将使用我们刚刚学到的知识，使提款更便宜，更省油。

7122
11:59:12.931 --> 11:59:15.366
我们将保持公共支付。

7123
11:59:15.366 --> 11:59:20.811
如果它是唯一的所有者，我们不会改变任何东西。

7124
11:59:20.811 --> 11:59:26.384
但对于这部分，我们能做什么呢，我们不想一直从存储器中读取。

7125
11:59:26.431 --> 11:59:29.618
我们不希望一直从存储中读取数据。

7126
11:59:29.618 --> 11:59:32.641
我们把读取的存储空间翻倍了。

7127
11:59:32.641 --> 11:59:42.447
相反，我们能做的是，我们可以一次性将整个数组读入内存，然后从内存中读取而不是不断地从存储中读取。

7128
11:59:42.447 --> 11:59:45.269
这将使我们的生活更便宜。

7129
11:59:45.269 --> 11:59:48.559
我们可以创建一个地址数组。

7130
11:59:48.559 --> 11:59:52.481
内存资助者等于s下划线，资助者。

7131
11:59:52.481 --> 12:00:06.511
现在我们开始明白为什么对于函数中的数组和字符串，我们会问，这个内存是存储空间吗?这是什么?我们告诉它，我们希望它是内存因为内存会便宜很多。

7132
12:00:06.511 --> 12:00:13.217
现在我们把它存到我们的资助者那里，哦，注意一下，映射不能在内存中。

7133
12:00:13.217 --> 12:00:13.610
对不起。

7134
12:00:13.610 --> 12:00:16.036
他们太奇怪太古怪了。

7135
12:00:16.036 --> 12:00:18.742
所以洪水现在不能让你这样做。

7136
12:00:18.742 --> 12:00:30.655
但现在我们已经将存储变量保存到内存变量中了，我们可以从这个内存变量中读写，这非常非常便宜，然后在完成后更新存储。

7137
12:00:30.655 --> 12:00:42.075
我们现在要做的是为你写入v6，基金或指数等于0，我们基本上会重写所有东西但只使用这个内存数组。

7138
12:00:42.075 --> 12:00:42.752
代替。

7139
12:00:42.752 --> 12:00:54.522
我们会说funder index小于funders。length而不是s funders。length，然后我们会说funder index + +。

7140
12:00:54.522 --> 12:01:09.466
然后在这里，我们会做几乎完全相同的事情，除了我们会说地址funder = funders，使用我们的内存数组，而不是s, funders有funder index。

7141
12:01:09.466 --> 12:01:14.156
然后我们会说s地址到资金。

7142
12:01:14.156 --> 12:01:16.449
资金等于零。

7143
12:01:16.449 --> 12:01:30.153
我们在这里重置我们的资助者映射，我们用内存变量代替，然后我们要做同样的事情s下划线资助者=新地址数组为零。

7144
12:01:30.153 --> 12:01:49.307
然后我们会做同样的事情bool success，逗号= sowner。callvalue, address这个balance，我们什么都不发送，然后需要success。

7145
12:01:49.307 --> 12:01:57.989
就像那个，抱歉，是声呐上的艾奥娜现在我们有了这个功能我们认为它更便宜，让我们回到我们的测试。

7146
12:01:57.989 --> 12:02:03.333
让我们在这里运行同样的多重测试，但用的是更便宜的函数。

7147
12:02:03.333 --> 12:02:08.776
我知道复制粘贴可能有点麻烦，但我们还是复制整个测试。

7148
12:02:08.776 --> 12:02:18.618
把它粘贴到下面，把名字改一下改为cheap withdraw, testing。完成。

7149
12:02:18.618 --> 12:02:29.718
在这里，在这个巨大的it中，我们要改变的是我们要把提现变成更便宜的提现，剩下的测试是完全一样的。

7150
12:02:29.718 --> 12:02:38.120
有了这个，让我们看看如果我们成功地让提取函数更便宜用更便宜的提取，我们现在把终端分开。

7151
12:02:38.120 --> 12:02:43.718
我们做纱线，艺术帽测试，这将运行我们的气体估计器，因为它现在是启用的。

7152
12:02:43.718 --> 12:02:47.504
当然，我们所有的功能都被破坏了因为我们重新命名了所有的东西。

7153
12:02:47.504 --> 12:02:56.142
所以我们会快速替换出资人，改变出资人，询问出资人。

7154
12:02:56.142 --> 12:03:01.163
然后我们将把价格供给改成询问价格供给。

7155
12:03:01.163 --> 12:03:05.842
那我们有主人吗?我们没有主人，也没有任何地方。

7156
12:03:05.842 --> 12:03:07.653
我们需要改变这个。

7157
12:03:07.653 --> 12:03:09.347
地址到资助金额。

7158
12:03:09.347 --> 12:03:10.750
我们到这里来。

7159
12:03:10.750 --> 12:03:12.734
地址到资助金额。

7160
12:03:12.734 --> 12:03:13.765
adderstone。

7161
12:03:13.765 --> 12:03:14.717
资金充足。

7162
12:03:14.717 --> 12:03:18.004
我们还需要什么来改变价格?我们给资助者定价。

7163
12:03:18.004 --> 12:03:19.348
好吧，我想我们改变了一切。

7164
12:03:19.348 --> 12:03:20.651
好了，现在我们来试试这个测试。

7165
12:03:20.651 --> 12:03:22.032
纱线硬头试验。

7166
12:03:22.032 --> 12:03:23.268
好的，很好。

7167
12:03:23.268 --> 12:03:25.099
一切都过去了。

7168
12:03:25.099 --> 12:03:28.908
我们进行了更便宜的提取测试。

7169
12:03:28.908 --> 12:03:41.536
现在，如果我们看这里的气体输出，我们的气体报告，缩小一点，我们可以看到更便宜的提取和提取之间的区别，我们看到了一些非常有趣的事情。

7170
12:03:41.536 --> 12:03:47.504
这里我们看到，平均来说，我们的廉价提款比我们的常规提款要贵。

7171
12:03:47.504 --> 12:03:55.183
这样做的原因是，如果我们的测试是更便宜的提取，我们只测试了多重提取。

7172
12:03:55.183 --> 12:03:57.966
所以我们不得不重新设置更多的账户。

7173
12:03:57.966 --> 12:04:01.299
但严格来说，这也是它的最大值。

7174
12:04:01.433 --> 12:04:08.814
如果我们比较更便宜的提款的最大值，提款的最大值，看起来更便宜的提款确实更便宜。

7175
12:04:08.814 --> 12:04:35.100
如果我们去到我们的硬帽。配置，我们添加我们的API键回来，我们甚至可以做的是在我们的测试，我们可以从一个单一的资金撤回eath，复制，粘贴它，只是改变撤回为更便宜的撤回，重新运行它与关键，现在做yarn Hardhead测试，我们可以看到确切地多少美元，我们将节省如果我们运行这个在Matic区块链。

7176
12:04:35.100 --> 12:04:39.434
现在我们回去，重新打开气体报告。

7177
12:04:39.434 --> 12:04:43.869
我们可以看到，在最小值的情况下，更便宜的取款实际上会更贵一点。

7178
12:04:43.869 --> 12:04:52.261
这实际上是有道理的，因为如果我们看资金，如果我们只需要在只有一个资助者的情况下取款，那么这个循环只运行一次。

7179
12:04:52.261 --> 12:05:03.014
我们更便宜的提款也会做同样的事情但它会有额外的东西，把它们都装进去，我们看到储蓄，在我们的合同中，我们的资助者越多。

7180
12:05:03.014 --> 12:05:06.991
如此自动，我们可以看到我们几乎没有保存任何东西。

7181
12:05:06.991 --> 12:05:12.719
但如果我再修改一次，再运行一次测试。

7182
12:05:12.719 --> 12:05:16.671
现在我们可以看到人们节省了几分钱。

7183
12:05:16.671 --> 12:05:20.950
这就是我们如何开始优化我们的合同，使其越来越便宜。

7184
12:05:20.950 --> 12:05:22.571
这两美分只是平均水平。

7185
12:05:22.571 --> 12:05:28.466
它甚至没有比较最大值和最大值，最大值的气体量比平均值多很多。

7186
12:05:28.466 --> 12:05:33.885
我们刚学了一大堆东西。

7187
12:05:33.885 --> 12:05:45.967
接下来的部分可能会让你们有些人抓狂因为我们要再重构一次代码如果你不想重构的话你想把所有的测试都留给s下划线你完全可以但是留给其他使用我们应用程序的用户。

7188
12:05:45.967 --> 12:05:53.339
处理s下划线有点恶心实际上会让我们的代码对使用它的人来说更混乱。

7189
12:05:53.339 --> 12:05:57.202
另外，现在所有的状态函数都是公共的。

7190
12:05:57.202 --> 12:06:01.193
实际上内部变量和私有变量也更便宜。

7191
12:06:01.193 --> 12:06:07.181
我们不需要让每一个变量都是公共的，因为任何人都可以从链上读取它们。

7192
12:06:07.181 --> 12:06:20.373
我们还会做一个重构我们会设置这些的可见性为private还是internal，基于它们是否需要为private或internal，然后我们会在函数的底部创建getter。

7193
12:06:20.435 --> 12:06:32.231
最低美元，我们可以公开这个因为我们想让其他人知道我们合同的最低美元是多少，不需要经过仓库，我们的合同的所有者对于其他人或其他合同来说并不重要。

7194
12:06:32.231 --> 12:06:39.265
我们可以把这个设为私有，然后在底部的函数get owner。

7195
12:06:39.265 --> 12:06:54.735
这是一个公共视图，返回我的所有者，把地址变成资助者，因为资助者也可以是私人的。

7196
12:06:54.735 --> 12:07:18.028
在底部，我们会说function, get funder，然后我们会传递一个un236 index, public U, turns，地址，return作为index的资助者，Mt funding的地址也可以是private。

7197
12:07:18.028 --> 12:07:25.145
在底部，我们会创建函数，获取地址和资金。

7198
12:07:25.145 --> 12:07:34.516
这将在公共视图返回下取一个地址，你到56。

7199
12:07:34.516 --> 12:07:43.075
我们将会返还投资人的资金这个做了，这个做了，这个做了。

7200
12:07:43.075 --> 12:07:46.774
然后是价格供给，函数得到价格供给。

7201
12:07:46.774 --> 12:07:56.813
这也将是公共视图，它返回三个界面的汇总tour它将返回因此，我将选择价格feed。

7202
12:07:56.813 --> 12:07:57.255
哦,好的。

7203
12:07:57.255 --> 12:08:07.736
我们这样做的原因是我们想让s有下划线这样我们作为开发人员就能知道，这是一个存储变量，我想在如何与它交互时非常小心。

7204
12:08:07.736 --> 12:08:12.078
但我们不希望与我们的代码交互的人不得不处理这些东西。

7205
12:08:12.078 --> 12:08:16.274
我们想给他们一个有意义的API，简单易读。

7206
12:08:16.274 --> 12:08:19.225
我们在底部添加这些getter函数来完成这个。

7207
12:08:19.225 --> 12:08:30.388
从长远来看，改变可见性也能节省一些汽油，因为我们会从私有变量或内部变量调用，这是更便宜的汽油，当然，我们需要再升级一次测试。

7208
12:08:30.388 --> 12:08:34.805
就像我说的，如果你想只留下S下划线，那完全没问题。

7209
12:08:34.805 --> 12:08:48.029
因此，s下划线价格提要现在将被替换为获取价格提要，s下划线资金金额现在将被替换为获取地址到资金金额。

7210
12:08:48.029 --> 12:08:54.569
现在要改变SW，强调资助者，以获得资助者。

7211
12:08:54.569 --> 12:09:00.029
我们要改变艾奥娜，她们脑子里没有别的东西，我们不需要改变她们。

7212
12:09:00.029 --> 12:09:01.029
我想这就是一切。

7213
12:09:01.029 --> 12:09:06.151
我们只找s下划线，我们看不到，I下划线，我们也看不到。

7214
12:09:06.151 --> 12:09:11.156
让我们再运行一次测试，以确保重构正确。

7215
12:09:11.156 --> 12:09:13.911
看起来我们做得很棒。

7216
12:09:13.911 --> 12:09:16.148
好了，我们刚学到了很多。

7217
12:09:16.148 --> 12:09:18.161
我们对代码进行了大量的重构。

7218
12:09:18.161 --> 12:09:21.469
这里的一切看起来都非常非常好。

7219
12:09:21.469 --> 12:09:24.049
我们可以再做一次气体优化。

7220
12:09:24.049 --> 12:09:32.647
还有一个针对错误的优化就是我们可以将所有的需求更新为。

7221
12:09:32.647 --> 12:09:42.898
因为如果没有require，我们实际上是在存储这个巨大的字符串，这个巨大的文本数组在chain上，这些错误码就便宜多了。

7222
12:09:42.898 --> 12:09:43.667
但这是可选的。

7223
12:09:43.667 --> 12:09:44.643
如果你想这么做的话。

7224
12:09:44.643 --> 12:09:49.826
我们这样做的全部原因是我们要通过样式指南来更新这里的东西。

7225
12:09:49.826 --> 12:10:00.288
我们有public internal private，底部是我们的view斜杠纯函数它们就是我们刚添加的这些getter。

7226
12:10:00.437 --> 12:10:02.130
现在我们的样式看起来很好。

7227
12:10:03.437 --> 12:10:05.402
气体，我们已经学了很多关于储存的知识。

7228
12:10:06.437 --> 12:10:12.216
让我们快速回顾一下我们刚刚学过的东西因为我们已经讲了很多了。

7229
12:10:12.216 --> 12:10:15.737
就像我说的，这是这门课比较难的部分。

7230
12:10:15.737 --> 12:10:22.237
我们希望跨契约执行和事务持久化的任何可变变量。

7231
12:10:22.237 --> 12:10:27.690
我们保存到一个叫做storage的大数组中这个数组的索引是从0开始的。

7232
12:10:27.690 --> 12:10:34.211
第一个变量契约中的第一个值被存储为0。

7233
12:10:34.211 --> 12:10:38.008
下一个被存储为1，以此类推。

7234
12:10:38.008 --> 12:10:55.438
动态数组和映射以及其他动态大小的对象使用特定的哈希函数，您可以在文档中找到这些动态数据结构的元素的位置，以确定内存变量、常量变量和不可变变量不在存储中。

7235
12:10:55.438 --> 12:11:08.919
谈论存储如此重要的一个主要原因是因为从存储中加载的操作码从存储中读取和写入到存储的操作码都非常耗油。

7236
12:11:08.919 --> 12:11:13.771
所以在任何地方，我们都想减少从存储中读取和加载的数量。

7237
12:11:13.771 --> 12:11:19.904
这是最简单的省油方法之一，可以优化我们的代码，使其省油。

7238
12:11:19.904 --> 12:11:23.067
就像我说的，有些气体的东西可能有点棘手，有点令人困惑。

7239
12:11:23.067 --> 12:11:25.341
所以如果你不能马上明白，也没关系。

7240
12:11:25.438 --> 12:11:26.295
完全没问题。

7241
12:11:28.438 --> 12:11:35.861
比如，他在说什么?就像我说的，这是一些更高级的东西它会出现的，你对坚固性做的越多，你对这里的一切做的越多。

7242
12:11:35.861 --> 12:11:37.126
所以不要让它给你带来压力。

7243
12:11:37.126 --> 12:11:38.994
不要让它阻止你继续前进。

7244
12:11:38.994 --> 12:11:41.995
你在这里做得很好。

7245
12:11:41.995 --> 12:11:42.683
到目前为止。

7246
12:11:42.683 --> 12:11:46.647
我们已经编写了一些非常好的单元测试。

7247
12:11:46.647 --> 12:11:49.469
现在让我们编写一些分段测试。

7248
12:11:49.469 --> 12:11:53.728
这些是我们可以在实际的测试网上使用的测试。

7249
12:11:53.728 --> 12:12:01.871
这个测试是在我们部署了一些代码后运行的只是为了看看一切是否都按照我们想要的方式运行。

7250
12:12:01.871 --> 12:12:03.882
我们来创建一个新文件。

7251
12:12:03.882 --> 12:12:06.326
我们就叫它资助我吧。

7252
12:12:06.326 --> 12:12:09.659
网点分期网点试验，网点j s。

7253
12:12:09.659 --> 12:12:13.628
它看起来和我们刚才在单元测试中做的很像。

7254
12:12:13.628 --> 12:12:15.929
我们假设这是在一个测试网上。

7255
12:12:15.929 --> 12:12:27.930
这些是我们要运行的测试，就在我们把它部署到主网之前，这是你们开发旅程的最后一步，我们要确保在实际的测试网上一切都大致正确地运行。

7256
12:12:27.930 --> 12:12:41.554
我们要做的是我们要做同样的事情描述，资助我，我要快速地过一遍这些测试，因为我们之前基本上写过这种类型的测试，所以我们会说，在每个之前，它将是一个async。

7257
12:12:41.554 --> 12:12:42.419
函数。

7258
12:12:42.419 --> 12:12:46.403
我们将做与单元测试相同的事情。

7259
12:12:46.403 --> 12:12:56.989
我们会有一个Funmi变量，我们会有我们的let Deployer，我们会有我们的常量send value =醚。

7260
12:12:56.989 --> 12:12:57.739
跑龙套。

7261
12:12:57.739 --> 12:13:03.596
Rs的醚(1)在这里，我们要做const。

7262
12:13:03.596 --> 12:13:05.262
获取命名帐户。

7263
12:13:05.439 --> 12:13:18.105
= require hardhats，我们会说，deployer = weight，获取命名帐户，我们会把它括起来，点deployer。

7264
12:13:18.105 --> 12:13:25.216
我们会说fun me = await醚。get contract。

7265
12:13:25.439 --> 12:13:38.045
我，逗号，我们将把它连接到部署器，我们不会部署这个，我们不会像单元测试中那样做任何fixture，因为在分段测试中，我们假设它已经部署在这里了。

7266
12:13:38.045 --> 12:13:49.852
我们也不需要模拟因为在一个阶段中，我们假设我们在一个测试网络上，现在我们可以包装整个东西来确保我们在一个测试网络上通过使用我们的helper配置。

7267
12:13:49.852 --> 12:13:58.032
在寻找我们的开发链时，我们可以说我们只在开发链上运行我们的description位。

7268
12:13:58.032 --> 12:14:01.117
首先，我们说const。

7269
12:14:01.117 --> 12:14:08.891
开发链等于需求，我们会把那个助手配置拉进来。

7270
12:14:08.891 --> 12:14:14.507
我们会说，development chains。includes network。name。

7271
12:14:14.507 --> 12:14:27.358
我们会说if开发者链包含network。name，我们会跳过实际上我们可以用这个跳过，我们会用一个叫做三元运算符的东西它基本上就像一个if语句。

7272
12:14:27.358 --> 12:14:29.790
你可以把它看作F的一种特殊类型。

7273
12:14:29.790 --> 12:14:32.832
我有一个链接到这个和GitHub回购与这门课相关。

7274
12:14:32.832 --> 12:14:36.725
下面是一些JavaScript文档，展示了它的实际应用。

7275
12:14:36.725 --> 12:14:39.797
你说，好，返回是成员。

7276
12:14:39.797 --> 12:14:43.225
如果是真的，就给2美元。

7277
12:14:43.440 --> 12:14:45.100
否则有一个B $10。

7278
12:14:45.100 --> 12:14:47.062
差不多就是这样了。

7279
12:14:47.440 --> 12:14:58.226
另一种思考方式是，你说，让变量等于真，然后我们可以说，让某个var等于变量问题。

7280
12:14:58.226 --> 12:15:02.455
是吗?还是没有?有些var最终会是Yes。

7281
12:15:02.455 --> 12:15:04.472
因为变量为真。

7282
12:15:04.472 --> 12:15:07.593
如果variable为false，那么一些var将为no。

7283
12:15:07.593 --> 12:15:14.159
字面意思是，如果变量，那么某个var等于yes。

7284
12:15:14.159 --> 12:15:14.773
其他的事情。

7285
12:15:14.773 --> 12:15:20.423
var等于不，这些直线实际上是完全一样的。

7286
12:15:20.423 --> 12:15:22.079
这个更简洁一点。

7287
12:15:22.079 --> 12:15:22.915
真的是这样。

7288
12:15:22.915 --> 12:15:24.588
这就是这个算子的作用。

7289
12:15:24.588 --> 12:15:27.524
我们会说开发链包括network。name。

7290
12:15:27.524 --> 12:15:34.725
如果我们的网络是一个发展链，我们也会从硬帽和醚中引入网络。

7291
12:15:34.725 --> 12:15:45.265
然后我们会做被跳过的描述这告诉我们的测试跳过这整个描述，然后我们会在这里放这个小冒号然后保存。

7292
12:15:45.265 --> 12:16:01.566
现在我们只会在不在开发链上的情况下运行这个，我们想使用完全相同的语法，我们会在这里进行单元测试，我们会做完全相同的事情，我们会粘贴它会让它相反通过在这里打一个小结，插入冒号。

7293
12:16:01.566 --> 12:16:07.801
所以现在，我们的单元测试只在开发链上运行在我们的分期测试中，只在测试网络上运行。

7294
12:16:07.801 --> 12:16:08.325
完美的。

7295
12:16:08.325 --> 12:16:14.012
这就是我们想要的，允许人们投资，拥有和提取。

7296
12:16:14.012 --> 12:16:25.474
这当然是一个async函数，我们可以让它很健壮，但我们只说await, fundme。fund将会发送一个值。

7297
12:16:25.474 --> 12:16:30.155
然后我们说我身上的重量。撤回。

7298
12:16:30.155 --> 12:16:33.583
CERT等于require try。

7299
12:16:33.583 --> 12:16:48.114
现在我们来做一个蹩脚的最后一个，我们说const ending balance等于一个weight on me。provider。get balance, fundme。address。

7300
12:16:48.114 --> 12:16:53.118
然后我们说assert。= ending balance。

7301
12:16:53.118 --> 12:17:02.405
to string，逗号0作为字符串，我们只会在测试网络上运行这个，我只会再运行一次，向你们展示它的实际操作。

7302
12:17:02.405 --> 12:17:12.141
请再次跳过这部分，因为我们将使用一个测试网，我将运行纱线，硬帽部署dash测试网Rinkeby。

7303
12:17:12.141 --> 12:17:16.241
它将贯穿我们的部署。

7304
12:17:16.241 --> 12:17:33.942
在它全部部署之后，我们将运行我们的阶段测试，以确保在真实测试网络上，即使有价格提要，一切都能工作，我需要执行const development chains = require。。斜杠。斜杠helper heart config。

7305
12:17:33.942 --> 12:17:40.924
现在对于run yarn, hard hat测试，我们将看到我们的单元测试被运行。

7306
12:17:40.924 --> 12:17:49.312
但如果我们用纱线来测试Rinkeby的dash网络，我们不会进行9个测试，我们只会进行单独的阶段测试。

7307
12:17:49.312 --> 12:17:55.526
当然，这要慢得多，因为我们是在一个测试网上。

7308
12:17:55.526 --> 12:18:03.651
Net会写所有这些测试，我们可以写一些脚本。

7309
12:18:03.651 --> 12:18:23.330
然后我们会把这个推到GitHub上让它成为我们的第一个智能合约GitHub仓库，当涉及到区块链时，当涉及到智能合约时，与社区互动与开源互动作为GitHub的一部分，或git实验室或任何你正在使用的git托管服务在这里是成功的关键。

7310
12:18:23.330 --> 12:18:24.775
让我们来写脚本。

7311
12:18:24.775 --> 12:18:28.114
然后我们上传到GitHub开始建立我们的投资组合。

7312
12:18:28.114 --> 12:18:33.196
首先，我们要创建一个脚本来与我们的代码fund。js交互。

7313
12:18:33.196 --> 12:18:36.242
这和我们的测试非常相似。

7314
12:18:36.242 --> 12:18:37.652
这样，在未来。

7315
12:18:37.652 --> 12:18:46.323
如果我们想要快速地为我们的合同提供资金，我们可以运行这个，我们可以做到，我们会做我们一直在做的相同的事情，我们会做一个async函数main。

7316
12:18:46.323 --> 12:18:51.204
下面，我要复制粘贴这个因为我们会经常用到复制粘贴。

7317
12:18:51.204 --> 12:18:54.156
我们把这个语法粘贴到这里。

7318
12:18:54.156 --> 12:18:58.308
所以让我们写一个脚本，让我们能够为我们的合同提供资金。

7319
12:18:58.308 --> 12:19:13.073
首先，我们需要const get命名帐户就像我们在测试中一样，equals require arhat我们会说const Deployer。

7320
12:19:13.073 --> 12:19:18.276
等价者等待着尚未命名的账户，就像这样。

7321
12:19:18.276 --> 12:19:26.693
然后我们说const fund me = await ethers。get contract。

7322
12:19:26.693 --> 12:19:29.146
从资金通信部署。

7323
12:19:29.146 --> 12:19:46.443
和我们的测试几乎完全一样，然后我们会做一个console。log funding contract然后我们会做const transaction response = await funding。fund。

7324
12:19:46.443 --> 12:19:55.849
对于这个值，我们会用ethers。utils来解析ether (0)

7325
12:19:55.849 --> 12:20:00.943
1或者别的什么，不管你想做什么，我们当然需要导入醚，看起来我们已经有了。

7326
12:20:00.943 --> 12:20:06.026
我们写await transaction response。wait for one transaction。

7327
12:20:06.026 --> 12:20:19.376
然后我们会做console。log funding，我们可以运行yarn运行这个小脚本，RT head node运行一个本地节点部署所有契约。

7328
12:20:19.376 --> 12:20:29.246
我们将通过运行yarn，硬帽运行脚本基金。j s破折号网络localhost来看看我们的脚本看起来是否ok。

7329
12:20:29.246 --> 12:20:32.278
而且看起来资金不错。

7330
12:20:32.443 --> 12:20:36.765
现在我们写一个提取脚本提取那个js。

7331
12:20:37.443 --> 12:20:43.120
甚至可以让我们的本地主机节点继续运行，因为我们将撤回我们刚刚资助它的资金。

7332
12:20:43.120 --> 12:20:45.720
我们要做完全相同的设置。

7333
12:20:45.720 --> 12:21:03.395
我们甚至可以复制这个主位到我们的withdraw，顶部会做async函数main会说const deployer = await，得到命名帐户，哇，我按下回车，我的VS code自动导入了它，这很好。

7334
12:21:03.444 --> 12:21:08.116
也许你的也会，也许不会如果它不会，你只需要把它写出来或者从另一个复制粘贴。

7335
12:21:08.116 --> 12:21:13.824
然后我们会做cars Funmi = await醚。get contract on me，当然。

7336
12:21:13.824 --> 12:21:16.300
这是完全一样的。

7337
12:21:16.300 --> 12:21:35.027
现在我们要写console。log funding data。我们说const transaction response = await on v。withdraw, await transaction response。wait 1，然后是console。log。

7338
12:21:35.027 --> 12:21:36.377
明白了吗?回来。

7339
12:21:36.377 --> 12:21:47.321
我们可以通过运行yarn，硬打运行脚本，提取破折号网络localhost来测试这个，我们会看到它是否有效。

7340
12:21:47.321 --> 12:21:50.391
很好，我们的剧本开始运作了。

7341
12:21:50.391 --> 12:21:53.777
Fantastic以惊人的速度写出了两个剧本。

7342
12:21:53.777 --> 12:22:00.088
现在我们有了一种方法，可以通过脚本轻松地与代码和契约进行交互。

7343
12:22:00.088 --> 12:22:09.056
在我们把这些很棒的代码推到GitHub之前我还想讲一点。JSON。

7344
12:22:09.056 --> 12:22:21.037
我之前已经向您展示了一些这方面的内容，但是我们可以添加这个脚本部分，使我们的工作变得容易得多，并将所有这些长时间的测试压缩为一个yarn脚本。

7345
12:22:21.037 --> 12:22:31.559
通常，在common package。JSON中，你会看到一个列表供人们查看，然后自动运行，其中最常见的是test。

7346
12:22:31.559 --> 12:22:35.335
为了进行测试，我们要做纱线，硬帽测试。

7347
12:22:35.335 --> 12:22:42.805
所以现在不是运行纱线，硬头测试，有人可以直接来到你的包，一旦它被保存，只运行纱线测试。

7348
12:22:42.805 --> 12:22:49.953
这将从你的脚本部分获取这个测试，它将运行yarn heart at test和Bada bing, Bada boom，好的，酷。

7349
12:22:49.953 --> 12:23:01.880
我们还想在这里做什么呢?我们可能需要一个测试阶段来运行硬头纱测试dash dash和Rinkeby网络。

7350
12:23:01.880 --> 12:23:03.208
我不打算运行它。

7351
12:23:03.208 --> 12:23:07.945
但这可能是我们想要的东西，我们可能需要一些毛线。

7352
12:23:07.945 --> 12:23:11.087
我们给你们简单展示了一下绒毛的事情。

7353
12:23:11.087 --> 12:23:16.361
所以我们会有一个纱线线头，它会运行纱线，鞋底提示。

7354
12:23:16.445 --> 12:23:20.122
然后我们就有了合约文件夹。

7355
12:23:20.445 --> 12:23:22.445
任何从灵魂开始的东西。

7356
12:23:24.445 --> 12:23:32.195
它会运行灵魂提示，这里所有的代码它会在这里给我们一些警告，我们几乎都可以忽略。

7357
12:23:32.195 --> 12:23:39.887
梭伦实际上有一个自动修复，我们可以添加自动修复，通过做纱线修复，我们会说纱线。

7358
12:23:39.887 --> 12:23:43.315
提示一下，合同一开始就砍了。

7359
12:23:43.315 --> 12:23:45.831
我们用破折号固定。

7360
12:23:45.831 --> 12:23:52.169
现在我们运行纱线，绒线修复，它会自动修复，没有什么可以自动修复的。

7361
12:23:52.169 --> 12:23:53.159
所以什么都没发生。

7362
12:23:53.159 --> 12:23:54.587
但无论如何，拥有它是件好事。

7363
12:23:54.587 --> 12:24:05.430
然后我们可以使用我们的formatter，我们会格式化我们的代码格式，它会做yarn, pretty, dash, write to，我们会用一个句点来做所有的事情。

7364
12:24:05.430 --> 12:24:07.612
然后我们可以做纱线格式。

7365
12:24:07.612 --> 12:24:13.833
它会解决我们所有的，它会解决我们的一切，这很好。

7366
12:24:13.833 --> 12:24:16.547
然后我们就能有保险了。

7367
12:24:16.547 --> 12:24:25.446
通过运行纱线的硬帽覆盖，现在我们可以运行纱线的覆盖，会给我们这个美妙的小覆盖报告。

7368
12:24:25.446 --> 12:24:25.979
太棒了。

7369
12:24:25.979 --> 12:24:28.245
所以我们的包装看起来很棒。

7370
12:24:28.446 --> 12:24:30.463
也许我们还会讲到package json。

7371
12:24:31.446 --> 12:24:31.890
的名字。

7372
12:24:31.890 --> 12:24:34.667
我们称它为安全帽。

7373
12:24:38.446 --> 12:24:39.571
就是你的名字。

7374
12:24:41.446 --> 12:24:45.334
我们会在这里给出一个版本。

7375
12:24:45.334 --> 12:24:45.889
为1。

7376
12:24:45.889 --> 12:24:47.666
0点哦，糟糕。

7377
12:24:48.446 --> 12:24:51.253
让我们用图标代替空格。

7378
12:24:53.446 --> 12:24:54.906
我们不使用ES lint。

7379
12:24:57.446 --> 12:24:59.913
我们可以删除纱线点锁，重新安装。

7380
12:25:00.446 --> 12:25:00.867
无论什么。

7381
12:25:00.867 --> 12:25:02.972
我们没有自述，不过没关系。

7382
12:25:03.446 --> 12:25:11.736
想回去，就像我说的，去看看最好的自述模板，去更新你的自述模板，让它们看起来像这样棒，你也可以这么做。

7383
12:25:11.736 --> 12:25:16.334
但除此之外，我们还有一个很棒的代码回购。

7384
12:25:16.334 --> 12:25:23.429
我们要怎么处理它?我们在GitHub上花了太多时间，我们一直在研究所有这些好的中心。

7385
12:25:23.429 --> 12:25:28.612
是时候加入GitHub和我们自己的第一个存储库了。

7386
12:25:28.612 --> 12:25:39.981
让我们继续，让我们在第七课完整区块链固体课程中实现它，是的，有一个链接到这个GitHub快速入门，我们将遵循它来建立我们的第一个存储库。

7387
12:25:39.981 --> 12:25:47.836
这将是你开始构建作品集的时刻，而GitHub对你的开发之旅至关重要。

7388
12:25:47.836 --> 12:25:55.007
这将是你的门户网站，你会在这里说，嘿，看看我参与的所有很酷的产品，我正在与之合作，我正在参与其中。

7389
12:25:55.007 --> 12:26:00.603
如果你之前已经做过GitHub，我强烈建议你仍然把它推到GitHub，作为你做过的证明。

7390
12:26:00.603 --> 12:26:04.161
然后你也可以在推特上对我说，嘿，看看我已经走了多远。

7391
12:26:04.161 --> 12:26:22.947
看看我都做了什么，看看我学习智能合约有多棒，现在要兴奋得不得了，这个快速入门将带你创建一个存储库，创建一个分支，教授所有这些东西，我们将遵循GitHub文档中的说明，向GitHub添加本地托管代码，我们已经有了一个项目，我们正在推进它。

7392
12:26:22.947 --> 12:26:52.259
因为Windows用户用的是WsL，你只需要遵循Mac或Linux的说明，我们要做的第一件事是在你的GitHub配置文件中，或者在你的GitHub登录中，我们会点击这个小加号，点击新存储库，你想叫它什么都行，我们叫它hard hat, fund me b code camp，你可以写个描述，从编码营学习，Patrick，关于智能合约。

7393
12:26:52.447 --> 12:26:56.990
我们会把它公开，因为我们想让其他人看到你很出色，学习智能合约。

7394
12:26:56.990 --> 12:27:00.266
我们让它保持空白，然后点击创建存储库。

7395
12:27:00.266 --> 12:27:02.528
现在，这是我们的公共代码库。

7396
12:27:02.528 --> 12:27:08.184
这是我们的第一个，如果你已经做过这些，这将是你的第一个智能合约。

7397
12:27:08.184 --> 12:27:23.056
它甚至还有一些说明，教我们如何从命令行创建一个新的存储库，你可以按照这个来做，或者像这样我们要做的第一件事是初始化一个git分支。

7398
12:27:23.056 --> 12:27:26.395
从你应该已经安装Git的时候开始。

7399
12:27:26.448 --> 12:27:29.930
记住，你可以通过运行git的破折号版本来检查。

7400
12:27:29.930 --> 12:27:33.555
Git和GitHub有点不同，Git被称为版本控制。

7401
12:27:33.555 --> 12:27:39.706
它允许我们对代码进行更改，但保留所有代码更改的历史。

7402
12:27:39.706 --> 12:27:44.585
GitHub是一个我们可以推送所有这些更改并跟踪所有代码的地方。

7403
12:27:44.585 --> 12:27:48.026
我们要做的第一件事是创建一个新的分支。

7404
12:27:48.026 --> 12:27:51.743
我不会太深入地解释Git以及如何使用Git。

7405
12:27:51.743 --> 12:27:57.792
但是如果你想了解Git Free Code Camp，当然有一个针对初学者的Git和GitHub视频。

7406
12:27:57.792 --> 12:28:05.781
我们会用gitinitdash bmain创建这个新分支，现在你的Visual Studio代码会自动开始格式化一些东西。

7407
12:28:05.781 --> 12:28:06.747
如果有，那就太好了。

7408
12:28:06.747 --> 12:28:08.431
如果没有，也不用担心。

7409
12:28:08.431 --> 12:28:22.605
但在左边你会看到有些东西是绿色的，有些东西是灰色的，打开那个。Git ignore，你会看到所有灰色的东西都是我们在这个。Git ignore里的东西这是有意的，这是我们想要的。

7410
12:28:22.605 --> 12:28:27.512
这只是一些突出显示，嘿，这些绿色的东西是你在GitHub上使用的。

7411
12:28:27.512 --> 12:28:30.227
这些灰色的东西是你没有和GitHub合作的东西。

7412
12:28:30.227 --> 12:28:31.040
这就是我们想要的。

7413
12:28:31.040 --> 12:28:43.988
你不需要推送工件、现金、覆盖率或节点模块，人们可以在自己的机器上安装和编译，如果我们使用Dotty和V，我们肯定不想推送我们的Dotty和V。

7414
12:28:43.988 --> 12:28:48.601
我们不需要推高coverage。JSON，其他的我们都需要。

7415
12:28:48.601 --> 12:29:13.913
接下来，在初始化主分支之后，你现在应该能在终端上运行gitstatus看到这个巨大的红色输出所有这些没有被跟踪的东西，我们没有任何提交，我们现在能做的是我们可以用gitaddperiod标记所有代码，然后用gitcommit提交，我们会一次运行一个而不是一起运行。

7416
12:29:13.913 --> 12:29:24.311
在运行git add之前，我也会将部署添加到这个列表中，因为GitHub并不需要知道我所做的所有不同的部署，特别是当我对本地主机进行大量部署时，它们不需要知道。

7417
12:29:24.311 --> 12:29:29.370
我们将把它添加到，然后运行gitadd。

7418
12:29:29.449 --> 12:29:39.017
如果我们做一个git状态，我们可以看到我们所有的代码都被分阶段提交了作为代码历史的一部分。

7419
12:29:39.017 --> 12:29:46.367
然后快速浏览一下这些文件确保你的。E和V文件不在这里。

7420
12:29:46.449 --> 12:30:05.234
现在我们要运行gitcommit dash m然后是这个提交的消息，我们会运行gitcommit dash m，我们可以说，初始提交，或者在这个消息中你想要的任何东西，first commit, initial commit，管它呢，它会说，创建模式，等等等等，所有这些文件。

7421
12:30:05.234 --> 12:30:09.855
如果我们调用gitstatus，它在branch main上是空白的，没什么要提交。

7422
12:30:09.855 --> 12:30:11.754
然后你可能会得到这样的结果。

7423
12:30:11.754 --> 12:30:15.489
如果您在自动添加您的姓名和电子邮件之前从未使用过Git。

7424
12:30:15.489 --> 12:30:17.563
我们有点困惑了。

7425
12:30:17.563 --> 12:30:20.120
我们马上会讲到这个。

7426
12:30:20.120 --> 12:30:24.629
接下来，我们能做的是复制GitHub回购的URL。

7427
12:30:24.629 --> 12:30:29.606
你可以通过复制这里或顶部的URL来获取它。

7428
12:30:29.606 --> 12:30:33.110
我们要做的是添加这个作为远程回购。

7429
12:30:33.110 --> 12:30:33.836
要做到这一点。

7430
12:30:33.836 --> 12:30:39.932
我们执行gitremote add，给这个远程回购起个名字。

7431
12:30:39.932 --> 12:30:40.496
对我们来说。

7432
12:30:40.496 --> 12:30:44.788
我们写上origin，然后把URL粘贴到这里。

7433
12:30:44.788 --> 12:30:48.314
我们现在说原点远程回购是好的。

7434
12:30:48.450 --> 12:30:57.417
在这个URL处，我们运行git remote dash v，我们可以看到取回的原点repo在这个分支处。

7435
12:30:57.417 --> 12:31:00.926
push的原点回购也在这个分支。

7436
12:31:00.926 --> 12:31:05.678
当我们想获取新代码时，获取代码会从这里获取它。

7437
12:31:05.678 --> 12:31:09.116
如果我们想把代码往上推，我们想把代码给GitHub。

7438
12:31:09.116 --> 12:31:10.873
我们也会从这里开始。

7439
12:31:10.873 --> 12:31:14.387
现在我们用那个远程URL设置了新的远程。

7440
12:31:14.387 --> 12:31:17.958
现在我们要把这些改变推送到github。

7441
12:31:17.958 --> 12:31:18.212
com。

7442
12:31:18.212 --> 12:31:26.139
我们的方法是用gitpush，我们选择要推送到哪个远程，我们会推送原点。

7443
12:31:26.139 --> 12:31:34.842
然后我们要推到哪个分支我们要推到缅因州，它可能会提示你输入用户名和密码，可能是你的电子邮件等。

7444
12:31:34.842 --> 12:31:38.917
如果身份验证不适合你，你可以切换到设置。

7445
12:31:38.917 --> 12:31:52.387
或者如果你向下滚动到开发者设置，个人访问令牌并创建生成新的令牌，一些令牌，给自己回购访问权，写访问权，然后点击生成令牌。

7446
12:31:52.450 --> 12:31:54.550
并尝试使用这个令牌作为您的密码。

7447
12:31:55.450 --> 12:32:03.111
使用GitHub文档和与本课程相关的GitHub讨论，如果你迷路了或某些东西不工作，如这里所示。

7448
12:32:03.111 --> 12:32:13.183
但一旦完成，一旦你正确地添加了所有的信息，你就会回到你的get，你会有你的第一个GitHub回购，所有的代码和所有的东西都像这样。

7449
12:32:13.183 --> 12:32:18.028
一旦你完成了这一步，一旦你做到了，你绝对应该庆祝。

7450
12:32:18.028 --> 12:32:24.631
如果你愿意，你可以在区块链社区拍摄一个推特网页三个社区绝对是这个协作空间。

7451
12:32:24.631 --> 12:32:28.090
所以Twitter加密是很多人聚集在一起分享想法的地方。

7452
12:32:28.090 --> 12:32:32.766
所以一定要庆祝和分享，非常非常兴奋。

7453
12:32:32.766 --> 12:32:34.054
然后发这样的推特。

7454
12:32:34.054 --> 12:32:41.029
和你的朋友击掌，在Twitter上分享，在Discord上分享，在Reddit上分享，为你所取得的成就感到兴奋，我们还有很多事情要做。

7455
12:32:41.029 --> 12:32:46.608
但通过完成这一部分，你已经做得很好了，我很高兴你开始下一部分。

7456
12:32:46.608 --> 12:32:51.705
现在，我们不打算讲TypeScript的附加内容因为这里没有什么新内容。

7457
12:32:51.705 --> 12:33:00.308
但是，如果你想要看到TypeScript，请随时进入与本课程相关的GitHub存储库。

7458
12:33:00.451 --> 12:33:01.293
好的,太棒了。

7459
12:33:03.451 --> 12:33:04.466
心曾逗过我。

7460
12:33:07.451 --> 12:33:14.744
这将是我们的HTML / JavaScript来资助我，你可以在我的GitHub回购上找到我们将要讲到的所有代码。

7461
12:33:14.744 --> 12:33:24.723
在这一节中，我们将开始了解Node js后端JavaScript和浏览器中的JavaScript或前端JavaScript之间的区别。

7462
12:33:24.723 --> 12:33:32.143
如果你来到与本课相关的GitHub回购，我们的主版本将使用被认为是更好的前端JavaScript。

7463
12:33:32.143 --> 12:33:41.140
但如果有些前端JavaScript让人困惑，我们也不会添加JS，你们很快就会明白我说的这些区别是什么意思。

7464
12:33:41.140 --> 12:33:44.924
现在，人们可以在任何时候通过编程与我们的智能合约进行交互。

7465
12:33:44.924 --> 12:33:48.031
然而，我们的大多数用户都不是竞争对手。

7466
12:33:48.031 --> 12:33:54.403
所以我们需要创建一个网站，我们需要创建一个用户界面让他们与我们的智能合约和协议进行交互。

7467
12:33:54.403 --> 12:33:58.778
这就是这一节要教我们的，它会介绍如何构建这些全栈。

7468
12:33:58.778 --> 12:34:01.515
在智能合约的基础上构建这些前端。

7469
12:34:01.515 --> 12:34:05.701
现在，我想向你们展示当我们完成它的时候，它实际上是什么样子的。

7470
12:34:05.701 --> 12:34:11.652
因为在这里，我们要做我们的第一个前端我们的第一个网站使用区块链使用web 3。

7471
12:34:11.652 --> 12:34:14.387
这将是一个极简的网站。

7472
12:34:14.387 --> 12:34:20.434
正如你在这里看到的，我们不会有任何样式，我们只会向你展示如何获得功能。

7473
12:34:20.434 --> 12:34:26.665
此外，我们将做一些不建议的事情，绝对不是最佳实践。

7474
12:34:26.665 --> 12:34:33.092
我们这样做的原因和在数学课上一样，在你们学习导数的技巧之前，先学习导数是什么。

7475
12:34:33.092 --> 12:34:38.807
我们首先是这样教的，这样当你与网站互动时，你就能理解网站上发生了什么。

7476
12:34:38.807 --> 12:34:39.887
当你和他们一起工作时。

7477
12:34:39.887 --> 12:34:45.402
我们已经在Foston身上看到了，触摸连接我们的钱包和水龙头的链接。

7478
12:34:45.452 --> 12:34:53.920
所有去中心化的应用程序都有这个网站，有这样的设置，你可以连接你的钱包，然后通过点击按钮进行交互，这些按钮会调用区块链的函数。

7479
12:34:53.920 --> 12:34:57.346
这将是我们的极简网站，正是这样做的。

7480
12:34:57.346 --> 12:35:00.735
所以这一节将会教你在引擎盖下发生了什么。

7481
12:35:00.735 --> 12:35:04.706
因此，您可以真正理解如何在专业级别上构建这些应用程序。

7482
12:35:04.706 --> 12:35:13.404
对于这一部分，如果你不想跟我一起写代码，你完全可以不写但是，跟我一起写代码肯定会把所有东西都刻在你的记忆里。

7483
12:35:13.452 --> 12:35:16.639
这就是应用程序的样子。

7484
12:35:17.452 --> 12:35:29.102
网站，它连接到我们的硬帽子，我们的本地区块链，但它会像在真正的测试网络上一样运行，你会注意到的第一件事是在我们的元掩码中，我们没有连接。

7485
12:35:29.102 --> 12:35:36.658
点击连接，元掩码会弹出问我们是否想连接，我们会连接到它。

7486
12:35:36.658 --> 12:35:39.536
现在我们可以在Funmi和我们的心脏互动了。

7487
12:35:39.536 --> 12:35:46.833
你会注意到这里的两个按钮是我们很熟悉的函数，我们有提现函数，这是我们刚刚创建的提现函数。

7488
12:35:46.833 --> 12:35:56.733
当然，我们这里还有基金功能，我们推送或发送Aetherium或Matic或其他原生区块链代币到智能合约。

7489
12:35:56.733 --> 12:35:58.276
我们可以通过这个用户界面来实现。

7490
12:35:58.276 --> 12:36:04.927
连接好后，如果我们想看到平衡，我们可以右键点击，点击检查，来到控制台。

7491
12:36:04.927 --> 12:36:10.961
我们将把智能合约的当前余额打印到JavaScript控制台。

7492
12:36:10.961 --> 12:36:15.703
现在还没有人资助这个项目，我们可以降低，我们可以选择我们想要资助的金额。

7493
12:36:15.703 --> 12:36:17.203
例如，0。

7494
12:36:17.203 --> 12:36:23.713
1，每个，我们继续，我们点击基金，元面具会弹出，我们会得到一个小委员会说，基金与0。

7495
12:36:23.713 --> 12:36:23.773
1.

7496
12:36:23.773 --> 12:36:28.786
它会给我们发送0所需的所有事务细节。

7497
12:36:28.786 --> 12:36:32.436
在我们的智能合约中，我们可以点击确认。

7498
12:36:32.436 --> 12:36:39.523
在它被确认之后在我们本地区块链上被开采之后，我们得到了平衡，我们现在看到它是0。

7499
12:36:39.523 --> 12:36:39.610
1.

7500
12:36:39.610 --> 12:36:46.065
我们可以再次调用fund，我们可以有多个出资人，我们可以在不同的账户和不同金额的基金之间切换。

7501
12:36:46.065 --> 12:36:50.357
我们可以看到资金金额的增加，然后我们可以调用退出函数。

7502
12:36:50.357 --> 12:36:54.846
只要我们是所有者，我们就可以确认我们可以从融资合同中取出所有的钱。

7503
12:36:54.846 --> 12:36:55.927
我们会得到平衡。

7504
12:36:55.927 --> 12:36:58.082
现在我们将看到余额重置为零。

7505
12:36:58.082 --> 12:37:00.162
这就是我们要建的东西。

7506
12:37:00.162 --> 12:37:01.405
你准备好了吗?我当然是。

7507
12:37:01.453 --> 12:37:02.380
让我们开始吧。

7508
12:37:04.453 --> 12:37:05.514
网站与web三。

7509
12:37:07.453 --> 12:37:09.843
我们的GitHub回购，所以请随时关注那里。

7510
12:37:10.453 --> 12:37:17.185
如果你心里想的是Funmi dash Free Code Camp repo，我们仍然想要打开这个。

7511
12:37:17.185 --> 12:37:22.323
但我们还需要创建一个新的Visual Studio代码来处理新的repo。

7512
12:37:22.323 --> 12:37:25.673
让我们向下CD一个目录。

7513
12:37:25.673 --> 12:37:33.372
输入mkdir，将其命名为HTML，资助我免费代码营。

7514
12:37:33.372 --> 12:37:34.617
我们会讲到的。

7515
12:37:34.617 --> 12:37:37.561
我们输入代码period来打开它。

7516
12:37:37.561 --> 12:37:44.388
你也可以做File Open Folder，但我们只想在一个新的Visual Studio Code中打开它。

7517
12:37:44.388 --> 12:37:56.335
新的VS代码会弹出，但在我们翻到那个之前，我们想要CD下CD回到硬帽的乐趣，我们免费的代码营地，因为我们仍然会使用这里的所有东西。

7518
12:37:56.335 --> 12:38:08.389
在使用这个文件夹和这个回购的智能合约中，当你建立daps或连接到区块链的网站时，你通常会有两个存储库或回购。

7519
12:38:08.454 --> 12:38:10.660
一个是智能合约，就像我们在这里看到的。

7520
12:38:10.660 --> 12:38:13.875
这是我们的回购，它拥有智能合约的所有代码。

7521
12:38:13.875 --> 12:38:16.695
然后你也会有一个前端斜杠网站。

7522
12:38:16.695 --> 12:38:21.025
它将是这两个回购的组合，它们组成了完整的堆栈。

7523
12:38:21.025 --> 12:38:37.267
当人们说到全栈时，他们说的是智能合约，这是我们的后端，加上HTML / JavaScript /网站，这是我们的前端。

7524
12:38:37.267 --> 12:38:42.604
智能合约是后端，HTML / JavaScript /网站是我们的前端。

7525
12:38:42.604 --> 12:38:44.204
所以我们已经有了后路。

7526
12:38:44.204 --> 12:38:51.628
现在我们要建立我们的前端，我们要保持它因为我们需要它来测试和我们的前端交互。

7527
12:38:51.628 --> 12:38:52.135
太棒了。

7528
12:38:52.135 --> 12:38:56.120
我们现在有了这个新文件夹，HTML Funmi, Free Code Camp。

7529
12:38:56.120 --> 12:39:01.863
这门课不是一门如何学习前端的课程，我们会教你一些前端的概念。

7530
12:39:01.863 --> 12:39:18.821
但如果你想学习完整的传统前端课程，还是那句话，你可以看看Free Code Camp，他们有很多很棒的教程，我教你前端，如果你继续跟我学，你肯定会对前端和前端有一个基本的了解以及它与智能合约的关系。

7531
12:39:18.821 --> 12:39:22.405
此外，您不必做前端部分或整个堆栈部分。

7532
12:39:22.455 --> 12:39:33.245
如果你只想上这门课，学习后端，学习JavaScript，学习稳定性，学习如何以编程方式执行智能合约，那么你完全可以跳过这些前端部分。

7533
12:39:33.245 --> 12:39:41.061
然而，如果你想学习如何建立令人兴奋的网站，并且你想让除了开发人员之外的其他人与你的协议进行交互，你肯定想要观看这一部分。

7534
12:39:41.061 --> 12:39:44.005
在我们开始写代码之前。

7535
12:39:44.005 --> 12:39:50.355
当使用使用区块链的这些网站之一时，我们需要了解到底发生了什么。

7536
12:39:50.355 --> 12:39:53.094
我最近做了一个关于这个的视频。

7537
12:39:53.094 --> 12:40:04.190
让我们快速看一段视频，这样我们就能更快地了解这些与区块链互动的网站背后到底发生了什么。

7538
12:40:04.190 --> 12:40:05.322
好吧。

7539
12:40:05.322 --> 12:40:13.008
所以我们在这里，有一个网站或前端，在一些我们已经部署的智能合约之上，现在它是什么并不重要。

7540
12:40:13.008 --> 12:40:19.582
这是典型的界面，你会看到浓缩到一个非常非常简单的水平。

7541
12:40:19.582 --> 12:40:28.946
通常，你会看到像连接功能，Metamask，或其他钱包连接器之类的东西会弹出，我们会点击，Next，我们会连接这里甚至会说，连接。

7542
12:40:28.946 --> 12:40:33.418
我们还可以执行函数，我们可以与智能合约交互，我们可以确认等等。

7543
12:40:33.455 --> 12:40:40.995
对吧?这是你可能会看到的比如Avi我点击应用程序上的连接，它会说，嘿，你想如何连接?我会选择Metamask。

7544
12:40:40.995 --> 12:40:47.901
我要把我的Metamask改成main net，但你们明白了吧?这是一个简单的例子。

7545
12:40:47.901 --> 12:40:57.170
那么当我们连接时浏览器中到底发生了什么呢?我们需要做的是，右键点击，点击检查。

7546
12:40:57.170 --> 12:41:01.122
在右边，我们会看到调试器在这里。

7547
12:41:01.122 --> 12:41:07.601
现在如果我们转到资源，在浏览器的顶部，你会看到一些东西。

7548
12:41:07.601 --> 12:41:15.656
如果你往下看这里，我们会看到这个URL，它现在将是我的localhost。

7549
12:41:15.656 --> 12:41:19.578
我们还会看到元蒙版和幻影和一大堆其他的东西。

7550
12:41:19.578 --> 12:41:24.973
我们在这里看到的其他东西将是从浏览器扩展中注入的。

7551
12:41:24.973 --> 12:41:33.406
我们看到这个元蒙版的原因是因为我安装了元蒙版?我在这里看到Phantom的原因是因为我安装了Phantom应用程序。

7552
12:41:33.456 --> 12:41:38.813
Meta面具，当然，是一个EVM，钱包和幻影是一个基于索拉纳的钱包。

7553
12:41:38.813 --> 12:41:57.520
安装了这些扩展后会发生什么它们会自动注入到JavaScript中的窗口对象中，我们向下滚动到控制台这里，你可以找到控制台，你可以点击这里，点击上面的任何东西。

7554
12:41:57.520 --> 12:41:59.294
我们输入window。

7555
12:41:59.456 --> 12:42:13.836
我们会看到有一个大窗口对象和所有这些东西，对吧?这个窗口对象代表了我们的窗口?现在，如果我们一直滚动到底部，我们做window。Aetherium。

7556
12:42:13.836 --> 12:42:15.978
我们在这里也看到了一个物体。

7557
12:42:15.978 --> 12:42:29.579
这个window。Aetherium对象只存在于你有一个元掩码或者像browser这样的元掩码或者如果你想看其他的web3wallet你可以用window。Solana。

7558
12:42:29.579 --> 12:42:32.407
右边是Alana我们看到这个窗口点了Solana。

7559
12:42:32.407 --> 12:42:36.403
现在让我们看看一个没有安装Metamask或phantom的浏览器。

7560
12:42:36.457 --> 12:42:40.494
你认为窗口中会发生什么现在让我们继续右键点击检查。

7561
12:42:40.494 --> 12:42:41.931
我们去控制台。

7562
12:42:41.931 --> 12:42:44.507
现在让我们看看这里发生了什么。

7563
12:42:44.507 --> 12:42:49.190
如果我们去查资料，我们首先我们没有在这里看到超元面具或索拉纳的资料。

7564
12:42:49.190 --> 12:42:53.837
如果我们到控制台，我们仍然能看到窗口如果我放大一点。

7565
12:42:53.837 --> 12:42:55.027
我们仍然可以看到窗户。

7566
12:42:55.027 --> 12:43:01.878
但如果我做window。Aetherium如果我们什么都得不到，或者如果我做window。Solana，我们也什么都得不到。

7567
12:43:01.878 --> 12:43:14.211
为了让浏览器知道有一个Metamask，或者有一个幻影，这些扩展会自动将这些添加到窗口对象中，这是我们可以在JavaScript中检查的。

7568
12:43:14.211 --> 12:43:21.653
这些钱包如此重要的原因是内置在它们的底层，它们有一个区块链节点连接到它们。

7569
12:43:21.653 --> 12:43:25.178
为了和区块链互动，我们总是需要一个笔记。

7570
12:43:25.178 --> 12:43:37.974
你可能在alchemy或FIRA看到过url，因为你需要它们与区块链交互，alchemy和infura都是第三方区块链的例子，你可以与它们交互，基本上可以租用它们。

7571
12:43:37.974 --> 12:43:43.149
但是您需要它们来创建一个提供程序，或者一个将事务发送到的节点。

7572
12:43:43.149 --> 12:43:53.769
你可以用JavaScript来做，比如这是炼金术文档你把炼金术URL，插入到某个对象中然后用它来发送你的事务。

7573
12:43:53.769 --> 12:43:56.832
这是一种可以在后端完成的方法。

7574
12:43:56.832 --> 12:44:04.957
但在前端，你通常想要使用的是你只想使用用户的Metamask，或他们的Solana或他们的钱包作为主要钱包。

7575
12:44:04.957 --> 12:44:11.362
现在，有很多其他不同类型的钱包可以连接，比如ledger、mu、Coinbase、wallet、connect等。

7576
12:44:11.362 --> 12:44:14.232
有不同的方法来设置它们。

7577
12:44:14.232 --> 12:44:22.000
但它们的作用都是一样的，它们暴露了一些URL，它们暴露了一些底层节点，它们给了我们那个URL。

7578
12:44:22.000 --> 12:44:23.830
他们给了我们提供者。

7579
12:44:23.830 --> 12:44:27.879
metamath的方法是用window。Aetherium。

7580
12:44:27.879 --> 12:44:29.910
这就是我们的URL。

7581
12:44:29.910 --> 12:44:32.151
这就是我们的联系。

7582
12:44:32.151 --> 12:44:40.208
事实上，如果你走到Metamask，点击那三个小点，展开视野。

7583
12:44:40.208 --> 12:44:44.828
点击添加网络，然后点击X，我们就可以进入网络了。

7584
12:44:44.828 --> 12:44:55.569
你可以看到我在这里的所有这些区块链都有一个RPC URL，这是HTTP RPC URL连接的区块链，不，它在运行。

7585
12:44:55.569 --> 12:44:59.299
我刚好有一台在本地运行。

7586
12:44:59.458 --> 12:45:05.186
所有这些都有一个节点RPC URL你可以在你的元掩码中看到它们。

7587
12:45:05.186 --> 12:45:08.919
这个连接到Fira，这些都连接到Fira。

7588
12:45:08.919 --> 12:45:10.716
都是一样的东西。

7589
12:45:10.716 --> 12:45:20.505
Meta mask可以很好地获取URL，并将其粘贴到浏览器中在window。Aetherium或window。Solana中等等。

7590
12:45:20.505 --> 12:45:22.867
这是我们需要知道的最主要的东西。

7591
12:45:22.867 --> 12:45:25.333
我们总是需要和区块链联系。

7592
12:45:25.333 --> 12:45:28.627
而这些浏览器钱包就是一种简单的方法。

7593
12:45:28.627 --> 12:45:29.734
有意义吗?太好了。

7594
12:45:29.734 --> 12:45:31.672
让我们现在就来学习这些知识。

7595
12:45:31.672 --> 12:45:33.232
我们来应用它。

7596
12:45:33.232 --> 12:45:36.909
在这里，让我们快速自述一下。

7597
12:45:36.909 --> 12:45:37.102
医学博士。

7598
12:45:37.102 --> 12:45:40.064
这样我们就可以谈谈我们要做什么了。

7599
12:45:40.064 --> 12:45:47.408
在这一节中，我们将使用原始HTML / JavaScript结合智能合约来构建这个网站。

7600
12:45:47.459 --> 12:45:48.001
稍后。

7601
12:45:52.459 --> 12:45:54.666
现代堆栈来建立我们的网站。

7602
12:45:55.459 --> 12:46:02.901
首先理解如何用HTML和JavaScript做所有的事情，会让我们以后的工作变得容易得多。

7603
12:46:02.901 --> 12:46:07.859
但正如我们所知，所有的网站都使用HTML作为他们看起来的脚手架。

7604
12:46:07.859 --> 12:46:13.104
我们来为网站创建HTML，命名为index。HTML。

7605
12:46:13.104 --> 12:46:20.878
这将是我们网站的基本框架或者说基本骨架。

7606
12:46:20.878 --> 12:46:33.125
在VS code中，如果你输入感叹号index。HTML，然后点击第一个弹出的东西，它会自动填充你的代码你的文件用一些基本的HTML设置。

7607
12:46:33.125 --> 12:46:42.249
如果它没有为你做这个，请随意从与这门课程相关的GitHub存储库中复制粘贴基本设置，我们有我们的文档类型。

7608
12:46:42.249 --> 12:46:47.785
HTML，我们有一些HTML标记告诉我们这中间的所有东西都将是HTML，这很好。

7609
12:46:47.785 --> 12:46:50.310
然而，为了简单起见，我们不需要这些内容中的大部分。

7610
12:46:50.310 --> 12:46:52.295
我们要让它简单一点。

7611
12:46:52.295 --> 12:46:55.131
我们要删除这条线，这条线和这条线。

7612
12:46:55.131 --> 12:46:58.180
我们要改标题来资助我的应用。

7613
12:46:58.180 --> 12:47:02.371
然后在我们的身体内部，我们可以做一些事情，比如，你好。

7614
12:47:02.371 --> 12:47:06.901
现在我们有了用这个来创建一个网站的基本框架。

7615
12:47:06.901 --> 12:47:10.426
要在网站上展示这个，我们可以做两件事中的一件。

7616
12:47:10.426 --> 12:47:16.131
如果您正在使用Visual Studio代码，我将建议您安装扩展活动服务器。

7617
12:47:16.131 --> 12:47:17.069
它看起来像这样。

7618
12:47:17.069 --> 12:47:23.910
我将有这个扩展的扩展ID在GitHub库中与这门课程相关，这将允许我们很容易地旋转一个HTML网站。

7619
12:47:23.910 --> 12:47:26.168
我们继续安装这个。

7620
12:47:26.168 --> 12:47:30.052
如果你不用Visual Studio Code，我马上会给你展示另一种方法。

7621
12:47:30.052 --> 12:47:35.270
一旦安装了这个，你应该在底部有一个小的go live按钮。

7622
12:47:35.270 --> 12:47:48.227
如果没有，你可以打开你的命令面板，你可以点击视图命令面板打开，你可以输入live server然后说open with live server我们只需要点击这个go live按钮。

7623
12:47:48.227 --> 12:47:54.348
它会说开始它会用index。HTML打开你的浏览器。

7624
12:47:54.348 --> 12:47:58.543
我们的网站叫Save on 1207。

7625
12:47:58.543 --> 12:47:59.293
0,0。

7626
12:47:59.293 --> 12:47:59.376
1.

7627
12:47:59.376 --> 12:48:05.348
这被称为环回，或本地主机端点，我们在端口5501上。

7628
12:48:05.348 --> 12:48:11.015
如果你不熟悉这些端口，现在不用担心，这里有index。HTML。

7629
12:48:11.015 --> 12:48:15.348
如果我们把这个改成what's good，点击保存。

7630
12:48:15.348 --> 12:48:18.991
如果它没有自动刷新，我们会到这里刷新。

7631
12:48:18.991 --> 12:48:20.495
我们可以在这里看到。

7632
12:48:20.495 --> 12:48:26.755
如果你以前从未创建过网站，你基本上已经做过了，恭喜你，你可能会得到这个。

7633
12:48:26.755 --> 12:48:27.673
Vs代码文件夹。

7634
12:48:27.673 --> 12:48:27.804
一个。

7635
12:48:27.804 --> 12:48:37.994
vs code文件夹允许你为你正在处理的回购做专门的设置，为你的vs code的代码编辑器做专门的设置，但我们现在会忽略它。

7636
12:48:37.994 --> 12:48:43.266
如果你不用Visual Studio Code，你能做的就是在浏览器中运行这个。

7637
12:48:43.266 --> 12:48:47.443
你能做的一件事就是右键点击它，我用的是Mac。

7638
12:48:47.443 --> 12:48:51.593
在Finder中点击显示，也就是显示它的位置。

7639
12:48:51.593 --> 12:48:54.788
你可以双击它，嘣，它就在你的浏览器里运行了。

7640
12:48:54.788 --> 12:49:00.022
它不是指向你的本地主机，而是直接指向你的本地文件路径。

7641
12:49:00.022 --> 12:49:03.558
现在我们可以做的最后一个版本我强烈建议你们不要做。

7642
12:49:03.558 --> 12:49:10.601
但这是另一种选择，我们会为你下载一个不使用Jas的包，它允许我们提供HTTP。

7643
12:49:10.601 --> 12:49:18.936
我们会像安装其他包一样安装它，我们可以用yarn，添加破折号dev HTTP连字符服务器。

7644
12:49:18.936 --> 12:49:22.296
你可能仍然想要添加它。

7645
12:49:22.461 --> 12:49:31.222
现在，我们会得到这个HTTP服务器包的一些节点模块，我们会得到一个package json，当然，还有一个yarn。lock。

7646
12:49:31.222 --> 12:49:35.430
我们能做的就是停止下面的这个，停止运行中的服务器。

7647
12:49:35.430 --> 12:49:38.936
回到网站，刷新，现在是空白。

7648
12:49:38.936 --> 12:49:41.558
我们可以运行yarn HTTP服务器。

7649
12:49:41.558 --> 12:49:43.815
这个也会做同样的事情。

7650
12:49:43.815 --> 12:49:47.810
如果我们过来，我们刷新一下，我们会看到什么是好的。

7651
12:49:47.810 --> 12:49:50.211
现在这个有点挑剔。

7652
12:49:50.211 --> 12:49:56.898
在你做了改变之后，比如，嘿，有什么好，你可能需要关闭它，然后重新打开它，然后刷新它。

7653
12:49:56.898 --> 12:50:04.409
我强烈建议，如果你用的是Visual Studio代码，你一定要用这个go live按钮，因为它会更好地反映你的更改。

7654
12:50:04.461 --> 12:50:05.880
让我们继续，点击go Live按钮。

7655
12:50:07.461 --> 12:50:08.147
弹出。

7656
12:50:08.147 --> 12:50:09.225
好的,很酷。

7657
12:50:12.461 --> 12:50:17.917
标题当然是Funmi app，我们可以在标题部分看到。

7658
12:50:17.917 --> 12:50:25.788
让我们更新这个HTML，让它有那些按钮，它就能连接和使用我们的区块链和任何区块链。

7659
12:50:25.788 --> 12:50:30.045
在HTML中你还能做的一件事是你可以在HTML中编写JavaScript。

7660
12:50:30.045 --> 12:50:36.106
我们可以通过做这个脚本标签，然后我们做一个结束脚本标签。

7661
12:50:36.106 --> 12:50:40.651
script标签里面的任何东西都是JavaScript。

7662
12:50:40.651 --> 12:50:46.806
我可以写console。log，加上一堆惊叹号，我要保存它。

7663
12:50:46.806 --> 12:50:52.675
我们会回到我们的前端，我们会右击，我们会点击检查，我们会到控制台。

7664
12:50:52.675 --> 12:51:02.747
我们可以看到Hi打印出来，我们刷新，我们可以看到Hi从script标签打印出来，我们保存它，我们移回去，我们看到Hi从script标签打印出来。

7665
12:51:02.747 --> 12:51:05.494
我知道有点小。

7666
12:51:05.494 --> 12:51:06.655
让我放大。

7667
12:51:06.655 --> 12:51:07.622
好了,好了。

7668
12:51:07.622 --> 12:51:17.033
我们可以在这里输入JavaScript，它在script标签的内部我们将在这里编写JavaScript来编写前端将与之交互的函数。

7669
12:51:17.033 --> 12:51:25.332
现在，正如我们之前看到的，在这个小控制台，我们可以检查窗口点以太，看看Metamask或安装。

7670
12:51:25.332 --> 12:51:29.526
再说一次，我们正在使用的很多东西实际上都在Metamask文档中。

7671
12:51:29.526 --> 12:51:40.774
如果你去他们的基础部分，他们会讲一点提供者，也就是这个窗口。Aetherium，你可以在元掩码文档中读到如何直接与元掩码交互。

7672
12:51:40.774 --> 12:51:48.620
现在使用window。Aetherium只是我们连接区块链的方法之一，实际上有多种方法因为有多种不同的钱包。

7673
12:51:48.620 --> 12:51:54.190
但现在，我们只打算假装窗口点Aetherium和元蒙版是唯一的扩展。

7674
12:51:54.190 --> 12:51:57.494
所以我们要做的是检查Aetherium的风是否存在。

7675
12:51:57.494 --> 12:51:59.890
这是我们应该做的第一件事。

7676
12:51:59.890 --> 12:52:08.203
因为如果这个不存在，这意味着它们不能连接到区块链，我们要做的第一件事之一是我们要检查它是否存在。

7677
12:52:08.203 --> 12:52:18.319
我们可以这样做如果我们可以说Aetherium不等于的窗口类型为undefined。

7678
12:52:18.319 --> 12:52:22.985
然后我们用console。log，我看到一个元掩码。

7679
12:52:22.985 --> 12:52:28.005
所以现在如果我们保存，我们回到我们的前端，我们确实看到了一个超掩模。

7680
12:52:28.005 --> 12:52:37.708
我有一个没有Metamask的谷歌Chrome，如果我们在控制台中查看，我们点击刷新它，我们的实时服务器正在运行的相同URL。

7681
12:52:37.708 --> 12:52:42.383
我没有看到元掩码因为它没有看到元掩码。

7682
12:52:42.383 --> 12:52:43.335
我们可以做别的。

7683
12:52:43.463 --> 12:52:50.479
console。log，没有元掩码刷新，我们仍然看到ICD一个元掩码，我们有一个元掩码。

7684
12:52:50.479 --> 12:52:55.807
你不需要打开一个浏览器，但我们看到Chrome没有元掩码，因为它没有元掩码。

7685
12:52:55.807 --> 12:53:19.025
现在我们能做的是，我们可以自动尝试连接到元掩码如果我们看到有一个元掩码，对吧?记得之前，当我们点击连接按钮时，元掩码会弹出，说，你确定要连接吗?我们能做的是，你能在meta mask文档中找到这个，我们能运行这个eath request accounts方法，这基本上是我们连接Metamask的方式。

7686
12:53:19.025 --> 12:53:23.479
现在，这是由一个新的EIP和一个旧的文档指定的。

7687
12:53:23.479 --> 12:53:27.790
在较早的教程中，您可能会看到Aetherium dot enable，它实际上做了完全相同的事情。

7688
12:53:27.790 --> 12:53:34.987
所以我们能做的是，我们可以说，一个铈，不好意思，窗口。Aetherium。请求。

7689
12:53:34.987 --> 12:53:39.379
我们可以让方法F请求账户。

7690
12:53:39.379 --> 12:53:41.712
我们把它保存起来。

7691
12:53:41.712 --> 12:53:51.775
现在回到浏览器，我们会看到，你会看到Metamask，它会弹出，让我们连接，我们可以选择一个账户。

7692
12:53:51.775 --> 12:53:56.903
点击连接，会自动将元掩码连接到网站。

7693
12:53:56.903 --> 12:54:01.157
现在如果我们看我们的元蒙版，我们可以看到这个连接的小东西。

7694
12:54:01.157 --> 12:54:04.413
它说我们的一号账户现在连接到我们的网站上了。

7695
12:54:04.463 --> 12:54:11.689
这意味着网站现在可以对我们的元掩码进行API调用，我们仍然必须是批准他们的人。

7696
12:54:11.689 --> 12:54:16.939
但它可以继续连接并尝试运行事务，这很好，这是我们想要的。

7697
12:54:16.939 --> 12:54:21.026
如果你想断开连接，我们可以点击那个小按钮，点击断开这个账户。

7698
12:54:21.026 --> 12:54:27.226
我们现在的代码是每当我们点击刷新，这个就会弹出这非常烦人。

7699
12:54:27.226 --> 12:54:38.078
我们要做的是把它包装成一个异步函数，和我们之前做的完全一样，我们会创建一个叫Connect的异步函数。

7700
12:54:38.078 --> 12:54:40.971
我们把这里的花括号括起来。

7701
12:54:40.971 --> 12:54:44.316
然后我们把它格式化一下，让它看起来更好看。

7702
12:54:44.316 --> 12:54:48.655
现在保存，回到网站，刷新。

7703
12:54:48.655 --> 12:54:51.293
然后我们继续断开连接。

7704
12:54:51.464 --> 12:55:00.928
如果我们刷新Metamask不会一直问我们，你想连接吗，你想连接这里吗，你想连接吗，因为我们需要调用这个连接函数我们可以在这里添加一个小按钮。

7705
12:55:00.928 --> 12:55:06.141
在script标签下面，我们会添加一个button标签。

7706
12:55:06.141 --> 12:55:07.480
这是打开按钮标签。

7707
12:55:07.480 --> 12:55:09.153
这是关闭按钮标签。

7708
12:55:09.153 --> 12:55:15.526
在开始按钮标签声明中，我们会给它一个ID，它将是Connect button。

7709
12:55:15.526 --> 12:55:22.089
我们写上onclick = Connect connections函数。

7710
12:55:22.089 --> 12:55:30.498
我们将这个按钮命名为connect在这些小按钮标签之间，我们将它命名为connect当我们点击它时，它会调用connect函数。

7711
12:55:30.498 --> 12:55:35.412
保存，回到前端，我们可以看到有一个连接按钮。

7712
12:55:35.464 --> 12:55:41.946
现在如果我们按连接，Metamask会弹出，我们点击next，像这样连接。

7713
12:55:41.946 --> 12:55:44.064
嘭，现在我们连在一起了。

7714
12:55:44.064 --> 12:55:49.498
我们甚至可以在这里执行一点await等待它完成后再继续。

7715
12:55:49.498 --> 12:55:54.683
连接之后，我们可以说console。log connected。

7716
12:55:54.683 --> 12:55:59.115
让我们来测试一下，我们回到Metamask。

7717
12:55:59.115 --> 12:56:03.600
我们会在这里断开连接，如果没有必要的话，尽量不要上主网。

7718
12:56:03.600 --> 12:56:07.328
运行连接，点击下一个连接。

7719
12:56:07.465 --> 12:56:10.965
现在我们看到一个小的console。log显示为connected。

7720
12:56:10.965 --> 12:56:11.631
好了,好了。

7721
12:56:11.631 --> 12:56:14.152
我们也可以相应地更新我们的网站。

7722
12:56:14.152 --> 12:56:17.339
这样我们就可以让用户知道我们是联网的。

7723
12:56:17.465 --> 12:56:22.947
我们可以抓取connect button元素ID并在连接后说我们已连接。

7724
12:56:22.947 --> 12:56:33.368
等待连接后，我们可以执行document。getelement by ID Connect button。

7725
12:56:33.368 --> 12:56:40.431
然后我们说。inner HTML = connected，像这样。

7726
12:56:40.431 --> 12:56:44.412
而不是在这里说不最小化，我们会做相反的事情。

7727
12:56:44.412 --> 12:56:45.858
我们复制这一行。

7728
12:56:45.858 --> 12:56:51.723
我们说的不是连接，而是请安装元掩码。

7729
12:56:51.723 --> 12:56:55.846
然后保存回到前端，点击连接。

7730
12:56:55.846 --> 12:56:59.915
如果我们已经连接了，它就会自动变成连接。

7731
12:56:59.915 --> 12:57:02.350
如果我们没有连接，它会弹出，我们会连接起来。

7732
12:57:02.350 --> 12:57:04.990
现在我们有了这个按钮，上面写着连接，这很好。

7733
12:57:04.990 --> 12:57:08.101
现在我们已经知道我们是有联系的。

7734
12:57:08.101 --> 12:57:12.955
我们已经把超元面具连接到前端了。

7735
12:57:12.955 --> 12:57:16.215
现在我们要在这里做一些函数。

7736
12:57:16.215 --> 12:57:24.015
这是我们想要创建更多功能和按钮的地方它们将使用我们非常熟悉的包。

7737
12:57:24.015 --> 12:57:28.111
现在，当我们编码的时候，我们的脚本部分会变得越来越大，越来越大。

7738
12:57:28.111 --> 12:57:32.666
通常情况下，我们希望把代码放在JavaScript文件中。

7739
12:57:32.666 --> 12:57:38.531
我们继续，到这里来，创建一个新文件，命名为index。js。

7740
12:57:38.531 --> 12:57:47.869
我们不会把JavaScript放在这些脚本标签中，我们会把它放在这个索引中然后把这个索引文件导入到HTML中。

7741
12:57:47.869 --> 12:57:52.415
我们要做的是我们实际上只需要获取这个函数。

7742
12:57:52.466 --> 12:57:54.836
我们要复制它，暂时删除所有内容。

7743
12:57:55.466 --> 12:58:06.014
粘贴到ext。js中，然后在index。HTML中，我们会告诉脚本标签使用index。

7744
12:58:06.014 --> 12:58:06.239
js。

7745
12:58:06.466 --> 12:58:12.887
我们只要说源等于。/下标。js。

7746
12:58:12.887 --> 12:58:20.235
然后我们会说，这个的类型是文本/ JavaScript。

7747
12:58:20.235 --> 12:58:27.207
现在，如果我们保存它，我们保存index。HTML，我们回到前端，我们做一点刷新。

7748
12:58:27.207 --> 12:58:30.672
我们确保我们会继续断开连接。

7749
12:58:30.672 --> 12:58:35.799
再进行一次刷新，即使是在索引中。

7750
12:58:35.799 --> 12:58:39.983
Js在不同文件中，因为我们做的是SRC = index。

7751
12:58:39.983 --> 12:58:46.841
js，我们将它导入到HTML中，当我们点击Connect时，它仍然调用Connect函数。

7752
12:58:46.841 --> 12:58:52.415
这就是我们如何将JavaScript分离到自己的js文件中这是我们比较熟悉的。

7753
12:58:52.466 --> 12:59:09.300
如果你看一下与这门课相关的GitHub回购，以及索引。j，你会看到我们的Connect函数，我们添加了一些生活质量的东西，我们添加了一些try catch来减少处理错误，如果你愿意，你可以自己添加这些try catch。

7754
12:59:09.300 --> 12:59:13.029
但我不会在这个视频中演示它们。

7755
12:59:13.029 --> 12:59:28.263
现在我们要创建有趣的函数。

7756
12:59:28.263 --> 12:59:38.794
之后，我们会创建取款函数。

7757
12:59:38.794 --> 12:59:42.094
这是前端JavaScript代码的地方。

7758
12:59:42.094 --> 12:59:45.057
没有g有一点不同。

7759
12:59:45.057 --> 12:59:54.696
在任何JS中，我们都使用require关键字在前端JavaScript中导入依赖项，但你不能使用require，它也不能正常工作。

7760
12:59:54.696 --> 12:59:59.677
稍后，我们将使用Import关键字，这是更好的方法。

7761
12:59:59.677 --> 13:00:10.534
这是我们的第一个不同点在前端使用Import关键字要比require关键字好得多，特别是因为require关键字实际上不起作用。

7762
13:00:10.534 --> 13:00:14.376
对于那些可能在这种变化中挣扎的人。

7763
13:00:14.376 --> 13:00:32.139
再说一次，在与此相关的GitHub回购中，我们有一个Node js版本，在那里你可以使用require关键字，你只需要通过自述文件下载一些包，运行一些脚本，基本上把使用require的代码转换成使用导入的代码。

7764
13:00:32.139 --> 13:00:36.324
但是我们会教你使用导入来处理前端代码的方法。

7765
13:00:36.324 --> 13:00:45.237
现在你会看到，当我们进入下一个Jas时，我们仍然会从节点模块下载代码，并使用yarn锁和json包等。

7766
13:00:45.237 --> 13:00:49.372
总结一下，我们还是要做纱线添加。

7767
13:00:49.372 --> 13:01:00.731
但在框架之外当我们使用原始JavaScript，原始HTML设置时，就像我们在这里做的，我们不会做yarn, add节点模块会为框架添加节点模块，比如next react。

7768
13:01:00.731 --> 13:01:04.631
但是对于原始JavaScript，我们将使用不同的语法，我很快将向您展示这种语法。

7769
13:01:04.631 --> 13:01:07.175
下面开始构造基金函数。

7770
13:01:07.175 --> 13:01:12.046
为了创造有趣的功能，我们通常会做什么?我们会创建一个叫fund的异步函数。

7771
13:01:12.046 --> 13:01:20.994
在这个函数中，我们可能想要取一些以太作为参数，因为我们想要用一些以太来为它提供资金。

7772
13:01:20.994 --> 13:01:29.991
当我们调用这个函数时，我们可能想运行console。log会在这里做一点字符串插值。

7773
13:01:29.991 --> 13:01:36.855
资金数额，点点点点，这些分号简直要把我逼疯了。

7774
13:01:36.855 --> 13:01:43.419
我要添加一个。pretty。rc文件到这里，我要在这里添加pretty。

7775
13:01:43.468 --> 13:01:45.155
否则我就要疯了。

7776
13:01:46.468 --> 13:01:52.123
Dev，这里是pretty tier，这样我们就可以用pretty tier来格式化JavaScript。

7777
13:01:52.123 --> 13:01:52.226
js。

7778
13:01:52.226 --> 13:02:02.894
我按下command S，它看起来确实是这样的，自动格式化现在，不管分号是什么，我们都可以像调用connect一样调用这个有趣的函数。

7779
13:02:02.894 --> 13:02:06.817
在index。HTML中，我们可能会创建一个新按钮。

7780
13:02:06.817 --> 13:02:07.261
按钮。

7781
13:02:07.261 --> 13:02:15.025
我们给它一个ID fund会说on click = fund。

7782
13:02:15.025 --> 13:02:18.139
我们写上基金。

7783
13:02:18.468 --> 13:02:21.517
这将是我们的按钮，保存，我们看我们的前端。

7784
13:02:21.517 --> 13:02:27.740
调用fund按钮时，我们说funding with undefined因为这里我们没有给它传递一个金额。

7785
13:02:27.740 --> 13:02:34.418
回到我们的index console。log funding with我们要确保我们能调用Funmi函数。

7786
13:02:34.418 --> 13:02:40.119
我们再复制这一行我们写上type of window。Aetherium不等于undefined。

7787
13:02:40.119 --> 13:02:42.822
我们将尝试在这里提供资金来发送交易。

7788
13:02:42.822 --> 13:02:50.115
什么东西是我们绝对永远需要的?我们需要一个到区块链的提供者斜杠连接。

7789
13:02:50.115 --> 13:03:02.296
我们需要一个签名者，一个钱包，一个有汽油的人来发送它，然后我们可能需要与我们交互的合同。

7790
13:03:02.296 --> 13:03:05.759
为了拿到合同，我们需要ABI和地址。

7791
13:03:05.759 --> 13:03:09.287
有了这些，我们可以发送任何事务。

7792
13:03:09.287 --> 13:03:13.598
所以要找到我们的提供者，我们要继续，再次使用醚。

7793
13:03:13.598 --> 13:03:24.294
现在，我们要用稍微不同的方式来做，尽管之前，我们处理醚的方式是我们说const ethers = require ethers。

7794
13:03:24.294 --> 13:03:26.389
这就是我们拉醚的方法。

7795
13:03:26.389 --> 13:03:30.904
就像我刚才说的，require在前面行不通。

7796
13:03:30.904 --> 13:03:34.699
我们不希望用node modules包来安装醚。

7797
13:03:34.699 --> 13:03:39.344
我们能做的是转到乙醚文档。

7798
13:03:39.344 --> 13:03:49.484
如果你去入门部分，向下滚动，他们有一个部分是关于使用Node js导入的，使用require或imports。

7799
13:03:49.484 --> 13:03:54.707
他们也有一些使用网页浏览器的文档。

7800
13:03:54.707 --> 13:04:03.069
我们不使用节点模块，而是将ethers库复制到自己的目录中，然后自己提供服务。

7801
13:04:03.069 --> 13:04:12.728
所以我们要做的是，我们可以到这里，复制这个大文件，也就是醚，但在前端加法，然后回到我们的文件。

7802
13:04:12.728 --> 13:04:16.220
我们在这里新建一个文件。

7803
13:04:16.470 --> 13:04:18.360
叫醚。

7804
13:04:18.360 --> 13:04:19.960
我们做5。

7805
13:04:19.960 --> 13:04:21.560
6点esm。

7806
13:04:21.560 --> 13:04:21.996
分钟。

7807
13:04:21.996 --> 13:04:22.286
js。

7808
13:04:24.470 --> 13:04:26.603
把那个大东西贴在这里。

7809
13:04:28.470 --> 13:04:30.486
当我保存它时，它会自动格式化。

7810
13:04:31.470 --> 13:04:38.012
很大的文件，里面有以太的所有东西，但是如果你愿意的话，前端是违抗的。

7811
13:04:38.012 --> 13:04:41.916
现在我们能做的是把它导入到索引中。

7812
13:04:41.916 --> 13:04:42.094
js。

7813
13:04:42.094 --> 13:04:55.755
这里我们不用require，而是用import ethers然后我们引用刚刚得到的文件ethers dash 5。

7814
13:04:55.755 --> 13:04:57.326
6点esm。

7815
13:04:57.326 --> 13:04:57.754
分钟。

7816
13:04:57.754 --> 13:04:58.039
js。

7817
13:04:58.039 --> 13:05:07.374
现在，我们只需要在HTML JavaScript课程中做文件导入的复制粘贴。

7818
13:05:07.374 --> 13:05:13.142
在未来的课程与Node js，我们将做纱线，添加醚，有点像我们通常看到的。

7819
13:05:13.142 --> 13:05:22.859
像React和我们将要使用的下一个Jas这样的框架将自动将这些纱线添加包转换为前端的五个版本。

7820
13:05:22.859 --> 13:05:26.373
但在这一节中，这是我们导入ethers包的方式。

7821
13:05:26.373 --> 13:05:37.364
现在我们要做的另一件事是在前端，我们要把这个从type text / JavaScript改成type module changes。

7822
13:05:37.364 --> 13:05:45.792
类型模块允许我们将模块导入到代码中，我们会导入这个，我们还会导入另一个模块。

7823
13:05:45.792 --> 13:05:46.437
太棒了。

7824
13:05:46.437 --> 13:05:55.619
现在回到前端，对connect按钮做一点刷新，我们得到connect is not defined at HTML button。

7825
13:05:55.619 --> 13:05:55.767
上。

7826
13:05:55.767 --> 13:06:06.304
点击，这里我们不从前端调用Connect按钮，我们要从index。HTML中移除这些点击，进入index。

7827
13:06:06.304 --> 13:06:10.007
Js，并在这里添加连接按钮。

7828
13:06:10.007 --> 13:06:12.346
所以我们用const。

7829
13:06:12.346 --> 13:06:21.674
连接按钮= document, dot get element by ID，连接按钮。

7830
13:06:21.674 --> 13:06:25.487
然后我们说const。

7831
13:06:25.487 --> 13:06:33.204
一个按钮等于Doc，你的意思是。get element by ID。

7832
13:06:33.204 --> 13:06:36.890
一个按钮，连接按钮的概念是连接按钮。

7833
13:06:36.890 --> 13:06:39.539
有趣按钮就是有趣按钮。

7834
13:06:39.539 --> 13:06:43.056
然后我们说connect button。

7835
13:06:43.056 --> 13:06:46.749
点击等于连接。

7836
13:06:46.749 --> 13:06:49.208
还有一个按钮。

7837
13:06:49.208 --> 13:06:52.486
点击等于喜欢。

7838
13:06:52.486 --> 13:06:55.881
我们回到我们的前端，稍微刷新一下。

7839
13:06:55.881 --> 13:06:57.071
我们现在点击连接。

7840
13:06:57.071 --> 13:07:06.557
它确实在工作，我们会去到Metamask断开连接，刷新，点击连接，砰，它又弹出了。

7841
13:07:06.557 --> 13:07:16.793
这只是因为那个类型是module，如果它是text斜杠JavaScript，点击按钮添加到这里，但因为我们做的是模块，我们会在JavaScript中添加那些点击。

7842
13:07:16.793 --> 13:07:26.471
现在我们有了醚，我们能做的是我们甚至可以做一个小小的console。log，把醚粘贴到这里，或者更好。

7843
13:07:26.471 --> 13:07:28.777
我们将把它添加到Connect按钮的正上方。

7844
13:07:28.777 --> 13:07:37.622
回到前端，我们会进行刷新我们会在前端看到整个ethers对象这很完美，这正是我们想要的。

7845
13:07:37.622 --> 13:07:48.103
既然我们有这两个变量，我们可以把它更新为，connect button。innerHTML = connected，这里也是。

7846
13:07:48.103 --> 13:07:56.916
Connects button。innerHTML = please install meta mask因为现在connect button将等同于运行这个document。get element by ID。

7847
13:07:56.916 --> 13:07:58.027
和伟大的。

7848
13:07:58.027 --> 13:08:03.138
让我们回到继续我们的字体函数。

7849
13:08:03.472 --> 13:08:13.472
我们写入const provider = new ethers。providers。web3provider window。Aetherium。

7850
13:08:13.472 --> 13:08:32.685
webthree provider是ether中的一个对象，它允许我们基本上围绕Metamask这样的东西，webthree provider非常类似于我们之前使用的JSON RPC provider，我们在那里放入那个端点，我们的炼金法端点，或者当我们使用Metamask时。

7851
13:08:32.685 --> 13:08:42.265
这里，无论我们在网络部分有什么端点web3provider接受那个HTTP端点并自动为我们插入到以太中。

7852
13:08:42.265 --> 13:08:48.972
这行代码基本上是看我们的Metamask，然后说，啊，好的，我在里面找到了HTTP端点，Metamask。

7853
13:08:48.972 --> 13:08:52.239
这就是我们要用的提供者。

7854
13:08:52.239 --> 13:08:55.084
因为我们的提供者连接到我们的超掩模。

7855
13:08:55.084 --> 13:09:14.015
这里，我们可以获得签署人或者我们可以通过运行const signer = provider。get signer来获得钱包，这将返回从提供者连接的钱包，同样，我们的提供者是Metamask。

7856
13:09:14.015 --> 13:09:26.266
如果我们连接到账户1，它会返回账户1作为连接到账户2的签名者，它会返回账户2，等等。

7857
13:09:26.266 --> 13:09:34.873
现在，我要在这里添加console。log signer，然后翻到前面看看点击基金按钮时会发生什么。

7858
13:09:34.873 --> 13:09:43.123
这里有我们的JSON RPC签名者，签名者将是我们连接到前端的帐户。

7859
13:09:43.123 --> 13:09:45.373
现在我们有了提供者，有了签名者。

7860
13:09:45.473 --> 13:09:50.182
现在，我们需要通过获取API和地址来获取契约。

7861
13:09:50.182 --> 13:09:52.311
我们需要写const。

7862
13:09:52.311 --> 13:10:10.932
契约等于什么?我们怎样才能拿到合同呢?这就是我们需要知道ABI和地址的地方通常你会看到很多项目做的因为一旦契约被部署，地址就会改变它们会有某种类型的常量文件。

7863
13:10:10.932 --> 13:10:17.243
他们会新建一个名为constants。js的文件。

7864
13:10:17.473 --> 13:10:24.769
在这里，他们会添加地址和API之类的东西供我们在基金部分使用。

7865
13:10:24.769 --> 13:10:34.196
现在，当我们在开发的时候，当我们在构建的时候，这个，后端和前端团队将会有一些交互，或者如果你只是在做整个堆栈，你将会和他们的后端交互。

7866
13:10:34.196 --> 13:10:40.013
这就是为什么把前端和后端代码都放在身边是如此重要的原因。

7867
13:10:40.013 --> 13:10:46.997
如果我们回到Hardhead，资助我们刚刚做的项目，我们可以在这里找到ABI。

7868
13:10:46.997 --> 13:10:59.260
再一次，如果我们去看工件，去看合同，我们可以去资助我。灵魂，资助我。JSON，我们可以在这里找到ABI，它将是这里这个巨大的东西。

7869
13:10:59.260 --> 13:11:07.349
你可以继续，你甚至可以复制这整个东西在这个小括号里这个小括号，我们可以复制这个。

7870
13:11:07.349 --> 13:11:09.880
然后我们可以回到我们的常数。

7871
13:11:09.880 --> 13:11:09.981
js。

7872
13:11:09.981 --> 13:11:21.670
我们可以将它保存为变量，我们写入Export const Avi e =然后粘贴到这里。

7873
13:11:21.670 --> 13:11:31.286
然后回到index。js中，我们可以用importapi from constants导入它。

7874
13:11:31.286 --> 13:11:32.067
哦。

7875
13:11:32.067 --> 13:11:33.942
好了,好了。

7876
13:11:33.942 --> 13:11:36.910
我们有了API。

7877
13:11:36.910 --> 13:11:47.424
地址呢，因为我们要在本地运行这个，我们想要得到本地运行合约的合约地址，我们有几种方法。

7878
13:11:47.424 --> 13:12:00.911
一种方法是你可以打开两个窗口一个是你的前端代码，一个是你的后端代码，一个是你的后端代码，你可以运行yarn，硬帽节点，它会为我们旋转区块链节点，并在这里给我们地址。

7879
13:12:00.911 --> 13:12:01.956
或者我们能做什么。

7880
13:12:01.956 --> 13:12:07.843
这可能会更容易一些在你的窗口中用你的前端代码创建一个新的终端。

7881
13:12:07.843 --> 13:12:09.735
现在我们有两个终端在运行。

7882
13:12:09.735 --> 13:12:18.344
然后是第二个，我们将向下CD。CD。然后CD，在Me Free Code Camp上。

7883
13:12:18.344 --> 13:12:22.084
在这里，我们要运行纱线，艺术头节点。

7884
13:12:22.084 --> 13:12:34.671
这将在这里的第二个终端上旋转我们的本地区块链，我们在这里部署资金我部署那个地址，等等，等等，就在这里。

7885
13:12:34.671 --> 13:12:38.046
提醒一下，如果我点这个x，它会隐藏终端。

7886
13:12:38.046 --> 13:12:46.491
我总能用终端新终端把它拉出来，我总能把它藏起来，但它仍然在我的终端里运行。

7887
13:12:46.491 --> 13:12:47.652
所以我要把它藏起来。

7888
13:12:47.652 --> 13:12:57.441
我能做的是回到常量文件夹，在最上面，我们可以输入导出const合约地址。

7889
13:12:57.441 --> 13:13:01.558
等于，我们把终端拉上来。

7890
13:13:01.558 --> 13:13:07.238
然后我们去取，上面写着，把我部署在这里的资金取出来。

7891
13:13:07.238 --> 13:13:11.507
我们复制那个地址，加上引号，然后粘贴进去。

7892
13:13:11.507 --> 13:13:17.211
现在我们还导出了合约地址，然后在索引中。

7893
13:13:17.211 --> 13:13:23.378
Js将导入带有逗号的合同地址。

7894
13:13:23.475 --> 13:13:27.551
现在我们有了ABI和合同地址。

7895
13:13:28.475 --> 13:13:39.875
可以做什么，我们可以说const contract = new醚。contract，我们会传递契约地址，传递API，我们会传递签署人。

7896
13:13:39.875 --> 13:14:02.966
现在我们有了连接到签署人的ethers契约对象，我们有了契约地址，我们有了契约abi，现在我们有了契约对象，我们就可以开始进行交易了就像我们之前做交易一样我们可以运行const transaction response = a weight contract。fund。

7897
13:14:02.966 --> 13:14:11.544
然后我们会传递一个值ethers。utils。parse, ether ether mount。

7898
13:14:11.544 --> 13:14:17.361
这就是我们创建事务的方式。

7899
13:14:17.361 --> 13:14:27.943
如果你现在拿这个，我们到前面，给它一点刷新，确保我们是连接的，我们点击基金，我们会得到这个错误值必须是一个字符串。

7900
13:14:27.943 --> 13:14:33.105
这是因为在这个坐垫上，它被传递进来的时候是空的。

7901
13:14:33.105 --> 13:14:36.234
通常，我们会直接把参数传递给函数。

7902
13:14:36.234 --> 13:14:40.076
但我们现在要做的是我们要硬编码这个。

7903
13:14:40.076 --> 13:14:41.342
所以我们用const。

7904
13:14:41.342 --> 13:14:45.682
在坐骑等于时，我们设为77，或者其他我们觉得有趣的东西。

7905
13:14:45.682 --> 13:14:57.062
现在，你觉得会发生什么?我们得到了另一个空气，内部交易成本的资金不足，或者你可能会得到其他错误，但你会得到一个奇怪的错误。

7906
13:14:57.062 --> 13:15:02.122
这是因为我们现在还没有连接到本地硬头节点。

7907
13:15:02.122 --> 13:15:13.101
如果我们看一下我们的超掩膜，我们目前没有连接到正确的区块链，我们连接到溜冰场B，或主网或其他什么，我们需要连接到我们的本地主机。

7908
13:15:13.101 --> 13:15:18.112
看看网络，这里已经有一个本地主机对象了。

7909
13:15:18.112 --> 13:15:19.992
但我们还是要特别具体一点。

7910
13:15:19.992 --> 13:15:26.209
我们会在这里添加一个新的网络，我们会添加一个叫做硬帽的东西，本地主机。

7911
13:15:26.209 --> 13:15:28.882
点击添加网络，添加Hardhead。

7912
13:15:28.882 --> 13:15:45.555
这里的本地主机，RPC URL，我们可以从节点区域找到，我们可以滚动到节点运行的地方，我们可以复制这个URL并粘贴到新的RPC URL，链ID是31337货币符号是go或ether。

7913
13:15:45.555 --> 13:15:51.677
尽管这个弹出窗口说它可能有一个不同的货币符号，我们将把eath放在这里。

7914
13:15:51.677 --> 13:15:57.427
没有块资源管理器，对吧?因为这是本地区块链，我们不会有块资源管理器。

7915
13:15:57.477 --> 13:15:58.444
点击保存。

7916
13:15:58.477 --> 13:16:00.680
现在我们在这里有了一个账户，这很好。

7917
13:16:01.477 --> 13:16:02.572
到我们当地的区块链。

7918
13:16:04.477 --> 13:16:06.445
看，我们戴上了本地安全帽。

7919
13:16:06.445 --> 13:16:07.778
我们彼此相连。

7920
13:16:08.477 --> 13:16:09.560
让我们刷新。

7921
13:16:09.560 --> 13:16:11.976
让我们再运行一次基金。

7922
13:16:13.477 --> 13:16:15.412
事务确实会弹出。

7923
13:16:15.412 --> 13:16:16.315
这太棒了。

7924
13:16:17.477 --> 13:16:22.789
我们没有钱，我们破产了，我们在当地也没有硬头Aetherium。

7925
13:16:22.789 --> 13:16:36.227
我们需要将一个账户从硬帽导入到元掩码中，这是可以做到的任何账户都可以这样做，只要有私钥，就能得到这些账户。

7926
13:16:36.227 --> 13:16:40.910
我们会导入0计数的私钥到元掩码中。

7927
13:16:40.910 --> 13:16:49.430
复制私钥，回到前端，点击元掩码，点击这个大按钮，点击导入账户。

7928
13:16:49.477 --> 13:16:53.132
键入私钥，然后粘贴私钥到这里。

7929
13:16:53.132 --> 13:17:07.288
简单说明一下，如果你选择json文件，记得在ether部分，我们如何将密钥加密到带密码的json文件中，你可以用带密码的json文件导入账户。

7930
13:17:07.288 --> 13:17:12.319
如果你加密一个密钥，你想把它添加到元掩码，你可以像这样添加它。

7931
13:17:12.319 --> 13:17:16.977
现在，我们将使用私钥，粘贴私钥，然后点击导入。

7932
13:17:16.977 --> 13:17:26.398
我们现在有了一个帐户，一个新帐户和一个帐户3，从本地区块链中有大量的eth。

7933
13:17:26.477 --> 13:17:32.665
再刷新一次，然后连接，确保账户3是连接的。

7934
13:17:32.665 --> 13:17:35.681
如果不是，我们会按下连接按钮。

7935
13:17:35.681 --> 13:17:38.670
现在我们的账户3是连接到这里的。

7936
13:17:38.670 --> 13:17:40.763
然后我们就会开始投资。

7937
13:17:40.763 --> 13:17:46.838
现在我们可以为合同提供资金，点击确认。

7938
13:17:46.838 --> 13:18:01.763
如果我们看，我们的前端什么都不会发生，因为我们确认后没有告诉前端做任何事，但如果我们去区块链，我们可以看到我们的fun函数被调用我们刚刚在我们自己的前端区块链上完成了第一次交易，这是了不起的工作。

7939
13:18:01.763 --> 13:18:04.461
但这可能会让用户感到困惑。

7940
13:18:04.461 --> 13:18:06.865
如果这里什么都没发生，它们就会击中趣味函数。

7941
13:18:06.865 --> 13:18:09.363
大家会觉得，哦，好吧，很酷。

7942
13:18:09.363 --> 13:18:14.858
发生了什么?现在，我们可能想让它变得更明显一些刚刚发生的事情。

7943
13:18:14.858 --> 13:18:24.589
还有一件事我想告诉你们，你们不需要跟着做，如果我点了基金，然后我点了拒绝，它会崩溃，就像，嘿，你点了拒绝，我不知道该怎么做。

7944
13:18:24.589 --> 13:18:27.986
我们将通过添加try catch让代码更健壮一些。

7945
13:18:27.986 --> 13:18:34.446
因此，我们将告诉JavaScript尝试运行这个事务。

7946
13:18:34.446 --> 13:18:41.127
如果它捕捉到一个错误，就到console。log，那个错误。

7947
13:18:41.127 --> 13:18:51.528
现在，如果我点击基金，然后点击拒绝，它仍然会有点疯狂，但至少我们抓住了它，它不会破坏所有东西。

7948
13:18:51.528 --> 13:18:52.078
好的,很酷。

7949
13:18:52.078 --> 13:18:53.931
我们这里有一个事务响应。

7950
13:18:53.931 --> 13:18:57.228
当我们有资金的时候，我们的前端就会很好。

7951
13:18:57.228 --> 13:19:02.228
你资助了我，我我超级困惑。

7952
13:19:02.228 --> 13:19:06.396
还有一点，你们可能会碰到很多次。

7953
13:19:06.396 --> 13:19:07.707
当我们这样做的时候。

7954
13:19:07.707 --> 13:19:10.812
如果你得到一个像这样的错误。

7955
13:19:10.812 --> 13:19:18.932
JS查询，同时格式化输出从RPC, nonce到高期望不是太但得到的形式，你肯定会看到这整个很多。

7956
13:19:18.932 --> 13:19:20.385
下面是解决这个问题的方法。

7957
13:19:20.479 --> 13:19:30.429
发生这种情况的原因是，您关闭了您的硬帽节点，然后重新启动它，您的心脏节点说，好吧，我重新开始，我从零开始。

7958
13:19:30.479 --> 13:19:42.412
但Metamask还不够聪明，我们要做的是来到Metamask，按下这个大按钮，到设置，到高级，然后重置账户。

7959
13:19:42.412 --> 13:19:44.608
是的，我们要重置它。

7960
13:19:44.608 --> 13:19:51.750
这并不是理想情况下你想在本地网络上用一个有实际资金的实际账户来做的事情，这是可以的。

7961
13:19:51.750 --> 13:19:57.029
如果你重置了账户，重置了节点，我们可以点击确认。

7962
13:19:57.029 --> 13:19:59.079
它不再给我们那个误差了。

7963
13:19:59.079 --> 13:20:08.305
这就是提示，你要重置螺母，使我们的Metamask和区块链与nonce数字同步。

7964
13:20:08.479 --> 13:20:09.720
我们有这个事务响应。

7965
13:20:10.479 --> 13:20:15.659
我们的前端给用户一些提示，嘿，交易通过了。

7966
13:20:15.659 --> 13:20:19.593
我们要做的是听区块链来结束这个。

7967
13:20:19.593 --> 13:20:23.806
所以我们要么监听TX被挖掘。

7968
13:20:23.806 --> 13:20:27.248
或者我们可以听一个事件。

7969
13:20:27.479 --> 13:20:28.626
我们还没有了解到事件的进展。

7970
13:20:28.626 --> 13:20:29.019
但我们会的。

7971
13:20:29.479 --> 13:20:33.399
因为我们还没有了解到事件，我们只需要听TX被挖掘。

7972
13:20:33.399 --> 13:20:50.004
为了监听要挖掘的事务，我们会创建一个新函数叫做，监听，或事务挖掘这将接受一个事务响应和一个提供者作为输入。

7973
13:20:50.004 --> 13:20:53.085
现在你会注意到这不是一个async函数。

7974
13:20:53.085 --> 13:20:54.159
对于本节。

7975
13:20:54.159 --> 13:20:57.301
这是有意的，我们不希望它是一个异步函数。

7976
13:20:57.301 --> 13:20:58.408
你马上就会知道为什么了。

7977
13:20:58.480 --> 13:21:03.795
我们将使用JavaScript承诺的异步功能来发挥它的巨大优势。

7978
13:21:03.795 --> 13:21:08.352
这就是为什么JavaScript在前端工作得这么好因为它是异步的。

7979
13:21:08.352 --> 13:21:14.130
我们会创建这个函数监听待挖掘的交易，我们会在fund函数中等待。

7980
13:21:14.130 --> 13:21:16.922
我们会让这个返回一个承诺。

7981
13:21:16.922 --> 13:21:19.381
让我们继续，让我们学习如何构建它。

7982
13:21:19.480 --> 13:21:23.299
我们会说console。log，字符串插值，我们会说挖掘。

7983
13:21:23.299 --> 13:21:28.125
然后在这里，我们写上transaction response。hash。

7984
13:21:28.125 --> 13:21:34.447
我们所有的事务响应对象都有一个散列，它只是表示这个散列。

7985
13:21:34.447 --> 13:21:44.896
我们会做一些数据点，放到控制台这里，等待事务被挖掘，然后我们会返回一个新承诺。

7986
13:21:44.896 --> 13:21:53.191
我们要返回一个promise的原因是我们需要为区块链创建一个监听器。

7987
13:21:53.191 --> 13:21:55.377
我们想要监听这个事件的发生。

7988
13:21:55.480 --> 13:22:04.221
但我们想告诉JavaScript，等这个东西看完，等这个东西看完。

7989
13:22:04.221 --> 13:22:06.770
这就有点棘手了。

7990
13:22:06.770 --> 13:22:07.880
在我们的基金功能中。

7991
13:22:07.880 --> 13:22:16.035
在我们创建事务之后，我们基本上想告诉JavaScript嘿，等待这个TX完成。

7992
13:22:16.035 --> 13:22:22.962
我们的代码看起来就像等待监听事务mine一样简单。

7993
13:22:22.962 --> 13:22:30.369
我们会给它传递transaction响应和提供者。

7994
13:22:30.369 --> 13:22:33.462
我们说，嘿，听这个事务结束。

7995
13:22:33.462 --> 13:22:38.873
我们使用await关键字，因为await关键字说，好，我们会在这里停止。

7996
13:22:38.873 --> 13:22:41.231
直到这个函数完全完成。

7997
13:22:41.231 --> 13:22:46.756
在这个listen for事务中，我们必须定义如何监听这个。

7998
13:22:46.756 --> 13:22:50.874
我们会说，监听这个事务是否完成。

7999
13:22:50.874 --> 13:22:59.658
醚实际上为我们提供了一种监听事务和监听事件的方法，同样，我们还没有学过这方面的知识，但现在不用担心。

8000
13:22:59.658 --> 13:23:01.481
我们可以去醚的文档。

8001
13:23:01.481 --> 13:23:03.081
我们可以向上看一次。

8002
13:23:03.081 --> 13:23:04.281
收缩点一次。

8003
13:23:04.481 --> 13:23:15.174
有很多监听器我们可以用来监听事件监听不同的事情发生，我们可以做这个provider。once我们监听一些事件。

8004
13:23:15.174 --> 13:23:20.217
一旦那个事件触发，我们调用我们定义的其他函数。

8005
13:23:20.217 --> 13:23:22.323
现在，我们还没有讲到事件。

8006
13:23:22.323 --> 13:23:24.623
还是那句话，不要太担心这个。

8007
13:23:24.623 --> 13:23:35.057
我们可以等待的事件之一是我们可以等待交易收据完成，因为一旦我们得到了交易收据，这意味着交易实际上已经完成了。

8008
13:23:35.057 --> 13:23:44.333
我们将使用这个provider。once语法来等待事务接收，这将是我们的事件，这不是真正的事件，但先不用担心。

8009
13:23:44.333 --> 13:23:49.052
然后我们会调用我们定义的监听器函数，你也可以调用provider。

8010
13:23:49.052 --> 13:23:58.302
On，它将在任何时候触发你的事件触发提供者，只要触发一次，我们只关心这个事务经过一次。

8011
13:23:58.302 --> 13:24:00.671
我们传递的是提供者对象。

8012
13:24:00.671 --> 13:24:12.127
我们会说provider。once我们的事件这将是transaction response。哈希，提供于transaction response。哈希。

8013
13:24:12.127 --> 13:24:17.882
一旦我们得到这个散列，它马上就会得到，我们会调用监听器函数。

8014
13:24:17.882 --> 13:24:22.903
现在我们可以像这样创建一个函数监听器，然后把监听器传入这里。

8015
13:24:22.903 --> 13:24:28.075
但这里我们要做一个匿名函数，因为这是我们通常看到的这些循环的语法。

8016
13:24:28.075 --> 13:24:34.174
到目前为止，我们只做了provider。一次来做这个匿名函数，这里我们只做两个小括号。

8017
13:24:34.174 --> 13:24:36.014
这个箭头符号。

8018
13:24:36.014 --> 13:24:39.762
这个单独代表一个匿名函数。

8019
13:24:39.762 --> 13:24:48.926
所以我们说，嘿，有一个函数，它不带任何参数，也没有任何代码，这个箭头函数，这整个过程表明这是一个匿名函数。

8020
13:24:48.926 --> 13:24:53.820
我们说，一旦事务哈希发生，这就是你想要执行的函数。

8021
13:24:53.820 --> 13:24:55.416
它现在什么都做不了。

8022
13:24:55.416 --> 13:24:56.857
但让我们做点什么吧。

8023
13:24:56.857 --> 13:25:10.291
一旦这个transaction。response完成，我们会取一个transtransaction received作为输入参数，或者我们的回调函数，或者我们的listener函数。

8024
13:25:10.291 --> 13:25:28.205
我们要做的是，console。log，用一些字符串插值完成，交易收据，那个确认，确认，然后用交易收据，确认，确认完成。

8025
13:25:28.205 --> 13:25:44.482
一旦这个provider。一旦看到有一个事务哈希，它就会把事务接收作为输入夯实器给监听器函数，这和我们一直看到的语法是一样的，一旦事务响应完成，我们就会得到事务接收，我们可以用它做一些事情。

8026
13:25:44.482 --> 13:25:46.482
我们看它有多少块确认。

8027
13:25:46.482 --> 13:25:48.876
对我们来说，这应该一直是1。

8028
13:25:48.876 --> 13:25:58.783
如果我们保存这个，回到我们的前端，点击基金，它会起作用，我们会给用户一些提示它起作用了，这很好。

8029
13:25:58.783 --> 13:26:02.040
但这并不是我们想要的那样。

8030
13:26:02.040 --> 13:26:17.451
这个console。log就在我们执行await，监听transaction mine之后完成，然后我们返回，点击fund，点击confirm，它实际上并没有按照我们想要的顺序进行，它去挖掘它说完成的东西。

8031
13:26:17.451 --> 13:26:27.889
然后它说完成一次行程确认这里发生了什么，我们应该在写完成之前写完成，因为这是我们的顺序。

8032
13:26:27.889 --> 13:26:30.939
但看起来好像是单词，顺序不对。

8033
13:26:30.939 --> 13:26:46.500
这里发生了什么，将要发生的是当我们调用listen for transaction mine，或者listen for transaction时，mine函数会启动，但它会启动一次，作为它自己的进程。

8034
13:26:46.500 --> 13:26:56.045
因此，await listen for transaction，我的将启动侦听器，但它不等待这个侦听器找到事务响应。

8035
13:26:56.045 --> 13:27:03.015
这个函数会在provider。once结束之前结束。

8036
13:27:03.015 --> 13:27:10.959
启动监听器后，它会运行到下一行代码，也就是console。log，完成。

8037
13:27:10.959 --> 13:27:14.640
我们的前端，我们会说，哦，哦，你刚才踢开了一个监听器。

8038
13:27:14.640 --> 13:27:19.273
让我再下去检查一下，看看是不是完成了。

8039
13:27:19.273 --> 13:27:22.548
如果它完成了，我就去做它让我做的事。

8040
13:27:22.548 --> 13:27:25.433
这就是所谓的事件循环起作用的地方。

8041
13:27:25.483 --> 13:27:32.730
我们不需要等待这个提供者完成，我们将这个被提供的立即添加到这个叫做事件循环的队列中。

8042
13:27:32.730 --> 13:27:37.992
我们的前端会定期检查它是否完成。

8043
13:27:37.992 --> 13:27:39.959
所以我们要调整我们的代码。

8044
13:27:39.959 --> 13:27:45.391
我们等待听者听完，这就是我们要讲承诺的地方。

8045
13:27:45.391 --> 13:27:49.915
我们要做的是调整这个函数，让它返回一个承诺。

8046
13:27:49.915 --> 13:27:53.431
以后我们还会多次用到这个语法。

8047
13:27:53.484 --> 13:28:01.284
我们要做的是说，嘿，我们要等听者听完，我们要把这整件事包装成一个承诺。

8048
13:28:01.284 --> 13:28:04.449
我们会说return, new promise。

8049
13:28:04.449 --> 13:28:09.776
promise接受函数本身作为输入参数。

8050
13:28:09.776 --> 13:28:13.394
再一次，我们将使用这种匿名函数符号。

8051
13:28:13.394 --> 13:28:17.198
它需要两个输入参数进行解析和拒绝。

8052
13:28:17.198 --> 13:28:23.502
resolve说，嘿，如果这个承诺工作正常，调用这个resolve函数。

8053
13:28:23.502 --> 13:28:28.422
对我们来说，这个承诺是在听者听完的时候完成的。

8054
13:28:28.484 --> 13:28:33.841
如果有某种类型的超时，我们会拒绝，我们不会写拒绝函数。

8055
13:28:33.841 --> 13:28:38.960
但将来，如果要在生产中执行此操作，则需要添加一些超时作为reject参数。

8056
13:28:38.960 --> 13:28:52.139
基本上，你会说，嘿，一旦监听器听完，我们会解析如果它花了太长时间，我们会说，ask for you，你花了太长时间，而不是关闭它，在这里，我们会关闭它围绕提供者这个东西。

8057
13:28:52.139 --> 13:28:55.216
返回新承诺，决心，拒绝。

8058
13:28:55.216 --> 13:29:02.294
只有当这个交易被终止，我们才会解决这个承诺，像这样。

8059
13:29:02.294 --> 13:29:10.151
这里发生了什么，我们会立刻把解析放入提供者中。

8060
13:29:10.151 --> 13:29:24.726
我们说，一旦找到这个事务哈希，我们会调用这个函数，我们会说console。log，然后我们会解析这个承诺只会在调用resolve或reject时返回。

8061
13:29:24.726 --> 13:29:31.375
我们告诉它只resolve只finish这个函数一次。

8062
13:29:31.485 --> 13:29:43.016
事务响应。哈希会被找到，因为它会在provider。的小圆括号里面一次，承诺只会在它被触发后解决。

8063
13:29:43.016 --> 13:29:44.130
这是一个事件。

8064
13:29:44.130 --> 13:29:51.162
如果这真的让人困惑，复制粘贴这个，然后继续，我们会更深入地了解前端的内容。

8065
13:29:51.162 --> 13:29:57.517
所以希望，这是清楚的，如果不是绝对跳到GitHub讨论开始问这个东西。

8066
13:29:57.517 --> 13:30:03.207
但现在我们已经更新了这个，我们可以回到我们的前端，我们可以点击基金按钮。

8067
13:30:03.207 --> 13:30:05.925
希望这一次，一切都能顺利进行。

8068
13:30:05.925 --> 13:30:10.412
我们点击确认，我们看到挖矿完成，然后我们看到完成。

8069
13:30:10.485 --> 13:30:20.985
原因还是因为，我们的await关键字现在是waiting，它说，哦，你在返回一个承诺，我需要等待，我需要等待它解决或拒绝。

8070
13:30:20.985 --> 13:30:29.618
我们只在提供者找到这个事务哈希和这个事务收据时解决承诺，这是这个监听事务mine。

8071
13:30:29.618 --> 13:30:32.818
在以后的章节中，所有这些都将被抽象出来。

8072
13:30:32.818 --> 13:30:37.549
生活将会变得简单很多，但重要的是要理解这里到底发生了什么。

8073
13:30:37.549 --> 13:30:37.936
太棒了。

8074
13:30:37.936 --> 13:30:44.637
所以现在我们给前端一些指示，告诉它发生了什么。

8075
13:30:44.637 --> 13:30:49.604
我们的娱乐功能做得很好，不，不完全是。

8076
13:30:49.604 --> 13:30:54.451
为什么不呢?因为现在我们把每个数都硬编码为0。

8077
13:30:54.451 --> 13:30:54.502
1.

8078
13:30:54.502 --> 13:31:01.930
在前端，我们可能不想硬编码它，我们可能希望允许用户根据他们的意愿投资多少或少。

8079
13:31:01.930 --> 13:31:05.739
我们需要把它从一个按钮变成一个输入表单。

8080
13:31:05.739 --> 13:31:09.167
要做到这一点，我们需要回到HTML。

8081
13:31:09.167 --> 13:31:11.454
回到index。HTML。

8082
13:31:11.454 --> 13:31:15.356
我们要改变这个有趣的部分，我们要添加一些表单信息。

8083
13:31:15.356 --> 13:31:22.223
我们将保持这个按钮不变，或者我们将添加一个小文本框来输入他们想要的内容。

8084
13:31:22.223 --> 13:31:33.216
我要创建一个标签，写上for，写上fund这个标签写上eath amount，然后关闭标签，这基本上就是要创建一个标签。

8085
13:31:33.216 --> 13:31:37.879
如果我们回到我们的前端，我们现在只有这个Etham out标签，它没有标记任何东西。

8086
13:31:37.879 --> 13:31:43.026
现在我们要创建一个输入，我们要给它一个eath amount的ID。

8087
13:31:43.026 --> 13:31:47.899
我们给它一个0的占位符。

8088
13:31:47.899 --> 13:31:48.002
1.

8089
13:31:48.002 --> 13:31:51.829
然后我们关闭输入。

8090
13:31:51.829 --> 13:31:58.693
现在如果我们翻到前面，我们有每个数量，标记这个小文本框的占位符是0。

8091
13:31:58.693 --> 13:31:58.749
1.

8092
13:31:58.749 --> 13:32:02.020
我们可以在这里添加一些东西，诸如此类。

8093
13:32:02.020 --> 13:32:11.236
还有一件事，如果你有一些标签，但你没有在它们之间放任何东西，你实际上可以缩短它，只需要在后面放一个小的结尾，像这样。

8094
13:32:11.236 --> 13:32:19.316
如果标签之间没有任何东西，你可以像这样关闭它们，这两个是等价的，嘣嘣嘣，它们是一样的。

8095
13:32:19.316 --> 13:32:19.621
太好了。

8096
13:32:19.621 --> 13:32:23.319
当我们调用fund时，我们正在调用fund，我们没有传递任何参数。

8097
13:32:23.319 --> 13:32:40.962
让我们更新fund不再是硬编码eamount，我们会让fund函数由我们在fund函数的eamount输入框中输入的内容填充，而不是const eamount = 0。

8098
13:32:40.962 --> 13:32:41.060
1.

8099
13:32:41.060 --> 13:32:53.970
我们从eath amount ID中获取document。getelement by ID eath amount。value。

8100
13:32:53.970 --> 13:33:00.656
所以我们要在这个输入框中抓取任意值，在我们的索引中。

8101
13:33:00.656 --> 13:33:06.320
Js，我们有console。log资金与每个数额，如果在我们的前端，我们做1。

8102
13:33:06.320 --> 13:33:06.403
7.

8103
13:33:06.403 --> 13:33:11.567
点击fund，我们在控制台。log中看到，funding with 1。

8104
13:33:11.567 --> 13:33:11.647
7.

8105
13:33:11.647 --> 13:33:12.937
得到1。

8106
13:33:12.937 --> 13:33:13.017
7.

8107
13:33:13.017 --> 13:33:19.674
我们有趣的部分确认，它会挖掘它，完成它，然后说，完成。

8108
13:33:19.674 --> 13:33:20.174
太棒了。

8109
13:33:20.174 --> 13:33:22.978
现在我们在这里添加了一个小文本框。

8110
13:33:22.978 --> 13:33:25.962
因此，人们可以根据自己的意愿提供多少资金。

8111
13:33:25.962 --> 13:33:29.418
太好了，这整件事可以看作是一种形式。

8112
13:33:29.418 --> 13:33:34.437
还有一个表单标签，但我们现在只使用这个。

8113
13:33:34.437 --> 13:33:35.830
好的，很好。

8114
13:33:35.830 --> 13:33:46.300
我们做了大量的资金，我们不断为我们的合同提供资金，我们不断添加更多的东西，我们可能需要一个按钮来跟踪这里实际有多少。

8115
13:33:46.300 --> 13:33:48.782
让我们添加一个非常简单的平衡按钮。

8116
13:33:48.782 --> 13:33:52.978
我把这个移到下面，这样更好。

8117
13:33:52.978 --> 13:33:57.294
我们写入button id = balance button。

8118
13:33:57.294 --> 13:34:00.794
我们称它为get balance。

8119
13:34:00.794 --> 13:34:03.978
现在我们有了一个平衡按钮。

8120
13:34:03.978 --> 13:34:06.723
它什么都不会做因为我们没有得到平衡函数。

8121
13:34:06.723 --> 13:34:08.402
让我们回到下标。

8122
13:34:08.402 --> 13:34:08.605
js。

8123
13:34:08.605 --> 13:34:14.694
我们会创建一个getbounce函数async函数getbounce。

8124
13:34:14.694 --> 13:34:17.834
我们就像之前做的那样。

8125
13:34:17.834 --> 13:35:07.453
如果type window。Aetherium不等于undefined，那么我们将执行const provider = new ethers ethers。providers。web3provider of window, Aetherium将执行const balance = await provider。get balance，合约地址，同样，我们在顶部导入，然后我们将执行console。log ethers。utils。format, ether, bounce这个格式ether function ethers utils，你可以在文档中找到它，使阅读醚，格式化的数字更容易阅读。

8126
13:35:07.453 --> 13:35:23.049
和之前做的一样，我们要向上，复制这条有趣的按钮行，粘贴这里写balance button = document。getelement by ID, balance button。

8127
13:35:23.049 --> 13:35:34.826
然后我们会说balance button on click = get balance，我们会回到前端，我们会快速刷新，我们会get balance。

8128
13:35:34.826 --> 13:35:39.154
现在我们可以看到控制台的余额，我们可以用1来投资。

8129
13:35:39.154 --> 13:35:49.649
8，我们会弹出基金metamath，我们会继续并确认挖矿完成，我们会点击平衡，现在我们在3。

8130
13:35:49.649 --> 13:35:49.761
8.

8131
13:35:49.761 --> 13:35:50.890
太棒了。

8132
13:35:50.890 --> 13:35:53.747
好了，我们继续。

8133
13:35:53.747 --> 13:35:57.116
接下来我们要做什么呢，我们要在这里吃掉取款函数。

8134
13:35:57.116 --> 13:36:01.301
我们来创建它它看起来和我们之前做过的很像。

8135
13:36:01.301 --> 13:36:12.015
在index。HTML上，我们创建一个新按钮我们可以复制这一行，粘贴到下面，调用这个withdraw按钮。

8136
13:36:12.015 --> 13:36:14.134
我们称之为取款。

8137
13:36:14.134 --> 13:36:20.902
然后在下标中，做同样的事情，复制这个，粘贴到下面。

8138
13:36:20.902 --> 13:36:29.965
drop button是document get element by ID，提取按钮，提取按钮。

8139
13:36:29.965 --> 13:36:31.910
点击等于退出。

8140
13:36:31.910 --> 13:36:35.168
下面画一个取款函数。

8141
13:36:35.168 --> 13:36:38.111
我们继续，选择async。

8142
13:36:38.111 --> 13:36:42.689
函数withdraw，会做和我们上面做的完全一样的事情。

8143
13:36:42.689 --> 13:36:49.278
我甚至可以从get balance中复制所有内容然后删除balance部分。

8144
13:36:49.278 --> 13:36:55.695
如果window。Aetherium的类型不等于undefined，那么我们将在这里获取提供者。

8145
13:36:55.695 --> 13:37:00.239
和基金合同一样，我们会抓住签名者和合同。

8146
13:37:00.239 --> 13:37:02.039
我们来看看这两条线。

8147
13:37:02.039 --> 13:37:06.040
将它们粘贴到这里称为signer = provider。get signer。

8148
13:37:06.040 --> 13:37:08.385
合同等于新合同，等等等等。

8149
13:37:08.385 --> 13:37:08.764
好的,很酷。

8150
13:37:08.764 --> 13:37:12.833
现在我们要做的和我们对fun函数做的完全一样。

8151
13:37:12.833 --> 13:37:19.735
我们会做一个try, catch，然后在这里添加catch, catch error, console。log error。

8152
13:37:19.735 --> 13:37:30.264
在try中，我们会写const transaction response = await, contractdot withdraw。

8153
13:37:30.264 --> 13:37:33.102
我们不需要在这里添加任何参数。

8154
13:37:33.102 --> 13:37:41.119
哦，然后我们执行一个console。log，退出，然后我们会得到这个事务响应。

8155
13:37:41.119 --> 13:37:44.052
然后我们会听到这个交易是否也被挖掘。

8156
13:37:44.052 --> 13:38:02.283
通过运行Wait, listen for transaction mine, transaction response，逗号，provider，就这样了，因为我们可以重用listen for transaction mine的功能。

8157
13:38:02.283 --> 13:38:08.061
现在刷新，确保连接，检查当前余额，也就是3。

8158
13:38:08.061 --> 13:38:08.156
8.

8159
13:38:08.156 --> 13:38:11.203
现在我们要撤退了。

8160
13:38:11.490 --> 13:38:15.036
看到正在退出的控制台。log，点击确认。

8161
13:38:15.036 --> 13:38:24.677
看起来我们已经完成了，如果我们看我们的Metamask，我们的反弹会增加这里添加的数量。

8162
13:38:24.677 --> 13:38:32.290
如果我们达到平衡，我们确实看到0，我们甚至可以再次检查这个是否有效，我们可以看到余额是9。

8163
13:38:32.290 --> 13:38:32.423
99.

8164
13:38:32.423 --> 13:38:35.839
让我们继续，甚至用99英镑来资助它。

8165
13:38:35.839 --> 13:38:39.013
很好，确认，看起来已经完成了。

8166
13:38:39.013 --> 13:38:41.354
我们的元蒙版现在显示99。

8167
13:38:41.354 --> 13:38:41.523
00.

8168
13:38:41.523 --> 13:38:51.627
如果我们继续取款，确认取款已经完成，我们可以看到我们的余额回到了9999。

8169
13:38:51.627 --> 13:38:55.973
现在我们回去换衣服。

8170
13:38:55.973 --> 13:38:57.343
嘿，什么是好东西。

8171
13:38:57.343 --> 13:38:59.601
我们将刷新我们的前端。

8172
13:38:59.601 --> 13:39:08.347
现在我们可以看到你已经做到了，我们已经创建了一个极简的网站，允许我们连接到区块链，并从前端调用功能。

8173
13:39:08.347 --> 13:39:14.523
对于一个网站来说，这绝对是巨大的，你应该为自己感到无比自豪和兴奋。

8174
13:39:14.523 --> 13:39:16.841
这绝对是一个极简的版本。

8175
13:39:16.841 --> 13:39:20.797
我们将使用更强大、更现代的前端框架。

8176
13:39:20.797 --> 13:39:28.441
但是当我们使用这些更高级的前端时，这会让你对幕后发生的事情有一个确切的了解，我们会改进它们的风格。

8177
13:39:28.491 --> 13:39:30.491
它们看起来比这个好一点。

8178
13:39:31.491 --> 13:39:34.694
赛义德，你刚刚了解了这些前端是如何工作的。

8179
13:39:34.694 --> 13:39:45.007
现在你知道了如何把东西往上推，我强烈建议你开始把所有这些项目都推到你的GitHub上，它们将是你实际完成工作的记录你已经构建了这些智能合约。

8180
13:39:45.007 --> 13:39:58.216
如果你想获得实习机会，如果你想帮助其他GitHub项目，这将是一个记录，嘿，我能做这个，我能做什么，看看我知道怎么做，所以恭喜你的第一个完整的堆栈或你的第一个前端应用程序。

8181
13:39:58.216 --> 13:40:02.118
在我们继续之前，让我们快速复习一下我们在这里学到的所有东西。

8182
13:40:02.118 --> 13:40:06.053
第一，通常，你需要存储库或代码库。

8183
13:40:06.053 --> 13:40:13.473
为了让智能合约的后端与前端是不同的存储库，前端代码将是HTML和JavaScript的组合。

8184
13:40:13.473 --> 13:40:21.157
当我们有一个像meta mask这样的钱包时，我们将这些基于浏览器的钱包注入到浏览器的窗口对象中，比如window。Aetherium。

8185
13:40:21.157 --> 13:40:28.991
每个浏览器在这里都有不同的扩展，我们这样做的原因是，我们想连接到构建在元掩码中的RPC URL。

8186
13:40:28.991 --> 13:40:59.253
以这种方式,我们犯同样的API调用RPC URL和我们一样在安全帽在醚混音为我们所做的,等我们创建我们的第一个承诺的基础功能有一个侦听器开始,我们用一个承诺说,嘿,我们要等待侦听器来完成,因为这是一个基于承诺的功能,我们设置一个重量侦听交易思想和我们等待这个交易完成,这样我们的前端,一旦完成我们的交易经历,我们可以告诉用户它已经完成了我们可以继续做其他事情。

8187
13:40:59.253 --> 13:41:04.412
为自己鼓掌，让我们进入下一个部分。

8188
13:41:04.492 --> 13:41:07.025
好了，欢迎来到下一部分。

8189
13:41:08.492 --> 13:41:16.614
第九，我们的硬帽智能合约抽签，这一节的所有代码都可以在与这门课相关的GitHub回购中找到。

8190
13:41:16.614 --> 13:41:18.427
好了，让我给你们展示一下我们要做的东西。

8191
13:41:18.427 --> 13:41:22.692
我将展示前端登录，如果你不想，你不必做前端登录。

8192
13:41:22.692 --> 13:41:26.599
但前端确实给了我们一个很好的方法来可视化我们正在构建的彩票。

8193
13:41:26.599 --> 13:41:35.015
在这里，我们正在构建一个应用程序，允许用户完全去中心化，允许我们参与一个公平的，可验证的随机抽签。

8194
13:41:35.015 --> 13:41:41.379
这个应用程序可以解决我们之前讨论过的麦当劳问题。

8195
13:41:41.379 --> 13:41:45.965
首先，我们有这个Kinect Wallet按钮，我们会点击它连接到meta mask。

8196
13:41:45.965 --> 13:41:54.992
在这里，我们将展示如何连接到不仅仅是Metamask钱包连接到信任钱包，数学钱包，任何这些钱包，我们还会展示如何定制更多。

8197
13:41:54.992 --> 13:41:56.984
所以我们要连接到超面具。

8198
13:41:56.984 --> 13:42:03.224
这里，我们选择从Hardhead导入的账户，选择下一步，选择Connect。

8199
13:42:03.224 --> 13:42:10.158
记住，对于我们的前端位，我们会去设置高级重置帐户，如果我们使用的是全新的安全帽区块链。

8200
13:42:10.158 --> 13:42:13.943
现在，前端看起来不是很好，但我们有一个进入抽奖按钮。

8201
13:42:13.943 --> 13:42:20.262
我们有一个关于当前玩家数量的UI，然后是抽奖中最多的赢家。

8202
13:42:20.262 --> 13:42:25.242
我们可以进入抽奖，允许任何人支付0。

8203
13:42:25.242 --> 13:42:25.742
1容易的。

8204
13:42:25.742 --> 13:42:37.429
要进入智能合约，我们会得到一个小交易说交易完成了，我们得到当前玩家的数量是1，我们可以继续参加抽奖任何人都可以参加抽奖。

8205
13:42:37.493 --> 13:42:46.071
智能合约会跟踪所有参与者，我们会在计时器上运行这个，彩票会自动触发某人中奖。

8206
13:42:46.071 --> 13:42:53.880
为了得到一个纯可验证的随机数，我们将使用链链VRF来得到一个纯可验证的随机数。

8207
13:42:53.880 --> 13:43:04.001
然后我们要用链环保持器来触发自动化，在每到一个时间间隔时自动选出一个赢家。

8208
13:43:04.001 --> 13:43:10.438
一旦饲养员开始，他们会选出一个中奖者，我们的去中心化彩票会说前一次中奖者是某某人。

8209
13:43:10.493 --> 13:43:21.393
他们将从这个彩票中获得所有的钱这是一个完全公平的去中心化彩票，我们将把我们的合同称为raffle。soul但你可以叫它lottery。soul或其他任何你想要的名字。

8210
13:43:21.393 --> 13:43:23.459
我们要让它看起来非常非常漂亮。

8211
13:43:23.459 --> 13:43:25.689
现在我们回到了Visual Studio代码中。

8212
13:43:25.689 --> 13:43:27.262
这将是一个项目。

8213
13:43:27.262 --> 13:43:34.935
如果你学会了这一点，你就有了学习其他所有智能合约概念的技能，你将能够在这个领域做伟大的事情。

8214
13:43:34.935 --> 13:43:43.493
这将是您的旗舰项目，这将是您在本教程中最激动和最自豪的项目。

8215
13:43:43.493 --> 13:43:47.738
我们来创建一个新文件夹。

8216
13:43:47.738 --> 13:44:00.283
我们要做mkdir，硬帽智能合约抽签，FCC或者智能合约抽签，随便你怎么叫，然后我们要进入硬帽智能合约抽签免费代码营。

8217
13:44:00.283 --> 13:44:05.624
我们会输入code period，或者我们会在一个新文件夹中打开它，随便你怎么做。

8218
13:44:05.624 --> 13:44:10.461
现在我们在新文件夹中，我们要创建新的安全帽项目。

8219
13:44:10.461 --> 13:44:16.397
所以我们要做纱线，添加破折号dev硬帽。

8220
13:44:16.397 --> 13:44:22.619
我们的节点模块是package。JSON和yarn。lock。

8221
13:44:22.619 --> 13:44:24.114
现在我们来做纱帽。

8222
13:44:24.114 --> 13:44:32.127
开始新项目时，我们会选择create一个空的hard hat。config。js因为我们知道基本项目是什么样子的。

8223
13:44:32.127 --> 13:44:37.327
我们会给这个项目我们想要看到的自定义，我们会创建一个空的hard hat。config。

8224
13:44:37.327 --> 13:44:40.597
现在我们有了一个空白的硬头。

8225
13:44:40.597 --> 13:44:41.114
配置。

8226
13:44:41.114 --> 13:44:43.094
这里几乎什么都没有。

8227
13:44:43.094 --> 13:44:44.822
所以我们完全是从零开始。

8228
13:44:44.822 --> 13:44:47.400
现在我们要把所有的依赖项都加进来。

8229
13:44:47.494 --> 13:44:54.838
通常情况下，你会在构建的过程中依次添加它们但我们只是将它们都添加在一行中，它们有很多。

8230
13:44:54.838 --> 13:45:03.003
我们留下了一个拷贝，粘贴完整的区块链固体性课程js的整个部分，你只需要复制，粘贴，所以你可以一次安装所有东西。

8231
13:45:03.003 --> 13:45:06.332
抓住这条线，它就会包含我们之前讨论过的所有内容。

8232
13:45:06.332 --> 13:45:10.382
按下回车键，就能安装所有这些。

8233
13:45:10.494 --> 13:45:17.528
当您创建越来越多的项目时，您就会知道您喜欢什么依赖项以及您喜欢使用什么工具。

8234
13:45:17.528 --> 13:45:24.178
记住，在一天结束的时候，最适合你和最适合工作的工具是你最喜欢的工具。

8235
13:45:24.178 --> 13:45:29.287
从来没有真正的万能工具，几乎总是会有权衡。

8236
13:45:29.287 --> 13:45:38.690
好了，现在我们已经安装了所有的依赖项，如果我们看一下我们的包，JSON会有大量的开发依赖项，我们会在Node模块中有所有的东西在yarn。lock中有所有的东西。

8237
13:45:38.690 --> 13:45:45.427
当然，正如我们所知道的，为了使其中任何一个实际工作，我们需要将它们添加到Hardhead配置中。

8238
13:45:45.494 --> 13:45:48.036
现在，这里也有很多东西要添加进去。

8239
13:45:48.494 --> 13:46:02.029
同样，如果你想在智能合约，彩票，FCC中找到核心，然后进入Hardhead配置，你可以复制粘贴所有东西放到你的项目中这样你就不必总是自己打出来。

8240
13:46:02.029 --> 13:46:09.850
Meclabs Hardhead waffle anomic labs开始以太扫描更难部署的分割覆盖，或有气体记者心脏有合同大小，这是我们还没有谈到的。

8241
13:46:09.850 --> 13:46:10.807
但我们会的别担心。

8242
13:46:10.807 --> 13:46:13.057
然后require。env。config。

8243
13:46:13.057 --> 13:46:18.807
你们都知道，所有这些小分号都冒出来了，这简直要把我逼疯了。

8244
13:46:18.807 --> 13:46:21.447
再一次，我们可以创建一个更漂亮的点，RC。

8245
13:46:21.447 --> 13:46:27.995
如果你也想从你以前的项目中复制这个，你可以这么做。

8246
13:46:27.995 --> 13:46:31.628
我在这里添加的一个东西是打印宽度为100。

8247
13:46:31.628 --> 13:46:35.672
这只是改变了一行在转入新行之前的长度。

8248
13:46:35.672 --> 13:46:37.187
这是唯一的区别。

8249
13:46:37.187 --> 13:46:40.806
如果我们点击保存，它们就消失了，谢天谢地。

8250
13:46:40.806 --> 13:46:45.114
现在如果我们看固体度的版本，我们现在用的是0,7。

8251
13:46:45.114 --> 13:46:45.161
3.

8252
13:46:45.161 --> 13:46:47.945
让我们把它更新为8。

8253
13:46:47.945 --> 13:46:48.245
8或8。

8254
13:46:48.245 --> 13:46:49.745
7，或者任何你想用的。

8255
13:46:49.745 --> 13:46:54.600
现在我们已经有了所有的基本设置，我们可以开始编写智能合约了。

8256
13:46:54.600 --> 13:47:03.253
首先，我们需要创建一个新文件夹，叫做contract，用来存储所有的合同。

8257
13:47:03.253 --> 13:47:09.035
我们来创建一个新文件叫lottery。soul或者raffle。soul，随便你怎么叫。

8258
13:47:09.035 --> 13:47:11.219
我要叫我的抽奖。灵魂。

8259
13:47:11.219 --> 13:47:15.341
你可能会看到索引的事情时常发生。

8260
13:47:15.341 --> 13:47:19.695
这是我们的硬帽子，固体扩展，索引所有的节点模块。

8261
13:47:19.695 --> 13:47:24.209
它知道如何高亮显示内容，知道如何处理固体性文件中的所有内容。

8262
13:47:24.209 --> 13:47:26.331
这就是它出现时的情况。

8263
13:47:26.331 --> 13:47:30.066
在我们开始创建它之前，让我们先弄清楚我们要做什么。

8264
13:47:30.066 --> 13:47:32.199
我们要创建抽奖合同。

8265
13:47:32.199 --> 13:47:42.649
我们希望人们能做什么?好吧，我们可能希望人们能够进入彩票，你知道，支付一定的金额，我们可能希望能够随机选择一个赢家。

8266
13:47:42.649 --> 13:47:47.446
但我们希望它是可验证的随机的，我们希望它没有被碗篡改过。

8267
13:47:47.496 --> 13:47:57.430
我们还希望每隔X分钟、几年或几个月选出一次获胜者，也就是说，我们希望这是完全自动化的。

8268
13:47:57.496 --> 13:48:03.257
所以我们想部署智能合约几乎不需要维护几乎没有人再碰它。

8269
13:48:03.257 --> 13:48:04.737
它会自动一直运行下去。

8270
13:48:04.737 --> 13:48:06.285
这就是智能合约的力量。

8271
13:48:06.285 --> 13:48:18.185
正如我们所知，由于我们选择了一个随机数，并且我们有一些事件驱动的执行，我们知道我们将需要使用一个链链接Oracle，因为我们将需要从区块链外部获得随机性。

8272
13:48:18.185 --> 13:48:22.116
我们需要自动执行。

8273
13:48:22.116 --> 13:48:27.733
因为智能合约可以自动执行，所以我们需要有人自动触发这些合约。

8274
13:48:27.733 --> 13:48:31.846
为了触发选择赢家，我们必须使用链链保持器。

8275
13:48:31.846 --> 13:48:34.396
这就是我们的全部代码。

8276
13:48:34.496 --> 13:48:37.254
现在，我通常喜欢在开始任何项目之前这样做。

8277
13:48:37.496 --> 13:48:49.338
我做头脑风暴的原因是，我们不想一开始就什么都不做，我们想对我们要构建的东西有一个很好的想法，这样我们就可以为它编写测试，这样我们就可以知道我们的方向是否正确，等等。

8278
13:48:49.338 --> 13:48:53.157
现在我们对我们的目标有了一个很好的想法，让我们构建它。

8279
13:48:53.157 --> 13:48:57.237
按惯例，我们用spdx许可证标识符。

8280
13:48:57.237 --> 13:49:02.972
我的团队会在这里写pragma solidity, 0点8。

8281
13:49:02.972 --> 13:49:18.297
7，甚至缩小，只要一毛毛就会被丢弃我们会说合同，抽奖，我们甚至可以确保我们没有疯掉通过做一点纱线Hardhead编译编译成功，我们希望它能够进入彩票希望我们能够进入它。

8282
13:49:18.297 --> 13:49:21.763
也许我们会创建一个函数，叫enter raffle。

8283
13:49:21.763 --> 13:49:25.309
我们还想做什么呢，我们想随机选出一个赢家。

8284
13:49:25.309 --> 13:49:30.684
也许我们可以创建一个函数，随机选择一个赢家。

8285
13:49:30.684 --> 13:49:32.934
现在让我们随便选一个。

8286
13:49:32.934 --> 13:49:35.425
我们来做抽奖的事吧。

8287
13:49:35.425 --> 13:49:46.221
在过去，我们已经创建了像Funmi这样的项目，在那里人们可以向我们的合约发送以太币，或者使用基于某些美元价值的消息点值向我们的智能合约发送任何原生区块链令牌。

8288
13:49:46.221 --> 13:49:52.063
对于这款游戏，我们将使用以美元为基础的入场费，这将是本地资产。

8289
13:49:52.063 --> 13:49:56.862
所以对于我们的抽奖，我们不需要设置美元价格，我们只需要设置最低价格。

8290
13:49:56.862 --> 13:50:00.005
在上面，我们取最小价格。

8291
13:50:00.005 --> 13:50:02.339
所以我们要收256的入场费。

8292
13:50:02.339 --> 13:50:12.446
现在我们从上一节学到的一些知识应该用到这里，我们现在知道这个入场费将是一个什么，它将是一个存储变量。

8293
13:50:12.497 --> 13:50:17.981
我们在它前面加上s下划线我们设一个私有变量因为我们总想设置可见性。

8294
13:50:17.981 --> 13:50:20.444
但是让我们让入场费是可配置的。

8295
13:50:20.444 --> 13:50:22.441
现在让我们创建一个构造函数。

8296
13:50:22.441 --> 13:50:34.087
我们会在构造函数中设置这个入口费，构造函数会取一个UNT 2的6次方入口费，s下划线入口费等于入口费。

8297
13:50:34.087 --> 13:50:38.890
如果我们只设置一次，我们也可以将它设为常数或不可变变量。

8298
13:50:38.890 --> 13:50:51.078
我们把它设为一个不可变变量这样可以节省一些汽油我们把它从S换成I现在我们说你面试了6个私人不可变I入场费等于入场费。

8299
13:50:51.078 --> 13:50:54.514
现在我们可能想让其他用户看到入场费。

8300
13:50:54.514 --> 13:51:05.108
在下面，我们可以创建函数get入口费，这将是一个公共视图函数它将返回一个UN到集合Next，我们将写入return入口费。

8301
13:51:05.108 --> 13:51:08.514
现在我们有一个功能，用户可以调用它来获取入场费。

8302
13:51:08.514 --> 13:51:13.040
但我们，作为开发者，可以利用AI入场费知道这是一个不可变的变量。

8303
13:51:13.040 --> 13:51:41.294
这是相当便宜的天然气明智的我们读从进入抽奖活动,我们做了大量的这些之前,我们需要做的是我们只需要需要消息点值大于我强调入场费,我们之前学到的关于这些错误代码,所以我们可以使用需要消息点价值,或者我们可以做其中的一个客户,也就是更多的天然气高效,因为不是存储这个字符串,我们只需要在智能合约中存储错误代码。

8304
13:51:41.294 --> 13:51:42.137
我们来做一下。

8305
13:51:42.137 --> 13:51:53.225
相反，我们会说，如果消息点值小于我们的眼睛入口费用，那么我们就会用一些错误代码恢复整个交易。

8306
13:51:53.225 --> 13:52:00.924
我们将使用命名raffle的最佳实践。

8307
13:52:00.924 --> 13:52:03.450
我们抓取这个箭头代码。

8308
13:52:03.450 --> 13:52:17.707
如果用户没有发送足够的值将会返回，但没有输入足够的eath现在我们知道他们调用了有足够值的raffle，我们可能会想要跟踪所有实际进入我们的raffle的用户。

8309
13:52:17.707 --> 13:52:20.707
这样，当我们选出赢家时，我们就知道谁有希望。

8310
13:52:20.707 --> 13:52:23.921
让我们在顶部错误处创建一个玩家数组。

8311
13:52:23.921 --> 13:52:28.411
然后为了让它看起来更好，我们在这里做一点注释。

8312
13:52:28.411 --> 13:52:29.971
我们说状态变量。

8313
13:52:29.971 --> 13:52:35.022
我们将把存储变量和非存储变量合并到状态变量部分。

8314
13:52:35.022 --> 13:52:37.859
我们会做地址数组播放器。

8315
13:52:37.859 --> 13:52:45.770
当然，玩家必须在存储中，因为我们会经常修改这个，我们会一直加减玩家。

8316
13:52:45.770 --> 13:52:49.958
我们要做的是，s players也会将这个设为私有。

8317
13:52:49.958 --> 13:52:56.514
我们将使这个地址为可支付的玩家因为其中一个玩家赢了，我们将需要支付给他们。

8318
13:52:56.514 --> 13:52:59.728
我们将使这个地址作为玩家的可支付私有。

8319
13:52:59.728 --> 13:53:06.114
既然我们要将这个设为私有，知道谁在播放器数组中是很好的，我们甚至会用函数itplayer。

8320
13:53:06.114 --> 13:53:12.405
这将是一个返回其中一个玩家地址的公共视图。

8321
13:53:12.405 --> 13:53:22.879
我们会返回s players of index会有这个函数，取un256 index作为输入参数，我们知道players将是一个存储变量。

8322
13:53:22.879 --> 13:53:29.981
我们会把它加到我们的抽奖中，我们当然希望我们的抽奖是公开的，是可支付的。

8323
13:53:29.981 --> 13:53:35.869
因为我们让人们发送message。value，我们希望任何人都能进入我们的抽奖。

8324
13:53:35.869 --> 13:53:38.467
这将是公共的，可支付的，这将是完美的。

8325
13:53:38.467 --> 13:53:45.963
现在我们有了数组，有人进入了抽奖，我们会写s players。push message。sender。

8326
13:53:45.963 --> 13:53:51.806
这实际上不起作用，因为message。sender不是一个可支付地址。

8327
13:53:51.806 --> 13:53:56.837
因此，我们需要将其类型转换为一个可支付地址，只需将其包装在可支付中。

8328
13:53:56.837 --> 13:54:01.239
现在我们有了一种跟踪所有参加抽奖的玩家的方法。

8329
13:54:01.239 --> 13:54:07.386
我们还没有讲的一个概念是事件。

8330
13:54:07.386 --> 13:54:10.277
事件对我们的智能合约非常重要。

8331
13:54:10.277 --> 13:54:17.911
每当更新动态对象(如数组或映射)时，我们总是希望在小于10时省略一个事件。

8332
13:54:17.911 --> 13:54:26.125
特别是低于15的Jas和if T市场，这些事件将非常有意义，特别是对前端开发者。

8333
13:54:26.125 --> 13:54:30.951
所以现在事件对你来说可能有点奇怪，我们来解释一下。

8334
13:54:30.951 --> 13:54:33.637
但随着我们继续，它们会变得越来越有意义。

8335
13:54:33.637 --> 13:54:36.428
我们将开始向智能合约中添加事件。

8336
13:54:36.428 --> 13:54:39.800
每当我们更新这些动态大小的数据结构之一时。

8337
13:54:39.800 --> 13:54:41.656
并学习更多关于事件和如何使用它们的知识。

8338
13:54:41.656 --> 13:54:44.270
我们将观看另一个解释所有事件的视频。

8339
13:54:44.270 --> 13:54:47.450
你可以把这个视频作为一个副业来学习。

8340
13:54:47.450 --> 13:54:48.921
但是让我们来学习所有的事件。

8341
13:54:48.921 --> 13:54:55.833
现在，如果你用过固体，你可能见过这些叫做事件的东西或者你可能没见过类似事件的东西。

8342
13:54:55.833 --> 13:55:01.221
但你总是想知道链链或图或其他一些链外协议是如何在底层工作的。

8343
13:55:01.221 --> 13:55:08.714
在这个视频中，我们将学习在固体中记录和事件，在以太扫描中查看这些事件，然后在安全帽中使用它们。

8344
13:55:08.714 --> 13:55:11.999
现在是以太坊虚拟机，简称EVM。

8345
13:55:11.999 --> 13:55:15.245
这使得很多区块链能够运行，比如Aetherium。

8346
13:55:15.245 --> 13:55:19.435
EVM有一个叫做日志功能的功能。

8347
13:55:19.500 --> 13:55:28.696
当区块链上发生事情时，EVM将这些东西写到一个叫做它的日志的特定数据结构中，我们实际上可以从我们运行的区块链节点读取这些日志。

8348
13:55:28.696 --> 13:55:36.000
事实上，如果您运行一个节点或连接到一个节点，您可以通过F get logs调用来获取日志。

8349
13:55:36.000 --> 13:55:40.008
在这些日志中有一个重要的日志记录，叫做事件。

8350
13:55:40.008 --> 13:55:43.448
这是我们今天要讨论的主要部分。

8351
13:55:43.500 --> 13:55:52.567
事件允许您以一种比实际将信息保存到存储变量等更省油的方式将信息打印到日志记录结构中。

8352
13:55:52.567 --> 13:55:58.371
这些事件和日志存在于智能合约无法访问的特殊数据结构中。

8353
13:55:58.371 --> 13:56:10.907
这就是为什么它更便宜的原因，因为智能合约可以访问它们，所以如果在这里权衡，我们仍然可以打印一些对我们重要的信息，而不必把它保存在存储变量中，这会占用更多的汽油。

8354
13:56:10.907 --> 13:56:17.501
这些事件中的每一个都与在这些事务中发出该事件的智能合约或帐户地址相关联。

8355
13:56:17.501 --> 13:56:19.839
倾听这些事件非常有帮助。

8356
13:56:19.839 --> 13:56:25.190
举个例子，你想在每次有人调用传递函数时都做些什么。

8357
13:56:25.190 --> 13:56:34.009
而不是总是读取所有的变量并寻找可以翻转和切换的内容，你所要做的就是说，监听事件。

8358
13:56:34.009 --> 13:56:36.551
因此，一个事务发生，一个事件被触发。

8359
13:56:36.551 --> 13:56:38.262
我们可以听这些事件。

8360
13:56:38.262 --> 13:56:40.813
这就是许多链下基础设施的工作方式。

8361
13:56:40.813 --> 13:56:53.286
当你在一个网站上，当一个交易完成时网站会重新加载，它实际上是在监听那个交易来完成监听那个事件被触发，这样它就可以重新加载或者做其他事情。

8362
13:56:53.286 --> 13:56:55.957
这对前端非常重要。

8363
13:56:55.957 --> 13:57:01.132
它对链结和链结网络中的图也非常重要。

8364
13:57:01.132 --> 13:57:07.876
链式链接节点实际上监听请求数据事件，以获取随机数、进行API调用等。

8365
13:57:07.876 --> 13:57:10.376
有时候事情太多了。

8366
13:57:10.376 --> 13:57:17.534
你需要以一种有意义的方式为它们建立索引这样你就可以查询以后发生的所有事件。

8367
13:57:17.534 --> 13:57:23.018
图监听这些事件并将它们存储在图中，以便稍后查询。

8368
13:57:23.018 --> 13:57:25.362
所以事件是非常强大的。

8369
13:57:25.501 --> 13:57:26.693
它们有广泛的用途。

8370
13:57:27.501 --> 13:57:30.066
测试和其他一些东西，但你应该能理解。

8371
13:57:30.502 --> 13:57:31.052
真的病了。

8372
13:57:33.502 --> 13:57:38.859
它们是什么样的，我们如何使用它们，以及我们如何在智能合约开发套件中使用它们。

8373
13:57:38.859 --> 13:57:41.312
这就是事件的样子。

8374
13:57:41.312 --> 13:57:43.792
这里有一个事件叫stored number。

8375
13:57:43.792 --> 13:57:47.592
我们有了一种新的事件叫做存储数。

8376
13:57:47.592 --> 13:57:56.911
我们说，嘿，稳健，嘿，智能合约，我们有了这个新的事件，我们将省略未来类型化存储数的东西。

8377
13:57:56.911 --> 13:58:01.846
当我们触发这个事件时，它会有这四个参数，它会有一个唯一的256。

8378
13:58:01.846 --> 13:58:02.983
被叫旧号码。

8379
13:58:02.983 --> 13:58:09.028
你感兴趣吗?是新号码吗?你被吓倒了吗?加一个号码和一个地址，叫中心。

8380
13:58:09.028 --> 13:58:17.108
聪明的人可能会注意到这里还有一个关键字，索引到关键字这是一个非常重要的关键字。

8381
13:58:17.108 --> 13:58:27.157
当我们忽略其中一个事件时，有两种形参，即索引形参和非索引形参，最多可以有三个索引形参。

8382
13:58:27.157 --> 13:58:28.879
它们也被称为主题。

8383
13:58:28.879 --> 13:58:33.090
如果你看到一个主题，你就知道那将是一个索引参数。

8384
13:58:33.090 --> 13:58:40.295
索引参数是比非索引参数更容易搜索和查询的参数。

8385
13:58:40.295 --> 13:58:46.036
事实上，我们推荐F获取日志功能，它甚至有一个参数允许我们搜索特定的主题。

8386
13:58:46.036 --> 13:58:49.847
所以它比没有索引的更容易搜索。

8387
13:58:49.847 --> 13:58:56.453
没有索引的更难搜索，因为它们是ABI编码的，为了解码它们，您必须了解API。

8388
13:58:56.502 --> 13:59:08.928
现在，它告诉我们的智能合约这里有一种新的存储数字类型，一种新的事件类型，我们需要发出该事件以便将数据存储到EVM的日志数据结构中。

8389
13:59:08.928 --> 13:59:12.125
要做到这一点，我们需要做一些像这样的东西。

8390
13:59:12.125 --> 13:59:17.128
这就是我们触发事件时的样子，它看起来与调用函数非常相似。

8391
13:59:17.128 --> 13:59:21.034
你先叫棒球手套，然后是比赛的名字。

8392
13:59:21.034 --> 13:59:24.115
然后把你喜欢的参数都加进去。

8393
13:59:24.115 --> 13:59:30.454
这是一个智能合约的完整例子，它有一个事件，这将是我们在安全帽中讲过的例子。

8394
13:59:30.503 --> 13:59:36.083
在智能合约中，只要有人调用store函数，我们就会省略这个事件。

8395
13:59:36.083 --> 13:59:56.434
这是一个事务的例子，我们调用值为1的store函数，让我们看看日志，看看这个事件实际上会是什么样子一个事件会被分解，比如契约或帐户的地址，事件从主题发出或事件数据的索引参数。

8396
13:59:56.503 --> 14:00:01.416
这是ABI编码的事件的非索引参数。

8397
14:00:01.503 --> 14:00:13.608
这是什么意思?这意味着我们取那些没有索引的参数，我们将它们与它们的API或应用程序二进制接口相匹配，通过编码算法将它们泵入，然后，这就是我们得到的。

8398
14:00:13.608 --> 14:00:16.248
如果你有API，它们很容易解码。

8399
14:00:16.248 --> 14:00:24.875
如果你没有ABI，它们就很难解码这些非索引参数，将更少的气体泵入日志。

8400
14:00:24.875 --> 14:00:35.206
现在在这个特定的合同中，因为我们已经验证了代码，我们验证了合同以太扫描知道ABI是什么，我们可以在Deke或解码模式中查看它。

8401
14:00:35.206 --> 14:00:41.440
十六进制模式显然是非解码模式，或者在其原始、十六进制或编码模式中。

8402
14:00:41.503 --> 14:00:45.921
你可以在solidity文档中阅读更多关于这些事件布局的内容。

8403
14:00:45.921 --> 14:00:50.693
这就是事件的基本介绍。

8404
14:00:50.693 --> 14:01:10.452
,对于你们中那些想看剩下的视频,和谁想真正实践自己使用事件,有一个链接到这些视频和视频相关的代码库,如果你想玩,如果你想了解更多,所以随时准备参考完整的区块链可靠性,雅,如果你想要更深入事件现在我们回来了,我们学到了更多关于事件,让我们添加一些事件来本合同。

8405
14:01:10.504 --> 14:01:15.004
记住，这些事件被发送到智能合约外部的数据存储。

8406
14:01:15.004 --> 14:01:23.237
让我们创建一个名为raffle的事件为命名事件输入一个良好的语法，命名事件，将函数名颠倒。

8407
14:01:23.237 --> 14:01:26.361
对于enter raffle，我们会说raffle entered。

8408
14:01:26.361 --> 14:01:33.004
在状态变量下面的顶部，但在构造函数上面，我们会创建一个叫做events的新部分。

8409
14:01:33.004 --> 14:01:35.754
我们将创建第一个事件。

8410
14:01:35.754 --> 14:01:38.143
我们会做event, raffle, Enter。

8411
14:01:38.143 --> 14:01:44.900
我们让这个raffle enter带一个索引参数，它会是一个地址索引播放器。

8412
14:01:44.900 --> 14:01:48.827
在interraffle中，我们会说省略raffle enter。

8413
14:01:48.827 --> 14:01:51.471
我们将传递它message。sender。

8414
14:01:51.471 --> 14:01:53.585
我现在要删除这些注释。

8415
14:01:53.585 --> 14:01:56.149
但在编写代码时，请随意保留它们。

8416
14:01:56.149 --> 14:02:04.391
现在，在抽奖编码过程的这一部分，我可能已经开始编写一些测试和部署脚本了。

8417
14:02:04.391 --> 14:02:08.453
我们这样做的原因是，它有助于在开发过程中测试我们的功能。

8418
14:02:08.504 --> 14:02:18.941
通常，当我在写智能合约的时候，我经常在部署脚本，合约和测试之间来回切换以确保所有事情都完全符合我这门课的目的。

8419
14:02:18.941 --> 14:02:22.722
为了方便你们学习和理解，我们不打算这么做。

8420
14:02:22.722 --> 14:02:30.412
我们将继续编写我们的智能合约，几乎完成，然后转移到部署脚本和测试。

8421
14:02:30.505 --> 14:02:35.130
所以从极简的意义上来说，我们基本上为人们提供了一种参与抽奖的方式。

8422
14:02:35.130 --> 14:02:37.786
现在我们需要一种随机挑选赢家的方法。

8423
14:02:37.786 --> 14:02:41.436
这就是我们需要链链VRF和链链保持者的地方。

8424
14:02:41.436 --> 14:02:45.226
让我们再看一些关于链条VRF的课程。

8425
14:02:45.226 --> 14:02:47.115
学习链链管理员。

8426
14:02:47.115 --> 14:02:49.250
我们之前做过一些相关的视频。

8427
14:02:49.250 --> 14:02:50.718
我们将播放这些视频。

8428
14:02:50.718 --> 14:02:58.387
所以你可以学习到taling VRF版本2是如何工作的，以及链链接保持器是如何工作的，然后我们回来，我们将把它们添加到我们的合同中。

8429
14:02:58.387 --> 14:03:02.241
如果你已经熟悉它们，并且已经玩过它们，请跳过这些部分。

8430
14:03:02.241 --> 14:03:04.398
我们会在这里建造它们。

8431
14:03:04.505 --> 14:03:05.335
嗨，我的名字是史蒂文流体。

8432
14:03:06.505 --> 14:03:08.064
看链环节VRF。

8433
14:03:10.505 --> 14:03:12.117
我们应该注意不同的心智模式。

8434
14:03:12.505 --> 14:03:15.005
向你展示使用它的感觉。

8435
14:03:15.505 --> 14:03:30.705
关于Vera版本2，需要知道的一件重要的事情是，与Vera 1模式不同，您将为与Link的合同提供资金，相反，您将为订阅提供资金，这基本上是一个允许您为多个消费者合同提供资金并保持平衡的帐户。

8436
14:03:30.705 --> 14:03:34.695
让我们深入到文档中，看看使用Vera fie two的外观和感觉是怎样的。

8437
14:03:34.695 --> 14:03:36.552
为了展示一下这个。

8438
14:03:36.552 --> 14:03:41.201
我将直接进入链链接文档中的获取随机数指南。

8439
14:03:41.201 --> 14:03:44.739
因此，我们将介绍一些我们今天将要使用的技术的要求。

8440
14:03:44.739 --> 14:03:49.409
它要求我们做的第一件事是确保我们在林克比测试网上。

8441
14:03:49.409 --> 14:03:51.795
让我们跳到林克比。

8442
14:03:51.795 --> 14:03:54.375
确保我的元蒙版在这里解锁。

8443
14:03:54.505 --> 14:04:00.305
现在我在Rinkeby上，很好，我应该可以用VIP版测试网了。

8444
14:04:00.305 --> 14:04:03.521
现在我们要跳到订阅管理器。

8445
14:04:03.521 --> 14:04:07.091
订阅管理器是我们管理订阅帐户的地方。

8446
14:04:07.091 --> 14:04:12.663
基本上，这是你把资金投入的地方以便能够在许多不同的链条上使用它。

8447
14:04:12.663 --> 14:04:17.521
我们将在这里连接我们的钱包以便使用订阅应用。

8448
14:04:17.521 --> 14:04:21.109
然后我们会创建一个新的订阅。

8449
14:04:21.109 --> 14:04:24.589
这里用我的地址作为订阅地址。

8450
14:04:24.589 --> 14:04:26.755
我会批准的。

8451
14:04:26.755 --> 14:04:30.742
一旦交易被确认，我们的订阅就会被创建。

8452
14:04:30.742 --> 14:04:33.360
好了，现在我们有了订阅。

8453
14:04:33.506 --> 14:04:35.472
基本上，这就是我们要资助它的账户。

8454
14:04:35.506 --> 14:04:39.030
然后我们就可以用这个账户处理所有的Miss请求。

8455
14:04:39.030 --> 14:04:44.946
我要在这里放10个链接，你想放多少就放多少。

8456
14:04:44.946 --> 14:04:55.349
你所要求的每个随机数的价格和链接，都将基于给定链上的当前汽油价格，以及你所选择的汽油。

8457
14:04:55.349 --> 14:04:58.878
在我们的资金已经添加之后，让我们继续添加一个消费者契约。

8458
14:04:58.878 --> 14:05:02.193
它问我们消费者地址，我们还没有消费者地址。

8459
14:05:02.193 --> 14:05:08.883
让我们继续，跳过文档，创建一个将请求一个数字的契约。

8460
14:05:08.883 --> 14:05:15.215
如果你向下滚动，你会看到Vera向消费者支付的费用这个灵魂契约我们可以在混合中打开它，让我们跳到这里。

8461
14:05:15.215 --> 14:05:19.872
我们会注意到合同顶部有一些不同的东西，我们有一些输入。

8462
14:05:19.872 --> 14:05:27.934
现在你有了VRF，消费者基础版本2，我们有了一个VRF协调器的接口，还有一个链接令牌接口的引用。

8463
14:05:27.934 --> 14:05:32.133
所有这些都是在Rinkeby网络的示例代码中指定的。

8464
14:05:32.133 --> 14:05:36.306
然后您可以参考文档，以了解您要部署到的任何链。

8465
14:05:36.306 --> 14:05:39.768
然后你会在这里看到一些新的选项。

8466
14:05:39.768 --> 14:05:45.828
关键的哈希选项是你指定汽油的方式在文档中有描述。

8467
14:05:45.828 --> 14:05:54.210
根据你为给定链选择的键哈希值对随机数请求设置的气体限制不同。

8468
14:05:54.210 --> 14:05:59.916
举个例子，在一个理论主网上，我们有200个键哈希500个维基哈希和1000个灰键哈希。

8469
14:05:59.916 --> 14:06:04.687
你也可以在我们的合同中看到听说我们有一个回调评估，由你负责。

8470
14:06:04.687 --> 14:06:11.055
根据你想在实现随机数中消耗多少汽油，你应该适当地设置这个值。

8471
14:06:11.055 --> 14:06:13.184
接下来是请求确认。

8472
14:06:13.184 --> 14:06:15.882
所以在验证过程中这是你无法控制的。

8473
14:06:15.882 --> 14:06:23.618
但现在，取决于你所在的链，取决于请求和你想要发出的请求的类型性质，你实际上可以改变这个数字。

8474
14:06:23.618 --> 14:06:33.664
一个最重要和有用的特性它给了你更多的灵活性和对VRF的控制你可以指定你想要的随机数的数量。

8475
14:06:33.664 --> 14:06:41.491
所以你指定数字单词，然后这将指定你从网络返回到56的随机数。

8476
14:06:41.491 --> 14:06:47.507
在构造函数中，我们会看到协调器的地址和链接令牌的地址。

8477
14:06:47.507 --> 14:06:51.268
然后您将看到，在部署契约时将创建订阅ID。

8478
14:06:51.268 --> 14:06:53.744
我要把它取下来。

8479
14:06:53.744 --> 14:07:00.607
如果你还记得我们在找到订阅后创建订阅时，我们看到这个订阅ID，现在我部署这个时，我将使用那个订阅ID。

8480
14:07:00.607 --> 14:07:13.717
我们有两个看起来很熟悉的方法，一个是随机数实现方法它接收到的随机性将由Oracle局实现，还有一个是请求随机词，这是我们向Oracle发起请求的方式。

8481
14:07:13.717 --> 14:07:16.861
所以我认为我们实际上已经准备好去部署它了。

8482
14:07:16.861 --> 14:07:21.894
所以让我们跳转到部署屏幕，选择正确的合同，在我们的例子中，就是你的FB to consumer。

8483
14:07:21.894 --> 14:07:27.457
我要确保我是在注射web 3上这样我们就可以部署到Rinkeby网络。

8484
14:07:27.507 --> 14:07:29.201
我将粘贴订阅ID到这里。

8485
14:07:29.507 --> 14:07:35.409
在部署之前，让我们继续为事务支付。

8486
14:07:35.508 --> 14:07:46.174
一旦网络确认了，就会显示在这里，我们就能复制这个地址，然后以消费者的身份添加这个地址并授权这个合同使用我的订阅帐户。

8487
14:07:46.174 --> 14:07:56.269
让我们继续并授权给他们另一个Metamask事务。

8488
14:07:56.508 --> 14:07:59.472
好的，我们可以让你订阅，我们可以看到我们资助了多少链接。

8489
14:07:59.472 --> 14:08:01.032
我们可以看到我们的消费者契约。

8490
14:08:01.032 --> 14:08:07.219
通过这样做，我们授权消费者契约对随机性发出请求。

8491
14:08:07.219 --> 14:08:09.915
让我们继续，在这里要求随机性。

8492
14:08:09.915 --> 14:08:12.721
所以我们要回到我们在这里部署的合同。

8493
14:08:12.721 --> 14:08:16.344
我们将使用这里的remix界面，让事情变得简单。

8494
14:08:16.344 --> 14:08:18.436
我要求一些随机性。

8495
14:08:18.436 --> 14:08:24.974
显然，这将使用我在合同中指定的所有配置，只是硬编码在这里。

8496
14:08:24.974 --> 14:08:26.542
我们会讲到随机的单词。

8497
14:08:26.542 --> 14:08:30.814
所以我们要点击随机请求，确认里格比交易。

8498
14:08:30.814 --> 14:08:36.258
一旦事务返回，我们会注意到我们实际上有一个请求。

8499
14:08:36.258 --> 14:08:41.944
然后我们要做的是等待神使调用合约上的随机数实现。

8500
14:08:41.944 --> 14:08:47.475
然后我们将所有这些随机单词存储在这个随机单词中，存储变量。

8501
14:08:47.475 --> 14:08:50.793
让我们继续检查，看看我们的随机数字是否从Oracle返回。

8502
14:08:50.793 --> 14:08:52.554
我将在这里进入随机单词。

8503
14:08:52.554 --> 14:08:56.901
让我们请求数组的第0项看起来我们得到了一个随机数。

8504
14:08:56.901 --> 14:09:01.697
因为我们要求两个随机数，所以在索引1中也应该有一项。

8505
14:09:01.697 --> 14:09:04.650
好了，我们我们有了随机性。

8506
14:09:04.650 --> 14:09:34.460
如果我们回到订阅管理器应用，你会看到这里有一个事件历史项，我们会看到我们花了第三点，三个链接来得到那两个随机数字，我们刚刚经历了一段旅程来看看它是什么样子和感觉使用Veera版本2，现在我们已经了解了更多关于链链接VRF的知识，我希望你们能花点时间去doxa chain link看看这样你们就能理解到底发生了什么，我们将用这个样本契约来创建我们的函数它将随机选择获胜者。

8507
14:09:34.509 --> 14:09:49.456
这是一个在链上的契约，它与一个可验证的随机链节点相协调，给我们一个随机数，你可以直接在链上看代码，或者你可以直接到链上的GitHub看所有的代码，看看这是如何被证明是随机发生的。

8508
14:09:49.509 --> 14:09:52.396
我们会在与这门课相关的GitHub回购中找到这个链接。

8509
14:09:52.396 --> 14:10:04.259
所以我们要在这里创建一个函数叫做随机选择一个赢家，这个函数将被链链守护者网络调用这样它就可以自动运行而不需要我们与它交互。

8510
14:10:04.259 --> 14:10:10.526
实际上，当我们更新这个的时候，我想在这里加一些星号表示视图/纯函数。

8511
14:10:10.526 --> 14:10:18.609
现在我们随机选择赢家函数，我们实际上不打算将它设为公共函数我们将设为外部函数，外部函数比公共函数便宜一点。

8512
14:10:18.609 --> 14:10:26.807
因为实体性知道我们自己的契约可以调用它，我们实际上也会改变这个函数的名字，很快，我们会稍微讲到这个。

8513
14:10:26.807 --> 14:10:33.309
为了选出随机赢家，我们需要做两件事，首先我们需要请求随机数。

8514
14:10:33.309 --> 14:10:36.545
一旦我们得到它，就用它做点什么。

8515
14:10:36.545 --> 14:10:39.754
因此链链VRF是一个双事务处理过程。

8516
14:10:39.754 --> 14:10:41.917
这实际上是故意的。

8517
14:10:41.917 --> 14:10:47.450
在两个事务中使用随机数实际上也比在一个事务中使用随机数好得多。

8518
14:10:47.450 --> 14:10:59.716
如果只有一个事务，那么人们可以尝试模拟调用这个事务，我们很快会学习如何模拟调用这些事务，看看他们可以操作什么，以确保他们是赢家。

8519
14:10:59.716 --> 14:11:01.440
我们要确保这是绝对公平的。

8520
14:11:01.510 --> 14:11:07.978
没有人能操纵智能合约让他们成为彩票的中奖者，这个函数会请求它。

8521
14:11:07.978 --> 14:11:11.221
然后在第二个函数中，随机数将被返回。

8522
14:11:11.221 --> 14:11:18.700
在我们从链条网络中获得随机数的交易中，也就是我们将钱寄给赢家的时候。

8523
14:11:18.700 --> 14:11:36.408
如果我们去看chain chain的文档，chain chain节点调用的函数是这个函数，这个函数叫fulfillment random words，这是请求函数，我们甚至可以把它改成request random winner，让它更清楚，然后我们会让一个函数实现random words。

8524
14:11:36.510 --> 14:11:44.748
这将是一个内部覆盖，我们稍后会解释一下，现在实现随机数实现随机数。

8525
14:11:44.748 --> 14:11:52.331
这个词来自于一个计算机科学术语，但你基本上可以把它看作完全随机数，因为我们可以得到多个随机数。

8526
14:11:52.331 --> 14:12:02.923
现在为了使我们的抽奖合同VRF成为一个碗，我们必须导入链链接代码，我们可以回到文档，我们只需要抓取这条底线我们马上会抓取这条上边的线。

8527
14:12:02.923 --> 14:12:06.667
我们要做import，我把它写出来。

8528
14:12:06.667 --> 14:12:13.069
但如果你想复制粘贴，你可以at chain link /合同/ SRC / v0。

8529
14:12:13.069 --> 14:12:17.093
8、斜杠V RF，消费者基数，b二点Sol。

8530
14:12:17.093 --> 14:12:28.983
既然我们导入的是chainlink，斜杠合同，我们需要通过运行yarn，添加dash dev在chainlink斜杠合同。

8531
14:12:28.983 --> 14:12:32.646
现在我们有了这个，我们应该可以像这样导入。

8532
14:12:32.646 --> 14:12:50.445
我们需要使我们的抽奖VRF消费者基础加倍，我们需要继承VRF消费者基础进入我们的节点模块在链链接src, v08 VRF，消费者基础v2，它带有这个函数实现随机单词。

8533
14:12:50.511 --> 14:13:05.511
你可以看到它是一个内部虚函数，虚意味着它会被覆盖，它在消费者基数v2的范围内的原因是VRF协调器，我们待会儿会用到它知道它可以调用这个实现随机词函数。

8534
14:13:05.511 --> 14:13:07.939
这就是我们要重写的函数。

8535
14:13:07.939 --> 14:13:13.752
回到我们的raffle。salt中，我们继承它的方式是VRF消费者基数v2。

8536
14:13:13.752 --> 14:13:29.752
现在如果我们向下滚动到满足随机单词，我们可以添加输入参数满足药丸随机单词，这将是un256，请求ID和un256，一个内存数组随机单词。

8537
14:13:29.752 --> 14:13:39.461
如果我们点击Save我们的linter会注意到，这就是我所期望的，我期望我们覆盖Fill random words，它接受这些参数。

8538
14:13:39.511 --> 14:13:47.070
现在，如果我们查看文档中的构造函数，我们需要传递VRF消费者基V TOS构造函数，并传递VRF协调器。

8539
14:13:47.070 --> 14:13:52.300
同样，这个V RF协调器是进行随机数验证的契约的地址。

8540
14:13:52.300 --> 14:14:02.761
因此，就在我们的构造函数旁边，将VRF消费者基数V添加到构造函数，我们需要传递VRF协调器v2地址。

8541
14:14:02.761 --> 14:14:06.254
在主构造函数中，我们也会把它作为形参添加。

8542
14:14:06.254 --> 14:14:20.248
我们会说地址VRF核心到Nate Torre v2，然后我们会把这个作为VRF消费者的参数传递到现在为止我们应该不再看到那个小下划线了。

8543
14:14:20.248 --> 14:14:24.664
我们应该能够运行纱线没有编译。

8544
14:14:24.664 --> 14:14:25.341
太棒了。

8545
14:14:25.512 --> 14:14:30.085
我们可以看到编译成功的两个文件，我们的代码运行良好。

8546
14:14:30.085 --> 14:14:39.577
我经常做的一件事是我讨厌一直运行纱线硬帽，因为那对我的小大脑来说有太多的键要处理。

8547
14:14:39.577 --> 14:14:45.226
我想写的键越少越好hard hat也希望我们写的键越少越好。

8548
14:14:45.226 --> 14:14:57.465
所以hard hat附带了一个速记和自动完成的速记是一个NPM包，它安装了一个全局可访问的二进制文件，叫做H H，它运行项目的本地安装的硬帽，并支持shell自动完成任务。

8549
14:14:57.465 --> 14:15:08.397
我们能做的是我们会从NPM开始，像这样，但我们会用yarn安装它，我们会运行yarn，全局，添加hardhat速记。

8550
14:15:08.512 --> 14:15:15.167
这将会做什么呢，我们可以看到这里安装了hard hat速记和二进制文件H, H和Hardhead补全。

8551
14:15:15.167 --> 14:15:29.812
现在不运行yarn, Hardhead compile，我们仍然可以运行，我们可以只运行h h compile，运行h h和我们在本地目录运行Hardhead命令是一样的。

8552
14:15:29.812 --> 14:15:36.308
现在我们需要我们的请求随机赢家函数请求一个随机赢家。

8553
14:15:36.308 --> 14:15:37.795
让我们回到文档中。

8554
14:15:37.795 --> 14:15:39.167
我们来看看怎么做。

8555
14:15:39.167 --> 14:15:43.804
我们可以看看这个请求随机单词的函数，看看它是如何工作的。

8556
14:15:43.804 --> 14:15:45.419
关于协调器地址的Vera。

8557
14:15:45.512 --> 14:15:53.388
我们继续调用这个request random words函数，我们需要在协调器契约上调用这个函数来获得协调器契约。

8558
14:15:53.388 --> 14:15:57.851
我们将使用Vera v2协调器接口和Vir的协调器地址。

8559
14:15:57.851 --> 14:16:00.076
我们要记录下这些。

8560
14:16:00.076 --> 14:16:02.038
我们可以在阿肯色州再次这样做。

8561
14:16:02.038 --> 14:16:05.663
因素，我们有地址被传递给我们的局的消费者基础。

8562
14:16:05.663 --> 14:16:07.939
我们也把它作为一个状态函数。

8563
14:16:07.939 --> 14:16:19.669
首先，让我们得到一个接口，这样我们就可以与合约进行交互，我们也可以从chain link导入通过import at chain link /合约/ SRC /费用0。

8564
14:16:19.669 --> 14:16:28.152
8、斜线接口面斜线VRF线到导师V到接口点Sol。

8565
14:16:28.152 --> 14:16:38.754
现在我们导入了这个接口，和价格提要一样，我们可以做VRF，协调器v2，接口VRF协调器。

8566
14:16:38.754 --> 14:16:48.442
然后我们可以用地址保存协调器的范围所以我们可以说VRF协调器等于这个地址VRF协调器否决。

8567
14:16:48.513 --> 14:16:53.906
我们会把那个地址包装在接口周围这样我们就可以使用这个VRF协调器契约了。

8568
14:16:53.906 --> 14:16:57.893
现在我们只需要在构造函数中设置一次VRF协调器。

8569
14:16:57.893 --> 14:17:02.450
我们能做的最好的事情是，私有的，不可变的。

8570
14:17:02.450 --> 14:17:12.873
好，我们来写private，不可变，你有一个coordinator我们把名字改成I，下划线，the ref coordinator这样我们就知道你的coordinator确实是一个不可变变量。

8571
14:17:12.873 --> 14:17:23.168
为了请求随机单词，我们需要给它一些参数，我将把这一行复制到我们的契约中，这样我们就能确切地讨论它发生了什么。

8572
14:17:23.168 --> 14:17:25.594
我们不需要AES请求ID。

8573
14:17:25.594 --> 14:17:29.886
我要强调的不是协调，而是对协调的恐惧。

8574
14:17:29.886 --> 14:17:42.092
我们会在VRF协调器契约上调用请求随机词，我们需要给它传递散列键或者汽油，我更喜欢叫它汽油通道，我们去链链接，Doc去契约地址。

8575
14:17:42.092 --> 14:18:03.080
我们向下滚动可以看到不同的气体通道不同为不同的网络配置参数是关键散列将是汽油的关键哈希,这告诉链条节点的最大价格你愿意支付你的客人和方式例如,如果天然气价格飞涨,这是要花费你很多钱,随机数设定一个上限,我们将使它因此随机数不回来。

8576
14:18:03.080 --> 14:18:07.956
为了选择一个气体通道，我们可能需要把这个气体通道或者这个键哈希存储在某个地方。

8577
14:18:07.956 --> 14:18:11.448
我们把它也设为构造函数的形参。

8578
14:18:11.448 --> 14:18:13.415
我们把它保存为状态函数。

8579
14:18:13.514 --> 14:18:19.433
我们用逗号字节32，汽油或键散列，随便你怎么叫。

8580
14:18:19.433 --> 14:18:21.416
然后我们会得到一个新的状态函数。

8581
14:18:21.514 --> 14:18:23.395
我们只设置一次。

8582
14:18:24.514 --> 14:18:27.169
私人的,不可变的。

8583
14:18:33.514 --> 14:18:38.314
汽油就是汽油。

8584
14:18:38.514 --> 14:18:42.447
现在，我们可以把这个换掉，我强调汽油。

8585
14:18:42.514 --> 14:18:48.799
接下来，我们需要一个订阅ID，订阅ID将是我们为请求提供资金所需的订阅。

8586
14:18:48.799 --> 14:18:55.874
实际上链上有一个契约，我们可以用它来为任何这些外部数据或外部计算位的订阅提供资金。

8587
14:18:55.874 --> 14:19:00.418
在这份合同中，有一个订阅列表供人们提出请求。

8588
14:19:00.418 --> 14:19:12.324
我们需要订阅ID用于请求随机数并支付链接Oracle gas，订阅ID也可能是我们将传递给彩票的参数。

8589
14:19:12.324 --> 14:19:15.936
再一次，滚动到构造函数，我们会添加一个新形参。

8590
14:19:15.936 --> 14:19:22.449
我们的订阅ID不需要是un 256，它可以小一点，用un 64。

8591
14:19:22.515 --> 14:19:28.613
我们会传递一个un64订阅ID，我们会创建一个un64。

8592
14:19:28.613 --> 14:19:33.229
因为我们只设置一次所以我们将它设为私有的，不可变的。

8593
14:19:33.229 --> 14:19:43.405
我在下面加下划线，我们写isubscription ID = subsubscription ID。

8594
14:19:43.515 --> 14:19:44.276
好的,太棒了。

8595
14:19:46.515 --> 14:19:46.668
ID。

8596
14:19:50.515 --> 14:19:56.925
confirmation是一个UN 16，它表示链链接节点在响应之前应该等待多少个确认。

8597
14:19:56.925 --> 14:20:07.115
如果你发出一个请求，只有一个区块确认，你可能不会发送因为你害怕某种区块链重组之类的，我们不会太担心这个。

8598
14:20:07.115 --> 14:20:09.192
实际上我们要让这个常数为3。

8599
14:20:09.192 --> 14:20:14.444
所以我们甚至不用让它是每可摊平的我们要让它是一个常数。

8600
14:20:14.444 --> 14:20:28.207
我们会说，a you int 16 Private constant request, confirations = 3，我们在这里用大写字母和下划线表示常量变量。

8601
14:20:28.207 --> 14:20:31.983
现在我们将抓取请求确认并将其插入这里。

8602
14:20:31.983 --> 14:20:47.915
下一个是回调气体限制回调气体限制是回调请求使用的气体量的限制你的契约满足随机单词，这设置了随机单词可以满足的计算量的限制这是一个很好的方法来保护我们不消耗太多的气体。

8603
14:20:47.915 --> 14:20:53.989
举个例子，如果我们不小心用一种方式来编码我们的契约，实现随机单词是非常昂贵的。

8604
14:20:53.989 --> 14:20:56.410
它会阻止随机数的响应。

8605
14:20:56.516 --> 14:21:01.791
我们要将这个参数设为相当大因为我们想根据我们如何编码我们的随机数来改变它。

8606
14:21:01.791 --> 14:21:06.349
在构造函数中，我们再加一个，我们会加int 32。

8607
14:21:06.349 --> 14:21:20.816
因为这个的大小是un32回调，气体限制，我们将把子顶部保存为un32，私有，不可变，我下划线回调。

8608
14:21:20.816 --> 14:21:21.816
是的限制。

8609
14:21:21.816 --> 14:21:23.982
我们保存这个。

8610
14:21:23.982 --> 14:21:29.815
我回电话限气等于回电话对，限气。

8611
14:21:29.815 --> 14:21:31.922
然后我们拿这个，把它粘在这里。

8612
14:21:31.922 --> 14:21:37.625
好了，我们还有一个数的单词，这就是我们想要得到的随机数，我们只需要一个。

8613
14:21:37.625 --> 14:21:42.177
我们会回到顶部，我们会创建一个你的int 32。

8614
14:21:42.177 --> 14:21:45.661
我们把它也设为私有常数。

8615
14:21:45.661 --> 14:21:48.722
Num个单词等于1，因为我们只需要一个随机数。

8616
14:21:48.722 --> 14:21:55.096
这是我们需要为试管受精协调器添加的最后一件事。request随机单词。

8617
14:21:55.096 --> 14:22:04.778
这个request random words函数返回一个请求ID一个256个请求ID一个唯一的ID它定义了谁在请求这个以及所有其他信息。

8618
14:22:04.778 --> 14:22:08.016
如果我们想保存它，我们可以用u和256。

8619
14:22:08.016 --> 14:22:11.583
IVF协调器请求随机单词。

8620
14:22:11.583 --> 14:22:15.141
现在，我们将用这个请求ID发出一个事件。

8621
14:22:15.141 --> 14:22:20.464
我们稍后会讲为什么要这样做，在顶部创建一个新事件。

8622
14:22:20.516 --> 14:22:23.463
这里我们不遵循命名规则。

8623
14:22:23.516 --> 14:22:30.434
因为我们要稍微改变一下函数的名字，我们要调用这个requested raffle winner。

8624
14:22:30.516 --> 14:22:36.183
我们会取一个un256索引的请求ID。

8625
14:22:37.517 --> 14:22:42.093
我们会省略请求的抽奖获胜者请求ID。

8626
14:22:42.517 --> 14:22:46.374
现在我们有了一个函数，我们可以使用链链接VRF来请求一个随机赢家。

8627
14:22:46.374 --> 14:22:51.974
现在，我们要把这个设置好让链链管理员在一个区间上调用它，但我们一会儿再做这个。

8628
14:22:51.974 --> 14:22:56.221
现在，我们来看看得到随机数后要做什么。

8629
14:22:56.221 --> 14:23:06.775
一旦我们得到了这个随机数，我们就想从上面的参与者数组中随机选出一个赢家。

8630
14:23:06.775 --> 14:23:09.420
那么我们该怎么办呢?好吧，我们进去吧。

8631
14:23:09.420 --> 14:23:14.199
我们用模块函数随机选一个赢家。

8632
14:23:14.199 --> 14:23:24.978
现在我们会得到一个由随机单词或随机数组成的数组，因为我们只请求一个随机单词，这个随机单词数组的大小将是1，其中包含一个随机单词。

8633
14:23:24.978 --> 14:23:26.501
现在这个随机的单词是aun 256。

8634
14:23:26.501 --> 14:23:29.481
所以这个随机的单词可能是这样的。

8635
14:23:29.481 --> 14:23:37.129
显然没有连字符，但也可以是非常大的东西比如我们的players数组只有这么大。

8636
14:23:37.129 --> 14:23:51.665
那么我们如何从这个潜在的巨大随机数中得到一个随机赢家呢，我们可以使用模函数，模运算，取N个模，剩下的是在操作数a除以等等等等等等。

8637
14:23:51.665 --> 14:23:57.250
这是什么意思呢?我们可以使用mod函数从玩家数组中获取一个随机数。

8638
14:23:57.250 --> 14:24:01.600
假设我们的players数组。不好意思，我们的s players数组的大小是10。

8639
14:24:01.600 --> 14:24:03.850
一个随机数是200。

8640
14:24:03.850 --> 14:24:09.787
我们如何从玩家数组中随机选出一个人，假设我们的随机数是202。

8641
14:24:09.787 --> 14:24:17.279
如果是202，也就是我们的随机数，对10取余，基本上就是202除以10。

8642
14:24:17.279 --> 14:24:23.354
但是我们不用小数，我们只要问，好，10除以202是多少倍。

8643
14:24:23.354 --> 14:24:37.184
余数是多少，没有被202整除的是什么?20乘以10等于200，剩下两个，所以2不能被平均除，或者说除以200。

8644
14:24:37.184 --> 14:24:41.255
也就是说202对10取余等于2。

8645
14:24:41.255 --> 14:24:43.222
这就是模块函数的工作原理。

8646
14:24:43.222 --> 14:24:46.469
我们可以用它来得到一个介于。

8647
14:24:46.518 --> 14:24:54.862
所以我们总是会得到一个0到9之间的数，这很好，因为这很好，因为这是数组中10个人的下标。

8648
14:24:54.862 --> 14:24:56.448
我们在这里用一下。

8649
14:24:56.448 --> 14:25:10.419
我们会说un256的winner索引将等于随机单词，在索引0处，因为我们只得到一个随机单词模块，S下划线players。length。

8650
14:25:10.419 --> 14:25:25.207
这将给我们随机赢家的索引来得到赢家的地址将做地址应付，最近的赢家等于s个玩家在这个赢家的索引上，太棒了。

8651
14:25:25.207 --> 14:25:32.966
现在我们有了得到这个随机数的人的地址，这个人将是我们可验证的随机赢家。

8652
14:25:32.966 --> 14:25:37.468
现在，向别人吹嘘你是最近的冠军可能有点酷。

8653
14:25:37.518 --> 14:25:46.934
让我们看一下顶部我们为最近的中奖者创建一个新的状态变量把这个状态变量放到一个叫做彩票变量的部分。

8654
14:25:46.934 --> 14:26:11.311
我们会说，addressprivate s下划线recent winner它会以nobody开始但当我们得到winner时，更新它用s recent winner = recent winner我们可能想让人们知道这是谁冬天在下面，我们可以做函数获取recent winner，这将是一个返回那个地址的公共视图。

8655
14:26:11.311 --> 14:26:18.519
然后我们会说，return s下划线recent winner，因为，recent winner将是一个存储变量。

8656
14:26:18.519 --> 14:26:24.011
现在我们有了最近的冠军，我们还能做什么?我们可能会把合同里的钱寄给他们。

8657
14:26:24.011 --> 14:26:47.876
我们要做的和之前送钱一样，我们要做公牛成功，逗号，空白等于最近的赢家，调用value，它将是这个点balance的地址，我们要把合同中的所有钱都送出去，并不传递任何数据。

8658
14:26:47.876 --> 14:26:53.967
现在我们可以说，要求，你知道，成功，不管怎样，我们会更省气一点。

8659
14:26:53.967 --> 14:27:00.219
我们会说，如果不是success，我们会返回一个新的transfer failed error。

8660
14:27:00.219 --> 14:27:13.185
我们会到顶部，契约的错误名称是raffle，下划线，下划线，transfer failed，像这样，然后回到下面，我们可以做revert, raffle transfer failed，像这样。

8661
14:27:13.185 --> 14:27:19.729
现在我们已经选出了获胜者，现在，我们还没有办法跟踪之前的获胜者名单。

8662
14:27:19.729 --> 14:27:21.656
我们要省略一个事件。

8663
14:27:21.656 --> 14:27:25.614
所以总是会有很容易查询的赛事获胜者的双重历史。

8664
14:27:25.614 --> 14:27:31.196
我们会在events部分创建一个新事件叫做event winner chosen。

8665
14:27:31.196 --> 14:27:36.841
这将是一个地址索引赢家。

8666
14:27:36.841 --> 14:27:44.734
向下滚动，我们会看到MIT winner选择了最近的获奖者的地址。

8667
14:27:44.734 --> 14:27:46.376
看起来不错。

8668
14:27:46.520 --> 14:27:47.785
这个看起来不错。

8669
14:27:49.520 --> 14:28:00.060
这里的这个小下划线表示，嘿，这是一个未使用的函数形参，因为我们没有使用这个，但我们仍然需要实现随机词来获取请求ID和随机词数组。

8670
14:28:00.060 --> 14:28:09.596
但我们不用Request ID，我们可以注释掉Request ID这部分，这告诉我们的函数，我们知道你需要un 256。

8671
14:28:09.596 --> 14:28:11.435
但我们不会使用请求ID。

8672
14:28:11.435 --> 14:28:12.316
我们把它放在这里。

8673
14:28:12.316 --> 14:28:13.770
但我们把它留空。

8674
14:28:13.770 --> 14:28:16.020
现在让我们在这里运行一点编译。

8675
14:28:16.020 --> 14:28:22.651
我们将使用yarn, hard hat, compile，或hh compile，我们将看看编码是否正确。

8676
14:28:22.651 --> 14:28:24.421
实际上，我们没有看到任何错误。

8677
14:28:24.520 --> 14:28:27.091
如此完美，我们可以继续。

8678
14:28:30.520 --> 14:28:34.445
我们有一种方法可以验证得到一个随机赢家。

8679
14:28:34.520 --> 14:28:35.634
这太棒了。

8680
14:28:38.520 --> 14:28:50.454
它只能选择一个可验证的赢家，但它也可以通过编程完成这一切，并自动触发选择一个随机赢家基于某个时间间隔，而无需我们与它交互。

8681
14:28:50.454 --> 14:28:51.978
在去中心化的背景下。

8682
14:28:51.978 --> 14:29:07.429
为了让我们根据一些参数自动触发智能合约可能是一个时间参数，可能是某个资产的价格是某个数字，可能是流动性池中有一定数量的钱或者任何你想要的触发器，我们可以使用链链保持器。

8683
14:29:07.429 --> 14:29:08.029
为了做到这一点。

8684
14:29:08.029 --> 14:29:12.070
斯蒂文再一次做到了，一个惊人的介绍链守门员。

8685
14:29:12.070 --> 14:29:21.806
所以我们将跟随另一个子视频部分，史蒂文解释链链守护者酱，他将使用COVID测试网，但一定要使用文档中的任何测试网。

8686
14:29:21.806 --> 14:29:23.483
当你玩这个，尝试这个的时候。

8687
14:29:23.521 --> 14:29:24.552
我叫史蒂文·冯。

8688
14:29:26.521 --> 14:29:31.975
链链接管理员网络，以使你的合同自动化，并让他们访问链外计算。

8689
14:29:31.975 --> 14:29:33.052
让我们开始吧。

8690
14:29:33.052 --> 14:29:37.133
所以我们今天要看的是我们要从链接文档网页开始。

8691
14:29:37.133 --> 14:29:40.682
如果你向下滚动一点，你会发现使用链链保持器。

8692
14:29:40.682 --> 14:29:45.425
要建立一个完整的智能合约有两个部分。

8693
14:29:45.425 --> 14:29:50.521
首先，你需要通过实现这两个方法来编写一个兼容的智能合约。

8694
14:29:50.521 --> 14:29:55.298
其次，你要注册智能合约以便与通道管理员网络进行维护。

8695
14:29:55.298 --> 14:29:57.816
我们来做这两件事。

8696
14:29:57.816 --> 14:30:02.198
让我们从复制和部署我们已经得到的示例代码开始。

8697
14:30:02.198 --> 14:30:07.078
点击一下就可以混音了，我们看到的是一个非常非常简单的契约。

8698
14:30:07.078 --> 14:30:08.833
这只是一个简单的计数器。

8699
14:30:08.833 --> 14:30:11.208
我们可以看到这里有一个计数器。

8700
14:30:11.208 --> 14:30:13.859
所以它只有一个简单的数字。

8701
14:30:13.859 --> 14:30:22.140
然后你可以指定何时创建契约和更新间隔，然后契约会验证，是否有足够的时间。

8702
14:30:22.140 --> 14:30:23.728
如果有，我们就更新计数器。

8703
14:30:23.728 --> 14:30:32.430
你会注意到chinley兼容或者时间记录网络兼容契约使用了两个非常重要的方法它们是这个时间记录兼容接口的一部分。

8704
14:30:32.430 --> 14:30:38.743
第一个是检查维护，检查维护是特殊的，因为这是发生链外计算的地方。

8705
14:30:38.743 --> 14:30:41.727
这是一个没有在chain上运行的方法。

8706
14:30:41.727 --> 14:30:46.449
这是由一个来自通道保持网络的节点运行的。

8707
14:30:46.449 --> 14:30:51.487
这样做的好处是这里使用的气体不是气体，而是链状的。

8708
14:30:51.487 --> 14:30:53.797
这只是由一个链条节点运行。

8709
14:30:53.797 --> 14:30:58.925
然后发生的是，如果检查维护方法返回，就需要维护。

8710
14:30:58.925 --> 14:31:01.410
然后它将继续执行维护。

8711
14:31:01.410 --> 14:31:05.945
在链上，你可以在链上生成数据，然后传递进来。

8712
14:31:05.945 --> 14:31:07.419
这叫做支票数据。

8713
14:31:07.522 --> 14:31:11.747
然后它就变成了被传递到执行维护的执行数据。

8714
14:31:11.747 --> 14:31:18.183
因此，执行维护方法是你想要验证事情是否正确的地方。

8715
14:31:18.183 --> 14:31:24.332
这些东西实际上应该被修改并在链上运行，然后使状态发生变化。

8716
14:31:24.332 --> 14:31:28.472
所以，让我们继续编译这份合同，并将其部署到COVID网络中。

8717
14:31:28.522 --> 14:31:32.231
让我们继续，在remix中，我们可以做这个编译。

8718
14:31:32.231 --> 14:31:35.763
我们将直接编译和部署到COVID。

8719
14:31:35.763 --> 14:31:42.662
所以动物园管理员网络目前在拍摄这段视频时，可以在COVID和主网的理论上使用。

8720
14:31:42.662 --> 14:31:44.958
我们来玩反合约。

8721
14:31:44.958 --> 14:31:48.970
让我们看看什么没有超过每30秒更新一次。

8722
14:31:48.970 --> 14:31:50.751
让我们继续部署。

8723
14:31:50.751 --> 14:31:55.360
所以meta mask可以要求一点报酬，以便我将这个合同部署到COVID网络。

8724
14:31:55.360 --> 14:31:57.360
看起来是直播的。

8725
14:31:57.360 --> 14:32:02.426
现在我要做的是，我要拿这个保管契约，复制它的地址。

8726
14:32:02.426 --> 14:32:05.722
现在我们要注册维护合同。

8727
14:32:05.722 --> 14:32:13.890
我们将跳到支持冠军守护者网络的应用程序，有几种不同的使用方式，你可以直接与注册表合同交互。

8728
14:32:13.890 --> 14:32:16.475
但是有一个非常非常好的界面可以让你这样做。

8729
14:32:16.475 --> 14:32:21.115
让我们继续注册一个新的维护，它给我一个错误，说你需要连接你的钱包。

8730
14:32:21.115 --> 14:32:22.052
我们来做一下。

8731
14:32:22.052 --> 14:32:25.877
这里我要连接钱包，让它访问我的账户。

8732
14:32:25.877 --> 14:32:29.137
然后，我们就可以注册了。

8733
14:32:29.137 --> 14:32:32.368
这里我要用电子邮件地址。

8734
14:32:32.368 --> 14:32:34.641
我会给我的合同起个简单的名字。

8735
14:32:34.641 --> 14:32:39.877
我会把部署合同上的地址粘贴进来，然后给它加个汽油限额。

8736
14:32:39.877 --> 14:32:50.989
检查数据是一种特殊的东西你可以在同一个合同上注册多个维护通过传递数据来指定你希望如何运行checkup keep，我们将忽略这是一个可选的。

8737
14:32:50.989 --> 14:32:59.051
然后我们会给它一个10左右的初始余额，它会继续使用Metamask在网络上注册交易。

8738
14:32:59.051 --> 14:33:06.200
一旦确认了，我的保养费就应该在网络上注册然后用10个链接来启动。

8739
14:33:06.200 --> 14:33:11.785
如果我们继续查看维护，我们可以看到它注册了。

8740
14:33:11.785 --> 14:33:27.470
当下一轮的keeper节点执行时，大概应该是每个块，我们应该看到check upkeep方法将返回嘿，upkeep实际上是需要的因为时间戳是30秒之前的。

8741
14:33:27.470 --> 14:33:30.210
然后我们应该继续进行维护。

8742
14:33:30.210 --> 14:33:40.323
在remix中，我可以把它放大，我们可以从契约的方法中看到，如果我们检查计数器，它将从0开始。

8743
14:33:40.323 --> 14:33:48.539
只要30秒过去，我们就能再次击中计数器，我们就会看到通道守护者网络按照我的合同执行了维护。

8744
14:33:48.539 --> 14:33:55.803
好了，我们刷新一下，我们看到维护的余额减少了大约01点link。

8745
14:33:55.803 --> 14:34:02.835
我们还应该在我们的合同中看到，我们的计数器现在已经通过执行维护方法调用的证明进行了更新。

8746
14:34:02.835 --> 14:34:10.245
现在我们的柜台显示我们的合同正在被链链管理员网络批准。

8747
14:34:10.245 --> 14:34:12.462
一切都如我们所愿。

8748
14:34:12.462 --> 14:34:17.505
正如你所看到的，创建一个与管理员网络兼容的合同是非常非常容易的。

8749
14:34:17.505 --> 14:34:25.476
很容易登记维护，并开始看到你的合同自动化和期权计算工作完美无缺。

8750
14:34:25.524 --> 14:34:33.805
现在，我们已经学习了更多关于链链接保持器是如何工作的，如果你想花点时间浏览文档，并打开下面的打开和混合按钮。

8751
14:34:33.805 --> 14:34:46.151
你们可以用其中的一个在测试网上自己看看它的作用，请随意，我们将使用一个设置非常类似于链条文档中的keepers计数器设置。

8752
14:34:46.151 --> 14:34:52.945
现在让我们更新我们的代码，让这个请求随机数自动发生使用链链接保持器。

8753
14:34:52.945 --> 14:34:58.146
如果我们看一下这个合同的例子就能了解到更多关于这个工作的真正重要的东西。

8754
14:34:58.146 --> 14:35:02.086
我们需要一个检查维护和一个执行维护函数在我们的代码中。

8755
14:35:02.086 --> 14:35:07.238
这不是请求随机赢家，而是我们要改变的执行维护。

8756
14:35:07.238 --> 14:35:16.345
但首先让我们让这个check upkeep checkup keep函数基本上是检查我们是否该获取一个随机数来更新最近的赢家并将所有的资金发送给他们。

8757
14:35:16.345 --> 14:35:17.917
我们来创建这个函数。

8758
14:35:17.917 --> 14:35:21.556
我将在这里添加一些注释，以便大家清楚发生了什么。

8759
14:35:21.556 --> 14:35:25.633
也许我还会用natspec来告诉开发者这个函数是怎么回事。

8760
14:35:25.633 --> 14:35:28.839
我们会创建这个函数check upkeep。

8761
14:35:28.839 --> 14:35:35.945
如果我们看看这个需要什么，它需要外部覆盖外部覆盖。

8762
14:35:35.945 --> 14:35:41.474
如果我们看到这个override关键字，这意味着可能在其他地方有一个执行维护。

8763
14:35:41.524 --> 14:35:51.445
如果我们滚动到顶部，我们会导入这个keeper兼容接口，这样我们就能确保我们在代码中实现了检查维护和执行维护。

8764
14:35:51.524 --> 14:35:56.270
如果你想，你可以在这里导入keeper compatible或者在代码中导入keeper compatible接口。

8765
14:35:56.270 --> 14:36:04.940
我们要做import at chain link /合约/ SRC / v0。

8766
14:36:04.940 --> 14:36:26.287
8点2接口/ keeper兼容接口这是灵魂现在我们要说契约抽奖是Veera消费者基础v2和keeper兼容接口这个keeper兼容接口继承确保我们添加了检查保持和执行维护，我们会添加一点。

8767
14:36:26.287 --> 14:36:33.754
如果我们回头看文档我们可以看到checkup keep接受一个叫做Data check Data的字节作为输入参数。

8768
14:36:33.754 --> 14:36:36.213
我们用的是叫做data的字节。

8769
14:36:36.213 --> 14:36:38.075
检查数据作为参数。

8770
14:36:38.075 --> 14:36:45.328
这个check upkeep字节调用数据允许我们在调用check upkeep函数时指定我们想要的任何东西。

8771
14:36:45.328 --> 14:36:59.368
让这个检查数据为bytes类型意味着我们甚至可以指定它来调用其他函数，有很多高级的事情你可以做，只要有一个输入形参作为bytes类型，我们会让它保持简单一点。

8772
14:36:59.368 --> 14:37:01.650
我们不打算用这个校验数据。

8773
14:37:01.650 --> 14:37:05.840
类似于下面我们不使用Request ID，我们可以注释掉它。

8774
14:37:05.840 --> 14:37:10.040
但是，我们仍然需要确保这个参数是名为data的字节类型。

8775
14:37:10.040 --> 14:37:24.639
不管怎样，让我们继续注释这个check upkeep函数，我们会说这是一个函数，链链接看守节点调用它们寻找返回true的函数。

8776
14:37:24.639 --> 14:37:37.837
回头看看文档，我们可以看到这个检查upkeep返回和upkeep needed和执行数据，同样，我们将忽略这个upkeep needed是真还是假。

8777
14:37:37.837 --> 14:37:47.235
如果它为真，那就意味着是时候获得一个新的随机数了，后面的随机数应为真，以便返回真。

8778
14:37:47.235 --> 14:37:56.776
为了让它成为请求随机赢家的时间，应该发生什么，我们的时间间隔应该已经过去了，我们还没有定义。

8779
14:37:56.776 --> 14:38:03.052
但我们将彩票应该至少有一个球员，并有一些。

8780
14:38:03.052 --> 14:38:17.542
然后我们的订阅由Link提供资金类似于channeling Vir，如果你的订阅需要由Link提供资金，同样的事情需要发生在check upkeep和keepers上，以运行你的订阅需要由Link提供资金。

8781
14:38:17.542 --> 14:38:30.187
现在我们要在这里再添加一个元素，我们说彩票应该处于开放状态，这是我们在等待随机数返回时要避免的情况。

8782
14:38:30.187 --> 14:38:32.388
当我们请求一个随机的赢家时。

8783
14:38:32.388 --> 14:38:36.576
从技术上讲，我们处于一种奇怪的状态，我们在等待一个随机的数字返回。

8784
14:38:36.576 --> 14:38:39.052
我们真的不应该允许任何新玩家加入。

8785
14:38:39.052 --> 14:38:43.668
我们要做的是创建一个状态函数告诉我们彩票是否开放。

8786
14:38:43.668 --> 14:38:51.412
在等待随机数返回的过程中，我们会处于封闭或计算状态。

8787
14:38:51.526 --> 14:38:57.746
现在我们可以在契约顶部做的是，我们可以说Boolean private, s下划线是open。

8788
14:38:57.746 --> 14:39:02.473
我们可以把它设为真，如果我们是开放的，否则设为假。

8789
14:39:02.473 --> 14:39:14.714
如果我们有很多不同的状态呢?如果我们想让它像挂起，打开，关闭，计算等?我们有很多不同的状态?我们可以把它写成U和256。

8790
14:39:14.714 --> 14:39:16.401
二等兵强调国家。

8791
14:39:16.401 --> 14:39:23.227
我们可以跟踪状态，比如0 b等待，1重新打开，关闭，3，正在计算，等等。

8792
14:39:23.227 --> 14:39:25.737
但这可能有点棘手。

8793
14:39:25.737 --> 14:39:35.465
在我们的代码中，更好的跟踪这些的方法是使用枚举枚举，它可以用来创建自定义类型，使用一组有限的常量值。

8794
14:39:35.527 --> 14:39:44.182
例如，我们可以创建一个状态，锁定非活动，这是智能合约的一个新类型，我们会创建一个新类型。

8795
14:39:44.182 --> 14:39:49.871
回到变量的布局，智能合约类型应该是合约的第一项。

8796
14:39:49.871 --> 14:39:52.899
所以我们要创造一个叫做抽奖状态的新状态。

8797
14:39:52.899 --> 14:39:58.713
现在，我们只需要让它是开放的，我们只需要开放或计算。

8798
14:39:58.713 --> 14:40:09.245
当我们创建一个这样的enum时，我们在暗中创建一个un256，其中0等于open, 1等于computing。

8799
14:40:09.245 --> 14:40:15.050
然而，这是更明确的，我们知道每一个数字的实际含义。

8800
14:40:15.050 --> 14:40:22.456
现在我们已经创建了这个名为raffle state的新类型，我们可以创建一个类型为raffle state的新彩票状态变量。

8801
14:40:22.527 --> 14:40:27.607
声明其他变量的方法和声明其他变量完全一样，我们将命名它的类型，它将是raffle state。

8802
14:40:27.607 --> 14:40:29.727
这是一个存储变量。

8803
14:40:29.727 --> 14:40:38.246
我们会在构造函数中执行私有s下划线raffle state，当我们启动合约时，我们应该打开这个raffle。

8804
14:40:38.246 --> 14:40:43.442
所以我们说s，抽奖状态等于我们可以用un256。

8805
14:40:43.527 --> 14:40:46.799
像这样包装在类型抽奖状态。

8806
14:40:48.527 --> 14:40:51.060
显式，并说raffle state DOT open。

8807
14:40:52.527 --> 14:40:58.264
抽奖状态处于开放状态，我们只希望检查保持工作，如果彩票实际上是开放的。

8808
14:40:58.264 --> 14:41:02.291
此外，我们可能希望人们只有在法律电池打开的情况下才能进入。

8809
14:41:02.291 --> 14:41:06.949
因此，让我们继续创建另一个if语句，并在彩票未打开时进行还原。

8810
14:41:06.949 --> 14:41:23.773
我们可以说，如果s_ raffle state不等于raffle state DOT open，那么我们会返回一个新错误，我们会创建raffle。

8811
14:41:23.773 --> 14:41:29.096
当然，在顶部会产生错误，抽奖不开放。

8812
14:41:29.096 --> 14:41:34.449
另外，当我们请求一个随机单词时，让我们往下看。

8813
14:41:34.528 --> 14:41:38.769
让我们将状态更新为正在计算，这样其他人就不能跳转到这里。

8814
14:41:38.769 --> 14:41:55.052
就在我们的VRF协调器。request上面，random words将做s下划线raffle state = raffle state dot计算，这样就没有人能进入我们的彩票，没有人能触发新的更新。

8815
14:41:55.052 --> 14:42:04.217
然后一旦我们完成在我们选出赢家之后，我们会说s抽奖状态等于抽奖状态DOT再次打开。

8816
14:42:04.217 --> 14:42:12.232
我们忘记做的另一件事是，在我们从s个玩家中选出胜者后，我们需要重置我们的玩家数组。

8817
14:42:12.232 --> 14:42:18.773
所以让我们在这里添加这些以及players = new address payable。

8818
14:42:18.773 --> 14:42:20.953
大小为0的数组。

8819
14:42:20.953 --> 14:42:23.001
我们会重置抽奖状态。

8820
14:42:23.001 --> 14:42:24.778
我们会重置我们的players数组。

8821
14:42:24.778 --> 14:42:25.528
好了,好了。

8822
14:42:25.528 --> 14:42:31.087
现在我们已经学习了enum，让我们把它添加到这里的checkup keep中，我们会检查这四个东西。

8823
14:42:31.087 --> 14:42:36.997
如果他们都通过了检查键将为真，并将触发链，饲养员请求一个新的随机赢家。

8824
14:42:36.997 --> 14:42:39.575
首先，我们说bool is open。

8825
14:42:39.575 --> 14:42:43.793
它等于抽奖状态。

8826
14:42:43.793 --> 14:42:50.303
打开等于等于s下划线抽奖状态。

8827
14:42:50.303 --> 14:43:01.021
所以你可以认为这个布尔值是开的，如果抽奖状态是开的，它将为真，如果抽奖状态是其他状态，它将为假。

8828
14:43:01.021 --> 14:43:01.436
太好了。

8829
14:43:01.529 --> 14:43:04.013
我们还没有打开布尔值，稍后可以检查。

8830
14:43:04.529 --> 14:43:10.329
我们需要吗?我们需要检查时间间隔是否超过好吧，我们还没有时间间隔。

8831
14:43:10.329 --> 14:43:12.306
我们来创建一个时间区间。

8832
14:43:12.306 --> 14:43:25.918
为了检查时间，我们可以使用另一个全局可用的变量block。timestamp block那个timestamp返回区块链的当前时间戳来获得当前时间戳，我们需要block。timestamp。

8833
14:43:25.918 --> 14:43:33.988
但要得到如果已经经过了足够的时间，我们需要得到当前block。timestamp减去最后一个block timestamp，这是我们还没有的。

8834
14:43:33.988 --> 14:43:38.195
让我们继续，创建一个状态变量来跟踪上一个块的时间戳。

8835
14:43:38.195 --> 14:43:41.156
这是我们要建立的一个新的状态函数。

8836
14:43:41.156 --> 14:43:43.568
我选u和256。

8837
14:43:43.568 --> 14:43:49.215
私有下划线最后的时间戳。。

8838
14:43:49.529 --> 14:43:57.232
当我们部署这个契约时，我们会用当前时间戳s lasttimestamp = block。timestamp更新这个。

8839
14:43:57.232 --> 14:43:58.560
好的,太棒了。

8840
14:43:58.560 --> 14:44:01.294
现在我们有了最后一个块时间戳。

8841
14:44:01.529 --> 14:44:07.929
但是我们需要检查当前时间戳和上一个时间戳之间的差异是否大于某个间隔。

8842
14:44:07.929 --> 14:44:09.829
我们还需要创建一个区间。

8843
14:44:09.829 --> 14:44:18.196
这是一个间隔，这是以秒为单位的数字表示我们想要等待的时间间隔。

8844
14:44:18.196 --> 14:44:21.142
让我们继续把这个也添加到构造函数中。

8845
14:44:21.142 --> 14:44:22.291
这里加个逗号。

8846
14:44:22.291 --> 14:44:23.751
我们用u和256。

8847
14:44:23.751 --> 14:44:24.322
时间间隔。

8848
14:44:24.322 --> 14:44:32.496
我们将创建另一个全局变量u和256 Private的下划线间隔。

8849
14:44:32.496 --> 14:44:36.130
在构造函数中，我们说s interval = interval。

8850
14:44:36.130 --> 14:44:39.482
interval在我们设置之后不会改变。

8851
14:44:39.482 --> 14:44:45.497
我们不设存储变量，而是设为不可变变量，这样可以省点油。

8852
14:44:45.497 --> 14:44:46.400
好的,完美的。

8853
14:44:46.530 --> 14:44:51.063
现在我们有了所有这些，我实际上创建一个布尔值来检查是否有足够的时间过去。

8854
14:44:51.063 --> 14:45:01.910
我们说布尔时间流逝等于当前块那个时间戳减去s下划线last时间戳。

8855
14:45:01.910 --> 14:45:08.702
我们应该检查一下它是否大于i_ interval。

8856
14:45:08.702 --> 14:45:11.330
我们用布尔值检查我们是否打开。

8857
14:45:11.330 --> 14:45:15.482
如果我们是开放的，它就为真，我们会有一个布尔值来判断时间是否足够。

8858
14:45:15.530 --> 14:45:17.545
如果时间足够长，这将是正确的。

8859
14:45:18.530 --> 14:45:21.481
检查?而我们应该检查一下我们是否有足够的玩家。

8860
14:45:21.530 --> 14:45:31.909
我们会写Boolean has players =我们会检查s是否下划线players。length大于零。

8861
14:45:31.909 --> 14:45:36.434
如果s players。length大于0，则为真，否则为假。

8862
14:45:36.434 --> 14:45:43.592
我们还会看看是否有余额我们写入Boolean has balance = address。

8863
14:45:43.592 --> 14:45:46.461
这个点结余大于零。

8864
14:45:46.461 --> 14:45:53.330
最后，我们要把所有这些布尔值转化为我们要找的返回变量。

8865
14:45:53.330 --> 14:45:55.711
我们会说Boolean up keep needed。

8866
14:45:55.711 --> 14:46:01.809
等号是开放的，时间流逝了。

8867
14:46:01.809 --> 14:46:12.908
作为玩家和平衡，就像这样，所有这些结合在一起就是布尔维持所需要的。

8868
14:46:12.908 --> 14:46:18.343
如果这个返回true，是时候请求一个新的随机数了，是时候结束抽奖了。

8869
14:46:18.343 --> 14:46:22.007
如果这是错误的，现在还不是时候，还不是结束彩票的时候。

8870
14:46:22.007 --> 14:46:29.995
现在，如果我们去chainlink，文档维护需要，实际上需要返回布尔维护需要一些字节内存执行数据。

8871
14:46:29.995 --> 14:46:34.090
我们需要更新我们需要更新这里的函数。

8872
14:46:34.090 --> 14:46:44.392
并返回所需的全部维护，逗号，字节内存，执行数据*斜杠。

8873
14:46:44.531 --> 14:46:52.449
因为我们已经初始化了Boolean，在这里保持需要，我们不需要说需要的维护类型在这里。

8874
14:46:52.531 --> 14:46:56.740
因为这将自动返回执行的数据是我们可以使用的东西。

8875
14:46:56.740 --> 14:46:59.580
如果我们想做体检，继续做一些其他的事情。

8876
14:46:59.580 --> 14:47:02.202
这要看检查进展如何了。

8877
14:47:02.202 --> 14:47:03.959
我们真的不需要它做任何其他事情。

8878
14:47:03.959 --> 14:47:05.292
所以我们可以让它保持原样。

8879
14:47:05.292 --> 14:47:05.577
正确的。

8880
14:47:05.577 --> 14:47:13.875
现在我们有了检查维护，我们有了一种方法来检查是否该触发选择彩票或抽奖的随机赢家。

8881
14:47:13.875 --> 14:47:22.991
现在我们已经学习了如何实际执行这个触发器，让我们编写在这个返回true后执行的函数。

8882
14:47:22.991 --> 14:47:29.203
这将是我们的执行维护函数，我们可以在chainlink文档中再次看到一个例子。

8883
14:47:29.203 --> 14:47:35.760
现在当要选择一个随机赢家时，实际上，我们要做的是我们要调用这个request random winner函数。

8884
14:47:35.760 --> 14:47:43.290
与其有这个额外的函数，不如把请求随机赢家函数转换成这个执行维护函数。

8885
14:47:43.290 --> 14:47:49.268
一旦check upkeep返回true，链连接节点将自动调用这个执行维护函数。

8886
14:47:49.268 --> 14:47:53.810
在函数request random winner中，我们重命名它来执行维护。

8887
14:47:53.810 --> 14:48:01.339
我们让它接受输入参数bytes，叫作Data，执行数据bytes，叫作Data，执行数据。

8888
14:48:01.339 --> 14:48:11.193
在检查keep中，我们必须执行数据，我们会自动将它传递给我们的performance keep，我们不会传递任何东西来执行维护，我们可以像这样将它注释掉。

8889
14:48:11.193 --> 14:48:18.193
由于执行维护实际上是在与管理员兼容的接口中标识的，所以现在必须重写该函数。

8890
14:48:18.193 --> 14:48:21.992
在继续之前，我们要做一点验证。

8891
14:48:21.992 --> 14:48:25.286
因为现在任何人都可以调用我们的执行维护函数。

8892
14:48:25.286 --> 14:48:28.881
我们要确保它只在checkup keep为真时被调用。

8893
14:48:28.881 --> 14:48:33.282
一个简单的方法是调用我们自己的checkup keep函数。

8894
14:48:33.282 --> 14:48:35.467
现在，现在，检查保持它是外部。

8895
14:48:35.467 --> 14:48:38.321
我们不能调用checkup keep函数。

8896
14:48:38.321 --> 14:48:43.532
我们把它改成public这样我们的智能合约也能调用checkup keep函数。

8897
14:48:43.532 --> 14:48:53.972
既然我们已经在执行维护中公开了它，我们就可以调用checkup，继续不传递任何东西，然后返回所需的维护和我们并不真正关心的执行数据。

8898
14:48:53.972 --> 14:48:57.938
所以我们会我们会把球举起来。

8899
14:48:57.938 --> 14:49:00.785
我们不关心执行数据。

8900
14:49:00.785 --> 14:49:04.422
我们把这个空着= check up keep。

8901
14:49:04.422 --> 14:49:07.277
然后传递给它一个空白的数据。

8902
14:49:07.277 --> 14:49:11.807
现在，我们要确保这是正确的以便继续研究这个函数。

8903
14:49:11.807 --> 14:49:24.451
我们可以在这里写一个require，但我们会做if not up keep needed，然后我们会用一个新的错误来恢复，我们会创建raffle。

8904
14:49:24.533 --> 14:49:25.949
不需要维护。

8905
14:49:29.533 --> 14:49:33.385
这样遇到这个错误的人就能看到为什么会出现这个错误。

8906
14:49:33.385 --> 14:49:37.549
所以我们把合同的余额传过去以防这里没有以太。

8907
14:49:37.549 --> 14:49:41.000
我们将添加players。length，以防没有玩家。

8908
14:49:41.000 --> 14:49:45.464
我们会添加一个un256s下划线抽奖状态。

8909
14:49:45.464 --> 14:49:49.199
确保抽奖真的开了。

8910
14:49:49.199 --> 14:50:06.340
当然，我们需要在顶部空气中创造这种空气，不需要抽奖维护，这将需要un 256当前平衡un 256非玩家，你去适合6抽奖状态。

8911
14:50:06.340 --> 14:50:09.713
我们的代码看起来非常专业。

8912
14:50:09.713 --> 14:50:10.499
这太棒了。

8913
14:50:10.499 --> 14:50:17.926
现在我们忘记在fullrandomwords中做的事情因为我们忘记了每次选中赢家时重置时间戳。

8914
14:50:17.926 --> 14:50:25.199
我们还想重置时间戳，这样我们就可以等待另一个时间间隔，让人们参与那个时间间隔的抽奖。

8915
14:50:25.199 --> 14:50:28.307
我们向下滚动到实现随机单词。

8916
14:50:28.307 --> 14:50:32.194
在我们重置之后，玩家也会重置时间戳。

8917
14:50:32.194 --> 14:50:34.920
好的，很好，我想我们差不多完成了。

8918
14:50:34.920 --> 14:50:45.876
让我们添加一点natspec，让它看起来更专业，并给正在阅读我们合同的人更多的信息。

8919
14:50:45.876 --> 14:50:57.913
所以让我们在标题处加上标题我们会说一个抽奖合同样本会说作者将是我帕特里克·柯林斯或者你也可以在那里写上你自己的名字。

8920
14:50:57.913 --> 14:51:04.518
这个合约是为了创建一个未经篡改的去中心化智能合约。

8921
14:51:04.518 --> 14:51:13.284
然后加上Dev，这实现了链VRF v2，和链keepers。

8922
14:51:13.284 --> 14:51:14.346
好的,太棒了。

8923
14:51:14.346 --> 14:51:22.057
我们有类型声明，我们有状态变量，我们有彩票变量，它们仍然是状态变量，我们有事件。

8924
14:51:22.057 --> 14:51:24.134
现在是我们函数的时间了。

8925
14:51:24.134 --> 14:51:28.596
之后，我们做了一些natspec，至少在检查维护方面。

8926
14:51:28.596 --> 14:51:33.937
如果你想在进入、抽奖、执行维护等方面添加更多的natspec，你完全可以这么做。

8927
14:51:33.937 --> 14:51:37.472
然后在底部，我们有视图/纯getter函数。

8928
14:51:37.472 --> 14:51:43.034
我们看看，这里还需要其他getter函数吗?我们可能想让人们有机会获得抽奖状态。

8929
14:51:43.034 --> 14:51:51.934
我们做一个函数，得到抽奖状态，这将是一个公共，你返回一个抽奖状态。

8930
14:51:51.934 --> 14:52:00.784
我们会说返回s下划线raffle state，我们可能想让人们有机会得到单词数。

8931
14:52:00.784 --> 14:52:04.393
这里跑起来有点有趣。

8932
14:52:04.393 --> 14:52:17.867
如果我们做function，获取num words，公共视图返回，你去6个返回num words，你会看到有趣的事情发生了。

8933
14:52:17.867 --> 14:52:21.034
我们打开编译器并运行hh compile。

8934
14:52:21.034 --> 14:52:23.700
希望这里一切正常。

8935
14:52:23.700 --> 14:52:28.470
哦，所有东西都不能用因为我没有正确导入这个。

8936
14:52:28.534 --> 14:52:29.846
让我们来解决这个问题。

8937
14:52:31.534 --> 14:52:33.975
我还错过了几件事。

8938
14:52:35.535 --> 14:52:38.090
这就是为什么当你编译的时候，最好把它编译为players。length。

8939
14:52:38.090 --> 14:52:39.571
让我们再试一次。

8940
14:52:39.571 --> 14:52:42.071
我把interval拼错了。

8941
14:52:42.071 --> 14:52:49.190
我下划线intervol strike再次编译，看看我犯了多少拼写错误。

8942
14:52:49.190 --> 14:52:50.293
就是这样。

8943
14:52:50.293 --> 14:52:55.831
我在error中下划线，然后粘贴它，我们会得到另一个错误。

8944
14:52:55.831 --> 14:53:02.166
函数调用中参数的类型无效，从字面字符串到被请求数据的字节的隐式转换无效。

8945
14:53:02.166 --> 14:53:04.857
因为我们传递的是空字符串。

8946
14:53:04.857 --> 14:53:09.201
checkup keep需要调用data data实际上对字符串不起作用。

8947
14:53:09.201 --> 14:53:11.344
所以我们需要把这个字节变成内存。

8948
14:53:11.344 --> 14:53:13.196
编译器现在对我们很满意。

8949
14:53:13.196 --> 14:53:14.975
我把时间戳拼错了。

8950
14:53:14.975 --> 14:53:24.889
这是小写的s你可能会在Check维护上看到一些潦草的字迹，我们可以把这个设为视图函数因为我们没有修改任何状态。

8951
14:53:24.889 --> 14:53:28.535
但是我想公开它的原因我稍后会告诉你们。

8952
14:53:28.535 --> 14:53:32.002
但最后我们得到了我想要的黄色曲线。

8953
14:53:32.002 --> 14:53:37.456
如果我们运行hh compile，我们也应该在编译器中看到一个警告。

8954
14:53:37.535 --> 14:53:39.035
好了，我们看到这些黄色的曲线。

8955
14:53:39.535 --> 14:53:41.535
变量可以保持未赋值。

8956
14:53:43.535 --> 14:53:46.092
因为这是饲养员要找的。

8957
14:53:46.535 --> 14:53:50.502
函数状态可变性可以限制为函数检查键的视图。

8958
14:53:50.502 --> 14:53:55.177
如果你想，你可以创建一个视图，但我将保持它是公开的，原因我稍后会告诉你。

8959
14:53:55.177 --> 14:54:11.724
最后，函数状态可变性可以被限制为纯这就是我想要展示给你们的因为num words实际上在字节码中，因为它是一个常量变量技术上来说它不是从存储中读取的，因此这可以是一个纯函数。

8960
14:54:11.724 --> 14:54:18.095
返回num words并不会在存储中读取，它会直接去读取数字1。

8961
14:54:18.095 --> 14:54:30.260
因此，在稳定的情况下获取num个单词num个单词是一个常数变量，它将字面上完全相同地说，我们将在这里返回1，我们可能还想获得玩家的数量。

8962
14:54:30.260 --> 14:54:35.328
我们创建一个函数，获取玩家数量。

8963
14:54:35.536 --> 14:54:41.536
这将是一个公共视图，返回一个un256。

8964
14:54:42.536 --> 14:54:44.993
下划线players。length。

8965
14:54:47.536 --> 14:54:49.260
想要最新的时间戳。

8966
14:54:51.536 --> 14:54:52.536
时间戳。

8967
14:54:52.536 --> 14:54:55.980
公共视图在256后返回。

8968
14:54:58.536 --> 14:55:02.925
返回s下划线最后的时间戳。

8969
14:55:05.536 --> 14:55:07.269
要做的请求确认。

8970
14:55:09.536 --> 14:55:10.551
询证函。

8971
14:55:14.536 --> 14:55:22.346
常量函数返回你到56转请求确认。

8972
14:55:22.346 --> 14:55:26.107
好了，我们这里有一些很棒的getter。

8973
14:55:26.107 --> 14:55:33.454
一些视图/纯函数，我们有办法得到一个随机数我们有办法在去中心化的环境中。

8974
14:55:33.536 --> 14:55:34.989
自动自动执行。

8975
14:55:36.536 --> 14:55:40.468
这是一种让人们参加抽奖的方式。

8976
14:55:40.536 --> 14:55:48.036
我们有一个无懈可击的方法来解决创建一个真正公平的分散彩票的问题。

8977
14:55:48.036 --> 14:55:49.107
我的天啊。

8978
14:55:49.107 --> 14:55:53.108
让我们再做一次编译。

8979
14:55:53.108 --> 14:55:54.958
这些只是警告。

8980
14:55:54.958 --> 14:55:56.273
我们可以开始了。

8981
14:55:56.273 --> 14:55:58.800
我们的代码编译成功了。

8982
14:55:58.800 --> 14:56:10.778
就像我说的，通常情况下，这绝对不是你写智能合约的方式，几乎不可能写一个完整的智能合约而不犯任何错误。

8983
14:56:10.778 --> 14:56:19.416
不用在文档之间翻来覆去，我自己已经写了很多遍这个合同，但我仍然犯了一大堆错误。

8984
14:56:19.416 --> 14:56:26.216
所以任何人在这个过程中犯错误都是完全合理的。

8985
14:56:26.216 --> 14:56:29.176
并在此过程中使用资源并编写测试。

8986
14:56:29.176 --> 14:56:33.251
现在我们已经创建了我们的抽奖点首尔，是时候添加其他东西了。

8987
14:56:33.251 --> 14:56:39.478
我们会到这里，创建一个新文件夹，并按惯例添加deploy文件夹。

8988
14:56:39.537 --> 14:56:45.072
我们将做我们已经做过几次的事情，我们将创建一些脚本来部署我们的抽奖合同。

8989
14:56:45.072 --> 14:56:52.198
对于我们的抽奖契约，这里有几件事我们要注意第一件事是我们的构造函数现在绝对是巨大的。

8990
14:56:52.198 --> 14:56:56.487
这里有大量的参数需要我们考虑。

8991
14:56:56.537 --> 14:57:00.946
让我们看一下构造函数，看看是否有已经与之交互的契约。

8992
14:57:00.946 --> 14:57:02.519
VRF，协调器v2。

8993
14:57:02.519 --> 14:57:10.070
这是合同地址，入场费，没有汽油，没有订阅ID没有回调，guestimate no和间隔。

8994
14:57:10.070 --> 14:57:10.270
不。

8995
14:57:10.270 --> 14:57:16.214
知道这是一个地址应该是一个提示，我们可能需要部署一些mock。

8996
14:57:16.214 --> 14:57:22.488
为此，因为我们需要与项目外部的VRF协调器合同进行交互。

8997
14:57:22.537 --> 14:57:27.782
但是让我们继续，首先开始我们的抽奖部署脚本，我们知道我们将不得不部署一些模拟。

8998
14:57:27.782 --> 14:57:29.355
我们要记住这一点。

8999
14:57:29.355 --> 14:57:31.037
让我们创建一个新文件。

9000
14:57:31.037 --> 14:57:33.912
哦，第一，部署抽奖。

9001
14:57:33.912 --> 14:57:34.162
js。

9002
14:57:34.162 --> 14:57:39.457
让我们开始部署抽奖合同。

9003
14:57:39.457 --> 14:57:42.331
这看起来和我们之前做过的很像。

9004
14:57:42.331 --> 14:57:43.473
我们在这里再做一遍。

9005
14:57:43.538 --> 14:57:48.089
如果您想使用以前的部署脚本作为参考，我绝对建议您这样做。

9006
14:57:48.089 --> 14:57:54.587
但让我们从exports = async函数的模块开始。

9007
14:57:54.587 --> 14:58:02.905
这需要获得指定的帐户和部署。

9008
14:58:02.905 --> 14:58:08.605
作为输入参数，然后我们用const。

9009
14:58:08.605 --> 14:58:18.038
部署日志等于部署，然后我们会说const，部署者，等于await，获取命名帐户。

9010
14:58:18.038 --> 14:58:33.487
让我们进入导出到的配置和更新模块我将复制粘贴这个，因此雇主将默认为账号0而玩家将默认为账号1，如果你想把这个写出来，请随时暂停并写出你的名字账号。

9011
14:58:33.487 --> 14:58:36.796
现在，我们的心帽里会有很多样板。

9012
14:58:36.796 --> 14:58:37.183
配置。

9013
14:58:37.183 --> 14:58:37.312
js。

9014
14:58:37.312 --> 14:58:45.792
所以，请随时使用这节课的GitHub回购文件，或之前作为参考编写的名为accounts Deployer的脚本。

9015
14:58:45.792 --> 14:58:53.502
我们还会有一个玩家名帐户，这样我们就可以区分不同的用户或不同的玩家，他们与我们的合同进行交互。

9016
14:58:53.538 --> 14:58:54.961
但现在，我们要抓取部署器。

9017
14:58:56.538 --> 14:58:57.070
开始。

9018
14:58:59.538 --> 14:59:10.454
Raffle = await ploy, Raffle，逗号，然后把所有的东西都加进去，对吧?这是来自Deployer。

9019
14:59:10.538 --> 14:59:13.014
参数，我们会有大量的参数。

9020
14:59:14.539 --> 14:59:15.506
回到这个话题。

9021
14:59:15.506 --> 14:59:18.167
然后log就为真。

9022
14:59:19.539 --> 14:59:25.280
需要等待确认，我们需要在Hardhead配置中使用更多的样板文件，我们在这里没有网络。

9023
14:59:25.280 --> 14:59:27.089
我们加上网络信息。

9024
14:59:27.089 --> 14:59:31.233
所以我们可以得到那些区块确认在这里也会是具体的。

9025
14:59:31.233 --> 14:59:35.539
默认网络将是硬帽。

9026
14:59:35.539 --> 14:59:48.329
然后我们会说网络，我们会添加我们的网络信息它将与heart hub一起工作，它的链ID是31337英里，我们也会把它放在这里。

9027
14:59:48.329 --> 14:59:56.030
区块确认只设置为这一列，我们还将在林克比网络上进行一些阶段性测试。

9028
14:59:56.030 --> 15:00:08.153
我们将在这里添加溜冰场B，链ID为4，区块确认为6，我们需要添加一个URL，然后为URL添加一些帐户。

9029
15:00:08.153 --> 15:00:10.433
我们已经做过100次了。

9030
15:00:10.433 --> 15:00:11.748
我们用const。

9031
15:00:11.748 --> 15:00:25.996
rinky dink可以是RPC URL = process study和v。rake, RPC URL，那是私钥，等等，等等，我们将添加所有这些相同的变量从我们的上一个项目。

9032
15:00:25.996 --> 15:00:30.605
我要求大家暂停一下复制粘贴上一个项目中的所有变量。

9033
15:00:30.605 --> 15:00:40.391
因为运行rink, prpc, URL，私钥玉米市值和以太扫描，我们还要确保你的文件夹，不好意思，是新文件。env。

9034
15:00:40.391 --> 15:00:49.668
我们会把所有的信息都放到这里我们的rink, prpc, URL，私钥，以太扫描API密钥，还有我们的硬币市值API密钥。

9035
15:00:49.668 --> 15:00:59.298
现在我们有了私钥或环prpc URL在URL B RPC URL下，对于账户，我们只需要添加那个私钥。

9036
15:00:59.298 --> 15:01:14.701
对于network config。block con，我们需要从Hardhead导入network，这看起来像我的VS code自动为我做的。

9037
15:01:14.701 --> 15:01:15.426
谢谢VS code。

9038
15:01:15.426 --> 15:01:17.898
这就是我们抽奖的方式。

9039
15:01:17.898 --> 15:01:21.453
显然，我们有大量的论点需要解释。

9040
15:01:21.453 --> 15:01:22.435
让我们开始吧。

9041
15:01:22.540 --> 15:01:24.830
让我们看看我们的抽奖构造函数，看看我们需要得到什么。

9042
15:01:24.830 --> 15:01:39.487
好的，首先我们需要通过协调器v2得到的东西，我们将使用我们在Funmi项目中使用的相同的策略使用模拟，如果我们在开发链上，如果我们在测试网络上，或在活动网络上，使用实际的合同地址，让我们开始吧。

9043
15:01:39.487 --> 15:01:47.095
让我们继续，重新创建那个助手，hardhat config。js并创建那个const。

9044
15:01:47.095 --> 15:01:47.983
网络。

9045
15:01:47.983 --> 15:01:54.149
Config，它等于hard hat，我们将使用mock。

9046
15:01:54.149 --> 15:01:56.258
所以我们现在不需要把它放在这里。

9047
15:01:56.258 --> 15:02:02.444
但是对于溜冰场B，让我们继续，但是这里有一个外国人，所以名字将是Rinkeby。

9048
15:02:02.444 --> 15:02:10.477
我们要去看链链文档，VRF合同，我们要去找林克比的射频协调器。

9049
15:02:10.477 --> 15:02:19.572
测试网，我们会抓取这个地址，把它放在这里，我们会说V RF core做了一个8圈V 2，砰，就像这样。

9050
15:02:19.572 --> 15:02:35.243
回到我们的部署抽奖中，我们要选择是否在网络配置中使用vrf协调器v2或者我们部署的一些模拟，当然，这导致我们必须部署一个模拟，让我们创建新文件00。

9051
15:02:35.243 --> 15:02:36.665
部署标志。

9052
15:02:36.665 --> 15:02:36.883
js。

9053
15:02:36.883 --> 15:02:56.616
同样的事情，modules exports equals async function，它在运行时环境中获取命名帐户和部署，作为它的输入变量，或者do const deploy COMM log =部署。

9054
15:02:56.616 --> 15:03:10.844
然后是const, Deployer = await, get named accounts, Excel，然后我们会抓取链ID我们只会在开发链上部署这个。

9055
15:03:10.844 --> 15:03:17.023
我们写入const chain ID = network。config。chain ID。

9056
15:03:17.023 --> 15:03:20.420
现在我们只想部署模拟，如果我们在开发链上。

9057
15:03:20.420 --> 15:03:25.069
再一次，我们将进入我们的助手配置，我们将在这里添加那些开发链。

9058
15:03:25.069 --> 15:03:32.741
我们写上const，开发链等于硬帽，还有localhost。

9059
15:03:32.741 --> 15:03:36.541
然后我们要导出这两个。

9060
15:03:36.541 --> 15:03:44.374
因此，模块，点导出，等于网络配置和开发机会。

9061
15:03:44.374 --> 15:04:00.713
在我们的部署模拟中，我们想要抓取那些说const development chains，等于require。。斜杠helper hardhat config。

9062
15:04:00.713 --> 15:04:09.168
现在我们可以检查开发链是否包含我们当前所在的网络。

9063
15:04:09.168 --> 15:04:16.902
如果我们在开发链中，我们将继续记录本地网络，即受保护的部署框。

9064
15:04:16.902 --> 15:04:29.439
现在我们必须部署一个模拟VRF协调器，我们在哪里得到一个模拟VRF协调器，让我们继续创建一个。

9065
15:04:29.542 --> 15:04:30.961
我们去了链条。

9066
15:04:30.961 --> 15:04:33.090
还是GitHub，我们用的是合约。

9067
15:04:33.542 --> 15:04:33.649
0.

9068
15:04:39.542 --> 15:04:42.491
马赫点索尔，我们将用它作为我们的模拟。

9069
15:04:42.542 --> 15:04:57.727
在合约文件夹中，我们会创建一个新文件test新文件V RF core，在一个core中，两个mock。Sol，我们会导入这个mock，让它成为我们的mock。

9070
15:04:57.727 --> 15:05:00.245
我们用spdx。

9071
15:05:00.245 --> 15:05:05.772
我们会做pragma, solidity，胡萝卜0，第8点。

9072
15:05:05.772 --> 15:05:15.197
0，或者7，或者其他我们想要的，我们输入import at chainlink /合同/ SRC / v0。

9073
15:05:15.197 --> 15:05:15.311
8.

9074
15:05:15.542 --> 15:05:18.558
斜杠，mock，斜杠VRF。

9075
15:05:23.542 --> 15:05:27.912
我们会检查它是否用Hardhead编译器编译，看起来它也在编译。

9076
15:05:27.912 --> 15:05:28.299
太棒了。

9077
15:05:28.299 --> 15:05:33.620
现在我们有了模拟契约，就可以实际部署它了。

9078
15:05:33.620 --> 15:05:44.186
所以我们做一个权重loi, RF核心de ne Tor V到Mach逗号，然后我们在这里给它我们的参数。

9079
15:05:44.186 --> 15:05:45.870
我们会说from Deployer。

9080
15:05:45.870 --> 15:05:50.808
Log是正确的，然后我们来做论证。

9081
15:05:50.808 --> 15:05:54.762
那么VRF协调器v2 Mk的参数是什么呢?

9082
15:05:54.762 --> 15:06:06.011
如果我们打开VRF协调器v2 Mock，就在我们的VS代码中，或者在GitHub上，我们实际上可以看到，我们将滚动到构造函数，它需要两个东西。

9083
15:06:06.011 --> 15:06:09.214
它需要一个基本费用和天然气价格的链接。

9084
15:06:09.214 --> 15:06:13.908
第一个是什么?第一个是const基础费用。

9085
15:06:13.908 --> 15:06:19.182
如果我们回到文档，我们可以看到溢价部分是0。

9086
15:06:19.182 --> 15:06:25.123
25链接B，这意味着每个请求的基本费用是0。

9087
15:06:25.123 --> 15:06:27.139
每个请求25个链接。

9088
15:06:27.139 --> 15:06:32.068
所以任何时候我们想在林基上请求一个随机数，它的代价都是0。

9089
15:06:32.068 --> 15:06:32.237
25.

9090
15:06:32.237 --> 15:06:35.118
链接，或者你可以认为它是0。

9091
15:06:35.118 --> 15:06:37.480
25 .甲骨文气提出此请求。

9092
15:06:37.480 --> 15:06:49.936
回到我们的部署模拟中，我们可以说以V为基数等于，我们可以像这里的Rinckey一样执行25，等等，等等，或者我们可以执行ethers。utils。parse eath, of 0。

9093
15:06:49.936 --> 15:06:50.132
25.

9094
15:06:50.132 --> 15:06:54.754
我在这里写上注释，设为0。

9095
15:06:54.754 --> 15:06:58.139
25是保险费，成本是0。

9096
15:06:58.139 --> 15:07:00.284
25链接每个请求。

9097
15:07:00.284 --> 15:07:04.076
记住，这个花费为0的原因。

9098
15:07:04.076 --> 15:07:09.193
每个请求25个链接与价格提要相比没有任何成本，因为价格提要。

9099
15:07:09.193 --> 15:07:29.887
如果我们回头看一个链接链，每一个价格提要都是由一组协议赞助的这些协议已经为所有这些请求支付了，因为没有赞助商，我们是唯一要求随机性的人，我们将是真正赞助得到这个随机数的人，那么第二个东西将是天然气价格链接。

9100
15:07:29.887 --> 15:07:33.376
让我们在这里创建另一个const。

9101
15:07:33.376 --> 15:07:34.626
汽油价格挂钩。

9102
15:07:34.626 --> 15:07:42.797
但这实际上是一个计算值是一个基于链条的天然气价格的计算值。

9103
15:07:42.797 --> 15:07:54.998
举个例子，如果我们在Aetherium上请求一个随机的数字，而地球的价格飙升到大约十亿美元，那么天然气将会非常非常昂贵。

9104
15:07:54.998 --> 15:08:10.351
当链结节点响应链结节点支付气费，给我们随机性，并进行外部执行时，链结节点实际上是在返回随机性或执行维护等时支付气费的节点。

9105
15:08:10.351 --> 15:08:23.511
如果我们去到我们的raffle。soul，向下滚动执行维护，或实现随机单词，实际上是链条节点调用这两个函数并为此支付气体，它们得到Oracle气体支付来抵消这些成本。

9106
15:08:23.511 --> 15:08:29.859
但如果地球的价格，或任何本地区块链的价格暴涨，链条就会连接自己来支付煤气费。

9107
15:08:29.859 --> 15:08:40.486
所以链条节点有一个计算价格每个环节有一个计算变量叫做天然气价格，它根据实际链条的价格波动，所以它们永远不会破产。

9108
15:08:41.544 --> 15:08:51.431
基本上，一个请求的价格是根据那个区块链的汽油价格变化的，你可以把这想成是每个汽油的链接，如果你愿意，现在我们可以把它设为我们想要的任何值。

9109
15:08:51.431 --> 15:08:58.169
我们把它设为1123456789，也就是1123456789。

9110
15:08:58.169 --> 15:09:18.889
现在我们有了基本费用和汽油价格链接，我们会抓取这个基本费用，我们会让这些作为VR和弦的参数，输入V来模拟，我们会说实际上我们可以删除它会说const, args等于基本费用，汽油价格链接，然后我们可以取这个args变量，把它放到这里。

9111
15:09:18.889 --> 15:09:32.223
现在我们可以执行log mocks deployed，然后我们可以执行log这一行像这样让人们知道deploy脚本已经完成，然后我们将执行一个导出。tags = all和mocks的模块。

9112
15:09:32.223 --> 15:09:40.732
现在我们已经部署了协调器v2 Mock的视图，我们将回到抽奖环节，并围绕它编写一些代码。

9113
15:09:40.732 --> 15:09:43.945
与我们刚刚对部署模拟所做的类似。

9114
15:09:43.945 --> 15:09:50.254
我们可以说，如果开发链包含network。name，我们会做一些事情。

9115
15:09:50.254 --> 15:09:54.303
我们需要从我们的助手Hardhead配置中导入开发链。

9116
15:09:54.303 --> 15:09:56.839
我们需要从安全帽导入网络。

9117
15:09:56.839 --> 15:09:59.708
我的VS code自动添加了他们哇，谢谢VS code。

9118
15:09:59.708 --> 15:10:02.883
我们用const args把这个变量设为下面这里。

9119
15:10:02.883 --> 15:10:03.811
插入参数。

9120
15:10:03.811 --> 15:10:20.165
我们的第一个参数需要是这个Vera fi to coordinator让我们创建一个变量让VRF core需要torby来处理如果我们在开发链上，我们会抓取那个模拟契约。

9121
15:10:20.165 --> 15:10:44.375
所以我们会说const PRF, Cor de ATAR V to mock等于await ether。get contract, RF连线到NATO Tor的连线V两个MK，然后我们可以设置RF协调器V两个地址等于VRF core denater V两个mach。address。

9122
15:10:44.375 --> 15:10:44.968
酷。

9123
15:10:44.968 --> 15:10:48.052
我们这里有地址。

9124
15:10:48.052 --> 15:10:57.412
否则，如果我们不在本地网络上，VRF v2协调器地址将简单地从我们的网络配置中派生出来。

9125
15:10:57.412 --> 15:11:08.562
所以让我们也从我们的助手Hardhead配置中导入网络配置，我们会说else VRF协调器v2地址等于链ID的网络配置。

9126
15:11:08.562 --> 15:11:21.062
不好意思，我们需要chain ID。chain ID = network。config。chain ID, VR协调器V的chain ID到chain ID。

9127
15:11:21.062 --> 15:11:23.675
你是协调者v2。

9128
15:11:23.675 --> 15:11:24.771
好的,完美的。

9129
15:11:24.771 --> 15:11:28.627
我们已经得到了与VRF协调器v2地址一起工作的设置。

9130
15:11:28.627 --> 15:11:38.498
我们的抽奖还需要什么?我们需要入场费，我们可能会根据我们所在的连锁店改变入场费，我们在一个更贵的连锁店，我们可能会让它比其他的高。

9131
15:11:38.546 --> 15:11:48.962
让我们回到我们的助手Hardhead配置并基于区块链设置入口费用，对于NP，也许我们想让它为0。

9132
15:11:48.962 --> 15:11:49.545
01容易的。

9133
15:11:49.545 --> 15:11:54.201
所以我们可以说，ethers。utils, parse ether (0)

9134
15:11:54.201 --> 15:11:54.407
01.

9135
15:11:54.407 --> 15:12:00.336
再次感谢VS code为我自动添加这个。

9136
15:12:00.336 --> 15:12:07.283
我们还需要心脏应用的入口费，我们还可以在这里设置默认值，让我们更明确一点。

9137
15:12:07.283 --> 15:12:08.817
所以我们写31337。

9138
15:12:08.817 --> 15:12:15.923
这个的名字是Art app，我们不需要给它一个协调器v2地址因为我们会部署一个模拟。

9139
15:12:15.923 --> 15:12:17.447
但我们要收入场费。

9140
15:12:17.546 --> 15:12:20.084
我们给它同样的入场费。

9141
15:12:20.546 --> 15:12:22.958
写入ethers。utils。parse ether 0。

9142
15:12:22.958 --> 15:12:23.211
01 E。

9143
15:12:23.211 --> 15:12:24.163
好了,好了。

9144
15:12:24.546 --> 15:12:33.659
在这里的部署中，我们可以说const入口费用等于网络配置。

9145
15:12:33.659 --> 15:12:37.433
门票链ID。

9146
15:12:37.433 --> 15:12:40.654
让我们开始填充弧线。

9147
15:12:40.654 --> 15:12:43.301
第一个是fe2协调器地址。

9148
15:12:43.301 --> 15:12:44.777
下一个是入场费。

9149
15:12:44.777 --> 15:12:45.930
明白了吗?明白了。

9150
15:12:45.930 --> 15:12:47.853
现在我们需要加油道。

9151
15:12:47.853 --> 15:13:07.030
在Rigby和其他网络上，我们可以选择不同的汽油通道，让我们从Rinckey获取唯一的汽油通道，30，灰色的散列键，让我们把这个，当然，放到我们的网络配置中作为汽油，把它放在这里，我们是硬帽子，我们的mock实际上并不关心我们在什么汽油通道上工作，因为我们无论如何都会模拟汽油。

9152
15:13:07.030 --> 15:13:12.772
所以我们可以说gas lane，我们可以继续使用相同的或者其他的，这并不重要。

9153
15:13:12.772 --> 15:13:18.427
这里我们说const，汽油等于网络配置。

9154
15:13:18.547 --> 15:13:22.598
链证，汽油，我们去加油通道。

9155
15:13:23.547 --> 15:13:27.710
把它插入参数数组，我们有这个，有这个，还有这个。

9156
15:13:27.710 --> 15:13:29.637
现在是订阅ID的时候了。

9157
15:13:29.637 --> 15:13:50.932
如果你还没读过docstoc chain link关于chain link VRF，我强烈建议你读一下这样你就能理解这个订阅ID是什么我们知道我们可以通过前端创建订阅ID通过这个网站VRF。chain。link，这很好但如果我们在所有本地链上，我们可以在这里获得订阅ID没问题。

9158
15:13:50.932 --> 15:13:53.756
但在本地网络上就有点难了。

9159
15:13:53.756 --> 15:13:58.333
现在我要教你如何创建和资助订阅这完全是程序化的。

9160
15:13:58.333 --> 15:14:01.186
如果你不想，你甚至不需要使用UI。

9161
15:14:01.186 --> 15:14:08.297
然而，这门课的目的是，我们仍然会使用用户界面，我们仍然会使用那个网站来获取我们自己的订阅id。

9162
15:14:08.297 --> 15:14:13.835
但是您可以100%自动化创建订阅ID和资助订阅ID的过程。

9163
15:14:13.835 --> 15:14:20.984
因为当你创建和资助订阅id时，你只是在智能合约上调用create subscription和fund subscription。

9164
15:14:20.984 --> 15:14:29.354
在我们的开发链上，我们有vrf协调器v2 Mock，我们要做的是在我们的开发链上，我们要创建那个订阅。

9165
15:14:29.354 --> 15:14:41.785
我们会说const transaction response = await VRF coordinator v2 Mock。create subption。

9166
15:14:41.785 --> 15:14:54.039
然后我们运行const transaction receipt = weight trends action response。Wait，等待一个区块确认。

9167
15:14:54.039 --> 15:15:03.709
在这个事务接收中，我们可以通过订阅发送一个事件这是另一个发送事件非常有用的地方。

9168
15:15:03.709 --> 15:15:18.902
事实上，如果我们打开一个Vera v2协调器标记，我们寻找create subscription，我们看到我们用subscription ID创建了subscription，我们实际上可以从我们的事务收据中获得这个事件。

9169
15:15:18.902 --> 15:15:23.214
现在要分配它，让我们在这里创建一个子订阅ID。

9170
15:15:23.214 --> 15:15:34.203
然后我们说订阅ID = transaction receipt events。args。subid。

9171
15:15:34.203 --> 15:15:40.698
如果您想了解更多关于如何在硬件中使用事件的知识，请务必观看事件视频。

9172
15:15:40.698 --> 15:15:47.863
现在我们有了订阅，我们需要在真实的网络上为订阅提供资金，您需要链接令牌来实际为订阅提供资金。

9173
15:15:47.863 --> 15:15:52.259
模拟的当前迭代允许您在没有链接令牌的情况下资助订阅。

9174
15:15:52.259 --> 15:16:24.082
我们能做的是运行一个F君标，如果协调器B到Mach。基金订阅，我们给它一个订阅ID我们需要做一些基本的这个，我们可以创建一些变量，我们说const VRF，订阅基金金额等于ethers。utils。parse ether，我们说30 VRF订阅。

9175
15:16:24.082 --> 15:16:26.215
我们把它粘贴到这里。

9176
15:16:26.215 --> 15:16:29.310
我们也可以在真实的测试网络或直播网络中这样做。

9177
15:16:29.310 --> 15:16:34.735
但是为了让我们熟悉用户界面，我们不打算用编程的方式做一个测试网。

9178
15:16:34.735 --> 15:16:37.725
对于测试网，我们将使用到目前为止我们所做的。

9179
15:16:37.725 --> 15:16:41.059
或者我们可以添加订阅ID和助手配置。

9180
15:16:41.059 --> 15:16:47.303
我们写入订阅ID，我们在这里放一些东西，让它为零。

9181
15:16:47.303 --> 15:16:52.715
但稍后，当我们实际创建订阅时，我们将更新订阅ID。

9182
15:16:52.715 --> 15:16:58.456
订阅ID等于网络配置。

9183
15:16:58.456 --> 15:17:02.471
更改订阅ID的ID。

9184
15:17:02.471 --> 15:17:03.578
完美的。

9185
15:17:03.578 --> 15:17:07.715
现在我们可以把它添加到arguments数组中。

9186
15:17:07.715 --> 15:17:15.049
我们还需要订阅ID吗，我们需要一个回调气体限制或者回调，气体限制会因网络而异。

9187
15:17:15.049 --> 15:17:18.972
再一次，我们要进入辅助配置回调气体限制。

9188
15:17:18.972 --> 15:17:23.844
对我们来说，我们设定的上限是50万汽油。

9189
15:17:23.844 --> 15:17:27.286
我们设气体极限是5。

9190
15:17:27.286 --> 15:17:28.367
123年500000年。

9191
15:17:28.367 --> 15:17:28.760
气体。

9192
15:17:28.760 --> 15:17:31.430
对于安全帽，我们做同样的事情。

9193
15:17:31.430 --> 15:17:44.470
我们可以说const，回调，gas limit = network config, chain ID，回调，gas limit，抓取这个，放到参数数组中。

9194
15:17:44.550 --> 15:17:47.200
我们还需要什么?我们现在需要的是区间。

9195
15:17:47.550 --> 15:17:50.397
也可以将这个网络更改为网络。

9196
15:17:51.550 --> 15:17:57.050
对于hard hat和Rigby来说，间隔将只有30秒。

9197
15:17:57.050 --> 15:17:58.827
我们在这里做同样的事情。

9198
15:17:58.827 --> 15:17:59.382
表示常量。

9199
15:17:59.550 --> 15:18:03.484
间隔等于网络配置。

9200
15:18:07.550 --> 15:18:10.856
拿上这个，放到数组的最后。

9201
15:18:12.550 --> 15:18:15.946
现在我们有了一个参数数组，把它放在这里，很好。

9202
15:18:15.946 --> 15:18:18.963
抽奖合同构造函数里的所有东西。

9203
15:18:18.963 --> 15:18:19.273
太好了。

9204
15:18:19.273 --> 15:18:20.617
这看起来棒极了。

9205
15:18:20.617 --> 15:18:24.683
我们有等待确认我们有日志参数Deployer。

9206
15:18:24.683 --> 15:18:29.487
好吧，接下来呢?好了，让我们继续添加验证部分。

9207
15:18:29.550 --> 15:18:34.994
再一次，创建一个新文件夹utils，新文件verify。

9208
15:18:34.994 --> 15:18:35.142
js。

9209
15:18:35.142 --> 15:18:48.009
我们可以从上一个项目复制粘贴这个，也可以从与这门课相关的GitHub回购中获取这个，一旦我们在这里有了验证脚本，我们会通过const来导入它。

9210
15:18:48.009 --> 15:18:54.860
验证等于要求。点。斜杠助手Hardhead配置。

9211
15:18:54.860 --> 15:19:07.425
然后我们可以在下面添加同样的代码来验证我们的合同，如果我们不在开发链上。

9212
15:19:07.425 --> 15:19:23.075
我们有研究v。ether扫描API key的进程，然后我们会验证log。然后等待验证raffle。address和弧。

9213
15:19:23.075 --> 15:19:34.519
现在我们用一大堆连字符的对数表示脚本已经完成module。exports。tags = this will be all and raffle。

9214
15:19:34.519 --> 15:19:37.228
好了，我们来测试一下。

9215
15:19:37.228 --> 15:19:44.217
我们将执行硬帽部署，或者yarn，硬帽部署，看看这个脚本是否正确工作。

9216
15:19:44.217 --> 15:19:48.173
看来我们遇到了网络配置未定义的错误。

9217
15:19:48.173 --> 15:19:49.789
我们把这个拼对。

9218
15:19:49.789 --> 15:19:50.503
网络配置。

9219
15:19:50.503 --> 15:19:51.074
好了。

9220
15:19:51.074 --> 15:19:52.359
这样看起来好多了。

9221
15:19:52.551 --> 15:19:53.585
让我们再试一次。

9222
15:19:55.551 --> 15:19:56.205
工作得很好。

9223
15:19:58.551 --> 15:20:05.451
部署VRF协调器v2模拟部署，然后我们继续部署我们的抽奖。

9224
15:20:05.451 --> 15:20:07.951
太棒了，这是巨大的。

9225
15:20:07.951 --> 15:20:14.499
现在我们还不打算测试将它部署到测试网中，因为我们还没有任何单元测试。

9226
15:20:14.551 --> 15:20:18.851
在我们想要在测试网络上测试运行之前，我们需要编写单元测试。

9227
15:20:18.851 --> 15:20:23.801
所以我们有了部署脚本，有了合同，这意味着我们是时候编写一些测试了。

9228
15:20:23.801 --> 15:20:26.757
我们到这里创建一个新文件夹test。

9229
15:20:26.757 --> 15:20:29.032
现在，我们只做单元测试。

9230
15:20:29.032 --> 15:20:34.680
单元测试，在这里我们创建一个名为raffle的新文件。

9231
15:20:34.680 --> 15:20:35.067
测试。

9232
15:20:35.067 --> 15:20:35.260
js。

9233
15:20:35.551 --> 15:20:36.981
让我们写一些单元测试。

9234
15:20:38.551 --> 15:20:42.173
这里有点啰嗦，我们要让我们的覆盖面非常非常好。

9235
15:20:42.173 --> 15:20:45.389
这不会是完美的，但会很啰嗦。

9236
15:20:45.389 --> 15:20:47.171
我很快地讲完。

9237
15:20:47.171 --> 15:20:52.689
所以你们可以随意暂停，让我慢下来，加快我学习这一部分的速度。

9238
15:20:52.689 --> 15:20:59.518
通过编写这些测试并理解在编写这些测试时应该考虑什么，这是非常好的肌肉记忆。

9239
15:20:59.518 --> 15:21:03.487
所以，请随意加快你已经知道的部分，放慢新部分。

9240
15:21:03.487 --> 15:21:06.952
因为我们要讲一些新知识。

9241
15:21:06.952 --> 15:21:09.689
编写测试似乎是一个乏味的过程。

9242
15:21:09.689 --> 15:21:16.896
但是我保证，当你更好地编写这些测试时，你会意识到当某些东西不能工作时，你可以依靠这些东西。

9243
15:21:16.896 --> 15:21:23.823
当你不确定如何编码时，记下这些肌肉记忆，编写这些测试将使你成为一个出色的工程师。

9244
15:21:23.823 --> 15:21:29.489
我们来做一遍我们会写一些冗长的测试来让它变得很好让它有很好的覆盖率。

9245
15:21:29.489 --> 15:21:35.409
如果你想稍后再回去，看看你是否能给它更多的覆盖范围，更好的测试，请随时这样做。

9246
15:21:35.409 --> 15:21:36.456
让我们开始吧。

9247
15:21:36.552 --> 15:21:37.599
让我们编写一些测试。

9248
15:21:39.552 --> 15:21:46.355
与我们开始所有事情的方式相同，我们将抓取我们的开发链，这样我们只在开发链上运行单元测试。

9249
15:21:46.355 --> 15:22:06.174
我们会写const development chains，等于require。。斜杠。。斜杠helper RD, hard hat config，然后我们会说not development chains，这包括network。name，并描述那个跳过。

9250
15:22:06.174 --> 15:22:12.197
否则，我们将使用描述，第一个描述将是抽奖单元测试。

9251
15:22:12.197 --> 15:22:15.390
这将是一个异步。

9252
15:22:15.390 --> 15:22:16.260
函数。

9253
15:22:16.552 --> 15:22:20.164
抽奖单元测试让它出现在下一行，看起来好一点。

9254
15:22:20.164 --> 15:22:20.647
好了,好了。

9255
15:22:20.647 --> 15:22:37.001
现在，我们需要部署的一些主要的东西是什么?我们需要部署一个抽奖，我们可能需要一个VRF核心到一个tour在每个之前进行模拟分级，那将是一个async函数，我们将在那里得到这些会说const。

9256
15:22:37.001 --> 15:22:41.345
雇主等于等待，得到指定的帐户。

9257
15:22:41.553 --> 15:22:49.460
我们需要导入getnames accounts或require从hardhat获取name accounts，然后我们需要使用fixture部署这些。

9258
15:22:49.460 --> 15:22:51.429
所以我们可以说等待部署。

9259
15:22:51.553 --> 15:23:01.053
然后我们还会从hardhat。fixture导入部署，我们会调用所有，我们会部署所有东西。

9260
15:23:01.053 --> 15:23:08.654
再看一下我们的，我们的raffle有alt标签，我们的mock也有alt标签，很好。

9261
15:23:08.654 --> 15:23:15.749
一旦我们部署了所有东西，我们可以说raffle = await醚。get to contract。

9262
15:23:15.749 --> 15:23:19.486
我们要从安全帽进口醚，就像这样。

9263
15:23:19.486 --> 15:23:27.026
我们会说它会得到抽奖合同我们会把它连接到我们的部署者。

9264
15:23:27.026 --> 15:23:40.129
然后我们会对VRF协调器v2做同样的事情，Mock = await ethers。get contract, RF协调器，B到MK，也把这个连接到部署器。

9265
15:23:40.129 --> 15:23:45.671
好的，我们的第一组测试描述了，它们将是构造函数。

9266
15:23:45.671 --> 15:23:49.942
这将是一个async函数。

9267
15:23:49.942 --> 15:23:51.693
我们来做这个。

9268
15:23:51.693 --> 15:24:01.762
让我们创建一个IT初始化抽奖正确初始化，这将是一个异步函数。

9269
15:24:01.762 --> 15:24:14.377
现在我要做一个标记，因为理想情况下，我们让我们的测试只有一个断言，或者它只是记住，理想情况下，我们希望它只有一个断言。

9270
15:24:14.377 --> 15:24:18.295
但是我们会有一堆因为就像我说的，我们在这里有点松散。

9271
15:24:18.295 --> 15:24:21.938
我们要确保抽奖被正确初始化。

9272
15:24:21.938 --> 15:24:30.467
所以我们说const raffle state，我们会得到那个raffle state因为我们想确保我们从一个开放的raffle state开始。

9273
15:24:30.467 --> 15:24:38.284
我们说const, raffle state = await raffle。get raffle state。

9274
15:24:38.284 --> 15:24:44.657
然后我们要说assert。equal ope然后我们需要从Chai导入assert。

9275
15:24:44.657 --> 15:24:49.384
因此，断言= require Chai断言。equal raffle state。

9276
15:24:49.384 --> 15:24:55.102
到字符串，因为raffle state将是一个大数字。

9277
15:24:55.102 --> 15:25:02.844
即使抽奖状态是raffle state类型，如果它是打开的，它会返回0如果它在计算中，它会返回1。

9278
15:25:02.844 --> 15:25:06.392
这就变成了un 256。

9279
15:25:06.554 --> 15:25:10.506
当我们这样调用它时，抽奖状态函数会是一个很大的数。

9280
15:25:10.506 --> 15:25:12.791
我们只是想把文件串起来。

9281
15:25:12.791 --> 15:25:15.689
断言。equal raffle state dot 2string 0。

9282
15:25:15.689 --> 15:25:19.172
我们还要确保区间设置正确。

9283
15:25:19.172 --> 15:25:26.268
我们写入const interval = await raffle。get interval。

9284
15:25:26.268 --> 15:25:33.363
我不知道我们是否有这样的一个，实际上是C国际球，看看我们是否有这样一个。

9285
15:25:33.363 --> 15:25:41.472
我们没有一个很好的区间我们继续，再加上区间函数我们会遇到麻烦。

9286
15:25:41.472 --> 15:25:58.316
我们有公共视图返回，你去6返回我下划线interval将会有好的interval将会说raffle。get interval也会说断言。equal interval。

9287
15:25:58.316 --> 15:25:59.117
字符串。

9288
15:25:59.117 --> 15:26:06.194
它在helper配置中应该等于1 Ever，对吧?因为我们正在使用interval和helper配置。

9289
15:26:06.194 --> 15:26:07.200
所以我们说间隔。

9290
15:26:07.200 --> 15:26:08.974
字符串应该等于。

9291
15:26:08.974 --> 15:26:11.312
我们也要导入它。

9292
15:26:11.555 --> 15:26:12.827
网络配置。

9293
15:26:16.555 --> 15:26:17.932
网络配置。

9294
15:26:22.555 --> 15:26:24.848
chain ID，写上const。

9295
15:26:29.555 --> 15:26:34.587
chain ID, interval的chain ID的网络配置。

9296
15:26:35.555 --> 15:26:35.930
酷。

9297
15:26:41.555 --> 15:26:43.081
酷毙了，好像过去了。

9298
15:26:44.555 --> 15:26:45.087
输出。

9299
15:26:45.087 --> 15:26:45.474
太棒了。

9300
15:26:47.555 --> 15:26:50.361
它并不总是在气体中打印出来，但现在是这样。

9301
15:26:50.555 --> 15:26:55.412
我要复制粘贴上一个项目的气体报告部分，像这样。

9302
15:26:55.412 --> 15:26:58.227
我们现在会让enabled gas为假。

9303
15:26:58.227 --> 15:27:04.538
现在如果我们进行硬脑测试，我们不应该打印出汽油价格，我们应该只看测试结果，完美，这就是我们所看到的。

9304
15:27:04.538 --> 15:27:06.313
我们的构造函数测试通过了。

9305
15:27:06.313 --> 15:27:08.933
接下来是什么，我们的构造函数。

9306
15:27:08.933 --> 15:27:11.401
我们可能可以为剩下的这些编写更多的测试。

9307
15:27:11.401 --> 15:27:12.440
我们继续吧。

9308
15:27:12.440 --> 15:27:16.950
输入raffle，这将是我们的下一个描述块。

9309
15:27:16.950 --> 15:27:20.620
所以它会描述，进入，抽奖。

9310
15:27:20.620 --> 15:27:24.062
这将是一个async函数。

9311
15:27:24.062 --> 15:27:32.948
当你支付的钱不够的时候，我们会说它会恢复，因为我们首先检查的一件事是他们支付的钱足够多。

9312
15:27:32.948 --> 15:27:37.889
所以我们要确保如果他们不支付足够的钱，这种情况会发生逆转。

9313
15:27:37.889 --> 15:27:40.047
这将是一个async函数。

9314
15:27:40.047 --> 15:27:43.841
我们会做同样的期望等待。

9315
15:27:43.841 --> 15:27:50.277
所以我们要从Chai中导入expect，它来自华夫饼matcher。

9316
15:27:50.277 --> 15:27:56.505
我们会说await, expect raffle。enter a raffle。

9317
15:27:56.505 --> 15:28:05.314
我们不打算在这里传递任何值，我们期望它。b。

9318
15:28:05.314 --> 15:28:10.822
如果我们看这里，我们希望它恢复到这个抽奖没有足够的人进入。

9319
15:28:10.822 --> 15:28:15.460
所以我们可以把它加引号抽奖，没有足够的每一个进入。

9320
15:28:15.460 --> 15:28:16.602
现在我们可以试一下。

9321
15:28:16.602 --> 15:28:18.703
确保它确实有效。

9322
15:28:18.703 --> 15:28:20.834
啊，啊，测试，冲刺，冲刺，grep。

9323
15:28:20.834 --> 15:28:24.222
把这个加引号，说明你付的钱不够。

9324
15:28:24.222 --> 15:28:25.022
而可畏。

9325
15:28:25.022 --> 15:28:26.355
我们正经过那里。

9326
15:28:26.556 --> 15:28:32.047
我们还想测试什么?我们想要测试如果抽奖没有打开，我们也会恢复但我们一会儿会测试。

9327
15:28:32.047 --> 15:28:34.456
当我们测试剩下的功能时。

9328
15:28:34.556 --> 15:28:39.698
我们希望看到它在玩家进入时记录他们。

9329
15:28:40.556 --> 15:28:42.280
将是一个异步函数。

9330
15:28:44.556 --> 15:28:47.056
首先我们需要抽奖券入场费。

9331
15:28:47.556 --> 15:28:49.081
前进，把它保存在顶端。

9332
15:28:50.556 --> 15:29:01.056
协调员是模拟抽奖入场费，然后我们每个人之前都会说抽奖入场费等于一个权重醚点得到入场费。

9333
15:29:01.056 --> 15:29:05.087
这应该是抽奖，并获得入场费。

9334
15:29:05.087 --> 15:29:17.041
现在我们有了这个抽奖入场费，你可以用它来进入抽奖我们说一个weight raffle。enter raffle带着抽奖入场费的值。

9335
15:29:17.041 --> 15:29:21.842
我们可以确保这里的Deployer已经被正确记录。

9336
15:29:21.842 --> 15:29:24.249
既然现在我们连上了部署者。

9337
15:29:24.249 --> 15:29:28.387
我们只要确保这个部署者确实在我们的合同中。

9338
15:29:28.387 --> 15:29:44.490
我们写入const playerfromcontract = await raffle。get playerof0，因为我们在players数组中记录了它们我们有get players函数把它们取出来。

9339
15:29:44.490 --> 15:29:51.470
然后我们说断言。equal player, player from contract应该是部署者。

9340
15:29:51.557 --> 15:29:54.007
现在我们可以在头部测试中得到答案了。

9341
15:29:54.557 --> 15:29:55.557
这个作品。

9342
15:29:55.557 --> 15:29:57.857
HH test dash dash grep。

9343
15:30:00.557 --> 15:30:01.326
我们把它放在这里。

9344
15:30:02.557 --> 15:30:03.223
在全球范围内。

9345
15:30:03.223 --> 15:30:06.223
所以我们要让普通的部署者。

9346
15:30:07.557 --> 15:30:10.057
部署者=等待获取命名帐户。

9347
15:30:11.557 --> 15:30:14.466
这能让部署人员觉得很棒。

9348
15:30:16.557 --> 15:30:17.779
而可畏。

9349
15:30:22.557 --> 15:30:23.341
发出一个事件。

9350
15:30:23.341 --> 15:30:25.048
我们要确保它触发一个事件。

9351
15:30:25.557 --> 15:30:28.302
它在进入时触发事件。

9352
15:30:31.557 --> 15:30:31.895
也

9353
15:30:34.557 --> 15:30:43.346
确保函数触发一个事件，并且语法看起来与我们检查是否触发错误时的测试非常相似。

9354
15:30:43.346 --> 15:30:58.796
我们会说await expect raffle。enter raffle withvalue raffle入口费。2。省略和这个。

9355
15:30:58.796 --> 15:31:09.207
在woful期间，这些编钟匹配发射事件我们可以做一个wait expect to emit，然后是我们期望发射的事件。

9356
15:31:09.207 --> 15:31:15.885
我们说省略raffle契约来触发raffle进入事件。

9357
15:31:15.885 --> 15:31:19.229
我们可以复制这个，试着在终端中测试它。

9358
15:31:19.229 --> 15:31:21.136
所以我们称之为安全帽。

9359
15:31:21.136 --> 15:31:22.890
测试dash dash grep。

9360
15:31:22.890 --> 15:31:25.332
把这个加引号。

9361
15:31:25.332 --> 15:31:28.428
这也可以通过。

9362
15:31:28.428 --> 15:31:29.202
太好了。

9363
15:31:29.202 --> 15:31:38.321
现在让我们继续进行测试，以确保在抽奖未开启或正在计算时我们不能进入抽奖。

9364
15:31:38.321 --> 15:31:45.954
所以我们说它不允许进入，当抽奖是卡尔累积。

9365
15:31:45.954 --> 15:31:48.977
这将是一个async函数。

9366
15:31:48.977 --> 15:31:59.824
首先我们会进入我们会说等待raffle。enter raffle value是抽奖入场费。

9367
15:31:59.824 --> 15:32:05.933
现在我们要做的是让抽奖进入一个封闭状态。

9368
15:32:05.933 --> 15:32:08.367
我们想让它脱离开放状态。

9369
15:32:08.367 --> 15:32:22.824
那么，我们如何在执行维护中将这个抽奖从抽奖点打开移动到抽奖点关闭，从抽奖中移除抽奖点打开到抽奖点计算，但执行维护只能在检查维护返回true时调用。

9370
15:32:22.824 --> 15:32:26.424
否则，它将恢复与抽奖维护不需要。

9371
15:32:26.558 --> 15:32:29.808
我们需要做的是让checkupkeep返回true。

9372
15:32:29.808 --> 15:32:36.291
我们会假装自己是通灵守护者网络，继续呼叫检查，等待它是真的。

9373
15:32:36.291 --> 15:32:43.913
一旦我们实现了它，我们就会假装自己是通灵守护者，并调用执行维护者，将这个契约置于计算状态。

9374
15:32:43.913 --> 15:32:52.809
现在我们要怎么做呢?好吧，为了让检查保持正确，我们首先需要看到我们确实是开放的，我们确实是开放的。

9375
15:32:52.809 --> 15:32:56.927
接下来我们要做的是，我们要把这段时间过了一点。

9376
15:32:56.927 --> 15:33:01.268
我们需要等30秒时间过去。

9377
15:33:01.268 --> 15:33:03.296
这听起来有点可怕。

9378
15:33:03.296 --> 15:33:12.474
所有的检查都要等30秒吗?如果我们的间隔是10天，而我们必须等待10天才能进行测试呢?这听起来很荒谬。

9379
15:33:12.474 --> 15:33:20.674
硬帽实际上内置了大量的函数让我们操作区块链来做我们想让它做的任何事。

9380
15:33:20.674 --> 15:33:22.404
在硬帽文档中。

9381
15:33:22.404 --> 15:33:27.334
在硬帽网络部分中有一个叫做硬帽网络参考的部分。

9382
15:33:27.334 --> 15:33:33.965
在这里，有大量关于硬帽网络如何工作的信息以及我们可以用它做的不同配置。

9383
15:33:33.965 --> 15:33:41.995
如果我们向下滚动足够低，我们可以看到我们可以在这个区块链上使用的JSON RPC方法，我们可以做每个帐户块编号调用chinetti。

9384
15:33:41.995 --> 15:33:45.225
我们可以执行正常区块链所具有的所有RPC方法。

9385
15:33:45.225 --> 15:33:50.809
此外，我们还可以做更多，我们可以使用这些叫做Hard Hat Network的方法。

9386
15:33:50.809 --> 15:33:52.613
因为这是我们本地的硬帽网络。

9387
15:33:52.613 --> 15:33:56.869
我们用它来测试，我们希望能够测试任何场景。

9388
15:33:56.869 --> 15:34:02.905
正是这些方法给了我们这样做的能力，你可以通过这个来尝试看看你能做的所有不同的事情。

9389
15:34:02.905 --> 15:34:08.125
其中一个特别的是设置存储设置，你可以在任何地方设置存储，这非常有趣。

9390
15:34:08.125 --> 15:34:14.130
但一些特殊的测试调试方法是EVM增加时间，和EVM。

9391
15:34:14.130 --> 15:34:20.147
我增加的时间允许我们自动增加区块链和EVM的时间。

9392
15:34:20.147 --> 15:34:28.244
挖矿允许我们挖矿或创建新的区块，因为如果我们增加时间，它不会做任何事情，除非有一个新的区块被挖出。

9393
15:34:28.244 --> 15:34:53.330
我们能做的是运行一个等待网络，我们从Hard Hat network导入network等待网络。提供者它在crease时间发送EVM，逗号，我们可以发送一组参数，对我们来说就是我们的间隔。

9394
15:34:53.330 --> 15:34:54.067
数量。

9395
15:34:54.067 --> 15:34:55.717
然后是+ 1。

9396
15:34:55.717 --> 15:34:59.813
现在，我们的区间不是全局存储的，所以我们可能需要这样做。

9397
15:34:59.813 --> 15:35:01.971
我们来做interval。

9398
15:35:01.971 --> 15:35:12.527
然后在before each中，我们写上interval = await, raffle。raffle。get interval，我要复制这个我们要删除这整行。

9399
15:35:12.527 --> 15:35:14.397
等待抽奖点得到间隔。

9400
15:35:14.397 --> 15:35:19.271
因为现在我们将在全局层面上称它为interval，因为我们将经常使用它。

9401
15:35:19.271 --> 15:35:21.560
现在我们要对它进行积分。

9402
15:35:21.560 --> 15:35:28.910
所以我们要增加时间无论我们的间隔是多少以确保我们能让checkup keep返回true。

9403
15:35:28.910 --> 15:35:36.185
另外，我们要做一个权值网络。提供者。

9404
15:35:36.185 --> 15:35:42.887
Dot发送带有空数组的EVM mine，因为我们只是想多挖一个块。

9405
15:35:42.887 --> 15:35:52.463
你也可以用network。provider这个请求，这里有一个await，这两个基本是一样的，不过这个要快一些?所以我们增加了区块链的时间。

9406
15:35:52.463 --> 15:35:54.785
为了前进，我们在一个街区埋了地雷。

9407
15:35:54.785 --> 15:35:56.729
应该开门的时间已经过去了。

9408
15:35:56.729 --> 15:36:00.216
我们有播放器吗?我们确实有，因为我们已经参与抽奖了。

9409
15:36:00.216 --> 15:36:04.294
我们应该有一个平衡，因为我们已经输入了正确的苹果，检查维护现在应该返回true。

9410
15:36:04.294 --> 15:36:08.830
所以我们应该可以调用执行维护并假装自己是链锁管理员。

9411
15:36:08.830 --> 15:36:14.727
所以我们要假装自己是一个锁链，看守人，调用等待抽奖，执行维护。

9412
15:36:14.727 --> 15:36:21.595
我们将通过这样传递一个空数组来传递一些空调用数据。

9413
15:36:21.595 --> 15:36:24.888
现在它应该处于计算状态。

9414
15:36:24.888 --> 15:36:32.866
现在它处于计算状态，我们可以说，如果抽奖没有打开，我们的进入抽奖将正确地返回。

9415
15:36:32.866 --> 15:36:38.238
现在我们写await, expect raffle。enter, raffle。

9416
15:36:38.238 --> 15:36:43.672
我们会把抽奖门票的价值寄给它。

9417
15:36:43.672 --> 15:36:46.005
这是我们所期待的。

9418
15:36:46.005 --> 15:36:56.116
To。b。revertwithraffle下划线下划线不打开错误。

9419
15:36:56.116 --> 15:37:00.893
好了，让我们在测试中试试这个。

9420
15:37:00.893 --> 15:37:04.856
所以我们要运行Hardhead测试dash dash grep。

9421
15:37:04.856 --> 15:37:06.413
把这个加引号。

9422
15:37:06.413 --> 15:37:11.361
完美地通过了。

9423
15:37:11.561 --> 15:37:14.870
现在如果我们运行Hardhead测试，让我们现在一起测试所有东西。

9424
15:37:14.870 --> 15:37:16.760
一切都在流逝。

9425
15:37:16.760 --> 15:37:18.192
哦，这太棒了。

9426
15:37:18.192 --> 15:37:18.613
太棒了。

9427
15:37:18.613 --> 15:37:19.665
让我们继续。

9428
15:37:19.665 --> 15:37:26.998
如果我们进行Hardhead的报道，我们会看到我们的覆盖率在上升，我们已经比以前好了很多。

9429
15:37:26.998 --> 15:37:31.294
让我们继续，让我们继续测试我们的检查维护现在。

9430
15:37:31.294 --> 15:37:33.164
我们会做描述，检查和维护。

9431
15:37:33.164 --> 15:37:41.527
这是一个async函数，它会返回false。

9432
15:37:41.527 --> 15:37:49.447
如果有人收到E, E，这是一个同步功能。

9433
15:37:49.562 --> 15:37:54.831
我们让这里的一切都为真除了还没有人进入这个事实。

9434
15:37:54.831 --> 15:38:06.404
我们做一个权值网络。提供者。发送EVM增加时间，逗号间隔。

9435
15:38:06.404 --> 15:38:17.021
对number + 1会做一个权重网络。

9436
15:38:17.021 --> 15:38:19.824
发送UVM地雷。

9437
15:38:19.824 --> 15:38:21.728
没有参数。

9438
15:38:21.728 --> 15:38:26.044
现在我们调用check maintenance。

9439
15:38:26.044 --> 15:38:28.953
事情是这样的，对了。

9440
15:38:28.953 --> 15:38:31.387
维护是一项公共职能。

9441
15:38:31.562 --> 15:38:45.212
如果我们运行await, raffle。check upkeep，然后什么都不传递进来这就会启动一个事务，因为hard had知道，这是一个公共函数，显然他们想在这里发送一个事务。

9442
15:38:45.212 --> 15:38:48.847
如果这是公共视图函数，它不会，它会返回那个视图。

9443
15:38:48.847 --> 15:38:51.812
但问题是，我并不想发送事务。

9444
15:38:51.812 --> 15:38:57.862
但是我想模拟发送这个事务，看看这个维护需要返回什么。

9445
15:38:57.862 --> 15:39:05.847
我可以通过调用static来得到它，我可以模拟调用这个事务，看它会做出什么响应。

9446
15:39:05.847 --> 15:39:12.514
所以我可以用raffle。check maintenance，来代替raffle。cost static，也就是check maintenance。

9447
15:39:12.514 --> 15:39:37.644
这将给我返回的upkeep needed和字节执行数据，我可以从这个返回中推断出需要的upkeep或者写const upkeep needed等于这个，然后我可以断言not upkeep needed，因为现在upkeep needed返回false。

9448
15:39:37.644 --> 15:39:40.696
我们会说assert，而不是false，这是true。

9449
15:39:40.696 --> 15:39:43.337
如果维护需要是真的，那么这将是假的。

9450
15:39:43.337 --> 15:39:44.014
这个会断裂。

9451
15:39:44.014 --> 15:39:45.444
这就是我们要做的。

9452
15:39:45.444 --> 15:39:49.143
让我们继续，我们运行这个，看看它是否有效。

9453
15:39:49.143 --> 15:39:51.949
我们的帽子测试，dash dash grep。

9454
15:39:51.949 --> 15:39:56.038
我们只是顺带而过，我们在做生意。

9455
15:39:56.038 --> 15:39:56.824
太棒了。

9456
15:39:56.824 --> 15:39:59.676
所以这是完美的。

9457
15:39:59.676 --> 15:40:05.511
我们还要测试它是否返回false。

9458
15:40:05.511 --> 15:40:07.963
如果没有抽奖。

9459
15:40:07.963 --> 15:40:11.063
这将是一个异步函数。

9460
15:40:11.063 --> 15:40:15.013
我们会做所有的事情除了我们会在这里做所有的事情。

9461
15:40:15.013 --> 15:40:18.828
但是我们会在计算状态下抽奖。

9462
15:40:18.828 --> 15:40:34.251
做一个weight, raffle。enter, raffle value, raffle入口费等待network。provider，发送我复制这两行。

9463
15:40:34.251 --> 15:40:36.464
因为我们会继续做这些。

9464
15:40:36.563 --> 15:40:42.086
我们还会做一个重量，抽奖，并执行维护。

9465
15:40:42.563 --> 15:40:52.841
另一种发送空白字节对象的方法是像0x这样的字符串hardhat很聪明，知道这应该被转换成一个空白字节对象。

9466
15:40:52.841 --> 15:40:54.804
所以这两个都可以。

9467
15:40:54.804 --> 15:41:02.460
现在我们做const, raffle state = await, raffle。get raffle state然后我们会get upkeep needed。

9468
15:41:02.460 --> 15:41:03.770
所以我们用const。

9469
15:41:03.770 --> 15:41:12.055
维护需要，我们将做我们上面做的抽奖点调用静态点检查维护。

9470
15:41:12.055 --> 15:41:16.399
我们说一个权重，raffle点叫静态。

9471
15:41:16.564 --> 15:41:23.979
现在我们可以断言。equal，说抽奖状态是。不好意思，是抽奖状态。

9472
15:41:23.979 --> 15:41:31.960
to string，它会计算，我开始。equal upkeep needed，它会是假的。

9473
15:41:31.960 --> 15:41:35.134
我们来做个GREP。

9474
15:41:35.134 --> 15:41:36.657
和完善。

9475
15:41:36.657 --> 15:41:39.443
它也能正常工作。

9476
15:41:39.443 --> 15:41:39.753
太好了。

9477
15:41:39.753 --> 15:41:44.985
现在我将跳过接下来的两个测试，因为我们没有从它们中学到任何东西。

9478
15:41:44.985 --> 15:41:50.318
我将从GitHub复制粘贴它们，如果时间不够，我们将返回false。

9479
15:41:50.318 --> 15:41:52.241
我们会返回true。

9480
15:41:52.241 --> 15:41:56.150
如果足够的时间过去了，我们就有了玩家Eve，并且是开放的。

9481
15:41:56.150 --> 15:41:58.697
所以我们在下面断言为真。

9482
15:41:58.697 --> 15:42:14.286
我们开始的时候在这里不为真，你想暂停视频复制粘贴这些，把它们写出来，你完全可以从GitHub回购中复制粘贴它们，你绝对不能像我说的那样，通过这些，让自己写这些，让自己理解这些测试会让你成为一个更好的程序员。

9483
15:42:14.286 --> 15:42:17.964
让我们用hh test测试一下是否一切正常。

9484
15:42:17.964 --> 15:42:29.827
现在，当我在记录这个的时候，我意识到对于我们所有的描述块，我一直在让它们异步函数描述块实际上不能实现，不能识别，不能与承诺工作。

9485
15:42:29.827 --> 15:42:32.483
使用be async实际上什么都做不了。

9486
15:42:32.483 --> 15:42:37.717
在描述块中，我们要去掉async字因为它对我们一点帮助都没有。

9487
15:42:37.717 --> 15:42:40.828
事实上，这只是一个多余的词，看起来有点恶心。

9488
15:42:40.828 --> 15:42:46.371
现在我们所有的描述块，我们会去掉async关键字，只让它们是函数。

9489
15:42:46.371 --> 15:42:51.707
当然，我们所有的。会使用异步函数，这是我们想要的。

9490
15:42:51.707 --> 15:42:54.498
所以我们写了一些测试以备体检。

9491
15:42:54.498 --> 15:42:56.565
现在让我们继续执行维护。

9492
15:42:56.565 --> 15:43:01.965
让我们创建一个新的描述、阻塞、归属或执行维护。

9493
15:43:01.965 --> 15:43:04.565
这是一个常规函数。

9494
15:43:04.565 --> 15:43:10.823
在这里，我们开始说它只能在check维护为真时运行。

9495
15:43:10.823 --> 15:43:13.081
这将是一个async函数。

9496
15:43:13.081 --> 15:43:18.289
因为我们只希望在检查keep确实为真时执行keep to work。

9497
15:43:18.289 --> 15:43:20.734
我们写入await raffle。enter。

9498
15:43:20.734 --> 15:43:28.676
我们会给它一些价值，抽奖门票，对不起，应该用花括号代替。

9499
15:43:28.676 --> 15:43:38.740
我们将做一个权重网络点提供程序发送EVM增加时间间隔。

9500
15:43:38.740 --> 15:43:57.790
到number + 1 await network。provider发送UVM mine一个空数组的原因是我们要将时间向前移动并将块向前移动，当然这和上面是一样的，我们希望check upkeep返回true。

9501
15:43:57.790 --> 15:44:05.211
然后我们会说const X或transaction = await rafel。performupkeep。

9502
15:44:05.211 --> 15:44:11.940
我们可以用空数组，也可以用0x。

9503
15:44:11.940 --> 15:44:13.440
我们可以断言X。

9504
15:44:13.440 --> 15:44:18.168
如果TX不工作，或者这个错误出现了，这个就会失败。

9505
15:44:18.168 --> 15:44:18.549
正确的。

9506
15:44:18.549 --> 15:44:21.232
这就是为什么我们知道这是可行的。

9507
15:44:21.232 --> 15:44:22.327
我们来测试一下。

9508
15:44:22.327 --> 15:44:25.973
我们希望这只在checkup keep为真时工作。

9509
15:44:25.973 --> 15:44:30.303
我们用上面的方法让检查保持正确。

9510
15:44:30.303 --> 15:44:35.923
现在我们用IT块做纱线硬帽测试。

9511
15:44:35.923 --> 15:44:40.387
我把perform upkeep拼错了。

9512
15:44:40.566 --> 15:44:42.475
让我们试着拼写正确。

9513
15:44:43.566 --> 15:44:44.221
再次测试。

9514
15:44:44.221 --> 15:44:44.876
和伟大的。

9515
15:44:44.876 --> 15:44:45.859
这是工作。

9516
15:44:47.566 --> 15:44:51.058
想做什么?我们希望它恢复与拉斐尔。

9517
15:44:52.566 --> 15:44:54.441
如果checkup keep为false。

9518
15:44:57.566 --> 15:45:00.266
当检查keep为假。

9519
15:45:03.566 --> 15:45:14.125
我们将使用相同的语法await expect raffle。execute upkeep empty bytes object that to。

9520
15:45:14.125 --> 15:45:16.294
被还原为。

9521
15:45:16.566 --> 15:45:27.316
我们想让它还原成什么呢?或者希望它与这个和那个恢复，我们可以在这里运行这个测试Hardhead测试dash dash grep粘贴进去。

9522
15:45:27.316 --> 15:45:36.166
我们看到它确实在传递你会注意到这里我们的revert会继续进行并将所有这些额外的东西都进行了还原。

9523
15:45:36.166 --> 15:45:43.652
我们的测试足够聪明，它知道如果我们所做的只是放入要返回的错误的名称，那么它就足够好了。

9524
15:45:43.652 --> 15:45:51.193
如果我们想要特别具体，我们可以继续把它变成一个字符串插值然后把所有这些都加进去。

9525
15:45:51.193 --> 15:45:55.766
所以我们可以增加我们期望的平衡我们可以增加我们期望的球员。

9526
15:45:55.766 --> 15:46:07.397
我们现在可以添加raffle语句我们将保持它和我们预期的一样但如果你想要非常具体你可以让你的测试期望得到你想要的确切的具体值。

9527
15:46:07.397 --> 15:46:15.300
好吧，我们最不应该期待的是什么?我们应该检查一下这个是否被称为抽奖状态被改变了。

9528
15:46:15.300 --> 15:46:16.963
我们承认这个事件。

9529
15:46:16.963 --> 15:46:19.423
我们把它加起来。

9530
15:46:19.423 --> 15:46:32.154
我们会说它更新抽奖状态，承认一个事件，并调用VRF协调器作为一个异步函数。

9531
15:46:32.154 --> 15:46:33.042
让我们开始吧。

9532
15:46:33.042 --> 15:46:40.698
让checkup keep为真，复制粘贴前三行，因为它们是完全一样的。

9533
15:46:40.698 --> 15:46:46.124
我们将进入抽奖我们将增加时间我们将关注一个新区块，然后我们将调用执行维护。

9534
15:46:46.124 --> 15:47:05.027
我们会说const, TX response = await raffle。performupkeep with一个空字节对象，我们会说const TX receipt = await TX response。wait for一个block。

9535
15:47:05.027 --> 15:47:14.400
从这个收据，我们会得到请求ID，我们会说const请求ID等于，我们能得到请求ID。

9536
15:47:14.400 --> 15:47:16.400
从这个省略的事件。

9537
15:47:16.400 --> 15:47:31.685
然而，我们应该再次查看VRF协调器模拟，当我们在模拟中调用请求随机单词时，然后在实际的契约中调用，您将注意到它还发出一个请求随机单词的事件。

9538
15:47:31.685 --> 15:47:37.277
看这里，第二个参数确实是请求ID。

9539
15:47:37.277 --> 15:47:47.968
所以在现实中，US省略请求ID是多余的，我们可以只使用VRF协调器中允许的请求ID，这是本课程的目的，并向您展示一个事件是什么样子的。

9540
15:47:47.968 --> 15:47:49.223
我们把它放在那里。

9541
15:47:49.223 --> 15:47:53.968
但如果你想回去重构这个，你肯定会想删除这个省略。

9542
15:47:53.968 --> 15:47:57.171
但是对于这个测试，让我们做TX收据点事件。

9543
15:47:57.171 --> 15:48:06.955
这将是第一个事件而不是0 with event因为在这个事件被触发之前，这个函数将会触发一个事件。

9544
15:48:06.955 --> 15:48:11.500
这不是带事件的0，这是这个之后触发的第一个事件。

9545
15:48:11.500 --> 15:48:20.027
税单。events。one。args。request, ID，然后我们会说，cert request ID。

9546
15:48:20.027 --> 15:48:22.977
To number大于0。

9547
15:48:22.977 --> 15:48:28.948
然后我们还会断言抽奖状态等于等于1。

9548
15:48:28.948 --> 15:48:36.515
我们将使用const, raffle state = await, raffle。get raffle state。

9549
15:48:36.515 --> 15:48:39.822
这应该是抽奖状态。

9550
15:48:39.822 --> 15:48:43.805
到Number，或者到string，然后你知道，做任何我们想做的。

9551
15:48:43.805 --> 15:48:48.318
这是一个很大的函数，但我们还是要复制整个式子。

9552
15:48:48.318 --> 15:48:52.786
HH test，破折号grep，粘贴到这里，我们运行它，不好意思。

9553
15:48:52.786 --> 15:49:03.245
to string = = 1，转换时间和完美，我们正在通过很好，现在是时候实现随机单词了。

9554
15:49:03.245 --> 15:49:06.771
我们将在这里学到很多奇妙的东西。

9555
15:49:06.771 --> 15:49:11.093
我们要创建一个新的描述块把这里缩小一点。

9556
15:49:11.093 --> 15:49:16.039
这就是我们要完成的随机单词。

9557
15:49:16.039 --> 15:49:19.718
当然，这是一个函数。

9558
15:49:19.718 --> 15:49:27.142
在这里，在我们进行任何测试之前我们实际上会在每个想要参与抽奖的人之前添加另一个。

9559
15:49:27.142 --> 15:49:32.045
我们会在每个之前做一个a，这将是一个async。

9560
15:49:32.045 --> 15:49:32.902
函数。

9561
15:49:32.902 --> 15:49:43.362
我们要运行await, raffle那个进入raffle带有raffle入场费的值。

9562
15:49:43.362 --> 15:50:04.500
然后我们要做一个等待网络。提供者。发送EVM增加时间间隔，到number + 1，然后一个等待网络。提供者。发送EVM mine。

9563
15:50:04.500 --> 15:50:05.327
逗号。

9564
15:50:05.327 --> 15:50:10.762
在我们尝试对随机单词做任何测试或满足之前，我们会让一些人进入抽奖。

9565
15:50:10.762 --> 15:50:14.235
我们将增加时间，挖出一个新的区块。

9566
15:50:14.235 --> 15:50:14.968
好的,很酷。

9567
15:50:14.968 --> 15:50:27.095
我们要做的第一件事是看看满足随机词只能被调用只要有一个请求在运行，只要有一个请求只要请求随机词被调用。

9568
15:50:27.095 --> 15:50:32.189
我们可以通过运行来检查它只能在执行之后被调用。

9569
15:50:32.189 --> 15:50:35.093
这将是一个异步函数。

9570
15:50:35.093 --> 15:50:40.117
在这里，我们会回复一些不存在的请求。

9571
15:50:40.117 --> 15:50:49.388
所以我们将做等待，期望射频核心没有一个巡回是模拟点实现随机词。

9572
15:50:49.388 --> 15:51:06.523
如果我们看我们的V RF，协调器v2 Mark在这里有实现随机单词函数，这是链链接节点实际调用的在实际契约中添加这个函数调用另一个契约来进行随机数验证。

9573
15:51:06.570 --> 15:51:08.820
我们基本上是在检查这部分。

9574
15:51:09.570 --> 15:51:13.796
不存在，我们会得到这个不存在的请求。

9575
15:51:13.796 --> 15:51:17.570
如您所见，它需要一个请求ID和一个使用者地址。

9576
15:51:17.570 --> 15:51:19.382
所以我们要猜0。

9577
15:51:19.382 --> 15:51:32.007
消费者地址，当然，它会在address被抽抽，我们会期望这个被还原，不存在请求。

9578
15:51:32.007 --> 15:51:38.103
然后我们会用不同的Request ID或Request ID 1做同样的事情。

9579
15:51:38.103 --> 15:51:41.659
希望我们也能得到不存在的请求。

9580
15:51:41.659 --> 15:51:46.021
理想情况下，这里的任何请求都不会允许这个满足的随机单词通过。

9581
15:51:46.021 --> 15:51:57.553
很明显，要测试每一个可能的Request ID是很困难的，我们将在未来看到一种方法，通过模糊测试来测试大量的这些变量。

9582
15:51:57.553 --> 15:51:58.880
我们以后会讲到这个。

9583
15:51:58.880 --> 15:52:07.370
我把scribe拼错了，让我们把scribe拼对，继续运行这个hh test dash grep。

9584
15:52:07.570 --> 15:52:09.438
它很好地过去了。

9585
15:52:13.570 --> 15:52:15.699
给你，那就太大了。

9586
15:52:17.570 --> 15:52:19.784
我们将要写的是这将是一个非常大的考验。

9587
15:52:19.784 --> 15:52:26.383
我们可能想把它分成不同的部分，但实际上这是最好的方式来展示这个部分。

9588
15:52:26.383 --> 15:52:28.379
这正是我们要做的。

9589
15:52:28.379 --> 15:52:33.355
当我们开始进行阶段测试时，我们将把这个测试写得几乎完全相同。

9590
15:52:33.355 --> 15:52:38.951
让我们写下来，这基本上是一个把所有东西放在一起的测试。

9591
15:52:38.951 --> 15:52:52.248
我们将测试这一点，赢家重置彩票，并送钱，这对一个人来说有点多，我们可能会想把这些分成他们自己的部分。

9592
15:52:52.248 --> 15:52:56.122
但对于这个，我们会把它们都放到一个里面，这将是一个async函数。

9593
15:52:56.122 --> 15:52:59.764
现在我们要学习一些新技巧。

9594
15:52:59.764 --> 15:53:01.602
所以一定要按照我说的去做。

9595
15:53:01.602 --> 15:53:07.465
现在对于这个，我们也要加入一些额外的入口额外的进入抽签的人。

9596
15:53:07.465 --> 15:53:12.191
我们写入const, extra, trance = great。

9597
15:53:12.191 --> 15:53:17.523
我们会让更多来自以太的假账户进入我们的抽奖。

9598
15:53:17.571 --> 15:53:20.142
我们会说const。

9599
15:53:23.571 --> 15:53:31.333
因为部署者等于0，不好意思是等于1，因为玩家是0，所以我们会有新账户从索引1开始。

9600
15:53:31.333 --> 15:53:52.461
我们要做一个for循环或者让i等于起始计数index, i小于起始计数index，加上附加趋势看到，会有入口。

9601
15:53:52.571 --> 15:53:58.452
I + +，我们要做一个小循环把我们的抽奖合同和这些新账户联系起来。

9602
15:53:58.452 --> 15:54:04.771
然后我们会有这些新客户，参加抽奖比赛。

9603
15:54:04.771 --> 15:54:15.834
计数，连接抽签等于。连接i的账户我们是否在其他地方定义了账户。

9604
15:54:15.834 --> 15:54:18.334
我们去找个地方记账吧。

9605
15:54:18.334 --> 15:54:22.503
我们写入const accounts = await ethers。get signed。

9606
15:54:22.503 --> 15:54:29.201
然后我们要做一个权重账户连接抽签。回车。

9607
15:54:29.201 --> 15:54:37.965
抽奖与价值当然抽奖入场费，我们将连接三个额外的入口到我们的抽奖。

9608
15:54:37.965 --> 15:54:42.105
我们总共有四个人参与抽奖。

9609
15:54:42.105 --> 15:54:46.238
现在我们已经在这里有了它们，我们将记录我们的起始时间戳。

9610
15:54:46.238 --> 15:54:54.877
我们写入const starting timestamp = await, raffle。get last timestamp。

9611
15:54:54.877 --> 15:54:56.959
这里我们会有一点棘手。

9612
15:54:56.959 --> 15:55:11.944
我们想要做的是我们想要执行一些事情我们想要执行upkeep，它将模仿链链守护者，它将启动链链，它将启动调用fulfillment random words。

9613
15:55:11.944 --> 15:55:15.555
我们也会嘲笑这样做。

9614
15:55:15.555 --> 15:55:18.014
模拟链接VRF。

9615
15:55:18.014 --> 15:55:28.222
一旦我们这样做了，我们当然可以检查看看最近的赢家是否被记录了抽奖被重置了就像我们说的时间戳一样，一切都重置了。

9616
15:55:28.222 --> 15:55:30.460
但是我们想用一种特殊的方式来做。

9617
15:55:30.460 --> 15:55:38.887
如果我们在一个测试网络上做这个在我们调用完成随机单词之后，我们将不得不等待完成随机单词被调用。

9618
15:55:38.887 --> 15:55:48.782
既然我们是在硬帽本地连锁店工作，我们不需要等待任何东西，对吧因为我们可以说，好，砰，打响指，调整我们的区块链做任何我们想做的事。

9619
15:55:48.782 --> 15:55:53.402
但我们会模拟我们需要等待事件被调用。

9620
15:55:53.402 --> 15:55:59.510
因此，为了模拟等待该事件，我们再次需要设置一个侦听器。

9621
15:55:59.573 --> 15:56:08.233
如果我们建立一个监听器我们不希望它在监听器完成监听之前结束，所以我们需要再次创建一个新的承诺。

9622
15:56:08.233 --> 15:56:12.948
这将是非常重要的，特别是对于我们的分期测试。

9623
15:56:12.948 --> 15:56:15.477
我们来看看await, new promise。

9624
15:56:15.477 --> 15:56:25.081
这将和我们之前设置的完全一样，这将是一个async函数将resolve和reject作为参数。

9625
15:56:25.081 --> 15:56:39.228
我们会用这个小箭头语法说，这是一个async函数，我们会再次设置once语法，我们会说raffle once，事件名是什么，winner chosen。

9626
15:56:39.228 --> 15:56:46.508
我们会说，听，对于这个winner chosen事件，我们会说raffle。一旦winner chosen发生，做一些事情。

9627
15:56:46.573 --> 15:56:49.027
再说一次，这只是一个匿名函数。

9628
15:56:49.573 --> 15:56:53.376
我们说raffle。一旦winner chosen事件被触发，做一些事情。

9629
15:56:53.376 --> 15:56:55.425
我们把这个设置好了。

9630
15:56:55.425 --> 15:57:01.523
现在它在这个函数中，我们要把所有的cert加上因为我们想等冬天被选中。

9631
15:57:01.573 --> 15:57:08.001
在事件被触发之前，我们当然需要调用，执行，调用，fullrandomwords。

9632
15:57:08.001 --> 15:57:10.952
所以这看起来有点倒退。

9633
15:57:10.952 --> 15:57:21.003
但那是因为我们想要设置监听器当我们触发触发事件的方法时，监听器会被激活并等待它。

9634
15:57:21.003 --> 15:57:24.861
我们会把所有的代码都放在这个承诺里面。

9635
15:57:24.861 --> 15:57:32.823
现在，因为我们把它放在promise外面，我们把所有的代码放在promise外面，这个promise永远不会被解决，因为监听器永远不会触发到vent。

9636
15:57:32.823 --> 15:57:38.349
如果在下面这里，我们调用fullrandom words with something，你知道哪个拼写不好。

9637
15:57:38.349 --> 15:57:48.081
但假设我们调用下面这里，这段代码永远不会到达这个完全随机单词，因为它总是在等待这个想要被解析。

9638
15:57:48.081 --> 15:57:51.446
所以我们需要在承诺中添加所有的代码。

9639
15:57:51.574 --> 15:57:57.669
但是在这个抽奖点外面我们不想永远等下去，对吧?也许这里有问题。

9640
15:57:57.669 --> 15:58:01.113
如果有问题，我们希望能够拒绝它。

9641
15:58:01.113 --> 15:58:05.636
现在我们能做的是在我们的heart hat。config中，我们能添加一个超时。

9642
15:58:05.636 --> 15:58:24.328
我们可以添加这个mocha部分，我们可以给自己一个200,000毫秒的超时，也就是200秒，如果这个事件在200秒内没有被触发，这将被认为是失败，这个测试将失败，这是我们想要的。

9643
15:58:24.328 --> 15:58:31.639
我通常喜欢用try catch来表示因为如果失败了，就会引起一大堆头疼的catch E。

9644
15:58:31.639 --> 15:58:39.360
如果任何东西失败了，我们也会拒绝，我们调用一些函数是有问题的，我们会说，嘿，好，这是一个失败。

9645
15:58:39.360 --> 15:58:44.416
但如果失败了，我们的承诺就能及时得到解决，我们稍后会加入这段代码。

9646
15:58:44.416 --> 15:58:45.889
让我们继续。

9647
15:58:45.889 --> 15:58:47.081
让我们继续。

9648
15:58:47.081 --> 15:58:53.875
不好意思，trycatch应该在那些，在结果上面的那些，不好意思，因为这是监听器。

9649
15:58:53.875 --> 15:58:59.518
抱歉，我们希望trycatch在其中如果这花费太长时间，我们会抛出一个错误。

9650
15:58:59.574 --> 15:59:21.469
否则，我们会在监听器外部解析，但在promise内部，我们会在这里做这一点，我们会去const TX = await raffle。perform upkeep，我们会把空字节对象传递给它，我们会得到const TX receipt = await TX。一个block的权重。

9651
15:59:21.575 --> 15:59:40.717
然后我们会做一个权重VRF核心没有一个tour是mock。实现随机单词，CX收据。事件。args。请求ID来抽奖那个地址。

9652
15:59:40.717 --> 15:59:51.325
最后我们要做的是我们会让这个转向协调器变成mock我们会让它调用fullrandomwords，它接受请求ID和消费者地址。

9653
15:59:51.325 --> 15:59:57.763
我们会模拟它，给它从事务收据中获取的请求ID，还有这里的消费者地址。

9654
15:59:57.763 --> 16:00:02.075
在这个承诺中，我们为这个获胜者挑选的事件设置了一个监听器。

9655
16:00:02.075 --> 16:00:06.747
然后我们嘲笑通灵守护者然后我们嘲笑链链VRF。

9656
16:00:06.747 --> 16:00:13.195
一旦这个函数被调用这个函数就会发出一个winner chosen事件。

9657
16:00:13.195 --> 16:00:23.800
所以这个被设置的用来监听这个信号发射的抽奖会捡起来，然后说，好吧，我找到它了，我找到赢家选择事件了。

9658
16:00:23.800 --> 16:00:26.251
现在我们可以继续做一些事情了。

9659
16:00:26.251 --> 16:00:40.575
一旦winner chosen事件被触发，我们会做一个console。log像这样找到事件然后我们会跳转到我们的trycatch这个trycatch基本上就是我们在这里做所有这些断言。

9660
16:00:40.575 --> 16:00:58.196
首先我们要写const recent winner = await raffle。get recent winner我们要检查抽奖中的所有内容我们要检查最近的赢家抽奖状态被重置玩家被重置，等等等等。

9661
16:00:58.196 --> 16:01:08.242
所以我们说const raffle state = waitraffle。get raffle state我们说const。

9662
16:01:08.242 --> 16:01:14.440
结束时间戳等于等待，抽奖点获取最后的时间戳。

9663
16:01:14.440 --> 16:01:17.406
让我们开始做一些断言。

9664
16:01:17.576 --> 16:01:22.401
因此，首先我们应该断言这个es players数组已重置为零。

9665
16:01:22.401 --> 16:01:26.042
如果我们调用getnumber of players，它应该是0。

9666
16:01:26.042 --> 16:01:36.379
我们可以用const num players = await raffle。get number players，像这样。

9667
16:01:36.379 --> 16:01:41.576
我们可以断言。等于9个参与人。

9668
16:01:41.576 --> 16:01:43.992
到字符串将是零。

9669
16:01:43.992 --> 16:01:54.641
我们还能断言什么?我们可以断言。equal raffle状态应该是开放的。

9670
16:01:54.641 --> 16:01:56.477
抽奖状态。

9671
16:01:56.477 --> 16:02:06.350
string应该为0，我们应该断言结束时间戳现在大于开始时间戳。

9672
16:02:06.350 --> 16:02:10.176
因为最后的时间戳应该已经更新了。

9673
16:02:10.176 --> 16:02:13.050
我们还想确保我们最近的赢家是正确的。

9674
16:02:13.050 --> 16:02:15.965
我们用console。log recent winner。

9675
16:02:15.965 --> 16:02:18.769
现在我们可以转到VRF协调器模拟。

9676
16:02:18.769 --> 16:02:23.805
我们可以模拟这个过程并试着找出随机的赢家是谁来控制。记录帐户。

9677
16:02:23.805 --> 16:02:37.524
然后我们来展示一些，我们用01和3来做raffle。once这需要是一个async函数，而不仅仅是一个普通函数。

9678
16:02:37.524 --> 16:02:42.305
让我们再试一次，get latest timestamp是正确的函数。

9679
16:02:42.305 --> 16:02:44.661
让我们用正确的最新更新这个。

9680
16:02:44.661 --> 16:02:46.119
把latest写在这里。

9681
16:02:46.119 --> 16:02:48.763
因为我拼写错了。

9682
16:02:48.763 --> 16:02:53.842
看起来好像我们还没初始化就打印出了最近的赢家。

9683
16:02:53.842 --> 16:02:54.779
我们把它上移。

9684
16:02:54.779 --> 16:02:57.992
然后我们写console。log recent winner。

9685
16:02:57.992 --> 16:03:00.860
我知道这是一个巨大的考验。

9686
16:03:00.860 --> 16:03:05.243
让我们试一试，看看是否一切都符合我们的要求。

9687
16:03:05.243 --> 16:03:08.993
这里的速度在放缓，这是好事，因为我们正在做很多事情。

9688
16:03:08.993 --> 16:03:13.764
啊哈，我们终于把这个过去的东西拿出来了。

9689
16:03:13.764 --> 16:03:19.441
我们做了很多console。logging这里有很多签名者的东西被打印出来。

9690
16:03:19.441 --> 16:03:21.814
让我们把它写得容易一点。

9691
16:03:21.814 --> 16:03:26.545
我们把。address加到所有这些，我们就知道谁是赢家了。

9692
16:03:26.545 --> 16:03:30.827
看起来赢家是一号账户，这很好。

9693
16:03:30.827 --> 16:03:40.249
我们现在能做的是，我们知道1号帐户将是赢家，我们可以让赢家的初始余额在调用complederrandom words之前一直到这里。

9694
16:03:40.249 --> 16:03:52.139
我们写入const winner，初始余额= await accounts 1。get balance，你可以像这样调用get balance。

9695
16:03:52.139 --> 16:04:04.529
现在我们在测试中有了winner的初始余额，我们可以说const winner，结束余额= await ounce one。get balance。

9696
16:04:04.529 --> 16:04:09.512
我们可以确保获胜者得到他们需要的报酬。

9697
16:04:09.512 --> 16:04:15.105
现在我们要做一个关于钱的断言，相信我，这就是数学运算。

9698
16:04:15.105 --> 16:04:19.744
我们要做断言。equal winner balance。

9699
16:04:19.744 --> 16:04:24.448
到弦，对不起冬天结束平衡。

9700
16:04:24.448 --> 16:04:43.501
到字符串应该等于赢家的起始余额点加上抽奖入场费乘以额外的恍惚加上我们支付的抽奖入场费。

9701
16:04:43.501 --> 16:04:44.193
字符串。

9702
16:04:44.193 --> 16:04:53.328
这个计算基本上是说，赢家最终应该得到所有其他人加到合同中的钱的余额。

9703
16:04:53.328 --> 16:04:54.188
就是这样。

9704
16:04:54.188 --> 16:04:56.764
所以我们可以再做一次测试。

9705
16:04:56.764 --> 16:04:58.509
天啊，该死的，它通过了。

9706
16:04:58.509 --> 16:05:00.474
这里有很多代码。

9707
16:05:00.578 --> 16:05:06.028
这可能是整个课程中最难的部分之一就是这部分。

9708
16:05:06.028 --> 16:05:08.778
所以如果你在这个问题上有一点挣扎，不要让它使你陷入困境。

9709
16:05:08.778 --> 16:05:16.110
这可能是这门课比较难的部分之一，让我们快速复习一下我们正在做的这个测试。

9710
16:05:16.110 --> 16:05:18.335
当我们做的时候，我们会看到一个动作。

9711
16:05:18.335 --> 16:05:19.316
在我们的分期测试中。

9712
16:05:19.316 --> 16:05:22.806
我们所做的就是选出一个中奖者重新设置彩票，然后给钱。

9713
16:05:22.806 --> 16:05:29.734
基本上，我们所做的就是测试这个完成随机单词的东西是否达到了我们的要求随机赢家胜出，他们得到了钱。

9714
16:05:29.734 --> 16:05:34.178
我们要怎么做呢?首先，我们让一群随机的人参加抽奖。

9715
16:05:34.178 --> 16:05:34.478
太好了。

9716
16:05:34.578 --> 16:05:35.349
听起来不错。

9717
16:05:38.578 --> 16:05:44.205
执行维护并实现随机单词时，我们希望假装抽取了随机数。

9718
16:05:44.205 --> 16:05:52.807
这就是下面这段代码的作用它调用那个随机数但是我们可以做的是我们可以有所有这些断言并检查所有的变量。

9719
16:05:52.807 --> 16:05:54.036
在我们做完这个之后。

9720
16:05:54.036 --> 16:05:56.020
我们完全可以这么做。

9721
16:05:56.020 --> 16:06:01.527
然而，在一个测试网络上，我们并不总是确切地知道一个事务将在何时结束。

9722
16:06:01.579 --> 16:06:11.712
我们必须等待如果我们必须监听一个事件被触发，在这之前，我们可以调用事务来结束整个事情，我们需要设置一些东西来监听那个事件被触发。

9723
16:06:11.712 --> 16:06:25.340
我们说，只有当这个事件被触发时只有当这个事务被调用时，我们才能对本地网络进行测试，我们模仿VRF协调器，我们有控制，我们知道它什么时候运行。

9724
16:06:25.340 --> 16:06:27.117
但在一个测试网上，我们没有。

9725
16:06:27.117 --> 16:06:30.688
所以你会在我们的阶段性测试中看到，我们这里不会有任何这些。

9726
16:06:30.688 --> 16:06:39.507
我们必须要建立一个监听器来监听通灵的VRF和守卫者来触发他们的事件。

9727
16:06:39.507 --> 16:06:44.579
这就是为什么分期测试是如此重要，以确保我们做的每件事都是正确的。

9728
16:06:44.579 --> 16:06:52.429
这就是为什么我们要设置这样的本地测试，这样它就能模拟我们在语句测试中要做的事情也就是我们在真实网络中要做的事情。

9729
16:06:52.429 --> 16:07:03.511
再一次，我们设置了这个监听器我们说，啊，一旦我们在这里做了这个事件，然后我们会试着检查所有的余额并检查一切都按照预期运行。

9730
16:07:03.511 --> 16:07:05.872
如果我们看不到它，我们就会拒绝。

9731
16:07:05.872 --> 16:07:11.382
如果有一个超时，如果时间超过200秒，我们会说，好，出错了，我们会取消它。

9732
16:07:11.382 --> 16:07:16.398
实际上，我要把时间增加到300秒，因为我觉得200秒不够用。

9733
16:07:16.398 --> 16:07:21.445
根据冰场B测试的速度，你可能要把它放大。

9734
16:07:21.445 --> 16:07:24.911
记住这一点。

9735
16:07:24.911 --> 16:07:29.293
我们刚刚做了一些很棒的测试。

9736
16:07:29.293 --> 16:07:36.483
让我们继续，让我们运行h h测试，看看是否所有的测试都能通过。

9737
16:07:36.579 --> 16:07:41.380
好的，14个传球，所有的都传球了，我们看起来很好。

9738
16:07:41.580 --> 16:07:42.929
这太棒了。

9739
16:07:46.580 --> 16:07:49.338
让我们继续创建一个分段测试。

9740
16:07:50.580 --> 16:07:54.644
看起来和我们刚才在下面创建的大型测试非常相似。

9741
16:07:54.644 --> 16:08:05.808
我们设置单元测试的原因是用抽奖点来做权重承诺因为这实际上是我们需要在测试网或主网上等待赢家被选中的方式。

9742
16:08:05.808 --> 16:08:11.225
我们不能在一个真实的测试网中，假装是链链V REF，我们可以假装是链链管理员，如果我们想的话。

9743
16:08:11.225 --> 16:08:14.924
但我们不能确保这10个看守人真的在工作。

9744
16:08:14.924 --> 16:08:24.313
但我们这样做是因为我们想要监听事件被触发，我们想要监听链接VRF对获胜者作出响应。

9745
16:08:24.313 --> 16:08:26.354
让我们创建一个阶段性测试。

9746
16:08:26.354 --> 16:08:30.849
这个测试我们将在一个真实的测试网上进行。

9747
16:08:30.849 --> 16:08:40.301
好，我们要创建一个新的测试叫做raffle。staging。test。Jas这是我们要进行分期测试的地方。

9748
16:08:40.301 --> 16:08:46.630
现在我们可以很快地编写这个代码因为我们的大部分阶段性测试看起来和我们的抽奖测试非常相似。

9749
16:08:46.630 --> 16:08:51.783
现在，我们只看第一部分，然后根据需要进行调整。

9750
16:08:51.783 --> 16:08:53.206
然后我们把它关闭。

9751
16:08:53.206 --> 16:09:00.235
因为我们肯定需要抽奖，我们不需要VRF协调器模拟因为我们不会使用模拟。

9752
16:09:00.235 --> 16:09:06.037
因为我们在一个真实的测试网上，我们需要抽奖入场费，我们需要部署者，我们需要部署者。

9753
16:09:06.037 --> 16:09:07.416
我们可能需要这个区间。

9754
16:09:07.416 --> 16:09:10.264
先把它删掉吧我们可能不需要chain ID了。

9755
16:09:10.264 --> 16:09:11.776
把这个也删掉。

9756
16:09:11.776 --> 16:09:12.169
太棒了。

9757
16:09:12.169 --> 16:09:18.665
我们要记住的一点是，当涉及到阶段性测试时，我们只希望在进行测试时运行蒸汽测试。

9758
16:09:18.665 --> 16:09:27.023
我们不需要运行我们的单元测试因为我们的单元测试不会检查与测试网的兼容性，我们希望我们的单元测试只在本地网络上运行。

9759
16:09:27.023 --> 16:09:30.597
我们希望我们的分期测试只在测试网络上运行。

9760
16:09:30.597 --> 16:09:35.331
在我们的测试中，我们要检查我们用的是哪种链。

9761
16:09:35.331 --> 16:09:38.781
哎呀，看起来我已经在这里导入了开发更改。

9762
16:09:38.781 --> 16:09:44.530
所以我们实际上在进行分期测试，在我们运行任何测试之前，我们要检查我们所使用的网络是什么样的。

9763
16:09:44.581 --> 16:10:01.886
我们会说，如果我们的开发链包含network。name，我们会说如果我们的开发链包含network to name，那么如果我们所处的链在开发链中，同样，我们会使用这个三元运算符，如果我们在开发链中，做些什么。

9764
16:10:01.886 --> 16:10:04.269
如果我们不在开发链上，那就做点别的。

9765
16:10:04.269 --> 16:10:12.269
如果我们在开发链上，我们要做什么?我们想跳过这个我们可以通过输入description。skip跳过这个。

9766
16:10:12.269 --> 16:10:14.750
这将跳过这一整部分。

9767
16:10:14.750 --> 16:10:19.744
然后我们可以说，如果我们是开发链，继续做我们的事情。

9768
16:10:19.744 --> 16:10:25.181
这是很好的语法它允许我们在本地网络上跳过分段测试。

9769
16:10:25.181 --> 16:10:34.981
另外，我们可以抓取这个语法，进入我们的raffle。test。j s里面有单元测试然后添加bang运算符，也就是knot，然后点击保存。

9770
16:10:34.981 --> 16:10:41.831
现在我们说，如果我们不在开发链上，跳过它，只在我们不在开发链上时运行这个。

9771
16:10:41.831 --> 16:10:44.481
这就是说只能在测试网或主网上运行。

9772
16:10:44.581 --> 16:10:46.924
这个只在本地网络上运行。

9773
16:10:46.924 --> 16:10:47.205
太好了。

9774
16:10:47.581 --> 16:10:49.665
有一个我们需要的部署人员。

9775
16:10:50.581 --> 16:10:57.387
需要部署任何fixture，因为我们将运行部署脚本，而契约应该已经部署好了。

9776
16:10:57.387 --> 16:11:04.361
我们将需要抽奖，我们不需要VRF协调模拟，我们可以删除，我们将需要门票费用，我们可能不需要间隔。

9777
16:11:04.361 --> 16:11:05.734
我们可以把这个也删掉。

9778
16:11:05.734 --> 16:11:06.598
好的,太棒了。

9779
16:11:06.598 --> 16:11:10.349
我们有了描述，我们有了之前，让我们做测试。

9780
16:11:10.349 --> 16:11:15.259
我要做一个巨大的测试从头到尾测试所有东西。

9781
16:11:15.259 --> 16:11:23.828
如果你想的话，你可以在以后自己添加更多的测试我们的阶段性测试和我们在下面做的大规模测试非常相似。

9782
16:11:23.828 --> 16:11:26.891
实际上，我们将使用这里的大部分代码作为我们的样板。

9783
16:11:26.891 --> 16:11:28.133
我们来创建一个描述。

9784
16:11:28.133 --> 16:11:34.132
我们会说，我们实际上只是复制这个描述四个随机单词并粘贴到这里。

9785
16:11:34.132 --> 16:11:38.323
因为我们将在这里的分段测试中使用很多相同的代码。

9786
16:11:38.323 --> 16:11:38.903
太好了。

9787
16:11:38.903 --> 16:11:50.300
所以现在我们说它适用于活的链链保持器和链链VRF，我们得到一个随机赢家，ace函数。

9788
16:11:50.300 --> 16:11:53.425
这就是我们的测试。

9789
16:11:53.582 --> 16:11:57.264
在这个测试中，我们当然要参加抽奖。

9790
16:11:57.582 --> 16:12:01.788
除了参加抽奖，我们什么都不用做。

9791
16:12:01.788 --> 16:12:11.970
因为链，管理员和唯一的VRF将为我们真正开启这个抽奖，我们将快速抓取开始时间戳，在所有这一切开始之前拥有它。

9792
16:12:11.970 --> 16:12:37.277
因此我们写入const starting timestamp = await raffle。get last to me get最新时间戳，get最新时间戳，我们将获取这个因为稍后，我们将测试时间戳是否真的向前移动，我们想进入抽奖，我们想运行我们一直在这里运行的命令，我们想做await raffle。enter raffle，但我们还不想调用它。

9793
16:12:37.277 --> 16:12:42.430
因为和这里一样，我们想先设置监听器。

9794
16:12:42.430 --> 16:12:46.963
在这里，我们可能应该在进入抽奖之前设置好监听器。

9795
16:12:46.963 --> 16:12:49.375
然而，我们控制了区块链。

9796
16:12:49.375 --> 16:12:52.260
所以按这个顺序是可以的。

9797
16:12:52.260 --> 16:12:59.123
但我们想在进入抽奖之前设置监听器以防区块链移动得非常快。

9798
16:12:59.123 --> 16:13:03.549
我们会用完全相同的方式设置监听器，我们在这里做过。

9799
16:13:03.549 --> 16:13:05.933
我们会说，等待新承诺。

9800
16:13:05.933 --> 16:13:09.599
这将是一个接受解析和拒绝的异步函数。

9801
16:13:09.599 --> 16:13:12.318
我们在这里用一个小箭头符号。

9802
16:13:12.318 --> 16:13:24.310
在这里，我们会设置监听器，我们会说raffle。once，一旦胜者被选中，我们会用那个Arrow来做另一个async函数。

9803
16:13:24.583 --> 16:13:31.812
箭头函数语法，我们写入console。log winner chosen the event fired。

9804
16:13:31.812 --> 16:13:43.916
只有当我们选中了这个赢家，我们才能在这里进行断言，我们才能确保有一个赢家，有一个可验证的随机赢家，它被选中了，钱被转移了，等等。

9805
16:13:43.916 --> 16:13:45.852
我们就在这里尝试接球。

9806
16:13:45.852 --> 16:13:52.333
如果有任何错误，我们会自动拒绝，我们会拒绝承诺。

9807
16:13:52.333 --> 16:13:56.828
如果一切顺利，当然，我们会解决这个承诺。

9808
16:13:56.828 --> 16:13:58.126
我们的监听器已经设置好了。

9809
16:13:58.126 --> 16:13:59.683
我们还没有在这里添加断言。

9810
16:13:59.683 --> 16:14:02.883
但是我们会的，让我们继续写剩下的测试。

9811
16:14:02.883 --> 16:14:08.244
然后我们返回，更新这个监听器我们的监听器被添加了。

9812
16:14:08.244 --> 16:14:10.550
这里是我们抽奖的地方。

9813
16:14:10.583 --> 16:14:20.169
在这里，等待，raffle。enter raffle value将是raffle门票。

9814
16:14:20.169 --> 16:14:22.341
就是这样了。

9815
16:14:22.341 --> 16:14:28.838
对吧?我们设置了监听器，设置了监听器，然后进入抽奖。

9816
16:14:28.838 --> 16:14:38.026
这段代码直到监听器听完才会完成因为整个SEC都在等待中。

9817
16:14:38.026 --> 16:14:41.734
我们会说，设置很好，监听器，等待它完成。

9818
16:14:41.734 --> 16:14:49.770
然后当它到达这里时，它会出去好了，这是代码的结束我们都执行完了吗?哦，没有解析或拒绝还没有被调用。

9819
16:14:49.770 --> 16:14:53.155
这是因为我们还在等待听者听完。

9820
16:14:53.155 --> 16:15:08.890
一旦我们把这个winner chosen事件发出到这里，我们就会得到那个最近的winner我们会说const recent winner = await raffle。get recent winner将会得到抽奖状态我们会说const。

9821
16:15:08.890 --> 16:15:15.459
抽奖状态等于等待抽奖点获得抽奖状态，我们将得到获胜者的余额。

9822
16:15:15.459 --> 16:15:17.834
所以我们用const。

9823
16:15:17.834 --> 16:15:22.422
赢家平衡等于等待最近的赢家。

9824
16:15:22.422 --> 16:15:31.092
因为我们只进入部署者我们应该检查部署者的平衡在最后我们不能用这个部署者对象做正确的事情。

9825
16:15:31.092 --> 16:15:44.773
所以我们要写player account = await ethers。get signers，不用换行这实际上会说这是这样的账户。

9826
16:15:44.773 --> 16:15:49.390
然后我们会做一个计数为0的计数因为0将被计算为我们的部署者。

9827
16:15:49.390 --> 16:15:53.122
赢家余额将是账户a乘以余额。

9828
16:15:53.122 --> 16:16:06.158
然后我们要做const ending timestamp =一个weight raffle。get latest to timestamp，我们也应该得到初始余额。

9829
16:16:06.158 --> 16:16:12.335
我们说赢家期末余额，我们也应该在进入后得到初始余额。

9830
16:16:12.335 --> 16:16:14.251
所以我们用const。

9831
16:16:14.251 --> 16:16:19.274
赢家，初始余额等于等待账户。

9832
16:16:19.274 --> 16:16:24.108
零导得到平衡，现在我们可以做一些比较。

9833
16:16:24.108 --> 16:16:24.917
好的，很好。

9834
16:16:24.917 --> 16:16:26.297
现在我们来做比较。

9835
16:16:26.297 --> 16:16:29.635
所以我们首先应该期待抽奖被重置。

9836
16:16:29.635 --> 16:16:32.172
我们可以用几种不同的方法来做。

9837
16:16:32.172 --> 16:16:32.806
下来。

9838
16:16:32.806 --> 16:16:34.393
我们做了很多球员。

9839
16:16:34.585 --> 16:16:42.423
我们也可以说，等待，期待抽奖，得到玩家0。

9840
16:16:43.585 --> 16:16:50.447
点返回，因为Get Player 0应该会被返回因为在0处甚至没有对象。

9841
16:16:50.447 --> 16:16:54.369
这是另一种检查players数组是否重置的方法。

9842
16:16:54.369 --> 16:16:58.335
接下来，我们可以断言。equal recent winner。

9843
16:16:58.335 --> 16:17:05.140
对于字符串，这应该等于我们的帐户0。address。

9844
16:17:05.140 --> 16:17:11.928
好的，我们的部署者我们还能做什么?我们断言。equal抽奖状态为零。

9845
16:17:11.928 --> 16:17:15.635
我们想让这封邮件在我们完成后重新打开。

9846
16:17:15.635 --> 16:17:19.221
最后，我们要确保钱被正确地转移了。

9847
16:17:19.221 --> 16:17:25.031
所以我们断言。equal，这应该是赢家结束的余额。

9848
16:17:25.031 --> 16:17:35.851
那到弦要等于中奖者的起始余额，加上抽奖入场费。

9849
16:17:35.851 --> 16:17:36.451
字符串。

9850
16:17:36.451 --> 16:17:43.103
如果我们往下看，他们进入抽奖我们在他们进入后检查他们的初始余额。

9851
16:17:43.103 --> 16:17:49.552
他们基本上应该拿回抽奖的入场费因为他们是唯一参加抽奖的人。

9852
16:17:49.552 --> 16:17:57.176
然后我们可以再做一个断言，断言结束时间戳大于开始时间戳。

9853
16:17:57.176 --> 16:17:59.667
然后我们当然会说resolve。

9854
16:17:59.667 --> 16:18:02.141
如果一切顺利，我们就解决。

9855
16:18:02.141 --> 16:18:09.222
如果这些断言有问题，我们会捕捉到这些错误，然后拒绝，这将为假。

9856
16:18:09.222 --> 16:18:14.938
整个测试会这样，有一个问题，我们现在有一个分期测试，看起来很好。

9857
16:18:14.938 --> 16:18:16.489
我们来试试这个。

9858
16:18:16.489 --> 16:18:22.359
让我们从头到尾尝试我们的分期测试。

9859
16:18:23.586 --> 16:18:37.392
所以现在为了让我们测试这个阶段性测试，从头到尾，你首先需要得到我们的通道恐惧F的子ID然后我们需要使用子ID部署我们的合同，我们需要用链链接VRF注册合同。

9860
16:18:37.392 --> 16:18:41.946
我们需要把它注册到链链管理员那里。

9861
16:18:41.946 --> 16:18:44.749
当然，我们还要进行阶段性测试。

9862
16:18:44.749 --> 16:18:45.486
我们开始做吧。

9863
16:18:45.586 --> 16:18:49.672
我们要做的第一件事是什么?获取链接VRF的子ID。

9864
16:18:49.672 --> 16:18:50.292
好了,好了。

9865
16:18:50.292 --> 16:18:53.137
下面我们来看看VRF。chain。link。

9866
16:18:53.137 --> 16:18:56.173
我们需要创建一个新的订阅。

9867
16:18:56.173 --> 16:18:58.458
如果我们没有足够的冰球场。

9868
16:18:58.586 --> 16:19:04.586
让我们进入完整的区块链固体性课程，在这里，我们要向下滚动。

9869
16:19:04.586 --> 16:19:08.344
我们要寻找推荐的测试，这里，排名是v。

9870
16:19:08.344 --> 16:19:15.881
我们将使用水龙头链接得到一些Rigby链接，运行Fosses。chain。link，让我们从COVID转换到铈。

9871
16:19:15.881 --> 16:19:18.914
里格比，我们知道我们需要一些联系和证据。

9872
16:19:18.914 --> 16:19:21.864
所以我们把两者都取下来。

9873
16:19:21.864 --> 16:19:27.570
好的，很好，现在我们的交易已经完成了，让我们再检查一下我们的钱包。

9874
16:19:27.570 --> 16:19:30.780
看起来我们确实有以太坊。

9875
16:19:30.780 --> 16:19:36.483
如果你没有看到链接，你可以转到link令牌合约，link令牌合约在link文档中。

9876
16:19:36.483 --> 16:19:43.264
我们向下滚动到Rigby，我们抓取这个合同地址导入令牌，然后粘贴到这里。

9877
16:19:43.264 --> 16:19:45.845
添加自定义令牌，导入令牌。

9878
16:19:45.845 --> 16:19:46.328
太好了。

9879
16:19:46.328 --> 16:19:49.654
现在我可以看到我的eath和我的链接，完美。

9880
16:19:49.654 --> 16:19:53.398
我们有一些我们有一些链接，让我们转到V REF订阅管理。

9881
16:19:53.398 --> 16:19:55.692
我们将创建一个新的订阅。

9882
16:19:55.692 --> 16:20:06.515
同样，我们完全可以通过编程来完成，因为这里的用户界面只帮助我们促进对注册契约的调用契约，注册契约是完全去中心化和链上的。

9883
16:20:06.515 --> 16:20:19.062
让我们继续创建订阅将创建订阅将确认交易在Rinkeby网络上的Metamask将进行一些操作很好一旦通过，你可以点击添加资金按钮。

9884
16:20:19.062 --> 16:20:23.393
我将向你们展示如果你不小心刷新并跳下去会是什么样子。

9885
16:20:23.393 --> 16:20:28.744
如果你刷新，然后返回离开chain。link，你应该有一个新的活动订阅。

9886
16:20:28.744 --> 16:20:30.602
你会看到这个数字。

9887
16:20:30.602 --> 16:20:34.242
如果你点击它，这是你的订阅ID很好。

9888
16:20:34.242 --> 16:20:40.341
我们可以用这个，回到我们的代码到我们的助手Hardhead配置中。

9889
16:20:40.341 --> 16:20:46.373
我们可以把我们的订阅ID贴在我们的Rinkeby网络的订阅ID下面。

9890
16:20:46.373 --> 16:20:46.897
太棒了。

9891
16:20:46.897 --> 16:20:51.387
现在我们有一个订阅，我们可以看到它没有任何链接的资金。

9892
16:20:51.387 --> 16:20:53.349
所以这里没有神谕气体。

9893
16:20:53.349 --> 16:20:54.976
我们没有任何消费者。

9894
16:20:54.976 --> 16:20:58.962
对，我们的消费者将是抽奖或抽签合同。

9895
16:20:58.962 --> 16:21:04.702
让我们先加入一些资金我们不需要加入很多因为我们只需要测试一次。

9896
16:21:04.702 --> 16:21:11.757
我们在这里添加一个link，这个数字可能会根据测试网的不同成本和可用的link令牌的数量而变化。

9897
16:21:11.757 --> 16:21:23.719
所以如果你真的在主网上工作，一定要浏览Doc的链接EVM链的合同地址，你可以阅读更多关于这些不同链的成本，所以你可以弄清楚在这里放多少钱。

9898
16:21:23.719 --> 16:21:34.254
如果你上完整的区块链固体性课程，Jas，我们可以向下滚动到第九课，有一个推荐的链接数量或链链接VRF的rinky保存测试。

9899
16:21:34.254 --> 16:21:39.398
现在我们要放2个给keepers，我们要放8个，但请随意参考这里，这样你就知道要放多少了。

9900
16:21:39.398 --> 16:21:44.054
我们来确认一下，我们要批准增加资金，请确认一下。

9901
16:21:44.054 --> 16:21:49.765
我们现在正在资助我们的订阅，这样我们就可以支付甲骨文的汽油来获得随机数。

9902
16:21:49.765 --> 16:21:50.055
太好了。

9903
16:21:50.055 --> 16:21:53.342
一旦我们得到资金，我们就可以关闭它，我们会稍微刷新一下。

9904
16:21:53.342 --> 16:21:57.981
我们可以看到，当我们没有任何消费者的时候，平衡就变成了链接。

9905
16:21:57.981 --> 16:22:01.095
我们有了我们的sub ID，我们资助了它。

9906
16:22:01.095 --> 16:22:04.164
现在让我们继续部署我们的契约。

9907
16:22:04.164 --> 16:22:16.525
我们已经知道，我们应该可以很好地部署我们的契约，我们到Dotty, V需要添加之前项目中所有相同的参数，我们需要缩小RPC URL，我们需要私钥。

9908
16:22:16.525 --> 16:22:20.007
如果我们想要验证，我们需要以太扫描API密钥。

9909
16:22:20.007 --> 16:22:24.188
如果我们想做气体输出，我们需要我们的硬币市场市值API密钥。

9910
16:22:24.188 --> 16:22:25.968
我们要确保所有这些都有。

9911
16:22:25.968 --> 16:22:27.682
我们将查看部署脚本。

9912
16:22:27.682 --> 16:22:34.200
再一次，快速看一下我们的helper hardcat配置，快速看一下，看起来我们确实有所有的东西。

9913
16:22:34.200 --> 16:22:40.463
我们应该能够在一个命令中部署它。

9914
16:22:40.589 --> 16:22:48.266
所以我们应该能做纱线，硬帽或只是h h再次，策略，dash dash网络Rinkeby。

9915
16:22:48.266 --> 16:22:50.876
我们去试试吧。

9916
16:22:50.876 --> 16:22:55.189
好的，看起来我们编译成功了，部署成功了。

9917
16:22:55.189 --> 16:22:59.379
我们已经验证过了，我们可以用环宫以太扫描打开它。

9918
16:22:59.379 --> 16:23:01.985
我们可以看到我们的代码已经被验证过了。

9919
16:23:01.985 --> 16:23:03.699
它看起来很漂亮。

9920
16:23:03.699 --> 16:23:05.684
我们可以从中阅读，这很好。

9921
16:23:05.684 --> 16:23:08.169
我们可以在这里看到所有这些命令，现在它已经被验证了。

9922
16:23:08.169 --> 16:23:18.802
如果我们看一下Git抽奖状态，我们应该看到它是打开的，它会一直保持打开直到有人结束抽奖并更新合同实际拥有的eath的数量。

9923
16:23:18.802 --> 16:23:24.017
现在我们已经使用那个子ID部署了一个契约，我们需要用chain link V REF注册契约。

9924
16:23:24.017 --> 16:23:25.350
还有链条看守人。

9925
16:23:25.350 --> 16:23:28.867
所以我们需要加上这个消费者确实告诉chinley VRF。

9926
16:23:28.867 --> 16:23:31.046
嘿，这就是你现在要找的合同。

9927
16:23:31.046 --> 16:23:41.504
回到vref。chain。link，我们会抓取这个合约地址，我们会把它添加为消费者，你的订阅准备好了，你现在可以添加消费者了我们会添加消费者。

9928
16:23:41.504 --> 16:23:46.899
这个网站只是为了帮助我们与合同进行互动。

9929
16:23:46.899 --> 16:23:51.303
所以我们会批准这个用户，我们会继续并确认，然后交易就会进行下去。

9930
16:23:51.303 --> 16:24:00.072
在等待它通过的同时，我们可以访问keepers。chain。link，并对用户界面进行同样的操作，注册一个新的upkeep。

9931
16:24:00.072 --> 16:24:05.395
所以我们将继续添加我们的电子邮件Hardhead免费代码camp@gmail。

9932
16:24:05.395 --> 16:24:05.636
com。

9933
16:24:05.636 --> 16:24:08.055
我们把这叫做抽奖维护。

9934
16:24:08.055 --> 16:24:14.847
我们把维护地址粘贴到这里我们有管理地址，你可以忽略这一点。

9935
16:24:14.847 --> 16:24:18.827
对于气体限制，这将是PErforM维护函数的气体限制。

9936
16:24:18.827 --> 16:24:23.661
如果我们用气体估算器，我们可以看看执行维护的成本是多少。

9937
16:24:23.661 --> 16:24:29.090
但现在，我只放50万这可能有点多，但没关系。

9938
16:24:29.090 --> 16:24:33.574
检查数据，我们将保持空白因为我们的检查keep不会取任何东西。

9939
16:24:33.574 --> 16:24:36.161
然后是初始余额，设为8。

9940
16:24:36.161 --> 16:24:40.426
如果你忘记在这里写上初始余额，你总能在后面找到它。

9941
16:24:40.426 --> 16:24:46.145
注册，会弹出一个Metamask，点击确认。

9942
16:24:46.145 --> 16:24:53.393
我们可以回到我们的VRF，看到它确实被添加了，很好，我们现在有一个消费者在我们的VRF上。

9943
16:24:53.393 --> 16:25:05.056
现在让我们等待我们的管理员通过在域名网上成功提交的维护注册请求，你可能需要等一段时间才能让你的请求通过，但我会测试它是否会自动通过。

9944
16:25:05.056 --> 16:25:21.540
现在回到keepers。chain。link，我们现在应该看到如果向下滚动到我的upkeeps，这里有一个抽奖的upkeep因为我不小心使用了我测试的同一个账户，你可以忽略这两个你会有一个但这是我们刚刚创建的。

9945
16:25:21.590 --> 16:25:25.923
我们可以看到我们的余额以及最小余额是多少。

9946
16:25:25.923 --> 16:25:28.812
所以看起来连克8有点太低了。

9947
16:25:28.812 --> 16:25:32.933
让我们回到Fosses。chain。link / rinky。

9948
16:25:32.933 --> 16:25:37.380
现在我们有了更多的链接，我们可以回到我们的抽奖维护。

9949
16:25:37.380 --> 16:25:39.352
然后点击添加资金。

9950
16:25:39.352 --> 16:25:41.470
再加3。

9951
16:25:41.470 --> 16:25:46.751
我们将继续并确认我们首先需要获得支出许可。

9952
16:25:46.751 --> 16:25:52.923
我们批准了我们的链接转移，现在让我们实际转移链接到合同，好了，资金添加成功。

9953
16:25:52.923 --> 16:25:54.524
现在我们来刷新一下。

9954
16:25:54.524 --> 16:26:01.419
现在我们不再看到资金不足的信息，我们有我们的余额，我们可以看到它超过了最低余额。

9955
16:26:01.419 --> 16:26:04.066
我们已经看过我们两次资助这个项目的历史。

9956
16:26:04.066 --> 16:26:15.057
一旦这个启动，我们会看到活动类型会像，执行维护，或者，有我们的子ID，我们部署了合约，我们注册了链链V REF，我们注册了链链keepers。

9957
16:26:15.057 --> 16:26:18.190
现在我们要做的就是进行分段测试。

9958
16:26:18.190 --> 16:26:26.705
现在运行我们的分期测试本质上和我们调用这个回车脚本是一样的，对吧，因为我们在分期测试中所做的就是进入彩票。

9959
16:26:26.705 --> 16:26:40.280
然后我们运行一大堆验证器来确保事情按照我们的预期进行，因为我们的合同实际上是经过验证的，我们可以在Rigby以太扫描上做的是我们可以到合同的右边部分。

9960
16:26:40.280 --> 16:26:44.073
我们甚至可以把我们的钱包连接到它。

9961
16:26:44.073 --> 16:27:01.813
一旦它从红色变成绿色，稍作刷新后，我们会看到它是绿色的，它是连接的，我们甚至可以调用这个契约上的函数，所以我们可以自己进入抽奖，我们会添加，不管进入抽奖有多少，这也会启动VRF中的keeper。

9962
16:27:01.813 --> 16:27:10.854
我们可以通过以太扫描调用它，我们可以通过这里的分段测试调用它，我们可以通过脚本调用它，我们可以通过控制台调用它，有很多方法可以做到这一点。

9963
16:27:10.854 --> 16:27:21.268
但关键时刻，我们要运行阶段性测试，这将让我们进入抽奖，并设置一个监听器，以确保一切正常工作。

9964
16:27:21.268 --> 16:27:30.273
此外，我们会在抽奖维护历史中看到一个交易，然后我们会在我们的链上看到一个交易，比如VRF。

9965
16:27:30.273 --> 16:27:32.495
你准备好了吗?我当然是。

9966
16:27:32.591 --> 16:27:34.216
让我们开始吧。

9967
16:27:40.592 --> 16:27:42.362
这就是我们要做的。

9968
16:27:43.592 --> 16:27:49.541
我们可能应该在这里添加一些console。log来告诉我们每个步骤是什么。

9969
16:27:49.592 --> 16:27:50.480
但是我们忘记了。

9970
16:27:52.592 --> 16:27:56.280
与此相关的是，我们在测试中添加了console点日志。

9971
16:27:56.280 --> 16:28:12.290
好吧，如果我们去以太扫描这个合约，我们回到溜冰场以太扫描这个，我们粘贴那个地址，这是我们在测试中做的第一步，当然，当我们设置这个监听器时，第一个交易将进入抽奖这将启动一切。

9972
16:28:12.290 --> 16:28:12.480
正确的。

9973
16:28:12.480 --> 16:28:17.247
所以如果我们在以太扫描上刷新一点，我们确实可以看到我们进入了抽奖。

9974
16:28:17.247 --> 16:28:20.592
我们更新了抽奖的余额。

9975
16:28:20.592 --> 16:28:21.668
好的,太棒了。

9976
16:28:21.668 --> 16:28:23.592
抽奖已经开始了。

9977
16:28:23.592 --> 16:28:37.269
接下来会发生什么?如果抽奖已经进入，如果我们进入raffle。soul，如果它是开放的，如果足够的时间过去了，如果有玩家并且它有一个平衡，就像我们刚刚检查的那样，它会被看守人踢掉。

9978
16:28:37.269 --> 16:28:51.640
如果我们去到keepers，我们在这里做一点刷新，过了一会儿，我们确实看到通过了检查键我们看到执行维护已经通过了很好，执行维护的是链链VRF。

9979
16:28:51.640 --> 16:29:04.610
如果我们到chainlink, VRF，刷新，到历史记录，我们确实看到一个交易通过了我们可以看到交易哈希值，花费的链接，等等。

9980
16:29:04.610 --> 16:29:11.559
现在如果我们回到我们的测试，我们确实看到抽奖单元测试的朋友满足随机请求赢家选择事件被触发。

9981
16:29:11.559 --> 16:29:22.556
这意味着我们刚刚经历了一个完整的过程，在我们的集成测试正常工作的情况下，在一个真正的圣经上有一个完全真正的分散抽奖工作。

9982
16:29:22.593 --> 16:29:25.978
如果你能走到这一步，绝对非常非常祝贺你。

9983
16:29:25.978 --> 16:29:34.524
如果你和我一起通过整合测试，现在合同被重置为零，因为我们的钱包地址刚刚中了彩票，拿回了钱。

9984
16:29:34.524 --> 16:29:38.270
现在你可能会想，嘿，我看到了创建抽奖功能。

9985
16:29:38.270 --> 16:29:48.270
我看到了抽奖，但我没有看到链链接节点没有调用执行维护和完成随机单词，我不管刷新多久都会来，我没有看到这些交易。

9986
16:29:48.270 --> 16:29:59.526
那些实际上会被认为是内部事务实现随机词，它实际上是通过VRF协调器调用的VRF协调器契约调用完全随机性。

9987
16:29:59.593 --> 16:30:02.283
我们可以看内部交易。

9988
16:30:03.593 --> 16:30:09.765
transactions将是VRF协调器契约的事务，它调用我们的契约。

9989
16:30:09.765 --> 16:30:11.593
执行维护也是一样。

9990
16:30:11.593 --> 16:30:18.374
执行维护，链链接节点实际上通过注册表契约调用，然后注册表契约调用执行维护。

9991
16:30:18.374 --> 16:30:19.499
这就是我们在这里看到的。

9992
16:30:19.593 --> 16:30:23.050
如果我们查一下内部交易，就能找到他。

9993
16:30:23.050 --> 16:30:25.287
现在让我们来看看这个抽奖。

9994
16:30:25.287 --> 16:30:30.287
既然我们已经了解了事件和日志，我们现在就可以进入日志部分了。

9995
16:30:30.287 --> 16:30:40.343
我们可以看到我们的日志或事件在这里发出我们可以看到名称raffle, enter，我们可以看到主题0它将识别整个事件。

9996
16:30:40.343 --> 16:30:55.779
然后我们在这里也看到这个数字它是索引主题，一个地址播放器然后没有与此相关的数据因为我们只有索引参数再次显示为主题所以这绝对是现象级的。

9997
16:30:55.779 --> 16:31:06.507
哇，绝对庞大，我们可以重新运行一个单元测试，在这里只运行我们的单元测试。

9998
16:31:06.594 --> 16:31:09.990
我们可以看到这些都在过去，这里看起来很好。

9999
16:31:09.990 --> 16:31:22.430
我们刚刚成功地在区块链上创建了一个可验证的随机的，自主的，分散的，抽奖的，你现在应该很兴奋。

10000
16:31:22.430 --> 16:31:25.142
现在，我不打算展示如何将它推到GitHub。

10001
16:31:25.142 --> 16:31:34.948
然而，如果你想把它推到上面，再一次，发推给我，发推给chainlink发推给Free Code Camp，请随意这么做，因为你已经做得很好了。

10002
16:31:34.948 --> 16:31:39.260
如果你想把这个推到GitHub，记住，我们会放一个。Git ignore。

10003
16:31:39.260 --> 16:31:45.780
在这里，我们添加了大量的东西，比如VS代码工件、现金部署、已知模块等。

10004
16:31:45.780 --> 16:31:58.529
类型链类型，所有这些，你可以在GitHub repo中找到。Git忽略的例子，这是一个高级项目，我们在这里做了很多非常高级的事情。

10005
16:31:58.594 --> 16:32:05.868
这是课程的一部分，我认为在这一点上，你们已经掌握了大部分的基础知识。

10006
16:32:05.868 --> 16:32:07.731
现在我们要进入更多的前端。

10007
16:32:07.731 --> 16:32:17.260
我们将进入更具体的行业和更高级的主题，这些主题将会让你更有动力，让你成为智能合约领域区块链的大师之一。

10008
16:32:17.260 --> 16:32:38.986
所以热烈的祝贺，再一次，一定要去庆祝，一定要去散步，休息一下，让我们刚学的东西沉淀你的大脑，为下一个做准备。

10009
16:32:39.595 --> 16:32:49.404
好了，现在我们来复习一下这节课的TypeScript版本，我们会稍微快一点，因为在这个TypeScript版本中我们学不到太多新东西。

10010
16:32:49.404 --> 16:32:53.939
如果你想继续学习，你可以在这里打开repo并使用TypeScript分支。

10011
16:32:53.939 --> 16:33:04.152
有一点需要注意的是当我们在测试中执行我们的承诺时，我们做的是一个无效的权值承诺，因为我们不会用我们的承诺返回任何东西。

10012
16:33:04.152 --> 16:33:06.282
但是剩下的是完全一样的。

10013
16:33:06.282 --> 16:33:10.542
我们会有一个硬帽。config到TypeScript它会用到导入。

10014
16:33:10.595 --> 16:33:13.232
再一次，其他的东西都差不多。

10015
16:33:13.595 --> 16:33:16.595
像上次一样导出配置。

10016
16:33:17.595 --> 16:33:17.982
点JSON。

10017
16:33:20.595 --> 16:33:21.562
依赖关系也是如此。

10018
16:33:23.595 --> 16:33:26.201
遵循我们之前使用过的相同功能。

10019
16:33:26.595 --> 16:33:32.431
我们的部署脚本对在底部导出的变量使用类型部署函数。

10020
16:33:32.431 --> 16:33:39.995
我们还导入了硬帽运行时环境类型，在我们的测试中，我们从该类型中获取部署的命名帐户和网络。

10021
16:33:39.995 --> 16:33:57.737
当然，我们仍然在从链斜杠类型导入这些契约的类型，就像你在这里看到的，例如，raffle将被签署到raffle VRF协调器V将被签署到类型VRF协调器V到MK如果我们想部署这些契约工厂，我们也可以。

10022
16:33:57.737 --> 16:34:00.063
这就是TypeScript的主要区别。

10023
16:34:00.063 --> 16:34:01.844
没有什么新鲜的东西。

10024
16:34:01.844 --> 16:34:11.805
但是，如果你想学习TypeScript，你想用TypeScript编写代码，这里有个例子，好的，欢迎回来。

10025
16:34:11.805 --> 16:34:20.428
我希望你的休息绝对是美妙的，因为现在我们正在进入更高级的全栈斜线前端开发。

10026
16:34:20.428 --> 16:34:25.055
我们做了后端开发，我们创建了智能合约，我们创建了彩票。

10027
16:34:25.055 --> 16:34:32.971
在我们的最后一节中，我们将使用所有这些出色的代码来处理我们自己的去中心化彩票。

10028
16:34:32.971 --> 16:34:39.225
为了让日常生活中的普通人使用我们的彩票，我们需要建立一个前端。

10029
16:34:39.225 --> 16:34:51.299
之前，我们学过用原始HTML JavaScript构建前端，在我们的Funmi项目中，我们只用纯HTML和JavaScript创建前端，只用HTML和JavaScript创建应用程序非常棒。

10030
16:34:51.299 --> 16:34:54.662
如果这是你想做的，你完全可以做到。

10031
16:34:54.662 --> 16:34:57.966
但是，使用这些普通协议进行操作有一些限制。

10032
16:34:57.966 --> 16:35:09.153
使用一个框架，就像我们在这一节中将要使用的那样会让我们的生活更容易，我们将能够更快地开发，有更多的功能，在更短的时间内做更多的事情。

10033
16:35:09.153 --> 16:35:15.442
你们还记得，这个项目并不是一个真正的项目，如果你们还记得的话，它只是一堆按钮。

10034
16:35:15.442 --> 16:35:16.503
就是这样。

10035
16:35:16.596 --> 16:35:24.329
使用框架能让我们很容易地将更多的特性和样式添加到应用中。

10036
16:35:24.329 --> 16:35:32.477
同样，这整个部分的代码都位于我们的课程中，并且位于与课程相关的GitHub存储库中。

10037
16:35:32.477 --> 16:35:43.158
这里我要打个星号，我说过很多次了，这门课的前端部分不是必修课，我们不会在前端部分学到任何关于后端的新内容。

10038
16:35:43.158 --> 16:35:50.047
如果你对网站建设不感兴趣，你想做的就是学习这门课的智能合约，你可以跳过这些部分。

10039
16:35:50.047 --> 16:35:59.471
但如果您确实想学习如何构建这些前端应用程序，如果您确实想让用户和非开发人员能够与我们的智能合约进行交互，那么请继续观看。

10040
16:35:59.471 --> 16:36:07.018
我还要在这里加上一个星号，因为如果你以前没有使用过这些框架，学习曲线可能会显得有点陡峭。

10041
16:36:07.018 --> 16:36:13.430
我已经说过很多次了，这不会是一门比本视频多花几个小时的前端课程。

10042
16:36:13.430 --> 16:36:22.734
如果你从来没学过前端，这是我建议你跟随这些可选的课程之一的部分，我们不会在这里播放它们。

10043
16:36:22.734 --> 16:36:26.482
但如果你跟随其中一个子课程，那肯定会非常有帮助。

10044
16:36:26.482 --> 16:36:33.212
我为这门课准备的一个视频就是这个视频，如何将智能合约连接到Metamask。

10045
16:36:33.212 --> 16:36:38.212
它展示了连接你的智能合约和建立这些这些前端的许多方法。

10046
16:36:38.212 --> 16:36:41.473
它确实从原始HTML和JavaScript版本开始。

10047
16:36:41.597 --> 16:36:45.065
你可以在这里得到更多HTML和JavaScript的练习。

10048
16:36:45.065 --> 16:36:48.993
然后它转移到index js醚和其他一些基于Jas的应用程序。

10049
16:36:48.993 --> 16:36:55.954
用几种不同的方法来做会让你对处理这些问题时应该考虑什么有更多的新见解。

10050
16:36:55.954 --> 16:36:59.946
如果你是前端开发新手，这段视频绝对值得一看。

10051
16:36:59.946 --> 16:37:02.547
此外，就像我说的，对于这一节，我们将使用一个框架。

10052
16:37:02.547 --> 16:37:06.069
特别地，我们将使用下一个Jas框架。

10053
16:37:06.069 --> 16:37:06.359
现在。

10054
16:37:06.359 --> 16:37:08.951
其次，Jas是一个基于反应的框架。

10055
16:37:08.951 --> 16:37:13.050
React是一个用于构建前端和全堆栈应用程序的框架。

10056
16:37:13.050 --> 16:37:15.678
接下来，Jas是React框架之上的一个框架。

10057
16:37:15.678 --> 16:37:28.032
如果你已经知道了react，大部分内容就会很自然地理解我们在下一个Jas中使用react的原因是因为react是目前最流行的框架和语言之一。

10058
16:37:28.032 --> 16:37:35.977
所以我们在GitHub上有一篇小文章标题是，为什么你应该使用React js进行网页开发，这一点并不奇怪，我们会深入一点。

10059
16:37:35.977 --> 16:37:49.356
一些最大的应用程序，如Facebook和Instagram使用React js和一些其他的财富500强公司，React js特别是在区块链领域是最受欢迎的协议，如uniswap, Avi也使用React Jas。

10060
16:37:49.356 --> 16:37:58.024
现在我们在React Jas之上使用next Jas的原因是，我认为next Jas使React的工作更容易。

10061
16:37:58.024 --> 16:38:01.836
我希望我们使用最简单，最强大的框架。

10062
16:38:01.836 --> 16:38:09.770
接下来，Jas也得到了大量的蒸汽有一些非常高级的，但在我看来比原始反应更容易使用的功能。

10063
16:38:09.770 --> 16:38:18.379
现在，就像我说的，如果你以前从来没有使用过React，如果你从来没有使用过next Jas，如果你想做一点复习，一定要看我的视频，六种将你的深度与钱包联系起来的方法。

10064
16:38:18.379 --> 16:38:23.598
如果你发现自己在这部分很挣扎，因为前端的东西真的没有意义。

10065
16:38:23.598 --> 16:38:28.542
我们也有一个下Jas速成课程在GitHub回购与本课程相关。

10066
16:38:28.598 --> 16:38:30.401
它大约有一个小时长，绝对是非凡的。

10067
16:38:30.598 --> 16:38:33.664
代码营也有一些Jas的速成课程。

10068
16:38:34.598 --> 16:38:44.936
在前面挣扎，去上下一个Jas课程，然后回到这部分，或者把前面的部分都跳过，只做后面的部分，然后回来做前面的部分。

10069
16:38:44.936 --> 16:38:50.631
我们将向您展示与前端交互和工作的前沿方法，然后还将部署它们。

10070
16:38:50.631 --> 16:38:57.198
如果你做得对，到最后，你就会有一个可以展示的网站，你可以把它的链接发送给你的朋友。

10071
16:38:57.198 --> 16:39:03.859
现在我知道我们已经给你们展示了它是什么样子的但我要再给你们展示一遍这样我们就能看清楚我们在做什么。

10072
16:39:03.859 --> 16:39:10.198
所以我们将有这种去中心化的彩票，我们可以继续连接我们的钱包，如果还没有连接。

10073
16:39:10.198 --> 16:39:12.968
我们可以在不同的网络之间切换。

10074
16:39:12.968 --> 16:39:23.030
我们的应用会识别它并说，嘿，我们这里唯一支持的链将是31337，这是localhost，或者4，这是ring feed。

10075
16:39:23.030 --> 16:39:32.002
我们会学习如何将这个验证添加到我们的应用中这样我们的应用只在我们想要的链上工作，然后我们可以继续和它交互。

10076
16:39:32.002 --> 16:39:40.150
通常，我们可以点击一个按钮，Metamask会弹出，我们可以继续，并确认我们会得到一个小的交易通知，说交易完成了。

10077
16:39:40.150 --> 16:39:42.632
我们会更新我们的前端。

10078
16:39:42.632 --> 16:39:47.995
然后在后端，我们将能够看到链条节点和Chinuch V REF做他们的工作。

10079
16:39:47.995 --> 16:39:55.964
一旦他们选出了一个优胜者，在刷新之后，我们就能看到后端节点被更新了，我们确实有一个之前的优胜者。

10080
16:39:55.964 --> 16:39:56.471
太棒了。

10081
16:39:56.599 --> 16:40:04.795
现在，不仅如此，我们将向你们展示如何构建这个，而且，我们将向你们展示如何在一个实际的网站上托管它。

10082
16:40:04.795 --> 16:40:07.499
所以你可以把它推到你自己的区块链。

10083
16:40:07.599 --> 16:40:11.954
此外，我们将把它托管在一个去中心化的环境中。

10084
16:40:11.954 --> 16:40:20.887
所以我们这里的这个网站它将被托管在一种技术上，它允许我们在去中心化的环境中托管网站，也可以托管后端。

10085
16:40:20.887 --> 16:40:24.978
甚至我们的前端也可以托管在去中心化的环境中。

10086
16:40:24.978 --> 16:40:33.937
我希望你们对此感到非常兴奋，因为我们将向你们展示许多顶级区块链项目使用的最前沿工具。

10087
16:40:33.937 --> 16:40:37.394
我们直接开始吧。

10088
16:40:37.599 --> 16:40:44.824
现在，我正在Hardhead智能合约抽签项目中，我们刚刚做的那个项目，我们做了这个硬帽智能合约抽签，这很棒。

10089
16:40:44.824 --> 16:40:52.277
我们现在要做的是创建一个新文件夹，尽管我们会时不时地回到这个文件夹做一些更新。

10090
16:40:52.277 --> 16:40:54.276
所以如果你想让它保持开放，你完全可以。

10091
16:40:54.276 --> 16:41:00.534
不过我还是选择CD下载目录这门课的主目录。

10092
16:41:00.600 --> 16:41:05.053
我们要创建一个新目录next Jas。

10093
16:41:05.600 --> 16:41:06.400
合同。

10094
16:41:11.600 --> 16:41:15.534
智能合约抽签FCC，继续，点击代码期。

10095
16:41:15.600 --> 16:41:19.729
就像我说的，如果你想保留那个文件夹和这个新文件夹，你完全可以。

10096
16:41:19.729 --> 16:41:25.300
但基本上，我们只是在Jas智能合约彩票文件夹中打开我们的VS代码。

10097
16:41:25.300 --> 16:41:44.400
对于这个前端的东西，特别是，如果你想绝对确保你使用的是和我相同的版本，你能做的是，你可以用git克隆这个repo，然后复制yarn。lock和package。JSON，然后运行yarn，这将确保你总是使用和我完全相同的包，你永远不会遇到任何奇怪的问题。

10098
16:41:44.400 --> 16:41:56.863
如果你真的遇到问题，首先要做的事情之一，特别是对于这些前端部分，就是返回，确保你有完全相同的yarn。lock和package JSON，我在我的例子中做的，然后从那里开始。

10099
16:41:56.863 --> 16:41:58.968
现在我们在我们的前端项目中。

10100
16:41:58.968 --> 16:42:11.059
我们将创建一个网站，我们将创建一个应用程序的前端，就像我说的，我们将使用下一个Jas，如果你想要跟随下一个Jas的文档，他们确实有一个很好的开始，并走过这个过程。

10101
16:42:11.059 --> 16:42:20.015
对于我们，我们会做yarn，创建下一个app，然后放一个小句点表示我们希望下一个app在这个目录中。

10102
16:42:20.015 --> 16:42:25.091
如果你不放句号，它会创建一个新文件夹，你会有两个文件夹。

10103
16:42:25.091 --> 16:42:26.009
好的,太棒了。

10104
16:42:26.009 --> 16:42:34.521
一旦我们这样做了，在我们的文件资源管理器部分，我们现在可以看到所有不同的文件样板。

10105
16:42:34.600 --> 16:42:36.790
现在，让我快速回顾一下这里发生了什么。

10106
16:42:36.790 --> 16:42:42.158
同样，我们在我推荐的两个视频中也讲过这个，复习两遍也无妨。

10107
16:42:42.158 --> 16:42:47.797
节点模块，当然是安装页面中的包会是我们网站上的不同页面。

10108
16:42:47.797 --> 16:42:49.911
让我给你们展示一下我的意思。

10109
16:42:49.911 --> 16:42:51.372
来管理整件事。

10110
16:42:51.372 --> 16:43:01.366
实际上，我们可以运行yarn，运行Dev，然后开始服务器，等等，等等，你可以命令点击它或者复制粘贴到你的浏览器中。

10111
16:43:01.366 --> 16:43:05.533
你会看到在localhost 3000上，我们的页面在这里。

10112
16:43:05.601 --> 16:43:08.134
现在我们能做的是，索引。

10113
16:43:09.601 --> 16:43:12.854
默认页面，也就是这里的斜杠。

10114
16:43:12.854 --> 16:43:15.774
但我们能做的是创建新的页面。

10115
16:43:15.774 --> 16:43:19.482
所以我可以做新文件，你知道，狗点Jas。

10116
16:43:19.482 --> 16:43:30.601
然后复制粘贴index到dog到Jas，粘贴，删除div里面的所有内容，你不需要遵循这里，点击，嗨，保存这个，回到这里。

10117
16:43:30.601 --> 16:43:34.378
我现在可以输入狗来得到这个。

10118
16:43:34.601 --> 16:43:39.431
所以页面就是这些到网站不同位置的不同路径。

10119
16:43:39.431 --> 16:43:43.124
index是默认值，就像主页一样。

10120
16:43:43.124 --> 16:43:44.846
我要删除达尔多。

10121
16:43:44.846 --> 16:43:48.889
在这些文件中会有一些东西叫做反应语法或JSX。

10122
16:43:48.889 --> 16:43:52.289
它们以Jas的形式出现，但基本上是文本中的反应。

10123
16:43:52.289 --> 16:43:59.288
Jas是基于React的，你会看到这些页面是JavaScript和HTML的奇怪组合。

10124
16:43:59.288 --> 16:44:18.746
我们在顶部看到一些import的东西，这让我们想起了JavaScript，你会在顶部看到一些重要的东西然后在下面这里，你会看到，像div head main h1 P，你会看到所有这些像HTML标签react index js让我们做JavaScript和HTML的组合。

10125
16:44:18.746 --> 16:44:21.698
这实际上让生活简单了很多。

10126
16:44:21.698 --> 16:44:24.952
你也会注意到我们在这里做了导入。

10127
16:44:24.952 --> 16:44:30.015
记住，我之前告诉过你，导入工作与我们的前端要求不。

10128
16:44:30.015 --> 16:44:37.570
这就是node不等于JavaScript之间的区别?这就是区别开始变得有点混乱的地方。

10129
16:44:37.602 --> 16:44:43.776
但我通常喜欢的思考方式是，我只说，没有JS，不好意思，我只说后端。

10130
16:44:43.776 --> 16:44:47.175
我可以J S有点不同于前端。

10131
16:44:47.175 --> 16:44:47.437
是的。

10132
16:44:47.437 --> 16:44:50.539
所以后端Jas和前端Jas有点不同。

10133
16:44:50.539 --> 16:44:52.338
这是我喜欢的思考方式。

10134
16:44:52.338 --> 16:44:52.548
应用程序。

10135
16:44:52.548 --> 16:45:06.489
js将是所有反应方式的入口点Jas的下一个工作是所有的东西都是基于我们所有文件的组件，你会看到这个export default函数home或类似的东西。

10136
16:45:06.489 --> 16:45:18.268
Jas接下来要做的是，嘿，这个包含大量JavaScript的HTML东西被认为是一个组件。

10137
16:45:18.268 --> 16:45:23.231
所有的页面都是通过这个下划线app包装的。

10138
16:45:23.231 --> 16:45:23.795
js页面。

10139
16:45:23.795 --> 16:45:27.118
这是一个页面，但它有点像主要的入口。

10140
16:45:27.118 --> 16:45:33.412
它们被卡在我们应用的组件部分Jas你可以在这张图上想一下。

10141
16:45:33.412 --> 16:45:36.852
GS是整个应用程序或整个前端。

10142
16:45:36.852 --> 16:45:43.470
在这个主页上，这个分量，我们把index。j放在这里，我们把component换成了index。j。

10143
16:45:43.470 --> 16:45:43.568
年代。

10144
16:45:43.568 --> 16:45:52.094
API是我们想做的如果我们想做一些HTTP GET HTTP POST请求，但我们不会做这些。

10145
16:45:52.094 --> 16:46:04.291
我们现在会忽略API public是一些公共图像比如favicon或Versaille, SVG styles将是我们项目的CSS。

10146
16:46:04.291 --> 16:46:06.667
CSS是层叠样式表的缩写。

10147
16:46:06.667 --> 16:46:18.389
这基本上是一种样式化HTML的方法，我们会稍微改变一下样式化的方法，但这基本上就是它们的作用ESLint我现在正在转储这个我们有。Git忽略，我们知道它的作用。

10148
16:46:18.389 --> 16:46:20.618
下一个。config。J。

10149
16:46:20.618 --> 16:46:20.749
年代。

10150
16:46:20.749 --> 16:46:22.841
这是一个配置文件或下一个。

10151
16:46:22.841 --> 16:46:28.022
Jas，当然，我们有package json，有readme，还有yarn。lock。

10152
16:46:28.022 --> 16:46:32.213
我们要做的大部分都在Pages文件夹中。

10153
16:46:32.213 --> 16:46:51.353
我们还会创建另外几个文件夹这将是我们的主要内容，因为我是我，我喜欢用pretty tier，我将自动转储一个pretty RC，和一个pretty ignore在这里，这样我可以把我的代码格式化得更好，你可以从我们上一个项目中获取你的pretty RC，你也可以获取你的pretty ignore。

10154
16:46:51.353 --> 16:47:06.924
或者你可以暂停我从与这节课相关的GitHub repo复制粘贴过来，然后我们会写yarn，添加dash Dev，更漂亮，这样我们就能自动格式化所有的代码回到这里，我们可以保存，然后东西就自动格式化了。

10155
16:47:06.924 --> 16:47:09.364
现在，再一次，我们将使用多终端功能。

10156
16:47:09.364 --> 16:47:11.506
现在有一个在我的前端运行。

10157
16:47:11.603 --> 16:47:14.012
回到前端，点刷新。

10158
16:47:14.603 --> 16:47:14.840
运行。

10159
16:47:16.603 --> 16:47:16.857
的东西。

10160
16:47:16.857 --> 16:47:18.840
我们现在让yarn运行开发。

10161
16:47:19.603 --> 16:47:23.790
到我们的包，JSON，运行yarn，运行dev就会运行下一个dev。

10162
16:47:23.790 --> 16:47:31.484
实际上，让我取消它，只运行yarn dev yarn非常聪明，它不需要运行dev，它只运行next dev。

10163
16:47:31.484 --> 16:47:37.758
这个next命令会在安装next时内建，这是我们在yarn create next app时做的。

10164
16:47:37.758 --> 16:47:50.030
下一个Jas附带了这些已经为我们构建的脚本，我们希望构建我们的前端，使人们能够以公平的方式与我们的彩票进行交互，并与正在运行的智能合约连接。

10165
16:47:50.030 --> 16:47:52.248
让我们为此创建一些简单的前端部件。

10166
16:47:52.248 --> 16:47:56.182
我们要做的第一件事是到Pages，然后到index。

10167
16:47:56.182 --> 16:47:56.287
js。

10168
16:47:56.287 --> 16:47:58.899
这里的东西都很可爱。

10169
16:47:58.899 --> 16:48:06.434
下一个谢谢你，Jas，但我们会把它全部删除除了那个头饰，我们会把它保留下来，我们只会更改名字。

10170
16:48:06.434 --> 16:48:17.389
下面这里，我们将把名称从Crate next app改为智能合约彩票或raffle等等。

10171
16:48:17.389 --> 16:48:20.840
描述将是我们的智能合约，彩票。

10172
16:48:20.840 --> 16:48:26.654
然后在正下方，我们写上hello，蓝色，然后保存。

10173
16:48:26.654 --> 16:48:38.175
如果我们看前端，我们会看到智能合约抽签和顶部我要把这个移到这里，智能合约抽签和顶部我们看到，你好，这是智能合约抽签。

10174
16:48:38.175 --> 16:48:45.450
你好，这里的描述，我们不会看到这将是一些我们将会找到的东西。

10175
16:48:45.604 --> 16:48:50.210
现在我们需要做的第一件事是我们需要创建那个连接按钮。

10176
16:48:50.210 --> 16:48:55.541
我们过去用原始JavaScript做过这个，但现在我们要用next js和react来做。

10177
16:48:55.541 --> 16:48:58.836
我们之前做的那个非常简约。

10178
16:48:58.836 --> 16:49:06.204
事实上，我们把它带回来，它检查是否有窗口Aetherium，然后去请求和连接，说，好，酷。

10179
16:49:06.204 --> 16:49:07.046
你连接。

10180
16:49:07.046 --> 16:49:11.636
没有做的是我们希望应用程序做的很多事情。

10181
16:49:11.636 --> 16:49:22.556
当我们改变网络时，我们的应用程序没有检测到当我们改变用户或应用程序没有检测到它在连接到钱包的功能上是非常严格的。

10182
16:49:22.605 --> 16:49:35.080
我们要让我们的钱包连接按钮，非常强大，你可以连接到按钮，你可以切换网络，你可以切换账户，你可以在我们的应用中做任何事我们的应用会有响应。

10183
16:49:35.080 --> 16:49:45.401
这是我们要做的第一件事之一，我们要创建一个头文件并连接按钮导航栏1在这里一个小导航栏，说，你可以连接这个按钮。

10184
16:49:45.401 --> 16:49:47.346
这是我们要做的第一件事。

10185
16:49:47.346 --> 16:49:51.121
现在我们可以在这个index。js中建立整个连接按钮并插入到这里。

10186
16:49:51.121 --> 16:49:54.700
但是相反，我们要做的是我们要把它变成一个叫做分量的东西。

10187
16:49:54.700 --> 16:49:58.201
我们要创建一个名为components的新文件夹。

10188
16:49:58.201 --> 16:50:02.121
我们将在这里创建一个新文件header。

10189
16:50:02.121 --> 16:50:02.250
js。

10190
16:50:02.250 --> 16:50:06.564
你可能也会看到很多人做头部动作。

10191
16:50:06.564 --> 16:50:06.972
js x。

10192
16:50:06.972 --> 16:50:07.584
js和。

10193
16:50:07.584 --> 16:50:17.105
js x做了完全相同的事情，你可以用任何一个，我要用。JSX，提醒我这是一个React文件。

10194
16:50:17.105 --> 16:50:18.533
这是我们创建的一个组件。

10195
16:50:18.605 --> 16:50:19.938
但是你可以做JS JSX。

10196
16:50:21.605 --> 16:50:25.088
关于组件的更多信息，我们有一个学习组件的链接。

10197
16:50:25.088 --> 16:50:27.811
它们基本上是独立的、可重用的代码位。

10198
16:50:27.811 --> 16:50:32.339
它们的作用与JavaScript函数相同，但独立工作并返回HTML。

10199
16:50:32.339 --> 16:50:44.552
基本上，我们会创建一小段HTML然后导出到索引中就像我们过去做的那样，这有助于在整个项目中模块化和重用这个头组件。

10200
16:50:44.552 --> 16:50:47.536
现在，我们只会在一个区域使用我们的头部。

10201
16:50:47.536 --> 16:50:50.686
然而，无论如何，对项目进行模块化仍然很好。

10202
16:50:50.686 --> 16:50:54.655
首先，这就是所谓的基函数组分。

10203
16:50:54.655 --> 16:51:04.504
我们会创建一个函数home write和JavaScript中的很像，只是它会返回一些HTML。

10204
16:51:04.504 --> 16:51:08.181
我们可以做一个小div。

10205
16:51:08.181 --> 16:51:11.444
我的VS代码在这里自动创建结束div。

10206
16:51:11.444 --> 16:51:14.021
在这里，我要说hi from header。

10207
16:51:14.021 --> 16:51:19.288
这将是一个真正的极简分量就像这是一个有效分量一样。

10208
16:51:19.288 --> 16:51:22.295
现在我们有了这个返回HTML的函数。

10209
16:51:22.295 --> 16:51:29.299
并且要给其他应用程序，使用这个组件的能力将做导出默认功能回家。

10210
16:51:29.299 --> 16:51:31.073
然后在指数中。

10211
16:51:31.073 --> 16:51:33.543
Js，我们可以用imports来导入它。

10212
16:51:33.543 --> 16:51:48.458
Home，不好意思，我不叫它Home，我们叫它header header，不好意思，export default function header，然后import header从下目录components / header，像这样。

10213
16:51:48.458 --> 16:51:59.551
现在我们已经在index中导入了头文件如果我们回到还在运行的前端，我们在这里看不到头文件?记住，所有东西都要通过我们的应用程序。

10214
16:51:59.606 --> 16:52:03.963
当我们在斜杠页面时，它会到我们的索引。

10215
16:52:03.963 --> 16:52:04.105
js。

10216
16:52:04.105 --> 16:52:10.481
Index js导入了头文件，但没有返回头文件。

10217
16:52:10.481 --> 16:52:12.065
这里，我们看到它返回了。

10218
16:52:12.065 --> 16:52:14.753
这是它返回的HTML。

10219
16:52:14.753 --> 16:52:17.133
如你所见，这里显然没有标题。

10220
16:52:17.133 --> 16:52:21.043
现在我们已经导入了头文件，我们需要在这里添加头文件。

10221
16:52:21.043 --> 16:52:24.812
我们做header，然后在这里添加结束标签。

10222
16:52:24.812 --> 16:52:34.896
如果你不添加任何东西，你知道，在两个标签之间，你可以只做这一行，在末尾有一个反斜杠，说，嘿，这是一个开闭标签。

10223
16:52:34.896 --> 16:52:44.392
现在我们已经导入了它，你认为我们会在前端看到什么，现在我们已经将它添加到index js中，你是对的，我们看到hi from header，因为我们在这里添加了header。

10224
16:52:44.392 --> 16:52:45.963
然后我们看到Hello。

10225
16:52:45.963 --> 16:52:48.352
这么高的头，你好，轰。

10226
16:52:48.352 --> 16:52:51.987
现在，我们做的任何事情，显然都在header中。

10227
16:52:51.987 --> 16:52:54.463
Js，将看到反映在我们的前端。

10228
16:52:54.463 --> 16:53:00.016
所以我们可以从头球做hi，等等，等等，你知道，只是一堆运球，我们会看到它在我们的前端。

10229
16:53:00.016 --> 16:53:05.321
这将是我们的部分我们将在这里创建我们的标题或导航栏或连接按钮的所有功能。

10230
16:53:05.321 --> 16:53:08.940
现在我要告诉你们一些事情，你们有些人会喜欢这个夏天，有些人会讨厌这个夏天。

10231
16:53:08.940 --> 16:53:09.807
我要展示给你看。

10232
16:53:09.807 --> 16:53:13.764
我先给你演示一下困难的方法，然后简单的方法。

10233
16:53:13.764 --> 16:53:26.933
为什么我要先给你看看艰难的方式?因为我想让你们熟悉幕后发生的事情以及这些组件发生的事情因为在构建这些前端时理解这些是很有帮助的，好，这是发生的事情。

10234
16:53:26.933 --> 16:53:34.770
如果你不了解幕后发生了什么，你就会去尝试构建更高级的应用程序，你将不知道该做什么因为你只是学习了捷径。

10235
16:53:34.770 --> 16:53:43.251
我喜欢把它想象成微积分，就像我们先学习如何计算导数，然后学习快速求导的捷径。

10236
16:53:43.251 --> 16:53:48.114
所以不要跳过这部分，因为这将对你大有帮助。

10237
16:53:48.114 --> 16:53:53.575
好的，我们将会用比较难的方法来学习在HTML Funmi中设置所有东西。

10238
16:53:53.575 --> 16:53:59.236
我们可以用生醚来做任何事情你完全可以用生醚来做任何事情。

10239
16:53:59.236 --> 16:54:08.038
然而，有一些软件包特别为React，使生活开发前端实质性更好，在我们的完整区块链坚实的过程中，Jas。

10240
16:54:08.038 --> 16:54:12.591
我们有许多其他的包，你可以使用它们来堆叠开发和其他库。

10241
16:54:12.591 --> 16:54:17.531
如果你看了这六种将你的深度与钱包联系起来的方法，你就会真正理解其中的一些区别。

10242
16:54:17.531 --> 16:54:20.857
如果你还没看过那个视频，回去看看那个视频。

10243
16:54:20.857 --> 16:54:25.689
但是有很多库可以让我们的生活变得更容易。

10244
16:54:25.689 --> 16:54:27.213
我们在这里列出了其中的一些。

10245
16:54:27.213 --> 16:54:35.642
React Morales是我们今天要用的，他们有一些额外的插件，他们可能有这个星球上我最喜欢的东西，我很快会向你们展示如何做。

10246
16:54:35.642 --> 16:54:45.048
但这些也是开源的，Ross还提供了一些可选的功能，可以连接到你自己的后端，为你的应用程序提供更多的特性和功能。

10247
16:54:45.048 --> 16:54:46.706
这也是我们这么做的另一个原因。

10248
16:54:46.706 --> 16:54:48.574
这个我们稍后再讲。

10249
16:54:48.574 --> 16:54:51.765
如果你想用纯醚，你完全可以。

10250
16:54:51.765 --> 16:54:56.758
我们使用的很多包都依赖于以太，但我们不会只使用以太。

10251
16:54:56.758 --> 16:54:58.508
我们进入反应莫拉莱斯的页面。

10252
16:54:58.608 --> 16:55:01.139
我们先从这里开始。

10253
16:55:02.608 --> 16:55:05.369
我要把这个复制到我们的项目中。

10254
16:55:05.608 --> 16:55:10.165
如果你去JSON包，我们实际上已经有了react和react DOM。

10255
16:55:10.165 --> 16:55:14.849
所以我们可以只做纱线，加入莫拉莱斯，然后反应口腔。

10256
16:55:14.849 --> 16:55:23.269
现在你会注意到我没有把这些作为开发依赖项，我没有把yarn添加到这里。

10257
16:55:23.269 --> 16:55:37.170
原因是，对于我们的产品构建，当我们在这里创建网站时，你会需要Morales你会需要react Morales我们不需要更漂亮的网站，更漂亮的是我们作为开发者使用的工具。

10258
16:55:37.170 --> 16:55:41.239
所以在我们所有的项目中，到目前为止，我们只使用了开发依赖。

10259
16:55:41.239 --> 16:55:54.117
这是因为我们一直在为开发人员建立项目，我们的GitHub repos，他们没有建立一个网站，他们只做后端的事情，对于我们的网站，我们实际上要建立一个前端。

10260
16:55:54.117 --> 16:56:03.473
所以我们需要把它放在依赖项部分，因为我们需要说，嘿，这些是我们需要在前端捆绑在一起的，你可以忽略这些。

10261
16:56:03.473 --> 16:56:07.258
如果它只是一个让我们的生活更美好的工具，那它就属于开发依赖。

10262
16:56:07.258 --> 16:56:09.854
加上莫拉莱斯，反应莫拉莱斯。

10263
16:56:09.854 --> 16:56:15.959
我们要为头文件做的很多语法实际上和我们目前看到的非常相似。

10264
16:56:15.959 --> 16:56:16.740
我们来做这个。

10265
16:56:16.740 --> 16:56:29.415
然后，我们要把这个名字改成manual header, manual header更新导入为manual header，你可以点击yes to man所有的header，我们要复制manual header，确保它在索引中。

10266
16:56:29.415 --> 16:56:33.209
我们要把页眉改成手动页眉，这里也要改成手动页眉。

10267
16:56:33.209 --> 16:56:40.270
我们这样做的原因是，就像我说的，我们将在创建这个难的头文件之后创建一个更简单的头文件。

10268
16:56:40.270 --> 16:56:44.386
我们会创建那个连接按钮，这是我们在HTML Funmi中做的。

10269
16:56:44.386 --> 16:56:51.542
通过调用每个请求账户，我们可以用Morales做这个叫Enable Web 3。

10270
16:56:51.542 --> 16:56:57.418
在顶部，我们要导入，使用米拉拉。

10271
16:56:57.609 --> 16:56:59.157
react ralis报道。

10272
16:57:03.609 --> 16:57:07.892
或者到他们的GitHub，你也会学到如何设置所有这些，并了解更多关于文档的知识。

10273
16:57:07.892 --> 16:57:20.415
我们会从react Morales导入use Morales，在函数内部，但在return之外，我们会说const, Enable Web three = use mirallas。

10274
16:57:20.415 --> 16:57:25.333
现在使用Morales就是所谓的钩子React钩子。

10275
16:57:25.333 --> 16:57:28.809
它是在应用程序中跟踪状态的一种方法。

10276
16:57:28.809 --> 16:57:37.547
现在，为了使用mirallas，我们的整个应用程序需要围绕所谓的Morales提供程序进行包装，它将是我们的上下文提供程序。

10277
16:57:37.609 --> 16:57:38.962
我马上会解释这是什么意思。

10278
16:57:39.609 --> 16:57:43.948
我们需要做的是将Morales提供者添加到我们的应用中。

10279
16:57:43.948 --> 16:57:44.173
js。

10280
16:57:44.173 --> 16:57:51.547
在这里，我们要从react oralis导入oralis provider。

10281
16:57:51.547 --> 16:57:58.990
我们将把整个应用围绕这个莫拉莱斯提供我们将在这里做一些小括号。

10282
16:57:58.990 --> 16:58:09.085
New Line，我们会像这样粘贴morass provider，它会给我们结束标签，复制，像这样粘贴，然后保存。

10283
16:58:09.085 --> 16:58:16.766
然后在这里，我们会在表格中写上盟军Mount = false。

10284
16:58:16.766 --> 16:58:24.902
这个初始化挂载部分是连接到服务器的可选性，为我们的网站添加更多的功能。

10285
16:58:24.902 --> 16:58:30.578
我们不希望这个应用程序与服务器挂钩，我们希望一切都是开源的，我们不需要任何额外的功能。

10286
16:58:30.610 --> 16:58:33.782
我们会在Mount上做初始化= false。

10287
16:58:33.782 --> 16:58:40.429
现在整个东西都被包装在这个Morales提供程序中了，我们去到前端我们应该能够刷新所有看起来几乎一样的东西。

10288
16:58:40.429 --> 16:58:42.832
我们可以开始用这些钩子了。

10289
16:58:42.832 --> 16:58:57.884
这个使用叫做钩子钩子乍一看可能会让人有点困惑，但它们非常强大它们是我们建立react项目的实际方式。

10290
16:58:57.884 --> 16:59:23.564
如果你熟悉类组件,我们不会使用类组件因为钩子是更好的钩子函数允许组件访问状态和其它人的反应特性状态可能是其中一个最大的和最受欢迎的人,我们希望我们的应用程序是不同的,如果我们连接到Metamask,而如果我们没有,对,如果我们回去,如果我们回到我们的示例网站这里,是的,如果我们不联系,我们想说,请连接到钱包上。

10291
16:59:23.611 --> 16:59:26.026
当我们被连接时，我们想要向前走并被连接。

10292
16:59:26.026 --> 16:59:37.695
假设我有一些变量，比如，这里没有钩子，我有，let connected = false，或者启用Web 3，或者启用Web 3，假设我有，led connected = false。

10293
16:59:37.695 --> 16:59:57.561
然后我有一个连接我们的按钮改变连接为真，改变连接为真很好但它不会重新呈现我们的应用，当我断开连接时，我们的应用会根据我们是否连接而改变。

10294
16:59:57.611 --> 17:00:01.544
这就是我们想要的，我们想要我们的前端重新渲染。

10295
17:00:01.611 --> 17:00:08.048
连接时，如果我在组件中使用这样的变量，前端不会重新渲染。

10296
17:00:08.048 --> 17:00:14.059
更糟糕的是，如果我在外面使用它，我们的组件甚至不知道这个变化的任何事情。

10297
17:00:14.059 --> 17:00:25.837
钩子是我们处理状态的一种方式特别是当有东西改变时自动重新渲染启用Web 3是我们从这个函数中得到的使用Morales钩子来做这个。

10298
17:00:25.837 --> 17:00:36.143
对于很多组件，我们不会像普通JavaScript那样，只说，让web three enabled = true，我们会做很多这个，这些钩子。

10299
17:00:36.143 --> 17:00:53.046
在大多数情况下，我们通常希望我们的网站改变基于如果一些变量改变了启用web 3是我们从这个钩子中获得的功能它说，好，继续连接启用web 3基本上相当于说try await Aetherium。request，像这样。

10300
17:00:53.046 --> 17:00:56.857
现在启用web3，我们这里使用它的方式只适用于Metamask。

10301
17:00:56.857 --> 17:01:05.494
我们会展示如何建立这个很酷的小模块在这里我们可以选择连接应用的不同方式。

10302
17:01:05.612 --> 17:01:25.366
我们已经启用了web3，让我们创建一个按钮，这和我们在返回的HTML Funmi中所做的一样，但这里，我们不添加hi friend header，我们要添加一个新组件，或者我们要添加一个新标签，我们要添加button标签，对我来说它会自动关闭，我把它命名为connect，然后保存。

10303
17:01:25.366 --> 17:01:26.849
现在我们看到一个小按钮，上面写着连接。

10304
17:01:26.849 --> 17:01:35.715
显然，它什么都不做，我们会给它一些功能，我们会说on click now因为这是JSX组件。

10305
17:01:35.715 --> 17:01:41.902
这不是原始HTML，在原始HTML中，我们不能随便把JavaScript放哪。

10306
17:01:41.902 --> 17:01:46.678
但在JSX文件中，我们可以随意放置JavaScript。

10307
17:01:46.678 --> 17:01:53.644
在这一段HTML中，我们可以通过添加这些小括号把JavaScript写在这里。

10308
17:01:53.644 --> 17:01:56.349
所以在我们的工作中加入这些小括号可以回来。

10309
17:01:56.349 --> 17:01:57.922
但在这里，我们可以添加JavaScript。

10310
17:01:57.922 --> 17:02:16.808
我们要做的是我们要有On Click Call Enable web3，我们会调用一个async函数，我们会在这里使用箭头语法，一键式，我们会调用这个async函数，它就是await, Enable web3, await Enable web3，我们在这里加一个小括号。

10311
17:02:16.808 --> 17:02:23.547
本质上，通过这个，我们已经完成了在这个大的连接函数中所做的所有事情。

10312
17:02:23.612 --> 17:02:29.992
现在回到前端，稍微刷新一下，我们现在可以看到，我已经连接上了，我要断开连接。

10313
17:02:29.992 --> 17:02:38.870
我还连接着之前做的一些应用，我们可以点击连接，现在我们看到metamath确实弹出了，我们点击下一步连接，然后嘣。

10314
17:02:38.870 --> 17:02:39.805
这就是我们要做的。

10315
17:02:39.805 --> 17:02:42.033
现在，如果我们看我们的Metamask，它说连接。

10316
17:02:42.033 --> 17:02:42.348
太好了。

10317
17:02:42.348 --> 17:02:42.927
好的,很酷。

10318
17:02:42.927 --> 17:02:50.631
现在我们有了连接的方法，让我们添加一些功能让我们的应用足够智能，在连接时有连接按钮。

10319
17:02:50.631 --> 17:02:53.163
如果我们没有联系，就没有那个按钮。

10320
17:02:53.163 --> 17:03:03.580
我们现在要做的是使用Morales附带的另一个钩子叫做iswebthree, enabled，这是我们钩子的一个可变部分，它跟踪我们的Metamask是否连接。

10321
17:03:03.580 --> 17:03:10.888
但我们可以做得更好，我们可以检查是否有账户因为也许web 3是连接的。

10322
17:03:10.888 --> 17:03:13.679
但是但是他们没有把它和账户联系起来。

10323
17:03:13.679 --> 17:03:16.924
我们继续，导入count。

10324
17:03:16.924 --> 17:03:19.957
莫拉莱斯会去查是否有账户。

10325
17:03:19.957 --> 17:03:27.693
我们要做的是在div标签内部，我们会用一点JavaScript，我们会再次使用三元运算符，我们会在这里放一个带问号的计数。

10326
17:03:27.693 --> 17:03:33.763
用之前学过的语法，我们说账户，如果账户存在，就这么做。

10327
17:03:33.763 --> 17:03:35.313
如果没有账户，就这么做。

10328
17:03:35.313 --> 17:03:39.350
如果没有帐户，我们要添加这个连接按钮。

10329
17:03:39.350 --> 17:03:41.799
我们继续，把它插在这里。

10330
17:03:41.799 --> 17:03:44.776
如果有一个账户，我们就会显示这个账户。

10331
17:03:44.776 --> 17:03:50.528
我们在这里写div反斜杠，我们写connected，像这样。

10332
17:03:50.613 --> 17:03:53.129
现在如果我们回到我们的前端，我们看到连接。

10333
17:03:53.613 --> 17:03:55.581
稍作调整，它就会消失。

10334
17:03:57.613 --> 17:03:59.596
现在我们联系在一起了，这很好。

10335
17:04:00.613 --> 17:04:01.050
更聪明。

10336
17:04:01.050 --> 17:04:03.300
我们要在这里显示我们的账户。

10337
17:04:04.613 --> 17:04:11.279
说连接，我们会说连接到，我会在我们的JavaScript中放入一些JavaScript。

10338
17:04:11.279 --> 17:04:16.422
但因为这是HTML的东西，我们要用括号来表示JavaScript。

10339
17:04:16.422 --> 17:04:21.145
我们会把JavaScript放在JavaScript里面，我们会说connected to，我们会说account。

10340
17:04:21.145 --> 17:04:32.306
现在回到我们的前端，我们看到连接到，等等，等等，你会注意到，如果你点击刷新，你需要重新连接，我们马上会讲到这个，很多人会做一个count。slice (0,6)

10341
17:04:32.306 --> 17:04:50.872
然后在括号外面，他们会写。那个。另一组括号帐户，那片，count。length - 4，像这样关闭，我们有了我们的帐户，当我们点击连接时，它会说连接到某某，某某，你好。

10342
17:04:50.872 --> 17:04:59.047
因为这些挂钩，当我切换账户，连接到这些新账户时，它甚至会自动重新呈现切换账户。

10343
17:04:59.047 --> 17:05:03.998
这些钩子对于重新渲染我们的网站非常有用每当一些值发生变化时。

10344
17:05:03.998 --> 17:05:16.130
例如，如果我说，让count number = 7，我们有一个按钮，那个更新的账号，我们的前端不会重新播放，除非我们特别告诉它重新播放，这很烦人。

10345
17:05:16.130 --> 17:05:18.375
钩子在这方面帮助很大。

10346
17:05:18.375 --> 17:05:24.457
它允许我们跟踪渲染之间的状态。

10347
17:05:24.614 --> 17:05:33.489
现在它没有做的是，如果我点击刷新，我必须重新点击连接按钮，即使我的Metamask说，嘿，我们连接了。

10348
17:05:33.489 --> 17:05:35.786
但如果我刷新，我必须重新点击连接按钮。

10349
17:05:35.786 --> 17:05:36.544
为什么会这样。

10350
17:05:36.614 --> 17:05:47.864
或者当我刷新时，我们的网站不知道我们已经点击了启用Web 3，因为当我刷新时，我们会回到空白状态，然后我必须点击连接，这非常讨厌，非常烦人。

10351
17:05:47.864 --> 17:05:56.114
我们想添加一些功能，在我们渲染的瞬间自动地，我们继续检查，看我们是否已经连接了。

10352
17:05:56.114 --> 17:05:58.114
如果我们连接起来展示这个。

10353
17:05:58.114 --> 17:06:02.460
要做到这一点，我们可以使用另一个钩子use effect。

10354
17:06:02.460 --> 17:06:05.720
这是一个核心反应钩子。

10355
17:06:05.720 --> 17:06:12.215
我们会像这样做import use effect from react。

10356
17:06:12.215 --> 17:06:14.881
这是一个核心钩子直接从react。

10357
17:06:14.881 --> 17:06:18.360
它和使用状态是最受欢迎的。

10358
17:06:18.360 --> 17:06:36.932
我们在这门课相关的GitHub repo中留下了一些关于effect钩子的链接，我会给你们总结这个use effect的作用，我们有这个函数叫use effect，它有两个形参，第一个形参是一个函数，第二个形参是一个依赖数组。

10359
17:06:36.932 --> 17:06:44.053
这个使用效果的作用是它会不断检查依赖数组中的值。

10360
17:06:44.053 --> 17:06:51.199
如果依赖率中有任何变化，它会调用某个函数，然后在前端重新渲染。

10361
17:06:51.199 --> 17:06:58.680
举个例子，使用Morales附带了一个函数叫做iswebthree enabled或者这个变量叫做iswhatthree enabled。

10362
17:06:58.680 --> 17:07:05.760
如果我们把它添加到依赖数组中，我们在使用效果中可以做的是做console。log, hi。

10363
17:07:05.760 --> 17:07:16.886
然后我们可以让console。log iswebthree enabled，这个使用效果会做的是它会一直运行，一直运行。

10364
17:07:16.886 --> 17:07:25.815
它会监听webthree是否启用了更改，对吧?只要我们运行启用Web 3 Web 3启用就会变为true。

10365
17:07:25.815 --> 17:07:31.860
现在如果我们到前端，我们做一点刷新，我们看到高假，高假。

10366
17:07:31.860 --> 17:07:47.706
为什么我们会看到两次web 3只启用了一次?这是因为use effect的工作方式，它会自动运行在load或right或第一次运行时，然后它会运行检查值。

10367
17:07:47.706 --> 17:07:53.056
我们基本上看到这个运行了两次，它在我们加载它的第一次运行，然后它会检查值并再次运行。

10368
17:07:53.056 --> 17:07:55.124
所以我们看到了两次，尽管实际上只有一次。

10369
17:07:55.124 --> 17:07:59.091
回到这里，抱歉，我再快速重新加载一次。

10370
17:07:59.091 --> 17:08:09.386
我们点击连接，我们现在看到Hi为真，因为它看到的是3enabled的改变为真因为enabled的webthree make是enabled的返回真。

10371
17:08:09.386 --> 17:08:11.287
然后它又运行了一遍。

10372
17:08:11.287 --> 17:08:13.252
这就是它的工作原理。

10373
17:08:13.252 --> 17:08:16.405
有几种不同的方法来考虑这个问题。

10374
17:08:16.405 --> 17:08:18.829
实际上，我们甚至不需要给它一个数组。

10375
17:08:18.829 --> 17:08:22.830
如果我们不给它一个数组会发生什么?让我们刷新一下。

10376
17:08:22.830 --> 17:08:26.412
点击Connect，我们会看到它仍然运行了几次。

10377
17:08:26.412 --> 17:08:32.909
如果我们不给它数组，没有依赖数组，它会在任何重渲染的时候运行。

10378
17:08:32.909 --> 17:08:34.882
你得小心点。

10379
17:08:34.882 --> 17:08:41.173
因为你可以得到循环渲染，如果你有一些使用效果改变了一些值。

10380
17:08:41.173 --> 17:08:47.282
你还有另一个使用效果当那个值改变时重新呈现而它们都将不断地来回改变。

10381
17:08:47.282 --> 17:08:48.916
没有这样的依赖数组。

10382
17:08:48.916 --> 17:08:53.583
它会在任何东西重新呈现的时候运行我们会给它一个空白的依赖数组。

10383
17:08:53.583 --> 17:08:56.166
它只在加载时运行一次，只运行一次。

10384
17:08:56.166 --> 17:09:00.029
这里有一个空白依赖项，我们重新加载。

10385
17:09:00.029 --> 17:09:02.171
对吧?我们看到它运行了两次。

10386
17:09:02.171 --> 17:09:06.393
那实际上是因为我们在后台重新渲染一次。

10387
17:09:06.393 --> 17:09:09.960
它实际上只是运行一次但在后台还有其他事情在进行。

10388
17:09:09.960 --> 17:09:11.201
看起来它运行了两次。

10389
17:09:11.201 --> 17:09:19.879
如果我们只添加启用了的webthree，稍微刷新一下，它会做完全一样的事情，它会运行和空白时一样的时间。

10390
17:09:19.879 --> 17:09:21.774
但当我们连接时，它会在这里加上。

10391
17:09:21.774 --> 17:09:28.068
如果这是一个空白数组，刷新时，我们会看到踢出两次，应该是1。

10392
17:09:28.068 --> 17:09:30.424
但就像我说的，有些事情正在发生。

10393
17:09:30.424 --> 17:09:31.462
如果我们点击连接。

10394
17:09:31.462 --> 17:09:38.289
现在，我们看不到任何东西，因为空白依赖数组说，嘿，我只会在加载时运行一次。

10395
17:09:38.289 --> 17:09:44.807
如果数组中有我们的东西，比如是否启用web 3，它会在数组中任何东西改变时运行。

10396
17:09:44.807 --> 17:09:51.569
再次，我们会刷新连接，我们看到它再次运行，在点击连接后会刷新。

10397
17:09:51.569 --> 17:09:54.426
嗨，嗨，连接，再跑一遍。

10398
17:09:54.426 --> 17:09:56.929
这是一个小抄。

10399
17:09:56.929 --> 17:10:07.855
如果我们不给它依赖数组，它会随时运行项目re渲染中的任何东西，如果我们给它一个空白的依赖数组，它只会运行一次，或者像我们看到的，它会运行两次。

10400
17:10:07.855 --> 17:10:10.458
但那是因为我们在背景中渲染了其他东西。

10401
17:10:10.458 --> 17:10:15.600
如果我们在这个数组中给它依赖项，它就会在数组中任何东西改变的时候运行。

10402
17:10:15.600 --> 17:10:30.499
这真的很有帮助，因为通常，我们想要前端重新渲染，这个use effect会说，哦，酷，一些值改变了，我要运行这个函数，然后我要重新渲染，你的前端。

10403
17:10:30.617 --> 17:10:36.038
现在我们要用这个use effect来确保刷新时，它记得我们是连接的。

10404
17:10:36.038 --> 17:10:40.047
我们在这里怎么做呢，我们将使用这个web3启用的东西。

10405
17:10:40.047 --> 17:10:47.467
我们要做的第一件事是我们要说if is what three enabled，然后我们会返回。

10406
17:10:47.467 --> 17:10:51.650
因为如果我们已经连接到web 3，那么我们不需要做任何事情。

10407
17:10:51.650 --> 17:11:00.522
现在，如果我们没有连接到web 3，我们没有账号，我们会调用启用web 3，自动启用web 3。

10408
17:11:00.522 --> 17:11:07.392
现在如果我返回，你会看到这段代码，我总是自动调用Enable Web 3。

10409
17:11:07.392 --> 17:11:08.988
但这真的很烦人。

10410
17:11:08.988 --> 17:11:13.260
因为如果我断开连接，让我们断开所有东西。

10411
17:11:13.260 --> 17:11:23.424
刷新，它会总是调用启用Web 3，每次刷新，它会自动调用启用，甚至不需要点击连接按钮。

10412
17:11:23.424 --> 17:11:26.568
所以这对我们想要看看是否有连接是没有好处的。

10413
17:11:26.618 --> 17:11:41.635
我们这样做的方式，像我说的，我们想使用本地存储，应用程序，或者这些小东西到应用程序，我们想让我们的应用程序记住有人点击了这个连接按钮，他们连接到我们。

10414
17:11:41.635 --> 17:11:54.142
我们要做的是在下面的onClick函数中，我们不仅会调用await Enable web3，我们还会在这里存储一点记忆说，嘿，我们最近确实连接了。

10415
17:11:54.142 --> 17:12:06.674
在这下面，我们会运行window。local storage。set item, connected，逗号inject。

10416
17:12:06.674 --> 17:12:11.586
我现在要把这个注释掉，因为我的朋友会一直像这样出现。

10417
17:12:11.586 --> 17:12:26.821
这做的是，在我们的窗口中，因为如果你回到窗口，到控制台，一个类型窗口，你会看到这个巨大的窗口，我们之前展示过，这里总是有这个窗口对象。

10418
17:12:26.821 --> 17:12:38.359
我们要做window。local storage，这与。如果我们到这个应用程序部分，这个本地存储部分，那个连接到注入的set项有关。

10419
17:12:38.359 --> 17:12:53.325
我们会在这里设置一个新的键值，我们这样做是因为在未来，也许你想把它连接到Wallet connect或连接到Coinbase Wallet之类的，但我们会说注入，意思是我们连接到元掩码。

10420
17:12:53.325 --> 17:12:57.419
在next的某些版本中，Jas很难知道这个窗口变量。

10421
17:12:57.419 --> 17:13:06.369
我们可以这样做如果type of window不等于等于undefined，我们会这样做。

10422
17:13:06.369 --> 17:13:10.946
我们只是确保窗口不等于未定义存在一个窗口。

10423
17:13:10.946 --> 17:13:28.333
现在如果我回到前端，点击连接，然后连接到这里，我们会看到在应用程序中，本地存储，我们会看到我们在这里添加了这个连接注入位，我们在浏览器中存储了我们确实连接到这个。

10424
17:13:28.333 --> 17:13:36.987
现在我们已经将它添加到浏览器中，我们可以回滚到这里的使用效果，说，好的，如果它们已经连接，很好，我们就完成了。

10425
17:13:36.987 --> 17:13:40.241
但在我们做任何事之前，让我们看看他们是否有这个。

10426
17:13:40.241 --> 17:13:44.038
如果它们已经连接了，让我们运行连接位。

10427
17:13:44.038 --> 17:13:53.306
我们会说if type of window不等于undefined，因为我们要检查window对象。

10428
17:13:53.306 --> 17:14:06.369
同样，我们会说if window。local storage。get item connected, connected，如果那个connected key存在，我们会运行Enable Web 3。

10429
17:14:06.369 --> 17:14:13.832
这里有一些功能，刷新时，它会自动运行enable of three。

10430
17:14:13.832 --> 17:14:24.999
现在如果我刷新前端，我们就不用再按连接键了，因为它会说，我看到本地，每当刷新时，我们都存储了这个连接键。

10431
17:14:24.999 --> 17:14:28.573
现在，它首先检查这个，它看到它，然后运行启用的web 3。

10432
17:14:28.620 --> 17:14:34.170
现在在另一边，如果我们在这里，现在我们断开连接，然后刷新。

10433
17:14:34.170 --> 17:14:36.345
这个会显示出来，这真的很烦人。

10434
17:14:36.345 --> 17:14:39.471
每次刷新，它都会一直显示，这是我们不想看到的。

10435
17:14:39.471 --> 17:14:45.812
我们希望当我们断开连接时，我们告诉它，我们已经在这里断开了。

10436
17:14:45.812 --> 17:14:52.353
回到我们的应用中，我们能添加另一个使用效果来检查我们是否断开连接。

10437
17:14:52.353 --> 17:14:54.527
让我们创建另一个使用效果。

10438
17:14:54.527 --> 17:15:01.587
这是很昂贵的只要我们连接起来，我们说使用效果，在这里做一个小箭头括号。

10439
17:15:01.587 --> 17:15:04.455
我们随时都可以这么做。

10440
17:15:04.620 --> 17:15:06.687
我的天啊，每次保存，它都会一直跳出来。

10441
17:15:06.687 --> 17:15:08.777
我现在要把它注释掉。

10442
17:15:08.777 --> 17:15:14.794
在这里，我们想说，不管怎样，如果任何账户发生了变化，我们想运行一个重新播放。

10443
17:15:14.794 --> 17:15:17.942
莫拉莱斯也为我们提供了一些功能。

10444
17:15:17.942 --> 17:15:23.716
从user morass，我们会导入更多Alice，然后在下面这里的使用效果。

10445
17:15:23.716 --> 17:15:28.048
在这个小函数中，我们会写mirallas。

10446
17:15:28.048 --> 17:15:34.652
换了换了，我们要做点什么。

10447
17:15:34.652 --> 17:15:38.520
帐户更改时，取一个函数作为输入参数。

10448
17:15:38.520 --> 17:15:44.447
我们写入console。log，帐户，更改为帐户。

10449
17:15:44.447 --> 17:15:49.792
我们能做的就是检查这个账户是否存在。

10450
17:15:49.792 --> 17:15:57.588
我们可以说，如果account = = no，那么如果account为null，我们可以假设它们已经断开。

10451
17:15:57.588 --> 17:16:08.037
我们可以说window。local storage。remove item, connected，我们还会运行一个deactivate web three函数。

10452
17:16:08.037 --> 17:16:19.001
从Ross，去激活，web3也会运行，去激活web3，这将把web3设为enabled为false。

10453
17:16:19.001 --> 17:16:25.530
我们会断开web 3，然后我们会说console。log。

10454
17:16:25.621 --> 17:16:28.161
没有发现计数。

10455
17:16:28.161 --> 17:16:29.242
我们来试一下。

10456
17:16:29.242 --> 17:16:29.438
现在。

10457
17:16:29.438 --> 17:16:32.741
让我们回到我们的前端，我们在这里做一点刷新。

10458
17:16:32.741 --> 17:16:34.692
现在它说我们是相连的。

10459
17:16:34.692 --> 17:16:39.859
虽然在我的元掩码里，我们并没有连接，对吧?为了从头开始，你可以断开连接。

10460
17:16:39.859 --> 17:16:43.489
但是我的浏览器说，嘿，我们连上了，对吧?现在我们连接起来。

10461
17:16:43.489 --> 17:16:51.310
我们实际上是连接的，下一个连接，它会重写连接，用注入，让这个被注入。

10462
17:16:51.310 --> 17:16:57.871
然后我们删除，是的，注入，我们会刷新，比如，连接，现在它说注入。

10463
17:16:57.871 --> 17:16:58.386
好的,很酷。

10464
17:16:58.386 --> 17:17:00.496
现在我们连在一起了。

10465
17:17:00.496 --> 17:17:06.906
如果在这里，如果我只是切换帐户，让我们到帐户3，我将连接。

10466
17:17:06.906 --> 17:17:16.293
如果我们快速回到控制台，我们会说账户更改为等等等等，我也可以更改回来，我们会把账户更改为等等等等。

10467
17:17:16.293 --> 17:17:19.417
现在，回到我们的应用程序，到这里。

10468
17:17:19.417 --> 17:17:20.823
我们会断开联系。

10469
17:17:20.823 --> 17:17:24.621
现在我们把这两个都断开。

10470
17:17:24.621 --> 17:17:25.871
和断开。

10471
17:17:25.871 --> 17:17:29.653
我们会看到它现在已经从本地存储中删除了。

10472
17:17:29.653 --> 17:17:37.147
如果我们到控制台，它会说，no account，改变no, no account found，并删除它。

10473
17:17:37.147 --> 17:17:41.621
如果我点击刷新，这里什么都没发生，我可以继续连接。

10474
17:17:41.621 --> 17:17:44.454
下一个连接，我可以刷新。

10475
17:17:44.622 --> 17:17:47.081
哦，我需要回到这里重新启用这个。

10476
17:17:47.622 --> 17:17:49.392
把这个加回来。

10477
17:17:49.392 --> 17:17:50.900
但现在它可以刷新了。

10478
17:17:51.622 --> 17:17:53.638
在这里断开连接。

10479
17:17:53.638 --> 17:17:54.767
我们联系了。

10480
17:17:56.622 --> 17:18:03.168
控制台，我们可以连接的东西会弹出下次连接，我可以刷新。

10481
17:18:03.168 --> 17:18:12.543
它为我保持连接，我可以切换帐户，我可以继续，我可以切换帐户，我甚至可以断开连接。

10482
17:18:12.622 --> 17:18:15.574
它会自动为我更新，这是我们想要的。

10483
17:18:15.622 --> 17:18:24.537
现在我们做了一个更健壮的连接按钮，当我们连接时，它可以来回移动。

10484
17:18:24.622 --> 17:18:34.372
我们还需要做一件事，或者说应用程序当我们点击连接时，我们需要禁用这个按钮，对吧?我们不希望它允许它被按压。

10485
17:18:34.372 --> 17:18:43.131
我点击取消，我们还要在这里添加一个功能，我们要添加这是web3enable loading。

10486
17:18:43.131 --> 17:18:47.740
它的作用是检查Metamask是否弹出。

10487
17:18:47.740 --> 17:18:53.331
我们的按钮在点击部分之后，我们可以添加disabled。

10488
17:18:53.331 --> 17:18:58.571
=是web3enable loading，如果我们在这里加载，它会被禁用。

10489
17:18:58.622 --> 17:19:01.888
我们继续，断开，断开。

10490
17:19:02.622 --> 17:19:05.186
点击Connect，你会看到可以点击这个按钮。

10491
17:19:05.622 --> 17:19:07.622
只是让它看起来更漂亮。

10492
17:19:09.622 --> 17:19:17.571
Bada boom，棒极了，我们刚刚做了一个方式更强大的前端比我们之前的连接按钮是超级光滑。

10493
17:19:17.622 --> 17:19:19.300
它让我们可以来回翻转。

10494
17:19:19.622 --> 17:19:25.732
应用程序非常强大，知道如何处理所有这些不同的更改。

10495
17:19:25.732 --> 17:19:42.442
现在我们已经学会了如何用手动的方式来做，让我用Chiti的方式来做，在组件中，我们会创建一个新的文件头。js，我们要做的是安装这个webthree UI工具包，这是一个前端工具包，它已经为我们构建了很多这些组件。

10496
17:19:42.442 --> 17:19:47.823
我们可以通过使用这个来创建header组件和connect按钮组件。

10497
17:19:47.823 --> 17:19:52.148
为了安装它，我们会回到这里，我们会停止我们的前端。

10498
17:19:52.148 --> 17:19:56.559
我们会运行yarn, addweb3uikit，像这样。

10499
17:19:56.559 --> 17:20:03.973
再说一次，我们不想让它成为一个开发依赖项，因为它将成为我们网站的一部分，然后我们会在标题中做。

10500
17:20:03.973 --> 17:20:10.477
js，我们会import connect button from web3uitkit。

10501
17:20:10.477 --> 17:20:15.956
然后我们会导出default function header。

10502
17:20:15.956 --> 17:20:20.671
然后我们要做的就是返回一个div。

10503
17:20:20.671 --> 17:20:24.461
在这个div中，我们用next button。

10504
17:20:24.623 --> 17:20:28.023
这里有个反斜杠，这个项目不需要这个。

10505
17:20:28.023 --> 17:20:31.558
但如果我们想要非常明确，我们会说Morales off = false。

10506
17:20:31.558 --> 17:20:38.311
重申一下，我们这里并不是要连接到服务器，只是为了更明确一点。

10507
17:20:38.311 --> 17:20:43.590
这个连接按钮可以做所有事情，这个我们刚创建的手动头可以。

10508
17:20:43.590 --> 17:20:45.131
回到我们的索引。

10509
17:20:45.131 --> 17:20:56.067
Js，我们可以注释或删除这一行将import header from。dot。slash components / header。

10510
17:20:56.067 --> 17:21:00.803
我们不用手动标头，而是直接标头。

10511
17:21:00.803 --> 17:21:09.816
我们再次用yarn dev启动我们的应用，回到页面，我们在这里做一点刷新，我们现在看到我们有这个连接钱包按钮。

10512
17:21:09.816 --> 17:21:11.081
它甚至看起来好多了。

10513
17:21:11.081 --> 17:21:14.887
它也有一些很好的样式，我们可以点击连接钱包。

10514
17:21:14.887 --> 17:21:19.899
它会给我们这个小ngModel询问我们想连接到哪个钱包。

10515
17:21:19.899 --> 17:21:35.385
问我们想连接到哪面墙在我们的手动头文件中类似于设置物品连接，注入，右或钱包连接，它会为信任钱包设置连接钱包连接，它会它会将物品设置为连接钱包连接，等等。

10516
17:21:35.385 --> 17:21:38.242
所以它允许我们以不同的方式联系。

10517
17:21:38.242 --> 17:21:45.899
如果我们点击Metamask，我们继续连接这里有一些漂亮的样式它会在这里给我们钱包地址。

10518
17:21:45.899 --> 17:21:49.209
但它也让我们的钱包余额。

10519
17:21:49.209 --> 17:21:52.804
如果我们继续断开连接，我们会看到它自动断开。

10520
17:21:52.804 --> 17:21:55.481
我们就像这样连接，这样我们就可以重新连接，砰，砰。

10521
17:21:55.481 --> 17:21:59.382
如果我们换了账户，它会很聪明地知道我们在换账户。

10522
17:21:59.382 --> 17:22:01.364
我知道我用了很艰难的方式让你明白了。

10523
17:22:01.364 --> 17:22:03.442
但我想向你们展示这是怎么回事。

10524
17:22:03.442 --> 17:22:09.089
它在后台设置这个本地存储以便它知道它实际连接到哪里。

10525
17:22:09.089 --> 17:22:11.827
但是对于头部向前移动，这就是你所需要的。

10526
17:22:11.827 --> 17:22:14.521
你的生活会变得非常非常容易。

10527
17:22:14.624 --> 17:22:21.957
我们可以在标题处添加一个集中的抽签或者分散的抽奖或者任何你想要的。

10528
17:22:21.957 --> 17:22:26.558
上面写着去中心化彩票，你知道那个按钮，你好。

10529
17:22:26.558 --> 17:22:34.474
现在我们有了这个，我们还需要什么?嗯，嗯，这个应用需要做的主要事情是有一个大按钮，说进入彩票。

10530
17:22:34.474 --> 17:22:38.591
然后理想情况下，你知道，展示有多少人参加了抽奖，然后是最近的中奖者。

10531
17:22:38.624 --> 17:22:42.024
让我们继续，我们将创建一个名为lottery entry的新组件。

10532
17:22:42.024 --> 17:22:49.543
我们会抓取那个组件就像我们处理头文件一样，我们会把这个组件放到这里。

10533
17:22:49.625 --> 17:22:51.038
然后我们的应用就差不多完成了。

10534
17:22:51.625 --> 17:23:12.142
这个彩票入口组件，那个Jas，对，我们把这些放在组件里的原因是，我们可以100%把所有的代码都放在这里，让它更模块化，所以我们在未来，如果我们想要更多的页面或做其他事情，我将把它缩小一点这样我们就能更容易地看到所有的代码。

10535
17:23:12.142 --> 17:23:13.590
这是整个指标js。

10536
17:23:13.590 --> 17:23:15.053
这是整个标题。

10537
17:23:15.053 --> 17:23:41.815
我们来创建一个新的彩票入口应用这是样板代码我们将导出默认彩票入口，不好意思，是导出默认函数，彩票入口，这将是另一个组件我们将返回一些JSX HTML的东西，对吧?我们用div，然后用hi from lottery entrance, Excel。

10538
17:23:41.815 --> 17:23:46.160
现在我们做了这些，我们可以回到索引。

10539
17:23:46.160 --> 17:23:46.374
js。

10540
17:23:46.374 --> 17:23:53.198
我们可以从。点。斜杠组件导入彩票入口。

10541
17:23:53.198 --> 17:23:59.800
Slash彩票入口，把它贴在标题下面，像这样。

10542
17:23:59.800 --> 17:24:08.291
如果我们回到我们的网站，我们看到彩票入口在上面所以我们的彩票入口就在标题下面，这是我们想要的。

10543
17:24:08.291 --> 17:24:10.247
然后我们会删除这一行，Hello。

10544
17:24:10.247 --> 17:24:21.969
那么抽签入口，我们首先需要做的是什么呢?我们想要有一个函数来调用彩票来进入彩票。

10545
17:24:21.969 --> 17:24:23.297
我们来做这个。

10546
17:24:23.297 --> 17:24:30.986
现在我们回到HTML是怎么做的回想一下这个有趣的函数，但是这样做不会重新播放。

10547
17:24:30.986 --> 17:24:41.047
还有很多其他的功能像这样做不会给我们所以我们要用Morales来调用其中的一些函数，因为mirallas在React中有。

10548
17:24:41.047 --> 17:24:45.001
再说一次，它们有钩子让我们做几乎任何我们想做的事。

10549
17:24:45.001 --> 17:24:48.314
其中一个钩子叫做use web three contract。

10550
17:24:48.314 --> 17:24:59.564
它的作用是给我们一个钩子它会给我们从一个叫error returned的函数返回的数据，一个我们可以用来调用任何函数的小函数。

10551
17:24:59.626 --> 17:25:03.077
然后我们还有这些非常有用的isfetingisloading。

10552
17:25:03.077 --> 17:25:12.371
如果我们想让每个人都有UI或网站，在抓取或加载事务时做点什么，我们可以用这两个变量来做。

10553
17:25:12.371 --> 17:25:23.371
然后我们只需要给它传递契约信息，类似于ethers，它将是ABI契约地址，我们将传递函数名，然后是函数的任何参数。

10554
17:25:23.371 --> 17:25:28.559
我们将使用这里的语法将事务发送到区块链。

10555
17:25:28.626 --> 17:25:29.483
调用这些函数。

10556
17:25:30.626 --> 17:25:37.263
我们将从react mirallas进口web三合同。

10557
17:25:37.263 --> 17:25:43.400
在函数内部，当然在我返回之前，我们要说const。

10558
17:25:43.400 --> 17:25:46.376
然后我们就像在这里看到的那样。

10559
17:25:46.376 --> 17:25:55.359
现在，我们来求这个函数，我们来求这个合约函数，因为这是我们可以调用的进入彩票的函数。

10560
17:25:55.359 --> 17:26:00.576
我们会说const，运行合约函数，我们会调用这个enter raffle。

10561
17:26:00.626 --> 17:26:18.159
我们会说=，使用web3contract，我们需要传递ABI，我们需要传递契约地址，我们需要给它函数名，我们需要给它params，实际上我们知道它将是空白的。

10562
17:26:18.159 --> 17:26:20.529
但最后，我们将需要消息值。

10563
17:26:20.627 --> 17:26:26.950
因为如果我们记得，back into raffle不带任何参数，它只带这个message。value bit。

10564
17:26:26.950 --> 17:26:30.488
这就是我们要通过的。

10565
17:26:30.488 --> 17:26:34.738
那么我们怎么得到这些东西呢，我把这些留在这里。

10566
17:26:34.738 --> 17:26:38.801
但我们现在要把它注释掉，因为这是我们需要做的。

10567
17:26:38.801 --> 17:26:41.890
但我们需要把所有这些东西都放到代码中。

10568
17:26:41.890 --> 17:26:51.053
那么我们是怎么得到这些东西的呢?ABI很简单，对吧?Abi不会改变，无论在什么网络上，Abi都会保持不变。

10569
17:26:51.053 --> 17:27:00.246
如果你已经部署了你的智能合约，你知道它的确切地址，因为你已经部署到一个主网，或者部署到一个测试网，所有这些东西都不会真的改变。

10570
17:27:00.246 --> 17:27:03.272
我们可以把它硬编码到这里。

10571
17:27:03.272 --> 17:27:06.454
或者我们可以像很多人做的那样创建一个常数文件夹。

10572
17:27:06.454 --> 17:27:14.341
在这里，他们会添加API。JSON，也许他们会添加合约地址。JSON。

10573
17:27:14.341 --> 17:27:27.679
然后他们会添加一个索引。js之类的东西，我们会建立一个我们可以在本地使用我们自己的硬帽网络进行测试的应用程序，然后将它与实际测试网上的情况进行比较。

10574
17:27:27.679 --> 17:27:29.427
所以我们要让它成为网络不可知论者。

10575
17:27:29.427 --> 17:27:33.198
所以不管我们用的是什么网络前端都是一样的。

10576
17:27:33.198 --> 17:27:45.808
我们可以回去，下载一个目录到CD上，硬帽智能合约抽签免费代码营，然后旋转我们的节点，用hh节点或yarn硬帽节点。

10577
17:27:45.808 --> 17:27:49.818
我们用这个作为我们要连接的区块链。

10578
17:27:49.818 --> 17:27:55.289
问题是，如果我回到这里，我在做前端，我想，啊，如果我们做X Y或Z会更好。

10579
17:27:55.289 --> 17:28:03.447
也许我改变了一些函数的名字，等等，等等，我希望这些改变能反映在前端。

10580
17:28:03.447 --> 17:28:06.305
我希望能够这样编码我的前端。

10581
17:28:06.305 --> 17:28:12.981
由于我们是目前唯一的开发人员，我们有能力在我们都知道的地方，后端代码和前端代码。

10582
17:28:12.981 --> 17:28:19.775
我想做的是让我的生活更简单我想做的是创建一个更新前端部署脚本。

10583
17:28:19.775 --> 17:28:33.940
在我们部署完东西之后，我们运行一个小脚本它会为我们创建这个包含很多东西的常量文件夹?它会给出ABI，它会给出合同地址以及我们前端从后端可能需要的任何其他信息。

10584
17:28:33.940 --> 17:28:40.351
所以我喜欢做的是回到我的原始代码并为一个新的脚本更新这个。

10585
17:28:40.351 --> 17:28:51.503
我进入部署脚本，创建一个新文件，命名为oh two或者9999,up date front和。Jas。

10586
17:28:51.503 --> 17:28:58.471
我用99的原因很明显，是因为我们希望它始终是deploy文件夹中的最后一个脚本。

10587
17:28:58.471 --> 17:29:01.136
然后我们可以写一个连接的小脚本。

10588
17:29:01.136 --> 17:29:10.817
我们只需要写一个小脚本连接到我们的前端这样当我们部署契约时，无论链是什么，我们都能更新前端的常量文件夹。

10589
17:29:10.817 --> 17:29:18.144
现在我们来创建这个脚本我们写入module。exports = async function。

10590
17:29:18.144 --> 17:29:24.939
我们会把所有的东西都加进去，我们不需要部署任何契约，因为我们只是更新前端。

10591
17:29:24.939 --> 17:29:26.962
所以我们可以把这个的参数留为空。

10592
17:29:26.962 --> 17:29:37.179
我喜欢做的另一件事，因为有时我不关心前端，我只会在我们指定了一个。env变量时更新前端。

10593
17:29:37.179 --> 17:29:42.809
我创建一个。env变量叫做up date, front end。

10594
17:29:42.809 --> 17:29:45.006
然后设这个为真。

10595
17:29:45.006 --> 17:29:52.343
现在在我们的脚本中，我们可以说if process。E和V。update，前端。

10596
17:29:52.343 --> 17:29:57.517
我们可以说，console。log，更新前端。

10597
17:29:57.517 --> 17:30:07.200
现在回到这里，如果一个mat如果我在正确的目录中，如果我们自己的硬点击Deploy，你知道，得到这个更新前端。

10598
17:30:07.200 --> 17:30:08.596
现在我们可以更新前端。

10599
17:30:08.596 --> 17:30:09.321
我们开始做吧。

10600
17:30:09.321 --> 17:30:15.190
我要创建一个函数，叫Update contract addresses。

10601
17:30:15.190 --> 17:30:25.488
这将是我们用来更新契约地址的函数，然后我将创建一个名为update API的函数，我们将更新API和前端我们将调用这个更新契约地址。

10602
17:30:25.488 --> 17:30:31.399
我要创建一个新函数async function，更新合约地址。

10603
17:30:31.399 --> 17:30:37.488
首先，我们要拿到那个抽奖合同因为我们需要知道它的地址。

10604
17:30:37.488 --> 17:30:39.661
我们写入const, raffle = await。

10605
17:30:39.661 --> 17:30:50.547
我们会做同样的事情我们做过ethers。get contract, raffle，然后我的VS code自动导入，它不会const ethers = require Hardhead，像这样。

10606
17:30:50.547 --> 17:30:51.891
我们这里有抽奖。

10607
17:30:51.891 --> 17:31:20.968
我们要想通过这抽奖活动地址我们的前端,因为这将是一个变量,我们可能会使用很多地方,我们可以把它像const,前端位置,文件地址,等于,我们要给我们现在的相对路径,也就是你知道,如果我们看到下载目录合同明年的智能彩票,FCC,我甚至可以复制,粘贴在这里。

10608
17:31:20.968 --> 17:31:26.576
然后是常量文件夹，这里是合约地址。JSON。

10609
17:31:26.576 --> 17:31:30.926
我们来获取ABI文件，我们用const。

10610
17:31:30.926 --> 17:31:37.613
Front和bi文件将会等于这几乎是一样的。

10611
17:31:37.613 --> 17:31:39.630
我们可以复制粘贴它。

10612
17:31:39.630 --> 17:31:43.330
然后是/ API。JSON。

10613
17:31:43.330 --> 17:31:57.106
现在在更新契约地址函数中，我们可以说const，当前地址，等于我们可以在前端读取，我们可以从这个文件中读取。

10614
17:31:57.106 --> 17:31:59.480
我通常会从两个括号开始。

10615
17:31:59.480 --> 17:32:02.328
这两个文件都是JSON兼容的。

10616
17:32:02.328 --> 17:32:11.531
要读取它，我们会说JSON。parse FS。read file sync，我们需要导入const。

10617
17:32:11.630 --> 17:32:28.148
FS = require，我知道我们以前用过FS extra，但这个，我们只使用FS，它将是我们的front and addresses文件，我们将用utf8编码将它读入。

10618
17:32:28.148 --> 17:32:30.112
这就是我们的当前地址。

10619
17:32:30.112 --> 17:32:34.430
我们会用一些新地址更新当前地址列表。

10620
17:32:34.430 --> 17:32:50.788
因为我们的合同地址我们希望它是链不可知的，我们会做一些事情，比如冰场B上的地址，我们可以做31337，然后是本地主机上的地址，对，我们希望能够跟踪所有不同链上的所有不同地址。

10621
17:32:50.788 --> 17:32:58.876
回到函数中，我们写入if if network。config。chain id。

10622
17:32:58.876 --> 17:33:09.860
输入合约地址，这是配置思想，然后我们会添加这个新合约地址。

10623
17:33:09.860 --> 17:33:14.320
但在我们添加这个新地址之前，让我们检查一下它是否已经在那里了。

10624
17:33:14.320 --> 17:33:21.171
我们写入if契约地址。config。chain id。

10625
17:33:21.171 --> 17:33:29.420
to string，这太长了，我不想一直写下去，我要说const chain ID = network，配置那个chain ID。

10626
17:33:29.420 --> 17:33:33.648
到string，我们将使用chain ID。

10627
17:33:33.648 --> 17:33:42.837
如果链ID和合同地址，那么如果我们还没有，那就包括抽签。地址。

10628
17:33:42.837 --> 17:34:08.122
我们会添加这个新地址如果链ID不存在，我们会输入合约地址当前地址，等于或者假设链ID等于的当前地址然后我们会创建一个新数组，抽抽出那个地址。

10629
17:34:08.122 --> 17:34:13.104
我们说，如果链ID在当前地址中不存在，我们就会把这个新数组添加进去。

10630
17:34:13.104 --> 17:34:23.596
最后，我们已经更新了它的对象，我们要把它写回这个文件，我们写入Fs。write, file sync, front And addresses file。

10631
17:34:23.596 --> 17:34:26.854
然后是JSON。string (5)

10632
17:34:26.854 --> 17:34:31.782
我们会Stringify这个JSON对象，我们会把它写回去。

10633
17:34:31.782 --> 17:34:39.293
然后是输出标签= all的底部模块然后是前端。

10634
17:34:39.293 --> 17:34:39.763
我很酷。

10635
17:34:39.763 --> 17:34:43.737
因此，我们有一个更新契约地址的函数，但我们还需要ABI。

10636
17:34:43.737 --> 17:34:50.822
我们要做date API，我们要创建另一个函数async function, update API。

10637
17:34:50.822 --> 17:35:06.438
在这里，我们要对raffle equals await醚做完全相同的事情，raffle FX。right file, sync, front和abi。

10638
17:35:06.438 --> 17:35:11.489
它会复制粘贴到AVI文件的前端。

10639
17:35:11.489 --> 17:35:28.032
然后传递ABI，我们可以直接从这个raffle对象获取它，我们可以用raffle。interface format ethers。utils。format types。JSON。

10640
17:35:28.032 --> 17:35:36.563
如果你看醚类文档，醚类有合约点接口的东西它返回的接口不同于固体接口。

10641
17:35:36.563 --> 17:35:40.360
但它允许我们只用一行代码就能得到API。

10642
17:35:40.360 --> 17:35:51.287
后端代码中，如果运行h h deploy或h h node，我们会自动更新API。JSON中的合约地址。

10643
17:35:51.287 --> 17:35:53.336
我们来试试这个。

10644
17:35:53.336 --> 17:35:55.139
我们运行h h node。

10645
17:35:55.139 --> 17:36:00.763
我们从这个终端开始一个节点，我们将翻转到前端。

10646
17:36:00.763 --> 17:36:07.099
如果我们打开ABI to JSON，我们确实，看，我们在这个文件中有raffle API。

10647
17:36:07.099 --> 17:36:13.570
如果我们查看合同地址，我们在网络31337上看到，这是我们的第一个地址。

10648
17:36:13.570 --> 17:36:20.568
如果我们部署到不同的链上，这将被填充不同的网络id，然后是与它们相关的地址列表。

10649
17:36:20.568 --> 17:36:26.445
所以它帮助我们的前端更容易维护，更容易弹跳，更容易测试和工作。

10650
17:36:26.445 --> 17:36:35.433
现在我们已经完成了所有这些，我们可以关闭硬帽智能合约抽签免费代码营，这个硬帽项目，我们将把所有终端都放在这里。

10651
17:36:35.433 --> 17:36:46.747
我们要做的是往下，目录CD。。然后CD进入。哦，抱歉，我们实际上已经在他们的CD中了，硬帽，智能合约，抽签免费代码营。

10652
17:36:46.747 --> 17:36:50.934
然后在这个中，我们会运行hh node或yarn hardhat node。

10653
17:36:50.934 --> 17:36:57.823
现在我们有一个本地区块链运行，所以我们可以测试我们在前端做的所有事情，实际上，我要把这个移上来。

10654
17:36:57.823 --> 17:37:04.720
现在在我们的第一个区域，这里，我们有我们的前端代码运行，然后我们有区块链运行。

10655
17:37:04.720 --> 17:37:07.836
然后在这个式子中，我们要加，你知道，我们想加什么就加什么。

10656
17:37:07.836 --> 17:37:11.508
现在，我们可以继续按这个小X键来关闭面板。

10657
17:37:11.508 --> 17:37:16.775
这只是隐藏了面板，这些都还在外面，只有当你击中小垃圾桶时，它们才会被丢弃。

10658
17:37:16.775 --> 17:37:18.370
所以我们要关闭面板。

10659
17:37:18.370 --> 17:37:21.383
但所有的终端都还在运行，我保证。

10660
17:37:21.383 --> 17:37:24.508
我们说到哪了?好，回到我们的函数。

10661
17:37:24.633 --> 17:37:30.039
所以我们只是自动化了更新API的过程，然后更新我们的合同。

10662
17:37:30.039 --> 17:37:32.075
现在我们可以把这些导入到我们的文件中。

10663
17:37:32.075 --> 17:37:45.575
现在我们可以一次导入一个，就像import API，从。。斜杠常量，斜杠API，或者我们可以做一些更聪明的事情我们可以把这些导出到同一个文件中。

10664
17:37:45.575 --> 17:37:47.961
如果我们创建一个新文件，一个新索引。

10665
17:37:47.961 --> 17:37:52.500
Js，在这里，我们可以导入然后导出到这个文件中。

10666
17:37:52.500 --> 17:38:06.734
我们可以说const，合约编辑器说= require。/合约编辑器。JSON，然后const API = require。/ API。JSON。

10667
17:38:06.734 --> 17:38:13.834
然后我们会做模块。export = API和合约地址。

10668
17:38:13.834 --> 17:38:20.441
一旦我们像这样导出它们回到彩票入口，我们可以在一行中导入它们。

10669
17:38:20.441 --> 17:38:28.817
我们输入import API，逗号，合约地址from。。

10670
17:38:28.817 --> 17:38:38.602
我们可以指定文件夹而不是每个单独的文件，因为我们有这个索引。j s，它基本上代表整个文件夹。

10671
17:38:38.602 --> 17:38:42.900
回到这里，我们现在有什么?让我们取消注释这个abi。

10672
17:38:42.900 --> 17:38:43.700
好了,好了。

10673
17:38:43.700 --> 17:38:50.650
我们有ABI我们从常量，文件夹，合约地址导入它，我们有合约地址。

10674
17:38:50.650 --> 17:38:55.896
我们马上就需要指定网络ID。

10675
17:38:55.896 --> 17:39:00.117
我们这里有函数名，它将是进入抽奖的。

10676
17:39:00.117 --> 17:39:01.729
没有参数。

10677
17:39:01.729 --> 17:39:17.795
我们需要做的是如何同时获得chain ID和message。value也会改变，这是我们用Morales很容易得到的，让我们再把这一整部分注释掉，这样我就能展示我们可以导入的东西。

10678
17:39:17.795 --> 17:39:25.518
再一次，我们将从react Morales得到use Morales的书。

10679
17:39:25.635 --> 17:39:29.532
我们能做的是写入const。

10680
17:39:29.635 --> 17:39:32.809
Chain ID = use ralis。

10681
17:39:37.635 --> 17:39:47.005
我们所处的链是因为在我们的头组件中，头实际上将所有关于Metamask的信息传递给Morales提供者。

10682
17:39:47.005 --> 17:39:56.560
然后Morales提供者将它传递给那些Morales提供的标签中的所有组件集中等于使用Morales。

10683
17:39:56.635 --> 17:40:01.477
我要写一个小的控制台日志链ID因为我想让你们看看它是什么样子的。

10684
17:40:01.477 --> 17:40:22.687
如果我们做一个小的刷新,我们这里在控制台,在这里我们可以忽略这些警告,但实际上我们看到链式ID 0 x 5、好吧,因为我在溜冰场B链或Grilley链对不起,如果我切换回安全帽localhost,你应该知道如何从某有趣我们打赌如果你没有安全帽localhost和Metamask回到HTML字体我们一点。

10685
17:40:22.687 --> 17:40:23.318
好了,好了。

10686
17:40:23.318 --> 17:40:26.169
现在它会打印这个哦x等等等等。

10687
17:40:26.169 --> 17:40:28.603
这可能有点让人困惑。

10688
17:40:28.603 --> 17:40:31.409
但这是链ID的十六进制形式。

10689
17:40:31.409 --> 17:40:31.796
正确的。

10690
17:40:31.796 --> 17:40:34.183
让我们切换到以太主网。

10691
17:40:34.183 --> 17:40:38.801
现在我们读x 1，对吧?x1是1的十六进制形式。

10692
17:40:38.801 --> 17:40:43.028
chain ID是chain ID的十六进制加法。

10693
17:40:43.028 --> 17:40:45.920
我要的不是十六进制加法，我要的是实际的数字。

10694
17:40:45.920 --> 17:40:51.860
我要做的是我要说，好，chain ID，你的名字实际上是chain ID hex。

10695
17:40:51.860 --> 17:40:55.206
我们可以写console。log chain ID十六进制，但我要的是数字。

10696
17:40:55.206 --> 17:41:03.235
我们能做的是解析JavaScript内置的parse int CIN ID十六进制。

10697
17:41:03.235 --> 17:41:06.502
现在回到这里，我们来刷新一下。

10698
17:41:06.636 --> 17:41:09.120
滚动警告，我们可以看到这里的一个。

10699
17:41:09.636 --> 17:41:11.974
切换到硬帽子，localhost。

10700
17:41:14.636 --> 17:41:19.761
用Morales chain ID返回十六进制，用Parson解析得到实际数字。

10701
17:41:19.761 --> 17:41:20.323
好了,好了。

10702
17:41:20.323 --> 17:41:22.226
所以我们可以把链ID放在这里。

10703
17:41:22.226 --> 17:41:30.861
这个抽奖地址我们会经常用到，我们不妨把它放在代码的顶部，我们不会改变抽奖地址。

10704
17:41:30.861 --> 17:41:32.054
所以我们不需要把它放在钩子里。

10705
17:41:32.054 --> 17:41:35.586
从技术上讲，我们在改变网络的时候也会改变地址。

10706
17:41:35.636 --> 17:41:39.898
但我们的头应用负责重新渲染和处理所有这些。

10707
17:41:39.898 --> 17:41:41.373
我们可以把它设为常数。

10708
17:41:41.373 --> 17:41:52.055
我们可以说const, raffle address =，首先让我们检查chain ID十六进制如果有chain ID十六进制如果没有chain ID十六进制我们就做别的。

10709
17:41:52.055 --> 17:41:56.227
不好意思，我们会说链ID十六进制合同地址。

10710
17:41:56.227 --> 17:41:58.202
事实上，永远不会有链条ID妖术。

10711
17:41:58.202 --> 17:42:06.836
我们用const chain ID = Gen ID hex parsed, Parsons, chinati hex，你可能会想，这两个名字是一样的。

10712
17:42:06.836 --> 17:42:18.175
我们在上面用Morales做的是我们说，拉出下巴ID对象，然后重命名为chain ID hex在下面这里，我们说，我们要创建一个新变量chain ID。

10713
17:42:18.175 --> 17:42:23.019
我们说链ID在0处的契约地址。

10714
17:42:23.019 --> 17:42:30.567
在这里，我们说这个网络ID和这个地址，否则，我们会说不。

10715
17:42:30.636 --> 17:42:32.198
好了，我们快到了。

10716
17:42:34.636 --> 17:42:36.921
抽奖地址，我们可以把它放在这里。

10717
17:42:37.636 --> 17:42:39.540
是消息点值。

10718
17:42:42.636 --> 17:42:45.127
实际上是动态设置费用。

10719
17:42:46.637 --> 17:42:50.110
我们让入口费等于入口费，这是构造函数中的参数。

10720
17:42:50.110 --> 17:42:52.687
我们把这个叫做get入口费函数。

10721
17:42:52.687 --> 17:42:55.187
这是我们发送事务的一种方式。

10722
17:42:55.187 --> 17:43:05.390
我们还可以发送函数，其中一种方法是当彩票入口加载时，我们会运行一个函数来读取入场费值。

10723
17:43:05.390 --> 17:43:16.119
我们怎么做呢?我们可以再次使用其中一个钩子，当某些东西发生变化时，使用效果可以运行，我们只会在启用web 3的情况下尝试获得抽奖入场费。

10724
17:43:16.119 --> 17:43:22.096
所以我们能做的就是回到这里，用Morales来拉进来，这是启用的web 3。

10725
17:43:22.096 --> 17:43:32.524
我们会在函数中有使用效果，我们会说如果这是web3启用的，然后我们会试着读取。

10726
17:43:32.637 --> 17:43:36.572
我们可以继续使用这个，使用web 3，合同瓦根。

10727
17:43:36.637 --> 17:43:37.981
我们来复制粘贴这个。

10728
17:43:38.637 --> 17:43:40.162
同样的设置。

10729
17:43:44.637 --> 17:43:47.348
我们会得到入场费的。

10730
17:43:48.637 --> 17:43:49.669
领取入场费。

10731
17:43:52.637 --> 17:43:52.737
它。

10732
17:43:55.637 --> 17:43:59.565
入场费params没有什么信息，没有什么价值。

10733
17:43:59.637 --> 17:44:02.391
我们会调用这个get入口费函数。

10734
17:44:02.637 --> 17:44:06.837
现在我给你们展示如何调用合同中的一个。

10735
17:44:06.837 --> 17:44:12.121
使用web三合同，下载我们的使用效果，我们其实是要打电话领入场费的。

10736
17:44:12.121 --> 17:44:27.558
如果我们像这样调用get入口费，我们说，const某某等于get入口费然后是console。log某某，你认为会发生什么?哦，我需要导入，我需要从react导入use effect。

10737
17:44:27.638 --> 17:44:28.775
好了。

10738
17:44:33.638 --> 17:44:37.138
一些不能获得入场费的内容将是一个async函数。

10739
17:44:37.138 --> 17:44:44.304
再说一次，我们需要等待我们需要等待进入T，对吧?在我们的使用效果中有一个不能调用await的问题。

10740
17:44:44.304 --> 17:44:50.342
那么我们能做什么呢?我们可以做一个async函数，叫它update UI。

10741
17:44:50.342 --> 17:44:55.388
然后我们可以把这个放在async函数里面。

10742
17:44:55.388 --> 17:44:59.064
我们可以在它外面调用updatuui，像这样。

10743
17:44:59.064 --> 17:45:01.944
现在我们回到我们的前端，我们做一点刷新。

10744
17:45:01.944 --> 17:45:04.104
如果我们向上滚动，我们仍然什么也看不到。

10745
17:45:04.104 --> 17:45:07.037
web3是否启用，实际上是变化的。

10746
17:45:07.037 --> 17:45:11.976
这个第一次运行时，是否启用web3可能是false。

10747
17:45:11.976 --> 17:45:17.824
但当它为true时，我们想。我们想在我们的依赖数组中运行这个section。

10748
17:45:17.824 --> 17:45:35.041
我们要把这个加进去，对吧?它一开始为假的原因正是因为我们在手册头文件中所显示的?它是做什么的?首先，我们在刷新后检查，如果window。local storage get item被连接，然后我们调用Enable web3，这会使这个启用。

10749
17:45:35.041 --> 17:45:41.734
在我们的彩票入口中，它们所启用的在刷新时开始为假。

10750
17:45:41.734 --> 17:45:47.722
然后浏览器检查本地存储说，web3应该是启用的，让我们启用它并为true。

10751
17:45:47.722 --> 17:45:54.532
如果我们点击保存，然后刷新控制台，我们就能看到注销费。

10752
17:45:54.532 --> 17:45:59.573
那么我们就把这个从合同中换成入场费。

10753
17:45:59.573 --> 17:46:10.115
现在，我们可能还想在UI上显示这个入口费，如果我们让入口费，我们会说= blank。

10754
17:46:10.115 --> 17:46:17.281
我们会用这个来更新，我们会更新这个说入口费等于等待入口费。

10755
17:46:17.281 --> 17:46:17.548
酷。

10756
17:46:17.548 --> 17:46:21.092
现在我们有了一个全局变量，我们可以把它加到这里。

10757
17:46:21.092 --> 17:46:23.452
我们还可以收举重入场费。

10758
17:46:23.452 --> 17:46:26.876
括号里的整个式子，然后。

10759
17:46:26.876 --> 17:46:33.401
到字符串，我们甚至可以控制台点日志入口费用。

10760
17:46:33.639 --> 17:46:35.439
现在我们正在添加一个新的浏览器。

10761
17:46:36.639 --> 17:46:37.147
问题在这里。

10762
17:46:39.639 --> 17:46:41.389
刷新。

10763
17:46:41.639 --> 17:46:44.477
我们在UI中看不到门票。

10764
17:46:45.639 --> 17:46:46.623
控制台。注销，对。

10765
17:46:47.639 --> 17:47:07.400
在某种程度上，这里所发生的将会使用effect来重新渲染我们的浏览器?这就是我们想要的三使能从false变为true，我们的浏览器重新渲染看，一旦我们拿到入场费，我们的浏览器会重新渲染吗?不，它没有，因为入场费只是这些正常变量之一，对吧。

10766
17:47:07.400 --> 17:47:16.120
我们想把这个从一个普通变量变成一个钩子因为入口费会被更新，但它不会触发重新渲染。

10767
17:47:16.120 --> 17:47:19.832
我们想把这个改成所谓的use state钩子。

10768
17:47:19.832 --> 17:47:28.951
你可以阅读更多关于使用state钩子的文档，它类似于让入口费等于什么的，然后设置在下面。

10769
17:47:28.951 --> 17:47:31.638
但它也会为我们触发回放。

10770
17:47:31.638 --> 17:47:44.246
要做到这一点，我们实际上用const入口费用，逗号，set入口费用等于使用状态0 import使用状态也从react。

10771
17:47:44.246 --> 17:48:01.282
基本上，入口费就是我们的值，如果我们用console。log入口费，它会打印出入口费入口费将是我们调用的获取入口费的变量，入口费将是我们调用的更新或设置入口费的函数。

10772
17:48:01.282 --> 17:48:05.164
不管这个入场费变量是什么，我们都会触发一个渲染。

10773
17:48:05.164 --> 17:48:10.553
在前端，我们有状态或函数中的实际变量来更新它。

10774
17:48:10.553 --> 17:48:17.306
然后在这里的使用状态，我们给它它的初始值我们说入口费开始是零。

10775
17:48:17.306 --> 17:48:30.295
现在我们知道了，回到下面这里，我们不说入口费等于这个，我们可以说const入口费from call等于away入口费。

10776
17:48:30.295 --> 17:48:36.223
字符串，然后我们可以说，将入口费用设置为这个入口费用从调用。

10777
17:48:36.223 --> 17:48:40.425
现在当我们设置使用状态时，我们会触发一个重新渲染。

10778
17:48:40.425 --> 17:48:42.590
所以入场费实际上是会增加的。

10779
17:48:42.590 --> 17:48:47.306
到浏览器，稍微刷新一下。

10780
17:48:47.306 --> 17:48:52.623
我们可以看到入场费确实已经重新呈现在这里，我们实际上可以在这里看到。

10781
17:48:52.623 --> 17:49:00.122
我们在这里看到console。log(0)虽然我们在做console。log入口费用因为这个set入口函数还没有运行完。

10782
17:49:00.122 --> 17:49:06.990
我们删掉这一行会刷新Bada bing Bada boom，这个巨大的数字有点恶心。

10783
17:49:06.990 --> 17:49:12.213
我们甚至可能想要更新它，让它看起来更好一些。

10784
17:49:12.213 --> 17:49:17.990
同样，我们可以导入醚，从醚中导入醚。

10785
17:49:17.990 --> 17:49:26.996
在下面，我们会写一些ethers。utils。format units。

10786
17:49:26.996 --> 17:49:34.847
我们会写入会费从电话我们会写一个逗号，然后输入。

10787
17:49:34.847 --> 17:49:39.728
如果我们在前端刷新，现在我们可以看到，入场费是0。

10788
17:49:39.728 --> 17:49:39.798
1.

10789
17:49:39.798 --> 17:49:45.553
我们甚至可以把它标记为入场费，等等等等。

10790
17:49:45.641 --> 17:49:49.516
如果我们在前端做一点刷新，入场费是0。

10791
17:49:49.641 --> 17:49:51.141
E。

10792
17:49:52.641 --> 17:49:58.044
最后，我们有入场费，现在在我们的函数上使用Finally进入彩票。

10793
17:49:58.044 --> 17:49:59.793
最后把注释去掉。

10794
17:49:59.793 --> 17:50:03.034
至于信息价值，我们要用这个入场费。

10795
17:50:03.034 --> 17:50:06.926
我意识到把它存储为raw到字符串的格式更好。

10796
17:50:06.926 --> 17:50:09.941
我们要撤销刚才做过的这部分。

10797
17:50:09.941 --> 17:50:11.541
我们要把它加到下面。

10798
17:50:11.641 --> 17:50:17.149
我们要用以太，这是单位的格式，入场费，逗号，以太，像这样。

10799
17:50:17.149 --> 17:50:20.926
就像这样，让我们很快地把这个注释掉。

10800
17:50:20.926 --> 17:50:23.493
至少在UI中，它显示为0。

10801
17:50:23.493 --> 17:50:23.558
1.

10802
17:50:23.558 --> 17:50:29.053
但在后端，我们会把它保存为原始的，有很大的价值。

10803
17:50:29.053 --> 17:50:37.891
我们有这个入场费，我们可以取消注释，我们可以抓取这个入场费，放到这里。

10804
17:50:37.891 --> 17:50:40.348
我们需要做一个按钮来做这个。

10805
17:50:40.348 --> 17:50:45.810
现在，我们想让我们的代码能够正常工作，即使我们连接到一个受支持的链。

10806
17:50:45.810 --> 17:50:51.391
所以在我们添加这个之前，如果我们从安全帽切换到Aetherium主网，做一点刷新。

10807
17:50:51.391 --> 17:50:57.159
这里我们会得到一个错误，因为我们调用了get入口费。

10808
17:50:57.159 --> 17:51:08.048
连接到一个不存在的地址，对吧?所以它会非常困惑，就像，嘿，你在这里做什么?让我们在这里添加一个小按钮，这样我们就可以实际进入抽奖。

10809
17:51:08.048 --> 17:51:15.642
在我们这样做之前，让我们确保我们只能在有抽奖地址的情况下调用函数。

10810
17:51:15.642 --> 17:51:17.570
我们来抽奖吧。

10811
17:51:17.570 --> 17:51:21.012
我们再做一次三元算符。

10812
17:51:21.012 --> 17:51:27.378
只有在这个抽奖地址有效的情况下，对吧?它不是，不，我们把所有的代码都加在这里。

10813
17:51:27.378 --> 17:51:30.536
我们会说，如果抽奖地址存在，我们会做一些事情。

10814
17:51:30.536 --> 17:51:35.835
现在，我们可以复制粘贴这一行，粘贴到这里。

10815
17:51:35.835 --> 17:51:38.823
否则，我们会写div。

10816
17:51:38.823 --> 17:51:41.459
卓越div，关闭它。

10817
17:51:41.642 --> 17:51:43.963
保存重新格式化，很好。

10818
17:51:46.642 --> 17:51:47.158
检测到。

10819
17:51:50.642 --> 17:51:50.829
在这里。

10820
17:51:50.829 --> 17:51:53.079
这里有个小div，很不错。

10821
17:51:53.642 --> 17:51:56.803
这个div，让我们添加一个按钮。

10822
17:52:00.642 --> 17:52:04.782
这里有一个小按钮，我们会让它写着，进入抽奖。

10823
17:52:05.642 --> 17:52:09.007
比如onclick，我们会做一些JavaScript。

10824
17:52:09.642 --> 17:52:14.086
做一些JavaScript，我们想调用一个async函数。

10825
17:52:14.086 --> 17:52:17.583
我知道双括号会让人困惑，对吧。

10826
17:52:17.583 --> 17:52:22.372
这些括号允许我们在HTML或JSX中使用JavaScript。

10827
17:52:22.372 --> 17:52:27.314
这些括号代表这个函数，它将是一个async函数。

10828
17:52:27.314 --> 17:52:31.182
我们会说，等待，进入抽奖。

10829
17:52:31.182 --> 17:52:32.559
就是这样。

10830
17:52:32.559 --> 17:52:34.455
让我们回到最前面。

10831
17:52:34.455 --> 17:52:36.308
现在我们有一个小的抽奖函数。

10832
17:52:36.308 --> 17:52:41.508
刷新时，确保账户在这里重置。

10833
17:52:41.508 --> 17:52:45.811
下面是设置，高级，重置账户，是的。

10834
17:52:45.811 --> 17:52:46.980
我按ENTER抽奖。

10835
17:52:46.980 --> 17:52:48.815
Metamath确实出现了。

10836
17:52:48.815 --> 17:52:51.573
我们可以继续确认。

10837
17:52:51.573 --> 17:52:55.643
太好了，我们现在可以抽奖了。

10838
17:52:55.643 --> 17:52:59.443
我们在这方面做得非常好。

10839
17:52:59.643 --> 17:53:01.258
如你所见，我们刚刚弹出了这个窗口。

10840
17:53:02.643 --> 17:53:21.159
对吧?如果用户一直在看这个，然后说，好了，它通过了吗?或者我们失败了，就像，刚刚发生了什么?我们要做的是创建所谓的通知，对吧?我们希望弹出一个小窗口说，嘿，你发送了交易，干得好，我们要使用库。

10841
17:53:21.159 --> 17:53:26.708
我们会通过UI Kit使用web, UI Kit中有一些通知我们可以继续使用。

10842
17:53:26.708 --> 17:53:33.543
如果你找到这个互动的东西，就在他们的GitHub里，这里有很多东西。

10843
17:53:33.543 --> 17:53:36.938
你可以点击和玩不同的按钮和不同的东西。

10844
17:53:36.938 --> 17:53:40.857
你甚至可以去文档查看每一个。

10845
17:53:40.857 --> 17:53:42.642
你可以去展示代码。

10846
17:53:42.642 --> 17:53:48.785
你可以复制粘贴代码到你的项目中，做任何你想做的样式等等。

10847
17:53:48.785 --> 17:54:07.861
回到app。js中，我们会添加import，不，to vacations provider from web3uikit在Morales provider内部，但在组件外部，我们会做notificationprovider notificationprovider像这样添加它。

10848
17:54:07.861 --> 17:54:11.108
它是Morales提供者通知提供者组件。

10849
17:54:11.108 --> 17:54:18.239
把组件包装在这个通知中，那是通知提供者而不是通知。

10850
17:54:18.239 --> 17:54:23.410
这将允许我们在彩票入口中发出通知。

10851
17:54:23.410 --> 17:54:35.660
回到我们的彩票入口，我们会滚动到顶部，我们会导入一个钩子那些通知叫我们知道，从web3uitkit到场合。

10852
17:54:35.660 --> 17:54:41.187
这个使用通知返回给我们这个叫做调度的东西。

10853
17:54:41.187 --> 17:54:45.258
所以我要说const dispatch = use notification。

10854
17:54:45.258 --> 17:55:05.234
use notification返回这个分派，这个分派就像一个小弹出框它会给我们下面这里，当我们调用这个enter raffle时，我们会在这里给它一些参数，我们会说onsuccess，这些函数带有onsuccess, onComplete，带有错误，等等。

10855
17:55:05.234 --> 17:55:14.177
当这个函数成功时，我们会做handle success，我们会创建一个新的handle success函数来处理success。

10856
17:55:14.177 --> 17:55:18.244
这是来自未来的帕特里克回来展示另外一点。

10857
17:55:18.244 --> 17:55:34.170
我知道我提到过，但添加这个on error非常好，冒号error console。log error对于任何运行契约函数，甚至是读取，如果任何运行契约函数出错，你不会知道。

10858
17:55:34.170 --> 17:55:40.390
当然要把这个加到所有的运行契约函数中。logerror。

10859
17:55:40.390 --> 17:55:46.355
在上面这里，在返回之前，我们会创建一个新的const句柄success。

10860
17:55:46.355 --> 17:55:54.660
我们说这是一个async函数async函数接受事务作为输入参数。

10861
17:55:54.660 --> 17:55:58.872
记住，你可以把函数变成常数变量。

10862
17:55:58.872 --> 17:56:06.295
我们写入await TX。Wait 1，我们会等待事务通过。

10863
17:56:06.295 --> 17:56:10.721
然后我们会创建另一个函数handhandle new notification dx。

10864
17:56:10.721 --> 17:56:14.660
你们马上就会明白我为什么要这样做。

10865
17:56:14.660 --> 17:56:20.895
我们会说const和Linoone notification，这将是一个同步函数因为我们不需要它是异步的。

10866
17:56:20.895 --> 17:56:25.454
我们会调用这个dispatch，我们会设置这个notification。

10867
17:56:25.454 --> 17:56:29.502
我们会说通知或分派，然后我们会在这里添加参数。

10868
17:56:29.502 --> 17:56:33.395
它接受一个对象作为参数，我们说type info。

10869
17:56:33.395 --> 17:56:48.020
Message是transaction complete，标题是TX notification。

10870
17:56:48.020 --> 17:56:58.395
何塞，肖恩，我们会说，顶部是然后图标，我们会说一个小铃铛。

10871
17:56:58.645 --> 17:57:08.200
你可以在这里找到所有这些东西，键入图标位置，你可以读到所有不同的参数你可以用它来设置handle new notification handle success。

10872
17:57:08.200 --> 17:57:18.195
我们说，一旦交易成功，就输入raffle，调用这个handle success函数，它会调用handle new notification。

10873
17:57:18.195 --> 17:57:18.445
好的。

10874
17:57:18.445 --> 17:57:22.359
你会明白为什么我们把它分成两个而不是只处理成功。

10875
17:57:22.359 --> 17:57:23.628
还要做调度。

10876
17:57:23.628 --> 17:57:30.119
当我们按下enter raffle按钮时，我们会调用enter raffle issuccessful，我们会调用handle success。

10877
17:57:30.119 --> 17:57:36.058
我们会等待事务完成，是的，它传递一个参数给handle success函数。

10878
17:57:36.058 --> 17:57:40.118
然后我们要做的是调用handle new notification。

10879
17:57:40.118 --> 17:57:44.171
我们会调度。我们会启动其中一个通知。

10880
17:57:44.171 --> 17:57:46.978
回到这里，点击回车抽奖。

10881
17:57:46.978 --> 17:57:49.478
Metamath会弹出确认。

10882
17:57:49.646 --> 17:57:54.868
在它完成后，我们得到这个奇妙的事务通知，事务完成。

10883
17:57:54.868 --> 17:57:59.201
我们让用户知道，很好，你提交了一个事务。

10884
17:57:59.201 --> 17:57:59.917
伟大的工作。

10885
17:57:59.917 --> 17:58:01.069
这很好。

10886
17:58:01.069 --> 17:58:04.547
我们在这里为用户提供了一些有用的内容。

10887
17:58:04.547 --> 17:58:11.026
现在让我们在这里再加一点这样用户就能知道这个抽奖还发生了什么。

10888
17:58:11.026 --> 17:58:15.712
但是我们需要显示更多的数据，让我们显示一下有多少人参加了这个抽奖。

10889
17:58:15.712 --> 17:58:17.908
这个游戏里有多少人。

10890
17:58:17.908 --> 17:58:19.153
我们可以这样做。

10891
17:58:19.153 --> 17:58:22.449
当然，因为我们有很多玩家的命令。

10892
17:58:22.449 --> 17:58:24.951
我们可能还想获得最近的获胜者。

10893
17:58:24.951 --> 17:58:26.323
我们也可以这样做。

10894
17:58:26.323 --> 17:58:33.083
在上面这里，我们会复制这个get入口费，我们会创建另一个叫做get num players。

10895
17:58:33.083 --> 17:58:37.435
这将调用go back to raffle。soul。

10896
17:58:37.435 --> 17:58:43.301
它会调用get number of players我们把它叫做同样的东西。

10897
17:58:43.301 --> 17:58:47.120
获取玩家数量，我们将调用并获取玩家数量。

10898
17:58:47.120 --> 17:58:48.747
为了储存这个值。

10899
17:58:48.747 --> 17:58:50.441
再来看看顶部。

10900
17:58:50.646 --> 17:58:56.201
我们将复制这一行，粘贴到右边我们将选择非玩家。

10901
17:58:56.201 --> 17:58:58.899
然后我们会写setnum players。

10902
17:58:58.899 --> 17:59:01.917
然后再复制这一行。

10903
17:59:01.917 --> 17:59:05.476
最近的赢家，所以我们用最近的赢家。

10904
17:59:05.646 --> 17:59:17.046
Winner会做Set，最近的Winner，然后我们再复制这个，而不是获取数字玩家会做get获取最近的Winner。

10905
17:59:17.046 --> 17:59:26.521
我们称它为，get近期赢家，get近期赢家，我们要做的不仅仅是入场费，我们要得到所有东西。

10906
17:59:26.521 --> 17:59:35.980
我们可以说const num players，从callequals，我们会做一个权重，得到玩家的数量。

10907
17:59:35.980 --> 17:59:41.754
到字符串，然后我们用setsetnum，玩家会这样做。

10908
17:59:41.754 --> 17:59:45.953
我们会写setnum players, num players from call。

10909
17:59:45.953 --> 17:59:55.286
然后我们还会做const recent winner from call这将是await get recent winner。

10910
17:59:55.286 --> 17:59:59.614
我们可能需要把这个用绳子包起来但我觉得我觉得没必要。

10911
17:59:59.614 --> 18:00:02.504
我们将setrecent winner粘贴到这里。

10912
18:00:02.504 --> 18:00:05.697
现在我们有了很多选手，我们又增加了一位最近的冠军。

10913
18:00:05.697 --> 18:00:06.997
让我们回到这里。

10914
18:00:06.997 --> 18:00:08.959
我们要收入场费。

10915
18:00:08.959 --> 18:00:13.334
我们来看看玩家人数。

10916
18:00:13.334 --> 18:00:30.432
我们会增加玩家的数量，我们怎么称呼它?我的天啊，我们叫设置雇主两次哦，它叫非玩家，向下滚动玩家将是非玩家，然后我们会选最近的赢家。

10917
18:00:30.647 --> 18:00:33.693
然后我们会加入最近的获胜者。

10918
18:00:33.693 --> 18:00:34.318
太棒了。

10919
18:00:35.647 --> 18:00:36.115
费用为0。

10920
18:00:40.647 --> 18:00:45.563
如果我们继续进入抽奖元数据就会弹出。

10921
18:00:45.647 --> 18:00:46.947
我们去确认一下。

10922
18:00:48.647 --> 18:00:51.066
我们会完成交易的。

10923
18:00:53.647 --> 18:00:55.414
玩家数量已更新

10924
18:00:56.647 --> 18:01:02.721
这有点烦人，让我们再次进入抽奖，我们将确认交易完成。

10925
18:01:02.721 --> 18:01:04.373
但这并没有重现。

10926
18:01:04.373 --> 18:01:04.663
正确的。

10927
18:01:04.663 --> 18:01:07.898
我们想要设置一些东西以便自动渲染。

10928
18:01:07.898 --> 18:01:11.381
猜猜我们要怎么处理我们之前讲过的成功。

10929
18:01:11.381 --> 18:01:16.862
没错，所有这些更新UI的东西，我们都能从使用效果中拉出来。

10930
18:01:16.862 --> 18:01:19.920
所以我们要把它全部复制删除。

10931
18:01:19.920 --> 18:01:23.848
我们要让它成为一个独立的函数，像这样。

10932
18:01:23.848 --> 18:01:35.555
然后在句柄success中，每当成功的事务通过，我们都会更新UI ?因此，handle success handled new notification，我们会更新白色。

10933
18:01:35.555 --> 18:01:38.862
现在回到这里，我们进入抽奖。

10934
18:01:38.862 --> 18:01:43.020
让我们确认一下，我们看到我们得到了5，我们得到了transaction Notification。

10935
18:01:43.020 --> 18:01:46.138
现在我们想测试一下，在这里获得一个最近的赢家。

10936
18:01:46.138 --> 18:01:52.203
在我们的硬帽项目中，我们能做的是创建一个新脚本。

10937
18:01:52.203 --> 18:01:56.016
实际上我已经为你们创建了它，它将模拟通灵VRF。

10938
18:01:56.016 --> 18:01:57.760
这是对守门员的嘲笑。

10939
18:01:57.760 --> 18:02:01.548
所有这些都和我们的测试所做的差不多。

10940
18:02:01.548 --> 18:02:08.873
如果您现在想暂停并自己查看它，请在这里暂停并添加这个mock off链，它既是keepers又是VRF。

10941
18:02:08.873 --> 18:02:11.616
或者你可以直接去GitHub回购。

10942
18:02:11.616 --> 18:02:14.448
去GitHub上的第九课复习就可以了。

10943
18:02:14.448 --> 18:02:20.460
它已经在脚本中了到脚本马尔可夫链中，你可以复制粘贴到这里。

10944
18:02:20.460 --> 18:02:22.981
因为我想测试一下最近的赢家。

10945
18:02:22.981 --> 18:02:39.494
在我的智能合约彩票中，我们会做yarn，硬帽运行脚本，斜杠模拟，链破折号测试网络本地主机，我们会模拟基本上从维护中选择一个赢家请求ID 1，我们在本地网络上。

10946
18:02:39.494 --> 18:02:41.954
好吧，让我们假设最近的冠军是某某人。

10947
18:02:41.954 --> 18:02:48.093
我们能做的是在这里刷新一下，我们能看到我们更新了一个winner。

10948
18:02:48.093 --> 18:02:48.489
繁荣。

10949
18:02:48.649 --> 18:02:50.225
现在我们要清理UI。

10950
18:02:51.649 --> 18:02:52.165
有几件事。

10951
18:02:53.649 --> 18:02:55.470
这一部分。

10952
18:02:59.649 --> 18:03:10.960
因为它让我有点困惑，这个onsuccess并没有检查交易是否有块确认，它只是检查交易是否成功发送到Metamask。

10953
18:03:10.960 --> 18:03:15.601
因此onsuccess检查一个事务是否成功发送了Metamask。

10954
18:03:15.601 --> 18:03:25.550
这就是为什么在另一个函数中，我们用TX。wait 1因为这是等待事务被确认的部分。

10955
18:03:25.649 --> 18:03:36.631
现在我们使用Morales来制作一旦我们调用嘲讽脚本，我必须刷新浏览器来查看这里的获胜者，对吧，玩家的数量显然被重置为零，这很好。

10956
18:03:36.631 --> 18:03:37.823
这并不理想。

10957
18:03:37.823 --> 18:03:43.377
理想情况下，我们希望UI在某些事件被触发时自动更新。

10958
18:03:43.377 --> 18:03:46.479
在我们的抽奖合同中，我们放出这个事件。

10959
18:03:46.479 --> 18:03:49.993
而不是在我们的代码中等待成功。

10960
18:03:49.993 --> 18:03:59.460
我们可以做的是，我们可以设置一个部分来监听被触发的事件，并相应地更新前端。

10961
18:03:59.460 --> 18:04:03.438
有了这些知识，我们还可以监听发出的winner事件。

10962
18:04:03.438 --> 18:04:14.149
我们可以更新我们的前端而不是刷新这是你的提示是的，你想看看你现在是否可以添加这个，我强烈建议你这样做。

10963
18:04:14.149 --> 18:04:17.131
我们基本上完成了所有的功能。

10964
18:04:17.131 --> 18:04:28.486
哇，你从这一点中学到了很多东西，对吧?我们学过使用效果使用莫拉莱斯，所有这些挂钩，所有这些东西，我们有一个前端很好地处理与智能合约的交互。

10965
18:04:28.486 --> 18:04:30.582
唯一的问题是，它看起来真的很丑。

10966
18:04:30.582 --> 18:04:32.446
这有点恶心。

10967
18:04:32.446 --> 18:04:36.096
让我们让这个看起来好一点。

10968
18:04:36.096 --> 18:04:39.334
在构建这些前端时，有两件事需要考虑。

10969
18:04:39.334 --> 18:04:49.857
还有组件库，比如我们正在使用的web3uitkit，它给我们提供组件，给我们提供代码块，比如这个连接按钮它已经为我们格式化了。

10970
18:04:49.857 --> 18:04:55.188
还有一些CSS库可以帮助我们格式化剩下的东西。

10971
18:04:55.188 --> 18:04:57.582
我们正在使用这些组件库中的一个。

10972
18:04:57.582 --> 18:05:02.602
我们还将使用这些格式化库中的一个，我们将要使用的库是tailwind。

10973
18:05:02.602 --> 18:05:06.824
我们使用顺风CSS的原因是它非常流行。

10974
18:05:06.824 --> 18:05:12.846
如果你想学习CSS，有一些很棒的资源你可以用来学习CSS web三所学校是我用过很多次的一个。

10975
18:05:12.846 --> 18:05:25.830
这门课的GitHub repo中会有一个链接这样你就能让你的网站在格式化时看起来更漂亮但我们实际上会使用顺风因为它会让我们做CSS的东西更容易。

10976
18:05:25.830 --> 18:05:28.518
因为我们要用下一个Jas的顺风。

10977
18:05:28.650 --> 18:05:32.850
实际上，这里有一个很棒的小指南，安装顺风与下Jas。

10978
18:05:32.850 --> 18:05:36.277
我们基本上会继续做下去。

10979
18:05:36.277 --> 18:05:40.462
此链接可在与本课程相关的GitHub回购中获得。

10980
18:05:40.462 --> 18:05:43.132
我们已经创建了我们的项目我们已经在项目中植入了种子。

10981
18:05:43.132 --> 18:06:05.317
现在我们要安装顺风npm安装破折号D，因为我们使用的是纱线，我们要做纱线或者打开这个，绿色的新纱线，添加破折号Dev，粘贴这三个在顺风CSS, post CSS和自动修复器这三个将基本组成下一个Jas的顺风。

10982
18:06:05.317 --> 18:06:10.412
一旦我们有了这些，我们基本上会init tailwind并为tailwind创建一个配置文件。

10983
18:06:10.412 --> 18:06:17.175
我们会做yarn tailwind CSS它会做p yarn tailwind CSS init dash p会运行它。

10984
18:06:17.175 --> 18:06:30.451
这将给我们这个post CSS。config。j s和这个tailwind。config。j s我们要做的就是点击这个复制按钮，然后更新我们的tailwind。

10985
18:06:30.451 --> 18:06:31.051
配置。

10986
18:06:31.051 --> 18:06:39.234
js的顺风Jas，这样它就会说，所有这些东西，Pages中的任何东西。

10987
18:06:39.234 --> 18:06:39.400
js。

10988
18:06:39.400 --> 18:06:40.811
ts。JSX或TSX。

10989
18:06:40.811 --> 18:06:47.370
这些分量中的任何东西，这两个文件夹中的任何东西都被认为是顺风双位数。

10990
18:06:47.370 --> 18:06:48.973
我们想在这两个文件夹上使用顺风。

10991
18:06:48.973 --> 18:06:53.831
然后我们将把顺风指令添加到全局CSS文件中。

10992
18:06:53.831 --> 18:07:02.952
如果我们返回到styles Global我们会用addtailwind base覆盖这里的所有东西并在tailwind utilities中添加顺风组件。

10993
18:07:02.952 --> 18:07:06.184
这使得我们的全局CSS文件使用顺风。

10994
18:07:06.184 --> 18:07:19.576
现在，你会看到一个未知的规则，我们能做的是我们能去组件，我们能做的是我们能找到这个post CSS语言支持扩展，粘贴到这里，让我们来安装它。

10995
18:07:19.576 --> 18:07:23.401
现在这些小下划线消失了，这很好。

10996
18:07:23.401 --> 18:07:27.984
现在，像往常一样，我们可以只执行NPM，运行Dev并开始为我们的div添加顺风。

10997
18:07:27.984 --> 18:07:37.635
tailwind所做的是允许我们在div中设置所有东西为类名，然后在这些类名中设置一些非常简单的文本。

10998
18:07:37.635 --> 18:07:40.023
让我们来看看智能合约抽签。

10999
18:07:40.023 --> 18:07:41.395
我们只是顺风而行。

11000
18:07:41.395 --> 18:07:43.719
所以它已经更新了一些。

11001
18:07:43.719 --> 18:07:44.989
让我们在这里更新头文件。

11002
18:07:44.989 --> 18:07:45.481
好吧，让我们看看。

11003
18:07:45.481 --> 18:07:48.352
我们想给我们的头球一个顺风的边界。

11004
18:07:48.352 --> 18:07:50.752
我们会快速搜索一下。

11005
18:07:50.752 --> 18:08:03.160
看看边界，我们可以看到所有这些边界，比如边界宽度边界这个边界说我们想在底部有一个边界，我们可以看到我们可以在底部有一个边界，就像这样。

11006
18:08:03.160 --> 18:08:06.838
让我们在底部做一个宽度为两个像素的边框。

11007
18:08:06.838 --> 18:08:08.479
我们只计算边界b2。

11008
18:08:08.479 --> 18:08:16.493
所以我要复制边界B为边界b2，我要保存它我们需要做的是我们的CSS和所有生效的东西。

11009
18:08:16.493 --> 18:08:18.524
来吧，把前端给杀了。

11010
18:08:18.652 --> 18:08:19.906
然后我们用纱线戴夫重新运行。

11011
18:08:20.652 --> 18:08:21.152
现在结束。

11012
18:08:21.152 --> 18:08:24.009
让它稍微刷新一下，好，很好。

11013
18:08:24.652 --> 18:08:25.861
这里有一点边界。

11014
18:08:27.652 --> 18:08:29.889
只是还不是很多。

11015
18:08:31.652 --> 18:08:34.152
添加顺风到我去扩展。

11016
18:08:35.652 --> 18:08:36.080
顺风。

11017
18:08:36.080 --> 18:08:37.901
这里有顺风延伸。

11018
18:08:38.652 --> 18:08:40.109
我要在这里加一大堆东西。

11019
18:08:40.652 --> 18:08:44.385
Flex, Flex row。

11020
18:08:44.652 --> 18:08:51.274
我们要做去中心化的彩票，h 1代表头像1。

11021
18:08:51.274 --> 18:08:55.433
用类名=，我们用y破折号。

11022
18:08:55.433 --> 18:09:01.652
我们让它填充form的顶部在X轴4上填充X。

11023
18:09:01.652 --> 18:09:05.329
我们将它设为粗体，并将文本设为3xl大小。

11024
18:09:05.329 --> 18:09:07.152
我们把所有东西都变大。

11025
18:09:07.152 --> 18:09:07.568
酷。

11026
18:09:07.568 --> 18:09:12.861
然后我们再做一个，我们将连接按钮包装在div中。

11027
18:09:12.861 --> 18:09:19.485
我们写入div class name =，然后给它一个自动左距。

11028
18:09:19.485 --> 18:09:20.818
我们还要做py。

11029
18:09:20.818 --> 18:09:24.071
填充y，填充x。

11030
18:09:24.071 --> 18:09:26.200
看看我们做了什么。

11031
18:09:26.200 --> 18:09:26.683
好的。

11032
18:09:26.683 --> 18:09:34.033
如果我们缩小一点，我们可以看到，如果我们把这个也关闭，我们可以看到连接按钮在这边。

11033
18:09:34.033 --> 18:09:35.553
它们就像这样分开了。

11034
18:09:35.553 --> 18:09:36.486
我觉得这看起来不错。

11035
18:09:36.486 --> 18:09:45.846
我们将保留这个现在我们将回到抽签入口，我们将稍微改变一下，我们将说div类名= P。

11036
18:09:45.846 --> 18:09:50.081
五，我们会让按钮看起来很漂亮。

11037
18:09:50.081 --> 18:09:54.541
我们说类名= background blue 500。

11038
18:09:54.541 --> 18:10:00.429
鼠标悬停时，它会显示，背景蓝700。

11039
18:10:00.653 --> 18:10:06.319
现在如果我这样说，当我们把鼠标悬停在它上面时，它看起来有点不同，这很好。

11040
18:10:06.319 --> 18:10:21.903
我们设文本为白色，字体为粗体，给它一些白色填充，给它一些x填充，给它一个圆角，给它一个左距自动，现在看起来好多了，对吧?这样漂亮多了。

11041
18:10:21.903 --> 18:10:29.938
我们会在这里做一些基本的CSS让它看起来更漂亮一些，但这本身已经让这个彩票按钮看起来更酷了。

11042
18:10:29.938 --> 18:10:32.415
这里有一些我们没有添加的功能。

11043
18:10:32.415 --> 18:10:36.153
我们需要添加一个disabled，就像我们之前做的那样。

11044
18:10:36.153 --> 18:10:42.707
在我们的抽奖中，就像我说的，是加载和抓取。

11045
18:10:42.707 --> 18:10:46.342
我们的事务都没有加载或抓取，我们将禁用它。

11046
18:10:46.342 --> 18:10:51.025
我们说isloading或isfetch这将被禁用。

11047
18:10:51.025 --> 18:10:57.753
对吧?回到前面，点击回车，点击确认，我们可以为它添加CSS。

11048
18:10:57.753 --> 18:11:06.161
但当事务正在加载时，它们将不能再点击按钮，这是我们想要做的另一件事，即加载和取回。

11049
18:11:06.161 --> 18:11:11.838
当它在加载或取回时，我们可能希望它在我们点击它时有一个小的旋转的东西。

11050
18:11:11.838 --> 18:11:13.068
土豆泥就会冒出来。

11051
18:11:13.068 --> 18:11:18.054
我们可以确认，但如果它有一个小旋转的东西会很酷，对吧。

11052
18:11:18.054 --> 18:11:24.082
你通常可以用谷歌来添加旋转之类的东西，你会得到一些东西。

11053
18:11:24.082 --> 18:11:29.654
但是你可以，你可以从我的代码中复制粘贴这个，我会给你展示这一节我是怎么做的。

11054
18:11:29.654 --> 18:11:33.145
我们要说的是，if is loading or is fetch。

11055
18:11:33.145 --> 18:11:39.864
我们会一直使用三元运算符，然后在这里，我们要做一点div。

11056
18:11:39.864 --> 18:11:47.879
否则，我们会为加载或取回做一个不同的div，我们会在这里添加一个小旋转的东西。

11057
18:11:47.879 --> 18:11:54.330
我们要添加类名=。

11058
18:11:54.654 --> 18:11:59.240
如果我们在加载，我们会添加这个小旋转的东西，我马上会给你们展示它是什么样子的。

11059
18:11:59.240 --> 18:12:02.916
如果我们没有加载，我们就会做enter，抽奖。

11060
18:12:02.916 --> 18:12:07.412
我们会回到最前面，看到答案抽奖，我们会点击按钮。

11061
18:12:07.412 --> 18:12:11.130
现在我们有了这个可爱的小旋转装置，确认交易通过。

11062
18:12:11.130 --> 18:12:12.526
所以任何东西都消失了。

11063
18:12:12.654 --> 18:12:12.850
好了。

11064
18:12:12.850 --> 18:12:14.866
我们把它们放在不同的直线上。

11065
18:12:15.654 --> 18:12:25.404
这样做的话，它们会在不同的线上。

11066
18:12:25.404 --> 18:12:35.992
现在热潮，入场费，数量玩家最近中奖，一旦抽奖现在就会确认交易完成，玩家数量已经上升，我们已经做到了。

11067
18:12:35.992 --> 18:12:37.298
现在看起来好多了。

11068
18:12:37.298 --> 18:12:42.011
它显然不是完美的，但它比我们之前看到的肿块更容易阅读。

11069
18:12:42.011 --> 18:12:48.955
我想给你们看这个的原因是给你们一个基础让这些看起来更好。

11070
18:12:48.955 --> 18:12:52.455
这绝对不是一门CSS课程。

11071
18:12:52.655 --> 18:12:53.173
哦,哇。

11072
18:12:53.173 --> 18:12:55.024
好吧，这太了不起了。

11073
18:12:56.655 --> 18:12:57.311
我们真的很喜欢。

11074
18:12:59.655 --> 18:13:08.018
这很糟糕，Larry，让我们谈谈如何部署它，这部分是可选的，因为我要部署一些B级的东西部署到测试集会花很长时间。

11075
18:13:08.018 --> 18:13:10.691
所以我们要把合同用在B上。

11076
18:13:10.691 --> 18:13:14.690
然后我们将把我们的网站部署到托管提供商。

11077
18:13:14.690 --> 18:13:26.589
首先，让我们简单讲一下托管提供商，如果我们想托管我们刚刚创建的漂亮网站，有很多方法可以使用for cell或谷歌Cloud或AWS来部署它。

11078
18:13:26.655 --> 18:13:26.861
荨麻。

11079
18:13:28.655 --> 18:13:31.163
我们可以在不同的地方部署应用程序。

11080
18:13:31.655 --> 18:13:47.474
关于这些，这些都是集中式部署的地方，拥有一个集中式部署应用程序仍然是非常重要的，对吧?如果我们再看一遍以太扫描以太扫描是一个集中的应用程序在一天结束的时候，但它仍然是我们经常使用的一个。

11081
18:13:47.474 --> 18:13:50.051
然而，如果我们想要一个去中心化的前端。

11082
18:13:50.051 --> 18:13:51.534
这就有点难了。

11083
18:13:51.534 --> 18:14:01.565
对我们来说更重要的是我们的后端，我们的智能合约是去中心化的，对吧?这是最重要的一点，因为这将使用户能够以去中心化的方式与我们的逻辑进行交互。

11084
18:14:01.565 --> 18:14:04.467
但也许我们也希望前端去中心化。

11085
18:14:04.467 --> 18:14:18.058
在某种程度上，我们仍然会使用像VSL这样的集中服务来部署一个应用程序，我将向你们展示为什么当我们到达那里的时候，现在有一些特性，如果没有一个真正可靠的集中式后端，它们真的很难实现。

11086
18:14:18.058 --> 18:14:26.229
重要的是要记住我们的后端，我们合同的逻辑是基于去中心化的区块链。

11087
18:14:26.229 --> 18:14:38.714
因此，即使我们将前端托管在一个集中式宿主提供程序上，使用某种类型的集中式数据库使前端更易于使用，应用程序的逻辑也是分散的。

11088
18:14:38.714 --> 18:14:40.708
这是最重要的部分。

11089
18:14:40.708 --> 18:14:46.591
我稍后会给你们一些工具，以及如何引入更多这些丰富的特性。

11090
18:14:46.656 --> 18:14:51.600
如果您选择这样做，那么将在前端添加一个集中式组件。

11091
18:14:51.600 --> 18:14:55.703
这是要记住的，取决于你想要怎样的架构。

11092
18:14:55.703 --> 18:15:04.588
所以在这样做的时候，一定要确保后端部署的智能合约是在其中一个区块链上去中心化的。

11093
18:15:04.656 --> 18:15:09.215
现在，我们将在后面的部分中学习一些中心化的方法。

11094
18:15:09.215 --> 18:15:16.539
现在，让我们学习如何以一种更分散的方式部署这个前端。

11095
18:15:16.656 --> 18:15:20.281
我们将要使用的工具叫做IPFS。

11096
18:15:20.656 --> 18:15:23.910
让我稍微解释一下IPFS是如何工作的。

11097
18:15:24.656 --> 18:15:27.881
分布式分散数据结构。

11098
18:15:29.656 --> 18:15:30.124
区块链。

11099
18:15:30.124 --> 18:15:31.670
但它和区块链很相似。

11100
18:15:32.656 --> 18:15:32.956
虽然。

11101
18:15:35.656 --> 18:15:37.740
让我来解释一下这是如何运作的。

11102
18:15:38.656 --> 18:15:42.480
在这个网站上是如何工作的，会有一个链接到这个和这个课程相关的GitHub回购。

11103
18:15:42.480 --> 18:15:44.722
但我们给你我的基本看法。

11104
18:15:44.722 --> 18:15:50.338
我们有代码，或者文件，或者别的什么，我们有一些数据。

11105
18:15:50.338 --> 18:15:57.946
现在我们知道，当你有任何东西的时候，你可以哈希那个东西，你可以哈希那个数据，对吧，所以你可以得到一个唯一的输出。

11106
18:15:57.946 --> 18:16:00.558
这是IPFS做的第一件事。

11107
18:16:00.656 --> 18:16:05.370
它哈希我们的数据得到一个唯一的哈希值，只指向那个数据。

11108
18:16:05.370 --> 18:16:08.465
是的，大量的代码文件，大量的文本。

11109
18:16:08.465 --> 18:16:15.323
是的，你可以把所有这些都编码到一个哈希函数中，你的IPFS节点为你做这个哈希。

11110
18:16:15.323 --> 18:16:26.538
地球上的每一个IPFS节点都有完全相同的哈希函数，有点像区块链，对吧，它们都运行相同的规范，相同的规范。

11111
18:16:26.538 --> 18:16:30.721
我们可以哈希IPFS节点上的数据并得到这个唯一的输出。

11112
18:16:30.721 --> 18:16:43.046
我们能做的是将数据或代码，或文件或其他东西固定到节点上，我们有一些数据，我们得到它的唯一哈希值，它所做的就是托管这些数据并拥有这些哈希值。

11113
18:16:43.046 --> 18:16:48.312
就是这样，我们的节点连接到其他IPFS节点的网络。

11114
18:16:48.312 --> 18:16:55.657
所以IPFS节点有一个庞大的网络，它们非常轻，比其他区块链节点轻得多。

11115
18:16:55.657 --> 18:16:57.180
他们都互相交谈。

11116
18:16:57.180 --> 18:17:00.088
如果我问网络，嘿，我想得到这个散列。

11117
18:17:00.088 --> 18:17:02.108
所有这些节点会相互通信。

11118
18:17:02.108 --> 18:17:07.588
最终他们会到达我们的节点，说，哦，我找到了一个有这个散列的节点。

11119
18:17:07.657 --> 18:17:08.736
这是与之相关的文件。

11120
18:17:09.657 --> 18:17:30.818
好吧，这有点集中，因为我们在一个节点上有数据，对吧?你是对的，事情是这样的，其他节点能做的是他们会说，数据看起来很酷，我想让它保持，他们能做的是固定你的散列，固定你的数据，他们会在他们的节点上得到你的数据的副本。

11121
18:17:30.818 --> 18:17:32.950
你可以一直这样做。

11122
18:17:32.950 --> 18:17:40.829
所以你很容易允许整个网络在去中心化的意义上轻松复制任何代码或任何数据。

11123
18:17:40.829 --> 18:17:42.173
它们非常容易向上旋转。

11124
18:17:42.173 --> 18:17:56.017
使用IPFS非常容易，这使得它与区块链截然不同它不能做智能合约，没有执行，它只能存储IPFS只能进行去中心化存储。

11125
18:17:56.017 --> 18:18:13.954
现在的问题是为了让我们的数据真正去中心化，需要另一个节点来固定我们的数据，对吧?因为如果我们是唯一的IPFS节点有这个散列，它就集中在我们的节点上，如果我们的节点坏了，数据就没了，网络就不能再访问这些数据了。

11126
18:18:13.954 --> 18:18:18.238
我们以后会讨论让别人固定你的数据的策略。

11127
18:18:18.238 --> 18:18:24.948
但就目前而言，这是我们托管数据的一种方式，我们可以发送代码并将其置于去中心化的上下文中。

11128
18:18:24.948 --> 18:18:38.229
不像区块链，区块链中的每个节点都有整个区块链的副本IPFS节点可以选择它们想要固定的数据，它们不能执行任何操作。

11129
18:18:38.229 --> 18:18:49.443
你可以有一个IPFS节点，半兆字节，你可以有一个IPFS节点，几tb，这取决于节点操作符，有多少数据，他们想固定什么数据。

11130
18:18:49.443 --> 18:18:52.443
现在我们知道了IPFS。

11131
18:18:52.658 --> 18:19:00.447
让我们把这个奇妙的应用程序部署到IPFS中，这样任何人都可以使用它，任何人都可以连接到它。

11132
18:19:00.447 --> 18:19:02.432
只要节点是向上的。

11133
18:19:02.432 --> 18:19:05.496
你准备好了吗?好了，兴奋起来吧。

11134
18:19:05.658 --> 18:19:10.122
我们首先要做的是Manuel Wait，因为我要向你们展示如何安装IPFS。

11135
18:19:10.122 --> 18:19:10.916
并与IPFS合作。

11136
18:19:10.916 --> 18:19:19.824
点击开始，有很多种方式可以安装和使用IPFS，你可以通过桌面应用程序获取它，通过命令行。

11137
18:19:19.824 --> 18:19:29.708
然后我们还可以在浏览器中添加IPFS比如brave或者Firefox这个IPFS路由器是自动构建的。

11138
18:19:29.708 --> 18:19:45.594
但如果使用像Chrome这样的东西，你可能需要添加一个小伙伴，因为我们想做的是我们实际上可以使用那些小散列作为网站的URL，对吧，所以我们想能够把那个URL放在浏览器中并连接到那个节点或那段代码。

11139
18:19:45.659 --> 18:19:50.309
我们要做的是让你安装IPFS桌面，你要点击它。

11140
18:19:50.309 --> 18:19:53.184
当你这样做的时候，你应该能够打开IPFS。

11141
18:19:53.184 --> 18:19:59.003
现在，如果你安装它，你可能会得到这个小东西，在你上面部分的这个小框。

11142
18:19:59.003 --> 18:20:04.059
否则，您可能可以在IPFS桌面中打开它，并将其视为普通的桌面应用程序。

11143
18:20:04.059 --> 18:20:15.790
一旦你安装了它，你可能会看到IPFS在运行，你可以重启停止，你可以做所有这些，我们会到文件部分，我们会看到一个像这样的小弹出框。

11144
18:20:15.790 --> 18:20:21.103
这里有很多东西，因为我用IPFS已经有一段时间了，现在，你可能没有数据。

11145
18:20:21.103 --> 18:20:23.896
我们来导入一些文件。

11146
18:20:23.896 --> 18:20:30.201
也许现在我们只导入。config。js，对吧?没关系，输入点东西就行了。

11147
18:20:30.201 --> 18:20:35.298
在这里，我们有next。config。js或者其他你导入的文件。

11148
18:20:35.298 --> 18:20:38.820
我们能做的就是复制CID。

11149
18:20:38.820 --> 18:20:42.303
我们可以在浏览器中查看。

11150
18:20:42.303 --> 18:20:53.278
如果我们输入IPFS。。斜杠，然后粘贴进去，按回车键，我们就能让浏览器访问到实际渲染的IPFS url。

11151
18:20:53.278 --> 18:20:59.709
如果使用brave，你可以使用brave本地IPFS节点或者让我们继续下载这个IPFS伙伴。

11152
18:20:59.709 --> 18:21:05.150
我们会得到IPFS companion，还有Chrome brave的Firefox安装，等等等等。

11153
18:21:05.150 --> 18:21:11.337
我要去Chrome商店为brave下载，我们要点击添加到brave添加扩展。

11154
18:21:11.337 --> 18:21:13.628
但是一旦你下载了它，你会得到像这样的东西。

11155
18:21:13.660 --> 18:21:21.315
甚至在一个小的浏览器上，我们可以看到导入，我们可以看到关于节点的东西，如果我们点击节点，我们会看到非常相似的设置。

11156
18:21:21.315 --> 18:21:27.250
但是现在我们在浏览器中有了同伴，我们可以复制Cid那个散列。

11157
18:21:27.250 --> 18:21:33.755
勇敢，我们可以使用勇敢本地IPFS节点，它会自动被放到文件中。

11158
18:21:33.755 --> 18:21:45.392
现在，如果IPFS同伴对你不起作用，你不能看到像谷歌Chrome或其他浏览器里面的URL，你能做的就是使用IPFS网关。

11159
18:21:45.392 --> 18:21:55.326
现在使用网关，实际上并不是直接通过IPFS请求数据，而是通过另一个服务器请求数据，而另一个服务器通过IPFS请求数据。

11160
18:21:55.326 --> 18:22:00.088
但如果访问这些文件有问题，可以使用网关。

11161
18:22:00.088 --> 18:22:10.535
我们要做的是HTTPS，斜杠IPFS，然后把哈希代码粘贴到这里。

11162
18:22:10.535 --> 18:22:12.802
你就能看到你的档案了。

11163
18:22:12.802 --> 18:22:16.184
如果你这样做，你甚至不需要IPFS陪伴。

11164
18:22:16.184 --> 18:22:18.831
所以我们将把我们的网站部署到IPFS。

11165
18:22:18.831 --> 18:22:28.860
所以任何人都可以把这个钉在，我们现在将有能力有一个廉洁的，不可篡改的网站，这真是太棒了。

11166
18:22:28.860 --> 18:22:34.625
我们要先学习如何用错误的方法来做，然后我们要用一个工具让我们做起来容易得多。

11167
18:22:34.660 --> 18:22:38.266
好的，首先，我们来看看我们的网站。

11168
18:22:39.660 --> 18:22:41.437
想要部署到B溜冰场，请随意。

11169
18:22:41.660 --> 18:22:47.406
记住要确保你的合同处理相应的文件更新。

11170
18:22:47.406 --> 18:22:47.744
好的。

11171
18:22:47.744 --> 18:22:51.661
接下来，Jas拥有创建静态网站的能力。

11172
18:22:51.661 --> 18:22:56.818
这是一个很重要的术语我们要做一个静态网站。

11173
18:22:56.818 --> 18:23:02.580
目前，我们不希望我们的网站与任何服务器的东西纠缠在一起。

11174
18:23:02.661 --> 18:23:13.038
我们不希望它与任何服务器的东西纠缠在一起的原因是如果我们的网站与服务器的东西一起运行，我们将它部署到IPFS, IPFS没有能力运行任何代码，它只是托管代码。

11175
18:23:13.038 --> 18:23:16.040
如果我们的前端有任何服务器的东西，它就不能工作。

11176
18:23:16.040 --> 18:23:23.582
现在，在它当前的状态下，IPFS无法进入我们的项目并知道该做什么，对吧，它不知道如何进行纱线开发不能进行纱线开发。

11177
18:23:23.582 --> 18:23:27.497
所以我们需要把我们所有的代码放到它的静态等等物中。

11178
18:23:27.497 --> 18:23:30.385
为了做到这一点，我们要做纱线构建。

11179
18:23:30.385 --> 18:23:36.915
如果我们再看一下我们的package。JSON，它附带这个构建，它只会运行下一个构建。

11180
18:23:36.915 --> 18:23:44.693
运行这个构建命令将构建我们的代码，这被称为生产构建，在这里创建一个优化的生产构建。

11181
18:23:44.693 --> 18:23:47.398
我们会得到像这样的东西。

11182
18:23:47.398 --> 18:23:49.168
我们可以看到下面这个点。

11183
18:23:49.168 --> 18:23:53.594
静态的，自动渲染为静态HTML不使用初始道具。

11184
18:23:53.661 --> 18:23:58.902
如果我们使用下一个Jas会附带一些基于服务器的应用程序。

11185
18:23:58.902 --> 18:24:00.350
我们的静态构建不起作用。

11186
18:24:00.350 --> 18:24:07.333
实际上，你会看到，当我们运行yarn时，如果你有非静态的东西，它就会失败。

11187
18:24:07.333 --> 18:24:09.422
所以让我们继续尝试纱线的下一个出口。

11188
18:24:09.422 --> 18:24:13.906
看看它是否失败，它没有失败，我们现在有了一个新文件夹。

11189
18:24:13.906 --> 18:24:19.273
这是我们的文件夹，这是纯静态代码我们可以在IPFS上使用。

11190
18:24:19.273 --> 18:24:24.511
在后面的部分中，我将向您展示当您不使用这些静态内容时它是什么样子的。

11191
18:24:24.511 --> 18:24:27.947
Morales和next Jas都可以选择不使用静态代码。

11192
18:24:27.947 --> 18:24:30.025
我们要记住这一点。

11193
18:24:30.025 --> 18:24:33.695
现在我们有了这个out文件夹，我们可以回到IPFS。

11194
18:24:33.695 --> 18:24:38.599
我们可以导入一个文件夹，我们会导入整个文件夹在这里。

11195
18:24:38.599 --> 18:24:42.062
点击导入按钮，进入文件夹。

11196
18:24:42.062 --> 18:24:46.102
我是在明年的智能合约抽签中选出的。

11197
18:24:46.102 --> 18:24:49.062
现在我们要上传这个到IPFS节点。

11198
18:24:49.062 --> 18:24:51.694
一旦完成，我们会得到这个小的复选标记。

11199
18:24:51.694 --> 18:24:55.407
我们可以浏览IPFS文件，看看这里的输出。

11200
18:24:55.407 --> 18:25:00.950
我们能做的是，把它固定在节点上，我们把它固定在本地节点上。

11201
18:25:00.950 --> 18:25:06.339
现在一旦它启动了，我们可以复制CID，回到勇敢或铬或其他。

11202
18:25:06.339 --> 18:25:11.989
输入IPFS冒号/斜杠，粘贴进去。

11203
18:25:11.989 --> 18:25:17.017
我们马上就进入了浏览器中的智能合约抽奖。

11204
18:25:17.017 --> 18:25:32.328
我们看到嗨来自彩票，没有检测到抽奖地址，因为现在我设置我的方法是它只与我们本地的安全帽工作，让我们连接我们的Metamask我们点击连接按钮，连接，瞧，我们又回到了原来的地方。

11205
18:25:32.328 --> 18:25:38.758
但是由于我们的数据存储在IPFS中，只要我们的节点运行确认，我们就可以进入抽奖。

11206
18:25:38.758 --> 18:25:42.912
我们可以看到我们在本地浏览器中得到了什么。

11207
18:25:42.912 --> 18:25:46.349
这是惊人的。

11208
18:25:46.662 --> 18:25:51.793
现在我已经向您展示了如何做到这一点，这是将代码添加到IPFS的手动方法。

11209
18:25:51.793 --> 18:25:58.412
让我给你们展示一下将代码添加到IPFS的更简单的方法我们将访问这个叫做fleek HQ的网站。

11210
18:25:58.412 --> 18:25:59.537
快去吧。

11211
18:25:59.537 --> 18:25:59.724
有限公司

11212
18:25:59.724 --> 18:26:09.876
说到这里，我要关掉我的IPFS伴注因为使用brave时有些奇怪的地方现在我们是here@flickr。

11213
18:26:09.876 --> 18:26:10.400
fleek。

11214
18:26:10.400 --> 18:26:16.803
Co使将网站和应用程序部署到新的开放网络变得容易，无需许可，无需信任，不受审查等。

11215
18:26:16.803 --> 18:26:20.663
我喜欢把它看作是我们网站的自动部署。

11216
18:26:20.663 --> 18:26:24.433
此外，它还做了一些事情来帮助解决这个问题。

11217
18:26:24.433 --> 18:26:28.372
我讲的是如何让其他节点固定我们的数据。

11218
18:26:28.372 --> 18:26:30.098
这对我们很有帮助。

11219
18:26:30.098 --> 18:26:31.646
我来给大家演示一下。

11220
18:26:31.646 --> 18:26:33.324
让我们开始吧，我们来注册。

11221
18:26:33.324 --> 18:26:35.968
为什么你不知道呢，你可以在GitHub上登录。

11222
18:26:35.968 --> 18:26:39.996
如果你有GitHub，一定要在这里用GitHub登录。

11223
18:26:39.996 --> 18:26:45.012
因为我们将使用GitHub来帮助我们自动部署。

11224
18:26:45.012 --> 18:26:47.741
所以我们将授权舰队与我们的GitHub工作。

11225
18:26:47.741 --> 18:26:51.598
你已经授权了你的GitHub，让我们继续添加一个新的网站或添加新的网站。

11226
18:26:51.598 --> 18:26:56.469
现在我们可以使用舰队来自动部署网站，一旦我们把它们推送到我们的GitHub。

11227
18:26:56.469 --> 18:26:59.694
所以我们可以再次来到我们的GitHub。

11228
18:26:59.694 --> 18:27:03.072
点击加号按钮，我们会新建一个仓库。

11229
18:27:03.072 --> 18:27:08.951
我们将称之为Jas智能合约，抽奖免费代码营。

11230
18:27:08.951 --> 18:27:13.452
我们将使它公开，创建存储库。

11231
18:27:13.452 --> 18:27:16.329
让我们把所有这些代码推到GitHub。

11232
18:27:16.329 --> 18:27:18.281
我们以前做过一次，再来一次。

11233
18:27:18.281 --> 18:27:29.490
我们用gitadd，我们用一个点，然后我们用gitcommit - m，比如初始提交之类的。

11234
18:27:29.490 --> 18:27:40.600
我们输入gitremote, addorigin，然后抓取URL，粘贴到这里。

11235
18:27:40.600 --> 18:27:44.818
然后我们写gitpush origin, main。

11236
18:27:44.818 --> 18:27:49.464
现在我们回到我们的应用程序，在这里我们可以做的是回到我们的fleek。

11237
18:27:49.464 --> 18:28:00.401
连接到GitHub，我们会说，only select repository，我们只会做这个next js应用，我们会安装一个Authorize。

11238
18:28:00.401 --> 18:28:01.712
授权好了。

11239
18:28:01.712 --> 18:28:08.351
现在我们要选择一个回购我们已经选择了一个回购，我们要选择这个应用程序。

11240
18:28:08.351 --> 18:28:10.926
我们将使用IPFS作为我们的托管服务。

11241
18:28:10.926 --> 18:28:13.378
现在我们要在这里添加我们的信息。

11242
18:28:13.378 --> 18:28:15.397
我们要用主分支。

11243
18:28:15.397 --> 18:28:16.463
这是回购。

11244
18:28:16.463 --> 18:28:20.276
我们的框架会是下一个Jas。

11245
18:28:20.276 --> 18:28:22.130
我们接下来做fleek。

11246
18:28:22.130 --> 18:28:24.008
Jas，我们用的是纱线。

11247
18:28:24.008 --> 18:28:30.264
我们会做yarn install，然后yarn run build，然后yarn run export。

11248
18:28:30.264 --> 18:28:36.125
如果你想，你也可以只做纱线，纱线构建和纱线运行输出，这是一样的。

11249
18:28:36.125 --> 18:28:44.760
发布目录会被取出然后我们点击Deploy site, yarn，下一个export，这是最后一个命令，不是yarn，是run, export。

11250
18:28:44.760 --> 18:28:48.138
事故做错了，你去检查一下部署。

11251
18:28:48.138 --> 18:28:55.356
点击这个，进入部署设置，然后编辑设置，然后把它改为yarn。

11252
18:28:55.356 --> 18:28:57.017
接下来，导出保存。

11253
18:28:57.017 --> 18:29:04.914
然后我们会回到部署并触发部署，如果你做错了这只是一个学习的机会让你知道部署后设置在哪里。

11254
18:29:04.914 --> 18:29:12.140
这个会做的是部署，它会运行这三个命令yarn build, yarn export，它会运行所有东西。

11255
18:29:12.140 --> 18:29:15.051
然后它将在IPFS上为我们两个部署一个站点。

11256
18:29:15.051 --> 18:29:21.975
它会给我们一个常规的URL我们可以用它来做规范。

11257
18:29:21.975 --> 18:29:29.772
当这个部署时，你会在下面看到我们在交易提议中有一个叫做file coin di D的东西Cid IPFS。

11258
18:29:29.772 --> 18:29:32.936
就像我说的，我们需要其他人来管理节点。

11259
18:29:32.936 --> 18:29:39.931
文件币实际上是一个区块链，它可以帮助您固定数据，并使用去中心化存储来实现这一点。

11260
18:29:39.931 --> 18:29:47.321
fleek帮助你创建这些交易，帮助你用这个文件币固定你的数据区块链文件币绝对是一个值得一看的。

11261
18:29:47.321 --> 18:29:50.310
过了一段时间，你可能要等一会儿。

11262
18:29:50.310 --> 18:30:00.315
一旦完成，得到一个部署的小网站，我们回到托管，我们点击我们的东西我们可以看到这里有一个小网站。

11263
18:30:00.315 --> 18:30:10.488
如果我们点击它，我们会得到一个正常的链接和网站交互的URL，你甚至会看到这个小IPFS它会连接到你的IPFS节点。

11264
18:30:10.488 --> 18:30:22.566
另外，我们向下滚动到这里我们能看到当前的IPFS哈希，我们可以把它插入Bada bing，我们有一个IPFS部署的应用程序。

11265
18:30:22.665 --> 18:30:27.465
现在酷的是，假设我做了一些改变，你知道，我将去彩票入口。

11266
18:30:27.465 --> 18:30:33.923
我要做的是，滚动到底部最近的获奖者，我要新建一个div。

11267
18:30:33.923 --> 18:30:46.474
关闭div，我们保存gteadd。gitcommit - m，添加一个。gtepush origin mean。

11268
18:30:46.665 --> 18:30:49.798
在GitHub中，我们会刷新，添加一个。

11269
18:30:50.665 --> 18:30:53.353
最近加了一个，回去看看fleek。

11270
18:30:54.665 --> 18:31:02.126
点击我们刚刚做的部分进入部署，你会看到一个新的部署正在进行。

11271
18:31:02.126 --> 18:31:07.288
它会自动部署你的新网站，它会自动为你的新数据创建一个新的IPFS散列。

11272
18:31:07.288 --> 18:31:12.327
但是，它还是会在这个神圣的鸟上，你知道，不管你的URL是什么。

11273
18:31:12.327 --> 18:31:15.117
这只是一个IPSs的路由器。

11274
18:31:15.117 --> 18:31:19.569
没有IPFS连接的人也可以连接到这个。

11275
18:31:19.569 --> 18:31:28.447
现在我的应用完成了，用fleek自动推送，我们可以看到我的应用中post了什么。

11276
18:31:28.447 --> 18:31:34.536
现在，就像我说的，文件币不会成为一种技术，我们会深入介绍我们自己。

11277
18:31:34.536 --> 18:31:38.749
但就像我刚才说的，IPFS确实有这个限制。

11278
18:31:38.749 --> 18:31:47.411
它没有数据持久性，你必须让人固定你的数据，以便它保持分布式和去中心化。

11279
18:31:47.411 --> 18:31:53.416
File coin是一个专门用于保存这些数据的区块链，既分散又持久。

11280
18:31:53.416 --> 18:31:56.072
为了让我们更好地理解文件币。

11281
18:31:56.072 --> 18:31:58.563
我们请到了阿里来给我们概述一下。

11282
18:31:58.666 --> 18:31:59.838
把它拿走，艾莉。

11283
18:32:00.666 --> 18:32:07.599
我是filecoin基金会的开发人员倡导者，该基金会与协议实验室和IPFS密切合作。

11284
18:32:07.666 --> 18:32:12.142
提醒一下，协议实验室是我们的研发部门。

11285
18:32:13.666 --> 18:32:18.607
为真正开放和民主的互联网和网络创造工具和技术。

11286
18:32:18.607 --> 18:32:25.993
它正在构建一些基本的工具，比如IPFS和文件币，这是两个独立的项目来实现它。

11287
18:32:25.993 --> 18:32:33.208
希望今天，因为你们是来建设的，我想传授给你们开始这两个项目所需的知识和工具。

11288
18:32:33.208 --> 18:32:42.156
所以，任何在这个生态系统或科技领域摸混过的人都会知道，数据是我们日常生活中绝对必不可少的一部分。

11289
18:32:42.156 --> 18:32:52.253
毫不奇怪，这也是网络三和网络一中一个增长非常快的领域，这是最基本的一点，也是去中心化网络栈的基本需求之一。

11290
18:32:52.253 --> 18:33:05.158
所以目前的集中化模式，基本上是由于互联网上缺乏身份层，只有少数几家大公司提供存储，只有少数实体为授权目的保存我们的数据。

11291
18:33:05.158 --> 18:33:18.899
这是一个明显的问题，作为数据挖掘的攻击载体，没有数据，就会通过不安全的服务泄露给第三方，同时也会产生数据弹性问题。

11292
18:33:18.899 --> 18:33:24.070
因此，每次这些公司的服务器出现故障，整个服务就会瘫痪，我们肯定看到过这种情况。

11293
18:33:24.070 --> 18:33:43.867
这就引出了一个问题，为什么我们不在设计网页的时候就考虑到我们需要的自主性和弹性呢?我们如何以一种既符合互联网作为知识共享和合作的开放场所的最初愿景，又符合web三的使命的方式来存储数据。

11294
18:33:43.867 --> 18:33:47.479
这些就是我们用IPFS和文件币解决的核心问题。

11295
18:33:47.479 --> 18:33:54.602
首先，IPFS是一个用于存储和访问文件、文件夹、网站、应用程序和数据的分布式系统。

11296
18:33:54.667 --> 18:34:04.381
它被设计成即使在行星之间的网络中也能工作，所以它是分布式的，它没有中央权威服务器，它被设计成首先离线，以适应环境。

11297
18:34:04.381 --> 18:34:07.446
它也不仅仅是另一个点对点网络的花哨名称。

11298
18:34:07.446 --> 18:34:14.042
因为IPFS协议的优点是它使用标准来寻址网络上的内容。

11299
18:34:14.042 --> 18:34:29.081
IPFS是独特的，因为它不使用传统的方法，我们可能从网上熟悉，比如那些位置部分，指向一个特定的HTTP地址，你的内容可能可用，也可能不存储在那里。

11300
18:34:29.081 --> 18:34:41.572
IPFS使用内容寻址，所以内容寻址意味着每一块数据，每一个模因，甚至整个文件系统都有它自己独特的可加密验证的指纹，你可以这么称呼它。

11301
18:34:41.572 --> 18:34:50.340
因此，如果您更改了主图像的一个像素，那么与它相关的内容ID或Cid也会更改。

11302
18:34:50.340 --> 18:34:54.068
重要的是，这个哈希函数也是可升级的。

11303
18:34:54.068 --> 18:34:59.702
假设量子计算突破了当前的安全哈希算法，我们可以升级我们使用的标准。

11304
18:34:59.702 --> 18:35:04.810
这意味着您将始终获得由IPFS返回的相同内容。

11305
18:35:04.810 --> 18:35:06.635
正如你所期望的那样。

11306
18:35:06.635 --> 18:35:16.468
所以这是非常重要的，因为当你不需要关心数据从哪里来的时候，你就向大规模分布式存储系统开放了网络。

11307
18:35:16.468 --> 18:35:18.068
你好,权力下放。

11308
18:35:18.068 --> 18:35:23.068
所以现在我们有了一个非常重要和有价值的协议，可以实现大规模分发。

11309
18:35:23.068 --> 18:35:27.603
它还提供了数据的可验证性，以服务和检索web上的内容。

11310
18:35:27.603 --> 18:35:33.244
这不仅仅是针对web 3，而是针对所有的web或技术用例。

11311
18:35:33.244 --> 18:35:41.001
问题是，这也是早期互联网也面临的问题，谁来确保网络上所有数据的持久性和持久性。

11312
18:35:41.001 --> 18:35:48.603
所以，除非你每天24小时都在运行自己的节点，或者你的内容非常受欢迎，或者其他节点决定无私地存储你的数据。

11313
18:35:48.603 --> 18:35:56.110
因为我认为这很重要，那么这些数据就会变得不可靠因为它们不再活跃地驻留在网络的任何节点上。

11314
18:35:56.110 --> 18:36:02.600
因此，为了避免这种情况，你也可以求助于固定服务，你可以付费保存你的内容的副本。

11315
18:36:02.668 --> 18:36:07.356
不幸的是，这样做的问题是，我们正朝着数据集中化的方向发展。

11316
18:36:07.356 --> 18:36:13.630
我们用这个解决方案创建了新的数据仓库，失去了我们正在寻找的不信任和弹性。

11317
18:36:13.669 --> 18:36:22.106
在文件币出现之前，这是一个糟糕的解决方案，这也是它们最初出现的原因，但我们想要一个更好的解决方案。

11318
18:36:22.106 --> 18:36:24.469
这就是文件币的用武之地。

11319
18:36:24.469 --> 18:36:37.954
到目前为止，货币架构设计利用加密经济激励模型和加密证明，以确保数据持久存储，高度可靠和可验证。

11320
18:36:37.954 --> 18:36:42.294
它还使用这些加密证明来支持基于智能合约的持久性。

11321
18:36:42.294 --> 18:36:47.439
这意味着它被设计成像数据所有者希望的那样永久。

11322
18:36:47.439 --> 18:36:49.454
这是你的数据，所以是你的选择。

11323
18:36:49.454 --> 18:36:53.097
它还旨在实现互联网规模的容量。

11324
18:36:53.097 --> 18:37:10.346
它是目前世界上最大的分布式存储网络拥有超过1800万兆兆字节的可用容量，这显然是135份欧盟核项目的拷贝，欧洲核子研究中心的数据，这是一种有趣的事实。

11325
18:37:10.346 --> 18:37:19.259
由于市场经济的原因，它的文件币也被设计成在定价上保持高度竞争。

11326
18:37:19.259 --> 18:37:21.914
这要归结于存储协议。

11327
18:37:21.914 --> 18:37:26.135
因此，为了使这个网络可行，filecoin使用存储协议。

11328
18:37:26.135 --> 18:37:33.446
其中包括两种主要的共识机制，确保对系统中良好参与者的奖励和对不良参与者的惩罚。

11329
18:37:33.446 --> 18:37:40.356
因此，当您与一个或多个存储提供者达成协议以存储重要数据时，提供者会生成复制证明。

11330
18:37:40.356 --> 18:37:50.566
因此，这证明了存储提供者在一段时间内存储原始数据的唯一副本，以确保该数据被持久保存。

11331
18:37:50.566 --> 18:37:58.447
这些存储提供商必须证明他们仍然拥有该客户端数据的随机子集，并且他们创建了空间时间的证明。

11332
18:37:58.447 --> 18:38:05.161
这些证明这个时空的证明是存储在区块链上的。

11333
18:38:05.161 --> 18:38:07.936
任何人在任何时候都可以验证这是正确的。

11334
18:38:07.936 --> 18:38:18.884
它也构成了奖励或惩罚矿工的机制，因为你必须把Phil放在网络上，才能成为存储提供商。

11335
18:38:18.884 --> 18:38:25.911
因此，当一个存储协议到期时，用户可以选择让它到期或续签协议。

11336
18:38:25.911 --> 18:38:30.336
如果您选择续订，那么提供者将再次出价托管该内容。

11337
18:38:30.336 --> 18:38:35.741
这就创造了一个有效的定价市场一个持续有效的定价市场。

11338
18:38:35.741 --> 18:38:37.455
它甚至可以变成负数。

11339
18:38:37.455 --> 18:38:47.807
因此，如果是重要的数据集，存储提供商甚至可以付钱给你存储数据，因为文件币基金会也提供了一些块奖励。

11340
18:38:47.807 --> 18:38:55.873
这些机制不仅内置了数据的持久性，还内置了数据的时限和主权，所以这是你的数据，是你的选择。

11341
18:38:55.873 --> 18:38:59.073
您可以决定将数据存储5分钟还是500年。

11342
18:38:59.073 --> 18:39:08.479
你也可以选择你想要多少弹性的数据或者你想要多少副本的数据以及用什么存储给提供商。

11343
18:39:08.479 --> 18:39:13.231
这让你能够遵守GDPR等法规。

11344
18:39:13.231 --> 18:39:20.373
在这个生态系统中，有越来越多的工具，比如低语位屏，可以让你进行这种过滤。

11345
18:39:20.373 --> 18:39:29.961
但它也保证了你的数据，你知道，如果一个存储器坏了，肯定不会有10个都坏了。

11346
18:39:29.961 --> 18:39:34.580
这也是你恢复力的保证。

11347
18:39:34.671 --> 18:39:37.583
这就是为什么IPFS和文件币是很好的互补。

11348
18:39:37.583 --> 18:39:48.785
因此，IPF s为你提供了内容寻址的好处，file coin为你提供了持久的保证，即使你的计算机或你最喜欢的IPFS固定服务消失了，内容也会持久。

11349
18:39:48.785 --> 18:39:55.355
作为对这些概念的最后一个简要说明，正如我所提到的，IPFS和文件币是独立的项目。

11350
18:39:55.355 --> 18:40:01.153
因此，IPFS是一个很像HTTP的协议，而文件币是一个区块链。

11351
18:40:01.153 --> 18:40:06.705
因此，IPFS也是存储层不可知的，您可以将它与您所选择的存储层结合起来。

11352
18:40:06.705 --> 18:40:16.750
虽然文件币是专门为补充它而设计的，我们认为这是一个很好的选择，但你也可以将你的IPFS数据存储在云或其他存储解决方案中。

11353
18:40:16.750 --> 18:40:21.852
希望你已经对为什么要使用IPFS和文件币有了一个很好的基线。

11354
18:40:21.852 --> 18:40:40.889
对于那些喜欢挑战，对IPFS的基本协议和代码以及文件币感兴趣的工程师来说，这对一般用户来说并不容易，我鼓励你们去看看项目文档，获得用于扩展这些开源项目的hub和一些相关拨款。

11355
18:40:40.889 --> 18:40:48.380
如果你想了解更多细节，深入研究IPFS和文件币背后的代码，这个网站很不错。

11356
18:40:48.380 --> 18:40:49.867
并将其扩展。

11357
18:40:49.867 --> 18:40:52.956
对于那些只想在盒子里建造的人。

11358
18:40:52.956 --> 18:40:55.479
这是我经常加入的一个阵营。

11359
18:40:55.479 --> 18:41:00.132
我想谈谈一些开发工具和存储助手，它们使您可以轻松上手。

11360
18:41:00.132 --> 18:41:03.441
首先，Flake是我最喜欢的IPFS开发工具之一。

11361
18:41:03.441 --> 18:41:17.214
projectflake是一个CI CD工具你可以用它来免费部署你的应用就像你使用一些你可能熟悉的网络工具一样简单，比如Netlify oversell。

11362
18:41:17.214 --> 18:41:21.817
不过，最大的区别是fleek使用IPFS托管您的站点或应用程序。

11363
18:41:21.817 --> 18:41:24.901
它甚至在其平台上提供AES域路由。

11364
18:41:24.901 --> 18:41:33.606
所以如果你在部署一个前端应用，我会鼓励你使用fleek让它更分布式，而不是一些传统的web 2工具。

11365
18:41:33.672 --> 18:41:35.395
这很简单，我保证。

11366
18:41:37.672 --> 18:41:49.636
是非功能性存储，将非功能性元数据永久持久地存储，正如你可能已经知道的，这对于保持非功能性t的主要价值主张是不可或缺的，然后是可替代性。

11367
18:41:49.636 --> 18:42:00.783
因此，如果您不将数据存储在链上(这显然对大文件来说在经济上是不可行的)，那么这正是NF T存储的用途。

11368
18:42:00.783 --> 18:42:05.542
因此，它被专门创建为一种公共产品，用于归档和持久化NF - T数据。

11369
18:42:05.542 --> 18:42:06.380
所以它是免费的。

11370
18:42:06.380 --> 18:42:16.768
它首先为这个元数据创建一个IPFS Cid，然后与文件币存储提供者进行自动处理。

11371
18:42:16.768 --> 18:42:19.982
因此，它至少与八个存储提供商一起实现了这一点。

11372
18:42:19.982 --> 18:42:23.442
所以是8倍的冗余，而且是在多代人的时间框架内完成的。

11373
18:42:23.442 --> 18:42:25.917
所以它会自动更新这些交易。

11374
18:42:25.917 --> 18:42:28.376
因为它是公共产品，所以都是免费的。

11375
18:42:28.376 --> 18:42:33.688
它也非常容易使用，因为你只需要因为它是一个JavaScript服务。

11376
18:42:33.688 --> 18:42:43.672
你只需要把它作为NPM包或JavaScript库导入然后调用API NFT点存储处理剩下的。

11377
18:42:43.672 --> 18:42:53.355
对于不是NF T元数据的数据，我们建立了web 3点存储，web 3点存储旨在给你同样的web 2好处。

11378
18:42:53.355 --> 18:42:57.012
类似于ntf点存储，使用起来非常简单。

11379
18:42:57.012 --> 18:43:02.445
它有JavaScript和客户端库。

11380
18:43:02.673 --> 18:43:12.869
当你知道IPFS和去中心化存储和IPFS内容寻址的文件币的力量时，它有一万亿又一万亿的免费存储空间。

11381
18:43:12.869 --> 18:43:16.983
如果你不只是想存储和获取元数据，可以试试这个。

11382
18:43:16.983 --> 18:43:19.534
下一个工具更高级一些。

11383
18:43:20.673 --> 18:43:30.735
它被称为textil Palghat gate，它是为更高级的开发人员或那些寻找更灵活的与IPFS实时点对点和文件币交互的人设计的。

11384
18:43:30.735 --> 18:43:35.101
它是一个包裹在文件币和IPFS节点周围的Docker容器。

11385
18:43:35.101 --> 18:43:39.731
它给了你很多选项来配置它是一个小的选择和扩展功能。

11386
18:43:39.731 --> 18:43:45.863
它还提供了一些连接到几个层的桥梁，可能会引起开发人员的兴趣。

11387
18:43:45.863 --> 18:43:52.043
这里还有一个，我先说你们需要一张邀请函这是ESRI技术。

11388
18:43:52.043 --> 18:43:56.266
所以它是为那些想要存储真正有意义的公共数据的人准备的。

11389
18:43:56.266 --> 18:44:05.535
它目前处于alpha模式，就像我说的，它需要一个邀请，因为它是作为一个公共产品专门存储重要信息。

11390
18:44:05.535 --> 18:44:12.266
如果你在这张幻灯片上有用例，请随时联系我们。

11391
18:44:12.266 --> 18:44:15.825
我要提到的最后一个工具是轨道dB。

11392
18:44:15.825 --> 18:44:28.639
这么多从web 2来到web 3空间的人经常在寻找我们在传统计算中习惯使用的关系数据库，除了去中心化或分布式格式。

11393
18:44:28.639 --> 18:44:31.042
这不是一个简单的问题。

11394
18:44:31.042 --> 18:44:33.568
所以欧巴对我来说目前正在积极开发中。

11395
18:44:33.674 --> 18:44:41.351
因为这不是一个容易解决的问题，这并不是一个理想的解决方案，对于那些寻求开箱即用体验的人来说。

11396
18:44:41.351 --> 18:44:45.460
但如果你在寻找类似的东西，试试dB轨道。

11397
18:44:45.460 --> 18:44:56.983
生态系统中还有其他一些工具利用IPFS和文件币，包括陶瓷，它类似于纺织电源门，除了它使用去中心化身份。

11398
18:44:56.983 --> 18:45:04.581
Lighthouse是文件驱动器，甚至Morales也有IPFS API，你也可以去看看。

11399
18:45:04.674 --> 18:45:08.601
所以存储是一个技术系统的基本组成部分。

11400
18:45:08.601 --> 18:45:11.726
这里有很多用例。

11401
18:45:11.726 --> 18:45:17.377
希望我已经为你们提供了一些开始使用IPFS和文件Goyt所需的知识和工具。

11402
18:45:17.377 --> 18:45:21.388
并真正实现强大的分布式应用。

11403
18:45:21.388 --> 18:45:25.768
现在还有一个工具也在积极开发中。

11404
18:45:25.768 --> 18:45:31.424
所以如果你仔细看这个图，你可能会注意到在逻辑层的末尾有一个不熟悉的logo。

11405
18:45:31.424 --> 18:45:34.397
这是文件币虚拟机的标志。

11406
18:45:34.397 --> 18:45:37.448
所以FBM将在今年年底推出。

11407
18:45:37.448 --> 18:45:39.577
我们对此非常兴奋。

11408
18:45:39.577 --> 18:45:51.480
它将允许智能合约，合约的使用结合存储数据的托管，负载，计算能力和存储能力，也将兼容EVM。

11409
18:45:51.480 --> 18:45:58.074
就像我说的，我们对我们将从这个项目中看到的各种用例非常兴奋。

11410
18:45:58.074 --> 18:46:02.372
你也可以在这个网站上跟着看。

11411
18:46:02.372 --> 18:46:05.957
希望我已经给了你们开始使用IPFS所需的所有工具。

11412
18:46:05.957 --> 18:46:07.013
和文件硬币。

11413
18:46:07.013 --> 18:46:14.626
如果你确实需要更多的资源或想参与其中，我们有proto School，这是一个去中心化web协议的交互式教程。

11414
18:46:14.675 --> 18:46:20.675
也有NFT, school dot Dev，或者加入一个黑客松，看看我们的黑客松。

11415
18:46:20.675 --> 18:46:21.119
filecoin。

11416
18:46:21.119 --> 18:46:24.029
IO页面，我们参与的所有最新的黑客马拉松。

11417
18:46:24.029 --> 18:46:42.515
如果你真的想在IPFS中深入挖掘和构建工具，文件币或构建一个很酷的项目，检查我们的拨款选项以及，与此同时，所有请学习长期构建和繁荣。

11418
18:46:42.675 --> 18:46:45.295
我们在这一节学到了很多。

11419
18:46:45.295 --> 18:46:46.329
就是这样。

11420
18:46:46.675 --> 18:46:50.013
让我们总结一下我们所学到的所有神奇的东西。

11421
18:46:50.013 --> 18:46:56.165
然后我们会讲到它的TypeScript版本因为TypeScript版本肯定有点不同。

11422
18:46:56.165 --> 18:46:56.928
我们来谈谈。

11423
18:46:56.928 --> 18:46:59.435
好的，首先，我们了解了下一个Jas。

11424
18:46:59.435 --> 18:47:02.379
我们知道我们可以用next Jas做一个应用。

11425
18:47:02.379 --> 18:47:09.045
这个框架可以让我们很容易地构建强大的前端和全栈应用程序。

11426
18:47:09.045 --> 18:47:23.175
我们学习了下一个JS项目的布局，我们在components文件夹中添加了组件，这基本上是JavaScript和HTML的极简块，我们可以使用这些组件模块化和创建我们的网站。

11427
18:47:23.175 --> 18:47:28.982
Constants是一个可以放置常量变量的文件夹，Node modules是Node modules。

11428
18:47:28.982 --> 18:47:30.043
取出文件夹。

11429
18:47:30.043 --> 18:47:38.933
当我们将所有代码导出到静态示例时会发生什么呢，页面基本上是我们网站的路由或不同页面，所有东西都通过app。

11430
18:47:38.933 --> 18:47:39.105
js。

11431
18:47:39.105 --> 18:47:46.263
Public是一些公共的东西，样式适用于任何CSS或应用的样式。

11432
18:47:46.263 --> 18:47:49.342
这是我们的基本文件。

11433
18:47:49.342 --> 18:48:02.342
在pages部分，我们有我们的app，它被这个通知提供程序和Morales提供程序包围，我们所有的组件都通过这个app在我们所有的页面上都通过这个app运行。

11434
18:48:02.342 --> 18:48:07.151
这是整个应用程序的入口点。

11435
18:48:07.151 --> 18:48:16.376
将Morales提供程序封装在组件中的通知中意味着我们不必在组件之间传递参数。

11436
18:48:16.376 --> 18:48:26.120
我们的彩票会知道我们在哪个链ID上，因为header会把它传递给Morales提供者而Morales提供者会把它传递回我们的彩票入口。

11437
18:48:26.120 --> 18:48:30.971
我们看到了手动头文件中，连接按钮在幕后的工作方式。

11438
18:48:30.971 --> 18:48:44.390
它在做一些本地存储，我们在那里存储不管我们是否连接，我们学习使用效果，你说这些不同的钩子在我们前端是我们想要钩子的主要原因之一是我们想要我们的网站重新播放。

11439
18:48:44.390 --> 18:48:50.914
当东西发生变化时，我们希望我们的组件能够彼此谈论区块链的状态。

11440
18:48:50.914 --> 18:48:54.176
它们在构建React应用时非常强大。

11441
18:48:54.176 --> 18:49:07.743
Use effect是最流行的一种如果我们没有依赖数组，我们的Use effect中的函数将在任何时候运行重新渲染一个空白的依赖数组意味着它只会在加载时运行一次。

11442
18:49:07.743 --> 18:49:14.596
如果数组中有依赖项，它会在任何变量发生变化时运行。

11443
18:49:14.676 --> 18:49:21.003
我们还学了use state钩子，它类似于，let variable = x。

11444
18:49:21.003 --> 18:49:23.455
但它也带有RE渲染能力。

11445
18:49:23.455 --> 18:49:30.238
它还有其他一些很好的功能我们这里没有讨论，我们学过如何用mirallas调用不同的契约函数。

11446
18:49:30.238 --> 18:49:33.880
不仅要发送事务，还要调用数据。

11447
18:49:33.880 --> 18:49:40.042
Morales很聪明，知道当它看到get门票时这将是一个视图函数。

11448
18:49:40.042 --> 18:49:43.005
这将是一个交易，它可以区分两者的区别。

11449
18:49:43.005 --> 18:49:45.395
这个将会在Metamask中弹出。

11450
18:49:45.395 --> 18:50:09.333
这个会像视图函数一样返回，我们可以在发送事务和调用契约视图函数之间使用相同的语法，我们添加了一个按钮，调用其中一个Morales片段然后有一个onsuccess部分当我们的事务完成时，我们更新UI并为通知添加一个小弹出框，我们学习了如何将代码直接部署到IPFS。

11451
18:50:09.333 --> 18:50:18.927
使用IPFS散列来交互和查看我们的代码，我们还学习了fleek以及fleek如何自动部署到IPFS。

11452
18:50:18.927 --> 18:50:26.086
每当我们向GitHub仓库推送git时，它就会使我们的网站不断更新变得更容易。

11453
18:50:26.086 --> 18:50:29.257
它也为我们提供了一个规范的URL。

11454
18:50:29.257 --> 18:50:33.621
最后，我们学习了IPFS和去中心化数据库存储。

11455
18:50:33.677 --> 18:50:51.581
现在你可能会问，好吧，为什么我们不把这个网站的所有数据存储在Aetherium, polygon或avalanche上呢?这个问题的答案是存储数据会非常昂贵，在区块链上存储大量的数据会消耗大量的汽油，而这是一个更便宜的选择。

11456
18:50:51.581 --> 18:51:04.935
以太雪崩和智能合约平台并不是数据存储层，而是逻辑层，对吧?去中心化逻辑，去中心化智能合约，通常，是的，我们需要在其中存储数据。

11457
18:51:04.935 --> 18:51:07.355
但当它是大量的数据时，有更好的解决方案。

11458
18:51:07.355 --> 18:51:19.267
有不同的解决方案来存储数据，比如IPFS和文件币，如果你已经做到了这一步，你应该为自己感到非常自豪，因为你已经做了一个非常可靠的应用，一个非常可靠的前端应用。

11459
18:51:19.267 --> 18:51:24.474
您还学习了如何非常轻松地添加与智能合约交互的功能。

11460
18:51:24.474 --> 18:51:30.626
所以，给自己一点鼓励吧，甚至可以在推特上发布，与你的朋友和家人分享这个非常酷的应用程序。

11461
18:51:30.678 --> 18:51:32.598
休息一下。

11462
18:51:38.678 --> 18:51:42.130
好了，欢迎来到我们最快的一节课。

11463
18:51:42.130 --> 18:51:45.152
在这节课中，我们将讨论硬帽入门套件。

11464
18:51:45.152 --> 18:51:48.801
很快地，我会给你们演示一下如何使用它。

11465
18:51:48.801 --> 18:51:54.066
现在我们学到了很多关于项目的知识，我们学到了很多关于不同回购的知识，学到了智能合约的基础知识。

11466
18:51:54.066 --> 18:51:58.505
我们也学到了很多关于前端的知识以及为应用程序构建前端的知识。

11467
18:51:58.505 --> 18:52:07.898
因此，这个智能合约套件repo附带了大量的启动套件，您可以使用它们立即开始部署您的项目。

11468
18:52:07.898 --> 18:52:14.203
正如你所看到的那样，这个硬帽入门套件很容易成为最受欢迎的装备之一，拥有最多的明星和叉子。

11469
18:52:14.203 --> 18:52:34.290
智能合约套件repo实际上附带了大量的框架，比如如果你想使用SWANA，如果你想使用Python和Brownie，如果你想使用foundry, truffle，任何其他的框架，你可以开始，克隆其中一个repo，使用其中一个repo来构建你的项目，然后立即开始，我们将向你展示如何使用hard hat starter套件。

11470
18:52:34.290 --> 18:52:46.264
你可以直接拿着repo去做已经有了一些样板代码和一个样板非常好看的repo来开始你的项目，我们来看看智能合约工具包，这里是hard hat starter kit repo。

11471
18:52:46.264 --> 18:52:53.679
如果你正在使用GitHub，你可以直接使用这个模板，它会自动生成一个新的GitHub回购与最难的启动工具包。

11472
18:52:53.679 --> 18:53:03.306
我们继续，点击使用这个模板，这里有我们自己的名字，我们将它命名为，make它public create repository from template。

11473
18:53:03.306 --> 18:53:05.658
它会生成我们的存储库。

11474
18:53:05.658 --> 18:53:09.575
现在我们自动在自己的回购中有了它。

11475
18:53:09.575 --> 18:53:11.397
我们可以开始处理它了。

11476
18:53:11.397 --> 18:53:12.615
我们可以开始处理它了。

11477
18:53:12.679 --> 18:53:16.743
如果你不想点击使用模板按钮，我们也可以复制URL。

11478
18:53:16.743 --> 18:53:20.329
在代码编辑器中，我们可以复制粘贴到这里。

11479
18:53:20.329 --> 18:53:25.804
现在，我将得到clone，但我将用我们刚创建的这个repo得到clone。

11480
18:53:25.804 --> 18:53:32.187
回来与git克隆，硬帽玩FCC或硬帽启动套件。

11481
18:53:32.187 --> 18:53:37.760
我们将cd放入我们的头部播放FCC，然后在一个新的代码编辑器中打开它。

11482
18:53:37.760 --> 18:53:38.546
而可畏。

11483
18:53:38.679 --> 18:53:48.488
现在你会看到在这个回购中，它打包了大量的合同，部署，脚本，任务，测试，一切，你能想到的，真正开始在一个专业的环境。

11484
18:53:48.488 --> 18:53:53.763
我们看一下合同部分，我们可以看到我们有一些合同样本。

11485
18:53:53.763 --> 18:54:03.138
我们有一个合同，对一个链节点进行API调用，与负责价格feed的饲养员合作，然后与链Vir Fe 2合作。

11486
18:54:03.138 --> 18:54:18.279
我们有一些测试合同，还有这个模糊文件夹，我们会在后面的课程中讲到，我们有部署脚本，我们从部署模拟开始，然后部署每一个合同，我们有一个示例脚本从这些合同中读取价格。

11487
18:54:18.279 --> 18:54:21.079
我们有一大堆的样本任务。

11488
18:54:21.079 --> 18:54:23.933
现在在记录的时候，这个回购使用的不是脚本，而是任务。

11489
18:54:23.933 --> 18:54:26.373
但是，它们是可以互换的。

11490
18:54:26.373 --> 18:54:39.024
当然，我们还有一些单元测试和一些分段测试，你们可以看一看，一旦我们在这个回购中，我们可以在这里运行一些熟悉的命令，我们会做yarn，当然，来安装我们所有的包。

11491
18:54:39.024 --> 18:54:44.130
然后我们要做的所有事情，如果你迷路了，你总是可以回到这个回购。

11492
18:54:44.130 --> 18:54:46.939
你可以跟随入门和快速入门。

11493
18:54:46.939 --> 18:54:48.280
我们只是做了git克隆。

11494
18:54:48.280 --> 18:54:52.764
现在我们在做纱线，然后我们要继续做纱线硬帽测试。

11495
18:54:52.764 --> 18:55:05.180
这个hard hat starter kit repo是非常持续更新的，我们在几天前刚刚发布了最后一个推送，它将不断提供一些构建智能合约的最佳实践，并拥有一个真正专业的编码环境。

11496
18:55:05.180 --> 18:55:06.883
它有一个非常可爱的标志。

11497
18:55:06.883 --> 18:55:19.470
一旦我们安装了所有的依赖项，我们就可以运行yarn, art had test，我们可以在test文件夹中运行所有的测试，它也会告诉我们如何交互以及如何使用这里所有这些不同的契约。

11498
18:55:19.470 --> 18:55:26.346
它们每个都有一些console。log，因此您可以看到更多关于这些测试实际运行时实际发生的情况。

11499
18:55:26.346 --> 18:55:28.970
如果我们查看Hardhead配置。

11500
18:55:28.970 --> 18:55:44.608
Js里面有一些很熟悉的代码，我们在顶部有所有的导入，我们抓取一大堆环境变量，我们有ether scan插件，我们有gas reporter，合约大小器，这是一个告诉你合约大小的插件。

11501
18:55:44.608 --> 18:55:48.489
命名帐户，不同的固态版本，还有摩卡超时。

11502
18:55:48.489 --> 18:56:14.146
当然，我们可以做yarn硬帽节点，它会运行在我们的部署脚本中，然后为我们旋转一个新的注释，它有模拟链链令牌，模拟Oracle的模拟聚合器，模拟VRF以便我们继续进行交互，然后我们当然可以，到硬帽，控制台，破折号网络localhost，开始与localhost上的契约进行交互。

11503
18:56:14.146 --> 18:56:29.538
我们可以遵循价格供给，例如，const price消费者b3 = await醚。get合约，价格，消费者v3。

11504
18:56:29.681 --> 18:56:35.181
然后我们可以等待价格消费者B 3点得到最新的价格。

11505
18:56:35.181 --> 18:56:38.281
我们把它包装成一个to字符串。

11506
18:56:38.281 --> 18:56:43.926
我们可以看到来自使用通道价格提要的合约的模拟最新价格。

11507
18:56:43.926 --> 18:56:49.415
我们可以与我们的任何合同进行交互也可以与这里的任何模拟进行工作。

11508
18:56:49.415 --> 18:57:01.612
如果我们想把它部署到一个实际的测试网络，比如Rinckey，或者主网会弹出我们的。env文件，我们会关闭节点终端，我们可以运行yarn hardhat或hh deploy。

11509
18:57:01.612 --> 18:57:04.784
然后我们会在这里添加任何我们想要的标签。

11510
18:57:04.784 --> 18:57:06.557
我们来部署价格供给合约。

11511
18:57:06.557 --> 18:57:10.616
如果我们转到价格提要部署，向下滚动，我们会得到标签。

11512
18:57:10.616 --> 18:57:18.600
好的，很好，我们将使用feed标签，dash标签提供dash或提供dash网络带来的光束。

11513
18:57:18.681 --> 18:57:22.270
在我们等待这个部署的时候，我们可以回到实际的回购。

11514
18:57:22.270 --> 18:57:30.759
一定要跟随这里的文档和快速入门所有的用法和所有的东西这样你就能确保你使用的是最新的版本。

11515
18:57:30.759 --> 18:57:37.131
甚至还有关于使用测试网或与Aetherium一起工作的活动网络运行本地网络的文档。

11516
18:57:37.131 --> 18:57:53.927
Rigby添加你的私钥和点羡慕所有这些你已经知道的东西，分叉，我们稍后会学到一点，自动资助你的合同使用链链接API运行测试，你可以额外的并行运行你的测试通过在我们的测试中添加虚线并行标志。

11517
18:57:53.927 --> 18:58:02.632
我们可以与部署的契约与我们创建的不同任务进行交互检测代码格式，估计气体代码覆盖模糊，我们将在后面讨论。

11518
18:58:02.682 --> 18:58:04.173
然后是贡献。

11519
18:58:06.682 --> 18:58:16.313
一旦它被输出，甚至被验证，如果你打开了验证，你会得到一个小任务我们可以运行它来读取价格提要或与合约交互。

11520
18:58:16.313 --> 18:58:17.839
我们可以把这个任务复制出来。

11521
18:58:17.839 --> 18:58:18.523
纱线建筑工人。

11522
18:58:18.682 --> 18:58:24.878
阅读价格提要，因为这是一个任务，合同数据，我们刚刚部署的网络Rigby。

11523
18:58:24.878 --> 18:58:36.364
我们将从网络上的消费者合同中获取读取数据价格，Rigby价格在这里，当然，我们说Aetherium的价格是3033美元，因为它有小数点后8位。

11524
18:58:36.364 --> 18:58:43.391
因此，如果你想开始一个新的项目，并且你想要一些样板代码，这个硬帽初学者工具包是一个很好的开始。

11525
18:58:43.391 --> 18:58:49.635
当然，你可以打开它，得到豆荚，如果你想测试一下，尝试一下，在云壳里得到豆荚。

11526
18:58:49.682 --> 18:58:51.082
这节课就到这里。

11527
18:58:51.082 --> 18:58:51.932
没那么快。

11528
18:58:52.682 --> 18:58:53.699
有史以来最快的一课。

11529
18:58:55.682 --> 18:59:08.475
在这里学习，我会分叉，会克隆，我会使用这个模板，试着自己尝试一下回购看看你认识什么，不认识什么，把它准备好，以备以后课程中的问题。

11530
18:59:08.475 --> 18:59:15.488
对于所有使用TypeScript的人，当然也有一个TypeScript版本你可以克隆它。

11531
18:59:15.488 --> 18:59:19.617
它有一个漂亮的蓝色标志，表明它有点不同。

11532
18:59:19.617 --> 18:59:24.895
也就是说，用回购，玩得开心。

11533
18:59:24.895 --> 18:59:29.299
让我们开始第十二课。

11534
18:59:29.683 --> 18:59:32.830
好了，现在我们开始讲硬帽ERC。

11535
18:59:33.683 --> 18:59:49.812
部分，我们将学习如何创建我们自己的ERC 20或EIP 20或B EP 20或AEP 20区块链上的任何这些令牌，在我们了解ERC 20是什么，甚至这些令牌是什么之前，我们首先需要了解什么是ERC。

11536
18:59:49.812 --> 18:59:55.450
还有Aetherium的EIP，雪崩，金融和多边形。

11537
18:59:55.450 --> 18:59:58.683
所有这些区块链都有所谓的改进建议。

11538
18:59:58.683 --> 19:00:03.612
对于Aetherium，它们被称为Aetherium改进建议，或E IPs。

11539
19:00:03.683 --> 19:00:13.016
人们会做的是想出这些想法来改进Aetherium或改进这些层，如多边形，马蒂奇雪崩等。

11540
19:00:13.016 --> 19:00:21.083
在一些GitHub或一些开源存储库中，他们会添加这些新的EIP他们会添加这些新的改进想法使这些协议更好。

11541
19:00:21.083 --> 19:00:31.269
现在，这些改进可以是任何东西，它们可以是任何东西，从核心区块链更新到一些标准，这将是整个社区采用的最佳实践。

11542
19:00:31.269 --> 19:00:38.328
一旦EIP获得了足够的洞察力，他们还会创建E RC，即Aetherium请求评论。

11543
19:00:38.328 --> 19:00:43.616
因此，EIP理论和改进建议ERC理论和征求意见。

11544
19:00:43.683 --> 19:00:47.933
这些公司可以是英国石油公司、活力公司等。

11545
19:00:48.683 --> 19:00:50.055
这些不同的区块链。

11546
19:00:51.683 --> 19:01:05.521
和评论请求，都有这些不同的标签，现在它们按时间顺序编号，所以像ERC 20这样的东西将是第20个ERC / EIP, ERC和efp共享相同的数字。

11547
19:01:05.521 --> 19:01:08.360
有一些网站，比如EIP是aetherium。

11548
19:01:08.360 --> 19:01:16.699
他们跟踪所有这些新的Aetherium改进建议，你可以实时看到它们通过被社区采用的过程。

11549
19:01:16.699 --> 19:01:23.934
现在，其中一个ip或ERC将成为ERC 20或智能合约的令牌标准。

11550
19:01:23.934 --> 19:01:30.897
这是一个改进方案，讨论了如何实际创建令牌和创建这些智能合约令牌。

11551
19:01:30.897 --> 19:01:32.287
我最近做了一个关于这个的视频。

11552
19:01:32.287 --> 19:01:40.311
在与这门课相关的GitHub回购中，我们会有一节课，我们会看一个简短的视频来解释更多关于这些不同代币的内容。

11553
19:01:40.311 --> 19:01:55.350
首先，让我们定义什么是ERC 20。ERC 20是部署在一个链上的令牌，使用所谓的ERC 20令牌标准，你可以在描述中的20年令牌标准链接中阅读更多关于它的信息。

11554
19:01:55.350 --> 19:01:59.054
但基本上，它是一个智能合约，它实际上代表一个代币。

11555
19:01:59.054 --> 19:02:01.395
它是代币或智能合约。

11556
19:02:01.395 --> 19:02:09.160
这两者都很酷，链链独特的令牌和染料都是ERC 20的例子技术上讲，链链属于ERC。

11557
19:02:09.160 --> 19:02:15.836
677，因为有升级到ERC 20的一些令牌仍然向后兼容ERC。

11558
19:02:15.836 --> 19:02:20.756
所以基本上，你可以把它们看作是带有一些额外功能的ERC。

11559
19:02:20.756 --> 19:02:24.913
我为什么要做ERC 20呢，你可以用它做很多很酷的东西。

11560
19:02:24.913 --> 19:02:32.102
你可以创建治理令牌，你可以保护底层网络，你可以创建某种类型的合成酸，或者其他任何东西。

11561
19:02:32.102 --> 19:02:48.406
在任何情况下，我们如何建立一个这样的ERC?我们怎么造一个代币?我们要做的就是建立一个遵循令牌标准的智能合约，我们要做的就是建立一个智能合约它有这些函数有名称函数，符号函数，小数函数，等等。

11562
19:02:48.406 --> 19:02:52.399
所有这些功能我们都需要能够传递它，我们需要能够得到它的平衡等等。

11563
19:02:52.399 --> 19:03:00.455
如果你想检查一些仍然兼容ERC 20的改进，比如ERC 677或ERC 777。

11564
19:03:00.455 --> 19:03:05.650
一定要去看看，然后建造一个这样的东西。

11565
19:03:05.650 --> 19:03:07.136
好吧，太棒了。

11566
19:03:07.136 --> 19:03:15.600
现在我们知道了这些ERC 20中的一个是什么，我们可以继续，在与本课程相关的GitHub回购中创建我们自己的。

11567
19:03:15.600 --> 19:03:16.943
我们这里有所有可用的代码。

11568
19:03:16.943 --> 19:03:18.878
如果你只想克隆。

11569
19:03:18.878 --> 19:03:22.077
这又是一节速成课。

11570
19:03:22.077 --> 19:03:23.072
我们在终点站。

11571
19:03:23.072 --> 19:03:24.330
我们在VS代码中。

11572
19:03:24.330 --> 19:03:26.528
我们要创建一个新目录。

11573
19:03:26.528 --> 19:03:33.193
我叫它硬帽ERC 20 FCC将cd变成硬帽，你的C 20秒。

11574
19:03:33.193 --> 19:03:40.409
我们将创建一个新的安全帽项目和我们之前做的完全一样，yarn add dash dev或tab。

11575
19:03:40.409 --> 19:03:45.330
让我们在它自己的VS code中打开它。

11576
19:03:45.330 --> 19:03:47.652
或文件打开此文件夹。

11577
19:03:47.652 --> 19:03:50.410
好了，我们现在在我们的项目中。

11578
19:03:50.410 --> 19:03:52.151
让我们创建一个新的安全帽项目。

11579
19:03:52.151 --> 19:03:55.485
我们会做纱线，艺术帽。

11580
19:03:55.685 --> 19:03:59.930
我们会创建一个空的hardhat。config。j s，很好。

11581
19:03:59.930 --> 19:04:02.438
我们现在有一个空的硬帽。config。js。

11582
19:04:02.438 --> 19:04:15.488
如果你想从之前的项目中复制粘贴你的hard hat。config你想复制粘贴你的heart Have。config或者你的。EMV文件，因为你知道我们会需要这些你可以现在就这么做，我要把它更新到8。

11583
19:04:15.488 --> 19:04:15.553
7.

11584
19:04:15.685 --> 19:04:18.057
我待会再加我的东西。

11585
19:04:19.685 --> 19:04:21.081
EIP 20，或者ERC 20。

11586
19:04:23.685 --> 19:04:33.419
在它的代币标准中，我们可以转让代币，我们可以在ERC 20合同中做所有的事情，它实际上只是跟踪每个人有多少代币。

11587
19:04:33.419 --> 19:04:36.892
智能合约以一种奇怪的方式保持着自我跟踪。

11588
19:04:36.892 --> 19:04:39.341
首先，我们要用手工的方法来做。

11589
19:04:39.341 --> 19:04:46.892
首先，我们要在这里创建我们自己的手动令牌，或者是一个非常简单的令牌，让我们创建一个新文件夹。

11590
19:04:46.892 --> 19:04:53.574
契约将创建一个名为manual token。soul的新文件。

11591
19:04:53.574 --> 19:04:59.876
好的，我先给大家演示一下比较难的做法然后再给大家演示一种简单得多的做法。

11592
19:04:59.876 --> 19:05:07.876
开始之前我们通常会做pragma, solidity to carrot 0，第8点。

11593
19:05:07.876 --> 19:05:07.971
7.

11594
19:05:07.971 --> 19:05:19.419
然后我们还会写spdx，许可标识符，MIT做合约，手动令牌，开始吧。

11595
19:05:19.419 --> 19:05:26.266
令牌智能合约工作的主要原因是存在一些余额映射。

11596
19:05:26.266 --> 19:05:31.195
所以我们有256页的地址映射。

11597
19:05:31.195 --> 19:05:43.744
它通常是公共的，叫做balance of它所做的就是这个映射很明显关键是这个星球上的每一个地址，然后是他们有多少。

11598
19:05:43.744 --> 19:05:55.156
基本上，当我们转移代币，转移代币时，我们基本上只是从地址，金额中减去，然后加到地址中。

11599
19:05:55.156 --> 19:06:00.855
实现这个的最简单的方法就是先创建传递函数。

11600
19:06:00.855 --> 19:06:10.936
我们将创建这个函数，我将它命名为下划线传输，我们可以做一个地址从地址到你到第五第六挂载。

11601
19:06:10.936 --> 19:06:16.801
现在我们可能会加上一些要求，我们可能会省略一些事件，让我们把这个也公开。

11602
19:06:16.801 --> 19:06:43.409
实际上，在一天结束的时候，我们会说balance of from - equals value，这和说bounce of from = bounce from - value，不好意思，是amount是一样的，然后我们会说balance of 2，不好意思，是+ equals，这和说balance of 2 +是一样的。

11603
19:06:43.409 --> 19:06:50.916
技术上来说，这就是我们需要的，对吧，我们可能需要在这里做一些断言，一些要求来确保所有的数字都有意义。

11604
19:06:50.916 --> 19:06:55.287
但实际上，在一天结束的时候，这就是这个函数所做的一切。

11605
19:06:55.287 --> 19:07:00.618
当呼叫者直接把钱送到另一个地址时，转账就起作用了。

11606
19:07:00.687 --> 19:07:16.093
但是如果我们想让智能合约使用我们的令牌，或者我们想让其他人使用我们的令牌，也许把它存入协议，或者用它做更多的功能，会有一些被批准的功能会批准合约来做这些。

11607
19:07:16.093 --> 19:07:26.428
然后我们会有一个功能转移，这个功能会，你知道，它会实现从用户那里获取资金，这也是公共的。

11608
19:07:26.428 --> 19:07:36.517
然后在顶部会是某种类型的许可映射它会告诉谁被允许在哪个地址取多少令牌，这听起来有点混乱，但让我添加映射。

11609
19:07:36.517 --> 19:07:55.160
这将是地址的映射到地址的映射到单位性的数量这将是公共许可，我们将说地址，帕特里克将允许帕特里克的弟弟的地址使用25代币。

11610
19:07:55.160 --> 19:07:57.688
这就是这项津贴的运作方式。

11611
19:07:57.688 --> 19:08:03.291
在我们的transfer from中，会检查这个允许映射并保存。

11612
19:08:03.291 --> 19:08:08.228
帕特里克授权你借那些代币了吗?哦，不，你说了。

11613
19:08:08.228 --> 19:08:09.934
好吧，我们让你从。

11614
19:08:09.934 --> 19:08:14.259
我将复制粘贴它的一个实现，你也可以查看GitHub repo。

11615
19:08:14.259 --> 19:08:20.881
它看起来是这样的，我们检查允许的金额，更新限额，然后转移代币。

11616
19:08:20.881 --> 19:08:22.171
这是一些主要的功能。

11617
19:08:22.171 --> 19:08:26.375
显然，我们需要一个被认可的功能，来更新这里的津贴。

11618
19:08:26.375 --> 19:08:32.501
通常，你会有一个un256的初始供给。

11619
19:08:32.501 --> 19:08:41.139
这就像有多少令牌从总共有多少令牌开始，有时你会添加一个薄荷函数来添加更多的函数。

11620
19:08:41.139 --> 19:08:44.161
但是你基本上可以看到这个合约在上升。

11621
19:08:44.161 --> 19:08:51.114
我们可以做的一件事是，我们可以继续，通过这个规范，一行一行地，你知道，自己构建我们的令牌。

11622
19:08:51.114 --> 19:08:54.211
在我们这样做之后，它可能看起来像这样。

11623
19:08:54.211 --> 19:08:57.425
我只是复制粘贴了GitHub回购的代码。

11624
19:08:57.425 --> 19:09:01.524
到合约，手动令牌，复制粘贴这段代码。

11625
19:09:01.524 --> 19:09:04.830
这就是令牌合约的样子。

11626
19:09:04.830 --> 19:09:05.068
好的。

11627
19:09:05.068 --> 19:09:07.868
我们有了所有这些函数，所有这些数组。

11628
19:09:07.868 --> 19:09:08.999
我们有所有这些东西。

11629
19:09:08.999 --> 19:09:14.720
你可以在构造函数中看到，我们取初始供给，然后是令牌名和令牌符号。

11630
19:09:14.720 --> 19:09:17.555
它的名字，你知道，可能是dy token之类的。

11631
19:09:17.555 --> 19:09:25.557
然后这个符号可以是dy这样的，这样就可以很容易地通过它的名字和符号来识别它。

11632
19:09:25.688 --> 19:09:29.480
从头开始编码，这绝对是我们可以做到的。

11633
19:09:29.480 --> 19:09:32.439
但作为工程师，我们知道这可能真的很烦人。

11634
19:09:32.439 --> 19:09:33.626
实际上我们并不想这样做。

11635
19:09:33.689 --> 19:09:47.066
那么我们能做些什么呢?我们可以使用一个开源库，比如开放的Zeppelin，来得到一些样板代码，而开放的Zeppelin几乎被认为是一种稳定的标准库。

11636
19:09:47.066 --> 19:10:03.642
他们有一个开源合同的列表，任何人都可以使用并导入到他们的合同中，其中有大量的样板文件，所以你不需要手动把所有东西都写出来，我们可以在GitHub仓库中看到他们的所有代码，打开Zeppelin /打开Zeppelin合同，我们以后会经常使用它们。

11637
19:10:03.689 --> 19:10:12.705
例如，你可以在他们文档的左边看到，他们有这个令牌部分，他们有一个ERC 20，这是令牌标准之一。

11638
19:10:12.705 --> 19:10:19.089
如果你滚动到这里，他们甚至有一些关于如何创建自己的ERC 20令牌的简单例子。

11639
19:10:19.089 --> 19:10:22.016
那就是我们要用来构建令牌的东西。

11640
19:10:22.016 --> 19:10:25.914
因为你可以看到这个有多小需要维护的代码有多少。

11641
19:10:25.914 --> 19:10:29.220
让我们继续，让我们使用打开Zeppelin来创建我们的令牌。

11642
19:10:29.220 --> 19:10:30.785
让我们创建一个新文件。

11643
19:10:30.785 --> 19:10:32.720
我们将令牌命名为。soul。

11644
19:10:32.720 --> 19:10:36.092
我要在这里创建我们自己的令牌。

11645
19:10:36.092 --> 19:10:37.726
我们来求spdx。

11646
19:10:37.726 --> 19:10:46.235
许可标识符MIT，我们用pragma, solidity胡萝卜0，点8。

11647
19:10:46.235 --> 19:10:48.578
7，我们会做代币契约。

11648
19:10:48.578 --> 19:10:54.516
现在，我们要做的是，我们要把openzeppelin合同导入到我们的安全帽项目中。

11649
19:10:54.516 --> 19:10:58.555
我们会像处理chain link和未来的其他包一样处理它。

11650
19:10:58.555 --> 19:11:05.146
所以我们会做纱线，添加破折号Dev，在打开齐柏林斜杠合同。

11651
19:11:05.146 --> 19:11:09.584
这将添加开放齐柏林砍合同NPM包到我们的项目。

11652
19:11:09.584 --> 19:11:17.471
其中一段代码就是我们可以使用的ERC 20契约我们可以让令牌继承所有的函数。

11653
19:11:17.471 --> 19:11:22.602
我们用importatopenzeppelin导入它。

11654
19:11:22.690 --> 19:11:28.065
/ /合约/ /代币/ / ERC 20 / / ERC 20

11655
19:11:28.065 --> 19:11:33.413
通过像这样导入它，我们要做的就是继承我们的令牌。

11656
19:11:33.413 --> 19:11:34.766
我们用契约。

11657
19:11:34.766 --> 19:11:36.077
我们的代币是ERC 20。

11658
19:11:36.077 --> 19:11:36.399
繁荣。

11659
19:11:36.399 --> 19:11:39.237
就这样，我们的代币差不多完成了。

11660
19:11:39.237 --> 19:11:44.500
现在你可能会看到这条小红线表示我们的标记应该被标记为抽象。

11661
19:11:44.500 --> 19:11:51.724
这是因为如果我们研究openzeppelin的ERC 20点灵魂，我们会看到它有一个构造函数。

11662
19:11:51.724 --> 19:12:00.540
因此，为了继承你的c20令牌，我们必须使用ERC 20构造函数，我们只需要给我们的令牌一个名称和一个符号。

11663
19:12:00.540 --> 19:12:04.034
但我们可以在构造函数中，让它为空。

11664
19:12:04.034 --> 19:12:10.769
然后就在构造函数旁边，我们会添加ERC 20构造函数我们的名字就是我们的令牌。

11665
19:12:10.769 --> 19:12:15.241
然后我们的符号就是OT和ERC。

11666
19:12:15.241 --> 19:12:27.050
20个token还带有一个叫做mint的函数，它本质上是一个允许我们创建token的函数，因为现在我们实际上是用0个token初始化的。

11667
19:12:27.050 --> 19:12:30.062
所以实际上没有人被允许持有任何代币。

11668
19:12:30.062 --> 19:12:36.109
我们想要铸造最初数量的代币然后谁拥有这些代币。

11669
19:12:36.109 --> 19:12:45.113
通常你会看到一个像这样的薄荷函数，它会传递给发送者，所以部署这个契约的人将拥有所有令牌。

11670
19:12:45.113 --> 19:12:49.519
然后我们就像给他们灵魂供给一样。

11671
19:12:49.690 --> 19:12:54.277
然后初始供给是56，等于7，等等。

11672
19:12:54.277 --> 19:12:58.711
但是，通常的做法是将它添加到构造函数中。

11673
19:12:58.711 --> 19:13:04.737
256个初始供给就像这样，我们知道固体度小数并不好用。

11674
19:13:04.737 --> 19:13:20.400
如果我说我的初始供给是50，这个50就是50，所有这些ERC 20都有一个小数和小数函数，它告诉我们ERC 20应该有多少个小数。

11675
19:13:20.400 --> 19:13:21.791
默认为18。

11676
19:13:21.791 --> 19:13:25.891
如果我们想要不同数量的小数，我们可以重写这个函数。

11677
19:13:25.891 --> 19:13:28.091
如果我们知道默认值是18。

11678
19:13:28.091 --> 19:13:32.894
我们想要部署50，我们可能想要初始供应50 e18。

11679
19:13:32.894 --> 19:13:39.841
或者你也可以说，50乘以10,18次方，或者任何你想要的。

11680
19:13:39.841 --> 19:13:44.035
在我们的代码中当我们部署这个时，这实际上是我们完成项目的地方。

11681
19:13:44.035 --> 19:13:51.207
因为我们在这里要做的其他事情，我们已经做过了，我们需要做的就是创建一个部署脚本并编写一些测试。

11682
19:13:51.207 --> 19:13:51.755
真的是这样。

11683
19:13:51.755 --> 19:13:58.778
因为现在您已经具备了编写部署脚本所需的所有技能，然后还可以为这个项目编写一些测试。

11684
19:13:58.778 --> 19:14:02.557
因此，我强烈建议您在此暂停视频，并尝试编写自己的部署脚本。

11685
19:14:02.557 --> 19:14:17.429
即使你想写自己的测试，你也可以参考与这节课相关的GitHub回购，因为我们在这里有一个部署脚本，我们也在这里有一个TypeScript版本，我们不打算再讲了。

11686
19:14:17.429 --> 19:14:27.548
当然，如果您完全迷失了方向，这里有大量的说明可以帮助您了解更多信息，并帮助您使用这个特定的存储库。

11687
19:14:27.691 --> 19:14:30.970
让我们快速回顾一下刚刚学过的内容。

11688
19:14:31.692 --> 19:14:37.837
代币，或EIP 20代币，或bp或p p，或这些破折号20中的任何一个。

11689
19:14:37.837 --> 19:14:42.273
改进建议就是所谓的令牌标准。

11690
19:14:42.273 --> 19:14:48.060
而令牌标准，这些链上的令牌实际上只是智能合约的令牌。

11691
19:14:48.060 --> 19:15:02.627
现在，这些代币明显不同于第一层代币，如Aetherium，或polygon或Avalanche或arbitration，它们不会是智能合约，它们将是区块链原生代币，你会听到我经常把它称为区块链原生代币。

11692
19:15:02.627 --> 19:15:08.629
而不是这些代币，这些ERC 20，这些智能合约代币，它们只是智能合约。

11693
19:15:08.692 --> 19:15:18.743
它们只是这些表示每个地址有多少令牌的函数的组合，我们可以用添加的所有规范创建我们自己的令牌。

11694
19:15:18.743 --> 19:15:26.803
或者我们可以用openzeppelin来导入代币现在另一个像open Zeppelin一样流行的回购将是这个来自Rory资本的叫soulmate的。

11695
19:15:26.803 --> 19:15:30.739
它们都旨在成为坚固性的标准库。

11696
19:15:30.739 --> 19:15:35.446
要记住的一件重要的事情是这些令牌有这个允许映射。

11697
19:15:35.446 --> 19:15:40.804
你可以允许其他地址访问你的令牌并移动你的令牌。

11698
19:15:40.804 --> 19:15:50.428
这很重要，特别是当我们稍后使用defy时，当我们想给令牌一些智能合约访问权，这样它们就可以把它输入到defy协议中。

11699
19:15:50.428 --> 19:15:52.031
这也有点棘手。

11700
19:15:52.031 --> 19:15:57.692
你要确保你不允许恶意合约与你的代币交互。

11701
19:15:57.692 --> 19:16:06.692
我们还会看到，当我们开始与这些代币进行更多的交互时，在任何合同可以与我们的代币交互之前，我们需要批准它们与我们的代币交互。

11702
19:16:06.692 --> 19:16:07.392
就是这样。

11703
19:16:07.392 --> 19:16:10.407
现在您是令牌向导，可以部署自己的令牌了。

11704
19:16:10.407 --> 19:16:18.557
休息一下，喝杯咖啡，下期见。

11705
19:16:18.693 --> 19:16:29.811
好了，欢迎来到下一节课，我们将在这一节课中学习defy，它将是程序化的，并将与defy协议进行程序化的交互。

11706
19:16:29.811 --> 19:16:36.630
在这一节课上，我为您感到非常兴奋，因为defi是智能合约的最佳用例之一。

11707
19:16:36.630 --> 19:16:49.559
我现在特别兴奋的一个用例，正如我所提到的，过去的defy代表去中心化金融，我们在GitHub存储库中留下了一些链接，让你们了解更多关于defy的信息。

11708
19:16:49.559 --> 19:16:54.951
我们对defy如此兴奋的一个主要原因是，我们脱离了这个传统共识的领域。

11709
19:16:54.951 --> 19:16:57.771
这就是智能合约的意义所在。

11710
19:16:57.771 --> 19:17:06.271
他们要把这个中心化的实体，从我们的金融世界中移除，特别是从那些有利益冲突的金融机构中移除。

11711
19:17:06.271 --> 19:17:09.226
他们做生意是为了赚钱而不是为了保护我们的钱不是为了赚钱。

11712
19:17:09.226 --> 19:17:16.209
我们希望与一个一切都透明的体系合作，特别是在金融服务方面。

11713
19:17:16.209 --> 19:17:21.483
因此，我们希望进入智能合约的世界，特别是在涉及到我们的资金时。

11714
19:17:21.483 --> 19:17:32.065
在我看来，defi将会是影响大众的行业，最快因为去中心化金融比中心化金融更公平更好。

11715
19:17:32.065 --> 19:17:54.744
目前，你在defy中获得的利率，收益和利息要比集中金融好得多，因为记住，它不再使用这些集中协议，你会说，嘿，相信我们，我们会让你进入市场或者不相信我们，把你的钱放在我们这里会保证你的钱的安全而不是不得不相信这些公司和实体，这是我们想要的。

11716
19:17:54.744 --> 19:18:06.394
此外，我们的Oracle网络越完善，Oracle网络与智能合约平台如Aetherium, polygon，套利平台的合作越多，我们就能提供更多的数据和更复杂的金融产品。

11717
19:18:06.394 --> 19:18:14.903
我对defy如此兴奋的另一个原因是如果你看这个小图表，它按规模显示了不同的市场。

11718
19:18:14.903 --> 19:18:27.439
现在这个图像有点过时了，但它仍然向你展示了所有这些不同行业的相对规模现在是一个2000亿美元的市场，大约有2000亿美元被锁定在这个行业。

11719
19:18:27.439 --> 19:18:29.122
我马上给你们看。

11720
19:18:29.122 --> 19:18:33.660
加密货币实际上，在记录的时候并不是3600亿。

11721
19:18:33.660 --> 19:18:35.439
实际上是1。

11722
19:18:35.439 --> 19:18:36.115
8万亿年。

11723
19:18:36.115 --> 19:18:37.641
所以事情远不止这些。

11724
19:18:37.641 --> 19:18:43.746
但它仍然是所有其他领域的一个巨大子集，就像黄金市场是一个10万亿美元的市场。

11725
19:18:43.746 --> 19:18:52.277
股票市场几乎是100万亿美元的全球房地产，衍生品几乎是300万亿美元的千万亿美元。

11726
19:18:52.277 --> 19:19:01.253
所以FBI现在是一个非常非常非常非常非常小的分支，在我看来，所有这些领域都可以通过Defy重新规划。

11727
19:19:01.253 --> 19:19:03.928
所以我们正在努力，我们正在达到目标。

11728
19:19:03.928 --> 19:19:14.653
因此，制定这些协议将取决于我们，让人们更容易进入他们的财务将更公平、更负责和更透明的空间。

11729
19:19:14.653 --> 19:19:22.953
有了更好的产出率，我们可以很好地总结这个网站上发生的事情，这个网站叫做“反抗美洲驼”。

11730
19:19:22.953 --> 19:19:28.294
它显示了锁定在所有这些不同的去中心化协议中的总价值。

11731
19:19:28.294 --> 19:19:32.345
我们可以看到很多是跨多个链的。

11732
19:19:32.345 --> 19:19:47.695
其中很多是与EVM兼容的链，Aetherium, Biden, smart chain, avalanche, Fanta, drawn polygon，所有这些都是与EVM兼容的区块链，我们可以确切地看到独立用户在这些协议中投入了多少钱。

11733
19:19:47.695 --> 19:19:52.602
记录Ave的时间是对总价值锁定的第一协议。

11734
19:19:52.602 --> 19:20:00.195
所以有220亿美元被锁定在Ave，这就是我们今天要讲的协议。

11735
19:20:00.695 --> 19:20:07.135
Ave是一个借贷协议，它允许我们借贷加密货币。

11736
19:20:07.135 --> 19:20:21.432
我们可以用代币作为抵押品，这有点类似于把钱存在银行，从其他人向我们借抵押品中获得收益这和银行的做法几乎完全一样，除了它被称为非托管。

11737
19:20:21.432 --> 19:20:23.465
给Ave团队的永远不要碰我们的钱。

11738
19:20:23.465 --> 19:20:24.958
没人碰过这些钱。

11739
19:20:24.958 --> 19:20:26.589
这只是一个智能合约。

11740
19:20:26.589 --> 19:20:28.504
这些都是编程代码。

11741
19:20:28.504 --> 19:20:33.325
所以我们可以放心，没有人会卷走我们的钱，没有人会做坏事。

11742
19:20:33.325 --> 19:20:34.712
我们也获得了更高的收益率。

11743
19:20:34.712 --> 19:20:40.326
借贷是创建真正有趣的金融应用程序的关键部分。

11744
19:20:40.326 --> 19:20:44.409
如果你想卖空某物，如果你想提高某资产的杠杆率如果你想。

11745
19:20:44.409 --> 19:20:49.781
如果你想做更复杂的金融产品，你就需要借贷。

11746
19:20:49.781 --> 19:20:55.039
现在很多典型的金融科技或金融技术或金融术语都适用于这里。

11747
19:20:55.039 --> 19:20:59.516
这门课不会深入研究这些金融产品是如何运作的。

11748
19:20:59.516 --> 19:21:01.559
这门课也不是关于金融的。

11749
19:21:01.559 --> 19:21:07.254
如果你想了解更多关于金融的知识，我们将在我们的GitHub回购中留下一些与这门课程相关的链接。

11750
19:21:07.254 --> 19:21:13.083
你可以学到更多金融知识，成为我所说的逆量化工程师，逆量化工程师。

11751
19:21:13.083 --> 19:21:16.321
我很高兴有更多的挑战者进入这个领域。

11752
19:21:16.321 --> 19:21:19.258
好了，这是Ave应用程序。

11753
19:21:19.258 --> 19:21:28.083
它在Ave。市场上，我们现在在Avi的市场上，我们在这里所做的一切都将在主网上工作，但我们将在他们的测试网上使用它。

11754
19:21:28.083 --> 19:21:33.117
这显然是旧的UI，他们有一个新网站看起来比这个更好。

11755
19:21:33.117 --> 19:21:43.789
但我们将经历很多基本功能，存款，贷款，甚至可能做空资产，如果我们想，我不建议去这个网站，因为它可能不会工作和冠状病毒的方式，你期待它。

11756
19:21:43.789 --> 19:21:45.851
所以，坐好，放松，看着。

11757
19:21:45.851 --> 19:21:48.596
为了让我们做空或保证金交易。

11758
19:21:48.596 --> 19:21:55.433
我们需要做的第一件事实际上是存放一些抵押品，我们需要存放一些抵押品以便以这种方式借款。

11759
19:21:55.433 --> 19:22:03.838
如果我们永远无法偿还我们借的贷款或者我们借的钱，Ave，我们就会直接拿走我们放在这里的抵押品，我们会进行所谓的清算赎回。

11760
19:22:03.838 --> 19:22:07.187
这就是为什么这实际上比传统市场的卖空更安全。

11761
19:22:07.187 --> 19:22:15.508
因为如果你的抵押品少于你所借的，你会立即被清算，但你仍然会损失一大笔钱，所以不要被清算。

11762
19:22:15.508 --> 19:22:24.323
所以我们现在要做的是滚动到Aetherium，我们要在这里连接我们的钱包，我们要在这里移动到COVID测试网络浏览器。

11763
19:22:24.323 --> 19:22:27.357
我们要讲的是存款部分。

11764
19:22:27.357 --> 19:22:32.196
这里已经显示出平衡了，点2 /。

11765
19:22:32.196 --> 19:22:34.196
我们存0。

11766
19:22:34.196 --> 19:22:34.321
1.

11767
19:22:34.696 --> 19:22:38.889
我们要去存款，超膜会弹出，确认。

11768
19:22:39.696 --> 19:22:52.903
这个通过了，这意味着我们已经把它存入了我们到仪表板上，我们可以看到这里有一些，第一点有一些API，这有点像我们将从存入Ave中得到的回报百分比。

11769
19:22:52.903 --> 19:22:58.123
是的，我们可以用它作为抵押品，我们有这个，这里标记为是。

11770
19:22:58.123 --> 19:23:00.506
这就是我们要做的。

11771
19:23:00.506 --> 19:23:01.886
上面说没有借过。

11772
19:23:01.886 --> 19:23:03.960
是的，我们可以点击这个“立即借用”按钮。

11773
19:23:03.960 --> 19:23:09.180
我们将进入借款人界面，我们将选择我们想借的资产。

11774
19:23:09.180 --> 19:23:18.915
现在，每当我们借用其中一个，就有了这些API，对吧?这是为了借到这笔资产，我们在一年内需要支付的百分比。

11775
19:23:18.915 --> 19:23:34.729
稳定的意味着它永远是for变量的意思是它会根据协议的流动性变化而变化，你可以选择你想要的是哪一个稳定的是你总是4%的变量会有一点风险，但你可能会得到更低的费用。

11776
19:23:34.729 --> 19:23:39.297
所以我们实际上要借一些染料，因为染料是稳定的硬币。

11777
19:23:39.297 --> 19:23:40.230
它值1美元。

11778
19:23:40.230 --> 19:23:57.911
在某种程度上，你可以称之为保证金提取因为我们提取染料去借另一种方式我们可以说我们在做空染料这听起来有点有趣，但你可以选择你想借多少你会看到这个叫做健康因子的东西我把它放大一点当我们滚动这个东西的时候，这个叫做健康因子的东西。

11779
19:23:57.911 --> 19:24:07.268
健康因子表示你离被清算有多近记得我说过你可以被清算健康因子表示我们离被清算有多近。

11780
19:24:07.268 --> 19:24:11.897
这意味着我们接近于总是说，你知道我们拿了你的钱。

11781
19:24:11.897 --> 19:24:27.497
如果它在任何时候低于1，就会有人对你进行清算并拿走我们存入的大量存款，健康因素背后有一些数学运算，你可以去Ave文档，我会在描述中留一个链接来阅读更多关于健康因素的内容。

11782
19:24:27.497 --> 19:24:31.698
我们要借29个骰子，我们要借30元。

11783
19:24:31.698 --> 19:24:41.347
点击继续，输入一个变量，缩小，继续，我们会借用metamath弹出，确认事务挂起。

11784
19:24:41.347 --> 19:24:42.682
我们要去仪表盘。

11785
19:24:42.682 --> 19:24:49.967
现在我们可以看到新的余额，我们可以看到每个点，存入，29个死亡。

11786
19:24:49.967 --> 19:25:03.873
我们可以在这里看到我们的健康系数，你甚至可以点击这个小按钮，说，嘿，它代表你离被清算有多近，我们可以在这里看到价值，我们的生命值200美元，或者死亡值30美元。

11787
19:25:03.873 --> 19:25:04.364
所以我们没问题。

11788
19:25:04.364 --> 19:25:05.276
我们在这里很健康。

11789
19:25:05.276 --> 19:25:12.138
为了让Avi了解并为基础抵押品定价，这样它就知道能借出多少钱。

11790
19:25:12.138 --> 19:25:23.915
显然，另一种协议使用了改变价格对价格的反馈，也就是基础抵押品，很多数十亿美元的协议在后端使用了链连接来实现所有的定价机制。

11791
19:25:23.915 --> 19:25:29.766
这就是它的本质，我们可以偿还债务，我们可以借更多资产，我们可以交换资产。

11792
19:25:29.766 --> 19:25:34.649
我们暂停资产的利息回报是惊人的。

11793
19:25:34.649 --> 19:25:50.525
现在我们学了一点如何使用他们的UI，它是在IPFS上托管的，顺便说一下，让我们继续，让我们学习如何做所有这些，让我们更编程地做，这样我们就可以成为量子工程师了。

11794
19:25:50.698 --> 19:26:00.870
现在，就像我说的，我们将使用Ave v 2协议，如果你想尝试v3，你完全可以，如果你现在可以去那里玩，它仍然锁定了更多的钱，这很好。

11795
19:26:00.870 --> 19:26:03.101
但是v3协议显然是最新加入的。

11796
19:26:03.101 --> 19:26:06.660
我们会在文档和代码库之间来回切换。

11797
19:26:06.698 --> 19:26:09.456
所以我建议你们把文档也准备好。

11798
19:26:09.698 --> 19:26:15.032
通常，我们将要使用的所有代码都在这个硬帽定义的Free code Camp库中。

11799
19:26:15.032 --> 19:26:16.150
让我们开始吧。

11800
19:26:16.150 --> 19:26:25.387
这里是by VS code，这里是这门课的文件夹，我们要新建一个文件夹，命名为hard hat，违抗FCC，然后cd到里面。

11801
19:26:25.387 --> 19:26:29.099
然后我们将用代码期来打开它。

11802
19:26:29.099 --> 19:26:33.408
或者你也可以按惯例，打开文件，然后打开那个文件夹。

11803
19:26:33.408 --> 19:26:38.635
现在我们在做一个新项目，我们要做纱线，添加dash Dev，不是帽子。

11804
19:26:38.699 --> 19:26:42.339
我们将添加安全帽开始我们的极简安全帽项目。

11805
19:26:42.339 --> 19:26:50.664
再一次，为了启动您的极简的硬帽项目，我通常只是从另一个文件夹复制粘贴，或者我只是使用我们在智能合约代码repo中看到的硬帽启动工具包。

11806
19:26:50.664 --> 19:26:57.215
但是无论你用什么方法来启动你的项目，你都可以使用现在我们有了这个，我们可以运行yarn hardhat。

11807
19:26:57.215 --> 19:26:59.512
我们将创建一个空的硬帽。

11808
19:26:59.512 --> 19:26:59.817
配置。

11809
19:26:59.817 --> 19:26:59.918
js。

11810
19:26:59.918 --> 19:27:04.546
现在为了节省一些制作样板的时间，我要复制粘贴我的安全帽。

11811
19:27:04.546 --> 19:27:04.952
配置。

11812
19:27:04.952 --> 19:27:09.682
Js从一个过去的项目到这个，只是使它，这样我们就不必再通过那个样板设置。

11813
19:27:09.682 --> 19:27:13.652
我还要复制粘贴智能合约彩票的这句话。

11814
19:27:13.699 --> 19:27:18.021
同样，如果你想使用你的JSON包或yarn点锁来安装依赖项，你完全可以。

11815
19:27:18.021 --> 19:27:21.190
我要把它粘贴到这里，然后运行。

11816
19:27:21.190 --> 19:27:28.010
然后复制粘贴到我的漂亮文件上，这样所有的JavaScript都可以按照我想要的方式格式化。

11817
19:27:28.010 --> 19:27:28.403
好了,好了。

11818
19:27:28.403 --> 19:27:33.572
现在我们已经有了一个极简的项目，让我们继续，开始学习如何在这里与AVI协议交互。

11819
19:27:33.572 --> 19:27:37.062
让我们快速自述一下并讨论一下我们希望能够做什么。

11820
19:27:37.062 --> 19:27:41.953
首先，我们希望能够学习如何以编程方式存放抵押品。

11821
19:27:41.953 --> 19:27:52.771
如果我们停在这里，那可能就足够了，我们就能程序化地存入抵押品，这样我们就能获得收益，我们就能从存入的抵押品中获得百分比回报率。

11822
19:27:52.771 --> 19:27:55.356
因此，完成这一任务本身已经是一项壮举。

11823
19:27:55.356 --> 19:28:00.649
但假如我们想更进一步，我们想进入这些更有趣的金融产品。

11824
19:28:00.700 --> 19:28:15.650
在存入一些抵押品之后，我们将学习如何通过编程借入其他资产，存入的抵押品将是斜线包装的，我们稍后会讲到，我们将借入另一种资产，在这个演示中，它将是dye。

11825
19:28:15.650 --> 19:28:19.896
我们使用染料的原因是染料被称为稳定的硬币。

11826
19:28:19.896 --> 19:28:27.527
染料实际上是由道琼斯公司创造的区块链上的一个代币染料代币的价格总是固定在1美元。

11827
19:28:27.527 --> 19:28:43.458
我们把每一个作为抵押品，我们借加密货币，美元，我们借这个代币，它代表一美元，然后我们将偿还它，我将偿还几乎所有的东西你马上就会明白为什么我们不偿还所有的东西。

11828
19:28:43.458 --> 19:28:46.527
我想快速讨论的另一个协议是uniswap协议。

11829
19:28:46.527 --> 19:28:49.914
uniswap协议已经成为交易的避风港。

11830
19:28:49.914 --> 19:28:59.454
这是一个去中心化的应用程序，允许我们在一个叫做自动做市商的东西上彼此交易资产和代币。

11831
19:28:59.454 --> 19:29:05.257
它基本上结束了一个去中心化的证券交易所，但是有代币，代币并不是确切的股票，它们非常不同。

11832
19:29:05.257 --> 19:29:10.768
所以当你想要得到这些资产的时候就像包装好的Aetherium或染料或链接代币。

11833
19:29:10.768 --> 19:29:15.454
在主网上，通常，你会使用这些去中心化交换之一。

11834
19:29:15.454 --> 19:29:25.436
很明显，这些去中心化的交易所更加公平，因为在它们上面发生的一切都是透明的，比中心化的金融公平得多，在它们上面发生的一切都是透明的。

11835
19:29:25.436 --> 19:29:30.343
你可以看到链上发生的一切，这绝对是现象级的。

11836
19:29:30.343 --> 19:29:32.653
让我们从这里开始。

11837
19:29:32.653 --> 19:29:34.605
我们来创建脚本文件夹。

11838
19:29:34.701 --> 19:29:40.335
因为在这个项目中，我们并不会自己创建任何契约，我们只会学习如何与这些协议交互。

11839
19:29:40.335 --> 19:29:46.601
如果您确实想学习如何构建其中一些协议，在本节课的最后，我们将为您提供大量链接。

11840
19:29:46.601 --> 19:29:51.911
我们将有一位特别嘉宾解释几种不同的方法来学习如何构建更多的去中心化协议。

11841
19:29:51.911 --> 19:29:56.044
虽然我们已经用去中心化彩票建立了一个，这很棒。

11842
19:29:56.044 --> 19:29:57.628
让我们在这里创建一些脚本。

11843
19:29:57.628 --> 19:30:01.055
对于所有这些东西，存入抵押品，借入和偿还。

11844
19:30:01.055 --> 19:30:05.210
我们将把这些都放到一个名为Ave borrow。Jas的新脚本中。

11845
19:30:05.210 --> 19:30:07.586
所以我们要在这里做所有事。

11846
19:30:07.586 --> 19:30:17.097
因为这是一个脚本，它会有相同的设置，就像我们之前看到的一样，我们会有这个主要的东西围绕一个async函数。

11847
19:30:17.097 --> 19:30:20.442
主菜单，然后是我们的进口菜单，当然是在最上面。

11848
19:30:20.442 --> 19:30:32.995
有件事很重要，我们去avi，我们去协议，我们通读文档，最终我们会发现协议把所有东西都当作ERC 20令牌。

11849
19:30:32.995 --> 19:30:40.614
但我们知道Aetherium或你正在使用的原生区块链代币不是ERC 20代币。

11850
19:30:40.701 --> 19:30:52.501
把所有东西都当成ERC 20代币的原因是这样更容易，对吧?如果所有东西都使用ERC 20令牌标准，那么发送和交互就容易得多。

11851
19:30:52.701 --> 19:31:07.239
在很多这样的协议中，当我们要存入以太币，或多边形，或任意标记等等，实际发生的情况是，他们将你的以太币通过所谓的网络网关发送，并将其交换为weath，即rapt ether。

11852
19:31:07.239 --> 19:31:09.668
基本上就是Aetherium。

11853
19:31:09.668 --> 19:31:17.074
但在ERC 20令牌合约中，我们想做的是做同样的事情，我们会跳过使用这个网络网关。

11854
19:31:17.074 --> 19:31:21.352
我们自己就会得到网络令牌，我们会用它作为抵押品。

11855
19:31:21.352 --> 19:31:26.035
在script标签中，我将创建另一个文件getweath。

11856
19:31:26.035 --> 19:31:26.168
js。

11857
19:31:26.168 --> 19:31:35.130
在这里，我们会继续，我们会建立一个脚本来存放我们的令牌为web令牌。

11858
19:31:35.130 --> 19:31:36.701
好了，让我们创建脚本。

11859
19:31:36.701 --> 19:31:40.960
在以太扫描和GitHub回购中有一个到web令牌的链接。

11860
19:31:40.960 --> 19:31:44.572
它的工作方式是，你把Aetherium存起来。

11861
19:31:44.702 --> 19:31:49.321
作为回报，它会给你里格比的网络代币，存入0。

11862
19:31:49.321 --> 19:31:49.511
05.

11863
19:31:49.511 --> 19:31:56.152
继续写，我连接到以太扫描，我继续写这个交易，我要喝尿。

11864
19:31:56.152 --> 19:32:00.831
所以我并不在乎这是不是真正的合同，因为这不是真正的钱。

11865
19:32:00.831 --> 19:32:02.292
但我要存入0。

11866
19:32:02.292 --> 19:32:02.751
05年容易的。

11867
19:32:02.751 --> 19:32:20.035
交易完成后，我们复制合同地址，将这个令牌添加到Metamask中就像添加链接一样导入令牌，将地址粘贴到这里，添加自定义令牌，导入令牌会看到这里有一些wet令牌，我存入了0。

11868
19:32:20.035 --> 19:32:21.066
0前面是1。

11869
19:32:21.066 --> 19:32:21.782
1 + 0。

11870
19:32:21.782 --> 19:32:23.959
05，这就是为什么它显示为0。

11871
19:32:23.959 --> 19:32:27.809
因为我做了两次，嗯，在我没有录音的时候。

11872
19:32:27.809 --> 19:32:31.102
这就是把这个湿代币写进合同的方法。

11873
19:32:31.102 --> 19:32:34.502
你可以随时调用这个取款函数。

11874
19:32:34.502 --> 19:32:39.029
你可以把你的Aetherium取出来然后做所谓的烧掉你的湿代币。

11875
19:32:39.029 --> 19:32:49.638
当你从weather换回Aetherium时，你按下取款键，然后你基本上就把它们换回来了因为合约本身现在持有你的Aetherium代币。

11876
19:32:49.702 --> 19:32:58.750
很酷，对吧?在get wet函数中，我们不会在这里添加这个主函数，我们会在这里创建get West作为一个模块我们会将它导入Ave borrow中。

11877
19:32:58.750 --> 19:33:01.957
所以我们不打算做你们在这里看到的这个主要的东西。

11878
19:33:01.957 --> 19:33:06.325
相反，我们将创建一个名为Get Wes的异步函数。

11879
19:33:06.325 --> 19:33:09.864
下面，我们要导出它。

11880
19:33:09.864 --> 19:33:14.509
我们写module。exports = get weather。

11881
19:33:14.703 --> 19:33:22.356
我们要导出它这样我们的Avi borrow就可以使用我们正在创建的get West脚本，让我们添加让我们来做这个。

11882
19:33:22.356 --> 19:33:26.369
为了与合同交互，我们需要一个账户。

11883
19:33:26.369 --> 19:33:33.555
我们可以按惯例执行const deployer = await get named accounts。

11884
19:33:33.555 --> 19:33:37.082
我们写入const getname accounts = require hardhat。

11885
19:33:37.082 --> 19:33:39.392
我的VS code自动导入了，谢谢VS code。

11886
19:33:39.392 --> 19:33:46.582
现在我们要调用西边契约的存款函数。

11887
19:33:46.703 --> 19:33:56.638
我们如何称呼西部合同的存款功能?那合同怎么称呼呢?那你需要什么?你需要ABI，然后你需要合同地址。

11888
19:33:56.703 --> 19:33:57.399
把这个钻进去。

11889
19:33:59.703 --> 19:34:02.003
与合同交互的合同地址。

11890
19:34:02.703 --> 19:34:17.457
如果我们知道如果我们给我们的项目整个合同，它会得到API但我们也知道如果我们只做接口，那也一样好，它不会给我们所有的功能，但它会告诉它会给我们API，它会告诉我们它可以使用什么功能。

11891
19:34:17.457 --> 19:34:21.799
我们要创建一个新文件夹，创建合约文件夹。

11892
19:34:21.799 --> 19:34:25.211
在这里，我们会在里面创建一个新文件夹叫做interfaces。

11893
19:34:25.211 --> 19:34:28.274
这就是我们要创建网页界面的地方。

11894
19:34:28.274 --> 19:34:32.623
现在一个web界面将会非常类似于ERC 20的界面。

11895
19:34:32.623 --> 19:34:36.672
如果你想自己添加，请随意。

11896
19:34:36.672 --> 19:34:55.481
或者你可以直接访问与这节课相关的GitHub回购，到iOS上复制粘贴，你会看到这里的功能和ERC 20完全一样，允许批准的小数点余额，还有这些额外的存取款功能。

11897
19:34:55.481 --> 19:35:03.976
复制所有这些，回到我的安全帽项目，创建一个新文件，命名为I left。soul。

11898
19:35:03.976 --> 19:35:13.736
需要注意的是，通常，最好的做法是有接口，从眼睛开始，这样你就知道接口是什么然后我们把它粘贴到这里。

11899
19:35:13.736 --> 19:35:17.359
现在为了编译它，我们需要使用0。

11900
19:35:17.359 --> 19:35:19.818
4分19版牢固性。

11901
19:35:19.818 --> 19:35:23.867
所以我们能做的是，我们可以回过头来。

11902
19:35:23.867 --> 19:35:24.260
配置。

11903
19:35:24.260 --> 19:35:24.391
js。

11904
19:35:24.391 --> 19:35:27.059
我们有坚实的编译器，版本0。

11905
19:35:27.059 --> 19:35:31.514
07或者其他版本的，我们可以添加或者替换。

11906
19:35:31.514 --> 19:35:35.551
我在这里加个逗号，版本0。

11907
19:35:35.551 --> 19:35:36.906
4点19分。

11908
19:35:36.906 --> 19:35:37.583
保存。

11909
19:35:37.583 --> 19:35:47.929
现在为了确保我们能得到那个API，做yarn, hardhats编译，或者hh编译，很好，我们编译这个接口。

11910
19:35:47.929 --> 19:35:50.304
现在我们有了ABI来进行交互。

11911
19:35:50.304 --> 19:35:55.654
现在我们有了ABI，这里有一个小的复选标记，让我们继续并获取合同地址。

11912
19:35:55.704 --> 19:36:07.754
但是因为我们很快就会学到的原因，我们实际上只会使用主网络集来获取Rinkeby测试和地址，我将在主网络上查找，我们将在主网络上找到web令牌。

11913
19:36:07.754 --> 19:36:10.229
所以我要复制主网的地址。

11914
19:36:10.229 --> 19:36:16.067
同样，你也可以从与这节课相关的GitHub回购中获取这个地址。

11915
19:36:16.067 --> 19:36:21.043
现在，我们会在这里打个勾，然后把地址粘贴到这里。

11916
19:36:21.043 --> 19:36:26.080
现在我们有了从接口编译的ABI，我们有了主网的合同地址。

11917
19:36:26.080 --> 19:36:28.330
现在让我们继续创建这个契约。

11918
19:36:28.330 --> 19:36:37.117
我们可以说const, iOS = await ethers。然后我们还需要从Hardhead导入ethers。

11919
19:36:37.117 --> 19:36:52.816
Ethers。get contract at这是Ethers上的另一个功能，它允许我们在特定地址上获取合约，我们说get contract app，我们现在用的是iOS ABI，我们在这里硬编码这个地址。

11920
19:36:52.816 --> 19:36:55.092
然后我们将它连接到部署器。

11921
19:36:55.092 --> 19:37:02.068
我们说，让我们与ABI的iOS在这个地址连接到Deployer。

11922
19:37:02.068 --> 19:37:07.276
所以我们可以继续运行await AI并进行点存款。

11923
19:37:07.276 --> 19:37:10.450
我们会设置一些数值。

11924
19:37:10.450 --> 19:37:21.882
让我们继续，在顶部，我们写上const amount =我们写上ethers。utils。parse, ether，然后我们写上0。

11925
19:37:21.882 --> 19:37:22.220
0 0。

11926
19:37:22.220 --> 19:37:22.445
02.

11927
19:37:22.445 --> 19:37:24.805
存入0。

11928
19:37:24.805 --> 19:37:32.475
02会说const TX =这就会做await TX。wait one等待一个block通过。

11929
19:37:32.475 --> 19:37:36.505
然后我们会得到余额会说const。

11930
19:37:36.505 --> 19:37:42.015
与雇主的差额等于等待我与雇主的差额。

11931
19:37:42.015 --> 19:37:47.020
我们将调用iWeb ERC 20令牌上的balance函数。

11932
19:37:47.020 --> 19:37:54.659
然后我们用console。log得到West balance。

11933
19:37:54.659 --> 19:37:56.333
字符串。

11934
19:37:56.706 --> 19:37:58.856
这里我们用的是主网络地址。

11935
19:37:59.706 --> 19:38:01.899
说好吧，我们要存入一些钱，我们要等待。

11936
19:38:01.899 --> 19:38:13.596
然后我们要继续保持平衡，我们把Aetherium存进去这样我们就能得到ERC 20版本的Aetherium，也就是这个West代币。

11937
19:38:13.706 --> 19:38:19.170
现在，你可能会想，好吧，为什么你把主地址放在这里?帕特里克，走慢点。

11938
19:38:19.170 --> 19:38:23.635
让我们继续，让我们创建一个模拟Web Token合同地址。

11939
19:38:23.706 --> 19:38:31.826
让我们先部署模拟，然后我们继续使用我们一直在做的相同的设置，为什么你要直接硬编码这个在这里。

11940
19:38:31.826 --> 19:38:34.610
我已经提到这个有一段时间了。

11941
19:38:34.610 --> 19:38:38.706
但我们还有另一种方法可以在智能合约中运行测试。

11942
19:38:38.706 --> 19:38:47.028
这就是所谓的主网分叉，我们可以在主网分叉的地方，运行一个本地硬帽节点。

11943
19:38:47.028 --> 19:38:50.253
这是假装成网络主节点。

11944
19:38:50.253 --> 19:38:54.706
我们所要做的就是更新我们的硬头配置来做到这一点。

11945
19:38:54.706 --> 19:38:57.050
我们来谈谈分叉的问题。

11946
19:38:57.050 --> 19:39:06.996
在左边这里，我们有区块链区块链的一个例子它类似于一个测试网或主网像Rinkeby, eath，主网多边形等。

11947
19:39:06.996 --> 19:39:10.127
这将是我们部署到的区块链。

11948
19:39:10.127 --> 19:39:14.994
这里有一大堆方块，对吧?我们有一个巨大的链条可以利用。

11949
19:39:14.994 --> 19:39:26.792
区块链上的所有信息都是公共信息，比如这个区块将有交易，每个区块将有一大堆交易。

11950
19:39:26.792 --> 19:39:29.528
所有这些信息都在这个公共区块链上。

11951
19:39:29.528 --> 19:39:37.657
除了所有这些交易，它还会有价格供给合约，它会有Ave合约，网络代币，合约等。

11952
19:39:37.707 --> 19:39:40.852
所有这些合同信息都是公开的。

11953
19:39:42.707 --> 19:39:50.373
它已经在那里了，我们基本上可以把它复制到我们的本地环境中，自己做一些模拟。

11954
19:39:50.373 --> 19:39:53.216
这正是分叉所做的。

11955
19:39:53.216 --> 19:40:01.564
一个分叉区块链取一个现有区块链的副本就像左边的这个，把它带到我们的本地计算机上。

11956
19:40:01.564 --> 19:40:08.653
我们实际上可以控制本地运行的区块链，因为它会在本地计算机上运行，类似于hard hat。

11957
19:40:08.707 --> 19:40:16.168
现在，我们在这个局部分叉区块链上所做的一切都不会影响到主区块链，因为它是一个模拟区块链。

11958
19:40:16.168 --> 19:40:18.152
它只是在我们当地的环境中运行。

11959
19:40:18.152 --> 19:40:24.657
所以我们实际上可以与这个分叉互动这种局部的区块链类似于模仿实际的区块链。

11960
19:40:24.707 --> 19:40:29.516
这就是分叉所不做的，它不会下载整个区块链到我们的本地设置中。

11961
19:40:29.516 --> 19:40:31.069
任何时候我们引用一个地址。

11962
19:40:31.069 --> 19:40:45.641
当我们引用某个特定地址的东西时，我们调用一个API到Aetherium节点，同样，我们使用了炼金术，然后说，这个地址有什么，它就会为我们返回那个特定的契约。

11963
19:40:45.707 --> 19:40:47.671
这样，我们就不用下载整个区块链了。

11964
19:40:47.707 --> 19:40:48.771
而且速度也快得多。

11965
19:40:50.707 --> 19:40:52.816
我们的测试运行我们的脚本来完成所有的事情。

11966
19:40:53.707 --> 19:40:55.167
你会想，哇，帕特里克，这听起来太棒了。

11967
19:40:55.707 --> 19:40:58.658
我们什么都这么做吗?嗯，这是需要权衡的。

11968
19:40:58.707 --> 19:41:03.034
优点是它快速、简单，而且测试与主网上的类似。

11969
19:41:03.034 --> 19:41:07.264
缺点是我们需要一个API，我们不能在本地做所有事情。

11970
19:41:07.264 --> 19:41:12.023
有些契约，有些契约处理起来比较复杂，而mock可能更好。

11971
19:41:12.023 --> 19:41:16.953
但是使用分叉网络可能是运行测试的好方法，它可能是只使用mock的一个很好的替代方法。

11972
19:41:16.953 --> 19:41:20.774
所以这真的取决于什么对你和你的项目是正确的。

11973
19:41:20.774 --> 19:41:26.129
但是它是一个非常棒的工具，特别是对于像Avi这样我们想要快速测试一些东西的工具。

11974
19:41:26.129 --> 19:41:30.347
硬分叉也会给我们一堆假账号。

11975
19:41:30.347 --> 19:41:35.134
所以我们仍然会在主网上得到一堆假账户，我们会给出一个定理。

11976
19:41:35.134 --> 19:41:37.658
所以我们会得到这个分叉的假的主网络账户。

11977
19:41:37.658 --> 19:41:42.035
接下来，我们将使用这个分叉来运行脚本和测试。

11978
19:41:42.035 --> 19:41:46.108
如果你想在这之后回去，在COVID上尝试所有这些。

11979
19:41:46.108 --> 19:41:51.095
我们为COVID网络提供了一大堆不同的地址，所以你可以直接在COVID上运行这些脚本。

11980
19:41:51.095 --> 19:41:53.127
你可以自己看到交易。

11981
19:41:53.127 --> 19:42:02.535
请注意，在使用COVID时，您需要确保使用的地址与AVI文档中为COVID网络使用的地址相同，因为它们有时会更改。

11982
19:42:02.535 --> 19:42:06.242
很好，我们继续，我们会到RT head。config。js。

11983
19:42:06.242 --> 19:42:12.514
现在我们来看看我们的网络，现在我什么都没有，我只有排名。

11984
19:42:12.514 --> 19:42:17.408
我们在这里加上安全帽，在下面加上一个小逗号。

11985
19:42:17.408 --> 19:42:21.623
我们会说，链ID当然是31337。

11986
19:42:21.623 --> 19:42:23.691
我们将添加这个分叉关键字。

11987
19:42:23.691 --> 19:42:28.930
在这里，我们会说Forking的URL将是我们的主网RPC URL。

11988
19:42:28.930 --> 19:42:32.216
这是我们使用炼金术的另一个原因。

11989
19:42:32.216 --> 19:42:36.803
炼金术公司在这些分叉的区块链方面非常出色，而且有非常好的区块链。

11990
19:42:36.803 --> 19:42:41.298
我们能做的是回到炼金术仪表盘，我们会创建一个新应用。

11991
19:42:41.298 --> 19:42:46.408
这个将用于Aetherium主网，我们将说分叉链。

11992
19:42:46.408 --> 19:42:52.539
我们会说，对于分叉，我们会继续在一个理论和主网上创建这个。

11993
19:42:52.539 --> 19:42:56.353
现在我们有了分叉链，我们可以做同样的事情。

11994
19:42:56.353 --> 19:43:04.644
获取API键，回到项目，创建这个新文件，创建。env。

11995
19:43:04.644 --> 19:43:08.878
我们写上main net RPC URL =，然后粘贴到这里。

11996
19:43:08.878 --> 19:43:16.146
在我们的Hardhead配置中，我们现在将从主网RPC URL分叉每当我们在区块链使用心脏。

11997
19:43:16.146 --> 19:43:21.709
现在我们有了这个，让我们继续运行这个get wet函数。

11998
19:43:21.709 --> 19:43:27.328
因为我们要用叉子叉区块链，我们应该可以继续模拟这个。

11999
19:43:27.328 --> 19:43:40.173
收回一个借式，我们继续我们执行const, get weath = require然后我们拉这个脚本。。scripts / get weath。

12000
19:43:40.173 --> 19:43:45.676
然后，在主函数中，我们运行await yet。

12001
19:43:45.676 --> 19:43:53.116
为了在这里运行我们的脚本，我们将运行yarn hard hat，运行脚本avevamo。

12002
19:43:53.116 --> 19:43:53.375
js。

12003
19:43:53.375 --> 19:43:56.293
我们的默认网络是硬帽。

12004
19:43:56.293 --> 19:43:59.042
所以我们要么做网络硬帽，要么直接运行。

12005
19:43:59.042 --> 19:44:09.088
记住，因为在我们的配置中，我们说，嘿，当我们运行硬帽链时，使用这个分叉，我们将会分叉，所以让我们继续运行这个跑到空气总管。

12006
19:44:09.088 --> 19:44:10.812
Net RPC URL未定义。

12007
19:44:10.812 --> 19:44:12.442
嗯，这很有道理。

12008
19:44:12.442 --> 19:44:20.160
让我们继续并添加这个完善的RPC rel等于过程研究和v点使它RPC URL。

12009
19:44:20.160 --> 19:44:22.155
让我们再试一次。

12010
19:44:22.155 --> 19:44:31.509
我们现在看到，我们有这么多财富，同样，这笔财富将是1-234-567-8910 1234567 0。

12011
19:44:31.509 --> 19:44:35.972
财富，这正是我们想要的。

12012
19:44:35.972 --> 19:44:41.010
现在我们有了一种本地与主网交互的方法，这听起来有点疯狂。

12013
19:44:41.010 --> 19:44:44.431
但我们在这里做的正是他的强大之处。

12014
19:44:44.431 --> 19:44:52.460
所以我们有办法fork main，运行我们的脚本，并进行某种测试，看看和模拟实际运行这些事务是什么样子的。

12015
19:44:52.460 --> 19:44:56.201
我们这样做，我们的get with函数看起来很好。

12016
19:44:56.201 --> 19:45:02.553
显然，我们仍然会将它模块化，我们把它放到助手Hardhead配置中，但我们现在跳过这个。

12017
19:45:02.553 --> 19:45:04.428
让我们回到AVI borrow。

12018
19:45:04.428 --> 19:45:06.960
让我们继续把剩下的部分充实起来。

12019
19:45:06.960 --> 19:45:09.290
现在，让我们继续，在这里设置样板的其余部分。

12020
19:45:09.290 --> 19:45:15.376
我们用const Deployer，因为我们需要一个帐户，显然= await，得到命名帐户。

12021
19:45:15.376 --> 19:45:20.306
然后我们用const get named accounts = require。

12022
19:45:20.306 --> 19:45:30.852
现在我们想开始与ABI协议交互，我们需要什么，我们需要ABI和地址，没有变化，我们需要这两个。

12023
19:45:30.852 --> 19:45:33.090
所以我们能做的就是去Ave医院。

12024
19:45:33.090 --> 19:45:35.443
我们还是在v2上。

12025
19:45:35.443 --> 19:45:39.487
我们可以在这里找到合同地址。

12026
19:45:39.487 --> 19:45:44.981
现在的工作方式是，他们实际上有一个合同，它会指引我们找到正确的合同。

12027
19:45:44.981 --> 19:45:49.025
我们要做所有贷款的合同就是这个贷款池。

12028
19:45:49.025 --> 19:45:53.742
合同地址是通过合同获得的。

12029
19:45:53.742 --> 19:45:59.000
要获得借出池地址，我们必须访问借出池地址提供者。

12030
19:45:59.000 --> 19:46:02.235
这份合同会告诉我们出借人的地址。

12031
19:46:02.235 --> 19:46:06.972
我们可以看到部署契约部分，我们可以看到这个契约的地址。

12032
19:46:06.972 --> 19:46:09.145
我们可以看到所有主要的地址和新冠病毒。

12033
19:46:09.145 --> 19:46:11.613
再说一次，如果你想在COVID上玩这个。

12034
19:46:11.711 --> 19:46:17.644
但我们可以看到贷款池地址提供者将位于这里，我们可以复制这个地址。

12035
19:46:17.644 --> 19:46:21.553
我们来做一下笔记。

12036
19:46:21.711 --> 19:46:25.863
而这个贷款池，我们将从贷款远洋供应商那里获得。

12037
19:46:25.863 --> 19:46:31.961
让我们创建一个函数从贷款池地址提供者获取贷款池地址。

12038
19:46:31.961 --> 19:46:36.301
下面这里，我们会创建async function，获取lending pool。

12039
19:46:36.301 --> 19:46:39.497
现在为了与这个借贷池地址提供程序交互。

12040
19:46:39.497 --> 19:46:43.456
同样的，我们需要它的地址和它的API，我们有它的地址。

12041
19:46:43.456 --> 19:46:49.226
我们来获取它的API，你可以去到与这节课相关的GitHub回购。

12042
19:46:49.226 --> 19:46:51.616
从接口部分复制粘贴。

12043
19:46:51.711 --> 19:46:58.011
你也可以直接在区块链上看这个合同是什么样子的，我可以创建你自己的界面。

12044
19:46:58.011 --> 19:47:00.573
或者我们可以直接使用文档中的接口。

12045
19:47:00.573 --> 19:47:01.952
所以我们有岛屿帕拉赫。

12046
19:47:01.952 --> 19:47:05.254
提供者，我将从ABI文档中复制这个。

12047
19:47:05.254 --> 19:47:08.044
但同样，你有很多选择。

12048
19:47:08.044 --> 19:47:12.677
所以在我们的契约中在我们的界面中，让我们让我们坚持在界面中。

12049
19:47:12.677 --> 19:47:14.304
让我们创建一个新文件。

12050
19:47:14.304 --> 19:47:20.211
我们称它为I借出池地址提供者。soul。

12051
19:47:20.211 --> 19:47:23.773
我们把它粘贴到这里，我们看到我们用的是0。

12052
19:47:23.773 --> 19:47:24.398
6点12。

12053
19:47:24.398 --> 19:47:31.743
所以一定要在Hardhead配置中确保我们没有创建一个新的0。

12054
19:47:31.743 --> 19:47:38.627
6点12，然后我们会编译纱线Hardhead编译，编译太棒了。

12055
19:47:38.711 --> 19:48:15.356
现在我们有了ABI，我们会通过const借出池地址提供者= await ethers。get contract at will来获取契约说I借出池地址哦，地址作为借出池地址不好意思，我要更新名称I Lenny pull addresses provider islding pool addresses provider，我们要传递从Ovid文档中得到的契约地址。

12056
19:48:15.356 --> 19:48:16.542
粘贴进去。

12057
19:48:16.712 --> 19:48:19.212
然后我们会把它连接到部署器。

12058
19:48:19.712 --> 19:48:29.498
我们会有get lending pool，通过这个账户变量然后我们会用这个账户来连接它我们要通过的账户当然是我们的部署者。

12059
19:48:29.498 --> 19:48:31.924
在我们的贷款池地址提供程序。

12060
19:48:31.924 --> 19:49:08.633
有一个函数得到贷款池返回衬里的地址池,这将是我们要调用的函数所以我们会说const贷款池说地址=重量贷款池地址探测地址池任何地址提供者说点得到贷款池就是这样我们会贷款池的地址,然后我们将本合同给我们贷款通过常量池合同贷款池=等待醚添加点得到合同。

12061
19:49:08.633 --> 19:49:14.712
我们需要做同样的事情，接口，接口，地址，然后是帐户。

12062
19:49:14.712 --> 19:49:20.131
回到文档中，我们可以通过这样复制来获取I的出借池。

12063
19:49:20.131 --> 19:49:26.779
我们会回到合约界面，new file, I lending pool，就是这样。

12064
19:49:26.779 --> 19:49:28.271
然后粘贴进去。

12065
19:49:28.271 --> 19:49:43.729
现在有了这个，如果我们滚动到顶部，我们会注意到我们从一些本地的地方导入这些在我们的契约区域中是没有的，我们可以再一次从NPM添加AVI协议v2。

12066
19:49:43.729 --> 19:49:46.629
用这个作为我们的导入。

12067
19:49:46.629 --> 19:49:53.923
所以我们会写yarn，加上破折号dev和一个斜杠原型，叫做连字符v2。

12068
19:49:53.923 --> 19:50:04.434
现在我们在节点模块中有了Add Ave协议，我们可以更新这些导入以指向节点模块而不是本地文件。

12069
19:50:04.434 --> 19:50:15.838
我将继续告诉你们，隔离质押提供者是Ave /协议V /契约/接口。

12070
19:50:15.838 --> 19:50:34.650
然后数据类型。soul是一个协议的缩写v2斜杠契约斜杠，原型调用斜杠库，斜杠类型，数据类型，这些都是为了确保这是正确的，yarn, Hardhead compile或者hh, compile。

12071
19:50:34.650 --> 19:50:35.212
和酷。

12072
19:50:35.212 --> 19:50:48.874
看起来我做对了吗?出借池等于await醚。get contract at，我们将使用出借池，我在这里出借池，我们将使用从地址提供者获得的出借池地址。

12073
19:50:48.874 --> 19:50:52.874
然后是账户，也就是我们的部署者。

12074
19:50:52.874 --> 19:50:56.551
现在我们可以做还贷池。

12075
19:50:56.551 --> 19:51:12.058
如果我们想，现在我们有了这个函数get lending pool backup在main函数中，我们可以说const lending pool = a weight, get lending pool然后传递给Deployer。

12076
19:51:12.058 --> 19:51:22.149
然后我们还可以写console。log，借出池地址然后写借出池。地址。

12077
19:51:22.149 --> 19:51:25.714
既然我们让它分叉，我们就可以一直这样运行下去。

12078
19:51:25.714 --> 19:51:29.414
所以我们会做纱线硬帽运行脚本。

12079
19:51:29.414 --> 19:51:35.651
Ave Baroda Jas，有多个用于合同II贷款池地址提供者的构件。

12080
19:51:35.651 --> 19:51:46.946
这是因为在节点模块中，从契约导入所有这些在这里，在islding中，在那些addons / slash契约中，已经有池地址提供者。

12081
19:51:46.946 --> 19:51:52.664
实际上，我们甚至不需要这个，I lending pool addserviceprovider，我们可以删除它。

12082
19:51:52.664 --> 19:51:54.614
我们现在的时代越来越混乱了。

12083
19:51:54.714 --> 19:52:02.599
它会说，哦，你是指你从NPM下载的那个还是你自己做的那个，你想用哪个。

12084
19:52:02.599 --> 19:52:04.615
所以我们要让硬帽子更容易。

12085
19:52:04.714 --> 19:52:09.285
我们会删除我们创建的那个，我们会使用我们下载的那个。

12086
19:52:09.285 --> 19:52:11.369
现在我们应该可以再运行一次了。

12087
19:52:11.369 --> 19:52:16.649
因为现在只有一个可供选择，也就是我们从NPM下载的那个。

12088
19:52:16.714 --> 19:52:21.836
很好，我们在这里得到了我们的get weath打印结果，然后我们在这里得到了贷款池地址。

12089
19:52:21.836 --> 19:52:26.460
这将是以太以太主网上的实际贷款池地址。

12090
19:52:26.460 --> 19:52:38.386
如果我们回到以太扫描，复制这个地址并粘贴到以太扫描，我们可以看到它甚至被标记为Ave v2，我们可以看到大量的交易一直在进行。

12091
19:52:38.386 --> 19:52:40.294
以太扫描很难跟上所有的事务。

12092
19:52:40.294 --> 19:53:09.115
我们有了借阅池地址，有了web令牌，我们需要做什么?现在我们想要存款，为了存入代币我们需要什么?看一下avec GitHub中的存款函数，滚动到这里，我们会看到它最终我们会调用这个安全转账它基本上是这个转账函数，因为我们调用了转账它将是这个合约，它实际上会从钱包中取出钱。

12093
19:53:09.115 --> 19:53:18.266
所以为了给Ave合同，从我们的钱包里取出钱的能力，我们需要做我们需要做的事情来批准合同。

12094
19:53:18.266 --> 19:53:25.508
首先，在我们存钱之前我们需要批准它来获得我们的网络令牌，我们需要先获得网络令牌。

12095
19:53:25.508 --> 19:53:35.436
我们来获取Web Token地址我们写入const Web Token地址，等于这是我们边缘化它的地方从硬头助手配置中获取它。

12096
19:53:35.436 --> 19:53:43.197
但现在，我们可以硬编码，Web Token契约地址将和get Web中的完全相同，然后想要批准。

12097
19:53:43.197 --> 19:53:47.857
让我们写一个被认可的函数因为我们会用到它几次。

12098
19:53:47.857 --> 19:54:10.005
我们会做一个async函数并批准ERC 20，我们会取一个合约地址一个花费者地址，这将是我们要批准花费代币的合约和花费的金额，我们想要证明它的确切数量。

12099
19:54:10.005 --> 19:54:13.069
然后有一个账户来做这些。

12100
19:54:13.069 --> 19:54:20.924
这里我们写const ERC 20 token = await ethers dot get contract at。

12101
19:54:20.924 --> 19:54:27.286
我们可以说I WEF但也许我们只是想要一个简单的ERC 20代币接口。

12102
19:54:27.286 --> 19:54:31.896
我们将通过欺骗一点硬币来抓住这一点，我们的硬脑袋违抗联邦通信委员会。

12103
19:54:31.896 --> 19:54:35.650
我们去界面，从这里抓取这个界面。

12104
19:54:35.650 --> 19:54:43.993
我们复制这个，粘贴到这里新建文件IO ERC 20。som粘贴现在我们有了ERC的ABI。

12105
19:54:43.993 --> 19:54:50.096
所以我们会签订合同，实际上，让我们把这个名字改成。

12106
19:54:50.096 --> 19:55:01.645
所以我们要和IRC ERC 20的ABI签订合同，在合同地址ERC 20的地址，然后我们将它连接到我们这里的账户。

12107
19:55:01.716 --> 19:55:18.601
一旦我们有了ERC 20，我们可以做const TX，我们会做那个批准事务我们会做一个ERC 20 token。批准花费者地址，然后是amount to spend。

12108
19:55:18.716 --> 19:55:21.841
我们会做一个wait TX。wait一个block。

12109
19:55:22.716 --> 19:55:25.941
一个小的控制台。log表示批准。

12110
19:55:27.716 --> 19:55:33.516
这个函数在你尝试存入之前你会得到一个错误，说，token未被批准，这是一个很常见的错误。

12111
19:55:33.516 --> 19:55:37.490
如果你看到这个，我忘记批准我的代币了。

12112
19:55:37.490 --> 19:55:41.409
在主脚本中备份，我们继续运行这个函数。

12113
19:55:41.409 --> 19:55:54.182
我们会说await approve ERC 20带有Web令牌地址借出池。address因为我们想给len池批准从账户中提取我们的Web令牌。

12114
19:55:54.182 --> 19:56:00.028
然后我们会给它一些实际上也会从get weath导入一个坐骑。

12115
19:56:00.028 --> 19:56:04.890
Mount我们需要返回导出它，这样我们才能导入它。

12116
19:56:04.890 --> 19:56:07.974
导出这个0。

12117
19:56:07.974 --> 19:56:08.135
02.

12118
19:56:08.135 --> 19:56:14.372
我们会证明这个量然后我们会连接显然我们会让部署器来做因为所有事情都是用部署器来做的。

12119
19:56:14.372 --> 19:56:15.897
所以我们会批准ERC 20。

12120
19:56:15.897 --> 19:56:19.717
一旦我们批准了，我们就可以把钱存进去了。

12121
19:56:19.717 --> 19:56:23.104
我们写入console。log，存放那个。

12122
19:56:23.104 --> 19:56:27.942
然后我们运行await lending pool。deposit。

12123
19:56:27.942 --> 19:56:35.450
如果我们看存款函数，我们可以看到存款函数的所有参数。

12124
19:56:35.450 --> 19:56:40.117
我们也可以在Ave v2文档中看到它，我们只是期待这个位置。

12125
19:56:40.117 --> 19:56:55.190
我们可以看到它取的是我们要存入的资产的地址我们要代存的资产的多少我们要代存一个地址然后是一个引用代码，它现在总是0因为引用代码已经停止了。

12126
19:56:55.190 --> 19:57:02.479
我们要存入wet令牌地址，我们要存入web令牌，我们设为0。

12127
19:57:02.479 --> 19:57:04.512
那个web令牌的02。

12128
19:57:04.717 --> 19:57:08.517
然后我们会使用部署器灰然后引用代码将是零。

12129
19:57:08.517 --> 19:57:11.304
然后我们写一个console。log。

12130
19:57:11.304 --> 19:57:13.288
让我们试试这个脚本。

12131
19:57:13.288 --> 19:57:15.061
让我们看看它是否有效。

12132
19:57:15.061 --> 19:57:23.029
我要重新运行这个脚本重新运行我在编译ERC 20时遇到的这个命令。

12133
19:57:23.029 --> 19:57:29.436
那首歌被编译成一个完整的文件，得到了一堆包装好的以太坊贷款池地址。

12134
19:57:29.436 --> 19:57:33.828
我们批准了，我们存了我们存了，然后存了。

12135
19:57:33.828 --> 19:57:42.560
如果我们看这个自述文件，我们会得到一个小的选中标记。

12136
19:57:42.717 --> 19:57:46.640
我们完成了第一步，我们存放了抵押品。

12137
19:57:46.717 --> 19:57:47.092
太棒了。

12138
19:57:49.717 --> 19:57:50.544
其他资产。

12139
19:57:50.544 --> 19:57:50.957
太好了。

12140
19:57:53.718 --> 19:57:58.931
现在通过几行新台词学习如何借用，我们会说借来的时间。

12141
19:57:58.931 --> 19:58:04.651
为了让我们借钱，我们可能想知道我们能借多少。

12142
19:58:04.651 --> 19:58:15.646
我们想了解更多关于我们账户的情况，对吗?我们想知道我们借了多少，抵押品有多少，我们能借多少。

12143
19:58:15.646 --> 19:58:33.780
Avi附带了一个函数，叫做获取用户账户数据，它将返回所有准备金的用户账户数据，我们有多少抵押品，它的总价值，我们有可用的借款和当前清算阈值，贷款与价值之比等。

12144
19:58:33.780 --> 19:58:36.217
这些都是非常重要的指标。

12145
19:58:36.217 --> 19:58:40.843
如果我们有一项资产和抵押品那并不意味着我们可以借到一项资产。

12146
19:58:40.843 --> 19:58:45.801
每一个代币都有一些不同的值，比如贷款价值比。

12147
19:58:45.801 --> 19:59:00.984
例如，如果你有一个，你只能借0.75染料代币，这是为了降低抵押品的风险，降低人们没有足够抵押品的风险，因为价格波动。

12148
19:59:00.984 --> 19:59:11.472
有一个80%的清算门槛如果你有一个作为抵押品和81点的借款，你会得到所谓的清算。

12149
19:59:11.472 --> 19:59:25.363
那么什么是清算呢?当你抵押贷款的时候，如果你借的钱超过了清算阈值超过了80%或者，根据不同的资产，不同的人可以对你进行清算。

12150
19:59:25.363 --> 19:59:29.586
这是他们偿还你贷款的时候。

12151
19:59:29.586 --> 19:59:33.891
他们还可以以更低的价格购买你的一些抵押品。

12152
19:59:33.891 --> 19:59:45.929
这就保证了Ave平台的偿付能力，这使得借款永远不会超过抵押品为了借入资产，我们仍然需要抵押品。

12153
19:59:45.929 --> 19:59:53.396
所以基本上，如果你借的钱比你还的多，其他用户就可以拿走你还的钱作为回报，让他们偿还你的贷款。

12154
19:59:53.396 --> 19:59:55.428
所以我们显然不希望这种情况发生。

12155
19:59:55.428 --> 20:00:00.346
审计协议在程序上不想没有足够的钱来做这件事。

12156
20:00:00.346 --> 20:00:15.922
所以他们鼓励用户进行清算，以防这些失败协议中有一个叫做健康因子的东西，如果健康因子低于1，你就会被清算，清算某人的实际功能叫做清算调用。

12157
20:00:15.922 --> 20:00:23.719
所以你可以建立一个机器人，你可以清算那些破产的用户，你可以赚一笔钱，你可以通过这样做获得奖励。

12158
20:00:23.719 --> 20:00:28.451
这些协议需要保持偿付能力，他们需要有足够的钱来放贷。

12159
20:00:28.451 --> 20:00:30.957
他们通过程序执行了这一点，这就是它如此伟大的原因。

12160
20:00:30.957 --> 20:00:34.600
您可以在清算文件中了解更多关于清算的信息。

12161
20:00:34.600 --> 20:00:43.915
这个账户数据会告诉我们有多少抵押品，我们有多少债务，根据抵押品的多少我们可以借到多少钱。

12162
20:00:43.915 --> 20:00:51.589
我们可以看到当前的清算阈值我们可以看到贷款价值比然后我们可以看到健康因子，这显然非常重要。

12163
20:00:51.589 --> 20:00:55.052
如果我们的健康系数低于1，我们就会被清算。

12164
20:00:55.052 --> 20:00:59.173
所以我们不希望这个地狱因子在我们借入资产时低于1。

12165
20:00:59.173 --> 20:01:01.096
我们先来创建一个函数。

12166
20:01:01.096 --> 20:01:04.959
让我们创建一个新函数async。

12167
20:01:04.959 --> 20:01:16.862
函数让它借用户数据，我们会传入借贷池契约，我们会传入借贷池契约和我们想要获取数据的帐户。

12168
20:01:16.862 --> 20:01:17.814
所以我们可以说const。

12169
20:01:17.814 --> 20:01:25.386
实际上，我们可以提取出我们想要的值，我们可以提取出总抵押品总债务和可借款。

12170
20:01:25.386 --> 20:01:37.684
让我们拿出总抵押品包含总债务和可用借款。

12171
20:01:37.684 --> 20:01:48.478
这个等于await，借贷池。get账户的用户账户数据。

12172
20:01:48.478 --> 20:02:06.360
现在我们要注销我们写console。log你有总抵押物价值正的console。

12173
20:02:06.360 --> 20:02:29.220
日志你有总债务eath借来的价值，然后控制台点日志你可以借来可用的eath借来的价值。

12174
20:02:29.220 --> 20:02:36.369
然后我们会返回available to borrow将available borrow变为eath。

12175
20:02:36.369 --> 20:02:43.136
我们将返回总债务，我们不需要返回总抵押品如果我们想的话，我们只需要把它打印出来。

12176
20:02:43.136 --> 20:02:57.302
现在回到我们的函数中，我们可以在main函数中做，我们可以运行let，我要这样做因为我们会调用它几次available borrows eath。

12177
20:02:57.302 --> 20:03:06.157
而总负债等于等待，得到借款池和部署器的借款用户数据。

12178
20:03:06.157 --> 20:03:15.302
如果我们运行这个，我们会看到我们实际上可以借多少纱线硬帽或只是h h运行脚本在一个借来的。

12179
20:03:15.302 --> 20:03:18.283
Js和工作在我们的分叉区块链这里。

12180
20:03:18.283 --> 20:03:20.287
记住，它会慢一点。

12181
20:03:20.287 --> 20:03:26.475
这也是缺点之一因为当我们想要与这些链交互时它必须进行API调用。

12182
20:03:26.475 --> 20:03:29.121
然后我们得到了总抵押物没有定义。

12183
20:03:29.121 --> 20:03:31.830
那是因为我拼错了。

12184
20:03:31.830 --> 20:03:34.251
让我们正确拼写total。

12185
20:03:34.251 --> 20:03:35.990
我们再运行一遍。

12186
20:03:35.990 --> 20:03:37.005
好吧，很好。

12187
20:03:37.005 --> 20:03:45.931
你存了这个月的钱，你借了零钱因为我们什么都没借，你可以借这么多钱。

12188
20:03:45.931 --> 20:03:51.990
记住，我们可以借的金额总是小于我们存入的总金额。

12189
20:03:51.990 --> 20:03:54.593
这就是为什么我们看到这个较低的数字。

12190
20:03:54.721 --> 20:03:55.054
太酷了。

12191
20:03:55.054 --> 20:03:56.625
这就是我们可以借的数额。

12192
20:03:57.721 --> 20:03:58.971
借点时间。

12193
20:04:01.721 --> 20:04:03.884
八分之一，我们就能借点时间了。

12194
20:04:04.721 --> 20:04:11.180
我们可以借点时间，但我们需要弄清楚饮食的转化率是多少?我们要知道每个人能借多少钱。

12195
20:04:11.180 --> 20:04:12.884
但是我们想借染料。

12196
20:04:12.884 --> 20:04:19.151
那么，根据地球的价值，我们能借多少染料呢?要做到这一点，我们得拿到染料的价格。

12197
20:04:19.151 --> 20:04:22.984
我们要怎么做呢?好吧，你猜对了，我们将使用链式价格反馈。

12198
20:04:22.984 --> 20:04:30.382
如果你查看AVI文档，你可以找到price Oracle，这是一个你可以直接从AVI使用的合同。

12199
20:04:30.382 --> 20:04:34.689
但它做的第一件事是从链链接聚合器检查，这我们已经知道怎么做了。

12200
20:04:34.722 --> 20:04:38.436
我们会直接从链链接聚合器调用。

12201
20:04:38.436 --> 20:04:46.099
我们来创建一个新函数函数，我们叫它get dye price首先我们需要得到接口，一样的。

12202
20:04:46.099 --> 20:04:56.394
你可以直接去Hardhead defy从这里抓取接口，我们也可以用从chainlink NPM导入来交换这个。

12203
20:04:56.394 --> 20:05:03.183
我要复制粘贴一个新文件，这将是agreg gate, Tor v3接口。

12204
20:05:03.183 --> 20:05:05.993
多特看到我们合作过那么多次。

12205
20:05:05.993 --> 20:05:14.239
现在我们有了这个接口，它会编译，我们显然在寻找最新一轮数据，它会给我们这个答案，也就是价格。

12206
20:05:14.239 --> 20:05:15.342
我们来抓取这个。

12207
20:05:15.342 --> 20:05:30.675
所以我们会说const di eath price feed = await ethers dot get contract at我们会使用air, Greg Tor v3接口将从链链接文档中获取dye eath price feed。

12208
20:05:30.722 --> 20:05:38.106
我们去docs。chain。link UVM链会去Aetherium的合同地址。

12209
20:05:38.106 --> 20:05:40.567
或者在主网上寻找di。

12210
20:05:40.722 --> 20:05:42.436
我们看到di在这里。

12211
20:05:43.722 --> 20:05:47.152
我们只是在与之关联的GitHub回购中硬编码它。

12212
20:05:47.152 --> 20:05:52.175
有了这个，我们把它放在一个小配置文件中，但我们可以直接硬编码进去。

12213
20:05:52.175 --> 20:05:55.609
对于这个，我们不需要将它连接到部署者帐户。

12214
20:05:55.609 --> 20:06:01.037
因为我们不会发送任何交易，我们只会从合约中读取数据。

12215
20:06:01.037 --> 20:06:04.597
所以阅读不需要一个签名者把我发送给签名者。

12216
20:06:04.597 --> 20:06:13.587
现在我们可以说const price等于weight dye eath price feed。最新一轮数据。

12217
20:06:13.587 --> 20:06:19.384
我们知道，最新一轮数据会返回这么大的值。

12218
20:06:19.384 --> 20:06:22.477
我们只要求第一个指标的值。

12219
20:06:22.477 --> 20:06:25.550
另一种方法是，我们可以把这整个包起来。

12220
20:06:25.550 --> 20:06:30.691
一旦这个返回，我们会说，抓取第一个指标，也就是那个价格。

12221
20:06:30.691 --> 20:06:36.846
然后我们可以写一个console。log，也就是dy。

12222
20:06:36.846 --> 20:06:42.437
价格在Price。2中，像这样，然后返回价格。

12223
20:06:42.437 --> 20:06:47.119
我们可以运行这个测试一下，点击上，然后回车。

12224
20:06:47.119 --> 20:06:51.563
我们存了这是我们能存的。

12225
20:06:51.723 --> 20:06:54.675
没什么哦，我忘了叫它哦，不好意思，我们上去吧。

12226
20:06:54.723 --> 20:07:01.167
这个，我们说const染料价格等于await get染料价格。

12227
20:07:01.723 --> 20:07:01.985
这样。

12228
20:07:05.723 --> 20:07:12.182
我们知道是3289美元当然是3289 di /每人。

12229
20:07:12.182 --> 20:07:18.011
现在我们有了染料的价格，我们可以计算出我们要借多少染料。

12230
20:07:18.011 --> 20:07:19.434
太好了，我们有价格了。

12231
20:07:19.434 --> 20:07:27.417
现在我们算一下染料可以借多少，我们有了泥土可以借多少，我们需要把它转换成死亡。

12232
20:07:27.417 --> 20:07:36.373
所以我们说const amount die to borrow = available，即eath中可用的借位数。

12233
20:07:36.373 --> 20:07:37.223
字符串。

12234
20:07:37.223 --> 20:07:40.473
在JavaScript中，我们可以这样做。

12235
20:07:40.473 --> 20:07:43.115
要串，但还是要做数学。

12236
20:07:43.115 --> 20:07:44.293
所以乘以0。

12237
20:07:44.293 --> 20:07:49.852
95乘以，然后求这个骰子的倒数。

12238
20:07:49.852 --> 20:07:52.562
1除以模具价格。

12239
20:07:52.562 --> 20:07:53.433
数量。

12240
20:07:53.724 --> 20:07:58.320
这就是我们可以借的骰子的数量。

12241
20:07:58.724 --> 20:08:00.452
那我们就把这事搞定。

12242
20:08:01.724 --> 20:08:08.561
现在，console。log，你可以借用。

12243
20:08:08.724 --> 20:08:13.543
现在运行这个，你可以借到钱死借到。

12244
20:08:14.724 --> 20:08:20.771
单位，我们需要单位，但你可以借48模，从价格上看差不多。

12245
20:08:20.771 --> 20:08:26.962
为了得到正确的单位，我们用const amount, di来借位。

12246
20:08:26.962 --> 20:08:34.137
这将等于ethers。utils。parse ether, MT di借位。

12247
20:08:34.137 --> 20:08:34.757
字符串。

12248
20:08:34.757 --> 20:08:39.807
这只是借来的染料的数量，对吧，我们得到48。

12249
20:08:39.807 --> 20:08:40.307
79年死亡。

12250
20:08:40.307 --> 20:08:47.411
但同样，我们希望die token有18位小数点后的位置，类似于Aetherium。

12251
20:08:47.411 --> 20:08:51.805
所以我们需要这笔钱然后我们就可以开始借钱了。

12252
20:08:51.805 --> 20:08:59.527
我们会创建一个新函数，叫borrow die async function, borrow die会取die地址。

12253
20:08:59.527 --> 20:09:09.124
拿着贷款池，拿着要借的钱，算一算当然，我们要算账户。

12254
20:09:09.124 --> 20:09:11.649
我们要做的就是用const。

12255
20:09:11.649 --> 20:09:21.232
Borrow TX是一个权重，借出池。Borrow, die address, die to Borrow的数量。

12256
20:09:21.232 --> 20:09:39.364
同样，我们可以直接去文档，如果我们想，它取资产的地址，金额，我们想借用利率模式，它是可变的或稳定的，引用代码然后地址代表，我们说利率模式是1，其中1是稳定的。

12257
20:09:39.364 --> 20:09:57.249
然后我们会做0或者这个引用代码因为它已经被揭穿了，然后我们会做一个计数，然后我们会做一个等待，借入TX。wait，等待一个事务，然后我们会做console。log你已经借入。

12258
20:09:57.249 --> 20:09:58.560
好了，就这些了。

12259
20:09:58.560 --> 20:10:01.249
现在我们有了这个借用的I函数。

12260
20:10:01.249 --> 20:10:06.788
回到我们的主函数，好了，现在，我们终于可以做借阅时间了。

12261
20:10:06.788 --> 20:10:09.248
我们用wait，借die。

12262
20:10:09.248 --> 20:10:11.567
我们将把这些参数传入这里。

12263
20:10:11.567 --> 20:10:18.610
我们会写const, die令牌地址，等于我们会从主网硬编码这个。

12264
20:10:18.610 --> 20:10:33.325
我们可以查到die token地址，main net，我们会在这里抓取这个地址，这看起来确实是DI token，我们可以在get up对象上检查，我们可以在实际代码的ABI上检查，因为我们只是在测试，我们会在这里从ether scan抓取。

12265
20:10:33.325 --> 20:10:45.832
对于借染料，我们需要染料令牌地址，我们需要借出池合约借染料的数量，然后是部署者。

12266
20:10:45.832 --> 20:10:48.499
然后我们将等待借来的染料。

12267
20:10:48.499 --> 20:10:56.486
然后我们会再次运行这个getbar用户数据，打印出我们所处位置的信息。

12268
20:10:56.486 --> 20:11:12.146
当我们运行这个的时候，我们应该看到我们已经借了多少，更新，我们对那个函数的第一个调用会说，嘿，你有这么多吃正数你什么都没借吗，你可以借这么多，我们得到价格，我们得到我们借了多少，我们借了多少。

12269
20:11:12.146 --> 20:11:20.226
现在它说你存了这么多钱你借了这么多钱你可以借这么多钱。

12270
20:11:20.226 --> 20:11:25.106
所以我们现在买了一堆借来的染料。

12271
20:11:25.106 --> 20:11:31.365
我们之所以要乘以0.95，是因为我们不想达到我们能借到的最大金额的上限。

12272
20:11:31.365 --> 20:11:35.070
所以我们说，嘿，让我们得到我们实际可以借到的金额的95%

12273
20:11:35.070 --> 20:11:38.887
所以我们不打算全部借，我们只借95%

12274
20:11:38.887 --> 20:11:42.226
你可以看到，我们已经存入的土地的数量实际上更高。

12275
20:11:42.226 --> 20:11:48.659
这是因为我们实际上从存款中获得了利息。

12276
20:11:48.659 --> 20:11:55.036
现在我们借了一些染料，我们借了48个染料，这相当于这么多的乙醚。

12277
20:11:55.036 --> 20:12:03.591
然后我们还有一点可以借因为我们只借了95%这很好。

12278
20:12:03.726 --> 20:12:09.154
太棒了，我们已经有程序地借出了，让我们至少在这里偿还一部分。

12279
20:12:09.154 --> 20:12:16.277
我们需要创建一个新函数它将使用契约中的偿还函数。

12280
20:12:16.277 --> 20:12:52.440
所以我们要做异步函数偿还,这是需要我们想要偿还的数额的染料地址我们会偿还贷款池帐户现在偿还再次,我们将不得不批准发送染料回到大街在这里,我们需要做的第一件事就是我们实际上需要调用等证明ERC 20与染料地址,贷款池点地址,然后山账户,因为通过伦理委员会20。

12281
20:12:52.440 --> 20:12:57.489
这是它需要的输入参数，我们需要批准将染料发回合同。

12282
20:12:57.489 --> 20:12:59.927
所以我们借了它，我们要把它还回去。

12283
20:12:59.927 --> 20:13:01.977
现在我们要把它送回去。

12284
20:13:01.977 --> 20:13:11.527
我们写const，偿还TX等于await，借出，酷偿还地址，金额，一个账户。

12285
20:13:11.527 --> 20:13:29.227
然后我们写入await传回TX。Wait，这将在主函数中执行console。log传回，我们将执行一个权重值传回，然后我们将给它以某种方式借出的染料的数量。

12286
20:13:29.227 --> 20:13:40.615
我们会给它染料令牌地址，给它借贷池，然后我们会给它部署者让你再借一次用户数据这样我们就能打印出最终的金额。

12287
20:13:40.615 --> 20:13:46.133
现在，你会注意到一些事情，我们会把所有借来的染料都还给你。

12288
20:13:46.133 --> 20:14:00.803
然而，我们仍然会有一个染料平衡，当我运行这个时，你会看到我们仍然会有一些借来的Aetherium，基本上，我们仍然会有一个染料平衡，因为我们仍然会有一些借来的die，试着在我回答之前找出原因。

12289
20:14:00.803 --> 20:14:16.289
所以我们在这里借了这么少，这么少的钱而我们存了更多的钱为什么我们还借了这么少，这么少的钱呢?原因是，当我们借染料时，我们实际上产生了利息。

12290
20:14:16.289 --> 20:14:17.907
所以我们还欠染料。

12291
20:14:17.907 --> 20:14:26.574
现在我们可以做的是做一些像uniswap这样的事情，用我们的Aetherium交换染料来偿还剩下的债务。

12292
20:14:26.574 --> 20:14:33.812
这就是我们偿还所有债务的方法得到更多的染料来偿还我们积累的利息。

12293
20:14:33.812 --> 20:14:43.211
如果你愿意，你可以回去做和这里完全一样的事情获取uniswap代码，把它放在这里，以编程方式偿还你的债务。

12294
20:14:43.211 --> 20:14:47.464
但在这一点上，你刚刚经历了整个生命周期。

12295
20:14:47.464 --> 20:14:51.105
这绝对是巨大的，巨大的祝贺。

12296
20:14:51.105 --> 20:14:58.278
您刚刚从AVI协议中存放了借入并偿还的令牌。

12297
20:14:58.278 --> 20:15:24.728
现在我将简要地向你们展示这些交易在实际的测试网络上是什么样子的，在以太扫描上，你们会看到，当我们存入抵押品时，我们实际上得到了所谓的A代币，或带息代币，这些代币记录了抵押品的数量，或者在我们的例子中，记录了我们在AVI协议中存入了多少web代币。

12298
20:15:24.728 --> 20:15:52.331
当我们想要收回我们的财富,我们燃烧这八令牌,我们删除这些八令牌,你可以看到我们的第一个事务是存款,我想告诉你它是什么样子当你存款的令牌,这个事务相关的贷款池,这里的存款,如果你看看令牌传输下面,你可以看到我们实际沉积,可以看到,我们全神贯注的醚发送到ARB合同。

12299
20:15:52.331 --> 20:15:55.417
现在你也会看到这个东西。

12300
20:15:55.417 --> 20:15:57.442
那么这个a和东西是什么。

12301
20:15:57.442 --> 20:16:07.355
因此，为了记录你在Ave实际存了多少钱，Ave会给你自己的财富代币或代币来记录。

12302
20:16:07.355 --> 20:16:15.665
这是这个带利息的令牌，你可以看到上面这里已经有一点兴趣了把这些令牌存入协议。

12303
20:16:15.729 --> 20:16:21.292
而这个代币，会持续上涨，因为借出的人越多，使用这个协议的人就越多。

12304
20:16:21.292 --> 20:16:28.519
你可以获取这个token address, interest bearing token这是一个token，我可以将它导入元掩码。

12305
20:16:28.519 --> 20:16:30.479
我可以看到我有0。

12306
20:16:30.479 --> 20:16:44.014
1，这代表我的初始存款00517乘以那个点A如果你保持这个时间足够长，这个数字会随着你越来越多慢慢增加。

12307
20:16:44.014 --> 20:16:51.676
因为利率在外面，你可以看到它在这里上升，利率会一直变化，一直上升。

12308
20:16:51.729 --> 20:16:57.879
显然，我们的存款很少，利率不会很快上升，但使用协议的人越多，利率就会上升。

12309
20:16:57.879 --> 20:17:06.354
由于我使用的是一个测试网，协议的实际使用量不是很高，但你可以想象一下。

12310
20:17:06.729 --> 20:17:09.118
太棒了，你能走到这一步真是太了不起了。

12311
20:17:09.729 --> 20:17:11.929
快速回顾一下我们学到的东西。

12312
20:17:12.729 --> 20:17:14.443
进入下一节。

12313
20:17:16.729 --> 20:17:24.118
令牌或包装的Aetherium令牌，它是令牌化我们的Aetherium或第一层区块链原生令牌的一种方式。

12314
20:17:24.118 --> 20:17:30.118
然后我们学习了一点AVI协议，以及它是如何作为借用和借出资产的违抗原语的。

12315
20:17:30.118 --> 20:17:58.516
我们可以获得利益通过沉淀我们的令牌和资产Ave uniswap我们也学会了一点,这是另一个非常重要的违背协议,它允许我们互相交换标记之间的分散的情况下,我们知道我们可以存一些令牌到AVI协议,这是一个分散的借款和贷款平台,类似于银行会获得利息我们把令牌。

12316
20:17:58.516 --> 20:18:00.237
但首先，我们得批准他们。

12317
20:18:00.237 --> 20:18:06.491
因为在任何时候，您希望契约与令牌交互，您都需要批准契约来实现此目的。

12318
20:18:06.491 --> 20:18:11.628
然后我们继续存入一旦存入我们就得到染料的价格。

12319
20:18:11.628 --> 20:18:19.230
然后我们知道我们实际上可以借到。我们可以借到一种资产基于我们提供的抵押品的多少。

12320
20:18:19.230 --> 20:18:21.306
然后我们学会了如何回报。

12321
20:18:21.306 --> 20:18:26.158
我们学习了叉子区块链，而不是使用我们自己的主区块链。

12322
20:18:26.158 --> 20:18:37.285
另一件要知道的事情是，如果你正在使用一个RPC URL，比如炼金术，你已经学习了很多关于违抗的东西，现在defi绝对是一个巨大的动力，当它涉及区块链。

12323
20:18:37.285 --> 20:18:40.630
这是区块链可以做的最重要的事情之一。

12324
20:18:40.630 --> 20:18:43.776
如果你想了解更多关于defy的信息，请阅读更多defy的内容。

12325
20:18:43.776 --> 20:18:54.110
我在GitHub里有更多的链接这样你们就可以了解更多关于defy的知识其中一个我特别想给你们看的是speed run Etherium。

12326
20:18:54.110 --> 20:18:59.246
它不仅提供了大量的反例，还提供了一大堆其他的例子。

12327
20:18:59.246 --> 20:19:02.968
这将是对你们通过这门课后所学内容的一次很好的测试。

12328
20:19:02.968 --> 20:19:16.301
甚至现在，如果你想或者什么时候你想多讲一点，实际上我们请到了Austin Griffiths来多讲一点关于Aetherium的极速运行，我将把它交给Austin。

12329
20:19:16.730 --> 20:19:19.649
你好，我是奥斯丁·格里菲斯，我想让你看看极速跑Aetherium。

12330
20:19:19.649 --> 20:19:23.020
极速跑Aetherium是开始Aetherium的好方法。

12331
20:19:23.020 --> 20:19:29.110
如果你是一个开发人员，它的目标是web二开发人员成为web三开发人员的速度运行理论。

12332
20:19:29.110 --> 20:19:29.236
m。

12333
20:19:29.236 --> 20:19:30.378
Com是网站。

12334
20:19:30.378 --> 20:19:36.649
它会带你开始学习，并对语言和语法有个大概的了解。

12335
20:19:36.649 --> 20:19:38.353
但这仅仅是个开始。

12336
20:19:38.353 --> 20:19:42.993
理解语言只是一个开始，你会觉得自己无所不能。

12337
20:19:42.993 --> 20:19:47.911
当你终于把实体的语法整合在一起时，你就站在了世界的顶端，你可以通过一个智能合约。

12338
20:19:47.911 --> 20:19:53.665
但真正了解空间的背景，弄清楚什么可行，什么不可行，那是另一场战斗。

12339
20:19:53.665 --> 20:19:55.484
这就是高速运行的aetherium。

12340
20:19:55.484 --> 20:19:56.492
Com进来了。

12341
20:19:56.492 --> 20:19:59.634
让我们快速跑，快速跑。

12342
20:19:59.634 --> 20:20:12.295
首先，你会得到支架快速运行Aetherium是围绕支架基座旋转的，并使用支架基座作为基础，你会想要在固体中修补一些想法。

12343
20:20:12.295 --> 20:20:14.668
我来解释一下我的意思。

12344
20:20:14.668 --> 20:20:19.569
因此，有了scaffold eath，就有了前端和智能合约。

12345
20:20:19.569 --> 20:20:23.159
所以脚手架上有一顶硬帽子。

12346
20:20:23.159 --> 20:20:32.397
您将结合使用硬帽和反应来构建一个DAP，在其中您将部署智能合约和前端。

12347
20:20:32.397 --> 20:20:41.934
这种编辑你的智能合约并让你的前端自动适应它的能力是简化脚手架的关键。

12348
20:20:41.934 --> 20:20:44.425
我加了几个额外的感叹号。

12349
20:20:44.425 --> 20:20:45.961
我们会在这里看到。

12350
20:20:45.961 --> 20:20:48.924
一旦合同生效，就这样了。

12351
20:20:48.924 --> 20:21:07.981
很快的，如果我创建一个un256的公共计数器，我们把它设为5，然后我建立一个叫做increment的函数，这是public，它对抗public，好了，它对抗plus, plus，你可以想象这里会发生什么。

12352
20:21:07.981 --> 20:21:14.338
所以你，你编辑一点稳定性，你部署你的合同，然后你的前端自动调整。

12353
20:21:14.338 --> 20:21:32.300
作为开发者，它让你能够调用这些函数对智能合约进行修改，你甚至可以有一个控制台登录在那里，集合说计数现在在那里，我们这样做。

12354
20:21:32.300 --> 20:21:34.232
让我们继续部署它。

12355
20:21:34.232 --> 20:21:40.841
注意我在做这些快速的迭代，我在固体上做了小的改变，我看到这些改变在前端显现出来。

12356
20:21:40.841 --> 20:21:45.107
我在前端对它们进行修补并测试我的假设。

12357
20:21:45.107 --> 20:21:58.028
这里，如果我们看一下硬帽节点，当我调用这个增量调用时，我们应该会看到控制台日志，这个地址，将计数设为8 ?非常非常酷。

12358
20:21:58.028 --> 20:21:59.506
这就是脚手架。

12359
20:21:59.506 --> 20:22:15.312
这就是speed run Aetherium的基础，你进入这里，编辑你的智能合约，然后编辑你的前端，将你的前端指向某个特定的网络，部署你的智能合约，部署你的应用程序，它让你能够拥有一个与智能合约同时存在的前端。

12360
20:22:15.312 --> 20:22:18.909
当你构建你的智能合约时，你会拥有这些。

12361
20:22:18.909 --> 20:22:40.460
有了这个前端，对智能合约进行修改能帮你弄清楚如何写实度，比如这是一个映射吗?这是一个数组吗?如何跟踪这个结构呢，你可以在迭代过程中完成只需把它扔到智能合约中在前端对其进行修改并进行尝试，看看需要构建什么。

12362
20:22:40.460 --> 20:22:41.655
这就是脚手架。

12363
20:22:41.655 --> 20:22:45.669
这是开始快速运行以太坊所需的基础。

12364
20:22:45.669 --> 20:22:55.194
一旦你能把这些都安装好，你就会有你的反应前端纱线开始，你会有纱线链，它会运行你的硬帽节点，然后你会做纱线展开。

12365
20:22:55.194 --> 20:23:00.683
一旦你在本地有了这个设置，你就可以快速运行Aetherium了。

12366
20:23:00.683 --> 20:23:03.751
你也可以在这里这么做，挑战零。

12367
20:23:03.751 --> 20:23:15.634
挑战零，必须有0索引，对吧，我们得很书呆子挑战零让你建立环境设置，你会你会探索建立一个简单的非功能性例子。

12368
20:23:15.634 --> 20:23:18.410
它将附带一个非ft智能合约。

12369
20:23:18.410 --> 20:23:25.800
它会有一个非功能性前端有点像minting视图，它会有所有这些东西来做那个。

12370
20:23:25.800 --> 20:23:39.478
它会带你完成基本的挑战这一行将会握住你的手，它会带你完成每一步你必须得到你必须有一个特定版本的节点E, L一些正确范围的节点和纱线安装。

12371
20:23:39.478 --> 20:23:45.184
注意yarn在Linux上有可执行文件，确保你有yarn，包管理器。

12372
20:23:45.184 --> 20:23:51.750
但是，在获得节点和纱线之后，您将对每个挑战进行克隆。

12373
20:23:51.750 --> 20:23:55.699
你会安装，你会点燃链条，你会点燃你的前端。

12374
20:23:55.733 --> 20:24:00.170
您将拥有一个工作的应用程序，它允许您与非ft智能合约进行交互。

12375
20:24:00.170 --> 20:24:03.571
你会从这里学到关于钱包的知识。

12376
20:24:03.571 --> 20:24:07.833
然后你将开始铸造NF T，你将发送那些NF T是圆形的。

12377
20:24:07.833 --> 20:24:11.240
这是第0个挑战，这只是你的开始。

12378
20:24:11.240 --> 20:24:15.999
在这里，即使在零挑战中，你也要把这个非杀伤性武器部署到林克比。

12379
20:24:15.999 --> 20:24:22.470
你还可以部署一个应用程序，允许你的朋友使用你的应用程序，并在Rinkeby的FTS中mint。

12380
20:24:22.470 --> 20:24:28.682
这是第一个挑战，看起来我们甚至想要投入到开放的环境中并尝试一些机制。

12381
20:24:28.733 --> 20:24:36.333
第二个挑战挑战第一个挑战快跑者理论的挑战之一是一切真正开始的地方。

12382
20:24:36.333 --> 20:24:39.527
这确实显示了Aetherium的超能力。

12383
20:24:39.527 --> 20:24:40.415
它设置好了。

12384
20:24:40.415 --> 20:24:50.208
因此，你需要构建一个应用程序，让一群互不信任的人可以协调并入股智能合约。

12385
20:24:50.208 --> 20:24:52.334
这就像，这是Aetherium的超能力。

12386
20:24:52.334 --> 20:25:09.499
作为开发者，你有能力编写一些简单的规则，让那些混蛋们在财务上协调一致，而不是互相问候和偷对方的钱，对吧?我们正在建立这些金融系统，这里有博弈论和经济学还有很多其他的东西。

12387
20:25:09.499 --> 20:25:15.511
但是你作为开发者，你在编写简单的规则，你在构建一个允许人们协调的系统。

12388
20:25:15.511 --> 20:25:25.495
挑战一，我们会教你如何设置你的牛排或者驯服，智能合约，你会以完全相同的方式安装所有东西，你会启动所有东西。

12389
20:25:25.495 --> 20:25:29.019
然后它会带你了解智能合约中需要的东西。

12390
20:25:29.019 --> 20:25:31.448
但是你必须自己写固体。

12391
20:25:31.448 --> 20:25:39.980
这不是一个手持教程，你需要自己编写智能合约。

12392
20:25:39.980 --> 20:25:44.910
有一些指导方针和轨道可以帮到你，但它不会帮到你。

12393
20:25:44.910 --> 20:25:48.334
好了，这就是任务一，这就是挑战。

12394
20:25:48.334 --> 20:25:51.267
一个是开发去中心化的赌注应用程序。

12395
20:25:51.267 --> 20:26:02.147
挑战二是建立代币供应商在挑战一中，你会学到如何向合同中汇款，如何拥有合同，跟踪映射。

12396
20:26:02.147 --> 20:26:29.670
在挑战两个,你要学习合同,合同互动,你会了解ERC 20多岁,你要学习专门批准的模式,这是一个混蛋,,是很困难的,这是一个困难的事情处理是批准的模式,你需要去你的令牌合同和批准供应商采取一些钱,然后在第二个交易,你需要去供应商和供应商的钱从令牌合同,做其他的事情。

12397
20:26:29.670 --> 20:26:42.319
第二个挑战是学习代币和供应商，并开始让你接触到大型多人游戏Aetherium的概念。

12398
20:26:42.319 --> 20:26:48.062
也有点像如何建立这些自动贩卖机，让任何人都能买到，然后你就建立了一个Dex。

12399
20:26:48.062 --> 20:26:50.194
现在，一旦你一旦你处理完01。

12400
20:26:50.194 --> 20:27:09.592
第二，在这一点上你真的有学习的许可，你已经准备好去做一些破坏和建造一些很酷的东西，也许去建造一些其他的东西，但是回来，来，来，来挑战三，挑战三将是更开放的一点，将会有其他的人也在建造这个。

12401
20:27:09.592 --> 20:27:15.412
你必须通过前三个挑战才能挑战第三个才能进入这个聊天室。

12402
20:27:15.412 --> 20:27:23.480
但这里有一个聊天室，其他正在构建自己平台的开发者都在那里，你可以和他们一起学习，一起聊天。

12403
20:27:23.480 --> 20:27:24.957
但你要建立一个交易所。

12404
20:27:24.957 --> 20:27:33.303
你要建立一个在智能合约中以去中心化的方式工作的交易所没有集中的断点。

12405
20:27:33.303 --> 20:27:43.985
这意味着你必须同时拥有存款和代币的储备你必须有一个定价函数和LP代币以及所有其他你需要学习的东西。

12406
20:27:43.985 --> 20:27:46.831
挑战五是一个多SIG钱包。

12407
20:27:46.831 --> 20:28:00.968
这样一个基本的重要的事情如何存储你的eath安全将是在一个多SIG钱包，你可以有多个身份，甚至像什么是道琼斯的基础，有点像从一个多SIG钱包开始。

12408
20:28:00.968 --> 20:28:06.680
你需要建立一个你需要理解的调用数据调用数据是非常奇怪和复杂的。

12409
20:28:06.680 --> 20:28:09.972
所有事情都是交易即使你只是戳了戳合同。

12410
20:28:09.972 --> 20:28:18.260
这是一个事务，你必须正确地编写调用数据，说，我想在这个特定的契约上调用这个特定的函数。

12411
20:28:18.260 --> 20:28:32.464
这就是multisig钱包然后它就结束了我们还有更多的挑战在进行中，但它就结束了构建一个SVG NFT构建一个在智能合约中制作实际绘图并渲染它非常有趣。

12412
20:28:32.464 --> 20:28:39.683
这就是极速跑，极速跑Aetherium checkout脚手架，开始建造，在Aetherium上建造一些很棒的东西。

12413
20:28:39.736 --> 20:28:41.680
心，心，心，去抓住他们。

12414
20:28:41.736 --> 20:28:56.593
Austin Griffith是OGS中的一员，帮助工程师跟上区块链世界的步伐，非常感谢Austin到目前为止所做的一切。

12415
20:28:56.736 --> 20:29:00.042
好了，现在我们开始讲NF - T。

12416
20:29:00.042 --> 20:29:01.171
让我们开始吧。

12417
20:29:01.736 --> 20:29:05.820
我已经做了一些关于什么是NF T以及如何开始使用NF T的视频。

12418
20:29:05.820 --> 20:29:16.316
所以我们将观看之前的Python版本的部分内容，我将在其中进行解释，并从更高的层面进行讲解，然后当然，我们将进入最终的非功能性教程。

12419
20:29:16.316 --> 20:29:19.617
让我们来了解一下NF - T看，NF - T现在很火。

12420
20:29:19.617 --> 20:29:25.908
Nf T也被称为ERC 720，是在以太坊平台上创建的令牌标准。

12421
20:29:25.908 --> 20:29:31.176
Nf T代表不可替代的令牌，是一个类似于ERC 20的令牌标准。

12422
20:29:31.176 --> 20:29:37.848
ERC 20就像一个制造者的环节，所有的好东西都在以太链上找到了。

12423
20:29:37.848 --> 20:29:45.382
NF T或不可替代的令牌是不可替代的令牌，这意味着它们彼此完全独特。

12424
20:29:45.382 --> 20:29:49.684
而且一个令牌不能与同类的任何其他令牌互换。

12425
20:29:49.684 --> 20:29:56.091
一种很好的思考方式是1美元可以和其他任何一美元互换1美元和另一美元的价值是相同的。

12426
20:29:56.091 --> 20:30:16.227
这些是可替换的代币，就像ERC 20s一个链接总是等价于另一个链接，相比之下，将是NFT的那些书呆子，我们知道就像口袋妖怪将是一个很好的例子，你是一个口袋妖怪将有不同的属性，不同的移动，套，不能与任何其他口袋妖怪互换，或可能是一个更相关的。

12427
20:30:16.227 --> 20:30:19.737
它就像一张交易卡，或一件独特的艺术品或类似的东西。

12428
20:30:19.737 --> 20:30:35.689
这就是这些NF T的含义不可替代，不可互换的符号，目前最好的表现形式或被认为是数字艺术作品，它们是不可腐蚀的，有一个永久的历史，谁拥有它们谁使用它们，等等。

12429
20:30:35.737 --> 20:30:39.185
现在，就像我说的，NF - T只是一个象征性的标准。

12430
20:30:39.737 --> 20:30:41.441
能让它们不仅仅是艺术。

12431
20:30:41.737 --> 20:30:48.037
给他们提供属性，你可以让他们战斗，你可以用他们做真正独特的事情，你可以对他们做任何你想做的事情。

12432
20:30:48.037 --> 20:31:01.874
但现在，最简单的思考方式，也是最流行的思考方式是称它们为啊，啊，啊它很奇怪，或某种类型的收藏品或任何独特的东西。

12433
20:31:01.874 --> 20:31:14.220
现在，他们最近得到了大量的关注，因为我们看到越来越多的这些土地以疯狂的价格出售，就像我们看到x∞以1美元的价格出售他们的9块土地9块他们独特的土地。

12434
20:31:14.220 --> 20:31:14.945
500万年。

12435
20:31:14.945 --> 20:31:24.281
我们还看到了Nyan猫的最初创造者，你知道，这只猫卖了300英镑。

12436
20:31:24.281 --> 20:31:27.358
显然人们很重视这些东西。

12437
20:31:27.358 --> 20:31:35.214
就像我说的，它们只是部署在智能合约平台上的代币，你可以在不同的非ft平台上查看它们，比如公海或可穿戴平台。

12438
20:31:35.214 --> 20:31:38.687
这些是非金融市场让人们买卖它们。

12439
20:31:38.738 --> 20:31:45.014
显然，没有这些市场你也能做到，因为它是去中心化的，但它们有助于提供良好的用户界面。

12440
20:31:45.014 --> 20:31:48.806
现在，像你们中的许多人一样，我最初对NF T的想法是好的，这听起来很蠢。

12441
20:31:48.806 --> 20:31:50.347
但我觉得那很蠢。

12442
20:31:50.347 --> 20:31:52.081
我认为艺术确实有很多价值。

12443
20:31:52.081 --> 20:31:55.492
而且我认为艺术家们的报酬并不总是公平的。

12444
20:31:55.492 --> 20:32:05.466
这实际上是当今世界的一个大问题一个艺术家可以创作某种类型的艺术作品人们只是复制粘贴它，你知道，到处都是，他们从来没有得到他们作品的归属。

12445
20:32:05.466 --> 20:32:14.996
所以，有一个非常简单的分散版税机制，或者某种类型的机制，让这些艺术家可以准确地获得他们所做的事情的报酬，我认为这是非常重要的。

12446
20:32:14.996 --> 20:32:15.625
我喜欢音乐。

12447
20:32:15.625 --> 20:32:18.238
我喜欢电影，那是我能消化的艺术作品。

12448
20:32:18.238 --> 20:32:23.590
我真的很喜欢，我认为他们得到适当的补偿是公平的，因为他们为我的生活提供了价值。

12449
20:32:23.590 --> 20:32:33.642
我认为NF T是解决这个问题的一个很好的方法，因为它有一些分散的审计跟踪，以及我们可以建立的专利追踪，并且可以非常透明地看到，而不需要通过一些集中的服务。

12450
20:32:33.642 --> 20:32:35.118
这就是它的基本要点。

12451
20:32:35.118 --> 20:32:41.118
让我们多谈谈标准ERC 721标准是非ft标准。

12452
20:32:41.118 --> 20:32:48.338
这是它的基础还有另一种标准是半可替换代币，1155我们不打算在这里讨论这个。

12453
20:32:48.338 --> 20:32:52.938
但是你可以看看721和ERC 20和ERC之间的主要区别。

12454
20:32:52.938 --> 20:32:58.024
20是他们有一个非常简单的映射在一个地址和这个地址的容量之间。

12455
20:32:58.024 --> 20:33:02.045
720个有唯一的令牌ID，每个令牌ID有唯一的所有者。

12456
20:33:02.045 --> 20:33:06.439
另外，它们还有一个叫令牌URI的东西，我们一会儿会讲到。

12457
20:33:06.439 --> 20:33:07.989
每个令牌都是唯一的。

12458
20:33:07.989 --> 20:33:11.322
每个令牌ID表示一个唯一的资产。

12459
20:33:11.322 --> 20:33:17.739
由于这些资产是唯一的，我们希望能够可视化它们并显示它们实际的样子我们需要定义对象的那些属性。

12460
20:33:17.739 --> 20:33:21.535
如果它是一件艺术品，我们就需要一种方法去定义这种艺术品的样子。

12461
20:33:21.535 --> 20:33:26.646
如果它是游戏中的某种类型的角色，我们需要等待在NFT中定义角色属性。

12462
20:33:26.646 --> 20:33:29.230
这就是元数据和令牌URI的用武之地。

12463
20:33:29.230 --> 20:33:37.246
如果你对Aetherium有所了解，你就会知道有时候汽油价格会非常高，特别是当它需要储存大量空间时，它会变得非常非常贵。

12464
20:33:37.246 --> 20:33:50.381
你的第一个问题可能是，他们储存了这些图像吗?这些是链上的碎片吗?答案是，有时候当他们想出NF T的时候，美工们在部署东西的时候，开发人员和美工们说，是的，艺术，让我们做艺术吧。

12465
20:33:50.381 --> 20:33:54.673
我要把这个一兆字节的图像放到以太链上。

12466
20:33:54.739 --> 20:34:00.627
天啊，汽油太贵了，删除按钮。

12467
20:34:00.739 --> 20:34:03.525
否则，就不好了。

12468
20:34:05.739 --> 20:34:08.196
他们把所有的艺术品都挂起来，会非常贵的。

12469
20:34:08.196 --> 20:34:12.339
为了解决这个问题，他们加入了标准，也就是令牌URI。

12470
20:34:12.339 --> 20:34:23.437
这是一个通用的唯一指示器，可以指示该资产或令牌是什么样子以及令牌的属性是什么，您可以使用集中的API或IPFS之类的东西。

12471
20:34:23.437 --> 20:34:25.089
来获取那个令牌URI。

12472
20:34:25.089 --> 20:34:36.587
典型的令牌URI必须以这样的格式返回一些东西，其中有名称，图像，位置，描述，以及下面的任何属性，通常有关于链上元数据和链外元数据的讨论。

12473
20:34:36.587 --> 20:34:49.213
因为在链外存储所有元数据要容易得多，成本也低得多，很多人会使用像去中心化的IPFS这样的东西，但确实需要一点中心性来保持持久性，但他们也可以使用自己的中心化API。

12474
20:34:49.213 --> 20:34:54.030
然而，很明显，如果它下降了，你就失去了你的形象，你就失去了与非功能性相关的一切。

12475
20:34:54.030 --> 20:35:02.055
因此，大多数非ft市场实际上不能也不会读取链属性或链元数据，因为它们太习惯于查找令牌URI了。

12476
20:35:02.055 --> 20:35:09.040
显然，如果你使用链外元数据，你就不能做任何很酷或很有趣的事情，也不能从你的NF T中获得任何收益。

12477
20:35:09.040 --> 20:35:16.161
举个例子来说吧，如果你想要创造一款基于链的Pokemon游戏，你的所有属性都必须是基于链的，这样你的Pokemon才能与其他Pokemon进行互动。

12478
20:35:16.161 --> 20:35:20.543
因为如果它是链外的，那就很难用密码学来证明了。

12479
20:35:20.543 --> 20:35:24.379
如果你是NF - T的新手，你可能会想，等等，这有很多信息，我会让你简单点。

12480
20:35:24.379 --> 20:35:31.490
如果你想渲染一个图像，我是一个非ft，把你的图像添加到IPFS，添加一个元数据文件指向IPFS上的图像文件。

12481
20:35:31.490 --> 20:35:35.422
然后抓取那个令牌URI，把它设置为你的NFT。

12482
20:35:35.422 --> 20:35:39.851
chain link DND这篇文章很好地介绍了这一点，并向您展示了如何做到这一点。

12483
20:35:39.851 --> 20:35:46.865
所以，如果你想学习如何做到这一点，一定要阅读这个视频我们不打算在这个视频中讨论，但我们将部署我们的第一个非函数链属性。

12484
20:35:46.865 --> 20:36:02.658
同样地，将你的属性放在链上能够让你创造出真正有创意的NFT去创造游戏或拥有有趣的属性，并且能够保证你的NFT的真实性因为这些属性总是在链上。

12485
20:36:02.740 --> 20:36:16.891
好了，现在我们知道了NF t是什么，和ERC 20类似的基本知识。你可以在Aetherium上看到eip721或ERC 721不可替代的令牌标准，即IP。

12486
20:36:16.891 --> 20:36:24.314
再一次，如果你向下滚动，你能看到所有不同的事件和创建这个令牌的不同函数。

12487
20:36:24.314 --> 20:36:29.200
现在我们要做的所有事情都可以在这个GitHub回购中找到。

12488
20:36:29.200 --> 20:36:38.788
这个硬帽NFT FCC，我们将通过所有的代码来部署和创建我们自己的定制的NFT。

12489
20:36:38.788 --> 20:36:51.812
我把这称为终极非功能性回购作为这门课的一部分，因为我们在这里会讲到很多，我们会讲到一个基本的非功能性回购，一个真正的极简的非功能性回购然后是一个IPFS主持的非功能性回购。

12490
20:36:51.812 --> 20:36:52.954
这是动态的。

12491
20:36:52.954 --> 20:37:05.445
它使用随机性来生成独特的NF T，这样我们就可以获得稀有稀有的卡片，稀有的代币或属性，或者任何你想要的东西。

12492
20:37:05.445 --> 20:37:08.991
然后我们将进行所谓的SVG非ft。

12493
20:37:08.991 --> 20:37:14.531
这些实体是100%托管在链上的，所以你不需要一个外链。

12494
20:37:14.531 --> 20:37:17.635
所以你不需要IPFS，不需要链下数据库。

12495
20:37:17.635 --> 20:37:26.870
这个也是动态的，它会使用价格供给来根据资产的价格波动实体的实际形象。

12496
20:37:26.870 --> 20:37:29.551
这是我们将要使用的图像。

12497
20:37:29.551 --> 20:37:32.508
显然我们还有这三只可爱的小狗。

12498
20:37:32.508 --> 20:37:35.169
如果你想跟随快速入门，你完全可以。

12499
20:37:35.169 --> 20:37:41.257
我将快速概述一下运行代码的过程向你们展示最后的结果。

12500
20:37:41.257 --> 20:37:50.947
基本上，我们要做的是我们要有我们的代码，我们要运行hardhat部署破折号网络，rink B，破折号标签主。

12501
20:37:50.947 --> 20:37:54.510
这将部署我们所有的合同和一切。

12502
20:37:54.510 --> 20:37:58.433
最后，如果我们去测试nets。open c。

12503
20:37:58.433 --> 20:38:07.186
我们抓取其中一个NFT的地址，我们应该能够把它放在这里，看到我们实际的NFT作为一个项目的集合。

12504
20:38:07.186 --> 20:38:10.614
另外，我们可以直接看合同。

12505
20:38:10.742 --> 20:38:25.617
我们可以读取契约，获取令牌URI，然后复制这个令牌，粘贴到浏览器中，然后获取image属性，看看chain上是什么样子。

12506
20:38:25.617 --> 20:38:34.903
说了这么多，让我们学习如何建立这个终极的非功能性回购和建立所有这些不同的可定制的NFT让我们开始吧。

12507
20:38:34.903 --> 20:38:40.825
同样，在终端中，我要创建一个新目录。

12508
20:38:40.825 --> 20:38:44.575
我们叫它“硬帽”和“T”代表FCC。

12509
20:38:44.742 --> 20:38:45.903
我们要用cd。

12510
20:38:47.742 --> 20:38:49.182
这就是代码。

12511
20:38:52.742 --> 20:39:02.897
Point，你已经很熟悉我们代码库的设置了，可以随意复制或做任何你想做的设置，我们会做yarn，添加dash dev hard hat。

12512
20:39:02.897 --> 20:39:06.592
在加载的时候，我要复制一些漂亮的文件。

12513
20:39:06.592 --> 20:39:10.742
因为我想用更漂亮的，我要把我的安全帽复制过来。

12514
20:39:10.742 --> 20:39:11.242
配置。

12515
20:39:11.242 --> 20:39:11.408
js。

12516
20:39:11.408 --> 20:39:19.304
我还要抓取Jason复制到这里的包，我要删除这个旧的package。JSON。

12517
20:39:19.304 --> 20:39:25.096
然后按回车键把刚才复制过来的这个重命名为package copy到package json。

12518
20:39:25.096 --> 20:39:31.373
我这样做的原因是，我可以直接运行纱线，为我安装所有这些东西。

12519
20:39:31.373 --> 20:39:40.181
或者我们可以回到这里，看看第九课的内容安全帽，智能合约彩票，所有这些东西，同样运行这一大块。

12520
20:39:40.181 --> 20:39:44.361
或者你可以复制你的json包，然后运行yarn，它会做同样的事情。

12521
20:39:44.361 --> 20:39:47.885
现在我们不需要一遍又一遍地做这个样板了。

12522
20:39:47.885 --> 20:39:54.043
当它加载时，我还会抓取我的Dotty和v文件我们在过去的几个项目中使用过，自述文件。

12523
20:39:54.043 --> 20:39:54.143
医学博士。

12524
20:39:54.143 --> 20:39:56.593
我们就做我们该做的事吧。

12525
20:39:56.743 --> 20:39:58.457
我们要做三种不同的契约。

12526
20:39:58.743 --> 20:40:08.132
使用ERC 721标准，然后我们将做一个随机的IPFS托管的NF t。

12527
20:40:08.132 --> 20:40:13.443
最后，我们要做一个动态的sv G非傅里叶变换。

12528
20:40:13.443 --> 20:40:22.076
所以我们的随机NF - T在创造时是随机的，这给了我们的NF - T一些真正的稀缺性和一些真正的随机性。

12529
20:40:22.076 --> 20:40:24.692
它将被托管在IPFS上。

12530
20:40:24.692 --> 20:40:34.143
我们的动态SVG非ft将100%托管在链上，它的图像将根据一些参数而改变。

12531
20:40:34.143 --> 20:40:39.243
这就是使它成为动态SVG非ft的原因。

12532
20:40:39.743 --> 20:40:47.437
我们来创建一个新文件夹，我们来创建合约文件夹，我们来创建我们的第一个ntf这将是我们的基本NFT。

12533
20:40:47.437 --> 20:40:55.225
这里我讲得快一点，因为我们要做的大部分实际上都是我们已经熟悉的东西。

12534
20:40:55.225 --> 20:40:58.143
所以我们将在一个新文件中做基本的NF T。soul。

12535
20:40:58.143 --> 20:41:00.780
我们来做一下。

12536
20:41:00.780 --> 20:41:07.795
我们来看看spdx许可标识符，它是MIT。

12537
20:41:07.795 --> 20:41:12.467
我们会做pragma, solidity，胡萝卜0，第8点。

12538
20:41:12.467 --> 20:41:17.849
语用，固性，然后我们学收缩，基本的NF - t。

12539
20:41:17.849 --> 20:41:20.691
我来取一个基本的t。

12540
20:41:20.691 --> 20:41:22.010
就像这样。

12541
20:41:22.010 --> 20:41:24.276
缩并基本NF t。

12542
20:41:24.276 --> 20:41:30.340
然后我们会努力运行编译或者yarn，点击编译，到目前为止看起来我们做得很好。

12543
20:41:30.340 --> 20:41:31.017
好的,完美的。

12544
20:41:31.017 --> 20:41:44.494
基于那个非ft令牌标准，我们回到那个EIP，我们将需要一大堆不同的函数，我们将需要转移事件，我们将需要所有者事件反弹，我们将会用到所有这些不同的函数。

12545
20:41:44.494 --> 20:41:56.881
我们可以百分之百地实现这些并像ERC 20那样转移它们，或者再一次，我们可以使用，你猜对了，我们也会使用公开的齐柏林飞船合同。

12546
20:41:56.881 --> 20:41:59.201
我们回来打开齐柏林飞艇，再看合同。

12547
20:41:59.201 --> 20:42:03.444
我们要把它和纱线一起加入，加入dash Dev。

12548
20:42:03.444 --> 20:42:08.985
纱，加上破折号开发在打开合同，像这样。

12549
20:42:08.985 --> 20:42:18.355
在这个过程中，我们可以看看ERC 721我们可以看到创建一个极简ERC 721是什么样子的。

12550
20:42:18.355 --> 20:42:21.981
现在它的ERC附带了许多扩展。

12551
20:42:21.981 --> 20:42:24.744
在题目给我们的这个例子中。

12552
20:42:24.744 --> 20:42:30.002
他们使用的是ERC 721 Uri存储，我们稍后会讲到。

12553
20:42:30.002 --> 20:42:31.260
我们把它加到这里。

12554
20:42:31.260 --> 20:42:35.399
现在我们可以从我们的合同中导入ERC 21。

12555
20:42:35.399 --> 20:42:44.177
我们会在open Zeppelin输入/合约/令牌/你的c721 / ERC。

12556
20:42:44.177 --> 20:42:49.282
所以他们在演示中使用了另一个，但不用担心这个。

12557
20:42:49.282 --> 20:42:50.930
和伦理委员会一样。

12558
20:42:50.930 --> 20:42:56.151
我们会说我们的基本非功能性是ERC 721。

12559
20:42:56.151 --> 20:43:04.151
我们在做这个继承，你找到构造函数，我们可以看到它有一个构造函数，它接受一个名字和一个符号。

12560
20:43:04.151 --> 20:43:08.633
我们需要使用构造函数和契约。

12561
20:43:08.633 --> 20:43:12.521
我们会说，建造门。

12562
20:43:12.745 --> 20:43:15.795
构造函数是空的。

12563
20:43:16.745 --> 20:43:21.306
ERC 721构造器，我们叫它小狗。

12564
20:43:21.745 --> 20:43:24.094
它的标志就是这样的狗。

12565
20:43:25.745 --> 20:43:30.278
它是这只狗，对吧所以它将是一个NF T，仅仅是这只狗。

12566
20:43:30.278 --> 20:43:33.880
名字是doggy，符号是dog。

12567
20:43:33.880 --> 20:43:35.995
现在为了创造新的狗。

12568
20:43:35.995 --> 20:43:55.035
我们要做的是openzeppelin代码带有一个叫做mint的函数和erc20完全一样我们要创建一个叫做mint NFT的函数这是一个公共文件函数它会返回活动6。

12569
20:43:55.035 --> 20:44:08.390
我们将使用ERC 20的safe mint函数或者下划线safe mint message。sender将向调用这个mint函数的人铸造令牌。

12570
20:44:08.390 --> 20:44:14.697
然后我们还需要给它一个令牌ID，如果我们回头看ERC 721的代码。

12571
20:44:14.697 --> 20:44:22.911
你也可以在GitHub上看到这个，我们会看这个safe mint函数，它接受一个地址，到谁将拥有NFT。

12572
20:44:22.911 --> 20:44:28.278
然后是令牌ID，基于这个地址的令牌ID是什么。

12573
20:44:28.278 --> 20:44:34.969
因此，如果在同一个智能合约上有一组令牌，那么每个令牌都需要自己唯一的令牌ID。

12574
20:44:34.969 --> 20:44:49.677
我们要做的是创建一个un256，私有变量s_ token counter，它会在构造函数中初始化为0，但我们会显式地说，es token counter = 0。

12575
20:44:49.677 --> 20:44:56.336
然后在这里，我们有这个新nft的标记ID是那个标记计数器。

12576
20:44:56.336 --> 20:45:01.795
当然，我们会说s token counter等于s token counter加1。

12577
20:45:01.795 --> 20:45:09.665
每次我们想要一个新的NFT时，我们向上取令牌计数器，然后我们会返回，我们会返回新的标签计数器。

12578
20:45:09.665 --> 20:45:09.955
正确的。

12579
20:45:09.955 --> 20:45:17.126
然后很明显，在底部，我们可以做function，获取令牌计数器，这将是一个公共视图在256中返回你。

12580
20:45:17.126 --> 20:45:29.296
这里我讲得快一点，因为你们之前见过这个，返回s_ token counter，因为上面是私有变量，下面是公共函数来获取token counter。

12581
20:45:29.296 --> 20:45:31.693
严格来说，就是这样。

12582
20:45:31.693 --> 20:45:33.166
严格来说这是NF T。

12583
20:45:33.166 --> 20:45:41.090
但这看起来像什么呢?现在，在这个EIP令牌标准中，这个NF T看起来什么都不像。

12584
20:45:41.090 --> 20:45:43.299
它有一个叫令牌URI的东西。

12585
20:45:43.299 --> 20:45:48.999
这是一个很重要的函数它告诉我们这个令牌到底是什么样的。

12586
20:45:48.999 --> 20:45:51.665
就像我们在小课上说的。

12587
20:45:51.665 --> 20:45:59.817
这个令牌URI返回某种类型的URL或通用资源标识符，它返回类似这样的JSON。

12588
20:45:59.817 --> 20:46:02.796
在这个JSON中，我们会有这个图像部分。

12589
20:46:02.796 --> 20:46:08.696
这个图像将是一个URL它将指向这个图像的实际样子。

12590
20:46:08.696 --> 20:46:13.496
这个URL可以托管在chain上，可以托管在IPFS上，可以托管在任何地方。

12591
20:46:13.496 --> 20:46:16.700
但理想情况下，我们不会使用一个集中的服务器来托管它。

12592
20:46:16.747 --> 20:46:22.126
如果这是托管在谷歌云或中央服务器上，我们的中央服务器宕机了。

12593
20:46:22.126 --> 20:46:25.254
猜猜这个主持人长什么样子，什么都不像。

12594
20:46:25.254 --> 20:46:32.136
我们想要使用某种去中心化存储，来获得一个URL或URI来存储它的样子。

12595
20:46:32.136 --> 20:46:38.811
为了使本节对您来说更容易一些，我实际上已经将一个图像托管到IPFS中。

12596
20:46:38.811 --> 20:46:48.271
对你来说，它会是@ IPFS。。斜杠，它会是这样的，这就是我们要用在狗身上的图像。

12597
20:46:48.271 --> 20:46:58.074
如果你只是创建这个图像，作为令牌URI，那是行不通的，我们需要一个URI返回这个，里面有图像。

12598
20:46:58.074 --> 20:47:01.347
对于第一部分，我们已经做过了。

12599
20:47:01.347 --> 20:47:03.320
它就在这里。

12600
20:47:03.320 --> 20:47:06.323
这就是令牌URI函数需要返回的内容。

12601
20:47:06.323 --> 20:47:14.366
它会有名字，描述，图片URI，然后指向狗，还有一些属性，等等。

12602
20:47:14.366 --> 20:47:21.008
你会注意到这里的图片指向HTTPS，点。/ / ipfs。

12603
20:47:21.008 --> 20:47:21.192
io。

12604
20:47:21.192 --> 20:47:29.522
我这样做的原因是，以防你没有IPFS网关，但如果它是IPFS形式会更好。

12605
20:47:29.522 --> 20:47:32.884
因为如果中央服务器ipfs。

12606
20:47:32.884 --> 20:47:38.424
io，当它下降时，NFT就会显示它什么也显示不出来。

12607
20:47:38.424 --> 20:47:41.009
所以会好很多。

12608
20:47:41.009 --> 20:47:43.566
如果不是ipfs。

12609
20:47:43.566 --> 20:47:43.762
io。

12610
20:47:43.762 --> 20:47:49.069
是IPFS，冒号，斜杠，像这样，而不是IPFS。

12611
20:47:49.069 --> 20:47:49.238
io。

12612
20:47:49.238 --> 20:47:51.298
但现在，这是我们要用的。

12613
20:47:51.298 --> 20:47:57.248
你可以到GitHub上，抓取这部分的内容。

12614
20:47:57.248 --> 20:48:04.494
对吧?打开契约，基本的非ft，你可以抓取这个，这个，上面的部分，像这样复制。

12615
20:48:04.494 --> 20:48:10.384
我们会把令牌URI粘贴到上面，像这样。

12616
20:48:10.384 --> 20:48:13.384
哦，应该是return。

12617
20:48:13.384 --> 20:48:14.474
好了。

12618
20:48:14.748 --> 20:48:15.224
好的,很酷。

12619
20:48:17.748 --> 20:48:18.075
这一点。

12620
20:48:22.748 --> 20:48:24.655
直接到IPFS，这很好。

12621
20:48:26.748 --> 20:48:29.594
文件实际上指向http。

12622
20:48:29.594 --> 20:48:29.901
ipf。

12623
20:48:29.901 --> 20:48:30.054
io。

12624
20:48:31.748 --> 20:48:33.715
T在非时态中不会这样做。

12625
20:48:35.748 --> 20:48:37.454
但是对于你的NF - T，不要这样做。

12626
20:48:38.748 --> 20:48:40.748
这是一个公共常数变量。

12627
20:48:42.748 --> 20:48:43.881
你写的东西永远不会变。

12628
20:48:44.748 --> 20:48:50.442
这样每个遇到它的人都能得到这个可爱的小冰球。

12629
20:48:50.442 --> 20:48:55.814
我们现在做的方法是我们需要识别实际的令牌URI函数。

12630
20:48:55.814 --> 20:49:02.506
我在上面写get token counter，我们说function, token URI。

12631
20:49:02.506 --> 20:49:16.373
这些总是使用一个unt256令牌ID，我们会让它成为一个公共视图，override返回字符串内存。

12632
20:49:16.373 --> 20:49:21.248
这需要返回令牌URI。

12633
20:49:21.248 --> 20:49:26.414
现在，这将是最基本的方法来创造它，对吧。

12634
20:49:26.414 --> 20:49:33.510
如果我们想让这个函数更好一点，我们也可以注释掉令牌ID，因为我们实际上没有使用令牌ID。

12635
20:49:33.510 --> 20:49:39.415
但是我们在我们进口的ERC 721中重写了。

12636
20:49:39.415 --> 20:49:43.291
它有一个令牌ID函数或一个令牌URI函数。

12637
20:49:43.291 --> 20:49:49.076
我们要重写这个，对吧，我们根本不用这个，我们说，嘿，我们要在这里用我们自己的。

12638
20:49:49.076 --> 20:49:52.354
这就是我们需要的一切。

12639
20:49:52.354 --> 20:50:03.114
现在如果你把这个放到B溜冰场，如果你跳到C测试网，你会把这个，这只狗，这个可爱的小pop会一直出现。

12640
20:50:03.114 --> 20:50:06.699
让我们继续，让我们为此创建一个小小的deploy函数。

12641
20:50:06.749 --> 20:50:14.601
我们创建一个新文件夹，部署一个新文件，我们称它为one deploy basic NF T·js。

12642
20:50:14.601 --> 20:50:19.191
这看起来和我们之前做过的很像。

12643
20:50:19.191 --> 20:50:22.749
所以我要在这里移动快一点。

12644
20:50:22.749 --> 20:50:36.129
Const network = require hard hats, Const development chains， = require。dot。slash helper, hard hats config。

12645
20:50:36.129 --> 20:50:38.589
我想我没有加进去。

12646
20:50:38.749 --> 20:50:43.369
所以我要复制粘贴我的助手Hardhead配置从我们的上一个项目。

12647
20:50:43.369 --> 20:50:59.165
如果你有困惑，你可以到这里的GitHub，到助手Hardhead配置，从这里获取它，我们有const开发链，或者说const verify = require。dot / utils。

12648
20:50:59.165 --> 20:51:00.248
削减验证。

12649
20:51:00.248 --> 20:51:17.016
我们还会抓取我们的utils，我要复制粘贴从alas项目中抓取utils文件夹，同样，你可以从上一个项目中复制粘贴，或者你可以直接到repo，抓取经过验证的。j，我们稍后会讲到这两个函数，但至少现在要抓取经过验证的。

12650
20:51:17.016 --> 20:51:18.875
然后我们开始这个函数。

12651
20:51:18.875 --> 20:51:22.782
我们会写modulethatexports = async function。

12652
20:51:22.782 --> 20:51:29.491
我们会得到指定账户和部署。

12653
20:51:29.750 --> 20:51:31.942
我们会说const。

12654
20:51:34.750 --> 20:51:40.282
针对部署器= await，获取指定帐户。

12655
20:51:41.750 --> 20:51:50.394
这里有一个小日志，只是为了开始做我们的基本非函数不接受任何构造函数参数。

12656
20:51:50.394 --> 20:51:55.250
所以我们说const args等于这里的一个小空白。

12657
20:51:55.250 --> 20:52:10.035
然后我们用const basic NFT = await，部署basic NFT，我们之前见过很多次了现在我们从Deployer调用。

12658
20:52:10.035 --> 20:52:11.765
Args将是Args。

12659
20:52:11.765 --> 20:52:14.050
然后是log，它是正确的。

12660
20:52:14.050 --> 20:52:16.057
然后我们还会做重量确认。

12661
20:52:16.057 --> 20:52:24.400
它将是network。config。block, confirmation，或者1。

12662
20:52:24.400 --> 20:52:56.385
如果我们想验证这个，我们会再做一次如果它不是development chains，。includes network。name。process EMV。ether。scan API key会说log verifying。the。await，验证基本NF T。address参数它会是空的，抓取这个小日志，把它放在下面。

12663
20:52:56.385 --> 20:52:58.670
然后在基本的NF - T中。

12664
20:52:58.670 --> 20:53:00.912
这应该是参数而不是参数。

12665
20:53:00.912 --> 20:53:02.718
现在我们有了一个部署脚本。

12666
20:53:02.718 --> 20:53:09.636
现在我们在测试数据部署脚本中有了一个基本的非ft，或者任何hh部署或yarn Hardhead部署。

12667
20:53:09.636 --> 20:53:19.195
哦，让我们回到最基本的茶或薄荷茶需要返回一个UNT 256。

12668
20:53:19.195 --> 20:53:20.073
再试一次。

12669
20:53:20.073 --> 20:53:24.651
Get令牌计数器也需要返回一个UNT忘记你到其他任何地方。

12670
20:53:24.651 --> 20:53:24.901
不。

12671
20:53:24.901 --> 20:53:25.851
好的，看起来不错。

12672
20:53:25.851 --> 20:53:33.595
看起来我们正在编译编译，部署，如果你想把它部署到溜冰场B，你可以。

12673
20:53:33.595 --> 20:53:37.412
但我建议你先别急，因为我们最后才会这么做。

12674
20:53:37.412 --> 20:53:39.154
现在我们已经编写了部署脚本。

12675
20:53:39.154 --> 20:53:42.751
我们已经写好了合同，你已经知道接下来要做什么了。

12676
20:53:42.751 --> 20:53:43.396
是的,整洁。

12677
20:53:43.396 --> 20:53:47.944
接下来要做的是测试因为我们还没有学到太多东西。

12678
20:53:47.944 --> 20:53:50.460
我不会带领你们完成这个测试。

12679
20:53:50.460 --> 20:53:51.969
我现在要挑战你。

12680
20:53:51.969 --> 20:53:58.322
如何暂停视频，自己写测试，看看你能在测试中走多远。

12681
20:53:58.322 --> 20:54:12.735
记住，要测试它，你需要运行纱线，硬帽测试，让我们看看你是否真的可以自己编写测试，然后回到视频中，看看你的测试是否和我们在这里做的一样好。

12682
20:54:12.735 --> 20:54:16.170
当然，你可以去GitHub的回购测试部分。

12683
20:54:16.170 --> 20:54:20.172
如果你迷路了，你可以看看基本的非功能性语言。

12684
20:54:20.172 --> 20:54:20.522
测试。

12685
20:54:20.522 --> 20:54:22.803
跟随。

12686
20:54:22.803 --> 20:54:27.855
好了，欢迎回来。

12687
20:54:27.855 --> 20:54:40.686
希望你写了一些很棒的测试，花时间做一些练习真的会让你成为一个更好的工程师。

12688
20:54:40.752 --> 20:54:42.571
跟着我走，太棒了。

12689
20:54:43.752 --> 20:54:47.502
所有事都亲力亲为才能让你坚持下去。

12690
20:54:47.502 --> 20:54:49.202
我希望你们暂停了视频。

12691
20:54:49.202 --> 20:54:55.693
希望你们能够自己编写这个测试，从技术上讲，你们已经创建了一个非常简单的非ft。

12692
20:54:55.752 --> 20:54:56.802
伟大的工作。

12693
20:54:56.802 --> 20:55:00.185
让我们来个升级。

12694
20:55:02.752 --> 20:55:09.475
随机IPFS托管的NFT，在那里我们几乎可以编程地完成所有事情。

12695
20:55:09.475 --> 20:55:10.521
让我们开始吧。

12696
20:55:10.521 --> 20:55:16.290
在我们的契约中，我们将创建一个新文件随机IPFS, NFT。soul。

12697
20:55:16.290 --> 20:55:17.407
同样的事情。

12698
20:55:17.407 --> 20:55:25.842
spdx许可标识符，MIT pragma, soidity carrot 0，点8。

12699
20:55:25.842 --> 20:55:34.152
7、无论你想用什么版本，都会做合同随机IPFS NF吗?T，像这样。

12700
20:55:34.152 --> 20:55:48.872
那么这个会做什么呢?因此，当我们指的是NFT时，我们将触发一个链链接VRF调用来获得一个随机数，而不是仅仅铸造任何nff。

12701
20:55:48.872 --> 20:55:54.945
利用这个数，我们将得到一个随机的NF t我们将决定它。

12702
20:55:54.945 --> 20:56:00.863
我们要用的随机n (t)要么是哈巴狗，要么是湿婆，要么是圣。

12703
20:56:00.863 --> 20:56:01.603
伯纳德。

12704
20:56:01.603 --> 20:56:06.379
所以无论什么时候有人铸造NF T，他们都会随机得到这三只狗中的一只。

12705
20:56:06.379 --> 20:56:19.681
我们要让每只狗都有不同的稀有度，我们要让这些狗有不同的稀有度，比如我们想让哈巴狗超级稀有，湿婆狗有点稀有，然后圣。

12706
20:56:19.681 --> 20:56:21.372
伯纳德很普通。

12707
20:56:21.372 --> 20:56:25.176
所以湿婆在我们身上可能是非常罕见的，圣。

12708
20:56:25.176 --> 20:56:30.091
伯纳德很常见，对吧?或者是最常见的。

12709
20:56:30.091 --> 20:56:49.304
让我们开始构建这个，我们可能需要创建一个函数叫request NF t，因为我们知道我们需要启动一个通道VRF请求，我们可能需要让一个函数满足随机单词，那将需要一个请求ID和一个。

12710
20:56:49.304 --> 20:56:57.395
数组，记忆随机单词，就像我们之前看到的，我们过去完成过随机单词。

12711
20:56:57.395 --> 20:57:03.946
让我们让我们更进一步，我们将使用户必须付费铸造NF t。

12712
20:57:03.946 --> 20:57:13.998
所以这将是他们必须支付一定数额的土地来获得非所有权然后合同的所有者收回土地。

12713
20:57:13.998 --> 20:57:18.817
所以我们基本上是在付钱给这些艺术家，我们付钱给这些艺术家来创作这些NF - T。

12714
20:57:18.817 --> 20:57:23.212
然后他们就可以收回所有这些NF T的支付。

12715
20:57:23.212 --> 20:57:29.334
当然，我们还需要一个函数，令牌URI，它需要un 256。

12716
20:57:29.334 --> 20:57:35.068
这和我们的基本非函数函数是一样的这就是这个代币的实际样子。

12717
20:57:35.068 --> 20:57:36.939
让我们开始创建这个。

12718
20:57:36.939 --> 20:57:39.437
因为这些红线会把我逼疯的。

12719
20:57:39.437 --> 20:57:51.511
我们会在这里添加一些可见性，我们会让这个请求NFT公共履行随机单词，我们实际上从过去知道它将是内部令牌URI将是公共。

12720
20:57:51.511 --> 20:57:53.685
让我们构建这个请求NFT。

12721
20:57:53.685 --> 20:57:58.141
同样，要请求一个随机数，请返回EVM。

12722
20:57:58.141 --> 20:58:02.304
链，我们使用随机性，我们可以跟随博士。

12723
20:58:02.304 --> 20:58:05.383
又是链式链接，来弄清楚如何得到这个随机数。

12724
20:58:05.383 --> 20:58:11.487
既然我们知道我们将使用chain link，我们想要添加at chain link斜杠契约。

12725
20:58:11.487 --> 20:58:22.220
回到我们的代码库中，我们将在yarn中添加dash dev在chain link中添加slash合同，就像这样，这是完美的。

12726
20:58:22.220 --> 20:58:32.622
我们可以继续，我们会导入VRF消费者基v2和VRF协调器接口到我们的代码中因为我们知道我们会用到这两个。

12727
20:58:32.622 --> 20:58:37.393
如果你想从文档中复制粘贴，你完全可以到这里的暂停。

12728
20:58:37.393 --> 20:58:42.325
既然我们要使用这种消费者基础的观点，我们就想继承它。

12729
20:58:42.325 --> 20:58:52.465
我们会说随机IPFS和tf是vrf消费者基数v2这条小的，小的摆动线会在这里显示说，这似乎是覆盖。

12730
20:58:52.465 --> 20:58:54.957
我要在这里添加override。

12731
20:58:54.957 --> 20:59:00.550
这条小的摆动线会在那里停留一段时间直到我们实现剩下的函数。

12732
20:59:00.550 --> 20:59:03.338
下面我们来实现剩下的函数。

12733
20:59:03.338 --> 20:59:06.420
当然，Request NFT在这里会是公共的。

12734
20:59:06.420 --> 20:59:14.683
为了让我们请求一个NF T，我们需要调用协调器。request random words我们传递所有这些东西的地方。

12735
20:59:14.754 --> 20:59:22.539
好，让我们在构造函数中为vref协调器获取所有这些东西，让我们创建一个新的构造函数。

12736
20:59:22.539 --> 20:59:23.396
结构体的门。

12737
20:59:23.396 --> 20:59:36.206
我们会使用VRF消费者基数，两个构造函数用来创建我们的构造函数，VRF消费者基数v2需要一个地址在这里用于VRF消费者基数。

12738
20:59:36.206 --> 20:59:38.939
我们继续，我们会处理VRF。

12739
20:59:38.939 --> 20:59:41.523
或者内特·托瑞赢了两个。

12740
20:59:41.523 --> 20:59:51.513
然后我们会把这个传递给VRF消费者基础构造函数，只需要添加那个红色的曲线就可以了。

12741
20:59:51.513 --> 20:59:55.021
我们想把这个地址保存到全局变量中。

12742
20:59:55.021 --> 20:59:58.139
我们可以在上面调用request random words。

12743
20:59:58.139 --> 21:00:04.916
我们继续到上面这里，我们说I下划线var F和弦。

12744
21:00:04.916 --> 21:00:08.817
对我来说，Tor，我们将使这个不可变VRF协调器。

12745
21:00:08.817 --> 21:00:28.817
我们会说VRF v2接口，它将是私有的，不可变的，你有协调器然后在我们的构造函数中，我们会说试管协调器= VRF协调器v2接口像这样包装起来。

12746
21:00:28.817 --> 21:00:32.355
所以我们知道我们会需要这个，我们知道我们实际上会需要很多这个。

12747
21:00:32.355 --> 21:01:15.791
让我们把这些变量都加进来，我们需要协调器，我们需要一个ut64 private，不可变，I下划线订阅ID，我们需要一个bytes 32 private，不可变，I下划线gas lane，我们需要一个you int 32 private，不可变，I下划线callback gas limit，我们需要一个ut16 private常量，请求确认，我们会说它是3，然后是un32。

12748
21:01:15.791 --> 21:01:27.941
私有常量= num words，也就是1，我们会得到这条红色的弯弯曲曲的线表示它对我们的构造函数很生气。

12749
21:01:27.941 --> 21:01:32.791
让我们继续，在构造函数中加入所有不可变变量。

12750
21:01:32.791 --> 21:01:48.893
我们会从构造函数得到VRF协调器v2会得到un64订阅ID，我们会得到字节32 Gas lane，也就是键哈希，我们会得到un 256。

12751
21:01:48.893 --> 21:02:11.620
我们会做一个unt32回调气体限制，然后我们会继续做我订阅ID等于订阅ID我做气体通道等于气体通道我回调气体限制等于回调。

12752
21:02:11.756 --> 21:02:13.556
是的限制。

12753
21:02:13.756 --> 21:02:14.709
好了，设置了很多变量。

12754
21:02:15.756 --> 21:02:17.876
我们需要的链链VRF。

12755
21:02:18.756 --> 21:02:21.089
这些变量在我们的请求中。

12756
21:02:22.756 --> 21:02:31.992
对于我们的随机n (t)我们会说，我们会返回一个主动性6的请求ID。

12757
21:02:31.992 --> 21:02:41.022
在这里，我们写入request, Id这个我们刚初始化的请求Id，下划线VRF。

12758
21:02:41.022 --> 21:02:44.522
核心没有发送洋葱网络请求。

12759
21:02:44.756 --> 21:02:45.542
随机的单词。

12760
21:02:48.756 --> 21:02:50.526
在我们的抽奖中。

12761
21:02:54.756 --> 21:03:01.724
订阅ID，逗号，请求，国家。

12762
21:03:03.757 --> 21:03:05.163
回调气体限制。

12763
21:03:08.757 --> 21:03:15.069
从文档中复制粘贴或者从上一个项目中复制粘贴，随便你怎么做。

12764
21:03:15.069 --> 21:03:19.176
所以我们在这里请求这个随机的非ft。

12765
21:03:19.176 --> 21:03:30.694
事情是这样的，我们希望调用这个请求函数的人能在那里喝茶。

12766
21:03:30.757 --> 21:03:38.690
如果我们在基本的NFT中看到，当我们铸造NFT时，我们调用这个安全铸币厂它需要所有者和令牌计数器。

12767
21:03:38.757 --> 21:03:40.994
当我们请求一个随机数时，四个是非ft。

12768
21:03:41.757 --> 21:03:51.101
发生在两个交易中，对吧?我们会先请求，然后再执行，履行这将是调用，履行random words，的链式链接节点。

12769
21:03:51.101 --> 21:04:02.231
所以如果它在履行函数中，我们只执行这个安全意味着的消息，这个非函数的所有者实际上将是满足我们的随机单词的链链接节点。

12770
21:04:02.231 --> 21:04:08.721
我们不想那样，我们想做的是在请求id之间创建一个映射。

12771
21:04:08.721 --> 21:04:32.002
不管谁调用了这个，当我们调用complededrandom words，它返回完全相同的请求ID时，我们可以说，啊，你的请求ID X，你属于调用这个请求的人和团队，我们会在调用这个的人和他们的请求ID之间创建一个映射这样当我们实现随机单词时，我们可以正确地将狗分配给他们。

12772
21:04:32.002 --> 21:04:40.145
在上面，就在这下面，我称它们为VRF助手，我们将创建一个un 256的映射。

12773
21:04:40.145 --> 21:04:48.987
对于一个地址，我们将它设为public本应设为private，但我们将它设为public s下划线请求ID To sender。

12774
21:04:48.987 --> 21:05:00.958
然后当我们调用这个请求时，F T会设置请求ID为sender request ID等于message。sender。

12775
21:05:00.958 --> 21:05:17.921
现在，当链节点用随机数完成响应时，我们能做的是我们可以说地址狗主人或非ft狗主人将等于s请求ID到请求ID的发送者。

12776
21:05:17.921 --> 21:05:26.266
这样，就不是拥有狗的链接节点，而是真正调用请求的节点。

12777
21:05:26.266 --> 21:05:26.593
非功能性测试。

12778
21:05:26.758 --> 21:05:27.234
好的,很酷。

12779
21:05:29.758 --> 21:05:30.631
随机NF t。

12780
21:05:34.758 --> 21:05:38.215
这个用户的随机NF T。

12781
21:05:40.758 --> 21:05:44.805
利用这个映射，我们还需要什么?我们这里需要一个代币柜台。

12782
21:05:44.805 --> 21:05:47.699
让我们继续，我们将创建一个令牌计数器变量。

12783
21:05:47.699 --> 21:05:50.535
我们会向上滚动，创建一个新section。

12784
21:05:50.535 --> 21:05:52.979
我们说，un256。

12785
21:05:52.979 --> 21:06:06.639
然后，我们会把很多这些设为公共，这样更简单，但你可能会想设为私有使用我们之前做过的语法dos_因为这是一个存储变量，令牌计数器。

12786
21:06:06.639 --> 21:06:08.944
我们会抓取这个代币计数器。

12787
21:06:08.944 --> 21:06:11.528
我们就说你到了56岁。

12788
21:06:11.528 --> 21:06:21.417
新的令牌ID等于作为令牌计数器，现在我们有了狗的主人和令牌ID，我们可以继续并铸造这个MFT。

12789
21:06:21.417 --> 21:06:23.563
我们用安全薄荷。

12790
21:06:23.759 --> 21:06:39.177
所有者，新令牌，ID然后safe man会是弯弯曲曲的因为代码会问，这是什么?什么是安全薄荷函数?你从哪儿弄来的?我们得再从开着的齐柏林飞艇上取下来。

12791
21:06:39.177 --> 21:06:47.909
我们将继续，在open Zeppelin上输入/合约/令牌/ ERC。

12792
21:06:47.909 --> 21:06:50.009
721斜杠ERC。

12793
21:06:50.009 --> 21:06:51.209
720一个。

12794
21:06:51.209 --> 21:07:05.081
所以我们会说一个随机的空IPFS是消费者基数的Vera和ERC 721，在我们的构造函数中，就在我们的V RF消费者基数之后，我们将放入ERC 721。

12795
21:07:05.081 --> 21:07:10.678
同样的，我们需要给它一个名字和一个符号。

12796
21:07:10.678 --> 21:07:14.742
我们称其为随机IPFS NF T。

12797
21:07:14.742 --> 21:07:18.687
逗号，我们只做随机IPFS NF团队的Rin。

12798
21:07:18.687 --> 21:07:22.559
现在安全薄荷真的起作用了然后它会为此生我的气。

12799
21:07:22.559 --> 21:07:24.723
所以我要重写它，让它不再生我的气。

12800
21:07:24.759 --> 21:07:30.249
公共视图覆盖转换字符串内存。

12801
21:07:31.759 --> 21:07:32.877
弯弯曲曲的线。

12802
21:07:32.877 --> 21:07:33.436
好的,很酷。

12803
21:07:33.436 --> 21:07:33.893
太好了。

12804
21:07:34.759 --> 21:07:45.092
安全薄荷给狗主人这个新的代币ID我们说完了吗?绝对不是。

12805
21:07:45.092 --> 21:07:48.791
为什么不呢?我们不知道这个代币长什么样。

12806
21:07:48.791 --> 21:07:53.548
我们在上面设置的是我们想要让这些狗变得不同寻常。

12807
21:07:53.548 --> 21:08:05.099
那么我们如何创造这些稀有狗，我们所能做的就是创建一个机会数组一个数组来显示这些不同狗出现的不同机会。

12808
21:08:05.099 --> 21:08:15.776
下面，我们要创建一个函数它是一个公共纯函数，叫做get chance array。

12809
21:08:15.776 --> 21:08:23.612
这将返回内存中大小为3的46。

12810
21:08:23.612 --> 21:08:29.707
这个概率数组将代表不同狗的不同概率。

12811
21:08:29.760 --> 21:08:38.529
所以我们说，返回10 3100或者我们说，最大机会值。

12812
21:08:38.760 --> 21:08:41.360
在上面空变量下面。

12813
21:08:42.760 --> 21:08:48.366
内部常数为56，最大机会值为100。

12814
21:08:48.760 --> 21:08:55.343
通过创建这个数组，我们说索引0有10%的概率发生。

12815
21:08:55.343 --> 21:09:03.350
指数1发生的概率是20%因为它是30 - 10。

12816
21:09:03.350 --> 21:09:11.410
然后我们说指数2有60%的概率发生，因为它是10 + 30。

12817
21:09:11.410 --> 21:09:12.600
减去这个100。

12818
21:09:12.760 --> 21:09:16.072
这个数组确定了不同狗的比例。

12819
21:09:16.072 --> 21:09:23.705
我们说哈巴狗有10%的机会，湿婆在你身上有20%的机会，圣。

12820
21:09:23.705 --> 21:09:30.794
Bernard有70%的几率，我们会用它来给这个代币ID我们刚刚铸造了它的狗的品种。

12821
21:09:30.794 --> 21:09:35.723
我们会创建一个新函数叫Get breed from modded RNG。

12822
21:09:35.723 --> 21:09:41.507
我们调用get breed from modded RNG的原因是完全相同的。

12823
21:09:41.507 --> 21:09:42.301
在我们的抽奖中。

12824
21:09:42.301 --> 21:09:57.094
我们有一个随机数，我们说你有56个modded RNG等于0的随机单词mod最大的机会值，我们将对我们得到的任何数字mod 100。

12825
21:09:57.094 --> 21:10:00.894
这样做，我们总是会得到一个0到99之间的数。

12826
21:10:00.894 --> 21:10:05.099
如果随机单词为0，对Max Chin的值进行mod将是7。

12827
21:10:05.099 --> 21:10:07.336
也就是说我们要养只哈巴狗。

12828
21:10:07.336 --> 21:10:08.217
如果我们得到88。

12829
21:10:08.217 --> 21:10:11.450
这意味着我们会得到一个圣。

12830
21:10:11.450 --> 21:10:13.932
伯纳德，如果我们得到45。

12831
21:10:13.932 --> 21:10:17.711
我们会得到什么?没错，圣。

12832
21:10:17.711 --> 21:10:21.914
伯纳德，如果我们得到12我们就会得到湿婆。

12833
21:10:21.914 --> 21:10:28.761
如果我们通过建模这个随机单词得到的mod ID号在0到10之间。

12834
21:10:28.761 --> 21:10:32.416
10岁到30岁之间的是哈巴狗。

12835
21:10:32.416 --> 21:10:35.563
街30号至100号之间的柴犬。

12836
21:10:36.761 --> 21:10:39.367
这就是我们如何得到这些随机值的。

12837
21:10:39.761 --> 21:10:44.729
我们有这个modded RNG，我们有这个mod ID号它将在0到99之间。

12838
21:10:44.729 --> 21:10:49.094
这个函数叫Get breed from modded RNG。

12839
21:10:49.094 --> 21:10:59.837
这将使用un256 mod ID RNG将使这成为一个公共纯函数，它将返回狗的品种。

12840
21:10:59.837 --> 21:11:05.416
现在狗的品种将是一个类似于我们之前做过的抽奖状态的电子邮件。

12841
21:11:05.416 --> 21:11:12.203
我们将在顶部做这个因为这将是一个类型声明或enum。

12842
21:11:12.203 --> 21:11:16.761
读，我们会说带数字的0是给哈巴狗的。

12843
21:11:16.761 --> 21:11:20.568
这个数字就是你体内的湿婆。

12844
21:11:20.568 --> 21:11:23.796
第二个是St。

12845
21:11:23.796 --> 21:11:24.485
伯纳德。

12846
21:11:24.485 --> 21:11:27.962
我们有哈巴狗，从0到10。

12847
21:11:27.962 --> 21:11:32.262
湿婆在你身上10到30圣伯纳德30到100。

12848
21:11:32.262 --> 21:11:37.358
所以从改装的RNG公共纯返回品种。

12849
21:11:37.358 --> 21:11:46.912
所以我们会循环这个我们会说直觉上6的累积和等于0，我们会说你到56。

12850
21:11:46.912 --> 21:11:55.253
大小为3的内存机会数组等于一个机会数组。

12851
21:11:55.253 --> 21:11:59.149
我们得到了这个机会数组。

12852
21:11:59.149 --> 21:12:10.713
所以我们要创建一个小的for循环我们会说，for you到56i它将从0开始小于chance array。length。

12853
21:12:10.713 --> 21:12:14.574
我+ +在这里运行了for循环。

12854
21:12:14.574 --> 21:12:41.647
我们会说如果modded RNG大于或等于这个累积和并且modded RNG小于累积和加上机会数组加上机会数组上的任何位置，那么返回AI的品种。

12855
21:12:41.762 --> 21:12:50.580
然后在这外面，我们会说累积和加上等于I的机会数组，我们说中等橙色的等于25。

12856
21:12:50.580 --> 21:12:56.860
如果是25，那应该是湿婆在你体内，因为那是在10到30之间。

12857
21:12:56.860 --> 21:13:22.874
所以我们说，如果mod RNG，也就是25大于或等于累积和，现在是0，并且小于n, Moto G小于累积和加上I的机会数组I的机会数组将是10返回的品种I的累积和目前是0加上I的机会I是10将是10。

12858
21:13:22.874 --> 21:13:26.496
这不是真的，因为莫拉吉才25岁。

12859
21:13:26.496 --> 21:13:36.013
既然这不是真的，我们就进入第二步也就是累积和，加上等于概率，对吧?所以累积和现在等于10。

12860
21:13:36.013 --> 21:13:38.213
然后我们到达了for循环的末尾。

12861
21:13:38.213 --> 21:13:48.631
重新开始，i现在等于1，我们再试一次mod RNG大于等于累加和，这是对的，累加和等于10。

12862
21:13:48.631 --> 21:13:50.237
Mod RNG是25。

12863
21:13:50.237 --> 21:13:56.969
mod RNG小于AI的累积和加上机会re，也就是30。

12864
21:13:56.969 --> 21:14:02.143
25小于10 + 30，等于40。

12865
21:14:02.143 --> 21:14:05.096
回归人工智能的品种，这是真的。

12866
21:14:05.096 --> 21:14:09.601
所以人工智能的繁殖是正确的，人工智能目前是一个。

12867
21:14:09.601 --> 21:14:12.903
如果我们向上滚动，那确实是你体内的湿婆。

12868
21:14:12.903 --> 21:14:18.548
这就是这个函数的工作原理，它会让我们从那个建模点得到品种。

12869
21:14:18.548 --> 21:14:26.613
然后如果由于某种原因，这里发生了一些非常奇怪的事情，我们想要继续并添加一个回复，对吧，因为我们应该返回一个品种。

12870
21:14:26.613 --> 21:14:29.484
但如果我们不返回一个品种，我们就应该返回。

12871
21:14:29.484 --> 21:14:39.643
我们将在顶部创建一个新错误，随机IPFS NFT下划线下划线range out of bounds。

12872
21:14:39.764 --> 21:14:48.354
下面这个，我们会说如果因为某种原因你没有返回任何东西，只要做一个revert random IPFS NFT range out of bounds。

12873
21:14:48.354 --> 21:14:50.321
现在我们有了这个函数。

12874
21:14:50.321 --> 21:14:53.264
好了，现在我们可以从modded RNG中获取摘要。

12875
21:14:53.264 --> 21:14:55.893
所以在我们的实现随机单词函数中。

12876
21:14:55.893 --> 21:15:16.485
我们继续，我们会说，我们取消注释这里会说，breed, dog breed，等于get breed for modded RNG传递modded RNG，然后把这个安全薄荷移到下面获取狗的繁殖者这样我们就可以薄荷并同时添加狗的繁殖。

12877
21:15:16.485 --> 21:15:22.564
所以我们要继续在这里安全地薄荷。

12878
21:15:23.764 --> 21:15:34.002
现在我们可以做一些事情来设置这个狗的品种，我们在狗的品种和令牌URI之间创建一个映射，然后让它反映在这个令牌URI函数中。

12879
21:15:34.002 --> 21:15:42.674
或者我们可以调用一个函数叫做Set令牌URI和openzeppelin ERC 721你必须自己设置这个令牌你的眼睛函数。

12880
21:15:42.674 --> 21:15:47.525
然而，在开放的齐柏林代码中有一个扩展叫做ERC。

12881
21:15:47.525 --> 21:15:51.626
721 Uri存储和这个版本的ERC。

12882
21:15:51.626 --> 21:15:57.979
721附带了一个叫做Set token URI的函数，我们可以调用Set token URI。

12883
21:15:57.979 --> 21:16:03.982
这将自动更新那个令牌令牌URI为你设置的任何值。

12884
21:16:03.982 --> 21:16:09.684
我们将在契约中使用这个扩展集令牌URI。

12885
21:16:09.764 --> 21:16:25.385
我们这样做的方式不是用令牌ERC 721 Year C 721 soul会用令牌ERC 721 /扩展/你的C 721 /你的存储。

12886
21:16:25.385 --> 21:16:26.522
这是所有。

12887
21:16:26.522 --> 21:16:33.265
随机IPFS是ERC 721你的大米储存。

12888
21:16:33.265 --> 21:16:40.092
现在最酷的是，我们的构造函数仍然只使用ERC。

12889
21:16:40.092 --> 21:16:45.641
因为ERC 721 Uri存储扩展了ERC 721。

12890
21:16:45.641 --> 21:16:52.493
这个契约附带了一些附加函数，比如set token URI。

12891
21:16:52.493 --> 21:16:59.542
就在safe的意思之后，我们会调用set令牌URI带有这个新项目ID。

12892
21:16:59.542 --> 21:17:12.420
然后我们会给它那个breedtoken URI，我们会在这里给它一个字符串它与我们刚从狗的品种得到的任何品种相关。

12893
21:17:12.420 --> 21:17:30.490
现在，要做到这一点，我们可以在顶部我们的非ft变量，我们可以创建一个字符串数组，内部，Alt S dog token，你的眼睛，我们要让这个常量它就是我们创建的所有这些字符串的数组。

12894
21:17:30.490 --> 21:17:34.288
但在我们的代码中，我们想让这个变量更多一点。

12895
21:17:34.288 --> 21:17:36.383
我们要把它参数化。

12896
21:17:36.383 --> 21:17:37.939
这正是我们要做的。

12897
21:17:37.939 --> 21:17:58.249
我们会创建这个字符串数组，内部s下划线狗牌，你的眼睛，这将是这些url的列表这些url指向这样的东西，我们会在代码中做这个这样当我们上传任何图片到IPFS时我们就可以上传这个s狗牌。

12898
21:17:58.249 --> 21:18:15.143
在构造函数中，我们会引入另一个形参叫做一个大小为3的字符串，memory dog token，我们会把它作为构造函数形参传递，这些不同的dog token。

12899
21:18:15.143 --> 21:18:19.352
我们要传递给它这个狗标记的列表。

12900
21:18:19.352 --> 21:18:22.749
当然，0将是哈巴狗的令牌URI。

12901
21:18:22.749 --> 21:18:25.946
一个是你体内的湿婆，第二个当然是圣。

12902
21:18:25.946 --> 21:18:26.208
伯纳德。

12903
21:18:26.208 --> 21:18:37.119
我们会把这个狗标记你的眼睛的列表传给它，然后从我们创建的列表中往下到set标记你的眼睛。

12904
21:18:37.119 --> 21:18:52.314
我们会设置这个令牌的URI基于那个数组的UN 256版本的那个品种将这个狗的品种转换回你和256来获取它的索引。

12905
21:18:52.314 --> 21:19:02.536
有了这个，我们就有了一种方法，通过编程得到一个可证明的随机非函数对于不同的非函数T具有不同的随机性。

12906
21:19:02.536 --> 21:19:14.007
现在，让我们回到我们的小评论，我们在这里做的小评论，有限的非ft，我们触发一个链链接或VRF。

12907
21:19:14.007 --> 21:19:17.750
要打随机数，我们就得把稀有物品和铸币都弄下来。

12908
21:19:17.750 --> 21:19:18.242
太棒了。

12909
21:19:18.242 --> 21:19:20.580
好吧，不过我们没有这部分。

12910
21:19:20.766 --> 21:19:25.454
用户必须支付给Minton NF T，合同的所有者可以收回土地。

12911
21:19:25.454 --> 21:19:28.952
这是我们之前做过的，应该很熟悉。

12912
21:19:28.952 --> 21:19:32.516
回到我们的requestnft函数，我们会让它成为公共支付。

12913
21:19:32.516 --> 21:19:48.648
我们只需要说如果message。value小于某个mint fee，我们回到构造函数，我们会创建一个mint fee, int 256 mint fee。

12914
21:19:48.767 --> 21:19:55.155
然后我们会在256内部I下划线mint fee，我们会让它是不可变的。

12915
21:19:55.155 --> 21:19:58.885
然后我们会说I'm intervention = mint fee。

12916
21:19:58.885 --> 21:20:22.619
如果message of value小于mint fee，你已经知道我们会做一个回复，需要更多eath sent，我们会创建一个新的air叫做，需要更多eath sent实际上我们会做air random IPFS和，下面加上，下面加上，需要更多II sent，复制这个，粘贴到这里，好了。

12917
21:20:22.619 --> 21:20:26.889
现在只要加上这一行，这就是一个可支付函数。

12918
21:20:26.889 --> 21:20:32.444
人们需要支付一些铸币费来铸币他们的随机NF t。

12919
21:20:32.444 --> 21:20:36.100
现在我们还需要一种让所有者提款的方法。

12920
21:20:36.100 --> 21:20:38.258
我们往下滚动一点。

12921
21:20:38.258 --> 21:20:44.077
向下滚动到这里，createfunction withdraw，这是公共的。

12922
21:20:44.077 --> 21:20:46.042
我们只希望所有者这样做。

12923
21:20:46.042 --> 21:20:53.403
我们可以创建修饰符，一个修饰符只有owner，或者我们可以使用openzeppelin。

12924
21:20:53.403 --> 21:21:07.947
同样，openzeppelin也带有一些访问代码，或者说其中一个是这个可拥有代码，在这里，它已经为我们提供了唯一的所有者修饰符，我们将继续导入它。

12925
21:21:07.947 --> 21:21:18.905
我们会输入import at openzeppelin /合同/ access / owable。som，我们会说合同随机IPFS。

12926
21:21:18.905 --> 21:21:22.629
如果t是这个，这个是可拥有的。

12927
21:21:22.629 --> 21:21:26.315
然后我们让取款函数只有所有者。

12928
21:21:26.315 --> 21:21:31.241
因此，无论谁部署了这个合同，都将被设置为所有者，这是我们想要的。

12929
21:21:31.241 --> 21:21:36.155
在这里，和我们做的一样，我们做u和256。

12930
21:21:36.155 --> 21:21:40.686
金额等于地址这个点余额。

12931
21:21:40.686 --> 21:21:55.452
然后我们会写success，逗号= payable, message。sender，但callvalue将是一个mount然后我们将调用什么都不调用。

12932
21:21:55.452 --> 21:21:59.208
然后我们会说if not success。

12933
21:21:59.208 --> 21:22:09.383
我们会用transfer failed进行恢复，然后在上面，我们会用error transfer failed。

12934
21:22:09.383 --> 21:22:17.664
我要复制得快一点，像这样然后返回到传输失败粘贴到这里。

12935
21:22:17.664 --> 21:22:19.948
我们将恢复随机IPFS。

12936
21:22:19.948 --> 21:22:26.393
如果转账失败，那就太好了，现在我们有了取款功能，让人们可以在这里为艺术品付款。

12937
21:22:26.393 --> 21:22:40.678
现在我们不再需要这个令牌URI了，因为当我们调用set令牌URI时，它会为我们设置令牌URI因为在ERC 721 URI存储中已经有了这个函数。

12938
21:22:40.678 --> 21:22:46.218
我们的契约已经有令牌URI函数了，我们不需要自己显式地设置它。

12939
21:22:46.218 --> 21:22:48.668
但我们需要显式地设置一些其他的。

12940
21:22:48.768 --> 21:23:19.311
我们需要function get意味着fee将是一个公共视图转到36转我的意思是fee将需要function get dog token你的眼睛，你到36 index，这将是一个公共视图它将返回字符串内存返回s下划线狗token你的眼睛索引将需要function get token counter。

12941
21:23:19.311 --> 21:23:27.824
这将是一个公共视图，把你变成56返回的下划线令牌计数器。

12942
21:23:27.824 --> 21:23:30.894
好了，我们刚刚写了很多代码。

12943
21:23:30.894 --> 21:23:35.118
当然，就像我们之前教过的，我们还需要一些事件。

12944
21:23:35.118 --> 21:23:40.107
当我们请求一个NF T时，我们会触发一个事件。

12945
21:23:40.107 --> 21:23:45.644
因此，我们将省略nft请求，然后将请求传递给它。

12946
21:23:45.644 --> 21:23:47.456
消息点发送方中的ID。

12947
21:23:47.456 --> 21:23:54.010
所以在上面会说事件nft请求。

12948
21:23:54.010 --> 21:24:01.785
pet，取一个un256索引请求ID，然后是地址请求器。

12949
21:24:01.785 --> 21:24:07.126
然后我们还会为ntf minted创建一个事件当它最终被minted时。

12950
21:24:07.126 --> 21:24:13.096
它需要一个品种，狗的品种，和一个地址，导师。

12951
21:24:13.096 --> 21:24:19.644
所以写下来，当我们完成时，我们将发射非ft。

12952
21:24:19.644 --> 21:24:20.519
铸造。

12953
21:24:20.769 --> 21:24:29.621
它会选择狗的品种，然后是狗的主人。

12954
21:24:29.769 --> 21:24:33.236
我们刚刚写了很多代码。

12955
21:24:34.769 --> 21:24:38.680
看看我们是否可以用H H编译，或者yarn Hardhead编译。

12956
21:24:38.680 --> 21:24:41.479
哇，看起来我们继续编译了它。

12957
21:24:41.479 --> 21:24:42.382
这太棒了。

12958
21:24:42.382 --> 21:24:44.575
现在所有的代码看起来都很好。

12959
21:24:44.770 --> 21:24:47.837
现在可能是休息一下的好时候了，我们刚刚写了很多代码。

12960
21:24:47.837 --> 21:24:51.822
复习一下我们刚刚讲过的内容可能会更好。

12961
21:24:51.822 --> 21:25:04.820
很多这是熟悉的，但它仍然是真的很好，重做一些东西，真正得到肌肉记忆和这些信用，一个NFT合同，当你铸造，其中一个NFT，你将得到一个湿婆在你或圣。

12962
21:25:04.820 --> 21:25:08.820
伯纳德，基于某种稀有性，而哈巴狗真的很罕见。

12963
21:25:08.820 --> 21:25:11.166
在圣。

12964
21:25:11.166 --> 21:25:12.753
伯纳德很普通。

12965
21:25:12.753 --> 21:25:22.689
我们的方法是，我们有一个请求NF - t函数，人们需要付费调用它向一个链连接节点发出一个请求以获得一个随机数。

12966
21:25:22.689 --> 21:25:32.254
一旦我们的契约得到了随机数使用一个机会数组来找出我们将使用哪个NF T来进行铸造。

12967
21:25:32.254 --> 21:25:34.735
我们会相应地设置令牌URI。

12968
21:25:34.735 --> 21:25:40.693
我们会把图像数据存储在IPFS上，这个我们还没做过。

12969
21:25:40.770 --> 21:25:45.603
这里的deploy函数将是合约中有趣的部分。

12970
21:25:45.603 --> 21:25:53.399
但是因为我们已经讲了这么多了，如果你们想休息一下喘口气，然后再回来，我鼓励你们这样做我们学到了很多。

12971
21:25:53.399 --> 21:25:55.140
我们写了很多坚固性代码。

12972
21:25:55.140 --> 21:25:58.597
快去喘口气吧，我们一会儿见。

12973
21:25:58.597 --> 21:26:11.208
我们继续，在这里创建一个新的deploy，进入ploy，随机ipfs。

12974
21:26:11.208 --> 21:26:11.558
js。

12975
21:26:11.558 --> 21:26:19.512
这和我们之前做过的彩票合约非常相似。

12976
21:26:19.512 --> 21:26:28.347
我们可以从这里的代码中复制一些样板，我们需要所有这些，我们复制这个，用一个小花括号结束然后，我们就得到了一个样板。

12977
21:26:28.347 --> 21:26:32.032
现在，因为我们在使用chainlink，在这里，我们将再次使用mock。

12978
21:26:32.032 --> 21:26:37.705
返回new file 00, deploymocks。js。

12979
21:26:37.705 --> 21:26:43.908
如果你愿意，你可以从前面的部分复制粘贴我们用raffle / lottery做的。

12980
21:26:43.908 --> 21:26:51.192
因为我们将在这里做完全相同的事情，我将继续，暂停，你可以从以前的项目中复制粘贴。

12981
21:26:51.192 --> 21:26:57.371
或者，如果你愿意，你可以到与这门课相关的GitHub回购，到部署。

12982
21:26:57.371 --> 21:27:00.121
然后从这里获取部署模拟。

12983
21:27:00.121 --> 21:27:08.658
如果你从GitHub回购中抓取，我们还将使用一个模拟v3聚合器，但我还不打算把那部分添加进去，因为我们还不需要它。

12984
21:27:08.658 --> 21:27:10.721
现在请暂停视频。

12985
21:27:10.721 --> 21:27:16.703
复制并粘贴VRF协调器模拟或暂停视频并尝试自己编写模拟代码。

12986
21:27:16.771 --> 21:27:17.278
好了,好了。

12987
21:27:19.771 --> 21:27:26.187
集中ID network。config。chain ID，因为我们需要决定我们是否在开发链上。

12988
21:27:26.187 --> 21:27:48.548
和我们之前做的一样我们会说如果开发链包含network。name，我们会说const VRF coordinator, B to mock goes await ethers。get contract VRF。

12989
21:27:48.548 --> 21:27:49.103
核心。

12990
21:27:49.103 --> 21:28:03.533
模拟的名字类似于抽奖我们会说，让VRF协调Tor v两个地址，相同，VRF协调器v两个地址等于VRF。

12991
21:28:03.533 --> 21:28:12.535
协调器v2mach mock那个地址然后我们要创建一个订阅就像我们对彩票做的一样。

12992
21:28:12.535 --> 21:28:22.755
我们会说const TX = weight VRF coordinate tore V to mock。create subscription。

12993
21:28:22.755 --> 21:28:30.216
然后我们会写const TX receipt = weight, TX。

12994
21:28:30.216 --> 21:28:35.411
我们会从这里获取子ID和我们在彩票部分做的完全一样。

12995
21:28:35.411 --> 21:28:49.272
我们需要那个子ID通过subsubscription ID我们会说，subscription ID = TX receipt。events, 0。

12996
21:28:49.272 --> 21:28:52.147
args找到了某人。

12997
21:28:52.147 --> 21:29:15.837
这就是我们在开发链上所做的，如果VRF坐标V到地址等于链ID点VRF坐标的网络配置或者B到那订阅ID等于网络配置。

12998
21:29:15.837 --> 21:29:18.689
链ID。订阅ID。

12999
21:29:18.689 --> 21:29:19.475
完美的。

13000
21:29:19.772 --> 21:29:23.518
然后我们会再次检查我们的助手安全帽配置。

13001
21:29:23.772 --> 21:29:27.392
Rigby同时拥有VRF协调器v2。

13002
21:29:28.772 --> 21:29:30.403
需要一个订阅ID。

13003
21:29:31.772 --> 21:29:35.209
订阅ID来自我们过去的彩票项目。

13004
21:29:35.209 --> 21:29:42.706
但是我们可以走到V或者F。链链，我们可以走到vrf，这个链链可以确保我们在溜冰场B上。

13005
21:29:42.773 --> 21:29:44.042
让我们看看我们的其他订阅。

13006
21:29:44.773 --> 21:29:46.042
我们这里有一个。

13007
21:29:49.773 --> 21:29:50.106
里格比。

13008
21:29:53.773 --> 21:30:01.789
链，合同地址，使用回忆，看到更多参数，特别是Rigby，确保这些都是正确的。

13009
21:30:01.789 --> 21:30:09.773
我们这里有订阅，我们很快会添加一个新的消费者一旦我们部署了这个契约如果我们要使用RankBrain。

13010
21:30:09.773 --> 21:30:14.740
我们在这里用连字符写一个小log。

13011
21:30:14.740 --> 21:30:20.616
我们现在会得到args =，我们会在这里做参数。

13012
21:30:20.616 --> 21:30:30.027
我们需要什么，我们需要协调员订阅，汽油回调，地址，狗，你的狗token，你的眼睛和管理费。

13013
21:30:30.027 --> 21:30:37.966
因此，我们将需要VRF协调器来处理订阅ID。

13014
21:30:37.966 --> 21:30:41.805
我们还需要网络配置。

13015
21:30:41.805 --> 21:30:44.288
链ID点气道。

13016
21:30:44.288 --> 21:31:01.423
我们需要网络配置链ID点意味着费用，然后我们将留下工作配置链ID点回调气体限制正确的顺序?是的。

13017
21:31:01.423 --> 21:31:12.553
然后我们需要狗的记号你的眼睛和铸币费。

13018
21:31:12.773 --> 21:31:17.215
现在我们没有什么，我们没有标记你眼睛的数组。

13019
21:31:17.215 --> 21:31:19.330
我们有几种方法可以做到这一点。

13020
21:31:19.330 --> 21:31:33.515
如果你去到与此相关的GitHub回购，去部署，我们实际上做了随机，哦，3在get这里，有一个部分我们会自动说，好，很好的令牌，你上升的就是这三个。

13021
21:31:33.515 --> 21:31:42.015
如果我们能复制粘贴这些cd到IPFS上，这些是更好的有IPFS作为图像的cd。

13022
21:31:42.015 --> 21:31:43.466
我们可以看到它们像这样。

13023
21:31:43.466 --> 21:31:45.937
所以我们可以用我已经部署好的东西。

13024
21:31:45.937 --> 21:31:56.248
如果你想这样做，你绝对百分之百可以，或者我们可以做的是我们可以学习通过编程上传我们自己的图像到IPFS。

13025
21:31:56.248 --> 21:31:57.942
听起来酷多了。

13026
21:31:57.942 --> 21:31:59.974
我们来做一下。

13027
21:31:59.974 --> 21:32:03.940
现在我想让你们做的是，如果你们想用你们自己的图像来做这个，请随意。

13028
21:32:03.940 --> 21:32:09.601
但如果你想跟着我们，那我们就去Hardhead NFT FCC回购。

13029
21:32:09.601 --> 21:32:14.921
我们将从他那里随机获取这些NF - T。

13030
21:32:14.921 --> 21:32:16.986
所以你能做的就是到这里来。

13031
21:32:16.986 --> 21:32:24.329
我们可以继续，右键点击保存图像Jas，我们将它保存到下载，我们创建一个新文件夹，命名为images。

13032
21:32:24.329 --> 21:32:34.621
图像会创建一个名为random的新文件夹，然后我们可以把它拉到这里，命名为random NFT。

13033
21:32:34.621 --> 21:32:38.349
这是png格式的。

13034
21:32:38.349 --> 21:32:41.174
我们可以对所有的图像这样做。

13035
21:32:41.174 --> 21:32:45.574
现在在我们的图片标签中，我们有你和圣伯纳德的哈巴狗船。

13036
21:32:45.574 --> 21:32:47.218
这是局部的。

13037
21:32:47.218 --> 21:32:49.503
但我们想把这些上传到IPFS。

13038
21:32:49.503 --> 21:32:53.070
我们想以一种任何人都能钉住它们并使用它们的方式上传它们。

13039
21:32:53.070 --> 21:33:02.619
在我们做这些之前，在我们得到部署契约的参数之前，我们需要得到图像的IPFS散列。

13040
21:33:02.619 --> 21:33:06.332
有几种方法可以做到这一点。

13041
21:33:06.332 --> 21:33:14.282
我们用我们自己的IPFS节点来做，我已经向你们展示了如何手动做，我们也可以通过编程来做。

13042
21:33:14.282 --> 21:33:16.041
现在，我不会告诉你们怎么做。

13043
21:33:16.041 --> 21:33:24.068
但是，如果您仔细阅读IPFS文档，您实际上可以通过命令行甚至通过一些脚本了解如何执行该操作。

13044
21:33:24.068 --> 21:33:27.375
但是，如果我们是唯一运行这个的节点，这就有点集中了。

13045
21:33:27.375 --> 21:33:36.694
理想情况下，我们希望这些图像和这些标记你的眼睛这个和这个标记元数据在我们自己的IPFS节点和其他一些节点上。

13046
21:33:36.775 --> 21:33:44.842
我们看待这个问题的第二种方式是使用Hinata Hinata是一种服务，基本上你只要付钱就能帮你固定NF - T。

13047
21:33:44.842 --> 21:33:48.397
这就是我们要看的。

13048
21:33:48.397 --> 21:33:58.775
现在，binotto的问题当然是，我们只是付钱给一个单一的中心实体去锁定我们的数据，我们有点相信他们真的会锁定数据，他们不会下降。

13049
21:33:58.775 --> 21:34:04.724
最后一种获取数据的方法叫做nnf T导存储。

13050
21:34:04.775 --> 21:34:15.709
如果T点存储使用后端文件币网络来固定我们的数据，那么filecoin就是一个专门用于固定IPFS数据和存储分散数据的区块链。

13051
21:34:15.709 --> 21:34:18.742
对我们来说，这个过程有点复杂。

13052
21:34:18.742 --> 21:34:21.152
但是非ft点存储让它变得非常非常简单。

13053
21:34:21.152 --> 21:34:25.108
现在，我们不打算在这个视频中使用非函数存储器。

13054
21:34:25.108 --> 21:34:37.759
然而，如果你想了解NFT T点存储，为了把你的数据放在与这门课程相关的GitHub repo中，我们有一个脚本，可以将你的代码上传到NFT存储称为utils文件夹，上传到NFT。

13055
21:34:37.759 --> 21:34:38.134
存储。

13056
21:34:38.134 --> 21:34:45.877
如果你想尝试一下，我建议你使用NF T点存储将是保持我们数据最持久的方法之一。

13057
21:34:45.877 --> 21:34:54.398
但将您自己的数据上传到您自己的IPFS节点仍然很好，我们已经学习了如何手动操作，至少让另一个人也固定您的数据。

13058
21:34:54.398 --> 21:35:01.309
理想情况下，一个完整的去中心化网络，将您的数据固定在一起，这就是NFS存储所能帮助您做到的。

13059
21:35:01.309 --> 21:35:06.088
但是现在，对于我们来说，我们只需要用皮纳塔来保持这个视频的美观和简单。

13060
21:35:06.088 --> 21:35:14.534
然后上传上传我们的元数据和代币，你的眼睛到IPFS会给我们这个代币列表你的眼睛给我们的三只狗。

13061
21:35:14.534 --> 21:35:27.338
在上面这里，我们会做一点如果我们会说if process。env。upload to pinata = true，对，我们会像这样使用字符串true。

13062
21:35:27.338 --> 21:35:29.650
然后上传到皮纳塔。

13063
21:35:29.776 --> 21:35:33.066
在上面这里我们会说，让我们标记你的眼睛。

13064
21:35:33.776 --> 21:35:38.242
token your eyes = await, handle token your eyes。

13065
21:35:38.242 --> 21:35:49.407
我们会创建一个叫handle token your eyes的函数，它会把我们的代码上传到下面的pinata里面，我们会创建一个叫async的新函数。

13066
21:35:49.407 --> 21:35:50.354
函数。

13067
21:35:50.354 --> 21:35:53.061
我们会标记你的眼睛。

13068
21:35:53.061 --> 21:36:08.582
这将返回一个令牌数组你的眼睛让我们上传到智能合约，我们会说token，你的眼睛等于这个然后在底部，我们会说return token你的上升，我们会返回这个数组。

13069
21:36:08.582 --> 21:36:14.204
现在我们需要做两件事，我们都需要在IPFS中存储图像。

13070
21:36:14.204 --> 21:36:18.087
然后我们需要将元数据存储在IPFS中。

13071
21:36:18.087 --> 21:36:22.294
首先，我们要创建一个store images函数。

13072
21:36:22.294 --> 21:36:24.577
这就是我们要用到效用的地方。

13073
21:36:24.577 --> 21:36:37.099
我们会在这里创建一个新文件夹，我们会创建一个名为new file的文件Upload to pinata。js，我们会把上传到pinata的所有代码都添加到这里。

13074
21:36:37.099 --> 21:36:46.015
因为，pinata是一项服务我们将使用它来为我们固定数据并与pinata一起工作，我们可以继续，免费尝试。

13075
21:36:46.015 --> 21:36:56.406
我们可以创建自己的应用程序。

13076
21:36:56.777 --> 21:36:58.088
我们可以开始了。

13077
21:37:00.777 --> 21:37:03.495
IPFS节点，因为这就是皮纳塔的本质。

13078
21:37:03.777 --> 21:37:06.562
只是一个IPFS节点，由别人运行。

13079
21:37:07.777 --> 21:37:10.443
你能帮我们固定这些数据吗。

13080
21:37:11.777 --> 21:37:24.234
我们可以像IPFS节点一样点击上传Cid然后放入一些IPFS文件的散列，pinata会为我们固定它，我们也可以像IPFS节点一样上传一个文件或文件夹。

13081
21:37:24.234 --> 21:37:30.838
但对我们来说，我们要把这个空着因为我们要用编程的方式来做，因为我们是工程师。

13082
21:37:30.838 --> 21:37:36.156
我们能做的是打开我们的配置文件，打开API键和文档。

13083
21:37:36.156 --> 21:37:40.341
文档几乎包含了我们开始所需的所有内容。

13084
21:37:40.341 --> 21:37:52.134
如果你向下滚动到pinata Node js SDK，这基本上是我们将要使用的，他们已经为我们创建了一个SDK我们可以使用，我们将继续安装这个pinata SDK。

13085
21:37:52.134 --> 21:38:13.199
他们使用NPM，安装破折号来保存，我们将继续使用yarn，在pinata dash SDK中添加破折号dev，他们有所有这些不同的端点，我们可以调用pin数据，我们将把文件pin到IPFS，因为我们要上传文件，也要把JSON固定到IPFS。

13086
21:38:13.199 --> 21:38:18.019
因为JSON是元数据，而file是实际图像。

13087
21:38:18.019 --> 21:38:21.896
如果你点它，它甚至会给你这里SDK的输出。

13088
21:38:21.896 --> 21:38:26.578
回到代码中，现在我们已经下载了这个，我们可以开始创建这个。

13089
21:38:26.578 --> 21:38:40.444
我们会说const pinata SDK = require at pinata slash SDK，然后我们会创建一个async函数store images，它会取一个图像文件路径。

13090
21:38:40.444 --> 21:38:50.611
我们将使用这个函数将我们的图像传递给它，随机的n (t)个文件路径，我们会让它把所有东西都存储在那个文件夹里来帮助我们处理路径。

13091
21:38:50.611 --> 21:38:53.896
我们还会安装这个路径包。

13092
21:38:53.896 --> 21:39:00.970
我们要做yarn，添加dash dev path，我们也要用Fs而不是Fs extra。

13093
21:39:00.970 --> 21:39:04.187
现在它已经建立了，我们会说const。

13094
21:39:04.187 --> 21:39:06.236
Path = require Path。

13095
21:39:06.236 --> 21:39:17.105
在这里，我们会说const, full images, path = path。resolve, images file path。

13096
21:39:17.105 --> 21:39:26.988
如果我们给出。/ images， / random, NF T之类的，这就会给你路径的全部输出。

13097
21:39:26.988 --> 21:39:34.049
我们得到了完整的图像路径，然后我们会说，我们会通过const files = Fs来获取这些文件。

13098
21:39:34.049 --> 21:39:44.261
我们会抓取s我们会说const Fs = require Fs来读取这里的文件，读取DirSync。

13099
21:39:44.261 --> 21:39:52.965
我们只需要读取整个目录然后取回文件来读取DirSync完整图像路径。

13100
21:39:52.965 --> 21:40:03.680
为了测试这个是否有效，我们要做的是我们要做module。exports， = store images。

13101
21:40:03.779 --> 21:40:10.985
然后回到部署脚本，我们可以注释掉args。

13102
21:40:10.985 --> 21:40:22.677
我们可以输入import const, store images = require。。/ utils / upload to pinata。

13103
21:40:22.779 --> 21:40:44.240
在这个脚本中，我们可以做一点，我们可以调用这个我们可以说await，或者images，然后我们会传递我们的images location，也许在最上面，甚至在函数的外面，我们会说const images location =。/ images / random和ft。

13104
21:40:44.240 --> 21:40:47.624
我们会做一个这样的权重存储图像。

13105
21:40:47.779 --> 21:40:50.712
我们应该能运行硬头部署。

13106
21:40:51.779 --> 21:41:01.379
这个deploy的一些标签，模块，点导出，点标签等于，我们说all random IPFS。

13107
21:41:01.379 --> 21:41:15.843
然后主要，我们做Hardhead部署的破折号标签，随机IPFS也会做模拟相信，我需要在这里创建一个测试文件夹，新文件夹测试。

13108
21:41:15.843 --> 21:41:20.980
我们需要在这里添加VF协调器v2 Mock。

13109
21:41:20.980 --> 21:41:26.075
我只是复制粘贴VRF协调器v2 Mock从我们的抽奖项目。

13110
21:41:26.075 --> 21:41:31.576
请随意暂停，复制，粘贴，或再次，一切都可以在GitHub上。

13111
21:41:31.576 --> 21:41:33.240
我们再试一次。

13112
21:41:33.240 --> 21:41:40.698
标签，随机IPFS，和模拟，然后，好的，模拟部署和完美的pug。png ship任何png St。

13113
21:41:40.780 --> 21:41:41.565
伯纳德PNG。

13114
21:41:41.565 --> 21:41:41.993
太好了。

13115
21:41:44.780 --> 21:41:45.113
在这里。

13116
21:41:49.780 --> 21:41:50.430
皮纳塔服务器。

13117
21:41:50.430 --> 21:41:52.180
所以我们说响应等于这个。

13118
21:41:52.780 --> 21:42:18.435
比如对于files中的每个文件索引对于这里的每个文件，我们会说const readable stream for file = Fs。create read stream of the full images path斜杠files of file index。

13119
21:42:18.435 --> 21:42:22.551
这条线是干什么的?我们正在创建一个读流。

13120
21:42:22.551 --> 21:42:32.380
因为这是一个图像文件，它的工作原理和推送数据不完全一样，对吧?我们必须创建一个流来传输这些图像中的所有数据。

13121
21:42:32.380 --> 21:42:47.541
因为这些图像，虽然只是一个可爱的小图像，它们其实是一个很大的文件里面有这么多字节和数据，然后我们会通过try发送它，我们会说const response = await。

13122
21:42:47.541 --> 21:42:50.652
我们要在这里做皮纳塔。

13123
21:42:50.780 --> 21:42:55.360
如果我们再去皮纳塔码头，这里有一些关于钥匙的东西。

13124
21:42:55.360 --> 21:43:06.329
我们能做的是，如果你去你的个人资料，去API密钥，我们可以创建一个新密钥，我们说这是一个管理密钥，为什么不呢?我们给它所有的固定访问权。

13125
21:43:06.329 --> 21:43:09.340
也许我们可以给它这个，也许我们可以给它一切，你想做什么都行。

13126
21:43:09.340 --> 21:43:14.638
然后我们把这个叫做hard hat, Free Code Camp key, create key。

13127
21:43:14.638 --> 21:43:20.076
现在我们要抓取这些并把它们放到。env中。

13128
21:43:20.076 --> 21:43:24.158
API键，复制到这里。

13129
21:43:24.158 --> 21:43:25.797
打开。env。

13130
21:43:25.797 --> 21:43:29.628
我们就叫它皮纳塔吧。

13131
21:43:29.628 --> 21:43:33.543
data API键等于那个键。

13132
21:43:33.781 --> 21:43:40.495
我们会获取API秘密，然后说皮纳塔API秘密等于那个密钥。

13133
21:43:40.495 --> 21:43:43.329
我们不需要这么大的代币。

13134
21:43:43.329 --> 21:43:44.881
但如果你想要，你绝对可以拥有它。

13135
21:43:44.881 --> 21:44:00.727
然后在store image之外，我们会说const pinata API key = price意思是，你需要那个pinata API key吗?然后不能皮纳塔。

13136
21:44:00.727 --> 21:44:07.813
API秘密等于工艺点E和V点皮纳塔API秘密。

13137
21:44:07.813 --> 21:44:10.892
然后我们说const。

13138
21:44:10.892 --> 21:44:16.447
Pinata = Pinata s。

13139
21:44:16.447 --> 21:44:22.053
DK的皮纳塔API键逗号，皮纳塔API。

13140
21:44:22.053 --> 21:44:32.138
为了和皮纳塔一起工作，我们需要传递一个API密钥和API秘密，这样皮纳塔就知道是我们在和他们一起工作。

13141
21:44:32.138 --> 21:44:52.351
一旦我们初始化了这个pinata，我们就可以运行pinata。然后做一些pinata的事情，我们想用这个pin文件到IPFS，它接受这个可读流，这就是为什么我们创建了那个可读字符串，所以pinata那个pin文件到IPFS。

13142
21:44:52.351 --> 21:44:55.161
可读流或文件的。

13143
21:44:55.161 --> 21:45:01.126
然后我们把这个响应推到我们的响应数组中。

13144
21:45:01.126 --> 21:45:03.915
因此我们写上responsresponsdot。push response。

13145
21:45:03.915 --> 21:45:08.489
然后我们会捕捉错误，以防这里出现奇怪的错误。

13146
21:45:08.489 --> 21:45:15.104
我们写入console。log error，然后我们会返回响应和文件。

13147
21:45:15.104 --> 21:45:21.848
我们会返回推入这些文件的所有响应，然后是文件。

13148
21:45:21.848 --> 21:45:26.264
现在，在这个点上，我们可以继续，自己测试一下。

13149
21:45:26.264 --> 21:45:27.549
这里有这个。

13150
21:45:27.549 --> 21:45:37.985
如果我们回到deploy，在顶部，我们有这个If process。E和V。upload to Niada = true，在这里做这些，上传到IPFS。

13151
21:45:37.985 --> 21:45:49.988
最后我们要做的，当然是require。env。config，这样我们就能拉入。env文件。

13152
21:45:49.988 --> 21:45:53.273
下面这里，我们只是做一个权重存储图像。

13153
21:45:53.273 --> 21:45:58.273
如果我们这样运行它，它会继续存储图像。

13154
21:45:58.273 --> 21:46:05.232
让我们运行相同的命令，或者部署随机IPFS和MOX来运行这个store images命令。

13155
21:46:05.232 --> 21:46:11.945
如果我们回到我们的皮纳塔，在我们运行它之后，我们可以看到上传的代码。

13156
21:46:11.945 --> 21:46:21.058
如果我们现在运行，脚本加载IPFS它会给我们一点延迟，因为它需要上传这些大图文件到IPFS。

13157
21:46:21.058 --> 21:46:22.610
或者更准确地说。

13158
21:46:22.783 --> 21:46:25.878
皮纳塔，我选上传到nada。

13159
21:46:27.783 --> 21:46:34.340
控制台点日志，工作在文件索引，做Excel。

13160
21:46:35.783 --> 21:46:36.021
太好了。

13161
21:46:36.021 --> 21:46:37.640
看起来它已经跑完了。

13162
21:46:38.783 --> 21:46:47.356
我们的项目，我们做了一点刷新，我们看到我们的三个文件已经上传，我们看到他们每个都有自己的CID。

13163
21:46:47.356 --> 21:46:51.618
现在，如果您愿意，您可以继续复制CID。

13164
21:46:51.783 --> 21:46:58.928
如果你有IPFS节点，你能做的是，我们能做的是从IPFS导入。

13165
21:46:58.928 --> 21:47:00.298
粘贴到这里。

13166
21:47:00.298 --> 21:47:06.572
我们可以确切地说这是什么，IPFS。

13167
21:47:06.572 --> 21:47:08.150
伯纳德叫圣。

13168
21:47:08.150 --> 21:47:08.851
伯纳德。

13169
21:47:08.851 --> 21:47:09.728
重要的。

13170
21:47:09.728 --> 21:47:12.989
现在我们把它固定在我们的IPFS上。

13171
21:47:12.989 --> 21:47:15.765
我把我的放在一个小狗档案里了。

13172
21:47:15.765 --> 21:47:21.110
现在我们已经上传了它们，皮纳塔建议你也把自己的钉在自己的节点上。

13173
21:47:21.110 --> 21:47:21.765
太酷了。

13174
21:47:21.765 --> 21:47:26.090
我们有办法把这些图像上传到IPFS上。

13175
21:47:26.090 --> 21:47:27.325
太棒了。

13176
21:47:27.325 --> 21:47:36.970
现在我们已经完成了这些，我们还需要存储令牌URI元数据。

13177
21:47:36.970 --> 21:47:40.583
我们先把它删掉。

13178
21:47:40.583 --> 21:47:51.408
我们能在这里做的，是回到顶部，我们可以说const元数据，template =我们会创建一个元数据模板。

13179
21:47:51.408 --> 21:47:56.957
这将包含令牌URI元数据所需的所有基本内容。

13180
21:47:56.957 --> 21:48:11.258
在这里，我们有一个名称，它是空白的，我们有一个描述，它也设置为空白会有一个图像它将被替换为我们刚创建的图像URI即IPFS URI。

13181
21:48:11.258 --> 21:48:21.461
如果你想给你的NFT像任何类型的统计，你可以做一些你可以像这样创建这个Attributes部分。

13182
21:48:21.461 --> 21:48:27.274
如果你给它traits type, cute，逗号，值100。

13183
21:48:27.274 --> 21:48:39.594
如果你想为你的NF T创建不同的卡或者拥有不同的攻击、防御和HP速度，你可以在属性部分添加它们。

13184
21:48:39.594 --> 21:48:46.732
通常，您希望这些属性也存储在链中，这样您的契约可以明显地通过编程与这些属性交互。

13185
21:48:46.784 --> 21:48:49.084
现在我们有了这个元数据模板。

13186
21:48:49.784 --> 21:48:52.184
我们要为每只狗狗填写表格。

13187
21:48:52.784 --> 21:48:59.646
在这里创建一个新函数叫async，用来存储令牌URI元数据。

13188
21:48:59.646 --> 21:49:04.672
我们会把元数据传递给async函数。

13189
21:49:04.672 --> 21:49:08.736
我们会传入从这里的脚本中得到的元数据。

13190
21:49:08.736 --> 21:49:10.497
我们有了这个模板。

13191
21:49:10.497 --> 21:49:16.187
我们会根据在IPFS中存储的数据来填充这个模板。

13192
21:49:16.187 --> 21:49:19.671
现在我们要写剩下的句柄token你的眼睛位。

13193
21:49:19.671 --> 21:49:29.521
我们会在数据和V中这样做，我们会说，upload to pinata = true，这样我们就能做所有事情并处理token你的眼睛。

13194
21:49:29.521 --> 21:49:33.214
上传到皮纳塔，这是真的，我们向下滚动，开始创建这个。

13195
21:49:33.214 --> 21:49:47.585
我们要做的第一件事，显然，我们要得到那些响应和那些文件，因为它在响应中，pin file to IPFS会返回文件的哈希值，我们需要那个哈希值，来添加到元数据中。

13196
21:49:47.585 --> 21:50:04.385
我们会在下面这里，我们会说const, responses，这将是image upload, responses，逗号files，等于await, store images，然后images, location。

13197
21:50:04.385 --> 21:50:11.375
所以这个反应，将是这些来自皮纳塔的反应的列表。

13198
21:50:11.375 --> 21:50:15.768
这些响应会有每个上传文件的哈希值。

13199
21:50:15.768 --> 21:50:19.835
现在我们要遍历这个列表上传每一个元数据。

13200
21:50:19.835 --> 21:50:31.585
对于每个图片上传响应索引，在图片上传响应中。

13201
21:50:31.785 --> 21:50:38.531
对于每一个，我们将创建元数据，我们将创建元数据，然后上传元数据。

13202
21:50:38.531 --> 21:50:47.260
我们说，让令牌URI，元数据=。点。元数据模板。

13203
21:50:47.260 --> 21:50:53.385
这是一些有趣的JavaScript，语法糖，意思是，解包。

13204
21:50:53.385 --> 21:50:57.735
基本上，我们说令牌URI元数据将等于这个东西。

13205
21:50:57.785 --> 21:51:05.118
我们把所有这些东西都放到这个token中，你的元数据变量，现在我们说token，你的元数据。

13206
21:51:05.118 --> 21:51:15.626
。name将等于。index的files。replace。png。png什么都没有。

13207
21:51:15.626 --> 21:51:26.428
files就是这些文件中的每一个，对吧?可以是St Bernard。png，也可以是Shiva。png。

13208
21:51:26.428 --> 21:51:31.933
基本上，我们所做的就是说，好，很好，令牌内部的名称，元数据将是pug。

13209
21:51:31.933 --> 21:51:34.539
所以我们要放弃扩展。

13210
21:51:34.539 --> 21:51:46.182
这就是我们得到name令牌的方式，你的AI元数据。description，将等于并崇拜一个碗。

13211
21:51:46.182 --> 21:51:50.992
然后我们会得到名字，令牌URI metadata。name。

13212
21:51:50.992 --> 21:51:53.926
这是一只可爱的哈巴狗和可爱的圣。

13213
21:51:53.926 --> 21:52:09.595
Bernard pop或者一个可爱的船你小狗令牌URI元数据。image，这可能是这里最重要的一个，这将是，它将是我们从响应中得到的带有IPFS哈希的IPFS扩展。

13214
21:52:09.595 --> 21:52:22.478
我们可以通过image upload response index。iipfs得到这个。

13215
21:52:22.478 --> 21:52:26.570
哈希，我们可以去找皮纳塔的医生。

13216
21:52:26.786 --> 21:52:36.389
我们可以在IPFS哈希中看到pin文件到IPFS的返回，pin大小和时间戳，我们只关心IPFS哈希。

13217
21:52:36.389 --> 21:52:41.395
我们将用它来给出我们的元数据图像。

13218
21:52:41.395 --> 21:52:45.458
最后，我再写一个console。log upload。

13219
21:52:45.458 --> 21:52:52.674
然后我们说，token，你的eye metadata。name。。

13220
21:52:52.786 --> 21:52:59.919
现在我们需要存储文件或存储JSON到pinata / IPFS。

13221
21:52:59.919 --> 21:53:05.176
这就是我们上传到皮纳塔的地方，我们要在这里添加这个函数。

13222
21:53:05.176 --> 21:53:06.987
我们有存储令牌URI元数据。

13223
21:53:06.987 --> 21:53:19.007
这里我们要做的是，try const response = await, nada，将JSON引脚到元数据的IPFS。

13224
21:53:19.007 --> 21:53:26.238
我们想要将JSON固定到IPFS中，这是非常相似的。

13225
21:53:26.238 --> 21:53:29.913
我们需要传递主体，也就是JSON。

13226
21:53:29.913 --> 21:53:36.377
这里有一些可选的东西，但它会给我们相同的返回值IPFS散列pin，大小和时间戳。

13227
21:53:36.377 --> 21:53:40.303
如果这个可行，我们只需要返回响应。

13228
21:53:40.303 --> 21:53:42.367
否则，我们会执行catch error。

13229
21:53:42.367 --> 21:53:52.916
然后我们用console。log error，然后我们用return null然后我们用exports或令牌URI元数据。

13230
21:53:52.916 --> 21:53:59.537
然后回到部署中，我们将继续导入这个存储令牌URI元数据。

13231
21:53:59.537 --> 21:54:01.599
我们向下滚动。

13232
21:54:01.599 --> 21:54:13.749
他们会执行const，元数据，upload response = await，存储令牌URI元数据我们传递令牌URI，元数据。

13233
21:54:13.749 --> 21:54:22.251
现在，随着所有这些元数据的上传我们最终会得到我们需要的令牌。

13234
21:54:22.251 --> 21:54:33.240
我们会说，令牌，你的眼睛。push, IPFS，斜杠，然后这里是元数据响应，元数据上传响应。IPFS。

13235
21:54:33.240 --> 21:54:33.630
散列。

13236
21:54:33.787 --> 21:54:41.388
我们最终会得到这个指向元数据的IPFS哈希数组，每一个元数据都指向图像。

13237
21:54:41.388 --> 21:54:44.654
然后我们写一个console。log令牌。

13238
21:54:44.788 --> 21:54:53.649
你升起，上传，它们然后我们再做一个console。log标记你的眼睛。

13239
21:54:53.649 --> 21:54:54.941
哦，好吧。

13240
21:54:54.941 --> 21:54:57.615
让我们继续运行这个。

13241
21:54:57.615 --> 21:54:59.408
让我们看看它是否有效。

13242
21:54:59.408 --> 21:55:04.507
在我们的皮纳塔中，我们应该同时看到图像和元数据。

13243
21:55:04.507 --> 21:55:09.755
如果process。E和V。upload to pinata = true，看起来它是真的。

13244
21:55:09.755 --> 21:55:19.076
我们应该运行这个并处理令牌，你的眼睛会上传我们的图像和store图像然后上传我们的元数据。

13245
21:55:19.076 --> 21:55:30.480
我们只会在这里看到它一次因为它会有完全相同的Cid对吧，它会有相同的哈希值，所以我们不会在pinata或IPFS中得到相同文件的副本。

13246
21:55:30.480 --> 21:55:32.172
我们把它打开。

13247
21:55:32.172 --> 21:55:38.055
让我们再运行一次，或者已经部署了破折号标签，随机IPFS和模拟。

13248
21:55:38.055 --> 21:55:47.343
好的，看起来我们上传到香蕉上的工作几乎是零的，一个的，两个的元数据模板没有定义。

13249
21:55:47.343 --> 21:55:55.703
哈，因为我拼写了元数据模板，元数据模板，让我们正确拼写。

13250
21:55:55.788 --> 21:56:01.645
现在让我们再试一次，它在0处工作它在2处工作图像上传响应没有定义。

13251
21:56:01.645 --> 21:56:03.550
我应该拼写正确。

13252
21:56:03.550 --> 21:56:04.566
好了。

13253
21:56:04.566 --> 21:56:07.532
让我们，让我们把帽子写对。

13254
21:56:07.788 --> 21:56:09.862
让我们再试一次。

13255
21:56:11.788 --> 21:56:13.538
上传Shiva在你上传St。

13256
21:56:14.788 --> 21:56:16.493
上传就可以了。

13257
21:56:18.789 --> 21:56:23.047
进入我们的浏览器，或者你的IPFS节点，砰，我们在这里有它们。

13258
21:56:23.047 --> 21:56:33.250
我们能做的就是抓取这个散列，进入IPFS桌面，找到文件，从IPFS导入粘贴到这里。

13259
21:56:33.250 --> 21:56:37.574
给它起个名字等等，我们在自己的IPFS节点上也有它。

13260
21:56:37.574 --> 21:56:38.145
太棒了。

13261
21:56:38.145 --> 21:56:44.931
现在我们回到皮纳塔，刷新一下，我们可以看到所有东西都在这里了。

13262
21:56:44.931 --> 21:56:51.723
如果我复制其中一个，然后到IPFS。。斜杠粘贴进去，我们可以看到这里的元数据。

13263
21:56:51.789 --> 21:56:53.428
一切看起来都很好。

13264
21:56:55.789 --> 21:57:11.539
我们这么做是因为现在我们可以将数据存储在我们自己的IPFS节点和至少一个其他节点上，所以如果我们的计算机或服务器宕机了，至少还有其他人在做。

13265
21:57:11.789 --> 21:57:17.149
现在我们终于有了这个标记列表，我们终于可以回到我们的论点。

13266
21:57:17.149 --> 21:57:19.903
现在我们可以这样做。

13267
21:57:19.903 --> 21:57:23.740
我们可以把这些标记上传到我们的智能合约里。

13268
21:57:23.789 --> 21:57:26.455
然后我们还需要一笔额外的费用。

13269
21:57:26.789 --> 21:57:38.289
我们到上面的config会在这里创建一个mint fee, mint fee是我们想要的任何值12345678123456789，我们会做的是0。

13270
21:57:38.289 --> 21:57:39.164
01容易的。

13271
21:57:39.164 --> 21:57:45.122
我们将把这个放到下面，我们将为我们将为Hard Hat Network做这个。

13272
21:57:45.122 --> 21:57:47.312
我们也会为林基做同样的事。

13273
21:57:47.312 --> 21:57:48.950
我们在这里有争论。

13274
21:57:48.950 --> 21:57:51.466
现在我们终于可以部署我们的契约了。

13275
21:57:51.466 --> 21:57:54.346
我们用const random IPFS。

13276
21:57:54.346 --> 21:58:03.451
如果t等于await，则部署，如果契约是来自Deployer的随机IPFS NF t。

13277
21:58:03.451 --> 21:58:05.051
Args就是Args。

13278
21:58:05.051 --> 21:58:06.613
日志是真的。

13279
21:58:06.613 --> 21:58:24.886
然后wait confirations将是network。config。block for confirm terminations，很好，这里可能还有一行。

13280
21:58:24.886 --> 21:58:26.551
我们来验证一下。

13281
21:58:26.551 --> 21:58:29.273
我要从部署中复制这个。

13282
21:58:29.273 --> 21:58:43.671
我们的基本的，我要复制这个它的代码是完全一样的，除了我们要验证随机IPFS而不是实际上我们使用args而不是参数，就是这样。

13283
21:58:43.671 --> 21:58:49.123
所以我们会给它一个快速部署测试，HH部署或yarn Hardhead部署。

13284
21:58:49.123 --> 21:58:52.740
看起来我们就快成功了我们就快搞定了一切都搞定了。

13285
21:58:52.790 --> 21:58:56.531
没有定义网络配置，因为我们没有导入它。

13286
21:58:56.790 --> 21:59:00.341
让我们继续从我们的助手Hardhead导入网络配置。

13287
21:59:00.341 --> 21:59:00.823
配置。

13288
21:59:00.823 --> 21:59:02.547
导入网络配置。

13289
21:59:02.547 --> 21:59:11.123
我们再试一次，当chain ID没有定义时，它是chain ID，那个chain ID再试一次。

13290
21:59:11.123 --> 21:59:14.990
太棒了，它至少对我们的帽子网络有用。

13291
21:59:14.990 --> 21:59:18.066
然后我们可以复制这个数组，粘贴到这里。

13292
21:59:18.066 --> 21:59:18.373
繁荣。

13293
21:59:18.373 --> 21:59:20.713
现在我们有了这个信物你的眼睛。

13294
21:59:20.713 --> 21:59:22.436
现在回到。env。

13295
21:59:22.436 --> 21:59:24.332
现在我们可以将它设为false。

13296
21:59:24.332 --> 21:59:32.445
因为我们已经有了所有的令牌神经元，我们只需要运行大力点击Deploy，我们只需要使用我们已经上传的令牌英雄。

13297
21:59:32.445 --> 21:59:33.893
是的，我们做到了。

13298
21:59:33.893 --> 21:59:40.290
现在我知道你很高兴看到这个像打开看，你很高兴看到这个马上。

13299
21:59:40.290 --> 21:59:46.097
但是让我们把所有这些都部署到溜冰场B上直到最后，因为部署到测试网是非常慢的。

13300
21:59:46.097 --> 21:59:51.483
让我们等到最后一点然后我们继续，我们把它部署到B级。

13301
21:59:51.483 --> 21:59:57.153
但是在编写测试之前，我在编写测试时注意到，我们忘记更新令牌计数器。

13302
21:59:57.153 --> 22:00:04.291
在这里，在我们做之前，我们的保险箱，男人会做s代币计数器加上等于s代币计数器，也就是esto。

13303
22:00:04.291 --> 22:00:07.362
相遇等于es个token counter加1。

13304
22:00:07.362 --> 22:00:10.742
这就是为什么编写测试如此重要的一个完美的例子。

13305
22:00:10.791 --> 22:00:16.052
在编写任何测试之前，您肯定需要为订阅提供资金，这一点我们在这里没有做。

13306
22:00:16.052 --> 22:00:26.877
所以我们需要做一个等待VRF坐标Tor V来模拟。基金，订阅。

13307
22:00:26.877 --> 22:00:36.141
订阅ID，逗号表示基金金额，然后在上面，我们甚至可以把它拉出来。

13308
22:00:36.141 --> 22:00:37.991
因为这一点都不会改变。

13309
22:00:37.991 --> 22:00:44.924
我们可以让令牌年看起来像const基金金额等于很酷。

13310
22:00:44.924 --> 22:00:47.902
或者你也可以。你也可以做醚。解析。

13311
22:00:47.902 --> 22:01:05.791
但如你所知，在我们部署到冰场横梁之前，我们该怎么办?好吧，你是对的，我们绝对应该百分之百地编写一些测试。

13312
22:01:05.791 --> 22:01:11.348
我们创建了一个新文件叫做random IPFS NF t。test。js。

13313
22:01:11.348 --> 22:01:14.593
我们可以在这里写一些测试。

13314
22:01:14.791 --> 22:01:22.592
再说一次，你们在这个测试中不会学到什么新东西，它和我们之前写过的彩票测试非常相似。

13315
22:01:22.592 --> 22:01:32.921
这就是我要说的，我再次强烈建议，你们自己写至少两到三个测试，但一定要写一个满足随机单词的测试。

13316
22:01:32.921 --> 22:01:40.945
但是我鼓励你们现在暂停视频，请暂停视频试着自己写一些测试。

13317
22:01:40.945 --> 22:01:49.569
而编写这些测试将真正锻炼你的编程能力，如果你愿意的话，这将给你持续编写这些测试的技能并且非常快速和有效。

13318
22:01:49.569 --> 22:01:51.824
当你构建这些智能合约时。

13319
22:01:51.824 --> 22:01:56.014
这些测试可以防止您编写糟糕的不可变代码。

13320
22:01:56.014 --> 22:01:59.234
请暂停视频，我要从GitHub回购中复制粘贴。

13321
22:01:59.234 --> 22:02:08.600
但是请利用这段时间在这里编写一些您自己的测试。

13322
22:02:08.792 --> 22:02:09.695
好了,好了。

13323
22:02:09.695 --> 22:02:12.211
你写测试了吗?希望你看过。

13324
22:02:12.792 --> 22:02:15.022
没有写一些测试，暂停视频，去写一些测试。

13325
22:02:15.022 --> 22:02:37.622
我保证你做这些测试，自己写练习会在这一点上极大地帮助你，我们做了什么，我们做了一些一些令人惊奇的东西，我们部署了一个基本的几乎什么都没有的NFT，然后我们部署了一个可证明的随机的NFT，随机的统计和随机的特征与不同的罕见，每个NFT取决于它是什么时候铸造的，或谁铸造的。

13326
22:02:37.622 --> 22:02:39.876
我们将数据存储在IPFS中。

13327
22:02:39.876 --> 22:02:47.073
我们还学会了如何通过编程将文件上传到pinata，这是另一种固定服务。

13328
22:02:47.073 --> 22:02:52.252
我们学习了一些关于非金融债务存储的知识，这是将数据固定到IPFS的另一种方法。

13329
22:02:52.252 --> 22:02:59.809
当然，我们知道如果我们想，我们可以通过编程将数据固定到我们自己节点上的IPFS。

13330
22:02:59.809 --> 22:03:03.268
但因为我们中的很多人不会每天24小时都在运行自己的电脑。

13331
22:03:03.268 --> 22:03:07.293
我们继续说，好吧，我们将坚持使用皮纳塔作为默认值。

13332
22:03:07.293 --> 22:03:13.694
现在我们完成了所有这些，砰，这里又有一个小的勾号。

13333
22:03:13.793 --> 22:03:22.465
现在我要说的是，我们不需要将数据存储在IPFS上如果我们愿意，我们可以直接将数据和元数据存储在链上。

13334
22:03:22.465 --> 22:03:27.529
然而，在IPFS上托管的IT优点和缺点各有不同，或者说它将会很便宜。

13335
22:03:27.529 --> 22:03:44.543
缺点是需要有人来固定我们的数据，对吧?至少有一个人需要固定她的数据，对吧?它是去中心化的，但你至少需要有人来固定你的数据，对吧?使用文件币之类的东西是一种激励人们钉住数据的方式。

13336
22:03:44.543 --> 22:03:51.938
但如果你不使用文件币，就不能保证在数据A在链上的情况下在链上执行SVG的优点。

13337
22:03:51.938 --> 22:03:56.093
而且你永远不用担心有人会把数据钉在里面。

13338
22:03:56.093 --> 22:04:00.348
缺点是这种方法要昂贵得多。

13339
22:04:00.348 --> 22:04:07.285
这些小图像，实际上非常大存储在链上会非常昂贵。

13340
22:04:07.285 --> 22:04:12.507
所以我们要用一些不同的图片，小得多的图片，便宜得多的图片。

13341
22:04:12.507 --> 22:04:27.480
如果你想看这个的另一个版本，我有另一个视频，如何用链元数据制作非ft艺术，它包含了我们将要在这里讨论的内容如果你想要第二个参考，在与这门课程相关的GitHub回购中有一个链接。

13342
22:04:27.480 --> 22:04:37.371
所以我们不使用这些png，而是使用SVG。

13343
22:04:37.371 --> 22:04:41.437
现在，SVG代表可缩放向量图形。

13344
22:04:41.437 --> 22:04:47.810
这些都是非常简单的文件我们可以把它们上传到区块链。

13345
22:04:47.810 --> 22:04:52.370
这就是我们要用它们的原因因为它们更简洁，上传也更便宜。

13346
22:04:52.370 --> 22:04:56.380
因为记住，上传到区块链的数据越多，开销就越高。

13347
22:04:56.380 --> 22:04:59.714
在这个视频中，我在链上随机化SVG数据。

13348
22:04:59.714 --> 22:05:01.919
这里有一个例子，它是什么样的。

13349
22:05:01.919 --> 22:05:03.682
只是一堆随机的行。

13350
22:05:03.682 --> 22:05:07.132
不是超级刺激，但随机和有点酷。

13351
22:05:07.132 --> 22:05:08.148
这是100%。

13352
22:05:08.148 --> 22:05:10.758
在链上，这些SVG实际上可以在HTML中正常工作。

13353
22:05:10.758 --> 22:05:20.217
如果你想在你的网站上使用这些，你也可以在GitHub上找到与这门课相关的教程链接，在那里我们可以自己尝试一下。

13354
22:05:20.217 --> 22:05:27.455
我们可以制作一个SVG，他们通过学校在这个网站上有各种不同的命令。

13355
22:05:27.455 --> 22:05:42.138
com/graphics/svg引入。ASP，你可以看到一些不同的命令，对吧，你可以做一个矩形你可以做一个圆路径是一个很大的路径，你可以确切地说你想画的路径或线是什么样的。

13356
22:05:42.138 --> 22:05:44.955
在SVG中可以制作很多东西。

13357
22:05:44.955 --> 22:05:56.465
最酷的是，无论你制作的SVG有多大，其质量总是完全相同的，因为SVG只是精确地解释了如何绘制图像，无论图像有多大或有多小。

13358
22:05:56.465 --> 22:06:02.336
如果你想了解更多关于SVG的知识想玩SVG，你可以来这里自己尝试一下。

13359
22:06:02.336 --> 22:06:04.760
也就是说，这就是我们要在链上储存的东西。

13360
22:06:04.794 --> 22:06:07.743
这就是我们如何在链上存储SVG的东西。

13361
22:06:07.794 --> 22:06:14.919
但我们要更进一步，我们要让这个动态，我们要让这个根据链上的一些数据改变。

13362
22:06:14.919 --> 22:06:25.122
如果你去到与这节课相关的GitHub回购，你去到图像，你去到动态非函数函数，你会看到两个图像，看到happy。SVG，看起来像这样。

13363
22:06:25.122 --> 22:06:29.384
你会看到皱眉。SVG，它看起来像这样。

13364
22:06:29.384 --> 22:06:39.152
我们将使这个非ft动态也就是说，如果每个价格高于某个数字，那么我们将让它是一张笑脸。

13365
22:06:39.152 --> 22:06:43.604
如果它低于这个值，我们会把它变成一张皱眉的脸。

13366
22:06:43.604 --> 22:06:47.545
所以我们的非ft会根据一些真实世界的参数而改变。

13367
22:06:47.545 --> 22:07:01.595
这显然是非常强大和酷的，因为我们可以有一个基于统计的变化的非函数函数，我们可以有一个基于任何变化的非函数函数t，我们要将所有的数据百分之百地存储在链上，这将会有点贵。

13368
22:07:01.595 --> 22:07:08.564
这就是我们要做的。

13369
22:07:08.795 --> 22:07:10.553
让我们开始吧，开始吧。

13370
22:07:11.795 --> 22:07:13.777
我们最终的非ft部分的合同。

13371
22:07:14.795 --> 22:07:22.128
在这里创建一个新契约，新契约，这将是我们的动态SVG和ftdot灵魂。

13372
22:07:22.128 --> 22:07:27.144
这看起来和我们刚才做的很像。

13373
22:07:27.144 --> 22:07:28.413
动态的。

13374
22:07:28.413 --> 22:07:38.742
SVG和ft点锯，斜杠lat spdx，许可证标识符，和我的团队的pragma。

13375
22:07:38.742 --> 22:07:43.320
固体，Eric 0，点8。

13376
22:07:43.320 --> 22:07:43.477
7.

13377
22:07:43.477 --> 22:07:47.638
契约，动态SVG, NF t。

13378
22:07:47.638 --> 22:07:53.695
现在我们来谈谈它的架构是什么样的。

13379
22:07:53.695 --> 22:07:56.937
它看起来很像正常的NF - T，有几点需要注意。

13380
22:07:56.937 --> 22:08:04.436
我们会给它一个min函数来mint，这些NF T也会把我们的SVG信息存储在某个地方。

13381
22:08:04.436 --> 22:08:13.490
然后我们需要一些逻辑来显示x图像或y图像。

13382
22:08:13.490 --> 22:08:19.151
正如我们所知，那只会切换令牌URI说show X或show y。

13383
22:08:19.151 --> 22:08:22.054
我们来看看怎么做。

13384
22:08:22.054 --> 22:08:24.957
首先，我们知道这是在ERC中。

13385
22:08:24.957 --> 22:08:25.215
721.

13386
22:08:25.215 --> 22:08:27.445
我们可以从齐柏林飞船上导入它。

13387
22:08:27.445 --> 22:08:35.517
我们会说import at open Zeppelin /合约/令牌/ ERC。

13388
22:08:35.517 --> 22:08:37.123
721斜杠ERC。

13389
22:08:37.123 --> 22:08:38.844
就这些。

13390
22:08:38.844 --> 22:08:47.524
现在我们不会调用之前调用的那个集令牌URI函数所以我们可以使用原始的ERC 721而不是扩展。

13391
22:08:47.524 --> 22:08:53.577
所以我们会说我们的合同是ERC 721现在我们把它变成ERC 721。

13392
22:08:53.577 --> 22:08:59.446
我们可以像这样构造宿舍，然后调用ERC的构造函数。

13393
22:08:59.446 --> 22:09:14.161
721，我们称之为动态SVG，还有ftdsn，动态SVG和s t f t，像这样然后我们还需要一个薄荷函数。

13394
22:09:14.161 --> 22:09:19.374
我们现在就来创建它比如function mint和ft或者request NFT。

13395
22:09:19.374 --> 22:09:24.934
这里我们会稍微宽松一点，我们会说用户不需要为此支付任何钱。

13396
22:09:24.934 --> 22:09:26.629
所以这只是一个公共活动。

13397
22:09:26.629 --> 22:09:28.240
我们要把它们和NFT都造出来。

13398
22:09:28.240 --> 22:09:32.462
同样的，我们会调用Safe mint message。sender。

13399
22:09:32.462 --> 22:09:35.462
当然，我们需要令牌计数项。

13400
22:09:35.462 --> 22:09:45.003
让我们继续，在我们的顶部，在256，私有s，下划线，令牌计数器，我们在这里写令牌计数器。

13401
22:09:45.003 --> 22:09:50.135
然后在我们的意思是我们会做标签计数器加，这里会是= token计数器加1。

13402
22:09:50.135 --> 22:09:55.745
差不多就是这样了，我们有一种方法意味着我们已经做了一些基本的。

13403
22:09:55.797 --> 22:10:00.130
我们甚至会显式地说s token counter = 0来初始化它。

13404
22:10:00.130 --> 22:10:04.504
现在这个代币会是什么样子呢?我们想让他们看起来像svg。

13405
22:10:04.504 --> 22:10:12.693
我们希望它基于构造函数中某些资产的价格，创建一个字符串内存。

13406
22:10:12.693 --> 22:10:19.051
我们称其为低SVG字符串内存为高SVG。

13407
22:10:19.051 --> 22:10:28.597
在我们的代码中，我们会把这个低的SVG保存到这个最高的vg中。

13408
22:10:28.597 --> 22:10:35.181
这些是图像，这些是皱眉的脸和微笑的脸它们会作为输入参数导入。

13409
22:10:35.181 --> 22:10:39.659
正如我们所知，我们可以让它们成为不可变的因为它们可能不会改变。

13410
22:10:39.659 --> 22:10:46.712
我们可以说String, private，下划线，low image URI。

13411
22:10:46.712 --> 22:10:51.441
在string private中，我强调了high image URI。

13412
22:10:51.441 --> 22:11:05.567
但如果我们只传递SVG数据，SVG数据看起来就像。在这个GitHub中，我可以在这里显示源blob我可以确切地看到代码是什么样的这段代码肯定不是图像URI。

13413
22:11:05.567 --> 22:11:16.734
我们需要的是像这样的图像URI，对吧?现在，我们传递它的方式是通过SVG代码，对吧?因为我们只想向它传递SVG代码，然后让契约处理其他一切。

13414
22:11:16.797 --> 22:11:26.353
那么我们要怎么做呢?我们能做的是创建一个名为SVG的函数来图像URI。

13415
22:11:26.353 --> 22:11:31.170
在链上，我们可以把svg转化成svg。

13416
22:11:31.170 --> 22:11:32.441
使形象出现。

13417
22:11:32.441 --> 22:11:45.147
我们不再使用IPFS，而是使用64进制编码，你可以将任何SVG编码为64进制图像URL。

13418
22:11:45.147 --> 22:11:46.178
这是正确的。

13419
22:11:46.178 --> 22:11:49.012
它看起来就像这个底。

13420
22:11:49.012 --> 22:11:53.572
64是将表示二进制数据的二进制编码方案分组为文本编码方案。

13421
22:11:53.572 --> 22:11:55.910
或者在我们的例子中，是SVG数据。

13422
22:11:55.910 --> 22:11:56.313
基地。

13423
22:11:56.313 --> 22:12:20.410
64在万维网上特别流行，它的用途之一是在文本资产中嵌入图像文件或其他二进制资产，如HTML和CSS，我们能做的是，将所有这些SVG转换为URL或图像URI，这很好，对吧?这正是我们想要的，我们想要能够将这个转换为URL或图像URI。

13424
22:12:20.410 --> 22:12:33.076
如果你取其中一幅图像，或者这些SVG图像，比如happy to have SVG，在这个happy。SVG中我们能做的是复制图像地址，也就是这个地址的URL。

13425
22:12:33.076 --> 22:12:36.221
如果我们把它粘贴回来，我们会在这里看到司法文件。

13426
22:12:36.221 --> 22:12:41.943
在这个网站中，我们可以做数据类型，远程URL，粘贴到这里。

13427
22:12:41.943 --> 22:12:44.909
我们可以说将SVG编码为64进制。

13428
22:12:44.909 --> 22:12:51.099
在下面这里，我们会得到这个奇怪的工作角色，数字，字母之类的。

13429
22:12:51.099 --> 22:13:12.195
这个64进制编码表示我们刚得到的SVG我们可以在浏览器中做什么，我们可以输入data，冒号，图像，斜杠SVG，加上XML，分号，进位64，逗号，然后粘贴到这里，回车。

13430
22:13:12.195 --> 22:13:16.957
你不知道吗，我们就能还原出那个画面。

13431
22:13:16.957 --> 22:13:22.275
这个巨大的东西就是这个图像的64进制编码。

13432
22:13:22.275 --> 22:13:28.153
有了这个基本的c4编码的图像，我们可以使用这个链作为你到达的图像。

13433
22:13:28.153 --> 22:13:29.656
然后是元数据。

13434
22:13:29.656 --> 22:13:32.256
我们将把它直接烘焙到令牌URI中。

13435
22:13:32.256 --> 22:13:34.035
你马上就会明白我的意思。

13436
22:13:34.035 --> 22:13:39.549
因此，我们有了一种方法，可以直接将SVG代码放入智能合约中。

13437
22:13:39.549 --> 22:13:40.549
我们来看看怎么做。

13438
22:13:40.549 --> 22:13:47.179
我们有函数，SVG to image URI，我们知道我们可能会在chain上做同样的64进制编码。

13439
22:13:47.179 --> 22:13:55.681
如果你想省点油，我们会百分之百地在链上做这个但是展示如何在链上做这个很有趣，所以我们将它设为一个公共纯函数。

13440
22:13:55.681 --> 22:13:59.452
我们会让它返回一个字符串内存。

13441
22:13:59.452 --> 22:14:06.322
我们将给这个函数一个SVG，它将从构造函数传入。

13442
22:14:06.322 --> 22:14:27.218
我们会返回一个字符串，也就是我们刚才看到的64进制编码的URL，而在上面我们会做string, private常量，以S为基数的feed，以64为基数的编码SVG前缀等于这个。

13443
22:14:27.218 --> 22:14:33.024
我们会用这个来生成我们的SVG，我们可以这么做。

13444
22:14:33.024 --> 22:14:43.735
然后我们会做字符串内存SVG，我们会为我们自己编码这个SVG通过在chain上添加64进制编码。

13445
22:14:43.800 --> 22:14:47.733
现在，我们不想自己重写它。

13446
22:14:47.800 --> 22:14:49.406
幸运的是，已经有人这么做了。

13447
22:14:49.800 --> 22:14:56.918
查看与此相关的GitHub回购，这是由一个LoopRing开发人员创建的非常棒的项目，如果你也想看看的话。

13448
22:14:56.918 --> 22:15:00.111
我们将为我们的SVG链借用这段代码。

13449
22:15:00.111 --> 22:15:18.292
我们能做的是在这里添加这个，添加他们的GitHub代码，这里有我们需要的所有编码和解码基础的东西，我们可以做yarn，添加dash Dev, base 64 dash soul，这将添加他们的代码作为依赖。

13450
22:15:18.292 --> 22:15:28.729
一旦我们添加了它，我们就可以导入导入，以64为底，破折号，斜杠，以64为底。Sol。

13451
22:15:28.729 --> 22:15:33.206
这份合同附带一个编码器。

13452
22:15:33.206 --> 22:15:41.956
然后我们可以做string memory, SVG base64 encoded，等于base64。ENCODE。

13453
22:15:41.956 --> 22:15:45.747
这里就有点奇怪了。

13454
22:15:45.800 --> 22:16:19.107
我们会使用bytes string, abi。ENCODE, act, SVG，然后我们会返回string API。ENCODE packed, base 64, encoded SVG prefix, comma SVG base 64 encoded，这个函数，这个SVG to image URI会接收任何SVG，然后返回一个URL或URI，看起来就像这样。

13455
22:16:19.107 --> 22:16:21.729
现在，我在这里快速浏览了一些内容。

13456
22:16:21.729 --> 22:16:33.597
还有很多新的东西，比如ABI。encode pack我们做了两次，这个ABI。encode pack是干什么的?让我们来了解一下。

13457
22:16:33.597 --> 22:16:41.001
从一个非常非常高的层面来说，这基本上就是连接字符串的方式。

13458
22:16:41.001 --> 22:16:43.710
这就是把字符串组合在一起的方法。

13459
22:16:43.710 --> 22:16:51.978
我们会跳过remix来探索这个ABI点编码契约和这个ABI编码的东西。

13460
22:16:51.978 --> 22:16:56.456
我们接下来要讲的部分绝对是高级的。

13461
22:16:56.456 --> 22:17:05.227
我们将会讨论一些非常低层次的东西，固体在幕后是如何工作的，二进制是如何工作的，还有这个叫做操作码的东西。

13462
22:17:05.227 --> 22:17:08.733
所有这些疯狂的，低级的，棘手的，难以理解的事情。

13463
22:17:08.733 --> 22:17:13.733
如果你想跳过这一节，在GitHub回购中有时间戳。

13464
22:17:13.801 --> 22:17:15.145
帮你度过难关。

13465
22:17:16.801 --> 22:17:22.448
如果你第一次听不懂，至少试着吸收大部分内容。

13466
22:17:22.448 --> 22:17:23.565
这是100%。

13467
22:17:23.565 --> 22:17:25.325
好的，这个更高级。

13468
22:17:25.325 --> 22:17:30.637
无论如何，对于大多数基本项目，您并不真正需要这些信息。

13469
22:17:30.637 --> 22:17:37.377
只有当你变得更高级的时候，知道所有这些才会让你成为一名出色的可靠性开发人员。

13470
22:17:37.377 --> 22:17:51.768
当你开始学习这一节的时候，当你开始学习EVM，操作码，编码和调用这一节的时候，你要知道如果你第一次不能百分百理解也没关系，如果你想多看几次这一节那就太棒了。

13471
22:17:51.768 --> 22:17:55.229
所以如果你想跳过去混音和跟随，让我们做。

13472
22:17:55.229 --> 22:17:59.995
在合约部分，我们创建一个新文件，命名为encoding。soul。

13473
22:17:59.995 --> 22:18:06.602
记住，我们在这里用到的所有代码都会在Hardhead NFT的子课程文件夹中。

13474
22:18:06.602 --> 22:18:06.868
FCC。

13475
22:18:06.868 --> 22:18:11.598
我们要处理的所有代码都在这个encoding。soul中。

13476
22:18:11.598 --> 22:18:18.005
再过一会儿，我们会把这个叫做灵魂的东西我们在这个encoding。soul中。

13477
22:18:18.005 --> 22:18:20.038
我们先写一下基本代码。

13478
22:18:20.038 --> 22:18:33.373
我们会说spdx许可标识符MIT pragma solidity胡萝卜0点8。

13479
22:18:33.373 --> 22:18:40.737
7、像那样，做缩约编码，boom，编译，或者Command S或ctrl S伟大的东西都看起来不错。

13480
22:18:40.802 --> 22:18:49.119
记住，这里的目的是首先理解这里发生了什么，以及更多关于这个API。encode pack的东西。

13481
22:18:49.119 --> 22:18:58.769
让我们先写一个函数它应该把API。encode包装成一些字符串把它包装成一个字符串会返回一个字符串。

13482
22:18:58.769 --> 22:19:03.837
我们可以做函数，绑定字符串，或者连接字符串。

13483
22:19:03.837 --> 22:19:12.140
这将是一个公共纯函数因为我们不会读取任何存储，我们会说返回字符串内存。

13484
22:19:12.140 --> 22:19:17.656
我们会说，返回string, API。encode packing。

13485
22:19:17.656 --> 22:19:22.602
我是我是逗号，空格在这里，我想你，就像这样。

13486
22:19:22.602 --> 22:19:24.802
这里还需要一个括号。

13487
22:19:24.802 --> 22:19:25.602
好了,好了。

13488
22:19:25.802 --> 22:19:32.016
现在我们来部署这个，我们会启动一个JavaScript VM来部署编码。

13489
22:19:32.016 --> 22:19:32.230
所以。

13490
22:19:32.230 --> 22:19:37.755
到下面这里，点击合并字符串，我们得到整个字符串输出。

13491
22:19:37.802 --> 22:19:38.864
嗨，妈妈，想你。

13492
22:19:41.803 --> 22:19:53.544
因为API。encode wrapped返回一个bytes对象，我们通过将它包装在这个字符串中，将它转换为字符串来对它进行类型转换。

13493
22:19:53.544 --> 22:19:57.615
固体性说，好的，字节到字符串，没问题，这完全可行。

13494
22:19:57.615 --> 22:20:02.464
这个API点编码是这些全局可用的方法和单元。

13495
22:20:02.464 --> 22:20:14.975
实际上，在固体性中，有很多这样的，有这个固体性小抄，在GitHub的repo中也会有链接，它有一大堆的操作符它有一大堆的全局变量和方法。

13496
22:20:14.975 --> 22:20:24.403
你可以看到，如果我们看这里，我们寻找ABI。encode pact，我们看到ABI。encode pact在这里，我们向下滚动，我们会看到更多我们熟悉的东西。

13497
22:20:24.403 --> 22:20:29.727
例如，message。sender, message的sender, message。value。

13498
22:20:29.803 --> 22:20:36.409
还有很多其他全局可用的方法和变量我们在编写代码时可以使用。

13499
22:20:36.409 --> 22:20:38.469
现在，我要说，在0。

13500
22:20:38.469 --> 22:20:57.065
8点，加上，你实际上可以用string。concat，你知道，字符串a，字符串B，如果你想，而不是用这个API。encode pack，但我还是想给你们看API。encode pack，因为这是一个很好的过渡到我们将要讲到的所有ABI的东西。

13501
22:20:57.065 --> 22:20:59.950
但让我们关注这个编码打包的东西。

13502
22:20:59.950 --> 22:21:11.691
那么到底发生了什么呢?在深入研究这个编码约定之前，让我们稍微了解一下在发送事务时发生了什么。

13503
22:21:11.691 --> 22:21:16.381
当我们编译代码时，所有这些图片都会在GitHub回购中。

13504
22:21:16.381 --> 22:21:17.644
回想一下醚。

13505
22:21:17.644 --> 22:21:23.717
js，我们有两个文件，一个是。ABI文件，一个是。bin或。binary。

13506
22:21:23.804 --> 22:21:27.234
回到我们的以太符号存储，当我们运行纱线，编译。

13507
22:21:27.234 --> 22:21:36.183
我们得到的两个主要文件，一个是符号存储abi，也就是这个，我们已经很熟悉的abi。

13508
22:21:36.183 --> 22:21:42.704
然后是简单的storage。bin，它是二进制，里面有一堆数字，字母和我们不懂的东西。

13509
22:21:42.704 --> 22:22:02.581
你可以在remix中看到，如果我们要编译这个，你会得到编译细节，你会在这里得到一大堆东西，对吧?你可以在这里看到ABI，这是一种观察API的不同方式，我们还得到这个字节码位它是这个对象有相同的东西有那些随机的数字和字母。

13510
22:22:02.581 --> 22:22:06.459
但这实际上是二进制这实际上是放在区块链上的。

13511
22:22:06.459 --> 22:22:09.344
这是二元的，这是低级的东西。

13512
22:22:09.344 --> 22:22:15.753
现在，当我们把这些合约发送到区块链时，我们发送的是像我说的，我们发送的是二进制的东西。

13513
22:22:15.804 --> 22:22:17.625
这就是我们要发给区块链的东西。

13514
22:22:17.804 --> 22:22:33.769
还记得吗，在我们的ethers项目中，我们看到了什么是交易，对吧，交易有nonce，它有天然气价格猜测限制值数据，我们略过了VRS，因为这是交易签名的数学组成部分。

13515
22:22:33.769 --> 22:22:42.677
但在我们的ethos项目中，我们也这样做了，就在我们的deploy脚本中，我们自己发送了一个事务，只使用醚。

13516
22:22:42.677 --> 22:22:51.698
我们通过了一个nonce，一个天然气价格，天然气限制到价值数据是这个庞大的东西来声明合同，然后是链ID。

13517
22:22:51.698 --> 22:22:55.130
我们没有与VAR合作，因为ethers为我们做了这些。

13518
22:22:55.130 --> 22:22:58.961
但还有一个VAR的分量我们不去看。

13519
22:22:58.961 --> 22:23:05.412
当我们发送一个真正创建契约的事务时，2将是空的。

13520
22:23:05.412 --> 22:23:08.499
我们不会把这个合同部署发送到任何地址。

13521
22:23:08.499 --> 22:23:15.721
但是这个数据会有合约初始化代码和合约字节码。

13522
22:23:15.805 --> 22:23:16.043
正确的。

13523
22:23:18.805 --> 22:23:22.313
初始化契约，然后看看契约的实际样子。

13524
22:23:22.313 --> 22:23:28.226
所以如果你看你部署的任何合同，例如，我要看我们部署的抽奖。

13525
22:23:28.226 --> 22:23:35.497
如果你去看合同的交易，我们可以看到创造抽奖，好吧，让我们去看那个交易。

13526
22:23:35.497 --> 22:23:40.805
如果我们向下点击看更多以太扫描，我们可以看到这个输入数据。

13527
22:23:40.805 --> 22:23:45.055
再一次，它有所有这些随机的乱码数字和字母。

13528
22:23:45.055 --> 22:23:57.888
这是合约初始化代码和合约字节码的二进制数据我们在这个动作中发送的是这个数据，我们发送这个奇怪的乱码。

13529
22:23:57.888 --> 22:23:59.648
现在我们要回去混音了。

13530
22:23:59.648 --> 22:24:03.756
我将把这个作为注释留在这里在encoding。soul和GitHub repo中。

13531
22:24:03.805 --> 22:24:07.305
这里有大量的评论解释了我所解释的内容。

13532
22:24:07.305 --> 22:24:09.998
所以如果你想在那里跟随，你也可以。

13533
22:24:09.998 --> 22:24:27.242
现在为了让区块链理解，这些数字和字母到底是什么意思?你需要一个特殊的读取器铈或者区块链需要能够读取所有这些东西，它需要能够将所有这些随机的数字和字母映射到它们实际的功能。

13534
22:24:27.242 --> 22:24:36.705
Aetherium, polygon或avalanche是如何知道所有这些无意义的内容都是在告诉它去签订契约，你可以将其理解为，脱下你的外套。

13535
22:24:36.705 --> 22:24:45.186
作为人类，我们理解脱掉外套的唯一原因是我们理解英语。我们都在阅读英语，为了坚固。

13536
22:24:45.186 --> 22:24:46.138
对于区块链来说也是如此。

13537
22:24:46.138 --> 22:24:55.113
我读的不是英语，而是这些数字和字母，就像读单词一样，而不是脱下你的外套，这就像部署合同，合同做的是下一步的XYZ和所有这些随机的东西。

13538
22:24:55.113 --> 22:24:59.509
这个字节码代表了使契约发生的底层计算机指令。

13539
22:24:59.509 --> 22:25:05.494
所有这些数字和字母都代表了一个字母表，就像脱下你的外套是一个字母表一样。

13540
22:25:05.494 --> 22:25:13.117
当你像这样把它们组合在一起时，对我们来说这是有意义的，你可以把这些字母想象成所谓的操作码。

13541
22:25:13.117 --> 22:25:21.539
如果你去创建一个新标签，如果你去EVM。codes，我们会看到这个地方它有一个所有这些指令的列表。

13542
22:25:21.539 --> 22:25:25.150
在左边，你可以看到这个叫做操作码的东西。

13543
22:25:25.150 --> 22:25:58.193
然后你可以看到名字,这操作码段是说,嘿,如果你看到一个00在这个字节码,00代表这个操作码停止,这是暂停执行,如果你看到一个01你会做一些另外的东西,02年繁殖,这些op像字母代码,或二进制的语言材料,对,他们一路f f自我摧毁,这些op代码也有,这是什么阅读。

13544
22:25:58.193 --> 22:26:02.271
对吧?如果我们看一下我们的交易，你的和你的可能有一点不同。

13545
22:26:02.271 --> 22:26:06.627
哦，6,1说，好的，我们想让你做的第一件事是O 6，一个操作码。

13546
22:26:06.627 --> 22:26:13.733
如果我们去EVM，操作码，我们找6 1，它说的是push to place，在栈上购买商品。

13547
22:26:13.733 --> 22:26:23.726
这正是它读取这个的方式任何语言都可以编译到这个操作码的东西到这个特定的Aetherium操作码集，或EVM。

13548
22:26:23.807 --> 22:26:28.169
操作码，即以太坊虚拟机EVM。

13549
22:26:28.169 --> 22:26:44.156
因此，能够读取这些操作代码有时被抽象地称为EVM，即以太虚拟机，EVM基本上代表了所有的指令，计算机必须能够读取指令才能与Aetherium或Aetherium进行交互，就像应用程序一样。

13550
22:26:44.156 --> 22:27:02.072
这就是为什么这么多区块链都是用固体来工作的，因为固体编译到这个字节码，还有多边形，雪崩套利Aetherium，它们都编译到完全相同类型的二进制，它们都有完全相同的读取器。

13551
22:27:02.072 --> 22:27:12.726
为什么我们要告诉你这些东西，你可能会说，嘿，Patrick，这很酷但它看起来像ABI。encode pack，它所做的只是连接字符串，ABI encode pack实际上能做的更多。

13552
22:27:12.807 --> 22:27:31.842
如果我们看一下这些全局变量，API。encode pack就像列表上的第三个因为这是一种非标准的方式来将东西编码成我们刚刚讲过的二进制东西，我们基本上可以用二进制格式编码任何东西。

13553
22:27:31.842 --> 22:27:34.116
让我们来看看编码。

13554
22:27:34.116 --> 22:27:36.708
我们来创建一个函数encode number。

13555
22:27:36.708 --> 22:27:43.736
这将是一个公共纯函数，因为我们不会读取任何状态，我们会说返回一个字节内存。

13556
22:27:43.736 --> 22:28:01.332
我们会让这个函数返回一个bytes对象，我们会让它返回这个数字会是什么样子但是是二进制的，我们会说bytes, memory number = ABI。encode 1，然后返回number。

13557
22:28:01.332 --> 22:28:06.715
我们将把number编码为bi或二进制格式。

13558
22:28:06.715 --> 22:28:17.008
我知道很多时候当我们说，ABI是什么ABI是什么，对吗?之前，我们说，哦，ABI是，对吧?它是所有这些输入和输出。

13559
22:28:17.008 --> 22:28:19.755
这是ABI的人类可读版本。

13560
22:28:19.755 --> 22:28:34.214
ABI是我们想要编码的应用程序二进制接口它基本上是二进制的，这个ABI。encode会和你在编译细节时看到的ABI有些不同。

13561
22:28:34.214 --> 22:28:39.130
这在技术上就像ABI技术上是如何与合同交互的。

13562
22:28:39.130 --> 22:28:41.876
然而，它并不是真正的二进制版本。

13563
22:28:41.876 --> 22:28:50.299
所以我们说，好吧，把数字1编码成它的二进制版本，这样我们的契约就能以一种他们能理解的方式与它交互。

13564
22:28:50.299 --> 22:28:54.808
所以我们只是说，好，看第一个，让我们让你的机器可读。

13565
22:28:54.808 --> 22:29:06.458
如果我们编译这个，部署这个，删掉那个旧契约，部署这个，我们现在有了组合字符串和编码数字，点击它，我们得到这个大十六进制的东西。

13566
22:29:06.458 --> 22:29:10.980
计算机就是这样理解数字1的。

13567
22:29:10.980 --> 22:29:15.665
现在我们几乎可以编码任何东西，我们可以编码一个字符串。

13568
22:29:15.665 --> 22:29:23.152
我们会说，函数，编码字符串，这里也设为公钥。

13569
22:29:23.152 --> 22:29:29.775
它会返回一个字节内存，因为我们想给它二进制的东西或者它咬的东西。

13570
22:29:29.775 --> 22:29:39.071
我们会说bytes memory, some字符串= ABI。encode一些字符串，然后返回一些字符串。

13571
22:29:39.071 --> 22:29:46.843
现在我们编译它，删除旧契约，部署代码串，我们得到这个很大很大的对象。

13572
22:29:46.843 --> 22:29:48.429
这是二进制。

13573
22:29:48.429 --> 22:29:58.498
现在你会注意到一些东西，这里有大量的0，这些0占据了空间，对吧，这对计算机来说是很大的空间，即使它们并没有真正做什么。

13574
22:29:58.498 --> 22:30:00.615
它们只是有点占地方。

13575
22:30:00.615 --> 22:30:08.642
因此，可靠性还伴随着ABI点编码策略，它对给定的参数执行打包编码。

13576
22:30:08.642 --> 22:30:12.047
如果你想，你可以在固体性文档中读到更多相关内容。

13577
22:30:12.047 --> 22:30:14.443
这被称为非标准包装模式。

13578
22:30:14.443 --> 22:30:24.609
它做同样的编码，但有一些规定，小于32字节的类型直接连接而不填充，或符号扩展，动态类型编码到位。

13579
22:30:24.609 --> 22:30:33.285
没有填充长度数组元素，但仍然被编码，你可以把ENCODE打包成某种压缩器，对吧?它是ENCODE函数。

13580
22:30:33.285 --> 22:30:37.402
但如果我们想编码一些字符串但又想节省空间，它会压缩东西。

13581
22:30:37.402 --> 22:30:40.927
我们不需要完美的低水平二进制。

13582
22:30:40.927 --> 22:30:49.110
我们可以把函数和代码串打包，把它设为公共纯，然后让它返回一个字节内存。

13583
22:30:49.110 --> 22:30:57.709
我们可以说，bytes memory，某个字符串等于ABI。encode packing，还是某个字符串。

13584
22:30:57.809 --> 22:31:00.209
所以我们做的是代码包而不是代码。

13585
22:31:00.809 --> 22:31:08.055
这里返回一些字符串，我们会编译这个，我们会看到区别，编译，我们会删除旧的，我们会部署这个。

13586
22:31:08.055 --> 22:31:18.885
现在我们有ENCODE string，这也是encoded string要给我们的我们有encoded string wrapped，它返回给我们这个小得多的bytes对象。

13587
22:31:18.885 --> 22:31:27.013
你可以看到大小的差异，如果我们想要节省汽油，在代码中，字符串包装将是我们节省更多汽油的一种方式。

13588
22:31:27.013 --> 22:32:08.081
abi。encode pact实际上和我们之前做过的很相似，也就是类型转换，如果我们没有函数和代码字符串，字节，公共纯返回，字节，内存，字节，内存，一些字符串等于字节，一些字符串，翻转一些字符串，这两个看起来几乎是一样的，对吧?如果我们编译，我们会删除旧的契约，部署这个代码字符串bytes，它给我们这个用ABI编码字符串包，它们给我们完全相同的输出，而编码字符串给我们这个大片段。

13589
22:32:08.081 --> 22:32:10.000
所以这两个结果是一样的。

13590
22:32:10.000 --> 22:32:12.410
但在幕后，他们正在做一些有点不同的事情。

13591
22:32:12.410 --> 22:32:14.717
具体是什么我就不细讲了。

13592
22:32:14.810 --> 22:32:21.757
但我在这里的代码中留下了一个链接，如果你想了解更多，这正是我们在非功能性测试中所做的。

13593
22:32:21.810 --> 22:32:25.531
我们在做ABR。encode packing，我们在组合两个字符串。

13594
22:32:25.531 --> 22:32:36.810
通过将它们放在一起，我们将它们编码到它们的字节实现到它们的打包字节实现，然后我们只是将它们从字节类型转换回字符串。

13595
22:32:36.810 --> 22:32:39.143
这就是我们连接它们的方法。

13596
22:32:39.143 --> 22:32:41.236
现在，在这一点上，你可能会想，好吧，酷。

13597
22:32:41.236 --> 22:32:41.973
很好,帕特里克。

13598
22:32:41.973 --> 22:32:42.563
我都准备好了。

13599
22:32:42.563 --> 22:32:43.524
我理解这一点。

13600
22:32:43.524 --> 22:32:45.190
我很高兴回去做我的项目。

13601
22:32:45.190 --> 22:32:53.476
如果你想这么做，那就跳过这部分，但是其他一些观众可能会说，好吧，帕特里克，这看起来很酷。

13602
22:32:53.476 --> 22:33:04.572
但我相信这个encode函数中的encode pact不仅仅是用来连接字符串的，它们可能还有其他函数，它们到底是做什么的?如果你是问这个，我很高兴你问了。

13603
22:33:04.572 --> 22:33:06.534
我很高兴你很好奇，因为我们会找到答案的。

13604
22:33:06.534 --> 22:33:15.268
现在你不仅可以编码东西，比如字符串和数字，以及任何东西，你还可以解码东西。

13605
22:33:15.268 --> 22:33:27.285
我可以说，函数，解码字符串，公共，你的返回字符串内存，字符串内存，某个字符串等于ABI。decode。

13606
22:33:27.285 --> 22:33:30.359
这需要几个参数。

13607
22:33:30.359 --> 22:33:39.861
看文档，abi。decode，它的第一个参数是，编码的数据，然后是一个元组。

13608
22:33:39.861 --> 22:33:48.181
你可以把它想象成一个列表但不完全是一个列表，一组要解码的类型它会返回你给它的参数的数量。

13609
22:33:48.181 --> 22:33:59.442
所以我们可能会说这个字符串内存一些字符串添加，让我们把它作为输入这个编码字符串函数，这个编码字符串函数的结果，对吧，它会是这么大的东西。

13610
22:33:59.442 --> 22:34:06.303
这相当于把这个大的东西放在这里，但是我们不把这个大的东西放在这里，因为它真的很大。

13611
22:34:06.303 --> 22:34:12.525
我们会说，解码ENCODE string的结果，解码成一个字符串。

13612
22:34:12.525 --> 22:34:20.161
因为我们需要告诉固体，嘿，我们要解码这个，但它不知道解码成什么。

13613
22:34:20.161 --> 22:34:21.261
这就像，好吧，酷。

13614
22:34:21.261 --> 22:34:28.739
我可以解码这个，但是，你想让我怎么处理它，我们说，哦，这是一个字符串，那么解码成一个字符串。

13615
22:34:28.739 --> 22:34:31.120
然后我们可以返回一些字符串。

13616
22:34:31.120 --> 22:34:36.995
现在，再一次，我们部署旧的科特斯，删除上一个合同，然后部署这个新合同。

13617
22:34:36.995 --> 22:34:47.744
所以在代码串中，在代码串中，而在代码串中，代码串返回大量的东西，作为人类，我们会想，天哪，我看不懂电脑能看懂。

13618
22:34:47.812 --> 22:34:49.262
但我们无法真正读懂。

13619
22:34:50.812 --> 22:34:55.812
回到它的字符串形式，我们点击解码字符串，我们得到一些字符串。

13620
22:34:55.812 --> 22:35:02.431
现在我们可以进行多重编码，多重解码，对吧，我们可以想编码多少就编码多少。

13621
22:35:02.431 --> 22:35:19.133
我可以说function multiencode, public pure，返回字节内存，我们会编码一些东西，我们会说bytes，内存，一些字符串等于ABI。ENCODE一些字符串，逗号，它更大。

13622
22:35:19.133 --> 22:35:25.565
我们会在这里编码两个字符串，我们会编码一些字符串，它更大一些。

13623
22:35:25.565 --> 22:35:32.619
我们有两个字符串，我们会编码并返回一些字符串，即使它是字节。

13624
22:35:32.619 --> 22:35:35.452
然后我们就可以进行多重解码。

13625
22:35:35.452 --> 22:35:45.689
我们会说function multi decode，这是一个公共纯返回，我们会说它返回两个字符串，字符串内存，和字符串内存。

13626
22:35:45.689 --> 22:35:58.412
而不是做字符串内存，一些字符串等于API解码，我们会说，字符串内存，一些字符串，逗号字符串内存，另一些字符串。

13627
22:35:58.412 --> 22:36:03.612
我们会得到returns = Avi。decode。

13628
22:36:03.812 --> 22:36:11.949
让我们解码这个多重编码的结果，它是双重编码的字符串变成一个字符串和另一个字符串。

13629
22:36:11.949 --> 22:36:17.395
然后我们返回这两个都是一些字符串，好了。

13630
22:36:17.395 --> 22:36:22.249
现在我们返回一个字符串，然后是另一个字符串，这里我需要一个分号。

13631
22:36:22.249 --> 22:36:35.146
当我们部署这个的时候，把它关闭，部署这个新的，现在我们有了这个multiin代码，这就得到了这个更大的bites对象?因为这是两个编码的字符串。

13632
22:36:35.146 --> 22:36:40.435
如果我们点击多重解码，花点时间，你觉得它会输出什么?让我们继续并点击它。

13633
22:36:40.435 --> 22:36:46.345
现在它会给我们两个字符串，对吧，它会给你这两个字符串，一些更大的字符串。

13634
22:36:46.345 --> 22:36:50.337
我们可以告诉固体度来编码一堆东西。

13635
22:36:50.337 --> 22:36:57.444
然后我们甚至可以通过告诉它来解码它，好的，这个大对象，它是两个字符串的组合，然后我们解码它。

13636
22:36:57.444 --> 22:37:25.729
现在你甚至可以用编码包进行多重编码?我们可以用function, multiencode packed, public pure returns, bytes memory，然后是bytes memory, some string = ABI。encode packed some string，逗号，它比return some string大，我们可以这样做，对吧，但这将给我们这两个字符串的打包版本。

13637
22:37:25.729 --> 22:37:32.253
解码实际上对这个无效因为这是打包编码。

13638
22:37:32.253 --> 22:37:36.485
如果我们试着这么做，我会说这行不通。

13639
22:37:36.485 --> 22:38:03.759
尝试执行function, multidecode，包装，公共纯返回，字符串内存，字符串内存，somestring = Avi。decode multiencode包装在字符串中就像我们上面做的那样，如果我们返回一些字符串，你认为会发生什么?让我们试着删除旧的合同，部署一个新的。

13640
22:38:03.814 --> 22:38:10.502
我们会做多重解码，打包，多重编码多重解码，打包，我们会得到一个错误。

13641
22:38:10.502 --> 22:38:14.414
固体基本上是这样的，是的，这里看起来很拥挤。

13642
22:38:14.414 --> 22:38:16.523
我不知道怎么解码。

13643
22:38:16.523 --> 22:38:37.256
但相反，我们能做的是我们能做更多的函数对string cast打包像这样一个public pure返回string memory, string, memory, some string = string, multi然后代码打包，返回一些字符串。

13644
22:38:37.256 --> 22:38:45.359
这个可以正常工作，因为这个契约编码有点类似于类型转换。

13645
22:38:45.359 --> 22:38:53.666
我们会编译并重新部署多字符串强制转换契约，我们得到一些尝试，它更大，对吧?我们这里没有空的地方。

13646
22:38:53.666 --> 22:38:55.617
但我们应该在这里留个空格。

13647
22:38:55.617 --> 22:39:08.581
现在我们已经在ABI点编码和解码中了解了更多，我们知道，这是计算机，这是Aetherium。

13648
22:39:08.581 --> 22:39:11.914
这就是EVM，或者任何与EVM兼容的链所寻找的。

13649
22:39:11.914 --> 22:39:13.639
它在寻找这个字节码。

13650
22:39:13.639 --> 22:39:16.242
它在寻找这个，这个二进制的东西。

13651
22:39:16.242 --> 22:39:22.402
我们刚刚学了一点关于如何将不同的变量编码成二进制到数据位。

13652
22:39:22.402 --> 22:39:39.010
那我们现在怎么办?既然我们知道我们的事务将被编译成二进制的东西，我们能做的就是我们自己用代码将要使用的二进制填充我们事务的数据值。

13653
22:39:39.010 --> 22:39:56.331
这是合约部署的事务，合约部署的数据字段将是函数调用的所有合约二进制代码，数据块将是发送到地址的数据调用到地址的函数。

13654
22:39:56.331 --> 22:40:04.252
让我们来看看另一笔交易以太扫描就在我们的一份合同上，你们不需要我要看看上一节的进入抽奖。

13655
22:40:04.252 --> 22:40:07.011
如果我们选择向下，我们会查看输入数据。

13656
22:40:07.011 --> 22:40:08.978
它说function enter raffle method ID。

13657
22:40:08.978 --> 22:40:14.735
但如果我们看原始数据，这是数据字段发送的数据。

13658
22:40:14.815 --> 22:40:19.142
这是二进制，这是十六进制这是奇怪的，低级字节的东西。

13659
22:40:19.142 --> 22:40:27.847
这就是以太坊区块链或任何你正在使用的EVM链知道调用哪个函数的方式，它将其转换为一个函数。

13660
22:40:27.847 --> 22:40:33.386
我们可以做完全相同的事情，自己调用这些函数。

13661
22:40:33.386 --> 22:40:52.340
我们能用这些新发现的数据和编码做什么呢，我们能做的是将事务的数据字段，在事务调用中发送回以太回调中数据就是合约创建代码。

13662
22:40:52.340 --> 22:41:02.190
相反，我们可以用函数调用代码填充这个数据，也就是我们想在十六进制加法二进制中调用的函数。

13663
22:41:02.190 --> 22:41:15.589
现在你可能会想，哦，好吧，我为什么要这样做，我总是可以使用接口，ABI，所有的东西，好吧，也许你没有这些也许你只有函数名，也许你只有你想发送的参数。

13664
22:41:15.589 --> 22:41:29.593
或者你想让你的代码，能够发送任意函数，或者进行任意调用，或者做一些非常高级的事情，这就是通过填充数据字段直接发送函数调用非常重要的地方。

13665
22:41:29.593 --> 22:41:35.578
记住，我说过，你总是需要ABI和契约地址，发送一个函数。

13666
22:41:35.578 --> 22:41:37.713
当我说，你总是需要API。

13667
22:41:37.816 --> 22:41:45.170
最初，我们讨论的是这个东西，这个很大的东西，很酷，就是API。

13668
22:41:45.170 --> 22:41:50.101
但这就像人类可读的API，你也可以用非人类可读的API。

13669
22:41:50.101 --> 22:41:59.701
另外，你不需要所有这些东西，你可以只使用函数名，然后输入类型来发送函数调用。

13670
22:41:59.701 --> 22:42:44.477
那么问题是，我们如何发送?如何发送调用仅填充数据字段的函数的事务?下一个问题是，如何填充数据字段?我们用什么填充数据字段来进行这些函数调用呢?然后我们如何缓慢地发送这些事务，有一些更低级的关键字，即静态调用和调用我们以前用过调用，这些代码你们熟悉吗?它应该是这样的，因为这是，我们在彩票的实现随机单词中使用了类似的设置，对吧，我们通过最近的winner点调用来发送资金?最近，这是最近的获奖者的地址，我们没有打电话。

13671
22:42:44.477 --> 22:42:49.612
然后括号里有一些奇怪的东西，括号里什么都没有。

13672
22:42:49.612 --> 22:42:56.077
我们之前用过这个call关键字，但我们没有告诉你它是做什么的。

13673
22:42:56.077 --> 22:42:59.494
调用是我们如何调用函数来改变区块链的状态。

13674
22:42:59.494 --> 22:43:10.613
静态调用基本上是在底层，我们调用视图或纯函数，写静态调用会像这样，不要用这个改变区块链的状态，只给我们返回值。

13675
22:43:10.613 --> 22:43:17.910
这类似于低级别的视图或纯函数，也有Send词但基本上还是算了吧。

13676
22:43:17.910 --> 22:43:20.488
我们只会用call，而不是call。

13677
22:43:20.488 --> 22:43:23.259
稍后，我们会学到另一个叫委托调用。

13678
22:43:23.259 --> 22:43:25.080
但现在不用担心这个。

13679
22:43:25.080 --> 22:43:33.572
最近的冬鸭调用是这样的，在这些弯弯曲曲的小括号中，我们说，好，我们直接更新了我们的交易的值。

13680
22:43:33.572 --> 22:43:45.663
如果我们有这些交易字段，我们直接在这些小括号里更新价值，对吧，我们也可以直接在这些小括号里更新天然气有限价格如果我们想的话。

13681
22:43:45.663 --> 22:43:49.160
在这里，这些括号是我们要存放数据的地方。

13682
22:43:49.160 --> 22:43:51.628
因为我们的退出是为了做什么。

13683
22:43:51.628 --> 22:43:53.928
以前的功能是送钱。

13684
22:43:53.928 --> 22:43:58.767
我们说，好吧，送钱改变我们要送的值。

13685
22:43:58.767 --> 22:44:18.591
但不要传递任何数据，保持数据位为空，这就是为什么，记住我们之前是怎么点击这个按钮的我们调用了data be empty，这实际上是运行这个命令，调用了data be空这个部分为空，然后更新我们用事务设置的值。

13686
22:44:18.591 --> 22:44:23.372
这部分我们可以用来填充数据来调用特定的函数。

13687
22:44:23.372 --> 22:44:25.368
我们会在这里放更多的注释。

13688
22:44:25.368 --> 22:44:29.259
因此，当我们使用弯弯曲曲的括号时，我们能够传递一个事务的特定字段，比如value。

13689
22:44:29.259 --> 22:44:34.117
在括号里，我们可以传递数据来调用一个特定的函数。

13690
22:44:34.117 --> 22:44:43.105
但在这里，没有函数可以调用因为我们只是发送它们如果我们想调用函数或发送任何数据，我们可以在括号中做。

13691
22:44:43.105 --> 22:44:47.834
我想我拼错了。

13692
22:44:47.834 --> 22:44:50.718
现在，我们已经学到了很多。

13693
22:44:50.718 --> 22:44:53.428
让我们快速复习一下刚刚学过的内容。

13694
22:44:53.428 --> 22:44:59.172
然后我们将学习如何调用任何函数通过使用这里的语法。

13695
22:44:59.172 --> 22:45:06.193
我们从很高级的地方学过，如果我们想组合字符串，我们可以做ABI。encode wrapped，然后类型转换为字符串。

13696
22:45:06.193 --> 22:45:15.741
在solidity的新版本中，你可以做string。concat，你知道，嗨，妈妈，来吧，想你。

13697
22:45:15.741 --> 22:45:17.507
在新的固体版本中。

13698
22:45:17.507 --> 22:45:20.197
这同样有效，但在较老版本的固体中无效。

13699
22:45:20.197 --> 22:45:37.751
然后我们学到了很多低级的东西，当我们编译合同时，我们得到一个ABI文件，这个奇怪的二进制文件，数字和字母当我们部署合同时它被发送到合同创建事务的数据字段中。

13700
22:45:37.818 --> 22:45:47.979
对于契约创建，数据会被二进制代码填充函数调用会定义调用哪个函数用什么形参这就是我们接下来要讲的。

13701
22:45:47.979 --> 22:45:54.394
现在，我们知道了我们可以把东西编码成二进制，编码成低级代码。

13702
22:45:54.394 --> 22:46:07.818
任何程序任何进程，只要能读取这个底层的东西并相应执行，读取这个EVM的东西，读取Aetherium指定的特定二进制文件，或者EVM指定的，都被认为是EVM。

13703
22:46:07.818 --> 22:46:08.632
兼容的。

13704
22:46:08.632 --> 22:46:14.468
我们可以编码数字，我们可以编码字符串，我们几乎可以编码任何我们想编码的东西。

13705
22:46:14.468 --> 22:46:25.750
为了节省空间，我们会打包编码，我们可以解码已经编码的东西，但我们不能解码打包编码的东西，我们可以多重编码，然后多重解码。

13706
22:46:25.750 --> 22:46:33.676
最后，我们可以使用调用函数在这里添加数据来对智能合约进行任何调用。

13707
22:46:33.676 --> 22:46:35.723
这就是我们接下来要学的。

13708
22:46:35.819 --> 22:46:39.751
好了，现在是休息的好时间了，因为我们刚刚学了一些非常难的概念。

13709
22:46:39.751 --> 22:46:44.345
就像我说的，如果你第一次没有理解，没关系。

13710
22:46:44.345 --> 22:46:47.432
好了，欢迎回来。

13711
22:46:47.432 --> 22:47:07.996
现在我们已经学习了编码，让我们学习如何填充这个括号这个数据域，这样我们就可以调用任何函数，我们基本上可以做，区块链在底层要做什么，我们可以使用二进制，我们可以使用字节，我们可以使用十六进制来与智能合约交互。

13712
22:47:07.996 --> 22:47:09.474
让我们创建一个新文件。

13713
22:47:09.474 --> 22:47:15.752
我们会调用它调用任何东西，这些都是从spdx开始的，许可标识符，MIT。

13714
22:47:15.752 --> 22:47:17.287
我们来谈谈这个。

13715
22:47:17.287 --> 22:47:28.115
为了调用为了只使用调用的数据字段来调用一个函数，我们需要编码函数名，以及我们想要添加的参数，因为当我们调用一个函数时，我们调用函数名。

13716
22:47:28.115 --> 22:47:30.115
我们称之为参数。

13717
22:47:30.115 --> 22:47:39.930
所以我们需要将这些编码到二进制级别，这样EVM或这些基于以太的智能合约和实体就能理解实际发生了什么。

13718
22:47:39.930 --> 22:47:51.369
为了做到这一点，我们需要使用两个概念来编码函数名，这样EVM或实体就能理解它，我们实际上必须抓取一个叫做函数选择器的东西。

13719
22:47:51.369 --> 22:47:56.019
现在函数选择器将是函数签名的前四个字节。

13720
22:47:56.019 --> 22:48:00.786
函数签名是一个字符串，它定义了函数的形参名。

13721
22:48:00.819 --> 22:48:07.270
这到底是什么意思呢?如果我们有一个传递函数，这就是函数的特征。

13722
22:48:07.270 --> 22:48:09.520
函数名是transfer。

13723
22:48:09.520 --> 22:48:22.992
它会取一个地址和256作为它的输入，如果我们编码这个传递函数，然后取它的前四个字节，我们得到这个，它指向函数选择器。

13724
22:48:22.992 --> 22:48:24.992
这就是固体是如何知道的。

13725
22:48:24.992 --> 22:48:35.328
在字节码中，在二进制代码中，这个函数选择器是劈开知道的，哦，他们说的是传递函数他们想让我调用传递函数。

13726
22:48:35.328 --> 22:48:48.521
这是我们使用调用来调用任何我们想要的函数时需要做的第一件事之一，我们需要得到函数选择器我们可以通过很多不同的方式得到它但其中一种方式是通过编码函数签名并获取前四个字节。

13727
22:48:48.521 --> 22:48:54.070
我们创建这个契约，pragma solidity 0,8。

13728
22:48:54.070 --> 22:48:57.177
7说合同，什么都可以。

13729
22:48:57.177 --> 22:49:10.320
我们把这个赋给存储的变量，赋给存储的变量并赋给public s，下划线表示某个数量，或者某个地址，然后在256中，public s下划线表示mount。

13730
22:49:10.320 --> 22:49:13.241
然后我们会创建一个函数叫做传递函数传递。

13731
22:49:13.241 --> 22:49:27.336
通常在这里，我们会做一个像ERC 20的转账，但我们只会做一个地址一个地址，然后你在这里添加256个金额，这里是金额，我们会让它成为一个公共函数。

13732
22:49:27.336 --> 22:49:34.070
然后我们要做的就是设S，某个地址等于某个地址，然后S的金额等于金额。

13733
22:49:34.070 --> 22:49:37.820
这就是我们要处理的函数。

13734
22:49:37.820 --> 22:49:42.968
这个函数的函数选择器是这个，函数签名是这个。

13735
22:49:42.968 --> 22:49:49.368
它取一个地址一个地址量，它被归结为函数选择器和函数签名。

13736
22:49:49.368 --> 22:49:55.476
当然，在字节码中，会有一些代码说，好，这是这个函数的功能，等等等等。

13737
22:49:55.476 --> 22:49:58.402
我们甚至可以写一个函数来得到那个函数选择器。

13738
22:49:58.402 --> 22:50:06.852
我们可以说，function, getselector我要说，getselector 1，因为我会给你们展示一些获取函数选择器的方法，我们会把这个设为公共纯。

13739
22:50:06.852 --> 22:50:25.691
我们会让这个返回一个bytes for selector，我们可以说selector = bytes for，然后我们哈希到签名的56个字节，也就是transfer。

13740
22:50:25.821 --> 22:50:29.545
它需要一个地址和一个UNT 56。

13741
22:50:31.821 --> 22:50:38.227
这个，然后我们运行它，让我们摆脱旧的合同，部署，确保我们随时待命，如果你有另一个。

13742
22:50:38.227 --> 22:50:47.725
在这里，我们有一些东西，我们点击Get selector 1，我们得到这个哦X，一个905，等等等等。

13743
22:50:47.821 --> 22:50:49.493
这和我刚才举的例子是一样的。

13744
22:50:49.821 --> 22:51:04.337
这里告诉我们的是可靠度告诉我们的智能合约，当我们调用这个合约时，如果你在函数数据中看到这个，它指的是我们的传递函数有一个地址和一个un256作为输入参数。

13745
22:51:04.337 --> 22:51:06.280
所以我们看到你进入56。

13746
22:51:06.280 --> 22:51:09.230
我们的函数知道执行这里的数据。

13747
22:51:09.230 --> 22:51:09.623
太好了。

13748
22:51:09.821 --> 22:51:12.221
当然，sml和S地址都是0。

13749
22:51:12.821 --> 22:51:21.288
我们在这里，我们也可以看到，如果我们调用传递函数会发生什么?它需要一个地址和一个金额，所以我们给它自己的地址或地址。

13750
22:51:21.288 --> 22:51:23.132
我们可以用777。

13751
22:51:23.132 --> 22:51:28.768
如果我们点击转移，我们会打开日志，我们会在这里得到一个小的标记，表示成功。

13752
22:51:28.822 --> 22:51:31.355
如果达到S值，就得到777。

13753
22:51:32.822 --> 22:51:35.383
都是一样的，对吧?这就是我们直接调用的转移。

13754
22:51:35.383 --> 22:51:43.789
当我们直接调用转移时，我们基本上是在说，抓取这个函数选择器，然后做一些其他的事情，我们一会儿会告诉你们其他的事情。

13755
22:51:43.822 --> 22:51:45.558
现在我们有了函数选择器。

13756
22:51:45.558 --> 22:51:46.189
好了,好了。

13757
22:51:46.822 --> 22:51:49.628
我们还需要我们想要添加的参数。

13758
22:51:49.822 --> 22:51:55.388
我们需要用函数选择器来编码这些参数。

13759
22:51:55.388 --> 22:52:00.640
我们要做的是，function，获取数据，调用transfer。

13760
22:52:00.640 --> 22:52:14.644
在这里，我们会有这个get data来调用transfer，我们会让它接受这些输入参数，我们会对这些进行编码以与我们的函数选择器一起工作，我们会说address，某个地址。

13761
22:52:14.644 --> 22:52:22.640
如果它是x, amount, public pure返回字节内存。

13762
22:52:22.822 --> 22:52:27.822
然后我们可以返回并使用小抄中的ABI和代码之一。

13763
22:52:27.822 --> 22:52:31.676
到目前为止，我们一直在做API和编码。

13764
22:52:31.676 --> 22:52:38.222
因为我们有函数选择器，我们可以用ABI。encode with selector。

13765
22:52:38.222 --> 22:52:43.516
这个ABI从第二个参数和前置参数开始编码给定的参数，即给定的四字节选择器。

13766
22:52:43.516 --> 22:52:49.063
当我们在Cobra选择器中做时，我们只是把选择器粘到我们会给它的数据上。

13767
22:52:49.063 --> 22:52:54.408
我们会返回API。encode with select door。

13768
22:52:54.408 --> 22:53:04.357
我们会把get selector 1的结果传递给它，然后我们会给它一些地址和数量。

13769
22:53:04.357 --> 22:53:18.203
它会给我们所有需要放到交易数据域中的数据，发送给这个合约让这个合约知道，使用传递函数，传入一个地址和一个金额。

13770
22:53:18.203 --> 22:53:34.177
然后我们编译这个，运行它，删除旧合同，然后部署，我们有一个新函数叫Get Data来调用和转移，我们只传递这个合同地址然后我们再做一次777。

13771
22:53:34.177 --> 22:53:42.661
这里这个东西是我们要放到事务数据域中的以便我们能从任何地方调用转移。

13772
22:53:42.661 --> 22:53:51.623
这是字节，这是二进制编码的数据，用我们指定的地址调用传递函数。

13773
22:53:51.623 --> 22:53:53.156
你知道，777mt。

13774
22:53:53.156 --> 22:54:00.823
一旦我们有了这些，我们可以调用传递函数而不用直接调用它。

13775
22:54:00.823 --> 22:54:18.117
我们能做的是，我们可以说函数，直接调用传递函数，我想用二进制可能是一个更好的标题，但你知道要点，我们会说地址某个地址，你在256中，我们会让它成为一个公共函数。

13776
22:54:18.117 --> 22:54:21.244
我们会有a返回一个字节4和一个bool。

13777
22:54:21.244 --> 22:54:23.353
你马上就会知道为什么了。

13778
22:54:23.353 --> 22:54:28.161
我们会像送奖券时那样打电话。

13779
22:54:28.161 --> 22:54:33.937
我们要做的是，在我们做recent winner。call之前，我们要做一些地址。

13780
22:54:33.937 --> 22:54:37.073
然后对我们来说，我们要处理这个点调用。

13781
22:54:37.073 --> 22:54:49.774
然后我们说这个契约地址我们可以把任何地址放在这里地址。调用，我们将调用编码的数据它指向带有一些参数的传递函数。

13782
22:54:49.774 --> 22:54:52.004
所以我们要解决这个问题。

13783
22:54:52.004 --> 22:54:52.200
com。

13784
22:54:52.200 --> 22:55:00.574
我们可以获取数据来调用转移地址金额，对，我们可以这样做。

13785
22:55:00.574 --> 22:55:03.044
或者我们也可以用一种错误的方法。

13786
22:55:03.044 --> 22:55:11.193
我们可以用ABI。和code，用select dorm，得到selector 1，逗号，一些地址，逗号amount。

13787
22:55:11.193 --> 22:55:14.146
抱歉，这里没有分号。

13788
22:55:14.146 --> 22:55:16.372
所以它们是一样的。

13789
22:55:16.372 --> 22:55:22.352
这个点调用的东西，它会返回我们之前看到的，它会返回bool success。

13790
22:55:22.352 --> 22:55:32.098
无论事务是否成功，然后是字节，内存，返回的数据，也就是调用返回的东西。

13791
22:55:32.098 --> 22:55:35.350
这就是我们需要成功的地方，对吧。

13792
22:55:35.350 --> 22:55:42.013
但对我们来说，我们只会返回字节，一个返回数据有四个字节，然后成功。

13793
22:55:42.013 --> 22:55:47.146
我们只会返回返回数据的前四个字节。

13794
22:55:47.146 --> 22:55:49.690
然后我们会返回这个是否成功。

13795
22:55:49.690 --> 22:56:01.760
这个函数会让我们直接调用传递函数通过传递这些参数而不需要我们做契约。转移，或者转移什么的。

13796
22:56:01.824 --> 22:56:08.157
你可以在多个合同中这样做在不同的合同中，只需要改变你调用的地址。

13797
22:56:08.157 --> 22:56:09.823
让我们来编译这个。

13798
22:56:09.823 --> 22:56:13.582
我们现在运行这个删除旧合同，部署调用任何东西。

13799
22:56:13.582 --> 22:56:14.908
现在如果我们如果我们。

13800
22:56:14.908 --> 22:56:18.109
现在sml和估计量都是0。

13801
22:56:18.109 --> 22:56:26.735
现在，如果我们直接调用转移函数，我们会传入这个的地址，然后我们会做777。

13802
22:56:26.825 --> 22:56:33.491
如果我们调出日志，点击这个，我们会得到这个事务响应。

13803
22:56:33.491 --> 22:56:42.200
但如果向下滚动，我们会看到解码后的输出，也就是一串0的字节，对吧?因为我们的转移实际上没有返回任何东西。

13804
22:56:42.200 --> 22:56:47.028
它会是一堆0，然后我们的布尔值为真，这意味着成功了。

13805
22:56:47.028 --> 22:56:51.758
既然成功了，这两个就应该在此基础上做出改变。

13806
22:56:51.825 --> 22:56:53.497
我们来试一下。

13807
22:56:54.825 --> 22:56:55.792
他们改变了。

13808
22:56:58.825 --> 22:57:05.750
函数而不必调用传递函数本身，我们也可以用签名而不是选择器进行编码。

13809
22:57:05.825 --> 22:57:20.934
如果我们去我们的小抄，下面这里也有这个encode with signature，它接受字符串内存签名，它等价于做ABI。encode with selector bytes for CAC bytes，你知道，signature，它等价于做我们在上面做的事情。

13810
22:57:20.934 --> 22:57:23.199
但它为我们完成了这一步。

13811
22:57:23.199 --> 22:57:39.753
我们可以复制这整个东西，粘贴到这里，我们可以不用selector编码，我们可以用SIG netshare编码，函数签名，然后我们会从上面这里复制函数签名，粘贴到这里。

13812
22:57:39.825 --> 22:57:51.857
编译时，我们碰到了编译错误，上来，这些都是直接调用SIG的转移函数，叫做Compile, leader, old contract, deploy。

13813
22:57:51.857 --> 22:57:54.375
现在这两个又都是0。

13814
22:57:54.375 --> 22:57:58.954
现在如果我们复制合同地址，我们直接调用合同呼叫转移功能SIG。

13815
22:57:58.954 --> 22:58:05.761
我们把它粘贴到这里，我们把它叫做777，让我检查一下我们可以看到它做了完全相同的事情。

13816
22:58:05.761 --> 22:58:08.316
这是API。encode with signature。

13817
22:58:08.316 --> 22:58:10.061
这是abi。encode selector。

13818
22:58:10.061 --> 22:58:13.873
Encode with signature只是把我们变成了selector。

13819
22:58:13.873 --> 22:58:17.235
这些都在上面，我们自己编码了这个选择器。

13820
22:58:17.235 --> 22:58:20.580
有很多不同的方法来获取选择器。

13821
22:58:20.580 --> 22:58:22.283
我们不会自己把这些编码出来。

13822
22:58:22.283 --> 22:58:27.747
这里有很多不同的获取selector的方法。

13823
22:58:27.747 --> 22:58:35.626
谁知道为什么呢为什么你会想用其他的理由，对吧?有很多原因可以解释为什么你想用不同的方式获得selector。

13824
22:58:35.626 --> 22:58:43.404
在这个视频中，我们不打算解释或复习所有这些不同的所有这些不同的函数选择器获取方法。

13825
22:58:43.404 --> 22:58:48.995
但如果你在与本课程相关的GitHub回购中浏览它们，它们都有大量注释来解释它们在做什么。

13826
22:58:48.995 --> 22:58:55.645
我们会向你们展示，合约之间是如何交互的而不需要每个合约的所有代码。

13827
22:58:55.645 --> 22:59:04.219
我们来做第二个契约它包含所有的二进制这个字节信息来调用另一个契约上的传递函数。

13828
22:59:04.219 --> 22:59:06.333
我们将向你展示这是如何工作的。

13829
22:59:06.333 --> 22:59:10.342
这是我做的另一个契约，叫做call function without contract。

13830
22:59:10.342 --> 22:59:41.629
实际上,下面,我们将调用传递函数,通过使用函数选择器的地址和签名和东西,我们会更新这些存储变量调用什么合同从另一个合同就这样二进制打电话,如果你愿意,是的,让我们编译、部署,我们就可以离开这了吧,我们可以离开这个让我们部署调用函数没有合同,我们将把它作为输入参数,只要是合同地址，我们就部署。

13831
22:59:41.629 --> 22:59:54.679
在这里，我可以直接调用传递函数。也许我可以把它切换到这里，这个合约地址这个新的合约地址，我们给它一个新数字123。

13832
22:59:54.679 --> 22:59:57.695
好的，我们点击呼叫转移函数。

13833
22:59:57.827 --> 23:00:01.093
然后当我们回到这里，我们看到这个确实被更新了。

13834
23:00:01.093 --> 23:00:04.284
现在做这种电话工作被认为是低水平的。

13835
23:00:04.284 --> 23:00:07.160
最好的做法是尽量避免。

13836
23:00:07.160 --> 23:00:10.318
如果你能导入一个接口，最好这样做。

13837
23:00:10.318 --> 23:00:16.646
因为编译器在你这边，你就能检查你的类型是否匹配等等。

13838
23:00:16.646 --> 23:00:24.827
通常在做这些低级调用时一些安全审计检查人员可能会说，嘿，比如这本书出了一点，你在做这些低级的东西。

13839
23:00:24.827 --> 23:00:29.810
但话虽如此，你们已经学到了很多关于低能级固体的知识。

13840
23:00:29.810 --> 23:00:31.531
这是一些非常高级的东西。

13841
23:00:31.531 --> 23:00:41.663
就像我说的，如果这很难，如果你有点困惑，别担心，你可以回到这部分再试一次，当你更高级一点的时候，如果你想现在就试着理解它。

13842
23:00:41.663 --> 23:00:42.187
太棒了。

13843
23:00:42.187 --> 23:00:57.536
当然，我们在GitHub上留下了一些与这节课相关的链接我强烈建议你们去看看其中一个你们一定要去看看的链接，它将是openzeppelin对实体的解构，它真正地分解了契约幕后发生的事情。

13844
23:00:57.536 --> 23:01:05.730
如果你想了解更多关于操作码的知识，关于低级别的东西，一定要读一读这个，它是一个了不起的读本，本质上，它比我们刚才讲的分解得要多一些。

13845
23:01:05.730 --> 23:01:07.665
还有其他几个视频。

13846
23:01:07.665 --> 23:01:10.303
我在这里也留下了很多链接。

13847
23:01:10.303 --> 23:01:18.239
话虽如此，现在我们又回到了非功能性的节目。

13848
23:01:18.239 --> 23:01:27.448
现在我们知道了ABI点编码的所有东西以及它的作用，我们知道ABI点编码包装，我们在这里使用的方法只是连接字符串的一种方法。

13849
23:01:27.448 --> 23:01:33.643
我们不会用ABI。encode来实现它的超能力，但我们会在后面的课程中用到。

13850
23:01:33.643 --> 23:01:47.177
在另一种情况下，我们使用我们导入的以64为基数的点编码，我们导入这个以64为基数的点编码这样我们就可以编码我们传递给SVG的以64为基数的编码。

13851
23:01:47.177 --> 23:01:49.565
我要复制粘贴一个例子，你不需要这么做。

13852
23:01:49.565 --> 23:02:06.387
比如，我们会传入SVG width =等等，所有这些SVG的东西，有点类似于我之前给你们看的，我们把它作为输入参数传入，然后输出，我们会得到它的64进制编码，我们会得到这个巨大的字符串。

13853
23:02:06.387 --> 23:02:09.150
稍后我们将对此进行测试，以确保其工作正常。

13854
23:02:09.150 --> 23:02:13.957
通常情况下，如果我现在像这样添加一个函数，我可能会立即测试它。

13855
23:02:13.957 --> 23:02:15.336
现在我们可以把它放在这里。

13856
23:02:15.336 --> 23:02:18.086
这对得到这张图很有帮助。

13857
23:02:18.086 --> 23:02:22.935
但我们不只是想要一个图像，对吧?我们需要元数据。

13858
23:02:22.935 --> 23:02:34.680
我们需要这是一个JSON对象，而不仅仅是像这样的图像URL，我们需要将这个图像，这个base64编码的图像粘贴到JSON的图像字段中。

13859
23:02:34.680 --> 23:02:49.090
那么我们要怎么做呢?我们能做的是，我们知道我们的ERC 721代码带有一个令牌URI，正是那个令牌URI指向这个，它告诉我们我们的代码是什么样的。

13860
23:02:49.090 --> 23:02:57.128
我们能做的是我们也能以64为基数编码我们的JSON，把它变成一个JSON令牌URI。

13861
23:02:57.128 --> 23:03:03.021
我们对这个图像进行了编码得到这个，我们将把这个URL插入到JSON中。

13862
23:03:03.021 --> 23:03:09.579
然后我们用64进制编码JSON，那将是令牌使用的URI。

13863
23:03:09.579 --> 23:03:12.844
我们有了函数，令牌URI。

13864
23:03:12.844 --> 23:03:23.540
这需要一个un 256令牌ID，我们会说它将是一个公共视图，公共视图覆盖，它返回一个字符串内存。

13865
23:03:23.540 --> 23:03:30.695
所以我们将重写ERC 721的令牌URI函数，让它变成我们想要的样子。

13866
23:03:30.695 --> 23:03:45.162
这里我们将把合约中的一些JSON文本编码成一个基于base64的JSON令牌URI首先，我们需要一个下划线exists。

13867
23:03:45.162 --> 23:03:52.283
Token ID，然后我说你的I查询不存在的Token。

13868
23:03:52.283 --> 23:03:57.863
对，这个价格应该是如果不存在，返回错误。

13869
23:03:57.863 --> 23:04:00.216
但是，我们要这样做。

13870
23:04:00.216 --> 23:04:04.764
这个存在函数在我的耳朵里，c721。

13871
23:04:04.764 --> 23:04:06.729
我们在这里做同样的事情。

13872
23:04:06.729 --> 23:04:08.568
我们会说，需要这个令牌，D存在。

13873
23:04:08.568 --> 23:04:09.872
同样，我们可以百分之百。

13874
23:04:09.872 --> 23:04:22.047
也许应该把这个设为IF EXISTS令牌ID，现在我们要做的是弄清楚如何让这个令牌URI返回这个JSON的64进制编码版本。

13875
23:04:22.047 --> 23:04:28.151
首先，我们知道如何连接一个字符串，这是我们要做的第一件事。

13876
23:04:28.151 --> 23:04:30.000
我们会用API。和代码打包。

13877
23:04:30.000 --> 23:04:42.392
我们将在chain上编码JSON，这里我们将使用单引号，因为在这个API和代码包中，我们将在这里使用双引号这是我们将添加JSON的地方。

13878
23:04:42.392 --> 23:04:47.563
我们会给出一个名字，第一个元数据需要是一个名字。

13879
23:04:47.563 --> 23:04:49.417
我们给它起个名字。

13880
23:04:49.417 --> 23:04:51.559
我们在这里加个逗号。

13881
23:04:51.559 --> 23:05:00.030
我们会说这个NF T的名字是我们得到的名字，我们有一个名字函数，它会返回这个名字。

13882
23:05:00.030 --> 23:05:02.071
所以我们会说名字就是名字。

13883
23:05:02.071 --> 23:05:05.145
我们要把这些东西连起来，名字就在这里。

13884
23:05:05.145 --> 23:05:07.417
我们将继续讨论JSON。

13885
23:05:07.417 --> 23:05:11.022
这里加个引号，这里也加个引号。

13886
23:05:11.022 --> 23:05:22.088
我们把这个名字封装在引号里，对吧?因为记住，我们是在连接，我们在这里做的这个大字符串，我们会用逗号，我们会说，description，我们会用另一个引号。

13887
23:05:22.088 --> 23:05:42.655
这一次，我们会把描述自己放进去，我们会说，NFT，基于链链接提要的变化，我们会在这里放一个结束引号和一个逗号，我们会在引号外面放一个逗号，在下面这里，我们会说，属性。

13888
23:05:42.830 --> 23:05:52.387
我们会说，特质类型，应该是酷。

13889
23:05:53.830 --> 23:05:55.480
价值，我是100。

13890
23:05:55.480 --> 23:05:58.781
砰，到一个逗号的图像。

13891
23:06:01.830 --> 23:06:02.110
在这里。

13892
23:06:05.830 --> 23:06:08.636
image URI，我们需要从某处获取。

13893
23:06:08.830 --> 23:06:12.718
现在，我要说的是string。

13894
23:06:12.830 --> 23:06:17.263
内存图像URI等于i，对吧，这显然不是到达的图像。

13895
23:06:17.263 --> 23:06:19.846
但是为了形成这种格式，我们把它放在这里。

13896
23:06:19.846 --> 23:06:25.414
这是我们把从SVG得到的图像URI放入图像URI的地方。

13897
23:06:25.414 --> 23:06:26.989
就这样了。

13898
23:06:26.989 --> 23:06:29.766
我的意思是关闭JSON。

13899
23:06:29.766 --> 23:06:34.210
做ABI。encode pack会把这些连在一起。

13900
23:06:34.210 --> 23:06:37.259
这基本上就是一个像这样的字符串。

13901
23:06:37.259 --> 23:06:37.544
太好了。

13902
23:06:37.544 --> 23:06:46.798
但是我们怎么把它变成一个64进制编码的令牌让其他人可以读它呢?我们要把整个东西类型转换成字节。

13903
23:06:46.798 --> 23:06:54.363
现在这一切都是以字节为单位的，我们就可以像上面的SVG那样进行64进制编码了。

13904
23:06:54.363 --> 23:06:56.943
我们用64进制。ENCODE。

13905
23:06:56.943 --> 23:07:01.749
然后我们在这个保存并自动格式化旁边再加一对括号。

13906
23:07:01.749 --> 23:07:10.584
这里会给我们第二行，对吧，它会给我们这所有的位，但不会给我们第一个位，对吧。

13907
23:07:10.584 --> 23:07:12.847
我们现在只需要把第一点加进去。

13908
23:07:12.847 --> 23:07:14.201
我们应该可以出发了。

13909
23:07:14.201 --> 23:07:26.798
数据图像SVG之前的基础知识加上XML基础知识，这是图像SVG图像的前缀，对吧?我们在上面使用它是因为它是SVG图像的前缀。

13910
23:07:26.798 --> 23:07:28.003
64进制的前缀。

13911
23:07:28.003 --> 23:07:33.581
Jason将会是数据应用JSON，以64为基数。

13912
23:07:33.581 --> 23:07:36.206
所以我们要这样做。

13913
23:07:36.206 --> 23:07:42.492
ERC 721有一个叫做基URI的东西我们会重写它我们会使用它。

13914
23:07:42.492 --> 23:07:45.468
我们说，function，下划线，base URI。

13915
23:07:45.468 --> 23:07:47.795
这是内纯的。

13916
23:07:47.795 --> 23:07:50.896
我们要推翻ERC 721的决定。

13917
23:07:50.896 --> 23:07:54.307
这将返回一个字符串内存。

13918
23:07:54.307 --> 23:07:58.997
我们将返回这里的这一点。

13919
23:07:58.997 --> 23:08:01.747
现在我们可以使用这个基URI。

13920
23:08:01.747 --> 23:08:07.848
我们要把第一部分附加到64编码的JSON中。

13921
23:08:07.848 --> 23:08:15.110
为了追加它们，我们再次写入ABI。ENCODE, wrapped。

13922
23:08:15.110 --> 23:08:19.569
然后把这个写下来。

13923
23:08:19.832 --> 23:08:25.170
我们会说，我们会把基URI连接到我们刚创建的这个庞大的东西。

13924
23:08:25.170 --> 23:08:31.181
然后我们保存，我们应该格式化这显然是一个字节对象，我们希望它是一个字符串。

13925
23:08:31.181 --> 23:08:48.139
然后我们要做的是将它类型转换为字符串，但另一个打印看到下面这里，然后我们实际上只返回这个，但基本上我们所做的是创建一个JSON字符串，我们用字节编码它，这样我们就可以用64进制编码它。

13926
23:08:48.139 --> 23:08:58.225
一旦我们用64进制编码，就像第二个字符串，就像这里，然后我们只需要附加这个初始部分。

13927
23:08:58.225 --> 23:09:03.044
但对于JSON对象，它是数据应用程序JSON。

13928
23:09:03.044 --> 23:09:09.882
我们添加API。encode packed，然后将它转换为字符串，然后我们就有了一个令牌URI。

13929
23:09:09.882 --> 23:09:11.454
就像这样。

13930
23:09:11.454 --> 23:09:19.635
然后我们要做的就是更新我们的图像URI用我们从函数appear中得到的东西，然后我们就可以开始了。

13931
23:09:19.635 --> 23:09:23.323
我们把这个做完。

13932
23:09:23.323 --> 23:09:25.388
让我们开始吧。

13933
23:09:25.832 --> 23:09:29.979
在构造函数中，我们传递了一个低SVG和一个高SVG。

13934
23:09:29.979 --> 23:09:39.159
这些低SVG是什么，在这些高SVG中也是什么，基本上是说，当资产的价格太低时，表现出不满。

13935
23:09:39.159 --> 23:09:43.098
当资产价格高的时候，露出笑脸。

13936
23:09:43.098 --> 23:09:51.483
我们将给它这个皱眉，SVG和这个快乐SVG作为输入参数，低CG和高SVG，我们可能想要保存它们。

13937
23:09:51.483 --> 23:09:55.306
但我们不一定要以SVG格式保存它们。

13938
23:09:55.306 --> 23:10:02.445
我们只需要存储图像URI，我们只需要存储上面这个字符串而不是实际的SVG。

13939
23:10:02.445 --> 23:10:17.409
在构造函数中，我们可以I _ low image URI =，我们有这个SVG来成像你的眼睛函数，我们可以传递low SVG。

13940
23:10:17.409 --> 23:10:22.095
然后我们可以对高图像URI做同样的事情。

13941
23:10:22.095 --> 23:10:26.770
现在，SVG imageuri将返回像这样的东西。

13942
23:10:26.833 --> 23:10:31.155
我们将只存储这个字符串这个图像URI在chain上。

13943
23:10:31.155 --> 23:10:35.110
现在我们有了这两个，我们可以在下面使用它。

13944
23:10:35.110 --> 23:10:46.751
在我们的token Uri函数中，当有人调用token时，你的I有令牌ID为0，我们会插入到JSON中，低图像或I或高图像到达。

13945
23:10:46.833 --> 23:10:49.196
而我们实际上是基于价格供给的。

13946
23:10:49.196 --> 23:10:55.062
我们怎么做呢?好吧，我们之前已经使用过价格传输，所以让我们继续并添加它。

13947
23:10:55.062 --> 23:10:58.236
所以纱加破折号开发在链条斜杠合同。

13948
23:10:58.236 --> 23:11:07.942
在顶部完成之后，我们可以import at chain link / SRC / v0。

13949
23:11:07.942 --> 23:11:16.478
8、斜杠接口，斜杠ag reg gate, Tor V三个接口，那灵魂就像这样。

13950
23:11:16.478 --> 23:11:20.639
然后下面这里，把它注释掉。

13951
23:11:20.833 --> 23:11:27.352
现在，我们想调用一个价格提要来找出价格然后根据这个显示高的图像或低的图像。

13952
23:11:27.352 --> 23:11:32.963
为了在构造函数中获得价格提要，我们添加另一个价格提要地址，街道地址。

13953
23:11:32.963 --> 23:11:35.946
然后我们再设一个变量。

13954
23:11:35.946 --> 23:11:40.994
我们会聚合Tor v3接口。

13955
23:11:40.994 --> 23:11:46.146
内部的，不可变的，我强调价格供给。

13956
23:11:46.146 --> 23:11:57.300
我们会在构造函数中说，I price feed =聚合Tor v3接口，在price feed，地址处。

13957
23:11:57.300 --> 23:12:09.749
然后我们可以在这里做的是，这里的一堆逗号变成256 Price，逗号，逗号= i Price提供最新一轮数据。

13958
23:12:09.749 --> 23:12:22.096
我们能做的是我们可以说如果价格大于或等于某个值，那么显示一个图像干，否则，显示另一个。

13959
23:12:22.096 --> 23:12:30.199
所以我们可以说字符串内存，图像URI等于s下划线low图像URI。

13960
23:12:30.199 --> 23:12:39.255
然后如果价格高于某个值，大于我们将要使用的图像URI AI将等于高图像URI。

13961
23:12:39.255 --> 23:12:41.884
下面这里是图像。

13962
23:12:41.884 --> 23:12:44.161
我们要做的就是算出价格。

13963
23:12:44.161 --> 23:12:51.990
所以我们可以，我们会让导师选择他们想要使用的价值。

13964
23:12:51.990 --> 23:12:58.562
所以我们可以说，在256中，I值我们会给每个非ft赋值，它们自己的高值。

13965
23:12:58.562 --> 23:13:06.047
我们需要在上面创建一个小映射，我们说，映射，你到56。

13966
23:13:06.047 --> 23:13:08.342
第二，你去了56。

13967
23:13:08.342 --> 23:13:17.431
让我们把它设为public public s的下划线令牌ID设为high value。

13968
23:13:17.431 --> 23:13:27.390
我们会说，当他们说nft会做s token ID to high value, s下划线token counter。

13969
23:13:27.390 --> 23:13:30.167
我们设它等于高值。

13970
23:13:30.167 --> 23:13:33.851
所以当他们选择他们想要的高值时。

13971
23:13:33.851 --> 23:13:42.763
然后在下面这里，如果价格大于或等于令牌ID的高值，那么我们就使用高值的那个。

13972
23:13:42.835 --> 23:13:44.028
否则，我们就用低的那个。

13973
23:13:44.835 --> 23:13:47.496
把你变成视频x 2变成256。

13974
23:13:49.835 --> 23:13:52.286
能够相当平等地比较它们。

13975
23:13:53.835 --> 23:13:54.657
看起来不错。

13976
23:13:56.835 --> 23:13:57.869
可能是一个事件。

13977
23:13:59.835 --> 23:14:03.597
我们遇到了其中一个NF T。

13978
23:14:05.835 --> 23:14:12.235
创建NF T，会说你去了56索引token ID, int 256。

13979
23:14:12.235 --> 23:14:14.368
我认为是这样的。

13980
23:14:14.368 --> 23:14:25.735
然后当我们遇到这个非ft时，会做emit create nt, s下划线token counter，逗号，I值。

13981
23:14:25.835 --> 23:14:31.157
最好的做法是在造币之前更新令牌计数器。

13982
23:14:31.157 --> 23:14:32.106
我们也会做这个。

13983
23:14:32.106 --> 23:14:34.343
这里有很多代码。

13984
23:14:34.343 --> 23:14:44.569
就像我说的，我们肯定不会在没有编译运行一些测试的情况下写所有的代码，但我们决定先把它写好。

13985
23:14:44.569 --> 23:14:46.436
所以我犯了一些拼写错误。

13986
23:14:46.436 --> 23:14:48.736
让我们确保所有东西都编译好了。

13987
23:14:48.836 --> 23:14:49.073
太棒了。

13988
23:14:49.073 --> 23:14:49.988
所有的东西都在这里。

13989
23:14:50.836 --> 23:14:53.787
我们需要做几件事来验证这一点。

13990
23:14:53.836 --> 23:15:03.398
我们需要做的第一件事是写部署函数，我们有基本的NFT，我们有random和ft，这两个都托管在IPFS上。

13991
23:15:03.398 --> 23:15:13.767
现在我们要做一个100%托管在链上的动态非ft，它会根据资产的价格变化。

13992
23:15:13.767 --> 23:15:17.870
我们来做这个。

13993
23:15:17.870 --> 23:15:26.012
哦，第三个，动态部署，SVG nft。

13994
23:15:26.012 --> 23:15:26.129
js。

13995
23:15:26.129 --> 23:15:29.545
我们不，我们需要一些样板文件。

13996
23:15:29.545 --> 23:15:31.415
让我们来看看基本的非ft。

13997
23:15:31.415 --> 23:15:35.196
我们来看看前七行。

13998
23:15:35.196 --> 23:15:37.224
我们把它粘贴到这里。

13999
23:15:37.224 --> 23:15:44.042
构造函数需要什么?我们需要一个价格提要地址，一个低SVG和一个最高CG。

14000
23:15:44.042 --> 23:15:45.867
好了，我们把这些都拿出来。

14001
23:15:45.867 --> 23:15:48.853
价格提要地址我们之前做过。

14002
23:15:48.853 --> 23:15:51.836
我们可以把它添加到我们的助手Hardhead配置中。

14003
23:15:51.836 --> 23:15:56.986
我们会做一个和一个foreign local，我们会用我们会用的一个mock。

14004
23:15:56.986 --> 23:16:00.302
如果我们在林克比，或者一个实际的网络上，我们就会使用一个实际的地址。

14005
23:16:00.302 --> 23:16:07.066
让我们继续到黑暗面链，链接会抓取一个价格feed地址，M Aetherium。

14006
23:16:07.066 --> 23:16:19.463
数据提要将进入排名B，排名B，让我们使用每一个美元拷贝，它将像这样创建一个新的条目每一个美元价格提要。

14007
23:16:19.463 --> 23:16:22.153
对于localhost，没问题。

14008
23:16:22.153 --> 23:16:24.649
因为我们知道对于localhost，我们需要做一个模拟。

14009
23:16:24.649 --> 23:16:27.293
让我们看看是否有价格供给模拟。

14010
23:16:27.293 --> 23:16:31.646
现在我们不需要了，我们需要一个模拟v3 aggregator。soul。

14011
23:16:31.646 --> 23:16:32.949
我只是复制粘贴了我的。

14012
23:16:32.949 --> 23:16:36.037
如果你愿意，你可以直接去这里的回购。

14013
23:16:36.037 --> 23:16:47.989
或者你可以从前一节复制，只是提醒心脏在f和f t FCC合同问moc v3聚合器，这是使用固体的06点。

14014
23:16:47.989 --> 23:16:53.043
我们要确保在hardhat。config中，至少有一个0。

14015
23:16:53.043 --> 23:16:55.709
6版本，我们做的很好。

14016
23:16:55.837 --> 23:17:21.423
这意味着在我们的部署模拟中，我们想要添加，初始价格将是2000小数将是一个团队。

14017
23:17:21.423 --> 23:17:24.087
因此，现在我们一直在等待为该价格提要部署模拟。

14018
23:17:24.087 --> 23:18:12.599
因此我们写入const chain ID = network。config。chain ID do if development chains。包含network。name，我们越需要导入development chains看起来就像我们所说的const eth USD akregator =我们将得到price feed = waitethers。get contract Mark v3 Air gate tour，然后我们会在上面这里我们会让eusd价格提要地址eusd价格提要地址等于eusd总地址那个地址否则就会说eusd价格提要地址将等于我们在网络配置中找到的。

14019
23:18:12.599 --> 23:18:14.503
网络配置。

14020
23:18:14.503 --> 23:18:17.931
链ID点eth美元价格。

14021
23:18:17.931 --> 23:18:22.549
好的，我们有了第eth美元价格供给率。

14022
23:18:22.549 --> 23:18:25.870
现在我们需要最低的VG和最高的SVG。

14023
23:18:25.870 --> 23:18:30.380
我们要在images文件夹中创建一个新文件夹。

14024
23:18:30.380 --> 23:18:35.125
CD图像，mkdir动态NF t。

14025
23:18:35.125 --> 23:18:40.647
这里我们有两个文件夹dynamic，一个是空的，一个是随机的，里面有所有随机的东西。

14026
23:18:40.647 --> 23:18:43.893
如果你想使用你自己的svg，你完全可以这么做。

14027
23:18:43.893 --> 23:18:50.991
但是如果你想打开我的图像文件然后将这些图像保存为右键点击save image as。

14028
23:18:50.991 --> 23:18:51.606
拯救他们。

14029
23:18:51.606 --> 23:18:55.231
然后拖放到你的图片文件里，你完全可以这么做。

14030
23:18:55.231 --> 23:19:03.041
现在我们有了这些，我们想继续把它们读入我们的脚本。

14031
23:19:03.041 --> 23:19:06.504
我们说const, low SVG等于一个权重。

14032
23:19:06.504 --> 23:19:09.170
我们将再次使用f。

14033
23:19:09.170 --> 23:19:28.596
我们写入const Fs = require Fs，或者await Fs。read file sync，我们将读取这个文件，对我来说，它是at。/ images / dynamic NF T / brown。SVG。

14034
23:19:28.596 --> 23:19:32.450
我们使用utf8编码。

14035
23:19:32.450 --> 23:19:34.869
然后我们说const。

14036
23:19:34.869 --> 23:19:39.355
嗨，SVG = await Fs。read file sync。

14037
23:19:39.355 --> 23:19:43.597
复制整个式子，因为我们用的是一样的东西。

14038
23:19:43.597 --> 23:19:46.089
这个人对SVG很满意。

14039
23:19:46.089 --> 23:19:47.255
就是这样。

14040
23:19:47.255 --> 23:19:53.275
价格好时，我们会用SVG表示幸福，价格不好时，我们会用SVG表示不满。

14041
23:19:53.275 --> 23:19:55.484
现在，让我们继续，部署这个契约。

14042
23:19:55.484 --> 23:20:04.454
我们说arguments或args =，这是价格提要地址，low SVG，然后high SVG。

14043
23:20:04.454 --> 23:20:21.699
我们写入const dynamic S G F T等于await, deploy dynamic SVG和F T，这里逗号小括号，来自Deployer。

14044
23:20:21.839 --> 23:20:24.553
Args, Args log true。

14045
23:20:29.839 --> 23:20:44.117
将是network。config，那将阻止确认，或者有人会做一些日志，我将做log来做这个。

14046
23:20:44.117 --> 23:20:52.068
Larry，你来验证一下，我将从上一个脚本中复制粘贴这个，因为这将是完全相同的复制粘贴。

14047
23:20:52.068 --> 23:20:57.008
但不是随机IPFS，而是动态SVG和f t。

14048
23:20:57.008 --> 23:20:58.731
其余部分看起来不错。

14049
23:20:58.731 --> 23:21:00.666
这就差不多了。

14050
23:21:00.666 --> 23:21:09.461
我们会写module, exports。tags =我们都是动态的。

14051
23:21:09.461 --> 23:21:09.985
SVG。

14052
23:21:09.985 --> 23:21:12.345
我们来做main。

14053
23:21:12.345 --> 23:21:13.525
哦,好的。

14054
23:21:13.525 --> 23:21:19.516
让我们试着看看刚刚创建的部署脚本是否有效。

14055
23:21:19.516 --> 23:21:28.697
要做h h，或yarn hardhat部署的破折号标签，die Namic SVG，这是有意义的，因为我们没有部署模拟。

14056
23:21:28.697 --> 23:21:31.128
我们会做标签，动态svg。

14057
23:21:31.128 --> 23:21:33.161
然后是嘲笑。

14058
23:21:33.161 --> 23:21:39.743
本地网络检测到游戏标记，我们部署标记，部署动态SVG，太棒了。

14059
23:21:39.743 --> 23:21:48.340
你知道接下来会发生什么吗?天啊，太对了，是时候做些检查了。

14060
23:21:48.340 --> 23:21:58.323
现在，我再一次鼓励你们暂停视频试着为这个测试写一个自己的测试这一节实际上会有点棘手。

14061
23:21:58.323 --> 23:22:05.373
因为我们要操纵模拟聚合器的价格，所以我们要检查这些长字符串等等。

14062
23:22:05.373 --> 23:22:10.772
所以一定要使用与这节课相关的GitHub存储库，以防你迷失方向。

14063
23:22:10.772 --> 23:22:18.036
现在，我想向你们展示这在市场上是什么样子的，比如OpenCL。

14064
23:22:18.036 --> 23:22:21.033
所以我们要把这个布置到B溜冰场。

14065
23:22:21.033 --> 23:22:23.219
记住，测试可能很慢。

14066
23:22:23.219 --> 23:22:24.494
所以你最好耐心点。

14067
23:22:24.494 --> 23:22:26.949
如果你不想，你甚至可以不做。

14068
23:22:26.949 --> 23:22:28.390
但还是很高兴看到的。

14069
23:22:28.390 --> 23:22:30.340
好吧，这才是真正的样子。

14070
23:22:30.340 --> 23:22:33.220
你可以去链上的合同，一旦它被验证。

14071
23:22:33.220 --> 23:22:35.040
你可以读取令牌URI等等。

14072
23:22:35.040 --> 23:22:35.767
这很有趣。

14073
23:22:35.840 --> 23:22:39.952
让我们再往deploy文件夹中添加一位。

14074
23:22:40.840 --> 23:22:44.430
一个薄荷脚本，它为每个合约发出一个NF T。

14075
23:22:44.430 --> 23:22:46.856
我们要为mint创建no。

14076
23:22:46.856 --> 23:22:46.987
js。

14077
23:22:46.987 --> 23:22:52.275
我们要让每一份合同都成为非功能性的。

14078
23:22:52.275 --> 23:22:54.658
我们来做这个。

14079
23:22:54.658 --> 23:23:00.840
在这里，我们写const ethers network = require arhat。

14080
23:23:00.840 --> 23:23:04.808
然后我要做一点复制粘贴。

14081
23:23:04.808 --> 23:23:08.774
我要复制这部分因为我知道我需要它。

14082
23:23:08.774 --> 23:23:12.660
我们需要部署，但我们不需要部署。

14083
23:23:12.660 --> 23:23:17.095
我将抓取记名账户，它将从这里开始。

14084
23:23:17.095 --> 23:23:18.213
我们有一个部署者。

14085
23:23:18.213 --> 23:23:20.691
我们的部署人员只是用来制造它们的。

14086
23:23:20.691 --> 23:23:22.291
首先我们制造基本的NF t。

14087
23:23:22.291 --> 23:23:31.983
因此我们写入const basic NF t = wait ethers。get contract, basic N ft，我们将把部署器连接到它。

14088
23:23:31.983 --> 23:23:41.737
然后我们说const basic mint如果T或basic mint, TX等于await basic NF T。mint NF T。

14089
23:23:41.737 --> 23:24:00.856
然后我们会做一个weight basic mint TX。weight 1然后我们会做一个console。logbase同样，tindex 0有令牌URI，我们会放入一个await basic NF T。令牌URI 0。

14090
23:24:00.856 --> 23:24:03.541
这就是基本实体的内容。

14091
23:24:03.541 --> 23:24:08.091
现在我们将随机执行IPFS并为空。

14092
23:24:08.091 --> 23:24:21.441
因此我们写入const, random IPFS NF t = await ethers。get contract, random IPFS和f t，连接到部署器。

14093
23:24:21.441 --> 23:24:23.912
这个案子，我们需要一大笔钱。

14094
23:24:23.912 --> 23:24:29.502
我们写入const, mint V = await random IPFS NF T。get mint fee。

14095
23:24:29.502 --> 23:24:31.679
然后我们再做薄荷。

14096
23:24:31.841 --> 23:24:42.779
我们会说const, random IPFS和ft mint, TX等于await, random IPFS和ftdot request和fteam。

14097
23:24:42.779 --> 23:24:47.681
对于这个，我们需要传递一个值，它将是薄荷v。

14098
23:24:47.681 --> 23:24:48.432
字符串。

14099
23:24:48.432 --> 23:25:04.648
对于这个，就像我们在测试中看到的一样，我们需要再次执行await new promise，因为我们需要等待它返回需要监听那些事件，我们可能应该先设置监听器。

14100
23:25:04.648 --> 23:25:06.270
让我们先设置监听器。

14101
23:25:06.270 --> 23:25:11.757
我们要写await new promise，我们要写async function。

14102
23:25:11.842 --> 23:25:14.745
我们要做的是解析拒绝。

14103
23:25:16.842 --> 23:25:19.772
这里有趣的小箭头语法。

14104
23:25:19.842 --> 23:25:36.175
既然我们在这个函数中，我们就像这样设置超时解析，这意味着我们有5分钟的时间让它暂停，你可能想把它再放大一点5分钟可能不够，这里是300毫秒，我们再做一次。

14105
23:25:36.175 --> 23:25:39.252
我们说随机IPFS和ft导。

14106
23:25:39.252 --> 23:25:46.719
一旦我们得到那个非ft mintedevent，我们会运行一个async函数，我们会做resolve。

14107
23:25:46.719 --> 23:25:53.334
这里面是我们可以放的地方，实际上是请求非ft。

14108
23:25:53.334 --> 23:26:04.925
但在listener下面，对吧，在这里，然后我们可以说if developments chains，这包括network。name。

14109
23:26:04.925 --> 23:26:13.632
我们要确保导入这些开发链和网络或影响它们和包含network。name的链。

14110
23:26:13.632 --> 23:26:17.648
我们在一个测试网上，这是我们前进的地方，我们假装是那些模拟动物。

14111
23:26:17.648 --> 23:26:21.442
我们写入const Request ID = random IPFS。

14112
23:26:21.442 --> 23:26:33.053
哦，实际上，我们需要const random IPFS和ft min TX receipt = await on IPFS和empty minted TX。weight 1。

14113
23:26:33.053 --> 23:26:35.789
所以我们得拿到收据。

14114
23:26:35.789 --> 23:26:39.499
从收据中，我们可以得到请求ID。

14115
23:26:39.499 --> 23:26:43.112
那个事件。args。request id。

14116
23:26:43.112 --> 23:26:44.254
字符串。

14117
23:26:44.254 --> 23:26:47.936
然后我们可以做const VRF。

14118
23:26:47.936 --> 23:27:00.770
协调器V要模拟等于等待醚点得到契约，V要模拟的射频坐标，将其连接到部署器。

14119
23:27:00.843 --> 23:27:12.000
然后我们会做一个等待RF编码和一个Tor V来模拟满足随机单词的请求ID，随机IPFS。

14120
23:27:12.000 --> 23:27:26.504
如果T。address，我们可以做console。log random IPFS让T索引为0令牌URI来等待随机IP。

14121
23:27:26.504 --> 23:27:31.218
那是nft导令牌URI (0)

14122
23:27:31.218 --> 23:27:36.343
最后，我们可以进行动态SVG (NF t)。

14123
23:27:36.343 --> 23:27:42.206
所以我们可以说const high high value =醚。

14124
23:27:42.206 --> 23:27:42.751
跑龙套。

14125
23:27:42.751 --> 23:27:44.786
在这里解析以太。

14126
23:27:44.786 --> 23:27:49.398
所以我们设4000美元4000美元是最高的值。

14127
23:27:49.398 --> 23:27:51.175
我们用const。

14128
23:27:51.175 --> 23:27:57.892
动态SVG和ft等于await醚。get契约，动态的。

14129
23:27:57.892 --> 23:28:20.719
SVG和一个T会把它连接到部署器比如const由Namic, s, B, G和ftmint, TX等于await dynamic SVG和ft。mint和fti value to string然后我们就等待。

14130
23:28:20.719 --> 23:28:23.094
这个数据等一等。

14131
23:28:23.094 --> 23:28:27.674
最后是console。log dynamic。

14132
23:28:27.674 --> 23:28:36.602
SVG非函数索引0令牌URI将是一个权重动态。

14133
23:28:36.602 --> 23:28:41.392
SVG和ft点令牌URI为零。

14134
23:28:41.392 --> 23:28:43.544
好的，我觉得看起来不错。

14135
23:28:43.544 --> 23:28:44.677
让我们在本地网络上试试。

14136
23:28:44.677 --> 23:28:48.118
所以我们要做纱线硬帽部署。

14137
23:28:48.118 --> 23:28:53.876
我们会运行所有的脚本，看起来一切正常。

14138
23:28:53.876 --> 23:29:01.360
所以我们有随机的，基本的非ft指数0有一个代币年，我有这个IPFS，随机的IPFS非ft。

14139
23:29:01.360 --> 23:29:03.037
索引0有这个。

14140
23:29:03.037 --> 23:29:06.621
然后我们的SVG有这个巨大的怪物，很好。

14141
23:29:06.621 --> 23:29:20.212
然后我们甚至可以检查，我们甚至可以抓取这个IPFS散列，我们到我们的IPFS节点，或者如果你在浏览器中安装了IPFS，或者你使用Brave，我们可以直接把它弹出到浏览器中，看看它是什么样子。

14142
23:29:20.212 --> 23:29:20.527
正确的。

14143
23:29:20.527 --> 23:29:22.844
如果我放大，可爱的圣。

14144
23:29:22.844 --> 23:29:25.110
伯纳德，画着圣。

14145
23:29:25.110 --> 23:29:27.377
伯纳德，像这样，这也是圣。

14146
23:29:27.377 --> 23:29:27.643
伯纳德。

14147
23:29:27.643 --> 23:29:33.219
当然，还有SVG，我们也可以复制粘贴，看起来很棒。

14148
23:29:33.219 --> 23:29:35.156
然后我们可以复制图像。

14149
23:29:35.156 --> 23:29:37.317
它是一个皱眉的脸或阴脸。

14150
23:29:37.317 --> 23:29:38.159
但是太棒了。

14151
23:29:38.159 --> 23:29:40.762
好吧，它在本地为我们工作。

14152
23:29:40.762 --> 23:29:45.344
现在，让我们继续，试着在一个实际的测试网上工作。

14153
23:29:45.344 --> 23:29:49.145
所以，希望我们的助手硬帽配置设置正确。

14154
23:29:49.145 --> 23:29:56.980
这里有足够的东西我们需要确保我们有订阅ID，我们需要确保我们有订阅ID。

14155
23:29:56.980 --> 23:30:03.304
我们不应该调用mint函数，因为我们需要将消费者添加到VRF。

14156
23:30:03.304 --> 23:30:08.120
在我们真正理解之前我给我们的意思加上一些标签。

14157
23:30:08.120 --> 23:30:18.921
我们会写module。exports。tags =，我们会说all，之前我说过，让我们添加一个主标签。

14158
23:30:18.921 --> 23:30:23.232
现在我们来看看为什么要在这里添加这个主标签。

14159
23:30:23.232 --> 23:30:26.688
所以我们想要做的是部署所有这些契约。

14160
23:30:26.688 --> 23:30:42.796
但在我们最终打算使用IPFS之前，我们需要将合同添加到我们的消费者，我们要做的是，我们要运行yarn, Hardhead，部署dash dash网络Rinkeby dash dash tags main。

14161
23:30:42.796 --> 23:30:53.673
现在，这并不意味着我们的任何NF T，好吧，这并不意味着我们的任何NF T，它只是部署那些契约可能只是坐在那里等待这些真正部署。

14162
23:30:53.673 --> 23:30:59.202
所以这是休息的好时机，可以去散步，喝点水，喝杯咖啡，做任何你想做的事。

14163
23:30:59.202 --> 23:31:06.779
部署完毕后，我们可以到V或F。chain。link，这里已经连接了，我们用了订阅。

14164
23:31:06.845 --> 23:31:11.038
然后我们把IPFS消费者加进来。

14165
23:31:11.845 --> 23:31:12.285
好好去吧。

14166
23:31:13.845 --> 23:31:34.797
区块链上有三个交易，我们可以获取随机IPFS NF T，获取地址，然后回到V或F。chain。link / rink D，找到订阅ID，然后添加一个新的消费者，添加合约地址。

14167
23:31:34.797 --> 23:31:37.297
所以我们会批准超掩模。

14168
23:31:37.297 --> 23:31:42.158
一旦完成了这些操作，我们就可以完成运行deploy文件夹的mint部分。

14169
23:31:42.158 --> 23:31:49.384
确认后，我们可以关闭也许可以稍微刷新一下，我们应该能看到新地址被添加为订阅。

14170
23:31:49.384 --> 23:32:00.157
现在我们已经添加了，我们可以从每个戴着安全帽的合同中创造一个NF T，部署破折号标签意味着破折号网络Rinkeby。

14171
23:32:00.157 --> 23:32:03.338
这个我们也得等一会儿。

14172
23:32:03.338 --> 23:32:08.354
好了，现在我们已经把它们都铸造好了，我们应该得到像这样的输出。

14173
23:32:08.354 --> 23:32:11.168
对吧?基本NF t0在这里有令牌URI。

14174
23:32:11.168 --> 23:32:14.958
基本随机IPFS NF T标记了你的眼睛。

14175
23:32:14.958 --> 23:32:18.535
然后我们的SVG用这个作为令牌年。

14176
23:32:18.535 --> 23:32:26.670
那么我们现在能做什么呢?让我去拿我的钱包地址然后把它放进瑞克比以太扫描。

14177
23:32:26.670 --> 23:32:30.620
我们再次调用了mint request和mint。

14178
23:32:30.620 --> 23:32:38.439
我们创建了三种契约，我们创建了基本的非ft，随机IPFS非ft和动态SVG非ft。

14179
23:32:38.439 --> 23:32:44.354
我们现在能做的是，我们可以复制合同的地址。

14180
23:32:44.354 --> 23:32:54.136
我们可以去测试网络打开，看到那个i，哦，我们可以把那个地址放在这里的栏里在搜索栏里。

14181
23:32:54.136 --> 23:32:57.699
这部分变化非常大。

14182
23:32:57.846 --> 23:32:59.753
好吧，open C是非常慢的。

14183
23:33:01.846 --> 23:33:06.373
注册合同部署到测试网需要几个小时。

14184
23:33:06.373 --> 23:33:09.397
所以如果它没有马上出现，也不要气馁。

14185
23:33:09.397 --> 23:33:10.747
不要让它拖累你。

14186
23:33:10.747 --> 23:33:16.659
但如果是这样，您应该可以单击您的集合，并看到NFT实际上在这里。

14187
23:33:16.659 --> 23:33:19.034
我将随机取IPFS NFT。

14188
23:33:19.034 --> 23:33:21.159
我们去拿那个合同地址。

14189
23:33:21.159 --> 23:33:23.915
我要抓取那个测试网站打开c。

14190
23:33:23.915 --> 23:33:24.052
io。

14191
23:33:24.052 --> 23:33:25.983
把那个地址粘贴进去。

14192
23:33:25.983 --> 23:33:33.535
你知道我们确实看到了什么，随机IPFS和f t，对，我已经部署了一些。

14193
23:33:33.535 --> 23:33:36.925
这是v2，我们可爱的湿婆就在你体内。

14194
23:33:36.925 --> 23:33:44.597
这就是它在open C中看起来的样子，现在我们可以100%验证我们的代码是好的，即使它没有在open中显示出来。

14195
23:33:44.597 --> 23:33:44.797
看到的。

14196
23:33:44.797 --> 23:33:47.513
如果我们去看合同，我们会去阅读合同。

14197
23:33:47.513 --> 23:33:51.513
然后我们到令牌URI打孔，这里是0。

14198
23:33:51.513 --> 23:33:57.492
一个查询，抓取这个，插入到我们的浏览器，JSON看起来很好。

14199
23:33:57.492 --> 23:33:59.298
让我们获取图像URI。

14200
23:33:59.298 --> 23:34:00.201
粘贴进去。

14201
23:34:00.201 --> 23:34:04.275
如果我们能看到这里，这意味着我们的代码是好的。

14202
23:34:04.275 --> 23:34:10.013
您已经成功地将许多fft部署到区块链。

14203
23:34:10.013 --> 23:34:17.508
我们在这门课中学到了很多东西，这绝对是最果酱的一门。

14204
23:34:17.508 --> 23:34:18.543
这都是关于艺术的。

14205
23:34:18.543 --> 23:34:23.750
对吧?这是不是很疯狂?让我们快速复习一下这门课。

14206
23:34:23.750 --> 23:34:33.513
首先，我们学习了基本的NF T dot Sol的基础知识，我们知道这些NF T是基于ERC 721标准的。

14207
23:34:33.513 --> 23:34:38.137
这意味着它们有name, token, Uri等函数。

14208
23:34:38.137 --> 23:34:56.005
我们学过NF - T使用这个令牌URI来告诉我们这个令牌实际上看起来像什么一个令牌，你的眼睛看起来像这样，它会是一个名字一个描述，它会有一个图像URL，它指向一个不同的位置，显示NFT实际看起来像什么。

14209
23:34:56.005 --> 23:35:00.863
它会有像属性这样的东西，它可以有像属性这样的东西，还有一些其他标签。

14210
23:35:00.863 --> 23:35:03.466
这被称为非ft的元数据。

14211
23:35:03.466 --> 23:35:05.562
这告诉我们关于非功能性的。

14212
23:35:05.562 --> 23:35:19.028
我们也可以在chain上有所有的元数据，当然，在chain上自定义它，让它在chain上看，增长，改变和交互，我们学习了更多关于IPFS的知识，我们实际上写了一个脚本叫upload to pinjarra。

14213
23:35:19.028 --> 23:35:31.768
js中，我们可以通过编程方式将图片和文件上传到另一个IPFS固定服务中，当然，如果我们愿意，我们总是可以使用我们自己的IPFS节点。

14214
23:35:31.848 --> 23:35:34.493
这个令牌URI可以是任何东西。

14215
23:35:35.848 --> 23:35:39.727
IPFS是我们的基本非ft和随机非ft。

14216
23:35:40.848 --> 23:35:47.714
动态非ft，我们实际上托管令牌，你是对的100%在链上，所以我们没有使用IPFS。

14217
23:35:47.714 --> 23:36:08.562
我们做了这个动态，令牌URI实际上是根据我们的随机IPFS非功能性饲料的价格变化而变化的，我们给我们的非功能性饲料一个机会我们给不同的狗不同的稀有物所以我们可以创建编程罕见的NF TS我们的哈巴狗是超级稀有的。

14218
23:36:08.562 --> 23:36:10.941
我们的湿婆有点稀有，而我们的圣。

14219
23:36:10.941 --> 23:36:12.112
伯纳德很普通。

14220
23:36:12.112 --> 23:36:14.733
所以我们能把它送到你这里真是太棒了。

14221
23:36:14.733 --> 23:36:17.414
我们做了一些惊人的部署，写了一些测试。

14222
23:36:17.414 --> 23:36:25.038
不仅如此，我们还学习了很多关于事务的知识，以及如何向这个数据部分添加我们想要的任何数据。

14223
23:36:25.038 --> 23:36:40.776
更多的是关于我们的事务是什么样子的，以及我们如何使用函数，选择器和函数签名来调用任何东西，我们还学习了ABI点编码，编码包和所有二进制的东西如果你想深入了解的话。

14224
23:36:40.776 --> 23:36:43.224
所以这绝对是一个JAM拥挤的会议。

14225
23:36:43.224 --> 23:36:55.510
你应该为自己感到无比自豪，尤其是你的小狗你可以在公海上看到或者你可以直接在以太扫描上看到，或者你可以只看它和IPFS，并为你所做的感到非常自豪。

14226
23:36:55.510 --> 23:36:59.009
话虽如此，恭喜你能走这么远。

14227
23:36:59.009 --> 23:37:12.525
一定要在这里休息一下，我们下期见。

14228
23:37:12.849 --> 23:37:18.991
好了，现在我们只有不到5个团队，这将是我们下一个JS非ft市场。

14229
23:37:18.991 --> 23:37:33.642
如果你完成了这节课，你就是一个web三全栈怪物，这将是我们使用web三栈最复杂的前端使用很多非常高级的web三和区块链工具。

14230
23:37:33.642 --> 23:37:38.134
所以大家要兴奋起来，因为这节课我们将学到很多东西。

14231
23:37:38.134 --> 23:37:41.610
实际上有三种不同的回购与这一课相关。

14232
23:37:41.610 --> 23:37:44.389
第一个是我们典型的安全帽项目。

14233
23:37:44.389 --> 23:37:52.949
对于后端，在安全帽项目之后，我们实际上有两个回购都是我们的前端回购，它们略有不同。

14234
23:37:52.949 --> 23:38:00.107
在这个项目中，我们将更多地了解事件是如何如此重要以及为什么事件如此重要，特别是对于链外服务。

14235
23:38:00.107 --> 23:38:07.392
所以我们实际上要看两种不同的方法来处理它们，一种是mirallas，或一个集中的数据库，另一种是使用图表。

14236
23:38:07.392 --> 23:38:22.210
我想展示这两种方法的原因是，当人们想要扩大项目规模时，当人们想要快速完成事情时，采用更集中的方法通常会更快一些，有时你可以给你的网站添加更多的功能。

14237
23:38:22.210 --> 23:38:24.688
还有很多协议都有去中心化的后端。

14238
23:38:24.688 --> 23:38:26.568
以及集中前端。

14239
23:38:26.568 --> 23:38:33.787
其中一个例子是，开放的海洋，例如，开放的海洋有能力喜欢不同的和fts。

14240
23:38:33.850 --> 23:38:37.172
现在，这不是我们真正想要花费汽油的东西。

14241
23:38:37.172 --> 23:38:42.968
但是我们必须把它存储在某种数据库中，这样人们才有能力这样做。

14242
23:38:42.968 --> 23:38:49.209
所以我想给你们展示这个可选的第一种方法来构建这些前端，因为我们所有的逻辑仍然是100%的。

14243
23:38:49.209 --> 23:38:55.627
在链上，前端不那么重要，因为任何人都可以与我们在链上建立的合约进行交互。

14244
23:38:55.627 --> 23:38:58.183
在web 3中，我们不想停留在那里。

14245
23:38:58.183 --> 23:39:03.241
然而，完成一个MVP，完成一个最小的可行项目是非常非常重要的。

14246
23:39:03.241 --> 23:39:07.650
所以使用中央服务器，像Morales，或中央项目可以让我们更快。

14247
23:39:07.650 --> 23:39:13.006
事实上，我们一直在使用中心化服务，就像炼金术一样，贯穿整个项目。

14248
23:39:13.006 --> 23:39:17.145
当然，我也想向你们展示去中心化的方法来制作你的前端。

14249
23:39:17.145 --> 23:39:22.357
在我们和莫拉莱斯合作之后，我们还会向你们展示如何使用这个图表来做所有这些事件索引。

14250
23:39:22.357 --> 23:39:28.146
现在这个图表将会是一个去中心化的方式我们可以做我们的前端和处理这些事件。

14251
23:39:28.146 --> 23:39:30.550
这个图表还自带一个graph repo。

14252
23:39:30.550 --> 23:39:33.833
等我们讲到前端部分的时候，我们会学到所有这些。

14253
23:39:33.833 --> 23:39:37.582
让我给你们展示一下我们要做的东西因为它真的很酷。

14254
23:39:37.582 --> 23:39:42.250
既然我们已经学习了大量关于如何使非功能性T成为他们是什么，我们将创建我们自己的非功能性市场。

14255
23:39:42.250 --> 23:39:47.083
就像我说的，这将是我们对所有这些惊人的前端工具的深入研究。

14256
23:39:47.083 --> 23:39:49.576
这就是我们前端的样子。

14257
23:39:49.576 --> 23:39:56.818
但我们能做的是用连接按钮连接，我们点击Metamask, Metamask弹出，我们继续连接。

14258
23:39:56.818 --> 23:40:00.402
现在我们连在一起了，我们可以看到这里不同的实体。

14259
23:40:00.402 --> 23:40:04.689
如果我们在一个属于我们的地址上，它会显示为你所有。

14260
23:40:04.689 --> 23:40:10.441
如果我们切换地址，或者UI会更新，连接到那里。

14261
23:40:10.441 --> 23:40:12.719
现在我们的地址不一样了。

14262
23:40:12.719 --> 23:40:15.678
如果它是我们的，我们会看到这个小的盘旋，上面写着Update listing。

14263
23:40:15.678 --> 23:40:17.394
现在它值0。

14264
23:40:17.394 --> 23:40:17.534
18.

14265
23:40:17.534 --> 23:40:20.588
我们的市场上就是这么标价的。

14266
23:40:20.588 --> 23:40:24.786
如果它是我们的，我们点击它，就可以更新到不同的价格。

14267
23:40:24.786 --> 23:40:32.251
让我们把它更新到每先令50美元，或者不管你的第一层货币是什么，我们只会说新的上市价格，我们将继续进行确认。

14268
23:40:32.251 --> 23:40:36.291
我会说，listing updated，请刷新，我们能做什么。

14269
23:40:36.291 --> 23:40:42.051
我们在后面挖一些区块，嘣，现在我们看到它值50。

14270
23:40:42.051 --> 23:40:54.146
如果我们切换到另一个账户，我们可以看到所有者等等等等，此时悬浮键会说，如果他被选为另一个用户，我将通过这个交易购买它。

14271
23:40:54.146 --> 23:40:57.368
现在请确认我是否要买，我就会看到一个小弹出框。

14272
23:40:57.368 --> 23:40:58.741
这是购买成功的项目。

14273
23:40:58.741 --> 23:41:06.883
现在如果我稍微刷新一下，我们就会看到非功能性从市场上消失了，因为我们正确地购买了它，它不再可以出售。

14274
23:41:06.883 --> 23:41:14.800
现在我们能做的就是卖出NF t，在底部，我们会看到提取收益。

14275
23:41:14.800 --> 23:41:22.574
所以当有人购买NFT时，NFT市场实际上保留了收益实际上保留了销售的结果。

14276
23:41:22.574 --> 23:41:31.816
因此，如果我们切换回我们列出的NF T的地址，我们现在可以看到提取50收益，因为我们知道我们每人有50，因为我们刚刚以50买了它。

14277
23:41:31.816 --> 23:41:44.561
如果我们点击取款，Metamask就会弹出，我们可以继续确认，等一会交易填充，一旦它通过，我们就会看到零收益。

14278
23:41:44.561 --> 23:41:46.742
对，我们把这里的东西都撤走了。

14279
23:41:46.852 --> 23:41:49.899
所以我们现在能做的，就是重新列出非功能性药物。

14280
23:41:50.852 --> 23:41:55.296
回到刚刚买了NF t的那个。

14281
23:41:55.852 --> 23:42:13.400
知道NFT的地址和令牌ID我们就拥有了它，我们可以继续并重新列出它，因为我们可以把地址和令牌ID放在这里给我们一个价格，我们会提交，我们会批准把NFT的市场访问权给我们的小狗。

14282
23:42:13.400 --> 23:42:23.544
然后我们会发送交易，让非ft在市场上成功上市。

14283
23:42:23.544 --> 23:42:27.802
在我们移除后端的一些障碍物后，我们可以回到前端。

14284
23:42:27.852 --> 23:42:34.342
我们现在看到，它归我们所有，而不是原来的主人，对吧，设为10以太币。

14285
23:42:34.342 --> 23:42:40.004
然后我们当然可以切换回不同的用户，我们可以让他们真正购买。

14286
23:42:40.004 --> 23:42:51.452
这将是一个完全去中心化的非功能性市场，我们将学习大量关于前端的知识大量关于索引的知识大量关于事件的知识，以及为什么它们如此强大。

14287
23:42:51.452 --> 23:42:54.118
这次我真的为你感到兴奋。

14288
23:42:54.118 --> 23:43:01.759
因为如果你通过了这个，你将有很多工具在你的指尖与区块链一起工作。

14289
23:43:01.852 --> 23:43:03.658
准备好了吗，我们开始吧。

14290
23:43:05.852 --> 23:43:07.005
然后我们来做前端。

14291
23:43:07.005 --> 23:43:07.479
让我们开始吧。

14292
23:43:07.853 --> 23:43:28.611
这个项目将基于Arteon项目，它是一个完全开源的去中心化智能合约非金融市场，我会在与这门课相关的GitHub上留下它的链接，当然我们的，将是这个的一个极简版本。

14293
23:43:28.853 --> 23:43:30.112
我们在VS code pre normal中。

14294
23:43:30.853 --> 23:43:35.297
在这里创建一个名为hard hat的新文件夹。

14295
23:43:37.853 --> 23:43:42.885
FCC，哦，MK dir，和他们一样，我们要用cd。

14296
23:43:43.853 --> 23:43:46.098
打开它和它自己的VS代码。

14297
23:43:47.853 --> 23:43:51.780
代码期，或文件打开文件夹，并打开此文件夹。

14298
23:43:52.853 --> 23:43:55.900
一旦我们到了这里，我们要做所有我们在整个课程中一直在做的正常的事情。

14299
23:43:55.900 --> 23:44:10.567
再说一次，如果你想复制粘贴到JSON包上，如果你想复制粘贴到模块里，不管你想做什么，请随意我要继续，这个repo，我们要向上滚动，再次抓取，这一行小于9。

14300
23:44:10.567 --> 23:44:21.984
然后运行这个，我知道我要用的是pretty所以我要复制粘贴这两个pretty文件到pretty忽略和pretty RC会再次使用它们，用于linting。

14301
23:44:21.984 --> 23:44:24.286
对于solidity，我们将使用Sol hint。JSON。

14302
23:44:24.286 --> 23:44:26.170
我们会抓取那个。soul hint。JSON。

14303
23:44:26.170 --> 23:44:28.868
这些点表示忽略。

14304
23:44:28.868 --> 23:44:35.259
我还会使用hardhat。config。js因为我们会使用一个非常非常相似的设置。

14305
23:44:35.259 --> 23:44:37.071
这个。config。js。

14306
23:44:37.071 --> 23:44:46.695
它有华夫饼，以太扫描，硬帽部署覆盖气体报告大小器和多蒂和v点配置，我们将带来我们的多蒂和v。

14307
23:44:46.695 --> 23:44:49.604
我们还会带来我们的utils文件夹。

14308
23:44:49.604 --> 23:44:52.644
好了，我们会带来很多样板文件。

14309
23:44:52.644 --> 23:45:03.624
现在就像这样，因为我们有硬帽。配置。j s在这里，如果我们运行yarn，现在，yarn硬帽会看到我们得到像这样的输出。

14310
23:45:03.624 --> 23:45:04.804
我们继续。

14311
23:45:04.804 --> 23:45:17.820
在写合同之前，我们先写一份文件说明合同的内容，我们希望它做什么?我们将创建一个去中心化的非金融市场。

14312
23:45:17.820 --> 23:45:33.582
这是什么意思呢?我们可能需要什么?我们可能需要某种类型的列表项函数，因为我们想要列出NF T而这将是在市场上列出NF T，我们需要某种类型的购买项目来购买NF T。

14313
23:45:33.582 --> 23:45:43.916
然后我们可能需要取消列表或取消项目，如果你不想再卖它，可能需要更新列表，更新价格。

14314
23:45:43.916 --> 23:45:51.001
然后可能会有一个提款程序来提款或者我的bot和fts。

14315
23:45:51.001 --> 23:45:57.803
当有人购买非担保债券时，我将不得不从合同中撤回它因为合同将是真正持有这些资金的合同。

14316
23:45:57.803 --> 23:45:58.786
在我看来还不错。

14317
23:45:58.854 --> 23:46:00.854
让我们开始做这个。

14318
23:46:01.854 --> 23:46:03.494
新文件夹，合同。

14319
23:46:03.494 --> 23:46:05.447
让我们开始吧。

14320
23:46:06.854 --> 23:46:09.742
一个新的文件非ft市场。

14321
23:46:09.854 --> 23:46:11.520
这是所有。

14322
23:46:11.520 --> 23:46:16.353
让我们得到我们的样板。

14323
23:46:18.854 --> 23:46:22.501
固体度，胡萝卜0，点，8。

14324
23:46:24.854 --> 23:46:26.319
市场,繁荣。

14325
23:46:29.855 --> 23:46:35.315
或纱线Hardhead编译或MPX，艺术，击中，编译，boom，事情看起来很好。

14326
23:46:35.315 --> 23:46:44.403
如果我们回到自述文件，我们可以在这里抓取这些，甚至把它们放在这里作为我们以后参考的一个小注释。

14327
23:46:44.403 --> 23:46:46.089
让我们从列出项目开始。

14328
23:46:46.089 --> 23:46:48.760
我们要如何记录人们的物品。

14329
23:46:48.855 --> 23:46:55.387
再说一次，记住，当我编写这个代码的时候，我会在编写测试和编写实际代码之间来回切换。

14330
23:46:55.387 --> 23:46:59.613
我们只需要把所有的固体度写在一个数据块里，然后再写测试。

14331
23:46:59.613 --> 23:47:04.188
我们会说，这些是我们的主要函数。

14332
23:47:04.188 --> 23:47:07.315
我将从函数列表项开始。

14333
23:47:07.315 --> 23:47:10.910
我们要让这个看起来非常非常好。

14334
23:47:10.910 --> 23:47:12.521
我们来做natspec。

14335
23:47:12.521 --> 23:47:33.977
这需要一个外部函数，我们可能不希望任何内部函数调用list item，它将被外部项目或外部帐户调用可能需要一个地址和ft地址，写NFT的地址，契约一个un256令牌ID，我们将要使用的契约的令牌ID的ID。

14336
23:47:33.977 --> 23:47:36.113
然后我们要设置一个un256的价格。

14337
23:47:36.113 --> 23:47:40.417
首先，我们可能希望价格大于0。

14338
23:47:40.417 --> 23:47:56.258
也许我们会在这里放入一个if或require语句，我们会说如果price小于或等于0，然后我们会返回一个price must高于0的错误。

14339
23:47:56.258 --> 23:48:02.820
当然，我们会在它前面加上合约的名字下划线。

14340
23:48:02.820 --> 23:48:07.324
在顶部，误差价格必须大于零。

14341
23:48:07.324 --> 23:48:20.439
现在为了让我们把它列出来，我们实际上可以用两种方式来做其中一种，我们可以把非功能性的东西发送到合同中，这需要我们做一个转移，对吧，我们可以让合同持有非功能性的东西。

14342
23:48:20.439 --> 23:48:27.763
现在我们可以这样做了，但是这对于在f t上列出的人来说有点油贵。

14343
23:48:27.763 --> 23:48:32.363
我们可以让非功能性的所有者成为我们的非功能性市场，我们可以百分之百做到这一点。

14344
23:48:32.363 --> 23:48:36.006
但问题是，市场将拥有非功能性货币。

14345
23:48:36.006 --> 23:48:54.669
用户不能说，嘿，我拥有这个NFT，它在市场上，从技术上讲，他们可以但他们必须撤回它，我们可以用一种稍微不同的方式我们可以说所有者仍然可以持有他们的NFT并给市场批准为他们出售NFT。

14346
23:48:54.669 --> 23:49:02.133
当然，实体的所有者可以在任何时候撤回批准，市场就不能再出售它了。

14347
23:49:02.133 --> 23:49:09.498
然而，这对人们来说真的很容易阅读，他们所要做的就是阅读，就像被批准进入市场一样。

14348
23:49:09.498 --> 23:49:11.822
他们实际上可以看到项目是否真的列出了。

14349
23:49:11.856 --> 23:49:16.793
所以我们继续用第二种方式来写，因为这是阿迪安的方法。

14350
23:49:16.793 --> 23:49:30.218
这是建立这个市场的最不具侵入性的方式，对吧?人们仍然拥有他们的NF T的所有权，而市场将获得批准，一旦价格达到，就可以实际互换和出售他们的NF T。

14351
23:49:30.218 --> 23:49:36.396
既然我们想要确保市场得到了批准，那就确保市场得到了批准。

14352
23:49:36.396 --> 23:49:45.856
我们可以在令牌ID上调用这个get approved函数来确保市场被批准与NFT一起工作。

14353
23:49:45.856 --> 23:49:53.789
要做到这一点，我们需要AI ERC 720接口，我们实际上可以从开放的齐柏林抓取。

14354
23:49:53.857 --> 23:50:00.031
对，这个接口将围绕一个地址，然后我们可以调用该地址获得批准。

14355
23:50:00.031 --> 23:50:10.273
我们会在open Zeppelin输入/合约/令牌/ ERC 721 / I ERC 721。Sol。

14356
23:50:10.273 --> 23:50:35.790
因为我们要从open Zeppelin进行导入，我们会做yarn add dash Dev, add open Zeppelin现在我们有了这个接口，我们能做的是我们会说I ERC 721 NF t = IRC 721围绕着我们传入的NF t地址。

14357
23:50:35.790 --> 23:50:45.544
我们会说，如果NF T dot得到批准我们试图列出的令牌ID不等于地址这个。

14358
23:50:45.544 --> 23:50:53.123
所以如果我们没有被批准，我们就会回复not approved or market place。

14359
23:50:53.123 --> 23:51:01.539
然后我们当然会把它用非ft市场加上下划线。

14360
23:51:01.539 --> 23:51:13.020
像这样的错误，嗒嗒嗒嗒，现在我们已经解决了一些问题，我们可能需要某种类型的数据结构来列出所有这些NF T。

14361
23:51:13.020 --> 23:51:36.876
通常我们会问，我们要用数组吗?还是要使用映射?你怎么看?在我们继续之前?让我们暂停一下，你认为把这些NF T和数组或者a映射放在一起更有意义吗?当你考虑这个的时候，试着想想，好吧，人们会买这些卖这些，什么更有意义，想一下这个，也许暂停一下，在这里写个评论，你认为数组或映射哪个更好。

14362
23:51:36.876 --> 23:51:39.288
现在，如果你说映射，我会同意你的观点。

14363
23:51:39.288 --> 23:51:45.513
你不能用数组，你不一定会错，但这不是我用数组的方法。

14364
23:51:45.513 --> 23:51:53.202
只要有人想买东西，我们就得遍历数组，我们就得创建这个巨大的动态数组。

14365
23:51:53.202 --> 23:51:56.996
这可能有点冒险因为数组变得非常非常大。

14366
23:51:56.996 --> 23:51:59.211
我们要把它变成一个映射。

14367
23:51:59.211 --> 23:52:03.599
这可能是一个全局变量或状态变量。

14368
23:52:03.599 --> 23:52:09.781
在顶部，让我们继续创建这个映射，这将是一个非ft地址的地址映射。

14369
23:52:09.858 --> 23:52:18.288
对吧?它将是NFT契约地址映射到NFT，令牌ID映射到某种类型的列表。

14370
23:52:18.288 --> 23:52:24.451
所以我们会说，一个地址的映射到一个unt256的映射。

14371
23:52:24.451 --> 23:52:30.562
我们在这里想要什么?我们想要我们想要价格，对吧?这是另一个你用了6年的。

14372
23:52:30.562 --> 23:52:36.406
但我们也想，我们也想跟踪卖家，我们知道把钱寄给谁。

14373
23:52:36.406 --> 23:52:41.524
我们可以创建两个映射或者我们只创建一个新的类型类型列表，我们来做这个。

14374
23:52:41.524 --> 23:52:43.072
我们现在将对此进行注释。

14375
23:52:43.072 --> 23:52:56.558
所以在顶部，因为这将是一种类型，比如说，结构列表，在这里，我们将做一个效用6,NF t的价格，然后解决NF团队的卖家。

14376
23:52:56.558 --> 23:53:11.367
现在我们有了新的类型，我们可以取消注释这个，我们可以说NFT，契约地址映射到NFT令牌ID映射到列表，我们会把这个设为私有变量，叫做S下划线列表。

14377
23:53:11.367 --> 23:53:18.318
现在回到我们的列表项函数，我们要更新那个列表映射。

14378
23:53:18.318 --> 23:53:28.231
我们会说nst地址的s列表，nst在令牌ID处的地址将等于我们会创建一个价格的列表。

14379
23:53:28.231 --> 23:53:36.792
那么谁呢，卖家将会是发送者的信息，对吧?message。sender是列出项目的人。

14380
23:53:36.859 --> 23:53:50.303
既然我们在更新映射，更新映射的最佳实践是什么，你猜对了，我们需要发射一个事件特别是对于这个项目，你会看到为什么发射事件，至少对于这个项目，这很有帮助。

14381
23:53:50.303 --> 23:53:56.059
我们会触发一个itemlistevent，我们马上就会创建它。

14382
23:53:56.059 --> 23:54:03.208
我们将给出发送者的消息、非ft地址、令牌ID和列出的价格项。

14383
23:54:03.208 --> 23:54:28.366
然后在最上面，但在结构下面，我们会说event item list会做一个地址索引卖家地址索引非ft，地址，地址索引令牌ID，然后是一个un 256价格。

14384
23:54:28.366 --> 23:54:32.826
抱歉，这需要一个un256令牌ID，你int 56。

14385
23:54:32.826 --> 23:54:35.632
这看起来很好。

14386
23:54:35.632 --> 23:54:41.732
然而，我们可能想要确保我们只列出那些还没有列出的fte。

14387
23:54:41.732 --> 23:54:44.747
我们可以在这里加上if then。

14388
23:54:44.747 --> 23:54:47.532
这就是偏好起作用的地方。

14389
23:54:47.532 --> 23:54:51.579
但我要创建一个修饰符not lists。

14390
23:54:51.579 --> 23:55:02.860
我们确保我们没有重新列出，如果T已经列在我们的主要函数上面，或者像一个没有列出的小指示器修饰符。

14391
23:55:02.860 --> 23:55:12.082
这需要一个地址，一个un256令牌ID和一个地址所有者。

14392
23:55:12.082 --> 23:55:25.066
我们要做的是检查，我们要创建一个新的列表内存列表= s NFT地址令牌ID的下划线列表。

14393
23:55:25.066 --> 23:55:39.053
现在我们会说，如果listing。price大于0，我们会继续并恢复已经传递的NFT地址和令牌ID。

14394
23:55:39.053 --> 23:55:46.029
当然，我们将以非功能性市场为开端。

14395
23:55:46.029 --> 23:55:52.405
在顶部，我们做错误的市场已经列出，像这样。

14396
23:55:52.405 --> 23:56:02.026
然后我们在下面加一个下划线然后在上面这里，我们写上地址如果地址是56。

14397
23:56:02.026 --> 23:56:02.776
好的,ID。

14398
23:56:02.776 --> 23:56:05.692
这个修饰符看起来不错。

14399
23:56:05.692 --> 23:56:11.237
让我们确保它真的要编译我们用yarn Hardhead compile或hh compile。

14400
23:56:11.237 --> 23:56:11.630
太好了。

14401
23:56:11.630 --> 23:56:12.679
看起来不错。

14402
23:56:12.679 --> 23:56:21.110
我们将添加这个修饰符到我们的列表项函数将做非ft地址，令牌ID message。sender。

14403
23:56:21.110 --> 23:56:21.526
酷。

14404
23:56:21.526 --> 23:56:31.210
我们还应该检查什么?我们还应该检查所列出的NF T是否属于message。sender。

14405
23:56:31.210 --> 23:57:05.244
这样只有NFT的所有者可以在这里列出所以我们继续，我们将添加一个is owner modifier modifier is owner NFT address token ID spender你到这里的256和一个地址spender I ERC 721 NFT = IRC 721如果地址地址所有者等于NFT。owner a有一个token ID。

14406
23:57:05.244 --> 23:57:10.500
然后我们会说，如果消费者不等于所有者。

14407
23:57:10.500 --> 23:57:16.161
我们会返回一个非所有者错误我们会在上面创建这个错误。

14408
23:57:16.161 --> 23:57:18.488
我们会说error，而不是owner。

14409
23:57:18.488 --> 23:57:40.344
我们会在它前面加上两个下划线“revert revert not owner”然后在剩下的代码中加上下划线，下面没有列出的是“owner NFT address”令牌ID message。center。

14410
23:57:40.344 --> 23:57:49.572
现在我们的列表项检查它是否已经被列出，确保只有那个令牌的NFT的所有者Id可以列出它。

14411
23:57:49.572 --> 23:57:52.254
然后它会继续，很好地列出它。

14412
23:57:52.254 --> 23:57:52.975
好的,很酷。

14413
23:57:52.975 --> 23:57:55.401
这是我们的列表项方法。

14414
23:57:55.401 --> 23:57:58.368
现在让我们继续做一点关于这个的natspec。

14415
23:57:58.368 --> 23:58:06.635
现在我们有一个小的natspec，看起来非常专业。

14416
23:58:06.635 --> 23:58:07.602
好了,好了。

14417
23:58:07.602 --> 23:58:09.667
我们有一个列表项函数。

14418
23:58:09.862 --> 23:58:16.433
好了，接下来是什么?也许我们可以做一个购买物品的函数，让人们在NF T上市后购买它们。

14419
23:58:16.433 --> 23:58:20.337
我们来创建它们，函数按项。

14420
23:58:20.337 --> 23:58:30.747
我们取一个地址，如果地址un256令牌ID，这将是一个外部函数。

14421
23:58:30.747 --> 23:58:57.112
这也会使这个可支付函数成为一个外部函数因为我们知道只有这个合同之外的人或合同会按项目和可支付进行调用这样人们就可以按项目和可支付进行调用，或者任何一层货币来购买这些价格，我们可以想要100%的引导价格现在上市，当然，我们可以添加价格然后做地址代币价格。

14422
23:58:57.112 --> 23:59:02.603
然后像我们之前对链链价格提要所做的那样，将这些代币的价格转换为它们的实际成本。

14423
23:59:02.603 --> 23:59:05.695
我们完全可以通过链接价格来实现这一点。

14424
23:59:05.695 --> 23:59:07.700
但为了简单起见，我们不讲这个。

14425
23:59:07.700 --> 23:59:30.590
但我将把它作为一个挑战，通过挑战将使这个合同也接受令牌子集中的支付，当然，我们需要在这里给出一个小提示，即引导价格feed来转换令牌之间的价格，我们将选择我们想要购买的令牌ID中的哪个NFT。

14426
23:59:30.590 --> 23:59:36.671
我们首先要做的是什么?我们可能想检查这个by项是否被列出。

14427
23:59:36.671 --> 23:59:44.298
我们将创建一个新的modifier而不是未列出我们将使它被列出modifiers modifier被列出。

14428
23:59:44.298 --> 23:59:50.418
这需要一个地址，加上地址un256令牌ID。

14429
23:59:50.418 --> 24:00:08.113
为了检查这个是否被列出了，我们会说，listmemoreslistingequals s，标记的NFT地址的下划线列表，Id进入映射这里。

14430
24:00:08.113 --> 24:00:10.738
然后我们再看看价格。

14431
24:00:10.738 --> 24:00:26.744
我们会说，如果列表中那个价格小于或等于零，基本上，如果没有价格，如果它默认为零，如果价格为零，那么我们会说，revert, not listing。

14432
24:00:26.863 --> 24:00:33.314
在地址之后，令牌ID，当然，我们要前置。

14433
24:00:33.314 --> 24:00:55.251
如果市场和市场下划线下划线，没有列出，然后我们把这个复制到这里，我们说air lists，这将取地址，NFT地址，和au int 256令牌Id像这样，在我们的修饰符中向下，然后我们将添加下划线并添加剩下的代码。

14434
24:00:55.251 --> 24:01:09.121
现在我们有了一个islists修饰符，我们要检查以确保NFT确实列在下面这里现在我们要说的是islistaddressft address，不好意思，如果地址和令牌ID。

14435
24:01:09.121 --> 24:01:20.659
再一次，我们会说，listing memory listitem = sunderline listings。

14436
24:01:20.659 --> 24:01:34.931
如果T地址令牌ID，或者如果message。value小于列出的item。price，那么我们将返回price未满足。

14437
24:01:34.931 --> 24:01:46.224
然后我们会做NFT address, Open ID listitem。price Excel我们会创建一个新的air price not met error。

14438
24:01:46.224 --> 24:01:52.654
价格没有满足，当然，我们将在此之前与非ft市场采取一个地址。

14439
24:01:52.654 --> 24:02:00.355
如果你去的地址是56代币ID，然后一个UNT 256价格。

14440
24:02:00.355 --> 24:02:09.404
我们可以看到exe中价格是如何不满足的，然后回到下面这里，我们会得到完整的错误。

14441
24:02:09.404 --> 24:02:12.489
所以我们要确保他们给我们寄了足够的钱。

14442
24:02:12.489 --> 24:02:18.412
首先，当他们汇钱的时候，钱必须属于列出物品的人。

14443
24:02:18.412 --> 24:02:23.109
所以我们实际上需要跟踪这些人有多少钱。

14444
24:02:23.109 --> 24:02:31.676
让我们创建另一个名为收益的数据结构在这里我们记录人们出售NF T所赚的钱。

14445
24:02:31.676 --> 24:02:37.264
我们会创建一个地址到你和256的映射。

14446
24:02:37.264 --> 24:02:45.208
这将是卖家地址到收入的映射。

14447
24:02:45.208 --> 24:02:51.419
我们将这个私有叫做s_。

14448
24:02:51.419 --> 24:02:58.777
我们会做的是，当有人买了一件东西，就会更新他们的收益。

14449
24:02:58.864 --> 24:03:13.164
所以我们会说作为上市商品的收益，卖家等于s非法IO乘以卖家的收益加上MSG的价值。

14450
24:03:13.164 --> 24:03:18.324
现在，一旦我们买了这个东西，我们会想要删除清单。

14451
24:03:18.324 --> 24:03:29.341
因此，要从残骸中删除一个映射，要删除一个条目和一个映射，我们只需使用delete s下划线列表和令牌ID的ft地址。

14452
24:03:29.341 --> 24:03:31.817
我们移除这个映射。

14453
24:03:31.817 --> 24:03:35.115
最后，我们要转移它。

14454
24:03:35.115 --> 24:03:50.566
我们会说I ERC 721和ft address，我们会调用。transfer从列出的项目。卖家到带有令牌ID的消息。sender。

14455
24:03:50.566 --> 24:03:56.477
现在你会注意到，我们不仅仅是把钱寄给卖家。

14456
24:03:56.477 --> 24:04:01.058
为什么呢?固体有个概念叫拉比推。

14457
24:04:01.058 --> 24:04:08.807
当使用固体时，它被认为是最佳实践，您希望将与传输以太相关的风险转移给用户。

14458
24:04:08.865 --> 24:04:24.541
所以我们不想把钱寄给用户，我们不想让他们把钱取出来，我们总是想把和钱打交道的风险转移到实际用户身上，把和钱打交道的风险转移到实际用户身上。

14459
24:04:24.541 --> 24:04:33.316
所以我们不想直接把钱寄给他们，我们想要创建这个收益数据结构，我们可以让他们以后从其中提取。

14460
24:04:33.316 --> 24:04:35.896
现在，我们可以在这里做一些检查。

14461
24:04:35.896 --> 24:04:41.316
或者我们可以说，好的，检查以确保非功能性转移。

14462
24:04:41.316 --> 24:04:52.127
如果我们看ierc 721，我们看从函数的转移，我们没有看到它实际上有一个返回。

14463
24:04:52.127 --> 24:05:01.167
如果我们去ip721，我们可以看到这些都没有返回类型，transfer from这里没有返回类型。

14464
24:05:01.167 --> 24:05:18.243
然而，我们确实看到了这种从位到位的安全传输它将会更好一些，对吧因为如果我们看从转移到转移一个实体的所有权，调用者有责任确认下划线2能够接收实体否则它们可能会永久丢失。

14465
24:05:18.243 --> 24:05:27.421
也许我们想使用安全传输，它会抛出一个错误，除非消息发送方是当前所有者和授权操作符，等等。

14466
24:05:27.421 --> 24:05:32.817
所以我们用安全的转移而不是从，只是为了更安全一点。

14467
24:05:32.866 --> 24:05:37.449
所以我们要做安全转移而不是转移。

14468
24:05:37.866 --> 24:05:45.456
既然我们要更新映射，我们会做什么，你猜对了，我们省略一个事件，我们调用item bot。

14469
24:05:45.456 --> 24:05:52.962
实验室将消息发送者，一个空地址，令牌ID和列出的项目，价格。

14470
24:05:52.962 --> 24:05:56.728
在上面，我们创建一个新事件。

14471
24:05:56.728 --> 24:06:00.348
到事件项目购买。

14472
24:06:00.348 --> 24:06:20.942
这将是一个地址索引fire一个地址索引非ft地址一个地址索引令牌ID然后是un236价格。

14473
24:06:20.942 --> 24:06:23.966
开个玩笑，看起来不太好。

14474
24:06:23.966 --> 24:06:25.416
这应该是直观的。

14475
24:06:25.416 --> 24:06:27.481
现在看起来棒极了。

14476
24:06:27.481 --> 24:06:36.528
现在在这个购买项目中，我们已经将其设置为一种安全的方式，可以避免所谓的重入攻击。

14477
24:06:36.528 --> 24:06:41.104
我们对这些契约的编码方式是先进行所有的状态变化。

14478
24:06:41.104 --> 24:06:44.588
然后我们将NFT转换为令牌或其他。

14479
24:06:44.588 --> 24:06:49.315
但我们为什么要这么做呢?从认知上来说，我们认为这是有道理的。

14480
24:06:49.315 --> 24:06:57.367
首先，也许我们应该发送非功能性，我们想先发送实体。

14481
24:06:57.867 --> 24:07:00.697
这实际上是一个巨大的安全漏洞。

14482
24:07:01.867 --> 24:07:06.496
为什么让我们来学习区块链中最常见的黑客，重入。

14483
24:07:06.496 --> 24:07:07.028
看到攻击。

14484
24:07:07.028 --> 24:07:09.998
在这节课中，我们将讨论可重入。

14485
24:07:09.998 --> 24:07:16.033
C，在与这节课相关的GitHub回购中，我们会有我们在这里要讲的所有东西的代码。

14486
24:07:16.033 --> 24:07:20.914
我们正在看的代码是基于这个示例的坚固性。

14487
24:07:20.914 --> 24:07:21.707
可重入。

14488
24:07:21.867 --> 24:07:22.467
看到的例子。

14489
24:07:24.867 --> 24:07:25.798
与本课程相关。

14490
24:07:26.867 --> 24:07:30.804
在这里，您可以存取款。

14491
24:07:30.867 --> 24:07:40.731
它有一个叫余额的映射，你可以叫存款，它会更新你存入协议的金额。

14492
24:07:40.731 --> 24:07:43.217
它还有取款功能。

14493
24:07:43.217 --> 24:07:50.818
它首先从这个余额映射中获取你的余额，确保你的余额大于零。

14494
24:07:50.867 --> 24:08:01.516
然后我们一直发送eath的方式，我们发送sender。call的消息，我们发送余额，然后我们更新消息sender = 0的弹跳。

14495
24:08:01.516 --> 24:08:05.375
这条线实际上让这份合同变得非常脆弱。

14496
24:08:05.375 --> 24:08:35.626
如果我们现在运行这个，我们会说，嘿，不，它看起来像预期的那样工作，我们可以部署一个我正在使用的帐户的副本，比如在反弹为0时，我们可以存入，你知道，它消失了，让我们到以太，将存入到以太，下降，现在的存款要平衡反弹上升，我们点击提取，现在反弹回到0。

14497
24:08:35.626 --> 24:08:37.904
而且看起来效果很好。

14498
24:08:37.904 --> 24:08:44.786
现在，我们有一种方法可以攻击这个函数耗尽合同中的所有钱。

14499
24:08:44.868 --> 24:08:47.949
这就是所谓的重入攻击。

14500
24:08:48.868 --> 24:08:55.257
这个领域常见的攻击类型是可重入性攻击，也就是我们在这里讨论的。

14501
24:08:55.257 --> 24:09:05.468
Oracle攻击，通常只发生在协议不使用去中心化Oracle的情况下，幸运的是，我们从一开始就教会您如何使用链链接，这样您就可以受到保护。

14502
24:09:05.468 --> 24:09:18.461
这两种类型的攻击通常导致最多的钱最后，有一个被称为rec点新闻的排行榜，它跟踪许多在defi空间发生过的顶级攻击。

14503
24:09:18.461 --> 24:09:24.190
如果你回顾一下，其中很多都是Oracle攻击或可重入攻击。

14504
24:09:24.190 --> 24:09:31.680
你可能会说，嘿，我们在哪里只讨论NF T这个，这和NF T没有任何关系我们会讲到的，别担心。

14505
24:09:31.680 --> 24:09:37.037
在下面的新契约中，我们将创建一个新契约，叫做attack。

14506
24:09:37.037 --> 24:09:48.328
我们对这个攻击契约做的是我们会抓取这个可重入脆弱契约，我们会说可重入脆弱，公共可重入脆弱，像这样。

14507
24:09:48.328 --> 24:09:53.386
我们将把可重入脆弱契约保存为全局变量。

14508
24:09:53.386 --> 24:10:00.835
我们会说，构造门地址，下划线牧场和易受害地址。

14509
24:10:00.835 --> 24:10:12.767
然后我们说reentrant vulnerable = rancher和vulnerable at reentrant vulnerable address。

14510
24:10:12.767 --> 24:10:17.885
现在我们要做的是创建一个叫做attack的函数。

14511
24:10:17.885 --> 24:10:24.475
这个函数会恶意地调用withdraw。

14512
24:10:24.475 --> 24:10:27.935
这里是攻击，这是一个外部支付合同。

14513
24:10:27.935 --> 24:10:30.735
我们把它叫做这个位置。

14514
24:10:30.869 --> 24:10:32.636
我们先存点钱。

14515
24:10:33.869 --> 24:10:40.369
脆弱点的位置将发送一个以太的值。

14516
24:10:40.369 --> 24:10:47.344
然后我们马上调用renn Trent vulnerable dot withdraw。

14517
24:10:47.344 --> 24:10:51.794
乍一看，这似乎是无害的。

14518
24:10:51.869 --> 24:11:01.223
记住，当我们像这样调用message。call来发送时我们回调的是这个攻击契约。

14519
24:11:01.223 --> 24:11:11.606
调用攻击契约时，是否有办法执行其他代码?还记得我们是如何学习回退函数的吗。

14520
24:11:11.606 --> 24:11:16.546
如果我们在这里放一个回退函数或者一个接收函数。

14521
24:11:16.546 --> 24:11:27.097
当这段代码运行调用和秒我们的合同醚，我们可以让它触发我们的回退函数再次调用撤回。

14522
24:11:27.097 --> 24:11:33.603
这将给我们的合同发送比更新余额之前更多的以太。

14523
24:11:33.603 --> 24:11:36.163
我们看看这是什么样子的。

14524
24:11:36.163 --> 24:11:57.209
在我们的退一步中，我们会说如果可重入脆弱余额的地址大于或等于1以太币也就是说，如果合同中还有钱，那么牧场主无懈可击。撤回。

14525
24:11:57.209 --> 24:12:03.377
然后在攻击契约中加入平衡函数。

14526
24:12:03.377 --> 24:12:07.394
我们要通过呼叫撤退来攻击易受攻击的再入者。

14527
24:12:07.394 --> 24:12:15.588
当我们讲到发送部分时，我们要做什么呢，我们会让我们的回退函数触发再次调用withdraw。

14528
24:12:15.588 --> 24:12:22.298
现在，当我们再次调用withdraw时，将反弹一个发送方尚未归零的消息。

14529
24:12:22.298 --> 24:12:26.801
合同代码会说，你还有一些钱。

14530
24:12:26.870 --> 24:12:31.785
让我们继续，让我们把它发送给你，这将再次触发我们调用撤回。

14531
24:12:31.785 --> 24:12:34.509
我们会一直调用退出，直到完成为止。

14532
24:12:34.509 --> 24:12:36.738
我们看看这是什么样子的。

14533
24:12:36.870 --> 24:12:44.148
我们编译这个，然后开始部署，首先，部署可重入脆弱契约。

14534
24:12:44.148 --> 24:12:55.484
好的，我们可以有任何合同地址，你知道，比如部署它的那个，我们可以有一个存款，让我们这样做，我们有一个存款一个以太存款。

14535
24:12:55.484 --> 24:12:58.641
现在我们可以查一下余额了。

14536
24:12:58.641 --> 24:12:59.079
副本。

14537
24:12:59.079 --> 24:13:01.547
贴得好，就是一个。

14538
24:13:01.547 --> 24:13:04.902
现在我们来做10。

14539
24:13:04.902 --> 24:13:08.226
存款，它拿走了余额。

14540
24:13:08.226 --> 24:13:09.954
现在这里有这么多。

14541
24:13:09.954 --> 24:13:11.513
这里有这么多。

14542
24:13:11.513 --> 24:13:13.763
如果我们退出，那就是全部退出。

14543
24:13:13.871 --> 24:13:19.775
如果我们把账户转到别人名下，我们点取款。

14544
24:13:19.871 --> 24:13:23.585
什么都不会发生，因为另一个账户什么都没有，这也说得通。

14545
24:13:23.585 --> 24:13:26.193
所以这里有很多钱，对吧。

14546
24:13:26.193 --> 24:13:33.553
如果我们与合同达成平衡，我们就能看到它有多少钱，对吧?它总共有这么多钱。

14547
24:13:33.553 --> 24:13:41.395
现在我们可以在另一个账户上做什么，我们选择这个全新的账户，我们来部署攻击契约。

14548
24:13:41.395 --> 24:13:46.299
我们将把可重入值address作为输入参数传递给它。

14549
24:13:46.299 --> 24:13:48.299
所以我们会部署它。

14550
24:13:48.299 --> 24:13:52.023
现在我们要做的是调用攻击。

14551
24:13:52.023 --> 24:14:04.228
你会看到，即使这个合约没有任何东西存入可重入脆弱合约，我们仍然会窃取这里所有的资金或者几乎所有的资金。

14552
24:14:04.228 --> 24:14:19.478
现在点击获取余额，一个可重入易受攻击者，这里是，获取余额a这里是0，这是地址，我们现在有了攻击，现在得到反弹，哦，不好意思在公共场合，提款也应该是可支付的。

14553
24:14:19.478 --> 24:14:25.952
现在我们将传递一个以太作为攻击函数的输入参数，我们将只存入一个以太。

14554
24:14:25.952 --> 24:14:27.574
然后我们就会退出。

14555
24:14:27.574 --> 24:14:32.746
我们会继续退出，因为我们的回退函数会继续调用退出。

14556
24:14:32.746 --> 24:14:39.746
我们所要做的就是存入一个以太币，我们就能取出里面的11个以太币。

14557
24:14:39.871 --> 24:14:42.000
所以我们现在就开始进攻。

14558
24:14:44.871 --> 24:14:54.226
合同的新余额是12，因为我们存入的1和我们偷走的11，旧合同的新余额现在是0。

14559
24:14:54.226 --> 24:14:55.774
这被称为重入体。

14560
24:14:55.872 --> 24:14:56.561
看到攻击。

14561
24:14:59.872 --> 24:15:05.041
在提取过程中，我们允许代码在不同的契约上运行。

14562
24:15:05.041 --> 24:15:22.440
在这个合约上运行的代码，在余额设置为零之前召回withdraw，我们在这里调用其他代码的回退函数，它调用withdraw，我们需要重读withdraw在我们设置一个sender等于零的消息之前。

14563
24:15:22.440 --> 24:15:24.043
这显然是个问题。

14564
24:15:24.043 --> 24:15:26.216
我们有两种方法可以预防它。

14565
24:15:26.216 --> 24:15:27.302
有个简单的方法。

14566
24:15:27.302 --> 24:15:31.568
还有互斥锁的方式，我不想说难的方式，它只是一种不同的方式。

14567
24:15:31.568 --> 24:15:41.760
你在安全工具中经常看到的一件事是你总是希望调用任何外部契约作为函数的最后一步，或事务的最后一步。

14568
24:15:41.760 --> 24:16:00.581
我们希望在调用外部契约之前将bounce更新为零，因为消息发送方的余额在调用外部代码之前被重置为零，然后如果它试图重新输入这个，它会碰到这个require步骤然后在这里取消，无法再次发送以太。

14569
24:16:00.581 --> 24:16:03.161
这是我们能做的第一步。

14570
24:16:03.161 --> 24:16:06.821
下一步我们可以使用一个叫做互斥锁的东西。

14571
24:16:06.872 --> 24:16:22.855
这就是open Zeppelin用他们的一个修饰符所做的，我们可以有一些布尔类型叫做locked或者别的什么，就在最上面，我们可以说require not locked。

14572
24:16:22.855 --> 24:16:24.625
否则,恢复。

14573
24:16:24.625 --> 24:16:30.983
然后我们在契约中做的第一件事是，我们可以说locked = true。

14574
24:16:30.983 --> 24:16:34.618
然后我们在这里做的最后一件事是我们说locked = false。

14575
24:16:34.618 --> 24:16:45.373
在这里使用这个锁，我们一次只允许一段代码在这里执行我们只在代码完成时解锁它。

14576
24:16:45.373 --> 24:16:50.405
现在open Zeplin带有一个可重入保护，我们可以在我们的代码中使用。

14577
24:16:50.405 --> 24:17:03.587
它有一个修饰符non - reentrant它的作用和我们在锁中讨论的一样它创建一个名为status的变量并在函数被输入时将其更改为enter。

14578
24:17:03.587 --> 24:17:07.794
它运行完代码，然后在完成时将其更改为未输入。

14579
24:17:07.794 --> 24:17:11.050
无论什么时候运行任何代码，它只要求不输入它。

14580
24:17:11.050 --> 24:17:27.808
如果我们想在代码中使用这个，我们可以在open Zeppelin导入，斜杠，合同，斜杠安全，斜杠重入。

14581
24:17:27.808 --> 24:17:35.922
守卫，所以我们可以继承功能，说非入口市场是可重入守卫。

14582
24:17:35.922 --> 24:17:48.364
然后任何我们担心的函数都会有这个可重入的see问题，比如by item，我们会添加修饰符non reentrant。

14583
24:17:48.364 --> 24:17:49.315
就像这样。

14584
24:17:49.315 --> 24:17:52.856
这会增加互斥锁，也就是我们讲过的锁机制。

14585
24:17:52.856 --> 24:17:58.098
互斥锁的方式对我们的安全性来说更加明确，对吧?因为我们说，嘿，这是锁着的。

14586
24:17:58.098 --> 24:18:00.227
这是一个不可重入函数。

14587
24:18:00.227 --> 24:18:09.440
这仍然是一个最佳实践，当你调用外部代码时，就像我们在这里看到的，你在调用外部契约之前做所有的状态更改。

14588
24:18:09.440 --> 24:18:11.159
现在，你可能会说，哦，这太酷了。

14589
24:18:11.159 --> 24:18:25.249
但是这和我们的NF t有什么关系呢?想象一下，不是sender。call的消息，你知道，所有的成功等于，你知道，一些nft。传输，然后我们从这里做一些传输。

14590
24:18:25.249 --> 24:18:36.696
而不是做一些后备的东西，我们的NF T有我们的NF T的功能转移从similis代码重新进入我们的提取。

14591
24:18:36.696 --> 24:18:41.670
如果我们像这样设置取款，因为我们仍然调用与NFT的外部合同。

14592
24:18:41.670 --> 24:18:48.284
从外部合同中的转移可能是恶意的，并试图重新进入我们的合同。

14593
24:18:48.284 --> 24:19:01.120
作为最佳实践，在调用任何可能无法控制的外部契约之前，您总是希望改变自己的状态，我强烈建议您尝试一下这个方法，因为眼见为实。

14594
24:19:01.120 --> 24:19:09.606
话虽如此，这个的所有代码都会在GitHub中提供与这个可重入脆弱代码相关的课程。

14595
24:19:09.606 --> 24:19:15.737
说到这里，让我们回到我们的非功能性项目。

14596
24:19:15.874 --> 24:19:34.749
好了，现在我们知道了为什么我们要从我们的函数的底部在我们的生物的底部进行这个安全转移，因为如果我们的安全转移函数从稍微高一点，可能最终会发生的是我们在更新它们之前将多个NF T发送到错误的地址。

14597
24:19:34.749 --> 24:19:36.207
这就是我们这么做的原因。

14598
24:19:36.207 --> 24:19:37.540
我们赞成推倒保罗。

14599
24:19:37.540 --> 24:19:43.818
就像我们说的，在这门课中，你会学到很多安全技巧。

14600
24:19:43.818 --> 24:19:47.187
但这仍然很好，我们有我们的by项。

14601
24:19:47.187 --> 24:19:49.625
我们有列表项函数。

14602
24:19:49.625 --> 24:19:53.708
现在我们来做一个取消项目，或取消列表。

14603
24:19:53.875 --> 24:19:57.701
我们来做一个函数。

14604
24:19:57.875 --> 24:20:02.350
取消名单，我们来做非ft地址。

14605
24:20:04.875 --> 24:20:05.108
ID。

14606
24:20:05.108 --> 24:20:09.074
这是一个外部函数。

14607
24:20:11.875 --> 24:20:14.357
当然，只有这个实体的所有者才能取消它。

14608
24:20:14.875 --> 24:20:17.644
说的是主人。

14609
24:20:17.875 --> 24:20:23.125
如果T地址，令牌ID消息点森。

14610
24:20:24.875 --> 24:20:27.925
确保NFT确实被列出了。

14611
24:20:29.875 --> 24:20:32.675
ft地址，令牌ID。

14612
24:20:32.675 --> 24:20:33.841
和伟大的。

14613
24:20:36.875 --> 24:20:46.366
我们要做的是删除s的列表NFT地址令牌ID，我们要删除那个映射。

14614
24:20:46.366 --> 24:20:56.255
然后我们会发出一个事件项cancelled message。sender和if T地址和令牌ID。

14615
24:20:56.255 --> 24:21:01.475
当然，我们会在这里创建一个新事件。

14616
24:21:01.475 --> 24:21:04.475
我们说event item cancelled。

14617
24:21:04.475 --> 24:21:11.875
它将是一个地址索引的卖家地址。

14618
24:21:11.875 --> 24:21:14.875
索引非ft地址。

14619
24:21:14.875 --> 24:21:17.616
你想56索引令牌ID。

14620
24:21:17.616 --> 24:21:18.261
好吧。

14621
24:21:18.261 --> 24:21:18.648
太好了。

14622
24:21:18.648 --> 24:21:20.284
真快啊。

14623
24:21:20.284 --> 24:21:21.677
取消听力。

14624
24:21:21.677 --> 24:21:22.086
繁荣。

14625
24:21:22.086 --> 24:21:22.495
杰克。

14626
24:21:22.495 --> 24:21:22.904
完成了。

14627
24:21:22.904 --> 24:21:27.294
接下来是什么?好了，让我们更新一下我们的清单。

14628
24:21:27.294 --> 24:22:00.476
我们会做函数更新listing address如果你去的第6个令牌ID的地址你去的6个新价格会更新这个的价格这个外部的价格我们会确保它被列出列出的是说所有者做一个令牌ID然后我们会做message。sender。

14629
24:22:00.476 --> 24:22:09.703
现在更新我们的列表，我们只说s下划线列表的NF T地址。

14630
24:22:09.703 --> 24:22:15.438
令牌ID。price等于我们给它的新价格。

14631
24:22:15.438 --> 24:22:18.842
然后我们承认，我们可以省略item updated。

14632
24:22:18.842 --> 24:22:28.203
但我们也可以省略一个带有MSG点发送者非ft地址，令牌ID，新价格的项目。

14633
24:22:28.203 --> 24:22:33.548
因为本质上，通过更新它，我们本质上只是用一个新的价格重新列出它。

14634
24:22:33.548 --> 24:22:41.256
我们只需要做一个项目列表事件，我们只需要做一个函数，我们需要做一个提取收益。

14635
24:22:41.256 --> 24:22:49.476
我们写函数，提取收益来得到所有实体的所有支付。

14636
24:22:49.476 --> 24:23:11.152
我们会通过new activity得到收益6progress=s_ progressmsg。sender，对吧，我们会得到所有按项目收集的支付，我们说如果progress小于等于0，那么我们将返回没有收益的情况。

14637
24:23:11.152 --> 24:23:14.009
我们要把它变成非功能性的。

14638
24:23:14.009 --> 24:23:17.810
市场没有收益。

14639
24:23:17.810 --> 24:23:32.623
Excel在顶部创建错误空市场没有收益，否则，我们会说s下划线收益的MSG。sender = 0。

14640
24:23:32.623 --> 24:23:38.283
所以我们要把收益重置为零，对吧，我们要在发送任何收益之前这么做。

14641
24:23:38.283 --> 24:23:57.652
然后我们会用传统的方式发送支付，bool success = payable, message。sender callvalue将是收益，这里全部为空。

14642
24:23:57.652 --> 24:24:16.877
然后我们可以要求，你知道，我们可以要求成功，或者我们可以说，如果不成功，返回与Aleksey市场，转移失败。

14643
24:24:16.877 --> 24:24:22.127
然后我们将使它成为一个新的空气，空气非ft市场转移失败。

14644
24:24:22.127 --> 24:24:23.877
这里加个分号。

14645
24:24:23.877 --> 24:24:26.409
我们看起来很好。

14646
24:24:26.409 --> 24:24:29.231
现在我们甚至有办法取款了。

14647
24:24:29.231 --> 24:24:31.808
这里有五个函数。

14648
24:24:31.808 --> 24:24:32.359
太棒了。

14649
24:24:32.359 --> 24:24:35.422
我们来创建几个getter。

14650
24:24:35.422 --> 24:24:38.694
也许我们可以复制这个。

14651
24:24:38.877 --> 24:24:42.747
粘贴到这里，getter函数是这样的。

14652
24:24:43.877 --> 24:24:46.290
函数，我们可以用getlisting。

14653
24:24:47.877 --> 24:24:58.687
地址，实用程序X令牌ID，外部视图，它在内存中返回一个列表。

14654
24:24:58.687 --> 24:25:08.592
我们会说，返回nnft地址令牌Id的下划线列表，像这样。

14655
24:25:08.592 --> 24:25:25.801
还有函数，获取地址卖家的收益，外部视图回报，你去到desex回报s下划线卖家的收益。

14656
24:25:25.801 --> 24:25:29.136
我们就能知道某人欠了多少钱。

14657
24:25:29.136 --> 24:25:36.746
然后是任何清单让我们在这里运行一个小的编译，yarn，或者点击compile或者hh compile看看我们搞砸了哪里。

14658
24:25:36.746 --> 24:25:37.778
哦，我们搞砸了。

14659
24:25:37.878 --> 24:25:39.648
哇，太好了。

14660
24:25:42.878 --> 24:25:50.262
成功地创建了一个极简的、完全去中心化的非金融市场。

14661
24:25:50.262 --> 24:25:51.800
这太疯狂了。

14662
24:25:51.800 --> 24:25:53.844
这是非常强大的。

14663
24:25:53.844 --> 24:25:56.420
你应该为自己感到高兴。

14664
24:25:56.420 --> 24:25:58.114
很酷，做得很好。

14665
24:25:58.114 --> 24:26:02.369
但你知道，我们还没有完成，我们还得写一些部署和测试。

14666
24:26:02.369 --> 24:26:03.555
让我们开始吧。

14667
24:26:03.555 --> 24:26:11.462
既然我们已经做过几次了，我实际上鼓励您在这里暂停视频，并尝试编写自己的部署脚本和测试。

14668
24:26:11.462 --> 24:26:21.497
然后再回来跟我们一起看是否做对了，我们会创建一个名为deploy的新文件夹。

14669
24:26:21.497 --> 24:26:27.163
当然，我们已经在我们的硬帽配置中部署了硬帽。

14670
24:26:27.163 --> 24:26:28.734
我们知道可以开始了。

14671
24:26:28.734 --> 24:26:31.164
我们来创建一个1。

14672
24:26:31.164 --> 24:26:33.628
部署非ft市场。

14673
24:26:33.628 --> 24:26:33.842
js。

14674
24:26:33.842 --> 24:27:00.800
再说一次，你们以前见过很多这样的，所以我们就不讲细节了do const network = require hard hat to constant development chains，等于= require。点。斜杠帮助我们的hard hats配置，我们应该让我们看看。

14675
24:27:00.879 --> 24:27:01.828
是复制粘贴吗?不。

14676
24:27:02.879 --> 24:27:06.729
以上是从上一个项目的助手Hardhead配置，让我们继续并抓住它。

14677
24:27:06.729 --> 24:27:10.879
或者我们可以从智能合约抽签中获取并粘贴到这里。

14678
24:27:10.879 --> 24:27:15.279
我们只需要这个文件用于开发链。

14679
24:27:15.279 --> 24:27:19.338
对于硬帽和本地主机，我们将从中获取开发链。

14680
24:27:19.338 --> 24:27:22.895
然后我们还会抓取const。

14681
24:27:22.895 --> 24:27:27.124
Verify = require，从utils中获取。

14682
24:27:27.124 --> 24:27:30.499
验证,对吧?我们有效用吗，我们核实过了。

14683
24:27:30.499 --> 24:27:31.533
太棒了。

14684
24:27:31.533 --> 24:27:36.414
现在我们来做modules that exports equals async。

14685
24:27:36.414 --> 24:27:45.079
一个async函数，它将获取命名帐户和部署。

14686
24:27:45.079 --> 24:27:52.027
从硬帽输入参数，然后我们要做const。

14687
24:27:52.027 --> 24:27:55.141
Deploy, log = deployment。

14688
24:27:55.141 --> 24:28:01.450
然后是const, Deployer = await，获取命名帐户。

14689
24:28:01.450 --> 24:28:05.879
当然，我们从hearthead。config中得到。

14690
24:28:05.879 --> 24:28:08.746
我们有命名帐户，我们有一个部署者。

14691
24:28:08.880 --> 24:28:12.208
我们这里有个我们上个项目的玩家。

14692
24:28:12.208 --> 24:28:16.848
现在我们的实体市场有构造函数了吗?构造?不，没有构造函数。

14693
24:28:16.848 --> 24:28:19.435
我们知道args是空的。

14694
24:28:19.435 --> 24:28:22.768
然后我们可以说const NFT。

14695
24:28:22.768 --> 24:28:26.750
市场等于等待，部署。

14696
24:28:26.750 --> 24:28:36.170
如果T市场，比如从部署者，args将是args。

14697
24:28:36.170 --> 24:28:38.363
Log为真。

14698
24:28:38.363 --> 24:28:56.930
然后等待确认将是network。config。wait confirmation或者一二，这将是阻塞病人的，我们会进入配置，确保这些都在这里。

14699
24:28:56.930 --> 24:28:59.439
抱歉，我没把它们加进来。

14700
24:28:59.439 --> 24:29:06.563
所有网络的区块确认都是6个。

14701
24:29:06.563 --> 24:29:14.229
实际上我不是从上一个项目中获取的，它看起来像是我从安全帽入门套件中获取的。

14702
24:29:14.229 --> 24:29:16.255
我要把这些区块确认加进去。

14703
24:29:16.255 --> 24:29:17.426
现在我们可以开始了。

14704
24:29:17.426 --> 24:29:38.786
现在我们要说的是，如果我们不在开发链上，不在开发链上包括网络。名称，进程研究和以太扫描API key，然后我们会继续，我们会做日志验证。

14705
24:29:38.786 --> 24:29:42.202
然后我们会做一个重量验证。

14706
24:29:42.202 --> 24:29:52.081
如果市场上的。address带圆弧，那么我们会在这里写一大堆连字符。

14707
24:29:52.081 --> 24:30:01.947
最后，导出点标记的模块等于所有，然后NFT Mar好地方。

14708
24:30:01.947 --> 24:30:08.608
我们可以用纱线硬头部署来测试这个部署功能。

14709
24:30:08.608 --> 24:30:09.981
太达，我们成功了。

14710
24:30:09.981 --> 24:30:10.281
太好了。

14711
24:30:10.281 --> 24:30:15.996
现在我们有了部署功能，我们可以验证契约，我们还需要做什么。

14712
24:30:15.996 --> 24:30:20.692
由于这是一个非功能性的市场，我们可能需要一些非功能性的t。

14713
24:30:20.692 --> 24:30:30.781
所以我们能做的是在我们的合同中，我们会为测试创建一个新文件夹在这里有一个新文件叫Basic NF T。soul。

14714
24:30:30.781 --> 24:30:35.569
在这里，我们可以添加我们上一个项目的基本NF T。

14715
24:30:35.569 --> 24:30:45.372
或者你可以去我的或者你可以去和这门课相关的GitHub回购，去契约，测试，基本NF t，然后复制粘贴。

14716
24:30:45.372 --> 24:30:46.847
这也很有效。

14717
24:30:46.847 --> 24:30:56.777
所以我们使用的基本NF t只是指向哈巴狗作为我们用来测试的基本NF t。

14718
24:30:56.777 --> 24:31:08.666
现在我们有了一个基本的NFT我们需要创建一个新文件，来部署基本的NFT T。js，我们会从这里借用很多样板。

14719
24:31:08.666 --> 24:31:13.181
我们把这些都复制粘贴进来。

14720
24:31:13.181 --> 24:31:24.088
我们会说const args = blank，我们会说const basic NF t = await deploy basic NF t。

14721
24:31:24.088 --> 24:31:26.729
从部署人员。

14722
24:31:26.729 --> 24:31:31.303
Args将是Args。

14723
24:31:31.303 --> 24:32:16.931
Log将是true weight。config。block confirmation或1然后我们将用if not develop meant chains。包括network。name和process。EMV，以太扫描API key，它会说Log或to find。A。等待在那里如果我basic NFT。address和arcs, module。exports。tags = all和basic NFT。

14724
24:32:16.931 --> 24:32:22.063
我们可以用纱线来测试这两种方法。

14725
24:32:22.063 --> 24:32:23.590
和美妙的。

14726
24:32:23.590 --> 24:32:26.501
这两种方法都已得到部署。

14727
24:32:26.501 --> 24:32:27.977
再说一次，你不需要停顿。

14728
24:32:27.977 --> 24:32:33.463
但这是一种很好的方法，可以让你在做所有这些事情的时候真正地磨砺自己的技能。

14729
24:32:33.463 --> 24:32:36.517
重复是所有技能之母。

14730
24:32:36.517 --> 24:32:46.914
所以自己重复这些东西，自己思考这些问题，自己尝试编码这些东西，是真正能让你在这方面成功的东西。

14731
24:32:46.914 --> 24:32:48.373
好吧，太棒了。

14732
24:32:48.373 --> 24:32:52.656
现在我们有了部署Betson，是时候编写一些测试了。

14733
24:32:52.656 --> 24:33:03.566
现在，如果你去到与这门课程相关的GitHub repo，你去到测试文件夹，测试这里有一些健壮的，实际上我们所有的项目都写过，这里有很多测试。

14734
24:33:03.566 --> 24:33:09.682
这里的几乎所有东西，我们都已经学过了你们也已经知道怎么做了你们有能力去做。

14735
24:33:09.682 --> 24:33:13.765
我要继续，让你们开始，我们要一起写一个测试。

14736
24:33:13.765 --> 24:33:22.435
然后我强烈建议你回去，你试着自己写一些测试，让代码覆盖率让测试覆盖率达到100%。

14737
24:33:22.435 --> 24:33:28.583
让我们继续，我们将一起编写一个测试，然后你应该暂停这个视频，试着自己编写一些测试。

14738
24:33:28.583 --> 24:33:35.476
当您完成了编写测试，并且认为自己已经达到了100%时，请随意与我们编写的测试进行比较。

14739
24:33:35.476 --> 24:33:40.459
让我们创建一个名为tests的新文件夹。

14740
24:33:40.459 --> 24:33:41.052
测试。

14741
24:33:41.052 --> 24:33:43.866
在这里，我们要做一个新的单位。

14742
24:33:43.866 --> 24:33:48.817
如果你想稍后再写分段测试，你完全可以，我们不会。

14743
24:33:48.883 --> 24:33:54.883
我们会在这里创建一个新文件叫做NFT marketplace。

14744
24:33:54.883 --> 24:33:55.327
测试。

14745
24:33:55.883 --> 24:33:58.709
我们会开始做一些测试

14746
24:34:00.883 --> 24:34:07.849
cert, expect = require Chai const。

14747
24:34:11.883 --> 24:34:26.798
以太，等于需要硬帽const开发链等于需要点。点。斜杠助手，急性子配置。

14748
24:34:26.883 --> 24:34:29.514
我们要做和之前一样的安排。

14749
24:34:29.883 --> 24:34:44.216
说bang发展链点包括网络点名称、问号、描述点跳过。

14750
24:34:44.216 --> 24:34:46.549
其他描述。

14751
24:34:46.549 --> 24:34:57.843
如果nft市场测试，逗号async函数，不好意思，这只是一个函数。

14752
24:34:57.843 --> 24:35:02.464
Scrabble oval只是一个函数，而不是一个异步函数，像这样。

14753
24:35:02.464 --> 24:35:02.851
太好了。

14754
24:35:02.851 --> 24:35:07.124
现在我们取一些变量，在每个变量之前做a。

14755
24:35:07.124 --> 24:35:14.470
我们说NF T市场，基本的NF T，我们会创造一个不变的价格。

14756
24:35:14.470 --> 24:35:18.427
我们总是将所有NF T的价格设为相同。

14757
24:35:18.427 --> 24:35:23.868
这将是ether。utils。parse ether 0。

14758
24:35:23.868 --> 24:35:24.008
1.

14759
24:35:24.008 --> 24:35:31.461
我们说const令牌ID现在总是0。

14760
24:35:31.884 --> 24:35:38.759
然后我们在每个将是一个async函数之前。

14761
24:35:38.884 --> 24:35:44.222
我们会出去的，我们也会救出迪布耶尔。

14762
24:35:45.884 --> 24:35:48.902
等号等待，获得命名帐户。

14763
24:35:50.884 --> 24:35:59.074
抓取从硬帽子进入帐户，以及把这一切。部署器Excel，然后我们也会在我们的心帽子。

14764
24:35:59.074 --> 24:35:59.454
配置。

14765
24:35:59.454 --> 24:35:59.580
js。

14766
24:35:59.580 --> 24:36:03.503
在get named accounts下面，我们还有一个叫做player的东西。

14767
24:36:03.503 --> 24:36:05.312
这个我没有讲太多。

14768
24:36:05.312 --> 24:36:15.384
但是我们会有第二个账户它被默认为第一个索引，对吧?所以我们可以在顶部做上来的玩家。

14769
24:36:15.384 --> 24:36:23.752
我们可以说，player = await getnames accounts。player。

14770
24:36:23.884 --> 24:36:29.384
现在我们有了一个玩家和一个部署者帐户来等待部署，这是固定的。

14771
24:36:29.384 --> 24:36:37.800
所有这些契约都会在deploy文件夹中运行。

14772
24:36:37.885 --> 24:36:39.726
我们将拥有我们的非功能性市场。

14773
24:36:41.885 --> 24:36:46.766
等待醚点得到合同和ft。

14774
24:36:46.766 --> 24:36:48.393
市场。

14775
24:36:49.885 --> 24:36:56.996
我们会做基本的NF t等于等待醚点得到合同。

14776
24:36:57.885 --> 24:36:58.212
NF T。

14777
24:37:02.885 --> 24:37:07.885
grab东西，无论帐户0是什么，也就是我们的部署者。

14778
24:37:07.885 --> 24:37:25.248
如果我们想在非ft市场上调用一个函数，玩家是调用函数的人，我们就必须说，实体市场等于等待和空市场点连接玩家像这样。

14779
24:37:25.248 --> 24:37:31.588
现在，每当我们调用一个函数时，我们都会使用player而不是Deployer。

14780
24:37:31.588 --> 24:37:38.901
有时我喜欢做的是你们会在我的代码中看到，我要让非功能性市场契约。

14781
24:37:38.901 --> 24:37:48.212
然后让NFT市场，然后我写NFT市场合约等于等待醚。合约。

14782
24:37:48.212 --> 24:37:52.456
然后我将把它连接到NF - T市场。

14783
24:37:52.456 --> 24:37:59.813
是的，我们可以这样做，我们可以自动选择谁连接谁想要连接写和得到合同。

14784
24:37:59.813 --> 24:38:02.099
但有时候直白一点真的很好。

14785
24:38:02.099 --> 24:38:03.072
所以这真的取决于你。

14786
24:38:03.072 --> 24:38:11.120
我将撤销所有这些，我只是想重新演示一下确保你们知道这是如何在不同的帐户和不同的用户之间切换的。

14787
24:38:11.120 --> 24:38:16.836
现在我们有了一个非功能性T，我们可能需要制造非功能性T，这样我们就可以把它投放到市场上。

14788
24:38:16.886 --> 24:38:23.508
所以我们会等待基本的NF T，然后我们会批准把它送到市场上。

14789
24:38:23.508 --> 24:38:24.753
我们先等一下。

14790
24:38:24.886 --> 24:38:36.386
基本NF T点批准和T市场地点点地址令牌ID，这将是零。

14791
24:38:36.386 --> 24:38:42.886
就像这样，NOC市场记住，它不能要求批准，因为它不拥有NF t。

14792
24:38:42.886 --> 24:38:45.347
所以我们需要部署者。

14793
24:38:45.347 --> 24:38:46.869
电话通过了，对。

14794
24:38:46.869 --> 24:38:51.219
记住，因为我们不是我们需要在这里加入基本的NF T。

14795
24:38:51.219 --> 24:38:58.580
因为我们没有告诉ether谁来连接它它会自动连接到我们的部署者因为这是帐户0。

14796
24:38:58.580 --> 24:39:05.467
所以是由部署者调用并制造它然后由部署者批准将它发送到市场。

14797
24:39:05.467 --> 24:39:12.821
只有在这个被批准的功能被调用之后，才能将所有这些NFT的转移称为非功能性市场。

14798
24:39:12.821 --> 24:39:15.771
现在我们只做一个测试。

14799
24:39:15.771 --> 24:39:20.000
我们会说它可以被买到。

14800
24:39:20.000 --> 24:39:23.419
就是这样，这将是一个async函数。

14801
24:39:23.419 --> 24:39:30.486
我们打算把NFT上市然后买下一个举重实体市场。

14802
24:39:30.486 --> 24:39:38.066
如果我们去我们的能源市场，我们要做什么，我们要把它列出，我们要列出项目，或者用地址令牌ID和价格。

14803
24:39:38.066 --> 24:39:41.475
我们用。listitem。

14804
24:39:41.475 --> 24:39:47.368
基本的nft点地址，令牌ID为0，我们已经在这里定义了。

14805
24:39:47.368 --> 24:39:50.299
然后是价格，这里也有硬编码。

14806
24:39:50.299 --> 24:39:51.569
所以我们把它列出来。

14807
24:39:51.569 --> 24:39:59.628
所以部署者拥有NF T，玩家现在将其列在列表中，现在我们想要购买它，让玩家成为购买者。

14808
24:39:59.628 --> 24:40:05.430
所以我们要做的就是将玩家与非功能性市场连接起来。

14809
24:40:05.430 --> 24:40:14.543
所以我们可以说const player connected NF T, marketplace =和ft marketplace。Connect。

14810
24:40:14.543 --> 24:40:15.199
的球员。

14811
24:40:15.199 --> 24:40:23.188
然后我们可以通过说一个重量播放器连接到ft市场来购买这个物品。

14812
24:40:23.188 --> 24:40:23.848
通过项目。

14813
24:40:23.848 --> 24:40:31.628
它将是最基本的，如果我们回头看市场的末端，购买物品需要什么，需要非ft地址和令牌ID。

14814
24:40:31.628 --> 24:40:43.420
因此，基本的NF和这个地址，然后是令牌ID，在这个机器人之后，我们应该检查，看看玩家确实拥有那个NF团队。

14815
24:40:43.420 --> 24:40:48.980
所以我们可以说const new owner然后检查那个owner是否确实更新了。

14816
24:40:48.980 --> 24:41:04.161
我们可以说基本的NFT。owner of因为NFT有一个函数的所有者，令牌ID然后我们还想看到部署者实际上会得到报酬。

14817
24:41:04.161 --> 24:41:11.744
我们可以说await和if T。get Deployer的收益。

14818
24:41:11.744 --> 24:41:29.277
现在我们可以断言new owner。2string = player我们可以断言deployer收益。

14819
24:41:29.277 --> 24:41:31.820
字符串等于价格。

14820
24:41:31.820 --> 24:41:36.677
因为他们应该为此付出代价。

14821
24:41:36.677 --> 24:41:39.405
这是对的，实际上更简单一些。

14822
24:41:39.405 --> 24:41:42.173
而不是通过获取命名帐号来获取玩家。

14823
24:41:42.173 --> 24:41:45.157
直接从醚中获取会更容易一些。

14824
24:41:45.157 --> 24:41:51.129
我们写const accounts = await get signers。

14825
24:41:51.129 --> 24:42:03.017
然后我们将save player = 1的账户因为当我们连接时，它期望它类型的账户然后get named账户是不同的类型。

14826
24:42:03.017 --> 24:42:05.316
哦，这样连接起来更简单一点。

14827
24:42:05.316 --> 24:42:10.841
现在我们要连接到player要知道player和deployer是不同类型的。

14828
24:42:10.841 --> 24:42:13.724
你会看到一些不同。

14829
24:42:13.724 --> 24:42:16.232
对我来说，是醚得到了签名者。

14830
24:42:16.232 --> 24:42:25.609
然后当我们买这个东西的时候，我们当然需要传递一个值，它是价格，当然，我们需要支付NFT的价格。

14831
24:42:25.609 --> 24:42:28.316
当然，这需要是player。address。

14832
24:42:28.316 --> 24:42:33.870
这就是现在的区别我们需要player那个地址每当我们需要其中一个以太账户的地址时。

14833
24:42:33.870 --> 24:42:36.678
然后这个新主人，当然，应该在等待。

14834
24:42:36.678 --> 24:42:38.396
现在我们可以运行这一切了。

14835
24:42:38.396 --> 24:42:43.141
在多田，我们看着事情过去。

14836
24:42:43.141 --> 24:42:54.051
因此，我们的非功能性市场能够促进任意人类对非功能性产品的买卖。

14837
24:42:54.051 --> 24:42:55.360
这太棒了。

14838
24:42:55.360 --> 24:43:01.755
所以我们只是运行了一个测试，以显示一点奇怪的工作时，与NF T和一些不同的帐户。

14839
24:43:01.755 --> 24:43:09.838
但是百分之百如果你已经准备好接受这个挑战，请暂停这个视频，试着写一些测试。

14840
24:43:09.838 --> 24:43:19.800
记住，这里的目标是为我们做纱线硬帽覆盖率，并看到我们的覆盖率是什么，并试图得到它是100%的覆盖率。

14841
24:43:19.800 --> 24:43:25.951
如果我们现在播放，我们会看到天哪，我们遗漏了很多内容。

14842
24:43:25.951 --> 24:43:31.098
在这里，我们有大量未覆盖的行，在未覆盖的函数、分支、语句等之上。

14843
24:43:31.098 --> 24:43:37.529
尝试编写一些测试以使其达到100%，然后返回。

14844
24:43:37.529 --> 24:43:40.200
好了，欢迎回来。

14845
24:43:40.200 --> 24:43:43.269
希望现在您已经编写了一些测试。

14846
24:43:43.269 --> 24:43:47.139
当你做测试的时候，你可以得到其中的一些，我是这样的，对吧。

14847
24:43:47.139 --> 24:43:50.475
这些是我的测试，这些是我写的测试，你可以做更多，你可以做最后。

14848
24:43:50.475 --> 24:43:54.155
让我想想，当我写硬头纱报道时，我甚至漏掉了几行。

14849
24:43:54.155 --> 24:43:56.698
我可以再多测试一下。

14850
24:43:56.698 --> 24:43:59.281
所以你的测试要比我做的更好。

14851
24:43:59.281 --> 24:44:01.872
这些是来自GitHub回购的测试与此相关。

14852
24:44:01.872 --> 24:44:05.751
现在我们已经编写了一些测试，让我们编写几个脚本。

14853
24:44:05.751 --> 24:44:09.973
我们要写几个脚本的原因是我们稍后会用到这些。

14854
24:44:09.973 --> 24:44:14.668
所以我们会写一些脚本来创造，一些被NF T戏弄的东西等等。

14855
24:44:14.668 --> 24:44:19.630
我们稍后会用到这个在前端摆弄一下。

14856
24:44:19.630 --> 24:44:27.212
要创建一个脚本，我们已经执行过了，让我们创建一个名为mint的脚本，以及list。js。

14857
24:44:27.212 --> 24:44:30.134
这将在NFT铸币。

14858
24:44:30.134 --> 24:44:33.986
然后马上上市了。

14859
24:44:33.986 --> 24:44:39.269
让我们创建一个名为mint和list的异步函数。

14860
24:44:39.269 --> 24:44:45.298
在下面，我们将调用mint然后用我们一直在做的脚本复制粘贴列表。

14861
24:44:45.298 --> 24:44:48.650
很明显，我们不叫它Maine，而是叫它mountain list。

14862
24:44:48.650 --> 24:45:01.734
在这个山地列表中，它是一个常数，NFT标记，在茶叶市场中，位置等于等待醚点得到合约。

14863
24:45:01.890 --> 24:45:03.441
和金融市场。

14864
24:45:06.890 --> 24:45:07.499
从安全帽。

14865
24:45:07.499 --> 24:45:09.374
然后我们取基本的NF - t。

14866
24:45:09.890 --> 24:45:10.890
表示常量。

14867
24:45:15.890 --> 24:45:16.676
合同。

14868
24:45:16.676 --> 24:45:17.757
基本NF t。

14869
24:45:22.890 --> 24:45:26.988
我们用console。log，保持在顶部。

14870
24:45:27.890 --> 24:45:30.973
做一个权值，或者我们用const。

14871
24:45:32.890 --> 24:45:35.690
基本NF T点薄荷NF T。

14872
24:45:39.890 --> 24:45:41.675
等等，等一个街区。

14873
24:45:41.675 --> 24:45:44.264
实际上我们要说的是const。

14874
24:45:44.890 --> 24:45:45.890
TX收据。

14875
24:45:45.890 --> 24:45:47.890
所以这个等于这个。

14876
24:45:50.890 --> 24:45:52.740
这也是为什么赛事如此精彩的原因。

14877
24:45:53.890 --> 24:45:59.723
我们在这个文档ID事件中省略了一个事件中的令牌ID。

14878
24:45:59.723 --> 24:46:10.660
我们可以说const令牌ID = mint TX receipt。events of 0。

14879
24:46:10.660 --> 24:46:13.905
args。token Id是这样的。

14880
24:46:13.905 --> 24:46:15.906
现在我们有了令牌ID。

14881
24:46:15.906 --> 24:46:18.690
现在我们有了令牌ID和基本的非ft。

14882
24:46:18.690 --> 24:46:22.290
我们现在可以调用我们的非ft市场列表项目。

14883
24:46:22.290 --> 24:46:25.590
现在我们写入console。log。

14884
24:46:25.590 --> 24:46:29.382
批准非功能性测试，和我们这里的测试很相似。

14885
24:46:29.382 --> 24:46:50.891
我要说const approval TX = await basic NFT data prove NFT marketplace。address token ID然后我们会做一个weight approved TX。wait 1然后我们会做console。log listing NFT。

14886
24:46:50.891 --> 24:47:11.568
然后我们会做const TX = await如果T market marketplace那个列表项我们会做NFT marketplace那个地址所以Id可以做await TX。wait one，控制台。log列表，很酷。

14887
24:47:11.568 --> 24:47:20.652
我们可以通过运行yarn hardhat node来验证这个，它会运行我们的部署脚本，它会运行到这些部署脚本。

14888
24:47:20.652 --> 24:47:31.491
然后在一个新的终端，我们会运行我们的脚本，yarn hard hat，运行脚本，列出破折号网络localhost。

14889
24:47:31.491 --> 24:47:36.908
我们错过了一个论点，我们还需要一个价格来列出我们的实体。

14890
24:47:36.908 --> 24:47:48.779
因此，我们创建一个常数价格等于我们写入ether。utils。parse, ether 0。

14891
24:47:48.779 --> 24:47:48.937
1.

14892
24:47:48.937 --> 24:47:53.197
然后我们将价格和传递给列表项。

14893
24:47:53.197 --> 24:48:02.201
哦，抱歉，这不是我们要上市的市场，当然是我们要上市的基本NF t，再运行一遍。

14894
24:48:02.201 --> 24:48:05.448
Bada bing, Bada boom，列出了一些事件。

14895
24:48:05.448 --> 24:48:08.891
我们可以看到，我们在做一些清单，很好。

14896
24:48:08.891 --> 24:48:10.181
现在我们有了一个脚本。

14897
24:48:10.181 --> 24:48:31.746
好了，现在我们有了一个脚本，稍后我们还会写几个其他的脚本，我们基本上有了一个非常可靠的回购这是我们完全去中心化的非金融市场，这绝对是巨大的，你们应该为自己感到非常非常自豪。

14898
24:48:31.892 --> 24:48:33.576
当然，这些都是代码。

14899
24:48:34.892 --> 24:48:38.569
有了这个，如果他们是软件开发人员，这很好。

14900
24:48:38.892 --> 24:48:45.825
我们想让任何人都能在我们的市场上进行互动，列出他们自己的NF - t。

14901
24:48:45.825 --> 24:48:51.098
那我们要怎么做呢?我们要为它做一个前端。

14902
24:48:51.098 --> 24:48:54.360
现在我们要进入这节课的第二部分。

14903
24:48:54.360 --> 24:48:57.953
第十五课，我们刚讲了后端。

14904
24:48:57.953 --> 24:49:01.793
现在我们来看看前面，我们从这个沼泽代码开始。

14905
24:49:01.793 --> 24:49:06.197
这两个程序的代码几乎完全相同。

14906
24:49:06.197 --> 24:49:09.315
但我们将从莫拉莱斯开始，我们将教你如何做这两件事。

14907
24:49:09.315 --> 24:49:12.247
我们会教你们莫拉莱斯和莫图的区别。

14908
24:49:12.247 --> 24:49:16.925
我们一开始为什么要用它们，我们从莫拉莱斯开始。

14909
24:49:16.925 --> 24:49:23.463
如果你想继续下一节的内容，我们要用到的所有代码，都在这里。

14910
24:49:23.463 --> 24:49:34.130
所以你们很兴奋，我希望你们很兴奋，因为这将是一个非凡的会议，我们将建立一个最复杂的前端，我们可以使用我们所拥有的工具。

14911
24:49:34.130 --> 24:49:37.334
就像我说的，我们之前向你们展示过这是什么样子的。

14912
24:49:37.334 --> 24:49:39.055
让我们快速复习一下。

14913
24:49:39.055 --> 24:49:41.613
这就是前端的样子。

14914
24:49:41.613 --> 24:49:47.954
但我们能做的是用连接按钮连接，我们点击Metamask, Metamask弹出，我们继续连接。

14915
24:49:47.954 --> 24:49:53.203
现在我们连接起来了，我们可以看到不同的NF T在这里。

14916
24:49:53.203 --> 24:49:57.831
如果我们在一个属于我们的地址上，它会显示为你所有。

14917
24:49:57.893 --> 24:50:02.565
如果我们交换地址，我将继续更新，连接到那里。

14918
24:50:02.565 --> 24:50:04.789
现在我们的地址不一样了。

14919
24:50:04.893 --> 24:50:07.617
如果它是我们的，我们会看到这个小的盘旋，上面写着Update listing。

14920
24:50:07.617 --> 24:50:09.013
现在它值0。

14921
24:50:09.013 --> 24:50:09.116
18.

14922
24:50:09.116 --> 24:50:12.854
我们的市场上就是这么标价的。

14923
24:50:12.854 --> 24:50:16.842
如果它是我们的，我们点击它，就可以更新到不同的价格。

14924
24:50:16.893 --> 24:50:22.840
让我们将其更新到50每先令，或无论你的第一层货币是什么，我们将节省新的上市价格。

14925
24:50:22.840 --> 24:50:24.375
我们去确认一下。

14926
24:50:24.375 --> 24:50:28.859
我会说，列表更新了，请刷新，我们能做什么。

14927
24:50:28.859 --> 24:50:33.343
我们在后面挖一些区块，嘣，现在我们看到它值50。

14928
24:50:33.343 --> 24:50:45.993
如果我们切换到另一个账户，我们可以看到所有者是Baba blah，此时盘旋显示，由我足够被选为另一个用户，我将通过这个交易购买它。

14929
24:50:45.993 --> 24:50:49.618
现在请确认我是否要买，我就会看到一个小弹出框。

14930
24:50:49.618 --> 24:50:51.214
这是购买成功的项目。

14931
24:50:51.214 --> 24:50:58.893
现在如果我稍微刷新一下，我们就会看到NFT从市场上消失了，因为我们正确地购买了它，它不再可以出售。

14932
24:50:58.893 --> 24:51:02.532
现在我们能做的就是过来卖NF t恤。

14933
24:51:02.532 --> 24:51:06.508
在底部，我们会看到提取收益。

14934
24:51:06.508 --> 24:51:14.793
所以当有人购买NFT时，NFT市场实际上保留了收益实际上保留了销售的结果。

14935
24:51:14.793 --> 24:51:24.030
因此，如果我们切换回列出NFT的地址，我们现在可以看到提取50收益，因为我们知道我们每人有50，因为我们刚刚以50买了它。

14936
24:51:24.030 --> 24:51:37.094
如果我们点击取款，Metamask就会弹出，我们可以继续确认，等待一会，交易填充，一旦它通过，我们就会看到零收益。

14937
24:51:37.094 --> 24:51:39.760
对吧?我们把这里的一切都撤走了。

14938
24:51:39.894 --> 24:51:42.168
所以我们现在能做的就是重新列出非功能性。

14939
24:51:42.894 --> 24:51:58.687
回到刚刚以T买下它的那个如果我们知道nnf T的地址和令牌ID并且我们拥有它，我们可以继续重新上市你会把地址和令牌ID放在这里给它一个价格。

14940
24:51:58.687 --> 24:52:05.481
我们会提交，我们会批准让非功能性市场进入我们的或非功能性的，我们的小狗。

14941
24:52:05.481 --> 24:52:15.465
然后我们会发送交易，让NFT在市场上成功上市。

14942
24:52:15.465 --> 24:52:19.506
当我们在后端移动一些块后，我们可以回到前端。

14943
24:52:19.506 --> 24:52:25.598
我们现在看到，它归我们所有，而不是原来的主人，对吧，设为10以太币。

14944
24:52:25.598 --> 24:52:32.539
然后我们当然可以切换回不同的用户，我们可以让他们真正购买。

14945
24:52:32.539 --> 24:52:39.227
好了，现在我们有了合同，我们知道合同这一边是什么样子的。

14946
24:52:39.227 --> 24:52:42.168
现在我们来看看如何在前面做这个。

14947
24:52:42.168 --> 24:52:44.163
让我们进入代码编辑器。

14948
24:52:44.163 --> 24:52:49.281
如果我们戴着安全帽，带着我的NFT市场免费代码营文件夹，就开始吧。

14949
24:52:49.281 --> 24:52:50.119
太好了。

14950
24:52:50.119 --> 24:52:53.336
但我们要创建另一个文件夹，我们要下到CD和目录。

14951
24:52:53.336 --> 24:52:55.303
我们要创建一个新目录。

14952
24:52:55.303 --> 24:53:00.962
我称它为下一个Jas，如果T marketplace dash FCC。

14953
24:53:00.962 --> 24:53:05.401
现在你可以做下一个Jas市场dash mirallas FCC，如果你想的话。

14954
24:53:05.401 --> 24:53:10.582
再一次，我们开始与mirallas CD下Jas非ft市场FCC。

14955
24:53:10.582 --> 24:53:19.270
现在我们有了这个文件夹，点击code。打开一个新的VS code，或者你也可以点击File open folder打开这个新文件夹。

14956
24:53:19.270 --> 24:53:22.520
我们可以在这个新文件夹中开始工作。

14957
24:53:22.520 --> 24:53:29.040
现在我们在我们的新项目中，我们在我们的新文件夹中，我们要做我们之前做过的事情。

14958
24:53:29.040 --> 24:53:31.485
Yarn创建下一个应用，句号。

14959
24:53:31.485 --> 24:53:34.632
好的，我们已经完成了我们的设置。

14960
24:53:34.632 --> 24:53:36.963
现在，我不喜欢棉绒。

14961
24:53:36.963 --> 24:53:38.228
我还是要把它删掉。

14962
24:53:38.228 --> 24:53:43.153
我们要加入的是更漂亮的东西。

14963
24:53:43.153 --> 24:53:44.808
所以更漂亮的，忽略更漂亮的RC。

14964
24:53:44.808 --> 24:53:49.927
同样，有些人可能会强烈反对我的观点，但每个人都有自己的权利，这就是我喜欢做的事。

14965
24:53:49.927 --> 24:53:51.024
这就是我要做的。

14966
24:53:51.024 --> 24:54:01.957
现在我们有了一个极简反应项目，对吧?如果我们运行yarn Dev，我们打开那个站点上的UI，复制这个，或者命令，点击它。

14967
24:54:01.957 --> 24:54:02.269
这样。

14968
24:54:02.269 --> 24:54:03.269
欢迎收看下一期节目。

14969
24:54:03.269 --> 24:54:06.145
是的，我们有一个xjs应用程序。

14970
24:54:06.145 --> 24:54:09.504
我们知道，我们去页面，我们去索引。

14971
24:54:09.504 --> 24:54:09.660
js。

14972
24:54:09.895 --> 24:54:13.452
把这里的都删掉。

14973
24:54:16.895 --> 24:54:20.109
如果有东西，头会写嗨，感叹号。

14974
24:54:20.109 --> 24:54:21.555
我们会拯救，我们会回来。

14975
24:54:21.555 --> 24:54:22.519
现在我们看到Hi。

14976
24:54:22.519 --> 24:54:24.366
我放大一大堆。

14977
24:54:24.366 --> 24:54:24.649
繁荣。

14978
24:54:24.649 --> 24:54:28.791
现在我们有了一些极简的反应下一个，Jas。

14979
24:54:28.791 --> 24:54:31.640
我知道我们已经开始这个项目了。

14980
24:54:31.640 --> 24:54:34.104
让我们跳到自述文件。

14981
24:54:34.104 --> 24:54:39.028
我们来讨论一下我们想怎么做我们想让它看起来是什么样的。

14982
24:54:39.028 --> 24:54:41.640
我们要做一个主页。

14983
24:54:41.640 --> 24:54:53.942
在这个主页上，我们会说，我们会让它显示最近上市的，NFT的主页会显示最近上市的实体，它会说，如果你拥有NFT，你可以更新列表。

14984
24:54:53.942 --> 24:54:56.219
如果没有，您可以购买该列表。

14985
24:54:56.219 --> 24:54:57.095
我们会得到这个。

14986
24:54:57.095 --> 24:54:58.571
然后我们会有一个销售页面。

14987
24:54:58.571 --> 24:55:03.114
在这个页面上，你可以在市场上列出你的非ft。

14988
24:55:03.114 --> 24:55:07.137
这将是我们的两个主页，我们将有一个主页和一个销售页面。

14989
24:55:07.137 --> 24:55:11.292
现在我们有很多组件，但我们实际上只有两个主页。

14990
24:55:11.292 --> 24:55:20.650
回到Pages，现在我们有apps。js，它服务于我们的app，很酷，所有东西都贯穿其中。

14991
24:55:20.650 --> 24:55:21.633
然后是我们的主页。

14992
24:55:21.633 --> 24:55:27.797
我们现在也来创建，我们的销售页面或者说销售T·j。

14993
24:55:27.896 --> 24:55:35.831
然后在这里，我们把这个最小化，这样我们就可以复制这里的大部分内容，实际上我们可以复制粘贴这整个东西，粘贴到这里。

14994
24:55:35.831 --> 24:55:38.896
我们用卖出页来代替高价。

14995
24:55:38.896 --> 24:55:40.580
我们把它保存起来。

14996
24:55:40.580 --> 24:55:45.605
现在如果我们去我们的本地主机做债务削减出售。

14997
24:55:45.605 --> 24:55:48.314
如果T出现了，我们就得跑了。

14998
24:55:48.314 --> 24:55:49.830
再运行前端。

14999
24:55:49.830 --> 24:55:50.518
与纱线Dev。

15000
24:55:50.518 --> 24:55:52.229
对不起，我们再运行纱线开发。

15001
24:55:52.229 --> 24:55:53.229
现在我们刷新。

15002
24:55:53.229 --> 24:55:55.162
现在我们可以看到销售页面了。

15003
24:55:55.162 --> 24:55:59.149
出售页面，也就是斜杠出售页面，然后首页就会很高。

15004
24:55:59.149 --> 24:55:59.847
好的,很酷。

15005
24:55:59.847 --> 24:56:01.434
我们有了两页。

15006
24:56:01.434 --> 24:56:06.626
我们应该先做哪一个?好了，让我们开始做主页吧。

15007
24:56:06.626 --> 24:56:08.811
所以我们在索引中。

15008
24:56:08.811 --> 24:56:08.912
js。

15009
24:56:08.912 --> 24:56:16.654
我要保持前端的运行，我们要隐藏它哦，这是隐藏它的对立面，把它压下去，我们要像这样隐藏它。

15010
24:56:16.654 --> 24:56:19.025
让我们继续，让我们开始建造这个。

15011
24:56:19.025 --> 24:56:24.053
在index js中，我们有一些头部的东西，我要把这个改成NFT。

15012
24:56:24.053 --> 24:56:25.316
市场。

15013
24:56:25.316 --> 24:56:32.706
描述将只是一个空洞的市场。

15014
24:56:32.897 --> 24:56:34.574
Fabcon看起来很棒。

15015
24:56:36.897 --> 24:56:39.845
上面写着NFT市场，这很好。

15016
24:56:40.897 --> 24:56:41.509
这就是我们想要的。

15017
24:56:42.897 --> 24:56:53.547
我们总要做的第一件事是什么?你猜对了，我们需要一个连接按钮，对吧?我们需要我们的用户能够连接到web 3连接到区块链。

15018
24:56:53.547 --> 24:56:55.388
和我们之前做的一样。

15019
24:56:55.388 --> 24:56:57.473
我们来创建一个组件文件夹。

15020
24:56:57.473 --> 24:57:05.054
我们会创建一个头组件组件Nance文件夹我们会创建一个新文件头摘要。

15021
24:57:05.054 --> 24:57:13.542
记住，因为我们之前做过这个，用我们的前端彩票代码，当我们构建这个时，我们总是可以引用彩票代码。

15022
24:57:13.542 --> 24:57:17.634
当然，我们在GitHub回购上有所有的代码。

15023
24:57:17.634 --> 24:57:28.039
你们可以用它我不会让你们都做的是上节课，我们做了手动头文件的事情，对吧，我们要做所有的本地存储和所有那些疯狂的事情，我们不会做那些。

15024
24:57:28.039 --> 24:57:32.445
这次，我们用简单的方法，我们用web3uikit。

15025
24:57:32.445 --> 24:57:36.230
为了使用这个连接按钮，我们要做纱线，添加。

15026
24:57:36.230 --> 24:57:45.388
我们不打算做dash Dev，因为这个连接按钮是前端的必要组件，yarn通过uikit添加web。

15027
24:57:45.388 --> 24:57:50.117
这也意味着我们要用Morales反应mirallas。

15028
24:57:50.117 --> 24:57:53.727
我说，这可能有点让人困惑。

15029
24:57:53.727 --> 24:57:59.077
我知道我在这里说过我们有莫拉莱斯和其他图表版本。

15030
24:57:59.077 --> 24:58:02.642
所以我们仍然会在这两种情况下使用莫拉莱斯包。

15031
24:58:02.642 --> 24:58:07.015
唯一不同的是，我们将在我们的莫拉莱斯版本中使用一个莫拉莱斯服务器。

15032
24:58:07.015 --> 24:58:18.648
我们不会在图表版本中使用士气服务器，它们都可以使用Morales包因为所有的开源钩子和工具仍然非常强大，即使我们不使用Morales服务器。

15033
24:58:18.648 --> 24:58:22.270
所以我们还是要用莫拉莱斯集合即使我们要用这个图。

15034
24:58:22.270 --> 24:58:22.575
太好了。

15035
24:58:22.575 --> 24:58:28.460
现在我们把它们都加起来了，我们要做的和之前的Jas反应一样。

15036
24:58:28.460 --> 24:58:47.139
为了通过app中的UI组件使用我们的web，点j s，并导入mirallas provider引号抱歉，还有花括号，它来自react mirallas。

15037
24:58:47.139 --> 24:58:52.516
然后我们将把整个组件封装到morass provider中。

15038
24:58:52.516 --> 24:59:00.107
我们要返回，这里有小的左括号，这里有小的右括号。

15039
24:59:00.107 --> 24:59:03.338
我们要进行查房。

15040
24:59:03.338 --> 24:59:15.075
然后我们要做的是，如果她在Mount上盟军将等于false，因为我们还不打算使用服务器，或者提供者。

15041
24:59:15.075 --> 24:59:15.607
好的,很酷。

15042
24:59:15.607 --> 24:59:30.598
现在我们已经在Morales提供程序中包装了我们的应用，回到我们的头部，我们会说Export default function header，我们会从你的eye kit中抓取连接按钮。

15043
24:59:30.598 --> 24:59:36.357
我们会从web3uitkit导入连接按钮。

15044
24:59:36.357 --> 24:59:41.635
然后在这里，我们会说返回。

15045
24:59:41.635 --> 24:59:43.285
下一个按钮。

15046
24:59:43.285 --> 24:59:45.736
现在我们能在应用J中做什么。

15047
24:59:45.736 --> 24:59:58.737
S，我们可以输入导入，输入header from。。/ components header，我们有header，我们把header放在组件的正上方。

15048
24:59:58.737 --> 25:00:02.157
我们会在标题中添加一些东西。

15049
25:00:02.157 --> 25:00:04.320
我们要确保导入的头文件正确。

15050
25:00:04.320 --> 25:00:05.679
回到UI。

15051
25:00:05.679 --> 25:00:07.833
好了，我们有了连接按钮。

15052
25:00:07.833 --> 25:00:10.560
如果我们点击它，就会弹出这个小窗口。

15053
25:00:10.560 --> 25:00:11.678
我放大了。

15054
25:00:11.678 --> 25:00:14.649
我要把它放大。

15055
25:00:14.899 --> 25:00:25.356
现在，我们还想在头文件中放入什么呢?我们可能会给它起个名字让它看起来更好看一些，可能还会给我们的cell NF - T页面一个链接。

15056
25:00:25.356 --> 25:00:27.474
我们来创建一个导航栏。

15057
25:00:27.474 --> 25:00:33.632
除了返回连接按钮，把这个放在括号里我们还会返回一些其他的东西。

15058
25:00:33.632 --> 25:00:37.834
我们可以使用这个nav标签，它通常定义一个导航栏。

15059
25:00:37.899 --> 25:00:41.222
它和div很像，只是另一个标签。

15060
25:00:41.899 --> 25:00:43.999
现在我们把所有东西都放到nav标签里。

15061
25:00:44.899 --> 25:00:50.899
我们可以使用下一个Jas链接标签来链接。

15062
25:00:51.899 --> 25:01:00.011
这个链接允许我们连接到应用中不同的链接或url，像这样。

15063
25:01:00.011 --> 25:01:04.850
我们可以输入import link from next / link。

15064
25:01:04.850 --> 25:01:11.823
在这里，如果我们想让它到主页，我们可以做一个链接。

15065
25:01:11.899 --> 25:01:17.149
我们说h ref =斜杠=斜杠。

15066
25:01:18.899 --> 25:01:23.495
这个，我们把它包装在一个a标签中，使它可点击。

15067
25:01:23.899 --> 25:01:28.039
那么我们就可以说非功能性市场。

15068
25:01:28.899 --> 25:01:37.794
保存下来，我们到我们的前端，我们现在看到有一个非ft市场按钮，我们可以点击，因为我们已经在家里，我们不打算去任何地方。

15069
25:01:37.794 --> 25:01:43.566
但如果我们复制这个链接，粘贴到下面，我们为cell和f t创建另一个链接。

15070
25:01:43.566 --> 25:01:46.232
我们把这个细胞命名为NF t。

15071
25:01:46.232 --> 25:02:00.900
现在我们保存，回到我们的前端，我们现在有非ft市场，出售非ft如果我点击出售NFT我们现在就会进入出售页面我们会回到主页出售页面，来回翻转。

15072
25:02:00.900 --> 25:02:02.752
太棒了，非常令人兴奋。

15073
25:02:02.752 --> 25:02:07.807
现在我们有了一个极简的标题显然看起来很糟糕。

15074
25:02:07.807 --> 25:02:10.426
我们来做一点格式化。

15075
25:02:10.426 --> 25:02:12.794
通常你会在最后进行格式化。

15076
25:02:12.900 --> 25:02:20.838
但是既然我们在这里，我们也可以做我们的格式我们要用如果你猜的是顺风呢?你猜对了。

15077
25:02:20.900 --> 25:02:23.141
所以记住，顺风。

15078
25:02:23.141 --> 25:02:23.572
下一个。

15079
25:02:25.900 --> 25:02:26.779
跟着这里走。

15080
25:02:28.900 --> 25:02:34.114
我们之前做过的事情，我们会做纱线，添加dash Dev，就是这里的东西。

15081
25:02:34.114 --> 25:02:37.952
然后我们将运行针织后，这些完成安装。

15082
25:02:37.952 --> 25:02:42.267
我们先做纱线，然后粘贴进去。

15083
25:02:42.267 --> 25:02:43.633
好了。

15084
25:02:43.633 --> 25:02:48.166
现在我们有了post CSS配置，我们有了tailwind配置。

15085
25:02:48.166 --> 25:02:50.099
我们要抓住顺风。

15086
25:02:50.099 --> 25:02:50.499
配置。

15087
25:02:50.499 --> 25:02:50.632
js。

15088
25:02:50.900 --> 25:02:51.915
粘贴到这里。

15089
25:02:54.900 --> 25:02:58.833
打开Global的。css，粘贴进去，冷却。

15090
25:02:58.900 --> 25:03:00.323
现在我们有顺风了。

15091
25:03:01.900 --> 25:03:05.003
可以在我们的头部做一些顺风动作。

15092
25:03:05.900 --> 25:03:24.933
为这里的所有东西创建一个div，我们会为这里的所有东西创建一个小div，我们会为一个大的部分，几乎像一个大的标志，说，嘿，你在NFC市场，h1，代表header 1，我们会给它一个类名padding y of form。

15093
25:03:24.933 --> 25:03:34.805
填充x = 4，字体加粗文本是3xl，然后它会说，非ft市场。

15094
25:03:34.805 --> 25:03:37.454
现在我们有了非ft市场，这是一个很好的螺栓。

15095
25:03:37.454 --> 25:03:37.946
太棒了。

15096
25:03:37.946 --> 25:03:44.377
如果你在服务器上，你会用Ctrl C杀死它，然后我们会重启它。

15097
25:03:44.377 --> 25:03:46.805
这就会把所有的顺风都拉进来。

15098
25:03:46.901 --> 25:03:58.722
现在如果我们刷新local main，我们现在应该会看到，如果T和F c r得到了位置，我们现在可以看到这个又大又粗的，看起来好多了。

15099
25:03:58.722 --> 25:03:59.793
我们继续。

15100
25:03:59.901 --> 25:04:02.409
让我们给整个导航起一个类名。

15101
25:04:03.901 --> 25:04:16.064
填充五，边框底部要伸缩行对齐，如果n项之间居中。

15102
25:04:16.064 --> 25:04:18.523
我们来看看结果如何。

15103
25:04:18.523 --> 25:04:20.511
哈哈，看起来好多了。

15104
25:04:20.511 --> 25:04:27.460
我们现在设置的是底部边框之类的东西像这样，看起来已经好很多了。

15105
25:04:27.460 --> 25:04:28.748
我们往下看。

15106
25:04:28.748 --> 25:04:36.336
让我们的按钮有一个类名= lax lax row items center。

15107
25:04:36.336 --> 25:04:39.863
就像我说的，这不是一门造型课。

15108
25:04:39.863 --> 25:04:43.432
我们不打算详细讲如何对它进行样式化。

15109
25:04:43.432 --> 25:04:44.251
这没什么。

15110
25:04:44.251 --> 25:04:47.918
但是这会把它移过去让它看起来更好看一些。

15111
25:04:47.918 --> 25:04:52.074
我们将在这里给出链接，类名等于Mr。

15112
25:04:52.074 --> 25:04:52.936
对于p6。

15113
25:04:52.936 --> 25:05:03.764
我们会给这两个相同的类名这两个链接，给它们一些填充，让它们彼此远离一些右边距，让它们彼此远离。

15114
25:05:03.764 --> 25:05:08.252
哦，我忘了做这个，Morales off = false。

15115
25:05:08.252 --> 25:05:17.687
我们需要Morales auth = false，这样我们就不会自动连接到Morales数据库或尝试连接到Morales数据库，当我们连接时，我们只想连接到Metamask。

15116
25:05:17.687 --> 25:05:20.768
我们将把它换成家庭而不是市场。

15117
25:05:20.768 --> 25:05:24.368
但除此之外，T Connect按钮在国内的销量看起来相当不错。

15118
25:05:24.368 --> 25:05:28.552
我们可以调整这个的格式让它看起来有点不同。

15119
25:05:28.552 --> 25:05:34.964
但我认为在大多数情况下，这个看起来好多了，对吧?好了，很酷，标题看起来好多了。

15120
25:05:34.964 --> 25:05:36.581
这是我们的应用程序。

15121
25:05:36.581 --> 25:05:39.683
Js设置与鼠标提供程序头组件。

15122
25:05:39.683 --> 25:05:42.104
现在让我们看看我们的索引。

15123
25:05:42.104 --> 25:05:47.838
现在让我们继续展示这些NF T展示我们市场上的所有NF T。

15124
25:05:47.902 --> 25:05:52.473
这就是它开始升温的地方变得非常有趣。

15125
25:05:52.473 --> 25:05:56.886
事实上，还有一件事，如果你还没有，我们将在索引中找到这个头饰。

15126
25:05:56.886 --> 25:06:00.783
我们会让它在应用JSX中。

15127
25:06:00.783 --> 25:06:02.562
我们的应用程序。

15128
25:06:02.562 --> 25:06:08.281
js中，我们会把那个头文件放在顶部，然后放一个小div。

15129
25:06:08.281 --> 25:06:12.789
Div，像这样围绕着整个东西。

15130
25:06:12.789 --> 25:06:13.998
这个放在这里。

15131
25:06:13.998 --> 25:06:19.521
这样一来，无论我们在哪个页面，我们总是会把这个作为标题。

15132
25:06:19.521 --> 25:06:21.870
我们不需要定义这里的每一个东西。

15133
25:06:21.902 --> 25:06:23.256
我们会进行刷新。

15134
25:06:23.256 --> 25:06:25.320
它说头没有定义。

15135
25:06:25.902 --> 25:06:29.919
这是因为我们需要从下一个斜杠头复制导入头。

15136
25:06:29.919 --> 25:06:33.666
将它粘贴到我们的应用，Jas从下一个头部导入头部。

15137
25:06:33.666 --> 25:06:38.837
现在我们可以看到，不管我们在哪个页面，我们都会清空市场，因为我们在应用程序层面定义了它。

15138
25:06:38.837 --> 25:06:44.225
这里有header，这里有这个，index几乎什么都没有。

15139
25:06:44.225 --> 25:06:45.169
让我们开始吧。

15140
25:06:45.169 --> 25:06:51.066
我们要怎么做呢?我们希望主页即我们的索引显示最近列出的非ft。

15141
25:06:51.066 --> 25:06:55.699
所以问题是，我们如何显示最近列出的NF t。

15142
25:06:55.699 --> 25:07:00.804
我们怎么做呢?好吧，让我们回到我们的合同上来。

15143
25:07:00.804 --> 25:07:11.379
我们回到我们的硬帽非金融市场，所以我们在看市场，我们在这里有什么?我们如何实际看到非功能性物质存储在哪里?它们存储在这个列表映射中。

15144
25:07:11.379 --> 25:07:30.103
但是，我们如何看到这里所有的列表呢?这是一个映射，这意味着我们有地球上的每一个地址在这里，我们不能遍历映射，我们必须遍历地球上的每一个地址，这是一个疯狂的大数字你和我永远无法知道有多少地址。

15145
25:07:30.103 --> 25:07:36.785
那么我们有什么办法来解决这个问题呢?因为我们显然不会遍历所有东西。

15146
25:07:36.785 --> 25:07:48.639
那么我们该怎么办呢?第一个方法是什么，第一个方法之一是，Patrick，我们为什么不创建一个数组，一个清单的数组呢，这可能是一个好方法。

15147
25:07:48.639 --> 25:07:59.745
但如果之后，我们还想得到一些其他奇怪的数据，也许我们想得到用户拥有的所有NF t用户拥有的NF t，用户拥有的NF t没有数组。

15148
25:07:59.745 --> 25:08:02.236
这只是一个映射。

15149
25:08:02.236 --> 25:08:15.904
但如果我们想查询其他一些奇怪的数据，或者查询其他一些奇怪的数据，或者一个数组会非常消耗气体，如果我们让这个数组进行循环，它会非常消耗气体。

15150
25:08:15.904 --> 25:08:18.182
所以我们不想回去改变。

15151
25:08:18.182 --> 25:08:20.356
我要把这个打出来。

15152
25:08:20.356 --> 25:08:21.827
因为这很重要。

15153
25:08:21.827 --> 25:08:33.808
我们不想仅仅为网站改变协议，我们不想仅仅为网站改变协议，或者我们不想为网站改变太多协议。

15154
25:08:33.808 --> 25:08:38.454
因为如果我们把它做成一个数组，它会变得非常低效。

15155
25:08:38.454 --> 25:08:43.516
使用非金融市场将变得更加困难，因为它将变得更加昂贵。

15156
25:08:43.516 --> 25:08:51.822
当您构建越来越复杂的协议时，您将意识到为每个映射使用一个数组是不可行的。

15157
25:08:51.822 --> 25:08:56.281
这就是这些事件发挥作用的原因之一。

15158
25:08:56.281 --> 25:09:02.463
所以每次我们列出一个NF t，我们调用这个列表项函数。

15159
25:09:02.463 --> 25:09:11.836
我们省略了列项事件，列项事件存储在链上的数据结构中，但只有智能合约可以访问它。

15160
25:09:11.836 --> 25:09:17.395
然而，猜猜什么不能访问它链外服务可以访问这些事件。

15161
25:09:17.395 --> 25:09:28.348
在这种情况下，我们要做的是，我们要做的是索引链外的事件然后从数据库中读取。

15162
25:09:28.348 --> 25:09:35.887
我们要做的是设置一个服务器来监听那些被触发的事件。

15163
25:09:35.887 --> 25:09:39.493
我们将把它们添加到数据库中进行查询。

15164
25:09:39.493 --> 25:09:47.838
是的，我们会把每一项都列出来，我们会在数据库中为自己建立索引。

15165
25:09:47.904 --> 25:09:53.589
然后我们会调用我们的中央数据库来启动我们会调用那个数据库来完成这个。

15166
25:09:53.589 --> 25:10:04.840
现在的问题是，哇，这不是中心化吗?帕特里克，我们说的不是中央集权吗?管他呢，答案是，不一定。

15167
25:10:04.905 --> 25:10:08.343
这个图就是这样一个协议。

15168
25:10:08.905 --> 25:10:15.146
该协议索引链外事件，并将它们插入到图协议中。

15169
25:10:15.146 --> 25:10:35.476
它以一种分散的方式来实现，莫拉莱斯，我们首先要展示的是一种集中的方式，莫拉莱斯将以一种集中的方式来实现它，这可能是你想要加快速度的路线额外的铃铛和口哨，这样你就可以进行本地开发，这就是我们这里要关注的，或者莫拉莱斯提供的其他功能。

15170
25:10:35.476 --> 25:10:37.837
因为莫拉莱斯做的远不止这些。

15171
25:10:37.837 --> 25:10:47.869
这也是要记住的，即使我们添加了一个集中的组件，或者逻辑，我们的智能合约，这个应用程序的真正主体是去中心化的。

15172
25:10:47.869 --> 25:11:01.857
你可以通过这个去中心化的智能合约来验证你所有的交互，我们实际上已经使用了很多中心化的协议，比如以太扫描，比如开放查看，其中一些中心化的协议对这个领域非常重要。

15173
25:11:01.905 --> 25:11:10.842
因此，我们向您展示Morales是为了让您熟悉如何使用这些集中式服务器之一，以防您想要创建一个提供集中式服务的应用程序。

15174
25:11:10.905 --> 25:11:19.114
在这个领域有大量的工具，比如打开和温柔防守等等，这些都是集中的，但给我们带来了巨大的好处。

15175
25:11:19.114 --> 25:11:22.262
作为一个社区，我们正在把越来越多的东西去中心化。

15176
25:11:22.262 --> 25:11:24.773
有时我们需要一些辅助工具才能到达那里。

15177
25:11:24.773 --> 25:11:31.387
然后是去中心化的方式，这是一个较长的过程，但当我们讲到那里，我们会解释所有的。

15178
25:11:31.387 --> 25:11:36.397
让我们学习一下如何在图中列出最近被列出的NF T和Morales。

15179
25:11:36.397 --> 25:11:41.551
两者都有一些非常不错的视频，我将在GitHub上留下一些相关的链接。

15180
25:11:41.551 --> 25:11:49.206
所以如果你想了解更多，你一定要看这两个视频，因为它们绝对很棒，会帮助你更好地理解这个事件。

15181
25:11:49.206 --> 25:11:58.772
通常，当我们从区块链读取时，我们会做一些类似于契约。get, get列表的操作，然后我们把输入参数放进去。

15182
25:11:58.772 --> 25:12:05.856
契约双blah，取而代之的是，我们将从一个包含所有映射和更容易读取的数据结构的数据库中读取。

15183
25:12:05.906 --> 25:12:11.734
莫拉莱斯和图表都是这样做的。

15184
25:12:11.906 --> 25:12:13.872
我们一直在使用沼泽、开源包和工具。

15185
25:12:13.906 --> 25:12:20.855
然而，莫拉莱斯还可选择与服务器后端，给您的web三个应用程序更多的功能。

15186
25:12:20.906 --> 25:12:26.560
然而，有很多我们不会讲到的东西莫拉莱斯可以帮助你构建web三应用。

15187
25:12:26.560 --> 25:12:37.112
所以我不再继续谈论莫拉莱斯，以及它能做什么，我们请伊万来简要概述一下莫拉莱斯能做的其他一些事情，我叫伊万，我来自拉利斯。

15188
25:12:37.112 --> 25:12:51.561
我在这里告诉你如何将你的开发速度提高10倍，我没有过分夸张，当你在创建一个东西时，你想要确保它是可扩展的，因为你的DAP可能会走向全球，可能会像病毒一样传播，可能会成为主流，这是可能发生的。

15189
25:12:51.561 --> 25:13:00.388
如果这种情况发生了，你不想从头开始，你想使用工具和服务，让你走得更快，也做得更大。

15190
25:13:00.388 --> 25:13:02.638
这正是米拉拉所提供的。

15191
25:13:02.638 --> 25:13:03.487
在mirallas。

15192
25:13:03.487 --> 25:13:14.117
我们创建工具，我们为开发人员创建基础设施，以一种单一工作流的方式，他们很快就会解释它的含义，因为这可以节省您的时间。

15193
25:13:14.117 --> 25:13:16.590
如果你有一个单一的工作流程。

15194
25:13:16.590 --> 25:13:30.841
web 3中的工作流意味着你必须有一个智能合约，无论是代币，游戏，某种赌注，某种市场，某种违抗，它都是在链上的，但同时，你必须将它连接到你的后端。

15195
25:13:30.841 --> 25:13:34.068
因为当链上发生一些事情时，你需要监控它。

15196
25:13:34.068 --> 25:13:48.446
你可以创建web hook，你可以创建电子邮件，你可以创建一个推送通知，你可以运行一些自定义代码，你可以运行一些计算，你可以保存一些东西到数据库，所有链上的东西在一天结束时都需要进入我们的后端。

15197
25:13:48.446 --> 25:13:51.626
当有东西在你的后端，它需要到前端。

15198
25:13:51.626 --> 25:13:56.757
例如，当链上发生一些事情时你改变UI或者你改变UI。

15199
25:13:56.757 --> 25:14:00.611
如果用户接收到的转账超过了一个特定的阈值。

15200
25:14:00.611 --> 25:14:08.165
或者如果你的用户拥有这种NFC，你可以允许他们访问某种类型的聊天或某种类型的独家内容。

15201
25:14:08.165 --> 25:14:19.152
所以在Morales，我们为你提供了一整套的工具套件，被超过10万的开发者使用，它真的成为了web 3中最被采用的技术栈之一。

15202
25:14:19.152 --> 25:14:29.347
这一切都始于Morales身份，它确保你得到一段代码，你写一段代码，你可以登录你的用户在不同的区块链，不同的钱包。

15203
25:14:29.347 --> 25:14:34.245
在你的士气仪表盘里，你会得到用户资料，你会得到一个网页会话。

15204
25:14:34.245 --> 25:14:41.480
因此mirallas允许您管理身份，因为一个用户配置文件可以有许多不同的钱包，来自许多连接到它的不同链。

15205
25:14:41.480 --> 25:14:48.326
所有的事务都会从那个用户同步，所有的实时事务都会和那个用户同步。

15206
25:14:48.326 --> 25:15:02.376
而且，你已经在你的前端建立了网络会话，无论是游戏还是网站，我们确保你有安全的经过认证的网络会话，我们为你提供会话管理。

15207
25:15:02.376 --> 25:15:12.783
如果你有自己的自行车，然后你有mirallas会话身份管理，你可以使会话无效，你可以登录用户，所有这些很好，所有这些很好的事情都只用一行代码。

15208
25:15:12.783 --> 25:15:13.814
这非常重要。

15209
25:15:13.908 --> 25:15:17.845
第二个是莫拉莱斯实时我已经提到了一点。

15210
25:15:17.908 --> 25:15:20.908
但基本上当你有一个用户时，你就能实时知道发生了什么。

15211
25:15:20.908 --> 25:15:33.844
你可以在用户进行交易时运行自定义代码，也可以在用户与智能合约进行交互时运行自定义代码或进行web hook、电子邮件或推送通知，也可以在智能合约发出事件时运行自定义代码。

15212
25:15:33.908 --> 25:15:42.627
这可以是NFC市场中的交易，这可以是ERC 20传输，你可以通过设置过滤器非常灵活。

15213
25:15:42.627 --> 25:15:49.369
所以你可以说，当用户传输超过10个nfc时，只给我提醒只给我web hook。

15214
25:15:49.369 --> 25:15:53.701
或者当这个代币转账超过1000美元时，等等。

15215
25:15:53.701 --> 25:15:57.858
这是士气，是实时的，非常非常强大的东西。

15216
25:15:57.858 --> 25:15:59.743
接下来是mirallas sdk。

15217
25:15:59.908 --> 25:16:16.527
所以，无论你是在建立一个网站，还是在开发一款与游戏引擎完全整合的游戏，还是在为其他平台开发游戏，我们都有大量易于使用的sdk，让你可以做所有这些事情，让你可以连接到Morales，非常非常容易地完成这些事情。

15218
25:16:16.527 --> 25:16:22.447
如果你去看我们的文档，我强烈建议你去看，你去看Morales, Doc's。Morales。

15219
25:16:22.447 --> 25:16:27.609
如果你去Doc's dot, Marisa Yo，你首先会深入了解mirallas是什么。

15220
25:16:27.609 --> 25:16:34.892
所以你可以把它想象成Firebase，但对于加密来说，它基本上是一个托管后端，你可以连接你的前端。

15221
25:16:34.892 --> 25:16:39.102
此外，你也可以不使用GS SDK将其连接到自己的后端，这非常非常简单。

15222
25:16:39.102 --> 25:16:41.666
但我想在这里展示的是跨平台。

15223
25:16:41.666 --> 25:16:52.477
对于每一件事，假设你想为你的用户获取nfts，我们会展示如何用简单的JavaScript，香草JavaScript来做，如何做和反应，如何用web请求来做。

15224
25:16:52.477 --> 25:16:55.253
假设您只想使用一个原始web请求。

15225
25:16:55.253 --> 25:17:02.775
假设你使用的是某种语言，我们没有SDK你仍然可以使用Morales，只是你需要调用原始HTTP请求。

15226
25:17:02.775 --> 25:17:07.400
我们还会展示如何在Unity中使用C调在Unity游戏引擎中实现它。

15227
25:17:07.400 --> 25:17:10.330
所以我们非常非常清楚跨平台。

15228
25:17:10.330 --> 25:17:12.126
我们是交叉链的。

15229
25:17:12.126 --> 25:17:29.271
这意味着，例如，当你登录用户时，你可以创建用户配置文件其中有lambda地址，假设你的用户使用Solana他们可以很容易地连接Aetherium，他们可以很容易地连接Binus链，最后，我们很快会添加更多链，他们可以很容易地连接L Ron到一个用户配置文件。

15230
25:17:29.271 --> 25:17:35.597
然后你有各种不同的钱包，不同的链，你有一个单一的用户配置文件一个单一的用户ID。

15231
25:17:35.597 --> 25:17:38.940
顺便说一下，这就是它在数据库中的样子。

15232
25:17:38.940 --> 25:17:45.859
如你所见，这里会有一个用户用户表，你会有他们所有的账户。

15233
25:17:45.909 --> 25:17:47.531
在这种情况下，我只有eth。

15234
25:17:48.909 --> 25:17:52.591
有了其他类型的区块链，它就都在这里了。

15235
25:17:52.909 --> 25:17:56.210
这个数据库也包含了我所有的事务。

15236
25:17:56.909 --> 25:18:01.489
数据库，我可以设置不同的监听事件或智能合约。

15237
25:18:01.489 --> 25:18:05.840
例如，我可以看open see智能合约或其他东西。

15238
25:18:05.840 --> 25:18:08.417
这是非常非常多变的，因为这是MongoDB。

15239
25:18:08.417 --> 25:18:12.813
这是MongoDB，你可以运行MongoDB查询，它非常非常可变。

15240
25:18:12.813 --> 25:18:20.624
从这个意义上说，mirallas提供了一个非常非常好的仪表板，其中包含了您需要了解的关于用户的所有信息，他们的会话、权限等等。

15241
25:18:20.624 --> 25:18:25.299
当然，你也可以使用Node js SDK连接到自己的后端。

15242
25:18:25.299 --> 25:18:26.926
这是莫拉莱斯sdk。

15243
25:18:26.926 --> 25:18:39.410
最后，当我们说到工作流时，最后一件事是API的，我也已经展示过了，但API是你可以从任何编程语言，任何类型的体系结构做RAW请求。

15244
25:18:39.410 --> 25:18:43.648
所以使用这个工作流程，你可以很容易地实现任何你想要的非常非常快。

15245
25:18:43.648 --> 25:18:47.345
你一定要试试莫拉莱斯它会改变你的生活。

15246
25:18:47.345 --> 25:18:49.812
我想怎么解释都可以，我时间有限。

15247
25:18:49.910 --> 25:19:01.435
但正如你们已经看到的，通过这个演示，你们非常好奇，正如你们已经看到的，通过这个演示，你们想要尝试一下正如你们已经看到我在这里的感觉一样，你们非常非常兴奋。

15248
25:19:01.435 --> 25:19:04.146
我们得亲自动手。

15249
25:19:04.146 --> 25:19:13.073
所以，第一个，两个狗，授权销售，然后到这里开始连接器SDK在香草或反应，并通过所有这些。

15250
25:19:13.073 --> 25:19:14.175
自己去看看魔法吧。

15251
25:19:14.175 --> 25:19:20.877
如果你想要实践，去youtube频道和道德频道哦，斜杠项目，伙计们，你们都在社区里。

15252
25:19:20.877 --> 25:19:25.592
利用莫拉莱斯，你就会成功利用拉力赛，你就会达到你的目标。

15253
25:19:25.592 --> 25:19:28.496
你会比你想象的要快。

15254
25:19:28.496 --> 25:19:30.469
你会让自己大吃一惊的。

15255
25:19:30.469 --> 25:19:32.367
但是不要让自己失望。

15256
25:19:32.367 --> 25:19:33.347
去找莫拉莱斯。

15257
25:19:33.347 --> 25:19:35.910
我报名，开始吧，伙计们。

15258
25:19:35.910 --> 25:19:46.176
现在我已经解释了所有这些，这是什么样子的?这就是我们真正开始使用mirallas及其服务器功能的地方。

15259
25:19:46.176 --> 25:19:48.082
我们要在这里注册一个服务器。

15260
25:19:48.082 --> 25:19:51.730
我们将使用Morales作为应用程序的后端。

15261
25:19:51.730 --> 25:19:54.577
为了和莫拉莱斯见面，我们去找莫拉莱斯。

15262
25:19:54.577 --> 25:19:54.688
io。

15263
25:19:54.688 --> 25:19:56.995
我们可以免费报名。

15264
25:19:56.995 --> 25:20:00.462
我们输入电子邮件，设置密码。

15265
25:20:00.462 --> 25:20:06.339
你为什么在这里?另外，请指定帕特里克令人惊叹的硬帽视频，你不必写那个。

15266
25:20:06.339 --> 25:20:08.149
但如果你想写，你可以写。

15267
25:20:08.149 --> 25:20:17.376
你第一次听说莫拉莱斯是什么情况?好吧，你们都在YouTube上听说过，因为你们是从我这里听说的，然后选择你们的名单，我要成为一个开发人员，我们将点击下一个，我不想订阅。

15268
25:20:17.376 --> 25:20:20.249
但我不会像机器人一样为你创建账户。

15269
25:20:20.249 --> 25:20:23.661
它甚至会给我们一些属性，或者创建你的第一个服务器。

15270
25:20:23.661 --> 25:20:28.063
我们的后端将使用一个服务器来完成后面的所有工作。

15271
25:20:28.063 --> 25:20:29.757
因此，我们将创建一个服务器。

15272
25:20:29.757 --> 25:20:33.152
如果我们要做一个主网或遗嘱，我们会从中选择一个。

15273
25:20:33.152 --> 25:20:35.813
但现在我们要做的是本地开发链服务器。

15274
25:20:35.911 --> 25:20:41.536
这也是《Morales》的一大优势，即它让我们能够与本地开发者合作。

15275
25:20:41.536 --> 25:20:53.720
对于事件索引，我们可以从本地硬帽节点索引我们的事件，这非常非常强大，检查你的邮件，我们会有一个激活我的账户的东西，电子邮件，我们会点击激活你的账户。

15276
25:20:53.720 --> 25:20:56.873
它会把我们带回这里，我们会重新创造，我们会做本地开发链。

15277
25:20:56.911 --> 25:21:00.428
好了，现在我们要创建一个新的本地开发链服务器。

15278
25:21:00.428 --> 25:21:07.758
我们将称之为非功能性市场，我们将选择一个地区，你想要哪个地区都行，我在美国东部。

15279
25:21:07.758 --> 25:21:08.842
所以我选择纽约。

15280
25:21:08.911 --> 25:21:13.729
但无论你在哪里工作，我们都会做本地开发链，我们会做每个本地开发链。

15281
25:21:13.729 --> 25:21:23.394
再一次，如果你是为polygon，为avalanche，为Phantom，为任何一个与EVM兼容的链，再一次，你的每个本地开发链，它的工作原理都是一样的。

15282
25:21:23.394 --> 25:21:25.007
我们现在要添加实例。

15283
25:21:25.007 --> 25:21:27.911
我们要在这里创建一个新应用程序。

15284
25:21:27.911 --> 25:21:32.670
现在我们要关闭服务器了，上面写着ganache，但它真的很硬。

15285
25:21:32.670 --> 25:21:33.428
别担心那个。

15286
25:21:33.428 --> 25:21:40.745
现在我们已经启动了服务器，我们可以去Morales文档，我们要找的是事件，我们要和事件同步。

15287
25:21:40.745 --> 25:21:44.472
我们甚至可以在这里搜索事件。

15288
25:21:44.472 --> 25:21:52.123
我们看到智能合约事件平台自动同步，甚至告诉我们为什么我们需要同步和观察智能合约事件。

15289
25:21:52.123 --> 25:21:56.864
基本上，这个服务器我们的数据库将寻找这些要触发的事件。

15290
25:21:56.912 --> 25:22:10.234
但在这之前，我们需要将应用连接到服务器如果你去顶部的React Morales GitHub，你可能见过这个，当你有这个Morales provider在他们的码头，他们会传递一个应用ID和一个服务器URL。

15291
25:22:10.234 --> 25:22:15.271
这就是我们直接连接mirallas服务器的方法。

15292
25:22:15.271 --> 25:22:23.153
我们要做的是，现在我们要回到我们的应用Jas最初我们说过，initialize on Mount = false。

15293
25:22:23.153 --> 25:22:30.365
当我们这么说的时候，我们是在说，嘿，我们不会使用士气服务器，我们只会使用你们提供的开源泥沼工具。

15294
25:22:30.365 --> 25:22:35.404
现在，我们确实想使用他们的服务器，对吧，我们确实想使用莫拉莱斯提供的所有这些花哨的东西。

15295
25:22:35.404 --> 25:22:36.662
所以我们要改变这一点。

15296
25:22:36.662 --> 25:22:41.420
这里不说initialize on Mount = false，这里只准备了应用ID和服务器URL。

15297
25:22:41.420 --> 25:22:42.945
我们要把这个删掉。

15298
25:22:42.945 --> 25:22:47.673
就像文档中说的，我们会给它一个app ID和一个服务器URL。

15299
25:22:47.673 --> 25:22:51.740
我们写入app ID =，这是我们将app ID作为字符串的地方。

15300
25:22:51.740 --> 25:22:55.827
回到莫拉莱斯数据库，我们可以查看细节。

15301
25:22:55.827 --> 25:22:58.412
我们可以在这里看到所有这些信息。

15302
25:22:58.412 --> 25:23:02.782
我们可以抓取应用ID，复制粘贴到这里。

15303
25:23:02.782 --> 25:23:07.296
然后我们会获取服务器URL，在顶部。

15304
25:23:07.296 --> 25:23:11.525
这是我们唯一定制士气服务器的URL。

15305
25:23:11.525 --> 25:23:15.879
我们写入server URL =然后像这样粘贴进去。

15306
25:23:15.879 --> 25:23:24.257
现在，如果你一直在跟随这些教程，你可能会想，哦，我们我们只是把那些东西硬编码在那里，就像这样，那看起来好像那看起来有点糟糕。

15307
25:23:24.257 --> 25:23:26.946
如果这是你的直觉，那太棒了。

15308
25:23:26.946 --> 25:23:29.600
相反，我们要把这些放到环境变量中。

15309
25:23:29.600 --> 25:23:33.355
我们要创建一个新文件。env文件。

15310
25:23:33.355 --> 25:23:36.558
这就是我们要放所有环境变量的地方。

15311
25:23:36.558 --> 25:23:46.984
接下来，Jas内置了对环境变量的支持，它允许您执行以下操作:使用。env和。local将环境变量或那些环境变量通过前缀加载到浏览器。

15312
25:23:46.984 --> 25:23:48.644
它的下一个下划线为public。

15313
25:23:48.644 --> 25:23:51.257
我们可以使用几种不同的环境变量路径。

15314
25:23:51.257 --> 25:23:57.343
我们可以做。env，。local，我们可以做。env，。这个。那个另一件事，我们要做。env，保持简单。

15315
25:23:57.343 --> 25:24:13.850
但是为了我们的前端，从我们的。env文件中读取环境变量，我们必须执行下一个下划线public下划线，下一个Jas将在我们的。env文件中查找以this开头的变量，并只将这些环境变量插入到我们的应用程序中。

15316
25:24:13.913 --> 25:24:23.403
如果我们只写，Morales服务器等于，等等，等等，它不知道这是什么，因为我们接下来要做的是，下划线，公共下划线。

15317
25:24:23.403 --> 25:24:28.538
如果我们这样做，我们会写一个console。log，看这里，process。env。

15318
25:24:28.538 --> 25:24:32.404
下一个公共士气服务器，我们实际上需要杀死它，重新启动它。

15319
25:24:32.404 --> 25:24:40.646
然后我们返回，在这里做一点刷新，它会说，Look here as a do等等等等，因为这是下一个公共的。env文件中的内容。

15320
25:24:40.646 --> 25:24:44.246
抓取我们的app ID，复制它。

15321
25:24:44.246 --> 25:24:51.828
然后我们的。env会写next public app ID =然后粘贴到这里。

15322
25:24:51.828 --> 25:24:55.914
获取服务器URL，回到这里。

15323
25:24:55.914 --> 25:25:01.602
我们写next public server URL =，像这样粘贴。

15324
25:25:01.602 --> 25:25:05.625
现在在顶部，我们用const。

15325
25:25:05.625 --> 25:25:12.914
App ID等于process。E和V。接下来是公共App ID。

15326
25:25:12.914 --> 25:25:15.545
然后我们说const。

15327
25:25:15.545 --> 25:25:22.802
服务器URL等于进程点E和V点下一个公共服务器URL。

15328
25:25:22.802 --> 25:25:28.826
现在我们有了这些变量，我们像这样把它们代进去。

15329
25:25:28.914 --> 25:25:33.229
这就是我们将应用程序连接到士气服务器的方法。

15330
25:25:33.229 --> 25:25:35.597
当然，我们还什么都没做。

15331
25:25:35.597 --> 25:25:38.543
但我们才刚刚开始，对吧?这就是我们连接它的方式。

15332
25:25:38.543 --> 25:25:43.520
现在我们已经登录了，我告诉过你我们的士气服务器将为我们的活动建立索引。

15333
25:25:43.520 --> 25:25:46.864
如果你点击Dashboard按钮，这是我们的整个数据库。

15334
25:25:46.914 --> 25:25:50.010
浏览器选项卡中的所有内容都是数据库中的内容。

15335
25:25:50.010 --> 25:25:56.117
就像你看到的，现在，没有很多东西，如果我们有任何事件数据在这里，它会在这里。

15336
25:25:56.117 --> 25:25:59.897
我们需要告诉服务器，你需要开始监听事件。

15337
25:25:59.897 --> 25:26:02.314
所以我们可以展示最近被列出的实体。

15338
25:26:02.314 --> 25:26:09.075
所以士气服务器，你需要开始监听，你需要为每一个列出的事件创建一个数据库条目。

15339
25:26:09.075 --> 25:26:16.986
无论何时有人买了一件商品，无论何时有人买了一件商品，或者取消了一件商品，你都需要从数据库中删除它。

15340
25:26:16.986 --> 25:26:24.553
我们怎么开始让莫拉莱斯开始监听我们的活动?首先，首先，我们要把它连接回我们的区块链。

15341
25:26:24.553 --> 25:26:31.098
然后我们会说，哪个契约哪些事件以及当它听到这些事件时该怎么做。

15342
25:26:31.098 --> 25:26:34.570
所以我们需要连接它然后我们需要告诉它当它听到这些事件时要做什么。

15343
25:26:34.570 --> 25:26:39.690
那么，我们如何将mirallas服务器连接到我们的硬帽子区块链?现在，我们还没有这样的计划。

15344
25:26:39.690 --> 25:26:44.415
我们先打开硬帽子，本地主机区块链。

15345
25:26:44.415 --> 25:26:50.355
在一个终端上，我们运行前端另一个终端会看到下载目录。

15346
25:26:50.355 --> 25:26:58.022
我们将进入我们的硬帽非ft市场点自由代码营或自由代码营，我们将做纱线硬帽节点。

15347
25:26:58.022 --> 25:27:02.259
如果我们做的一切都是正确的，它将部署我们的非金融市场。

15348
25:27:02.259 --> 25:27:07.656
它会部署我们的Basic NFT然后它会启动本地HTTP web套接字等等。

15349
25:27:07.656 --> 25:27:08.264
这很好。

15350
25:27:08.264 --> 25:27:15.315
现在节点已经运行了，我们能做的是查看细节，然后到dev链代理服务器。

15351
25:27:15.315 --> 25:27:23.125
这个开发链代理服务器就是我们告诉Morales监听本地运行的硬帽节点的方式。

15352
25:27:23.125 --> 25:27:29.222
现在，要做到这一点，你需要做的是我们需要下载这个所谓的反向代理。

15353
25:27:29.222 --> 25:27:37.107
我在GitHub上也有一个链接，根据你运行的电脑会告诉你我们需要下载哪一个。

15354
25:27:37.107 --> 25:27:49.406
如果你迷路了，如果你真的很困惑，这里有一些排除故障的技巧，我们可以做什么，莫拉莱斯FRP可以下载，快速搜索一下。

15355
25:27:49.406 --> 25:27:59.515
我们甚至直接进入文档，将ganache连接到Morales note，供Mac用户下载FRP dot Darwin dot等等等等，用于nosh代理服务器。

15356
25:27:59.515 --> 25:28:00.315
我用的是Mac电脑。

15357
25:28:00.315 --> 25:28:02.767
我要下载这个Darwin AMD 64。

15358
25:28:02.767 --> 25:28:07.415
看看发布版本，这是第一个在顶部的，Darwin AMD 64。

15359
25:28:07.415 --> 25:28:10.850
这就是我要下载的。

15360
25:28:10.915 --> 25:28:13.115
我要点击它，下载它。

15361
25:28:13.916 --> 25:28:18.752
下载后，我们会打开它，我们会得到一个文件夹我们会得到一个像这样的文件夹。

15362
25:28:18.752 --> 25:28:24.109
我们需要的主要材料是FRP和FRP·ini。

15363
25:28:24.109 --> 25:28:35.169
F RPC将是可执行文件它将是我们将运行的用来连接区块链节点到Morales的文件，F RPC。ini将是做这个的配置文件。

15364
25:28:35.169 --> 25:28:40.549
这是其中一节下载这将是最难的步骤之一。

15365
25:28:40.549 --> 25:28:48.541
所以如果你迷路了，请在GitHub上提问，请在莫拉莱斯论坛上提问，也有一个莫拉莱斯论坛，在那里你可以问很多不同的问题。

15366
25:28:48.541 --> 25:28:50.677
也请查看故障排除。

15367
25:28:50.677 --> 25:28:56.150
我要做的是在这里创建一个新文件夹叫做F R P。

15368
25:28:56.150 --> 25:28:58.821
我在这里做它只是为了让它更简单一点。

15369
25:28:58.916 --> 25:29:02.737
但你可以把它放在任何你想放的地方，然后总是引用它。

15370
25:29:02.737 --> 25:29:09.555
我要做的是我要复制这两个文件，把它们放到这个FRP文件夹里。

15371
25:29:09.555 --> 25:29:23.968
现在我有了FRP C和frpc那ini如果你点F RPC，它会像，嘿，它是二进制的，你不能看这个，不要点那个，它只是一堆废话，但frpc。ini看起来是一个非常典型的配置文件。

15372
25:29:23.968 --> 25:29:26.443
这就是我们要调整的。

15373
25:29:26.443 --> 25:29:31.836
即使我们回到我们的士气服务器，它也会给你你需要的东西。

15374
25:29:31.836 --> 25:29:33.416
我们要用安全帽。

15375
25:29:33.416 --> 25:29:35.853
所以我们要复制这里的所有东西。

15376
25:29:35.853 --> 25:29:41.566
我们会回到frpc。ini，然后把这里的东西粘贴到这里。

15377
25:29:41.566 --> 25:29:45.254
这就是我们如何告诉这个frpc我们需要连接。

15378
25:29:45.254 --> 25:29:47.536
我还没有为使用WsL的用户尝试过这个功能。

15379
25:29:47.536 --> 25:29:57.057
因此，如果你正在使用WsL，请在完整的区块链固体性课程中让我们知道，Jas，进行一个新的讨论，如果你还没有看过它，说，嘿，我正在为F RPC使用WsL。

15380
25:29:57.057 --> 25:29:58.557
这是你需要用到的。

15381
25:29:58.557 --> 25:30:01.142
然后在底部写着，跑步享受。

15382
25:30:01.142 --> 25:30:07.297
我在Mac OS上运行，它运行Linux命令，所以我可以复制这个，我会创建一个新终端。

15383
25:30:07.297 --> 25:30:10.794
我要做的是把它cd到FRP文件夹里。

15384
25:30:10.794 --> 25:30:16.390
我要把我刚从罗斯那里复制的东西粘贴过来。

15385
25:30:16.390 --> 25:30:22.135
我们运行那个frpc可执行文件，破折号c，也就是破折号配置，frpc。ini。

15386
25:30:22.135 --> 25:30:31.158
如果我按回车键，它会显示登录服务器成功，获取运行ID，等等，服务器，UDP端口，还有一大堆其他东西。

15387
25:30:31.158 --> 25:30:34.450
如果你在这里看到了成功的东西，那就意味着你做对了。

15388
25:30:34.450 --> 25:30:39.117
你可以按CTRL C取消因为我们不会一直运行它。

15389
25:30:39.117 --> 25:30:41.817
现在，如果你想运行这个，你完全可以。

15390
25:30:41.817 --> 25:30:44.472
但我要给你们展示另一种方法。

15391
25:30:44.472 --> 25:30:47.646
这是使用Morales管理命令行。

15392
25:30:47.646 --> 25:30:56.317
我们在这里做的所有事情，我们按下的所有这些按钮，都有一个叫做管理CLI的东西或者命令行界面。

15393
25:30:56.317 --> 25:31:02.547
这是我们连接和运行所有这些按钮和东西的一种方式我们在终端和shell中按下这些按钮和东西。

15394
25:31:02.547 --> 25:31:06.338
因此，我将向您展示几个关于如何使用管理CLI的命令。

15395
25:31:06.338 --> 25:31:09.338
我们将使用大量的管理CLI命令。

15396
25:31:09.338 --> 25:31:14.850
但我们要做的是npm install dash g Morales, admin CLI或者我们的yarn Global Add。

15397
25:31:14.850 --> 25:31:21.802
我们会去做yarn, Global Add routes，这样的admin CLI。

15398
25:31:21.802 --> 25:31:28.345
现在我们应该可以运行Morales admin CLI看到一大堆这样的东西。

15399
25:31:28.345 --> 25:31:31.606
如果你运行路由，admin CLI，我们有所有这些东西。

15400
25:31:31.606 --> 25:31:37.968
其中一个大的，也是最重要的是我们要处理的是连接本地开发者链。

15401
25:31:37.968 --> 25:31:41.295
运行这个F RPC破折号c破折号F RPC ini。

15402
25:31:41.295 --> 25:31:45.816
这和运行connect本地开发链是一样的。

15403
25:31:45.816 --> 25:31:49.672
现在我要做的是进入我们的package。JSON。

15404
25:31:49.672 --> 25:32:05.473
我们会在这里创建一个附加的脚本来运行yarn，不管我们想要什么名字，为了这样做，为了让我们更容易连接本地的开发链在lint下面，我要做一个平静的，女士，我要创建一个新命令。

15405
25:32:05.473 --> 25:32:07.615
我选莫拉莱斯同步。

15406
25:32:07.615 --> 25:32:14.180
我们会运行这个frpc dash c的Morales admin CLI版本。

15407
25:32:14.180 --> 25:32:31.054
这里我们要做的是mirallas admin CLI，连接本地开发链，破折号链，硬帽，破折号mirallas。

15408
25:32:31.054 --> 25:32:33.644
大写子域。

15409
25:32:33.918 --> 25:32:43.697
这是我们将放置士气服务器子域的地方，如果我们回到我们的路线，管理数据服务器，我们可以回到服务器细节。

15410
25:32:43.697 --> 25:32:48.563
这不是HTTPS，而是从这里一直到。

15411
25:32:48.563 --> 25:32:48.756
com。

15412
25:32:48.756 --> 25:32:53.348
不包括端口，我们要抓取它粘贴到这里。

15413
25:32:53.348 --> 25:33:05.496
然后我们要写，f RPC路径是。/ f RPC， / FRP / f RPC。

15414
25:33:05.496 --> 25:33:09.273
如果我们保存这个，然后运行它，它就不能工作了。

15415
25:33:09.273 --> 25:33:16.817
如果我用我们的新脚本Morales sync运行yarn，它会说指定Morales API key，它会给我们这个提示。

15416
25:33:16.817 --> 25:33:23.866
在仪表板中，我们有API key，我们可以复制粘贴它，还有API secret，我们可以复制粘贴它。

15417
25:33:23.866 --> 25:33:27.308
然后我们说开始连接到硬帽，这很好。

15418
25:33:27.308 --> 25:33:28.454
但那真的很烦人。

15419
25:33:28.454 --> 25:33:29.739
我可不想这么做。

15420
25:33:29.739 --> 25:33:31.485
按Ctrl C，把它扼杀掉。

15421
25:33:31.485 --> 25:33:34.869
我们能做的就是进入。env。

15422
25:33:34.869 --> 25:33:40.652
我们可以把这些作为莫拉莱斯期望的环境变量。

15423
25:33:40.652 --> 25:33:49.981
当我们运行Morales admin CLI时，它会检查。env文件是否有Morales API key，我们可以复制到这里。

15424
25:33:49.981 --> 25:33:57.272
然后是Morales API secret，我们可以复制粘贴到这里。

15425
25:33:57.272 --> 25:34:03.452
现在，这些不是资本的原因是，它们不会成为我们的前端部分。

15426
25:34:03.452 --> 25:34:08.569
这些是我们在后端用于测试和本地开发链连接的键。

15427
25:34:08.569 --> 25:34:12.207
所以我们不需要做next public，就这样吧。

15428
25:34:12.207 --> 25:34:19.064
但是现在如果我点击并运行yarn Morales同步，这次它不会提示我，它只会说开始连接到安全帽。

15429
25:34:19.064 --> 25:34:29.838
如果你看到这个，开始连接到硬帽位，我们可以回到我们的服务器，我们会到开发链代理服务器，我们会点击这个断开按钮，刷新。

15430
25:34:29.919 --> 25:34:38.252
如果你看到连接，你已经成功连接了我们的心脏添加节点，它正在运行到我们的莫拉莱斯服务器上，太棒了。

15431
25:34:38.252 --> 25:34:45.495
事实上，如果你坐在没有终端的心脏上，你会看到对区块链的实际RPC调用。

15432
25:34:45.495 --> 25:34:54.872
你会看到莫拉莱斯一直在调用f区号以确保它是最新的。

15433
25:34:54.872 --> 25:35:01.570
那么我们如何告诉士气服务器开始监听事件呢?有两种方法。

15434
25:35:01.570 --> 25:35:03.808
第一种方法是用户界面。

15435
25:35:03.808 --> 25:35:06.792
我们可以去查看细节，我们会去同步。

15436
25:35:06.920 --> 25:35:09.242
现在它说没有安装同步服务。

15437
25:35:09.920 --> 25:35:11.049
添加一个新的同步。

15438
25:35:14.920 --> 25:35:20.592
观察合约事件，我们可以观察交易的地址也可以观察任何事件的某个地址。

15439
25:35:20.592 --> 25:35:33.051
我们可以在这里手动添加所有信息，你可以选择链描述，决定是否要同步历史，我们可以放入事件的主题，事件的ABI，事件过滤器的地址，然后是表名。

15440
25:35:33.051 --> 25:35:40.216
或者我们可以通过编程来完成这一切，这就是我们将要做的，我们会创建一个可以运行的小脚本，告诉士气服务器去监视这些脚本。

15441
25:35:40.216 --> 25:35:44.329
我们会看到我们的数据库升级到监听这些事件。

15442
25:35:44.329 --> 25:35:58.446
回到代码中，我们会创建一个名为add events that Jas的新文件现在我们有一个终端在运行前端一个终端在运行区块链一个终端在同步区块链和morass。

15443
25:35:58.446 --> 25:36:00.134
现在我们来做另一个终端。

15444
25:36:00.134 --> 25:36:11.402
对于任何我们想做的事，比如运行小脚本变成Morales码头，点击connect with SDK，我们有很多不同的方式可以连接SDK，我们已经学过如何通过使用react Morales连接react。

15445
25:36:11.402 --> 25:36:16.661
现在我们将不连接JS因为我们将运行一个小的Morales脚本。

15446
25:36:16.661 --> 25:36:20.227
这是文档中的一个小例子。

15447
25:36:20.227 --> 25:36:26.554
但我要继续，我写入const Morales，等于require oralis slash node。

15448
25:36:26.554 --> 25:36:42.463
我们要导入Morales包的节点扩展到我们的脚本中，我们需要。env。config，这意味着我们需要安装。env yarn添加。dev。env。

15449
25:36:42.463 --> 25:36:49.128
现在我们必须告诉士气服务器我们需要在用户界面上告诉它的所有信息。

15450
25:36:49.128 --> 25:36:51.889
我们首先需要的是合同的地址。

15451
25:36:51.921 --> 25:37:06.619
我们需要写上const合约地址=这就是我们要去的地方我们怎么得到合约地址呢?最简单的方法是我们回到运行区块链的地方我们会抓取NFC市场部署的地方。

15452
25:37:06.619 --> 25:37:12.873
类似于智能合约彩票我们创建了一个更新前端脚本，这里我们要做完全相同的事情。

15453
25:37:12.873 --> 25:37:30.854
回到我们的非ft市场，如果T code，我们到我们的部署脚本或部署文件夹，我们会创建一个新文件叫做99 Dash update，前端。j s，我们会创建一些部署进程它会自动更新我们的前端。

15454
25:37:30.854 --> 25:37:35.403
所以我们可以从程序创建的文件中获取网络地址。

15455
25:37:35.403 --> 25:37:39.748
我们要写module。exports = async function。

15456
25:37:39.748 --> 25:37:57.243
现在我们说if process。EMV那个更新前端，然后console。log，更新前端在。EMV中，我们有更新前端= true。

15457
25:37:57.243 --> 25:38:01.550
这将是我们决定是否要更新前端的方式。

15458
25:38:01.550 --> 25:38:06.478
然后我们会创建一个函数叫做up date contract addresses，我们会等待它。

15459
25:38:06.478 --> 25:38:09.904
这将更新我们前端的合同地址。

15460
25:38:09.904 --> 25:38:11.734
我们来做这个函数。

15461
25:38:11.734 --> 25:38:19.382
执行async函数更新契约地址，确保它们拼写相同。

15462
25:38:19.382 --> 25:38:26.122
所以我们写const NFT, market place = await醚。get contract。

15463
25:38:26.122 --> 25:38:32.646
然后，是的，我们需要导入const ethers = require hardhat，我们将占领非ft市场。

15464
25:38:32.646 --> 25:38:43.212
然后我们要把文件写到这里到前端代码的某个地方，我们要在一个新的文件夹常数中做。

15465
25:38:43.212 --> 25:38:49.193
我们将在这里创建一个新文件network mapping。JSON。

15466
25:38:49.193 --> 25:38:54.954
这是一个JSON对象它记录所有部署。

15467
25:38:54.954 --> 25:39:11.196
所以如果我们部署一些东西，V链会保持一个列表，它会保持一个列表，它会说，非金融市场将保持一个所有的物联网市场地址的列表，基本的NFT，对，然后我列出所有这些，现在我们没有部署任何东西。

15468
25:39:11.196 --> 25:39:13.829
我们让它是一个空JSON对象。

15469
25:39:13.829 --> 25:39:21.022
现在回到我们在硬帽非ft市场项目中的部署脚本中，我们将跟踪那个位置。

15470
25:39:21.022 --> 25:39:23.460
在顶部，我们会说const。

15471
25:39:23.460 --> 25:39:32.971
前面，和合同文件等于，我们将放置它的位置根据你的文件设置。

15472
25:39:32.971 --> 25:39:41.750
如果我输入cd。。/ next JS NFT，市场，free code, Camp常量，网络映射。JSON，这就是我的所在。

15473
25:39:41.750 --> 25:39:50.822
所以你会想把它放在任何你的位置在Mt marketplace Free Code Camp，它是我的前端合同文件，它就在这里。

15474
25:39:50.822 --> 25:39:53.561
现在我们有了所有这些，我们要得到链ID。

15475
25:39:53.561 --> 25:39:59.823
我们写入const, chain ID = network。config。chain ID。

15476
25:39:59.823 --> 25:40:00.723
字符串。

15477
25:40:00.723 --> 25:40:05.288
我们还需要从硬帽导入网络。

15478
25:40:05.288 --> 25:40:11.195
然后我们要从这个网络映射文件中读取看当前在那里有什么。

15479
25:40:11.195 --> 25:40:12.922
所以我们用const。

15480
25:40:12.922 --> 25:40:26.285
合约地址等于。我们要做一个JSON。parse。Fs。read文件同步，front front和合约。

15481
25:40:26.285 --> 25:40:29.361
文件，UTF, 8。

15482
25:40:29.361 --> 25:40:34.650
这是我们要说的，如果chain ID在契约中。

15483
25:40:34.650 --> 25:40:47.423
地址，我们说如果这个合同地址列表不包括市场，然后加上，我们会说如果合同地址的链ID的NFT。

15484
25:40:47.423 --> 25:41:24.605
市场会说。包括NFT，市场，Mar get地点。地址，然后我们会说合约地址说链ID NFT市场，push NFT市场。地址否则我们会说合约地址说链ID NFT市场，这将是一个新的条目现在等于NFT。

15485
25:41:24.605 --> 25:41:28.668
市场市场地点点地址。

15486
25:41:28.923 --> 25:41:34.502
现在我们更新了合约地址对象我们只需要把它写回网络映射。

15487
25:41:34.502 --> 25:41:54.090
现在我们写入Fs。right file sync front and contractfile, JSON。string五个合约地址然后在底部我们写入module。exports。tags =我们写入all or front end。

15488
25:41:54.090 --> 25:42:05.466
现在我们能做的是运行这个更新前端脚本用yarn hardhat deploy虚线虚线，网络localhost。

15489
25:42:05.466 --> 25:42:09.457
我们只想做这个更新前端脚本。

15490
25:42:09.457 --> 25:42:25.743
所以我们说，破折号标签前端，我们运行这个，我遇到了一个错误FS is not defined，哦，我忘了const FS = require FS stride，不能设置未定义的非功能性市场的属性。

15491
25:42:25.743 --> 25:42:26.070
哦。

15492
25:42:26.070 --> 25:42:30.174
这是因为这条线是关闭的，而不是这条线。

15493
25:42:30.174 --> 25:42:34.831
基本上，现在，它说的是，它说的是，嘿，这个非金融市场不存在。

15494
25:42:34.831 --> 25:42:36.615
所以我们要让它存在。

15495
25:42:36.615 --> 25:42:51.524
现在我们说链ID的合约地址等于NFT市场的一个新条目并添加它的第一个参数，它将是NFT, Mark得到放置点地址，像这样。

15496
25:42:51.524 --> 25:42:56.268
现在我们可以运行它了，更新前端看起来已经完成了。

15497
25:42:56.268 --> 25:43:04.440
如果我们回到我们的前端，我们现在看到我们有一个为localhost with NFC marketplace的条目，地址在我们的网络映射。JSON中。

15498
25:43:04.440 --> 25:43:06.111
如果做对了，就会得到这个。

15499
25:43:06.111 --> 25:43:14.088
如果没有，如果你有困难你当然可以，直接硬编码进去但我强烈建议你用编程的方式来做，因为你的生活将会好很多。

15500
25:43:14.088 --> 25:43:14.378
太酷了。

15501
25:43:14.378 --> 25:43:19.194
我们有这个更新前端脚本，现在可以工作了，所以我们可以把它放回一边。

15502
25:43:19.194 --> 25:43:20.527
让我们继续。

15503
25:43:20.527 --> 25:43:25.686
现在我们有了这个网络映射文件，其中包含基于链ID的合同地址。

15504
25:43:25.686 --> 25:43:40.401
我们能做的是把它也拉进来，我们说const contract, address说= require。斜杠常数，斜杠网络映射。JSON。

15505
25:43:40.401 --> 25:43:44.236
现在我们可以根据链ID获取合同地址。

15506
25:43:44.236 --> 25:43:54.279
所以链ID等于进程点E和V点链ID，或者31337。

15507
25:43:54.279 --> 25:43:59.521
在数据和V中，我们会新建一个名为Chain ID的项。

15508
25:43:59.521 --> 25:44:01.362
现在我们用31337。

15509
25:44:01.362 --> 25:44:13.433
现在我们可以通过说合同地址等于合同地址在链ID n f t Mark处得到0的位置。

15510
25:44:13.433 --> 25:44:22.699
所以我们将进入网络映射，进入链，我将进入非功能性市场并获得最近部署的非功能性市场繁荣。

15511
25:44:22.699 --> 25:44:26.367
现在我们有了合同地址合同地址写着，对不起。

15512
25:44:26.367 --> 25:44:32.763
在添加事件中，我们会创建一个新函数类似于我们正在做的，我们会写async function main。

15513
25:44:32.763 --> 25:44:35.021
这是我们的主要功能。

15514
25:44:35.021 --> 25:44:51.498
当然，我们会复制粘贴主脚本这个我们一直在做的时间域点然后catch等等，我们回到沼泽文档，我们会看到我们需要获取服务器URL, app ID主键，然后启动它。

15515
25:44:51.498 --> 25:44:53.451
所以我们要做完全一样的事情。

15516
25:44:53.451 --> 25:44:57.892
抱歉，在我们进入main之前，你可以在main函数中做。

15517
25:44:57.926 --> 25:45:05.383
我们写入const serverurl =，我们可以再次从web中获取这个。

15518
25:45:05.383 --> 25:45:27.560
我们说process web。next public Morales服务器URL，我们会得到app ID = process Studien v。next public Morales app ID，然后我们会说const, master key = process study v。master key。

15519
25:45:27.560 --> 25:45:30.226
所以我们这里还没有万能钥匙。

15520
25:45:30.226 --> 25:45:33.354
我们新建一个master key。

15521
25:45:33.354 --> 25:45:39.392
回到Morales前端，关闭这个，点击查看细节。

15522
25:45:39.392 --> 25:45:41.458
我们去拿万能钥匙。

15523
25:45:41.458 --> 25:45:44.991
复制这个，回到代码编辑器，粘贴进去。

15524
25:45:44.991 --> 25:45:47.796
现在我们的网站上也有了一个万能钥匙。

15525
25:45:47.796 --> 25:45:50.610
我们不希望我们的万能钥匙在前端。

15526
25:45:50.610 --> 25:45:53.110
所以我们不会像这样公开下一个。

15527
25:45:53.110 --> 25:46:12.992
主函数中我们要做的第一件事是await Morales。start服务器URL, app ID和主键作为输入参数这会做一个console。log，使用合同地址，合同地址。

15528
25:46:12.992 --> 25:46:17.576
现在我们要添加UI中所有相同的片段。

15529
25:46:17.576 --> 25:46:29.926
那么我们想听的事件是什么呢?如果我们回到这里的代码，我们有非ft市场，在这里输入event我们有商品列表，商品购买，商品取消。

15530
25:46:29.926 --> 25:46:36.392
我们有三个要听的事件和一个Morales，他们有这个从代码同步的添加新事件，我们基本上会遵循这个。

15531
25:46:36.392 --> 25:46:41.096
要做到这一点，我们显然需要开始并为事件创建选项。

15532
25:46:41.096 --> 25:46:52.663
我们有链地址主题，abi elimite，表名，同步历史然后我们只做Morales。Cloud。run，观看云事件选项使用主键。

15533
25:46:52.663 --> 25:46:54.031
差不多就是这样了。

15534
25:46:54.031 --> 25:46:57.140
我们将遵循这些文档来编写代码。

15535
25:46:57.140 --> 25:46:58.688
让我们从列出的项目开始。

15536
25:46:58.688 --> 25:47:01.350
让我们为id列出的事件创建一些选项。

15537
25:47:01.350 --> 25:47:09.830
我们说，let item lists options，如果我们想的话也可以用const，这里我要写的是，let item lists options equals。

15538
25:47:09.830 --> 25:47:15.943
首先我们需要链ID，我们已经有了，因为我们要从莫拉莱斯那里得到。

15539
25:47:15.943 --> 25:47:22.411
关于chain ID首先要指出的是，ralis知道本地链是1337。

15540
25:47:22.411 --> 25:47:29.249
所以即使你用的是31337，如果你在做本地开发，你也要切换到1337。

15541
25:47:29.249 --> 25:47:33.588
我们再设一个变量叫做莫拉莱斯链ID。

15542
25:47:33.588 --> 25:47:44.164
我们就说，让莫拉莱斯的链ID等于31337。

15543
25:47:44.164 --> 25:47:48.079
问号311337。

15544
25:47:48.079 --> 25:48:01.834
否则，chain ID但是我们说因为Morales知道任何本地Dev都是1337，我们说如果chain ID等于31337。

15545
25:48:01.927 --> 25:48:04.910
那么莫拉莱斯链ID等于1337。

15546
25:48:06.927 --> 25:48:14.863
无论链的想法是什么，在点环境中我们可以决定，如果我们想做rink B, localhost main net等等。

15547
25:48:14.928 --> 25:48:24.859
我们会说，好，链ID morass会做你的Morales链ID，逗号，我们还需要什么?我们做了chain ID，我们会跳过description，一个同步历史。

15548
25:48:24.928 --> 25:48:31.435
点击同步历史允许节点返回整个区块链，获取契约发出的所有事件。

15549
25:48:31.435 --> 25:48:37.583
因为这是一个非常小的本地区块链只会说sync history is true。

15550
25:48:37.583 --> 25:48:38.566
像这样。

15551
25:48:38.566 --> 25:48:45.061
好吧，我们还需要什么?好的，我们需要主题，主题将是你的事件信息。

15552
25:48:45.061 --> 25:48:51.428
要获得主题，回到我们的事件代码，主题将是事件的名称，加上参数的类型。

15553
25:48:51.428 --> 25:49:09.134
我们会回到代码，我们会回到这里，我们会说，topic is going to item lists，它有一个地址，一个地址，一个地址，一个地址，你去了56，一个UNT 256，地址地址，你采访了6,YouTube和6。

15554
25:49:09.134 --> 25:49:20.237
那些问题看起来是这样的，我们还需要事件的API，我们可以找到我们回到我们的硬帽项目，我们去工件，我们去契约。

15555
25:49:20.237 --> 25:49:28.673
如果市场。灵魂非ft市场。JSON，我们从这里开始的ABI将是整个合同的ABI。

15556
25:49:28.673 --> 25:49:31.100
我们只需要item列出事件。

15557
25:49:31.100 --> 25:49:33.789
我们按Ctrl F，我们在这里找到了它。

15558
25:49:33.928 --> 25:49:44.261
我们会在它说到type event之后进行抓取，我们会复制我们会向上滚动到anonymous false，对吧，这一点描述了事件的ABI。

15559
25:49:44.261 --> 25:49:59.535
我们有内部类型，地址，名称，卖家类型，地址，如果T地址令牌ID price item lists，对吧，这将是我们item lists事件的ABI，我们可以把它插入这里，点击保存，然后自动格式化它，去掉括号。

15560
25:49:59.535 --> 25:50:05.765
好，我们还需要什么，我们有主题，有ABI，我们已经有地址，我们不需要过滤器。

15561
25:50:05.765 --> 25:50:07.200
然后我们需要一个表名。

15562
25:50:07.200 --> 25:50:12.103
我们要新建一行，我们写入表名，它将是item lists。

15563
25:50:12.103 --> 25:50:16.329
这将是数据库中更新的表的名称。

15564
25:50:16.329 --> 25:50:22.640
我们会在这里得到一个新表，叫做item lists，它会填满关于item lists事件的信息。

15565
25:50:22.640 --> 25:50:25.816
这就对了，如果我们在UI上做这个，我们会点击确认。

15566
25:50:25.816 --> 25:50:31.309
因为我们在这里做，我们点击保存，这是我们的一个事件，我们想对所有事件都这样做。

15567
25:50:31.309 --> 25:50:32.832
让我们现在就为购买的物品结账。

15568
25:50:32.929 --> 25:50:42.322
我们写入item bought options，等于我们会重复这个过程，顶部的一些东西是一样的，链也是一样的同步历史也是一样的。

15569
25:50:42.322 --> 25:50:48.025
我们可以抓取这两个，粘贴到item下面，但主题是不同的。

15570
25:50:48.025 --> 25:50:57.643
主题将是item bot是事件的名称，它将取一个地址，一个地址，一个un 256和一个un 256。

15571
25:50:57.643 --> 25:51:00.691
ABI将会有所不同。

15572
25:51:00.691 --> 25:51:07.187
再一次，我们要去我们的Hardhead非ft市场，我们会寻找一个机器人，你会在这里找到这个活动。

15573
25:51:07.187 --> 25:51:15.976
我们复制这个，返回，粘贴到这里，我们有了item bot，我们给它一个表名item bot。

15574
25:51:15.976 --> 25:51:33.404
然后还有一个我们有let item cancelled options =我们将做chain ID这将是唤醒chain ID将是来自顶层地址的相同样板。

15575
25:51:33.404 --> 25:51:36.381
合同地址的主题将有所不同。

15576
25:51:36.381 --> 25:51:44.719
这个的主题叫做item cancelled，它有一个地址，一个地址和一个unt256会说sync。

15577
25:51:44.719 --> 25:51:49.180
历史将是真实的，历史是真实的。

15578
25:51:49.180 --> 25:51:50.742
然后我们需要ABI。

15579
25:51:50.742 --> 25:52:00.822
再一次，我们可以回到我们的安全帽，编译信息我们可以寻找取消的项目，获取事件的ABI。

15580
25:52:00.822 --> 25:52:01.893
收到

15581
25:52:01.893 --> 25:52:05.011
回到粘贴进来的运行代码。

15582
25:52:05.011 --> 25:52:06.830
哦，我没有给出项目取消。

15583
25:52:06.930 --> 25:52:12.766
让我们给item cancelled一个表名，它将是item cancelled。

15584
25:52:12.766 --> 25:52:18.360
缩小一点，就有取消选项和购买选项。

15585
25:52:18.360 --> 25:52:27.336
项目列表选项告诉罗斯，听这些事件，每当你听到一个项目取消事件，把所有这些东西都存入数据库。

15586
25:52:27.336 --> 25:52:35.336
当你听到一个物品购买事件时，把所有这些都存入数据库，当它发出一个列出的物品时，把所有这些都存入数据库以便我们可以从中读取。

15587
25:52:35.336 --> 25:52:38.372
所以我们为这些事件建立索引，这样我们就能更容易地查询它们。

15588
25:52:38.372 --> 25:52:57.768
现在把它们发送到我们的服务器会说const列出的响应等于await或者Alice。Cloud。run，观察契约事件会传递列出的选项。

15589
25:52:57.768 --> 25:53:06.716
再加一个逗号，然后我们传递一个对象到这里我们会说use master key是true。

15590
25:53:06.716 --> 25:53:12.479
我们会做同样的事情我们会说const bot response或传递bot item选项。

15591
25:53:12.479 --> 25:53:26.967
我们写入bot response = await或else。Cloud。run, watch合约，事件，逗号，item bought options。

15592
25:53:26.967 --> 25:53:32.388
逗号，使用主键，这是真的。

15593
25:53:32.388 --> 25:53:52.866
最后康德的取消响应等于await oralis。Cloud。run, watch contract event，逗号，item cancelled options，逗号use master key将为真。

15594
25:53:52.866 --> 25:53:59.269
这个Morales。Cloud。run对服务器的API调用会返回一个响应。

15595
25:53:59.269 --> 25:54:03.167
让我们看一下文档看看如果它成功了，反应是什么样的。

15596
25:54:03.167 --> 25:54:03.439
好。

15597
25:54:03.439 --> 25:54:06.877
在终点站，你会看到真正的成功。

15598
25:54:06.877 --> 25:54:10.253
这是我们从API获得的返回值。

15599
25:54:10.253 --> 25:54:15.031
为了确保一切顺利，我列出一个if。

15600
25:54:15.031 --> 25:54:30.502
Response。success，我们从rails服务器获取那个success对象，我们只做一个console。log success数据库，用监视事件更新。

15601
25:54:30.502 --> 25:54:37.145
然后我们会写console。log，鸭子出问题了。

15602
25:54:37.145 --> 25:54:43.744
当然，我们不只是要求response。success为真。

15603
25:54:43.744 --> 25:54:52.032
我们还希望取消响应成功和机器人响应成功。

15604
25:54:52.032 --> 25:54:54.151
然后说，嘿，你做到了。

15605
25:54:54.151 --> 25:54:56.716
否则就说嘿，出问题了。

15606
25:54:56.716 --> 25:55:02.265
这就是我们通过编程告诉服务器和数据库监听事件的方式。

15607
25:55:02.265 --> 25:55:08.832
我们只需要等待Murata Clodagh，运行，观察契约事件，我们将这个带有参数和标志的对象传递给它。

15608
25:55:08.832 --> 25:55:09.782
就这样了。

15609
25:55:09.782 --> 25:55:14.581
然后我们就可以发送了因为我放了下一个公共莫拉莱斯服务器的URL。

15610
25:55:14.581 --> 25:55:17.386
在我的车管所，我只有下一个公共服务器的URL。

15611
25:55:17.386 --> 25:55:18.899
我们把名字改一下。

15612
25:55:18.899 --> 25:55:20.640
看来我们的服务器地址是错的。

15613
25:55:20.640 --> 25:55:22.865
我们的应用ID名也错了。

15614
25:55:22.865 --> 25:55:26.839
让我们修复下一个公共app ID主键看起来正确。

15615
25:55:26.839 --> 25:55:27.515
好的,很酷。

15616
25:55:27.515 --> 25:55:38.867
让我们来了解一下，好吗?更像Alice, cada运行，Rasta云运行，当我们在数据库中运行这个时，如果刷新，我们看不到这些表。

15617
25:55:38.867 --> 25:55:41.528
但一旦我们运行这个，添加事件。

15618
25:55:41.528 --> 25:55:45.474
Js，我们应该调用服务器告诉它，你需要添加这些表。

15619
25:55:45.474 --> 25:55:47.247
你需要开始倾听这些事件。

15620
25:55:47.247 --> 25:55:53.614
在一个新终端中，我们会运行这个添加事件，比如，我要把终端弄大一点。

15621
25:55:53.614 --> 25:55:57.994
这就是如果出现问题，弄清楚如何解决这个问题会让人有点沮丧的地方。

15622
25:55:57.994 --> 25:56:04.243
所以如果你在这里遇到了问题，如果有些东西没有按照预期工作，请使用与本课程相关的GitHub回购。

15623
25:56:04.243 --> 25:56:08.673
莫拉莱斯论坛和Stack Exchange ethereum也在这里。

15624
25:56:08.673 --> 25:56:14.270
我们运行Node，添加事件，点js，然后回车。

15625
25:56:14.270 --> 25:56:18.624
好了，现在我们看到成功数据库更新了监视事件。

15626
25:56:18.624 --> 25:56:27.728
如果你遇到一个问题，你重新运行它，它出现了一些错误，它仍然有可能是正确的，因为它返回false。

15627
25:56:27.728 --> 25:56:31.793
它返回有一个问题，如果其中任何一个已经有表在那里。

15628
25:56:31.793 --> 25:56:39.725
回到数据库，点击刷新，我就能看到购买，取消和数据库中列出的商品。

15629
25:56:39.725 --> 25:56:44.674
同样，你可以通过点击服务器上的下拉菜单和仪表盘看到它们。

15630
25:56:44.674 --> 25:56:46.610
我们还可以看到事件同步状态。

15631
25:56:46.610 --> 25:56:55.869
这就是我们的数据库知道它需要监听一些事件的方式，它在这里有所有关于如何监听事件的信息。

15632
25:56:55.933 --> 25:56:56.266
太酷了。

15633
25:56:56.266 --> 25:56:57.932
现在我们在监听事件。

15634
25:56:58.933 --> 25:57:10.719
这意味着我们的数据库正在监听区块链节点，它在监听这里的事件它在监听这些项目列出的项目购买的项目，取消的事件。

15635
25:57:10.719 --> 25:57:15.983
所以让我们继续，在我们的硬帽非ft市场自由代码营窗口中测试它。

15636
25:57:15.983 --> 25:57:17.870
我们这里有一些脚本。

15637
25:57:17.870 --> 25:57:19.682
其中之一是薄荷和名单。

15638
25:57:19.682 --> 25:57:21.147
所以我们去了New NFT。

15639
25:57:21.147 --> 25:57:33.266
当我们在市场上列出一个NF T时，我们的mirallas数据库应该听到这个项目列出的事件并继续将它插入到它所创建的项目列出的表中。

15640
25:57:33.266 --> 25:57:38.218
为了验证这一点，让我们打开Hardhead非金融市场回购的终端。

15641
25:57:38.218 --> 25:57:51.617
在实际运行之前，我们会为localhost运行明顿列表，确保我们的硬帽节点与Morales服务器同步以便数据库能够获取那个事件。

15642
25:57:51.617 --> 25:57:54.666
需要连接本地硬帽节点。

15643
25:57:54.666 --> 25:57:59.617
所以我们会做纱线，硬帽运行脚本，薄荷和列表。

15644
25:57:59.617 --> 25:58:02.575
Js破折号，网络localhost。

15645
25:58:02.575 --> 25:58:03.432
让我们进入。

15646
25:58:03.432 --> 25:58:30.362
好的，minting，批准列表现在如果我们回到数据库，在快速刷新之后，你知道吗，我们看到我们的数据库中确实有一个项目列出了事件，我们可以看到一个工具的信息我们可以看到一个块哈希，一个时间戳，我们可以看到列出的令牌ID，我们可以看到清单的价格交易哈希，我们可以看到所有这些关于事件的信息。

15647
25:58:30.362 --> 25:58:32.552
现在它在数据库中供我们查询。

15648
25:58:32.552 --> 25:58:37.837
因此，如果您已经达到了这一点，那么您已经成功地使用Morales数据库设置了一个索引器。

15649
25:58:37.837 --> 25:58:40.425
你应该非常兴奋，因为这真的很强大。

15650
25:58:40.425 --> 25:58:43.610
现在我们进入高级阶段，我们开始做一些高级的东西。

15651
25:58:43.610 --> 25:58:45.772
如果你已经走到这一步，恭喜你。

15652
25:58:45.772 --> 25:58:47.318
这已经很酷了。

15653
25:58:47.318 --> 25:58:58.770
现在，这里还有一些我自己遇到过很多次的故障排除帮助，假设我已经离开了这个项目，我已经停止了我的心跳，我现在就要停止它。

15654
25:58:58.770 --> 25:59:06.217
如果我停止，我的心脏有节点，我回到我的Morales管理，我将查看详细的开发链代理服务器，我现在断开了。

15655
25:59:06.217 --> 25:59:12.291
如果我点击这个刷新，我就断开了，因为我不再运行我的心脏标题。

15656
25:59:12.291 --> 25:59:15.114
如果我重新启动节点，我的笔记也重新启动了。

15657
25:59:15.114 --> 25:59:18.000
我的连接本地dev链命令仍在运行。

15658
25:59:18.000 --> 25:59:21.822
如果我刷新它，它会显示connected，这很好。

15659
25:59:21.822 --> 25:59:37.267
但是，如果我回到区块链，或者回到NFC市场脚本，我运行yarn, hardhat脚本，mint，然后再次列表，network localhost，我回到数据库，然后刷新，我们不会看到这里列出的项目。

15660
25:59:37.267 --> 25:59:43.684
因此，我们的mirallas服务器正在寻找确保我们正在使用的区块链是相同的。

15661
25:59:43.684 --> 25:59:51.327
如果我们重置区块链，就像我们做的，取消它然后重置它，我们的数据库就会很混乱。

15662
25:59:51.327 --> 26:00:01.458
我们要做的是点击重置局部链，重置局部链，我们要确保新的局部链在运行，并且连接到这里。

15663
26:00:01.458 --> 26:00:07.671
我们点击重置本地链，这将告诉他们罗斯，嘿，我们重置了链，没关系，请继续这样做。

15664
26:00:07.671 --> 26:00:12.312
一旦我们点击重置局部链，我们不会看到这个项列在这里。

15665
26:00:12.312 --> 26:00:21.197
但是，如果我们回去，重新运行mint和list网络，本地主机和这个重置本地链。

15666
26:00:21.197 --> 26:00:35.649
回到Morales数据库，点击刷新，就能看到新数据进入只要你停止了硬帽注释，只要你重置了硬帽节点，你就需要到查看详细信息dev链代理服务器重置本地链。

15667
26:00:35.649 --> 26:00:39.709
你也可以用编程的方式来做，我们不打算讲如何用编程的方式来做。

15668
26:00:39.709 --> 26:00:42.839
但这可能是你想在你的安全帽部署中添加的东西。

15669
26:00:42.839 --> 26:00:47.883
另一件需要注意的事是它没有清除上一个事件，对吧。

15670
26:00:47.935 --> 26:00:56.786
如果我在完成后再列出一分钟，这里会有另一个事件。

15671
26:00:56.935 --> 26:00:58.180
好吧，这太棒了。

15672
26:01:00.935 --> 26:01:04.176
我们做的所有这些首先是为了在索引中。

15673
26:01:04.176 --> 26:01:05.917
我们可以开始监听事件。

15674
26:01:05.917 --> 26:01:08.338
我们如何显示最近的侦听实体。

15675
26:01:08.338 --> 26:01:11.335
现在我们有了一个列出实体的数据库。

15676
26:01:11.335 --> 26:01:16.273
我们能做的是，查询这个itemlists表格并抓取这里的所有东西。

15677
26:01:16.273 --> 26:01:23.535
然而，我们有一个问题，如果有人买了一个NFT，会发生什么，如果有人买了一个NFT，项目列出的事件仍然在我们的数据库中。

15678
26:01:23.535 --> 26:01:26.386
但严格来说，它不会再出现在市场上了。

15679
26:01:26.386 --> 26:01:28.579
它会消失，不会被列出来。

15680
26:01:28.579 --> 26:01:33.499
我们能做什么呢，我们可以做很多架构选择来绕过这个问题来解决这个问题。

15681
26:01:33.499 --> 26:01:37.936
但我们能做的一件事是我们能使用mirallas云功能。

15682
26:01:37.936 --> 26:01:45.120
所以Morales云功能让我们能够在士气服务器上添加任何我们想要的前端操作。

15683
26:01:45.120 --> 26:01:45.858
这些是函数。

15684
26:01:45.858 --> 26:01:49.567
这些脚本可以随时在士气服务器上运行。

15685
26:01:49.567 --> 26:01:53.516
我们到服务器点击下拉菜单，点击云功能。

15686
26:01:53.516 --> 26:01:59.212
现在我们可以在其他地方写入东西以便随时在服务器上运行。

15687
26:01:59.212 --> 26:02:14.689
我们会在IDE中设置云功能通过点击这个小滴来同步我们的Visual Studio代码和云功能，我们可以在这里运行这个命令，它会把我们在某个云文件夹中的云功能添加到这里。

15688
26:02:14.689 --> 26:02:21.426
我们能在VS代码中做的是，创建一个新文件夹，名为Cloud Functions。

15689
26:02:21.426 --> 26:02:27.857
在这里，我们会创建一个新文件Update, active items。

15690
26:02:27.857 --> 26:02:28.075
js。

15691
26:02:28.075 --> 26:02:36.613
在这里，如果我们写console。log，我们可以自动保存到士气服务器上。

15692
26:02:36.613 --> 26:02:39.478
我们的方法是运行这个命令。

15693
26:02:39.478 --> 26:02:45.739
现在，我们想让运行这个命令变得容易得多而不是总是要运行这个庞大的东西。

15694
26:02:45.739 --> 26:02:59.840
我们要做的是打开我们的package json，我们会在这里创建另一个Morales脚本，就在这下面，我们会创建另一个Morales脚本，我们会写Morales Morales cloud，我们会有它，运行这个命令。

15695
26:02:59.840 --> 26:03:05.461
我们将复制这个命令，粘贴到我们的package json中。

15696
26:03:05.461 --> 26:03:13.903
这是Morales admin CLI, watchcloud folder，我们不需要Morales API键，因为它会从环境变量中获取那个。

15697
26:03:13.937 --> 26:03:21.750
我们不需要唤醒秘密，因为它会从环境变量中获取它，我们需要士气子域autosave。

15698
26:03:21.750 --> 26:03:32.937
然后Morales云文件夹是新的云功能出价我们做了斜杠云功能，函数。

15699
26:03:32.937 --> 26:03:48.517
现在，在一个新的终端，如果我运行yarn，更多Alice cloud，这和运行这个大函数是一样的，我按回车键，它会显示编译，版本，编译，修改上传正确。

15700
26:03:48.517 --> 26:03:54.396
如果我们回到我们的前端，我们可以看到这个console。log ky我们的前端正在更新。

15701
26:03:54.396 --> 26:04:01.871
如果我们继续在Jas的更新活动项中运行这个，我们还可以写入console。log，保存它。

15702
26:04:01.871 --> 26:04:05.454
如果这个还在运行，它会自动上传。

15703
26:04:05.454 --> 26:04:11.264
现在我们可以看到如果我们稍微刷新一下我们的前端云功能，我们可以看到它已经上传了。

15704
26:04:11.264 --> 26:04:23.784
此时，如果你有很多这样的东西在运行，你可能会看到CPU 100%，你可能会看到这个小东西弹出，服务器可能会开始变慢，我们开始使用大量网络活动。

15705
26:04:23.784 --> 26:04:28.004
现在我要结束我的莫拉莱斯故事了。

15706
26:04:28.004 --> 26:04:30.625
需要的时候我只上传一次。

15707
26:04:30.625 --> 26:04:35.567
因为我们是连接的，我们让它听事件，我们让它在这里做越来越多的事情。

15708
26:04:35.567 --> 26:04:38.199
它会开始给服务器带来大量的负载。

15709
26:04:38.199 --> 26:04:41.307
我们要把它消掉。

15710
26:04:41.307 --> 26:04:42.780
现在的CPU就低很多了。

15711
26:04:42.780 --> 26:04:46.537
回到云功能，我们可以看到它还在这里。

15712
26:04:46.537 --> 26:04:51.410
当我们更新云功能时，它会用这些云功能更新我们的服务器。

15713
26:04:51.410 --> 26:04:54.814
完事后我们就去运行那该死的沼泽云。

15714
26:04:54.814 --> 26:05:03.188
不管怎样，现在我们正试图弄清楚，好吧，我们有商品列出来，但如果有人买了一件商品，严格来说，它将不再列出来。

15715
26:05:03.188 --> 26:05:05.971
但是我们的项目列表表仍然会列出它。

15716
26:05:05.971 --> 26:05:09.438
我们能做的是创建一个云功能，它可以随时运行。

15717
26:05:09.438 --> 26:05:12.276
就像我说的，我们可以让它们随时运行。

15718
26:05:12.276 --> 26:05:13.709
我们可以随时调用它们。

15719
26:05:13.709 --> 26:05:16.148
但我们要创建一个只运行的云功能。

15720
26:05:16.148 --> 26:05:31.905
当这些事件中有一个被同步时取消或购买，我们会创建一个名为活动项目的新表，活动项目会说，任何时候它被列出，它都是活动的，但当它被购买或取消时，它会从活动项目列表中删除。

15721
26:05:31.905 --> 26:05:33.695
我们要创建一个新表。

15722
26:05:33.695 --> 26:05:35.282
我们来做一下。

15723
26:05:35.282 --> 26:05:37.412
我们从爱丽丝的想法开始。

15724
26:05:37.412 --> 26:05:45.776
如果你是IT审核员，你不需要这个，我们不需要在这里导入Morales，因为我们将把它作为云功能上传。

15725
26:05:45.776 --> 26:05:49.723
我们的服务器已经自动向我们的脚本中注入mirallas。

15726
26:05:49.723 --> 26:05:58.179
我们在保存后写上Morales。cloud，你可以用Morales cloud做很多事情。

15727
26:05:58.179 --> 26:06:00.840
这些都可以在文档中找到。

15728
26:06:00.938 --> 26:06:06.674
after save关键字意味着在指定的表上保存数据时，我们将执行一些操作。

15729
26:06:06.674 --> 26:06:08.398
它有两个参数。

15730
26:06:08.398 --> 26:06:12.318
它取保存后我们想要做的表。

15731
26:06:12.318 --> 26:06:13.841
我们会说item lists。

15732
26:06:13.938 --> 26:06:20.824
只要有东西保存到item列表中，我们就会运行async函数。

15733
26:06:20.938 --> 26:06:22.364
我们会把请求写在这里。

15734
26:06:23.938 --> 26:06:26.043
保存后，它附带一个请求。

15735
26:06:27.938 --> 26:06:31.338
发生时，我们希望将其添加到活动项列表中。

15736
26:06:31.938 --> 26:06:35.648
随之而来的请求被标记为确认请求。

15737
26:06:35.939 --> 26:06:40.749
我们用const confirmed因为每个请求，每个事件都会被触发两次。

15738
26:06:40.749 --> 26:06:52.404
一旦事务通过，它会触发保存，一旦事务被确认，我们只希望在事务被确认时更新活动项。

15739
26:06:52.404 --> 26:06:57.605
我们写入const confirmed = request。object。get confirmed。

15740
26:06:57.605 --> 26:07:02.204
筛选，从该请求获得确认的属性。

15741
26:07:02.204 --> 26:07:10.234
然后我们还会让一个logger会说const logger = oralis。Cloud。get logger。

15742
26:07:10.234 --> 26:07:17.237
你马上就会明白为什么，我们可以用这个log写log到我们的Morales数据库。

15743
26:07:17.237 --> 26:07:20.890
所以我们可以把任何对数加到这里，我马上会演示给你们看。

15744
26:07:20.939 --> 26:07:23.412
控制台记录器莫拉莱斯。云，找到记录器。

15745
26:07:23.939 --> 26:07:26.839
我们只写logger。info。

15746
26:07:26.939 --> 26:07:32.126
寻找确定的x，我们现在就可以验证它。

15747
26:07:32.126 --> 26:07:34.813
好吧，我们现在就可以测试一下。

15748
26:07:34.813 --> 26:07:35.563
在日志里。

15749
26:07:35.563 --> 26:07:43.532
我们应该看到寻找确认TX一旦一个项目列出和保存现在测试这只是为了测试我们的记录器是实际工作。

15750
26:07:43.532 --> 26:07:51.549
让我们运行纱线，纱线罗斯云只是更新活动项目到我们的士气服务器更改上传正确。

15751
26:07:51.549 --> 26:07:53.176
好吧，我们现在就杀了它。

15752
26:07:53.176 --> 26:07:57.355
现在我们有了明顿，列表脚本。

15753
26:07:57.355 --> 26:07:59.188
让我们运行明顿列表。

15754
26:07:59.188 --> 26:08:02.389
我们应该能在服务器上看到这些日志。

15755
26:08:02.389 --> 26:08:05.048
到服务器，这里刷新一下。

15756
26:08:05.048 --> 26:08:11.507
如果我们现在看看我们的日志，我们现在可以看到在我们的服务器日志中寻找确认的TX。

15757
26:08:11.507 --> 26:08:12.334
现在在log中。

15758
26:08:12.334 --> 26:08:21.685
这里我们看到我们只会寻找一次确认的TX我刚刚告诉过你们，它实际上会触发两次一次是在事务第一次发送时。

15759
26:08:21.685 --> 26:08:26.569
一旦交易被确认，也就是区块确认。

15760
26:08:26.569 --> 26:08:34.617
另外，如果我们查看数据库中列出的项目，并一直向右滚动，我们可以看到确认等于假。

15761
26:08:34.617 --> 26:08:41.214
因此，我们只想在确认为真时计算此项目列出的事件交互项目。

15762
26:08:41.214 --> 26:08:52.661
我们要做的是更新我们的脚本，在我们的本地Hardhead区块链上添加一个块确认，这样这些就可以被更改为确认，来解决这个问题。

15763
26:08:52.661 --> 26:08:57.058
在我的mentalist脚本中，我通常会添加一个新的工具。

15764
26:08:57.058 --> 26:09:02.560
我到utils，新建文件，然后创建一个move blocks。

15765
26:09:02.560 --> 26:09:02.766
js。

15766
26:09:02.766 --> 26:09:08.649
这是我用来移动方块的工具。

15767
26:09:08.649 --> 26:09:13.908
当我们运行自己的心帽节点时，我们实际上可以完全控制我们想让心帽节点做什么。

15768
26:09:13.908 --> 26:09:23.627
我们能做的是，我们可以手动挖掘节点并向前移动区块，这样Morales就知道，哦，好吧，这个交易被确认了，对吧，因为我们正在用交易挖掘区块。

15769
26:09:23.627 --> 26:09:28.500
就这样，罗斯就只能永远等着下一个街区了。

15770
26:09:28.500 --> 26:09:33.430
所以我们想在脚本中添加一些功能，在它完成后我们只挖掘一个块。

15771
26:09:33.430 --> 26:09:40.035
现在，请记住，如果我们快速挖出1000块或一吨块，Moorehouse可能很难索引它。

15772
26:09:40.035 --> 26:09:45.181
所以我们每次只挖矿一个，给我足够的时间索引每一个挖矿的数据块。

15773
26:09:45.181 --> 26:09:54.190
我们会建立一个小脚本，我们会手动挖矿使用这个EVM挖矿RPC方法它和我们的心帽区块链一起来的。

15774
26:09:54.190 --> 26:09:55.784
我们有了这个新的move blocks脚本。

15775
26:09:55.784 --> 26:09:57.330
我们来做这个。

15776
26:09:57.330 --> 26:10:05.730
这不是我们的脚本，我们会在底部有一个主函数，我们会让这是一个实用程序我们会导入到其他脚本中。

15777
26:10:05.730 --> 26:10:10.392
这里我们不需要一个主函数，我们只需要把它变成一个async函数。

15778
26:10:10.392 --> 26:10:12.246
我们称之为move blocks。

15779
26:10:12.246 --> 26:10:24.389
然后我们写入amount，这是我们想要移动的块的数量，我们还会设置一个sleep amount默认为0，这个sleep amount将是一个可选参数。

15780
26:10:24.389 --> 26:10:32.607
如果我们想移动方块，在方块之间休息一秒钟，就像一个真正的区块链，我们也可以在这里有它。

15781
26:10:32.607 --> 26:10:40.141
所以我们可以让它像一个真正的区块链，通过在方块移动时休眠，或者在方块移动时等待。

15782
26:10:40.141 --> 26:10:53.115
在移动块脚本中，我们会写console。log，移动块，点那个点，我们会说，for let index = 0，我们会绕着amount做一个for循环称之为EVM。

15783
26:10:53.115 --> 26:10:59.544
我在for循环中的index小于amount index加上一个权值网络。

15784
26:10:59.544 --> 26:11:07.731
然后我们要导入network哦，我们要从硬帽导入network, await network。provider。request。

15785
26:11:07.731 --> 26:11:16.207
然后我们会请求方法ev mime逗号params都是空的。

15786
26:11:16.207 --> 26:11:20.734
这和我们对区块链节点进行原始调用的方式是一样的。

15787
26:11:20.734 --> 26:11:26.891
我们没有做很多这样的事情，因为以太把它抽象在引子下，但我们对EVM做了一个原始的调用。

15788
26:11:26.891 --> 26:11:34.166
显然，您不能在一个真正的区块链上调用EVM挖矿，因为您不能只是告诉区块链节点挖下一个块。

15789
26:11:34.166 --> 26:11:48.433
因为这是我们的本地硬帽节点，我们可以调用VM现在我们会说如果sleep amount大于0，或者只是sleep mount，那么我们也会让这个脚本休眠或等待一小段时间。

15790
26:11:48.433 --> 26:11:55.760
在上面，我们会创建一个新函数叫做sleep，它会输入一个以毫秒为单位的时间。

15791
26:11:55.760 --> 26:12:05.257
这将返回一个新的承诺，对吧?因为记住，为了让我们等待一段时间我们必须使用承诺，这是我们之前学过的。

15792
26:12:05.257 --> 26:12:10.243
这个承诺将取一个具有解析的函数作为输入参数。

15793
26:12:10.243 --> 26:12:17.535
我们会说，settimeout将是resolve，逗号，Ms中的time。

15794
26:12:17.535 --> 26:12:21.528
JavaScript的睡眠方式是返回一个新承诺。

15795
26:12:21.528 --> 26:12:25.595
我们把这个叫做set timeout函数，它基本上是以毫秒为单位对时间进行加权。

15796
26:12:25.595 --> 26:12:26.525
现在来看看真正的睡眠。

15797
26:12:26.525 --> 26:12:32.708
我们用console。log表示睡眠量。

15798
26:12:32.942 --> 26:12:39.275
然后我们用await, sleep, sleep amount，单位是毫秒。

15799
26:12:39.275 --> 26:12:45.322
既然sleep返回了一个promise，我们可以用await调用它，等待这个sleep函数完成。

15800
26:12:45.322 --> 26:12:52.127
睡眠函数只有在以毫秒为单位的时间结束时才会结束。

15801
26:12:52.127 --> 26:13:10.666
现在我们有了一个叫move blocks的函数，它会在我们的本地区块链上挖掘block，这样Morales就能确认它正在寻找的block现在在底部，我们只需要做module。exports, move blocks, move blocks，然后我们还会导出sleep，为什么不呢?就像这样。

15802
26:13:10.666 --> 26:13:24.328
现在，我们能在明顿列表中做的是，在顶部，我们会说const, move blocks = require。。/ utils / move blocks。

15803
26:13:24.328 --> 26:13:28.332
然后我们还会从以太网络导入网络。

15804
26:13:28.332 --> 26:13:30.085
在我们的脚本中是向下的。

15805
26:13:30.085 --> 26:13:46.076
就在底部，我们会说if network。config，那个chain ID = = 31337 await, move blocks，我们会说我们会移动到blocks然后我们也会说sleep amount = 1000。

15806
26:13:46.076 --> 26:13:49.688
每挖一个区块，我们会等待一毫秒。

15807
26:13:49.688 --> 26:13:52.943
所以sleep mount等于1000，也就是1毫秒。

15808
26:13:52.943 --> 26:13:56.387
现在让我们把这些都评论一下。

15809
26:13:56.387 --> 26:13:59.800
我们只运行这个脚本。

15810
26:13:59.800 --> 26:14:15.561
好的，我们会把这个拉上来，纱线硬帽，运行脚本，mentalist破折号网络，本地主机，我们只会移动块移动回我们的前端，我们会刷新，我们会去看列出的项目。

15811
26:14:15.561 --> 26:14:19.133
我们往右滚动，现在我们看到确认为真。

15812
26:14:19.133 --> 26:14:23.713
现在如果我们查看我们的日志，我们会看到记录项发生了两次。

15813
26:14:23.713 --> 26:14:26.756
好了，我们取消注释，继续。

15814
26:14:26.756 --> 26:14:34.943
现在我们有了这个现在我们学习了日志记录，现在我们做了所有这些事情，我们可以说If confirmed，我们将要做一些事情。

15815
26:14:34.943 --> 26:14:38.807
如果确认，我们将创建一个名为active item的表并将其添加到active item表中。

15816
26:14:38.807 --> 26:14:42.306
我们要做一个logger。info bound item。

15817
26:14:42.306 --> 26:14:47.580
我们将在这个表中创建一个新表和一个新条目。

15818
26:14:47.580 --> 26:14:57.343
因此我们写入const active item = more Alice。object。extend ACC active item。

15819
26:14:57.343 --> 26:15:02.878
这里我们说的是，如果活动项存在，抓取它，如果不创建它。

15820
26:15:02.944 --> 26:15:07.801
我们会创建这个活动项目表如果它不存在，很好，抓取它。

15821
26:15:07.801 --> 26:15:12.360
我们会说const active item = new, active item。

15822
26:15:12.360 --> 26:15:17.705
我们要在这个活动项目表中创建一个新条目。

15823
26:15:17.705 --> 26:15:20.943
我们说active item。set。

15824
26:15:20.943 --> 26:15:25.895
我们可以为新建的表格设置任意列。

15825
26:15:25.944 --> 26:15:28.232
我们给它一个市场地址列。

15826
26:15:28.944 --> 26:15:31.239
市场地址。

15827
26:15:35.944 --> 26:15:55.157
object。get address所有这些来自事件的请求都带有它们来自的地址，对我们来说，这是市场地址，我们会做active item set如果T地址，这些事件保存的带有事件的所有参数。

15828
26:15:55.157 --> 26:16:31.194
我们会说request那个object。get NFT address会得到价格会说active item。set price将会是request。object。get price将会得到令牌ID会说active item。set令牌ID request。object。get令牌ID然后我们会得到卖方会说active item。set seller将会请求那个object。get seller。

15829
26:16:31.194 --> 26:16:37.147
我们从事件中得到所有这些信息。

15830
26:16:37.147 --> 26:16:42.366
Ross的事件更新总是自动带有事件被遗漏的地址。

15831
26:16:42.366 --> 26:16:45.419
我们会抓取所有我们会创建这个活动项目表。

15832
26:16:45.419 --> 26:16:47.145
我们要把所有这些行相加。

15833
26:16:47.145 --> 26:16:50.267
我们要把这一行加上所有这些列。

15834
26:16:50.267 --> 26:16:50.783
太棒了。

15835
26:16:50.783 --> 26:16:54.833
现在我们用logger。info来打印一下。

15836
26:16:54.833 --> 26:16:56.221
我们说addingaddress。

15837
26:16:56.221 --> 26:17:11.714
我们会做一点字符串插值我们会说request。object。get addressperiod token ID with request。object。get token ID。

15838
26:17:11.714 --> 26:17:15.745
我得把这堵上，堵得更好。

15839
26:17:15.745 --> 26:17:22.500
然后在logger。info之外，我们会说logger。info，保存。

15840
26:17:22.500 --> 26:17:27.634
然后运行await activeitem。save。

15841
26:17:27.634 --> 26:17:37.991
现在我们有了云功能，它会在新表中创建一个新的条目，叫做活动条目，只要列出的条目发生。

15842
26:17:37.991 --> 26:17:44.897
后项称为云功能的触发器，不同的罗斯云功能有很多不同的触发器。

15843
26:17:44.945 --> 26:17:53.599
如果你去莫拉莱斯的文档，我们寻找触发器，我们可以在这里找到所有这些不同的触发器的列表，比如在save之后为save。

15844
26:17:53.599 --> 26:18:03.006
保存后，删除前，删除后，保存文件前，有各种不同的触发器来触发云代码。

15845
26:18:03.006 --> 26:18:09.178
现在，如果我们把这个新脚本上传到士气服务器上并正确上传纱线沼泽和云更改，好，很好，我们可以杀死它。

15846
26:18:09.178 --> 26:18:15.064
回到云服务器，稍微刷新一下确保它没有继续处理更新。

15847
26:18:15.064 --> 26:18:16.183
好的，cpu足够低。

15848
26:18:16.183 --> 26:18:16.793
好了,好了。

15849
26:18:16.946 --> 26:18:20.284
在数据库中，这里没有活动项目表。

15850
26:18:20.284 --> 26:18:36.422
但如果我们回到Hardhead脚本，调用mint和list，因为现在我们有一个云函数，它说，任何时候，项目列表事件发生，更新活动项目表，我们应该看到活动项目更新。

15851
26:18:36.422 --> 26:18:37.564
让我们运行这个。

15852
26:18:37.564 --> 26:18:42.300
记住，我们需要让心头节点连接到硬帽。

15853
26:18:42.300 --> 26:18:46.325
如果我们重置本地链，我们需要点击重置本地链按钮。

15854
26:18:46.325 --> 26:18:48.053
所以我们继续，我们运行了这个。

15855
26:18:48.053 --> 26:18:51.720
回到数据库，稍微刷新一下。

15856
26:18:51.720 --> 26:18:53.849
现在我什么都没看到。

15857
26:18:53.946 --> 26:18:59.657
如果我打开我的日志到信息，我可以看到任何错误或问题。

15858
26:18:59.657 --> 26:19:07.673
所以看起来在保存失败后，为用户列出的项目，等等，等等，看起来有一个问题，不能读取未定义的读扩展的属性。

15859
26:19:07.673 --> 26:19:10.526
这也在信息里，我出了个问题。

15860
26:19:10.526 --> 26:19:13.071
我并没有写完所有的代码。

15861
26:19:13.071 --> 26:19:17.296
回到更新活动项，我能看到我搞砸了哪里。

15862
26:19:17.296 --> 26:19:21.252
它应该是带有大写O点范围的Morales点对象。

15863
26:19:21.252 --> 26:19:31.914
我要做的是，再次运行yarn morass cloud，现在我已经把它修改好了，我们要取消它，我们要再次运行mminton list，现在我们已经修复了我们的脚本。

15864
26:19:31.914 --> 26:19:41.208
现在我们已经修复了脚本，回到数据库，稍微刷新一下，我可以看到这里有一个活动条目。

15865
26:19:41.208 --> 26:19:48.300
在这一点上，有些时候你不想离开去喝杯咖啡，或者去上个厕所或者去吃点东西。

15866
26:19:48.300 --> 26:19:51.418
你需要停止终端的运行。

15867
26:19:51.418 --> 26:19:56.677
让我们练习重新启动所有东西重新进入本地开发环境。

15868
26:19:56.677 --> 26:19:58.759
因为这可能会有点奇怪，有点棘手。

15869
26:19:58.759 --> 26:20:00.196
我们来练习一下。

15870
26:20:00.196 --> 26:20:02.375
我们再来看这里。

15871
26:20:02.375 --> 26:20:11.222
我们需要做什么?按Ctrl C，终止区块链按Ctrl C，终止到Morales服务器的连接。

15872
26:20:11.222 --> 26:20:16.587
如果我们在前端运行Ctrl C，现在如果我们到服务器，我们去查看细节。

15873
26:20:16.587 --> 26:20:23.087
开发链代理服务器，如果我们点击状态，这个重置按钮仍然会我们现在将断开。

15874
26:20:23.087 --> 26:20:25.008
现在一切都被切断了。

15875
26:20:25.008 --> 26:20:42.982
现在如果我们想重新启动一切，如果我们在我们的心帽非ft市场将运行yarn Hardhead节点，这将再次旋转一切，我们将运行yarn Morales同步与我们的路由连接同步，我们可以回到我们的服务器将查看细节，我们现在应该连接了。

15876
26:20:42.982 --> 26:20:43.517
连接。

15877
26:20:43.517 --> 26:20:50.232
因为我们重新启动了本地区块链，我们现在需要记住执行重置本地链，我们会继续运行那个。

15878
26:20:50.232 --> 26:20:50.660
太好了。

15879
26:20:50.660 --> 26:21:02.913
如果我们想重新启动前端，我们可以像这样重新启动前端现在的问题是，我们的数据库仍然会有即使我们刷新它即使我们重置本地区块链，它仍然会有所有这些东西在里面。

15880
26:21:02.947 --> 26:21:08.013
现在这里的这些项是来自一个不再存在的区块链的项。

15881
26:21:08.013 --> 26:21:14.881
我通常会点击上面这个按钮，然后删除这个类中的所有行。

15882
26:21:14.947 --> 26:21:18.619
为了确认我们做的活动项目，读取表的名称。

15883
26:21:18.947 --> 26:21:20.423
让我们对列出的项目也这样做。

15884
26:21:21.947 --> 26:21:23.928
所有行，列出项目。

15885
26:21:23.928 --> 26:21:25.060
是的,删除。

15886
26:21:26.947 --> 26:21:27.309
刷新。

15887
26:21:27.309 --> 26:21:29.067
这里所有的都是0。

15888
26:21:29.947 --> 26:21:32.518
这些事件的空数据库在我们的后保存在这里。

15889
26:21:32.947 --> 26:21:49.328
我们在脚本中添加了一些权重，让我们回到我们的硬帽非ft市场，我们将运行yarn, RT hat，运行脚本，mint和list。j s dash dash network，本地主机。

15890
26:21:49.328 --> 26:21:58.800
这会让它被铸造，被列出来然后我们挖出两个区块给莫拉莱斯时间来索引我们的活动然后在一个士气服务器上。

15891
26:21:58.800 --> 26:22:05.173
我们继续并刷新，现在我们看到项目被列出为一个，活动项目同时是一个。

15892
26:22:05.173 --> 26:22:16.672
这就是我们如何确保，当我们调用一个函数时，Morales总是索引，我们只需要介意一个额外的块，告诉Morales，嘿，那个事务确实被确认了。

15893
26:22:16.672 --> 26:22:17.654
真的很令人兴奋。

15894
26:22:17.654 --> 26:22:21.578
我们还练习了关闭和重新开始，做了所有的好事情。

15895
26:22:21.578 --> 26:22:23.614
这太棒了。

15896
26:22:23.614 --> 26:22:31.340
现在我们有了这个额外的功能让其他人更容易操作好，很好，我们可以检查活动项目。

15897
26:22:31.340 --> 26:22:41.684
我们还没做完呢，对吧?因为如果有人购买了非功能性的，或者出售了一个实体我们应该移除活动项目?对，现在一件活动物品里只列了一件。

15898
26:22:41.684 --> 26:22:46.510
但如果我们买了一件商品，活动商品仍然会显示该商品是活动的。

15899
26:22:46.510 --> 26:22:55.301
让我们继续，让我们更新我们的云功能，也就是说，当一个商品被购买时，我们将该商品从活动状态中移除。

15900
26:22:55.301 --> 26:22:57.454
我们在保存后再创建一个。

15901
26:22:57.454 --> 26:22:59.226
让我们首先构建这个来取消项目。

15902
26:22:59.226 --> 26:23:01.431
然后我们会建立一个购买项目。

15903
26:23:01.431 --> 26:23:10.053
为了在保存后再创建一个触发器，我们写入mirallas。Cloud。after save，我们写入item cancelled。

15904
26:23:10.053 --> 26:23:16.530
这将是一个async函数它再次将请求作为输入参数，我们会做同样的事情。

15905
26:23:16.530 --> 26:23:25.674
我们说const confirmed = request那个object。get confirmed，我们说const。

15906
26:23:25.674 --> 26:23:30.124
Logger等于routes。Cloud。get Logger，像这样。

15907
26:23:30.124 --> 26:23:32.316
然后是logger。

15908
26:23:32.316 --> 26:23:33.894
哦，小写的L。

15909
26:23:33.894 --> 26:23:44.094
然后我们会写logger。info。marketplace，这个小管道对象然后是request。object。

15910
26:23:44.094 --> 26:23:47.466
然后我们做同样的事情。

15911
26:23:47.466 --> 26:23:48.138
如果确认。

15912
26:23:48.138 --> 26:23:53.631
如果这个事务在一个块后被确认，我们将从活动项中删除它。

15913
26:23:53.631 --> 26:23:57.749
我们将使用一个查询首先找到被取消的活动项。

15914
26:23:57.749 --> 26:24:00.556
您可以在Morales文档中了解更多关于基本查询的知识。

15915
26:24:00.556 --> 26:24:11.499
我们将通过const active item = more outlets那个对象对于大写的O对象。extend active item来获得那个表。

15916
26:24:11.499 --> 26:24:13.399
我们会创建一个新的查询。

15917
26:24:13.399 --> 26:24:17.626
在设置或保存数据之前，我们会先查询表格。

15918
26:24:17.626 --> 26:24:24.756
我们会说const, query, query = new Morales。query of active item。

15919
26:24:24.756 --> 26:24:34.120
我们会查询Morales数据库找到一个活动项，它会匹配这里的请求，我们可以取消它。

15920
26:24:34.120 --> 26:24:52.981
我们会说query。equal to marketaddress，逗号request那个对象。get address，我们在寻找一个活动项目其中市场地址将与取消项目的地址相同。

15921
26:24:52.981 --> 26:25:15.085
我们会说query。equal = nft address，逗号request。object。get一个ft address会说query。equal = token ID，逗号request。object。get token ID。

15922
26:25:15.085 --> 26:25:19.802
应该是这样吧?让我们再看一下我们的契约。

15923
26:25:19.802 --> 26:25:26.686
取消的项目给我们一个卖家NFC地址和一个令牌ID卖家ft地址和一个令牌ID。

15924
26:25:26.686 --> 26:25:32.512
我们正在寻找非ft地址和令牌ID，我们不需要寻找卖家，我们只需要寻找这两个。

15925
26:25:32.512 --> 26:25:33.887
当然，还有市场地址。

15926
26:25:33.950 --> 26:25:34.337
太好了。

15927
26:25:36.950 --> 26:25:42.473
Info，然后我们会打印出marketplace类型的查询。

15928
26:25:42.950 --> 26:25:45.700
然后我们会打印出我们正在运行的这个查询。

15929
26:25:45.950 --> 26:26:00.045
然后我们可以说const, cancelled item = await query。首先，我们会找到数据库中第一个活动的项目它有相同的市场地址T地址和刚刚被取消的令牌ID。

15930
26:26:00.045 --> 26:26:01.984
我们要找到第一个被取消的项。

15931
26:26:01.984 --> 26:26:10.021
我们会再做一点logger information，我们会说logger。info, marketplace, pipe, cancelled item。

15932
26:26:10.021 --> 26:26:12.672
然后我们做一些字符串插值。

15933
26:26:12.672 --> 26:26:14.838
我们会打印出取消的项目。

15934
26:26:14.950 --> 26:26:19.330
取消项目，我们会说if Cancelled item。

15935
26:26:20.950 --> 26:26:23.404
没有找到任何东西，它将返回undefined。

15936
26:26:23.950 --> 26:26:27.653
说if cancelled item如果找到了东西，它会返回true。

15937
26:26:27.653 --> 26:26:32.380
如果取消了项目，那么我们会说logger。info。

15938
26:26:32.380 --> 26:26:53.196
删除，然后我们会request。object。get令牌ID at address, request。object。get address地址空间，因为它被取消了，这里我们会打印一些日志记录。

15939
26:26:53.196 --> 26:27:03.899
从它被取消的时候开始取它的前导然后我们运行一个wait cancelled item。destroy这就是我们从活动项中移除它的时候。

15940
26:27:03.951 --> 26:27:06.751
然后我们就说else。

15941
26:27:09.951 --> 26:27:23.165
with address, request。object。get address, and token, Id。

15942
26:27:23.165 --> 26:27:23.879
太酷了。

15943
26:27:23.879 --> 26:27:31.704
现在我们在保存之后有了这个，看起来我的终端自动在这里添加了这个require，这是我们不想要的。

15944
26:27:31.704 --> 26:27:33.644
我要把它删掉。

15945
26:27:33.644 --> 26:27:39.882
我们可以上传这到我们的莫拉莱斯服务器运行纱线，莫拉莱斯云和伟大的变化上传正确。

15946
26:27:39.882 --> 26:27:47.826
现在，为了测试这个测试是否有效，让我们在硬帽非ft市场中创建一个名为cancel item的新脚本。

15947
26:27:47.826 --> 26:27:54.628
我们现在进入脚本我们已经提到了list，我们写入new file，我们将它命名为cancel。Jas。

15948
26:27:54.628 --> 26:27:57.144
我们会取消的，Jas。

15949
26:27:57.144 --> 26:27:59.660
这将是一个脚本。

15950
26:27:59.951 --> 26:28:05.522
我们要用这个主要的东西，但我们要调用我们的函数cancel。

15951
26:28:05.522 --> 26:28:15.014
我们会写async function cancel，然后在顶部，我们会写const令牌ID =现在我们回到活动项列表。

15952
26:28:15.014 --> 26:28:18.214
让我们在这里找到一个令牌ID。

15953
26:28:18.214 --> 26:28:19.525
令牌ID为0。

15954
26:28:19.525 --> 26:28:24.035
我们用这个作为我们要删除的令牌ID。

15955
26:28:24.035 --> 26:28:26.285
我们使用令牌ID 0。

15956
26:28:26.285 --> 26:28:27.904
在取消项中。

15957
26:28:27.904 --> 26:28:32.309
js脚本，我们写入const令牌ID = 0，然后取消它。

15958
26:28:32.309 --> 26:28:33.951
所以我们说const NFT。

15959
26:28:33.951 --> 26:28:38.002
市场等于等待醚点得到合同。

15960
26:28:38.002 --> 26:28:42.047
是的，const醚=需要硬帽。

15961
26:28:42.047 --> 26:28:52.420
ft市场会说const basic NF t = await醚。get get契约。

15962
26:28:52.420 --> 26:29:06.888
基本NF团队做const TX等于等待NF T市场点取消列出基本NF T点地址令牌ID。

15963
26:29:06.888 --> 26:29:14.698
我们调用cancelitemshoulbecancellisting我们调用cancel listing。

15964
26:29:14.698 --> 26:29:17.710
所以取消了上市是的，就像这样。

15965
26:29:17.710 --> 26:29:21.693
它接受NFT的地址和令牌ID。

15966
26:29:21.693 --> 26:29:25.141
基本的NF T点地址和标记D，很好。

15967
26:29:25.141 --> 26:29:27.952
然后我们用权重TX点权重1。

15968
26:29:27.952 --> 26:29:32.752
然后我们写console。log nftcancelled。

15969
26:29:32.952 --> 26:29:41.475
然后我们写入if network。config。chain ID = = 31337。

15970
26:29:41.475 --> 26:29:49.916
我们会继续，我们会做一个等待，移动block到2，然后我们会说sleep。

15971
26:29:49.916 --> 26:29:51.179
Mount = 1000。

15972
26:29:51.179 --> 26:29:54.738
然后我们就说const。

15973
26:29:54.738 --> 26:29:59.403
移动块= require。dot / utils /移动块。

15974
26:29:59.403 --> 26:29:59.953
好的,很酷。

15975
26:29:59.953 --> 26:30:01.215
看起来真不错。

15976
26:30:01.215 --> 26:30:06.247
让我们继续运行这个yarn hardhat运行脚本取消项。

15977
26:30:06.247 --> 26:30:13.280
Js破折号网络，本地主机和ft取消移动块睡眠。

15978
26:30:13.280 --> 26:30:14.152
好了,好了。

15979
26:30:14.152 --> 26:30:15.470
我们的节点正在运行。

15980
26:30:15.470 --> 26:30:15.883
太棒了。

15981
26:30:15.883 --> 26:30:21.091
我们连接到我们的mirallas我们上传了我们的云功能与纱线莫拉莱斯云。

15982
26:30:21.091 --> 26:30:26.425
回到数据库，稍微刷新一下。

15983
26:30:26.425 --> 26:30:29.133
看来我有麻烦了。

15984
26:30:29.133 --> 26:30:34.021
我打开我的信息，它说保存失败后取消用户等等。

15985
26:30:34.021 --> 26:30:35.651
这是登录信息。

15986
26:30:35.651 --> 26:30:38.825
莫拉莱斯点云容易得到侧侧不是一个函数。

15987
26:30:38.953 --> 26:30:39.553
嗯嗯。

15988
26:30:39.553 --> 26:30:42.753
那就说得通了。

15989
26:30:42.753 --> 26:30:43.753
得到水。

15990
26:30:44.953 --> 26:30:46.715
让我们让这个得到记录器。

15991
26:30:48.953 --> 26:30:49.674
上传。

15992
26:30:49.674 --> 26:30:51.444
正确上传更改。

15993
26:30:52.953 --> 26:30:58.103
必须手动到活动项目，我要手动删除这个，会有一个删除这一行。

15994
26:30:58.103 --> 26:30:59.410
是的，删除，刷新。

15995
26:30:59.410 --> 26:31:03.133
我必须这么做的原因是它已经被保存了。

15996
26:31:03.133 --> 26:31:05.100
我们在做一个after保存。

15997
26:31:05.100 --> 26:31:06.485
因为我搞砸了。

15998
26:31:06.485 --> 26:31:08.855
如果你拼对了，你很有可能拼对了。

15999
26:31:08.953 --> 26:31:10.921
但因为我搞砸了，我们得重新建一个。

16000
26:31:10.953 --> 26:31:12.789
然后删除那个新的。

16001
26:31:14.953 --> 26:31:17.268
运行脚本，薄荷和列表网络localhost。

16002
26:31:17.953 --> 26:31:19.090
本来是要加一个新的。

16003
26:31:20.953 --> 26:31:22.114
我们会进行刷新。

16004
26:31:24.953 --> 26:31:25.171
上市。

16005
26:31:25.171 --> 26:31:26.080
它的令牌ID为1。

16006
26:31:26.953 --> 26:31:27.920
现在取消。

16007
26:31:30.953 --> 26:31:31.698
一到一。

16008
26:31:34.953 --> 26:31:40.085
脚本取消项目，网络，本地主机运行此NFT取消移动块。

16009
26:31:40.085 --> 26:31:42.574
现在我们到前端，我们进行刷新。

16010
26:31:42.574 --> 26:31:46.773
我们可以看到它被编程地从活动项中移除，这很好。

16011
26:31:46.773 --> 26:31:49.212
这就是这些日志真正有用的地方。

16012
26:31:49.212 --> 26:32:00.906
现在，故意犯错可能有点可怕，但学习如何使用日志等信息和学习如何有效调试将使你成为一个更快的程序员，因为你猜怎么着，你不会是完美的。

16013
26:32:00.906 --> 26:32:07.215
你将会遇到一些问题，了解如何使用日志，了解如何读取错误将使你成为更快的开发人员。

16014
26:32:07.215 --> 26:32:12.904
现在我们有了取消项目的东西，我们还需要什么东西?你买东西的时候就猜对了。

16015
26:32:12.954 --> 26:32:16.588
我们在保存后再画一幅壁画。

16016
26:32:16.588 --> 26:32:25.237
我们会使用与item cancelled完全相同的item bought代码，我们可能应该把它们都变成一个函数。

16017
26:32:25.237 --> 26:32:30.068
但是为了练习，我们要再做一遍，我们用莫拉莱斯点云。

16018
26:32:30.068 --> 26:32:34.183
然后我的VS代码因为某种原因一直插入这个。

16019
26:32:34.183 --> 26:32:38.863
我要在保存后撤销Morales。Cloud。

16020
26:32:38.863 --> 26:32:40.863
项目机器人是事件。

16021
26:32:40.863 --> 26:32:57.079
这里会有一个async request小箭头函数，const confirmed equals requestobjectdot get confirmed将获取这个事务是否被确认。

16022
26:32:57.079 --> 26:33:00.854
我们会得到记录器，我只需要复制粘贴，所以这次我做对了。

16023
26:33:00.854 --> 26:33:09.235
我要复制粘贴这两行const logger = Morales。Cloud。get logger logger。info。

16024
26:33:09.235 --> 26:33:26.919
我们写入If confirmed const active item = Morales。object。extend active item const query对于这个查询，我实际上要复制这些行因为这是完全相同的。

16025
26:33:26.955 --> 26:33:31.180
我们将寻找非ft地址、令牌ID和市场地址。

16026
26:33:31.180 --> 26:33:37.429
如果我们在我们的非ft。soul和到marketplace。som right和bot event中寻找非ft地址。

16027
26:33:37.429 --> 26:33:42.080
我们想要找到的令牌ID被列出来了。

16028
26:33:42.080 --> 26:33:43.580
我们会运行那个查询。

16029
26:33:43.580 --> 26:33:52.523
我们将const bots item = await query。first，我们将和之前做的一样。

16030
26:33:52.523 --> 26:34:27.429
如果bots项目，那么logger。info，删除请求点对象点获取对象ID等待购买项目点摧毁logger。info删除项目与开放ID请求点对象点获取开放ID地址请求点对象点获取地址。

16031
26:34:27.429 --> 26:34:30.344
如果我们没有找到，它会说else。

16032
26:34:30.344 --> 26:34:47.479
Logger点信息，没有找到地址请求对象点获取地址和token, Id请求对象点获取token Id。

16033
26:34:47.479 --> 26:34:47.806
酷。

16034
26:34:47.806 --> 26:34:49.051
看起来不错。

16035
26:34:49.051 --> 26:34:52.684
让我们把它上传到云端。

16036
26:34:52.684 --> 26:34:57.398
所以纱口云的变化上传正确。

16037
26:34:57.398 --> 26:34:59.709
让我们确保它在我们的服务器上看起来不错。

16038
26:34:59.709 --> 26:35:03.027
所以我们要给士气服务器一点刷新。

16039
26:35:03.027 --> 26:35:04.905
去这里的云功能。

16040
26:35:04.905 --> 26:35:07.820
我还能看到这个项目被取消了。

16041
26:35:07.956 --> 26:35:11.481
现在我可以看到保存完美后购买的项目。

16042
26:35:11.956 --> 26:35:13.432
就像我有百分之百的能力。

16043
26:35:14.956 --> 26:35:20.489
为了冷静思考，让它稍微刷新一下，看起来我们在上传了云功能后回到了原来的状态。

16044
26:35:20.489 --> 26:35:21.222
好的,很酷。

16045
26:35:21.222 --> 26:35:23.755
来测试这部分是否正常工作。

16046
26:35:23.956 --> 26:35:26.294
让我们继续，我们再写一个脚本。

16047
26:35:26.956 --> 26:35:28.165
乘以项·j s。

16048
26:35:28.165 --> 26:35:31.229
我们现在做同样的事情。

16049
26:35:31.956 --> 26:35:32.498
数据库。

16050
26:35:32.498 --> 26:35:34.599
我们没有任何有效的物品。

16051
26:35:35.956 --> 26:35:36.789
真正的快。

16052
26:35:36.789 --> 26:35:38.705
我们在薄荷和名单上。

16053
26:35:38.705 --> 26:35:39.955
造一个新的。

16054
26:35:40.956 --> 26:35:43.313
检查我们的数据库，我们会做一点刷新。

16055
26:35:43.956 --> 26:35:47.130
其中含有活性维生素，ID为2

16056
26:35:47.956 --> 26:37:10.094
是我们会买令牌ID会说const醚网络=需要罗汉const移动块=需要点削减跑龙套削减移动块const标记ID =异步函数逐项const非功能性测试市场=等待醚点得到合同NF T市场const基本NF T =等待醚点得到合同清单基本非功能性测试coms等于等待和英国《金融时报》的市场点得到清单基本NF T点地址和令牌ID会说const价格等于清单,价格字符串，我们会说const Tx这实际上是我们要买它等于await和ft marketplace。buy item basic n ft。address，令牌ID，逗号。

16057
26:37:10.094 --> 26:37:13.448
然后价值当然是价格。

16058
26:37:13.448 --> 26:37:19.290
做等待TX点等待一个，控制台点日志机器人NF t。

16059
26:37:19.290 --> 26:37:35.006
然后如果network。config。chain ID = 31337，那么await move blocks to comma, sleep amount = 1000。

16060
26:37:35.006 --> 26:37:40.317
当然，这是一个脚本，我们将使用与cancel相同的东西。

16061
26:37:40.317 --> 26:37:44.086
但它不会被取消，而是被item调用。

16062
26:37:44.086 --> 26:37:52.284
我们这里有一个非活动项目，我们运行yarn, art，按项目运行脚本。

16063
26:37:52.284 --> 26:37:55.693
. js Dash network, localhost。

16064
26:37:55.957 --> 26:37:58.090
现在我们可以测试是否购买该道具。

16065
26:37:59.957 --> 26:38:05.579
block，我们会在数据库上做一点刷新，我们会看到活动项消失了。

16066
26:38:05.579 --> 26:38:08.803
我们可以看到，这个物品现在已经被购买了。

16067
26:38:08.803 --> 26:38:09.418
太棒了。

16068
26:38:09.418 --> 26:38:14.612
我们几乎完成了活动项的保存，这是一个活动项的表。

16069
26:38:14.612 --> 26:38:16.034
但我们还有一件事要做。

16070
26:38:16.034 --> 26:38:17.161
我们不打算在这里测试。

16071
26:38:17.161 --> 26:38:28.845
但是如果你想测试它，我们可以在我们的非ft市场，去市场。Sol，我们实际上也有一个更新列表功能，它也允许一个项目被列出。

16072
26:38:28.845 --> 26:38:35.216
因此，我们还想检查所列出的项目是否来自更新监听。

16073
26:38:35.216 --> 26:38:44.315
回到我们的项目列表Cloud Function，在我们真正开始保存东西之前，我们想检查它是否已经存在。

16074
26:38:44.315 --> 26:38:51.450
我们会说我们会说const query = new mirallas。query。

16075
26:38:51.450 --> 26:38:55.398
抱歉，我一直在写活动项的sin。

16076
26:38:55.398 --> 26:38:58.361
我们要做我们一直在做的事。

16077
26:38:58.361 --> 26:39:00.351
我们会说query。= NFT。

16078
26:39:00.351 --> 26:39:44.208
地址，我们会寻找非ft地址request。object。get和ft地址，query。等于令牌ID, request那个对象。get令牌ID, query。等于市场，地址，逗号request。object。get Address query。等于seller requests。object。get seller会说const already listing item等于await query。first。

16079
26:39:44.208 --> 26:39:48.922
然后我们会说这个项目是否已经被列出了。

16080
26:39:48.922 --> 26:39:52.781
然后我们继续，写入logger。info。

16081
26:39:52.958 --> 26:40:00.827
删除已经列出的请求。对象。get对象ID。

16082
26:40:00.959 --> 26:40:06.441
我们会做一个已经列出的权重item。destroy。

16083
26:40:06.959 --> 26:40:35.518
然后执行logger。info, deleted item with token ID request。object。get token ID at address request。object。get address因为它已经被列出了，如果对象已经被列出了，我们知道它来自这个update listing函数。

16084
26:40:35.518 --> 26:40:40.039
我们先删除它，然后用新的价格重新保存它。

16085
26:40:40.039 --> 26:40:46.865
让我们继续，把这个上传到云纱线莫拉莱斯云。

16086
26:40:46.959 --> 26:40:50.883
上传这个到我们的服务器更改上传正确。

16087
26:40:50.959 --> 26:40:54.303
我们去检查一下服务器，稍微刷新一下。

16088
26:40:54.959 --> 26:40:56.991
检查云功能。

16089
26:41:00.959 --> 26:41:02.620
用于删除的现在在这里。

16090
26:41:04.959 --> 26:41:15.039
要使这个活动项目表始终只包含在市场上活动的项目，而不需要在应用程序中花费任何额外的资源。

16091
26:41:15.039 --> 26:41:24.039
这将对用户体验有更好的改善因为他们不需要支付额外的汽油来保存所有这些实体和数组或其他数据结构。

16092
26:41:24.039 --> 26:41:25.520
如果你已经走到这一步。

16093
26:41:25.520 --> 26:41:31.906
这很容易成为这门课最难的部分之一，因为我们要处理大量的技术。

16094
26:41:31.959 --> 26:41:37.451
我们正在使用智能合约，我们正在使用云功能，我们正在使用后端数据库。

16095
26:41:37.451 --> 26:41:41.391
如果你能走到这一步，你应该感到非常非常自豪。

16096
26:41:41.391 --> 26:41:46.594
现在让我们继续，让我们创造并列出另一个非ft。

16097
26:41:46.594 --> 26:41:54.353
我们会运行yarn heart在运行脚本，mint和列表网络本地主机将意味着它会列出它或睡觉。

16098
26:41:54.353 --> 26:41:55.730
我们去查一下数据库。

16099
26:41:55.730 --> 26:41:56.664
我们会进行刷新。

16100
26:41:56.664 --> 26:41:59.069
我们在这里看到了活动项目。

16101
26:41:59.069 --> 26:42:06.881
现在我们来学习如何调用活动项目数据库中的所有对象。

16102
26:42:06.960 --> 26:42:16.693
记住，如果你要重置你的本地区块链，你需要到这里来删除支持表中的所有行。

16103
26:42:16.960 --> 26:42:24.427
说了这么多，是时候回到我们的前端了，回到我们的index。J。

16104
26:42:24.427 --> 26:42:26.637
然后回答这个问题。

16105
26:42:26.637 --> 26:42:33.369
我们如何显示最近上市的NF t，我们只想显示市场上活跃的NF t。

16106
26:42:33.369 --> 26:42:42.531
现在我们有了一个系统只获取活跃的药物，只获取目前市场上的药物，因为我们要为这些事件建立索引。

16107
26:42:42.531 --> 26:42:44.864
现在，我要删除这里所有的注释。

16108
26:42:44.960 --> 26:42:45.744
我们来做这个。

16109
26:42:47.960 --> 26:42:49.681
这个叫做使用莫拉莱斯查询。

16110
26:42:50.960 --> 26:42:55.543
莫拉莱斯码头，有一个钩子叫使用莫拉莱斯查询。

16111
26:42:55.960 --> 26:43:00.826
这允许我们在React上下文中获取并查询数据库。

16112
26:43:00.826 --> 26:43:07.626
回到这里，我们会说，导入，使用Morales query从react mirallas。

16113
26:43:07.626 --> 26:43:14.878
现在，如果你看这里的文档，使用鼠标查询返回数据错误加载。

16114
26:43:14.960 --> 26:43:19.427
这将在索引弹出时自动运行这个查询。

16115
26:43:19.427 --> 26:43:29.262
为了从查询中获取数据从数据库中获取所有活动项，我们会说const data，并将data重命名为lists和fts。

16116
26:43:29.262 --> 26:43:33.993
然后我们还会检查这个查询是否还在取回。

16117
26:43:33.993 --> 26:43:44.175
因此我们写入isfetch然后我们将它重命名为fetinglistnftis = use Morales query。

16118
26:43:44.175 --> 26:43:53.403
在这里，它接受两个输入参数，它接受要进行搜索的表名然后它还接受一个函数或查询。

16119
26:43:53.403 --> 26:43:57.912
我们要找的表名是active item。

16120
26:43:57.961 --> 26:44:05.428
然后查询的函数是我们说query。我们把它限制为10。

16121
26:44:05.428 --> 26:44:13.468
我们只说前10个，我们按点降序来做，基于令牌ID。

16122
26:44:13.468 --> 26:44:21.896
如果我们想处理不同的页码，我们可以用。skip来处理页码，这里我们不打算处理页码。

16123
26:44:21.896 --> 26:44:23.568
所以我们现在就把它放在这里。

16124
26:44:23.568 --> 26:44:24.068
就是这样。

16125
26:44:24.068 --> 26:44:32.961
我们说，很好，从数据库中抓取活动项表，只抓取令牌ID降序排列的前10个。

16126
26:44:32.961 --> 26:44:38.544
现在它会把结果保存到nfts部分。

16127
26:44:38.544 --> 26:44:40.884
现在看看这是否有效。

16128
26:44:40.884 --> 26:44:48.697
让我们来做一些console。log列出ntf看看这个使用Ross查询的结果是什么。

16129
26:44:48.697 --> 26:44:56.199
现在我们有了本地区块链节点运行，我们有了到Morales服务器的连接，我们有了前端运行。

16130
26:44:56.199 --> 26:45:02.495
让我们到前端，我们在这里做一点刷新，我们右键点击，点击检查，我们会到控制台。

16131
26:45:02.495 --> 26:45:05.843
我们看到这个数组被输出到这里。

16132
26:45:05.843 --> 26:45:09.378
第一次console。logs时，它是空的。

16133
26:45:09.378 --> 26:45:14.716
这是因为当它最初从T中列出的加载还没有返回时。

16134
26:45:14.716 --> 26:45:16.914
它实际上是一个空数组。

16135
26:45:16.914 --> 26:45:24.212
但当它完成加载时，我们会得到一个大小为1的数组，我们会得到一个大小为1的数组，因为活动项目现在只有一个回车。

16136
26:45:24.212 --> 26:45:36.295
我们得到这个大小为1的数组，我们看到它的索引为0，我们有类名active item，我们有项目ID，我们有所有这些属性，这些都将在市场地址处创建。

16137
26:45:36.295 --> 26:45:43.598
如果地址，价格，卖家和令牌ID这就是我们在数据库中看到的。

16138
26:45:43.598 --> 26:45:44.290
如此完美。

16139
26:45:44.290 --> 26:45:48.273
这正是我们想要的能够在前端显示这些NF t。

16140
26:45:48.273 --> 26:45:51.673
那么我们如何显示这个非函数和列出这个非函数T呢?

16141
26:45:51.673 --> 26:46:01.502
对于那些不是开发人员也不打算去查看控制台。日志的人?我们要做的是在这里的return中，我们在它周围加一些括号。

16142
26:46:01.502 --> 26:46:05.131
首先，我们应该检查我们是否正在获取那些列出的NF T。

16143
26:46:05.131 --> 26:46:07.223
我们会做一些JavaScript的东西。

16144
26:46:07.223 --> 26:46:11.703
我们会说抓取列出的NF T我们会做一个三元运算符。

16145
26:46:11.703 --> 26:46:21.342
我们会说，如果我们要获取这些NF T，我们添加一个小div div表示加载完成，我们在这里放一个小冒号。

16146
26:46:21.342 --> 26:46:26.748
如果我们不取回，我们会说，listnfts。map。

16147
26:46:26.748 --> 26:46:37.349
点映射基本上是遍历并在所有列出的实体上做一些函数在我们想要做的函数中。

16148
26:46:37.349 --> 26:46:40.629
它会把每个NF t作为输入参数。

16149
26:46:40.629 --> 26:46:43.979
所以我们说我们基本上要循环通过每个NF T。

16150
26:46:43.979 --> 26:46:50.869
我们会说，console。log和ft。attribute attribute，加上S。

16151
26:46:50.963 --> 26:46:55.963
然后在这些里面在这些属性里面是我们想要的不同部分。

16152
26:46:55.963 --> 26:47:01.173
我们要得到这些块我们用const表示价格。

16153
26:47:01.173 --> 26:47:15.129
NFT地址，市场地址中的令牌ID，当然就是这个，然后卖家，这就是我们要在前端显示的所有信息它会说等于ntf。attributes。

16154
26:47:15.129 --> 26:47:20.108
我们会把这些拉出来，我们会看到price seller token ID，等等。

16155
26:47:20.108 --> 26:47:22.672
我们将把这些从ntf导属性中取出来。

16156
26:47:22.672 --> 26:47:26.897
我们可以用这个函数来表示，我们写上return。

16157
26:47:26.963 --> 26:47:30.338
然后返回一些HTML，比如div div。

16158
26:47:30.963 --> 26:47:47.439
我们可以说像价格，价格，价格，期间，和ft地址和ft地址，token ID, token ID卖家，然后出于某种原因添加这个。

16159
26:47:47.439 --> 26:47:53.748
出于某种原因，我要把前面加$1的符号删掉，保存。

16160
26:47:53.748 --> 26:48:01.878
现在如果我去到前端，我现在可以看到我们的非功能性金融的信息从我们的数据库列在这里。

16161
26:48:01.963 --> 26:48:02.749
这太棒了。

16162
26:48:04.963 --> 26:48:06.963
我们看到的是卖家的令牌ID。

16163
26:48:08.963 --> 26:48:13.454
市场，我们的小，我们的小硬帽MC市场，让我们再造一个。

16164
26:48:13.454 --> 26:48:20.816
纱线硬帽运行脚本mentalist Dash网络localhost，我们将运行它将铸造更多。

16165
26:48:20.816 --> 26:48:28.725
回到Morales数据库，对活动项目表做一点刷新，这里有了一个新项目。

16166
26:48:28.725 --> 26:48:32.839
如果我们回到我们的前端，我们给它一点刷新。

16167
26:48:32.839 --> 26:48:35.339
嘭，现在我们有了两项。

16168
26:48:35.339 --> 26:48:44.821
这太棒了，我们现在有了一种方法来显示我们市场上最近列出的NF t，加上。

16169
26:48:44.964 --> 26:48:49.259
当然，你可能会对自己说，嘿，帕特里克，这很酷。

16170
26:48:49.259 --> 26:48:51.472
但那看起来真的很丑。

16171
26:48:51.472 --> 26:48:53.258
我同意你的观点。

16172
26:48:53.258 --> 26:48:55.081
但是百分之百同意你的说法。

16173
26:48:55.081 --> 26:49:00.406
因此，我们应该想出一个组件来显示我们列出的实体，它看起来要好得多。

16174
26:49:00.406 --> 26:49:09.285
当我们不返回并打印出原始信息时，我们可能想要显示图像，我们想要显示图像，我们想让一切看起来更好。

16175
26:49:09.285 --> 26:49:14.830
所以我们要创建一个新组件我们要在这里返回它来适当地格式化我们所有的NF T。

16176
26:49:14.830 --> 26:49:20.794
我们将进入组件，我们将写入新文件，我们将调用nftbox。js。

16177
26:49:20.794 --> 26:49:26.229
这是我们要获取所有信息的地方关于如何显示我们的非功能性函数是什么样子的。

16178
26:49:26.229 --> 26:49:35.877
让我们开始处理实体框，我们会设置这个，我们设置这些的方法是export default function和ft box。

16179
26:49:35.964 --> 26:49:42.705
这里有一点不同，在我们的索引中，我们有所有这些信息。

16180
26:49:42.705 --> 26:49:48.385
我们需要把所有这些变量传递给我们的非ft Box组件。

16181
26:49:48.385 --> 26:49:52.071
为此，我们将把它们作为输入参数添加到组件中。

16182
26:49:52.071 --> 26:49:58.754
我们会说价格，如果地址，令牌ID，市场，地址和卖家。

16183
26:49:58.754 --> 26:50:04.610
现在在我们的前端，我们只有一大堆的文本，我们甚至有这个粗鄙的警告，我们要去掉这个提示。

16184
26:50:04.610 --> 26:50:13.261
我们知道，令牌有它们的令牌URI，它指向一个图像URI或实际令牌的图像URL。

16185
26:50:13.261 --> 26:50:20.698
我们要做的是调用那个令牌URI，然后调用图像URI来显示图像。

16186
26:50:20.698 --> 26:50:26.276
我们需要等这两个API请求才能得到实际图像。

16187
26:50:26.276 --> 26:50:31.352
我们将把这个图像保存为这个分量的状态函数。

16188
26:50:31.352 --> 26:50:35.981
如你所知，我们将使用use state来跟踪图像URI。

16189
26:50:35.981 --> 26:50:41.739
我们会像这样使用state from react。

16190
26:50:41.965 --> 26:50:50.320
在这里，我们说const image Uri，逗号set image Uri = use state。

16191
26:50:50.320 --> 26:50:53.794
我们会从一个空字符串开始。

16192
26:50:53.965 --> 26:51:01.706
现在我们来创建一个函数，我们将其命名为update UI来更新UI并获取这个令牌URI和图像URI。

16193
26:51:01.706 --> 26:51:05.817
我们会创建一个叫Update UI的异步函数。

16194
26:51:05.817 --> 26:51:17.534
为了先获取图像，我们需要获取令牌URI，然后使用令牌URI中的image ag获取图像。

16195
26:51:17.534 --> 26:51:20.626
首先我们要做的是获取令牌URI。

16196
26:51:20.626 --> 26:51:24.098
我们知道如何使用web3contract。

16197
26:51:24.098 --> 26:51:29.048
所以我们会做导入，使用web三合同从react Morales。

16198
26:51:29.048 --> 26:51:33.076
正如我们所知，通过合同使用网络需要一些参数。

16199
26:51:33.076 --> 26:51:42.605
我们说const run contract function, get令牌URI，等于，使用web through contract。

16200
26:51:42.605 --> 26:51:48.499
首先，我们需要NFT的ABI因为我们需要调用令牌URI。

16201
26:51:48.499 --> 26:51:51.919
为了得到ABI，我们需要再次更新我们的前端。

16202
26:51:51.966 --> 26:51:53.441
我们把这部分注释掉。

16203
26:51:54.966 --> 26:51:55.316
一块。

16204
26:51:55.316 --> 26:51:57.912
让我们看看部署脚本。

16205
26:51:58.966 --> 26:52:01.062
现在就更新前端。

16206
26:52:03.966 --> 26:52:04.490
对象的地址。

16207
26:52:04.490 --> 26:52:05.080
那很好。

16208
26:52:05.966 --> 26:52:08.353
在我们的前端添加API。

16209
26:52:09.966 --> 26:52:11.585
函数叫做Update API。

16210
26:52:12.966 --> 26:52:13.288
好。

16211
26:52:13.288 --> 26:52:16.352
我们会用async函数更新API。

16212
26:52:17.966 --> 26:52:24.621
基本的非ft API和非ft市场API，因为我们都需要它们。

16213
26:52:24.621 --> 26:52:31.860
我们写入const NF T, market = await ethers dot get contract。

16214
26:52:31.860 --> 26:52:39.299
在市场中，我们将写入ABI到前端API位置，我们有前端合同文件。

16215
26:52:39.299 --> 26:52:41.716
我们也来做一个const。

16216
26:52:41.716 --> 26:53:00.320
Front和ABI location等于。。/ next是Jas，如果T marketplace dash FCC /常量，我们不只是给出文件名，我们可以直接给出前端API位置。

16217
26:53:00.320 --> 26:53:06.778
然后我们会让它为我们生成那个文件因为我们会在任何时候覆盖ABI文件。

16218
26:53:06.778 --> 26:53:20.717
现在我们有了marketplace，我们只需要Fs。right file sync，还有front和ABI location, ft marketplace。JSON。

16219
26:53:20.717 --> 26:53:32.780
还有ft marketplace，。interface, format ethers。utils。format types。JSON。

16220
26:53:32.780 --> 26:53:35.515
对于基本的NF t我们也要这样做。

16221
26:53:35.515 --> 26:53:48.809
因此我们写入const basic NF t = await ethers。get contract basic NF t Fs。对吧?文件同步，也就是这个地方。

16222
26:53:48.809 --> 26:53:54.655
除了它将是一个不同的位置，它将是基本的NFT。JSON。

16223
26:53:54.655 --> 26:54:09.747
当然，我们会做一个逗号，基本的NFT，接口。format ethers。utils，点格式，类型。JSON，你可以在Hardhead文档中找到这个接口。

16224
26:54:09.747 --> 26:54:12.819
你可以在乙醚文档中找到这个。

16225
26:54:12.819 --> 26:54:15.441
现在我们有了这个更新ABI函数。

16226
26:54:15.441 --> 26:54:23.744
让我们把它添加到导出的模块中，这样我们就可以像这样对ABI进行加权。

16227
26:54:23.967 --> 26:54:25.458
这里有个连字符不应该出现在这里。

16228
26:54:25.967 --> 26:54:37.105
只是我们硬帽前端的这一部分，运行纱线，硬帽，部署破折号，破折号标签，这里的标签是前端，前端。

16229
26:54:37.105 --> 26:54:40.173
现在它没有什么需要编译更新前端了，它完成了。

16230
26:54:40.173 --> 26:54:49.483
如果我们回到我们的前端，现在我们去我们的常量，我们现在在这里看到两个对象，它们将是API的，基本的非函数函数，和非函数函数。

16231
26:54:49.483 --> 26:54:50.257
市场。

16232
26:54:50.257 --> 26:54:50.773
太棒了。

16233
26:54:50.967 --> 26:54:54.905
现在我们有了这些，我们可以把它们导入到前端。

16234
26:54:54.967 --> 26:55:06.568
我们可以说import, if T marketplace, abi from。。/常数/ NF T, market。JSON。

16235
26:55:06.568 --> 26:55:09.689
我们也可以得到NF T API。

16236
26:55:09.689 --> 26:55:17.394
我们会导入nft，从这个斜杠常数斜杠基本NF T。JSON。

16237
26:55:17.394 --> 26:55:23.891
现在在我们的run contract函数中，令牌URI函数是NFT API的一部分。

16238
26:55:23.968 --> 26:55:33.843
API将是NFT, abi，契约地址将是NFT的地址，我们将它作为参数传入。

16239
26:55:33.843 --> 26:55:47.905
我们会传递一个NF T地址，函数名是令牌URI, params是令牌ID，它会作为输入参数传递给这个函数，传递给这个组件。

16240
26:55:47.905 --> 26:55:48.280
正确的。

16241
26:55:48.280 --> 26:55:49.780
我们可以再检查一下。

16242
26:55:49.968 --> 26:55:55.381
我们对基本的NF T点灵魂很满意，对吧?向下滚动，我们有这个要重写的令牌URI。

16243
26:55:55.381 --> 26:55:59.039
这是我们要调用的函数，接受令牌ID。

16244
26:55:59.039 --> 26:56:02.015
我们要调用的函数接受令牌ID。

16245
26:56:02.015 --> 26:56:02.586
好了,好了。

16246
26:56:02.586 --> 26:56:09.671
在更新UI中，首先，我们说const，令牌URI = await令牌URI。

16247
26:56:09.671 --> 26:56:20.900
现在我们来做一个console。log令牌看看它会返回什么确保updatuui被调用，我们会把它添加到一个use effect中，我们说use effect。

16248
26:56:20.968 --> 26:56:26.001
这需要一个函数的输入参数，我们可以说Update UI。

16249
26:56:26.001 --> 26:56:32.240
我们只会让这个在任何时候运行当web 3启用更改时。

16250
26:56:32.240 --> 26:56:37.561
我们想运行updatuui，但我们希望它依赖于已启用的webthree。

16251
26:56:37.561 --> 26:56:42.397
然后我们说，如果它启用了web3，那么更新UI。

16252
26:56:42.397 --> 26:56:44.158
所以我们还需要增加使用效果。

16253
26:56:44.158 --> 26:56:48.104
我们用use state，逗号，use effect。

16254
26:56:48.104 --> 26:56:52.419
现在我们至少应该从区块链读取令牌URI。

16255
26:56:52.419 --> 26:56:57.445
我们还不打算设置图像，因为我们要从令牌神经元获取图像URI。

16256
26:56:57.445 --> 26:57:12.746
让我们把这个NFT框添加到我们的索引中，看看它在我们的索引中是否工作得很好。接下来，在顶部，我们将导入ntf框。

16257
26:57:12.746 --> 26:57:20.690
在下面这里，当我们返回时它会添加我们的NF T box组件会确保传入它所接受的所有参数。

16258
26:57:20.690 --> 26:57:24.461
价格等于JavaScript价格。

16259
26:57:24.461 --> 26:57:29.608
ft地址等于JavaScript实体地址。

16260
26:57:29.608 --> 26:57:42.175
令牌ID将等于令牌ID，市场地址将是市场地址卖家将是卖家。

16261
26:57:42.175 --> 26:57:49.313
你看到那个警告说，所有组件需要映射中的所有东西都需要有唯一的键。

16262
26:57:49.313 --> 26:57:52.193
我们会说key，我们也会给它们一个key。

16263
26:57:52.193 --> 26:58:00.169
我们会说key = this，我们会做一些字符串插值，我们会说NFT地址，加上令牌ID可以是key。

16264
26:58:00.169 --> 26:58:09.665
保存一下，回到我们的前端，做一点刷新，市场地址是未定义的市场地址。

16265
26:58:09.665 --> 26:58:16.346
让我们确保拼写正确，让我们回到前端，我们给它一个刷新3enabled是没有定义的。

16266
26:58:16.346 --> 26:58:21.773
不好意思，在非功能性的盒子里，我们需要从我们的莫拉莱斯那里抓取那个，所以我们将导入使用莫拉莱斯。

16267
26:58:21.773 --> 26:58:30.570
在ponents中我们会说const isweb3enabled = use Morales。

16268
26:58:30.570 --> 26:58:32.170
我们把它保存起来。

16269
26:58:32.170 --> 26:58:36.919
我注意到的一件事是这个需要用弯弯曲曲的东西包起来。

16270
26:58:36.970 --> 26:58:38.208
对不起，我忘记了。

16271
26:58:39.970 --> 26:58:41.418
道具，道具输入参数。

16272
26:58:42.970 --> 26:58:45.123
道具令牌ID来获取令牌ID。

16273
26:58:46.970 --> 26:58:50.901
通过在这里画上弯弯曲曲的括号。

16274
26:58:50.970 --> 26:58:52.103
把弯弯曲曲的括号放在这里。

16275
26:58:52.970 --> 26:58:55.749
控制台点日志标记，你的眼睛，或索引。

16276
26:58:56.970 --> 26:58:57.407
更新。

16277
26:58:57.407 --> 26:58:57.719
这里。

16278
26:58:57.719 --> 26:58:59.156
我们来保存一下。

16279
26:59:00.970 --> 26:59:03.183
web 3启用了UI。

16280
26:59:05.970 --> 26:59:07.451
前端，我们会做一点刷新。

16281
26:59:07.970 --> 26:59:09.747
一切都如预期般顺利。

16282
26:59:10.970 --> 26:59:13.170
在那个硬有localhost和我们的元掩码。

16283
26:59:13.970 --> 26:59:16.919
可以忽略这个错误，这个警告。

16284
26:59:16.970 --> 26:59:25.731
如果你点这个，你有你的IPFS和brave或你的IPFS同伴，我们现在能看到我们得到令牌URI，这很完美。

16285
26:59:25.731 --> 26:59:27.873
我们现在想要的是这个图像出价。

16286
26:59:27.970 --> 26:59:42.303
我用的这个是HTTPS，严格来说它不是去中心化的，我们需要它来自而不是HTTPS，我们需要来自IPFS冒号，斜杠，但实际上它是HTTPS IPFS。

16287
26:59:42.303 --> 26:59:42.469
io。

16288
26:59:42.469 --> 26:59:45.330
现在是好的，我们马上会解释为什么。

16289
26:59:45.330 --> 26:59:55.188
现在我们得到了令牌URI，我们可以调用这个URL，我们可以取回我们想要在前端显示的图像。

16290
26:59:55.188 --> 27:00:11.704
在这里，我们会做一个console。log，令牌URI是字符串插值，像这样，然后我们会说，if令牌URI，我们需要抓取这个令牌URI，从中获取图像。

16291
27:00:11.704 --> 27:00:14.145
这就是我们要做的有点古怪的事情。

16292
27:00:14.145 --> 27:00:15.625
我们要稍微作弊一下。

16293
27:00:15.625 --> 27:00:23.616
对于我们的应用程序，不是每个浏览器都有IPFS，不是每个浏览器都能兼容IPFS。

16294
27:00:23.616 --> 27:00:33.006
这里我们要稍微作弊一下，我们要把令牌Uriah从IPFS版本改成H HTTPS版本。

16295
27:00:33.006 --> 27:00:45.100
这被称为使用IPFS网关，它是一个服务器，将从一个普通的URL返回IPFS文件。

16296
27:00:45.100 --> 27:00:54.304
我们将使用IPFS网关，我们可以对它进行常规的HTTPS调用，它会返回那些IPFS文件。

16297
27:00:54.304 --> 27:00:57.771
所以从技术上讲，我们是让中央集权来做这个吗?是的。

16298
27:00:57.771 --> 27:00:59.237
这是理想的吗?不。

16299
27:00:59.237 --> 27:01:05.528
然而，在世界采用IPFS之前，在世界采用IPFS标准之前，这是我们现在必须要做的。

16300
27:01:05.528 --> 27:01:07.937
否则，前端就会显示为空白。

16301
27:01:07.971 --> 27:01:09.987
我们不能这样，我们不想这样。

16302
27:01:10.971 --> 27:01:25.691
const请求URL等于令牌URI点替换IPFS，斜杠斜杠与HTTP, HTTPS。

16303
27:01:25.971 --> 27:01:26.828
/ / ipfs。

16304
27:01:26.828 --> 27:01:27.363
io / ipf /。

16305
27:01:28.971 --> 27:01:31.740
以IPFS开头的令牌URI，这很好。

16306
27:01:32.971 --> 27:01:34.825
切换到使用IPFS网关。

16307
27:01:35.971 --> 27:01:40.889
IPFS网关由构建IPFS的团队提供。

16308
27:01:41.972 --> 27:01:43.972
可靠网关是一种逃避。

16309
27:01:43.972 --> 27:01:44.172
是的。

16310
27:01:44.972 --> 27:01:46.178
还在吗?ipf吗?是的。

16311
27:01:46.178 --> 27:01:48.273
所以这不是世界末日。

16312
27:01:48.972 --> 27:01:52.907
会让我们更容易调用这些API。

16313
27:01:52.972 --> 27:01:57.808
我们会说const令牌URI。

16314
27:01:59.972 --> 27:02:00.206
等待。

16315
27:02:00.206 --> 27:02:02.034
这有点奇怪。

16316
27:02:02.972 --> 27:02:04.222
两个等待。

16317
27:02:04.222 --> 27:02:09.597
等待一个权重获取请求，URL。JSON。

16318
27:02:10.972 --> 27:02:20.876
是一个关键字，你可以在JavaScript中使用它来获取URL获取关键字本质上是做同样的事情，像这样粘贴到浏览器中。

16319
27:02:20.876 --> 27:02:22.844
得到这个JSON响应。

16320
27:02:22.972 --> 27:02:24.402
所以我们等待得到答复。

16321
27:02:25.972 --> 27:02:26.987
响应JSON。

16322
27:02:26.987 --> 27:02:29.653
这就是我们得到切换响应的方式。

16323
27:02:29.972 --> 27:02:37.709
JavaScript中有了这个对象，这很完美因为这个对象有我们想要的图像属性。

16324
27:02:37.709 --> 27:02:44.125
和这里一样，我们会用IPFS网关，这个已经用HTTPS了。

16325
27:02:44.125 --> 27:02:44.278
io。

16326
27:02:44.278 --> 27:02:46.489
但如果它不是，我们仍然想要转换它。

16327
27:02:46.489 --> 27:02:48.782
现在我们要说const。

16328
27:02:48.782 --> 27:02:54.722
Image URI = token you are i response dot Image。

16329
27:02:54.722 --> 27:02:59.385
我们会得到这个响应的图像标签。

16330
27:02:59.385 --> 27:03:02.902
然后我们会说const。

16331
27:03:02.902 --> 27:03:18.022
imagururl等于，我们会做和上面一样的事情，我们会使用gateway imagururi。replace IPFS，冒号/斜杠/ HTTPS IPFS。

16332
27:03:18.022 --> 27:03:19.072
io / ipf。

16333
27:03:19.072 --> 27:03:23.743
这就是我们得到这个URL的方式。

16334
27:03:23.743 --> 27:03:30.706
最后我们可以把imageururi设置为那个imageurl。

16335
27:03:30.706 --> 27:03:35.515
现在我们有了图像URI就是这个图像。

16336
27:03:35.515 --> 27:03:37.396
这是不是有点不靠谱?是的。

16337
27:03:37.396 --> 27:04:05.343
有没有更好的方法可以做到这一点?是的,实际上有很多更好的方法,我们可以做一些,我们可以,因为我们使用的是莫拉莱斯,我们可以使图像在我们的服务器上,就叫我们的服务器,我们还能做什么,或测试网和维护路线实际上有一大堆像我们这样的非功能性测试平衡将向我们展示一个F TS告诉我们有多少NF T显示所有这信息NF T的但它只适用于测试网和主要网,我们会采用ipf的世界。

16338
27:04:05.343 --> 27:04:07.214
所以我们不需要进行包装。

16339
27:04:07.214 --> 27:04:09.544
不幸的是，它还没有那么像生活。

16340
27:04:09.544 --> 27:04:20.179
现在我们设置了图像，我们有了这个图像URI，我们有了它的实际样子，我们会有这个如果我们点这个，我们在浏览器中使用它，它会返回这个狗。

16341
27:04:20.179 --> 27:04:27.446
现在我们网站上有了图像URI，我们终于可以用它来展示它的样子了。

16342
27:04:27.446 --> 27:04:30.403
最后，我们可以在这里创建一个return。

16343
27:04:30.403 --> 27:04:33.295
下面，我们会返回一个div。

16344
27:04:33.295 --> 27:04:36.197
然后我们再做一个div，因为我想做。

16345
27:04:36.197 --> 27:04:41.160
我们可以用JavaScript写如果图像数组存在，我们会做一些事情。

16346
27:04:41.160 --> 27:04:43.472
否则，我们就做点别的。

16347
27:04:43.472 --> 27:04:46.989
如果它不存在，也许我们先做一个div。

16348
27:04:46.989 --> 27:04:49.908
Div上面写着loading。the。

16349
27:04:49.908 --> 27:04:56.661
如果它确实存在，我们会说，输入一个小div，关闭这个div。

16350
27:04:56.661 --> 27:04:58.747
我们就说找到了。

16351
27:04:58.747 --> 27:05:03.849
现在如果我们回到我们的前端，让我们看看我们是否做得好。

16352
27:05:03.974 --> 27:05:04.374
嗯嗯。

16353
27:05:07.974 --> 27:05:08.450
NF T。

16354
27:05:08.450 --> 27:05:09.323
好的,很酷。

16355
27:05:12.974 --> 27:05:15.593
终于有了我们可以用来显示NF T的URL。

16356
27:05:15.974 --> 27:05:17.552
想要真正使用它们。

16357
27:05:18.974 --> 27:05:25.826
组件叫做image组件，我们可以用它来很容易地渲染图像，只需要使用一个URI。

16358
27:05:25.826 --> 27:05:37.240
现在，因为我们要使用这个图像标签，因为它在后端做了一些优化，这意味着这个网站不能被部署到静态到静态网站，比如IPFS。

16359
27:05:37.240 --> 27:05:43.236
因为现在我们的网站需要一个服务器技术上来说，需要一个服务器因为我们有莫拉莱斯。

16360
27:05:43.236 --> 27:05:56.640
这可能是另一个原因，因为我们使用的是图像标签，我们不能将它静态部署到像IPFS这样的东西我们要在顶部，我们要从下一个斜杠图像导入图像。

16361
27:05:56.640 --> 27:06:12.107
我们会在下面这里我们会说，我们不会用created，而是用Image，我们也会在这里关闭它，我们会给一个加载器一个空白函数它只给我们图像URI。

16362
27:06:12.107 --> 27:06:14.006
不要太担心加载器。

16363
27:06:14.006 --> 27:06:17.906
现在，我们会说图像的源将是图像URI。

16364
27:06:17.906 --> 27:06:21.007
然后我们将它的高度设为200。

16365
27:06:21.007 --> 27:06:24.923
然后宽度也设为200。

16366
27:06:24.923 --> 27:06:29.380
如果我们做得对，保存之后，我们应该能在UI上看到图像。

16367
27:06:29.380 --> 27:06:35.198
所以我们回到我们的网站，哦，我的天，我们可以看到狗的天哪。

16368
27:06:35.198 --> 27:06:36.704
这真是令人兴奋。

16369
27:06:36.704 --> 27:06:41.700
我们可以看到小狗，我们可以看到图像，我们肯定在做一些事情，这真的很令人兴奋。

16370
27:06:41.700 --> 27:06:44.338
我知道我之前说过这不是CSS。

16371
27:06:44.338 --> 27:06:49.325
这不是一个格式化教程，因为那绝对不是我的专长。

16372
27:06:49.325 --> 27:06:51.775
不过，让我们把它做得好看一点。

16373
27:06:51.775 --> 27:06:59.506
我们还会用到，web3uitkit，因为web3uitkit有很多非常有用的工具。

16374
27:06:59.506 --> 27:07:08.991
如果我们到web3uikit，我们能到那个实时故事书另一个交互位，我们能向下滚动到调用了card的部分。

16375
27:07:08.991 --> 27:07:14.708
或者我们可以制作这些可点击的小卡片我们可以显示一些关于nfts的信息。

16376
27:07:14.708 --> 27:07:22.182
让我们继续，在顶部，我们会从web 3uitkit导入导入卡。

16377
27:07:22.182 --> 27:07:28.590
现在不只是显示图像，我们将像这样将图像包装在卡片中。

16378
27:07:28.590 --> 27:07:29.820
我们把它保存起来。

16379
27:07:29.975 --> 27:07:34.087
现在回到我们的前端，稍微刷新一下。

16380
27:07:34.975 --> 27:07:38.229
有了这种可点击的部分，看起来更好一些。

16381
27:07:38.229 --> 27:07:39.245
我们甚至会给它贴上标签。

16382
27:07:39.245 --> 27:07:42.100
我们甚至可以给它贴上标题和描述。

16383
27:07:42.100 --> 27:07:47.337
现在我们可以从令牌URI响应获取标题和描述。

16384
27:07:47.337 --> 27:07:54.128
在顶部，我们抓取令牌UI的标题和描述作为状态变量。

16385
27:07:54.128 --> 27:08:10.841
我们会说const，令牌名，set令牌名，等于use state，一开始为空，const令牌描述，那个令牌描述，等于use state。

16386
27:08:10.975 --> 27:08:17.120
从空白开始下载，我们调用这个updatuitbit，我们调用settoken name。

16387
27:08:17.120 --> 27:08:29.547
我们说name is token，你的response。name，我们说set token description，也就是token，你的response。description。

16388
27:08:29.547 --> 27:08:33.642
然后我们将在购物车中使用这些描述和标题。

16389
27:08:33.642 --> 27:08:43.090
我们说title =令牌名description =令牌描述。

16390
27:08:43.090 --> 27:08:44.190
保存。

16391
27:08:44.190 --> 27:08:45.957
我们来看看我们的前端。

16392
27:08:45.957 --> 27:08:47.467
给它一点新鲜感。

16393
27:08:47.467 --> 27:08:50.274
对了，现在我们有了NFT的名字。

16394
27:08:50.274 --> 27:08:51.925
和它的描述在我们的前端。

16395
27:08:51.925 --> 27:08:52.297
好的,很酷。

16396
27:08:52.297 --> 27:08:52.873
让我们继续。

16397
27:08:52.976 --> 27:08:56.500
我们还想要什么?我们可能想知道它的主人是谁。

16398
27:08:56.500 --> 27:09:02.925
我们会在card里面放一个div，也许我们会放一个令牌ID我们会写一个小数字。

16399
27:09:02.976 --> 27:09:05.809
使用令牌ID。

16400
27:09:05.976 --> 27:09:08.926
我们再画一个div，然后把它变成斜体。

16401
27:09:08.976 --> 27:09:11.320
我们说类名= italic。

16402
27:09:13.976 --> 27:09:14.652
要小。

16403
27:09:17.976 --> 27:09:20.507
我们作为输入参数传入的卖家。

16404
27:09:20.976 --> 27:09:23.492
也许在图片下面，我们想写上价格。

16405
27:09:23.976 --> 27:09:25.235
这里有一个小div。

16406
27:09:27.976 --> 27:09:32.588
然而，我们可能不希望它以人类可读的单位出现。

16407
27:09:32.588 --> 27:09:37.583
我们会输入ethers，我们会说import ethers from ethers。

16408
27:09:37.583 --> 27:09:50.874
然后我们不只是显示价格，而是用一点JavaScript这里我们用ethers。utils。format，单位，价格，价格和ether。

16409
27:09:50.976 --> 27:09:52.449
然后我们会做太空旅行。

16410
27:09:53.976 --> 27:10:01.330
类名等于字体加粗，所以我们可以读它在我们的市场上列出多少。

16411
27:10:01.330 --> 27:10:05.460
让我们回到高点我们可以看到，这是令牌ID 4。

16412
27:10:05.460 --> 27:10:10.681
我们可以看到它的主人，它的价格，还有更多关于狗的信息。

16413
27:10:10.681 --> 27:10:10.877
耶。

16414
27:10:10.977 --> 27:10:13.783
现在让我们把这些东西格式化得好看一点。

16415
27:10:13.977 --> 27:10:16.993
让我们把一个div里的内容再打包一个div。

16416
27:10:17.977 --> 27:10:19.649
比如类名将是flex。

16417
27:10:20.977 --> 27:10:26.262
格式化所有内容，我们将把所有内容放在一个列项目中，然后。

16418
27:10:26.262 --> 27:10:36.614
现在再看这里，就像在列中，再包装一个div，给它们一些填充，姓= P表示填充已经被添加了。

16419
27:10:36.614 --> 27:10:37.239
好了,好了。

16420
27:10:37.239 --> 27:10:42.813
然后回到下标，给下标添加一些格式。

16421
27:10:42.813 --> 27:10:48.910
我们的主函数，我们将删除styles。container，我们将写入container。

16422
27:10:48.977 --> 27:11:02.944
MX auto，我们在这里写一个h1，类名，等于，我用E X表示粗体字体，文本，XML。

16423
27:11:02.944 --> 27:11:13.215
这是最近列出的，然后我们再做一个div。

16424
27:11:13.215 --> 27:11:17.352
类，名称等于伸缩，伸缩包装。

16425
27:11:17.352 --> 27:11:22.215
我们将在这里结束关于JavaScript的div。

16426
27:11:22.215 --> 27:11:23.405
让我们看看UI。

16427
27:11:23.405 --> 27:11:24.892
我们来看看这是怎么回事。

16428
27:11:24.892 --> 27:11:25.451
好的,很酷。

16429
27:11:25.451 --> 27:11:26.823
让我们回到索引。

16430
27:11:26.977 --> 27:11:27.892
我们把这些东西都去掉。

16431
27:11:28.977 --> 27:11:29.738
这张卡。

16432
27:11:29.738 --> 27:11:30.785
让我们拯救。

16433
27:11:34.977 --> 27:11:40.147
能够开始倾听我们的NF t，然后让它们出现在我们的市场上，就像我们在这里看到的。

16434
27:11:40.147 --> 27:11:40.825
太棒了。

16435
27:11:40.825 --> 27:11:44.723
好的，如果我们去自述主页看看最近听空的。

16436
27:11:44.723 --> 27:11:47.863
天啊，这是我们签的支票。

16437
27:11:47.863 --> 27:11:52.332
我知道看起来工作量很大，但其中很大一部分是正确设置士气服务器。

16438
27:11:52.332 --> 27:11:57.299
因为我们有自己的后端，现在，我们有一些需要配置的后端服务。

16439
27:11:57.299 --> 27:12:00.692
但现在一切都准备好了，剩下的就简单了圣。

16440
27:12:00.692 --> 27:12:04.995
现在我们只需要显示连接到web 3的情况。

16441
27:12:04.995 --> 27:12:07.885
对吧?现在，如果我们点击这个，这个仍然会显示出来。

16442
27:12:07.885 --> 27:12:11.523
所以我们要把它更新一下。

16443
27:12:11.523 --> 27:12:13.068
在我们的指数中。

16444
27:12:13.068 --> 27:12:16.789
Js，我们现在检查取回。

16445
27:12:16.789 --> 27:12:23.617
听着，NF T就在那之前，对吧?在我们这样做之前，我们实际上想看看是否启用了web 3。

16446
27:12:23.617 --> 27:12:26.995
这是一些嵌套的三级运算。

16447
27:12:26.995 --> 27:12:31.639
如果web3是启用的，那么我们会做所有这些取回，这里列出了nft的东西。

16448
27:12:31.639 --> 27:12:33.748
我们什么都要在这里做。

16449
27:12:33.748 --> 27:12:42.863
如果它没有启用，我们写一个小div，写webthree，当前未启用。

16450
27:12:42.978 --> 27:12:46.437
当然，我们需要抓取iswebthree enabled。

16451
27:12:46.437 --> 27:12:59.774
我们会说，对于顶部我们会做const即threenabled = use oralis就像我们一直做的那样，我们会从react Morales中抓取use Morales，我们会保存它回到我们的前端，给它一点刷新。

16452
27:12:59.774 --> 27:13:02.043
如果我们连接起来，我们就能看到市场。

16453
27:13:02.043 --> 27:13:06.913
如果我们断开连接，我们会看到web 3目前没有启用，这是我们想要的。

16454
27:13:06.978 --> 27:13:07.415
完美的。

16455
27:13:07.415 --> 27:13:09.290
下面是自述文件。

16456
27:13:10.978 --> 27:13:11.878
更新清单。

16457
27:13:13.978 --> 27:13:15.896
实际上是这些实体的所有者。

16458
27:13:16.978 --> 27:13:18.758
对这个网站上的人来说很容易。

16459
27:13:19.979 --> 27:13:26.364
这个人的Metamask通过从鼠标上抓取帐户，所以我们做一个逗号帐户。

16460
27:13:26.364 --> 27:13:35.882
然后我们可以很容易地写const由user = seller = = = account拥有。

16461
27:13:35.882 --> 27:13:47.269
我们从合同中得到的卖家，我们从关联方那里得到的账户，如果卖家等于账户，没有卖家等于等于没有定义。

16462
27:13:47.269 --> 27:13:50.172
我们就说它们是你的。

16463
27:13:50.172 --> 27:14:06.093
现在我们不说由卖方所有，我们可以说const，格式化的卖方地址等于，我们做三元操作符会说如果它是由你开的，那么我们就说你而不是卖方。

16464
27:14:06.093 --> 27:14:07.929
否则，我们会说卖方。

16465
27:14:07.929 --> 27:14:11.282
现在我们说由格式化的销售者地址拥有，像这样。

16466
27:14:11.282 --> 27:14:15.792
如果我们回到我们的前端，我们做一点刷新。

16467
27:14:15.792 --> 27:14:19.733
根据用户的不同，你可能会看到所有者等等等等。

16468
27:14:19.733 --> 27:14:29.979
如果我到Metamask，把账户切换到账户3，连接到账户3，我们现在看到的是属于你的。

16469
27:14:29.979 --> 27:14:43.432
对，我们甚至可以再次切换，我们会再次切换帐户，我们会切换到帐户1，我们现在看到拥有，等等，等等，就像这样当我们来回切换时，这个直径实际上是变化的，这真的很烦人。

16470
27:14:43.432 --> 27:14:45.317
也许我们想更进一步。

16471
27:14:45.317 --> 27:14:49.179
我们要截断这个卖家地址让它变小一点。

16472
27:14:49.179 --> 27:14:52.312
我们想让卖家变小一点。

16473
27:14:52.312 --> 27:14:53.788
我们来创建一个新函数。

16474
27:14:53.788 --> 27:15:03.081
我们可以在export default函数外面创建这个因为这是一个不依赖于应用内部任何东西的函数。

16475
27:15:03.081 --> 27:15:04.606
它只是一个原始函数。

16476
27:15:04.606 --> 27:15:15.750
我们将创建。我们将它命名为const truncate string，这将是一个以完整字符串和字符串长度作为参数的函数。

16477
27:15:15.750 --> 27:15:20.776
我们会传递卖家地址以及这个字符串的长度。

16478
27:15:20.776 --> 27:15:31.115
这是我们要做的一个箭头函数，我们会说，如果所有string。length小于等于str Lang，返回完整的str。

16479
27:15:31.115 --> 27:15:37.265
否则，我们会说ra torx等于三个小点。

16480
27:15:37.265 --> 27:15:43.480
我们会说，让我们分离Tor的长度等于Sep。

16481
27:15:43.480 --> 27:15:45.730
Ra Tor点长度。

16482
27:15:45.730 --> 27:15:59.426
要设置分隔符长度，我们说const chars来表示字符串长度减去分隔符长度，我们说const。

16483
27:15:59.426 --> 27:16:16.130
前面的字符等于math。ceiling chars除以两个const后面的字符等于math。floor chars除以两个。

16484
27:16:16.130 --> 27:16:19.583
如果你不明白这个数学公式，不用担心。

16485
27:16:19.583 --> 27:16:33.963
然后我们会说，返回0到front字符的完整字符串子串加上SEP IRA tour加上完整的STR。子串。

16486
27:16:33.963 --> 27:16:38.747
完整的STR点长度，减去后面的字符。

16487
27:16:38.981 --> 27:16:55.896
现在我们能做的是抓取这个截断的STR这个截断的字符串for被格式化的seller会说如果它是，你仍然会做你否则我们会做截断的字符串卖方或空白，如果没有卖方，我们会让它的大小为15。

16488
27:16:55.896 --> 27:17:01.918
现在如果我们保存它，回到我们的前端，如果它属于你，它仍然会显示为你。

16489
27:17:01.981 --> 27:17:08.925
但如果我们切换帐户，现在说拥有，你知道，等等，等等，点，点，等等，加上一个删减的地址。

16490
27:17:08.925 --> 27:17:14.425
这些尺寸实际上不会改变，这比它们变大变小要好得多。

16491
27:17:14.425 --> 27:17:15.123
所以太棒了。

16492
27:17:15.123 --> 27:17:17.789
现在我们把它格式化得更好了。

16493
27:17:17.981 --> 27:17:29.997
好了，现在我们要做什么?好了，现在我们知道了谁拥有NFT, NFT的格式也非常好，我们需要想出一种方法来更新清单。

16494
27:17:29.997 --> 27:17:41.581
我们想做的是，如果它属于我们，我们可以切换回账户，它属于如果它属于我们，当我们点击它时，我们希望能够更新市场上的列表。

16495
27:17:41.581 --> 27:17:47.027
为此，我们要创建一个新组件Update listing ngModel。

16496
27:17:47.027 --> 27:17:54.888
我们会创建一个新组件，新文件，更新，列出ngmodel。

16497
27:17:54.888 --> 27:17:55.134
js。

16498
27:17:55.134 --> 27:17:58.821
ngModel会弹出来。

16499
27:17:58.821 --> 27:18:02.996
例如，这个弹出的小窗口叫做模态。

16500
27:18:02.996 --> 27:18:04.600
这就是我们想要建立的。

16501
27:18:04.600 --> 27:18:08.384
如果它属于我们，点这个时，我们希望它弹出这个模态。

16502
27:18:08.384 --> 27:18:20.084
开始之前，我们会对所有组件做同样的事情，export default function update, listing ngModel，像这样。

16503
27:18:20.084 --> 27:18:27.505
我们可能会想要从实体框传递这些参数，可能会想要传递这些参数。

16504
27:18:27.505 --> 27:18:31.876
所以ngModel知道它需要在非ft市场中调用什么函数。

16505
27:18:31.876 --> 27:18:39.403
更新listing的方法是调用这个update listing函数这里我们需要地址令牌ID和一些新的价格。

16506
27:18:39.403 --> 27:18:41.184
所以我们至少需要这些。

16507
27:18:41.184 --> 27:18:56.809
我们需要NFT地址，至少是令牌ID来让这个小弹出，我们不会自己编码它，我们将再次使用web three uikit, web three uikit有这个很好的弹出部分，它有一些代码来处理模态。

16508
27:18:56.809 --> 27:19:09.870
我们会从web3uitkit导入ngModel这是它看起来的样子我们有modal然后我们有所有这些关于modal的东西。

16509
27:19:09.870 --> 27:19:13.178
我们会做返回，做一个模态，像这样。

16510
27:19:13.178 --> 27:19:17.134
ngModel的关键之一是它是否应该是可见的。

16511
27:19:17.134 --> 27:19:24.151
它有一个isvisible标签，我们需要从空框中抓取。

16512
27:19:24.151 --> 27:19:31.548
我们也会在这里传递一点isvisible，在我们的NFT框中，我们需要告诉ngModel它什么时候是可见的。

16513
27:19:31.548 --> 27:19:34.093
我们一会儿就会写代码。

16514
27:19:34.093 --> 27:19:35.241
现在，它只会是空白的。

16515
27:19:35.241 --> 27:19:39.439
在ngModel内部，我们会给如何更新它一个输入字段。

16516
27:19:39.439 --> 27:19:46.604
我知道我们之前做过一些常规输入，因为我们通过uikit处理过web，让我们也使用它的输入。

16517
27:19:46.604 --> 27:19:48.696
我们在这里输入一个逗号。

16518
27:19:48.696 --> 27:19:52.304
在ngModel内部，我们会创建一个新的输入。

16519
27:19:52.304 --> 27:19:59.261
在输入字段中，我们会给它一个标签它会更新L货币的标价。

16520
27:19:59.261 --> 27:20:00.733
我们只做每个。

16521
27:20:00.733 --> 27:20:14.935
现在我们只是硬编码每个名字都是新的挂牌价格，类型将等于一个数字我们在这里做一个小反斜杠，哦，我们要做一个小反斜杠而不是像这样。

16522
27:20:14.935 --> 27:20:15.315
太酷了。

16523
27:20:15.315 --> 27:20:18.386
当这个模态弹出时，这里会有这个输入。

16524
27:20:18.386 --> 27:20:21.590
我们可以测试一下这是否有效。

16525
27:20:21.590 --> 27:20:29.120
我们可以将它导入到非ft框中，我们会导入，更新，列出ngModel。

16526
27:20:29.120 --> 27:20:38.260
从斜杠，更新，listing ngModel抱歉，这里不需要括号，在返回的顶部，就在我们的card将它添加进去之前。

16527
27:20:38.260 --> 27:20:40.352
我们再加一个div。

16528
27:20:40.352 --> 27:20:42.998
这样它们就可以发生相同的反应。

16529
27:20:42.998 --> 27:20:49.383
但我们会添加另一个div，我们会说Update listing ngModel，像这样，这里有一个反斜杠。

16530
27:20:49.383 --> 27:20:52.427
现在我们只需要通过是可见的。

16531
27:20:52.427 --> 27:20:55.411
现在，我们只会说true。

16532
27:20:55.411 --> 27:20:59.333
前端有了这个listing ngModel，我们做了一点刷新。

16533
27:20:59.333 --> 27:21:03.140
我们得到这个小框，像这个更新列表价格和一种货币。

16534
27:21:03.140 --> 27:21:04.876
我们必须关闭其中两个。

16535
27:21:04.983 --> 27:21:08.921
因为技术上来说我们现在两种模式都成立。

16536
27:21:08.983 --> 27:21:18.554
如果我们进行刷新，我们会得到这个小输入弹出这个小模式然后关闭它两次，因为我们有两个NF T如果这里有很多NF T，你需要关闭很多。

16537
27:21:18.554 --> 27:21:25.189
我们把它改成false，回到前端，做一点刷新，然后它就变成false了。

16538
27:21:25.189 --> 27:21:28.661
没错，保存，运行，它就在那里。

16539
27:21:28.661 --> 27:21:33.883
Gross, delete, delete, false, save前端，它已经不在那里了。

16540
27:21:33.883 --> 27:21:34.433
好的,很酷。

16541
27:21:34.433 --> 27:21:40.852
我们需要告诉这个ngModel只有当有人点击这个并拥有自己的茶时才会弹出。

16542
27:21:40.852 --> 27:21:45.250
为了切换这个，让它工作，我们需要更新纸牌。

16543
27:21:45.250 --> 27:21:55.951
每当我们点击我们的纸牌时，我们会创建一个叫做handle cardclick的函数handle cardclick会更新一个变量来决定我们是否应该显示这个ngModel。

16544
27:21:55.951 --> 27:22:04.896
我们会做的是，在点击牌时，也就是，一旦我们点击狗，我们会调用一些函数。

16545
27:22:04.896 --> 27:22:18.629
我们会说onclick = handle card click animal card click，我们会把它变成一个函数，我们会说const handle card click =一个函数，我们会用一些Arrow的东西。

16546
27:22:18.629 --> 27:22:26.871
然后我们会说，如果它是由用户拥有的，如果它是由用户打开的，我们会显示ngModel。

16547
27:22:26.871 --> 27:22:33.361
否则，我们将调用by item函数，因为我们希望重新呈现整个UI。

16548
27:22:33.361 --> 27:22:39.284
一旦我们改变，一旦我们改变变量来显示ngModel，我们会做这个作为US state。

16549
27:22:39.284 --> 27:22:42.584
我们写入const, show ngModel。

16550
27:22:42.584 --> 27:22:45.825
来一组，显示ngModel = use state。

16551
27:22:45.825 --> 27:22:49.734
然后我们开始时将它默认为false。

16552
27:22:49.734 --> 27:22:53.262
默认情况下，我们不会显示向下，这是我们想要的。

16553
27:22:53.262 --> 27:22:59.466
但如果它是用户所有的，我们会说设置Show ngModel为true。

16554
27:22:59.466 --> 27:23:07.301
然后else现在我们输入console。log，我们买之后会更新这个来绑定项目。

16555
27:23:07.301 --> 27:23:12.904
这里不是isvisible be false，而是isvisible = show ngModel。

16556
27:23:12.904 --> 27:23:13.864
或者显示ngModel。

16557
27:23:13.984 --> 27:23:14.359
变量。

16558
27:23:14.359 --> 27:23:14.921
好了,好了。

16559
27:23:16.984 --> 27:23:28.554
UI，我们右键点击，点击检查，如果我们拥有它，我们点击它，ngModel会弹出，我们可以点击它，点击另一个，但如果我们不拥有它，它会弹出。

16560
27:23:28.554 --> 27:23:31.542
所以如果我们切换账号，Connect也会切换。

16561
27:23:31.542 --> 27:23:33.494
我们点击它，什么也没发生。

16562
27:23:33.494 --> 27:23:43.207
如果我们去检查，到控制台，点击它，我们应该会看到。我们买弹出，这就是我们看到的，我们在这里刷新一下。

16563
27:23:43.207 --> 27:23:49.178
点击我们看到让我们买弹出，再次点击，让我们买点击让我们飞行员，为什么?不错,很酷。

16564
27:23:49.178 --> 27:23:51.065
现在我们有了这个ngModel的词。

16565
27:23:51.065 --> 27:24:11.509
为了正确显示，让我们切换回实际拥有这个非函数的人我们点击它，我们想要能够当我们点击确定，或者提交，我们想要发送一个交易来更新这个非函数的价格，所以我们能做的是在我们的输入中有一个标签叫on change equals这是每当这个更新时调用的函数。

16566
27:24:11.509 --> 27:24:15.568
我们会说onchange event是一个函数。

16567
27:24:15.568 --> 27:24:25.348
我们会创建一个名为setprice的函数来更新listingwithevent。target。value。

16568
27:24:25.348 --> 27:24:29.307
我们想要记录我们在这里放入的东西。

16569
27:24:29.307 --> 27:24:32.951
当我们调用函数更新价格时，它已经自动有了。

16570
27:24:32.985 --> 27:24:39.467
我们将创建这个函数而event。target。value将是输入框中的任何东西。

16571
27:24:39.467 --> 27:25:01.902
我们会创建这个set price来更新列表将它设为使用日期因为我们想要基于这个来改变UI因此我们会说const price to update listwithcomma set price to update listing with equals use state然后我们会让它开始时为0或为空。

16572
27:25:01.902 --> 27:25:05.938
那么现在，无论这里的是什么都会被这个更新。

16573
27:25:05.938 --> 27:25:18.297
现在我可以做我们的console。log价格更新列表回到前端，我们需要导入使用状态导入，使用状态从反应。

16574
27:25:18.297 --> 27:25:23.886
回到前端，点击这个，右键点击检查。

16575
27:25:23.986 --> 27:25:26.562
第一类，我们看到114，我们看到14。

16576
27:25:27.986 --> 27:25:29.173
控制台点日志。

16577
27:25:31.986 --> 27:25:36.936
这个函数就是我们碰到这个时调用的函数，等等。

16578
27:25:36.936 --> 27:25:49.401
它将等于一个函数，我们将使用一个小箭头符号，我们将调用那个更新列表函数在区块链上，我们需要抓取那个函数以便使用它。

16579
27:25:49.401 --> 27:25:57.282
要使用那个函数，我们会从react mirallas导入use web3contract。

16580
27:25:57.282 --> 27:26:07.379
作为一个新的钩子，我们说const run合约函数Update listing，等于use webthree合约。

16581
27:26:07.379 --> 27:26:12.936
这将是我们在非金融市场上调用的一个函数。

16582
27:26:12.936 --> 27:26:22.534
ABI将是非ft市场API，我们可以通过导入得到它，类似于我们在这里做的。

16583
27:26:22.534 --> 27:26:26.017
我们只需要从非ft框中复制粘贴。

16584
27:26:26.017 --> 27:26:40.760
我们会从。。constant导入非ft集市API将JSON发送到集市，我们需要合约地址，这将是更新列表ngModel的输入参数。

16585
27:26:40.760 --> 27:26:53.987
我们甚至可以做一个逗号marketplace地址，复制这里的这个地方，这意味着在我们的NFT框中，很快，我们将把所有这些变量传递给它，但我们马上会保存它。

16586
27:26:53.987 --> 27:27:03.602
NFT市场地址，市场地址函数名，将是Update，列在智能合约中，然后是params。

16587
27:27:03.602 --> 27:27:25.642
如果我们到这里，我们有更新列表取非ft地址令牌ID新价格做非ft地址，这将是非ft地址，我们说令牌ID将是令牌ID新价格你的价格将从价格更新列表中得到但将它从人类可读转换为醚。

16588
27:27:25.642 --> 27:27:29.802
所以我们从醚中导入醚。

16589
27:27:29.802 --> 27:27:44.422
新的价格将是ethers。utils。parse ethers或ether price来更新列表如果它是空的，我们就说or 0。

16590
27:27:44.422 --> 27:27:51.936
我们有NFT地址令牌ID市场地址在我们的NFT框中，我们需要在这里传递那些参数。

16591
27:27:51.987 --> 27:28:03.415
我们有isvisible，我们还有令牌ID，它将等于令牌ID，市场地址将等于市场地址。

16592
27:28:03.415 --> 27:28:08.487
NFT地址将等于NFT地址。

16593
27:28:08.487 --> 27:28:15.748
当我们编码和测试这个的时候这很烦人，因为这对我来说很烦人让我们刷新一下网站。

16594
27:28:15.748 --> 27:28:17.715
如果我们点击它，这个东西就会弹出。

16595
27:28:17.715 --> 27:28:21.209
但当我点X，点这个，还是没有显示。

16596
27:28:21.209 --> 27:28:26.246
这是因为从技术上讲，show ngModel现在仍然为真，即使我们退出了。

16597
27:28:26.246 --> 27:28:45.083
我们要在NFT框中做的是在我们的更新列表ngModel中我们也会在关闭时将它传递进来，我们会传递给它一个隐藏的ngModel变量这是我们将要创建的，在Show ngModel Set Show ngModel下面我们会创建const Eid ngModel。

16598
27:28:45.083 --> 27:28:51.665
这是一个函数，它会说set, show modal。

16599
27:28:51.665 --> 27:28:57.552
如果是false，我们将把这个函数传递给update模态列表。

16600
27:28:57.552 --> 27:29:00.455
我们在Close处用逗号。

16601
27:29:00.455 --> 27:29:05.445
在我们的模式中，我们会说，on Close。

16602
27:29:05.445 --> 27:29:17.925
On，取消，我们会调用它On close function，或者On close button pressed，我们也会调用它On close function。

16603
27:29:17.988 --> 27:29:29.670
如果我们刷新网站，点击这个模态就会弹出，点击X，再点击一次，它就会弹出，因为现在我们正确地将它设为假然后将它重置为真。

16604
27:29:29.670 --> 27:29:40.428
现在要发送这个更新列表函数，我们要传递另一个东西，另一个变量，我们要传递它，它也会是一个函数。

16605
27:29:40.428 --> 27:29:44.254
它会调用我们刚创建的updatlisting。

16606
27:29:44.254 --> 27:29:47.375
现在，添加一个On错误总是一个好主意。

16607
27:29:47.375 --> 27:29:54.854
我们会说on error，把这个error作为一个函数和console。log。

16608
27:29:54.988 --> 27:30:01.750
错误和这个需要用括号括起来，但是合同地址是错误的。

16609
27:30:01.750 --> 27:30:09.575
所以我们要写这份合同，合同地址并拼写正确。

16610
27:30:09.575 --> 27:30:11.747
拼写正确。

16611
27:30:11.989 --> 27:30:14.939
现在回到UI，给它一点刷新。

16612
27:30:14.989 --> 27:30:16.864
单击，这将添加一个。

16613
27:30:16.864 --> 27:30:18.973
我们看到Metamask出现了。

16614
27:30:19.989 --> 27:30:20.989
效果很好。

16615
27:30:22.989 --> 27:30:23.881
会吓坏的。

16616
27:30:24.989 --> 27:30:28.726
很棒的应用就这样出现了，这很好。

16617
27:30:28.989 --> 27:30:33.284
有这个小错误处理，我想为所有这些运行契约函数添加这个。

16618
27:30:33.284 --> 27:30:35.579
让我们再来谈谈成功。

16619
27:30:35.579 --> 27:30:42.560
当这个成功通过时，我们会调用一个函数叫作handle update，列出成功。

16620
27:30:42.560 --> 27:30:46.284
这是一个当它正确通过时我们会调用的函数。

16621
27:30:46.284 --> 27:30:48.609
在顶部，我们创建这个新函数，我们设为const。

16622
27:30:48.609 --> 27:30:54.655
处理更新，监听成功将是一个使用箭头语法的新函数。

16623
27:30:54.655 --> 27:30:59.639
我们会让这个为一个web应用程序设置一个新的通知。

16624
27:30:59.639 --> 27:31:09.389
要做通知，我们会使用web3uitkits使用通知，这和我们上一个使用的通知服务是一样的。

16625
27:31:09.389 --> 27:31:13.682
在上面这里，我们会导入它，使用通知。

16626
27:31:13.682 --> 27:31:20.368
然后我们会说，在我们的组件中，我们会说const, dispatch = use notification。

16627
27:31:20.368 --> 27:31:24.623
因为我们在应用中使用通知。

16628
27:31:24.623 --> 27:31:26.654
Js，我们必须把它导入这里。

16629
27:31:26.654 --> 27:31:32.150
我们会从web3uitkit导入通知提供者。

16630
27:31:32.150 --> 27:31:44.871
在Morales提供程序内部，我们会在header和组件周围添加通知提供程序，这样我们就有了相关的上下文。

16631
27:31:44.990 --> 27:31:54.227
在我们的句柄更新列表success中，这个函数会说dispatch，说type将是success。

16632
27:31:54.227 --> 27:32:07.561
消息将被更新，标题将被更新，请刷新，请刷新和移动块。

16633
27:32:07.561 --> 27:32:10.132
然后是位置。

16634
27:32:10.132 --> 27:32:11.615
右上方。

16635
27:32:11.615 --> 27:32:17.240
然后我们再讨论衣服，再讨论衣服。

16636
27:32:17.240 --> 27:32:23.679
我们会说set price to update listing with back to 0。

16637
27:32:23.679 --> 27:32:25.735
我还会在以后编辑一下这个。

16638
27:32:25.735 --> 27:32:31.056
我意识到我忘了给很多句柄函数添加TX。

16639
27:32:31.056 --> 27:32:38.723
当我们调用这些运行契约函数时，就像我们说的，他们在onsuccess中有这个。

16640
27:32:38.723 --> 27:32:46.406
现在这个onsuccess自动地将调用的结果传递给那里的任何回调函数。

16641
27:32:46.406 --> 27:32:55.610
例如，上面的列表返回一个事务，我们将把该事务传递给添加到onsuccess的任何东西。

16642
27:32:55.610 --> 27:33:00.168
在这里，你可以让它有一个事务作为输入参数。

16643
27:33:00.168 --> 27:33:04.974
这个交易将会在区块链上更新价格。

16644
27:33:04.974 --> 27:33:09.891
我们想把它从常规函数改成异步函数。

16645
27:33:09.891 --> 27:33:18.580
我们可以用await TX。Wait, 1，因为我们不想说，成功，在事务执行之前，列表已经更新了。

16646
27:33:18.580 --> 27:33:20.892
所以我们希望首先进行事务处理。

16647
27:33:20.991 --> 27:33:34.635
然后我们想弹出调度说，嘿，它通过了然后另外，当我们在onsuccess上调用这些模型时，我们通过引用函数的名字把它们传递进来。

16648
27:33:34.635 --> 27:33:45.829
我们不再使用箭头语法，像这样，我们只说，嘿，onsuccess将是这个，把你的结果传递给它。

16649
27:33:45.829 --> 27:33:48.667
这就是我们在下面的称呼。

16650
27:33:48.667 --> 27:33:53.406
如果你看与此相关的GitHub回购，你会进入组件，我们会进入这些。

16651
27:33:53.406 --> 27:33:57.680
在这个视频中，我忘了加上await TX。wait 1。

16652
27:33:57.680 --> 27:33:59.925
但在GitHub回购中，我们有这些。

16653
27:33:59.925 --> 27:34:06.991
我在视频中演示的时候，调度会在事务完成之前弹出。

16654
27:34:06.991 --> 27:34:09.391
我想让你们知道，回到视频。

16655
27:34:09.391 --> 27:34:13.885
当我们成功时，会弹出一个成功的小窗口。

16656
27:34:13.885 --> 27:34:27.313
另一件事是，当我们调用这个时，我们会省略Morales仪表板中列出的一个项目，价格实际上应该在活动项目中更新因为我们的云功能。

16657
27:34:27.313 --> 27:34:30.184
现在我们把这些都放在一起。

16658
27:34:30.184 --> 27:34:31.861
所以我们在前端。

16659
27:34:31.991 --> 27:34:35.429
如果你拥有的市场会点击它。

16660
27:34:35.991 --> 27:34:37.249
清单至25。

16661
27:34:41.991 --> 27:34:49.591
我们将继续并确认并运行一个错误因为我们需要点击Metamask，我需要重置我的帐户。

16662
27:34:49.591 --> 27:34:54.879
我要设置，高级重置账户。

16663
27:34:54.991 --> 27:35:05.955
Metamask又弹出来了，我们要确认它关闭了，弹出模式，我们得到了我们的小通知。

16664
27:35:05.955 --> 27:35:14.942
我们可以看到一个活动，事务已经完成，我们到活动项，给它一点刷新。

16665
27:35:14.992 --> 27:35:18.106
现在我们看到我们的item列出了事件。

16666
27:35:19.992 --> 27:35:21.458
这还没有得到证实。

16667
27:35:23.992 --> 27:35:26.242
我们需要把积木移动1个。

16668
27:35:26.992 --> 27:36:09.942
我们会创建一个新脚本，一个叫做Mind。Jas的新文件，只移动我们的block一次，我们会说const move blocks，等于require。/ utils / / move blocks，我们会说const blocks等于const sleep amount等于1000 async function mine, do await move blocks将do blocks作为参数然后sleep sleep amount将等于sleep amount。

16669
27:36:09.942 --> 27:36:12.499
这将是一个脚本。

16670
27:36:12.499 --> 27:36:18.280
所以我们要添加复制粘贴和我这里做的语法一样。

16671
27:36:18.280 --> 27:36:21.680
现在我们要挖掘这两个区块。

16672
27:36:21.680 --> 27:36:26.155
所以我们将运行纱线，美术和脚本。

16673
27:36:26.155 --> 27:36:30.753
注意Jas dash dash网络，本地主机。

16674
27:36:30.753 --> 27:36:34.468
所以我们要在这两个街区开矿。

16675
27:36:34.468 --> 27:36:53.135
现在回到数据库，回到活动项目，我们可以看到它被更新了因为在我们列出的项目中，2500事件现在是一个已确认的交易，我们可以确认它们很好。

16676
27:36:53.135 --> 27:36:58.796
这意味着，既然它已经在我们的前端确认了，我们将给它一点刷新。

16677
27:36:58.796 --> 27:37:03.386
我们可以看到这只幼崽现在每只价值25英镑。

16678
27:37:03.386 --> 27:37:04.304
太棒了。

16679
27:37:04.304 --> 27:37:07.381
我们在更新ngModel，它运行得很好。

16680
27:37:07.381 --> 27:37:08.145
优秀的工作。

16681
27:37:08.145 --> 27:37:09.670
现在我们来看自述文件。

16682
27:37:09.670 --> 27:37:13.362
如果您拥有NFT，则可以更新清单。

16683
27:37:13.362 --> 27:37:15.408
这是一个勾号。

16684
27:37:15.408 --> 27:37:16.484
太好了。

16685
27:37:16.484 --> 27:37:21.459
接下来，我们想让它做什么?如果你不拥有它，你可以买下它。

16686
27:37:21.459 --> 27:37:30.343
好，回到我们的网站，把用户切换到另一个账户，我们可能需要一个拥有一些钱的账户。

16687
27:37:30.343 --> 27:37:39.484
让我们继续，在我的账户之间转账给另一个账户，我们每人汇100到账户1，确认在我们的安全帽链上。

16688
27:37:39.484 --> 27:37:40.221
好了,好了。

16689
27:37:40.221 --> 27:37:43.760
现在我们可以转到1号账户，我们各有100元。

16690
27:37:43.760 --> 27:37:44.402
好了,好了。

16691
27:37:44.402 --> 27:37:46.721
这些棒棒糖，每只不到100块。

16692
27:37:46.721 --> 27:37:49.659
这对我们来说足够测试了。

16693
27:37:49.659 --> 27:37:50.897
让我们回到这个盒子。

16694
27:37:50.993 --> 27:37:58.680
因为我想我们说过，我们做了一个手柄card click，如果它属于用户，就会弹出模式。

16695
27:37:58.680 --> 27:38:01.659
如果没有，我们用by函数。

16696
27:38:01.659 --> 27:38:07.009
要做by函数，我们要做另一个run合约函数。

16697
27:38:07.009 --> 27:38:14.605
我们用const run合约函数，按项调用这个。

16698
27:38:14.605 --> 27:38:18.596
而这将等于使用web三合同。

16699
27:38:18.596 --> 27:38:23.151
这将是非金融市场的ABI。

16700
27:38:23.151 --> 27:38:30.450
API，合同地址将是市场地址。

16701
27:38:30.450 --> 27:38:41.877
函数名将是按项的，消息值将是非函数的价格。

16702
27:38:41.994 --> 27:38:44.502
因为我们需要汇款来购买物品。

16703
27:38:44.994 --> 27:38:51.265
params将是非ft地址，这将是非ft地址。

16704
27:38:51.265 --> 27:39:02.089
令牌ID，也就是令牌ID现在我们在句柄cardclick上有了这个by item，我们可以说，show ngModel为true。

16705
27:39:02.089 --> 27:39:05.119
否则，我们会按项调用。

16706
27:39:05.119 --> 27:39:07.837
我们将在直播中进行。

16707
27:39:07.837 --> 27:39:14.061
Air会是一个函数我们会用console。log Air和onsuccess。

16708
27:39:14.061 --> 27:39:20.522
这是一个调用handle by item success的函数。

16709
27:39:20.522 --> 27:39:29.633
我们会在处理过的推车下面创建一个新的处理程序点击const handled by item success = a function。

16710
27:39:29.633 --> 27:39:33.739
对于这个，我们还会让它做一个小通知。

16711
27:39:33.739 --> 27:39:41.354
再一次，我们将导入我们将从web通过UI kit导入use notification。

16712
27:39:41.354 --> 27:39:44.354
我们要说的是const。

16713
27:39:44.354 --> 27:39:47.851
分派等于使用通知。

16714
27:39:47.851 --> 27:39:50.422
然后在处理的项目成功。

16715
27:39:50.422 --> 27:39:56.377
我们会说调度类型，成功。

16716
27:39:56.377 --> 27:39:57.843
消息。

16717
27:39:57.843 --> 27:40:00.043
项目购买。

16718
27:40:00.043 --> 27:40:05.822
标题也将购买的项目。

16719
27:40:05.822 --> 27:40:12.304
那么杆位就在右上方就这样。

16720
27:40:12.304 --> 27:40:18.042
handle cardclick，如果他们拥有它，我们会显示更新清单ngModel。

16721
27:40:18.042 --> 27:40:20.595
如果他们还没有拥有它，总有人会买的。

16722
27:40:20.595 --> 27:40:21.695
我们回到这里。

16723
27:40:21.695 --> 27:40:24.776
我现在的账户不拥有这些NF T。

16724
27:40:24.776 --> 27:40:26.137
让我们继续点击它。

16725
27:40:26.137 --> 27:40:29.351
我们的超面具确实出现了25次。

16726
27:40:29.351 --> 27:40:32.047
太贵了。

16727
27:40:32.047 --> 27:40:40.280
我们来确认商品已经被购买，点击那个小x，进入元掩码，交易正在等待中。

16728
27:40:40.280 --> 27:40:41.851
它通过了。

16729
27:40:41.995 --> 27:40:43.167
这太棒了。

16730
27:40:45.995 --> 27:40:49.732
最近列出的NF T如果没有，你可以更新列表。

16731
27:40:49.995 --> 27:40:51.395
没有，你可以买到。

16732
27:40:52.995 --> 27:40:53.461
页面。

16733
27:40:59.995 --> 27:41:07.677
让我们得到这个单元格页面，让我们得到这个完成页面，我们有我们的单元格非ft页面，它现在什么都不做。

16734
27:41:07.677 --> 27:41:11.927
在我们的前端，我们到这里，这里没有很多。

16735
27:41:11.995 --> 27:41:16.902
实际上，你可以在市场上列出你的非功能性资产，我们还需要添加提取收益。

16736
27:41:16.902 --> 27:41:18.194
所以我没有加上这个。

16737
27:41:18.194 --> 27:41:22.029
但这可能也是我们希望允许人们去做的事情。

16738
27:41:22.029 --> 27:41:23.373
我们从这里开始。

16739
27:41:23.373 --> 27:41:27.302
我们可以去掉这个头部的东西现在我们把它添加到主页上了。

16740
27:41:27.302 --> 27:41:36.822
要提交一个新的NFT，我们可能需要一个空格来添加实体地址NFT的令牌ID等等。

16741
27:41:36.822 --> 27:41:43.392
我们需要一个表单来做这个，你猜怎么着，我们也可以通过UI kit从web获取一个表单。

16742
27:41:43.392 --> 27:41:52.642
我们将继续在单元格NMC页面中，我们将从web3uitkit导入表单。

16743
27:41:52.642 --> 27:41:57.241
我们将在单元格页面中创建一个新表单。

16744
27:41:57.241 --> 27:42:12.962
我们可以添加到表单中的参数，同样可以在文档中找到，或者我们将添加一个主要部分就是这个数据块，它是一个对象里面有一个列表，所有不同的字段，我们可以放入表单中。

16745
27:42:12.962 --> 27:42:17.329
也许我们会做第一个有一个非ft地址的名字。

16746
27:42:17.329 --> 27:42:28.168
它的类型是text，不好意思，这些都是这是一个对象的列表。

16747
27:42:28.168 --> 27:42:35.635
现在，如果我们保存它，回到单元格页面，我们能看到一个空地址和一个小小的Submit按钮。

16748
27:42:35.635 --> 27:42:37.749
那现在什么都做不到。

16749
27:42:37.749 --> 27:42:48.496
我们有一个非ft地址，它会有一个文本，也许我们也会在英尺宽为50%的情况下让起始值为空。

16750
27:42:48.496 --> 27:43:06.307
这个的键将是NFT地址，我们还需要什么呢，我们需要给它一个令牌ID我们会说name，令牌ID, type将是一个数字值，开始时它是空的。

16751
27:43:06.307 --> 27:43:11.946
这个的键是令牌ID。

16752
27:43:11.946 --> 27:43:15.757
接下来，我们需要知道价格。

16753
27:43:15.757 --> 27:43:18.804
我们说name will be price。

16754
27:43:18.996 --> 27:43:19.773
容易的。

16755
27:43:19.773 --> 27:43:24.440
类型将是一个数字，值将为空。

16756
27:43:25.997 --> 27:43:26.797
将是价格。

16757
27:43:29.997 --> 27:43:33.679
删除第二个，让它用一个标签自动关闭。

16758
27:43:33.997 --> 27:43:41.617
然后在这里，我们会写title = sell your NF T ID = main form。

16759
27:43:41.617 --> 27:43:42.168
太酷了。

16760
27:43:42.168 --> 27:43:48.925
所以现在我们可以取一个空地址、一个令牌ID和一个标题为cellular NFT的新价格。

16761
27:43:48.997 --> 27:43:50.447
太好了，看起来真不错。

16762
27:43:51.997 --> 27:43:56.130
任何事情，我们可能想给它功能来做一些事情。

16763
27:43:56.130 --> 27:44:01.770
我们会在Submit上，然后我们需要创建一个新函数来列出NF - T。

16764
27:44:01.770 --> 27:44:10.913
所以我们要创建一个叫做批准和列表的函数，我们必须批准我们的市场，从我们的钱包中取出非功能性产品。

16765
27:44:10.997 --> 27:44:26.013
我们要创建一个新函数，一个同步函数approven list，它会在表单上取一个数据输入参数，当我们点击submit时，它会自动将这个数据对象传递给approved list函数。

16766
27:44:26.013 --> 27:44:32.292
这就是我们获取地址值令牌ID值和价格值的方法。

16767
27:44:32.292 --> 27:44:44.234
在async函数approven list中，doconsole。log，审批契约，非ft地址将来自这个数据对象。

16768
27:44:44.234 --> 27:44:56.877
所以它将是data。data在索引0处，或者0 with object这里将是我们的地址，输入结果。

16769
27:44:56.997 --> 27:45:00.857
令牌ID等于data。data。

16770
27:45:01.998 --> 27:45:07.901
同样，这个将是我们的令牌ID输入结果。

16771
27:45:07.998 --> 27:45:23.498
然后价格将等于ethers。utils。data。data的解析单位与输入结果，逗号ether。

16772
27:45:23.498 --> 27:45:24.398
字符串。

16773
27:45:24.398 --> 27:45:28.398
这就是每单位的价格。

16774
27:45:28.398 --> 27:45:33.670
在人类可读的形式中，我们将把它转换为Aetherium可读的形式。

16775
27:45:33.670 --> 27:45:39.722
然后我们将它作为字符串传递因为这返回一个大数字，这是我们不想要的。

16776
27:45:39.722 --> 27:45:58.283
我们有了NFT地址，令牌ID和新列表的价格，我们现在能做的是我们可以说const approve options等于这里的一个小函数，ABI将是我们的NFT ABI，我们需要导入它，我们需要从ethers导入两个醚。

16777
27:45:58.283 --> 27:46:32.696
我们还需要导入NFT abi，它的NFT abi from。dot constants / slash basic at at at T dot JSON，我刚从NFT框复制粘贴过来，合约地址将是NFT地址，函数名将是approve params将是2，市场地址，我们马上会定义，然后令牌ID将是令牌ID。

16778
27:46:32.696 --> 27:46:41.424
NFT框中的市场地址，我们直接从索引中获取，索引从数据库中获取。

16779
27:46:41.424 --> 27:46:48.507
现在我们希望我们的应用足够智能，能够抓取非ft市场本身，即市场地址。

16780
27:46:48.507 --> 27:46:53.249
如果我们看我们的常数，现在，我们实际上在这个网络映射中有它。

16781
27:46:53.249 --> 27:47:09.224
我们想在最上面抓取它通过const marketaddress =网络映射，网络映射的是实体市场地址的链ID在0处带索引。

16782
27:47:09.224 --> 27:47:16.951
所以链ID的网络映射，我们会得到真实的链ID等于我们莫拉莱斯。

16783
27:47:16.951 --> 27:47:22.919
链Id实际上就像我们说的，它是莫拉莱斯的蜡制六边形。

16784
27:47:22.999 --> 27:47:27.522
我们需要将chain ID转换为字符串可读版本。

16785
27:47:27.522 --> 27:47:32.149
因此我们写入const，链式字符串=链式ID。

16786
27:47:32.149 --> 27:47:40.585
我们用一个第三运算符，如果chain ID存在，就解析int (chain ID)

16787
27:47:40.585 --> 27:47:41.671
字符串。

16788
27:47:41.671 --> 27:47:46.811
因此，我们将从十六进制解析到一个更可读的版本，然后执行。

16789
27:47:46.811 --> 27:47:47.516
字符串。

16790
27:47:47.516 --> 27:47:51.826
否则，我们就说31337。

16791
27:47:51.999 --> 27:47:53.179
chain ID string。

16792
27:47:55.999 --> 27:48:04.558
string。。NFT市场在索引0处，那将是我们的市场地址。

16793
27:48:04.558 --> 27:48:13.499
我们得到了市场地址，这就是我们调用非功能性核准函数所需要的，我们现在可以调用运行契约函数作为证明。

16794
27:48:13.499 --> 27:48:15.753
所以我们实际上要做的有点不同。

16795
27:48:15.753 --> 27:48:18.676
我们会说const。

16796
27:48:18.676 --> 27:48:30.375
runcontractfunction = use web3contract，你可以导入runcontractfunction，然后把所有选项传递给它，就像我们这里要做的那样。

16797
27:48:30.375 --> 27:48:33.961
现在我们要说的是await oncontractfunction。

16798
27:48:34.100 --> 27:48:43.007
因为这是一个async函数，等待运行合约函数，我们会说params将是批准选项。

16799
27:48:43.100 --> 27:48:57.149
我们会说onsuccess，我们会做一些事情，我要说onerror，我们也会说error，小箭头函数，console。log error。

16800
27:48:57.149 --> 27:49:09.600
成功后，一旦我们发送这个事务，在审批通过后，我们会调用下面的列表函数调用async async。

16801
27:49:09.600 --> 27:49:13.673
功能，处理审批成功。

16802
27:49:13.673 --> 27:49:20.879
这将使用非ft地址，令牌ID，以及价格，将它放入参数中。

16803
27:49:20.879 --> 27:49:27.310
这个运行契约函数通过后，我们会调用handle proof success。

16804
27:49:27.310 --> 27:49:35.990
我们会把地址的末尾，令牌ID和价格传递给它，它会说console。log。

16805
27:49:36.100 --> 27:49:39.433
好了，现在是列出清单的时间了，我们会做同样的事情。

16806
27:49:40.100 --> 27:49:50.731
const list options，等于这将是所有调用列表函数API的选项这次将在市场上出现。

16807
27:49:50.731 --> 27:49:56.766
NFT market place abi，我们还要导入它我要回到NFT方框。

16808
27:49:56.766 --> 27:50:00.290
我们复制这一行，粘贴到上面。

16809
27:50:00.290 --> 27:50:03.655
那将是合约地址的API。

16810
27:50:03.655 --> 27:50:09.015
这将是市场地址，我们已经有了。

16811
27:50:09.100 --> 27:50:12.375
函数名将是列表项。

16812
27:50:14.100 --> 27:50:23.900
将是NFT地址的ntf地址，令牌ID的令牌ID，价格的价格。

16813
27:50:23.900 --> 27:50:32.927
现在我们有了这些选项，我们可以执行await，用params运行契约函数。

16814
27:50:32.927 --> 27:50:45.405
列表选项的onsuccess箭头函数，处理列表成功，这是一个我们还没有做的函数。

16815
27:50:45.405 --> 27:50:47.714
它会在空气错误上显示。

16816
27:50:47.714 --> 27:50:52.749
我们写入console。log error。

16817
27:50:52.749 --> 27:51:03.018
让这个句柄列表成功处理一个拼写句柄正确处理成功，这将是一个async函数。

16818
27:51:03.100 --> 27:51:06.037
这也会调用dispatch并发出一个小通知。

16819
27:51:06.037 --> 27:51:11.911
我们会从web3uitkit中抓取这个，使用通知。

16820
27:51:11.911 --> 27:51:17.261
我们说const dispatch = use notification。

16821
27:51:17.261 --> 27:51:24.688
然后在处理成功中输入dispatch，输入success。

16822
27:51:24.688 --> 27:51:33.838
消息非帖列表，标题非帖列表位置。

16823
27:51:33.838 --> 27:51:35.499
顶部酒吧，很酷。

16824
27:51:35.499 --> 27:51:42.035
我们还得把莫拉莱斯抓来。

16825
27:51:42.035 --> 27:51:46.673
所以一定要把莫拉莱斯从react引进来。

16826
27:51:46.673 --> 27:51:49.705
我们导入这个网络映射。

16827
27:51:49.705 --> 27:51:57.521
导入网络映射从点。点。斜杠常数/斜杠网络映射点JSON。

16828
27:51:57.521 --> 27:52:03.981
因为我又把合同地址拼错了，好的，我们的前端我们会刷新一下我们的网页，三个合同没有定义。

16829
27:52:03.981 --> 27:52:06.286
让我们从react moral中得到答案。

16830
27:52:06.286 --> 27:52:08.833
好吧，保存，刷新我们的前端。

16831
27:52:08.833 --> 27:52:10.966
好了，我们可以开始了。

16832
27:52:11.100 --> 27:52:15.761
好了，现在要测试这个，我们要做的是我们要在这里创建另一个脚本。

16833
27:52:15.761 --> 27:52:19.640
所以我们回到了非ft市场的内心，我们在看我们的脚本。

16834
27:52:19.640 --> 27:52:22.417
我们要创建一个新文件mint。

16835
27:52:22.417 --> 27:52:22.575
js。

16836
27:52:22.575 --> 27:52:31.521
这次我们不打算列出它，我们只打算创建一个ntf我们可以自己在UI上列出它。

16837
27:52:31.521 --> 27:52:40.067
实际上，我们可以复制mminton列表代码，粘贴到这里，然后删除审批和列表代码。

16838
27:52:40.067 --> 27:52:43.615
轰，移开那个，移开这个，移开这个。

16839
27:52:43.615 --> 27:52:45.047
这就是我们需要的。

16840
27:52:45.047 --> 27:52:47.293
现在我们把名字改成薄荷吧。

16841
27:52:47.293 --> 27:52:48.938
我们也可以去掉价格。

16842
27:52:48.938 --> 27:52:50.664
我们把这个换成薄荷糖。

16843
27:52:50.664 --> 27:52:51.793
就是这样。

16844
27:52:51.793 --> 27:52:58.623
现在我们有了一个可以调用的脚本，我们只需要创建一个非功能性的，我们也可以摆脱非功能性的市场。

16845
27:52:58.623 --> 27:53:02.881
实际上，我们可能需要令牌ID，以便知道它是什么。

16846
27:53:02.881 --> 27:53:06.068
我们写const令牌ID =。

16847
27:53:06.068 --> 27:53:13.350
让我们实际获取收据我们用const mint TX收据，但是收据，我可以在这里等于它。

16848
27:53:13.350 --> 27:53:17.528
然后我要把这个从羊绒收据上抄下来。

16849
27:53:17.528 --> 27:53:22.211
Cons令牌ID等于这个，粘贴到mint中。

16850
27:53:22.211 --> 27:53:25.433
Js，然后是console。log。

16851
27:53:25.433 --> 27:53:36.487
得到令牌ID，字符串插值令牌ID，硬帽子，运行脚本，分钟。j s破折号网络，本地主机。

16852
27:53:36.487 --> 27:53:39.623
我们要创造一个NF - T。

16853
27:53:39.623 --> 27:53:47.134
Got token ID 6表示我们知道m token ID 6，我们可以列出这个实体。

16854
27:53:47.134 --> 27:53:48.530
让我们还添加地址。

16855
27:53:48.530 --> 27:53:51.287
让我们做console。log NFTL。

16856
27:53:51.287 --> 27:53:58.957
如果地址是我们会做字符串插值。

16857
27:53:59.100 --> 27:54:01.811
你知道吗?让我们再做一次。

16858
27:54:03.100 --> 27:54:03.353
酷。

16859
27:54:07.100 --> 27:54:09.528
现在我们就去找这个非ft地址。

16860
27:54:11.100 --> 27:54:21.100
转到帐户3，因为这是我导入的帐户当你切换帐户时，我们会刷新页面为地址70。

16861
27:54:21.100 --> 27:54:21.200
6.

16862
27:54:21.200 --> 27:54:23.307
弹出Submit Metamask。

16863
27:54:23.307 --> 27:54:24.816
给予许可是的。

16864
27:54:24.816 --> 27:54:29.245
好了，现在是时候列出你现在有一支笔了。

16865
27:54:29.245 --> 27:54:30.938
本地主机列表项。

16866
27:54:31.100 --> 27:54:32.366
我们可以看到所有的数据和一切。

16867
27:54:33.100 --> 27:54:35.994
并确认非功能性清单好的，好的。

16868
27:54:35.994 --> 27:54:36.432
好的。

16869
27:54:36.432 --> 27:54:36.870
好的。

16870
27:54:38.100 --> 27:54:38.310
好。

16871
27:54:41.100 --> 27:54:41.438
节点。

16872
27:54:46.100 --> 27:54:49.433
我的点j的破折号网络，本地主机。

16873
27:54:51.100 --> 27:54:52.166
那两个街区。

16874
27:54:55.100 --> 27:54:57.836
给它一点新鲜感。

16875
27:54:57.836 --> 27:54:59.730
转到活动项目。

16876
27:55:01.100 --> 27:55:03.132
有一个新项为0。

16877
27:55:03.132 --> 27:55:03.525
6容易的。

16878
27:55:03.525 --> 27:55:04.574
在我们的数据库中。

16879
27:55:05.100 --> 27:55:05.927
棒极了。

16880
27:55:09.100 --> 27:55:12.033
现在让我们再来做一个。

16881
27:55:13.100 --> 27:55:14.854
第二个，看看它是否真的有效。

16882
27:55:15.100 --> 27:55:16.306
令牌ID为8。

16883
27:55:16.306 --> 27:55:18.374
让我们抓住这个地址。

16884
27:55:20.100 --> 27:55:20.800
刷新。

16885
27:55:20.800 --> 27:55:23.700
将此粘贴到令牌ID 8中。

16886
27:55:23.700 --> 27:55:24.800
我们用0。

16887
27:55:24.800 --> 27:55:25.100
999.

16888
27:55:26.100 --> 27:55:26.861
提交。

16889
27:55:26.861 --> 27:55:29.273
我们会批准的。

16890
27:55:29.273 --> 27:55:29.780
是的。

16891
27:55:29.780 --> 27:55:32.192
那我们就把它寄出去。

16892
27:55:32.192 --> 27:55:32.699
是的。

16893
27:55:34.100 --> 27:55:35.287
现在我们去挖两个街区的矿。

16894
27:55:36.100 --> 27:55:40.553
上去再回去矿就会跑矿，搬块。

16895
27:55:41.100 --> 27:55:41.568
太好了。

16896
27:55:47.100 --> 27:55:53.990
现在列出来了，我们有原来的那个，我们有刚才列出来的两个8和0的7。

16897
27:55:53.990 --> 27:55:54.536
6和0。

16898
27:55:54.536 --> 27:55:54.770
999.

16899
27:55:54.770 --> 27:55:57.100
在我们的非ft市场上上市。

16900
27:55:57.100 --> 27:55:58.433
这太令人兴奋了。

16901
27:55:58.433 --> 27:56:00.792
我们的列表运行正常。

16902
27:56:00.792 --> 27:56:09.680
现在，由于这节课已经非常长了，我决定删掉这部分，然后把它删掉一点，因为我们并没有学到什么新东西。

16903
27:56:09.680 --> 27:56:19.313
然而，请随时回到与分数相关的每一个比特，如果你想要实现它，我们将为你提供退出功能。

16904
27:56:19.313 --> 27:56:21.372
否则，请跳过并继续前进。

16905
27:56:21.372 --> 27:56:22.561
这是非常强大的。

16906
27:56:22.561 --> 27:56:25.734
你应该为自己感到无比兴奋。

16907
27:56:25.734 --> 27:56:27.876
如果你已经走到这一步。

16908
27:56:27.876 --> 27:56:29.145
这太棒了。

16909
27:56:29.145 --> 27:56:37.034
你只是做了一个去中心化的市场，然后在它上面建立了一个前端，允许任何人与你的市场进行交互。

16910
27:56:37.100 --> 27:56:37.700
很容易。

16911
27:56:37.700 --> 27:56:38.800
巨大的,巨大的。

16912
27:56:38.800 --> 27:56:40.900
祝贺你在这里。

16913
27:56:42.100 --> 27:56:44.480
是休息和庆祝的最佳时机。

16914
27:56:45.100 --> 27:56:51.048
在推特上给我打电话，说嘿，帕特里克，我刚刚完成了非ft市场。

16915
27:56:51.100 --> 27:57:00.084
全栈前端是免费代码营课程的一部分，我现在知道如何在我的智能合约应用程序之上构建全栈前端。

16916
27:57:00.084 --> 27:57:03.300
要对自己充满信心，因为这太棒了。

16917
27:57:03.300 --> 27:57:14.693
我无法低估我有多兴奋，你已经走到这一步，你正在学习和使用大量的技术，可靠的智能合约，前端你正在做完整的堆栈你在这里做了很多东西。

16918
27:57:14.693 --> 27:57:16.889
所以你应该为自己感到骄傲。

16919
27:57:16.889 --> 27:57:21.755
恭喜你，一定要给自己一个表扬。

16920
27:57:21.755 --> 27:57:26.993
然后准备继续我们的下一部分。

16921
27:57:27.100 --> 27:57:35.755
现在我们已经使用我们的Morales后端完成了所有这些工作，我将对您进行切换，而不是用一个集中的服务器索引我们所有的事件。

16922
27:57:35.755 --> 27:57:47.700
现在我们要学习如何用图表来构建这个，这是一个去中心化的事件索引器我们可以使用，很多代码都是完全一样的。

16923
27:57:47.700 --> 27:58:02.274
所以我们不需要重新开始，我们要做的是，首先我们可以关闭所有本地的东西，我们可以关闭所有这些东西，我们最终可以关闭所有的终端，这真的很令人兴奋。

16924
27:58:02.274 --> 27:58:08.944
在这个文件夹中，我们要做的是将所有内容复制到一个新文件夹中。

16925
27:58:08.944 --> 27:58:14.782
我将向下CD一个目录，我们将新建一个名为next Jas的目录。

16926
27:58:14.782 --> 27:58:30.561
如果T市场，这个图表，虚线FCC，以及这部分的所有代码都将在这里用于前端的图表索引器我们将需要进行另一个回购我们稍后会讲到这个。

16927
27:58:30.561 --> 27:58:33.290
所有的变化，都在这一部分。

16928
27:58:33.290 --> 27:58:40.269
我们要做的是创建这个新文件夹，复制破折号R。

16929
27:58:40.269 --> 27:58:46.890
接下来，Jas和ft市场FCC变成下一个Jas非ft。

16930
27:58:46.890 --> 27:58:50.809
市场，图表FCC。

16931
27:58:51.100 --> 27:58:59.286
我们要递归地复制，所有在那个文件夹里的东西我们刚创建到这个新文件夹里我们要做很多调整。

16932
27:58:59.286 --> 27:59:04.800
这个可能要花点时间因为这个文件夹里有很多东西。

16933
27:59:04.800 --> 27:59:16.625
好的，一旦我们完成了这些，我们就可以进入下一个Jas和ft市场，FCC图，做代码周期，在一个新的代码编辑器中打开它。

16934
27:59:16.625 --> 27:59:20.772
或者像往常一样，你可以用File Open folder来打开它。

16935
27:59:20.772 --> 27:59:26.657
现在我们在这里，我们要学习如何做这个完全相同的项目，而不是使用mirallas。

16936
27:59:26.657 --> 27:59:32.410
但是使用这个图表，我们首先要做的一件事是我们实际上要把合约部署到溜冰场B。

16937
27:59:32.410 --> 27:59:40.690
所以我们要抓住我们的市场，那个灵魂，把它停下来，我们要抓住我们的硬帽市场。灵魂项目，把它停下来。

16938
27:59:40.690 --> 27:59:43.521
首先，我们要在rink v上运行部署脚本。

16939
27:59:43.521 --> 27:59:50.477
希望你已经正确地设置了所有的部署，这样所有的参数都能正确地通过。

16940
27:59:50.477 --> 27:59:57.300
所以我们要继续这个故事，戴上安全帽部署破折号网络。

16941
27:59:57.300 --> 28:00:00.427
并确保它对林克比有效。

16942
28:00:00.427 --> 28:00:02.366
让我们检查一下我们的安全帽配置。

16943
28:00:02.366 --> 28:00:06.845
对于网络，我把Rigby的东西放在这里了。

16944
28:00:06.845 --> 28:00:10.576
好的，我有我的RPC URL，我从环境变量中获取它。

16945
28:00:10.576 --> 28:00:17.913
如果我有一个私钥，我有一个私钥，我也从环境变量中获得，我有一个链ID块确认和保存部署。

16946
28:00:17.913 --> 28:00:19.489
让我们继续运行这个。

16947
28:00:19.489 --> 28:00:24.336
现在我们将继续，将非ft市场部署到Rigby网络。

16948
28:00:24.336 --> 28:00:27.964
我们的部署脚本也有一个ID进行验证。

16949
28:00:27.964 --> 28:00:34.427
我们也可以验证这一点，如果你不部署一个溜冰场就不能跟着这一节走。

16950
28:00:34.427 --> 28:00:40.358
所以部署到B级，或者在第15课中推荐的任何测试网，然后从那里开始。

16951
28:00:40.358 --> 28:00:42.995
很好，我们已经部署了NFC市场。

16952
28:00:43.100 --> 28:00:45.591
现在我们要继续部署我们的基本非ft。

16953
28:00:46.100 --> 28:00:50.450
部署完成后，我们可以开始更新前端代码，以使用图而不是mirallas。

16954
28:00:50.450 --> 28:00:53.100
好了，我们已经核实过了，一切都很正常。

16955
28:00:53.100 --> 28:00:55.411
现在我们要验证基本的非ft。

16956
28:00:55.411 --> 28:00:57.181
我们已经核实过了。

16957
28:00:57.181 --> 28:00:57.705
太棒了。

16958
28:00:57.705 --> 28:01:03.453
现在我们在P环上部署了一个非功能性市场，在B环上部署了一个基本的非功能性市场。

16959
28:01:03.453 --> 28:01:05.299
这两个都得到了验证。

16960
28:01:05.299 --> 28:01:11.854
所以一定要注意这些，因为我们在学习图形部分的时候会用到它们。

16961
28:01:11.854 --> 28:01:17.035
现在让我们抓取名为next Jas and ft marketplace的代码编辑器，即图表。

16962
28:01:17.100 --> 28:01:18.410
让我们开始吧。

16963
28:01:21.100 --> 28:01:24.683
但是我们忘记在这里添加一些代码来更新我们的网络映射。

16964
28:01:24.683 --> 28:01:50.043
但是，如果我们回去，打开代码，下一个Jas NFT市场，FCC，在这里的网络映射中会有一个新的B溜冰场条目，如果我们做得正确，让我们复制这个网络映射并粘贴到我们的网络中，我们的下一个GS和ft市场，图表部分，或者你可以手动添加你的新条目。

16965
28:01:50.100 --> 28:01:50.412
正确的。

16966
28:01:53.100 --> 28:01:53.640
市场。

16967
28:01:56.100 --> 28:01:59.709
我们要删除这个云功能。

16968
28:01:59.709 --> 28:02:06.155
再见，因为既然我们不再使用服务器，就不会有任何云功能或任何后端要运行。

16969
28:02:06.155 --> 28:02:08.423
所以我们要把它移到垃圾再见。

16970
28:02:08.423 --> 28:02:15.666
接下来，我们不再需要FRP了，因为我们不需要把我们的本地区块链连接到图上，我们只需要使用这里的测试网。

16971
28:02:15.666 --> 28:02:17.821
我们把它删掉。

16972
28:02:17.821 --> 28:02:22.253
再见，接下来是什么，还有我们的app。j。s。

16973
28:02:22.253 --> 28:02:39.548
现在我们像这样连接到一个Morales提供者，我们将把它切换回去在Mount上启动盟友，这将返回为false，我们不再像这样连接到我们的Morales数据库，我们将再次使用钩子。

16974
28:02:39.548 --> 28:02:42.942
现在唯一要改变的是指数。

16975
28:02:42.942 --> 28:02:43.047
js。

16976
28:02:43.047 --> 28:02:44.638
现在，在我们的指数中。

16977
28:02:44.638 --> 28:02:50.884
js中，我们从Morales查询中获取NF TS的列表。

16978
28:02:51.100 --> 28:02:53.893
我们要改变这个，让我们更新自述文件。

16979
28:02:54.100 --> 28:03:01.782
我们不会从ralis读取事件，我们会首先用图表索引它们。

16980
28:03:01.782 --> 28:03:04.050
然后我们从图中读出。

16981
28:03:04.050 --> 28:03:08.877
问题是，图像是什么。

16982
28:03:09.100 --> 28:03:13.600
因此，这个图形将是一个分散的层，用于存储事件数据。

16983
28:03:13.600 --> 28:03:17.338
所以有了所有这些区块链和所有这些不同的存储网络。

16984
28:03:17.338 --> 28:03:27.242
这个图是，这个图是一个不同节点的网络，从区块链中读取数据并建立索引，它为我们提供了一个API来调用我们可以读取数据。

16985
28:03:27.242 --> 28:03:28.099
而不仅仅是我自己。

16986
28:03:28.099 --> 28:03:32.053
我们跟阿伯特聊过了，他比我更能解释清楚。

16987
28:03:32.100 --> 28:03:32.957
和在。

16988
28:03:33.100 --> 28:03:39.046
首先，我要感谢帕特里克创建了这么棒的教育资源，并邀请我成为其中的一员。

16989
28:03:39.100 --> 28:03:40.237
我叫Nadia dabit。

16990
28:03:42.100 --> 28:03:42.946
处理图表。

16991
28:03:44.100 --> 28:03:52.510
对去中心化网络，如Aetherium IPFS，数十个其他EVM兼容网络，以及近未来宇宙和索拉纳的查询协议。

16992
28:03:52.510 --> 28:04:06.962
使用图，开发人员可以构建和发布称为子图的开放API，然后在他们的应用程序中使用这些子图来实现对存储在这些网络上的数据更好的查询功能，包括过滤、排序、关系数据和全堆栈搜索等功能。

16993
28:04:06.962 --> 28:04:28.503
子图位于区块链和UI之间，提供了一个重要的软件基础设施，一个灵活的性能和分散的API层，以及传统技术堆栈数据库，服务器和API的查询过滤器，排序分页组和连接数据之前返回到应用程序，通常通过某种类型的HTTP请求。

16994
28:04:28.503 --> 28:04:34.950
当直接从Aetherium或其他区块链读取数据时，这些类型的数据转换是不可能的。

16995
28:04:34.950 --> 28:04:39.217
在图表团队必须开发和操作专有索引服务器之前。

16996
28:04:39.217 --> 28:04:51.363
这需要大量的工程和硬件资源，打破了去中心化所需的重要安全原则，我们如何与区块链交互并在其上构建，这与我们在传统技术栈中习惯的非常不同。

16997
28:04:51.363 --> 28:04:59.890
在区块链中，数据不是以可以轻松或有效地使用或直接从其他应用程序或前端检索的格式存储的。

16998
28:04:59.890 --> 28:05:03.663
问题是，您需要为数据建立索引并进行组织，以便进行有效的检索。

16999
28:05:03.663 --> 28:05:09.053
传统上，这是数据库和网络服务器在这个集中式技术栈中所做的工作。

17000
28:05:09.053 --> 28:05:12.134
但是在索引层，在web三栈中是缺失的。

17001
28:05:12.134 --> 28:05:16.051
让我们来看看现实世界中的其他几个索引示例。

17002
28:05:16.101 --> 28:05:23.464
像谷歌这样的搜索引擎抓取互联网索引相关数据，使用户可以通过他们的web界面和其他API进行搜索。

17003
28:05:23.464 --> 28:05:29.493
如果没有这个索引层，我们就很难知道在哪里以及如何在网络上找到相关信息。

17004
28:05:29.493 --> 28:05:31.601
另一个类似的类比是图书馆。

17005
28:05:31.601 --> 28:05:42.016
使用像杜威十进制系统这样的索引系统，我们知道在哪里找到我们要找的书，而不必一本书一本书地在整个图书馆里寻找。

17006
28:05:42.016 --> 28:05:49.522
该图表每天为许多不同类型的web三应用程序提供超过20亿次查询，包括挑战游戏和FC领域的应用程序。

17007
28:05:49.522 --> 28:05:53.331
在深入研究任何代码之前，让我们看看如何构建子图。

17008
28:05:53.331 --> 28:05:55.269
首先，你要看图表。

17009
28:05:55.269 --> 28:05:58.810
Com，并创建一个新的子图和图形用户界面。

17010
28:05:58.810 --> 28:06:06.825
然后，您可以使用图CLI构建一个空子图样板，然后用您自己的契约信息更新该样板。

17011
28:06:06.825 --> 28:06:15.726
在子图配置中，您将定义数据模型、网络、契约地址和其他特定于您想要索引的数据的配置。

17012
28:06:15.726 --> 28:06:23.624
对于我们的数据模型，我们使用Graph QL，一种定义顶级类型以及这些类型中的字段的模式定义语言。

17013
28:06:23.624 --> 28:06:32.360
当我们准备好部署子图，以便开始测试它并在应用程序中使用它时，我们可以使用运行deploy命令的图形CLI。

17014
28:06:32.360 --> 28:06:40.592
一旦部署了子图并开始为数据建立索引，我们就可以在图形指示板中直接使用图形界面对其进行测试。

17015
28:06:40.592 --> 28:06:48.726
当我们准备好开始quering时，我们的应用程序的子图，我们可以使用图提供给我们的API URL，以及任何graph QL查询。

17016
28:06:48.726 --> 28:06:53.691
如果你想了解更多关于这张图的信息，请查看这张图。

17017
28:06:53.691 --> 28:06:57.863
com以及Graph Protocol、Twitter、Graph上的文档。

17018
28:06:57.863 --> 28:07:00.998
或我们的Discord在图表中。

17019
28:07:00.998 --> 28:07:02.527
谢谢很重要。

17020
28:07:02.527 --> 28:07:07.851
现在我们对这个图有了更好的了解，我们就可以开始用它来构建了。

17021
28:07:07.851 --> 28:07:14.132
如果我们试着运行这个应用，它显然会失败，因为index。

17022
28:07:14.132 --> 28:07:18.757
Js，现在从mirallas而不是从图中读取。

17023
28:07:18.757 --> 28:07:28.038
就像自述文件里说的，我们要做的第一件事是我们要从图中建立索引，然后我们就可以从图中读取数据。

17024
28:07:28.101 --> 28:07:30.632
让我们继续学习如何构建子图。

17025
28:07:31.101 --> 28:07:37.810
为了让图形网络开始索引合同中的事件，我们需要用到图形。

17026
28:07:37.810 --> 28:07:39.810
Com，我们要讲产品。

17027
28:07:39.810 --> 28:07:47.951
我们要去子图工作室，如果你去产品，你首先看到的是图资源管理器，这些都是已经存在的子图。

17028
28:07:47.951 --> 28:07:56.258
如果你仔细看这里，你会看到很多非常流行的去中心化协议都有不同的子图，托管服务会在某个时刻停止。

17029
28:07:56.258 --> 28:07:57.346
我们跳过这里。

17030
28:07:57.346 --> 28:08:04.051
让我们进入子图工作室，这将帮助我们为其他节点创建子图，开始为我们的事件索引。

17031
28:08:04.051 --> 28:08:07.549
我们要把钱包和meta mask连接起来。

17032
28:08:07.549 --> 28:08:15.914
我要在这里选择账号1，下一个连接，我们要关掉Hardhead。

17033
28:08:15.914 --> 28:08:19.981
本地，转到林克比测试网络。

17034
28:08:19.981 --> 28:08:21.859
然后转到账户1。

17035
28:08:21.859 --> 28:08:27.413
我们会得到一个签名请求从图表汇总到我们刚刚建立的网站。

17036
28:08:27.413 --> 28:08:32.469
子图网站有一些签名功能，后端有一个数据库。

17037
28:08:32.469 --> 28:08:36.377
我们在现实生活中看到的，正是我们刚刚使用的方法。

17038
28:08:36.377 --> 28:08:40.901
所以他们没有和莫拉莱斯签约，而是在这里有自己的定制标识。

17039
28:08:40.901 --> 28:08:45.050
我们要登录，这样图形网站就可以和我们互动了。

17040
28:08:45.050 --> 28:08:47.412
我们可以输入我们的邮箱。

17041
28:08:47.412 --> 28:08:49.248
我要跳过了。

17042
28:08:49.248 --> 28:08:57.101
你甚至会在这里得到一个小通知说，只有索引Aetherium或main net或Rigby的子图可以在子图工作室中创建。

17043
28:08:57.101 --> 28:08:59.767
我们来创建一个子图。

17044
28:08:59.767 --> 28:09:05.871
所以我们要选一个铈里格比子图的名字是NFT市场。

17045
28:09:05.871 --> 28:09:07.969
我们继续并点击Continue。

17046
28:09:08.101 --> 28:09:11.378
这将是我们创建子图的仪表盘。

17047
28:09:11.378 --> 28:09:20.488
这里有大量的说明和文档我们可以查看，我将把这些文档添加到与这门课程相关的GitHub回购中。

17048
28:09:20.488 --> 28:09:25.351
所以这个非ft市场子图需要它自己的git仓库。

17049
28:09:25.351 --> 28:09:34.157
这里我们要做的是CD向下，创建一个新目录，命名为graph。

17050
28:09:34.157 --> 28:09:39.375
如果T市场，FCC，我们也会开放它。

17051
28:09:39.375 --> 28:09:50.033
代码图NFT，市场FCC，或者文件开放接枝代码市场FCC，在这个窗口中，我们将构建我们的子图。

17052
28:09:50.101 --> 28:09:54.083
在本地，我们会构建子图并把它推到子图工作室。

17053
28:09:54.083 --> 28:09:59.429
在这里，有一大堆指导我们可以按照指导进行安装。

17054
28:09:59.429 --> 28:10:03.543
我们需要做的第一件事是安装图形命令行接口。

17055
28:10:03.543 --> 28:10:05.969
我们想要在全球范围内安装这个。

17056
28:10:06.101 --> 28:10:08.396
我把这部分复制过来。

17057
28:10:10.101 --> 28:10:13.133
纱线，全球广告，然后粘贴进去。

17058
28:10:15.101 --> 28:10:21.574
这将帮助我们建立一个图表，并为图表建立指令，从而为我们的事件建立索引。

17059
28:10:21.574 --> 28:10:26.037
既然已经安装了全局变量，我们就可以初始化图形代码了。

17060
28:10:26.101 --> 28:10:28.036
所以我们可以复制这条线。

17061
28:10:31.101 --> 28:10:33.423
然后按回车键。

17062
28:10:35.101 --> 28:10:37.184
为Aetherium，或子图。

17063
28:10:37.184 --> 28:10:38.600
鼻涕虫将非ft。

17064
28:10:38.600 --> 28:10:39.600
市场。

17065
28:10:40.101 --> 28:10:43.825
希望目录在这里，但它说目录已经存在。

17066
28:10:43.825 --> 28:10:45.790
所以我们只给它非ft市场。

17067
28:10:45.790 --> 28:10:47.481
然后我们把它移到后面。

17068
28:10:47.481 --> 28:10:48.766
这是在林克比球场上。

17069
28:10:48.766 --> 28:10:49.288
测试网络。

17070
28:10:49.288 --> 28:10:52.288
现在我们要给它合同地址。

17071
28:10:52.288 --> 28:10:55.201
我们想获取刚刚部署的地址。

17072
28:10:55.201 --> 28:10:57.519
它现在应该在我们的网络映射中。

17073
28:10:57.519 --> 28:11:04.019
我们会抓取刚刚部署的合约地址，并粘贴到这里。

17074
28:11:04.101 --> 28:11:04.694
像这样。

17075
28:11:09.101 --> 28:11:15.434
自动从以太扫描中为我们抓取ABI，我们给它一个合约名，这就是非金融市场。

17076
28:11:15.434 --> 28:11:21.101
它会在这个非ft市场目录中给我们一大堆样板代码。

17077
28:11:21.101 --> 28:11:23.005
这可能要花几分钟。

17078
28:11:23.101 --> 28:11:23.901
好的,太棒了。

17079
28:11:26.101 --> 28:11:28.767
在非ft市场创建的市场。

17080
28:11:30.101 --> 28:11:31.051
它应该在卖家文件夹里。

17081
28:11:32.101 --> 28:11:42.473
往下移动一个目录，但你也可以把它留在原来的地方，如果你想的话，我要说移动，我要说移动非ft市场，星号为。/。

17082
28:11:42.473 --> 28:11:47.051
现在NFT市场中的所有内容都将在当前目录中。

17083
28:11:47.101 --> 28:11:49.151
然后如果市场空了。

17084
28:11:50.101 --> 28:11:51.372
继续删除。

17085
28:11:51.372 --> 28:11:52.541
如果市场。

17086
28:11:53.101 --> 28:11:53.445
太好了。

17087
28:11:57.101 --> 28:11:59.687
这是我们刚创建的文件。

17088
28:12:00.101 --> 28:12:01.751
第一个文件夹是API的。

17089
28:12:03.101 --> 28:12:08.197
索引并读取我们的契约索引我们的事件，它需要我们的事件的ABI。

17090
28:12:08.197 --> 28:12:19.577
我们有整个市场的ABI，从以太扫描，如果我们没有验证以太扫描，我们可以自己创建这个API文件夹，并在这里添加非ft市场JSON。

17091
28:12:19.577 --> 28:12:21.669
现在我们有了这个生成的文件夹。

17092
28:12:21.669 --> 28:12:23.394
这是一个自动生成的文件。

17093
28:12:23.394 --> 28:12:26.609
他甚至在顶部说，不要直接编辑这个文件。

17094
28:12:26.609 --> 28:12:32.621
你可以把它看作构建文件夹，或者我们编译图形代码的地方。

17095
28:12:32.621 --> 28:12:36.038
节点模块，当然是节点模块和依赖项。

17096
28:12:36.038 --> 28:12:43.593
SRC将是我们定义和告诉图形，如何映射以及如何使用契约的地方。

17097
28:12:43.593 --> 28:12:45.316
它是一个TypeScript文件。

17098
28:12:45.316 --> 28:12:53.051
对于所有刚刚用JavaScript做过这个的人，我将会教你们一些TypeScript来完成这一部分。

17099
28:12:53.101 --> 28:13:06.005
然后是network。JSON，它提供了所有网络信息关于哪个网络，地址是什么，以及我们要索引的不同契约是什么，package。JSON，当然只是一个普通的package。JSON。

17100
28:13:06.005 --> 28:13:10.458
它有一些已经内置在schema。graph中的图形脚本。

17101
28:13:10.458 --> 28:13:13.101
QL将是我们的Graph QL模式。

17102
28:13:13.101 --> 28:13:19.054
这也是我们告诉图形如何处理事件和索引事件的方式。

17103
28:13:19.101 --> 28:13:22.501
如果您熟悉的话，该模式遵循Graph QL语法。

17104
28:13:22.501 --> 28:13:28.527
如果你之前用过Graph QL，它会是完全一样的，图。

17105
28:13:28.527 --> 28:13:30.755
QL是API的查询语言。

17106
28:13:30.755 --> 28:13:39.726
它不是一种关系数据库，它可以以一种更图形的方式进行查询，我不打算深入讨论它的幕后工作原理。

17107
28:13:39.726 --> 28:13:48.545
但如果你想了解更多，我会在GitHub存储库中留下一些与这门课程相关的文档，子图。Yamo告诉子图如何将所有文件组合在一起。

17108
28:13:48.545 --> 28:14:00.196
我们有数据源，它们来自不同的地址，不同的实体或事件，API从不同的事件处理程序中获取文件，我们一会儿会讲到。

17109
28:14:00.196 --> 28:14:02.910
然后是主文件，也就是我们的映射。

17110
28:14:02.910 --> 28:14:07.455
ts，我们有一个ts配置，这是一个TypeScript特定的配置文件。

17111
28:14:07.455 --> 28:14:09.815
当然，我们还有纱线点锁。

17112
28:14:09.815 --> 28:14:18.513
有了所有这些信息和所有这些代码，我们现在要更新所有这些代码来告诉图形开始为我们的事件建立索引。

17113
28:14:18.513 --> 28:14:24.721
因此，我们可以在分散的上下文中从图中读取事件，而不是从集中的数据库中。

17114
28:14:24.721 --> 28:14:34.646
在我们构建完所有东西之后，我们将运行这个并部署代码，这是为了验证我们自己，然后将我们的代码部署到图中开始索引。

17115
28:14:34.646 --> 28:14:37.208
废话不多说，让我们开始吧。

17116
28:14:37.208 --> 28:14:38.315
我们来做这个。

17117
28:14:38.315 --> 28:14:43.837
首先我要做的是，为这些。Graph QL文件添加一个高亮显示。

17118
28:14:43.837 --> 28:14:46.767
在扩展中，我们会看到Graph QL。

17119
28:14:46.767 --> 28:14:50.600
我们会拖延这个Graph QL扩展。

17120
28:14:50.600 --> 28:14:56.658
现在我们已经安装了它，如果我们回到schema。graph, QL，我们现在有了一些颜色，这是令人兴奋的。

17121
28:14:56.658 --> 28:15:05.391
所以这个模式点图QL将定义我们的契约中有什么实体如果我们要类似mirallas。

17122
28:15:05.391 --> 28:15:08.529
这就是我们如何定义表格的样子。

17123
28:15:08.529 --> 28:15:09.850
这些就是我们的事件。

17124
28:15:09.850 --> 28:15:12.592
加上我们创建的活动项目表。

17125
28:15:12.592 --> 28:15:18.834
我们不会有一个实体示例，我们会有一个类型活动项。

17126
28:15:18.834 --> 28:15:21.367
这将是一个加法实体。

17127
28:15:21.367 --> 28:15:31.273
这些是我们在图中可以查询的不同类型，我们要查询的主要内容和之前一样，它是我们的活动项。

17128
28:15:31.273 --> 28:15:41.434
然后在活动项目内部，我们会告诉图形，每个活动项目类型有什么参数，它将有一个ID类型。

17129
28:15:41.434 --> 28:15:43.394
变量是ID类型的ID。

17130
28:15:43.394 --> 28:15:47.524
你可以在图表文档中阅读更多关于不同类型的信息。

17131
28:15:47.524 --> 28:15:51.354
这个感叹号意味着它一定有一个ID。

17132
28:15:51.354 --> 28:16:08.790
所以每个活动物品都需要并且将会有一个ID，我们说将会有一个买家，这将是一个地址，这将是一个字节买家可以是空的，对吧?它可以是0x000，所有的活动项目都有0000点。

17133
28:16:08.790 --> 28:16:08.962
如果。

17134
28:16:08.962 --> 28:16:19.445
如果还没有人买，我们就会有一个卖家，这当然也会是一个字节因为它将是一个地址，我们会有一个非ft地址。

17135
28:16:19.445 --> 28:16:31.367
NFT的地址，也将是字节，我们将有一个令牌ID，它不会是字节，这将是大int类型的，然后我们将有一个价格，它也将是一个大int。

17136
28:16:31.367 --> 28:16:37.008
现在我们不需要price，我们让price为可空。

17137
28:16:37.008 --> 28:16:38.300
所以价格可以为零。

17138
28:16:38.300 --> 28:16:39.789
所以我们有一个活动项目。

17139
28:16:39.789 --> 28:16:40.182
太棒了。

17140
28:16:40.182 --> 28:16:46.236
我们还需要什么?我们在莫拉莱斯还有什么别的桌子?我们需要列出类型item。

17141
28:16:46.236 --> 28:16:52.640
这将是实体需要一个ID，它将有一个卖家。

17142
28:16:52.640 --> 28:16:57.901
无论什么时候一件商品被列出，它都会有一个销售权，也就是一个字节。

17143
28:16:57.901 --> 28:17:23.835
如果地址NFT的地址，也将是字节，令牌ID，也将是一个大int，然后是价格，也将是一个大end，我们将需要一个类型项取消在实体它将有一个ID seller一个NFT地址。

17144
28:17:23.835 --> 28:17:29.301
令牌ID将是一个重要的结尾。

17145
28:17:29.301 --> 28:17:37.963
最后一种类型的商品将在实体中有一个ID ID。

17146
28:17:37.963 --> 28:17:42.767
它将是一个买家字节。

17147
28:17:43.101 --> 28:17:54.006
然后是T地址的一个字节和一个令牌ID，然后是一个开始的价格。

17148
28:17:54.006 --> 28:18:04.364
在Justice Information中，我们定义了子图想要跟踪的东西想要跟踪物品购买事件，物品，取消事件，物品列出事件。

17149
28:18:04.364 --> 28:18:09.846
然后我们将创建这个新的活动项目表类似于mirallas。

17150
28:18:09.846 --> 28:18:13.522
它是其他三个事件的函数。

17151
28:18:13.522 --> 28:18:16.679
现在我们完成了模式点图。

17152
28:18:16.679 --> 28:18:16.889
QL。

17153
28:18:17.101 --> 28:18:17.445
太棒了。

17154
28:18:20.101 --> 28:18:22.870
子图来监听这些事件。

17155
28:18:24.101 --> 28:18:30.601
我们要告诉它如何监听这些事件，我们会去到src mapping。

17156
28:18:30.601 --> 28:18:30.801
ts。

17157
28:18:30.801 --> 28:18:32.601
就是这个映射。

17158
28:18:32.601 --> 28:18:40.051
Ts文件会告诉子图如何映射以及如何存储所有的事件信息。

17159
28:18:40.101 --> 28:18:43.901
如果你现在看它，它甚至可能给你一个例子事件。

17160
28:18:43.901 --> 28:18:46.967
它说Export function, handle item event。

17161
28:18:47.101 --> 28:18:51.101
这是Maya现在说的，它作为一个输入参数事件项目机器人。

17162
28:18:51.101 --> 28:18:58.133
也就是说，当一个项目bot事件发生时，执行这个处理项目bot函数。

17163
28:18:58.133 --> 28:19:01.101
每当item bot发生时，这个就处理item bot。

17164
28:19:01.101 --> 28:19:08.684
我们实际上从我们生成的非ft市场中从一些生成的代码中得到这个项目机器人。

17165
28:19:08.684 --> 28:19:09.767
在图中。

17166
28:19:09.767 --> 28:19:11.850
如果我们运行图形代码Gen。

17167
28:19:12.101 --> 28:19:19.783
这个图代码Gen命令获取我们在模式点graph QL中的所有东西，并将其放入这个生成的文件中。

17168
28:19:19.783 --> 28:19:25.862
现在我运行了图形代码Gen，你会看到这里有一个项目机器人类，有一个模式，类型脚本。

17169
28:19:25.862 --> 28:19:32.628
我们甚至可以找到我们在模式中创建的新活动项类。

17170
28:19:32.628 --> 28:19:40.379
每当你更新schema。Graph QL时，你总是需要运行Graph代码Gen，这样你就能更新那些类型。

17171
28:19:40.379 --> 28:19:43.720
如果失败了，这意味着您在模式点图QL中搞砸了一些东西。

17172
28:19:43.720 --> 28:19:45.497
现在在我们的映射中。

17173
28:19:45.497 --> 28:19:55.291
Ts，我们实际上是导入商品购买商品取消商品从生成的和如果市场如果市场从生成的代码。

17174
28:19:55.291 --> 28:19:56.901
这些是我们的事件。

17175
28:19:56.901 --> 28:19:59.901
我们不需要在非功能性市场上做任何事情。

17176
28:19:59.901 --> 28:20:01.624
我们只需要我们的事件信息。

17177
28:20:01.624 --> 28:20:02.004
现在。

17178
28:20:02.004 --> 28:20:09.020
我们删掉句柄项目bot里面的所有东西不管样本是什么。

17179
28:20:09.101 --> 28:20:12.762
我们从生成的代码中导入事件。

17180
28:20:13.101 --> 28:20:16.406
然后是这条线，我们马上要改变它。

17181
28:20:16.406 --> 28:20:21.491
同样，我们有这三个函数处理物品购买，处理物品取消和处理物品列出。

17182
28:20:21.491 --> 28:20:25.049
每当我们得到一个物品购买事件，我们就会执行这个函数。

17183
28:20:25.101 --> 28:20:27.778
每当我们得到一个项目取消事件，我们就会用这个函数。

17184
28:20:27.778 --> 28:20:32.304
所有这些代码都定义在子图。Yamo中。

17185
28:20:32.304 --> 28:20:38.204
您可以在列出的bot项目和事件处理程序中看到不同的实体。

17186
28:20:38.204 --> 28:20:52.846
它说，无论何时这个特定事件触发一个索引地址，一个索引地址索引，YouTube中的YouTube 36有6个调用句柄项目买了，这里是句柄项目。

17187
28:20:52.846 --> 28:20:55.354
这就是它的工作原理。

17188
28:20:55.354 --> 28:20:59.773
那么让我们来看看当购买事件触发时该怎么做。

17189
28:20:59.773 --> 28:21:04.434
我觉得买的，取消的清单有点让人困惑。

17190
28:21:04.434 --> 28:21:18.713
所以我想把这个改成，买的东西是买的东西，取消的东西是取消的东西，列出的东西是列出的东西。

17191
28:21:18.713 --> 28:21:25.490
所以我只是改变了这三个从NFT市场进口的名称。

17192
28:21:25.490 --> 28:21:29.649
现在我要把事件，item bot，改成，item bought，事件。

17193
28:21:29.649 --> 28:21:34.197
取消的事件项目到取消的事件和列出的事件项目到列出的事件。

17194
28:21:34.197 --> 28:21:34.971
好了,好了。

17195
28:21:34.971 --> 28:21:37.649
现在我们把这条线去掉。

17196
28:21:37.649 --> 28:21:42.295
一开始我们也不需要顶部的这一行，等下会用到，但现在先把它删掉。

17197
28:21:42.295 --> 28:21:44.682
这是我们的极简代码。

17198
28:21:44.682 --> 28:21:51.308
当我们列出一个项目时，我们需要做什么?我们需要把这个事件保存到图中。

17199
28:21:51.308 --> 28:21:56.628
然后我们还需要更新活动项，就像我们对莫拉莱斯所做的一样。

17200
28:21:56.628 --> 28:22:01.786
首先我们需要做的是获取或创建一个item列表对象。

17201
28:22:01.786 --> 28:22:06.211
我们需要知道的是每件物品都需要一个唯一的ID。

17202
28:22:06.211 --> 28:22:09.205
我们需要创建那个ID。

17203
28:22:09.205 --> 28:22:17.085
我要做的第一件事是创建一个函数叫Get ID from event params。

17204
28:22:17.085 --> 28:22:21.239
它需要一个令牌ID这就是TypeScript发挥作用的地方。

17205
28:22:21.239 --> 28:22:25.546
在TypeScript中，我们实际上需要定义不同形参的类型。

17206
28:22:25.546 --> 28:22:28.211
令牌ID是一个大int。

17207
28:22:28.211 --> 28:22:33.462
我们还会取一个非ft地址，它会取一种地址类型。

17208
28:22:33.462 --> 28:22:42.387
我们还需要说明返回类型或函数会给出什么，我们会返回一个字符串，我们会从事件参数创建一个ID。

17209
28:22:42.387 --> 28:22:46.157
它将是令牌ID和NFT地址的组合。

17210
28:22:46.157 --> 28:22:51.467
这两者的组合将为每种类型的事件提供唯一的ID。

17211
28:22:51.467 --> 28:23:02.528
我们会说，返回令牌ID，令牌ID有一个函数，叫做xstring，我要说，加上，如果T地址。

17212
28:23:02.528 --> 28:23:04.292
到X字符串，像这样。

17213
28:23:04.292 --> 28:23:09.786
和大int地址，我们需要导入at图形协议斜杠图形TX。

17214
28:23:09.786 --> 28:23:11.731
它对我来说已经足够大了。

17215
28:23:11.731 --> 28:23:16.456
所以我要在这里添加地址是来自图的两种特殊类型。

17216
28:23:16.456 --> 28:23:18.118
字符串被内置到TypeScript中。

17217
28:23:18.118 --> 28:23:27.244
现在我们已经有了为函数中的每个项获取特殊ID的方法，现在我们必须获取或创建一个新项。

17218
28:23:27.244 --> 28:23:29.624
现在我们有一个项目。

17219
28:23:29.624 --> 28:23:33.139
但是如果我们没有购买物品。

17220
28:23:33.139 --> 28:23:39.789
物品购买对象将是我们保存的东西，物品购买事件只是原始事件。

17221
28:23:39.789 --> 28:23:44.339
我们需要从itembought事件中创建一个itembought对象。

17222
28:23:44.339 --> 28:23:47.944
在TypeScript中，这是两种不同的类型。

17223
28:23:47.944 --> 28:23:50.456
我们需要按对象导入这些项。

17224
28:23:50.456 --> 28:23:54.168
这些是从生成的模式中自动创建的。

17225
28:23:54.168 --> 28:24:01.789
在这里我们有活动道具，道具，道具购买类别，道具取消等等。

17226
28:24:01.789 --> 28:24:04.363
我们需要从这里导入这些类型。

17227
28:24:04.363 --> 28:24:17.067
我们可以说，导入，项目列表，逗号，活动项目，项目购买项目取消从。斜杠，生成斜杠模式。

17228
28:24:17.067 --> 28:24:21.602
让我们继续，获取或创建一个项目机器人对象。

17229
28:24:21.602 --> 28:24:26.888
我们写入let item bot = item bot。load。

17230
28:24:26.888 --> 28:24:39.050
这就是我们加载一个项目的方式我们加载它的唯一ID通过调用这个getid from event params。load, getid from event params。

17231
28:24:39.050 --> 28:24:44.166
我们可以传递event。params。

17232
28:24:44.166 --> 28:24:51.495
那个令牌ID因为一个项目bot事件会有一个令牌ID和一个params事件。

17233
28:24:51.495 --> 28:24:52.478
nf T地址。

17234
28:24:52.478 --> 28:24:58.429
我知道我们可能应该先处理itemlists但我们先处理itembot。

17235
28:24:58.429 --> 28:25:05.305
既然我们买了一个物品，我们可能也会有一个活动物品，对吧?我们还没有列出一个项目。

17236
28:25:05.305 --> 28:25:07.553
这和我们对莫拉莱斯的处理是类似的。

17237
28:25:07.553 --> 28:25:13.462
所以我们知道，每当我们活着的时候，某些项目也会列出一个活动项目。

17238
28:25:13.462 --> 28:25:18.502
我们说，let激活项目等于加载的激活项目。

17239
28:25:18.502 --> 28:25:21.429
我们要做同样的事情。

17240
28:25:21.429 --> 28:25:24.379
我要复制粘贴到这里。

17241
28:25:24.379 --> 28:25:31.779
即使这些有完全相同的ID，也没关系因为它们在不同类型中是相同的ID。

17242
28:25:31.779 --> 28:25:41.368
现在我们会说，如果没有item bot，我们会说item bot =一个新的item bot对象。

17243
28:25:41.368 --> 28:25:50.757
我们会给它一个ID，也就是我们这里的ID赋值参数，从事件中获取ID，然后传递给那里。

17244
28:25:50.757 --> 28:25:53.183
我们要在这里创建一个新的物品。

17245
28:25:53.183 --> 28:25:55.816
现在我们要更新所有的参数。

17246
28:25:55.816 --> 28:25:58.387
回到我们的模式点图QL。

17247
28:25:58.387 --> 28:26:02.446
购买的物品有ID、买家地址、令牌ID和价格。

17248
28:26:02.446 --> 28:26:13.035
我们会说，itembought, buyer等于event。params。buyer, itembought。

17249
28:26:13.035 --> 28:26:16.368
T地址等于事件。

17250
28:26:16.368 --> 28:26:17.168
参数个数。

17251
28:26:17.168 --> 28:26:25.482
nf T地址，项目bot，点token ID =事件点params点token ID。

17252
28:26:25.482 --> 28:26:26.434
看起来不错。

17253
28:26:26.434 --> 28:26:34.164
我们的活动物品将来自于被列出的物品，被列出的物品会给它所有这些参数，除了它不会有买家。

17254
28:26:34.164 --> 28:26:37.924
所以我们只需要向买家更新我们的活动物品。

17255
28:26:37.924 --> 28:26:42.390
我们写上active item，点buyer，加上一个感叹号。

17256
28:26:42.390 --> 28:26:45.502
这是一些TypeScript的东西，表示我们将有一个活动项。

17257
28:26:45.502 --> 28:26:47.932
如果你不熟悉TypeScript，不要太担心。

17258
28:26:47.932 --> 28:26:52.312
我们说它等于event。params。buyer。

17259
28:26:52.312 --> 28:27:06.972
和Morales类似，我们会做item bot。save和带感叹号的活动item，也就是保存这就是我们将item bought事件保存为图形协议对象的方式。

17260
28:27:06.972 --> 28:27:09.382
同时，我们会更新活动项。

17261
28:27:09.382 --> 28:27:12.960
这是我们处理商品购买的完整功能。

17262
28:27:13.102 --> 28:27:25.823
每当有人买了一件物品，我们就更新一个新的物品购买对象，我们将活动物品更新为一个新的买家，我们不会从活动物品列表中删除它，我们只会用一个新的买家更新它。

17263
28:27:25.823 --> 28:27:29.102
我们会说如果它有买家，那就意味着它被买了。

17264
28:27:29.102 --> 28:27:32.987
如果没有买家，那就意味着它还在市场上。

17265
28:27:32.987 --> 28:27:33.511
太棒了。

17266
28:27:33.511 --> 28:27:41.049
现在我们已经完成了handle item bot，下面来做我们列出的handle item，这将使我们的handle item bot更容易理解。

17267
28:27:41.049 --> 28:27:44.315
对于handle itemlists，我们会在这里做相同的部分。

17268
28:27:44.315 --> 28:27:50.020
我们说，let itemlists = itemlists。load。

17269
28:27:50.020 --> 28:27:56.932
我们会做和所有这些完全一样的事情从事件params中获取ID。

17270
28:27:56.932 --> 28:27:59.495
像这样，获取一个不同的事件参数。

17271
28:27:59.495 --> 28:28:01.855
然后我们说，让激活项目。

17272
28:28:01.855 --> 28:28:05.659
这条线和上面这条线是一样的。

17273
28:28:05.659 --> 28:28:07.829
我只需要复制粘贴。

17274
28:28:07.829 --> 28:28:14.983
我们说，很好，抓取我们列出的项目，抓取我们的活动项目，看那些对象是否已经存在。

17275
28:28:14.983 --> 28:28:24.966
我会说如果没有item被列出，这是不应该的，我们会创建一个新的，我们说item lists = new item lists。

17276
28:28:24.966 --> 28:28:30.702
它的ID将来自我们创建的这个函数是唯一的ID。

17277
28:28:30.702 --> 28:28:41.843
现在，不像我们上面做的那样，我们还会说，如果没有活动项目，那么我们将创建一个新的活动项目，对吧?因为我们列出了一个项目，所以它不应该是一个活动项目。

17278
28:28:41.843 --> 28:28:48.610
现在这个功能在这里更有意义了，对吧?因为如果我们更新一个商品的价格，活动商品将已经存在。

17279
28:28:48.610 --> 28:28:52.835
但是，如果它是一个全新的列表，活动项目将不存在。

17280
28:28:52.835 --> 28:29:03.548
我们会说，如果它不存在，这意味着它是一个全新的列表，我们会说item lists = new item lists，然后我们会给它一个ID。

17281
28:29:03.548 --> 28:29:07.655
这是相同的ID方法，粘贴进去。

17282
28:29:07.655 --> 28:29:11.911
现在我们要做的就是更新这些新对象。

17283
28:29:11.911 --> 28:29:18.625
我写上item lists, seller = event。params。seller。

17284
28:29:18.625 --> 28:29:21.002
复制粘贴这一行。

17285
28:29:21.002 --> 28:29:24.836
因为这将是active item。seller。

17286
28:29:24.836 --> 28:29:28.456
哦，看到我，然后它就会变成这个活动项目。

17287
28:29:28.456 --> 28:29:30.714
活动项目而不是列出的项目。

17288
28:29:30.714 --> 28:29:38.018
列出的项目还包括什么?好了，让我们转到列出的具有非ft地址、令牌ID和价格的模式项。

17289
28:29:38.102 --> 28:29:41.477
好，我们把它们加起来。

17290
28:29:45.102 --> 28:29:46.213
=事件。

17291
28:29:46.213 --> 28:29:46.768
参数个数。

17292
28:29:46.768 --> 28:29:47.879
nf T地址。

17293
28:29:50.102 --> 28:29:54.711
因为它对活动项是完全一样的。

17294
28:29:55.102 --> 28:30:01.990
项目列出token ID = event。params。token ID。

17295
28:30:02.102 --> 28:30:03.640
复制粘贴这一行。

17296
28:30:03.640 --> 28:30:05.716
活动项目也是一样。

17297
28:30:07.102 --> 28:30:13.741
在价格，复制，粘贴这一行活动项目。

17298
28:30:13.741 --> 28:30:16.281
然后我们就说这两个。

17299
28:30:16.281 --> 28:30:20.835
保存活动项目的项目列表。

17300
28:30:20.835 --> 28:30:21.501
保存。

17301
28:30:21.501 --> 28:30:30.132
在我们的协议中，如果它已经是，如果已经有一个活动项，那么我们就继续，我们得到那个活动项。

17302
28:30:30.132 --> 28:30:32.964
这将是一个清单，我们正在更新。

17303
28:30:32.964 --> 28:30:34.757
如果没有，我们就做一个新的。

17304
28:30:34.757 --> 28:30:37.472
我们用通过事件传入的信息更新它。

17305
28:30:37.472 --> 28:30:39.972
然后我们把它保存到我们的图形协议中。

17306
28:30:39.972 --> 28:30:40.875
好的,完美的。

17307
28:30:40.875 --> 28:30:43.302
现在我们只剩下一个了，项目取消了。

17308
28:30:43.302 --> 28:30:48.052
我们来看看如何取消商品，这看起来和购买商品很像。

17309
28:30:48.102 --> 28:30:54.992
我们说，let item cancelled = item cancelled that load。

17310
28:30:55.102 --> 28:31:09.340
同样，我们会做相同的Id get我们会做所有的事情，我们会说，let active item =，我把它缩小一点active item = active item。load。

17311
28:31:09.340 --> 28:31:12.482
或者做同样的事情。

17312
28:31:12.482 --> 28:31:12.958
繁荣。

17313
28:31:12.958 --> 28:31:23.052
然后我们会说，if not item cancelled，这是不应该的因为这应该是这里唯一的item cancelled事件。

17314
28:31:23.102 --> 28:31:28.860
我们说item cancelled，等于new item cancelled。

17315
28:31:30.102 --> 28:31:33.343
用我们用过的相同的ID方法给它一个ID。

17316
28:31:33.343 --> 28:31:35.713
现在这个看起来有点不同。

17317
28:31:35.713 --> 28:31:42.136
我们会说item cancelled，那个seller等于event。params。seller。

17318
28:31:42.136 --> 28:31:43.791
到目前为止，一切顺利。

17319
28:31:43.791 --> 28:31:55.938
项目取消的。NFT地址=事件。params。NFT地址项目取消的。token ID =事件。params。token ID。

17320
28:31:55.938 --> 28:32:01.118
最后，我们要改变活动项与我们之前看到的稍微不同。

17321
28:32:01.118 --> 28:32:06.387
活动项目感叹号，如果你被那个点买家搞糊涂了，就忽略它。

17322
28:32:06.387 --> 28:32:12.985
我们将把buyer更新为equal address。fromstring。

17323
28:32:13.102 --> 28:32:15.843
我们会给它一个所谓的死亡地址。

17324
28:32:16.102 --> 28:32:18.690
就是这个。

17325
28:32:22.102 --> 28:32:37.784
产生718 1920 21到2到3到45到67到8930 3130 230-334-3536零小写d，大写E，小写A大写d，这被称为死地址。

17326
28:32:37.784 --> 28:32:42.477
这就是我们决定一件商品是否还在市场上的方法。

17327
28:32:42.477 --> 28:32:44.789
或者是否购买了某件物品。

17328
28:32:44.789 --> 28:32:49.972
如果我们有死亡地址作为买家，那就意味着物品已经被取消了。

17329
28:32:49.972 --> 28:32:56.640
这就是我们如何能够告诉一个项目是否在市场上或死亡地址意味着它被取消了。

17330
28:32:56.640 --> 28:33:01.736
空的地址，也就是句柄item所列出的情况，意味着它在市场上。

17331
28:33:01.736 --> 28:33:05.843
而真正的真实地址意味着它确实被某人买走了。

17332
28:33:05.843 --> 28:33:09.416
所以我们判断它是否在市场上的方法是，它是0x 0000000。

17333
28:33:09.416 --> 28:33:14.610
因为数据地址显然不等于全0。

17334
28:33:14.610 --> 28:33:30.151
数据地址是一种常用的地址类似于无人拥有的一次性地址，然后我们可以说，项目取消保存一个活动项目说活动项目，感叹号点保存和完美。

17335
28:33:30.151 --> 28:33:32.937
我们的映射文件现在已经完成。

17336
28:33:33.102 --> 28:33:42.049
现在我们有三个不同的函数来定义如何处理物品被购买的事件、如何处理物品被取消的事件和物品列出的事件。

17337
28:33:42.049 --> 28:33:47.602
如果你不明白，记住所有的代码都可以在我的GitHub的图形部分找到。

17338
28:33:47.602 --> 28:33:51.625
所以，如果你迷路或需要帮助，你可以跟着这里的代码走。

17339
28:33:51.625 --> 28:33:58.964
有了这些，我们就差不多准备好让子图开始监听契约了，我们至少还有一件事要做。

17340
28:33:58.964 --> 28:34:08.702
在子图。Yamo中，我们会看到源地址等等等等，这告诉我们开始索引Aetherium开始以来的事件。

17341
28:34:08.702 --> 28:34:20.152
现在我们不希望它这样做，因为这会花很长时间，我们想告诉我们的子图，你不能从时间的开始开始，你只需要从契约被部署之前开始。

17342
28:34:20.152 --> 28:34:25.757
我们可以添加起始块告诉它开始部署的块号是多少。

17343
28:34:25.757 --> 28:34:40.635
如果我们有地址，就在这里，我们可以复制它，粘贴到溜冰场费用，以太扫描，粘贴到这里，或者任何块资源管理器，我们会看到我们的合同部署的块号是多少。

17344
28:34:40.635 --> 28:34:42.977
看起来是这个街区。

17345
28:34:42.977 --> 28:34:50.031
我要复制那个地址，回到我的代码，写上起始块，它就在这里。

17346
28:34:50.102 --> 28:34:55.021
起始块是它被展开的时间，减1。

17347
28:34:55.102 --> 28:35:01.602
我们会在部署契约之前，开始读取任何被索引的事件。

17348
28:35:01.602 --> 28:35:18.237
现在，如果你部署了这个，它可能根本没有任何事件，我们马上就会解决这个问题，不要担心，但有了这个，所有关于如何构建子图的指令都准备好部署到图中了，开始我们的索引，开始在去中心化的上下文中使用我们的指令。

17349
28:35:18.237 --> 28:35:33.452
我们现在能做的是回到图中，我们这里有auth和deploy代码，我们可以复制这个，这个图auth破折号studio，这是关于如何部署的部署键。

17350
28:35:33.452 --> 28:35:35.502
我们可以在代码编辑器中运行它。

17351
28:35:35.502 --> 28:35:40.216
粘贴到这里，绘制dash studio，回车。

17352
28:35:40.216 --> 28:35:43.347
我们会说，这个图的部署键集。

17353
28:35:43.347 --> 28:35:52.053
这只是设置以便我们在推送代码时，它会推送到我们在他们网站上做的子图配置来帮助我们自动部署。

17354
28:35:52.102 --> 28:36:07.983
现在我们不需要输入子图，因为我们已经把东西往下移动了，我们会构建子图，我们会运行图代码Gen，我们可以运行图kojem，这将确保我们的schema。graph QL看起来很好。

17355
28:36:07.983 --> 28:36:10.966
然后我们要运行我们的图表构建。

17356
28:36:11.102 --> 28:36:18.802
这个图构建命令会编译并运行所有子图的东西，所有映射JSON的东西所有生成的代码。

17357
28:36:18.802 --> 28:36:24.392
它会把这个放到一个真正的构建文件夹中，生成的文件夹有点像一个伪构建文件夹。

17358
28:36:24.392 --> 28:36:26.182
然后我们有一个真正的构建文件夹。

17359
28:36:26.182 --> 28:36:29.584
生成的是为TypeScript构建一些类型。

17360
28:36:29.584 --> 28:36:35.721
这个构建文件夹，这个真正的构建文件夹，是我们要部署并发送到图中的东西。

17361
28:36:35.721 --> 28:36:38.387
我们可以展开子图。

17362
28:36:38.387 --> 28:36:40.798
现在，使用图形部署dash的studio。

17363
28:36:40.798 --> 28:36:48.856
如果市场，也就是我们现在要运行的，会给我们一个版本标签选项，我们会给它0。

17364
28:36:48.856 --> 28:36:58.568
零点一，因为这是我们的第一个版本，它会继续并开始将它部署到图中，我们也会上传我们的子图到IPFS。

17365
28:36:58.568 --> 28:37:03.508
我们在这里有一个小哈希是IPFS的子图我们可以看一下。

17366
28:37:03.508 --> 28:37:07.515
但如果你成功了，我们就完成了这个构建。

17367
28:37:07.515 --> 28:37:11.512
我们有这些用于查询和订阅的子图端点。

17368
28:37:11.512 --> 28:37:16.031
我们可以开始查询和订阅子图。

17369
28:37:16.102 --> 28:37:23.784
回到我们的网站，点击刷新，我们可以看到状态部署，我们可以看到我们正在下沉。

17370
28:37:23.784 --> 28:37:30.479
现在我们有一些节点在监听我们要在这里发出的事件，这非常令人兴奋。

17371
28:37:30.479 --> 28:37:32.892
我们可以查看日志，看看是否出了什么问题。

17372
28:37:32.892 --> 28:37:35.263
现在它只是在索引，在监听。

17373
28:37:35.263 --> 28:37:39.829
它正在通过区块链的所有不同区块，监听我们的事件。

17374
28:37:39.829 --> 28:37:51.373
然后我们在这里有一个游乐场，在那里我们可以运行一些查询，从我们的Graph QL中查看不同的事件和不同的响应，现在，它是完全空白的，因为我们还没有做任何事情。

17375
28:37:51.373 --> 28:37:58.808
所以，再一次，让我们拿出我们的安全帽和ft市场代码，或在一个新的终端打开它，无论你想做什么。

17376
28:37:58.808 --> 28:38:02.898
让我们继续，让我们运行mminton列表脚本。

17377
28:38:02.898 --> 28:38:12.292
但对于溜冰场B，我们会做yarn, hard hat, run scripts, mint，和列表项dash network Rinkeby。

17378
28:38:12.292 --> 28:38:19.610
所以我们要创造一个NFT，对吧，这是一个交易，所以我们要等一会儿，然后我们要批准NFT。

17379
28:38:19.610 --> 28:38:21.566
然后我们会把它上市。

17380
28:38:21.566 --> 28:38:25.135
一旦它被列出，它就会发出一个itemlists事件。

17381
28:38:25.135 --> 28:38:30.610
现在我们应该看到，在Graph QL中有一个活动项和一个列出数据的项。

17382
28:38:30.610 --> 28:38:36.803
现在您可以了解更多关于左边所看到的是所谓的Graph QL查询。

17383
28:38:36.803 --> 28:38:41.055
现在，我们不打算讲如何做这些，但我会在GitHub存储库中留下一些链接。

17384
28:38:41.055 --> 28:38:45.323
如果你想学习如何做更多这样的查询，这些将与我们在莫拉莱斯中看到的类似。

17385
28:38:45.323 --> 28:38:48.189
但它们不是常规的表查找。

17386
28:38:48.189 --> 28:38:56.056
它们是Graph QL语法的，我们的查询结果，在这里，我们可以看到更多关于模式的信息一直到右边。

17387
28:38:56.103 --> 28:39:02.769
但是如果我们看看我们的代码，现在，我们已经获得了NFT的批准我们已经在我们的市场上上市了。

17388
28:39:02.769 --> 28:39:14.492
现在如果我们回到这个图表，我们运行这个查询，我们在我们的非ft市场上做一点刷新，我们可能要等几分钟图表才能索引这些新块。

17389
28:39:14.492 --> 28:39:18.199
但是在我们的操场上，我们应该把show看作一个查询。

17390
28:39:18.199 --> 28:39:30.916
如果你没有自动得到这些你可以暂停视频把这些写进你的Graph QL游乐场，对吧?所以几分钟后，刷新以太扫描，我可以看到列表项交易已经通过。

17391
28:39:30.916 --> 28:39:33.424
这意味着我们已经触发了一个新事件。

17392
28:39:33.424 --> 28:39:40.040
如果我回到操场，点击这里的play，天哪，我们可以看到活动项目。

17393
28:39:40.040 --> 28:39:41.977
我们看到我们列出了项目。

17394
28:39:42.103 --> 28:39:43.149
这太棒了。

17395
28:39:46.103 --> 28:39:56.083
一个链下服务，它为我们的合同索引我们的事件，这样我们就可以更新我们的前端，我们可以以去中心化的方式更新人员。

17396
28:39:56.083 --> 28:39:58.828
这太令人兴奋了。

17397
28:39:59.103 --> 28:40:07.656
太棒了，现在我们都设置好了，我们终于可以回到我们的下一个JS项目或下一个Jas非ft市场FCC图。

17398
28:40:07.656 --> 28:40:18.431
我们这么做的原因是，在我们的下一个Jas非ft Marketplace应用程序的代码库中，我们正在从Morales数据库中读取数据，我们将不再这样做。

17399
28:40:18.431 --> 28:40:28.780
我们不从莫拉莱斯数据库中读取数据，而是从图中读取数据，我们来学习一下如何更新代码index。j, s来从图中读取数据。

17400
28:40:28.780 --> 28:40:36.275
为了突出显示这个，我们要创建一个新页面，一个新文件，我们将它命名为graph example。j s。

17401
28:40:36.275 --> 28:40:42.822
我们会让这个页面变得非常简洁来展示如何进行图形查询。

17402
28:40:42.822 --> 28:40:49.585
类似于index。j, s，我们要做一个导出默认图形的例子。

17403
28:40:49.585 --> 28:40:54.551
这是一个函数，或者默认函数，图的例子。

17404
28:40:54.551 --> 28:40:58.349
我们将使用阿波罗客户端工具，复制粘贴过来。

17405
28:40:58.349 --> 28:41:10.053
我们将用纱线添加它，在P O ll O添加破折号dev，斜杠，客户端，不好意思，不是dev，因为我们在前端需要这个。

17406
28:41:10.053 --> 28:41:12.686
所以纱线添加在阿波罗斜杠客户端。

17407
28:41:12.686 --> 28:41:18.636
哦，抱歉，我们还需要做yarn，添加Graph QL，我们需要添加这两个。

17408
28:41:18.636 --> 28:41:24.740
这是Apollo斜杠客户端，我们将通过它对新创建的图表进行查询。

17409
28:41:24.740 --> 28:41:24.998
QL。

17410
28:41:24.998 --> 28:41:35.496
我们会说，从这个刚刚安装的包导入use query hook从P O ll O客户端。

17411
28:41:35.496 --> 28:41:37.709
我们还会导入gql。

17412
28:41:37.709 --> 28:41:46.436
要创建一个新查询，我们说const, get active item = gql。

17413
28:41:46.436 --> 28:41:48.969
我们在这里加上这个反勾。

17414
28:41:48.969 --> 28:41:54.516
我们会把所有的Graph QL的东西都加进去，这和这个是等价的，这是Graph QL。

17415
28:41:54.516 --> 28:41:54.878
语法。

17416
28:41:54.878 --> 28:41:59.136
我们将把这个Graph QL语法放到我们的代码库中。

17417
28:41:59.136 --> 28:42:01.723
但我们只想得到活性项。

17418
28:42:01.723 --> 28:42:10.660
那么我们如何得到活性物质呢?我们可以先把它建在操场上，然后把它添加到代码库中。

17419
28:42:10.660 --> 28:42:27.035
我们会说我们想要抓取活动物品，我们会抓取前5个，然后我们会说买家的位置是0x 12345678。

17420
28:42:27.035 --> 28:42:29.627
我们说的是买家是空的。

17421
28:42:29.627 --> 28:42:47.918
我们抓取没有买家的活动物品，然后我们会然后我们会得到ID，买家，卖家，非ft地址，代币，ID和从中得到的价格。

17422
28:42:47.918 --> 28:42:52.730
如果我们点击运行，我们在这里得到活动项。

17423
28:42:52.730 --> 28:43:02.997
这里，买家是0x12345678因为没有买家时，它会被默认为0。

17424
28:43:02.997 --> 28:43:07.119
这就是为什么取消项目，我们更新买家的死亡地址。

17425
28:43:07.119 --> 28:43:09.321
如果它被买了，它就不再活跃了。

17426
28:43:09.321 --> 28:43:12.568
如果它被取消，它也将不再活跃。

17427
28:43:12.568 --> 28:43:17.134
现在，我们可以复制这个查询并将其粘贴到代码中。

17428
28:43:17.134 --> 28:43:22.189
现在我们有了一个可以用于图形示例的Graph QL查询。

17429
28:43:22.189 --> 28:43:25.945
在我们的图形示例中，我们将使用这个查询和这个使用查询钩子。

17430
28:43:25.945 --> 28:43:29.748
在export default函数，图的例子中，我们可以说const。

17431
28:43:29.748 --> 28:43:37.540
它附带了一大堆东西，比如加载错误，然后返回的数据等于，使用查询。

17432
28:43:37.540 --> 28:43:46.264
然后我们会传递这个Get active item，或者Get active items，我们在上面加个S, Get active items。

17433
28:43:46.264 --> 28:43:50.909
然后我们可以返回一个小div。

17434
28:43:51.103 --> 28:43:54.737
在div中输入hi，然后输入console。log data。

17435
28:43:54.737 --> 28:43:57.752
然后回到我们的应用程序。

17436
28:43:57.752 --> 28:44:04.103
js中，我们将所有内容包装到Morales提供程序中，我们还需要将所有内容包装到Apollo提供程序中。

17437
28:44:04.103 --> 28:44:12.769
我们需要初始化它类似于初始化连接到士气服务器的方式，但我们要初始化连接到Graph QL。

17438
28:44:12.769 --> 28:44:34.971
我们会说导入一个po ll O提供者，一个po ll O客户端，在内存中，缓存来自po ll O斜杠客户端，像这样，然后我们需要初始化这个，这样我们就可以删除士气这些东西。

17439
28:44:34.971 --> 28:44:41.819
我们通过写上const client = new a P O LL来初始化这个客户机。

17440
28:44:41.819 --> 28:44:44.837
O客户端，我们会在这里给它参数。

17441
28:44:44.837 --> 28:45:01.790
你们可以在阿波罗客户端文档中找到这些会说，当我们进行刷新等操作时，会有一个缓存来帮助我们在内存缓存中写入new，我们会写入逗号URI，一个我们要连接的地方。

17442
28:45:01.790 --> 28:45:04.796
这就是我们要为子图添加API的地方。

17443
28:45:04.796 --> 28:45:15.619
如果我们回到细节，我们可以看到临时查询URL这是一个速率限制的临时查询，因为这只是一个测试网，我们要复制这个，回到我们的代码。

17444
28:45:15.619 --> 28:45:16.941
我们把它粘贴到这里。

17445
28:45:16.941 --> 28:45:23.534
不管你有什么临时查询URL，还有你的子图形工作室，这就是你要粘贴到这里的地方。

17446
28:45:23.534 --> 28:45:28.436
现在，这个客户机告诉我们的Graph QL，它应该在哪里执行这些查询。

17447
28:45:28.436 --> 28:45:29.959
我们会走到这里的。

17448
28:45:29.959 --> 28:45:31.441
这要从HTTPS说起。

17449
28:45:31.441 --> 28:45:37.295
这是中心化的吗?是的，因为我们直接调用了图形网站。

17450
28:45:37.295 --> 28:45:42.835
然而，所有的数据仍然会存储在这个分散的图索引器中。

17451
28:45:42.835 --> 28:45:51.436
类似于我们对IPFS所做的，我们把它作为一个入口，让我们更容易连接和从图形工作室读取数据。

17452
28:45:51.436 --> 28:46:10.971
然而，在未来，随着更多的协议和浏览器采用图和IPFS，这在Morales提供程序内部会变得容易得多，但在通知提供程序外部，我们会说P O ll O提供程序，然后客户端等于客户端。

17453
28:46:11.103 --> 28:46:17.103
然后我们复制结束标签，把它放在通知提供程序周围，然后按Save。

17454
28:46:17.103 --> 28:46:19.944
现在我要拯救我们的前端，现在我们要试着跑我们的前端。

17455
28:46:19.944 --> 28:46:23.040
我们得改变一下这里的一些东西因为它要崩溃了。

17456
28:46:23.040 --> 28:46:26.711
所以我们要运行纱线Dev，为新前端。

17457
28:46:26.711 --> 28:46:28.817
我们会到本地主机3000。

17458
28:46:28.817 --> 28:46:32.864
它会完全崩溃的，因为我们这里还有一些鼓舞士气的东西。

17459
28:46:32.864 --> 28:46:34.053
这完全没问题。

17460
28:46:34.053 --> 28:46:36.490
当然，我们不需要一个运行的硬帽节点。

17461
28:46:36.490 --> 28:46:41.348
因为我们在一个测试网上，我们不需要和莫拉莱斯同步，我们不需要做任何那些事情。

17462
28:46:41.348 --> 28:46:45.995
因为我们正在使用一个测试网，现在，它实际上没有崩溃，这很好。

17463
28:46:45.995 --> 28:46:48.430
但它显然没有显示最近上市。

17464
28:46:48.430 --> 28:46:55.275
我们现在要做的是斜杠，图形例子，然后回车。

17465
28:46:55.275 --> 28:46:57.740
我们可以看到嗨，出现。

17466
28:46:57.740 --> 28:47:14.150
但如果我们去检查，我们去控制台，这里有一个控制台，我们可以看到一个活动物品的对象，它从图中返回，有买家ID，非ft，地址价格，所有这些都在空中。

17467
28:47:14.150 --> 28:47:15.007
这太棒了。

17468
28:47:15.103 --> 28:47:15.955
好吧，好吧。

17469
28:47:15.955 --> 28:47:16.282
好的。

17470
28:47:19.103 --> 28:47:19.545
更新。

17471
28:47:19.545 --> 28:47:21.561
让我们继续，我们将关闭服务器。

17472
28:47:22.103 --> 28:47:27.941
我们要做的是更新，而不是使用mirallas query，我们要删除这个。

17473
28:47:27.941 --> 28:47:31.070
我们将从Apollo查询从Graph QL查询。

17474
28:47:31.070 --> 28:47:39.909
其他的都保持不变，对吧?因为我们的非ft框，以及我们使用过的所有其他代码，仍然会完全相同地工作。

17475
28:47:39.909 --> 28:47:41.401
首先，我们得找到我们的地址。

17476
28:47:41.401 --> 28:47:47.803
我们会说导入，和Sell一样，Sell NFT，导入网络映射，我要复制它。

17477
28:47:47.803 --> 28:47:51.857
我们将从常量导入network mapping network mapping。JSON。

17478
28:47:51.857 --> 28:47:54.695
现在我们可以说const。

17479
28:47:54.695 --> 28:48:10.636
集市，地址等于，我们会用完全相同的方式，把非ft卖给，我们会抓取这一行，获取链字符串，我们会把它粘贴到这里，这意味着我们需要从用户Morales获取链ID。

17480
28:48:10.636 --> 28:48:13.922
然后我们要像这样得到市场地址。

17481
28:48:13.922 --> 28:48:16.524
我们复制这一行，粘贴到这里。

17482
28:48:16.524 --> 28:48:17.155
好了,好了。

17483
28:48:17.155 --> 28:48:19.769
现在我们有了市场地址。

17484
28:48:19.769 --> 28:48:22.926
现在我们要做const。

17485
28:48:23.103 --> 28:48:27.167
加载错误数据，我们可以列出。

17486
28:48:29.103 --> 28:48:34.245
等于，使用查询，我们可以获取活动项。

17487
28:48:35.103 --> 28:48:47.022
我要做的是创建一个新文件和常量，我们要在新文件中传递get active items这个东西，我们叫它subgraph queries。j s。

17488
28:48:47.103 --> 28:48:51.303
然后这里，我们会输入gql。

17489
28:48:53.103 --> 28:48:54.526
降低客户端。

17490
28:49:00.103 --> 28:49:01.151
g QL反勾。

17491
28:49:05.103 --> 28:49:09.699
回到图的例子，我们复制粘贴到这里的整行。

17492
28:49:09.699 --> 28:49:15.703
现在我们只需要export default，获取活动项。

17493
28:49:15.703 --> 28:49:22.960
我们将把这个查询从子图查询导入到索引。js中。

17494
28:49:22.960 --> 28:49:34.838
我们会说，import, get active queries are skimming apt get active items from。。

17495
28:49:34.838 --> 28:49:42.103
现在在我们的use查询中将传递Get活动项，它应该返回列出的NF t。

17496
28:49:42.103 --> 28:49:53.214
现在，我们把这个从获取列出的nft变成加载，加载，或者我们没有列出的nft。

17497
28:49:53.214 --> 28:50:05.364
如果它在加载，或者我们没有监听TS然后执行加载，否则，我们会做另一个映射，但Graph QL的返回会有点不同。

17498
28:50:05.364 --> 28:50:15.447
不列出MTS。map，而是列出NF T。AQ两个有物品，点映射和f T，然后我们得到价格。

17499
28:50:15.447 --> 28:50:21.603
如果地址令牌ID，我们不会得到市场地址，但我们会从NFT得到卖家。

17500
28:50:21.603 --> 28:50:24.136
它不会返回属性。

17501
28:50:24.136 --> 28:50:26.764
我们可以用console。log NFT代替。

17502
28:50:26.764 --> 28:50:32.413
然后我们就像之前一样，把所有的东西，正常地传递到非ft框。

17503
28:50:32.413 --> 28:50:51.918
我们我们做的一切都是真的,我们这里换掉查询方法,价格将会从价格价格是查询,和英国《金融时报》的地址将会从查询令牌ID从查询市场地址,这也是会略有不同,我们会得到从我们自己的配置卖方将从查询,然后关键是要从查询。

17504
28:50:51.918 --> 28:51:08.038
现在如果我们保存它，如果我们用yarn Dev重新启动我们的网站，回到我们的主页，我们应该会看到一切都是一样的，除了图片是从图表中提取的，而不是从Alice那里提取的。

17505
28:51:08.103 --> 28:51:12.395
让我们回到我们的前端，我们给它一个很好的刷新，关闭控制台。

17506
28:51:12.395 --> 28:51:14.179
我们将进入我们的主页。

17507
28:51:14.179 --> 28:51:16.824
我忘了使用查询。

17508
28:51:16.824 --> 28:51:24.361
我们从Paulo斜杠客户端导入使用查询。

17509
28:51:24.361 --> 28:51:28.884
保存一下，返回来刷新一下。

17510
28:51:28.884 --> 28:51:38.004
哦，天哪，我们现在更新了，从分散的数据结构中获取事件。

17511
28:51:38.103 --> 28:51:40.085
太棒了。

17512
28:51:43.103 --> 28:51:52.531
很快地，我们在我们的非ft框中使用图像标签，我们在这里使用下一个Jas的图像标签，它带有一些预处理。

17513
28:51:52.531 --> 28:51:54.287
在IPFS上使用有点困难。

17514
28:51:54.287 --> 28:51:58.182
因此，我们需要更新我们处理图像的方式，以便在IPFS上托管它。

17515
28:51:58.182 --> 28:51:59.769
但我们仍然可以这样做。

17516
28:51:59.769 --> 28:52:05.499
我们还有其他选项，比如Morales，我们甚至可以在Morales上托管我们的应用。

17517
28:52:05.499 --> 28:52:11.906
我们还可以使用for cell或Netlify等，或者其他任何传统的集中式主机服务。

17518
28:52:11.906 --> 28:52:17.836
现在，如果您愿意，我建议您更新这段代码，使其能够驻留在IPFS上。

17519
28:52:17.836 --> 28:52:20.460
这样你就有了一个端到端的去中心化。

17520
28:52:20.460 --> 28:52:29.119
如果市场首先想对这段代码做一个PR，这样它就可以成功地完全端到端托管在IPFS获胜和空为我。

17521
28:52:29.119 --> 28:52:29.506
但哇。

17522
28:52:29.506 --> 28:52:32.169
这样我们就完成了少于15的任务。

17523
28:52:32.169 --> 28:52:35.960
这绝对是一个巨大的成就。

17524
28:52:35.960 --> 28:52:42.436
如果你完成了这个，如果你理解了所有的内容，如果你已经完成了目前为止的所有内容，你应该为自己感到无比自豪。

17525
28:52:42.436 --> 28:52:48.332
因为这是我们最后一个全栈部分，我们的前端部分你现在是一个全栈怪物了。

17526
28:52:48.332 --> 28:52:52.516
恭喜你，你应该非常非常非常骄傲。

17527
28:52:52.516 --> 28:52:59.139
一定要休息一下，去喝杯咖啡，为1617和18课的最后一部分做准备。

17528
28:52:59.139 --> 28:53:01.453
这些会过得快一点。

17529
28:53:01.453 --> 28:53:12.203
我很高兴你能休息一下，到时候见。

17530
28:53:13.103 --> 28:53:21.277
好了，欢迎来到第六课第十课，我们将学习更低级的代码。

17531
28:53:21.277 --> 28:53:27.296
当然，按照惯例，我们的整个GitHub存储库都位于这里。

17532
28:53:27.296 --> 28:53:30.366
另外，我们还有一个可选的视频供你观看。

17533
28:53:30.366 --> 28:53:36.553
如果你想了解更多，我们将观看一段视频来解释可升级的智能合约。

17534
28:53:36.553 --> 28:53:37.403
让我们开始吧。

17535
28:53:37.403 --> 28:53:45.052
现在我在拍完这个视频很久之后才开始编辑这个视频，这就是为什么我有胡子，所以我会时不时地插入更新一些部分。

17536
28:53:45.103 --> 28:53:47.418
在链上部署智能合约时。

17537
28:53:48.103 --> 28:53:50.857
这些智能合约是不可变的。

17538
28:53:51.103 --> 28:53:57.289
如果我告诉你它们是不可变的呢?严格来说，这是不对的。

17539
28:53:57.289 --> 28:54:00.393
然而，智能合约实际上随时都可能发生变化。

17540
28:54:00.393 --> 28:54:05.293
当人们转让代币时，当人们入股合同时，或真正执行任何类型的功能时。

17541
28:54:05.293 --> 28:54:10.293
这些智能合约必须更新它们的余额、更新它们的映射和更新它们的变量来反映这一点。

17542
28:54:10.293 --> 28:54:16.065
它们不可变的原因是逻辑本身永远不会改变，并且会永远这样在链上。

17543
28:54:16.065 --> 28:54:19.021
所以从技术上讲，是的，一旦它们被部署，它们就是不可变的。

17544
28:54:19.021 --> 28:54:25.758
这实际上是智能合约的主要好处之一，一旦我们部署了智能合约，就没有人能篡改或破坏它。

17545
28:54:25.758 --> 28:54:34.296
然而，如果我们想要升级智能合约或协议来做更多的事情，或者想要修复一些明显的bug或问题，这就会成为一个问题。

17546
28:54:34.296 --> 28:54:39.424
现在，即使我们不能改变部署到一个地址的特定代码，我们实际上可以做的比你想象的多得多。

17547
28:54:39.424 --> 28:54:44.054
在本视频中，我们将解释升级智能合约背后的不同方法。

17548
28:54:44.103 --> 28:54:54.903
然后我们将向你们展示如何使用头盔和打开齐柏林飞艇大声喊出许多齐柏林飞艇和三叶虫的开放文章，它们帮助我整理了这个视频以及许多其他来源和描述中的链接。

17549
28:54:54.903 --> 28:54:56.103
让我们开始吧。

17550
28:54:56.103 --> 28:55:06.103
乍一看，你可能会想，如果你能升级智能合约，那么它们就不是不可变的在某种程度上你是对的。

17551
28:55:06.103 --> 28:55:17.916
所以，在解释我们可以在这里使用的不同的哲学和模式时，我们确实需要了解每一种模式的哲学和去中心化含义，因为它们都有不同的优点和缺点。

17552
28:55:17.916 --> 28:55:21.878
是的，这里的一些缺点会影响中心性。

17553
28:55:21.878 --> 28:55:22.910
所以我们要记住这一点。

17554
28:55:22.910 --> 28:55:29.923
这就是为什么在你开始部署可升级的智能合约之前，你必须先了解其中的利弊。

17555
28:55:29.923 --> 28:55:33.366
我们将讨论三种不同的方式来升级智能合约。

17556
28:55:33.366 --> 28:55:51.416
第一个是用非斜杠参数绑定的方法来升级你的智能合约，社会迁移方法，然后是你可能听说过的方法，那就是代理，它有很多子类，比如变形合约，透明可升级代理，和通用可升级代理。

17557
28:55:51.416 --> 28:55:56.577
我们来谈谈非升级方法，或者参数化方法，或者随便你怎么称呼它。

17558
28:55:56.577 --> 28:56:00.104
这是考虑升级智能合约的最简单方法。

17559
28:56:00.104 --> 28:56:02.530
它并没有升级我们的智能合约。

17560
28:56:02.530 --> 28:56:09.554
因为我们不能真正改变智能合约的逻辑，不管我们写了什么逻辑，我们也可以添加新的存储或状态变量。

17561
28:56:09.554 --> 28:56:11.504
所以这并不是真正的升级。

17562
28:56:11.504 --> 28:56:22.437
但升级需要考虑的是参数化，我们部署的所有逻辑都在那里，这就是我们与这个函数交互的地方意味着我们有一大堆setter函数。

17563
28:56:22.437 --> 28:56:23.974
我们可以更新某些参数。

17564
28:56:23.974 --> 28:56:30.043
比如我们有一个奖励参数，每年以1%的利率发放代币。

17565
28:56:30.104 --> 28:56:34.687
也许我们有一个setter函数，它说，嘿，把这个更新为2%，或者把那个更新为4%。

17566
28:56:34.687 --> 28:56:37.416
它只是一个改变变量的setter函数。

17567
28:56:37.416 --> 28:56:41.507
这里的优点，很明显，实现起来很简单。

17568
28:56:41.507 --> 28:56:55.530
缺点是，如果你在第一次部署智能合约时，没有考虑到一些逻辑或功能，那就太糟糕了，你被它困住了，你无法更新逻辑或真正更新参数化的任何东西，也就是方法。

17569
28:56:55.530 --> 28:57:02.476
另一件你需要考虑的事是谁是管理员，谁有权访问这些setter函数和这些更新函数。

17570
28:57:02.476 --> 28:57:06.290
如果是一个人，你猜怎么着，你有一个集中式智能合约。

17571
28:57:06.290 --> 28:57:10.354
当然，现在可以添加治理契约作为协议的管理契约。

17572
28:57:10.354 --> 28:57:12.661
这是一种去中心化的方式。

17573
28:57:12.661 --> 28:57:19.419
记住，你可以用这个方法只需要一个治理协议另一个例子可能是契约注册表。

17574
28:57:19.419 --> 28:57:30.151
这是ABA早期版本在调用函数之前使用的东西，你会检查合约注册表它被某人更新为参数你会被路由到合约，然后在那里调用。

17575
28:57:30.151 --> 28:57:36.881
同样，这确实不允许我们在这里拥有升级的全部功能，你可以争辩说这个注册表是后期版本的混合。

17576
28:57:36.881 --> 28:57:41.491
但无论如何，这并没有给我们提供我们想要的升级的灵活性。

17577
28:57:41.491 --> 28:57:46.304
但有些人甚至可能认为，升级智能合约正在破坏体面的现实。

17578
28:57:46.304 --> 28:57:51.294
智能合约如此强大的原因之一就是它是不可变的，这是它的好处之一。

17579
28:57:51.294 --> 28:57:57.776
有些人认为你不应该添加任何自定义或可升级性，你应该部署你的契约。

17580
28:57:57.776 --> 28:57:58.758
就这样了。

17581
28:57:58.758 --> 28:58:08.158
Trilobites认为，如果你在部署合同时，知道它以后不能更改，你就会多花一点时间，确保一切都是正确的。

17582
28:58:08.158 --> 28:58:14.087
而且通常安全漏洞更少因为你只是设置它忘记它，不再看它。

17583
28:58:14.087 --> 28:58:26.039
现在，如果我想用这个理念来升级一个智能合约，我想让我的智能合约保持不变的理念，我们可以用社会迁移方法，我之前叫它Eat方法。

17584
28:58:26.039 --> 28:58:27.572
现在我觉得没那么好笑了。

17585
28:58:27.572 --> 28:58:37.140
我们会继续讲社会迁移，也就是社会饮食法，或者说迁移法是指你部署新契约，与旧契约没有任何联系。

17586
28:58:37.140 --> 28:58:44.246
按照社会惯例，你告诉所有人，嘿，嘿，这个新合同，这个我们刚刚部署的新合同?是啊，这是真的了。

17587
28:58:44.246 --> 28:58:51.071
按照惯例，人们迁移到使用这个新软件时，升级就完成了，因此我的俚语名称是social yeet。

17588
28:58:51.104 --> 28:58:57.831
因为你用了第一个移到第二个。

17589
28:58:58.104 --> 28:58:59.014
我觉得我很有趣。

17590
28:59:01.104 --> 28:59:03.858
总是说，嘿，这是我们的不可变智能合约。

17591
28:59:04.104 --> 28:59:05.054
这是我们的新产品。

17592
28:59:07.104 --> 28:59:17.379
不可变，因为你不给它任何升级的方法，如果有人在5万年后调用契约，它的响应是完全一样的。

17593
28:59:17.379 --> 28:59:22.170
另一个巨大的缺点是你必须有一个全新的合同地址。

17594
28:59:22.170 --> 28:59:29.942
因此，如果你是一个ERC 20代币，例如，你必须说服所有的交易所列出你的新合同地址作为实际地址。

17595
28:59:29.942 --> 28:59:34.998
记住，当我们这样做的时候，我们必须把第一个的状态移到第二个。

17596
28:59:34.998 --> 28:59:45.039
例如，如果一个ERC令牌移动到该ERC令牌的新版本，你必须有一种方法从第一个契约中获取所有映射并将其移动到第二个契约中。

17597
28:59:45.039 --> 28:59:47.776
显然，有很多方法可以做到这一点，因为所有东西都在链上。

17598
28:59:47.776 --> 28:59:56.504
但如果你有100万个转帐电话，我不想编写一个脚本来更新每个人的余额并计算每个人的余额，这样我就可以迁移到我的新版本的合同。

17599
28:59:56.504 --> 28:59:59.213
所以这里有很多社会习俗方面的工作要做。

17600
28:59:59.213 --> 29:00:04.815
Trilobites写了一篇很棒的博客关于从v1升级到v2等等。

17601
29:00:04.815 --> 29:00:11.246
在这个eat方法中他们给出了很多步骤来移动你的存储和状态变量到新的契约中。

17602
29:00:11.246 --> 29:00:13.265
如果你想阅读，请在描述中链接。

17603
29:00:13.265 --> 29:00:14.483
现在让我们开始我们的高价项目。

17604
29:00:14.483 --> 29:00:31.270
因此，为了拥有真正强大的升级心态或理念，我们需要某种类型的方法或框架，能够更新我们的状态，保持我们的合同地址，并允许我们以一种简单的方式更新智能合同中的任何类型的逻辑，这将导致我们的大项目是代理。

17605
29:00:31.270 --> 29:00:37.483
我们的大项目是什么?代理,代理。

17606
29:00:37.483 --> 29:00:47.476
代理是最真实的升级形式，因为用户可以通过这些代理继续与协议交互，甚至不会注意到任何更改或更新。

17607
29:00:47.476 --> 29:00:50.925
现在，这些也是你最容易搞砸的地方。

17608
29:00:50.925 --> 29:00:53.519
代理使用大量低级功能。

17609
29:00:53.519 --> 29:00:56.733
最主要的是委托调用功能。

17610
29:00:56.733 --> 29:01:04.878
委托调用是一个低级函数，目标契约中的代码在调用契约的上下文中执行。

17611
29:01:04.878 --> 29:01:07.722
message。sender和message。value也不变。

17612
29:01:07.722 --> 29:01:09.367
你们明白委托调用的意思了吧。

17613
29:01:09.367 --> 29:01:10.314
现在,对吗?太好了。

17614
29:01:10.314 --> 29:01:20.357
在英语中，这意味着如果我从合同a委托调用合同B中的函数，我将在合同a中执行合同B的逻辑。

17615
29:01:20.357 --> 29:01:30.639
如果缩并B有一个函数说，嘿，把这个值存储在上面的一个变量中，我要把这个变量存储在缩并a中，这就是幂函数。

17616
29:01:30.639 --> 29:01:44.104
这与回退功能相结合，允许我们通过代理合同地址将所有调用委托给其他合同，这意味着我可以拥有一个代理合同，它将永远拥有相同的地址。

17617
29:01:44.104 --> 29:01:57.804
我可以指向和路由人们到正确的实现契约，它具有逻辑，每当我想要升级时，我只需要部署一个新的实现契约并将我的代理指向那个新的实现。

17618
29:01:57.804 --> 29:02:11.069
现在，每当用户调用代理契约上的函数时，我就会把它委托给新契约，我可以只调用代理契约上的管理函数，我们叫它upgrade什么的然后我让所有的契约调用都指向这个新契约。

17619
29:02:11.069 --> 29:02:15.056
当我们讨论代理时，我们需要记住四个术语。

17620
29:02:15.056 --> 29:02:16.817
首先是实施合同。

17621
29:02:16.817 --> 29:02:20.879
实现契约包含我们的所有逻辑和协议的所有部分。

17622
29:02:20.879 --> 29:02:29.297
每当我们升级时，我们实际上启动一个全新的实现契约，代理契约的代理指向哪个实现是正确的。

17623
29:02:29.297 --> 29:02:42.765
并将每个人的调用路由到正确的实现契约，你可以认为代理契约位于用户的实现之上，用户将通过代理契约进行契约和函数调用。

17624
29:02:42.765 --> 29:02:49.523
然后是某种类型的管理员，管理员将决定何时升级和指向哪个合约。

17625
29:02:49.523 --> 29:03:00.038
在这个场景中，关于代理和委托调用的另一件很酷的事情是，我的所有存储变量都将存储在代理契约中，而不是存储在实现契约中。

17626
29:03:00.104 --> 29:03:05.934
这样，当我升级到一个新的逻辑契约时，我的所有数据都将保留在代理契约上。

17627
29:03:05.934 --> 29:03:17.304
所以每当我想要更新我的逻辑，只要指向一个新的实现契约，如果我想要添加一个新的存储变量或一种新的存储类型，我只要把它添加到我的逻辑契约中，代理契约就会接收它。

17628
29:03:17.304 --> 29:03:19.349
现在，使用代理有一些问题。

17629
29:03:19.349 --> 29:03:20.717
我们来谈谈这些陷阱。

17630
29:03:20.717 --> 29:03:27.088
然后我们将讨论不同的代理合同方法，因为是的，也有很多代理合同方法。

17631
29:03:27.088 --> 29:03:31.604
这就是为什么三叶虫不建议为你的智能合约使用可升级的代理。

17632
29:03:31.604 --> 29:03:35.009
因为他们充满了很多潜在的问题。

17633
29:03:35.009 --> 29:03:40.546
更不用说，您仍然有一些类型的管理员将升级您的智能合约。

17634
29:03:40.546 --> 29:03:43.844
现在，如果这是一个治理协议，那么很好，你是去中心化的。

17635
29:03:43.844 --> 29:03:47.646
但如果这是一个单独的团体或实体，那我们就有问题了。

17636
29:03:47.646 --> 29:03:53.834
最大的两个问题是存储、冲突和函数选择器冲突。

17637
29:03:53.834 --> 29:04:00.488
这是什么意思呢?当我们使用委托调用时，记住，我们在契约a中执行契约B的逻辑。

17638
29:04:00.488 --> 29:04:15.222
如果合约B说我们需要将值设为2，我们就会将值设为智能合约的愚蠢之处，我们会将值设为合约B中相同存储位置的值。

17639
29:04:15.222 --> 29:04:24.037
如果我们的契约是这样的，我们有两个变量和契约a，我们仍然会将契约a的第一个存储点设为新值。

17640
29:04:24.104 --> 29:04:30.039
知道这一点非常重要，因为这意味着我们只能追加新的存储变量和新的实现契约。

17641
29:04:30.104 --> 29:04:31.961
我们不能重新订购或更换旧的。

17642
29:04:33.104 --> 29:04:33.574
冲突。

17643
29:04:36.104 --> 29:04:38.193
他们都在讨论这个问题。

17644
29:04:39.104 --> 29:04:41.045
调用函数选择或冲突。

17645
29:04:42.104 --> 29:04:47.954
代理将调用委托给这些实现之一，它使用所谓的函数选择器来查找函数。

17646
29:04:47.954 --> 29:04:52.918
函数选择器是函数名和函数签名的四字节散列。

17647
29:04:52.918 --> 29:04:55.237
现在不要担心函数签名。

17648
29:04:55.237 --> 29:05:07.267
现在，实现契约中的函数可能与代理契约中的管理函数具有相同的函数选择器，这可能会导致您意外地做一大堆奇怪的事情。

17649
29:05:07.267 --> 29:05:13.707
例如，在你面前的这个示例代码中即使所有这些函数完全不同，它们实际上有相同的函数选择器。

17650
29:05:13.707 --> 29:05:25.033
是的，我们可能会遇到这样的问题，一些无害的函数，比如get price具有与upgrade proxy或destroy proxy相同的函数选择器。

17651
29:05:25.104 --> 29:05:29.071
这就引出了代理契约的三个实现中的第一个。

17652
29:05:29.071 --> 29:05:31.974
这称为透明代理模式。

17653
29:05:32.104 --> 29:05:35.138
这就是我们今天要演示的模式。

17654
29:05:35.138 --> 29:05:38.764
在这种方法中，管理员只允许调用管理函数。

17655
29:05:38.764 --> 29:05:42.770
它们不能调用实现契约中的任何函数。

17656
29:05:42.770 --> 29:05:47.310
而且用户只能调用实现契约中的函数，而不能调用任何管理契约。

17657
29:05:47.310 --> 29:05:57.866
这样，你就不会意外地有两个交换，有一个函数选择器冲突，你在调用函数时遇到一个大问题，你可能不应该有，如果你是一个管理员，你调用管理函数。

17658
29:05:57.866 --> 29:06:00.409
如果你的用户正在调用实现函数。

17659
29:06:00.409 --> 29:06:06.402
所以如果你是一个管理员，你建立了一些疯狂的，了不起的定义协议，你最好想出一个新的钱包地址，因为你不能参与。

17660
29:06:06.402 --> 29:06:12.011
我们要讨论的第二种代理是通用可升级代理，或运算放大器。

17661
29:06:12.011 --> 29:06:29.394
这个版本的可升级契约实际上把所有的升级逻辑都放在了实现本身中，可靠度编译器会跳出来，说，嘿，这里有两个函数，它们有相同的函数选择器。

17662
29:06:29.394 --> 29:06:37.854
这也是有利的，因为我们少了一个阅读，我们必须做，我们不再需要检入代理合同，如果某人是管理员或不是。

17663
29:06:37.854 --> 29:06:40.734
这节省了汽油，当然，代理也小了一点。

17664
29:06:40.734 --> 29:06:47.865
因此，问题在于，如果部署的是实现契约，而没有任何可升级的功能，那么就会陷入困境。

17665
29:06:47.865 --> 29:06:50.468
现在我们回到Eat方法。

17666
29:06:50.468 --> 29:06:55.329
我们要讲的最后一种模式或方法是菱形模式，它有很多作用。

17667
29:06:55.329 --> 29:07:00.265
但它做的最大的事情之一是，它实际上允许多个实现契约。

17668
29:07:00.265 --> 29:07:02.431
这解决了几个不同的问题。

17669
29:07:02.431 --> 29:07:12.104
例如，如果您的契约非常大，并且它不适合一个契约的最大大小，您可以通过这个多实现方法有多个契约。

17670
29:07:12.104 --> 29:07:20.168
它还允许你进行更细粒度的升级，比如你不必总是部署和升级整个智能合约，你可以只升级它的一小部分。

17671
29:07:20.168 --> 29:07:21.038
如果你把它们切成块。

17672
29:07:21.038 --> 29:07:26.215
这里提到的所有代理都有某种类型的Aetherium改进建议，其中大多数都处于草案阶段。

17673
29:07:26.215 --> 29:07:31.661
在这个解释的最后，我们会做一个演示演示委托调用函数是如何工作的。

17674
29:07:31.661 --> 29:07:34.693
演示到此结束。

17675
29:07:34.693 --> 29:07:38.961
我们来看委托调用。

17676
29:07:39.104 --> 29:07:44.845
现在，我们将学习如何构建这些代理如何构建这些可升级的智能合约。

17677
29:07:44.845 --> 29:07:48.525
要做到这一点，我们首先需要了解这个委托调用函数。

17678
29:07:48.525 --> 29:07:52.404
它和我们之前学过的调用函数非常相似。

17679
29:07:52.404 --> 29:07:55.022
如果你还没看过，一定要回到我们的Harnett。

17680
29:07:55.022 --> 29:08:02.793
如果是T，我们有一节课，关于EVM，操作码，编码和调用我们会给你们委托调用的所有上下文。

17681
29:08:02.793 --> 29:08:12.554
就像我在解释中说的，这和调用非常相似但是，我认为它是一个契约说，哦，我真的很喜欢你的函数，我自己也要借用它。

17682
29:08:12.554 --> 29:08:14.604
我们将通过例子来研究固体的性质。

17683
29:08:14.604 --> 29:08:16.691
我会在GitHub上留下描述。

17684
29:08:16.691 --> 29:08:21.294
所有的代码都会在GitHub中与这节课相关。

17685
29:08:21.294 --> 29:08:28.659
现在我们有两个合同，一个是合同B，我们将在混音时使用它看起来是一个非常简约的非常简单的合同。

17686
29:08:28.659 --> 29:08:30.344
这里有几个存储变量。

17687
29:08:30.344 --> 29:08:55.038
然后我们有一个函数来更新我们的值，我们有一个叫做Set VARs的函数更新你是public num吗?我们之前学过，每当我们有某种类型的契约与存储变量，它们被存储在这个索引从0开始的存储数据结构中，现在你进入公共num是索引0，还是发送者的索引1，我们的值和索引2等等。

17688
29:08:55.104 --> 29:09:02.748
现在我们要部署一个合约a，现在这个合约将使用委托调用函数。

17689
29:09:02.748 --> 29:09:12.039
合同a这看起来有点不同，但它仍然有这个set bars函数，除了它会调用委托调用函数调用合同B。

17690
29:09:12.104 --> 29:09:18.326
在我们关于NF TS的第14课中，我们学习了调用API dot encode和签名API dot encode等。

17691
29:09:18.326 --> 29:09:29.387
如果你不熟悉函数选择器，如果你不熟悉如果你不熟悉这个语法，一定要回到第14课来理解ABI。encode with signature和contract。call。

17692
29:09:29.387 --> 29:09:33.704
不同的是，这里我们做的是合约。委托调用。

17693
29:09:33.704 --> 29:09:37.071
这个调用的作用和调用非常相似。

17694
29:09:37.071 --> 29:10:00.612
通常情况下，如果我们对契约进行契约式。调用，我们只会调用这个函数集VARs，这将更新契约B的存储，但相反，我们说，调用那个集VARs函数，然后将它作为输入参数传递，但在契约中调用它，在契约a中调用它，我们在契约中借用了一个函数。

17695
29:10:00.612 --> 29:10:06.991
相反，我们要做的是，我们要借用这个set bars然后运行这里的set bars函数。

17696
29:10:06.991 --> 29:10:13.858
不同的是，这些变量的命名可以不同于契约a中的变量。

17697
29:10:13.858 --> 29:10:23.414
所以不是num等于num，我们的契约会说，嘿，不管那个存储0的值等于我们传递的作为输入参数的值。

17698
29:10:23.414 --> 29:10:25.459
如果有一点困惑，请继续听我讲。

17699
29:10:25.459 --> 29:10:27.645
让我们来看看混音版。

17700
29:10:27.645 --> 29:10:30.317
我将复制粘贴这段代码到这里的remix中。

17701
29:10:30.317 --> 29:10:32.845
我们可以测试一下，看看这是什么样子。

17702
29:10:32.845 --> 29:10:39.329
同样，在与这门课程相关的GitHub回购中有这个链接，请随时暂停视频获取这个链接。

17703
29:10:39.329 --> 29:10:42.270
它是固体，连字符，连字符，例子。

17704
29:10:42.270 --> 29:10:47.354
或者你可以直接从第16课Hardhead升级中获取代码。

17705
29:10:47.354 --> 29:10:48.197
让我们编译这段代码。

17706
29:10:48.197 --> 29:10:49.362
让我来告诉你我是什么意思。

17707
29:10:49.362 --> 29:10:52.974
我要编译它，然后到运行选项卡。

17708
29:10:53.104 --> 29:11:03.865
首先部署合约光束，点击部署，现在我们有了合约，num, center和value都是空的，我们将数字更新为777，点击Set VARS。

17709
29:11:03.865 --> 29:11:08.912
设置VARs会将存储变量num更改为777。

17710
29:11:09.104 --> 29:11:13.318
然后我们改变sender和value, sender, value为0。

17711
29:11:13.318 --> 29:11:15.318
现在让我们部署契约a。

17712
29:11:15.318 --> 29:11:19.970
当然，我们在JavaScript VM上。

17713
29:11:19.970 --> 29:11:24.828
现在我们在Cinder中有这个带有num值的合同也都是空的。

17714
29:11:24.828 --> 29:11:45.734
但当我们调用集合VARs时，它会从契约B中借用集合VARs函数并在契约a中运行，你几乎可以把它想象成我们在复制集合VARs并将它粘贴到契约a中只运行一次，然后立即删除ADM，这就是委托调用函数的作用。

17715
29:11:45.734 --> 29:11:50.291
当我调用集合VARs时，我们会把合约地址作为输入参数传递给它。

17716
29:11:50.291 --> 29:11:53.725
所以它知道调用这个合约病毒函数。

17717
29:11:53.725 --> 29:11:57.021
当我传递地址时，我传递987。

17718
29:11:57.021 --> 29:12:01.750
因为我们借用了这个函数，所以我们不会更新这个num。

17719
29:12:01.750 --> 29:12:05.565
在契约B中，我们将更新契约a中的num。

17720
29:12:05.565 --> 29:12:09.038
当我点击Set VARs时，我们看到num现在有19。

17721
29:12:09.038 --> 29:12:15.292
7，我们看到参议员，我们看到value仍然是0，因为我们再次借用了这个函数，并在这里运行。

17722
29:12:15.292 --> 29:12:23.319
它的工作原理是，它并不查看存储变量的名称，而是查看存储槽。

17723
29:12:23.319 --> 29:12:34.015
当我们使用委托调用借用这个函数时，我们可以有这些变量我们可以命名为任何东西而不是num，我们可以叫它第一个值。

17724
29:12:34.105 --> 29:12:36.492
参议员，我们可以叫别的名字。

17725
29:12:38.105 --> 29:12:41.021
调用foo，或者任何你想要的。

17726
29:12:43.105 --> 29:12:51.355
函数使用委托调用，而不是获取变量的实际名称，我们的契约将用存储槽交换这些变量名称。

17727
29:12:51.355 --> 29:12:59.006
它说，哦，好的，在契约B中，你访问的是num变量，它在0号存储槽。

17728
29:12:59.006 --> 29:13:12.449
当我们借用set条并与委托调用收缩a时，我们会说存储槽0将等于那个下划线num。

17729
29:13:12.449 --> 29:13:16.793
也就是这个契约存储槽0是第一个值。

17730
29:13:16.793 --> 29:13:30.054
我们会说，firstvalue =下划线，现在，另一些东西会被存储在插槽2中，它会说，好，存储插槽2，我们会更新存储插槽2来通知发送者。

17731
29:13:30.105 --> 29:13:33.028
好吧?这里的值是存储槽位3。

17732
29:13:35.105 --> 29:13:38.838
槽3将像这样更新消息点值。

17733
29:13:39.105 --> 29:13:41.621
这基本上就是幕后发生的事情。

17734
29:13:42.105 --> 29:13:44.898
让我们删除这些并重新部署。

17735
29:13:44.898 --> 29:13:45.786
重新部署。

17736
29:13:46.105 --> 29:13:54.323
我们将部署合同，部署合同a，现在在B中，同样，如果我们执行1234，设置var，我们有123。

17737
29:13:54.323 --> 29:13:55.794
缩并a。

17738
29:13:55.794 --> 29:14:05.894
尽管这些变量名称不同，我们还是可以获取合同B的地址，粘贴进去，输入654，点击设置VARS。

17739
29:14:05.894 --> 29:14:09.578
第一个值是6 × 4。

17740
29:14:09.578 --> 29:14:17.637
委托调用允许我们借用函数，然后把这里的东西转置到对应的存储位置。

17741
29:14:17.637 --> 29:14:23.851
另一件有趣的事是即使你没有变量，它仍然会保存到存储槽中。

17742
29:14:23.851 --> 29:14:29.514
在契约a中，如果我们没有这些变量名，存储槽01和2仍然会被更新。

17743
29:14:29.514 --> 29:14:32.157
事情会变得非常有趣。

17744
29:14:32.157 --> 29:14:34.252
我们再把合同删掉吧。

17745
29:14:34.252 --> 29:14:41.271
让我们将契约A的第一个值的类型从UNT改为布尔值。

17746
29:14:41.271 --> 29:14:42.604
让我们保存它。

17747
29:14:42.604 --> 29:14:45.282
现在部署契约a。

17748
29:14:45.282 --> 29:15:05.524
当我们调用集合VARs时，在契约a中，它仍然会使用契约B的集合VARs函数，它接受一个Yewande并分配我们传递给它的第一个存储槽，但我们的第一个存储槽现在是一个布尔值所以你们认为现在会发生什么?让我们试一下。

17749
29:15:05.524 --> 29:15:08.845
我们把合同B的地址复制过来，粘贴在这里。

17750
29:15:08.845 --> 29:15:14.406
我们用tu tu作为输入参数，点击Set VARS。

17751
29:15:14.406 --> 29:15:17.651
我们的交易确实完成了。

17752
29:15:17.651 --> 29:15:21.557
现在当我们看第一个值时，它说为真。

17753
29:15:21.557 --> 29:15:23.292
嗯，那真的很奇怪。

17754
29:15:23.292 --> 29:15:26.750
如果我们将set VARs改为0，然后点击set VARs。

17755
29:15:26.750 --> 29:15:29.169
现在，第一个值为假。

17756
29:15:29.169 --> 29:15:38.695
在这里的存储中，当我们添加一个带有集合var的数字时，它会通过因为它只是将布尔值的存储槽设置为一个数字。

17757
29:15:38.695 --> 29:15:43.460
当固体读取它时，它会说，哦，好吧，第一个值是布尔值。

17758
29:15:43.460 --> 29:15:46.443
所以如果它不是0，它就是对的。

17759
29:15:46.443 --> 29:15:49.473
这就是为什么你会得到一些奇怪的结果。

17760
29:15:49.473 --> 29:15:53.136
如果类型不同，或者存储的变量不同。

17761
29:15:53.136 --> 29:15:54.636
如果我们把这改成地址呢。

17762
29:15:54.636 --> 29:16:04.845
这就是使用委托调用会变得非常奇怪和棘手的地方。

17763
29:16:05.105 --> 29:16:05.715
好吧。

17764
29:16:09.105 --> 29:16:09.319
热量。

17765
29:16:12.105 --> 29:16:20.415
示例，它展示了如何将合同用作单数地址，但底层代码实际上可以更改。

17766
29:16:20.415 --> 29:16:31.830
我们要用到的所有代码，还是那句话，在硬帽升级，FCC子课程，小代理。Sol中，你可以复制粘贴这些代码，如果你想学的话。

17767
29:16:31.830 --> 29:16:34.007
所以你不需要跟我一起写代码。

17768
29:16:34.105 --> 29:16:35.811
但如果我们愿意，你完全可以。

17769
29:16:37.105 --> 29:16:41.927
这将是整个课程中最先进的部分之一。

17770
29:16:41.927 --> 29:16:44.622
所以请随意跳过这节课。

17771
29:16:44.622 --> 29:16:51.305
如果您只想继续学习如何实际构建这些代理，而不真正了解幕后发生了什么。

17772
29:16:51.305 --> 29:16:55.032
然而，如果您确实了解幕后发生的事情，它仍然非常强大。

17773
29:16:55.032 --> 29:16:58.438
这是最简的起始位置。

17774
29:16:58.438 --> 29:17:00.402
我有小代理就是代理。

17775
29:17:00.402 --> 29:17:05.030
我要从Zeplin导入proxy。sole这个东西。

17776
29:17:05.105 --> 29:17:11.055
Openzeppelin有这个极简的代理契约，我们可以用它实际开始处理这个委托调用。

17777
29:17:11.105 --> 29:17:14.789
这个契约使用了大量的集合或者所谓的"你会"

17778
29:17:14.789 --> 29:17:19.443
它是一种可以编译为不同后端字节码的中间语言。

17779
29:17:19.443 --> 29:17:27.383
它是一种内嵌的程序集，它允许你写非常非常低级别的代码，接近操作码。

17780
29:17:27.383 --> 29:17:32.261
现在我们不复习了但是如果你们想了解更多我会给你们一些文档的链接。

17781
29:17:32.261 --> 29:17:38.105
即使您是一个非常高级的用户，您也希望尽量少使用EULA。

17782
29:17:38.105 --> 29:17:43.556
因为它的级别要低得多，所以更容易把事情搞砸。

17783
29:17:43.556 --> 29:17:58.524
然而，就像我说的，在这个例子中，我们会用到一点。在我们将要做的这个代理中，我们有这个委托函数，在这个内联程序集中，它会做很多非常低级的事情。

17784
29:17:58.524 --> 29:18:02.875
但它做的主要事情是它继续它做这个委托调用功能。

17785
29:18:02.875 --> 29:18:08.105
看这里，它使用了一个回退函数和一个接收函数。

17786
29:18:08.105 --> 29:18:17.438
当它接收到一个无法识别的函数时，它会调用fallback，而fallback调用委托函数。

17787
29:18:17.438 --> 29:18:30.043
因此，每当代理契约接收到一个它不识别的函数的数据时，它就会将它发送到某个实现到某个实现契约，在那里它将用委托调用调用它。

17788
29:18:30.105 --> 29:18:38.531
在我们最简单的例子中，我们有一个叫Set implementation的函数，它会改变那些委托调用发送的位置。

17789
29:18:38.531 --> 29:18:41.975
这相当于升级你的智能合约。

17790
29:18:41.975 --> 29:18:47.741
然后我们在这里有实现来读取实现契约的位置。

17791
29:18:47.741 --> 29:18:57.089
要使用代理，我们真的不想在存储中有任何东西，因为如果我们进行委托调用，而委托调用发生了变化，一些存储，我们就会把契约存储搞砸。

17792
29:18:57.089 --> 29:19:04.566
需要注意的是，我们仍然需要把实现地址存储在某处，我们可以叫它ERP 1976。

17793
29:19:04.566 --> 29:19:15.028
它被称为标准代理存储槽，这是Aetherium的改进建议，用于指定特定的存储槽用于代理。

17794
29:19:15.105 --> 29:19:23.695
在这个最简单的例子中，我们设置bytes 32，私有常量实现槽到存储中的那个位置。

17795
29:19:23.695 --> 29:19:31.533
我们会说，不管这个存储槽是什么它就是实现地址的位置。

17796
29:19:31.533 --> 29:19:36.793
代理的工作方式是任何调用这个代理契约的契约。

17797
29:19:36.793 --> 29:19:42.990
如果它不是这个集合实现函数，它会把它传递到实现槽地址内的任何东西。

17798
29:19:42.990 --> 29:19:44.432
这就是我们要在这里建立的。

17799
29:19:44.432 --> 29:19:47.382
我们有一个小代理。

17800
29:19:47.382 --> 29:19:51.308
我们将创建一个真正的极简契约。

17801
29:19:51.308 --> 29:19:58.443
我们写合同雇员，心理状态A，我们给它一个U和256。

17802
29:19:58.443 --> 29:20:13.023
然后函数集value，你添加256个新值，public会说value = new value，这就是我们的实现。

17803
29:20:13.023 --> 29:20:26.542
只要有人调用小代理，或者小代理契约，它就会委托，调用它到我们的实现a，然后把存储存到小代理地址中。

17804
29:20:26.542 --> 29:20:32.676
我们会用数据调用我们的小代理来使用这个集值函数选择器。

17805
29:20:32.676 --> 29:20:44.964
让我们让它变得更简单一些通过创建一个新的helper函数，dofunction，获取数据到事务处理。

17806
29:20:45.105 --> 29:20:51.025
我们可以使用我们在前一课中学过的带有签名的API点编码来获取数据。

17807
29:20:51.025 --> 29:20:57.711
函数获取数据到transact，我们将传递给它一个un256数字来更新。

17808
29:20:57.711 --> 29:21:01.645
我们给这个数字一个新值。

17809
29:21:01.645 --> 29:21:07.999
我们将它设为public pure，它将返回一个字节。

17810
29:21:08.105 --> 29:21:08.771
内存。

17811
29:21:08.771 --> 29:21:13.326
我们会说返回ABI。ENCODE。

17812
29:21:14.105 --> 29:21:23.941
签名集值，你去56，逗号，数字更新。

17813
29:21:24.105 --> 29:21:27.588
你们应该记得我们的任意部分。

17814
29:21:28.105 --> 29:21:41.252
你不记得怎么做了，记得回看我们的非ft部分，学习如何调用任何东西，并使用ABI。encode ABI。encode与签名，调用任何带有原始字节的东西，带来和获取数据进行交易。

17815
29:21:41.252 --> 29:21:48.225
我们知道，当我们从小代理调用实现a时，我们会更新小代理存储。

17816
29:21:48.225 --> 29:21:53.006
我们会在实体中创建一个小函数来读取小代理中的存储。

17817
29:21:53.006 --> 29:21:56.202
我们会说函数，读取存储。

17818
29:21:56.202 --> 29:22:07.901
这将是一个公共视图，它会返回到256，在存储槽处的值，0。

17819
29:22:07.901 --> 29:22:13.978
我们将在这里使用一点汇编因为我们做的都是低级的东西。

17820
29:22:13.978 --> 29:22:32.846
我们会调用s load up代码来读取0号存储槽位的值，我们会说0号存储槽位的value，我们会设置它然后在汇编中，这是我们设置东西的方式，我们会设置它等于0号存储槽位的s load，然后它会返回这个值。

17821
29:22:32.846 --> 29:22:34.884
我们直接从存储中读取。

17822
29:22:34.884 --> 29:22:37.732
哦，然后我们需要一个小括号。

17823
29:22:37.732 --> 29:22:38.138
对不起。

17824
29:22:38.138 --> 29:22:41.223
现在，让我们继续部署我们的小代理。

17825
29:22:41.223 --> 29:22:43.188
让我们部署实现A。

17826
29:22:43.188 --> 29:22:47.966
现在我们的小代理有一个名为Set implementation的函数。

17827
29:22:47.966 --> 29:22:55.460
我们会说，任何时候调用这个代理契约，我们都会委托调用函数到这里。

17828
29:22:55.460 --> 29:23:02.819
我们会抓取当前实现A的地址，粘贴到集合实现77中。

17829
29:23:02.819 --> 29:23:09.105
这是你在256中的数据值，里面编码了要更新的数字。

17830
29:23:09.105 --> 29:23:17.850
如果我们调用小代理，用这些数据，我们的代理契约会说，哦，这是一个函数。

17831
29:23:17.850 --> 29:23:19.875
我没有，我没有看到这个函数。

17832
29:23:19.875 --> 29:23:24.551
我们将调用我们的fallback，对吧，它同样来自open Zeplin。

17833
29:23:24.551 --> 29:23:40.695
我们的Fallback会做这个委托，这是低级别的东西，但它基本上只是做一个委托调用，我们会调用我们的Fallback函数，然后我们会在实现a中得到这个函数，我们会借用这个函数，我们会在我们自己身上使用它。

17834
29:23:40.695 --> 29:23:45.558
如果我复制这个，实现被设置为下面这个地址。

17835
29:23:45.558 --> 29:23:47.533
所有的逻辑都在这里完成了。

17836
29:23:47.533 --> 29:23:54.717
我抓取这个，粘贴到调用数据中，点击交易，看起来它成功通过了。

17837
29:23:54.717 --> 29:24:00.333
如果我读存储，现在，我们看到它确实是777，这是非常令人兴奋的。

17838
29:24:00.333 --> 29:24:08.305
现在，这是非常有益的，因为现在我们想要更新我们的代码，对吧?我们不再喜欢契约执行了。

17839
29:24:08.305 --> 29:24:11.105
我们来复制契约实现A。

17840
29:24:11.105 --> 29:24:14.191
我们新建一个，叫做实现B。

17841
29:24:14.191 --> 29:24:23.195
现在，我们说每当有人调用setvalue时，我们做value = new value + 1或+ 2。

17842
29:24:23.195 --> 29:24:25.938
让我们继续，保存它。

17843
29:24:25.938 --> 29:24:27.521
让我们编译这个。

17844
29:24:27.521 --> 29:24:36.777
我们部署实现B，获取实现B的契约地址，我们在代理中称它为起始实现。

17845
29:24:36.777 --> 29:24:42.637
实际上，我们已经从实现a升级到实现B。

17846
29:24:42.637 --> 29:24:49.137
现在，如果我们用同样的数据，我们仍然会调用setvalue = 777。

17847
29:24:49.137 --> 29:24:55.395
但相反，我们现在是委托调用实现B，而不是实现A。

17848
29:24:55.395 --> 29:25:02.688
如果我调用。如果我把这个数据放到低级调用数据中，然后点击事务，它看起来通过了。

17849
29:25:02.688 --> 29:25:13.765
现在我读取storage，现在是779因为value = new value + 2这是一个关于升级的简单例子。

17850
29:25:13.765 --> 29:25:22.377
现在，这是非常有益的，因为我们总是可以告诉人们，嘿，让你所有的函数调用到小代理，你会很好。

17851
29:25:22.377 --> 29:25:30.505
但正如我前面所说，这也意味着该协议的开发人员可以在任何时候从本质上更改底层逻辑。

17852
29:25:30.505 --> 29:25:36.882
这就是为什么一定要阅读合同并查看谁拥有开发人员密钥是如此重要。

17853
29:25:36.882 --> 29:25:44.396
如果一个合同可以更新，如果一个合同可以更新，一个人可以更新它，你猜怎么着，你就有了一个集中的故障点。

17854
29:25:44.396 --> 29:25:46.744
从技术上讲，这份合同甚至没有去中心化。

17855
29:25:46.744 --> 29:25:53.501
现在，我在视频中谈到的另一件事是函数冲突函数选择器冲突。

17856
29:25:53.501 --> 29:26:01.782
现在，当我们调用set实现时，代理函数沉降会被调用因为我们不会触发回退因为我们可以看到函数在这里。

17857
29:26:01.782 --> 29:26:14.029
然而，如果我有一个叫Set implementation的函数，在我们的实现中，这个永远不能被调用，每当我们发送一个Set implementation的函数签名时，它总是会调用代理上的那个。

17858
29:26:14.029 --> 29:26:22.311
这就是我们要使用的透明代理可以帮助我们的地方通用可升级代理可以帮助我们，我现在不打算深入讲这些。

17859
29:26:22.311 --> 29:26:28.329
但我们在GitHub存储库中留下了一些链接，以教您更多关于这些选择器冲突的知识。

17860
29:26:28.329 --> 29:26:54.416
以及我刚才提到的两种代理模式，透明的和通用的可升级模式是如何解决这些问题的，如果你对这里的任何内容感到困惑，请进入这个讨论环节，对代理进行新的讨论对程序集进行新的讨论对你将设置的实现进行新的讨论，这是一个与其他选修这门课的人联系并提问的好时机，因为我知道这是一个非常高级的部分，这要求你们没有学过很多我们之前学过的次级课程。

17861
29:26:54.416 --> 29:27:03.460
如果这需要你花上几次时间来处理固相和混音，我强烈建议你这样做这是我们看到的真正值得相信的部分。

17862
29:27:03.460 --> 29:27:04.819
我要你开始混音。

17863
29:27:04.819 --> 29:27:06.152
我想让你测试一下。

17864
29:27:06.152 --> 29:27:10.308
我想让你们玩玩这个看看你们能打破什么，摆弄什么。

17865
29:27:10.308 --> 29:27:17.665
但是说了这么多，我们终于拥有了构建处理升级的硬帽项目所需的所有知识。

17866
29:27:17.665 --> 29:27:21.865
让我们开始吧。

17867
29:27:22.105 --> 29:27:44.072
你的新终端，我们会执行mkdir, hard hat，升级，FCC, CD, hard hat，升级，FCC，然后代码周期，或者文件，打开文件夹，这个文件夹，现在我要抓取那个yarn add我们从小于9处抓取，我们要把它粘贴进去，我们要添加所有这些不同的参数。

17868
29:27:44.072 --> 29:27:49.155
再一次，我们要复制我们的硬帽子配置从以前的章节，我们要复制漂亮。

17869
29:27:49.155 --> 29:27:51.789
我们会得到基本的默认设置。

17870
29:27:51.789 --> 29:27:56.219
在这一点上，你可能有一个最适合你和你更喜欢的设置。

17871
29:27:56.219 --> 29:27:57.969
你也可以随便拿这个。

17872
29:27:57.969 --> 29:28:00.298
我要把漂亮的粘贴到这里。

17873
29:28:00.298 --> 29:28:02.039
我要把安全帽粘上去。

17874
29:28:02.039 --> 29:28:02.329
配置。

17875
29:28:02.329 --> 29:28:05.200
Js，我们一直在使用，而不是运行纱线安全帽。

17876
29:28:05.200 --> 29:28:07.105
现在我们应该可以开始了。

17877
29:28:07.105 --> 29:28:10.643
让我们创建一个名为contract的新文件夹。

17878
29:28:10.643 --> 29:28:15.040
在这里，我们将创建一个名为Box。soul的新文件。

17879
29:28:15.105 --> 29:28:19.505
然后是这个契约，这将是我们的实现或逻辑契约。

17880
29:28:19.505 --> 29:28:24.318
所以它会说pragma, solidity carrot零点8。

17881
29:28:24.318 --> 29:28:46.896
7合约框会说你进入256个内部值将做事件值改变你进入256个新值，做函数存储，你进入36个值，这将是一个公共函数会说值等于新值。

17882
29:28:46.896 --> 29:29:00.623
这个store函数会在内部的0号存储槽更新变量，然后我们会省略value changed那个新值。

17883
29:29:00.623 --> 29:29:11.529
然后我们会创建函数检索，这将是一个公共视图返回一个unt256我们只做返回值。

17884
29:29:11.529 --> 29:29:16.699
然后我们会创建一个新函数叫做version。

17885
29:29:16.699 --> 29:29:19.326
这将是一扇公共大门。

17886
29:29:19.326 --> 29:29:21.574
返回un256。

17887
29:29:21.574 --> 29:29:25.089
我们只会有这个返回值。

17888
29:29:25.089 --> 29:29:28.106
盒子契约是版本1。

17889
29:29:28.106 --> 29:29:38.456
现在我们要复制所有这些代码，粘贴到v2。soul中并将其重命名为contract v2，我们将把这个版本更新到版本2。

17890
29:29:38.456 --> 29:29:42.525
我们要创建一个新函数，叫做increment。

17891
29:29:42.525 --> 29:29:45.912
这将是一个公共活动。

17892
29:29:46.106 --> 29:29:49.949
我们设value = value + 1。

17893
29:29:52.106 --> 29:29:54.913
带有值的值更改事件。

17894
29:29:57.106 --> 29:30:03.875
合同地址最初使用盒子里的逻辑，然后我们将把它升级到盒子v2里的逻辑。

17895
29:30:03.875 --> 29:30:16.992
我们将学习如何使用我们在这里使用过的所有工具来添加这个逻辑并创建这个逻辑，让我们确保它工作，我们将使用yarn，或者编译。

17896
29:30:17.106 --> 29:30:18.798
让我们做一个自述文件。

17897
29:30:22.106 --> 29:30:23.582
盒子到盒子v2。

17898
29:30:28.106 --> 29:30:29.306
指向盒子。

17899
29:30:32.106 --> 29:30:34.041
它指向盒子v2。

17900
29:30:37.106 --> 29:30:40.201
指向盒子，那么我们让它指向盒子v2。

17901
29:30:40.201 --> 29:30:50.231
这就是我们要升级它的方式，我们首先要做的一件事就是部署一个代理，我们可以自己手动部署一个代理，我们可以建立代理合同，做所有这些事情。

17902
29:30:50.231 --> 29:30:51.516
这是我们的第一选择。

17903
29:30:51.516 --> 29:31:00.351
Hardhead部署也内置在部署和升级代理本身中，我们可以只指定想要使用代理。

17904
29:31:00.351 --> 29:31:03.316
我们可以指定我们想要使用的代理的类型。

17905
29:31:03.316 --> 29:31:08.248
第二点说的是使用硬帽部署，内置代理。

17906
29:31:08.248 --> 29:31:21.213
第三点是Zeppelin有一个升级插件，它允许你写一些非常简单的脚本，允许你有一个非常简单的API，比如升级。部署代理，然后升级那个升级代理。

17907
29:31:21.213 --> 29:31:26.532
在本节中，我们将进行内建代理的硬帽部署。

17908
29:31:26.532 --> 29:31:34.895
然而，在与此相关的GitHub回购中，如果你去脚本，有其他的升级示例，将向你展示如何使用打开和升级插件。

17909
29:31:34.895 --> 29:31:41.912
我们不会手动部署代理手动部署代理，因为我们在子课中已经演示过了。

17910
29:31:41.912 --> 29:31:51.306
我们会向你们展示这个，我们会向你们展示Hardhead部署内置代理，如果你想使用openzeppelin升级插件，那在GitHub回购中也是可用的。

17911
29:31:51.306 --> 29:31:53.033
我们来做这个。

17912
29:31:53.033 --> 29:31:57.235
我们会创建一个新文件夹，也就是部署文件夹。

17913
29:31:57.235 --> 29:32:02.702
首先，我们创建一个新文件，名为1,deploy box。js。

17914
29:32:02.702 --> 29:32:06.326
这看起来和我们之前做过的很像。

17915
29:32:06.326 --> 29:32:14.735
module。exports = async function，我们会得到命名帐户和部署。

17916
29:32:14.735 --> 29:32:28.929
箭头函数会写const deploy COMM A log = deployment const deployer = await, get named。

17917
29:32:29.106 --> 29:32:57.106
Accounts，做一些记录，像这样，然后我们说const, box = await, loi, box，逗号，我们说from Deployer，逗号，args像这样，我们说weight conformation将是network。config。block confirations for Masons。

17918
29:32:57.106 --> 29:33:01.506
是的，我们要从硬帽获取const。

17919
29:33:01.506 --> 29:33:05.267
然后我们可以在这里添加代理的参数。

17920
29:33:05.267 --> 29:33:08.846
这就是我们可以添加大量信息的地方。

17921
29:33:08.846 --> 29:33:17.525
就像我说的，我们将使用开放齐柏林飞船的透明可升级代理，如果我们想使用它，我们必须添加开放齐柏林飞船。

17922
29:33:17.525 --> 29:33:24.124
所以我们会做纱线，添加破折号开发打开齐柏林斜杠合同。

17923
29:33:24.124 --> 29:33:39.623
我们可以告诉我们的硬帽在代理后面部署这个盒子契约会说代理契约将是开放的齐柏林透明代理。

17924
29:33:39.623 --> 29:33:44.588
我们还会做via管理合同。

17925
29:33:44.588 --> 29:33:52.499
代理合同不再是管理地址，而是由管理合同拥有。

17926
29:33:52.499 --> 29:33:56.639
这样做被认为是一种最佳实践，原因有很多。

17927
29:33:56.639 --> 29:34:07.515
但是我们将为这个管理契约、盒子代理管理和这个盒子代理管理的工件命名。

17928
29:34:07.515 --> 29:34:12.953
因此，我们需要创建一个盒子代理管理合同作为我们的盒子的管理。

17929
29:34:12.953 --> 29:34:18.213
在合约文件夹中，新建一个名为proxy的文件夹。

17930
29:34:18.213 --> 29:34:35.895
这里有个新文件，叫做Box代理管理这是管理合同用来控制Box的代理收件箱代理管理。Saul会做SP DX许可。

17931
29:34:35.895 --> 29:34:44.742
然后我点燃MIT实用主义，胡萝卜0，点8。

17932
29:34:44.742 --> 29:34:56.267
7，比如合同，盒子代理管理，像这样，对吧?再一次，我们将使用透明文件夹中的Zetland工具。

17933
29:34:56.267 --> 29:35:02.059
他们有一个代理管理。Saul，这和我们的box代理管理是一样的。

17934
29:35:02.106 --> 29:35:09.706
它有一些功能，这里有一些功能，比如更改，代理管理，升级，升级和处理升级的调用。

17935
29:35:09.706 --> 29:35:10.352
所有合同。

17936
29:35:10.352 --> 29:35:22.173
我们要导入它会在open Zeppelin处导入斜杠合同斜杠代理斜杠透明，斜杠代理管理，点灵魂。

17937
29:35:22.173 --> 29:35:28.847
我们会说我们的Brock's box代理管理是代理管理，像这样。

17938
29:35:28.847 --> 29:35:39.573
为了让这个框代理管理与deploy plugin中的心脏一起工作，我们的构造函数需要接受一个地址所有者作为输入参数，但我们将把它保留为空。

17939
29:35:39.573 --> 29:35:42.735
然后我们需要做代理管理，这也是空白的。

17940
29:35:42.735 --> 29:35:43.412
就是这样。

17941
29:35:43.412 --> 29:35:51.772
这就是我们要做的box代理管理合同，它有所有的功能来进行升级和更改代理管理等等。

17942
29:35:51.772 --> 29:36:03.193
我们将在代理后面部署我们的盒子合同，并开放透明的代理，它属于模板Aetherium合同中的Brock的代理管理合同。

17943
29:36:03.193 --> 29:36:11.783
GitHub回购实际上是一个例子斜杠打开代理分支，将向你展示如何使用不同类型的代理。

17944
29:36:11.783 --> 29:36:15.206
在与这门课相关的GitHub回购中会有一个链接。

17945
29:36:15.206 --> 29:36:20.948
然后我们会进行验证，比如，链。包含。

17946
29:36:20.948 --> 29:36:32.932
我们继续，我要复制粘贴我们的硬帽助手配置从我们的上一个项目，它有开发链，我们导出的硬帽和本地主机，也会导入这个。

17947
29:36:32.932 --> 29:36:40.391
Const开发链= require。slash helper hard hat config。

17948
29:36:40.391 --> 29:36:59.512
如果development chains。包括network。name和process。env。ether scan API key log，验证和我们上次验证的方法一样，我们将复制utils文件夹。

17949
29:36:59.512 --> 29:37:05.299
复制粘贴，我们有验证，它会导入到这里。

17950
29:37:05.299 --> 29:37:17.006
我们写入const verify = require。dot / utils，斜杠verify, await verify box。address。

17951
29:37:17.106 --> 29:37:18.864
然后args是空的。

17952
29:37:20.106 --> 29:37:21.182
这里，砰。

17953
29:37:25.106 --> 29:37:30.942
我们可以通过运行Hardhead deploy纱线来测试，看看是否一切正常。

17954
29:37:30.942 --> 29:37:32.187
就这样完成了。

17955
29:37:32.187 --> 29:37:38.018
然后我们还应该加上log beach true。

17956
29:37:38.106 --> 29:37:40.009
让我们再运行一遍，效果更好。

17957
29:37:41.106 --> 29:37:42.987
实际上部署了几个契约。

17958
29:37:44.106 --> 29:37:50.155
代理管理，这将是我们的管理契约，然后我们部署盒子实现。

17959
29:37:50.155 --> 29:38:01.778
hardhat deploy，将我们的盒子契约重命名为盒子实现然后部署它，然后部署我们的盒子代理。

17960
29:38:01.778 --> 29:38:05.912
任何时候我们调用这个地址，它都会指向盒子的逻辑。

17961
29:38:05.912 --> 29:38:23.728
现在我们能做的是写一个部署脚本来部署box v2实现，然后把我们的box升级到V创建一个新的部署脚本叫做Zero来部署box v2。j或者部署box two。j。

17962
29:38:23.728 --> 29:38:26.486
我们会做一些类似的事情。

17963
29:38:26.486 --> 29:38:31.806
好的，我要复制大部分的内容，粘贴到这里。

17964
29:38:31.806 --> 29:38:40.106
现在我们要做const box v2 = await, deploy。

17965
29:38:40.106 --> 29:38:45.369
框v2，逗号，来自Deployer。

17966
29:38:45.369 --> 29:38:58.956
logtrue RMS空白，权重确认，它将是network。config。lock。

17967
29:38:59.106 --> 29:39:08.699
或者masons，然后复制验证码，复制这个，粘贴到这里，server，这是box v2。address。

17968
29:39:08.699 --> 29:39:09.715
好了,好了。

17969
29:39:09.715 --> 29:39:14.439
现在我们有了一些可以部署box和v2的代码。

17970
29:39:14.439 --> 29:39:19.235
现在让我们写一个脚本来升级这些。

17971
29:39:19.235 --> 29:39:22.525
新建一个文件夹，scripts。

17972
29:39:22.525 --> 29:39:26.518
新建文件，命名为upgrade box。js。

17973
29:39:26.518 --> 29:39:28.912
现在我们用手工的方法来做。

17974
29:39:28.912 --> 29:39:36.052
我们用手动的方式是因为我想给你们展示我们调用的函数来完成这个升级过程。

17975
29:39:36.106 --> 29:39:42.810
不过，硬帽部署还提供了一个API，可以非常容易地升级您的盒式契约。

17976
29:39:42.810 --> 29:39:44.347
这将是一个脚本。

17977
29:39:44.347 --> 29:39:47.418
我们从async函数main开始。

17978
29:39:47.418 --> 29:39:53.868
然后复制粘贴传统脚本，main。然后process exit等等，等等，等等。

17979
29:39:53.868 --> 29:39:57.834
我们得先拿到代理管理合同。

17980
29:39:57.834 --> 29:39:59.761
我们写上box const。

17981
29:39:59.761 --> 29:40:15.751
Box, proxy admin = await ethers。get contract, Box proxy admin我们需要导入这里来自Hardhead，然后我们会得到实际的代理，这是我们的透明代理。

17982
29:40:15.751 --> 29:40:24.963
因此我们写入const transparent proxy = await ethers。get contract, box下划线proxy。

17983
29:40:24.963 --> 29:40:30.043
由于是硬帽部署，我们将用实现下划线代理的名称命名代理。

17984
29:40:30.043 --> 29:40:34.483
当然，我们需要盒子V收缩。

17985
29:40:34.483 --> 29:40:35.548
所以写上const。

17986
29:40:35.548 --> 29:40:41.550
方框v 2等于等待醚。得到契约，方框v 2。

17987
29:40:41.550 --> 29:40:49.614
现在我们可以说const，升级TX等于一个权重箱代理admin，也就是升级。

17988
29:40:49.614 --> 29:40:59.994
我们会在盒子代理管理上调用升级函数，它会在透明代理上调用它，这会将实现从盒子1改变到盒子2。

17989
29:40:59.994 --> 29:41:23.784
盒子代理管理，也就是升级，我们将把透明代理。address升级到盒子B到那个地址，它会在盒子代理中查找，盒子代理有一个升级函数调用我们的透明可升级代理会执行一个权重升级TX。等一下。

17990
29:41:23.784 --> 29:41:35.527
现在要处理box v2上的函数，我们会说const proxy box = await ethers。get contract。

17991
29:41:35.527 --> 29:41:45.596
在v2处，我们会得到v2abi然而，我们会在透明代理地址加载它。

17992
29:41:45.596 --> 29:41:51.958
这样醚类就知道了，我们会在透明代理地址上调用所有的函数。

17993
29:41:51.958 --> 29:41:57.563
但是这个代理盒子会有ABI (v2)这就是我们想要的。

17994
29:41:57.563 --> 29:42:03.088
现在我们可以说const version = await proxy box。version。

17995
29:42:03.088 --> 29:42:06.296
我们写上console。log version。

17996
29:42:06.296 --> 29:42:14.428
如果我们想在升级之前，把这个和它原来的实现进行比较，我们可以做同样的事情。

17997
29:42:14.428 --> 29:42:29.439
我们可以说const代理框v1，我们实际上称这个代理框V表示代理框v1等于这个等价的调用框。

17998
29:42:29.439 --> 29:42:44.450
我们会写const version = weight，右边代理框v1。version console。log version，或者版本v1。

17999
29:42:44.450 --> 29:42:51.211
我们称这个为v2, v2，代理框为v2。

18000
29:42:51.211 --> 29:42:54.868
所以我们会得到版本v1会升级。

18001
29:42:54.868 --> 29:43:00.378
然后我们会看到在同一个地址，版本函数现在返回了什么。

18002
29:43:00.378 --> 29:43:02.806
让我们打开终端。

18003
29:43:02.806 --> 29:43:15.689
如果我运行yarn，我们的头节点会旋转一个节点会部署我们的admin我们的实现，我们的代理，然后我们的box V到实现。

18004
29:43:15.689 --> 29:43:17.892
我要做一个新的终端。

18005
29:43:17.892 --> 29:43:26.439
我将运行纱线，硬帽运行脚本升级框，即J S破折号网络，本地主机。

18006
29:43:26.439 --> 29:43:29.286
我们会看到这个框在更新。

18007
29:43:29.286 --> 29:43:30.810
这正是我们所看到的。

18008
29:43:30.810 --> 29:43:33.123
然后我们来做，我忘了做。

18009
29:43:33.123 --> 29:43:34.002
在这里串线。

18010
29:43:34.106 --> 29:43:38.481
但它在同一个地址上从版本1到版本2。

18011
29:43:38.481 --> 29:43:44.829
通过这一小段代码，我们已经成功地学会了如何以编程方式升级智能合约。

18012
29:43:44.829 --> 29:43:52.668
现在，就像我说的，在与这一课相关的GitHub回购中，你也可以从打开Zeppelin检查升级插件。

18013
29:43:52.668 --> 29:44:03.391
要处理这个，你只需要执行升级。deploy proxy代理来调用Prepare upgrade函数，然后像这样升级升级代理。

18014
29:44:03.391 --> 29:44:08.006
他们也有一个升级教程，一步一步的hardhat，你可以跟随以及。

18015
29:44:08.006 --> 29:44:10.006
现在我知道这是高级部分。

18016
29:44:10.106 --> 29:44:12.731
我知道我们讲得有点快了。

18017
29:44:14.106 --> 29:44:20.021
只需完成本节，您就不仅完成了使您成为真正强大的智能合同开发人员的所有其他部分。

18018
29:44:20.021 --> 29:44:22.751
但你在这里学到了一些非常高级的东西。

18019
29:44:22.751 --> 29:44:36.090
我们研究了一些低级代码，比如委托调用，我们研究了汇编，我们研究了这些代理模式，它们能让你成为智能合约领域中杰出的开发者。

18020
29:44:36.090 --> 29:44:43.753
如果你刚刚看完这部分，你应该为自己感到非常非常自豪，因为我们讲得非常快，因为这里有很多先进的信息。

18021
29:44:43.753 --> 29:44:51.820
现在，就像我说的，百分之百，一定要进入讨论选项卡，问问题，与该地区的其他人联系和交谈。

18022
29:44:51.820 --> 29:45:00.991
也许可以看看已经开始的讨论，并开始询问其他学生，开始询问其他人他们学到了什么，以及他们的代理进行得如何。

18023
29:45:00.991 --> 29:45:02.296
如果他们做了什么很酷的东西。

18024
29:45:02.296 --> 29:45:10.003
如果你只是很兴奋，你想去展示和展示部分，做一个展示，告诉我，嘿，这是我做这个升级部分的GitHub回购。

18025
29:45:10.003 --> 29:45:29.535
到这里来，为这句话感到兴奋去喝杯咖啡休息去散步去健身房去兴奋去告诉你的朋友我们快完成了我们还有两节课，然后你就自由了好了，欢迎回到第十七课给硬帽们。

18026
29:45:29.535 --> 29:45:31.249
杜丝，你快完成了。

18027
29:45:31.249 --> 29:45:38.460
在本节中，我已经做了一个视频，讲的是如何用TypeScript和JavaScript中的固体性来编写销子。

18028
29:45:38.460 --> 29:45:41.878
我们只播放这一节的视频。

18029
29:45:41.878 --> 29:45:45.865
我们要展示这个的原因是因为我做了很多工作让这个看起来很好。

18030
29:45:45.865 --> 29:45:48.416
它仍然是令人难以置信的最新的。

18031
29:45:48.416 --> 29:45:51.059
这将在TypeScript和solidity中。

18032
29:45:51.059 --> 29:45:56.805
但是，我们将在视频部分的代码中有JavaScript版本的代码库。

18033
29:45:56.805 --> 29:46:04.664
如果你想要这个增量模板代码的最新版本，你可以使用，你可以选择这个最新的代码，它会进入这个怀疑模板回购。

18034
29:46:04.664 --> 29:46:11.768
我将定期用新的Dao示例和新方法来更新这个回购，以创建疑问或分散自治组织。

18035
29:46:11.768 --> 29:46:15.507
现在，在我们学习如何编码一个怀疑之前，我们应该了解什么是DAO。

18036
29:46:15.507 --> 29:46:18.440
再说一次，我已经做了一个视频，我花了很多功夫。

18037
29:46:18.440 --> 29:46:23.276
我们先从高层次上看一下什么是道琼斯指数，然后再学习如何编码道琼斯指数。

18038
29:46:23.276 --> 29:46:25.950
最后一节是安全与审计。

18039
29:46:25.950 --> 29:46:27.043
我们要把这个做完。

18040
29:46:27.107 --> 29:46:30.090
Bucklin，让我们学习一下什么是道琼斯指数。

18041
29:46:32.107 --> 29:46:35.545
建立一个道琼斯指数，让我们这么做吧。

18042
29:46:39.107 --> 29:46:42.773
自治组织是一个有点超载的术语。

18043
29:46:43.107 --> 29:46:49.623
它通常描述由区块链或智能合约上的一组透明规则管理的任何组。

18044
29:46:49.623 --> 29:46:55.899
我说过载，是因为有人说比特币下跌了，因为矿工可以选择是否升级他们的软件。

18045
29:46:55.899 --> 29:47:01.624
其他人则认为Dows必须使用透明的智能合约，这种合约的规则已经根深蒂固。

18046
29:47:01.624 --> 29:47:07.573
然后其他人认为道只是一个流行词，所以他们就把接力这个名字贴在任何组织上，这样他们就能获得一些影响力。

18047
29:47:07.573 --> 29:47:09.734
这让人很难过，帕特里克。

18048
29:47:09.734 --> 29:47:19.074
不要把它和道琼斯指数搞混了，道琼斯指数是2016年道琼斯指数的实现，创下了当时最大的黑客攻击记录。

18049
29:47:19.074 --> 29:47:23.807
所以有很多不同的思考方式道指这个术语有很多不同的用法。

18050
29:47:23.807 --> 29:47:29.831
但本质上，想象一下，如果谷歌的所有用户都被赋予了谷歌下一步应该做什么的投票权。

18051
29:47:29.831 --> 29:47:34.526
投票的规则是不变的，透明的，分散的。

18052
29:47:34.526 --> 29:47:45.615
这解决了信任、中心性和透明度的老问题，并将权力交给不同协议和应用程序的用户，而不是一切都在关起门来。

18053
29:47:45.615 --> 29:47:56.240
这个投票部分是这些如何运作去中心化治理的基石，如果你愿意的话，它可以被专门通过代码运作的公司或组织总结。

18054
29:47:56.240 --> 29:48:11.294
为了真正理解这一切，我们要深入了解协议的背后它为所有其他的怀疑和复合设定了先例，然后一旦我们了解复合，我们就会明白构建其中一个的过程以及所有的权衡，所有不同的架构选择对你的团队意味着什么。

18055
29:48:11.294 --> 29:48:17.785
在我的下一个视频中，我将为开发者提供一个完整的教程，帮助他们自己构建一个这样的工具。

18056
29:48:17.785 --> 29:48:22.525
但是一定要看这个视频的剩余部分因为它会给你所有的架构基础知识。

18057
29:48:22.525 --> 29:48:26.007
所以当你到达那个部分时，你可以做出明智的决定。

18058
29:48:26.007 --> 29:48:28.884
一定要让你和道琼斯的朋友们点击“点赞”和“订阅”按钮。

18059
29:48:28.884 --> 29:48:35.503
因此，当涉及到智能合约时，我们可以继续为您提供地球上最好的工程师第一内容。

18060
29:48:35.503 --> 29:48:36.434
让我们开始吧。

18061
29:48:36.434 --> 29:48:38.499
这里我们有一个复合协议。

18062
29:48:38.499 --> 29:48:44.042
它是一个借贷应用程序，允许用户借贷他们的资产。

18063
29:48:44.107 --> 29:48:46.572
这个应用程序的一切都是在智能合约中构建的。

18064
29:48:46.572 --> 29:49:00.123
通常，他们会想做很多新事情，也许他们想添加一个新的令牌来允许借贷，也许他们想改变一些API参数，也许他们想阻止某些货币，他们可能想做很多不同的事情。

18065
29:49:00.123 --> 29:49:10.575
这就是我们要讲到治理的地方，在这里你可以找到一个用户界面列出所有的提案和所有不同的投票结果。

18066
29:49:10.575 --> 29:49:15.852
这里是一些治理建议的列表，该协议实际上已经做出了改进。

18067
29:49:15.852 --> 29:49:19.143
让我们来看看其中一个目前正在进行中的提议。

18068
29:49:19.143 --> 29:49:27.293
如果我们点击提案，我们会看到提案的所有内容，谁投了票谁投了反对票，还有提案的历史。

18069
29:49:27.293 --> 29:49:32.654
这些提案的第一件事是有人必须在提案的交易中创建提案。

18070
29:49:32.654 --> 29:49:36.607
我们可以在这里看到提议的交易。

18071
29:49:36.607 --> 29:49:42.589
如果我们点击这个，向下滚动，我们可以看到他们用来提出这个建议的确切参数。

18072
29:49:42.589 --> 29:49:45.583
让我们继续解码输入数据。

18073
29:49:45.583 --> 29:49:48.057
我们可以看到这就是这个提案的样子。

18074
29:49:48.057 --> 29:49:54.370
它们通常的划分方式是它们有一个地址列表和一个调用这些地址的函数列表。

18075
29:49:54.370 --> 29:49:57.683
显然，还有传递这些地址的参数。

18076
29:49:57.683 --> 29:50:06.124
所以这个提议说，嘿，我想在这个地址上呼叫支持市场，在这个地址上设置备用因子。

18077
29:50:06.124 --> 29:50:08.558
这是我们要传递的参数。

18078
29:50:08.558 --> 29:50:10.365
它们显然是用字节编码的。

18079
29:50:10.365 --> 29:50:15.139
这是描述字符串说明它在做什么以及为什么要这样做。

18080
29:50:15.139 --> 29:50:28.907
我们必须进行这个建议治理过程的原因是，这些契约可能具有访问控制，只有这些契约的所有者才能实际调用这些do函数，而这两个契约的所有者很可能是这种治理风格。

18081
29:50:28.907 --> 29:50:29.457
和价值观。

18082
29:50:29.457 --> 29:50:48.813
零仅仅意味着我们不会在这些交易中发送任何信息，一旦提案被创建，在短暂的延迟后变为活跃状态，这是人们真正开始投票的时候，提案和投票行为之间的延迟可以被改变或修改，这取决于你的怀疑，然后人们有一些时间开始投票。

18083
29:50:48.813 --> 29:50:57.732
如果它通过了，就像这个压倒性地通过了，它达到了成功，我们再次点击这个事务，然后我们进入复合治理契约。

18084
29:50:57.732 --> 29:51:12.412
我们向下滚动到合同，权利作为代理，我们实际上可以看到人们调用投票的确切功能，即投票投票，投票，签名投票和理性投票。

18085
29:51:12.412 --> 29:51:16.537
我们会在下一集视频中讨论它们之间的确切区别。

18086
29:51:16.537 --> 29:51:19.607
但这些是它们实际调用的函数。

18087
29:51:19.607 --> 29:51:28.848
如果你去复合应用，我们去投票，这是一个用户界面，你可以投票，让它更容易，如果你不是技术通。

18088
29:51:28.848 --> 29:51:31.916
所以你可以直接在财经的app。compound中投票。

18089
29:51:31.916 --> 29:51:34.530
或者您可以自己发送交易。

18090
29:51:34.530 --> 29:51:36.287
一旦所有的投票都发生了。

18091
29:51:36.287 --> 29:51:38.188
它到达这个排队阶段。

18092
29:51:38.188 --> 29:51:48.693
那么排队是什么意思呢?在提案真正生效之前，提案通过和执行之间有一个最小的延迟。

18093
29:51:48.693 --> 29:51:51.640
所以必须有人调用这个可爱的函数。

18094
29:51:51.640 --> 29:51:54.506
而且只有在投票通过的情况下才能宣布选举结果。

18095
29:51:54.506 --> 29:51:59.357
它说，好的，邮政ID已经被提示，我们很快就会执行它。

18096
29:51:59.357 --> 29:52:09.145
现在，如果我们看一个不同的提议，比如这个，我们可以看到它已经被执行了，我们可以看到有人叫这个被执行的函数。

18097
29:52:09.145 --> 29:52:11.475
他们执行了提案A的细节。

18098
29:52:11.475 --> 29:52:17.551
这将是一个完整的提案生命周期的例子通过这个过程。

18099
29:52:17.551 --> 29:52:22.025
现在有一些甚至失败了，很多人投了反对票。

18100
29:52:22.025 --> 29:52:27.376
如果你向下滚动，你可以看到它被创建了，它是活跃的，大多数人投了反对票。

18101
29:52:27.376 --> 29:52:28.963
到此为止。

18102
29:52:28.963 --> 29:52:41.571
现在，通常情况下，仅仅通过这些提案中的一个并不足以真正获得一些选票，你通常需要一个论坛或某种类型的讨论场所来讨论这些提案，以及你为什么喜欢或不喜欢它们。

18103
29:52:41.571 --> 29:52:47.907
通常情况下，话语是人们争论为什么某事是好的，或者为什么某事是坏的主要场所之一。

18104
29:52:47.907 --> 29:52:50.522
所以人们可以对这些改变进行投票。

18105
29:52:50.522 --> 29:53:08.445
再说一遍，snapshot可能是其中一种工具，你可以用它来判断你的社区是否需要一些东西，甚至在它进行投票之前，你可以加入其中一个，用你的令牌实际上对事物进行投票，而不执行它们，只是为了获得情绪，或者像我之前说的，你可以构建你的协议，快照实际上帮助你进行投票过程。

18106
29:53:08.445 --> 29:53:13.589
好了，现在你已经看到了影响投票的所有其他细节的协议。

18107
29:53:13.589 --> 29:53:21.549
现在，你知道，现在我们知道了一个怀疑是什么样子的，让我们谈谈构建其中一个的架构和工具，以及它们之间的权衡。

18108
29:53:21.549 --> 29:53:25.433
首先要讨论的是投票机制。

18109
29:53:25.433 --> 29:53:33.657
现在，在去中心化治理中投票是至关重要的，因为有时他们确实需要更新和改变，以跟上时代。

18110
29:53:33.657 --> 29:53:39.624
不是所有的协议都需要有一个陶氏指数，但那些需要有疑问的协议需要一种让参与者参与的方式。

18111
29:53:39.624 --> 29:53:44.210
这是问他告诉你的社区的最重要的问题之一。

18112
29:53:44.210 --> 29:53:53.456
我如何参与?我该如何面对这种怀疑?我如何帮助你做决定，你会发现这是一个很难解决的问题。

18113
29:53:53.456 --> 29:53:59.844
现在，解决这个问题的一个简单方法是使用ERC 20或NFT令牌作为投票权。

18114
29:53:59.844 --> 29:54:07.762
类似于我们看到的复合使用comp令牌来为不同的提案投票似乎很简单，对吧?问题解决了，格雷。

18115
29:54:07.762 --> 29:54:11.175
现在，这实际上可能是解决某些疑问的正确方法。

18116
29:54:11.175 --> 29:54:13.821
但它也存在实际上不那么公平的风险。

18117
29:54:13.821 --> 29:54:23.707
因为当你把投票权代币化的时候，你实际上是在拍卖这个投票权给那些最有钱的人，那些最有钱的人可以选择改变。

18118
29:54:23.707 --> 29:54:34.757
所以如果只有富人有权投票，那么很有可能协议中的所有变化都会让富人受益，这对我们现在的世界来说似乎并不是很大的改善。

18119
29:54:34.757 --> 29:54:41.419
如果T很有趣，因为它们有不可替代的成分，但是，即使它们仍然会遇到这个问题。

18120
29:54:41.419 --> 29:54:45.547
此外，如果你买了一大堆选票，你就做出了一个糟糕的决定，然后卖掉了所有的选票。

18121
29:54:45.547 --> 29:54:49.857
你作为一个个体并不会受到惩罚，你只是在惩罚整个群体。

18122
29:54:49.857 --> 29:54:59.773
但如果你是恶意的，你可以毫发无损地离开现在再说一次，这个投票机制对一些群体是正确的，但对另一些群体，可能不是。

18123
29:54:59.773 --> 29:55:02.428
这完全取决于你的底层社区设置是什么样子的。

18124
29:55:02.428 --> 29:55:04.868
下一个我们要讲的是博弈中的风险。

18125
29:55:04.868 --> 29:55:15.700
metal已经写了很多关于这方面的文章，我强烈建议你阅读他的文章，链接在描述中，看看游戏方法中的皮肤意味着无论何时你做了一个决定，你的投票都会被记录下来。

18126
29:55:15.700 --> 29:55:21.022
如果这个决定导致了一个糟糕的结果，您的代币将被砍掉。

18127
29:55:21.107 --> 29:55:25.673
你为你的道和你的礼仪做了邪恶或错误的决定，你会受到惩罚。

18128
29:55:25.673 --> 29:55:31.994
我喜欢这种心态，因为即使你买了一吨代币，并决定用它生病，你可以为你的错误决定负责。

18129
29:55:31.994 --> 29:55:44.589
现在，最困难的部分是，作为一个社区，我们如何做出决定?什么是坏结果?我们要如何惩罚这些人?这很简单，因为答案是，我不确定。

18130
29:55:44.589 --> 29:55:51.058
现在，这个投票机制的第三个方法可能是最有趣的一个，但也是最难实现的一个。

18131
29:55:51.107 --> 29:55:54.218
这是人格或参与的证明。

18132
29:55:55.107 --> 29:56:00.710
仅仅因为使用了该协议，所有复合协议的用户都获得了一票。

18133
29:56:00.710 --> 29:56:04.520
即使他们有1000个钱包，他们也会使用协议。

18134
29:56:04.520 --> 29:56:11.434
一个人意味着一票，这将是令人惊讶的，一个更公平的实现，选票实际上不能被收买。

18135
29:56:11.434 --> 29:56:24.477
然而，问题在于所谓的公民抵抗，我们如何才能确保一票等于一个参与者，而不是一个参与者假装成1000个不同的人，从而获得更多的选票。

18136
29:56:24.477 --> 29:56:26.027
这个方法还没有被真正解决。

18137
29:56:26.027 --> 29:56:34.714
但我敢打赌，某个非常聪明的工程师会做一些惊人的链链集成，因为人格证明基本上只是链外数据，可以在链上传递。

18138
29:56:34.714 --> 29:56:36.916
这正是通灵的亮点所在。

18139
29:56:36.916 --> 29:56:42.503
你可以看到所有这些方法甚至更多你可能想到的方法都不是那么牵强。

18140
29:56:42.503 --> 29:56:46.457
我们在现实世界中也能看到完全相同的方法。

18141
29:56:46.457 --> 29:56:53.381
人格证明或参与证明可能与我们每天看到的常规政府投票完全相同。

18142
29:56:53.381 --> 29:57:00.726
在美国，至少有一个人可以投票给一个总统，你不能到处制造一堆假人来投票给总统。

18143
29:57:00.726 --> 29:57:08.503
但在公司中ERC 20投票标准是适用的，你拥有的公司股份越多你在公司的投票权就越大。

18144
29:57:08.503 --> 29:57:13.107
因此，我们可以将现实世界与智能合约中投票和治理的工作方式进行类比。

18145
29:57:13.107 --> 29:57:17.276
事实上，你应该做对比，从网络到太空中寻找灵感。

18146
29:57:17.276 --> 29:57:55.551
现在实施投票时,我把它们分为两类链投票,投票链链投票就是我们看到的化合物,聪明的合同链,你的选民,你调用某些函数称为投票与元面具分类帐等等,发送一个事务和投票,投票恭喜,你可以穿你的小贴纸现在称之为函数发送一个事务,你送一个事务,哪些交易使用起来有点烦人，有点昂贵?哦，对了，我想象一下，你的社区有1万人，每个人投票要花费100美元，你现在要花费你的社区100万美元。

18147
29:57:55.551 --> 29:57:57.652
任何时候你想改变什么。

18148
29:57:57.652 --> 29:58:03.125
这显然是疯狂的，而且对您的社区来说不是很可持续的，因为架构真的很简单。

18149
29:58:03.125 --> 29:58:05.693
所有东西都是透明的，所有东西都在链上。

18150
29:58:05.693 --> 29:58:06.630
这真的很好。

18151
29:58:06.630 --> 29:58:10.460
但是，是的，缺点是你可能会打破很多人的银行账户。

18152
29:58:10.460 --> 29:58:15.345
现在有很多这样的变化来帮助解决这些问题，特别是气体问题。

18153
29:58:15.345 --> 29:58:25.124
其中一个让我非常兴奋的是这个叫做州长席位的地方，他们使用一些随机抽样来做一些二次投票来帮助减少成本同时增加民众的反抗。

18154
29:58:25.124 --> 29:58:28.647
如果你想了解更多，一定要在描述中阅读。

18155
29:58:28.647 --> 29:58:30.810
链式投票是最简单的。

18156
29:58:30.810 --> 29:58:33.951
我们来谈谈非链式投票。

18157
29:58:33.951 --> 29:58:49.294
为了把投票投到去中心化的环境，放松，放松，你可以投到去中心化链，但仍然拥有100%的去中心化，你实际上可以签署一个交易，签署一个投票，而不实际发送到区块链，因此不实际花费任何汽油。

18158
29:58:49.294 --> 29:58:57.360
相反，你能做的是将签名事务发送到去中心化数据库，比如IPFS，计算IPFS中的所有选票。

18159
29:58:57.360 --> 29:59:05.039
然后，当时间到来时，将数据的结果通过Oracle之类的链链接传递到区块链，所有这些都在单个事务中完成。

18160
29:59:05.039 --> 29:59:13.660
或者，你可以做的是在一个交易中重播所有相同的交易以节省汽油，这可以减少高达99%的投票成本。

18161
29:59:13.660 --> 29:59:19.203
现在，这是一个实现，最流行的实现方式之一是通过快照。

18162
29:59:19.203 --> 29:59:26.840
我非常渴望有人能做一个链式集成因为这样会更安全，更可靠，更好等等，等等，为它而死。

18163
29:59:26.840 --> 29:59:28.583
这是你们的行动号召去建造这个东西。

18164
29:59:28.583 --> 29:59:29.154
此选项。

18165
29:59:29.154 --> 29:59:38.365
显然，投票机制为社区节省了大量的资源，并且可以更有效地存储这些事务，然而，它需要非常谨慎地实现。

18166
29:59:38.365 --> 29:59:45.881
如果您通过集中式Oracle运行整个Dow，那么您实际上是重新引入了一个集中式中介，并破坏了应用程序的良好质量。

18167
29:59:45.881 --> 29:59:46.703
所以不要这样做。

18168
29:59:46.703 --> 29:59:50.300
如果你做到了视频的这一点，给自己一点鼓励。

18169
29:59:50.300 --> 29:59:51.412
你做得很好。

18170
29:59:51.412 --> 29:59:51.895
太棒了。

18171
29:59:51.895 --> 30:00:02.325
就像我说的，在这之后我会有一个视频，它将从头到尾地向你展示如何从零开始构建一个这样的东西，让我们来学习一些工具，你可以使用它们来帮助你更快地跟上进度。

18172
30:00:02.325 --> 30:00:09.464
现在有很多无代码的解决方案可以用来建造一个陶叠阿拉贡销子。

18173
30:00:09.464 --> 30:00:17.779
开个玩笑，这是阿拉贡，殖民地和道屋都是可以帮助你运行道和建立怀疑的替代方案。

18174
30:00:17.779 --> 30:00:24.336
但是，如果您想要更细粒度的控制，并且不想支付与这些协议相关的任何费用，那么您可能希望从头开始。

18175
30:00:24.336 --> 30:00:31.395
现在让我们讨论一些您可以使用的更多的Cody解决方案，快照是最流行的工具之一，用于获取Dao的情绪。

18176
30:00:31.395 --> 30:00:39.044
实际执行时，用户可以用他们实际的令牌投票通过这个协议，这些交易被存储在IPFS中。

18177
30:00:39.107 --> 30:00:41.125
但实际上没有一个会被执行。

18178
30:00:42.107 --> 30:00:47.074
选择，这是一个很好的方式来了解你的道琼斯想要做什么。

18179
30:00:47.074 --> 30:01:04.407
此外，你还可以发送交易并执行投票，强烈建议你使用Zodiac，这是一套数据库工具，你可以将其实现到你的Dallas中，计数是另一种ui，它可以让人们看到并实际投票，并通过用户界面与这些智能合约交互。

18180
30:01:04.407 --> 30:01:09.526
所以那些不知道Gnosis安全的人，你绝对应该知道安全是一个多SIG钱包。

18181
30:01:09.526 --> 30:01:21.779
我把它列在列表上的原因是，尽管它增加了一些中心性的成分，大多数的销子在开始的时候，可能会以某种类型的中心性开始，当你没有1000人等待投票的时候，更快会更容易。

18182
30:01:21.779 --> 30:01:33.977
在开始的时候，任何协议都在某种程度上是集中的，使用multisig，我们通过一些关键成员进行投票，在开始的时候对你的拨号盘来说是很好的，通常也是紧急情况。

18183
30:01:33.977 --> 30:01:41.422
但请记住，当你增加其中一个时，你就增加了这种程度的中心性，当然，我们喜欢的开放和契约就会开放和契约。

18184
30:01:41.422 --> 30:01:44.522
我们的Dao代码将基于这些契约。

18185
30:01:44.522 --> 30:01:46.345
好了，这就是所有的工具。

18186
30:01:46.345 --> 30:01:47.488
这就是架构。

18187
30:01:47.488 --> 30:02:14.679
在我讲法律之前还有一件事，Dows的未来很有趣因为我们刚才讲过的这些原因，但尤其是在法律方面，怀疑公司和其他公司遵守同样的规定有意义吗?为什么你要强迫它去做什么呢，你必须强制他们以某种方式投票如果政府让你这么做的话，这有点灰色，很难确定谁应该负责现在美国至少你可以建立自己的道琼斯指数并在怀俄明州得到法律认可。

18188
30:02:14.679 --> 30:02:16.172
这是我想做的事。

18189
30:02:16.172 --> 30:02:18.435
所以我们只需要看看会发生什么。

18190
30:02:18.435 --> 30:02:28.478
哦，在这一点上，你已经被注入了陶氏所需的所有知识，你需要成功和发展这个令人惊叹的新技术和这些令人惊叹的新概念。

18191
30:02:28.478 --> 30:02:29.819
我发现他们杀了孩子。

18192
30:02:29.819 --> 30:02:32.446
好吧，你听到他说的了是时候开工了。

18193
30:02:32.446 --> 30:02:43.865
就像我们说的，所有的代码都位于小于17的位置，让我们开始。

18194
30:02:44.108 --> 30:02:52.371
在这个视频中，我们将向你们展示如何通过合成来建立你自己的怀疑现在这将100%关于链式投票和链式治理。

18195
30:02:52.371 --> 30:02:59.017
我们将向你展示最简单的方法，旋转一个非ft或ERC 20投票类型，所有使用固体和硬帽。

18196
30:02:59.017 --> 30:03:07.091
如果你还没有看过我上一集关于Dows体系结构的视频，那么一定要先看那个视频，然后再看这个视频。

18197
30:03:07.091 --> 30:03:15.026
因为那个视频解释了我们在这里所做的一切背后的哲学我们将使用开放，契约和一个硬帽框架来建立这一切。

18198
30:03:15.026 --> 30:03:21.108
如果你想看一个全新的或python版本的操作，请查看描述中的链接，因为我们最近在chainlink黑客马拉松上做了一个视频。

18199
30:03:21.108 --> 30:03:28.253
另外，我们知道，因为我们是100%用链条煤气，所以费用会很贵。

18200
30:03:28.253 --> 30:03:34.822
所以我真的很期待有人做一个链连接加上IPFS加上快照集成这样我们就可以在链外完成所有这些。

18201
30:03:34.822 --> 30:03:37.694
一旦它存在，你们已经知道了，我会做一个关于它的教程。

18202
30:03:37.694 --> 30:03:43.941
如果你喜欢这种风格的内容，一定要点击喜欢按钮，订阅并在评论区留言，告诉我你想看什么。

18203
30:03:43.941 --> 30:03:47.624
接下来，让我知道您希望如何增强您的智能合约开发人员体验。

18204
30:03:47.624 --> 30:03:48.590
让我们开始吧。

18205
30:03:48.590 --> 30:04:00.567
这就是我们要建立的东西，我们会有一个非常基础的智能合约，它叫box它能做的就是存储一个值然后检索一个值。

18206
30:04:00.567 --> 30:04:02.534
但问题是，它是可以拥有的。

18207
30:04:02.534 --> 30:04:09.642
只有契约的所有者才能调用store函数并猜出所有者是谁所有者是疑问。

18208
30:04:09.642 --> 30:04:14.534
所以只有通过治理的过程，任何人都可以在这里存储不同的功能。

18209
30:04:14.534 --> 30:04:24.723
一旦我们完成了，我们将经历提议投票排队的整个过程，然后在Dao中执行一个事务来更新我们的Bach契约。

18210
30:04:24.723 --> 30:04:29.824
这就是这些Dao设置的美妙之处在于它们是完全模块化的。

18211
30:04:29.824 --> 30:04:41.157
所以当我经历整个过程时，我会在这里做Hardhead测试，我现在的测试是用来做所有事情的，我们会看到道琼斯指数的每一步。

18212
30:04:41.157 --> 30:04:44.311
我们看到方框的起始值是0。

18213
30:04:44.311 --> 30:04:47.337
然后所有这些东西都将进入治理过程。

18214
30:04:47.337 --> 30:04:48.353
这些只是一些笔记。

18215
30:04:48.353 --> 30:04:51.012
人们基本上是在投票、排队和执行。

18216
30:04:51.012 --> 30:04:57.684
最后，我们通过一个投票过程来确定盒子合同的价值。

18217
30:04:57.684 --> 30:04:59.944
这正是我们今天要向你们展示的方法。

18218
30:04:59.944 --> 30:05:08.841
记住，我们这里要做的所有代码都在我的怀疑模板GitHub repo中，所以如果你迷路了，可以参考这个来开始。

18219
30:05:08.841 --> 30:05:21.358
另外，如果你想看这个的python版本，请回到downmix，主要的事情是，尽管所有的契约都是一样的，无论什么布朗尼硬帽，dab工具，代工厂，这都没关系。

18220
30:05:21.358 --> 30:05:24.369
这部分的第一部分是完全一样的。

18221
30:05:24.369 --> 30:05:26.631
这是我们的议程。

18222
30:05:26.631 --> 30:05:28.726
首先，我们要写智能合约。

18223
30:05:28.726 --> 30:05:33.950
如果你不熟悉Hardhead，没关系，我们会先做智能合约，然后再写部署脚本。

18224
30:05:33.950 --> 30:05:36.822
这就是你的硬帽知识将发挥作用的地方。

18225
30:05:36.822 --> 30:05:41.049
我们将在TypeScript中编写部署脚本，因为TypeScript非常了不起。

18226
30:05:41.049 --> 30:05:45.955
如果你不熟悉TypeScript，我建议你用JavaScript重写它，然后做一个JavaScript版本。

18227
30:05:45.955 --> 30:05:52.089
最后，我们将编写一些脚本，用部署的契约与治理进行交互。

18228
30:05:52.089 --> 30:06:03.659
现在，快速说明一下，这不是我最初构建它的方式，我不只是阅读智能合约，编写部署脚本，编写脚本，然后进行测试，然后我完成了，我在测试，智能合约，部署脚本之间来回切换。

18229
30:06:03.659 --> 30:06:06.962
如果你在想，哦，我的天，这对他来说太容易了。

18230
30:06:06.962 --> 30:06:07.591
所以无缝。

18231
30:06:07.591 --> 30:06:10.552
当我最初编写这段代码时，它有很多来回。

18232
30:06:10.552 --> 30:06:14.076
这就是你应该如何进行开发，你将在测试和智能合约之间转换。

18233
30:06:14.108 --> 30:06:18.108
此外，在本教程中，我们将向你展示一些恶心的硬头技能。

18234
30:06:18.108 --> 30:06:24.337
所以你们不仅要学习如何建立道琼斯指数，还要学习一些非常高级的硬头牌技能。

18235
30:06:24.337 --> 30:06:25.730
让我们开始吧。

18236
30:06:25.730 --> 30:06:26.877
让我们开始吧。

18237
30:06:26.877 --> 30:06:29.465
我使用的代码编辑器是Visual Studio代码。

18238
30:06:29.465 --> 30:06:32.457
因此，请确保您有一个代码编辑器，可以随时使用。

18239
30:06:32.457 --> 30:06:35.556
这里你需要一些先决条件。

18240
30:06:35.556 --> 30:06:40.575
前提条件在GitHub存储库中，我们需要Git，而不是J。

18241
30:06:40.575 --> 30:06:48.462
纱线，如果你只是想克隆这个回购，并按照这里的说明开始，你完全可以，然后你甚至不需要从头开始构建它。

18242
30:06:48.462 --> 30:06:50.338
但是我们想要学习从零开始建造它。

18243
30:06:50.338 --> 30:06:52.548
让我们开始gitusdash版本。

18244
30:06:52.548 --> 30:06:55.937
很好，我们没有破折号版本。

18245
30:06:56.108 --> 30:06:58.708
很好，我们有节点，然后纱线破折号版本。

18246
30:06:59.108 --> 30:07:00.338
我们有纱线，可以开始了。

18247
30:07:01.108 --> 30:07:04.882
我们将在这里为包安装它将是一个开发依赖。

18248
30:07:04.882 --> 30:07:11.308
所以我们要做的第一件事是做纱线，添加dash Dev，安全帽，如果你还没有的话。

18249
30:07:11.308 --> 30:07:16.822
在文件夹中，我们会有node modules package。JSON readme和一个锁。

18250
30:07:16.822 --> 30:07:21.318
当然，现在我们有了，我们可以运行纱线RDAP，我们将得到硬帽CLI。

18251
30:07:21.318 --> 30:07:27.862
我们会把所有这些东西都放在这里，我们会创建一个空hardhat。config。js，我们会把它变成TypeScript。

18252
30:07:27.862 --> 30:07:30.704
高级示例TypeScript项目有一堆我不喜欢的东西。

18253
30:07:30.704 --> 30:07:32.536
所以我们要创建一个空的硬磁头。

18254
30:07:32.536 --> 30:07:32.857
配置。

18255
30:07:32.857 --> 30:07:32.964
js。

18256
30:07:32.964 --> 30:07:35.318
太好了，我们有一个小安全帽。

18257
30:07:35.318 --> 30:07:35.739
配置。

18258
30:07:35.739 --> 30:07:35.879
js。

18259
30:07:35.879 --> 30:07:39.894
现在让我们继续创建一个文件夹，或者说是合同文件夹。

18260
30:07:39.894 --> 30:07:42.548
这就是我们要添加所有契约的地方。

18261
30:07:42.548 --> 30:07:50.353
我们需要的第一个契约是我们想要治理的契约，在我们的例子中是box。soul。

18262
30:07:50.353 --> 30:07:56.308
现在，我要复制粘贴我的方框，这里的灵魂，因为它不是特别有趣。

18263
30:07:56.308 --> 30:07:58.727
你可以在这里写任何你想写的东西。

18264
30:07:58.727 --> 30:08:05.786
请随意暂停视频，从我的GitHub回购中复制粘贴，创建你自己的治理合同，你想玩的，或在这里做任何你想做的。

18265
30:08:05.786 --> 30:08:13.574
但对我们来说，我们只有一个存储函数，一个检索函数，一个事件，还有一个私有值我们会存储和检索它。

18266
30:08:13.574 --> 30:08:14.507
就是这样。

18267
30:08:14.507 --> 30:08:16.697
当然，我们想解决这个问题。

18268
30:08:16.697 --> 30:08:20.295
我们从openzeppelin的合同中进口，这是惊人的。

18269
30:08:20.295 --> 30:08:25.974
我们要加上这个我们要做yarn，加上dash Dev, at打开合同。

18270
30:08:25.974 --> 30:08:28.633
这样就可以去掉盒子了。

18271
30:08:28.633 --> 30:08:29.565
这是所有。

18272
30:08:29.565 --> 30:08:31.005
让我们重新打开盒子。

18273
30:08:31.005 --> 30:08:33.755
看来我们绕了个弯子才达到那个完美的境界。

18274
30:08:33.755 --> 30:08:38.429
至于扩展，我用的是固体，一个Blonko，狭缝扩展。

18275
30:08:38.429 --> 30:08:40.676
这就是我们得到这些美妙的绒毛的原因。

18276
30:08:40.676 --> 30:08:40.986
太好了。

18277
30:08:40.986 --> 30:08:47.908
现在我们要检查这个是否编译如果使用remix，你可以用remix hard hat编译，你会看到我们是如何编译的。

18278
30:08:47.908 --> 30:08:52.060
或者如果你用Browning，我们只是想看看这个编译是否正确。

18279
30:08:52.108 --> 30:08:54.452
所以run yarn有了一个不小的打击Compile。

18280
30:08:56.108 --> 30:08:59.686
一些编译错误，因为我们需要更新这个，让我们用这8个。

18281
30:08:59.686 --> 30:09:01.791
我们会试着再编译一次。

18282
30:09:01.791 --> 30:09:04.768
完美看起来像是编译成功了。

18283
30:09:04.768 --> 30:09:08.041
看这里，我们的合同确实在这里。

18284
30:09:08.041 --> 30:09:10.371
好了，很好，简单的部分都搞定了。

18285
30:09:10.371 --> 30:09:10.792
了。

18286
30:09:10.792 --> 30:09:11.739
真快啊。

18287
30:09:11.739 --> 30:09:13.415
现在让我们开始创建下一部分。

18288
30:09:13.415 --> 30:09:14.883
让我们创建治理部分。

18289
30:09:14.883 --> 30:09:21.832
所以我们要做的就是建立这个治理平台我们要在ERC的基础上建立它。

18290
30:09:21.832 --> 30:09:24.353
20标准，所以你会得到一个ERC 20代币。

18291
30:09:24.353 --> 30:09:27.008
这将是你可以投票的代币。

18292
30:09:27.108 --> 30:09:31.418
让我们创建一个名为governance token的新文件。

18293
30:09:32.108 --> 30:09:34.006
所有治理令牌。Sol。

18294
30:09:36.108 --> 30:09:37.531
我们用来投票的代币。

18295
30:09:38.108 --> 30:09:40.076
创建一个正常的ERC 20令牌。

18296
30:09:42.108 --> 30:09:45.398
让它治理一个碗，你马上就会明白我的意思。

18297
30:09:45.398 --> 30:09:50.237
让我们继续设置这个spdx许可标识符。

18298
30:09:50.237 --> 30:09:56.701
这是MIT的pragma solidity我们用0。

18299
30:09:56.701 --> 30:09:56.785
8.

18300
30:09:56.785 --> 30:10:09.624
然后我们会做合约治理令牌，然后我们会说，是ERC 20，我将继续导入openzeppelin，因为open Zeppelin有一个包，里面基本上有我们需要的ERC 20令牌的所有东西。

18301
30:10:09.624 --> 30:10:26.954
我们会说import at open Zeppelin /合约/令牌/ ERC 20x我们可以去他们的github openzeppelin合同令牌，你的C 20我们会做ERC 20 Dotto，我们现在这样做。

18302
30:10:27.108 --> 30:10:29.002
令牌，使用你的c20 ditzel。

18303
30:10:31.108 --> 30:10:32.901
不要担心这个。

18304
30:10:35.108 --> 30:10:44.264
公共存储最大供应，这是最好的做法，但没关系，我们会给这个最大供应这么多将是1-234-567-8910 12345678。

18305
30:10:44.264 --> 30:10:49.026
这是100万，我们要发行100万枚代币。

18306
30:10:49.026 --> 30:10:53.885
然后我们会创建构造函数构造或者你的c20。

18307
30:10:53.885 --> 30:10:59.358
给它一个治理令牌作为名称，然后我们的符号将是GT。

18308
30:10:59.358 --> 30:11:07.463
对于那些不知道的人，当你在构造函数中继承另一个契约时，你也可以使用那个继承的契约构造函数。

18309
30:11:07.463 --> 30:11:14.829
事实上，我认为你必须，所以治理令牌G团队，然后我们甚至会调用其中一个ERC 20函数叫做mint。

18310
30:11:14.829 --> 30:11:22.179
我们会给发送者发信息，所以谁部署了ERC 20合同就意味着他们拥有一切，所有的最大供应。

18311
30:11:22.179 --> 30:11:26.076
通常情况下，如果这是一个正常的ERC 20代币，你就完成了。

18312
30:11:26.076 --> 30:11:28.358
但这不是一个普通的ERC 20代币。

18313
30:11:28.358 --> 30:11:39.314
看，当我们进行投票时，我们需要确保它是公平的，想象一下，有人知道一个热门提案即将提出，他们想要投票。

18314
30:11:39.314 --> 30:11:42.591
所以他们买了很多代币。

18315
30:11:42.591 --> 30:11:46.058
投票结束后他们就把它扔了。

18316
30:11:46.058 --> 30:11:47.616
我们希望避免这种情况。

18317
30:11:47.616 --> 30:11:51.608
我们希望避免人们只是通过买卖代币来参与治理。

18318
30:11:51.608 --> 30:12:03.219
我们所做的就是创建一个快照，记录人们在某个区块拥有多少代币，记录人们在某个区块拥有多少代币。

18319
30:12:03.219 --> 30:12:17.420
我们想要确保，一旦提案通过，我们实际上从过去的快照中选择一个我们想要使用的这种激励人们不只是在提案通过时跳进去，然后跳出去因为一旦提案通过，它使用了过去的块快照。

18320
30:12:17.420 --> 30:12:20.233
所以我们需要做一点改变。

18321
30:12:20.233 --> 30:12:32.753
我们要把这个从ERC 20改成ERC 20投票，我们实际上可以在打开的齐柏林飞艇和扩展中看到这个灵魂契约的ERC 20投票。

18322
30:12:32.753 --> 30:12:39.483
如果我们回到国税局的GitHub，我们可以看到ERC 20票，他们也有一个快照，非常相似。

18323
30:12:39.483 --> 30:12:42.954
一些主要的功能是它有这些检查点。

18324
30:12:42.954 --> 30:12:51.562
所以这些检查点基本上是，嘿，快照是什么?有很多检查点，你也可以把你的代币委托给不同的人。

18325
30:12:51.562 --> 30:12:53.688
所以你可能无法真正投票。

18326
30:12:53.688 --> 30:12:56.298
所以你说，嘿，我要把我的代币给别人。

18327
30:12:56.298 --> 30:13:06.737
你可以知道某人通过了多少票，通过了多少票，或者应用它有所有这些功能，使这个令牌成为更好的投票工具。

18328
30:13:06.737 --> 30:13:08.285
对了就好多了。

18329
30:13:08.285 --> 30:13:19.160
我们会说，我们的合约治理令牌是erc20 votes我们只需要添加额外的构造函数，这个erc20 permit，抱歉，我复制粘贴了。

18330
30:13:19.160 --> 30:13:21.123
ERC 20允许治理令牌。

18331
30:13:21.123 --> 30:13:34.737
现在我们有一个治理令牌它更有能力进行实际的投票，因为快照有这个委派功能，它有这些检查点，它会更好地以公平的方式进行投票。

18332
30:13:34.737 --> 30:13:38.785
我们唯一需要做的是，我们需要添加一些重写。

18333
30:13:38.785 --> 30:13:46.980
我们说的是固体性所要求的覆盖函数下面的函数。

18334
30:13:47.108 --> 30:13:48.970
这部分有点无聊。

18335
30:13:50.108 --> 30:13:53.780
从我的GitHub复制粘贴它。

18336
30:13:54.108 --> 30:14:04.665
我们所做的是，每当我们在token转移之后做这个，当我们转移一个token的时候，我们要确保我们调用ERC 20投票的token转移之后。

18337
30:14:04.665 --> 30:14:14.733
我们这样做的原因是因为我们想确保快照被更新了，我们想确保我们知道每个块有多少人有多少令牌。

18338
30:14:14.733 --> 30:14:16.042
薄荷也是一样。

18339
30:14:16.042 --> 30:14:23.853
燃烧也是一样，我们想要确保我们总是知道人们在不同的街区或不同的检查点有多少代币。

18340
30:14:23.853 --> 30:14:27.462
这是最重要的一点你要在哪个检查点使用代币投票。

18341
30:14:27.462 --> 30:14:27.849
太酷了。

18342
30:14:27.849 --> 30:14:34.853
你可以从GitHub上复制它，如果你想的话，你甚至可以尝试教程的其余部分，看看你的表现如何。

18343
30:14:34.853 --> 30:14:35.348
但很酷。

18344
30:14:35.348 --> 30:14:40.145
所以现在我们有了一个治理令牌和ERC 20令牌，可以用于治理。

18345
30:14:40.145 --> 30:14:41.877
让我们试着编译它。

18346
30:14:41.877 --> 30:14:43.569
纱线硬头编译。

18347
30:14:43.569 --> 30:14:47.088
很好，看起来编译成功了。

18348
30:14:47.088 --> 30:14:47.568
完美的。

18349
30:14:47.568 --> 30:14:49.822
所以我们的治理令牌看起来不错。

18350
30:14:49.822 --> 30:14:51.028
我们的盒子看起来不错。

18351
30:14:51.028 --> 30:14:55.293
现在让我们实际开始创建治理契约。

18352
30:14:55.293 --> 30:15:02.822
现在我们要创建一个名为治理标准的文件夹因为这将是标准治理模型。

18353
30:15:02.822 --> 30:15:09.653
这将是ERC 20链上的这个，我计划在未来更新这个没有治理链或其他正确的东西。

18354
30:15:09.653 --> 30:15:26.414
现在，我们称之为治理标准因为这是治理的标准方式，但在空中，我们需要两个契约，我们需要一个政府工作，契约那个灵魂然后我们还需要一个时间锁那个灵魂这马上就讲得通了。

18355
30:15:26.414 --> 30:15:40.226
我们的gov contract。soul是包含所有投票代码的合约，以及治理令牌将要使用的所有投票逻辑，时间锁实际上是一个额外的合约它实际上是所有者。

18356
30:15:40.226 --> 30:15:48.447
Time Lock和调控器契约是一样的，不同之处在于Time Lock实际上是盒子契约的所有者。

18357
30:15:48.447 --> 30:16:01.237
这一点很重要，因为每当我们提出或暗示一个提议要通过时，我们都想等待，对吧?我们希望等待执行新的投票。

18358
30:16:01.237 --> 30:16:06.730
现在，我们为什么要这么做，假设某个提案通过了，那是不好的。

18359
30:16:06.730 --> 30:16:08.582
比如说，我们有一个盒装合同。

18360
30:16:08.582 --> 30:16:22.377
然后通过了一个提议，每个持有治理代币的人都必须支付五个代币，或者类似的东西，对吧，或者别的什么，谁知道呢?也许这是你并不想参与的事情。

18361
30:16:22.377 --> 30:16:33.300
因此，如果用户不喜欢治理更新，那么所有这些治理契约都给了他们退出的时间。

18362
30:16:33.300 --> 30:16:36.659
所以我们总是需要一些时间轴。

18363
30:16:36.659 --> 30:16:43.338
因此，一旦提案通过，它不会立即生效，它必须等待一段时间，然后生效。

18364
30:16:43.338 --> 30:16:45.030
这就是时间线的作用。

18365
30:16:45.108 --> 30:16:47.866
调控器契约将包含我们所有的实际代码。

18366
30:16:48.108 --> 30:16:50.031
我们可以稍微作弊一下。

18367
30:16:50.108 --> 30:16:52.271
实际上，我们可以欺骗很多人。

18368
30:16:53.108 --> 30:16:57.866
有个叫做契约向导的东西，描述中也有链接。

18369
30:16:57.866 --> 30:17:04.832
当wizard是我们用来写基本样板代码的一种方式时，这就打开了。

18370
30:17:04.832 --> 30:17:11.646
好的，如果我们去向导合同这里，我们可以看到我们可以做ERC 20和NFT 1155。

18371
30:17:11.646 --> 30:17:14.308
最后，这里的政府。

18372
30:17:14.308 --> 30:17:18.108
我们可以给它起个名字，我们叫它Rs。

18373
30:17:18.108 --> 30:17:25.967
政府合同，解释这一切意味着什么，并给它一个投票延迟，这是从提案创建到投票开始的延迟。

18374
30:17:25.967 --> 30:17:31.023
所以一旦你创建了一个提案，你需要等待一段时间，投票期，投票应该持续多长时间。

18375
30:17:31.023 --> 30:17:37.792
这个音频很重要的原因是因为他们实际上是投票的，投票周期是以区块为单位的。

18376
30:17:37.792 --> 30:17:44.002
所以在智能合约中做基于时间的事情是一种反模式，做基于区块的事情要好得多。

18377
30:17:44.002 --> 30:17:48.921
我们说的是一周，但是这将是。如果如果平均区块时间是13。

18378
30:17:48.921 --> 30:17:55.862
2秒后，我们会算出弱提案的阈值是最小票数帐户必须创建一个提案。

18379
30:17:55.862 --> 30:18:04.996
也许你只想让拥有大量治理令牌的人投票法定人数百分比，也就是需要全部投票的人的百分比。

18380
30:18:04.996 --> 30:18:12.072
所以我们说，4%的代币持有者需要投票，或者我们可以说，刚好100个代币需要投票，不管我们想做什么。

18381
30:18:12.072 --> 30:18:17.769
我们也有一些可更新的设置我们有Bravo兼容的Bravo是复合类型契约。

18382
30:18:17.769 --> 30:18:21.233
所以如果你想让它对化合物可积分，你可以这样做。

18383
30:18:21.233 --> 30:18:36.950
或者ERC 20投票，我们正在使用这个ERC 20投票，我们总是想做一个时间锁，我们要做一个时间锁的开放式Zeplin实现，你也可以做一个复合实现，我们不打算在这里做可升级性，但是，我有很多很棒的资源关于如何真正做可升级性。

18384
30:18:36.950 --> 30:18:40.624
如果我们真的想要升级，它会添加所有其他的东西。

18385
30:18:40.624 --> 30:18:47.600
我们现在不打算这么做，因为这会使视频变得更长，然后你可以添加一些像这样的东西，但哦，差不多就是这样了。

18386
30:18:47.600 --> 30:18:56.193
我知道这听起来像是你在作弊，或者我们就直接抄一遍，对吧?复制我们放到剪贴板里的所有内容，然后粘贴进去。

18387
30:18:56.193 --> 30:18:58.759
别担心，我现在就解释这是怎么回事。

18388
30:18:58.759 --> 30:19:00.537
我们有政府合同。

18389
30:19:00.537 --> 30:19:06.797
这是州长设置州长计算简单的州长投票，州长投票，法定人数，等等。

18390
30:19:06.797 --> 30:19:15.781
所有这些都是为了让州长更容易成为州长，州长计数简单是一种计数选票的方式，州长投票是一种与当年20份合同整合的方式。

18391
30:19:15.781 --> 30:19:19.459
仲裁分数是一种理解仲裁时间锁定的方法。

18392
30:19:19.459 --> 30:19:20.759
显然，这是时间锁。

18393
30:19:20.759 --> 30:19:21.701
这是基础契约。

18394
30:19:21.701 --> 30:19:22.522
这需要一些设置。

18395
30:19:22.522 --> 30:19:24.797
我们马上会讲到这个。

18396
30:19:24.797 --> 30:19:27.367
我们来看看这里的函数是什么我们有投票延迟。

18397
30:19:27.367 --> 30:19:39.042
这就是投票延迟，我们将使用superdad voting gelei，我们将从这个州长设置契约中得到我们将在一分钟后设置你的投票周期我们将在我们的政府设置中设置，就是这个。

18398
30:19:39.042 --> 30:19:54.997
如果你想看所有这些合同，你绝对可以，如果我们去看合同，管理，扩展，我们都在这里，对吧?因此，如果我们查看治理设置，我们可以看到它有投票延迟、投票周期、提案阈值，这些都在它的构造函数中。

18399
30:19:54.997 --> 30:19:56.942
这就是我们要设置的。

18400
30:19:56.942 --> 30:20:02.996
我们会设置投票延迟投票周期，然后是提案阈值，然后我们会让这个也可以自定义。

18401
30:20:02.996 --> 30:20:07.092
剩下的就是通过超级投票来达到法定人数。

18402
30:20:07.092 --> 30:20:14.327
然后，超级是那些继承的契约，得到状态然后我们提出了一些有趣的函数。

18403
30:20:14.327 --> 30:20:23.818
这就是我们提出新治理要做的事情我们有提案阈值，然后我们有执行，执行一个线索提案。

18404
30:20:23.818 --> 30:20:33.399
为了取消，我们有executor它可以实际执行一些东西，我们将它设为任何人然后支持接口，你可以忽略。

18405
30:20:33.399 --> 30:20:35.866
但让我们让它更可定制一点。

18406
30:20:35.866 --> 30:20:43.383
我们有Iboats令牌，这是治理令牌，时间轴控制器时间轴，这是我们修改的时间轴控制器。

18407
30:20:43.383 --> 30:20:50.061
再说一次，我们需要这个，因为我们不想让任何提案一旦通过就被通过，我们想给人们时间退出。

18408
30:20:50.109 --> 30:20:56.544
但是让我们在这里添加un256投票延迟作为参数。

18409
30:20:57.109 --> 30:21:05.496
对于投票延迟，我们会这样做，我们会把它设为我们的调控器设置，我们会做一个unt256投票周期。

18410
30:21:05.496 --> 30:21:08.012
我们要把它加在这里。

18411
30:21:08.012 --> 30:21:12.305
这意味着45,000块积木大约是一周的时间。

18412
30:21:12.305 --> 30:21:19.505
这就意味着我们将把提案的门槛设置为零因为我们不想改变这一点我们想让任何人提出提案。

18413
30:21:19.505 --> 30:21:27.418
然后我们要在这里加上256下划线的核心百分比。

18414
30:21:27.418 --> 30:21:30.966
州长投票法定人数百分比的公司参议员。

18415
30:21:30.966 --> 30:21:36.728
这是完全可定制的，对于投票，延迟投票周期，核心百分比，你想要什么都行。

18416
30:21:36.728 --> 30:21:38.299
信不信由你，就是这样。

18417
30:21:38.299 --> 30:21:40.501
现在您有了一个简单的治理契约。

18418
30:21:40.501 --> 30:21:43.945
谢谢你，openzeppelin，为我们做了99%的工作。

18419
30:21:43.945 --> 30:21:44.797
就是这样。

18420
30:21:44.797 --> 30:21:52.823
这个契约，它会有所有这些我们会讲到的函数用于提议，执行和排队，不同的提议。

18421
30:21:52.823 --> 30:21:53.299
正确的。

18422
30:21:53.299 --> 30:21:56.870
现在我们得签个时间锁契约。

18423
30:21:57.109 --> 30:21:59.902
这个合同实际上会简单很多。

18424
30:22:00.109 --> 30:22:01.334
我们要从头开始。

18425
30:22:02.109 --> 30:22:15.592
许可我，然后开火，我的团队，做pragma solidity让我们这样做你的点，点零，然后我们将从打开齐柏林，导入一个叫做时间锁控制器的合同。

18426
30:22:15.592 --> 30:22:30.092
看看这里的治理，如果这个time lock controller。soul contract，这里有创建角色的所有功能，谁能提议谁能执行，谁是time lock管理员，这里也有执行的东西。

18427
30:22:30.092 --> 30:22:40.156
这将与我们的治理合同协同工作，对吧?这是一份合同，它确保我们的治理合同不会随随便便地推进事情。

18428
30:22:40.156 --> 30:22:50.816
我们会说，我们首先导入那个导入在open Zeppelin /合同/治理/时间锁控制器。

18429
30:22:50.816 --> 30:22:58.092
就这些然后我们会说合约，I'm lock is Time lock controller，像这样。

18430
30:22:58.092 --> 30:23:01.833
我们会在这里创建构造函数，和卡车门。

18431
30:23:01.833 --> 30:23:15.859
因为这需要几个不同的参数，我们会取un 256 Min delay，也就是Min delay, Min delay是在执行之前需要等待的。

18432
30:23:15.859 --> 30:23:27.859
这是，提案通过后，很好，我们要等待这个最小延迟，然后我们要做一个提案者列表，提案者的地址数组内存。

18433
30:23:27.859 --> 30:23:36.053
然后提议者是可以为我们求婚的地址列表，我们会说每个人都可以求婚。

18434
30:23:36.053 --> 30:23:48.833
最后，一个地址数组，可以执行所有操作的executor的内存，我们说的是当探测pole通过时可以执行的executor。

18435
30:23:48.833 --> 30:23:58.240
再说一次，我们会说everyone，我们需要这些的原因是因为我们需要把这些传递给时间锁控制器，这个构造函数需要三个参数。

18436
30:23:58.240 --> 30:24:04.918
所以我们只做Tama控制器，延时，pro posers, X EQ，巡演。

18437
30:24:04.918 --> 30:24:06.695
就是这样。

18438
30:24:06.695 --> 30:24:13.637
这就是拥有所有东西的时间日志，它将拥有我们的盒子。

18439
30:24:13.637 --> 30:24:18.399
不是政府合同，政府合同是我们发送选票的地方。

18440
30:24:18.399 --> 30:24:27.464
但是在这个时间锁中，为了让治理真正发生，所有事情都需要通过这个时间锁，因为我们想要确保我们有这个最小的延迟，我们通过正确的过程和所有事情。

18441
30:24:27.464 --> 30:24:29.209
信不信由你，这就是一切。

18442
30:24:29.209 --> 30:24:35.895
就稳定性而言，这就是创建治理和创建Dao所需的所有代码。

18443
30:24:35.895 --> 30:24:40.421
你可以自己进行硬帽编译，确保所有东西都编译好了。

18444
30:24:40.421 --> 30:24:43.660
太好了，我们已经做到了，你做了大部分艰苦的工作。

18445
30:24:43.660 --> 30:24:49.176
现在我们要转到实际编写脚本来部署和使用TypeScript与所有东西交互。

18446
30:24:49.176 --> 30:24:55.156
在这一点上，如果你想，哦，我已经学会了我想要的一切，我不使用安全帽，我使用一些其他工具。

18447
30:24:55.156 --> 30:24:58.573
这就是我挑战你的地方，我挑战你去尝试一些别的东西。

18448
30:24:58.573 --> 30:25:05.956
如果你已经达到了这一点，我只想给你一个大大的祝贺，因为你已经采取了步骤来建立你自己的怀疑，建立你自己的治理模型。

18449
30:25:05.956 --> 30:25:07.649
这就是你真正需要的所有的固体。

18450
30:25:07.649 --> 30:25:10.207
你可以把它部署好就可以了。

18451
30:25:10.207 --> 30:25:20.600
当然，我们知道智能合约开发者要做的不仅仅是工具的可靠性让我们继续，我们将开始编写TypeScript脚本来真正做到这一点。

18452
30:25:20.600 --> 30:25:25.601
再说一遍，如果你想看Python版的，请点击链接描述查看Python版的。

18453
30:25:25.601 --> 30:25:30.930
当然，别忘了点赞，订阅，给我们留言。

18454
30:25:30.930 --> 30:25:32.990
当然，也要鼓励一下自己。

18455
30:25:32.990 --> 30:25:33.328
伟大的工作。

18456
30:25:33.328 --> 30:25:35.632
你能走到这一步真是太棒了。

18457
30:25:35.632 --> 30:25:37.917
恭喜你，让我们开始吧。

18458
30:25:38.109 --> 30:25:45.190
好了，回到这里，我们已经写好了智能合约，检查并不容易，这比我想象的要简单得多。

18459
30:25:45.190 --> 30:25:49.329
现在我们将编写部署脚本，然后我们将编写与它们交互的脚本。

18460
30:25:49.329 --> 30:25:53.315
我的完整回购也有测试，但我们只会写一些脚本。

18461
30:25:53.315 --> 30:25:55.486
然后你可以自己查看测试。

18462
30:25:55.486 --> 30:26:02.050
让我们写这些部署脚本我们将使用一个叫做Hard Hat deploy的部署包。

18463
30:26:02.050 --> 30:26:06.458
它绝对是了不起的，让你的部署变得非常非常容易。

18464
30:26:06.458 --> 30:26:10.142
我们会向下滚动到安装，我们会继续安装这个。

18465
30:26:10.142 --> 30:26:11.990
通常，你可以这样安装它。

18466
30:26:11.990 --> 30:26:18.033
我们会用纱线，但我们会用一种更安全的方式看起来有点不靠谱，但我解释得对。

18467
30:26:18.033 --> 30:26:23.551
我们不使用NPM install，而是使用yarn，添加dash Dev，然后是这里的整个东西。

18468
30:26:23.551 --> 30:26:27.322
所以我们要做纱线，添加dash Dev，然后把它粘贴到这里。

18469
30:26:27.322 --> 30:26:33.930
这将是nomic，实验室斜杠，硬帽，连字符的醚在NPM，冒号，硬帽，部署醚。

18470
30:26:33.930 --> 30:26:40.928
它的作用是我们基本上说硬帽部署醚将覆盖这个硬醚。

18471
30:26:40.928 --> 30:26:42.560
我们还要加上醚。

18472
30:26:42.560 --> 30:26:47.886
一旦我们加入这个，检查我们的package json，我们可以看到我们有hard hats。

18473
30:26:47.886 --> 30:26:52.600
我们有硬帽醚，它被这个硬帽覆盖了，部署醚。

18474
30:26:52.600 --> 30:26:57.515
另外，我们要添加一个deploy。

18475
30:26:57.515 --> 30:27:02.246
所以做纱线，添加破折号Dev，硬帽子连字符，部署。

18476
30:27:02.246 --> 30:27:15.246
这样我们就不用写脚本了，不用做这些事情了，这样就很难保存部署了，我们只需要创建一个deploy文件夹，把所有的部署脚本都添加到这里。

18477
30:27:15.246 --> 30:27:17.004
所以我非常喜欢这个套餐。

18478
30:27:17.109 --> 30:27:19.159
这使得部署非常非常简单。

18479
30:27:20.109 --> 30:27:30.950
创建一个新文件，它会做哦，首先，我们会一步一步地部署所有东西，我们会叫它deploy，治理，或者token。TypeScript，这是我们要做的第一件事。

18480
30:27:30.950 --> 30:27:33.798
我们还会把这个改成TypeScript。

18481
30:27:33.798 --> 30:27:35.798
Tada，我们现在有TypeScript了。

18482
30:27:35.798 --> 30:27:36.073
耶。

18483
30:27:36.073 --> 30:27:45.625
做高级TypeScript的一个好处是它给了它一个开始，你不需要自己安装所有TypeScript的东西。

18484
30:27:45.625 --> 30:27:46.270
但我们有。

18485
30:27:46.270 --> 30:28:02.977
我们要做yarn，添加TypeScript类型chain vs node在type chain / ethers V 5，这是很多东西，别担心type chain / hard hat，在type / Chai，在type / node。

18486
30:28:02.977 --> 30:28:10.028
然后我们会确保这些都是戴夫，戴夫，我知道有很多东西。

18487
30:28:10.109 --> 30:28:12.066
有很多东西可以让它变成TypeScript D。

18488
30:28:12.109 --> 30:28:14.625
如果你愿意，你完全可以在JavaScript中完成。

18489
30:28:15.109 --> 30:28:17.092
不得不处理JS文件，忽略输入。

18490
30:28:18.109 --> 30:28:18.990
做你想做的事。

18491
30:28:18.990 --> 30:28:19.464
好了,很酷。

18492
30:28:20.109 --> 30:28:20.719
好吧。

18493
30:28:20.719 --> 30:28:23.295
让我们进入总督令牌。

18494
30:28:24.109 --> 30:28:25.528
创建一个部署脚本。

18495
30:28:28.109 --> 30:28:31.448
这是一些演示样板代码，用于实际执行部署脚本。

18496
30:28:31.448 --> 30:28:34.484
所以，如果你迷路或困惑，请随时参考这里。

18497
30:28:34.484 --> 30:28:43.994
我们要做的是从增强的斜杠类型，导入硬帽运行时环境。

18498
30:28:44.109 --> 30:28:45.609
你们马上就会明白为什么我们需要这个。

18499
30:28:46.109 --> 30:28:49.557
也将从Hardhead导入deploy函数。

18500
30:28:50.109 --> 30:28:50.677
削减类型。

18501
30:28:53.109 --> 30:29:03.046
用pothead deploy创建一个部署函数，我们会创建我们的函数，我们会叫它const ploy治理令牌，它的类型是deploy function。

18502
30:29:03.046 --> 30:29:07.234
为了让这些实际工作，我们只需要创建一大堆部署函数我们用heart hub运行。

18503
30:29:07.234 --> 30:29:09.091
这将是一个async函数。

18504
30:29:09.091 --> 30:29:15.633
它将把硬帽运行时环境作为输入参数，我们将称之为HRV。

18505
30:29:15.633 --> 30:29:27.172
当我们运行hardhat deploy时，你马上就会看到，我们实际上在传递假的hardhat链它会在后台为我们旋转，我们甚至可以写console。log Hello。

18506
30:29:27.172 --> 30:29:29.949
如果我们做纱线，戴上安全帽。

18507
30:29:30.109 --> 30:29:38.484
实际上，在我们这么做之前，如果我们做yarn，你会看到，因为我们导入了hard hat deploy不好意思，我们需要把这个添加到我们的配置中。

18508
30:29:38.484 --> 30:29:53.496
首先在我们的配置中，我们需要做top imports，部署top Roscoe需要import at nomic labs / hard hat ethers，我们还需要import at type chain / hard hat。

18509
30:29:53.496 --> 30:29:55.334
然后我们先把它放在这里。

18510
30:29:55.334 --> 30:29:58.673
我们马上要导入更多的东西，就像这样。

18511
30:29:58.673 --> 30:30:03.296
现在，如果我们做纱线安全帽，应该有帮助，我们应该在这里看到一个新的任务。

18512
30:30:03.296 --> 30:30:09.270
我们确实看到了很多新任务，对吧?已填满任务，检查干净编译，部署控制台。

18513
30:30:09.270 --> 30:30:18.709
这是我们的新任务它会部署所有契约，deploy文件夹下的所有契约，head会在deploy文件夹下运行。

18514
30:30:18.709 --> 30:30:21.338
我们只有这个console。log Hello。

18515
30:30:21.338 --> 30:30:25.383
如果我们运行yarn，或者点击Deploy，我们应该看到，它会打印出hello。

18516
30:30:25.383 --> 30:30:35.859
它会打开一个新的区块链后台，而我们所有的项目，会做一些类型类型链之类的东西，它说你会经常看到这个部署脚本。func不是一个函数。

18517
30:30:35.859 --> 30:30:37.696
那是因为我们现在需要导出这个。

18518
30:30:37.696 --> 30:30:42.697
我们会导出default，部署治理令牌。

18519
30:30:42.697 --> 30:30:44.854
所以它才对我们发火。

18520
30:30:44.854 --> 30:30:46.496
现在我们要让纱尔德戴上安全帽。

18521
30:30:46.496 --> 30:30:47.979
砰的一声，我们打了个招呼。

18522
30:30:47.979 --> 30:30:51.318
这就是我们部署所有脚本的方式。

18523
30:30:51.318 --> 30:30:56.828
我们可以一次性运行deploy文件夹中的所有内容，这非常有用。

18524
30:30:56.828 --> 30:30:59.625
因此，让我们先部署治理令牌。

18525
30:30:59.625 --> 30:31:01.309
随着时间的推移，速度会越来越快。

18526
30:31:01.309 --> 30:31:02.309
别担心，删掉这条吧。

18527
30:31:02.309 --> 30:31:04.859
首先我们要做的是，我们要说const。

18528
30:31:04.859 --> 30:31:06.879
我们需要一个帐户来部署它。

18529
30:31:06.879 --> 30:31:12.093
我们写入const，获取命名帐户，部署，网络等于HRA。

18530
30:31:12.093 --> 30:31:14.397
这个会更高级一些。

18531
30:31:14.397 --> 30:31:15.041
这是很难的。

18532
30:31:15.109 --> 30:31:22.832
这是我们在这里做的灵巧的事情，我们从我们的硬帽运行时环境中得到这些，它是从硬帽部署中更新的。

18533
30:31:22.832 --> 30:31:29.675
get named accounts是将账户从硬帽配置导入到部署脚本的方法。

18534
30:31:29.675 --> 30:31:31.041
我们要进入硬帽配置。

18535
30:31:31.109 --> 30:31:34.530
我们要创建一个新的配置比这个稍微好一点。

18536
30:31:34.530 --> 30:31:37.014
因此，首先，我们需要导入硬帽配置类型。

18537
30:31:37.109 --> 30:31:41.729
因为我们使用的是类型脚本，所以我们将从硬帽斜杠配置导入硬帽用户配置。

18538
30:31:41.729 --> 30:31:43.859
我们会创建一个配置。

18539
30:31:43.859 --> 30:31:45.609
我把这个注释掉。

18540
30:31:45.609 --> 30:31:48.109
现在我们用const。

18541
30:31:48.109 --> 30:31:50.419
配置，输入hard hat user Config。

18542
30:31:50.419 --> 30:31:53.530
等于，在这里我们可以加上一大堆东西。

18543
30:31:53.530 --> 30:31:59.463
假设默认网络是hard hat，也就是本地伪区块链。

18544
30:31:59.463 --> 30:32:03.836
然后我们说固体度是0，点8。

18545
30:32:03.836 --> 30:32:09.736
8，然后我们要做命名账户，这是我们一开始来这里的目的。

18546
30:32:09.736 --> 30:32:12.270
这是我们可以使用的账户列表。

18547
30:32:12.270 --> 30:32:20.855
对于账户，我们会说Deployer，这是负责所有部署的账户名，我们会说，default是0。

18548
30:32:20.855 --> 30:32:27.061
运行任意链时，带account的0将命名为Deployer。

18549
30:32:27.061 --> 30:32:30.690
我们需要做的另一件事是我们需要在这里增加我们的网络。

18550
30:32:30.690 --> 30:32:36.058
实际上我们有两个网络，我们有一个硬帽子，它的链ID是313337。

18551
30:32:36.058 --> 30:32:41.566
还有本地主机链ID是31337。

18552
30:32:41.566 --> 30:32:45.537
现在，这些看起来几乎一样。

18553
30:32:45.537 --> 30:32:48.259
我能理解，但他们不是。

18554
30:32:48.259 --> 30:32:51.575
你马上就会明白为什么，但我们现在需要它们。

18555
30:32:51.575 --> 30:32:58.281
只是想告诉Hardhead，嘿，这是我们正在合作的开发伪区块链?好的。

18556
30:32:58.281 --> 30:33:00.486
这是我们的基本设置。

18557
30:33:00.486 --> 30:33:00.731
好的。

18558
30:33:00.731 --> 30:33:02.205
我知道这有点多。

18559
30:33:02.205 --> 30:33:07.424
但现在我们有了命名帐户，我们有了网络，对吧?因为任何时候你部署一个东西，它都会在网络上。

18560
30:33:07.424 --> 30:33:16.334
当我们部署一些东西时，如果你运行yarn, hard hat node, hard hat会做什么呢，它会在后台旋转一个假的区块链。

18561
30:33:16.334 --> 30:33:17.942
它会生我的气的。

18562
30:33:17.942 --> 30:33:22.798
哦，我忘了添加导出，默认配置，对，我们需要导出配置。

18563
30:33:22.798 --> 30:33:26.367
我们用的是这种吊索。

18564
30:33:26.367 --> 30:33:36.680
如果你在一个硬帽节点上，你就会明白为什么我们要在这里添加这两个网络硬帽在localhost上，我们实际上旋转了我们自己的假区块链，我们得到了账户，我们得到了私钥，一切都是正确的。

18565
30:33:36.680 --> 30:33:44.464
这是一个在这个终端上运行的硬帽节点，对吧?奇怪的是，当你运行硬帽节点时，它实际上是本地主机网络。

18566
30:33:44.464 --> 30:33:45.989
这不是“硬帽网络”。

18567
30:33:45.989 --> 30:33:49.171
当使用硬帽部署时，它将是本地主机网络。

18568
30:33:49.171 --> 30:33:53.918
不好意思，当你使用硬帽节点时，它实际上是本地主机网络，而不是硬帽网络。

18569
30:33:53.918 --> 30:33:56.585
它在运行测试时使用的是Hard Hat网络。

18570
30:33:56.585 --> 30:34:02.770
Localhost是当你运行这个硬帽节点并在你的终端中运行这种假的区块链。

18571
30:34:02.770 --> 30:34:04.397
这就是localhost。

18572
30:34:04.397 --> 30:34:04.651
酷。

18573
30:34:04.651 --> 30:34:06.109
Ctrl C会扼杀它。

18574
30:34:06.109 --> 30:34:06.823
好了,好了。

18575
30:34:06.823 --> 30:34:08.471
现在一切都开始运转了。

18576
30:34:08.471 --> 30:34:13.849
所以让他们计算部署是一大堆来自部署的东西，你马上就会看到网络就是我们所在的网络。

18577
30:34:13.849 --> 30:34:14.571
好了,好了。

18578
30:34:14.571 --> 30:34:22.502
现在我们要获取const deploy log = deployment，这个deployment对象带有这个deploy函数。

18579
30:34:22.502 --> 30:34:26.801
这个log函数，这个log函数很适合做日志记录。

18580
30:34:26.801 --> 30:34:32.966
然后我们会抓取const, employer = await，获取命名账户。

18581
30:34:32.966 --> 30:34:42.109
我们从配置中抓取这个部署者账户?它总是带下标的0。

18582
30:34:42.109 --> 30:34:46.047
它默认是0索引，不管账户是什么。

18583
30:34:46.047 --> 30:34:46.323
太好了。

18584
30:34:46.323 --> 30:34:51.573
现在我们有了一个帐户来部署我们有了一个部署功能，我们有了所有这些东西，我们看起来很好。

18585
30:34:51.573 --> 30:34:51.840
酷。

18586
30:34:51.840 --> 30:35:08.928
有时他们会写一个log，飞行治理令牌，点，我们会说const治理令牌= await, deploy，然后是契约的名称也就是治理令牌，逗号，这些都是我们要传递给它的参数。

18587
30:35:08.928 --> 30:35:13.681
我们会说from deployer不接受任何参数。

18588
30:35:13.681 --> 30:35:15.839
args就是空的。

18589
30:35:15.839 --> 30:35:19.864
我们要让log为真所以我们要打印一些对数。

18590
30:35:19.864 --> 30:35:24.669
然后我在GitHub repo中设置了这个等待确认属性。

18591
30:35:24.669 --> 30:35:26.448
现在我们先忽略它。

18592
30:35:26.448 --> 30:35:30.834
但如果你跟着我的回购，你想要自动验证，这是你会想要使用的东西。

18593
30:35:30.834 --> 30:35:38.062
所以你需要等待一些block来部署这个契约然后你才能进行验证。

18594
30:35:38.110 --> 30:35:43.332
因为如果你用的是以太扫描之类的，你需要等一下，是的，你需要等几分钟。

18595
30:35:43.332 --> 30:35:47.110
所以请查看我的GitHub回购，看看这个等待确认的东西，我现在将忽略它。

18596
30:35:47.110 --> 30:35:52.585
此外，在我的GitHub回购中，我有这个验证功能，我们检查它是否在开发链上。

18597
30:35:52.585 --> 30:35:54.176
即使是，我们也不会去核实。

18598
30:35:54.176 --> 30:35:56.771
但如果是以太扫描之类的，我们就会去验证。

18599
30:35:56.771 --> 30:36:01.594
所以一定要查看GitHub回购，学习如何不做任何事情就自动验证。

18600
30:36:01.594 --> 30:36:03.526
如果我们只做这部分。

18601
30:36:03.526 --> 30:36:13.974
然后我们甚至可以用Floyd，治理令牌来处理治理令牌。address。

18602
30:36:13.974 --> 30:36:17.710
我们会做纱硬帽。

18603
30:36:17.710 --> 30:36:18.643
部署。

18604
30:36:18.643 --> 30:36:19.309
繁荣。

18605
30:36:19.309 --> 30:36:26.641
所以我们在一个假的硬帽网络上旋转，我们部署治理令牌来解决繁荣。

18606
30:36:26.641 --> 30:36:30.937
这就是我们部署的方法一个冒牌的已经在我们的小网络上部署了这个。

18607
30:36:30.937 --> 30:36:31.350
太好了。

18608
30:36:31.350 --> 30:36:34.932
这个令牌被部署，我们有部署脚本。

18609
30:36:34.932 --> 30:36:36.286
是的，缩小一点。

18610
30:36:36.286 --> 30:36:37.490
让我们缩小一点。

18611
30:36:37.490 --> 30:36:37.680
太好了。

18612
30:36:37.680 --> 30:36:38.410
这就是全部。

18613
30:36:38.410 --> 30:36:41.919
现在我们还要添加一个东西，我们要添加一个叫做委托函数的东西。

18614
30:36:41.919 --> 30:36:45.416
现在，当你真正执行这份合同时，还没有人有投票权。

18615
30:36:45.416 --> 30:36:51.531
原因是，因为没有人将令牌委托给他们，所以我们希望将这个令牌委托给我们的部署者。

18616
30:36:51.531 --> 30:36:53.538
我们会调用这个委托函数。

18617
30:36:53.538 --> 30:36:56.519
我们要创建一个名为const的新函数。

18618
30:36:56.519 --> 30:36:57.256
委托。

18619
30:36:57.256 --> 30:37:00.452
这将是一个async函数。

18620
30:37:00.452 --> 30:37:18.538
它会将治理令牌地址作为字符串，它会将委托帐户作为字符串，所以我们会争分夺秒，我们想要谁?委托吗?我们希望谁能够用我们的代币投票?我们已经创建了这个叫delegate的async函数。

18621
30:37:18.538 --> 30:37:32.860
我们要怎么做呢?我们说康德在它的令牌等于令牌等于等待醚点得到契约。

18622
30:37:33.110 --> 30:37:36.811
也许是精明的奥托为我们做了两个乙醚，这很好。

18623
30:37:36.811 --> 30:37:37.512
这就是我们想要的。

18624
30:37:37.512 --> 30:37:38.571
就像醚一样。

18625
30:37:38.571 --> 30:37:39.571
谢谢vs。

18626
30:37:39.571 --> 30:37:40.340
代码了。

18627
30:37:40.340 --> 30:37:42.493
以太就像一个合约。

18628
30:37:42.493 --> 30:37:50.041
我们想要我们的治理令牌，也就是契约，治理令牌地址。

18629
30:37:50.041 --> 30:37:54.899
我有自动格式未保存，这就是为什么它一直这样格式化。

18630
30:37:54.899 --> 30:37:56.667
这应该委托记账。

18631
30:37:56.667 --> 30:37:57.301
好的,很酷。

18632
30:37:57.301 --> 30:38:00.033
我们有治理令牌契约。

18633
30:38:00.033 --> 30:38:09.360
现在我们可以使用const TX或transaction = await, governance token。delegate委派这个委派的帐户。

18634
30:38:09.360 --> 30:38:16.028
然后我们可以做一个等待，我们会等待这个事务被一个block确认。

18635
30:38:16.110 --> 30:38:35.855
然后我们会写console。log检查点，等等，治理令牌。num检查点委派帐户?这是在做什么呢?我们有这个num检查点函数我们可以去检查ERC 20令牌上它到底在做什么。

18636
30:38:35.855 --> 30:38:40.206
但基本上这整个东西做的是，我们有这个委托函数，我们还没用过它。

18637
30:38:40.206 --> 30:38:44.710
但当有人打电话给我们时，我们会说，嘿，你可以用我的票，拿我的票，你想怎么投就怎么投。

18638
30:38:44.710 --> 30:38:46.536
这就是这个委托的作用。

18639
30:38:46.536 --> 30:39:03.998
现在，如果我们看这个令牌，这里有20个扩展，你看到20个投票，我们看数量检查点，我们可以看到这个账户有多少个检查点这很重要，因为就像我说的，当人们投票时，他们会基于一些检查点。

18640
30:39:03.998 --> 30:39:16.760
当你转移一个令牌，或委派一个令牌时，基本上调用这个函数move投票权，这发生在后端，它写检查点，说，嘿，在检查点x，这是每个人的投票权。

18641
30:39:16.760 --> 30:39:18.710
这就是为什么这些很重要。

18642
30:39:18.710 --> 30:39:28.601
我知道我之前说过，是每个街区，但实际上是每个检查点，每当这些检查点更新时，这将比我们只更新每个街区要便宜得多，对吧?那太疯狂了。

18643
30:39:28.601 --> 30:39:34.125
这个治理检查点的检查点，我们马上就会看到它到底是什么。

18644
30:39:34.125 --> 30:39:40.667
我们甚至会做等待，委托，治理令牌。address和Deployer。

18645
30:39:40.667 --> 30:39:43.880
我们说log委派。

18646
30:39:44.110 --> 30:39:47.531
现在，当我们使用这个函数时，约翰·霍华德点击了部署。

18647
30:39:47.531 --> 30:39:54.703
我们有一个检查点，这说得通，对吧?因为这只是部署，只是委派。

18648
30:39:54.703 --> 30:39:56.528
这个地址有一个检查点。

18649
30:39:56.528 --> 30:39:57.073
就是这样。

18650
30:39:57.073 --> 30:40:02.077
我检查这个的原因是如果你在这里看到零检查点，这意味着你没有正确地委派。

18651
30:40:02.077 --> 30:40:03.824
所以一定要检查检查点。

18652
30:40:03.824 --> 30:40:04.490
但仅此而已。

18653
30:40:04.490 --> 30:40:07.420
我们已经完成了部署的治理令牌契约。

18654
30:40:07.420 --> 30:40:07.833
布拉沃。

18655
30:40:07.833 --> 30:40:09.901
让我们继续下一个。

18656
30:40:10.110 --> 30:40:15.860
那么，在部署治理令牌之后，我们想做什么呢?好吧，让我们使用那个时间锁或时间锁。

18657
30:40:15.860 --> 30:40:15.985
ts。

18658
30:40:15.985 --> 30:40:23.306
我们要从这里复制很多东西，所以我实际上要哦，有时你会在这里得到一些奇怪的linting错误。

18659
30:40:23.306 --> 30:40:24.781
我只需要忽略TS。

18660
30:40:24.781 --> 30:40:26.660
有时你在这里也会得到。

18661
30:40:26.660 --> 30:40:28.710
事实上，我们甚至不需要网络。

18662
30:40:28.710 --> 30:40:29.300
好的,很酷。

18663
30:40:29.300 --> 30:40:31.204
是的，你甚至不需要网络环路。

18664
30:40:31.204 --> 30:40:33.425
有时我们会得到一些奇怪的毛线错误。

18665
30:40:33.425 --> 30:40:38.516
有时候Vyas代码很难理解，比如我们做的覆盖。

18666
30:40:38.516 --> 30:40:46.943
所以只要运行那个TS ignore if如果它给你一些，一些工程师，不管怎样，我们有这个哦，要部署时间锁，我们要部署时间锁合同。

18667
30:40:46.943 --> 30:40:54.110
我们要从这里借用很多东西，所以我要回到这里实际上是复制粘贴上面的这两位。

18668
30:40:54.110 --> 30:41:07.494
同样，我们要做的是const deploytimelock将是一个部署函数，它将是一个async函数在运行时环境中取心脏作为参数，很酷，几乎完全一样抱歉。

18669
30:41:07.494 --> 30:41:14.868
然后我们将得到前三行，或者前四行，比索，然后我们将得到这里完全相同的东西。

18670
30:41:14.868 --> 30:41:17.804
我们将要做几乎完全相同的事情。

18671
30:41:17.804 --> 30:41:20.007
我们将进行日志部署。

18672
30:41:20.007 --> 30:41:24.730
时间锁，点时间锁，会做const。

18673
30:41:24.730 --> 30:41:28.456
标记等于等待，部署，解锁。

18674
30:41:28.456 --> 30:41:32.360
我们在这里添加一些参数，我们说from Deployer。

18675
30:41:32.360 --> 30:41:36.860
这需要一些论证吗?确实如此。

18676
30:41:36.860 --> 30:41:41.600
好的，我们可以看看时间锁，最小延迟提议者和执行者。

18677
30:41:41.600 --> 30:41:46.980
我们希望最小延时是多少?这个值我们会经常用到。

18678
30:41:46.980 --> 30:41:51.479
我通常会创建一个名为helper的新文件。

18679
30:41:51.479 --> 30:41:53.202
安全帽配置。

18680
30:41:53.202 --> 30:41:53.417
ts。

18681
30:41:53.417 --> 30:41:58.265
在顶部，我写上Export const min。

18682
30:41:58.265 --> 30:42:02.375
延迟，我可以让这个延迟变成我想要的样子。

18683
30:42:02.375 --> 30:42:09.057
所以我们继续做3600，大概是一个小时，对吧，你要等这么多秒，我想是一个小时。

18684
30:42:09.110 --> 30:42:10.581
不用老的计算器。

18685
30:42:12.110 --> 30:42:12.569
分钟。

18686
30:42:12.569 --> 30:42:12.962
太好了。

18687
30:42:12.962 --> 30:42:14.601
要一个小时。

18688
30:42:16.110 --> 30:42:17.717
我们要把它导入这里。

18689
30:42:18.110 --> 30:42:19.713
导入，最小延时。

18690
30:42:23.110 --> 30:42:27.395
从helper，你知道，它是下目录，helper Hardhead config。

18691
30:42:27.395 --> 30:42:29.490
这是我们的第一个论点。

18692
30:42:29.490 --> 30:42:31.475
我们的第二个论点是一系列的建议。

18693
30:42:31.475 --> 30:42:33.125
现在我们先把它空着。

18694
30:42:33.125 --> 30:42:38.485
还有执行人列表我们暂时把它留空，我们一会儿会更新这个。

18695
30:42:38.485 --> 30:42:41.985
你就会明白为什么我们到这里，我们用log true。

18696
30:42:42.110 --> 30:42:46.310
这在我的GitHub中也有一个等待确认的东西，但我们现在先跳过这个。

18697
30:42:46.310 --> 30:42:49.421
它还有一个自动验证，我们先跳过这个。

18698
30:42:49.421 --> 30:42:53.205
然后我们只需要导出default，部署timelock。

18699
30:42:53.205 --> 30:42:55.376
砰，我们应该没问题。

18700
30:42:55.376 --> 30:42:58.509
让我们试着在安全帽部署时运行这个。

18701
30:42:58.509 --> 30:43:04.054
现在它应该运行这两个伟大的部署治理令牌部署时间锁。

18702
30:43:04.110 --> 30:43:08.946
很好，我们现在正在浏览我们想要部署治理契约的内容。

18703
30:43:08.946 --> 30:43:10.036
我们来做一下。

18704
30:43:10.110 --> 30:43:13.906
我们要做哦，三个LOI。

18705
30:43:13.906 --> 30:43:16.346
政府，也不是合同。

18706
30:43:16.346 --> 30:43:16.617
ts。

18707
30:43:18.110 --> 30:43:21.546
猜猜看，这和我们刚才做的很像。

18708
30:43:21.546 --> 30:43:21.873
正确的。

18709
30:43:21.873 --> 30:43:26.143
在部署时间锁中，我们抓取上面两个东西。

18710
30:43:26.143 --> 30:43:27.538
我们把它粘贴在这里。

18711
30:43:27.538 --> 30:43:41.041
我们会使用const deploy, governance或contract，这里会有一个apply函数，它是一个async函数，在运行时环境中取一部分，保存并关闭它。

18712
30:43:41.041 --> 30:43:48.633
我们甚至可以返回，抓取这三行。哦，要部署时间锁，把它粘贴到这里，因为我们需要得到完全相同的东西。

18713
30:43:48.633 --> 30:43:54.297
此外，为此，我们需要获得治理令牌和Time Lock契约。

18714
30:43:54.297 --> 30:43:58.710
我们用const治理，token = await。

18715
30:43:58.710 --> 30:44:06.843
Get实际上，我们有这个，这个Get函数来自于这些部署，它实际上只是出去获取这些部署。

18716
30:44:06.843 --> 30:44:09.176
我们说get Gover Nance token。

18717
30:44:09.176 --> 30:44:13.610
然后我们还要拿到时间锁。

18718
30:44:13.610 --> 30:44:16.060
等待，获取m锁。

18719
30:44:16.060 --> 30:44:22.025
我们需要将这些作为调控器契约的参数传递。

18720
30:44:22.110 --> 30:44:34.062
对吧?因为如果我们打开该灵魂的管理器契约，我们查看构造函数，它将令牌、Time Lock投票、延迟投票周期和仲裁百分比作为输入参数。

18721
30:44:34.062 --> 30:44:38.919
所以我们会做一个快速的日志部署go burn或ello。

18722
30:44:39.110 --> 30:44:50.837
他们会写const govern nor contract = await, deploy，并将部署治理或契约我不确定我是否总是拼写正确，但这没关系。

18723
30:44:50.837 --> 30:44:52.899
我们再做一次参数。

18724
30:44:52.899 --> 30:44:54.643
它将来自Deployer。

18725
30:44:54.643 --> 30:44:57.243
参数将是这个参数列表。

18726
30:44:57.243 --> 30:45:02.802
它首先需要的是什么?它首先需要令牌和时间锁。

18727
30:45:02.802 --> 30:45:08.610
我们会写governance token。address，然后它需要Time Lock那个地址。

18728
30:45:08.610 --> 30:45:13.765
我们需要就投票延迟投票时间和法定人数百分比进行投票。

18729
30:45:13.765 --> 30:45:17.355
这些也是我们会经常用到的值。

18730
30:45:17.355 --> 30:45:21.903
让我们打开助手Hardhead配置，让我们也创建这些。

18731
30:45:21.903 --> 30:45:24.962
因此我们写入Export const just voting period。

18732
30:45:24.962 --> 30:45:34.946
我们会说这将是五个block，我们会做export const voting delay，这将是一个block，我知道这非常快。

18733
30:45:34.946 --> 30:45:45.938
然后我们需要export const Orem percentage，也就是4%的选民总是需要投票。

18734
30:45:45.938 --> 30:45:50.047
不好意思，需要4%的选民投赞成票才能通过。

18735
30:45:50.047 --> 30:45:50.422
太好了。

18736
30:45:50.422 --> 30:45:54.860
我们要做投票延迟投票百分比法定人数百分比。

18737
30:45:54.860 --> 30:46:07.287
所以我们会导入这些来导入投票延迟投票周期，或从助手Hardhead配置的法定人数百分比。

18738
30:46:07.287 --> 30:46:17.872
现在我们有了这些延迟周期百分比，我们可以做投票延迟，投票周期，农场百分比，然后我们说log为真。

18739
30:46:17.872 --> 30:46:19.499
同样，这个也是。

18740
30:46:19.499 --> 30:46:24.028
它有一个等待确认和自动验证我们会完全忽略它。

18741
30:46:24.028 --> 30:46:27.523
然后导出违约，血腥总督合同。

18742
30:46:27.523 --> 30:46:29.178
凯莉，我们开始辣了。

18743
30:46:29.178 --> 30:46:30.899
我们来确认一下。

18744
30:46:30.899 --> 30:46:31.951
纱线硬帽部署。

18745
30:46:31.951 --> 30:46:34.618
我们应该看到这里部署了三个契约。

18746
30:46:34.618 --> 30:46:40.056
我认为要编译治理，令牌部署时间锁部署治理契约部署。

18747
30:46:40.110 --> 30:46:40.776
我们走吧。

18748
30:46:40.776 --> 30:46:41.442
好吧。

18749
30:46:41.442 --> 30:46:43.442
现在，我们还没有做完。

18750
30:46:45.110 --> 30:46:45.755
部署脚本。

18751
30:46:47.110 --> 30:46:48.360
管理合同。

18752
30:46:48.360 --> 30:46:48.672
好的。

18753
30:46:48.672 --> 30:46:50.672
这一点非常重要。

18754
30:46:51.110 --> 30:46:55.720
现在我们的时间锁定合同没有申请人也没有执行人。

18755
30:46:55.720 --> 30:46:56.126
正确的。

18756
30:46:56.126 --> 30:47:07.364
所以我们想要改变我们想要只允许提议者成为管理者，管理者合同应该是唯一提出事情的人时间锁，然后任何人都应该能够执行它的工作方式。

18757
30:47:07.364 --> 30:47:13.479
我们说，治理契约一旦进入时间锁，就会向时间锁提出一些建议，并在这段时间内等待。

18758
30:47:13.479 --> 30:47:15.694
任何人都可以去执行它。

18759
30:47:15.694 --> 30:47:18.610
所以州长让每个人都投票。

18760
30:47:18.610 --> 30:47:23.847
一旦投票通过，州长说，时间锁，你能提出这个吗?汤姆说，当然可以。

18761
30:47:23.847 --> 30:47:28.610
但我们需要等待，这个最小延迟，一旦它被延迟，任何人都可以执行它。

18762
30:47:28.610 --> 30:47:34.177
这将是一个很酷的集成，顺便说一下，这将是一个很酷的集成，为了让链链保持器自动执行。

18763
30:47:34.177 --> 30:47:36.007
反正我也要造下一个。

18764
30:47:36.110 --> 30:47:44.566
我们需要设置它，让它这样工作，我们会创建一个新的deploy叫做，哦，第四，setup，治理契约。TypeScript。

18765
30:47:44.566 --> 30:47:48.143
这段代码将完成所有的设置。

18766
30:47:48.143 --> 30:47:51.663
这看起来和其他的deploy函数非常相似。

18767
30:47:51.663 --> 30:48:11.432
我们会从3往回走，我们会把上面的两个粘贴到这里，当然，我们会做const setup契约，它会是一个部署函数，还是一个async函数，它会把HRV art at runtime environment作为参数，然后这就是赢家。

18768
30:48:11.432 --> 30:48:11.754
酷。

18769
30:48:11.754 --> 30:48:20.432
我们会从上面抓取同样的三个，你可以看到，这变得更容易了，因为它有点重复，对，我们会抓取这里的那一点。

18770
30:48:20.432 --> 30:48:23.125
现在我们要拿到这些合同这样我们就可以和他们互动了。

18771
30:48:23.125 --> 30:48:37.179
这也是为什么硬帽部署如此好用的另一个原因，因为我们可以用const timelock = await ethers进入下一个我们继续从硬帽导入导入醚。

18772
30:48:37.179 --> 30:48:43.296
从红帽的醚甚至会下降一点TS忽略这里。

18773
30:48:43.296 --> 30:48:46.519
没有合同，我们要那个时间锁定合同。

18774
30:48:46.519 --> 30:48:48.940
我们说我们想把它附加到部署器。

18775
30:48:48.940 --> 30:49:02.144
无论何时我们在上面调用函数，都是部署者调用那个函数我们要做const总督= await ethers。get总督，这都将附加到部署者。

18776
30:49:02.144 --> 30:49:02.557
正确的。

18777
30:49:02.557 --> 30:49:05.432
现在，我们要做log设置角色。

18778
30:49:05.432 --> 30:49:16.710
我们要设置好角色，再一次，我们要设置好只有调控器才能向这个时间锁发送东西，因为时间锁将是你几乎可以把时间锁想象成总统。

18779
30:49:16.710 --> 30:49:16.928
正确的。

18780
30:49:16.928 --> 30:49:23.060
所以所有的事情都交给参议院，众议院代表，也就是州长，然后总统说，是的，当然。

18781
30:49:23.110 --> 30:49:36.363
我们只需要等待这个最小延迟，但总统将是真正执行所有事情的那个我不确定它在政治中是如何工作的，但现在，这是我们保护总统的地方或者说时间like是唯一可以做任何事情的。

18782
30:49:36.363 --> 30:49:48.348
这个工作的方式是我们实际上会得到不同角色的字节码，对吧?如果你看这里的时间锁，我们会在合同上做一些。

18783
30:49:48.348 --> 30:49:50.749
我们来看看治理。

18784
30:49:50.749 --> 30:49:57.300
Tama控制器有这些东西叫做提案滚动，执行者滚动时间，比如管理等。

18785
30:49:57.300 --> 30:50:00.347
这些就是这些字符串的散列。

18786
30:50:00.347 --> 30:50:08.381
但是这些是这些字节32说，嘿，任何有这个字节32的人是提议者，任何有这个字节32的人是执行者。

18787
30:50:08.381 --> 30:50:10.837
任何人都有这个字节，比如admin等等。

18788
30:50:10.837 --> 30:50:15.410
现在，我们的部署者帐户是管理员，这很糟糕。

18789
30:50:15.410 --> 30:50:22.077
我们不希望那样我们不希望任何人做时间管理员，对吧?我们不希望任何人拥有这个时间锁的权力。

18790
30:50:22.077 --> 30:50:24.437
我们不希望这里有任何集中力量。

18791
30:50:24.437 --> 30:50:28.077
我们要做的是我们要const我们要获取那些角色。

18792
30:50:28.077 --> 30:50:34.432
提议者，提议者角色，这将是一个权重，解锁那个行极，Sir角色。

18793
30:50:34.432 --> 30:50:49.626
如果你熟悉多呼叫，这将是一个很好的时间来做多呼叫复制粘贴整个线路xeq tour角色在xeq tour roll，我们将复制整个线路管理角色。

18794
30:50:49.626 --> 30:50:52.730
这将是onlockadmin角色。

18795
30:50:52.730 --> 30:50:58.376
这就是我们需要修正的三个角色，让我们继续修正它们。

18796
30:50:58.376 --> 30:51:09.834
首先我们需要做的是const row poser dx = await Time Lock。grant roll，向我们的总督。address发起滚动。

18797
30:51:09.834 --> 30:51:16.547
所以说，好吧，州长，你是唯一一个可以做任何事的人只要你让时间锁做某事。

18798
30:51:16.547 --> 30:51:18.860
我们会等待时间锁定期结束。

18799
30:51:18.860 --> 30:51:20.010
然后我们就做完了。

18800
30:51:20.110 --> 30:51:25.077
然后我们会做一个await posittx。wait一个block来确保。

18801
30:51:25.077 --> 30:51:52.011
现在我们要做const executor, TX = await Time Lock。grant roll executor role给任何人，我们要执行这个我们不把这个给任何人，我们要写address 0这是我们要添加的东西如果我们去helper或者head config会说Export const address 0 = 0你可以复制粘贴这个。

18802
30:51:52.011 --> 30:51:54.541
对醚也有几种其他的方法。

18803
30:51:54.541 --> 30:51:55.925
我们就这样做。

18804
30:51:55.925 --> 30:52:04.772
我喜欢有这样的冲突然后我们直接导入输入import at 0 from。

18805
30:52:04.772 --> 30:52:08.691
所以我们不把执行者的角色交给任何人，也就是所有人。

18806
30:52:08.691 --> 30:52:13.044
一旦提案通过，任何人都可以执行。

18807
30:52:13.044 --> 30:52:16.694
我们说executor, TX那个等一个等一个块。

18808
30:52:16.694 --> 30:52:25.990
这里还有一件事要做，我们现在需要撤销角色我们的部署者计数拥有那个时间锁控制器。

18809
30:52:25.990 --> 30:52:33.852
这就是我们做这些事务的方式，我们可以授予角色因为我们的部署者账户拥有它现在我们给了每个人访问权限。

18810
30:52:33.852 --> 30:52:38.296
考虑到我们所需要的去中心化访问，我们想撤销这个角色。

18811
30:52:38.296 --> 30:52:40.666
const revoke TX = await。

18812
30:52:40.666 --> 30:53:01.559
我锁定了撤销角色，来自部署者的管理角色会做Rotex等待，现在猜猜，任何想做的事都要经过治理，没有人拥有时间I控制器，目前在运行后，任何人都不可能在没有治理发生的情况下用时间锁做任何事。

18813
30:53:01.559 --> 30:53:05.562
当然，当输出违约合约集时，很好。

18814
30:53:05.562 --> 30:53:15.061
最后一步，我们需要部署我们想要管理的契约写方框契约，真正的基本契约。

18815
30:53:15.061 --> 30:53:17.307
所以我们要创建一个新的105，部署框。

18816
30:53:17.307 --> 30:53:17.438
ts。

18817
30:53:17.438 --> 30:53:38.731
我们会做一些和之前做的完全一样的事情，我们会抓取这两行，这里的这两行，粘贴进去，os deploy box会是一个deployfunction = async function，抱歉，是hard hat runtime environment，我们会抓取前三行，TS ignore，就像这样。

18818
30:53:38.731 --> 30:53:41.420
现在我们要展开这个盒子。

18819
30:53:41.420 --> 30:53:52.011
log，部署bucks，我们会写const box = await，部署框，从部署器中给我们一些值。

18820
30:53:52.011 --> 30:53:56.643
这个有任何args所以打开一个box。soul，我没有看到一个构造函数。

18821
30:53:56.643 --> 30:54:04.197
虽然这是所有这些契约中最简单的，没有构造函数，然后我们说log，它是真的。

18822
30:54:04.197 --> 30:54:10.711
如果你想查看我的GitHub回购来获取确认，请随时点击这里。

18823
30:54:10.711 --> 30:54:15.385
现在，我们的部署者实际上部署了这个，而不是我们的时间锁。

18824
30:54:15.385 --> 30:54:20.476
因此，我们希望将这些盒子的所有权交给我们的治理过程。

18825
30:54:20.476 --> 30:54:26.216
现在我们要做的是const timelock，它将是一个weight ethers。get contract。

18826
30:54:26.216 --> 30:54:27.970
和之前一样。

18827
30:54:28.111 --> 30:54:28.825
timelock。

18828
30:54:33.111 --> 30:54:34.750
乙醚从安全帽。

18829
30:54:38.111 --> 30:54:39.396
这是过分挑剔。

18830
30:54:42.111 --> 30:54:48.274
盒子对这个时间锁的所有权，这就是所谓的盒子部署。

18831
30:54:48.274 --> 30:54:50.456
在此之前，我们必须得到盒子合约。

18832
30:54:50.456 --> 30:55:07.998
这是一个盒状部署对象，它没有契约函数我们想要得到这个盒状契约对象因此我们输入box或const box contract = await ethers。get contract at box然后我们就把那个地址框起来。

18833
30:55:07.998 --> 30:55:09.511
你也可以得到合同。

18834
30:55:09.511 --> 30:55:14.161
实际上这两个都很如果你有地址，你可以把地址框起来。

18835
30:55:14.161 --> 30:55:15.677
你也可以在这里签合同。

18836
30:55:15.677 --> 30:55:44.111
现在我们有了盒子契约，我们做const transfer owner, dx等于await by contract。transfer TX或者schema。transfer所有权给我们的timelock。address time walk。address，然后我们做一个权转移所有权TX。weight 1，做一个log，完成了。

18837
30:55:44.111 --> 30:55:47.682
这些是export default。

18838
30:55:47.682 --> 30:55:49.253
部署的盒子。

18839
30:55:49.253 --> 30:55:52.504
哦，让我们看看这是否有效。

18840
30:55:52.504 --> 30:55:54.635
所以我们做了所有的事情。

18841
30:55:54.635 --> 30:56:05.795
我们部署了GOV令牌，部署了时间锁，它拥有治理过程，我们部署了治理过程，我们设置了治理过程，使其完全去中心化。

18842
30:56:05.795 --> 30:56:13.023
然后我们部署并设置了我们的盒子，以便它只能通过治理流程进行更新。

18843
30:56:13.111 --> 30:56:14.832
让我们看看它是否有效。

18844
30:56:14.832 --> 30:56:16.635
纱线，戴上安全帽。

18845
30:56:18.111 --> 30:56:18.549
的工作原理。

18846
30:56:18.549 --> 30:56:20.829
嘣，你成功了。

18847
30:56:23.111 --> 30:56:28.401
脚本来设置整个治理过程，这样您就可以建立自己的怀疑。

18848
30:56:28.401 --> 30:56:36.687
你还在吗?嗯，是的，你是，恭喜你走了这么远，我们还有一个作品要做，我们只需要写那些脚本。

18849
30:56:36.687 --> 30:56:42.304
我们可以与它交互，我们可以进行治理，我们可以确切地看到治理过程是什么样子的。

18850
30:56:42.304 --> 30:56:48.788
现在，如果你没有看过我上一个关于道斯的视频，一定要看那个视频，因为那会给你这部分的所有背景知识。

18851
30:56:48.788 --> 30:56:56.917
如果你仍然百分之百地观看，点击点赞按钮，点击订阅，在下方评论区留言，这对我们的频道很有帮助。

18852
30:56:56.917 --> 30:56:58.192
真为你骄傲，能走这么远。

18853
30:56:58.192 --> 30:57:00.479
就快完成了，还剩一个了。

18854
30:57:00.479 --> 30:57:03.838
然后你就可以自由地制造你的怀疑了。

18855
30:57:03.838 --> 30:57:05.928
我们继续吧。

18856
30:57:06.111 --> 30:57:13.261
好了，现在我们要做一些脚本来与提议Q交互，并对Dao中发生的任何事情进行投票。

18857
30:57:13.261 --> 30:57:19.356
这些是脚本，这些是你在构建这个的时候会做的事情当你在构建你的怀疑的时候。

18858
30:57:19.356 --> 30:57:23.059
你也可以用快照或计数做积分。

18859
30:57:23.111 --> 30:57:27.817
如果你想在GitHub上看到完整的功能，我有这个测试流程。

18860
30:57:27.817 --> 30:57:29.416
这不是这里最大的考验。

18861
30:57:29.416 --> 30:57:35.721
但你也可以看看这个，因为它也做了一个从汤到坚果的演示，通过这个确切的过程。

18862
30:57:35.721 --> 30:57:37.444
让我们继续，开始制作一些脚本。

18863
30:57:37.444 --> 30:57:39.824
我们要创建一个名为scripts的新文件夹。

18864
30:57:39.824 --> 30:57:42.661
这是我们要放所有脚本的地方。

18865
30:57:42.661 --> 30:57:56.603
这个过程是我们首先要提出一些建议，对吧?你知道，也许我们会建议我们的盒子契约存储的值是77，对吧?因为当它第一次被初始化时，它会从0开始。

18866
30:57:56.603 --> 30:57:59.852
也许我们会提议从77岁开始。

18867
30:57:59.852 --> 30:58:02.644
求婚一旦完成，我们就会进行投票。

18868
30:58:02.644 --> 30:58:07.976
一旦提案提出，我们就会投票决定我们是否希望提案通过，是还是否。

18869
30:58:07.976 --> 30:58:13.388
如果它通过，我们会先排队执行。

18870
30:58:13.388 --> 30:58:17.904
然后我们执行，我把它们放在同一个脚本里，这样更简单。

18871
30:58:17.904 --> 30:58:22.303
我们从求婚开始，因为这是我们要做的第一件事。

18872
30:58:22.303 --> 30:58:23.703
我们来创建一个新函数。

18873
30:58:23.703 --> 30:58:29.843
我们称它为async function，然后我们将它导出为export async function proposal。

18874
30:58:29.843 --> 30:58:31.559
我们要在这里待一会儿。

18875
30:58:31.559 --> 30:58:32.777
我们把所有东西都清空。

18876
30:58:32.777 --> 30:58:33.491
好的，很酷。

18877
30:58:33.491 --> 30:58:39.370
这就是我们要在州长合同上提出的建议，对吧?所以我们要提出一份新的州长合同。

18878
30:58:39.370 --> 30:58:41.848
所以我们首先需要的，当然是州长。

18879
30:58:41.848 --> 30:58:55.146
所以你不能统治或等于等待他人得到契约，统治或契约，对吧?因为我们在做醚，我们需要从心脏app导入醚。

18880
30:58:55.146 --> 30:58:59.046
然后我们仍然得到基本的东西。

18881
30:58:59.046 --> 30:59:01.253
我们会在这里做一个AT, t，忽略。

18882
30:59:01.253 --> 30:59:01.431
酷。

18883
30:59:01.431 --> 30:59:09.258
这里有总督契约，我们还需要盒子契约，我们要提议盒子契约改变存储值。

18884
30:59:09.258 --> 30:59:18.321
我们写入const box = await ethers。get这是一个礼物契约，我们想要get contract, get contractat。

18885
30:59:18.321 --> 30:59:22.058
这是我们开始时需要的两个主要的。

18886
30:59:22.111 --> 30:59:29.061
现在，如果我们看看提议的功能，如果我们去治理，我们去总督，我们看看提议的功能。

18887
30:59:29.111 --> 30:59:30.007
这就是它的样子。

18888
30:59:31.111 --> 30:59:32.282
函数在上个视频中。

18889
30:59:34.111 --> 30:59:42.498
回去看一下因为它会给你所有你需要知道的东西基本上我们选择一个目标列表，我们的列表就是我们的盒子合同。

18890
30:59:42.498 --> 30:59:51.820
这些是我们想要调用函数的目标，我们做一些值，比如我们想要发送多少以太，我们不会发送任何东西，我们有字节，一个叫做data的数组。

18891
30:59:51.820 --> 30:59:57.911
这就是我们要调用的函数的编码参数然后是描述。

18892
30:59:57.911 --> 31:00:00.079
这就是我们要做的。

18893
31:00:00.079 --> 31:00:02.175
首先，我们要弄清楚我们要做什么。

18894
31:00:02.175 --> 31:00:05.548
看看Box，我们将用这个新值调用这个store函数。

18895
31:00:05.548 --> 31:00:08.798
所以我们需要编码我们需要编码这只袜子。

18896
31:00:08.798 --> 31:00:14.825
我们还需要编码我们想要升级的东西所以我们必须编码所有的函数参数。

18897
31:00:14.825 --> 31:00:39.711
我们将使用const编码的函数调用= box我们得到这个box的方法就是编码函数数据的接口这就是将它变成字节调用数据的方法，对吧?我们对所有东西进行编码，这个编码的函数，你可以在ethers文档中找到这个，我们必须给它传递要调用的函数，然后是我们想传递的参数，这就是我们实际得到它的方式。

18898
31:00:39.711 --> 31:00:41.977
我们来看看这些论证。

18899
31:00:42.111 --> 31:00:45.491
我们会说args，我们会让我们提出的函数有点模块化。

18900
31:00:45.491 --> 31:00:56.653
我们会说args将是一个任何数组，然后我们会说函数要调用的将是一个字符串，然后在底部，我们实际上会调用这个，这个提议的函数。

18901
31:00:56.653 --> 31:01:03.111
假设我们要给它77，函数将会是store store。

18902
31:01:03.111 --> 31:01:04.444
这是一个字符串。

18903
31:01:04.444 --> 31:01:06.301
这需要一个清单。

18904
31:01:06.301 --> 31:01:07.777
我们要这样做。

18905
31:01:07.777 --> 31:01:10.586
现在，我们要在所有地方都用到它。

18906
31:01:10.586 --> 31:01:16.544
因为我们要在所有地方使用这个，我们要把它们粘在这个部分headhelper配置中。

18907
31:01:16.544 --> 31:01:21.416
我们要做的是，输入export const, new store value = 77。

18908
31:01:21.416 --> 31:01:25.968
然后输出const funk = store。

18909
31:01:25.968 --> 31:01:30.163
我建议，我们把它们导入。

18910
31:01:30.163 --> 31:01:39.211
我们会导入，new store value，还有funk from helper Hardhead。config，它为我们添加了它，这很好。

18911
31:01:39.211 --> 31:01:41.295
我们在这里写上新的存储值。

18912
31:01:41.295 --> 31:01:42.771
然后我们在这里放放克。

18913
31:01:42.771 --> 31:01:49.818
我知道这可能看起来有点混乱，但基本上，我们要做的第一件事是我们要调用这个提议的函数它调用上面的post函数。

18914
31:01:49.818 --> 31:01:54.277
现在我们要做一些有趣的事情然后处理出口0。

18915
31:01:54.277 --> 31:02:05.277
然后我们会做一个。catch error，如果有错误，我们会做console。log error，然后处理它。

18916
31:02:05.277 --> 31:02:11.349
这是你使用的任何脚本的典型设置，还有硬帽。

18917
31:02:11.349 --> 31:02:11.777
太好了。

18918
31:02:11.777 --> 31:02:15.900
我们有一个常数编码函数调用，它有一个函数来调用弧。

18919
31:02:15.900 --> 31:02:18.717
我们基本上是把这些合并到这个字节里。

18920
31:02:18.717 --> 31:02:20.864
我们甚至可以把它打印出来，你可以看到它是什么样的。

18921
31:02:20.864 --> 31:02:25.111
你用console。log，看到了吧，这个疯狂的字节。

18922
31:02:25.111 --> 31:02:33.449
我们的测试方法是，我们用纱线硬帽节点，它会再次向上旋转，我们的假区块链。

18923
31:02:33.449 --> 31:02:44.127
另外，使用Hardhead deploy，它会在这里部署我们所有的契约，对吧，我们可以看到时间日志治理，你知道，我们在本地测试所需的一切都已经完成了。

18924
31:02:44.127 --> 31:03:00.888
一旦我们有了那个，我们就能做yarn hardhat，运行脚本，建议TS dash network，本地主机，这很重要，因为当你处理一个本地运行的节点时，你会处理本地主机，我们会看到它在这里打印出什么。

18925
31:03:01.111 --> 31:03:05.035
合同命名为总督合同，总督合同。

18926
31:03:05.111 --> 31:03:06.422
让我们再试一次。

18927
31:03:09.111 --> 31:03:14.223
编码的函数调用和参数看起来像一个很长的字节字符串。

18928
31:03:14.223 --> 31:03:20.890
但如果你要解码这个，使用盒子接口，你会得到函数调用和参数，这非常令人兴奋。

18929
31:03:20.890 --> 31:03:22.689
太酷了，我们把它编码成字节。

18930
31:03:22.689 --> 31:03:27.957
现在我们要做的是，我们鼓励字节，现在我们要创建提议事务。

18931
31:03:27.957 --> 31:03:36.291
所以我们写console。log会说pro。然后说，函数调用box那个地址，带args。

18932
31:03:36.291 --> 31:03:39.841
然后我们还需要通过提案描述。

18933
31:03:39.841 --> 31:03:50.039
我们会写pro pose，所有描述，我们会在换行，为什么不呢?专业人士把所有这些选项，我们还没有。

18934
31:03:50.111 --> 31:03:50.968
好吧，我们会得到它的。

18935
31:03:52.111 --> 31:03:55.852
描述，对，因为我们在下面有描述。

18936
31:03:56.111 --> 31:03:58.422
让我们在这里为我们的提议添加另一个参数。

18937
31:03:59.111 --> 31:04:03.373
提案描述，这也是一个字符串。

18938
31:04:04.111 --> 31:04:07.063
下面，我们还需要提案描述。

18939
31:04:07.111 --> 31:04:12.666
我们会创建一个proposal或者export const proposal description，这里会有一些字符串。

18940
31:04:12.666 --> 31:04:20.957
所以我们写提案1,77号门，在方框里，这是描述，逗号，提案描述。

18941
31:04:20.957 --> 31:04:23.223
然后我们导入这个或者一个helper配置。

18942
31:04:23.223 --> 31:04:23.900
好的,完美的。

18943
31:04:23.900 --> 31:04:37.225
现在我们有了新的存储值，函数提案描述，我们现在可以调用我们刚才看到的那个提案这是我们要做的const提案TX = await。

18944
31:04:37.225 --> 31:04:38.585
政府没有提议。

18945
31:04:38.585 --> 31:04:40.754
我们需要通过那些名单。

18946
31:04:40.754 --> 31:04:45.561
首先是一个目标列表，对我们来说就是一个只有一个目标的方框。

18947
31:04:45.561 --> 31:05:01.165
再说一次，这些小括号，让它成为一个值列表，它将是0，一个编码的函数调用列表或者我们的字节数据，然后是提案描述，然后我们要做提案，TX。wait 1。

18948
31:05:01.165 --> 31:05:14.042
现在，如果你还记得，从复合，这将是完全一样的如果我们回到复合回到治理，这个事务实际上将和这里创建的东西是一样的。

18949
31:05:14.111 --> 31:05:31.146
对吧?如果我们向下滚动，我们可以看到代码输入数据，这些东西在复合提案中完全相同，对吧?我们有目标值签名，好的，这个CES有点，这个有点高级，使用签名，但它有相同的东西叫做数据，然后这里是描述。

18950
31:05:31.146 --> 31:05:36.438
现在由于我们有投票延迟，人们实际上不能投票，直到投票延迟通过。

18951
31:05:36.438 --> 31:05:43.444
现在，有了一个本地区块链，没有人会处理block，时间也不会像我们想的那么快。

18952
31:05:43.444 --> 31:05:46.924
为了我们自己的测试目的，我们要加快速度。

18953
31:05:46.924 --> 31:05:58.280
我通常的做法是创建这个这个变量，所有开发，出口，在开发链上，我会添加硬帽和本地主机。

18954
31:05:58.280 --> 31:06:04.938
因为我们可以用我们自己的本地区块链做一些事情，我们可以加速时间，我们可以加速块，我们可以做所有这些疯狂的事情。

18955
31:06:04.938 --> 31:06:07.304
通常，我会把它导入这里。

18956
31:06:07.304 --> 31:06:08.658
然后我们做一个快速的F。

18957
31:06:08.658 --> 31:06:12.317
我会说，如果我们在开发链上，让我们继续前进，加快我们的速度。

18958
31:06:12.317 --> 31:06:12.937
正确的。

18959
31:06:12.937 --> 31:06:22.619
所以我会说if development chains，其中包含network。name，然后我们也可以从ethers导入network。

18960
31:06:22.619 --> 31:06:25.539
这就是我所说的你要学习的六大技能。

18961
31:06:25.539 --> 31:06:32.852
如果它包含network。name，那么我们就会向前移动区块，因为如果我们不在开发链上，我们就不能移动区块。

18962
31:06:32.852 --> 31:06:38.611
这里我要做的是创建一个新文件夹，叫做utilities，你的文件夹，你就是utils。

18963
31:06:38.611 --> 31:06:42.495
在这里，我要创建一个名为Move blocks的脚本。

18964
31:06:42.495 --> 31:06:42.648
ts。

18965
31:06:42.648 --> 31:06:48.856
我们将创建这个叫move blocks的小函数，它为我们移动block。

18966
31:06:48.856 --> 31:06:49.958
你会看到我们是怎么做的。

18967
31:06:49.958 --> 31:06:57.788
我们会从heart app导入network，因为我们想加快投票延迟，我们会用export async function，我们称之为move blocks。

18968
31:06:57.788 --> 31:07:02.537
它需要一个量，这将是一个数字，所以我们实际上想移动多少块。

18969
31:07:02.537 --> 31:07:06.111
然后我们写console。log moving blocks。

18970
31:07:06.111 --> 31:07:12.064
我们说，for let index = 0, index小于amount。

18971
31:07:12.064 --> 31:07:19.861
index + +，或者我们要做的是我们要做一个权重网络DAP提供者。request request。

18972
31:07:19.861 --> 31:07:23.932
我们会请求方法EVM。

18973
31:07:23.932 --> 31:07:24.467
我的。

18974
31:07:24.467 --> 31:07:35.935
基本上，我们在挖掘我们本地的区块链，所以你可以在硬帽码头找到这些码头在醚码头，有几个不同的地方你可以找到这些。

18975
31:07:35.935 --> 31:07:41.377
这是一种很酷的hack我们可以用它在本地链上向前移动块。

18976
31:07:41.377 --> 31:07:47.377
现在，很明显，这在一个实际的链上是行不通的，因为你实际上必须进行挖矿但在我们的本地链上，我们完全可以这样做。

18977
31:07:47.377 --> 31:07:57.548
我们导出了这个move blocks函数，我们会抓取Mark的提议，我们会从utils blocks导入move box。

18978
31:07:57.548 --> 31:08:13.111
我们会在下面这里说，如果我们在这个开发链上，做一个权重移动块，然后我们会通过我们讨论过的投票延迟移动块，对吧?因为我们需要等待投票延迟才能移动它看起来像是自动从助手硬件配置中导入它。

18979
31:08:13.111 --> 31:08:16.664
我告诉过你，我们会用几次，但我们会通过投票延迟来转移街区。

18980
31:08:16.664 --> 31:08:23.611
现在，这个提议的交易做了一些我们真正想要的东西，对吧?它想要的一件大事是，它有这个提案ID。

18981
31:08:23.611 --> 31:08:33.330
如果我们向下滚动到它发出的事件，它最终会发出这个提案ID，当我们稍后进行投票时，我们实际上需要提案ID。

18982
31:08:33.330 --> 31:08:40.594
我们要做的是，我们实际上要做的是const proposal receipt = proposal text。weight。

18983
31:08:40.594 --> 31:08:43.918
我们将从这个提议的收据中得到那些事件。

18984
31:08:43.918 --> 31:08:45.727
我们会说const。

18985
31:08:45.727 --> 31:08:55.531
提案，id等于提议的收据，那个事件，带event的0因为第一个事件是我们唯一关心的是你的停止提案id。

18986
31:08:55.531 --> 31:08:59.924
这就是我们如何从这个省略也创建的事件中获得这个提案ID。

18987
31:08:59.924 --> 31:09:03.327
有一些其他的方法来获得建议，以获得事件在硬帽。

18988
31:09:03.327 --> 31:09:05.800
我在我的YouTube上有一个视频，如果你想去看的话。

18989
31:09:05.800 --> 31:09:18.799
我们还想知道快照的截止日期是什么，你可以去我的GitHub看看快照是什么样子或者截止日期，基本上，我们要投票多长时间，你知道你用的是什么快照，所有这些不同的东西。

18990
31:09:18.799 --> 31:09:22.080
但现在，我们将坚持这个提议。我一定会去GitHub看看更多的东西。

18991
31:09:22.112 --> 31:09:31.533
现在我们想要保存这个提案ID，我们想要保存它到某个地方以便我们的其他脚本以便我们的投票，我们的队列和执行当我们运行这些时知道这个提案ID是什么。

18992
31:09:31.533 --> 31:09:35.535
我们要做的是创建这个文件，名为提案。JSON。

18993
31:09:35.535 --> 31:09:37.384
它会存储我们所有的建议。

18994
31:09:37.384 --> 31:09:42.921
我们写入pro poll, souls。JSON，这里会有我们所有的提案。

18995
31:09:42.921 --> 31:09:50.800
我们要做的是。我们要把这个添加到我们的助手Hardhead配置中，然后输出const，提案，file =提案。JSON。

18996
31:09:50.800 --> 31:09:55.159
我们将在顶部导入这个以及提案文件。

18997
31:09:55.159 --> 31:10:00.518
一旦我们得到这个提案ID，我们要做的是读取所有当前的提案。

18998
31:10:00.518 --> 31:10:13.804
我们会说，let建议书= JSON。parse，然后我们会做Fs。read文件同步从这个探测建议书文件，我们会把它传递给utf8。

18999
31:10:13.804 --> 31:10:19.112
现在，这个f我们还没有得到，所以我们需要导入f。

19000
31:10:19.112 --> 31:10:22.695
我们要像这样把纱线加上f。

19001
31:10:22.695 --> 31:10:24.762
如果我们看的是package。JSON。

19002
31:10:24.762 --> 31:10:30.708
哦，我应该把它存成戴夫的，但我没有哦，那不重要。

19003
31:10:30.708 --> 31:10:33.918
现在我们有了这个，我们可以把它导入到TypeScript中。

19004
31:10:33.918 --> 31:10:38.243
我们只要说，从Fs导入*作为Fs。

19005
31:10:38.243 --> 31:10:42.580
现在我们可以用F F作为从文件中读取的一种方式。

19006
31:10:42.580 --> 31:10:44.361
现在我们可以拿到建议书的清单了。

19007
31:10:44.361 --> 31:10:48.062
我们有两个提议，现在我们只是做一个空白的JSON。

19008
31:10:48.112 --> 31:10:50.552
第一次运行时，它是空白的。

19009
31:10:51.112 --> 31:10:52.330
它会有东西在里面。

19010
31:10:54.112 --> 31:11:03.826
这些提案是我们会说pro提案network。config。chain ID，这个小银行会说，是的，会有一个chain ID。

19011
31:11:03.826 --> 31:11:07.518
到字符串，我们会按链id存储它们。

19012
31:11:07.518 --> 31:11:11.033
所以对于每个我们有一个提议的网络我们会像这样开始。

19013
31:11:11.033 --> 31:11:13.440
然后是。push提案，id。

19014
31:11:13.440 --> 31:11:16.486
到字符串，然后再写回来。

19015
31:11:16.486 --> 31:11:21.312
Fs。right，文件同步，提案文件。

19016
31:11:21.312 --> 31:11:25.325
JSON处理字符串，提案，棒极了。

19017
31:11:25.325 --> 31:11:27.702
这就是我们要做的。

19018
31:11:27.702 --> 31:11:29.353
我们来运行一下这个。

19019
31:11:29.353 --> 31:11:35.259
然后这里有一些console。log说，嘿，这是提案的状态，它是打开的吗?是投票还是取消，等等。

19020
31:11:35.259 --> 31:11:39.049
提案快照是什么，你们知道的，再去我的GitHub看看。

19021
31:11:39.049 --> 31:11:45.273
但是我们能做的是，现在这个已经完成了，我们可以做纱线，Hardhead节点，旋转我们的小音符。

19022
31:11:45.273 --> 31:11:47.578
所有的合同都部署好了。

19023
31:11:47.578 --> 31:11:57.495
然后我们会做yarn，运行脚本，提出TS是破折号网络，本地主机脚本提出TS是找不到的。

19024
31:11:57.495 --> 31:12:05.695
专业姿势，纱线，硬帽子，运行脚本，姿势id，哎呀，破折号网络，本地主机。

19025
31:12:05.695 --> 31:12:06.789
再试一次。

19026
31:12:06.789 --> 31:12:07.941
现在你找到了。

19027
31:12:07.941 --> 31:12:08.212
耶。

19028
31:12:08.212 --> 31:12:09.839
哦，我遇到了一个问题。

19029
31:12:10.112 --> 31:12:12.712
虽然描述无法读取未定义的属性0。

19030
31:12:12.712 --> 31:12:14.912
看看它在哪里生我的气。

19031
31:12:14.912 --> 31:12:16.439
Poser表单点事件。

19032
31:12:16.439 --> 31:12:19.979
它是本地主机上的事件，而不是事件拍摄。

19033
31:12:20.112 --> 31:12:22.322
好了，又碰到了一个问题。

19034
31:12:23.112 --> 31:12:23.505
的存在。

19035
31:12:23.505 --> 31:12:24.488
很好。

19036
31:12:27.112 --> 31:12:33.293
直接杀死节点，重启节点，所以你不可能有两个完全相同的提议。

19037
31:12:33.293 --> 31:12:35.954
所以我们不能那样做，我们需要改变描述之类的。

19038
31:12:35.954 --> 31:12:37.704
我们要杀死节点，然后重启。

19039
31:12:37.704 --> 31:12:39.515
现在我们再来运行一遍这个提案。

19040
31:12:39.515 --> 31:12:43.144
希望这次能成功。

19041
31:12:43.144 --> 31:12:47.207
共同财产零未定义欠收据。

19042
31:12:47.207 --> 31:12:53.997
这需要等待，因为它是一个承诺，再杀死它一次，我们运行它一旦所有这些部署。

19043
31:12:53.997 --> 31:12:56.238
我们将继续运行这个。

19044
31:12:56.238 --> 31:13:02.549
现在你可以看到这比你把它直接发送到一个测试网中要快得多要等很长时间，这一点都不好。

19045
31:13:02.549 --> 31:13:07.515
我们又碰到一个不能读取属性，push它们为undefined。

19046
31:13:07.515 --> 31:13:09.015
这也很有道理。

19047
31:13:09.112 --> 31:13:12.821
因为建议点JSON作为无链id。

19048
31:13:13.112 --> 31:13:13.595
231337.

19049
31:13:13.595 --> 31:13:16.498
我们会在这里列一个小列表。

19050
31:13:18.112 --> 31:13:18.612
空列表。

19051
31:13:21.112 --> 31:13:22.445
它。

19052
31:13:23.112 --> 31:13:25.378
一旦这个完成了，我们就继续做这个。

19053
31:13:25.378 --> 31:13:25.911
完美的。

19054
31:13:25.911 --> 31:13:33.234
现在我们要运行这个，现在它应该保存了，一切都很好。

19055
31:13:33.234 --> 31:13:33.935
太棒了。

19056
31:13:34.112 --> 31:13:37.612
提案一，把积木放在盒子里，我们把积木搬走。

19057
31:13:38.112 --> 31:13:41.577
我们看proposal。JSON，我们现在看到有一个提案列表。

19058
31:13:41.577 --> 31:13:44.474
这是我们刚创建的提案ID。

19059
31:13:44.474 --> 31:13:45.974
好吧，我们求婚了。

19060
31:13:45.974 --> 31:13:46.387
太棒了。

19061
31:13:46.387 --> 31:13:48.612
干得好，我们让Node继续运行。

19062
31:13:48.612 --> 31:13:51.882
希望我们能为投票做好准备。

19063
31:13:51.882 --> 31:13:54.315
现在让我们创建这个投票脚本。

19064
31:13:54.315 --> 31:13:58.531
好了，现在我们提议该投票了，让我们来投票吧。

19065
31:13:58.531 --> 31:14:01.962
这个看起来和那个脚本很像，我们刚刚创建的。

19066
31:14:01.962 --> 31:14:12.055
我们在New async function中，我们把这个叫做main proposal index number，我们把这个叫做main因为我们要让vote函数有点不同。

19067
31:14:12.055 --> 31:14:12.621
你会看到原因的。

19068
31:14:12.621 --> 31:14:29.000
在底部，当然，我们会做main index。然后process。exit 0, catch error箭头函数，console。error error，然后处理那个exit。

19069
31:14:29.000 --> 31:14:33.477
一个主指标，我们设指标0成本指标0。

19070
31:14:33.477 --> 31:14:35.456
这个成本指数就是邮政指数。

19071
31:14:35.456 --> 31:14:40.565
我们会得到。我们会得到第0位的index，对吧，提案。JSON中的第一个索引。

19072
31:14:40.565 --> 31:14:44.542
所以无论列表中的第一个是什么都是我们要用的，对吧?这就是我们现在想要的。

19073
31:14:44.542 --> 31:14:45.465
只有一个，所以很简单。

19074
31:14:45.465 --> 31:14:47.143
所以我们要把第一个放在这里。

19075
31:14:47.143 --> 31:14:51.576
所以我们要做的第一件事就是拿到提案的名单。

19076
31:14:51.576 --> 31:14:59.969
我们会写const proposal = JSON。parse FS。read文件同步建议书文件UTF 8。

19077
31:14:59.969 --> 31:15:03.901
当然，我们需要导入一些东西。

19078
31:15:03.901 --> 31:15:09.278
我们要导入提案文件，一个斜杠，一个Bernhard配置。

19079
31:15:09.278 --> 31:15:14.207
然后我们要import * as f。

19080
31:15:14.207 --> 31:15:14.778
太好了。

19081
31:15:14.778 --> 31:15:18.325
我们有f，我们可以读东西，我们可以得到那些船。

19082
31:15:18.325 --> 31:15:18.865
好的,很酷。

19083
31:15:18.865 --> 31:15:20.540
我们有一个提案id列表。

19084
31:15:20.540 --> 31:15:24.079
现在让我们得到提案的想法，我们将使用const probo。

19085
31:15:24.079 --> 31:15:28.505
ID也等于网络点配置的建议。

19086
31:15:28.505 --> 31:15:30.668
这不是我们想要的。

19087
31:15:30.668 --> 31:15:47.275
我们想要导入网络，从hard hat导入网络，网络点配置，那个链ID，感叹号提案索引，对我们来说是零，对吧?我们收到了提案清单上的第一份提案。

19088
31:15:47.275 --> 31:15:49.816
现在我们要决定怎么投票了。

19089
31:15:49.816 --> 31:15:53.612
0等于1等于4,2等于弃权。

19090
31:15:53.612 --> 31:16:01.737
我不知道为什么你会弃权弃权会消耗汽油，你可以不投票，但我们会说const投票方式我们的投票方式等于1。

19091
31:16:01.737 --> 31:16:03.487
我们也可以给出一个理由。

19092
31:16:03.487 --> 31:16:14.758
所以如果我们回到我们的州长，有几个不同的功能来投票，有投票，我们只是投了一票，投，有理由的投票，和有签名的投票，我们实际做了一个签名。

19093
31:16:14.758 --> 31:16:25.512
我问了这个问题，嘿，有病的人在论坛上投票是干什么的，我想，嘿，这是什么目的是什么?我的直觉是，如果我不发送交易，任何人都可以代表我执行这个投票。

19094
31:16:25.512 --> 31:16:26.602
这就是事实。

19095
31:16:26.602 --> 31:16:35.285
该方法实现了一个元事务，并允许项目补贴投票费用，投票者可以免费生成签名，项目可以提交这些签名并支付汽油费用。

19096
31:16:35.285 --> 31:16:37.073
这是非常强大的。

19097
31:16:37.073 --> 31:16:55.954
这个函数允许这个，这个签名投票它允许快照链接集成，希望你们中有人能构建，但对于我们来说，因为我们不实现这些元事务，这些链外的东西，我们只会有理由地投票因为我们想给它一个理由。

19098
31:16:55.954 --> 31:16:56.848
真的是这样。

19099
31:16:56.848 --> 31:17:02.212
我们会说const boat TX response = await。

19100
31:17:02.212 --> 31:17:05.921
不好意思，我们需要得到政府合同。

19101
31:17:05.921 --> 31:17:07.259
我们用const。

19102
31:17:07.259 --> 31:17:10.947
政府也不平等等待别人得到合同。

19103
31:17:11.112 --> 31:17:11.702
政府合同。

19104
31:17:14.112 --> 31:17:14.492
醚。

19105
31:17:14.492 --> 31:17:14.872
太好了。

19106
31:17:14.872 --> 31:17:15.951
我们来看看醚。

19107
31:17:15.951 --> 31:17:17.347
我们忽略它。

19108
31:17:18.112 --> 31:17:19.112
我们有合同。

19109
31:17:21.112 --> 31:17:24.040
有道理的拼写对吗?与原因。

19110
31:17:25.112 --> 31:17:26.381
提案ID那样。

19111
31:17:29.112 --> 31:17:31.445
讲道理，我们来讲个道理。

19112
31:17:33.112 --> 31:17:40.732
我喜欢做恰恰，如果你知道这部电影，你一定要在描述中评论它。

19113
31:17:40.732 --> 31:17:47.210
我们投票是有原因的我们说我们想我们确实想让你们把方框改成77。

19114
31:17:47.210 --> 31:17:55.724
原因是，我喜欢做Cha Cha，如果你不去想，它很有意义，然后我们会做一个等待，Kotex响应那个等待。

19115
31:17:55.724 --> 31:18:02.969
所以我做了一些事情，再次检查提案的状态，不同的数字意味着，嘿，它在进行中，它在投票，等等，我们可以检查这些。

19116
31:18:02.969 --> 31:18:04.048
但我们现在先跳过这个。

19117
31:18:04.112 --> 31:18:07.645
我们现在要做的就是，既然我们已经投票了，我们就是投票的人。

19118
31:18:07.645 --> 31:18:09.925
所以我们要再一次移动方块。

19119
31:18:09.925 --> 31:18:14.059
为什么呢?因为我们想马上结束投票期。

19120
31:18:14.059 --> 31:18:23.818
我们会再做一次，如果veldevelopmentchains，它包括network。name，然后我们会做一个权重move blocks, voting period，加1。

19121
31:18:23.818 --> 31:18:26.902
我们需要在这里导入一大堆东西。

19122
31:18:26.902 --> 31:18:32.269
姿势文件开发，看起来那些被自动导入了，我们需要导入这个移动块。

19123
31:18:32.269 --> 31:18:38.262
因此，import move blocks from utils blocks，网络在这里。

19124
31:18:38.262 --> 31:18:41.056
然后我们需要helper配置中的投票周期。

19125
31:18:41.056 --> 31:18:41.833
投票时间。

19126
31:18:41.833 --> 31:18:42.444
好的,很酷。

19127
31:18:42.444 --> 31:18:47.173
然后我们写console。log，投票，准备好了。

19128
31:18:47.173 --> 31:18:54.053
我检查提案状态的原因是在州长契约中有这个状态函数。

19129
31:18:54.053 --> 31:19:04.870
如果我们查看状态，它会告诉我们提案的状态如果它被执行了，返回被执行了，如果它被取消了，返回被取消了。

19130
31:19:04.870 --> 31:19:19.235
你有截止日期，检查它是否有效，检查法定人数是否达到了所有这些，对吧?你通常寻找的是蠕虫到达和投票成功，对吧?如果这两件事都发生了，交通部的提案成功了，对吧?否则，它就被打败了，或者还没到那里。

19131
31:19:19.235 --> 31:19:21.273
我相信这是1，这是0。

19132
31:19:21.273 --> 31:19:26.174
所以如果你调用这个函数并得到正确的状态，现在我们应该得到0。

19133
31:19:26.174 --> 31:19:28.489
不好意思，我们应该为过去的这段时间拿一个。

19134
31:19:28.489 --> 31:19:31.445
如果你想做这个作为额外的学分，请随意做。

19135
31:19:31.445 --> 31:19:32.839
看看我们做得对不对。

19136
31:19:32.839 --> 31:19:35.254
事实上，我想我们得改一下，就为了投票。

19137
31:19:35.254 --> 31:19:37.342
但我刚刚把所有东西都打包成main了。

19138
31:19:37.342 --> 31:19:38.899
我们来看看这是否可行。

19139
31:19:38.899 --> 31:19:42.281
纱线，硬帽运行脚本投票网络，本地主机。

19140
31:19:42.281 --> 31:19:47.849
我们应该在底部得到一个小小的console。log说，投票准备好了。

19141
31:19:47.849 --> 31:19:48.898
现在我们开始投票。

19142
31:19:48.898 --> 31:19:56.032
我们不只是去北极理事会，我们可以做纱线，硬帽主机，破折号网络，本地主机。

19143
31:19:56.112 --> 31:19:58.387
在这里，你可以在这里检查状态。

19144
31:19:58.387 --> 31:20:04.578
为什么不呢?我们将复制这一行作为总督因为我们要么得到总督契约。

19145
31:20:04.578 --> 31:20:13.629
现在我们可以做一个等待，总督，这是去提案。JSON的状态，抓取这个，粘贴到这里。

19146
31:20:13.629 --> 31:20:18.064
现在的状态是，我忘了4是什么意思了。

19147
31:20:18.064 --> 31:20:19.362
就像求婚的状态。

19148
31:20:19.362 --> 31:20:30.732
提案状态实际上在眼调控器中，因此调控器的接口我们可以看到，0个是未决的，1个是活动的，2个取消了，3个失败了，4个成功了。

19149
31:20:30.732 --> 31:20:34.243
所以我们处于成功的状态，这非常好。

19150
31:20:34.243 --> 31:20:35.161
这正是我们想要的。

19151
31:20:35.161 --> 31:20:36.370
我们现在就退出吧。

19152
31:20:36.370 --> 31:20:37.663
抱歉，Ctrl键。

19153
31:20:37.663 --> 31:20:41.366
C，我们的建议现在处于成功的状态。

19154
31:20:41.366 --> 31:20:44.402
我们实际上已经移动了投票期间的区块。

19155
31:20:44.402 --> 31:20:46.385
投票结束了，因为我们作弊了。

19156
31:20:46.385 --> 31:20:51.778
现在我们来排队并执行到最后一位。

19157
31:20:51.778 --> 31:20:53.095
这看起来和我们已经做过的很像。

19158
31:20:53.112 --> 31:20:59.705
对吧?让我们最小化它，导出async，函数，Q和执行。

19159
31:20:59.705 --> 31:21:04.456
然后在底部，我们会调用queue并执行。

19160
31:21:04.456 --> 31:21:10.722
复制粘贴，语法是一样的，然后process exec catch，等等等等，你就得到了练习。

19161
31:21:10.722 --> 31:21:16.518
为了排队和执行，回到调控器契约，而不是调控器，让我们回到调控器。

19162
31:21:16.518 --> 31:21:19.009
首先我们要做的是调用这个队列。

19163
31:21:19.112 --> 31:21:25.412
现在这个Q函数实际上在调控器时间锁中，在这个扩展中。

19164
31:21:25.412 --> 31:21:35.144
我们能在这里找到调控器Time Lock控制器，它做的和建议完全一样我们取建议中做的所有东西，然后像这样排队。

19165
31:21:35.144 --> 31:21:37.012
我们在这里传递完全相同的值。

19166
31:21:37.112 --> 31:21:38.012
太可爱了。

19167
31:21:40.112 --> 31:21:43.563
首先需要得到完全相同的值，我告诉过你们，我们会用到几次。

19168
31:21:43.563 --> 31:22:07.596
我们要导入，新存储值，文章的建议描述，现在我们有了这些东西，我们会说const args =一个新的存储值，我们会说const box = await ethers。get contract，我们再次得到那个box contract，我们需要从hat导入ethers。

19169
31:22:07.596 --> 31:22:21.912
这将来自我们将做TS忽略，然后我们再次将这个函数调用编码为const编码的函数调用等于Boxtop接口，编码函数数据。

19170
31:22:21.912 --> 31:22:29.375
再说一次，funk是我们要调用的函数和args这就像real和我们建议的位一样。

19171
31:22:29.375 --> 31:22:44.326
然后我们会做内容描述哈希= ethers。utils得到GAC 256 ethers。utils，这对你们来说是TF 8字节，这马上就说得通了。

19172
31:22:44.326 --> 31:22:45.968
我们也是描述性的。

19173
31:22:45.968 --> 31:23:01.762
我们的提案，我们所做的只是传递提案描述，然而，它实际上是在chain上哈希的，这就是我们的视图和执行要找的，它会找描述哈希，而不仅仅是单纯的描述，这样会更节省时间，这很好。

19174
31:23:01.762 --> 31:23:08.695
现在我们有了描述哈希，现在我们有了所有相同的函数假设是时候对它们进行排队了。

19175
31:23:08.695 --> 31:23:13.061
所以做成本政府等于等待醚点得到合同。

19176
31:23:13.061 --> 31:23:23.000
政府合约，console。log会说我们正在排队然后我们会写cos Q dx等于政府。Q。

19177
31:23:23.112 --> 31:23:34.805
我们会传递和姿势一样的参数除了哈希值而不是实际的提议，所以把地址设为0，然后在函数调用时传递代码。

19178
31:23:34.805 --> 31:23:37.627
然后是描述哈希率。

19179
31:23:37.627 --> 31:23:41.789
然后我们要做，哦，是这里的一个权重。

19180
31:23:41.789 --> 31:23:43.737
然后我们要等待。

19181
31:23:43.737 --> 31:23:46.424
你发短信哦，等一下，等一个街区。

19182
31:23:46.424 --> 31:23:48.674
太好了，我们都排好队了。

19183
31:23:48.674 --> 31:23:54.332
现在我们还得等待最小延迟，对吧?记住，在时间轴上，它有最小延迟。

19184
31:23:54.332 --> 31:23:58.543
它说，嘿，一旦有东西排队了，你不能马上执行它。

19185
31:23:58.543 --> 31:24:00.462
你得给人们时间离开。

19186
31:24:00.462 --> 31:24:11.497
所以我们会再次加快时间，我们会说，如果开发链发展，我指的是链，然后它看起来像自动导入的开发链。

19187
31:24:11.497 --> 31:24:12.339
是的，确实如此。

19188
31:24:12.339 --> 31:24:12.900
很神奇的。

19189
31:24:13.112 --> 31:24:14.563
这包括network。name。

19190
31:24:16.112 --> 31:24:17.639
网络从Hardhead。

19191
31:24:20.112 --> 31:24:21.933
当然，我们要移动街区。

19192
31:24:23.112 --> 31:24:26.849
必须把时间移到这里，因为最小延迟需要一段时间。

19193
31:24:26.849 --> 31:24:30.455
让我们创建一个名为Move time的新util。

19194
31:24:30.455 --> 31:24:32.690
好的，移动时间是的。

19195
31:24:32.690 --> 31:24:37.558
这个util将允许我们移动时间，所以你可以学到所有很酷的东西。

19196
31:24:37.558 --> 31:25:06.466
我们很快就会写一个脚本来完成这个重要的网络从硬帽导出异步函数移动时间，移动时间是多少是Mount console。log，移动时间，然后是await network。provider。send EVM增加时间然后是数量，然后是console。log，向前移动，数量秒，它向前移动和秒。

19197
31:25:06.466 --> 31:25:06.788
酷。

19198
31:25:06.788 --> 31:25:08.891
现在我们有了这个移动时间函数。

19199
31:25:08.891 --> 31:25:15.773
挺快的，对吧?首先，我们要移动时间我们要先移动那个最小延时，为了安全起见，加1。

19200
31:25:15.773 --> 31:25:17.293
然后我们也要移动方块。

19201
31:25:17.293 --> 31:25:20.735
我们要做一个重量移动时间，然后一个重量移动块。

19202
31:25:20.735 --> 31:25:22.768
我们就按街区移动。

19203
31:25:22.768 --> 31:25:26.046
从utils导入move blocks。

19204
31:25:26.046 --> 31:25:30.561
它也从这些工具中导入移动时间，时间。

19205
31:25:30.561 --> 31:25:35.063
然后我们还需要导入这个最小延迟，这是我们从辅助函数得到的。

19206
31:25:35.113 --> 31:25:35.850
傻瓜配置。

19207
31:25:35.850 --> 31:25:36.145
太好了。

19208
31:25:36.145 --> 31:25:37.472
所以我们把所有的东西都搬走了。

19209
31:25:38.113 --> 31:25:40.290
这是真正的连锁店，你只需要等待。

19210
31:25:41.113 --> 31:25:42.713
不是真正的链条，我们想怎么做就怎么做。

19211
31:25:43.113 --> 31:25:44.163
做我想做的事。

19212
31:25:46.113 --> 31:25:48.768
过了，我们看起来很辣。

19213
31:25:48.768 --> 31:25:50.931
让我们把它开回家。

19214
31:25:52.113 --> 31:25:57.926
执行const execute TX = await。

19215
31:25:57.926 --> 31:25:59.010
政府执行。

19216
31:25:59.010 --> 31:26:05.838
我们要传递这个和我们对qtx做的一样的东西所以我要复制这个。

19217
31:26:05.838 --> 31:26:06.757
把它贴在这里。

19218
31:26:06.757 --> 31:26:10.573
然后我们要做一个权重sqtx。权重。

19219
31:26:10.573 --> 31:26:12.953
我们要等一个街区。

19220
31:26:13.113 --> 31:26:24.078
最后一小时，我们将看看治理是否更新了我们的box contract const box new value = await box。retrieve。

19221
31:26:24.078 --> 31:26:28.060
它会做console。log。

19222
31:26:28.060 --> 31:26:29.749
新框值。

19223
31:26:30.113 --> 31:26:31.178
框新值。

19224
31:26:35.113 --> 31:26:36.573
要更新的框值。

19225
31:26:39.113 --> 31:26:43.713
帽子运行握Q和执行现在工作localhost。

19226
31:26:45.113 --> 31:26:49.019
对吧?我们成功地完成了治理吗?我们所做的。

19227
31:26:50.113 --> 31:26:51.446
我们会查出我们做错了什么。

19228
31:26:52.113 --> 31:26:54.899
我拼错了几个字。

19229
31:26:57.113 --> 31:26:57.435
没有CK。

19230
31:26:57.435 --> 31:26:58.209
只要k。

19231
31:26:58.209 --> 31:26:59.628
好吧，我们再试一次。

19232
31:27:01.113 --> 31:27:01.779
实际上做的。

19233
31:27:01.779 --> 31:27:02.890
我认为这很好。

19234
31:27:04.113 --> 31:27:07.774
提供EVM和crit，因为我拼写错误。

19235
31:27:08.113 --> 31:27:13.238
没有EVM增加时间，只是再次检查。

19236
31:27:15.113 --> 31:27:17.349
拼写正确，T是大写的。

19237
31:27:18.113 --> 31:27:18.578
搞砸了。

19238
31:27:18.578 --> 31:27:20.491
它实际上已经排队了。

19239
31:27:21.113 --> 31:27:24.653
现在在我们的小节点EVM增加团队排队。

19240
31:27:25.113 --> 31:27:32.563
可以删除并重新启动，或者我可以继续我将注释掉一些东西，我们将跳过这里的提示。

19241
31:27:32.563 --> 31:27:36.045
我们要再运行一遍，因为它已经排队了。

19242
31:27:36.045 --> 31:27:38.883
现在应该执行，我们将再次移动时间。

19243
31:27:38.883 --> 31:27:39.669
不过没关系。

19244
31:27:39.669 --> 31:27:41.003
天啊，我们成功了。

19245
31:27:41.003 --> 31:27:41.284
正确的。

19246
31:27:41.284 --> 31:27:43.940
通常情况下，你只需要在一个脚本中完成。

19247
31:27:43.940 --> 31:27:46.790
但是这个队列会失败，因为它已经排队了。

19248
31:27:46.790 --> 31:27:48.870
好吧，你不能排两次队，往前走。

19249
31:27:48.870 --> 31:28:03.028
随着时间的推移，我们移动了我们执行的区块我们得到了一个新的盒子值完全使用我们的道指完全去中心化投票完全在链上，没有第三方信任。

19250
31:28:03.113 --> 31:28:11.028
这里没有投票站，也没有你知道的，在员工身上花费1000美元，我们刚刚投票的所有事情都发生在我们面前。

19251
31:28:11.028 --> 31:28:16.064
再一次，我强烈推荐大家去我的GitHub回购，你们可以看看这里发生了什么。

19252
31:28:16.113 --> 31:28:19.313
同样，如果您想了解JavaScript的内容，请随意做一些JavaScript的内容。

19253
31:28:19.313 --> 31:28:23.713
这节课讲的是如何开始克隆如果你想这么做的话。

19254
31:28:23.713 --> 31:28:32.138
但如果你和我一起走过这段路，如果你和我一起走过这段路，你就会学到绝对的可汗，非常感谢你来到这里。

19255
31:28:32.138 --> 31:28:34.907
我们下期见。

19256
31:28:35.113 --> 31:28:35.827
好吧。

19257
31:28:40.113 --> 31:28:46.473
安全和审计部分，这部分的编码会少一点，解释会多一点。

19258
31:28:46.473 --> 31:28:50.382
我们要学习的大部分内容都是在这个硬头安全FCC部分。

19259
31:28:50.382 --> 31:28:56.481
在本课程中，我们给了您一些关于不同安全特性的提示。

19260
31:28:56.481 --> 31:29:02.440
第一，我们讲了可重入性，我们讲了一点甲骨文税，我们还会继续讲。

19261
31:29:02.440 --> 31:29:09.867
还有一些工具可以让我们的代码更高效，找出错误，让我们的代码更安全。

19262
31:29:09.867 --> 31:29:17.387
我们将继续，我们将过一遍这个硬帽安全FCC代码库，我们将稍微过一遍。

19263
31:29:17.387 --> 31:29:27.313
我们首先要讲的是，什么是审计?审计将是一个以安全为重点的代码审查，寻找您的代码的问题。

19264
31:29:27.313 --> 31:29:44.604
举个例子，假设我们有一些这样的代码，这应该有点熟悉，因为我们在之前的可重入部分讨论过这个，我们的代码，提取，去发送以太币，然后更新余额，这段代码显然很容易受到可重入攻击。

19265
31:29:44.604 --> 31:29:47.294
这是审计员会发现的。

19266
31:29:47.294 --> 31:29:49.435
因为当我们部署代码时，代码是不可变的。

19267
31:29:49.435 --> 31:30:07.589
这些代码会一直在那里，在我们将代码部署到主网之前，在我们上线之前，进行这些安全审查是非常重要的，所以如果你要部署一些疯狂的，大规模的对抗协议，你将有数十亿美元的人们的钱锁定在你的协议中，你可能要确保这些钱去了正确的地方。

19268
31:30:07.589 --> 31:30:12.684
所以审计对于我们项目的生命周期是非常重要的。

19269
31:30:12.684 --> 31:30:18.738
我们希望人们进行同行评审，我们希望人们评审我们的代码，以确保一切看起来都很好。

19270
31:30:18.738 --> 31:30:23.096
现在，当我们将代码发送给审计时，我们不应该只是说，嘿，这是我们的代码。

19271
31:30:23.096 --> 31:30:25.014
你能检查一下吗确保它是好的。

19272
31:30:25.113 --> 31:30:32.892
这不会给审计员足够的信息，他们需要能够非常容易地知道你的代码是做什么的，如何使用它，以及你在寻找什么。

19273
31:30:32.892 --> 31:30:38.621
因为审计员不会是那种，这种故障保险，如果你的代码很糟糕，他们就会抓住一切。

19274
31:30:38.621 --> 31:30:40.096
审核员也是人。

19275
31:30:40.096 --> 31:30:42.014
审计员也会漏掉一些东西。

19276
31:30:42.113 --> 31:30:44.435
另外，不要确保你的代码没有bug。

19277
31:30:45.113 --> 31:30:48.795
审计是针对代码库的以安全性为重点的同行评审。

19278
31:30:49.113 --> 31:30:54.822
当您将代码发送给审核时，您希望确保尽可能多地帮助审核人员。

19279
31:30:54.822 --> 31:31:08.713
有一个惊人的推文线程来自Tinto，之前是Zeplin开放审查员，有大量的提示和技巧与审查员合作，我强烈建议你暂停视频，你点击这个链接，你阅读他的推文，因为他们是神奇的。

19280
31:31:08.713 --> 31:31:16.285
Openzeppelin有一个准备指南，试图帮助您确保您已经为审计做好了准备。

19281
31:31:16.285 --> 31:31:19.227
我们在GitHub存储库中有一个准备指南的链接。

19282
31:31:19.227 --> 31:31:34.800
它们的总结是向代码中添加注释，使用natspec(我们学习过它来记录函数，记录函数，记录函数)，测试，准备好与审计人员交谈，并准备好给他们充足的时间。

19283
31:31:34.800 --> 31:31:40.129
他们实际上是在你的代码上倾注了数周的时间，以确保没有任何错误。

19284
31:31:40.129 --> 31:31:44.629
如果你催促审计员，你就会得到一个匆忙的审计，他们就会错过一些东西。

19285
31:31:44.629 --> 31:31:46.566
让我们来谈谈审计过程。

19286
31:31:46.566 --> 31:31:48.790
在审计过程中是这样的。

19287
31:31:48.790 --> 31:31:50.677
首先，他们会给你做检查。

19288
31:31:50.677 --> 31:32:05.827
这是order总是要做的第一步在这里，他们会发现他们有足够的代码覆盖率吗?一切都过去了吗?这些测试是做什么的?最优的功能是什么?在审核人员运行测试后，他们会阅读规范或运行你的文档。

19289
31:32:05.827 --> 31:32:11.371
然后他们会运行一些快速的工具，像Slither, linters和静态分析。

19290
31:32:11.371 --> 31:32:16.354
这将是我们将要讨论的关于滑动和静态分析的首要内容之一。

19291
31:32:16.354 --> 31:32:24.541
因此，静态分析就是运行一些程序来阅读所有代码并查找常见错误的过程。

19292
31:32:24.541 --> 31:32:28.790
最流行的静态分析工具之一是这个叫做Slither的工具。

19293
31:32:28.790 --> 31:32:32.128
这是我们要做的第一件事。

19294
31:32:32.128 --> 31:32:34.289
现在让我们打开VS代码。

19295
31:32:34.289 --> 31:32:38.738
我们将创建一个新的目录，叫做hardhats security, FCC。

19296
31:32:38.738 --> 31:32:40.863
我们会做的。

19297
31:32:40.863 --> 31:32:43.488
我们会讲代码期。

19298
31:32:43.488 --> 31:32:45.887
我们把它打开。

19299
31:32:45.887 --> 31:32:52.859
现在我想让你们做的是，不要新建一个文件夹，所有的东西都要克隆，我的心有安全FCC。

19300
31:32:52.859 --> 31:33:00.051
我们用gitclone，我们的net security FCC空间，然后加一个句点将它克隆到这个目录。

19301
31:33:00.113 --> 31:33:02.418
我们会得到像这样的东西。

19302
31:33:04.113 --> 31:33:11.401
我们已经有了几个不同的合同，每个合同都有不同的漏洞，其中一个将是糟糕的RNG。

19303
31:33:11.401 --> 31:33:18.488
这是一个使用块难度和消息点发送者从抽奖中随机挑选赢家的契约。

19304
31:33:18.488 --> 31:33:24.867
这并不是真正的随机，因为矿工可以影响块点难度，人们可以取消交易。

19305
31:33:24.867 --> 31:33:30.020
用这种方式创造随机性有许许多多不同的弱点。

19306
31:33:30.020 --> 31:33:44.703
我们也有这个液体池作为Oracle，两种最常见的攻击类型是可重入性，我们已经学习过Oracle操作攻击，幸运的是，我们已经教过分散的Oracle和使用链链接，这应该会使您更安全。

19307
31:33:44.703 --> 31:33:56.613
尤其在这一部分，我要反复强调这些，请，请，请，如果你们上这门课，请不要制定一个受这些影响的协议，我会觉得我让你们失望了。

19308
31:33:56.613 --> 31:34:03.389
如果你构建的协议中使用了一些被操纵的集中oracle，或者你构建的协议中存在重入攻击。

19309
31:34:03.389 --> 31:34:07.359
我要给你们展示的工具将会帮助你们实现可重入性。

19310
31:34:07.359 --> 31:34:12.822
我讲的链条应该能教会你们如何不被甲骨文操纵。

19311
31:34:12.822 --> 31:34:19.384
在这个合同中，我们使用流动性池作为Oracle这是一种高级的挑战。

19312
31:34:19.384 --> 31:34:26.779
这是一个极简的去中心化交易的例子，在这里人们可以买卖和交换不同的资产。

19313
31:34:26.779 --> 31:34:32.366
用这个单一交换，得到掉期价格是个糟糕的主意。

19314
31:34:32.366 --> 31:34:35.731
因为这是一个价格单一的单一协议。

19315
31:34:35.731 --> 31:34:42.513
这个协议的价格是一个集中的位置，我们不希望从一个集中的交易所获得我们的价格。

19316
31:34:42.513 --> 31:34:44.413
我们想从许多交易所得到它。

19317
31:34:44.413 --> 31:34:57.500
从一个去中心化的交易所获得任何资产的价格不是去中心化的，而是有人在操纵市场做一些疯狂的高级违抗会毁掉你的资产价格的事情。

19318
31:34:57.500 --> 31:35:02.854
因此，从一个集中的地方获取资产价格是一个糟糕的想法。

19319
31:35:02.854 --> 31:35:04.983
我们这里有一个变质的代理人。

19320
31:35:05.113 --> 31:35:10.553
这里的问题是它是双初始化的，我们不能保证契约已经初始化了。

19321
31:35:10.553 --> 31:35:13.079
这里有一个经典的重入问题。

19322
31:35:13.079 --> 31:35:22.548
然后我们有然后我们有一个保险库在那里用链子存储着一些密码我们祈祷没有人读这个密码来解锁它。

19323
31:35:22.548 --> 31:35:31.955
我们将对这些契约进行静态分析，看看静态分析是否能发现其中的一些不好之处。

19324
31:35:32.113 --> 31:35:41.065
首先，我们将使用一种工具，就像我说的，叫做slither slither工具是由Crytek团队，也就是三叶虫团队发明的。

19325
31:35:41.065 --> 31:35:45.199
三叶虫绝对是我最喜欢的审计师之一。

19326
31:35:45.199 --> 31:35:51.822
我非常喜欢这个团队推出的所有工具，他们为我们提供了开源的安全工具，比如分割器。

19327
31:35:51.822 --> 31:35:56.596
现在要开始使用Slither，我们实际上需要首先安装Python。

19328
31:35:56.596 --> 31:35:58.774
你也可以用Docker运行它。

19329
31:35:58.774 --> 31:36:02.284
但我将首先向您展示如何使用Python。

19330
31:36:02.284 --> 31:36:05.988
如果你之前没有使用过Python，你可以来学习Python。

19331
31:36:05.988 --> 31:36:09.629
org/downloads和从网站下载Python，你就会知道你做对了。

19332
31:36:09.629 --> 31:36:13.313
你可以运行python的三个破折号版本，像这样。

19333
31:36:13.313 --> 31:36:17.293
或者如果你有一个较老版本的Python，你可以运行Python的破折号版本。

19334
31:36:17.293 --> 31:36:27.686
安装Python之后，还应该安装这个名为PIP 3的工具，可以通过运行PIP 3的破折号版本或PIP破折号版本进行检查。

19335
31:36:27.686 --> 31:36:35.065
我们还需要安装这个sock select包以防我们使用奇怪的solidity版本来安装。

19336
31:36:35.113 --> 31:36:40.029
我们运行PIP 3，安装sock select，像这样。

19337
31:36:40.113 --> 31:36:42.925
然后我们可以做袜子，选择，使用。

19338
31:36:45.113 --> 31:36:48.078
结实度或滑动度的版本。

19339
31:36:49.113 --> 31:36:53.145
那些工具，你可以像这样运行PIP 3安装slither分析器。

19340
31:36:53.145 --> 31:36:56.467
你可以将slither安装到你的Python环境中。

19341
31:36:56.467 --> 31:36:57.918
我不打算播了，因为已经播过了。

19342
31:36:57.918 --> 31:37:03.145
你也可以学习如何用Docker来做这些我们稍后会学习如何用Docker来做这些。

19343
31:37:03.145 --> 31:37:07.467
在我们的包json中，我们在包中有命令脚本。

19344
31:37:07.467 --> 31:37:12.218
JSON来运行Slither，你就会知道你已经正确安装了Slither。

19345
31:37:12.218 --> 31:37:19.063
如果你能运行Slither，破折号可以帮助你得到这样的输出。

19346
31:37:19.063 --> 31:37:24.224
现在我们可以使用slither在合约文件夹上运行通过运行这个大命令。

19347
31:37:24.224 --> 31:37:25.564
我们用Slither。

19348
31:37:25.564 --> 31:37:40.293
我们想在。/契约上运行它，我们需要告诉它它有一些诗篇映射，每次它看到打开的Zeppelin，它应该使用Node module / open Zeppelin每次它看到引入的chain link节点模块/ chain link。

19349
31:37:40.293 --> 31:37:42.985
我将从我们的包json中读取。

19350
31:37:42.985 --> 31:37:49.768
我们排除了一些它运行的函数排除了建设者忽略的函数，但不用太担心。

19351
31:37:49.768 --> 31:38:02.840
我们实际上只是通过首先运行纱线来安装我们所有的包。

19352
31:38:03.113 --> 31:38:06.451
在我们安装好所有的包之后，我们就可以运行yarn Slither了。

19353
31:38:06.451 --> 31:38:09.790
或者您可以复制粘贴slither命令并直接运行它。

19354
31:38:09.790 --> 31:38:15.819
现在我们会得到这个大量的输出，看起来像这样，有些红，有些绿。

19355
31:38:15.819 --> 31:38:24.282
让我们来看看这里到底发生了什么，我们阅读Slither的方式，它会列出一些有问题的行，然后是对该问题的引用。

19356
31:38:24.282 --> 31:38:27.253
每一个都用一条新线隔开。

19357
31:38:27.253 --> 31:38:30.937
这是一个例外的部分，等等。

19358
31:38:31.113 --> 31:38:37.231
因此，如果我们在这里得到一个红色，这意味着有一个高影响的问题，我们一定要解决。

19359
31:38:37.231 --> 31:38:49.279
它甚至还附带了一个参考链接，我们可以复制粘贴到浏览器中，看看是什么问题，还有滑动工具中关于问题的更多信息以及如何改正。

19360
31:38:49.279 --> 31:38:53.695
我们可以看到它抓住了我们变形契约的问题。

19361
31:38:53.695 --> 31:38:56.492
它表示变形契约从未初始化。

19362
31:38:56.492 --> 31:38:59.149
这是用在这里的变形网点扼杀。

19363
31:38:59.149 --> 31:39:13.490
这是一个大问题的原因，如果我们去我们的变形合同外底，如果我们部署这个合同，其他人可能会初始化这个代码，成为所有者，然后在我们甚至有机会之前自动杀死它。

19364
31:39:13.490 --> 31:39:18.497
这实际上是过去发生过的事情，导致了大量的问题。

19365
31:39:18.497 --> 31:39:23.588
所以如果我们在终点站看到红色，这意味着嘿，大问题，我们绝对应该去看看。

19366
31:39:23.588 --> 31:39:25.809
现在这里将会有大量的绿色。

19367
31:39:25.809 --> 31:39:30.350
这些探测器可能是低冲击的，它们可能没问题。

19368
31:39:30.350 --> 31:39:36.959
事实上，我们可以看到，它甚至只是在这里调用一些打开，说，嘿，我们看到一些内联汇编。

19369
31:39:36.959 --> 31:39:39.806
内联汇编有点可怕，也许不要用它。

19370
31:39:39.806 --> 31:39:56.613
所以你可以把绿色看作是一种警告这对任何东西产生影响的可能性很低，但你可能想要检查一下，我们使用了不同版本的固体，也就是说，嘿，有几个不同版本的固体可能是你需要记住的，也许你应该使用相同版本的固体。

19371
31:39:56.613 --> 31:39:58.398
我们允许旧版本。

19372
31:39:58.398 --> 31:40:03.096
这就是为什么在这门课中，我们一直用8。

19373
31:40:03.096 --> 31:40:04.870
因为0,8。

19374
31:40:04.870 --> 31:40:06.001
4和零点8。

19375
31:40:06.001 --> 31:40:08.834
7被认为是更稳定的固体版本。

19376
31:40:08.834 --> 31:40:14.557
如果你在外面使用版本，这里会说，嘿，也许你想使用不同的版本。

19377
31:40:14.557 --> 31:40:21.066
这里有一些标记，比如，你应该把变量设为常量因为它永远不会变，这很好。

19378
31:40:21.113 --> 31:40:28.246
使用有太多数字的文字，说，嘿，这个有点难读，也许你搞砸了一些0，响亮的旧版本。

19379
31:40:28.246 --> 31:40:32.050
ether store。withdraw的可重入性是什么。

19380
31:40:32.050 --> 31:40:39.703
所以只要运行这个滑动工具，我们就能在合同中发现一个可重入性漏洞，这太棒了。

19381
31:40:39.703 --> 31:40:46.313
所以运行静态分析至少发现了变形契约中的两个巨大漏洞。

19382
31:40:46.313 --> 31:41:01.800
在我们的可重入契约中，它没有捕捉到单一流动性池中涉及的问题，或者糟糕的RNG，这就是为什么我们不想只依赖slither因为它不会捕捉到所有的问题，但它会捕捉到很多主要的漏洞。

19383
31:41:01.800 --> 31:41:06.413
这就是我们如何使用Slither，至少从中间堆栈点开始。

19384
31:41:06.413 --> 31:41:08.909
太好了，我们刚学会如何和斯利瑟合作。

19385
31:41:08.909 --> 31:41:12.779
这是我们审计过程中最重要的工具之一。

19386
31:41:12.779 --> 31:41:23.988
这将被认为是静态分析的快速工具，运行测试，linters等等，也是静态分析的类型。

19387
31:41:24.113 --> 31:41:38.398
在我们运行一个这样的工具后，我们进入一些手动分析，我们自己手动遍历代码，也许我们会运行一些较慢的工具，比如kitna Manta Corp，和其他符号执行工具。

19388
31:41:38.398 --> 31:41:43.630
符号执行是模拟在区块链上执行事务的地方。

19389
31:41:43.630 --> 31:41:48.269
我们将要使用的其中一个符号执行工具是这个kidmin工具。

19390
31:41:48.269 --> 31:41:52.062
再说一次，这是一个用于做模糊测试的工具。

19391
31:41:52.113 --> 31:42:02.851
在编程中，模糊测试是一种自动化软件测试技术，它涉及提供无效的、意外的或随机的数据作为计算机程序的输入。

19392
31:42:02.851 --> 31:42:10.048
在我们的很多代码中，我们经常会让人们以我们从未想过的方式与它们进行交互。

19393
31:42:10.114 --> 31:42:17.469
所以我们希望能够为我们的测试提供随机数据和随机信息，看看是否发生了我们没有预料到的奇怪的事情。

19394
31:42:17.469 --> 31:42:31.614
所以我们实际上可以在我们的硬帽项目中建立我们自己的模糊测试并运行这些模糊测试，我实际上创建了一个模糊测试的示例，我们用固体写我们的模糊测试，而不是用JavaScript写测试。

19395
31:42:31.614 --> 31:42:34.621
举个例子，我们建立了一个保险库合同。

19396
31:42:34.621 --> 31:42:43.180
我们认为，乍一看，没有人能够知道密码，也没有人能够解锁这份合同。

19397
31:42:43.180 --> 31:42:48.941
显然，我们知道这很荒谬，因为我们知道任何人都可以读取存储变量中的任何东西。

19398
31:42:48.941 --> 31:42:52.614
所以我们知道这应该失败，但是编写一个测试可能很难。

19399
31:42:52.614 --> 31:42:54.780
来发现这实际上会失败。

19400
31:42:54.780 --> 31:43:03.458
测试这个的一个好方法是向这个解锁函数发送大量随机字节32对象，看看我们是否可以解锁它。

19401
31:43:03.458 --> 31:43:06.002
我们可以写一个模糊测试来做到这一点。

19402
31:43:06.002 --> 31:43:10.574
所以在我的保险库，绒毛测试。索尔，我们要进口保险库的外底。

19403
31:43:10.574 --> 31:43:17.304
我们说保险库模糊测试是保险库密码是123 ASD 123。

19404
31:43:17.304 --> 31:43:29.294
现在我们有一个叫kid和test find password的函数，它会向保险库发送大量随机数据试图使s locked等于false。

19405
31:43:29.294 --> 31:43:34.872
我们在这里说s locked = true，我们的第一个测试将尝试使s locked = false。

19406
31:43:34.872 --> 31:43:43.310
现在我们可以只安装kitna，但在这一点上，从trail of bits调出我们的安全工具箱是一个好主意。

19407
31:43:43.310 --> 31:43:58.050
踪迹比特有一个叫做eath安全工具箱的包，它把所有的安全工具都放在一个容器里kitna, Ethan o Manta core, slither, rattle，还有不那么智能合约，所有这些都放在同一个包里。

19408
31:43:58.114 --> 31:43:59.725
现在来使用这个工具箱。

19409
31:44:01.114 --> 31:44:01.399
安装。

19410
31:44:03.114 --> 31:44:07.914
有时这可能是课程中最难的部分安装这些包。

19411
31:44:07.914 --> 31:44:10.447
我们留下了Doc的。docker的链接。

19412
31:44:10.447 --> 31:44:25.429
com，让Docker安装Docker，真正使用这些工具，你只需要点击其中一个适合你安装Docker的，一旦我们安装了Docker，我们可以通过从Docker的GitHub中拉下它来运行E安全工具箱。

19413
31:44:25.429 --> 31:44:35.364
我们会用到一大堆Docker命令，我在这里就不解释了因为这不是Docker课程，如果你想了解安全方面的东西，我绝对建议你在后面阅读所有这些命令。

19414
31:44:35.364 --> 31:44:38.535
我们会留下很多链接让你了解更多。

19415
31:44:38.535 --> 31:44:41.801
在JSON与这一课相关联的包中。

19416
31:44:41.801 --> 31:44:44.852
我们甚至可以在这里进行设置。

19417
31:44:44.852 --> 31:44:49.012
我们可以运行yarn toolbox，它会像这样运行Docker命令。

19418
31:44:49.012 --> 31:44:51.534
所以我要运行纱线工具箱。

19419
31:44:51.534 --> 31:44:59.780
如果你得到这样的东西说不能连接到Docker守护进程Docker守护进程在运行，因为我需要我的Docker守护进程在运行。

19420
31:44:59.780 --> 31:45:01.876
自从我安装了Docker桌面。

19421
31:45:01.876 --> 31:45:06.605
我需要有我的Docker引擎启动和运行，它实际上正在工作。

19422
31:45:06.605 --> 31:45:07.780
再来处理这个。

19423
31:45:07.780 --> 31:45:14.786
需要进行大量的Docker设置和配置，关于如何开始使用Docker，我将留下大量的说明。

19424
31:45:14.786 --> 31:45:16.286
一旦我们设置好Docker。

19425
31:45:16.286 --> 31:45:24.419
现在我们可以运行纱线工具箱，它将把我们插入一个新的外壳，以使用三叶虫自带的任何工具。

19426
31:45:24.419 --> 31:45:27.914
现在我们的保险库模糊测试也有一个配置。

19427
31:45:27.914 --> 31:45:32.419
这是亚莫的档案里面有我们实施绑架的所有理由。

19428
31:45:32.419 --> 31:45:37.637
它有一个测试限制，也就是有多少次不同的运行，我们应该做一个时间延迟，块延迟。

19429
31:45:37.637 --> 31:45:39.779
当然，这里还有一些重新映射。

19430
31:45:39.779 --> 31:45:46.395
这个较暗的shell已经安装了安全工具，比如Kidner测试。

19431
31:45:46.395 --> 31:46:12.415
所以我们要对SRC进行kinah测试斜杠合同斜杠测试斜杠模糊斜杠故障模糊测试。Sol破折号合同将是保险库模糊测试，破折号配置将是SRC斜杠合同斜杠测试斜杠嗡斜杠配置。Yamo。

19432
31:46:12.415 --> 31:46:20.724
我们继续，在这里按回车键，它会说，分析合约，它会给我们一个像这样的输出，它会给我们一个像这样的输出。

19433
31:46:20.724 --> 31:46:26.825
它说的是，它找到了一个用例，它可以使s locked = false。

19434
31:46:26.825 --> 31:46:29.717
用例是123 ASD 123。

19435
31:46:29.717 --> 31:46:36.133
几秒钟后，它就找到了解锁合同的密码。

19436
31:46:36.133 --> 31:46:47.064
这就是为什么运行一个模糊测试器可以如此强大，我们认为我们的合同是安全的，但它立即找到了密码，这意味着任何人都可以立即找到密码。

19437
31:46:47.114 --> 31:46:50.163
这将是一个指标，表明我们正在做的不是一个好的设置。

19438
31:46:50.163 --> 31:46:52.130
按CTRL C退出。

19439
31:46:52.130 --> 31:46:55.562
为了结束Docker设置，我们写入exit。

19440
31:46:55.562 --> 31:47:06.542
现在，我将在与这节课相关的GitHub回购中留下大量与绑匪合作和与这个模糊测试器合作的链接，这样你就可以继续学习更多内容。

19441
31:47:06.542 --> 31:47:12.796
现在，如果你从这一整部分中拿走任何东西，它应该是这里。

19442
31:47:12.796 --> 31:47:15.133
两个最常见的任务是可重入的。

19443
31:47:15.133 --> 31:47:16.694
看，和Oracle操作。

19444
31:47:16.694 --> 31:47:28.075
如果你不打算做审计员，你只想把东西部署到主网上，在你部署任何东西之前，你应该做的绝对最小值就是一直运行Slither。

19445
31:47:28.075 --> 31:47:32.606
然后手动查找Oracle操作和可重入性攻击。

19446
31:47:32.606 --> 31:47:37.043
如果您在代码中看到您正在获取定价信息。

19447
31:47:37.114 --> 31:47:47.061
价格是我们人类分配给某个东西的数据如果你从一个集中的位置获得定价信息，重新考虑一下场景，重新考虑你在那里做什么。

19448
31:47:47.061 --> 31:47:53.327
如果您得到的是一个随机数，如果您正在从一个集中的位置进行任何类型的自动化，请重新考虑并改变您的策略。

19449
31:47:53.327 --> 31:47:59.114
创建链链接Oracle网络是为了防止像这样的黑客攻击。

19450
31:47:59.114 --> 31:48:05.063
因此，在部署任何带有任何类型安全保证的主要内容之前，请记住这些。

19451
31:48:05.114 --> 31:48:05.692
好了,好了。

19452
31:48:08.114 --> 31:48:09.828
了解了一些慢速工具。

19453
31:48:11.114 --> 31:48:11.850
公司或Mythix。

19454
31:48:14.114 --> 31:48:17.372
蝠鲼公司将是三叶虫团队的另一个工具。

19455
31:48:17.372 --> 31:48:29.818
Mythix实际上是共识团队提供的一种智能合约安全服务，你把他们在云端运行的机器人发送到你的合约上，它会执行一些自动流程来检查安全漏洞。

19456
31:48:29.818 --> 31:48:30.898
这是一项付费服务。

19457
31:48:30.898 --> 31:48:36.060
但如果你要部署一个价值数百万美元的协议，只花区区1000美元。

19458
31:48:36.114 --> 31:48:38.664
花1000美元来确保它真的有用。

19459
31:48:39.114 --> 31:48:42.442
你想要投资的东西肯定是正确的。

19460
31:48:42.442 --> 31:48:45.645
在你完成整个过程之后。

19461
31:48:45.645 --> 31:48:49.814
你们这些智能合约开发人员和审计员应该讨论他们的发现。

19462
31:48:49.814 --> 31:48:55.176
如果有任何问题，请重复这些步骤，在做出更改后再次重复所有步骤。

19463
31:48:55.176 --> 31:48:59.442
因此，审计过程和确保合同安全是一个漫长的过程。

19464
31:48:59.442 --> 31:49:07.017
之后，审计员会写一份报告，包括他们在你的合同中发现的所有安全漏洞。

19465
31:49:07.017 --> 31:49:20.844
通常情况下，你会将报告组织在一个像这样的图表中，你会将发生几率高、影响大的问题标记为影响大的关键问题，而可能性低的问题则标记为中等，等等。

19466
31:49:20.844 --> 31:49:27.277
我还会留下一些例子两个过去做过的审计这样你们就可以看一看。

19467
31:49:27.277 --> 31:49:30.243
您可以看到对某些代码的全面审计是什么样的。

19468
31:49:30.243 --> 31:49:37.372
我们会研究openzeppelin sigma '和三叶虫，因为我认为这三种是这个领域中最好的审计师。

19469
31:49:37.372 --> 31:49:38.561
现在在GitHub回购。

19470
31:49:38.561 --> 31:49:45.377
我们还有很多其他工具可以使用Mythix、秘银醚play和共识安全工具。

19471
31:49:45.377 --> 31:49:53.581
如果您想了解更多关于安全和审计的知识，我强烈建议您在本课程结束后玩以太网游戏和该死的脆弱的Defy。

19472
31:49:53.581 --> 31:49:56.573
这两款游戏将教会你很多关于安全的知识。

19473
31:49:56.573 --> 31:50:00.780
我们会测试排骨我们会测试你在这门课上学到的所有东西。

19474
31:50:00.780 --> 31:50:04.014
还有一些我非常喜欢的关于安全的博客。

19475
31:50:04.014 --> 31:50:06.385
其中一个是失事点新闻。

19476
31:50:06.385 --> 31:50:15.045
他们列出了这个领域中曾经发生过的一些最大的黑客事件，然后回顾了这些事件发生的原因。

19477
31:50:15.045 --> 31:50:17.447
他们通常也会把它做得很有趣。

19478
31:50:17.447 --> 31:50:19.980
我们这里也有一些文章。

19479
31:50:20.114 --> 31:50:40.046
其中一个最好的地方是已知的攻击部分，他们讨论了可重入性、Oracle操作、前端运行和其他大量的攻击，这些是你在编写智能合约时绝对应该注意的，我们不打算在这里详细介绍，因为他们在这些资源中做了很好的解释，你也应该看看这篇文章，因为我帮助编写了它。

19480
31:50:40.046 --> 31:50:41.507
所以一定要去看看。

19481
31:50:41.507 --> 31:50:43.867
我们还有更多的章节列表。

19482
31:50:43.867 --> 31:50:46.991
这将是一个有生命的部分。

19483
31:50:46.991 --> 31:50:48.239
所以请随意。

19484
31:50:48.239 --> 31:51:01.736
如果您将来发现了更多的东西，请随意发出pull请求并更新这个存储库，以便其他人可以学习和了解更多关于安全和审计的知识，并提供关于糟糕代码是什么样子以及如何捕获它们的契约示例。

19485
31:51:01.736 --> 31:51:03.584
尽管这是我们最快的环节之一。

19486
31:51:03.584 --> 31:51:10.041
从视频的角度来看，这将是你职业生涯中最长的一段。

19487
31:51:10.114 --> 31:51:13.065
安全是您始终要考虑的问题。

19488
31:51:13.114 --> 31:51:16.066
而且总是会有新的工具来帮助安全。

19489
31:51:16.114 --> 31:51:17.980
而且总是会有新的东西需要思考。

19490
31:51:18.114 --> 31:51:26.303
尽管我们讲得很快，我还是百分之百希望你们暂停这个视频，尝试一下我们在这里用过的一些工具。

19491
31:51:26.303 --> 31:51:31.004
然后甚至可以试着说出你自己的弱点。

19492
31:51:31.004 --> 31:51:59.694
话是这么说，你刚刚完成了这门关于智能合约、实体、web 3和区块链开发的大型硕士课程的最后一部分，你应该为自己感到无比自豪。

19493
31:51:59.694 --> 31:52:19.622
恭喜你，我和网络三社区作为一个整体想祝贺你完成了这个绝对怪物的教程，你已经做了一个惊人的工作，走到今天。

19494
31:52:19.622 --> 31:52:22.221
看着我现在和你说话。

19495
31:52:22.221 --> 31:52:26.780
如果你还没有完成这门课程，在来这里之前回去完成它。

19496
31:52:26.780 --> 31:52:29.726
我们在这段旅程中学到了很多。

19497
31:52:29.726 --> 31:52:42.307
我可以从我的灵魂深处说，我很高兴有你在web三空间，智能合约空间，区块链空间，加密货币空间，我们很高兴你在这里。

19498
31:52:42.307 --> 31:52:47.796
我真的很期待在区块链社区的webthree中见到你。

19499
31:52:47.796 --> 31:52:53.283
很多人会问，我该去哪里?我并没有这些新发现的知识。

19500
31:52:53.283 --> 31:52:57.047
我武装了智能的web三开发空间。

19501
31:52:57.047 --> 31:53:02.533
好吧，我在GitHub存储库中留下了一些链接，以引导您进入下一步。

19502
31:53:02.533 --> 31:53:09.482
但现在你能为自己做的最大的一件事就是把你学到的东西应用到其他地方。

19503
31:53:09.482 --> 31:53:15.130
这可能是你们在这方面学过的最全面的课程。

19504
31:53:15.130 --> 31:53:19.458
你可以去一个又一个教程，一个又一个训练营，随你便。

19505
31:53:19.458 --> 31:53:24.300
但在某些时候，你必须做出跳跃，你必须投入进去。

19506
31:53:24.300 --> 31:53:27.775
无论如何，这也是大部分增长的来源。

19507
31:53:27.775 --> 31:53:31.864
所以，如果你在这里，想知道下一步该去哪里，那就去参加黑客马拉松吧。

19508
31:53:31.864 --> 31:53:41.355
开始在GitHub上讨论问题，开始申请拨款，开始申请工作，然后说，我上了帕特里克的大课。

19509
31:53:41.355 --> 31:53:46.677
这是我的GitHub回购，在个人项目上工作，在别人的项目上工作。

19510
31:53:46.677 --> 31:53:51.989
接受这些知识并应用它们，你将会遇到的挑战和你将面对的挑战。

19511
31:53:51.989 --> 31:54:00.047
在没有我的帮助下做一件事，你学到的东西会比在这里学到的多十倍。

19512
31:54:00.114 --> 31:54:03.355
我已经尽我所能把你带进这个兔子洞了。

19513
31:54:03.355 --> 31:54:07.709
现在就看你走出去用它做点什么了。

19514
31:54:07.709 --> 31:54:10.598
谢谢所有帮助我开设这门课的人。

19515
31:54:10.598 --> 31:54:12.580
谢谢你们上这门课。

19516
31:54:12.580 --> 31:54:20.114
我很高兴能在社区中看到你们，看到你们创造了什么，看到我们能用这项技术创造了什么。
