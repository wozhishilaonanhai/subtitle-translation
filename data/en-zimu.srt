1
00:00:00.000 --> 00:00:02.290
If you're interested in learning
about blockchain, this is the

2
00:00:02.290 --> 00:00:06.695
course for you. Patrick Collins
is a veteran software engineer

3
00:00:06.695 --> 00:00:10.104
and longtime finance industry
developer. Be sure to leave a

4
00:00:10.104 --> 00:00:12.128
comment with something you
learned from this course.

5
00:00:12.128 --> 00:00:17.175
Welcome to the ultimate solidity
smart contract and blockchain

6
00:00:17.175 --> 00:00:20.209
Developer course, JavaScript
addition, we recently did a

7
00:00:20.209 --> 00:00:24.246
version of this video in Python
that has over 2 million views

8
00:00:24.246 --> 00:00:28.281
right now making it the most
watched smart contract tutorial

9
00:00:28.281 --> 00:00:31.310
on the planet. We've learned a
ton from doing that first

10
00:00:31.310 --> 00:00:34.340
course. And if you love the
Python language, definitely be

11
00:00:34.340 --> 00:00:36.365
sure to check that one out.
We've taken all the learnings

12
00:00:36.365 --> 00:00:39.397
we've got from making that first
course, wrapped it up and put it

13
00:00:39.397 --> 00:00:42.427
into this JavaScript video for
you. If you're looking to get

14
00:00:42.427 --> 00:00:46.462
started in web three blockchain
smart contracts or any of these

15
00:00:46.462 --> 00:00:50.502
terms, this is the course for
you. And it's for anybody and

16
00:00:50.502 --> 00:00:53.535
everybody, no matter your
experience level in programming

17
00:00:53.535 --> 00:00:57.572
or in blockchain. Ideally, you
know, a little bit of JavaScript

18
00:00:57.572 --> 00:01:00.608
before starting this. But if you
don't, no worries, we will help

19
00:01:00.608 --> 00:01:03.633
you along the way. And in case
you do want to learn a little

20
00:01:03.633 --> 00:01:05.658
bit of JavaScript before
starting here, there are some

21
00:01:05.658 --> 00:01:09.693
fantastic courses on Free Code
Camp to learn more, but you

22
00:01:09.693 --> 00:01:12.726
absolutely don't have to. And
really, any experience with any

23
00:01:12.726 --> 00:01:15.755
object oriented programming
language will work, right. So if

24
00:01:15.755 --> 00:01:18.784
you're brand new to coding, or
if you're brand new to

25
00:01:18.784 --> 00:01:22.819
blockchain, this is exactly
where you should be. And if you

26
00:01:22.819 --> 00:01:24.847
already know a lot about
blockchain or coding, this

27
00:01:24.847 --> 00:01:29.891
course will give you even more
deep fundamentals on the space.

28
00:01:29.891 --> 00:01:32.928
So welcome to the edge of the
rabbit hole. So for those of you

29
00:01:32.928 --> 00:01:35.953
who don't know, my name is
Patrick Collins. I'm a smart

30
00:01:35.953 --> 00:01:38.983
contract engineer, developer
advocate on the chain link

31
00:01:38.983 --> 00:01:43.103
protocol. And I live in breed
smart contracts. I also make

32
00:01:43.103 --> 00:01:46.106
YouTube videos on my own
channel, medium Twitter threads

33
00:01:46.106 --> 00:01:49.109
and more. teaching people about
smart contracts about coding and

34
00:01:49.109 --> 00:01:53.113
about this new technology. I
love helping developers learn,

35
00:01:53.113 --> 00:01:56.116
grow and learn about this new
Advent. That's blockchain and

36
00:01:56.116 --> 00:01:59.119
smart contracts. And I'll be
taking you on your journey to

37
00:01:59.119 --> 00:02:03.123
becoming a blockchain expert and
Wizard of the smart contract

38
00:02:03.123 --> 00:02:06.126
developing world. And even if
you don't want to become a

39
00:02:06.126 --> 00:02:10.130
developer, the first section our
blockchain basics, will give you

40
00:02:10.130 --> 00:02:14.133
a lot of fundamental knowledge
about how blockchain and smart

41
00:02:14.133 --> 00:02:18.137
contracts, even work. I am so
excited for you to be here. And

42
00:02:18.137 --> 00:02:21.141
I hope you enjoy the journey.
This is a data dump, passion

43
00:02:21.141 --> 00:02:24.144
educational project of
everything I've learned working

44
00:02:24.144 --> 00:02:28.148
in this space. And I am 100%
certain that if you follow

45
00:02:28.148 --> 00:02:31.151
along, you'll come out the other
side of this, armed with the

46
00:02:31.151 --> 00:02:35.155
knowledge to be a positive force
in this incredible industry,

47
00:02:35.155 --> 00:02:38.158
solidity and smart contract
developers are massively in

48
00:02:38.158 --> 00:02:43.163
demand with an average salary of
being around $145,000 a year,

49
00:02:43.163 --> 00:02:47.166
there is massive economic
opportunity from learning this

50
00:02:47.166 --> 00:02:50.170
course. And this technology has
the ability to revolutionize

51
00:02:50.170 --> 00:02:54.174
everything that we interact
with, and you can be one of the

52
00:02:54.174 --> 00:02:58.178
pioneers ushering in this new
age. In our courses. We already

53
00:02:58.178 --> 00:03:01.181
have a track record of giving
people these educational needs

54
00:03:01.181 --> 00:03:04.184
and sending them into their
careers in the blockchain and

55
00:03:04.184 --> 00:03:08.188
smart contract space. And we are
going to give you all of the

56
00:03:08.188 --> 00:03:11.191
cutting edge tools and how to
use them including working with

57
00:03:11.191 --> 00:03:16.196
things like D phi NF TS Dows,
ERC 20s upgradable, smart

58
00:03:16.196 --> 00:03:19.199
contracts and more. We're going
to teach you the skills

59
00:03:19.199 --> 00:03:22.202
necessary to build defy
applications like Ave synthetics

60
00:03:22.202 --> 00:03:27.207
and compound, billion dollar
decentralized applications, or

61
00:03:27.207 --> 00:03:30.210
massively successful NFT
projects like crypto punks, or

62
00:03:30.210 --> 00:03:35.214
board apes. Dow is like maker
Dow or developer, Dow and any of

63
00:03:35.214 --> 00:03:38.217
the amazing things you've seen
in the cryptocurrency world. In

64
00:03:38.217 --> 00:03:40.220
learning these skills, you will
have all these economic

65
00:03:40.220 --> 00:03:44.224
opportunities at your fingertips
and the ability to be a pioneer

66
00:03:44.224 --> 00:03:48.227
in completely changing the way
we interact with each other. In

67
00:03:48.227 --> 00:03:51.230
a fundamental way. Building
decentralized smart contract

68
00:03:51.230 --> 00:03:54.234
applications is building a world
that's more accountable a world

69
00:03:54.234 --> 00:03:58.238
with unbreakable promises, a
faster, more efficient,

70
00:03:58.238 --> 00:04:00.240
financially free world, a
collaborative community,

71
00:04:00.240 --> 00:04:04.243
combining the prowess of
philosophy and technology into a

72
00:04:04.243 --> 00:04:08.247
new system. We'll learn more
about the purpose and the value

73
00:04:08.247 --> 00:04:11.251
of smart contracts and
decentralized applications in

74
00:04:11.251 --> 00:04:14.254
lesson one of this course, and
why they're so exciting. Finish

75
00:04:14.254 --> 00:04:17.257
this course. And you'll be
ready. So again, I want to give

76
00:04:17.257 --> 00:04:20.260
a major thank you and a major
kudos to you because you've

77
00:04:20.260 --> 00:04:24.264
taken the first step to enter
this realm. So welcome to Web

78
00:04:24.264 --> 00:04:26.266
three. Welcome to the
blockchain. Welcome to smart

79
00:04:26.266 --> 00:04:29.269
contracts. And I'll see you at
the bottom of the rabbit hole.

80
00:04:29.269 --> 00:04:33.273
So let's jump into some best
practices for this course so

81
00:04:33.273 --> 00:04:36.276
that you can learn most
effectively and learn with this

82
00:04:36.276 --> 00:04:40.280
course as best you can.

83
00:04:40.280 --> 00:04:41.281
You do not want to skip

84
00:04:41.281 --> 00:04:44.284
this part. It'll help you solve
80% of your issue. Now, while

85
00:04:44.284 --> 00:04:48.287
going through this course be
100% certain to follow along

86
00:04:48.287 --> 00:04:51.291
with a GitHub repository
associated with this course we

87
00:04:51.291 --> 00:04:54.294
have a link in the description
of this video for you to

88
00:04:54.294 --> 00:04:58.297
absolutely click on follow along
have open in a tab as you're

89
00:04:58.297 --> 00:05:01.300
doing this because it has all
the code Sam polls, timestamps a

90
00:05:01.300 --> 00:05:04.304
community to interact with and
more, it is going to be your

91
00:05:04.304 --> 00:05:07.307
Bible for watching this course.
And yes, we have a Discussions

92
00:05:07.307 --> 00:05:10.310
tab. This Discussions tab is a
place where you can ask

93
00:05:10.310 --> 00:05:13.313
questions, engage with other
developers who are going through

94
00:05:13.313 --> 00:05:17.317
this course as well. Get some
help, and etc. Be sure to say

95
00:05:17.317 --> 00:05:20.319
hello and meet other like minded
individuals like yourselves.

96
00:05:20.319 --> 00:05:22.322
Now, blockchain and smart
contracts move really quickly.

97
00:05:22.322 --> 00:05:25.325
And things are constantly being
updated. So to make sure you're

98
00:05:25.325 --> 00:05:28.327
always up to date with the
latest, when I open up some

99
00:05:28.327 --> 00:05:31.330
documentation, try to open up
the documentation for yourself

100
00:05:31.330 --> 00:05:34.334
as well. And maybe even have the
code sample next to you. And as

101
00:05:34.334 --> 00:05:37.337
you're writing code, be sure to
refer back to make sure that you

102
00:05:37.337 --> 00:05:39.339
are keeping pace, and then you
have the most up to date

103
00:05:39.339 --> 00:05:43.342
samples, sometimes technology
might change, and there might be

104
00:05:43.342 --> 00:05:46.345
a way to do something a little
bit better. So we have this file

105
00:05:46.345 --> 00:05:49.348
called chronological updates, be
sure that this is the first

106
00:05:49.348 --> 00:05:51.351
place to check when you run into
an issue to see if maybe

107
00:05:51.351 --> 00:05:54.354
something was updated that you
missed, it'll be chronologically

108
00:05:54.354 --> 00:05:57.356
ordered. So it's easier to find
updates. Basically, this is to

109
00:05:57.356 --> 00:06:00.360
say, always refer back to the
GitHub repo first. And if you do

110
00:06:00.360 --> 00:06:02.362
to find a mistake, or something
isn't working the way you

111
00:06:02.362 --> 00:06:05.364
expected, jump into the
conversation, leave a

112
00:06:05.364 --> 00:06:09.369
discussion, leave an issue, ask
questions here, take breaks, I

113
00:06:09.369 --> 00:06:13.372
cannot tell you how many people
tried rushing through our entire

114
00:06:13.372 --> 00:06:15.375
first course in one setting and
didn't retain as much

115
00:06:15.375 --> 00:06:18.378
information, your brain
remembers information much

116
00:06:18.378 --> 00:06:21.381
better if you take breaks. So
every 25 minutes or half an

117
00:06:21.381 --> 00:06:24.384
hour, maybe take a five minute
walk. And then every two hours

118
00:06:24.384 --> 00:06:27.386
take a much longer break. And if
you really want to make sure

119
00:06:27.386 --> 00:06:29.389
something drills in, try to go
back and reflect on what you did

120
00:06:30.389 --> 00:06:32.392
for the lesson prior before
continuing to the next lesson.

121
00:06:32.392 --> 00:06:36.396
And at the same time, though,
learn at your own speed. There

122
00:06:36.396 --> 00:06:41.400
is no right speed for this
course. If it takes you a day, a

123
00:06:41.400 --> 00:06:45.404
week, a month or even a year, it
doesn't matter. Learn at the

124
00:06:45.404 --> 00:06:48.408
pace that's right for you, you
can change the speed at which I

125
00:06:48.408 --> 00:06:52.411
talked using the little gear
icon in the YouTube video. If

126
00:06:52.411 --> 00:06:55.415
I'm talking way too fast for
you, you can slow me down. And

127
00:06:55.415 --> 00:06:59.419
at the same time, if I'm talking
too slow, you can speed me up,

128
00:06:59.419 --> 00:07:02.422
you also don't even have to go
in order. You can bounce around

129
00:07:02.422 --> 00:07:05.424
topic to topic, if you don't
want to learn full stack, you

130
00:07:05.424 --> 00:07:07.427
can skip the full stack stuff.
If you don't want to learn

131
00:07:07.427 --> 00:07:10.429
coding, we can skip the coding
stuff. If you only want to go to

132
00:07:10.429 --> 00:07:13.432
the advanced stuff, go to the
advanced stuff. You are highly

133
00:07:13.432 --> 00:07:16.436
encouraged to pause, come back
and ask questions. The

134
00:07:16.436 --> 00:07:18.438
blockchain and smart contract
world is incredibly

135
00:07:18.438 --> 00:07:22.442
collaborative. So be sure to use
tools like the discussions tab

136
00:07:22.442 --> 00:07:26.446
of our GitHub repository, asking
questions on Stack Overflow and

137
00:07:26.446 --> 00:07:30.450
Aetherium Stack Exchange and
tagging relative technologies,

138
00:07:30.450 --> 00:07:33.452
making issues on different
GitHub repositories that you're

139
00:07:33.452 --> 00:07:36.455
working with jumping into
discord, Reddit, Twitter, and

140
00:07:36.455 --> 00:07:39.458
any other place that these
communities and technologies are

141
00:07:39.458 --> 00:07:41.461
congregating. And the reason I'm
putting so much emphasis on

142
00:07:41.461 --> 00:07:44.463
these community aspects is that
becoming a solidity and

143
00:07:44.463 --> 00:07:47.467
blockchain engineer is so much
more than just the solidity

144
00:07:47.467 --> 00:07:50.470
part. Being comfortable with all
the tools in this space,

145
00:07:51.470 --> 00:07:55.474
including the ones to get help
and to give help are essential

146
00:07:55.474 --> 00:07:58.477
to being successful here.
Networking is massive, and it

147
00:07:58.477 --> 00:08:01.480
makes it a ton of fun. As you
continue your journey and you

148
00:08:01.480 --> 00:08:03.483
get more advanced and you're
looking for places to meet other

149
00:08:03.483 --> 00:08:07.486
developers. Hackathons are one
of the best places to connect

150
00:08:07.486 --> 00:08:10.489
with other engineers, the
chainlink hackathons eath,

151
00:08:10.489 --> 00:08:13.493
global hackathons, and Dev folio
hackathons are three great

152
00:08:13.493 --> 00:08:16.496
hackathon suites to connect. And
no matter where you are in your

153
00:08:16.496 --> 00:08:19.499
journey, they're great places to
flex what you've learned.

154
00:08:19.499 --> 00:08:22.501
Alright, so those are some of
the best practices for this

155
00:08:22.501 --> 00:08:26.506
course. You're standing at the
edge of the rabbit hole, looking

156
00:08:26.506 --> 00:08:30.509
down, peering into the world of
web three and smart contracts

157
00:08:30.509 --> 00:08:33.512
and blockchain. If you're like
me want to jump in, you want to

158
00:08:33.512 --> 00:08:37.516
keep going further. Let's begin
our journey into the world of

159
00:08:37.516 --> 00:08:40.519
smart contracts. And it all
starts with the blockchain

160
00:08:40.519 --> 00:08:43.523
basics.

161
00:08:43.523 --> 00:08:44.524
Now, I know you're excited

162
00:08:44.524 --> 00:08:47.527
to get coding. But before we
jump in, we want to learn some

163
00:08:47.527 --> 00:08:50.530
of the fundamentals of
blockchains and smart contracts.

164
00:08:50.530 --> 00:08:53.533
Understanding these ideologies
and these basics are so

165
00:08:53.533 --> 00:08:56.536
important, because it'll dictate
how you architect your

166
00:08:56.536 --> 00:08:59.539
decentralized applications,
learning the basics of

167
00:08:59.539 --> 00:09:02.542
blockchain and solidity is
critical. But if you already

168
00:09:02.542 --> 00:09:05.544
know the basics of a blockchain,
feel free to jump into lesson

169
00:09:05.544 --> 00:09:08.547
two.

170
00:09:08.547 --> 00:09:09.548
Now, since you're here,

171
00:09:09.548 --> 00:09:12.552
you've probably heard of Bitcoin
before. Bitcoin was one of the

172
00:09:12.552 --> 00:09:16.555
first protocols to use this
revolutionary technology called

173
00:09:16.555 --> 00:09:19.558
blockchain. The Bitcoin white
paper was created by the pseudo

174
00:09:19.558 --> 00:09:23.562
anonymous Satoshi Nakamoto, and
outlined how Bitcoin can make

175
00:09:23.562 --> 00:09:26.566
peer to peer transactions. In a
decentralized network. This

176
00:09:26.566 --> 00:09:30.569
network was powered by
cryptography, decent Tality, and

177
00:09:30.569 --> 00:09:34.573
allowed people to engage in
censorship resistant finance, in

178
00:09:34.573 --> 00:09:37.576
a decentralized manner due to
its features, which we'll talk

179
00:09:37.576 --> 00:09:40.580
about in a little bit. People
took to this as a superior

180
00:09:40.580 --> 00:09:44.584
digital store of value, a better
store of value over something

181
00:09:44.584 --> 00:09:47.586
like gold, for example, and
that's why you'll also hear

182
00:09:47.586 --> 00:09:51.590
people commonly refer to it as a
digital gold similar to gold.

183
00:09:51.590 --> 00:09:54.594
There's a scarce amount or a set
amount of bitcoin available on

184
00:09:54.594 --> 00:09:57.597
the planet, only so much that
you can buy and sell. You can

185
00:09:57.597 --> 00:10:00.599
read more about the original
vision in the white A paper

186
00:10:00.599 --> 00:10:03.602
we've linked to the white paper
in the GitHub repo associated

187
00:10:03.602 --> 00:10:06.605
with this course. Now, this was
an insane breakthrough in a

188
00:10:06.605 --> 00:10:09.608
little bit, we're going to learn
exactly how this is all possible

189
00:10:09.608 --> 00:10:11.611
and how this actually works
under the hood. Some people

190
00:10:11.611 --> 00:10:15.614
though, saw this technology and
wanted to take it a little bit

191
00:10:15.614 --> 00:10:18.618
farther, and do even more with
this blockchain technology. And

192
00:10:18.618 --> 00:10:22.621
a few years later, a man named
Vitalik Buterin, released a

193
00:10:22.621 --> 00:10:26.626
white paper for a new protocol
named Aetherium, which use this

194
00:10:26.626 --> 00:10:30.629
same blockchain infrastructure
with an additional feature. And

195
00:10:30.629 --> 00:10:34.633
in 2015, him and a number of
other co founders released the

196
00:10:34.633 --> 00:10:37.636
project Aetherium, where people
could not only make

197
00:10:37.636 --> 00:10:40.639
decentralized transactions, but
decentralized agreements,

198
00:10:40.639 --> 00:10:43.643
decentralized organizations, and
all these other ways to interact

199
00:10:43.643 --> 00:10:46.646
with each other without a
centralized intermediary or

200
00:10:46.646 --> 00:10:50.649
centralized governing force.
Basically, their idea was to

201
00:10:50.649 --> 00:10:53.652
take this thing that made
Bitcoin so great, and add

202
00:10:53.652 --> 00:10:58.657
decentralized agreements to it,
or smart contracts. And in fact,

203
00:10:58.657 --> 00:11:00.660
technically, these smart
contracts weren't even really a

204
00:11:00.660 --> 00:11:05.664
new idea. Back in 1994, a man
named Nick Zabo, had actually

205
00:11:05.664 --> 00:11:08.667
originally come up with the idea
smart contracts are a set of

206
00:11:08.667 --> 00:11:12.671
instructions executed in a
decentralized autonomous way,

207
00:11:12.671 --> 00:11:16.675
without the need for a third
party or centralized body to run

208
00:11:16.675 --> 00:11:19.678
them. And they come to life on
these blockchains, or these

209
00:11:19.678 --> 00:11:22.681
smart contract platforms, like
Aetherium. And it's the smart

210
00:11:22.681 --> 00:11:24.684
contracts that are going to be
the core thing that we're going

211
00:11:24.684 --> 00:11:26.686
to be working on in this course,
and that we're going to be

212
00:11:26.686 --> 00:11:29.688
developing, you can think of
smart contracts in the same way

213
00:11:29.688 --> 00:11:31.691
you think of traditional
contracts or traditional

214
00:11:31.691 --> 00:11:34.694
agreements. They're just a set
of instructions between parties,

215
00:11:34.694 --> 00:11:37.697
except instead of written on pen
and paper or typed up in

216
00:11:37.697 --> 00:11:41.700
Microsoft Word, they are written
in code and embodied on these

217
00:11:41.700 --> 00:11:44.703
decentralized blockchain
platforms. And that's also where

218
00:11:44.703 --> 00:11:47.706
they're executed. Instead of
being executed by the two

219
00:11:47.706 --> 00:11:49.708
parties, or three parties, or
however many parties that are

220
00:11:49.708 --> 00:11:53.712
involved. This removes this
centralized issue that we'll

221
00:11:53.712 --> 00:11:55.714
talk about more in a bit. This
is one of the main

222
00:11:55.714 --> 00:11:58.717
differentiators between the
Etherium protocol and the

223
00:11:58.717 --> 00:12:01.720
Bitcoin protocol. It's these
smart contracts. Now,

224
00:12:01.720 --> 00:12:04.724
technically, bitcoin does have
smart contracts, but they're

225
00:12:04.724 --> 00:12:08.727
intentionally Turing incomplete,
which means they don't have all

226
00:12:08.727 --> 00:12:10.729
the functionality that a
programming language would give

227
00:12:10.729 --> 00:12:13.732
them. This was an intentional
move by Bitcoin developers.

228
00:12:13.732 --> 00:12:17.736
Bitcoin developers viewed
Bitcoin as a store of value

229
00:12:17.736 --> 00:12:21.740
versus Aetherium, developers
viewed Aetherium as both a store

230
00:12:21.740 --> 00:12:25.744
of value and a utility to
facilitate these decentralized

231
00:12:25.744 --> 00:12:28.747
agreements. Now, the smart
contracts on blockchains alone

232
00:12:28.747 --> 00:12:31.750
are absolutely incredible.
However, they do come with a

233
00:12:31.750 --> 00:12:34.753
huge issue. If we want these
digital agreements to replace

234
00:12:34.753 --> 00:12:37.756
the agreements in our everyday
lives, they probably are going

235
00:12:37.756 --> 00:12:40.759
to need data from the real world
blockchains by themselves

236
00:12:40.759 --> 00:12:44.763
actually can't interact with and
can't read or listen to data

237
00:12:44.763 --> 00:12:47.766
from the real world. This is
what's known as the Oracle

238
00:12:47.766 --> 00:12:50.769
problem. These blockchains are
deterministic systems and

239
00:12:50.769 --> 00:12:52.771
they're deterministic on
purpose. And we'll learn about

240
00:12:52.771 --> 00:12:55.775
more about how that works in the
sessions to come. So everything

241
00:12:55.775 --> 00:12:58.777
that happens with them happens
in their little world. But if

242
00:12:58.777 --> 00:13:00.779
they're going to be these
agreements, they need external

243
00:13:00.779 --> 00:13:03.782
data and they need external
computation. And this is where

244
00:13:03.782 --> 00:13:06.785
Oracle's come into play.
Oracle's are any device that

245
00:13:06.785 --> 00:13:09.788
delivers data to these
decentralized blockchain or runs

246
00:13:09.788 --> 00:13:12.791
external computation. However,
if we want our applications to

247
00:13:12.791 --> 00:13:17.796
stay truly decentralized, we
can't work with a single Oracle

248
00:13:17.796 --> 00:13:20.799
or a single data provider or a
single source that's running

249
00:13:20.799 --> 00:13:24.803
these external computations. So
we need a decentralized Oracle

250
00:13:24.803 --> 00:13:26.806
network. Similar to our
decentralized blockchain

251
00:13:26.806 --> 00:13:29.808
network, you're on chain logic
will be decentralized, but you

252
00:13:29.808 --> 00:13:32.811
also need your off chain data
and computation be

253
00:13:32.811 --> 00:13:36.815
decentralized, combining this on
chain decentralized logic. With

254
00:13:36.815 --> 00:13:39.818
this off chain, decentralized
data and decentralized

255
00:13:39.818 --> 00:13:42.821
computation gives rise to
something called hybrid smart

256
00:13:42.821 --> 00:13:45.825
contracts. And most of the
biggest protocols that we

257
00:13:45.825 --> 00:13:49.829
interact with today are some
type of hybrid smart contract or

258
00:13:49.829 --> 00:13:52.831
interact with hybrid smart
contracts. To some extent, this

259
00:13:52.831 --> 00:13:55.834
is where the protocol chaining
comes into play. It is a

260
00:13:55.834 --> 00:13:58.837
modular, decentralized Oracle
network that can both bring

261
00:13:58.837 --> 00:14:02.841
external data and external
computation into our smart

262
00:14:02.841 --> 00:14:05.844
contracts to make sure they're
decentralized end to end, while

263
00:14:05.844 --> 00:14:09.848
giving them the feature richness
that we need for our agreements.

264
00:14:09.848 --> 00:14:13.852
chainlink allows for us to get
data to upkeeps, get random

265
00:14:13.852 --> 00:14:16.855
numbers or really customize our
smart contracts in any

266
00:14:16.855 --> 00:14:18.858
meaningful way. Now, throughout
the course, we're going to use

267
00:14:18.858 --> 00:14:22.861
the terminology smart contract.
However, whenever we say smart

268
00:14:22.861 --> 00:14:26.865
contract, we're often using it a
little interchangeably with

269
00:14:26.865 --> 00:14:28.868
hybrid smart contracts, but just
know that when we say hybrid

270
00:14:28.868 --> 00:14:32.871
smart contract, we're talking
specifically about smart

271
00:14:32.871 --> 00:14:35.874
contracts that have some type of
off chain component. Now since

272
00:14:35.874 --> 00:14:37.877
the theorems release, a number
of different block chains or

273
00:14:37.877 --> 00:14:41.880
smart contract platforms have
come to light such as avalanche

274
00:14:41.880 --> 00:14:45.884
polygon, Phantom harmony, and
more. For the majority of this

275
00:14:45.884 --> 00:14:47.886
course, we're going to be
assuming that we're going to be

276
00:14:47.886 --> 00:14:50.889
deploying to the Ethereum
network. However, everything

277
00:14:50.889 --> 00:14:53.892
that we learned here is going to
be applicable to the vast

278
00:14:53.892 --> 00:14:56.895
majority of the blockchains out
there like polygon, avalanche,

279
00:14:56.895 --> 00:14:59.898
Phantom harmony, etc, and
understanding everything from a

280
00:14:59.898 --> 00:15:01.900
theory and funding mentals will
give you the skills that you

281
00:15:01.900 --> 00:15:05.904
need to switch chains very
easily with literally one line

282
00:15:05.904 --> 00:15:08.907
of code. So don't worry about
learning a specific tool or with

283
00:15:08.907 --> 00:15:12.911
a specific chain because most of
them work together seamlessly.

284
00:15:12.911 --> 00:15:15.914
Now, there are a couple of smart
contract platforms that don't

285
00:15:15.914 --> 00:15:18.917
use solidity. But still learning
the fundamentals here will make

286
00:15:18.917 --> 00:15:21.920
you much better at those as
well. And the Etherium by far

287
00:15:21.920 --> 00:15:24.923
has the most value locked and is
the most used blockchain and

288
00:15:24.923 --> 00:15:26.925
smart contract platform out
there. You'll also hear those

289
00:15:26.925 --> 00:15:29.928
two terms used a little bit
interchangeably as well.

290
00:15:29.928 --> 00:15:31.930
Sometimes they'll say smart
contract platform, sometimes

291
00:15:31.930 --> 00:15:34.933
they'll say blockchain, they
kind of mean the same thing.

292
00:15:34.933 --> 00:15:37.936
Obviously, blockchains could
mean store of value and smart

293
00:15:37.936 --> 00:15:41.940
contract platform, but you get
the idea. Similarly, chainlink

294
00:15:41.940 --> 00:15:44.943
is the most popular and powerful
decentralized Oracle network is

295
00:15:44.943 --> 00:15:46.946
the one that we're going to be
focusing on for this course as

296
00:15:46.946 --> 00:15:50.949
well. chainlink is also
blockchain agnostic. So to work

297
00:15:50.949 --> 00:15:54.953
on Aetherium, avalanche, Polygon
Solana Terra, or really any

298
00:15:54.953 --> 00:15:56.955
other blockchain out there. Now,
throughout this course, you'll

299
00:15:56.955 --> 00:16:00.959
hear the term DAP or
decentralized Protocol, or smart

300
00:16:00.959 --> 00:16:03.962
contract Protocol, or
decentralized application. And

301
00:16:03.962 --> 00:16:06.965
they all kind of mean the same
thing. A decentralized

302
00:16:06.965 --> 00:16:08.968
application is usually the
combination of many smart

303
00:16:08.968 --> 00:16:11.970
contracts. And when we get into
solidity, you'll see what a

304
00:16:11.970 --> 00:16:14.973
singular smart contract really
looks like. And like I said,

305
00:16:14.973 --> 00:16:17.976
learning all these core
fundamentals will make you a

306
00:16:17.976 --> 00:16:20.979
better solidity and a better
smart contract developer, you'll

307
00:16:20.979 --> 00:16:23.983
also hear the term web three a
lot in this video. And in the

308
00:16:24.983 --> 00:16:26.985
industry, web three is the idea
that blockchain and smart

309
00:16:26.985 --> 00:16:30.989
contracts are the next iteration
of the web web one being this

310
00:16:30.989 --> 00:16:34.993
permissionless open source world
with static content, web two

311
00:16:34.993 --> 00:16:37.996
being the permissioned web with
dynamic content, but all the

312
00:16:37.996 --> 00:16:41.100
agreements and logic runs off of
centralized servers where they

313
00:16:41.100 --> 00:16:44.100
control your information. And
then web three comes back to the

314
00:16:44.100 --> 00:16:48.100
permissionless web. But once
again, with dynamic content, and

315
00:16:48.100 --> 00:16:50.100
instead of centralized servers,
running your logic,

316
00:16:50.100 --> 00:16:54.101
decentralized networks, run the
logic creating these censorship

317
00:16:54.101 --> 00:16:58.101
resistant agreements, that the
smart contracts enable is also

318
00:16:58.101 --> 00:17:01.102
generally accompanied by the
idea that the users own the

319
00:17:01.102 --> 00:17:04.102
protocols that they work with,
and it's an ownership economy.

320
00:17:04.102 --> 00:17:06.102
You'll see what I mean later in
this course. And we've talked a

321
00:17:06.102 --> 00:17:08.102
lot about the history and about
the high level of these

322
00:17:09.102 --> 00:17:12.103
protocols and of the smart
contracts and what they can do.

323
00:17:12.103 --> 00:17:15.103
But what do these smart
contracts really mean? What is

324
00:17:15.103 --> 00:17:18.103
it when I say trust, minimize
agreements or unbreakable

325
00:17:18.103 --> 00:17:23.104
promises? What is the real value
add of these smart contracts?

326
00:17:23.104 --> 00:17:25.104
Before we look under the hood,
take a peek at how this all

327
00:17:25.104 --> 00:17:29.104
works. From a technical
standpoint. Let's learn what all

328
00:17:29.104 --> 00:17:32.105
the value of this is. What is
the purpose of us building all

329
00:17:32.105 --> 00:17:35.105
these technologies? Have you
taken this course? What problem

330
00:17:35.105 --> 00:17:38.105
does this technology solve? In
my mind, a technology is really

331
00:17:38.105 --> 00:17:41.106
only as good as the problem that
it solves. If it doesn't solve a

332
00:17:41.106 --> 00:17:45.106
problem, then why bother Mark
contracts, Blockchain web three

333
00:17:45.106 --> 00:17:48.106
cryptocurrencies, those are all
just different words that

334
00:17:48.106 --> 00:17:52.107
encapsulate the idea of what
we're doing in such a unique

335
00:17:52.107 --> 00:17:55.107
paradigm. I think the easiest
way to sum up what these smart

336
00:17:55.107 --> 00:17:59.107
contracts do is that they create
trust minimized agreements. And

337
00:17:59.107 --> 00:18:02.108
if you might be scratching your
head to that. A much easier way

338
00:18:02.108 --> 00:18:06.108
to think about it is just that
give rise to unbreakable

339
00:18:06.108 --> 00:18:10.108
promises. Yes, you heard that
right. Unbreakable agreements

340
00:18:10.108 --> 00:18:13.109
and promises. Additionally, they
give rise to speed, efficiency

341
00:18:13.109 --> 00:18:17.109
and transparency, and a number
of other things. I made a video

342
00:18:17.109 --> 00:18:21.110
pretty recently about exactly
this. So let's dive in and take

343
00:18:21.110 --> 00:18:24.110
a listen to the purpose the
undeniable value

344
00:18:24.110 --> 00:18:30.110
of smart contracts
cryptocurrencies, fundamentally

345
00:18:30.110 --> 00:18:33.111
re landscape markets and
agreements as we know them.

346
00:18:33.111 --> 00:18:36.111
Unfortunately, you've probably
only been bombarded with people

347
00:18:36.111 --> 00:18:38.111
screaming about empties and
money. Now, some of the memes

348
00:18:38.111 --> 00:18:41.111
are fun, but let's forget the
bullet and get down to the

349
00:18:41.111 --> 00:18:44.112
essence of the space. If you're
already in web three. This is

350
00:18:44.112 --> 00:18:47.112
the video to send to your
friends to explain why you're so

351
00:18:47.112 --> 00:18:50.112
excited about this space and
explain why we're here. And then

352
00:18:50.112 --> 00:18:53.113
if you're not into crypto,
you've come to the right place.

353
00:18:53.113 --> 00:18:55.113
And yes, there are fun memes and
markets and there's some money

354
00:18:55.113 --> 00:18:58.113
stuff in there all these things.
But outside of all that the

355
00:18:58.113 --> 00:19:02.114
purpose of blockchains relates
to the age old elementary school

356
00:19:02.114 --> 00:19:07.114
unbreakable, promise the pinky
swear, let's get Froggy. Nearly

357
00:19:07.114 --> 00:19:10.114
everything you do in life is the
result of an agreement or a

358
00:19:10.114 --> 00:19:14.115
contract. Your chair was the
result of an agreement to buy

359
00:19:14.115 --> 00:19:16.115
and sell lumber to assemble and
sell the chair to a real tailor

360
00:19:16.115 --> 00:19:19.115
on Amazon. Then you made an
agreement to buy the chair for

361
00:19:19.115 --> 00:19:23.116
$40. The lights in your house
are powered by electricity,

362
00:19:23.116 --> 00:19:25.116
which is an agreement from you
and the electric company you

363
00:19:25.116 --> 00:19:28.116
agree to pay them in return
they'll keep the lights on the

364
00:19:28.116 --> 00:19:30.116
electricity they generate it's
agreements between them and

365
00:19:30.116 --> 00:19:33.117
engineers who built turbines to
generate the electricity with

366
00:19:33.117 --> 00:19:36.117
insurance you agree to pay some
amount of money to them every

367
00:19:36.117 --> 00:19:39.117
month, and in return, they will
do nothing or I mean, they'll

368
00:19:39.117 --> 00:19:43.118
cover your medical bills, almost
everything you do and everything

369
00:19:43.118 --> 00:19:46.118
you interact with is the result
of some form of agreement or

370
00:19:46.118 --> 00:19:50.118
contract in some aspect. Now,
agreements and contracts can

371
00:19:50.118 --> 00:19:54.119
feel kind of abstract and boring
to really grasp on to simplify,

372
00:19:54.119 --> 00:19:57.119
we can also refer to them as
promises. When you get an oil

373
00:19:57.119 --> 00:19:59.119
change. They're promising that
they will faithfully change your

374
00:19:59.119 --> 00:20:03.120
oil In exchange for money, when
you put money in the bank, they

375
00:20:03.120 --> 00:20:06.120
promise to keep it safe in
exchange for them to use your

376
00:20:06.120 --> 00:20:09.120
money to give out loans. When
you buy a lottery ticket, the

377
00:20:09.120 --> 00:20:12.121
lottery promises to give you a
fair chance at winning a ton of

378
00:20:12.121 --> 00:20:15.121
money in exchange for you buying
the ticket. Whenever you make

379
00:20:15.121 --> 00:20:19.121
one of these agreements. In a
way, you're asking them to pinky

380
00:20:19.121 --> 00:20:22.122
swear to not screw you over and
to treat you fairly. But this

381
00:20:22.122 --> 00:20:25.122
doesn't always happen. Let's
look at a real world example of

382
00:20:25.122 --> 00:20:28.122
someone breaking the Pinkie
swear back in the 80s and 90s,

383
00:20:28.122 --> 00:20:30.122
McDonald's ran a promotion for
people to win money by

384
00:20:30.122 --> 00:20:33.123
collecting McDonald's Monopoly
game cards. The idea was simple.

385
00:20:33.123 --> 00:20:36.123
You buy McDonald's in return,
you get a chance to win $1

386
00:20:36.123 --> 00:20:41.123
million. You can imagine
McDonald's literally going Hey,

387
00:20:41.123 --> 00:20:44.124
everybody, I promise you if you
buy our MC food and McNuggets,

388
00:20:44.124 --> 00:20:48.124
we'll give you a fair chance of
winning this money, we ended up

389
00:20:48.124 --> 00:20:50.124
breaking this promise, instead
of having a fair chance of

390
00:20:50.124 --> 00:20:56.125
winning your chance was in fact,
zero in the mid 90s. Between 13

391
00:20:56.125 --> 00:21:00.125
and $24 million went into the
pockets of not people playing

392
00:21:00.125 --> 00:21:03.126
the game, honestly. But a group
of corrupt insiders who had

393
00:21:03.126 --> 00:21:06.126
rigged the game, meaning that
when you played the McDonald's

394
00:21:06.126 --> 00:21:09.126
Monopoly game, you were buying
into a set of lies and promises

395
00:21:09.126 --> 00:21:13.127
that were 100% always going to
be broken. And the thing is, it

396
00:21:13.127 --> 00:21:16.127
doesn't really matter if this
was McDonald's fault or not.

397
00:21:16.127 --> 00:21:19.127
They were the ones making the
promises that they ultimately

398
00:21:19.127 --> 00:21:21.128
could not keep. Another way you
could think about it is that

399
00:21:21.128 --> 00:21:26.128
that's $24 million that they
essentially stole from you and I

400
00:21:26.128 --> 00:21:30.128
now if this system was deployed
on a blockchain was something

401
00:21:30.128 --> 00:21:34.129
called a smart contract, it
would have been impossible to

402
00:21:34.129 --> 00:21:39.129
defraud this $24 million due to
smart contracts being immutable,

403
00:21:39.129 --> 00:21:42.130
decentralized and transparent.
But I'll get back to that in a

404
00:21:42.130 --> 00:21:47.130
minute. In all the agreements
and contracts we make, imagine

405
00:21:47.130 --> 00:21:50.130
making a pinky swear with a 10
year old and imagining how that

406
00:21:51.130 --> 00:21:53.131
agreement would hold up. Hey,
buddy, Could you could you

407
00:21:53.131 --> 00:21:55.131
please keep my money safe? You
can play with it if you like,

408
00:21:55.131 --> 00:21:58.131
but just please have it when I
come back. Immediately. You

409
00:21:58.131 --> 00:22:01.131
might get that worrying feeling
in your chest, something might

410
00:22:01.131 --> 00:22:03.132
go wrong. This 10 year old might
lose your money. You might be

411
00:22:03.132 --> 00:22:07.132
thinking, how could I trust
them? Will they break their

412
00:22:07.132 --> 00:22:10.132
promise and this feeling of I
can't breathe because of

413
00:22:10.132 --> 00:22:14.133
untrustworthy situations
happens? Once all the time. Can

414
00:22:14.133 --> 00:22:16.133
I trust this used car
salesperson to give me a good

415
00:22:16.133 --> 00:22:20.133
car? Can I trust this tag that
says machine washable? Or will

416
00:22:20.133 --> 00:22:22.134
it make my shirt shrink? Will my
insurance provider break their

417
00:22:22.134 --> 00:22:25.134
promise of covering my medical
bills want to get hit by a bus?

418
00:22:25.134 --> 00:22:28.134
I'm Patrick promises he'll go on
a hike with me. Well, he

419
00:22:28.134 --> 00:22:32.135
actually I actually will. But
the issue with our current

420
00:22:32.135 --> 00:22:35.135
agreements and contracts is we
have to trust the people. We're

421
00:22:35.135 --> 00:22:38.135
making them to do the right
thing. However often they're

422
00:22:38.135 --> 00:22:41.136
actually incentivized to not do
the right thing. insurance

423
00:22:41.136 --> 00:22:44.136
doesn't want to pay out money.
Sometimes salespeople just want

424
00:22:44.136 --> 00:22:47.136
to get the shit off the shelves
and with my girlfriend, I

425
00:22:47.136 --> 00:22:50.136
promised to go on a hike. But I
need hikes. Where else is has

426
00:22:50.136 --> 00:22:52.137
happened. Now you might be
thinking okay, Patrick, this

427
00:22:52.137 --> 00:22:56.137
seems cool. But like Where has
this actually affected me? Well,

428
00:22:56.137 --> 00:22:59.137
the McDonald's lottery that we
just spoke about above during

429
00:22:59.137 --> 00:23:01.138
the Great Depression with the
run of the banks banks promised

430
00:23:01.138 --> 00:23:04.138
to keep our money safe and that
when we went back to go get it

431
00:23:04.138 --> 00:23:07.138
they would actually have the
money there. And well and behold

432
00:23:07.138 --> 00:23:10.138
there were times that they
didn't have the money they're

433
00:23:10.138 --> 00:23:14.139
just last year Robin Hood
painted this amazing picture. On

434
00:23:14.139 --> 00:23:17.139
user application we will give
you access to the markets we

435
00:23:17.139 --> 00:23:22.140
promise we will give you a
retail investor a fair chance of

436
00:23:22.140 --> 00:23:25.140
interacting with the world the
finance

437
00:23:25.140 --> 00:23:29.140
side, but not this asset. This
asset, this asset or this asset,

438
00:23:29.140 --> 00:23:33.141
the 2008 financial crisis
remember that shady deals behind

439
00:23:33.141 --> 00:23:35.141
closed doors combined with lies
about financial product brought

440
00:23:35.141 --> 00:23:39.141
the world to its economic knees,
how are you? hyperinflation in

441
00:23:39.141 --> 00:23:42.142
Zimbabwe hyperinflation in
Brazil, fair enough. US history

442
00:23:42.142 --> 00:23:46.142
is a relentless lesson of
trustworthy entities being

443
00:23:46.142 --> 00:23:49.142
notorious promised breakers and
we finally have a way to fix it

444
00:23:49.142 --> 00:23:52.143
with smart contracts. Now,
before I jump into smart

445
00:23:52.143 --> 00:23:56.143
contracts, a lot of people might
be thinking, hey, cool in all,

446
00:23:56.143 --> 00:23:59.143
however, we have systems in
place to protect against a lot

447
00:23:59.143 --> 00:24:03.144
of these things, which is true,
and which is great. And that is

448
00:24:03.144 --> 00:24:06.144
a very helpful step forward. But
these systems often breaks ones

449
00:24:06.144 --> 00:24:09.144
in 2008 Definitely didn't work.
The ones with the Robin Hood

450
00:24:09.144 --> 00:24:12.145
crisis definitely didn't work.
And even if these systems apply,

451
00:24:12.145 --> 00:24:15.145
and you go to court to try to
work them out, maybe you're in

452
00:24:15.145 --> 00:24:18.145
court for years before you
actually see a resolution and by

453
00:24:18.145 --> 00:24:23.146
that time, what you needed the
money for is longer. So what is

454
00:24:23.146 --> 00:24:26.146
this technology? What is this
tool that can fix this

455
00:24:26.146 --> 00:24:29.146
fundamental problem in our
agreements today, this tool is

456
00:24:30.146 --> 00:24:33.147
smart contracts and this tool is
what the blockchain was built

457
00:24:33.147 --> 00:24:36.147
for. Now, I'm gonna give you a
quick overview of what a smart

458
00:24:36.147 --> 00:24:39.147
contract is. However, I'm
leaving some links in the

459
00:24:39.147 --> 00:24:42.148
description for more in depth
explanations, but the basics of

460
00:24:42.148 --> 00:24:46.148
them is a smart contract is an
agreement contract or a set of

461
00:24:46.148 --> 00:24:49.148
instructions deployed on a
decentralized blockchain. And

462
00:24:49.148 --> 00:24:52.149
once the contract or set of
instructions is deployed, it

463
00:24:52.149 --> 00:24:56.149
cannot be altered, it
automatically executes and

464
00:24:56.149 --> 00:24:59.149
everyone can see the terms of
the agreement. Real basics of it

465
00:24:59.149 --> 00:25:02.150
is that the code is executed by
decentralized collective like a

466
00:25:02.150 --> 00:25:05.150
group of people but a group of
people running a certain

467
00:25:05.150 --> 00:25:08.150
software. This means that no one
person or entity can actually

468
00:25:08.150 --> 00:25:11.150
alter any of these agreements or
change the terms of the

469
00:25:11.150 --> 00:25:14.151
arrangement in these traditional
agreements. Whoever owns the

470
00:25:14.151 --> 00:25:17.151
contract, whoever owns the
execution of the contract can

471
00:25:17.151 --> 00:25:20.151
flip a switch and say, We're not
going to do that anymore. In

472
00:25:20.151 --> 00:25:24.152
smart contracts and web three in
blockchain, you no longer can do

473
00:25:24.152 --> 00:25:26.152
that. Typically, these smart
contracts are on a decentralized

474
00:25:26.152 --> 00:25:29.152
blockchain, and used in
combination with a decentralized

475
00:25:29.152 --> 00:25:32.153
Oracle network to get the real
world assets and information.

476
00:25:32.153 --> 00:25:35.153
And if these words sound like
I'm conjuring up a magic spell,

477
00:25:35.153 --> 00:25:37.153
well, again, check the links in
the description. If you want to

478
00:25:37.153 --> 00:25:39.153
learn more about the technical
implications. If you're not a

479
00:25:39.153 --> 00:25:41.154
technical person, then you're
not interested in getting into

480
00:25:41.154 --> 00:25:45.154
the nitty gritty, you can kind
of think of it like HTTPS, I bet

481
00:25:45.154 --> 00:25:48.154
the vast majority of you don't
even know what HTTPS stands for.

482
00:25:48.154 --> 00:25:51.154
And yet you use it every single
day whenever you log on to the

483
00:25:51.154 --> 00:25:54.155
internet. So how does this fix
the McDonald's Monopoly issue?

484
00:25:54.155 --> 00:25:57.155
In its traditional form, the
lottery was executed behind

485
00:25:57.155 --> 00:26:01.155
closed doors, somebody operated
and owned the code and the

486
00:26:01.155 --> 00:26:03.156
contracts and the agreements
that ran the lottery, and they

487
00:26:03.156 --> 00:26:07.156
had the power to alter it. And
nobody other than the people

488
00:26:07.156 --> 00:26:10.156
internal on the lottery could
audit this altering happening.

489
00:26:10.156 --> 00:26:14.157
Now if the code for this lottery
was deployed onto a blockchain,

490
00:26:15.157 --> 00:26:18.157
every time a hacker attempted to
alter it, everyone would be

491
00:26:18.157 --> 00:26:21.157
notified. Not only that, but you
couldn't even alter it, because

492
00:26:21.157 --> 00:26:23.158
the terms of a smart contract
cannot be altered. Once

493
00:26:23.158 --> 00:26:26.158
deployed, combine that smart
contract with a chain link VRF

494
00:26:26.158 --> 00:26:30.158
Oracle to get a verifiably
random number. And presto, you

495
00:26:30.158 --> 00:26:33.159
now have a perfectly
decentralized, unalterable

496
00:26:33.159 --> 00:26:36.159
agreement that is impossible to
hack commit fraud or manipulate

497
00:26:36.159 --> 00:26:41.159
we have just saved the public
between 13,000,020 $4 million

498
00:26:41.159 --> 00:26:46.160
just by fixing the issue of
trust. How does this fix Robin

499
00:26:46.160 --> 00:26:48.160
Hood? Well, the problem with
Robin Hood is already fixed.

500
00:26:48.160 --> 00:26:51.160
Right? Again, the problem is
that there's a centralized body

501
00:26:51.160 --> 00:26:55.161
that can flip a switch at any
time and say you can't access

502
00:26:55.161 --> 00:26:58.161
these markets anymore. We're
breaking our promise of actually

503
00:26:58.161 --> 00:27:01.161
giving you access to the
markets. This is already fixed

504
00:27:01.161 --> 00:27:03.162
with something called
decentralized exchanges. And

505
00:27:03.162 --> 00:27:07.162
these exist today, one of these
exchanges is one called uniswap.

506
00:27:07.162 --> 00:27:10.162
You can swap ERC 20 tokens,
which are kind of the equivalent

507
00:27:10.162 --> 00:27:13.163
of stocks, but some are some
are, it's a little confusing. I

508
00:27:13.163 --> 00:27:15.163
won't get into that here either.
But it doesn't have that

509
00:27:15.163 --> 00:27:19.163
centralized body that can flip a
switch and ruin access to the

510
00:27:19.163 --> 00:27:22.164
markets. And had these investors
been on a decentralized

511
00:27:22.164 --> 00:27:26.164
exchange, it would have saved
them hundreds of millions of

512
00:27:26.164 --> 00:27:29.164
dollars, and it would have
prevented fraudulent market

513
00:27:29.164 --> 00:27:31.164
manipulation. How does it fix
run of the banks with

514
00:27:31.164 --> 00:27:34.165
transparency built in an
automated solvency checks, you

515
00:27:34.165 --> 00:27:37.165
can build a bank like smart
contract that has insolvency

516
00:27:37.165 --> 00:27:39.165
checks built in that make it
impossible to get there and

517
00:27:39.165 --> 00:27:44.166
solve it means brokers any
agreement or any history lesson,

518
00:27:44.166 --> 00:27:47.166
where there was a trust
assumption that was broken,

519
00:27:47.166 --> 00:27:50.166
smart contracts can be applied
to and should be applied to,

520
00:27:50.166 --> 00:27:54.167
especially in a time where big
money runs, owns and controls

521
00:27:54.167 --> 00:27:58.167
everything, we desperately need
to move to a world where some

522
00:27:58.167 --> 00:28:01.167
self interested centralized
entity can't flip a switch and

523
00:28:01.167 --> 00:28:04.168
ruin people's access to the
services that they need. We can

524
00:28:04.168 --> 00:28:08.168
move away from a world that is
brand based to a world that is

525
00:28:08.168 --> 00:28:11.169
math based. Right now, if you
interact with a service that you

526
00:28:11.169 --> 00:28:15.169
don't like, or that they break
their promise, the only thing

527
00:28:15.169 --> 00:28:18.169
you can do is walk down the
street to the next service

528
00:28:18.169 --> 00:28:20.169
that's going to make the same
set of promises. And you have to

529
00:28:20.169 --> 00:28:23.170
hope and pray that they're
actually going to keep it we can

530
00:28:23.170 --> 00:28:26.170
move from that to a world where
we can just look at the map and

531
00:28:26.170 --> 00:28:29.170
say, oh, okay, one plus one
equals two. This is what this

532
00:28:29.170 --> 00:28:33.171
agreement is going to do for me
every single time guaranteed,

533
00:28:33.171 --> 00:28:36.171
because it's a decentralized
autonomous agent has no

534
00:28:36.171 --> 00:28:39.171
incentive to be evil, and
everything is transparent and

535
00:28:39.171 --> 00:28:42.172
out in the open of a big
company. And if it was better

536
00:28:42.172 --> 00:28:45.172
for me for one plus one to equal
three, maybe I would go behind

537
00:28:45.172 --> 00:28:48.172
some closed doors and flood some
numbers and come back and be

538
00:28:48.172 --> 00:28:51.172
like, hey, one plus one equals
three with smart contracts.

539
00:28:51.172 --> 00:28:55.173
That's impossible. Doing the
right thing is infrastructural

540
00:28:55.173 --> 00:28:58.173
now, given the choice between
two agreements, one where you

541
00:28:58.173 --> 00:29:01.173
have to trust a single
centralized entity that they're

542
00:29:01.173 --> 00:29:05.174
going to do the right thing for
you, versus a decentralized

543
00:29:05.174 --> 00:29:07.174
untampered double collective,

544
00:29:07.174 --> 00:29:09.174
which one you're gonna choose.
I'm picking the one that can't

545
00:29:09.174 --> 00:29:14.175
screw me over every single time.
For every agreement I can apply

546
00:29:14.175 --> 00:29:17.175
it to now this technology is
relatively new, but we have

547
00:29:17.175 --> 00:29:20.175
already seen it relandscaping
entire markets and continue to

548
00:29:20.175 --> 00:29:23.176
do so the traditional financial
world is already getting its

549
00:29:23.176 --> 00:29:27.176
lunch eaten by defy or
decentralized finance. There's

550
00:29:27.176 --> 00:29:30.176
already over $200 billion of
people's money in these

551
00:29:30.176 --> 00:29:34.177
protocols to help have a more
fair, more accountable, more

552
00:29:34.177 --> 00:29:37.177
transparent financial system.
This defy movement is one of the

553
00:29:37.177 --> 00:29:40.177
main reasons I got into this
space because we desperately

554
00:29:40.177 --> 00:29:44.178
need to move away from where we
are right now. And and people's

555
00:29:44.178 --> 00:29:47.178
chances for wealth being sucked
up by some group that's bending

556
00:29:47.178 --> 00:29:50.178
the rules in their favor and
smart contracts are our ticket

557
00:29:50.178 --> 00:29:53.179
to that better world. More and
more industries are also coming

558
00:29:53.179 --> 00:29:56.179
over to smart contracts and
blockchain because of all the

559
00:29:56.179 --> 00:29:59.179
innovations and because of all
the advantages that it has as we

560
00:29:59.179 --> 00:30:02.180
grow and as we get better as we
get closer to this vision of

561
00:30:02.180 --> 00:30:06.180
having this concept fulfilled,
trust minimized agreements.

562
00:30:06.180 --> 00:30:09.180
These smart contracts are
minimizing the trust that we

563
00:30:09.180 --> 00:30:12.181
need to give other people in
order for these agreements to be

564
00:30:12.181 --> 00:30:15.181
executed. If trust minimized
agreements is too confusing for

565
00:30:15.181 --> 00:30:18.181
you just say unbreakable
promises. Now I gotta be honest

566
00:30:18.181 --> 00:30:21.181
with you guys. blockchains and
smart contracts and

567
00:30:21.181 --> 00:30:23.182
cryptocurrencies can actually do
more than just trust, minimize

568
00:30:23.182 --> 00:30:26.182
agreements. They have security
benefits, uptime benefits,

569
00:30:26.182 --> 00:30:29.182
execution, speed benefits, and a
whole lot more. But it's a lot

570
00:30:29.182 --> 00:30:31.182
easier to just learn about one
and learn the other ones later,

571
00:30:31.182 --> 00:30:34.183
right. It's kind of like
sprinkles on top. So this is why

572
00:30:34.183 --> 00:30:36.183
we are here. This is why we're
building this future and this is

573
00:30:36.183 --> 00:30:42.184
why we are so excited about it.

574
00:30:42.184 --> 00:30:46.184
Even in just this introduction
part, we've learned a ton. So

575
00:30:46.184 --> 00:30:49.184
let's do a quick summary of what
we've learned so far. Bitcoin

576
00:30:49.184 --> 00:30:53.185
was the first protocol to take
this blockchain technology into

577
00:30:53.185 --> 00:30:55.185
the limelight and take these
cryptocurrencies into the

578
00:30:55.185 --> 00:30:59.185
mainstream Bitcoin is a sort of
digital gold or a store of value

579
00:30:59.185 --> 00:31:02.186
able to make transactions
between users in a decentralized

580
00:31:02.186 --> 00:31:05.186
manner. Aetherium and other
smart contract platforms take

581
00:31:05.186 --> 00:31:08.186
this blockchain technology one
step further, enabling people to

582
00:31:08.186 --> 00:31:11.186
make smart contracts and
decentralized trust minimized

583
00:31:11.186 --> 00:31:14.187
agreements, the smart contracts
and decentralized applications

584
00:31:14.187 --> 00:31:18.187
can access and interact with the
real world using something

585
00:31:18.187 --> 00:31:21.187
called decentralized Oracle
networks. chain link is a

586
00:31:21.187 --> 00:31:24.188
decentralized network that
allows us to build these hybrid

587
00:31:24.188 --> 00:31:28.188
smart contracts, which combines
our on chain logic with our off

588
00:31:28.188 --> 00:31:31.189
chain, decentralized data, and
decentralized computation,

589
00:31:31.189 --> 00:31:35.189
giving rise to our logic being
completely decentralized, and

590
00:31:35.189 --> 00:31:37.189
our data and external
computation being completely

591
00:31:37.189 --> 00:31:41.189
decentralized, giving us all the
features that traditional

592
00:31:41.189 --> 00:31:44.190
agreements and traditional
contracts have. Now these

593
00:31:44.190 --> 00:31:46.190
digital currencies like
Aetherium, and Bitcoin have

594
00:31:46.190 --> 00:31:50.190
value. Even without the smart
contract part, having a

595
00:31:50.190 --> 00:31:53.191
censorship resistant,
decentralized store of value is

596
00:31:53.191 --> 00:31:56.191
naturally powerful in its own
right, we have some links in the

597
00:31:56.191 --> 00:31:58.191
GitHub repository that will
teach you how this decentralized

598
00:31:58.191 --> 00:32:02.192
store of value flips traditional
finance on its head. And it's

599
00:32:02.192 --> 00:32:04.192
another one of the great reasons
for building smart contracts.

600
00:32:04.192 --> 00:32:08.192
But again, the easiest way to
boil it down is trust minimized

601
00:32:08.192 --> 00:32:11.192
agreements, or unbreakable
promises. But let's also go into

602
00:32:11.192 --> 00:32:13.193
some of these other features
that smart contracts have over

603
00:32:13.193 --> 00:32:16.193
our traditional environment. The
first feature, of course, is

604
00:32:16.193 --> 00:32:19.193
that they are decentralized. And
they have no centralized

605
00:32:19.193 --> 00:32:21.193
intermediary, the different
individuals that run one of

606
00:32:21.193 --> 00:32:24.194
these blockchains are known as
node operators. And it's the

607
00:32:24.194 --> 00:32:28.194
combination of all these 1000s
of node operators running the

608
00:32:28.194 --> 00:32:31.194
same software running these
algorithms running these smart

609
00:32:31.194 --> 00:32:34.195
contracts that make the network
decentralized. We'll dive deeper

610
00:32:34.195 --> 00:32:38.195
into how that works later. The
next feature is transparency and

611
00:32:38.195 --> 00:32:41.195
flexibility in these
decentralized networks. Since

612
00:32:41.195 --> 00:32:44.196
all these individual node
operators run the software,

613
00:32:44.196 --> 00:32:47.196
everybody can see everything
that's happening on chain,

614
00:32:47.196 --> 00:32:49.196
meaning there's no shady deals,
there's no weird things

615
00:32:49.196 --> 00:32:53.197
happening. Anything that's going
to be unfair, people will be

616
00:32:53.197 --> 00:32:56.197
able to see and just not use,
everybody has perfect

617
00:32:56.197 --> 00:33:00.197
information and has to play by
the same rules. Now

618
00:33:00.197 --> 00:33:03.198
additionally, this doesn't mean
that there's no privacy, the

619
00:33:03.198 --> 00:33:05.198
blockchain is pseudo anonymous,
meaning that you aren't

620
00:33:05.198 --> 00:33:09.198
necessarily tied to an identity
in real life, they also have the

621
00:33:09.198 --> 00:33:12.199
feature of speed and efficiency.
For those of you who have ever

622
00:33:12.199 --> 00:33:16.199
tried to do a bank transfer or
send money across seas, you

623
00:33:16.199 --> 00:33:19.199
know, it sometimes can take two
to three weeks, when in fact,

624
00:33:19.199 --> 00:33:22.200
all these banks are really doing
is basic math. They're

625
00:33:22.200 --> 00:33:26.200
subtracting money from your
balance and adding it to some

626
00:33:26.200 --> 00:33:29.200
other balance. Why does it take
so long, in the blockchain, all

627
00:33:29.200 --> 00:33:33.201
of these transactions happen
instantly. Another instance for

628
00:33:33.201 --> 00:33:35.201
those in the financial world
today know that clearing houses

629
00:33:35.201 --> 00:33:39.201
and settlement days can take a
long time. In the blockchain,

630
00:33:39.201 --> 00:33:42.202
there's no need for any of that,
because they happen instantly.

631
00:33:42.202 --> 00:33:45.202
This obviously is much quicker,
but it also makes for much more

632
00:33:45.202 --> 00:33:48.202
efficient interactions with each
other security and immutability.

633
00:33:48.202 --> 00:33:52.203
Again, immutable means that it
can't be changed. Once a smart

634
00:33:52.203 --> 00:33:56.203
contract is deployed, that's it,
whatever is in the code is going

635
00:33:56.203 --> 00:33:59.203
to be in the code forever, they
cannot be altered or tampered

636
00:33:59.203 --> 00:34:02.204
with in any way. This means that
the security is much easier.

637
00:34:02.204 --> 00:34:04.204
Whereas in a centralized world,
somebody can hack into the

638
00:34:04.204 --> 00:34:08.204
server, jump into the database
and change some numbers. You

639
00:34:08.204 --> 00:34:10.204
can't do that in the blockchain
world. And since it's

640
00:34:10.204 --> 00:34:14.205
decentralized, in order to hack
the blockchain, you'd have to

641
00:34:14.205 --> 00:34:17.205
take over half of the nodes as
opposed to in the centralized

642
00:34:17.205 --> 00:34:20.205
world, where you only have to
take over one in the regular

643
00:34:20.205 --> 00:34:23.206
world. If your computer and your
backup computer go down, all of

644
00:34:23.206 --> 00:34:27.206
your data is gone. In the
blockchain world, if your

645
00:34:27.206 --> 00:34:30.206
computer and your backup
computer go down, all your data

646
00:34:30.206 --> 00:34:34.207
is safe, because it's being run
on all these other decentralized

647
00:34:34.207 --> 00:34:38.207
nodes. And even if a few 100
nodes or a few 1000 nodes go

648
00:34:38.207 --> 00:34:41.207
down. It doesn't matter because
as long as one node has a copy

649
00:34:41.207 --> 00:34:45.208
of the blockchain, you're good
to go hacking a blockchain is

650
00:34:45.208 --> 00:34:49.208
nearly impossible, and leaps and
bounds more difficult than

651
00:34:49.208 --> 00:34:52.209
hacking a centralized server.
Not only that, but this is safer

652
00:34:52.209 --> 00:34:56.209
in the asset sense as well. All
you need to access your

653
00:34:56.209 --> 00:34:59.209
credentials and your information
in your assets is your private

654
00:34:59.209 --> 00:35:03.210
key. Which is basically your
password for all of this. And as

655
00:35:03.210 --> 00:35:05.210
we've discussed in the video,
the smart contracts remove this

656
00:35:06.210 --> 00:35:09.210
counterparty risk, remove this
centralized intermediary, remove

657
00:35:09.210 --> 00:35:13.211
these trust gateways that we
have to do in web two. When we

658
00:35:13.211 --> 00:35:15.211
engage with users and
individuals, they don't always

659
00:35:15.211 --> 00:35:19.211
have our best interests at heart
smart contracts, remove this

660
00:35:19.211 --> 00:35:21.211
counterparty risk, because once
one of these contracts is

661
00:35:21.211 --> 00:35:24.212
created, they can't go in and
they can't alter it. And they

662
00:35:24.212 --> 00:35:27.212
can't let greed or ego or
anything else, get the better of

663
00:35:27.212 --> 00:35:30.212
them and alter the terms of the
deal. And as we said, this gives

664
00:35:30.212 --> 00:35:34.213
rise to these trust minimized
agreements or these programmatic

665
00:35:34.213 --> 00:35:38.213
unbreakable promises. We move
away from brand based agreements

666
00:35:38.213 --> 00:35:41.213
to math based agreements, where
we can look at the cryptography

667
00:35:41.213 --> 00:35:44.214
we can look right at the code
and see exactly what something

668
00:35:44.214 --> 00:35:47.214
is going to do and how it's
going to execute, versus having

669
00:35:47.214 --> 00:35:50.214
to rely on a human being doing
the right thing with smart

670
00:35:51.214 --> 00:35:54.215
contracts and decentralized
hybrid smart contracts. Doing

671
00:35:54.215 --> 00:35:57.215
the right thing is
infrastructural all these pieces

672
00:35:57.215 --> 00:36:01.215
boil down to us having the
freedom to interact the way we

673
00:36:01.215 --> 00:36:04.216
want to interact without having
to be afraid that interacting

674
00:36:04.216 --> 00:36:07.216
like that is going to screw us
over this trust minimized piece,

675
00:36:07.216 --> 00:36:12.217
these unbreakable promises, make
interactions so much better. In

676
00:36:12.217 --> 00:36:15.217
a purely web two world, we're
constantly bombarded with

677
00:36:15.217 --> 00:36:19.217
messages of projects and
protocols pushing us to move or

678
00:36:19.217 --> 00:36:22.218
act in the direction that makes
them more profitable. Versus in

679
00:36:22.218 --> 00:36:23.218
the smart contract space,

680
00:36:23.218 --> 00:36:26.218
we can see everything
transparently. And we can even

681
00:36:26.218 --> 00:36:29.218
engage in interact and be
partially owners of the

682
00:36:29.218 --> 00:36:33.219
protocols and the interactions
that we decide that we want to

683
00:36:33.219 --> 00:36:33.219
be a part

684
00:36:33.219 --> 00:36:38.219
of. So smart contracts have

685
00:36:38.219 --> 00:36:41.219
been around for a few years now.
And what did they generate for

686
00:36:41.219 --> 00:36:44.220
what industries have come about
due to these smart contract

687
00:36:44.220 --> 00:36:46.220
platforms being around? Well,
you've probably heard of some of

688
00:36:46.220 --> 00:36:49.220
these and some of these we've
already mentioned, but let's

689
00:36:49.220 --> 00:36:52.221
give you a quick refresher, d
phi d phi stands for

690
00:36:52.221 --> 00:36:56.221
decentralized finance. And it
gives users the ability to

691
00:36:56.221 --> 00:36:58.221
engage with finance and markets
without having to go through a

692
00:36:58.221 --> 00:37:01.221
centralized intermediary. For
example, like we said, with

693
00:37:01.221 --> 00:37:04.222
Robin Hood, you no longer have
to trust that Robin Hood would

694
00:37:04.222 --> 00:37:07.222
continue to give you access to
the markets, you instead would

695
00:37:07.222 --> 00:37:10.222
be able to see in the smart
contract. Yes, I have access to

696
00:37:10.222 --> 00:37:13.223
the markets or in the 2008
financial crisis. You never have

697
00:37:13.223 --> 00:37:16.223
to trust that these groups and
institutions are giving you the

698
00:37:16.223 --> 00:37:19.223
correct things on the back end.
You can see everything

699
00:37:19.223 --> 00:37:22.224
transparently right on the
blockchain, you can engage with

700
00:37:22.224 --> 00:37:25.224
things like money markets and
sophisticated financial products

701
00:37:25.224 --> 00:37:30.224
easy effectively and securely at
the time of recording. defi has

702
00:37:30.224 --> 00:37:34.225
around $200 billion in assets
under management and is quickly

703
00:37:34.225 --> 00:37:37.225
growing. If you're really
excited about defy we have a ton

704
00:37:37.225 --> 00:37:40.225
of defy examples showing you how
to build and interact with these

705
00:37:40.225 --> 00:37:43.226
protocols. In coming lessons.
Dows or decentralized.

706
00:37:43.226 --> 00:37:46.226
autonomous organizations are
another group that we've already

707
00:37:46.226 --> 00:37:49.226
mentioned. Dows are groups that
are governed completely

708
00:37:49.226 --> 00:37:52.227
decentralized by a set of
instructions or smart contracts

709
00:37:52.227 --> 00:37:56.227
on chain. There are some massive
benefits here where engagement

710
00:37:56.227 --> 00:37:58.227
is much easier. The rules are
black and white. And you can see

711
00:37:58.227 --> 00:38:01.227
everything directly on chain
voting and governance

712
00:38:01.227 --> 00:38:04.228
technologies completely
decentralized in the blockchain

713
00:38:04.228 --> 00:38:06.228
space is one of the big ones
pushing how we can evolve

714
00:38:06.228 --> 00:38:09.228
politics and how we can evolve
governance to make it more

715
00:38:09.228 --> 00:38:12.229
efficient, fair and reasonable.
And you better know it, we have

716
00:38:12.229 --> 00:38:15.229
some examples of how to build
Dows and how to work with Dows

717
00:38:15.229 --> 00:38:18.229
incoming lessons. So be sure to
watch those NF T's Stanford non

718
00:38:18.229 --> 00:38:22.230
fungible tokens and can really
be kind of described as digital

719
00:38:22.230 --> 00:38:26.230
art or just a unique asset, they
can do so much more, but we'll

720
00:38:26.230 --> 00:38:29.230
keep it high level for now.
Projects like board apes and

721
00:38:29.230 --> 00:38:32.231
crypto punks have revolutionized
the way that people get paid for

722
00:38:32.231 --> 00:38:35.231
their work, show off their
creativity, status, and so much

723
00:38:35.231 --> 00:38:38.231
more. And yes, of course, we
have lessons showing you how to

724
00:38:38.231 --> 00:38:42.231
create and interact with NF T's
as well, so many other groups

725
00:38:42.231 --> 00:38:44.232
and so many other industries are
being created as a result of

726
00:38:44.232 --> 00:38:47.232
this insane technology. And
maybe after finishing the

727
00:38:47.232 --> 00:38:51.232
journey with us here, you go out
and you'd be the one to pioneer

728
00:38:51.232 --> 00:38:54.233
the next industry or the next
billion dollar idea you've

729
00:38:54.233 --> 00:38:58.233
learned so much already. But now
that we've learned a lot of this

730
00:38:58.233 --> 00:39:02.234
high level information, let's
finally jump in, and let's make

731
00:39:02.234 --> 00:39:06.234
your first transaction and let's
get you set up to interact with

732
00:39:06.234 --> 00:39:09.234
this new world. In this next
section, we're going to get you

733
00:39:09.234 --> 00:39:12.235
a wallet and we're going to show
you exactly what a transaction

734
00:39:12.235 --> 00:39:20.235
looks like and feels like. Let's
dive in. This is the Aetherium

735
00:39:20.235 --> 00:39:24.236
website aetherium.org We are
going to make a transaction on a

736
00:39:24.236 --> 00:39:28.236
test Aetherium blockchain I'll
explain what that means in a

737
00:39:28.236 --> 00:39:31.236
little bit. This is going to be
our first transaction that's

738
00:39:31.236 --> 00:39:34.237
made on the blockchain. Now
again, this process that we're

739
00:39:34.237 --> 00:39:38.237
going to follow is going to work
the exact same with polygon,

740
00:39:38.237 --> 00:39:41.237
avalanche Phantom and all these
other EVM compatible

741
00:39:41.237 --> 00:39:44.238
blockchains. I'll explain what
that means in a bit too. For

742
00:39:44.238 --> 00:39:47.238
now, just follow along and have
fun in order to make a

743
00:39:47.238 --> 00:39:50.238
transaction on any of these
blockchains. The first thing

744
00:39:50.238 --> 00:39:55.239
that we need to do is we need to
set up a wallet. So I'm gonna go

745
00:39:55.239 --> 00:39:57.239
ahead and go to meta mask
because it's one of the most

746
00:39:57.239 --> 00:40:00.239
popular wallets and one of the
easiest to Use, we're going to

747
00:40:00.239 --> 00:40:03.240
go ahead and download it. I'm
using the brave browser, but it

748
00:40:03.240 --> 00:40:07.240
works for Chrome, Firefox or
really any other browsers. And

749
00:40:07.240 --> 00:40:11.240
it's just going to be a little
extension in the top right hand

750
00:40:11.240 --> 00:40:14.241
of your browser. This way, we
can really easily see it any

751
00:40:14.241 --> 00:40:17.241
times what we have in our
wallet, will still are all of

752
00:40:17.241 --> 00:40:21.241
our Aetherium based currencies.
So I'm gonna go ahead and

753
00:40:21.241 --> 00:40:24.242
install meta mask for brave,

754
00:40:24.242 --> 00:40:27.242
add to brave, add extension. And
now we can go ahead and get

755
00:40:27.242 --> 00:40:31.242
started with working with Brave,
this is the first step you

756
00:40:31.242 --> 00:40:34.243
absolutely need to take when
starting your journey and one of

757
00:40:34.243 --> 00:40:36.243
the easiest steps to take. So
we're gonna go ahead and get

758
00:40:36.243 --> 00:40:40.243
started. And we're going to
create a brand new wallet. So

759
00:40:40.243 --> 00:40:42.244
we're gonna go ahead and hit
create wallet. If you already

760
00:40:42.244 --> 00:40:46.244
have a wallet, you can actually
import it via I have a seed

761
00:40:46.244 --> 00:40:49.244
phrase, and we'll talk about the
seed phrase or secret phrase in

762
00:40:49.244 --> 00:40:53.245
a little bit. So let's go ahead
and create a new wallet. And

763
00:40:53.245 --> 00:40:56.245
sure, we'll agree to help out
Metamask now we will create our

764
00:40:56.245 --> 00:41:00.245
password make sure that this is
really secure. For the purpose

765
00:41:00.245 --> 00:41:03.246
of this demo, my passwords are
just gonna be password. But

766
00:41:03.246 --> 00:41:06.246
please don't have that be your
password. You may also get a

767
00:41:06.246 --> 00:41:08.246
video like this teaching you
about your secret recovery

768
00:41:08.246 --> 00:41:12.246
phrase. This is the same thing
as your pneumonic. But see your

769
00:41:12.246 --> 00:41:15.247
recovery phrase is a lot more
clear as to what it is. And

770
00:41:15.247 --> 00:41:17.247
again, to give us a ton of
different tips on how to

771
00:41:17.247 --> 00:41:21.247
actually store it and keep it
safe. The main takeaway from

772
00:41:21.247 --> 00:41:24.248
this is never shared this
absolutely never shared this. So

773
00:41:24.248 --> 00:41:28.248
we're going to go ahead and
click reveal secret words. I'm

774
00:41:28.248 --> 00:41:31.248
showing you guys here because
this is just a demo and I don't

775
00:41:31.248 --> 00:41:35.249
really care. However, if you
show this secret phrase to

776
00:41:35.249 --> 00:41:38.249
anybody else, they will have
access to all the funds in your

777
00:41:38.249 --> 00:41:41.249
application. So everything that
we're going to do in this

778
00:41:41.249 --> 00:41:44.250
tutorial, we're going to use
fake money, we're going to use

779
00:41:44.250 --> 00:41:47.250
not real money, so it doesn't
matter. Now for the purposes of

780
00:41:47.250 --> 00:41:51.250
testing and developing, I always
recommend using a completely

781
00:41:51.250 --> 00:41:54.251
separate meta mask, a completely
separate Wallet. So for going

782
00:41:54.251 --> 00:41:57.251
throughout this entire course,
if you already have a wallet, or

783
00:41:57.251 --> 00:42:01.251
if you already have a meta mask,
please just set up a new one,

784
00:42:01.251 --> 00:42:04.252
create a new profile, create a
new meta mask, and this will be

785
00:42:04.252 --> 00:42:06.252
your wallet that you use for the
duration of this course.

786
00:42:06.252 --> 00:42:08.252
However, if you're going to
actually put money in here, you

787
00:42:09.252 --> 00:42:11.252
absolutely need to have this
written down. Because if you

788
00:42:11.252 --> 00:42:14.253
lose access to this, and all
your private keys, which we'll

789
00:42:14.253 --> 00:42:17.253
talk about in a little bit, you
will lose access to your wallet,

790
00:42:17.253 --> 00:42:20.253
and you will lose access to all
your funds. So they give some

791
00:42:20.253 --> 00:42:23.254
tips like store this phrase and
a password manager like one

792
00:42:23.254 --> 00:42:26.254
password, write this phrase down
on a piece of paper, put it in a

793
00:42:26.254 --> 00:42:30.254
secure location, memorize it,
whatever you want to do, just

794
00:42:30.254 --> 00:42:32.255
make sure you have this backed
up somewhere, I'm just gonna go

795
00:42:32.255 --> 00:42:35.255
ahead and hit download this for
now, it's not best practice to

796
00:42:35.255 --> 00:42:37.255
save to your computer, it is
much better to use a password

797
00:42:37.255 --> 00:42:40.255
manager or write it down on a
piece of paper or something. So

798
00:42:40.255 --> 00:42:44.256
we're gonna go ahead and hit
next. And it's going to ask us

799
00:42:44.256 --> 00:42:49.256
to verify that we actually have
it written down. And we're gonna

800
00:42:49.256 --> 00:42:52.257
go ahead and hit confirm, and
great and gives us a couple

801
00:42:52.257 --> 00:42:55.257
other tips. Remember, definitely
take these tips very seriously,

802
00:42:55.257 --> 00:42:58.257
especially if you're gonna use
this for real money. Like I

803
00:42:58.257 --> 00:43:01.257
said, For this demo, we're just
going to use test money. So it's

804
00:43:01.257 --> 00:43:04.258
not as big of a deal. But if you
put real money in, you

805
00:43:04.258 --> 00:43:08.258
absolutely need to backup this
seed phrase or secret phrase or

806
00:43:08.258 --> 00:43:11.258
we're going to refer to it as
our pneumonic phrase. Awesome.

807
00:43:11.258 --> 00:43:16.259
Now we can see the interface of
our wallet here full screen. And

808
00:43:16.259 --> 00:43:19.259
depending on your browser, you
can actually come up and pin it

809
00:43:19.259 --> 00:43:22.259
to your browser so that you can
just click it up in the top

810
00:43:22.259 --> 00:43:25.260
right, and it'll drop down and
you can see the same interface

811
00:43:25.260 --> 00:43:29.260
here our pneumonic phrase that
secret phrase, those that secret

812
00:43:29.260 --> 00:43:33.261
12 words that they gave us have
given us access to a new

813
00:43:33.261 --> 00:43:36.261
account, the address of our
account is located right here.

814
00:43:36.261 --> 00:43:41.261
In fact, if we click it and copy
it to our clipboard, and go to a

815
00:43:41.261 --> 00:43:45.262
tool called a block explorer
called ether scan, we can

816
00:43:45.262 --> 00:43:49.262
actually paste our address in
here and see details about our

817
00:43:49.262 --> 00:43:52.262
account. Ether scan, like I
said, is what's known as a block

818
00:43:52.262 --> 00:43:55.263
Explorer. And it's a way to view
different addresses transactions

819
00:43:55.263 --> 00:43:59.263
and other happenings that happen
with a blockchain. If we look at

820
00:43:59.263 --> 00:44:02.264
this address that we just
created on ether scan for

821
00:44:02.264 --> 00:44:06.264
Etherium main net, we can see no
transactions have happened.

822
00:44:06.264 --> 00:44:09.264
There's really no analytics,
there's no comments, there's no

823
00:44:09.264 --> 00:44:13.265
balance, there's no value,
because it's a brand new wallet,

824
00:44:13.265 --> 00:44:16.265
and this address that we just
punched into ether scan

825
00:44:16.265 --> 00:44:21.265
represents our unique address
our unique wallet only

826
00:44:21.265 --> 00:44:25.266
identifiable for us. We'll talk
about ether scan a little bit

827
00:44:25.266 --> 00:44:27.266
more in a bit because it's a
tool that we're going to use

828
00:44:27.266 --> 00:44:30.266
quite often in wallets like meta
mask, you can actually even

829
00:44:30.266 --> 00:44:34.267
click right here and create even
more accounts. So let's go ahead

830
00:44:34.267 --> 00:44:38.267
and create a new account. We'll
call this

831
00:44:38.267 --> 00:44:41.267
account two.

832
00:44:41.267 --> 00:44:44.268
As you can see, this one has a
different address. So if we

833
00:44:44.268 --> 00:44:49.268
click this one, we go back to
ether scan. We paste the address

834
00:44:49.268 --> 00:44:53.269
in here. We hit Enter. We can
see another address again that's

835
00:44:53.269 --> 00:44:57.269
uniquely identifiable to us,
right here. It is zero balance,

836
00:44:57.269 --> 00:45:01.269
no value, no transactions now If
we go back to our Metamask, and

837
00:45:01.269 --> 00:45:04.270
we click the little button, we
can see we have two different

838
00:45:04.270 --> 00:45:07.270
accounts in here, it's the same.
If we hit the extension in the

839
00:45:07.270 --> 00:45:12.270
top right, click the button, we
have two different accounts. The

840
00:45:12.270 --> 00:45:16.271
12 word secret recovery phrase
allows us to create multiple

841
00:45:16.271 --> 00:45:20.271
accounts, all with the same
secret recovery phrase. So that

842
00:45:20.271 --> 00:45:24.272
secret recovery phrase will give
us access to both account one

843
00:45:24.272 --> 00:45:28.272
and account two and any other
accounts that we create by

844
00:45:28.272 --> 00:45:30.272
hitting this Create Account
button, because it gives you

845
00:45:30.272 --> 00:45:34.273
access to all the accounts in
your meta mask. Now, these

846
00:45:34.273 --> 00:45:38.273
addresses of both of our
accounts are the public unique

847
00:45:38.273 --> 00:45:43.274
identifiers, but they also have
a private unique identifier only

848
00:45:43.274 --> 00:45:47.274
identifiable to us. Similar to
the pneumonic, these are private

849
00:45:48.274 --> 00:45:51.274
identifiers we never want to
share and we never want to give

850
00:45:51.274 --> 00:45:55.275
out their private This is known
as your accounts private key. So

851
00:45:55.275 --> 00:45:58.275
the mnemonic will give you
access over many of these

852
00:45:58.275 --> 00:46:01.275
accounts, the private key will
give you access to just one of

853
00:46:01.275 --> 00:46:04.276
these accounts, we can see it by
hitting these little three dots,

854
00:46:04.276 --> 00:46:08.276
going to account details and
export private key, you'll just

855
00:46:08.276 --> 00:46:12.276
have to punch in your password
here. And you'll be able to see

856
00:46:12.276 --> 00:46:16.277
your private key. This is going
to be your private key for your

857
00:46:16.277 --> 00:46:19.277
account, you can think of your
private key as a password for

858
00:46:19.277 --> 00:46:23.278
your account that lets you
create transactions. Now the

859
00:46:23.278 --> 00:46:26.278
reason that I'm showing mine on
screen is because I'm not going

860
00:46:26.278 --> 00:46:28.278
to put any real money in here.
And this is just going to be a

861
00:46:28.278 --> 00:46:32.278
burner account for this
tutorial. And I highly recommend

862
00:46:32.278 --> 00:46:35.279
once again, you use a burner
account, you use accounts that

863
00:46:35.279 --> 00:46:38.279
you never put any real money
into. And along the way, I'll

864
00:46:38.279 --> 00:46:42.279
show you how to make sure that
you don't do that. But normally,

865
00:46:42.279 --> 00:46:45.280
it's not a good idea to show or
share your private keys or your

866
00:46:45.280 --> 00:46:49.280
secret recovery phrase, if
somebody gets a hold of this

867
00:46:49.280 --> 00:46:53.281
private key, they will have
access to my account one.

868
00:46:53.281 --> 00:46:57.281
However, they won't have access
to my account to if they get a

869
00:46:57.281 --> 00:47:00.281
hold of my 12 word recovery
phrase or pneumonic they'll have

870
00:47:00.281 --> 00:47:04.282
access to both accounts. And
this is why when people say keep

871
00:47:04.282 --> 00:47:07.282
your private keys safe, your
keys, your Bitcoin, your keys,

872
00:47:07.282 --> 00:47:11.282
your Aetherium, they're talking
about both your mnemonics or

873
00:47:11.282 --> 00:47:15.283
your secret recovery phrases.
And your private keys keep those

874
00:47:15.283 --> 00:47:19.283
private, your public addresses
are totally public. And anybody

875
00:47:19.283 --> 00:47:22.283
can view your accounts on
something like ether scan, or

876
00:47:22.283 --> 00:47:25.284
any other explore. And it's
totally okay for people to share

877
00:47:25.284 --> 00:47:28.284
their public addresses. If you
lose your private key, you lose

878
00:47:28.284 --> 00:47:31.284
access to one of your accounts.
If you lose your mnemonic, you

879
00:47:31.284 --> 00:47:34.285
could potentially lose access to
all your accounts. Basically,

880
00:47:34.285 --> 00:47:37.285
what I'm trying to say is back
these up and keep them in safe

881
00:47:37.285 --> 00:47:41.285
places for this course it's okay
if you lose one, since we're not

882
00:47:41.285 --> 00:47:44.286
putting any real money in them.
But in the real world, be sure

883
00:47:44.286 --> 00:47:46.286
to do this. And great. Those are
some of the main security

884
00:47:46.286 --> 00:47:49.286
considerations here. Now, if you
look up in the top right, right

885
00:47:49.286 --> 00:47:52.286
next to that account button that
we've been clicking, you also

886
00:47:52.286 --> 00:47:57.287
see this thing saying Etherium
main net, this is our networks

887
00:47:57.287 --> 00:48:00.287
tab. And if we click it, we can
see a list of all the different

888
00:48:00.287 --> 00:48:05.288
networks that we currently have
access to a Etherium main net is

889
00:48:05.288 --> 00:48:09.288
the main network of Aetherium.
And this is where real money is

890
00:48:09.288 --> 00:48:13.289
spent and used for transactions.
For this course, we're not going

891
00:48:13.289 --> 00:48:15.289
to be working with the Etherium
main net, we're instead going to

892
00:48:15.289 --> 00:48:18.289
be working with something called
a test net. Since we're

893
00:48:18.289 --> 00:48:22.289
engineers, oftentimes, we're
going to want to test and see

894
00:48:22.289 --> 00:48:25.290
what our code is actually going
to do and how to interact with

895
00:48:25.290 --> 00:48:28.290
it. We're going to use a
combination of local networks

896
00:48:28.290 --> 00:48:32.290
and test networks to actually do
this to actually test our smart

897
00:48:32.290 --> 00:48:35.291
contracts. We're mainly going to
use local networks. But we'll

898
00:48:35.291 --> 00:48:38.291
get to that in a little bit to
see some of the test networks

899
00:48:38.291 --> 00:48:42.291
that come default with meta
mask, we hit show slash hide

900
00:48:42.291 --> 00:48:45.292
test networks, this will bring
us into the settings page. And

901
00:48:45.292 --> 00:48:48.292
we just hit select this to show
test networks in the list. And

902
00:48:48.292 --> 00:48:52.292
we just hit on Now if we scroll
back up, we'll close out of the

903
00:48:52.292 --> 00:48:57.293
settings, we hit the network's
tab again. Now we can see all of

904
00:48:57.293 --> 00:49:01.293
these other networks here like
ropsten, Koven, Rinkeby, and

905
00:49:01.293 --> 00:49:04.294
Garelli. These test networks or
networks that resemble

906
00:49:04.294 --> 00:49:08.294
Aetherium, or polygon, or
Avalanche or phantom or any of

907
00:49:08.294 --> 00:49:11.294
these other blockchains. And we
can actually switch our accounts

908
00:49:11.294 --> 00:49:14.295
to one of these other test
networks. Let's click rink B,

909
00:49:15.295 --> 00:49:18.295
for example, we can see that on
the Rinkeby test network. We

910
00:49:18.295 --> 00:49:22.295
also have zero Aetherium we have
no money or nothing in here, we

911
00:49:22.295 --> 00:49:26.296
have a blank Rinkeby wallet.
These test nets work nearly

912
00:49:26.296 --> 00:49:29.296
identical to how Aetherium main
networks except for they run

913
00:49:29.296 --> 00:49:33.297
with not real money. They run
with fake money as a way for us

914
00:49:33.297 --> 00:49:36.297
to learn and interact and see
how these different smart

915
00:49:36.297 --> 00:49:39.297
contracts actually work together
at the time of filming. rink B

916
00:49:39.297 --> 00:49:43.298
is one of the most popular test
networks along with COVID. So

917
00:49:43.298 --> 00:49:47.298
we're going to work a lot with
Rigby In this tutorial, however,

918
00:49:47.298 --> 00:49:51.298
be absolutely sure to check our
GitHub repository to make sure

919
00:49:51.298 --> 00:49:55.299
that you're always up to date
with the best test network for

920
00:49:55.299 --> 00:49:57.299
following along with the
tutorial here since their test

921
00:49:57.299 --> 00:50:00.299
networks people are running them
out of the goodness of their

922
00:50:00.299 --> 00:50:03.300
hearts. And sometimes the best
ones actually change so, so be

923
00:50:03.300 --> 00:50:06.300
sure to follow along with the
GitHub repository. We might also

924
00:50:06.300 --> 00:50:10.300
use COVID From time to time or
maybe even Grilli. So we're

925
00:50:10.300 --> 00:50:12.300
going to show you how to use a
couple of these different test

926
00:50:12.300 --> 00:50:15.301
nets. In fact, if we go to the
GitHub repo associated with this

927
00:50:15.301 --> 00:50:19.301
course, we can see recommended
test net is indeed currently

928
00:50:19.301 --> 00:50:22.301
ranking. So that's what we're
going to work with should this

929
00:50:22.301 --> 00:50:25.302
change, you should be able to
follow along with another test.

930
00:50:25.302 --> 00:50:28.302
And we'll leave notes as to how
to continue. Now what we can do

931
00:50:28.302 --> 00:50:34.303
actually is we can go to Rigby
ether scan, we can go to,

932
00:50:34.303 --> 00:50:37.303
you can look up Rinku ether
scan, and it looks like it's the

933
00:50:37.303 --> 00:50:41.303
first thing that shows up
Rinkeby dot ether scan.io, we

934
00:50:41.303 --> 00:50:47.304
can punch in this same address,
copy and paste it. And we can

935
00:50:47.304 --> 00:50:50.304
see some of the details of this
address on the Rinkeby ether

936
00:50:50.304 --> 00:50:53.305
scan. Like I said, right now,
it's totally blank. This

937
00:50:53.305 --> 00:50:57.305
networks interface later on is
also how we're going to be able

938
00:50:57.305 --> 00:51:00.305
to work with polygon, avalanche,
etc, we'll just have to add

939
00:51:00.305 --> 00:51:03.306
networks. But we'll get to that
in a bit. And just to reiterate,

940
00:51:03.306 --> 00:51:06.306
test nets are free and for
testing our smart contracts and

941
00:51:06.306 --> 00:51:11.306
main net networks cost money and
are considered live. Now I also

942
00:51:11.306 --> 00:51:14.307
do want to put a caveat here
that we do want to keep in mind

943
00:51:14.307 --> 00:51:17.307
that these test nets are being
run at the goodness of people's

944
00:51:17.307 --> 00:51:20.307
hearts. So we don't want to
abuse them, we want to use them

945
00:51:20.307 --> 00:51:23.308
to learn and then move on. So
try not to send a billion

946
00:51:23.308 --> 00:51:26.308
transactions on one of these
test nets. In fact, what we're

947
00:51:26.308 --> 00:51:30.308
going to do right now is we're
going to send a transaction on

948
00:51:30.308 --> 00:51:33.309
the Rinkeby test net. And this
will show us exactly what it

949
00:51:33.309 --> 00:51:36.309
would look like on a main
network. In order for us to

950
00:51:36.309 --> 00:51:39.309
simulate one of these
transactions, we're going to go

951
00:51:39.309 --> 00:51:42.309
to what's called a faucet. And
if you go to the GitHub

952
00:51:42.309 --> 00:51:45.310
repository associated with this
course, right underneath the

953
00:51:45.310 --> 00:51:49.310
recommended test net is going to
be a test net faucets, which is

954
00:51:49.310 --> 00:51:53.311
going to show us where the most
up to date faucet location is

955
00:51:53.311 --> 00:51:56.311
for us getting test net
Aetherium. So here we are at

956
00:51:56.311 --> 00:51:59.311
faucets dot chain dot link,
which again is the recommended

957
00:51:59.311 --> 00:52:03.312
faucet, and what we can do is we
can actually put our wallet

958
00:52:03.312 --> 00:52:08.312
address in and get some test net
link or test net Aetherium. Now

959
00:52:08.312 --> 00:52:11.312
what we are gonna have to do is
we are gonna have to connect our

960
00:52:11.312 --> 00:52:15.313
wallet to the Rinkeby network.
So we're going to come down,

961
00:52:15.313 --> 00:52:21.313
we're going to switch from COVID
to Etherium. Rigby, and then

962
00:52:21.313 --> 00:52:25.314
we're going to make sure our
meta mask is on the Rinkeby test

963
00:52:25.314 --> 00:52:28.314
network here. Once both of those
are set up, we're gonna go ahead

964
00:52:28.314 --> 00:52:33.315
and hit Connect wallet. And
we're going to choose meta mask.

965
00:52:33.315 --> 00:52:36.315
Once we do that, our meta mask
is actually going to pop up and

966
00:52:36.315 --> 00:52:40.315
say would you like to connect to
this website, connecting to a

967
00:52:40.315 --> 00:52:43.316
website is how we give these
websites in interface to

968
00:52:43.316 --> 00:52:46.316
interact with our wallets and
interact with our meta masks.

969
00:52:46.316 --> 00:52:49.316
Don't worry, we're not sending
any transactions like this,

970
00:52:49.316 --> 00:52:52.316
we'll get to that in a bit. So
we just we can pick an account

971
00:52:52.316 --> 00:52:56.317
we want to connect. Let's choose
our account one, we'll hit Next.

972
00:52:57.317 --> 00:53:00.317
And then we'll go ahead and
connect. Now that we're

973
00:53:00.317 --> 00:53:04.318
connected, we can actually see
our account connected up here.

974
00:53:04.318 --> 00:53:07.318
And that little warning is now
gone. And our wallet address is

975
00:53:07.318 --> 00:53:10.318
automatically placed into here,
we're going to make our first

976
00:53:10.318 --> 00:53:15.319
test transaction. And for now,
we don't need test link. So

977
00:53:15.319 --> 00:53:17.319
we're going to leave that off.
But later on, we're going to

978
00:53:17.319 --> 00:53:20.319
come back and get that test
link. For now we're just going

979
00:53:20.319 --> 00:53:24.320
to need 0.1 test Aetherium.

980
00:53:24.320 --> 00:53:27.320
So let's go ahead and complete
the security by choosing the

981
00:53:27.320 --> 00:53:31.320
traffic lights. And we're going
to hit Send Request. What this

982
00:53:31.320 --> 00:53:37.321
is going to do is we're asking
this faucet to send us 0.1 test

983
00:53:37.321 --> 00:53:41.321
Aetherium test net faucets are
ways for us to get money into

984
00:53:41.321 --> 00:53:44.322
our wallets on a test net. And
this is why this test and

985
00:53:44.322 --> 00:53:47.322
Aetherium isn't worth any actual
money. Since we can get it for

986
00:53:47.322 --> 00:53:51.322
free. These don't exist on Main
net, you can't get real

987
00:53:51.322 --> 00:53:55.323
Aetherium or real money for free
on a main network. So we're on

988
00:53:55.323 --> 00:53:58.323
Rinkeby we're getting fake
Rinckey Aetherium. And we're

989
00:53:58.323 --> 00:54:00.323
gonna go ahead and hit send
request. Once we hit Send

990
00:54:00.323 --> 00:54:04.324
Request, this transaction hash
is going to pop up here, and it

991
00:54:04.324 --> 00:54:07.324
says transactions have been
initiated waiting for

992
00:54:07.324 --> 00:54:11.324
confirmation. This means that
some other wallet is actually

993
00:54:11.324 --> 00:54:15.325
going to send us 0.1 test eath.
And this is the transaction that

994
00:54:15.325 --> 00:54:18.325
it's doing to do that now we
just have to wait for our

995
00:54:18.325 --> 00:54:22.325
transaction to finish verifying
and finish going through. Now if

996
00:54:22.325 --> 00:54:24.326
this doesn't work right away, I
would recommend Wait a minute

997
00:54:24.326 --> 00:54:27.326
and then just try it again. But
what we can do is we can click

998
00:54:27.326 --> 00:54:31.326
this transaction hash. If that
transaction doesn't show up, we

999
00:54:31.326 --> 00:54:35.327
can also just close this. And we
can copy our address here. And

1000
00:54:35.327 --> 00:54:39.327
actually we already see 0.1 eath
in our wallets here. But we can

1001
00:54:39.327 --> 00:54:44.328
go back over to Rinkeby ether
scan, paste our address and and

1002
00:54:44.328 --> 00:54:49.328
we can see that we now have 0.1
ether as a balance. We can also

1003
00:54:49.328 --> 00:54:53.329
see that we have a transaction
with all this information going

1004
00:54:53.329 --> 00:54:56.329
into our wallet. That's what
this green is for. If you click

1005
00:54:56.329 --> 00:55:00.329
that transaction link, you'd get
something like this, but If you

1006
00:55:00.329 --> 00:55:03.330
didn't, don't worry, because on
the ether scan, if you click the

1007
00:55:03.330 --> 00:55:07.330
transaction hash in the
transaction list, you can also

1008
00:55:07.330 --> 00:55:10.330
see all the details like that.
So now in our meta mask, we have

1009
00:55:10.330 --> 00:55:15.331
0.1 eath. Again, this is fake
Aetherium. And we have a

1010
00:55:15.331 --> 00:55:18.331
transaction associated with our
wallet now, which is awesome.

1011
00:55:18.331 --> 00:55:22.331
Again, though, if we switch
networks, if we switch networks

1012
00:55:22.331 --> 00:55:25.332
back to Etherium main net, you
can see that we have nothing on

1013
00:55:25.332 --> 00:55:29.332
a theory main net. Or if we go
to ropsten, we also have

1014
00:55:29.332 --> 00:55:33.333
nothing, we only have this 0.1
eath. On the Rinkeby test

1015
00:55:33.333 --> 00:55:37.333
network, if you want to practice
working with another test net,

1016
00:55:37.333 --> 00:55:40.333
and the faucet that we're using,
has multiple test nets. Let's go

1017
00:55:40.333 --> 00:55:43.334
ahead and try it during this
section right now is completely

1018
00:55:43.334 --> 00:55:46.334
optional, you can watch or you
can follow along. But for

1019
00:55:46.334 --> 00:55:49.334
example, I can see in my wallet
that we already have COVID

1020
00:55:49.334 --> 00:55:53.334
supported, so maybe I'll switch
to COVID. Maybe we'll switch to

1021
00:55:53.334 --> 00:55:57.335
COVID. In the drop down here,
we'll remove test 10 Link,

1022
00:55:57.335 --> 00:56:01.335
because we only need test eath.
We'll hit I'm not a robot, and

1023
00:56:01.335 --> 00:56:04.336
we'll send request and the same
things will pop up this time,

1024
00:56:04.336 --> 00:56:08.336
this is going to be for the
COVID test net. And once our

1025
00:56:08.336 --> 00:56:11.336
transaction finishes going
through. Now, same thing on

1026
00:56:11.336 --> 00:56:14.337
COVID. Here, like what we did
with rink B, once our

1027
00:56:14.337 --> 00:56:18.337
transaction finishes going
through, we'll see 0.1 test eath

1028
00:56:18.337 --> 00:56:21.337
on the COVID network, if you
want to go ahead and try working

1029
00:56:21.337 --> 00:56:25.338
with another one of the test
nets. Like maybe, for example

1030
00:56:25.338 --> 00:56:28.338
COVID recommend you go ahead and
giving it a try. But it's

1031
00:56:28.338 --> 00:56:31.338
completely optional. And I would
always refer back to the GitHub

1032
00:56:31.338 --> 00:56:34.339
repo to make sure you're working
with the most up to date faucet

1033
00:56:34.339 --> 00:56:37.339
and test net. And if we look
back at ether scan, we can

1034
00:56:37.339 --> 00:56:41.339
actually see more details on
what actually just took place.

1035
00:56:41.339 --> 00:56:45.340
What actually just happened, how
did our Metamask get a balance

1036
00:56:45.340 --> 00:56:48.340
of 0.1 eath. All of a sudden?
Well, if we looked down in the

1037
00:56:48.340 --> 00:56:53.340
transaction section, we can see
that there's a transaction here,

1038
00:56:53.340 --> 00:56:58.341
some address sent us 0.1 ether.
And if we click the transaction

1039
00:56:58.341 --> 00:57:02.341
hash, we can see more details
about what actually went down

1040
00:57:02.341 --> 00:57:05.342
with this transaction. Now
understanding what's going on in

1041
00:57:05.342 --> 00:57:09.342
this transaction is essential to
learning and being a smart

1042
00:57:09.342 --> 00:57:12.342
contract developer or just
engaging with the ecosystem. So

1043
00:57:12.342 --> 00:57:16.343
let's learn the first bit at the
top is this transaction hash.

1044
00:57:16.343 --> 00:57:21.343
This is a unique identifier for
this blockchain or this test net

1045
00:57:21.343 --> 00:57:24.344
that identifies this exact
transaction. This transaction

1046
00:57:24.344 --> 00:57:31.344
hash identifies sending 0.1 eath
to our address, we can see that

1047
00:57:31.344 --> 00:57:34.345
the status of this transaction
was successful, it didn't break.

1048
00:57:34.345 --> 00:57:38.345
In any case, we can see the
block number that this

1049
00:57:38.345 --> 00:57:41.345
transaction was included in and
we'll get to blocks in a little

1050
00:57:41.345 --> 00:57:45.346
bit, we can see the timestamp
which of course is when this

1051
00:57:45.346 --> 00:57:49.346
transaction occurred, we can see
which account it was from which

1052
00:57:49.346 --> 00:57:54.347
if we go ahead and open in a new
tab, we can see that this is the

1053
00:57:54.347 --> 00:57:57.347
account that this transaction
came from. And it's got 3

1054
00:57:57.347 --> 00:58:01.347
million ether. Of course, this
is fake Rinckey ether. So it

1055
00:58:01.347 --> 00:58:04.348
doesn't really matter, we can
all see who it was to, which

1056
00:58:04.348 --> 00:58:10.348
again, is just us. This is our
wallet address 0x 106 X blah,

1057
00:58:10.348 --> 00:58:15.349
blah, blah, cero x 1066, blah,
blah, blah, right, the value of

1058
00:58:15.349 --> 00:58:19.349
this transaction, of course, is
0.1 ether. Now what's all this

1059
00:58:19.349 --> 00:58:22.349
that we see as the value so
obviously, the value is 0.1,

1060
00:58:22.349 --> 00:58:24.350
because that's a mode which we
sent. But we see this

1061
00:58:24.350 --> 00:58:28.350
transaction fee. In this gas
price, we hover over the

1062
00:58:28.350 --> 00:58:31.350
tooltip, we can see if you zoom
in on your ether scan, you see

1063
00:58:31.350 --> 00:58:35.351
amount paid to the miner for
processing the transaction. And

1064
00:58:35.351 --> 00:58:40.351
we see a gas price which is cost
per unit of gas specified for

1065
00:58:40.351 --> 00:58:43.352
the transaction and ether and
gray. The higher the gas price,

1066
00:58:43.352 --> 00:58:46.352
the higher the chance of getting
included in the block. Now if we

1067
00:58:46.352 --> 00:58:50.352
scroll down even more, and we
click See more, we can also see

1068
00:58:50.352 --> 00:58:53.352
a ton of other information here.
For now we're just going to

1069
00:58:53.352 --> 00:58:57.353
click to see less and just focus
on these two. I'll explain all

1070
00:58:57.353 --> 00:59:01.353
of these in a later session.

1071
00:59:01.353 --> 00:59:02.353
Let's talk about just

1072
00:59:02.353 --> 00:59:06.354
the concept of transaction fees
and gas for a second. Remember

1073
00:59:06.354 --> 00:59:09.354
how I said the blockchain is run
by all these different nodes

1074
00:59:09.354 --> 00:59:12.354
will all those different nodes
are running this blockchain

1075
00:59:12.354 --> 00:59:15.355
because they actually get paid
for all the transactions that

1076
00:59:15.355 --> 00:59:19.355
happen on these blockchains
whenever you make a transaction,

1077
00:59:19.355 --> 00:59:23.356
there's a node or a miner or or
a validator somebody running the

1078
00:59:23.356 --> 00:59:28.356
blockchain software is gonna get
paid a tiny bit of Aetherium or

1079
00:59:28.356 --> 00:59:30.356
polygon or whatever blockchain
that you're running on, they're

1080
00:59:30.356 --> 00:59:34.357
gonna get paid a tiny bit of
that native blockchain currency.

1081
00:59:34.357 --> 00:59:37.357
This payment is obviously to
incentivize people to continue

1082
00:59:37.357 --> 00:59:40.357
to run nodes and they calculate
how much you pay and how much

1083
00:59:40.357 --> 00:59:43.358
the node operators get paid
based off of how much gas you

1084
00:59:43.358 --> 00:59:48.358
use. So there's this concept of
gas. Gas is a unit of

1085
00:59:48.358 --> 00:59:52.358
computational measure. The more
computation a transaction uses,

1086
00:59:52.358 --> 00:59:56.359
the more gas you'd have to pay
for. For example, we do hit

1087
00:59:56.359 --> 01:00:00.359
click More just really quickly.
We can see this section say A

1088
01:00:00.359 --> 01:00:04.360
gas limit and gas usage by
transaction, there was a limit

1089
01:00:04.360 --> 01:00:09.360
of 60,000 units of gas on this
transaction, and 21,000 or

1090
01:00:09.360 --> 01:00:15.361
actually use. So this
transaction use 21 units of gas.

1091
01:00:15.361 --> 01:00:19.361
Now for very simple things like
sending ether, the units of gas

1092
01:00:19.361 --> 01:00:22.361
are usually pretty cheap. But
maybe for more complex things

1093
01:00:22.361 --> 01:00:25.362
like like minting NFT,
depositing to some defy

1094
01:00:25.362 --> 01:00:30.362
contract, etc, maybe those will
cost more gas because they'll be

1095
01:00:30.362 --> 01:00:33.362
more computationally expensive.
And this is a little confusing

1096
01:00:33.362 --> 01:00:35.363
right now, don't worry too much
about it. But just know that we

1097
01:00:35.363 --> 01:00:39.363
use 21,000 gas here. And if we
pull out the calculator 21,000

1098
01:00:39.363 --> 01:00:45.364
gas times this gas price right
here, times the gas price, we

1099
01:00:45.364 --> 01:00:50.364
get the exact same as we see for
the transaction fee. So gas

1100
01:00:50.364 --> 01:00:55.365
price, times how much gas you
used, is the transaction fee. So

1101
01:00:55.365 --> 01:01:04.366
whoever sent us this 0.1 ether,
also paid 0.0000525, etc Rinkeby

1102
01:01:04.366 --> 01:01:07.366
ether to make this transaction.
Now, each blockchain has a

1103
01:01:07.366 --> 01:01:11.366
different way of actually
calculating how this gas stuff

1104
01:01:11.366 --> 01:01:14.367
works. So that's basically going
to be the high level of it. So

1105
01:01:14.367 --> 01:01:16.367
we're going to focus just here
for now there's a total

1106
01:01:16.367 --> 01:01:19.367
transaction fee. And then
there's obviously the gas price.

1107
01:01:19.367 --> 01:01:22.367
After we cover how blockchain
works, I'll explain what this

1108
01:01:22.367 --> 01:01:25.368
burn stuff is these gas fees and
all these other stuff. For now,

1109
01:01:25.368 --> 01:01:28.368
just know that anytime you make
a transaction on chain, you have

1110
01:01:28.368 --> 01:01:32.368
to pay a little bit of what I
call transaction gas. So for

1111
01:01:32.368 --> 01:01:35.369
example, if we go to our
Metamask, we have two accounts

1112
01:01:35.369 --> 01:01:39.369
right here, we have account one
was 0.1, Rinckey eath, and

1113
01:01:39.369 --> 01:01:46.370
account two was zero. Rigby. If
I were to send 0.05 Rinckey

1114
01:01:46.370 --> 01:01:50.370
eath. From this account to my
other account, how much rinky

1115
01:01:50.370 --> 01:01:53.371
eath Do you think I'd have left?
Well, let's go ahead and try it,

1116
01:01:54.371 --> 01:01:56.371
this will be the first
transaction that you're actually

1117
01:01:56.371 --> 01:02:00.371
creating that you are going to
spend the gas for. So if we go

1118
01:02:00.371 --> 01:02:03.371
ahead and hit send, we'll hit
transfer between my accounts.

1119
01:02:03.371 --> 01:02:07.372
count two, we'll do 0.05.

1120
01:02:07.372 --> 01:02:10.372
Next, we can see

1121
01:02:10.372 --> 01:02:13.372
some information here about
what's actually going on

1122
01:02:13.372 --> 01:02:17.373
Metamask has some new advanced
gas for UI and settings, we're

1123
01:02:17.373 --> 01:02:20.373
also going to turn the song, so
go ahead and click that enable

1124
01:02:20.373 --> 01:02:24.374
enhanced gas UI, turn that on,
and then go back. And again,

1125
01:02:24.374 --> 01:02:27.374
this is going to be the
experimental tab. But it could

1126
01:02:27.374 --> 01:02:29.374
also just be in the General
Settings tab. Depending on when

1127
01:02:29.374 --> 01:02:32.374
you actually run this, we can
see a little notification here.

1128
01:02:32.374 --> 01:02:35.375
Again, this depends on what
version of Metamask we're using.

1129
01:02:35.375 --> 01:02:38.375
And we get this little drop down
that says Here are some of the

1130
01:02:38.375 --> 01:02:41.375
different type of gas fees that
you can actually pay. The reason

1131
01:02:41.375 --> 01:02:45.376
that gas fees might change, as
you can see here is that

1132
01:02:45.376 --> 01:02:47.376
depending on how busy the
blockchain is, you have to pay

1133
01:02:47.376 --> 01:02:52.376
more gas. If a lot of people are
sending transactions, that means

1134
01:02:52.376 --> 01:02:55.377
there's not going to be enough
space for everyone's transaction

1135
01:02:55.377 --> 01:02:58.377
to get through. That's a bit of
an oversimplification of what's

1136
01:02:58.377 --> 01:03:00.377
happening. But don't worry too
much about it for now. Now, if

1137
01:03:00.377 --> 01:03:04.378
we want to send the 0.05 ether
to our second account, we can

1138
01:03:04.378 --> 01:03:08.378
see this gas estimated section,
which is saying it's estimating,

1139
01:03:08.378 --> 01:03:15.379
we're going to pay 0.00004792
gas in addition to sending the

1140
01:03:15.379 --> 01:03:19.379
0.5 eath. So at the bottom, we
have amount plus gas fee. And

1141
01:03:19.379 --> 01:03:22.379
this is going to be the total
amount that we're going to be

1142
01:03:22.379 --> 01:03:26.380
spending on this transaction
0.05 is what we're sending. And

1143
01:03:26.380 --> 01:03:30.380
we also have this gas piece. So
we go ahead and confirm, we now

1144
01:03:30.380 --> 01:03:34.381
see we have a transaction
pending in our Rigby ether scan.

1145
01:03:34.381 --> 01:03:39.381
And if we click on it, we can
even hit View on block Explorer.

1146
01:03:39.381 --> 01:03:42.381
And a Rigby transaction hash
will pop up and depending on

1147
01:03:42.381 --> 01:03:46.382
when you click it, it might say
indexing, this means that ether

1148
01:03:46.382 --> 01:03:49.382
scan has received your
transaction and is trying to

1149
01:03:49.382 --> 01:03:52.382
place it. If you don't see
anything here, it means that

1150
01:03:52.382 --> 01:03:54.383
maybe the transaction hasn't
gone through yet. Maybe you need

1151
01:03:54.383 --> 01:03:57.383
to wait a little bit more. Or
maybe you need to go back to the

1152
01:03:57.383 --> 01:04:00.383
GitHub repo and pick the
recommended testament and

1153
01:04:00.383 --> 01:04:03.383
faucet. So you might have to
wait a minute or so for this to

1154
01:04:03.383 --> 01:04:06.384
actually finish indexing. After
a minute or so we can see that

1155
01:04:06.384 --> 01:04:09.384
this transaction has indeed
passed. And we can see a lot of

1156
01:04:09.384 --> 01:04:13.384
the same information that we saw
on our last one, this time with

1157
01:04:13.384 --> 01:04:18.385
0.05 ether. And now if we look
in our meta mask, we'll see we

1158
01:04:18.385 --> 01:04:22.385
can see account one has 0.05
It's rounding up a little bit,

1159
01:04:22.385 --> 01:04:24.386
we click on the big button, we
can see it actually has

1160
01:04:24.386 --> 01:04:30.386
0.049953, etc. And our other
account account two does have

1161
01:04:30.386 --> 01:04:35.387
exactly 0.05. This is because we
spent a little bit of Aetherium

1162
01:04:35.387 --> 01:04:39.387
on gas to send this transaction.
And now with just this little

1163
01:04:39.387 --> 01:04:42.387
bit of information, you know how
to actually interact with

1164
01:04:42.387 --> 01:04:45.388
applications that use the
blockchain, how to send

1165
01:04:45.388 --> 01:04:48.388
transactions and a lot of the
non technical details. Now

1166
01:04:48.388 --> 01:04:50.388
here's something that's
incredibly exciting with just

1167
01:04:50.388 --> 01:04:53.388
this little bit of information.
You now know how to interact

1168
01:04:53.388 --> 01:04:56.389
with blockchains and interact
with the Etherion protocol. So

1169
01:04:56.389 --> 01:05:00.389
if you don't want to learn how
to code anything, you can go If

1170
01:05:00.389 --> 01:05:02.389
you can start interacting with
Aetherium and interact with

1171
01:05:02.389 --> 01:05:05.390
protocols with just as much
information. However, I know

1172
01:05:06.390 --> 01:05:08.390
most of you guys are here to
learn how to code. So let's look

1173
01:05:08.390 --> 01:05:11.390
under the hood of Aetherium. And
what is actually going on with

1174
01:05:11.390 --> 01:05:13.390
these transactions, and what
these gas and what these

1175
01:05:13.390 --> 01:05:17.391
blockchains. And what's really
going on, let's learn all the

1176
01:05:17.391 --> 01:05:19.391
fundamentals of a blockchain.
Now, if you want to just go

1177
01:05:19.391 --> 01:05:22.391
ahead and jump into the coding,
go ahead and grab a timestamp

1178
01:05:22.391 --> 01:05:26.392
from the description. However,
learning exactly how the

1179
01:05:26.392 --> 01:05:28.392
blockchain works is going to
make you an incredibly powerful

1180
01:05:28.392 --> 01:05:29.392
developer.

1181
01:05:29.392 --> 01:05:33.393
So let's take a look at that
first. So we're going to

1182
01:05:33.393 --> 01:05:36.393
be going through this blockchain
demo on this site right here.

1183
01:05:36.393 --> 01:05:39.393
Now, the creator of the site has
a fantastic video and a

1184
01:05:39.393 --> 01:05:41.393
fantastic walk through
blockchain one on one, it is

1185
01:05:41.393 --> 01:05:44.394
right on their site. So if
you're looking for another

1186
01:05:44.394 --> 01:05:47.394
explanation, definitely check
out his video, it is absolutely

1187
01:05:47.394 --> 01:05:49.394
fantastic. But the first thing
that we really need to do in

1188
01:05:49.394 --> 01:05:52.394
order to understand blockchain
or just on really anything, and

1189
01:05:52.394 --> 01:05:54.395
everything that's going on here
working first really need to

1190
01:05:54.395 --> 01:05:58.395
understand this Sha 256, hash,
or hashing just kind of in

1191
01:05:58.395 --> 01:06:01.395
general, let's first understand
what a hash is. A hash is a

1192
01:06:01.395 --> 01:06:06.396
unique fixed length string,
meant to identify any piece of

1193
01:06:06.396 --> 01:06:09.396
data, they are created by
putting some piece of data into

1194
01:06:09.396 --> 01:06:13.396
a hash function. In this
example, the hashing algorithm

1195
01:06:13.396 --> 01:06:18.397
used is Sha 256. Now Etherium
actually uses this, this right

1196
01:06:18.397 --> 01:06:22.397
here for its hashing algorithm,
which isn't quite Sha 256, but

1197
01:06:22.397 --> 01:06:26.398
as in kind of this SHA family.
But it's really just another way

1198
01:06:26.398 --> 01:06:30.398
to hash things. And the specific
hash algorithm doesn't matter so

1199
01:06:30.398 --> 01:06:34.399
much. So this example, you just
shot up to six, but you can

1200
01:06:34.399 --> 01:06:36.399
imagine it's the same as the
Etherium. Hash, they're just

1201
01:06:36.399 --> 01:06:40.399
going to result in a different
hash. So what's going to happen

1202
01:06:40.399 --> 01:06:44.400
in this application here is
whatever data or whatever

1203
01:06:44.400 --> 01:06:48.400
information we put into this
data section here, as you can

1204
01:06:48.400 --> 01:06:54.401
see below this hash changes. So
what's happening is this data is

1205
01:06:54.401 --> 01:06:59.401
running through the Sha 256 hash
algorithm. And it's outputting,

1206
01:06:59.401 --> 01:07:04.402
this unique hash. So this hash
is a unique fixed length string,

1207
01:07:04.402 --> 01:07:07.402
that's going to identify like a
blank data piece here, right. So

1208
01:07:07.402 --> 01:07:11.402
if I put in, you know, my name
like Patrick Collins, this is

1209
01:07:11.402 --> 01:07:14.403
the hash that's going to
represent Patrick Collins,

1210
01:07:14.403 --> 01:07:18.403
right. And you can see, even
when I put, you know, tons and

1211
01:07:18.403 --> 01:07:24.404
tons of data in here, the length
of the string doesn't change,

1212
01:07:24.404 --> 01:07:29.404
right. So it's always gonna be
the same, we can put almost any

1213
01:07:29.404 --> 01:07:32.404
amount of data in here, there is
an upper limit on the max size

1214
01:07:32.404 --> 01:07:36.405
of the data. But for all intents
purposes, we can pretty much put

1215
01:07:36.405 --> 01:07:39.405
any length in here. And you'll
see to that every time I type in

1216
01:07:39.405 --> 01:07:43.405
Patrick Collins, this hash is
always gonna be this seven e

1217
01:07:43.405 --> 01:07:46.406
five D, right? I'm gonna delete
I'm gonna do Patrick Collins,

1218
01:07:46.406 --> 01:07:50.406
again, you're 75 B is always
this, this unique hash is always

1219
01:07:50.406 --> 01:07:53.406
going to be unique, right, it's
always gonna be this fixed

1220
01:07:53.406 --> 01:07:57.407
length string here. So now we
can take this idea while putting

1221
01:07:57.407 --> 01:08:01.407
this data in here, we can move
on to this concept of a block.

1222
01:08:01.407 --> 01:08:04.408
So with this block concept,
we're going to take the exact

1223
01:08:04.408 --> 01:08:06.408
same thing with this hash this
this data section, right, but

1224
01:08:06.408 --> 01:08:09.408
instead of having everything
just being in this, this

1225
01:08:09.408 --> 01:08:12.408
singular data area right here,
we're going to split this data

1226
01:08:12.408 --> 01:08:16.409
up into block, nuns, and data.
So all so what we're going to do

1227
01:08:16.409 --> 01:08:20.409
is we're actually going to hash
all three of these to get to get

1228
01:08:20.409 --> 01:08:21.409
this hash, right, we're gonna
put all three of these, we're

1229
01:08:21.409 --> 01:08:24.410
gonna say all three of these are
combined. Together, we're gonna

1230
01:08:24.410 --> 01:08:28.410
put every all three of them into
this hashing algorithm to figure

1231
01:08:28.410 --> 01:08:31.410
it out. So if I type a bunch of
stuff here, we can see that

1232
01:08:31.410 --> 01:08:36.411
block one with nonce, you know,
this nonce, and this data, we're

1233
01:08:36.411 --> 01:08:39.411
going to get this hash. And as
you can see, actually, the

1234
01:08:39.411 --> 01:08:44.412
screen turns red, this block
turned red. Now, what happens

1235
01:08:44.412 --> 01:08:47.412
when I hit this mind button?
When I hit this mind button,

1236
01:08:47.412 --> 01:08:49.412
it's actually gonna take some
time, it's gonna think for a

1237
01:08:49.412 --> 01:08:53.412
little bit. And we can see that
the nonce here actually changed,

1238
01:08:53.412 --> 01:08:57.413
right? The nonce is different
from what it was before. And

1239
01:08:57.413 --> 01:09:02.413
this hash now starts with four
zeros. Okay, and then the back

1240
01:09:02.413 --> 01:09:04.414
turn green. When we're talking
about mining, we're talking

1241
01:09:04.414 --> 01:09:08.414
about miners solving some type
of very difficult problem that

1242
01:09:08.414 --> 01:09:12.414
takes a lot of time to do now in
this example, here, the problem

1243
01:09:12.414 --> 01:09:17.415
that the miners had to solve was
they had to find a nonce, or or

1244
01:09:17.415 --> 01:09:20.415
a value in this nonce section
that when hashed with at block

1245
01:09:20.415 --> 01:09:25.416
number one with this data, it
would start with four zeros. So

1246
01:09:25.416 --> 01:09:28.416
the problem here the miners had
to solve was to start with four

1247
01:09:28.416 --> 01:09:31.416
zeros and the only way for them
to really do that is kind of

1248
01:09:31.416 --> 01:09:33.416
this brute force, you know,
trying stuff so they tried one

1249
01:09:33.416 --> 01:09:38.417
okay, one didn't work. Okay,
two, nope, two didn't work. 3456

1250
01:09:38.417 --> 01:09:40.417
Okay, five, well, that started
with one zero, but it's not

1251
01:09:40.417 --> 01:09:43.417
four. And they have to keep
trying all these numbers until

1252
01:09:43.417 --> 01:09:50.418
they get to this one where you
know, let's hit mine again.

1253
01:09:50.418 --> 01:09:54.419
Where it has four zeros at the
top at the start. Now, this

1254
01:09:54.419 --> 01:09:56.419
specific problem changes
blockchain to blockchain right

1255
01:09:56.419 --> 01:10:00.419
yet. Aetherium has a different
problem for miners to solve A

1256
01:10:00.419 --> 01:10:02.419
bitcoin is different problems
from yourself, but this concept

1257
01:10:02.419 --> 01:10:07.420
is going to be the same. So they
have to take it, one block is

1258
01:10:07.420 --> 01:10:10.420
going to be this, this, this
concept is going to be all this

1259
01:10:10.420 --> 01:10:13.420
data, it's going to be the block
number. And it's going to be

1260
01:10:13.420 --> 01:10:18.421
this nonce, right. And so this
nonce is the solution is going

1261
01:10:18.421 --> 01:10:20.421
to be the the number that they
use to get like the solution to

1262
01:10:20.421 --> 01:10:24.422
the problem, right? So if I go
to one here, you know, I do this

1263
01:10:24.422 --> 01:10:27.422
again,

1264
01:10:27.422 --> 01:10:30.422
hit mine. And the nonces
changed, right? And went from

1265
01:10:30.422 --> 01:10:35.423
one to 33,128. Because this is
the nonce that allowed this hash

1266
01:10:35.423 --> 01:10:40.423
to start with four zeros. And so
that's what's happening. When

1267
01:10:40.423 --> 01:10:42.423
blockchain miners are mining
they're going through this

1268
01:10:42.423 --> 01:10:46.424
process is very computationally
intensive process of trying to

1269
01:10:46.424 --> 01:10:50.424
find a nonce that fulfills
whatever the problem is. So

1270
01:10:50.424 --> 01:10:52.424
that's really it, actually. So
that's a block. And that's

1271
01:10:52.424 --> 01:10:54.425
really what's happening when
miners are mining. They're just

1272
01:10:54.425 --> 01:10:57.425
looking, there's trial and
error, brute force trying to

1273
01:10:57.425 --> 01:11:00.425
find this nut so so now that we
know what a block is, let's go

1274
01:11:00.425 --> 01:11:03.425
to the next step and figure out
okay, well, what's a block

1275
01:11:03.425 --> 01:11:08.426
chain. So here we have an
example of what a blockchain is

1276
01:11:08.426 --> 01:11:11.426
going to look like. Right, we
have a combination, you know, we

1277
01:11:11.426 --> 01:11:13.426
have back here in the block
section, we have one what one

1278
01:11:13.426 --> 01:11:17.427
block looks like. Now here, we
have multiple different blocks,

1279
01:11:17.427 --> 01:11:20.427
right, each one of these
represents a different block,

1280
01:11:20.427 --> 01:11:23.427
but we have an additional column
here, we have additional

1281
01:11:23.427 --> 01:11:26.428
variable here. So like before,
you know, we have block nonce

1282
01:11:26.428 --> 01:11:30.428
and data, right, we have blocked
nonce data, we also have this

1283
01:11:30.428 --> 01:11:33.428
thing called previous right, and
so this is actually gonna be

1284
01:11:33.428 --> 01:11:38.429
pointing to the previous hash of
the last block. So for example,

1285
01:11:38.429 --> 01:11:41.429
if we go to the last block in
this blockchain, it says

1286
01:11:41.429 --> 01:11:45.430
previous 008. And if we look at
the hash of block number four,

1287
01:11:45.430 --> 01:11:50.430
is 00008. And then we look at
its previous it's four zeros, B

1288
01:11:50.430 --> 01:11:54.430
nine, we have four zeros, B,
nine, and so on, all the way

1289
01:11:54.430 --> 01:11:58.431
back to our first block, which
has previous of just all zeros,

1290
01:11:58.431 --> 01:12:02.431
right. And so the block with the
previous of all zeros, is going

1291
01:12:02.431 --> 01:12:04.432
to be known as the Genesis
block. So you've probably heard

1292
01:12:04.432 --> 01:12:07.432
that before the Genesis block,
it's the first block in the

1293
01:12:07.432 --> 01:12:10.432
blockchain were the previous
hash points to a hash that

1294
01:12:10.432 --> 01:12:13.432
doesn't actually exist. Now, as
you can imagine, kind of the

1295
01:12:13.432 --> 01:12:17.433
same as how this block worked,
how the block nuts and dated all

1296
01:12:17.433 --> 01:12:20.433
go through the hashing algorithm
in the blockchain, the block

1297
01:12:20.433 --> 01:12:24.433
nonce data, and previous hash
all go through this hashing

1298
01:12:24.433 --> 01:12:28.434
algorithm to figure out what the
hashes okay? So if we go to over

1299
01:12:28.434 --> 01:12:31.434
here, you know, for example, if
I type in Patrick, obviously,

1300
01:12:31.434 --> 01:12:35.435
this is now no longer valid,
right? Because this nuns

1301
01:12:35.435 --> 01:12:37.435
combined with the block the data
in the previous hash, aren't

1302
01:12:37.435 --> 01:12:41.435
going to solve our problem of
having four zeros at the at the

1303
01:12:41.435 --> 01:12:44.436
start, right. So I'm gonna go
and fix that. And that's, that's

1304
01:12:44.436 --> 01:12:47.436
kind of an easy way to see it
being broken. But, but let's

1305
01:12:47.436 --> 01:12:51.436
take a look, if I break this
block, right here, what happens

1306
01:12:51.436 --> 01:12:54.437
if I, if I break the data in
here, if I do like Patrick in

1307
01:12:54.437 --> 01:12:59.437
here, you can see that both of
these are now read, both of

1308
01:12:59.437 --> 01:13:03.437
these are now invalid, right?
Because the block hash with the

1309
01:13:03.437 --> 01:13:07.438
nonce hash with the new data,
which is my name, Patrick has

1310
01:13:07.438 --> 01:13:11.438
hashed with the previous block
is now a brand new hash, right,

1311
01:13:11.438 --> 01:13:15.439
and this block is still pointing
to this previous hash right

1312
01:13:15.439 --> 01:13:19.439
here, right is pointing to this
previous block. And now it is

1313
01:13:19.439 --> 01:13:24.439
wrong, and it is messed up and
now, and now it's nuts with this

1314
01:13:24.439 --> 01:13:28.440
previous hash is also wrong.
Right? And this is where when we

1315
01:13:28.440 --> 01:13:32.440
talk about blockchains, being
immutable, this is exactly how

1316
01:13:32.440 --> 01:13:35.441
it's immutable, right? Because I
go back and I change anything,

1317
01:13:35.441 --> 01:13:39.441
you know, if I've just typed a
right here, the entire

1318
01:13:39.441 --> 01:13:42.441
blockchain is now invalidated.
Because none of these are going

1319
01:13:42.441 --> 01:13:47.442
to have nonces that solve this
equation anymore. So this is why

1320
01:13:47.442 --> 01:13:50.442
blockchains are immutable is
because anytime you change one

1321
01:13:50.442 --> 01:13:54.443
thing, you ruin the rest of the
blockchain, okay? So however,

1322
01:13:54.443 --> 01:13:57.443
though, you know, if it was
here, originally, we can go

1323
01:13:57.443 --> 01:14:00.443
ahead and mine these, mine all
these but as you can see, you

1324
01:14:00.443 --> 01:14:03.443
know, this is going to start
getting very computationally

1325
01:14:03.443 --> 01:14:07.444
expensive, because I have to go
redo basically the entire

1326
01:14:07.444 --> 01:14:10.444
blockchain. And the farther and
farther down the line you get,

1327
01:14:10.444 --> 01:14:13.444
the harder and harder it becomes
to, you know, rehash and redo

1328
01:14:13.444 --> 01:14:16.445
all these different block chains
here. Now, this makes a lot of

1329
01:14:16.445 --> 01:14:17.445
sense, right? So we have this
blockchain, it's really hard to

1330
01:14:17.445 --> 01:14:19.445
change something in the past,
but if we do, we can just go

1331
01:14:19.445 --> 01:14:22.445
ahead and remind it. Now if I'm
the one who controls the

1332
01:14:22.445 --> 01:14:25.446
blockchain, right, if I'm the
one who controls this, you know,

1333
01:14:25.446 --> 01:14:27.446
and I want to change something,
the past will, okay, great. All

1334
01:14:27.446 --> 01:14:30.446
I got to do is change the state
of here. And then you know,

1335
01:14:30.446 --> 01:14:32.446
mine, each one of these, you
know, obviously, it's going to

1336
01:14:32.446 --> 01:14:34.447
be very computationally
expensive, but it's something

1337
01:14:34.447 --> 01:14:39.447
that I can do right if I'm the
one who owns the blockchain.

1338
01:14:39.447 --> 01:14:42.447
Now, here's where the
decentralized nature or the

1339
01:14:42.447 --> 01:14:47.448
distributed nature really makes
it incredibly powerful. So we're

1340
01:14:47.448 --> 01:14:50.448
gonna go to the distributed tab
here, which is also referred to

1341
01:14:50.448 --> 01:14:53.448
as the decentralized tab here,
and it's going to show us what a

1342
01:14:53.448 --> 01:14:57.449
blockchain looks like in a
decentralized manner. So we have

1343
01:14:57.449 --> 01:15:00.449
this exact same initial setup
here we have to Shoot a

1344
01:15:00.449 --> 01:15:02.449
blockchain, we have our first
blockchain, which is kind of

1345
01:15:02.449 --> 01:15:06.450
exactly as the one from here.
But we also have more than once

1346
01:15:06.450 --> 01:15:10.450
we have peer, a peer beam, and
PRC and when people are talking

1347
01:15:10.450 --> 01:15:12.450
about Peer to Peer, peer to peer
transactions through the

1348
01:15:12.450 --> 01:15:15.451
talking, this is kind of that
concept that they're talking

1349
01:15:15.451 --> 01:15:18.451
about, right. So we have a
number of different peers who

1350
01:15:18.451 --> 01:15:20.451
are running this blockchain
technology, they're all weighted

1351
01:15:20.451 --> 01:15:23.451
equally, right, each one of
these peers or each one of these

1352
01:15:23.451 --> 01:15:27.452
nodes, each one of these
entities running a blockchain

1353
01:15:27.452 --> 01:15:32.452
has the exact same power as
anybody else, right. So the way

1354
01:15:32.452 --> 01:15:36.453
that we can tell very easily
which blockchain is correct, or

1355
01:15:36.453 --> 01:15:40.453
which ones are correct, or by
looking at this end, hash here,

1356
01:15:40.453 --> 01:15:44.453
right, or by looking at where we
are in the blockchain, because

1357
01:15:44.453 --> 01:15:47.454
again, remember, because again,
remember this, this hash that

1358
01:15:47.454 --> 01:15:52.454
this this in this last block
here, is going to encompass all

1359
01:15:52.454 --> 01:15:55.455
of the blocks from before,
right, because this last hash is

1360
01:15:55.455 --> 01:15:58.455
going to have the previous hash
here, which includes the

1361
01:15:58.455 --> 01:16:01.455
previous hash here, which this
hash includes the previous hash

1362
01:16:01.455 --> 01:16:05.456
here. And so this last hash is
encompasses everything in here,

1363
01:16:05.456 --> 01:16:08.456
right? And we can look, we can
look at the hash of Piercey,

1364
01:16:08.456 --> 01:16:11.456
which is four zeros, and then E
four B, we can look at the

1365
01:16:11.456 --> 01:16:15.457
latest hash appear B, which is
four zeros, E for B, and then

1366
01:16:15.457 --> 01:16:19.457
pure A, which is four zeros, E
for b. So all of these peers,

1367
01:16:19.457 --> 01:16:23.457
all of these nodes, all of these
decentralized, you know these

1368
01:16:23.457 --> 01:16:27.458
independent, all these
independent users running this

1369
01:16:27.458 --> 01:16:30.458
blockchain software, they're all
matched up, it's very easy for

1370
01:16:30.458 --> 01:16:32.458
their nodes to look at each
other and say, hey, great, we

1371
01:16:32.458 --> 01:16:37.459
are all matched up. Now, what
let's say that a decides that,

1372
01:16:37.459 --> 01:16:40.459
you know, something happened on
the blockchain that they didn't

1373
01:16:40.459 --> 01:16:43.459
like, and they wanted to go back
and change something, right. So

1374
01:16:43.459 --> 01:16:46.460
let's say they change here, you
know, obviously, the rest of

1375
01:16:46.460 --> 01:16:49.460
their blockchain is invalidated.
And they have to spend a lot of

1376
01:16:49.460 --> 01:16:52.460
computational power to catch up
to speed. So let's go ahead and

1377
01:16:52.460 --> 01:16:55.461
humor it. Let's say that they
did, they ended up catching up.

1378
01:16:55.461 --> 01:16:57.461
They ended up catching up, you
know, they ended up mining

1379
01:16:57.461 --> 01:17:01.461
everything. And now they have a
valid blockchain. Right? It

1380
01:17:01.461 --> 01:17:06.462
solves the equation. Awesome.
However, in block number three,

1381
01:17:06.462 --> 01:17:10.462
there's something new, right?
This is here, and it shouldn't

1382
01:17:10.462 --> 01:17:12.462
have been here, this is some
that Peer A put in by

1383
01:17:12.462 --> 01:17:17.463
themselves. All that happens now
is we look at all the

1384
01:17:17.463 --> 01:17:21.463
blockchains that are running the
software, and we're looking at

1385
01:17:21.463 --> 01:17:25.464
all the hashes and hash at block
number five. So pure A has this

1386
01:17:25.464 --> 01:17:31.464
new hash. Now, there's a 09 BC.
But pure B has a different hash

1387
01:17:31.464 --> 01:17:35.465
00, e for B, right? So who's
right? Is it disappear a with

1388
01:17:35.465 --> 01:17:39.465
their new stuff? Or is it pure
B? Well, that's where the

1389
01:17:39.465 --> 01:17:40.465
decentralized data comes in.
Because then we can look at

1390
01:17:40.465 --> 01:17:45.466
Piercey Piercey, also as E
forby. So if you're being

1391
01:17:45.466 --> 01:17:50.466
Piercey will say, Hey, you're a,
you're wrong, get out, right.

1392
01:17:50.466 --> 01:17:52.466
And pure A will stop being able
to participate in the mining

1393
01:17:52.466 --> 01:17:56.467
rewards because they have
essentially forked the

1394
01:17:56.467 --> 01:17:59.467
blockchain and started their own
little blockchain right with

1395
01:17:59.467 --> 01:18:02.467
their own history, because
they're the only ones with this,

1396
01:18:02.467 --> 01:18:07.468
this piece of data in block
three, whereas pure B, and pure

1397
01:18:07.468 --> 01:18:10.468
C have nothing in there. So that
really shows why in these

1398
01:18:10.468 --> 01:18:12.468
blockchain worlds in this
decentralized world, there

1399
01:18:12.468 --> 01:18:15.469
really is no centralized entity,
you know, pure A, you know,

1400
01:18:15.469 --> 01:18:18.469
might have been maliciously
motivated to change. You know,

1401
01:18:18.469 --> 01:18:21.469
there's this block number three,
however, democracy rules, right,

1402
01:18:21.469 --> 01:18:24.470
the majority rules in the
blockchain, pure vmpfc will say,

1403
01:18:24.470 --> 01:18:28.470
hey, you know, the, that's cute
and all puree. But you're wrong,

1404
01:18:28.470 --> 01:18:31.470
right? That's not right. Now, it
might be a little abstract, that

1405
01:18:31.470 --> 01:18:33.470
you just look at data and you
know, as typing kind of random

1406
01:18:33.470 --> 01:18:36.471
stuff in here and think, okay,
yeah, that's, that's data,

1407
01:18:36.471 --> 01:18:38.471
right? That makes sense, you
know, just kind of random

1408
01:18:38.471 --> 01:18:41.471
strings in here doesn't really
do anything for us. So if we

1409
01:18:41.471 --> 01:18:44.471
actually go over to the token
section here, this is where

1410
01:18:44.471 --> 01:18:47.472
everything really starts to make
a lot of sense. So we have the

1411
01:18:47.472 --> 01:18:52.472
exact same setup here with pure
a pure B Piercey. Except and the

1412
01:18:52.472 --> 01:18:55.473
difference is, instead of having
kind of this, this data section,

1413
01:18:55.473 --> 01:18:59.473
we have this TX This transaction
section, right? And this

1414
01:18:59.473 --> 01:19:03.473
represents all the transactions
that are happening in this

1415
01:19:03.473 --> 01:19:08.474
block, right? So we're sending
$25, from Darcy to Bingle, or to

1416
01:19:08.474 --> 01:19:13.474
Bingley force toward dollars and
27 cents here. 1922, right. And

1417
01:19:13.474 --> 01:19:17.475
it's the exact same thing. So
this, all these transactions are

1418
01:19:17.475 --> 01:19:20.475
gonna get hashed in the exact
same way that the data is going

1419
01:19:20.475 --> 01:19:23.475
to get hashed. And, and this is
why it's so powerful, because

1420
01:19:23.475 --> 01:19:26.476
again, you know, if I want to be
malicious, right, if, if I want

1421
01:19:26.476 --> 01:19:30.476
to say, hey, I really wanted to
give Jane a lot more money from

1422
01:19:30.476 --> 01:19:33.476
Elizabeth, so I'm puree and I go
back and I change it to 100.

1423
01:19:33.476 --> 01:19:37.477
Well, now, you know not only do
I does my whole blockchain get

1424
01:19:37.477 --> 01:19:41.477
invalidated because that was so
so long ago, but I'm not going

1425
01:19:41.477 --> 01:19:43.477
to match any of these other
chains. Right? And so my

1426
01:19:43.477 --> 01:19:46.478
blockchain is going to be
excluded from the overall

1427
01:19:46.478 --> 01:19:50.478
blockchain. So and let's let's
go ahead and fix this. And it's

1428
01:19:50.478 --> 01:19:53.478
the same thing if down here if I
become malicious, and I want to

1429
01:19:53.478 --> 01:19:56.479
send you know, I want

1430
01:19:56.479 --> 01:19:59.479
Miss Audrey to have less money.
Maybe I want to send $1 And they

1431
01:19:59.479 --> 01:20:04.479
go had in mind it the same thing
here, this hash now this two a

1432
01:20:04.479 --> 01:20:11.480
one is not going to match the
rubies rubies hash of BBA. And

1433
01:20:11.480 --> 01:20:14.480
it's not going to match Pierce's
hash of BBA as well. So the two

1434
01:20:14.480 --> 01:20:17.481
of them are gonna say, hey,
this, your blockchain is

1435
01:20:17.481 --> 01:20:20.481
invalid, it's not matching the
majority, you know, you're out,

1436
01:20:20.481 --> 01:20:25.482
right. So that's really how
these blockchains work at a low

1437
01:20:25.482 --> 01:20:28.482
level. And it all goes back to
this, this understanding this

1438
01:20:28.482 --> 01:20:32.482
hash idea, and using it in this
very sophisticated manner, to

1439
01:20:32.482 --> 01:20:36.483
kind of cryptographically prove,
you know, where, where stuff

1440
01:20:36.483 --> 01:20:38.483
lies. Now, the way the
blockchain works is, instead of

1441
01:20:39.483 --> 01:20:41.483
random stuff, put in the Status
section, it's actually going to

1442
01:20:41.483 --> 01:20:44.483
be solidity code in here to
finding ways to interact with

1443
01:20:44.483 --> 01:20:48.484
different blocks and different
protocols that are on chain, or,

1444
01:20:48.484 --> 01:20:52.484
as we've said before, different
smart contracts. Now, the next

1445
01:20:52.484 --> 01:20:56.485
question that you might be
asking is, okay, well, how do I

1446
01:20:56.485 --> 01:21:00.485
know how can I be sure that I'm
the one? You know, let's say

1447
01:21:00.485 --> 01:21:03.485
this is, let's say, I'm Darcy
right? How can I be sure that I

1448
01:21:03.485 --> 01:21:06.486
was that Darcy was the one to
actually send us money here. How

1449
01:21:06.486 --> 01:21:11.486
do we know that Darcy sent $25.
To Bingley? Well, this is where

1450
01:21:11.486 --> 01:21:15.487
we get into private keys and
public keys. And that's what

1451
01:21:15.487 --> 01:21:18.487
we're going to go into. Now.
Let's just do a quick recap of

1452
01:21:18.487 --> 01:21:20.487
what we've learned in this
section. So far, right? We've

1453
01:21:20.487 --> 01:21:25.488
learned that Aetherium actually
runs on this hit check 256. But

1454
01:21:25.488 --> 01:21:28.488
we use Sha 256. For this demo,
it doesn't really matter. We're

1455
01:21:28.488 --> 01:21:33.488
just talking about hashing
algorithms. So again, hash is a

1456
01:21:33.488 --> 01:21:38.489
unique fixed length string meant
to identify any piece of data. A

1457
01:21:39.489 --> 01:21:42.489
hash algorithm or a hash
function is a function or

1458
01:21:42.489 --> 01:21:47.490
algorithm that computes any type
of data into a unique hash.

1459
01:21:47.490 --> 01:21:50.490
Mining is going to be the
process of finding the solution

1460
01:21:50.490 --> 01:21:53.490
to the blockchain problem. In
our example, the problem was

1461
01:21:53.490 --> 01:21:57.491
finding a hash that starts with
four zeros. nodes get paid for

1462
01:21:57.491 --> 01:22:00.491
mining different blocks. And the
problem is going to be different

1463
01:22:00.491 --> 01:22:03.491
blockchain to blockchain a block
and a blockchain is basically a

1464
01:22:03.491 --> 01:22:07.492
combination of a block, nonce
transaction and previous hash to

1465
01:22:07.492 --> 01:22:11.492
create this unique hash for this
block. And again, depending on

1466
01:22:11.492 --> 01:22:13.492
the blockchain implementation,
this might have a couple other

1467
01:22:13.492 --> 01:22:16.493
fields or might have different
fields. But this is essentially

1468
01:22:16.493 --> 01:22:19.493
what's going on blockchains are
decentralized and distributed

1469
01:22:19.493 --> 01:22:22.493
because many independent users
are going to run this blockchain

1470
01:22:22.493 --> 01:22:25.494
software. And they will check
and then we'll compare against

1471
01:22:25.494 --> 01:22:27.494
each other to see which
blockchains are acting honestly,

1472
01:22:27.494 --> 01:22:30.494
and which ones are acting
maliciously, in the blockchain

1473
01:22:30.494 --> 01:22:35.495
world majority rules. The nonce
here is the answer used or the

1474
01:22:35.495 --> 01:22:39.495
number used to get this hash.
Now nonce is kind of an

1475
01:22:39.495 --> 01:22:41.495
overloaded term, it's actually
used for a number of different

1476
01:22:41.495 --> 01:22:44.495
reasons. In this case, we're
using it to solve this problem

1477
01:22:44.495 --> 01:22:48.496
of getting four or five zeros at
the stop or the hash. However,

1478
01:22:48.496 --> 01:22:51.496
in Aetherium, it will also be
often used as the number of

1479
01:22:51.496 --> 01:22:56.497
transactions from a given
address.

1480
01:22:56.497 --> 01:22:58.497
So now we're going to talk a
little bit about signing these

1481
01:22:58.497 --> 01:23:01.497
transactions and private keys
and some other cryptography

1482
01:23:01.497 --> 01:23:04.497
pieces, right? Because in this
blockchain demo here, we can see

1483
01:23:04.497 --> 01:23:06.498
we have all these these
fantastic transactions, right?

1484
01:23:06.498 --> 01:23:09.498
All these things went through,
but how do we know that it was

1485
01:23:09.498 --> 01:23:14.498
Darcy? Who was the one to send
$25? To bangli? Right? How do we

1486
01:23:14.498 --> 01:23:18.499
know that actually happened. And
this is where all those pieces

1487
01:23:18.499 --> 01:23:22.499
that we just learned about in
our test net, in our meta mask

1488
01:23:22.499 --> 01:23:25.500
account are really going to
start to, to come to life here a

1489
01:23:25.500 --> 01:23:29.500
little bit here. So here we have
an example of public and private

1490
01:23:29.500 --> 01:23:33.500
keys, okay, at the top, we have
this private key, right that was

1491
01:23:33.500 --> 01:23:37.501
that was randomly generated. A
private key is you know, as it

1492
01:23:37.501 --> 01:23:39.501
kind of states is a key that you
really want to keep secret,

1493
01:23:39.501 --> 01:23:43.501
because you're going to be using
this as kind of your your secret

1494
01:23:43.501 --> 01:23:45.502
password for all your
transactions where I can really

1495
01:23:45.502 --> 01:23:49.502
pick, you know, any, any, any
private key, anything that I

1496
01:23:49.502 --> 01:23:54.502
want. And with it, this
algorithm, or they're going to

1497
01:23:54.502 --> 01:23:56.503
use an algorithm for Aetherium.
Bitcoin, they both use this

1498
01:23:56.503 --> 01:24:00.503
elliptic curve, digital
signature algorithm, it's a

1499
01:24:00.503 --> 01:24:03.503
variant of just a digital
signature algorithm. And it's

1500
01:24:03.503 --> 01:24:05.504
going to create this this public
key, right, I'm really not going

1501
01:24:05.504 --> 01:24:09.504
to go at all into kind of this
digital signature algorithm. But

1502
01:24:09.504 --> 01:24:13.504
just know it does use some of
these, some of the hash

1503
01:24:13.504 --> 01:24:16.505
knowledge that we just learned
combined with some other pieces

1504
01:24:16.505 --> 01:24:18.505
to kind of get this this public
here. So I'm not gonna go too

1505
01:24:18.505 --> 01:24:22.505
deep into it. But we have this
private key that we create. And

1506
01:24:22.505 --> 01:24:26.506
we get this public key. Now this
public key we want everybody to

1507
01:24:26.506 --> 01:24:28.506
have access to right this is
yeah, whole world can see this,

1508
01:24:28.506 --> 01:24:32.506
this private key, we really want
it to be private, we don't want

1509
01:24:32.506 --> 01:24:35.507
people to see this, we're going
to use this private key as like

1510
01:24:35.507 --> 01:24:40.507
a password to quote unquote,
digitally sign transactions, and

1511
01:24:40.507 --> 01:24:44.507
then people can verify them with
this public key. So let's, let's

1512
01:24:44.507 --> 01:24:46.508
see what this actually looks
like. Let's pick a random key, a

1513
01:24:46.508 --> 01:24:49.508
more secure key, right? Because
the longer it is, the more

1514
01:24:49.508 --> 01:24:54.508
secure it's going to be. And if
we go to signatures now, right?

1515
01:24:54.508 --> 01:24:57.509
Let's say we have this, this
message that we want, right?

1516
01:24:57.509 --> 01:25:00.509
We'll say hi world, right? We
want this To be the message,

1517
01:25:00.509 --> 01:25:04.509
what's gonna happen is this
private key that we've created,

1518
01:25:04.509 --> 01:25:07.510
we can use to sign this data,
right? Remember how in the

1519
01:25:07.510 --> 01:25:10.510
blockchain demo, you know, we
were kind of we were hashing

1520
01:25:10.510 --> 01:25:14.510
stuff, right? We were using this
Shea 256 hash to get this hash.

1521
01:25:14.510 --> 01:25:17.511
Well, we're doing something
similar. But instead of hashing,

1522
01:25:17.511 --> 01:25:20.511
we're, we're using this digital
signature algorithm to create

1523
01:25:20.511 --> 01:25:24.511
this message signature. Now,
what's really powerful about how

1524
01:25:24.511 --> 01:25:28.512
this this algorithm works, is
that you can create this message

1525
01:25:28.512 --> 01:25:33.512
signature with your private key,
but somebody else can't derive

1526
01:25:33.512 --> 01:25:36.513
your private key from the
message signature. And that's

1527
01:25:36.513 --> 01:25:39.513
what makes this really, really
powerful. However, if we go to

1528
01:25:39.513 --> 01:25:43.513
verify using this public key,
right, and so this is the this

1529
01:25:43.513 --> 01:25:47.514
is that, Oh, 403. This is that
same public key, using this,

1530
01:25:47.514 --> 01:25:51.514
using this public key, anybody
can verify, let's go ahead and

1531
01:25:51.514 --> 01:25:57.515
sign again, anybody can verify
that the signature is yours,

1532
01:25:57.515 --> 01:26:01.515
right? So you have a public a
private key, just for you. So

1533
01:26:01.515 --> 01:26:04.515
you can sign things and a public
key that anybody can verify

1534
01:26:04.515 --> 01:26:07.516
something, right. So anybody can
verify this, and let's say

1535
01:26:07.516 --> 01:26:10.516
somebody tries to fake a
transaction from you, they say,

1536
01:26:10.516 --> 01:26:15.517
Hey, you know, this is this is
this is their transaction, all

1537
01:26:15.517 --> 01:26:19.517
they have to do is verify that
this signature against your

1538
01:26:19.517 --> 01:26:24.517
public key and very easily, this
whole thing turns red, because

1539
01:26:24.517 --> 01:26:27.518
it isn't verified, right, that
the algorithm says, hey, that's

1540
01:26:27.518 --> 01:26:31.518
wrong. So we can go ahead and
take that into transactions in

1541
01:26:31.518 --> 01:26:35.518
this exact same way. So if I
want to send money, you know, if

1542
01:26:35.518 --> 01:26:40.519
I want to send $400, from, you
know, my address to another

1543
01:26:40.519 --> 01:26:45.520
address, using my private key, I
can sign that transaction. And

1544
01:26:45.520 --> 01:26:49.520
anybody else in the world can
then verify this transaction,

1545
01:26:49.520 --> 01:26:52.520
right. And this is why when
people say Hydra keys, you know,

1546
01:26:52.520 --> 01:26:55.520
protect your keys, this is what
we're talking about in our

1547
01:26:55.520 --> 01:27:00.521
accounts here. Right? If we go
to settings, and again, the only

1548
01:27:00.521 --> 01:27:03.521
reason that I'm showing you
guys, my pneumonic, and my

1549
01:27:03.521 --> 01:27:06.522
private key is because this is
a, this is a dumpster account,

1550
01:27:06.522 --> 01:27:08.522
I'm going to throw this away at
the end of this video, or I'm

1551
01:27:08.522 --> 01:27:15.523
just not gonna put any real
money in it. But when we look at

1552
01:27:15.523 --> 01:27:19.523
our Metamask, here, we have this
pneumonic phrase, which allows

1553
01:27:19.523 --> 01:27:24.523
us to easily get these different
private keys, right? So

1554
01:27:24.523 --> 01:27:28.524
pneumonic phrase combined with,
you know, whatever account

1555
01:27:28.524 --> 01:27:31.524
number will get us a private
key. So mnemonic phrase combined

1556
01:27:31.524 --> 01:27:34.524
with one, we're gonna get this
private key. And this is when we

1557
01:27:34.524 --> 01:27:40.525
look at account details, export
private key.

1558
01:27:40.525 --> 01:27:44.525
That's where it confirm, this is
going to be the private key that

1559
01:27:44.525 --> 01:27:47.526
we're going to use to sign our
transactions, right, this, if

1560
01:27:47.526 --> 01:27:50.526
anybody else gets access to this
private key, they then can sign

1561
01:27:50.526 --> 01:27:54.526
transactions for us, and they
can send transactions for us.

1562
01:27:54.526 --> 01:27:57.527
And that's why we want to keep
these private, so that it works

1563
01:27:57.527 --> 01:28:00.527
the exact same way, right. And
so this is why it's so important

1564
01:28:00.527 --> 01:28:03.527
to hide your private keys and
hide your mnemonics now, your

1565
01:28:03.527 --> 01:28:11.528
Aetherium address is actually a
piece is actually a piece of

1566
01:28:11.528 --> 01:28:15.529
your public key. Now, to get our
address in Aetherium, all we

1567
01:28:15.529 --> 01:28:17.529
have to do is take this public
key that we've created with our

1568
01:28:17.529 --> 01:28:21.529
private key, hash it using that
same Aetherium hashing

1569
01:28:21.529 --> 01:28:23.529
algorithm, and then take the
last 20 bytes. And that's how

1570
01:28:23.529 --> 01:28:28.530
we'll actually derive to our to
our address here. Now, knowing

1571
01:28:28.530 --> 01:28:31.530
the exact methodology of how to
get the address doesn't really

1572
01:28:31.530 --> 01:28:34.530
matter, because it could change
blockchain to blockchain and

1573
01:28:34.530 --> 01:28:36.531
could even change it too. But
just know that that is

1574
01:28:36.531 --> 01:28:39.531
essentially how kind of these
addresses are derived or there's

1575
01:28:39.531 --> 01:28:43.531
some derivative of the public
key, right, because the public

1576
01:28:43.531 --> 01:28:46.532
key is public. And you know,
using the public key and kind of

1577
01:28:46.532 --> 01:28:50.532
any public way is totally fine,
but not the private key. So that

1578
01:28:50.532 --> 01:28:53.532
is how we sign our transactions.
Note though, this isn't how we

1579
01:28:53.532 --> 01:28:56.533
send the transaction. So so this
is just going to assign it

1580
01:28:56.533 --> 01:29:00.533
create a transaction for us to
send, we'll learn later on how

1581
01:29:00.533 --> 01:29:02.533
to send these transactions.
Cool. So that was a lot of

1582
01:29:02.533 --> 01:29:06.534
information there too. Let's do
a quick recap, your public key

1583
01:29:06.534 --> 01:29:10.534
is derived by using a digital
signature algorithm on your

1584
01:29:10.534 --> 01:29:13.534
private key, right, and you want
to keep your private key private

1585
01:29:13.534 --> 01:29:16.535
at all times, because you're
going to use your private key to

1586
01:29:16.535 --> 01:29:20.535
sign transactions. Signing
transactions with your private

1587
01:29:20.535 --> 01:29:23.535
key, you are the only one who
can actually do this because you

1588
01:29:23.535 --> 01:29:27.536
can't get the private key from a
message signature. However,

1589
01:29:27.536 --> 01:29:32.536
using your public key, you can
anybody can very easily verify

1590
01:29:32.536 --> 01:29:35.537
that a signature that signed by
you is in fact signed by you in

1591
01:29:35.537 --> 01:29:39.537
our meta mask. Our private keys
are located in this account

1592
01:29:39.537 --> 01:29:43.537
details section you just hit
show private keys and type in

1593
01:29:43.537 --> 01:29:46.538
your password. And you'll get
your your private key here. A

1594
01:29:46.538 --> 01:29:49.538
quick note here is oftentimes
when using your private keys

1595
01:29:49.538 --> 01:29:52.538
somewhere, they want it in
hexadecimal form. So if we're

1596
01:29:52.538 --> 01:29:56.539
going to use our private key for
something like brownie, which

1597
01:29:56.539 --> 01:29:59.539
we'll go into later, we need to
actually append a 0x to the

1598
01:29:59.539 --> 01:30:03.539
front but We'll get into that
later. And the address of your

1599
01:30:03.539 --> 01:30:07.540
account is derived from this. So
if you think about your private

1600
01:30:07.540 --> 01:30:11.540
key creates your public key,
which then can create your

1601
01:30:11.540 --> 01:30:16.541
address. And there's a little
barrier or a big barrier here.

1602
01:30:16.541 --> 01:30:18.541
Because your private key, you
want to keep private and your

1603
01:30:18.541 --> 01:30:27.542
public key and your address can
all be public information.

1604
01:30:27.542 --> 01:30:28.542
Now that we know a little

1605
01:30:28.542 --> 01:30:31.542
bit more about what's going on
underneath the hood of these

1606
01:30:31.542 --> 01:30:34.542
blockchains, let's go back at
our transactions and look at

1607
01:30:34.542 --> 01:30:36.543
this gas thing again, and we'll
look to see what's actually

1608
01:30:36.543 --> 01:30:39.543
happening here, gas in
particular can be a little bit

1609
01:30:39.543 --> 01:30:42.543
tricky to wrap your head around.
So if you don't get it right

1610
01:30:42.543 --> 01:30:45.543
away, don't worry. As we go
through examples, it'll start to

1611
01:30:45.543 --> 01:30:48.544
make more sense. So before I was
saying, let's just look at this

1612
01:30:48.544 --> 01:30:51.544
transaction fee bid, which is
the costs associated with

1613
01:30:51.544 --> 01:30:54.544
running this transaction. If I
scroll over this on ether scan,

1614
01:30:54.544 --> 01:30:57.545
I can see this thing that says
block base fee per gas plus max

1615
01:30:57.545 --> 01:31:01.545
party fee per gas times the gas
use, which might be a little bit

1616
01:31:01.545 --> 01:31:04.545
confusing here, let's actually
break down what's going on on

1617
01:31:04.545 --> 01:31:08.546
Aetherium with ERP 15, five nine
in place. And again, this is

1618
01:31:08.546 --> 01:31:10.546
going to be specific to
Aetherium, as every blockchain

1619
01:31:10.546 --> 01:31:12.546
might do it a little bit
differently. But if we click to

1620
01:31:12.546 --> 01:31:15.547
see more, we can see a number of
useful values here, we can see

1621
01:31:15.547 --> 01:31:21.547
gas limit is 21,000. And usage
is 21,000. So this transaction

1622
01:31:21.547 --> 01:31:26.548
used 21,000 gas, and we sent
21,000 gas along with it.

1623
01:31:26.548 --> 01:31:29.548
Sometimes when sending a
transaction, depending on when

1624
01:31:29.548 --> 01:31:32.548
it's sent. And depending on what
the specific instructions are,

1625
01:31:32.548 --> 01:31:35.548
it might actually use way more
gas than what you want it to

1626
01:31:35.548 --> 01:31:38.549
use. So with your transactions,
you can actually set a limit,

1627
01:31:38.549 --> 01:31:41.549
hey, I don't want to use more
than x amount of gas, I don't

1628
01:31:41.549 --> 01:31:45.549
want to do more than x
computational units. And in

1629
01:31:45.549 --> 01:31:49.550
fact, we go to our Metamask. And
we click Send to transfer

1630
01:31:49.550 --> 01:31:53.550
between accounts again, and we
pick you know, 0.01 eath, or

1631
01:31:53.550 --> 01:31:57.551
something next can actually hit
this little button here, go to

1632
01:31:57.551 --> 01:32:00.551
Advanced, and we can actually
edit some specifics of this

1633
01:32:00.551 --> 01:32:03.551
transaction, one of them is
going to be the gas limit, we

1634
01:32:03.551 --> 01:32:09.552
can change this gas limit to
maybe 2200 2300, or more or even

1635
01:32:09.552 --> 01:32:13.552
less, since sending Aetherium
takes exactly 21,000 Gas

1636
01:32:13.552 --> 01:32:16.553
Metamask just defaults to
setting into that. Well, we also

1637
01:32:16.553 --> 01:32:19.553
see these other interesting
things, we see a priority fee,

1638
01:32:19.553 --> 01:32:24.553
and a max base fee. Let's reject
this transaction. And let's look

1639
01:32:24.553 --> 01:32:27.554
back at ether scan to talk about
these. So currently in

1640
01:32:27.554 --> 01:32:32.554
Aetherium, according to EE IP
1559, every transaction on

1641
01:32:32.554 --> 01:32:36.555
Aetherium comes with something
called the base fee. This is the

1642
01:32:36.555 --> 01:32:40.555
minimum gas price you need to
set to include your transaction.

1643
01:32:40.555 --> 01:32:43.555
And you'll notice that these are
priced in something called

1644
01:32:43.555 --> 01:32:47.556
gateway. So what is a gateway?
If we come to the site eath

1645
01:32:47.556 --> 01:32:50.556
converter.com. And again,
there's a link to this in the

1646
01:32:50.556 --> 01:32:55.556
GitHub repository, we scroll
down we can see way gateway and

1647
01:32:55.556 --> 01:33:00.557
ether five put one ether in
here, I can see how much one

1648
01:33:00.557 --> 01:33:04.557
ether is in terms of way. And in
terms of way, one ether is equal

1649
01:33:04.557 --> 01:33:12.558
to 1-234-567-8990. So that's
that's 1 billion way is going to

1650
01:33:12.558 --> 01:33:18.559
be one ether. And then
1-234-567-8910 1112 1314 Did 16

1651
01:33:18.559 --> 01:33:23.559
Seven, eight team and then 18
zeros is away. These are just

1652
01:33:23.559 --> 01:33:27.560
easier ways of referring to
really, really small amounts of

1653
01:33:27.560 --> 01:33:31.560
Aetherium. So if we look at our
gas fees, we see that the base

1654
01:33:31.560 --> 01:33:38.561
fee is 0.00000004 Go away. And
this obviously would be an even

1655
01:33:38.561 --> 01:33:42.561
smaller number if this was in
units of weigh. So if we take

1656
01:33:42.561 --> 01:33:46.562
this number, and we put it into
our calculator, we can see that

1657
01:33:46.562 --> 01:33:51.562
this is equal to 40 weigh or
0.0000 a whole bunch of zeros

1658
01:33:51.562 --> 01:33:55.563
for ether. The max fee here
refers to the maximum gas fee

1659
01:33:55.563 --> 01:33:59.563
that we're willing to pay for
this transaction. And you can

1660
01:33:59.563 --> 01:34:04.563
actually see that our max fee is
a little bit higher than what we

1661
01:34:04.563 --> 01:34:08.564
actually ended up paying. Our
maximum was 2.2132 something

1662
01:34:08.564 --> 01:34:12.564
something and the gas price we
actually paid was up here. Now

1663
01:34:12.564 --> 01:34:15.564
your transaction might of course
be a little bit different than

1664
01:34:15.564 --> 01:34:18.565
Additionally we have a max
priority fee. This is going to

1665
01:34:18.565 --> 01:34:21.565
be the max gas fee that we're
willing to pay plus the max tip

1666
01:34:21.565 --> 01:34:23.565
that we're willing to give to
miners. Now currently in

1667
01:34:24.565 --> 01:34:28.566
Aetherium, this base fee ends up
getting burnt and we can see on

1668
01:34:28.566 --> 01:34:31.566
ether scan exactly how much is
getting burnt here. And if we

1669
01:34:31.566 --> 01:34:36.567
pull up our calculator again, we
can grab this gas fee, multiply

1670
01:34:36.567 --> 01:34:40.567
it by the amount of gas we used,
and we can see that this is

1671
01:34:40.567 --> 01:34:44.567
indeed how much Aetherium we
actually ended up burning. We go

1672
01:34:44.567 --> 01:34:47.568
back to Ethereum converter,
paste it in we can see that

1673
01:34:47.568 --> 01:34:51.568
these two numbers are indeed
equal. This means whenever you

1674
01:34:51.568 --> 01:34:55.568
send a transaction, a little bit
of Aetherium is removed from

1675
01:34:55.568 --> 01:34:59.569
circulation forever, or it's
considered burnt. So currently,

1676
01:34:59.569 --> 01:35:01.569
in theory As part of your
Aetherium part of your

1677
01:35:01.569 --> 01:35:05.569
transaction fee actually gets
burnt. And then the other part

1678
01:35:05.569 --> 01:35:08.570
goes directly to miners. So to
figure out exactly how much went

1679
01:35:08.570 --> 01:35:14.570
to miners, we could do this
number minus the burnt amount.

1680
01:35:14.570 --> 01:35:18.571
And this is how much Etherium
was paid to Aetherium miner for

1681
01:35:18.571 --> 01:35:21.571
this transaction, you'll see
down here your transaction type

1682
01:35:21.571 --> 01:35:26.572
to ERP 15, five, nine, this is
the eip 15 five nine version of

1683
01:35:26.572 --> 01:35:28.572
these transactions. Like I said,
every blockchain is going to

1684
01:35:28.572 --> 01:35:32.572
have a different fee burning and
fee and gas process. And they're

1685
01:35:33.572 --> 01:35:35.572
all going to be a little bit
different, but the some of it is

1686
01:35:35.572 --> 01:35:39.573
blockchains have limited block
space for transactions, the gas

1687
01:35:39.573 --> 01:35:42.573
price that costs for your
transaction to be included in

1688
01:35:42.573 --> 01:35:45.574
one of these blocks changes
based off how much demand there

1689
01:35:45.574 --> 01:35:49.574
is the base gas fee for
Aetherium will go up and down

1690
01:35:49.574 --> 01:35:53.574
depending on how many people are
sending transactions and how

1691
01:35:53.574 --> 01:35:57.575
many people want to be included
in a block. If a ton of people

1692
01:35:57.575 --> 01:36:01.575
want to be included in a block.
That means a ton of gas is

1693
01:36:01.575 --> 01:36:04.575
obviously going to get burnt.
We've left a link to a video in

1694
01:36:04.575 --> 01:36:08.576
the GitHub repository with this
section from this YouTuber who

1695
01:36:08.576 --> 01:36:12.576
does an amazing job breaking
down this EIP 15, five, nine and

1696
01:36:12.576 --> 01:36:16.577
more about how this gas model
actually works. I highly

1697
01:36:16.577 --> 01:36:18.577
recommend you pause this video
and watch that video. To

1698
01:36:18.577 --> 01:36:21.577
understand more, the base fee
gets programmatically

1699
01:36:21.577 --> 01:36:26.578
algorithmically adjusted to try
to target for all the blocks to

1700
01:36:26.578 --> 01:36:30.578
be 50% full. If they're more
than 50% full, this base fee

1701
01:36:30.578 --> 01:36:34.578
automatically goes up. If
they're less than 50% full, this

1702
01:36:34.578 --> 01:36:38.579
base fee goes down. Now this is
a lot of the basics of how this

1703
01:36:38.579 --> 01:36:40.579
transaction works. And it can be
a little confusing. So let's do

1704
01:36:40.579 --> 01:36:43.579
a quick refresher of everything
in here. There's a unique

1705
01:36:43.579 --> 01:36:48.580
transaction hash that uniquely
identifies this transaction. On

1706
01:36:48.580 --> 01:36:52.580
this blockchain, we can see the
status, we can see the block

1707
01:36:52.580 --> 01:36:56.581
number that it's confirmed on.
One other thing we want to look

1708
01:36:56.581 --> 01:36:58.581
at. If we scroll up, we see
block number and block

1709
01:36:58.581 --> 01:37:03.581
confirmations. This is how many
blocks have been mined. Since

1710
01:37:03.581 --> 01:37:07.582
this block was included. Like we
saw with our blockchain demo,

1711
01:37:07.582 --> 01:37:10.582
the longer the blockchain gets,
the harder it is to tamper with

1712
01:37:10.582 --> 01:37:12.582
and the more secure it is
typically, you'll see some

1713
01:37:12.582 --> 01:37:16.583
processes say they'll only do
something after 20 Block

1714
01:37:16.583 --> 01:37:20.583
confirmations, 30 Block
confirmations or etc. The reason

1715
01:37:20.583 --> 01:37:22.583
that they wait for these block
confirmations is because they

1716
01:37:22.583 --> 01:37:25.583
want to make sure that that
transaction is actually

1717
01:37:25.583 --> 01:37:28.584
included. And we can actually
see the block that our

1718
01:37:28.584 --> 01:37:32.584
transaction was included in and
all the other transactions with

1719
01:37:32.584 --> 01:37:35.584
it, different details about how
much gas was used, the gas

1720
01:37:35.584 --> 01:37:39.585
limit, etc. timestamp is when
the transaction happened, we can

1721
01:37:39.585 --> 01:37:44.585
see from and to we can see the
value. And then we can see the

1722
01:37:44.585 --> 01:37:47.586
transaction fee, which we see
right here is blocked base fee

1723
01:37:47.586 --> 01:37:51.586
per gas plus the max priority
fee per gas times the gas used.

1724
01:37:51.586 --> 01:37:54.586
And we see all the details of
the gas down here gas price is

1725
01:37:54.586 --> 01:38:00.587
the cost of one unit of gas gas
limit is the max amount of units

1726
01:38:00.587 --> 01:38:03.587
of gas that we're willing to pay
in this transaction, the usage

1727
01:38:03.587 --> 01:38:07.588
is how many actually got us the
base fee is going to be the base

1728
01:38:07.588 --> 01:38:13.588
network fee per gas. So 40 way
per one gas used, the max gas is

1729
01:38:13.588 --> 01:38:18.589
the max gas price we're willing
to pay. And Max priority is

1730
01:38:18.589 --> 01:38:21.589
gonna be the max gas price, plus
the tip that we give to miners,

1731
01:38:21.589 --> 01:38:23.589
and then we can see how much is
burnt. And then we see

1732
01:38:23.589 --> 01:38:27.590
transaction savings which which
is the difference between how

1733
01:38:27.590 --> 01:38:31.590
much was actually used or paid
for and then returned. So for

1734
01:38:31.590 --> 01:38:34.590
example, in this transaction,
the gas price we ended up

1735
01:38:34.590 --> 01:38:38.591
picking was a little less than
our max gas price here. So the

1736
01:38:38.591 --> 01:38:41.591
gas price we ended up using was
a little less than our max

1737
01:38:41.591 --> 01:38:45.591
priority fee here. So we had
some savings compared to that,

1738
01:38:45.591 --> 01:38:49.592
we can also see that this was an
ERP 15 five nine transaction, we

1739
01:38:49.592 --> 01:38:53.592
can see our nonce here, which
was not zero because the

1740
01:38:53.592 --> 01:38:56.593
transaction that I'm showing is
our first nones. And then of

1741
01:38:56.593 --> 01:38:59.593
course, we can see the input
data for transactions that are

1742
01:38:59.593 --> 01:39:02.593
just sending Aetherium, the
input data is going to be blank.

1743
01:39:02.593 --> 01:39:05.593
But you'll see that when we get
to smart contracts, the input

1744
01:39:05.593 --> 01:39:07.594
data is not going to be blank.
And it's going to be one of the

1745
01:39:07.594 --> 01:39:11.594
most important features of these
transactions. You'll also notice

1746
01:39:11.594 --> 01:39:15.594
that there's a state tab. This
is an advanced tab, and it shows

1747
01:39:15.594 --> 01:39:18.595
the different states that are
changed based off of this

1748
01:39:18.595 --> 01:39:21.595
transaction. We're going to
ignore this one for now. Now

1749
01:39:21.595 --> 01:39:24.595
that we know how the blockchain
itself works under the hood,

1750
01:39:24.595 --> 01:39:28.596
let's talk about some blockchain
fundamentals. And we actually

1751
01:39:28.596 --> 01:39:31.596
covered all these topics in a
previous Freako camp video. So

1752
01:39:31.596 --> 01:39:34.596
let's go to that.

1753
01:39:34.596 --> 01:39:35.596
If the first time

1754
01:39:35.596 --> 01:39:38.597
you listen to this, some of
these concepts seem a little bit

1755
01:39:38.597 --> 01:39:42.597
hard to grasp. Don't worry about
it. As we continue and as we

1756
01:39:42.597 --> 01:39:45.597
move on with this course,
they'll start to make more sense

1757
01:39:45.597 --> 01:39:48.598
when you see them used in real
examples. I definitely would

1758
01:39:48.598 --> 01:39:51.598
recommend going back and
rewatching and re listening to

1759
01:39:51.598 --> 01:39:55.598
the parts that you don't quite
get an asking questions in the

1760
01:39:55.598 --> 01:39:58.599
discussions tab of the GitHub
repository. Awesome. So now that

1761
01:39:58.599 --> 01:40:01.599
we know all the cryptography
pieces and all the little nitty

1762
01:40:01.599 --> 01:40:04.599
gritties of how the blockchain
actually works, and how our

1763
01:40:04.599 --> 01:40:06.600
signatures work and how
everything sticks together.

1764
01:40:06.600 --> 01:40:10.600
Let's talk a little bit about
how this works, in actuality,

1765
01:40:10.600 --> 01:40:12.600
and what's really going on. Now
for a lot of this, each

1766
01:40:12.600 --> 01:40:15.600
different blockchain has
slightly different algorithms

1767
01:40:15.600 --> 01:40:18.601
and slightly different metrics
and criteria for doing a lot of

1768
01:40:18.601 --> 01:40:21.601
this stuff. So when we're
talking about these specific

1769
01:40:21.601 --> 01:40:25.601
implementations, keep in mind,
the exact algorithm might be a

1770
01:40:25.601 --> 01:40:27.602
little bit different, but the
concepts are all still going to

1771
01:40:27.602 --> 01:40:30.602
be exactly the same. Hashing and
hash function is going to be the

1772
01:40:30.602 --> 01:40:34.602
same. No matter where you look
at decentralized blockchain,

1773
01:40:34.602 --> 01:40:36.603
it's going to be the same no
matter where you look, how it's

1774
01:40:36.603 --> 01:40:39.603
actually implemented, is going
to be a little bit different.

1775
01:40:39.603 --> 01:40:42.603
Now traditionally, when you run
an application, you will be

1776
01:40:42.603 --> 01:40:45.603
website or something that
connects to some server, you are

1777
01:40:45.603 --> 01:40:49.604
interacting with a centralized
entity. And unlike how we saw

1778
01:40:49.604 --> 01:40:52.604
with the blockchain with
multiple different peers, it's

1779
01:40:52.604 --> 01:40:56.605
going to be run by a single
centralized group. Now, it still

1780
01:40:56.605 --> 01:40:59.605
could be run on many different
servers, but all those servers

1781
01:40:59.605 --> 01:41:02.605
are still going to be controlled
by the same centralized group

1782
01:41:02.605 --> 01:41:07.606
blockchains, as we saw run on a
network of different independent

1783
01:41:07.606 --> 01:41:10.606
nodes. When we saw a peer, a
peer, B Piercey. Those were

1784
01:41:10.606 --> 01:41:14.606
different examples of different
independent users running the

1785
01:41:14.606 --> 01:41:17.607
blockchain technology on their
own node. Now, when I use the

1786
01:41:17.607 --> 01:41:20.607
term node, I'm usually referring
to a single instance of a

1787
01:41:20.607 --> 01:41:23.607
decentralized system. So when I
say a single node, when I'm

1788
01:41:23.607 --> 01:41:26.608
talking about a blockchain, I'm
talking about one of those pure

1789
01:41:26.608 --> 01:41:29.608
A's pure BS pure C's running
that blockchain software, I'm

1790
01:41:29.608 --> 01:41:33.608
talking about one server running
this technology. And again, it's

1791
01:41:33.608 --> 01:41:35.608
this network. It's this
combination of these nodes

1792
01:41:35.608 --> 01:41:38.609
interacting with each other,
that creates this entire

1793
01:41:38.609 --> 01:41:41.609
blockchain. What makes these so
potent too, is that anybody can

1794
01:41:41.609 --> 01:41:44.609
join the network. And that's why
there's decentralized the

1795
01:41:44.609 --> 01:41:47.610
barrier to entry is a little bit
of hardware requirements for

1796
01:41:47.610 --> 01:41:50.610
getting the correct materials to
run the software. And then you

1797
01:41:50.610 --> 01:41:52.610
running the software, anybody
can join these networks and

1798
01:41:52.610 --> 01:41:55.610
participate. And that's what
makes it truly decentralized. In

1799
01:41:55.610 --> 01:41:58.611
fact, you can go to GitHub right
now, and run your own Aetherium

1800
01:41:58.611 --> 01:42:02.611
node in a few seconds. Now in
the traditional world,

1801
01:42:02.611 --> 01:42:05.611
applications are run by
centralized entities. And if

1802
01:42:05.611 --> 01:42:09.612
that entity goes down, or is
maliciously bribed, or decides

1803
01:42:09.612 --> 01:42:12.612
that they want to shut off, they
just can't, because they are the

1804
01:42:12.612 --> 01:42:16.613
ones that control everything.
blockchains, by contrast, don't

1805
01:42:16.613 --> 01:42:20.613
have this problem. If one node
or one entity that runs several

1806
01:42:20.613 --> 01:42:24.613
nodes goes down, since there are
so many other independent nodes

1807
01:42:24.613 --> 01:42:27.614
running that it doesn't matter,
the blockchain and the system

1808
01:42:27.614 --> 01:42:30.614
will persist so long as there is
at least one node always

1809
01:42:30.614 --> 01:42:34.614
running. And luckily for us,
most of the most popular chains

1810
01:42:34.614 --> 01:42:38.615
like Bitcoin and Aetherium, have
1000s and 1000s of nodes. And as

1811
01:42:38.615 --> 01:42:42.615
we showed in our demo, if one
node acts maliciously, all the

1812
01:42:42.615 --> 01:42:46.616
other nodes will ignore that
node and kick that out or even

1813
01:42:46.616 --> 01:42:49.616
punish it in some systems,
because they can easily check

1814
01:42:49.616 --> 01:42:52.616
everybody else's node and see,
okay, this one is out of sync

1815
01:42:52.616 --> 01:42:55.616
with the majority. And yes,
majority rules when it comes to

1816
01:42:55.616 --> 01:42:58.617
the blockchain. Each blockchain
keeps a full list of every

1817
01:42:58.617 --> 01:43:01.617
transaction and interaction
that's happened on that

1818
01:43:01.617 --> 01:43:05.617
blockchain and we saw if a node
tries to act maliciously, then

1819
01:43:05.617 --> 01:43:07.618
all their hashes are going to be
way out of whack and they're not

1820
01:43:07.618 --> 01:43:10.618
going to match everybody else.
This gives blockchains this

1821
01:43:10.618 --> 01:43:13.618
incredibly potent immutability
trait where nothing can be

1822
01:43:13.618 --> 01:43:16.619
changed or corrupted. So in
essence, we can think of a

1823
01:43:16.619 --> 01:43:20.619
blockchain as a decentralized
database. And with Aetherium, it

1824
01:43:20.619 --> 01:43:24.619
has an extra additional feature
where it also can do computation

1825
01:43:24.619 --> 01:43:27.620
in a decentralized manner. Now
let's talk consensus, proof of

1826
01:43:27.620 --> 01:43:30.620
work and proof of stake because
you've probably heard these

1827
01:43:30.620 --> 01:43:33.620
before. And they're really
important to how these

1828
01:43:33.620 --> 01:43:35.620
blockchains actually work. We
went through that blockchain

1829
01:43:35.620 --> 01:43:39.621
example, and we did that mining
feature. This is what's known as

1830
01:43:39.621 --> 01:43:43.621
proof of work. Proof of Work and
proof of steak fall under this

1831
01:43:43.621 --> 01:43:47.622
umbrella of consensus and
consensus is a really important

1832
01:43:47.622 --> 01:43:49.622
topic when it comes to
blockchains. Consensus is

1833
01:43:49.622 --> 01:43:53.622
defined as the mechanism used to
reach an agreement on the state

1834
01:43:53.622 --> 01:43:56.623
or a single value on the
blockchain, especially in a

1835
01:43:56.623 --> 01:43:59.623
decentralized system. I briefly
alluded to this consensus

1836
01:43:59.623 --> 01:44:02.623
mechanism in our blockchain
example, when I said if one

1837
01:44:03.623 --> 01:44:06.624
change is something and the
other two, don't, then majority

1838
01:44:06.624 --> 01:44:09.624
will rule and kick that one out.
This is part of that consensus

1839
01:44:09.624 --> 01:44:13.624
mechanism. Now very roughly a
consensus protocol in a

1840
01:44:13.624 --> 01:44:15.624
blockchain or decentralized
system can be broken down into

1841
01:44:15.624 --> 01:44:19.625
two pieces, a chain selection
algorithm, and a civil

1842
01:44:19.625 --> 01:44:22.625
resistance mechanism, that
mining piece that we were doing,

1843
01:44:22.625 --> 01:44:25.625
or where the proof of work
algorithm is what's known as a

1844
01:44:25.625 --> 01:44:28.626
civil resistance mechanism. And
this is what Aetherium and

1845
01:44:28.626 --> 01:44:31.626
Bitcoin currently use. Please
note that depending on when

1846
01:44:31.626 --> 01:44:34.626
you're watching this, if eath
two is out, then it's no longer

1847
01:44:34.626 --> 01:44:37.627
proof of work. Now, proof of
work is known as a civil

1848
01:44:37.627 --> 01:44:40.627
resistance mechanism, because it
defines a way to figure out who

1849
01:44:40.627 --> 01:44:43.627
is the block author, which node
is going to be the node who did

1850
01:44:43.627 --> 01:44:47.628
the work to find that mine and
be the author of that block so

1851
01:44:47.628 --> 01:44:50.628
all the other nodes can verify
that it's accurate civil

1852
01:44:50.628 --> 01:44:53.628
resistance is a blockchains
ability to defend against users

1853
01:44:54.628 --> 01:44:57.629
creating a large number of
pseudo anonymous identities to

1854
01:44:57.629 --> 01:45:00.629
gain a disproportionately
advantageous influence is over

1855
01:45:00.629 --> 01:45:04.629
set system. And in layman's
terms, it's basically a way for

1856
01:45:04.629 --> 01:45:06.629
a blockchain to defend against
somebody making a bunch of fake

1857
01:45:06.629 --> 01:45:09.630
blockchains so that they can get
more and more rewards. Now,

1858
01:45:09.630 --> 01:45:11.630
there are two types of civil
resistance mechanisms that we're

1859
01:45:11.630 --> 01:45:15.630
going to talk about here. Namely
proof of work and proof of

1860
01:45:15.630 --> 01:45:18.631
stake. Let's talk about proof of
work a little bit more in depth

1861
01:45:18.631 --> 01:45:21.631
first, in proof of work. This is
civil resistant, because a

1862
01:45:21.631 --> 01:45:24.631
single node has to go through a
very computationally expensive

1863
01:45:24.631 --> 01:45:28.632
process called mining, which we
demonstrated earlier to figure

1864
01:45:28.632 --> 01:45:30.632
out the answer to the
blockchains Riddle of finding

1865
01:45:30.632 --> 01:45:32.632
that correct nonce, or, or
whatever the

1866
01:45:32.632 --> 01:45:34.632
blockchain system has in place.
And proof of work. This works

1867
01:45:34.632 --> 01:45:37.633
because no matter how many
pseudo anonymous accounts you

1868
01:45:37.633 --> 01:45:40.633
make, each one still has to
undergo this very

1869
01:45:40.633 --> 01:45:44.633
computationally expensive
activity of finding the answer

1870
01:45:44.633 --> 01:45:47.634
to the proof of work problem, or
the proof of work riddle, which

1871
01:45:47.634 --> 01:45:50.634
again, in our demonstration, it
was finding a nonce with that

1872
01:45:50.634 --> 01:45:54.634
first four zeros. But again,
each blockchain might change the

1873
01:45:54.634 --> 01:45:55.634
riddle work or change the
problem to be a little bit

1874
01:45:55.634 --> 01:45:58.635
different. In fact, some of
these blockchains make this

1875
01:45:58.635 --> 01:46:01.635
riddle intentionally hard or
intentionally easy to change

1876
01:46:01.635 --> 01:46:04.635
what's called the block time,
the block time is how long it

1877
01:46:04.635 --> 01:46:06.636
takes between blocks being
published. And it's proportional

1878
01:46:06.636 --> 01:46:10.636
to how hard these algorithms
are. So these problems actually

1879
01:46:10.636 --> 01:46:13.636
can change. Depending on how
long they want the blockchain to

1880
01:46:13.636 --> 01:46:17.637
be. If a system wants to block
time to be very, very long, they

1881
01:46:17.637 --> 01:46:20.637
just make the problem very, very
hard. If they wanted to be very

1882
01:46:20.637 --> 01:46:23.637
short, they make the problem a
lot easier. We'll talk about

1883
01:46:23.637 --> 01:46:25.637
civil attacks in a little bit
and how they can affect the

1884
01:46:25.637 --> 01:46:28.638
system. But with proof of work,
it's a verifiable way to figure

1885
01:46:28.638 --> 01:46:32.638
out who the block author is and
be civil resistant. Now, you

1886
01:46:32.638 --> 01:46:35.638
need to combine this with a
chain selection rule create this

1887
01:46:35.638 --> 01:46:37.639
consensus. Now, there's some
consensus protocols that have

1888
01:46:37.639 --> 01:46:40.639
more features, but very, very
roughly, these are the two

1889
01:46:40.639 --> 01:46:43.639
pieces that we're going to look
at. The second piece is going to

1890
01:46:43.639 --> 01:46:47.640
be a chain selection rule. How
do we know which blockchain is

1891
01:46:47.640 --> 01:46:50.640
actually the real blockchain and
the true blockchain now on

1892
01:46:50.640 --> 01:46:53.640
Bitcoin and Aetherium, they both
use a form of consensus called

1893
01:46:53.640 --> 01:46:57.641
Nakamoto consensus. And this is
a combination of proof of work

1894
01:46:57.641 --> 01:47:00.641
and longest chain rule, the
decentralized network side that

1895
01:47:00.641 --> 01:47:03.641
whichever blockchain has the
longest chain, or the most

1896
01:47:03.641 --> 01:47:07.642
number of blocks on it is going
to be the chain that they use.

1897
01:47:07.642 --> 01:47:09.642
This makes a lot of sense,
because every additional block

1898
01:47:09.642 --> 01:47:12.642
that a chain is behind, it's
going to take more and more

1899
01:47:12.642 --> 01:47:16.642
computation for it to come up.
That's why when we saw in our

1900
01:47:16.642 --> 01:47:19.643
transaction, we actually saw
confirmations. The number of

1901
01:47:19.643 --> 01:47:23.643
confirmations is the number of
additional blocks added on after

1902
01:47:23.643 --> 01:47:26.643
our transaction went through in
a block. So if we see

1903
01:47:26.643 --> 01:47:28.644
confirmations as to it means
that the block that our

1904
01:47:28.644 --> 01:47:32.644
transaction was in has two
blocks ahead of it in the

1905
01:47:32.644 --> 01:47:35.644
longest chain. Now, I do want to
point out that a lot of people

1906
01:47:35.644 --> 01:47:38.645
use proof of work as a consensus
protocol. And I do want to say

1907
01:47:38.645 --> 01:47:41.645
that this is a little bit
inaccurate, but sometimes people

1908
01:47:41.645 --> 01:47:45.645
use it interchangeably. Proof of
Work is a piece of the overall

1909
01:47:45.645 --> 01:47:48.646
consensus protocol, which in
Bitcoin and Aetherium. One

1910
01:47:48.646 --> 01:47:53.646
current case is Nakamoto
consensus, Nakamoto consensus is

1911
01:47:53.646 --> 01:47:56.647
a combination of proof of work,
and this longest chain rule,

1912
01:47:56.647 --> 01:48:00.647
both equally and very, very
important. Now, proof of work

1913
01:48:00.647 --> 01:48:03.647
also tells us where these
transaction fees and these block

1914
01:48:03.647 --> 01:48:07.648
rewards go to remember how when
we made this transaction, we had

1915
01:48:07.648 --> 01:48:10.648
to talk about gas and a
transaction fee. So who's

1916
01:48:10.648 --> 01:48:13.648
getting paid who was getting
this transaction, and this

1917
01:48:13.648 --> 01:48:16.649
transaction fee is going to the
miners or the validators in a

1918
01:48:16.649 --> 01:48:19.649
proof of work network? They're
called miners and in the proof

1919
01:48:19.649 --> 01:48:23.649
of stake network, they're called
validators there are a little

1920
01:48:23.649 --> 01:48:25.649
bit different. And we'll get
into that when we talk about

1921
01:48:25.649 --> 01:48:28.650
proof of stake in this proof of
work system. All these nodes are

1922
01:48:28.650 --> 01:48:31.650
competing against each other to
find the answer to the

1923
01:48:31.650 --> 01:48:34.650
blockchain riddle. Remember, in
our example, it was to find a

1924
01:48:34.650 --> 01:48:38.651
hash that has four zeros at the
start. And again, depending on

1925
01:48:38.651 --> 01:48:40.651
the blockchain implementation,
that riddle is going to be a

1926
01:48:40.651 --> 01:48:44.651
little bit different. But all
the nodes are trying as many as

1927
01:48:44.651 --> 01:48:48.652
possible to try to get this
answer first. Why? Because the

1928
01:48:48.652 --> 01:48:51.652
first node to figure out the
answer to the blockchain real is

1929
01:48:51.652 --> 01:48:53.652
gonna get that transaction fee,
they're gonna get paid from

1930
01:48:53.652 --> 01:48:56.652
that. Now, when a node gets
paid, they actually get paid in

1931
01:48:56.652 --> 01:48:59.653
two different ways. One is going
to be with a transaction fee.

1932
01:48:59.653 --> 01:49:02.653
And another piece is going to be
the block reward. Remember how

1933
01:49:02.653 --> 01:49:05.653
we talked about alternating the
gas price or the gray on our

1934
01:49:05.653 --> 01:49:08.654
transaction? Well, that's the
transaction fee that we're going

1935
01:49:08.654 --> 01:49:11.654
to pay to these blockchain nodes
for including our transaction,

1936
01:49:11.654 --> 01:49:15.654
the block reward is given to
these nodes from the protocol

1937
01:49:15.654 --> 01:49:17.655
from the blockchain itself.
You've probably heard of the

1938
01:49:18.655 --> 01:49:21.655
Bitcoin halving before the
halving is referring to this

1939
01:49:21.655 --> 01:49:24.655
block reward getting cut in half
and it's supposed to be cut in

1940
01:49:24.655 --> 01:49:29.656
half, roughly every four years.
This block reward increases the

1941
01:49:29.656 --> 01:49:32.656
circulating amount of whatever
cryptocurrency that is being

1942
01:49:32.656 --> 01:49:34.656
rewarded. For example, on
Aetherium the block reward is

1943
01:49:34.656 --> 01:49:37.657
giving out Aetherium and a
Bitcoin the block reward is

1944
01:49:37.657 --> 01:49:40.657
giving out Bitcoin. So these
nodes are competing against each

1945
01:49:40.657 --> 01:49:43.657
other to be the first one to
find this transaction to be the

1946
01:49:43.657 --> 01:49:46.657
first one to find the answer to
this problem, so that they can

1947
01:49:46.657 --> 01:49:49.658
be the ones to win both this
block reward and your

1948
01:49:49.658 --> 01:49:52.658
transaction fee. Some block
chains like Bitcoin, for

1949
01:49:52.658 --> 01:49:55.658
example, have a set time when
they're no longer going to give

1950
01:49:55.658 --> 01:49:58.659
out block rewards and the miners
or the nodes are only going to

1951
01:49:58.659 --> 01:50:02.659
get paid from trends. Action
fees. Now this gas fee, again is

1952
01:50:02.659 --> 01:50:06.659
paid by whoever initialize the
transaction. When we got our

1953
01:50:06.659 --> 01:50:09.660
funds from the faucet, there was
some server and somebody else

1954
01:50:09.660 --> 01:50:13.660
was paying the transaction fee
for us. However, when we sent

1955
01:50:13.660 --> 01:50:16.661
ether from one account to
another, our first account

1956
01:50:16.661 --> 01:50:20.661
actually paid some transaction
fee to send that ether. In proof

1957
01:50:20.661 --> 01:50:23.661
of steak. There's also a gas
fee, but it's paid out to

1958
01:50:23.661 --> 01:50:26.662
validators instead of miners.
And we'll talk about that in a

1959
01:50:26.662 --> 01:50:29.662
little bit. Now let's talk about
two types of attacks that can

1960
01:50:29.662 --> 01:50:31.662
happen in these blockchain
worlds. Let's talk about the

1961
01:50:31.662 --> 01:50:34.662
first one being the Sybil
attack. The Sybil attack is when

1962
01:50:34.662 --> 01:50:37.663
a user creates a whole bunch of
pseudo anonymous accounts to try

1963
01:50:37.663 --> 01:50:41.663
to influence a network. Now,
obviously, on Bitcoin and

1964
01:50:41.663 --> 01:50:44.663
Aetherium, this is really,
really difficult because user

1965
01:50:44.663 --> 01:50:47.664
needs to do all this work in
proof of work or have a ton of

1966
01:50:47.664 --> 01:50:49.664
collateral and proof of stake,
which again, we'll talk about in

1967
01:50:49.664 --> 01:50:53.664
a bit. The other more prevalent
attack is what's known as a 51%

1968
01:50:53.664 --> 01:50:56.665
attack. Now, as we saw as part
of our consensus protocol, these

1969
01:50:57.665 --> 01:51:00.665
block chains are going to agree
that the longest chain is the

1970
01:51:00.665 --> 01:51:03.665
one that they're going to go
with, so long as it matches up

1971
01:51:03.665 --> 01:51:07.666
with 51% of the rest of the
network. This means that if you

1972
01:51:07.666 --> 01:51:10.666
have the longest chain, and you
have more than 51% of the rest

1973
01:51:10.666 --> 01:51:13.666
of the network, you can do
what's called a fork in the

1974
01:51:13.666 --> 01:51:16.667
network, and bring the network
onto your now longest chain. Now

1975
01:51:16.667 --> 01:51:19.667
Sybil attacks, obviously, are
when a single node or a single

1976
01:51:19.667 --> 01:51:23.667
entity tries to affect the
decent reality of the network by

1977
01:51:23.667 --> 01:51:25.667
pretending to be multiple
different people, although

1978
01:51:25.667 --> 01:51:28.668
they're just the same person or
entity. And like I said, it's

1979
01:51:28.668 --> 01:51:31.668
really difficult to do in proof
of work and proof of steak. So

1980
01:51:31.668 --> 01:51:33.668
you can see now that blockchains
are very democratic, whichever

1981
01:51:33.668 --> 01:51:37.669
blockchain has the most buy in
and is the longest is the

1982
01:51:37.669 --> 01:51:40.669
blockchain that the whole system
is going to corroborate. When

1983
01:51:40.669 --> 01:51:43.669
nodes produce a new block and
add to the longest chain, the

1984
01:51:43.669 --> 01:51:45.669
other nodes will follow this
longest chain that the rest of

1985
01:51:45.669 --> 01:51:48.670
the network is agreeing with,
add those blocks to their chain

1986
01:51:48.670 --> 01:51:51.670
and follow up. So very small
reorganizations are actually

1987
01:51:51.670 --> 01:51:54.670
pretty common when a blockchain
picks a block from a different

1988
01:51:54.670 --> 01:51:58.671
longest chain puts it on and
then has to swap it out for

1989
01:51:58.671 --> 01:52:01.671
another block and continue with
a different blockchain. However,

1990
01:52:01.671 --> 01:52:04.671
if a group of nodes had enough
nodes or enough power, they

1991
01:52:04.671 --> 01:52:08.672
could essentially be 51% of the
network and influence the

1992
01:52:08.672 --> 01:52:10.672
network in whatever direction
that they want it. This is

1993
01:52:10.672 --> 01:52:14.672
what's known as a 51% attack.
And it's happened on blockchains

1994
01:52:14.672 --> 01:52:17.673
like Ethereum classic, which is
not Aetherium. This is why the

1995
01:52:17.673 --> 01:52:20.673
bigger a blockchain is, the more
decentralized and the more

1996
01:52:20.673 --> 01:52:21.673
secure it becomes.

1997
01:52:21.673 --> 01:52:24.673
So after you watch this video,
and you become a blockchain

1998
01:52:24.673 --> 01:52:26.674
engineering expert, I definitely
recommend you run a node as

1999
01:52:27.674 --> 01:52:29.674
well, because you are going to
increase the security of the

2000
01:52:29.674 --> 01:52:32.674
network as a whole by running a
node. So proof of work is

2001
01:52:32.674 --> 01:52:35.674
fantastic because it allows us
to very easily protect against

2002
01:52:35.674 --> 01:52:38.675
the Sybil attacks and keep our
blockchain is decentralized and

2003
01:52:38.675 --> 01:52:42.675
secure. However, it has some
drawbacks as well. Proof of Work

2004
01:52:42.675 --> 01:52:45.675
costs a lot of electricity,
because every single node is

2005
01:52:45.675 --> 01:52:48.676
running as fast as they can to
win this race to get the

2006
01:52:48.676 --> 01:52:52.676
rewards. This leads to obviously
an environmental impact. Now

2007
01:52:52.676 --> 01:52:54.676
since proof of work and Nakamoto
consensus, a lot of other

2008
01:52:54.676 --> 01:52:57.677
protocols have taken this idea
and gone in a different

2009
01:52:57.677 --> 01:53:00.677
direction with a different civil
resistance protocol, a lot of

2010
01:53:00.677 --> 01:53:03.677
them with the intention to be a
lot more environmentally

2011
01:53:03.677 --> 01:53:06.677
friendly. And the most popular
one right now is proof of stake.

2012
01:53:06.677 --> 01:53:09.678
There are some chains that are
already using this proof of

2013
01:53:09.678 --> 01:53:12.678
stake protocol, and that are
live and thriving. Some of them

2014
01:53:12.678 --> 01:53:16.678
are like avalanche, LaLana,
Polygon, polka dot and Terra and

2015
01:53:16.678 --> 01:53:20.679
additionally Aetherium is
decided to upgrade to eath. Two,

2016
01:53:20.679 --> 01:53:23.679
which will have this proof of
stake algorithm as well, it will

2017
01:53:23.679 --> 01:53:26.680
also have some other features,
which we'll talk about in a bit.

2018
01:53:26.680 --> 01:53:29.680
Now as a quick aside, all the
tools that we're going to learn

2019
01:53:29.680 --> 01:53:32.680
here are still going to work in
eath. Two, so depending on when

2020
01:53:32.680 --> 01:53:34.680
you watch this, everything here
is still valid. So let's talk

2021
01:53:34.680 --> 01:53:37.681
about proof of stake. Now,
again, this is a different civil

2022
01:53:37.681 --> 01:53:40.681
resistance mechanism. Instead of
solving this difficult problem,

2023
01:53:40.681 --> 01:53:44.681
proof of stake nodes put up some
collateral that they're going to

2024
01:53:44.681 --> 01:53:49.682
behave honestly, aka, they stake
in the example of Aetherium. two

2025
01:53:49.682 --> 01:53:52.682
nodes put up some Aetherium as a
stake that they're going to

2026
01:53:52.682 --> 01:53:55.682
behave honestly in the network,
if they misbehave to the

2027
01:53:55.682 --> 01:53:58.683
network, they are going to be
slashed or remove some of their

2028
01:53:58.683 --> 01:54:01.683
steak. Obviously, this is a very
good civil resistance mechanism.

2029
01:54:01.683 --> 01:54:04.683
Because if you try to create a
whole bunch of anonymous

2030
01:54:04.683 --> 01:54:07.684
accounts, then each one of those
accounts, you have to put up

2031
01:54:07.684 --> 01:54:10.684
some stake. And if you
misbehave, you're going to run

2032
01:54:10.684 --> 01:54:13.684
the risk of losing all the money
that you put up as collateral.

2033
01:54:13.684 --> 01:54:16.685
In this system, miners are
actually called validators

2034
01:54:16.685 --> 01:54:18.685
because they're no longer
binding anything, they're

2035
01:54:18.685 --> 01:54:21.685
actually just validating other
nodes. Now, unlike proof of

2036
01:54:21.685 --> 01:54:24.685
work, which every node is racing
to be the first one to find the

2037
01:54:24.685 --> 01:54:28.686
block, and proof of stake nodes
are actually randomly chosen to

2038
01:54:28.686 --> 01:54:31.686
propose the new block and then
the rest of the validators will

2039
01:54:31.686 --> 01:54:35.686
validate if that node has
proposed the block. Honestly, as

2040
01:54:35.686 --> 01:54:38.687
we saw with our cryptography
lesson, it's usually very easy

2041
01:54:38.687 --> 01:54:42.687
for other nodes to verify if a
proposal or a transaction is

2042
01:54:42.687 --> 01:54:45.687
honest. Now randomness is a
really important topic when

2043
01:54:45.687 --> 01:54:47.688
we're talking about blockchains.
Because keep in mind, these

2044
01:54:47.688 --> 01:54:51.688
blockchains are deterministic
systems. They're walled gardens

2045
01:54:51.688 --> 01:54:54.688
from the rest of the world. And
as you know, a deterministic

2046
01:54:54.688 --> 01:54:58.689
system by definition can't have
random numbers. So how do we

2047
01:54:58.689 --> 01:55:01.689
choose the random validators in
the system? While it changes

2048
01:55:01.689 --> 01:55:04.689
from blockchain to blockchain,
and actually choosing the node

2049
01:55:04.689 --> 01:55:07.690
will change blockchain to
blockchain, but eath two,

2050
01:55:07.690 --> 01:55:09.690
they're using what's called Rand
doubt, at least for the original

2051
01:55:09.690 --> 01:55:12.690
implementation. This is a
decentralized autonomous

2052
01:55:12.690 --> 01:55:15.690
organization that collectively
chooses the random number and

2053
01:55:15.690 --> 01:55:18.691
collectively chooses which node
is going to run. Next, we aren't

2054
01:55:18.691 --> 01:55:20.691
going to dive too deep into this
because there's a good chance

2055
01:55:20.691 --> 01:55:23.691
that this might change in the
future. But we will go into

2056
01:55:23.691 --> 01:55:25.691
randomness solutions and
blockchain later on in this

2057
01:55:25.691 --> 01:55:28.692
course. Now, proof of stake
obviously has some pros and cons

2058
01:55:28.692 --> 01:55:31.692
as well, pros are that again, it
is a great civil resistance

2059
01:55:31.692 --> 01:55:33.692
mechanism. And a great way to
figure out who the author of a

2060
01:55:33.692 --> 01:55:37.693
block should be. The other pros
are that it's way less

2061
01:55:37.693 --> 01:55:40.693
computationally expensive to
figure out the new block,

2062
01:55:40.693 --> 01:55:42.693
because instead of every single
node on the network trying to do

2063
01:55:42.693 --> 01:55:46.693
this, only one node needs to do
this. And then the rest of the

2064
01:55:46.693 --> 01:55:49.694
nodes just need to validate it.
The cons are that it's usually

2065
01:55:49.694 --> 01:55:52.694
considered a slightly less
decentralized network, due to

2066
01:55:52.694 --> 01:55:55.694
the upfront staking costs it
cost to participate. Now, this

2067
01:55:55.694 --> 01:55:58.695
gets into a little bit of a
philosophical battle on how

2068
01:55:58.695 --> 01:56:01.695
decentralized is decentralized
enough. And I think that's up to

2069
01:56:01.695 --> 01:56:04.695
the community to decide. And as
we progress, I think we'll learn

2070
01:56:04.695 --> 01:56:06.695
more and more about how
decentralized is decentralized

2071
01:56:06.695 --> 01:56:09.696
enough. The general consensus
amongst blockchain engineers,

2072
01:56:09.696 --> 01:56:13.696
though, is that proof of stake
is very, very decentralized and

2073
01:56:13.696 --> 01:56:16.696
very secure. This massive
environmental impact improvement

2074
01:56:16.696 --> 01:56:19.697
is one of the two main reasons
why eath is shifting to eath.

2075
01:56:19.697 --> 01:56:21.697
Two, it reduces the
environmental impact by up to

2076
01:56:21.697 --> 01:56:25.697
99%. Now, these are the main
pieces of proof of work and

2077
01:56:25.697 --> 01:56:28.698
proof of stake. But I did want
to talk about another concept

2078
01:56:28.698 --> 01:56:31.698
that's really important in these
ecosystems. And that is

2079
01:56:31.698 --> 01:56:34.698
scalability. When we were
talking about gas prices, we

2080
01:56:34.698 --> 01:56:37.699
were saying that the gas prices
can get really high if a lot of

2081
01:56:37.699 --> 01:56:40.699
people want to send a
transaction, because a block

2082
01:56:40.699 --> 01:56:43.699
only has so much black space,
and the nodes can only add so

2083
01:56:43.699 --> 01:56:46.699
many notes. So when a lot of
people want to use a blockchain,

2084
01:56:46.699 --> 01:56:51.700
the gas price skyrockets. This
is not very scalable, because if

2085
01:56:51.700 --> 01:56:54.700
we want to add more and more
people to these blockchains,

2086
01:56:54.700 --> 01:56:57.701
it's going to cost more and more
to use the blockchains. Because

2087
01:56:57.701 --> 01:57:00.701
more people are going to want to
get into these blocks. This

2088
01:57:00.701 --> 01:57:02.701
means that there's kind of a
ceiling to how many people can

2089
01:57:02.701 --> 01:57:04.701
use the system because of the
financial constraints that will

2090
01:57:04.701 --> 01:57:08.702
get imposed as gas prices keep
rising. Aetherium too is not

2091
01:57:08.702 --> 01:57:10.702
only attacking the environmental
impact of proof of work by

2092
01:57:10.702 --> 01:57:13.702
switching to proof of steak, but
they're also implementing this

2093
01:57:13.702 --> 01:57:18.703
new methodology called sharding.
And sharding is a solution to

2094
01:57:18.703 --> 01:57:21.703
the scalability problem, a
sharded blockchain really just

2095
01:57:21.703 --> 01:57:24.703
means that it's going to be a
blockchain of blockchains

2096
01:57:24.703 --> 01:57:27.704
there's a main chain that's
going to coordinate everything

2097
01:57:27.704 --> 01:57:32.704
amongst several chains that hook
into this main chain. This means

2098
01:57:32.704 --> 01:57:35.704
that there's more chains for
people to make transactions on

2099
01:57:35.704 --> 01:57:38.705
effectively increasing the
amount of block space that there

2100
01:57:38.705 --> 01:57:41.705
is sharding can greatly increase
the number of transactions on a

2101
01:57:41.705 --> 01:57:44.705
blockchain layer one now there's
another term that might be the

2102
01:57:44.705 --> 01:57:47.706
first time you heard it, a layer
one, we're going to talk about

2103
01:57:47.706 --> 01:57:50.706
layer one and layer twos in
terms of scalability really

2104
01:57:50.706 --> 01:57:54.706
quickly as well. A layer one
refers to any base layer

2105
01:57:54.706 --> 01:57:58.707
blockchain implementation
Bitcoins, a layer one Aetherium

2106
01:57:58.707 --> 01:58:01.707
the layer one avalanches, a
layer one, these are the base

2107
01:58:01.707 --> 01:58:06.707
layer blockchain solutions. A
layer two is any application

2108
01:58:06.707 --> 01:58:09.708
that is added on top of a layer
one added on top of the

2109
01:58:09.708 --> 01:58:12.708
blockchain. Some examples of
layer twos are going to be chain

2110
01:58:12.708 --> 01:58:16.708
link arbitrage, or optimism.
Arbitrage and optimism are very

2111
01:58:16.708 --> 01:58:19.709
interesting because they are
layer twos that also look to

2112
01:58:19.709 --> 01:58:22.709
solve this scalability issue.
Arbitrage and optimism are

2113
01:58:22.709 --> 01:58:27.710
what's known as roll ups and
they roll up their transactions

2114
01:58:27.710 --> 01:58:30.710
into a layer one like Aetherium,
we're not going to go too deep

2115
01:58:30.710 --> 01:58:32.710
into roll ups and how they
actually work. But all you

2116
01:58:32.710 --> 01:58:35.710
really need to know is that a
roll up is kind of like a

2117
01:58:35.710 --> 01:58:38.711
sharded chain, they derive their
security from the base layer

2118
01:58:38.711 --> 01:58:41.711
from the layer one like
Aetherium. And they bulk send

2119
01:58:41.711 --> 01:58:44.711
their transactions onto the
layer one, they solve some of

2120
01:58:44.711 --> 01:58:47.712
the scalability issues by being
another blockchain that people

2121
01:58:47.712 --> 01:58:51.712
can make transactions on, still
on kind of this base Aetherium

2122
01:58:51.712 --> 01:58:54.712
layer. Now they're different
from side chains. Because side

2123
01:58:54.712 --> 01:58:58.713
chains derive their security
from their own protocols, roll

2124
01:58:58.713 --> 01:59:01.713
ups, derive their security from
the base layers. So arbitrage

2125
01:59:01.713 --> 01:59:04.713
and optimism, for example, is
going to be just about as secure

2126
01:59:04.713 --> 01:59:06.713
as Aetherium. There's some
fantastic guys in there that go

2127
01:59:06.713 --> 01:59:09.714
a little bit deeper into roll
ups and I've left a link in the

2128
01:59:09.714 --> 01:59:12.714
description for you. All right,
so we just talked about a lot of

2129
01:59:12.714 --> 01:59:16.714
stuff. So let's do a quick recap
before moving on. Aetherium and

2130
01:59:16.714 --> 01:59:19.715
Bitcoin are currently both proof
of work blockchains that follow

2131
01:59:19.715 --> 01:59:23.715
Nakamoto consensus, however,
Aetherium is moving to Aetherium

2132
01:59:23.715 --> 01:59:26.715
two, which will be a proof of
stake sharded blockchain Sybil

2133
01:59:26.715 --> 01:59:29.716
attacks are prevented due to
protocols like proof of work and

2134
01:59:29.716 --> 01:59:33.716
proof of steak 51% attacks grow
increasingly harder with the

2135
01:59:33.716 --> 01:59:37.716
size of blockchain. So you
should run a node consensus is

2136
01:59:37.716 --> 01:59:39.717
the mechanism that allows a
blockchain to agree upon what

2137
01:59:39.717 --> 01:59:43.717
the state of the blockchain is
sharding and roll ups are

2138
01:59:43.717 --> 01:59:48.718
solutions to scalability issues
on layer ones. Layer One is any

2139
01:59:48.718 --> 01:59:51.718
based blockchain implementation
like Bitcoin or Aetherium. A

2140
01:59:51.718 --> 01:59:53.718
blockchain scalability problem
is that there's not always

2141
01:59:53.718 --> 01:59:56.718
enough block space for the
amount of transactions that want

2142
01:59:56.718 --> 01:59:59.719
to get in them. This leads to
very high gas prices and a

2143
02:00:00.719 --> 02:00:02.719
Again, gas prices or how much it
costs to interact with the

2144
02:00:03.719 --> 02:00:04.719
blockchain.

2145
02:00:04.719 --> 02:00:08.720
So that's it for the blockchain
basics and the blockchain

2146
02:00:08.720 --> 02:00:12.720
explainers. With just this
information, you now can go off

2147
02:00:12.720 --> 02:00:15.720
into the world and start working
with blockchains and interacting

2148
02:00:15.720 --> 02:00:19.721
with blockchains. With at least
some level of knowledge as to

2149
02:00:19.721 --> 02:00:22.721
what's going on, you should be
incredibly proud of yourself for

2150
02:00:22.721 --> 02:00:26.721
just making it this far.
Definitely be sure to give

2151
02:00:26.721 --> 02:00:29.722
yourself a pat on the back and a
round of applause. Now that

2152
02:00:29.722 --> 02:00:32.722
we've gotten a lot of the basics
and the fundamentals of the way,

2153
02:00:32.722 --> 02:00:35.722
let's start jumping into the
coding aspect. This is where

2154
02:00:36.722 --> 02:00:38.723
you're going to learn how to
actually build these smart

2155
02:00:38.723 --> 02:00:42.723
contracts, how to build these
trust minimized agreements, in

2156
02:00:42.723 --> 02:00:45.723
these blockchains. And in the
smart contract platforms. This

2157
02:00:45.723 --> 02:00:48.724
next section, this solidity
basics, the solidity

2158
02:00:48.724 --> 02:00:52.724
fundamentals section will give
you all the skills to start

2159
02:00:52.724 --> 02:00:56.724
actually coding solidity and
understanding how these smart

2160
02:00:56.724 --> 02:00:59.725
contracts work underneath the
hood. So at this point,

2161
02:00:59.725 --> 02:01:02.725
absolutely, give yourself a high
five, maybe say hi, in the

2162
02:01:02.725 --> 02:01:05.725
GitHub discussions, maybe say hi
in the community, on Twitter, on

2163
02:01:05.725 --> 02:01:09.726
Reddit, etc, and be proud of
just making it this far, the

2164
02:01:09.726 --> 02:01:11.726
journey has really only just
begun, but you've already

2165
02:01:11.726 --> 02:01:15.726
learned so much. Let's begin the
next section. And let's

2166
02:01:15.726 --> 02:01:19.727
jump into the code.

2167
02:01:19.727 --> 02:01:21.727
Now that we're getting to the
coding sections, I need to

2168
02:01:21.727 --> 02:01:25.727
stress to absolutely use the
GitHub repository associated

2169
02:01:25.727 --> 02:01:28.728
with this course. If you come to
the GitHub repo, and you scroll

2170
02:01:28.728 --> 02:01:31.728
down, and you click the lesson
that we're on right now, we're

2171
02:01:31.728 --> 02:01:35.728
on lesson two. Welcome to remix,
simple storage. If you click on

2172
02:01:35.728 --> 02:01:38.729
it, it'll give you a ton of
timestamps and, and other

2173
02:01:38.729 --> 02:01:42.729
helpful links associated with
this lesson. Additionally, the

2174
02:01:42.729 --> 02:01:45.729
biggest piece is that all the
code will be available right

2175
02:01:45.729 --> 02:01:49.730
underneath the lesson title.
This will have all the code that

2176
02:01:49.730 --> 02:01:52.730
we're going to be working with,
as well as some more additional

2177
02:01:52.730 --> 02:01:55.730
information on how to work with
the code. Please, when asking

2178
02:01:55.730 --> 02:01:58.731
questions and entering in
discussions, though, please ask

2179
02:01:58.731 --> 02:02:01.731
your questions and the full
blockchain solidity course

2180
02:02:01.731 --> 02:02:03.731
repository. Thank you. And if
we're at the top of the

2181
02:02:03.731 --> 02:02:06.731
repository, and we scroll down,
we have the resources for this

2182
02:02:06.731 --> 02:02:09.732
course section. Which brings us
to the GitHub discussions in

2183
02:02:09.732 --> 02:02:12.732
which you can ask questions in
the GitHub discussion section of

2184
02:02:12.732 --> 02:02:17.733
this course. Additionally, on
Stack Exchange, Aetherium, or at

2185
02:02:17.733 --> 02:02:21.733
Stack Overflow. I'll talk a
little bit about how to format

2186
02:02:21.733 --> 02:02:24.733
questions and ask questions the
best way so that you have the

2187
02:02:24.733 --> 02:02:28.734
highest chance of getting a good
answer in a later lesson, I

2188
02:02:28.734 --> 02:02:32.734
highly recommend you pause and
make accounts for Stack Exchange

2189
02:02:32.734 --> 02:02:36.734
Aetherium, Stack Overflow, and
GitHub right now, if you haven't

2190
02:02:36.734 --> 02:02:38.735
already, links to them, of
course, can be found in our

2191
02:02:38.735 --> 02:02:42.735
GitHub repository. Typically,
for each coding section, I'll

2192
02:02:42.735 --> 02:02:45.735
start it off by giving a quick
overview of the code of what

2193
02:02:45.735 --> 02:02:46.735
we're going to be working with
and what we're going to be

2194
02:02:46.735 --> 02:02:49.736
building towards, since
everything that we're doing is

2195
02:02:49.736 --> 02:02:51.736
going to be project based. And
that's how we're going to learn.

2196
02:02:51.736 --> 02:02:55.736
For our first one and remix
though, we're going to skip over

2197
02:02:55.736 --> 02:02:58.737
that because there's a lot of
stuff to get used to. Now, I

2198
02:02:58.737 --> 02:03:01.737
highly recommend that as I'm
coding this. And as I'm doing

2199
02:03:01.737 --> 02:03:05.737
all this in remix, you follow
along with me and you code along

2200
02:03:05.737 --> 02:03:08.738
with me. Remember, you can
change my speed if I'm coding

2201
02:03:08.738 --> 02:03:10.738
too fast, or if I'm coding too
slow. To start, we're going to

2202
02:03:10.738 --> 02:03:13.738
jump into a tool called remix.
If you're unsure how to get

2203
02:03:13.738 --> 02:03:17.739
there, there's a link to remix
in our GitHub repository. This

2204
02:03:17.739 --> 02:03:21.739
is where we're gonna be writing
all of our code. So welcome to

2205
02:03:21.739 --> 02:03:25.739
the remix IDE, or integrated
development environment. This is

2206
02:03:25.739 --> 02:03:28.740
where we're going to learn how
to code and interact with our

2207
02:03:28.740 --> 02:03:32.740
smart contracts. If you want,
you can go ahead and accept help

2208
02:03:32.740 --> 02:03:35.740
out remix. If you've never been
here before, it'll give you a

2209
02:03:35.740 --> 02:03:38.741
quick walkthrough of some of the
tools that remix actually has,

2210
02:03:38.741 --> 02:03:40.741
we're going to skip over them
for now. Because I'm gonna

2211
02:03:40.741 --> 02:03:42.741
explain everything that's going
up. Remix is such a powerful

2212
02:03:42.741 --> 02:03:46.741
tool because it has a lot of
features that allow us to really

2213
02:03:46.741 --> 02:03:49.742
see and interact with our smart
contracts. Eventually, we're

2214
02:03:49.742 --> 02:03:52.742
going to move off of remix,
actually to a local development

2215
02:03:52.742 --> 02:03:56.742
environment. However, remix is
absolutely fantastic for

2216
02:03:56.742 --> 02:03:58.743
learning the fundamentals of
solidity. And I highly recommend

2217
02:03:58.743 --> 02:04:01.743
everybody start with remix when
they're getting started. When

2218
02:04:01.743 --> 02:04:04.743
you come to the remix IDE,
there's a whole lot of different

2219
02:04:04.743 --> 02:04:07.744
things that are popping out to
us. There's a lot of different

2220
02:04:07.744 --> 02:04:09.744
plugins as well. Since we're
going to be working with

2221
02:04:09.744 --> 02:04:12.744
solidity, which is going to be
the language that we're using to

2222
02:04:12.744 --> 02:04:15.744
develop our smart contracts. We
can go ahead and get started by

2223
02:04:15.744 --> 02:04:18.745
clicking the solidity plugin,
and a couple of other tools will

2224
02:04:18.745 --> 02:04:22.745
show up on the side. Even if you
don't click the solidity plugin,

2225
02:04:22.745 --> 02:04:25.745
you'll still be able to code
solidity smart contracts, the

2226
02:04:25.745 --> 02:04:27.745
left hand side is where we're
going to start to actually

2227
02:04:27.745 --> 02:04:30.746
interact with things. The button
on the top most of the left is

2228
02:04:30.746 --> 02:04:34.746
our files or explore
directories, remix comes

2229
02:04:34.746 --> 02:04:38.747
boilerplate with some different
contracts, some different

2230
02:04:38.747 --> 02:04:42.747
scripts, some different tests,
and different dependencies. We

2231
02:04:42.747 --> 02:04:45.747
are going to minimize this a
little bit. So if you want to go

2232
02:04:45.747 --> 02:04:48.748
ahead and right click and delete
some of these folders other than

2233
02:04:48.748 --> 02:04:51.748
the contracts folders, feel free
to do so. Or if you kind of like

2234
02:04:51.748 --> 02:04:55.748
them there, feel free to leave
them as well. We're going to

2235
02:04:55.748 --> 02:04:57.749
leave our contracts folder and
we're going to delete the

2236
02:04:57.749 --> 02:05:00.749
different files inside of it
just so that we can start From a

2237
02:05:00.749 --> 02:05:07.749
blank slate. Most projects come
with something known as a

2238
02:05:07.749 --> 02:05:10.750
readme. Usually it's a
readme.md, which usually

2239
02:05:10.750 --> 02:05:13.750
explains how to actually work
with code. But for our purposes,

2240
02:05:13.750 --> 02:05:15.750
we're going to delete this as
well. And you can just follow

2241
02:05:15.750 --> 02:05:15.750
along with

2242
02:05:15.750 --> 02:05:20.751
me. Now we have a blank

2243
02:05:20.751 --> 02:05:23.751
remix Setup, click on the
contracts folder and click the

2244
02:05:23.751 --> 02:05:27.751
little page icon to create a new
file, a little box will pop up

2245
02:05:27.751 --> 02:05:30.752
and you can start typing text
into it. We're going to type in

2246
02:05:30.752 --> 02:05:37.752
simple storage dot Sol, dot Sol
tells our compilers that this is

2247
02:05:37.752 --> 02:05:40.753
going to be a solidity file, and
that we're going to code

2248
02:05:40.753 --> 02:05:43.753
solidity in this solidity is the
primary coding language of smart

2249
02:05:43.753 --> 02:05:46.753
contracts. There are a few other
smart contract languages as

2250
02:05:46.753 --> 02:05:50.754
well. But solidity by far is the
most dominant smart contract

2251
02:05:50.754 --> 02:05:53.754
coding language out there. And
now we have a simple storage dot

2252
02:05:53.754 --> 02:05:56.754
soul contract on the right that
we can actually start coding our

2253
02:05:56.754 --> 02:06:00.755
solidity with. So let's start
coding some solidity. Now if you

2254
02:06:00.755 --> 02:06:04.755
click on this button right below
the files button that looks like

2255
02:06:04.755 --> 02:06:08.756
the solidity logo, you'll see a
bunch of stuff pop up in here.

2256
02:06:08.756 --> 02:06:11.756
These are different parameters
for us to actually compile our

2257
02:06:11.756 --> 02:06:14.756
solidity code so that we can run
it. So the first thing that

2258
02:06:14.756 --> 02:06:17.757
you're going to need in any
solidity smart contract is going

2259
02:06:17.757 --> 02:06:20.757
to be the version of solidity
that you're going to use. And

2260
02:06:20.757 --> 02:06:23.757
this should always be at the top
of your solidity code, solidity

2261
02:06:24.757 --> 02:06:26.757
is a constantly changing
language, and it constantly

2262
02:06:26.757 --> 02:06:29.758
updating language. Because it's
relatively new compared to other

2263
02:06:29.758 --> 02:06:32.758
languages, we need to tell our
code, hey, this is the version

2264
02:06:32.758 --> 02:06:35.758
that I want you to use, we can
add the solidity version by

2265
02:06:35.758 --> 02:06:40.759
doing pragma. solidity. And then
the version that we want to use,

2266
02:06:40.759 --> 02:06:42.759
if we want to choose a very
specific version, we could say

2267
02:06:42.759 --> 02:06:48.760
zero, point 8.7. The most
current version to date is 0.8.

2268
02:06:48.760 --> 02:06:51.760
Point 12. But getting used to
different versions of solidity

2269
02:06:51.760 --> 02:06:54.760
is good practice, and different
versions of solidity are

2270
02:06:54.760 --> 02:06:57.761
considered more stable than
others. Zero point 8.7 is one of

2271
02:06:57.761 --> 02:07:00.761
those versions that is
considered more stable. These

2272
02:07:00.761 --> 02:07:03.761
double slashes here are what's
known as a comment, there are

2273
02:07:03.761 --> 02:07:06.761
places where you can type stuff
that won't actually get executed

2274
02:07:06.761 --> 02:07:09.762
in won't get compiled and isn't
really considered part of your

2275
02:07:09.762 --> 02:07:14.762
code. For example, I could write
Hello all. I'm Patrick. And if

2276
02:07:15.762 --> 02:07:17.762
we were going to run this code,
this part of my code would get

2277
02:07:17.762 --> 02:07:20.763
completely ignored. So this
double backslash is how we do

2278
02:07:20.763 --> 02:07:23.763
what's called comments. And as
we're coding, and as we're

2279
02:07:23.763 --> 02:07:27.763
building our projects, be sure
to use this comments tool to

2280
02:07:27.763 --> 02:07:31.764
your advantage every time you
write a new function, or you

2281
02:07:31.764 --> 02:07:34.764
learn something that you didn't
understand, or you learned

2282
02:07:34.764 --> 02:07:37.764
something new that you want to
remember, put it in a comment in

2283
02:07:37.764 --> 02:07:40.765
your code, you're going to be
most effective at taking notes

2284
02:07:40.765 --> 02:07:43.765
in this course, by making them
comments in your code and then

2285
02:07:43.765 --> 02:07:46.765
saving your code so you can
refer back to it later. So leave

2286
02:07:46.765 --> 02:07:49.766
comments in your code, leave
notes in your code. And that

2287
02:07:49.766 --> 02:07:51.766
will be one of the best ways for
you to understand what you're

2288
02:07:51.766 --> 02:07:54.766
coding when you want to refer
back to it later. Now when it

2289
02:07:54.766 --> 02:07:56.766
comes to the versions of
solidity, there's actually a few

2290
02:07:56.766 --> 02:07:59.767
different ways we can actually
write it, we can say we want to

2291
02:07:59.767 --> 02:08:04.767
use only zero point 8.7. And
this is how we would write that.

2292
02:08:04.767 --> 02:08:07.768
But maybe we're okay if we use a
more new version of solidity

2293
02:08:07.768 --> 02:08:11.768
than zero point 8.7 to tell our
code that we're okay with a more

2294
02:08:11.768 --> 02:08:15.768
new version, we can put a little
caret here. And this is how we

2295
02:08:15.768 --> 02:08:20.769
tell solidity. Hey, any version
of zero point 8.7 And above is

2296
02:08:20.769 --> 02:08:24.769
okay for this contract. This
means zero point 8.8 would work

2297
02:08:24.769 --> 02:08:29.770
zero point 8.9 0.8 point 10,
etc. But if we wanted to use

2298
02:08:29.770 --> 02:08:33.770
just 0.17, we would type in like
that if we want to use solidity

2299
02:08:33.770 --> 02:08:35.770
versions between a specific
range, we could do something

2300
02:08:36.770 --> 02:08:39.771
like this, we can say we want
our solidity version greater

2301
02:08:39.771 --> 02:08:45.771
than or equal to zero point 8.7
But less than zero point 9.0.

2302
02:08:45.771 --> 02:08:50.772
This means that any compiler
between zero point 8.7 and zero

2303
02:08:50.772 --> 02:08:55.772
point 9.0 would work. This means
zero point 8.8 would work. Zero

2304
02:08:55.772 --> 02:09:00.773
point 8.9 would work 0.8 point
10 would work. But zero point

2305
02:09:00.773 --> 02:09:06.773
9.0 would not work because it is
not strictly less than 0.9 point

2306
02:09:06.773 --> 02:09:09.774
00 point 9.1 would also not
work. To keep things simple for

2307
02:09:09.774 --> 02:09:13.774
us, we're going to use zero
point 8.8. And every line of

2308
02:09:13.774 --> 02:09:17.774
solidity that's completed, every
completed section needs to end

2309
02:09:17.774 --> 02:09:20.775
with one of these semicolons
this is how you tell solidity

2310
02:09:20.775 --> 02:09:23.775
it's the end of the line. Also
at the top of your code, you're

2311
02:09:23.775 --> 02:09:26.775
always going to want to put
what's called an spdx license

2312
02:09:26.775 --> 02:09:30.776
identifier. This is optional,
but some compilers will flag

2313
02:09:30.776 --> 02:09:33.776
your warning that you don't have
one. This is to make licensing

2314
02:09:33.776 --> 02:09:37.776
and sharing code a lot easier.
We have a link to more about how

2315
02:09:37.776 --> 02:09:40.777
licenses work in the section of
this lesson in our GitHub

2316
02:09:40.777 --> 02:09:45.777
repository to do an spdx license
identifier, we just say spdx

2317
02:09:45.777 --> 02:09:51.778
license identifier, and we're
gonna choose MIT, the MIT

2318
02:09:51.778 --> 02:09:54.778
license is one of the least
restrictive licenses out there.

2319
02:09:54.778 --> 02:09:58.779
So we use the MIT license for
most of our code samples once

2320
02:09:58.779 --> 02:10:01.779
you have a version and once you
have Is this much written, we

2321
02:10:01.779 --> 02:10:04.779
can actually go ahead and write
to our compiler tab and scroll

2322
02:10:04.779 --> 02:10:08.780
down and hit Compile, that
little turn thing will go. And

2323
02:10:08.780 --> 02:10:11.780
in a minute, we'll see, this
contract is attempted to be

2324
02:10:11.780 --> 02:10:14.780
compiled. Since we actually
don't have a contract, we see no

2325
02:10:14.780 --> 02:10:17.781
contract compiled yet, but we
see the compiler automatically

2326
02:10:17.781 --> 02:10:21.781
switched to zero point 8.8.
compiling our code means taking

2327
02:10:21.781 --> 02:10:24.781
our more human readable code
like pragma, solidity and

2328
02:10:24.781 --> 02:10:29.782
transforming it into computer
code, or very specific

2329
02:10:29.782 --> 02:10:32.782
instructions for the computer to
use. We'll go over what a lot of

2330
02:10:32.782 --> 02:10:36.782
this machine level code or this
computer level code is doing in

2331
02:10:36.782 --> 02:10:39.783
a later section. If you're using
a Mac, you can also hit command

2332
02:10:39.783 --> 02:10:42.783
S, and it will run the compiler
for you as well. On Windows, it

2333
02:10:42.783 --> 02:10:46.783
might be Ctrl S, we can actually
choose the compiler version that

2334
02:10:46.783 --> 02:10:49.784
we want to use. However, if we
tell in our code to specifically

2335
02:10:49.784 --> 02:10:53.784
use zero, point 8.8, and we hit
the compile button, it'll

2336
02:10:53.784 --> 02:10:56.784
automatically switch to zero
point 8.8. However, if we use

2337
02:10:56.784 --> 02:11:00.785
the carrot thing, we get
specifically say, hey, we want

2338
02:11:00.785 --> 02:11:05.785
0.8 point 10, we can hit
compile, and it will compile

2339
02:11:05.785 --> 02:11:09.786
with 0.8 point 10. Because
again, remember, the carrot says

2340
02:11:09.786 --> 02:11:13.786
we want to use at least zero,
point eight, all the way up to

2341
02:11:13.786 --> 02:11:18.787
the latest version of 0.8. Now
let's stay on zero point 8.8.

2342
02:11:18.787 --> 02:11:20.787
The next thing that we're going
to do in our code is define our

2343
02:11:20.787 --> 02:11:23.787
contract. And to get a full
screen view, you can go ahead

2344
02:11:23.787 --> 02:11:25.787
and hit the compiler button to
get rid of it there. To start

2345
02:11:25.787 --> 02:11:27.788
defining our contract, we're
gonna go ahead and write the

2346
02:11:27.788 --> 02:11:31.788
word contract. This tells
solidity that the next pieces of

2347
02:11:31.788 --> 02:11:35.788
code is going to be a contract
contract is a key word in

2348
02:11:35.788 --> 02:11:37.789
solidity, and it tells our
compiler that the next section

2349
02:11:37.789 --> 02:11:41.789
of this code is going to define
a contract. You can think of a

2350
02:11:41.789 --> 02:11:44.789
contract similar to a class in
any object oriented programming

2351
02:11:44.789 --> 02:11:48.790
like Java or JavaScript. Let's
go ahead and give our contract a

2352
02:11:48.790 --> 02:11:53.790
name here, we're going to call
RS simple storage. And then we

2353
02:11:53.790 --> 02:11:57.790
add this little open and close
curly brackets. Everything

2354
02:11:57.790 --> 02:12:00.791
inside this open and close curly
brackets is going to be the

2355
02:12:00.791 --> 02:12:03.791
contents of this contract.
Simple Storage. Now, if we go

2356
02:12:03.791 --> 02:12:06.791
ahead and hit command S or Ctrl
S, we can see this little green

2357
02:12:06.791 --> 02:12:09.792
checkmark show up. And if you
don't, you can always go back to

2358
02:12:09.792 --> 02:12:13.792
the compiler tab, scroll down
and hit Compile and see the

2359
02:12:13.792 --> 02:12:16.792
little green checkmark. That
little green checkmark means

2360
02:12:16.792 --> 02:12:19.793
that our code is compiling
successfully. And we don't have

2361
02:12:19.793 --> 02:12:21.793
any errors, we could
hypothetically deploy this

2362
02:12:21.793 --> 02:12:25.793
contract right now. And it would
be a valid contract. So

2363
02:12:25.793 --> 02:12:30.794
congratulations on writing your
first contract.

2364
02:12:30.794 --> 02:12:33.794
Now solidity has multiple
different types or primitive

2365
02:12:33.794 --> 02:12:36.794
data types. And if you go to the
solidity documentation, which

2366
02:12:36.794 --> 02:12:39.795
again, is in our GitHub
repository, you can read more

2367
02:12:39.795 --> 02:12:41.795
and learn more about the
different types that are in

2368
02:12:41.795 --> 02:12:45.795
here. The four most basic types
are going to be Boolean,

2369
02:12:45.795 --> 02:12:49.796
you int, int, and an address

2370
02:12:49.796 --> 02:12:52.796
or bytes, which is a lower level
type, which we'll talk about a

2371
02:12:52.796 --> 02:12:55.796
little bit later. A boolean
define some type of true false,

2372
02:12:55.796 --> 02:12:58.797
a you int is going to be an
unsigned integer, which means

2373
02:12:58.797 --> 02:13:01.797
it's going to be a whole number
that isn't positive or negative.

2374
02:13:01.797 --> 02:13:05.797
It's just positive, we have an
integer, which is going to be a

2375
02:13:05.797 --> 02:13:08.798
positive or negative whole
number. And then we have an

2376
02:13:08.798 --> 02:13:12.798
address, which is going to be an
address, like what we see in our

2377
02:13:12.798 --> 02:13:15.798
meta mask here. There are some
other types as well that you'll

2378
02:13:15.798 --> 02:13:18.799
learn later on. The reason that
we have these types is we use

2379
02:13:18.799 --> 02:13:22.799
them to define what different
variables are. Variables are

2380
02:13:22.799 --> 02:13:25.799
basically holders for different
values. For example, we could

2381
02:13:25.799 --> 02:13:31.800
create a variable called has
favorite number to represent if

2382
02:13:31.800 --> 02:13:35.800
somebody has a favorite number.
And we would put this bull

2383
02:13:35.800 --> 02:13:40.801
keyword before has to renumber
say, Okay, we have a variable

2384
02:13:40.801 --> 02:13:44.801
called has favorite number, and
it's of type boolean. So this

2385
02:13:44.801 --> 02:13:47.801
has favorite number is going to
represent a true or a false to

2386
02:13:47.801 --> 02:13:52.802
set its value, we could say has
favorite number equals true. Now

2387
02:13:52.802 --> 02:13:56.802
has favorite number is going to
be true. We could also say has

2388
02:13:56.802 --> 02:14:00.803
favorite number equals false. So
this Boolean has faded number is

2389
02:14:00.803 --> 02:14:05.803
now going to be false. For uns
we could say you went favorite

2390
02:14:05.803 --> 02:14:11.804
number equals and then set a
number 123. This means that our

2391
02:14:11.804 --> 02:14:14.804
favorite number is going to be
123 You'll enter is special

2392
02:14:14.804 --> 02:14:18.805
because we can actually specify
how many bits want to allocate

2393
02:14:18.805 --> 02:14:22.805
to this number bits and bytes
are pretty fundamental pieces of

2394
02:14:22.805 --> 02:14:24.805
information for computer
science. We're not going to go

2395
02:14:24.805 --> 02:14:27.805
over it here. However, there's a
fantastic video in the GitHub

2396
02:14:27.805 --> 02:14:30.806
repository that explains it
more. Basically, it's how much

2397
02:14:30.806 --> 02:14:34.806
storage or memory to allocate to
this number. How big can it get,

2398
02:14:34.806 --> 02:14:38.807
if we say a you int eight can
have eight bits all the way up

2399
02:14:38.807 --> 02:14:42.807
to you went to 56. If you don't
specify how big it is, it

2400
02:14:42.807 --> 02:14:46.807
automatically defaults to you
into 256. Oftentimes, it's

2401
02:14:46.807 --> 02:14:49.808
better when writing our code to
be very explicit. So usually

2402
02:14:49.808 --> 02:14:53.808
you'll see me just do you int
256 to represent a un 256. We

2403
02:14:53.808 --> 02:14:59.809
could also do an int favorite
number equals 123 or an int 256.

2404
02:14:59.809 --> 02:15:01.809
I'm just Going to go ahead and
add this Boolean back here,

2405
02:15:01.809 --> 02:15:05.809
we're going to change this back
to UNT to 36. And let's change

2406
02:15:05.809 --> 02:15:07.809
our favorite number to five
here, we could also do something

2407
02:15:07.809 --> 02:15:14.810
called strings, string, favorite
number in text

2408
02:15:14.810 --> 02:15:16.810
equals five

2409
02:15:16.810 --> 02:15:20.811
strings represent basically
words, and you can represent

2410
02:15:20.811 --> 02:15:23.811
them by putting them in these
quotes, it's going to be some

2411
02:15:23.811 --> 02:15:25.811
word or phrase, or really,
really just kind of any

2412
02:15:25.811 --> 02:15:30.812
combination of keystrokes in
here, our ends can be positive

2413
02:15:30.812 --> 02:15:35.812
or negative. So we could say,
negative five or positive five,

2414
02:15:35.812 --> 02:15:39.813
both are going to be valid,
since we can also do address my

2415
02:15:39.813 --> 02:15:45.813
address equals and grab our
address, right from Metamask.

2416
02:15:45.813 --> 02:15:48.814
And paste it in, you'll notice
that we end all of these lines

2417
02:15:48.814 --> 02:15:53.814
of code with the semicolon. We
also have bytes objects, or a

2418
02:15:53.814 --> 02:15:56.814
bytes 32, again, representing
how many bytes we want them to

2419
02:15:56.814 --> 02:16:04.815
be. And this says that we have
called favorite bytes, and we're

2420
02:16:04.815 --> 02:16:07.815
just gonna set it equal to cat.
So strings are actually really

2421
02:16:07.815 --> 02:16:11.816
interesting, because strings are
secretly just bytes objects, but

2422
02:16:11.816 --> 02:16:15.816
only for text to a cat is
actually a string, but can

2423
02:16:15.816 --> 02:16:18.817
automatically get converted into
one of these bytes object bytes,

2424
02:16:18.817 --> 02:16:23.817
objects typically look like 0x.
And then some random letters and

2425
02:16:23.817 --> 02:16:26.817
numbers that represent the bytes
object, but cat can

2426
02:16:26.817 --> 02:16:29.818
automatically get converted down
to bytes. We'll talk about bytes

2427
02:16:29.818 --> 02:16:32.818
more in coming sessions, you can
also do bytes, two bytes, three

2428
02:16:32.818 --> 02:16:37.818
bytes, five bytes 22, you get
the picture for our uns and our

2429
02:16:37.818 --> 02:16:41.819
into the sixth lowest we can go
is eight bits, because eight

2430
02:16:41.819 --> 02:16:44.819
bits is a byte. And we can go up
by steps of eight. So we can do

2431
02:16:44.819 --> 02:16:51.820
816 32, etc, all the way to 256.
For example, down here, we can't

2432
02:16:51.820 --> 02:16:58.820
do bytes 64. And if we go ahead
and try to compile this, we get

2433
02:16:58.820 --> 02:17:02.821
a little red thing here. And if
we scroll down, we get a

2434
02:17:02.821 --> 02:17:06.821
declaration error identifier not
found or not unique. Bytes 64

2435
02:17:06.821 --> 02:17:10.822
favorite bytes equals cats. And
we even got a little red warning

2436
02:17:10.822 --> 02:17:13.822
sign here in our remix. This is
remix telling us there's

2437
02:17:13.822 --> 02:17:16.822
something wrong with this line.
So we can switch back to bite

2438
02:17:16.822 --> 02:17:20.823
32. Since byte 32 is the maximum
size that a bytes can be, you

2439
02:17:20.823 --> 02:17:23.823
could also do just a bytes
object, which means it can have

2440
02:17:23.823 --> 02:17:26.823
any size, but we typically want
to be explicit. And we're going

2441
02:17:26.823 --> 02:17:29.824
to stick with bytes 32 For now
want to learn more about the

2442
02:17:29.824 --> 02:17:32.824
different types and how to use
them and all the different

2443
02:17:32.824 --> 02:17:34.824
features with them, be sure to
check out the solidity

2444
02:17:34.824 --> 02:17:37.824
documentation. For now for our
simple storage, let's say we

2445
02:17:37.824 --> 02:17:40.825
only want to store numbers. So
let's go ahead and delete

2446
02:17:40.825 --> 02:17:45.825
everything except for the
favorite number section.

2447
02:17:45.825 --> 02:17:46.825
Now in solidity,

2448
02:17:46.825 --> 02:17:50.826
if I do this, and I remove the
equals five, this favorite

2449
02:17:50.826 --> 02:17:54.826
number actually does get set to
a default value, the default

2450
02:17:54.826 --> 02:17:57.826
value for solidity is going to
be whatever the null value is,

2451
02:17:57.826 --> 02:18:01.827
which in solidity is case zero.
So saying you Intuit six

2452
02:18:01.827 --> 02:18:04.827
favorite number is going to be
the same as saying you 256

2453
02:18:04.827 --> 02:18:08.828
favorite number equals zero
since it gets initialized to

2454
02:18:08.828 --> 02:18:11.828
zero. So for now, let's not
initialize it to anything. So

2455
02:18:11.828 --> 02:18:15.828
that favorite number will
automatically start off as zero.

2456
02:18:15.828 --> 02:18:17.828
Now, if you get confused, as
you're coding along, and you're

2457
02:18:17.828 --> 02:18:21.829
following along with me, be sure
to write comments in your code

2458
02:18:21.829 --> 02:18:24.829
so you know what's going on. So
maybe, for example, a great

2459
02:18:24.829 --> 02:18:30.830
comment here would be this gets
initially alized to zero. And

2460
02:18:30.830 --> 02:18:35.830
then if that's even confusing,
you could say, this means that

2461
02:18:35.830 --> 02:18:44.831
this section is a comment. Now
let's go ahead and create a

2462
02:18:44.831 --> 02:18:47.831
function functions or methods
are self contained modules that

2463
02:18:48.831 --> 02:18:51.832
will execute some specific set
of instructions for us, when we

2464
02:18:51.832 --> 02:18:54.832
call it if you're familiar with
Java, or Python, or JavaScript

2465
02:18:54.832 --> 02:18:57.832
or anything like that functions
work the exact same way

2466
02:18:57.832 --> 02:19:01.833
functions get identified by the
keyword function, let's create a

2467
02:19:01.833 --> 02:19:06.833
function called store that will
change the value of favorite

2468
02:19:06.833 --> 02:19:10.834
number to some new value. And
the number that we're going to

2469
02:19:10.834 --> 02:19:13.834
change it to is going to be
variables that are passed to our

2470
02:19:13.834 --> 02:19:16.834
store function here. So we're
going to allow our store

2471
02:19:16.834 --> 02:19:22.835
function to take a variable of
type un 256. And we'll call it

2472
02:19:22.835 --> 02:19:25.835
underscore favorite

2473
02:19:25.835 --> 02:19:28.836
number, we'll make this a public
function, which we'll get to in

2474
02:19:28.836 --> 02:19:30.836
a minute. And all we're going to
do is we're going to set

2475
02:19:30.836 --> 02:19:34.836
favorite number equal to
whatever variable that we just

2476
02:19:34.836 --> 02:19:39.837
passed. So now we have this
function called store, that it

2477
02:19:39.837 --> 02:19:43.837
takes some parameter that we're
going to give it and it sets

2478
02:19:43.837 --> 02:19:46.837
this favorite number variable
equal to whatever number that we

2479
02:19:46.837 --> 02:19:49.838
give this function. Now to see
this actually in action, let's

2480
02:19:49.838 --> 02:19:52.838
deploy this to an even thicker
blockchain than a test net.

2481
02:19:52.838 --> 02:19:55.838
We're going to actually deploy
this to a local network or a

2482
02:19:55.838 --> 02:19:59.839
JavaScript VM. And first before
we can even do that, let's just

2483
02:19:59.839 --> 02:20:01.839
make sure that it's going
compiling correctly looks like

2484
02:20:01.839 --> 02:20:04.839
we have a green checkmark, which
is good. And we'll come down to

2485
02:20:04.839 --> 02:20:08.840
this button here, which is our
deploy and run Transactions tab.

2486
02:20:08.840 --> 02:20:11.840
Our deploy and run Transactions
tab has a ton of different

2487
02:20:11.840 --> 02:20:14.840
configuration pieces for
actually deploying this

2488
02:20:14.840 --> 02:20:18.840
contract. First, we want to make
sure we are on the JavaScript VM

2489
02:20:18.840 --> 02:20:21.841
London piece here, JavaScript VM
means we're going to be

2490
02:20:21.841 --> 02:20:26.841
deploying to a fake local
JavaScript VM. The JavaScript VM

2491
02:20:26.841 --> 02:20:30.842
is a fake local blockchain where
we can simulate transactions

2492
02:20:30.842 --> 02:20:33.842
really quickly without having to
wait for them to go through on a

2493
02:20:33.842 --> 02:20:36.842
test net, don't worry about the
London versus Berlin piece here

2494
02:20:36.842 --> 02:20:39.843
for now, injected web three and
web three provider we'll talk

2495
02:20:39.843 --> 02:20:42.843
about in a little bit. We also
have this account section here.

2496
02:20:42.843 --> 02:20:46.843
When we run on our fake
JavaScript VM, we're given a

2497
02:20:46.843 --> 02:20:49.844
whole bunch of fake accounts
from where to deploy from, and

2498
02:20:49.844 --> 02:20:53.844
we're given 100 eath. For each
one of these fake accounts, you

2499
02:20:53.844 --> 02:20:56.844
can kind of think of it similar
to our meta mask account in meta

2500
02:20:56.844 --> 02:21:01.845
mask, except for the difference
here is that this is this fake

2501
02:21:01.845 --> 02:21:04.845
JavaScript VM Aetherium that
we're given. For our

2502
02:21:04.845 --> 02:21:06.845
transactions, including
deploying contracts, we're

2503
02:21:06.845 --> 02:21:09.846
actually given a gas limit,
there's also values we can send,

2504
02:21:09.846 --> 02:21:12.846
and we can choose our contracts.
Right now we only have one

2505
02:21:12.846 --> 02:21:15.846
contract, simple storage, so
that's going to be the one that

2506
02:21:15.846 --> 02:21:18.847
we're going to deploy. So on the
left hand side, to deploy this

2507
02:21:18.847 --> 02:21:22.847
to our fake JavaScript VM, we're
gonna go ahead and hit the

2508
02:21:22.847 --> 02:21:24.847
Deploy button. And if we scroll
all the way down to the bottom,

2509
02:21:24.847 --> 02:21:30.848
now, we can see a contract was
deployed. It says simple storage

2510
02:21:30.848 --> 02:21:34.848
at x, blah, blah, blah, blah,
blah. And we see this orange

2511
02:21:34.848 --> 02:21:38.849
button store with come this
grade text you in 256,

2512
02:21:38.849 --> 02:21:42.849
underscore favorite number on
our fake local blockchain, we're

2513
02:21:42.849 --> 02:21:46.849
actually given an address every
single smart contract, it has an

2514
02:21:46.849 --> 02:21:51.850
address, just like how our
wallets have an address. So if

2515
02:21:51.850 --> 02:21:55.850
we hit this copy button here,
and we put it into a comment,

2516
02:21:55.850 --> 02:21:59.851
make this a little bit bigger,
we can see that the address of

2517
02:21:59.851 --> 02:22:02.851
this contract that we just
deployed, is located at this

2518
02:22:02.851 --> 02:22:06.851
address. Additionally, if you
pull up the slider over here,

2519
02:22:06.851 --> 02:22:08.851
you'll be able to see this
little green checkmark with all

2520
02:22:08.851 --> 02:22:11.852
this information about this
deployment. And you can hit the

2521
02:22:11.852 --> 02:22:14.852
little drop down and see a whole
lot more information about this.

2522
02:22:14.852 --> 02:22:17.852
Something you might notice is
you'll see some familiar

2523
02:22:17.852 --> 02:22:22.853
keywords like status,
transaction hash, from to gas,

2524
02:22:22.853 --> 02:22:27.853
etc. When we deploy a contract,
it's actually the same as

2525
02:22:27.853 --> 02:22:30.854
sending a transaction. Remember,
anytime we do anything on the

2526
02:22:30.854 --> 02:22:36.854
blockchain, we modify any value,
we are sending a transaction. So

2527
02:22:36.854 --> 02:22:40.855
deploying a contract is
modifying the blockchain to have

2528
02:22:40.855 --> 02:22:43.855
this contract, it's modifying
the state of the blockchain. And

2529
02:22:43.855 --> 02:22:45.855
if we had sent this on a
Rinkeby, or COVID, or main net

2530
02:22:45.855 --> 02:22:49.856
network, we would have had to
spend the gas to actually deploy

2531
02:22:49.856 --> 02:22:53.856
this contract. And this is the
simulation of how much gas and

2532
02:22:53.856 --> 02:22:56.856
the transaction hash and from
and to and all this other stuff

2533
02:22:56.856 --> 02:22:59.857
about our transaction had, we
actually deployed it to a real

2534
02:22:59.857 --> 02:23:02.857
network. But since it's
JavaScript VM, it's all fake

2535
02:23:02.857 --> 02:23:05.857
information. Now we have this
big orange button store, this

2536
02:23:05.857 --> 02:23:08.858
big orange button resembles the
store function that we just

2537
02:23:08.858 --> 02:23:12.858
created. So if we add some
number into this store, like

2538
02:23:12.858 --> 02:23:16.858
123, and we hit the Store
button, we actually call this

2539
02:23:16.858 --> 02:23:19.859
store button. And we actually
execute a transaction on our

2540
02:23:19.859 --> 02:23:25.859
fake Jasika. Blockchain to store
the number 1234 favorite number.

2541
02:23:25.859 --> 02:23:29.860
And if we scroll all the way up
to our account, now, you'll see

2542
02:23:29.860 --> 02:23:32.860
that we have a little bit less
ether in our fake account. This

2543
02:23:32.860 --> 02:23:37.860
is because we spent the gas to
actually call this contract. And

2544
02:23:37.860 --> 02:23:40.861
if we pull up this bottom bit
here, and I call this with five

2545
02:23:40.861 --> 02:23:43.861
I call store, you'll see it
flashed for a quick second, we

2546
02:23:43.861 --> 02:23:47.861
sent another transaction to
store the value five in our

2547
02:23:47.861 --> 02:23:50.862
favorite number. Now the
question might be having is,

2548
02:23:50.862 --> 02:23:53.862
that's really cool, Patrick, but
I can't see what favorite number

2549
02:23:53.862 --> 02:23:56.862
actually is, how do I know that
those transactions are actually

2550
02:23:56.862 --> 02:24:00.863
going through? Well, right now,
the visibility of our favorite

2551
02:24:00.863 --> 02:24:04.863
number is set to private, so we
actually can't see it. And we'll

2552
02:24:04.863 --> 02:24:07.863
talk about visibility in just a
second. To make it so that we

2553
02:24:07.863 --> 02:24:10.864
can see it. We'll change our
favorite numbers visibility to

2554
02:24:10.864 --> 02:24:14.864
public. So let's go ahead, we'll
recompile we'll go back to the

2555
02:24:14.864 --> 02:24:18.864
deploy tab. We'll click the
little x here, which is to say

2556
02:24:18.864 --> 02:24:21.865
let's get rid of this contract.
And it just gets rid of it from

2557
02:24:21.865 --> 02:24:23.865
our window here. It doesn't
actually get rid of it from the

2558
02:24:23.865 --> 02:24:27.865
blockchain, because again,
they're immutable, well, kind of

2559
02:24:27.865 --> 02:24:30.866
immutable, since again, this is
kind of a fake simulated chain.

2560
02:24:30.866 --> 02:24:34.866
But we go ahead and compile, and
now we hit Deploy again. And if

2561
02:24:34.866 --> 02:24:37.866
we scroll down, our new
contract, will now have two

2562
02:24:37.866 --> 02:24:41.867
buttons. One is the orange
button for store. But now we

2563
02:24:41.867 --> 02:24:45.867
have a New Favorite button. This
button represents this public

2564
02:24:45.867 --> 02:24:48.868
variable favorite number, and it
resembles a function saying,

2565
02:24:48.868 --> 02:24:52.868
Hey, show me what favorite
number is. So if I were to click

2566
02:24:52.868 --> 02:24:55.868
this favorite number button,
what do you think will show up?

2567
02:24:55.868 --> 02:24:58.868
Well, do you remember what this
gets initialized to? Well, let's

2568
02:24:58.868 --> 02:25:02.869
click it now. We do indeed See
that zero shows up, we see that

2569
02:25:02.869 --> 02:25:06.869
this is a YouTube ID six, and
the value stored in it is zero.

2570
02:25:06.869 --> 02:25:10.870
Now, if I were to change that
number to five by calling the

2571
02:25:10.870 --> 02:25:13.870
store function, and now hitting
favorite number, we do indeed

2572
02:25:13.870 --> 02:25:16.870
see, favorite number gets
updated to five functions and

2573
02:25:16.870 --> 02:25:20.871
variables can have one for
visibility specifiers, we have

2574
02:25:20.871 --> 02:25:26.871
public, private, external, and
internal. Public is visible

2575
02:25:26.871 --> 02:25:30.872
externally and internally,
meaning anybody who interacts

2576
02:25:30.872 --> 02:25:33.872
with this contract or sees this
contract can see what's stored

2577
02:25:33.872 --> 02:25:35.872
in this favorite number
function. You'll see here in the

2578
02:25:35.872 --> 02:25:38.872
solidity documentation, it says
it creates a getter function for

2579
02:25:38.872 --> 02:25:41.873
the storage slash state
variables. When we add this

2580
02:25:41.873 --> 02:25:44.873
keyword public to favorite
number, what we're actually

2581
02:25:44.873 --> 02:25:47.873
doing is we're creating what's
called a getter function for

2582
02:25:47.873 --> 02:25:50.874
favorite number, we're basically
creating a function that says to

2583
02:25:50.874 --> 02:25:54.874
return the value of favorite
number, and that's why this blue

2584
02:25:54.874 --> 02:25:57.874
button pops up. Because this
blue button is a function that

2585
02:25:57.874 --> 02:26:02.875
says, hey, return the value of
favorite number private means

2586
02:26:02.875 --> 02:26:05.875
only this specific contract can
call this function. Now for

2587
02:26:05.875 --> 02:26:10.876
storage, it doesn't mean only
this contract can read what's

2588
02:26:10.876 --> 02:26:13.876
stored here. And we'll get into
that a little bit later. But by

2589
02:26:13.876 --> 02:26:15.876
that means, this is the only
contract that can call the

2590
02:26:15.876 --> 02:26:18.876
favorite number function.
Private functions are only

2591
02:26:18.876 --> 02:26:21.877
visible to the current contract.
External functions are only

2592
02:26:21.877 --> 02:26:25.877
visible externally, meaning
somebody outside this contract

2593
02:26:25.877 --> 02:26:29.878
can call this function. And then
internal means that only this

2594
02:26:29.878 --> 02:26:32.878
contract and it's children
contracts can actually read it,

2595
02:26:32.878 --> 02:26:36.878
but we'll get into that a little
bit later, too. So oddly enough,

2596
02:26:36.878 --> 02:26:39.879
variables are just function
calls. Now, the reason that we

2597
02:26:39.879 --> 02:26:42.879
didn't see favorite numbers show
up on the left hand side, when

2598
02:26:42.879 --> 02:26:45.879
we first deployed this without
the public keyword. When we

2599
02:26:45.879 --> 02:26:47.879
don't give a visibility
specifier to functions or

2600
02:26:47.879 --> 02:26:51.880
variables, they automatically
get deployed as internal. And as

2601
02:26:51.880 --> 02:26:54.880
we know, internal functions and
variables can only be called by

2602
02:26:54.880 --> 02:26:57.880
this specific contract or
derived contracts, which again,

2603
02:26:57.880 --> 02:27:01.881
we'll get into later. So let's
just keep it public. For now,

2604
02:27:01.881 --> 02:27:04.881
the reason that we're prefixing,
our parameter here with an

2605
02:27:04.881 --> 02:27:09.882
underscore is a way to tell us,
hey, this variable here is

2606
02:27:09.882 --> 02:27:11.882
different from the favorite
number global, there are some

2607
02:27:11.882 --> 02:27:14.882
different naming conventions
that are used for parameters.

2608
02:27:14.882 --> 02:27:17.882
And as we get later into the
course, will understand more and

2609
02:27:17.882 --> 02:27:20.883
more of what good names are
parameters are, every time we

2610
02:27:20.883 --> 02:27:23.883
call this store function. And we
change the value here, we're

2611
02:27:24.883 --> 02:27:27.883
actually sending a transaction
because remember, every single

2612
02:27:27.883 --> 02:27:30.884
time we change the state of the
blockchain, we do it in a

2613
02:27:30.884 --> 02:27:33.884
transaction. And we can see all
the details here. If you go over

2614
02:27:33.884 --> 02:27:37.884
to the transaction details in
the logging area of your remix,

2615
02:27:37.884 --> 02:27:41.885
you can actually scroll down and
you can see the transaction cost

2616
02:27:41.885 --> 02:27:44.885
in units of gas, you'll see a
number of something around this.

2617
02:27:44.885 --> 02:27:48.885
And you'll notice it's more than
that 21,000 number from sending

2618
02:27:48.885 --> 02:27:50.886
Aetherium. That's because we're
doing something more

2619
02:27:50.886 --> 02:27:55.886
computationally expensive. We're
actually storing a number over

2620
02:27:55.886 --> 02:27:59.887
here. Now what do you think will
happen if we do more inside of

2621
02:27:59.887 --> 02:28:01.887
the store function as well. So
instead of just storing this

2622
02:28:01.887 --> 02:28:06.887
number, maybe what else we do is
we will store the number here.

2623
02:28:06.887 --> 02:28:08.887
And then we'll update our
favorite number will say

2624
02:28:08.887 --> 02:28:11.888
favorite number equals favorite
number plus one. Since we're

2625
02:28:11.888 --> 02:28:15.888
doing more stuff, now we should
see this store function actually

2626
02:28:15.888 --> 02:28:19.889
become more expensive. So let's
go ahead and recompile we'll do

2627
02:28:19.889 --> 02:28:24.889
delete this will redeploy. We
now have a new contract will

2628
02:28:24.889 --> 02:28:29.890
store five again. Now if we look
in the details of this

2629
02:28:29.890 --> 02:28:33.890
transaction, and we scroll down
to execution costs, we do indeed

2630
02:28:33.890 --> 02:28:36.890
see the amount of gas has
greatly increased. And that's

2631
02:28:36.890 --> 02:28:40.891
because we're doing more things,
this store function is now more

2632
02:28:40.891 --> 02:28:44.891
computationally expensive. And
like I said, each blockchain has

2633
02:28:44.891 --> 02:28:46.891
a little different way of how
they actually calculate gas. But

2634
02:28:46.891 --> 02:28:50.892
the easiest way to think about
it is, the more stuff you do,

2635
02:28:50.892 --> 02:28:54.892
the more expensive that
transaction is going to cost. So

2636
02:28:54.892 --> 02:28:57.892
let's go ahead and delete this
line to continue our example.

2637
02:28:57.892 --> 02:29:02.893
Now let's talk about scope for a
second, our favorite number is

2638
02:29:02.893 --> 02:29:05.893
basically in something called
the global scope, meaning

2639
02:29:05.893 --> 02:29:09.894
anything inside of these
brackets can access this

2640
02:29:09.894 --> 02:29:11.894
favorite number variable. But
what if I did something like

2641
02:29:11.894 --> 02:29:17.894
this? What if I made a un 256
called Test var? And I set it

2642
02:29:17.894 --> 02:29:21.895
equal to five? And then I
created a new function called

2643
02:29:21.895 --> 02:29:26.895
something will have it take no
parameters and be public? Could

2644
02:29:26.895 --> 02:29:30.896
I access the test var and then
change it to something like six?

2645
02:29:30.896 --> 02:29:33.896
Can we do that? Well, let's go
ahead and see what happens when

2646
02:29:33.896 --> 02:29:37.896
we try to compile this. We
actually run into an error. We

2647
02:29:37.896 --> 02:29:41.897
had expected primary expression
right here. Oh, well, that's

2648
02:29:41.897 --> 02:29:44.897
because I have the double
question mark. Let's try now. We

2649
02:29:44.897 --> 02:29:48.897
get undeclared identifier. Our
something function doesn't know

2650
02:29:48.897 --> 02:29:51.898
about this test var when you
create variables, they only can

2651
02:29:51.898 --> 02:29:55.898
be viewed in the scope of where
they are. Now if that's a little

2652
02:29:55.898 --> 02:29:57.898
confusing, just look for the
curly brackets. These two curly

2653
02:29:57.898 --> 02:30:01.899
brackets encompass this whole
We'll section here write, the

2654
02:30:01.899 --> 02:30:04.899
opening one is up here, the
closing one is down here. So if

2655
02:30:04.899 --> 02:30:08.899
I create a variable directly
inside of these curly brackets,

2656
02:30:08.899 --> 02:30:12.900
that means everything in here
can access it. However, test var

2657
02:30:12.900 --> 02:30:15.900
was created inside of these
curly brackets, which means that

2658
02:30:15.900 --> 02:30:19.901
only stuff inside of these curly
brackets can access test var,

2659
02:30:19.901 --> 02:30:23.901
since our functions something
isn't inside of store, or

2660
02:30:23.901 --> 02:30:27.901
something function won't know
about test var. So that's how

2661
02:30:27.901 --> 02:30:30.902
scope works, you want to look to
see if your variable that you

2662
02:30:30.902 --> 02:30:33.902
created is inside of these curly
brackets. And that's how you can

2663
02:30:33.902 --> 02:30:38.902
know if other functions can work
with them. So this is why this

2664
02:30:38.902 --> 02:30:41.903
fails. Now, like what we saw in
the documentation, when we add

2665
02:30:41.903 --> 02:30:44.903
this public variable to favorite
number, we're secretly adding a

2666
02:30:44.903 --> 02:30:48.903
function that just returns this
favorite number, we can also add

2667
02:30:48.903 --> 02:30:51.904
our own function that also
returns the favorite number to

2668
02:30:51.904 --> 02:30:53.904
resemble the function that's
getting created in the backend.

2669
02:30:53.904 --> 02:30:58.904
So we can say function, we call
it retrieve, and we make it a

2670
02:30:58.904 --> 02:31:05.905
public view. And we'll say it
returns, you went to 56. or

2671
02:31:05.905 --> 02:31:08.905
explain what that means in just
a second. And we'll say return

2672
02:31:08.905 --> 02:31:13.906
favorite number. Now, I'm going
to hit command S, which again,

2673
02:31:13.906 --> 02:31:16.906
I'm going to do that a lot
throughout this section. But

2674
02:31:16.906 --> 02:31:19.907
just remember that that's
equivalent to me going to the

2675
02:31:19.907 --> 02:31:22.907
compile tab and hitting compile.
Now if we go to the deploy tab,

2676
02:31:22.907 --> 02:31:26.907
delete our last one, deploy a
new one, we now have a retrieve

2677
02:31:26.907 --> 02:31:30.908
function, which is going to
return the exact same thing that

2678
02:31:30.908 --> 02:31:32.908
our favorite number is going to
return. Again, if we update this

2679
02:31:32.908 --> 02:31:36.908
to five, called favorite number
and then retrieve they both now

2680
02:31:36.908 --> 02:31:40.909
return five. Now as you can see
here, these two functions are

2681
02:31:40.909 --> 02:31:44.909
blue, but this function is
orange. What's the difference?

2682
02:31:44.909 --> 02:31:47.909
Why did these have these
different colors? Well, the key

2683
02:31:47.909 --> 02:31:50.910
lies in this view keyword here,
there are actually two keywords

2684
02:31:50.910 --> 02:31:54.910
in solidity that notate a
function that doesn't actually

2685
02:31:54.910 --> 02:31:58.910
have to spend gas to run. And
those keywords are view, and

2686
02:31:58.910 --> 02:32:02.911
pure. And let's also get rid of
this variable here. A function

2687
02:32:02.911 --> 02:32:06.911
that is a view function means
we're just going to read state

2688
02:32:06.911 --> 02:32:08.911
from this contract, we're just
going to read something off of

2689
02:32:08.911 --> 02:32:11.912
this contract. For example, our
retrieve function right now is

2690
02:32:11.912 --> 02:32:14.912
just reading what favorite
number is, a view function

2691
02:32:14.912 --> 02:32:19.912
disallows any modification of
state. So you can't update the

2692
02:32:19.912 --> 02:32:22.913
blockchain at all with a view
function. Pure functions also

2693
02:32:22.913 --> 02:32:26.913
disallow any modification of
state. So we couldn't update our

2694
02:32:26.913 --> 02:32:29.914
favorite number. Not only that,
but they also disallow reading

2695
02:32:29.914 --> 02:32:32.914
from the blockchain. So we
couldn't read favorite number

2696
02:32:32.914 --> 02:32:36.914
either. Instead, what you might
do with a pure function is maybe

2697
02:32:36.914 --> 02:32:38.914
something like

2698
02:32:38.914 --> 02:32:45.915
function, add public here, one
plus one,

2699
02:32:45.915 --> 02:32:51.916
or return, one plus one, this
would be turns you into 36,

2700
02:32:51.916 --> 02:32:54.916
maybe something like this, maybe
there's some math you want to

2701
02:32:54.916 --> 02:32:57.916
use over and over again, maybe
there's some specific algorithm

2702
02:32:57.916 --> 02:32:59.917
that you want to implement that
doesn't actually need to read

2703
02:32:59.917 --> 02:33:03.917
any storage, etc. Now, if we
call a view function, or a pure

2704
02:33:03.917 --> 02:33:07.917
function by itself, we actually
don't need to spend any gas.

2705
02:33:07.917 --> 02:33:09.918
Since we're just reading from
the blockchain. Remember, we

2706
02:33:09.918 --> 02:33:13.918
only spend gas we only make a
transaction if we modify the

2707
02:33:13.918 --> 02:33:17.918
blockchain state. So you'll
notice in our little console

2708
02:33:17.918 --> 02:33:21.919
down here, that if I call
retrieve this call things comes

2709
02:33:21.919 --> 02:33:24.919
up. However, it looks different
than when we call the store

2710
02:33:24.919 --> 02:33:26.919
function. And we call the store
function, we get this little

2711
02:33:26.919 --> 02:33:30.920
checkmark, we get a hash, we
don't get a little checkmark.

2712
02:33:30.920 --> 02:33:33.920
And we don't get a hash with the
calls. That's because clicking

2713
02:33:33.920 --> 02:33:37.920
these blue buttons doesn't make
a transaction. This is saying,

2714
02:33:37.920 --> 02:33:39.921
Hey, we're just going to read
off chain, we're just going to

2715
02:33:39.921 --> 02:33:43.921
read this value. However, if you
look in the details of this

2716
02:33:43.921 --> 02:33:46.921
call, there's this execution
cost bit here. So what's going

2717
02:33:46.921 --> 02:33:50.922
on? Well, we can read this part
right here, cost only applies

2718
02:33:50.922 --> 02:33:54.922
when called by contract. If we
do have a function that calls

2719
02:33:54.922 --> 02:33:58.922
retrieve, if there's a function
that is updating state that

2720
02:33:58.922 --> 02:34:01.923
calls a view or a pure function,
that's the only time it'll cost

2721
02:34:01.923 --> 02:34:05.923
gas. So for example, if our
store function which is not a

2722
02:34:05.923 --> 02:34:08.923
view function, were to call
retrieve at some point, then

2723
02:34:08.923 --> 02:34:12.924
we'd have to pay the cost of the
Retrieve because reading from

2724
02:34:12.924 --> 02:34:16.924
the blockchain cost this
computation and cost gas calling

2725
02:34:16.924 --> 02:34:20.925
view functions is free, unless
you're calling it inside of a

2726
02:34:20.925 --> 02:34:24.925
function that costs gas, in
which case it will cost gas. So

2727
02:34:24.925 --> 02:34:31.926
if we leave it here, we delete
this recompile redeploy. We had

2728
02:34:31.926 --> 02:34:34.926
favorite number retrieved, they
both still cost nothing. But if

2729
02:34:34.926 --> 02:34:40.927
we add, restore eight in here,
we can see, we can see our

2730
02:34:40.927 --> 02:34:43.927
execution cost has gone up from
what it was without retrieve,

2731
02:34:43.927 --> 02:34:45.927
which we can go ahead, we can
compile, I hit command us to

2732
02:34:45.927 --> 02:34:50.928
compile here, we can deploy.
Let's go ahead and store again.

2733
02:34:50.928 --> 02:34:53.928
We'll click on that transaction,
we can see that it's much

2734
02:34:53.928 --> 02:34:56.928
cheaper without that retrieve
function in there. And again,

2735
02:34:56.928 --> 02:34:59.929
our favorite number variable as
long as it has this public

2736
02:34:59.929 --> 02:35:04.929
visible solidity, it also is
counted as a view function that

2737
02:35:04.929 --> 02:35:08.929
returns a un 256. The returns
keyword means what is this

2738
02:35:08.929 --> 02:35:11.930
function going to give us after
we call it so we say this

2739
02:35:11.930 --> 02:35:15.930
function is going to give us
this function is going to return

2740
02:35:15.930 --> 02:35:20.931
a un 256. When we call retrieve,
it's going to return or give us

2741
02:35:20.931 --> 02:35:25.931
a utility six. This is the
result of calling the function

2742
02:35:25.931 --> 02:35:31.932
this six is the result of
calling arbitrary function.

2743
02:35:31.932 --> 02:35:32.932
Now our contract is

2744
02:35:32.932 --> 02:35:35.932
good as it is, it allows us to
store a single favorite number.

2745
02:35:35.932 --> 02:35:38.932
But what if we want to store a
range of favorite numbers? Or

2746
02:35:38.932 --> 02:35:42.933
maybe we want to store a whole
bunch of different people who

2747
02:35:42.933 --> 02:35:44.933
have different favorite numbers?
Well, how do we do that there

2748
02:35:44.933 --> 02:35:46.933
are several different ways that
we can approach this, one of the

2749
02:35:46.933 --> 02:35:48.933
ways we could start approaching
this is by creating what's

2750
02:35:48.933 --> 02:35:53.934
called a struct of people. Or we
create a new type. In our

2751
02:35:53.934 --> 02:35:57.934
solidity, we can create a people
object that holds both someone's

2752
02:35:57.934 --> 02:36:02.935
name, and their favorite number.
To do that, we say struct

2753
02:36:02.935 --> 02:36:11.936
people, you went to 56, favorite
number, and a string name. Now

2754
02:36:11.936 --> 02:36:15.936
we've created a new type called
people kinda like you intuited

2755
02:36:15.936 --> 02:36:19.937
six, or Boolean, or string. Now
we have a people type that we

2756
02:36:19.937 --> 02:36:23.937
can use. Now similar to how we
created a un 256 public favorite

2757
02:36:23.937 --> 02:36:28.937
number, we can do the exact same
thing. But with a people, we

2758
02:36:28.937 --> 02:36:33.938
could say people public, we call
this person, and we can create a

2759
02:36:33.938 --> 02:36:37.938
new people and assign it to this
variable person. So we'll say

2760
02:36:37.938 --> 02:36:42.939
equals people public person,
equals, and we'll add

2761
02:36:42.939 --> 02:36:46.939
parentheses here to signify
we're creating a new person. And

2762
02:36:46.939 --> 02:36:49.940
since we made this a struct, we
add little curly brackets here

2763
02:36:49.940 --> 02:36:52.940
to let solidity know that we're
going to be grabbing from these

2764
02:36:52.940 --> 02:36:57.940
struct variables, we'll say
favorite number is going to be

2765
02:36:57.940 --> 02:37:04.941
two, and the name is going to be
Patrick semicolon, and then we

2766
02:37:04.941 --> 02:37:07.941
can hit Ctrl S, or we can go
ahead and compile. Now if we go

2767
02:37:07.941 --> 02:37:15.942
ahead and deploy this we now
have a new person, since this,

2768
02:37:15.942 --> 02:37:19.942
again, is a public variable, it
has a getter function called

2769
02:37:19.942 --> 02:37:23.943
person. And if we click person,
we see our new object, the

2770
02:37:23.943 --> 02:37:27.943
favorite number is two. And then
the name is Patrick, you see

2771
02:37:27.943 --> 02:37:31.944
this zero and this one, because
these are showing the index of

2772
02:37:31.944 --> 02:37:33.944
the different variables. But
those of you new to computer

2773
02:37:33.944 --> 02:37:36.944
science, typically in computer
science, let's start with the

2774
02:37:36.944 --> 02:37:39.945
number zero. So what are zero
with index, we have you in 256,

2775
02:37:39.945 --> 02:37:43.945
called favorite number, which is
saved at two. And then at index

2776
02:37:43.945 --> 02:37:47.945
one, we have a string, which
stands for the name of Patrick,

2777
02:37:47.945 --> 02:37:50.946
whenever you have a list of
variables inside of an object in

2778
02:37:50.946 --> 02:37:54.946
solidity, they get automatically
indexed. So favorite number gets

2779
02:37:54.946 --> 02:37:58.946
indexed to zero, and name gets
indexed to one. Interestingly

2780
02:37:58.946 --> 02:38:01.947
enough, if you have a whole
bunch of variables inside your

2781
02:38:01.947 --> 02:38:05.947
contract, like we have public
favorite number, this favorite

2782
02:38:05.947 --> 02:38:09.947
number, actually, technically is
getting indexed at the zero with

2783
02:38:09.947 --> 02:38:12.948
storage slot. And if we were to
make another one of these, maybe

2784
02:38:12.948 --> 02:38:16.948
you want to get six public
brother's favorite number, this

2785
02:38:16.948 --> 02:38:19.948
would technically be indexed at
the first slot. And then if we

2786
02:38:19.948 --> 02:38:23.949
were to make one more, maybe
sister's favorite number, this

2787
02:38:23.949 --> 02:38:25.949
would be the next add the second
slot. So favorite number at

2788
02:38:25.949 --> 02:38:29.949
zero, this add one, and this a
two, but we'll learn more about

2789
02:38:29.949 --> 02:38:33.950
that much later in the course.
Similarly, favorite number is

2790
02:38:33.950 --> 02:38:37.950
index zero name is index at one.
Now what we have is great, but

2791
02:38:37.950 --> 02:38:39.951
if we want a whole lot of people
are we gonna have to keep copy

2792
02:38:39.951 --> 02:38:43.951
pasting and changing the
people's name person to their

2793
02:38:43.951 --> 02:38:48.951
favorite one, number one, number
three, will name them ally.

2794
02:38:48.951 --> 02:38:53.952
Person three, their favorite
number will be seven. Their name

2795
02:38:53.952 --> 02:38:58.952
will be Chad or something. This
obviously isn't great way to

2796
02:38:58.952 --> 02:39:00.953
create lists and large number of
people's because we have to

2797
02:39:00.953 --> 02:39:04.953
statically keep typing them in.
So a much better way to create a

2798
02:39:04.953 --> 02:39:08.953
list. And let's actually just go
ahead and delete Patrick to a

2799
02:39:08.953 --> 02:39:11.954
much better way to create a list
is to use a data structure

2800
02:39:11.954 --> 02:39:15.954
called an array. An array is a
way to store a list, or a

2801
02:39:15.954 --> 02:39:19.954
sequence of objects, creating an
array works the exact same we've

2802
02:39:19.954 --> 02:39:22.955
seen to initialize other
different types. Typically, we

2803
02:39:22.955 --> 02:39:26.955
do the type of the object, the
visibility of the object, and

2804
02:39:26.955 --> 02:39:29.955
then the variable name. We do
the exact same thing with

2805
02:39:29.955 --> 02:39:33.956
arrays. We'll say we want a
people array. These little

2806
02:39:33.956 --> 02:39:37.956
brackets represent that we want
an array of people. We'll give

2807
02:39:37.956 --> 02:39:42.957
it a visibility of public and
we'll call it people you could

2808
02:39:42.957 --> 02:39:45.957
do the same thing with you and
256 for example, you could say

2809
02:39:45.957 --> 02:39:49.957
you went to 56

2810
02:39:49.957 --> 02:39:54.958
public favorite numbers list

2811
02:39:54.958 --> 02:39:57.958
and just add this little array
key here. And now favorite

2812
02:39:57.958 --> 02:40:00.959
numbers list is going to be an
array or a list We're going to

2813
02:40:00.959 --> 02:40:03.959
comment that out for now. Now if
I were to go ahead and deploy

2814
02:40:03.959 --> 02:40:06.959
this contract, let's go ahead
delete the last one, let's

2815
02:40:06.959 --> 02:40:11.960
redeploy. We now have this blue
people button here. Remember,

2816
02:40:11.960 --> 02:40:14.960
since it's public, and it's a
variable, it automatically is

2817
02:40:14.960 --> 02:40:18.960
given a view function, it's
given one of these blue buttons.

2818
02:40:18.960 --> 02:40:22.961
And instead of just having a
single button where the value

2819
02:40:22.961 --> 02:40:25.961
shows up, it's giving us a form
to fill out, it wants to take a

2820
02:40:25.961 --> 02:40:30.962
un 256 as an input parameter. So
if I put zero, I get nothing

2821
02:40:30.962 --> 02:40:33.962
back, if I put one, I get
nothing back. No matter what you

2822
02:40:33.962 --> 02:40:36.962
put in this box, right? Now
we're gonna get nothing back.

2823
02:40:36.962 --> 02:40:40.963
This is because our people array
or our people list is currently

2824
02:40:40.963 --> 02:40:43.963
empty. And the value that it
wants is going to be the index

2825
02:40:43.963 --> 02:40:47.963
of the object that you want. So
for example, if at index zero, I

2826
02:40:47.963 --> 02:40:50.964
had Patrick, it would show
Patrick for zero, if it didn't x

2827
02:40:50.964 --> 02:40:56.964
one I had John, or actually
better yet, to Patrick.

2828
02:40:57.964 --> 02:40:59.964
Seven, John,

2829
02:40:59.964 --> 02:41:03.965
etc. This is what it would show.
But since it's empty, it's going

2830
02:41:03.965 --> 02:41:06.965
to show nothing. And let's go
ahead and remove the public

2831
02:41:06.965 --> 02:41:09.965
variable from favorite numbers
so that we don't get the

2832
02:41:09.965 --> 02:41:12.966
duplicate functions at the
moment, we'll just get the

2833
02:41:12.966 --> 02:41:14.966
Retrieve function, we'll show
you how to add to this array in

2834
02:41:14.966 --> 02:41:17.966
just a second. This type of
array is what's known as a

2835
02:41:17.966 --> 02:41:22.967
dynamic array, because the size
of the array isn't given at the

2836
02:41:22.967 --> 02:41:26.967
array initialization. If we were
to say, a people array and add a

2837
02:41:26.967 --> 02:41:29.967
three in these brackets here,
that means that this list, or

2838
02:41:29.967 --> 02:41:34.968
this array of people could only
be three people big, if we don't

2839
02:41:34.968 --> 02:41:37.968
give it a size, it means it can
be any size and the size of the

2840
02:41:37.968 --> 02:41:40.969
array can grow and shrink as we
add and subtract people, if I

2841
02:41:40.969 --> 02:41:44.969
add three, it can only have a
maximum of three in the array

2842
02:41:44.969 --> 02:41:47.969
ever, we're going to work with a
dynamic array, because we're

2843
02:41:47.969 --> 02:41:50.970
going to want to add a arbitrary
number of people to this array.

2844
02:41:50.970 --> 02:41:53.970
So let's go ahead and create a
function that's going to add

2845
02:41:53.970 --> 02:41:58.970
people who are people array, so
we're gonna say function, add

2846
02:41:58.970 --> 02:42:04.971
person. And we're going to take
string, memory, name as input

2847
02:42:04.971 --> 02:42:08.971
parameter, and I'll explain that
in a minute. And a un 256

2848
02:42:08.971 --> 02:42:13.972
underscore favorite number,
we're going to make this a

2849
02:42:13.972 --> 02:42:17.972
public function, or we're going
to do is we're going to call a

2850
02:42:17.972 --> 02:42:21.973
push function that's available
on our people object. So we're

2851
02:42:21.973 --> 02:42:25.973
gonna say people dot push, and
we're going to create a new

2852
02:42:25.973 --> 02:42:28.973
person, a new people object,
which is going to take in the

2853
02:42:28.973 --> 02:42:31.974
favorite number.

2854
02:42:31.974 --> 02:42:34.974
And the name.

2855
02:42:34.974 --> 02:42:36.974
Now, this might be a little bit
tricky to you. So let's break

2856
02:42:36.974 --> 02:42:40.975
this down. People here is
capitalized. So we know that

2857
02:42:40.975 --> 02:42:43.975
since capitalize, it's referring
to this struct people and not

2858
02:42:43.975 --> 02:42:46.975
our variable people, the
lowercase people here is

2859
02:42:46.975 --> 02:42:51.976
referring to this lowercase
array. So we're saying our array

2860
02:42:51.976 --> 02:42:55.976
dot push, or push is the
equivalent of adding basically,

2861
02:42:55.976 --> 02:42:59.976
a new people that grabs favorite
number and name. Another way

2862
02:42:59.976 --> 02:43:03.977
that we could actually do this
is we could create a variable of

2863
02:43:03.977 --> 02:43:07.977
type people and then add it like
so. So we could say people, new

2864
02:43:07.977 --> 02:43:12.978
person equals people. And then
we put those brackets the same

2865
02:43:12.978 --> 02:43:17.978
way we did before. You say
favorite number is going to be

2866
02:43:18.978 --> 02:43:22.979
this input value, this
parameter, and we could say name

2867
02:43:22.979 --> 02:43:26.979
is going to be this parameter.
Now if you hit save, you'll get

2868
02:43:26.979 --> 02:43:29.979
this error set here, saying data
location must be stored in

2869
02:43:29.979 --> 02:43:32.980
memory, or called data for
variable but no one's given. For

2870
02:43:32.980 --> 02:43:35.980
now, we're just going to add the
memory keyword here, and I'll

2871
02:43:35.980 --> 02:43:37.980
explain what it does in a little
bit. And then of course, we need

2872
02:43:37.980 --> 02:43:40.981
to add the new person into our
people dot push right here. So

2873
02:43:40.981 --> 02:43:44.981
this is how we're actually going
to push people into our people

2874
02:43:44.981 --> 02:43:47.981
array. And I'll get to this
memory keyword in a bit. Now if

2875
02:43:47.981 --> 02:43:52.982
we go back to our deploy tab, we
delete our last contract. Let's

2876
02:43:52.982 --> 02:43:56.982
deploy this new one. Right now,
if we try to look at the zero

2877
02:43:56.982 --> 02:43:59.982
with person in our people array,
we get nothing but let's go

2878
02:43:59.982 --> 02:44:03.983
ahead and add a person, we'll
call it, Patrick will be the

2879
02:44:03.983 --> 02:44:07.983
name, and seven will be the
favorite number. So we added

2880
02:44:07.983 --> 02:44:11.984
Patrick, we added seven. Now if
we look at people's zero, we

2881
02:44:11.984 --> 02:44:14.984
should see the zeroeth person
has a name of Patrick, and a

2882
02:44:14.984 --> 02:44:18.984
favorite number of seven, boom.
And that's exactly what we do

2883
02:44:18.984 --> 02:44:21.985
see, we see a favorite number of
seven, and we see a string name

2884
02:44:21.985 --> 02:44:26.985
Patrick, we tried to add John
and do his 16. We hit Add

2885
02:44:26.985 --> 02:44:29.985
Person, we can see our
transaction go through. And now

2886
02:44:29.985 --> 02:44:33.986
if we go to people at zero, it's
still Patrick with a favorite

2887
02:44:33.986 --> 02:44:37.986
number of seven. But if we look
at the people at index one, it's

2888
02:44:37.986 --> 02:44:40.987
going to be John with a favorite
number of 16. And if we look at

2889
02:44:40.987 --> 02:44:44.987
two, this, of course, should be
blank. And we do indeed see

2890
02:44:44.987 --> 02:44:47.987
nothing actually happens here.
Perfect. Now there's actually a

2891
02:44:47.987 --> 02:44:50.988
couple of different ways to
create this new person here,

2892
02:44:50.988 --> 02:44:54.988
like we showed before, we can
use this bracket notation, or

2893
02:44:54.988 --> 02:44:57.988
what we can do is we can
actually just add the parameters

2894
02:44:57.988 --> 02:45:01.989
in the order that they show. So
the first parameter for people

2895
02:45:01.989 --> 02:45:04.989
is going to be favorite number.
So we can just do favorite

2896
02:45:04.989 --> 02:45:08.989
number, comma, and the second
one is going to be name, the

2897
02:45:08.989 --> 02:45:12.990
second one is going to be name.
So if we save this, this, this

2898
02:45:12.990 --> 02:45:15.990
line we just created is the
exact same as the last line,

2899
02:45:15.990 --> 02:45:18.990
we're being a little bit less
explicit here. So the other way

2900
02:45:18.990 --> 02:45:21.991
is generally a little bit better
because it's more explicit as to

2901
02:45:21.991 --> 02:45:24.991
what variables are what or we
don't even need to save to this

2902
02:45:24.991 --> 02:45:27.991
variable here, we could take out
this whole line, replace new

2903
02:45:27.991 --> 02:45:32.992
person with exactly what we just
saw, like so now we don't even

2904
02:45:32.992 --> 02:45:37.992
need the memory keyword. Now,
you've probably seen this by

2905
02:45:37.992 --> 02:45:40.993
now. But if I go ahead and
compile, and I see a little,

2906
02:45:40.993 --> 02:45:44.993
little red one here, I roll
over. And it says something

2907
02:45:44.993 --> 02:45:48.993
about error, expected semicolon,
but got bracket, all these

2908
02:45:48.993 --> 02:45:52.994
errors mean that your code isn't
compiling. It's not working as

2909
02:45:52.994 --> 02:45:56.994
expected. So now I can go over
here and do a little semicolon

2910
02:45:56.994 --> 02:45:59.994
recompile, and I get a green.
Now if I delete this top line,

2911
02:45:59.994 --> 02:46:04.995
for example, and I compile it,
actually get a yellow thing.

2912
02:46:04.995 --> 02:46:08.995
Yellow stands for warnings, the
warning that I get is warning

2913
02:46:08.995 --> 02:46:12.996
SPX license identifier, not
provided, you should add it. So

2914
02:46:12.996 --> 02:46:15.996
let's go ahead and add that
back. recompile. And the warning

2915
02:46:15.996 --> 02:46:18.996
goes away. Warnings Don't stop
your code from compiling. So if

2916
02:46:18.996 --> 02:46:20.997
you get warnings, it's okay. But
it's usually a good idea to

2917
02:46:20.997 --> 02:46:23.997
listen to the warnings, because
often they'll give really

2918
02:46:23.997 --> 02:46:26.997
insightful information about how
to improve your smart contracts.

2919
02:46:26.997 --> 02:46:30.998
So to summarize, if it's red,
it's broken. If it's yellow, you

2920
02:46:30.998 --> 02:46:32.998
might want to check it out. But
it won't stop you from

2921
02:46:32.998 --> 02:46:39.998
continuing to code. So one thing

2922
02:46:39.998 --> 02:46:42.999
that you'll notice here is that
we have this memory keyword. And

2923
02:46:42.999 --> 02:46:44.999
you'll notice if you try to
delete it from our function

2924
02:46:44.999 --> 02:46:47.999
here, you try to compile, you
actually run into an error data

2925
02:46:47.999 --> 02:46:51.100
location must be memory or call
data for parameter and function.

2926
02:46:51.100 --> 02:46:54.100
Now there are actually six
places you can store data in

2927
02:46:54.100 --> 02:46:59.100
solidity you have the stack,
memory, storage, call data, code

2928
02:47:00.100 --> 02:47:03.100
and logs. We're not going to go
over these right now. But we are

2929
02:47:03.100 --> 02:47:06.100
going to focus on three of the
big ones, or three of the

2930
02:47:06.100 --> 02:47:10.100
important ones for this section,
which are called data, memory,

2931
02:47:10.100 --> 02:47:12.100
and storage. So for this
section, we're going to talk

2932
02:47:12.100 --> 02:47:15.100
about call data memory and
storage. And this is a little

2933
02:47:15.100 --> 02:47:18.100
bit advanced. So if you don't
totally grasp it the first time,

2934
02:47:18.100 --> 02:47:21.100
that's totally okay. Please
continue. Even if it's not

2935
02:47:21.100 --> 02:47:24.100
crystal clear what's going on
here, call data and memory mean

2936
02:47:24.100 --> 02:47:29.100
that the variable is only going
to exist temporarily. So this

2937
02:47:29.100 --> 02:47:32.100
name variable only exists
temporarily during the

2938
02:47:32.100 --> 02:47:36.100
transaction that this Add Person
function is called storage

2939
02:47:36.100 --> 02:47:41.100
variables exist, even outside of
just the function executing.

2940
02:47:41.100 --> 02:47:45.100
Even though we didn't specify it
up above, our favorite number is

2941
02:47:45.100 --> 02:47:48.100
automatically cast to be a
storage variable. Since it's not

2942
02:47:48.100 --> 02:47:52.100
explicitly defined in one of
these functions. Since we don't

2943
02:47:52.100 --> 02:47:55.100
need this name variable anymore
after this function runs, we can

2944
02:47:55.100 --> 02:48:00.100
keep it as memory, or we could
keep it as called data, you can

2945
02:48:00.100 --> 02:48:03.100
have a parameter as called data
if you don't end up modifying

2946
02:48:03.100 --> 02:48:07.100
the name. For example, we
couldn't reassign name to equal

2947
02:48:07.100 --> 02:48:11.100
cat here, if we compile we run
into an error. Type literal

2948
02:48:11.100 --> 02:48:14.100
string cat is not implicitly
convertible to expect the type

2949
02:48:14.100 --> 02:48:18.100
string called data. However, if
we have this as memory, and we

2950
02:48:18.100 --> 02:48:22.100
compile and save it, that error
goes away call data is temporary

2951
02:48:22.100 --> 02:48:25.100
variables that can't be
modified. Memory is temporary

2952
02:48:25.100 --> 02:48:29.100
variables that can be modified.
And storage is permanent

2953
02:48:29.100 --> 02:48:32.101
variables that can be modified.
Now even though I just said

2954
02:48:32.101 --> 02:48:35.101
there's actually six places
where we can access and store

2955
02:48:35.101 --> 02:48:40.101
information, we cannot say a
variable is stack code or logs,

2956
02:48:40.101 --> 02:48:43.101
we can only say memory storage
are called data, you will learn

2957
02:48:43.101 --> 02:48:46.101
why in a much later section.
Now, this is a bit of an

2958
02:48:46.101 --> 02:48:49.101
oversimplification of this. But
that's essentially what's going

2959
02:48:49.101 --> 02:48:53.101
on. The next question you might
have is, well, why do I need to

2960
02:48:53.101 --> 02:48:58.101
say memory here, but I don't
need to say memory here. Well,

2961
02:48:58.101 --> 02:49:02.101
let's go ahead and put memory
here and hit CTRL S or compile.

2962
02:49:02.101 --> 02:49:05.101
And let's see what happens we
get from solidity data location

2963
02:49:05.101 --> 02:49:08.101
can only be specified for an
array, struct or mapping types.

2964
02:49:08.101 --> 02:49:12.101
A memory was given arrays
structs and mappings are

2965
02:49:12.101 --> 02:49:15.101
considered special types and
solidity. solidity automatically

2966
02:49:15.101 --> 02:49:19.101
knows where are you in 256 is
going to be slowly knows that

2967
02:49:19.101 --> 02:49:24.101
for this function, a un 256 is
going to live just in memory.

2968
02:49:24.101 --> 02:49:27.101
However, it's not sure what a
string is going to be. Strings

2969
02:49:27.101 --> 02:49:30.101
are actually kind of
complicated. Behind the scenes,

2970
02:49:30.101 --> 02:49:34.101
a string is actually an array of
bytes. And since a string is an

2971
02:49:34.101 --> 02:49:38.101
array, we need to add this
memory bit to it because we need

2972
02:49:38.101 --> 02:49:41.101
to tell solidity, the data
location of arrays structs, or

2973
02:49:41.101 --> 02:49:45.101
mappings and a string is
secretly an array. So that's why

2974
02:49:45.101 --> 02:49:48.101
we need to tell it it's in
memory. You'll notice we can't

2975
02:49:48.101 --> 02:49:50.101
add the storage keyword here
slowly also knows that since

2976
02:49:50.101 --> 02:49:53.101
this is a function, this name
variable isn't actually getting

2977
02:49:53.101 --> 02:49:56.101
stored anywhere. So it says Hey,
you can't have that you need to

2978
02:49:56.101 --> 02:49:59.101
have it beat memory or called
data and those are the only two

2979
02:49:59.101 --> 02:50:02.101
that it accepts So this is what
we want our function to look

2980
02:50:02.101 --> 02:50:05.101
like here. So the summary of
this is struct mappings and

2981
02:50:05.101 --> 02:50:09.101
arrays need to be given this
memory or called Data keyword

2982
02:50:09.101 --> 02:50:12.102
when adding them as a parameter
to different functions. We'll

2983
02:50:12.102 --> 02:50:15.102
learn more about storage memory
and call data in later

2984
02:50:15.102 --> 02:50:19.102
sessions. Now, this list

2985
02:50:19.102 --> 02:50:22.102
is great, but what if we know
someone's name, but we don't

2986
02:50:22.102 --> 02:50:25.102
know their favorite number?
Well, what we could do is we

2987
02:50:25.102 --> 02:50:28.102
could look through the whole
array looking for that person.

2988
02:50:28.102 --> 02:50:32.102
For example, in our contract, we
can say, Okay, I'm looking for

2989
02:50:32.102 --> 02:50:36.102
John. Okay, let's start with
zero. No, okay, that's Patrick.

2990
02:50:36.102 --> 02:50:39.102
Okay, let's go to one. Okay.
That's John. Oh, great. His

2991
02:50:39.102 --> 02:50:42.102
favorite number 16? Well, this
was really easy, because we only

2992
02:50:42.102 --> 02:50:45.102
had two people. But what if we
had hundreds of people in this

2993
02:50:45.102 --> 02:50:48.102
array? Well, we'd keep have to
iterating all the way up to the

2994
02:50:48.102 --> 02:50:51.102
index that that person was in,
it's obviously really

2995
02:50:51.102 --> 02:50:54.102
inefficient. What's another way
to store this information so

2996
02:50:54.102 --> 02:50:57.102
that it's much easier and
quicker to access? Well, another

2997
02:50:57.102 --> 02:51:00.102
data structure that we can use
is something called a mapping,

2998
02:51:00.102 --> 02:51:04.102
you can think of a mapping as
sort of like a dictionary, it's

2999
02:51:04.102 --> 02:51:08.102
a set of keys, which each key
returning a certain value

3000
02:51:08.102 --> 02:51:10.102
associated with that key. And we
create a mapping variable the

3001
02:51:10.102 --> 02:51:14.102
exact same way we create all of
our other variables. This is

3002
02:51:14.102 --> 02:51:19.102
going to be a type mapping of
string

3003
02:51:19.102 --> 02:51:22.102
to you and tivity sex,

3004
02:51:22.102 --> 02:51:25.102
this is going to be our type of
visibility keyword is going to

3005
02:51:25.102 --> 02:51:32.102
be public. And we'll call it
name to favorite number. Now we

3006
02:51:32.102 --> 02:51:36.102
have a dictionary where every
single name is going to map to a

3007
02:51:36.102 --> 02:51:39.102
specific number. So let's add
some capability to our Add

3008
02:51:39.102 --> 02:51:44.102
Person function. So we are going
to add our people to our array.

3009
02:51:44.102 --> 02:51:48.102
But let's also add them to our
mapping here, what we'll do is

3010
02:51:48.102 --> 02:51:53.103
we'll say name to favorite
number. App key name is going to

3011
02:51:53.103 --> 02:51:57.103
equal to

3012
02:51:57.103 --> 02:52:03.103
favorite number. So let's go
ahead, compile this.

3013
02:52:03.103 --> 02:52:08.103
We'll go to our deploy screen,
we'll deploy this click, we have

3014
02:52:08.103 --> 02:52:13.103
a new button named a favorite
number. If I type in Patrick,

3015
02:52:13.103 --> 02:52:17.103
nothing shows up. By typing
Patrick, you'll see I get zero

3016
02:52:17.103 --> 02:52:21.103
response. By typing John, I also
get a zero response. If I type

3017
02:52:21.103 --> 02:52:25.103
in Becca, I also get a with zero
response. When you create a

3018
02:52:25.103 --> 02:52:29.103
mapping, you initialize
everything to its null value,

3019
02:52:29.103 --> 02:52:32.103
every single possible string on
the planet right now is

3020
02:52:32.103 --> 02:52:35.103
initialized to having a favorite
number of zero. So if we want to

3021
02:52:35.103 --> 02:52:38.103
change that, we'll have to go in
and manually add that. So let's

3022
02:52:38.103 --> 02:52:43.103
go ahead and add a person to our
mapping here. So we'll add

3023
02:52:43.103 --> 02:52:47.103
Patrick. And we'll say my
favorite number is seven. And

3024
02:52:47.103 --> 02:52:51.103
looks like that transaction did
go through also add, Becca, and

3025
02:52:51.103 --> 02:52:56.103
we'll say her favorite number is
13. Let John and we'll say his

3026
02:52:56.103 --> 02:53:01.103
favorite number is 16. Now, if I
look up, Patrick, I'll

3027
02:53:01.103 --> 02:53:04.103
immediately get back what
Patrick's favorite number is, I

3028
02:53:04.103 --> 02:53:08.103
get seven back. If we look up,
John, we immediately get back

3029
02:53:08.103 --> 02:53:12.103
16. Back up, we may only get
back 13. And we also can see

3030
02:53:12.103 --> 02:53:16.103
them in our array. Because we
kept in this people that push

3031
02:53:16.103 --> 02:53:22.103
bit zero, we see Patrick's
there. At one, we see Becca. And

3032
02:53:22.103 --> 02:53:26.103
at two, we see John, in our
mapping, we're saying the string

3033
02:53:26.103 --> 02:53:31.104
name is being mapped to the UN
256 favorite number. And a lot

3034
02:53:31.104 --> 02:53:34.104
of my variables, I like to make
them explicitly named like that.

3035
02:53:34.104 --> 02:53:35.104
So this is name to

3036
02:53:35.104 --> 02:53:39.104
favorite number. So

3037
02:53:39.104 --> 02:53:43.104
now we're in a space where let's
say that we really like our

3038
02:53:43.104 --> 02:53:46.104
simple storage contract. Right
now we have a favorite number, a

3039
02:53:46.104 --> 02:53:51.104
global variable that we can save
a favorite number to with our

3040
02:53:51.104 --> 02:53:56.104
store function, we have a
mapping of name to favorite

3041
02:53:56.104 --> 02:54:00.104
numbers, and we have an array of
a new type that we created

3042
02:54:00.104 --> 02:54:04.104
called people, we can add to
both the array and to the

3043
02:54:04.104 --> 02:54:08.104
mapping. Using this Add Person
function that we've created,

3044
02:54:08.104 --> 02:54:11.104
we're able to save multiple
people's favorite numbers as

3045
02:54:11.104 --> 02:54:14.104
well as kind of a global
favorite number as well. Let's

3046
02:54:14.104 --> 02:54:17.104
say we really love this
contract, and we're ready to

3047
02:54:17.104 --> 02:54:20.104
send it to a test net to have
other people interact with it.

3048
02:54:20.104 --> 02:54:23.104
Now in future sections, you'll
hear me say that you shouldn't

3049
02:54:23.104 --> 02:54:26.104
do this until you write tests
until you do some really simple

3050
02:54:26.104 --> 02:54:29.104
auditing. But for now, let's go
ahead and learn how to actually

3051
02:54:29.104 --> 02:54:34.104
deploy this to a test net or to
a real network. Now remember,

3052
02:54:34.104 --> 02:54:36.104
test nets are run out of the
goodness of people's hearts. So

3053
02:54:36.104 --> 02:54:39.104
if it's a little bit funky, or
maybe doesn't work exactly as we

3054
02:54:39.104 --> 02:54:43.104
show here, that's okay. As long
as it works with the JavaScript

3055
02:54:43.104 --> 02:54:46.104
VM, you'll be all set but it is
good practice to learn how to

3056
02:54:46.104 --> 02:54:50.104
deploy these to a real test net.
Let's go ahead and do that. Our

3057
02:54:50.104 --> 02:54:54.104
contract is here. Simple Storage
dot soul. It's compiled,

3058
02:54:54.104 --> 02:54:57.104
compiling is passing we get this
little green checkmark here we

3059
02:54:57.104 --> 02:55:00.104
go to the deploy section. Let's
go ahead and do Get this. And

3060
02:55:00.104 --> 02:55:03.104
now we're going to change the
environment. So we were working

3061
02:55:03.104 --> 02:55:07.104
with a JavaScript VM or kind of
this fake simulated environment,

3062
02:55:07.104 --> 02:55:11.105
we want to now move to either
injected web three, or web three

3063
02:55:11.105 --> 02:55:14.105
provider. If you hover over
injected web three, there's this

3064
02:55:14.105 --> 02:55:18.105
really, really small text here.
But this basically means we're

3065
02:55:18.105 --> 02:55:22.105
going to inject our meta mask or
our web three wallet into our

3066
02:55:22.105 --> 02:55:25.105
browser to use similar to what
we did with the faucet, we'll

3067
02:55:25.105 --> 02:55:29.105
pick our account we want to use.
So I'm gonna go ahead and pick

3068
02:55:29.105 --> 02:55:34.105
account one. And now we actually
see our account in the Account

3069
02:55:34.105 --> 02:55:38.105
section of remix, injected web
three means we're using our meta

3070
02:55:38.105 --> 02:55:42.105
mask or whatever web three
wallet, web three provider is,

3071
02:55:42.105 --> 02:55:45.105
when we a little bit more
manually choose an endpoint. And

3072
02:55:45.105 --> 02:55:48.105
we're not going to go over this
right now. But as we get later

3073
02:55:48.105 --> 02:55:50.105
into the course, you'll
understand what this means. So

3074
02:55:50.105 --> 02:55:53.105
we're picking injected web
three, whatever network are

3075
02:55:53.105 --> 02:55:57.105
injected web three, or in this
case, our wallet is connected to

3076
02:55:57.105 --> 02:56:00.105
is going to be the network that
we deploy to. So for this

3077
02:56:00.105 --> 02:56:03.105
section, we're going to be
deploying to Rinkeby. But again,

3078
02:56:03.105 --> 02:56:05.105
depending on whatever the
recommended test net and the

3079
02:56:05.105 --> 02:56:09.105
recommended faucet is, that will
dictate which test net you

3080
02:56:09.105 --> 02:56:12.105
should actually deploy to. For
us, it's going to be Rigby. To

3081
02:56:12.105 --> 02:56:15.105
deploy to a test that remember,
we're going to need gas, so

3082
02:56:15.105 --> 02:56:18.105
we're going to need some tested
Etherium. Or if you're deploying

3083
02:56:18.105 --> 02:56:21.105
to a main net main Aetherium,
which you shouldn't be come to

3084
02:56:21.105 --> 02:56:23.105
the top of the GitHub repo to
make sure you have the most

3085
02:56:23.105 --> 02:56:27.105
updated faucet, the other place
you can go is link token

3086
02:56:27.105 --> 02:56:31.105
contracts page in the chain link
documentation and scroll down

3087
02:56:31.105 --> 02:56:35.105
the ranking. And you can see
test that link available here,

3088
02:56:35.105 --> 02:56:38.105
test that eath available here.
So this is the other location,

3089
02:56:38.105 --> 02:56:41.105
you can always look to find the
most up to date faucets, and

3090
02:56:41.105 --> 02:56:45.105
both of them point right back
here. So now that we're working

3091
02:56:45.105 --> 02:56:47.105
with injected web three, we can
just go through the exact same

3092
02:56:47.105 --> 02:56:53.106
steps to deploy to a test net as
to deploy to a virtual machine.

3093
02:56:53.106 --> 02:56:56.106
And remember, if you run out of
gas to deploy this, be sure to

3094
02:56:56.106 --> 02:56:58.106
check back to the faucets to
actually deploy this. So we're

3095
02:56:58.106 --> 02:57:00.106
going to do the same thing,
we're gonna go ahead and hit

3096
02:57:00.106 --> 02:57:05.106
Deploy. But this time Metamask
is going to pop up and ask us if

3097
02:57:05.106 --> 02:57:09.106
we want to actually deploy this,
this is the exact same as what

3098
02:57:09.106 --> 02:57:13.106
we saw with the blockchain
example, where we sign

3099
02:57:13.106 --> 02:57:17.106
transactions, we are signing and
sending this transaction, the

3100
02:57:17.106 --> 02:57:21.106
data of this transaction is this
massive, massive data thing

3101
02:57:21.106 --> 02:57:24.106
here, which represents the
contract that we just created,

3102
02:57:24.106 --> 02:57:28.106
we can see all the payment
information for this transaction

3103
02:57:28.106 --> 02:57:32.106
for deploying this contract, we
see it's going to cost around

3104
02:57:32.106 --> 02:57:36.106
this much Aetherium to deploy.
But again, we're on the Rinkeby

3105
02:57:36.106 --> 02:57:38.106
test network. So this is going
to be fake Aetherium. We're

3106
02:57:38.106 --> 02:57:43.106
gonna go ahead, hit Confirm. And
if you pop up a little console,

3107
02:57:43.106 --> 02:57:48.106
and remix, you'll see that after
a slight delay, it'll actually

3108
02:57:48.106 --> 02:57:51.106
say have this green checkmark
that it's confirmed that it went

3109
02:57:51.106 --> 02:57:55.106
actually went through, we can go
ahead right click, open a new

3110
02:57:55.106 --> 02:58:00.106
tab, and view this on ether
scan. And after a slight delay,

3111
02:58:00.106 --> 02:58:03.106
we'll actually be able to see
the transaction details here,

3112
02:58:03.106 --> 02:58:06.106
exactly the same as our
transaction details for sending

3113
02:58:06.106 --> 02:58:10.106
Aetherium we have a hash, we
have a status, we have blocked

3114
02:58:10.106 --> 02:58:13.106
block confirmations, we have
timestamp from which is going to

3115
02:58:13.106 --> 02:58:16.106
be us two, which is going to be
the average of the contract that

3116
02:58:16.106 --> 02:58:20.106
we just created. We didn't send
any value with this. So this is

3117
02:58:20.106 --> 02:58:22.106
going to be zero ether. And then
of course, we see the

3118
02:58:22.106 --> 02:58:26.106
transaction fee, and as well as
the gas price. Because again,

3119
02:58:26.106 --> 02:58:29.106
deploying a contract to the
blockchain is modifying the

3120
02:58:29.106 --> 02:58:32.107
state of the blockchain. So we
have to pay gas, and we can see

3121
02:58:32.107 --> 02:58:36.107
all the different pieces here.
As we can see, gas limit and gas

3122
02:58:36.107 --> 02:58:39.107
usage is much higher than just
sending Aetherium, since we are

3123
02:58:39.107 --> 02:58:44.107
putting a lot of data on chain
and adding a lot of computation.

3124
02:58:44.107 --> 02:58:48.107
So this number is much higher
than the 21,000 number of just

3125
02:58:48.107 --> 02:58:51.107
sending Aetherium. Now, if we
come back to our remix and

3126
02:58:51.107 --> 02:58:55.107
scroll down, we're able to see
our simple storage contract at

3127
02:58:55.107 --> 02:58:59.107
this address. If we hit this
copy button, and we go to the

3128
02:58:59.107 --> 02:59:03.107
rink be ether scan, we paste it
in the search bar, we will get

3129
02:59:03.107 --> 02:59:06.107
the contract that we just
deployed. And we see this first

3130
02:59:06.107 --> 02:59:10.107
transaction is going to be the
contract creation transaction.

3131
02:59:10.107 --> 02:59:14.107
So this contract that we just
created one transaction, which

3132
02:59:14.107 --> 02:59:17.107
is contract created. So now that
we have this contract created,

3133
02:59:17.107 --> 02:59:19.107
we have all the exact same
functions that we saw when

3134
02:59:19.107 --> 02:59:22.107
working with the JavaScript
virtual machine, or the our fake

3135
02:59:22.107 --> 02:59:25.107
environment, or our super fake
environment. Now we can do all

3136
02:59:25.107 --> 02:59:28.107
the exact same things that we
did with the JavaScript VM, but

3137
02:59:28.107 --> 02:59:32.107
on a real test network. So
you'll see if I hit retrieve

3138
02:59:32.107 --> 02:59:36.107
Metamask doesn't pop up. Because
again, this is a blue view

3139
02:59:36.107 --> 02:59:39.107
function. If we look people at
zero, this is also a view

3140
02:59:39.107 --> 02:59:42.107
function and nothing pops up,
named a favorite number should

3141
02:59:42.107 --> 02:59:45.107
be blank. So if I type in
Patrick now, absolutely nothing

3142
02:59:45.107 --> 02:59:49.107
happens, right? I get I get zero
returned because mappings

3143
02:59:49.107 --> 02:59:53.107
initialize every single key with
a blank or a null value, which

3144
02:59:53.107 --> 02:59:58.107
for you 256 is zero. Now, we can
go ahead and store a favorite

3145
02:59:58.107 --> 03:00:01.107
number store When your favorite
number is going to modify the

3146
03:00:01.107 --> 03:00:06.107
blockchain, so our meta mask
should pop up for us to confirm

3147
03:00:06.107 --> 03:00:10.107
the transaction and sign that
transaction to modify the

3148
03:00:10.107 --> 03:00:13.108
blockchain state. So I'm going
to store my favorite number of

3149
03:00:13.108 --> 03:00:18.108
16, we'll hit store, meta mask
will pop up, and we're going to

3150
03:00:18.108 --> 03:00:21.108
go ahead and actually confirm
this didn't confirm is

3151
03:00:21.108 --> 03:00:24.108
equivalent to US signing this
transaction and sending it to

3152
03:00:24.108 --> 03:00:27.108
the blockchain to modify the
state. So we're gonna go ahead

3153
03:00:27.108 --> 03:00:31.108
and confirm this, we should be
able to view this on ether scan.

3154
03:00:31.108 --> 03:00:34.108
And again, it might take a
little bit for it to actually

3155
03:00:34.108 --> 03:00:37.108
index or actually start working.
So please be patient with these

3156
03:00:37.108 --> 03:00:40.108
test nets. And again, this is
why when building your

3157
03:00:40.108 --> 03:00:43.108
applications, you want the test
net piece to absolutely try to

3158
03:00:43.108 --> 03:00:47.108
be your last step, because you
have to wait a really long time.

3159
03:00:47.108 --> 03:00:50.108
And it puts a burden on these
people running these tests into

3160
03:00:50.108 --> 03:00:52.108
running it out of the goodness
of their heart. So please try to

3161
03:00:52.108 --> 03:00:56.108
make this the last step of your
actual building process. For us

3162
03:00:56.108 --> 03:01:00.108
learning right here, it's okay.
And after a slight delay, once

3163
03:01:00.108 --> 03:01:03.108
we hit refresh, it looks like
it's indexing on ether scan, the

3164
03:01:03.108 --> 03:01:05.108
ether scan website is still
figuring out where the

3165
03:01:05.108 --> 03:01:08.108
transaction is going to remix,
it looks like on the blockchain,

3166
03:01:08.108 --> 03:01:10.108
this has actually already gone
through. So now if we hit

3167
03:01:10.108 --> 03:01:14.108
retrieve, we do indeed see, our
favorite number is 16. Of

3168
03:01:14.108 --> 03:01:17.108
course, these two are still
going to be blank. And it looks

3169
03:01:17.108 --> 03:01:20.108
like that transaction has gone
through and ether scan has

3170
03:01:20.108 --> 03:01:23.108
indexed. So now let's go ahead
and add a person will add

3171
03:01:23.108 --> 03:01:27.108
Patrick, and my favorite number
is going to be 16. We'll go

3172
03:01:27.108 --> 03:01:30.108
ahead and add person. Again,
since these are orange

3173
03:01:30.108 --> 03:01:32.108
transactions gonna pop up
because we're modifying the

3174
03:01:33.108 --> 03:01:36.108
blockchain state, we'll go ahead
and hit Confirm. And we're going

3175
03:01:36.108 --> 03:01:39.108
to be a little bit patient here
and wait for this transaction to

3176
03:01:39.108 --> 03:01:43.108
go through. And we should see
this update. And this update.

3177
03:01:43.108 --> 03:01:47.108
Now if I hit named a favorite
number of Patrick, I get 16. And

3178
03:01:47.108 --> 03:01:50.108
if I hit people of zero, I get
favorite number 16. And the name

3179
03:01:50.108 --> 03:01:54.109
is Patrick. Awesome. So you've
actually successfully deployed a

3180
03:01:54.109 --> 03:01:58.109
contract to an actual test net,
and actually seen on ether scan

3181
03:01:58.109 --> 03:02:00.109
what these transactions look
like, you should be incredibly

3182
03:02:00.109 --> 03:02:03.109
proud of yourself, be sure to
give yourself a high five pat on

3183
03:02:03.109 --> 03:02:07.109
the back, send a tweet saying
exactly how excited you are. But

3184
03:02:07.109 --> 03:02:09.109
make sure to celebrate these
little wins, celebrating these

3185
03:02:09.109 --> 03:02:12.109
little wins will give you the
motivation to keep going and

3186
03:02:12.109 --> 03:02:16.109
really excite you for learning
each new thing. So huge.

3187
03:02:16.109 --> 03:02:19.109
Congratulations. If you got this
far, you've deployed your first

3188
03:02:19.109 --> 03:02:22.109
contract to a test net,
congratulations. Now if you want

3189
03:02:22.109 --> 03:02:24.109
to see what it looks like to
deploy to a different network,

3190
03:02:24.109 --> 03:02:28.109
all you need to do in your
Metamask is switch to a

3191
03:02:28.109 --> 03:02:32.109
different test net. See, if we
switch to COVID remix

3192
03:02:32.109 --> 03:02:35.109
automatically updates and says,
ah, injected web three is now

3193
03:02:35.109 --> 03:02:39.109
the COVID test network. We could
switch again maybe to Grilley,

3194
03:02:39.109 --> 03:02:42.109
we say Ah, the injected web
three is now at the Grilley.

3195
03:02:42.109 --> 03:02:45.109
This is the test net that we'd
be deploying to of course, we

3196
03:02:45.109 --> 03:02:48.109
need actual test net Aetherium
to do any deploying, so we

3197
03:02:48.109 --> 03:02:51.109
wouldn't be able to here. And if
we go ahead and hit Deploy right

3198
03:02:51.109 --> 03:02:55.109
now Metamask pops up. But we get
this little red thing saying

3199
03:02:55.109 --> 03:02:59.109
insufficient funds. Of course,
later on, we'll learn how to add

3200
03:02:59.109 --> 03:03:03.109
new networks like polygon like
avalanche like phantom into our

3201
03:03:03.109 --> 03:03:05.109
Metamask. So we can deploy from
any one of them

3202
03:03:05.109 --> 03:03:08.109
as well.

3203
03:03:08.109 --> 03:03:11.109
Now, I mentioned this term
before, but all this code that

3204
03:03:11.109 --> 03:03:14.109
we wrote, when we hit this
compile button, it compiles it

3205
03:03:14.109 --> 03:03:20.109
down to the EVM or the Ethereum
virtual machine. Don't worry too

3206
03:03:20.109 --> 03:03:24.109
much about what this means. EVM
is a standard of how to deploy

3207
03:03:24.109 --> 03:03:28.109
smart contracts to Aetherium
like blockchains. And any

3208
03:03:28.109 --> 03:03:32.110
blockchain that implements a
type of EVM. You can deploy

3209
03:03:32.110 --> 03:03:36.110
solidity code to some examples
of EVM compatible blockchains

3210
03:03:36.110 --> 03:03:41.110
are going to be avalanche,
Phantom, and polygon. Since

3211
03:03:41.110 --> 03:03:44.110
these are EVM compatible, this
means we can write our solidity

3212
03:03:44.110 --> 03:03:47.110
code, and deploy to these
blockchains, which again, I'll

3213
03:03:48.110 --> 03:03:50.110
show you later on how to add
these new networks into your

3214
03:03:50.110 --> 03:03:53.110
Metamask. And then how to deploy
them. Let's do a quick recap of

3215
03:03:53.110 --> 03:03:56.110
our first smart contract. And
then you should actually take a

3216
03:03:56.110 --> 03:04:00.110
break, maybe get some ice cream
or coffee because you absolutely

3217
03:04:00.110 --> 03:04:02.110
deserve it. Congratulations. The
first thing you always need to

3218
03:04:02.110 --> 03:04:06.110
do in your smart contracts is
tell solidity, what version of

3219
03:04:06.110 --> 03:04:09.110
solidity that you're going to be
using. And additionally, you

3220
03:04:09.110 --> 03:04:13.110
want to add an spdx license
identifier, then you have to

3221
03:04:13.110 --> 03:04:16.110
create your contract object and
name your contract. The contract

3222
03:04:16.110 --> 03:04:19.110
in solidity is similar to a
class in other programming

3223
03:04:19.110 --> 03:04:23.110
languages, and everything inside
the squiggly brackets is a part

3224
03:04:23.110 --> 03:04:26.110
of that contract. There are many
different types in solidity like

3225
03:04:26.110 --> 03:04:32.110
unsigned integer, 256, Boolean
string, bytes, 32, etc. If we

3226
03:04:32.110 --> 03:04:35.110
want to create a new type, we
can create what's called a

3227
03:04:35.110 --> 03:04:38.110
struct in solidity. You can
create arrays or lists in

3228
03:04:38.110 --> 03:04:41.110
solidity, you can create
dictionaries, or what's called

3229
03:04:42.110 --> 03:04:45.110
mappings in solidity or hash
tables, which when you give it a

3230
03:04:45.110 --> 03:04:49.110
key, it'll spit out the value
that that key represents. We can

3231
03:04:49.110 --> 03:04:52.110
create functions in solidity
that modify the state of the

3232
03:04:52.110 --> 03:04:55.110
blockchain. We can also create
functions in solidity that don't

3233
03:04:55.110 --> 03:04:58.110
modify the state of the
blockchain view in pure

3234
03:04:58.110 --> 03:05:01.110
functions, don't modify by the
state of a blockchain, we also

3235
03:05:01.110 --> 03:05:05.110
can specify different data
locations in our functions,

3236
03:05:05.110 --> 03:05:09.110
called data and memory mean that
that data is only temporary and

3237
03:05:09.110 --> 03:05:12.111
will only exist for the duration
of the function. Storage

3238
03:05:12.111 --> 03:05:15.111
variables are permanent and stay
there forever. function

3239
03:05:15.111 --> 03:05:17.111
parameters can't be stored
variables because they're only

3240
03:05:17.111 --> 03:05:20.111
going to exist for the duration
of the function. All the

3241
03:05:20.111 --> 03:05:23.111
solidity code that we work with,
when we hit Compile, it actually

3242
03:05:23.111 --> 03:05:28.111
compiles down to this Aetherium
virtual machine specifications.

3243
03:05:28.111 --> 03:05:30.111
We'll learn more about those
specifications later. And last,

3244
03:05:30.111 --> 03:05:33.111
but not least, another huge
congratulations on your first

3245
03:05:33.111 --> 03:05:37.111
contract here.

3246
03:05:37.111 --> 03:05:37.111
Awesome.

3247
03:05:37.111 --> 03:05:41.111
All right, let's get started on
our lesson three, remember,

3248
03:05:41.111 --> 03:05:43.111
everything is in the GitHub
repository. And we can scroll

3249
03:05:43.111 --> 03:05:47.111
down, hit Lesson three and see
all the code here. I'm building

3250
03:05:47.111 --> 03:05:50.111
up this repo as I film. So
underneath this lesson three is

3251
03:05:50.111 --> 03:05:52.111
going to be a lot more
information than just the code

3252
03:05:52.111 --> 03:05:57.111
here, all of our code samples
end with dash f f, c, which

3253
03:05:57.111 --> 03:06:00.111
means dash Free Code Camp. So if
you see a GitHub repo that ends

3254
03:06:00.111 --> 03:06:05.111
with dash F, F, C, know that
that repository is associated

3255
03:06:05.111 --> 03:06:07.111
with this course, I'm going to
do a quick high level

3256
03:06:07.111 --> 03:06:10.111
walkthrough of what we're going
to be building in this lesson.

3257
03:06:10.111 --> 03:06:14.111
So you don't need to code right
now just sit back watch and

3258
03:06:14.111 --> 03:06:16.111
enjoy. In this lesson, we're
actually going to expand to

3259
03:06:16.111 --> 03:06:19.111
having three different
contracts. Let's say we want to

3260
03:06:19.111 --> 03:06:23.111
be able to deploy simple storage
contracts from a contract

3261
03:06:23.111 --> 03:06:28.111
itself. Yes, contracts can
indeed deploy contracts, we are

3262
03:06:28.111 --> 03:06:31.111
going to create a contract
called storage factory dot sole,

3263
03:06:31.111 --> 03:06:34.111
that's going to be able to
deploy and interact with other

3264
03:06:34.111 --> 03:06:38.111
contracts itself. So what we
could do is we could go deploy

3265
03:06:38.111 --> 03:06:41.111
this to a JavaScript VM, we're
going to choose storage factory,

3266
03:06:42.111 --> 03:06:45.111
and we're gonna go ahead and hit
Deploy. In our contract down

3267
03:06:45.111 --> 03:06:48.111
below, we have a number of
different functions. Our top

3268
03:06:48.111 --> 03:06:52.112
function is this function called
crate simple storage contract,

3269
03:06:52.112 --> 03:06:56.112
which we can click and it'll
actually create a simple storage

3270
03:06:56.112 --> 03:06:59.112
contract for us, then we can go
ahead and interact with it at an

3271
03:06:59.112 --> 03:07:04.112
IG zero will save a favorite
number of one. Now, if we hit SF

3272
03:07:04.112 --> 03:07:06.112
get zero,

3273
03:07:06.112 --> 03:07:09.112
we get one back. And

3274
03:07:09.112 --> 03:07:12.112
we can see the address of the
simple storage contract that we

3275
03:07:12.112 --> 03:07:14.112
just deployed. Additionally,
we're going to learn about a

3276
03:07:14.112 --> 03:07:18.112
number of solidity features,
such as importing inheritance,

3277
03:07:18.112 --> 03:07:22.112
and so much more. So let's go
ahead and jump in. And remember

3278
03:07:22.112 --> 03:07:25.112
all the code is available here
from the GitHub repository. So

3279
03:07:25.112 --> 03:07:31.112
be sure to refer back to these
contracts if you get lost.

3280
03:07:31.112 --> 03:07:32.112
So here we are

3281
03:07:32.112 --> 03:07:35.112
back in remix, and we have our
simple storage dot soul. If you

3282
03:07:35.112 --> 03:07:38.112
skipped over the last section,
be sure to go to the full

3283
03:07:38.112 --> 03:07:42.112
blockchain solidity course, Jas.
And scroll down to lesson two,

3284
03:07:42.112 --> 03:07:46.112
welcome to remix and grab this
code. Go to simple storage

3285
03:07:46.112 --> 03:07:50.112
outsole. And copy paste this
code into remix. Because this is

3286
03:07:50.112 --> 03:07:53.112
where we're going to be starting
from, we have this simple

3287
03:07:53.112 --> 03:07:56.112
storage contract, which is
great. It allows us to store a

3288
03:07:56.112 --> 03:07:59.112
favorite number. And it allows
us to store favorite numbers

3289
03:07:59.112 --> 03:08:02.112
across different people in both
mappings and arrays. But let's

3290
03:08:02.112 --> 03:08:05.112
say we want to get even more
advanced with this, we actually

3291
03:08:05.112 --> 03:08:10.112
can have a contract actually
deploy other contracts for us.

3292
03:08:10.112 --> 03:08:13.112
And then go ahead and interact
with those contracts from other

3293
03:08:13.112 --> 03:08:17.112
contracts, contracts interacting
with each other is an essential

3294
03:08:17.112 --> 03:08:19.112
part of working with solidity
and working with smart

3295
03:08:19.112 --> 03:08:23.112
contracts. The ability for
contracts to seamlessly interact

3296
03:08:23.112 --> 03:08:26.112
with each other is what's known
as composability. smart

3297
03:08:26.112 --> 03:08:28.112
contracts are composable,
because they can easily interact

3298
03:08:28.112 --> 03:08:31.113
with each other. This is
especially awesome when it comes

3299
03:08:31.113 --> 03:08:34.113
to things like defy where you
can have really complex

3300
03:08:34.113 --> 03:08:38.113
financial products interact with
each other incredibly easily,

3301
03:08:38.113 --> 03:08:41.113
since all their code is
available on chain. So we're

3302
03:08:41.113 --> 03:08:43.113
going to learn how to do that.
So let's keep our simple storage

3303
03:08:43.113 --> 03:08:46.113
contract exactly the way it is,
we're going to create a new

3304
03:08:46.113 --> 03:08:49.113
contract called storage factory.
So we're going to hit the New

3305
03:08:49.113 --> 03:08:56.113
File button and type in storage,
factory dot salt. And let's

3306
03:08:56.113 --> 03:08:59.113
close this off for now. So let's
go ahead and get this contract

3307
03:08:59.113 --> 03:09:01.113
setup from what we learned
before. First thing we're going

3308
03:09:01.113 --> 03:09:08.113
to want to do is the spdx
license identifier, which we're

3309
03:09:08.113 --> 03:09:11.113
going to do MIT. And then the
next thing we're always going to

3310
03:09:11.113 --> 03:09:13.113
need is our solidity version.

3311
03:09:13.113 --> 03:09:17.113
So we'll do pragma solidity

3312
03:09:17.113 --> 03:09:21.113
and we could do zero point 8.7.
But for this one, let's do zero

3313
03:09:21.113 --> 03:09:25.113
point 8.0 And then just add the
carrot, meaning any version of

3314
03:09:25.113 --> 03:09:28.113
0.8 point something will work.
And then let's add our contract

3315
03:09:28.113 --> 03:09:33.113
name, which is going to be
storage factory. Now hit command

3316
03:09:33.113 --> 03:09:37.113
S or ctrl S or go to the compile
tab and hit compile, and boom,

3317
03:09:37.113 --> 03:09:41.113
we have our regular setup here.
Now we want to create a function

3318
03:09:41.113 --> 03:09:44.113
that can actually deploy our
simple storage contract. So

3319
03:09:44.113 --> 03:09:49.113
we'll create a function called
function. create simple storage

3320
03:09:49.113 --> 03:09:53.113
contract, we'll have it be
public, so anybody can call it

3321
03:09:53.113 --> 03:09:57.113
will have to deploy a simple
storage contract and save it to

3322
03:09:57.113 --> 03:10:00.113
a global variable. But before we
can do it How can our storage

3323
03:10:00.113 --> 03:10:04.113
factory contract know what our
simple storage contract looks

3324
03:10:04.113 --> 03:10:08.113
like? In order to deploy it, if
our storage factory contract is

3325
03:10:08.113 --> 03:10:11.114
going to deploy simple storage,
it's going to need to know code

3326
03:10:11.114 --> 03:10:14.114
of simple storage. One way we
can do this is we can actually

3327
03:10:14.114 --> 03:10:18.114
go to our simple storage dot
soul and copy everything

3328
03:10:18.114 --> 03:10:23.114
underneath pragma, solidity and
down and paste it into our

3329
03:10:23.114 --> 03:10:27.114
storage factory dot soul
underneath our pragma, solidity.

3330
03:10:27.114 --> 03:10:30.114
If we go ahead and compile and
save this, it actually works our

3331
03:10:30.114 --> 03:10:33.114
storage factory, that soul
contract actually now has two

3332
03:10:33.114 --> 03:10:36.114
contracts in it. It has the
simple storage contract, and it

3333
03:10:36.114 --> 03:10:39.114
has the storage factory contract
in it, you actually go to the

3334
03:10:39.114 --> 03:10:43.114
deploy tab and scroll down to
deploy while you're on the

3335
03:10:43.114 --> 03:10:46.114
storage factory dot soul, not
the simple storage that's all on

3336
03:10:46.114 --> 03:10:49.114
storage factory, you can see
that you can actually choose

3337
03:10:49.114 --> 03:10:52.114
which one of these contracts to
deploy, a single file of

3338
03:10:52.114 --> 03:10:56.114
solidity can hold multiple
different contracts. Now that we

3339
03:10:56.114 --> 03:10:59.114
have our simple storage, that's
all in our storage factory, we

3340
03:10:59.114 --> 03:11:02.114
can actually go ahead and create
this function to deploy a simple

3341
03:11:02.114 --> 03:11:05.114
storage console, we're going to
create a global variable the

3342
03:11:05.114 --> 03:11:07.114
same way that we would create
any other global variable, we'll

3343
03:11:07.114 --> 03:11:12.114
do the type, which is going to
be type simple storage contract,

3344
03:11:12.114 --> 03:11:17.114
we'll give it a visibility of
public. And we'll give it a

3345
03:11:17.114 --> 03:11:20.114
variable name. Type simple
storage contract going to be

3346
03:11:20.114 --> 03:11:24.114
public, the name of the variable
is going to be simple storage.

3347
03:11:24.114 --> 03:11:26.114
Now in our function, create
simple storage contract, we're

3348
03:11:26.114 --> 03:11:29.114
gonna say simple storage equals

3349
03:11:29.114 --> 03:11:34.114
new, simple storage.

3350
03:11:34.114 --> 03:11:37.114
This new keyword is how solidity
knows Ah, okay, we're going to

3351
03:11:37.114 --> 03:11:41.114
deploy a new simple storage
contract. So we go ahead and

3352
03:11:41.114 --> 03:11:44.114
compile this, we'll go to the
deploy tab, make sure we're on

3353
03:11:44.114 --> 03:11:48.114
the JavaScript VM, we'll scroll
down to the contract. And we'll

3354
03:11:48.114 --> 03:11:51.115
choose storage factory. And
remember, you need to have

3355
03:11:51.115 --> 03:11:54.115
storage factory dot soul
selected. In order for that to

3356
03:11:54.115 --> 03:12:00.115
show up storage factory, we'll
go ahead and hit Deploy. And now

3357
03:12:00.115 --> 03:12:04.115
we see our storage factory
contract has two buttons. One is

3358
03:12:04.115 --> 03:12:07.115
create simple storage, and the
other one is going to be a view

3359
03:12:07.115 --> 03:12:11.115
of our simple storage contract.
If we click it right now, it's

3360
03:12:11.115 --> 03:12:13.115
going to show us that it's
currently at address zero,

3361
03:12:13.115 --> 03:12:16.115
because it gets initialized to
being blank. It's saying there

3362
03:12:16.115 --> 03:12:19.115
is no simple storage contract
currently deployed. Now if we

3363
03:12:19.115 --> 03:12:23.115
pull up our console and click
create simple storage, we see we

3364
03:12:23.115 --> 03:12:27.115
created a new function call
storage factory dot create

3365
03:12:27.115 --> 03:12:30.115
simple storage contract. And in
doing so we called this function

3366
03:12:30.115 --> 03:12:34.115
which created and deployed a new
simple storage contract, we can

3367
03:12:34.115 --> 03:12:36.115
now see what address the simple
storage contract is out by

3368
03:12:36.115 --> 03:12:39.115
clicking the simple storage
button and we see the address

3369
03:12:39.115 --> 03:12:42.115
associated with it. So now we
know how a contract can actually

3370
03:12:42.115 --> 03:12:46.115
deploy another contract. But the
thing is, having this massive

3371
03:12:46.115 --> 03:12:49.115
chunk of code above our storage
factory is a little bit

3372
03:12:49.115 --> 03:12:52.115
redundant, especially since we
have our other file called

3373
03:12:52.115 --> 03:12:56.115
Simple Storage dot soul. And
let's say we have a contract

3374
03:12:56.115 --> 03:12:59.115
that has got a ton of other
contracts in it. Always copy

3375
03:12:59.115 --> 03:13:02.115
pasting all these contracts is
going to be a lot of work. So

3376
03:13:02.115 --> 03:13:06.115
instead, what we can do is use
what's called an import. So

3377
03:13:06.115 --> 03:13:09.115
let's go ahead and delete our
contracts simple storage. And

3378
03:13:09.115 --> 03:13:15.115
now we're just going to type
import dot slash simple storage

3379
03:13:15.115 --> 03:13:19.115
dot soul. This import dot slash
simple storage dot Seoul is the

3380
03:13:19.115 --> 03:13:22.115
exact same as our copy pasted
version of simple storage.

3381
03:13:22.115 --> 03:13:27.115
That's all. It takes the path of
another file, it takes the path

3382
03:13:27.115 --> 03:13:29.115
package or GitHub, which we'll
get to in a minute of another

3383
03:13:29.115 --> 03:13:34.116
file and says, Okay, we're going
to paste that contract into the

3384
03:13:34.116 --> 03:13:37.116
top of this contract here, we
actually see we go back to

3385
03:13:37.116 --> 03:13:42.116
compile, we go to deploy, let's
delete our old contract, we can

3386
03:13:42.116 --> 03:13:46.116
actually see storage factory dot
soul again, we can deploy it,

3387
03:13:46.116 --> 03:13:49.116
click the drop down. And once
again, we can run those

3388
03:13:49.116 --> 03:13:52.116
functions exactly the same.
importing our contracts like

3389
03:13:52.116 --> 03:13:56.116
this is much nicer than always
copy pasting the code. This way,

3390
03:13:56.116 --> 03:13:58.116
if we want to change something
in simple storage, we have one

3391
03:13:58.116 --> 03:14:01.116
canonical place to go ahead and
change it instead of having to

3392
03:14:01.116 --> 03:14:03.116
change it in multiple different
places. Now additionally, you'll

3393
03:14:03.116 --> 03:14:06.116
notice the pragma, solidity if
we have our contracts in two

3394
03:14:06.116 --> 03:14:09.116
separate files, we actually can
have different versions of

3395
03:14:09.116 --> 03:14:13.116
solidity right now our storage
factory has carrot zero point

3396
03:14:13.116 --> 03:14:18.116
8.0 Which means that anything
within the 0.8 range of this

3397
03:14:18.116 --> 03:14:22.116
contract is okay. But for simple
storage that sole, it says

3398
03:14:22.116 --> 03:14:26.116
anything in the zero point 8.8
And above range is okay. So if

3399
03:14:27.116 --> 03:14:31.116
we were to try to change the
compiler version 8.5 And then go

3400
03:14:31.116 --> 03:14:34.116
ahead and compile, a remix is
going to automatically bump it

3401
03:14:34.116 --> 03:14:37.116
up to a better version that is
compatible with both of them, in

3402
03:14:37.116 --> 03:14:41.116
this case eight point 13. But if
we, for example, changed our

3403
03:14:41.116 --> 03:14:46.116
solidity version of storage
factory to zero point 7.0 And

3404
03:14:46.116 --> 03:14:51.116
then tried to compile them. We
actually end up getting an issue

3405
03:14:51.116 --> 03:14:54.116
parser error source file
requires a different compiler

3406
03:14:54.116 --> 03:14:58.116
version. This is because our
storage factory is saying hey,

3407
03:14:58.116 --> 03:15:03.116
anything in 0.7 means is okay.
However, our simple storage is

3408
03:15:03.116 --> 03:15:07.116
saying anything in the zero
point 8.8 And above is okay. So

3409
03:15:07.116 --> 03:15:10.116
those two versions are not
compatible. So what we need to

3410
03:15:10.116 --> 03:15:13.117
do is we need to make sure our
versions of solidity are indeed

3411
03:15:13.117 --> 03:15:17.117
compatible. So let's change the
version back recompile. And now

3412
03:15:17.117 --> 03:15:20.117
we're looking good again. Now
since we have this create simple

3413
03:15:20.117 --> 03:15:23.117
storage contract, every single
time we call it right now, it'll

3414
03:15:23.117 --> 03:15:26.117
just replace whatever is
currently in our public simple

3415
03:15:26.117 --> 03:15:29.117
storage variable. Let's go ahead
and update this so that we can

3416
03:15:29.117 --> 03:15:32.117
actually keep a running list of
all of our deployed simple

3417
03:15:32.117 --> 03:15:35.117
storage contracts. So instead of
having this be a single

3418
03:15:35.117 --> 03:15:39.117
variable, we'll make this a
simple storage array or list

3419
03:15:39.117 --> 03:15:44.117
public simple storage array.
Now, whenever we create a new

3420
03:15:44.117 --> 03:15:48.117
simple storage contract, instead
of saving it like this, what

3421
03:15:48.117 --> 03:15:51.117
we're going to do is we're going
to save it as a memory variable

3422
03:15:51.117 --> 03:15:56.117
by saying simple storage, simple
storage equals new simple

3423
03:15:56.117 --> 03:16:00.117
storage. And we're going to add
this variable to our simple

3424
03:16:00.117 --> 03:16:04.117
storage array. So the same way
we did it before, we're gonna do

3425
03:16:04.117 --> 03:16:11.117
simple storage array dot push,
simple storage. So I should

3426
03:16:11.117 --> 03:16:14.117
spell storage, right? Let's go
ahead and compile this looks

3427
03:16:14.117 --> 03:16:19.117
good. We'll deploy the storage
factory deploy. Like here, we

3428
03:16:19.117 --> 03:16:24.117
now have simple storage array
View button, we'll do create

3429
03:16:24.117 --> 03:16:27.117
simple storage. Now we can view
the simple storage contract

3430
03:16:27.117 --> 03:16:31.117
zero. Right now there's nothing
at one. But if we create another

3431
03:16:31.117 --> 03:16:33.117
simple storage contract, we can
see the new simple storage

3432
03:16:33.117 --> 03:16:38.117
contract address at index one.

3433
03:16:38.117 --> 03:16:39.117
All right, so this is great,

3434
03:16:39.117 --> 03:16:43.117
we can now keep track of all of
our simple storage deployments.

3435
03:16:43.117 --> 03:16:45.117
But how do we actually interact
with them, let's say we wanted

3436
03:16:45.117 --> 03:16:48.117
to be able to call the store
function on all of our simple

3437
03:16:48.117 --> 03:16:52.118
storage dot souls from our
storage factory, you can think

3438
03:16:52.118 --> 03:16:55.118
of the storage factory as almost
like a manager of all of our

3439
03:16:55.118 --> 03:16:58.118
simple storages. That's all
let's create a new function that

3440
03:16:58.118 --> 03:17:01.118
can do exactly that. So we'll
create function, and we'll call

3441
03:17:01.118 --> 03:17:07.118
it S F store, which is going to
stand for storage factory store.

3442
03:17:07.118 --> 03:17:13.118
And it's going to take you in
256, simple storage index, and a

3443
03:17:13.118 --> 03:17:20.118
UNT 256, underscore simple
storage

3444
03:17:20.118 --> 03:17:23.118
number. There'll be a public

3445
03:17:23.118 --> 03:17:26.118
auction as well. Now in order
for you to interact with any

3446
03:17:26.118 --> 03:17:30.118
contract, you're always going to
need two things. And we're going

3447
03:17:30.118 --> 03:17:34.118
to refer to this a lot. You're
always going to need the address

3448
03:17:34.118 --> 03:17:40.118
of the contract, and the ABI of
the contract. The API stands for

3449
03:17:40.118 --> 03:17:44.118
Application binary interface,
the API will tell our code

3450
03:17:44.118 --> 03:17:48.118
exactly how it can interact with
the contract, we'll go deeper

3451
03:17:48.118 --> 03:17:52.118
into API as we move on. But if
you go to your compile tab, you

3452
03:17:52.118 --> 03:17:54.118
hit compile, and things are
actually compiling. You can

3453
03:17:54.118 --> 03:17:58.118
scroll down, and you can see
compilation details. And you can

3454
03:17:58.118 --> 03:18:02.118
see a whole bunch of information
on your different contracts. You

3455
03:18:02.118 --> 03:18:05.118
can see the name of your
contract, which for our simple

3456
03:18:05.118 --> 03:18:08.118
storage contract is simple
storage, you can see a whole

3457
03:18:08.118 --> 03:18:11.118
bunch of metadata, like the
compiler, the language output

3458
03:18:12.118 --> 03:18:15.118
settings, all this other stuff.
You can see the exact bytecode

3459
03:18:15.118 --> 03:18:18.118
and the opcodes, which we'll
talk about much later. But you

3460
03:18:18.118 --> 03:18:22.118
can also see this API, this API
tells you all the different

3461
03:18:22.118 --> 03:18:24.118
inputs and outputs and
everything you could do with

3462
03:18:24.118 --> 03:18:28.118
this contract. For example, in
our simple storage, if we look

3463
03:18:28.118 --> 03:18:32.119
at the zero with index of our
API, we have a function add

3464
03:18:32.119 --> 03:18:36.119
person. If we look at one, we
see our name to favorite number,

3465
03:18:36.119 --> 03:18:42.119
we looked at two we can see our
people three retrieve for store,

3466
03:18:42.119 --> 03:18:44.119
it tells us all these different
ways we can actually interact

3467
03:18:44.119 --> 03:18:47.119
with our contract. And the
different functions that we can

3468
03:18:47.119 --> 03:18:51.119
call, we know where addresses
are, because we're storing them

3469
03:18:51.119 --> 03:18:55.119
in this array here, our simple
storage array, we can also get

3470
03:18:55.119 --> 03:18:58.119
the API because we're importing
simple storage dot soul when you

3471
03:18:58.119 --> 03:19:02.119
compile simple storage on soul.
As you saw on the compilation

3472
03:19:02.119 --> 03:19:05.119
details, whenever you compile
it, it comes prepackaged with

3473
03:19:05.119 --> 03:19:09.119
the ABI, we automatically get
the ABI just by importing it

3474
03:19:09.119 --> 03:19:12.119
like this. In the future, we'll
see other ways that we can

3475
03:19:12.119 --> 03:19:15.119
actually get API's really
easily. So to call the store

3476
03:19:15.119 --> 03:19:18.119
function on one of our
contracts, we're first going to

3477
03:19:18.119 --> 03:19:21.119
need to get that contract
object. So what we can do is we

3478
03:19:21.119 --> 03:19:27.119
can say simple storage variable
named simple storage. Variable

3479
03:19:27.119 --> 03:19:30.119
Name simple storage of type
simple storage is going to be

3480
03:19:30.119 --> 03:19:38.119
equal to a simple storage
object. And instead of doing new

3481
03:19:38.119 --> 03:19:41.119
simple storage, like we did last
time, we're just going to put

3482
03:19:41.119 --> 03:19:45.119
the address of this simple
storage object in here, which

3483
03:19:45.119 --> 03:19:48.119
again, we can get from our
array. And in this function,

3484
03:19:48.119 --> 03:19:52.119
we're passing the array index.
So we can say simple storage

3485
03:19:52.119 --> 03:19:59.119
contract at address simple
storage array. At index simple

3486
03:20:00.119 --> 03:20:05.119
Storage index. This bracket
notation here is how you access

3487
03:20:05.119 --> 03:20:08.119
different elements of arrays. So
if we want the zeroeth element

3488
03:20:08.119 --> 03:20:12.120
of our list here, simple storage
index would be zero, and we pass

3489
03:20:12.120 --> 03:20:16.120
it into this bit here, then
that'll give us the address of

3490
03:20:16.120 --> 03:20:18.120
our simple storage contract,
which we pass into simple

3491
03:20:18.120 --> 03:20:22.120
storage here. Since this is an
array of simple storage

3492
03:20:22.120 --> 03:20:25.120
contracts, we can just access
that simple storage contract

3493
03:20:25.120 --> 03:20:32.120
using the index. So we would
say, simple store, Edge array at

3494
03:20:32.120 --> 03:20:40.120
index underscore simple storage
index. Now we're saving the

3495
03:20:40.120 --> 03:20:44.120
contract object at index simple
storage index to our simple

3496
03:20:44.120 --> 03:20:47.120
storage variable. Our array here
is keeping track of the

3497
03:20:47.120 --> 03:20:52.120
addresses for us. And it
automatically comes with the ABI

3498
03:20:52.120 --> 03:20:56.120
is here. If this was just an
array of addresses of the

3499
03:20:56.120 --> 03:21:00.120
contract objects, instead, we
would have to wrap the address

3500
03:21:00.120 --> 03:21:04.120
in a simple storage object like
this. But we'll get to that much

3501
03:21:04.120 --> 03:21:07.120
later. So for now, all we have
to do is this and we now have a

3502
03:21:07.120 --> 03:21:11.120
simple storage contract object.
Now that we have it, we can call

3503
03:21:11.120 --> 03:21:15.120
our store function on the simple
storage contract. So we'll call

3504
03:21:15.120 --> 03:21:23.120
simple storage dot store. And
we'll store the simple storage

3505
03:21:23.120 --> 03:21:24.120
number to it. So this

3506
03:21:24.120 --> 03:21:26.120
is perfect. And if we were to
deploy this right now, though,

3507
03:21:26.120 --> 03:21:29.120
we wouldn't be able to read the
store function. So let's create

3508
03:21:29.120 --> 03:21:32.120
another function that can read
from the simple storage contract

3509
03:21:32.120 --> 03:21:36.120
from the storage factory. So
we'll create a function called S

3510
03:21:36.120 --> 03:21:42.120
F get, which stands for storage
factory get, it'll take a un 256

3511
03:21:42.120 --> 03:21:47.120
underscore simple storage index.
This will be a public view

3512
03:21:47.120 --> 03:21:50.120
function, since we're just going
to be reading from our simple

3513
03:21:50.120 --> 03:21:54.121
storage contract. And it's going
to return a UNT 256. And we'll

3514
03:21:54.121 --> 03:21:57.121
say simple storage.

3515
03:21:57.121 --> 03:22:01.121
Simple Storage. Equals

3516
03:22:01.121 --> 03:22:04.121
when you use this same syntax
from up here to get the contract

3517
03:22:04.121 --> 03:22:07.121
simple storage array at the
simple storage index. And then

3518
03:22:07.121 --> 03:22:10.121
we're going to do return,

3519
03:22:10.121 --> 03:22:16.121
simple storage.re retrieve

3520
03:22:16.121 --> 03:22:20.121
to get that number that we just
stored up here. And I should

3521
03:22:20.121 --> 03:22:24.121
spell retrieved correctly, so we
get no issues. Perfect. So now

3522
03:22:24.121 --> 03:22:29.121
we'll compile, we'll deploy JAVA
script, we're working on a fake

3523
03:22:29.121 --> 03:22:33.121
account, we're going to use our
storage factory, go ahead and

3524
03:22:33.121 --> 03:22:35.121
delete all the contracts we have
so far. Let's go ahead and

3525
03:22:35.121 --> 03:22:41.121
deploy the drop down rate. Right
now if we do SF get at zero,

3526
03:22:41.121 --> 03:22:44.121
we're going to get nothing.
Simple Storage address zero is

3527
03:22:44.121 --> 03:22:47.121
going to be nothing. Let's
create a simple storage

3528
03:22:47.121 --> 03:22:52.121
contract. Now it's simple
storage list, we get an address

3529
03:22:52.121 --> 03:22:57.121
at zero. If we hit SF get right
now it didn't zero, we get zero.

3530
03:22:57.121 --> 03:23:02.121
So let's store a value on this
contract here. So the index of

3531
03:23:02.121 --> 03:23:05.121
that contract is zero. So we're
going to pass zero as a symbol

3532
03:23:05.121 --> 03:23:09.121
storage index. And we're going
to save the number seven. So

3533
03:23:09.121 --> 03:23:13.121
we'll go ahead and do SF store.
And if we did this, right, this

3534
03:23:13.121 --> 03:23:18.121
is going to store the value
seven into this contract. So if

3535
03:23:18.121 --> 03:23:23.121
we do SF get of zero now, it
does indeed return seven. If we

3536
03:23:23.121 --> 03:23:27.121
do SF get one we're going to get
nothing's going to happen. And

3537
03:23:27.121 --> 03:23:30.121
we're actually going to get this
revert error here. So let's

3538
03:23:30.121 --> 03:23:33.122
create another simple storage
contract. Now if we do SF get

3539
03:23:33.122 --> 03:23:37.122
one, we get zero, because we're
gonna get that default value.

3540
03:23:37.122 --> 03:23:40.122
Let's go ahead on the simple
storage contract and index one

3541
03:23:40.122 --> 03:23:45.122
will store the number 16 will
hit SF store. Now we'll do SF

3542
03:23:45.122 --> 03:23:49.122
get one and we get 16. Feel free
to pause right now and play

3543
03:23:49.122 --> 03:23:51.122
around with this so that you
really understand it. The quick

3544
03:23:51.122 --> 03:23:54.122
recap is our storage factory
contract allows us to create

3545
03:23:54.122 --> 03:23:58.122
simple storage contracts, it
then saves it to our simple

3546
03:23:58.122 --> 03:24:02.122
storage array, which we can then
call different functions on, we

3547
03:24:02.122 --> 03:24:06.122
can store values from our
storage factory contract. And

3548
03:24:06.122 --> 03:24:09.122
then we can read values from our
storage factory contract for any

3549
03:24:09.122 --> 03:24:13.122
of the simple storage contracts
that we've created. This is

3550
03:24:13.122 --> 03:24:16.122
incredibly powerful, we can
additionally make these two

3551
03:24:16.122 --> 03:24:20.122
functions even easier. We can
call the Retrieve function

3552
03:24:20.122 --> 03:24:24.122
directly on this when we call
simple storage array. And then

3553
03:24:24.122 --> 03:24:28.122
we have these brackets and add
the simple storage index. This

3554
03:24:28.122 --> 03:24:31.122
returns a simple storage object.
So what we could do is we could

3555
03:24:31.122 --> 03:24:34.122
actually delete this whole part

3556
03:24:34.122 --> 03:24:38.122
and just do dot retrieve

3557
03:24:38.122 --> 03:24:41.122
right here, and then delete this
line and say return and just

3558
03:24:41.122 --> 03:24:44.122
have it be just like this. If
you go ahead and save or hit

3559
03:24:44.122 --> 03:24:47.122
Compile, you'll get the green
checkmark there. We're calling

3560
03:24:47.122 --> 03:24:51.122
the Retrieve function on
whatever this is. And whatever

3561
03:24:51.122 --> 03:24:55.122
this is, is a simple storage
object. So perfect. We can do

3562
03:24:55.122 --> 03:24:59.122
the same thing up here by
deleting this part and just

3563
03:24:59.122 --> 03:25:08.122
doing dot store, underscore
simple store edge number, we

3564
03:25:08.122 --> 03:25:11.122
save it. And this will work
exactly the same. Awesome, we

3565
03:25:11.122 --> 03:25:13.123
now have a simple storage
contract that can store

3566
03:25:13.123 --> 03:25:16.123
variables in a storage factory
contract that can be almost like

3567
03:25:16.123 --> 03:25:19.123
a manager of these simple
storage contracts and deploy and

3568
03:25:19.123 --> 03:25:21.123
interact with them themselves.
This is

3569
03:25:21.123 --> 03:25:26.123
fantastic. Now, let's say that

3570
03:25:26.123 --> 03:25:28.123
we really liked the simple
storage contract, but it doesn't

3571
03:25:28.123 --> 03:25:32.123
do everything that we want it to
do. Maybe we want it so that

3572
03:25:32.123 --> 03:25:35.123
whenever we actually store value
doesn't store the favorite

3573
03:25:35.123 --> 03:25:39.123
number, it stores the favorite
number plus five, for some

3574
03:25:39.123 --> 03:25:41.123
reason you want a contract that
that everyone's favorite number

3575
03:25:41.123 --> 03:25:44.123
is five numbers bigger than what
they think it is. But you really

3576
03:25:44.123 --> 03:25:47.123
like everything else that this
contract has to offer. Let's

3577
03:25:47.123 --> 03:25:51.123
create this new contract. And
we'll call it extra storage.

3578
03:25:51.123 --> 03:25:56.123
So we'll say extra storage dot
soul.

3579
03:25:56.123 --> 03:25:58.123
And we'll create this new
contract, we're going to set it

3580
03:25:58.123 --> 03:26:02.123
up the exact same way we
normally would spdx license

3581
03:26:02.123 --> 03:26:09.123
identifier, gonna be MIT, we'll
give it pragma solidity. And

3582
03:26:09.123 --> 03:26:12.123
we'll just do zero

3583
03:26:12.123 --> 03:26:17.123
point 8.0 with the carrot. And
we'll say contract, extra

3584
03:26:17.123 --> 03:26:20.123
storage, like so

3585
03:26:20.123 --> 03:26:23.123
if you save or compile, you'll
get the green checkmark. So what

3586
03:26:23.123 --> 03:26:26.123
can we do? Well, the first thing
we could do is we could copy

3587
03:26:26.123 --> 03:26:30.123
paste all this code back into
here, and then modify our extra

3588
03:26:30.123 --> 03:26:33.123
storage contract as we see fit.
This seems a little bit

3589
03:26:33.123 --> 03:26:36.123
redundant. And a lot of work
though. So what's another way we

3590
03:26:36.123 --> 03:26:39.123
can actually get our extra
storage contract to be like our

3591
03:26:39.123 --> 03:26:42.123
simple storage contract? Well,
this is where we can do

3592
03:26:42.123 --> 03:26:46.123
something called inheritance, we
can have our extra storage

3593
03:26:46.123 --> 03:26:50.123
contract, do what's called a
child contract of our simple

3594
03:26:50.123 --> 03:26:54.124
storage contract. And we can
have extra storage, inherit all

3595
03:26:54.124 --> 03:26:59.124
the functionality of simple
storage with two lines of code.

3596
03:26:59.124 --> 03:27:03.124
So first, in order for our extra
storage contract to know about

3597
03:27:03.124 --> 03:27:06.124
simple storage, we once again
need to import it. So we'll say

3598
03:27:06.124 --> 03:27:12.124
import dot slash, simple storage
dot soul. And we'll say our

3599
03:27:12.124 --> 03:27:20.124
contract extra storage is simple
storage. And we save or compile.

3600
03:27:20.124 --> 03:27:25.124
Now our extra storage contract
is going to be the exact same as

3601
03:27:25.124 --> 03:27:28.124
simple storage. And it's going
to do what's called inherit all

3602
03:27:28.124 --> 03:27:30.124
the functionality of simple
storage. And we can actually

3603
03:27:30.124 --> 03:27:34.124
even see that, let's go ahead
and make sure this is compiled.

3604
03:27:34.124 --> 03:27:37.124
And we'll go and deploy this.
And now in our deployed

3605
03:27:37.124 --> 03:27:42.124
contract, we can see we have
extra storage deployed with all

3606
03:27:42.124 --> 03:27:45.124
the functions that simple
storage has, if you want a

3607
03:27:45.124 --> 03:27:48.124
contract to inherit all the
functionality of another

3608
03:27:48.124 --> 03:27:52.124
contract, you can just import it
and say your contract is that

3609
03:27:52.124 --> 03:27:56.124
other contract. Now, we can add
additional functions to our

3610
03:27:56.124 --> 03:27:59.124
extra storage contract. That
will include all the

3611
03:27:59.124 --> 03:28:02.124
functionality of simple storage.
Now, let's say that we inherit

3612
03:28:02.124 --> 03:28:06.124
simple storage to extra storage.
However, one of the functions in

3613
03:28:06.124 --> 03:28:09.124
simple storage we don't really
actually like. So if we go back

3614
03:28:09.124 --> 03:28:12.124
to our simple storage contract,
our store function, all it does

3615
03:28:12.124 --> 03:28:15.124
is take a favorite number, and
then assigns the global favorite

3616
03:28:15.124 --> 03:28:19.124
number to whatever new number
that we give it in our extra

3617
03:28:19.124 --> 03:28:21.124
storage. We want the store
function to do something

3618
03:28:21.124 --> 03:28:26.124
different. We want it to add
five, to any number that we give

3619
03:28:26.124 --> 03:28:29.124
it. How can we achieve this?
Well, we can do something called

3620
03:28:29.124 --> 03:28:32.125
overriding the functions. And
there are two keywords that

3621
03:28:32.125 --> 03:28:36.125
we're going to use. Those are
virtual, and override. Right

3622
03:28:36.125 --> 03:28:39.125
now, if I were to try to
implement a store function for

3623
03:28:39.125 --> 03:28:42.125
extra storage, let's see what
happens. We'll say function

3624
03:28:42.125 --> 03:28:48.125
store, you went to the six
favorite number. There'll be a

3625
03:28:48.125 --> 03:28:53.125
public function. And let's say
instead of just storing favorite

3626
03:28:53.125 --> 03:28:59.125
number, we'll say favorite
number equals favorite number,

3627
03:28:59.125 --> 03:29:03.125
plus five. If we try to compile
this right now, we'll actually

3628
03:29:03.125 --> 03:29:07.125
run into two different errors.
First one is going to say

3629
03:29:07.125 --> 03:29:10.125
overriding function is missing,
override specifier. If the

3630
03:29:10.125 --> 03:29:13.125
parent contract, which in our
case is simple storage has that

3631
03:29:13.125 --> 03:29:17.125
same function, we need to tell
solidity that we're going to

3632
03:29:17.125 --> 03:29:22.125
override this store function and
instead we're going to use this

3633
03:29:22.125 --> 03:29:25.125
store function. But
additionally, we get this other

3634
03:29:25.125 --> 03:29:28.125
error saying trying to override
non virtual function. Did you

3635
03:29:28.125 --> 03:29:33.125
forget to add virtual in order
for a function to be overridable

3636
03:29:33.125 --> 03:29:37.125
you need to add the virtual
keyword to the store function.

3637
03:29:37.125 --> 03:29:41.125
Now it can be overridable.
However, if we save and compile,

3638
03:29:41.125 --> 03:29:44.125
we still have this issue
overriding function is missing

3639
03:29:44.125 --> 03:29:48.125
override specifier. And then all
we need to do is add override to

3640
03:29:48.125 --> 03:29:52.125
restore function. Now if we save
everything compiles correctly,

3641
03:29:52.125 --> 03:29:56.125
let's go ahead and deploy this.
Let's delete our old contracts.

3642
03:29:56.125 --> 03:29:59.125
JavaScript VM right account.
Great we're going to choose

3643
03:29:59.125 --> 03:30:02.125
extra store Reg, let's go ahead
and deploy. And here's our extra

3644
03:30:02.125 --> 03:30:06.125
storage contract. Right now if
we retrieve, we get zero.

3645
03:30:06.125 --> 03:30:09.125
Previously, our store function
would store the exact number.

3646
03:30:09.125 --> 03:30:13.126
However, if I were to store
five, it'll store five, plus

3647
03:30:13.126 --> 03:30:17.126
five. So we should have 10
stored here. Let's go ahead call

3648
03:30:17.126 --> 03:30:21.126
store looks like that one
through, and we'll hit retrieved

3649
03:30:21.126 --> 03:30:25.126
now. And we do indeed see 10 is
in here. So this is how we do

3650
03:30:25.126 --> 03:30:27.126
inheritance, and we override

3651
03:30:27.126 --> 03:30:32.126
functions. And that's it. For
this

3652
03:30:32.126 --> 03:30:35.126
section, you've just learned a
ton of incredibly powerful

3653
03:30:35.126 --> 03:30:39.126
solidity for having multiple
files. Let's do a quick overview

3654
03:30:39.126 --> 03:30:42.126
of what we learned, we learned
that we can actually deploy

3655
03:30:42.126 --> 03:30:46.126
contracts from other contracts
using the new keyword, we

3656
03:30:46.126 --> 03:30:50.126
learned that we can actually
import other contracts into our

3657
03:30:50.126 --> 03:30:53.126
contracts and into our code
using the Import keyword. And

3658
03:30:53.126 --> 03:30:56.126
the import keyword is the same
as copying pasting that file to

3659
03:30:56.126 --> 03:30:59.126
the location of the import line,
we learned that we can interact

3660
03:30:59.126 --> 03:31:03.126
with other contracts. As long as
we have the ABI and address. We

3661
03:31:03.126 --> 03:31:06.126
didn't learn too much about the
ABI. But we'll learn more later,

3662
03:31:06.126 --> 03:31:09.126
we learned that if we want to
create a child contract and

3663
03:31:09.126 --> 03:31:12.126
inherit the functionality of
some other contract, we can do

3664
03:31:12.126 --> 03:31:15.126
something called inheritance.
And the way to inherit

3665
03:31:15.126 --> 03:31:19.126
functionality is using the is
keyword and saying our contract

3666
03:31:19.126 --> 03:31:22.126
is some other contract. However,
if we want to change from the

3667
03:31:22.126 --> 03:31:26.126
functionality of the parent
contract, we have to override

3668
03:31:26.126 --> 03:31:29.126
that function. And additionally,
we have to set the function we

3669
03:31:29.126 --> 03:31:32.126
want to override to virtual now
we can have our own store

3670
03:31:32.126 --> 03:31:36.126
function, do whatever we want it
to do. That is the end of this

3671
03:31:36.126 --> 03:31:38.126
lesson. Once again, give
yourself a huge round of

3672
03:31:38.126 --> 03:31:41.126
applause a pat on the back for
making it this far. And for

3673
03:31:41.126 --> 03:31:44.126
finishing this section. You're
getting more and more advanced

3674
03:31:44.126 --> 03:31:48.126
facility so quickly, so be sure
to celebrate the little wins by

3675
03:31:48.126 --> 03:31:50.126
getting some ice cream, maybe
going for a walk or tweeting

3676
03:31:50.126 --> 03:31:53.127
about or posting on Reddit.
Congratulations, you have

3677
03:31:53.127 --> 03:31:57.127
completed this section.

3678
03:31:57.127 --> 03:32:00.127
All right, everybody. Welcome
back. We are now headed into

3679
03:32:00.127 --> 03:32:05.127
Lesson four remix Funmi. And of
course, all the code can be

3680
03:32:06.127 --> 03:32:09.127
found on the GitHub repository
associated with this course.

3681
03:32:09.127 --> 03:32:12.127
We're going to be working with
two contracts here, one of them

3682
03:32:12.127 --> 03:32:15.127
is fundament outsole. And then
one of them is price converted

3683
03:32:15.127 --> 03:32:19.127
outsole Funmi dot Sol is going
to be a contract that allows

3684
03:32:19.127 --> 03:32:22.127
people to actually fund a
collective good. So people can

3685
03:32:22.127 --> 03:32:26.127
send Aetherium send Aetherium,
or polygon or Avalanche or

3686
03:32:26.127 --> 03:32:30.127
Phantom, or whatever blockchain
native token into this contract,

3687
03:32:30.127 --> 03:32:33.127
and some owner of the contract
can then withdraw those funds

3688
03:32:33.127 --> 03:32:36.127
and do whatever they want. After
deploying this to a test net, we

3689
03:32:36.127 --> 03:32:39.127
can see the list of functions
this contract has, this will

3690
03:32:39.127 --> 03:32:44.127
have two red buttons, which are
used to notate to payable

3691
03:32:44.127 --> 03:32:49.127
functions in fund in our fund
function. And in our withdrawal

3692
03:32:49.127 --> 03:32:54.127
function, withdraw allows users
to withdraw the funding and fund

3693
03:32:54.127 --> 03:32:58.127
allows users to send money to
the contract, what we can do is

3694
03:32:58.127 --> 03:33:02.127
we can send some value along
with our transaction. When we

3695
03:33:02.127 --> 03:33:05.127
call this fund function, then
what we can do is we can

3696
03:33:05.127 --> 03:33:08.127
actually fund this contract with
a certain amount of eath, or way

3697
03:33:08.127 --> 03:33:12.127
by pasting some value into the
way value section. And then

3698
03:33:12.127 --> 03:33:16.127
hitting fund, we will now have
sent money into our deployed

3699
03:33:16.127 --> 03:33:20.127
contract. And we can see a list
of the funders and a mapping of

3700
03:33:20.127 --> 03:33:23.127
those addresses and how much
they've actually sent into the

3701
03:33:23.127 --> 03:33:27.127
contract, we can then withdraw
the funds out of the contract.

3702
03:33:27.127 --> 03:33:30.127
With a special exception with
only the person who deployed

3703
03:33:30.127 --> 03:33:33.128
this contract can actually
withdraw the funds back out.

3704
03:33:33.128 --> 03:33:35.128
Once the funds are withdrawn,
the amount of all the funds is

3705
03:33:35.128 --> 03:33:38.128
reset back to zero. Are you
excited? Well, you should be.

3706
03:33:38.128 --> 03:33:41.128
And if you've finished the
section, you've completed most

3707
03:33:41.128 --> 03:33:44.128
of the basics of solidity, and
you'll be ready to start making

3708
03:33:44.128 --> 03:33:46.128
even more powerful smart
contracts, we'll be using

3709
03:33:46.128 --> 03:33:49.128
channeling price feeds to
actually set the value of how

3710
03:33:49.128 --> 03:33:53.128
much these people should be able
to fund in USD as opposed to

3711
03:33:53.128 --> 03:33:56.128
just in terms of ether, we're
gonna go over a lot of advanced

3712
03:33:56.128 --> 03:33:58.128
sections here. And I'll let you
know what parts might be a

3713
03:33:58.128 --> 03:34:01.128
little bit harder to digest. So
you don't have to spend your

3714
03:34:01.128 --> 03:34:03.128
entire time trying to figure out
exactly what's going on. Be sure

3715
03:34:03.128 --> 03:34:05.128
to use the GitHub repo to your
advantage here and the

3716
03:34:05.128 --> 03:34:08.128
discussions tab to stay
connected with other people

3717
03:34:08.128 --> 03:34:14.128
taking this lesson. Alright,
let's jump in. So at this point,

3718
03:34:14.128 --> 03:34:17.128
in remix, you'll have a couple
of contracts here, simple

3719
03:34:17.128 --> 03:34:20.128
storage, storage, factory extra
storage, maybe you refreshed

3720
03:34:20.128 --> 03:34:23.128
remix, and these have gone away.
And in the case, make sure that

3721
03:34:23.128 --> 03:34:26.128
you just don't have any of those
tabs open, we're going to create

3722
03:34:26.128 --> 03:34:31.128
a new contract called funding.
So let's go ahead and start

3723
03:34:31.128 --> 03:34:35.128
creating our funding contract.
Again, we want it to be able to

3724
03:34:35.128 --> 03:34:41.128
get funds from users and
withdraw funds and set a minimum

3725
03:34:41.128 --> 03:34:45.128
funding value in USD. This is
what we're going to get our

3726
03:34:45.128 --> 03:34:51.128
contract to do. So first, let's
set it up spdx license I tend to

3727
03:34:51.128 --> 03:35:00.128
fire MIT do pragma solidity do
caret zero point 8.8. And we'll

3728
03:35:00.128 --> 03:35:05.128
do contract bunbee. Awesome. And
we'll compile, see if things

3729
03:35:05.128 --> 03:35:09.128
look good. And they do. Great.
Let's keep going. So before we

3730
03:35:09.128 --> 03:35:11.128
actually embark on creating all
of our functions here, let's

3731
03:35:11.128 --> 03:35:14.129
just add the different functions
that we're going to implement.

3732
03:35:14.129 --> 03:35:18.129
So we want a function fund for
people to actually send money

3733
03:35:18.129 --> 03:35:23.129
to, we want a function withdraw,
or the owner of this contract to

3734
03:35:23.129 --> 03:35:25.129
actually withdraw the funds that
different funders actually give

3735
03:35:25.129 --> 03:35:29.129
us. And that's pretty much it.
These are the two main functions

3736
03:35:29.129 --> 03:35:32.129
that we want this contract to
do, we will be implementing more

3737
03:35:32.129 --> 03:35:36.129
functions to help facilitate
these two functions. But let's

3738
03:35:36.129 --> 03:35:39.129
get started by looking at fund.
let's comment out withdrawal for

3739
03:35:39.129 --> 03:35:42.129
now. And let's just start with
fun. So we want anybody to be

3740
03:35:42.129 --> 03:35:46.129
able to call this fun function.
So we'll make this public. So as

3741
03:35:46.129 --> 03:35:52.129
we mentioned, we want to be able
to set a minimum font amount in

3742
03:35:52.129 --> 03:35:55.129
USD. So there's a lot of things
to think about here. First thing

3743
03:35:55.129 --> 03:35:58.129
we probably want to think about
is how do we send eath to this

3744
03:35:58.129 --> 03:36:02.129
contract, whenever we create a
transaction on the on any of

3745
03:36:02.129 --> 03:36:06.129
these EVM blockchains, there's
this value field that we can set

3746
03:36:06.129 --> 03:36:08.129
value represents how much
Aetherium we're going to be

3747
03:36:08.129 --> 03:36:12.129
sending with our transactions.
For example, when we transferred

3748
03:36:12.129 --> 03:36:15.129
Aetherium. between our different
accounts, we were actually

3749
03:36:15.129 --> 03:36:19.129
populating this value parameter
with different amounts of

3750
03:36:19.129 --> 03:36:22.129
Aetherium. In fact, every single
transaction that we send, will

3751
03:36:22.129 --> 03:36:26.129
have these fields, it'll have a
nonce or the transaction count

3752
03:36:26.129 --> 03:36:30.129
the account the gas price, the
gas limit that we've seen on

3753
03:36:30.129 --> 03:36:35.129
ether scan a to aka the address
that the transaction is sent to

3754
03:36:35.129 --> 03:36:37.129
a value which is going to be
this amount that we're talking

3755
03:36:37.129 --> 03:36:40.129
about. They'll also have data
which is going to be what we

3756
03:36:40.129 --> 03:36:44.129
send if we make a function call
or deploy contract, and then

3757
03:36:44.129 --> 03:36:47.129
we'll have this v r s
components. We're not really

3758
03:36:47.129 --> 03:36:50.129
going to go over these v r and s
because this is that

3759
03:36:50.129 --> 03:36:53.130
cryptographic magic that's
happening when a transaction is

3760
03:36:53.130 --> 03:36:56.130
signed, but just know that
that's it Now, for sending

3761
03:36:56.130 --> 03:37:00.130
value, we can populate some of
these fields, the gas limit, for

3762
03:37:00.130 --> 03:37:04.130
example, was populated to 21,000
data is going to be empty. And

3763
03:37:04.130 --> 03:37:07.130
then that two is going to be the
address of the transaction we

3764
03:37:07.130 --> 03:37:11.130
want to send to, for a function
call, we can also still populate

3765
03:37:12.130 --> 03:37:16.130
the way that we want to send. So
we can call a function and send

3766
03:37:16.130 --> 03:37:19.130
a value at the same time in
remix has a little drop down

3767
03:37:19.130 --> 03:37:23.130
here for way way Feeny and
ether, we're gonna ignore Feeny

3768
03:37:23.130 --> 03:37:26.130
for now. But of course, we have
our way, great and ether. Again,

3769
03:37:26.130 --> 03:37:30.130
we're one ether is worth this
much way. And this much way, the

3770
03:37:30.130 --> 03:37:33.130
first thing we need to do in
order to make a function payable

3771
03:37:33.130 --> 03:37:36.130
with Aetherium, or any other
native blockchain currency is we

3772
03:37:36.130 --> 03:37:39.130
need to mark the function as
payable. It's this payable

3773
03:37:39.130 --> 03:37:43.130
keyword that makes our font
function red, as opposed to

3774
03:37:43.130 --> 03:37:46.130
having it normal orange, just
like how our wallet can hold

3775
03:37:46.130 --> 03:37:50.130
funds, contract addresses can
hold funds as well, since every

3776
03:37:51.130 --> 03:37:54.130
time you deploy a contract, they
get a contract address, it's

3777
03:37:54.130 --> 03:37:59.130
nearly the exact same as a
wallet address. So both wallets

3778
03:37:59.130 --> 03:38:04.130
and contracts can hold native
blockchain token like Aetherium.

3779
03:38:04.130 --> 03:38:07.130
And you'll see that when we
deploy this later on in the

3780
03:38:07.130 --> 03:38:11.130
lesson, that actually will gain
a balance of Aetherium. Now that

3781
03:38:11.130 --> 03:38:15.130
we have it payable, we can
access this value attribute by

3782
03:38:15.130 --> 03:38:18.130
using one of the global keywords
in solidity with message dot

3783
03:38:18.130 --> 03:38:22.130
value to get how much value
somebody is sending. You use

3784
03:38:22.130 --> 03:38:25.130
message dot value in your
function. Now let's say we want

3785
03:38:25.130 --> 03:38:29.130
to set our message add value to
a certain value of Aetherium.

3786
03:38:29.130 --> 03:38:32.130
Let's say we wanted it to be
let's say we wanted people to

3787
03:38:32.130 --> 03:38:37.131
send at least one whole ether
with all the transactions. Or

3788
03:38:37.131 --> 03:38:40.131
put another way, if they sent
Aetherium, they would need to

3789
03:38:40.131 --> 03:38:43.131
send at least one Aetherium. How
would we implement that? Well,

3790
03:38:43.131 --> 03:38:46.131
we could do something called
require, we would say we want to

3791
03:38:46.131 --> 03:38:53.131
require the message dot value is
greater than one e 18. There's a

3792
03:38:53.131 --> 03:38:59.131
couple of things to unpack here.
One, e 18 is equal to one times

3793
03:38:59.131 --> 03:39:04.131
10 raised to the 18th, which is
also equal to

3794
03:39:04.131 --> 03:39:12.131
112345 678-910-1234 5678. This
is the value in way of one

3795
03:39:12.131 --> 03:39:16.131
Aetherium this much way is one
eath. So if we wanted the

3796
03:39:16.131 --> 03:39:20.131
message dot value to be at least
one eath, or one polygon or

3797
03:39:20.131 --> 03:39:23.131
whatever ranch etc, we would set
it like this require message on

3798
03:39:23.131 --> 03:39:28.131
value is greater than one. This
require keyword is a checker it

3799
03:39:28.131 --> 03:39:33.131
says hey, is message dot value
greater than one. If not, it's

3800
03:39:33.131 --> 03:39:35.131
going to revert, it's going to
do what's called revert with an

3801
03:39:35.131 --> 03:39:40.131
error message. And we can say
didn't send enough, we're gonna

3802
03:39:40.131 --> 03:39:44.131
try deploying this on a
JavaScript VM, deploy Funmi,

3803
03:39:44.131 --> 03:39:47.131
we'll hit Deploy, look at Funmi
we see this fun button is now

3804
03:39:47.131 --> 03:39:52.131
red. If we call Funmi right now,
and we look at the console, you

3805
03:39:52.131 --> 03:39:55.131
can see we actually get an error
here, call it again, we get an

3806
03:39:55.131 --> 03:39:59.131
error, we get an error here, we
know that the air is going to be

3807
03:39:59.131 --> 03:40:04.131
this didn't send enough. So what
we need to do is we need to send

3808
03:40:04.131 --> 03:40:07.131
at least one ether with this fun
transaction, in order for this

3809
03:40:07.131 --> 03:40:11.131
require statement to be
fulfilled. So back up in the

3810
03:40:11.131 --> 03:40:15.132
value section, we can change
this value to one. So that's

3811
03:40:15.132 --> 03:40:20.132
gonna be one ether, or this much
way or this much way. Now we can

3812
03:40:20.132 --> 03:40:23.132
hit fund oh actually needs to be
greater than one.

3813
03:40:23.132 --> 03:40:28.132
So let's send to for example.
Now we'll scroll down. And now

3814
03:40:28.132 --> 03:40:32.132
we'll hit fund. And we see that
that actually passes the require

3815
03:40:32.132 --> 03:40:36.132
statement says if our first
section is false, then go ahead

3816
03:40:36.132 --> 03:40:39.132
and revert with this error. What
is reverting? Revert can be a

3817
03:40:39.132 --> 03:40:42.132
little bit confusing, so I
wouldn't let this section hold

3818
03:40:42.132 --> 03:40:46.132
you back. If it's a little bit
confusing. Revert is when it

3819
03:40:46.132 --> 03:40:49.132
undos any actions that happened
before and send the remaining

3820
03:40:49.132 --> 03:40:53.132
gas back. So what does that
actually look like? Well, let's

3821
03:40:53.132 --> 03:40:59.132
say for example, we had a un
256. Public number. And in our

3822
03:40:59.132 --> 03:41:04.132
fund function, we said number
equals five. If we were to go

3823
03:41:04.132 --> 03:41:07.132
ahead and deploy this, let's
delete our old contract.

3824
03:41:07.132 --> 03:41:11.132
deployed this new contract or
number right now is zero. But if

3825
03:41:11.132 --> 03:41:14.132
we were to call our fund
function number gets set to

3826
03:41:14.132 --> 03:41:19.132
five. However, if we call a fund
and this require isn't met, this

3827
03:41:19.132 --> 03:41:23.132
transaction would revert an
undue setting number to five. So

3828
03:41:23.132 --> 03:41:27.132
let's go ahead and look at our
logs here. We'll keep value zero

3829
03:41:27.132 --> 03:41:31.132
so that our fun function
reverts. We'll call fund will

3830
03:41:31.132 --> 03:41:35.132
see that this transaction failed
because this require end up

3831
03:41:35.132 --> 03:41:38.132
reverting and number is still
zero. So then the question

3832
03:41:38.132 --> 03:41:43.132
becomes, did we actually spend
gas Yes, we spent gas to change

3833
03:41:43.132 --> 03:41:48.132
number to five and then any
remaining gas we would get

3834
03:41:48.132 --> 03:41:52.132
returned by this require for
example, if we had a ton of

3835
03:41:52.132 --> 03:41:56.133
computation here, it On a
computation here, we would have

3836
03:41:56.133 --> 03:42:00.133
need to send a ton of gas with
our fun function. But all the

3837
03:42:00.133 --> 03:42:05.133
extra gas that we send, after
this require gets returned the

3838
03:42:05.133 --> 03:42:08.133
original user after it gets
reverted right here, if reverts

3839
03:42:08.133 --> 03:42:10.133
are a little bit confusing for
you here, don't worry too much

3840
03:42:10.133 --> 03:42:13.133
about it, we'll go over it in
future modules. All you need to

3841
03:42:13.133 --> 03:42:16.133
know right now is that when you
do a require statement, if this

3842
03:42:16.133 --> 03:42:20.133
first section isn't met, the
transaction will be canceled,

3843
03:42:20.133 --> 03:42:23.133
and any prior work will be
undone, and it'll send an error

3844
03:42:23.133 --> 03:42:27.133
message. Cool. Let's delete this
number for now. And we'll delete

3845
03:42:27.133 --> 03:42:30.133
it from the global scope.
There's actually another way to

3846
03:42:30.133 --> 03:42:32.133
do these reverts, which we'll go
over

3847
03:42:32.133 --> 03:42:38.133
later in this contract. So what
we've done so far is great.

3848
03:42:38.133 --> 03:42:43.133
However, we're checking message
dot value in terms of Aetherium,

3849
03:42:43.133 --> 03:42:48.133
we're looking for one whole
Aetherium instead of $50, we

3850
03:42:48.133 --> 03:42:52.133
want to check that message add
value is greater than some

3851
03:42:52.133 --> 03:42:56.133
number like $50. Let's go ahead
and first set the minimum USD

3852
03:42:56.133 --> 03:43:00.133
value we want people to send
along with the fund function, we

3853
03:43:00.133 --> 03:43:04.133
can do that at the top of our
contract, we can say you went to

3854
03:43:04.133 --> 03:43:14.133
56 public minimum USD equals 50.
Now we have some place to check

3855
03:43:14.133 --> 03:43:18.133
for minimum USD, we're going to
update this minimum USD to make

3856
03:43:18.133 --> 03:43:21.133
it more gas efficient and a
little bit. Now that we've set

3857
03:43:21.133 --> 03:43:24.133
our minimum USD, we want to be
able to require the message that

3858
03:43:24.133 --> 03:43:28.133
value is greater than or let's
say greater than or equal to the

3859
03:43:28.133 --> 03:43:34.134
minimum USD. But minimum USD is
in terms of USD and value is in

3860
03:43:34.134 --> 03:43:41.134
terms of Aetherium. So how do we
convert Aetherium to USD, this

3861
03:43:41.134 --> 03:43:44.134
is where Oracle's and chainlink
are going to come into play. The

3862
03:43:44.134 --> 03:43:47.134
USD value of Aetherium is
something that we've assigned

3863
03:43:47.134 --> 03:43:51.134
outside of the blockchain to
Aetherium, or any other layer

3864
03:43:51.134 --> 03:43:54.134
one currency or any other native
smart contract platform

3865
03:43:54.134 --> 03:43:57.134
currency. So in order to get
this value that is outside the

3866
03:43:57.134 --> 03:44:00.134
blockchain, we have to use a
decentralized Oracle network to

3867
03:44:00.134 --> 03:44:05.134
get the price of one ether in
terms of USD. So before we can

3868
03:44:05.134 --> 03:44:08.134
continue on here, let's learn a
little bit more about the

3869
03:44:08.134 --> 03:44:11.134
architecture of these
decentralized Oracle networks

3870
03:44:11.134 --> 03:44:13.134
and the different solutions that
they have. So that we can create

3871
03:44:13.134 --> 03:44:17.134
this Funmi contract in the most
advanced way possible, as we've

3872
03:44:17.134 --> 03:44:20.134
talked about blockchains are
deterministic systems, which

3873
03:44:20.134 --> 03:44:23.134
means that they themselves can't
actually interact with real

3874
03:44:23.134 --> 03:44:26.134
world data and events. They
don't know what the value of an

3875
03:44:26.134 --> 03:44:29.134
Aetherium is, they don't know
what random numbers are. They

3876
03:44:29.134 --> 03:44:31.134
don't know if it's sunny
outside, they don't know the

3877
03:44:31.134 --> 03:44:33.134
temperature, they don't know
who's president, they don't know

3878
03:44:33.134 --> 03:44:37.134
any of this information. These
blockchains also can't do any

3879
03:44:37.134 --> 03:44:40.134
external computation. Maybe you
have some amazing artificial

3880
03:44:40.134 --> 03:44:43.134
intelligence model that you want
to integrate with a smart

3881
03:44:43.134 --> 03:44:46.134
contract. smart contracts by
themselves can't do anything

3882
03:44:46.134 --> 03:44:49.134
with that. As we've mentioned,
this is because blockchains are

3883
03:44:49.134 --> 03:44:52.134
deterministic by design. This is
so that all the nodes can reach

3884
03:44:52.134 --> 03:44:57.134
consensus. If you start adding
variable data or random data, or

3885
03:44:57.134 --> 03:45:00.134
values that returned from an API
call, different nodes could get

3886
03:45:00.134 --> 03:45:03.134
different results, and they
would never be able to reach a

3887
03:45:03.134 --> 03:45:06.134
consensus. This is known as the
smart contract connectivity

3888
03:45:06.134 --> 03:45:10.134
problem, or the Oracle problem.
And this is bad news, because we

3889
03:45:10.134 --> 03:45:13.135
want our smart contracts to be
able to replace traditional

3890
03:45:13.135 --> 03:45:16.135
agreements. And traditional
agreements need data and they

3891
03:45:16.135 --> 03:45:19.135
need to interact with the real
world. So this is where

3892
03:45:19.135 --> 03:45:22.135
chainlink and blockchain,
Oracle's come into place. A

3893
03:45:22.135 --> 03:45:25.135
blockchain Oracle is going to be
any device that interacts with

3894
03:45:25.135 --> 03:45:28.135
the often world to provide
external data or computation to

3895
03:45:28.135 --> 03:45:31.135
smart contracts. However, the
whole story doesn't even in

3896
03:45:31.135 --> 03:45:36.135
there. If we use a centralized
Oracle, we are reintroducing a

3897
03:45:36.135 --> 03:45:39.135
point of failure. We've done all
this work to make our logic

3898
03:45:39.135 --> 03:45:42.135
layer decentralized. But if we
get our data through a

3899
03:45:42.135 --> 03:45:46.135
centralized node or through a
centralized API, we decide we

3900
03:45:46.135 --> 03:45:49.135
want to make the API call
ourselves. We are reintroducing

3901
03:45:49.135 --> 03:45:52.135
these trust assumptions that
we've worked so hard to get rid

3902
03:45:52.135 --> 03:45:55.135
of, we're essentially ruining
the entire purpose of building a

3903
03:45:55.135 --> 03:45:59.135
smart contract. So we don't want
to get our data or do external

3904
03:45:59.135 --> 03:46:03.135
computation through centralized
nodes. Those are bad news. chain

3905
03:46:03.135 --> 03:46:06.135
link is the solution here. chain
link is a decentralized Oracle

3906
03:46:06.135 --> 03:46:10.135
network for bringing data and
external computation into our

3907
03:46:10.135 --> 03:46:13.135
smart contracts. As we mentioned
before, this gives rise to these

3908
03:46:13.135 --> 03:46:17.135
hybrid smart contracts, which
combined on chain and off chain

3909
03:46:17.135 --> 03:46:20.135
to make incredibly feature rich,
powerful applications. chain

3910
03:46:21.135 --> 03:46:23.135
link is a modular, decentralized
Oracle network that can be

3911
03:46:23.135 --> 03:46:27.135
customized to deliver any data
or do any external computation

3912
03:46:27.135 --> 03:46:31.135
that you like. So for example, a
lot of people say, Oh, I can

3913
03:46:31.135 --> 03:46:36.135
just make an HTTPS call to some
API, and we'll be good to go.

3914
03:46:36.135 --> 03:46:40.135
The blockchain nodes can't make
these HTTPS calls, because they

3915
03:46:40.135 --> 03:46:42.135
wouldn't be able to reach
consensus. If they called the

3916
03:46:42.135 --> 03:46:45.135
node at different times, or they
did something else. All the

3917
03:46:45.135 --> 03:46:49.135
consensus would be broken. So
instead, we need a decentralized

3918
03:46:49.135 --> 03:46:52.135
network of chain link Oracle's
to do this, and then in the

3919
03:46:52.135 --> 03:46:56.136
transaction, this network of
nodes will work Turn the data to

3920
03:46:56.136 --> 03:46:59.136
our smart contracts for us. Now
chainlink networks can be

3921
03:46:59.136 --> 03:47:02.136
completely customized to bring
any data or any external

3922
03:47:02.136 --> 03:47:06.136
computation that you want.
However, doing the customization

3923
03:47:06.136 --> 03:47:09.136
can be a little bit extra work,
there are a ton of chainlink

3924
03:47:09.136 --> 03:47:12.136
features that come out of the
box completely decentralized,

3925
03:47:12.136 --> 03:47:15.136
ready to plug and play into your
smart contract applications.

3926
03:47:15.136 --> 03:47:17.136
What are those features, the
first one is going to be

3927
03:47:17.136 --> 03:47:19.136
channeling data feeds, and
that's the one we're actually

3928
03:47:19.136 --> 03:47:21.136
going to be using for
application here. Channeling

3929
03:47:21.136 --> 03:47:24.136
data feeds currently at the time
of recording are powering over

3930
03:47:24.136 --> 03:47:29.136
$50 billion. In the defy world,
the way they work is a network

3931
03:47:29.136 --> 03:47:32.136
of chain link nodes gets data
from different exchanges and

3932
03:47:32.136 --> 03:47:36.136
data providers and brings that
data through a network of

3933
03:47:36.136 --> 03:47:39.136
decentralized chain like notes,
the chain link nodes use a

3934
03:47:39.136 --> 03:47:42.136
median to figure out what the
actual price of the asset is,

3935
03:47:42.136 --> 03:47:45.136
and then deliver that in a
single transaction to what's

3936
03:47:45.136 --> 03:47:48.136
called a reference contract, a
price feed contract or a data

3937
03:47:48.136 --> 03:47:52.136
contract on chain that other
smart contracts can use. And

3938
03:47:52.136 --> 03:47:55.136
then those smart contracts use
that pricing information to

3939
03:47:55.136 --> 03:47:58.136
power their defy application, we
can see an example. We can see

3940
03:47:58.136 --> 03:48:02.136
an example at data dot chain dot
link. And you can change

3941
03:48:02.136 --> 03:48:05.136
networks, you can change price
feeds, you can change a whole

3942
03:48:05.136 --> 03:48:07.136
bunch of different information
to see some of those popular

3943
03:48:07.136 --> 03:48:11.136
price feeds. Let's look at eath
USD for example. On eath USD, we

3944
03:48:11.136 --> 03:48:14.136
can see this whole network of
independent chain link node

3945
03:48:14.136 --> 03:48:17.136
operators that are each getting
different answers for the price

3946
03:48:17.136 --> 03:48:20.136
of eth USD, they're getting
aggregated by the network and

3947
03:48:20.136 --> 03:48:24.136
then delivered on chain, we can
see how often they're updated.

3948
03:48:24.136 --> 03:48:28.136
These ones are updated 4.5
deviation threshold or a few

3949
03:48:28.136 --> 03:48:31.136
hour heartbeat, whichever one
hits. First, we can see when the

3950
03:48:31.136 --> 03:48:35.137
last update was we can see the
number of Oracle responses etc,

3951
03:48:35.137 --> 03:48:39.137
we can see the contract address
directly on chain, we can even

3952
03:48:39.137 --> 03:48:43.137
look at the contract on ether
scan, we can see some of the

3953
03:48:43.137 --> 03:48:46.137
history, we can see all the
responses of the different

3954
03:48:46.137 --> 03:48:49.137
Oracle's. And then at the
bottom, we can see the different

3955
03:48:49.137 --> 03:48:54.137
users and sponsors, keeping this
network up. Similar to

3956
03:48:54.137 --> 03:48:58.137
transaction gas, whenever a node
operator delivers data to a

3957
03:48:58.137 --> 03:49:01.137
smart contract, the chain link
node operators are paid a little

3958
03:49:01.137 --> 03:49:04.137
bit of Oracle gas in the chain
link token. Right now these

3959
03:49:04.137 --> 03:49:07.137
users of the protocol are
sponsoring keeping these feeds

3960
03:49:07.137 --> 03:49:10.137
up and are paying the Oracle gas
associated with delivering this

3961
03:49:10.137 --> 03:49:13.137
data on chain. Here's an
illustration of what the current

3962
03:49:13.137 --> 03:49:15.137
model of these data feeds look
like a network of these chain

3963
03:49:15.137 --> 03:49:19.137
link nodes, each reaches out and
gets the information about an

3964
03:49:19.137 --> 03:49:23.137
asset and then signs the data
with their own private key in a

3965
03:49:23.137 --> 03:49:27.137
single transaction, then, one
node will deliver all the data

3966
03:49:27.137 --> 03:49:29.137
with all the different
signatures to a reference

3967
03:49:29.137 --> 03:49:32.137
contract. If that node doesn't
deliver the data, another node

3968
03:49:32.137 --> 03:49:35.137
will send it instead. Reputation
is incredibly important when

3969
03:49:35.137 --> 03:49:37.137
your chain link node operator if
you miss data updates, if you

3970
03:49:37.137 --> 03:49:40.137
forget to send transactions,
you'll probably be quickly

3971
03:49:40.137 --> 03:49:42.137
kicked off these networks and
have no chance of making any

3972
03:49:42.137 --> 03:49:45.137
more money in the future. These
data feeds are used by some of

3973
03:49:45.137 --> 03:49:49.137
the largest protocols in the
space, such as synthetics, sushi

3974
03:49:49.137 --> 03:49:53.137
swap compound, and Avi, with
several billion dollars each, we

3975
03:49:53.137 --> 03:49:57.137
can take a look at an example
over at Doc's dot chain dot link

3976
03:49:57.137 --> 03:50:00.137
work with EVM contracts, we're
going to hit EVM chains, scroll

3977
03:50:00.137 --> 03:50:04.137
down to data feeds. We'll scroll
down to the solidity section.

3978
03:50:04.137 --> 03:50:08.137
And we can see an example of an
entire contract that uses and

3979
03:50:08.137 --> 03:50:12.137
reads from one of these trending
price feeds. We can even open

3980
03:50:12.137 --> 03:50:17.138
this up and remix and work with
it and remix. It looks like this

3981
03:50:17.138 --> 03:50:20.138
example is reading from a price
feed on COVID. The reason we're

3982
03:50:20.138 --> 03:50:23.138
actually going to use a test net
to see this work is that there's

3983
03:50:23.138 --> 03:50:25.138
a set of chain link nodes
monitoring the test network.

3984
03:50:25.138 --> 03:50:28.138
Just to show you exactly how
this works out. Once we get

3985
03:50:28.138 --> 03:50:30.138
deeper into the course, we'll
show you how to actually run

3986
03:50:30.138 --> 03:50:34.138
tests and work with chain link
nodes without actually being on

3987
03:50:34.138 --> 03:50:36.138
a test net, which will make your
development much faster. But I

3988
03:50:36.138 --> 03:50:40.138
highly recommend walking through
this section along with me so

3989
03:50:40.138 --> 03:50:44.138
that you can see firsthand how
this actually works. So let's go

3990
03:50:44.138 --> 03:50:47.138
ahead and faucets dot chain dot
link slash COVID. We're going to

3991
03:50:47.138 --> 03:50:51.138
switch to the COVID network,
we're going to get some COVID

3992
03:50:51.138 --> 03:50:55.138
eath. But remember, look at the
network flag and use whatever

3993
03:50:55.138 --> 03:50:59.138
network is in the documentation.
So to get some COVID, we're

3994
03:50:59.138 --> 03:51:01.138
going to come to the faucet,
we're going to turn off test

3995
03:51:01.138 --> 03:51:06.138
link, we'll just stay with eath
I'm not a robot,

3996
03:51:06.138 --> 03:51:10.138
and then send request. Once our
COVID Aetherium has reached our

3997
03:51:10.138 --> 03:51:14.138
wallet, we can go ahead and
close we can take a look in our

3998
03:51:14.138 --> 03:51:18.138
wallet and see that we do indeed
have 0.1 eath on Kelvin. Now

3999
03:51:18.138 --> 03:51:22.138
let's go back to our remix,
we'll compile this contract, go

4000
03:51:22.138 --> 03:51:25.138
and deploy this on injected web
three. And again, the reason

4001
03:51:25.138 --> 03:51:28.138
we're going to use injected web
three instead of JavaScript VM

4002
03:51:28.138 --> 03:51:32.138
is that there's no network of
chain link nodes watching our

4003
03:51:32.138 --> 03:51:35.138
little fake JavaScript VM. There
are a network of chain link

4004
03:51:35.138 --> 03:51:39.138
nodes watching the test net. So
we'll scroll down. We'll switch

4005
03:51:39.138 --> 03:51:43.138
contract to the price consumer V
three, and we'll hit Deploy and

4006
03:51:43.138 --> 03:51:47.138
a mass will pop up and after a
brief delay, we can see our

4007
03:51:47.138 --> 03:51:50.138
price feed consumer down here
and we can hit Get the latest

4008
03:51:50.138 --> 03:51:54.139
price which shows us the latest
price of Aetherium in terms of

4009
03:51:54.139 --> 03:51:57.139
USD you may be wondering why the
number looks so weird. That

4010
03:51:57.139 --> 03:52:00.139
seems like a really large number
for the price of Aetherium in

4011
03:52:00.139 --> 03:52:03.139
terms of USD, and this is
because decimals don't actually

4012
03:52:03.139 --> 03:52:06.139
work so well in solidity, and
we'll get to that in a little

4013
03:52:06.139 --> 03:52:09.139
bit. There's a decimals flag
associated with this price feed

4014
03:52:09.139 --> 03:52:13.139
address, that tells us how many
decimals to include with this

4015
03:52:13.139 --> 03:52:16.139
price. It's also in the
documentation. However, I know

4016
03:52:16.139 --> 03:52:19.139
that this one has eight
decimals. So this is saying the

4017
03:52:19.139 --> 03:52:24.139
value of Aetherium right now is
$3,262. It may of course be

4018
03:52:24.139 --> 03:52:27.139
different when you go ahead and
try this. Now there's a number

4019
03:52:27.139 --> 03:52:30.139
of things that happened in this
contract that I'll explain in

4020
03:52:30.139 --> 03:52:32.139
our Funmi example. But if you
want to take a look now and see

4021
03:52:32.139 --> 03:52:35.139
if you can figure out what's
going on, I recommend you do so.

4022
03:52:35.139 --> 03:52:37.139
Price feeds are one of the most
powerful out of the box

4023
03:52:37.139 --> 03:52:41.139
decentralized features, you can
use your smart contract to level

4024
03:52:41.139 --> 03:52:44.139
them up, especially for
decentralized finance. If you're

4025
03:52:44.139 --> 03:52:46.139
looking for different addresses
of different price feeds, you

4026
03:52:46.139 --> 03:52:49.139
can check the contract addresses
section of the documentation,

4027
03:52:49.139 --> 03:52:53.139
choose the network that you
want, and then scroll down and

4028
03:52:53.139 --> 03:52:55.139
look some of the different
addresses of the different price

4029
03:52:55.139 --> 03:52:59.139
feeds. For example, this address
will give you the price of one

4030
03:52:59.139 --> 03:53:02.139
inch token in terms of
Aetherium. This address will

4031
03:53:02.139 --> 03:53:07.139
give you the price of the Apple
stock in terms of USD, and so on

4032
03:53:07.139 --> 03:53:10.139
and so forth. The next
decentralized application right

4033
03:53:10.139 --> 03:53:13.139
out of the box is going to be
channeling VRF or channeling

4034
03:53:13.139 --> 03:53:17.139
verifiable random dysfunction.
Once we do our lottery example a

4035
03:53:17.139 --> 03:53:20.139
little bit later, we'll talk
about how randomness can be

4036
03:53:20.139 --> 03:53:22.139
manipulated in blockchain.
blockchains are deterministic

4037
03:53:22.139 --> 03:53:25.139
systems, which by definition
means that they can't have

4038
03:53:25.139 --> 03:53:28.139
randomness. If you can determine
what a random number is, it's

4039
03:53:28.139 --> 03:53:31.139
not really random anymore, is
it? So we need to wait to get a

4040
03:53:31.139 --> 03:53:34.140
provably random number by
looking outside of the

4041
03:53:34.140 --> 03:53:37.140
blockchain and Oracle's are
perfectly positioned to do

4042
03:53:37.140 --> 03:53:40.140
exactly that. chainlink
verifiable randomness function

4043
03:53:40.140 --> 03:53:42.140
is a way to get provably a
random number into our smart

4044
03:53:42.140 --> 03:53:46.140
contract to guarantee fairness
and guarantee randomness of

4045
03:53:46.140 --> 03:53:50.140
applications. Many protocols
like pool together x infinity,

4046
03:53:50.140 --> 03:53:54.140
ether cards, avocado cheese and
more use channeling VRF for

4047
03:53:54.140 --> 03:53:58.140
lotteries, randomizing NF T's
for gaming and for more, we're

4048
03:53:58.140 --> 03:54:01.140
going to do an example of
channeling VRF in a later

4049
03:54:01.140 --> 03:54:03.140
section. Once we get to the
lottery section, if you want to

4050
03:54:03.140 --> 03:54:06.140
see if you can play with the
randomness yourself right now, I

4051
03:54:06.140 --> 03:54:09.140
recommend you go into Doc's
chain link EVM chains, and

4052
03:54:09.140 --> 03:54:12.140
scroll down to get a random
number. And this will teach you

4053
03:54:12.140 --> 03:54:15.140
how to get a provably random
number into your applications.

4054
03:54:15.140 --> 03:54:18.140
The next decentralized out of
the box feature of chain link is

4055
03:54:18.140 --> 03:54:22.140
chain like keepers, which is
decentralized event driven

4056
03:54:22.140 --> 03:54:25.140
execution. As we've seen, in
order to kick off some type of

4057
03:54:25.140 --> 03:54:29.140
transaction, somebody needs to
spend the gas and somebody needs

4058
03:54:29.140 --> 03:54:32.140
to sit down and hit the go
button or hit the transact

4059
03:54:32.140 --> 03:54:34.140
button or hit the sun. But this
is obviously a centralized

4060
03:54:34.140 --> 03:54:37.140
vector. If you have a
decentralized application that

4061
03:54:37.140 --> 03:54:40.140
needs to run at specific times,
or after specific events are

4062
03:54:40.140 --> 03:54:42.140
triggered. Channeling keepers
are the solution to this

4063
03:54:42.140 --> 03:54:45.140
channeling keepers are chain
link nodes that listen to a

4064
03:54:45.140 --> 03:54:48.140
registration contract for
different events that you

4065
03:54:48.140 --> 03:54:52.140
specify to fire. Maybe you say
every 10 minutes, you want to do

4066
03:54:52.140 --> 03:54:55.140
something or once a week do
something or if the price of

4067
03:54:55.140 --> 03:54:59.140
some acid hits some number, or
maybe a liquidity pool is at a

4068
03:54:59.140 --> 03:55:02.140
certain level, whatever event
that you want to code, you

4069
03:55:02.140 --> 03:55:05.140
absolutely can the chain link
nodes constantly listen for

4070
03:55:05.140 --> 03:55:08.140
these triggers to happen and
check the different contracts

4071
03:55:08.140 --> 03:55:12.140
for these triggers. Once a
trigger returns true, the chain

4072
03:55:12.140 --> 03:55:15.141
link nodes will then perform
whatever action that you tell

4073
03:55:15.141 --> 03:55:18.141
the chain link nodes to do,
we're also not going to go over

4074
03:55:18.141 --> 03:55:21.141
the chain link keepers examples
right now, because we're going

4075
03:55:21.141 --> 03:55:23.141
to get to them in a later
module. However, if you want to

4076
03:55:23.141 --> 03:55:26.141
try them out, go to Doc's
touching that link slash

4077
03:55:26.141 --> 03:55:30.141
Aetherium. Going and go to
making compatible contracts and

4078
03:55:30.141 --> 03:55:32.141
feel free to read the
documentation. Try it out

4079
03:55:32.141 --> 03:55:35.141
yourself. The last out of the
box feature of chain link is the

4080
03:55:35.141 --> 03:55:38.141
most customizable, but also the
hardest to get correct end to

4081
03:55:38.141 --> 03:55:41.141
end reliability is the ultimate
promise of our smart contracts.

4082
03:55:41.141 --> 03:55:45.141
And we want and need them to be
able to do anything, we want to

4083
03:55:45.141 --> 03:55:50.141
be able to take any input and
get any output making HTTP GET

4084
03:55:50.141 --> 03:55:53.141
HTTP POST request is an easy way
to customize our chain link

4085
03:55:53.141 --> 03:55:56.141
nodes to be able to do anything.
Remember how we talked about

4086
03:55:56.141 --> 03:56:00.141
making API calls that blockchain
nodes themselves can do that?

4087
03:56:00.141 --> 03:56:04.141
Well, chain link nodes can do
that chain link nodes can make

4088
03:56:04.141 --> 03:56:07.141
direct requests to any API that
you specify. In order to do

4089
03:56:07.141 --> 03:56:11.141
this, you both have to choose
the chain link node and the URL

4090
03:56:11.141 --> 03:56:14.141
slash data to send the request
to this is a little bit trickier

4091
03:56:14.141 --> 03:56:18.141
than chain link VRF keepers or
price feeds because you then

4092
03:56:18.141 --> 03:56:21.141
have to be responsible for
creating the chain link network

4093
03:56:21.141 --> 03:56:23.141
that gets data from many
different chain link nodes and

4094
03:56:23.141 --> 03:56:25.141
many different data providers.

4095
03:56:25.141 --> 03:56:29.141
But let's look at an example in
remix anyways. For this section,

4096
03:56:29.141 --> 03:56:31.141
feel free to just watch it since
we are working with a test net

4097
03:56:31.141 --> 03:56:34.141
here. And test nets, as we've
seen, can take a little bit of

4098
03:56:34.141 --> 03:56:36.141
time. As long as you're familiar
with what this process looks

4099
03:56:36.141 --> 03:56:39.141
like. That's good enough. You
don't actually have to try it if

4100
03:56:39.141 --> 03:56:43.141
you don't want to. So we'll open
up and remix will read through.

4101
03:56:43.141 --> 03:56:46.141
It looks like this example is on
the COVID network. So we'll go

4102
03:56:46.141 --> 03:56:50.141
ahead and compile API consumer.
We're gonna go ahead and deploy

4103
03:56:50.141 --> 03:56:53.141
on the injected web three, we're
going to make sure that we're

4104
03:56:53.141 --> 03:56:57.142
back on the COVID test network.
We're going to scroll down. And

4105
03:56:57.142 --> 03:56:59.142
we're going to change the
contract to the API consumer.

4106
03:56:59.142 --> 03:57:02.142
And we're going to go ahead and
hit Deploy, we're going to

4107
03:57:02.142 --> 03:57:06.142
deploy this contract to the
COVID. Test net. And now we can

4108
03:57:06.142 --> 03:57:09.142
call this function called
Request volume data to actually

4109
03:57:09.142 --> 03:57:12.142
make an API call. Now, like I
mentioned before, whenever we

4110
03:57:12.142 --> 03:57:15.142
request data from a chain link
node, we have to pay a little

4111
03:57:15.142 --> 03:57:20.142
bit of Oracle gas, or link
token, in order to pay some link

4112
03:57:20.142 --> 03:57:23.142
token, we're going to need to
have link token in our API

4113
03:57:23.142 --> 03:57:26.142
consumer contract. This is
what's known as the basic

4114
03:57:26.142 --> 03:57:29.142
request and receive model to get
link token, we go back to our

4115
03:57:29.142 --> 03:57:32.142
faucet, and this time, we'll
select 10 test link for our

4116
03:57:32.142 --> 03:57:35.142
contract. Let's go ahead and
verify that we're human. And

4117
03:57:35.142 --> 03:57:38.142
we'll hit Send Request. This
time, instead of sending us

4118
03:57:38.142 --> 03:57:42.142
Aetherium. They're sending us 10
test link, which is what's known

4119
03:57:42.142 --> 03:57:47.142
as an ERC 20 token. Or more
accurately, in ERC 677 We'll get

4120
03:57:47.142 --> 03:57:50.142
to understanding that a little
bit later, we can see the asset

4121
03:57:50.142 --> 03:57:54.142
in our Metamask. By importing
the token, in order to get the

4122
03:57:54.142 --> 03:57:57.142
token, we're going to come back
to the documentation. And we're

4123
03:57:57.142 --> 03:58:02.142
going to look up link token
contracts like that, we're going

4124
03:58:02.142 --> 03:58:05.142
to go to the network that we
just got the tokens on, which

4125
03:58:05.142 --> 03:58:10.142
for us was COVID. We're going to
copy this address, we're gonna

4126
03:58:10.142 --> 03:58:14.142
go to Metamask, hit import
tokens, paste that address, and

4127
03:58:14.142 --> 03:58:19.142
hit add custom token, and then
import tokens. And now we can

4128
03:58:19.142 --> 03:58:24.142
see in our account one, we both
have Aetherium and 10. Link, now

4129
03:58:24.142 --> 03:58:27.142
that we have our link or Oracle
gas, we're going to send it to

4130
03:58:27.142 --> 03:58:31.142
our API consumer, we're going to
copy the address of the API

4131
03:58:31.142 --> 03:58:36.143
consumer, open up our meta mask,
we're gonna hit send, paste the

4132
03:58:36.143 --> 03:58:41.143
address of our contract, switch
the asset to link. For now we'll

4133
03:58:41.143 --> 03:58:46.143
just send 0.2 link. We'll hit
next, next. And we'll hit

4134
03:58:46.143 --> 03:58:49.143
Confirm. And we'll wait for this
transaction to go through. I

4135
03:58:49.143 --> 03:58:54.143
chose 0.2 Link, because in this
contract, there's a fee

4136
03:58:54.143 --> 03:58:59.143
character, which tells us how
much making an API call for this

4137
03:58:59.143 --> 03:59:03.143
is going to cost. This one is
actually 0.1 link, I send 0.2.

4138
03:59:03.143 --> 03:59:05.143
Just in case, we want to make
that API call twice. Everything

4139
03:59:05.143 --> 03:59:08.143
that's going on in this function
will explain in a little bit

4140
03:59:08.143 --> 03:59:10.143
later section. But for now, I
just want to show you what it

4141
03:59:10.143 --> 03:59:13.143
looks like to do is, once we
send the link to our contract,

4142
03:59:13.143 --> 03:59:18.143
we can first check to see what
the volume is volume is zero, we

4143
03:59:18.143 --> 03:59:21.143
want to get the volume of the
last 24 hours of Aetherium

4144
03:59:21.143 --> 03:59:25.143
asset, we're going to be calling
this API which has a ton of raw

4145
03:59:25.143 --> 03:59:29.143
data, including one in specific
called volume over the last 24

4146
03:59:29.143 --> 03:59:31.143
hours, which can be this number
right here. Say we wanted to get

4147
03:59:31.143 --> 03:59:35.143
this into our contract from this
API, we're going to make an HTTP

4148
03:59:35.143 --> 03:59:39.143
GET call to this API. And what's
going to happen is we're going

4149
03:59:39.143 --> 03:59:43.143
to make the request in one
transaction. And in a second

4150
03:59:43.143 --> 03:59:46.143
transaction, the chain link node
is gonna return the value and

4151
03:59:46.143 --> 03:59:51.143
store it in this volume variable
in the global scope. So let's go

4152
03:59:51.143 --> 03:59:55.143
ahead and hit request volume
data Metamask gonna pop up,

4153
03:59:55.143 --> 03:59:57.143
we're going to go ahead and hit
Confirm. And you'll notice right

4154
03:59:57.143 --> 04:00:01.143
away volume doesn't update. This
is again, because we actually

4155
04:00:01.143 --> 04:00:05.143
need to wait two transactions,
we're sending a transaction for

4156
04:00:05.143 --> 04:00:08.143
the request. And then in a
second transaction, the chain

4157
04:00:08.143 --> 04:00:11.143
link node is actually going to
respond. And after a slight

4158
04:00:11.143 --> 04:00:14.144
delay, the chain link node has
indeed responded with the result

4159
04:00:14.144 --> 04:00:18.144
of making that API call back to
our contract. We'll go over this

4160
04:00:18.144 --> 04:00:20.144
process a little bit more in
depth in later sections. The

4161
04:00:20.144 --> 04:00:24.144
reason that I wanted to show you
specifically the API calls, is

4162
04:00:24.144 --> 04:00:27.144
because we're going to show you
a real life example of how to

4163
04:00:27.144 --> 04:00:32.144
use chain link VRF and chain the
keepers in a later lesson.

4164
04:00:32.144 --> 04:00:35.144
Now I know we've already gone
over a ton. So let's do a quick

4165
04:00:35.144 --> 04:00:39.144
review. In order to send
Aetherium or whatever native

4166
04:00:39.144 --> 04:00:43.144
blockchain token with a function
need to mark it as payable. If

4167
04:00:43.144 --> 04:00:46.144
you need something in your
contract to happen, and you want

4168
04:00:46.144 --> 04:00:49.144
the whole transaction to fail.
If that doesn't happen, you can

4169
04:00:49.144 --> 04:00:52.144
use a require statement. To get
the Aetherium or native

4170
04:00:52.144 --> 04:00:55.144
blockchain token value of a
transaction, you can use the

4171
04:00:55.144 --> 04:00:59.144
global keyword message dot
value. chain link is a

4172
04:00:59.144 --> 04:01:02.144
technology for getting external
data and doing external

4173
04:01:02.144 --> 04:01:06.144
computation in a decentralized
context for our smart contracts.

4174
04:01:06.144 --> 04:01:09.144
Channeling data feeds or price
feeds are ways to read pricing

4175
04:01:09.144 --> 04:01:12.144
information or other pieces of
data from the real world that's

4176
04:01:12.144 --> 04:01:15.144
already aggregated and
decentralized for us, channeling

4177
04:01:15.144 --> 04:01:19.144
VRF is a way to get provably
random numbers from the real

4178
04:01:19.144 --> 04:01:22.144
world into our smart contracts.
Channeling keepers are a way to

4179
04:01:22.144 --> 04:01:26.144
do decentralized event driven
computation. We can set some

4180
04:01:26.144 --> 04:01:29.144
trigger say if this trigger hits
do something and we get to

4181
04:01:29.144 --> 04:01:32.144
define what the trigger is and
what to do something is

4182
04:01:32.144 --> 04:01:36.144
channeling any API's is the
ultimate customization of

4183
04:01:36.144 --> 04:01:39.144
channeling nodes and allows us
to connect to anything on the

4184
04:01:39.144 --> 04:01:42.144
planet. To make this one
production ready. We have to do

4185
04:01:42.144 --> 04:01:44.144
the most work because it doesn't
come already with a

4186
04:01:44.144 --> 04:01:47.144
decentralized Oracle network,
like chaining the keepers and

4187
04:01:47.144 --> 04:01:50.144
price feeds. We'll learn more
about these channeling services

4188
04:01:50.144 --> 04:01:56.145
as we continue in this course.
Now in order for us to figure

4189
04:01:56.145 --> 04:02:00.145
out if our message dot value is
actually greater than the

4190
04:02:00.145 --> 04:02:03.145
minimum USD that we set, we
actually have to convert our

4191
04:02:03.145 --> 04:02:09.145
message dot value from its layer
one slash Aetherium to the USD

4192
04:02:09.145 --> 04:02:12.145
equivalent. So how are we
actually going to do that? Well,

4193
04:02:12.145 --> 04:02:15.145
first, we're gonna need to get
the price of Aetherium, or

4194
04:02:15.145 --> 04:02:18.145
Phantom, or Avalanche or
whatever layer, one blockchain

4195
04:02:18.145 --> 04:02:21.145
that we're working with. So
let's create a function to get

4196
04:02:21.145 --> 04:02:24.145
that price to get that
conversion rate. So we'll do

4197
04:02:24.145 --> 04:02:29.145
function, get price, and this is
going to be the function that we

4198
04:02:29.145 --> 04:02:33.145
use to get the price of the room
in terms of USD, so we can

4199
04:02:33.145 --> 04:02:37.145
convert our message dot value to
USD. And then we're also going

4200
04:02:37.145 --> 04:02:45.145
to do a function called Get
conversion rate. These are both

4201
04:02:45.145 --> 04:02:47.145
going to be public functions, so
that we can go ahead and call

4202
04:02:47.145 --> 04:02:50.145
them and test them and do
whatever we want with them. So

4203
04:02:50.145 --> 04:02:52.145
in order to get the price, we're
going to have to use one of

4204
04:02:52.145 --> 04:02:56.145
these chain link data feeds to
get the pricing information. And

4205
04:02:56.145 --> 04:03:00.145
we can look right here at this
contract to see what using one

4206
04:03:00.145 --> 04:03:03.145
of these channeling price feeds
looks like. What we're actually

4207
04:03:03.145 --> 04:03:06.145
doing when we're interacting
with this channeling price feed

4208
04:03:06.145 --> 04:03:09.145
is we're actually reading from
one of these contracts, there's

4209
04:03:09.145 --> 04:03:12.145
a contract out there called the
aggregator contract that has a

4210
04:03:12.145 --> 04:03:15.145
function called latest round
data, which returns a whole

4211
04:03:15.145 --> 04:03:20.145
bunch of data. But namely, this
int price. And this in price is

4212
04:03:20.145 --> 04:03:24.145
what we are interested in. Let's
look at our get price function

4213
04:03:24.145 --> 04:03:27.145
and figure out how do we
actually call this since this is

4214
04:03:27.145 --> 04:03:30.145
an instance of us interacting
with a contract outside of our

4215
04:03:30.145 --> 04:03:34.146
project, we're going to need two
things. What are those two

4216
04:03:34.146 --> 04:03:35.146
things,

4217
04:03:35.146 --> 04:03:39.146
we're going to need the ABI of
the contract, and also the

4218
04:03:39.146 --> 04:03:43.146
address of the contract. So the
address of the contract is going

4219
04:03:43.146 --> 04:03:46.146
to be easy, we can get the
address of the contract from the

4220
04:03:46.146 --> 04:03:50.146
contract address this section of
the chain link data feeds. Let's

4221
04:03:50.146 --> 04:03:56.146
scroll on down to bank B. And we
can find the eath USD address on

4222
04:03:56.146 --> 04:03:59.146
Rigby and we'll create this
contract so that it works on

4223
04:03:59.146 --> 04:04:01.146
Rinkeby. So we're going to grab
this address, we're going to

4224
04:04:01.146 --> 04:04:05.146
copy it. And we're going to move
back to our to our code here.

4225
04:04:05.146 --> 04:04:08.146
And we're going to paste the
address here. So great, we have

4226
04:04:08.146 --> 04:04:10.146
the address. Now we have the
address of the other contract

4227
04:04:10.146 --> 04:04:13.146
that we don't want to interact.
Now, how do we get the ABI?

4228
04:04:13.146 --> 04:04:16.146
Well, what we did before was
simple storage was we imported

4229
04:04:16.146 --> 04:04:19.146
the entire contract into our
code here. That's something that

4230
04:04:19.146 --> 04:04:22.146
we could do. But that's actually
a lot of code. So what's

4231
04:04:22.146 --> 04:04:25.146
something that we could do
instead, remember, if we're

4232
04:04:25.146 --> 04:04:28.146
looking at remix, and we look at
one of the contracts that we

4233
04:04:28.146 --> 04:04:33.146
compiled before, the ABI is
really just kind of this list of

4234
04:04:33.146 --> 04:04:36.146
the different functions and
interactions you can have with a

4235
04:04:36.146 --> 04:04:39.146
contract. The ABI itself doesn't
actually need to include any of

4236
04:04:39.146 --> 04:04:42.146
the logic, it just needs to
include, hey, here are the

4237
04:04:42.146 --> 04:04:45.146
different functions that you can
call, for example, in this

4238
04:04:45.146 --> 04:04:48.146
contract, we can call fund, we
have get conversion rate, we

4239
04:04:48.146 --> 04:04:50.146
have get price, they're not
implemented yet, but they will

4240
04:04:50.146 --> 04:04:53.146
be eventually now there
technically is another way to

4241
04:04:53.146 --> 04:04:57.146
interact with contracts without
the API. But for now, we're just

4242
04:04:57.146 --> 04:05:00.146
going to ignore that. So how can
we get the API, there's a

4243
04:05:00.146 --> 04:05:03.146
concept in solidity called an
interface. And let's look at an

4244
04:05:03.146 --> 04:05:07.146
example of an interface. If we
go to github.com/smart, contract

4245
04:05:07.146 --> 04:05:11.146
kits, chainlink, we can see a
number of different contracts in

4246
04:05:11.146 --> 04:05:17.147
the chainlink repository, we can
go to contracts, src, V 0.8,

4247
04:05:17.147 --> 04:05:22.147
interfaces, and we'll go to
aggregator v3 interface, dot

4248
04:05:22.147 --> 04:05:25.147
soul. And if we look at the
solidity in here, we can see a

4249
04:05:25.147 --> 04:05:28.147
whole bunch of function
declarations, but none of the

4250
04:05:28.147 --> 04:05:32.147
logic is actually implemented in
this. This is what's known as an

4251
04:05:32.147 --> 04:05:36.147
interface. If we compile this,
we'll actually get the ABI of a

4252
04:05:36.147 --> 04:05:40.147
contract, because it defines all
the different ways we can

4253
04:05:40.147 --> 04:05:43.147
interact with the contract. It
doesn't actually say, what these

4254
04:05:43.147 --> 04:05:46.147
functions do, which is fine,
though, because we don't need to

4255
04:05:46.147 --> 04:05:49.147
know what the functions actually
do, those are going to be stored

4256
04:05:49.147 --> 04:05:54.147
in the contract. So what we can
do is we can grab this interface

4257
04:05:54.147 --> 04:05:58.147
from the code and paste it into
our remix. Now hold on, if

4258
04:05:58.147 --> 04:06:00.147
you're following along, you
don't have to copy paste this

4259
04:06:00.147 --> 04:06:02.147
with me, because I'm going to
show you an easier way in just a

4260
04:06:02.147 --> 04:06:05.147
second. So for now, feel free to
go ahead and just watch. But

4261
04:06:05.147 --> 04:06:09.147
once we have this interface
aggregator v3 interface, we can

4262
04:06:09.147 --> 04:06:14.147
now use this to make API calls.
So now we could say, aggregator

4263
04:06:14.147 --> 04:06:19.147
v3 interface at this address.
And the combination of these

4264
04:06:19.147 --> 04:06:24.147
two, give us that aggregator v3
contract with whatever code is

4265
04:06:24.147 --> 04:06:27.147
here. If at this contract
address is aggregator v3

4266
04:06:27.147 --> 04:06:31.147
interfaces valid, we can do
something like dot version.

4267
04:06:31.147 --> 04:06:34.147
Let's look at this interface. Is
there a version function? There

4268
04:06:34.147 --> 04:06:39.147
sure is. So that means we can
call the version function on

4269
04:06:39.147 --> 04:06:42.147
this contract. So let's actually
go ahead and copy this into a

4270
04:06:42.147 --> 04:06:45.147
different section. I'm going to
create a new function called Get

4271
04:06:45.147 --> 04:06:50.147
version just to illustrate this.
I'm going to be public. It's

4272
04:06:50.147 --> 04:06:55.148
going to be a view and it's
going to return the UN 256 and

4273
04:06:55.148 --> 04:06:58.148
We're gonna split it up into two
steps here. We're gonna say

4274
04:06:58.148 --> 04:07:04.148
aggregate tour, v3 interface,
price feed. So we're creating a

4275
04:07:04.148 --> 04:07:10.148
variable of type aggregator v3
interface equals aggregator v3

4276
04:07:10.148 --> 04:07:18.148
interface at this address. And
then we're going to return price

4277
04:07:18.148 --> 04:07:22.148
feed that version. Now I'm going
to go ahead and deploy this

4278
04:07:22.148 --> 04:07:25.148
contract to Rigby just to show
you what this git version is

4279
04:07:25.148 --> 04:07:28.148
going to return. But you don't
have to follow along here if you

4280
04:07:28.148 --> 04:07:30.148
don't want because again, we're
working with the test net, you

4281
04:07:30.148 --> 04:07:33.148
can just watch if you'd like for
this section, we're going to

4282
04:07:33.148 --> 04:07:36.148
test a little bit more sparse.
Since we're going to be mainly

4283
04:07:36.148 --> 04:07:38.148
using the test net, since we're
going to be working with an

4284
04:07:38.148 --> 04:07:41.148
actual chain link Oracle
network, once you move over to

4285
04:07:41.148 --> 04:07:45.148
hard hat, and with JavaScript,
all this testing locally will be

4286
04:07:45.148 --> 04:07:47.148
a lot easier and a lot faster,
you're more than welcome to go

4287
04:07:47.148 --> 04:07:50.148
ahead and fiddle and try and
test a lot of this stuff as we

4288
04:07:50.148 --> 04:07:53.148
go along. But just know that it
might take a little bit longer

4289
04:07:53.148 --> 04:07:55.148
to do some of the testing on the
test net,

4290
04:07:55.148 --> 04:07:58.148
let's delete that last funding
contract, we're going to deploy

4291
04:07:58.148 --> 04:08:00.148
this one, we're going to scroll
up, we're going to switch to

4292
04:08:00.148 --> 04:08:05.148
injected web three, we're going
to switch from COVID to rink B.

4293
04:08:05.148 --> 04:08:08.148
And the reason we want to make
sure we're on rink beam is

4294
04:08:08.148 --> 04:08:12.148
because this address is specific
to rink B, the contract that

4295
04:08:12.148 --> 04:08:15.148
we're looking to interact with
might not be at this address on

4296
04:08:15.148 --> 04:08:17.148
every single chain, we want to
make sure we're on the rink B

4297
04:08:17.148 --> 04:08:20.148
chain for this, because of some
other contract is there on the

4298
04:08:20.148 --> 04:08:23.148
different chain, this version
function obviously won't exist,

4299
04:08:23.148 --> 04:08:26.148
and this function could error.
So let's go ahead, we're gonna

4300
04:08:26.148 --> 04:08:31.148
find me, we're going to deploy
this to the rink V chain. Again,

4301
04:08:31.148 --> 04:08:33.148
you don't have to follow along
with me here, you can just

4302
04:08:33.148 --> 04:08:36.149
watch. And once that contract
has been deployed, we now have a

4303
04:08:36.149 --> 04:08:39.149
view function called Get
version. And we can see it's

4304
04:08:39.149 --> 04:08:42.149
returning the variable for
showing us that this is the

4305
04:08:42.149 --> 04:08:47.149
fourth version of a price feed.
So this is a really easy way for

4306
04:08:47.149 --> 04:08:50.149
us to interact with contracts
that exist. Outside of our

4307
04:08:50.149 --> 04:08:53.149
project, we use one of these
interfaces, which can get

4308
04:08:53.149 --> 04:08:57.149
compiled down to the API, and
then combine that ABI with the

4309
04:08:57.149 --> 04:09:00.149
address to call a function. As
we work with these interfaces

4310
04:09:00.149 --> 04:09:03.149
more and more, they'll start to
make more and more sense. So if

4311
04:09:03.149 --> 04:09:05.149
it's a little confusing to you
right now, don't get

4312
04:09:05.149 --> 04:09:08.149
discouraged, the more you work
with it, the easier it will

4313
04:09:08.149 --> 04:09:13.149
become. Now, though, now that we
know how to call these functions

4314
04:09:13.149 --> 04:09:17.149
in here, we can start working
with this interface. However, as

4315
04:09:17.149 --> 04:09:19.149
you know, if we have a whole
bunch of interfaces, we're gonna

4316
04:09:19.149 --> 04:09:21.149
have to stick a whole bunch of
interfaces at the top of our

4317
04:09:21.149 --> 04:09:25.149
code, which looks pretty ugly.
What's a better way for us to do

4318
04:09:25.149 --> 04:09:29.149
this? Well, before we used
import, right, we imported from

4319
04:09:29.149 --> 04:09:34.149
simple storage. That's all for
this one, what we could do is we

4320
04:09:34.149 --> 04:09:38.149
could import from an array gay
Tore v3 interface. That's all,

4321
04:09:39.149 --> 04:09:42.149
we can go ahead and create a new
contract with this aggregator v3

4322
04:09:42.149 --> 04:09:46.149
interface. Or what we can do is
we can import this directly from

4323
04:09:46.149 --> 04:09:50.149
GitHub. If we go back to the
documentation of these chainlink

4324
04:09:50.149 --> 04:09:53.149
data feeds go to using data
feeds, we scroll down, we see at

4325
04:09:53.149 --> 04:09:57.149
the top, we have this import
statement, import at chain link

4326
04:09:57.149 --> 04:10:01.149
slash contracts slash SFC visa
right interfaces aggregator v3

4327
04:10:01.149 --> 04:10:07.149
interface, this, this import is
has the same path setup as the

4328
04:10:07.149 --> 04:10:10.149
GitHub repository for the chain
link code, instead of us

4329
04:10:10.149 --> 04:10:14.149
directly adding all the code
right into our remix, what we

4330
04:10:14.149 --> 04:10:18.150
can do instead is we can import
directly from GitHub, or what's

4331
04:10:18.150 --> 04:10:22.150
called an NPM package. Remix is
smart enough to know that at

4332
04:10:22.150 --> 04:10:26.150
chain link slash contracts, is
referring to the NPM package at

4333
04:10:26.150 --> 04:10:29.150
chain link slash contracts,
we'll talk about NPM, a little

4334
04:10:29.150 --> 04:10:32.150
bit in the future, it's what's
known as a package manager, and

4335
04:10:32.150 --> 04:10:35.150
can keep versions of different
contracts for us to directly

4336
04:10:35.150 --> 04:10:39.150
import into our code bases at
chain link slash contracts is

4337
04:10:39.150 --> 04:10:43.150
created directly from the
chainlink GitHub repository. So

4338
04:10:43.150 --> 04:10:47.150
remix downloads this code from
NPM, which is created from this

4339
04:10:47.150 --> 04:10:50.150
GitHub. So now we know that if
we import at chain link slash

4340
04:10:50.150 --> 04:10:54.150
contracts, src, V 0.8 interfaces
aggregator v3 interface dot

4341
04:10:54.150 --> 04:10:59.150
soul, this is the same as if we
had just stuck this whole

4342
04:10:59.150 --> 04:11:02.150
contract right at the top of our
funding contract, which makes

4343
04:11:02.150 --> 04:11:05.150
our code look a lot nicer. And
now we have this aggregator v3

4344
04:11:05.150 --> 04:11:11.150
interface that we can work with.
Okay, great. So now that we have

4345
04:11:11.150 --> 04:11:14.150
a minimalistic interface, which
will give us the API, how do we

4346
04:11:14.150 --> 04:11:17.150
actually go ahead and get the
price here? Well, documentation

4347
04:11:17.150 --> 04:11:19.150
has a good example, if you want
to play with it and try to

4348
04:11:19.150 --> 04:11:21.150
reverse engineer it as well.
Here's how we're going to do it.

4349
04:11:21.150 --> 04:11:25.150
In our code. We're going to
create an aggregator v3

4350
04:11:25.150 --> 04:11:32.150
interface object called price
feed an aggregator v3 variable

4351
04:11:32.150 --> 04:11:36.150
called price feed, which is
going to equal to aggregator v3

4352
04:11:36.150 --> 04:11:41.150
interface contract at address
this address exactly the same as

4353
04:11:41.150 --> 04:11:45.150
what we're doing down here.
We're assuming a contract at

4354
04:11:45.150 --> 04:11:48.150
this address is going to have
all the functionality of this

4355
04:11:48.150 --> 04:11:51.150
aggregator v3 interface, which
again, means it has this

4356
04:11:51.150 --> 04:11:54.150
decimals function, this
description function version,

4357
04:11:54.150 --> 04:11:57.151
get round data. And the
important one latest round data,

4358
04:11:57.151 --> 04:12:01.151
which has the latest price at
this answer piece, what we can

4359
04:12:01.151 --> 04:12:04.151
do now is we can call that
latest round data function on

4360
04:12:04.151 --> 04:12:09.151
the price feed. So we'll say
price feed dot latest round

4361
04:12:09.151 --> 04:12:12.151
data. Now if we look at the
interface, we see that this

4362
04:12:12.151 --> 04:12:16.151
latest round data actually
doesn't return one variable, it

4363
04:12:16.151 --> 04:12:20.151
returns a whole bunch of
different variables. And that's

4364
04:12:20.151 --> 04:12:22.151
what we're going to return in
our contract. So we're going to

4365
04:12:22.151 --> 04:12:27.151
put these parentheses, and we're
going to say, you went at round

4366
04:12:27.151 --> 04:12:30.151
ID, we can even look right at
the documentation to see what

4367
04:12:30.151 --> 04:12:35.151
else it returns int price, you
went,

4368
04:12:36.151 --> 04:12:45.151
you went started out, you went
timestamp. And then you went ad,

4369
04:12:45.151 --> 04:12:51.151
answered and round. Now there's
a lot of code here. Since this

4370
04:12:51.151 --> 04:12:54.151
function returns so many
different variables, we have to

4371
04:12:54.151 --> 04:12:57.151
set something up to capture
them. However, all we care about

4372
04:12:57.151 --> 04:13:01.151
is price. We don't care about
round Id started at timestamp or

4373
04:13:01.151 --> 04:13:03.151
answered in round. So what we
can do is just remove them and

4374
04:13:03.151 --> 04:13:10.151
just leave the commas.

4375
04:13:10.151 --> 04:13:15.151
Now we have int price equals
price feed that latest round

4376
04:13:15.151 --> 04:13:19.151
data. The reason that price is
an int 256. And not a un 256 is

4377
04:13:19.151 --> 04:13:23.151
because some prices or some data
feeds could be negative here, so

4378
04:13:23.151 --> 04:13:26.151
that it's an int 256. So it can
stay flexible. Now that we have

4379
04:13:26.151 --> 04:13:32.151
the price, this is going to be
price of eath in terms of USD.

4380
04:13:32.151 --> 04:13:35.152
And we saw an example of this
before, it was around 3000. And

4381
04:13:35.152 --> 04:13:39.152
it returned this number because
solidity doesn't work with

4382
04:13:39.152 --> 04:13:41.152
decimals for a number of
reasons. But we just need to

4383
04:13:41.152 --> 04:13:44.152
know that there are eight
decimal places associated with

4384
04:13:44.152 --> 04:13:47.152
this price feed. If you want to
double check how many decimals

4385
04:13:47.152 --> 04:13:50.152
there are, this contract has a
decimal function that you can

4386
04:13:50.152 --> 04:13:53.152
call as well, that will tell you
exactly how many decimals are in

4387
04:13:53.152 --> 04:13:57.152
this price feed. Now as we know,
message dot value is going to

4388
04:13:57.152 --> 04:14:00.152
have 18 decimal places. Why does
it have 18 decimal places? Well,

4389
04:14:00.152 --> 04:14:07.152
because one ether is equal to
1-234-567-8910 12345678 Is this

4390
04:14:07.152 --> 04:14:12.152
massive number in way which has
18 zeros, which is equivalent to

4391
04:14:12.152 --> 04:14:20.152
1.12345 678-910-1234 5678. So we
want these to have the same

4392
04:14:20.152 --> 04:14:22.152
decimal places, right? Because
right now this has eight, this

4393
04:14:22.152 --> 04:14:26.152
is 18. They're different units
right now. So to get them to

4394
04:14:26.152 --> 04:14:34.152
match up, all we need to do is
return price times one, ie 10,

4395
04:14:34.152 --> 04:14:40.152
or one raised to the 10th, which
is equal to 1123456789 10.

4396
04:14:40.152 --> 04:14:45.152
Message dot value, though, is
going to be a UNT 256. And right

4397
04:14:45.152 --> 04:14:49.152
now, price is an interval at
six. So why did we convert this

4398
04:14:49.152 --> 04:14:54.152
value from n into 56. To a human
to 56? Well, we can do what's

4399
04:14:54.152 --> 04:14:58.152
called typecasting, all we need
to do is add you into 56. And

4400
04:14:58.152 --> 04:15:01.152
wrap this whole thing up between
these two parentheses, you can't

4401
04:15:01.152 --> 04:15:06.152
typecast anything. But there are
some values like into 56 and you

4402
04:15:06.152 --> 04:15:09.152
into 56, that can be easily
converted between the two. Now

4403
04:15:09.152 --> 04:15:12.152
of course, since we're not
modifying any state with this

4404
04:15:12.152 --> 04:15:17.153
get price function, we can make
this view and say it returns

4405
04:15:17.153 --> 04:15:21.153
that you went to 36. And if we
save and compile, we go ahead

4406
04:15:21.153 --> 04:15:23.153
and we get that checkmark. Now
math can be a little bit tricky.

4407
04:15:23.153 --> 04:15:26.153
The first couple times you do it
in solidity. But the more you do

4408
04:15:26.153 --> 04:15:28.153
it, the easier it becomes. And
in the future, we can always

4409
04:15:28.153 --> 04:15:32.153
reference a function like this
to figure out okay, here's the

4410
04:15:32.153 --> 04:15:35.153
easiest way for me to get this
number. Awesome. So now we have

4411
04:15:35.153 --> 04:15:39.153
a get price function, which is
going to return a un 256, which

4412
04:15:39.153 --> 04:15:42.153
is going to be the price of
Aetherium. In terms of USD, all

4413
04:15:42.153 --> 04:15:46.153
we need to do is convert the
message dot value from

4414
04:15:46.153 --> 04:15:51.153
Aetherium. To terms of dollars,
let's create this get conversion

4415
04:15:51.153 --> 04:15:54.153
rate function. So this one,
we're going to take an input

4416
04:15:54.153 --> 04:15:58.153
parameter of un 256 of eath
amount, it's going to be a

4417
04:15:58.153 --> 04:16:04.153
public view function. And it's
going to return you went to 56,

4418
04:16:04.153 --> 04:16:08.153
we're going to pass it some eath
amount. And on the other side,

4419
04:16:08.153 --> 04:16:11.153
we're going to get how much that
eath is worth in terms of USD.

4420
04:16:11.153 --> 04:16:16.153
So we're going to do a u
intuity. Six eath price equals

4421
04:16:16.153 --> 04:16:21.153
get price. So first, we're going
to call our get price function

4422
04:16:21.153 --> 04:16:24.153
that we just created to get the
price of Aetherium. Then we're

4423
04:16:24.153 --> 04:16:32.153
going to do u and 256 eath
amount in USD equals eath price

4424
04:16:32.153 --> 04:16:37.153
times eath amount, and then
we're going to divide it by 118.

4425
04:16:37.153 --> 04:16:40.153
When you're doing multiplication
and division math in solidity,

4426
04:16:40.153 --> 04:16:44.153
you always want to multiply and
add first and then go ahead and

4427
04:16:44.153 --> 04:16:48.153
divide since eath price and eath
amount both have 18 additional

4428
04:16:48.153 --> 04:16:52.153
decimal places if we were to
just let them rock without this,

4429
04:16:52.153 --> 04:16:56.154
they would have an additional 36
zeros tax tacked onto the end.

4430
04:16:56.154 --> 04:16:58.154
So we need to divide by one EA
team. Now when we get to the

4431
04:16:58.154 --> 04:17:01.154
hard hat sections of this course
testing all this math is going

4432
04:17:01.154 --> 04:17:04.154
to be a lot easier. And if
you're really struggling with

4433
04:17:04.154 --> 04:17:06.154
some of the math bits right now,
I wouldn't let that slow you

4434
04:17:06.154 --> 04:17:08.154
down. Because once we get to
heart, it's going to become a

4435
04:17:08.154 --> 04:17:12.154
lot easier to actually test this
than working on a test net. And

4436
04:17:12.154 --> 04:17:15.154
this eath amount in terms of USD
is the number that we're looking

4437
04:17:15.154 --> 04:17:20.154
for. So we can just go ahead and
return eath amount in USD, CSB

4438
04:17:20.154 --> 04:17:24.154
returns here, and boom, now we
have a good conversion rate

4439
04:17:24.154 --> 04:17:26.154
function to walk you through the
math real quick. Let's say the

4440
04:17:26.154 --> 04:17:29.154
eath price is going to be
$3,000. So it's going to be

4441
04:17:29.154 --> 04:17:33.154
3000. But it's going to have an
additional 18 zeros tacked on

4442
04:17:33.154 --> 04:17:37.154
the end, it matches the message
dot value way units. And let's

4443
04:17:37.154 --> 04:17:45.154
say for example, we send one
eath or 112345 678-910-1234 5678

4444
04:17:45.154 --> 04:17:51.154
eath into this contract, one
eath should equal $3,000. So to

4445
04:17:51.154 --> 04:17:54.154
get the price, we're going to
now do the eath price, which is

4446
04:17:54.154 --> 04:17:59.154
3000 times the eath amount,
which is this one, and then

4447
04:17:59.154 --> 04:18:02.154
divide by one raised to the
18th. So method out we'll do

4448
04:18:02.154 --> 04:18:09.154
3123 1-234-567-8910 12345678
times we'd

4449
04:18:09.154 --> 04:18:20.154
1001 2345678 1-234-567-8910
times 112345678 1-234-567-8910.

4450
04:18:20.154 --> 04:18:27.154
And now we divide that by
112345678 1-234-567-8910, which

4451
04:18:27.154 --> 04:18:32.154
equals 2.9. Mmm, II 21, which
the calculator kind of messed up

4452
04:18:32.154 --> 04:18:38.155
them a little bit, but 2.9, not
2.99, ie 21 means this has 21

4453
04:18:38.155 --> 04:18:46.155
decimal places. So it'd be
2.1 234-567-8910 1-234-567-8910

4454
04:18:46.155 --> 04:18:53.155
one, or
1-234-567-8910 12345678 2900 I

4455
04:18:53.155 --> 04:18:58.155
9.99 and a nine. And this is
actually exactly the reason why

4456
04:18:58.155 --> 04:19:01.155
we don't do decimal math in
solidity, our calculator saw

4457
04:19:01.155 --> 04:19:04.155
that massive number was having a
hard time getting it. So it

4458
04:19:04.155 --> 04:19:07.155
ended up rounding that number to
2.999. And nine, when we work

4459
04:19:07.155 --> 04:19:11.155
exclusively with whole numbers
in solidity, we don't have a

4460
04:19:11.155 --> 04:19:14.155
chance of losing that precision.
And in solidity, this is going

4461
04:19:14.155 --> 04:19:19.155
to return exactly $3,000, which
is correct one Aetherium at

4462
04:19:19.155 --> 04:19:24.155
$3,000 per Aetherium is going to
be $3,000. And like I said,

4463
04:19:24.155 --> 04:19:26.155
since we're building this
contract, assuming we're going

4464
04:19:26.155 --> 04:19:29.155
to be working on this test net,
we're not going to test this

4465
04:19:29.155 --> 04:19:31.155
function on the test net,
because we're going to have to

4466
04:19:31.155 --> 04:19:34.155
wait for that transaction to go
through. If you want to go ahead

4467
04:19:34.155 --> 04:19:36.155
and deploy this and play around
with it yourself, you're more

4468
04:19:36.155 --> 04:19:39.155
than welcome to Okay, great, now
we have a function called Get

4469
04:19:39.155 --> 04:19:43.155
conversion rate that we can use
on our fund function to make

4470
04:19:43.155 --> 04:19:46.155
sure we've sent enough message
dot value in our fund. So what

4471
04:19:46.155 --> 04:19:50.155
we can do now is all we need to
do is to get conversion rate of

4472
04:19:50.155 --> 04:19:53.155
message dot value needs to be
greater than the minimum USD. Of

4473
04:19:53.155 --> 04:19:57.155
course, right now our minimum
USD is just in terms of 50. And

4474
04:19:57.155 --> 04:20:01.155
we know that conversion rate is
going to return it with 18 zeros

4475
04:20:01.155 --> 04:20:05.155
to represent the decimal places,
our minimum USD amount needs to

4476
04:20:05.155 --> 04:20:12.155
be upgraded to 10 to 50 times
one e 18. Or again, one times

4477
04:20:12.155 --> 04:20:16.156
10, raise the 18th, I'm going to
deploy this to a test net just

4478
04:20:16.156 --> 04:20:19.156
to demonstrate it. But again,
you don't have to if you don't

4479
04:20:19.156 --> 04:20:22.156
want to wait for this. So I'm
gonna go ahead and deploy this

4480
04:20:22.156 --> 04:20:25.156
confirm. And now we have this
funny contract. If I don't say

4481
04:20:25.156 --> 04:20:28.156
anything in value, and hit the
fun button, we're gonna get this

4482
04:20:28.156 --> 04:20:32.156
gas estimation error failed.
This is kind of a blanket error,

4483
04:20:32.156 --> 04:20:34.156
basically saying, Hey, you can
go ahead and send this

4484
04:20:34.156 --> 04:20:36.156
transaction if you want, it's
highly likely that it's not

4485
04:20:36.156 --> 04:20:39.156
going to work. And the reason
that remix knows that it's

4486
04:20:39.156 --> 04:20:42.156
probably not going to work is
because it can see this require

4487
04:20:42.156 --> 04:20:44.156
and simulate the transaction and
say, Hey, you didn't send enough

4488
04:20:44.156 --> 04:20:49.156
money with this. However, even
if we send some money, like 5000

4489
04:20:49.156 --> 04:20:52.156
way, it'll still give us this
error. Because that's not

4490
04:20:52.156 --> 04:20:55.156
enough. Let's do the calculation
right now based on what the

4491
04:20:55.156 --> 04:20:59.156
price of eath is. So we can
actually go to data dot chain

4492
04:20:59.156 --> 04:21:02.156
that link, we look and see
approximately what the price is.

4493
04:21:02.156 --> 04:21:04.156
So it looks like the price of
Aetherium right now is about

4494
04:21:04.156 --> 04:21:07.156
$3,000. And this might be
different for you depending on

4495
04:21:07.156 --> 04:21:10.156
when you do that. So if the
price of Aetherium is $3,000,

4496
04:21:10.156 --> 04:21:15.156
and our minimum is at least 50.
We could do 50 divided by

4497
04:21:15.156 --> 04:21:21.156
3000 0.016 eath should be
approximately enough. So if we

4498
04:21:21.156 --> 04:21:27.156
go to our Aetherium converter,
and we do 0.016, we'll get how

4499
04:21:27.156 --> 04:21:33.156
much that is in way, let's do
0.02 Just to make sure that

4500
04:21:33.156 --> 04:21:36.156
we're going to be over the
amount. So we'll paste that in.

4501
04:21:36.156 --> 04:21:40.156
We'll change this to way. And
now if I hit the fun button,

4502
04:21:40.156 --> 04:21:43.156
instead of us getting that error
popping up, it's going to

4503
04:21:43.156 --> 04:21:46.156
actually go ahead and let us do
the fun function and we could

4504
04:21:46.156 --> 04:21:49.156
confirm it and it wouldn't fail.
I'm going to reject it for now

4505
04:21:49.156 --> 04:21:51.156
just because I don't really feel
like waiting for the transaction

4506
04:21:51.156 --> 04:21:54.156
to go through. But great. We've
confirmed that our get

4507
04:21:54.156 --> 04:21:56.157
conversion rate is one working
as intended, awesome, great

4508
04:21:57.157 --> 04:22:00.157
work.

4509
04:22:00.157 --> 04:22:02.157
So what's the next bit of this
funding contract that we want to

4510
04:22:02.157 --> 04:22:06.157
do? Well, when people actually
send money to this contract, we

4511
04:22:06.157 --> 04:22:09.157
want to keep track of all the
people who send us money. So

4512
04:22:09.157 --> 04:22:12.157
let's create some data
structures. To keep track. Let's

4513
04:22:12.157 --> 04:22:16.157
create an array of addresses
called funders. And we'll keep

4514
04:22:16.157 --> 04:22:20.157
adding all the funders who send
money to us. So we'll say an

4515
04:22:20.157 --> 04:22:25.157
address array, or an address
list. We'll make it public

4516
04:22:25.157 --> 04:22:29.157
funders. And anytime somebody
sends us money, and this

4517
04:22:29.157 --> 04:22:32.157
actually does indeed go through,
we'll add that funded server

4518
04:22:32.157 --> 04:22:37.157
list. So we'll say funders dot
push message dot sender, like

4519
04:22:37.157 --> 04:22:41.157
message dot value. Message dot
sender is an always available

4520
04:22:41.157 --> 04:22:45.157
global keyword message dot value
stands for how much Aetherium or

4521
04:22:45.157 --> 04:22:48.157
how much native blockchain
currency is sent. Message dot

4522
04:22:48.157 --> 04:22:53.157
sender is the address of whoever
calls the font function. So if

4523
04:22:53.157 --> 04:22:56.157
we're on Rigby message dot
sender is going to be equal to

4524
04:22:56.157 --> 04:23:00.157
whatever address is calling that
function. Since our address is

4525
04:23:00.157 --> 04:23:04.157
sending the ether, we're going
to add our address to this

4526
04:23:04.157 --> 04:23:07.157
funders list. This way we can
keep track of all the wonderful

4527
04:23:07.157 --> 04:23:11.157
donators who are donating to our
contract, then maybe we won't

4528
04:23:11.157 --> 04:23:17.157
even make a mapping of addresses
to you and 250 sixes of

4529
04:23:17.157 --> 04:23:20.157
addresses to how much money each
one of these people have

4530
04:23:20.157 --> 04:23:26.157
actually sent. So we'll do
address to you and 256 public

4531
04:23:26.157 --> 04:23:31.157
address to amount funded. And
when somebody funds our contract

4532
04:23:31.157 --> 04:23:36.158
will say address to amount
funded of message dot sender

4533
04:23:36.158 --> 04:23:40.158
equals message dot value. Now we
have a function where people can

4534
04:23:40.158 --> 04:23:44.158
fund our contract. And we can
set a value in terms of USD and

4535
04:23:44.158 --> 04:23:47.158
we keep track of the different
funders who actually fund our

4536
04:23:47.158 --> 04:23:54.158
contract. This is fantastic. Now
I know we've gone over a lot of

4537
04:23:54.158 --> 04:23:57.158
really intense math and intense
stuff here. So so let's do a

4538
04:23:57.158 --> 04:24:00.158
quick refresher of what we've
learned so far. Whenever we work

4539
04:24:00.158 --> 04:24:03.158
with a contract, we always need
the API and the address when

4540
04:24:03.158 --> 04:24:08.158
compiled an interface gives us
that minimalistic API to

4541
04:24:08.158 --> 04:24:12.158
interact with contracts outside
of our project. When you combine

4542
04:24:12.158 --> 04:24:15.158
these compiled interfaces with
an address, we can call the

4543
04:24:15.158 --> 04:24:19.158
functions on that interface on
that contract. chain link. data

4544
04:24:19.158 --> 04:24:22.158
feeds are a decentralized way to
get information about the real

4545
04:24:22.158 --> 04:24:25.158
world. In this case, we're
getting the price of Aetherium

4546
04:24:25.158 --> 04:24:29.158
in terms of USD from a
decentralized collective of

4547
04:24:29.158 --> 04:24:32.158
chain link nodes. When working
with math and solidity. Decimals

4548
04:24:32.158 --> 04:24:35.158
don't work. So we need to keep
that in mind when doing any type

4549
04:24:35.158 --> 04:24:38.158
of math in solidity. And we need
to make sure we always have the

4550
04:24:38.158 --> 04:24:42.158
correct units, so that our math
makes sense. Message dot value,

4551
04:24:42.158 --> 04:24:46.158
and message dot sender, our
globally available variables

4552
04:24:46.158 --> 04:24:49.158
were message dot sender
represents the sender of the

4553
04:24:49.158 --> 04:24:52.158
message or transaction. And
message dot value represents the

4554
04:24:52.158 --> 04:24:55.158
number of ways sent with the
message. There's a whole bunch

4555
04:24:55.158 --> 04:24:58.158
of different special variables
and functions that we can access

4556
04:24:58.158 --> 04:25:00.158
at any time. And these are
available in the solidity

4557
04:25:00.158 --> 04:25:06.158
documentation. Alright, great,
we've got a great way that we

4558
04:25:06.158 --> 04:25:09.158
can actually start funding our
contract. But our code looks a

4559
04:25:09.158 --> 04:25:11.158
little bit messy, we've got a
couple of different functions

4560
04:25:11.158 --> 04:25:14.158
for getting the price and
working with these prices, is

4561
04:25:14.158 --> 04:25:17.159
there a way to make this math a
lot easier to use, this is where

4562
04:25:17.159 --> 04:25:21.159
we're going to introduce the
concept of a library. So what is

4563
04:25:21.159 --> 04:25:23.159
a library, I definitely
recommend checking out solidity

4564
04:25:23.159 --> 04:25:27.159
by example.org, as you're going
along with this course, as well,

4565
04:25:27.159 --> 04:25:30.159
they've got some fantastic
examples. One of such example is

4566
04:25:30.159 --> 04:25:33.159
going to be about libraries,
libraries are similar to

4567
04:25:33.159 --> 04:25:35.159
contracts. But you can't declare
any state variables and you

4568
04:25:35.159 --> 04:25:39.159
can't send ether. We can also
use libraries to add more

4569
04:25:39.159 --> 04:25:43.159
functionality to different
values. What do I mean by that?

4570
04:25:43.159 --> 04:25:47.159
Well, what we can do actually is
we can have get conversion rate

4571
04:25:47.159 --> 04:25:53.159
be a function of a un 256. So we
could do something like Messer

4572
04:25:53.159 --> 04:25:59.159
dot value dot get convert John,
conversion rate. And we can add

4573
04:25:59.159 --> 04:26:03.159
functions as if you went to 36
was an object or a struct or a

4574
04:26:03.159 --> 04:26:06.159
contract that we actually
created. So how do we do this?

4575
04:26:06.159 --> 04:26:10.159
Well, let's create a new
contract in our contracts folder

4576
04:26:10.159 --> 04:26:12.159
and create a new file. We're
going to call it price

4577
04:26:12.159 --> 04:26:17.159
converter, dot salt. And our
price converted outsole is going

4578
04:26:17.159 --> 04:26:21.159
to be a library that we're going
to attach to a un 256. So how do

4579
04:26:21.159 --> 04:26:24.159
you actually create a library
and what is a library? Well, a

4580
04:26:24.159 --> 04:26:27.159
library is going to be really,
really similar to a smart

4581
04:26:27.159 --> 04:26:34.159
contract. It's gonna start with
spdx license identifier. My

4582
04:26:34.159 --> 04:26:40.159
team, we're gonna give it a
pragma, solidity zero point 8.0.

4583
04:26:40.159 --> 04:26:43.159
And instead of typing contract
for the name of the contract,

4584
04:26:43.159 --> 04:26:46.159
we're going to do library for
the name of the library. We're

4585
04:26:46.159 --> 04:26:49.159
going to call it price
converter. Now libraries can't

4586
04:26:49.159 --> 04:26:52.159
have any state variables and
they also can't send ether and

4587
04:26:52.159 --> 04:26:55.159
all the functions in a library
are going to be in there.

4588
04:26:55.159 --> 04:26:59.160
kernel. So what we can do is we
can go back to fund me dot soul,

4589
04:26:59.160 --> 04:27:04.160
we can grab get price, get
version and get conversion rate,

4590
04:27:04.160 --> 04:27:08.160
copy them all, delete them from
Funmi dot soul and paste them

4591
04:27:08.160 --> 04:27:11.160
into our library. And of course,
since we're using aggregator v3

4592
04:27:11.160 --> 04:27:17.160
interface in here, we can also
copy the import from Funmi. And

4593
04:27:17.160 --> 04:27:19.160
since we're not using the
aggregate of three interface and

4594
04:27:19.160 --> 04:27:23.160
our contract anymore, and we're
using our price converter, we

4595
04:27:23.160 --> 04:27:26.160
can paste it into our price
converter. Now, if we compile

4596
04:27:26.160 --> 04:27:30.160
price converted at soul, we see
that it actually passes. Now all

4597
04:27:30.160 --> 04:27:33.160
the functions inside of our
library need to be internal. And

4598
04:27:33.160 --> 04:27:36.160
we're gonna make this library
price converter different

4599
04:27:36.160 --> 04:27:40.160
functions, we can call on you
activity six, for example, we're

4600
04:27:40.160 --> 04:27:42.160
going to be able to do message
dot value dot get conversion

4601
04:27:42.160 --> 04:27:46.160
rate, we're going to directly be
able to get the conversion rate

4602
04:27:46.160 --> 04:27:50.160
of a value of a U and 256 as if
that was a function for it the

4603
04:27:50.160 --> 04:27:54.160
whole time. So first, let's make
this internal. Let's make get

4604
04:27:54.160 --> 04:27:57.160
conversion rate internal. And
we'll make good version

4605
04:27:57.160 --> 04:28:00.160
internal. Now that we have this
library price converter back in

4606
04:28:00.160 --> 04:28:04.160
our Funmi, we can now import
this price converter and attach

4607
04:28:04.160 --> 04:28:08.160
it to you in 256. So we'll do
import that slash price

4608
04:28:08.160 --> 04:28:11.160
converter, dot soul.

4609
04:28:11.160 --> 04:28:19.160
And in Funmi, we'll do using
price converter for UNT 256. Of

4610
04:28:19.160 --> 04:28:23.160
course, if we compile our Funmi.
Now, this line is getting an

4611
04:28:23.160 --> 04:28:26.160
issue because saying hey, get
conversion rate isn't defined.

4612
04:28:26.160 --> 04:28:31.160
Now in our library, the first
variable that gets passed to the

4613
04:28:31.160 --> 04:28:33.160
function is going to be the
object that it's called on

4614
04:28:33.160 --> 04:28:37.161
itself. So in Funmi dot soul,
let's go ahead and comment out

4615
04:28:37.161 --> 04:28:40.161
this line for now. If we do
message dot value dot get

4616
04:28:40.161 --> 04:28:44.161
conversion rate, this is
secretly the same as we did get

4617
04:28:44.161 --> 04:28:47.161
conversion rate or message dot
value in our price converter

4618
04:28:47.161 --> 04:28:50.161
library, the message dot value
is going to be passed as the

4619
04:28:50.161 --> 04:28:53.161
input parameter to get
conversion rate, forget price

4620
04:28:53.161 --> 04:28:56.161
and get version we don't really
care about the number. So we're

4621
04:28:56.161 --> 04:29:00.161
just going to leave it blank for
now. So instead of require get

4622
04:29:00.161 --> 04:29:05.161
conversion rate of message dot
value, we can now do message dot

4623
04:29:05.161 --> 04:29:11.161
value dot get conversion rate.
And compile that you'll see that

4624
04:29:11.161 --> 04:29:14.161
here we're not passing a
variable, even though our get

4625
04:29:14.161 --> 04:29:17.161
conversion rate function says
hey, I'm expecting a variable.

4626
04:29:17.161 --> 04:29:20.161
Again, the reason for this is,
is this message add value is

4627
04:29:20.161 --> 04:29:23.161
considered the first parameter
for any of these library

4628
04:29:23.161 --> 04:29:26.161
functions. And that's how it
works. If we wanted another

4629
04:29:26.161 --> 04:29:32.161
variable in here, like you went
to 56, something else. Now we

4630
04:29:32.161 --> 04:29:37.161
would want to pass something
else in here 123. And this 123

4631
04:29:37.161 --> 04:29:39.161
would get assigned to this
something else. But we're going

4632
04:29:39.161 --> 04:29:44.161
to delete that for now. Okay,
great. And in doing that, we've

4633
04:29:44.161 --> 04:29:48.161
minimized our Funmi contract a
lot by moving a lot of that math

4634
04:29:48.161 --> 04:29:52.161
and price conversion stuff into
our price converter library dot

4635
04:29:52.161 --> 04:29:57.161
Sol. One of the most common
libraries that was used for the

4636
04:29:57.161 --> 04:30:02.161
longest time was this library
called Safe math dot Sol. And

4637
04:30:02.161 --> 04:30:05.161
you'll probably see it a lot of
different places, we're gonna go

4638
04:30:05.161 --> 04:30:08.161
off on a quick little tangent
here and teach you about safe

4639
04:30:08.161 --> 04:30:11.161
math. So let's close Funmi close
price converter. And let's

4640
04:30:11.161 --> 04:30:17.162
create a new file called Safe
math tester. That's all. And

4641
04:30:17.162 --> 04:30:20.162
let's start with some basic
stuff in here. Safe math was all

4642
04:30:20.162 --> 04:30:24.162
over the place before version
0.8 of solidity. And now it's

4643
04:30:24.162 --> 04:30:28.162
almost in no contracts. What
happened, why is safe math no

4644
04:30:28.162 --> 04:30:32.162
longer used as much? Well, let's
create a sample contract. This

4645
04:30:32.162 --> 04:30:34.162
is a section that you don't have
to follow along if you don't

4646
04:30:34.162 --> 04:30:38.162
want to code along with me. But
if you want to you absolutely

4647
04:30:38.162 --> 04:30:40.162
still can. This is going to be a
contract we are going to deploy

4648
04:30:40.162 --> 04:30:44.162
on a JavaScript virtual machine,
we can use any version of

4649
04:30:44.162 --> 04:30:48.162
solidity before version 0.8 of
solidity. So for example, we use

4650
04:30:48.162 --> 04:30:54.162
pragma, carrot, zero, point 6.0.
And we'll create contract safe

4651
04:30:54.162 --> 04:31:00.162
math tester, dot Sol. Now if I
create a you int eight, I set it

4652
04:31:00.162 --> 04:31:06.162
to public big number. And I set
this to 255 Oops safe math

4653
04:31:06.162 --> 04:31:11.162
tester. Let's go ahead and
compile safe math tester with

4654
04:31:11.162 --> 04:31:17.162
zero point 6.7 pragma, solidity,
the maximum size of a Yewande

4655
04:31:17.162 --> 04:31:21.162
eight is going to be 255. This
is going to be the biggest

4656
04:31:21.162 --> 04:31:24.162
number that we can fit in the
new int eight. And if I were to

4657
04:31:24.162 --> 04:31:29.162
deploy this to a JavaScript VM
or even a test network, safe

4658
04:31:29.162 --> 04:31:34.162
math tester, let's go ahead to
play up. If I hit big number,

4659
04:31:34.162 --> 04:31:39.162
we're gonna get 255. Well, what
happens if I create a function

4660
04:31:39.162 --> 04:31:46.162
called ADD? That sets big number
equal to big number plus one?

4661
04:31:46.162 --> 04:31:50.162
Let's save that. Delete that old
contract and deploy. All right

4662
04:31:50.162 --> 04:31:56.162
now big numbers 255 What happens
when we add one two? big number.

4663
04:31:56.162 --> 04:32:01.163
When 255 is the max size a, UNT
eight can be? Well, let's hit

4664
04:32:01.163 --> 04:32:06.163
add. Now let's check what big
number is. Big number gets reset

4665
04:32:06.163 --> 04:32:10.163
to zero. So what's going on?
Well, prior to version 0.8, of

4666
04:32:10.163 --> 04:32:14.163
solidity, unsigned integers and
integers ran on this concept of

4667
04:32:14.163 --> 04:32:18.163
being unchecked, which means
that if you passed the upper

4668
04:32:18.163 --> 04:32:22.163
limit of a number, it would just
wrap around and start back from

4669
04:32:22.163 --> 04:32:25.163
the lowest number it could be.
So if I call add a whole bunch

4670
04:32:25.163 --> 04:32:28.163
more times, and hit big number,
now let's say if I were to hit

4671
04:32:28.163 --> 04:32:33.163
this add button a ton more times
and get it back to two and a 55.

4672
04:32:33.163 --> 04:32:36.163
It would then continue to wrap
over to zero. So one of the most

4673
04:32:36.163 --> 04:32:39.163
popular libraries that was out
there was this safe math

4674
04:32:39.163 --> 04:32:43.163
library, which would basically
check to make sure that you

4675
04:32:43.163 --> 04:32:47.163
weren't wrapping around a un 256
or an intuitive six, basically,

4676
04:32:47.163 --> 04:32:50.163
it was a way to say, hey, you've
reached the max this number can

4677
04:32:50.163 --> 04:32:54.163
be and now your transaction is
going to fail. If we switch this

4678
04:32:54.163 --> 04:33:00.163
to 0.8, of solidity, delete the
old contract, go switch this to

4679
04:33:00.163 --> 04:33:05.163
0.8. We'll go ahead and compile
it. And now we deploy this to

4680
04:33:05.163 --> 04:33:07.163
JavaScript VM.

4681
04:33:07.163 --> 04:33:11.163
If I hit big number, we get to
under 55. But if we hit Add, it

4682
04:33:11.163 --> 04:33:16.163
actually fails. And we still get
to under 55. In version 0.8, in

4683
04:33:16.163 --> 04:33:19.163
solidity, they added this bit,
where it automatically checks to

4684
04:33:19.163 --> 04:33:22.163
make sure if you're going to do
what's called overflow or

4685
04:33:22.163 --> 04:33:26.163
underflow on a variable, we can
actually revert back to the

4686
04:33:26.163 --> 04:33:30.163
unchecked version by using an
unchecked keyword. So if we wrap

4687
04:33:30.163 --> 04:33:33.163
this big number equals big
number plus one in this

4688
04:33:33.163 --> 04:33:38.164
unchecked bracket, let's delete
our old contract will compile

4689
04:33:38.164 --> 04:33:42.164
will redeploy. We had big
numbers to 55. Now we hit add,

4690
04:33:42.164 --> 04:33:47.164
we hit big number again, it
reverted back to zero. So that's

4691
04:33:47.164 --> 04:33:50.164
a little bit more about safe
math, checked and unchecked. So

4692
04:33:50.164 --> 04:33:54.164
in version 0.76, and below this
code that you see in front of

4693
04:33:54.164 --> 04:34:00.164
you, is going to be the exact
same as this code in 0.8. And

4694
04:34:00.164 --> 04:34:02.164
above with this unchecked
keyword. Now you might be

4695
04:34:02.164 --> 04:34:06.164
thinking in newer versions of
solidity, why would I use this

4696
04:34:06.164 --> 04:34:10.164
unchecked keyword? Well, you'll
find out later that this

4697
04:34:10.164 --> 04:34:14.164
unchecked keyword makes your
code a little bit more gas

4698
04:34:14.164 --> 04:34:16.164
efficient. So if you're
absolutely positive that your

4699
04:34:16.164 --> 04:34:19.164
math is never going to reach the
top or bottom limits of a

4700
04:34:19.164 --> 04:34:22.164
number, that it might make sense
for you to use the unchecked

4701
04:34:22.164 --> 04:34:26.164
keyword. Let's head back over to
our Funmi contract, where we are

4702
04:34:26.164 --> 04:34:31.164
now using the price converter
library that we just created.

4703
04:34:31.164 --> 04:34:34.164
Alright, great. So now we've got
a pretty minimalistic contract

4704
04:34:34.164 --> 04:34:37.164
here for actually doing the
funding. And we have all of our

4705
04:34:37.164 --> 04:34:42.164
math for getting conversion
rates done in our library price

4706
04:34:42.164 --> 04:34:45.164
converter, which we're going to
import at the top of Funmi.

4707
04:34:45.164 --> 04:34:49.164
Cool. So at this point, we've
got our fun method. Awesome. And

4708
04:34:49.164 --> 04:34:53.164
so we can allow anybody to go
ahead and fund this contract and

4709
04:34:53.164 --> 04:34:58.164
send this contract Aetherium, or
any native blockchain currency

4710
04:34:58.164 --> 04:35:01.164
to this contract. Well, now what
do we want to do? Well, once all

4711
04:35:01.164 --> 04:35:04.164
the funders have gone ahead and
funded, we're going to want the

4712
04:35:04.164 --> 04:35:08.164
project to be able to withdraw
the funds out of this contract.

4713
04:35:08.164 --> 04:35:12.164
So they can actually go ahead
and use those funds to buy

4714
04:35:12.164 --> 04:35:16.164
things for this project. So
let's go ahead and create a

4715
04:35:16.164 --> 04:35:20.165
withdrawal function. So we'll
create a function withdraw. And

4716
04:35:20.165 --> 04:35:23.165
we'll make this public. Since
we're going to be withdrawing

4717
04:35:23.165 --> 04:35:26.165
all the funds out of this
contract, we probably also want

4718
04:35:26.165 --> 04:35:31.165
to reset our funders array, and
our address to amount funded.

4719
04:35:31.165 --> 04:35:35.165
Since we'll be withdrawing all
the funds, those amounts should

4720
04:35:35.165 --> 04:35:39.165
go back down to zero. So let's
go ahead and loop through the

4721
04:35:39.165 --> 04:35:42.165
funders array and update our
mapping object so that each of

4722
04:35:42.165 --> 04:35:46.165
these funders now has zero,
because in just a second, we're

4723
04:35:46.165 --> 04:35:51.165
going to withdraw all the money
from them. So to do this, we're

4724
04:35:51.165 --> 04:35:54.165
going to use something called a
for loop. So what is a for loop?

4725
04:35:54.165 --> 04:35:57.165
A for loop is a way to loop
through some type of index

4726
04:35:57.165 --> 04:36:01.165
object or loop through some
range of numbers or just do a

4727
04:36:01.165 --> 04:36:05.165
task a certain amount of times
repeating. So for example, let's

4728
04:36:05.165 --> 04:36:12.165
say we have an array or list.
And on that list, we have 1234.

4729
04:36:12.165 --> 04:36:16.165
If we wanted to get all of the
elements in this array, or in

4730
04:36:16.165 --> 04:36:22.165
this list, okay, 1234. How do we
get all the elements in this

4731
04:36:22.165 --> 04:36:28.165
list? Well, we would use a for
loop to loop through each one of

4732
04:36:28.165 --> 04:36:33.165
these objects. So at zero with
index would be one at the first

4733
04:36:33.165 --> 04:36:37.165
index would be two, and at the
second index would be three, at

4734
04:36:37.165 --> 04:36:40.165
the last index would be four. So
we would loop through the

4735
04:36:40.165 --> 04:36:45.165
indexes zero through three to
get all these elements. Or maybe

4736
04:36:45.165 --> 04:36:51.165
another example is if this was
A, B, C, D, A is at the zero

4737
04:36:51.165 --> 04:36:55.165
with index B is at the first
index sees the second Indy's at

4738
04:36:55.165 --> 04:36:59.166
the third and we will loop zero
through three. To get to each

4739
04:36:59.166 --> 04:37:02.166
one of these elements, we're
gonna do that exact same thing.

4740
04:37:02.166 --> 04:37:06.166
But with the funders array. So
how do we actually do that?

4741
04:37:06.166 --> 04:37:11.166
Well, we first start with the
for keyword, the for keyword

4742
04:37:11.166 --> 04:37:14.166
says, Okay, we're about to start
a loop. And inside of these

4743
04:37:14.166 --> 04:37:18.166
parentheses, we define how we
want to loop through it. Also

4744
04:37:18.166 --> 04:37:21.166
backslash star, and star
backslash is sort of like

4745
04:37:21.166 --> 04:37:26.166
brackets for comments. Anything
in between these two will be a

4746
04:37:26.166 --> 04:37:29.166
comment. So in a for loop,
first, we give it the starting

4747
04:37:29.166 --> 04:37:34.166
index, then we give it the
ending index, and then we give

4748
04:37:34.166 --> 04:37:39.166
it the step amount. For example,
maybe we want to start with

4749
04:37:39.166 --> 04:37:43.166
zero, we want to go to 10. And
we want to go up by one each

4750
04:37:43.166 --> 04:37:47.166
time. So we would go
01 234-567-8910. Or maybe we

4751
04:37:47.166 --> 04:37:51.166
start at zero, we want to end at
10. And we go up by two each

4752
04:37:51.166 --> 04:37:57.166
time. So we'd go 02468 10. Or
maybe we want to go from zero to

4753
04:37:57.166 --> 04:38:02.166
five, we want to go from two to
five, with a step of one, we'd

4754
04:38:02.166 --> 04:38:08.166
go 2345, etc. So this is what's
going to go inside of this four

4755
04:38:08.166 --> 04:38:12.166
bit here. So for our starting
index, and let me even just put

4756
04:38:12.166 --> 04:38:14.166
this above so that you can
reference it. So our starting

4757
04:38:14.166 --> 04:38:17.166
index is going to be you in to
VT six variable, and we're going

4758
04:38:17.166 --> 04:38:21.166
to call it funder index. And
we're going to start with

4759
04:38:21.166 --> 04:38:25.166
thunder index being equal to
zero. So we're starting with

4760
04:38:25.166 --> 04:38:29.166
zero here. And we're going to
end with the length of our

4761
04:38:30.166 --> 04:38:33.166
funders array, since we want to
loop through all of the funders.

4762
04:38:33.166 --> 04:38:40.167
So we're going to say, funder
index needs to be less than

4763
04:38:40.167 --> 04:38:44.167
funders dot length. So our
ending index is going to be

4764
04:38:44.167 --> 04:38:49.167
whenever funders index is no
longer less than funders dot

4765
04:38:49.167 --> 04:38:54.167
length. And then finally, we're
gonna say funder index equals

4766
04:38:54.167 --> 04:39:00.167
funder index, plus one, which
means that every time the code

4767
04:39:00.167 --> 04:39:03.167
inside of this loop finishes,
we're going to increase funder

4768
04:39:03.167 --> 04:39:07.167
index by one. That's how we go
from zero to one to two to three

4769
04:39:07.167 --> 04:39:11.167
to four to five, etc. Another
way you can type funder index

4770
04:39:11.167 --> 04:39:15.167
equals funder index plus one is
you can just do funder index

4771
04:39:15.167 --> 04:39:21.167
plus plus, this plus plus syntax
means funder index equals itself

4772
04:39:21.167 --> 04:39:25.167
plus one. So let's start looping
through our funders array to

4773
04:39:25.167 --> 04:39:28.167
access the the zero with element
or the first element, we're

4774
04:39:28.167 --> 04:39:34.167
going to say, funders of funder
index. So we're saying we want

4775
04:39:34.167 --> 04:39:38.167
to access the zero with element
of our funders object. And this

4776
04:39:38.167 --> 04:39:41.167
is going to return an address
for us to use, we're gonna go

4777
04:39:41.167 --> 04:39:48.167
ahead and say address under
equals funders at the funder

4778
04:39:48.167 --> 04:39:52.167
index. So now we have this
funder address. And we want to

4779
04:39:52.167 --> 04:39:58.167
use this to reset our mapping.
So we're going to say, address

4780
04:39:58.167 --> 04:40:07.167
to amount funded at at the
funder key is now equal to zero.

4781
04:40:07.167 --> 04:40:13.167
Because remember, in fund we
update the amount. Whenever we

4782
04:40:13.167 --> 04:40:17.168
fund the contract, when we
withdraw the money from the

4783
04:40:17.168 --> 04:40:21.168
contract, we're going to reset
it back to zero. Now let's walk

4784
04:40:21.168 --> 04:40:25.168
through this funder index starts
from zero. So we're going to get

4785
04:40:25.168 --> 04:40:29.168
the zero with funder, we're
going to grab that funder at the

4786
04:40:29.168 --> 04:40:32.168
zero with index and we're going
to reset the address to male

4787
04:40:32.168 --> 04:40:36.168
funded of that funder to zero,
then this for loop is going to

4788
04:40:36.168 --> 04:40:40.168
update by one, it's going to
move from zero to one, it's

4789
04:40:40.168 --> 04:40:44.168
going to check then if funder
index is less than the length,

4790
04:40:44.168 --> 04:40:47.168
let's say funders has 10 people
in it. If funders has 10 people

4791
04:40:47.168 --> 04:40:51.168
in it, it'll still be less. So
now funder links will be one

4792
04:40:51.168 --> 04:40:55.168
address funder will equal
funders of one now instead of

4793
04:40:55.168 --> 04:40:59.168
zero, and we'll grab that
address, and we'll reset that

4794
04:40:59.168 --> 04:41:03.168
addresses about funded to zero,
then we'll continue to two to

4795
04:41:03.168 --> 04:41:07.168
three to four all the way up to
the length of our funders array.

4796
04:41:07.168 --> 04:41:10.168
And this is how we can loop
through our objects. So saying

4797
04:41:10.168 --> 04:41:14.168
this middle one is the ending
index isn't exactly right, since

4798
04:41:14.168 --> 04:41:17.168
we're really checking for a
boolean to see if this is still

4799
04:41:17.168 --> 04:41:21.168
true, but hopefully you get the
idea. So we've reset the

4800
04:41:21.168 --> 04:41:24.168
balances of the mapping.
However, we still haven't done

4801
04:41:24.168 --> 04:41:28.168
two things, we still need to
reset the array to make the

4802
04:41:28.168 --> 04:41:33.168
funders a blank array. And then
we also need to actually

4803
04:41:33.168 --> 04:41:39.168
withdraw the funds. Since when
we funded this, we sent message

4804
04:41:39.168 --> 04:41:45.168
dot value along with calling
this fund function. However, we

4805
04:41:45.168 --> 04:41:48.168
didn't actually withdraw the
funds. So to reset the array, we

4806
04:41:48.168 --> 04:41:54.168
could loop through it and delete
objects from this address array.

4807
04:41:54.168 --> 04:41:57.169
Or we could Just totally refresh

4808
04:41:57.169 --> 04:42:03.169
this variable. So instead of
looping through the array and

4809
04:42:03.169 --> 04:42:08.169
deleting objects, we're just
going to say funders equals a

4810
04:42:08.169 --> 04:42:13.169
new address array, we're going
to completely reset the array by

4811
04:42:13.169 --> 04:42:19.169
saying this font is variable now
equals a brand new address array

4812
04:42:19.169 --> 04:42:23.169
with zero objects in it to
start, if we were to put a one

4813
04:42:23.169 --> 04:42:26.169
here, this would be there'll be
one element to start in the

4814
04:42:26.169 --> 04:42:30.169
array, two would be two, three
would be three, etc, we're just

4815
04:42:30.169 --> 04:42:43.169
going to start it as a
completely blank new array. So

4816
04:42:43.169 --> 04:42:46.169
great, we've gone ahead and
reset the array. But how do we

4817
04:42:46.169 --> 04:42:50.169
actually now with draw funds
from this contract? How do we

4818
04:42:50.169 --> 04:42:55.169
send the funds back to whomever
is calling this now to actually

4819
04:42:55.169 --> 04:42:59.169
send ether or send native
blockchain currency, there are

4820
04:42:59.169 --> 04:43:02.169
actually three different ways to
do this, we're going to look at

4821
04:43:02.169 --> 04:43:06.169
all three, and say what the
differences between the three of

4822
04:43:06.169 --> 04:43:10.169
them are, the three different
ways are going to be transfer,

4823
04:43:10.169 --> 04:43:15.169
send, and call. Let's go ahead
and start with transfer. Since

4824
04:43:15.169 --> 04:43:19.169
transfer is the simplest and at
surface level makes the most

4825
04:43:19.169 --> 04:43:23.169
sense to us. So if we want to
transfer the funds to whomever

4826
04:43:23.169 --> 04:43:27.169
is calling this withdrawal
function, we would do we would

4827
04:43:27.169 --> 04:43:32.169
say message dot sender, dot
transfer. And then we'd get the

4828
04:43:32.169 --> 04:43:39.170
balance of our contract here by
saying address this, this

4829
04:43:39.170 --> 04:43:44.170
keyword refers to this whole
contract dot balance, and we can

4830
04:43:44.170 --> 04:43:46.170
get the native blockchain
currency or the Aetherium

4831
04:43:46.170 --> 04:43:49.170
currency balance of this address
like this. And we can just do

4832
04:43:49.170 --> 04:43:53.170
that only thing that we need to
do is we need to cast we need to

4833
04:43:53.170 --> 04:44:00.170
typecast message dot sender from
an address type to a payable

4834
04:44:00.170 --> 04:44:08.170
address type. So message dot
sender is of type address.

4835
04:44:08.170 --> 04:44:14.170
Whereas payable, message that
sender is of type, payable

4836
04:44:14.170 --> 04:44:17.170
address, and in solidity in
order to send the native

4837
04:44:17.170 --> 04:44:21.170
blockchain token like Aetherium,
you can only work with payable

4838
04:44:21.170 --> 04:44:25.170
addresses. To do that, we just
wrap it in this payable type

4839
04:44:25.170 --> 04:44:29.170
caster. So this is the first way
that we actually send Aetherium

4840
04:44:29.170 --> 04:44:33.170
or send tokens from different
contracts to each other, we wrap

4841
04:44:33.170 --> 04:44:37.170
the address that we want to send
it in, in this payable keyword,

4842
04:44:37.170 --> 04:44:41.170
we do dot transfer, and then we
say exactly how much we want to

4843
04:44:41.170 --> 04:44:45.170
transfer. But there are some
issues with transfer. Here we

4844
04:44:45.170 --> 04:44:50.170
are on solidity by example, for
sending ether, which, again is a

4845
04:44:50.170 --> 04:44:54.170
fantastic resource to refer to,
if you get lost, the method that

4846
04:44:54.170 --> 04:44:59.170
we just looked at was this
transfer method. Now we saw way

4847
04:44:59.170 --> 04:45:04.170
earlier in the course, that if I
sent Aetherium, from one address

4848
04:45:04.170 --> 04:45:10.170
to another, it cost about 2100
gas or 2100. Gas, our transfer

4849
04:45:10.170 --> 04:45:16.170
function is capped at 2300 gas.
And if more gas is used, it

4850
04:45:16.170 --> 04:45:19.171
throws an error. The next one
that we're using is going to be

4851
04:45:19.171 --> 04:45:24.171
sent which is also capped at
2300 gas. And if it fails, it'll

4852
04:45:24.171 --> 04:45:28.171
return a Boolean. So with
transfer, if this line fails,

4853
04:45:28.171 --> 04:45:32.171
it'll air and revert the
transaction with send, it won't

4854
04:45:32.171 --> 04:45:36.171
air, it'll return a boolean of
whether or not it was

4855
04:45:36.171 --> 04:45:42.171
successful. So using send will
do payable message that sender

4856
04:45:42.171 --> 04:45:50.171
that send address this balance.
But we don't want to finish our

4857
04:45:50.171 --> 04:45:54.171
call here. If this were to fail,
the contract wouldn't revert the

4858
04:45:54.171 --> 04:45:58.171
transaction, and we just want to
get our money sent. So we want

4859
04:45:58.171 --> 04:46:05.171
to do Boolean send success
equals this whole bit here. And

4860
04:46:05.171 --> 04:46:11.171
then we want to require success.
And if this send fails will

4861
04:46:11.171 --> 04:46:15.171
throw an error saying sin
failed.

4862
04:46:15.171 --> 04:46:20.171
This way, if this fails, we will
still revert by adding our

4863
04:46:20.171 --> 04:46:23.171
require statement here. Transfer
automatically reverts if the

4864
04:46:23.171 --> 04:46:28.171
transfer fails, send will only
revert the transaction if we add

4865
04:46:28.171 --> 04:46:32.171
this require statement here. So
great. What's the third way that

4866
04:46:32.171 --> 04:46:36.171
we can actually send Etherium or
native currency wallets with

4867
04:46:36.171 --> 04:46:40.171
this call command. Now call is
going to be one of the first

4868
04:46:40.171 --> 04:46:43.171
lower level commands that we
actually use in our solidity

4869
04:46:43.171 --> 04:46:48.171
code, because this call function
is actually incredibly powerful.

4870
04:46:48.171 --> 04:46:53.171
And we can use it to call
virtually any function in all of

4871
04:46:53.171 --> 04:46:57.171
Aetherium without even having to
Have the API we'll learn the

4872
04:46:57.171 --> 04:47:00.172
advanced ways to use this call
much later. For now, we're just

4873
04:47:00.172 --> 04:47:03.172
going to learn how to use it to
send Aetherium, or your native

4874
04:47:03.172 --> 04:47:07.172
blockchain currency call is
going to look very similar to

4875
04:47:07.172 --> 04:47:14.172
send, we're going to do payable,
message dot sender, dot call.

4876
04:47:14.172 --> 04:47:18.172
And this is where we will put
any function information or any

4877
04:47:18.172 --> 04:47:21.172
information about the function,
we want to call on some other

4878
04:47:21.172 --> 04:47:24.172
contract, we actually don't want
to call a function. So we're

4879
04:47:24.172 --> 04:47:26.172
going to leave this blank, we
can show that we're leaving it

4880
04:47:27.172 --> 04:47:30.172
blank by just putting in these
two quotes here, we instead want

4881
04:47:30.172 --> 04:47:34.172
to use this like a transaction.
And as we saw in our deployment,

4882
04:47:34.172 --> 04:47:38.172
there's always this message dot
value bid, we're going to use

4883
04:47:38.172 --> 04:47:41.172
this call function as if it's a
regular transaction, and we can

4884
04:47:41.172 --> 04:47:45.172
add stuff like message dot
value. So in here, we're going

4885
04:47:45.172 --> 04:47:52.172
to add these squiggly brackets.
And we're going to say, value

4886
04:47:52.172 --> 04:48:00.172
address this dot balance, this
call function returns actually

4887
04:48:00.172 --> 04:48:03.172
two variables. And when a
function returns two variables,

4888
04:48:03.172 --> 04:48:07.172
we can show that by placing them
into parentheses on the left

4889
04:48:07.172 --> 04:48:10.172
hand side, the two variables, it
returns are going to be a

4890
04:48:10.172 --> 04:48:15.172
Boolean, that we're going to
call call success. And also a

4891
04:48:15.172 --> 04:48:20.172
bytes object called data
returned, since call allows us

4892
04:48:20.172 --> 04:48:23.172
to actually call different
functions. If that function

4893
04:48:23.172 --> 04:48:28.172
returns some data or returns
value, we're going to save that

4894
04:48:28.172 --> 04:48:32.172
in the data returned variable.
It also returns call success,

4895
04:48:32.172 --> 04:48:36.172
where if the function was
successfully called this will be

4896
04:48:36.172 --> 04:48:41.173
true. If not, this will be
false. And since bytes objects

4897
04:48:41.173 --> 04:48:46.173
are arrays, data returns needs
to be in memory. Now for our

4898
04:48:46.173 --> 04:48:49.173
code here, we're actually not
calling a function, so we don't

4899
04:48:49.173 --> 04:48:53.173
really care about data returned.
So similar to what we saw with

4900
04:48:53.173 --> 04:48:57.173
the price contract, we can just
go ahead and delete that and

4901
04:48:57.173 --> 04:49:00.173
leave the comma to tell solidity
Yeah, we know this function

4902
04:49:00.173 --> 04:49:03.173
returns two variables, but we
only care about one. And then

4903
04:49:03.173 --> 04:49:08.173
similar to the centerpiece
above, we're going to do require

4904
04:49:08.173 --> 04:49:12.173
cost access call failed, meaning
that we're requiring cost

4905
04:49:12.173 --> 04:49:16.173
accesses true. Otherwise, we'll
revert with an error that says

4906
04:49:16.173 --> 04:49:19.173
call failed. Now of learning the
difference between these three

4907
04:49:19.173 --> 04:49:22.173
is a little complicated for you
right now. Don't let that slow

4908
04:49:22.173 --> 04:49:26.173
you down. Feel free to come back
to this after you've learned

4909
04:49:26.173 --> 04:49:28.173
more about how some of these
lower level functions work. And

4910
04:49:28.173 --> 04:49:32.173
a little bit more about how
gasworks solidity by example,

4911
04:49:32.173 --> 04:49:35.173
does a fantastic job though of
saying what the difference is

4912
04:49:35.173 --> 04:49:39.173
between all three, our transfer
has a maximum of 2300 gas and

4913
04:49:39.173 --> 04:49:44.173
throws an error if it fails,
send has a maximum of 2300 gas

4914
04:49:44.173 --> 04:49:48.173
returns a Boolean, if it fails,
call forwards all gas so doesn't

4915
04:49:48.173 --> 04:49:54.173
have a capped gas. And similar
to send returns a Boolean, if it

4916
04:49:54.173 --> 04:49:59.173
is successful, or if it fails,
As of recording right now using

4917
04:49:59.173 --> 04:50:04.173
call is the recommended way to
actually send and receive

4918
04:50:04.173 --> 04:50:07.173
Aetherium or your blockchain
native token for now, if this

4919
04:50:07.173 --> 04:50:10.173
part's a little bit confusing
for you, for now, just look at

4920
04:50:10.173 --> 04:50:14.173
this and see ah, that's how we
send and transfer Aetherium or

4921
04:50:14.173 --> 04:50:18.174
native blockchain currency
tokens. And I'm going to delete

4922
04:50:18.174 --> 04:50:21.174
this part for the video, but
I'll keep those comments in the

4923
04:50:21.174 --> 04:50:28.174
code repository associated with
this course. And okay, perfect.

4924
04:50:28.174 --> 04:50:32.174
If we hit compile a fun meat
outsole, we do indeed see that

4925
04:50:32.174 --> 04:50:36.174
it's passing compliation.
However, there's a bit of an

4926
04:50:36.174 --> 04:50:38.174
issue here, right now,

4927
04:50:38.174 --> 04:50:43.174
anybody can withdraw from this
contract. So anybody can fund,

4928
04:50:43.174 --> 04:50:46.174
which is what we want. But we
don't want anyone to be able to

4929
04:50:46.174 --> 04:50:50.174
withdraw. We only want the
person who's collecting the

4930
04:50:50.174 --> 04:50:53.174
funds to be able to actually
withdraw the funds. So how do we

4931
04:50:53.174 --> 04:50:58.174
set this up so that the withdraw
function is only called by the

4932
04:50:58.174 --> 04:51:01.174
owner of this contract? Well, to
do that, we're going to set up a

4933
04:51:01.174 --> 04:51:05.174
couple new functions. So when we
deploy this contract, we want to

4934
04:51:05.174 --> 04:51:09.174
automatically set it up so that
whomever deploys this contract

4935
04:51:09.174 --> 04:51:12.174
is going to be the owner of this
contract. And then we can do

4936
04:51:12.174 --> 04:51:16.174
some parameters to set it up so
that only the owner of this

4937
04:51:16.174 --> 04:51:18.174
contract can call the withdrawal
function. So how would we do

4938
04:51:18.174 --> 04:51:23.174
that? Well, maybe we can create
a function called like, call me

4939
04:51:23.174 --> 04:51:28.174
right away. And right after we
deploy this contract, we call

4940
04:51:28.174 --> 04:51:31.174
this call me right away
function, which will set up us

4941
04:51:31.174 --> 04:51:35.174
as the owner. Now that's going
to take two transactions. And

4942
04:51:35.174 --> 04:51:38.174
that would be really annoying if
we had to do that. So instead,

4943
04:51:38.174 --> 04:51:44.174
solidity has something called a
constructor. And if you're

4944
04:51:44.174 --> 04:51:46.174
familiar with other programming
language, a constructor is

4945
04:51:46.174 --> 04:51:50.174
exactly the same as other
programming languages.

4946
04:51:50.174 --> 04:51:53.174
constructor is going to be the
function that gets called when,

4947
04:51:53.174 --> 04:51:57.174
immediately whenever or you
deploy a contract. So if I were

4948
04:51:57.174 --> 04:52:03.175
to deploy Funmi, dot Sol, and I
were to say, minimum USD equals

4949
04:52:03.175 --> 04:52:08.175
to minimum USD would no longer
be 50 times one e to the 18th,

4950
04:52:08.175 --> 04:52:12.175
it would be immediately updated
to two. Because constructor is a

4951
04:52:12.175 --> 04:52:16.175
function that gets immediately
called in the same transaction,

4952
04:52:16.175 --> 04:52:20.175
that we create this contract,
this constructor function is

4953
04:52:20.175 --> 04:52:23.175
going to be incredibly helpful
for us, because it allows us to

4954
04:52:23.175 --> 04:52:27.175
set up the contract the way we
want it to be. So for example,

4955
04:52:27.175 --> 04:52:30.175
if we want the withdrawal
function to only be able to be

4956
04:52:30.175 --> 04:52:34.175
called by the owner of this
contract, we can have the

4957
04:52:34.175 --> 04:52:38.175
constructor set up who the owner
of the contract is. So let's

4958
04:52:38.175 --> 04:52:43.175
create a global variable called
address, public owner. And then

4959
04:52:43.175 --> 04:52:47.175
in our constructor, we'll say
the owner is going to be equal

4960
04:52:47.175 --> 04:52:52.175
to the message dot sender. The
message that sender of the

4961
04:52:52.175 --> 04:52:56.175
constructor function is going to
be whoever is deploying the

4962
04:52:56.175 --> 04:53:00.175
contract. So owner is now going
to be whoever deployed this

4963
04:53:00.175 --> 04:53:04.175
contract. And don't worry, we're
going to demo all this very soon

4964
04:53:04.175 --> 04:53:07.175
and show you everything that's
going on with ether scan

4965
04:53:07.175 --> 04:53:10.175
everything, demoing this all
right now might take a little

4966
04:53:10.175 --> 04:53:13.175
bit of time, because we're using
a test net. So if you want to

4967
04:53:13.175 --> 04:53:16.175
test it all right now,
absolutely go for it, but just

4968
04:53:16.175 --> 04:53:21.175
know, it'll take you a little
bit longer to do so. Now that we

4969
04:53:21.175 --> 04:53:25.175
have the owner setup, we can
modify our withdrawal function

4970
04:53:25.175 --> 04:53:29.175
to make it so that only the
owner can actually call this

4971
04:53:29.175 --> 04:53:32.175
withdrawal function. So at the
top of the withdrawal function,

4972
04:53:32.175 --> 04:53:37.176
maybe we want to add a section,
maybe we want to say require

4973
04:53:37.176 --> 04:53:44.176
message dot sender equals the
owner, a note about double

4974
04:53:44.176 --> 04:53:47.176
equals versus equals, you can
think of this single equals as a

4975
04:53:48.176 --> 04:53:53.176
set parameter. So when I say
owner, is now set to message dot

4976
04:53:53.176 --> 04:53:58.176
sender, double equals is how you
check to see if these two

4977
04:53:58.176 --> 04:54:02.176
variables are equivalent. So
we're saying is message dot

4978
04:54:02.176 --> 04:54:06.176
sender, the same as owner. So
this is checking to see

4979
04:54:06.176 --> 04:54:10.176
equivalence. This is setting
checking to see equivalence

4980
04:54:10.176 --> 04:54:14.176
setting. So we're gonna say
require message dot sender is

4981
04:54:14.176 --> 04:54:18.176
equal to owner, otherwise, we're
gonna throw an error, saying,

4982
04:54:18.176 --> 04:54:23.176
sender is not owner. Perfect.
Now we have a quick way to make

4983
04:54:23.176 --> 04:54:28.176
sure the withdrawal function is
only called by the owner of this

4984
04:54:28.176 --> 04:54:31.176
contract. Now, let's say that
there's a lot of functions that

4985
04:54:31.176 --> 04:54:35.176
we have in this contract that
are going to be required to be

4986
04:54:35.176 --> 04:54:38.176
the owner, maybe there's a lot
of functions in this contract

4987
04:54:38.176 --> 04:54:40.176
that need a whole lot of
different requires, we don't

4988
04:54:40.176 --> 04:54:43.176
want to have to copy paste this
line to every single one of our

4989
04:54:43.176 --> 04:54:46.176
functions. So what can we do?
Well, this is where something

4990
04:54:46.176 --> 04:54:50.176
called modifiers come in. So for
now, we're gonna go ahead and

4991
04:54:50.176 --> 04:54:54.176
delete this line. And below,
we're going to create something

4992
04:54:54.176 --> 04:54:59.176
called a modifier, our modifier
is going to be a key word that

4993
04:54:59.176 --> 04:55:03.176
we can add right in the function
declaration. To modify the

4994
04:55:03.176 --> 04:55:05.176
function with that
functionality, we're going to

4995
04:55:05.176 --> 04:55:10.176
create a modifier and call it
only owner. And we're going to

4996
04:55:10.176 --> 04:55:15.176
paste that line that we just
made in withdraw. And underneath

4997
04:55:15.176 --> 04:55:17.177
that, we're going to put a
little underscore, what I can do

4998
04:55:18.177 --> 04:55:21.177
now is I can take this only
owner modifier, and stick it in

4999
04:55:21.177 --> 04:55:25.177
the function declaration of my
withdrawal function. So what's

5000
04:55:25.177 --> 04:55:29.177
happening with this modifier
with only owner in this function

5001
04:55:29.177 --> 04:55:30.177
declaration,

5002
04:55:30.177 --> 04:55:33.177
we're saying, hey, for this
withdrawal function, before you

5003
04:55:33.177 --> 04:55:37.177
read all this code inside of it,
look down at the only owner

5004
04:55:37.177 --> 04:55:42.177
modifier and do whatever is in
there first, and then do

5005
04:55:42.177 --> 04:55:45.177
whatever's in the underscore,
this underscore represents doing

5006
04:55:45.177 --> 04:55:48.177
the rest of the code. So now,
when we go call the withdraw

5007
04:55:48.177 --> 04:55:53.177
function, we actually do this
require statement first, and

5008
04:55:53.177 --> 04:55:57.177
then call the rest of the code.
If this require statement, we're

5009
04:55:57.177 --> 04:56:02.177
below the underscore, this would
tell our function to go ahead

5010
04:56:02.177 --> 04:56:06.177
and do all this code first. And
then run the require. Because

5011
04:56:06.177 --> 04:56:09.177
again, we have this only only
keyword, we're saying, Great,

5012
04:56:09.177 --> 04:56:12.177
we've got a function, it's
withdraw its public, oh, only

5013
04:56:12.177 --> 04:56:16.177
odor modifier. Let's look at how
that works. Okay, it tells us

5014
04:56:16.177 --> 04:56:19.177
how to do all the code of the
original function first. So

5015
04:56:19.177 --> 04:56:22.177
let's go ahead and do that.
Okay, now we're done. Now, what

5016
04:56:22.177 --> 04:56:25.177
do we do? Okay, now we'll run
the require, we want to go ahead

5017
04:56:25.177 --> 04:56:30.177
and put the require here first.
So this is how modifiers work,

5018
04:56:30.177 --> 04:56:35.177
and how we can use them to
improve our functionality. All

5019
04:56:35.177 --> 04:56:39.177
right, awesome. We have all the
basic functionality of our

5020
04:56:39.177 --> 04:56:42.177
contract that we need here. Now
we're finally actually going to

5021
04:56:42.177 --> 04:56:46.177
run everything on a test and see
everything happened live before

5022
04:56:46.177 --> 04:56:49.177
our eyes. Are you ready? Let's
do this.

5023
04:56:49.177 --> 04:56:52.177
So let's go over to the deploy
tab. And we're going to switch

5024
04:56:52.177 --> 04:56:55.177
of course to injected web three.
Remember But we're using

5025
04:56:55.177 --> 04:56:59.178
injected web three, because our
price converter dot soul is

5026
04:56:59.178 --> 04:57:02.178
using chainlink Oracle's that
actually exist and are actually

5027
04:57:02.178 --> 04:57:05.178
monitoring the Rinkeby network
for us. Now we're going to

5028
04:57:05.178 --> 04:57:09.178
scroll down to, and we're going
to choose the Funmi contract.

5029
04:57:09.178 --> 04:57:12.178
And we're going to go ahead and
deploy. Once again, we want to

5030
04:57:12.178 --> 04:57:16.178
make sure we're on the Rinkeby
test net. And we have a little

5031
04:57:16.178 --> 04:57:20.178
bit of rinky eath in our wallet,
let's go ahead and deploy,

5032
04:57:20.178 --> 04:57:24.178
confirm. And we'll wait a little
bit. And I'll pull up our log

5033
04:57:24.178 --> 04:57:28.178
here. And we'll wait a little
bit for our contract to get

5034
04:57:28.178 --> 04:57:31.178
deployed. Alright, great. It
looks like our contract has

5035
04:57:31.178 --> 04:57:35.178
indeed been deployed. If we
scroll down, we can see all of

5036
04:57:35.178 --> 04:57:40.178
our functionality, minimum USD
is going to be that $50. But

5037
04:57:40.178 --> 04:57:44.178
with 18 zeros so that the units
are the same as Aetherium, the

5038
04:57:44.178 --> 04:57:49.178
owner of our contract was set to
our address, the instant we

5039
04:57:49.178 --> 04:57:53.178
deployed this contract, it was
deployed by calling our

5040
04:57:53.178 --> 04:57:58.178
constructor function. So this
address 0x 106 x is going to be

5041
04:57:58.178 --> 04:58:02.178
the same as the address in our
meta mask, your address here, of

5042
04:58:02.178 --> 04:58:05.178
course, is going to be a little
bit different than mine, we have

5043
04:58:05.178 --> 04:58:08.178
our funders array, which, of
course is going to be blank, we

5044
04:58:08.178 --> 04:58:11.178
have our address array, which is
also going to be blank. And then

5045
04:58:11.178 --> 04:58:14.178
we have two functions that we
can use to modify the state of

5046
04:58:14.178 --> 04:58:18.178
the blockchain withdraw is going
to be orange, because we're not

5047
04:58:18.178 --> 04:58:22.178
paying any Aetherium we're
actually gaining Aetherium or

5048
04:58:22.178 --> 04:58:25.178
whatever native blockchain
currency fund is going to be

5049
04:58:25.178 --> 04:58:29.178
read, because fun is a payable
function that we are going to be

5050
04:58:29.178 --> 04:58:33.178
sending Aetherium to or sending
whatever native blockchain

5051
04:58:33.178 --> 04:58:35.178
currency that you're working
with. So let's go ahead and see

5052
04:58:35.178 --> 04:58:39.179
how this all works. So first,
let's go ahead and fund this

5053
04:58:39.179 --> 04:58:43.179
contract. Again, funding, we got
to do a little bit of math,

5054
04:58:43.179 --> 04:58:47.179
right now, since the price of
eath is around $3,000. And we're

5055
04:58:47.179 --> 04:58:53.179
looking for $50. Minimum, we do
50 divided by 3000. We can do

5056
04:58:53.179 --> 04:58:58.179
3000 divided by 50, we can do 50
divided by 3000. So we know that

5057
04:58:58.179 --> 04:59:04.179
around 0.02 Aetherium, should be
enough for this contract to

5058
04:59:04.179 --> 04:59:12.179
work. So 0.02 Aetherium is this
much way, we can copy that,

5059
04:59:12.179 --> 04:59:16.179
paste that into here. So when we
hit fund, it should actually

5060
04:59:16.179 --> 04:59:20.179
pass. And we do indeed see meta
masks pop up. And we'll go ahead

5061
04:59:20.179 --> 04:59:23.179
and confirm. Once this
transaction goes through, we'll

5062
04:59:23.179 --> 04:59:28.179
be able to see this contract on
ether scan with the funds in it.

5063
04:59:28.179 --> 04:59:31.179
Now if we don't add way here, if
we don't add a value, once

5064
04:59:31.179 --> 04:59:35.179
again, we had fund will say gas
estimation failed because we're

5065
04:59:35.179 --> 04:59:39.179
not sending enough here. And in
fact, we even see execution

5066
04:59:39.179 --> 04:59:42.179
reverted didn't send enough, we
can absolutely send this

5067
04:59:42.179 --> 04:59:46.179
transaction however, it's going
to fail. Great. So now that our

5068
04:59:46.179 --> 04:59:49.179
transaction has gone through, if
we go on to the rink the ether

5069
04:59:49.179 --> 04:59:53.179
scan, once we wait a little bit
for it to finish indexing here

5070
04:59:53.179 --> 04:59:56.179
on the Rinkeby ether scan, we
can see that transaction

5071
04:59:56.179 --> 04:59:59.179
actually went through for doing
the funding, we can actually see

5072
05:00:00.179 --> 05:00:03.179
a lot of different details going
on with this transaction as

5073
05:00:03.179 --> 05:00:06.179
well. And if we scroll down, we
once again, you can see all the

5074
05:00:06.179 --> 05:00:10.179
information about us calling
this fun function, gas limit

5075
05:00:10.179 --> 05:00:15.179
gas, you should the gas fees,
gas price, and we can see the

5076
05:00:15.179 --> 05:00:20.180
input data as well, we can see
that we called the fund function

5077
05:00:20.180 --> 05:00:23.180
down here. We'll learn more
about the input data later. If

5078
05:00:23.180 --> 05:00:27.180
we go to the contract that we
deployed, we can now see two

5079
05:00:27.180 --> 05:00:32.180
transactions, we can see our
contract created transaction.

5080
05:00:32.180 --> 05:00:36.180
And we can also see we called a
font method. And if we look at

5081
05:00:36.180 --> 05:00:40.180
the balance of our contract, and
now has 0.02 ether, which makes

5082
05:00:40.180 --> 05:00:46.180
sense, since we just sent it
0.02. If we put that 0.02 eath

5083
05:00:46.180 --> 05:00:51.180
in terms of way back into the
value section, and we call font

5084
05:00:51.180 --> 05:00:57.180
again, after this transaction
goes through, we should see this

5085
05:00:57.180 --> 05:01:04.180
number go from 0.02 to 0.04. Now
after we wait a brief delay, we

5086
05:01:04.180 --> 05:01:09.180
do indeed see the balance has
gone up to 0.04, which is

5087
05:01:09.180 --> 05:01:12.180
exactly what we'd expect.
Awesome. So our funding

5088
05:01:12.180 --> 05:01:16.180
mechanism is working correctly.
And if we go down into our

5089
05:01:16.180 --> 05:01:20.180
array, and our mapping

5090
05:01:20.180 --> 05:01:25.180
to do address to array, and we
paste our address, we should see

5091
05:01:25.180 --> 05:01:29.180
the phone number show up. And if
we go to funders of zero, we see

5092
05:01:29.180 --> 05:01:33.180
our address. And if we go to
funders of one, we also see our

5093
05:01:33.180 --> 05:01:37.180
address and we see that and we
see this call going through if

5094
05:01:37.180 --> 05:01:41.180
we go to funders have to in our
log over here, we actually see

5095
05:01:41.180 --> 05:01:44.180
that we get an error an
optimization that we could make

5096
05:01:44.180 --> 05:01:48.180
to our contract in the future is
to check to see if an address is

5097
05:01:48.180 --> 05:01:51.180
already in the funders array and
then not add it if it's already

5098
05:01:51.180 --> 05:01:54.180
there. Now let's go ahead and
try to call this withdrawal

5099
05:01:54.180 --> 05:01:58.180
function. But let's try to call
it with a different address than

5100
05:01:58.180 --> 05:02:00.181
the address we originally
deployed this contract with. So

5101
05:02:00.181 --> 05:02:05.181
to do that, scroll all the way
to the top of this here. And I'm

5102
05:02:05.181 --> 05:02:11.181
going to go to my Metamask. And
I'm going to switch to a second

5103
05:02:11.181 --> 05:02:16.181
account and hit connect. Now,
our remixes should be updated

5104
05:02:16.181 --> 05:02:19.181
with the new account that's in
here, you'll see that if I

5105
05:02:19.181 --> 05:02:24.181
switch back to account one, it
switches back to account one, so

5106
05:02:24.181 --> 05:02:27.181
long as they're both connected,
you can see which accounts are

5107
05:02:27.181 --> 05:02:31.181
connected to applications by
clicking this connected button

5108
05:02:31.181 --> 05:02:33.181
and see which ones are
connected. If you ever want to

5109
05:02:33.181 --> 05:02:36.181
disconnect that account, you can
click the three little dots and

5110
05:02:36.181 --> 05:02:40.181
it disconnect the account. And
now we can see that this account

5111
05:02:40.181 --> 05:02:45.181
is not connected. However, count
two is connected. Let's go back

5112
05:02:45.181 --> 05:02:49.181
to account one and Connect
account one so that both of them

5113
05:02:49.181 --> 05:02:53.181
are now connected. But we'll
switch to account two, let's

5114
05:02:53.181 --> 05:02:57.181
switch to account two, because
again, account two isn't the

5115
05:02:57.181 --> 05:03:02.181
owner of this contract. We
scroll down to owner, we can see

5116
05:03:02.181 --> 05:03:07.181
owner's 0x 1066 Something
something and account two is

5117
05:03:07.181 --> 05:03:11.181
0x 043. Something something
awesome. So what do you think

5118
05:03:11.181 --> 05:03:15.181
will happen when we hit withdraw
here? Well, our modifier only

5119
05:03:15.181 --> 05:03:19.181
owner should kick in. And we
should get notified that if we

5120
05:03:19.181 --> 05:03:23.181
send the transaction, we'll get
this error sender is not owner.

5121
05:03:23.181 --> 05:03:27.181
So let's try it. Ah gas
estimation failed, we do get

5122
05:03:27.181 --> 05:03:31.181
this error. Sender is not owner,
which is perfect. This is

5123
05:03:31.181 --> 05:03:34.181
exactly what we want, we could
absolutely send this transaction

5124
05:03:34.181 --> 05:03:37.181
if we wanted to. But that would
just be a waste of gas because

5125
05:03:37.181 --> 05:03:42.182
this transaction is going to
fail. However, if we switch back

5126
05:03:42.182 --> 05:03:48.182
to account one, and we hit
withdraw, meta mask will pop up,

5127
05:03:48.182 --> 05:03:53.182
enabling us to confirm and
withdraw the ether out of this

5128
05:03:53.182 --> 05:03:57.182
contract address. Now if we look
at this contract address on

5129
05:03:57.182 --> 05:04:01.182
ether scan, after a brief delay,
we'll see the balance go from

5130
05:04:01.182 --> 05:04:07.182
0.04 back down to zero. And
we'll see our wallet balance go

5131
05:04:07.182 --> 05:04:11.182
up from what it is back to 0.04
plus what it was. And after a

5132
05:04:12.182 --> 05:04:15.182
brief delay, you can see our
balance is indeed back down to

5133
05:04:15.182 --> 05:04:20.182
zero in our contract. Now, if we
do address to amount for our

5134
05:04:20.182 --> 05:04:22.182
wallet address that was doing
the funding, it's back down to

5135
05:04:22.182 --> 05:04:27.182
zero. And if we try to check the
address of funders at index

5136
05:04:27.182 --> 05:04:30.182
zero, we get called to funders
that fund me errored execution

5137
05:04:30.182 --> 05:04:40.182
reverted.

5138
05:04:40.182 --> 05:04:43.182
We've completed all the basics
of this section that I wanted to

5139
05:04:43.182 --> 05:04:46.182
go through. And you should be
incredibly proud of yourself for

5140
05:04:46.182 --> 05:04:49.182
getting this far, you've just
deployed a really advanced smart

5141
05:04:49.182 --> 05:04:53.182
contract, we're using a library
and chainlink contracts to build

5142
05:04:53.182 --> 05:04:55.182
some of the most powerful
applications in the planet,

5143
05:04:55.182 --> 05:04:59.182
we've learned to use a library
for any type we want in our

5144
05:04:59.182 --> 05:05:03.182
smart contracts. We've learned
more about multiplication, and

5145
05:05:03.182 --> 05:05:06.182
then units of measure in
solidity and smart contracts.

5146
05:05:06.182 --> 05:05:08.182
We've learned about mappings
more about arrays what the

5147
05:05:09.182 --> 05:05:12.182
constructor does, we've learned
how to send money we've learned

5148
05:05:12.182 --> 05:05:15.182
about for loops, we've learned
about the different ways we can

5149
05:05:15.182 --> 05:05:18.182
actually send money, at least
from a low level. And we've

5150
05:05:18.182 --> 05:05:20.183
learned about modifiers. This
section is one of the tougher

5151
05:05:20.183 --> 05:05:23.183
sections in this course. So if
you completed this, you should

5152
05:05:23.183 --> 05:05:26.183
be incredibly excited. We're
going to go through our code

5153
05:05:26.183 --> 05:05:29.183
now. And we're going to make a
number of tweaks. Now this

5154
05:05:29.183 --> 05:05:32.183
section, we are going to do a
little bit more advanced

5155
05:05:32.183 --> 05:05:36.183
solidity here. So if you get a
little bit lost, don't sweat it

5156
05:05:36.183 --> 05:05:39.183
too much. And feel free to try
some of this stuff in the future

5157
05:05:39.183 --> 05:05:44.183
on your own. We're going to
modify this contract to make it

5158
05:05:44.183 --> 05:05:47.183
a little bit more professional.
It's not going to be end to end

5159
05:05:47.183 --> 05:05:49.183
amazing, but it's going to be a
little bit better. And you'll

5160
05:05:49.183 --> 05:05:51.183
see why in a minute. So the
first thing that we're going to

5161
05:05:51.183 --> 05:05:53.183
do is we're looking we're going
to look at some of these

5162
05:05:53.183 --> 05:05:58.183
variables here. In particular
owner and minimum USD, owner

5163
05:05:58.183 --> 05:06:02.183
gets set one time in our
contract here. And then it never

5164
05:06:02.183 --> 05:06:08.183
changes. Again, minimum USD gets
set one time, even outside of

5165
05:06:08.183 --> 05:06:12.183
the constructor. If we have
variables that only get set one

5166
05:06:12.183 --> 05:06:16.183
time, we can actually use some
tools in solidity to make them

5167
05:06:16.183 --> 05:06:19.183
more gas efficient. For now
let's compile our Funmi

5168
05:06:19.183 --> 05:06:22.183
contract, and then deploy it to
a JavaScript virtual machine.

5169
05:06:22.183 --> 05:06:26.183
Remember, we can go ahead and
deploy it right now. However,

5170
05:06:26.183 --> 05:06:29.183
funding and withdrawing and
doing in the money stuff isn't

5171
05:06:29.183 --> 05:06:32.183
going to work. Because again, we
don't have a chain link network

5172
05:06:33.183 --> 05:06:36.183
on our JavaScript VM. So those
aren't going to work so well.

5173
05:06:36.183 --> 05:06:38.183
But for what we're gonna do
right now, we don't really care

5174
05:06:38.183 --> 05:06:42.183
so much. Here's what we do care
about. You do care about how

5175
05:06:42.183 --> 05:06:46.183
much gas this costs to actually
send. We do care about how much

5176
05:06:46.183 --> 05:06:50.183
gas is costs to create right now
creating this contract costs

5177
05:06:50.183 --> 05:06:56.183
about 859,000 gas and we're
going to Add a couple of tricks.

5178
05:06:56.183 --> 05:06:59.184
Right now to bring this number
down, we're going to add some

5179
05:06:59.184 --> 05:07:02.184
stuff back in in the bid, which
will bring it back up. But for

5180
05:07:02.184 --> 05:07:04.184
now, we're going to learn some
tricks to bring this number

5181
05:07:04.184 --> 05:07:07.184
down. The two tricks that we're
going to learn are the constant

5182
05:07:07.184 --> 05:07:10.184
keyword and the immutable
keyword, in their solidity.

5183
05:07:10.184 --> 05:07:14.184
There are two keywords that make
it so that your variables can't

5184
05:07:14.184 --> 05:07:18.184
be changed. And those keywords
are constant and immutable. You

5185
05:07:18.184 --> 05:07:21.184
can learn more about them in the
solidity documentation, if you

5186
05:07:21.184 --> 05:07:24.184
assign a variable once outside
of a function, and then never

5187
05:07:24.184 --> 05:07:28.184
change it, so if if it's
assigned at compile time, you

5188
05:07:28.184 --> 05:07:32.184
can go ahead and add this
constant keyword. We'll learn

5189
05:07:32.184 --> 05:07:35.184
later about storage. But when
you add a constant keyword, this

5190
05:07:35.184 --> 05:07:40.184
minimum USD no longer takes up a
storage spot, and is much easier

5191
05:07:40.184 --> 05:07:43.184
to read too. So now we recompile
this, and we deploy this new

5192
05:07:43.184 --> 05:07:48.184
contract. Let's see if we saved
any gas. We look in the

5193
05:07:48.184 --> 05:07:52.184
transaction logs, now, we can
grab the transaction cost of how

5194
05:07:52.184 --> 05:07:55.184
much this cost to deploy, let's
compare it to how much it was

5195
05:07:55.184 --> 05:08:00.184
before. Well, we saved almost
19,000 gas, that's almost as

5196
05:08:00.184 --> 05:08:03.184
much gas as a cost to send
Aetherium. Typically, constant

5197
05:08:03.184 --> 05:08:06.184
variables have a different
naming convention. Typically,

5198
05:08:06.184 --> 05:08:11.184
you'll want to do them all caps
like Min imaam. Underscore, who

5199
05:08:11.184 --> 05:08:15.184
is the CIO all caps with
underscores. So now let's just

5200
05:08:15.184 --> 05:08:18.184
find minimum use D, and replace
that with all caps as well. With

5201
05:08:18.184 --> 05:08:22.184
this interaction, we know that
this variable is a constant

5202
05:08:22.184 --> 05:08:25.184
variable, and it's much cheaper
to read from now, if we go ahead

5203
05:08:25.184 --> 05:08:30.184
and compile this and redeploy.
In our Funmi contract, even

5204
05:08:30.184 --> 05:08:34.184
though this is a view function,
remember, view functions do have

5205
05:08:34.184 --> 05:08:38.185
gas costs when when called by
contract as a constant variable,

5206
05:08:38.185 --> 05:08:44.185
we can see the execution cost of
this variable 21,415 gas. So

5207
05:08:44.185 --> 05:08:47.185
let's put a little note rather
Nathan.

5208
05:08:47.185 --> 05:08:50.185
If we remove the constant
variable, we delete this

5209
05:08:50.185 --> 05:08:56.185
contract. And we redeploy, like
Funmi. And we hit minimum ust

5210
05:08:56.185 --> 05:08:59.185
again, we can now see how much
gas this was cost. If it wasn't

5211
05:09:00.185 --> 05:09:03.185
a constant variable, we can see
the gas cost did indeed go up.

5212
05:09:03.185 --> 05:09:06.185
Now on chains that are much
cheaper, this gas difference

5213
05:09:06.185 --> 05:09:08.185
probably won't make that much of
a difference. But on more

5214
05:09:08.185 --> 05:09:11.185
expensive chains like Aetherium,
this is going to make a big

5215
05:09:11.185 --> 05:09:15.185
difference. For example, on
Aetherium, we can actually see

5216
05:09:15.185 --> 05:09:19.185
current gas prices on Aetherium.
Here, we can see the current gas

5217
05:09:19.185 --> 05:09:23.185
price of Aetherium is about 141
way, so we'll go to our

5218
05:09:23.185 --> 05:09:28.185
converter, way to way we'll copy
the way price times this will

5219
05:09:28.185 --> 05:09:32.185
get the gas price of calling our
minimum USD, which is this

5220
05:09:32.185 --> 05:09:36.185
number here, which if we put
back in our Aetherium

5221
05:09:36.185 --> 05:09:41.185
uniconverter, we can see cost
this much gas. And if we times

5222
05:09:41.185 --> 05:09:45.185
that by the approximate current
price of Aetherium, which is

5223
05:09:45.185 --> 05:09:49.185
around $3,000. Calling minimum
use D as a constant is going to

5224
05:09:49.185 --> 05:09:54.185
cost $9 on the inside is at a
nonconstant is going to cost

5225
05:09:54.185 --> 05:09:58.185
almost an entire dollar more,
you can see how all these little

5226
05:09:58.185 --> 05:10:01.185
gas optimization tricks are
going to make your life a lot

5227
05:10:01.185 --> 05:10:04.185
better. So let's keep this
constant keyword in here. We'll

5228
05:10:04.185 --> 05:10:07.185
learn more about constant and
storage in later sections of

5229
05:10:07.185 --> 05:10:10.185
this course. Now, as you're just
getting started with this

5230
05:10:10.185 --> 05:10:15.185
course, and with slip the Do not
struggle. And do not worry about

5231
05:10:15.185 --> 05:10:19.186
making your contracts as gas
efficient as possible in the

5232
05:10:19.186 --> 05:10:22.186
beginning, and especially right
now. Just write your contracts

5233
05:10:22.186 --> 05:10:26.186
as best as you can. Once you get
really good at gas. And once you

5234
05:10:26.186 --> 05:10:30.186
get much later on in the course,
and much more advanced with

5235
05:10:30.186 --> 05:10:33.186
solidity, then you can start
going back and working on gas

5236
05:10:33.186 --> 05:10:37.186
optimizations. But do not let
gas optimizations hold you back.

5237
05:10:37.186 --> 05:10:41.186
Or if you start stressing over
it, just let it go. Don't worry

5238
05:10:41.186 --> 05:10:44.186
about it and just write your
code as best you can. So long

5239
05:10:44.186 --> 05:10:48.186
story short, Do not stress about
gas optimizations right now. Now

5240
05:10:48.186 --> 05:10:51.186
another variable we only set one
time is going to be our owner

5241
05:10:51.186 --> 05:10:56.186
variable. Owner equals message
dot sender. We set this one time

5242
05:10:56.186 --> 05:11:00.186
in the constructor variables
that we set one time but outside

5243
05:11:00.186 --> 05:11:02.186
of the same line that they're
declared. And we set them for

5244
05:11:02.186 --> 05:11:06.186
example, in the constructor, we
can mark as a mutable typically

5245
05:11:06.186 --> 05:11:09.186
a good convention for marking
immutable variables is going to

5246
05:11:09.186 --> 05:11:13.186
be doing I underscore so that we
know that these are immutable

5247
05:11:13.186 --> 05:11:16.186
variables, they have very
similar gas savings to the

5248
05:11:16.186 --> 05:11:19.186
constant keyword. Owner, of
course, is a variable that we

5249
05:11:19.186 --> 05:11:23.186
can't set on the line here
because inside the global scope,

5250
05:11:23.186 --> 05:11:27.186
there's no function going on.
However, inside functions,

5251
05:11:27.186 --> 05:11:29.186
because inside the global scope,
there's going to be no message

5252
05:11:29.186 --> 05:11:32.186
that sender, there's only going
to be a message dot sender when

5253
05:11:32.186 --> 05:11:36.186
we're inside of a function. So
inside here, we might say I

5254
05:11:36.186 --> 05:11:39.186
owner equals message dot sender.
And then of course, we'll scroll

5255
05:11:39.186 --> 05:11:44.186
down and we'll change this
require only owner now equals i

5256
05:11:44.186 --> 05:11:50.186
owner. Now if we compile that
deploy up, we can see how much

5257
05:11:50.186 --> 05:11:53.186
gas we can see how much gas
calling I owner is going to be

5258
05:11:53.186 --> 05:11:59.187
by with immutable notice, we get
21,508, which we'll go ahead and

5259
05:11:59.187 --> 05:12:02.187
copy for now. And we'll put
right here, we'll say,

5260
05:12:02.187 --> 05:12:08.187
immutable. Now, if we remove the
immutable keyword, let's close

5261
05:12:08.187 --> 05:12:13.187
this redeploy. If we scroll down
to I owner, screw up the logs,

5262
05:12:13.187 --> 05:12:17.187
we go down to the call, scroll
down, we see the execution cost

5263
05:12:17.187 --> 05:12:24.187
was much more. So we'll do the
backslash, a seven here, yes, or

5264
05:12:24.187 --> 05:12:28.187
non immutable. So you want to
keep some of these tricks in

5265
05:12:28.187 --> 05:12:32.187
mind, when it comes to storing
variables. The reason that these

5266
05:12:32.187 --> 05:12:36.187
two save gas is because instead
of storing these variables

5267
05:12:36.187 --> 05:12:39.187
inside of a storage slot, we
actually store them directly

5268
05:12:39.187 --> 05:12:41.187
into the bytecode of the
contract. And like I said, don't

5269
05:12:41.187 --> 05:12:44.187
worry too much about that for
now, later on in the course,

5270
05:12:44.187 --> 05:12:47.187
we'll teach you more about
storage and a lot of this low

5271
05:12:47.187 --> 05:12:50.187
level stuff that comes to these
contracts. But for now, just

5272
05:12:50.187 --> 05:12:54.187
know that these exist. And
they're nice gas savers, if

5273
05:12:54.187 --> 05:12:59.187
you're only setting your
variables once. Alright, great.

5274
05:12:59.187 --> 05:13:02.187
So we've just made our contract
a little bit more gas efficient,

5275
05:13:02.187 --> 05:13:04.187
little gas efficiency
improvements are going to be

5276
05:13:04.187 --> 05:13:07.187
concept I sprinkled throughout
this course. And when we get to

5277
05:13:07.187 --> 05:13:10.187
the more advanced section, I'm
going to break down exactly

5278
05:13:10.187 --> 05:13:13.187
what's going on and why all
these gas efficiencies exist and

5279
05:13:13.187 --> 05:13:15.187
what's going on behind the
scenes for these gas

5280
05:13:15.187 --> 05:13:18.187
efficiencies to occur. It's a
little bit in the weeds, which

5281
05:13:18.187 --> 05:13:20.187
is why I'm going to gloss over
it right now.

5282
05:13:20.187 --> 05:13:23.187
So if it's confusing, don't
worry, I wouldn't let these gas

5283
05:13:23.187 --> 05:13:26.187
efficiencies be the thing that
slow you down. Awesome. So we

5284
05:13:26.187 --> 05:13:29.187
have these two gas
optimizations? How else can we

5285
05:13:29.187 --> 05:13:32.187
make this contract a little bit
more gas efficient? Well, one of

5286
05:13:32.187 --> 05:13:35.187
the ways we can make this more
gas efficient, is by updating

5287
05:13:35.187 --> 05:13:39.188
our requires right now with our
require statement, we actually

5288
05:13:39.188 --> 05:13:44.188
have to store this sender is not
an owner as a string array,

5289
05:13:44.188 --> 05:13:46.188
every single one of these
characters in this errorlog

5290
05:13:46.188 --> 05:13:49.188
needs to get stored
individually, this string may

5291
05:13:49.188 --> 05:13:52.188
not seem very big, but it's a
lot bigger than the alternative

5292
05:13:52.188 --> 05:13:56.188
with what we can do. As of zero,
point 8.4 of solidity, you can

5293
05:13:56.188 --> 05:14:01.188
now actually do custom errors.
For our reverts, we declare them

5294
05:14:01.188 --> 05:14:05.188
at the top and then use ifs,
instead of require and then just

5295
05:14:05.188 --> 05:14:09.188
add a revert statements. This
ends up saving a lot of gas,

5296
05:14:09.188 --> 05:14:12.188
since we just call the error
code, as opposed to calling the

5297
05:14:12.188 --> 05:14:17.188
entire string associated with
the air. So for example, with

5298
05:14:17.188 --> 05:14:20.188
our require down here, and with
actually with all of our

5299
05:14:20.188 --> 05:14:23.188
requires, well we could do is
instead of having this require

5300
05:14:23.188 --> 05:14:28.188
we could create a custom error.
So at the top, what we could do

5301
05:14:28.188 --> 05:14:35.188
is we could say error, not
owner. And you'll notice that

5302
05:14:35.188 --> 05:14:39.188
this is actually outside of the
contract here. Now what we can

5303
05:14:39.188 --> 05:14:42.188
do is we can take this error not
owner scroll down into our only

5304
05:14:42.188 --> 05:14:45.188
owner, instead of doing a
require we'll do an if

5305
05:14:45.188 --> 05:14:53.188
statement, we'll say if message
dot sender is not owner, then

5306
05:14:53.188 --> 05:15:00.188
we're going to go ahead and
revert with a non owner error.

5307
05:15:00.188 --> 05:15:03.188
This ends up saving us a lot of
gas, since we don't have to

5308
05:15:03.188 --> 05:15:07.188
store and emit this long string
here. Now in a lot of code

5309
05:15:07.188 --> 05:15:10.188
today, you'll still see require
a lot of places because these

5310
05:15:10.188 --> 05:15:13.188
these custom errors are pretty
new in solidity. So you'll want

5311
05:15:13.188 --> 05:15:16.188
to get used to writing in both
ways. I wouldn't be surprised if

5312
05:15:16.188 --> 05:15:19.189
in the future, the syntax for
some of these errors looks like

5313
05:15:19.189 --> 05:15:22.189
this so that it's more readable.
But for now, if you want to do a

5314
05:15:22.189 --> 05:15:25.189
more gas efficient way than
required, you can use something

5315
05:15:25.189 --> 05:15:28.189
like this, we could update all
of our requires here for these

5316
05:15:28.189 --> 05:15:31.189
customers. But for now, I'm
going to leave both in just to

5317
05:15:31.189 --> 05:15:34.189
show you the differences. This
revert keyword does the exact

5318
05:15:34.189 --> 05:15:37.189
same thing that required us
without the conditional

5319
05:15:37.189 --> 05:15:40.189
beforehand. So you can actually
go ahead and revert any

5320
05:15:40.189 --> 05:15:43.189
transaction or any function call
in the middle of the function

5321
05:15:43.189 --> 05:15:49.189
call. Now let's look at one more
way to improve this contract.

5322
05:15:49.189 --> 05:15:51.189
Sometimes people will try to
interact with the contract that

5323
05:15:51.189 --> 05:15:54.189
takes Aetherium or the native
blockchain token without

5324
05:15:54.189 --> 05:15:57.189
actually going through the
required function calls that

5325
05:15:57.189 --> 05:16:01.189
that are needed. For example, on
a JavaScript EVM here, I could

5326
05:16:01.189 --> 05:16:04.189
actually try to send this
contract money without calling

5327
05:16:04.189 --> 05:16:08.189
the fund function. However, if I
were to do that, what would

5328
05:16:08.189 --> 05:16:11.189
happen with our fund function
get triggered? No, it wouldn't

5329
05:16:11.189 --> 05:16:14.189
get triggered, we wouldn't keep
track of that funder, we

5330
05:16:14.189 --> 05:16:17.189
wouldn't have that person's
information updated in this

5331
05:16:17.189 --> 05:16:20.189
contract. So if later on we want
to give rewards or something we

5332
05:16:20.189 --> 05:16:23.189
wouldn't know about those
funders. And this wouldn't be

5333
05:16:23.189 --> 05:16:26.189
great because people would send
our contract money without us

5334
05:16:26.189 --> 05:16:28.189
ever knowing and we wouldn't be
able to give them any credit or

5335
05:16:28.189 --> 05:16:32.189
anything. Additionally, maybe
they called the wrong function

5336
05:16:32.189 --> 05:16:35.189
by accident, and they they
weren't using Metamask. And they

5337
05:16:35.189 --> 05:16:38.189
weren't using a tool to tell
them, hey, this transaction is

5338
05:16:38.189 --> 05:16:41.189
likely going to fail. So what
can we do in this case? What

5339
05:16:41.189 --> 05:16:49.189
happens if someone sends this
contract, ether without calling

5340
05:16:49.189 --> 05:16:52.189
the fun function? Right now, if
we were to send this Funmi

5341
05:16:52.189 --> 05:16:55.189
contract, ie it would just go to
the contract Right, and this

5342
05:16:55.189 --> 05:16:58.189
contract just wouldn't keep
track of those people. But

5343
05:16:58.189 --> 05:17:00.190
there's actually a way for when
people send money to this

5344
05:17:00.190 --> 05:17:04.190
contract, or people call a
function that doesn't exist for

5345
05:17:04.190 --> 05:17:07.190
us to still trigger some code.
And now there are two special

5346
05:17:07.190 --> 05:17:12.190
functions in solidity one is
called receive, and one is

5347
05:17:12.190 --> 05:17:16.190
called the fallback. Now in
solidity, there are actually a

5348
05:17:16.190 --> 05:17:19.190
number of special functions and
two of these special functions

5349
05:17:19.190 --> 05:17:23.190
are the receive special
function. And the fallback

5350
05:17:23.190 --> 05:17:26.190
special function, a contract can
have at most one receive

5351
05:17:26.190 --> 05:17:29.190
function declared using the
received external payable.

5352
05:17:29.190 --> 05:17:32.190
Without the function keyword.
This function cannot have

5353
05:17:32.190 --> 05:17:34.190
arguments cannot return anything
and must have external

5354
05:17:34.190 --> 05:17:38.190
visibility, and a payable state
mutability. What does that

5355
05:17:38.190 --> 05:17:41.190
actually mean? And or look like?
Well, let's create a separate

5356
05:17:42.190 --> 05:17:44.190
contract to go ahead and play
with this. So in here, we're

5357
05:17:44.190 --> 05:17:48.190
going to create a new file
called fallback example, dot

5358
05:17:48.190 --> 05:17:52.190
soul. And in here, we're going
to add our basic pieces, SPX

5359
05:17:52.190 --> 05:18:00.190
license identifier, MIT pragma,
solidity zero, point 8.7. And

5360
05:18:00.190 --> 05:18:06.190
we'll do contract fallback
example, like so, feel free to

5361
05:18:06.190 --> 05:18:09.190
pause the video to catch up to
this point, let's recreate our

5362
05:18:09.190 --> 05:18:12.190
fallback contract, let's create
a variable to go ahead and try

5363
05:18:12.190 --> 05:18:17.190
to test this function, we'll
create a un 256 public result

5364
05:18:17.190 --> 05:18:20.190
variable. And let's create this
receive function. So we'll say

5365
05:18:20.190 --> 05:18:25.190
receive, it's going to be an
external payable.

5366
05:18:25.190 --> 05:18:30.190
function, we don't add the
function keyword for receive,

5367
05:18:30.190 --> 05:18:34.190
since solidity knows that
receive is a special function

5368
05:18:34.190 --> 05:18:38.190
whenever we send Aetherium or
make a transaction to this

5369
05:18:38.190 --> 05:18:41.191
contract. Now, as long as
there's no data associated with

5370
05:18:41.191 --> 05:18:45.191
that transaction, this receive
function will get triggered.

5371
05:18:45.191 --> 05:18:50.191
What we can do in here now is we
can say result equals one. So

5372
05:18:50.191 --> 05:18:53.191
let's go ahead and test this out
on the JavaScript virtual

5373
05:18:53.191 --> 05:18:56.191
machine, we compile this, so
we're gonna go ahead and compile

5374
05:18:56.191 --> 05:19:00.191
this. And we'll go deploy it on
the Java Virtual Machine, we're

5375
05:19:00.191 --> 05:19:04.191
going to deploy our fallback
example. And we're going to see

5376
05:19:04.191 --> 05:19:07.191
what result is initialized to,
since we haven't set anything

5377
05:19:07.191 --> 05:19:12.191
for result, result, of course,
is initialized zero. But what if

5378
05:19:12.191 --> 05:19:16.191
we were to send this contract
some Aetherium? Well receive

5379
05:19:16.191 --> 05:19:19.191
would go ahead and be triggered
here, we can actually send this

5380
05:19:19.191 --> 05:19:22.191
contract some material directly
by working with this low level

5381
05:19:22.191 --> 05:19:25.191
interactions. But here, don't
worry about what call data means

5382
05:19:25.191 --> 05:19:28.191
for now, just know that this
area down here is a way we can

5383
05:19:28.191 --> 05:19:32.191
send and work with different
functions. And we can add

5384
05:19:32.191 --> 05:19:35.191
parameters to this transaction,
by going up here and adjusting

5385
05:19:35.191 --> 05:19:39.191
the variables up here. If we
keep called Data blank, it'll be

5386
05:19:39.191 --> 05:19:42.191
the same as if we were in
Metamask. And just hitting send

5387
05:19:42.191 --> 05:19:45.191
in the choosing this contract
address. Again, we can't

5388
05:19:45.191 --> 05:19:48.191
actually use Metamask, since
this is a virtual machine, and

5389
05:19:48.191 --> 05:19:51.191
not one of the networks that
we're working with. So if I do,

5390
05:19:51.191 --> 05:19:55.191
for example, I change this value
to one way, and I keep

5391
05:19:55.191 --> 05:19:59.191
everything blank. And I go ahead
and hit this transaction button,

5392
05:19:59.191 --> 05:20:02.191
which again, is going to be the
same as hitting this Send

5393
05:20:02.191 --> 05:20:05.191
button, but only sending one
way. What do you think will

5394
05:20:05.191 --> 05:20:10.191
happen? Well, let's try it. We
can see in the log area that we

5395
05:20:10.191 --> 05:20:14.191
did indeed send a transaction.
And if you look at the

5396
05:20:14.191 --> 05:20:17.191
description here, you can even
see it says from so and so to

5397
05:20:17.191 --> 05:20:22.192
fall back example, dot receive,
it looks like it called our

5398
05:20:22.192 --> 05:20:26.192
received function, which should
have updated our result to one.

5399
05:20:26.192 --> 05:20:30.192
So if we hit result, now we can
indeed see that result has been

5400
05:20:30.192 --> 05:20:33.192
updated to the value of one.
Well, let's go ahead and delete

5401
05:20:33.192 --> 05:20:38.192
this. Let's deploy this contract
again. And this time, let's have

5402
05:20:38.192 --> 05:20:42.192
this value be zero, does receive
get triggered this time. So

5403
05:20:42.192 --> 05:20:45.192
let's pull this down. Let's hit
transact. Let's leave the call

5404
05:20:45.192 --> 05:20:50.192
data blank, we'll leave value at
zero. So this will be the same

5405
05:20:50.192 --> 05:20:55.192
as if we had sent zero Aetherium
to this contract. Let's hit

5406
05:20:55.192 --> 05:20:58.192
transact. It looks like that
went through, do you think

5407
05:20:58.192 --> 05:21:02.192
result is going to be one or
zero? You thought one you were

5408
05:21:02.192 --> 05:21:05.192
correct or receive function gets
triggered anytime we send a

5409
05:21:05.192 --> 05:21:09.192
transaction to this contract
now, and we don't specify a

5410
05:21:09.192 --> 05:21:13.192
function. And we keep the call
data blank when working with any

5411
05:21:13.192 --> 05:21:16.192
other contract like Funmi. For
example, when we call one of

5412
05:21:16.192 --> 05:21:19.192
these functions, we're actually
just populating this call data

5413
05:21:19.192 --> 05:21:22.192
bit with certain data that
points to one of these functions

5414
05:21:22.192 --> 05:21:26.192
up here. If we send a
transaction and we add data to

5415
05:21:26.192 --> 05:21:29.192
it, we could actually call one
of these functions. Now let's

5416
05:21:29.192 --> 05:21:32.192
try this again. Let's delete the
contract again we'll redeploy

5417
05:21:32.192 --> 05:21:36.192
open this up result is currently
zero receive like I said only is

5418
05:21:36.192 --> 05:21:41.192
triggered if our call data to it
is blank. Now this time if I had

5419
05:21:41.192 --> 05:21:44.192
some call data to this
transaction, do you think

5420
05:21:44.192 --> 05:21:46.192
receive will be triggered this
time? If we hit transact and

5421
05:21:46.192 --> 05:21:50.192
remix we actually get a pop up
saying fallback function is not

5422
05:21:50.192 --> 05:21:53.192
defined. This is because
whenever data is sent with a

5423
05:21:53.192 --> 05:21:58.192
transaction solidity says, Oh,
well, since you're sending data

5424
05:21:58.192 --> 05:22:00.193
you're not looking for receive,
you're looking for some

5425
05:22:00.193 --> 05:22:04.193
function. So let me look for
that function for you. Hmm, I

5426
05:22:04.193 --> 05:22:08.193
don't see any function that
matches the 0x 00. So I'm going

5427
05:22:08.193 --> 05:22:11.193
to look for your fallback
function. Remix is smart enough

5428
05:22:11.193 --> 05:22:14.193
to know that we don't have a
fallback function. The second

5429
05:22:14.193 --> 05:22:17.193
special function in solidity is
called the fallback function.

5430
05:22:17.193 --> 05:22:21.193
This is very similar to the
receive function, except for the

5431
05:22:21.193 --> 05:22:24.193
fact that can work even when
data is sent along with

5432
05:22:24.193 --> 05:22:27.193
transaction. So our fallback
will look something like this

5433
05:22:27.193 --> 05:22:29.193
callback,

5434
05:22:29.193 --> 05:22:38.193
external payable. result equals
to Fallback is another one of

5435
05:22:38.193 --> 05:22:40.193
these functions where we're not
going to put the function

5436
05:22:40.193 --> 05:22:44.193
selector because solidity is
expecting this, actually, you're

5437
05:22:44.193 --> 05:22:47.193
already familiar with one other
special function, we go back to

5438
05:22:48.193 --> 05:22:52.193
our Funmi. Our constructor, for
example, is a another type of

5439
05:22:52.193 --> 05:22:56.193
special function. There's no
function keyword. solidity knows

5440
05:22:56.193 --> 05:22:58.193
that this constructor is
immediately called when we

5441
05:22:58.193 --> 05:23:02.193
deploy this contract. So now we
have our fallback function.

5442
05:23:02.193 --> 05:23:06.193
Let's go ahead and compile this.
Let's delete our old contract.

5443
05:23:06.193 --> 05:23:11.193
Let's go ahead and deploy this
new contract. Like here, we hit

5444
05:23:11.193 --> 05:23:15.193
result, we do indeed, see, it's
set to zero. Now, if I add this

5445
05:23:15.193 --> 05:23:21.193
0x 00, and I send this, and I
hit transact, this is equivalent

5446
05:23:21.193 --> 05:23:25.193
to calling our contract here
without a valid function. So our

5447
05:23:25.193 --> 05:23:27.193
contract goes, Huh, I don't
recognize what you're trying to

5448
05:23:27.193 --> 05:23:30.193
tell me here, I'm going to refer
you to our fallback. And now if

5449
05:23:30.193 --> 05:23:34.193
we hit result, we see that it's
been updated to two. If we take

5450
05:23:34.193 --> 05:23:38.193
this away, solidity will go,
Hmm, it looks like you're trying

5451
05:23:38.193 --> 05:23:40.194
to send some Aetherium, or call
this contract without specifying

5452
05:23:40.194 --> 05:23:43.194
what you want to do. Well, I
have a receipt function. So I'm

5453
05:23:43.194 --> 05:23:46.194
just gonna go ahead and forward
you to that. So if we call

5454
05:23:46.194 --> 05:23:50.194
transact, we hit result, we see
it updates back to one, add some

5455
05:23:50.194 --> 05:23:56.194
data, hit transact, we see it
updates to to no data, updates

5456
05:23:56.194 --> 05:24:00.194
to one slowly by example, that
org has a wonderful little chart

5457
05:24:00.194 --> 05:24:03.194
that we can use to figure out
whether or not receive is going

5458
05:24:03.194 --> 05:24:06.194
to get triggered, or Fallback is
going to get triggered. If it is

5459
05:24:06.194 --> 05:24:09.194
empty, and there's a receive
function, it'll call the receive

5460
05:24:09.194 --> 05:24:13.194
function. If it is data, and
there's no receive function,

5461
05:24:13.194 --> 05:24:16.194
it'll just go to the fallback
function. And if there's no

5462
05:24:16.194 --> 05:24:19.194
fallback function, it might just
it might air out. So this is a

5463
05:24:19.194 --> 05:24:22.194
lot of really fantastic
information here. How can we

5464
05:24:22.194 --> 05:24:26.194
apply this to our fund mi
contract here, or what we can do

5465
05:24:26.194 --> 05:24:30.194
now in our Funmi is we can add
these fallback and receive

5466
05:24:30.194 --> 05:24:34.194
functions, just in case somebody
actually sends us contract money

5467
05:24:34.194 --> 05:24:36.194
instead of calling the fund
function correctly. So what we

5468
05:24:36.194 --> 05:24:40.194
can do is let's add a receive
function. So if somebody

5469
05:24:40.194 --> 05:24:42.194
accidentally sends it money, we
can still process the

5470
05:24:42.194 --> 05:24:48.194
transaction will say receive is
going to be external payable.

5471
05:24:48.194 --> 05:24:52.194
And we'll just have the receive
function call fund. And we'll do

5472
05:24:52.194 --> 05:24:57.194
the same thing with our fallback
function will have fallback

5473
05:24:57.194 --> 05:25:04.194
external payable. We'll just
have it automatically call fund.

5474
05:25:04.194 --> 05:25:07.194
Now, if somebody accidentally
sends us money without calling

5475
05:25:07.194 --> 05:25:12.194
our fund function, it'll still
automatically route them over to

5476
05:25:12.194 --> 05:25:16.194
the fund function. This means to
that if somebody doesn't send us

5477
05:25:16.194 --> 05:25:19.194
enough funding, it'll, that
transaction will still get

5478
05:25:19.194 --> 05:25:22.195
reverted. So let's go ahead now.
And let's switch to rink B to

5479
05:25:22.195 --> 05:25:26.195
test this on a real test net,
Amman rink B and my Metamask.

5480
05:25:26.195 --> 05:25:31.195
Let's switch over to injected
web three. And we'll scroll down

5481
05:25:31.195 --> 05:25:34.195
we'll choose our Funmi contract.
And we'll go ahead and deploy

5482
05:25:34.195 --> 05:25:38.195
this Metamask pops up, I'm gonna
go ahead and confirm the

5483
05:25:38.195 --> 05:25:42.195
transaction. And we see our
Funmi contract here right now we

5484
05:25:42.195 --> 05:25:45.195
can see the owner we can see I'm
the owner, we can see minimum

5485
05:25:45.195 --> 05:25:49.195
USD. And we can see of course
that it's a blank contract, and

5486
05:25:49.195 --> 05:25:52.195
there's nothing funded in here.
If we the copy the address, and

5487
05:25:52.195 --> 05:25:58.195
then go to rink the ether scan,
paste the address in, we can see

5488
05:25:58.195 --> 05:26:01.195
that there's no ether in here.
And the only transaction

5489
05:26:01.195 --> 05:26:03.195
associated with this has been
the contract creation. We saw

5490
05:26:03.195 --> 05:26:06.195
what happened before when we hit
the fun function, our contract

5491
05:26:06.195 --> 05:26:11.195
was updated with a new balance,
and that funder was added to our

5492
05:26:11.195 --> 05:26:15.195
an array. Let's see what happens
now if we just directly send

5493
05:26:15.195 --> 05:26:19.195
this contract money without
calling the fund function here.

5494
05:26:19.195 --> 05:26:23.195
If we did this right, our
receive function should pick it

5495
05:26:23.195 --> 05:26:28.195
up and kick the transaction over
the font. So let's copy this

5496
05:26:28.195 --> 05:26:33.195
address. We'll go to our meta
mask. We'll hit send, paste the

5497
05:26:33.195 --> 05:26:38.195
address in here with 0.02 eath.
Again, because this should be

5498
05:26:38.195 --> 05:26:43.195
more than the minimum amount in
USD, we'll hit next. I'll go

5499
05:26:43.195 --> 05:26:47.195
ahead and confirm this. After a
slight delay, if we did this

5500
05:26:47.195 --> 05:26:51.195
right, we should see the
transaction having called the

5501
05:26:51.195 --> 05:26:55.195
fund function here, now that our
transaction has gone through

5502
05:26:55.195 --> 05:26:58.195
After a brief delay in waiting
for ethers can update, we do

5503
05:26:58.195 --> 05:27:02.196
indeed see that our balance has
updated to 0.02, which of

5504
05:27:02.196 --> 05:27:06.196
course, this makes sense. And we
see in the transactions list

5505
05:27:06.196 --> 05:27:09.196
here, we see that this actually
went through as a, as a transfer

5506
05:27:09.196 --> 05:27:12.196
instead of us calling the fund
function. Let's go ahead and

5507
05:27:12.196 --> 05:27:16.196
remix and see if our funders was
updated.

5508
05:27:16.196 --> 05:27:20.196
It looks like it was at the zero
with position of funders, we

5509
05:27:20.196 --> 05:27:23.196
have our address. And if we take
our address and pop it into

5510
05:27:23.196 --> 05:27:27.196
address to amount funded, we can
see exactly how much we had

5511
05:27:27.196 --> 05:27:30.196
funded. This means that since we
added this receive function in

5512
05:27:30.196 --> 05:27:34.196
here, we automatically had to
call our fun function up here.

5513
05:27:34.196 --> 05:27:38.196
So awesome work, we were able to
add a receive function to help

5514
05:27:38.196 --> 05:27:42.196
people who accidentally call the
wrong function or accidentally

5515
05:27:42.196 --> 05:27:45.196
send this contract money,
instead of correctly calling the

5516
05:27:45.196 --> 05:27:48.196
fun function. Now, if they had
directly called the fun

5517
05:27:48.196 --> 05:27:51.196
function, it would have cost
them a little bit less gas, but

5518
05:27:51.196 --> 05:27:54.196
at least this time, they're
gonna get credit and add it to

5519
05:27:54.196 --> 05:27:59.196
our funders array for having
sent our funding contract money.

5520
05:27:59.196 --> 05:28:03.196
We've even learned some advanced
sections of solidity. And this

5521
05:28:03.196 --> 05:28:05.196
is going to be the last time
that we start our projects in

5522
05:28:05.196 --> 05:28:10.196
remix, we're going to be moving
over to a code editor now, where

5523
05:28:10.196 --> 05:28:13.196
we can get even more advanced
with our solidity on our setups.

5524
05:28:13.196 --> 05:28:16.196
For the most part, you've gone
over the vast majority of

5525
05:28:16.196 --> 05:28:19.196
solidity basics, there are a
number of things that we still

5526
05:28:19.196 --> 05:28:21.196
haven't learned yet. And the
reason we haven't gotten into

5527
05:28:21.196 --> 05:28:24.196
them is because they get more
advanced. And understanding the

5528
05:28:24.196 --> 05:28:27.196
real use doesn't really make too
much sense until a little bit

5529
05:28:27.196 --> 05:28:30.196
later. Some of the things that
we're going to go over are itams

5530
05:28:30.196 --> 05:28:34.196
events, try catch function
selectors, abi encoding,

5531
05:28:34.196 --> 05:28:36.196
hashing, and then you will slash
and then you will slash

5532
05:28:36.196 --> 05:28:39.196
assembly. However, if you've
gotten this far, you probably

5533
05:28:39.196 --> 05:28:42.197
can read most solidity code and
understand what's going on,

5534
05:28:42.197 --> 05:28:45.197
which is absolutely fantastic.
So you should give yourself a

5535
05:28:45.197 --> 05:28:48.197
huge round of applause for
getting this far. And doing

5536
05:28:48.197 --> 05:28:51.197
this. Let's do a quick summary
of this more advanced section

5537
05:28:51.197 --> 05:28:54.197
and make sure we understand what
we learned in solidity there are

5538
05:28:54.197 --> 05:28:58.197
a couple special functions. Some
of them are receive fallback,

5539
05:28:58.197 --> 05:29:03.197
and Constructor. These functions
don't need to have the function

5540
05:29:03.197 --> 05:29:07.197
keyword. And instead it can just
be called like so. Receive and

5541
05:29:07.197 --> 05:29:10.197
fallback are two very special
functions. If data is sent with

5542
05:29:10.197 --> 05:29:14.197
a transaction, and no function
was specified, the transaction

5543
05:29:14.197 --> 05:29:17.197
will default to the fallback
function if that fallback

5544
05:29:17.197 --> 05:29:20.197
function exists. If data is
empty, and there's a receive

5545
05:29:20.197 --> 05:29:24.197
function, it'll call the receive
function. There are a couple of

5546
05:29:24.197 --> 05:29:28.197
keywords that can help us save
gas in the long run. Some of

5547
05:29:28.197 --> 05:29:31.197
those keywords are going to be
constant and immutable. Constant

5548
05:29:31.197 --> 05:29:34.197
and immutable are for variables
that can only be declared and

5549
05:29:34.197 --> 05:29:39.197
updated once. Once we say
minimum USD is 50 times 118.

5550
05:29:39.197 --> 05:29:43.197
This minimum USD can never be
changed again. And this helps us

5551
05:29:43.197 --> 05:29:47.197
save gas. Immutable can also
save gas similar to constant.

5552
05:29:47.197 --> 05:29:50.197
However, immutable variables can
be declared one time in the

5553
05:29:50.197 --> 05:29:55.197
constructor, once an immutable
variable is declared, it can't

5554
05:29:55.197 --> 05:29:58.197
be changed later on. In fact, if
we even tried to update an

5555
05:29:58.197 --> 05:30:02.197
immutable variable or constant
variable, and we compiled, a

5556
05:30:02.197 --> 05:30:06.197
compiler would give us an error
saying, Can't write to a mutable

5557
05:30:06.197 --> 05:30:11.197
here. Or if we tried to change a
constant variable. Our compiler

5558
05:30:11.197 --> 05:30:14.197
would say, Hey, you can't assign
to a constant variable, sorry.

5559
05:30:14.197 --> 05:30:17.197
In remix, if we want to send
ether to a contract that's on

5560
05:30:17.197 --> 05:30:21.198
the JavaScript virtual machine,
we can deploy that contract. And

5561
05:30:21.198 --> 05:30:24.198
then in the contract, we can
just hit the transact button

5562
05:30:24.198 --> 05:30:27.198
without any call data and update
the value that we send with the

5563
05:30:27.198 --> 05:30:30.198
transaction. If call data is
blank, it will trigger the

5564
05:30:30.198 --> 05:30:34.198
receive function if it exists.
But if there's data that doesn't

5565
05:30:34.198 --> 05:30:37.198
specify any of the other
functions, it'll trigger the

5566
05:30:37.198 --> 05:30:47.198
fallback function

5567
05:30:47.198 --> 05:30:50.198
Awesome, you've done
fantastically to get this far.

5568
05:30:50.198 --> 05:30:54.198
And for this section before we
get started actually moving over

5569
05:30:54.198 --> 05:30:57.198
to Hardhead. And moving over to
JavaScript and understanding why

5570
05:30:57.198 --> 05:31:00.198
we need to do that. Let's
understand a little bit about

5571
05:31:00.198 --> 05:31:03.198
getting help and running into
problems. So let's say we have

5572
05:31:03.198 --> 05:31:07.198
our Funmi contract here that we
just worked on. And we run into

5573
05:31:07.198 --> 05:31:11.198
an error. Let's say for example,
we forgot the payable keyword,

5574
05:31:11.198 --> 05:31:15.198
right, and we go ahead and
compile this compile fund, we

5575
05:31:15.198 --> 05:31:18.198
did so. And we scroll down. And
we see obviously, we have two

5576
05:31:18.198 --> 05:31:20.198
errors here, right, we're
getting some errors, and we

5577
05:31:20.198 --> 05:31:25.198
scroll down. And we see type
error message dot value and call

5578
05:31:25.198 --> 05:31:28.198
value can only be used and
payable public functions, make

5579
05:31:28.198 --> 05:31:31.198
the function payable or using an
internal function to avoid this

5580
05:31:31.198 --> 05:31:34.198
error. And then it goes ahead
and gives the line that's

5581
05:31:34.198 --> 05:31:38.198
airing. Now this error is pretty
clear, this error code is pretty

5582
05:31:38.198 --> 05:31:41.198
clear. It's saying Hey, make the
function payable, or using an

5583
05:31:41.198 --> 05:31:44.198
internal function to avoid this
error, right? This should be

5584
05:31:44.198 --> 05:31:48.198
pretty easy to to add payable,
and then recompile and be good

5585
05:31:48.198 --> 05:31:51.198
to go. And this is actually a
good example of what to do when

5586
05:31:51.198 --> 05:31:53.198
you run into errors. When you
run into errors. The first thing

5587
05:31:53.198 --> 05:31:56.198
you want to do is you want to
try to figure out exactly what's

5588
05:31:56.198 --> 05:32:00.199
going on yourself based off of
what the error says. This one's

5589
05:32:00.199 --> 05:32:02.199
pretty straightforward, but some
of them can be a little bit more

5590
05:32:02.199 --> 05:32:06.199
obscure step one when trying to
get unblocked trying to tinker

5591
05:32:06.199 --> 05:32:10.199
and figure out errors yourself,
right? Because maybe you go

5592
05:32:10.199 --> 05:32:14.199
okay, I'll make this payable,
right? And you go to save. And

5593
05:32:14.199 --> 05:32:17.199
then it gives a different error
saying, hey, you know, payable

5594
05:32:17.199 --> 05:32:21.199
doesn't go here. You resave you
recompile it goes, Hey, we're

5595
05:32:21.199 --> 05:32:24.199
still missing that payable
thing. First step is always

5596
05:32:24.199 --> 05:32:27.199
going to be trying to tinker and
figure it out yourself. For this

5597
05:32:27.199 --> 05:32:31.199
course, I want you to limit
tinkering, slash triaging to 20

5598
05:32:31.199 --> 05:32:36.199
minutes, if you take more than
20 minutes to tinker and triage,

5599
05:32:36.199 --> 05:32:40.199
then move on to the next step.
But I also want you to take at

5600
05:32:40.199 --> 05:32:48.199
least 15 minutes yourself or be
100% Sure, you exhausted all

5601
05:32:48.199 --> 05:32:51.199
options, you're completely out
of ideas. So typically try to

5602
05:32:51.199 --> 05:32:55.199
tinker try some stuff for 15
minutes. And if you're under 15

5603
05:32:55.199 --> 05:32:58.199
minutes, and you're saying, Hey,
I'm 100% Certain I've tried

5604
05:32:58.199 --> 05:33:01.199
everything that I can think of,
then you can move on to the next

5605
05:33:01.199 --> 05:33:04.199
step. So step one, when you run
into errors is always going to

5606
05:33:04.199 --> 05:33:11.199
be tinker and try to pinpoint
exactly what's going on. Try to

5607
05:33:11.199 --> 05:33:14.199
pinpoint exactly what's going
wrong. Step two, let's say you

5608
05:33:14.199 --> 05:33:16.199
tinkered and you tried payable
all over the place, and you

5609
05:33:16.199 --> 05:33:19.199
couldn't figure out what this
error was and how to debug this

5610
05:33:19.199 --> 05:33:24.199
here. Step two is always going
to be Google the exact error and

5611
05:33:24.199 --> 05:33:27.199
see if you can learn from that.
So zoom out a little bit, I'll

5612
05:33:27.199 --> 05:33:32.199
roll my mouse over this, grab
this, copy it, or quotes around

5613
05:33:32.199 --> 05:33:36.199
it, and do exactly that, in
Google search that exact error

5614
05:33:36.199 --> 05:33:38.199
and take some time going through
Google going through Stack

5615
05:33:38.199 --> 05:33:41.200
Overflow going through Stack
Exchange eath, and look to see

5616
05:33:41.200 --> 05:33:44.200
if somebody has asked this
question already. And it looks

5617
05:33:44.200 --> 05:33:47.200
like down here looks like
somebody has type error missed a

5618
05:33:47.200 --> 05:33:49.200
value and call though can only
be used on PayPal public

5619
05:33:49.200 --> 05:33:53.200
functions. And if we scroll
down, we see that somebody ran

5620
05:33:53.200 --> 05:33:56.200
into exactly this. And they went
ahead and solved it. They go, I

5621
05:33:56.200 --> 05:33:59.200
realized my mistake, I needed to
add the PayPal keyword to my own

5622
05:33:59.200 --> 05:34:02.200
implementation. And they go
ahead in this question, they've

5623
05:34:02.200 --> 05:34:05.200
added the payable. And hopefully
this would give you the insight

5624
05:34:05.200 --> 05:34:08.200
to say, Ah, okay, great. I do
need to come back here and add

5625
05:34:08.200 --> 05:34:11.200
payable. Let's say this
StackOverflow question didn't

5626
05:34:11.200 --> 05:34:14.200
show up. Right? This forum
wasn't here. What do we do next?

5627
05:34:14.200 --> 05:34:19.200
So step one, tinker. Step two,
Google the exact error, I'm

5628
05:34:19.200 --> 05:34:25.200
going to do a step 2.5 That only
is for this class, go to our

5629
05:34:25.200 --> 05:34:30.200
GitHub, repo discussions, and or
updates for this course,

5630
05:34:30.200 --> 05:34:34.200
specifically, go to this GitHub
repo, full blockchain solidity

5631
05:34:34.200 --> 05:34:36.200
course, Jas, it'll look a little
bit different when you all get

5632
05:34:36.200 --> 05:34:39.200
to it. But come to this repo,
and look in this chronological

5633
05:34:39.200 --> 05:34:43.200
update section to see if there's
an update on that section that

5634
05:34:43.200 --> 05:34:46.200
you're doing. Obviously, since
I'm recording right now, there's

5635
05:34:46.200 --> 05:34:50.200
no update. And if you don't get
anything, feel free to jump into

5636
05:34:50.200 --> 05:34:52.200
the discussion section. And ask
a question in here, right,

5637
05:34:52.200 --> 05:34:55.200
there's going to be a community
of people looking to help each

5638
05:34:55.200 --> 05:34:58.200
other out and looking to make
this a lot of fun. And the

5639
05:34:58.200 --> 05:35:02.200
reason I say 2.5 is because in
the real world, you're not going

5640
05:35:02.200 --> 05:35:05.200
to have our GitHub repo, when
working on stuff outside of this

5641
05:35:05.200 --> 05:35:09.200
course, you're not going to have
this GitHub repo. So instead, in

5642
05:35:09.200 --> 05:35:11.200
the real world, I'm still going
to give you the keys, I'm going

5643
05:35:11.200 --> 05:35:15.200
to give you what it takes to
still unblock yourself on

5644
05:35:15.200 --> 05:35:19.200
anything. Okay. So number three
is going to be asked a question

5645
05:35:19.200 --> 05:35:27.201
on a forum, like stack, exchange
eath and Stack Overflow. Stack

5646
05:35:27.201 --> 05:35:31.201
Overflow is a question and
answering tech forum like this,

5647
05:35:31.201 --> 05:35:35.201
right? You can ask tech
questions, and then you can

5648
05:35:35.201 --> 05:35:38.201
answer them as well. And as you
can see, when you search for

5649
05:35:38.201 --> 05:35:41.201
these issues, they'll show up so
Stack Overflow is more for

5650
05:35:41.201 --> 05:35:45.201
general Role programming
questions and Stack Exchange

5651
05:35:45.201 --> 05:35:50.201
Aetherium or Stack Exchange eath
Aetherium Stack Exchange, this

5652
05:35:50.201 --> 05:35:53.201
is for more Aetherium or EVM
based question and all the

5653
05:35:53.201 --> 05:35:56.201
solidity code that we're gonna
be working with, whether it's

5654
05:35:56.201 --> 05:35:59.201
polygon, whether it's avalanche,
whether it's whatever, those

5655
05:35:59.201 --> 05:36:03.201
questions are going to be valid
here, and you can ask here. So

5656
05:36:03.201 --> 05:36:06.201
what you'd want to do is you'd
want to sign up or log in, and

5657
05:36:06.201 --> 05:36:09.201
ask and format your questions on
these forms, you'll want to sign

5658
05:36:09.201 --> 05:36:11.201
up for GitHub, you want to sign
up for Stack Exchange, you'll

5659
05:36:11.201 --> 05:36:14.201
want to sign up for Stack
Overflow, so you can participate

5660
05:36:14.201 --> 05:36:17.201
in these forums. In fact, if you
haven't already, let's sign up

5661
05:36:17.201 --> 05:36:20.201
for GitHub right now. And let me
walk you through formatting one

5662
05:36:20.201 --> 05:36:22.201
of these questions, because the
better you format your

5663
05:36:22.201 --> 05:36:25.201
questions, the better chance you
have of actually getting the

5664
05:36:25.201 --> 05:36:27.201
answer. And remember, when
asking questions on these

5665
05:36:28.201 --> 05:36:31.201
forums, when asking questions,
in these discussion communities,

5666
05:36:31.201 --> 05:36:34.201
people answer these questions
out of the goodness of their

5667
05:36:34.201 --> 05:36:37.201
heart, right? So if you don't
get a response, there's a chance

5668
05:36:37.201 --> 05:36:40.201
that maybe nobody knows, maybe
it's your question isn't

5669
05:36:40.201 --> 05:36:43.201
formatted very well, and etc. So
we're going to learn how to ask

5670
05:36:43.201 --> 05:36:46.201
really good questions here. And
if you're new to blockchain, do

5671
05:36:46.201 --> 05:36:49.201
not skip this section. Okay,
this is going to be that piece

5672
05:36:49.201 --> 05:36:51.201
that's going to give you the
superpower to unblock yourself

5673
05:36:51.201 --> 05:36:54.201
from any coding issue you run
into. So don't skip this

5674
05:36:54.201 --> 05:36:57.201
powerup. Be sure to follow
along. Okay. So if you don't

5675
05:36:57.201 --> 05:37:00.201
have a GitHub already, you do
need an email to get started. So

5676
05:37:00.202 --> 05:37:03.202
I'm going to go ahead and sign
in, I made a burner account just

5677
05:37:03.202 --> 05:37:05.202
for this video. So what we're
gonna do, we're gonna go ahead

5678
05:37:05.202 --> 05:37:16.202
and sign up GitHub, enter your
email

5679
05:37:16.202 --> 05:37:18.202
and we hit Create Account,
they're going to send us an

5680
05:37:18.202 --> 05:37:20.202
email. So we're going to come
back to our email, and we got

5681
05:37:20.202 --> 05:37:25.202
our launch code here, paste it
in. And so a little bit of

5682
05:37:25.202 --> 05:37:32.202
information. We're going to
choose the free version. and

5683
05:37:32.202 --> 05:37:35.202
fantastic. We've now created a
GitHub profile. Now back over in

5684
05:37:35.202 --> 05:37:39.202
the smart contract kid full
blockchain solidity course, Jas,

5685
05:37:39.202 --> 05:37:41.202
I'm going to create a new
discussion, a new thread, and I

5686
05:37:41.202 --> 05:37:44.202
want you all to comment on to
make sure you understand how to

5687
05:37:44.202 --> 05:37:47.202
format and how to ask questions.
Okay, general thread for

5688
05:37:47.202 --> 05:37:53.202
practicing. Question formatting.
Oops. And so let's go back here.

5689
05:37:53.202 --> 05:37:57.202
So first, I'm going to format
this question poorly, two ways,

5690
05:37:57.202 --> 05:38:00.202
and then we're gonna format it
really, really well. So the

5691
05:38:00.202 --> 05:38:03.202
first way we're going to format
it poorly, is by not giving

5692
05:38:03.202 --> 05:38:07.202
enough information. So what
we're going to do is I'm gonna

5693
05:38:07.202 --> 05:38:11.202
just copy this issue we're going
to do is we'll just say like,

5694
05:38:11.202 --> 05:38:19.202
Hey, I'm having trouble with
remix and an error. Can someone

5695
05:38:19.202 --> 05:38:23.202
help me? Why is this not a well
formatted question? If this is

5696
05:38:23.202 --> 05:38:27.202
my question, there's not nearly
enough information here, I, as a

5697
05:38:27.202 --> 05:38:30.202
helper, have no idea what this
person's asking. So let's do

5698
05:38:30.202 --> 05:38:34.202
something else. What I'm going
to do is I'm going to copy this

5699
05:38:34.202 --> 05:38:39.202
entire contract all the fun,
read outsole, paste it in here,

5700
05:38:39.202 --> 05:38:45.203
and go, Hi, I'm having issues
here. Can someone help? I'm

5701
05:38:46.203 --> 05:38:49.203
gonna head start discussion here
want to hit start discussion, it

5702
05:38:49.203 --> 05:38:52.203
formats this all weird. And once
again, there's not really enough

5703
05:38:52.203 --> 05:38:56.203
information here. I don't know
what the issue is. But at least

5704
05:38:56.203 --> 05:38:58.203
with this one, we have some
code, we have some way to

5705
05:38:58.203 --> 05:39:00.203
actually debug. So this is a
little bit better. But it's

5706
05:39:00.203 --> 05:39:03.203
still not that good. Let's go
ahead and edit this. To make

5707
05:39:03.203 --> 05:39:06.203
this even better. We hit three
dots, we can hit edit, what we

5708
05:39:06.203 --> 05:39:10.203
can do is we can use something
called Markdown syntax, and

5709
05:39:10.203 --> 05:39:13.203
highly recommend learning a
little bit of markdown, it's

5710
05:39:13.203 --> 05:39:17.203
basically some syntax help make
discussions on GitHub. And also,

5711
05:39:17.203 --> 05:39:21.203
questions on Stack Overflow and
Stack Exchange a lot easier. So

5712
05:39:21.203 --> 05:39:25.203
we're going to format this code
by adding these three backticks

5713
05:39:25.203 --> 05:39:31.203
at the start, and then also at
the end of our code. And then

5714
05:39:31.203 --> 05:39:34.203
additionally, next, the first
three backticks, we're going to

5715
05:39:34.203 --> 05:39:40.203
type so lid did T which tells
the format or to to use solidity

5716
05:39:40.203 --> 05:39:44.203
to format this code here. Now if
we update discussion, we notice

5717
05:39:44.203 --> 05:39:49.203
we get some nice highlighting
here. So this becomes much, much

5718
05:39:49.203 --> 05:39:53.203
easier to read. Right? This is
way easier to read now than than

5719
05:39:53.203 --> 05:39:57.203
it was before. However, it's
still not specific enough. We've

5720
05:39:57.203 --> 05:40:00.203
given a ton of code here, and we
haven't given the specific

5721
05:40:00.203 --> 05:40:03.203
answer. So this is gonna be
really hard for somebody to

5722
05:40:03.203 --> 05:40:06.203
answer. So let's make this more
specific. So let's edit this

5723
05:40:06.203 --> 05:40:10.203
question again. And let's
specify, so we see here, our

5724
05:40:10.203 --> 05:40:15.203
issue is specifically on this
function. We're going to copy

5725
05:40:15.203 --> 05:40:19.203
this function and we're going to
delete everything else in here.

5726
05:40:19.203 --> 05:40:23.204
And now we have just this code
inside of here. Now we're going

5727
05:40:23.204 --> 05:40:26.204
to make this really specific.
We're going to say, on this

5728
05:40:26.204 --> 05:40:31.204
function, I'm running into an
error. And then what we're going

5729
05:40:31.204 --> 05:40:33.204
to do is we're going to come
back here, we're going to roll

5730
05:40:33.204 --> 05:40:36.204
the over this. We're going to
copy this we could have pull our

5731
05:40:36.204 --> 05:40:39.204
code if we want but we're going
to format this error like this.

5732
05:40:39.204 --> 05:40:44.204
And then we're gonna say Can
someone tell me What's going on?

5733
05:40:44.204 --> 05:40:49.204
Update? Now this is a much, much
easier question to debug. Right?

5734
05:40:49.204 --> 05:40:52.204
We have some minimalistic code,
we have the error that we're

5735
05:40:52.204 --> 05:40:56.204
getting. And we have Can someone
tell me what's going on?

5736
05:40:56.204 --> 05:41:00.204
Obviously, the answer to this
would be to add payable to this.

5737
05:41:00.204 --> 05:41:02.204
And that's what somebody would
say, hey, like, you need to add

5738
05:41:02.204 --> 05:41:04.204
payable to this, I want you all
to practice doing some

5739
05:41:04.204 --> 05:41:08.204
formatting, go ahead and add a
comment on this with your own

5740
05:41:08.204 --> 05:41:11.204
formatted question. So that you
understand how to actually do

5741
05:41:11.204 --> 05:41:14.204
the formatting. And this
markdown format. It's this

5742
05:41:14.204 --> 05:41:17.204
format here, that's gonna be the
exact same for asking questions

5743
05:41:17.204 --> 05:41:21.204
on Stack Overflow, or Stack
Exchange for this course, go

5744
05:41:21.204 --> 05:41:24.204
ahead and practice if you want
to create more new discussions,

5745
05:41:24.204 --> 05:41:27.204
feel free to create new
discussions. If you want to use

5746
05:41:27.204 --> 05:41:31.204
Stack Overflow or Stack Exchange
eath actually highly recommend

5747
05:41:31.204 --> 05:41:33.204
you Stack Overflow or Stack
Exchange eath as well, because

5748
05:41:33.204 --> 05:41:37.204
those are gonna get indexed a
lot better than GitHub here.

5749
05:41:37.204 --> 05:41:39.204
However, feel free to ask
questions, obviously, in this

5750
05:41:39.204 --> 05:41:42.204
GitHub as well. Now that I've
given you kind of the basics

5751
05:41:42.204 --> 05:41:45.204
rundown, we're going to watch a
video that I made that goes even

5752
05:41:45.204 --> 05:41:48.204
deeper into why and how to
format all these questions and

5753
05:41:48.204 --> 05:41:50.204
what to use. So let's go ahead

5754
05:41:50.204 --> 05:42:00.204
and watch that. Every developer
has run into this. Something

5755
05:42:00.204 --> 05:42:01.205
breaks or maybe you don't know
something, but you don't have

5756
05:42:01.205 --> 05:42:04.205
time to let these stop you.
There are a series of steps that

5757
05:42:04.205 --> 05:42:08.205
one should take to maximize
one's chances of solving any

5758
05:42:08.205 --> 05:42:11.205
coding problem, but you'd be
surprised at how few developers

5759
05:42:11.205 --> 05:42:14.205
currently use the superpower
effectively, our first one we'll

5760
05:42:14.205 --> 05:42:16.205
spend the least time on, because
it's just tinker and experiment.

5761
05:42:16.205 --> 05:42:19.205
When you run into an issue. Keep
trying different things you

5762
05:42:19.205 --> 05:42:21.205
think might work, maybe try
doing print statements

5763
05:42:21.205 --> 05:42:23.205
throughout the file, learn some
debugging tips, but don't be so

5764
05:42:23.205 --> 05:42:27.205
cocky that you only do this
first step. And this shouldn't

5765
05:42:27.205 --> 05:42:30.205
just be random running around.
This should be trying to

5766
05:42:30.205 --> 05:42:33.205
pinpoint exactly what's going
wrong in your code, so that you

5767
05:42:33.205 --> 05:42:36.205
can either ask an effective
question, or figure it out

5768
05:42:36.205 --> 05:42:39.205
yourself. So pinpoint exactly
what's going wrong, because

5769
05:42:39.205 --> 05:42:42.205
you'll need it for the next
steps. Anyways, next, check the

5770
05:42:42.205 --> 05:42:46.205
documentation. Not all tools
have good documentation. But

5771
05:42:46.205 --> 05:42:49.205
taking some time to explore
documentation can be a quick way

5772
05:42:49.205 --> 05:42:52.205
to find your answer, you'll want
to learn how to search a webpage

5773
05:42:52.205 --> 05:42:55.205
with Command F or Control F.
That way, you can look for

5774
05:42:55.205 --> 05:42:58.205
specific keywords on a page, or
hopefully they have a good

5775
05:42:58.205 --> 05:43:01.205
search bar that works well.
Sometimes documentation can be

5776
05:43:01.205 --> 05:43:03.205
really dense. So maybe you'll
move to the next step, which is

5777
05:43:03.205 --> 05:43:06.205
doing a web search. At the end
of the day, good software

5778
05:43:06.205 --> 05:43:09.205
engineers are secretly just
professional Googlers. And this

5779
05:43:09.205 --> 05:43:12.205
is one of their most powerful
tools, being able to search the

5780
05:43:12.205 --> 05:43:15.205
web for somebody else who has
already run into the problem

5781
05:43:15.205 --> 05:43:17.205
that you've just run into, and
then solved it. Most search

5782
05:43:17.205 --> 05:43:20.205
engines like Google have tools
you can use to get even more

5783
05:43:20.205 --> 05:43:23.205
specific about what you're
looking for. Often for specific

5784
05:43:23.205 --> 05:43:26.205
errors, the best thing to do is
actually just copy the exact

5785
05:43:26.205 --> 05:43:29.205
error and paste it in the search
bar with quotes or use the

5786
05:43:29.205 --> 05:43:32.205
Asterix in spots, your error
might be too specific. Most of

5787
05:43:32.205 --> 05:43:36.205
the results you'll get will be
from forums and q&a sites, which

5788
05:43:36.205 --> 05:43:38.205
leads us to our next step,
asking questions in these forums

5789
05:43:38.205 --> 05:43:42.206
and q&a sites. Just make sure
that before you ask a question,

5790
05:43:42.206 --> 05:43:46.206
you've done some ample Googling
around yourself beforehand. This

5791
05:43:46.206 --> 05:43:49.206
way you don't waste yours and
anybody else's time. And by

5792
05:43:49.206 --> 05:43:52.206
asking questions that you swear
you will promise me that at some

5793
05:43:52.206 --> 05:43:56.206
point, you will go back and help
other people learn as well got

5794
05:43:56.206 --> 05:43:59.206
it good. Before even asking your
question though, we should learn

5795
05:43:59.206 --> 05:44:03.206
where is going to be the best
place to ask. This is why I've

5796
05:44:03.206 --> 05:44:07.206
categorized for different types
of forums and QA sites, feel

5797
05:44:07.206 --> 05:44:10.206
free to pause to read them over.
And here's some specific

5798
05:44:10.206 --> 05:44:13.206
examples of each one of these
index code base forms like Stack

5799
05:44:13.206 --> 05:44:17.206
Overflow, index repositories
like GitHub issues, index

5800
05:44:17.206 --> 05:44:21.206
technology, specific forums,
like our slash eat dev or

5801
05:44:21.206 --> 05:44:24.206
unindexed discussion platforms
like chainlink discord, one of

5802
05:44:24.206 --> 05:44:28.206
the key differentiators in these
categories is the index keyword.

5803
05:44:28.206 --> 05:44:31.206
We typically want to ask
questions on forums that web

5804
05:44:31.206 --> 05:44:34.206
crawlers have gone through and
stuck them in their database or

5805
05:44:34.206 --> 05:44:37.206
index them this way. And three
weeks when we look back at the

5806
05:44:37.206 --> 05:44:40.206
code that we wrote, we can just
Google what was going on when we

5807
05:44:40.206 --> 05:44:43.206
forget what it does. And this
will help out other developers

5808
05:44:43.206 --> 05:44:46.206
who run into the same problem,
which in turn, they might go

5809
05:44:46.206 --> 05:44:49.206
ahead and help you out later.
Ideally, most of your questions

5810
05:44:49.206 --> 05:44:52.206
should be asked on one of these
index forms for this reason for

5811
05:44:52.206 --> 05:44:54.206
their searchability and
discoverability. However, at

5812
05:44:54.206 --> 05:44:58.206
some questions are a better fit
for DMS, Twitter or discord that

5813
05:44:58.206 --> 05:45:00.206
aren't index and we made a
little chart here to figure out

5814
05:45:00.206 --> 05:45:03.206
where's the best place to post
your questions, feel free to

5815
05:45:03.206 --> 05:45:05.206
pause the video take a look or
read our blog and the

5816
05:45:05.206 --> 05:45:07.206
descriptions with the picture as
well to take another look at it.

5817
05:45:07.206 --> 05:45:10.206
And of course, before actually
posting that in one of these

5818
05:45:10.206 --> 05:45:13.206
forums, be sure to read their
rules as they might state that

5819
05:45:13.206 --> 05:45:15.206
some kind of questions are
specifically for Ben. But

5820
05:45:15.206 --> 05:45:19.206
basically the breakdown looks
like this. Theoretical big

5821
05:45:19.206 --> 05:45:23.207
picture or opinionated questions
can go great on general q&a

5822
05:45:23.207 --> 05:45:27.207
forums like Quora or specific
technical forums like specific

5823
05:45:27.207 --> 05:45:31.207
subreddits or discord forums,
specific coding questions can go

5824
05:45:31.207 --> 05:45:35.207
on these forums as well, but
will often get more eyes on

5825
05:45:35.207 --> 05:45:38.207
coding forums like Stack
Overflow or Stack Exchange

5826
05:45:38.207 --> 05:45:41.207
communities often the question
of Oh, should I post this on

5827
05:45:41.207 --> 05:45:45.207
stack URL? flow or maybe a Stack
Exchange community is incredibly

5828
05:45:45.207 --> 05:45:47.207
blurry. And sometimes it doesn't
really matter which one you post

5829
05:45:47.207 --> 05:45:51.207
on. Now, if you run into a bug
or an issue with a technology

5830
05:45:51.207 --> 05:45:54.207
you're really familiar with, and
you think it shouldn't be

5831
05:45:54.207 --> 05:45:57.207
breaking, this is your chance to
pop an issue into their open

5832
05:45:57.207 --> 05:46:00.207
source code repository and
potentially improve the tool.

5833
05:46:00.207 --> 05:46:03.207
They don't have an open source
code repository, you throw that

5834
05:46:03.207 --> 05:46:06.207
closed source piece of shit into
the garbage, but just kidding

5835
05:46:06.207 --> 05:46:09.207
closed source Tech has its place
in our lives, too. Additionally,

5836
05:46:09.207 --> 05:46:12.207
if you're following a tutorial,
and they have a Git repo

5837
05:46:12.207 --> 05:46:16.207
associated with it, like all of
my videos that do, that's gonna

5838
05:46:16.207 --> 05:46:19.207
be the best place to leave your
issues. So as much as I hate to

5839
05:46:19.207 --> 05:46:22.207
say it, putting your issues onto
my GitHub repositories is going

5840
05:46:22.207 --> 05:46:25.207
to be much more effective for us
answering your questions than

5841
05:46:25.207 --> 05:46:29.207
posting it in the YouTube
comments. Now finally, Discord,

5842
05:46:29.207 --> 05:46:33.207
element, email, text message or
any other these unindexed chats

5843
05:46:33.207 --> 05:46:36.207
are still good places to ask
questions, but please try to use

5844
05:46:36.207 --> 05:46:39.207
them as a last resort. And if
they do end up answering one of

5845
05:46:39.207 --> 05:46:42.207
your questions, maybe go back
and add that question and answer

5846
05:46:42.207 --> 05:46:44.207
to one of the other forums that
we were talking about this way

5847
05:46:44.207 --> 05:46:47.207
it will be indexed next time you
or somebody else, Google's it

5848
05:46:47.207 --> 05:46:50.207
now these quicker chat forums
are places more for the

5849
05:46:50.207 --> 05:46:53.207
community to congregate and have
quick conversations with each

5850
05:46:53.207 --> 05:46:56.207
other. They're places to theory
craft, talk about new things

5851
05:46:56.207 --> 05:47:00.207
coming out new ideas, events,
and other things that shouldn't

5852
05:47:00.207 --> 05:47:03.208
be indexed by web crawlers.
They're also great places to

5853
05:47:03.208 --> 05:47:06.208
meet and network with people
that you might be able to bounce

5854
05:47:06.208 --> 05:47:09.208
ideas off directly as you get to
know each other, which leads

5855
05:47:09.208 --> 05:47:12.208
into our last section. But
before we do that, Oh, do you

5856
05:47:12.208 --> 05:47:17.208
hear that? Oh, that's the video
inside another video alarm

5857
05:47:17.208 --> 05:47:20.208
ringing. When you ask a question
in one of these forums, the

5858
05:47:20.208 --> 05:47:22.208
better you format your
questions, the better chance

5859
05:47:22.208 --> 05:47:25.208
you'll have of getting an
answered. Now there's no bad

5860
05:47:25.208 --> 05:47:28.208
questions out there. But there
are poorly formatted questions.

5861
05:47:28.208 --> 05:47:31.208
So let's teach you how to always
ask questions as format as best

5862
05:47:31.208 --> 05:47:34.208
as possible to give you the
highest chance of making sure

5863
05:47:34.208 --> 05:47:37.208
they get answered. Number one,
before asking your question,

5864
05:47:37.208 --> 05:47:40.208
make sure you followed all the
steps in the parent video. And

5865
05:47:40.208 --> 05:47:43.208
you've done some research on
this already and make sure the

5866
05:47:43.208 --> 05:47:46.208
question hasn't already been
asked. Number two, make a title

5867
05:47:46.208 --> 05:47:50.208
that summarizes the specifics of
the question three introduced

5868
05:47:50.208 --> 05:47:53.208
the problem before you write any
code, add minimalistic,

5869
05:47:53.208 --> 05:47:57.208
reproducible code minimalistic
code means it's not just a copy

5870
05:47:57.208 --> 05:48:00.208
paste your entire file. If
you're having problems on one

5871
05:48:00.208 --> 05:48:04.208
line, maybe just post that one
line reproducible code means

5872
05:48:04.208 --> 05:48:07.208
that others should be able to
run to the exact same error that

5873
05:48:07.208 --> 05:48:11.208
you're running into, or at least
post the steps for them to do

5874
05:48:11.208 --> 05:48:14.208
it. This doesn't mean that you
should put I was following along

5875
05:48:14.208 --> 05:48:17.208
Patrick's video and on our five
I ran into this problem, just

5876
05:48:17.208 --> 05:48:20.208
watch his video and you'll get
there. As flattering as this is

5877
05:48:20.208 --> 05:48:22.208
it's not reasonable that
everyone is going to have

5878
05:48:22.208 --> 05:48:25.208
watched my videos, even though
they should you want to give the

5879
05:48:25.208 --> 05:48:28.208
technical steps to reach the
error that you've reached. For

5880
05:48:28.208 --> 05:48:30.208
those of you watching my Free
Code Camp video, you're kind of

5881
05:48:30.208 --> 05:48:34.208
exempt from this, but you can
only say, Hey, I was on our Five

5882
05:48:34.208 --> 05:48:37.208
on this part of your video
inside of our discussions tab of

5883
05:48:37.208 --> 05:48:41.209
the GitHub repo associated with
this course. So you can do that.

5884
05:48:41.209 --> 05:48:44.209
But only in that GitHub repo
associated with this course,

5885
05:48:44.209 --> 05:48:48.209
learning markdown to format your
code, especially using these

5886
05:48:48.209 --> 05:48:53.209
three backticks and labeling of
the language. This is a critical

5887
05:48:53.209 --> 05:48:56.209
piece of formatting your code
and will drastically improve on

5888
05:48:56.209 --> 05:48:59.209
the number of people who answer
your questions. Any errors or

5889
05:48:59.209 --> 05:49:03.209
code should be formatted with
this three backticks syntax. And

5890
05:49:03.209 --> 05:49:06.209
finally, often people who care
about certain technologies,

5891
05:49:06.209 --> 05:49:10.209
monitor specific tags and
monitor specific questions being

5892
05:49:10.209 --> 05:49:12.209
asked about the technologies
that they like. And then

5893
05:49:12.209 --> 05:49:15.209
finally, again, be sure to read
the forum's guides before

5894
05:49:15.209 --> 05:49:18.209
posting different forums have
different rules about what they

5895
05:49:18.209 --> 05:49:21.209
want and what they don't want.
So being familiar will increase

5896
05:49:21.209 --> 05:49:24.209
your chances of getting an
answer. All right. So now back

5897
05:49:24.209 --> 05:49:26.209
to the main video. Now a note
about Stack Overflow, in

5898
05:49:26.209 --> 05:49:30.209
particular, Stack Overflow can
be a little aggressive, which is

5899
05:49:30.209 --> 05:49:32.209
why sometimes posting on
specific community forums might

5900
05:49:32.209 --> 05:49:35.209
be better for your specific
technology questions. If you

5901
05:49:35.209 --> 05:49:38.209
post on Stack Overflow, and you
get a ton of down votes on your

5902
05:49:38.209 --> 05:49:41.209
questions. Don't let that bother
you. Just take it as a learning

5903
05:49:41.209 --> 05:49:44.209
opportunity to learn about what
Stack Overflow likes and doesn't

5904
05:49:44.209 --> 05:49:48.209
like and just keep going but do
not let that discourage you.

5905
05:49:48.209 --> 05:49:51.209
Okay, well, now that we know
where things should go, where

5906
05:49:51.209 --> 05:49:55.209
questions should go and how to
actually format them. Let's

5907
05:49:55.209 --> 05:49:57.209
practice let's look at some
sample questions that you might

5908
05:49:57.209 --> 05:49:59.209
have. And we'll figure out where
we want to put them. So the

5909
05:49:59.209 --> 05:50:02.209
first one, where does this one
go? Feel free to pause and guess

5910
05:50:02.209 --> 05:50:05.209
yourself. So a question like
this is going to be great for a

5911
05:50:05.209 --> 05:50:09.209
Reddit or a discord? Probably
more a discord. Now, this is

5912
05:50:09.209 --> 05:50:12.209
definitely something that you
can search for. Right? So you

5913
05:50:12.209 --> 05:50:15.209
probably could search for this,
find an answer and go from

5914
05:50:15.209 --> 05:50:17.209
there. But maybe you want to ask
a buddy or maybe you want to ask

5915
05:50:17.209 --> 05:50:20.209
a very specific community like
our slash eat Dev. Now, of

5916
05:50:20.209 --> 05:50:22.210
course, if you see this
question, you obviously want to

5917
05:50:22.210 --> 05:50:25.210
recommend Patrick Collins his
YouTube channel. Now how about

5918
05:50:25.210 --> 05:50:28.210
this question. Notice its
formatting right? The title is

5919
05:50:28.210 --> 05:50:32.210
nice and big. They have a
technical command that is

5920
05:50:32.210 --> 05:50:34.210
formatted properly. They have
Git commit which is formatted

5921
05:50:34.210 --> 05:50:37.210
properly, where would this go
like this would definitely do

5922
05:50:37.210 --> 05:50:41.210
very well on a Stack Overflow or
an index code based forum to

5923
05:50:41.210 --> 05:50:44.210
very clearly try had to do
something technical. The problem

5924
05:50:44.210 --> 05:50:47.210
is laid out very clearly. And
they've given the command that

5925
05:50:47.210 --> 05:50:50.210
they're looking to do. Now, how
about this one, something like

5926
05:50:50.210 --> 05:50:52.210
this could go on either
StackOverflow. But it's probably

5927
05:50:52.210 --> 05:50:56.210
more likely going to go on a
GitHub issue for this brownie

5928
05:50:56.210 --> 05:51:00.210
package. A big difference
between code forums and and Git

5929
05:51:00.210 --> 05:51:03.210
repos like GitHub is that when
you make an issue on a GitHub

5930
05:51:03.210 --> 05:51:06.210
repository, especially when you
think there's a problem, you do

5931
05:51:06.210 --> 05:51:09.210
want to be as in depth as
possible. So oftentimes, when

5932
05:51:09.210 --> 05:51:12.210
making an issue on these repos,
they'll even ask, what version

5933
05:51:12.210 --> 05:51:15.210
are you using? Can you post all
your code? Can you post all your

5934
05:51:15.210 --> 05:51:18.210
files and just be much, much
more explicit? So how about

5935
05:51:18.210 --> 05:51:21.210
something like this. So this is
going to be really good for the

5936
05:51:21.210 --> 05:51:25.210
GitHub repo associated with this
tutorial, it looks like this

5937
05:51:25.210 --> 05:51:28.210
person is asking about a very
specific tutorial. So posting

5938
05:51:28.210 --> 05:51:32.210
this, there is going to be best.
Now if your question is on a

5939
05:51:32.210 --> 05:51:35.210
tutorial that doesn't have a
GitHub repo, well, they probably

5940
05:51:35.210 --> 05:51:38.210
should. But then maybe this is
better in the comment section.

5941
05:51:38.210 --> 05:51:42.210
Now, again, this is where this
all becomes a little bit more

5942
05:51:42.210 --> 05:51:45.210
art than science, because maybe
the specific error that they're

5943
05:51:45.210 --> 05:51:48.210
running into is a generic error
that a ton of people run into,

5944
05:51:48.210 --> 05:51:51.210
and maybe it is better on
StackOverflow. Or maybe there's

5945
05:51:51.210 --> 05:51:55.210
an issue with the package. So
maybe it is better on GitHub. Or

5946
05:51:55.210 --> 05:51:58.210
maybe the solution to this is
opinionated. And finally, what

5947
05:51:58.210 --> 05:52:01.211
about this? Yep, this is going
to be much better for a discord

5948
05:52:01.211 --> 05:52:04.211
or a DM with your buddy. And
away, it's our last step on

5949
05:52:04.211 --> 05:52:06.211
blocking you from any question
is going to be join and

5950
05:52:06.211 --> 05:52:09.211
strengthen the community of your
tool. Now at the start, it's

5951
05:52:09.211 --> 05:52:11.211
going to be hard for you to give
back since you're not going to

5952
05:52:11.211 --> 05:52:13.211
be very knowledgeable on these
tools. But as you get better at

5953
05:52:13.211 --> 05:52:16.211
these technologies, you'll want
to try to answer some of these

5954
05:52:16.211 --> 05:52:18.211
new questions that do come in.
The reason is because this will

5955
05:52:18.211 --> 05:52:21.211
give you a chance to actually
learn more about the tools that

5956
05:52:21.211 --> 05:52:24.211
you like, it'll strengthen the
community of your favorite

5957
05:52:24.211 --> 05:52:27.211
tools, meaning if you help
answer questions on tool, it'll

5958
05:52:27.211 --> 05:52:30.211
actually encourage other people
to use the tool because there's

5959
05:52:30.211 --> 05:52:33.211
a strong following there. And
likely, they might actually help

5960
05:52:33.211 --> 05:52:35.211
you sometime in the future, you
helping people will make you

5961
05:52:35.211 --> 05:52:38.211
look like a good person. And
then you'll also feel like a

5962
05:52:38.211 --> 05:52:41.211
good person. Additionally, in
many forums like Reddit,

5963
05:52:41.211 --> 05:52:44.211
oftentimes, mods will actually
look at how often you post

5964
05:52:44.211 --> 05:52:47.211
versus how often you help others
and comments on others people

5965
05:52:47.211 --> 05:52:50.211
posts and some mods may actually
start blocking your posts for

5966
05:52:50.211 --> 05:52:53.211
abusing the forums and not
giving back to the community and

5967
05:52:53.211 --> 05:52:55.211
only trying to take knowledge
you in the community will be

5968
05:52:55.211 --> 05:52:59.211
more successful if you join in
and help others and not just try

5969
05:52:59.211 --> 05:53:02.211
to extract things from other
people. Additionally, by

5970
05:53:02.211 --> 05:53:05.211
engaging with the community, I
can't tell you how many people

5971
05:53:05.211 --> 05:53:09.211
I've met and I've learned and
been able to brainstorm with.

5972
05:53:09.211 --> 05:53:11.211
And then the final step is going
to be iterate through these

5973
05:53:11.211 --> 05:53:14.211
steps. Maybe you get to the end
of these and you say, Oh, I'm

5974
05:53:14.211 --> 05:53:18.211
still blocked, but you'll likely
be much, much more

5975
05:53:18.211 --> 05:53:21.211
knowledgeable. So you want to go
back and try these steps again.

5976
05:53:21.211 --> 05:53:24.211
Now this is where this whole
process is a little bit more art

5977
05:53:24.211 --> 05:53:27.211
than science. Because some
questions might not have been

5978
05:53:27.211 --> 05:53:30.211
discovered yet. Only very few
people know not enough people

5979
05:53:30.211 --> 05:53:33.211
understand the importance of the
questions, or maybe people don't

5980
05:53:33.211 --> 05:53:36.211
understand your question. And
this is why it's important to go

5981
05:53:36.211 --> 05:53:39.211
back and iterate on these steps.
Now that you have the basic

5982
05:53:39.211 --> 05:53:41.212
building blocks of this
incredible superpower, I

5983
05:53:41.212 --> 05:53:44.212
encourage all of you to go out
there and try this and then let

5984
05:53:44.212 --> 05:53:48.212
me know how it went.

5985
05:53:48.212 --> 05:53:51.212
Alright, awesome. So now that we
know more about how to get

5986
05:53:51.212 --> 05:53:54.212
unblocked, we can move on. The
reason it's so important to

5987
05:53:54.212 --> 05:53:57.212
learn how to get unblocked is
because blockchain and web three

5988
05:53:57.212 --> 05:54:00.212
is more than just everybody on
their own. It is a very

5989
05:54:00.212 --> 05:54:04.212
collaborative space. So as you
get better, and as you learn

5990
05:54:04.212 --> 05:54:07.212
more a massive way to test how
much you've learned and give

5991
05:54:07.212 --> 05:54:09.212
back to the community is to
going to Stack Overflow and

5992
05:54:09.212 --> 05:54:13.212
going to stack exchange them and
trying to answer some questions

5993
05:54:13.212 --> 05:54:16.212
yourself. So I highly recommend
you all go to Stack Overflow,

5994
05:54:16.212 --> 05:54:19.212
and then you go to the GitHub
repo associated with the scores,

5995
05:54:19.212 --> 05:54:21.212
you try to answer some
discussions, try to answer some

5996
05:54:22.212 --> 05:54:24.212
issues and help other people out
because it's going to help you

5997
05:54:24.212 --> 05:54:28.212
become a much better software
engineer. The other reason I

5998
05:54:28.212 --> 05:54:31.212
want to do that part is because
when we install some of the

5999
05:54:31.212 --> 05:54:34.212
tools that I'm about to show
you, sometimes the installation

6000
05:54:34.212 --> 05:54:38.212
process is the hardest piece
there. Once you get past the

6001
05:54:38.212 --> 05:54:41.212
install process, it generally
becomes much, much easier. But

6002
05:54:41.212 --> 05:54:44.212
this can often be the hardest
part of the course is just

6003
05:54:44.212 --> 05:54:47.212
installing some of these tools
that we're going to give you.

6004
05:54:47.212 --> 05:54:50.212
And that's what we're going to
learn about right now. So we

6005
05:54:50.212 --> 05:54:54.212
have been working so far with
remix, remix IDE, or integrated

6006
05:54:54.212 --> 05:54:57.212
development environment. As
we've seen, it's this wonderful

6007
05:54:57.212 --> 05:55:00.212
place where we can try out code
we can try solidity out, we can

6008
05:55:00.212 --> 05:55:02.212
compile we can deploy, we can
pretty much do everything that

6009
05:55:02.212 --> 05:55:05.212
we need to do. It's web based.
It can do testing, debugging,

6010
05:55:05.212 --> 05:55:09.212
deploying local JavaScript VM,
it's very quick and easy to

6011
05:55:09.212 --> 05:55:12.212
create and test our smart
contracts. However, it does have

6012
05:55:12.212 --> 05:55:15.212
some limitations. It can really
only deal with smart contract,

6013
05:55:15.212 --> 05:55:18.212
it can't really integrate with
other parts of projects. It has

6014
05:55:18.212 --> 05:55:21.213
limited support for tests or
custom deployments. And you need

6015
05:55:21.213 --> 05:55:25.213
an internet connection to even
work with remix and it can be

6016
05:55:25.213 --> 05:55:28.213
tricky to do a lot more advanced
functionality. So it's a

6017
05:55:28.213 --> 05:55:30.213
phenomenal tool and absolutely
if you're looking to do

6018
05:55:30.213 --> 05:55:32.213
something very quickly, I
absolutely recommend everybody

6019
05:55:32.213 --> 05:55:35.213
just go to remix to go ahead and
try something out how are now

6020
05:55:35.213 --> 05:55:38.213
we're going to move over to a
more professional smart contract

6021
05:55:38.213 --> 05:55:42.213
developer setup. And this is
with hard hat. This is known as

6022
05:55:42.213 --> 05:55:45.213
a smart contract developer
framework similar to brownie or

6023
05:55:45.213 --> 05:55:49.213
foundry or, and likes, there's a
number of these frameworks. And

6024
05:55:49.213 --> 05:55:51.213
the reason that we're going to
do hard hat is because hard hat

6025
05:55:51.213 --> 05:55:55.213
is JavaScript based. It's a
JavaScript based development

6026
05:55:55.213 --> 05:55:58.213
environment. It's got JavaScript
based compilation, environment,

6027
05:55:58.213 --> 05:56:02.213
deploying, testing, debugging.
Now, for those of you who love

6028
05:56:02.213 --> 05:56:06.213
TypeScript, we will also have
TypeScript editions of every

6029
05:56:06.213 --> 05:56:09.213
single one of our code examples
for you. So if you love

6030
05:56:09.213 --> 05:56:12.213
JavaScript, we got you, if you
love TypeScript, we also got you

6031
05:56:12.213 --> 05:56:16.213
we're not always going to walk
through us doing the TypeScript.

6032
05:56:16.213 --> 05:56:20.213
But we will sometimes, and all
of the code for the TypeScript

6033
05:56:20.213 --> 05:56:23.213
will be available in the GitHub
repo. Now, before we can

6034
05:56:23.213 --> 05:56:26.213
actually learn hard hat, we have
to learn another package first.

6035
05:56:26.213 --> 05:56:30.213
So we're going to learn how to
do everything with ethers. Jas,

6036
05:56:30.213 --> 05:56:33.213
which is a JavaScript based
library for working with smart

6037
05:56:33.213 --> 05:56:36.213
contracts. And it's also what
powers the next tool that we're

6038
05:56:36.213 --> 05:56:39.213
going to be working with, which
is hard hat under the hood of

6039
05:56:39.213 --> 05:56:41.213
hard hat. There's a lot of
ethers Jas. So it's important

6040
05:56:41.213 --> 05:56:45.213
for us to learn ethers Jas so
that we can understand what hard

6041
05:56:45.213 --> 05:56:47.213
hat is actually doing. Now for
the rest of the course, I'm

6042
05:56:47.213 --> 05:56:51.213
going to be using a code editor
called Visual Studio code. This

6043
05:56:51.213 --> 05:56:54.213
is one of the most powerful code
editors on the planet. And if

6044
05:56:54.213 --> 05:56:57.213
you've already got it set up,
feel free to go ahead and skip

6045
05:56:57.213 --> 05:57:00.213
this part. If you already have a
professional coding setup with

6046
05:57:00.213 --> 05:57:03.214
no GS and VS code, and Git and
everything, feel free to use the

6047
05:57:03.214 --> 05:57:06.214
timestamps in the GitHub
repository. To skip over this

6048
05:57:06.214 --> 05:57:11.214
setup section. You'll often hear
people refer to this as VS code,

6049
05:57:11.214 --> 05:57:14.214
or Visual Studio code or just
Visual Studio. However, it's

6050
05:57:14.214 --> 05:57:18.214
important to note that Visual
Studio code this is different

6051
05:57:18.214 --> 05:57:22.214
than Visual Studio, which you
might see look like this. So

6052
05:57:22.214 --> 05:57:26.214
Visual Studio code is what you
want, not Visual Studio, Visual

6053
05:57:26.214 --> 05:57:29.214
Studio is a different
application, make sure you're on

6054
05:57:29.214 --> 05:57:33.214
Visual Studio code. Now, if you
choose so and you're a total

6055
05:57:33.214 --> 05:57:37.214
Harto, you can absolutely work
just with your terminal, or just

6056
05:57:37.214 --> 05:57:40.214
with PowerShell, or just with
whatever coding environment that

6057
05:57:40.214 --> 05:57:44.214
you want, like atom or Sublime.
However, for us, we're going to

6058
05:57:44.214 --> 05:57:47.214
be working with Visual Studio
code. And I'm going to be going

6059
05:57:47.214 --> 05:57:51.214
through setting up Visual Studio
code the way that I like to set

6060
05:57:51.214 --> 05:57:54.214
it up, you can actually set it
up whatever way that you feel

6061
05:57:54.214 --> 05:57:58.214
comfortable. And of course, in
our lesson six here, we have a

6062
05:57:58.214 --> 05:58:01.214
link to installation and setup.
And I'm going to be adding more

6063
05:58:01.214 --> 05:58:04.214
links as we go about here. And
once again, all the code that

6064
05:58:04.214 --> 05:58:08.214
we're going to be working with
is in this GitHub repository

6065
05:58:08.214 --> 05:58:10.214
down here where it says code.
Now we're gonna go through three

6066
05:58:10.214 --> 05:58:13.214
different installation processes
and pick the one that's most

6067
05:58:13.214 --> 05:58:17.214
appropriate for you. The first
one is going to be for Mac and

6068
05:58:17.214 --> 05:58:21.214
Linux users. The second one is
going to be for Windows users.

6069
05:58:21.214 --> 05:58:24.214
And then our third one is going
to be a last ditch effort. If

6070
05:58:24.214 --> 05:58:28.214
for whatever reason, you can't
get Windows or Linux or the Mac

6071
05:58:28.214 --> 05:58:31.214
instructions to work, we're
going to use a Git pod

6072
05:58:31.214 --> 05:58:34.214
installation. Now, I highly,
highly recommend that you try to

6073
05:58:34.214 --> 05:58:38.214
get everything working locally
without using Git pod. However,

6074
05:58:38.214 --> 05:58:42.215
if for whatever reason, you
can't get those installation

6075
05:58:42.215 --> 05:58:46.215
pieces to work, we will have Git
pod instructions for all of the

6076
05:58:46.215 --> 05:58:48.215
repos that we work with here.
But to get started, we'll start

6077
05:58:48.215 --> 05:58:54.215
with the Mac and Linux
installation instructions.

6078
05:58:54.215 --> 05:58:57.215
The first thing you're going to
want to do is download the Mac

6079
05:58:57.215 --> 05:59:01.215
or if you're working with Linux,
download the Linux installation

6080
05:59:01.215 --> 05:59:04.215
of Visual Studio code. Once you
have it installed, it'll look a

6081
05:59:04.215 --> 05:59:08.215
little something like this. And
if it's a fresh installation,

6082
05:59:08.215 --> 05:59:11.215
It'll even give you some tips
and tools to actually get

6083
05:59:11.215 --> 05:59:14.215
started. If you've never worked
with Visual Studio code before,

6084
05:59:14.215 --> 05:59:17.215
I highly recommend going through
any get started or getting

6085
05:59:17.215 --> 05:59:21.215
instructions tips that come with
opening Visual Studio Code.

6086
05:59:21.215 --> 05:59:25.215
Additionally, we have a Visual
Studio Code crash course in the

6087
05:59:25.215 --> 05:59:28.215
GitHub repo associated with this
course. Once you have Visual

6088
05:59:28.215 --> 05:59:31.215
Studio code installed, the next
thing that we're going to want

6089
05:59:31.215 --> 05:59:34.215
to install is going to be node j
s. And again, we have links to

6090
05:59:34.215 --> 05:59:37.215
all of these in the GitHub repo
associated with this course, you

6091
05:59:37.215 --> 05:59:40.215
can just go ahead and click
download for Mac OS or download

6092
05:59:40.215 --> 05:59:45.215
for Linux, I recommend using the
LTS version. lts stands for long

6093
05:59:45.215 --> 05:59:48.215
term support, which means that
they will be supporting this

6094
05:59:48.215 --> 05:59:53.215
version for a long time. So go
ahead and download Node js. I've

6095
05:59:53.215 --> 05:59:55.215
already downloaded this, so I'm
not gonna go ahead and

6096
05:59:55.215 --> 05:59:58.215
redownload this now one of the
awesome things about Visual

6097
05:59:58.215 --> 06:00:01.215
Studio code is it has this thing
called terminals, which are

6098
06:00:01.215 --> 06:00:05.215
command line prompts that allow
us to run scripts, basically,

6099
06:00:05.215 --> 06:00:07.215
it's where we're going to be
running all of our code where we

6100
06:00:07.215 --> 06:00:10.215
can open up the terminal is we
can go ahead and hit terminal

6101
06:00:10.215 --> 06:00:14.215
and select new terminal and
you'll get something like this.

6102
06:00:14.215 --> 06:00:18.215
Now you might have bash or Z ca
or some other type of shell type

6103
06:00:18.215 --> 06:00:21.215
that you have doesn't really
matter because on Mac and Linux

6104
06:00:21.215 --> 06:00:25.216
it's going to be Linux based we
can now test our no Jess

6105
06:00:25.216 --> 06:00:29.216
installation has been done
correctly by running Node dash

6106
06:00:29.216 --> 06:00:33.216
dash version, and you should see
something that looks like this.

6107
06:00:33.216 --> 06:00:37.216
The exact version of node that
you have doesn't really matter

6108
06:00:37.216 --> 06:00:40.216
here. But ideally you're at
least on Node version 14 or

6109
06:00:40.216 --> 06:00:43.216
higher. And if something like
this doesn't show up, remember

6110
06:00:43.216 --> 06:00:46.216
to go ahead and start looking at
Stack Overflow looking on the

6111
06:00:46.216 --> 06:00:49.216
GitHub repo in the discussions
tab, looking on the updated

6112
06:00:49.216 --> 06:00:52.216
section, etc. And like I said,
sometimes installing this can be

6113
06:00:52.216 --> 06:00:55.216
the hardest part of this entire
course so, so don't get

6114
06:00:55.216 --> 06:00:58.216
discouraged. And please use
Stack Overflow Stack Exchange

6115
06:00:58.216 --> 06:01:01.216
Etherium, and the GitHub repo to
move past any issues you run

6116
06:01:01.216 --> 06:01:05.216
into. Now, if you're on Mac or
Linux, you can actually hit Ctrl

6117
06:01:05.216 --> 06:01:08.216
back tick, to actually toggle
your terminal mode, this will

6118
06:01:08.216 --> 06:01:11.216
pull the terminal up and down
for you getting familiar with

6119
06:01:11.216 --> 06:01:14.216
keyboard shortcuts will actually
make your life a lot easier.

6120
06:01:14.216 --> 06:01:17.216
Because you'll be able to move
around Visual Studio code much

6121
06:01:17.216 --> 06:01:21.216
more effectively, we have a link
to a list of keyboard shortcuts.

6122
06:01:21.216 --> 06:01:24.216
Additionally, in the GitHub
repository associated with this

6123
06:01:24.216 --> 06:01:27.216
section, as we move along, I'll
give tip on different keyboard

6124
06:01:27.216 --> 06:01:29.216
shortcuts that you can
optionally use otherwise, you

6125
06:01:29.216 --> 06:01:32.216
can just go ahead and click as
well, you can click the trash

6126
06:01:32.216 --> 06:01:36.216
can to delete the terminal, go
back up Terminal new terminal to

6127
06:01:36.216 --> 06:01:38.216
pop it back up. Now the next
thing that we're going to need a

6128
06:01:38.216 --> 06:01:39.216
little bit later, we're not
going to need it for this

6129
06:01:39.216 --> 06:01:42.216
section, but it's good to
install it now is going to be

6130
06:01:42.216 --> 06:01:46.216
git no jazz is known as a
JavaScript runtime. And it's a

6131
06:01:46.216 --> 06:01:49.216
tool that we're going to use to
help run JavaScript code in our

6132
06:01:49.216 --> 06:01:52.216
Visual Studio Code slot exactly
JavaScript. And the difference

6133
06:01:52.216 --> 06:01:55.216
between no Jas and JavaScript
can be a little bit confusing,

6134
06:01:55.216 --> 06:01:58.216
but don't let that stop you for
now. Next, we're actually going

6135
06:01:58.216 --> 06:02:00.216
to go ahead and install Git, we
will have links to the

6136
06:02:00.216 --> 06:02:03.217
installation instructions in the
GitHub repository, installing

6137
06:02:03.217 --> 06:02:06.217
git on Linux, you're going to
use one of these two commands

6138
06:02:06.217 --> 06:02:09.217
and on macOS, if you just type
git on the command line, it

6139
06:02:10.217 --> 06:02:12.217
should go ahead and prompt you
to install it. So we're back in

6140
06:02:12.217 --> 06:02:15.217
our command line, and we just
type git, it should prompt you

6141
06:02:15.217 --> 06:02:18.217
to go ahead and stall it. And if
you do get dash dash version,

6142
06:02:18.217 --> 06:02:21.217
you should get something that
looks like this. You can also

6143
06:02:21.217 --> 06:02:24.217
use a Mac OS get installer by
clicking this link here and

6144
06:02:24.217 --> 06:02:26.217
running through the installation
process. Alright, now that you

6145
06:02:26.217 --> 06:02:31.217
have no JS yet in Visual Studio
code installed, we can continue

6146
06:02:31.217 --> 06:02:35.217
on to the next section. Awesome.
If you're not planning on using

6147
06:02:35.217 --> 06:02:41.217
Windows or get pod, feel free to
skip the next two sections.

6148
06:02:41.217 --> 06:02:44.217
I'm running this on Windows 11.
However, it should work on most

6149
06:02:44.217 --> 06:02:47.217
editions of Windows. So the
first thing that we're going to

6150
06:02:47.217 --> 06:02:53.217
want to install is Visual Studio
Code, which looks something like

6151
06:02:53.217 --> 06:02:56.217
this, it should auto detect it.
And we're gonna go ahead and

6152
06:02:56.217 --> 06:03:00.217
download this for windows in a
walk through all the

6153
06:03:00.217 --> 06:03:04.217
installation process. Go ahead
and create a desktop item, we'll

6154
06:03:04.217 --> 06:03:08.217
add this just in case we want to
open with code. And we'll go

6155
06:03:08.217 --> 06:03:12.217
ahead and install. And then
we'll go ahead and finish. Once

6156
06:03:12.217 --> 06:03:14.217
you've installed Visual Studio
code, you'll see something that

6157
06:03:14.217 --> 06:03:17.217
looks a little like this, it'll
go ahead and give you this get

6158
06:03:17.217 --> 06:03:19.217
started with VS Code section
where you can choose some

6159
06:03:19.217 --> 06:03:22.217
themes, and you can choose kind
of the way it looks feel free to

6160
06:03:22.217 --> 06:03:24.217
customize it the way that you
want. If you want to learn a

6161
06:03:24.217 --> 06:03:27.217
little bit more about Visual
Studio code, I highly recommend

6162
06:03:27.217 --> 06:03:30.217
you walk through this section to
learn more about the shortcuts

6163
06:03:30.217 --> 06:03:33.217
and making your development
experience more efficient. When

6164
06:03:33.217 --> 06:03:36.217
you're done, you can just go
ahead and close the tabs at the

6165
06:03:36.217 --> 06:03:38.217
top. And it'll look a little
something like this. Once we

6166
06:03:38.217 --> 06:03:41.217
have Visual Studio code
installed. The next thing that

6167
06:03:41.217 --> 06:03:44.218
we're going to want to install
is node j s. And of course, we

6168
06:03:44.218 --> 06:03:46.218
have a link to installing this
in the GitHub repository

6169
06:03:46.218 --> 06:03:48.218
associated with this course,
what we're going to do is we're

6170
06:03:48.218 --> 06:03:52.218
going to go ahead and come to
node j s.org. To download this

6171
06:03:52.218 --> 06:03:55.218
for Windows node. JS is a
JavaScript runtime environment,

6172
06:03:55.218 --> 06:03:58.218
it's not exactly JavaScript. And
the distinction can be a little

6173
06:03:58.218 --> 06:04:01.218
bit confusing, but just know
it's going to help us run our

6174
06:04:01.218 --> 06:04:03.218
JavaScript code for our
development environment. Let's

6175
06:04:03.218 --> 06:04:08.218
go ahead and download the LTS or
the long term support edition of

6176
06:04:08.218 --> 06:04:15.218
no GS. We'll go ahead and we'll
run through the setup wizard.

6177
06:04:15.218 --> 06:04:18.218
And we'll go ahead and make sure
that this is clicked just in

6178
06:04:18.218 --> 06:04:21.218
case we ever want to use some
different tools with our setup.

6179
06:04:21.218 --> 06:04:24.218
And then we'll go ahead and
click Install, you'll get a pop

6180
06:04:24.218 --> 06:04:27.218
up asking if you really want to
install this on your device. And

6181
06:04:27.218 --> 06:04:30.218
we'll go ahead and hit yes. And
then we'll hit finish, you might

6182
06:04:30.218 --> 06:04:33.218
get a pop up that looks like
this, go ahead and click any

6183
06:04:33.218 --> 06:04:35.218
button to go ahead and install
the tools, go ahead and press

6184
06:04:35.218 --> 06:04:39.218
any key again. And you'll likely
get a Windows PowerShell screen

6185
06:04:39.218 --> 06:04:42.218
pop up asking you to go ahead
and install a whole bunch of

6186
06:04:42.218 --> 06:04:45.218
different projects and files. If
you chose not to install this,

6187
06:04:45.218 --> 06:04:47.218
that's totally okay. But in the
future, this will be really

6188
06:04:47.218 --> 06:04:50.218
helpful since we are going to
use a lot of tools that this

6189
06:04:50.218 --> 06:04:54.218
package installs anyways, this
might take some time to install.

6190
06:04:54.218 --> 06:04:56.218
So go ahead and be patient. And
if it gets stuck, it might just

6191
06:04:56.218 --> 06:04:59.218
be waiting for you to go ahead
and hit enter. So go ahead and

6192
06:04:59.218 --> 06:05:02.218
hit Enter for any prompts. But
yes, please be patient with

6193
06:05:02.218 --> 06:05:04.218
this, it can be a little bit
slow to go ahead and install

6194
06:05:04.218 --> 06:05:06.218
everything. Once you have all
that installed, you can come

6195
06:05:06.218 --> 06:05:10.218
back to Visual Studio code. And
we're going to go ahead and open

6196
06:05:10.218 --> 06:05:13.218
up a terminal. To do that we hit
terminal and we hit new terminal

6197
06:05:13.218 --> 06:05:16.218
terminal is going to be our
command line prompt where we're

6198
06:05:16.218 --> 06:05:19.218
going to basically run all of
our scripts to work with our

6199
06:05:19.218 --> 06:05:23.219
code. And if you run Node dash
dash version, you should see

6200
06:05:23.219 --> 06:05:26.219
something that looks like this
to know that you've installed

6201
06:05:26.219 --> 06:05:30.219
Node js correctly. Now this
command line is known as Windows

6202
06:05:30.219 --> 06:05:33.219
PowerShell. If you want to work
with Windows PowerShell, you

6203
06:05:33.219 --> 06:05:36.219
absolutely can. In fact, if you
want to be a total Harto, and

6204
06:05:36.219 --> 06:05:38.219
write all your code through
Windows PowerShell, you can

6205
06:05:38.219 --> 06:05:40.219
absolutely do that as well.
However, we're actually not

6206
06:05:40.219 --> 06:05:42.219
going to be working with
PowerShell We're going to be

6207
06:05:42.219 --> 06:05:46.219
using a tool that makes our
Windows environments more like

6208
06:05:46.219 --> 06:05:48.219
Linux. The reason that we're
doing this is Linux is the

6209
06:05:48.219 --> 06:05:51.219
standard for most development
environments. And having

6210
06:05:51.219 --> 06:05:54.219
everybody work on a very similar
setup will make the rest of this

6211
06:05:54.219 --> 06:05:57.219
course a lot easier for everyone
to interact with each other, no

6212
06:05:57.219 --> 06:06:01.219
matter what coding environment,
they're working on. WsL stands

6213
06:06:01.219 --> 06:06:05.219
for Windows subsystem for Linux,
and allows Linux programs to run

6214
06:06:05.219 --> 06:06:09.219
natively on our Windows
environments. To get this setup,

6215
06:06:09.219 --> 06:06:14.219
we're gonna go ahead, go to the
WsL install. And we'll have a

6216
06:06:14.219 --> 06:06:19.219
link for this as well in our
GitHub repository. So what we're

6217
06:06:19.219 --> 06:06:23.219
going to do, you must be running
a Windows 10, version 2004 or

6218
06:06:23.219 --> 06:06:25.219
higher, or Windows 11. If you're
using an older version of

6219
06:06:25.219 --> 06:06:28.219
Windows, you can absolutely
continue with PowerShell. But

6220
06:06:28.219 --> 06:06:31.219
you might run into some issues
where all the commands don't

6221
06:06:31.219 --> 06:06:34.219
work exactly the same. So I
highly recommend working on a

6222
06:06:34.219 --> 06:06:40.219
newer version of Windows. To
install this back in your Visual

6223
06:06:40.219 --> 06:06:43.219
Studio Code, PowerShell, or just
the PowerShell app, or running

6224
06:06:43.219 --> 06:06:48.219
WsL dash dash install. Now if
you get this error, the

6225
06:06:48.219 --> 06:06:52.219
requested operation requires
elevation, it means that we have

6226
06:06:52.219 --> 06:06:55.219
to run our Visual Studio code or
our PowerShell application as

6227
06:06:55.219 --> 06:07:03.220
administrator. We close out our
Visual Studio code. And right

6228
06:07:03.220 --> 06:07:06.220
click it and say, Run as
Administrator, we get a little

6229
06:07:07.220 --> 06:07:09.220
pop up saying Do you want to
allow this app to make changes

6230
06:07:09.220 --> 06:07:13.220
to your device, we'll go ahead
and click Yes. And then we'll

6231
06:07:13.220 --> 06:07:18.220
reopen the terminal. And then we
can run WsL space dash dash

6232
06:07:18.220 --> 06:07:23.220
install. And we'll go ahead and
install WsL. This may take a

6233
06:07:23.220 --> 06:07:25.220
little bit so please be patient.

6234
06:07:25.220 --> 06:07:28.220
Once it's completed, you'll see
something that looks like this,

6235
06:07:28.220 --> 06:07:31.220
we're going to be working with
Ubuntu. And we have a list of

6236
06:07:31.220 --> 06:07:34.220
different commands to change
your Linux distribution. If you

6237
06:07:34.220 --> 06:07:36.220
choose to do so. And you'll see
the request set operation is

6238
06:07:36.220 --> 06:07:40.220
successful changes will not be
effective until the system is

6239
06:07:40.220 --> 06:07:43.220
rebooted. So you'll want to go
ahead and restart your computer.

6240
06:07:43.220 --> 06:07:46.220
There's also a troubleshooting
guide in the GitHub repository.

6241
06:07:46.220 --> 06:07:49.220
If you run into issues after you
restart your computer, you'll be

6242
06:07:49.220 --> 06:07:52.220
prompted for a name for your new
system and a password. This can

6243
06:07:52.220 --> 06:07:54.220
be different from your Windows
name and password, and then just

6244
06:07:55.220 --> 06:07:57.220
follow through with all the
prompts. And then once you're

6245
06:07:57.220 --> 06:08:00.220
done, you'll be dropped into a
Ubuntu shell, and you can run

6246
06:08:00.220 --> 06:08:04.220
Linux commands. Now you'll have
a Ubuntu instance, on your

6247
06:08:04.220 --> 06:08:07.220
machine. And you'll be able to
run Linux commands in your

6248
06:08:07.220 --> 06:08:11.220
terminal. Now that we have WsL
set up correctly, we're going to

6249
06:08:11.220 --> 06:08:15.220
head back over to Visual Studio
code. Once we have WsL, we'll

6250
06:08:15.220 --> 06:08:18.220
want to go ahead and install an
extension. So in our Visual

6251
06:08:18.220 --> 06:08:21.220
Studio code, we'll go to
Extensions, and we'll look up

6252
06:08:21.220 --> 06:08:28.220
remote development you can
install the whole thing or just

6253
06:08:28.220 --> 06:08:33.220
remote WsL we're gonna install
the whole thing you can follow

6254
06:08:33.220 --> 06:08:37.220
along to get started with remote
WsL if you like, or you can just

6255
06:08:37.220 --> 06:08:40.220
follow along with me right now.
Right now if I go to the

6256
06:08:40.220 --> 06:08:45.221
terminal and hit new terminal,
I'm still gonna get PowerShell

6257
06:08:45.221 --> 06:08:48.221
we actually want this to be our
Linux shell. So there are a

6258
06:08:48.221 --> 06:08:51.221
couple ways to open Visual
Studio code up in our Linux

6259
06:08:51.221 --> 06:08:57.221
environment. One way is you're
gonna hit Ctrl, Shift P and type

6260
06:08:57.221 --> 06:09:03.221
WsL. And then click remote WsL
new WsL window, and you'll get a

6261
06:09:03.221 --> 06:09:06.221
new window that looks like this,
you can also click the bottom

6262
06:09:06.221 --> 06:09:12.221
left and choose New WsL window.
Now if we go to our terminal and

6263
06:09:12.221 --> 06:09:15.221
hit new terminal, we'll be
dropped into a bash shell and we

6264
06:09:15.221 --> 06:09:18.221
can run Linux commands in here.
Awesome. Another way we can open

6265
06:09:18.221 --> 06:09:22.221
up Visual Studio code with WsL
on is we can go into our your

6266
06:09:22.221 --> 06:09:29.221
boon to application, we can make
a folder by typing MK dir

6267
06:09:29.221 --> 06:09:34.221
folder, we'll CD or change
directory into folder and type

6268
06:09:34.221 --> 06:09:38.221
code period. We'll go ahead and
trust the authors in here. And

6269
06:09:38.221 --> 06:09:42.221
this will open up Visual Studio
code already connected to the

6270
06:09:42.221 --> 06:09:45.221
folder that we're in. And we can
create files in this folder like

6271
06:09:45.221 --> 06:09:50.221
hi dot txt, and those will get
created inside the folder in our

6272
06:09:50.221 --> 06:09:53.221
WsL. Now that we're inside our
WsL environment, you'll notice

6273
06:09:53.221 --> 06:09:56.221
that node dash dash version
doesn't work anymore. That's

6274
06:09:56.221 --> 06:10:00.221
because we installed it on our
regular Windows machine and not

6275
06:10:00.221 --> 06:10:04.221
on our WsL or Linux environment.
The reason we installed it on a

6276
06:10:04.221 --> 06:10:06.221
Windows environment first is
that just in case you wanted to

6277
06:10:07.221 --> 06:10:09.221
go ahead and use PowerShell or
user Windows environment to run

6278
06:10:10.221 --> 06:10:12.221
everything you still can just
remember if you use the Windows

6279
06:10:12.221 --> 06:10:15.221
environment and PowerShell all
the commands that we use might

6280
06:10:15.221 --> 06:10:20.221
not work for you. So we're gonna
go ahead and install Node js on

6281
06:10:20.221 --> 06:10:22.222
our Linux environment. Now, all
the commands that we're going to

6282
06:10:22.222 --> 06:10:25.222
write are going to be in the
GitHub repo associated with this

6283
06:10:25.222 --> 06:10:31.222
course. We're going to do a curl
command to the nvm repository,

6284
06:10:31.222 --> 06:10:44.222
which stands for node version
manager.

6285
06:10:44.222 --> 06:10:47.222
And we're going to pipe the
install script into bash. And

6286
06:10:47.222 --> 06:10:52.222
this will go ahead and install
and VM. After running that, go

6287
06:10:52.222 --> 06:10:57.222
ahead and trash the terminal,
and then reopen it. And then we

6288
06:10:57.222 --> 06:11:02.222
can type MBM dash dash version
to see if it actually installed

6289
06:11:02.222 --> 06:11:05.222
correctly. Once we've installed
nvm, we can go ahead and install

6290
06:11:05.222 --> 06:11:13.222
no GS using nvm. Just type npm
install, and we'll do 16 point

6291
06:11:13.222 --> 06:11:16.222
14.2 Is that same long term
support version we installed on

6292
06:11:16.222 --> 06:11:20.222
our Windows machine. Once we
have it installed, we can type

6293
06:11:20.222 --> 06:11:24.222
in Node dash S version. And now
we have no JS installed. Now I

6294
06:11:24.222 --> 06:11:27.222
know there was a lot here, but
if you made it this far, this is

6295
06:11:27.222 --> 06:11:31.222
fantastic. You've done a great
job to push through to this

6296
06:11:31.222 --> 06:11:34.222
point and get everything set up
so you can code in the best

6297
06:11:34.222 --> 06:11:36.222
environment there is. So if
you've made it this far, huge

6298
06:11:36.222 --> 06:11:39.222
congratulations. Now the next
thing that we're going to

6299
06:11:39.222 --> 06:11:42.222
install is Git. And now we're
not going to use Git for this

6300
06:11:42.222 --> 06:11:45.222
lesson. However, we will
definitely be using it in the

6301
06:11:45.222 --> 06:11:49.222
future. See if gets installed
type git dash dash version,

6302
06:11:49.222 --> 06:11:51.222
sometimes Linux will
automatically come with Git

6303
06:11:51.222 --> 06:11:54.222
installed and you'll see
something output like this. If

6304
06:11:54.222 --> 06:11:58.222
you don't have Git, we can just
look up the get install. Which

6305
06:11:58.222 --> 06:12:01.222
again, link to this is in the
description. And you'll actually

6306
06:12:01.222 --> 06:12:06.223
run the installing on Linux. Now
again, now if you want to use

6307
06:12:06.223 --> 06:12:09.223
PowerShell, and you want to do
everything with Windows, you can

6308
06:12:09.223 --> 06:12:11.223
absolutely follow the installing
on Windows instructions here

6309
06:12:11.223 --> 06:12:15.223
instead, when you're working in
WsL, you'll want to use the

6310
06:12:15.223 --> 06:12:18.223
Linux commands instead of the
windows commands even though

6311
06:12:18.223 --> 06:12:21.223
you're on a Windows because WsL
makes it so that you're

6312
06:12:21.223 --> 06:12:24.223
basically running in a Linux
environment. And now if you've

6313
06:12:24.223 --> 06:12:27.223
made it this far, you should be
able to follow along with the

6314
06:12:27.223 --> 06:12:30.223
Mac and Linux instructions as if
you're running on a Mac and

6315
06:12:30.223 --> 06:12:33.223
Linux even though you're running
on Windows. Just be sure that

6316
06:12:33.223 --> 06:12:36.223
whenever you're in your VS code,
you take a look at the bottom

6317
06:12:36.223 --> 06:12:40.223
left and make sure you're on WsL
Ubuntu. Like I said before, if

6318
06:12:40.223 --> 06:12:42.223
you want to run in PowerShell,
or in a Windows environment,

6319
06:12:42.223 --> 06:12:45.223
you're more than free to do so.
But like I said, if you've made

6320
06:12:45.223 --> 06:12:51.223
it this far, huge
congratulations. Awesome work.

6321
06:12:51.223 --> 06:12:54.223
And then finally, our last setup
is going to be using a tool

6322
06:12:54.223 --> 06:12:57.223
called Git pod starting from
Lesson five. The lesson that

6323
06:12:57.223 --> 06:13:00.223
we're on right now, ethers,
jazz, simple storage, all of our

6324
06:13:00.223 --> 06:13:04.223
code repos are going to come
with a button in the repo scroll

6325
06:13:04.223 --> 06:13:08.223
down, they'll come with this
open in get pod button. Now git

6326
06:13:08.223 --> 06:13:11.223
pod is a cloud development
environment where you can

6327
06:13:11.223 --> 06:13:16.223
actually run your code on a
remote server, it's kind of

6328
06:13:16.223 --> 06:13:20.223
similar to remix IDE, but it
allows you to run Visual Studio

6329
06:13:20.223 --> 06:13:25.223
code in the browser or connected
to another server. This is good

6330
06:13:25.223 --> 06:13:28.223
because then you don't have to
do any installation on anything.

6331
06:13:28.223 --> 06:13:31.223
Since all the tools that you can
want to use are just going to be

6332
06:13:31.223 --> 06:13:34.223
running on this remote server.
This has its downsides, though,

6333
06:13:34.223 --> 06:13:39.223
obviously, since you'll only be
able to code if git pod is up

6334
06:13:39.223 --> 06:13:41.223
and working for you.
Additionally, when it comes to

6335
06:13:41.223 --> 06:13:45.224
private keys, you absolutely do
not want to run any code with a

6336
06:13:45.224 --> 06:13:49.224
private key that has real money
in good pop. Why? Well, once

6337
06:13:49.224 --> 06:13:53.224
again, since you're running your
scripts on a remote server,

6338
06:13:53.224 --> 06:13:57.224
those servers have access to
your private keys. But since

6339
06:13:57.224 --> 06:14:00.224
you've Pinky promise that for
this course, you're not going to

6340
06:14:00.224 --> 06:14:03.224
be using a meta mask or a
private key with actual money in

6341
06:14:03.224 --> 06:14:07.224
it, it should be fine. The other
downside is that these often

6342
06:14:07.224 --> 06:14:11.224
cost money to use and get pot
isn't free. But it's an option

6343
06:14:11.224 --> 06:14:15.224
if you absolutely cannot get any
of the installation working. So

6344
06:14:15.224 --> 06:14:18.224
if you go ahead and you hit this
opening get pod button, you'll

6345
06:14:18.224 --> 06:14:20.224
get a welcome to get pods
showing up. We're gonna go ahead

6346
06:14:20.224 --> 06:14:24.224
and continue with GitHub. Since
you've signed up for GitHub

6347
06:14:24.224 --> 06:14:29.224
here, you want to go ahead and
authorize get pod. And it'll go

6348
06:14:29.224 --> 06:14:32.224
ahead and start creating this
workspace for you. And you'll

6349
06:14:32.224 --> 06:14:36.224
notice it looks exactly like
Visual Studio Code. Since I

6350
06:14:36.224 --> 06:14:41.224
opened the repo up in Git pod,
it came with all the code, and

6351
06:14:41.224 --> 06:14:47.224
you can even open this workspace
up in VS code desktop. So this

6352
06:14:47.224 --> 06:14:50.224
is might be a little bit
confusing. But basically, you

6353
06:14:50.224 --> 06:14:54.224
can run off of Git pod using
your local Visual Studio code.

6354
06:14:54.224 --> 06:14:57.224
And if you see git pod here,
that's how you know that you're

6355
06:14:57.224 --> 06:15:00.224
running off of Git pod. If you
see this pop up, do you want to

6356
06:15:00.224 --> 06:15:04.224
open this workspace in VS code
desktop, you can hit Open. And

6357
06:15:04.224 --> 06:15:07.224
it'll ask you if you want to
open up Visual Studio Code,

6358
06:15:07.224 --> 06:15:10.224
which I'm going to go ahead and
hit yes. And you'll get

6359
06:15:10.224 --> 06:15:13.224
something that looks like this
on your Visual Studio Code.

6360
06:15:13.224 --> 06:15:16.224
It'll tell you that it wants to
install the Git pod extension,

6361
06:15:16.224 --> 06:15:20.224
and then open that Git pod URL.
So you can go ahead and install

6362
06:15:20.224 --> 06:15:25.225
it. Reload window and open and
it's going to go ahead and start

6363
06:15:25.225 --> 06:15:29.225
connecting to our the Git pod
workspace. And this is going to

6364
06:15:29.225 --> 06:15:34.225
be the same as running git pod
in the browser here. Or you can

6365
06:15:34.225 --> 06:15:38.225
also do it manually by hitting
the Git pod in the bottom left,

6366
06:15:38.225 --> 06:15:43.225
and then type in open in VS code

6367
06:15:43.225 --> 06:15:45.225
And then you should be able to
run it in your Visual Studio

6368
06:15:45.225 --> 06:15:48.225
code. For now, I'm going to
recommend that if you're using

6369
06:15:48.225 --> 06:15:51.225
Git pod, just stay in the
browser, just so that you know,

6370
06:15:51.225 --> 06:15:55.225
okay, I am running this on a
remote server. And just as a

6371
06:15:55.225 --> 06:15:59.225
reminder for you that you're not
actually locally developing. And

6372
06:15:59.225 --> 06:16:02.225
hopefully, this will be a
trigger to not actually put any

6373
06:16:02.225 --> 06:16:05.225
special private keys or anything
like that. But you can make

6374
06:16:05.225 --> 06:16:08.225
workspaces, you can make new
folders, and you should be able

6375
06:16:08.225 --> 06:16:11.225
to run all the commands on here,
as if you are running locally

6376
06:16:11.225 --> 06:16:14.225
with Visual Studio code. To open
up the terminal, you can hit

6377
06:16:14.225 --> 06:16:20.225
this little bar at the top left,
go to terminal, new terminal, or

6378
06:16:20.225 --> 06:16:25.225
use CTRL tilde exact same as Mac
OS and Linux keyboard shortcuts

6379
06:16:25.225 --> 06:16:30.225
to create a new folder, we can
change directory, CD, dot.mk,

6380
06:16:30.225 --> 06:16:36.225
dir, new folder, MK dir makes
make directory called New

6381
06:16:36.225 --> 06:16:39.225
Folder. And then we're going to
change our directory into a new

6382
06:16:39.225 --> 06:16:42.225
folder, and hit enter. And now
we're in that new folder. For

6383
06:16:42.225 --> 06:16:46.225
each section, you can either
open up the entire source code

6384
06:16:46.225 --> 06:16:50.225
right into GitHub, or you can
create a new folder for each

6385
06:16:50.225 --> 06:16:53.225
section yourself and start from
blank. And then you would just

6386
06:16:53.225 --> 06:17:01.225
type code period. And you'd be
in a brand new folder. All

6387
06:17:01.225 --> 06:17:04.226
right, this is fantastic. At
this point, you should be set up

6388
06:17:04.226 --> 06:17:09.226
with Visual Studio Code no Jas
and get. And I'm going to be

6389
06:17:09.226 --> 06:17:12.226
working out of a folder called
Hard Hat Free Code Camp at this

6390
06:17:12.226 --> 06:17:18.226
point, you should have node,
dash dash version, get dash dash

6391
06:17:18.226 --> 06:17:22.226
version. And if you're using
Windows, this should say WsL or

6392
06:17:22.226 --> 06:17:26.226
your boon to or something like
that. And if you have all that,

6393
06:17:26.226 --> 06:17:29.226
that means we're ready to go.
Now a quick note something that

6394
06:17:29.226 --> 06:17:33.226
you'll see me do a lot. And you
can do this as well. Oftentimes,

6395
06:17:33.226 --> 06:17:36.226
when my terminal gets really,
really big, or there's a ton of

6396
06:17:36.226 --> 06:17:39.226
commands in here gets a little
bit overwhelming for me. So one

6397
06:17:39.226 --> 06:17:42.226
thing that you can do is you can
type clear, and hit Enter to

6398
06:17:42.226 --> 06:17:47.226
clear it. Or what you can do is
you can hit Command K, if you're

6399
06:17:47.226 --> 06:17:52.226
on a Mac, or Ctrl K, if you're
on a Linux or a Windows, and

6400
06:17:52.226 --> 06:17:54.226
it's one of my favorite keyboard
shortcuts that I use all the

6401
06:17:54.226 --> 06:17:58.226
time. Additionally, the trash
can and the X here are very

6402
06:17:58.226 --> 06:18:02.226
different. If I go to a couple
of enters here, and we're down

6403
06:18:02.226 --> 06:18:06.226
here, if I hit the trashcan, and
then pull my terminal back up,

6404
06:18:06.226 --> 06:18:10.226
by doing the toggle, or by doing
terminal new terminal, you'll

6405
06:18:10.226 --> 06:18:14.226
see all those lines are still
here. But if I hit the trashcan,

6406
06:18:14.226 --> 06:18:17.226
and then pull the terminal back
up, you'll see it actually

6407
06:18:17.226 --> 06:18:22.226
refreshes mine a special command
that prints stuff out. trashing

6408
06:18:22.226 --> 06:18:24.226
your terminal is basically
deleting whatever's running in

6409
06:18:24.226 --> 06:18:29.226
it, and the x is just hiding it.
And as hitting Ctrl tilde or

6410
06:18:29.226 --> 06:18:32.226
toggling our terminal or
whatever command it is on your

6411
06:18:32.226 --> 06:18:35.226
environment, that's equivalent
to hitting the hide, not the

6412
06:18:35.226 --> 06:18:38.226
trash. So if we want to remove
and start a terminal over, we

6413
06:18:38.226 --> 06:18:42.226
hit the trashcan, and then we
pull it back up. Alright, so now

6414
06:18:42.226 --> 06:18:44.227
we're gonna start working with
ethers. And we're going to start

6415
06:18:44.227 --> 06:18:48.227
learning to code, our
transactions and our contract

6416
06:18:48.227 --> 06:18:51.227
deployments and everything
programmatically at a relatively

6417
06:18:51.227 --> 06:18:54.227
low level. And we're gonna learn
how to deploy and interact with

6418
06:18:54.227 --> 06:18:58.227
the contracts using the ethers
JS package. Now to get started,

6419
06:18:58.227 --> 06:19:00.227
I'm going to recommend you
create a folder where you're

6420
06:19:00.227 --> 06:19:02.227
going to put all of your
projects in it, I'm going to

6421
06:19:02.227 --> 06:19:07.227
create a new directory called H
H. hyphen, FCC, which stands for

6422
06:19:07.227 --> 06:19:11.227
hard hat Free Code Camp. And
once we run that command, we can

6423
06:19:11.227 --> 06:19:15.227
cd into hh FCC. And this is
where we'll create all of our

6424
06:19:15.227 --> 06:19:18.227
projects for this course moving
forward, so that we have them

6425
06:19:18.227 --> 06:19:21.227
all in one place. Now to get
started, whenever you create a

6426
06:19:21.227 --> 06:19:25.227
new project, you always want to
create a new folder. So to

6427
06:19:25.227 --> 06:19:28.227
create a new folder, we're going
to do MK dir, and we're going to

6428
06:19:28.227 --> 06:19:35.227
call this ethers, simple
storage, like that. And now, if

6429
06:19:35.227 --> 06:19:40.227
you type ls, you'll see that
there is one folder named

6430
06:19:40.227 --> 06:19:45.227
ethers, simple storage. ls is
how you list all the contents of

6431
06:19:45.227 --> 06:19:49.227
your folder. You might have a
lot of other folders in here, I

6432
06:19:49.227 --> 06:19:52.227
only have the one since I
created this new folder for

6433
06:19:52.227 --> 06:19:57.227
this. Now what you can do, you
can type code, ethers simple.

6434
06:19:57.227 --> 06:20:01.227
And then if you hit tab, it
should autocomplete for you. And

6435
06:20:01.227 --> 06:20:06.227
if you enter, Visual Studio code
should open up a new Visual

6436
06:20:06.227 --> 06:20:13.227
Studio code for you. That is
inside of either simple storage

6437
06:20:13.227 --> 06:20:16.227
if you open up your terminal
now, your home directory for

6438
06:20:16.227 --> 06:20:19.227
this workspace is going to be
through simple storage as this

6439
06:20:19.227 --> 06:20:23.228
is what pops up. If that doesn't
work for you, we can also do is

6440
06:20:23.228 --> 06:20:28.228
you can hit File, Open folder
and then open the folder that

6441
06:20:28.228 --> 06:20:32.228
you just created or that you
want to open this again we'll

6442
06:20:32.228 --> 06:20:35.228
open up VS code. And if we open
up our terminal we see we're

6443
06:20:35.228 --> 06:20:38.228
inside of ether simple storage.
This is so powerful because as

6444
06:20:38.228 --> 06:20:41.228
we create files

6445
06:20:41.228 --> 06:20:45.228
we'll be able to See those files
in our Explorer here, this

6446
06:20:45.228 --> 06:20:48.228
button here stands for the
Explorer. If we click it, we can

6447
06:20:48.228 --> 06:20:51.228
see the different files in here.
And I'm going to go ahead and

6448
06:20:51.228 --> 06:20:54.228
actually delete this file dot
txt, because we're not actually

6449
06:20:54.228 --> 06:20:57.228
going to use that. Now it's this
part of the course, where we're

6450
06:20:57.228 --> 06:21:01.228
actually going to start jumping
into some JavaScript. Since this

6451
06:21:01.228 --> 06:21:04.228
course is in JavaScript course,
if you're unfamiliar with

6452
06:21:04.228 --> 06:21:07.228
JavaScript, it might be a little
bit tricky. If you want to come

6453
06:21:07.228 --> 06:21:09.228
into this with a better
understanding of JavaScript and

6454
06:21:10.228 --> 06:21:14.228
Node js, there is a Free Code
Camp YouTube video teaching No,

6455
06:21:14.228 --> 06:21:17.228
Jas for beginners. And a link to
this will be in the GitHub repo

6456
06:21:17.228 --> 06:21:20.228
associated with this course.
There's also a JavaScript Free

6457
06:21:20.228 --> 06:21:23.228
Code Camp video that I'm also
going to put in the description

6458
06:21:23.228 --> 06:21:26.228
for this course, keep in mind
that JavaScript and Node js are

6459
06:21:26.228 --> 06:21:29.228
slightly different. And we are
going to go over some of the

6460
06:21:29.228 --> 06:21:33.228
differences as we code along
here. But for the most part,

6461
06:21:33.228 --> 06:21:35.228
learning one means you've
learned the majority of the

6462
06:21:35.228 --> 06:21:38.228
other. So if you want to pause
and go through these videos,

6463
06:21:38.228 --> 06:21:42.228
before continuing here, please
feel free to do so you don't

6464
06:21:42.228 --> 06:21:45.228
have to, you can absolutely
continue on with the course as

6465
06:21:45.228 --> 06:21:50.228
is. And if you get confused or
stuck on some JavaScript piece,

6466
06:21:50.228 --> 06:21:54.228
feel free to pause, Google it
and come back. But just to

6467
06:21:54.228 --> 06:21:56.228
reiterate, you can check out the
JavaScript programming full

6468
06:21:56.228 --> 06:22:00.228
course. And also the Node js
full course, as those are both

6469
06:22:00.228 --> 06:22:03.229
going to help you. Like I was
saying before, Node js is a

6470
06:22:03.229 --> 06:22:08.229
JavaScript runtime. So it's not
exactly JavaScript. But we're

6471
06:22:08.229 --> 06:22:10.229
going to write our code in
JavaScript. And if that's

6472
06:22:10.229 --> 06:22:14.229
confusing, just don't worry
about it right now. And as we go

6473
06:22:14.229 --> 06:22:17.229
through this course, I'll show
you where the differences are.

6474
06:22:17.229 --> 06:22:20.229
But basically, you can think of
no Jas and JavaScript kind of

6475
06:22:20.229 --> 06:22:23.229
being the same thing. The big
thing about Node js is it allows

6476
06:22:23.229 --> 06:22:27.229
us to write JavaScript code in
the back end, as opposed to

6477
06:22:28.229 --> 06:22:31.229
running JavaScript on the front
end, JavaScript is made to be a

6478
06:22:31.229 --> 06:22:35.229
browser run language, like
running inside of, you know,

6479
06:22:35.229 --> 06:22:40.229
Chrome, brave Firefox, etc. No,
Jas allows it to become a a

6480
06:22:40.229 --> 06:22:43.229
scripting language, a back end
language, which is why the

6481
06:22:43.229 --> 06:22:46.229
syntax between the front end
JavaScript and the back end

6482
06:22:46.229 --> 06:22:49.229
JavaScript or the no JS
JavaScript are going to be a

6483
06:22:49.229 --> 06:22:52.229
little bit different.
Additionally, as we go along in

6484
06:22:52.229 --> 06:22:56.229
this code, if you're familiar
with TypeScript, all of our code

6485
06:22:56.229 --> 06:22:59.229
is going to come with a
TypeScript edition. TypeScript

6486
06:22:59.229 --> 06:23:03.229
is what's known as a statically
typed version of JavaScript. And

6487
06:23:03.229 --> 06:23:05.229
it'll be it'll be this one.
It'll be TypeScript, not

6488
06:23:05.229 --> 06:23:08.229
TypeScript edition. I'll go
ahead and fix that and remove

6489
06:23:08.229 --> 06:23:11.229
this one to make it clear.
TypeScript is a type safe

6490
06:23:11.229 --> 06:23:14.229
version of JavaScript, which is
that's confusing, don't worry

6491
06:23:14.229 --> 06:23:17.229
too much about that. But we are
going to do all of our

6492
06:23:17.229 --> 06:23:20.229
programming in JavaScript. And
then if the code is different

6493
06:23:20.229 --> 06:23:22.229
enough, I'll show you how to do
it in TypeScript as well.

6494
06:23:22.229 --> 06:23:24.229
However, for most of them, we're
not going to show you the

6495
06:23:24.229 --> 06:23:27.229
TypeScript editions, because
it's going to be really similar.

6496
06:23:27.229 --> 06:23:30.229
But you can always refer back to
the GitHub repository to see all

6497
06:23:30.229 --> 06:23:32.229
the code for the TypeScript.
Now, if you're new to this

6498
06:23:32.229 --> 06:23:36.229
space, I actually do recommend
you go ahead and start with

6499
06:23:36.229 --> 06:23:40.229
JavaScript and learn how to do
TypeScript later on. TypeScript

6500
06:23:40.229 --> 06:23:45.230
actually catches bugs early on,
making it a lot easier to code

6501
06:23:45.230 --> 06:23:48.230
your projects in the long run.
However, it does take a lot of

6502
06:23:48.230 --> 06:23:52.230
extra typing. And it can be a
little bit frustrating learning

6503
06:23:52.230 --> 06:23:55.230
how types work for beginners,
JavaScript is a little bit more

6504
06:23:55.230 --> 06:23:59.230
loose as a language and lets us
kind of do whatever we want, but

6505
06:23:59.230 --> 06:24:01.230
it can cause a headache later
on. So if you do run into some

6506
06:24:01.230 --> 06:24:04.230
issues, and you do run into some
bugs, it might be a good idea to

6507
06:24:04.230 --> 06:24:08.230
try TypeScript on for size, and
see how that fares. Well. Let's

6508
06:24:08.230 --> 06:24:11.230
go ahead and begin working on
our local development

6509
06:24:11.230 --> 06:24:14.230
environment and getting set up
to do everything in ethers Jas

6510
06:24:14.230 --> 06:24:17.230
and in JavaScript. Oops. And I
actually went and renamed this

6511
06:24:17.230 --> 06:24:22.230
folder to ether symbol storage
dash, FCC. Reason I added this

6512
06:24:22.230 --> 06:24:26.230
dash FCC is all the GitHub
repositories associated with

6513
06:24:26.230 --> 06:24:30.230
this course, all the GitHub
repos that have this dash FCC to

6514
06:24:30.230 --> 06:24:33.230
know that it is part of this
hard hat JavaScript course.

6515
06:24:33.230 --> 06:24:36.230
Awesome. Let's jump in. Let's
start working with solidity and

6516
06:24:36.230 --> 06:24:39.230
our smart contracts locally in
Visual Studio code, as you can

6517
06:24:39.230 --> 06:24:43.230
probably tell by the name of
this folder. And of course, if

6518
06:24:43.230 --> 06:24:46.230
you looked at the code, this
project is going to be our

6519
06:24:46.230 --> 06:24:51.230
simple storage project, but
developed locally using ethers.

6520
06:24:52.230 --> 06:24:54.230
So the first thing that we want
to do is want to get in that

6521
06:24:54.230 --> 06:24:57.230
smart contract code. So what we
can do is make sure we have the

6522
06:24:57.230 --> 06:25:01.230
Explorer selected, we can go
ahead and right click and select

6523
06:25:01.230 --> 06:25:10.230
new file and do simple storage.
So just close this for now. And

6524
06:25:10.230 --> 06:25:13.230
we can copy paste our simple
storage code from our last

6525
06:25:13.230 --> 06:25:15.230
section into VS code.

6526
06:25:15.230 --> 06:25:18.230
If you closed remix or you
forgot where it is, you can just

6527
06:25:18.230 --> 06:25:23.231
go to the ethers simple storage
FCC repo, it's simple storage

6528
06:25:23.231 --> 06:25:27.231
dot Sol, and we can just copy
all the code in here and then

6529
06:25:27.231 --> 06:25:31.231
come back over select Symbol
storage that Saul and paste it

6530
06:25:31.231 --> 06:25:35.231
in. Now an important note about
Visual Studio code is that when

6531
06:25:35.231 --> 06:25:39.231
you see this little white.up
here, it means that this file

6532
06:25:39.231 --> 06:25:45.231
isn't saved to save your Git
file. To save, and it'll go away

6533
06:25:45.231 --> 06:25:51.231
like that. Or what you can do is
you can hit command S or Ctrl S,

6534
06:25:51.231 --> 06:25:55.231
depending on if you're on a
Windows, Mac, or Linux. Now

6535
06:25:55.231 --> 06:25:58.231
you'll see here that this code
is a little bit hard to read the

6536
06:25:58.231 --> 06:26:01.231
simple storage dot salt, it
doesn't have the syntax

6537
06:26:01.231 --> 06:26:04.231
highlighting that we saw in
remix. So we want to go ahead

6538
06:26:04.231 --> 06:26:08.231
and add a Visual Studio Code
extension to give this syntax

6539
06:26:08.231 --> 06:26:11.231
highlighting. So what we can do
is come over to this bar over

6540
06:26:11.231 --> 06:26:14.231
here looks like this. And if you
don't see it on the left hand

6541
06:26:14.231 --> 06:26:17.231
bar, you should click these
three dots, and it should be in

6542
06:26:17.231 --> 06:26:20.231
here. But we'll go ahead and
click Extensions. And what we're

6543
06:26:20.231 --> 06:26:27.231
going to do is we're going to
look up, solidity plus hard hat.

6544
06:26:27.231 --> 06:26:30.231
And we're going to install this
solidity plus hard hat

6545
06:26:30.231 --> 06:26:35.231
extension. For VS code. Now that
we have this installed, if we go

6546
06:26:35.231 --> 06:26:38.231
back over to our simple storage
dot sole, you'll see that all

6547
06:26:38.231 --> 06:26:42.231
the highlighting is back in. And
now it's much easier to read.

6548
06:26:42.231 --> 06:26:45.231
Right? So this is good. We have
our code in here we have our

6549
06:26:45.231 --> 06:26:49.231
syntax highlighting. Now let's
add an auto format or or default

6550
06:26:49.231 --> 06:26:52.231
format or right now our code is
pretty good with the way that

6551
06:26:52.231 --> 06:26:57.231
it's formatted. But what if we,
we accidentally do some stuff

6552
06:26:57.231 --> 06:27:05.232
like this or like this, or maybe
even like this, we add a ton of

6553
06:27:05.232 --> 06:27:08.232
new lines, etc, our code can
start to look pretty gross. And

6554
06:27:08.232 --> 06:27:12.232
even though the code itself is
fine, and it'll run the exact

6555
06:27:12.232 --> 06:27:15.232
same way, with all this extra
whitespace, it doesn't look very

6556
06:27:15.232 --> 06:27:18.232
good, right. And due to that, it
can be a little bit hard to

6557
06:27:18.232 --> 06:27:22.232
read. What we want to do, then,
we want to open up our settings

6558
06:27:22.232 --> 06:27:26.232
and adjust our vias code so that
it auto formats whenever we

6559
06:27:26.232 --> 06:27:30.232
save, so whenever we save, so
that whenever it goes from the

6560
06:27:30.232 --> 06:27:34.232
little white dot here to no
white dot, this whole thing gets

6561
06:27:34.232 --> 06:27:38.232
automatically formatted to some
looks really nice. Okay. So what

6562
06:27:38.232 --> 06:27:42.232
we can do is we can open up our
command palette to open up our

6563
06:27:42.232 --> 06:27:46.232
command palette, you can hit
View command palette, and we'll

6564
06:27:46.232 --> 06:27:50.232
get a little pop up that looks
like this. Another way to open

6565
06:27:50.232 --> 06:27:52.232
up your command palette is
you're gonna hit Command, Shift

6566
06:27:52.232 --> 06:27:57.232
P, or Ctrl, Shift P, depending
on your Mac, or Linux or

6567
06:27:57.232 --> 06:28:00.232
Windows. And what we want to do
is we want to type in settings,

6568
06:28:00.232 --> 06:28:03.232
and we're going to open Settings
JSON, we don't want to open the

6569
06:28:03.232 --> 06:28:07.232
default settings JSON. We don't
want to touch these. But we want

6570
06:28:07.232 --> 06:28:10.232
to open our JSON settings.
You'll also notice there are

6571
06:28:10.232 --> 06:28:13.232
user settings and workspace
settings. These are pieces that

6572
06:28:13.232 --> 06:28:16.232
we can adjust as well. But we're
going to just go right into the

6573
06:28:16.232 --> 06:28:20.232
JSON settings. So So I already
have some stuff in here, but

6574
06:28:20.232 --> 06:28:23.232
yours might be blank. Or you
might have some stuff in here as

6575
06:28:23.232 --> 06:28:25.232
well. So what we're going to do
is if you have stuff in here

6576
06:28:25.232 --> 06:28:29.232
already, we're going to add a
comma, then we're going to do

6577
06:28:29.232 --> 06:28:36.232
quotes, solidity. Close the
brackets, we're gonna do a

6578
06:28:36.232 --> 06:28:39.232
little colon and something like
this. This means that we're

6579
06:28:39.232 --> 06:28:42.232
going to apply some settings to
our Visual Studio Code. Whenever

6580
06:28:43.232 --> 06:28:45.233
we're working with solidity, one
of the things we're going to add

6581
06:28:45.233 --> 06:28:50.233
in here is going to be an
editor, Doc's default, for

6582
06:28:50.233 --> 06:28:55.233
matter. And you might even get a
pop up that tells you some

6583
06:28:55.233 --> 06:28:58.233
different things that we can use
for a default format or our

6584
06:28:58.233 --> 06:29:03.233
default format, or is going to
be Nanak, foundation, dot hard

6585
06:29:03.233 --> 06:29:09.233
hat, hyphens solidity. This will
mean that any time we go to

6586
06:29:09.233 --> 06:29:13.233
format our code, it'll use the
hard hat solidity plug in, as

6587
06:29:13.233 --> 06:29:18.233
its default format, or the hard
hat solidity plugin comes with

6588
06:29:18.233 --> 06:29:22.233
some formatting, and a lot of
other really useful tools for us

6589
06:29:22.233 --> 06:29:26.233
writing our code. So now that we
have this part in, the next

6590
06:29:26.233 --> 06:29:29.233
thing we're going to do is add
format on Save. If we haven't

6591
06:29:29.233 --> 06:29:33.233
already, we could add it in here
in our JSON, but I'm going to

6592
06:29:33.233 --> 06:29:36.233
add it not in the JSON file, I'm
going to add it in the overall

6593
06:29:36.233 --> 06:29:40.233
file. So if we open that command
palette back up, and we type in

6594
06:29:40.233 --> 06:29:45.233
settings, open user settings,
this is another really good

6595
06:29:45.233 --> 06:29:48.233
place where we can look in add
settings with the UI. So these

6596
06:29:48.233 --> 06:29:51.233
two do essentially the same
thing. It's just that this one

6597
06:29:51.233 --> 06:29:54.233
has dials and a little bit more
context versus settings that

6598
06:29:54.233 --> 06:29:57.233
JSON just says Okay, give me the
raw code for it. This tells us a

6599
06:29:57.233 --> 06:30:00.233
little bit more. So you can use
either one. But we're going to

6600
06:30:00.233 --> 06:30:05.233
look for format, on save. And
you're going to want this

6601
06:30:05.233 --> 06:30:09.233
checked if you haven't already.
This means that every time we

6602
06:30:09.233 --> 06:30:14.233
save VS code is going to try to
format our code for us. So now

6603
06:30:14.233 --> 06:30:16.233
that we have this checked, we
have settings dot JSON added in.

6604
06:30:16.233 --> 06:30:19.233
And remember, we want to save
this. Remember, if you see this

6605
06:30:19.233 --> 06:30:22.233
white dot, that means not saved.
So you're gonna want to save it

6606
06:30:22.233 --> 06:30:25.234
and close it out. Let me close
this out too. If we come back in

6607
06:30:25.234 --> 06:30:28.234
here and we add a bunch of
random new spaces or whatever,

6608
06:30:28.234 --> 06:30:31.234
you want to make it look a
little bit ugly, and then we

6609
06:30:31.234 --> 06:30:36.234
save it. It should automatically
reformat to look much nicer,

6610
06:30:36.234 --> 06:30:40.234
right. So if we do something
like this, we'd save it

6611
06:30:40.234 --> 06:30:43.234
reformats it to look much nicer
this one make them more readable

6612
06:30:43.234 --> 06:30:46.234
for you, and more readable for
anybody else who looks at your

6613
06:30:46.234 --> 06:30:50.234
code. And it's just really nice.
And this line of code for your

6614
06:30:50.234 --> 06:30:54.234
settings dot JSON is located in
the full blockchain study

6615
06:30:54.234 --> 06:30:57.234
course.js. So you can also just
copy paste it, we are going to

6616
06:30:57.234 --> 06:31:01.234
end up overriding that default
format or with another format

6617
06:31:01.234 --> 06:31:05.234
are called prettier pretty soon.
But it's great to have a default

6618
06:31:05.234 --> 06:31:08.234
format or so that if you don't
feel like adding the prettier

6619
06:31:08.234 --> 06:31:12.234
code sometime in the future, you
can just rely on your default

6620
06:31:12.234 --> 06:31:16.234
formatter. Awesome. While we're
doing formatting, let's also add

6621
06:31:16.234 --> 06:31:19.234
a default format or for our
JavaScript code. And just to

6622
06:31:19.234 --> 06:31:22.234
test it out, let's go ahead and
create our new file, we'll call

6623
06:31:22.234 --> 06:31:28.234
it deploy dot Jas. And in here,
we can do something like

6624
06:31:28.234 --> 06:31:30.234
function Hi,

6625
06:31:30.234 --> 06:31:37.234
console dot log, hi, and then
just add and then just make it

6626
06:31:37.234 --> 06:31:40.234
look kind of gross, maybe
something like this. If you hit

6627
06:31:40.234 --> 06:31:43.234
save, and it does some auto
formatting, that's great, you

6628
06:31:43.234 --> 06:31:46.234
can actually turn that off by
going back to your command

6629
06:31:46.234 --> 06:31:51.234
palette, and saying, Save
without formatting. And that way

6630
06:31:51.234 --> 06:31:54.234
it will be saved and not
formatted. The way we can add

6631
06:31:54.234 --> 06:31:56.234
some other formatting here is
we're gonna install another

6632
06:31:56.234 --> 06:32:01.234
extension, this one is going to
be called prettier. So we can

6633
06:32:01.234 --> 06:32:04.235
just look up prettier and
extensions here. And you'll want

6634
06:32:04.235 --> 06:32:08.235
to install this prettier code
formatter. So we're gonna go

6635
06:32:08.235 --> 06:32:11.235
ahead and install this. And
great, now it's installed

6636
06:32:11.235 --> 06:32:15.235
prettier is a form is a code
format, or that works for many

6637
06:32:15.235 --> 06:32:18.235
languages like Python,
JavaScript, and even solidity.

6638
06:32:19.235 --> 06:32:22.235
And pretty soon we're going to
use prettier for both JavaScript

6639
06:32:22.235 --> 06:32:25.235
and solidity. But for now, we're
just going to use prettier for

6640
06:32:25.235 --> 06:32:28.235
JavaScript, we can enable this
by opening back up our command

6641
06:32:28.235 --> 06:32:32.235
palette, we'll go to
preferences, open Settings. And

6642
06:32:32.235 --> 06:32:36.235
the same way we added a solidity
section, we're going to add a

6643
06:32:36.235 --> 06:32:41.235
JavaScript section. So we're
going to add a comma here, some

6644
06:32:41.235 --> 06:32:46.235
quotes, brackets, we're going to
type in JavaScript, close that

6645
06:32:46.235 --> 06:32:51.235
colon brackets. And we're going
to do the same thing at the door

6646
06:32:51.235 --> 06:32:58.235
dot default, or matter. Net
we're going to do and then in

6647
06:32:58.235 --> 06:33:04.235
here, we're going to do e s
BENP, that prettier, hyphen VS

6648
06:33:04.235 --> 06:33:08.235
code. And this will make
prettier the default editor for

6649
06:33:08.235 --> 06:33:11.235
JavaScript. Now, like I said,
pretty soon, we're going to have

6650
06:33:11.235 --> 06:33:15.235
prettier override both of these
for solidity and JavaScript. And

6651
06:33:15.235 --> 06:33:18.235
we're going to give prettier
some parameters so that no

6652
06:33:18.235 --> 06:33:21.235
matter who uses your code, they
will always have the exact same

6653
06:33:21.235 --> 06:33:24.235
formatting. But now that we have
prettier in here as the default

6654
06:33:25.235 --> 06:33:29.235
editor, if we come back to
deploy dot j s, and we hit save,

6655
06:33:29.235 --> 06:33:33.235
it should format to look a
little something like this. Now,

6656
06:33:33.235 --> 06:33:36.235
we go ahead and we do something
like this. If we go ahead and do

6657
06:33:36.235 --> 06:33:39.235
something like this, it'll
reformat to look like look like

6658
06:33:39.235 --> 06:33:43.235
that. And then additionally, if
you want to go back to the

6659
06:33:43.235 --> 06:33:47.236
command palette, open user
settings, not in JSON mode, and

6660
06:33:47.236 --> 06:33:51.236
we go to default format, or you
can actually even select the

6661
06:33:52.236 --> 06:33:56.236
default format or for all
languages, if you want to use

6662
06:33:56.236 --> 06:33:59.236
prettier for all formatters.
Feel free to go ahead. Alright,

6663
06:33:59.236 --> 06:34:02.236
great, got our JavaScript
format, or in as well, let's

6664
06:34:02.236 --> 06:34:07.236
start writing some JavaScript
code.

6665
06:34:07.236 --> 06:34:10.236
Awesome. So now that we have our
code in here, it's time for us

6666
06:34:10.236 --> 06:34:15.236
to learn how to actually deploy
our contract using JavaScript.

6667
06:34:15.236 --> 06:34:17.236
This is going to teach us a lot
about transactions and what's

6668
06:34:17.236 --> 06:34:21.236
going on under the hood, and
even what's going on under the

6669
06:34:21.236 --> 06:34:24.236
hood in remix, and remix, we
usually just hit a compile

6670
06:34:24.236 --> 06:34:28.236
button, and then hit a Deploy
button. And that's really it. In

6671
06:34:28.236 --> 06:34:31.236
JavaScript, we're actually going
to create our own functions that

6672
06:34:31.236 --> 06:34:33.236
are going to help us do both of
those. And as I mentioned, this

6673
06:34:33.236 --> 06:34:35.236
is the part of the course we're
going to start working with

6674
06:34:35.236 --> 06:34:39.236
JavaScript, and optionally,
TypeScript if you like. Like I

6675
06:34:39.236 --> 06:34:42.236
said, all of these sections come
with a TypeScript edition as

6676
06:34:42.236 --> 06:34:47.236
well. So let's set up our
deployed out js script to

6677
06:34:47.236 --> 06:34:50.236
actually deploy our simple
storage dot soul. So how can we

6678
06:34:50.236 --> 06:34:53.236
get started here? Well, let's
first learn how to run a script

6679
06:34:53.236 --> 06:34:57.236
using JavaScript and Node J S.
So if you want to do a print

6680
06:34:57.236 --> 06:35:00.236
line, or just print something
out to your terminal, we can do

6681
06:35:00.236 --> 06:35:04.236
something called a console dot
log. And if I do console dot

6682
06:35:04.236 --> 06:35:10.236
log, hi, I hit Save. And I open
up my terminal. I can now run

6683
06:35:10.236 --> 06:35:16.236
Node deploy.js. And it'll print
out high node is how we say hey,

6684
06:35:16.236 --> 06:35:21.236
we want to run this JavaScript
code using Node js. Other

6685
06:35:21.236 --> 06:35:24.237
languages you might be familiar
with, sometimes we'll do Python,

6686
06:35:24.237 --> 06:35:30.237
you know, deployed up py, or
Java, C deploy dot Java, you

6687
06:35:30.237 --> 06:35:34.237
know, etc. But with JavaScript,
since the front end and back end

6688
06:35:34.237 --> 06:35:37.237
JavaScript are different. We run
code on the back end with node.

6689
06:35:37.237 --> 06:35:40.237
And with JavaScript, you can do
a lot of things that you'd see

6690
06:35:40.237 --> 06:35:43.237
in something like solidity with
a little bit looser have a

6691
06:35:43.237 --> 06:35:46.237
structure. If I wanted to create
some variable, I could say let

6692
06:35:46.237 --> 06:35:51.237
variable equals five, this kind
of similar into solidity like

6693
06:35:51.237 --> 06:35:57.237
you and 256, variable equals
five. But in JavaScript, we use

6694
06:35:57.237 --> 06:36:01.237
let or var or const. And then I
can print this out, I can do

6695
06:36:01.237 --> 06:36:08.237
console dot log variable. And I
had saved JavaScript is optional

6696
06:36:08.237 --> 06:36:11.237
on whether or not you actually
want to have semicolons. Here, I

6697
06:36:11.237 --> 06:36:14.237
think prettier, defaults to
putting semicolons. And we'll

6698
06:36:14.237 --> 06:36:17.237
get rid of those in the near
future in your terminal. Once

6699
06:36:17.237 --> 06:36:22.237
you start typing the name of a
file, if you hit tab, it could

6700
06:36:22.237 --> 06:36:26.237
autocomplete the rest of the
file name for you node deploy

6701
06:36:26.237 --> 06:36:31.237
hit Tab, it'll autocomplete and
if we hit enter, now, we get Hi,

6702
06:36:31.237 --> 06:36:34.237
and then we get five. Since this
prints out Hi, and then it

6703
06:36:34.237 --> 06:36:37.237
prints out five. JavaScript
automatically starts with

6704
06:36:37.237 --> 06:36:40.237
whatever code you have at the
top of the file. So it does

6705
06:36:40.237 --> 06:36:43.237
console dot log first and
variable. And then this one as

6706
06:36:43.237 --> 06:36:47.237
well. However, a good practice
is to actually wrap everything

6707
06:36:47.237 --> 06:36:51.237
you want to do in a main
function, and then run that main

6708
06:36:51.237 --> 06:36:55.237
function. But what we could do
is up at the top here, we'd say

6709
06:36:55.237 --> 06:37:01.237
function, mean, add parentheses
and some brackets, a closing

6710
06:37:01.237 --> 06:37:05.238
bracket at the bottom, and hit
save for its auto format. Right

6711
06:37:05.238 --> 06:37:07.238
now, if we run this, nothing
will happen, because we've

6712
06:37:07.238 --> 06:37:11.238
wrapped all of our code in a
main function. So if I run it

6713
06:37:11.238 --> 06:37:15.238
now node deployed to Jess,
nothing happens, because I need

6714
06:37:15.238 --> 06:37:19.238
something to call the main
function. So if I then take

6715
06:37:19.238 --> 06:37:24.238
this, this main function down
here, and I call main, our jobs

6716
06:37:24.238 --> 06:37:26.238
from code is actually going to
say, ah, the first line of the

6717
06:37:26.238 --> 06:37:30.238
script is actually this main
function here. So now if I do

6718
06:37:30.238 --> 06:37:33.238
node deploy dot j, s, it'll run
high and five, which is what we

6719
06:37:33.238 --> 06:37:36.238
want. Now, this is going to be
the setup for most of our

6720
06:37:36.238 --> 06:37:39.238
scripts moving forward,
including the scripts that we

6721
06:37:39.238 --> 06:37:41.238
write, when we get to hard hat,
however, there is going to be

6722
06:37:41.238 --> 06:37:45.238
one major difference. Instead of
regular functions, we're

6723
06:37:45.238 --> 06:37:48.238
actually going to use something
called async functions. And

6724
06:37:48.238 --> 06:37:50.238
we're going to do something
called asynchronous programming

6725
06:37:50.238 --> 06:37:54.238
to do this. Now, if what I say
next is really confusing for you

6726
06:37:54.238 --> 06:37:57.238
don't let it slow you down, feel
free to go ahead and watch that

6727
06:37:57.238 --> 06:38:00.238
JavaScript course to learn more
about this. But I'll also let

6728
06:38:00.238 --> 06:38:03.238
you know, hey, this is an async
function. Here's what we need to

6729
06:38:03.238 --> 06:38:05.238
be aware of when working with
it,

6730
06:38:05.238 --> 06:38:16.238
okay. But I do want to give you
a quick bit background on

6731
06:38:16.238 --> 06:38:19.238
asynchronous programming. So
far, the programming that we've

6732
06:38:19.238 --> 06:38:22.238
done has been synchronous. And
solidity is an example of a

6733
06:38:22.238 --> 06:38:25.238
programming language, that
synchronous, Synchronous means

6734
06:38:25.238 --> 06:38:28.238
it just goes one line after
another. If our code looks like

6735
06:38:28.238 --> 06:38:32.238
this, this is synchronous write,
our main function is the first

6736
06:38:32.238 --> 06:38:36.238
thing that actually gets called.
Then we do console dot log, that

6737
06:38:36.238 --> 06:38:38.238
variable equals five, and then
console dot log. Again, this is

6738
06:38:38.238 --> 06:38:41.238
synchronous programming in
JavaScript, all of our solidity

6739
06:38:41.238 --> 06:38:44.239
is synchronously programmed.
There will be some exceptions to

6740
06:38:44.239 --> 06:38:46.239
this when working with oracles.
But for now, everything is

6741
06:38:46.239 --> 06:38:50.239
synchronous. JavaScript can be
asynchronous, meaning that we

6742
06:38:50.239 --> 06:38:54.239
can actually have code running
at the same time. A good example

6743
06:38:54.239 --> 06:38:58.239
I like to use to understand the
difference is with cooking. In

6744
06:38:58.239 --> 06:39:02.239
synchronous programming, for
cooking, you might put popcorn

6745
06:39:02.239 --> 06:39:08.239
in microwave, wait for popcorn
to finish. And then, and then

6746
06:39:08.239 --> 06:39:11.239
maybe you'll pour drinks for
everyone. And now this is

6747
06:39:11.239 --> 06:39:14.239
synchronous programming. Now, it
might be a little bit weird for

6748
06:39:14.239 --> 06:39:17.239
you just to put the popcorn in
the microwave, and then just

6749
06:39:17.239 --> 06:39:19.239
stare at it, waiting for it to
finish. And then pour the

6750
06:39:19.239 --> 06:39:24.239
drinks, you typically can pour
the drinks while your popcorn is

6751
06:39:24.239 --> 06:39:27.239
in the microwave. And this is
where asynchronous programming

6752
06:39:27.239 --> 06:39:30.239
comes in. If setting up for this
movie night, we're asynchronous,

6753
06:39:30.239 --> 06:39:34.239
what you would do is you'd put
popcorn in the microwave. And

6754
06:39:34.239 --> 06:39:37.239
while the popcorn is in the
microwave, or drinks for

6755
06:39:37.239 --> 06:39:42.239
everyone, and then you'd wait
for popcorn finish, since

6756
06:39:42.239 --> 06:39:45.239
there's nothing left for you to
do, but it doesn't make sense

6757
06:39:45.239 --> 06:39:48.239
for you to wait for the popcorn
to finish to pour your drinks,

6758
06:39:48.239 --> 06:39:51.239
you can just go ahead and pour
the drinks right away and then

6759
06:39:51.239 --> 06:39:54.239
wait for the popcorn to finish.
So asynchronous programming is

6760
06:39:54.239 --> 06:39:57.239
way for us to do stuff without
waiting around for things to

6761
06:39:57.239 --> 06:40:00.239
finish. And this is really
advantageous in JavaScript by

6762
06:40:00.239 --> 06:40:02.239
default allows us to do this
asynchronous programming,

6763
06:40:02.239 --> 06:40:05.239
however, sometimes we do want to
wait for our popcorn to finish.

6764
06:40:05.239 --> 06:40:09.239
For example, if instead of just
pouring drinks, maybe the next

6765
06:40:09.239 --> 06:40:14.239
thing instead of pouring drinks
was placed salt on popcorn. Of

6766
06:40:14.239 --> 06:40:17.239
course, if we want to play salt
on our popcorn, we do have to

6767
06:40:17.239 --> 06:40:20.239
wait for the popcorn to get out
of the microwave. So even though

6768
06:40:20.239 --> 06:40:24.240
placing popcorn in the microwave
has this wait time we need to be

6769
06:40:24.240 --> 06:40:27.240
able to tell our code I want you
to actually wait for it or No,

6770
06:40:27.240 --> 06:40:31.240
you're good. You can go on and
do another task. So that's kind

6771
06:40:31.240 --> 06:40:34.240
of the difference here. And I'll
leave some links in the GitHub

6772
06:40:34.240 --> 06:40:36.240
repo associated with this course
to understand this a little bit

6773
06:40:36.240 --> 06:40:39.240
better functions that have
functions that come with this

6774
06:40:39.240 --> 06:40:43.240
waiting period return something
called a problem. This, if put

6775
06:40:43.240 --> 06:40:46.240
popcorn in the microwave was a
function in JavaScript, it would

6776
06:40:46.240 --> 06:40:51.240
be a promise based function. A
promise can be either pending,

6777
06:40:51.240 --> 06:40:55.240
fulfilled, or rejected. And this
is how we know if our popcorn is

6778
06:40:55.240 --> 06:40:58.240
done. If our popcorn was a
method, putting popcorn in the

6779
06:40:58.240 --> 06:41:01.240
microwave, were a function in
JavaScript, when we're waiting

6780
06:41:01.240 --> 06:41:04.240
for the popcorn to finish, it's
in a pending state. When it's

6781
06:41:04.240 --> 06:41:08.240
when the popcorn is finished, it
would be fulfilled. And if we

6782
06:41:08.240 --> 06:41:11.240
aborted halfway through, and we
stopped waiting, it would be

6783
06:41:11.240 --> 06:41:14.240
rejected. So putting the popcorn
in the microwave returns a

6784
06:41:14.240 --> 06:41:18.240
promise. With this promise, we
have to tell our code, hey, we

6785
06:41:18.240 --> 06:41:22.240
want you to wait for the popcorn
to finish or you can go ahead

6786
06:41:22.240 --> 06:41:24.240
and you can just keep doing
stuff. So let's put this all

6787
06:41:24.240 --> 06:41:27.240
together with some JavaScript
syntax here. Let's say again,

6788
06:41:27.240 --> 06:41:30.240
we're going to be setting up
this movie night. And we need to

6789
06:41:30.240 --> 06:41:34.240
cook popcorn, pour drinks for
everybody. And then we need to

6790
06:41:34.240 --> 06:41:37.240
start a movie. So let's write
some pseudocode to pretend what

6791
06:41:37.240 --> 06:41:40.240
this code would look like if
this was actually a function. So

6792
06:41:40.240 --> 06:41:45.240
we create some function called
setup, Movie Night. And in here,

6793
06:41:45.240 --> 06:41:48.240
we would say okay, what's the
first thing we need to do? Okay,

6794
06:41:48.240 --> 06:41:50.240
we need to cook popcorn. So
let's say we have some cook

6795
06:41:50.240 --> 06:41:54.240
popcorn function. So we'll say,
okay, cook popcorn, then the

6796
06:41:54.240 --> 06:41:55.240
next thing we're gonna have to
do is we're gonna have to pour

6797
06:41:55.240 --> 06:42:00.240
drinks, or drink. So we'll call
some pour drinks function. Now

6798
06:42:00.240 --> 06:42:03.240
here's the thing, we only want
to start the movie once our

6799
06:42:03.240 --> 06:42:07.241
popcorn has been cooked. And
once our drinks have been

6800
06:42:07.241 --> 06:42:11.241
poured, so if either one of
these returned a promise, so if

6801
06:42:11.241 --> 06:42:14.241
either one of these returns a
promise, like cook popcorn, for

6802
06:42:14.241 --> 06:42:18.241
example, we would need to tell
our code here to actually wait

6803
06:42:18.241 --> 06:42:21.241
for the popcorn to finish
because cook popcorn is going to

6804
06:42:21.241 --> 06:42:25.241
be a function where we could say
let status equals cook popcorn.

6805
06:42:25.241 --> 06:42:29.241
And while the popcorn is being
cooked, the status is going to

6806
06:42:29.241 --> 06:42:33.241
be ending. Once the popcorn gets
cooked, it'll be fulfilled. If

6807
06:42:33.241 --> 06:42:35.241
the popcorn breaks, the
microwave explodes, the status

6808
06:42:35.241 --> 06:42:39.241
would be rejected. But we don't
want the status to be in a

6809
06:42:39.241 --> 06:42:42.241
pending situation. Before we
move on, we only want to start

6810
06:42:42.241 --> 06:42:45.241
our movie once these two
functions have completed. And

6811
06:42:45.241 --> 06:42:48.241
let's say both of these return
these promises things. So we

6812
06:42:48.241 --> 06:42:52.241
need to tell our code, hey, you
have to wait. Or you have to

6813
06:42:52.241 --> 06:42:56.241
wait for cook popcorn and for
poor drinks to finish. So what

6814
06:42:56.241 --> 06:42:59.241
we can do now without getting
too deep into the weeds on how

6815
06:42:59.241 --> 06:43:01.241
all this works, one of the
easiest things that we can do

6816
06:43:01.241 --> 06:43:04.241
and you'll see us use this
syntax quite often is we'll turn

6817
06:43:04.241 --> 06:43:08.241
this function into an async
function. When our functions are

6818
06:43:08.241 --> 06:43:12.241
async, we get access to a
keyword called await the await

6819
06:43:12.241 --> 06:43:17.241
keyword tells any promise based
function to wait for that

6820
06:43:17.241 --> 06:43:20.241
promise to be fulfilled or
rejected. So we say okay, we

6821
06:43:20.241 --> 06:43:24.241
want to await for our popcorn to
cook. And then we want to await

6822
06:43:24.241 --> 06:43:27.241
to pour drinks. And then we can
just go ahead and start the

6823
06:43:27.241 --> 06:43:31.241
movie. And we only start the
movie here once these two have

6824
06:43:31.241 --> 06:43:34.241
been completed. And this is why
throughout all of our code,

6825
06:43:34.241 --> 06:43:37.241
you'll see this await keyword
used a lot. But it can only be

6826
06:43:37.241 --> 06:43:40.241
used in async functions. So
basically, whenever you see this

6827
06:43:40.241 --> 06:43:44.242
await keyword just now Ah, okay,
the function that's being called

6828
06:43:44.242 --> 06:43:48.242
is promise based. And we don't
want to move on to the next step

6829
06:43:48.242 --> 06:43:50.242
until that function has
completed. So that's a little

6830
06:43:50.242 --> 06:43:53.242
bit more about promises and
asynchronous programming.

6831
06:43:53.242 --> 06:43:56.242
Hopefully, that's clear. If not,
like I said, there's some links

6832
06:43:56.242 --> 06:43:59.242
in the description to learn more
about asynchronous programming.

6833
06:43:59.242 --> 06:44:01.242
The reason I wanted to go
through this is because most of

6834
06:44:01.242 --> 06:44:03.242
the functions that we're going
to be working with are going to

6835
06:44:03.242 --> 06:44:07.242
be asynchronous. For example,
when we deploy a contract, what

6836
06:44:07.242 --> 06:44:14.242
do we have to do? Well, we have
to wait for it to be deployed.

6837
06:44:14.242 --> 06:44:16.242
If we don't use synchronous
programming, and we just leave

6838
06:44:16.242 --> 06:44:20.242
our function main like this,
what would happen is we would

6839
06:44:20.242 --> 06:44:24.242
write some code like contract
dot deploy, and we wouldn't wait

6840
06:44:24.242 --> 06:44:29.242
for it to finish. Obviously, if
we don't wait for it to finish,

6841
06:44:29.242 --> 06:44:32.242
and we try to run some code on a
contract that hasn't finished

6842
06:44:32.242 --> 06:44:35.242
deploying it, it's not going to
work. So we want to do this, we

6843
06:44:35.242 --> 06:44:38.242
want to have our main function
be an async function, so that we

6844
06:44:38.242 --> 06:44:42.242
can we can wait for our
contracts to deploy, we can wait

6845
06:44:42.242 --> 06:44:45.242
for things to happen, we can
wait for our popcorn to finish,

6846
06:44:45.242 --> 06:44:48.242
we can have the flexibility to
tell our code to either wait for

6847
06:44:48.242 --> 06:44:51.242
our popcorn to finish or
continue on. So now that we have

6848
06:44:51.242 --> 06:44:54.242
our main function as an async
function, we're going to add

6849
06:44:54.242 --> 06:44:57.242
some code to our main function
down here. And the code that's

6850
06:44:57.242 --> 06:45:00.242
added here is some syntax for
working with asynchronous

6851
06:45:00.242 --> 06:45:02.242
functions. And if this part is
confusing, I'm just going to say

6852
06:45:02.242 --> 06:45:05.242
for now, absolute, don't worry
about this. If you want to try

6853
06:45:05.242 --> 06:45:07.242
to understand that later. That's
fine. But for those who are

6854
06:45:07.242 --> 06:45:09.242
following along, we're just
going to add an add

6855
06:45:09.242 --> 06:45:25.243
then catch air air you can
follow along typing this

6856
06:45:25.243 --> 06:45:28.243
yourself or you can just copy
paste it into your code.

6857
06:45:28.243 --> 06:45:31.243
Basically what this allows us to
do is we have our main function,

6858
06:45:31.243 --> 06:45:34.243
that's an asynchronous function.
So when we call the main

6859
06:45:34.243 --> 06:45:38.243
function, this is some other
syntax for waiting for it to

6860
06:45:38.243 --> 06:45:41.243
basically finish and then
printing any errors it gets. And

6861
06:45:41.243 --> 06:45:44.243
that's why we do this but Again,
if this big lump of code, if

6862
06:45:44.243 --> 06:45:46.243
you're like what is going on
with this big clump of code,

6863
06:45:46.243 --> 06:45:49.243
honestly, for now, just copy
paste it. So great. We have our

6864
06:45:49.243 --> 06:45:52.243
asynchronous function main, we
have some code. And then we have

6865
06:45:52.243 --> 06:45:55.243
this lump of code, which
basically just calls our main

6866
06:45:55.243 --> 06:45:58.243
asynchronous function. Okay,
great. I'm gonna delete all this

6867
06:45:58.243 --> 06:46:01.243
for now. But you can still find
that common in the GitHub repo

6868
06:46:01.243 --> 06:46:04.243
associated with this course.
Awesome. Okay, so now that we

6869
06:46:04.243 --> 06:46:08.243
have our real basic setup, let's
go ahead and start coding. And

6870
06:46:08.243 --> 06:46:11.243
if this set apart is confusing,
and the async await stuff is

6871
06:46:11.243 --> 06:46:14.243
confusing, don't worry too much
about it. It'll make more sense

6872
06:46:14.243 --> 06:46:19.243
as we progress. All of our code
basically is going to be inside

6873
06:46:19.243 --> 06:46:22.243
of this async function main,
which is going to be our main

6874
06:46:22.243 --> 06:46:25.243
script for deploying our simple
storage dot soul store deploy

6875
06:46:25.243 --> 06:46:29.243
script is going to replicate
exactly what goes on in remix,

6876
06:46:29.243 --> 06:46:32.243
in remix, what was the first
thing that we always did? Well,

6877
06:46:32.243 --> 06:46:35.243
the first thing that we would do
is actually compile all of our

6878
06:46:35.243 --> 06:46:38.243
code. So we're going to want to
compile our code in our

6879
06:46:38.243 --> 06:46:42.243
JavaScript project as well. In
order for us to compile our

6880
06:46:42.243 --> 06:46:45.243
simple storage contract, we're
going to use a tool called Silk

6881
06:46:45.243 --> 06:46:48.243
Jas, and JavaScript actually has
a way to install projects

6882
06:46:48.243 --> 06:46:52.243
directly into our setups and
into our folders. If we scroll

6883
06:46:52.243 --> 06:46:55.243
down this silk Jas is exactly
what we're looking for. Because

6884
06:46:55.243 --> 06:46:58.243
it has a way to compile a
contract that imports other

6885
06:46:58.243 --> 06:47:02.243
contracts via relative paths,
you can see a section in this

6886
06:47:02.243 --> 06:47:05.244
readme and most documentation
will have something like this,

6887
06:47:05.244 --> 06:47:09.244
if it's JavaScript compatible.
For Node js usage, it says to

6888
06:47:09.244 --> 06:47:11.244
use the latest stable version of
the solidity compiler via Node

6889
06:47:11.244 --> 06:47:17.244
js, you can install it via NPM
npm install. So NPM is what's

6890
06:47:17.244 --> 06:47:22.244
known as a package manager. And
we actually installed NPM just

6891
06:47:22.244 --> 06:47:26.244
by installing no Jess, right, if
we do no dash dash version, you

6892
06:47:26.244 --> 06:47:30.244
should also be able to do NPM
dash dash version. Another tool

6893
06:47:30.244 --> 06:47:33.244
that it comes with is something
called core pack. And you can

6894
06:47:33.244 --> 06:47:36.244
type core pack dash dash
version, now we can install with

6895
06:47:36.244 --> 06:47:40.244
NPM using npm install silk,
however, I like the yarn package

6896
06:47:40.244 --> 06:47:44.244
manager a little bit better. So
we're actually going to install

6897
06:47:44.244 --> 06:47:47.244
the yarn package manager instead
to do all of our package

6898
06:47:47.244 --> 06:47:51.244
management. If you go to the
installation page, the newer way

6899
06:47:51.244 --> 06:47:54.244
to install yarn is just by
running core pack enable. And

6900
06:47:54.244 --> 06:47:58.244
the older way is to install with
NPM. If you go ahead and run

6901
06:47:58.244 --> 06:48:01.244
core pack enable after that
finishes, you should be able to

6902
06:48:01.244 --> 06:48:07.244
run yarn dash dash version.
Alternatively, you can just run

6903
06:48:07.244 --> 06:48:12.244
NPM i dash g core pack, and then
you can run core pack enable.

6904
06:48:13.244 --> 06:48:17.244
The last option you have is you
can run NPM i dash g

6905
06:48:17.244 --> 06:48:21.244
yarn. This will install yarn
globally for your system. But

6906
06:48:21.244 --> 06:48:25.244
this is considered the outdated
way to install yarn. And ideally

6907
06:48:25.244 --> 06:48:29.244
you run core pack enable. But in
any case, after you run those,

6908
06:48:29.244 --> 06:48:31.244
if you run yarn dash dash
version, you should get

6909
06:48:31.244 --> 06:48:35.244
something that looks like this.
Now that we have yarn, we can

6910
06:48:35.244 --> 06:48:39.244
actually use yarn to install all
of our projects, instead of NPM.

6911
06:48:39.244 --> 06:48:44.244
Back in silk Jas where it says
npm install soak, we can do the

6912
06:48:44.244 --> 06:48:49.245
yarn equivalents of NPM install
sock, which is going to be yarn,

6913
06:48:49.245 --> 06:48:55.245
add sock, this will actually go
ahead and install solc to our

6914
06:48:55.245 --> 06:48:59.245
project. If we open up our
folders, you'll actually see

6915
06:48:59.245 --> 06:49:01.245
that this added a couple of
different folders, it first

6916
06:49:01.245 --> 06:49:06.245
added a package dot JSON package
dot JSON is a file that tells us

6917
06:49:06.245 --> 06:49:09.245
a lot about our project and the
dependencies that it works with.

6918
06:49:09.245 --> 06:49:15.245
For example, we've installed the
soap package of 0.8 point 13.

6919
06:49:15.245 --> 06:49:18.245
Our yarn dot lock tells us the
exact version of all the

6920
06:49:18.245 --> 06:49:22.245
different packages of our
project. For example, the reason

6921
06:49:22.245 --> 06:49:25.245
this is so important too, is
solc has a ton of dependencies

6922
06:49:25.245 --> 06:49:30.245
as well. So yarn dot lock tells
us exactly what version of solc

6923
06:49:30.245 --> 06:49:32.245
and all the different
dependencies of solchen. Any

6924
06:49:32.245 --> 06:49:36.245
other project that we add. This
is autogenerated file, don't

6925
06:49:36.245 --> 06:49:39.245
edit the file directly. The
final bit is we got this node

6926
06:49:39.245 --> 06:49:44.245
modules folder. This node
modules folder is going to be

6927
06:49:44.245 --> 06:49:47.245
where all the installed code
that we just downloaded is, for

6928
06:49:47.245 --> 06:49:51.245
example, if we look at node
modules, we can see there's a

6929
06:49:51.245 --> 06:49:55.245
sock folder. And inside this
sock folder is all the code

6930
06:49:55.245 --> 06:49:59.245
associated with this soap
package that we just installed.

6931
06:49:59.245 --> 06:50:03.245
And since we're working with
zero point 8.7 of slowly, we

6932
06:50:03.245 --> 06:50:06.245
actually want to install that
specific version. So we're going

6933
06:50:06.245 --> 06:50:17.245
to do yarn add solc at zero
point 8.7 Dash fixed and you'll

6934
06:50:17.245 --> 06:50:21.245
see in our package dot JSON you
can now see zero point 8.7 Dash

6935
06:50:21.245 --> 06:50:25.246
fixed in our dependencies
section for sulk. Normally you

6936
06:50:25.246 --> 06:50:29.246
can just add your salt version
like yarn add zero point 8.7 But

6937
06:50:29.246 --> 06:50:33.246
there was an issue with zero
point 8.7 So we had to do zero

6938
06:50:33.246 --> 06:50:36.246
point 8.7 Dash fixed.

6939
06:50:36.246 --> 06:50:38.246
You can find the different
releases and the different

6940
06:50:38.246 --> 06:50:42.246
versions if you go to sulk Jas
releases and then to tags

6941
06:50:42.246 --> 06:50:45.246
Alright, great. Now that we have
sold, we have the ability to

6942
06:50:45.246 --> 06:50:50.246
actually compile our contracts,
we could either compile them in

6943
06:50:50.246 --> 06:50:54.246
our code and have it
automatically run whenever we

6944
06:50:54.246 --> 06:51:00.246
hit Deploy, or, or we could
compile them separately. If you

6945
06:51:00.246 --> 06:51:03.246
want to go back after this
section is an example in the

6946
06:51:03.246 --> 06:51:07.246
sculpt Jas repository that shows
you how to actually compile silk

6947
06:51:07.246 --> 06:51:09.246
right in your code. We are
actually going to compile them

6948
06:51:09.246 --> 06:51:14.246
separately using a soap Jas
command. The yarn command is

6949
06:51:14.246 --> 06:51:17.246
both used to install
dependencies and it can be used

6950
06:51:17.246 --> 06:51:21.246
to run scripts. If you go to
sulk Jas and you scroll down, it

6951
06:51:21.246 --> 06:51:24.246
says in order to use the command
line, you actually need to

6952
06:51:24.246 --> 06:51:27.246
install it globally. If you want
to install this globally using

6953
06:51:27.246 --> 06:51:33.246
yarn Global Add solc at zero
point 8.7 Dash fixed you can

6954
06:51:33.246 --> 06:51:36.246
absolutely go ahead. However,
since we're inside of this

6955
06:51:36.246 --> 06:51:40.246
folder here, which has the yarn
dot lock the package json and

6956
06:51:40.246 --> 06:51:44.246
the node modules yarn will be
smart enough to know i You're

6957
06:51:44.246 --> 06:51:48.246
looking for the soak in this
folder. So we can actually go

6958
06:51:48.246 --> 06:51:52.246
ahead and compile our contract
using yarn and solc Jess if you

6959
06:51:52.246 --> 06:51:55.246
want to see all the different
commands soak Jas allows we can

6960
06:51:55.246 --> 06:52:00.246
just run yarn. So Jas dash dash
help, and you'll see it'll spit

6961
06:52:00.246 --> 06:52:06.247
out a list of all the different
options that soft Jas has. You

6962
06:52:06.247 --> 06:52:11.247
can also run yarn, so Jas dash
dash version to just make sure

6963
06:52:11.247 --> 06:52:14.247
that we're on the correct
version, which is indeed zero

6964
06:52:14.247 --> 06:52:18.247
point 8.7. Now to actually
compile our simple storage at

6965
06:52:18.247 --> 06:52:23.247
soul, let's run the compliation
command we will run yarn, so J

6966
06:52:23.247 --> 06:52:29.247
S, dash dash bin since we want
the binary dash dash ABI since

6967
06:52:29.247 --> 06:52:37.247
we also want the ABI dash dash
include path node modules. Since

6968
06:52:37.247 --> 06:52:41.247
we want to include any contracts
or files in our node modules, we

6969
06:52:41.247 --> 06:52:43.247
aren't using any for this
project, but in the future, you

6970
06:52:43.247 --> 06:52:47.247
will need to include this dash
dash include path node modules

6971
06:52:47.247 --> 06:52:52.247
do dash dash base path of
period, this period means that

6972
06:52:52.247 --> 06:52:56.247
the base path is going to be
this folder dash O period, which

6973
06:52:56.247 --> 06:53:00.247
means we're going to output the
compiled binary and ABI to this

6974
06:53:00.247 --> 06:53:05.247
folder. And then finally, simple
storage dot soul. Since this is

6975
06:53:05.247 --> 06:53:08.247
the contract that we want to
compile, auto completed it from

6976
06:53:08.247 --> 06:53:12.247
simple storage to simple
storage. So by typing simple,

6977
06:53:12.247 --> 06:53:15.247
and then hitting Tab, but let's
go ahead and hit enter, you'll

6978
06:53:15.247 --> 06:53:19.247
see it's running this command to
compile this contract. And

6979
06:53:19.247 --> 06:53:24.247
you'll see two files get output.
One called Simple Storage soul

6980
06:53:24.247 --> 06:53:27.247
underscore simple storage that
API in simple storage Sol

6981
06:53:27.247 --> 06:53:31.247
underscore simple storage dot
bin, the ABI is obviously the

6982
06:53:31.247 --> 06:53:35.247
ABI of this contract, which will
need in the future. And then the

6983
06:53:35.247 --> 06:53:39.247
bin is going to be the binary,
or the really low level of this

6984
06:53:39.247 --> 06:53:42.247
code back and remix. If you
compile simple storage, that

6985
06:53:42.247 --> 06:53:46.248
soul, you can actually look at
compliation details, like the

6986
06:53:46.248 --> 06:53:51.248
ABI which we just got, or the
bytecode, which if you look at

6987
06:53:51.248 --> 06:53:59.248
this object 60806 That's the
same as the binary here 60806.

6988
06:53:59.248 --> 06:54:02.248
Alright, great. So now we've
compiled our contracts here.

6989
06:54:02.248 --> 06:54:05.248
Now, obviously, now if you hit
up on your keyboard, you can

6990
06:54:05.248 --> 06:54:09.248
actually cycle through your most
recent terminal commands. And if

6991
06:54:09.248 --> 06:54:12.248
you hit up enough, we can see
this command that we just ran

6992
06:54:12.248 --> 06:54:15.248
typing this out or hitting up a
whole bunch every single time,

6993
06:54:15.248 --> 06:54:18.248
it's going to be really annoying
to do anytime we want to

6994
06:54:18.248 --> 06:54:22.248
recompile. So what we can do is
we can add a script section in

6995
06:54:22.248 --> 06:54:26.248
our package dot JSON to shorten
some yarn scripts for us. So

6996
06:54:26.248 --> 06:54:29.248
what we'll do is back in our
package, dot JSON, a lot of

6997
06:54:29.248 --> 06:54:33.248
comma, and we'll add a section
called scripts, add the colon

6998
06:54:34.248 --> 06:54:36.248
and the brackets. And in here,
we'll say anytime we say

6999
06:54:37.248 --> 06:54:42.248
compile, we will run this long
command. So I'd compile we'll

7000
06:54:42.248 --> 06:54:46.248
put some quotes. And we'll paste
that in there. So now instead of

7001
06:54:46.248 --> 06:54:49.248
typing that whole thing out, as
long as we're in the same folder

7002
06:54:49.248 --> 06:54:54.248
that our package json is in, we
can run yarn compile. And this

7003
06:54:54.248 --> 06:54:57.248
will run that whole script for
us without us having to type the

7004
06:54:57.248 --> 06:55:00.248
whole thing out scripts are a
really useful way to make it

7005
06:55:00.248 --> 06:55:03.248
easier for us to run long
commands. All right, great. Now

7006
06:55:03.248 --> 06:55:07.248
we have our code compiled, this
is going to be equivalent to US

7007
06:55:07.248 --> 06:55:10.248
hitting this compile button for
us to actually go ahead and

7008
06:55:10.248 --> 06:55:13.248
deploy.

7009
06:55:13.248 --> 06:55:16.248
So now we have our simple
storage. That's all compiled,

7010
06:55:16.248 --> 06:55:19.248
let's learn how we can actually
deploy this thing. Remember, in

7011
06:55:19.248 --> 06:55:22.248
remix, we actually deployed it
to one of two different places,

7012
06:55:22.248 --> 06:55:27.249
we deployed it to either a
JavaScript VM, or with our

7013
06:55:27.249 --> 06:55:31.249
injected web three, with our
Metamask. Let's learn first ad,

7014
06:55:31.249 --> 06:55:34.249
do the JavaScript VM. And then
we'll learn how to use the

7015
06:55:34.249 --> 06:55:38.249
injected web three, or a meta
mask or some connection to an

7016
06:55:38.249 --> 06:55:41.249
actual test net. So in order to
deploy this to a JavaScript

7017
06:55:41.249 --> 06:55:44.249
virtual invite I'm in or kind of
a fake blockchain, we're gonna

7018
06:55:44.249 --> 06:55:48.249
need to get a fake blockchain.
Now in the future, we're going

7019
06:55:48.249 --> 06:55:51.249
to be using the Hardhead runtime
environment as our JavaScript

7020
06:55:51.249 --> 06:55:55.249
virtual machine or aka our fake
blockchain. But for this

7021
06:55:55.249 --> 06:55:59.249
section, I want us to use a tool
called ganache. There's a link

7022
06:55:59.249 --> 06:56:02.249
to this in the GitHub
repository. Ganache is similar

7023
06:56:02.249 --> 06:56:06.249
to a virtual machine in remix.
It's a fake blockchain that we

7024
06:56:06.249 --> 06:56:10.249
can run locally to actually
test, deploy and run code. It's

7025
06:56:10.249 --> 06:56:14.249
also a nice way to see things
that are going on in a

7026
06:56:14.249 --> 06:56:17.249
blockchain. Let's go ahead and
spin up the ganache application

7027
06:56:17.249 --> 06:56:20.249
after you install it, the
ganache application will look a

7028
06:56:20.249 --> 06:56:24.249
little something like this. And
to spin up a fake blockchain

7029
06:56:24.249 --> 06:56:28.249
really quickly, you can just go
ahead and click Quickstart. This

7030
06:56:28.249 --> 06:56:31.249
will spin up a fake blockchain
that's running locally on your

7031
06:56:31.249 --> 06:56:35.249
computer right here, which is
fantastic. It comes with a whole

7032
06:56:35.249 --> 06:56:39.249
bunch of fake accounts exactly
like how remix comes with a ton

7033
06:56:39.249 --> 06:56:42.249
of fake accounts with 100 ether
each ganache comes with a bunch

7034
06:56:42.249 --> 06:56:46.249
of fake accounts with 100 ether
each. They also come with the

7035
06:56:46.249 --> 06:56:50.249
private keys that we can use in
our applications to actually

7036
06:56:50.249 --> 06:56:54.249
take control of these fake
accounts. Remember, don't use

7037
06:56:54.249 --> 06:56:56.249
these private keys on a public
blockchain. They're for

7038
06:56:56.249 --> 06:56:59.249
development purposes only
because a lot of people know

7039
06:56:59.249 --> 06:57:02.249
these private keys in our code.
One of the first things that

7040
06:57:02.249 --> 06:57:05.250
we're going to need to do is
actually connect to our

7041
06:57:05.250 --> 06:57:09.250
blockchain remix does this a
little bit behind the scenes, if

7042
06:57:09.250 --> 06:57:12.250
we're choosing JavaScript
virtual machine remix chooses

7043
06:57:12.250 --> 06:57:15.250
its own fake blockchain that it
runs. If we choose injected web

7044
06:57:15.250 --> 06:57:19.250
three, as we know, meta mask
pops up, and it connects to our

7045
06:57:19.250 --> 06:57:22.250
meta mask, this connection that
remix does, is actually doing

7046
06:57:22.250 --> 06:57:25.250
something really interesting.
It's not just connecting to our

7047
06:57:25.250 --> 06:57:29.250
meta mask by some magical
powers. It's actually connecting

7048
06:57:29.250 --> 06:57:32.250
to our meta mask, which has a
connection to the blockchain

7049
06:57:32.250 --> 06:57:36.250
behind the scenes. If you open
up your meta mask, and you go

7050
06:57:36.250 --> 06:57:39.250
down to you select the networks
and you select ad networks,

7051
06:57:40.250 --> 06:57:43.250
you'll get popped up into a UI
that looks like this. If we go

7052
06:57:43.250 --> 06:57:47.250
back and hit select networks
over here, we can actually see

7053
06:57:47.250 --> 06:57:50.250
information about these
different networks. One of the

7054
06:57:50.250 --> 06:57:53.250
main things that we can see is
that all these networks have

7055
06:57:53.250 --> 06:57:58.250
something called an RPC URL. RPC
stands for remote procedure

7056
06:57:58.250 --> 06:58:04.250
call. And then URL is uniform
resource locator. This RPC URL

7057
06:58:04.250 --> 06:58:07.250
stands for a connection to a
blockchain node that somebody is

7058
06:58:07.250 --> 06:58:12.250
running this this URL connects
us to make API calls and to

7059
06:58:12.250 --> 06:58:15.250
interact with a blockchain node.
Blockchain nodes run with

7060
06:58:15.250 --> 06:58:19.250
software, and some of them
expose an API call. If you look

7061
06:58:19.250 --> 06:58:23.250
at the NGO Aetherium website,
there actually are instructions

7062
06:58:23.250 --> 06:58:26.250
for you to run your own
blockchain node for a real

7063
06:58:26.250 --> 06:58:30.250
blockchain like Aetherium. Most
of these have flags like dash

7064
06:58:30.250 --> 06:58:36.250
HTTP dot ADR to expose these RPC
endpoints. So if you ever want

7065
06:58:36.250 --> 06:58:39.250
to run your own node, your own
real blockchain node, instead of

7066
06:58:39.250 --> 06:58:42.250
using meta masks or any other
the providers that we're going

7067
06:58:42.250 --> 06:58:44.250
to go through, you can use go
Aetherium, or whatever

7068
06:58:44.250 --> 06:58:47.251
blockchain you're working with
software to run your own notes.

7069
06:58:47.251 --> 06:58:50.251
But it's this RPC URL that
allows us to connect to Rinkeby,

7070
06:58:50.251 --> 06:58:54.251
if on Rinkeby ropsten, if we're
on ropsten main net if we're on

7071
06:58:54.251 --> 06:58:57.251
Main net, etc. And it's going to
be the way that we're going to

7072
06:58:57.251 --> 06:59:01.251
connect to our ganache
blockchain that we're running

7073
06:59:01.251 --> 06:59:04.251
inside of this application. So
if you look at the top of your

7074
06:59:04.251 --> 06:59:08.251
ganache here, there's a section
called the RPC server. And this

7075
06:59:08.251 --> 06:59:11.251
is the endpoint of our ganache
node right now. So what we can

7076
06:59:11.251 --> 06:59:16.251
do is we can copy this and go
back to our VS code, and paste

7077
06:59:16.251 --> 06:59:20.251
it in here to see if we can
connect instead of HTTP. With

7078
06:59:20.251 --> 06:59:22.251
these capitals, we're gonna have
a B lowercase instead of the

7079
06:59:22.251 --> 06:59:25.251
uppercase, because the lowercase
is more correct, and it looks

7080
06:59:25.251 --> 06:59:27.251
nicer. But now we have the
endpoint. Hypothetically, with

7081
06:59:27.251 --> 06:59:31.251
just this, we can start making
calls and API calls to this

7082
06:59:31.251 --> 06:59:35.251
endpoint, go to this JSON RPC
specification. Again, link will

7083
06:59:35.251 --> 06:59:38.251
be in the GitHub repo, we can
actually see different calls we

7084
06:59:38.251 --> 06:59:42.251
can make directly to our node to
get different information. eath

7085
06:59:42.251 --> 06:59:45.251
get blocked by hash eath get
blocked by number. And all of

7086
06:59:45.251 --> 06:59:49.251
these wonderful pieces in here.
Making these API calls directly

7087
06:59:49.251 --> 06:59:52.251
is is a little bit annoying to
do ourselves. If you want to do

7088
06:59:52.251 --> 06:59:56.251
it yourself, you absolutely can
using an API endpoint like Axios

7089
06:59:56.251 --> 06:59:59.251
or fetch. However, we're going
to use a rapper to interact with

7090
06:59:59.251 --> 07:00:02.251
our node and do things like
deploy and interact and other

7091
07:00:02.251 --> 07:00:06.251
such things with our blockchain
node. This is finally where

7092
07:00:06.251 --> 07:00:07.251
ethers comes

7093
07:00:07.251 --> 07:00:13.251
into play. Ethers js is one of
the most popular JavaScript

7094
07:00:13.251 --> 07:00:16.251
based tooling kits, that allows
us to interact with different

7095
07:00:16.251 --> 07:00:20.251
blockchains and has all these
rappers that make all these API

7096
07:00:20.251 --> 07:00:24.251
calls and do all these things
with Aetherium, and polygon and

7097
07:00:24.251 --> 07:00:27.252
avalanche and any EVM compatible
chain. The other incredibly

7098
07:00:27.252 --> 07:00:30.252
popular package that does the
same thing is going to be web

7099
07:00:30.252 --> 07:00:32.252
three.js. And you've probably
heard about this and you'll

7100
07:00:32.252 --> 07:00:34.252
probably see it a little bit
more throughout this course and

7101
07:00:34.252 --> 07:00:36.252
throughout your web three
journey. The reason that we're

7102
07:00:36.252 --> 07:00:40.252
using ethers is that ethers is
the main tool that powers the

7103
07:00:40.252 --> 07:00:43.252
hard hat environment and I
really enjoy it myself. And

7104
07:00:43.252 --> 07:00:46.252
remember, if you ever get lost
with any of this, you can always

7105
07:00:46.252 --> 07:00:49.252
come back to their documentation
to install it. As you can see

7106
07:00:49.252 --> 07:00:52.252
here, you can just run npm
install ethers, we're just going

7107
07:00:52.252 --> 07:00:56.252
to do yarn, add ethers.

7108
07:00:56.252 --> 07:01:01.252
And now you should see in your
package json, we now have ethers

7109
07:01:01.252 --> 07:01:04.252
added in here. Awesome. Now back
in our code, we're going to

7110
07:01:04.252 --> 07:01:07.252
import ethers into our
deployed.js script so that we

7111
07:01:07.252 --> 07:01:09.252
can use all the wonderful tools
that comes with so we'll say

7112
07:01:09.252 --> 07:01:16.252
const ethers equals require
ethers. For those of you doing

7113
07:01:16.252 --> 07:01:18.252
the TypeScript edition of this
course, this will be import

7114
07:01:18.252 --> 07:01:21.252
instead of require now that we
have ethers in here, we can

7115
07:01:21.252 --> 07:01:25.252
create our provider object in
our main function. The reason we

7116
07:01:25.252 --> 07:01:28.252
we pull ethers outside of the
main function is because we do

7117
07:01:28.252 --> 07:01:32.252
want to pull our package into
our script. Before we call main,

7118
07:01:32.252 --> 07:01:35.252
we want to make sure all of this
is done first. So you'll see

7119
07:01:35.252 --> 07:01:38.252
this is kind of the the normal
setup of our scripts. At the

7120
07:01:38.252 --> 07:01:42.252
top, we import any dependencies
or external packages, we'll have

7121
07:01:42.252 --> 07:01:45.252
our main function, and then
we'll call our main function at

7122
07:01:45.252 --> 07:01:49.252
the bottom. const is a keyword
similar to let the const keyword

7123
07:01:49.252 --> 07:01:52.252
makes it so that ethers can't be
changed. So we can't change

7124
07:01:52.252 --> 07:01:56.252
this. Our ethers variable,
anytime we use const require is

7125
07:01:56.252 --> 07:01:59.252
a function for us to import the
ethers package. Now remix does

7126
07:01:59.252 --> 07:02:02.252
all this behind the scenes. But
the way we're going to do it in

7127
07:02:02.252 --> 07:02:08.253
our code here is we're going to
say const provider equals new

7128
07:02:08.253 --> 07:02:15.253
ethers dot providers dot JSON
RPC provider. And then we're

7129
07:02:15.253 --> 07:02:20.253
going to pass this string as our
provider. So we're saying hey,

7130
07:02:20.253 --> 07:02:24.253
we're going to connect to this
URL right here. Awesome. So this

7131
07:02:24.253 --> 07:02:27.253
is the way that our script is
going to connect to our

7132
07:02:27.253 --> 07:02:30.253
blockchain, our local
blockchain. Now let's get an

7133
07:02:30.253 --> 07:02:33.253
actual wallet here. With a
private key and a balance and

7134
07:02:33.253 --> 07:02:37.253
everything, we can see all of
our wallets and private keys in

7135
07:02:37.253 --> 07:02:40.253
our ganache here. So the way to
get this set up is we can say

7136
07:02:40.253 --> 07:02:47.253
const. Wallet equals new ethers
dot wallet. And this wallet

7137
07:02:47.253 --> 07:02:50.253
function takes in a couple of
input parameters, like a private

7138
07:02:50.253 --> 07:02:55.253
key, and a provider, the private
key will go to Kenosha and just

7139
07:02:55.253 --> 07:02:57.253
choose one of these private
keys. And we're going to paste

7140
07:02:57.253 --> 07:03:00.253
this right into our code. And
then we're gonna do comma

7141
07:03:00.253 --> 07:03:04.253
provider and save that. Now
pasting your private key

7142
07:03:04.253 --> 07:03:08.253
directly into your code is a
huge nono. And we're going to

7143
07:03:08.253 --> 07:03:11.253
learn how to avoid this in the
future. It's okay right now,

7144
07:03:11.253 --> 07:03:14.253
since we're just using one of
the ganache private keys, and

7145
07:03:14.253 --> 07:03:17.253
you have no risk of having any
money associated with this

7146
07:03:17.253 --> 07:03:20.253
account. These two lines alone
give us everything that we need

7147
07:03:20.253 --> 07:03:24.253
to interact with smart contract,
they give us our connection to

7148
07:03:24.253 --> 07:03:28.253
the blockchain, and they give us
a wallet with a private key so

7149
07:03:28.253 --> 07:03:30.253
we can sign different
transactions. If you remember

7150
07:03:30.253 --> 07:03:34.253
back to our blockchain basics
section. This is the private key

7151
07:03:34.253 --> 07:03:37.253
that we're using to sign all of
our transactions to encrypt our

7152
07:03:37.253 --> 07:03:40.253
transactions. Now that we have a
provider and a wallet, let's go

7153
07:03:40.253 --> 07:03:44.253
ahead and grab our contract
objects from these two files

7154
07:03:44.253 --> 07:03:47.254
here. In order to deploy our
contract, we're gonna need the

7155
07:03:47.254 --> 07:03:52.254
ABI and we're going to need the
binary compiled code of the

7156
07:03:52.254 --> 07:03:55.254
contract. So we're going to need
to read from these two files to

7157
07:03:55.254 --> 07:03:58.254
read from these two files, we're
going to need to use a package

7158
07:03:58.254 --> 07:04:03.254
called Fs. So back at the top,
we're gonna do const Fs equals

7159
07:04:03.254 --> 07:04:08.254
require Fs extra I autosave, all
the time, you'll see like, I'll

7160
07:04:08.254 --> 07:04:11.254
do something and then my white
dot will go away a lot. It's

7161
07:04:11.254 --> 07:04:14.254
because my fingers have a habit
of pretty much anytime I stop

7162
07:04:14.254 --> 07:04:18.254
typing I save so so please
remember to save early and

7163
07:04:18.254 --> 07:04:22.254
often, this Fs extra should come
directly with your node project.

7164
07:04:22.254 --> 07:04:26.254
But if not, you can always add
it with yarn, add Fs extra, and

7165
07:04:26.254 --> 07:04:31.254
you should see it in our package
dot JSON. Now we can get the ABI

7166
07:04:31.254 --> 07:04:38.254
and the binary, we can say
const, abi equals Fs dot read

7167
07:04:38.254 --> 07:04:42.254
file sync, which means we're
going to synchronously read from

7168
07:04:42.254 --> 07:04:46.254
this file, we could do it
asynchronously. But we want to

7169
07:04:46.254 --> 07:04:48.254
wait for this file to get done.
So we're gonna say read file

7170
07:04:48.254 --> 07:04:52.254
sync. And depending on your VS
code, if you scroll over, you

7171
07:04:52.254 --> 07:04:55.254
might even get some information
about this function popup like

7172
07:04:55.254 --> 07:04:58.254
this, which can be really
helpful, we can see that we need

7173
07:04:58.254 --> 07:05:01.254
the path for the file we want to
read. And then any options as

7174
07:05:01.254 --> 07:05:04.254
well path the file that we want
to read the at the ABI located

7175
07:05:04.254 --> 07:05:11.254
at dot slash simple storage,
underscore soul underscore

7176
07:05:11.254 --> 07:05:18.254
simple storage dot AVI and then
we're going to do a comma of U

7177
07:05:18.254 --> 07:05:22.254
T, F eight is UTF. Eight is the
encoding that we do for this

7178
07:05:22.254 --> 07:05:24.254
file here. Don't worry too much
about what that means for now.

7179
07:05:24.254 --> 07:05:29.255
So we need the ABI. And we also
need the binary, which is in

7180
07:05:29.255 --> 07:05:34.255
this second file. Simple Storage
underscore soul underscore

7181
07:05:34.255 --> 07:05:38.255
simple storage dot bin. So we're
gonna say const binary equals Fs

7182
07:05:38.255 --> 07:05:43.255
dot read file sync. We're gonna
give it the path Hear, which is

7183
07:05:43.255 --> 07:05:51.255
going to be dot slash, simple
storage soul, simple storage dot

7184
07:05:51.255 --> 07:05:54.255
bin, and then the encoding
option, which again is going to

7185
07:05:54.255 --> 07:05:57.255
be, and it should look like
this. Now that we have the

7186
07:05:57.255 --> 07:06:00.255
binary, we have the ABI, we can
create something called a

7187
07:06:00.255 --> 07:06:04.255
contract factory, which is not
to be confused with the factory

7188
07:06:04.255 --> 07:06:07.255
pattern in ethers. A contract
factory is just an object that

7189
07:06:07.255 --> 07:06:11.255
you can use to deploy contracts.
So we're gonna say const,

7190
07:06:11.255 --> 07:06:21.255
contract factory equals new
ethers dot contract, factory.

7191
07:06:21.255 --> 07:06:28.255
And we're going to pass it, the
API binary. And the wallet, we

7192
07:06:28.255 --> 07:06:31.255
pass the ABI so that our code
knows how to interact with the

7193
07:06:31.255 --> 07:06:34.255
contract the binary, obviously,
because this is the main

7194
07:06:34.255 --> 07:06:37.255
compiled code in our wallet so
that we have a private key we

7195
07:06:37.255 --> 07:06:41.255
can use to sign deploying this
contract, then I usually like to

7196
07:06:41.255 --> 07:06:45.255
write a little console dot log,
saying something like deploying

7197
07:06:45.255 --> 07:06:50.255
these wait. And we can actually
deploy this contract with ethers

7198
07:06:50.255 --> 07:06:59.255
by doing const. Contract equals
await, contract factory dot

7199
07:06:59.255 --> 07:07:02.255
deploy. Now, this is the first
time we've seen this await

7200
07:07:02.255 --> 07:07:06.256
keyword and you can only use the
await keyword inside of an async

7201
07:07:06.256 --> 07:07:10.256
function. The reason we want
this await keyword we're telling

7202
07:07:10.256 --> 07:07:16.256
our code to stop here, wait for
contract to deploy. And this

7203
07:07:16.256 --> 07:07:19.256
await keyword means that this
will resolve the promise

7204
07:07:19.256 --> 07:07:22.256
contract in this contract
factory dot deploy with the

7205
07:07:22.256 --> 07:07:26.256
await here returns a contract
object. So now I could do

7206
07:07:26.256 --> 07:07:30.256
something like console dot log
contract. Let's see what happens

7207
07:07:30.256 --> 07:07:37.256
when we run this code node
deploy dot j s, we scroll up, we

7208
07:07:37.256 --> 07:07:42.256
see deploying, please wait. And
then we see this massive object

7209
07:07:42.256 --> 07:07:45.256
that gets printed out. This is
the contract object that we just

7210
07:07:45.256 --> 07:07:50.256
deployed. And in fact, if we go
over to our ganache, we can see

7211
07:07:50.256 --> 07:07:54.256
that the address that we're used
for our wallet has a little bit

7212
07:07:54.256 --> 07:07:57.256
less balance and has a
transaction count of one. If we

7213
07:07:57.256 --> 07:08:00.256
were working with truffle, we'd
be able to see the contracts

7214
07:08:00.256 --> 07:08:02.256
here we're working with hard
hat, so you won't be able to see

7215
07:08:02.256 --> 07:08:05.256
the contracts in here. But if
you go to transactions, we can

7216
07:08:05.256 --> 07:08:09.256
indeed see the transaction that
we just created. This is similar

7217
07:08:09.256 --> 07:08:12.256
to ether scan. But for our local
blockchain, we can see the

7218
07:08:12.256 --> 07:08:15.256
sender address, the creation
address, the value, gas price,

7219
07:08:16.256 --> 07:08:19.256
all this stuff associated with
this contract. You can also see

7220
07:08:19.256 --> 07:08:22.256
the different blocks. Since
we've only made one transaction

7221
07:08:22.256 --> 07:08:25.256
only one block has been mined.
And this is awesome. We have all

7222
07:08:25.256 --> 07:08:30.256
this other stuff associated with
it. Great job. You just deployed

7223
07:08:30.256 --> 07:08:35.256
a contract to your own local
blockchain with ethers. Jas.

7224
07:08:35.256 --> 07:08:41.256
This is fantastic, Awesome work.
Now let me show you what happens

7225
07:08:41.256 --> 07:08:45.256
if we don't use the await
keyword here. We're not telling

7226
07:08:45.256 --> 07:08:48.257
our code to stop. We're saying
hey, deploy this contract and

7227
07:08:48.257 --> 07:08:51.257
then just keep going. So we
never actually checked to see if

7228
07:08:51.257 --> 07:08:53.257
this deploy function finished.
So let's see what happens when

7229
07:08:53.257 --> 07:08:57.257
we run this instead. Instead of
that big contract object, we get

7230
07:08:57.257 --> 07:09:01.257
this promise in its pending
state because our code actually

7231
07:09:01.257 --> 07:09:05.257
finished before our contract
could finish deploying. So we

7232
07:09:05.257 --> 07:09:09.257
see promise pending here
instead, this is why the await

7233
07:09:09.257 --> 07:09:12.257
keyword is so important. We're
saying hey, wait for this to

7234
07:09:12.257 --> 07:09:17.257
finish the await keyword also
resolves a promise. So it'll

7235
07:09:17.257 --> 07:09:21.257
wait for the promise to exit
it's pending state. And then

7236
07:09:21.257 --> 07:09:24.257
it'll return whatever the
pending promise returns. So

7237
07:09:25.257 --> 07:09:29.257
contract factory to deploy
returns a promise that returns a

7238
07:09:29.257 --> 07:09:32.257
contract. In fact, if we go to
the ethers documentation, we

7239
07:09:32.257 --> 07:09:36.257
look up deploy. And here we can
see contract factory methods

7240
07:09:36.257 --> 07:09:40.257
contract factory dot deploy. If
we look at the definition of the

7241
07:09:40.257 --> 07:09:43.257
function, it says contract
factory dot deploy takes a whole

7242
07:09:43.257 --> 07:09:47.257
bunch of arguments and some
overrides this arrow is saying

7243
07:09:47.257 --> 07:09:52.257
this is what it returns, it
returns a promise that resolves

7244
07:09:52.257 --> 07:09:55.257
to a contract. And that's why we
need this await keyword because

7245
07:09:55.257 --> 07:09:59.257
contract factory to deploy by
itself just returns a promise.

7246
07:09:59.257 --> 07:10:03.257
But if we do await contract
factory dot deploy, we're saying

7247
07:10:03.257 --> 07:10:06.257
it returns a promise that
resolves to a contract. And

7248
07:10:06.257 --> 07:10:09.257
we're waiting for it to finish
deploying to resolve to a

7249
07:10:09.257 --> 07:10:12.257
contract object. So that's gonna
be a major difference here.

7250
07:10:12.257 --> 07:10:15.257
Awesome work. So that's gonna be
why this await keyword is so

7251
07:10:15.257 --> 07:10:18.257
important. And again, you can
only do that in asynchronous

7252
07:10:18.257 --> 07:10:21.257
functions. So you need this
async keyword at the top of your

7253
07:10:21.257 --> 07:10:28.258
function names. Awesome work. So
we've deployed a contract to our

7254
07:10:28.258 --> 07:10:31.258
ganache. Shane, this is
fantastic. Let's play with this

7255
07:10:31.258 --> 07:10:34.258
a little bit more. So what else
can we do? Remember how in remix

7256
07:10:34.258 --> 07:10:38.258
and in Metamask, we could add a
whole bunch of stuff. We could

7257
07:10:38.258 --> 07:10:41.258
add a gas limit, we could add
some value when we were doing

7258
07:10:41.258 --> 07:10:44.258
our trends. that we could press
the transact button. We know

7259
07:10:44.258 --> 07:10:47.258
that when we're working with
Metamask, and we want to send

7260
07:10:47.258 --> 07:10:50.258
some money between our accounts,

7261
07:10:50.258 --> 07:10:53.258
we can actually choose our gas
price, our priority fee, all

7262
07:10:53.258 --> 07:10:56.258
this other stuff, we can
actually do all that in ethers

7263
07:10:56.258 --> 07:11:00.258
as well. So if we wanted to
await contract factory to

7264
07:11:00.258 --> 07:11:03.258
deploy, but with a certain gas
price, we can add these

7265
07:11:03.258 --> 07:11:06.258
overrides in this deploy
function here. Another really

7266
07:11:06.258 --> 07:11:09.258
neat trick that your Visual
Studio code might have is if you

7267
07:11:09.258 --> 07:11:13.258
click Command or Control,
depending on your setup, you can

7268
07:11:13.258 --> 07:11:17.258
actually click into a function
and see where it's defined and

7269
07:11:17.258 --> 07:11:20.258
see everything about this
function. So if I command

7270
07:11:20.258 --> 07:11:23.258
clicked, I could see that I'm
now in Node modules ethers

7271
07:11:23.258 --> 07:11:28.258
project contract source of Ts,
all this stuff. And I can see

7272
07:11:28.258 --> 07:11:33.258
exactly the function definition
of this deploy function on the

7273
07:11:33.258 --> 07:11:36.258
contract factory object, which
shows us the same code as what

7274
07:11:36.258 --> 07:11:40.258
we saw in the documentation. We
see we have a deploy function,

7275
07:11:40.258 --> 07:11:44.258
it takes some arguments, and
then it returns this little

7276
07:11:44.258 --> 07:11:47.258
semicolon means it returns a
promise that resolves to a

7277
07:11:47.258 --> 07:11:50.258
contract, which is really nice.
These are in here are actually a

7278
07:11:50.258 --> 07:11:54.258
list of overrides that we can
specify with some brackets. So

7279
07:11:54.258 --> 07:11:57.258
what we can do is we can put
some brackets in our deploy

7280
07:11:57.258 --> 07:12:01.258
function here and specify
certain things like for example,

7281
07:12:01.258 --> 07:12:06.259
we can specify the gas price to
being some number. And now if we

7282
07:12:06.259 --> 07:12:09.259
were to run this, we would
deploy this contract with a gas

7283
07:12:09.259 --> 07:12:12.259
price of this, we could add a
gas limit, we can add a whole

7284
07:12:12.259 --> 07:12:18.259
bunch of different overrides in
our deploy function here. Well,

7285
07:12:18.259 --> 07:12:21.259
what else can we do? Well, we
can wait for a certain number of

7286
07:12:21.259 --> 07:12:25.259
blocks for our contract finish
with so we've deployed the

7287
07:12:25.259 --> 07:12:28.259
contract. But maybe we want to
wait one block to make sure it

7288
07:12:28.259 --> 07:12:33.259
actually gets attached to the
chain. So we can say const.

7289
07:12:33.259 --> 07:12:40.259
Deployment received equals
await, contract dot deploy

7290
07:12:40.259 --> 07:12:43.259
transaction dot Wait, and
specify the number of

7291
07:12:43.259 --> 07:12:46.259
confirmations that we want to
actually wait. So we'll wait one

7292
07:12:46.259 --> 07:12:50.259
block confirmation to make sure
that this happened. And then we

7293
07:12:50.259 --> 07:12:55.259
can do console dot log, this
deployment receipt option. So if

7294
07:12:55.259 --> 07:13:01.259
we run the code now, we can see
all this information about our

7295
07:13:01.259 --> 07:13:04.259
transaction, and we can see
exactly what our transaction

7296
07:13:04.259 --> 07:13:09.259
looks like, we can see there's
two is no because we're creating

7297
07:13:09.259 --> 07:13:13.259
a contract from is going to be
this ganache address that we got

7298
07:13:13.259 --> 07:13:17.259
the private key for, we see the
contract address that we created

7299
07:13:17.259 --> 07:13:21.259
transaction index, we can see
gas use gas use log bloom block

7300
07:13:21.259 --> 07:13:24.259
hash transaction, and we can see
all this information about our

7301
07:13:24.259 --> 07:13:27.259
transaction, something I want
you to take note of is the

7302
07:13:27.259 --> 07:13:31.259
deployment receipt and the
deployment transaction, I want

7303
07:13:31.259 --> 07:13:33.259
you to separate these two
because it's going to make your

7304
07:13:33.259 --> 07:13:36.259
life a lot easier. So we're
going to do quick console dot

7305
07:13:36.259 --> 07:13:43.259
log, here is the deployment
transaction. And then we'll do

7306
07:13:43.259 --> 07:13:50.260
console dot log contract, dot
deploy transaction. And then I'm

7307
07:13:50.260 --> 07:13:54.260
going to copy this whole line by
just typing Command C or Ctrl. C

7308
07:13:54.260 --> 07:13:59.260
right there. And then here is
the deployment. Here is the

7309
07:13:59.260 --> 07:14:04.260
transaction receipt. And then
this deployment is receipt is

7310
07:14:04.260 --> 07:14:07.260
the transaction receipt. So I'm
just going to rename this to

7311
07:14:07.260 --> 07:14:10.260
transaction receipt. To make it
a little bit clearer, which ones

7312
07:14:10.260 --> 07:14:15.260
which, and we'll run this one
more time. You only get a

7313
07:14:15.260 --> 07:14:19.260
transaction receipt, when you
wait for a block confirmation.

7314
07:14:19.260 --> 07:14:21.260
Otherwise, you're gonna get the
contract object, which has the

7315
07:14:21.260 --> 07:14:24.260
deploy transaction with it, this
distinction will be more

7316
07:14:24.260 --> 07:14:27.260
important later on. But I wanted
you to know what the difference

7317
07:14:27.260 --> 07:14:30.260
between the two transaction
receipt is what you get when you

7318
07:14:30.260 --> 07:14:34.260
wait for a block confirmation,
the deployment transaction or

7319
07:14:34.260 --> 07:14:38.260
the transaction response,
transaction response is what you

7320
07:14:38.260 --> 07:14:41.260
get just when you create your
transaction. So transaction

7321
07:14:41.260 --> 07:14:44.260
receipts transactional response,
they're different receipt is

7322
07:14:44.260 --> 07:14:47.260
what you get when you wait for a
transaction to finish. And then

7323
07:14:47.260 --> 07:14:49.260
response is just what you
initially get. Make sense? Okay,

7324
07:14:49.260 --> 07:14:52.260
great. We're gonna go ahead and
delete those. But those lines

7325
07:14:52.260 --> 07:14:58.260
will be in the code associated
with the GitHub. Now you saw

7326
07:14:58.260 --> 07:15:01.260
when we actually printed out
those receipts, we got all this

7327
07:15:01.260 --> 07:15:04.260
stuff in here, because deploying
a contract is actually just

7328
07:15:04.260 --> 07:15:08.260
sending a transaction, as we've
said before, so if we want to

7329
07:15:08.260 --> 07:15:12.260
see what's really going on under
the hood, we can actually create

7330
07:15:12.260 --> 07:15:16.260
a transaction ourselves and
create a contract ourselves just

7331
07:15:16.260 --> 07:15:20.260
by specifying the transaction
information. So how will we do

7332
07:15:20.260 --> 07:15:24.260
that? Let's deploy this contract
again, but only purely using

7333
07:15:24.260 --> 07:15:28.261
transaction data. So we'll do a
console dot log.

7334
07:15:28.261 --> 07:15:34.261
Let's deploy with only
transaction data. And this is

7335
07:15:34.261 --> 07:15:37.261
going to be the way you can
actually deploy or send

7336
07:15:37.261 --> 07:15:39.261
transactions purely with
transaction data you can send

7337
07:15:39.261 --> 07:15:43.261
any transaction this gives you
unlimited flux. ability with the

7338
07:15:43.261 --> 07:15:46.261
transactions you want to send,
what we can do is we can say

7339
07:15:46.261 --> 07:15:51.261
const, or let TX which is going
to stand for our transaction

7340
07:15:51.261 --> 07:15:54.261
equals, and we can just add all
of our transaction information

7341
07:15:54.261 --> 07:15:57.261
in here. So the first thing that
we're going to need is our nuts,

7342
07:15:57.261 --> 07:16:00.261
or the number that we only use
once we go back to our

7343
07:16:01.261 --> 07:16:05.261
transaction count, we're on four
transactions here. So we'll use

7344
07:16:05.261 --> 07:16:07.261
the nonce five, because that's
going to be a nonce that we

7345
07:16:07.261 --> 07:16:11.261
haven't used before. Every time
you send a transaction, it comes

7346
07:16:11.261 --> 07:16:15.261
with one of those nonces. Right,
so the nonce is a bit of a over

7347
07:16:15.261 --> 07:16:18.261
overused term, we saw it back in
our blockchain basics that we

7348
07:16:18.261 --> 07:16:23.261
use the nonce to solve that hard
problem. nonces are also used in

7349
07:16:23.261 --> 07:16:26.261
wallets and in signers, to send
transactions and they use a

7350
07:16:26.261 --> 07:16:30.261
different nones for every
transaction. So nonce, when

7351
07:16:30.261 --> 07:16:33.261
we're talking about wallets
talks about a number associated

7352
07:16:33.261 --> 07:16:36.261
with a unique transaction.
nonce, when we're talking about

7353
07:16:36.261 --> 07:16:40.261
blockchain mining is a value
used to solve that hard problem,

7354
07:16:40.261 --> 07:16:42.261
they both mean the same thing.
They both mean a number only

7355
07:16:42.261 --> 07:16:45.261
used once. But they're different
in these different contexts. So

7356
07:16:45.261 --> 07:16:48.261
we're going to use this number
only use once this unique number

7357
07:16:48.261 --> 07:16:51.261
for a transaction to send this,
so we're going to say nonce is

7358
07:16:51.261 --> 07:16:55.261
going to be five, we're going to
pick a gas price of, of this

7359
07:16:55.261 --> 07:16:59.261
right here, we're just going to
use the gas price of ganache

7360
07:16:59.261 --> 07:17:02.261
like that, we're going to pick a
gas limit of some big number,

7361
07:17:02.261 --> 07:17:08.262
we'll use 1123456, we'll just
use that we're gonna say two is

7362
07:17:08.262 --> 07:17:12.262
going to be no, right, exactly
like what we saw in our receipts

7363
07:17:13.262 --> 07:17:17.262
and responses down here. Since
we're creating a contract value

7364
07:17:17.262 --> 07:17:20.262
is going to be zero. Since we're
creating a contract, we don't

7365
07:17:20.262 --> 07:17:25.262
want to send an ether polygon or
avalanche. And then data is

7366
07:17:25.262 --> 07:17:30.262
going to be that massive binary
object in our binary bit. So in

7367
07:17:30.262 --> 07:17:34.262
the binary section, we're gonna
copy this massive binary piece,

7368
07:17:34.262 --> 07:17:37.262
and we're going to put some
quotes in here, we're gonna do

7369
07:17:37.262 --> 07:17:42.262
0x, and paste that in here. So
this massive, massive data piece

7370
07:17:42.262 --> 07:17:44.262
is the binary that we're
sending. Whenever you send a

7371
07:17:44.262 --> 07:17:47.262
transaction, you have this this
data object that you can fill

7372
07:17:47.262 --> 07:17:51.262
this stuff, we're filling our
data object with the binary with

7373
07:17:51.262 --> 07:17:54.262
the code that tells the theory
that tells our blockchain to

7374
07:17:54.262 --> 07:17:58.262
deploy our smart contract that's
going to look exactly like this.

7375
07:17:58.262 --> 07:18:02.262
And then finally, we want to add
the chain ID.

7376
07:18:02.262 --> 07:18:05.262
As we've seen before with
Metamask, if we go back over to

7377
07:18:05.262 --> 07:18:09.262
our networks, each one of these
EVM chains has a different chain

7378
07:18:09.262 --> 07:18:13.262
ID Etherium. Main net is one
ropsten is three Rinke, B is

7379
07:18:13.262 --> 07:18:18.262
four COVID is 42, etc. And other
EVM chains like avalanche like

7380
07:18:18.262 --> 07:18:22.262
polygon, are going to have their
unique chain IDs as well, or

7381
07:18:22.262 --> 07:18:27.262
ganache, we can see the network
ID appear is 1337 in some

7382
07:18:27.262 --> 07:18:30.262
people, so we can just paste
that in here. Some people have

7383
07:18:30.262 --> 07:18:33.262
run into some issues where the
chain ID and the network ID are

7384
07:18:33.262 --> 07:18:38.262
different. And the chain ID is
actually 31337. So if you have a

7385
07:18:38.262 --> 07:18:43.262
problem with this, try 31337
instead, but it should be 1337.

7386
07:18:43.262 --> 07:18:46.263
Now this is a transaction with
all this information propagated,

7387
07:18:46.263 --> 07:18:50.263
which is awesome. However, this
transaction isn't signed. So

7388
07:18:50.263 --> 07:18:52.263
nobody's sending this
transaction right now this is

7389
07:18:52.263 --> 07:18:55.263
just the transaction details of
what somebody wants to do, we

7390
07:18:55.263 --> 07:18:59.263
actually need to sign this
transaction, and then send it to

7391
07:18:59.263 --> 07:19:09.263
our blockchain. Cons sign, TX
response equals await, wallet

7392
07:19:09.263 --> 07:19:15.263
dot sign transaction, and we can
pass that TX object. And then

7393
07:19:15.263 --> 07:19:20.263
we'll do a console dot log of
the sign TX response in

7394
07:19:20.263 --> 07:19:25.263
JavaScript. Same as solidity. If
you type two backslashes, before

7395
07:19:25.263 --> 07:19:29.263
some code, it won't run that
code. So I'm gonna go ahead and

7396
07:19:29.263 --> 07:19:33.263
comment out the three lines
above. And the way that I'm

7397
07:19:33.263 --> 07:19:35.263
doing it is by highlighting the
sections and hitting Command

7398
07:19:35.263 --> 07:19:39.263
backslash, or you might hit Ctrl
backslash, but this is a

7399
07:19:39.263 --> 07:19:42.263
keyboard shortcut you can use to
quickly comment out entire

7400
07:19:42.263 --> 07:19:45.263
sections. And the reason I'm
doing this is because I want to

7401
07:19:45.263 --> 07:19:49.263
show you what happens when we
just run scientex response

7402
07:19:49.263 --> 07:19:53.263
wallet that signed transaction
back in nosh, we see that we

7403
07:19:53.263 --> 07:19:56.263
have four blocks in here. Let me
ask if we do this sign

7404
07:19:56.263 --> 07:19:59.263
transaction and we get the
signed transaction response,

7405
07:19:59.263 --> 07:20:03.263
will we propagate another block?
Well, let's find out run no

7406
07:20:03.263 --> 07:20:08.263
deploy.js, we get this massive
thing here. But if we go back to

7407
07:20:08.263 --> 07:20:13.263
ganache refresh, we actually
don't see another transaction

7408
07:20:13.263 --> 07:20:17.263
sent. That's because we're only
signing a transaction here,

7409
07:20:17.263 --> 07:20:20.263
we're not actually sending it.
So the signed transaction

7410
07:20:20.263 --> 07:20:25.263
response. This big number here
represents a signed transaction

7411
07:20:25.263 --> 07:20:28.264
but not a cent transaction,
which is different. You can

7412
07:20:28.264 --> 07:20:31.264
actually send one of these
transactions by changing this

7413
07:20:31.264 --> 07:20:35.264
line a little bit. So instead of
scientex response, we'll change

7414
07:20:35.264 --> 07:20:39.264
this to send TX response equals
await wallet dot send

7415
07:20:39.264 --> 07:20:44.264
transaction TX then once We send
the transaction here, we can do

7416
07:20:44.264 --> 07:20:50.264
a wait, send transaction
response, that Wait, one, we're

7417
07:20:50.264 --> 07:20:53.264
gonna wait one block
confirmation to make sure this

7418
07:20:53.264 --> 07:20:58.264
transaction actually goes
through. And we can run node.js.

7419
07:20:58.264 --> 07:21:01.264
And it looks like it's done. But
if we actually scroll up, we

7420
07:21:01.264 --> 07:21:05.264
actually got an error here. So
there's this huge, massive thing

7421
07:21:05.264 --> 07:21:10.264
here. And if we scroll up, we'll
eventually see TX reject error,

7422
07:21:10.264 --> 07:21:13.264
the TX doesn't have the correct
nuts, which just for some

7423
07:21:13.264 --> 07:21:18.264
practice, let's go ahead, type
this into Google and see what we

7424
07:21:18.264 --> 07:21:22.264
get. We actually get a web three
Jas from four years ago, trying

7425
07:21:22.264 --> 07:21:25.264
to call leaf picked, blah, blah,
blah, blah, blah, blah, blah,

7426
07:21:25.264 --> 07:21:29.264
blah. It looks like this is a
meta mask issue that they ran

7427
07:21:29.264 --> 07:21:32.264
into. And they said, you have to
reset your account in meta mask,

7428
07:21:32.264 --> 07:21:35.264
which we could do. But let's
make this a little bit more

7429
07:21:35.264 --> 07:21:40.264
specific. Let's say ethers. JS
looks like we don't get it looks

7430
07:21:40.264 --> 07:21:44.264
like as of right now, from this
recording, we don't get a Stack

7431
07:21:44.264 --> 07:21:46.264
Exchange eath or a Stack
Overflow question for this

7432
07:21:46.264 --> 07:21:49.264
trolley, because this is pretty
straightforward. We don't have

7433
07:21:49.264 --> 07:21:51.264
the correct nonce for our
transaction. But this would be a

7434
07:21:51.264 --> 07:21:55.264
good time to actually make this
a question on Stack Overflow or

7435
07:21:55.264 --> 07:21:58.264
Stack Exchange Aetherium so that
it shows up first. So we

7436
07:21:58.264 --> 07:22:00.264
actually don't get the correct
nuts, we're going to want to

7437
07:22:00.264 --> 07:22:03.264
make this a nonce of four you
can see here account has a nonce

7438
07:22:03.264 --> 07:22:07.265
of four TX has a nonce of five.
So we actually would want this

7439
07:22:07.265 --> 07:22:10.265
to be four. Now an easier way to
always get the correct nonce

7440
07:22:10.265 --> 07:22:14.265
here is going to be actually
just calling the transaction

7441
07:22:14.265 --> 07:22:16.265
count from the wallet. So back
in the ethers documentation,

7442
07:22:16.265 --> 07:22:19.265
there's actually some good
samples here on how to assigning

7443
07:22:19.265 --> 07:22:23.265
a message and then how to
actually send these messages. So

7444
07:22:23.265 --> 07:22:26.265
we can do a weight wallet dot
get transaction count to get the

7445
07:22:26.265 --> 07:22:32.265
nuts. So back in our code, we
could do const nuns equals

7446
07:22:32.265 --> 07:22:37.265
await, oops, copy pasted, await
wallet dot get transaction

7447
07:22:37.265 --> 07:22:40.265
count. And then we can just
place the nonce right here.

7448
07:22:40.265 --> 07:22:44.265
Now, let's try running this
again. And it looks like this

7449
07:22:44.265 --> 07:22:48.265
one did indeed go through. We
can verify on ganache here. We

7450
07:22:48.265 --> 07:22:51.265
do indeed see we're currently on
block five now and we have one

7451
07:22:51.265 --> 07:22:54.265
extra transaction. Now we could
go ahead and just run this

7452
07:22:54.265 --> 07:22:57.265
again. And we'll never have to
worry about actually updating

7453
07:22:57.265 --> 07:23:00.265
this nonce ourselves. Since
we're just calling wallet dot

7454
07:23:00.265 --> 07:23:03.265
get transaction count to keep
updating it current block is six

7455
07:23:03.265 --> 07:23:06.265
and the our additional
transaction has indeed gone

7456
07:23:06.265 --> 07:23:09.265
through awesome. I showed you
how to actually sign the

7457
07:23:09.265 --> 07:23:12.265
transaction. But we didn't sign
the transaction for our central

7458
07:23:12.265 --> 07:23:16.265
injection. Well, why not? If you
command click or control click,

7459
07:23:16.265 --> 07:23:20.265
or you go to the documentation
for ethers, we can see the code

7460
07:23:20.265 --> 07:23:23.265
for send transaction. So first,
it does some check provider

7461
07:23:23.265 --> 07:23:25.265
stuff. There's some stuff to
populate the transaction. But we

7462
07:23:25.265 --> 07:23:29.265
can actually see that before it
sends the transaction even in

7463
07:23:29.265 --> 07:23:34.265
ethers, it signs the transaction
first, and then calls this dot

7464
07:23:34.265 --> 07:23:37.265
provider dot send transaction.
So if you just call send

7465
07:23:37.265 --> 07:23:41.265
transaction with the transaction
details like we did here, it's

7466
07:23:41.265 --> 07:23:44.265
the same as signing it first and
then sending it with the

7467
07:23:44.265 --> 07:23:47.266
provider. Okay, great. So we've
learned how to send a

7468
07:23:47.266 --> 07:23:50.266
transaction using pure
JavaScript and using pure

7469
07:23:50.266 --> 07:23:53.266
ethers. One of the main
takeaways from this is that

7470
07:23:53.266 --> 07:23:56.266
every time we change the
blockchain, every time we change

7471
07:23:56.266 --> 07:24:00.266
state, every time we use gas,
we're sending a transaction that

7472
07:24:00.266 --> 07:24:04.266
looks pretty much exactly like
this, the data is going to be

7473
07:24:04.266 --> 07:24:07.266
the differentiator, the data for
us here was data saying to

7474
07:24:07.266 --> 07:24:11.266
create a new contract, when we
make transactions, like adding

7475
07:24:11.266 --> 07:24:14.266
people or storing the data that
we're going to be passing in our

7476
07:24:14.266 --> 07:24:17.266
transaction is going to be data
associated with calling these

7477
07:24:17.266 --> 07:24:21.266
functions. And when we actually
call functions in ethers, or in

7478
07:24:21.266 --> 07:24:24.266
Hardhead. We're not going to do
this kind of raw const, TX, and

7479
07:24:24.266 --> 07:24:27.266
list out all the stuff like here
and list out the raw data,

7480
07:24:27.266 --> 07:24:30.266
right? Because that's really,
really hard ethers and hard hat

7481
07:24:30.266 --> 07:24:33.266
are going to make this process a
lot easier. So for now, let's go

7482
07:24:33.266 --> 07:24:36.266
ahead, comment out this whole
section, which again, if we copy

7483
07:24:36.266 --> 07:24:40.266
this whole thing, and then hit
Command, slash, or control

7484
07:24:40.266 --> 07:24:42.266
slash, or whatever the shortcut
is on your environment, that'll

7485
07:24:42.266 --> 07:24:45.266
actually comment this out. Let's
go ahead and uncomment this

7486
07:24:45.266 --> 07:24:48.266
section so that we deploy our
contract using kind of the ether

7487
07:24:48.266 --> 07:24:52.266
is much easier to read way than
this weird TX stuff. Oh, cool.

7488
07:24:52.266 --> 07:24:55.266
So we've changed our script back
to deploy our contracts like

7489
07:24:55.266 --> 07:25:00.266
this. Now that we've actually
deployed our contract, we can

7490
07:25:00.266 --> 07:25:03.266
learn how to interact with our
contract through code as well,

7491
07:25:03.266 --> 07:25:06.266
the same way that we click these
buttons in remix, we're going to

7492
07:25:06.266 --> 07:25:10.266
code it out for ourselves here.
So if we look at symbol storage,

7493
07:25:10.266 --> 07:25:14.266
we have a button for add person
for store. And then we have

7494
07:25:14.266 --> 07:25:16.266
these view functions as well.
The easiest one is going to be

7495
07:25:16.266 --> 07:25:19.266
the Retrieve function, which
grabs our favorite number,

7496
07:25:19.266 --> 07:25:23.266
retrieve returns favorite
number. So we can call that in

7497
07:25:23.266 --> 07:25:31.267
ethers by doing const. current
favorite number equals await.

7498
07:25:31.267 --> 07:25:37.267
contract.we retrieve. The
contract object that we have is

7499
07:25:37.267 --> 07:25:40.267
what's returned from our
contract factory as long as

7500
07:25:40.267 --> 07:25:43.267
we've awaited it the contract
object is going to come with all

7501
07:25:43.267 --> 07:25:46.267
the functionality described in
our API. That's why we had to

7502
07:25:46.267 --> 07:25:51.267
pass the API to our contract
factory. If we look inside our

7503
07:25:51.267 --> 07:25:55.267
API piece here, we can see it
has a ton of information on the

7504
07:25:55.267 --> 07:25:58.267
different functions that we can
call and the types that it has

7505
07:25:58.267 --> 07:26:00.267
and the return types and
everything like that. For

7506
07:26:00.267 --> 07:26:05.267
example, if I look up retrieve,
I can see down here, we have

7507
07:26:05.267 --> 07:26:08.267
retrieve, we can see that the
name of this function is going

7508
07:26:08.267 --> 07:26:13.267
to be retrieved. And the outputs
are going to be a un 256, of

7509
07:26:13.267 --> 07:26:16.267
type Nuun 256. Now, this is a
little bit difficult to read

7510
07:26:16.267 --> 07:26:19.267
because it's not formatted.
Since we call this dot API, it's

7511
07:26:19.267 --> 07:26:22.267
going to be a little bit hard to
read. But we could change it the

7512
07:26:22.267 --> 07:26:27.267
dot JSON. And then you'll see
it's highlighted a little bit, I

7513
07:26:27.267 --> 07:26:32.267
can even do format document with
prettier. And you'll see it

7514
07:26:32.267 --> 07:26:35.267
actually formats to be a lot
easier to read now and go back

7515
07:26:35.267 --> 07:26:40.267
to retrieve. And we can see,
this block of code here defines

7516
07:26:40.267 --> 07:26:43.267
what the Retrieve function can
and can't do. I'm going to

7517
07:26:43.267 --> 07:26:46.267
change it back to abi. And it
looks like my formatting has

7518
07:26:46.267 --> 07:26:49.267
stayed, which is great. This is
much easier to read than it was

7519
07:26:49.267 --> 07:26:52.267
before. As I said, the ABI or
the application binary interface

7520
07:26:52.267 --> 07:26:55.267
is incredibly important for
working with our contracts. If

7521
07:26:55.267 --> 07:26:58.267
we give our code just this huge
bytecode thing, it's gonna be

7522
07:26:58.267 --> 07:27:03.267
really hard for any processor to
decompile this or understand

7523
07:27:03.267 --> 07:27:05.267
what exactly what the functions
are that are going on here.

7524
07:27:05.267 --> 07:27:09.268
There are decompiler options out
there, like ether VM, that IO

7525
07:27:09.268 --> 07:27:13.268
slash decompile. That can
decompile some bytecode into the

7526
07:27:13.268 --> 07:27:17.268
solidity. But it can be really
tricky to get it exactly right.

7527
07:27:17.268 --> 07:27:20.268
So it's much easier just to have
the ABI to say, hey, this lump

7528
07:27:20.268 --> 07:27:25.268
of code, this lump of numbers
and garbled nonsense is this.

7529
07:27:25.268 --> 07:27:27.268
When we deploy this bytecode to
the blockchain, and we call

7530
07:27:28.268 --> 07:27:30.268
functions on it, the code will
automatically allow those

7531
07:27:30.268 --> 07:27:33.268
functions to get called if they
do exist. But in order for our

7532
07:27:33.268 --> 07:27:36.268
code to know that they exist,
it's much easier just to give it

7533
07:27:36.268 --> 07:27:39.268
the API. So we can get our
current favorite number like

7534
07:27:39.268 --> 07:27:44.268
this. Let's go ahead and console
dot log, the current favorite

7535
07:27:44.268 --> 07:27:48.268
number. Now that we've edited
this code, we're going to let me

7536
07:27:48.268 --> 07:27:51.268
zoom out a little bit. Now that
we've edited this code, we're

7537
07:27:51.268 --> 07:27:54.268
going to connect organ nosh
instance, we're going to connect

7538
07:27:54.268 --> 07:27:58.268
a wallet with a private key that
we got from the top of our

7539
07:27:58.268 --> 07:28:01.268
ganache here, we're gonna grab
the ABI and the binary of our

7540
07:28:01.268 --> 07:28:05.268
contracts, and connect them to a
new contract factory object,

7541
07:28:05.268 --> 07:28:09.268
which is connected to that
wallet. So that wallet will be

7542
07:28:09.268 --> 07:28:12.268
the one to actually deploy the
contract, we'll deploy the

7543
07:28:12.268 --> 07:28:15.268
contract with const contract
equals await contract factory

7544
07:28:15.268 --> 07:28:18.268
dot deploy, we will wait one
block for that transaction to

7545
07:28:18.268 --> 07:28:20.268
finish. And in fact, we're not
going to use transaction

7546
07:28:20.268 --> 07:28:24.268
receipt. So for now, we're just
going to delete that part. We're

7547
07:28:24.268 --> 07:28:27.268
not going to do any of this
here. So I'm going to delete it

7548
07:28:27.268 --> 07:28:29.268
for now. However, I'll leave
this section commented out in

7549
07:28:29.268 --> 07:28:33.268
the GitHub repo. And then we're
going to call contract retrieve

7550
07:28:33.268 --> 07:28:36.268
which should return our current
favorite number. Since this is a

7551
07:28:36.268 --> 07:28:40.268
view function, this contract
call won't cost us any gas. If

7552
07:28:40.268 --> 07:28:44.268
we look at simple storage, that
soul we can see retrieve is a

7553
07:28:44.268 --> 07:28:48.269
view function. And remember view
and pure functions, if called

7554
07:28:48.269 --> 07:28:52.269
outside of a contract function
call don't cost any gas, we're

7555
07:28:52.269 --> 07:28:55.269
just reading up the blockchain,
we're not changing any variables

7556
07:28:55.269 --> 07:28:58.269
on chain, we're not changing the
state of the blockchain. So this

7557
07:28:58.269 --> 07:29:00.269
won't cost any gas. So let's go

7558
07:29:00.269 --> 07:29:06.269
ahead and run this. Perfect, we
get deploying, please wait. And

7559
07:29:06.269 --> 07:29:09.269
then we get this big number
response. So what's this big

7560
07:29:09.269 --> 07:29:13.269
number response here? Big number
is a library that comes with the

7561
07:29:13.269 --> 07:29:16.269
ethers application that helps us
work with numbers. If you

7562
07:29:16.269 --> 07:29:20.269
actually scroll down, they even
have a section saying why can I

7563
07:29:20.269 --> 07:29:23.269
just use numbers, you'd expect
current favorite number to just

7564
07:29:23.269 --> 07:29:25.269
be zero, but it returns this
weird hex thing that says his

7565
07:29:25.269 --> 07:29:29.269
big number true this weird, big
number thing. So solidity can't

7566
07:29:29.269 --> 07:29:32.269
use decimal places, and
JavaScript has a hard time with

7567
07:29:32.269 --> 07:29:35.269
decimal places. And this is kind
of the more specific rationale

7568
07:29:35.269 --> 07:29:38.269
for why not to use numbers, what
you'll see a lot of the time

7569
07:29:38.269 --> 07:29:42.269
instead of numbers is you'll see
strings like zero, you'll see

7570
07:29:42.269 --> 07:29:47.269
JavaScript use strings like
this, or big numbers. Now, if I

7571
07:29:47.269 --> 07:29:51.269
were to try to pass a number
like this in JavaScript, this

7572
07:29:51.269 --> 07:29:53.269
number would be too big for
JavaScript to understand. So we

7573
07:29:53.269 --> 07:29:56.269
want to use big numbers or
strings when working with

7574
07:29:56.269 --> 07:29:59.269
ethers. Now we can make this
more readable by adding.to

7575
07:29:59.269 --> 07:30:03.269
string at the end and printing
out the string version of this

7576
07:30:03.269 --> 07:30:08.269
big number. Now, if I rerun this
code, we can see we get zero,

7577
07:30:08.269 --> 07:30:11.269
which makes sense again, because
our favorite number gets

7578
07:30:11.269 --> 07:30:16.269
initialized to the zero value,
if not specified, and we haven't

7579
07:30:16.269 --> 07:30:19.269
called store yet. So awesome. So
that is, that's working

7580
07:30:19.269 --> 07:30:22.269
perfectly. So this is what our
current favorite number is.

7581
07:30:22.269 --> 07:30:25.269
Let's make this console dot log
a little bit more syntactical.

7582
07:30:25.269 --> 07:30:28.270
We're going to use something
called string interpolation. So

7583
07:30:28.270 --> 07:30:32.270
we can interpolate our string
here with variables. Typically

7584
07:30:32.270 --> 07:30:34.270
in JavaScript when working with
strings, use double quotes.

7585
07:30:34.270 --> 07:30:39.270
However, if you want to mix
variables with actual strings,

7586
07:30:39.270 --> 07:30:42.270
you can use backticks instead.
So we're going to use some that

7587
07:30:42.270 --> 07:30:47.270
backticks here, and we're gonna
say current favorite number to

7588
07:30:47.270 --> 07:30:50.270
call in here. And to tell
JavaScript that this is a

7589
07:30:50.270 --> 07:30:54.270
variable that we want to read,
we put a little dollar sign and

7590
07:30:54.270 --> 07:30:59.270
a bracket around it, like this.
Now, if we run this code again,

7591
07:30:59.270 --> 07:31:02.270
it's saying deploying, please
wait, and we get current

7592
07:31:02.270 --> 07:31:05.270
favorite number is zero, because
JavaScript goes, Okay, this is a

7593
07:31:05.270 --> 07:31:09.270
string, ah, dollar sign, curly
brace looks like this is going

7594
07:31:09.270 --> 07:31:12.270
to be some variable or some
JavaScript that you want me to

7595
07:31:12.270 --> 07:31:16.270
interpret and close it off, and
then backtick. Cool. So our

7596
07:31:16.270 --> 07:31:18.270
current favorite number is going
to be zero. Great. So let's

7597
07:31:18.270 --> 07:31:21.270
update on the contract the
number by calling the store

7598
07:31:21.270 --> 07:31:27.270
function. So we'll say const,
transaction response equals

7599
07:31:27.270 --> 07:31:32.270
await, contract dot store, and
we'll add seven. Now since seven

7600
07:31:32.270 --> 07:31:35.270
is a small number, you can just
pass it like seven. But passing

7601
07:31:35.270 --> 07:31:39.270
it like seven in a string also
works. Again, this is because if

7602
07:31:39.270 --> 07:31:43.270
we want to pass some crazy
massive number, JavaScript would

7603
07:31:43.270 --> 07:31:47.270
get confused. So it's usually
best practice to pass variables

7604
07:31:47.270 --> 07:31:49.270
to contract functions as
strings, even though that might

7605
07:31:49.270 --> 07:31:53.270
be a little bit confusing ethers
is smart enough to know that

7606
07:31:53.270 --> 07:31:56.270
this seventh string is actually
seven the number then we can do

7607
07:31:56.270 --> 07:32:03.270
const. Transaction received
equals await transaction

7608
07:32:03.270 --> 07:32:09.271
response that Wait, one. So
we'll wait one block here. This

7609
07:32:09.271 --> 07:32:13.271
is similar to us doing contract
dot deploy transaction dot Wait,

7610
07:32:13.271 --> 07:32:16.271
the syntax here is a little bit
different than what we saw up

7611
07:32:16.271 --> 07:32:18.271
here. Because this is using a
contract factory. And this is

7612
07:32:18.271 --> 07:32:22.271
calling a function on a
contract. So when we call the

7613
07:32:22.271 --> 07:32:25.271
function on the contract, we get
a transaction response. When we

7614
07:32:25.271 --> 07:32:27.271
wait for the transaction
response to finish, we get the

7615
07:32:27.271 --> 07:32:32.271
transaction receipt. Now I can
do const, updated, favorite

7616
07:32:32.271 --> 07:32:39.271
number two equals await on track
dot retrieve. And then console

7617
07:32:39.271 --> 07:32:46.271
dot log updated. favorite number
is, and we'll do a little string

7618
07:32:46.271 --> 07:32:51.271
interpolation, updated, favorite
number like that? Now let's go

7619
07:32:51.271 --> 07:32:54.271
ahead and run this. So in this
process, what are we doing,

7620
07:32:54.271 --> 07:32:57.271
we're deploying the contract,
we're getting the initial value,

7621
07:32:57.271 --> 07:33:01.271
we're going to update our
contract by calling store which

7622
07:33:01.271 --> 07:33:05.271
is going to cost gas. So this is
a transaction, we're going to

7623
07:33:05.271 --> 07:33:07.271
get the transaction response,
then we're gonna get the

7624
07:33:07.271 --> 07:33:10.271
transaction receipt, we're not
going to do anything with the

7625
07:33:10.271 --> 07:33:13.271
transaction receipt, I want to
ingrain in you all that these

7626
07:33:13.271 --> 07:33:16.271
two are different transaction
response and transaction

7627
07:33:16.271 --> 07:33:19.271
receipt, and you'll see why in
the future. And then we'll get

7628
07:33:19.271 --> 07:33:21.271
the updated favorite number, and
then we're just going to print

7629
07:33:21.271 --> 07:33:26.271
it out. So let's do this. Boom,
and perfect. Deploying, please

7630
07:33:26.271 --> 07:33:30.271
wait, current favorite number is
zero, updated favorite number is

7631
07:33:30.271 --> 07:33:33.271
seven. And if we go to our
ganache instance, we go to

7632
07:33:33.271 --> 07:33:38.271
transactions, we can see, we now
have a contract call at the top,

7633
07:33:38.271 --> 07:33:42.271
we have the sender, the contract
address, the gas price, all this

7634
07:33:42.271 --> 07:33:46.271
stuff, and we see our
transaction data right here. So

7635
07:33:46.271 --> 07:33:49.272
this transaction data is what
gets sent in that data slot of

7636
07:33:49.272 --> 07:33:53.272
our transaction object. Ethers
is just doing that on the back

7637
07:33:53.272 --> 07:33:56.272
end for us so that we don't have
to make that big transaction

7638
07:33:56.272 --> 07:33:59.272
object there. All right,
awesome. You've successfully

7639
07:33:59.272 --> 07:34:04.272
deployed a contract to your own
local ganache instance, or your

7640
07:34:04.272 --> 07:34:09.272
own JavaScript virtual machine.
This is great.

7641
07:34:09.272 --> 07:34:12.272
Now let's clean this up a little
bit. Because if we look up here,

7642
07:34:12.272 --> 07:34:17.272
we have both our connection to
the blockchain and our private

7643
07:34:17.272 --> 07:34:21.272
key stored directly in our code,
we were to push this code up to

7644
07:34:21.272 --> 07:34:24.272
a GitHub or some other code
repository, if you will, will be

7645
07:34:24.272 --> 07:34:28.272
able to see our code. If we look
into ploy dot j s of my code,

7646
07:34:28.272 --> 07:34:31.272
ah, there's something else in
here, we don't actually see the

7647
07:34:31.272 --> 07:34:34.272
private key or the RPC URL in
here. So what's going on?

7648
07:34:34.272 --> 07:34:37.272
Remember, if you give out your
private key, whoever has your

7649
07:34:37.272 --> 07:34:40.272
private key owns your funds. So
even though this is a fake,

7650
07:34:40.272 --> 07:34:43.272
private key that doesn't have
any real money in it, we still

7651
07:34:43.272 --> 07:34:46.272
don't want to have to hard code
our private keys into our code,

7652
07:34:46.272 --> 07:34:49.272
just in case we accidentally
share code with somebody. So

7653
07:34:49.272 --> 07:34:52.272
what can we do? Well, one of the
most popular methods is actually

7654
07:34:52.272 --> 07:34:55.272
creating something called a dot
EMV file or an environment

7655
07:34:55.272 --> 07:34:58.272
variable. And if you're familiar
with environment variables, you

7656
07:34:58.272 --> 07:35:01.272
can actually set them right in
your terminal, but we're gonna

7657
07:35:01.272 --> 07:35:04.272
set them in our dot env. So what
you want to do is you're gonna

7658
07:35:04.272 --> 07:35:07.272
want to create a dot env file.
And this is going to be a file

7659
07:35:07.272 --> 07:35:10.272
where you store its sensitive
information. And this is going

7660
07:35:10.272 --> 07:35:13.272
to be a file, we're never going
to share this with anybody. This

7661
07:35:13.272 --> 07:35:16.272
dot env file will stick
variables of our choosing into

7662
07:35:16.272 --> 07:35:20.272
the environment of our code. So
for example, if I pull up my

7663
07:35:20.272 --> 07:35:25.272
terminal here, and I do echo
cat, this is going to reflect

7664
07:35:25.272 --> 07:35:29.273
what the cat environment
variable is for us. Right now

7665
07:35:29.273 --> 07:35:32.273
there is no cat environment
variable. However, if I do

7666
07:35:32.273 --> 07:35:41.273
export, cat equals dog, and now
I do echo dollar sign cat, I get

7667
07:35:41.273 --> 07:35:45.273
dog output. This is what an
environment variable is, it's a

7668
07:35:45.273 --> 07:35:48.273
variable in our terminal or in
our scripting environment, since

7669
07:35:48.273 --> 07:35:52.273
I don't want to have to type
export, private key equals blah,

7670
07:35:52.273 --> 07:35:55.273
blah, blah, every time, what
we're going to do instead is

7671
07:35:55.273 --> 07:35:58.273
we're going to stick them into
this dot env file. So when this

7672
07:35:58.273 --> 07:36:04.273
dot env, we can put private key
equals. And we can grab this

7673
07:36:04.273 --> 07:36:08.273
private key from our script, and
paste it in like this. And a

7674
07:36:08.273 --> 07:36:11.273
note, some tools look for the
0x, at the beginning of the

7675
07:36:11.273 --> 07:36:14.273
private key ethers, and hard hat
is smart enough that either one

7676
07:36:14.273 --> 07:36:18.273
works, but if you run into some
issues, just know that sometimes

7677
07:36:18.273 --> 07:36:21.273
you might have to put your 0x at
the front of this. Great. So now

7678
07:36:21.273 --> 07:36:23.273
we have a private key in an
environment variable. What do we

7679
07:36:23.273 --> 07:36:28.273
do now? Well, in our deploy.js,
we want to grab this environment

7680
07:36:28.273 --> 07:36:32.273
variable and stick it into our
script here, so that our script

7681
07:36:32.273 --> 07:36:34.273
can then stick it into our
environment. So we're going to

7682
07:36:34.273 --> 07:36:38.273
add a tool called dot env. To
make this easier, so we're gonna

7683
07:36:38.273 --> 07:36:44.273
do yarn, add dot env. And if we
look at the dot env package, can

7684
07:36:44.273 --> 07:36:47.273
read more about it and read
about how to add it with NPM.

7685
07:36:47.273 --> 07:36:51.273
Again, we're just using yarn
add. But then we can just call

7686
07:36:51.273 --> 07:36:54.273
this require dot E and V dot
config. And this will pull in

7687
07:36:54.273 --> 07:36:59.273
all our environment variables.
So we can just do require

7688
07:36:59.273 --> 07:37:04.273
dot EMV config, we should see
this on our package that JSON,

7689
07:37:04.273 --> 07:37:07.274
we do. Excellent. Now that we
pulled it in, we actually get

7690
07:37:07.274 --> 07:37:11.274
access to our private key
environment variable, you can

7691
07:37:11.274 --> 07:37:14.274
access environment variables in
JavaScript, are using process

7692
07:37:14.274 --> 07:37:17.274
dot EMV. So instead of putting
our private key here, we're

7693
07:37:17.274 --> 07:37:21.274
gonna delete that whole thing
and substitute it with process

7694
07:37:21.274 --> 07:37:26.274
dot EMV, that private key, and
we'll save and it'll reformat

7695
07:37:26.274 --> 07:37:29.274
for us to make sure this is
actually working, we can just

7696
07:37:29.274 --> 07:37:34.274
hit up after we save up, up up
up up a bunch and go back to no

7697
07:37:34.274 --> 07:37:38.274
deploy to Jas. And we see we get
the exact same setup. And if we

7698
07:37:38.274 --> 07:37:41.274
scroll back, you can see a
transaction has indeed gone

7699
07:37:41.274 --> 07:37:43.274
through. If you want to double
check that this is actually

7700
07:37:43.274 --> 07:37:47.274
printing out your private key,
we could do console dot log,

7701
07:37:47.274 --> 07:37:51.274
press study and via private key
we run, we see that that is

7702
07:37:51.274 --> 07:37:54.274
indeed the private key coming
from our environment variable

7703
07:37:54.274 --> 07:37:59.274
here. Awesome. Now our RPC URL
here is isn't really something

7704
07:37:59.274 --> 07:38:01.274
that we need to secure however,
maybe we're going to use a

7705
07:38:01.274 --> 07:38:05.274
certain API key or maybe a
certain endpoint that only we

7706
07:38:05.274 --> 07:38:07.274
want to have access to. And we
don't want anybody else to be

7707
07:38:07.274 --> 07:38:11.274
using our RPC endpoint. So we're
going to add this to our dot env

7708
07:38:11.274 --> 07:38:16.274
file as well. So in our dot env.
When I copy this here, I'm gonna

7709
07:38:16.274 --> 07:38:22.274
say RPC URL equals, and I paste
that in there, just like that.

7710
07:38:22.274 --> 07:38:25.274
And we're gonna delete here. And
we're gonna do the exact same

7711
07:38:25.274 --> 07:38:30.274
thing, say process dot e NV dot
RPC URL. And now we're going to

7712
07:38:30.274 --> 07:38:33.274
run this again. And I'm going to
take out that console dot log.

7713
07:38:33.274 --> 07:38:37.274
And we should get the exact same
response because all we did was

7714
07:38:37.274 --> 07:38:41.274
swap out our RPC URL with our
environment variable, which is

7715
07:38:41.274 --> 07:38:43.274
going to be exactly what it was
before. So we go ahead and run

7716
07:38:43.274 --> 07:38:46.274
this, and we get the exact same
response. And if we go to

7717
07:38:46.274 --> 07:38:50.275
ganache, we see that we do
indeed get a transaction here,

7718
07:38:50.275 --> 07:38:54.275
which is perfect. Awesome. So
we've learned how to add

7719
07:38:54.275 --> 07:38:58.275
environment variables to our dot
env file. So that so that just

7720
07:38:58.275 --> 07:39:00.275
in case, we want to share our
code, or we push our code up to

7721
07:39:00.275 --> 07:39:03.275
GitHub, which we'll do in later
sections, we don't accidentally

7722
07:39:03.275 --> 07:39:07.275
expose our private keys or our
RPC URLs. Now all the code that

7723
07:39:07.275 --> 07:39:11.275
we have in our project here, if
we push it up to GitHub, or

7724
07:39:11.275 --> 07:39:14.275
share it with somebody else, all
this code will get pushed up,

7725
07:39:14.275 --> 07:39:17.275
including our dot env file.
However, if you look at my code

7726
07:39:17.275 --> 07:39:22.275
samples here for this course, we
don't see a dot env file in

7727
07:39:22.275 --> 07:39:25.275
here. So how is that possible?
Well, what we want to do

7728
07:39:25.275 --> 07:39:30.275
whenever we have a project is
create a dot Git ignore file.

7729
07:39:30.275 --> 07:39:34.275
And in here, we want to put in
v. And we also want to put in

7730
07:39:34.275 --> 07:39:38.275
Node modules. This means that
when working with Git and

7731
07:39:38.275 --> 07:39:40.275
working with version control,
which we're going to do a little

7732
07:39:40.275 --> 07:39:44.275
bit later, we won't push our dot
env file up to GitHub. And we

7733
07:39:44.275 --> 07:39:47.275
also won't push up known
modules. So if we go back to my

7734
07:39:47.275 --> 07:39:52.275
example here, we don't see, we
don't see a dot env file, but we

7735
07:39:52.275 --> 07:39:56.275
do see a dot env dot example,
just to show you what one would

7736
07:39:56.275 --> 07:40:01.275
look like. So it doesn't really
matter that I have them in here.

7737
07:40:01.275 --> 07:40:03.275
Now, if you're really paranoid,
there's something else you can

7738
07:40:03.275 --> 07:40:05.275
actually do when running your
scripts and running your

7739
07:40:05.275 --> 07:40:08.275
commands. Let's say you didn't
want to put your private key

7740
07:40:08.275 --> 07:40:11.275
into a dot env file because you
were nervous that you would

7741
07:40:11.275 --> 07:40:13.275
accidentally push it up or
something. What you can do is

7742
07:40:13.275 --> 07:40:16.275
you can add your private key in
your RPC URL as environment

7743
07:40:16.275 --> 07:40:20.275
variables right in the command
line. So before you run Node

7744
07:40:20.275 --> 07:40:25.275
deploy, that's as well you can
do, you can say RPC URL equals,

7745
07:40:25.275 --> 07:40:32.276
paste your RPC around. And then
you can say private key. equals

7746
07:40:32.276 --> 07:40:37.276
and then paste your private key
and then do node deploy.js.

7747
07:40:37.276 --> 07:40:40.276
Setting these right before we
run our script is the exact same

7748
07:40:40.276 --> 07:40:43.276
as if we had set them into dot
env. Here If we hit run, we see

7749
07:40:43.276 --> 07:40:46.276
the exact same output, which
means that our RPC URL and our

7750
07:40:46.276 --> 07:40:49.276
private key went through
successfully. This way for key

7751
07:40:49.276 --> 07:40:52.276
management is fine. But our
rights doing this, it's going to

7752
07:40:52.276 --> 07:40:55.276
be much better. But it still
makes me a little bit nervous in

7753
07:40:55.276 --> 07:40:57.276
our development environments
with our fake private keys,

7754
07:40:57.276 --> 07:41:01.276
having our code in the dot env
file like this is, is okay,

7755
07:41:01.276 --> 07:41:04.276
right? Because we don't really
care if this key gets hacked,

7756
07:41:04.276 --> 07:41:06.276
like nobody's using it. But when
we move to a more professional

7757
07:41:06.276 --> 07:41:10.276
setup, this can be a little bit
scary. So how can we make this

7758
07:41:10.276 --> 07:41:14.276
even more secure? Well, what we
can do is actually we can

7759
07:41:14.276 --> 07:41:17.276
encrypt our private key and
store our encrypted key locally.

7760
07:41:17.276 --> 07:41:20.276
That way, if for some reason
somebody does get into our

7761
07:41:20.276 --> 07:41:23.276
account, our private key isn't
just sitting around in plain

7762
07:41:23.276 --> 07:41:26.276
text, it's encrypted. And you'll
need to know a password that

7763
07:41:26.276 --> 07:41:29.276
only you know to get into it. So
how do we add that? Well, first,

7764
07:41:29.276 --> 07:41:36.276
we're going to create a new file
called encrypt key.js. And this

7765
07:41:36.276 --> 07:41:39.276
is some code that we're going to
use to actually encrypt a key.

7766
07:41:39.276 --> 07:41:41.276
And we'll store that locally
instead of our private key in

7767
07:41:41.276 --> 07:41:45.276
plain text. This will make us
even more secure so that we

7768
07:41:45.276 --> 07:41:47.276
don't have our private key just
hanging around in plain text

7769
07:41:47.276 --> 07:41:50.276
here. So let's go ahead and
build the script to encrypt our

7770
07:41:50.276 --> 07:41:52.276
private key. So we're going to
use the exact same setup as we

7771
07:41:52.276 --> 07:41:55.276
did for our deploy script. We're
going to do an async function

7772
07:41:55.276 --> 07:41:57.276
main.

7773
07:41:57.276 --> 07:41:59.276
And then down here, I'm just
gonna go ahead and copy from

7774
07:41:59.276 --> 07:42:03.276
deployed J S. We're gonna use
this exact same setup, and paste

7775
07:42:03.276 --> 07:42:07.276
it. Okay, great. We're gonna be
using ethers J, s, and r dot E

7776
07:42:07.276 --> 07:42:10.277
and V again. So we're going to
add these in const ethers equals

7777
07:42:10.277 --> 07:42:20.277
require ethers const, FS equals
require Fs extra. And then

7778
07:42:20.277 --> 07:42:27.277
require dot env. Config.
Alright, so right now, in our

7779
07:42:27.277 --> 07:42:30.277
dot env, we do have this private
key. And again, if you don't

7780
07:42:30.277 --> 07:42:33.277
want to have the private key in
their way you can just do is you

7781
07:42:33.277 --> 07:42:36.277
can do private key equals and
then you know, node, whatever

7782
07:42:36.277 --> 07:42:39.277
script you want to run. So we're
going to set this script up to

7783
07:42:39.277 --> 07:42:43.277
run our encrypt key one time.
And then we can remove our

7784
07:42:43.277 --> 07:42:46.277
private key from anywhere in our
workspace so that it's no longer

7785
07:42:46.277 --> 07:42:48.277
in plain text anywhere. So what
we want to do is we want to say

7786
07:42:48.277 --> 07:42:53.277
const wallet, and we're gonna
create a new wallet, but a

7787
07:42:53.277 --> 07:42:56.277
little bit differently. We're
gonna say equals new ethers dot

7788
07:42:56.277 --> 07:43:03.277
wallet, process dot E and V dot
private key. So we do need our

7789
07:43:03.277 --> 07:43:06.277
private key to stick in here.
But then once we create this

7790
07:43:06.277 --> 07:43:14.277
wallet, we're gonna say const.
Encrypted JSON key equals await

7791
07:43:14.277 --> 07:43:19.277
ethers dot encrypt, this encrypt
function is going to return an

7792
07:43:19.277 --> 07:43:23.277
encrypted JSON key that we can
store locally and that we can

7793
07:43:23.277 --> 07:43:26.277
only decrypt it with the
password. And it takes two

7794
07:43:26.277 --> 07:43:30.277
parameters. It takes a private
key password and a private key.

7795
07:43:30.277 --> 07:43:33.277
So in our dot EMV, just for
right, now we're going to create

7796
07:43:33.277 --> 07:43:38.277
a private key password. And I'm
going to say it's password. But

7797
07:43:38.277 --> 07:43:40.277
obviously, this is a terrible
password. And you should never

7798
07:43:40.277 --> 07:43:43.277
use password as your password.
But for now, we're just going to

7799
07:43:43.277 --> 07:43:46.277
leave it as password since I'm
encrypting this big key anyways.

7800
07:43:46.277 --> 07:43:49.278
So we're going to encrypt it by
passing the password process

7801
07:43:49.278 --> 07:43:53.278
study and v dot private key
password. And we're also going

7802
07:43:53.278 --> 07:43:56.278
to pass the private key, it's
going to be ethers, it's going

7803
07:43:56.278 --> 07:44:00.278
to be wallet dot encrypt. We're
also going to pass it process

7804
07:44:00.278 --> 07:44:04.278
dot EMV dot private key. Now
let's go ahead and run this

7805
07:44:04.278 --> 07:44:08.278
right now. And then we'll
console dot log out this

7806
07:44:08.278 --> 07:44:12.278
encrypted JSON key and see what
happens when we run this. So to

7807
07:44:12.278 --> 07:44:16.278
run this, we're going to do
node, encrypt key.js. And hit

7808
07:44:16.278 --> 07:44:19.278
enter. And we'll see what
happens when we console log it

7809
07:44:19.278 --> 07:44:23.278
out this JSON object here is
what our key looks like,

7810
07:44:23.278 --> 07:44:27.278
encrypted. So it's got the
address this ID version, all

7811
07:44:27.278 --> 07:44:31.278
this other stuff. And all this
other stuff is the encrypted

7812
07:44:31.278 --> 07:44:34.278
version of this key. If somebody
gets into our account and they

7813
07:44:34.278 --> 07:44:38.278
see this, they'll have to know
the password to decrypt this

7814
07:44:38.278 --> 07:44:40.278
private key, they'll need to
know the password to decrypt

7815
07:44:40.278 --> 07:44:44.278
this JSON object back into a
private key. So what we're going

7816
07:44:44.278 --> 07:44:47.278
to do, now that we've encrypted
it, we're going to save it. So

7817
07:44:47.278 --> 07:44:52.278
we'll do Fs dot write, file
sync, we're going to pass it to

7818
07:44:52.278 --> 07:44:59.278
dot slash dot encrypted key dot
JSON, comma encrypted JSON key.

7819
07:44:59.278 --> 07:45:02.278
So we're saving it to a new file
called dot encrypted key dot

7820
07:45:02.278 --> 07:45:06.278
JSON. And we're passing it this
encrypted key that we just made.

7821
07:45:06.278 --> 07:45:09.278
So if we open up our file
explorer, and we run this

7822
07:45:09.278 --> 07:45:12.278
command,

7823
07:45:12.278 --> 07:45:15.278
you'll see we get a new file
called dot encrypted key dot

7824
07:45:15.278 --> 07:45:19.278
JSON. And it's this encrypted
key here, which is awesome. So

7825
07:45:19.278 --> 07:45:22.278
now what we want to do in our
dot Git ignore is add dot

7826
07:45:22.278 --> 07:45:28.279
encrypted key dot JSON, so that
we don't accidentally push this

7827
07:45:28.279 --> 07:45:31.279
up to GitHub. And now we have an
encrypted key and we can go to

7828
07:45:31.279 --> 07:45:35.279
our private key and delete this
from our dot env file. We can

7829
07:45:35.279 --> 07:45:39.279
also delete our private key
password from our WMV file so

7830
07:45:39.279 --> 07:45:41.279
that the password isn't just
hanging around in plain text.

7831
07:45:41.279 --> 07:45:45.279
Now that We have an encrypted
key. Back in our deploy script,

7832
07:45:45.279 --> 07:45:49.279
we can change the way that we
actually get a wallet. So at the

7833
07:45:49.279 --> 07:45:52.279
top, we're getting our wallet
just by passing in the private

7834
07:45:52.279 --> 07:45:54.279
key like this, we're not going
to do that, we're going to use

7835
07:45:54.279 --> 07:45:58.279
our encrypted key that we just
created. So we're going to do is

7836
07:45:58.279 --> 07:46:03.279
we're going to say const
encrypted JSON equals Fs dot

7837
07:46:03.279 --> 07:46:12.279
read file sync. That slash dot
encrypted key dot JSON, comma

7838
07:46:12.279 --> 07:46:16.279
UTF eight, this Fs dot read file
sync is just going to read from

7839
07:46:16.279 --> 07:46:20.279
our encrypted key dot JSON into
this encrypted JSON variable

7840
07:46:20.279 --> 07:46:24.279
here. Next, we're going to
create a wallet from this

7841
07:46:24.279 --> 07:46:30.279
encrypted key. We're gonna say
let wallet equals new ethers dot

7842
07:46:30.279 --> 07:46:38.279
wallet, dot from encrypted JSON
sync. And all these commands

7843
07:46:38.279 --> 07:46:42.279
that we're working with ethers,
we can of course, find them in

7844
07:46:42.279 --> 07:46:45.279
the documentation from encrypted
JSON sync takes the encrypted

7845
07:46:46.279 --> 07:46:49.279
JSON and a password and returns
a Wallet Object. So we're going

7846
07:46:49.279 --> 07:46:53.279
to pass it that encrypted JSON
that we just read. And then

7847
07:46:53.279 --> 07:46:57.279
we're going to pass it password
which we're going to do process

7848
07:46:57.279 --> 07:47:03.279
dot EMP dot private key
password. And then finally, the

7849
07:47:03.279 --> 07:47:06.279
reason I use let here is because
now we have to connect this

7850
07:47:06.279 --> 07:47:09.280
wallet back to our provider. If
you look here, we're not

7851
07:47:09.280 --> 07:47:11.280
connecting our wallet with a
provider. When we make our

7852
07:47:11.280 --> 07:47:14.280
transactions with our contract
factory, we need to make sure

7853
07:47:14.280 --> 07:47:17.280
the wallet knows about the
provider here. So we can just

7854
07:47:17.280 --> 07:47:24.280
say wallet equals await wallet
dot connect provider. Now, if we

7855
07:47:24.280 --> 07:47:28.280
run our deploy dot j s with our
private key password as an

7856
07:47:28.280 --> 07:47:31.280
environment variable, it should
still deploy. So we can do

7857
07:47:31.280 --> 07:47:34.280
private key password equals
password, which yes, we know is

7858
07:47:34.280 --> 07:47:38.280
terrible. But that's what we're
using for now node deploy dot j

7859
07:47:38.280 --> 07:47:41.280
s, we should get the same output
we've been seeing this whole

7860
07:47:41.280 --> 07:47:47.280
time and we do we're able to no
longer have our private key in

7861
07:47:47.280 --> 07:47:49.280
our dot env file not in
plaintext anymore, it's in this

7862
07:47:49.280 --> 07:47:52.280
encrypted key. So that just in
case somebody hacks our

7863
07:47:52.280 --> 07:47:55.280
computer, they still won't be
able to send in new transactions

7864
07:47:55.280 --> 07:47:58.280
unless they know the password.
This is awesome. One more thing

7865
07:47:58.280 --> 07:48:02.280
to know, if you type history, if
somebody got into your computer,

7866
07:48:02.280 --> 07:48:05.280
a hacker could actually see
private key password equals

7867
07:48:05.280 --> 07:48:10.280
password in your bash history.
If you run history, dash c, you

7868
07:48:10.280 --> 07:48:14.280
actually will clear your
history. Now if I type history,

7869
07:48:14.280 --> 07:48:16.280
I can just see that the most
recent command I wrote was

7870
07:48:16.280 --> 07:48:19.280
history, this is really just
some of the bare minimum for

7871
07:48:19.280 --> 07:48:21.280
encryption and keeping your key
safe. And it might seem

7872
07:48:21.280 --> 07:48:24.280
ridiculous that somebody might
be able to hack your computer

7873
07:48:24.280 --> 07:48:26.280
and read your encrypted private
keys and everything. But as your

7874
07:48:26.280 --> 07:48:29.280
projects get bigger and bigger,
it is really important to know

7875
07:48:29.280 --> 07:48:32.280
about private key security and
private key safety and, and for

7876
07:48:32.280 --> 07:48:35.280
this course really just giving
you the bare minimum here and

7877
07:48:35.280 --> 07:48:38.280
showing you how to encrypt keys
and how to be a little bit safer

7878
07:48:38.280 --> 07:48:41.280
here. Now for the rest of this
course, we are going to be just

7879
07:48:41.280 --> 07:48:46.280
using this syntax with our
private key in a dot env file.

7880
07:48:46.280 --> 07:48:48.281
The reason why we're doing like
this for the rest of the course

7881
07:48:48.281 --> 07:48:51.281
is it is a little bit easier,
I'm really hoping Hardhead add

7882
07:48:51.281 --> 07:48:53.281
some additional features to make
private key encryption much

7883
07:48:53.281 --> 07:48:56.281
safer and also easier to use in
the future. And they probably

7884
07:48:56.281 --> 07:48:58.281
will. And the other reason that
we're okay to do this here is

7885
07:48:58.281 --> 07:49:01.281
because you've solemnly sworn
that you're not going to use an

7886
07:49:01.281 --> 07:49:03.281
account that has any real money
in it for the duration of this

7887
07:49:03.281 --> 07:49:06.281
course, you're only going to use
private keys that have tests on

7888
07:49:06.281 --> 07:49:08.281
Aetherium or are fake private
keys like this one that we got

7889
07:49:08.281 --> 07:49:12.281
from ganache. In fact just to
really hone this in in the smart

7890
07:49:12.281 --> 07:49:16.281
contract kit slash full blocked
in solidity course, Jas GitHub

7891
07:49:16.281 --> 07:49:20.281
repo in the discussions tab, you
go to announcements, I've

7892
07:49:20.281 --> 07:49:23.281
created one called the dot end
pledge. Because recently I've

7893
07:49:23.281 --> 07:49:27.281
seen too many people follow a
tutorial that doesn't tell them

7894
07:49:27.281 --> 07:49:30.281
about the security risks of
doing this. And I've made this

7895
07:49:30.281 --> 07:49:33.281
dot EMV pledge, I would love
everyone to jump on and read.

7896
07:49:33.281 --> 07:49:37.281
And if you agree, at the bottom,
leave a comment saying I will be

7897
07:49:37.281 --> 07:49:41.281
safe, I will be safe, make sure
you read and you understand

7898
07:49:41.281 --> 07:49:44.281
what's going on in here. And I'm
not doing this to scare you.

7899
07:49:44.281 --> 07:49:47.281
Because again, at the end of the
day, if you use a Metamask that

7900
07:49:47.281 --> 07:49:50.281
only has tests that funds for
the duration of this course, you

7901
07:49:50.281 --> 07:49:52.281
will never have to be worried
because of your key gets

7902
07:49:52.281 --> 07:49:56.281
compromised. It's just test it.
So who cares? This is if you're

7903
07:49:56.281 --> 07:49:58.281
using a meta mask or you're
working with a meta mask that

7904
07:49:58.281 --> 07:50:02.281
has real funds. So I'm going to
read up the pledge because it is

7905
07:50:02.281 --> 07:50:05.281
really important. You understand
this when you're working with

7906
07:50:05.281 --> 07:50:07.281
real funds. And if you're like,
Hey, I'm not working with real

7907
07:50:07.281 --> 07:50:11.281
funds, I don't care, great move
past this, whatever. But when

7908
07:50:11.281 --> 07:50:14.281
you do work with real funds,
when you do decide, hey, I

7909
07:50:14.281 --> 07:50:17.281
actually want to deploy this to
a real network. Now I need real

7910
07:50:17.281 --> 07:50:21.281
money to do that. Come back to
this pledge. Scroll the bottom

7911
07:50:21.281 --> 07:50:24.281
say I will be safe and make sure
you read and you understand

7912
07:50:24.281 --> 07:50:28.282
this. Okay, so the pledge is, I
solemnly swear that I will never

7913
07:50:28.282 --> 07:50:32.282
place a private key or secret
phrase or pneumonic in a dot env

7914
07:50:32.282 --> 07:50:36.282
file that is associated with any
real funds. Basically, you

7915
07:50:36.282 --> 07:50:39.282
basically never have your
private key or your pneumonic

7916
07:50:39.282 --> 07:50:43.282
phrase, in plain text, anywhere.
You'll all only place private

7917
07:50:43.282 --> 07:50:48.282
keys in a web file that only
have tested e FF link or other

7918
07:50:48.282 --> 07:50:51.282
cryptocurrencies. Because again,
if your private key has only

7919
07:50:51.282 --> 07:50:54.282
test net funds, then that's
great. I don't care, we are

7920
07:50:54.282 --> 07:50:58.282
aware that if we forget a dot
Git ignore, and we push our key

7921
07:50:58.282 --> 07:51:02.282
phrase to GitHub, even for a
split second, or even show our

7922
07:51:02.282 --> 07:51:05.282
key slash phrase on the
internet, wherever it may be for

7923
07:51:05.282 --> 07:51:08.282
a split second, it should be
considered compromised. And you

7924
07:51:08.282 --> 07:51:11.282
should remove all funds
immediately. So even if you

7925
07:51:11.282 --> 07:51:14.282
deploy your private key to a
website, and then immediately

7926
07:51:14.282 --> 07:51:17.282
delete your website and think,
Oh, nobody probably got to it,

7927
07:51:17.282 --> 07:51:20.282
you should consider that private
key compromised, and you should

7928
07:51:20.282 --> 07:51:23.282
remove all your funds. And
again, this is just for real

7929
07:51:23.282 --> 07:51:25.282
funds. If your private key was
only tested, funds gets

7930
07:51:25.282 --> 07:51:28.282
compromised. Well, who cares? I
do that all the time, you've

7931
07:51:28.282 --> 07:51:30.282
been seeing me do that all the
time, because it only has tested

7932
07:51:30.282 --> 07:51:33.282
funds in it. If at the end of
this course, you want to steal

7933
07:51:33.282 --> 07:51:36.282
all of my tests that funds I
mean, have a blast, it would be

7934
07:51:36.282 --> 07:51:39.282
annoying to me at worst. If I'm
unsure if my account has real

7935
07:51:39.282 --> 07:51:43.282
funds in it, I will assume it
has real funds in it. So if you

7936
07:51:43.282 --> 07:51:46.282
don't know if it has real funds,
assume it has real funds, and

7937
07:51:46.282 --> 07:51:48.282
you will not use it for
developing purposes. And then

7938
07:51:48.282 --> 07:51:52.282
finally, I am aware that even if
I hit Add Account on my meta

7939
07:51:52.282 --> 07:51:55.282
mask or other eath wallet, I
will get a new private key, but

7940
07:51:55.282 --> 07:51:59.282
it will share the same secret
phrase slash pneumonic of all

7941
07:51:59.282 --> 07:52:02.282
the other accounts generated in
the meta mask or other eath

7942
07:52:02.282 --> 07:52:06.282
Wallet. So if I'm in my meta
mask here, and I hit Create

7943
07:52:06.282 --> 07:52:09.283
account, I will get a new
private key with the new

7944
07:52:09.283 --> 07:52:13.283
account. However, all of these
accounts that I've created with

7945
07:52:13.283 --> 07:52:16.283
this Create Account button have
the exact same pneumonic phrase

7946
07:52:16.283 --> 07:52:20.283
or secret phrase. If I import an
account with a private key, it's

7947
07:52:20.283 --> 07:52:22.283
going to have a different
pneumonic phrase. But all of the

7948
07:52:22.283 --> 07:52:25.283
ones that I generate inside the
wallet are all going to have the

7949
07:52:25.283 --> 07:52:28.283
same phrase. Okay, great.
Hopefully that'll make sense. I

7950
07:52:28.283 --> 07:52:31.283
have some pledge additions here.
For this course, I will only use

7951
07:52:31.283 --> 07:52:34.283
funds associated with a brand
new never before use meta mask

7952
07:52:34.283 --> 07:52:37.283
or other eath wallet. Again,
this is not to scare you, if you

7953
07:52:37.283 --> 07:52:40.283
just work with a brand new meta
mask, you don't have to worry

7954
07:52:40.283 --> 07:52:42.283
about any of this and just refer
back to this when you start

7955
07:52:42.283 --> 07:52:46.283
looking at real money and real
private keys. I'm aware that my

7956
07:52:46.283 --> 07:52:49.283
account associated with my
private key is the same on test

7957
07:52:49.283 --> 07:52:53.283
nets that it is on Main nets. So
like I was showing you, my

7958
07:52:53.283 --> 07:52:55.283
private key on Rinkeby is going
to be the same as my private key

7959
07:52:55.283 --> 07:52:58.283
I'm on a main net, if I must use
a private key associated with

7960
07:52:58.283 --> 07:53:02.283
real funds in the future, until
I am 100% sure what I am doing,

7961
07:53:02.283 --> 07:53:06.283
I will always either use one of
the encrypted methods that

7962
07:53:06.283 --> 07:53:09.283
Patrick showed you some better
encryption stuff that I didn't

7963
07:53:09.283 --> 07:53:13.283
show or use the command line way
to pass private keys and then

7964
07:53:13.283 --> 07:53:16.283
delete the command line history
right after. If I'm never

7965
07:53:16.283 --> 07:53:18.283
actually deploying anything to
make that myself or work with a

7966
07:53:18.283 --> 07:53:21.283
private key with real funds. I
do not need to be concerned.

7967
07:53:21.283 --> 07:53:24.283
Take a look at this. Read this
internalize it, it should make

7968
07:53:24.283 --> 07:53:27.283
you confident. Now again, I'm
not saying this to scare you.

7969
07:53:27.283 --> 07:53:30.283
I'm saying this to instill
confidence in you that these are

7970
07:53:30.283 --> 07:53:33.283
some of the things that we want
to think about. Okay, great. In

7971
07:53:33.283 --> 07:53:37.283
here, I will be safe.

7972
07:53:37.283 --> 07:53:41.283
Boom, I will be safe. And if you
want to copy paste this on

7973
07:53:41.283 --> 07:53:44.283
Twitter, put this in a huge
tweet thread. Go for it. The

7974
07:53:44.283 --> 07:53:48.284
more people who know about this,
the more people who understand

7975
07:53:48.284 --> 07:53:51.284
the security risks of their WMV
files and their private keys,

7976
07:53:51.284 --> 07:53:54.284
the better. So thank you for
listening to this. I know I

7977
07:53:54.284 --> 07:53:57.284
definitely belabor the point,
but it is really important.

7978
07:53:57.284 --> 07:54:02.284
Let's continue with the course.
Alright, so we're just about

7979
07:54:02.284 --> 07:54:05.284
done here. However, there's one
or two more things we want to do

7980
07:54:05.284 --> 07:54:07.284
just to clean this all up right
now when we're auto saving

7981
07:54:07.284 --> 07:54:11.284
reason, the VS code plugin for
us to auto format. However, in

7982
07:54:11.284 --> 07:54:14.284
the future, if anybody else
comes across our repository,

7983
07:54:14.284 --> 07:54:18.284
they might not have the Vyas
code auto format or on. So we

7984
07:54:18.284 --> 07:54:21.284
want to give users a way to
format their code. So it matches

7985
07:54:21.284 --> 07:54:25.284
the styles that we use. So we
have prettier the extension

7986
07:54:25.284 --> 07:54:31.284
installed. We can also add
prettier as a Node js module

7987
07:54:31.284 --> 07:54:35.284
that can tell other users who
don't have a Vyas code exactly

7988
07:54:35.284 --> 07:54:38.284
how to format both their
JavaScript and the solidity.

7989
07:54:38.284 --> 07:54:41.284
There is a prettier plugin
solidity located here, there

7990
07:54:41.284 --> 07:54:44.284
will be a link to it in our
GitHub repo. And if we scroll

7991
07:54:44.284 --> 07:54:47.284
down, we can see how to install
with npm install dash dash save

7992
07:54:47.284 --> 07:54:50.284
Dev, which again, we're just
going to use yarn, so we're

7993
07:54:50.284 --> 07:54:58.284
going to do yarn, add prettier,
and then prettier plugin

7994
07:54:58.284 --> 07:55:03.284
solidity. So we're installing
both prettier, and the solidity

7995
07:55:03.284 --> 07:55:07.284
plugin for prettier. And if we
check our package, JSON, we can

7996
07:55:07.284 --> 07:55:09.284
see that these two have been
added. And what we can do now is

7997
07:55:09.284 --> 07:55:17.284
we can create a new file called
dot prettier, R C. And in this

7998
07:55:17.284 --> 07:55:21.284
file, we can define some little
curly braces. And here, we can

7999
07:55:22.284 --> 07:55:26.284
define what we want for both our
solidity and for a JavaScript,

8000
07:55:26.284 --> 07:55:30.285
so for example, our simple
storage has a tab width of

8001
07:55:30.285 --> 07:55:38.285
412344 spaces. Maybe we want to
change that. We want tab width

8002
07:55:38.285 --> 07:55:41.285
to be two. So we would save it
here and come back to simple

8003
07:55:41.285 --> 07:55:45.285
storage To save it here, and it
would get auto formatted to r

8004
07:55:45.285 --> 07:55:51.285
dot prettier RC. So in our
settings here, we have the

8005
07:55:51.285 --> 07:55:55.285
default editor for solidity, our
hard hat, solidity plugin, and

8006
07:55:55.285 --> 07:55:57.285
the default for meta for
JavaScript being the prettier

8007
07:55:57.285 --> 07:56:01.285
vs. Code one, when we add
prettier RC in here, this file

8008
07:56:01.285 --> 07:56:05.285
will take precedent over the
default configuration, so long

8009
07:56:05.285 --> 07:56:09.285
as we have downloaded the module
in our node modules, which we

8010
07:56:09.285 --> 07:56:14.285
can see it right here. And we
have this dot prettier rc file.

8011
07:56:14.285 --> 07:56:17.285
I'm going to keep the tab with
form. So we're going to update

8012
07:56:17.285 --> 07:56:20.285
it to that one thing that we
currently do have that I do not

8013
07:56:20.285 --> 07:56:27.285
like is these semicolons at the
end, so we're going to do semi

8014
07:56:27.285 --> 07:56:31.285
boss, and I'm going to save
this, come back to deploy it

8015
07:56:31.285 --> 07:56:34.285
save and you'll see the
semicolon automatically goes

8016
07:56:34.285 --> 07:56:38.285
away. I'm also going to add use
tabs false, since I want to use

8017
07:56:38.285 --> 07:56:43.285
spaces or spacing, and then
single quote, false. This way,

8018
07:56:43.285 --> 07:56:46.285
we'll always use a double quote,
instead of a single quote, in

8019
07:56:46.285 --> 07:56:49.285
JavaScript, you can actually use
the single quote or double

8020
07:56:49.285 --> 07:56:52.285
quote, to define strings, but
we're going to make it so that

8021
07:56:52.285 --> 07:56:55.285
no matter what quote you use,
it'll always be double quote.

8022
07:56:55.285 --> 07:56:58.285
And then for all your open
source repos, and for all your

8023
07:56:58.285 --> 07:57:02.285
projects that you make, you want
to make a readme.md readme files

8024
07:57:02.285 --> 07:57:05.285
are generally where people put
instructions or information

8025
07:57:05.285 --> 07:57:08.286
about your project or anything
like that. This way, whenever

8026
07:57:08.286 --> 07:57:11.286
anybody comes across your
project, they'll know what it's

8027
07:57:11.286 --> 07:57:15.286
about your readme dot MDs, our
Markdown syntax again, remember

8028
07:57:15.286 --> 07:57:19.286
how when we made that trial
discussion, we use some

8029
07:57:19.286 --> 07:57:23.286
interesting tips to format our
solidity in our code here. Well,

8030
07:57:23.286 --> 07:57:27.286
that formatting process is the
exact same for.md files for

8031
07:57:27.286 --> 07:57:31.286
markdown. They're both going to
use markdown. In fact, if we hit

8032
07:57:31.286 --> 07:57:35.286
Ctrl, Shift V, you'll enter
preview mode for the markdown

8033
07:57:35.286 --> 07:57:38.286
you'll see pound sign here in my
preview of the hard hat. This

8034
07:57:38.286 --> 07:57:42.286
ethers simple storage FCC is
huge. And it looks like a

8035
07:57:42.286 --> 07:57:47.286
heading at the top. So Command
Shift V to view your.md files or

8036
07:57:47.286 --> 07:57:53.286
or MIP Ctrl, Shift V for Windows
and Linux users.

8037
07:57:53.286 --> 07:57:56.286
The last thing that we're going
to do is we're going to deploy

8038
07:57:56.286 --> 07:58:00.286
this to a test net and interact
with this on a test net, we're

8039
07:58:00.286 --> 07:58:03.286
going to use the Rinkeby test
net. But be sure to use whatever

8040
07:58:03.286 --> 07:58:07.286
recommended test net the GitHub
repository for this coerce

8041
07:58:07.286 --> 07:58:10.286
recommends. Now looking at our
code, you might already have a

8042
07:58:10.286 --> 07:58:15.286
good idea of how to actually
make this slight change. Based

8043
07:58:15.286 --> 07:58:18.286
off of our last section, we know
that all we need is an RPC URL

8044
07:58:18.286 --> 07:58:21.286
and a private key and we can
begin making transactions on a

8045
07:58:21.286 --> 07:58:26.286
blockchain. So we're probably
going to need a rink B RPC URL,

8046
07:58:26.286 --> 07:58:29.286
and a rinky private key. Where
can we find both of those, if

8047
07:58:29.286 --> 07:58:32.286
you want to do everything on
your own, and in full

8048
07:58:32.286 --> 07:58:37.286
decentralized context, we could
run a rink B version of geth, we

8049
07:58:37.286 --> 07:58:39.286
could run it locally, and then
just connect to our guest node,

8050
07:58:39.286 --> 07:58:42.286
we're not going to be showing
how to do this here. However,

8051
07:58:42.286 --> 07:58:45.286
this is 100%, something that you
could do. Instead, we're gonna

8052
07:58:45.286 --> 07:58:49.287
use a third party RPC URL in the
GitHub repo associated with this

8053
07:58:49.287 --> 07:58:55.287
course. Go to Lesson five, we
can scroll down to get a link

8054
07:58:55.287 --> 07:58:59.287
for alchemy. Alchemy has a node
as a service and allows us to

8055
07:58:59.287 --> 07:59:02.287
connect to any blockchain that
they have support for two

8056
07:59:02.287 --> 07:59:06.287
alternates might be quick node,
Morales, or infura. These all

8057
07:59:06.287 --> 07:59:09.287
have node as a service options.
But we're going to work with

8058
07:59:09.287 --> 07:59:11.287
Alchemy, because it's the one
that I liked the best, we can go

8059
07:59:11.287 --> 07:59:14.287
ahead and get started for free
or login or create a new

8060
07:59:14.287 --> 07:59:18.287
account, I'm going to go ahead
and sign up with our hard hat

8061
07:59:18.287 --> 07:59:22.287
Free Code Camp user. And we're
going to select the Ethereum

8062
07:59:22.287 --> 07:59:25.287
blockchain ecosystem. Let's go
ahead and create our first app.

8063
07:59:25.287 --> 07:59:29.287
This is going to be we'll call
it Free Code Camp. RT hat. Our

8064
07:59:29.287 --> 07:59:36.287
app name will be ethers, simple
storage, FCC, and the network is

8065
07:59:36.287 --> 07:59:40.287
where we're going to choose rink
B. But you can see in here, we

8066
07:59:40.287 --> 07:59:43.287
can actually choose more than
just rink B, we can choose

8067
07:59:43.287 --> 07:59:48.287
really Kovan, rink B, ropsten.
And layer twos like arbitrage

8068
07:59:48.287 --> 07:59:51.287
and optimism, we're going to be
using rink B. So let's go ahead

8069
07:59:51.287 --> 07:59:55.287
and create this app. We're going
to choose the free plan and hit

8070
07:59:55.287 --> 07:59:59.287
Continue. We're going to skip
adding payments. If you want to

8071
07:59:59.287 --> 08:00:02.287
tweet your referral code, feel
free to tweet your referral

8072
08:00:02.287 --> 08:00:05.287
code. We're going to skip for
now. And we're going to keep it

8073
08:00:05.287 --> 08:00:08.287
at capped capacity. Since we
don't have a we don't have a key

8074
08:00:08.287 --> 08:00:11.287
in here. And then how did you
hear about us go ahead and give

8075
08:00:11.287 --> 08:00:13.287
me that shout out at Patrick and
Free Code Camp and then hit

8076
08:00:13.287 --> 08:00:16.287
Let's go. Now we get to the
alchemy dashboard, where we can

8077
08:00:16.287 --> 08:00:20.287
see a ton of information about
our node and different ways to

8078
08:00:20.287 --> 08:00:23.287
connect to the nodes and and
stuff like that. This is going

8079
08:00:23.287 --> 08:00:29.288
to be really similar to to this
RPC server endpoint of ganache,

8080
08:00:29.288 --> 08:00:31.288
except it's going to be a
connection, except it's going to

8081
08:00:31.288 --> 08:00:34.288
be a connection to a real test
net or real main net. What we

8082
08:00:34.288 --> 08:00:39.288
can do now is we can select our
our app that we just made. And

8083
08:00:39.288 --> 08:00:43.288
we can hit View key. And we can
see here we get an API key Key,

8084
08:00:43.288 --> 08:00:46.288
we add an HTTP endpoint and we
also get a WebSocket. We're only

8085
08:00:46.288 --> 08:00:50.288
concerned with the HTTP
endpoint. This is going to be

8086
08:00:50.288 --> 08:00:54.288
our RPC URL that connects to
rink B. So what we can do now is

8087
08:00:54.288 --> 08:00:58.288
we can copy this and come over
to our Visual Studio code. And

8088
08:00:58.288 --> 08:01:02.288
in our dot env, we can
substitute these out for their

8089
08:01:02.288 --> 08:01:06.288
actual tests and values. So for
RPC URL, we're going to delete

8090
08:01:06.288 --> 08:01:10.288
this and replace it with our
Rigby RPC row. And now how do we

8091
08:01:10.288 --> 08:01:14.288
get a private key for an actual
test set that has actual rank be

8092
08:01:14.288 --> 08:01:18.288
on it? Well, here is where we
can use our meta masks. So back

8093
08:01:18.288 --> 08:01:21.288
in your browser, go over to your
meta mask, select the three

8094
08:01:21.288 --> 08:01:27.288
dots, go to Account Details,
export private key. And this is

8095
08:01:27.288 --> 08:01:31.288
where you can export your
private key, type in your

8096
08:01:31.288 --> 08:01:34.288
password and boom, you now have
your private key for your

8097
08:01:34.288 --> 08:01:38.288
account on meta mask. Now
remember, please, please, please

8098
08:01:38.288 --> 08:01:43.288
don't continue with a meta mask
that has actual money in it. A

8099
08:01:43.288 --> 08:01:46.288
quick way to check is by going
to your networks tab and seeing

8100
08:01:46.288 --> 08:01:50.288
if on any of the main nets or
the networks with actual money

8101
08:01:50.288 --> 08:01:53.288
in it, you see any money, I
don't have any money in this. So

8102
08:01:53.288 --> 08:01:55.288
I know I'm good to go. If you
have tests that money, that's

8103
08:01:55.288 --> 08:01:58.288
fine, because that's fake money
anyways. And again, most

8104
08:01:58.288 --> 08:02:01.288
browsers have a profile
mechanism where you can create a

8105
08:02:01.288 --> 08:02:05.288
new profile for you to use. But
here now that I've copied my

8106
08:02:05.288 --> 08:02:08.288
private key, we can come back to
our Visual Studio code, paste

8107
08:02:08.288 --> 08:02:12.289
the key in here. And now I have
a private key that has actual

8108
08:02:12.289 --> 08:02:16.289
rink be in it. Awesome. And
remember, if you ever get low,

8109
08:02:16.289 --> 08:02:20.289
just come over to faucets dot
chain dot link slash Rigby get

8110
08:02:20.289 --> 08:02:25.289
some tests eath I'm not a robot
will send the request. Now that

8111
08:02:25.289 --> 08:02:29.289
we have our private key in our
rink being here, we can now try

8112
08:02:29.289 --> 08:02:33.289
to run this on an actual test.
Net, we look at our code, we see

8113
08:02:33.289 --> 08:02:36.289
we're grabbing an RPC URL, which
is going to be from r dot end,

8114
08:02:37.289 --> 08:02:38.289
we're grabbing a private key
which is going to be from our

8115
08:02:38.289 --> 08:02:42.289
daughter Yun V, which points to
our rink D Metamask. And our

8116
08:02:42.289 --> 08:02:47.289
rink B blockchain. So let's just
add a console dot log under our

8117
08:02:47.289 --> 08:02:50.289
contract deployment so that we
know what address it's at. So

8118
08:02:50.289 --> 08:02:55.289
we'll do console dot log, we'll
do some string interpolation,

8119
08:02:55.289 --> 08:02:59.289
contract, address,

8120
08:02:59.289 --> 08:03:04.289
contract dot address. All right,
great. Now let's go ahead and

8121
08:03:04.289 --> 08:03:09.289
run this. So we'll do node
deploy dot J. S deploying Please

8122
08:03:09.289 --> 08:03:12.289
wait, you'll notice this takes a
lot longer. Because we're

8123
08:03:12.289 --> 08:03:15.289
deploying to a test net instead
of our own fake local

8124
08:03:15.289 --> 08:03:18.289
blockchain, test nets and real
networks often will take a

8125
08:03:19.289 --> 08:03:21.289
little bit longer because they
need to wait for the blocks to

8126
08:03:21.289 --> 08:03:25.289
propagate the transaction to go
through, etc. But after a brief

8127
08:03:25.289 --> 08:03:29.289
delay, we will indeed see that
we get a contract address here.

8128
08:03:29.289 --> 08:03:31.289
And we have a current favorite
number. And it's being a little

8129
08:03:31.289 --> 08:03:34.289
slow again, because we're
waiting for our next transaction

8130
08:03:34.289 --> 08:03:37.289
to go through to update the
number and boom, looks like

8131
08:03:37.289 --> 08:03:40.289
we've successfully updated it.
Now something that's important

8132
08:03:40.289 --> 08:03:45.289
to know if ever you run command,
and you want to kill it, you can

8133
08:03:45.289 --> 08:03:49.290
do Ctrl C, and that will stop
it. So any command in the

8134
08:03:49.290 --> 08:03:54.290
terminal that you want to just
abort Ctrl. C is your Get Out of

8135
08:03:54.290 --> 08:03:56.290
Jail Free card and that will
kill it. That'll stop it

8136
08:03:56.290 --> 08:04:00.290
wherever it is. So we'll use
Ctrl C a lot in the future. So

8137
08:04:00.290 --> 08:04:04.290
now let's grab this contract
address and go over to Frank V

8138
08:04:04.290 --> 08:04:12.290
ether scan and paste it in, we
can see our two transactions

8139
08:04:12.290 --> 08:04:15.290
here, we can see we have a
contract creation. And we can

8140
08:04:15.290 --> 08:04:19.290
also see we call a store
function. This is awesome. We've

8141
08:04:19.290 --> 08:04:24.290
successfully deployed a contract
to the wrinkly chain using our

8142
08:04:24.290 --> 08:04:31.290
own code. Congratulations, this
is massive. Now on ether scan,

8143
08:04:31.290 --> 08:04:34.290
we actually can verify and
publish our contract code. What

8144
08:04:34.290 --> 08:04:39.290
is verifying and publishing your
code? Well, right now, our code

8145
08:04:39.290 --> 08:04:42.290
looks like a huge gerbil of
bytecode. And anybody looking at

8146
08:04:42.290 --> 08:04:45.290
our contract directly on chain
will just see this huge jumble

8147
08:04:45.290 --> 08:04:48.290
of bytecode, we can use a
decompiler to try to decompile

8148
08:04:49.290 --> 08:04:51.290
the bytecode into what it looks
like in solidity. But this can

8149
08:04:51.290 --> 08:04:55.290
often take a long time and, and
a lot of processing power. So

8150
08:04:55.290 --> 08:04:58.290
instead, we can just make it
much easier by verifying and

8151
08:04:58.290 --> 08:05:02.290
publishing the code ourself, you
go ahead and hit verify and

8152
08:05:02.290 --> 08:05:06.290
publish. We can scroll down and
we can add compiler information

8153
08:05:06.290 --> 08:05:09.290
to compile this on ether scan
and other block explorers. This

8154
08:05:09.290 --> 08:05:14.290
is a single file compiler
version is zero point 8.7. And

8155
08:05:14.290 --> 08:05:17.290
it's open source is licensed is
MIT. Let's go ahead and

8156
08:05:17.290 --> 08:05:22.290
continue. And we're going to
copy paste our solidity code

8157
08:05:22.290 --> 08:05:26.290
into this large section. Paste.
We don't have any constructor

8158
08:05:26.290 --> 08:05:30.291
arguments so we can skip this
section. We don't have any

8159
08:05:30.291 --> 08:05:33.291
libraries or any other
miscellaneous settings. So we'll

8160
08:05:33.291 --> 08:05:38.291
select I'm not a robot and we'll
hit verify and publish. You

8161
08:05:38.291 --> 08:05:41.291
might have to wait a few
minutes, but awesome. Our

8162
08:05:41.291 --> 08:05:45.291
contract was successfully
compiled. Now if we go back to

8163
08:05:45.291 --> 08:05:50.291
contract source code, we can see
all the code in here. And if we

8164
08:05:50.291 --> 08:05:54.291
grab our contract address, place
it into place into the search

8165
08:05:54.291 --> 08:05:58.291
now, and we go to contract, we
get a little green checkmark.

8166
08:05:58.291 --> 08:06:02.291
And we can see, anybody can now
read our source code.

8167
08:06:02.291 --> 08:06:05.291
Additionally, those buttons that
we saw and remix for reading

8168
08:06:05.291 --> 08:06:08.291
from our contract, and writing
to our contract, are in this

8169
08:06:08.291 --> 08:06:11.291
read contract and this write
contract. If we read the

8170
08:06:11.291 --> 08:06:15.291
contract, and we retrieve the
most recent number, we do indeed

8171
08:06:15.291 --> 08:06:17.291
see that we have seven here
because we recently stored

8172
08:06:17.291 --> 08:06:21.291
seven. Awesome, quick note, this
might already be verified for

8173
08:06:21.291 --> 08:06:24.291
you, since ether scan might get
smart enough to notice that a

8174
08:06:24.291 --> 08:06:27.291
lot of people are deploying the
same bytecode it's already

8175
08:06:27.291 --> 08:06:29.291
verified for you just go ahead
and walk through these steps

8176
08:06:29.291 --> 08:06:32.291
anyways. Now the code
verification we just did was

8177
08:06:32.291 --> 08:06:34.291
pretty simple and
straightforward, because our

8178
08:06:34.291 --> 08:06:37.291
code was pretty simple and
straightforward. Using larger

8179
08:06:37.291 --> 08:06:41.291
and more complex code can make
the verification process a

8180
08:06:41.291 --> 08:06:44.291
little bit harder. Additionally,
we don't always want to have to

8181
08:06:44.291 --> 08:06:47.291
click buttons on ether scan. To
verify our code, we want to do

8182
08:06:47.291 --> 08:06:50.291
it programmatically. So in later
sections, we'll learn how to

8183
08:06:50.291 --> 08:06:55.291
verify all of our code directly
through our code editor, you can

8184
08:06:55.291 --> 08:06:59.291
imagine the process is this easy
for deploying to any EVM chain

8185
08:06:59.291 --> 08:07:02.291
in our alchemy, we could easily
create a new app and change our

8186
08:07:02.291 --> 08:07:05.291
network. And you could see how
easy it would be to just switch

8187
08:07:05.291 --> 08:07:08.291
out this RPC URL and your
private key to work on a

8188
08:07:08.291 --> 08:07:12.292
different chain. This process is
also the same for harmony

8189
08:07:12.292 --> 08:07:16.292
Phantom, avalanche, etc. And if
we wanted to switch chains, we

8190
08:07:16.292 --> 08:07:20.292
would just switch the RPC URL
and switch the private key, and

8191
08:07:20.292 --> 08:07:26.292
everything else would stay
exactly the same. Now, Alchemy

8192
08:07:26.292 --> 08:07:30.292
also shows us and can teach us a
lot about transactions and about

8193
08:07:30.292 --> 08:07:33.292
things that are going on behind
the scenes, including a concept

8194
08:07:33.292 --> 08:07:36.292
called the mempool. To help us
understand a little bit more

8195
08:07:36.292 --> 08:07:39.292
about those transactions that we
just sent, and how to work with

8196
08:07:39.292 --> 08:07:42.292
Alchemy. To see more about our
transactions, we have Albert

8197
08:07:42.292 --> 08:07:45.292
from the alchemy team to give us
a little demonstration.

8198
08:07:45.292 --> 08:07:51.292
Hello, Albert here from alchemy,
I'm that guy in tech on Twitter,

8199
08:07:51.292 --> 08:07:53.292
feel free to follow if you want
to engage and ask any questions

8200
08:07:53.292 --> 08:07:56.292
about this section of the video.
But super excited to join

8201
08:07:56.292 --> 08:07:59.292
Patrick here to explain a little
bit of what goes on behind the

8202
08:07:59.292 --> 08:08:02.292
scenes when you are using
alchemy to submit a transaction.

8203
08:08:02.292 --> 08:08:05.292
And we have a ton of tools to
actually provide a window of

8204
08:08:05.292 --> 08:08:09.292
visibility into what's going on
so that you can actually debug

8205
08:08:09.292 --> 08:08:13.292
in case there are usage errors
on your website, or there are

8206
08:08:13.292 --> 08:08:16.292
pending transactions that are
stuck. Whatever it is, we

8207
08:08:16.292 --> 08:08:20.292
provide that window into the
data that you control. Remember

8208
08:08:20.292 --> 08:08:22.292
that all the transactions that
you submit are recorded on the

8209
08:08:22.292 --> 08:08:24.292
blockchain. They're not
controlled by alchemy, they're

8210
08:08:24.292 --> 08:08:27.292
not controlled by any other
service provider. We are just a

8211
08:08:27.292 --> 08:08:32.292
window, we're just the plumbing
the piping to be useful to you.

8212
08:08:32.292 --> 08:08:35.292
So let me show you exactly what
that means. Right now I have a

8213
08:08:35.292 --> 08:08:37.292
bunch of applications in my
dashboard. You can see here that

8214
08:08:37.292 --> 08:08:40.292
there are different projects
that I've used over time. This

8215
08:08:40.292 --> 08:08:43.292
one is the most recently active,
and it is the one that I have

8216
08:08:43.292 --> 08:08:46.292
currently set up to connect to
my meta mask. So actually use a

8217
08:08:46.292 --> 08:08:49.293
custom RPC provider here. And
let me make my face a little

8218
08:08:49.293 --> 08:08:53.293
smaller. And you can see here,
I've misspelled Rinkeby. But

8219
08:08:53.293 --> 08:08:56.293
this right now, my my network is
actually connected to the

8220
08:08:56.293 --> 08:09:00.293
Rinkeby test network via
alchemy. So this is actually

8221
08:09:00.293 --> 08:09:02.293
this application. So if I click
into here in the dashboard, you

8222
08:09:02.293 --> 08:09:05.293
can see here, a bunch of really
interesting statistics, this is

8223
08:09:05.293 --> 08:09:08.293
the first thing that you'll
probably use. If you're trying

8224
08:09:08.293 --> 08:09:11.293
to understand more about your
application, you'll go here and

8225
08:09:11.293 --> 08:09:15.293
you can see how many compute
units per second your

8226
08:09:15.293 --> 08:09:18.293
application is currently using.
And this is kind of great for

8227
08:09:18.293 --> 08:09:22.293
specifically alchemy usage,
understanding. But then this is

8228
08:09:22.293 --> 08:09:25.293
also really useful to see like,
what's the median response time,

8229
08:09:25.293 --> 08:09:29.293
and so 33 milliseconds is pretty
good. If that starts to

8230
08:09:29.293 --> 08:09:31.293
increase, then you might want to
figure out, you know, what's

8231
08:09:31.293 --> 08:09:35.293
going on here, success rate, it
has been kind of low. So that is

8232
08:09:35.293 --> 08:09:39.293
a clue for me to click on this
tab to view recent invalid

8233
08:09:39.293 --> 08:09:42.293
requests. And that I can
actually see oh, there's a bunch

8234
08:09:42.293 --> 08:09:44.293
of

8235
08:09:44.293 --> 08:09:47.293
failed transactions where the
transaction has already been

8236
08:09:47.293 --> 08:09:51.293
sent or the nonce is too low, or
whatever it is, I can actually

8237
08:09:51.293 --> 08:09:54.293
use this tab to debug. So that
success rate is pretty useful.

8238
08:09:54.293 --> 08:09:58.293
Throughput that's been limited.
So if you are sending too many

8239
08:09:58.293 --> 08:10:00.293
requests or your website is
getting spammed, you might start

8240
08:10:00.293 --> 08:10:05.293
getting some requests blocked.
So that's what's useful to view

8241
08:10:05.293 --> 08:10:09.293
their concurrent requests over
here, success rate in the past

8242
08:10:09.293 --> 08:10:12.293
24 hours versus the past one
hour, the total number of

8243
08:10:12.293 --> 08:10:15.293
requests in the last 24 hours.
And this is different than

8244
08:10:15.293 --> 08:10:18.293
compute units, because each
request can have a different

8245
08:10:18.293 --> 08:10:22.293
level of computing cost. And
computing cost as measured by

8246
08:10:22.293 --> 08:10:26.293
compute units. Total requests is
just the actual number of

8247
08:10:26.293 --> 08:10:29.293
absolute requests. And then of
course, the number of invalid

8248
08:10:29.293 --> 08:10:33.294
request. Cool. So one thing I do
want to show you that's

8249
08:10:33.294 --> 08:10:36.294
interesting is when I do submit
a transaction, and I actually

8250
08:10:36.294 --> 08:10:40.294
have one right here, I want to
send so let's transfer between

8251
08:10:40.294 --> 08:10:42.294
my accounts, and I'm just gonna
send it to tiny amount of

8252
08:10:43.294 --> 08:10:47.294
Rinkeby eath. But I'm going to
purposefully edit my gas fees to

8253
08:10:47.294 --> 08:10:53.294
be super, super low so that the
node will actually not muck send

8254
08:10:53.294 --> 08:10:55.294
the transaction to be mined, or
there are no miners that will

8255
08:10:55.294 --> 08:10:58.294
actually pick it up. So you can
see here I've divided the the

8256
08:10:58.294 --> 08:11:02.294
priority fee and the max fee by
a ton. So it's super low. And it

8257
08:11:02.294 --> 08:11:05.294
might confirm that in the MME
Max UI, you'll see that the

8258
08:11:05.294 --> 08:11:08.294
transaction has been pending for
a bit. And we'll go over to this

8259
08:11:08.294 --> 08:11:12.294
mempool tab. This is another
really useful visualization. And

8260
08:11:12.294 --> 08:11:17.294
what the mempool is, is a kind
of a holding ground, I like to

8261
08:11:17.294 --> 08:11:20.294
think of it as the waiting room
of a restaurant, where if you're

8262
08:11:20.294 --> 08:11:23.294
a transaction, and you're
waiting to get mined, the

8263
08:11:23.294 --> 08:11:25.294
mempool is kind of like the
waiting room where you're

8264
08:11:25.294 --> 08:11:29.294
waiting to get seated. So there
are different statuses for your

8265
08:11:29.294 --> 08:11:32.294
each of your transactions, the
ones that you always want to see

8266
08:11:32.294 --> 08:11:35.294
are the mines transactions,
because that says that your

8267
08:11:35.294 --> 08:11:38.294
transaction is successful. And
it's now part of the blockchain.

8268
08:11:38.294 --> 08:11:42.294
Now, the mempool, every node has
its own, you know, holding

8269
08:11:42.294 --> 08:11:44.294
ground. So I can actually show
you this quick visualization.

8270
08:11:44.294 --> 08:11:48.294
Remember, blockchains are run by
a network of nodes. And each

8271
08:11:48.294 --> 08:11:51.294
node or each computer that's
running the theorem, software

8272
08:11:51.294 --> 08:11:55.294
maintains a copy of the
blockchain. And as a developer,

8273
08:11:55.294 --> 08:11:58.294
you have to use these nodes to
make requests to the blockchain.

8274
08:11:58.294 --> 08:12:01.294
Now you can use alchemy, you can
use another RPC provider, you

8275
08:12:01.294 --> 08:12:04.294
can spin up your own node if you
want to. But regardless, you

8276
08:12:04.294 --> 08:12:07.294
need to use a node to
communicate with the chain. Now

8277
08:12:07.294 --> 08:12:11.295
each node beyond having a copy
of the entire blockchain state,

8278
08:12:11.295 --> 08:12:16.295
it also has a local memory of
transaction. And that's called

8279
08:12:16.295 --> 08:12:19.295
mempool. So if there are pending
transactions that are waiting to

8280
08:12:19.295 --> 08:12:23.295
be mined, you can consider them
as being in the mempool. Now

8281
08:12:23.295 --> 08:12:25.295
that's what we're looking at
right here. If we click on the

8282
08:12:25.295 --> 08:12:29.295
app that I am currently using
for my Metamask RPC, then you

8283
08:12:29.295 --> 08:12:34.295
can see here that there are,
this is not the right one, this

8284
08:12:34.295 --> 08:12:37.295
one is the right one for
wrinkling. For all the

8285
08:12:37.295 --> 08:12:39.295
transactions here, you can see
some more drop in placed

8286
08:12:39.295 --> 08:12:42.295
somewhere mind and there's one
that's pending, and this

8287
08:12:42.295 --> 08:12:45.295
pending, one actually matches up
with the one that is pending,

8288
08:12:45.295 --> 08:12:49.295
here, it's being sent to 0x, C,
BB. And if we click on this

8289
08:12:49.295 --> 08:12:52.295
transaction hash, you get all
the information that you need to

8290
08:12:52.295 --> 08:12:56.295
debug. So you can see here that
it's from my current address,

8291
08:12:56.295 --> 08:13:01.295
0x, five F, and then it's two
0x, C, BB. And here's the value

8292
08:13:01.295 --> 08:13:05.295
that I'm trying to send. Here's
the gas fee that I've attached

8293
08:13:05.295 --> 08:13:08.295
to this transaction. And you'll
notice that that is super low,

8294
08:13:08.295 --> 08:13:11.295
even for the Rinkeby test
network. So knowing this, and

8295
08:13:11.295 --> 08:13:14.295
seeing, wow, this transaction
has been pending for one minute

8296
08:13:14.295 --> 08:13:18.295
and 46 seconds, it was sent at
this time, I should probably fix

8297
08:13:18.295 --> 08:13:23.295
that. And so over here, you can
actually use the metamath RPC,

8298
08:13:23.295 --> 08:13:27.295
meta meta mask API. And speeded
up. And then I'm just going to

8299
08:13:27.295 --> 08:13:31.295
use the auto high speed up to
update the gas fees. And then if

8300
08:13:31.295 --> 08:13:36.295
we go back to our dashboard back
to our application, you can see

8301
08:13:36.295 --> 08:13:39.295
that there are some new recent
invalid requests. And this is

8302
08:13:39.295 --> 08:13:42.295
because we've resubmitted a
transaction, and then in their

8303
08:13:43.295 --> 08:13:47.295
recent requests we have, let's
refresh that real quick. You can

8304
08:13:47.295 --> 08:13:50.296
see that we are sending a raw
transaction, this one's already

8305
08:13:50.296 --> 08:13:54.296
known. And there's another one
before, but it that's resulting

8306
08:13:54.296 --> 08:13:57.296
in a get transaction receipt
that is successful. And then if

8307
08:13:57.296 --> 08:14:00.296
we go back to the mempool, you
can see boom, no more pending

8308
08:14:00.296 --> 08:14:04.296
transactions only dropped and
replaced and mined. So this

8309
08:14:04.296 --> 08:14:07.296
transaction nonce number five is
now successful, and you're on

8310
08:14:07.296 --> 08:14:10.296
your way to developing and
maintaining the rest of your

8311
08:14:10.296 --> 08:14:13.296
application. So yeah, thanks
hope that was useful. Let me

8312
08:14:13.296 --> 08:14:19.296
know if you have any questions.

8313
08:14:19.296 --> 08:14:22.296
Now, other than the TypeScript
portion, which I'll do at the

8314
08:14:22.296 --> 08:14:26.296
end, you've successfully
completed this section. And wow,

8315
08:14:26.296 --> 08:14:29.296
you've learned a ton. Let's do a
quick review of everything that

8316
08:14:29.296 --> 08:14:32.296
we've learned. Well, first,
we've learned how to create new

8317
08:14:32.296 --> 08:14:35.296
projects with Node js, we've
learned what the node keyword

8318
08:14:35.296 --> 08:14:39.296
does and how we can use the node
keyword. To run JavaScript in

8319
08:14:39.296 --> 08:14:42.296
our local development
environment, we learned that we

8320
08:14:42.296 --> 08:14:45.296
can add different dependencies
of external packages into our

8321
08:14:45.296 --> 08:14:49.296
local package using yarn or NPM.
And we can see those

8322
08:14:49.296 --> 08:14:52.296
dependencies added in package
dot JSON, we know that they've

8323
08:14:52.296 --> 08:14:55.296
been installed because they get
installed into the node modules

8324
08:14:55.296 --> 08:14:58.296
folder, we can also create a
script section where we can

8325
08:14:58.296 --> 08:15:01.296
minimize long commands that we
need to run into a single

8326
08:15:01.296 --> 08:15:04.296
keyword, like compile for
example, we can just run yarn

8327
08:15:04.296 --> 08:15:08.296
compile. To compile all of our
code, we learned the basic setup

8328
08:15:08.296 --> 08:15:12.296
of our JavaScript scripts, we
import our packages at the top,

8329
08:15:12.296 --> 08:15:15.296
we have some main executor
function at the bottom. And then

8330
08:15:15.296 --> 08:15:19.296
we have our main function in the
middle, we use the async keyword

8331
08:15:19.296 --> 08:15:23.296
so that our function can use
asynchronous programming, and we

8332
08:15:23.296 --> 08:15:27.296
get access to the await keyword,
which basically means Hey, wait

8333
08:15:27.296 --> 08:15:31.297
for this promise to finish doing
its thing. We're able to connect

8334
08:15:31.297 --> 08:15:35.297
to any blockchain we want using
an RPC URL, and then we're able

8335
08:15:35.297 --> 08:15:39.297
to connect our provider to a
wallet or a private key in

8336
08:15:39.297 --> 08:15:42.297
ethers by doing something like
this. Speaking of So we've

8337
08:15:42.297 --> 08:15:45.297
learned about the ethers
package, which is a tool that

8338
08:15:45.297 --> 08:15:48.297
makes our life a lot easier to
interact with the blockchain in

8339
08:15:48.297 --> 08:15:51.297
JavaScript, if we decide to,
we've also learned we can

8340
08:15:51.297 --> 08:15:55.297
encrypt our private keys so that
even if our computers get

8341
08:15:55.297 --> 08:15:58.297
hacked, our private keys aren't
lying around in plaintext. And

8342
08:15:58.297 --> 08:16:02.297
we've learned how to run scripts
from our encrypted keys. We've

8343
08:16:02.297 --> 08:16:05.297
learned how to get the ABI or
the application binary

8344
08:16:05.297 --> 08:16:08.297
interface, and the binary of our
code to deploy to a blockchain,

8345
08:16:08.297 --> 08:16:11.297
we've learned how to deploy our
contracts to a blockchain

8346
08:16:11.297 --> 08:16:14.297
programmatically. And then we've
learned how to interact with our

8347
08:16:14.297 --> 08:16:16.297
contracts programmatically as
well. Additionally, we've

8348
08:16:16.297 --> 08:16:20.297
learned how to add a default
editor in our settings dot JSON

8349
08:16:20.297 --> 08:16:24.297
of our VS code. But we've also
learned how to override those

8350
08:16:24.297 --> 08:16:28.297
settings by adding prettier
using a dot prettier rc file

8351
08:16:28.297 --> 08:16:31.297
this way, we can auto format our
code to make it look a lot nicer

8352
08:16:31.297 --> 08:16:34.297
and much easier to read.
Finally, we learned how to

8353
08:16:34.297 --> 08:16:38.297
deploy one of these contracts to
a real test net or a real

8354
08:16:38.297 --> 08:16:42.297
network. And then we finally
learned the manual way to verify

8355
08:16:42.297 --> 08:16:45.297
our contract source code. Like I
said, we're going to learn a lot

8356
08:16:45.297 --> 08:16:47.297
of shortcuts. And a lot of ways
to make this all a little bit

8357
08:16:47.297 --> 08:16:51.297
easier in coming sections. Oh,
you have done a phenomenally to

8358
08:16:51.297 --> 08:16:54.297
reach this section, give
yourself a pat on the back, take

8359
08:16:54.297 --> 08:16:57.297
a break, go for a lap, and feel
really proud about yourself that

8360
08:16:57.297 --> 08:17:00.297
you made it this far, we've got
a lot more to go. But you have

8361
08:17:00.297 --> 08:17:04.297
come a phenomenally long way.
Congratulations. Or take that

8362
08:17:04.297 --> 08:17:09.297
five to 10 minute break and come
back when you're ready.

8363
08:17:09.297 --> 08:17:12.298
Now the one thing left I want to
show you all is the TypeScript

8364
08:17:12.298 --> 08:17:15.298
addition to this. However, if
you're not interested in the

8365
08:17:15.298 --> 08:17:17.298
TypeScript edition, which you
don't have to be, then you're

8366
08:17:17.298 --> 08:17:20.298
done, there's only a couple of
changes we need to make to make

8367
08:17:20.298 --> 08:17:23.298
this TypeScript compatible.
First, of course, we're going to

8368
08:17:23.298 --> 08:17:28.298
change our deploy.ts and encrypt
key, we're going to change our

8369
08:17:28.298 --> 08:17:33.298
deploy and our encrypt key from
dot j s two.ts. And then we're

8370
08:17:33.298 --> 08:17:37.298
also going to swap these
requires out for imports. So

8371
08:17:37.298 --> 08:17:43.298
we're going to import ethers
from ethers, we're going to

8372
08:17:43.298 --> 08:17:51.298
import star as Fs from Fs extra.
And then we're going to import

8373
08:17:51.298 --> 08:17:55.298
dot TMP slash config. And then
we're just going to copy these,

8374
08:17:55.298 --> 08:17:59.298
and we're gonna come over and
paste them into here, deleting

8375
08:17:59.298 --> 08:18:03.298
or commenting out the requires,
okay, great. Now, if we try to

8376
08:18:03.298 --> 08:18:07.298
run Node deploy.ts, we're going
to get cannot use input

8377
08:18:07.298 --> 08:18:11.298
statement outside of a module.
In JavaScript, if we'd want to

8378
08:18:11.298 --> 08:18:14.298
use an import statement outside
of a module, we'd come in here

8379
08:18:14.298 --> 08:18:19.298
and do some like type module
like that. But in TypeScript, we

8380
08:18:19.298 --> 08:18:23.298
actually don't even need that.
All we need to do is run this in

8381
08:18:23.298 --> 08:18:27.298
TypeScript note. So to add
TypeScript, we're going to do

8382
08:18:27.298 --> 08:18:32.298
yarn, add TypeScript. And we're
also going to add TS node. TS

8383
08:18:32.298 --> 08:18:36.298
node is the TypeScript edition
of node. So now that we've added

8384
08:18:36.298 --> 08:18:40.298
that we can try a TS node
deploy.ts. And we're still going

8385
08:18:40.298 --> 08:18:44.298
to run into an error. And if you
scroll up, we're gonna get a

8386
08:18:44.298 --> 08:18:47.298
couple errors here. We're gonna
say, could not find a

8387
08:18:47.298 --> 08:18:51.299
declaration file for Module Fs
extra, we need to add the

8388
08:18:51.299 --> 08:18:56.299
TypeScript version of them. So
we're gonna do yarn at types

8389
08:18:56.299 --> 08:19:01.299
slash Fs extra. That, and if we
run it again, it still shouldn't

8390
08:19:01.299 --> 08:19:03.299
work. But for a different
reason. Yes, we're gonna get

8391
08:19:03.299 --> 08:19:06.299
something like this type.
Undefined is not assignable to

8392
08:19:06.299 --> 08:19:10.299
type bytes. Like the reason we
get this is because process dot

8393
08:19:10.299 --> 08:19:15.299
EMV private key in TypeScript
technically, is type string, or

8394
08:19:15.299 --> 08:19:20.299
undefined. So we need to tell
Typescript and and the Wallet

8395
08:19:20.299 --> 08:19:22.299
Objects. And the Encrypt
function is looking for a type

8396
08:19:22.299 --> 08:19:26.299
string, not string or undefined.
So we just need to tell

8397
08:19:26.299 --> 08:19:29.299
TypeScript that this will not be
undefined. So we can just put a

8398
08:19:29.299 --> 08:19:33.299
bang here. And everywhere that
we use process, study and be,

8399
08:19:33.299 --> 08:19:38.299
oops, I got to do that on
deploy, as well. Bang, looks

8400
08:19:38.299 --> 08:19:41.299
good. Now that we've added
everything in here, we run TS

8401
08:19:41.299 --> 08:19:45.299
node deploy.ts, we're gonna see
the exact same output as we saw

8402
08:19:45.299 --> 08:19:48.299
with just using regular node.
And as long as our private key

8403
08:19:48.299 --> 08:19:52.299
password is in our dot env file.
If we run TS node and crypt

8404
08:19:52.299 --> 08:19:56.299
key.ts, we're gonna get the
exact same setup as before. And

8405
08:19:56.299 --> 08:19:59.299
we're gonna get a new encrypted
key dot JSON. And that's all you

8406
08:19:59.299 --> 08:20:02.299
need to do to make this
TypeScript compatible. And you

8407
08:20:02.299 --> 08:20:04.299
should give yourself a huge
round of applause for getting

8408
08:20:04.299 --> 08:20:08.299
this far and learning what's
going on underneath hardhat. The

8409
08:20:08.299 --> 08:20:11.299
next tool that we're going to
learn and learning all about

8410
08:20:11.299 --> 08:20:14.299
these transactions and how to
interact with these blockchains

8411
08:20:14.299 --> 08:20:19.299
this is absolutely massive, so
huge. Congratulations.

8412
08:20:19.299 --> 08:20:22.299
Alright, so now that we've
learned about ethers js and how

8413
08:20:22.299 --> 08:20:26.299
to do some more raw JavaScript
coding, we're now going to move

8414
08:20:26.299 --> 08:20:29.299
into hardhat. We saw with our
ether symbol storage that

8415
08:20:29.299 --> 08:20:32.300
deploying a contract can take a
lot of code. And there's a

8416
08:20:32.300 --> 08:20:35.300
number of things we didn't even
do in here. Like we didn't save

8417
08:20:35.300 --> 08:20:38.300
where this contract was
deployed. So we'd have to go

8418
08:20:38.300 --> 08:20:41.300
remember where it was deployed
every time. Instead of having it

8419
08:20:41.300 --> 08:20:44.300
just added programmatically. We
didn't write any tests here, and

8420
08:20:44.300 --> 08:20:46.300
we'd have to build our own
testing infrastructure. Maybe we

8421
08:20:46.300 --> 08:20:49.300
want to make this a cross chain
application. And we want more

8422
08:20:49.300 --> 08:20:52.300
than just one private key and
RPC URL, you can absolutely work

8423
08:20:52.300 --> 08:20:55.300
with your smart contracts in
JavaScript purely through ethers

8424
08:20:55.300 --> 08:20:59.300
and small scripts like this. But
we want a more robust framework

8425
08:20:59.300 --> 08:21:03.300
for doing all this. And that's
where hard hat comes into play.

8426
08:21:03.300 --> 08:21:06.300
Hardhead is easily one of the
most, if not the most popular

8427
08:21:06.300 --> 08:21:09.300
smart contract development
framework out there. It's used

8428
08:21:09.300 --> 08:21:13.300
by massive several billion
dollar protocols like Ave

8429
08:21:13.300 --> 08:21:16.300
uniswap, sushi swap, and more.
In fact, I recently did a poll

8430
08:21:16.300 --> 08:21:19.300
on Twitter. And even though a
lot of my content has been more

8431
08:21:19.300 --> 08:21:23.300
brownie and Pythonic, Hardhead
was well and beyond the most

8432
08:21:23.300 --> 08:21:26.300
popular framework, and Hardhead
has quickly become one of the

8433
08:21:26.300 --> 08:21:29.300
most advanced frameworks out
there. Hardhead is a development

8434
08:21:29.300 --> 08:21:31.300
environment, which allows for
JavaScript based development,

8435
08:21:31.300 --> 08:21:34.300
kind of like what we saw with
ethers, it gives us even more

8436
08:21:34.300 --> 08:21:38.300
tools to integrate our code with
common things that we want to

8437
08:21:38.300 --> 08:21:41.300
do. It's incredibly extensible,
and it has really nice debugging

8438
08:21:41.300 --> 08:21:44.300
features as well. And it's just
an overall fantastic tool. So

8439
08:21:44.300 --> 08:21:47.300
let's go ahead and let's jump
in. If you want to follow along

8440
08:21:47.300 --> 08:21:50.300
with the code, come over to the
GitHub repo and scroll down.

8441
08:21:50.300 --> 08:21:53.300
Lesson Six heart had simple
storage, and all the code is

8442
08:21:53.300 --> 08:21:57.300
located here. And a quick note
for the future ever, you want to

8443
08:21:57.300 --> 08:21:59.300
just download all the code from
one of these repositories, the

8444
08:21:59.300 --> 08:22:03.300
way you can do that is by doing
a git clone, what you do is you

8445
08:22:03.300 --> 08:22:06.300
come to the folder that you want
to put this code in, and you run

8446
08:22:06.300 --> 08:22:10.301
git clone. And then you grab the
URL that you want to clone,

8447
08:22:10.301 --> 08:22:16.301
paste it in. Now, you can CD
into your new folder here that

8448
08:22:16.301 --> 08:22:20.301
has everything downloaded
directly from GitHub, but only

8449
08:22:20.301 --> 08:22:23.301
do that as a backup or to just
download the code yourself. But

8450
08:22:23.301 --> 08:22:26.301
for now, just follow along with
me. Right, so let's do this.

8451
08:22:26.301 --> 08:22:30.301
Let's create our next project
using hard hat. The project that

8452
08:22:30.301 --> 08:22:33.301
we're going to be making is
called Hard Hat, simple storage

8453
08:22:33.301 --> 08:22:37.301
dash FCC or Free Code Camp. This
is going to be us working again

8454
08:22:37.301 --> 08:22:40.301
with that simple storage
contract. But in hard hat, we're

8455
08:22:40.301 --> 08:22:44.301
going to show you a ton of the
fantastic tools that we can use

8456
08:22:44.301 --> 08:22:50.301
to make our coding life way
easier. So I'm in a brand new VS

8457
08:22:50.301 --> 08:22:53.301
code, and we're going to create
a new folder for us to run all

8458
08:22:53.301 --> 08:22:56.301
this. Now what you can do to
create a brand new folder is you

8459
08:22:56.301 --> 08:23:04.301
once again you can do MK dir,
hard hat, simple storage of CC.

8460
08:23:04.301 --> 08:23:08.301
Now we can cd into hard hat
simple storage of CD, and type

8461
08:23:08.301 --> 08:23:13.301
code, period. And this will open
up a new Visual Studio code

8462
08:23:13.301 --> 08:23:18.301
inside of that folder. Now if we
open up our terminal, you'll see

8463
08:23:18.301 --> 08:23:22.301
that we are indeed inside that
folder. Now if that doesn't work

8464
08:23:22.301 --> 08:23:26.301
for you, you can still of course
to File, Open folder and select

8465
08:23:26.301 --> 08:23:29.301
the folder you'd like to open.
And you'll be inside of that

8466
08:23:29.301 --> 08:23:31.301
folder. Now that we have our
folder setup for working with

8467
08:23:31.301 --> 08:23:34.301
hard hat, we can begin setting
up our environment to be

8468
08:23:34.301 --> 08:23:37.301
incredibly professional using
the hard hat framework got a

8469
08:23:37.301 --> 08:23:41.301
link to the hard hat
documentation inside our whole

8470
08:23:41.301 --> 08:23:44.301
blockchain solidity course, yes,
the hard hat documentation is

8471
08:23:44.301 --> 08:23:47.301
phenomenal. And I highly
recommend everybody have it up

8472
08:23:47.301 --> 08:23:49.301
as they go through the section.
Because it's going to give you

8473
08:23:49.301 --> 08:23:52.302
pretty much everything that you
need to know for working with

8474
08:23:52.302 --> 08:23:55.302
hard hat, you can simply go
ahead over to tutorial and get

8475
08:23:55.302 --> 08:23:58.302
started. If you want to pause
the video here and read through

8476
08:23:58.302 --> 08:24:01.302
the tutorial, I recommend doing
so it'll give you a lot of

8477
08:24:01.302 --> 08:24:04.302
information about how to work
with hardhat. And more about

8478
08:24:04.302 --> 08:24:06.302
hardhat. However, we're just
going to jump right into setting

8479
08:24:06.302 --> 08:24:09.302
up the environment. We've
already installed no Gs on

8480
08:24:09.302 --> 08:24:14.302
Linux, or Mac OS. And those of
you who are using Windows, I set

8481
08:24:14.302 --> 08:24:19.302
you up with WsL. So you can just
follow the Linux instructions.

8482
08:24:19.302 --> 08:24:21.302
Now to create a new hard hat
project, you can actually just

8483
08:24:21.302 --> 08:24:24.302
go ahead and run these steps
right here. Instead of NPM,

8484
08:24:24.302 --> 08:24:27.302
we're going to be using yarn,
but if you want to use NPM, you

8485
08:24:27.302 --> 08:24:31.302
can absolutely do so the hard
hat Doc's say run npm init dash

8486
08:24:31.302 --> 08:24:34.302
dash, yes, we're just going to
run yarn in it, which is going

8487
08:24:34.302 --> 08:24:38.302
to create a new project for us
in this folder. So let's give it

8488
08:24:38.302 --> 08:24:42.302
a name, which if we want it set
to this hard hat symbol storage

8489
08:24:42.302 --> 08:24:45.302
FF FCC, we just hit enter, we'll
give it a version. And when if

8490
08:24:45.302 --> 08:24:49.302
we want it 1.0 point oh, we just
hit enter. We're going to skip

8491
08:24:49.302 --> 08:24:52.302
the description for now just by
hitting enter. And we're just

8492
08:24:52.302 --> 08:24:55.302
going to hit Enter for this as
well. And for this as well enter

8493
08:24:55.302 --> 08:24:59.302
for this as well and for this as
well and over this as well. Just

8494
08:24:59.302 --> 08:25:03.302
to keep those as blanks. And if
we look in package json, we now

8495
08:25:03.302 --> 08:25:06.302
see we have a name Hardhead
symbol storage that FCC we have

8496
08:25:06.302 --> 08:25:09.302
a version we have a main which
we're actually going to delete

8497
08:25:09.302 --> 08:25:12.302
the main and then we have a
license as well. yarn in it just

8498
08:25:12.302 --> 08:25:15.302
sets up this package json for
us. Now we're going to do yarn,

8499
08:25:15.302 --> 08:25:17.302
add dash dash dash

8500
08:25:17.302 --> 08:25:25.302
of our app. So far, we've just
been running yarn add, and then

8501
08:25:25.302 --> 08:25:27.302
whatever our package name is.
But for most of what we're

8502
08:25:27.302 --> 08:25:31.303
doing, we really want to do yarn
add dash dash Dev. The reasons

8503
08:25:31.303 --> 08:25:34.303
for this is a little bit
nuanced. But we can see some of

8504
08:25:34.303 --> 08:25:36.303
the information on this
StackOverflow question here. The

8505
08:25:36.303 --> 08:25:39.303
main difference is that
dependencies are required to run

8506
08:25:39.303 --> 08:25:42.303
your project. Whereas dev
dependencies are required only

8507
08:25:43.303 --> 08:25:45.303
to develop. For the most part,
we're going to be doing just

8508
08:25:45.303 --> 08:25:48.303
dash dash Dev, when we get to
the front end portion of this

8509
08:25:48.303 --> 08:25:51.303
course, we'll be installing more
packages that we don't need just

8510
08:25:51.303 --> 08:25:53.303
for development. Now in the same
directory where we install hard

8511
08:25:53.303 --> 08:25:58.303
hat, you can run MPX hard hat.
So a quick note about MPX is

8512
08:25:58.303 --> 08:26:03.303
that the yarn equivalent of NPM
is just yarn. So yarn goes NPM,

8513
08:26:03.303 --> 08:26:07.303
the yarn equivalent of MPX is
also yarn. So pretty much

8514
08:26:07.303 --> 08:26:11.303
anytime you see MPX, do
something, you can just replace

8515
08:26:11.303 --> 08:26:14.303
that MPX with yarn, and it'll do
the exact same thing. If you

8516
08:26:14.303 --> 08:26:17.303
want to run this with NPM or
MPX, you can absolutely do that

8517
08:26:17.303 --> 08:26:21.303
as well. So for us, we're going
to run yarn hardhat. And we'll

8518
08:26:21.303 --> 08:26:23.303
see we'll get prompted to
actually start creating a

8519
08:26:23.303 --> 08:26:27.303
hardhat project, run yarn
hardhat. And we'll get this

8520
08:26:27.303 --> 08:26:30.303
wonderfully cute prompt right
here and saying welcome to

8521
08:26:30.303 --> 08:26:32.303
Hardhead. What do you want to
do, create a basic sample

8522
08:26:32.303 --> 08:26:36.303
project, create an advanced
sample project can advance some

8523
08:26:36.303 --> 08:26:38.303
project uses type script or
create an empty

8524
08:26:38.303 --> 08:26:41.303
hardhat.config.js. For us, we're
just going to select create a

8525
08:26:41.303 --> 08:26:44.303
basic sample project. And this
is going to give us all the

8526
08:26:44.303 --> 08:26:48.303
boilerplate for a really simple
hardhat project. The hard hat

8527
08:26:48.303 --> 08:26:50.303
project route is going to be
this folder that we're in right

8528
08:26:50.303 --> 08:26:53.303
now. Do you want to add a Git
dot Git ignore? Yes, we

8529
08:26:53.303 --> 08:26:56.303
absolutely do. Because we're
going to be using dot env files.

8530
08:26:56.303 --> 08:26:59.303
Do you want to install this
sample projects dependencies

8531
08:26:59.303 --> 08:27:04.303
with yarn at nomic labs hard hat
at a theory and waffle at Chai?

8532
08:27:04.303 --> 08:27:06.303
We're going to go ahead and say
yes, and I'll explain what all

8533
08:27:06.303 --> 08:27:09.303
these dependencies are in a bit.
Let's go ahead and say yes for

8534
08:27:09.303 --> 08:27:15.304
now. And we're going to install
all these dependencies. Now, if

8535
08:27:15.304 --> 08:27:18.304
we look in our package, JSON, we
can see we've added a number of

8536
08:27:18.304 --> 08:27:22.304
dependencies like nomic labs,
Hardhead ethers, not MacLeods,

8537
08:27:22.304 --> 08:27:26.304
Hardhead, waffle, Chai,
Aetherium, waffle, and ethers.

8538
08:27:26.304 --> 08:27:28.304
Obviously, we're already
familiar with ethers, but the

8539
08:27:28.304 --> 08:27:30.304
rest of these might be a little
new. We'll talk about those

8540
08:27:30.304 --> 08:27:35.304
later. And great, we now have a
sample hardhat boilerplate

8541
08:27:35.304 --> 08:27:38.304
project. Let's walk through what
we just installed here. The

8542
08:27:38.304 --> 08:27:41.304
first thing we have is a
contracts folder, which comes

8543
08:27:41.304 --> 08:27:44.304
pre populated with greeted
outsole is really minimalistic

8544
08:27:44.304 --> 08:27:48.304
contract here. Next, you'll see
node modules, which of course is

8545
08:27:48.304 --> 08:27:50.304
our installed JavaScript
dependencies. Something I want

8546
08:27:50.304 --> 08:27:53.304
to know because it was really
confusing to me when I first

8547
08:27:53.304 --> 08:27:56.304
started working with this is
some of these node modules start

8548
08:27:56.304 --> 08:27:58.304
with an add sign, and then a lot
of them don't. What's the

8549
08:27:58.304 --> 08:28:01.304
difference between those two,
these outside node modules are

8550
08:28:01.304 --> 08:28:05.304
known as scoped packages, which
effectively allow NPM packages

8551
08:28:05.304 --> 08:28:08.304
to be namespace or yarn
packages. This allows

8552
08:28:08.304 --> 08:28:11.304
organizations to make it clear
what packages are official and

8553
08:28:11.304 --> 08:28:15.304
which ones are not. For example,
if a package has a scope at

8554
08:28:15.304 --> 08:28:17.304
Angular, you know, it's
published by the Angular core

8555
08:28:17.304 --> 08:28:20.304
team. So it's the same thing
with this anything with AP ens

8556
08:28:20.304 --> 08:28:23.304
domains we know is by the ens
domains team, anything with

8557
08:28:23.304 --> 08:28:27.304
abnormal Labs is going to be by
the team that created hard hat.

8558
08:28:27.304 --> 08:28:30.304
So that's why this at nomic
labs, hard hat ethers and at

8559
08:28:30.304 --> 08:28:33.304
nomic labs, hard at Waffle has
this at sign, because we know

8560
08:28:33.304 --> 08:28:37.304
it's published by the nomic labs
team, then we have a scripts

8561
08:28:37.304 --> 08:28:40.304
section. This is going to be
where we're adding any and all

8562
08:28:40.304 --> 08:28:43.304
of our scripts that we want to
write like deploying contracts,

8563
08:28:43.304 --> 08:28:46.304
interacting with contracts, etc.
And then we have a test folder.

8564
08:28:46.304 --> 08:28:49.304
We haven't started building any
tests yet. But tests are

8565
08:28:49.304 --> 08:28:52.305
incredibly important for working
with smart contracts. And this

8566
08:28:52.305 --> 08:28:56.305
sample test folder gives us a
minimalistic test for testing

8567
08:28:56.305 --> 08:28:59.305
our smart contracts. We of
course have Git ignore, which of

8568
08:28:59.305 --> 08:29:02.305
course comes pre populated with
some important things to ignore

8569
08:29:02.305 --> 08:29:06.305
like Dotty and V. And also node
modules because node modules

8570
08:29:06.305 --> 08:29:09.305
might get too huge push up to
GitHub. And one of the biggest

8571
08:29:09.305 --> 08:29:14.305
changes here is it adds this
hard hat.config.js. This file

8572
08:29:14.305 --> 08:29:17.305
even though it's minimalistic,
right now, you can think of as

8573
08:29:17.305 --> 08:29:20.305
the entry point for all the
scripts that we write, it's the

8574
08:29:20.305 --> 08:29:22.305
configuration file that
determines how the rest of our

8575
08:29:22.305 --> 08:29:25.305
code is going to work and
interact with the blockchain.

8576
08:29:25.305 --> 08:29:28.305
Then of course, we have package
dot JSON, we get started with a

8577
08:29:28.305 --> 08:29:31.305
readme. Remember how the first
time we ran yarn hard hat, we

8578
08:29:31.305 --> 08:29:35.305
were prompted with this Getting
Started piece. Now if we run

8579
08:29:35.305 --> 08:29:38.305
yarn Hardhead, we're actually
going to get output of all the

8580
08:29:38.305 --> 08:29:40.305
different options and commands
we can use

8581
08:29:40.305 --> 08:29:46.305
with running hard hat. Now, if
you run into an issue where you

8582
08:29:46.305 --> 08:29:50.305
run yarn, hard hat, and this
pops up, but you don't see a

8583
08:29:50.305 --> 08:29:53.305
hard hat.config.js in your
folder, it likely means that

8584
08:29:53.305 --> 08:29:57.305
there's a hard hat dot config
dot j s in a higher level

8585
08:29:57.305 --> 08:30:00.305
folder, or there's a node
modules with hard hat in a

8586
08:30:00.305 --> 08:30:04.305
higher level folder. So if that
happens, maybe CD down a

8587
08:30:04.305 --> 08:30:07.305
directory and do a little LS and
look to see if you've got a hard

8588
08:30:07.305 --> 08:30:12.305
hat.config.js or node modules in
earlier folder. And because I've

8589
08:30:12.305 --> 08:30:14.305
actually seen a number of
engineers have a couple of

8590
08:30:14.305 --> 08:30:17.305
different problems here. My
friend CAMI is going to explain

8591
08:30:17.305 --> 08:30:19.305
A couple of different
troubleshooting tips you can

8592
08:30:19.305 --> 08:30:21.305
take to try to avoid these
common errors.

8593
08:30:21.305 --> 08:30:23.305
As a developer the most annoying
thing to deal with our

8594
08:30:23.305 --> 08:30:26.305
environment set of issues. My
name is Camila Ramos. I'm a

8595
08:30:26.305 --> 08:30:30.305
DevRel engineer at edge node
supporting the Graph Protocol.

8596
08:30:30.305 --> 08:30:32.306
And I'm going to show you how to
solve two common problems that

8597
08:30:32.306 --> 08:30:35.306
you might see when working on
this project. After installing

8598
08:30:35.306 --> 08:30:38.306
hardhat. And running the command
and px hard hat in your new

8599
08:30:38.306 --> 08:30:40.306
project folder, you're going to
expect to get back a menu of

8600
08:30:40.306 --> 08:30:42.306
options like this, but sometimes
you're not going to get that

8601
08:30:42.306 --> 08:30:46.306
back. And when you run into this
error, there is a solution for

8602
08:30:46.306 --> 08:30:48.306
you. And it usually just means
that you have a config file

8603
08:30:48.306 --> 08:30:51.306
somewhere that it shouldn't be,
and deleting it will get rid of

8604
08:30:51.306 --> 08:30:53.306
that error. What you're going to
do in order to find this file

8605
08:30:53.306 --> 08:30:57.306
that you need to delete is run
the command MPX hardhats space,

8606
08:30:57.306 --> 08:31:00.306
hyphen, hyphen verbose. And this
is going to spit out where this

8607
08:31:00.306 --> 08:31:03.306
file is if you have one, and
it's going to tell you exactly

8608
08:31:03.306 --> 08:31:05.306
where it is so that you can
delete it. After you've deleted

8609
08:31:05.306 --> 08:31:08.306
this config file, you should be
able to run MPX hardhat in your

8610
08:31:08.306 --> 08:31:12.306
project folder and get back that
many that we were expecting.

8611
08:31:12.306 --> 08:31:15.306
Another problem that is pretty
common. And I still run into all

8612
08:31:15.306 --> 08:31:18.306
the time is forgetting to npm
install, whenever you're working

8613
08:31:18.306 --> 08:31:21.306
with a repo that other people
have been working on on GitHub.

8614
08:31:21.306 --> 08:31:24.306
So let's say you're pulling down
some code that you and some

8615
08:31:24.306 --> 08:31:27.306
collaborators were working on
together, and then suddenly,

8616
08:31:27.306 --> 08:31:29.306
it's not working for you, you
probably just need to npm

8617
08:31:29.306 --> 08:31:32.306
install. So in your terminal, go
ahead and navigate to where this

8618
08:31:32.306 --> 08:31:36.306
project is located and then run
the command npm install. If

8619
08:31:36.306 --> 08:31:39.306
there are any new packages that
were installed in the time that

8620
08:31:39.306 --> 08:31:41.306
you weren't working on the code,
those will get installed locally

8621
08:31:41.306 --> 08:31:43.306
for you so that when you run the
code, it will be able to run

8622
08:31:43.306 --> 08:31:50.306
successfully.

8623
08:31:50.306 --> 08:31:53.306
What are some of the main things
we can do with hardhat in its

8624
08:31:53.306 --> 08:31:56.306
raw state here, these are some
of the main tasks that we can

8625
08:31:56.306 --> 08:31:59.306
run with hardhat different tasks
or just different commands, we

8626
08:31:59.306 --> 08:32:02.306
can run with hardhat. For
example, we can do yarn hardhat

8627
08:32:02.306 --> 08:32:07.306
counts, which will print out a
list of fake accounts we can use

8628
08:32:07.306 --> 08:32:10.306
with Hardhead. Similar to the
list of fake accounts that we

8629
08:32:10.306 --> 08:32:13.307
used with ganache, we can
compile our contracts by running

8630
08:32:13.307 --> 08:32:19.307
yarn Hardhead compile. Very
similar to what we did with

8631
08:32:19.307 --> 08:32:23.307
ethers Jas and soap Jas, you'll
see when we run compile, we get

8632
08:32:23.307 --> 08:32:27.307
a cache, which is just going to
be a quick way to access

8633
08:32:27.307 --> 08:32:30.307
solidity files, and we also get
an artifacts section. This

8634
08:32:30.307 --> 08:32:34.307
artifacts folder contains all
the information about our

8635
08:32:34.307 --> 08:32:38.307
compiled code we look in here
now we can, for example, look in

8636
08:32:38.307 --> 08:32:42.307
the build info and see a ton of
information about our compiled

8637
08:32:42.307 --> 08:32:45.307
contract. If you're looking
contracts, we can see more

8638
08:32:45.307 --> 08:32:49.307
compiled information. And then
if we look in the hardhat, slash

8639
08:32:49.307 --> 08:32:52.307
console.so, we can see more
compiled information. So all of

8640
08:32:52.307 --> 08:32:55.307
our compliation information is
going to be in this artifacts

8641
08:32:55.307 --> 08:32:59.307
folder. And whenever you want to
look to see what's going on on

8642
08:32:59.307 --> 08:33:03.307
the lower level when you compile
this artifacts folder is what

8643
08:33:03.307 --> 08:33:05.307
has everything. There are a
number of other hard hat tasks

8644
08:33:05.307 --> 08:33:11.307
that we can run as well. But
we'll get to them as we go. So

8645
08:33:11.307 --> 08:33:14.307
now that we have some of the
basics of hard head down, let's

8646
08:33:14.307 --> 08:33:16.307
go ahead and try doing some of
the same things we did with

8647
08:33:16.307 --> 08:33:20.307
ethers before but with hard hat.
So one of the first things we

8648
08:33:20.307 --> 08:33:23.307
want to do is we want to write
and interact with our smart

8649
08:33:23.307 --> 08:33:28.307
contracts. So let's go ahead and
rename greeter dot soul to

8650
08:33:28.307 --> 08:33:33.307
simple storage dot soul, you can
click on the file and hit enter

8651
08:33:33.307 --> 08:33:35.307
and should be able to rename it.
Otherwise, you can go ahead and

8652
08:33:35.307 --> 08:33:39.307
right click, delete it, and then
create a new file and call it

8653
08:33:39.307 --> 08:33:43.307
simple storage dot soul. We're
going to copy paste all of our

8654
08:33:43.307 --> 08:33:47.307
code from our previous simple
storage that saw into this file,

8655
08:33:47.307 --> 08:33:50.307
we can make sure that our simple
storage is compiling correctly

8656
08:33:50.307 --> 08:33:55.308
by running yarn hardhat compile.
Whoa, it looks like we ran into

8657
08:33:55.308 --> 08:33:59.308
an issue project cannot be
compiled. See reasons below the

8658
08:33:59.308 --> 08:34:01.308
solidity pragma version of the
file. It doesn't match any of

8659
08:34:01.308 --> 08:34:05.308
the configured compilers in your
config. Hmm, well, what's going

8660
08:34:05.308 --> 08:34:09.308
on contracts slash symbol
storage that's Sol zero point

8661
08:34:09.308 --> 08:34:13.308
8.8. Ah, okay, let's go ahead
and fix them. So we can open up

8662
08:34:13.308 --> 08:34:17.308
our hard hat dot config dot j s.
Now a quick note on opening

8663
08:34:17.308 --> 08:34:21.308
files. If you're on Mac and you
hit Command P, you can actually

8664
08:34:21.308 --> 08:34:24.308
start typing in the names of
files to get them to them

8665
08:34:24.308 --> 08:34:29.308
quicker. Or if you're on Linux
or Windows, you can type Ctrl p,

8666
08:34:29.308 --> 08:34:32.308
this will bring up and
interestingly if you type man P

8667
08:34:32.308 --> 08:34:36.308
or ctrl p and then you hit the
greater than key. This will drop

8668
08:34:36.308 --> 08:34:39.308
you into the command palette,
know command palette, command

8669
08:34:39.308 --> 08:34:43.308
palette, search for files,
search for commands in our

8670
08:34:43.308 --> 08:34:46.308
Hardhead dot config. Jas, I'm
gonna scroll down to module dot

8671
08:34:46.308 --> 08:34:52.308
exports and change this to zero
point 8.8. So that the version

8672
08:34:52.308 --> 08:34:54.308
that we're going to compile for
simple storage, it's gonna be

8673
08:34:54.308 --> 08:34:58.308
the same version and that hard
hat is looking for. Let's run

8674
08:34:58.308 --> 08:35:00.308
that same command by just
hitting up yarn Hardhead

8675
08:35:00.308 --> 08:35:03.308
compile, and awesome we see
compiled one solidity file

8676
08:35:03.308 --> 08:35:07.308
successfully. We should now see
this in artifacts. If we go to

8677
08:35:07.308 --> 08:35:10.308
artifacts and contracts. We now
see two contracts in here,

8678
08:35:10.308 --> 08:35:13.308
greater and simple storage and
we can see a ton of the

8679
08:35:13.308 --> 08:35:16.308
information about simple storage
we can also see some more lower

8680
08:35:16.308 --> 08:35:19.308
level in Information and build
info. Alright, so now that we

8681
08:35:19.308 --> 08:35:22.308
have our simple storage contract
in here, the next thing we

8682
08:35:22.308 --> 08:35:24.308
probably want to do is learn how
to deploy it. This is where

8683
08:35:24.308 --> 08:35:28.308
we're going to write our deploy
script. Now, for this section,

8684
08:35:28.308 --> 08:35:30.308
I'm going to be showing you how
to write a deploy script. But in

8685
08:35:30.308 --> 08:35:33.309
the next section, we're going to
do it a little bit differently.

8686
08:35:33.309 --> 08:35:35.309
But this is still going to teach
you how to write scripts and

8687
08:35:35.309 --> 08:35:38.309
worked with scripts in heart
app. So we're going to come to

8688
08:35:38.309 --> 08:35:41.309
our sample script dot j s, and
we're gonna go ahead and hit

8689
08:35:41.309 --> 08:35:46.309
enter and renamed it to deploy
dot j s. And if you want to read

8690
08:35:46.309 --> 08:35:48.309
all the comments in here, you
absolutely can, we're just gonna

8691
08:35:48.309 --> 08:35:52.309
go ahead and delete them all. A
quick keyboard shortcut is if

8692
08:35:52.309 --> 08:35:56.309
you hit Command A or Ctrl, a,
you'll highlight all the text in

8693
08:35:56.309 --> 08:36:00.309
your file, and we're going to go
ahead and delete it all. So now

8694
08:36:00.309 --> 08:36:02.309
we're just going to start from
scratch here. Now the setup for

8695
08:36:02.309 --> 08:36:04.309
our deploy script in here is
going to look really similar to

8696
08:36:04.309 --> 08:36:07.309
the setup of our deploy script.
From our previous section, we're

8697
08:36:07.309 --> 08:36:10.309
going to do imports at the top,
we're going to have our async

8698
08:36:10.309 --> 08:36:13.309
main function, and then we're
going to call the main function.

8699
08:36:13.309 --> 08:36:16.309
So let's go ahead and define our
main function, we'll call it

8700
08:36:16.309 --> 08:36:20.309
async. function main, like that,
and then we'll call our main

8701
08:36:20.309 --> 08:36:23.309
function. And if you want to
just copy paste this from the

8702
08:36:23.309 --> 08:36:42.309
last section, you absolutely
can. So we'll domain that then.

8703
08:36:42.309 --> 08:36:45.309
Boom, just like that. And
because of these semicolons are

8704
08:36:45.309 --> 08:36:48.309
going to drive me absolutely
insane. We're also going to add

8705
08:36:48.309 --> 08:36:52.309
prettier, and our solidity
prettier plugins. So we'll do

8706
08:36:52.309 --> 08:37:02.309
yarn, add dash dash Dev,
prettier and prettier, plug in

8707
08:37:02.309 --> 08:37:09.309
solidity. Then we can go ahead
and create our dot prettier, rc

8708
08:37:09.309 --> 08:37:19.310
file, we're going to add tab
with four, use tabs, false, semi

8709
08:37:19.310 --> 08:37:24.310
false, and then single quote,
also false. Now we're going to

8710
08:37:24.310 --> 08:37:28.310
be using this prettier rc file
setup a lot. So in future

8711
08:37:28.310 --> 08:37:30.310
sections, if you want to just
copy paste it, you can

8712
08:37:30.310 --> 08:37:33.310
absolutely do that as well.
We're also going to add a dot

8713
08:37:33.310 --> 08:37:37.310
prettier, ignore, which tells
prettier not to format some

8714
08:37:37.310 --> 08:37:40.310
files, which we want, we don't
want prettier to spend a ton of

8715
08:37:40.310 --> 08:37:42.310
time formatting all of our
files, I'm just going to copy

8716
08:37:42.310 --> 08:37:46.310
paste from the GitHub repo. So
feel free to copy paste from the

8717
08:37:46.310 --> 08:37:48.310
GitHub repo as well, you'd find
all the code for this section,

8718
08:37:49.310 --> 08:37:51.310
like I said, in the GitHub repo
associated with this course.

8719
08:37:51.310 --> 08:37:54.310
Now, unlike in our last section,
where we had to grab our

8720
08:37:54.310 --> 08:37:58.310
contract code a little bit more
manually, with hard hat, it's

8721
08:37:58.310 --> 08:38:00.310
actually a number of different
ways to grab compiled contracts.

8722
08:38:00.310 --> 08:38:03.310
The first way we're going to do
it, we're actually going to use

8723
08:38:03.310 --> 08:38:06.310
ethers. And now this is where
one of the first confusing

8724
08:38:06.310 --> 08:38:11.310
changes actually comes in.
Previously, we did const ethers

8725
08:38:11.310 --> 08:38:16.310
equals require ethers. And that
was how we went ahead and worked

8726
08:38:16.310 --> 08:38:21.310
with ethers. However, you'll
notice in our dev dependencies,

8727
08:38:21.310 --> 08:38:24.310
we have this dependency called
Hard Hat ethers. Hard Hat ethers

8728
08:38:24.310 --> 08:38:28.310
is a package that actually wraps
hard hat with its own built in

8729
08:38:28.310 --> 08:38:31.310
ethers. This is really
advantageous because it allows

8730
08:38:31.310 --> 08:38:33.310
hard hat to keep track of
different deployments at

8731
08:38:33.310 --> 08:38:36.310
different scripts and all these
other things for us. So instead

8732
08:38:36.310 --> 08:38:39.310
of importing ethers directly
from ethers, we're actually

8733
08:38:39.310 --> 08:38:43.310
going to import ethers directly
from hard hat instead. This

8734
08:38:43.310 --> 08:38:46.310
might seem a little confusing at
first, but just know if we want

8735
08:38:46.310 --> 08:38:49.310
to work with ethers and heart
it, it's usually much better to

8736
08:38:49.310 --> 08:38:52.311
pull it in from heart and you
can still do this and ethers

8737
08:38:52.311 --> 08:38:56.311
will still work the same. But
hard hat won't necessarily know

8738
08:38:56.311 --> 08:38:58.311
about different contract
factories in different pieces

8739
08:38:58.311 --> 08:39:00.311
and, and you'll see that in
action in a second. Now that

8740
08:39:00.311 --> 08:39:04.311
we're pulling in ethers, we can
actually immediately grab a

8741
08:39:04.311 --> 08:39:10.311
contract factory using ethers.
We can say const simple storage

8742
08:39:10.311 --> 08:39:22.311
factory equals await ethers dot
get contract. Factory simple

8743
08:39:22.311 --> 08:39:26.311
storage. So in order to get a
simple storage, contract

8744
08:39:26.311 --> 08:39:29.311
factory, we can just do await
ethers dot get contract factory.

8745
08:39:29.311 --> 08:39:33.311
Now if we pulled right from
ethers, the package ethers

8746
08:39:33.311 --> 08:39:35.311
doesn't know about this
contracts folder and ethers

8747
08:39:35.311 --> 08:39:38.311
doesn't know we've already
compiled simple storage dot

8748
08:39:38.311 --> 08:39:42.311
soul. And it's in our artifacts.
Hard Hat, on the other hand,

8749
08:39:42.311 --> 08:39:45.311
does know about the contracts
folder and does know that it's

8750
08:39:45.311 --> 08:39:48.311
already compiled, which is why
this simple storage factory

8751
08:39:48.311 --> 08:39:51.311
grabbing work so well. Once we
have our factory here, we can do

8752
08:39:51.311 --> 08:39:54.311
the same thing that we did in
our previous section and deploy

8753
08:39:54.311 --> 08:40:00.311
the contract. So we'll do a
quick console dot log. Deploy

8754
08:40:00.311 --> 08:40:06.311
flooring, contract done, and
then we'll do Kant's simple

8755
08:40:06.311 --> 08:40:17.311
storage equals await simple
store edge factory dot deploy

8756
08:40:17.311 --> 08:40:20.311
And boom, with that little bit
of code, we're already able to

8757
08:40:20.311 --> 08:40:25.311
deploy our simple storage
contract, then to wait to make

8758
08:40:25.311 --> 08:40:30.311
sure it gets deployed, we can do
await, simple storage, deployed.

8759
08:40:30.311 --> 08:40:33.312
And that's it. Now let's see
what happens when we go ahead

8760
08:40:33.312 --> 08:40:37.312
and run this deploy script. As
you know, in our last section,

8761
08:40:37.312 --> 08:40:40.312
we had to put in a private key,
and we had to put an RPC URL.

8762
08:40:40.312 --> 08:40:44.312
Right now, we don't have either
one of those defined. So what do

8763
08:40:44.312 --> 08:40:46.312
you think should the script
actually work? Or do you think

8764
08:40:46.312 --> 08:40:49.312
it'll break because we, we
didn't define what blockchain

8765
08:40:49.312 --> 08:40:52.312
we're going to deploy you. We
also didn't find a private key.

8766
08:40:52.312 --> 08:40:56.312
Well, let's go ahead and try
this out. We can run the script

8767
08:40:56.312 --> 08:41:04.312
in our terminal by running yarn,
hard hat, run, scripts slash

8768
08:41:04.312 --> 08:41:07.312
deploy dot j, s. And again, I'm
hitting tab here to do a little

8769
08:41:07.312 --> 08:41:11.312
auto completion and see what
happens. Well, we got deploying

8770
08:41:11.312 --> 08:41:15.312
contract, it says done, but
that's really it. So what really

8771
08:41:15.312 --> 08:41:18.312
happened? Well, let's add one
more line in here.

8772
08:41:18.312 --> 08:41:24.312
Let's do console dot log. We'll
do some string interpolation

8773
08:41:24.312 --> 08:41:31.312
deployed, contract to. And then
we'll add simple storage. That

8774
08:41:31.312 --> 08:41:36.312
address. Let's run this now. We
get deployed contract, and then

8775
08:41:36.312 --> 08:41:40.312
we get deployed contract to, and
then we get a contract address.

8776
08:41:40.312 --> 08:41:47.312
Hmm, what's going on here.
Hardhead has this fantastic tool

8777
08:41:47.312 --> 08:41:51.312
built in called The Hard Hat
Network hard hat comes built in

8778
08:41:51.312 --> 08:41:54.312
with Hard Hat Network, a local
Aetherium network node designed

8779
08:41:54.312 --> 08:41:58.312
for development, akin to
ganache, that allows you to

8780
08:41:58.312 --> 08:42:00.312
deploy your contracts and run
your tests and debug your code.

8781
08:42:00.312 --> 08:42:04.312
Whenever we run a command in
hard hat, or a script and hard

8782
08:42:04.312 --> 08:42:08.312
hat or a task and hard hat, we
by default deploy to this fake

8783
08:42:08.312 --> 08:42:11.313
Hard Hat Network. This Hard Hat
Network is very similar to

8784
08:42:11.313 --> 08:42:15.313
ganache, except for instead of
having this UI, it runs in the

8785
08:42:15.313 --> 08:42:18.313
background for our scripts. In
fact, if we go to our hard

8786
08:42:18.313 --> 08:42:22.313
hat.config.js, we can scroll
down to the bottom to this

8787
08:42:22.313 --> 08:42:26.313
module that exports section and
add more information about our

8788
08:42:26.313 --> 08:42:29.313
default networks. So right now,
if we don't have anything in

8789
08:42:29.313 --> 08:42:32.313
this module that export, by
default, it adds this piece

8790
08:42:32.313 --> 08:42:39.313
called default network hardhat.
So anytime we run a script,

8791
08:42:39.313 --> 08:42:42.313
without specifying a network, it
automatically uses this fake

8792
08:42:42.313 --> 08:42:45.313
Hard Hat Network. And this fake
Hard Hat Network comes

8793
08:42:45.313 --> 08:42:49.313
automatically with an RPC URL
and a private key for you. So

8794
08:42:49.313 --> 08:42:52.313
you don't even have to add one
in. This is one of the major

8795
08:42:52.313 --> 08:42:56.313
advantages of working with
Hardhead. It just automatically

8796
08:42:56.313 --> 08:42:59.313
gives you this fake blockchain.
And these fake private keys, if

8797
08:42:59.313 --> 08:43:02.313
you want to be a little bit more
explicit. And I always recommend

8798
08:43:02.313 --> 08:43:06.313
being more explicit, we can add
the default network in to the

8799
08:43:06.313 --> 08:43:09.313
module that are experts. So now
our default network is

8800
08:43:09.313 --> 08:43:13.313
explicitly stated as hard hat.
However, in any script, you run,

8801
08:43:13.313 --> 08:43:16.313
you can choose whatever network
you want to work with. So if I

8802
08:43:16.313 --> 08:43:20.313
want to explicitly say I want to
run our deploy script on our

8803
08:43:20.313 --> 08:43:25.313
fake Hard Hat Network, I can do
yarn, hard hat, run scripts,

8804
08:43:25.313 --> 08:43:31.313
deploy dot j s, dash dash
network, hard hat, this is us

8805
08:43:31.313 --> 08:43:34.313
telling her that, hey, we want
to run this script on the Hard

8806
08:43:34.313 --> 08:43:37.313
Hat Network. Hopefully, you
might be able to see where this

8807
08:43:37.313 --> 08:43:41.313
is going. Having this network
flag makes it incredibly easy to

8808
08:43:41.313 --> 08:43:44.313
switch across different chains,
different block chains,

8809
08:43:44.313 --> 08:43:48.313
different private keys, etc. So
we have our default network set

8810
08:43:48.313 --> 08:43:51.314
the hard hat here, we can add
other networks in here as well.

8811
08:43:51.314 --> 08:43:56.314
The way we do that is we're
going to add a networks section.

8812
08:43:56.314 --> 08:43:58.314
And we're going to define any of
the network sections that we

8813
08:43:58.314 --> 08:44:01.314
want. And remember to put a
comment there so that your

8814
08:44:01.314 --> 08:44:04.314
Visual Studio code doesn't get
mad at you. So recently, we

8815
08:44:04.314 --> 08:44:08.314
worked with Rigby so let's go
ahead and add a Rinkeby network

8816
08:44:08.314 --> 08:44:12.314
in here. So we're gonna say
another network is gonna be

8817
08:44:12.314 --> 08:44:16.314
really cool. So I should just be
able to change the network flag

8818
08:44:16.314 --> 08:44:24.314
to Rigby now, right? Well, not
quite. If you try to run that,

8819
08:44:24.314 --> 08:44:28.314
you're gonna get invalid value
undefined for hardhat config

8820
08:44:28.314 --> 08:44:32.314
networks. Rigby, that URL, it's
expecting you to tell it, hey,

8821
08:44:32.314 --> 08:44:35.314
what the URL is, since this
isn't the hard hat network, we

8822
08:44:35.314 --> 08:44:38.314
need to tell hard hat exactly
how we're going to connect to

8823
08:44:38.314 --> 08:44:41.314
rink B. And this is where a lot
of what we learned before is

8824
08:44:41.314 --> 08:44:44.314
going to come in handy, again,
exactly the same as what we did

8825
08:44:44.314 --> 08:44:48.314
before. We're going to create a
new Dotty v file, and we're

8826
08:44:48.314 --> 08:44:52.314
going to add our Rigby URL in
this dot env file. Just

8827
08:44:52.314 --> 08:44:56.314
remember, dot env is an r dot
get ignore just in case. So in

8828
08:44:56.314 --> 08:44:59.314
our Dotty env, we're going to
add that RPC URL from alcmi back

8829
08:44:59.314 --> 08:45:04.314
in here before we just said RPC
URL. But since we might want to

8830
08:45:04.314 --> 08:45:07.314
work across multiple networks,
it's usually good to specify

8831
08:45:07.314 --> 08:45:12.314
exactly what network each URL
stands for. So we're gonna say

8832
08:45:12.314 --> 08:45:18.314
Rynkeby RPC URL equals and then
paste that URL in here. Now, as

8833
08:45:18.314 --> 08:45:22.314
you probably have guessed, we
can add our URL to our Rinkeby

8834
08:45:22.314 --> 08:45:25.314
network here. for readability, I
usually like to add them as

8835
08:45:25.314 --> 08:45:29.314
variables right above the module
that experts. So I'll say const

8836
08:45:29.314 --> 08:45:40.315
Rynkeby. RPC URL equals process
dot E and V dot Rynkeby RPC URL.

8837
08:45:40.315 --> 08:45:44.315
And once again, we're going to
be pulling that Rinckey RPC URL

8838
08:45:44.315 --> 08:45:47.315
from our environment variable.
Of course, in order to pull that

8839
08:45:47.315 --> 08:45:50.315
environment variable in, we're
going to need to use that dot

8840
08:45:50.315 --> 08:45:54.315
env package again. So to add
that in, we're going to yarn add

8841
08:45:54.315 --> 08:46:00.315
dash dash dev dot EMV. And at
the top of our Hardhead config,

8842
08:46:00.315 --> 08:46:08.315
we're going to add require dot
EMV, and then do dot config to

8843
08:46:08.315 --> 08:46:11.315
enable the config. Now this
means we should be able to pull

8844
08:46:11.315 --> 08:46:15.315
our rink the RPC URL from our
dot env. Now that we have that

8845
08:46:15.315 --> 08:46:21.315
in our Rinkeby network, we can
add URL Rinckey RPC URL.

8846
08:46:21.315 --> 08:46:24.315
Awesome. So we have an RPC URL
for different network. But what

8847
08:46:24.315 --> 08:46:27.315
else do we usually need? Well,
we usually need a private key to

8848
08:46:27.315 --> 08:46:30.315
work with an actual network, or
that doesn't automatically give

8849
08:46:30.315 --> 08:46:33.315
us a private key for rugby,
because Hardhead can't just give

8850
08:46:33.315 --> 08:46:36.315
us test and the Etherium, we
need to have an actual account

8851
08:46:36.315 --> 08:46:40.315
an actual test nets. Hardhead
doesn't control those. So we

8852
08:46:40.315 --> 08:46:43.315
have to actually give it a real
URL and a real private key. So

8853
08:46:43.315 --> 08:46:46.315
to add private keys, you
actually add something called

8854
08:46:46.315 --> 08:46:50.315
accounts, you add a list of
accounts that you want to give

8855
08:46:50.315 --> 08:46:53.315
to hard hat for us, we're only
going to add one, which is going

8856
08:46:53.315 --> 08:46:55.315
to be our private key. And for
our private key, we're going to

8857
08:46:55.315 --> 08:46:59.315
do the exact same thing. We're
gonna say const private key

8858
08:46:59.315 --> 08:47:05.315
equals process dot e NV dot
private key. And since this

8859
08:47:05.315 --> 08:47:09.315
private key is going to be a
real private key for a real test

8860
08:47:09.315 --> 08:47:12.316
net, again, we are going to have
to grab this from our meta mask.

8861
08:47:12.316 --> 08:47:15.316
So it will go to our meta mask,
three dots, account details,

8862
08:47:15.316 --> 08:47:20.316
export private key, and we'll
add our password in here.

8863
08:47:20.316 --> 08:47:25.316
And then in our dot env will add
private key equals and then add

8864
08:47:25.316 --> 08:47:28.316
our private key. Now I know I've
said this 100 times, but please,

8865
08:47:28.316 --> 08:47:33.316
please, please, for learning
this, do not use a real key that

8866
08:47:33.316 --> 08:47:37.316
is connected to any real money
just in case, please use a new

8867
08:47:37.316 --> 08:47:40.316
meta mask. I've know I've said
it a bunch. But some people go

8868
08:47:40.316 --> 08:47:43.316
no, I'm going to be okay, I'll
be safe. Just to be super, super

8869
08:47:43.316 --> 08:47:47.316
safe here, please use a brand
new meta mask. So now that we

8870
08:47:47.316 --> 08:47:50.316
have a private key, we're going
to add it in here account

8871
08:47:50.316 --> 08:47:53.316
private key. And now we have an
account here. One more thing I

8872
08:47:53.316 --> 08:47:58.316
like to do is I like to give the
chain ID of the network, which

8873
08:47:58.316 --> 08:48:02.316
for Rigby is going to be for
every single EVM base network as

8874
08:48:02.316 --> 08:48:06.316
a new chain ID and EVM network
basically just means solidity

8875
08:48:06.316 --> 08:48:10.316
works on it. This includes all
test nets, there's a good site

8876
08:48:10.316 --> 08:48:13.316
called chainless.org, which may
or may not be going down at some

8877
08:48:13.316 --> 08:48:16.316
point, it has a list of all
these different networks. For

8878
08:48:16.316 --> 08:48:19.316
example, you can see on here a
theory main net has a chain ID

8879
08:48:19.316 --> 08:48:24.316
of one byte and smart chain is
56, avalanches, 4311 for

8880
08:48:24.316 --> 08:48:29.316
Phantom, opera 250, Polygon,
137, etc. Each one of these EVM

8881
08:48:29.316 --> 08:48:33.316
compatible chains has their own
chain ID, rank V, the chain ID

8882
08:48:33.316 --> 08:48:38.316
is for adding the chain ID is
helpful here for later on. And

8883
08:48:38.316 --> 08:48:40.316
we'll get to that in the future.
But for now, just go ahead and

8884
08:48:40.316 --> 08:48:43.316
make sure to add your chain IDs.
Okay, now that we have the RPC

8885
08:48:43.316 --> 08:48:47.316
URL, we have the private key, we
can go ahead and test deploying

8886
08:48:47.316 --> 08:48:51.316
this to an actual test net, and
actually did something incorrect

8887
08:48:51.316 --> 08:48:54.317
here. And we're gonna get an
error here. And I want you to go

8888
08:48:54.317 --> 08:48:58.317
ahead and try to figure out and
debug this error yourself.

8889
08:48:58.317 --> 08:49:03.317
You're ready. Alright, let's do
it. We'll do yarn, hard hat, run

8890
08:49:03.317 --> 08:49:11.317
scripts, deploy dot j s, dash
dash network Rinkeby. And we get

8891
08:49:11.317 --> 08:49:16.317
this wonderfully weird error,
which we see we have deployed

8892
08:49:16.317 --> 08:49:20.317
contract. So we know that in our
deploy script, we get to at

8893
08:49:20.317 --> 08:49:23.317
least this line, but then we're
getting an error, I highly

8894
08:49:23.317 --> 08:49:26.317
likely hear what's going on
saying cannot read properties

8895
08:49:26.317 --> 08:49:30.317
have no reading send
transaction, if you want, you

8896
08:49:30.317 --> 08:49:33.317
can absolutely go to this spot.
But it basically it looks like

8897
08:49:33.317 --> 08:49:36.317
it's having a hard time
understanding what the private

8898
08:49:36.317 --> 08:49:40.317
key or what the account of this
is. And what do you think I'm

8899
08:49:40.317 --> 08:49:43.317
going to recommend we do? Well,
if it's not clear, after doing a

8900
08:49:43.317 --> 08:49:46.317
little bit of triaging and
debugging, we're going to copy

8901
08:49:46.317 --> 08:49:49.317
this air. And we're going to
come on over to Google and paste

8902
08:49:49.317 --> 08:49:54.317
that right in. It looks like we
do get a question here from

8903
08:49:54.317 --> 08:49:57.317
stackexchange Etherium. And it
looks like it's really similar

8904
08:49:57.317 --> 08:50:01.317
to what we're doing. We scroll
down. They're running nearly the

8905
08:50:01.317 --> 08:50:04.317
exact same script that we're
running, they're using MPX

8906
08:50:04.317 --> 08:50:08.317
instead of yarn. They've got a
pretty minimalistic deploy file.

8907
08:50:08.317 --> 08:50:11.317
Let's scroll down and see what
the answers have to say. I've

8908
08:50:11.317 --> 08:50:14.317
seen this error where my private
key wasn't properly populated. I

8909
08:50:14.317 --> 08:50:17.317
would also use an environment
variable I'm pretty sure Are

8910
08:50:17.317 --> 08:50:20.317
environment variables good. But
we have a second one saying in

8911
08:50:20.317 --> 08:50:24.317
your heart head, I can think
that Jas, it should be accounts

8912
08:50:24.317 --> 08:50:27.317
instead of account, it works for
me, let's go back to our head

8913
08:50:27.317 --> 08:50:32.318
config and see if that's what's
going on. Uh huh, we put account

8914
08:50:32.318 --> 08:50:34.318
in this should be accounts. So
let's swap that over to

8915
08:50:34.318 --> 08:50:37.318
accounts. We'll clear our
terminal. And we'll run this

8916
08:50:37.318 --> 08:50:41.318
again. Uh huh. And now it's
reading a little bit longer,

8917
08:50:41.318 --> 08:50:44.318
which is good. This means that
we're probably deploying this to

8918
08:50:44.318 --> 08:50:47.318
rink B, which is what we want to
see. Awesome. And now we can see

8919
08:50:47.318 --> 08:50:51.318
deployed contract to, and we
have a contract address here. So

8920
08:50:51.318 --> 08:50:54.318
we'll grab this contract. And
we'll pop on over to bring the

8921
08:50:54.318 --> 08:50:57.318
ether scan, that's numbering the
ether scan. And we'll go ahead

8922
08:50:57.318 --> 08:51:00.318
and we'll paste this in.
Awesome. And we see our contract

8923
08:51:00.318 --> 08:51:04.318
was created about 26 seconds
ago. Perfect. Now for this part,

8924
08:51:04.318 --> 08:51:07.318
you don't have to deploy this to
rink be with me, if you follow

8925
08:51:07.318 --> 08:51:10.318
along here. That's good enough.
So remember, the flying to test

8926
08:51:10.318 --> 08:51:13.318
that's can take a long time. So
for this one, you don't have to

8927
08:51:13.318 --> 08:51:19.318
deploy with me. Alright, great.
So we've deployed to rink be

8928
08:51:19.318 --> 08:51:22.318
using hard hat. This is
fantastic. Now something that we

8929
08:51:22.318 --> 08:51:26.318
notice, once again is oof, our
contract isn't verified? Do we

8930
08:51:26.318 --> 08:51:29.318
have to go back through and do
this verify and publish and all

8931
08:51:29.318 --> 08:51:33.318
that stuff again? Luckily for
us, we actually don't need to do

8932
08:51:33.318 --> 08:51:36.318
that. So what can we do? Well,
back in our deploy script, we

8933
08:51:36.318 --> 08:51:40.318
can add some code to
automatically verify right after

8934
08:51:40.318 --> 08:51:43.318
we deploy. So let's go ahead and
do that. Right below our main

8935
08:51:43.318 --> 08:51:47.318
function, we're gonna create a
new function called verify,

8936
08:51:47.318 --> 08:51:52.318
we're gonna say async function,
verify. And we're gonna have

8937
08:51:52.318 --> 08:51:55.318
this function get past some
arguments, we're gonna have to

8938
08:51:55.318 --> 08:52:00.318
get past a contract, address,
and some arguments or the

8939
08:52:00.318 --> 08:52:02.318
contract. Since our simple
storage doesn't have a

8940
08:52:02.318 --> 08:52:05.318
constructor, the arguments for
simple storage are just gonna be

8941
08:52:05.318 --> 08:52:09.318
blank. But in the future, when
we have contracts that do have

8942
08:52:09.318 --> 08:52:12.319
constructors, the arguments are
going to be populated. And when

8943
08:52:12.319 --> 08:52:15.319
we get there, you'll see what I
mean, we need at least the

8944
08:52:15.319 --> 08:52:18.319
contract address, and we're
going to add some code in here

8945
08:52:18.319 --> 08:52:20.319
to automatically verify our
contracts after they've been

8946
08:52:20.319 --> 08:52:25.319
deployed. This auto verification
process works on block explorers

8947
08:52:25.319 --> 08:52:28.319
like ether scan, it might not
work on block explorers like

8948
08:52:28.319 --> 08:52:31.319
eath, pler, or other block
explorers. But if you want to

8949
08:52:31.319 --> 08:52:33.319
verify on these other block
explorers, I'm sure they have an

8950
08:52:33.319 --> 08:52:37.319
API to allow you to do that as
well. Now, ether scan in most

8951
08:52:37.319 --> 08:52:41.319
other block explorers have a
section on their website called

8952
08:52:41.319 --> 08:52:45.319
API documentation, or something
to do with API's. These are ways

8953
08:52:45.319 --> 08:52:48.319
for us to programmatically
interact with ether scan, and do

8954
08:52:48.319 --> 08:52:51.319
stuff with them. One of the main
things that we can do is we can

8955
08:52:51.319 --> 08:52:56.319
actually verify our contracts
through this API. Ether scan

8956
08:52:56.319 --> 08:52:59.319
even has a tutorial in here
called verifying contracts

8957
08:52:59.319 --> 08:53:01.319
programmatically. And the link
to this will be in the GitHub

8958
08:53:01.319 --> 08:53:04.319
repo, they have an API endpoint
that we can make some requests

8959
08:53:04.319 --> 08:53:08.319
to to go ahead and verify our
contracts. Now, we could

8960
08:53:08.319 --> 08:53:11.319
absolutely make the raw API
calls and follow the tutorial

8961
08:53:11.319 --> 08:53:14.319
here. But there's actually an
easier way than even going

8962
08:53:14.319 --> 08:53:17.319
through this tutorial here.
Hardhead is an extensible

8963
08:53:17.319 --> 08:53:21.319
framework, meaning you can add
something called plugins to it.

8964
08:53:21.319 --> 08:53:24.319
There's even an advanced section
in the documentation called

8965
08:53:24.319 --> 08:53:27.319
Building plugins. If we scroll
down to the bottom, we can see

8966
08:53:27.319 --> 08:53:31.319
some popular plugins that the
nomic labs team or the Hardhead

8967
08:53:31.319 --> 08:53:34.319
team has created. And also a
number of community plugins as

8968
08:53:34.319 --> 08:53:36.319
well. One of the most used
Hardhead plugins is going to be

8969
08:53:36.319 --> 08:53:40.319
this hard hat ether scan plugin
that makes this verification

8970
08:53:40.319 --> 08:53:44.319
process much, much easier.
Install it, you can just run npm

8971
08:53:44.319 --> 08:53:48.319
install bash, just save dev at
nomic labs harden ether scan,

8972
08:53:48.319 --> 08:53:51.319
and then add it to our hard hat
dot config. Since we're using

8973
08:53:51.319 --> 08:53:54.320
yarn, we're just going to go
ahead and use yarn. So back in

8974
08:53:54.320 --> 08:54:02.320
our code, we'll do yarn, add
dash dash Dev, at nomic, labs,

8975
08:54:02.320 --> 08:54:08.320
slash hard hat slash hyphen,
ether scan. Now that we have

8976
08:54:08.320 --> 08:54:12.320
this plugin, we can go to our
hard hat dot config, scroll to

8977
08:54:12.320 --> 08:54:22.320
the top and add this plugin do
require at nomic labs slash hard

8978
08:54:22.320 --> 08:54:26.320
hat, ether scan. Now that we
have this plugin, the hard hat

8979
08:54:26.320 --> 08:54:29.320
documentation has some more
information about the usage, how

8980
08:54:29.320 --> 08:54:33.320
to actually use this plugin, and
how to run different commands

8981
08:54:33.320 --> 08:54:36.320
with it. In order for us to use
this verification, we actually

8982
08:54:36.320 --> 08:54:40.320
need an API key from ether scan.
This is basically a password for

8983
08:54:40.320 --> 08:54:44.320
allowing us to use the ether
scan API. So we're going to come

8984
08:54:44.320 --> 08:54:47.320
to ether scan. And we're going
to go ahead and sign in. And

8985
08:54:47.320 --> 08:54:51.320
actually we're going to click to
sign up and create an account.

8986
08:54:51.320 --> 08:54:54.320
And we'll go ahead and create an
account. We'll go ahead and

8987
08:54:54.320 --> 08:54:57.320
verify our registration by
clicking the verification link.

8988
08:54:57.320 --> 08:55:00.320
And we'll click the Login. Now
that we're logged in. On the

8989
08:55:00.320 --> 08:55:03.320
left hand side, we can scroll
down to API keys. And we can go

8990
08:55:03.320 --> 08:55:09.320
ahead and create a new API key.
We call this H H hyphen sec,

8991
08:55:09.320 --> 08:55:12.320
which stands for hardhat Free
Code Camp. Great, this new API

8992
08:55:12.320 --> 08:55:16.320
key will copy this and we'll go
back to our code and we'll add

8993
08:55:16.320 --> 08:55:18.320
this somewhere since the API
keys basically considered a

8994
08:55:18.320 --> 08:55:21.320
password. Where do you think we
should add this? That's right in

8995
08:55:21.320 --> 08:55:25.320
our dot env. So in our dot env,
we're going to add a new entry

8996
08:55:25.320 --> 08:55:31.320
called ether scan API key. And
we're going to add that API key

8997
08:55:31.320 --> 08:55:34.321
that we just got. Now that we
have our API key, back in our

8998
08:55:34.321 --> 08:55:38.321
Hardhead, config, we're going to
create a new section in a module

8999
08:55:38.321 --> 08:55:42.321
dot exports, tell hardhat that
we have this ether scan API key,

9000
08:55:42.321 --> 08:55:46.321
or new section is going to be
called ether scan.

9001
08:55:46.321 --> 08:55:50.321
And in here, we're gonna say API
key is going to be ether scan

9002
08:55:50.321 --> 08:55:55.321
API key that we're going to
define up here the same way we

9003
08:55:55.321 --> 08:55:59.321
define these other keys. So
we'll say const, ether scan API

9004
08:55:59.321 --> 08:56:05.321
key equals process dot e NV dot
ether scan API key. And if

9005
08:56:05.321 --> 08:56:08.321
something like this pops up, you
can generally just hit enter,

9006
08:56:08.321 --> 08:56:12.321
and it will autocomplete it for
you, which is awesome. Great. So

9007
08:56:12.321 --> 08:56:14.321
now we have an ether scan API
key back in the heart had

9008
08:56:14.321 --> 08:56:18.321
documentation, it tells us by
adding this, we actually get a

9009
08:56:18.321 --> 08:56:22.321
new task called verify. Let's
try that out. So open our

9010
08:56:22.321 --> 08:56:27.321
terminal back up. And we'll do
yarn, RT hat. Let's see what

9011
08:56:27.321 --> 08:56:32.321
pops up. Wow, we did get a new
verification here. When we run

9012
08:56:32.321 --> 08:56:35.321
yarn hard hat harder, it
actually looks into our hard

9013
08:56:35.321 --> 08:56:38.321
hat.config.js and checks for any
plugins. If there are new

9014
08:56:38.321 --> 08:56:42.321
plugins there, it'll add them as
a new task that we can do. You

9015
08:56:42.321 --> 08:56:46.321
can manually verify your
contract by doing yarn or MPX

9016
08:56:46.321 --> 08:56:50.321
Harnett verify dash dash
network, the deployed contract

9017
08:56:50.321 --> 08:56:53.321
address and any constructor
arguments yourself. But we want

9018
08:56:53.321 --> 08:56:56.321
to be a little bit more
programmatic than this. So what

9019
08:56:56.321 --> 08:56:58.321
we're going to do is we're going
to go back and create this

9020
08:56:58.321 --> 08:57:01.321
verification function, it is
good to know how to do it via

9021
08:57:01.321 --> 08:57:03.321
command line so that if you want
to verify something in the

9022
08:57:03.321 --> 08:57:07.321
future, manually, you can, let's
build this verify function

9023
08:57:07.321 --> 08:57:10.321
though. So we're going to take
the our contract address and

9024
08:57:10.321 --> 08:57:13.322
some arguments. And for our
sake, we're going to do console

9025
08:57:13.322 --> 08:57:18.322
dot log verifying contract that
that just so that we know we

9026
08:57:18.322 --> 08:57:22.322
might have to wait for a little
bit. And in our code, we can

9027
08:57:22.322 --> 08:57:28.322
actually run any task from hard
hat using a run package. So up

9028
08:57:28.322 --> 08:57:32.322
at the top, we're actually going
to import run from hard hat as

9029
08:57:32.322 --> 08:57:37.322
well run allows us to run any
hard hat task. So in our code

9030
08:57:37.322 --> 08:57:43.322
here, we're going to do a wait
to run. And then we can do there

9031
08:57:43.322 --> 08:57:46.322
it thought. Now part of that
allows you to add different

9032
08:57:46.322 --> 08:57:49.322
parameters as well in this run.
And it's usually best that you

9033
08:57:49.322 --> 08:57:52.322
go ahead and add them in here so
that we're really specific with

9034
08:57:52.322 --> 08:57:58.322
what we're doing. If we do yarn
hardhat verify dash dash help,

9035
08:57:58.322 --> 08:58:01.322
we can see what parameters we
can actually pass. Well, it

9036
08:58:01.322 --> 08:58:04.322
looks like we can pass the
Verify parameter. So we'll do

9037
08:58:04.322 --> 08:58:08.322
colon, verify. If you go to the
actual GitHub for the

9038
08:58:08.322 --> 08:58:11.322
verification tasks, you can
actually see you can do more

9039
08:58:11.322 --> 08:58:14.322
than just verify, you can do
verify, get minimum build,

9040
08:58:14.322 --> 08:58:17.322
verify, get constructor
arguments, verify, verify, which

9041
08:58:17.322 --> 08:58:19.322
is what we're going to be
working with, and a couple of

9042
08:58:19.322 --> 08:58:23.322
other subtasks as well. The
second parameter that goes

9043
08:58:23.322 --> 08:58:26.322
inside run is going to be a list
of actual parameters. This

9044
08:58:26.322 --> 08:58:28.322
second parameter here is just
kind of the sub task, if you

9045
08:58:28.322 --> 08:58:32.322
will, of our verify task. And
this is going to be an object

9046
08:58:32.322 --> 08:58:34.322
that contains the actual
parameters. And this is where we

9047
08:58:34.322 --> 08:58:40.322
pass in an address, which is
going to be our contract

9048
08:58:40.322 --> 08:58:47.322
address, and then our construct
or arguments, which is going to

9049
08:58:47.322 --> 08:58:52.322
be arcs. Now normally just this
right here should be enough for

9050
08:58:52.322 --> 08:58:55.323
us to go ahead and use this
verify contract in our main

9051
08:58:55.323 --> 08:58:58.323
function, but we're going to add
one additional thing to it.

9052
08:58:58.323 --> 08:59:00.323
Because in practice, sometimes
there's some errors that can

9053
08:59:00.323 --> 08:59:03.323
come up. One of the errors that
often comes up when running a

9054
08:59:03.323 --> 08:59:05.323
wait is that the contract has
already been verified. And

9055
08:59:05.323 --> 08:59:08.323
you'll actually likely run into
this, because ether scan will

9056
08:59:08.323 --> 08:59:11.323
get smart enough by seeing
enough bytecode that is exactly

9057
08:59:11.323 --> 08:59:14.323
simple storage that it will
start to just automatically

9058
08:59:14.323 --> 08:59:17.323
verify any bytecode that looks
like simple storage. And then

9059
08:59:17.323 --> 08:59:21.323
this await will throw an error,
which we want to avoid. So what

9060
08:59:21.323 --> 08:59:27.323
we can do is we can add a try
catch onto this await. So

9061
08:59:27.323 --> 08:59:30.323
outside of the way, we're going
to add a try. And we're going to

9062
08:59:30.323 --> 08:59:34.323
add these little brackets that
wrap around our weight. And then

9063
08:59:34.323 --> 08:59:40.323
we're going to put a catch. This
is known as a try, catch and

9064
08:59:40.323 --> 08:59:44.323
solidity also has tried catches.
But basically, this e is going

9065
08:59:44.323 --> 08:59:47.323
to be any error that this
section throws. So we're going

9066
08:59:47.323 --> 08:59:51.323
to do is we're going to say if
this message is already

9067
08:59:51.323 --> 08:59:53.323
verified, then we're just going
to continue. So we're gonna say

9068
08:59:53.323 --> 09:00:00.323
if e.message.to lowercase, we're
going to make sure it's to

9069
09:00:00.323 --> 09:00:06.323
lowercase that includes already
there. If five, then we're just

9070
09:00:06.323 --> 09:00:11.323
going to console dot log already
verified

9071
09:00:11.323 --> 09:00:16.323
like that. Otherwise, we're just
going to console dot log e. The

9072
09:00:16.323 --> 09:00:20.323
reason we do This is because of
this errors, our verification

9073
09:00:20.323 --> 09:00:23.323
function will break, and our
whole script will end. And we

9074
09:00:23.323 --> 09:00:25.323
don't want our whole script to
end, we want our script to keep

9075
09:00:25.323 --> 09:00:28.323
continuing if the verification
doesn't work, because it's not

9076
09:00:28.323 --> 09:00:30.323
really a big deal. So I know
this might seem like a lot of

9077
09:00:30.323 --> 09:00:34.324
code, feel free to copy and
paste it from the GitHub repo to

9078
09:00:34.324 --> 09:00:38.324
just move along. But awesome. So
we now have a verify function

9079
09:00:38.324 --> 09:00:42.324
using the Verify task in
hardhat. Let's go ahead and use

9080
09:00:42.324 --> 09:00:45.324
this now in our main function,
right below our deploy, we'll do

9081
09:00:45.324 --> 09:00:48.324
console dot log deployed
contract two, and then the

9082
09:00:48.324 --> 09:00:51.324
contract address. But before we
call this main function, let's

9083
09:00:51.324 --> 09:00:57.324
think for a quick second. What
happens when we deploy to our RT

9084
09:00:57.324 --> 09:01:01.324
Hat Network? Well, remember, if
we deploy to our Hard Hat

9085
09:01:01.324 --> 09:01:04.324
Network, will our contract need
to be verified I need to scan?

9086
09:01:04.324 --> 09:01:08.324
Well, we know there's a we know
there's a rink ether scan, we

9087
09:01:08.324 --> 09:01:10.324
know there's a COVID ether scan,
we know there's a main net easy

9088
09:01:10.324 --> 09:01:14.324
scan. But is there a Hardhead
ether scan? No, of course not.

9089
09:01:14.324 --> 09:01:18.324
Right? The hard at runtime
environment is a network local

9090
09:01:18.324 --> 09:01:21.324
to our machine. So it doesn't
make sense for us to verify a

9091
09:01:21.324 --> 09:01:24.324
hard hat network deployed
contract on ether scan. So we

9092
09:01:24.324 --> 09:01:28.324
actually don't want to call this
verify function, when we're

9093
09:01:28.324 --> 09:01:31.324
working with our local network.
This is where these chain IDs

9094
09:01:31.324 --> 09:01:34.324
are going to come in quite
useful. What we can do is we can

9095
09:01:34.324 --> 09:01:37.324
check to see if the network that
we're running on is a live

9096
09:01:37.324 --> 09:01:40.324
network or it's a test net, or
it's a network that actually can

9097
09:01:40.324 --> 09:01:42.324
be verified, we can actually get
network configuration

9098
09:01:42.324 --> 09:01:49.324
information by importing a
network like this. And we can do

9099
09:01:49.324 --> 09:01:56.324
something like console dot log
network dot config. Now, if I

9100
09:01:56.324 --> 09:02:01.324
run yarn, art, hit run scripts
deploy.js. On our Hard Hat

9101
09:02:01.324 --> 09:02:05.324
Network, since I'm not passing a
network flag, we get this

9102
09:02:05.324 --> 09:02:09.324
massive output that looks like
this. Our network dot config

9103
09:02:09.324 --> 09:02:12.324
contains a ton of information
about the current network that

9104
09:02:12.324 --> 09:02:15.325
we're on, you'll see here that
the chain ID of the Hardhead

9105
09:02:15.325 --> 09:02:20.325
network is actually 31337 gas
price, which gets set to auto

9106
09:02:20.325 --> 09:02:23.325
block gas limit the current fork
of Aetherium that we're working

9107
09:02:23.325 --> 09:02:27.325
with, and all these other pieces
here. This chain ID is really

9108
09:02:27.325 --> 09:02:30.325
important. Because we can use
this chain ID to figure out

9109
09:02:31.325 --> 09:02:33.325
which one is a test net, or
which one is a live network. And

9110
09:02:33.325 --> 09:02:36.325
remember, running the script is
going to be the same as doing

9111
09:02:36.325 --> 09:02:40.325
dash dash network, hard hat,

9112
09:02:40.325 --> 09:02:44.325
you'll see our channel ID is
still 31337. Again, that's

9113
09:02:44.325 --> 09:02:47.325
because the default network in
our heart had config, it's hard

9114
09:02:47.325 --> 09:02:51.325
hat, which is the same as saying
every single time we run a

9115
09:02:51.325 --> 09:02:54.325
script, we're secretly running
it with dash dash network hard

9116
09:02:54.325 --> 09:02:57.325
hat. So now we only want to
verify on our test net. So what

9117
09:02:57.325 --> 09:03:02.325
we can do is we can say if
network dot config, that chain

9118
09:03:02.325 --> 09:03:08.325
ID equals equals equals four,
which is going to be rank B, ad.

9119
09:03:08.325 --> 09:03:12.325
And a JavaScript equals equals
equals is nearly the same as

9120
09:03:12.325 --> 09:03:15.325
equals equals, except no type
conversion is done, which just

9121
09:03:15.325 --> 09:03:21.325
means in JavaScript, four equals
four, and four equals equals the

9122
09:03:21.325 --> 09:03:26.325
string of four, but four, but if
you were to use four equals

9123
09:03:26.325 --> 09:03:30.325
equals equals four, this is
false. This is true equals

9124
09:03:30.325 --> 09:03:34.325
equals four equals equals would
be true, four equals equals to

9125
09:03:34.325 --> 09:03:38.325
the string of four would also be
true, but four equals equals

9126
09:03:38.325 --> 09:03:41.325
equals to the string of four is
going to be false. So you can

9127
09:03:41.325 --> 09:03:43.325
kind of do whatever you want
here equals equals or equals

9128
09:03:43.325 --> 09:03:46.325
equals equals. So we want to say
if the network dot config dot

9129
09:03:46.325 --> 09:03:52.325
Trinity is four, so if we're on
Rinkeby, then we can go ahead

9130
09:03:52.325 --> 09:03:57.326
and actually verify. But we also
want to make sure we only verify

9131
09:03:57.326 --> 09:04:01.326
if our ether scan API key
exists. So we can also in here

9132
09:04:01.326 --> 09:04:05.326
is site and this double
ampersand means and we can say

9133
09:04:05.326 --> 09:04:12.326
process dot e NV dot ether scan
API key. This is some Boolean

9134
09:04:12.326 --> 09:04:15.326
tricks that we're doing here,
basically, so our first

9135
09:04:15.326 --> 09:04:18.326
conditional we're saying if
network dot config chinati

9136
09:04:18.326 --> 09:04:22.326
equals equals equals four, this
section can be true or false,

9137
09:04:22.326 --> 09:04:25.326
obviously, right? The chain ID
that we're running on can be the

9138
09:04:25.326 --> 09:04:28.326
hardest network, which would
mean this doesn't equal four, or

9139
09:04:28.326 --> 09:04:31.326
it would be Rinckey, which means
this does equal four. But

9140
09:04:31.326 --> 09:04:34.326
there's no conditional on this
side. So how does this side

9141
09:04:34.326 --> 09:04:37.326
work? In JavaScript, if an
object exists, and you try to

9142
09:04:37.326 --> 09:04:41.326
cast it as a Boolean, it will be
converted to true. If it doesn't

9143
09:04:41.326 --> 09:04:44.326
exist, it will be converted to
false. So in JavaScript,

9144
09:04:44.326 --> 09:04:49.326
basically, if either scan API
key exists, if we have this in

9145
09:04:49.326 --> 09:04:53.326
our data in VI, this will be
true. And if not, this will be

9146
09:04:53.326 --> 09:04:57.326
false. So another way to read
this line here is saying if

9147
09:04:57.326 --> 09:05:01.326
network dot config that Trinity
is for AKA, if we're on rink B,

9148
09:05:01.326 --> 09:05:07.326
and our ether scan API key
exists, then do some stuff. And

9149
09:05:07.326 --> 09:05:09.326
that's what we're going to do
here. So in here, we'd want to

9150
09:05:09.326 --> 09:05:15.326
run verify, or verify function
and pass it the contract address

9151
09:05:15.326 --> 09:05:20.326
which is going to be Simple
Storage dot address and the

9152
09:05:20.326 --> 09:05:23.326
constructor arguments which we
know are going to be blank. And

9153
09:05:23.326 --> 09:05:27.326
since our verify function is an
async function, and it deals

9154
09:05:27.326 --> 09:05:31.326
with promises and stuff, we want
to add the await keyword here.

9155
09:05:31.326 --> 09:05:34.327
Awesome. So we've added a way to
actually verify our contract.

9156
09:05:34.327 --> 09:05:38.327
But we're not quite done. See on
ether scan and all these block

9157
09:05:38.327 --> 09:05:42.327
explorers the instant we deploy
the contract and the instant we

9158
09:05:42.327 --> 09:05:46.327
send the contract, ether scan
might not know about the

9159
09:05:46.327 --> 09:05:50.327
transaction yet, it might take a
hot second for ether scan to be

9160
09:05:50.327 --> 09:05:53.327
up to speed with where the
blockchain is. So it's usually

9161
09:05:53.327 --> 09:05:57.327
best practice to wait for a few
blocks to be mined, until you

9162
09:05:57.327 --> 09:06:00.327
actually run your verification
process. We've actually learned

9163
09:06:00.327 --> 09:06:03.327
how to do this already with the
deploy transaction. So before we

9164
09:06:04.327 --> 09:06:10.327
actually verify we run, we want
to run a weight, simple storage.

9165
09:06:10.327 --> 09:06:19.327
Deploy transaction Wait, six. So
we will wait six blocks, and

9166
09:06:19.327 --> 09:06:22.327
then we'll run our verification
process. Now, if you want to go

9167
09:06:22.327 --> 09:06:25.327
and test this out right now, you
absolutely can. I'm going to

9168
09:06:25.327 --> 09:06:28.327
keep going, though, because
again, testing all these on a

9169
09:06:28.327 --> 09:06:31.327
test net takes a little bit of
extra time. So I'm going to

9170
09:06:31.327 --> 09:06:34.327
finish the rest of our main
function, and then I'm going to

9171
09:06:34.327 --> 09:06:39.327
run everything all together.
Okay, cool. So we've deployed

9172
09:06:39.327 --> 09:06:42.327
our contract, we've
automatically programmatically

9173
09:06:42.327 --> 09:06:46.327
verified our contract. What's
next? Well, what did we do last

9174
09:06:46.327 --> 09:06:50.327
time, we started interacting
with the contract. So let's do

9175
09:06:50.327 --> 09:06:56.327
const. Current Value equals
await simple storage dot

9176
09:06:56.327 --> 09:07:01.327
retrieve. To get the current
value, simple storage, that's

9177
09:07:01.327 --> 09:07:05.327
all. We have a retrieve
function, which returns the

9178
09:07:05.327 --> 09:07:09.327
favorite number, so let's get
the current value. And we'll do

9179
09:07:09.327 --> 09:07:18.328
console dot log, the current
value is and then some string

9180
09:07:18.328 --> 09:07:23.328
interpolation, current value.
And then we'll go ahead and

9181
09:07:23.328 --> 09:07:31.328
update the current value by
doing cons. Transaction response

9182
09:07:31.328 --> 09:07:39.328
equals await simple storage,
that store will store the number

9183
09:07:39.328 --> 09:07:45.328
seven, and then we'll await
transaction response dot Wait,

9184
09:07:45.328 --> 09:07:49.328
we'll wait one block for that
transaction to go through. And

9185
09:07:49.328 --> 09:07:54.328
we'll grab the updated value by
saying const updated value

9186
09:07:54.328 --> 09:07:58.328
equals await simple storage

9187
09:07:58.328 --> 09:08:11.328
dot retrieve. Then we'll do
console log. The added value is

9188
09:08:11.328 --> 09:08:15.328
updated value. Awesome. And this
is going to be our whole script.

9189
09:08:15.328 --> 09:08:17.328
So if I can zoom out for a
little bit, I know it will be a

9190
09:08:17.328 --> 09:08:22.328
little bit small here, we've got
this huge main function, which

9191
09:08:22.328 --> 09:08:26.328
does what? Well it deploys our
contract. If we're on a test

9192
09:08:26.328 --> 09:08:29.328
net, it then verifies our
contract. And then it updates

9193
09:08:29.328 --> 09:08:33.328
the value to seven. And we have
our verify function down here.

9194
09:08:33.328 --> 09:08:37.328
And we have a section of our
code that calls our main

9195
09:08:37.328 --> 09:08:40.328
function. Now for run this on
the hard hat network. What do

9196
09:08:40.328 --> 09:08:44.328
you think will happen? Well,
let's try yarn, or net run

9197
09:08:44.328 --> 09:08:48.328
scripts. Deploy dot j s.
Alright, awesome, we get exactly

9198
09:08:48.328 --> 09:08:52.328
what we saw before we get
deploying contract deployed

9199
09:08:52.328 --> 09:08:56.329
contract to current value is
zero, update value seven. And

9200
09:08:56.329 --> 09:08:58.329
there's nothing in here about
verification. That's exactly

9201
09:08:58.329 --> 09:09:02.329
what we want. Now, moment of
truth. Let's try this on

9202
09:09:02.329 --> 09:09:08.329
Rinkeby. We'll do yarn, RT hat
run scripts, deploy dot j s,

9203
09:09:08.329 --> 09:09:16.329
dash dash network Rinkeby. And
it's gonna go a lot slower,

9204
09:09:16.329 --> 09:09:19.329
because obviously now we're
deploying to an actual test net,

9205
09:09:19.329 --> 09:09:21.329
where the blocks actually need
to be mined. And we see we

9206
09:09:21.329 --> 09:09:24.329
haven't deployed the contract.
Now that our contract is

9207
09:09:24.329 --> 09:09:27.329
deployed. We know that we're
currently waiting six block

9208
09:09:27.329 --> 09:09:30.329
confirmations for us to go ahead
and verify. And actually I

9209
09:09:30.329 --> 09:09:37.329
should add console dot log,
waiting for block the x's so

9210
09:09:37.329 --> 09:09:42.329
that we don't get campus weird.
Oh, wait, what are we doing now?

9211
09:09:42.329 --> 09:09:45.329
That it looks like we ran into
this error, no such file or

9212
09:09:45.329 --> 09:09:48.329
directory, it looks like our
code might not have compiled

9213
09:09:48.329 --> 09:09:51.329
correctly here. So here's what
I'm gonna do. We're gonna go

9214
09:09:51.329 --> 09:09:55.329
ahead and delete our artifacts
to trash. We're gonna delete our

9215
09:09:55.329 --> 09:09:58.329
cache as well. And we're going
to try rerunning this whenever

9216
09:09:58.329 --> 09:10:01.329
you run a script with the hard
drive command Hardhead will

9217
09:10:01.329 --> 09:10:04.329
automatically recompile it for
you, especially if there's no

9218
09:10:04.329 --> 09:10:08.329
artifacts folder. So we're going
to rerun this command and

9219
09:10:08.329 --> 09:10:11.329
heartbeat, it's going to compile
first and we can see that it

9220
09:10:11.329 --> 09:10:15.329
does exactly that. And then it's
going to go ahead and redeploy.

9221
09:10:15.329 --> 09:10:17.329
Hopefully this time, it should
be able to find the contract

9222
09:10:17.329 --> 09:10:26.329
that had just compiled looks
like this time after I deleted

9223
09:10:26.329 --> 09:10:29.329
the artifacts folder, we
actually did indeed get some

9224
09:10:29.329 --> 09:10:32.329
successful compilation. And we
can see here successfully

9225
09:10:32.329 --> 09:10:35.330
submitted source code for
contract or verification on the

9226
09:10:35.330 --> 09:10:38.330
block explore waiting for
verification results,

9227
09:10:38.330 --> 09:10:41.330
successfully verified contracts
simple storage on ether scan,

9228
09:10:41.330 --> 09:10:45.330
and even gives us a link that we
can go ahead and Command click

9229
09:10:45.330 --> 09:10:48.330
or control click into. And we
can see the contract indeed

9230
09:10:48.330 --> 09:10:55.330
being verified. This is awesome.
This is perfect. We've now got a

9231
09:10:55.330 --> 09:11:00.330
successful deploy dot j s script
that can deploy, verify, and

9232
09:11:00.330 --> 09:11:04.330
then interact with our code.
This is fantastic. This hard hat

9233
09:11:04.330 --> 09:11:06.330
thing seems pretty cool. What
else can we do with hard hat

9234
09:11:06.330 --> 09:11:11.330
like I showed you before. Hard
Hat comes with these tasks. And

9235
09:11:11.330 --> 09:11:13.330
the number of tasks that
Hardhead can come with can be

9236
09:11:13.330 --> 09:11:17.330
extended by us writing plugins,
we can actually write our own

9237
09:11:17.330 --> 09:11:21.330
tasks in hardhat. And in our
Hardhead dot config, it can

9238
09:11:21.330 --> 09:11:24.330
defaulted with this task
account, we can see task

9239
09:11:24.330 --> 09:11:28.330
accounts, prints the list of
accounts, and just prints a list

9240
09:11:28.330 --> 09:11:31.330
of accounts here actually go to
the heart had documentation to

9241
09:11:31.330 --> 09:11:34.330
learn more about creating our
own tasks, one of the ways that

9242
09:11:34.330 --> 09:11:39.330
you can define tasks is directly
in our heart head.config.js. But

9243
09:11:39.330 --> 09:11:43.330
typically, what people do is
they have a new folder called

9244
09:11:43.330 --> 09:11:47.330
tasks where they put all their
tasks. So for now, I'm gonna go

9245
09:11:47.330 --> 09:11:49.330
ahead and delete this section
here. And we're going to create

9246
09:11:49.330 --> 09:11:52.330
our own task. You'll notice that
now that we've deleted that

9247
09:11:52.330 --> 09:11:58.330
section, if we run yarn RDAP, we
no longer see the accounts task

9248
09:11:58.330 --> 09:12:01.330
in here, because we've just
deleted that task. So let's

9249
09:12:01.330 --> 09:12:08.330
create our own new task. We'll
call this block number.js. And

9250
09:12:08.330 --> 09:12:10.330
we'll use this to get the
current block number or whatever

9251
09:12:10.330 --> 09:12:14.331
blockchain that we're working
with. So let's create this task.

9252
09:12:14.331 --> 09:12:17.331
First, we need to import the
task function, we can get it by

9253
09:12:17.331 --> 09:12:24.331
saying const task equals require
arhat slash config. The hard hat

9254
09:12:24.331 --> 09:12:28.331
slash config has the task
function. To define a task, we

9255
09:12:28.331 --> 09:12:33.331
can now just say task, give it a
name and a description, the name

9256
09:12:33.331 --> 09:12:36.331
is going to be blocked number.

9257
09:12:36.331 --> 09:12:40.331
And then the description is
going to be prints the current

9258
09:12:40.331 --> 09:12:45.331
block number. Now that we have
this task, there's a couple of

9259
09:12:45.331 --> 09:12:48.331
things we can actually do with
it, we can add different

9260
09:12:48.331 --> 09:12:51.331
parameters to it by using the
dot add command, which allow us

9261
09:12:51.331 --> 09:12:54.331
to pass parameters to the task.
And then we could also set

9262
09:12:54.331 --> 09:12:58.331
actions which define what the
task should actually do for us,

9263
09:12:58.331 --> 09:13:03.331
we're just going to do dot set
action. And define what we want

9264
09:13:03.331 --> 09:13:07.331
this function to do. So we're
going to make this an async

9265
09:13:07.331 --> 09:13:11.331
function, that's going to take
as an input, the task arguments,

9266
09:13:11.331 --> 09:13:15.331
which are going to be blank for
us, and the HR E, which I'll

9267
09:13:15.331 --> 09:13:19.331
define in a second. Now, let me
explain the syntax really

9268
09:13:19.331 --> 09:13:22.331
quickly. This might look a
little bit weird, but this is

9269
09:13:22.331 --> 09:13:26.331
what's known as a JavaScript
arrow function. In JavaScript,

9270
09:13:26.331 --> 09:13:29.331
you can actually define
functions without even using the

9271
09:13:29.331 --> 09:13:32.331
function keyword. For example,
if we go back to our deploy

9272
09:13:32.331 --> 09:13:37.331
function, we have our async
function verify down here.

9273
09:13:37.331 --> 09:13:40.331
However, another way we could
have defined this is is without

9274
09:13:40.331 --> 09:13:43.331
using the function word at all,
and actually turning this whole

9275
09:13:43.331 --> 09:13:48.331
thing into a variable, we could
have said instead, we could say

9276
09:13:48.331 --> 09:13:54.332
const verify is going to be an
async function that takes

9277
09:13:54.332 --> 09:14:00.332
contract addresses and
arguments. And here's the

9278
09:14:00.332 --> 09:14:03.332
function definition. These two
lines are essentially

9279
09:14:03.332 --> 09:14:07.332
equivalent. There's some slight
differences between between

9280
09:14:07.332 --> 09:14:10.332
using the function keyword and
having your function be a

9281
09:14:10.332 --> 09:14:13.332
variable. But for the purposes
of this course, they're

9282
09:14:13.332 --> 09:14:17.332
basically the same. Which means
though, that this by itself is a

9283
09:14:17.332 --> 09:14:21.332
function, just not assigned to a
variable. But essentially, the

9284
09:14:21.332 --> 09:14:24.332
two of these do are exactly the
same. And that's the syntax that

9285
09:14:24.332 --> 09:14:27.332
we're doing here. You can
imagine this sort of being like

9286
09:14:27.332 --> 09:14:35.332
const block task equals async
function, which takes the params

9287
09:14:35.332 --> 09:14:39.332
and then runs that arrow
function. Or you can think of it

9288
09:14:39.332 --> 09:14:45.332
as async. Function, block task
parameters, and then the

9289
09:14:45.332 --> 09:14:49.332
function definition, these are
all essentially the same. The

9290
09:14:49.332 --> 09:14:53.332
major difference is that we're
never giving our function a

9291
09:14:53.332 --> 09:14:56.332
name, we never give it this
block task variable. This is

9292
09:14:56.332 --> 09:14:59.332
known as an anonymous function
in JavaScript, because it

9293
09:14:59.332 --> 09:15:02.332
doesn't have a name. Now that we
have our function in here, we

9294
09:15:02.332 --> 09:15:06.332
can now call some function to
get the block number. Well, how

9295
09:15:06.332 --> 09:15:10.332
can we get the block number when
we run tasks, we automatically

9296
09:15:10.332 --> 09:15:13.332
pass our anonymous functions,
the task arguments, which in

9297
09:15:13.332 --> 09:15:18.332
this one, we don't have any, but
we also pass this HR II object.

9298
09:15:18.332 --> 09:15:23.332
This HRV is the heart hat
runtime environment. Back in our

9299
09:15:23.332 --> 09:15:27.332
deploy script, this is basically
the same as this require hard

9300
09:15:27.332 --> 09:15:32.332
hat in here. So this HRV can
access a lot of the same, this

9301
09:15:32.332 --> 09:15:37.333
HRV can access a lot of the same
packages that the hard hat

9302
09:15:37.333 --> 09:15:41.333
package can. So we can do Hae
dot ethers, just like how you

9303
09:15:41.333 --> 09:15:45.333
can import ethers from hard hat.
And in our ethers package,

9304
09:15:45.333 --> 09:15:47.333
there's actually a number of
functions we can use like dot

9305
09:15:47.333 --> 09:15:54.333
Pro, biter dot get block number.
Let's save this to a variable

9306
09:15:54.333 --> 09:15:59.333
const blocked number equals, and
this is going to be a

9307
09:15:59.333 --> 09:16:02.333
synchronous, so we're going to
want to add a weight here. And

9308
09:16:02.333 --> 09:16:07.333
then let's do console dot log
block number. Or better yet,

9309
09:16:07.333 --> 09:16:12.333
we'll string interpolate this
and say current block number

9310
09:16:12.333 --> 09:16:17.333
like this. Now though, if I try
to run this task, you'll notice

9311
09:16:17.333 --> 09:16:22.333
it doesn't show up in the heart
Atlas of tasks, let's do yarn.

9312
09:16:22.333 --> 09:16:26.333
Art app. Hmm, I don't see block
number in here. Well, this is

9313
09:16:26.333 --> 09:16:31.333
because we need to add it to our
config dot config will add

9314
09:16:31.333 --> 09:16:39.333
require dot slash tasks slash
block number.

9315
09:16:39.333 --> 09:16:43.333
And in order for us to import
it, and let's add a module that

9316
09:16:43.333 --> 09:16:47.333
exports I'll explain what this
does a little bit later. But now

9317
09:16:47.333 --> 09:16:50.333
that we've required it, if I run
yarn hard hat, and now see

9318
09:16:50.333 --> 09:16:54.333
blocked over is one of the tasks
that I can use. Now for a run

9319
09:16:54.333 --> 09:16:59.333
yarn, art hat block number, we
get current block number is

9320
09:16:59.333 --> 09:17:03.333
zero. And this makes sense
because this is defaulting to

9321
09:17:03.333 --> 09:17:08.333
our Hard Hat Network, which gets
reset every time we run it. But

9322
09:17:08.333 --> 09:17:11.333
if I run yarn, hard hat block
number A dash dash network

9323
09:17:11.333 --> 09:17:15.334
Rinkeby, what do you think I'm
gonna get? Again, a much larger

9324
09:17:15.334 --> 09:17:19.334
number, current block number is
right here. Because this is the

9325
09:17:19.334 --> 09:17:23.334
actual block number of Rigby
versus the block number of our

9326
09:17:23.334 --> 09:17:27.334
heart ad network is going to be
zero because it gets reset every

9327
09:17:27.334 --> 09:17:31.334
single time, we run one of these
scripts now scripts and tasks

9328
09:17:31.334 --> 09:17:35.334
both can basically do the same
thing. They both can interact

9329
09:17:35.334 --> 09:17:38.334
with contracts, they both can
deploy smart contracts, they can

9330
09:17:38.334 --> 09:17:41.334
both pretty much do everything.
I prefer scripts just as a

9331
09:17:41.334 --> 09:17:45.334
general rule of thumb, because I
don't always think adding a

9332
09:17:45.334 --> 09:17:48.334
special thing from the command
line makes sense. So I prefer

9333
09:17:48.334 --> 09:17:51.334
scripts, but you'll see a ton of
tasks and examples out there as

9334
09:17:51.334 --> 09:17:55.334
well. I think tasks are really
nice for specific use cases. But

9335
09:17:55.334 --> 09:17:58.334
for the most part, we're pretty
much going to use exclusively

9336
09:17:58.334 --> 09:18:01.334
scripts, but it is good to know
what a task looks like and how

9337
09:18:01.334 --> 09:18:05.334
to use it. I think tasks are
better for plugins and scripts

9338
09:18:05.334 --> 09:18:08.334
are better for your own local
development environment. But if

9339
09:18:08.334 --> 09:18:14.334
you want to do everything with
tasks, you absolutely can. As

9340
09:18:14.334 --> 09:18:18.334
you're starting to see, this
config piece is pretty powerful.

9341
09:18:18.334 --> 09:18:21.334
And we can use it to modify our
entire code base and our entire

9342
09:18:21.334 --> 09:18:25.334
project to give our project more
functionality. What else can

9343
09:18:25.334 --> 09:18:28.334
this do? Well, right now, as you
can see, every time we work with

9344
09:18:28.334 --> 09:18:31.334
a hard hat network, every time
we run a script, we run that

9345
09:18:31.334 --> 09:18:34.334
script, and then the Hard Hat
Network is deleted, right? We

9346
09:18:34.334 --> 09:18:36.334
can't interact with our
contracts anymore. Well, there's

9347
09:18:36.334 --> 09:18:40.334
actually a way for us to run a
hard hat network. Similar to how

9348
09:18:40.334 --> 09:18:44.334
we ran a ganache network with a
user interface. What we can do

9349
09:18:44.334 --> 09:18:51.334
in hard hat is run yarn, RT hat
node. And what this will do is

9350
09:18:51.334 --> 09:18:55.335
it'll spin up a node on a local
network, exactly the same as

9351
09:18:55.335 --> 09:19:00.335
ganache but in our terminal. So
you see here started HTTP and

9352
09:19:00.335 --> 09:19:04.335
WebSocket. JSON RPC server at
this address. And just like

9353
09:19:04.335 --> 09:19:08.335
nosh, it comes packed with all
these different accounts and

9354
09:19:08.335 --> 09:19:11.335
private keys, which is awesome.
You'll notice though,

9355
09:19:11.335 --> 09:19:16.335
interestingly enough that this
node that we're running isn't on

9356
09:19:16.335 --> 09:19:18.335
the Hard Hat Network, well, we
can actually create a new

9357
09:19:18.335 --> 09:19:22.335
terminal to try to interact with
this just by hitting this little

9358
09:19:22.335 --> 09:19:26.335
plus button and creating a new
terminal. Again, I'm using bash,

9359
09:19:26.335 --> 09:19:29.335
but based off of whatever your
operating system is, you can be

9360
09:19:29.335 --> 09:19:33.335
using a different shell. And
here, let's go ahead and run

9361
09:19:33.335 --> 09:19:39.335
yarn arhat run scripts, deploy
dot j s, and see what happens.

9362
09:19:39.335 --> 09:19:42.335
Well, our typical setup happens,
we deploy a contract, we get a

9363
09:19:42.335 --> 09:19:46.335
contract address, we update the
value. But if we look at our

9364
09:19:46.335 --> 09:19:49.335
node, it doesn't look like any
transactions went through what

9365
09:19:49.335 --> 09:19:53.335
we don't see any locking here.
So what's going on? Well, our

9366
09:19:53.335 --> 09:19:58.335
Hard Hat Network is actually
different from this locally

9367
09:19:58.335 --> 09:20:02.335
running network here. This
locally running network we often

9368
09:20:02.335 --> 09:20:05.335
want to refer to as our local
host. So it's slightly different

9369
09:20:05.335 --> 09:20:08.335
than the Hard Hat Network. It's
still using the hard hat runtime

9370
09:20:08.335 --> 09:20:11.335
environment, but it's just not
this default Hard Hat Network.

9371
09:20:11.335 --> 09:20:15.335
It's considered its own separate
network when we're running a

9372
09:20:15.335 --> 09:20:19.335
node that it's going to live. of
past the duration of a script.

9373
09:20:19.335 --> 09:20:23.335
So we can actually interact with
this by adding a new network to

9374
09:20:23.335 --> 09:20:27.335
our hardhead.config.js, we'll
create a new network and call it

9375
09:20:27.335 --> 09:20:30.335
local host.

9376
09:20:30.335 --> 09:20:35.336
And exactly as we did up here,
we'll give it a URL accounts and

9377
09:20:35.336 --> 09:20:40.336
a chain ID. So for URL, we can
get that URL right from our

9378
09:20:40.336 --> 09:20:44.336
terminal, I'll put a running
yarn hard hat node. by copying

9379
09:20:44.336 --> 09:20:48.336
that and pasting it in here, we
can then do a comma, we'll give

9380
09:20:48.336 --> 09:20:55.336
it a chain ID of 31337. Because
even though it's considered a

9381
09:20:55.336 --> 09:20:58.336
different network, it actually
has the same chain ID as hard

9382
09:20:58.336 --> 09:21:01.336
hat. Interestingly enough, I
know I just said we were going

9383
09:21:01.336 --> 09:21:03.336
to give it accounts, but we
actually don't need to give it

9384
09:21:03.336 --> 09:21:07.336
accounts. Because when we run
with this localhost hard hat

9385
09:21:07.336 --> 09:21:11.336
will automatically give us these
10 fake accounts for us. So you

9386
09:21:11.336 --> 09:21:14.336
can kind of think of the
accounts here for this localhost

9387
09:21:14.336 --> 09:21:19.336
as, as hard had already placing
them in thanks, hard hat. But

9388
09:21:19.336 --> 09:21:23.336
now, if we go back to our bash
here, let's clear the terminal.

9389
09:21:23.336 --> 09:21:28.336
Let's rerun the script. And
we'll do dash dash network local

9390
09:21:28.336 --> 09:21:33.336
host. Now we should be pointing
to this node. And when I run

9391
09:21:33.336 --> 09:21:38.336
this script, we should see some
logging output at the end of

9392
09:21:38.336 --> 09:21:42.336
this node. So let's go ahead and
hit enter. Well, we see our

9393
09:21:42.336 --> 09:21:46.336
normal stuff on our deploy
script, we flip back to our node

9394
09:21:46.336 --> 09:21:50.336
Wow, we see a ton of logging
here. Similar to ganache, we can

9395
09:21:50.336 --> 09:21:53.336
see a whole bunch of different
logs on what just happened, we

9396
09:21:53.336 --> 09:21:56.336
can see a contract was deployed,
we can see the address the

9397
09:21:56.336 --> 09:22:00.336
transaction hash from value,
gas, and the block number and

9398
09:22:00.336 --> 09:22:05.336
everything. We can also see our
contract call calling the store

9399
09:22:05.336 --> 09:22:09.336
function to update the value of
our favorite number. This is

9400
09:22:09.336 --> 09:22:13.336
incredibly powerful for quickly
testing and working with things

9401
09:22:13.336 --> 09:22:17.337
on a local JavaScript VM or hard
hat network to be able to see

9402
09:22:17.337 --> 09:22:20.337
how your contracts will interact
on a real test net. And this is

9403
09:22:20.337 --> 09:22:24.337
much quicker than working with a
real test net. Now additionally,

9404
09:22:24.337 --> 09:22:27.337
same as what we said before, any
process that's running in the

9405
09:22:27.337 --> 09:22:32.337
terminal, we can kill it with
Ctrl C. So if you want to stop

9406
09:22:32.337 --> 09:22:37.337
your node and then restart it,
you can hit Ctrl. C, to stop it,

9407
09:22:37.337 --> 09:22:41.337
and then just up and then rerun
that same command to re spin up

9408
09:22:41.337 --> 09:22:45.337
your node Ctrl C stops it. And
then you can up to start again.

9409
09:22:45.337 --> 09:22:47.337
Another way you can stop it, of
course, is if you hit the

9410
09:22:47.337 --> 09:22:50.337
trashcan, which deletes the
whole terminal, we pulled a

9411
09:22:50.337 --> 09:22:55.337
terminal back up, we can run it
again. And just remember, if you

9412
09:22:55.337 --> 09:22:58.337
hit the X that actually doesn't
delete the terminal, that just

9413
09:22:58.337 --> 09:23:02.337
hides it. So our hard hat node
right now is still running

9414
09:23:02.337 --> 09:23:04.337
because I just hit it. So I pull
it back up, I can see that it is

9415
09:23:04.337 --> 09:23:07.337
indeed still running. But if I
trashed candidate, and then it

9416
09:23:07.337 --> 09:23:09.337
pulled the terminal back up, I
can see that it is no longer

9417
09:23:09.337 --> 09:23:15.337
running. So running scripts is
great. But what if I don't want

9418
09:23:15.337 --> 09:23:19.337
to have to code an entire script
to do some things? What if I

9419
09:23:19.337 --> 09:23:23.337
want to just tinker around with
the blockchain? Well, hard hat

9420
09:23:23.337 --> 09:23:26.337
comes packed with this thing
called the console. The console

9421
09:23:26.337 --> 09:23:29.337
is a JavaScript environment. For
us to run JavaScript commands to

9422
09:23:29.337 --> 09:23:33.337
interact with any blockchain, we
can jump to the console by

9423
09:23:33.337 --> 09:23:38.337
running yarn, hardhat, console,
and then whatever network flag

9424
09:23:38.337 --> 09:23:41.337
if we want to work on rink B,
main net polygon, avalanche,

9425
09:23:41.337 --> 09:23:45.337
etc. That's just network local
host. And now we're dropped into

9426
09:23:45.337 --> 09:23:49.337
a shell him in the shell, we can
do everything that we do in a

9427
09:23:49.337 --> 09:23:52.337
deploy script. And we don't even
have to run these imports,

9428
09:23:52.337 --> 09:23:55.338
because everything with hard hat
is automatically imported into

9429
09:23:55.338 --> 09:23:59.338
our console. So for example,
let's say I wanted to get a

9430
09:23:59.338 --> 09:24:02.338
simple storage contract factory.
Well, I could run exactly this

9431
09:24:02.338 --> 09:24:08.338
line here. I could say const,
simple storage, factory equals

9432
09:24:08.338 --> 09:24:16.338
await ethers dot get contract
factory, have simple storage.

9433
09:24:16.338 --> 09:24:19.338
And now I can go ahead and even
deploy this. So I can even just

9434
09:24:19.338 --> 09:24:25.338
copy this line, paste it. And if
we flip back to our node, we'll

9435
09:24:25.338 --> 09:24:28.338
see that we just deployed a
nother simple storage. And now

9436
09:24:28.338 --> 09:24:36.338
we can do things like await
simple storage dot retrieve. And

9437
09:24:36.338 --> 09:24:39.338
I get the return value which is
going to be a big number with a

9438
09:24:39.338 --> 09:24:43.338
value of zero. I can also make
transactions so I can do a

9439
09:24:43.338 --> 09:24:52.338
weight, simple storage. That
store let's do 55 If I hit up

9440
09:24:52.338 --> 09:24:55.338
twice, I can go back to the
simple storage dot retrieve.

9441
09:24:55.338 --> 09:24:59.338
call that function and I can see
my big number has a value of 55.

9442
09:24:59.338 --> 09:25:01.338
Now, this is a great way to
quickly interact with any

9443
09:25:01.338 --> 09:25:04.338
blockchain that we want. Now you
can exit the shell by hitting

9444
09:25:04.338 --> 09:25:09.338
Ctrl C twice to get out. Or you
can also just you can also Trash

9445
09:25:09.338 --> 09:25:12.338
Can your terminal if you get
confused. This console works

9446
09:25:12.338 --> 09:25:18.338
with any network we can even do
yarn, hard hat console dash dash

9447
09:25:18.338 --> 09:25:23.338
network hard hat. And we'll get
dropped into a hard hat network.

9448
09:25:23.338 --> 09:25:26.338
Now this is not going to be the
same node that's running here,

9449
09:25:26.338 --> 09:25:30.338
this is going to be one that
only runs for the duration of

9450
09:25:30.338 --> 09:25:33.338
this command. So whenever we
cancel this command, this hard

9451
09:25:33.338 --> 09:25:37.339
hat network gets cancelled. And
close out that too. We can also

9452
09:25:37.339 --> 09:25:45.339
do yarn, hard hat, console, dash
dash network Rinkeby Rigby, or

9453
09:25:45.339 --> 09:25:48.339
polygon or test net or main net
or whatever we want. And we can

9454
09:25:48.339 --> 09:25:54.339
do things like ethers dot
provider that can do things like

9455
09:25:54.339 --> 09:25:59.339
await ethers dot provider dot
get block number, see the block

9456
09:25:59.339 --> 09:26:03.339
number of Rigby. We can also
deploy contracts, we can update

9457
09:26:03.339 --> 09:26:06.339
contracts, we can do anything
that we want, you can do

9458
09:26:06.339 --> 09:26:08.339
anything in these consoles, and
they're great ways to quickly

9459
09:26:08.339 --> 09:26:10.339
test and tinker in interact

9460
09:26:10.339 --> 09:26:16.339
with contracts. Now, there's a
couple other tasks that are

9461
09:26:16.339 --> 09:26:19.339
really helpful. You'll see
before I went ahead and just

9462
09:26:19.339 --> 09:26:22.339
deleted artifacts and deleted
the cache manually. Well, to do

9463
09:26:22.339 --> 09:26:28.339
that yourself, you can also just
run yarn Hardhead, clean. And

9464
09:26:28.339 --> 09:26:31.339
that'll delete the artifacts
folder and clear out your cache.

9465
09:26:31.339 --> 09:26:34.339
We already know what compiled
does. But one of the biggest

9466
09:26:34.339 --> 09:26:37.339
things that Hardhead is
fantastic for especially is

9467
09:26:37.339 --> 09:26:41.339
running tests. Now we haven't
run tests yet so far. However,

9468
09:26:41.339 --> 09:26:45.339
running tests is absolutely
critical to your smart contract

9469
09:26:45.339 --> 09:26:48.339
development journey. And we're
going to spend a lot of time in

9470
09:26:48.339 --> 09:26:51.339
the future writing really good
tests. The reason that writing

9471
09:26:51.339 --> 09:26:55.339
tests are so important is
because we want to make sure our

9472
09:26:55.339 --> 09:26:59.339
code does exactly what we want
it to do, especially in the

9473
09:26:59.339 --> 09:27:03.339
defy, and the decentralized,
smart contract world, all of our

9474
09:27:03.339 --> 09:27:06.339
code is going to be open source
for anybody to interact with,

9475
09:27:06.339 --> 09:27:10.339
and potentially exploit. There's
sites like req dot news, which

9476
09:27:10.339 --> 09:27:14.340
go through a ton of previous
hacks and how they actually got

9477
09:27:14.340 --> 09:27:17.340
hacked and what happened in the
smart contract to enable these

9478
09:27:17.340 --> 09:27:21.340
hacks to occur. So testing, so
writing really strong tests is

9479
09:27:21.340 --> 09:27:25.340
always going to be our first
line of defense. And we have

9480
09:27:25.340 --> 09:27:28.340
this sample test.js, that comes
default with the basic package

9481
09:27:28.340 --> 09:27:31.340
of hardhat. But as you probably
already know, we're going to

9482
09:27:31.340 --> 09:27:34.340
rename this and change it. So
we're going to rename this to

9483
09:27:34.340 --> 09:27:39.340
test deploy dot j s. And we're
going to delete everything in

9484
09:27:39.340 --> 09:27:43.340
here and start from scratch. We
want to be able to test all of

9485
09:27:43.340 --> 09:27:46.340
our solidity code locally, so
that we know exactly what it's

9486
09:27:46.340 --> 09:27:50.340
doing. And we can have a
programmatic way to make sure

9487
09:27:50.340 --> 09:27:54.340
that our code does what we want
it to do. So let's write a basic

9488
09:27:54.340 --> 09:27:58.340
test for our simple storage
contract. So that we can be sure

9489
09:27:58.340 --> 09:28:02.340
that it's doing exactly what we
want it to be doing. Hard Hat

9490
09:28:02.340 --> 09:28:06.340
testing works with the Mocha
framework, which is a JavaScript

9491
09:28:06.340 --> 09:28:09.340
based framework for running our
tests, you actually can write

9492
09:28:09.340 --> 09:28:13.340
tests directly in solidity, if
you'd like to, there's a bit of

9493
09:28:13.340 --> 09:28:16.340
back and forth on whether
testing with pure solidity is

9494
09:28:16.340 --> 09:28:19.340
better or testing with a modern
programming language. The

9495
09:28:19.340 --> 09:28:22.340
argument goes that testing with
a modern programming language,

9496
09:28:22.340 --> 09:28:27.340
you have more flexibility to do
more stuff to interact and test

9497
09:28:27.340 --> 09:28:29.340
your smart contracts. But the
argument for testing with us

9498
09:28:29.340 --> 09:28:32.340
with solidity is that we want to
be as close to the code as

9499
09:28:32.340 --> 09:28:35.340
possible. At the time of
recording, most projects do the

9500
09:28:35.340 --> 09:28:39.340
vast majority of their testing
in a modern programming language

9501
09:28:39.340 --> 09:28:42.340
like JavaScript. So that's what
we're going to be using here. So

9502
09:28:42.340 --> 09:28:45.340
to get started with our mocha
tests, we do, we're going to

9503
09:28:45.340 --> 09:28:50.340
write a describe function.
Describe is a keyword that

9504
09:28:50.340 --> 09:28:54.341
hardheaded mocha will recognize,
and it takes two parameters, it

9505
09:28:54.341 --> 09:28:58.341
takes a string, which we're
going to just write simple

9506
09:28:58.341 --> 09:29:03.341
storage for now. And then also
takes a function, we could make

9507
09:29:03.341 --> 09:29:09.341
function, test func and then
write some stuff in here, and

9508
09:29:09.341 --> 09:29:14.341
then pass it to our describe
here. But the common convention

9509
09:29:14.341 --> 09:29:18.341
is going to be to do is to make
it as an anonymous function,

9510
09:29:18.341 --> 09:29:22.341
which we can create by typing
function, putting an empty

9511
09:29:22.341 --> 09:29:25.341
parameter here, and then some
brackets like that. So our

9512
09:29:25.341 --> 09:29:29.341
describe function takes a name,
a string, and a function.

9513
09:29:29.341 --> 09:29:32.341
Another way that you'll often
see functions in describe is

9514
09:29:32.341 --> 09:29:36.341
using that anonymous function
syntax. So you might see just

9515
09:29:37.341 --> 09:29:41.341
these parentheses, an arrow, and
then some brackets, the two of

9516
09:29:41.341 --> 09:29:44.341
these are going to be basically
the same, there are some

9517
09:29:44.341 --> 09:29:47.341
differences. And this second one
is actually best practice, but

9518
09:29:47.341 --> 09:29:51.341
just know that you might see
this arrow syntax in other tests

9519
09:29:51.341 --> 09:29:54.341
as well. We have described a
sample storage and then our

9520
09:29:54.341 --> 09:29:56.341
function here, which is going to
have all of our tests in it.

9521
09:29:56.341 --> 09:29:59.341
Inside each one of our describe
blocks. We're gonna have

9522
09:29:59.341 --> 09:30:03.341
something called a before each,
and a bunch of It's Our before

9523
09:30:03.341 --> 09:30:07.341
each function is going to tell
us what to do before each of our

9524
09:30:07.341 --> 09:30:09.341
hits. So we're going to have a
ton of it and then we're going

9525
09:30:09.341 --> 09:30:13.341
to have a before each. All of
our IDs are going to be where we

9526
09:30:13.341 --> 09:30:15.341
actually write the code for
running our tests. And before

9527
09:30:15.341 --> 09:30:19.341
each is going to be some code
that tells us what to do before

9528
09:30:19.341 --> 09:30:25.341
each one of these hits, we can
also actually have describes,

9529
09:30:25.341 --> 09:30:29.341
inside of describes, which again
have more before each and more

9530
09:30:29.341 --> 09:30:33.341
before it's having these nested
describes can be really helpful

9531
09:30:33.341 --> 09:30:37.342
for separating and modularizing
our tests. But for this one,

9532
09:30:37.342 --> 09:30:41.342
we're just going to have a setup
that looks like this. And for

9533
09:30:41.342 --> 09:30:45.342
this demo, we're only going to
have one it. So in order to test

9534
09:30:45.342 --> 09:30:47.342
our smart contracts, before we
actually run our tests, we're

9535
09:30:47.342 --> 09:30:50.342
probably going to need to deploy
the smart contracts first. So

9536
09:30:50.342 --> 09:30:53.342
inside of our before each, we're
going to pass the our before

9537
09:30:53.342 --> 09:30:56.342
each a function, that's going to
tell our testing framework what

9538
09:30:56.342 --> 09:31:00.342
to do before each test. So we're
going to pass it an async

9539
09:31:00.342 --> 09:31:05.342
function like this. And in here,
we want to deploy our simple

9540
09:31:05.342 --> 09:31:08.342
storage contract. So to do that,
we're going to need to get the

9541
09:31:08.342 --> 09:31:12.342
ethers framework and do exactly
what we did in our deploy

9542
09:31:12.342 --> 09:31:16.342
script. So in here, we're at the
top we're gonna say const.

9543
09:31:16.342 --> 09:31:23.342
Ethers, equals require art have
an import ethers from hard hat.

9544
09:31:23.342 --> 09:31:29.342
Then in our before each
function, we'll say await ethers

9545
09:31:29.342 --> 09:31:37.342
dot get contract factory of
simple storage. And we'll assign

9546
09:31:37.342 --> 09:31:46.342
this to a const. Simple Storage
factory. And then we'll run

9547
09:31:46.342 --> 09:31:52.342
away, simple storage factory dot
deploy. Cool. And let's also

9548
09:31:52.342 --> 09:31:58.342
assign this to a variable cost
simple. Now, since right now,

9549
09:31:58.342 --> 09:32:02.342
our simple storage and simple
storage factory are scoped just

9550
09:32:02.342 --> 09:32:05.342
to inside the before each, we
actually need to stick these

9551
09:32:05.342 --> 09:32:09.342
variables outside of the before
each, so all of our events can

9552
09:32:09.342 --> 09:32:12.342
interact with them. So instead
of having simple storage,

9553
09:32:12.342 --> 09:32:16.343
factory, and simple storage, be
constant variables, we're going

9554
09:32:16.343 --> 09:32:20.343
to define them outside of them
for each with the let keyword.

9555
09:32:20.343 --> 09:32:25.343
And we're gonna say let simple
storage factory and we're going

9556
09:32:25.343 --> 09:32:29.343
to initialize it to nothing. And
then we'll say led simple

9557
09:32:29.343 --> 09:32:32.343
storage. Now, if you have a
whole bunch of let's just

9558
09:32:32.343 --> 09:32:35.343
initializing another way, you
can write them in JavaScript,

9559
09:32:35.343 --> 09:32:41.343
just let simple storage factory
comma, simple storage. And that

9560
09:32:41.343 --> 09:32:43.343
works exactly the same. And then
we can get rid of this const

9561
09:32:43.343 --> 09:32:47.343
keyword. Because it's not a
constant since we are assigning

9562
09:32:47.343 --> 09:32:50.343
it. And now we have simple
storage, factory and simple

9563
09:32:50.343 --> 09:32:53.343
storage that we can use inside
of our init function. Now we

9564
09:32:53.343 --> 09:32:56.343
have a before each section. So
before each one of our tests,

9565
09:32:56.343 --> 09:32:58.343
we're going to deploy our simple
storage contract. So we have a

9566
09:32:58.343 --> 09:33:02.343
brand new contract to interact
with for each one of our tests.

9567
09:33:02.343 --> 09:33:05.343
Now, inside of the ID, this is
where we're going to say what we

9568
09:33:05.343 --> 09:33:09.343
want this specific test to do,
and then describe the code

9569
09:33:09.343 --> 09:33:13.343
that's going to actually do
that. So we're going to say it

9570
09:33:13.343 --> 09:33:20.343
should start with a favorite
number of zero. So this is

9571
09:33:20.343 --> 09:33:24.343
saying what this test should do.
And then we're going to add our

9572
09:33:24.343 --> 09:33:28.343
async function to actually do
that. So we'll say async

9573
09:33:28.343 --> 09:33:34.343
function. And in here, this is
where we'll actually write the

9574
09:33:34.343 --> 09:33:38.343
code to make sure that our
contract does exactly this.

9575
09:33:38.343 --> 09:33:46.343
We're say const. Current Value,
equals await, simple storage.re

9576
09:33:46.343 --> 09:33:50.343
retrieve. And now in this test,
we want to say okay, now check

9577
09:33:50.343 --> 09:33:54.343
to see that this current value
is indeed zero. So how do we do

9578
09:33:54.343 --> 09:33:59.344
that? Well, we can say const,
expected value is going to equal

9579
09:33:59.344 --> 09:34:04.344
zero. And what we can do is we
can do either we can use either

9580
09:34:04.344 --> 09:34:08.344
the assert keyword, or the
expect keyword, which we're

9581
09:34:08.344 --> 09:34:12.344
going to import both of these
from a package called Chai. We

9582
09:34:12.344 --> 09:34:16.344
actually installed Chai
automatically when we downloaded

9583
09:34:16.344 --> 09:34:19.344
the basic parameters when we
downloaded the basic packages

9584
09:34:19.344 --> 09:34:23.344
for hardhats. So at the top,
we're gonna say const. Expect

9585
09:34:23.344 --> 09:34:25.344
and assert

9586
09:34:25.344 --> 09:34:30.344
equals require Chai, I'm a big
fan of using assert as much as

9587
09:34:30.344 --> 09:34:33.344
possible, because I think the
syntax makes a little bit more

9588
09:34:33.344 --> 09:34:36.344
sense. But there will be
scenarios where we need to use

9589
09:34:36.344 --> 09:34:39.344
expect instead. Now, assert has
a ton of functions that are

9590
09:34:39.344 --> 09:34:43.344
built in that help us make sure
this is what we expect it to be.

9591
09:34:43.344 --> 09:34:48.344
So I can do assert dot equal
current value.to string, because

9592
09:34:48.344 --> 09:34:51.344
remember, this is actually going
to be a big number, comma,

9593
09:34:51.344 --> 09:34:55.344
expected value. So I'm saying
I'm asserting this retrieve to

9594
09:34:55.344 --> 09:34:59.344
return zero, which is going to
be our expected value. Now to

9595
09:34:59.344 --> 09:35:04.344
actually run this, we're going
to run yarn, art hat test. And

9596
09:35:04.344 --> 09:35:07.344
we see we get an output that
looks like this should start

9597
09:35:07.344 --> 09:35:10.344
with favorite number of zero,
and it's indeed passing. You'll

9598
09:35:10.344 --> 09:35:14.344
notice that if I were to change
this to one, and this wasn't

9599
09:35:14.344 --> 09:35:18.344
correct, it would break and it
would say art Pass or not

9600
09:35:18.344 --> 09:35:23.344
passing assertion error expected
zero to equal one. It expected

9601
09:35:23.344 --> 09:35:29.344
zero to equal one, which is not
what we want. We want zero to

9602
09:35:29.344 --> 09:35:33.344
equal zero. So let's run this
again. Tada should start with

9603
09:35:33.344 --> 09:35:36.345
favorite number zero, and it's
passing. Alright, fantastic. So

9604
09:35:36.345 --> 09:35:40.345
that's how we wrote one of our
tests, let's write one more test

9605
09:35:40.345 --> 09:35:43.345
just to make sure that things
are good. So let's say it should

9606
09:35:43.345 --> 09:35:48.345
update when we call store,
because when we call the store

9607
09:35:48.345 --> 09:35:51.345
function, we want our favorite
number to update. And we'll make

9608
09:35:51.345 --> 09:35:56.345
this an async function as well.
And let's add our stuff in here.

9609
09:35:56.345 --> 09:36:01.345
So we'll say const. Expected
Value equals seven, we're

9610
09:36:01.345 --> 09:36:05.345
expecting that when we call
store it updates to seven. Now

9611
09:36:05.345 --> 09:36:11.345
we can say const. Transaction
response equals await simple

9612
09:36:11.345 --> 09:36:16.345
storage dot store. And we can
even just pass it the expected

9613
09:36:16.345 --> 09:36:21.345
value here. And then we'll do a
weight transaction response that

9614
09:36:21.345 --> 09:36:25.345
weight one. Now let's get the
current value. So we'll say

9615
09:36:25.345 --> 09:36:32.345
const. Current Value equals
weight, simple storage,

9616
09:36:32.345 --> 09:36:37.345
retrieve. And now we're going to
assert dot equal current

9617
09:36:37.345 --> 09:36:44.345
value.to string, comma expected
value. And now we can run all

9618
09:36:44.345 --> 09:36:47.345
these tests by running yarn
Hardhead test. And you'll see we

9619
09:36:47.345 --> 09:36:51.345
ran both of these tests. And now
if I have 10,000 tests, and I'm

9620
09:36:51.345 --> 09:36:54.345
only finagling with one test, I
can actually just run one test

9621
09:36:55.345 --> 09:37:01.345
by running yarn, art app, test,
dash dash grep. And I can search

9622
09:37:01.345 --> 09:37:06.345
for any keywords in any of the
text here. So I'm going to grep

9623
09:37:06.345 --> 09:37:10.345
for the store function. Because
the store keyword isn't in this

9624
09:37:10.345 --> 09:37:14.346
tax for this, it, it's only in
the text for this it. So if I do

9625
09:37:14.346 --> 09:37:18.346
grep store, it should only run
our second test, which does

9626
09:37:18.346 --> 09:37:22.346
indeed, one other way we can run
only specific tests is with the

9627
09:37:22.346 --> 09:37:28.346
only keyword. So we can type it
dot only like that. And then we

9628
09:37:28.346 --> 09:37:33.346
can run yarn, art hat test. And
it should only run, this should

9629
09:37:33.346 --> 09:37:36.346
update when we call store. And
it does indeed, then we'll go

9630
09:37:36.346 --> 09:37:40.346
ahead and delete this save, run
again, and it should run all

9631
09:37:40.346 --> 09:37:45.346
too. Fantastic. Now the other
way you'll see these tests

9632
09:37:45.346 --> 09:37:49.346
written is with instead of
assert, it'll use the expect

9633
09:37:49.346 --> 09:37:52.346
keyword. So you'll see something
like expect current

9634
09:37:52.346 --> 09:37:59.346
value.to string.to dot equal
expected value, the two of these

9635
09:37:59.346 --> 09:38:03.346
lines do exactly the same thing.
And it's sort of up to you on

9636
09:38:03.346 --> 09:38:06.346
which one you want to use. And
that's all we're going to do for

9637
09:38:06.346 --> 09:38:12.346
our testing. Now. This is
fantastic, great job. Now that

9638
09:38:12.346 --> 09:38:15.346
we have some tests, we can
actually start testing to see

9639
09:38:15.346 --> 09:38:19.346
how much gas each one of our
functions actually costs. One of

9640
09:38:19.346 --> 09:38:23.346
the most popular extensions for
hard hat is the hard hat gas

9641
09:38:23.346 --> 09:38:27.346
reporter. This is an extension
that gets attached to all of our

9642
09:38:27.346 --> 09:38:30.346
tests, and automatically gives
us an output that looks like

9643
09:38:30.346 --> 09:38:32.346
this, that tells us
approximately how much gas each

9644
09:38:32.346 --> 09:38:36.346
one of our functions cost. We
scroll down in here, we can read

9645
09:38:36.346 --> 09:38:38.346
the instructions on how to
actually install this npm

9646
09:38:38.346 --> 09:38:41.346
install Hardhead gas reporter
which we're going to use with

9647
09:38:41.346 --> 09:38:49.346
yarn. So we're gonna say yarn,
add hard hat, gas reporter, dash

9648
09:38:49.346 --> 09:38:52.346
dash Dev.

9649
09:38:52.346 --> 09:38:57.347
And now that that package is
installed, we can go over to our

9650
09:38:57.347 --> 09:39:01.347
config and add some parameters
in here so that we can work with

9651
09:39:01.347 --> 09:39:04.347
this gas pit. But our neath our
ether scan section, we're going

9652
09:39:04.347 --> 09:39:09.347
to add a new section called gas
reporter. To have it run,

9653
09:39:09.347 --> 09:39:12.347
whenever we run our tests we're
going to do enabled is going to

9654
09:39:12.347 --> 09:39:18.347
be true. And then up at the top,
we can add it by adding require

9655
09:39:18.347 --> 09:39:23.347
hardhat gas reporter. Now that
we have it in here, we can do

9656
09:39:23.347 --> 09:39:27.347
yarn hardhat test, and after we
run our tests, it'll

9657
09:39:27.347 --> 09:39:32.347
automatically run this gas
reporter. So we see our tests go

9658
09:39:32.347 --> 09:39:35.347
ahead and run. And then we get
this output that looks like this

9659
09:39:35.347 --> 09:39:39.347
that tells us how approximately
how much our contracts and

9660
09:39:39.347 --> 09:39:42.347
methods cost. So our store
function looks like It costs

9661
09:39:42.347 --> 09:39:45.347
approximately this much gas and
our simple storage costs

9662
09:39:45.347 --> 09:39:49.347
approximately this much gas.
This is incredibly helpful for

9663
09:39:49.347 --> 09:39:53.347
figuring out how to optimize our
gas as best as possible. Now I

9664
09:39:53.347 --> 09:39:56.347
usually like to take it a step
further though. Having the gas

9665
09:39:56.347 --> 09:40:00.347
output it like that is nice, but
we can make it even better. I

9666
09:40:00.347 --> 09:40:05.347
like to output it to a file by
doing output file. Yes, report

9667
09:40:05.347 --> 09:40:10.347
dot txt and then my dot get
ignore like to add it in here,

9668
09:40:10.347 --> 09:40:15.347
but doing gas report dot txt
sentence it's not really

9669
09:40:15.347 --> 09:40:18.347
important for the gas report to
get pushed up to GitHub. Do no

9670
09:40:18.347 --> 09:40:22.347
colors is true. The reason we
add this is because when we

9671
09:40:22.347 --> 09:40:26.347
output to a file, the colors can
get messed up basically. And

9672
09:40:26.347 --> 09:40:29.347
then the biggest addition we
could do is we can add a

9673
09:40:29.347 --> 09:40:34.348
currency in here. So that we can
get the cost of each function in

9674
09:40:34.348 --> 09:40:38.348
USD for a blockchain like
Aetherium. Now in order to get a

9675
09:40:38.348 --> 09:40:43.348
currency here, we actually need
to get an API key from corn

9676
09:40:43.348 --> 09:40:46.348
market cap, just like we did
with ether scan, you can go to

9677
09:40:46.348 --> 09:40:52.348
coin market cap, corn market cap
API, get your API key now, and

9678
09:40:52.348 --> 09:41:01.348
we'll go ahead and sign up.
Choose a basic plan. We'll agree

9679
09:41:01.348 --> 09:41:05.348
and create my account, we'll get
an email verification. And we'll

9680
09:41:05.348 --> 09:41:10.348
go ahead and verify. Now in the
coin market cap dashboard, we

9681
09:41:10.348 --> 09:41:14.348
can copy our key. And yep, you
guessed it exactly what we're

9682
09:41:14.348 --> 09:41:16.348
going to do with this key, we're
going to drop it into our dot

9683
09:41:16.348 --> 09:41:22.348
env file, or say coin market
cap, API key equals and then

9684
09:41:22.348 --> 09:41:25.348
paste it in there like that. Now
that we have our corn market cap

9685
09:41:25.348 --> 09:41:30.348
API key in here, we can go back
to our header dot config and add

9686
09:41:30.348 --> 09:41:33.348
it in this corn market cap
parameter. We're gonna do the

9687
09:41:33.348 --> 09:41:38.348
exact same way we did above,
we'll do const, coin, market

9688
09:41:38.348 --> 09:41:46.348
cap, API key equals process dot
EMV, that coin market cap API

9689
09:41:46.348 --> 09:41:49.348
key, and then we'll take this
sticking in here. So what this

9690
09:41:49.348 --> 09:41:52.348
is going to do is actually going
to make an API call to corn

9691
09:41:52.348 --> 09:41:56.348
market cap, whenever we run our
gas reporter. This is why

9692
09:41:56.348 --> 09:41:59.348
sometimes you'll see me comment
this out and uncomment it

9693
09:41:59.348 --> 09:42:02.348
because I don't always want it
to make this API calls. But now

9694
09:42:02.348 --> 09:42:05.348
what we can do now that it's
enabled, we have an output file,

9695
09:42:05.348 --> 09:42:08.348
we can see the currency and we
have our API key, all we can do

9696
09:42:08.348 --> 09:42:14.348
is run yarn hardhat test. And
after all our tests pass, we're

9697
09:42:14.348 --> 09:42:18.349
going to see a gas report.tx T
that we can go ahead and read

9698
09:42:18.349 --> 09:42:23.349
from which has that gas report.
And now it actually has the USD

9699
09:42:23.349 --> 09:42:26.349
price of each one of these
transactions, it looks like at

9700
09:42:26.349 --> 09:42:30.349
current prices, with Aetherium
being $3,000 per eath, and a gas

9701
09:42:30.349 --> 09:42:34.349
price of 43 Gwei, the store
function would cost $6. And the

9702
09:42:34.349 --> 09:42:38.349
simple storage function would
cost $64. The current the

9703
09:42:38.349 --> 09:42:40.349
Hardhead gas reporter actually
comes with some different

9704
09:42:40.349 --> 09:42:42.349
options, though, if you're going
to be deploying to different

9705
09:42:42.349 --> 09:42:46.349
network, for example, with
binance, Polygon, Avalanche or

9706
09:42:46.349 --> 09:42:49.349
hecho. For example, let's say we
wanted to deploy the polygon,

9707
09:42:49.349 --> 09:42:53.349
let's see how much deploying the
polygon would cost well in our

9708
09:42:53.349 --> 09:42:57.349
WMV UHD ad token,

9709
09:42:57.349 --> 09:43:03.349
Matic And now we'd rerun this
test. And if we look at our gas

9710
09:43:03.349 --> 09:43:07.349
report that takes T will now see
the gas price of polygon right

9711
09:43:07.349 --> 09:43:12.349
now is around 37 Gray per gas.
And the cost of Matic is 147

9712
09:43:12.349 --> 09:43:15.349
automatic and USD. Now we can
see the cost of calling the

9713
09:43:15.349 --> 09:43:20.349
simple storage method is going
to be $0.00. Now this of course

9714
09:43:20.349 --> 09:43:23.349
is rounded down, but it's going
to be really, really cheap to

9715
09:43:23.349 --> 09:43:26.349
call store versus deploying the
contract is going to cost three

9716
09:43:26.349 --> 09:43:30.349
cents, I make it a habit to
select false for my gas reporter

9717
09:43:30.349 --> 09:43:33.349
whenever I don't want to
actually work with the gas here.

9718
09:43:33.349 --> 09:43:36.349
Awesome. Now sometimes when
we're working with our code, if

9719
09:43:36.349 --> 09:43:39.349
we don't have these environment
variables specified Hardhead

9720
09:43:39.349 --> 09:43:43.349
might get a little bit upset
with us. So oftentimes, I'll add

9721
09:43:43.349 --> 09:43:47.349
some code in here. So that these
variables are always populated,

9722
09:43:47.349 --> 09:43:52.349
because we didn't specify our
rink prpc URL, ring P RPC URL is

9723
09:43:52.349 --> 09:43:56.350
going to be undefined. And that
might throw some errors blow. So

9724
09:43:56.350 --> 09:43:59.350
oftentimes, what we'll do is
I'll add an or parameter here,

9725
09:43:59.350 --> 09:44:03.350
these double pipes mean or, and
in JavaScript, if we say some

9726
09:44:03.350 --> 09:44:06.350
variable equals something or
something else, what is really

9727
09:44:07.350 --> 09:44:10.350
happening is we're gonna say,
okay, rink, the RPC URL is going

9728
09:44:10.350 --> 09:44:15.350
to be equal to process dot E and
V dot rink, the RPC URL. But if

9729
09:44:15.350 --> 09:44:18.350
this rink, the RPC URL doesn't
exist, it's going to be whatever

9730
09:44:18.350 --> 09:44:23.350
else is over here. And I might
write something like HTTPS eath

9731
09:44:23.350 --> 09:44:28.350
Rinkeby. Example, or something
like this, just so that I don't

9732
09:44:28.350 --> 09:44:31.350
make hard hat mad if I don't use
rank B. And we can do something

9733
09:44:31.350 --> 09:44:36.350
like that for all these. So
you'll see this syntax,

9734
09:44:36.350 --> 09:44:42.350
oftentimes in a lot of code
setups. Now the last thing that

9735
09:44:42.350 --> 09:44:45.350
I'm going to show you before
going into the TypeScript

9736
09:44:45.350 --> 09:44:48.350
edition of This is test
coverage. And as we progressed

9737
09:44:48.350 --> 09:44:51.350
to this course, I'm going to
show you more and more tools

9738
09:44:51.350 --> 09:44:54.350
that you can use to make sure
that our simple storage contract

9739
09:44:54.350 --> 09:44:58.350
is safe and secure. And we take
all the steps we can to prevent

9740
09:44:58.350 --> 09:45:01.350
any hacks from happening if we
deploy in real life. One of

9741
09:45:01.350 --> 09:45:04.350
those tools is a tool called
solidity coverage. And this is

9742
09:45:04.350 --> 09:45:07.350
also a hardhat plugin that we
can use for our code. solidity

9743
09:45:07.350 --> 09:45:10.350
coverage is a project that goes
through all of our tests and

9744
09:45:10.350 --> 09:45:15.350
sees exactly how many lines of
code in our sample store dot Sol

9745
09:45:15.350 --> 09:45:18.350
are actually covered. And this
can be a Good tip off. If we

9746
09:45:18.350 --> 09:45:21.350
don't cover some line of code,
solidity coverage will say, Hey,

9747
09:45:21.350 --> 09:45:23.350
you don't have any tests for
this line, maybe you should

9748
09:45:23.350 --> 09:45:26.350
write some tests for it. We can
add solidity coverage the same

9749
09:45:26.350 --> 09:45:29.350
way we've been adding all of our
packages. npm install dash, just

9750
09:45:29.350 --> 09:45:34.350
save Dev, or since we're using
yarn, yarn, add dash dash Dev,

9751
09:45:34.350 --> 09:45:41.351
solidity coverage. And we can
then add this to our config, the

9752
09:45:41.351 --> 09:45:43.351
same way we've been adding
everything to our config, go to

9753
09:45:43.351 --> 09:45:48.351
our config, and we'll write
require solidity coverage. And

9754
09:45:48.351 --> 09:45:50.351
there's some configuration
pieces we can add down here

9755
09:45:50.351 --> 09:45:53.351
below for this, but we're just
going to use the default now we

9756
09:45:53.351 --> 09:45:58.351
can do is run yarn, RT hat
coverage. And this is going to

9757
09:45:58.351 --> 09:46:01.351
go through our tests and print
out a file that looks like this,

9758
09:46:01.351 --> 09:46:04.351
we'll also get a file called
coverage dot JSON, which is

9759
09:46:04.351 --> 09:46:08.351
basically this chart broken down
a little bit more often put my

9760
09:46:08.351 --> 09:46:12.351
coverage dot JSON in my dot get
ignore. And I know we haven't

9761
09:46:12.351 --> 09:46:15.351
actually seen dot Git ignore, do
what it's supposed to do. But we

9762
09:46:15.351 --> 09:46:20.351
will soon we can see here that
about 50% of the code 50% of our

9763
09:46:20.351 --> 09:46:24.351
statements in simple storage dot
soul are covered. About two

9764
09:46:24.351 --> 09:46:27.351
thirds of our functions are and
50% of the lines, It'll even

9765
09:46:27.351 --> 09:46:30.351
give us exactly what lines
aren't tested right now, which

9766
09:46:30.351 --> 09:46:34.351
we can see exactly 31 and 32 of
simple swords, outsole aren't

9767
09:46:34.351 --> 09:46:38.351
covered, which makes a lot of
sense, because 31 to 32 is this

9768
09:46:38.351 --> 09:46:41.351
Add Person function, which we
didn't call and we didn't add to

9769
09:46:41.351 --> 09:46:45.351
our tests. If you want to take
this time to pause and try to

9770
09:46:45.351 --> 09:46:48.351
make this solidity coverage be
100% across the board, by

9771
09:46:48.351 --> 09:46:51.351
writing some more tests, I
highly recommend you do so it'll

9772
09:46:51.351 --> 09:46:54.351
be a great learning exercise.
We'll also add the coverage

9773
09:46:54.351 --> 09:46:57.351
folder. So covered adjacent and
the coverage folder, which

9774
09:46:57.351 --> 09:47:00.351
again, I'll explain what the dot
get ignore folder does a little

9775
09:47:00.351 --> 09:47:06.351
bit later. Now the last thing
that we didn't talk about and

9776
09:47:06.351 --> 09:47:10.351
here was what is this nomic labs
hard hat waffle. We talked about

9777
09:47:10.351 --> 09:47:14.351
Daddy and V heart and ether scan
tasks gas reports. So today,

9778
09:47:14.351 --> 09:47:18.352
what is this? Well, we can
actually Google search this and

9779
09:47:18.352 --> 09:47:21.352
find out exactly what this is
Hardhead waffle is actually a

9780
09:47:21.352 --> 09:47:25.352
plugin to work with the waffle
testing framework. waffle is one

9781
09:47:25.352 --> 09:47:27.352
of these frameworks that allow
us to do some really advanced

9782
09:47:27.352 --> 09:47:30.352
testing, we're going to be
working with some syntax that

9783
09:47:30.352 --> 09:47:33.352
looks really similar to this
really soon. And we'll be

9784
09:47:33.352 --> 09:47:35.352
showing you more and more of
this waffle tool

9785
09:47:35.352 --> 09:47:41.352
as we continue. Alright, the
next part of this section, I'm

9786
09:47:41.352 --> 09:47:43.352
actually going to go over the
TypeScript edition of this. But

9787
09:47:43.352 --> 09:47:46.352
for all intents and purposes,
you've successfully created your

9788
09:47:46.352 --> 09:47:50.352
first Hardhead project, you've
done a ton of amazing things. In

9789
09:47:50.352 --> 09:47:53.352
this lesson, let's do a quick
refresher of what we've learned

9790
09:47:53.352 --> 09:47:57.352
so far, we learned how to spin
up our own hard hat projects.

9791
09:47:57.352 --> 09:48:02.352
And now we can run yarn, hard
hat and see a list of the tasks

9792
09:48:02.352 --> 09:48:06.352
and different things that we can
do with hard hat. We learned

9793
09:48:06.352 --> 09:48:10.352
that hard hat looks for this
hard hat.config.js. And this is

9794
09:48:10.352 --> 09:48:13.352
sort of the entry point for any
task that we run that starts

9795
09:48:13.352 --> 09:48:16.352
with hard hat, we learned we can
add our contracts to this

9796
09:48:16.352 --> 09:48:20.352
contracts folder. And then we
compile it by running yarn, art

9797
09:48:20.352 --> 09:48:24.352
half compile, we learned that
all the compliation goes into

9798
09:48:24.352 --> 09:48:28.352
the artifacts and then the cache
as well. And if we want to clean

9799
09:48:28.352 --> 09:48:30.352
reset, we can either delete
these two files or just run

9800
09:48:30.352 --> 09:48:34.352
yarn, hard hat clean. So we
learned that we can use scripts

9801
09:48:34.352 --> 09:48:38.352
or tasks to actually deploy,
interact and do things with our

9802
09:48:38.352 --> 09:48:40.352
smart contracts. We also learned
that I'm going to be using

9803
09:48:40.352 --> 09:48:43.352
scripts for the rest of this
course. But if you want, you

9804
09:48:43.352 --> 09:48:46.352
could absolutely use tasks as
well. I've asked this question a

9805
09:48:46.352 --> 09:48:49.352
million times what's the
difference? Nobody really seems

9806
09:48:49.352 --> 09:48:51.352
to know what the main difference
is. But I think the main

9807
09:48:51.352 --> 09:48:54.352
difference is that tasks are for
plugins. And scripts are for

9808
09:48:54.352 --> 09:48:57.353
your local development Mart,
that is mind limiter, we learned

9809
09:48:57.353 --> 09:49:01.353
that we can import a whole bunch
of things, including tasks from

9810
09:49:01.353 --> 09:49:03.353
hard hat in our scripts, and we
can work with our async

9811
09:49:03.353 --> 09:49:07.353
functions to grab our contracts
and deploy them, we actually

9812
09:49:07.353 --> 09:49:11.353
then can programmatically verify
them using hard hat and using

9813
09:49:11.353 --> 09:49:14.353
hard hat plugins. And then
additionally, we can interact

9814
09:49:14.353 --> 09:49:17.353
with our contracts very similar
to how we did it with ethers. We

9815
09:49:17.353 --> 09:49:20.353
wrote a wonderful verification
script. And we also wrote our

9816
09:49:20.353 --> 09:49:24.353
own task, we wrote our first
test for this whole space. And

9817
09:49:24.353 --> 09:49:27.353
we showed what our tests are
going to look like moving

9818
09:49:27.353 --> 09:49:30.353
forward. And we talked a little
bit about their importance. And

9819
09:49:30.353 --> 09:49:33.353
I really should stress that
writing good tests is going to

9820
09:49:33.353 --> 09:49:36.353
be the difference between a
really professional environment

9821
09:49:36.353 --> 09:49:38.353
and kind of a side project.
Whenever I audit smart

9822
09:49:38.353 --> 09:49:41.353
contracts, or whenever I'm given
a project for someone to tell me

9823
09:49:41.353 --> 09:49:45.353
to take a look at. The first
thing I look at is the readme,

9824
09:49:45.353 --> 09:49:48.353
of course. And the second thing
I look at is the tests. And if

9825
09:49:48.353 --> 09:49:51.353
tests aren't good, I usually
tell them, hey, you need to go

9826
09:49:51.353 --> 09:49:54.353
back to the drawing board, and
you need to level up your tests.

9827
09:49:54.353 --> 09:49:57.353
So tests are really really
important, especially for this

9828
09:49:57.353 --> 09:50:00.353
space, we learned about a couple
of more environment variables we

9829
09:50:00.353 --> 09:50:03.353
can use. We learned about a
couple of tools to see how good

9830
09:50:03.353 --> 09:50:07.353
our tests are one of them being
coverage. We also learn about a

9831
09:50:07.353 --> 09:50:10.353
gas reporter to see how much
it's going to cost us when we

9832
09:50:10.353 --> 09:50:13.353
actually deploy to a real
network. We learned a ton about

9833
09:50:13.353 --> 09:50:16.353
the hard hat config, and how
there are multiple networks that

9834
09:50:16.353 --> 09:50:19.353
we can add add to our hard
heads, we can make our project

9835
09:50:19.353 --> 09:50:23.353
our EVM code, work with any
network out there, we started

9836
09:50:23.353 --> 09:50:26.353
working with dev dependencies
instead of regular dependencies.

9837
09:50:26.353 --> 09:50:29.353
Now, READMEs are something that
I'm not really going to go over

9838
09:50:29.353 --> 09:50:33.353
too deeply in here. But READMEs
are sort of like the welcome

9839
09:50:33.353 --> 09:50:36.354
page of your GitHub repository,
and really should give you an

9840
09:50:36.354 --> 09:50:39.354
understanding of what your code
does. Being a part of the web

9841
09:50:39.354 --> 09:50:42.354
through space. And being a part
of the blockchain ecosystem is

9842
09:50:42.354 --> 09:50:45.354
really more than just you coding
your stuff by yourself. You want

9843
09:50:45.354 --> 09:50:48.354
other people to interact and
engage with your code and engage

9844
09:50:48.354 --> 09:50:50.354
with your projects. I haven't
showed you how to use GitHub

9845
09:50:50.354 --> 09:50:53.354
yet. But don't worry, we're
going to but if you look at my

9846
09:50:53.354 --> 09:50:56.354
heart had simple storage readme.
If you scroll down, usually, you

9847
09:50:56.354 --> 09:50:59.354
really want to have a Getting
Started section where you define

9848
09:50:59.354 --> 09:51:02.354
how to set up all the code and
how to set everything up a

9849
09:51:02.354 --> 09:51:06.354
Quickstart section, and maybe a
usage section and some testing

9850
09:51:06.354 --> 09:51:09.354
section, which teaches people
how to actually use and interact

9851
09:51:09.354 --> 09:51:12.354
with your code. Since we're just
learning more of the code part

9852
09:51:12.354 --> 09:51:15.354
and not so much the readme part.
For now, we're not going to go

9853
09:51:15.354 --> 09:51:18.354
over how to make a fantastic
readme. However, I will leave a

9854
09:51:18.354 --> 09:51:20.354
link in the GitHub repository
associated with this course,

9855
09:51:20.354 --> 09:51:23.354
link to this best readme
template. It really is a

9856
09:51:23.354 --> 09:51:26.354
fantastic readme template that
you can copy to any of your

9857
09:51:26.354 --> 09:51:29.354
projects to make them look
really good and give them a

9858
09:51:29.354 --> 09:51:32.354
really good setup, so that other
developers can come to your

9859
09:51:32.354 --> 09:51:35.354
project, and learn and
participate with what you're

9860
09:51:35.354 --> 09:51:38.354
coding. But all right, you have
learned an absolute ton, you

9861
09:51:38.354 --> 09:51:41.354
should be incredibly proud of
yourself, and incredibly excited

9862
09:51:41.354 --> 09:51:44.354
that you've made it this far.
Now I'm going to jump into the

9863
09:51:44.354 --> 09:51:46.354
TypeScript section here. So for
those of you who are coding

9864
09:51:46.354 --> 09:51:49.354
along with TypeScript, feel free
to follow along. For those of

9865
09:51:49.354 --> 09:51:52.354
you who are not, you just
finished the Basic section on

9866
09:51:52.354 --> 09:51:55.354
hard hit, but stick around the
next to heart out sections are

9867
09:51:55.354 --> 09:51:58.354
going to be the ones that really
fine grain and hone your skills,

9868
09:51:58.354 --> 09:52:01.354
and give you all the
fundamentals for working with

9869
09:52:01.354 --> 09:52:04.354
these frameworks. So be sure to
follow along with the next two

9870
09:52:04.354 --> 09:52:07.354
sections, we've got a ton more
fantastic content for you, we

9871
09:52:07.354 --> 09:52:10.354
are just beginning to get deeper
into the smart contract

9872
09:52:10.354 --> 09:52:14.354
ecosystem. So take that lap, get
that coffee, and I'll see you

9873
09:52:14.354 --> 09:52:20.355
soon. Alright, also now let's do
this with TypeScript. So I am

9874
09:52:20.355 --> 09:52:22.355
going to go ahead and just start
this from our JavaScript

9875
09:52:22.355 --> 09:52:25.355
section. However, if in the
future, you want to start a new

9876
09:52:25.355 --> 09:52:29.355
Hardhead project, you can
actually start a new project

9877
09:52:29.355 --> 09:52:34.355
with yarn, hard hat. And then do
great and advanced sample

9878
09:52:34.355 --> 09:52:38.355
project that uses TypeScript,
you'll add a ton of plugins. And

9879
09:52:38.355 --> 09:52:41.355
you'll wait a while for
everything to get uploaded. And

9880
09:52:41.355 --> 09:52:43.355
you wait, and you wait a little
bit for everything to get

9881
09:52:43.355 --> 09:52:45.355
downloaded. We're not going to
do that though, because I'm

9882
09:52:45.355 --> 09:52:48.355
going to show you how to convert
this to JavaScript Anyways, if

9883
09:52:48.355 --> 09:52:51.355
in future hearted sections, as
we're coding along with

9884
09:52:51.355 --> 09:52:53.355
JavaScript, if you want to code
along with TypeScript, you

9885
09:52:53.355 --> 09:52:57.355
absolutely 100% can. But let's
go ahead and show you what the

9886
09:52:57.355 --> 09:52:59.355
main differences are. Now that
advanced TypeScript thing is

9887
09:52:59.355 --> 09:53:01.355
going to add a whole bunch of
packages that you may or may not

9888
09:53:01.355 --> 09:53:04.355
want, I will talk about some of
them in our next lesson. But

9889
09:53:04.355 --> 09:53:07.355
there are going to be some that
you absolutely do need. Those

9890
09:53:07.355 --> 09:53:14.355
are going to be at type chain
slash ethers, dash v five, at

9891
09:53:14.355 --> 09:53:20.355
type chain, slash hard hat, at
TypeScript, at types, slash

9892
09:53:20.355 --> 09:53:28.355
Chai, at types, slash node, at
types slash moko, TS node, type

9893
09:53:28.355 --> 09:53:33.355
chain and TypeScript. And I have
a link in the GitHub repo

9894
09:53:33.355 --> 09:53:36.355
associated with this course,
I've got this yarn ad that you

9895
09:53:36.355 --> 09:53:39.355
can just copy paste, if you want
to just copy paste that into

9896
09:53:39.355 --> 09:53:41.355
your project to run it. Oops,
and I should have added those as

9897
09:53:41.355 --> 09:53:44.355
dev dependencies. So we're going
to actually just make them dev

9898
09:53:44.355 --> 09:53:47.355
dependencies real quick, just by
deleting these two lines, and

9899
09:53:47.355 --> 09:53:51.355
adding a comma here. Awesome,
that looks much better. And then

9900
09:53:51.355 --> 09:53:54.355
of course, what we're going to
do is we're going to convert all

9901
09:53:54.355 --> 09:53:59.356
of our JavaScript to TypeScript.
So anywhere where we have J S,

9902
09:53:59.356 --> 09:54:01.356
we're going to put Ts,
obviously, if you're coding this

9903
09:54:01.356 --> 09:54:04.356
from scratch with TypeScript,
you would do the.ts From the get

9904
09:54:04.356 --> 09:54:08.356
go. This includes our hard hat
dot config, that's also going to

9905
09:54:08.356 --> 09:54:10.356
be TypeScript now. And
additionally, we're going to add

9906
09:54:10.356 --> 09:54:14.356
a TS config dot JSON. This is
going to be our TypeScript

9907
09:54:14.356 --> 09:54:16.356
configuration. Typically, for a
setup, we're gonna go with

9908
09:54:16.356 --> 09:54:19.356
something like this. And you can
copy this from the GitHub repo

9909
09:54:19.356 --> 09:54:21.356
associated with this course.
It's basically telling

9910
09:54:21.356 --> 09:54:24.356
TypeScript, what versions of
Typescript and what files to

9911
09:54:24.356 --> 09:54:27.356
include for working with
TypeScript. Now let's go ahead

9912
09:54:27.356 --> 09:54:30.356
and start with our deploy dot
TypeScript. For usual, instead

9913
09:54:30.356 --> 09:54:34.356
of using require, we're gonna go
ahead and use import, we're

9914
09:54:34.356 --> 09:54:37.356
gonna do the exact same thing.
We're gonna have import ethers

9915
09:54:37.356 --> 09:54:45.356
run network, from hard hat. And
then in our verify function,

9916
09:54:45.356 --> 09:54:48.356
we're going to add that we're
gonna add the types for these

9917
09:54:48.356 --> 09:54:52.356
arguments. So contract address,
is going to be a string. And

9918
09:54:52.356 --> 09:54:56.356
args is going to be an array of
arguments. So we're gonna say

9919
09:54:56.356 --> 09:54:59.356
it's gonna be any array, because
it could be string, it could be

9920
09:54:59.356 --> 09:55:02.356
numbers, it could be balloons,
it could be anything. We're also

9921
09:55:02.356 --> 09:55:04.356
going to say for IE, it could be
any, even though this is

9922
09:55:04.356 --> 09:55:08.356
technically an error type, we're
just going to put any for

9923
09:55:08.356 --> 09:55:12.356
simplicity. For now. All of our
TypeScript scripts are included

9924
09:55:12.356 --> 09:55:15.356
in our TS config, or any
TypeScript files are manually

9925
09:55:15.356 --> 09:55:18.356
added here, which we have Our
entire scripts folder here,

9926
09:55:18.356 --> 09:55:22.356
which is good. So now we need to
add ethers in here. Well, if we

9927
09:55:22.356 --> 09:55:27.356
look at our hardhead.config.ts,
we're using require here still,

9928
09:55:27.356 --> 09:55:30.356
and we need to swap this out for
import for Donnie V, you can use

9929
09:55:30.356 --> 09:55:34.356
dot env slash config for it to
grab your dot env file. Now that

9930
09:55:34.356 --> 09:55:38.357
we've imported everything, go
back to our deploy.ts, we can

9931
09:55:38.357 --> 09:55:41.357
see that that linting has gone
away. If you want to be even

9932
09:55:41.357 --> 09:55:45.357
more explicit, we can go ahead
and add import at nomic labs

9933
09:55:45.357 --> 09:55:50.357
slash hard hat ethers like so.
reason we don't need to import

9934
09:55:50.357 --> 09:55:54.357
it here is because these two
packages also work with Hardhead

9935
09:55:54.357 --> 09:55:56.357
ethers, so they automatically
import it. But if you want to be

9936
09:55:56.357 --> 09:56:00.357
super explicit, you can go ahead
and add it like so. Now, we're

9937
09:56:00.357 --> 09:56:03.357
almost good to go. But remember,
our Harnett dot config is also

9938
09:56:03.357 --> 09:56:06.357
importing our tasks. So we're
going to need to update our

9939
09:56:06.357 --> 09:56:11.357
tasks or block number to be
TypeScript fide. So of course,

9940
09:56:11.357 --> 09:56:16.357
instead of const require, we're
going to import task from our

9941
09:56:16.357 --> 09:56:19.357
that slash config. And we're
going to be sure to export our

9942
09:56:19.357 --> 09:56:23.357
task from lock number as the
default. So we're going to do

9943
09:56:23.357 --> 09:56:28.357
export default task like so. And
now we should be good to run our

9944
09:56:28.357 --> 09:56:34.357
scripts. So we can just do yarn,
art hat, run scripts,

9945
09:56:34.357 --> 09:56:38.357
employee.ts. We can do network
hard hat if we choose. And

9946
09:56:38.357 --> 09:56:42.357
awesome. Now, it's when we get
to the testing, that things get

9947
09:56:42.357 --> 09:56:45.357
a little bit different here. So
let's go ahead and change this

9948
09:56:45.357 --> 09:56:50.357
required to import. Just to make
it happy there. Let's try to run

9949
09:56:50.357 --> 09:56:55.357
yarn, art head test, we get a
whole bunch of errors, and in VS

9950
09:56:55.357 --> 09:56:58.357
code will actually go ahead and
get these errors right from the

9951
09:56:58.357 --> 09:57:02.357
linter. One of the trickiest
things that you run into as a

9952
09:57:02.357 --> 09:57:06.357
developer in this space is
calling functions on contracts

9953
09:57:06.357 --> 09:57:09.357
where those functions don't
exist, or vice versa. We're not

9954
09:57:09.357 --> 09:57:12.357
calling functions on contracts
that do exist. Right now the

9955
09:57:12.357 --> 09:57:17.358
typing for our contracts is just
type contract, which isn't super

9956
09:57:17.358 --> 09:57:20.358
helpful, because type contract
doesn't necessarily have all the

9957
09:57:20.358 --> 09:57:23.358
functions that we want it to
have. We want our contracts to

9958
09:57:23.358 --> 09:57:27.358
be of type contract, but we want
them to be of the type of our

9959
09:57:27.358 --> 09:57:30.358
contract, because if they're the
type of our contract, they can

9960
09:57:30.358 --> 09:57:33.358
have all the functions that we
want them to have. So to give

9961
09:57:33.358 --> 09:57:37.358
our contracts the correct typing
here, we actually can use this

9962
09:57:37.358 --> 09:57:40.358
tool called type chain, which
gives our contracts correct

9963
09:57:40.358 --> 09:57:44.358
typing type chain has a hardened
plugin, which allows us to use

9964
09:57:44.358 --> 09:57:47.358
type chain and TypeScript
natively together, type chain

9965
09:57:47.358 --> 09:57:49.358
slash hard hat was one of these
things that we already

9966
09:57:49.358 --> 09:57:53.358
installed. And to add it to our
hard hat, we got to just go to

9967
09:57:53.358 --> 09:57:59.358
the hard hat config, and add it
in import at type chain slash

9968
09:57:59.358 --> 09:58:03.358
arhat. Now once we import that
in to our config, if we run yarn

9969
09:58:03.358 --> 09:58:08.358
hardhat, we now get a new task
here called type chain, you read

9970
09:58:08.358 --> 09:58:11.358
the description, it says
generate type chain typings for

9971
09:58:11.358 --> 09:58:15.358
compiled contracts, this will
enable all of our contracts to

9972
09:58:15.358 --> 09:58:18.358
have their own typing. So we can
have a simple storage variable

9973
09:58:18.358 --> 09:58:22.358
of type simple storage contract,
which is much better, because

9974
09:58:22.358 --> 09:58:25.358
we're always going to know
exactly what we can do with each

9975
09:58:25.358 --> 09:58:28.358
contract. To create this, we run
yarn,

9976
09:58:28.358 --> 09:58:35.358
arhat type chain. And this is
going to create a new folder

9977
09:58:35.358 --> 09:58:39.358
called type chain slash types.
With types for all of our

9978
09:58:39.358 --> 09:58:42.358
contracts, you can even go into
our simple storage sub Ts, which

9979
09:58:42.358 --> 09:58:44.358
is going to have all the
different functions and

9980
09:58:44.358 --> 09:58:48.358
everything to do with our simple
storage contract automatically

9981
09:58:48.358 --> 09:58:51.358
coded into Typescript and
JavaScript for us, which is

9982
09:58:51.358 --> 09:58:54.358
incredibly helpful. And again,
no, I haven't shown you what

9983
09:58:54.358 --> 09:58:57.359
this is yet. But in our dot Git
ignore, we usually want to add

9984
09:58:57.359 --> 09:59:01.359
type chain and type chain dash
types into our dot Git ignore so

9985
09:59:01.359 --> 09:59:04.359
we don't push them up to GitHub.
Now back in our test, we're

9986
09:59:04.359 --> 09:59:09.359
going to add the exact types of
these different objects here. So

9987
09:59:09.359 --> 09:59:12.359
we're going to import them from
that folder that we just

9988
09:59:12.359 --> 09:59:17.359
created. So we'll do import
simple storage, comma, simple

9989
09:59:17.359 --> 09:59:24.359
storage underscore underscore
factory from dot dot slash

9990
09:59:24.359 --> 09:59:29.359
types, ain slash types, the
simple storage factory is going

9991
09:59:29.359 --> 09:59:32.359
to be simple storage factory and
then civil storage of course, is

9992
09:59:32.359 --> 09:59:36.359
going to be simple storage. So
now when do let simple storage

9993
09:59:36.359 --> 09:59:42.359
factory which is going to be of
type, simple storage, underscore

9994
09:59:42.359 --> 09:59:46.359
underscore factory, and then
simple storage, which is going

9995
09:59:46.359 --> 09:59:51.359
to be of type simple storage
contract. And if we command

9996
09:59:51.359 --> 09:59:55.359
clicked into simple storage,
once again, we can see all the

9997
09:59:55.359 --> 09:59:59.359
contract functions that we know
and love, are here. In addition,

9998
09:59:59.359 --> 10:00:03.359
we have all the functions of the
actual contract itself. Once we

9999
10:00:03.359 --> 10:00:06.359
do that, we're pretty much good
to go we just need to have a

10000
10:00:06.359 --> 10:00:10.359
couple of new things here. Get
contract factory returns a type

10001
10:00:10.359 --> 10:00:13.359
ethers dot contract factory. So
what we just need to do is we

10002
10:00:13.359 --> 10:00:17.359
need to wrap this in a simple
storage factory type. So We'll

10003
10:00:17.359 --> 10:00:21.359
just do a little wrap like this.
And we'll say, as simple

10004
10:00:21.359 --> 10:00:25.359
storage, I'm just going to sort
of factory. And that's good to

10005
10:00:25.359 --> 10:00:28.359
go. Now that we've added all
this, we can run yarn, Hardhead

10006
10:00:28.359 --> 10:00:33.359
test. And boom, our test run is
normal, but with TypeScript and

10007
10:00:33.359 --> 10:00:37.360
with this additional typing that
makes our lives substantially

10008
10:00:37.360 --> 10:00:39.360
substantially better. And that's
going to be all you need to know

10009
10:00:39.360 --> 10:00:43.360
for TypeScript, reusable, all of
the branches have an optional

10010
10:00:43.360 --> 10:00:46.360
TypeScript branch that you can
use to reference to work with

10011
10:00:46.360 --> 10:00:51.360
TypeScript.

10012
10:00:51.360 --> 10:00:53.360
We've learned really just the
basics of all the different

10013
10:00:53.360 --> 10:00:56.360
things we can do with hardhat.
And these next few lessons

10014
10:00:56.360 --> 10:00:59.360
Hardhead fun meme and hard hat
smart contract lottery are

10015
10:00:59.360 --> 10:01:02.360
really going to be the basics
for all the fundamentals of all

10016
10:01:02.360 --> 10:01:05.360
the tools that we're going to
learn in hardhat. Lesson Eight

10017
10:01:05.360 --> 10:01:07.360
is going to be our introduction
to full stack and working with

10018
10:01:07.360 --> 10:01:11.360
front end and building full
stack applications. Getting all

10019
10:01:11.360 --> 10:01:14.360
the way through this course will
give you all the tools to start

10020
10:01:14.360 --> 10:01:17.360
your web three journey. But if
you're looking to just learn

10021
10:01:17.360 --> 10:01:20.360
just the basics, make sure you
absolutely get all the way to

10022
10:01:20.360 --> 10:01:24.360
Lesson Nine. And if you get all
the way through lesson 18, you

10023
10:01:24.360 --> 10:01:26.360
are going to know all of the
cutting edge tools for this

10024
10:01:26.360 --> 10:01:29.360
space. And you're going to have
the knowledge to become easily

10025
10:01:29.360 --> 10:01:32.360
one of the best developers in
the space. So hope you make it

10026
10:01:32.360 --> 10:01:35.360
all the way through to the end.
Now one of the most important

10027
10:01:35.360 --> 10:01:38.360
parts of this section of this
lesson is going to be pushing

10028
10:01:38.360 --> 10:01:42.360
our code up to GitHub, and then
sending a tweet celebrating that

10029
10:01:42.360 --> 10:01:45.360
we pushed our first smart
contract our first web three

10030
10:01:45.360 --> 10:01:49.360
GitHub repository to GitHub. So
before moving on to the next

10031
10:01:49.360 --> 10:01:53.360
lesson, be absolutely sure to
get to the end of this and push

10032
10:01:53.360 --> 10:01:57.360
this code up to GitHub. And then
optionally, if you want to

10033
10:01:57.360 --> 10:02:00.360
celebrate by sending a tweet,
but be absolutely sure to get to

10034
10:02:00.360 --> 10:02:02.360
the GitHub section, because as
I've said, many times the web

10035
10:02:02.360 --> 10:02:05.360
three space is this incredibly
collaborative community and

10036
10:02:05.360 --> 10:02:09.360
working with GitHub or GitLab,
or any other version control

10037
10:02:09.360 --> 10:02:12.360
tool is going to be essential
for your success in the space.

10038
10:02:12.360 --> 10:02:16.361
So be sure to get to that part.
All right. Now, welcome back to

10039
10:02:16.361 --> 10:02:21.361
the hard hat Fund Me section of
our course. This is the section

10040
10:02:21.361 --> 10:02:24.361
where we're actually going to
upload our first code repository

10041
10:02:24.361 --> 10:02:28.361
to GitHub if you've never done
this before, this is going to be

10042
10:02:28.361 --> 10:02:31.361
the section where we're going to
learn even more about hardhat

10043
10:02:31.361 --> 10:02:34.361
using a familiar contract base
we've already worked with, which

10044
10:02:34.361 --> 10:02:37.361
is the fund me contract. And
again, if you're using the

10045
10:02:37.361 --> 10:02:40.361
GitHub repo associated with this
course, you can scroll down to

10046
10:02:40.361 --> 10:02:46.361
the Hardhead Funmi. And all the
code is located in our repo. If

10047
10:02:46.361 --> 10:02:48.361
you'd like to do a quickstart,
you can go ahead and get clone

10048
10:02:48.361 --> 10:02:52.361
it CVU into it, and then run
yarn, and then just run yarn

10049
10:02:52.361 --> 10:02:56.361
hardhat deploy this, I'm going
to briefly show you what that

10050
10:02:56.361 --> 10:03:01.361
looks like. So in your in your
VS code, you can do git clone,

10051
10:03:01.361 --> 10:03:08.361
grab the package, cd into it,
and then type code period. To

10052
10:03:08.361 --> 10:03:12.361
open it up in a new VS code.
Once you're in your folder, you

10053
10:03:12.361 --> 10:03:15.361
can go ahead and run yarn. To
install all the dependencies for

10054
10:03:15.361 --> 10:03:17.361
working with this project, you
plan on working with the test

10055
10:03:17.361 --> 10:03:21.361
net or working with ether scan
or coin market cap, feel free to

10056
10:03:21.361 --> 10:03:25.361
fill out your Dotty and V with a
private key RPC URL, corn market

10057
10:03:25.361 --> 10:03:28.361
cap key and ether scan key. And
then you can just follow along

10058
10:03:28.361 --> 10:03:34.361
with the readme to use this repo
to run yarn, hard hat deploy.

10059
10:03:34.361 --> 10:03:37.361
And it'll show you deploying
some contracts and some mocks,

10060
10:03:37.361 --> 10:03:43.361
etc. So let's get to building
this ourselves though. Now we're

10061
10:03:43.361 --> 10:03:45.361
gonna make a new directory for
this project, it's gonna be the

10062
10:03:45.361 --> 10:03:53.361
same setup we've seen before. MK
dir, hard hat. And me, FCC,

10063
10:03:53.361 --> 10:03:56.362
we're gonna cd into heart at
Funmi, FCC, and then type code

10064
10:03:56.362 --> 10:03:59.362
period. And if code period
doesn't work for you, you can

10065
10:03:59.362 --> 10:04:04.362
absolutely open this up by
hitting File, Open Folder, like

10066
10:04:04.362 --> 10:04:07.362
we showed you before. Now, we're
in a brand new folder here. And

10067
10:04:07.362 --> 10:04:10.362
we're gonna go ahead and add
hard hat here. And we're gonna

10068
10:04:10.362 --> 10:04:19.362
run yarn, add dash dash Dev,
hard hat. Now that we have hard

10069
10:04:19.362 --> 10:04:23.362
hat, in our package, JSON, and
in our node modules, we can go

10070
10:04:23.362 --> 10:04:27.362
ahead and run yarn, start app.
And this will say, What do you

10071
10:04:27.362 --> 10:04:30.362
want to do? I'm going to choose
the advanced sample project

10072
10:04:30.362 --> 10:04:33.362
here, just to show you what's
going on. And we're going to set

10073
10:04:33.362 --> 10:04:36.362
this up in a way that I think
works best. So we'll go ahead

10074
10:04:36.362 --> 10:04:38.362
and do the advanced sample
project. Yes, we're going to

10075
10:04:38.362 --> 10:04:41.362
have that as the root. Yes, we
want to add a Git ignore. And

10076
10:04:41.362 --> 10:04:44.362
there are a lot of sample
project dependencies that it

10077
10:04:44.362 --> 10:04:47.362
wants us to add. We're gonna go
ahead and hit yes. But we're

10078
10:04:47.362 --> 10:04:50.362
going to end up not using all of
these and I'll show you which

10079
10:04:50.362 --> 10:04:53.362
ones we're not going to use and
why. But for now, let's go ahead

10080
10:04:53.362 --> 10:05:02.362
and hit yes.

10081
10:05:02.362 --> 10:05:06.362
All right, awesome. And now we
have an advanced project in

10082
10:05:06.362 --> 10:05:08.362
here. Let me walk you through
the additional things that are

10083
10:05:08.362 --> 10:05:11.362
in here. So we have a
traditional contract node

10084
10:05:11.362 --> 10:05:14.362
modules, which is going to be
the same scripts is going to be

10085
10:05:14.362 --> 10:05:18.362
the same test is going to be the
same. But this comes with a dot

10086
10:05:18.362 --> 10:05:21.362
E and V dot example already
packed in for us. It also comes

10087
10:05:21.362 --> 10:05:28.362
with.es lint files.es lint, RC
dot j s.es. Lint, ignore es Lint

10088
10:05:28.362 --> 10:05:31.362
is known as a JavaScript linter,
which helps you find and

10089
10:05:31.362 --> 10:05:34.362
automatically fix problems in
your code for the JavaScript

10090
10:05:34.362 --> 10:05:37.363
that I work with. I'm not a big
fan of ES lint, so I typically

10091
10:05:37.363 --> 10:05:40.363
don't use it. So I'm going to go
ahead and delete the two of

10092
10:05:40.363 --> 10:05:43.363
these. If you want to keep them
in you absolutely can dot Git

10093
10:05:43.363 --> 10:05:46.363
ignore. We're going to finally
understand what this file does

10094
10:05:46.363 --> 10:05:50.363
in this lesson that NPM ignore
helps Ignore files if you want

10095
10:05:50.363 --> 10:05:53.363
to push your project up to be an
NPM package, which we're not

10096
10:05:53.363 --> 10:05:56.363
going to do. So if you want to
delete this, you can as well

10097
10:05:56.363 --> 10:05:58.363
pretty or ignore it and pretty
DRC. We already know what these

10098
10:05:58.363 --> 10:06:01.363
do small hint. And so hint
ignore, which we're going to

10099
10:06:01.363 --> 10:06:04.363
talk about it in a minute, or
Hardhead config, which just

10100
10:06:04.363 --> 10:06:08.363
comes already with a ropsten
network, a gas reporter and

10101
10:06:08.363 --> 10:06:11.363
ether scan package dot JSON with
all the additional packages, the

10102
10:06:11.363 --> 10:06:14.363
readme is a little bit more
robust. And then of course, our

10103
10:06:14.363 --> 10:06:17.363
yarn dot lock. So this advanced
project looks pretty similar to

10104
10:06:17.363 --> 10:06:22.363
what we're going to be working
with anyways. Now I do want to

10105
10:06:22.363 --> 10:06:25.363
talk about this soul hint,
though. So what is solvent

10106
10:06:25.363 --> 10:06:30.363
solvent is known as a solidity
linter that we can use to lint

10107
10:06:30.363 --> 10:06:33.363
our code linting is the process
of running a program that will

10108
10:06:33.363 --> 10:06:36.363
analyze code for potential
errors. It also does a little

10109
10:06:36.363 --> 10:06:40.363
bit of formatting, oftentimes,
es Lint is a way to lint for

10110
10:06:41.363 --> 10:06:45.363
JavaScript code. So hint is a
way to lint for solidity code,

10111
10:06:45.363 --> 10:06:48.363
we use prettier to format our
code, and we can use soul hint

10112
10:06:48.363 --> 10:06:51.363
to lint, our code, they are
often used a little bit

10113
10:06:51.363 --> 10:06:54.363
interchangeably, even though
that's not exactly correct, as

10114
10:06:54.363 --> 10:06:56.363
they are a little bit different.
We can run this linter on our

10115
10:06:56.363 --> 10:07:01.363
code by running yarn, sole hint,
and then type the name of the

10116
10:07:01.363 --> 10:07:06.363
files that we want to lint. So
we do contracts, slash and then

10117
10:07:06.363 --> 10:07:10.363
you can just do start out so
everything looks okay, nothing

10118
10:07:10.363 --> 10:07:13.363
will happen. Well, let's say we
have a variable that we don't

10119
10:07:13.363 --> 10:07:18.364
explicitly say the visibility of
it is. This isn't the best

10120
10:07:18.364 --> 10:07:22.364
practice because ideally, we
always say exactly what the

10121
10:07:22.364 --> 10:07:25.364
visibility of some variable is.
This obviously gets defaulted.

10122
10:07:25.364 --> 10:07:28.364
But it's usually better to be
more explicit. So now if we run

10123
10:07:28.364 --> 10:07:35.364
yarn, so hint, contracts start
up so it'll give us a warning,

10124
10:07:35.364 --> 10:07:39.364
saying we should explicitly Mark
visibility of state, this linter

10125
10:07:39.364 --> 10:07:42.364
is a good way to check for some
best practices for running our

10126
10:07:42.364 --> 10:07:48.364
code. So we're definitely going
to keep a small hint around. Now

10127
10:07:48.364 --> 10:07:51.364
that we've got a repo here,
let's add a couple of our common

10128
10:07:51.364 --> 10:07:56.364
setup pieces here. So in
prettier.rc, we're going to swap

10129
10:07:56.364 --> 10:08:00.364
this out with what we've been
using so far. Tab of the form us

10130
10:08:00.364 --> 10:08:04.364
tab is false, semi false, single
quote, also false. We're going

10131
10:08:04.364 --> 10:08:08.364
to update our prettier dot
ignore node modules, package dot

10132
10:08:08.364 --> 10:08:12.364
JSON image artifacts, cache
coverage ID v dot star, readme,

10133
10:08:12.364 --> 10:08:16.364
and coverage and anything else
you want to add in here. And

10134
10:08:16.364 --> 10:08:19.364
we're going to scroll up to our
contracts folder. And we're

10135
10:08:19.364 --> 10:08:22.364
going to swap this greeter dot
soul out with our fund me dot

10136
10:08:22.364 --> 10:08:26.364
soul. Now let's go ahead and add
our contracts in here. If you're

10137
10:08:26.364 --> 10:08:29.364
following along with the repo,
you go to the contracts folder,

10138
10:08:29.364 --> 10:08:33.364
there's actually another folder
in here and the contracts look a

10139
10:08:33.364 --> 10:08:36.364
little bit different. So if you
have those contracts, steal from

10140
10:08:36.364 --> 10:08:39.364
remix, let's actually grab them
from remix because we're going

10141
10:08:39.364 --> 10:08:42.364
to make a couple of changes to
them. If you don't have remix up

10142
10:08:42.364 --> 10:08:44.364
anymore, which you probably
shouldn't, because you should be

10143
10:08:44.364 --> 10:08:48.364
taking breaks, you can jump back
over to Lesson four remix Funmi

10144
10:08:48.364 --> 10:08:52.364
jump into the repo here and grab
the contracts from inside here.

10145
10:08:52.364 --> 10:08:55.364
Just go to the fun v dash Free
Code Camp tutorial and grab the

10146
10:08:55.364 --> 10:08:58.365
code from there. So we're gonna
grab just fun me and price

10147
10:08:58.365 --> 10:09:02.365
converter dot soul. So go ahead
and delete that old file, create

10148
10:09:02.365 --> 10:09:07.365
a new one and call it fund me
dot song. Paste it in there. And

10149
10:09:07.365 --> 10:09:13.365
then we're going to create the
price converter. That's all. Now

10150
10:09:13.365 --> 10:09:17.365
we have both our Funmi and our
price converter contracts in

10151
10:09:17.365 --> 10:09:19.365
here. Now one of the first
things that we want to do one of

10152
10:09:19.365 --> 10:09:21.365
the first things that we did
last time was we ran yarn

10153
10:09:21.365 --> 10:09:24.365
compile to make sure that our
code is actually working the way

10154
10:09:24.365 --> 10:09:27.365
we want to. And before we
actually hit Compile, one of the

10155
10:09:27.365 --> 10:09:29.365
things that we're going to need
to do is come to our Hardhead

10156
10:09:29.365 --> 10:09:31.365
dot config, we're going to make
sure we're on the correct

10157
10:09:31.365 --> 10:09:35.365
solidity version. So we're going
to do zero point 8.8 here. And

10158
10:09:35.365 --> 10:09:39.365
let's go ahead and try to
compile.

10159
10:09:39.365 --> 10:09:44.365
So we can run yarn Hardhead
compile. And you'll see we

10160
10:09:44.365 --> 10:09:47.365
actually get an error here.
Library at chain link slash

10161
10:09:47.365 --> 10:09:50.365
contracts imported from
contracts slash fund me dot soul

10162
10:09:50.365 --> 10:09:55.365
is not installed, try installing
it using npm. In remix, we went

10163
10:09:55.365 --> 10:09:58.365
ahead and just imported at
chainlink slash contracts, right

10164
10:09:58.365 --> 10:10:02.365
from our NPM and or GitHub. But
in our local code, we have to

10165
10:10:02.365 --> 10:10:07.365
tell Hardhead specifically,
where to get this from, we want

10166
10:10:07.365 --> 10:10:11.365
to download this specifically
from the NPM package manager at

10167
10:10:11.365 --> 10:10:14.365
chainlink slash contracts, we
can download it simply by

10168
10:10:14.365 --> 10:10:22.365
running yarn, add dash dash dev
at chainlink slash contracts.

10169
10:10:23.365 --> 10:10:25.365
Now that we've downloaded it
into our file, we'll be able to

10170
10:10:25.365 --> 10:10:30.365
see it in Node modules here.
Hardhead is now smart enough to

10171
10:10:30.365 --> 10:10:32.365
know that at chain link slash
contracts is going to point to

10172
10:10:32.365 --> 10:10:36.365
that node module that we have.
So we can now run yarn Hardhead

10173
10:10:36.365 --> 10:10:40.366
compile boom, now we can see
compiled three solidity files

10174
10:10:40.366 --> 10:10:46.366
successfully. So now we have our
contracts in here and our code

10175
10:10:47.366 --> 10:10:50.366
is compiling successfully. We're
probably going Want to deploy

10176
10:10:50.366 --> 10:10:52.366
our code? Now in our last
section, I know we use the

10177
10:10:52.366 --> 10:10:56.366
scripts module. And we made our
own manual deploy script.

10178
10:10:56.366 --> 10:10:58.366
However, something that you'd
notice, the more that you work

10179
10:10:58.366 --> 10:11:01.366
with just raw ethers, or even
just hard hat is that keeping

10180
10:11:01.366 --> 10:11:05.366
track of all our deployments can
get a little bit tricky. If you

10181
10:11:05.366 --> 10:11:08.366
just use a deploy script, it's
not saving our deployments to

10182
10:11:08.366 --> 10:11:11.366
any file. Additionally, having
everything in the deploy script

10183
10:11:11.366 --> 10:11:15.366
for deploying can make the tests
and the deploy scripts, maybe

10184
10:11:15.366 --> 10:11:18.366
not work exactly hand in hand.
And there are a couple of other

10185
10:11:18.366 --> 10:11:20.366
things that might be a little
bit tricky to work on, we're

10186
10:11:20.366 --> 10:11:22.366
actually going to work with a
package that makes everything I

10187
10:11:22.366 --> 10:11:26.366
just mentioned, and a couple
other things way easier. And

10188
10:11:26.366 --> 10:11:29.366
this package that I'm talking
about is going to be the hard

10189
10:11:29.366 --> 10:11:32.366
hat deploy package. There's a
link to this package in the

10190
10:11:32.366 --> 10:11:35.366
GitHub repository associated
with this course. It's a hardhat

10191
10:11:35.366 --> 10:11:38.366
plugin for replicable
deployments and easy testing.

10192
10:11:38.366 --> 10:11:40.366
And if we scroll down to
installation, we can see we

10193
10:11:40.366 --> 10:11:44.366
install it basically the normal
way. They're using npm. And

10194
10:11:44.366 --> 10:11:48.366
we're gonna go ahead and use
yarn. So for us to add it, we'll

10195
10:11:48.366 --> 10:11:53.366
do yarn, add hardhat dash
deploy. And then of course,

10196
10:11:53.366 --> 10:11:59.366
we're gonna do dash dash Dev.
Once done deploying this require

10197
10:11:59.366 --> 10:12:04.366
statement to our hard
hat.config.js. Once again,

10198
10:12:04.366 --> 10:12:07.366
basically the config is our
entry point. This is where we're

10199
10:12:07.366 --> 10:12:11.366
gonna get started. And we can go
ahead and delete our deploy.js

10200
10:12:11.366 --> 10:12:15.366
script. Now if we run yarn
hardhat, you see that we have a

10201
10:12:15.366 --> 10:12:19.367
bunch of new tasks in here, with
one of them being this deploy

10202
10:12:19.367 --> 10:12:23.367
task, this deploy task is going
to be the main task that we use

10203
10:12:23.367 --> 10:12:26.367
to deploy our contracts. Instead
of writing our deploy scripts in

10204
10:12:26.367 --> 10:12:28.367
the Scripts folder, we're
actually going to create a new

10205
10:12:28.367 --> 10:12:32.367
folder, we can create a new
folder by just doing MK dir

10206
10:12:32.367 --> 10:12:36.367
deploy. Or you can always right
click and hit New Folder. This

10207
10:12:36.367 --> 10:12:39.367
deploy folder is going to be
where a lot of hard hat Deploy

10208
10:12:39.367 --> 10:12:42.367
Module looks to deploy code. And
it's going to be where we are

10209
10:12:42.367 --> 10:12:45.367
writing our scripts. To write
our scripts, we usually need to

10210
10:12:45.367 --> 10:12:48.367
add one more thing in here.
Since we're going to be using

10211
10:12:48.367 --> 10:12:51.367
ethers JS in all of our scripts,
we want to add Hardhead deploy

10212
10:12:51.367 --> 10:12:55.367
ethers to our package here. Now,
instead of just doing yarn, add

10213
10:12:55.367 --> 10:12:58.367
dash dev hard at deploy ethers,
we're going to do something a

10214
10:12:58.367 --> 10:13:02.367
little bit weird. We're going to
do yarn add or npm install dash

10215
10:13:02.367 --> 10:13:05.367
dash Dev, and we're going to
install it like this. So let me

10216
10:13:05.367 --> 10:13:08.367
just copy this. And you can just
copy that from the repo. And

10217
10:13:08.367 --> 10:13:12.367
we'll do yarn, add dash dash
Dev, and paste that in here.

10218
10:13:12.367 --> 10:13:16.367
What we're doing is we're taking
at nomic labs, hard hat ethers,

10219
10:13:16.367 --> 10:13:19.367
which we've used before, and
we're overriding it with hard

10220
10:13:19.367 --> 10:13:23.367
hat deploy ethers. Remember how
in our last project, we used

10221
10:13:23.367 --> 10:13:27.367
hard hat ethers. So that hard
hat could override ethers to use

10222
10:13:27.367 --> 10:13:30.367
hard hat deploy. We use hard hat
deploy ethers, so that hard hat

10223
10:13:30.367 --> 10:13:34.367
deploy can override Hardhead,
which overrides ethers, which is

10224
10:13:34.367 --> 10:13:38.367
kind of funny. When you say like
that, this will enable ethers to

10225
10:13:38.367 --> 10:13:41.367
keep track of and remember all
the different deployments that

10226
10:13:41.367 --> 10:13:44.367
we actually make in our
contract. So if we look at our

10227
10:13:44.367 --> 10:13:48.367
package, JSON, and now we can
see our nomic labs dashboard had

10228
10:13:48.367 --> 10:13:52.367
ethers. Now the version of it is
going to be MPM. Hardhead deploy

10229
10:13:52.367 --> 10:13:56.367
ethers. This is our package dot
JSON, basically saying the hard

10230
10:13:56.367 --> 10:13:59.368
hat ethers package is now
overwritten by the hard hat

10231
10:13:59.368 --> 10:14:03.368
deploy ethers package, which is
what we want. Alright, great. So

10232
10:14:03.368 --> 10:14:05.368
now that we have that setup, we
can start writing our deploy

10233
10:14:05.368 --> 10:14:08.368
scripts, the way that Hart had
to play works is all the scripts

10234
10:14:08.368 --> 10:14:12.368
that get added to our deploy
folder will get run when we run

10235
10:14:12.368 --> 10:14:16.368
yarn, hard hat deploy. So a good
practice is usually to number

10236
10:14:16.368 --> 10:14:18.368
them so that they run in the
order that you want them to run

10237
10:14:18.368 --> 10:14:22.368
in. So since we only have one
contract that we want to deploy

10238
10:14:22.368 --> 10:14:28.368
the Funmi contract, we're going
to do 01 Deploy Funmi Jas, and

10239
10:14:28.368 --> 10:14:31.368
in this script, this is going to
be where we define how to deploy

10240
10:14:31.368 --> 10:14:35.368
the fundament contract. Alright,
so we're in our deploy Funmi

10241
10:14:35.368 --> 10:14:39.368
scripts. Now traditionally, what
did we do, we did imports, we

10242
10:14:39.368 --> 10:14:44.368
did the main function. And then
we did calling of main function,

10243
10:14:44.368 --> 10:14:47.368
that Hardhead deploy is a little
bit different, we're still going

10244
10:14:47.368 --> 10:14:49.368
to import our libraries and
packages, but we're not going to

10245
10:14:49.368 --> 10:14:52.368
have main function. And we're
also not going to call the main

10246
10:14:52.368 --> 10:14:55.368
function when we run Hardhead
deploy Harnett deploy is

10247
10:14:56.368 --> 10:14:59.368
actually going to call a
function that we specify. In

10248
10:14:59.368 --> 10:15:02.368
this script here. What we're
going to do is we're gonna

10249
10:15:02.368 --> 10:15:06.368
create a function, we'll call it
deploy funk.

10250
10:15:06.368 --> 10:15:08.368
We're going to export this
deploy function as the default

10251
10:15:08.368 --> 10:15:13.368
function for Hardhead deploy to
look for, so we could say,

10252
10:15:13.368 --> 10:15:20.368
module that exports dot default
equals deploy funk. To test it

10253
10:15:20.368 --> 10:15:25.368
out, we can go ahead and do
console dot log, hi. And then in

10254
10:15:25.368 --> 10:15:31.368
our terminal, run yarn, hard
hat, deploy. Oops, get rid of

10255
10:15:31.368 --> 10:15:37.369
the parentheses here. Sorry. Run
it again. And we can see it went

10256
10:15:37.369 --> 10:15:41.369
and ran our deploy func here.
Now if this syntax is easier for

10257
10:15:41.369 --> 10:15:44.369
you to understand, go ahead and
use this syntax and we're going

10258
10:15:44.369 --> 10:15:47.369
to be passing the heart at
runtime environment as a

10259
10:15:47.369 --> 10:15:51.369
parameter to this function.
However, if we go to the heart

10260
10:15:51.369 --> 10:15:55.369
hat deploy documentation, and we
scroll down to an example

10261
10:15:55.369 --> 10:15:58.369
script, the syntax looks a
little bit different. And let me

10262
10:15:58.369 --> 10:16:01.369
just explain what's going on
here and how we're going to be

10263
10:16:01.369 --> 10:16:04.369
writing ours. So instead of kind
of defining everything like

10264
10:16:04.369 --> 10:16:07.369
this, and defining the function
name, similar to what we were

10265
10:16:07.369 --> 10:16:10.369
doing before, we're actually
going to using a nameless, a

10266
10:16:10.369 --> 10:16:13.369
synchronous function, we're
going to make it an anonymous

10267
10:16:13.369 --> 10:16:17.369
function, similar to what we've
seen before. So instead, we're

10268
10:16:17.369 --> 10:16:21.369
going to say async parameters
like this, I'm going to pass our

10269
10:16:21.369 --> 10:16:24.369
parameters our heart at runtime
environment in here. And it's

10270
10:16:24.369 --> 10:16:28.369
going to be an arrow function.
And then we're going to wrap

10271
10:16:28.369 --> 10:16:33.369
this whole thing in module dot
exports. So we're gonna say,

10272
10:16:33.369 --> 10:16:40.369
module, dot exports, equals this
async function like this. This

10273
10:16:40.369 --> 10:16:45.369
syntax here is nearly identical
to what's up here, we just don't

10274
10:16:45.369 --> 10:16:48.369
have a name for our async
function. So this is how we're

10275
10:16:48.369 --> 10:16:52.369
going to set it up instead. But
if this syntax is a little bit

10276
10:16:52.369 --> 10:16:55.369
confusing for you feel free to
use this above as the two of

10277
10:16:55.369 --> 10:16:58.369
these are going to be the same.
Now the next thing that most of

10278
10:16:58.369 --> 10:17:01.369
the documentation does is it
pulls out the variables and

10279
10:17:01.369 --> 10:17:05.369
functions out of the HRV that
we're going to use. HRV is the

10280
10:17:05.369 --> 10:17:09.369
heart hat runtime environment.
Whenever we run a deploy script,

10281
10:17:09.369 --> 10:17:12.369
heart hat deploy automatically
calls this function and just

10282
10:17:12.369 --> 10:17:16.369
passes the hard hat object into
it similar to in back in hard

10283
10:17:16.369 --> 10:17:21.370
hat simple storage. In our
deploy script. We had ethers run

10284
10:17:21.370 --> 10:17:24.370
in network come from hard hat,
instead of coming from hard hat.

10285
10:17:24.370 --> 10:17:27.370
We're coming from HRV, which is
basically the same thing as hard

10286
10:17:27.370 --> 10:17:30.370
hat. For our script, we're only
going to use two variables from

10287
10:17:30.370 --> 10:17:41.370
a jury when you use const. Get
named accounts. And deployments.

10288
10:17:41.370 --> 10:17:44.370
This syntax might look a little
bit weird for you. But it's just

10289
10:17:44.370 --> 10:17:47.370
a way to pull these exact
variables out of a tree. It's

10290
10:17:47.370 --> 10:17:51.370
kind of the same thing as just
doing a tree dot get named

10291
10:17:51.370 --> 10:17:56.370
accounts and HRA dot
deployments. But pulling them

10292
10:17:56.370 --> 10:17:58.370
out like this means we don't
have to add a tree at the

10293
10:17:58.370 --> 10:18:02.370
beginning anymore. And then
additionally, additionally,

10294
10:18:02.370 --> 10:18:05.370
JavaScript has something called
syntactic sugar. So instead of

10295
10:18:05.370 --> 10:18:09.370
doing this on two lines like
this, we can actually do that

10296
10:18:09.370 --> 10:18:14.370
whole bit on one line. So
instead, we just extrapolate

10297
10:18:14.370 --> 10:18:18.370
those two variables, right in
the function declaration. So

10298
10:18:18.370 --> 10:18:22.370
this line is the exact same
thing as doing this line. This

10299
10:18:22.370 --> 10:18:25.370
is an asynchronous, nameless
function using the arrow

10300
10:18:25.370 --> 10:18:29.370
notation, or working with our
deploy scripts here. And we're

10301
10:18:29.370 --> 10:18:32.370
default, exporting it with
module dot exports. I don't know

10302
10:18:32.370 --> 10:18:35.370
that was a lot. And another is
kind of a lot of syntactic sugar

10303
10:18:35.370 --> 10:18:38.370
here. But if that's really
confusing for you, just feel

10304
10:18:38.370 --> 10:18:41.370
free to use the above. And
whenever we refer to get named

10305
10:18:41.370 --> 10:18:48.370
accounts, you can also just do a
three dot get named accounts, or

10306
10:18:48.370 --> 10:18:53.370
a three dot deployments. So
hopefully, that's clear that

10307
10:18:53.370 --> 10:18:55.370
this top part is gonna be the
same as this bottom part right

10308
10:18:55.370 --> 10:18:59.371
here, whichever one you feel
more comfortable working with.

10309
10:18:59.371 --> 10:19:01.371
But alright, now that we've
gotten all that out of the way,

10310
10:19:01.371 --> 10:19:04.371
let's continue with the script.
So we're using this deployments

10311
10:19:04.371 --> 10:19:08.371
object, reason this deployments
object to get two functions,

10312
10:19:08.371 --> 10:19:11.371
those two functions are going to
be the deploy function, and the

10313
10:19:11.371 --> 10:19:14.371
log function. So we're gonna say
const, deploy log equals

10314
10:19:14.371 --> 10:19:18.371
deployments. So we're going to
pull these two functions out of

10315
10:19:18.371 --> 10:19:23.371
deployments. And then we're also
going to do const Deployer.

10316
10:19:23.371 --> 10:19:28.371
Equals await, get named
accounts. So we are grabbing

10317
10:19:28.371 --> 10:19:31.371
this new deploy function, this
new log function, and we're

10318
10:19:31.371 --> 10:19:34.371
grabbing this deployer account
from this weird get named

10319
10:19:34.371 --> 10:19:38.371
accounts function. What's this
get named accounts function,

10320
10:19:38.371 --> 10:19:42.371
this get named accounts is a way
for us to get named accounts.

10321
10:19:42.371 --> 10:19:45.371
When working with ethers we saw
when working with ethers, we can

10322
10:19:45.371 --> 10:19:49.371
actually get our accounts based
off of the number in the Account

10323
10:19:49.371 --> 10:19:54.371
section of each network. So for
example,

10324
10:19:54.371 --> 10:19:57.371
in this list of private keys,
private keys zero private key

10325
10:19:57.371 --> 10:20:00.371
one private key two, it might
get a little confusing to

10326
10:20:00.371 --> 10:20:04.371
remember which ones which so
instead of working like that, we

10327
10:20:04.371 --> 10:20:07.371
can add a section at the bottom
called named accounts where we

10328
10:20:07.371 --> 10:20:11.371
can name each one of those spots
in the accounts array. So we'll

10329
10:20:11.371 --> 10:20:15.371
do named accounts. And we'll say
one of the accounts that will

10330
10:20:15.371 --> 10:20:18.371
name is going to be named
Deployer. And we're gonna say by

10331
10:20:18.371 --> 10:20:23.371
default, the zero with account
is going to be Deployer. We can

10332
10:20:23.371 --> 10:20:27.371
also specify which number is
going to be the deployer account

10333
10:20:27.371 --> 10:20:31.371
across different chains. For
example, on Rigby we wanted the

10334
10:20:31.371 --> 10:20:33.371
deployer account to be the first
position, we could do something

10335
10:20:33.371 --> 10:20:37.371
like this or on hard hat, we
could do it like this. We can

10336
10:20:37.371 --> 10:20:40.372
create multiple users. Like for
example, if we wanted to do a

10337
10:20:40.372 --> 10:20:44.372
user for some test or something,
and we'll just say the default

10338
10:20:44.372 --> 10:20:48.372
is one or whatever we wanted in
here. So back in our deploy fun

10339
10:20:48.372 --> 10:20:51.372
me We're going to say we're
going to grab that deployer

10340
10:20:51.372 --> 10:20:54.372
account from our named accounts.
And then finally, we're going to

10341
10:20:54.372 --> 10:20:57.372
grab our chain ID for reasons
that will come clear pretty

10342
10:20:57.372 --> 10:21:03.372
soon. So we'll do const, chain
ID equals network dot config dot

10343
10:21:03.372 --> 10:21:09.372
chain ID. Now, how do we
actually deploy this fund me

10344
10:21:09.372 --> 10:21:12.372
contract? Well, let's think
about this for a little bit.

10345
10:21:12.372 --> 10:21:15.372
When working with remix, it was
pretty easy, right? We just

10346
10:21:15.372 --> 10:21:18.372
deployed it to a test net. Ah,
that's kind of the issue there,

10347
10:21:18.372 --> 10:21:21.372
isn't it deploying to a rink,
the test net is a little bit

10348
10:21:21.372 --> 10:21:24.372
slow. We don't always want to
have to deploy to one of these

10349
10:21:24.372 --> 10:21:27.372
slow test nets or even a main
net when tinkering and fiddling

10350
10:21:27.372 --> 10:21:31.372
with our contracts, do we know
that's gonna be really bad, we

10351
10:21:31.372 --> 10:21:34.372
really want to deploy to a test
net as a last stop after we've

10352
10:21:34.372 --> 10:21:37.372
done all our testing locally. Or
we can deploy it to a test that

10353
10:21:37.372 --> 10:21:41.372
to see some very specific code
work, like for example, with the

10354
10:21:41.372 --> 10:21:44.372
chain link documentation. So
ideally, we deploy this to a

10355
10:21:44.372 --> 10:21:48.372
local network first. But can we
just do that? Well, if we look

10356
10:21:48.372 --> 10:21:51.372
in our price converter, dot
Seoul, we have this hard coded

10357
10:21:51.372 --> 10:21:55.372
address in here, this 0x
address, if we go to Doc's dot

10358
10:21:55.372 --> 10:21:59.372
chain that link EVM chains,
contract addresses for Aetherium

10359
10:21:59.372 --> 10:22:03.372
data feeds. That address is the
eth USD, specifically for

10360
10:22:03.372 --> 10:22:07.372
Rinkeby. What if we work on the
Hard Hat Network? Example?

10361
10:22:07.372 --> 10:22:10.372
default network?

10362
10:22:10.372 --> 10:22:13.372
Hard Hat. And then like I said
before, if you don't write this

10363
10:22:13.372 --> 10:22:16.372
in part, it is automatically the
default network. But if we're to

10364
10:22:16.372 --> 10:22:19.373
point to the Hard Hat Network,
harder network is a blank

10365
10:22:19.373 --> 10:22:21.373
blockchain. And it gets
destroyed every time our scripts

10366
10:22:21.373 --> 10:22:24.373
finish, or even if we're working
with a local node, this price

10367
10:22:24.373 --> 10:22:28.373
feed contract won't exist, one
of the code there won't be

10368
10:22:28.373 --> 10:22:31.373
updated with data. So what do we
do? How do we test and interact

10369
10:22:31.373 --> 10:22:34.373
with our code locally? Is there
a way we can do this? Well, one

10370
10:22:34.373 --> 10:22:36.373
of the ways that we can do this
that we'll learn a little bit

10371
10:22:36.373 --> 10:22:39.373
later is actually forking a
blockchain, where you can keep

10372
10:22:39.373 --> 10:22:42.373
stuff hard coded. But usually,
it's still better to figure out

10373
10:22:42.373 --> 10:22:46.373
how to do everything with
something called mocks. There's

10374
10:22:46.373 --> 10:22:49.373
a great Stack Overflow question
that just says, What is mocking

10375
10:22:49.373 --> 10:22:52.373
and mocking is primarily used
for unit testing, which we'll

10376
10:22:52.373 --> 10:22:55.373
talk about in a little bit. And
object under test may have

10377
10:22:55.373 --> 10:22:59.373
dependencies on other complex
objects. To isolate the behavior

10378
10:22:59.373 --> 10:23:03.373
of the object, you want to
replace other objects by mocks

10379
10:23:03.373 --> 10:23:07.373
that simulate the behavior of
the real objects. In short,

10380
10:23:07.373 --> 10:23:10.373
mocking is creating objects that
simulate behavior of real

10381
10:23:10.373 --> 10:23:14.373
objects. Now, this might seem
like a lot of words. But

10382
10:23:14.373 --> 10:23:17.373
basically, what we want to do is
we want to make a fake price

10383
10:23:17.373 --> 10:23:20.373
feed contract that we can use
and we can control when working

10384
10:23:20.373 --> 10:23:23.373
locally. So back here, I'm just
going to leave a note in here

10385
10:23:23.373 --> 10:23:30.373
saying, When going for local
host or Hard Hat Network, we

10386
10:23:30.373 --> 10:23:33.373
want to use a mock. Okay, great,
well, we can use a mock and

10387
10:23:33.373 --> 10:23:36.373
we'll learn how to make one of
those in a little bit. Well,

10388
10:23:36.373 --> 10:23:42.373
what happens when we want to
change chains, for example, back

10389
10:23:42.373 --> 10:23:46.373
in dots dot chain to link EVM
chains, contract addresses,

10390
10:23:46.373 --> 10:23:50.373
there are a ton of different
block chains that have price

10391
10:23:50.373 --> 10:23:53.373
feeds on them. And on each one
of these blockchains, the eth

10392
10:23:53.373 --> 10:23:56.373
USD price feed is going to be a
little bit different. For

10393
10:23:56.373 --> 10:23:59.374
example, we're looking at ETH
USD, the address of eth USD for

10394
10:23:59.374 --> 10:24:03.374
Aetherium main net is different
from the address of eth USD for

10395
10:24:03.374 --> 10:24:05.374
Rigby, which makes sense,
they're totally different

10396
10:24:05.374 --> 10:24:08.374
contracts on different chains,
they have very similar

10397
10:24:08.374 --> 10:24:10.374
functionality. And they do
nearly the exact same thing. But

10398
10:24:11.374 --> 10:24:13.374
they're still different. We're
also going to need a way for us

10399
10:24:13.374 --> 10:24:18.374
to modularize or parameterize,
this address in here, so that no

10400
10:24:18.374 --> 10:24:21.374
matter what chain we deploy to,
we don't have to change any of

10401
10:24:21.374 --> 10:24:23.374
our code, we can always have our
code be exactly the same. And we

10402
10:24:23.374 --> 10:24:26.374
don't have to come in here and
like flip values and flip

10403
10:24:26.374 --> 10:24:29.374
variables and stuff. So let's
keep that all of that in mind as

10404
10:24:29.374 --> 10:24:33.374
we write the rest of this. Now
in order to parameterize. This,

10405
10:24:33.374 --> 10:24:36.374
we actually want to prioritize
and do a little refactoring of

10406
10:24:36.374 --> 10:24:39.374
our fundamental soul.
Refactoring basically means

10407
10:24:39.374 --> 10:24:43.374
going back and, and changing the
way your code works. Right now

10408
10:24:43.374 --> 10:24:46.374
we have this constructor
function, right the constructor

10409
10:24:46.374 --> 10:24:49.374
function is the function that
automatically gets called

10410
10:24:49.374 --> 10:24:52.374
whenever we deploy our contract.
Right now it's not doing a whole

10411
10:24:52.374 --> 10:24:55.374
lot right now it's just updating
the owner variable to be whoever

10412
10:24:55.374 --> 10:24:58.374
sent in the contract. But we can
actually have a do much more

10413
10:24:58.374 --> 10:25:02.374
than that. Since this
constructor is a function just

10414
10:25:02.374 --> 10:25:04.374
like every other function, we
can actually have it take

10415
10:25:04.374 --> 10:25:07.374
parameters, one of the
parameters that we might like

10416
10:25:07.374 --> 10:25:11.374
for it to have is going to be
the address of a price feed. So

10417
10:25:11.374 --> 10:25:13.374
let's go ahead and add this and
figure out how to refactor all

10418
10:25:13.374 --> 10:25:18.374
this code. So we're going to add
constructor address, price feed

10419
10:25:18.374 --> 10:25:21.374
for the constructor in here.
When we deploy our contract. Now

10420
10:25:21.374 --> 10:25:24.374
we're going to pass it the eth
USD price feed address depending

10421
10:25:24.374 --> 10:25:27.374
on what chain we're on. If we're
on rink B, we'll use this

10422
10:25:27.374 --> 10:25:30.374
address if one polygon will use
a different one b&b, different

10423
10:25:30.374 --> 10:25:34.374
one, Gnosis hecho, avalanche,
etc, you get the picture. So

10424
10:25:34.374 --> 10:25:37.375
we're going to marginalize this
like so. Now that our

10425
10:25:37.375 --> 10:25:40.375
constructor takes a parameter
for the price feed, we can

10426
10:25:40.375 --> 10:25:44.375
actually save an aggregator v3
interface object as a global

10427
10:25:44.375 --> 10:25:47.375
variable in our price converter,
we just create a price feed

10428
10:25:47.375 --> 10:25:51.375
variable of type aggregator v3
interface, which again, we're

10429
10:25:51.375 --> 10:25:54.375
importing from the chainlink
repo, which is an interface

10430
10:25:54.375 --> 10:25:57.375
object which gets compiled down
to the ABI. If you match an ABI

10431
10:25:57.375 --> 10:26:00.375
with up with an address, you get
a contract that you can interact

10432
10:26:00.375 --> 10:26:02.375
with. So we're going to do the
same thing here. We're gonna

10433
10:26:02.375 --> 10:26:10.375
say, aggregate Tor, v3
interface, public price feed,

10434
10:26:10.375 --> 10:26:13.375
ration and call this price feed
address so that these don't have

10435
10:26:13.375 --> 10:26:17.375
the same name. And in our
constructor, we're going to say

10436
10:26:17.375 --> 10:26:21.375
price feed equals, and we're
going to do the exact same thing

10437
10:26:21.375 --> 10:26:26.375
we did with our price converter
equals aggregate tore the three

10438
10:26:26.375 --> 10:26:28.375
interface

10439
10:26:28.375 --> 10:26:36.375
of price feed address. Like so
now, we have this price feed

10440
10:26:36.375 --> 10:26:40.375
address that's variable and
modularized, depending on

10441
10:26:40.375 --> 10:26:44.375
whatever chain that we're on.
Now, what we can do is we can

10442
10:26:44.375 --> 10:26:47.375
grab this price feed address,
and we can use it for our price

10443
10:26:47.375 --> 10:26:51.375
converter. So where are we using
our price converter? Well, just

10444
10:26:51.375 --> 10:26:55.375
a quick reminder, we're using
using price converter for you at

10445
10:26:55.375 --> 10:26:59.375
256. We're using this as a
library on top of our unit 256

10446
10:26:59.375 --> 10:27:03.375
type. So we're calling message
dot value dot get conversion

10447
10:27:03.375 --> 10:27:06.375
rate. So we look at our price
converter, we have this function

10448
10:27:06.375 --> 10:27:09.375
get conversion rate, which takes
an FML as its initial parameter,

10449
10:27:09.375 --> 10:27:13.375
which again, since this is a
library, it automatically passes

10450
10:27:13.375 --> 10:27:17.375
the message dot value into this
get conversion rate function.

10451
10:27:17.375 --> 10:27:22.376
But we could also pass in this
price feed, and therefore we

10452
10:27:22.376 --> 10:27:25.376
wouldn't need to hard code it in
the get price anymore. So let's

10453
10:27:25.376 --> 10:27:28.376
go ahead and figure out how to
do that. Well, what we can do is

10454
10:27:28.376 --> 10:27:31.376
we can do message dot value dot
get conversion rate, we'll stick

10455
10:27:31.376 --> 10:27:34.376
price feed in here. And then
we'll have to update our get

10456
10:27:34.376 --> 10:27:38.376
conversion rate to do a comma so
that it takes a second

10457
10:27:38.376 --> 10:27:41.376
parameter, because remember,
again, the initial parameter is

10458
10:27:41.376 --> 10:27:44.376
going to be message dot value.
And the second parameter is

10459
10:27:44.376 --> 10:27:50.376
going to be what we define here.
So we'll do s amount, comma ag

10460
10:27:50.376 --> 10:27:58.376
reg gate Tor v3 interface. And
we'll call this price feed. And

10461
10:27:58.376 --> 10:28:03.376
now, when we call our get price
function, we can pass the price

10462
10:28:03.376 --> 10:28:07.376
feed to the get price function.
And up here we can have get

10463
10:28:07.376 --> 10:28:15.376
price. Take, you guessed it an
aggregate or the three interface

10464
10:28:15.376 --> 10:28:22.376
called price feed. And now we no
longer need to hard code in the

10465
10:28:22.376 --> 10:28:25.376
price feed. And we can just
delete those lines and have it

10466
10:28:25.376 --> 10:28:30.376
compile like this, which is
awesome. So quick refresher,

10467
10:28:30.376 --> 10:28:33.376
we're parameterizing that price
feed address and passing it in

10468
10:28:33.376 --> 10:28:37.376
with a constructor that gets
saved as a global variable to an

10469
10:28:37.376 --> 10:28:41.376
aggregator v3 interface type, or
passing it to a get conversion

10470
10:28:41.376 --> 10:28:45.376
rate function, which passes it
to the get price function, which

10471
10:28:45.376 --> 10:28:48.376
then just calls latest round
data. And we probably could have

10472
10:28:48.376 --> 10:28:50.376
made this even easier, probably
could have just got rid of the

10473
10:28:50.376 --> 10:28:54.376
get price function and stuck
this code in the get conversion

10474
10:28:54.376 --> 10:28:56.376
rate. But we'll leave it there
for now. Now that we've done

10475
10:28:56.376 --> 10:28:59.377
that refactoring, let's make
sure it works. Yarn Hardhead,

10476
10:28:59.377 --> 10:29:03.377
compile, invalid value undefined
for hardhat dot config dot

10477
10:29:03.377 --> 10:29:07.377
networks. Let's go to the let's
go to the config real quick.

10478
10:29:07.377 --> 10:29:09.377
That's because the default
network needs to be outside of

10479
10:29:09.377 --> 10:29:14.377
networks. My mistake. Let's try
that again. I spelled interface

10480
10:29:14.377 --> 10:29:17.377
wrong and the price converter.
And a quick note, if gives you

10481
10:29:17.377 --> 10:29:20.377
an error like this, oftentimes,
you can command click or control

10482
10:29:20.377 --> 10:29:23.377
click and open that file up
right in the editor, which saves

10483
10:29:23.377 --> 10:29:26.377
you some time, we're going to
have defined the line and find

10484
10:29:26.377 --> 10:29:29.377
the file. But yeah, let's spell
that correctly. And let's try

10485
10:29:29.377 --> 10:29:33.377
this again. And awesome. It
looks like it's compiling

10486
10:29:33.377 --> 10:29:36.377
correctly. And we just have some
warnings, it looks like these

10487
10:29:36.377 --> 10:29:39.377
warnings are just about this git
version, which is because we're

10488
10:29:39.377 --> 10:29:42.377
shadowing this, we're creating a
new price variable down here,

10489
10:29:42.377 --> 10:29:46.377
you've no we just created a
global price free variable.

10490
10:29:46.377 --> 10:29:48.377
Let's just go ahead and delete
the get version function

10491
10:29:48.377 --> 10:29:51.377
altogether since we're not even
going to really need it. And we

10492
10:29:51.377 --> 10:29:53.377
only use the Git version to show
you how to actually start

10493
10:29:53.377 --> 10:29:56.377
working with interfaces. And
then we'll compile it one more

10494
10:29:56.377 --> 10:30:01.377
time for good measure. Boom
compiled successfully. Awesome.

10495
10:30:01.377 --> 10:30:04.377
So now we've just refactored our
code. So we can pass a price

10496
10:30:04.377 --> 10:30:08.377
feed address depending on the
network that we're on. Okay,

10497
10:30:08.377 --> 10:30:12.377
great. With all that being said,
let's come back to our deploy

10498
10:30:12.377 --> 10:30:15.377
Funmi script, and let's learn
how to actually deploy the rest

10499
10:30:15.377 --> 10:30:18.377
of it. In order for us to deploy
a contract we remember from our

10500
10:30:18.377 --> 10:30:22.377
last sections that we use the
contract factories, with heart

10501
10:30:22.377 --> 10:30:25.377
hit Deploy, we can just use this
deploy function. And to use the

10502
10:30:25.377 --> 10:30:28.377
deploy function, we'll say const
Funmi, which is going to be the

10503
10:30:28.377 --> 10:30:32.377
name of our contract, equals
await. And we'll call this

10504
10:30:32.377 --> 10:30:36.377
deploy function, the name of the
contract that we're deploying

10505
10:30:36.377 --> 10:30:39.378
right now, and then a list of
overrides that we want to add

10506
10:30:39.378 --> 10:30:42.378
here. So we're gonna say who is
actually deploying this by

10507
10:30:42.378 --> 10:30:45.378
saying from, we're gonna say
it's from the Deployer. We're

10508
10:30:45.378 --> 10:30:49.378
gonna pass any arguments to the
constructor In this args piece

10509
10:30:49.378 --> 10:30:55.378
here, which we just added a
single Argh. So these brackets,

10510
10:30:55.378 --> 10:30:57.378
we're going to make it a list of
arguments, we're going to put

10511
10:30:57.378 --> 10:30:59.378
the price feed address in here,
which we'll show you how to do

10512
10:30:59.378 --> 10:31:03.378
in a second, put price feed
address. And then we're also

10513
10:31:03.378 --> 10:31:06.378
going to do some custom logging
here so that we don't have to do

10514
10:31:06.378 --> 10:31:08.378
all that console dot log stuff
that we've been doing this whole

10515
10:31:08.378 --> 10:31:12.378
time. And we need to put
something in here. We need to

10516
10:31:12.378 --> 10:31:15.378
put an address in here. And you
can use this backslash star to

10517
10:31:15.378 --> 10:31:18.378
put like a common in between
your code.

10518
10:31:18.378 --> 10:31:22.378
We can't just do const address
equals, you know the address and

10519
10:31:22.378 --> 10:31:24.378
stick it in here. Well, I mean,
we could but we're not really

10520
10:31:24.378 --> 10:31:27.378
prioritizing now. Right? We're
kind of back to just hard coding

10521
10:31:27.378 --> 10:31:30.378
it here. So what can we do
instead? Well, what we can do is

10522
10:31:30.378 --> 10:31:35.378
we can actually use the chain ID
to do something like if chain ID

10523
10:31:35.378 --> 10:31:45.378
is x, use address, Y, or if
chain ID is Z use address A. So

10524
10:31:45.378 --> 10:31:48.378
we can do something that looks
like this. And to enable this

10525
10:31:48.378 --> 10:31:51.378
functionality, we actually take
a page out of the Ave GitHub. So

10526
10:31:51.378 --> 10:31:54.378
Ave is another protocol that's
on multiple chains and has to

10527
10:31:54.378 --> 10:31:57.378
deploy their code to multiple
chains and work with multiple

10528
10:31:57.378 --> 10:32:01.378
different addresses. So what
they do is they use a number of

10529
10:32:01.378 --> 10:32:04.378
different useful tricks. But one
of the main ones is using this

10530
10:32:04.378 --> 10:32:07.378
helper hardhat config. Now
they're using TypeScript with

10531
10:32:07.378 --> 10:32:10.378
JavaScript, but it's gonna be
the same thing. With this

10532
10:32:10.378 --> 10:32:14.378
config, they have different
variables, depending on what

10533
10:32:14.378 --> 10:32:17.378
network that they're actually
on. And depending on the network

10534
10:32:17.378 --> 10:32:20.379
that they're on, they use
different variables. So they use

10535
10:32:20.379 --> 10:32:24.379
this network config almost to do
exactly what we're trying to do

10536
10:32:24.379 --> 10:32:28.379
here. So what we want to do is
we're going to create a new file

10537
10:32:28.379 --> 10:32:32.379
at the root directory, so just
click down here, new file. And

10538
10:32:32.379 --> 10:32:39.379
we're going to call it helper,
hard hat config dot j, s. And

10539
10:32:39.379 --> 10:32:41.379
this is where we're going to
define that network config. And

10540
10:32:41.379 --> 10:32:43.379
this is where we're going to
say, hey, if you're on network,

10541
10:32:43.379 --> 10:32:48.379
a, use this address network, be
this use this address, etc. So

10542
10:32:48.379 --> 10:32:52.379
we're going to create an object
called const. Network config.

10543
10:32:53.379 --> 10:32:55.379
equals and we're going to add a
bunch of stuff in here. So our

10544
10:32:55.379 --> 10:32:58.379
main network that we're working
with right now is rinky. dinky

10545
10:32:58.379 --> 10:33:04.379
has a chain ID of four. So we'll
say chain ID four is going to be

10546
10:33:04.379 --> 10:33:12.379
named Rinkeby. And the eth USD
price feed address is going to

10547
10:33:12.379 --> 10:33:16.379
be the price feed address of
rank B of the eth USD price

10548
10:33:16.379 --> 10:33:19.379
feed. So we're going to copied
from the documentation or from

10549
10:33:19.379 --> 10:33:22.379
the GitHub, whatever you want to
do, and paste it in here. Now we

10550
10:33:22.379 --> 10:33:25.379
have a simple methodology of
keeping track of different price

10551
10:33:26.379 --> 10:33:29.379
feeds a different contract
addresses across different

10552
10:33:29.379 --> 10:33:33.379
chains. Let's say for example,
we wanted to deploy to Polygon

10553
10:33:33.379 --> 10:33:36.379
as well. Well, first, what are
we going to need? Well, we're

10554
10:33:36.379 --> 10:33:39.379
going to need the chain ID of
polygon. So a quick little

10555
10:33:39.379 --> 10:33:43.379
Google Search brings us to the
polygon documentation. And we

10556
10:33:43.379 --> 10:33:48.379
see the chain ID is 137. So I'll
do 137. What's a little brackets

10557
10:33:48.379 --> 10:33:54.379
here, we'll say name, polygon.
Then we'll do a comma eth USD,

10558
10:33:54.379 --> 10:33:58.380
price feed. And then we'll add
the price feed of eth USD on

10559
10:33:58.380 --> 10:34:04.380
polygon. So docstoc, chain link,
polygon or Matic and then we'll

10560
10:34:04.380 --> 10:34:09.380
look up eth, USD. And boom, we
see it right here. We've grabbed

10561
10:34:09.380 --> 10:34:12.380
this address, and we paste it
in. Well, what about the

10562
10:34:12.380 --> 10:34:15.380
Hardhead? Network? We'll get to
that in just a second, don't you

10563
10:34:15.380 --> 10:34:18.380
worry. And then at the bottom,
we need to export this network

10564
10:34:18.380 --> 10:34:21.380
config. So our other scripts can
actually work with it. So we'll

10565
10:34:21.380 --> 10:34:28.380
do module dot exports equals
network config. And we're going

10566
10:34:28.380 --> 10:34:31.380
to actually export a couple of
things from this file, which is

10567
10:34:31.380 --> 10:34:34.380
why we're doing it like this
instead of that default way that

10568
10:34:34.380 --> 10:34:37.380
I showed you before. So back in
our script, now, what can we do?

10569
10:34:37.380 --> 10:34:41.380
Well, first, we want to go ahead
and import that network config.

10570
10:34:41.380 --> 10:34:47.380
So we'll say const. Network
config equals require, and then

10571
10:34:47.380 --> 10:34:51.380
we'll import it, we'll go down
and directory to help our

10572
10:34:51.380 --> 10:34:54.380
Hardhead config and save. And I
just want to mention this one

10573
10:34:54.380 --> 10:34:57.380
more time, just so that it
doesn't confuse anybody. This

10574
10:34:57.380 --> 10:35:00.380
syntax here, constant network
config with the little curly

10575
10:35:00.380 --> 10:35:10.380
braces around it is the same is
if I went const. Helper config

10576
10:35:10.380 --> 10:35:13.380
equals this thing, which helper
config is now kind of this whole

10577
10:35:13.380 --> 10:35:21.380
file. And then const network
config equals Hopper config dot

10578
10:35:21.380 --> 10:35:24.380
network config. So again, this
index is just kind of an easy

10579
10:35:24.380 --> 10:35:28.380
way to extrapolate or pull out
just the network config from

10580
10:35:28.380 --> 10:35:31.380
this file. So that's how that
works. And that's why we export

10581
10:35:31.380 --> 10:35:35.380
it at the bottom so that we can
do this, please use the GitHub

10582
10:35:35.380 --> 10:35:39.381
repository to ask questions and
discussions especially about

10583
10:35:39.381 --> 10:35:41.381
some of this JavaScript stuff.
Alright, great. So now that we

10584
10:35:41.381 --> 10:35:44.381
have this network configured
here, we can now do this part of

10585
10:35:44.381 --> 10:35:48.381
where we say if China d z use a
if chain ID is x use y. So Since

10586
10:35:48.381 --> 10:35:52.381
our helper config is nicely in
this kind of dictionary, key

10587
10:35:52.381 --> 10:35:59.381
value pair style, what we can do
is we can say const. eth USD.

10588
10:35:59.381 --> 10:36:08.381
Price feed address equals
network config at the chain ID,

10589
10:36:08.381 --> 10:36:12.381
because if Francina D, or it'll
be this object, French entity

10590
10:36:12.381 --> 10:36:21.381
polygon, it'll be this object at
the eth USD price feed, we're

10591
10:36:21.381 --> 10:36:24.381
going to save this to eth USD
price feed address. And now no

10592
10:36:24.381 --> 10:36:28.381
matter what chain we're on,
whenever we run hard hat deploy,

10593
10:36:28.381 --> 10:36:34.381
if I run yarn, hard hat deploy
dash dash network Rinkeby. This

10594
10:36:34.381 --> 10:36:37.381
chain ID is going to be four.
And so it's going to use this

10595
10:36:37.381 --> 10:36:42.381
price feed address. If I do dash
test network polygon, and I

10596
10:36:42.381 --> 10:36:45.381
remember to add both ring P and
polygon to my networks, like

10597
10:36:45.381 --> 10:36:48.381
here, the channel is going to be
137. It's going to use this

10598
10:36:48.381 --> 10:36:52.381
price feed address. So this is
awesome. This is exactly what we

10599
10:36:52.381 --> 10:36:55.381
want. But is it everything that
we want? Those of you who have

10600
10:36:55.381 --> 10:36:58.381
been questioning while I have
been coding and talking, you

10601
10:36:58.381 --> 10:37:00.381
might be thinking, Okay, well,
you talked about this marking

10602
10:37:00.381 --> 10:37:03.381
thing. You talked about
localhost and hard hat. And how

10603
10:37:03.381 --> 10:37:06.381
do we test this locally? Like
this is how we go to a test net

10604
10:37:06.381 --> 10:37:09.381
and a main net. But what about a
local network? And that is

10605
10:37:09.381 --> 10:37:13.381
exactly what we're going to talk
about now. So we've modularized,

10606
10:37:13.381 --> 10:37:16.381
our code and parameterize our
code so that we're going to use

10607
10:37:16.381 --> 10:37:20.382
the address based off of the
chain that we're on. But what if

10608
10:37:20.382 --> 10:37:24.382
we use a chain that doesn't even
have a price feed address on it?

10609
10:37:24.382 --> 10:37:27.382
What do we do there? This is
where we actually create those

10610
10:37:27.382 --> 10:37:32.382
mock contracts. The idea of mock
contracts here is if the

10611
10:37:32.382 --> 10:37:37.382
contract doesn't exist, we
deploy a minimal version of it

10612
10:37:37.382 --> 10:37:42.382
for our local testing, or our
local testing. And deploying

10613
10:37:42.382 --> 10:37:48.382
mocks is technically a deploy
script. So what we do actually

10614
10:37:48.382 --> 10:37:51.382
is back in our deploy folder is
we're going to create a new

10615
10:37:51.382 --> 10:37:58.382
file, and we're going to call it
00 Dash deploy mocks dot j s, we

10616
10:37:58.382 --> 10:38:01.382
started with 00. Because this is
almost like the pre deploy

10617
10:38:01.382 --> 10:38:05.382
stuff, we only do this,
sometimes we don't always deploy

10618
10:38:05.382 --> 10:38:08.382
mocks, right, we don't need to
deploy mocks to Rinkeby, or

10619
10:38:08.382 --> 10:38:11.382
polygon or or Aetherium main
net, because those already have

10620
10:38:11.382 --> 10:38:15.382
these price feeds, we're
actually going to deploy our own

10621
10:38:15.382 --> 10:38:19.382
mock price feed contracts. And
in our deploy Funmi script,

10622
10:38:19.382 --> 10:38:23.382
we're going to use our own
contracts, instead of already

10623
10:38:23.382 --> 10:38:27.382
established contracts. If we're
on a network that doesn't have

10624
10:38:27.382 --> 10:38:30.382
any price, few contracts, like
hard hat or locos, for example.

10625
10:38:30.382 --> 10:38:34.382
So let's write our deploy mock
script. So the setup of this is

10626
10:38:34.382 --> 10:38:37.382
going to look nearly identical
to our deploy Funmi. And again,

10627
10:38:37.382 --> 10:38:41.382
if you want to set it up like
this, you absolutely can. But

10628
10:38:41.382 --> 10:38:43.382
I'm actually just going to copy
this, this part, paste it in

10629
10:38:43.382 --> 10:38:46.382
here, because that initial part
is going to be exactly the same.

10630
10:38:47.382 --> 10:38:49.382
Oh, and over here, I just
realized that we're calling this

10631
10:38:49.382 --> 10:38:52.382
network thing without being
defined, JavaScript will kind of

10632
10:38:52.382 --> 10:38:54.382
be smart enough to know where
this network thing is coming

10633
10:38:54.382 --> 10:38:57.382
from. But it can be a little bit
confusing. So it's better to be

10634
10:38:57.382 --> 10:39:03.383
really explicit, and say, const.
Network equals require hard hat,

10635
10:39:03.383 --> 10:39:07.383
this network thing is coming
from hard hat. And we're going

10636
10:39:07.383 --> 10:39:10.383
to grab this line. And we're
also going to use this at the

10637
10:39:10.383 --> 10:39:13.383
top of our script here. And then
our top section is going to look

10638
10:39:13.383 --> 10:39:16.383
exactly the same as well, we're
going to grab these three lines,

10639
10:39:16.383 --> 10:39:19.383
and paste them in deploy
deployer chain ID, boom, it's

10640
10:39:19.383 --> 10:39:21.383
all going to be the same here,
because we're setting up to

10641
10:39:21.383 --> 10:39:25.383
deploy some stuff. Now we want
to deploy a new contract. But if

10642
10:39:25.383 --> 10:39:28.383
we look at our contracts folder,
this is all we have right now.

10643
10:39:28.383 --> 10:39:32.383
So we're going to need to add
this mock this fake contract to

10644
10:39:32.383 --> 10:39:35.383
our contracts folder. Now what
we can do is in our contracts

10645
10:39:35.383 --> 10:39:38.383
folder, we want to separate this
file from the rest of our file

10646
10:39:38.383 --> 10:39:41.383
so that we know okay, this isn't
part of our project, but it is

10647
10:39:41.383 --> 10:39:44.383
part of our testing. So we're
going to right click Create New

10648
10:39:44.383 --> 10:39:49.383
Folder. And we can either call
it mocks, or test I like to call

10649
10:39:49.383 --> 10:39:52.383
mine test. And inside of this
folder, we can go ahead and

10650
10:39:52.383 --> 10:39:54.383
right click create a new file,
I'm going to create a new file

10651
10:39:54.383 --> 10:40:01.383
and call it mock, v3 aggregate
tore that soul. And this is

10652
10:40:01.383 --> 10:40:05.383
where we're going to define our
mock price feed aggregator

10653
10:40:05.383 --> 10:40:09.383
ourselves. So how can we create
our own fake price feed

10654
10:40:09.383 --> 10:40:12.383
contract, so we can test
everything locally? Well, one

10655
10:40:12.383 --> 10:40:16.383
thing we could do is we go to
the chain link GitHub repo, and

10656
10:40:16.383 --> 10:40:18.383
go through the contracts and
find one of these price feed

10657
10:40:18.383 --> 10:40:22.383
addresses, source eight, or
maybe we'll go back to source

10658
10:40:22.383 --> 10:40:26.383
we'll maybe we'll check in V
six.

10659
10:40:26.383 --> 10:40:29.383
Looks like we could find some
stuff and look around and we

10660
10:40:29.383 --> 10:40:32.383
probably copy paste all this
code, but it really seems like

10661
10:40:32.383 --> 10:40:35.383
kind of a huge pain in the butt
to have to copy all this code.

10662
10:40:35.383 --> 10:40:38.383
Now we absolutely could we copy
paste the code in here, but

10663
10:40:38.383 --> 10:40:40.384
we're gonna do something a
little bit more clever. So the

10664
10:40:40.384 --> 10:40:44.384
chainlink repo actually comes
with some mocks. If we go to

10665
10:40:44.384 --> 10:40:52.384
contracts, SRC V 0.6 tests They
actually have a mock v3

10666
10:40:52.384 --> 10:40:56.384
aggregator dot soul in here that
we can use as our mock. So we

10667
10:40:56.384 --> 10:40:59.384
can copy paste everything, but
we'd have to revamp a little bit

10668
10:40:59.384 --> 10:41:03.384
of it because it's doing some
dot dot stuff. It's talking to

10669
10:41:03.384 --> 10:41:06.384
other contracts that are locally
in this file structure that are

10670
10:41:06.384 --> 10:41:10.384
not going to be in our file
structure. So instead though,

10671
10:41:10.384 --> 10:41:13.384
what we can do is we can use
this node modules package to our

10672
10:41:13.384 --> 10:41:19.384
advantage, we can just say
pragma, solidity, carrot zero,

10673
10:41:19.384 --> 10:41:22.384
point 6.0, we'll use the same
version that that package is

10674
10:41:22.384 --> 10:41:28.384
doing. And then just do import
at a chain link slash contracts

10675
10:41:28.384 --> 10:41:35.384
slash SRC slash v 0.6. Slash
tests slash mock, B, three egg,

10676
10:41:35.384 --> 10:41:40.384
Reg, gay tore that soul. And
then we'll add, and then of

10677
10:41:40.384 --> 10:41:46.384
course, we'll add spdx, license
identifier, MIT. And boom, this

10678
10:41:46.384 --> 10:41:50.384
is actually all we need. If we
just import the code like this,

10679
10:41:50.384 --> 10:41:54.384
remember, this is exactly the
same as copy pasting this

10680
10:41:54.384 --> 10:41:58.384
contract into our project, of
course, with this path resolve

10681
10:41:59.384 --> 10:42:03.384
to where it actually is in our
node modules. Now, actually, I

10682
10:42:03.384 --> 10:42:07.384
can run yarn hardhat compile,
and it will also compile this

10683
10:42:07.384 --> 10:42:12.384
contract. Except for of course,
we have an issue, hey, compiler

10684
10:42:12.384 --> 10:42:15.384
versions don't match. Right?
What's What's up with that now,

10685
10:42:15.384 --> 10:42:18.384
you're going to get into
situations where you will be

10686
10:42:18.384 --> 10:42:20.385
working with contracts that are
not the same version of solidity

10687
10:42:20.385 --> 10:42:23.385
as you why well because
contracts keep being deployed

10688
10:42:23.385 --> 10:42:26.385
all the time. And there are a
ton of contracts that are in

10689
10:42:26.385 --> 10:42:32.385
version 0.4, solidity,
0.5 0.678, and probably 910, or

10690
10:42:32.385 --> 10:42:35.385
15 billion, or however many
solidity versions will come to

10691
10:42:35.385 --> 10:42:38.385
be. So in our config, in our
hard hat dot config, when you

10692
10:42:38.385 --> 10:42:41.385
scroll to the bottom, we can
scroll to where we're defining

10693
10:42:41.385 --> 10:42:45.385
our solidity version. And we can
actually add multiple solidity

10694
10:42:45.385 --> 10:42:49.385
versions, so that our compiler
can compile multiple versions of

10695
10:42:49.385 --> 10:42:54.385
solidity. To do that, we'll say,
so Lyd, did T. And we'll turn it

10696
10:42:54.385 --> 10:42:57.385
into an object here, we'll make
sure to put this comma here. And

10697
10:42:57.385 --> 10:43:01.385
inside our solidity object,
we'll put compilers and we'll

10698
10:43:01.385 --> 10:43:06.385
have a list of compilers. Our
first one we'll say is version,

10699
10:43:06.385 --> 10:43:09.385
zero, point 8.8. And we'll say
our second one is going to be

10700
10:43:09.385 --> 10:43:15.385
version 0.6, point six, and then
we'll go ahead and save that.

10701
10:43:15.385 --> 10:43:17.385
And it looks like mine wanted to
format it like this, which is

10702
10:43:17.385 --> 10:43:22.385
fine. Now, we can go ahead,
rerun, yarn, Hardhead, compile,

10703
10:43:22.385 --> 10:43:26.385
and boom, compiled five solidity
files successfully. This means

10704
10:43:26.385 --> 10:43:29.385
that our Mark V aggregator
should also have been compiled.

10705
10:43:29.385 --> 10:43:34.385
And if we look in artifacts, at
chain link, do indeed see this

10706
10:43:34.385 --> 10:43:38.385
at chain link slash contract
slash SRC bid, and a v 0.6. In

10707
10:43:38.385 --> 10:43:41.385
tests, we see this mock
aggregator dot soul, which has

10708
10:43:41.385 --> 10:43:45.385
been compiled. Awesome. So now
that we have our mock contract

10709
10:43:45.385 --> 10:43:50.385
compiled, we now have a contract
that we can use to deploy a fake

10710
10:43:50.385 --> 10:43:53.385
price feed to a blockchain. So
how do we actually do this?

10711
10:43:53.385 --> 10:43:56.385
Well, it's going to be the exact
same way that we deployed the

10712
10:43:56.385 --> 10:43:59.386
Funmi contract. But we're going
to add a little if statement in

10713
10:43:59.386 --> 10:44:04.386
here, we don't want to deploy
this mock contract to a test net

10714
10:44:04.386 --> 10:44:08.386
or a network that actually has a
price feed on it, we could just

10715
10:44:08.386 --> 10:44:13.386
do something like if chain ID
does not equal, you know, some

10716
10:44:13.386 --> 10:44:17.386
chain ID, then deploy marks,
right. And then this is kind of

10717
10:44:17.386 --> 10:44:19.386
pseudocode. Obviously, this code
won't actually work. But

10718
10:44:19.386 --> 10:44:22.386
instead, what I like is I
actually like to specify which

10719
10:44:22.386 --> 10:44:25.386
chains are going to be my
development chains, which chains

10720
10:44:25.386 --> 10:44:29.386
are going to be the one that I
can deploy these mocks to, in my

10721
10:44:29.386 --> 10:44:32.386
helper, hard hat config, I'll
define these chains. So I'll say

10722
10:44:32.386 --> 10:44:38.386
const, development chains,
equals, and then I'll just say

10723
10:44:38.386 --> 10:44:45.386
hard hat, and local host. I'll
export these. And back in my

10724
10:44:45.386 --> 10:44:51.386
deploy mocks, I'll import these
with const. Development chains

10725
10:44:51.386 --> 10:44:58.386
equals require dot dot slash
helper Hardhead config. And now

10726
10:44:58.386 --> 10:45:06.386
I'll say if development chains
dot includes chain ID. This

10727
10:45:06.386 --> 10:45:10.386
includes keyword basically is a
function that checks to see if

10728
10:45:10.386 --> 10:45:13.386
some variable is inside an
array, then we're gonna go ahead

10729
10:45:13.386 --> 10:45:17.386
and deploy Max, and which is
what we want to do. So we'll do

10730
10:45:17.386 --> 10:45:19.386
log, which we're getting from
deployments, which is basically

10731
10:45:19.386 --> 10:45:25.386
console dot log. And we'll say
local network detected,

10732
10:45:25.386 --> 10:45:28.386
deploying mocks.

10733
10:45:28.386 --> 10:45:34.386
And we'll do a weight ploy, and
we'll deploy our new mock v3

10734
10:45:34.386 --> 10:45:40.387
aggregator mock v3 aggregator
will do a comma. There a little

10735
10:45:40.387 --> 10:45:43.387
colons here. If we want to get
really specific, we can say

10736
10:45:43.387 --> 10:45:47.387
contract v3 aggregator which
we're kind of already saying

10737
10:45:47.387 --> 10:45:53.387
we'll say from deployer We'll
say logging is going to be true.

10738
10:45:53.387 --> 10:45:56.387
And then we need to pass some
arguments, we need to pass the

10739
10:45:56.387 --> 10:46:00.387
constructor parameters for the
mock v3 aggregator, which are

10740
10:46:00.387 --> 10:46:04.387
what? Well, let's go to docs
chain to link to find out. Or

10741
10:46:04.387 --> 10:46:10.387
you can also just go to Node
modules chainlink, SRC V 06,

10742
10:46:10.387 --> 10:46:13.387
tests, and then all the way down
to mock V three, aggregated out.

10743
10:46:13.387 --> 10:46:17.387
So where you could also find the
constructor in here, whatever

10744
10:46:17.387 --> 10:46:19.387
one you like better, sometimes I
find it easier just to read

10745
10:46:19.387 --> 10:46:25.387
GitHub Ctrl plus F or Command
plus F for constructor. We see

10746
10:46:25.387 --> 10:46:29.387
it takes a decimals and an
initial answer. And if we read

10747
10:46:29.387 --> 10:46:33.387
through the code, we'll learn
that the decimals object is

10748
10:46:33.387 --> 10:46:36.387
going to be equivalent to the
decimals parameter is going to

10749
10:46:36.387 --> 10:46:40.387
be equivalent to this decimals
function and the initial answer.

10750
10:46:40.387 --> 10:46:43.387
And the initial answer is
basically just going to be what

10751
10:46:43.387 --> 10:46:45.387
is the price feed starting at,
we actually get to pick the

10752
10:46:45.387 --> 10:46:48.387
price of the price feed, which
works out really well, because

10753
10:46:48.387 --> 10:46:51.387
that works out great for
testing. I usually like to

10754
10:46:51.387 --> 10:46:53.387
define the decimals and the
initial answers somewhere

10755
10:46:53.387 --> 10:46:57.387
outside of this function so that
I can access it later. One good

10756
10:46:57.387 --> 10:47:00.387
place you can add it is once
again in our helper Hardhead

10757
10:47:00.387 --> 10:47:06.387
config.js. So I might do const
decimals equals eight. And then

10758
10:47:06.387 --> 10:47:15.387
const initial answer. Answer
equals, and we'll do 2000. So

10759
10:47:15.387 --> 10:47:20.388
since we have a decimals, we'll
do 2000 And then 123456788

10760
10:47:20.388 --> 10:47:24.388
decimal places, and then we'll
export these as well. Export

10761
10:47:24.388 --> 10:47:28.388
decimals, and export initial
answer. We could of course, just

10762
10:47:28.388 --> 10:47:32.388
do you know, const decimals
equals eight at the top and then

10763
10:47:32.388 --> 10:47:35.388
initial answer and then use them
down here. But I like to do it

10764
10:47:35.388 --> 10:47:39.388
like that. So Conce. So now we
have to import them in here.

10765
10:47:39.388 --> 10:47:43.388
const development chains. It's
also grabbed decimals. It's also

10766
10:47:43.388 --> 10:47:47.388
grabbed initial answer, we'll
save it. We'll take a look back

10767
10:47:47.388 --> 10:47:49.388
at the constructor looks like
it's decimals first, initial

10768
10:47:49.388 --> 10:47:52.388
answers second. So in our
arguments, we'll do decimals

10769
10:47:52.388 --> 10:47:57.388
first, initial answers second,
and tada. And then we will be

10770
10:47:57.388 --> 10:48:01.388
all done that we'll do a quick
log box deployed. And then I

10771
10:48:01.388 --> 10:48:05.388
also like to do kind of like a
big line at the end of all of my

10772
10:48:05.388 --> 10:48:08.388
deploy scripts just to be like,
hey, that's the end of this

10773
10:48:08.388 --> 10:48:11.388
deploy script. Anything else
after this is going to be a

10774
10:48:11.388 --> 10:48:14.388
different deploy script. All
right, great. Now our deployed

10775
10:48:14.388 --> 10:48:17.388
mocks script is actually done.
But our deploy Funmi script

10776
10:48:17.388 --> 10:48:21.388
isn't quite done. Is there a way
that we could run only our

10777
10:48:21.388 --> 10:48:25.388
deploy mock script? Well, yes,
there is. Great, thanks for

10778
10:48:25.388 --> 10:48:27.388
asking. What we can do at the
bottom of our deploy mock script

10779
10:48:27.388 --> 10:48:34.388
is we can add a module that
exports dot tags, equals, and

10780
10:48:35.388 --> 10:48:40.388
we'll say all and marks. Now
what we can do is if we run

10781
10:48:40.388 --> 10:48:46.388
yarn, hard hat deploy, we can
add this flag dash dash tags.

10782
10:48:46.388 --> 10:48:50.388
And it will only run the deploy
scripts that have a special tag.

10783
10:48:50.388 --> 10:48:55.388
So we'll run our mocks tag,
which means it'll only run our

10784
10:48:55.388 --> 10:48:59.389
deploy mock script. And, and
oops, actually, in our helper

10785
10:48:59.389 --> 10:49:03.389
config development chains is
actually hard hat and localhost.

10786
10:49:03.389 --> 10:49:06.389
And I said, we're going to try
to do with the chain ID, sorry,

10787
10:49:06.389 --> 10:49:09.389
we're going to do this, we're
gonna do development chains dot

10788
10:49:09.389 --> 10:49:15.389
includes network dot name.

10789
10:49:15.389 --> 10:49:19.389
Because our helper config is
using names and not chain IDs,

10790
10:49:19.389 --> 10:49:23.389
so if development chains that
includes that network the names,

10791
10:49:23.389 --> 10:49:25.389
then we're gonna go ahead and
deploy the mocks. So let's go

10792
10:49:25.389 --> 10:49:28.389
ahead and run this yarn here and
hit Deploy dash dash tags,

10793
10:49:28.389 --> 10:49:32.389
mocks. And perfect we do indeed
see our mocks getting deployed

10794
10:49:32.389 --> 10:49:36.389
here. This log true means that
it's going to spit out stuff

10795
10:49:36.389 --> 10:49:39.389
like this. It'll say contract,
it's deploying, it'll say the

10796
10:49:39.389 --> 10:49:42.389
transaction it's doing and it'll
say where it was deployed with

10797
10:49:42.389 --> 10:49:46.389
how much gas and awesome This
means our deployed Mach script

10798
10:49:47.389 --> 10:49:50.389
is working perfectly. So now we
have our deploy mocks script

10799
10:49:50.389 --> 10:49:54.389
working perfectly. So how do we
apply that back to our deploy

10800
10:49:54.389 --> 10:49:57.389
Funmi script? Well, we're gonna
do the exact same thing here.

10801
10:49:57.389 --> 10:50:01.389
Instead of making eth USD price
feed address constant variable,

10802
10:50:01.389 --> 10:50:04.389
we're gonna say let at USD price
you'd variable so that we can

10803
10:50:04.389 --> 10:50:09.389
actually update it. And we'll
say, if development chains dot

10804
10:50:09.389 --> 10:50:15.389
includes network dot name, what
we can do with hard hat deploy

10805
10:50:15.389 --> 10:50:19.389
is we can just get the most
recent deployment using a

10806
10:50:19.389 --> 10:50:23.389
command called literally get. So
we'll say const. eth USD

10807
10:50:23.389 --> 10:50:30.389
aggregator equals await
deployments dot get. And then

10808
10:50:30.389 --> 10:50:34.389
the name of the contract that we
deployed Mach v3 aggregator, and

10809
10:50:34.389 --> 10:50:37.389
if you wanted to just do get
instead of deployments dot get,

10810
10:50:37.389 --> 10:50:42.390
we absolutely could, just by
doing it like this. Those are

10811
10:50:42.390 --> 10:50:45.390
exactly the same. So we'll get
the address like this and then

10812
10:50:45.390 --> 10:50:52.390
we'll say eth USD price feed
address equals that eth USD

10813
10:50:52.390 --> 10:50:56.390
aggregator contract dot address.
And then if we're not on a

10814
10:50:56.390 --> 10:51:00.390
development chain, if we didn't
deploy a mock, we're just going

10815
10:51:00.390 --> 10:51:04.390
to do exactly what we did
before. With using the network

10816
10:51:04.390 --> 10:51:09.390
config. Oh, my goodness. Now,
now that we've done all of these

10817
10:51:09.390 --> 10:51:13.390
steps, let's add a little log
thing at the bottom here with

10818
10:51:13.390 --> 10:51:18.390
just a bunch of hyphens. Now, we
should have a very robust script

10819
10:51:18.390 --> 10:51:22.390
to flip between a local
development chain, a test net

10820
10:51:22.390 --> 10:51:25.390
chain, a main net chain, and
allow us to deploy literally

10821
10:51:25.390 --> 10:51:29.390
everywhere without changing any
of our solidity. And then we

10822
10:51:29.390 --> 10:51:34.390
just take this, this eth USD
price feed address and stick it

10823
10:51:34.390 --> 10:51:38.390
into logs here. And then at the
bottom, we can do module dot

10824
10:51:38.390 --> 10:51:43.390
exports, dot tags equals and
then we'll just do all and then

10825
10:51:43.390 --> 10:51:48.390
we'll call this one Funmi. Oh,
now moment of truth. If we did

10826
10:51:48.390 --> 10:51:52.390
all this, right, we should just
be able to run yarn, hard hat

10827
10:51:52.390 --> 10:51:57.390
deploy. And it should work on
our local chain, our hard hat

10828
10:51:57.390 --> 10:52:00.390
chain. And then it should also
work on any test net that we

10829
10:52:00.390 --> 10:52:04.390
give it. So let's give this a
try. Yarn, Hardhead deploy.

10830
10:52:04.390 --> 10:52:07.390
Let's see if this works.
Awesome. And we got this all to

10831
10:52:07.390 --> 10:52:11.390
deploy locally to our Hard Hat
Network, we can see that we went

10832
10:52:11.390 --> 10:52:15.390
ahead and we deployed mocks, we
did our little underline here.

10833
10:52:15.390 --> 10:52:18.390
And then we deployed Funmi
deployed at this address with

10834
10:52:18.390 --> 10:52:21.391
this much gas. Now, what are the
other awesome things about hard

10835
10:52:21.391 --> 10:52:24.391
hat deploy? When we run our
local blockchain, our own

10836
10:52:24.391 --> 10:52:29.391
blockchain node, hard hat deploy
will automatically run through

10837
10:52:29.391 --> 10:52:33.391
all of our deploy scripts and
add them to our node. So now if

10838
10:52:33.391 --> 10:52:38.391
I run yarn, hard hat node, we're
going to spin up a new

10839
10:52:38.391 --> 10:52:41.391
blockchain node, but it's
already going to have all of our

10840
10:52:41.391 --> 10:52:45.391
deployed contracts on it. So
every time we spin up a local

10841
10:52:45.391 --> 10:52:48.391
node, now it's going to come
automatically packed with the

10842
10:52:48.391 --> 10:52:54.391
contracts that we want on it. So
we are going to show us doing

10843
10:52:54.391 --> 10:52:57.391
this on a test net on Rinkeby.
But before we actually test it

10844
10:52:57.391 --> 10:53:00.391
on Rinkeby, I'm going to add a
little bit of the auto

10845
10:53:00.391 --> 10:53:03.391
verification piece in here as
well, because we did that in the

10846
10:53:03.391 --> 10:53:06.391
last lesson. And we wanted to
show how to do it in hard hat

10847
10:53:06.391 --> 10:53:09.391
deploy as well. So right after
we deploy our Funmi, we can do

10848
10:53:09.391 --> 10:53:13.391
something similar here, we'll
say, if developer chains

10849
10:53:13.391 --> 10:53:17.391
includes network dot name, we'll
say if developer chains doesn't

10850
10:53:17.391 --> 10:53:19.391
include network dot name,
because we don't want to verify

10851
10:53:19.391 --> 10:53:25.391
on a local network. So we'll say
if not development chains dot

10852
10:53:25.391 --> 10:53:28.391
includes network dot name, the
exclamation mark, aka the bang

10853
10:53:29.391 --> 10:53:32.391
means not when we're talking
about booleans. So we're saying,

10854
10:53:32.391 --> 10:53:36.391
if the name of the network isn't
a development chain, we want to

10855
10:53:36.391 --> 10:53:41.391
go ahead and verify and same as
last time. And if process dot e

10856
10:53:41.391 --> 10:53:46.391
NV dot ether scan API key,

10857
10:53:46.391 --> 10:53:50.391
then we're going to go ahead and
verify. Now before we had our

10858
10:53:50.391 --> 10:53:53.391
verify code, right in our deploy
code, we're gonna do something a

10859
10:53:53.391 --> 10:53:56.391
little bit different here.
Instead of having our verify

10860
10:53:56.391 --> 10:53:59.392
code in our deploy scripts here,
we're actually going to create a

10861
10:53:59.392 --> 10:54:04.392
new folder called utils, which
stands for utilities. And this

10862
10:54:04.392 --> 10:54:07.392
is where we're going to add
different scripts that we can

10863
10:54:07.392 --> 10:54:09.392
use across different
deployments. Because let's say

10864
10:54:09.392 --> 10:54:12.392
we have 50 Deploy scripts, we're
not going to make 50 Deploy

10865
10:54:12.392 --> 10:54:15.392
functions, we're just going to
add them to our utils folder,

10866
10:54:15.392 --> 10:54:19.392
and in our utils folder, or
create a new file called verify

10867
10:54:19.392 --> 10:54:23.392
dot j s, we're going to add that
code from our last project in

10868
10:54:23.392 --> 10:54:26.392
here. So if you want, you can go
ahead copy paste from our last

10869
10:54:26.392 --> 10:54:30.392
project over to this one, or you
can pause the video to type it

10870
10:54:30.392 --> 10:54:33.392
out yourself. Since we're using
the run command here, we're

10871
10:54:33.392 --> 10:54:38.392
gonna do const run equals
require RT hat. And then at the

10872
10:54:38.392 --> 10:54:48.392
bottom, we're going to do module
exports. Exports equals verify.

10873
10:54:48.392 --> 10:54:53.392
Now that we have a verify script
in our utils folder, back in our

10874
10:54:53.392 --> 10:54:59.392
deploy Funmi we're going to say
const. Verify equals require dot

10875
10:54:59.392 --> 10:55:04.392
dot slash utils. Slash verify.
And since now in our verified

10876
10:55:05.392 --> 10:55:08.392
Jas, we have a lot of this
trycatch stuff in here, we can

10877
10:55:08.392 --> 10:55:15.392
just do a wait. Verify and a
verify once again takes a

10878
10:55:15.392 --> 10:55:18.392
contract address and a list of
arguments. We'll say await

10879
10:55:18.392 --> 10:55:24.392
verify, fund me dot address and
then the list of arguments. To

10880
10:55:24.392 --> 10:55:27.392
make the list of arguments
easier to put in. You can go

10881
10:55:27.392 --> 10:55:32.392
const args, equals and then
we'll just stick our eth USD

10882
10:55:32.392 --> 10:55:37.392
price feed in here and then
replace this with args and then

10883
10:55:37.392 --> 10:55:42.393
take this args and pop it on
down into the second parameter

10884
10:55:42.393 --> 10:55:48.393
here. All right, great. Now
let's go ahead and deploy this

10885
10:55:48.393 --> 10:55:51.393
to With the Rinkeby test net,
and what do we need to deploy

10886
10:55:51.393 --> 10:55:53.393
this to the Rinkeby test net?
Well, let's jump into our hard

10887
10:55:53.393 --> 10:55:57.393
hat config first. And let's
clean this up, we don't really

10888
10:55:57.393 --> 10:56:00.393
need this accounts task, so I'm
just going to delete it, I don't

10889
10:56:00.393 --> 10:56:03.393
really need this comment. So I'm
going to delete this too. And

10890
10:56:03.393 --> 10:56:06.393
let's jump into the network
section, we're not going to be

10891
10:56:06.393 --> 10:56:09.393
working with ropsten. So we're
gonna go ahead and dump that. We

10892
10:56:09.393 --> 10:56:13.393
are however, going to be working
with rink B, the URL is going to

10893
10:56:13.393 --> 10:56:18.393
be that same Rinkeby RPC URL. So
we're going to define that up

10894
10:56:18.393 --> 10:56:21.393
here, like we did before. And if
you want to copy paste from your

10895
10:56:21.393 --> 10:56:25.393
last project, feel free to do so
you can also follow along with

10896
10:56:25.393 --> 10:56:38.393
me or fastforward me the counts
is going to be the same. I'm

10897
10:56:38.393 --> 10:56:41.393
going to go ahead and just copy
paste the gas reporter with what

10898
10:56:41.393 --> 10:56:44.393
we had from before. So we're
going to add this constant corn

10899
10:56:44.393 --> 10:56:49.393
market cap API key equals
process dot EMV dot corn market

10900
10:56:49.393 --> 10:56:53.393
cap API key. Do the same thing
with the ether scan API key

10901
10:56:53.393 --> 10:57:00.393
Licious add everything in here.
Now. We have our ether scan

10902
10:57:00.393 --> 10:57:04.393
section in here already, we're
gonna have our gas reporter be

10903
10:57:04.393 --> 10:57:07.393
false, because I don't really
feel like using it right now.

10904
10:57:07.393 --> 10:57:10.393
And then finally, we're going to
add one more thing in here.

10905
10:57:10.393 --> 10:57:12.393
Remember how in our last
project, before we actually

10906
10:57:12.393 --> 10:57:16.393
verified we waited some block
confirmations. That way ether

10907
10:57:16.393 --> 10:57:19.393
scan could make sure to catch
up. Well, we can do the exact

10908
10:57:19.393 --> 10:57:22.394
same thing in here in our hard
hat dot config, we can add a

10909
10:57:22.394 --> 10:57:26.394
section for each test net for
how many blocks we want to wait,

10910
10:57:26.394 --> 10:57:33.394
I'm going to add block
confirmations of six. Now back

10911
10:57:33.394 --> 10:57:37.394
on our deploy Funmi. In a new
section, I can add wait

10912
10:57:37.394 --> 10:57:47.394
confirmations of network dot
config. That block on for

10913
10:57:47.394 --> 10:57:53.394
motions, or one is or one means
if no block confirmations is

10914
10:57:53.394 --> 10:57:57.394
given in our Hardhead dot config
will just wait for one block.

10915
10:57:57.394 --> 10:57:59.394
And again, the reason we want to
wait for approximately six block

10916
10:57:59.394 --> 10:58:03.394
confirmations is we want to give
ether scan a chance to index our

10917
10:58:03.394 --> 10:58:07.394
transaction. And I added a chain
ID 42 when it should be for my

10918
10:58:07.394 --> 10:58:11.394
mistake. And of course, we're
going to need our dot env file,

10919
10:58:11.394 --> 10:58:14.394
where we add all of our stuff
from the last session, the RIP

10920
10:58:14.394 --> 10:58:18.394
ERP CRL private key ether scan
API and then coin market cap

10921
10:58:18.394 --> 10:58:22.394
API. All right moment of truth.
Let's try this out. If we run

10922
10:58:23.394 --> 10:58:30.394
yarn Hardhead deploy dash dash
network Rinkeby. It should not

10923
10:58:30.394 --> 10:58:34.394
deploy any marks because we have
this if statement in our mock

10924
10:58:34.394 --> 10:58:39.394
deployment. But it should deploy
our Funmi contract using the

10925
10:58:39.394 --> 10:58:43.394
correct price feed address. And
then it'll go ahead and verify

10926
10:58:43.394 --> 10:58:47.394
it. Since we're waiting for six
block confirmations, we can even

10927
10:58:47.394 --> 10:58:51.394
be super secure by adding dash
dash tags and just running the

10928
10:58:51.394 --> 10:58:55.394
funding tag. But we're just
going to do yarn hearted deploy

10929
10:58:55.394 --> 10:58:59.395
network Rigby. And let's see
what happens. All right, and

10930
10:58:59.395 --> 10:59:03.395
we're deploying funding. And we
can see the transaction that we

10931
10:59:03.395 --> 10:59:08.395
have for fun me, this is that
logging feature, we have log is

10932
10:59:08.395 --> 10:59:12.395
true for deploying Funmi. So it
gives us the transaction once it

10933
10:59:12.395 --> 10:59:16.395
has a transaction, and it will
give us the address once we have

10934
10:59:16.395 --> 10:59:20.395
the address. So we're going to
wait six block confirmations for

10935
10:59:20.395 --> 10:59:23.395
this transaction to finish going
through. Now we see we've

10936
10:59:23.395 --> 10:59:27.395
deployed this contract address
with X amount of gas. And now

10937
10:59:27.395 --> 10:59:30.395
we're running the verification
process. While the verification

10938
10:59:30.395 --> 10:59:35.395
process is running, we can pull
up Rinkeby ether scan, paste our

10939
10:59:35.395 --> 10:59:39.395
address in here and see that we
have indeed created this

10940
10:59:39.395 --> 10:59:42.395
contract. And now it looks like
we've successfully verified the

10941
10:59:42.395 --> 10:59:46.395
contract on ether scan. So if we
hit refresh, we can indeed see

10942
10:59:46.395 --> 10:59:50.395
that the contract has been
verified. Awesome. All right. So

10943
10:59:50.395 --> 10:59:53.395
this is fantastic. Our deploy
script is looking great, we're

10944
10:59:53.395 --> 10:59:57.395
able to deploy to a local chain,
we're able to deploy to a test

10945
10:59:57.395 --> 11:00:00.395
that and if we wanted to, we
could deploy to any network that

10946
11:00:00.395 --> 11:00:03.395
we wanted simply by updating our
hard hat config, and then

10947
11:00:03.395 --> 11:00:07.395
updating our helper config. This
is fantastic.

10948
11:00:07.395 --> 11:00:13.395
Great work so far. Now we're
about to jump in and level up

10949
11:00:13.395 --> 11:00:16.395
our tests. But before we do
that, we're going to clean up

10950
11:00:16.395 --> 11:00:19.395
our Funmi contract a little bit
to make it look a little bit

10951
11:00:19.395 --> 11:00:22.395
more professional. And I'm going
to talk about some of the syntax

10952
11:00:22.395 --> 11:00:25.395
and some of the reasons why some
conventions exist. We're not

10953
11:00:25.395 --> 11:00:29.395
going to do this full force on
all the projects moving forward.

10954
11:00:29.395 --> 11:00:31.395
But they are good to know and
they are good to keep in mind

10955
11:00:31.395 --> 11:00:35.395
when moving forward and working
with our contracts. While we go

10956
11:00:35.395 --> 11:00:37.395
through this we're going to
learn why some of these

10957
11:00:37.395 --> 11:00:40.396
conventions exist including
learning a little bit of low

10958
11:00:40.396 --> 11:00:43.396
level solidity. So don't skip
this part. When we get to later

10959
11:00:43.396 --> 11:00:46.396
sections. We're going to be a
little bit looser and not be as

10960
11:00:46.396 --> 11:00:49.396
strict with the code style
guides but That's basically what

10961
11:00:49.396 --> 11:00:52.396
we're gonna go over now. And for
now, you might see this event

10962
11:00:52.396 --> 11:00:55.396
funded thing here, please just
ignore that for now, in an

10963
11:00:55.396 --> 11:00:58.396
earlier take, I'd introduced the
events much earlier. And now

10964
11:00:58.396 --> 11:01:00.396
we're actually going to learn
about events a little bit later

10965
11:01:00.396 --> 11:01:04.396
in the course. So please ignore
that event funded for now. So

10966
11:01:04.396 --> 11:01:06.396
let's go ahead and tweak a
little bit of our contracts

10967
11:01:06.396 --> 11:01:08.396
here. Now what I'm talking about
tweaking this to make it look

10968
11:01:08.396 --> 11:01:11.396
professional, a little bit more
professional, I'm talking about

10969
11:01:11.396 --> 11:01:14.396
the solidity style guide, there
are some conventions for naming

10970
11:01:14.396 --> 11:01:17.396
and ordering that we can follow
to make our code look a little

10971
11:01:17.396 --> 11:01:20.396
bit better. Now, like I said,
this is going to be a little bit

10972
11:01:20.396 --> 11:01:23.396
more optional, because it can be
a little bit verbose. And it

10973
11:01:23.396 --> 11:01:26.396
doesn't really make that big of
a difference. But it can

10974
11:01:26.396 --> 11:01:29.396
increase readability of your
contracts by a lot and make your

10975
11:01:29.396 --> 11:01:33.396
code look a lot nicer. So if you
want, you can go through this

10976
11:01:33.396 --> 11:01:36.396
style guide to learn more about
what kind of makes solidity look

10977
11:01:36.396 --> 11:01:39.396
nice, and what makes it not look
nice. But well, that's some of

10978
11:01:39.396 --> 11:01:41.396
these style guides in here,
we're not going to follow the

10979
11:01:41.396 --> 11:01:44.396
style guide exactly to a tee.
But we are going to make some

10980
11:01:44.396 --> 11:01:47.396
best efforts to make our code
follow the style guide, we've

10981
11:01:47.396 --> 11:01:50.396
got a link to the style guide in
the GitHub repository for this

10982
11:01:50.396 --> 11:01:53.396
section, we can read some more
about the layout. But the main

10983
11:01:53.396 --> 11:01:55.396
thing we want to look at is this
order of the layout, we want to

10984
11:01:55.396 --> 11:01:59.396
start with our imports with our
pragma statement, our imports,

10985
11:01:59.396 --> 11:02:02.396
interfaces, libraries, and then
contracts. And then inside each

10986
11:02:02.396 --> 11:02:05.396
contract type declarations,
state variables, events,

10987
11:02:05.396 --> 11:02:08.396
modifiers, and functions. So
let's go back here and make sure

10988
11:02:08.396 --> 11:02:12.396
that we're up to speed, we want
our pragma first. Alright,

10989
11:02:12.396 --> 11:02:16.396
awesome, we did exactly that,
then we want our imports. Okay,

10990
11:02:16.396 --> 11:02:19.396
awesome, we have those too.
Something that's not in the

10991
11:02:19.396 --> 11:02:22.397
style guide is going to be error
codes, which we definitely want

10992
11:02:22.397 --> 11:02:27.397
next. So next is going to be
error codes. Now this is where

10993
11:02:27.397 --> 11:02:30.397
we're going to bump into one of
our first updates here. As of

10994
11:02:30.397 --> 11:02:34.397
recent, it's sort of becoming a
best practice to add the name of

10995
11:02:34.397 --> 11:02:37.397
your contract, some underscores,
and then the name of your error.

10996
11:02:38.397 --> 11:02:40.397
Whenever you're running into an
error. This makes it a lot

10997
11:02:40.397 --> 11:02:44.397
easier to understand which
contract is throwing the error.

10998
11:02:44.397 --> 11:02:48.397
So for this, we're going to say
error Funmi, two underscores not

10999
11:02:48.397 --> 11:02:52.397
owner, then we're going to
scroll down to the our revert

11000
11:02:52.397 --> 11:02:56.397
and set it like this. This way,
when if we ever run into this

11001
11:02:56.397 --> 11:02:59.397
error, we know that the error is
coming from the Funmi contract,

11002
11:02:59.397 --> 11:03:01.397
not from the aggregator v3
interface, or the price

11003
11:03:01.397 --> 11:03:05.397
converter or some other
contract. So that's how we want

11004
11:03:05.397 --> 11:03:07.397
to write our error codes here.
If we had any interfaces or

11005
11:03:07.397 --> 11:03:11.397
libraries not imported, we would
add them here. But then finally,

11006
11:03:11.397 --> 11:03:15.397
we add our contracts. In this
file, we only have one contract

11007
11:03:15.397 --> 11:03:18.397
here. It's our Funmi contract.
Awesome. Now the next thing we

11008
11:03:18.397 --> 11:03:21.397
want to learn about as far as
style guides go is this thing

11009
11:03:21.397 --> 11:03:26.397
called natspec. natspec stands
for Etherium natural language

11010
11:03:26.397 --> 11:03:30.397
specification format. And it's
basically a way of documenting

11011
11:03:30.397 --> 11:03:34.397
our code inspired by Doxygen
uses Doxygen style comments and

11012
11:03:34.397 --> 11:03:38.397
tags to help document our code,
you can click the link here in

11013
11:03:38.397 --> 11:03:41.397
the solidity documentation to
learn more about Doxygen. If we

11014
11:03:41.397 --> 11:03:43.397
scroll down in the
documentation, here, we can see

11015
11:03:43.397 --> 11:03:47.397
an example of using natspec.
Whenever we have a contract or a

11016
11:03:47.397 --> 11:03:50.397
function that needs
documentation, we can add some

11017
11:03:50.397 --> 11:03:53.397
syntax that looks like this to
it. So for example, if we wanted

11018
11:03:53.397 --> 11:03:57.397
to add this to our code, we
could add a comment explaining

11019
11:03:57.397 --> 11:04:00.398
this funding contract to start a
piece of natspec, you can do

11020
11:04:00.398 --> 11:04:05.398
three backslashes, or one
backslash, two stars, and then

11021
11:04:05.398 --> 11:04:09.398
another ending star here.
Everything we put inside of this

11022
11:04:09.398 --> 11:04:12.398
comment section basically gets
turned into a comment. For the

11023
11:04:12.398 --> 11:04:15.398
start of our contract, we'll do
the Add sign title to explain

11024
11:04:15.398 --> 11:04:18.398
basically, what this contract
is, it's fun, we contract is

11025
11:04:18.398 --> 11:04:20.398
going to be a contract

11026
11:04:20.398 --> 11:04:27.398
for crowdfunding, we'll add
another star. And we can add the

11027
11:04:27.398 --> 11:04:31.398
author of it, which is going to
be your name, I'm going to put

11028
11:04:31.398 --> 11:04:35.398
Patrick Collins, of course, then
we'll add a notice, which is

11029
11:04:35.398 --> 11:04:39.398
just kind of a note to people we
can say this contract is is to

11030
11:04:39.398 --> 11:04:46.398
demo a sample funding contract.
And we can also add apt Dev,

11031
11:04:46.398 --> 11:04:50.398
which is a note specifically to
developers. And we can say this

11032
11:04:50.398 --> 11:04:54.398
implements price feeds as our
library. The reason that we want

11033
11:04:54.398 --> 11:04:58.398
to add these tags here is
actually because we can use the

11034
11:04:58.398 --> 11:05:02.398
natspec to automatically create
documentation for us if we

11035
11:05:02.398 --> 11:05:06.398
download so we can actually run
solc dash s user doc dash dash

11036
11:05:06.398 --> 11:05:10.398
dev doc, and the name of our
file to automatically generate

11037
11:05:10.398 --> 11:05:13.398
documentation. So this is also
really helpful for automatically

11038
11:05:13.398 --> 11:05:16.398
creating documentation for other
developers who interact with the

11039
11:05:16.398 --> 11:05:20.398
protocol later on. You can use
this natspec For as many or as

11040
11:05:20.398 --> 11:05:23.398
few functions as you'd like.
Most of us probably aren't going

11041
11:05:23.398 --> 11:05:26.398
to be making documentation. So
we really just want to follow

11042
11:05:26.398 --> 11:05:29.398
those guidelines if we think
some function or some section of

11043
11:05:29.398 --> 11:05:32.398
our code is a little bit tricky
for other developers. Now that

11044
11:05:32.398 --> 11:05:34.398
we're inside of contract, we can
follow the order of our

11045
11:05:34.398 --> 11:05:41.399
contract. We're first going to
start with type declarations

11046
11:05:41.399 --> 11:05:43.399
which we don't really have any
except for the fact that we're

11047
11:05:43.399 --> 11:05:48.399
using our price converter for
the UN 256 type. Okay, great.

11048
11:05:48.399 --> 11:05:51.399
You Next, after our type
declarations, we're going to do

11049
11:05:51.399 --> 11:05:54.399
state variables. And in this
state variables section, this is

11050
11:05:54.399 --> 11:05:57.399
where we're actually going to
change the name of some of our

11051
11:05:57.399 --> 11:06:00.399
state variables. So we'll do a
little common here state

11052
11:06:00.399 --> 11:06:04.399
variables. Now in the solidity
style guide, kind of adhere to

11053
11:06:04.399 --> 11:06:08.399
the naming styles, we use upper
and lowercase, we use total caps

11054
11:06:08.399 --> 11:06:12.399
with underscores here. However,
these naming variables are going

11055
11:06:12.399 --> 11:06:14.399
to change in the future in this
section. And if you're following

11056
11:06:14.399 --> 11:06:17.399
along with the GitHub repo
associated with this course,

11057
11:06:17.399 --> 11:06:19.399
these are going to be actually a
little bit different than what

11058
11:06:19.399 --> 11:06:22.399
you see. However, for now, we're
going to leave them as they are,

11059
11:06:22.399 --> 11:06:24.399
because the reason why we're
going to change them isn't going

11060
11:06:24.399 --> 11:06:27.399
to be quite clear yet. Don't
worry. So these names are going

11061
11:06:27.399 --> 11:06:31.399
to change soon, but not yet.
Alright, after state variables

11062
11:06:31.399 --> 11:06:34.399
comes events, and modifiers. We
don't have any events, but we do

11063
11:06:34.399 --> 11:06:39.399
have a modifier. So we'll copy
this. And actually, we'll delete

11064
11:06:39.399 --> 11:06:46.399
this comment here. And we'll
paste our modifier here. Oh, and

11065
11:06:46.399 --> 11:06:50.399
it looks like looks like we're
not auto formatting here. So

11066
11:06:50.399 --> 11:06:52.399
we're going to uncomment
immutable actually, so that it

11067
11:06:52.399 --> 11:06:55.399
automatically auto formats.
Okay, great. We're out of

11068
11:06:55.399 --> 11:06:57.399
formatting now. And Cool.
Alright, so now we have our

11069
11:06:57.399 --> 11:07:01.399
modifiers. Next, we have right
here, and then we have all of

11070
11:07:01.399 --> 11:07:05.399
our functions. Great. We
actually want to group our

11071
11:07:05.399 --> 11:07:08.399
functions in this order that I
just print here. So we want the

11072
11:07:08.399 --> 11:07:11.399
constructor which we have
received and fall back, we do

11073
11:07:11.399 --> 11:07:14.399
have fall back and receive. So
we're going to actually copy

11074
11:07:14.399 --> 11:07:20.400
those and delete this comment.
We're gonna stick those veterans

11075
11:07:20.400 --> 11:07:24.400
Heath here looks like receive
goes first. So we'll put that

11076
11:07:24.400 --> 11:07:29.400
here. Then external functions,
then public, internal, private.

11077
11:07:29.400 --> 11:07:32.400
So we have public public. And
that's it. And then we can

11078
11:07:32.400 --> 11:07:36.400
delete this part down here.
Okay. Cool. And if we want, we

11079
11:07:36.400 --> 11:07:40.400
can do that syntax up here from
the net spec for our functions.

11080
11:07:40.400 --> 11:07:44.400
For example, for fund it, we
could even just copy paste, we

11081
11:07:44.400 --> 11:07:48.400
would remove title, we would
remove author, and we just say

11082
11:07:48.400 --> 11:07:55.400
add, notice, this function,
funds this contract. And we can

11083
11:07:55.400 --> 11:07:58.400
even leave a little dev thing
here to talk about it. Now if we

11084
11:07:58.400 --> 11:08:02.400
have parameters, you can do apt
puram. And say like what the

11085
11:08:02.400 --> 11:08:06.400
parameter is. And then if we
have returns, we can say

11086
11:08:06.400 --> 11:08:10.400
returns, or returns and then
what it returns for the

11087
11:08:10.400 --> 11:08:13.400
documentation. Since this
doesn't have any parameters in

11088
11:08:13.400 --> 11:08:15.400
here, and doesn't return
anything, we can just leave it

11089
11:08:15.400 --> 11:08:18.400
like this. And great, we've just
revamped our contract here to

11090
11:08:18.400 --> 11:08:21.400
make it a little bit more nicely
formatted. Great job. Now, like

11091
11:08:21.400 --> 11:08:24.400
I said, we actually are going to
change the names of our state

11092
11:08:24.400 --> 11:08:26.400
variables, and we're going to
add some functions in here and a

11093
11:08:26.400 --> 11:08:29.400
little bit. So if we're
following with the GitHub repo,

11094
11:08:29.400 --> 11:08:31.400
the state of the contract right
now is going to look a little

11095
11:08:31.400 --> 11:08:34.400
bit different. But it'll make
sense why change this up in a

11096
11:08:34.400 --> 11:08:37.400
little bit.

11097
11:08:37.400 --> 11:08:40.400
Alright, so now that we've
cleaned this up, we've got to

11098
11:08:40.400 --> 11:08:43.400
deploy marks, deploy Funmi.
Let's go ahead and start writing

11099
11:08:43.400 --> 11:08:46.400
some tests. And after we write
these tests, we're actually

11100
11:08:46.400 --> 11:08:50.400
going to run that gas estimator
and using that gas estimator,

11101
11:08:50.400 --> 11:08:52.400
we're gonna go back, and we're
going to update this contract

11102
11:08:52.400 --> 11:08:56.400
one more time to make this even
cheaper to use and work with.

11103
11:08:56.400 --> 11:08:58.400
And remember, that's going to be
one of the advantages of writing

11104
11:08:58.400 --> 11:09:01.401
these tests is how we can
optimize our contracts to be

11105
11:09:01.401 --> 11:09:05.401
even faster, more gas efficient,
etc, we want to make sure that

11106
11:09:05.401 --> 11:09:08.401
we write really good tests, and
this is going to be one of our

11107
11:09:08.401 --> 11:09:13.401
first jumps into these more
professional test setups. So

11108
11:09:13.401 --> 11:09:14.401
we're going to jump into our
test folder, we're going to

11109
11:09:14.401 --> 11:09:19.401
delete this sample test.js. In
our last section, we went over a

11110
11:09:19.401 --> 11:09:22.401
really minimalistic test, which
is great. However, when we get

11111
11:09:22.401 --> 11:09:24.401
bigger and bigger projects,
we're going to want to start

11112
11:09:24.401 --> 11:09:28.401
testing more and more different
things, we're going to get more

11113
11:09:28.401 --> 11:09:31.401
and more into at least two
different types of testing. So

11114
11:09:31.401 --> 11:09:33.401
if we cd into our test folder,
we're going to make one

11115
11:09:33.401 --> 11:09:37.401
directory called staging. And
then we're going to make another

11116
11:09:37.401 --> 11:09:41.401
directory called unit. And now
if we look in our test folder,

11117
11:09:41.401 --> 11:09:44.401
we now have a staging folder,
and a unit test folder. Now

11118
11:09:44.401 --> 11:09:47.401
we're going to talk about two
different types of tests. The

11119
11:09:47.401 --> 11:09:49.401
first one is going to be
something called a unit test.

11120
11:09:49.401 --> 11:09:53.401
Now what is a unit test? Unit
testing is a software testing

11121
11:09:53.401 --> 11:09:56.401
method by which individual units
of source code are tested.

11122
11:09:56.401 --> 11:10:00.401
Basically, what we want to do is
in our contracts, we want to

11123
11:10:00.401 --> 11:10:03.401
test minimal portions of our
code to make sure that they work

11124
11:10:03.401 --> 11:10:07.401
correctly. Then once our small
pieces of the test work, we want

11125
11:10:07.401 --> 11:10:11.401
to do a staging test or maybe an
integration test. This might be

11126
11:10:11.401 --> 11:10:15.401
where we run our code on a test
net or some actual network. You

11127
11:10:15.401 --> 11:10:17.401
can think of a staging test,
it's kind of the last stop

11128
11:10:17.401 --> 11:10:21.401
before you deploy to a main net.
They're not always 100%

11129
11:10:21.401 --> 11:10:24.401
necessary, but they can be
really, really helpful.

11130
11:10:24.401 --> 11:10:28.401
Remember, we do want to be
conscientious of how much we use

11131
11:10:28.401 --> 11:10:32.401
our test nets, but we absolutely
would 100% want to make sure

11132
11:10:32.401 --> 11:10:35.401
that everything works locally
and that we unit test and we run

11133
11:10:35.401 --> 11:10:39.401
all of our code locally. Then we
can use staging tests on an

11134
11:10:39.401 --> 11:10:43.402
actual test net to make sure
that our code will work with

11135
11:10:43.402 --> 11:10:48.402
actual other contracts. Now unit
tests can be done with local

11136
11:10:48.402 --> 11:10:52.402
Hard Hat Network or a forked
Hard Hat Network, we'll talk

11137
11:10:52.402 --> 11:10:55.402
about this for tar Hat Network
very soon, right, now, let's

11138
11:10:55.402 --> 11:10:58.402
build these unit tests, these
unit tests are going to be

11139
11:10:58.402 --> 11:11:02.402
basically what we saw in our
last section. So let's go in and

11140
11:11:02.402 --> 11:11:04.402
let's jump in and write some of
these unit tests. So let's

11141
11:11:04.402 --> 11:11:10.402
create a new test, we'll call it
on me dot test dot j, s. And

11142
11:11:10.402 --> 11:11:13.402
we'll start making our tests in
here. Now, we did test

11143
11:11:13.402 --> 11:11:15.402
previously in our last section,
but our tests here are going to

11144
11:11:15.402 --> 11:11:18.402
look a little bit differently,
we're actually going to use

11145
11:11:18.402 --> 11:11:22.402
hardhat deploy, to automatically
set up our tests as if both of

11146
11:11:22.402 --> 11:11:24.402
these deployed functions had
been run. So let's go ahead and

11147
11:11:24.402 --> 11:11:27.402
get this started. So we're still
going to do that same setup that

11148
11:11:27.402 --> 11:11:32.402
we're gonna do describe, we're
gonna say fund me. And this is

11149
11:11:32.402 --> 11:11:41.402
going to have that async
function like so. And in here,

11150
11:11:41.402 --> 11:11:46.402
we're going to have a before
each, and we're going to have

11151
11:11:46.402 --> 11:11:49.402
some hits and some describes and
everything. Now since we want to

11152
11:11:49.402 --> 11:11:52.402
unit test this, we're gonna go a
little bit heavier on the test

11153
11:11:52.402 --> 11:11:54.402
here, and then with our last
project, but in the future,

11154
11:11:54.402 --> 11:11:57.402
we'll go a little bit lighter
with some of the tests. So let's

11155
11:11:57.402 --> 11:12:02.402
get started. If we run yarn
Hardhead test right now, we're

11156
11:12:02.402 --> 11:12:08.402
gonna get zero passing. Now, if
we run yarn hardhat coverage,

11157
11:12:08.402 --> 11:12:11.402
we're gonna get something that
looks like this, saying, Hey,

11158
11:12:11.402 --> 11:12:15.402
you're missing a lot of stuff.
So let's try to cover some more

11159
11:12:15.402 --> 11:12:18.402
lines with our tests. And one
way we can do that is actually

11160
11:12:18.402 --> 11:12:22.403
we can group our tests based off
of different functions. So let's

11161
11:12:22.403 --> 11:12:26.403
have our first set of tests be
around our constructor. To do

11162
11:12:26.403 --> 11:12:29.403
that inside of our first
describe, we can add another

11163
11:12:29.403 --> 11:12:34.403
describe, have this describe the
just the constructor, this

11164
11:12:34.403 --> 11:12:37.403
larger scope will be for the
entire Funmi contract. And

11165
11:12:37.403 --> 11:12:41.403
everything inside this one will
just be for the constructor. So

11166
11:12:41.403 --> 11:12:45.403
this will also be an async
function. And these tasks will

11167
11:12:45.403 --> 11:12:48.403
be just for the constructor. But
before we even work on this

11168
11:12:48.403 --> 11:12:51.403
describe, we probably want to
deploy our Funmi contract. So

11169
11:12:51.403 --> 11:12:54.403
let's learn how to do that. So
we'll do a before each, which

11170
11:12:54.403 --> 11:13:00.403
will be an async function. And
we're going to deploy our Funmi

11171
11:13:00.403 --> 11:13:06.403
contract using hard hat deploy.
Since we use hard hat deploy,

11172
11:13:06.403 --> 11:13:09.403
our Funmi contract will come
even with our mocks and

11173
11:13:09.403 --> 11:13:11.403
everything. So above the before
each,

11174
11:13:11.403 --> 11:13:18.403
let's do let me HDMI. And then
here, we're going to deploy

11175
11:13:18.403 --> 11:13:21.403
Funmi, where we're going to
deploy our Funmi contract is

11176
11:13:21.403 --> 11:13:24.403
first by pulling in our
deployments object from Harnett

11177
11:13:24.403 --> 11:13:29.403
deploy. So we'll do const
deployments equals require

11178
11:13:29.403 --> 11:13:33.403
hardhat. And this deployments
object has, has a function

11179
11:13:33.403 --> 11:13:38.403
called fixture with fixture does
is it allows us to basically run

11180
11:13:38.403 --> 11:13:41.403
our entire deploy folder with as
many tags as we want. You'll

11181
11:13:41.403 --> 11:13:46.403
notice I added this alt tag in
both of our scripts. This means

11182
11:13:46.403 --> 11:13:49.403
that in this deployment stuff
fixtures, it's gonna be a wait

11183
11:13:49.403 --> 11:13:53.403
deployment of fixtures. If I run
away deployments dot fixture,

11184
11:13:53.403 --> 11:13:56.403
I'll run through our deploy
scripts on our local network and

11185
11:13:56.403 --> 11:14:00.403
deploy all of the contracts that
we can use them in our scripts

11186
11:14:00.403 --> 11:14:03.404
and in our testing, and we can
deploy everything in that deploy

11187
11:14:03.404 --> 11:14:07.404
folder with just this one line.
isn't that helpful. Now, once

11188
11:14:07.404 --> 11:14:09.404
all of our contracts have been
deployed, we can start getting

11189
11:14:09.404 --> 11:14:15.404
them will say fund me equals
await ethers, and we'll pull an

11190
11:14:15.404 --> 11:14:20.404
ether some hard hat as well. dot
and this is where hard hat

11191
11:14:20.404 --> 11:14:25.404
deploy is helpful. Again, hard
to deploy rapt ether is with a

11192
11:14:25.404 --> 11:14:29.404
function called Get contract,
this get contract function is

11193
11:14:29.404 --> 11:14:32.404
going to get the most recent
deployment of whatever contract

11194
11:14:32.404 --> 11:14:36.404
we tell it. So we'll say get
contract of fun to me. So this

11195
11:14:36.404 --> 11:14:40.404
will give us the most recent Lee
deployed Funmi contract in just

11196
11:14:40.404 --> 11:14:45.404
this one line. And now Funmi
will be equal to this line here.

11197
11:14:45.404 --> 11:14:48.404
Now we're going to make a bunch
of transactions on our Funmi. To

11198
11:14:48.404 --> 11:14:52.404
test it. Of course, we can also
tell ethers which account we

11199
11:14:52.404 --> 11:14:57.404
want connected to fund me. So I
can say const deployer equals

11200
11:14:57.404 --> 11:15:03.404
goes away get named accounts,
exactly like we did in our

11201
11:15:03.404 --> 11:15:06.404
deploy scripts. And then we just
need to import it from our tap

11202
11:15:06.404 --> 11:15:10.404
in our deploy scripts we
imported get named accounts

11203
11:15:10.404 --> 11:15:14.404
inside of our input parameters
for our deploy function.

11204
11:15:14.404 --> 11:15:17.404
Remember getting named accounts
and deployments was abstracted

11205
11:15:17.404 --> 11:15:20.404
from if we look up here, from
the hard hat runtime

11206
11:15:20.404 --> 11:15:23.404
environment, and like I said,
the hard hat runtime environment

11207
11:15:23.404 --> 11:15:25.404
is basically the same thing as
hard hat. So we can just go

11208
11:15:25.404 --> 11:15:29.404
ahead and import it like this,
actually like this. Because we

11209
11:15:29.404 --> 11:15:32.404
actually need to abstract just
the deployer from getting named

11210
11:15:32.404 --> 11:15:36.404
accounts. And now what we can do
is we can connect our Deployer

11211
11:15:36.404 --> 11:15:39.404
to our Fund Me account. So
whenever we call a function with

11212
11:15:39.404 --> 11:15:43.405
fund me, it'll automatically be
from that the player account,

11213
11:15:43.405 --> 11:15:46.405
which is great. Another way you
can get different accounts

11214
11:15:46.405 --> 11:15:49.405
directly from your heart had
config. Is you could take const

11215
11:15:49.405 --> 11:15:55.405
accounts equals await ethers dot
get signers, ethers dot get

11216
11:15:55.405 --> 11:15:58.405
signers is going to return
whatever is in this account

11217
11:15:58.405 --> 11:16:01.405
section of your network. If
you're on your default network

11218
11:16:01.405 --> 11:16:04.405
hard hat, it's going to give you
a list of 10 fake accounts that

11219
11:16:04.405 --> 11:16:06.405
we can work with you then of
course, can do something like

11220
11:16:06.405 --> 11:16:12.405
const. Account one equals
accounts. More correctly would

11221
11:16:12.405 --> 11:16:16.405
be account zero equals account
zero and work like that. We'll

11222
11:16:16.405 --> 11:16:17.405
leave that comment that out,
just in case you need a

11223
11:16:17.405 --> 11:16:20.405
reference to it in the future.
Okay, great. So now we have our

11224
11:16:20.405 --> 11:16:23.405
Funmi contract. Let's go ahead
and write some tests for testing

11225
11:16:23.405 --> 11:16:25.405
the constructor. And we're
probably going to want to use

11226
11:16:25.405 --> 11:16:30.405
this deployer object down here.
So we'll do let deployer above.

11227
11:16:30.405 --> 11:16:33.405
And we'll do something a little
finicky here. But we'll say

11228
11:16:33.405 --> 11:16:39.405
deployer equals Wait, get named
accounts, dot Deployer. And

11229
11:16:39.405 --> 11:16:42.405
we'll just wrap this up so that
we can just grab this deployer

11230
11:16:42.405 --> 11:16:45.405
object and assign it to declare
like so. Now in here, we'll

11231
11:16:45.405 --> 11:16:50.405
create our first test, we'll say
it will say it sets the Agra

11232
11:16:50.405 --> 11:16:56.405
Gator addresses correctly. Comma
will have this be an async

11233
11:16:56.405 --> 11:17:03.405
function. And we'll say const
response equals await fund me

11234
11:17:03.405 --> 11:17:08.405
dot, let's get this price feed
here, fund me dot price feed.

11235
11:17:08.405 --> 11:17:10.405
And then we'll want to make sure
this price feed is going to be

11236
11:17:10.405 --> 11:17:14.405
the same as our Mk V three
aggregator since we're going to

11237
11:17:14.405 --> 11:17:18.405
be running these tests locally.
So we should get our mark three

11238
11:17:18.405 --> 11:17:25.406
V three aggregator up top. Let's
do let mock v3 aggregate store.

11239
11:17:25.406 --> 11:17:27.406
And we'll grab this address the
same way mockbee Three

11240
11:17:27.406 --> 11:17:34.406
aggregator equals await ethers
dot get contract mockbee Three

11241
11:17:34.406 --> 11:17:37.406
aggregator comma, we'll connect
this one to the deployer as

11242
11:17:37.406 --> 11:17:44.406
well. So we'll want to say cert
dot equals cert dot equal

11243
11:17:44.406 --> 11:17:49.406
response comma lock v3
aggregator dot address. And of

11244
11:17:50.406 --> 11:17:58.406
course we'll want to say const.
Assert equals require gy. Import

11245
11:17:58.406 --> 11:18:00.406
that from DJI. Okay, cool.

11246
11:18:00.406 --> 11:18:05.406
Now, let's go ahead and try this
out. Yarn hardhat. Test. Oops, I

11247
11:18:05.406 --> 11:18:10.406
spelled response wrong. Let's
try that again. Awesome. So this

11248
11:18:10.406 --> 11:18:14.406
means that we are indeed
assigning the price feed address

11249
11:18:14.406 --> 11:18:18.406
correctly to the Mach v3
aggregator. Okay, great.

11250
11:18:18.406 --> 11:18:21.406
Awesome. I think for now, that's
all we really want to do for our

11251
11:18:21.406 --> 11:18:24.406
constructor. Now these two are
kind of a nice to have, I showed

11252
11:18:24.406 --> 11:18:26.406
them more just to kind of demo
what they look like, we're going

11253
11:18:26.406 --> 11:18:29.406
to skip writing tests for them
for now. And we're actually

11254
11:18:29.406 --> 11:18:32.406
going to go ahead and delete
them directly from the contract.

11255
11:18:32.406 --> 11:18:34.406
If you want to go ahead and
write some tests for them and

11256
11:18:34.406 --> 11:18:36.406
leave them in your examples for
your learnings. You absolutely

11257
11:18:36.406 --> 11:18:39.406
can pause the video and write
some tests for it if you choose

11258
11:18:39.406 --> 11:18:42.406
so, but we're going to skip
them. Next though, we are going

11259
11:18:42.406 --> 11:18:46.406
to move on to fund and running
some tests for fun here. So

11260
11:18:46.406 --> 11:18:49.406
let's go ahead and write
describe fund. This will be an

11261
11:18:49.406 --> 11:18:55.406
async function. And in here,
we're going to do a number of

11262
11:18:55.406 --> 11:18:58.406
tests. So if we're going to go
line by line here, what's the

11263
11:18:58.406 --> 11:19:01.407
first thing that we should look
at? Well, we should look at this

11264
11:19:01.407 --> 11:19:04.407
require line we should write a
test to see if this contract

11265
11:19:04.407 --> 11:19:09.407
actually does fail? If not
enough, eath is sent. So let's

11266
11:19:09.407 --> 11:19:17.407
go ahead and we'll say it fails,
if you don't send enough eath

11267
11:19:17.407 --> 11:19:23.407
have this be an async function?
Now, how do we test to see if

11268
11:19:23.407 --> 11:19:26.407
something fails? Right now we've
done assert equals, but if

11269
11:19:26.407 --> 11:19:30.407
something fails, we might run
into an issue. So for example,

11270
11:19:30.407 --> 11:19:36.407
if I run await fund me dot fund,
but I don't pass any value to

11271
11:19:36.407 --> 11:19:39.407
this transaction. Let's see what
happens. I run yarn Hardhead

11272
11:19:39.407 --> 11:19:44.407
test. Well, our test is actually
going to break VM exception.

11273
11:19:44.407 --> 11:19:48.407
While processing transaction
reverted with reason string, you

11274
11:19:48.407 --> 11:19:51.407
need to spend more eath. So our
tests are going to break which

11275
11:19:51.407 --> 11:19:56.407
is good. We want this to break.
But we want to tell our test

11276
11:19:56.407 --> 11:20:00.407
that this is okay. Right? Want
to tell that this is okay. So

11277
11:20:00.407 --> 11:20:04.407
the way we can do this, and this
is where our waffle testing

11278
11:20:04.407 --> 11:20:07.407
comes into play. With waffle and
with testing, what we can

11279
11:20:07.407 --> 11:20:11.407
actually do is we can use the
expect keyword and expect

11280
11:20:11.407 --> 11:20:15.407
transactions to be reverted and
for transactions to fail. So

11281
11:20:15.407 --> 11:20:18.407
instead of using assert here,
we're actually going to run a

11282
11:20:18.407 --> 11:20:28.407
wait expect fund me dot fun 2.2
dot B, that reverted and we've

11283
11:20:28.407 --> 11:20:31.407
actually even be more specific
here by saying to be reverted

11284
11:20:31.407 --> 11:20:37.407
with and then the exact reverted
error, you need to spend more

11285
11:20:37.407 --> 11:20:42.408
eath. Now if we run our tests,
oops expect is not defined. So

11286
11:20:42.408 --> 11:20:47.408
we need to import that from
Chai. Which chai is being

11287
11:20:47.408 --> 11:20:52.408
overwritten by waffle, we see
that it does indeed Pass, which

11288
11:20:52.408 --> 11:20:57.408
is perfect. So now we have a way
to both assert things and expect

11289
11:20:57.408 --> 11:21:01.408
things to fail. Awesome, even
with the specific failure codes.

11290
11:21:01.408 --> 11:21:04.408
Perfect. Let's write some more
tests here. Well, we probably

11291
11:21:04.408 --> 11:21:09.408
want it to correctly update this
data structure. So we could say,

11292
11:21:09.408 --> 11:21:16.408
it updates the amount funded
data structure, it's going to be

11293
11:21:16.408 --> 11:21:20.408
an async function. In here,
we're going to need to call fund

11294
11:21:20.408 --> 11:21:25.408
v dot fund. However, we're going
to need to actually pass some

11295
11:21:25.408 --> 11:21:29.408
value with this transaction. And
for now, we'll just hard code

11296
11:21:29.408 --> 11:21:34.408
the value that we're going to
send, say const. Send value is

11297
11:21:34.408 --> 11:21:40.408
going to be
112345 678-910-1234 5678, which

11298
11:21:40.408 --> 11:21:43.408
is going to be one eath. Another
way we can write this though, is

11299
11:21:43.408 --> 11:21:46.408
we can use the ethers utility to
make this a little bit easier to

11300
11:21:46.408 --> 11:21:49.408
read. Because all those zeros
are kind of confusing, and it's

11301
11:21:49.408 --> 11:21:52.408
hard to tell at first glance
what this actually is. So we're

11302
11:21:52.408 --> 11:22:01.408
gonna actually use ethers dot
utils dot parse ether, one, this

11303
11:22:01.408 --> 11:22:05.408
parse ethers utility converts
this one into that one with 18

11304
11:22:05.408 --> 11:22:08.408
zeros, which makes life a lot
easier. If you go to the ethers

11305
11:22:08.408 --> 11:22:11.408
documentation, there's also a
parts units function where you

11306
11:22:11.408 --> 11:22:16.408
can actually convert any unit,
either ethers or Gwei. Or really

11307
11:22:16.408 --> 11:22:19.408
whatever you want to do, you
could convert any number to any

11308
11:22:19.408 --> 11:22:22.409
other Aetherium you type. So
this is the set value that we're

11309
11:22:22.409 --> 11:22:25.409
going to use for our fund. And,
and this is definitely going to

11310
11:22:25.409 --> 11:22:30.409
be more than our minimum USD of
50. So after we call this fun

11311
11:22:30.409 --> 11:22:34.409
function, we'll say const
response is going to be equal to

11312
11:22:34.409 --> 11:22:41.409
a weight, fund me dot address to
Mt funded address to Mt funded

11313
11:22:41.409 --> 11:22:45.409
for the deployer dot address.
Because remember, this is a

11314
11:22:45.409 --> 11:22:49.409
mapping of each address and how
much they've actually funded. So

11315
11:22:49.409 --> 11:22:52.409
if we use the deployer address,
it should give us the amount

11316
11:22:52.409 --> 11:22:57.409
that we actually sent. So now we
can run assert dot equal

11317
11:22:57.409 --> 11:23:00.409
response.to string, right,
because this response is going

11318
11:23:00.409 --> 11:23:04.409
to be the big number version of
how much has been funded by that

11319
11:23:04.409 --> 11:23:08.409
account. And that should be the
same as our send value.to

11320
11:23:08.409 --> 11:23:14.409
string. Since send value, our
one should be the exact same as

11321
11:23:14.409 --> 11:23:17.409
the amount that we funded, we
can run just this one test, or

11322
11:23:17.409 --> 11:23:23.409
running yarn, art hat, test,
dash dash grep. And we'll put

11323
11:23:23.409 --> 11:23:28.409
this in quotes allow funded for
this amount funded line. And it

11324
11:23:28.409 --> 11:23:32.409
looks like we ran into an issue
here, because we don't need to

11325
11:23:32.409 --> 11:23:36.409
do deployed at address, we can
just do deploy here. And great,

11326
11:23:36.409 --> 11:23:40.409
it looks like we are indeed
passing. Now if we even run yarn

11327
11:23:40.409 --> 11:23:44.409
Hardhead coverage will now see
we've got at least a little bit

11328
11:23:44.409 --> 11:23:47.409
more coverage here. It's still
not going to be great. But we

11329
11:23:47.409 --> 11:23:50.409
have much better coverage. We
have some statements, some

11330
11:23:50.409 --> 11:23:53.409
branches, and at least some
functions covered. So this is

11331
11:23:53.409 --> 11:23:56.409
awesome. Let's keep going. Are
we all done testing our fun

11332
11:23:56.409 --> 11:24:00.409
function? Well, probably not.
What else can we do with our fun

11333
11:24:00.409 --> 11:24:03.410
function? Well, we're also
adding funders to a funders

11334
11:24:03.410 --> 11:24:09.410
array. So let's go ahead and
test for that. So it adds funder

11335
11:24:09.410 --> 11:24:17.410
to array of funders has been an
async function. And we'll say

11336
11:24:17.410 --> 11:24:23.410
await fund mean that fund value
is going to be send value. We'll

11337
11:24:23.410 --> 11:24:30.410
say const response equals await
fund me dot calling the funders

11338
11:24:30.410 --> 11:24:38.410
array at index zero. So this
will be funder equals await fund

11339
11:24:38.410 --> 11:24:42.410
me dot funders zero. And then
we'll say assert dot equal

11340
11:24:42.410 --> 11:24:46.410
funder should be the same as the
Deployer. So let's go ahead and

11341
11:24:46.410 --> 11:24:49.410
run this test. We'll hit up a
couple times. And we'll change

11342
11:24:49.410 --> 11:24:56.410
the GREP to under to array so
that it looks for this line. And

11343
11:24:56.410 --> 11:25:00.410
perfect. It looks like that one
is also passing. Great. So the

11344
11:25:00.410 --> 11:25:03.410
money's coming through, the
minimum amount is coming through

11345
11:25:03.410 --> 11:25:07.410
and our data structures are
being updated. Awesome. Now we

11346
11:25:07.410 --> 11:25:10.410
could be a little bit more
verbose and do even more testing

11347
11:25:10.410 --> 11:25:12.410
with this fun function. But I
think for the most part, we've

11348
11:25:12.410 --> 11:25:16.410
got the gist, right. So now
let's go ahead and move on to

11349
11:25:16.410 --> 11:25:18.410
the withdrawal function. So
we're going to create a new

11350
11:25:18.410 --> 11:25:26.410
describe or withdraw. This is
going to be an async function.

11351
11:25:26.410 --> 11:25:29.410
And let's see what the
withdrawal function does. Only

11352
11:25:29.410 --> 11:25:32.410
the owner of the contract is
going to be able to get the

11353
11:25:32.410 --> 11:25:36.410
balance, get the money back. And
we're also going to reset all of

11354
11:25:36.410 --> 11:25:39.410
the amounts that each one of
these users is done. So let's go

11355
11:25:39.410 --> 11:25:42.411
ahead and do some withdrawing.
Now in order for us to test

11356
11:25:42.411 --> 11:25:47.411
withdraw, we probably first want
the contract to actually have

11357
11:25:47.411 --> 11:25:51.411
some money and so what we can do
actually is we can add another

11358
11:25:51.411 --> 11:25:55.411
before each in the describe to
automatically fund the contract

11359
11:25:55.411 --> 11:26:01.411
before we run any tests. So we
can say before each async

11360
11:26:01.411 --> 11:26:10.411
function. We can say await, fund
me dot fund. Value, send value.

11361
11:26:10.411 --> 11:26:14.411
Now for all of our tests in this
withdrawal scope, we're first

11362
11:26:14.411 --> 11:26:19.411
going to fund it with eath.
Let's say it can withdraw,

11363
11:26:19.411 --> 11:26:26.411
withdraw eath. From a single
founder, this would be an async

11364
11:26:26.411 --> 11:26:32.411
function. And this is going to
be a little bit longer test. So

11365
11:26:32.411 --> 11:26:39.411
I'm going to set it up to be an
arrange, act and assert test. So

11366
11:26:39.411 --> 11:26:42.411
arrange act assert is just sort
of a way to think about writing

11367
11:26:42.411 --> 11:26:45.411
tests, you want to arrange the
test, then you want to act. And

11368
11:26:45.411 --> 11:26:47.411
then you want to run the
asserts, and you'll see what I

11369
11:26:47.411 --> 11:26:50.411
mean in just a second. So we're
going to arrange this test,

11370
11:26:50.411 --> 11:26:53.411
we're going to set this test up,
we want to actually check that

11371
11:26:53.411 --> 11:26:56.411
we're correctly withdrawing the
ether from a single founder. So

11372
11:26:56.411 --> 11:26:59.411
first, we're going to get the
starting balance of the

11373
11:26:59.411 --> 11:27:01.411
fundraising contract and the
starting balance of the

11374
11:27:01.411 --> 11:27:09.411
Deployer. So we'll say const.
Starting under me, balance,

11375
11:27:09.411 --> 11:27:16.411
equals await, fund me dot
provider, dot get balance, fund

11376
11:27:16.411 --> 11:27:20.411
me dot address. So we're gonna
start with the balance of the

11377
11:27:20.411 --> 11:27:24.412
fund V contract after it's been
funded with some eath. And we're

11378
11:27:24.412 --> 11:27:30.412
also gonna get costs start
starting, deploy your balance

11379
11:27:30.412 --> 11:27:38.412
goes await, fund me dot
provider, dot get balance of

11380
11:27:38.412 --> 11:27:39.412
deployed employer.

11381
11:27:39.412 --> 11:27:42.412
So we're getting the starting
balance of the Funmi, we're

11382
11:27:42.412 --> 11:27:44.412
getting to the starting balance
of the employer so that we can

11383
11:27:44.412 --> 11:27:48.412
test later on how much these
numbers have changed based off

11384
11:27:48.412 --> 11:27:50.412
of what happens when we call the
withdrawal function. Now that

11385
11:27:50.412 --> 11:27:53.412
we've done a little bit of
setup, we can actually run this

11386
11:27:53.412 --> 11:27:56.412
withdrawal function, we can do
the act here. So we're gonna say

11387
11:27:56.412 --> 11:28:02.412
const, trans action response
equals await, fund me dot

11388
11:28:02.412 --> 11:28:11.412
withdraw. And then we can say
const, transaction receipt

11389
11:28:11.412 --> 11:28:19.412
equals await transaction
response. That Wait, one, and

11390
11:28:19.412 --> 11:28:22.412
now we should be able to check
to see that the entire fund

11391
11:28:22.412 --> 11:28:26.412
rebalance has been added to the
deployer balance. So now we can

11392
11:28:26.412 --> 11:28:33.412
say const ending fund me balance
equals a weight on me that

11393
11:28:33.412 --> 11:28:41.412
provider dot get balance of
Unreal dot address. Then we can

11394
11:28:41.412 --> 11:28:49.412
say const ending deployer
balance equals await, fund me

11395
11:28:49.412 --> 11:28:54.412
dot provider dot get balance

11396
11:28:54.412 --> 11:28:59.412
of Deployer. And now we can just
check to see if the numbers work

11397
11:28:59.412 --> 11:29:00.412
out here.

11398
11:29:00.412 --> 11:29:09.413
So we can say assert dot equal
ending fund me balance is going

11399
11:29:09.413 --> 11:29:13.413
to be zero, right, because we
just withdrew all of the money.

11400
11:29:13.413 --> 11:29:17.413
So ending funding balance should
be zero. And we'll say assert

11401
11:29:17.413 --> 11:29:25.413
dot equal starting fund me
balance plus starting deployer

11402
11:29:25.413 --> 11:29:30.413
balance. So the starting funds
the balance plus the starting

11403
11:29:30.413 --> 11:29:34.413
employer balance should equal
the ending employer balance.

11404
11:29:34.413 --> 11:29:37.413
Since we're grabbing whatever
the starting deployer balance

11405
11:29:37.413 --> 11:29:40.413
started with plus the starting
fund to be balanced, because we

11406
11:29:40.413 --> 11:29:43.413
just withdrew all of the
starting fund, we balance that

11407
11:29:43.413 --> 11:29:46.413
should equal the ending deployer
bots. Now a couple of notes

11408
11:29:46.413 --> 11:29:48.413
here, since starting Funmi
balance is calling from the

11409
11:29:48.413 --> 11:29:52.413
blockchain, it's going to be of
type a big number, we want to

11410
11:29:52.413 --> 11:29:56.413
use big number dot add actually,
instead of the plus sign here,

11411
11:29:56.413 --> 11:29:58.413
just because it'll it'll make
working with our big numbers a

11412
11:29:58.413 --> 11:30:02.413
little bit easier. So instead of
starting Funmi balance, plus

11413
11:30:02.413 --> 11:30:06.413
we're gonna be starting from the
balance dot add. Like that. And

11414
11:30:06.413 --> 11:30:09.413
that should be good. One other
thing about this, though, is

11415
11:30:09.413 --> 11:30:13.413
that when we called withdraw our
Deployer did what our Deployer

11416
11:30:13.413 --> 11:30:20.413
spent a little bit of gas. So
this actually isn't accurate. We

11417
11:30:20.413 --> 11:30:24.413
actually also need to calculate
in the gas cost, so we wouldn't

11418
11:30:24.413 --> 11:30:29.413
need to do dot add gas cost.
We'd also have to do.to string

11419
11:30:29.413 --> 11:30:34.413
because big numbers are objects
and so identities a little bit

11420
11:30:34.413 --> 11:30:37.413
weird. So to test to see if
they're equal, we'll just make

11421
11:30:37.413 --> 11:30:44.414
them both strings. Now we don't
have gas costs. So let's figure

11422
11:30:44.414 --> 11:30:48.414
out how to get the gas cost from
this transaction. So we can add

11423
11:30:48.414 --> 11:30:51.414
it to Are any deployer bounce,
so we can run this assertion

11424
11:30:51.414 --> 11:30:54.414
here. So what we can do is we
can actually find the gas costs

11425
11:30:54.414 --> 11:30:57.414
from our transaction receipt.
And I'm going to show you a

11426
11:30:57.414 --> 11:31:01.414
couple of phenomenal tricks you
can use with VS code. And if

11427
11:31:01.414 --> 11:31:04.414
using a different editor, then
don't worry too much about this.

11428
11:31:04.414 --> 11:31:07.414
What we can do in VS code
actually is create something

11429
11:31:07.414 --> 11:31:10.414
called breakpoints. unverified
breakpoint file is modified to

11430
11:31:11.414 --> 11:31:14.414
please restart the bug session,
or let's put it right here, put

11431
11:31:14.414 --> 11:31:17.414
it right in this line after
transaction receipt is created.

11432
11:31:17.414 --> 11:31:21.414
But before ending Funmi belts,
what this breakpoint does is it

11433
11:31:21.414 --> 11:31:25.414
stops the script at this line,
and allows us to drop into

11434
11:31:25.414 --> 11:31:30.414
something called a debug console
and see all the variables that

11435
11:31:30.414 --> 11:31:33.414
are happening. At this time, we
want to look at the transaction

11436
11:31:33.414 --> 11:31:37.414
receipt and see if the total gas
cost is in there. This is also

11437
11:31:37.414 --> 11:31:40.414
incredibly helpful for dropping
into tests and dropping into

11438
11:31:40.414 --> 11:31:44.414
scripts and seeing exactly
what's going on that's wrong. So

11439
11:31:44.414 --> 11:31:47.414
what we can do is we can move
down to this run into bug

11440
11:31:47.414 --> 11:31:50.414
section. And if it's not there,
you can hit additional views.

11441
11:31:50.414 --> 11:31:54.414
And we can click this JavaScript
Debug Terminal, which will

11442
11:31:54.414 --> 11:31:58.414
create a new terminal in our
terminal section. Now, what

11443
11:31:58.414 --> 11:32:03.414
happens here is if we run yarn,
hard hat test, it'll run our

11444
11:32:03.414 --> 11:32:06.414
testing and everything. But when
it hits this breakpoint, it'll

11445
11:32:06.414 --> 11:32:09.414
stop. Currently, there is no gas
cost. So we're just going to

11446
11:32:09.414 --> 11:32:11.414
delete this for now. So that we
compile and we work in

11447
11:32:11.414 --> 11:32:16.414
everything. But if we run yarn
Hardhead test, see, it's gonna

11448
11:32:17.414 --> 11:32:21.414
say debugger has been attached
to start running our tests. And

11449
11:32:21.414 --> 11:32:25.415
it's going to stop on this line
here. And if we look in this

11450
11:32:25.415 --> 11:32:29.415
variable section on the left
hand side, we can actually see a

11451
11:32:29.415 --> 11:32:34.415
ton of the variables that are in
here. And we can read a little

11452
11:32:34.415 --> 11:32:37.415
bit more about what's going on.
And if we go over to our debug

11453
11:32:37.415 --> 11:32:44.415
console, we can type in things
like transaction receipt, and we

11454
11:32:44.415 --> 11:32:47.415
can see a ton of information
about that transaction receipt

11455
11:32:47.415 --> 11:32:50.415
object, what we're looking for
is we're looking to see this

11456
11:32:50.415 --> 11:32:53.415
transaction receipt, which we
could look in the debug console

11457
11:32:53.415 --> 11:32:57.415
or over here, if there's
anything to do with gas in here.

11458
11:32:57.415 --> 11:33:01.415
And it looks like there is
there's a gas used big number.

11459
11:33:01.415 --> 11:33:05.415
And there's also an effective
gas price. So the amount of gas

11460
11:33:05.415 --> 11:33:09.415
used times the gas price is
going to give us all the money

11461
11:33:09.415 --> 11:33:13.415
that we paid for gas here. So
now that we've figured out

11462
11:33:13.415 --> 11:33:17.415
there's a gas used and effective
gas price variables in this

11463
11:33:17.415 --> 11:33:20.415
transaction receipt, which we
could have also found in the

11464
11:33:20.415 --> 11:33:23.415
documentation here. However,
sometimes it's even quicker just

11465
11:33:23.415 --> 11:33:27.415
to find it out yourself what we
can do, we can exit the debugger

11466
11:33:27.415 --> 11:33:32.415
by clicking this little thing
here. Go back to terminal will

11467
11:33:32.415 --> 11:33:35.415
trash can the JavaScript
debugger, we'll remove the

11468
11:33:35.415 --> 11:33:42.415
breakpoint. And we'll grab those
two variables we can pull them

11469
11:33:42.415 --> 11:33:48.415
right out of that transaction
receipt object by typing const.

11470
11:33:48.415 --> 11:33:55.415
Yes, used comma effective gas
price equals transaction

11471
11:33:55.415 --> 11:33:59.415
receipt. So again, with this
curly bracket syntax, we can use

11472
11:33:59.415 --> 11:34:03.416
this to pull out objects out of
another object. And now that we

11473
11:34:03.416 --> 11:34:08.416
have these two objects, we can
create a const gas cost or total

11474
11:34:08.416 --> 11:34:13.416
gas cost is going to be equal to
the gas used times the effective

11475
11:34:13.416 --> 11:34:17.416
gas price. Which again, since
these are both big numbers, we

11476
11:34:17.416 --> 11:34:23.416
can use a big number function
called dot mol to multiply them

11477
11:34:23.416 --> 11:34:27.416
together. Now that we have this
total gas cost, we can come down

11478
11:34:27.416 --> 11:34:32.416
and we can say the ending
deployer balance plus that gas

11479
11:34:32.416 --> 11:34:36.416
cost to string. Now the two of
these should be equivalent. I

11480
11:34:36.416 --> 11:34:39.416
know there's a lot of math that
we're doing in this section and

11481
11:34:39.416 --> 11:34:42.416
a lot of new things. So I want
to just quickly rego over what

11482
11:34:42.416 --> 11:34:46.416
we just learned. So first off,
the font of the contract comes

11483
11:34:46.416 --> 11:34:49.416
with a provider, we could have
also done ethers dot provider

11484
11:34:49.416 --> 11:34:52.416
dot get balance, but we're using
fun v dot provider because we're

11485
11:34:52.416 --> 11:34:55.416
using the provider of the Funmi
contract. It doesn't really

11486
11:34:55.416 --> 11:34:58.416
matter what we use here. We just
wanted to use this get balanced

11487
11:34:58.416 --> 11:35:02.416
function of the provider object
which gets us the balance of any

11488
11:35:02.416 --> 11:35:06.416
contract. We do the same thing
with starting deplore balance.

11489
11:35:06.416 --> 11:35:08.416
The reason that we needed the
starting balances is because we

11490
11:35:08.416 --> 11:35:11.416
wanted to compare it to the
ending balances to see if all

11491
11:35:11.416 --> 11:35:13.416
the money went to the right
places, we then call the

11492
11:35:13.416 --> 11:35:17.416
withdrawal function. And from
the transaction receipt, we

11493
11:35:17.416 --> 11:35:22.416
grabbed the gas used and the gas
price. If you want to debug your

11494
11:35:22.416 --> 11:35:26.416
JavaScript code, you can add a
breakpoint like so go to run

11495
11:35:26.416 --> 11:35:30.416
into bug, open your debug
JavaScript terminal, which is

11496
11:35:30.416 --> 11:35:34.416
different from your regular bash
terminals. And when you run

11497
11:35:35.416 --> 11:35:38.416
JavaScript commands in here,
they will stop where your

11498
11:35:38.416 --> 11:35:40.416
breakpoints are. Then you can
read the different variables and

11499
11:35:40.416 --> 11:35:43.417
see where different things are.
Using that knowledge. We pulled

11500
11:35:43.417 --> 11:35:46.417
out the gas use and effective
gas price from the transaction

11501
11:35:46.417 --> 11:35:49.417
receipt and used it to get the
total gas cost of this

11502
11:35:49.417 --> 11:35:52.417
transaction, we then got the
ending fund, we balanced the

11503
11:35:52.417 --> 11:35:55.417
ending deployer balance, and
used all those variables to make

11504
11:35:55.417 --> 11:35:59.417
sure all the money went to the
right places. And we, we can

11505
11:35:59.417 --> 11:36:05.417
check this by running yarn
Hardhead test dash dash grep

11506
11:36:05.417 --> 11:36:09.417
withdraw eath in quotes, since
there's a space here, and we can

11507
11:36:09.417 --> 11:36:14.417
see that our test does indeed
pass. Great job. If we didn't

11508
11:36:14.417 --> 11:36:19.417
add the gas cost here, and we
just did.to string, we would see

11509
11:36:19.417 --> 11:36:25.417
something like this, we would
see that the numbers are ever so

11510
11:36:25.417 --> 11:36:28.417
slightly off, because we're not
anticipating we're not

11511
11:36:28.417 --> 11:36:31.417
calculating the gas here. So we
always want to make sure we're

11512
11:36:31.417 --> 11:36:36.417
using the gas if we're doing
calculations like this. Now

11513
11:36:36.417 --> 11:36:39.417
another incredibly powerful
debugging tool that we're not

11514
11:36:39.417 --> 11:36:41.417
really going to go over here.
But it's important to know about

11515
11:36:41.417 --> 11:36:43.417
because it can be really helpful
is that you can actually use

11516
11:36:43.417 --> 11:36:48.417
console dot log in your solidity
with hard hat. If you're inside

11517
11:36:48.417 --> 11:36:51.417
of a heart hat project, you just
import hard hat slash console

11518
11:36:51.417 --> 11:36:56.417
dot soul. And then right in your
solidity, you can do console dot

11519
11:36:56.417 --> 11:36:59.417
log, and then type pretty much
whatever you want. When you

11520
11:36:59.417 --> 11:37:02.417
execute these functions, similar
to how we do a console dot log

11521
11:37:02.417 --> 11:37:05.417
in JavaScript, those will
actually console dot log out to

11522
11:37:05.417 --> 11:37:09.417
your terminal. Here's an example
of if you run yarn, hard hat

11523
11:37:09.417 --> 11:37:12.417
test and you have those console
dot logs, you'll see stuff like

11524
11:37:12.417 --> 11:37:16.417
this get printed out. So in
addition to the Visual Studio

11525
11:37:16.417 --> 11:37:19.417
Code debugger, importing hard
hat slash console dot Sol, and

11526
11:37:19.417 --> 11:37:22.418
using console dot logs in your
solidity can also be an

11527
11:37:23.418 --> 11:37:25.418
effective debugging strategy.
Feel free to give this video a

11528
11:37:25.418 --> 11:37:29.418
pause, implement this in some of
our contracts and try it out in

11529
11:37:29.418 --> 11:37:35.418
our tests. So we tested that
withdrawing eath when there's a

11530
11:37:35.418 --> 11:37:38.418
single funder works perfectly,
let's test withdrawing eath if

11531
11:37:38.418 --> 11:37:44.418
there are multiple funders, so
we'll do it, let's say allows us

11532
11:37:44.418 --> 11:37:51.418
to withdraw with multiple
funders. Why would this be an

11533
11:37:51.418 --> 11:37:59.418
async function. And let's do
this await Funmi not fun, but

11534
11:37:59.418 --> 11:38:02.418
with a number of different
accounts. So we can create a

11535
11:38:02.418 --> 11:38:04.418
whole bunch of different
accounts of course, by saying

11536
11:38:04.418 --> 11:38:12.418
const accounts equals await
ethers dot get signers. And we

11537
11:38:12.418 --> 11:38:15.418
can loop through these accounts
and have each one of these

11538
11:38:15.418 --> 11:38:18.418
accounts call the fund function.
And we're going to do this with

11539
11:38:18.418 --> 11:38:25.418
a for loop. So we're going to
say for let i equals we'll start

11540
11:38:25.418 --> 11:38:28.418
with the first index of the
accounts because the zero with

11541
11:38:28.418 --> 11:38:31.418
index is going to be the
Deployer. So we'll say let i

11542
11:38:31.418 --> 11:38:36.418
equals one is going to be less
than let's say six. And we'll do

11543
11:38:36.418 --> 11:38:43.418
i plus plus. And in here, we'll
say const. And me contract Funmi

11544
11:38:43.418 --> 11:38:51.418
connected contract equals await.
And me dot connect two accounts,

11545
11:38:51.418 --> 11:38:55.418
I, so we need to call this
connect function because right

11546
11:38:55.418 --> 11:38:59.418
now if we scroll up back to the
top, our Funmi contract is

11547
11:38:59.418 --> 11:39:03.419
connected to our Deployer
account. And anytime we call a

11548
11:39:03.419 --> 11:39:08.419
transaction with Funmi, the
deployer is the account that is

11549
11:39:08.419 --> 11:39:11.419
calling that transaction, we
need to create new objects to

11550
11:39:11.419 --> 11:39:13.419
connect to all of these
different accounts. So we're

11551
11:39:13.419 --> 11:39:16.419
gonna say fund me connected
contract, which is now connected

11552
11:39:16.419 --> 11:39:20.419
to one of these different
accounts dot fund. And this is

11553
11:39:20.419 --> 11:39:25.419
where we'll do value, send
value. Or excuse me, we'll do

11554
11:39:25.419 --> 11:39:29.419
await. Great. So this is going
to be our our range section. And

11555
11:39:29.419 --> 11:39:33.419
then same as we did above, we
need to grab those starting

11556
11:39:33.419 --> 11:39:36.419
balances. So we can just copy
that, those two lines and paste

11557
11:39:36.419 --> 11:39:39.419
that down here. Now we're going
to move into act, I'm going to

11558
11:39:39.419 --> 11:39:43.419
call that withdrawal function
again. So let's say const,

11559
11:39:43.419 --> 11:39:50.419
transaction action response
equals await and MI dot

11560
11:39:50.419 --> 11:39:54.419
withdraw. And we're going to do
the exact same thing as we did

11561
11:39:54.419 --> 11:39:58.419
above, getting the transaction
receipt and the gas costs so we

11562
11:39:58.419 --> 11:40:01.419
can get everything correct. Once
we've done the act, we move on

11563
11:40:01.419 --> 11:40:05.419
into assert. And we're going to
do some very similar things to

11564
11:40:05.419 --> 11:40:08.419
what we did above, like this,
for example, this whole first

11565
11:40:08.419 --> 11:40:12.419
part is going to be exactly the
same. We also want to make sure

11566
11:40:12.419 --> 11:40:18.419
the funders are reset properly.
So we'll make sure that this

11567
11:40:18.419 --> 11:40:22.419
funders array is reset properly.
So to do that, we can actually

11568
11:40:22.419 --> 11:40:25.419
just check to see that if
looking at the zero with

11569
11:40:25.419 --> 11:40:30.419
position throws an error so we
can run a wait expect fund me

11570
11:40:30.419 --> 11:40:36.419
dot get on me dot funder on me
dot funders of zero. This should

11571
11:40:36.419 --> 11:40:41.419
revert so we'll say await expect
Funmi dot funders dot two dot b

11572
11:40:41.419 --> 11:40:47.420
dot reverted and then we want to
loop through all these accounts

11573
11:40:47.420 --> 11:40:50.420
and make sure that it makes sure
or that in our mapping here, all

11574
11:40:50.420 --> 11:40:58.420
their amounts are zero. So we'll
say, for I equals one is less

11575
11:40:58.420 --> 11:41:01.420
than six,

11576
11:41:01.420 --> 11:41:12.420
i plus plus, we'll say assert
dot equal. Wait, fund me dot

11577
11:41:12.420 --> 11:41:21.420
address to amount funded, of the
accounts of I got address should

11578
11:41:21.420 --> 11:41:26.420
be zero. So we're making sure
that all of these mappings are

11579
11:41:26.420 --> 11:41:29.420
correctly updated to zero. So
let's go and test this. So we're

11580
11:41:29.420 --> 11:41:32.420
withdrawing with multiple
founders, we're going to go back

11581
11:41:32.420 --> 11:41:36.420
to our terminal, we're going to
hit up, we're going to change

11582
11:41:36.420 --> 11:41:42.420
this GREP or this one. We'll see
if this passes. And it does

11583
11:41:42.420 --> 11:41:45.420
indeed, so this means that our
withdraw function works really

11584
11:41:45.420 --> 11:41:49.420
well even when there's multiple
funders and we can be happy and

11585
11:41:49.420 --> 11:41:52.420
go to sleep knowing that. Now
the other thing we absolutely

11586
11:41:52.420 --> 11:41:55.420
want 100% want to test is that
our only owner modifier is

11587
11:41:55.420 --> 11:41:59.420
working, we want only the owner
to be able to withdraw the funds

11588
11:41:59.420 --> 11:42:04.420
from here. So we'll create a new
session, we'll say it only

11589
11:42:04.420 --> 11:42:10.420
allows the owner to withdraw
only allows you to withdraw.

11590
11:42:10.420 --> 11:42:17.420
This will be an async function.
And in here, we'll say const.

11591
11:42:17.420 --> 11:42:20.420
Accounts equals ethers dot get
signers again. And we'll say

11592
11:42:20.420 --> 11:42:27.421
const attacker equals accounts
of one. So we'll say the first

11593
11:42:27.421 --> 11:42:30.421
account will be some random
attacker will connect this

11594
11:42:30.421 --> 11:42:35.421
attacker to a new contract,
we'll say const attacker

11595
11:42:35.421 --> 11:42:44.421
connected contract equals await
on DB dot Connect. Attacker dot

11596
11:42:44.421 --> 11:42:49.421
address, excuse me a dot connect
attacker. Since we're not just

11597
11:42:49.421 --> 11:42:52.421
connecting the address, we're
connecting the account which

11598
11:42:52.421 --> 11:42:59.421
attacker is an account object.
And then we'll do a wait expect

11599
11:42:59.421 --> 11:43:11.421
attacker connected contract dot
withdraw dot two dot b dot

11600
11:43:11.421 --> 11:43:15.421
reverted, they should not be
able to withdraw. So let's go

11601
11:43:15.421 --> 11:43:19.421
ahead, we can even just copy
this whole thing if we want to

11602
11:43:19.421 --> 11:43:24.421
hit up, we'll delete this
section here. We'll paste that

11603
11:43:24.421 --> 11:43:29.421
in. And boom. This means that
when some other account tries to

11604
11:43:29.421 --> 11:43:32.421
call withdraw, automatically
gets reverted, which is what we

11605
11:43:32.421 --> 11:43:36.421
want. Now we can be more
explicit to make sure that the

11606
11:43:36.421 --> 11:43:39.421
correct error code is being
thrown, not just that it's

11607
11:43:39.421 --> 11:43:43.421
reverted. Right, it can be very
reverted because they sent ether

11608
11:43:43.421 --> 11:43:45.421
did it they did something weird,
we want to make sure it's

11609
11:43:45.421 --> 11:43:48.421
reverted with our specific error
code. So right now we have this

11610
11:43:48.421 --> 11:43:52.421
not owner error code. But it's
actually a best practice to put

11611
11:43:52.421 --> 11:43:57.421
the contract name to underscores
and then your custom error. This

11612
11:43:57.421 --> 11:44:00.421
makes it a lot easier in the
future when you have a ton of

11613
11:44:00.421 --> 11:44:02.422
different contracts, and you're
not sure where an error is

11614
11:44:02.422 --> 11:44:05.422
coming from. So we're going to
just update this really quickly

11615
11:44:05.422 --> 11:44:09.422
to be fund me underscore
underscore, not owner, now we

11616
11:44:09.422 --> 11:44:12.422
can do is now that we have this
custom error, we can say

11617
11:44:12.422 --> 11:44:17.422
withdraw that to be reverted
with, then we can add our custom

11618
11:44:17.422 --> 11:44:22.422
error in here. Now, if we rerun
our test, with only allows the

11619
11:44:22.422 --> 11:44:26.422
owner to withdraw, oops, we need
to do a wait here. My mistake,

11620
11:44:26.422 --> 11:44:30.422
wait a Thursday, get signers.
And now let's try this again.

11621
11:44:30.422 --> 11:44:35.422
And we are indeed passing
Perfect.

11622
11:44:35.422 --> 11:44:38.422
Okay, great. We have some basic
unit tests here. And we're going

11623
11:44:38.422 --> 11:44:41.422
to write some staging tests
pretty soon. But before we

11624
11:44:41.422 --> 11:44:46.422
actually do that, let's go ahead
and add the gas estimator. And

11625
11:44:46.422 --> 11:44:49.422
we'll see how much gas these
contracts in these functions are

11626
11:44:49.422 --> 11:44:52.422
taking. It looks like the
Hardhead gas reporter is already

11627
11:44:52.422 --> 11:44:57.422
here. So let's scroll down.
We'll do gas reporter true. And

11628
11:44:57.422 --> 11:45:01.422
we won't do coin market cap
here. And we'll just look purely

11629
11:45:01.422 --> 11:45:03.422
at the GUI. So you can just
comment it out like that. Now

11630
11:45:03.422 --> 11:45:09.422
rerun all of our tests. So we'll
say yarn, our test. And in doing

11631
11:45:09.422 --> 11:45:13.422
so we're gonna get that that gas
output in that gas report dash

11632
11:45:13.422 --> 11:45:17.422
text here. So looks like all of
our tests are passing, which is

11633
11:45:17.422 --> 11:45:21.422
perfect. Now we can look into
our gas report and see what's

11634
11:45:21.422 --> 11:45:25.422
going on here. i Well, it looks
like the fundraising function is

11635
11:45:25.422 --> 11:45:28.422
taking a decent chunk of gas,
the withdrawal function, take it

11636
11:45:28.422 --> 11:45:32.422
some guests to we'd see the min,
the max and the average. Of

11637
11:45:32.422 --> 11:45:35.422
course, we can see how much each
one of these contracts cost to

11638
11:45:35.422 --> 11:45:38.422
actually output. We don't really
care about the MOQ aggregator of

11639
11:45:38.422 --> 11:45:40.422
course, because we're never
actually going to use that.

11640
11:45:40.422 --> 11:45:42.423
Let's say we look at the average
gas for these and we go hmm,

11641
11:45:42.423 --> 11:45:45.423
this looks like it's actually a
lot more than what we originally

11642
11:45:45.423 --> 11:45:48.423
expected. Is there a way for us
to make this a little bit cheap.

11643
11:45:48.423 --> 11:45:51.423
If we go back to our funding
contract, we look at our

11644
11:45:51.423 --> 11:45:55.423
withdrawal function. And we
noticed something, oh, there is

11645
11:45:55.423 --> 11:45:58.423
actually a way to make this a
lot cheaper. And it has to do

11646
11:45:58.423 --> 11:46:02.423
with something called storage
variables, or these global

11647
11:46:02.423 --> 11:46:05.423
variables that we've been
working with this whole time.

11648
11:46:05.423 --> 11:46:07.423
Let me let me paint you a little
picture here, we're gonna look

11649
11:46:07.423 --> 11:46:10.423
at one of the first gas
optimization techniques you can

11650
11:46:10.423 --> 11:46:14.423
take to drop these down. And it
has to do with an R Funmi.

11651
11:46:14.423 --> 11:46:19.423
Contract these state variables
and how they're actually stored

11652
11:46:19.423 --> 11:46:22.423
and how this contract actually
keeps track of all this stuff,

11653
11:46:22.423 --> 11:46:25.423
this section is going to be a
little bit more advanced. So

11654
11:46:25.423 --> 11:46:27.423
we'll have a note here saying
that this is an advanced

11655
11:46:27.423 --> 11:46:30.423
section, if you want to skip
over it, you can, because now

11656
11:46:30.423 --> 11:46:32.423
we're getting into gas
optimizations here, this

11657
11:46:32.423 --> 11:46:35.423
information still is really good
to know. So if you want to skip

11658
11:46:35.423 --> 11:46:38.423
it for now, and then come back
later, you absolutely can. But

11659
11:46:38.423 --> 11:46:43.423
let's talk about what happens
when we actually save or store

11660
11:46:43.423 --> 11:46:47.423
these global variables. Okay,
these storage variables. Now,

11661
11:46:47.423 --> 11:46:50.423
everything I'm about to go
through is in the documentation.

11662
11:46:50.423 --> 11:46:52.423
And there is a link to this, of
course, in the GitHub repo

11663
11:46:52.423 --> 11:46:55.423
associated with this course,
whenever we have one of these

11664
11:46:55.423 --> 11:46:58.423
global variables, or these
variables that stay permanently,

11665
11:46:58.423 --> 11:47:01.423
they're stuck in something
called storage, you can think of

11666
11:47:01.423 --> 11:47:06.423
storage as a big giant array, or
a giant list of all the

11667
11:47:06.423 --> 11:47:08.423
variables that we actually
create. So when we say we have

11668
11:47:08.423 --> 11:47:11.423
some contract called Son of
storage, and we have a variable

11669
11:47:11.423 --> 11:47:14.423
called favorite number, we're
basically saying we want this

11670
11:47:14.423 --> 11:47:17.423
favorite number variable to
persist, right, we saw in a lot

11671
11:47:17.423 --> 11:47:20.423
of our examples, we had a
favorite number variable that we

11672
11:47:20.423 --> 11:47:22.424
can always call to see what this
contracts favorite number was,

11673
11:47:23.424 --> 11:47:27.424
well, the way it persists, is it
gets stored in this place called

11674
11:47:27.424 --> 11:47:30.424
storage. A storage box is this
giant list associated with this

11675
11:47:30.424 --> 11:47:33.424
contract where every single
variable and every single value

11676
11:47:33.424 --> 11:47:38.424
in the storage section is
slotted into a 32 byte long slot

11677
11:47:38.424 --> 11:47:43.424
in this storage array. So for
example, the number 25 in its

11678
11:47:43.424 --> 11:47:48.424
bytes implementation is 000 with
a ton of zeros 19. This is the

11679
11:47:48.424 --> 11:47:51.424
hex version of the yuan 256.
This is why we do so much hex

11680
11:47:51.424 --> 11:47:56.424
translation, the bytes
implementation of a yuan 256.

11681
11:47:56.424 --> 11:47:59.424
And each store saw increments
just like an array starting from

11682
11:47:59.424 --> 11:48:04.424
zero. So for example, our next
global variable or next storage

11683
11:48:04.424 --> 11:48:09.424
variable just gets slotted at
the next slot that's available.

11684
11:48:09.424 --> 11:48:12.424
So bullions, for example, get
transformed from their bull

11685
11:48:12.424 --> 11:48:16.424
version two, their hex and we
modified our some bool variable

11686
11:48:16.424 --> 11:48:22.424
to be true and X edition of the
true Boolean 0x 001. Every time

11687
11:48:22.424 --> 11:48:25.424
you save an additional global
variable, or more correctly, one

11688
11:48:25.424 --> 11:48:29.424
of these storage variables, it
takes up an additional storage

11689
11:48:29.424 --> 11:48:32.424
slot. And what about variables
that are dynamic in length, or

11690
11:48:32.424 --> 11:48:35.424
that can change length? What
about something that's dynamic?

11691
11:48:35.424 --> 11:48:39.424
Well, for dynamic values, like a
dynamic array, or a mapping

11692
11:48:39.424 --> 11:48:42.424
elements inside the array or
inside the mapping are actually

11693
11:48:42.424 --> 11:48:45.424
stored using some type of
hashing function. And you can

11694
11:48:45.424 --> 11:48:48.424
see those specific functions in
the documentation, the object

11695
11:48:48.424 --> 11:48:52.424
itself does take up a storage
slot, but it's not going to be

11696
11:48:52.424 --> 11:48:55.424
the entire array. For example,
my array variable here at

11697
11:48:55.424 --> 11:49:00.424
storage, slot two doesn't have
the entire array in storage slot

11698
11:49:00.424 --> 11:49:04.425
two, what has actually is just
the array length, the length of

11699
11:49:04.425 --> 11:49:07.425
the array is stored at storage
slot two. But for example, if we

11700
11:49:07.425 --> 11:49:12.425
do my array dot push 222, we do
some hashing function, which

11701
11:49:12.425 --> 11:49:15.425
again, you can see in the
documentation what that is, and

11702
11:49:15.425 --> 11:49:20.425
we'll store the number 222. At
that location in storage, the

11703
11:49:20.425 --> 11:49:26.425
hex of 222 is 0x 0000 D, so it
gets stored in this crazy spot.

11704
11:49:26.425 --> 11:49:29.425
And this is good, this is
intentional, because 32 Bytes

11705
11:49:29.425 --> 11:49:32.425
may not be nearly big enough to
store my array if our array gets

11706
11:49:32.425 --> 11:49:35.425
massive. And it wouldn't make
sense for to put the elements

11707
11:49:35.425 --> 11:49:38.425
inside the array at subsequent
numbers because again, the size

11708
11:49:38.425 --> 11:49:40.425
of the array can change and
you're never going to be sure

11709
11:49:40.425 --> 11:49:44.425
how many subsequence that you
need. So for my array, it does

11710
11:49:44.425 --> 11:49:47.425
have a storage slot for the
length for mappings. It does

11711
11:49:47.425 --> 11:49:50.425
have a storage spot as well
similar to array, but it's just

11712
11:49:50.425 --> 11:49:54.425
blank. But it's blank
intentionally so that solidity

11713
11:49:54.425 --> 11:49:57.425
knows, okay, there is a mapping
here, and it needs a storage

11714
11:49:57.425 --> 11:50:00.425
slot for attaching functional
work correctly. Now

11715
11:50:00.425 --> 11:50:03.425
interestingly, constant
variables and immutable

11716
11:50:03.425 --> 11:50:07.425
variables do not take up spots
in storage. The reason for this

11717
11:50:07.425 --> 11:50:10.425
is because constant variables
are actually part of the

11718
11:50:10.425 --> 11:50:14.425
contracts byte code itself,
which sounds a little bit weird.

11719
11:50:14.425 --> 11:50:17.425
But you can imagine what
solidity does is anytime it sees

11720
11:50:17.425 --> 11:50:21.425
constant variables name is it
just automatically swaps it out

11721
11:50:21.425 --> 11:50:24.425
with whatever number it actually
is. So you can kind of think of

11722
11:50:24.425 --> 11:50:28.425
not in storage is just a pointer
to 123 and it doesn't take up a

11723
11:50:28.425 --> 11:50:32.425
storage slot. Well when we have
variables inside of a function,

11724
11:50:32.425 --> 11:50:36.425
those variables only exist for
the duration of the function.

11725
11:50:36.425 --> 11:50:39.425
They don't stay inside the
contract. They don't persist

11726
11:50:39.425 --> 11:50:42.425
they're not permanent. So
variables inside these functions

11727
11:50:42.425 --> 11:50:46.426
like new var and other var do
not get added to storage. They

11728
11:50:46.426 --> 11:50:49.426
get added in their own memory
data structure. Which gets

11729
11:50:49.426 --> 11:50:52.426
deleted after the function has
finished running. Now you might

11730
11:50:52.426 --> 11:50:55.426
be asking, Okay, well, why do we
need this memory keyword,

11731
11:50:55.426 --> 11:50:59.426
especially when it comes to
strings, we saw before that we

11732
11:50:59.426 --> 11:51:02.426
had to say String memory. The
reason we need it for strings is

11733
11:51:02.426 --> 11:51:06.426
because strings are technically
this dynamically sized array.

11734
11:51:06.426 --> 11:51:08.426
And we need to tell solidity,
hey, we're going to do this on

11735
11:51:08.426 --> 11:51:11.426
the storage location, or we're
going to do it into the memory

11736
11:51:11.426 --> 11:51:14.426
location where we can just wipe
it. arrays and mappings can take

11737
11:51:14.426 --> 11:51:18.426
up a lot more space. So slowly,
just wants to make sure Okay,

11738
11:51:18.426 --> 11:51:21.426
where are we working with this
is it storage is a memory, you

11739
11:51:21.426 --> 11:51:24.426
have to tell me, I need to know
if I need to allocate space for

11740
11:51:24.426 --> 11:51:27.426
it in our storage data
structure. And again, everything

11741
11:51:27.426 --> 11:51:29.426
here you can read in the
solidity documentation. Now, in

11742
11:51:29.426 --> 11:51:33.426
the GitHub repo associated with
this course, if you go to

11743
11:51:33.426 --> 11:51:37.426
contracts, we've actually got an
example contract section called

11744
11:51:37.426 --> 11:51:39.426
Fun with storage, where you can
play with and look at a lot of

11745
11:51:39.426 --> 11:51:44.426
this stuff. And we even wrote a
little script called deploy

11746
11:51:44.426 --> 11:51:48.426
storage fun, where it'll print
out the storage location of some

11747
11:51:48.426 --> 11:51:50.426
of the different variables, feel
free to give it a run, if you

11748
11:51:50.426 --> 11:51:53.426
want to try a challenge anybody
to write some functions that

11749
11:51:53.426 --> 11:51:56.426
find the storage slots of the
elements of the arrays, and the

11750
11:51:56.426 --> 11:52:00.426
mappings, and then find the data
inside of those as well. We use

11751
11:52:00.426 --> 11:52:03.426
a function here called Get
storage app, which allows us to

11752
11:52:03.426 --> 11:52:06.426
get the storage at any one of
these slots. And this is to

11753
11:52:06.426 --> 11:52:10.426
reinforce that even if you have
a function as private or

11754
11:52:10.426 --> 11:52:14.426
internal. Anybody can still read
it. Anybody can read anything

11755
11:52:14.426 --> 11:52:18.426
off the blockchain. And you can
test it exactly what this if you

11756
11:52:18.426 --> 11:52:21.426
go ahead and get clone that or
copy paste the code yourself.

11757
11:52:21.426 --> 11:52:27.427
You can then run yarn part at
deploy dash test tags, storage.

11758
11:52:27.427 --> 11:52:30.427
And you'll run the deploy script
for that storage.

11759
11:52:30.427 --> 11:52:33.427
And you'll see printing out the
location of storage in each

11760
11:52:33.427 --> 11:52:40.427
storage slot with a fun contract
that we made as an example. And

11761
11:52:40.427 --> 11:52:42.427
you might of course be asking,
Okay, Patrick, why are you

11762
11:52:42.427 --> 11:52:45.427
telling me all this? We're just
trying to get this gas price

11763
11:52:45.427 --> 11:52:48.427
down? Why are you telling me all
about this storage thing? Well,

11764
11:52:48.427 --> 11:52:51.427
the reason I'm telling you all
about the storage thing. Anytime

11765
11:52:51.427 --> 11:52:55.427
you read or you write to and
from storage, you spend a ton of

11766
11:52:55.427 --> 11:52:58.427
gas. Remember I said when we
compile our code, we compile it

11767
11:52:58.427 --> 11:53:01.427
down to some crazy weird
bytecode. Well, let me show you

11768
11:53:01.427 --> 11:53:05.427
on remix what this looks like.
We go to compliation details, we

11769
11:53:05.427 --> 11:53:09.427
can go to bytecode. And we see
this weird hex object zero,

11770
11:53:09.427 --> 11:53:12.427
blah, blah, blah. But we also
see these things called op

11771
11:53:12.427 --> 11:53:16.427
codes. Now, this bytecode here
represents these op codes. Each

11772
11:53:16.427 --> 11:53:20.427
one of these op codes represents
a small piece of everything in

11773
11:53:20.427 --> 11:53:23.427
this bytecode. And in fact, in
our heart hat, we can go to

11774
11:53:23.427 --> 11:53:28.427
artifacts, build info, and we
can see, we can see these op

11775
11:53:28.427 --> 11:53:32.427
codes in the build info, we can
do a command F or Control F for

11776
11:53:32.427 --> 11:53:37.427
opcodes. We can see op codes for
different contracts. These op

11777
11:53:37.427 --> 11:53:40.427
codes represent what the machine
code is doing. And they

11778
11:53:40.427 --> 11:53:44.427
represent how much computational
work it takes to actually run

11779
11:53:44.427 --> 11:53:47.427
our code and do stuff with our
code. The way that gas is

11780
11:53:47.427 --> 11:53:50.427
actually calculated is by these
opcodes. There are a couple of

11781
11:53:50.427 --> 11:53:53.427
lists here. But here's one that
I'm going to use this EVM

11782
11:53:53.427 --> 11:53:55.427
opcodes. And again, there's a
link to this in the GitHub repo

11783
11:53:56.427 --> 11:53:59.427
associated with this lesson.
Well, if we scroll down, we can

11784
11:53:59.427 --> 11:54:03.428
see exactly how much it costs
for each one of these op codes.

11785
11:54:03.428 --> 11:54:08.428
So for example, anytime we add,
it costs three gas, anytime we

11786
11:54:08.428 --> 11:54:13.428
multiply, that's five gas,
subtracting three gas, we have

11787
11:54:13.428 --> 11:54:17.428
all of these op codes that cost
different amounts of gas in in

11788
11:54:17.428 --> 11:54:21.428
our functions, here's kind of a
sample contract. If we're doing

11789
11:54:21.428 --> 11:54:25.428
adding, anytime we add it's
going to cost three gas. Anytime

11790
11:54:25.428 --> 11:54:28.428
we save to memory, it's going to
cost gas from some other

11791
11:54:29.428 --> 11:54:33.428
opcodes. These op codes combined
show us how much gas we actually

11792
11:54:33.428 --> 11:54:36.428
use. Now, let's look at a lot of
these op codes and how much they

11793
11:54:36.428 --> 11:54:43.428
cost three 510, three, three,
balance is 700. So getting the

11794
11:54:43.428 --> 11:54:47.428
balance is is a ton of gas.
Let's keep going. Getting the

11795
11:54:47.428 --> 11:54:50.428
sides of an Accounts code is a
lot of gas copying and accounts

11796
11:54:50.428 --> 11:54:56.428
code into memory. But oh my
goodness, what is this save word

11797
11:54:56.428 --> 11:55:03.428
to storage costs a ton of gas
that is 20,000 gas and s load

11798
11:55:03.428 --> 11:55:08.428
load word from storage cost 800
gas. These are two of the most

11799
11:55:08.428 --> 11:55:12.428
important opcodes s load and s
store which stands for storage

11800
11:55:12.428 --> 11:55:17.428
load and storage store. Anytime
one of these op codes fires,

11801
11:55:17.428 --> 11:55:21.428
we're spending 800 or 20,000.
You know, there's a big asterisk

11802
11:55:21.428 --> 11:55:25.428
there because that can change a
lot. But we're spending a ton of

11803
11:55:25.428 --> 11:55:29.428
gas anytime we work with storage
as developers. Anytime we work

11804
11:55:29.428 --> 11:55:33.428
with some stuff in storage, we
want to go boy, this is about to

11805
11:55:33.428 --> 11:55:37.428
cost me a lot of gas and the
best convention or making sure

11806
11:55:37.428 --> 11:55:40.428
we know that we're working with
a stored variable and we're

11807
11:55:40.428 --> 11:55:46.429
about to spend a lot of gas is
to append an S underscore right

11808
11:55:46.429 --> 11:55:49.429
before them which stands for
storage right So we're saying

11809
11:55:49.429 --> 11:55:52.429
address to amount funded is
going to be a storage variable

11810
11:55:52.429 --> 11:55:56.429
wonders is going to be a storage
variable. Owner is not going to

11811
11:55:56.429 --> 11:55:59.429
be a storage variable. It's
immutable. The best practice for

11812
11:55:59.429 --> 11:56:02.429
immutable variables is
prefixing. It with an I

11813
11:56:02.429 --> 11:56:06.429
underscore constant values are
also not in storage. So for

11814
11:56:06.429 --> 11:56:09.429
constant values, we want to keep
them capslock, like that

11815
11:56:09.429 --> 11:56:12.429
aggregator v3 interface public
price feed. Yep, you know what

11816
11:56:12.429 --> 11:56:15.429
that is going to be a storage
variable. So we want to append

11817
11:56:15.429 --> 11:56:18.429
an S underscore with it. So
we're going to do a little bit

11818
11:56:18.429 --> 11:56:21.429
more refactor, we've appended
these appropriately to update

11819
11:56:21.429 --> 11:56:25.429
everything. So instead of owner,
it's going to be I underscore

11820
11:56:25.429 --> 11:56:28.429
owner, and as a developer will
read this, and we'll go ah, this

11821
11:56:28.429 --> 11:56:31.429
is going to be much cheaper than
a regular variable. Okay, that's

11822
11:56:31.429 --> 11:56:34.429
great. I'm going to work with
this. This I underscore owner

11823
11:56:34.429 --> 11:56:38.429
for my modifier. Awesome. Is
owner anywhere else in here?

11824
11:56:38.429 --> 11:56:42.429
Okay, right in the constructor.
I own underscore owner is

11825
11:56:42.429 --> 11:56:45.429
message dot sender. Price feed
is a storage variable. We should

11826
11:56:45.429 --> 11:56:49.429
as developers, we should see the
s underscore when reading this

11827
11:56:49.429 --> 11:56:53.429
and go, Okay, we're spending a
lot of gas to store this.

11828
11:56:53.429 --> 11:56:57.429
Perfect. Okay, great. Let's keep
going. Great. We've updated all

11829
11:56:57.429 --> 11:57:01.429
the owners. Okay, well, what
about address to amount funded?

11830
11:57:01.429 --> 11:57:06.429
In VS code? If you do Command F,
or Ctrl, F, and you hit this

11831
11:57:06.429 --> 11:57:10.429
little down arrow, you can
actually find and replace all of

11832
11:57:10.429 --> 11:57:14.429
these address to amount funded
with s underscore address to Mt

11833
11:57:14.429 --> 11:57:18.429
funded. Hit it like that. And
since I updated one, I got a

11834
11:57:18.429 --> 11:57:22.429
backspace that one no. So now
these are all updated. Let's do

11835
11:57:22.429 --> 11:57:26.430
the same thing with s funders.
Let's update everywhere. It has

11836
11:57:26.430 --> 11:57:29.430
funders just to be s funders.
And we probably doubled up here.

11837
11:57:29.430 --> 11:57:30.430
Yep.

11838
11:57:30.430 --> 11:57:33.430
Let's undo that. We already
updated all the AI owners. So

11839
11:57:33.430 --> 11:57:36.430
now it's updated all the price
feeds. So let's look for price

11840
11:57:36.430 --> 11:57:39.430
feed, we'll update it with ES
price feed. And then we probably

11841
11:57:39.430 --> 11:57:42.430
doubled up right here. So we'll
undo that. Okay, great. Now that

11842
11:57:42.430 --> 11:57:45.430
we've updated everything in
here, we can scroll down and we

11843
11:57:45.430 --> 11:57:49.430
can oops, sorry, doubled up
there too. Sorry. We can we can

11844
11:57:49.430 --> 11:57:53.430
green through our code and go
okay, where are we reading and

11845
11:57:53.430 --> 11:57:57.430
writing to storage way more
often than we probably need to.

11846
11:57:57.430 --> 11:58:00.430
And that's when we get to this
withdrawal function, which seems

11847
11:58:00.430 --> 11:58:05.430
rather suspect to reading and
writing to storage a lot. So

11848
11:58:05.430 --> 11:58:08.430
let's take a look at what we're
doing here. Okay, so first of

11849
11:58:08.430 --> 11:58:13.430
all, I can see that we're doing
a for loop here. And every time

11850
11:58:13.430 --> 11:58:16.430
we do a for loop, we're just
constantly looping through all

11851
11:58:16.430 --> 11:58:20.430
of this code. Every single time
we're doing a little compare

11852
11:58:20.430 --> 11:58:24.430
option here we're saying, okay,
is our funder index less than s

11853
11:58:24.430 --> 11:58:28.430
funders dot length? S funders
dot length, this means the

11854
11:58:28.430 --> 11:58:31.430
longer our funders array is, the
more times we're going to be

11855
11:58:32.430 --> 11:58:36.430
reading from storage, that's
incredibly expensive. We're also

11856
11:58:36.430 --> 11:58:40.430
recalling this, oh my goodness,
we're reading from storage a lot

11857
11:58:40.430 --> 11:58:43.430
and saving it to this memory
variable, and then updating our

11858
11:58:43.430 --> 11:58:46.430
storage variable with it. Wow.
So we're reading from storage a

11859
11:58:46.430 --> 11:58:50.430
ton here, and we're reading from
storage a ton here, okay, then

11860
11:58:50.430 --> 11:58:52.430
we have to reset our funders
array, there's really no way

11861
11:58:52.430 --> 11:58:55.430
around it. And that's pretty
much it for our reading and

11862
11:58:55.430 --> 11:58:58.430
writing to storage, we could
probably create a withdrawal

11863
11:58:58.430 --> 11:59:01.430
function, that's a lot cheaper.
So let's go ahead and create a

11864
11:59:01.430 --> 11:59:05.431
function called cheaper
withdraw, function, cheaper

11865
11:59:05.431 --> 11:59:10.431
withdraw. That's going to take
what we've just learned and make

11866
11:59:10.431 --> 11:59:13.431
a cheaper withdraw, that's much
more gas efficient. So we'll

11867
11:59:13.431 --> 11:59:18.431
keep this public payable. and
have it be only owner, we're not

11868
11:59:18.431 --> 11:59:23.431
going to change anything there.
But what can we do for at least

11869
11:59:23.431 --> 11:59:26.431
this part here, we don't want to
keep reading from storage here.

11870
11:59:26.431 --> 11:59:29.431
And we don't want to always have
to keep reading from storage

11871
11:59:29.431 --> 11:59:32.431
here. We're like doubling up the
amount of storage we're reading

11872
11:59:32.431 --> 11:59:35.431
from. So instead, what we can
do, we can read this entire

11873
11:59:35.431 --> 11:59:41.431
array into memory one time, and
then read from memory instead of

11874
11:59:41.431 --> 11:59:43.431
constantly reading from storage.
And that's going to make our

11875
11:59:43.431 --> 11:59:49.431
lives a lot cheaper. So we can
create an address array. Memory

11876
11:59:49.431 --> 11:59:54.431
funders equals s underscore,
funders. And now it's going to

11877
11:59:54.431 --> 11:59:58.431
start making sense why for
arrays and strings in our

11878
11:59:58.431 --> 12:00:01.431
functions, it makes us say, hey,
is this memory is a storage?

11879
12:00:02.431 --> 12:00:04.431
What is this? And we're telling
it, we want it to be memory

11880
12:00:04.431 --> 12:00:07.431
because memory is going to be a
lot cheaper. So now that we're

11881
12:00:07.431 --> 12:00:12.431
saving it into our funders, oh,
and a quick note mappings can't

11882
12:00:12.431 --> 12:00:16.431
be in memory. Sorry. They're
just too weird and too wacky. So

11883
12:00:16.431 --> 12:00:19.431
flooding just doesn't let you do
that right now. But now that

11884
12:00:19.431 --> 12:00:24.431
we've saved our storage variable
into a memory variable, we can

11885
12:00:24.431 --> 12:00:28.431
read and write from this memory
variable, much, much cheaper,

11886
12:00:28.431 --> 12:00:31.431
and then update storage when
we're all done. So what we're

11887
12:00:31.431 --> 12:00:35.431
going to do now is we're gonna
say for you into V six, fund or

11888
12:00:35.431 --> 12:00:38.431
index equals zero, and we're
going to basically rewrite

11889
12:00:38.431 --> 12:00:43.431
everything but just using this
memory array. instead. We're

11890
12:00:43.431 --> 12:00:48.432
gonna say funder index is less
than funders dot length and

11891
12:00:48.432 --> 12:00:53.432
instead of s funders dot length,
and then we're gonna say funder

11892
12:00:53.432 --> 12:00:57.432
index plus plus. And then in
here we're gonna do nearly

11893
12:00:57.432 --> 12:01:01.432
exactly the same thing, except
we're gonna say address funder

11894
12:01:01.432 --> 12:01:08.432
equals funders, using our memory
array and not s funders have

11895
12:01:08.432 --> 12:01:13.432
funder index. And then we're
gonna say s address to amount

11896
12:01:13.432 --> 12:01:20.432
funded. funder equals zero. So
we're resetting our funders

11897
12:01:20.432 --> 12:01:24.432
mapping here, we're using our
memory variables instead, then

11898
12:01:24.432 --> 12:01:28.432
we're going to do the same thing
s underscore funders equals new

11899
12:01:28.432 --> 12:01:33.432
address array of zero. And then
we're gonna do the same thing

11900
12:01:33.432 --> 12:01:41.432
bool success, comma equals S
owner, dot call value,

11901
12:01:41.432 --> 12:01:46.432
address this balance, and we're
going to send it nothing and

11902
12:01:47.432 --> 12:01:53.432
then require success. Like that
actually, sorry, Iona on a sonar

11903
12:01:53.432 --> 12:01:56.432
now that we have this function
that we think is cheaper, let's

11904
12:01:56.432 --> 12:02:01.432
go back to our test. And let's
run this same multi test here,

11905
12:02:01.432 --> 12:02:05.432
but with our cheaper function.
So I know this can be a little

11906
12:02:05.432 --> 12:02:08.432
bit tricky to copy, paste, but
let's copy this entire massive

11907
12:02:08.432 --> 12:02:13.432
test. Let's come down here,
paste it, and we'll change the

11908
12:02:13.432 --> 12:02:19.432
name saying cheaper withdraw,
testing dot that done. And in

11909
12:02:19.432 --> 12:02:22.432
here in in this giant it here,
all we're going to change is

11910
12:02:23.432 --> 12:02:27.433
we're going to change withdraw
to cheaper withdraw, and the

11911
12:02:27.433 --> 12:02:30.433
rest of the test is going to be
exactly the same. So with that,

11912
12:02:30.433 --> 12:02:33.433
let's see if if we were
successful in making our

11913
12:02:33.433 --> 12:02:36.433
withdraw function cheaper with
cheaper withdraw, we're gonna

11914
12:02:36.433 --> 12:02:40.433
pull apart our terminal now. And
we do yarn, art hat test, which

11915
12:02:40.433 --> 12:02:43.433
is going to run our gas
estimator because it's enabled

11916
12:02:43.433 --> 12:02:45.433
right now. And of course, all of
our functions have been broken

11917
12:02:45.433 --> 12:02:49.433
because we renamed everything.
So we'll do a quick final

11918
12:02:49.433 --> 12:02:57.433
replace of funders, to change
funders to ask funders. And then

11919
12:02:57.433 --> 12:03:02.433
we're gonna change price feed to
ask price feed. And then do we

11920
12:03:02.433 --> 12:03:06.433
have owner anywhere? We don't
have owner or anywhere. We need

11921
12:03:06.433 --> 12:03:10.433
to change this one. Address to
amount funded. Let's come in

11922
12:03:10.433 --> 12:03:15.433
here. Address to amount funded.
S adderstone. well funded. What

11923
12:03:15.433 --> 12:03:18.433
else do we need to change price?
We price feed funders. Okay, I

11924
12:03:18.433 --> 12:03:20.433
think we changed everything.
Alright, so let's try our test

11925
12:03:20.433 --> 12:03:24.433
now. Yarn Hardhead test. All
right, great. Everything's

11926
12:03:24.433 --> 12:03:30.433
passing. And we ran our cheaper
withdraw testing. So now, if we

11927
12:03:30.433 --> 12:03:34.433
go to our gas output here, our
gas report, zoom out just a

11928
12:03:34.433 --> 12:03:38.433
hair, we can see the difference
between cheaper withdraw and

11929
12:03:38.433 --> 12:03:42.433
withdraw, we see something
really interesting. Here we see

11930
12:03:42.433 --> 12:03:46.433
our cheaper withdraw on average
was actually more expensive than

11931
12:03:46.433 --> 12:03:49.433
our regular withdraw. And the
reason for this is because

11932
12:03:49.433 --> 12:03:53.433
actually, if we go to our tests
are cheaper withdrawal, we only

11933
12:03:53.433 --> 12:03:57.433
tested on the multi withdraw. So
we had to reset many, many more

11934
12:03:57.433 --> 12:04:01.433
accounts. But this was also
technically its maximum as well.

11935
12:04:01.433 --> 12:04:04.434
And if we compare the maximum of
the cheaper withdrawal, the

11936
12:04:04.434 --> 12:04:07.434
maximum of the withdraw, it
looks like the cheaper

11937
12:04:07.434 --> 12:04:10.434
withdrawal was indeed cheaper.
And if we go to our hard hat dot

11938
12:04:11.434 --> 12:04:15.434
config, and we add our API key
back in, what we could even do

11939
12:04:15.434 --> 12:04:18.434
is in our test, we could copy
withdraw eath from a single

11940
12:04:18.434 --> 12:04:23.434
funder, copy that, paste it in
and just change withdraw to

11941
12:04:23.434 --> 12:04:27.434
cheaper withdrawal, rerun it
with the key and now do yarn

11942
12:04:27.434 --> 12:04:30.434
Hardhead test, we can see
exactly how many dollars we

11943
12:04:30.434 --> 12:04:36.434
would save if we ran this on the
Matic blockchain. Now let's go

11944
12:04:36.434 --> 12:04:41.434
back, we'll reopen up our gas
report. And we can see, in the

11945
12:04:41.434 --> 12:04:43.434
minimum cheaper withdrawal was
actually a little bit more

11946
12:04:43.434 --> 12:04:46.434
expensive. This actually does
make sense because if we look at

11947
12:04:46.434 --> 12:04:49.434
funding, if we only have to
withdraw when there was one

11948
12:04:49.434 --> 12:04:53.434
funder, well this loop only runs
one time. And our cheaper

11949
12:04:53.434 --> 12:04:56.434
withdraw will do the exact same
but it will have this this extra

11950
12:04:56.434 --> 12:05:00.434
thing here of loading them all
in, we see that the savings The

11951
12:05:00.434 --> 12:05:04.434
more people our funders in our
contracts. So automatic, we can

11952
12:05:04.434 --> 12:05:08.434
see we pretty much didn't save
anything. But if I change this

11953
12:05:08.434 --> 12:05:14.434
one more time to eath run the
test again. Now we can see

11954
12:05:14.434 --> 12:05:18.434
people withdraw saved a few
cents. This is how we can start

11955
12:05:18.434 --> 12:05:21.434
optimizing our contracts will be
cheaper and cheaper. And this

11956
12:05:21.434 --> 12:05:23.434
two cents was just in the
average. It's not even comparing

11957
12:05:23.434 --> 12:05:27.434
the max to the max, which was a
lot more gas than their

11958
12:05:27.434 --> 12:05:35.434
averages. We have just learned
an absolute ton here. Now, this

11959
12:05:35.434 --> 12:05:36.434
next part is going to make some
of you mad because we're going

11960
12:05:36.434 --> 12:05:39.434
to refactor our code one more
time if you don't want to

11961
12:05:39.434 --> 12:05:42.434
refactor it and you want to
leave all your tests as s

11962
12:05:42.434 --> 12:05:45.435
underscores you absolutely can
but to other users using our

11963
12:05:45.435 --> 12:05:48.435
application. Dealing with this s
underscore is a little Little

11964
12:05:48.435 --> 12:05:51.435
bit gross and actually can make
our code a little bit more

11965
12:05:51.435 --> 12:05:55.435
confusing for those who use it.
And additionally, right now all

11966
12:05:55.435 --> 12:05:58.435
of our state variables are
public. And actually internal

11967
12:05:58.435 --> 12:06:01.435
variables and private variables
are also cheaper gas wise. And

11968
12:06:01.435 --> 12:06:03.435
we don't need to make every
single one of our variables

11969
12:06:03.435 --> 12:06:07.435
public, because anybody can read
them off the chain anyways. So

11970
12:06:07.435 --> 12:06:09.435
one more refactoring that we're
going to do is we're actually

11971
12:06:09.435 --> 12:06:13.435
going to set the visibility of
these to private or internal,

11972
12:06:13.435 --> 12:06:16.435
based off of whether or not they
need to be private or internal,

11973
12:06:16.435 --> 12:06:20.435
and then we'll create getters at
the bottom of our function here.

11974
12:06:20.435 --> 12:06:23.435
So minimum USD, we can keep this
public because we want other

11975
12:06:23.435 --> 12:06:26.435
people to know what the minimum
USD of our contract is, without

11976
12:06:26.435 --> 12:06:29.435
having to go right through
storage, the owner of our

11977
12:06:29.435 --> 12:06:31.435
contract isn't important for
others to know or other

11978
12:06:31.435 --> 12:06:34.435
contracts to know. So we can go
ahead and make this private, and

11979
12:06:34.435 --> 12:06:37.435
then at the bottom at a function

11980
12:06:37.435 --> 12:06:49.435
get owner. That's a public view
that returns I owner, turns

11981
12:06:49.435 --> 12:06:55.435
address as funders, as funders
can be private as well. So at

11982
12:06:55.435 --> 12:07:00.435
the bottom, we're gonna say
function, get funder, and we're

11983
12:07:00.435 --> 12:07:12.435
going to pass a un 236 index,
public U, turns, address, return

11984
12:07:12.435 --> 12:07:17.435
as funders of index, the address
to Mt funded can also be

11985
12:07:17.435 --> 12:07:22.435
private. So the bottom, we're
going to create function, get

11986
12:07:22.435 --> 12:07:29.436
address to amount funded. And
this is going to take an address

11987
12:07:29.436 --> 12:07:36.436
under the public view returns,
you went to 56. And we're going

11988
12:07:36.436 --> 12:07:41.436
to return amount funded of the
funder did this one we did this

11989
12:07:41.436 --> 12:07:46.436
one, we did this one. And then
price feed, function get price

11990
12:07:46.436 --> 12:07:51.436
feed. This is going to be public
view as well, that returns

11991
12:07:51.436 --> 12:07:55.436
aggregate tour of the three
interface that's going to return

11992
12:07:55.436 --> 12:07:58.436
so I'm just gonna price feed.
Oh, okay. The reason why we did

11993
12:07:58.436 --> 12:08:02.436
that is because we want to have
this s underscore so that we as

11994
12:08:02.436 --> 12:08:05.436
developers can know, okay, this
is a storage variable, I want to

11995
12:08:05.436 --> 12:08:08.436
be very careful about how I
interact with this. But we don't

11996
12:08:08.436 --> 12:08:11.436
want people who interact with
our code to have to deal with

11997
12:08:11.436 --> 12:08:14.436
this s stuff. And we want to
give them an API that makes

11998
12:08:14.436 --> 12:08:17.436
sense, and that it's easy and
readable. So we add these getter

11999
12:08:17.436 --> 12:08:20.436
functions at the bottom to do
that. And also changing the

12000
12:08:20.436 --> 12:08:24.436
visibility can save us some gas
in the long run as well, because

12001
12:08:24.436 --> 12:08:26.436
we're gonna be calling from
private variables or internal

12002
12:08:26.436 --> 12:08:29.436
variables, which are cheaper gas
wise, of course, we do need to

12003
12:08:29.436 --> 12:08:31.436
upgrade our test one more time.
And like I said, if you want to

12004
12:08:31.436 --> 12:08:34.436
just leave them with the S
underscores, that's absolutely

12005
12:08:34.436 --> 12:08:40.436
fine. So s underscore price feed
is now going to be replaced with

12006
12:08:40.436 --> 12:08:44.436
get price feed, s underscore
amount to fund it is going to be

12007
12:08:44.436 --> 12:08:49.436
now replaced with get address to
amount funded. For now going to

12008
12:08:49.436 --> 12:08:56.436
change SW, underscore funders,
to get funder. We're going to

12009
12:08:56.436 --> 12:08:59.436
change Iona, there's nowhere
else in their mind, we don't

12010
12:08:59.436 --> 12:09:01.436
need to change them. And I think
that was everything. Let's just

12011
12:09:01.436 --> 12:09:05.437
look for s underscore, we don't
see it, I underscore, we don't

12012
12:09:05.437 --> 12:09:08.437
see that either. Let's just run
our tests one more time to make

12013
12:09:08.437 --> 12:09:13.437
sure we refactor that correctly.
And it looks like we did

12014
12:09:13.437 --> 12:09:17.437
awesome. Okay, we have just
learned a ton. we've refactored

12015
12:09:17.437 --> 12:09:20.437
our code a ton. And everything
is starting to look really,

12016
12:09:20.437 --> 12:09:24.437
really good here. One more gas
optimization we could make. And

12017
12:09:24.437 --> 12:09:28.437
an optimization for errors as
well is we could update all of

12018
12:09:28.437 --> 12:09:33.437
our requires to instead be to
instead be reverts. Because

12019
12:09:33.437 --> 12:09:37.437
without requires, we're actually
storing this massive string,

12020
12:09:37.437 --> 12:09:42.437
this massive array of text on
chain, these error codes are

12021
12:09:42.437 --> 12:09:44.437
much cheaper. But that's
optional. If you want to do

12022
12:09:44.437 --> 12:09:47.437
that. The whole reason we were
doing this is we were going

12023
12:09:47.437 --> 12:09:50.437
through the style guide in
updating things here. So we have

12024
12:09:50.437 --> 12:09:53.437
public internal private, and the
bottom is going to be our view

12025
12:09:53.437 --> 12:09:56.437
slash pure functions, which they
are they're just all these

12026
12:09:56.437 --> 12:10:00.437
getters that we just added.

12027
12:10:00.437 --> 12:10:03.437
So now our style in here looks
good. We've learned a lot about

12028
12:10:03.437 --> 12:10:06.437
gas, we've learned a lot about
storage. This is fantastic.

12029
12:10:06.437 --> 12:10:09.437
Let's do a quick refresher on
everything we just learned

12030
12:10:09.437 --> 12:10:13.437
because we went through a lot
right there. And like I said,

12031
12:10:13.437 --> 12:10:16.437
this is one of the harder parts
of this course. Any variable

12032
12:10:16.437 --> 12:10:19.437
that is changeable that we want
to persist across contract

12033
12:10:20.437 --> 12:10:24.437
executions and transactions. We
save to a giant array called

12034
12:10:24.437 --> 12:10:27.437
storage this array is
sequentially indexed starting at

12035
12:10:27.437 --> 12:10:31.437
zero. So the first variable the
first value that we have in our

12036
12:10:31.437 --> 12:10:35.437
contract gets stored to the zero
with index. The next one gets

12037
12:10:35.437 --> 12:10:39.437
stored to one and so on and so
forth. Dynamic arrays and

12038
12:10:39.437 --> 12:10:43.437
mappings and other dynamically
sized objects use specific

12039
12:10:43.437 --> 12:10:46.438
hashing function that you can
find in the documentation to

12040
12:10:46.438 --> 12:10:50.438
determine where the elements of
those dynamic Data Structures go

12041
12:10:50.438 --> 12:10:53.438
memory variables, constant
variables and immutable

12042
12:10:53.438 --> 12:10:57.438
variables don't go in storage.
And one of the main reasons

12043
12:10:57.438 --> 12:11:01.438
talking about storage is so
important is because the op

12044
12:11:01.438 --> 12:11:05.438
codes for loading from storage
and for reading from storage and

12045
12:11:05.438 --> 12:11:09.438
writing to storage are
incredibly gas expensive. So in

12046
12:11:09.438 --> 12:11:12.438
everywhere we can we want to
reduce the amount that we read

12047
12:11:12.438 --> 12:11:16.438
and load from storage. And it's
one of the easiest ways to save

12048
12:11:16.438 --> 12:11:20.438
gas and try to optimize our code
to be gas efficient. Like I

12049
12:11:20.438 --> 12:11:22.438
said, some of this gas stuff can
be a little tricky and a little

12050
12:11:22.438 --> 12:11:25.438
bit confusing. So if you don't
get this right away, it's okay.

12051
12:11:25.438 --> 12:11:28.438
It is totally fine. If you're a
little bit confused, and you're

12052
12:11:28.438 --> 12:11:31.438
like, What is he talking about?
Like I said, this is some of the

12053
12:11:31.438 --> 12:11:34.438
more advanced stuff it'll come,
the more you work with solidity,

12054
12:11:34.438 --> 12:11:36.438
and the more you work with
everything here. So don't let it

12055
12:11:36.438 --> 12:11:39.438
stress you out. Don't let it
stop you from continuing. You're

12056
12:11:39.438 --> 12:11:45.438
doing fantastic being here. So
far. We've written some really

12057
12:11:45.438 --> 12:11:50.438
good unit tests. Let's now write
some staging tests. And these

12058
12:11:50.438 --> 12:11:54.438
are the tests that we can use on
an actual test net. This is a

12059
12:11:54.438 --> 12:11:57.438
test that we're basically going
to run after we've deployed some

12060
12:11:57.438 --> 12:12:01.438
code just to see if everything
is working approximately the way

12061
12:12:01.438 --> 12:12:03.438
we want it to. So let's go ahead
and we'll create a new file

12062
12:12:03.438 --> 12:12:10.438
here. We'll call it fund me. Dot
staging dot test, dot j s. And

12063
12:12:10.438 --> 12:12:12.438
it's going to look really
similar to what we were just

12064
12:12:12.438 --> 12:12:15.438
doing with our unit tests. And
we're going to assume this is on

12065
12:12:15.438 --> 12:12:18.438
a test net. So these are tests
that we're going to run, right

12066
12:12:18.438 --> 12:12:21.438
before we deploy this to a main
net, this is the last step in

12067
12:12:21.438 --> 12:12:24.439
your development journey, we
want to just make sure that

12068
12:12:24.439 --> 12:12:27.439
everything is working
approximately correctly on an

12069
12:12:27.439 --> 12:12:29.439
actual test net. So what we're
gonna do is we're gonna do the

12070
12:12:29.439 --> 12:12:34.439
same thing describe, fund me,
and I'm gonna go a little quick

12071
12:12:34.439 --> 12:12:37.439
through these tests here,
because we've basically written

12072
12:12:37.439 --> 12:12:39.439
this type of test before, so
we're gonna say before each,

12073
12:12:39.439 --> 12:12:44.439
it's gonna be an async.
function. We're gonna do the

12074
12:12:44.439 --> 12:12:48.439
same thing as our unit tests. So
we're gonna have a Funmi

12075
12:12:48.439 --> 12:12:51.439
variable, we're gonna have our
let Deployer, we're gonna have

12076
12:12:51.439 --> 12:13:00.439
our constant send value equals
ethers.utils.rs ether of one,

12077
12:13:00.439 --> 12:13:05.439
and in here, we're going to do
const. Get named accounts.

12078
12:13:05.439 --> 12:13:12.439
Equals require hardhats, we're
going to say deployer equals

12079
12:13:12.439 --> 12:13:17.439
weight, get named accounts,
we're going to wrap this up, dot

12080
12:13:17.439 --> 12:13:22.439
Deployer. We're gonna say fun me
equals await ethers dot get

12081
12:13:23.439 --> 12:13:25.439
contract.

12082
12:13:25.439 --> 12:13:29.439
And me, comma, we're going to
connect it to our Deployer,

12083
12:13:29.439 --> 12:13:32.439
we're not going to deploy this,
we're not going to do any

12084
12:13:32.439 --> 12:13:34.439
fixtures like we did in our unit
tests, because in our staging

12085
12:13:35.439 --> 12:13:38.439
tests, we're assuming that it's
already deployed here. And we

12086
12:13:38.439 --> 12:13:43.439
also don't need a mock because
on a staging, we're assuming

12087
12:13:43.439 --> 12:13:46.439
that we're on a test net, now we
can actually wrap this whole

12088
12:13:46.439 --> 12:13:49.439
thing to make sure that we're on
a test net by using our helper

12089
12:13:49.439 --> 12:13:53.439
config. And looking for our
development chains, we can say

12090
12:13:53.439 --> 12:13:57.439
we only want to run our describe
bit if we're on a development

12091
12:13:57.439 --> 12:14:04.440
chain. So first, we'll say
const. Development chains equals

12092
12:14:04.440 --> 12:14:10.440
require, we'll pull that that
helper config in. And we'll say,

12093
12:14:10.440 --> 12:14:15.440
development chains dot includes
network dot name. And we'll

12094
12:14:15.440 --> 12:14:18.440
basically will say if developer
chains that includes network dot

12095
12:14:18.440 --> 12:14:22.440
name, we're going to skip and we
can actually skip using this,

12096
12:14:22.440 --> 12:14:25.440
we're going to use something
called a ternary operator is

12097
12:14:25.440 --> 12:14:28.440
basically like a one liner if
statement. And you can think of

12098
12:14:28.440 --> 12:14:31.440
this as a special type of F.
I've got a link to this and the

12099
12:14:31.440 --> 12:14:33.440
GitHub repo associated with this
course. And here's some

12100
12:14:33.440 --> 12:14:37.440
JavaScript documentation,
showing it in action. You say,

12101
12:14:37.440 --> 12:14:43.440
Okay, return is member. And if
it's true, have it be $2.

12102
12:14:43.440 --> 12:14:47.440
Otherwise have a B $10. And
that's pretty much it. So

12103
12:14:47.440 --> 12:14:51.440
another way of thinking about is
like, you say, let variable

12104
12:14:51.440 --> 12:14:57.440
equals true, then we could say,
let some var equals variable

12105
12:14:57.440 --> 12:15:03.440
question. Yes? Or no? Some var
will end up being Yes. Because

12106
12:15:03.440 --> 12:15:07.440
variable is true. If variable
was false than some var would be

12107
12:15:07.440 --> 12:15:12.440
no. So it's literally saying, If
variable, if variable, then some

12108
12:15:12.440 --> 12:15:19.440
var equals yes. Else. Some var
equals no, these lines are

12109
12:15:19.440 --> 12:15:21.440
literally the exact same thing.
This one is just a little bit

12110
12:15:21.440 --> 12:15:24.440
more succinct. That's really it.
So that's what this operator

12111
12:15:24.440 --> 12:15:26.440
does. We're gonna say
development chains that includes

12112
12:15:26.440 --> 12:15:30.440
network dot name. So if our
network is a development chain,

12113
12:15:30.440 --> 12:15:33.440
which we're going to import
network as well from hard hat

12114
12:15:33.440 --> 12:15:37.440
and ethers as well. Then we're
going to do describe that

12115
12:15:37.440 --> 12:15:41.440
skipped and this tells our test
to just skip this whole

12116
12:15:41.440 --> 12:15:43.440
describe, and then we're going
to put this little colon here

12117
12:15:43.440 --> 12:15:48.441
thing and save and boom. So now
we're only going to run this if

12118
12:15:48.441 --> 12:15:50.441
we're not On a development
chain, and we want to take this

12119
12:15:50.441 --> 12:15:54.441
exact same syntax, we'll go to
our unit testing here, and we'll

12120
12:15:54.441 --> 12:15:58.441
do the exact same thing, we'll
paste it will have this be the

12121
12:15:58.441 --> 12:16:01.441
opposite by putting a little
knot here, sticking that colon

12122
12:16:01.441 --> 12:16:05.441
in. So now, our unit tests only
run on development chains in our

12123
12:16:05.441 --> 12:16:09.441
staging tests, only run on test
nets. Perfect. That's what we

12124
12:16:09.441 --> 12:16:15.441
want, allows people to fund and
own and withdraw. And this will

12125
12:16:15.441 --> 12:16:18.441
be an async function, of course,
and we probably can make this

12126
12:16:18.441 --> 12:16:23.441
pretty robust, but we'll just
say await, fund me dot fund is

12127
12:16:23.441 --> 12:16:28.441
going to be send a value. And
then we'll say a weight on me

12128
12:16:28.441 --> 12:16:36.441
dot withdraw. CERT equals
require try. Now we'll do kind

12129
12:16:36.441 --> 12:16:40.441
of a lame final one, we'll say
const ending balance equals a

12130
12:16:40.441 --> 12:16:47.441
weight on me dot provider dot
get balance, fund me dot

12131
12:16:47.441 --> 12:16:52.441
address. And then we'll say
assert dot equals ending

12132
12:16:52.441 --> 12:16:58.441
balance.to string, comma zero as
a string, we're only going to

12133
12:16:58.441 --> 12:17:00.441
run this on a test net, I'm just
going to give you this one more

12134
12:17:00.441 --> 12:17:04.441
run to show you it in action.
Feel free to skip this part

12135
12:17:04.441 --> 12:17:06.441
again, because we are going to
be working with a test net, I'm

12136
12:17:06.441 --> 12:17:11.441
going to run yarn, hard hat
deploy dash test network

12137
12:17:11.441 --> 12:17:17.441
Rinkeby. And it's going to run
through our deploy. And after

12138
12:17:17.441 --> 12:17:20.441
it's all deployed, we're going
to run our staging tests to make

12139
12:17:20.441 --> 12:17:24.442
sure that everything works even
with a price feed on a real test

12140
12:17:24.442 --> 12:17:28.442
net, and I need to do const
development chains equals

12141
12:17:28.442 --> 12:17:34.442
require dot dot slash dot dot
slash helper heart config. Now

12142
12:17:34.442 --> 12:17:40.442
for run yarn, hard hat test,
we'll see just our unit tests

12143
12:17:40.442 --> 12:17:44.442
get run. But if we run yarn hard
to test dash dash network

12144
12:17:44.442 --> 12:17:47.442
Rinkeby, we're not going to run
nine tests, we're only going to

12145
12:17:47.442 --> 12:17:51.442
run our singular staging test.
And of course, this is going to

12146
12:17:51.442 --> 12:17:54.442
be a lot slower, because we're
on a

12147
12:17:54.442 --> 12:18:02.442
test net. Net will we write
written all these tests, we can

12148
12:18:02.442 --> 12:18:05.442
write a couple of scripts. And
then we're going to finish this

12149
12:18:05.442 --> 12:18:08.442
out by pushing this up to GitHub
making this our first smart

12150
12:18:08.442 --> 12:18:11.442
contract GitHub repository, when
it comes to the blockchain, when

12151
12:18:11.442 --> 12:18:14.442
it comes to smart contracts,
interacting with community

12152
12:18:14.442 --> 12:18:18.442
interacting with open source
being a part of GitHub, or git

12153
12:18:18.442 --> 12:18:21.442
labs or whatever Git hosting
service you're using is

12154
12:18:21.442 --> 12:18:24.442
essential to being successful
here. So let's write our

12155
12:18:24.442 --> 12:18:27.442
scripts. And then we'll upload
this to GitHub to start building

12156
12:18:27.442 --> 12:18:30.442
our portfolio. So first, we're
going to create a script to

12157
12:18:30.442 --> 12:18:34.442
interact with our code called
fund dot j s. And this is going

12158
12:18:34.442 --> 12:18:37.442
to be really similar to our
tests. And this way, in the

12159
12:18:37.442 --> 12:18:39.442
future. If we want to just fund
one of our contracts very

12160
12:18:39.442 --> 12:18:42.442
quickly, we can just run this
and we can do it, we're gonna do

12161
12:18:42.442 --> 12:18:45.442
the same thing that we've been
doing, we're gonna do an async

12162
12:18:45.442 --> 12:18:49.442
function main. And down below,
I'm just going to copy paste

12163
12:18:49.442 --> 12:18:51.442
this because we're going to be
copy pasting in a lot. We're

12164
12:18:51.442 --> 12:18:55.442
going to paste this little
syntax here. So let's write a

12165
12:18:55.442 --> 12:18:59.442
script that allows us to fund
our contracts. So first, we're

12166
12:18:59.442 --> 12:19:04.443
going to need const get named
accounts just like in our tests,

12167
12:19:04.443 --> 12:19:15.443
equals require arhat we're gonna
say const Deployer. Equals await

12168
12:19:15.443 --> 12:19:20.443
yet named accounts, just like
that. And then we're gonna say

12169
12:19:20.443 --> 12:19:27.443
const fund me equals await
ethers dot get contract. From

12170
12:19:27.443 --> 12:19:31.443
funding comm a Deployer.
Literally, almost exactly the

12171
12:19:31.443 --> 12:19:36.443
same as our tests, then we'll do
a little console dot log funding

12172
12:19:36.443 --> 12:19:43.443
contract that that and we'll do
const transaction response

12173
12:19:43.443 --> 12:19:49.443
equals await funding dot fund.
And for the value, we'll do

12174
12:19:49.443 --> 12:19:56.443
something like ethers dot utils,
that parse ether of 0.1 or

12175
12:19:56.443 --> 12:19:58.443
something, whatever you want to
do here, we of course, need to

12176
12:19:58.443 --> 12:20:01.443
import ethers, which it looks
like we already have. We'll do

12177
12:20:01.443 --> 12:20:06.443
await transaction response dot
wait for one transaction. And

12178
12:20:06.443 --> 12:20:12.443
then we'll do console dot log
funded, we can run this little

12179
12:20:12.443 --> 12:20:17.443
script by running yarn, RT head
node will run a local node with

12180
12:20:17.443 --> 12:20:21.443
all of our contracts deployed.
We'll see if our script looks

12181
12:20:21.443 --> 12:20:27.443
okay by running yarn, hard hat
run scripts fund dot j s dash

12182
12:20:27.443 --> 12:20:32.443
dash network localhost. And it
looks like it's funding Great.

12183
12:20:32.443 --> 12:20:37.443
Let's now write a withdraw
script withdraw that J S. And we

12184
12:20:37.443 --> 12:20:40.443
can even leave our localhost
Node running because we're going

12185
12:20:41.443 --> 12:20:43.443
to withdraw the funds that we've
just funded it with. So we're

12186
12:20:43.443 --> 12:20:47.444
going to do the exact same setup
here. We can even copy this main

12187
12:20:47.444 --> 12:20:54.444
bit to our withdraw Ah, the top
will do async function main will

12188
12:20:54.444 --> 12:21:00.444
say const deployer equals await,
get named accounts, which wow, I

12189
12:21:00.444 --> 12:21:03.444
hit enter and my VS code auto
imported it, that's pretty nice.

12190
12:21:03.444 --> 12:21:06.444
Maybe yours will too, maybe
won't if it won't, you just

12191
12:21:06.444 --> 12:21:08.444
gotta write it out or copy paste
from the other one. And then

12192
12:21:08.444 --> 12:21:13.444
we'll do cars Funmi equals await
ethers dot get contract on me,

12193
12:21:13.444 --> 12:21:17.444
course. And this is going to be
the exact same. Now we're going

12194
12:21:17.444 --> 12:21:23.444
to do console dot log funding
data dot, we'll say const

12195
12:21:23.444 --> 12:21:30.444
transaction response equals
await on v dot withdraw, await

12196
12:21:30.444 --> 12:21:35.444
transaction response dot wait
one, then console dot log. Got

12197
12:21:35.444 --> 12:21:42.444
it? Back. And we can test this
out by running yarn, hard hit

12198
12:21:42.444 --> 12:21:46.444
run scripts, withdraw dash dash
network localhost, we'll see if

12199
12:21:46.444 --> 12:21:51.444
this works. And cool and our
script is working. Fantastic

12200
12:21:51.444 --> 12:21:54.444
crushed out two scripts
incredibly quickly. And now we

12201
12:21:54.444 --> 12:21:57.444
have a way to easily interact
with our code with our contracts

12202
12:21:57.444 --> 12:22:03.444
if we want to via a script.
There's actually one more thing

12203
12:22:03.444 --> 12:22:05.444
I want to show you before we
actually work and we push all

12204
12:22:05.444 --> 12:22:09.444
this wonderful code up to GitHub
in our package dot JSON. I've

12205
12:22:09.444 --> 12:22:12.444
shown you a little bit of this
before, but we can add this

12206
12:22:12.444 --> 12:22:17.444
scripts section to make our
lives a lot easier and condense

12207
12:22:17.444 --> 12:22:22.444
all these long tests into a yarn
script for us. So usually, what

12208
12:22:22.444 --> 12:22:25.445
you'll see in common package dot
JSON is you'll see a list of

12209
12:22:25.445 --> 12:22:28.445
these in here for people to look
and just automatically run, one

12210
12:22:29.445 --> 12:22:32.445
of the most common ones is going
to be test. And to run test,

12211
12:22:32.445 --> 12:22:37.445
we're going to do yarn, hard hat
test. So now instead of running

12212
12:22:37.445 --> 12:22:40.445
yarn, Hardhead test, someone can
just come to your package once

12213
12:22:40.445 --> 12:22:44.445
this is saved and just run yarn
test. And this will grab this

12214
12:22:44.445 --> 12:22:47.445
test from your script section
and it will run yarn heart at

12215
12:22:47.445 --> 12:22:49.445
test and Bada bing, bada boom,

12216
12:22:49.445 --> 12:22:52.445
okay, cool. What else do we
probably probably want to do in

12217
12:22:52.445 --> 12:22:55.445
here? Well, we probably want to
have a test staging section

12218
12:22:55.445 --> 12:23:02.445
that'll run yarn Hardhead test
dash dash, network Rinkeby. I'm

12219
12:23:02.445 --> 12:23:04.445
not going to run that. But
that's probably something we

12220
12:23:05.445 --> 12:23:07.445
want to have in here, we're
probably going to want some

12221
12:23:07.445 --> 12:23:11.445
linting. So we showed you
briefly that linting thing. So

12222
12:23:11.445 --> 12:23:16.445
we'll have a yarn lint, which
will just run yarn, sole hint.

12223
12:23:16.445 --> 12:23:20.445
And then we'll just have it so
hence the contracts folder. And

12224
12:23:20.445 --> 12:23:24.445
anything that starts out soul.
So now if I run yarn, lint,

12225
12:23:24.445 --> 12:23:29.445
it'll run soul hint, and all of
our code here and it'll give us

12226
12:23:29.445 --> 12:23:32.445
some warnings here, which we can
pretty much all ignore. And

12227
12:23:32.445 --> 12:23:36.445
Solon actually has an auto fix
and auto fix that we can add, by

12228
12:23:36.445 --> 12:23:42.445
doing yarn lint fix, we'll say
yarn. So hint, contracts slash

12229
12:23:42.445 --> 12:23:48.445
start out. So we'll do dash dash
fix. So now we run yarn, lint

12230
12:23:48.445 --> 12:23:52.445
fix, it'll auto fix, which
there's nothing to auto fix. So

12231
12:23:52.445 --> 12:23:55.445
nothing happens. But it's good
to have anyways. And then we can

12232
12:23:55.445 --> 12:23:59.445
do our formatter, we're just
going to format our code format,

12233
12:23:59.445 --> 12:24:03.445
that which will do yarn,
prettier, dash dash write to,

12234
12:24:03.445 --> 12:24:06.446
and we'll just do a period to do
everything. And then we can just

12235
12:24:06.446 --> 12:24:11.446
do yarn format. And it's gonna
fix all of our, it's going to

12236
12:24:11.446 --> 12:24:15.446
fix everything for us, which is
great. And then we finally can

12237
12:24:15.446 --> 12:24:20.446
have coverage. By running yarn
hardhat coverage, now we can

12238
12:24:20.446 --> 12:24:24.446
just run yarn coverage, will
give us this wonderful little

12239
12:24:24.446 --> 12:24:28.446
coverage report. Awesome. So our
packages looking fantastic.

12240
12:24:28.446 --> 12:24:31.446
Maybe we'll even come into
package json. We'll give this a

12241
12:24:31.446 --> 12:24:38.446
name. We'll call this hard hat.
And me give it an author, which

12242
12:24:38.446 --> 12:24:41.446
is going to be your name. So I'm
just gonna say Patrick Collins,

12243
12:24:41.446 --> 12:24:48.446
and we'll give it a version in
here. of 1.0 Point Oh, oops. And

12244
12:24:48.446 --> 12:24:53.446
let's do icons instead of
spaces. Oh, and one more thing.

12245
12:24:53.446 --> 12:24:57.446
We're not using ES lint. So all
this es lint stuff, we can dump

12246
12:24:57.446 --> 12:25:00.446
and we could delete the yarn dot
lock and reinstall. But yeah,

12247
12:25:00.446 --> 12:25:03.446
whatever. We don't have a
readme, but that's okay. If you

12248
12:25:03.446 --> 12:25:06.446
want to go back, like I said, go
check out that best readme

12249
12:25:06.446 --> 12:25:10.446
template and go update your
READMEs to make them look as

12250
12:25:10.446 --> 12:25:12.446
awesome as this, you can do that
as well. But other than that,

12251
12:25:12.446 --> 12:25:19.446
we've got an awesome code repo
here. What do we want to do with

12252
12:25:19.446 --> 12:25:21.446
it? Well, we've been playing
around with GitHub so much,

12253
12:25:21.446 --> 12:25:24.446
we've been looking at all these
good hubs. It's time for us to

12254
12:25:24.446 --> 12:25:29.446
join GitHub with our own with
our first repository. Let's go

12255
12:25:29.446 --> 12:25:33.446
ahead and let's make this happen
in the lesson seven full

12256
12:25:33.446 --> 12:25:36.446
blockchain solidity course, yes,
there is a link to this GitHub

12257
12:25:36.446 --> 12:25:39.446
Quickstart that we're going to
follow to set up our first

12258
12:25:39.446 --> 12:25:42.446
repository. This is going to be
the moment where you are

12259
12:25:42.446 --> 12:25:45.447
starting to build your portfolio
building and GitHub is

12260
12:25:45.447 --> 12:25:48.447
borderline crucial for your
development journey. It's going

12261
12:25:48.447 --> 12:25:50.447
to be your portal folio, it's
going to be where you say, Hey,

12262
12:25:50.447 --> 12:25:53.447
look at all the cool products
that I'm engaging with, that I'm

12263
12:25:53.447 --> 12:25:55.447
working with, that I'm
participating in. If you've

12264
12:25:55.447 --> 12:25:58.447
already made GitHub before, I
highly recommend you still push

12265
12:25:58.447 --> 12:26:01.447
this up to GitHub as proof that
you've done it. And then you can

12266
12:26:01.447 --> 12:26:04.447
also tweet it at me saying, hey,
look how far I've gotten. Look

12267
12:26:04.447 --> 12:26:07.447
where I've done, look at how
fantastic I'm learning smart

12268
12:26:07.447 --> 12:26:10.447
contracts, and be incredibly
excited about now, this

12269
12:26:10.447 --> 12:26:13.447
quickstart will walk you through
creating a repository, creating

12270
12:26:13.447 --> 12:26:16.447
a branch and teaching all this
stuff, we're going to follow the

12271
12:26:16.447 --> 12:26:18.447
instructions from the GitHub
documentation about adding

12272
12:26:18.447 --> 12:26:21.447
locally hosted code to GitHub,
we already have a project, and

12273
12:26:21.447 --> 12:26:25.447
we're just pushing it up. Since
the Windows users are using WsL,

12274
12:26:25.447 --> 12:26:28.447
you can just follow the Mac or
Linux instructions here, the

12275
12:26:28.447 --> 12:26:31.447
first thing that we're going to
do is in your GitHub profile, or

12276
12:26:31.447 --> 12:26:34.447
your GitHub login, we're gonna
hit this little plus thing, and

12277
12:26:34.447 --> 12:26:37.447
hit new repository, you can call
this whatever you want, let's

12278
12:26:37.447 --> 12:26:43.447
call it hard hat, fund me b code
camp, you can put a description

12279
12:26:43.447 --> 12:26:49.447
if you want, learning from
recode camp, and Patrick, about

12280
12:26:49.447 --> 12:26:52.447
smart contracts.

12281
12:26:52.447 --> 12:26:55.447
We'll make it public because we
want other people to see you

12282
12:26:55.447 --> 12:26:57.447
being fantastic and learning
smart contracts. We'll leave

12283
12:26:57.447 --> 12:27:01.447
this blank, and we'll hit Create
repository. Now, this is our

12284
12:27:01.447 --> 12:27:04.447
public code repository. This is
our first one, if you've done

12285
12:27:04.447 --> 12:27:08.447
these already, this will be your
first smart contract one. It

12286
12:27:08.447 --> 12:27:11.447
even has some instructions in
here, too, that teaches us how

12287
12:27:11.447 --> 12:27:14.447
to create a new repository from
the command line, you can follow

12288
12:27:14.447 --> 12:27:18.447
this if you want, or you can
follow like so the first thing

12289
12:27:18.447 --> 12:27:23.447
we're going to do is we're going
to initialize a git branch. And

12290
12:27:23.447 --> 12:27:26.448
from way back when you should
already have Git installed.

12291
12:27:26.448 --> 12:27:29.448
Remember, you can check by
running git dash dash version

12292
12:27:29.448 --> 12:27:32.448
like this. Git is a little
different from GitHub, Git is

12293
12:27:32.448 --> 12:27:35.448
known as version control. And it
allows us to make changes to our

12294
12:27:35.448 --> 12:27:39.448
code, but keep a history of all
the code changes that we've

12295
12:27:39.448 --> 12:27:43.448
made. GitHub is a place where we
can push all of these changes

12296
12:27:43.448 --> 12:27:45.448
and keep track of all of our
code. So the first thing that

12297
12:27:45.448 --> 12:27:48.448
we're going to do is we're going
to create a new branch. And I'm

12298
12:27:48.448 --> 12:27:51.448
not going to explain Git and
working with Git too, too

12299
12:27:51.448 --> 12:27:54.448
deeply. But if you want to learn
about Git Free Code Camp, of

12300
12:27:54.448 --> 12:27:58.448
course, has a video on Git and
GitHub for beginners. So we're

12301
12:27:58.448 --> 12:28:01.448
going to create this new branch
with git init dash b main, now

12302
12:28:02.448 --> 12:28:05.448
your Visual Studio code might
automatically start formatting

12303
12:28:05.448 --> 12:28:07.448
some stuff. And if it does,
that's great. And if it doesn't,

12304
12:28:07.448 --> 12:28:10.448
don't worry about it. But what
you'll see here on the left is

12305
12:28:10.448 --> 12:28:14.448
you'll see some stuff is green,
and some stuff is gray, open

12306
12:28:14.448 --> 12:28:17.448
back up that dot Git ignore,
you'll see that all the gray

12307
12:28:17.448 --> 12:28:21.448
stuff is the stuff that we have
in this dot Git ignore this is

12308
12:28:21.448 --> 12:28:23.448
intentional, this is what we
want. This is just some some

12309
12:28:23.448 --> 12:28:26.448
highlighting saying, hey, this
green stuff is what you're

12310
12:28:26.448 --> 12:28:29.448
working with on GitHub. And this
gray stuff is what you're not

12311
12:28:29.448 --> 12:28:31.448
working with and GitHub. And
that's what we want. You don't

12312
12:28:31.448 --> 12:28:35.448
need to push artifacts, or cash
or coverage or node modules,

12313
12:28:35.448 --> 12:28:39.448
people can install and compile
on their own machines, we

12314
12:28:39.448 --> 12:28:43.448
definitely don't want to push up
our Dotty and V if we're using a

12315
12:28:43.448 --> 12:28:46.448
Dotty and V. And we don't really
need to push up coverage dot

12316
12:28:46.448 --> 12:28:50.448
JSON, either the rest of this we
do. So now what's next, after we

12317
12:28:50.448 --> 12:28:54.448
initialize our main branch, you
now should be able to run git

12318
12:28:54.448 --> 12:28:59.448
status in your terminal and see
this huge red output of all

12319
12:28:59.448 --> 12:29:03.448
these things that are untracked,
and we don't have any commits

12320
12:29:03.448 --> 12:29:07.449
for, what we can do now is we
can stage all of our code with

12321
12:29:07.449 --> 12:29:11.449
git add period, and then commit
it with Git commit, we're going

12322
12:29:11.449 --> 12:29:14.449
to run these one at a time
instead of together. Before I

12323
12:29:14.449 --> 12:29:17.449
run git add, I'm going to add
deployments to this list too,

12324
12:29:17.449 --> 12:29:19.449
because GitHub doesn't really
need to know about all the

12325
12:29:19.449 --> 12:29:22.449
different deployments I make,
especially when I make a ton of

12326
12:29:22.449 --> 12:29:24.449
deployments to my local hosts,
they don't need to know. So

12327
12:29:24.449 --> 12:29:29.449
we're going to add that to, then
we're going to run git add dot.

12328
12:29:29.449 --> 12:29:34.449
And if we do a git status, now,
we can see all of our code has

12329
12:29:34.449 --> 12:29:38.449
been staged for being committed
for being a part of this history

12330
12:29:38.449 --> 12:29:41.449
of our code. And then take a
quick look at all these files

12331
12:29:41.449 --> 12:29:46.449
and make sure your dot E and V
file is not and never in here.

12332
12:29:46.449 --> 12:29:49.449
So now we're going to run git
commit dash m and then this

12333
12:29:49.449 --> 12:29:55.449
message for our commit, okay, so
we'll run git commit dash m, we

12334
12:29:55.449 --> 12:29:59.449
can say, initial commit, or
whatever you want in this

12335
12:29:59.449 --> 12:30:01.449
message here, first commit,
initial commit, who cares, and

12336
12:30:02.449 --> 12:30:04.449
it's gonna say, create mode,
blah, blah, blah, for all of

12337
12:30:04.449 --> 12:30:08.449
these files. And if we do git
status, now, it's blank on

12338
12:30:08.449 --> 12:30:11.449
branch main, nothing to commit.
And then you might get something

12339
12:30:11.449 --> 12:30:13.449
like this. If you've never
worked with Git before your name

12340
12:30:13.449 --> 12:30:16.449
and email were added
automatically. We're a little

12341
12:30:16.449 --> 12:30:20.449
bit confused here. We'll talk
about this in just a second. So

12342
12:30:20.449 --> 12:30:23.449
next, what we can do is we're
actually going to copy the URL

12343
12:30:23.449 --> 12:30:27.449
of our GitHub repo. So you can
grab that just by copying here

12344
12:30:27.449 --> 12:30:30.449
or right at the top, that URL
right there. And what we're

12345
12:30:30.449 --> 12:30:33.449
going to do is we're going to
add this as a remote repo. To do

12346
12:30:33.449 --> 12:30:39.449
that. We'll do git remote add,
and we'll give this remote repo

12347
12:30:39.449 --> 12:30:44.449
a name. For us. We'll say origin
and then we'll paste that URL

12348
12:30:44.449 --> 12:30:48.450
there. We're now saying the the
origin remote repo is good.

12349
12:30:48.450 --> 12:30:54.450
Gonna be at this URL, we run git
remote dash v, we can see that

12350
12:30:54.450 --> 12:30:58.450
the origin repo for fetching is
at this branch. And the origin

12351
12:30:58.450 --> 12:31:02.450
repo for pushing is also at this
branch. So when we want to get

12352
12:31:02.450 --> 12:31:06.450
new code, a fetch code will
fetch it from here. And if we

12353
12:31:06.450 --> 12:31:09.450
want to push code up, we want to
give code to the GitHub. We'll

12354
12:31:09.450 --> 12:31:13.450
also get it from here. So now
we've set the new remote with

12355
12:31:13.450 --> 12:31:17.450
that remote URL. Now we're going
to actually push the changes to

12356
12:31:17.450 --> 12:31:22.450
github.com. And the way we do
that is with Git push, and we

12357
12:31:22.450 --> 12:31:25.450
pick which remote we want to
push to, and we're going to push

12358
12:31:25.450 --> 12:31:29.450
the origin. And then which
branch we want to push to which

12359
12:31:29.450 --> 12:31:32.450
we're going to push to Maine,
it'll probably prompt you for

12360
12:31:32.450 --> 12:31:34.450
your username and your password,
and maybe your email and

12361
12:31:34.450 --> 12:31:36.450
everything. Now, if
authentication doesn't work for

12362
12:31:36.450 --> 12:31:39.450
you, for some reason, you can
come over to Settings. Or if you

12363
12:31:39.450 --> 12:31:44.450
scroll down to developer
settings, Personal Access Tokens

12364
12:31:44.450 --> 12:31:48.450
and create generate new token,
some token,

12365
12:31:48.450 --> 12:31:52.450
give yourself repo access, write
access, and hit Generate token.

12366
12:31:52.450 --> 12:31:55.450
And try to use this token as
your password. Instead, be sure

12367
12:31:55.450 --> 12:31:58.450
to use the GitHub documentation
and the GitHub discussion

12368
12:31:59.450 --> 12:32:01.450
associated with this course, if
you get lost or if something

12369
12:32:01.450 --> 12:32:05.450
doesn't work, as shown here. But
once it's done, once you add all

12370
12:32:05.450 --> 12:32:08.450
that information in correctly,
you come back to your get up and

12371
12:32:08.450 --> 12:32:11.450
you will have your first GitHub
repo with all the code and

12372
12:32:11.450 --> 12:32:15.450
everything in it like this. And
once you complete this step,

12373
12:32:15.450 --> 12:32:18.450
once you do this, you should
absolutely celebrate. If you

12374
12:32:18.450 --> 12:32:21.450
like, you can shoot a tweet web
three community in the

12375
12:32:21.450 --> 12:32:24.450
blockchain community is
absolutely this collaborative

12376
12:32:24.450 --> 12:32:26.451
space. So Twitter crypto is
where a lot of these people

12377
12:32:26.451 --> 12:32:30.451
congregate to share ideas. So
definitely be sure to celebrate

12378
12:32:30.451 --> 12:32:33.451
and share this and be really,
really excited. And shoot a

12379
12:32:33.451 --> 12:32:35.451
tweet out like this. Give your
friends a high five, share it on

12380
12:32:35.451 --> 12:32:38.451
Twitter, share it on Discord
shared on Reddit, be excited for

12381
12:32:38.451 --> 12:32:41.451
how far you've gotten, we've got
a lot more to go. But by

12382
12:32:41.451 --> 12:32:44.451
completing this part, you have
done fantastically, and I'm so

12383
12:32:44.451 --> 12:32:47.451
excited for you to start the
next section. Now, we're not

12384
12:32:47.451 --> 12:32:50.451
going to go over the TypeScript
addition to this because there's

12385
12:32:50.451 --> 12:32:53.451
nothing really new here.
However, again, if you want to

12386
12:32:53.451 --> 12:32:56.451
see TypeScript, feel free to
jump into the GitHub repository

12387
12:32:56.451 --> 12:33:00.451
associated with this course.

12388
12:33:00.451 --> 12:33:03.451
Alright, awesome. You've just
completed Lesson Seven, the

12389
12:33:03.451 --> 12:33:07.451
heart had fun me. And now it's
time to move on to lesson eight,

12390
12:33:07.451 --> 12:33:11.451
which is going to be our HTML
slash JavaScript to fund me, you

12391
12:33:11.451 --> 12:33:13.451
can find all the code for what
we're about to go through, of

12392
12:33:13.451 --> 12:33:16.451
course, on my GitHub repo. And
for this section, we're now

12393
12:33:16.451 --> 12:33:20.451
going to start to see some of
the differences between Node js

12394
12:33:20.451 --> 12:33:23.451
between that back end
JavaScript, and JavaScript in

12395
12:33:23.451 --> 12:33:25.451
the browser or front end
JavaScript. And if you come to

12396
12:33:25.451 --> 12:33:28.451
the GitHub repo associated with
this lesson, our main version

12397
12:33:28.451 --> 12:33:32.451
we'll be using what's considered
better front end JavaScript. But

12398
12:33:32.451 --> 12:33:36.451
we'll also have a no JS
addition, as well, if some of

12399
12:33:36.451 --> 12:33:38.451
the front end JavaScript is
really confusing, and you'll see

12400
12:33:38.451 --> 12:33:41.451
what I mean with some of those
differences very soon. Now,

12401
12:33:41.451 --> 12:33:43.451
people can programmatically
interact with our smart

12402
12:33:43.451 --> 12:33:47.451
contracts at any time. However,
most of our users are not

12403
12:33:47.451 --> 12:33:49.451
compete developers. So we need
to create a website, we need to

12404
12:33:49.451 --> 12:33:52.451
create a user interface for them
to interact with our smart

12405
12:33:52.451 --> 12:33:55.451
contracts and interact with our
protocols. And that's what this

12406
12:33:55.451 --> 12:33:57.451
section is going to teach us,
it's going to be an introduction

12407
12:33:57.451 --> 12:34:00.451
to building these fullstack.
building these front ends on top

12408
12:34:00.451 --> 12:34:03.451
of our smart contracts. Now, I
wanted to show you what this is

12409
12:34:03.451 --> 12:34:06.452
actually going to look like when
we finish it. Because here,

12410
12:34:06.452 --> 12:34:09.452
we're actually going to make our
first front end our first

12411
12:34:09.452 --> 12:34:12.452
website using the blockchain
using web three. And it's going

12412
12:34:12.452 --> 12:34:15.452
to be an incredibly minimalistic
website. As you can see right

12413
12:34:16.452 --> 12:34:18.452
here, we're not going to have
any styling, we're just going to

12414
12:34:18.452 --> 12:34:21.452
show you how to get the
functionality. And additionally,

12415
12:34:21.452 --> 12:34:23.452
we're going to do a couple of
things that aren't really

12416
12:34:23.452 --> 12:34:27.452
recommended and are definitely
not best practices. The reason

12417
12:34:27.452 --> 12:34:29.452
we're going to do it like this
is the same reason that in math

12418
12:34:29.452 --> 12:34:31.452
class, before you learn the
tricks for derivatives, you

12419
12:34:31.452 --> 12:34:34.452
learn what a derivative actually
is. We're teaching it like this

12420
12:34:34.452 --> 12:34:37.452
first, so that you can
understand what's going on on

12421
12:34:37.452 --> 12:34:39.452
the websites when you interact
with them. And when you work

12422
12:34:39.452 --> 12:34:42.452
with them. We saw already with
Foston, touching the link where

12423
12:34:42.452 --> 12:34:45.452
we can connect our wallets and
we can work with the faucets.

12424
12:34:45.452 --> 12:34:48.452
All decentralized applications
have this website and have this

12425
12:34:48.452 --> 12:34:50.452
setup where you connect your
wallet and then you interact by

12426
12:34:50.452 --> 12:34:53.452
clicking buttons, which make
these function calls to the

12427
12:34:53.452 --> 12:34:56.452
blockchain. And here's going to
be our minimalistic website that

12428
12:34:56.452 --> 12:34:59.452
does exactly that. So this
section is just going to teach

12429
12:34:59.452 --> 12:35:01.452
you what's going on under the
hood. So you can really

12430
12:35:01.452 --> 12:35:04.452
understand how to build these
applications at a professional

12431
12:35:04.452 --> 12:35:07.452
level. So for this section, if
you don't want to code along

12432
12:35:07.452 --> 12:35:10.452
with me, you definitely don't
have to however, coding along

12433
12:35:10.452 --> 12:35:13.452
with me will definitely ingrain
everything in your memory here.

12434
12:35:13.452 --> 12:35:17.452
So here's what an application is
going to look like. We have our

12435
12:35:17.452 --> 12:35:20.452
website here, which is connected
to our hard hat, our local

12436
12:35:20.452 --> 12:35:24.452
blockchain, but it's gonna run
exactly the same as if it was on

12437
12:35:24.452 --> 12:35:27.452
a real test net, the first thing
you'll notice is in our meta

12438
12:35:27.452 --> 12:35:31.452
mask, we are not connected. And
we'll go ahead and hit Connect,

12439
12:35:31.452 --> 12:35:34.452
and meta masks will pop up
asking us if we want to connect,

12440
12:35:34.452 --> 12:35:38.452
we'll go ahead and connect to
it. And now we'll be able to

12441
12:35:38.452 --> 12:35:40.452
interact with our heart at
Funmi. You'll notice two buttons

12442
12:35:40.452 --> 12:35:43.452
here are functions that we're
familiar with, we have our

12443
12:35:43.452 --> 12:35:45.452
withdrawal function, which is
going to be our withdrawal

12444
12:35:45.452 --> 12:35:48.453
function that we just created.
And then of course, we also have

12445
12:35:48.453 --> 12:35:52.453
our fund function here where we
push or we send Aetherium or

12446
12:35:52.453 --> 12:35:56.453
Matic or whatever, native
blockchain token to our smart

12447
12:35:56.453 --> 12:35:58.453
contract. So we can do it
through this user interface. So

12448
12:35:58.453 --> 12:36:01.453
once we're connected, if we want
to see the balance, we can

12449
12:36:01.453 --> 12:36:04.453
actually right click, hit
Inspect, come over to our

12450
12:36:04.453 --> 12:36:08.453
console. And we'll print out to
the JavaScript console, the

12451
12:36:08.453 --> 12:36:12.453
current balance of our smart
contract. So nobody has funded

12452
12:36:12.453 --> 12:36:15.453
this yet, we can come down, we
can choose an amount we want to

12453
12:36:15.453 --> 12:36:19.453
fund. So for example, maybe 0.1,
eath, we'll go ahead, we'll hit

12454
12:36:19.453 --> 12:36:22.453
fund, meta masks will pop up,
we'll get a little council

12455
12:36:22.453 --> 12:36:25.453
saying funding with 0.1. And
it'll give us all the

12456
12:36:25.453 --> 12:36:30.453
transaction details that we need
to send 0.1 eath, to our smart

12457
12:36:30.453 --> 12:36:33.453
contract, we can go ahead and
hit Confirm. And after it's been

12458
12:36:33.453 --> 12:36:36.453
confirmed after it's been mined
on our local blockchain, we had

12459
12:36:36.453 --> 12:36:41.453
get balance, we now see that
it's 0.1. We could call fund

12460
12:36:41.453 --> 12:36:44.453
again, we could have multiple
funders, we could switch between

12461
12:36:44.453 --> 12:36:46.453
different accounts and fund with
different amounts. And we can

12462
12:36:46.453 --> 12:36:49.453
see that funding amount
increase, then we can call the

12463
12:36:49.453 --> 12:36:52.453
withdrawal function. As long as
we're the owner, we can confirm

12464
12:36:52.453 --> 12:36:54.453
and we can pull out all the
money out of our funding

12465
12:36:54.453 --> 12:36:57.453
contract. And we'll get balance.
Now we'll see the balance is

12466
12:36:57.453 --> 12:37:00.453
reset to zero. So this is what
we're going to be building. Are

12467
12:37:00.453 --> 12:37:01.453
you ready? I sure am.

12468
12:37:01.453 --> 12:37:04.453
Let's get into it. This is the
introduction to building

12469
12:37:04.453 --> 12:37:07.453
websites with web three. All the
information here is available in

12470
12:37:07.453 --> 12:37:10.453
our GitHub repo, so feel free to
follow along there. Alright, so

12471
12:37:10.453 --> 12:37:14.453
if you're in your heart head
Funmi dash Free Code Camp repo,

12472
12:37:14.453 --> 12:37:17.453
we're still going to want to
have this open as well. But

12473
12:37:17.453 --> 12:37:20.453
we're also going to want to
create a new Visual Studio code

12474
12:37:20.453 --> 12:37:24.453
for working with our new repo.
So let's go ahead and CD down a

12475
12:37:24.453 --> 12:37:32.454
directory. We'll type MK dir,
we'll call this HTML, Fund Me

12476
12:37:32.454 --> 12:37:36.454
Free Code Camp. We'll cd into
that. And we'll open this up by

12477
12:37:36.454 --> 12:37:40.454
typing code period. You can also
do File Open Folder, but we just

12478
12:37:40.454 --> 12:37:45.454
want to open this up in a new
Visual Studio Code. New VS code

12479
12:37:45.454 --> 12:37:49.454
will pop up but before we flip
over to that, we do want to CD

12480
12:37:49.454 --> 12:37:54.454
down CD back into hard hat fun
we Free Code Camp because we are

12481
12:37:54.454 --> 12:37:57.454
still going to use everything in
here. We're still going to

12482
12:37:57.454 --> 12:38:01.454
deploy In a smart contract using
this folder and using this repo,

12483
12:38:01.454 --> 12:38:04.454
when you're building daps, or
websites that are connected to

12484
12:38:04.454 --> 12:38:08.454
the blockchain, you'll usually
have two repositories or repos.

12485
12:38:08.454 --> 12:38:10.454
One is going to be for the smart
contracts, like what we see

12486
12:38:10.454 --> 12:38:13.454
here. This is our repo that has
all the code for our smart

12487
12:38:13.454 --> 12:38:16.454
contracts. And then you'll also
have one for the front end slash

12488
12:38:16.454 --> 12:38:18.454
website. And it's going to be
the combination of these two

12489
12:38:18.454 --> 12:38:22.454
repos, which makes up the full
stack. So when people are

12490
12:38:22.454 --> 12:38:25.454
talking about full stack,
they're talking about the smart

12491
12:38:25.454 --> 12:38:31.454
contracts, which is going to be
our back end, plus, plus our

12492
12:38:31.454 --> 12:38:36.454
HTML slash JavaScript slash
website stuff, which is going to

12493
12:38:36.454 --> 12:38:39.454
be our front end. So smart
contracts are the back end, HTML

12494
12:38:39.454 --> 12:38:42.454
slash JavaScript slash website
stuff is going to be our front

12495
12:38:42.454 --> 12:38:45.454
end. So we have our back end
already. And now we're going to

12496
12:38:45.454 --> 12:38:48.454
build our front end, we want to
keep this up because we're going

12497
12:38:48.454 --> 12:38:52.454
to need it to test and interact
with our front end. Awesome. So

12498
12:38:52.454 --> 12:38:56.454
we have this new folder now,
HTML Funmi, Free Code Camp. Now

12499
12:38:56.454 --> 12:38:59.454
this course is not a how to
learn front end course, we are

12500
12:38:59.454 --> 12:39:02.454
going to teach you a number of
front end concepts. But if you

12501
12:39:02.454 --> 12:39:06.455
want to learn a full traditional
front end course, once again,

12502
12:39:06.455 --> 12:39:08.455
you can check out Free Code
Camp, they've got a ton of

12503
12:39:08.455 --> 12:39:11.455
fantastic tutorials, I'm
teaching you front end, if you

12504
12:39:11.455 --> 12:39:13.455
go ahead and follow along with
me, though, you'll definitely

12505
12:39:13.455 --> 12:39:17.455
get a basic understanding of
front end as well as front ends

12506
12:39:17.455 --> 12:39:19.455
and how it relates to our smart
contracts. Additionally, you

12507
12:39:19.455 --> 12:39:22.455
don't have to do the front end
parts or the full stack parts.

12508
12:39:22.455 --> 12:39:25.455
If you only want to take this
course, to learn back end and to

12509
12:39:25.455 --> 12:39:28.455
learn JavaScript, and to learn
solidity and learn how to do

12510
12:39:28.455 --> 12:39:31.455
these smart contracts
programmatically, then you can

12511
12:39:31.455 --> 12:39:34.455
absolutely skip these front end
parts. However, if you want to

12512
12:39:34.455 --> 12:39:36.455
learn to build exciting
websites, and you want to have

12513
12:39:36.455 --> 12:39:39.455
other people other than
developers interact with your

12514
12:39:39.455 --> 12:39:41.455
protocols, you definitely want
to watch this part. Now before

12515
12:39:41.455 --> 12:39:44.455
we actually jump in here and
start writing our code. We need

12516
12:39:44.455 --> 12:39:48.455
to understand what exactly is
going on when work with one of

12517
12:39:48.455 --> 12:39:51.455
these websites that use the
blockchain. So I actually made a

12518
12:39:51.455 --> 12:39:55.455
video about this recently. So
let's watch a segment from that

12519
12:39:55.455 --> 12:39:57.455
really quick, just so that we
can get up to speed with with

12520
12:39:57.455 --> 12:40:00.455
exactly what's going on behind
the scenes of these websites

12521
12:40:00.455 --> 12:40:06.455
that interact with the
blockchain. All right. So here

12522
12:40:06.455 --> 12:40:09.455
we are, with a website or a
front end on top of some smart

12523
12:40:10.455 --> 12:40:12.455
contracts that we've deployed,
doesn't really matter what it is

12524
12:40:12.455 --> 12:40:16.455
right now. This is typically the
interface that you'll see boiled

12525
12:40:16.455 --> 12:40:20.455
down to a really, really
minimalistic level. Typically,

12526
12:40:20.455 --> 12:40:22.455
you'll see something like
connect function, right, and

12527
12:40:22.455 --> 12:40:25.455
Metamask, or some other wallet
connector thing will pop up,

12528
12:40:25.455 --> 12:40:28.455
we'll hit Next we'll connect
here might even say something

12529
12:40:28.455 --> 12:40:30.455
like connected. And we can also
execute functions, we can

12530
12:40:31.455 --> 12:40:33.455
interact with our smart
contracts, we can confirm, etc.

12531
12:40:33.455 --> 12:40:35.455
Right? This is something you
might see something like Avi

12532
12:40:35.455 --> 12:40:39.455
right, I'll hit Connect on the
application, it'll say, hey, how

12533
12:40:39.455 --> 12:40:41.455
would you like to connect? I'll
choose Metamask. I'm going to

12534
12:40:41.455 --> 12:40:45.455
change my Metamask to main net,
but you get the picture, right?

12535
12:40:45.455 --> 12:40:48.456
This is a simple example of what
that would look like. So what is

12536
12:40:48.456 --> 12:40:52.456
actually going on in the browser
when we connect what is actually

12537
12:40:52.456 --> 12:40:55.456
going on? And what do we
actually need to do, we're going

12538
12:40:55.456 --> 12:40:59.456
to right click, hit Inspect. And
on the right side, we're gonna

12539
12:40:59.456 --> 12:41:04.456
see our debugger here. Now if we
go over to sources, on the top

12540
12:41:04.456 --> 12:41:09.456
of our browser, you'll see a few
things. If you look down over

12541
12:41:09.456 --> 12:41:14.456
here, right, we'll see this URL,
right, which right now is going

12542
12:41:14.456 --> 12:41:18.456
to be my localhost. And we'll
also see meta mask and Phantom

12543
12:41:18.456 --> 12:41:20.456
and a whole bunch of other
stuff. These other things that

12544
12:41:20.456 --> 12:41:24.456
we see here are going to be
what's injected from our browser

12545
12:41:24.456 --> 12:41:27.456
extensions. The reason we see
this meta mask thing here is

12546
12:41:27.456 --> 12:41:30.456
because I've meta mask
installed, right? The reason I

12547
12:41:30.456 --> 12:41:33.456
see Phantom here is because I
have the Phantom app installed.

12548
12:41:33.456 --> 12:41:37.456
Meta masks, of course, being an
EVM, wallet and Phantom being a

12549
12:41:37.456 --> 12:41:41.456
Solana based wallet. Now what
happens when we have these

12550
12:41:41.456 --> 12:41:45.456
extensions installed is they
automatically get injected into

12551
12:41:45.456 --> 12:41:51.456
a window object in JavaScript,
and in fact, we scroll down

12552
12:41:51.456 --> 12:41:54.456
to here in the console, again,
you can find console, you can

12553
12:41:54.456 --> 12:41:59.456
click here and click anything up
there. And we type in window.

12554
12:41:59.456 --> 12:42:02.456
We'll see we have this big
window object with all this

12555
12:42:02.456 --> 12:42:06.456
stuff, right? This window object
represents this our window

12556
12:42:06.456 --> 12:42:11.456
basically right? Now if we
scroll all the way to the bottom

12557
12:42:11.456 --> 12:42:16.456
and we do window dot Aetherium.
We also see an object here. Now

12558
12:42:16.456 --> 12:42:20.456
this window dot Aetherium object
only exists if you have a meta

12559
12:42:20.456 --> 12:42:25.456
mask or meta mask like browser
or if you want to look at some

12560
12:42:25.456 --> 12:42:30.457
other web three wallet you do
window dot Solana. So Alana

12561
12:42:30.457 --> 12:42:33.457
right and we see this window dot
Solana. Now let's look at a

12562
12:42:33.457 --> 12:42:36.457
browser that doesn't have
Metamask or phantom installed.

12563
12:42:36.457 --> 12:42:38.457
What do you think is going to
happen in the window now let's

12564
12:42:38.457 --> 12:42:41.457
go ahead and right click hit
Inspect. We'll go to the

12565
12:42:41.457 --> 12:42:45.457
console. Now let's see what's
going on in here. If we go to

12566
12:42:45.457 --> 12:42:48.457
sources, we first off we don't
see that Metamask or that Solana

12567
12:42:48.457 --> 12:42:52.457
source here. And if we go to
console, we still see window if

12568
12:42:52.457 --> 12:42:55.457
I let me zoom in a little bit.
We still see window here. But if

12569
12:42:55.457 --> 12:42:59.457
I do window dot Aetherium If we
get nothing, or if I do window

12570
12:42:59.457 --> 12:43:04.457
dot Solana, we also get nothing.
So in order for our browsers to

12571
12:43:04.457 --> 12:43:08.457
know that there's a Metamask, or
that there's a phantom, those

12572
12:43:08.457 --> 12:43:11.457
extensions automatically add
these to our window objects, and

12573
12:43:11.457 --> 12:43:14.457
that's something that we can
check for in our JavaScript. The

12574
12:43:14.457 --> 12:43:17.457
reason these wallets are so
important is built into them

12575
12:43:17.457 --> 12:43:21.457
underneath the hood, they have a
blockchain node connected to

12576
12:43:21.457 --> 12:43:24.457
them. And in order to interact
with the blockchain, we always

12577
12:43:24.457 --> 12:43:28.457
need a note. And you might have
seen URLs from alchemy, or in

12578
12:43:28.457 --> 12:43:32.457
FIRA because you need them to
interact with the blockchain,

12579
12:43:32.457 --> 12:43:35.457
Alchemy, and infura are examples
of third party blockchains that

12580
12:43:35.457 --> 12:43:38.457
you can interact with and
basically rent, right. But you

12581
12:43:38.457 --> 12:43:42.457
need them to create a provider,
or a node to send your

12582
12:43:42.457 --> 12:43:45.457
transactions to. So you could do
it in JavaScript, like something

12583
12:43:45.457 --> 12:43:48.457
like this is the alchemy
documentation where you take

12584
12:43:48.457 --> 12:43:52.457
that alchemy URL, you stick it
into some object and use that to

12585
12:43:52.457 --> 12:43:56.457
send your transaction. This is a
way that you could do it in the

12586
12:43:56.457 --> 12:43:59.457
back end. But on the front end,
what you normally want to use is

12587
12:43:59.457 --> 12:44:03.457
you just want to use the user's
Metamask, or their Solana or

12588
12:44:03.457 --> 12:44:06.458
their wallet as the main wallet.
Now, there are a ton of other

12589
12:44:06.458 --> 12:44:09.458
different types of wallets to
connect, like ledger, mu,

12590
12:44:09.458 --> 12:44:13.458
Coinbase, wallet, connect, etc.
And there are different ways to

12591
12:44:13.458 --> 12:44:17.458
set those up. But they all do
the same thing where they expose

12592
12:44:17.458 --> 12:44:21.458
some URL, they expose some node
under the hood, they give us

12593
12:44:21.458 --> 12:44:25.458
that URL. They give us that
provider. The way metamath Does

12594
12:44:25.458 --> 12:44:30.458
it is with window dot Aetherium.
Boom, this is now our URL. This

12595
12:44:30.458 --> 12:44:35.458
is now our connection. In fact,
if you go up to your Metamask,

12596
12:44:35.458 --> 12:44:42.458
hit the little three dots,
expand view. hit Add Network,

12597
12:44:42.458 --> 12:44:45.458
and then just hit the X so we
can get to networks. You can see

12598
12:44:45.458 --> 12:44:49.458
all of these blockchains that I
have in here all have an RPC

12599
12:44:49.458 --> 12:44:54.458
URL, this the HTTP RPC URL
connection of the blockchain No,

12600
12:44:54.458 --> 12:44:59.458
that's running. I happen to have
one running locally right now.

12601
12:44:59.458 --> 12:45:03.458
All of these also have a node
RPC URL and you can actually see

12602
12:45:03.458 --> 12:45:06.458
them right in your meta mask
right. This is connected to in

12603
12:45:06.458 --> 12:45:10.458
Fira, these are all connected to
in Fira. It's all the exact same

12604
12:45:10.458 --> 12:45:13.458
thing. Meta mask just has a
really nice way of taking that

12605
12:45:13.458 --> 12:45:16.458
URL, sticking it in the browser
for us in this window dot

12606
12:45:16.458 --> 12:45:21.458
Aetherium or window dot Solana
you know or whatever. So this is

12607
12:45:21.458 --> 12:45:23.458
the main thing that we need to
know we need. We always need a

12608
12:45:23.458 --> 12:45:27.458
connection with the blockchain.
And these browser wallets are an

12609
12:45:27.458 --> 12:45:31.458
easy way to do that. Make sense?
Great. Let's take this knowledge

12610
12:45:31.458 --> 12:45:32.458
now. And let's

12611
12:45:32.458 --> 12:45:38.458
apply it. So in here, let's make
a quick readme.md. Just so we

12612
12:45:38.458 --> 12:45:40.458
can talk about what we're going
to be making here. So in this

12613
12:45:40.458 --> 12:45:44.458
section, we're gonna be using
raw HTML slash JavaScript in

12614
12:45:44.458 --> 12:45:47.459
conjunction with our smart
contracts to build this website.

12615
12:45:47.459 --> 12:45:51.459
Later on. We will use next Jas
slash react, which is a more

12616
12:45:52.459 --> 12:45:55.459
modern stack to build our
websites here. But learning

12617
12:45:55.459 --> 12:45:57.459
understanding how to do
everything with HTML and

12618
12:45:57.459 --> 12:46:01.459
JavaScript first, is going to
make our lives a lot easier come

12619
12:46:01.459 --> 12:46:05.459
later on down the road. But as
we know, all websites use HTML

12620
12:46:05.459 --> 12:46:08.459
as kind of their scaffolding for
what they look like. So let's go

12621
12:46:08.459 --> 12:46:12.459
ahead and create our HTML for
our website, we'll call it index

12622
12:46:12.459 --> 12:46:17.459
dot HTML. And this is going to
be the basic scaffolding or the

12623
12:46:17.459 --> 12:46:21.459
basic bones of what our website
is going to look like. Now, in

12624
12:46:21.459 --> 12:46:24.459
VS code, if you go ahead and
just type exclamation mark index

12625
12:46:24.459 --> 12:46:28.459
dot HTML, and you click the
first thing that pops up, it'll

12626
12:46:28.459 --> 12:46:32.459
automatically populate your code
your file here with some basic

12627
12:46:32.459 --> 12:46:36.459
HTML setup. If it doesn't do
this for you, feel free to copy

12628
12:46:36.459 --> 12:46:40.459
paste the basic setup from the
GitHub repository associated

12629
12:46:40.459 --> 12:46:43.459
with this course, we have our
doctype. HTML, we have some HTML

12630
12:46:43.459 --> 12:46:46.459
tags telling us that everything
in between here is going to be

12631
12:46:46.459 --> 12:46:49.459
an HTML, which is great.
However, for simplicity, we

12632
12:46:49.459 --> 12:46:51.459
don't need most of this. So
we're going to make this a

12633
12:46:51.459 --> 12:46:54.459
little bit easier. We're going
to delete this line, this line

12634
12:46:54.459 --> 12:46:57.459
and this line. And we're just
going to change the title to

12635
12:46:57.459 --> 12:47:01.459
fund me app. And then inside of
our body, we can do something

12636
12:47:01.459 --> 12:47:05.459
like or Hello. And now we have
the bare bones to create a

12637
12:47:05.459 --> 12:47:09.459
website just with this. Now to
show this on a website, we can

12638
12:47:09.459 --> 12:47:12.459
do one of two things. If you are
using Visual Studio code, I'm

12639
12:47:12.459 --> 12:47:16.459
going to recommend you install
the extension live server. And

12640
12:47:16.459 --> 12:47:18.459
it looks like this. And I'll
have the extension ID for this

12641
12:47:18.459 --> 12:47:21.459
extension in the GitHub
repository associated with this

12642
12:47:21.459 --> 12:47:23.459
course, this is going to allow
us to easily spin up an HTML

12643
12:47:23.459 --> 12:47:27.460
website. So we'll go ahead and
install this. And if you're not

12644
12:47:27.460 --> 12:47:29.460
using Visual Studio Code, I'll
show you a different way in just

12645
12:47:29.460 --> 12:47:33.460
a second. Once this is
installed, you should have this

12646
12:47:33.460 --> 12:47:36.460
little go live button at the
bottom. And if you don't, you

12647
12:47:36.460 --> 12:47:39.460
can always open up your command
palette, which again, you can

12648
12:47:39.460 --> 12:47:43.460
open up by hitting View command
palette, and you can type in

12649
12:47:43.460 --> 12:47:46.460
live server and just say open
with live server but we're going

12650
12:47:46.460 --> 12:47:49.460
to just click this go live
button. And it's going to say

12651
12:47:49.460 --> 12:47:53.460
starting and it's actually going
to open up your browser with our

12652
12:47:53.460 --> 12:47:57.460
index dot HTML. We can actually
see our website is being called

12653
12:47:57.460 --> 12:48:02.460
Save on 120 7.0 point 0.1. This
is known as the loopback, or

12654
12:48:02.460 --> 12:48:06.460
local host endpoint, we're on
port 5501. If you're not

12655
12:48:06.460 --> 12:48:09.460
familiar with the ports, don't
worry about that for now, we

12656
12:48:09.460 --> 12:48:12.460
have our index dot HTML here.
And if we change this to

12657
12:48:12.460 --> 12:48:16.460
something like what's good, we
hit save. If it doesn't

12658
12:48:16.460 --> 12:48:19.460
automatically refresh, we'd come
over here and refresh. And we'd

12659
12:48:19.460 --> 12:48:21.460
see that being reflected here.
If you've never created a

12660
12:48:21.460 --> 12:48:24.460
website before, you've
essentially just done it,

12661
12:48:24.460 --> 12:48:28.460
congratulations, you might get
this.vs code folder. a.vs code

12662
12:48:28.460 --> 12:48:32.460
folder allows you to make
settings specifically for the

12663
12:48:32.460 --> 12:48:35.460
repo that you're working with,
for your code editor for VS

12664
12:48:35.460 --> 12:48:38.460
code, but we're going to mostly
ignore it for now. Now, if

12665
12:48:38.460 --> 12:48:41.460
you're not using Visual Studio
Code, what you can do is you can

12666
12:48:41.460 --> 12:48:45.460
just run this in the browser. So
one thing you could do is you

12667
12:48:45.460 --> 12:48:48.460
could right click it, and I'm
using a Mac. So I'm going to hit

12668
12:48:48.460 --> 12:48:52.460
Reveal in Finder, aka reveal
where it's located. And you can

12669
12:48:52.460 --> 12:48:54.460
just double click it, and boom,
now it's running right in your

12670
12:48:54.460 --> 12:48:57.460
browser. Instead of pointing to
your localhost, it's going to be

12671
12:48:57.460 --> 12:49:01.460
pointing directly to your local
file path. Now one final version

12672
12:49:01.460 --> 12:49:03.460
that we could do that I'm going
to highly recommend you don't

12673
12:49:03.460 --> 12:49:06.461
do. But it's another option,
we're actually going to download

12674
12:49:06.461 --> 12:49:10.461
a package for you using no Jas,
which allows us to serve up

12675
12:49:10.461 --> 12:49:12.461
HTTP. And we're gonna install it
the exact same way we've

12676
12:49:12.461 --> 12:49:17.461
installed our other packages, we
can do yarn, add dash dash dev

12677
12:49:17.461 --> 12:49:22.461
HTTP hyphen server. And you may
still want to add it anyways.

12678
12:49:22.461 --> 12:49:26.461
But now, we'll get some node
modules for this HTTP server

12679
12:49:26.461 --> 12:49:30.461
package, we'll get a package
json, and of course, a yarn dot

12680
12:49:30.461 --> 12:49:34.461
lock as well. And what we can do
is we can stop this down here,

12681
12:49:34.461 --> 12:49:37.461
stop that live server. And if we
go back to our website, refresh,

12682
12:49:37.461 --> 12:49:42.461
it'll now be blank. And we can
run yarn HTTP server. And this

12683
12:49:42.461 --> 12:49:45.461
will do the exact same thing.
And we get, and if we come over,

12684
12:49:45.461 --> 12:49:49.461
and we refresh, we'll see what's
good. Now this one is a little

12685
12:49:49.461 --> 12:49:52.461
bit more finicky. And after you
make a change, like, Hey, what's

12686
12:49:52.461 --> 12:49:56.461
good, you might have to close
it, and then reopen it and then

12687
12:49:56.461 --> 12:50:00.461
refresh. So I do recommend that
if you're on Visual Studio code,

12688
12:50:00.461 --> 12:50:02.461
you definitely just use this
little go live button, because

12689
12:50:02.461 --> 12:50:04.461
it'll reflect your changes a lot
nicer.

12690
12:50:04.461 --> 12:50:06.461
So let's go ahead and hit the Go
Live button. Hey, what's good

12691
12:50:07.461 --> 12:50:12.461
pops up. Okay, cool. Our HTML is
working perfectly.

12692
12:50:12.461 --> 12:50:15.461
So the title, of course, is
going to be the Funmi app, which

12693
12:50:15.461 --> 12:50:19.461
we see up here in the title
section. So let's update this

12694
12:50:19.461 --> 12:50:22.461
HTML, so that it has those
buttons, and it can actually

12695
12:50:22.461 --> 12:50:25.461
connect and work with our
blockchain and work with any

12696
12:50:25.461 --> 12:50:27.461
blockchain. Something else that
you can do in HTML is you can

12697
12:50:27.461 --> 12:50:31.461
actually write JavaScript inside
your HTML. And the way we can do

12698
12:50:31.461 --> 12:50:35.461
that is by doing this script
tag, and then we'll do a closing

12699
12:50:35.461 --> 12:50:39.461
script tag. And anything inside
here inside of our script tags

12700
12:50:39.461 --> 12:50:42.461
is going to be JavaScript. So I
could do something like console

12701
12:50:42.461 --> 12:50:46.462
dot log, hi, with a bunch of
exclamation marks, I'm going to

12702
12:50:46.462 --> 12:50:49.462
save it. We'll go back to our
front end, we're going to right

12703
12:50:49.462 --> 12:50:53.462
click, we'll hit Inspect, we'll
go to the console. And we can

12704
12:50:53.462 --> 12:50:56.462
see that Hi prints it out, we
refresh, we can see the hi

12705
12:50:56.462 --> 12:51:00.462
consistently printed out hi from
script tag, we'll save it, we'll

12706
12:51:00.462 --> 12:51:03.462
move back, we see hi from script
tag printed out. I know it's a

12707
12:51:04.462 --> 12:51:08.462
little bit small. So let me zoom
in. Alright, great. So we can

12708
12:51:08.462 --> 12:51:12.462
type our JavaScript in here,
it's inside the script tag is

12709
12:51:12.462 --> 12:51:14.462
where we're going to write our
JavaScript to write the

12710
12:51:14.462 --> 12:51:17.462
functions that our front end is
going to interact with. Now, as

12711
12:51:17.462 --> 12:51:21.462
we saw before, in this little
console, we can check for window

12712
12:51:21.462 --> 12:51:26.462
dot Etherium, to see if Metamask
or is installed. And again, a

12713
12:51:26.462 --> 12:51:28.462
lot of what we're working with
is actually right in the

12714
12:51:28.462 --> 12:51:31.462
Metamask documentation. If you
go to their basic section, they

12715
12:51:31.462 --> 12:51:34.462
talk a little bit about the
provider, which is this window

12716
12:51:34.462 --> 12:51:37.462
dot Aetherium, you can read how
to actually interact directly

12717
12:51:37.462 --> 12:51:41.462
with meta mask in the meta mask
documentation as well. Now using

12718
12:51:41.462 --> 12:51:43.462
window dot Aetherium is just one
of the ways we're actually going

12719
12:51:43.462 --> 12:51:45.462
to connect to the blockchain,
there's actually multiple ways

12720
12:51:46.462 --> 12:51:48.462
because there's multiple
different kinds of wallets out

12721
12:51:48.462 --> 12:51:50.462
there. But for now, we're just
going to pretend that window dot

12722
12:51:50.462 --> 12:51:54.462
Aetherium and meta mask is the
only extension out there. So

12723
12:51:54.462 --> 12:51:56.462
what we want to do is we want to
check to see if this wind of

12724
12:51:56.462 --> 12:51:59.462
that Aetherium exists. This is
the first thing that we should

12725
12:51:59.462 --> 12:52:02.462
be doing. Because if this
doesn't exist, this means that

12726
12:52:02.462 --> 12:52:04.462
they can't connect to the
blockchain, one of the first

12727
12:52:04.462 --> 12:52:06.462
things that we're going to want
to do is we're going to want to

12728
12:52:06.462 --> 12:52:10.462
check to see if that exists. So
we can do something like if we

12729
12:52:10.462 --> 12:52:17.462
can say type of window that
Aetherium does not equal,

12730
12:52:17.462 --> 12:52:23.462
undefined. Then we'll do console
dot log, I see a meta mask. So

12731
12:52:23.462 --> 12:52:27.463
now if we save, we come back to
our front end, we do see I see a

12732
12:52:27.463 --> 12:52:31.463
Metamask. I've got a Google
Chrome up without Metamask that

12733
12:52:31.463 --> 12:52:35.463
if we look in the console, and
we hit refresh it the same URL

12734
12:52:35.463 --> 12:52:39.463
where our live server is
running. We don't see that I see

12735
12:52:39.463 --> 12:52:43.463
a meta mask because it doesn't
see a meta mask. We can do else.

12736
12:52:43.463 --> 12:52:49.463
console dot log, no Metamask
refresh, we still see ICD a meta

12737
12:52:49.463 --> 12:52:51.463
mask where we have a meta mask.
You don't have to open up a

12738
12:52:51.463 --> 12:52:54.463
browser without one but we see
no meta mask for Chrome because

12739
12:52:54.463 --> 12:52:57.463
it doesn't see a meta mask. Now
what we could do is We can

12740
12:52:57.463 --> 12:53:02.463
automatically try to connect to
meta mask if we see that there

12741
12:53:02.463 --> 12:53:04.463
is a meta mask, right? Remember
how before, when we hit that

12742
12:53:04.463 --> 12:53:07.463
connect button meta mask popped
up and said, Are you sure you

12743
12:53:07.463 --> 12:53:10.463
want to connect? So what we can
do is, and you can, again, you

12744
12:53:10.463 --> 12:53:13.463
can find this in the meta mask
docs, we can run this eath

12745
12:53:13.463 --> 12:53:17.463
request accounts method, which
is basically going to be how we

12746
12:53:17.463 --> 12:53:22.463
connect our Metamask. Now, this
is specified by a new EIP and an

12747
12:53:22.463 --> 12:53:25.463
older documentations. And in
older tutorials, you might see

12748
12:53:25.463 --> 12:53:27.463
Aetherium dot enable, which
essentially does the exact same

12749
12:53:27.463 --> 12:53:31.463
thing. So what we could do here
is we could say, a cerium, or

12750
12:53:31.463 --> 12:53:36.463
excuse me, window dot Aetherium
dot request. And we could put

12751
12:53:36.463 --> 12:53:43.463
method F request accounts. And
we'll save that. Now if we go

12752
12:53:43.463 --> 12:53:47.463
back to our browser, we'll
actually see, you'll actually

12753
12:53:47.463 --> 12:53:50.463
see Metamask, go ahead and pop
up and say, let's connect so we

12754
12:53:50.463 --> 12:53:54.463
can choose an account. And we'll
hit Connect, will automatically

12755
12:53:54.463 --> 12:53:58.463
connect our meta mask to our
website. And now if we look at

12756
12:53:58.463 --> 12:54:01.463
our meta mask, we can see this
little connected thing. It's

12757
12:54:01.463 --> 12:54:04.463
saying that our account one is
now connected to our website.

12758
12:54:04.463 --> 12:54:08.464
This means that the website can
now make API calls to our meta

12759
12:54:08.464 --> 12:54:12.464
mask, we still have to be the
ones to approve them. But it can

12760
12:54:12.464 --> 12:54:15.464
go ahead and connect and try to
run transactions, which is

12761
12:54:15.464 --> 12:54:18.464
awesome, which is what we want.
If you want to disconnect, we

12762
12:54:18.464 --> 12:54:20.464
can go ahead and click that
little button and hit disconnect

12763
12:54:20.464 --> 12:54:23.464
this account. Well that we have
our code currently is anytime we

12764
12:54:23.464 --> 12:54:26.464
hit refresh, this is going to
pop up which is going to be

12765
12:54:26.464 --> 12:54:29.464
really annoying. So what we're
going to do instead is we're

12766
12:54:29.464 --> 12:54:33.464
going to wrap this up into an
asynchronous function, the exact

12767
12:54:33.464 --> 12:54:36.464
same as we've been doing, we'll
do we'll create an async

12768
12:54:36.464 --> 12:54:40.464
function called Connect. And
we'll wrap it up these curly

12769
12:54:40.464 --> 12:54:43.464
braces here. And then we'll just
format this a little bit to make

12770
12:54:43.464 --> 12:54:47.464
it look nicer. And now if we
save, we go back to our website,

12771
12:54:47.464 --> 12:54:51.464
and we refresh. And we go ahead
and disconnect.

12772
12:54:51.464 --> 12:54:54.464
If we refresh Metamask won't
keep asking us Hey, do you want

12773
12:54:54.464 --> 12:54:56.464
to connect Hey, do you want to
connect here do you want to

12774
12:54:56.464 --> 12:54:58.464
connect, because we need to call
this connect function where we

12775
12:54:58.464 --> 12:55:01.464
can do that is we can add a
little button here. So right

12776
12:55:01.464 --> 12:55:06.464
underneath our script tag, we're
going to add a button tag. So

12777
12:55:06.464 --> 12:55:08.464
this is the opening button tag.
And then here's the closing

12778
12:55:08.464 --> 12:55:12.464
button tag. And inside the
opening button tag declaration,

12779
12:55:12.464 --> 12:55:16.464
we'll give it an ID, which will
be Connect button. And we'll say

12780
12:55:16.464 --> 12:55:23.464
on click equals the Connect
connects function. And we'll

12781
12:55:23.464 --> 12:55:25.464
call this button connect in
between these little button

12782
12:55:25.464 --> 12:55:29.464
tags, we'll call it connect will
say when we click it will call

12783
12:55:29.464 --> 12:55:32.464
the Connect function. So if we
save, and we go back to our

12784
12:55:32.464 --> 12:55:35.464
front end, we can now see we
have a little Connect button.

12785
12:55:35.464 --> 12:55:39.464
And now if we press Connect,
Metamask is going to pop up,

12786
12:55:39.464 --> 12:55:43.464
we'll hit next and connect like
that. And boom, now we are

12787
12:55:43.464 --> 12:55:47.465
connected. And we can even do a
little await here so that we

12788
12:55:47.465 --> 12:55:50.465
wait for this to finish before
moving on. And then after we

12789
12:55:50.465 --> 12:55:56.465
connect, we can say console dot
log connected. So let's actually

12790
12:55:56.465 --> 12:55:59.465
go ahead and test this out,
we'll go back to Metamask. we'll

12791
12:55:59.465 --> 12:56:03.465
disconnect here, try to never be
on Main net if we don't have to

12792
12:56:03.465 --> 12:56:07.465
be. And let's go ahead run
connect, we'll hit Next connect.

12793
12:56:07.465 --> 12:56:10.465
And now we see a little console
dot log come out saying

12794
12:56:10.465 --> 12:56:13.465
connected. Okay, great. We can
also update our website

12795
12:56:13.465 --> 12:56:17.465
accordingly. So that we can let
users know that we're connected.

12796
12:56:17.465 --> 12:56:20.465
So we can grab the connect
button element ID and say that

12797
12:56:20.465 --> 12:56:24.465
we're connected once we're
connected. So after we await to

12798
12:56:24.465 --> 12:56:30.465
be connected, we can go ahead
and do document dot get element

12799
12:56:30.465 --> 12:56:39.465
by ID Connect button. And then
we'll say dot inner HTML equals

12800
12:56:39.465 --> 12:56:42.465
connected like that. And then
instead of saying no minimize

12801
12:56:42.465 --> 12:56:45.465
down here, we'll do just the
opposite. So we'll copy this

12802
12:56:45.465 --> 12:56:51.465
line. And instead of connected,
we'll say please install meta

12803
12:56:51.465 --> 12:56:55.465
mask. And we'll save we'll go
back to our front end, we'll hit

12804
12:56:55.465 --> 12:56:58.465
connect. And now if we're
already connected, it'll just

12805
12:56:58.465 --> 12:57:01.465
automatically go to connected.
If we're not connected, it'll

12806
12:57:01.465 --> 12:57:03.465
pop up, we'll get connected. And
now we have this button that

12807
12:57:03.465 --> 12:57:06.465
says connected, which is great.
So now we already know that

12808
12:57:06.465 --> 12:57:12.465
we're connected. So we've
connected our Metamask to our

12809
12:57:12.465 --> 12:57:15.465
front end. Now we want to
actually go ahead and do some

12810
12:57:15.465 --> 12:57:18.465
functions here. And this is
where we want to create some

12811
12:57:18.465 --> 12:57:21.465
more functions and some more
buttons that are going to use

12812
12:57:21.465 --> 12:57:24.465
ethers that package that we
become so familiar with. Now, as

12813
12:57:24.465 --> 12:57:27.466
we code, our script section is
going to get bigger and bigger

12814
12:57:27.466 --> 12:57:31.466
and bigger. So oftentimes, we
actually want to put our code in

12815
12:57:31.466 --> 12:57:34.466
a JavaScript file itself. So
we're gonna go ahead, come over

12816
12:57:34.466 --> 12:57:37.466
here, we're going to create a
new file, and we'll call it

12817
12:57:37.466 --> 12:57:42.466
index dot j s. And instead of
putting our JavaScript in these

12818
12:57:42.466 --> 12:57:46.466
script tags, we're going to put
it in this index and then import

12819
12:57:46.466 --> 12:57:49.466
this index file into our HTML.
And the way that we're going to

12820
12:57:49.466 --> 12:57:52.466
do that is we're actually just
going to grab this function.

12821
12:57:52.466 --> 12:57:55.466
We're going to copy it, delete
everything for now. We're going

12822
12:57:55.466 --> 12:57:59.466
to paste it into our end ext dot
j s, and then in our index dot

12823
12:57:59.466 --> 12:58:06.466
HTML, we're just going to tell
our script tag to use index.js.

12824
12:58:06.466 --> 12:58:10.466
So we're just going to say the
source is going to be equal to

12825
12:58:10.466 --> 12:58:16.466
dot slash index dot j s. And
then we're going to say, the

12826
12:58:16.466 --> 12:58:21.466
type of this is going to be text
slash JavaScript. Now if we save

12827
12:58:21.466 --> 12:58:25.466
that, and we save our index dot
HTML, we come back to our front

12828
12:58:25.466 --> 12:58:29.466
end, we do a little refresh. And
we make sure that we go ahead

12829
12:58:29.466 --> 12:58:34.466
and disconnect. And we do
another refresh, we can see that

12830
12:58:34.466 --> 12:58:38.466
even with our index.js in a
different file, because we're

12831
12:58:38.466 --> 12:58:42.466
doing src equals index.js, and
we're importing it into our

12832
12:58:42.466 --> 12:58:46.466
HTML, when we hit Connect, it
still calls our Connect

12833
12:58:46.466 --> 12:58:49.466
function. That's how we can kind
of separate our JavaScript into

12834
12:58:49.466 --> 12:58:52.466
its own js file that we're a
little bit more familiar with.

12835
12:58:52.466 --> 12:58:54.466
Now, if you look in the GitHub
repo associated with this

12836
12:58:55.466 --> 12:58:58.466
course, and you look in the
index dot j s, you'll see our

12837
12:58:58.466 --> 12:59:01.466
Connect function, we've added
some quality of life stuff,

12838
12:59:01.466 --> 12:59:05.466
we've added some try catches
just to make handling errors a

12839
12:59:05.466 --> 12:59:08.467
little bit better, you can go
ahead and add those try catches

12840
12:59:08.467 --> 12:59:10.467
in yourself if you'd like. But
I'm not going to demo them in

12841
12:59:10.467 --> 12:59:11.467
this video

12842
12:59:11.467 --> 12:59:36.467
here. Now we want to create our
fun function. And then later on,

12843
12:59:36.467 --> 12:59:39.467
we're going to create our
withdrawal function. And this is

12844
12:59:39.467 --> 12:59:44.467
where front end JavaScript code.
And no Gs are a little bit

12845
12:59:44.467 --> 12:59:48.467
different. In no JS, we've been
using this require keyword to

12846
12:59:48.467 --> 12:59:52.467
import dependencies in front end
JavaScript, you can't use

12847
12:59:52.467 --> 12:59:56.467
require, and it won't exactly
work. Now later on, we're going

12848
12:59:56.467 --> 12:59:59.467
to use the Import keyword, which
is really the better way to do

12849
12:59:59.467 --> 13:00:02.467
this. And this is where our
first differences going to be

12850
13:00:02.467 --> 13:00:06.467
using the Import keyword for
front end is much better than

12851
13:00:06.467 --> 13:00:09.467
the require keyword, especially
since the require keyword

12852
13:00:09.467 --> 13:00:12.467
doesn't actually work. And for
those you who might struggle

12853
13:00:12.467 --> 13:00:15.467
with this disconnect in this
change. Once again, in the

12854
13:00:15.467 --> 13:00:18.467
GitHub repo associated with
this, we do have a Node js

12855
13:00:18.467 --> 13:00:22.467
edition of this, where you can
use the require keyword, you

12856
13:00:22.467 --> 13:00:24.467
just have to go through the
readme and download some

12857
13:00:24.467 --> 13:00:27.467
packages and run some scripts
that basically transform your

12858
13:00:28.467 --> 13:00:32.467
code that uses require into code
that works with imports. But

12859
13:00:32.467 --> 13:00:35.467
we're going to teach you the way
to work with your front end code

12860
13:00:35.467 --> 13:00:38.467
here using imports. Now you'll
see when we get to next Jas that

12861
13:00:38.467 --> 13:00:43.467
we will still download code from
node modules and using a yarn

12862
13:00:43.467 --> 13:00:47.468
lock and a package json etc. So
summary in future seconds, we

12863
13:00:47.468 --> 13:00:51.468
are still going to do yarn add.
But outside of a framework when

12864
13:00:51.468 --> 13:00:55.468
we're using this raw JavaScript,
this raw HTML setup, like what

12865
13:00:55.468 --> 13:00:57.468
we're working with here, we're
not going to be doing yarn, add

12866
13:00:57.468 --> 13:01:00.468
node modules will add node
modules for framework like next

12867
13:01:00.468 --> 13:01:03.468
react. But for raw JavaScript,
we'll be using a different

12868
13:01:03.468 --> 13:01:05.468
syntax, which I'll show you
soon. So let's go ahead and

12869
13:01:05.468 --> 13:01:08.468
start building our fund function
here. To make our fun functions,

12870
13:01:08.468 --> 13:01:11.468
what would we normally do? Well,
we'd create an async function

12871
13:01:11.468 --> 13:01:14.468
called fund. And in this
function, we probably would want

12872
13:01:14.468 --> 13:01:18.468
to take some ether mount as a
parameter, because we're going

12873
13:01:18.468 --> 13:01:21.468
to want to fund it with some
amount of Aetherium. When we

12874
13:01:21.468 --> 13:01:26.468
call this function, we might
want to run console dot log will

12875
13:01:26.468 --> 13:01:32.468
do a little string interpolation
here. Funding with eth amount,

12876
13:01:32.468 --> 13:01:36.468
dot dot dot, these semicolons
are going to drive me absolutely

12877
13:01:36.468 --> 13:01:40.468
insane. So I'm going to add a
our dot prettier dot our rc file

12878
13:01:40.468 --> 13:01:43.468
into this, and I'm going to go
ahead and add prettier in here.

12879
13:01:43.468 --> 13:01:46.468
Otherwise, I'm going to lose my
mind. So we're gonna do yarn add

12880
13:01:46.468 --> 13:01:50.468
dash dash Dev, prettier, just so
we can format our JavaScript

12881
13:01:50.468 --> 13:01:53.468
with prettier come back to
index.js. I'm gonna hit command

12882
13:01:53.468 --> 13:01:55.468
S, and it looks like it does
indeed, auto format with

12883
13:01:55.468 --> 13:02:00.468
prettier now yay, no matter
semicolons, we can call this fun

12884
13:02:00.468 --> 13:02:04.468
function the same way we call
connect. So in in our index dot

12885
13:02:04.468 --> 13:02:08.468
HTML, maybe we'll create a new
button. Button. We'll give it an

12886
13:02:08.468 --> 13:02:18.468
ID of fund will say on click
equals fund. And we'll say fund.

12887
13:02:18.468 --> 13:02:20.468
And this will be our button
here, we save it, we're looking

12888
13:02:20.468 --> 13:02:24.468
at our front end. Now the fund
button that if we call, we say

12889
13:02:24.468 --> 13:02:27.469
funding with undefined because
we're not passing it an amount

12890
13:02:27.469 --> 13:02:31.469
here. So back in our index
console dot log funding with and

12891
13:02:31.469 --> 13:02:33.469
we'll just want to make sure
that we can actually call that

12892
13:02:33.469 --> 13:02:37.469
Funmi function. So we'll copy
this line again and we'll say

12893
13:02:37.469 --> 13:02:40.469
type of window dot Aetherium
does not equal undefined. We'll

12894
13:02:40.469 --> 13:02:43.469
go ahead and try to fund here to
send a transaction. What are the

12895
13:02:43.469 --> 13:02:47.469
things that we absolutely 100%
Always need? Well, we need a

12896
13:02:47.469 --> 13:02:51.469
provider slash connection to the
blockchain. And we need a signer

12897
13:02:51.469 --> 13:02:57.469
slash wallet, slash someone with
some gas to actually send it and

12898
13:02:57.469 --> 13:03:01.469
then And we're probably going to
need the contract that we are

12899
13:03:01.469 --> 13:03:04.469
interacting with. And to get
that contract, we're going to

12900
13:03:04.469 --> 13:03:08.469
need ABI and address. And with
these all together, we can send

12901
13:03:08.469 --> 13:03:11.469
any transaction. So to get our
provider, we're going to

12902
13:03:11.469 --> 13:03:14.469
actually go ahead and work with
ethers again. Now, we're going

12903
13:03:14.469 --> 13:03:17.469
to do it a little bit
differently, though, before, the

12904
13:03:17.469 --> 13:03:23.469
way we worked with ethers is we
said const ethers equals require

12905
13:03:23.469 --> 13:03:27.469
ethers, right. And this is how
we pulled ethers. And now like I

12906
13:03:27.469 --> 13:03:30.469
just said to you, though,
require doesn't work in the

12907
13:03:30.469 --> 13:03:33.469
front end. And we actually don't
want to install ethers with a

12908
13:03:33.469 --> 13:03:37.469
node modules package. So what we
can actually do instead is let's

12909
13:03:37.469 --> 13:03:41.469
go to the ethers documentation.
If you go to the Getting Started

12910
13:03:41.469 --> 13:03:46.469
section, scroll down, they have
a section about importing using

12911
13:03:46.469 --> 13:03:51.469
Node js, which uses require or
imports. And then they also have

12912
13:03:51.469 --> 13:03:55.469
some documentation for working
with the web browser. So instead

12913
13:03:55.469 --> 13:03:59.469
of us doing a node module, what
we'll do is we'll copy the

12914
13:03:59.469 --> 13:04:02.469
ethers library to our own
directories and serve it

12915
13:04:02.469 --> 13:04:06.469
ourselves. So what we do is we
can come in here, we can copy

12916
13:04:06.469 --> 13:04:10.470
this massive file, which is
ethers, but in front end

12917
13:04:10.470 --> 13:04:14.470
addition, and come back to our
file. And we'll make a new file

12918
13:04:14.470 --> 13:04:16.470
in here.

12919
13:04:16.470 --> 13:04:24.470
Called ethers. We'll do 5.6
point esm.min.js. And we'll

12920
13:04:24.470 --> 13:04:28.470
paste that massive thing in
here. Now, since I have prettier

12921
13:04:28.470 --> 13:04:31.470
when I save it, it's going to
auto format. And it's just this

12922
13:04:31.470 --> 13:04:37.470
huge file, which has everything
ethers, but front end defied if

12923
13:04:37.470 --> 13:04:41.470
you will. Now what we can do is
we can import this into our

12924
13:04:41.470 --> 13:04:46.470
index.js. So instead of using
require in here, we'll say

12925
13:04:46.470 --> 13:04:51.470
import ethers from and then
we'll just refer to that file

12926
13:04:51.470 --> 13:05:00.470
that we just got ethers dash 5.6
point esm.min.js. Now, we only

12927
13:05:00.470 --> 13:05:05.470
need to do this weird copy
pasting of the file import thing

12928
13:05:05.470 --> 13:05:09.470
in this HTML JavaScript lesson.
In future lessons with Node js,

12929
13:05:09.470 --> 13:05:12.470
we are going to do yarn, add
ethers, kinda like we've

12930
13:05:12.470 --> 13:05:15.470
normally seen. The frameworks
like React and next Jas that

12931
13:05:15.470 --> 13:05:19.470
we're going to use are going to
automatically convert those yarn

12932
13:05:19.470 --> 13:05:23.470
added packages to their front
end to five versions. But for

12933
13:05:23.470 --> 13:05:25.470
this section, this is how we're
going to actually import the

12934
13:05:25.470 --> 13:05:29.470
ethers package. Now the other
thing we'll have to do is on our

12935
13:05:29.470 --> 13:05:34.470
front end, we'll have to change
this from type text slash

12936
13:05:34.470 --> 13:05:39.470
JavaScript to type module
changes. The type module allows

12937
13:05:39.470 --> 13:05:42.470
us to import modules into our
code, which we're going to be

12938
13:05:42.470 --> 13:05:45.470
importing this, and we're going
to import another module as

12939
13:05:45.470 --> 13:05:50.471
well. Awesome. And now though,
if we go back to our front end,

12940
13:05:50.471 --> 13:05:53.471
do a little refresh with the
connect button, we get Connect

12941
13:05:53.471 --> 13:05:57.471
is not defined at HTML
button.on. Click, so instead of

12942
13:05:57.471 --> 13:06:00.471
calling our Connect button from
the front end here, we're going

12943
13:06:00.471 --> 13:06:05.471
to remove these on clicks from
our index dot HTML, and go into

12944
13:06:05.471 --> 13:06:10.471
our index.js and add those
connect buttons in here. So

12945
13:06:10.471 --> 13:06:18.471
we'll say const. Connect button
equals document, dot get element

12946
13:06:18.471 --> 13:06:27.471
by ID, Connect button. And then
we'll say const. One button

12947
13:06:27.471 --> 13:06:35.471
equals Doc, you meant dot get
element by ID. One button, the

12948
13:06:35.471 --> 13:06:37.471
idea of the connect button is
Connect button. The idea the fun

12949
13:06:37.471 --> 13:06:43.471
button is fun button. And then
we'll say connect button.on

12950
13:06:43.471 --> 13:06:53.471
Click equals connect. And one
button.on Click equals fond. We

12951
13:06:53.471 --> 13:06:56.471
go back to our front end, do a
little refresh. We'll hit

12952
13:06:56.471 --> 13:06:59.471
connect now. And it's actually
working, we'll go to our

12953
13:06:59.471 --> 13:07:05.471
Metamask will disconnect,
refresh, hit Connect, and boom,

12954
13:07:05.471 --> 13:07:08.471
it's popping up again. This is
just due to that type being

12955
13:07:08.471 --> 13:07:12.471
module, if it was text slash
JavaScript, that on click button

12956
13:07:12.471 --> 13:07:15.471
adding in here, but since we're
doing module, we're going to add

12957
13:07:15.471 --> 13:07:17.471
those on clicks right in our
JavaScript. But now that we've

12958
13:07:17.471 --> 13:07:20.471
got ethers in here, what we can
do is we can even do like a

12959
13:07:20.471 --> 13:07:25.471
little console dot log, just
paste ethers in here, or

12960
13:07:25.471 --> 13:07:28.472
actually better yet. We'll add
it right above the Connect

12961
13:07:28.472 --> 13:07:31.472
button. Go back to our front
end, we'll do a refresh and we

12962
13:07:31.472 --> 13:07:35.472
see the entire ethers object
right in our front end which is

12963
13:07:35.472 --> 13:07:38.472
perfect, which is exactly what
we want here. And since we've

12964
13:07:38.472 --> 13:07:42.472
got these two variables here, we
might as well update this to

12965
13:07:43.472 --> 13:07:47.472
just say connect button dot
innerHTML equals connected and

12966
13:07:47.472 --> 13:07:50.472
here as well. Connects button
dot innerHTML equals please

12967
13:07:50.472 --> 13:07:53.472
install meta mask because now
connect button is going to be

12968
13:07:53.472 --> 13:07:56.472
the same as running this
document dot get element by ID

12969
13:07:56.472 --> 13:07:56.472
right

12970
13:07:56.472 --> 13:08:03.472
here. and great. Let's go back
to continuing our font function.

12971
13:08:03.472 --> 13:08:09.472
So we'll say const provider
equals new ethers dot providers

12972
13:08:09.472 --> 13:08:14.472
dot web three provider, window
dot Aetherium. Web three

12973
13:08:14.472 --> 13:08:18.472
provider is an object in ethers
that allows us to basically wrap

12974
13:08:18.472 --> 13:08:21.472
around stuff like Metamask is
web three provider is really

12975
13:08:22.472 --> 13:08:25.472
similar to that JSON RPC
provider, which we use before,

12976
13:08:25.472 --> 13:08:30.472
which is where we put in exactly
that endpoint, our alchemy

12977
13:08:30.472 --> 13:08:33.472
endpoint, or when we're working
with Metamask. Here, whatever

12978
13:08:33.472 --> 13:08:36.472
endpoint that we have in our
network section is web three

12979
13:08:36.472 --> 13:08:40.472
provider takes that HTTP
endpoint and automatically

12980
13:08:40.472 --> 13:08:44.472
sticks it in ethers for us. So
this line of code basically

12981
13:08:44.472 --> 13:08:47.472
looks at our Metamask and goes,
Ah, okay, I found the HTTP

12982
13:08:47.472 --> 13:08:50.472
endpoint inside there, Metamask.
That's going to be what we're

12983
13:08:50.472 --> 13:08:53.472
going to use as our provider
here. Since our provider is

12984
13:08:53.472 --> 13:08:57.472
connected to our Metamask. Here,
we can get a signer or we can

12985
13:08:57.472 --> 13:09:05.472
get a wallet just by running
const signer equals provider,

12986
13:09:05.472 --> 13:09:09.473
dot get signer, this is going to
return whichever wallet is

12987
13:09:09.473 --> 13:09:13.473
connected from the provider,
which again, our provider is our

12988
13:09:13.473 --> 13:09:17.473
Metamask. So if we're connected
with with account one, it's

12989
13:09:17.473 --> 13:09:20.473
going to return account one as
the signer connected with

12990
13:09:20.473 --> 13:09:28.473
account two, it'll return
account two, etc. Now, I'm going

12991
13:09:28.473 --> 13:09:31.473
to add console dot log signer
here, and then flip to the front

12992
13:09:31.473 --> 13:09:34.473
end now and show you what
happens when we hit the fund

12993
13:09:34.473 --> 13:09:38.473
button. You can see in here we
have our JSON RPC signer, the

12994
13:09:38.473 --> 13:09:42.473
signer is going to be the
account that we've connected to

12995
13:09:42.473 --> 13:09:45.473
our front end. Now we have our
provider, we have our signer.

12996
13:09:45.473 --> 13:09:49.473
Now, we're going to need our
contract by getting the API and

12997
13:09:49.473 --> 13:09:53.473
the address. So we're gonna need
to say const. Contract equals

12998
13:09:53.473 --> 13:09:57.473
what? How are we going to get
our contract? Well, this is

12999
13:09:57.473 --> 13:10:01.473
where we're going to need to
know the ABI and the address of

13000
13:10:01.473 --> 13:10:04.473
a working with typically, what
you'll see a lot of projects do

13001
13:10:04.473 --> 13:10:07.473
since once a contract is
deployed, the addresses are

13002
13:10:07.473 --> 13:10:10.473
going to change is they're going
to have some type of constants

13003
13:10:10.473 --> 13:10:17.473
file. So they'll create a new
file called constants, dot j s.

13004
13:10:17.473 --> 13:10:20.473
And in here, they'll add the
addresses and any API's and

13005
13:10:20.473 --> 13:10:25.473
anything like that for us to use
in our fund piece here. Now, as

13006
13:10:25.473 --> 13:10:27.473
we're developing, and as we're
building, this, the backend and

13007
13:10:27.473 --> 13:10:30.473
the front end team are gonna
have to interact a little bit,

13008
13:10:30.473 --> 13:10:32.473
or if it's just you doing the
full stack, you're gonna have to

13009
13:10:32.473 --> 13:10:36.473
interact with their back end. So
this is why it's so important to

13010
13:10:36.473 --> 13:10:40.473
have both your front end and
your back end code nearby. So if

13011
13:10:40.473 --> 13:10:45.473
we go back to our Hardhead, fund
me project that we just made, we

13012
13:10:45.473 --> 13:10:49.474
can find the ABI in here. Once
again, if we go to artifacts, go

13013
13:10:49.474 --> 13:10:54.474
to contracts, we can go to fund
me dot soul, fund me dot JSON,

13014
13:10:54.474 --> 13:10:58.474
we can find the ABI right here,
it's going to be this massive

13015
13:10:58.474 --> 13:11:01.474
thing right here. So you can go
ahead, you can even copy this

13016
13:11:01.474 --> 13:11:05.474
whole thing in this little non
squiggly bracket and this little

13017
13:11:05.474 --> 13:11:09.474
bracket here, we can copy that.
And then we can come back to our

13018
13:11:09.474 --> 13:11:12.474
constant.js. And we can just
save it as variable, we'll say

13019
13:11:12.474 --> 13:11:23.474
Export const, Avi, e equals and
paste that in there. And then

13020
13:11:23.474 --> 13:11:28.474
back in our index dot j s, we
can import it with import

13021
13:11:28.474 --> 13:11:38.474
API from constants. Oops. Okay,
great. So we have the API. Well,

13022
13:11:38.474 --> 13:11:41.474
what about the address, since
we're going to be running this

13023
13:11:41.474 --> 13:11:44.474
locally, we want to get the
contract address of this locally

13024
13:11:44.474 --> 13:11:48.474
run contract, we can do that a
couple of ways. One way is you

13025
13:11:48.474 --> 13:11:50.474
can just have two windows open
one with your front end code,

13026
13:11:50.474 --> 13:11:53.474
one with your back end code, and
the one with your back end code,

13027
13:11:53.474 --> 13:11:57.474
you can run yarn, hard hat node,
which will spin up our

13028
13:11:57.474 --> 13:12:01.474
blockchain node for us, and give
us the address in here. Or what

13029
13:12:01.474 --> 13:12:04.474
we can do. And this will
probably be a little bit easier

13030
13:12:04.474 --> 13:12:07.474
is in your window with your
front end code and create a new

13031
13:12:07.474 --> 13:12:10.474
terminal. And now we'll have two
terminals running. And then this

13032
13:12:10.474 --> 13:12:16.474
second one, we're going to CD
down CD dot dot, and then CD,

13033
13:12:16.474 --> 13:12:20.474
hard hat on Me Free Code Camp.
And in here, we're going to run

13034
13:12:20.474 --> 13:12:25.474
yarn, art head node. And this is
going to spin up our local

13035
13:12:25.474 --> 13:12:30.475
blockchain in this second
terminal in here, where we have

13036
13:12:30.475 --> 13:12:34.475
deploying fund me deploy that
address, blah, blah, blah, right

13037
13:12:34.475 --> 13:12:37.475
here. And just a reminder, if I
hit this x, it just hides the

13038
13:12:37.475 --> 13:12:41.475
terminal. I can always pull it
back up with terminal new

13039
13:12:41.475 --> 13:12:45.475
terminal, and I can always hide
it, but this is still running

13040
13:12:45.475 --> 13:12:48.475
inside of my terminal. So I'm
going to hide it. And what I can

13041
13:12:48.475 --> 13:12:51.475
do is I can come back over to
our constants folder, and at the

13042
13:12:51.475 --> 13:12:59.475
top, we can do export const
contract address. equals, we'll

13043
13:12:59.475 --> 13:13:04.475
pull the terminal back up. And
we'll go grab, where it says,

13044
13:13:04.475 --> 13:13:08.475
pulling fund me deployed at
right here. We'll copy that

13045
13:13:08.475 --> 13:13:12.475
address, put some quotes, and
we'll paste it in. And now we're

13046
13:13:12.475 --> 13:13:17.475
also exporting the contract
address, then in our index.js

13047
13:13:17.475 --> 13:13:23.475
will import the contract address
with comma, contract address.

13048
13:13:23.475 --> 13:13:28.475
And now we have both the ABI and
the contract address. So what we

13049
13:13:28.475 --> 13:13:33.475
can do, we can say const
contract equals new ethers dot

13050
13:13:33.475 --> 13:13:38.475
contract of, we'll pass the
contract address, pass the API,

13051
13:13:38.475 --> 13:13:41.475
and we'll pass it the signer.
Now we have an ethers contract

13052
13:13:41.475 --> 13:13:44.475
object that's connected to our
signer, and we have the contract

13053
13:13:44.475 --> 13:13:47.475
address, and we have the
contract abi, now that we have a

13054
13:13:47.475 --> 13:13:51.475
contract object, we can go ahead
and start making transactions

13055
13:13:51.475 --> 13:13:54.475
the exact same way we've made
transactions before we can just

13056
13:13:54.475 --> 13:14:02.475
run const transaction response
equals a weight contract dot

13057
13:14:02.475 --> 13:14:09.476
fund. And then we'll pass a
value of ethers dot utils dot

13058
13:14:09.476 --> 13:14:14.476
parse, ether ether mount. So
this is going to be how we're

13059
13:14:14.476 --> 13:14:18.476
going to go ahead and create our
transaction. And if you take

13060
13:14:18.476 --> 13:14:21.476
this right now, and we go to our
front, we give it a little

13061
13:14:21.476 --> 13:14:24.476
refresh, make sure we're
connected and we hit fund, we're

13062
13:14:24.476 --> 13:14:29.476
gonna get this error value must
be a string. That's because at

13063
13:14:29.476 --> 13:14:33.476
the mount right now is being
passed in as nothing. Now

13064
13:14:33.476 --> 13:14:36.476
normally, we'll pass parameters
directly to our functions. But

13065
13:14:36.476 --> 13:14:39.476
what we're going to do is for
now is we're just going to hard

13066
13:14:39.476 --> 13:14:43.476
code this. So we'll say const.
At the mount equals, we'll do

13067
13:14:43.476 --> 13:14:47.476
like 77, or something we had
fun. Now, what do you think's

13068
13:14:47.476 --> 13:14:51.476
gonna happen? Well, we get this
other air, insufficient funds

13069
13:14:51.476 --> 13:14:55.476
for intrinsic transaction cost,
or you might get some other

13070
13:14:55.476 --> 13:14:57.476
error, but you're gonna get a
weird error here. And that's

13071
13:14:57.476 --> 13:15:01.476
because we're not actually
connected to our local hard head

13072
13:15:01.476 --> 13:15:04.476
node right now. Well, if we look
at our Metamask, we're currently

13073
13:15:04.476 --> 13:15:08.476
not connected to the right
blockchain, we're connected to

13074
13:15:08.476 --> 13:15:12.476
rink B, or main net or whatever,
we need to get connected to our

13075
13:15:12.476 --> 13:15:16.476
local host. If you look in your
networks, you'll actually have a

13076
13:15:16.476 --> 13:15:19.476
local host object here already.
But let's just be super

13077
13:15:19.476 --> 13:15:23.476
specific. And we'll add a new
network here, we're going to add

13078
13:15:23.476 --> 13:15:27.476
something called our hard hat,
local host. And we'll hit Add

13079
13:15:27.476 --> 13:15:30.476
Network and we'll add Hardhead.
Local host in here, the RPC URL,

13080
13:15:30.476 --> 13:15:35.476
we can find from our node area,
which we scroll to where our

13081
13:15:35.476 --> 13:15:39.476
node is running, we can copy
this URL and paste it into new

13082
13:15:39.476 --> 13:15:44.476
RPC URL, chain ID is going to be
31337 currency symbol is going

13083
13:15:44.476 --> 13:15:48.477
to be go or ether. Even though
this pop up says it might have a

13084
13:15:48.477 --> 13:15:51.477
different currency symbol go,
we're just going to put eath in

13085
13:15:51.477 --> 13:15:54.477
here. And there is no block
explorer, right? Because this is

13086
13:15:54.477 --> 13:15:57.477
a local blockchain, we're not
going to have a block Explorer.

13087
13:15:57.477 --> 13:15:58.477
So we'll go ahead and hit Save.

13088
13:15:58.477 --> 13:16:01.477
And now we have an account here,
which is great. We're connected

13089
13:16:01.477 --> 13:16:04.477
to our local blockchain. And if
we switch our meta mask, we can

13090
13:16:04.477 --> 13:16:08.477
see we're on the local hard hat.
And we are connected. Awesome.

13091
13:16:08.477 --> 13:16:13.477
Let's refresh. Let's run fund
one more time. And we'll see a

13092
13:16:13.477 --> 13:16:17.477
transaction does indeed pop up.
This is great. But our account

13093
13:16:17.477 --> 13:16:21.477
here doesn't have any money we
have, we're broke, we don't have

13094
13:16:21.477 --> 13:16:24.477
any local Hardhead Aetherium. So
we're actually going to need to

13095
13:16:24.477 --> 13:16:29.477
import one of our accounts from
hard hat into our meta mask,

13096
13:16:29.477 --> 13:16:33.477
which we can do so and you can
actually do this for any account

13097
13:16:33.477 --> 13:16:36.477
with a private key so hard that
gives us these accounts. And

13098
13:16:36.477 --> 13:16:40.477
we're going to import the
private key of Count zero into

13099
13:16:40.477 --> 13:16:42.477
our meta mask. So we're going to
copy the private key, we're

13100
13:16:42.477 --> 13:16:46.477
going to come back to our front
end, click on our meta mask,

13101
13:16:46.477 --> 13:16:49.477
we're gonna hit this big button,
we're gonna hit import account.

13102
13:16:49.477 --> 13:16:52.477
It's like type private key, and
we're gonna paste our private

13103
13:16:52.477 --> 13:16:57.477
key here. A quick note, if you
choose json file, remember how

13104
13:16:57.477 --> 13:17:01.477
back in that ether section, we
encrypted our key into a JSON

13105
13:17:01.477 --> 13:17:05.477
file with a password, you can
actually import accounts with

13106
13:17:05.477 --> 13:17:08.477
that JSON file with the
password. So if you encrypt a

13107
13:17:08.477 --> 13:17:11.477
key and you want to add it to
meta mask, you can go ahead and

13108
13:17:11.477 --> 13:17:13.477
add it in just like this. But
for now, we're going to use

13109
13:17:13.477 --> 13:17:16.477
private key, we'll paste the
private key in and we'll hit

13110
13:17:16.477 --> 13:17:21.477
import. And we can see we now
have an account, a new account

13111
13:17:21.477 --> 13:17:26.477
and account three, with a ton of
eath from our local blockchain.

13112
13:17:26.477 --> 13:17:29.478
So we'll refresh one more time,
we'll go ahead and connect,

13113
13:17:29.478 --> 13:17:33.478
we'll make sure that our account
three is connected. And if it's

13114
13:17:33.478 --> 13:17:36.478
not, we'll go ahead and hit this
Connect button. So that now our

13115
13:17:36.478 --> 13:17:39.478
account three is what's
connected here. And we'll go

13116
13:17:39.478 --> 13:17:43.478
ahead and hit fund. And we now
see that we can fund this

13117
13:17:43.478 --> 13:17:48.478
contract, we can go ahead and
hit Confirm. And if we look and

13118
13:17:48.478 --> 13:17:50.478
nothing's going to happen on our
front end, because we didn't

13119
13:17:50.478 --> 13:17:52.478
tell our front end to do
anything once we confirm, but if

13120
13:17:52.478 --> 13:17:55.478
we go to our blockchain, we can
see our fun function was called

13121
13:17:55.478 --> 13:17:58.478
we've just made our first
transaction on a blockchain from

13122
13:17:58.478 --> 13:18:02.478
our own front end, this is
awesome, great work. But it's

13123
13:18:02.478 --> 13:18:05.478
probably a little confusing to
the user. If nothing happens

13124
13:18:05.478 --> 13:18:07.478
here, they're going to hit the
fun function. And it's going to

13125
13:18:07.478 --> 13:18:12.478
be like, Oh, okay, cool. What,
what happens? Now, we probably

13126
13:18:12.478 --> 13:18:14.478
want to make it a little bit
more obvious that something just

13127
13:18:14.478 --> 13:18:17.478
happened. And one more thing I
want to show you, you don't have

13128
13:18:17.478 --> 13:18:20.478
to follow along here, if I hit
fund, and then I hit reject,

13129
13:18:20.478 --> 13:18:23.478
it's gonna freak out on us and
be like, hey, like, you hit

13130
13:18:23.478 --> 13:18:25.478
reject, I don't know what to do
now. So we're going to make our

13131
13:18:25.478 --> 13:18:28.478
code a little bit more robust by
adding a try catch. So we'll

13132
13:18:28.478 --> 13:18:36.478
tell JavaScript to try running
this transaction. And then if it

13133
13:18:36.478 --> 13:18:41.478
catches an error, just to
console dot log, that error. So

13134
13:18:41.478 --> 13:18:46.478
now, if I hit fund, and I hit
reject, it's gonna, it'll still

13135
13:18:46.478 --> 13:18:49.478
be a little bit mad, but at
least we're catching it and it's

13136
13:18:49.478 --> 13:18:52.478
not going to break and destroy
everything. Okay, cool. We've

13137
13:18:52.478 --> 13:18:55.478
got a transaction response here.
And when we hit fund, our front

13138
13:18:55.478 --> 13:19:03.478
end goes great. You've funded me
I'm I'm super confused. Oh, one

13139
13:19:03.478 --> 13:19:05.478
other point, something that
you'll probably run into

13140
13:19:05.478 --> 13:19:09.479
multiple times. As we're doing
this. If you get an error that

13141
13:19:09.479 --> 13:19:13.479
looks like this eath. JS query
while formatting outputs from

13142
13:19:13.479 --> 13:19:17.479
RPC, nonce to high expected not
to be too but got form, you will

13143
13:19:17.479 --> 13:19:20.479
definitely see this a whole lot.
Here's what you do to fix this.

13144
13:19:20.479 --> 13:19:23.479
The reason this happens is
because you've closed your

13145
13:19:23.479 --> 13:19:27.479
hardhat node and then restarted
it, and your heart had node

13146
13:19:27.479 --> 13:19:30.479
goes, Okay, well, I'm starting
fresh, I'm starting from zero.

13147
13:19:30.479 --> 13:19:34.479
But Metamask isn't smart enough
to know that, what we want to do

13148
13:19:34.479 --> 13:19:36.479
is we want to come to our
Metamask, we'll hit this big

13149
13:19:36.479 --> 13:19:40.479
button, we'll go down to
settings, we'll go to Advanced,

13150
13:19:40.479 --> 13:19:44.479
and we'll go to reset account.
And yes, we're going to reset

13151
13:19:44.479 --> 13:19:48.479
it. This isn't something ideally
that you'd like to do with an

13152
13:19:48.479 --> 13:19:51.479
actual account with actual money
on a local network, this is

13153
13:19:51.479 --> 13:19:55.479
fine. Now if you reset the
account, and you reset the node,

13154
13:19:55.479 --> 13:19:58.479
we can go ahead and hit Confirm.
And it doesn't give us that

13155
13:19:58.479 --> 13:20:01.479
error anymore. So that's kind of
the tip there, you want to reset

13156
13:20:01.479 --> 13:20:04.479
the nuts so that our Metamask
and our blockchain are in sync

13157
13:20:04.479 --> 13:20:08.479
with that nonce number.

13158
13:20:08.479 --> 13:20:10.479
So we have this transaction
response. And we probably want

13159
13:20:10.479 --> 13:20:14.479
our front end to give the user
some indication, hey, the

13160
13:20:14.479 --> 13:20:17.479
transaction went through. So
what we want to do is we want to

13161
13:20:17.479 --> 13:20:20.479
listen to the blockchain for
this to finish. So we can either

13162
13:20:20.479 --> 13:20:27.479
listen for the TX to be mined.
Or we can listen for an event.

13163
13:20:27.479 --> 13:20:29.479
We haven't learned about events
yet. But we will. So for now,

13164
13:20:29.479 --> 13:20:32.479
since we haven't learned about
events yet, we're just going to

13165
13:20:32.479 --> 13:20:34.479
listen for the TX to be mined.
Or to listen for the transaction

13166
13:20:34.479 --> 13:20:37.479
to be mined, we're actually
going to create a new function

13167
13:20:37.479 --> 13:20:44.479
called function, listen, or
transaction mine in this is

13168
13:20:44.479 --> 13:20:49.480
going to take as input a
transaction response, and a

13169
13:20:49.480 --> 13:20:53.480
provider. Now you'll notice this
isn't an async function. For

13170
13:20:53.480 --> 13:20:56.480
this section. This is
intentional, we don't want this

13171
13:20:56.480 --> 13:20:58.480
to be an async function. And
you'll see why in a second.

13172
13:20:58.480 --> 13:21:00.480
We're going to be using
JavaScript promise JavaScript

13173
13:21:01.480 --> 13:21:04.480
async functionality to its
massive advantage. And this is

13174
13:21:04.480 --> 13:21:07.480
why JavaScript actually works so
well on the front end is because

13175
13:21:07.480 --> 13:21:09.480
of how it's asynchronous. So
we're going to create this

13176
13:21:09.480 --> 13:21:12.480
function listen for transaction
to be mined, we're going to

13177
13:21:12.480 --> 13:21:16.480
await in our fund function. And
we're going to have this return

13178
13:21:16.480 --> 13:21:19.480
a promise. Let's go ahead, and
let's learn how to build this.

13179
13:21:19.480 --> 13:21:22.480
So we're gonna say console dot
log, string interpolation, we'll

13180
13:21:22.480 --> 13:21:27.480
say mining. And then in here,
we'll say transaction, response

13181
13:21:27.480 --> 13:21:32.480
dot hash. All of our transaction
response objects have a hash,

13182
13:21:32.480 --> 13:21:36.480
which just represent that hash.
And we'll do a couple of data

13183
13:21:36.480 --> 13:21:39.480
dot, we'll put in our console
here, we're waiting for the

13184
13:21:39.480 --> 13:21:42.480
transaction to be mined, then
what we're going to do is we're

13185
13:21:42.480 --> 13:21:47.480
going to return a new promise.
And the reason we're going to

13186
13:21:47.480 --> 13:21:52.480
return a promise is because we
need to create a listener for

13187
13:21:52.480 --> 13:21:55.480
the blockchain. We want to
listen for this event to happen.

13188
13:21:55.480 --> 13:22:01.480
But we want to tell JavaScript,
hey, wait for this thing to

13189
13:22:01.480 --> 13:22:04.480
finish looking, wait for this
thing to finish looking. Now

13190
13:22:04.480 --> 13:22:07.480
here's where this gets a little
bit tricky. In our fund

13191
13:22:07.480 --> 13:22:10.480
function. After we create the
transaction, we basically want

13192
13:22:10.480 --> 13:22:17.480
to tell JavaScript Hey, wait for
this TX to finish. So our code

13193
13:22:17.480 --> 13:22:22.480
is going to look as simple as
await listen for transaction

13194
13:22:22.480 --> 13:22:29.481
mine. And we're going to pass it
the trans action response

13195
13:22:29.481 --> 13:22:32.481
and our provider. So we're
saying hey, listen for this

13196
13:22:32.481 --> 13:22:35.481
transaction finish. And we're
using this await keyword,

13197
13:22:35.481 --> 13:22:38.481
because again, the await keyword
says okay, we're gonna stop

13198
13:22:38.481 --> 13:22:40.481
right here. We're gonna stop
until this function is

13199
13:22:40.481 --> 13:22:43.481
completely done. Now in this
listen for transaction in mind,

13200
13:22:43.481 --> 13:22:46.481
we have to define how we're
actually going to listen for

13201
13:22:46.481 --> 13:22:50.481
this. So we're going to say
listen for this transaction to

13202
13:22:50.481 --> 13:22:54.481
finish. Ethers actually comes
with a way for us to listen for

13203
13:22:54.481 --> 13:22:57.481
transactions and listen for
events, which again, we haven't

13204
13:22:57.481 --> 13:23:00.481
learned About, but don't worry
about that yet. So we can go to

13205
13:23:00.481 --> 13:23:04.481
the ethers docs. And we can look
up once. Contract dot once.

13206
13:23:04.481 --> 13:23:08.481
There's a whole bunch of
listeners that we can use to

13207
13:23:08.481 --> 13:23:11.481
listen for events and listen for
different things to happen, we

13208
13:23:11.481 --> 13:23:13.481
can do this thing called
provider dot once where we

13209
13:23:13.481 --> 13:23:18.481
listen for some event. And once
that event fires, we call some

13210
13:23:18.481 --> 13:23:21.481
other function that we've
defined. Now, we haven't talked

13211
13:23:21.481 --> 13:23:24.481
about events yet. And again,
don't worry about this quite

13212
13:23:24.481 --> 13:23:27.481
yet. One of the events that we
can wait for is we can just wait

13213
13:23:27.481 --> 13:23:30.481
for the transaction receipt to
finish, right, because once we

13214
13:23:30.481 --> 13:23:33.481
get a transaction receipt, that
means that the transaction has

13215
13:23:33.481 --> 13:23:36.481
actually finished going through.
So we're going to use this

13216
13:23:36.481 --> 13:23:41.481
provider dot once syntax to wait
for the transaction receipt,

13217
13:23:41.481 --> 13:23:43.481
which is going to be our event,
which isn't really an event, but

13218
13:23:43.481 --> 13:23:45.481
don't worry about that yet. And
then we're going to call some

13219
13:23:45.481 --> 13:23:48.481
listener function that we
defined, you can also do

13220
13:23:48.481 --> 13:23:52.481
provider.on, which will trigger
anytime your event fires

13221
13:23:52.481 --> 13:23:56.481
provider once just triggers one
time, we only care about this

13222
13:23:56.481 --> 13:23:59.481
transaction going through one
time. So we're passing our

13223
13:23:59.481 --> 13:24:04.481
provider object. So we're gonna
say provider dot once our event

13224
13:24:04.481 --> 13:24:09.482
which is just going to be
transaction response, hash,

13225
13:24:09.482 --> 13:24:13.482
provided on transaction response
dot hash. So once we get this

13226
13:24:13.482 --> 13:24:16.482
hash, which will pretty much get
right away, we're going to call

13227
13:24:16.482 --> 13:24:20.482
our listener function. Now we
can create a function listener

13228
13:24:20.482 --> 13:24:23.482
like this, and then just pass
listener in here. But we're

13229
13:24:23.482 --> 13:24:25.482
going to do an anonymous
function here, because that's

13230
13:24:25.482 --> 13:24:28.482
typically what we see as the
syntax for these loops. And so

13231
13:24:28.482 --> 13:24:30.482
far, we're doing provider dot
once to do this anonymous

13232
13:24:30.482 --> 13:24:34.482
function, we're going to do just
two little parentheses here. And

13233
13:24:34.482 --> 13:24:39.482
this arrow notation. So this by
itself represents an anonymous

13234
13:24:39.482 --> 13:24:41.482
function. So we're saying, hey,
there's some function, it

13235
13:24:41.482 --> 13:24:45.482
doesn't take any parameters, and
it doesn't have any code, this

13236
13:24:45.482 --> 13:24:48.482
arrow function, this whole thing
is saying this is an anonymous

13237
13:24:48.482 --> 13:24:51.482
function. So we're saying
provided at once transaction

13238
13:24:51.482 --> 13:24:53.482
hash happens, here's the
function that you want to

13239
13:24:53.482 --> 13:24:56.482
execute. It doesn't do anything
right now. But let's have a do

13240
13:24:56.482 --> 13:24:58.482
something. So once this
transaction dot response

13241
13:24:58.482 --> 13:25:05.482
finishes, we're going to take a
trans transaction received as an

13242
13:25:05.482 --> 13:25:09.482
input parameter, or our our
callback function, or our

13243
13:25:09.482 --> 13:25:12.482
listener function. And all we're
going to do is we're gonna say

13244
13:25:12.482 --> 13:25:19.482
console dot log, completed with
a little string interpolation,

13245
13:25:19.482 --> 13:25:24.482
transaction receipt, that
confirmations, confirmations,

13246
13:25:24.482 --> 13:25:26.482
and then completed with
transaction receipt,

13247
13:25:26.482 --> 13:25:30.482
confirmations, confirmations. So
once this provider dot once sees

13248
13:25:30.482 --> 13:25:34.482
that there's a transaction hash,
it's going to give as an input

13249
13:25:34.482 --> 13:25:37.482
rammer to our listener function,
the transaction receipt, kind of

13250
13:25:37.482 --> 13:25:40.482
that same syntax that we've been
seeing this whole time, once a

13251
13:25:40.482 --> 13:25:43.482
transaction response finishes,
we get the transaction receipt,

13252
13:25:43.482 --> 13:25:45.482
and we can do stuff with it. And
we see how many block

13253
13:25:45.482 --> 13:25:48.483
confirmations it has. For us,
this pretty much should always

13254
13:25:48.483 --> 13:25:52.483
be one. Now if we save this, go
back to our front end, and we

13255
13:25:52.483 --> 13:25:56.483
hit fund, it's going to work,
we're going to give the user

13256
13:25:56.483 --> 13:25:59.483
some indication that it worked,
which is great. But it's not

13257
13:25:59.483 --> 13:26:02.483
really going to work the way
that we want it to work. We have

13258
13:26:02.483 --> 13:26:05.483
this console dot log done right
after we do the await, listen

13259
13:26:05.483 --> 13:26:09.483
for transaction mine, and we
come back and we hit fund, we

13260
13:26:09.483 --> 13:26:13.483
hit confirm, it actually doesn't
go in the order that we want it

13261
13:26:13.483 --> 13:26:18.483
to go, it goes mining this thing
that it says Done. And then it

13262
13:26:18.483 --> 13:26:21.483
says completed with one trip
confirmation what what's going

13263
13:26:21.483 --> 13:26:26.483
on here, we should write
completed before we write done,

13264
13:26:26.483 --> 13:26:28.483
because that's the order that we
have this in. But it looks like

13265
13:26:28.483 --> 13:26:32.483
it's words, it's going out of
order. What what's going on

13266
13:26:32.483 --> 13:26:35.483
here, what's going to happen is
when we call listen for

13267
13:26:35.483 --> 13:26:40.483
transaction mine, or listen for
transaction, mine function is

13268
13:26:40.483 --> 13:26:44.483
going to kick off, but it's
going to kick off provided on

13269
13:26:44.483 --> 13:26:49.483
once as its own process. So
await listen for transaction,

13270
13:26:49.483 --> 13:26:53.483
mine will kick off the listener,
but it doesn't wait for this

13271
13:26:53.483 --> 13:26:57.483
listener to find the transaction
response. So this function will

13272
13:26:57.483 --> 13:27:04.483
actually finish before provider
dot once finishes. So after it

13273
13:27:04.483 --> 13:27:08.483
kicks off the listener, it'll
run to the next line of our

13274
13:27:08.483 --> 13:27:12.483
code, which is console dot log
and done. Our front end we'll go

13275
13:27:12.483 --> 13:27:15.483
oh, oh, you kicked off a
listener earlier. Let me go back

13276
13:27:15.483 --> 13:27:20.483
down and let me recheck to see
if it's finished. And if it has

13277
13:27:20.483 --> 13:27:23.483
finished, I'll go do what it
told me to do. And this is where

13278
13:27:23.483 --> 13:27:25.483
what's known as the event loop
kicks in.

13279
13:27:25.483 --> 13:27:28.484
We don't actually wait for this
provider that wants to finish,

13280
13:27:28.484 --> 13:27:32.484
we add this provided at once
onto this queue called the event

13281
13:27:32.484 --> 13:27:36.484
loop. And our front end is going
to periodically check back to it

13282
13:27:36.484 --> 13:27:40.484
to see if it's finished. So we
want to adjust our code. So we

13283
13:27:40.484 --> 13:27:43.484
wait for the listener to finish
listening, which is where we're

13284
13:27:43.484 --> 13:27:47.484
going to get into promises here.
So what we want to do is we want

13285
13:27:47.484 --> 13:27:50.484
to adjust this function to now
return a promise. And we're

13286
13:27:50.484 --> 13:27:53.484
going to use this syntax a
couple of times in the future.

13287
13:27:53.484 --> 13:27:55.484
So what we're going to do is
we're going to say hey, we want

13288
13:27:55.484 --> 13:27:59.484
to wait for the listener To
finish listening, we're going to

13289
13:27:59.484 --> 13:28:02.484
wrap this whole thing into a
promise. And we're going to say

13290
13:28:02.484 --> 13:28:08.484
return, new promise. And a
promise takes a function itself

13291
13:28:08.484 --> 13:28:12.484
as an input parameter. So again,
we'll use kind of this anonymous

13292
13:28:12.484 --> 13:28:15.484
function notation. And it will
take two input parameters

13293
13:28:15.484 --> 13:28:21.484
resolve and reject. So resolve
says, hey, if this promise works

13294
13:28:21.484 --> 13:28:24.484
correctly, call this resolve
function. And for us, this

13295
13:28:24.484 --> 13:28:28.484
promise is going to be done when
the listener finishes listening.

13296
13:28:28.484 --> 13:28:31.484
And then we would reject if
there was some type of timeout,

13297
13:28:31.484 --> 13:28:34.484
we're not going to write the
reject function. But in the

13298
13:28:34.484 --> 13:28:37.484
future, if you were to do this
for production, you'd add some

13299
13:28:37.484 --> 13:28:40.484
timeout as the reject parameter.
Basically, you're saying, hey,

13300
13:28:40.484 --> 13:28:42.484
once the listener finishes
listening, we're going to

13301
13:28:42.484 --> 13:28:45.484
resolve and if it takes too
long, we're gonna say ask for

13302
13:28:45.484 --> 13:28:47.484
you, you took too long, and
instead of closing it off, here,

13303
13:28:47.484 --> 13:28:52.484
we're going to close it off
around this provider thing. So

13304
13:28:52.484 --> 13:28:55.484
we're gonna say return new
promise, resolve, reject. And

13305
13:28:55.484 --> 13:29:00.484
only once this transaction gets
fired, are we going to resolve

13306
13:29:00.484 --> 13:29:05.484
this promise, like so. So what
is happening here, so we're

13307
13:29:05.484 --> 13:29:10.485
going to put the resolve inside
of this provider at once. So

13308
13:29:10.485 --> 13:29:15.485
we're saying, once this
transaction hash is found, then

13309
13:29:15.485 --> 13:29:18.485
we're going to call this
function, we're gonna say

13310
13:29:18.485 --> 13:29:21.485
console dot log, and then we're
going to resolve so this promise

13311
13:29:21.485 --> 13:29:25.485
only returns once a resolve or
reject is called. And we're

13312
13:29:25.485 --> 13:29:31.485
telling it only resolve only
finish this function once.

13313
13:29:31.485 --> 13:29:34.485
Transaction response dot hash is
found, because it's going to be

13314
13:29:34.485 --> 13:29:38.485
inside of these little squiggly
parentheses for provider dot

13315
13:29:38.485 --> 13:29:43.485
once, the promise right now only
resolves after it's fired. It's

13316
13:29:43.485 --> 13:29:47.485
event here. If this was really
confusing, just copy paste this

13317
13:29:47.485 --> 13:29:50.485
and move on, we're getting a
little bit deeper into front end

13318
13:29:50.485 --> 13:29:54.485
stuff here. So hopefully, this
was clear, if not definitely

13319
13:29:54.485 --> 13:29:56.485
jump in to the GitHub
discussions to start asking

13320
13:29:56.485 --> 13:30:00.485
about this stuff. But now that
we've updated this, we can come

13321
13:30:00.485 --> 13:30:03.485
back to our front end, we can
hit the fund button. And

13322
13:30:03.485 --> 13:30:06.485
hopefully this time, everything
will go in order. We'll hit

13323
13:30:06.485 --> 13:30:10.485
confirm, we see mining
completed, and then we see done.

13324
13:30:10.485 --> 13:30:14.485
And the reason for this is
because again, our await keyword

13325
13:30:14.485 --> 13:30:17.485
is now waiting, it says oh,
you're returning a promise, I

13326
13:30:17.485 --> 13:30:21.485
need to await I need to wait for
it to resolve or reject. And we

13327
13:30:21.485 --> 13:30:25.485
only resolve the promise once
our provider finds this

13328
13:30:25.485 --> 13:30:27.485
transaction hash and this
transaction receipt, this is

13329
13:30:27.485 --> 13:30:31.485
this listen for transaction
mine. In future sections, all of

13330
13:30:31.485 --> 13:30:33.485
this is going to be abstracted
away for us. So life is going to

13331
13:30:33.485 --> 13:30:36.485
be much easier, but it is
important to understand what's

13332
13:30:36.485 --> 13:30:39.485
actually going on here. Awesome.
So now we're giving the front

13333
13:30:39.485 --> 13:30:47.485
end some indication of what's
going on. Our fun function is

13334
13:30:47.485 --> 13:30:52.486
done well, no, not really. Why
not? Well, because right now

13335
13:30:52.486 --> 13:30:55.486
we're hard coding the eath
amount to 0.1. And on the front

13336
13:30:55.486 --> 13:30:57.486
end, we probably don't want to
hard code it, we probably want

13337
13:30:57.486 --> 13:31:02.486
to allow users to fund as much
or as little as they want. So we

13338
13:31:02.486 --> 13:31:05.486
actually need to change this
from just a button to a input

13339
13:31:05.486 --> 13:31:09.486
form. So to do this, we're gonna
go back over into our HTML. So

13340
13:31:09.486 --> 13:31:13.486
we'll go back to index dot HTML.
And we're going to change this

13341
13:31:13.486 --> 13:31:15.486
fun section here, we're going to
add some form information. So

13342
13:31:15.486 --> 13:31:18.486
we're going to keep this button
as it is, or we're going to add

13343
13:31:18.486 --> 13:31:22.486
like a little text box to input
as much eath as they want. So

13344
13:31:22.486 --> 13:31:26.486
I'm going to create a label,
we're gonna say it's for, it's

13345
13:31:26.486 --> 13:31:30.486
going to be fund and this label
we're gonna say, is eath amount,

13346
13:31:30.486 --> 13:31:32.486
and then we're gonna close
label, this is basically just

13347
13:31:32.486 --> 13:31:34.486
going to create a label. And if
we go back to our front end, we

13348
13:31:34.486 --> 13:31:37.486
now just have this Etham out
label that isn't labeling

13349
13:31:37.486 --> 13:31:40.486
anything. Now we're going to
create an input, and we're going

13350
13:31:40.486 --> 13:31:45.486
to give it an ID of eath amount.
And we're going to give it a

13351
13:31:45.486 --> 13:31:47.486
placeholder

13352
13:31:47.486 --> 13:31:53.486
of 0.1. And then we're gonna
close the input. So now if we

13353
13:31:53.486 --> 13:31:56.486
flip to our front end, we have
eath amount, labeling this

13354
13:31:56.486 --> 13:31:59.486
little text box with a
placeholder of 0.1. And we can

13355
13:31:59.486 --> 13:32:02.486
add stuff in here, you know,
blah, blah, whatever. And one

13356
13:32:02.486 --> 13:32:05.486
more thing, if you have some
tags, but you don't put anything

13357
13:32:05.486 --> 13:32:07.486
in between them, you can
actually shorten it by just

13358
13:32:07.486 --> 13:32:11.486
putting the little closing thing
at the back of it like this. So

13359
13:32:11.486 --> 13:32:13.486
if you don't have anything
between your tags, you can just

13360
13:32:13.486 --> 13:32:17.486
close them like this, these two
are equivalent, boom, boom,

13361
13:32:17.486 --> 13:32:20.486
boom, boom, those are the same
thing. Great. When we called

13362
13:32:20.486 --> 13:32:22.486
fund right now we're calling
fund and we're not passing any

13363
13:32:22.486 --> 13:32:27.486
parameters. Let's update our
fund to no longer be hardcoding

13364
13:32:27.486 --> 13:32:30.487
eath amount in here, and we'll
have and we'll have our fund

13365
13:32:30.487 --> 13:32:36.487
function populated by whatever
we put in this eath amount input

13366
13:32:36.487 --> 13:32:39.487
box in our fund function,
instead of saying const eath

13367
13:32:39.487 --> 13:32:45.487
amount equals 0.1. We'll grab it
from this eath amount ID and

13368
13:32:45.487 --> 13:32:53.487
we'll say document dot get
element by ID eath amount, dot

13369
13:32:53.487 --> 13:32:59.487
value. So we're going to grab
whatever value In this input box

13370
13:32:59.487 --> 13:33:02.487
here, now, in our index.js, we
have console dot log funding

13371
13:33:02.487 --> 13:33:07.487
with eath amount, if in our
front end, we do 1.7. And we hit

13372
13:33:07.487 --> 13:33:11.487
fund, we now see in our console
dot log, it says funding with

13373
13:33:11.487 --> 13:33:16.487
1.7. And we'll get 1.7. And our
little fun section confirm, it

13374
13:33:16.487 --> 13:33:20.487
will mine it, it'll complete it,
and then say, done. Awesome. So

13375
13:33:20.487 --> 13:33:24.487
now we've added a little text
box here. So people can fund as

13376
13:33:24.487 --> 13:33:27.487
much or as little as they want.
Perfect, this whole thing can

13377
13:33:27.487 --> 13:33:31.487
kind of be considered a form.
There's also a form tag, but

13378
13:33:31.487 --> 13:33:36.487
we're going to just use this for
now. All right, great. We're

13379
13:33:36.487 --> 13:33:39.487
doing a lot of funding right,
and we keep funding our contract

13380
13:33:39.487 --> 13:33:42.487
with more and more Ethan, we
keep adding more and more stuff,

13381
13:33:42.487 --> 13:33:45.487
we probably want a button to
keep track of how much is

13382
13:33:45.487 --> 13:33:48.487
actually in here. So let's just
add a really simple balance

13383
13:33:48.487 --> 13:33:51.487
button. And let me actually just
move this down to the bottom

13384
13:33:51.487 --> 13:33:56.487
here, much better. So we'll say
button, id equals balance

13385
13:33:56.487 --> 13:34:03.487
button. We'll call it get
balance. Now we have a get

13386
13:34:03.487 --> 13:34:05.487
balanced button. And it's not
going to do anything because we

13387
13:34:05.487 --> 13:34:07.487
don't have a get balanced
function. So let's go back to

13388
13:34:07.487 --> 13:34:13.488
our index.js. And we'll create a
get bounced function async

13389
13:34:13.488 --> 13:34:17.488
function get bounce. And we'll
just do what we've been doing so

13390
13:34:17.488 --> 13:34:23.488
far. If type of window dot
Aetherium does not equal,

13391
13:34:23.488 --> 13:34:27.488
undefined, then we're going to
do const provider equals new

13392
13:34:27.488 --> 13:34:34.488
ethers, ethers, dot providers
dot web three provider of

13393
13:34:34.488 --> 13:34:40.488
window, that Aetherium then will
do const balance equals awaits

13394
13:34:40.488 --> 13:34:46.488
provider dot get balance,
contract address, which again,

13395
13:34:46.488 --> 13:34:50.488
we're importing way up at the
top, and then we'll just do

13396
13:34:50.488 --> 13:34:59.488
console dot log ethers dot utils
dot format, ether, bounce this

13397
13:34:59.488 --> 13:35:02.488
format ether function ethers
utils, which you can find in the

13398
13:35:02.488 --> 13:35:06.488
documentation to make reading
ethers, formatted numbers much

13399
13:35:06.488 --> 13:35:10.488
easier to read. Then same as
what we've been doing before,

13400
13:35:10.488 --> 13:35:13.488
we're going to go up, we're
going to copy this fun button

13401
13:35:13.488 --> 13:35:19.488
line, paste it will say balance
button equals document dot get

13402
13:35:19.488 --> 13:35:26.488
element by ID, balance button.
And then we'll say balance

13403
13:35:26.488 --> 13:35:31.488
button on click equals get
balance, we're gonna come back

13404
13:35:31.488 --> 13:35:34.488
to our front end, we'll do a
quick refresh, we'll do get

13405
13:35:34.488 --> 13:35:37.488
balance. And now we can see the
balance in the console, we can

13406
13:35:37.488 --> 13:35:42.488
fund with more like 1.8, we'll
hit fund metamath pops up, we'll

13407
13:35:42.488 --> 13:35:46.488
go ahead and confirm mining
completed done, we hit get

13408
13:35:46.488 --> 13:35:53.489
balanced, and now we're at 3.8.
Fantastic. Alright, let's keep

13409
13:35:53.489 --> 13:35:55.489
it going. What do we need to do
next, we're gonna go ahead and

13410
13:35:55.489 --> 13:35:58.489
eat our withdrawal function
here. So let's create that this

13411
13:35:58.489 --> 13:36:01.489
is gonna look really similar to
everything we've done so far. So

13412
13:36:01.489 --> 13:36:04.489
on our index dot HTML, let's
create a new button that we can

13413
13:36:04.489 --> 13:36:09.489
do by copying this whole line,
paste it underneath, call this

13414
13:36:09.489 --> 13:36:13.489
withdraw button, we'll call
withdraw. And we'll call this

13415
13:36:13.489 --> 13:36:18.489
withdraw. And then in our index,
do the same thing, we'll copy

13416
13:36:18.489 --> 13:36:25.489
this, paste it below. So with
drop button was document get

13417
13:36:25.489 --> 13:36:31.489
element by ID, withdraw button,
withdraw button.on Click equals

13418
13:36:31.489 --> 13:36:34.489
withdraw. So let's make a
withdrawal function down at the

13419
13:36:34.489 --> 13:36:40.489
bottom. We'll go ahead, say
async. Function withdraw,

13420
13:36:40.489 --> 13:36:43.489
will do the exact same that
we've done above. And I can even

13421
13:36:43.489 --> 13:36:48.489
just copy everything from the
get balance and just remove the

13422
13:36:48.489 --> 13:36:51.489
balance section. If type of
window dot Aetherium does not

13423
13:36:51.489 --> 13:36:56.489
equal to undefined, then we'll
grab the provider here. And same

13424
13:36:56.489 --> 13:37:00.489
as the fund contract, we'll grab
the signer and the contract. So

13425
13:37:00.489 --> 13:37:03.489
let's just grab those two lines.
Paste them down here called

13426
13:37:03.489 --> 13:37:07.489
signer equals provider dot get
signer. Contract equals new

13427
13:37:07.489 --> 13:37:09.489
contract, blah, blah, blah.
Okay, cool. Now we're gonna do

13428
13:37:09.489 --> 13:37:13.489
the exact same here as we did
with the fun function. So we're

13429
13:37:13.489 --> 13:37:15.489
gonna do a little try, catch,
and then we'll even add the

13430
13:37:15.489 --> 13:37:21.489
catch here, catch error, console
dot log error. And inside of our

13431
13:37:21.489 --> 13:37:29.490
try, we'll do const transaction
response equals await, contracts

13432
13:37:29.490 --> 13:37:33.490
dot withdraw. We don't need to
put any parameters in here. Oh,

13433
13:37:33.490 --> 13:37:39.490
then actually, let's do a little
console dot log, withdrawing,

13434
13:37:39.490 --> 13:37:41.490
and then we'll get this
transaction response. And then

13435
13:37:41.490 --> 13:37:43.490
we'll listen for this
transaction to get mined as

13436
13:37:43.490 --> 13:37:52.490
well. By running a Wait, listen
for transaction mine transaction

13437
13:37:52.490 --> 13:37:59.490
response comma, provider And
that's it, since we can reuse

13438
13:37:59.490 --> 13:38:02.490
the functionality from our
listen for transaction mine. So

13439
13:38:02.490 --> 13:38:05.490
now we'll refresh, we'll make
sure we're connected, check the

13440
13:38:05.490 --> 13:38:11.490
current balance, which is 3.8.
Now we'll go ahead and withdraw.

13441
13:38:11.490 --> 13:38:14.490
We see our little withdrawing
console dot log, we'll hit

13442
13:38:14.490 --> 13:38:19.490
Confirm. And it looks like we've
completed it, if we look in our

13443
13:38:19.490 --> 13:38:23.490
Metamask, our bounced will have
been increased by the amount

13444
13:38:23.490 --> 13:38:27.490
that was added here. And now if
we hit balance, we do indeed see

13445
13:38:27.490 --> 13:38:30.490
zero, we can even double check
that this is actually working,

13446
13:38:30.490 --> 13:38:34.490
we can see our balance is 9.99.
Let's go ahead and even fund

13447
13:38:34.490 --> 13:38:39.490
this with 99 eath. Good confirm,
looks like it's completed. Our

13448
13:38:39.490 --> 13:38:44.490
meta mask now shows 99.00. And
if we go ahead and withdraw,

13449
13:38:44.490 --> 13:38:48.490
confirm, that withdrawal has
gone through, we can see our

13450
13:38:48.490 --> 13:38:55.490
balance is back up to 9999. And
now let's just go back and

13451
13:38:55.490 --> 13:39:00.490
change. Hey, what's good. We'll
refresh our front end. And now

13452
13:39:00.490 --> 13:39:04.490
we can see you've done it, we've
created a minimalistic website

13453
13:39:04.490 --> 13:39:07.490
that allows us to connect to the
blockchain and call functions

13454
13:39:07.490 --> 13:39:10.491
from a front end. And from a
website, this is absolutely

13455
13:39:10.491 --> 13:39:13.491
massive, you should be
incredibly proud and incredibly

13456
13:39:13.491 --> 13:39:16.491
excited with yourself. Now, this
is definitely a minimalistic

13457
13:39:16.491 --> 13:39:19.491
version. And we're going to work
with more powerful and more

13458
13:39:19.491 --> 13:39:22.491
modern front end frameworks. But
this will give you an idea of

13459
13:39:22.491 --> 13:39:25.491
exactly what's going on behind
the scenes when we're working

13460
13:39:25.491 --> 13:39:28.491
with those more advanced front
ends, and we'll style them up.

13461
13:39:28.491 --> 13:39:31.491
So they look a little bit better
than this. But with that being

13462
13:39:31.491 --> 13:39:34.491
said, you've just learned the
basics of how these front ends

13463
13:39:34.491 --> 13:39:37.491
work. And now that you know how
to push things up to get, I

13464
13:39:37.491 --> 13:39:40.491
highly recommend you start
pushing all of these projects up

13465
13:39:40.491 --> 13:39:43.491
to your GitHub, they will be a
record that you've actually done

13466
13:39:43.491 --> 13:39:45.491
the work and you've built these
smart contracts. And if you're

13467
13:39:45.491 --> 13:39:47.491
looking to get an internship
down the line, if you're looking

13468
13:39:47.491 --> 13:39:51.491
to help other GitHub projects,
this will be a record of hey, I

13469
13:39:51.491 --> 13:39:54.491
can do this, what I can build
look at what I know how to do so

13470
13:39:54.491 --> 13:39:57.491
congratulations on your first
full stack or your first front

13471
13:39:57.491 --> 13:40:00.491
end application. Before we move
on, let's do a quick refresher

13472
13:40:00.491 --> 13:40:03.491
of everything we've learned
here. So number one, typically,

13473
13:40:03.491 --> 13:40:07.491
you want the repository or your
code base. For your back end for

13474
13:40:07.491 --> 13:40:09.491
your smart contracts to be a
different repository than your

13475
13:40:09.491 --> 13:40:12.491
front end, your front end code
is going to be a combination of

13476
13:40:12.491 --> 13:40:15.491
HTML and JavaScript. When we
have a wallet like meta mask,

13477
13:40:15.491 --> 13:40:18.491
we're injecting these browser
based wallets into the window

13478
13:40:18.491 --> 13:40:21.491
object of our browsers like
window dot Aetherium. Each

13479
13:40:21.491 --> 13:40:24.491
browser will have a different
extension here, reason we do

13480
13:40:24.491 --> 13:40:28.491
this, we want to connect to the
RPC URL that's built into our

13481
13:40:28.491 --> 13:40:31.491
meta masks. And in this way,
we're making the same API calls

13482
13:40:31.491 --> 13:40:34.491
to an RPC URL as we do in hard
hat as we do in remix as we do

13483
13:40:34.491 --> 13:40:38.491
in ethers, etc, we created our
first promise based function

13484
13:40:38.491 --> 13:40:42.491
where we had a listener kickoff,
and we wrapped it in a promise

13485
13:40:42.491 --> 13:40:46.491
to say, hey, we want to wait for
our listener to finish since

13486
13:40:46.491 --> 13:40:49.492
this is a promise based
function, we set a weight listen

13487
13:40:49.492 --> 13:40:52.492
for transaction mind and we
waited for this transaction to

13488
13:40:52.492 --> 13:40:55.492
finish so that on our front end,
once our transaction finished

13489
13:40:55.492 --> 13:40:57.492
going through, we can tell the
user it's finished going through

13490
13:40:57.492 --> 13:41:00.492
and we can continue doing other
stuff. Give yourself that round

13491
13:41:00.492 --> 13:41:04.492
of applause and let's move on to
the next section.

13492
13:41:04.492 --> 13:41:08.492
All right, welcome to the next
section. We are now on Lesson

13493
13:41:08.492 --> 13:41:11.492
Nine, our hardhat smart contract
lottery, which again, all the

13494
13:41:11.492 --> 13:41:15.492
code for this section is going
to be available in the GitHub

13495
13:41:15.492 --> 13:41:17.492
repo associated with this
course. Alright, so let me show

13496
13:41:17.492 --> 13:41:19.492
you what we're about to build.
I'm going to show you the front

13497
13:41:20.492 --> 13:41:22.492
end login, you don't have to do
the front end, if you don't

13498
13:41:22.492 --> 13:41:25.492
want. But the front end does
give us a nice way to visualize

13499
13:41:25.492 --> 13:41:27.492
the lottery that we're building.
Here, we're building an

13500
13:41:27.492 --> 13:41:30.492
application that allows users
completely decentralized to

13501
13:41:30.492 --> 13:41:35.492
allow us to engage in a fair, a
verifiably random lottery. This

13502
13:41:35.492 --> 13:41:39.492
is the application that would
actually fix the McDonald's

13503
13:41:39.492 --> 13:41:42.492
issue that we talked about much
earlier. So first, we got this

13504
13:41:42.492 --> 13:41:45.492
Kinect Wallet button that we're
going to click to connect to

13505
13:41:45.492 --> 13:41:48.492
meta mask. And here, we're
actually going to show you how

13506
13:41:48.492 --> 13:41:51.492
to connect to more than just
Metamask wallet connect to trust

13507
13:41:51.492 --> 13:41:53.492
wallet, math, wallet, any of
these wallets, and we'll show

13508
13:41:53.492 --> 13:41:56.492
you how to customize even more.
So we're going to connect to

13509
13:41:56.492 --> 13:42:00.492
Metamask. Here, we'll choose our
account that we imported in from

13510
13:42:00.492 --> 13:42:03.492
Hardhead, we choose Next we're
gonna choose Connect. And

13511
13:42:03.492 --> 13:42:06.492
remember, for our front end bit,
we're gonna go to Settings

13512
13:42:06.492 --> 13:42:09.492
Advanced reset account, if we're
working with a brand new hard

13513
13:42:09.492 --> 13:42:12.492
hat blockchain. Now, the front
end doesn't look super nice, but

13514
13:42:12.492 --> 13:42:15.492
we have an enter raffle button.
And we have a little bit of UI

13515
13:42:15.492 --> 13:42:18.492
talking about the current number
of players and then the most

13516
13:42:18.492 --> 13:42:22.492
previous winner of a raffle. So
we can go ahead and enter the

13517
13:42:22.492 --> 13:42:27.492
raffle and allow anybody to pay
0.1 eath. To enter our smart

13518
13:42:27.492 --> 13:42:30.493
contract, we get a little
transaction saying transaction

13519
13:42:30.493 --> 13:42:33.493
complete, and we get the current
number of players is one, we can

13520
13:42:33.493 --> 13:42:37.493
continue to enter the raffle and
anybody can enter this raffle.

13521
13:42:37.493 --> 13:42:40.493
And this, the smart contract
will keep track of all the

13522
13:42:40.493 --> 13:42:43.493
players in here, we're going to
run this on a timer, the lottery

13523
13:42:43.493 --> 13:42:46.493
is going to automatically
trigger somebody to win. And to

13524
13:42:46.493 --> 13:42:49.493
do this, to get a pure
verifiable random number, we're

13525
13:42:49.493 --> 13:42:53.493
going to be using chain link VRF
to get a pure verifiably random

13526
13:42:53.493 --> 13:42:57.493
number. And then we're gonna use
chain link keepers to trigger

13527
13:42:57.493 --> 13:43:01.493
the automation to automatically
have one of these winners get

13528
13:43:01.493 --> 13:43:04.493
picked every time one of those
time intervals is up. Once the

13529
13:43:04.493 --> 13:43:07.493
keepers kick it off, they will
pick a winner, our decentralized

13530
13:43:07.493 --> 13:43:10.493
lottery will say the most
previous winner is so and so.

13531
13:43:10.493 --> 13:43:13.493
And they will get all the money
from this lottery making a

13532
13:43:13.493 --> 13:43:17.493
perfectly fair decentralized
lottery, we're going to call our

13533
13:43:17.493 --> 13:43:20.493
contract, raffle dot soul but
you can call it lottery dot soul

13534
13:43:20.493 --> 13:43:22.493
or really whatever you want. And
we're going to make it look

13535
13:43:22.493 --> 13:43:25.493
really, really nice. So now
we're back in our Visual Studio

13536
13:43:25.493 --> 13:43:28.493
code. This is going to be the
project. If you learn this, you

13537
13:43:28.493 --> 13:43:31.493
have the skills to learn all the
rest of the smart contract

13538
13:43:31.493 --> 13:43:34.493
concepts, and you are going to
be able to do great things in

13539
13:43:34.493 --> 13:43:37.493
the space. This is going to be
your flagship project, this is

13540
13:43:37.493 --> 13:43:40.493
going to be the one that you can
be the most excited and the most

13541
13:43:40.493 --> 13:43:46.493
proud about for this tutorial.
So let's go ahead and let's

13542
13:43:46.493 --> 13:43:50.493
create a new folder. So we're
gonna do MK dir, hardhat, smart

13543
13:43:50.493 --> 13:43:55.493
contract lottery, FCC or smart
contract, raffle, whatever you

13544
13:43:55.493 --> 13:43:58.493
want to call it, then we're
going to cd into our hard hat,

13545
13:43:58.493 --> 13:44:01.493
smart contract lottery Free Code
Camp. And we're going to type

13546
13:44:01.493 --> 13:44:04.493
code period, or we're going to
open this up in a new folder,

13547
13:44:04.493 --> 13:44:07.493
however we choose to do. So now
that we're in our new folder,

13548
13:44:07.493 --> 13:44:11.494
we're going to create our new
hard hat project. So we're going

13549
13:44:11.494 --> 13:44:19.494
to do yarn, add dash dash dev
hard hat. And we'll get our node

13550
13:44:19.494 --> 13:44:23.494
modules are package dot JSON and
our yarn dot lock. Now we'll do

13551
13:44:23.494 --> 13:44:26.494
yarn hardhat. To get started
with a new project, and we're

13552
13:44:26.494 --> 13:44:30.494
just going to select create an
empty hard hat dot config dot j

13553
13:44:30.494 --> 13:44:32.494
s because we know what a basic
project looks like. And we're

13554
13:44:32.494 --> 13:44:35.494
gonna give this project the
customizations that we want to

13555
13:44:35.494 --> 13:44:37.494
see, we're going to create an
empty hard hat dot config. And

13556
13:44:37.494 --> 13:44:42.494
now in here we have a blank
hardhead.config.js with almost

13557
13:44:42.494 --> 13:44:44.494
nothing in here. So we're
starting completely from

13558
13:44:44.494 --> 13:44:47.494
scratch. Now we're going to add
all of our dependencies in here.

13559
13:44:47.494 --> 13:44:50.494
And oftentimes, you'll add these
sequentially as you build but

13560
13:44:50.494 --> 13:44:54.494
we're just going to add them all
in one line, and there are a lot

13561
13:44:54.494 --> 13:44:57.494
of them. So we've left a copy,
paste the whole section of the

13562
13:44:57.494 --> 13:45:00.494
full blockchain solidity course,
J S, for you to just copy,

13563
13:45:00.494 --> 13:45:03.494
paste, so you can install
everything in one go. So grab

13564
13:45:03.494 --> 13:45:05.494
that line, and it's going to
have everything that we've been

13565
13:45:05.494 --> 13:45:09.494
talking about. And we'll just
hit enter, and we'll install all

13566
13:45:09.494 --> 13:45:10.494
of these.

13567
13:45:10.494 --> 13:45:13.494
And as you create more and more
projects, you'll get the feel of

13568
13:45:13.494 --> 13:45:16.494
what you like for your
dependencies and what tools that

13569
13:45:16.494 --> 13:45:20.494
you like to use. Remember, at
the end of the day, the tool

13570
13:45:20.494 --> 13:45:23.494
that's best for you and best for
the job is the tool that you

13571
13:45:23.494 --> 13:45:26.494
like the most. There never
really is a one tool fits all,

13572
13:45:26.494 --> 13:45:30.494
there's almost always going to
be trade offs. Alright, now that

13573
13:45:30.494 --> 13:45:32.494
we have all those dependencies
installed, if we look at our

13574
13:45:32.494 --> 13:45:36.494
package, JSON will have this
massive dev dependencies, we'll

13575
13:45:36.494 --> 13:45:38.494
have everything in Node modules
will have everything in yarn dot

13576
13:45:38.494 --> 13:45:41.494
lock. And of course, as we know,
in order for any of these to

13577
13:45:41.494 --> 13:45:45.494
actually work, we need to add
them into our Hardhead config.

13578
13:45:45.494 --> 13:45:48.494
Now, there's a lot of stuff to
add in here as well. So like

13579
13:45:48.494 --> 13:45:51.495
once again, if you want to come
to the heart at smart contract,

13580
13:45:51.495 --> 13:45:55.495
lottery, FCC, and go to the
Hardhead config, you can just

13581
13:45:55.495 --> 13:45:59.495
copy paste everything and place
it into your project so that you

13582
13:45:59.495 --> 13:46:02.495
don't have to always type
everything out yourself. Meclabs

13583
13:46:02.495 --> 13:46:05.495
Hardhead waffle anomic labs
started ether scan harder to

13584
13:46:05.495 --> 13:46:08.495
deploy slitted coverage, or had
gas reporter heart had contract

13585
13:46:08.495 --> 13:46:10.495
sizer, which we haven't talked
about yet. But we will Don't

13586
13:46:10.495 --> 13:46:14.495
worry. And then require dot env
dot config. And as you all know,

13587
13:46:14.495 --> 13:46:17.495
all these little semicolons are
popping up and those are going

13588
13:46:17.495 --> 13:46:20.495
to drive me absolutely crazy. So
once again, we can create a dot

13589
13:46:20.495 --> 13:46:25.495
prettier, RC. And if you want to
copy this as well, from one of

13590
13:46:25.495 --> 13:46:29.495
your previous projects are free
to do so. One thing that I added

13591
13:46:29.495 --> 13:46:33.495
in here was a print width of
100. This just changes how long

13592
13:46:33.495 --> 13:46:36.495
a line can be before it goes on
to a new line. That's the only

13593
13:46:36.495 --> 13:46:39.495
difference here. Now if we go to
our config and hit save, they go

13594
13:46:39.495 --> 13:46:43.495
away, thank goodness. Now if we
look at our solidity version,

13595
13:46:43.495 --> 13:46:46.495
we're currently using zero point
7.3. Let's go ahead and update

13596
13:46:47.495 --> 13:46:50.495
that to 8.8 or 8.7, or whatever
you want to use. Now that we

13597
13:46:50.495 --> 13:46:53.495
have all the basic setup, we can
begin coding our smart

13598
13:46:53.495 --> 13:47:00.495
contracts. So we first need to
create a new folder called

13599
13:47:00.495 --> 13:47:03.495
contracts where we're going to
store all of our contracts. And

13600
13:47:03.495 --> 13:47:07.495
let's go ahead and create a new
file called lottery dot soul or

13601
13:47:07.495 --> 13:47:09.495
raffle dot soul or whatever you
want to call it. I'm going to

13602
13:47:09.495 --> 13:47:13.495
call mine raffle dot soul. And
you might see this indexing

13603
13:47:13.495 --> 13:47:16.495
thing happened from time to
time. It's our hard hat,

13604
13:47:16.495 --> 13:47:20.495
solidity extension, indexing all
of our node modules. So it knows

13605
13:47:20.495 --> 13:47:22.495
how to highlight things and
knows how to work with

13606
13:47:22.495 --> 13:47:25.495
everything in our solidity
files. So that's what happens

13607
13:47:25.495 --> 13:47:28.495
when that pops up. Now before we
jump in and create it, let's

13608
13:47:28.495 --> 13:47:31.496
figure out what we're going to
do. So we're going to create our

13609
13:47:31.496 --> 13:47:34.496
raffle contract. And what do we
want people able to do? Well, we

13610
13:47:34.496 --> 13:47:37.496
probably want people be able to
enter the lottery, you know,

13611
13:47:37.496 --> 13:47:40.496
paying some amount, we're
probably going to want to be

13612
13:47:40.496 --> 13:47:44.496
able to pick a random winner.
But we want this to be

13613
13:47:44.496 --> 13:47:47.496
verifiably random, we want this
to be untampered with a bowl.

13614
13:47:47.496 --> 13:47:53.496
And we also want winner to be
selected every X minutes or

13615
13:47:53.496 --> 13:47:57.496
years or months, aka we want
this to be completely automated.

13616
13:47:57.496 --> 13:48:00.496
So we want to deploy the smart
contract and almost have no

13617
13:48:00.496 --> 13:48:03.496
maintenance almost have nobody
ever have to touch it again. And

13618
13:48:03.496 --> 13:48:05.496
it'll just automatically run
forever. This is the power of

13619
13:48:05.496 --> 13:48:08.496
smart contracts. As we know,
since we're picking a random

13620
13:48:08.496 --> 13:48:12.496
number, and we have some event
driven execution, we know that

13621
13:48:12.496 --> 13:48:15.496
we're going to need to use a
chain link Oracle, since we're

13622
13:48:15.496 --> 13:48:17.496
going to need to get the
randomness from outside the

13623
13:48:17.496 --> 13:48:21.496
blockchain. And we're going to
need to have that automated

13624
13:48:21.496 --> 13:48:25.496
execution. Because a smart
contract can execute itself, we

13625
13:48:25.496 --> 13:48:28.496
need somebody to automatically
trigger these. So to trigger

13626
13:48:28.496 --> 13:48:31.496
selecting a winner, we're gonna
have to use the chain link

13627
13:48:31.496 --> 13:48:34.496
keepers. And that's pretty much
going to be our entire code.

13628
13:48:34.496 --> 13:48:37.496
Now, I usually like to do this
before I start any project. And

13629
13:48:37.496 --> 13:48:39.496
the reason that I do a little
bit of brainstorming is because

13630
13:48:39.496 --> 13:48:42.496
we don't want to just jump in
and really do anything, we want

13631
13:48:42.496 --> 13:48:45.496
to have a good idea of what
we're trying to build so that we

13632
13:48:45.496 --> 13:48:48.496
can write tests for it, so that
we can know if we're going in

13633
13:48:48.496 --> 13:48:50.496
the right direction, etc. Now
that we have a good idea of

13634
13:48:50.496 --> 13:48:55.496
where we're going, let's build
it. So per usual, let's do spdx

13635
13:48:55.496 --> 13:49:01.496
license identifier. And my team
will do pragma solidity little

13636
13:49:01.496 --> 13:49:05.496
caret here, zero point 8.7, even
zoom out, just a hair will trash

13637
13:49:05.496 --> 13:49:09.496
that and we'll say contract,
raffle, we can even make sure

13638
13:49:09.496 --> 13:49:12.497
that we're not going crazy by
doing a little yarn Hardhead

13639
13:49:12.497 --> 13:49:15.497
compile and compiled
successfully, we want it to be

13640
13:49:15.497 --> 13:49:18.497
able to enter the lottery want
us to be able to enter it. So

13641
13:49:18.497 --> 13:49:22.497
maybe we'll create a function
called enter raffle. What else

13642
13:49:22.497 --> 13:49:25.497
do we want to do, we want to be
able to pick a random winner. So

13643
13:49:25.497 --> 13:49:30.497
maybe we'll create a function
called pick a random winner, and

13644
13:49:30.497 --> 13:49:33.497
boom. So let's comment out pick
random winner for now. And let's

13645
13:49:33.497 --> 13:49:36.497
just work on this enter raffle
thing. In the past, we've

13646
13:49:36.497 --> 13:49:39.497
created projects like Funmi,
where people can send ether to

13647
13:49:39.497 --> 13:49:42.497
our contracts or send whatever
native blockchain token to our

13648
13:49:42.497 --> 13:49:45.497
smart contracts using the
message dot value based off of

13649
13:49:45.497 --> 13:49:48.497
some USD value. For this one,
we're just going to have the

13650
13:49:48.497 --> 13:49:51.497
entrance fee instead be USD
based, it's just going to be

13651
13:49:51.497 --> 13:49:53.497
that native asset. So for our
enter raffle, we don't have to

13652
13:49:53.497 --> 13:49:57.497
set a USD price, we can just set
a minimum eath price. So up at

13653
13:49:57.497 --> 13:50:01.497
the top, let's pick our minimum
price. So we'll do a un 256

13654
13:50:01.497 --> 13:50:05.497
entrance fee. And now some of
our learnings from our last

13655
13:50:05.497 --> 13:50:09.497
section should come in here, we
now know that this entrance fee

13656
13:50:09.497 --> 13:50:12.497
is going to be a what, it's
going to be a storage variable.

13657
13:50:12.497 --> 13:50:15.497
So let's prepend it with s
underscore let's make a private

13658
13:50:15.497 --> 13:50:18.497
variable because we always want
to set our visibility. But let's

13659
13:50:18.497 --> 13:50:21.497
have the entrance fee be
configurable. Well, let's create

13660
13:50:21.497 --> 13:50:24.497
a constructor now. And we'll
have this entrance fee be

13661
13:50:24.497 --> 13:50:27.497
settable in our constructor, so
our constructor will take a UNT

13662
13:50:27.497 --> 13:50:33.497
two to the sixth entrance fee, s
underscore entrance fee equals

13663
13:50:33.497 --> 13:50:36.497
entrance fee. Well, if we're
gonna only set this one time, we

13664
13:50:36.497 --> 13:50:38.497
might as well make this a
constant or an immutable

13665
13:50:38.497 --> 13:50:41.497
variable. So let's make this an
immutable variable so that we

13666
13:50:41.497 --> 13:50:46.497
save some gas we'll change this
from S to I and now we're saying

13667
13:50:46.497 --> 13:50:50.498
you interviewed six private
immutable I entrance fee equals

13668
13:50:50.498 --> 13:50:53.498
entrance fee. Now we probably
are going to want other users to

13669
13:50:53.498 --> 13:50:56.498
see the entrance fee. So down
below, we can create function

13670
13:50:56.498 --> 13:50:59.498
get entrance fee, and this will
be a public view function which

13671
13:50:59.498 --> 13:51:04.498
will returns a UN to the set
Next, and we'll just say return

13672
13:51:04.498 --> 13:51:07.498
entrance fee. Now we have a
function that users can call to

13673
13:51:07.498 --> 13:51:10.498
get the entrance fee. But we, as
developers can use this AI

13674
13:51:10.498 --> 13:51:13.498
entrance fee to know this is an
immutable variable. This is

13675
13:51:13.498 --> 13:51:17.498
pretty cheap gas wise for us to
read from in our enter raffle,

13676
13:51:17.498 --> 13:51:20.498
we've done a ton of these
before, all we need to do is we

13677
13:51:20.498 --> 13:51:24.498
just need to require the message
dot value is greater than that I

13678
13:51:24.498 --> 13:51:27.498
underscore entrance fee, what
we've learned before about those

13679
13:51:27.498 --> 13:51:32.498
error codes, so we could use
require message dot value, or we

13680
13:51:32.498 --> 13:51:35.498
could do one of these customers,
which is going to be a lot more

13681
13:51:35.498 --> 13:51:38.498
gas efficient, because instead
of storing this string, we're

13682
13:51:38.498 --> 13:51:41.498
just going to store an error
code in our smart contract. So

13683
13:51:41.498 --> 13:51:44.498
let's do that. Instead, we'll
say if the message dot value is

13684
13:51:44.498 --> 13:51:48.498
less than our eye entrance fee,

13685
13:51:48.498 --> 13:51:52.498
then we're just going to revert
the whole transaction with some

13686
13:51:52.498 --> 13:51:56.498
error code. And we'll use a best
practice naming raffle

13687
13:51:56.498 --> 13:52:02.498
underscore underscore not enough
eath entered. And we'll grab

13688
13:52:02.498 --> 13:52:06.498
this arrow code. And we'll have
if the user doesn't send enough

13689
13:52:06.498 --> 13:52:10.498
value will revert with not
enough eath entered now that we

13690
13:52:10.498 --> 13:52:13.498
know they're calling into raffle
with enough value, we're

13691
13:52:13.498 --> 13:52:16.498
probably going to want to keep
track of all the users who

13692
13:52:16.498 --> 13:52:19.498
actually enter our raffle. That
way, when we pick a winner, we

13693
13:52:19.498 --> 13:52:22.498
know who's in the running. So
let's create an array of players

13694
13:52:22.498 --> 13:52:26.498
at the top error here. And then
just to make this look even

13695
13:52:26.498 --> 13:52:29.498
nicer, we'll do a little comment
here. And we'll say state

13696
13:52:29.498 --> 13:52:32.499
variables. And we'll combine
both our storage and are not

13697
13:52:32.499 --> 13:52:35.499
storage variables just in this
state variable section. So we'll

13698
13:52:35.499 --> 13:52:41.499
do address array players. Now
players, of course, is going to

13699
13:52:41.499 --> 13:52:43.499
have to be in storage, because
we're going to modify this a

13700
13:52:43.499 --> 13:52:45.499
lot, we're going to be adding
and subtracting players all the

13701
13:52:45.499 --> 13:52:49.499
time. So we're going to do s
players will make this private

13702
13:52:49.499 --> 13:52:53.499
as well. And we're going to make
this address payable players

13703
13:52:53.499 --> 13:52:55.499
because one of these players
wins, we're going to need to

13704
13:52:55.499 --> 13:52:59.499
have to pay them. So we'll make
this address payable private as

13705
13:52:59.499 --> 13:53:01.499
players. And since we're going
to make this private, and it's

13706
13:53:01.499 --> 13:53:04.499
probably good that we know who's
in the players array, we'll even

13707
13:53:04.499 --> 13:53:09.499
do function it player. This will
be a public view that returns an

13708
13:53:09.499 --> 13:53:15.499
address of one of these players.
And we'll just return s players

13709
13:53:15.499 --> 13:53:19.499
of index will have this
function, take a un 256 index as

13710
13:53:19.499 --> 13:53:22.499
an input parameter, we know that
players is going to be a storage

13711
13:53:22.499 --> 13:53:25.499
variable. And we're going to add
it to our enter raffle Oh, and

13712
13:53:25.499 --> 13:53:29.499
we definitely want our Inter
raffle to be public and to be

13713
13:53:29.499 --> 13:53:33.499
payable. Since we're having
people send message dot value,

13714
13:53:33.499 --> 13:53:36.499
and we want anyone to be able to
enter our raffle. So it'll be

13715
13:53:36.499 --> 13:53:39.499
public, it'll be payable, it'll
be perfect. Now that we have our

13716
13:53:39.499 --> 13:53:43.499
array, and someone's entered the
raffle, we'll do s players dot

13717
13:53:43.499 --> 13:53:49.499
push message dot sender. Now,
this doesn't actually work

13718
13:53:49.499 --> 13:53:52.499
because message dot sender isn't
a payable address. So we'll need

13719
13:53:52.499 --> 13:53:56.499
to typecast it as a payable
address just by wrapping it in

13720
13:53:56.499 --> 13:53:59.499
payable. So now we have a way to
keep track of all the players

13721
13:53:59.499 --> 13:54:00.499
that are entering

13722
13:54:00.499 --> 13:54:05.499
a raffle. Now one of the
concepts that we haven't gone

13723
13:54:05.499 --> 13:54:08.499
over yet is actually going to be
events. And events are really

13724
13:54:08.499 --> 13:54:11.500
important to our smart
contracts. Whenever we update a

13725
13:54:11.500 --> 13:54:15.500
dynamic object, like an array or
a mapping, we always want to

13726
13:54:15.500 --> 13:54:18.500
omit an event when we get to
less than 10. And then

13727
13:54:18.500 --> 13:54:22.500
especially less than 15 with the
next Jas and if T marketplace,

13728
13:54:22.500 --> 13:54:25.500
these events will make a ton of
sense, especially for front end

13729
13:54:25.500 --> 13:54:29.500
developers. So right now events
might be a little bit of a weird

13730
13:54:29.500 --> 13:54:32.500
thing for you as we explain it.
But as we continue on, they'll

13731
13:54:32.500 --> 13:54:34.500
start to make more and more
sense. So we're going to start

13732
13:54:34.500 --> 13:54:37.500
adding events to our smart
contracts. Whenever we update

13733
13:54:37.500 --> 13:54:40.500
one of these dynamically sized
data structures. And to learn

13734
13:54:40.500 --> 13:54:42.500
more about events and how to use
them. We're gonna watch another

13735
13:54:42.500 --> 13:54:45.500
video that explains all about
events. You can actually follow

13736
13:54:45.500 --> 13:54:48.500
along with this video as a side
project. But let's learn all

13737
13:54:48.500 --> 13:54:50.500
about events. Now, if you've
worked with solidity, you've

13738
13:54:50.500 --> 13:54:54.500
probably seen these things
called events before or maybe

13739
13:54:54.500 --> 13:54:56.500
you haven't seen something like
events. But you've always

13740
13:54:56.500 --> 13:54:59.500
wondered how chain link or the
graph or some of these other off

13741
13:54:59.500 --> 13:55:02.500
chain protocols work under the
hood. And in this video, we're

13742
13:55:02.500 --> 13:55:05.500
gonna learn about logging and
events in solidity, viewing

13743
13:55:05.500 --> 13:55:08.500
those events on ether scan, and
then working with them in hard

13744
13:55:08.500 --> 13:55:12.500
hat. Now it's the Ethereum
virtual machine, or EVM. That

13745
13:55:12.500 --> 13:55:15.500
makes a lot of these block
chains tick, like Aetherium. And

13746
13:55:15.500 --> 13:55:19.500
the EVM has this functionality
called a logging functionality.

13747
13:55:19.500 --> 13:55:22.500
When things happen on a
blockchain, the EVM writes these

13748
13:55:22.500 --> 13:55:26.500
things to a specific data
structure called its log, we can

13749
13:55:26.500 --> 13:55:28.500
actually read these logs from
our blockchain nodes that we

13750
13:55:28.500 --> 13:55:32.500
run. In fact, if you run a node
or you connect to a node, you

13751
13:55:32.500 --> 13:55:37.500
can make a F get logs call to
get the logs. Now inside these

13752
13:55:37.500 --> 13:55:40.500
logs is an important piece of
logging called events. And this

13753
13:55:40.500 --> 13:55:43.500
is the main piece that we're
gonna be talking about today.

13754
13:55:43.500 --> 13:55:46.500
events allow you to print
information to this logging

13755
13:55:46.500 --> 13:55:49.500
structure in a way that's more
gas efficient than actually

13756
13:55:49.500 --> 13:55:53.501
saving it to something like a
storage variable. These events

13757
13:55:53.501 --> 13:55:56.501
and logs live in this special
data structure that isn't

13758
13:55:56.501 --> 13:56:00.501
accessible to smart contracts.
That's why it's cheaper because

13759
13:56:00.501 --> 13:56:02.501
smart contracts can access them
so that If the trade off here,

13760
13:56:02.501 --> 13:56:05.501
we can still print some
information that's important to

13761
13:56:05.501 --> 13:56:09.501
us without having to save it in
a storage variable, which is

13762
13:56:09.501 --> 13:56:12.501
going to take up much more gas.
Each one of these events is tied

13763
13:56:12.501 --> 13:56:16.501
to the smart contract or account
address that emitted this event

13764
13:56:16.501 --> 13:56:19.501
in these transactions. listening
for these events is incredibly

13765
13:56:19.501 --> 13:56:22.501
helpful. Let's say for example,
you want to do something every

13766
13:56:22.501 --> 13:56:26.501
time somebody calls a transfer
function. Instead of always

13767
13:56:26.501 --> 13:56:29.501
reading all the variables and
looking for something to flip

13768
13:56:29.501 --> 13:56:34.501
and switch, all you have to do
is say, listen for event. So a

13769
13:56:34.501 --> 13:56:37.501
transaction happened, an event
is emitted. And we can listen

13770
13:56:37.501 --> 13:56:40.501
for these events. This is how a
lot of off chain infrastructure

13771
13:56:40.501 --> 13:56:44.501
works. When you're on a website,
and that website reloads when a

13772
13:56:44.501 --> 13:56:47.501
transaction completes, it
actually was listening for that

13773
13:56:47.501 --> 13:56:51.501
transaction to finish listening
for that event to be emitted, so

13774
13:56:51.501 --> 13:56:53.501
that it could reload or it could
do something else. It's

13775
13:56:53.501 --> 13:56:57.501
incredibly important for front
ends. It's also incredibly

13776
13:56:57.501 --> 13:57:00.501
important for things like chain
link, and the graph in the chain

13777
13:57:00.501 --> 13:57:03.501
link network. A chain link node
is actually listening for

13778
13:57:03.501 --> 13:57:07.501
request data events for to get a
random number, make an API call,

13779
13:57:07.501 --> 13:57:11.501
or etc. Sometimes there are way
too many events. And you need to

13780
13:57:11.501 --> 13:57:15.501
index them in a way that makes
sense that you can query all

13781
13:57:15.501 --> 13:57:18.501
these events that happen at a
later date. The graph listens

13782
13:57:18.501 --> 13:57:21.501
for these events and stores them
in the graph so that they're

13783
13:57:21.501 --> 13:57:25.501
easy to query later on. So
events are incredibly powerful.

13784
13:57:25.501 --> 13:57:27.501
And they have a wide range of
uses. They're also good for

13785
13:57:27.501 --> 13:57:30.502
testing and some other stuff,
but you get the picture. They're

13786
13:57:30.502 --> 13:57:33.502
really sick. Now that we know
what events are, let's look at

13787
13:57:33.502 --> 13:57:36.502
what they look like how we can
use them and how we might use

13788
13:57:36.502 --> 13:57:39.502
them in our smart contract
development suite. Now here's

13789
13:57:39.502 --> 13:57:42.502
what an event is going to look
like. We have an event here

13790
13:57:42.502 --> 13:57:46.502
called stored number. So we have
basically a new type of event

13791
13:57:46.502 --> 13:57:49.502
called stored number. We're
saying, hey, solidity, hey,

13792
13:57:49.502 --> 13:57:53.502
smart contract, we have this new
event thing, we're going to be

13793
13:57:53.502 --> 13:57:57.502
omitting things of typed stored
number in the future. When we

13794
13:57:57.502 --> 13:58:00.502
emit this event, it's going to
have these four parameters, it's

13795
13:58:00.502 --> 13:58:03.502
going to have a unique 256. For
called old number. Are you

13796
13:58:03.502 --> 13:58:06.502
interested? Is it called new
number are you intimidated six

13797
13:58:06.502 --> 13:58:09.502
called add a number and an
address called center. Now for

13798
13:58:09.502 --> 13:58:10.502
the astute people here, you

13799
13:58:10.502 --> 13:58:13.502
might have noticed that there
was another keyword in here, the

13800
13:58:13.502 --> 13:58:17.502
index to keyword and this is a
really important keyword. When

13801
13:58:17.502 --> 13:58:19.502
we omit one of these events,
there are two kinds of

13802
13:58:19.502 --> 13:58:23.502
parameters, there are the index
parameters and the non indexed

13803
13:58:23.502 --> 13:58:27.502
parameters, you can have up to
three index parameters. And

13804
13:58:27.502 --> 13:58:30.502
they're also known as topics. So
if you see a topic, you know

13805
13:58:30.502 --> 13:58:33.502
that that's going to be an
indexed parameter. Index

13806
13:58:33.502 --> 13:58:37.502
parameters are parameters that
are much easier to search for,

13807
13:58:37.502 --> 13:58:40.502
and much easier to query than
the non index parameters. In

13808
13:58:40.502 --> 13:58:43.502
fact, we recommend F get logs
function, it even has a

13809
13:58:43.502 --> 13:58:46.502
parameter allows us to search
for specific topics. So it's

13810
13:58:46.502 --> 13:58:50.502
much more searchable than the
non indexed ones. The non

13811
13:58:50.502 --> 13:58:53.502
indexed ones are harder to
search because they get ABI

13812
13:58:53.502 --> 13:58:56.502
encoded, and you have to know
the API in order to decode them.

13813
13:58:56.502 --> 13:58:58.502
Now, this is told our smart
contract that there is a new

13814
13:58:58.502 --> 13:59:02.502
type of stored number, a new
kind of event here, we need to

13815
13:59:02.502 --> 13:59:06.502
actually emit that event in
order to store that data into

13816
13:59:06.502 --> 13:59:10.503
the logging data structure of
the EVM. To do that, we need to

13817
13:59:10.503 --> 13:59:13.503
do something that looks like
this. This is what it looks like

13818
13:59:13.503 --> 13:59:16.503
when we emit an event, it looks
very similar to calling a

13819
13:59:16.503 --> 13:59:21.503
function. So you call a mitt and
then the name of the event. And

13820
13:59:21.503 --> 13:59:24.503
then you add all the parameters
in there that you like. Here's

13821
13:59:24.503 --> 13:59:27.503
the full example of a smart
contract that has an event and

13822
13:59:27.503 --> 13:59:30.503
is going to be the example that
we walked through in hard hat.

13823
13:59:30.503 --> 13:59:33.503
Now in this smart contract,
whenever anybody calls the store

13824
13:59:33.503 --> 13:59:37.503
function, we're going to omit
this event. Here's an example of

13825
13:59:37.503 --> 13:59:41.503
a transaction where we call the
store function with a value of

13826
13:59:41.503 --> 13:59:45.503
one, let's look into the logs to
see what this event actually is

13827
13:59:45.503 --> 13:59:49.503
going to look like an event is
going to be broken down like so

13828
13:59:49.503 --> 13:59:52.503
the address of the contract or
account, the event is emitted

13829
13:59:52.503 --> 13:59:56.503
from the topics or the index
parameters of the event data.

13830
13:59:56.503 --> 14:00:01.503
This is the ABI encoded non
index parameters of the event.

13831
14:00:01.503 --> 14:00:04.503
What does this mean? This means
that we took those parameters

13832
14:00:04.503 --> 14:00:08.503
that were non indexed, we match
them together with their API or

13833
14:00:08.503 --> 14:00:11.503
application binary interface,
pumped them through an encoding

13834
14:00:11.503 --> 14:00:14.503
algorithm, and boom, this is
what we got. If you have the

13835
14:00:14.503 --> 14:00:17.503
API, they're very easy to
decode. If you don't have the

13836
14:00:17.503 --> 14:00:22.503
ABI they are very hard to decode
these non indexed parameters

13837
14:00:22.503 --> 14:00:26.503
cost less gas to pump into the
logs. Now in this particular

13838
14:00:26.503 --> 14:00:29.503
contract, since we have verified
the code, we verified the

13839
14:00:29.503 --> 14:00:33.503
contract ether scan knows what
the ABI is, and we can view this

13840
14:00:33.503 --> 14:00:37.503
in Deke or decoded mode. Hex
mode is obviously the non

13841
14:00:37.503 --> 14:00:41.503
decoded mode, or in its raw, hex
or hexadecimal or encoded mode.

13842
14:00:41.503 --> 14:00:44.503
You can read more about the
layout of these events in the

13843
14:00:44.503 --> 14:00:50.503
solidity docs. Now, so that's
the basic introduction of

13844
14:00:50.503 --> 14:00:52.504
events. And for those of you who
want to watch the rest of that

13845
14:00:52.504 --> 14:00:55.504
video, and who wants to actually
practice using events yourself,

13846
14:00:55.504 --> 14:00:58.504
there's a link to these videos
and the code repository

13847
14:00:58.504 --> 14:01:00.504
associated with that video, if
you want to play with it, and if

13848
14:01:00.504 --> 14:01:02.504
you want to learn more, so feel
free Ready to refer back to the

13849
14:01:02.504 --> 14:01:05.504
full blockchain solidity course,
Jas, if you want to go deeper

13850
14:01:05.504 --> 14:01:07.504
into events now that we're back,
and we've learned a little bit

13851
14:01:07.504 --> 14:01:10.504
more about events, let's add
some events to this contract.

13852
14:01:10.504 --> 14:01:13.504
Remember, these events get
emitted to a data storage

13853
14:01:13.504 --> 14:01:16.504
outside of this smart contract.
Let's create an event called

13854
14:01:16.504 --> 14:01:21.504
raffle enter a good syntax for
naming events, name events, with

13855
14:01:21.504 --> 14:01:25.504
the function name reversed. So
for enter raffle, we're gonna

13856
14:01:25.504 --> 14:01:28.504
say raffle entered. So up at the
top below our state variables,

13857
14:01:28.504 --> 14:01:32.504
but above our constructor, we'll
create a new section called

13858
14:01:32.504 --> 14:01:37.504
events. And we'll create our
first event. So we'll do event,

13859
14:01:37.504 --> 14:01:40.504
raffle, Enter. And we'll just
have this raffle enter take one

13860
14:01:40.504 --> 14:01:45.504
index parameter, it'll be an
address indexed player. So in

13861
14:01:45.504 --> 14:01:49.504
our Inter raffle, we're going to
say omit raffle enter. And we're

13862
14:01:49.504 --> 14:01:52.504
just going to pass it message
dot sender. I'm going to remove

13863
14:01:52.504 --> 14:01:55.504
these comments for now. But feel
free to leave them in as you

13864
14:01:55.504 --> 14:01:59.504
code along. Now in this part of
my raffle coding or my lottery

13865
14:01:59.504 --> 14:02:02.504
coding process, I probably would
start already writing some tests

13866
14:02:02.504 --> 14:02:05.504
and already writing some deploy
scripts. The reason that we do

13867
14:02:05.504 --> 14:02:08.504
this is it's good to test our
functionality as we progress.

13868
14:02:08.504 --> 14:02:11.504
And oftentimes, when I'm writing
smart contracts, I'm constantly

13869
14:02:11.504 --> 14:02:14.504
flipping back and forth between
my deploy scripts, my contracts

13870
14:02:14.504 --> 14:02:17.504
and my tests to make sure
everything is doing exactly what

13871
14:02:17.504 --> 14:02:19.504
I want it to do for the purpose
of this course. And just to make

13872
14:02:19.504 --> 14:02:22.504
it easy for you to learn and
follow along, we're not going to

13873
14:02:22.504 --> 14:02:24.504
do that. And we're just going to
keep writing our smart contract

13874
14:02:24.504 --> 14:02:30.505
almost to complete and then move
to our deploy scripts and tests.

13875
14:02:30.505 --> 14:02:33.505
So in its minimalistic sense, we
essentially have a way for

13876
14:02:33.505 --> 14:02:37.505
people to enter our raffle. Now
we need a way to pick the random

13877
14:02:37.505 --> 14:02:40.505
winner. And this is where we're
going to need chain link VRF and

13878
14:02:40.505 --> 14:02:43.505
chain link keepers. So let's
again, watch some sub lessons

13879
14:02:43.505 --> 14:02:46.505
about learning about chain link
VRF. And learning about chain

13880
14:02:46.505 --> 14:02:49.505
link keepers. We've made some
videos about these before. So

13881
14:02:49.505 --> 14:02:51.505
we're just going to play these
videos. So you can learn about

13882
14:02:51.505 --> 14:02:54.505
how taling VRF version two
works, and also how chain link

13883
14:02:54.505 --> 14:02:56.505
keepers works, then we're going
to come back and we're going to

13884
14:02:56.505 --> 14:02:59.505
add them into our contracts
here. If you're already

13885
14:02:59.505 --> 14:03:01.505
familiar, and you already played
with them, feel free to skip

13886
14:03:01.505 --> 14:03:04.505
those sections. And we'll just
get to building them here.

13887
14:03:04.505 --> 14:03:06.505
Hi, my name is Steven fluid. And
today we're going to be taking a

13888
14:03:06.505 --> 14:03:10.505
look at chain links VRF. version
two, version two has a few

13889
14:03:10.505 --> 14:03:12.505
different mental models that we
should be aware of. And I want

13890
14:03:12.505 --> 14:03:15.505
to show you what it feels like
to be using it. The big

13891
14:03:15.505 --> 14:03:18.505
important thing to know about
Vera version two is that instead

13892
14:03:18.505 --> 14:03:21.505
of the Vera one model where
you'd be funding your contract

13893
14:03:21.505 --> 14:03:24.505
with Link, instead, you're going
to be funding a subscription,

13894
14:03:24.505 --> 14:03:27.505
which is basically an account
that allows you to fund and

13895
14:03:27.505 --> 14:03:31.505
maintain balance for multiple
consumer contracts. Let's dive

13896
14:03:31.505 --> 14:03:34.505
into the docs and see what using
Vera fie two looks and feels

13897
14:03:34.505 --> 14:03:37.505
like. In order to show this off
a little bit. I'm going to dive

13898
14:03:37.505 --> 14:03:40.505
right into the get a random
number guide in the chain link

13899
14:03:40.505 --> 14:03:43.505
documentation. And so it's going
to go through a few the

13900
14:03:43.505 --> 14:03:44.505
requirements of some of the
technology we're going to use

13901
14:03:44.505 --> 14:03:47.505
today. And the first thing it's
going to ask us to do is to make

13902
14:03:47.505 --> 14:03:50.505
sure that we are on the Rinkeby
test net. So let's go ahead and

13903
14:03:50.505 --> 14:03:54.505
jump over to Rinkeby. Make sure
my meta mask is unlocked here.

13904
14:03:54.505 --> 14:03:58.505
And now that I'm on Rinkeby,
great, I should be able to use

13905
14:03:58.505 --> 14:04:02.505
the VIP version to test net. Now
we're going to jump over to

13906
14:04:02.505 --> 14:04:05.505
subscription manager. And the
subscription manager is where

13907
14:04:05.505 --> 14:04:07.505
we're going to manage our
subscription account. Basically,

13908
14:04:07.505 --> 14:04:10.505
this is the place that you put
the funds in order to be able to

13909
14:04:10.505 --> 14:04:13.506
use it across a bunch of
different chains. So we're going

13910
14:04:13.506 --> 14:04:16.506
to go ahead and connect our
wallet here in order to use the

13911
14:04:16.506 --> 14:04:20.506
subscription app. And then we're
going to go ahead and create a

13912
14:04:20.506 --> 14:04:22.506
new subscription. So we'll just
use my address as the

13913
14:04:22.506 --> 14:04:27.506
subscription address here. I'll
approve the creation. And as

13914
14:04:27.506 --> 14:04:29.506
soon as that transaction is
confirmed, our subscription

13915
14:04:29.506 --> 14:04:33.506
should be created. Alright, now
we have a subscription.

13916
14:04:33.506 --> 14:04:35.506
Basically, this is the account
where we're going to fund it.

13917
14:04:35.506 --> 14:04:38.506
And then we can use that account
for all of our random Miss

13918
14:04:38.506 --> 14:04:42.506
requests. So I'm gonna go ahead
and just put in 10 link here,

13919
14:04:42.506 --> 14:04:46.506
you can put in however much you
want. The price and link of

13920
14:04:46.506 --> 14:04:49.506
every random number you request,
it's going to be based on the

13921
14:04:49.506 --> 14:04:54.506
current gas rates on a given
chain, as well as the gasoline

13922
14:04:54.506 --> 14:04:57.506
that you've chosen. On our funds
have been added, let's go ahead

13923
14:04:57.506 --> 14:05:00.506
and add a consumer contract. So
it's asking us for consumer

13924
14:05:00.506 --> 14:05:02.506
address, we don't actually have
a consumer address yet. So let's

13925
14:05:02.506 --> 14:05:06.506
go ahead and jump over to the
documentation and create a

13926
14:05:06.506 --> 14:05:09.506
contract that is going to
request a number. So if you

13927
14:05:09.506 --> 14:05:12.506
scroll down, you're going to see
this Vera fee to consumer that

13928
14:05:12.506 --> 14:05:14.506
soul contract that we can open
it in remix, let's just jump

13929
14:05:14.506 --> 14:05:18.506
right there. We're gonna notice
a few different things in this

13930
14:05:18.506 --> 14:05:20.506
contract at the top, we've got
some input. So now you've got

13931
14:05:20.506 --> 14:05:23.506
VRF, consumer base version two,
we've got an interface for the

13932
14:05:23.506 --> 14:05:27.506
VRF coordinator, and then also a
reference to the link token

13933
14:05:27.506 --> 14:05:30.506
interface. So all of those are
specified for you on the Rinkeby

13934
14:05:30.506 --> 14:05:33.506
network here in the example
code. And then you can refer to

13935
14:05:33.506 --> 14:05:35.506
the documentation for whatever
chain you're going to be

13936
14:05:35.506 --> 14:05:39.506
deploying to. And then you're
going to see a few new options

13937
14:05:39.506 --> 14:05:43.506
here. So the key hash option is
the way that you specify that

13938
14:05:43.506 --> 14:05:46.506
gasoline that was described in
the documentation. So depending

13939
14:05:46.506 --> 14:05:49.506
on the key hash you choose for
the given chain you're on the

13940
14:05:49.506 --> 14:05:53.507
gas limit will be set
differently for your random

13941
14:05:53.507 --> 14:05:56.507
number requests. So for example,
on a theory main net, we have a

13942
14:05:56.507 --> 14:06:00.507
200 way key hash 500 Wiki hash
and 1000 graykey hash. You can

13943
14:06:00.507 --> 14:06:03.507
also see in our contract Hear
that we have a callback estimate

13944
14:06:03.507 --> 14:06:06.507
that you're in charge of. So
depending on how much gas you're

13945
14:06:06.507 --> 14:06:09.507
willing to spend in the fulfill
random number, you should set

13946
14:06:09.507 --> 14:06:13.507
this value appropriately. Next
up is request confirmations. So

13947
14:06:13.507 --> 14:06:15.507
this was something in verify
would be one that you could not

13948
14:06:15.507 --> 14:06:18.507
control. But here now, depending
on the chain you're on,

13949
14:06:18.507 --> 14:06:20.507
depending on the request and the
type nature of the request you

13950
14:06:20.507 --> 14:06:24.507
want to make, you can actually
change this number. And then one

13951
14:06:24.507 --> 14:06:26.507
of the most important and useful
features that gives you a lot

13952
14:06:26.507 --> 14:06:30.507
more flexibility and control of
your VRF is you can actually

13953
14:06:30.507 --> 14:06:34.507
specify the number of random
numbers you want. And so you

13954
14:06:34.507 --> 14:06:36.507
specify the number words, and
then that will specify how many

13955
14:06:36.507 --> 14:06:42.507
random you went to 56 as you get
back from the network. All right

13956
14:06:42.507 --> 14:06:45.507
here in the constructor, we're
gonna see a address for the

13957
14:06:45.507 --> 14:06:48.507
coordinator and address for the
link token. And then you'll see

13958
14:06:48.507 --> 14:06:50.507
that the subscription ID is
going to be created as we deploy

13959
14:06:50.507 --> 14:06:54.507
the contract. And so I'm gonna
go ahead and get that. So if you

13960
14:06:54.507 --> 14:06:56.507
remember when we created the
subscription after we found it,

13961
14:06:56.507 --> 14:06:59.507
and we see this subscription ID,
and now when I deploy this, I'm

13962
14:06:59.507 --> 14:07:01.507
going to use that subscription
ID. And we've got two methods

13963
14:07:01.507 --> 14:07:04.507
that should look very familiar,
we've got fulfill randomness

13964
14:07:05.507 --> 14:07:07.507
method that takes in randomness
is going to be fulfilled by the

13965
14:07:07.507 --> 14:07:10.507
Bureau of Oracle, as well as you
got request random words, which

13966
14:07:10.507 --> 14:07:13.507
is how we're actually going to
initiate the request to the

13967
14:07:13.507 --> 14:07:15.507
Oracle. So I think we're
actually are already ready to go

13968
14:07:15.507 --> 14:07:19.507
ahead and deploy this. So let's
jump to the deploy screen here

13969
14:07:19.507 --> 14:07:21.507
and select the right contract,
which in our case, is your FB to

13970
14:07:21.507 --> 14:07:24.507
consumer. And I'm going to make
sure that I am on injected web

13971
14:07:24.507 --> 14:07:27.507
three so that we can actually
deploy to the Rinkeby network.

13972
14:07:27.507 --> 14:07:29.507
And I'm going to paste in the
subscription ID here. And I'm

13973
14:07:29.507 --> 14:07:35.508
going to deploy, let's go ahead
and pay for that transaction.

13974
14:07:35.508 --> 14:07:38.508
And as soon as that is confirmed
by the network will show up

13975
14:07:38.508 --> 14:07:41.508
here, and we'll be able to copy
this address, and then add that

13976
14:07:41.508 --> 14:07:45.508
as a consumer and authorize this
contract to use my subscription

13977
14:07:45.508 --> 14:07:51.508
account. So let's go ahead and
authorize this with them another

13978
14:07:51.508 --> 14:07:56.508
Metamask transaction.

13979
14:07:56.508 --> 14:07:58.508
Alright, we can have your
subscription, we can see how

13980
14:07:58.508 --> 14:08:00.508
much link we funded it with. And
we can see our consumer

13981
14:08:00.508 --> 14:08:04.508
contract. So now by doing this,
we've authorized our consumer

13982
14:08:04.508 --> 14:08:08.508
contract to make requests for
randomness. So let's go ahead

13983
14:08:08.508 --> 14:08:10.508
and make a request for
randomness here. So we're gonna

13984
14:08:10.508 --> 14:08:13.508
go back to our contract that we
deployed here. And we're just

13985
14:08:14.508 --> 14:08:16.508
gonna use the remix interface
here to keep things simple. And

13986
14:08:16.508 --> 14:08:19.508
I'm going to request some
randomness. So obviously, this

13987
14:08:19.508 --> 14:08:23.508
is going to use all of the
configuration that I specified

13988
14:08:23.508 --> 14:08:25.508
in my contract, just kind of
hard coded here. So we're gonna

13989
14:08:25.508 --> 14:08:27.508
get to words of random is here.
So we're gonna hit request

13990
14:08:27.508 --> 14:08:32.508
randomness, confirm the Rigby
transaction. And then as soon as

13991
14:08:32.508 --> 14:08:34.508
that transaction comes back, we
should notice that we actually

13992
14:08:35.508 --> 14:08:38.508
have a request. And then what
we'll be doing is we'll be

13993
14:08:38.508 --> 14:08:41.508
waiting for the Oracle to call
fulfill random words on our

13994
14:08:41.508 --> 14:08:44.508
contract. And then we'll be
storing all of those random

13995
14:08:44.508 --> 14:08:48.508
words in this s random words,
storage variable. Let's go ahead

13996
14:08:48.508 --> 14:08:50.508
and check to see if our random
numbers come back from the

13997
14:08:50.508 --> 14:08:53.508
Oracle. So I'll go in here into
random words. And let's request

13998
14:08:53.508 --> 14:08:56.508
the zeroeth item of the array
looks like we've got a random

13999
14:08:56.508 --> 14:08:58.508
number there. And because we
requested two random numbers, we

14000
14:08:58.508 --> 14:09:03.508
should also have an item in
index one. All right, we we've

14001
14:09:03.508 --> 14:09:06.508
got our randomness there. And if
we go back to the subscription

14002
14:09:06.508 --> 14:09:09.508
manager app, you're going to see
that there's actually an event

14003
14:09:09.508 --> 14:09:11.509
history item here, we'll see
that we spent about point three,

14004
14:09:11.509 --> 14:09:16.509
three link to get those two
random numbers, we've just taken

14005
14:09:16.509 --> 14:09:19.509
a journey to see what it looks
like and feels like to use Veera

14006
14:09:19.509 --> 14:09:20.509
version two,

14007
14:09:20.509 --> 14:09:22.509
now that we've learned a little
bit more about chainlink VRF, I

14008
14:09:22.509 --> 14:09:25.509
hope that you took some time to
go to doxa chain link and play

14009
14:09:25.509 --> 14:09:28.509
around with it a little bit so
that you understand what's

14010
14:09:28.509 --> 14:09:31.509
really going on, we're going to
use this sample contract in here

14011
14:09:31.509 --> 14:09:34.509
to create our function that's
going to pick our random winner.

14012
14:09:34.509 --> 14:09:36.509
This is an on chain contract
that coordinates with a

14013
14:09:36.509 --> 14:09:40.509
verifiably random chain link
node to give us a random number,

14014
14:09:40.509 --> 14:09:42.509
you could look at the code
directly on chain, or you can

14015
14:09:42.509 --> 14:09:46.509
come right to the chain link
GitHub and look at all the code

14016
14:09:46.509 --> 14:09:49.509
for how this is actually
happening provably and randomly.

14017
14:09:49.509 --> 14:09:51.509
And we'll have a link to this in
the GitHub repo associated with

14018
14:09:51.509 --> 14:09:56.509
this course. So we're going to
create our function here called

14019
14:09:56.509 --> 14:09:59.509
pick a random winner, this
function is going to be called

14020
14:09:59.509 --> 14:10:01.509
by the chain link keepers
network so that this can

14021
14:10:01.509 --> 14:10:04.509
automatically run without us
having to interact with it. And

14022
14:10:04.509 --> 14:10:07.509
actually, while we're updating
this, I want to add some some

14023
14:10:07.509 --> 14:10:11.509
stars here saying view slash
pure functions. Now our pick

14024
14:10:11.509 --> 14:10:13.509
random winner function, we're
actually not going to make

14025
14:10:13.509 --> 14:10:16.509
public we're going to make
external, external functions are

14026
14:10:16.509 --> 14:10:19.509
a little bit cheaper than public
functions. Because solidity

14027
14:10:19.509 --> 14:10:22.509
knows that our own contract can
call this, we're actually going

14028
14:10:22.509 --> 14:10:25.509
to change the name of this
function, as well, very soon,

14029
14:10:25.509 --> 14:10:27.509
but we'll get to that in a
little bit. So in order for us

14030
14:10:27.509 --> 14:10:30.509
to pick a random winner, we
actually have to do two things,

14031
14:10:30.509 --> 14:10:34.509
we first have to request the
random number. And then once we

14032
14:10:34.509 --> 14:10:38.509
get it, do something with it. So
chainlink VRF is a two

14033
14:10:38.509 --> 14:10:42.509
transaction process. And this is
actually intentional. Having

14034
14:10:42.509 --> 14:10:45.509
random numbers in two
transactions is actually also

14035
14:10:45.509 --> 14:10:48.509
much better than having it in
one. If it's just one

14036
14:10:48.509 --> 14:10:51.510
transaction, then people could
just brute force tries

14037
14:10:51.510 --> 14:10:53.510
simulating calling this
transaction and we'll learn how

14038
14:10:53.510 --> 14:10:56.510
to simulate calls soon simulate
calling these transactions to

14039
14:10:56.510 --> 14:10:59.510
see what they can manipulate to
make sure that they are the

14040
14:10:59.510 --> 14:11:01.510
winner. We want to make sure
that this is absolutely fair.

14041
14:11:01.510 --> 14:11:05.510
Nobody can manipulate our smart
contract into having them be the

14042
14:11:05.510 --> 14:11:07.510
winner of the lottery, this
function is actually going to

14043
14:11:07.510 --> 14:11:10.510
request it. And then in a second
func the random number is going

14044
14:11:10.510 --> 14:11:13.510
to be returned. And in the
transaction that we actually get

14045
14:11:13.510 --> 14:11:16.510
the random number from the chain
link network, that's when we're

14046
14:11:16.510 --> 14:11:19.510
going to actually send the money
to the winner. And if we go to

14047
14:11:19.510 --> 14:11:21.510
the chain link documentation,
the function that the chain link

14048
14:11:21.510 --> 14:11:24.510
node calls is this function
called fulfill random words,

14049
14:11:24.510 --> 14:11:27.510
this is going to be the
requesting one, which we could

14050
14:11:27.510 --> 14:11:30.510
even change this to request
random winner to make it more

14051
14:11:30.510 --> 14:11:36.510
clear, and then we'll make a
function fulfill random words.

14052
14:11:36.510 --> 14:11:38.510
And this is going to be an
internal override, which we'll

14053
14:11:38.510 --> 14:11:42.510
explain in a little bit, now
fulfill fulfill random words

14054
14:11:42.510 --> 14:11:45.510
basically means we're fulfilling
random numbers. The word comes

14055
14:11:45.510 --> 14:11:47.510
from a computer science
terminology, but you can

14056
14:11:47.510 --> 14:11:50.510
basically just think of this as
fulfill random numbers, because

14057
14:11:50.510 --> 14:11:53.510
we can get multiple random
numbers. Now in order to make

14058
14:11:53.510 --> 14:11:57.510
our raffle contract VRF a bowl,
we have to import the chain link

14059
14:11:57.510 --> 14:11:59.510
code, we can go back to the
documentation, and we're just

14060
14:11:59.510 --> 14:12:02.510
going to grab this bottom line
and we'll grab the top line in a

14061
14:12:02.510 --> 14:12:06.510
second. So we're going to do
import, I'm going to write it

14062
14:12:06.510 --> 14:12:09.510
out. But if you want to copy
paste, you can at chain link

14063
14:12:09.510 --> 14:12:15.510
slash contracts slash SRC slash
V 0.8, slash V RF, consumer

14064
14:12:15.510 --> 14:12:20.510
base, b two dot Sol. And since
we're importing at chainlink,

14065
14:12:20.510 --> 14:12:23.510
slash contracts, we're gonna
need to add that in by running

14066
14:12:23.510 --> 14:12:29.510
yarn, add dash dash dev at
chainlink slash contracts. And

14067
14:12:29.510 --> 14:12:32.511
now that we have this in here,
we should be able to import like

14068
14:12:32.511 --> 14:12:36.511
so. And we're going to need to
make our raffle VRF consumer

14069
14:12:36.511 --> 14:12:39.511
base double, we're gonna need to
inherit VRF consumer base go

14070
14:12:39.511 --> 14:12:46.511
into our node modules at chain
link src, V 08 VRF, consumer

14071
14:12:46.511 --> 14:12:50.511
base V two, it comes with this
function fulfill random words.

14072
14:12:50.511 --> 14:12:54.511
And you can see it's an internal
virtual function, virtual means

14073
14:12:54.511 --> 14:12:57.511
it's expecting to be
overwritten, the reason that

14074
14:12:57.511 --> 14:13:00.511
it's in the sphere of consumer
base V two is so that the VRF

14075
14:13:00.511 --> 14:13:03.511
coordinator, which we'll use in
a bit knows that it can call

14076
14:13:03.511 --> 14:13:06.511
this fulfill random words
function. And this is the

14077
14:13:06.511 --> 14:13:09.511
function that we're overriding.
So back in our raffle dot salt,

14078
14:13:09.511 --> 14:13:13.511
we're going to inherit it by
doing is VRF consumer base V

14079
14:13:13.511 --> 14:13:18.511
two. And now if we scroll down
to fulfill random words, we can

14080
14:13:18.511 --> 14:13:21.511
add in the input parameters
fulfilled pill random words,

14081
14:13:21.511 --> 14:13:28.511
which are going to be un 256,
Request ID and un 256, a memory

14082
14:13:28.511 --> 14:13:32.511
array random words. And if we
hit Save Our linter will now

14083
14:13:32.511 --> 14:13:36.511
notice, okay, this is what I'm
expecting, I'm expecting us to

14084
14:13:36.511 --> 14:13:39.511
override the Fill random words,
which takes these parameters.

14085
14:13:39.511 --> 14:13:43.511
Now if we look in our docs in
our constructor, we need to pass

14086
14:13:43.511 --> 14:13:46.511
the VRF consumer base V TOS
constructor and pass that VRF

14087
14:13:46.511 --> 14:13:49.511
coordinator. Again, this V RF
coordinator is the address of

14088
14:13:49.511 --> 14:13:52.511
the contract that does the
random number verification. So

14089
14:13:52.511 --> 14:13:57.511
right next to our constructor
will add the VRF consumer base V

14090
14:13:57.511 --> 14:14:02.511
to constructor and we need to
pass the VRF coordinator v2

14091
14:14:02.511 --> 14:14:04.511
address. So in our main
constructor, we'll add that as a

14092
14:14:04.511 --> 14:14:08.511
parameter as well. So we'll say
address

14093
14:14:08.511 --> 14:14:13.512
VRF core to Nate Torre v two,
and then we'll pass this as a

14094
14:14:13.512 --> 14:14:17.512
parameter for the VRF consumer
basically till now that we have

14095
14:14:17.512 --> 14:14:20.512
that we shouldn't see that
little underscore anymore. And

14096
14:14:20.512 --> 14:14:25.512
we should be able to run yarn
aren't had compiled. Awesome.

14097
14:14:25.512 --> 14:14:28.512
And we can see compiled two
files successfully and our code

14098
14:14:28.512 --> 14:14:34.512
is working great. Now something
that I often do is I actually

14099
14:14:34.512 --> 14:14:37.512
hate running yarn hard hat all
the time, because that's too

14100
14:14:37.512 --> 14:14:40.512
many keys for my little brain to
work with. I would prefer to

14101
14:14:40.512 --> 14:14:43.512
write as little keys as possible
hard hat also would like us to

14102
14:14:43.512 --> 14:14:46.512
write as little keys as
possible. So hard hat comes with

14103
14:14:46.512 --> 14:14:49.512
a shorthand and autocomplete
hard hat shorthand is an NPM

14104
14:14:49.512 --> 14:14:53.512
package that installs a globally
accessible binary called H H,

14105
14:14:53.512 --> 14:14:56.512
that runs the project's locally
installed hard hat and supports

14106
14:14:56.512 --> 14:14:58.512
shell auto completion for tasks.
So what we can do is we're going

14107
14:14:59.512 --> 14:15:01.512
to start with NPM, like this,
but we're gonna install it with

14108
14:15:01.512 --> 14:15:08.512
yarn, we're going to run yarn,
global, add hardhat shorthand.

14109
14:15:08.512 --> 14:15:11.512
And what this is going to do, we
can see here installed hard hat

14110
14:15:11.512 --> 14:15:15.512
shorthand with binaries H, H,
and Hardhead completion. Now

14111
14:15:15.512 --> 14:15:19.512
instead of running yarn,
Hardhead compile, which we can

14112
14:15:19.512 --> 14:15:24.512
still run, we can just run h h
compile, running h h is going to

14113
14:15:24.512 --> 14:15:27.512
be the same thing as if we had
just run the Hardhead command

14114
14:15:27.512 --> 14:15:33.512
for our local directory. So now
we need to actually have our

14115
14:15:33.512 --> 14:15:36.512
request random winner function
requests a random winner. So

14116
14:15:36.512 --> 14:15:38.512
let's go back to the
documentation. And we'll see how

14117
14:15:38.512 --> 14:15:42.512
to do that. We can look at this
function request random words

14118
14:15:42.512 --> 14:15:45.512
and see exactly how it works. On
the Vera of coordinator address.

14119
14:15:45.512 --> 14:15:48.512
We go ahead and call this
request random words function,

14120
14:15:48.512 --> 14:15:51.513
we're going to need to call this
function on the coordinator

14121
14:15:51.513 --> 14:15:54.513
contract to get the coordinator
contract. We're going to use the

14122
14:15:54.513 --> 14:15:57.513
Vera v2 coordinator interface
and the Vir of coordinator

14123
14:15:57.513 --> 14:16:00.513
address. So we're going to want
to keep track of those. We can

14124
14:16:00.513 --> 14:16:03.513
do that once again in Arkansas.
factor, we have the address

14125
14:16:03.513 --> 14:16:06.513
being passed to our Bureau of
consumer base. Let's also keep

14126
14:16:06.513 --> 14:16:09.513
it as a state variable for us.
First, let's get the interface

14127
14:16:09.513 --> 14:16:11.513
so we can interact with that
contract, we can import that

14128
14:16:11.513 --> 14:16:14.513
from chain link as well by doing
import at chain link slash

14129
14:16:14.513 --> 14:16:24.513
contracts, slash SRC slash fees
0.8, slash inter faces slash VRF

14130
14:16:24.513 --> 14:16:30.513
cord to mentor V to interface
dot Sol. And now that we import

14131
14:16:30.513 --> 14:16:34.513
this interface, same as we did
with price feeds, we can do VRF,

14132
14:16:34.513 --> 14:16:40.513
coordinator v2, interface VRF
coordinator. And then we can

14133
14:16:40.513 --> 14:16:44.513
save the sphere of coordinator
using the address so we can say

14134
14:16:44.513 --> 14:16:48.513
VRF coordinator equals this
address VRF coordinator veto.

14135
14:16:48.513 --> 14:16:50.513
And we're just going to wrap
that address around the

14136
14:16:50.513 --> 14:16:53.513
interface so that now we can
work with this VRF coordinator

14137
14:16:53.513 --> 14:16:56.513
contract. Now we're only going
to set our VRF coordinator one

14138
14:16:56.513 --> 14:16:59.513
time right in our constructor.
So what's the best thing that we

14139
14:16:59.513 --> 14:17:03.513
can do here, private, immutable,
you Gosh, darn. Right, let's do

14140
14:17:03.513 --> 14:17:06.513
private, immutable, you have
coordinator and we'll change the

14141
14:17:06.513 --> 14:17:10.513
name to I underscore the ref
coordinator so that we know that

14142
14:17:10.513 --> 14:17:13.513
your coordinator is indeed an
immutable variable. In order to

14143
14:17:14.513 --> 14:17:16.513
request the random word, we need
to give it a number of

14144
14:17:16.513 --> 14:17:20.513
parameters, I'm gonna go ahead
and copy this line into our

14145
14:17:20.513 --> 14:17:22.513
contract just so that we can
talk about exactly what's going

14146
14:17:22.513 --> 14:17:26.513
on with it. And we don't need
the AES Request ID. And instead

14147
14:17:26.513 --> 14:17:29.513
of coordinator we're going to do
I underscore fear of

14148
14:17:29.513 --> 14:17:31.514
coordinator. So we're going to
call request random words on

14149
14:17:32.514 --> 14:17:35.514
that VRF coordinator contract,
and we need to pass it the key

14150
14:17:35.514 --> 14:17:39.514
hash or the gasoline, I prefer
calling it the gas lane, we go

14151
14:17:39.514 --> 14:17:42.514
to the chain link, Doc's go to
contract addresses. And we

14152
14:17:42.514 --> 14:17:44.514
scroll down we can see different
gas lanes a different

14153
14:17:44.514 --> 14:17:47.514
configuration parameters for
different networks is key hash

14154
14:17:47.514 --> 14:17:50.514
is going to be the gasoline of
the key hash, which tells the

14155
14:17:50.514 --> 14:17:53.514
chain link node the maximum
price you're willing to pay for

14156
14:17:53.514 --> 14:17:57.514
your guests and way if for
example, gas prices skyrocket,

14157
14:17:57.514 --> 14:17:59.514
and it's going to cost you a ton
of money to get that random

14158
14:17:59.514 --> 14:18:02.514
number setting a ceiling, we'll
make it so that random number

14159
14:18:02.514 --> 14:18:04.514
doesn't come back. For us to
pick a gas lane, we're probably

14160
14:18:04.514 --> 14:18:07.514
going to want to have this gas
lane or this key hash stored

14161
14:18:07.514 --> 14:18:10.514
somewhere. So let's go ahead and
make that a parameter of our

14162
14:18:10.514 --> 14:18:13.514
constructor as well. And we'll
save that as a state variable.

14163
14:18:13.514 --> 14:18:18.514
So we'll do comma bytes 32,
gasoline or key hash or whatever

14164
14:18:18.514 --> 14:18:21.514
you want to call it. And then
we'll make a new state variable.

14165
14:18:21.514 --> 14:18:24.514
And we're only going to set this
once. So we'll make this a

14166
14:18:24.514 --> 14:18:33.514
private, immutable. I underscore
gasoline, and then we'll say

14167
14:18:33.514 --> 14:18:38.514
gasoline equals gasoline.

14168
14:18:38.514 --> 14:18:42.514
So now, we can just swap this
out, or I underscore gasoline.

14169
14:18:42.514 --> 14:18:44.514
Okay, what's next, we need a
subscription ID, the

14170
14:18:44.514 --> 14:18:47.514
subscription ID is going to be
the subscription that we need

14171
14:18:47.514 --> 14:18:50.514
for funding our requests.
There's actually a contract on

14172
14:18:50.514 --> 14:18:53.514
chain, which we can use to fund
any subscription for any of

14173
14:18:53.514 --> 14:18:56.514
these external data or external
computation bits. And in this

14174
14:18:56.514 --> 14:18:59.514
contract, there's a list of
these subscriptions for people

14175
14:18:59.514 --> 14:19:02.514
to make requests to. So we need
the ID of the subscription that

14176
14:19:02.514 --> 14:19:06.514
we're using to request our
random numbers and pay the link

14177
14:19:06.514 --> 14:19:09.514
Oracle gas, the subscription ID
is probably also going to be

14178
14:19:09.514 --> 14:19:12.515
something we're going to pass as
a parameter to our lottery. So

14179
14:19:12.515 --> 14:19:15.515
once again, let's scroll up to
our constructor, we'll add a new

14180
14:19:15.515 --> 14:19:18.515
parameter. And our subscription
ID actually doesn't need to be a

14181
14:19:18.515 --> 14:19:22.515
un 256, it can actually be a
little bit smaller with a un 64.

14182
14:19:22.515 --> 14:19:28.515
So we'll pass a un 64 sub
scription ID, we'll make a UNT

14183
14:19:28.515 --> 14:19:31.515
64. Since we're only going to
set this once we'll make this a

14184
14:19:31.515 --> 14:19:37.515
private, immutable. I underscore
sub scription ID down here and

14185
14:19:37.515 --> 14:19:43.515
we'll say I subscription ID
equals sub subscription ID.

14186
14:19:43.515 --> 14:19:46.515
Alright, awesome. So now we can
change this to our subscription

14187
14:19:46.515 --> 14:19:50.515
ID. Okay, what's next? Request
confirmations request

14188
14:19:50.515 --> 14:19:54.515
confirmations is a un 16, which
says how many confirmations the

14189
14:19:54.515 --> 14:19:57.515
chain link node should wait
before responding. So if you

14190
14:19:57.515 --> 14:20:00.515
make a request, and there's only
one block confirmation, maybe

14191
14:20:00.515 --> 14:20:02.515
you don't actually send it
because you don't you're afraid

14192
14:20:02.515 --> 14:20:05.515
of some type of blockchain
reorganization or something,

14193
14:20:05.515 --> 14:20:07.515
we're not going to worry too
much about this. And we're

14194
14:20:07.515 --> 14:20:09.515
actually just going to make this
a constant of three. So we're

14195
14:20:09.515 --> 14:20:12.515
not even going to have this be
per amortizable we're gonna have

14196
14:20:12.515 --> 14:20:17.515
this one be a constant. So we'll
say a you int 16 Private

14197
14:20:17.515 --> 14:20:24.515
constant request, confirmations
equals three, and we're using

14198
14:20:24.515 --> 14:20:28.515
the capslock and underscores for
our constant variables here. And

14199
14:20:28.515 --> 14:20:31.515
now we'll grab request
confirmations and stick it in

14200
14:20:31.515 --> 14:20:34.515
right here. What's next callback
gas limit callback gas limit is

14201
14:20:34.515 --> 14:20:37.515
going to be the limit for how
much gas to use for the callback

14202
14:20:37.515 --> 14:20:40.515
request your contracts fulfill
random words, this sets a limit

14203
14:20:40.515 --> 14:20:44.515
for how much computation are
fulfilled random words can be

14204
14:20:44.515 --> 14:20:46.515
this is a good way to protect
ourselves from spending way too

14205
14:20:47.515 --> 14:20:50.515
much gas. If, for example, we
accidentally code our contract

14206
14:20:50.515 --> 14:20:53.516
in a way where fulfill random
words is incredibly gas

14207
14:20:53.516 --> 14:20:56.516
expensive. It'll block the
random number from responding.

14208
14:20:56.516 --> 14:20:58.516
We are going to make this
parameter sizable because we

14209
14:20:58.516 --> 14:21:01.516
want to change it depending on
how we code our fulfill random

14210
14:21:01.516 --> 14:21:05.516
word. So in our constructor,
let's add one more, we'll add

14211
14:21:05.516 --> 14:21:10.516
you int 32. Since the size of
this is a un 32, callback, gas

14212
14:21:10.516 --> 14:21:17.516
limit, and we'll save the sub
top as a UNT 32, private,

14213
14:21:17.516 --> 14:21:23.516
immutable, I underscore call
back. Yes limit. And we'll save

14214
14:21:23.516 --> 14:21:30.516
this. I call back gas limit
equals call back Yes, limit. And

14215
14:21:30.516 --> 14:21:32.516
then we'll take this, and we'll
stick it here. All right, we got

14216
14:21:32.516 --> 14:21:35.516
one more number of words, this
is going to be how many random

14217
14:21:35.516 --> 14:21:38.516
numbers that we want to get, we
only want one. So we're gonna go

14218
14:21:38.516 --> 14:21:42.516
back up to the top, we're going
to create a you int 32. And

14219
14:21:42.516 --> 14:21:47.516
we'll make this also a private
constant. Num words equals one,

14220
14:21:47.516 --> 14:21:49.516
because we only want one random
number. And then that'll be the

14221
14:21:49.516 --> 14:21:54.516
last thing we need to add for
our IVF coordinator dot request

14222
14:21:54.516 --> 14:21:57.516
random words. Now this request
random words function returns a

14223
14:21:57.516 --> 14:22:02.516
request ID a un 256 Request ID a
unique ID that defines who's

14224
14:22:02.516 --> 14:22:05.516
requesting this and all this
other information. If we want to

14225
14:22:05.516 --> 14:22:10.516
save it, we can do u and 256.
Request ID IVF coordinator

14226
14:22:10.516 --> 14:22:13.516
requests random words. Now for
now, we are going to emit an

14227
14:22:13.516 --> 14:22:17.516
event with this request ID. And
we'll go over why we're going to

14228
14:22:17.516 --> 14:22:20.516
do that a little bit later,
create a new event at the top.

14229
14:22:20.516 --> 14:22:23.516
And we're not going to follow
the naming convention here.

14230
14:22:23.516 --> 14:22:25.516
Because we're going to change
the name of our functions a

14231
14:22:25.516 --> 14:22:30.516
little bit, we're going to call
this requested raffle winner.

14232
14:22:30.516 --> 14:22:37.517
And we're going to take a un 256
indexed Request ID. Down here,

14233
14:22:37.517 --> 14:22:42.517
we're gonna do omit requested
raffle winner Request ID. And

14234
14:22:42.517 --> 14:22:45.517
now we have a function that we
can use to request a random

14235
14:22:45.517 --> 14:22:47.517
winner using chain link VRF. Now
again, we're going to set this

14236
14:22:47.517 --> 14:22:50.517
up so that the chain link
keepers call this on an

14237
14:22:50.517 --> 14:22:52.517
interval, but we'll do that in a
little bit. For now, let's

14238
14:22:52.517 --> 14:22:54.517
figure out what to do once we
get that

14239
14:22:54.517 --> 14:23:02.517
random number. Once we get that
random number, we're going to

14240
14:23:02.517 --> 14:23:06.517
want to pick a random winner
from our array of players up

14241
14:23:06.517 --> 14:23:10.517
here. So what do we do? Well,
let's go in here. And let's pick

14242
14:23:10.517 --> 14:23:14.517
a random winner using something
called the module function. Now

14243
14:23:14.517 --> 14:23:18.517
we're gonna get an array back of
random words, or random numbers,

14244
14:23:18.517 --> 14:23:21.517
if you will, since we're only
requesting one random word, this

14245
14:23:21.517 --> 14:23:24.517
random words array is going to
be of size one with one random

14246
14:23:24.517 --> 14:23:27.517
word in it. Now this random word
is a un 256. So this random word

14247
14:23:27.517 --> 14:23:31.517
could be something like this.
Well, obviously without the

14248
14:23:31.517 --> 14:23:34.517
hyphens, but it could be
something absolutely massive

14249
14:23:34.517 --> 14:23:37.517
like that our players array is
only going to be so big. So how

14250
14:23:37.517 --> 14:23:41.517
do we get a random winner from
this potentially massive random

14251
14:23:41.517 --> 14:23:43.517
number, we can use something
called the modulo function, the

14252
14:23:43.517 --> 14:23:48.517
module operation, a mod N
yields, the remainder are after

14253
14:23:48.517 --> 14:23:51.517
the division of an operand a by
the blah, blah, blah, blah,

14254
14:23:51.517 --> 14:23:53.517
blah. So what does this mean?
Well, we can use the mod

14255
14:23:53.517 --> 14:23:57.517
function to get a random number
out of our players array. So

14256
14:23:57.517 --> 14:24:00.517
let's say our players array or
excuse me, our s players array

14257
14:24:00.517 --> 14:24:05.517
is of size 10. And a random
number is 200. So how do we pick

14258
14:24:05.517 --> 14:24:08.517
a random person out of this
players array, or, let's say our

14259
14:24:08.517 --> 14:24:12.518
random number is 202. If we do
202, which is our random number,

14260
14:24:12.518 --> 14:24:18.518
mod 10, we're gonna basically do
202 divided by 10. But instead

14261
14:24:18.518 --> 14:24:20.518
of having the decimals, we're
just going to say, Okay, how

14262
14:24:20.518 --> 14:24:24.518
many times is 10 evenly divide
into 202. And what's the

14263
14:24:24.518 --> 14:24:29.518
remainder, what doesn't divide
evenly into 202? Well, 20 times

14264
14:24:29.518 --> 14:24:34.518
10 equals 200, with two
leftover, so two doesn't evenly

14265
14:24:34.518 --> 14:24:40.518
divide, or multiply into 200. So
that means 202 mod 10 is going

14266
14:24:40.518 --> 14:24:43.518
to equal to two. So that's how
the module function works. And

14267
14:24:43.518 --> 14:24:46.518
we can use that so we're always
going to get a number between.

14268
14:24:46.518 --> 14:24:48.518
So we're always going to get a
number here between zero and

14269
14:24:48.518 --> 14:24:51.518
nine, which works out perfectly
because that which works out

14270
14:24:51.518 --> 14:24:54.518
perfectly, because those are the
indexes of the 10 people in our

14271
14:24:54.518 --> 14:24:58.518
array. So let's use that here.
We'll say a un 256 index of

14272
14:24:58.518 --> 14:25:04.518
winner is going to be equal to
random words, at index zero,

14273
14:25:04.518 --> 14:25:08.518
because we're only getting one
random word module, the S

14274
14:25:08.518 --> 14:25:12.518
underscore players dot length.
So this will give us the index

14275
14:25:12.518 --> 14:25:14.518
of our random winner to get that
address of the winner will do

14276
14:25:14.518 --> 14:25:24.518
address payable, recent winner
equals s players at this index

14277
14:25:24.518 --> 14:25:26.518
of winner so awesome. So now
we'll have the address of the

14278
14:25:26.518 --> 14:25:29.518
person that got this random
number, the person's that's

14279
14:25:29.518 --> 14:25:34.518
going to be our verifiably
random winner. Now, it might be

14280
14:25:34.518 --> 14:25:37.518
kind of cool to brag to people
that you're the recent winner.

14281
14:25:37.518 --> 14:25:40.518
So let's go ahead to the top and
we'll create a new state

14282
14:25:40.518 --> 14:25:43.518
variable for our most recent
winner make this state variable

14283
14:25:43.518 --> 14:25:48.518
in a new section called lottery
variables. We'll say address

14284
14:25:48.518 --> 14:25:52.519
private s underscore recent
winner and it'll start out as

14285
14:25:52.519 --> 14:25:56.519
nobody but as we get winners
update it with s recent winner

14286
14:25:56.519 --> 14:26:01.519
equals recent winner and we'll
probably want people to know who

14287
14:26:01.519 --> 14:26:05.519
this is winter is so down below,
we can do function get recent

14288
14:26:05.519 --> 14:26:09.519
winner, it's going to be a
public view that's going to

14289
14:26:09.519 --> 14:26:14.519
return that address. And then
we'll just say return s

14290
14:26:14.519 --> 14:26:17.519
underscore recent winner, since
again, the recent winner is

14291
14:26:17.519 --> 14:26:19.519
going to be a storage variable.
So now that we have a recent

14292
14:26:19.519 --> 14:26:22.519
winner, what else are we gonna
do? Well, we're probably going

14293
14:26:22.519 --> 14:26:24.519
to want to send them the money
in this contract. So we're going

14294
14:26:24.519 --> 14:26:27.519
to do exactly what we did before
with sending the money, we're

14295
14:26:27.519 --> 14:26:35.519
going to do that bull success,
comma, blank equals recent

14296
14:26:35.519 --> 14:26:41.519
winner, call, I'm gonna say
value, it's going to be address

14297
14:26:41.519 --> 14:26:45.519
of this dot balance, we're going
to send all the money in this

14298
14:26:45.519 --> 14:26:48.519
contract, and we're going to
pass it no data. And now we

14299
14:26:48.519 --> 14:26:52.519
could say require, you know,
success, whatever, we're going

14300
14:26:52.519 --> 14:26:54.519
to be a little bit more gas
efficient here. And we're just

14301
14:26:54.519 --> 14:26:58.519
gonna say, if not success, then
we're going to revert a new

14302
14:26:59.519 --> 14:27:01.519
transfer failed error. So we're
gonna go to the top, or say,

14303
14:27:01.519 --> 14:27:05.519
error name of the contract is
raffle, underscore, underscore,

14304
14:27:05.519 --> 14:27:10.519
transfer failed, like that, then
go back down, and we can now do

14305
14:27:10.519 --> 14:27:14.519
revert, raffle transfer failed
like that. And now that we've

14306
14:27:14.519 --> 14:27:17.519
picked a winner, right now, we
don't have a way to actually

14307
14:27:17.519 --> 14:27:20.519
keep track of the list of
previous winners. So we're just

14308
14:27:20.519 --> 14:27:23.519
going to omit an event. So
there's always going to be that

14309
14:27:23.519 --> 14:27:26.519
easily query double history of
event winners. So we're going to

14310
14:27:26.519 --> 14:27:30.519
create a new event in the events
section called the event winner

14311
14:27:30.519 --> 14:27:37.520
picked. And this is going to be
an address indexed winner. And

14312
14:27:37.520 --> 14:27:43.520
we'll scroll down and we'll do
MIT winner picked the address of

14313
14:27:43.520 --> 14:27:46.520
the recent winner. This looks
pretty good.

14314
14:27:46.520 --> 14:27:49.520
This looks pretty good here. Now
you'll notice our request ID as

14315
14:27:49.520 --> 14:27:53.520
this little underscore here and
saying, hey, it's an unused

14316
14:27:53.520 --> 14:27:56.520
function parameter, since we
don't use this, but we still

14317
14:27:56.520 --> 14:27:59.520
need fulfill random words to
take a request ID and a random

14318
14:27:59.520 --> 14:28:02.520
words array. But we don't use
Request ID, we can just comment

14319
14:28:02.520 --> 14:28:06.520
out just the request ID part
like this, this tells our

14320
14:28:06.520 --> 14:28:10.520
function, hey, yes, we know that
you need a un 256. But we're not

14321
14:28:10.520 --> 14:28:12.520
going to use the request ID. So
we'll leave it in here. But

14322
14:28:12.520 --> 14:28:16.520
we'll leave it blank. Now let's
run a little compile here. We'll

14323
14:28:16.520 --> 14:28:21.520
use yarn, hard hat, compile, or
hh compile, we'll see if we're

14324
14:28:21.520 --> 14:28:24.520
coding things correctly. And
indeed, we don't see any errors.

14325
14:28:24.520 --> 14:28:30.520
So perfect, we can continue. So
we've added the chain link VRF,

14326
14:28:30.520 --> 14:28:34.520
where we have a way to
verifiably get a random winner.

14327
14:28:34.520 --> 14:28:38.520
This is fantastic. Now let's
update this contract so that not

14328
14:28:38.520 --> 14:28:42.520
only can it pick a verifiable
winner, but it can also do this

14329
14:28:42.520 --> 14:28:45.520
all programmatically and
automatically trigger picking a

14330
14:28:45.520 --> 14:28:49.520
random winner based off of some
time interval without us having

14331
14:28:49.520 --> 14:28:52.520
to interact with it. And in a
decentralized context. In order

14332
14:28:52.520 --> 14:28:55.520
for us to automatically trigger
smart contracts based off of

14333
14:28:55.520 --> 14:28:59.520
some parameter be a time
parameter, maybe the price of

14334
14:28:59.520 --> 14:29:02.520
some asset is some number, maybe
there's a certain amount of

14335
14:29:02.520 --> 14:29:05.520
money in the liquidity pool or
really whatever trigger that you

14336
14:29:05.520 --> 14:29:08.520
want, we can use chain link
keepers. To do this. Steven

14337
14:29:08.520 --> 14:29:11.520
fluid has done once again, an
amazing introduction to chain

14338
14:29:11.520 --> 14:29:14.521
the keepers. So we're going to
follow along with another sub

14339
14:29:14.521 --> 14:29:16.521
video section of Steven
explaining chain link keeper

14340
14:29:16.521 --> 14:29:19.521
sauce, he's going to be using
the COVID test net, but be sure

14341
14:29:19.521 --> 14:29:22.521
to use whatever test net is in
the documentation. When you play

14342
14:29:22.521 --> 14:29:23.521
with this and you try this.

14343
14:29:23.521 --> 14:29:26.521
My name is Steven foon. Today, I
want to show you how to use the

14344
14:29:26.521 --> 14:29:29.521
chain link keeper network in
order to automate your contracts

14345
14:29:29.521 --> 14:29:32.521
and give them access to off
chain computation. Let's go

14346
14:29:32.521 --> 14:29:34.521
ahead and dive in. So what we're
going to look at today is we're

14347
14:29:34.521 --> 14:29:37.521
going to start on the chain link
documentation webpage. And if

14348
14:29:37.521 --> 14:29:39.521
you just scroll down a little
bit, you're going to find using

14349
14:29:39.521 --> 14:29:43.521
chain link keepers. Now there's
really two parts to building a

14350
14:29:43.521 --> 14:29:46.521
chain link keeper up kept smart
contract. So the first thing is

14351
14:29:46.521 --> 14:29:49.521
you need to write a smart
contract that's compatible by

14352
14:29:49.521 --> 14:29:51.521
implementing these two methods.
And then second, you want to

14353
14:29:51.521 --> 14:29:54.521
register that smart contract for
upkeep with the channeling

14354
14:29:54.521 --> 14:29:57.521
keeper network. So let's go
ahead and do both of those

14355
14:29:57.521 --> 14:30:00.521
things. So let's start off just
by copying and deploying this

14356
14:30:00.521 --> 14:30:04.521
sample code that we've got. With
this one click to remix, what

14357
14:30:04.521 --> 14:30:07.521
we're gonna see here is a very,
very simple contract. That is

14358
14:30:07.521 --> 14:30:11.521
just a simple counter. So we can
see it's got a counter here. So

14359
14:30:11.521 --> 14:30:16.521
it's got just a simple number.
And then you're able to specify

14360
14:30:16.521 --> 14:30:19.521
when you create the contract and
update interval, and then the

14361
14:30:19.521 --> 14:30:22.521
contract is going to verify Hey,
has enough time passed. And if

14362
14:30:22.521 --> 14:30:24.521
it has, let's update the
counter. And you're going to

14363
14:30:24.521 --> 14:30:27.521
notice that chinley compatible
or timekeeper network compatible

14364
14:30:27.521 --> 14:30:30.521
contracts use two really
important methods that are part

14365
14:30:30.521 --> 14:30:33.521
of this keeper compatible
interface. The first is check

14366
14:30:33.521 --> 14:30:37.521
upkeep, and check upkeep is
special because this is where

14367
14:30:37.521 --> 14:30:39.521
the off chain computation
happens. So this is a method

14368
14:30:39.521 --> 14:30:43.521
that's not actually run on
chain. This is run off chain by

14369
14:30:43.521 --> 14:30:47.521
a node from the channeling
keeper network. And so what's

14370
14:30:47.521 --> 14:30:50.521
really nice about this is that
the gas used here isn't actually

14371
14:30:50.521 --> 14:30:53.522
gas, it's on chains. This is
just being run by a chain link

14372
14:30:53.522 --> 14:30:57.522
node. And then what happens is
if your check upkeep method

14373
14:30:57.522 --> 14:31:00.522
returns, the upkeep is needed.
Then it's going to go ahead and

14374
14:31:00.522 --> 14:31:04.522
perform upkeep. On chain, so you
can actually generate data off

14375
14:31:04.522 --> 14:31:07.522
chain, and then pass that in.
That's called the check data.

14376
14:31:07.522 --> 14:31:10.522
And then that becomes the
performed data that's passed

14377
14:31:10.522 --> 14:31:14.522
into perform upkeep. And so the
PErforM upkeep method is where

14378
14:31:14.522 --> 14:31:18.522
you're going to want to verify
that things are correct. And

14379
14:31:18.522 --> 14:31:22.522
that things actually should be
modified and run on chain, and

14380
14:31:22.522 --> 14:31:25.522
then actually make the state
change. And so let's go ahead

14381
14:31:25.522 --> 14:31:28.522
and compile this contract and
deploy it to the COVID network.

14382
14:31:28.522 --> 14:31:31.522
So let's go ahead and within
remix, we can do this

14383
14:31:31.522 --> 14:31:35.522
compilation. And we're going to
compile and deploy directly to

14384
14:31:35.522 --> 14:31:38.522
COVID. So the zookeeper network
is currently as of the filming

14385
14:31:38.522 --> 14:31:42.522
of this, available on both COVID
as well as the theory of main

14386
14:31:42.522 --> 14:31:45.522
net. And let's go ahead and play
the counter contract. And let's

14387
14:31:45.522 --> 14:31:49.522
see what's not updating more
than every 30 seconds. And so

14388
14:31:49.522 --> 14:31:52.522
let's go ahead and deploy. So
meta masks can ask for a little

14389
14:31:52.522 --> 14:31:54.522
bit of payment, in order for me
to deploy this contract to the

14390
14:31:54.522 --> 14:31:58.522
COVID network. And it looks like
that is live. So now what I'm

14391
14:31:58.522 --> 14:32:00.522
going to do is I'm going to be
able to take this keeper

14392
14:32:00.522 --> 14:32:04.522
contract, and copy its address.
And now we're going to register

14393
14:32:04.522 --> 14:32:07.522
that contract for upkeep. So
we're going to jump over to the

14394
14:32:07.522 --> 14:32:10.522
application that powers the
champion keeper network, there's

14395
14:32:10.522 --> 14:32:12.522
a few different ways you can
use, you can interact directly

14396
14:32:12.522 --> 14:32:15.522
with the registry contract. But
there's a very, very nice

14397
14:32:15.522 --> 14:32:17.522
interface that lets you do this.
So let's go ahead and register a

14398
14:32:17.522 --> 14:32:20.522
new upkeep and it's giving me an
error that says you need to

14399
14:32:20.522 --> 14:32:22.522
connect your wallet. So let's go
ahead and do that. So I'm going

14400
14:32:22.522 --> 14:32:25.522
to just connect wallet here, and
I'm gonna give it access to my

14401
14:32:25.522 --> 14:32:28.522
account. And then from there, we
should actually be able to

14402
14:32:28.522 --> 14:32:33.523
register. So I'm going to use an
email address here. I'll give my

14403
14:32:33.523 --> 14:32:36.523
contract a simple name. I'll
paste in that address from the

14404
14:32:36.523 --> 14:32:40.523
deployed contract, and then I'll
give it a gas limit. And then

14405
14:32:40.523 --> 14:32:42.523
check data is this special thing
where you can actually register

14406
14:32:42.523 --> 14:32:45.523
multiple upkeeps On the same
contract in passing data to

14407
14:32:45.523 --> 14:32:49.523
specify how you want checkup
keep to be run of, we're just

14408
14:32:49.523 --> 14:32:51.523
going to ignore that that is an
optional one. And then we'll

14409
14:32:51.523 --> 14:32:55.523
give it a starting balance of
around 10 link, it's gonna go

14410
14:32:55.523 --> 14:32:58.523
ahead and use Metamask again to
register that transaction on the

14411
14:32:58.523 --> 14:33:02.523
network. And once it's
confirmed, my upkeep should be

14412
14:33:02.523 --> 14:33:05.523
registered with the network and
funded with 10 Link To kick

14413
14:33:05.523 --> 14:33:09.523
things off. Alright, if we go
ahead and view the upkeep, we

14414
14:33:09.523 --> 14:33:15.523
can see it's registered. And as
soon as the next round of the

14415
14:33:15.523 --> 14:33:19.523
keeper nodes executes, which
should be roughly about every

14416
14:33:19.523 --> 14:33:23.523
block, we should see that the
check upkeep method is going to

14417
14:33:23.523 --> 14:33:25.523
return that hey, upkeep is
actually needed because the

14418
14:33:25.523 --> 14:33:28.523
timestamp is more than 30
seconds ago. And then we should

14419
14:33:28.523 --> 14:33:32.523
go ahead and perform upkeep. So
as soon as I take a look at this

14420
14:33:32.523 --> 14:33:36.523
in remix, I can actually make
this bigger here, we're going to

14421
14:33:36.523 --> 14:33:38.523
be able to see from the methods
of the contract, if we check the

14422
14:33:38.523 --> 14:33:41.523
counter, it's going to start at
zero. And as soon as that 30

14423
14:33:41.523 --> 14:33:44.523
seconds has passed, we'll be
able to hit the counter again,

14424
14:33:44.523 --> 14:33:47.523
we'll see that the channeling
keeper network has performed

14425
14:33:47.523 --> 14:33:50.523
upkeep on my contract. Alright,
we just refresh and we see the

14426
14:33:50.523 --> 14:33:55.523
balance of the upkeep has been
decreased by about point 01

14427
14:33:55.523 --> 14:33:59.523
link. And we should also see
within our contract that our

14428
14:33:59.523 --> 14:34:02.523
counter has now updated via
proof that perform upkeep method

14429
14:34:02.523 --> 14:34:07.523
call. And now our counter is at
one showing us that our contract

14430
14:34:07.523 --> 14:34:10.523
is being approved by the
chainlink keeper network. And

14431
14:34:10.523 --> 14:34:13.524
everything is working exactly as
we expect. So as you can see, it

14432
14:34:13.524 --> 14:34:16.524
is very, very easy to create a
contract that is compatible with

14433
14:34:16.524 --> 14:34:19.524
the keeper network. And it's
very easy to register that

14434
14:34:19.524 --> 14:34:23.524
upkeep and start seeing that
your contract automation and

14435
14:34:23.524 --> 14:34:25.524
option computation are working
flawlessly.

14436
14:34:25.524 --> 14:34:27.524
Now that we've learned a little
bit more about how chainlink

14437
14:34:27.524 --> 14:34:30.524
keepers work if you want to take
some time to go through the

14438
14:34:30.524 --> 14:34:33.524
documentation and open up way
down below this open and remix

14439
14:34:33.524 --> 14:34:36.524
button. So you can actually work
with one of these and see these

14440
14:34:36.524 --> 14:34:39.524
in action for yourself on a test
net, feel free to do so we're

14441
14:34:39.524 --> 14:34:42.524
gonna be using a setup very
similar to this keepers counter

14442
14:34:42.524 --> 14:34:47.524
setup in the chain link
documentation. So now let's

14443
14:34:47.524 --> 14:34:50.524
update our code so that this
request random numbers

14444
14:34:50.524 --> 14:34:53.524
automatically happens using
chain link keepers. And if we

14445
14:34:53.524 --> 14:34:56.524
look at the example contract can
actually read more about what's

14446
14:34:56.524 --> 14:34:59.524
really important for this to
work. And we need a check upkeep

14447
14:34:59.524 --> 14:35:03.524
and a perform upkeep function in
our code. So instead of request

14448
14:35:03.524 --> 14:35:06.524
random winner, this is going to
be the PErforM upkeep that we're

14449
14:35:06.524 --> 14:35:09.524
going to change. But first let's
make this check upkeep checkup

14450
14:35:09.524 --> 14:35:12.524
keep function is basically going
to be checking to see is it time

14451
14:35:12.524 --> 14:35:15.524
for us to get a random number to
update the recent winner and to

14452
14:35:15.524 --> 14:35:17.524
send them all the funds. So
let's go ahead and make that

14453
14:35:17.524 --> 14:35:20.524
function. I'm going to add some
notes here, just so that it's

14454
14:35:20.524 --> 14:35:23.524
clear what's going on. And maybe
I'll even do natspec To tell

14455
14:35:23.524 --> 14:35:26.524
developers what's going on with
this function. So we're going to

14456
14:35:26.524 --> 14:35:30.524
create this function check
upkeep. And if we look at what

14457
14:35:30.524 --> 14:35:35.524
this needs, it needs to be
external override external

14458
14:35:35.524 --> 14:35:38.524
override. And if we see this
override keyword, this means

14459
14:35:38.524 --> 14:35:41.524
that okay, there's probably a
perform upkeep somewhere else.

14460
14:35:41.524 --> 14:35:43.524
And if we scroll to the top, and
we're going to import this

14461
14:35:43.524 --> 14:35:46.524
keeper compatible interface, so
that we make sure that we

14462
14:35:46.524 --> 14:35:51.524
implement both check upkeep and
perform upkeep in our code here.

14463
14:35:51.524 --> 14:35:54.525
If you want you can just import
keeper compatible in here or

14464
14:35:54.525 --> 14:35:56.525
just the keeper compatible
interface in our code. We're

14465
14:35:56.525 --> 14:36:04.525
going to do import at chain link
slash contracts slash SRC slash

14466
14:36:04.525 --> 14:36:13.525
V 0.8 point two interfaces slash
keeper compatible interface that

14467
14:36:13.525 --> 14:36:16.525
soul and now we're just gonna
say contract raffle is Veera of

14468
14:36:16.525 --> 14:36:19.525
consumer base V two and keeper
compatible interface and this

14469
14:36:19.525 --> 14:36:22.525
keeper compatible interface
inheritance just make sure that

14470
14:36:22.525 --> 14:36:25.525
we add checkup keep and perform
upkeep, which we're going to add

14471
14:36:25.525 --> 14:36:28.525
in a little bit. And if we look
back at the docs we can see

14472
14:36:28.525 --> 14:36:32.525
checkup keep takes a bytes
called Data check data as an

14473
14:36:32.525 --> 14:36:37.525
input parameter. So we'll do
bytes called data. Check data as

14474
14:36:37.525 --> 14:36:40.525
a parameter. Now this check
upkeep bytes call data allows us

14475
14:36:40.525 --> 14:36:44.525
to specify really anything that
we want when we call this check

14476
14:36:44.525 --> 14:36:47.525
upkeep function. Having this
check data be of type bytes

14477
14:36:47.525 --> 14:36:51.525
means that we can even specify
this to call other functions,

14478
14:36:51.525 --> 14:36:54.525
there's a lot of advanced things
you can do by just having an

14479
14:36:54.525 --> 14:36:58.525
input parameter as type of bytes
for us though, we're going to

14480
14:36:58.525 --> 14:37:00.525
keep it a little bit simple. And
we're actually not going to use

14481
14:37:00.525 --> 14:37:03.525
this check data piece. So
similar to how below we're not

14482
14:37:03.525 --> 14:37:06.525
using Request ID, we can just
comment it out. However, we

14483
14:37:06.525 --> 14:37:09.525
still need to make sure that
this parameter is type of bytes

14484
14:37:09.525 --> 14:37:12.525
called data. Now anyways, let's
go ahead and annotate this check

14485
14:37:12.525 --> 14:37:16.525
upkeep function, we'll say this
is the function that the chain

14486
14:37:16.525 --> 14:37:25.525
link keeper nodes call they look
for the to return true. Look

14487
14:37:25.525 --> 14:37:28.525
back at the documentation, we
can see that this check upkeep

14488
14:37:28.525 --> 14:37:33.526
returns both and upkeep needed
and to perform data, which

14489
14:37:33.526 --> 14:37:36.526
again, we're going to ignore
this upkeep needed is going to

14490
14:37:36.526 --> 14:37:41.526
be true or false. If it's true,
that means it's time to get a

14491
14:37:41.526 --> 14:37:46.526
new random number following
should be true in order to

14492
14:37:46.526 --> 14:37:50.526
return true. So in order for it
to be time to request a random

14493
14:37:50.526 --> 14:37:54.526
winner, what should happen, our
time interval should have

14494
14:37:54.526 --> 14:37:58.526
passed, which we haven't defined
yet. But we will lottery should

14495
14:37:58.526 --> 14:38:04.526
have at least one player and
have some eath. And then our

14496
14:38:04.526 --> 14:38:09.526
subscription is funded with Link
similar to how with channeling

14497
14:38:09.526 --> 14:38:12.526
Vir f your subscription needs to
be funded with Link, the same

14498
14:38:12.526 --> 14:38:15.526
thing needs to happen for check
upkeep and keepers to run your

14499
14:38:15.526 --> 14:38:18.526
subscription needs to be funded
with link. Now we're going to

14500
14:38:18.526 --> 14:38:21.526
add one more additional piece
here, we're going to say for the

14501
14:38:21.526 --> 14:38:26.526
lottery should be in an open
state, something that we want to

14502
14:38:26.526 --> 14:38:30.526
avoid when we're waiting for a
random number to return. And

14503
14:38:30.526 --> 14:38:33.526
when we've requested a random
winner. We're technically in

14504
14:38:33.526 --> 14:38:35.526
this weird limbo state where
we're waiting for a random

14505
14:38:35.526 --> 14:38:38.526
number to be returned. And we
really shouldn't allow any new

14506
14:38:38.526 --> 14:38:40.526
players to join. So what we
actually want to do is create

14507
14:38:40.526 --> 14:38:43.526
some state variable telling us
whether the lottery is open or

14508
14:38:43.526 --> 14:38:46.526
not. And while we're waiting for
our random number to get back,

14509
14:38:46.526 --> 14:38:51.526
we'll be in a closed or a
calculating state.

14510
14:38:51.526 --> 14:38:54.526
Now what we could do at the top
of our contract, we can just say

14511
14:38:54.526 --> 14:38:59.526
Boolean, private, s underscore
is open. And we can just set

14512
14:38:59.526 --> 14:39:03.526
this to true if we're open
otherwise false. Well, what if

14513
14:39:03.526 --> 14:39:05.526
we have a ton of different
states? What if we want it to be

14514
14:39:05.526 --> 14:39:10.526
like pending, open, closed,
calculating, etc? What do we

14515
14:39:10.526 --> 14:39:14.527
have a ton of different states?
Well, we could make this a U and

14516
14:39:14.527 --> 14:39:18.527
256. Private s underscore state.
And we could just keep track of

14517
14:39:18.527 --> 14:39:21.527
the state having like zero b
pending a one reopen to be

14518
14:39:21.527 --> 14:39:24.527
closed, three, be calculating,
etc. But this can be a little

14519
14:39:24.527 --> 14:39:27.527
tricky to keep track of. So a
better way to actually keep

14520
14:39:27.527 --> 14:39:31.527
track of all this in our code is
to use an enum enums, can be

14521
14:39:31.527 --> 14:39:35.527
used to create custom types with
a finite set of constant values.

14522
14:39:35.527 --> 14:39:39.527
So we can create, for example, a
state created locked inactive,

14523
14:39:39.527 --> 14:39:42.527
and it's basically a new type
for a smart contract for us,

14524
14:39:42.527 --> 14:39:45.527
we're going to create a new
type. And if we go back to the

14525
14:39:45.527 --> 14:39:48.527
layout of variables, and our
smart contract types should

14526
14:39:48.527 --> 14:39:50.527
actually be first thing in our
contract. So we're going to

14527
14:39:50.527 --> 14:39:54.527
create an E new called raffle
state. And for now, and we're

14528
14:39:54.527 --> 14:39:57.527
just going to have it be open,
we're just gonna have to be open

14529
14:39:57.527 --> 14:40:02.527
or calculating. Now when we
create an enum like this, we're

14530
14:40:02.527 --> 14:40:07.527
kind of secretly creating a un
256, where zero equals open, and

14531
14:40:07.527 --> 14:40:12.527
one equals calculating. However,
this is much more explicit that

14532
14:40:12.527 --> 14:40:15.527
we know what each one of these
numbers actually means. Now that

14533
14:40:15.527 --> 14:40:18.527
we've created this new type
called raffle state, we can

14534
14:40:18.527 --> 14:40:22.527
create a new lottery state
variable of type raffle state.

14535
14:40:22.527 --> 14:40:25.527
So the exact same way we declare
any other variable, we'll name

14536
14:40:25.527 --> 14:40:28.527
its type, which is going to be
raffle state. And this is going

14537
14:40:28.527 --> 14:40:31.527
to be a storage variable. So
we'll go ahead and do private s

14538
14:40:31.527 --> 14:40:34.527
underscore raffle state in our
constructor, right when we

14539
14:40:34.527 --> 14:40:38.527
launched this contract, we
should open up this raffle. So

14540
14:40:38.527 --> 14:40:43.527
we'll say s, raffle state equals
and we could use a un 256.

14541
14:40:43.527 --> 14:40:48.527
Wrapped in type raffle state
like so. Or we can be more

14542
14:40:48.527 --> 14:40:52.527
explicit and say raffle state
DOT open. Now we know that the

14543
14:40:52.527 --> 14:40:55.528
raffle state is in an open state
and we only want checkup keep to

14544
14:40:55.528 --> 14:40:59.528
work is if the lottery is
actually open. Additionally, we

14545
14:40:59.528 --> 14:41:01.528
probably only want people to be
able to enter if the law

14546
14:41:01.528 --> 14:41:04.528
battery's open. So let's go
ahead and create another if

14547
14:41:04.528 --> 14:41:07.528
statement and revert if the
lottery isn't open. So we can

14548
14:41:07.528 --> 14:41:14.528
say if s underscore raffle state
does not equal raffle state DOT

14549
14:41:14.528 --> 14:41:19.528
open, then we're going to revert
with a new error, we're going to

14550
14:41:19.528 --> 14:41:24.528
create raffle underscore
underscore, not open. And of

14551
14:41:24.528 --> 14:41:29.528
course, at the top will create
error, raffle not open. Now

14552
14:41:29.528 --> 14:41:34.528
additionally, let's go down when
we're requesting a random word.

14553
14:41:34.528 --> 14:41:37.528
Let's update the state to be
calculating so other people

14554
14:41:37.528 --> 14:41:41.528
can't jump in here. So right
above our VRF coordinator dot

14555
14:41:41.528 --> 14:41:46.528
request, random words will do s
underscore raffle state equals

14556
14:41:46.528 --> 14:41:51.528
raffle state DOT calculating so
that nobody can enter our

14557
14:41:51.528 --> 14:41:56.528
lottery and nobody can trigger a
new update. And then once we

14558
14:41:56.528 --> 14:41:59.528
fulfill after we pick our
winner, we'll say s raffle state

14559
14:41:59.528 --> 14:42:07.528
equals raffle state DOT open
again. Something else that we

14560
14:42:07.528 --> 14:42:10.528
forgot to do was after we pick a
winner from s players, we need

14561
14:42:10.528 --> 14:42:14.528
to reset our players array. So
let's add that in here as well

14562
14:42:14.528 --> 14:42:21.528
as players equals new address
payable. array of size zero. So

14563
14:42:21.528 --> 14:42:24.528
we'll reset the raffle state.
And we'll reset our players

14564
14:42:24.528 --> 14:42:27.528
array. Alright, great. So now
that we've learned about enum,

14565
14:42:27.528 --> 14:42:30.528
let's add it to our checkup keep
here, we're going to check these

14566
14:42:30.528 --> 14:42:33.529
four things. And if they all
pass checkup keys will be true

14567
14:42:33.529 --> 14:42:36.529
and will trigger the chain the
keepers to request a new random

14568
14:42:36.529 --> 14:42:41.529
winner. So first, we'll say bool
is open. It's going to be equal

14569
14:42:41.529 --> 14:42:49.529
to raffle state. That open
equals equals s underscore

14570
14:42:49.529 --> 14:42:53.529
raffle state. So you can think
of that as this boolean is open

14571
14:42:53.529 --> 14:42:58.529
is going to be true if raffle
state is in an open state, and

14572
14:42:58.529 --> 14:43:01.529
it will be false if raffle state
is in any other state. So great.

14573
14:43:01.529 --> 14:43:04.529
We haven't is open Boolean that
we can check later on. What else

14574
14:43:04.529 --> 14:43:07.529
do we need? Well, we need to
check to make sure our time

14575
14:43:07.529 --> 14:43:10.529
interval is past well, we don't
have a time interval yet. So

14576
14:43:10.529 --> 14:43:14.529
let's create a time interval. In
order to check the time we can

14577
14:43:14.529 --> 14:43:17.529
use another one a solidity is
globally available variables

14578
14:43:17.529 --> 14:43:20.529
with block dot timestamp block
that timestamp returns the

14579
14:43:20.529 --> 14:43:23.529
current timestamp of the
blockchain to get the current

14580
14:43:23.529 --> 14:43:26.529
timestamp, we're gonna need
block dot timestamp. But to get

14581
14:43:26.529 --> 14:43:28.529
if enough time has passed, we're
going to need to get the current

14582
14:43:28.529 --> 14:43:33.529
block dot timestamp minus the
last block timestamp, which we

14583
14:43:33.529 --> 14:43:35.529
don't have yet. Let's go ahead
and create a state variable to

14584
14:43:35.529 --> 14:43:39.529
keep track of the previous block
timestamp. So this is going to

14585
14:43:39.529 --> 14:43:41.529
be a new state variable that
we're going to make. I'm gonna

14586
14:43:41.529 --> 14:43:49.529
say u and 256. Private s
underscore last timestamp.

14587
14:43:49.529 --> 14:43:52.529
And right when we deploy this
contract, we'll update this with

14588
14:43:52.529 --> 14:43:56.529
the current timestamp s last
timestamp equals block dot

14589
14:43:56.529 --> 14:44:01.529
timestamp. Alright, awesome. Now
we have a last block timestamp.

14590
14:44:01.529 --> 14:44:04.529
But we're going to need to check
that the difference between the

14591
14:44:04.529 --> 14:44:07.529
current timestamp and the last
timestamp is greater than some

14592
14:44:07.529 --> 14:44:10.529
interval. So we also need to
create an interval. And this is

14593
14:44:10.529 --> 14:44:13.530
going to be some interval, this
is going to be some number in

14594
14:44:13.530 --> 14:44:18.530
seconds of how long we want to
wait between lottery runs. So

14595
14:44:18.530 --> 14:44:21.530
let's go ahead and add this to
our constructor as well. And do

14596
14:44:21.530 --> 14:44:25.530
a comma here. And we'll do u and
256. Interval. And we're going

14597
14:44:25.530 --> 14:44:31.530
to create another global
variable u and 256 Private s

14598
14:44:31.530 --> 14:44:34.530
underscore interval. And in our
constructor and we'll say s

14599
14:44:34.530 --> 14:44:38.530
interval equals interval. Now
interval isn't going to change

14600
14:44:38.530 --> 14:44:42.530
after we set it. So instead of
making a storage variable, let's

14601
14:44:42.530 --> 14:44:46.530
make it an immutable variable to
save some gas. Okay, perfect.

14602
14:44:46.530 --> 14:44:48.530
Now that we have all this, I'm
actually create a boolean to

14603
14:44:48.530 --> 14:44:52.530
check to see if enough time has
passed. So we'll say Boolean

14604
14:44:52.530 --> 14:44:59.530
time passed equals the current
block that timestamp minus s

14605
14:44:59.530 --> 14:45:05.530
underscore last timestamp. And
we should check to see that this

14606
14:45:05.530 --> 14:45:09.530
is actually greater than I
underscore interval. So we have

14607
14:45:09.530 --> 14:45:12.530
a Boolean check to see if we're
open. It'll be true if we're

14608
14:45:12.530 --> 14:45:15.530
open and we'll have a boolean to
see if enough time has passed.

14609
14:45:15.530 --> 14:45:18.530
This will be true if enough time
has passed. What else should we

14610
14:45:18.530 --> 14:45:21.530
check? While we should check to
see if we have enough players.

14611
14:45:21.530 --> 14:45:26.530
So we'll do Boolean has players
equals and we'll check to see if

14612
14:45:26.530 --> 14:45:32.530
s underscore players dot length
is greater than zero. If s

14613
14:45:32.530 --> 14:45:34.530
players dot length is greater
than zero as players will be

14614
14:45:34.530 --> 14:45:38.530
true, otherwise it'll be false.
And we'll also see if we have a

14615
14:45:38.530 --> 14:45:44.530
balance so we'll do Boolean has
balance equals address. This dot

14616
14:45:44.530 --> 14:45:48.530
balance is greater than zero.
Then finally, we're going to

14617
14:45:48.530 --> 14:45:52.530
take all these booleans and turn
them into the return variable

14618
14:45:52.530 --> 14:45:54.531
that we're looking for. We're
gonna say Boolean up keep

14619
14:45:54.531 --> 14:46:06.531
needed. Equals is open and time
passed. And as players and as

14620
14:46:06.531 --> 14:46:11.531
balance, like that, so all these
combined is gonna be this

14621
14:46:11.531 --> 14:46:15.531
Boolean upkeep needed. And if
this returns true, it's time to

14622
14:46:15.531 --> 14:46:18.531
request a new random number and
it's time to end the lottery. If

14623
14:46:18.531 --> 14:46:21.531
this is false, it's not time
yet, it's not time to end the

14624
14:46:21.531 --> 14:46:24.531
lottery up. Now again, if we go
to the chainlink, documentation

14625
14:46:24.531 --> 14:46:28.531
upkeep needed, actually needs to
return that Boolean upkeep

14626
14:46:28.531 --> 14:46:30.531
needed and some bytes memory
perform data. So we need to

14627
14:46:30.531 --> 14:46:35.531
update we need to update our
function here. And say returns

14628
14:46:35.531 --> 14:46:44.531
full upkeep needed, comma, bytes
memory, perform data star slash.

14629
14:46:44.531 --> 14:46:47.531
And since we've initialized
Boolean up, keep needed up here,

14630
14:46:47.531 --> 14:46:52.531
we don't need to say what type
of upkeep needed is down here.

14631
14:46:52.531 --> 14:46:55.531
Since this will automatically
get returned performed data is

14632
14:46:55.531 --> 14:46:58.531
something that we can use. If we
want to have checkup, keep do

14633
14:46:58.531 --> 14:47:02.531
some other stuff. Depending on
how this checkup keep went. We

14634
14:47:02.531 --> 14:47:04.531
don't really need it to do
anything else. So we can just

14635
14:47:04.531 --> 14:47:07.531
leave it as such. Right. So now
we have a check upkeep, we have

14636
14:47:07.531 --> 14:47:10.531
a way to check to see if it's
time to trigger picking our

14637
14:47:11.531 --> 14:47:12.531
random winner of our lottery

14638
14:47:12.531 --> 14:47:18.531
or our raffle. Now that we
learned how to actually do this

14639
14:47:18.531 --> 14:47:21.531
trigger, let's write the
function that gets executed

14640
14:47:21.531 --> 14:47:25.531
after this returns true. This is
going to be our perform upkeep

14641
14:47:25.531 --> 14:47:28.531
function, which we can see an
example again in the chainlink

14642
14:47:28.531 --> 14:47:31.531
documentation. Now when it's
time to pick a random winner,

14643
14:47:31.531 --> 14:47:34.532
actually, what we're going to do
is just we're just going to call

14644
14:47:34.532 --> 14:47:36.532
this request random winner
function. So instead of having

14645
14:47:36.532 --> 14:47:40.532
this extra function, let's just
transform our request random

14646
14:47:40.532 --> 14:47:44.532
winner function into this
perform upkeep. Since once check

14647
14:47:44.532 --> 14:47:46.532
upkeep returns true, the chain
link nodes will automatically

14648
14:47:47.532 --> 14:47:50.532
call this perform upkeep
function. So in function request

14649
14:47:50.532 --> 14:47:54.532
random winner, let's rename this
to perform upkeep. And we'll

14650
14:47:54.532 --> 14:47:58.532
have it take the input parameter
bytes called Data perform data

14651
14:47:58.532 --> 14:48:03.532
bytes, called data, perform
data. In our checkup, keep we

14652
14:48:03.532 --> 14:48:06.532
had to perform data, we would
automatically pass it to our

14653
14:48:06.532 --> 14:48:08.532
performance keep, we're not
going to pass anything to

14654
14:48:08.532 --> 14:48:11.532
perform upkeep, we can leave it
commented out like this. Since

14655
14:48:11.532 --> 14:48:14.532
perform upkeep is actually
identified in the keeper

14656
14:48:14.532 --> 14:48:17.532
compatible interface, this is
now going to have to override

14657
14:48:17.532 --> 14:48:20.532
that function. Now we want to do
a little bit of validation

14658
14:48:20.532 --> 14:48:24.532
before we continue here. Because
right now anybody can call our

14659
14:48:24.532 --> 14:48:26.532
perform upkeep function. So we
want to make sure that it only

14660
14:48:26.532 --> 14:48:30.532
gets called when checkup keep is
true. An easy way for us to do

14661
14:48:30.532 --> 14:48:33.532
that is to actually call our own
checkup, keep function. Now

14662
14:48:33.532 --> 14:48:36.532
right now, checkup keep it's an
external. So we actually can't

14663
14:48:36.532 --> 14:48:39.532
call our own checkup keep
function. So let's change it to

14664
14:48:39.532 --> 14:48:42.532
public so that even our own
smart contracts can call this

14665
14:48:42.532 --> 14:48:45.532
checkup keep function. Now that
we've made it public in perform

14666
14:48:45.532 --> 14:48:49.532
upkeep, we can call checkup,
keep passing nothing, and then

14667
14:48:49.532 --> 14:48:52.532
return the upkeep needed and
perform data which we don't

14668
14:48:52.532 --> 14:48:57.532
really care about. So we'll get
we'll get that ball up keep

14669
14:48:57.532 --> 14:49:01.532
needed. And then we don't care
about perform data. So we'll

14670
14:49:01.532 --> 14:49:06.532
leave that blank equals check up
keep. And we'll pass it a blank

14671
14:49:06.532 --> 14:49:10.532
called data. Now, we want to
make sure that this is true in

14672
14:49:10.532 --> 14:49:12.532
order to keep going with the
function. So we could write a

14673
14:49:12.532 --> 14:49:19.533
require here, but we're going to
do if not up keep needed, then

14674
14:49:19.533 --> 14:49:24.533
we're going to revert with a new
error that we create raffle.

14675
14:49:24.533 --> 14:49:29.533
upkeep not needed. And we're
going to pass some variables to

14676
14:49:29.533 --> 14:49:29.533
this error

14677
14:49:29.533 --> 14:49:32.533
so that whoever was running into
this bug can hopefully see why

14678
14:49:32.533 --> 14:49:34.533
they're getting this error. So
we'll pass the balance of this

14679
14:49:34.533 --> 14:49:38.533
contract just in case there's no
ether in here. We'll add the

14680
14:49:38.533 --> 14:49:41.533
players dot length, just in case
there's no players. And we'll

14681
14:49:41.533 --> 14:49:47.533
add a un 256 s underscore raffle
state. Make sure that the

14682
14:49:47.533 --> 14:49:52.533
raffles actually open. And then
of course, we'll need to create

14683
14:49:52.533 --> 14:49:56.533
this air at the top air, raffle
upkeep not needed, which is

14684
14:49:56.533 --> 14:50:03.533
going to take a un 256 current
balance un 256 non players and

14685
14:50:03.533 --> 14:50:08.533
you went to fit six raffle
state. Our code is starting to

14686
14:50:08.533 --> 14:50:11.533
look really professional. This
is awesome. Now something that

14687
14:50:11.533 --> 14:50:14.533
we forgot to do back in the
fulfill random words because we

14688
14:50:14.533 --> 14:50:17.533
actually forgot to reset
timestamp every time a winner is

14689
14:50:17.533 --> 14:50:21.533
picked. We want to reset the
timestamp as well so that we can

14690
14:50:21.533 --> 14:50:23.533
wait another interval and let
people participate in the

14691
14:50:23.533 --> 14:50:27.533
lottery for that interval. So
we'll scroll down into fulfill

14692
14:50:27.533 --> 14:50:31.533
random words. And right after we
reset players will also reset

14693
14:50:31.533 --> 14:50:34.533
the timestamp. Okay great and I
think we're just about done

14694
14:50:34.533 --> 14:50:40.533
here. Let's add a little bit of
natspec to make this look even

14695
14:50:40.533 --> 14:50:43.533
more professional and and give
people who are reading our

14696
14:50:43.533 --> 14:50:48.533
contract even more information.
So let's add title here at title

14697
14:50:48.533 --> 14:50:52.533
and we'll say a sample raffle
contract will say an author is

14698
14:50:52.533 --> 14:50:55.534
going to be me Patrick Collins
or you can put your own name

14699
14:50:55.534 --> 14:51:01.534
there as well at notice. This
contract is for creating and

14700
14:51:01.534 --> 14:51:05.534
untampered orrible decentralized
smart contract. And then we'll

14701
14:51:05.534 --> 14:51:12.534
do add Dev, this implements
chain link VRF v two, and chain

14702
14:51:12.534 --> 14:51:16.534
link keepers. Alright, awesome.
We've got our type declarations,

14703
14:51:16.534 --> 14:51:19.534
we've got our state variables,
we've got lottery variables,

14704
14:51:19.534 --> 14:51:22.534
which are still state variables,
we've got our events. Now it's

14705
14:51:22.534 --> 14:51:26.534
time for our functions.
Afterwards, we've done a little

14706
14:51:26.534 --> 14:51:29.534
bit of natspec, at least on our
check upkeep. If you want to add

14707
14:51:29.534 --> 14:51:32.534
some more natspec on things like
enter, raffle, perform upkeep,

14708
14:51:32.534 --> 14:51:35.534
etc, you can absolutely do so.
And then down at the bottom, we

14709
14:51:35.534 --> 14:51:38.534
have our views slash pure getter
functions. Let's see, do we want

14710
14:51:38.534 --> 14:51:41.534
any other getter functions here?
Well, we probably want to give

14711
14:51:41.534 --> 14:51:43.534
people the chance to get a
raffle state. So we'll do

14712
14:51:43.534 --> 14:51:50.534
function, get raffle state, this
will be a public, you returns a

14713
14:51:50.534 --> 14:51:57.534
raffle state. We'll say return s
underscore raffle state, we

14714
14:51:57.534 --> 14:52:00.534
probably want to give people the
chance to get the number of

14715
14:52:00.534 --> 14:52:03.534
words. And this is going to be a
little bit interesting here

14716
14:52:03.534 --> 14:52:10.534
running. So if we do function,
get num words, public view

14717
14:52:10.534 --> 14:52:15.534
returns, you went to the six
return num words, you'll see

14718
14:52:15.534 --> 14:52:19.534
something interesting happened
here. We pull up our compiler

14719
14:52:19.534 --> 14:52:24.534
and run hh compile. Hopefully
everything works here. Oh, and

14720
14:52:24.534 --> 14:52:28.534
everything doesn't work because
I didn't import this correctly.

14721
14:52:28.534 --> 14:52:31.534
Let's fix that. Let's try again.

14722
14:52:31.534 --> 14:52:35.535
Oh, there's a couple things I
missed. Let's fix es players.

14723
14:52:35.535 --> 14:52:37.535
This is why it's good to compile
as you code as players dot

14724
14:52:37.535 --> 14:52:42.535
length. Let's try again. And I
spelt interval wrong. I

14725
14:52:42.535 --> 14:52:47.535
underscore inter vol strike to
compile again, see how many more

14726
14:52:47.535 --> 14:52:51.535
spelling mistakes I made. And
there it is. I underscore in

14727
14:52:51.535 --> 14:52:56.535
error go to paste that and we do
get another error here. Invalid

14728
14:52:56.535 --> 14:52:59.535
type for argument in a function
call invalid implicit conversion

14729
14:52:59.535 --> 14:53:02.535
from literal string to bytes
called data requested. Since

14730
14:53:02.535 --> 14:53:06.535
we're passing this empty string
here. And checkup keep needs a

14731
14:53:06.535 --> 14:53:09.535
call data called data actually
doesn't work with strings. So we

14732
14:53:09.535 --> 14:53:12.535
need to make this bytes memory
instead. And our compiler is now

14733
14:53:12.535 --> 14:53:15.535
happy with us. And I spell it
the timestamp wrong. That's a

14734
14:53:15.535 --> 14:53:19.535
lowercase s so and you might see
some squiggles here on Check

14735
14:53:20.535 --> 14:53:23.535
upkeep, we could make this a
view function since we're not

14736
14:53:23.535 --> 14:53:26.535
actually modifying any state.
But I want to keep it public for

14737
14:53:26.535 --> 14:53:29.535
reasons I'll show you a little
bit later. But finally we get

14738
14:53:29.535 --> 14:53:32.535
the the yellow squiggly that I
was looking for here. And if we

14739
14:53:32.535 --> 14:53:37.535
run hh compile, we should see a
warning in our compiler as well.

14740
14:53:37.535 --> 14:53:39.535
Okay, so we see all those yellow
squigglies here. Unnamed return

14741
14:53:39.535 --> 14:53:43.535
variable can remain unassigned.
We need this bytes memory in

14742
14:53:43.535 --> 14:53:46.535
here because that's what the
keepers are looking for. Morning

14743
14:53:46.535 --> 14:53:49.535
function state mutability can be
restricted to view for our

14744
14:53:49.535 --> 14:53:52.535
function checkup key. You can
make a view if you want, but I'm

14745
14:53:52.535 --> 14:53:54.535
going to keep it public for
reasons I'll show you a little

14746
14:53:54.535 --> 14:53:58.535
bit later. And finally, function
state mutability can be

14747
14:53:58.535 --> 14:54:01.535
restricted to pure this is what
I wanted to show you since num

14748
14:54:01.535 --> 14:54:05.535
words is actually in the
bytecode, since it's a constant

14749
14:54:05.535 --> 14:54:08.535
variable technically isn't
reading from storage, and

14750
14:54:08.535 --> 14:54:13.535
therefore this can be a pure
function. Returning num words

14751
14:54:13.535 --> 14:54:16.536
doesn't actually read in
storage, it literally will go

14752
14:54:16.536 --> 14:54:20.536
and read the number one. So
doing get num words in solidity

14753
14:54:20.536 --> 14:54:23.536
with num words being a constant
variable, it's going to

14754
14:54:23.536 --> 14:54:27.536
literally be the exact same as
saying get one and we would

14755
14:54:27.536 --> 14:54:29.536
return one here, we might also
want to get the number of

14756
14:54:29.536 --> 14:54:35.536
players. So we'll create a
function get number of players.

14757
14:54:35.536 --> 14:54:42.536
And this will be a public view,
returns a un 256. Turn s

14758
14:54:42.536 --> 14:54:47.536
underscore players dot length.
We're also probably going to

14759
14:54:47.536 --> 14:54:51.536
want the latest timestamp. So
we'll do function get latest

14760
14:54:51.536 --> 14:54:58.536
timestamp. public view returns
you in 256. And we're just going

14761
14:54:58.536 --> 14:55:05.536
to return s underscore last
timestamp. And maybe we'll want

14762
14:55:05.536 --> 14:55:09.536
to do request confirmation. So
we'll do function GET request

14763
14:55:09.536 --> 14:55:14.536
confirmations. Public pure since
request confirmations is also a

14764
14:55:14.536 --> 14:55:20.536
constant function returns you
went to you went to 56 Turn

14765
14:55:20.536 --> 14:55:25.536
request confirmations. All
right, we've got some wonderful

14766
14:55:25.536 --> 14:55:28.536
getters here. Some views slash
pure functions, we have a way to

14767
14:55:28.536 --> 14:55:33.536
get a random number we have a
way in a decentralized context.

14768
14:55:33.536 --> 14:55:36.536
Automatic automatically execute.
picking a random winner we have

14769
14:55:36.536 --> 14:55:40.536
a way for people to enter our
raffle to enter this lottery.

14770
14:55:40.536 --> 14:55:46.536
And we have a bullet proof way
to solve creating a truly fair

14771
14:55:46.536 --> 14:55:50.536
decentralized lottery. Oh my
goodness. Let's do one more

14772
14:55:50.536 --> 14:55:54.537
compile for good measure H H
compile. And these are just

14773
14:55:54.537 --> 14:55:57.537
warnings. So we're good to go
here. Our code is compiling

14774
14:55:57.537 --> 14:56:03.537
successfully. Like I said
Normally, this definitely isn't

14775
14:56:03.537 --> 14:56:05.537
going to be the way that you're
going to write your smart

14776
14:56:05.537 --> 14:56:09.537
contracts, it's almost
impossible to write a full smart

14777
14:56:09.537 --> 14:56:11.537
contract without making any
mistakes. And without flipping

14778
14:56:11.537 --> 14:56:14.537
back and forth between
documentation, I have already

14779
14:56:14.537 --> 14:56:18.537
written this contract many times
myself, and I still made a whole

14780
14:56:18.537 --> 14:56:21.537
bunch of mistakes. So it is
totally reasonable and totally

14781
14:56:21.537 --> 14:56:25.537
rational for anybody and
everybody to make mistakes going

14782
14:56:25.537 --> 14:56:28.537
through this. And to use
resources and to write tests

14783
14:56:28.537 --> 14:56:31.537
along the way. Now that we have
our raffle dot Seoul created,

14784
14:56:31.537 --> 14:56:34.537
it's time to add everything
else. So we're going to come

14785
14:56:34.537 --> 14:56:38.537
over here, we're gonna create a
new folder, and add our deploy

14786
14:56:38.537 --> 14:56:39.537
folder per usual.

14787
14:56:39.537 --> 14:56:41.537
And we're going to do exactly
what we've already done a couple

14788
14:56:41.537 --> 14:56:44.537
of times, we're going to create
some scripts to deploy our

14789
14:56:44.537 --> 14:56:46.537
raffle contract. Now with our
raffle contract, there's a

14790
14:56:46.537 --> 14:56:49.537
couple of things in here that we
want to make note of first thing

14791
14:56:49.537 --> 14:56:52.537
is that our constructor right
now is absolutely massive. There

14792
14:56:53.537 --> 14:56:56.537
are a ton of parameters in here
that we need to account for.

14793
14:56:56.537 --> 14:56:58.537
Let's take a look at our
constructors and see if there's

14794
14:56:58.537 --> 14:57:01.537
any contracts that we're already
interacting with. Okay, VRF,

14795
14:57:01.537 --> 14:57:05.537
coordinator v2. This is a
contract address, entrance fee,

14796
14:57:05.537 --> 14:57:09.537
no gasline, no subscription ID
no callback, guestimate No, and

14797
14:57:09.537 --> 14:57:13.537
interval. No. So knowing that
this is an address should be a

14798
14:57:13.537 --> 14:57:15.537
tip that Ah, okay, we're
probably going to need to deploy

14799
14:57:15.537 --> 14:57:19.537
some mocks. For this, since
we're going to need to interact

14800
14:57:19.537 --> 14:57:22.537
with a VRF coordinator contract
that's outside of our project.

14801
14:57:22.537 --> 14:57:24.537
But let's go ahead and start
working on our raffle deployment

14802
14:57:24.537 --> 14:57:27.537
script first, and we know we're
going to have to deploy some

14803
14:57:27.537 --> 14:57:30.537
mocks. So we'll just keep that
in mind. So let's create a new

14804
14:57:30.537 --> 14:57:38.538
file. Oh, one, deploy raffle.js.
And let's get started deploying

14805
14:57:38.538 --> 14:57:41.538
our raffle contract. Now, this
is going to look really similar

14806
14:57:41.538 --> 14:57:43.538
to what we've done before. And
we're going to do it again here.

14807
14:57:43.538 --> 14:57:46.538
If you want to use your previous
deploy scripts as a reference, I

14808
14:57:46.538 --> 14:57:49.538
absolutely recommend you do so.
But let's get started with

14809
14:57:49.538 --> 14:57:56.538
module that exports equals an
async function. That's going to

14810
14:57:56.538 --> 14:58:04.538
take get named accounts and
deployments. As input

14811
14:58:04.538 --> 14:58:10.538
parameters, then we're going to
do const. Deploy log equals

14812
14:58:10.538 --> 14:58:15.538
deployments, then we're gonna
say const, Deployer, equals

14813
14:58:15.538 --> 14:58:21.538
await, get named accounts. Let's
go to our config and update

14814
14:58:21.538 --> 14:58:24.538
module that exports to to have
this I'm just going to copy

14815
14:58:24.538 --> 14:58:27.538
paste, so that employer is going
to be defaulted to account zero

14816
14:58:27.538 --> 14:58:30.538
and player is going to be
defaulted to account one, if you

14817
14:58:30.538 --> 14:58:32.538
want to go ahead and write this
out, feel free to pause and

14818
14:58:32.538 --> 14:58:34.538
write out your name accounts.
Right now, there's gonna be a

14819
14:58:34.538 --> 14:58:38.538
lot of boilerplate in our heart
hat.config.js. So feel free to

14820
14:58:38.538 --> 14:58:42.538
have the GitHub repo for this
lesson up with you or your

14821
14:58:42.538 --> 14:58:44.538
previous scripts that you've
already written as a reference

14822
14:58:44.538 --> 14:58:47.538
named accounts Deployer. And
we're also going to have a

14823
14:58:47.538 --> 14:58:51.538
player named account so that we
can separate different users or

14824
14:58:51.538 --> 14:58:53.538
different players who are
interacting with our contracts.

14825
14:58:53.538 --> 14:58:55.538
But for now, we're gonna grab
our Deployer. And we're gonna

14826
14:58:56.538 --> 14:58:59.538
get started. Now similar to last
time, we would just do const,

14827
14:58:59.538 --> 14:59:05.538
raffle equals await ploy,
raffle, comma, and then add all

14828
14:59:05.538 --> 14:59:10.538
of our stuff in here, right? So
this would be from Deployer.

14829
14:59:10.538 --> 14:59:14.539
args, we're going to have a ton
of args. So we're going to come

14830
14:59:14.539 --> 14:59:19.539
back to this. And then log is
going to be true. And then we're

14831
14:59:19.539 --> 14:59:21.539
going to have wait
confirmations, there's a little

14832
14:59:21.539 --> 14:59:23.539
bit more boilerplate we need to
work with here in our Hardhead

14833
14:59:23.539 --> 14:59:26.539
config, we don't have a network
here. So let's add our network

14834
14:59:26.539 --> 14:59:29.539
information. So we can get those
block confirmations will be

14835
14:59:29.539 --> 14:59:33.539
specific in here, as well. And
we'll say default network is

14836
14:59:33.539 --> 14:59:37.539
going to be hard hat. And then
we'll say

14837
14:59:37.539 --> 14:59:40.539
networks, and we'll add our
network information that's going

14838
14:59:40.539 --> 14:59:46.539
to be working with heart hub,
which has a chain ID of 31337

14839
14:59:46.539 --> 14:59:49.539
miles, we'll put that in here as
well. And block confirmations

14840
14:59:49.539 --> 14:59:52.539
were just set to one lot this
column here, we're also gonna be

14841
14:59:53.539 --> 14:59:56.539
running some staging tests on
the Rinkeby network. So we'll

14842
14:59:56.539 --> 15:00:02.539
add rink B in here with a chain
ID of four, block confirmations

14843
15:00:02.539 --> 15:00:07.539
of six, and we need to add a URL
and then also some accounts for

14844
15:00:07.539 --> 15:00:12.539
our URL. We've done this 100
times. We'll do const. rinky

14845
15:00:12.539 --> 15:00:18.539
dink could be RPC URL equals
process study and v dot rake,

14846
15:00:18.539 --> 15:00:22.539
the RPC URL, that's private key,
blah, blah, blah, we're going to

14847
15:00:22.539 --> 15:00:26.539
add all these same variables
from our last projects. So I'm

14848
15:00:26.539 --> 15:00:28.539
going to ask you to pause here
and just copy paste all those

14849
15:00:28.539 --> 15:00:32.539
variables from our last project.
Boom, like so since running

14850
15:00:32.539 --> 15:00:35.539
rink, prpc, URL, private key
corn market cap and ether scan,

14851
15:00:35.539 --> 15:00:39.539
we're also going to want to make
sure you folder, excuse me, new

14852
15:00:39.539 --> 15:00:43.539
file, dot env. And we're going
to drop all of our information

14853
15:00:43.539 --> 15:00:47.539
in here our rink, prpc, URL,
private key, ether scan API key,

14854
15:00:47.539 --> 15:00:50.539
and then our coin market cap API
key as well. Now that we have

14855
15:00:50.539 --> 15:00:56.540
our private key or ring prpc URL
down in URL, B RPC URL, and for

14856
15:00:56.540 --> 15:00:59.540
accounts, we're just going to
add that single private key. Now

14857
15:00:59.540 --> 15:01:03.540
for weight confirmations is
going to equal For network

14858
15:01:03.540 --> 15:01:10.540
config dot block con formations,
or one, we're gonna have to

14859
15:01:10.540 --> 15:01:13.540
import network from Hardhead,
which looks like my VS code

14860
15:01:13.540 --> 15:01:16.540
automatically did for me. Thanks
VS code. So this is how we're

14861
15:01:16.540 --> 15:01:19.540
going to deploy a raffle.
Obviously, we have a ton of

14862
15:01:19.540 --> 15:01:22.540
arguments that we need to
account for. So let's get to it.

14863
15:01:22.540 --> 15:01:24.540
Let's look at our raffle
constructor to see what we need

14864
15:01:24.540 --> 15:01:27.540
to get. Okay, well, the first
thing that we need to get via of

14865
15:01:27.540 --> 15:01:30.540
coordinator v2, we're gonna use
the same strategy we used in our

14866
15:01:30.540 --> 15:01:34.540
Funmi project with using mocks,
if we're on a development chain,

14867
15:01:34.540 --> 15:01:37.540
and using the actual contract
address if we're on a test net,

14868
15:01:37.540 --> 15:01:40.540
or a live network, so let's get
to it. So let's go ahead,

14869
15:01:40.540 --> 15:01:46.540
recreate that helper, hard hat
config dot j s and create that

14870
15:01:46.540 --> 15:01:53.540
const. Network. Config, say it
equals for hard hat, we're going

14871
15:01:53.540 --> 15:01:56.540
to use a mock. So we don't need
to put that in here for now. But

14872
15:01:56.540 --> 15:02:01.540
for rink B, let's go ahead, but
a foreign here, so the name is

14873
15:02:01.540 --> 15:02:04.540
going to be Rinkeby. And we're
going to need to go to the chain

14874
15:02:04.540 --> 15:02:07.540
link documentation, the VRF
contracts, and we're going to

14875
15:02:07.540 --> 15:02:11.540
need to grab the RF coordinator
for the Rinkeby. Test net, we're

14876
15:02:11.540 --> 15:02:15.540
going to grab this address here,
plop it in here, we'll say V RF

14877
15:02:15.540 --> 15:02:20.540
core did an eight tour v two,
bam, right like that. So back in

14878
15:02:20.540 --> 15:02:23.540
our deploy raffle, we're gonna
have to pick whether or not to

14879
15:02:23.540 --> 15:02:26.540
use the V RF coordinator v two
in the network config or some

14880
15:02:26.540 --> 15:02:30.540
mock that we deployed, which of
course, leads us to us having to

14881
15:02:30.540 --> 15:02:37.541
deploy a mock, let's create the
new file 00. Deploy marks.js. So

14882
15:02:37.541 --> 15:02:43.541
same thing module that exports
equals async function where it's

14883
15:02:43.541 --> 15:02:48.541
taking, get named accounts, and
deployments, as its input

14884
15:02:48.541 --> 15:02:52.541
variables from the heart at
runtime environment, or do const

14885
15:02:52.541 --> 15:02:58.541
deploy COMM A log equals
deployments. And then const,

14886
15:02:58.541 --> 15:03:05.541
Deployer equals await, get named
accounts, Excel, and then we're

14887
15:03:05.541 --> 15:03:08.541
going to grab the chain ID as
well as we're going to only

14888
15:03:08.541 --> 15:03:11.541
wants to deploy this on a
development chain. So we'll do

14889
15:03:11.541 --> 15:03:17.541
const chain ID equals network
dot config dot chain ID. Now

14890
15:03:17.541 --> 15:03:19.541
we're going to only want to
deploy mocks, if we're on a

14891
15:03:19.541 --> 15:03:22.541
development chain. So once
again, we're going to go to our

14892
15:03:22.541 --> 15:03:24.541
helper config, we're going to
add those development chains in

14893
15:03:24.541 --> 15:03:31.541
here. We'll say const,
development chains equals hard

14894
15:03:31.541 --> 15:03:35.541
hat, and localhost. And then
we're gonna want to export both

14895
15:03:35.541 --> 15:03:42.541
of these. So module, dot
exports, equals network config,

14896
15:03:42.541 --> 15:03:47.541
and development chance. Now in
our deploy mocks, we're gonna

14897
15:03:47.541 --> 15:03:55.541
want to grab those are saying
const development chains, equals

14898
15:03:55.541 --> 15:04:01.541
require dot dot slash helper
helper hardhat config. Now we

14899
15:04:01.541 --> 15:04:07.541
can check to see if development
chains dot includes the network

14900
15:04:07.541 --> 15:04:10.541
dot name that we're currently
on. If we're in a development

14901
15:04:10.541 --> 15:04:14.542
chain, we're gonna go ahead and
log local network, the

14902
15:04:14.542 --> 15:04:20.542
protected, deploying box. And
now we'll have to deploy a mock

14903
15:04:20.542 --> 15:04:25.542
VRF coordinator, where do we get
a mock VRF to coordinator Well,

14904
15:04:25.542 --> 15:04:29.542
let's go ahead and create one of
those.

14905
15:04:29.542 --> 15:04:33.542
We go to the chainlink. GitHub
again, we go to contracts. So C

14906
15:04:33.542 --> 15:04:39.542
0.8, actually have a mocks
folder with VF coordinator v2

14907
15:04:39.542 --> 15:04:42.542
Mach dot Sol, and we're just
going to use this as our mock.

14908
15:04:42.542 --> 15:04:45.542
So in our contracts folder,
we're gonna create a new file

14909
15:04:45.542 --> 15:04:53.542
called test new file called V RF
core, in a core, the two mock

14910
15:04:53.542 --> 15:04:56.542
dot Sol, and we're just going to
import this mock and have it be

14911
15:04:56.542 --> 15:05:04.542
our mock. So we'll do spdx.
We'll do pragma, solidity,

14912
15:05:04.542 --> 15:05:08.542
carrot zero, point 8.0, or seven
or whatever we want to do, we'll

14913
15:05:08.542 --> 15:05:15.542
do import at chainlink slash
contracts slash SRC slash v 0.8.

14914
15:05:15.542 --> 15:05:23.542
Slash, mocks, slash VRF. Pour
did a tour B to mock that soul.

14915
15:05:23.542 --> 15:05:25.542
And we'll just check to see if
it compiles with Hardhead

14916
15:05:25.542 --> 15:05:28.542
compile, and it looks like it's
compiling as well. Awesome. So

14917
15:05:28.542 --> 15:05:31.542
now that we have our mock
contract, we can actually go

14918
15:05:31.542 --> 15:05:38.542
ahead and deploy it. So we'll do
a weight loi, the RF core de ne

14919
15:05:38.542 --> 15:05:41.542
Tor V to Mach

14920
15:05:41.542 --> 15:05:44.542
comma, and then we'll give it
our parameters in here. We'll

14921
15:05:44.542 --> 15:05:49.542
say from Deployer. Log is going
to be true, and then we're going

14922
15:05:49.542 --> 15:05:53.542
to do our arguments. Now, what
are the arguments of this VRF

14923
15:05:53.542 --> 15:05:57.543
coordinator, v2 Mk. Well, if we
open the VRF coordinator v2

14924
15:05:57.543 --> 15:06:02.543
Mock, right in our VS code, or
on GitHub, we can actually see

14925
15:06:02.543 --> 15:06:05.543
We will roll over to the
constructor that it takes two

14926
15:06:05.543 --> 15:06:10.543
things. It takes a base fee and
a gas price link. What are these

14927
15:06:10.543 --> 15:06:14.543
first one? Well, the first one
is this const base fee. If we go

14928
15:06:14.543 --> 15:06:17.543
back to the documentation, we
can see that there's this

14929
15:06:17.543 --> 15:06:22.543
premium section of 0.25 Link
rink B, this means that for each

14930
15:06:22.543 --> 15:06:27.543
request, there's a base fee of
0.25 link for every request. So

14931
15:06:27.543 --> 15:06:30.543
anytime we want to request a
random number on Rinckey, it's

14932
15:06:30.543 --> 15:06:35.543
going to cost us 0.25. Link, or
you can think of it as 0.25

14933
15:06:35.543 --> 15:06:39.543
Oracle gas to make this request.
So back in our deploy mocks, we

14934
15:06:39.543 --> 15:06:44.543
can say base V equals, we could
resemble Rinckey here and do 25,

14935
15:06:44.543 --> 15:06:49.543
blah, blah, blah, or we could do
ethers dot utils dot parse eath,

14936
15:06:49.543 --> 15:06:55.543
of 0.25. And I'll even put a
little comment here, say 0.25 is

14937
15:06:55.543 --> 15:07:02.543
the premium, it costs 0.25 Link
per request. And remember, the

14938
15:07:02.543 --> 15:07:06.543
reason that this cost 0.25 Link
per request versus the price

14939
15:07:06.543 --> 15:07:09.543
feeds didn't cost anything is
because the price feeds. If we

14940
15:07:09.543 --> 15:07:13.543
look back at a chain that link,
each one of these price feeds is

14941
15:07:13.543 --> 15:07:17.543
being sponsored by a group of
protocols who are paying for all

14942
15:07:17.543 --> 15:07:20.543
these requests already, since
there isn't a sponsor for this,

14943
15:07:20.543 --> 15:07:24.543
we are the only ones requesting
the randomness, we get to be the

14944
15:07:24.543 --> 15:07:26.543
ones to actually sponsor getting
this random number, then the

14945
15:07:26.543 --> 15:07:30.543
second thing here is going to be
the gas price link. So let's

14946
15:07:30.543 --> 15:07:35.544
create another const here to
const. gas price link. But what

14947
15:07:35.544 --> 15:07:39.544
this is, is actually a
calculated value is a calculated

14948
15:07:39.544 --> 15:07:44.544
value based on the gas price of
the chain. Here's an example if

14949
15:07:44.544 --> 15:07:47.544
we were to request a random
number on Aetherium, and the

14950
15:07:47.544 --> 15:07:52.544
eath price skyrocketed up to
like to like a billion dollars,

14951
15:07:52.544 --> 15:07:55.544
gas would be incredibly,
incredibly expensive. Now when

14952
15:07:55.544 --> 15:07:59.544
chain link nodes respond chain
link nodes pay the gas fees, who

14953
15:07:59.544 --> 15:08:05.544
give us randomness, and do
external execution, the chain

14954
15:08:05.544 --> 15:08:07.544
link nodes are actually the ones
that pay the gas when returning

14955
15:08:07.544 --> 15:08:11.544
randomness or executing an
upkeep or etc. If we go to our

14956
15:08:11.544 --> 15:08:15.544
raffle dot soul, and scroll down
to perform upkeep, or fulfill

14957
15:08:15.544 --> 15:08:18.544
random words, it's actually the
chain link nodes that are

14958
15:08:18.544 --> 15:08:21.544
calling these two functions and
paying the gas for it, they get

14959
15:08:21.544 --> 15:08:24.544
paid in Oracle gas to offset
those costs. But if the price of

14960
15:08:24.544 --> 15:08:28.544
eath, or any native blockchain
skyrocketed the chain that nodes

14961
15:08:28.544 --> 15:08:31.544
itself to pay the gas fee. So
the chain link nodes have a

14962
15:08:31.544 --> 15:08:34.544
calculated price have a
calculated variable called the

14963
15:08:34.544 --> 15:08:37.544
gas price per link, which
fluctuates based off the price

14964
15:08:37.544 --> 15:08:40.544
of the actual chain, so that
they never go bankrupt.

14965
15:08:41.544 --> 15:08:43.544
Basically, the price of a
request changes based off the

14966
15:08:43.544 --> 15:08:45.544
price of gas for that
blockchain, you can kind of

14967
15:08:45.544 --> 15:08:49.544
think of this as the link per
gas, if you will, for now we can

14968
15:08:49.544 --> 15:08:52.544
kind of just set it to whatever
we want. And we'll just set it

14969
15:08:52.544 --> 15:08:58.544
to one e nine, which is going to
be equivalent to 1123456789. So

14970
15:08:58.544 --> 15:09:01.544
now that we have the base fee,
and the gas price link, we'll

14971
15:09:01.544 --> 15:09:05.544
grab this base fee, we'll have
these be the arguments for our

14972
15:09:05.544 --> 15:09:08.544
VR chord, enter V to mock, so
we'll say and actually we can

14973
15:09:08.544 --> 15:09:15.545
delete that will say const, args
equals base fee, and gas price

14974
15:09:15.545 --> 15:09:18.545
link, then we can take this args
variable and just plop it in

14975
15:09:18.545 --> 15:09:23.545
here. Now we can do log mocks
deployed, then we can do log

14976
15:09:23.545 --> 15:09:26.545
that a little line like this to
let people know that this deploy

14977
15:09:26.545 --> 15:09:29.545
script is done, then we'll just
do a module that exports dot

14978
15:09:29.545 --> 15:09:35.545
tags equals all and mocks. So
now that we have a view of

14979
15:09:35.545 --> 15:09:38.545
coordinator v2 Mock deployed,
we'll come back over to our

14980
15:09:38.545 --> 15:09:42.545
raffle and make some code around
it. Similar to what we just did

14981
15:09:42.545 --> 15:09:46.545
with our deploy mocks. We can
say if development chains that

14982
15:09:46.545 --> 15:09:51.545
includes network dot name, we'll
do some stuff. And we need to

14983
15:09:51.545 --> 15:09:54.545
import development chains from
our helper Hardhead config. And

14984
15:09:54.545 --> 15:09:57.545
we need to import network from
hard hat. My VS code

14985
15:09:57.545 --> 15:10:00.545
automatically added them Wow,
thanks VS code. Let's even just

14986
15:10:00.545 --> 15:10:03.545
do const args and make this
variable down here. Stick it in

14987
15:10:03.545 --> 15:10:07.545
args. Our first argument is
going to need to be this Vera fi

14988
15:10:07.545 --> 15:10:12.545
to coordinator so let's make a
variable we'll say let VRF core

14989
15:10:12.545 --> 15:10:17.545
need torby to address and if
we're on a development chain,

14990
15:10:17.545 --> 15:10:21.545
we're going to grab that mock
contract. So we'll say const

14991
15:10:21.545 --> 15:10:28.545
PRF, Cor de ATAR V to mock
equals await ethers dot get

14992
15:10:28.545 --> 15:10:35.545
contract, the RF cord the cord
to NATO Tor v two MK, and then

14993
15:10:35.545 --> 15:10:40.545
we can set the RF coordinator v
two address equals VRF core

14994
15:10:40.545 --> 15:10:43.545
denater V two mach dot

14995
15:10:43.545 --> 15:10:50.545
address. Cool. We have that
address here. Else if we're not

14996
15:10:50.545 --> 15:10:54.545
on a local network, the VRF v2
coordinator address is simply

14997
15:10:54.545 --> 15:10:58.546
going to be derived from our
network config. So let's import

14998
15:10:58.546 --> 15:11:01.546
the network config as well from
our helper Hardhead config and

14999
15:11:01.546 --> 15:11:07.546
we'll say else VRF coordinator
v2 address equals network config

15000
15:11:07.546 --> 15:11:11.546
of our chain ID. Let's which
actually sorry, we do need the

15001
15:11:11.546 --> 15:11:16.546
chain ID cons chain ID equals
network dot config dot chain ID,

15002
15:11:16.546 --> 15:11:23.546
chain ID of VR coordinator V to
chain ID. You're a coordinator

15003
15:11:23.546 --> 15:11:27.546
v2. Alright, perfect. We've got
the setup to work with our VRF

15004
15:11:27.546 --> 15:11:30.546
coordinator v2 address. What
else do we need from our raffle?

15005
15:11:30.546 --> 15:11:33.546
Well, we need an entrance fee,
we probably want to change the

15006
15:11:33.546 --> 15:11:35.546
entrance fee depending on what
chain we're on, we're on a more

15007
15:11:35.546 --> 15:11:38.546
expensive chain, we might want
to make this higher than others.

15008
15:11:38.546 --> 15:11:42.546
So let's go ahead back to our
helper Hardhead config and make

15009
15:11:42.546 --> 15:11:47.546
an entrance fee based off of the
blockchain, so for NP, maybe we

15010
15:11:47.546 --> 15:11:52.546
want to make it 0.01 eath. So we
could say ethers dot utils,

15011
15:11:52.546 --> 15:11:58.546
parse ether of 0.01. And once
again, thank you VS code for

15012
15:11:58.546 --> 15:12:01.546
automatically dropping that in
for me. And we're also going to

15013
15:12:01.546 --> 15:12:03.546
want an entrance fee for our
heart app, we can also set a

15014
15:12:03.546 --> 15:12:07.546
default in here, but let's just
be a little more explicit. So

15015
15:12:07.546 --> 15:12:12.546
we'll say 31337. The name of
this is Art app, we don't need

15016
15:12:12.546 --> 15:12:14.546
to give it a veneer of
coordinator v2 address because

15017
15:12:14.546 --> 15:12:17.546
we're going to deploy a mock.
But we do want an entrance fee.

15018
15:12:17.546 --> 15:12:20.546
And let's just give it the exact
same entrance fee here. So we'll

15019
15:12:20.546 --> 15:12:24.546
say ethers dot utils dot parse
ether 0.01 E. Alright, great. So

15020
15:12:24.546 --> 15:12:31.546
on our deploy here, we can just
say const entrance fee equals

15021
15:12:31.546 --> 15:12:39.547
network config. Chain ID of
entrance fee. Let's start

15022
15:12:39.547 --> 15:12:42.547
populating our arcs here. So the
first one is going to be your Fe

15023
15:12:42.547 --> 15:12:44.547
two coordinator address. Next
one is going to be our entrance

15024
15:12:44.547 --> 15:12:49.547
fee. Got it? Got it. Now we need
our gas lane. On Rigby and other

15025
15:12:49.547 --> 15:12:52.547
networks, there are different
gas lanes that we can choose

15026
15:12:52.547 --> 15:12:56.547
from, let's grab the only gas
Lane from Rinckey, the 30, gray

15027
15:12:56.547 --> 15:13:00.547
key hash, let's drop this, of
course into our network config

15028
15:13:00.547 --> 15:13:03.547
as gasoline, pop it in here,
we're hard hat, our mock

15029
15:13:03.547 --> 15:13:05.547
actually doesn't care what gas
line we're working on, because

15030
15:13:05.547 --> 15:13:07.547
we're going to be mocking the
gasoline anyways. So we can just

15031
15:13:07.547 --> 15:13:10.547
say gas lane, we can just go
ahead and use the same one or

15032
15:13:10.547 --> 15:13:13.547
really anything here, it doesn't
really matter. Now here we'll

15033
15:13:13.547 --> 15:13:18.547
say const, gasoline equals
network config.

15034
15:13:18.547 --> 15:13:23.547
Chain ID, gasoline, and we'll
grab the gas lane. And we'll

15035
15:13:23.547 --> 15:13:26.547
stick it into our argument
array, we've got this one, we've

15036
15:13:26.547 --> 15:13:28.547
got this one, we've got this
one. Now it's time for the

15037
15:13:28.547 --> 15:13:32.547
subscription ID. Now if you
haven't run through docstoc

15038
15:13:32.547 --> 15:13:35.547
chain link for the chain link
VRF, I highly recommend you do

15039
15:13:35.547 --> 15:13:38.547
so so that you can understand
what this subscription ID is we

15040
15:13:38.547 --> 15:13:41.547
know that we can actually make a
subscription ID using that front

15041
15:13:41.547 --> 15:13:45.547
end using that website VRF dot
chain dot link, which is great

15042
15:13:45.547 --> 15:13:48.547
and all but what if we're on all
local chains, we can get a

15043
15:13:48.547 --> 15:13:52.547
subscription ID no problem in
here. But it's a little bit

15044
15:13:52.547 --> 15:13:55.547
harder on a local network. Now
I'm actually going to teach you

15045
15:13:55.547 --> 15:13:57.547
how to create and fund
subscription it is completely

15046
15:13:57.547 --> 15:14:00.547
programmatically. So you don't
even need to use the UI if you

15047
15:14:00.547 --> 15:14:03.547
don't want to. However, for the
purpose of this course, we're

15048
15:14:03.547 --> 15:14:05.547
still going to use the user
interface, we're still going to

15049
15:14:05.547 --> 15:14:08.547
use that website for us to get
our own subscription IDs. But

15050
15:14:08.547 --> 15:14:11.547
you could 100% automate the
process of creating a

15051
15:14:11.547 --> 15:14:14.548
subscription ID and funding a
subscription ID. Because when

15052
15:14:14.548 --> 15:14:17.548
you create and fund subscription
IDs, you're just calling create

15053
15:14:17.548 --> 15:14:20.548
subscription and fund
subscription on that smart

15054
15:14:20.548 --> 15:14:23.548
contract. So on our development
chain, we have our V RF

15055
15:14:23.548 --> 15:14:26.548
coordinator v2 Mock, and what
we're going to do and on our

15056
15:14:26.548 --> 15:14:29.548
development chain, we're going
to create that subscription. So

15057
15:14:29.548 --> 15:14:33.548
we're gonna say const,
transaction, response equals

15058
15:14:33.548 --> 15:14:42.548
await VRF coordinator v2 Mock
dot create sub scription. And

15059
15:14:42.548 --> 15:14:48.548
then we'll run const transaction
receipt equals weight trends

15060
15:14:48.548 --> 15:14:54.548
action response, dot Wait, wait
one block confirmation. And

15061
15:14:54.548 --> 15:14:57.548
inside this transaction receipt,
there's actually an event that's

15062
15:14:57.548 --> 15:15:00.548
emitted with our subscription
that we can get this is another

15063
15:15:00.548 --> 15:15:04.548
place where emitting events is
incredibly helpful. So in fact,

15064
15:15:04.548 --> 15:15:08.548
if we open back up a Vera v2
coordinator mark, and we look

15065
15:15:08.548 --> 15:15:13.548
for create subscription, we see
we emit subscription created

15066
15:15:13.548 --> 15:15:17.548
with the subscription ID, we can
actually get this event emitted

15067
15:15:17.548 --> 15:15:20.548
from our transaction receipt.
Now to assign it, let's go ahead

15068
15:15:20.548 --> 15:15:24.548
and create a sub subscription ID
up here. And then we'll say

15069
15:15:24.548 --> 15:15:31.548
subscription ID equals
transaction receipt that events

15070
15:15:31.548 --> 15:15:37.548
of zero dot args dot sub ID. And
again, be sure to watch that

15071
15:15:37.548 --> 15:15:39.548
events video if you want to
learn more about how to work

15072
15:15:39.548 --> 15:15:42.548
with events in hardware. Now
that we have a subscription, we

15073
15:15:42.548 --> 15:15:45.548
need to fund the subscription on
a real network, you'd need the

15074
15:15:45.548 --> 15:15:48.548
link token to actually fund the
subscription. The current

15075
15:15:48.548 --> 15:15:51.548
iteration of the mock allows you
to fund a subscription without

15076
15:15:51.548 --> 15:15:54.548
the link token. So what we can
do is we can just run a wait

15077
15:15:54.548 --> 15:16:02.549
your F corps inator Mark, if
coordinator B to Mach dot fund

15078
15:16:02.549 --> 15:16:07.549
subscription, and we'll give it
the subscription ID and we'll

15079
15:16:07.549 --> 15:16:09.549
need to do some fundamental
this, we can just create some

15080
15:16:09.549 --> 15:16:15.549
variable, we'll say const VRF,
subscription fund amount equals

15081
15:16:15.549 --> 15:16:22.549
ethers dot utils, dot parse
ether, of, we'll say 30 VRF

15082
15:16:22.549 --> 15:16:26.549
subscription, fundament. We'll
just paste that down here. We

15083
15:16:26.549 --> 15:16:29.549
could do this as well for a real
test net or live networks. But

15084
15:16:29.549 --> 15:16:32.549
just so that we become familiar
with the user interface, we're

15085
15:16:32.549 --> 15:16:35.549
not going to do a test net
programmatically. And for a test

15086
15:16:35.549 --> 15:16:37.549
net, we're just going to use
exactly what we've been doing so

15087
15:16:37.549 --> 15:16:40.549
far. Or we can put a
subscription ID and our helper

15088
15:16:40.549 --> 15:16:44.549
config. So we'll say
subscription ID, we'll put

15089
15:16:44.549 --> 15:16:47.549
something in here right now,
we'll just leave it as zero. But

15090
15:16:47.549 --> 15:16:50.549
later on, when we actually
create a subscription, we'll

15091
15:16:50.549 --> 15:16:55.549
update our subscription ID. And
so we'll say subscription ID

15092
15:16:55.549 --> 15:17:04.549
equals network config. Change ID
of subscription ID. Perfect. Now

15093
15:17:04.549 --> 15:17:09.549
we can add this to our arguments
array. What else do we need

15094
15:17:09.549 --> 15:17:12.549
subscription ID, we need a
callback gas limit or callback,

15095
15:17:12.549 --> 15:17:15.549
gas limit is going to vary
network to network. So once

15096
15:17:15.549 --> 15:17:18.549
again, we're gonna go into our
helper configure callback gas

15097
15:17:18.549 --> 15:17:23.549
limit. And for us, we'll set a
pretty high limit of 500,000

15098
15:17:23.549 --> 15:17:29.549
gas. So we'll say call a gas
limit of 5.123 500,000. Gas. And

15099
15:17:29.549 --> 15:17:32.549
for hard hat, we'll do the same
thing. So we can say const,

15100
15:17:32.549 --> 15:17:39.550
callback, gas limit equals
network config, chain ID,

15101
15:17:39.550 --> 15:17:44.550
callback, gas limit, grab this,
put it into our argument array.

15102
15:17:44.550 --> 15:17:47.550
What else do we need? All we
need now is the interval. So we

15103
15:17:47.550 --> 15:17:51.550
can change this network to
network as well. Rigby will say,

15104
15:17:51.550 --> 15:17:56.550
interval will ever just be 30
seconds for both hard hat and

15105
15:17:56.550 --> 15:17:59.550
for Rigby. So we'll do the same
thing here. Say const.

15106
15:17:59.550 --> 15:18:07.550
Interval equals network config.
Chain ID, interval, and we'll

15107
15:18:07.550 --> 15:18:12.550
grab this, pop it in the end of
our array. All right, awesome.

15108
15:18:12.550 --> 15:18:15.550
Now we have an argument array
and drop it right in here and

15109
15:18:15.550 --> 15:18:18.550
perfect. Everything in our
constructor for our raffle

15110
15:18:18.550 --> 15:18:21.550
contract. Great. This is looking
fantastic. We've got wait

15111
15:18:21.550 --> 15:18:25.550
confirmations we got logging
arguments Deployer. Okay, well,

15112
15:18:25.550 --> 15:18:29.550
what next? Well, let's go ahead
and add that verification piece.

15113
15:18:29.550 --> 15:18:34.550
So once again, create a new
folder utils, new file

15114
15:18:34.550 --> 15:18:38.550
verify.js. We can either copy
paste this from our last

15115
15:18:38.550 --> 15:18:41.550
project, or we can grab this
from the GitHub repo associated

15116
15:18:41.550 --> 15:18:43.550
with this course, once we have
our verify script in here, we're

15117
15:18:43.550 --> 15:18:51.550
going to import it by saying
const. Verify equals require dot

15118
15:18:51.550 --> 15:18:57.550
dot slash helper Hardhead
config. And then we can add that

15119
15:18:57.550 --> 15:19:00.550
same bit of code down here to
verify our contract, we'll say

15120
15:19:00.550 --> 15:19:11.550
if we're not on a development
chain. And we have process

15121
15:19:11.550 --> 15:19:16.551
studying v dot ether scan API
key, then we're going to log

15122
15:19:16.551 --> 15:19:22.551
verifying dot dot and then await
verify raffle dot address and

15123
15:19:22.551 --> 15:19:26.551
the arcs. Now we'll just do a
log of a whole bunch of hyphens

15124
15:19:26.551 --> 15:19:31.551
say that this script is done
module dot exports dot tags

15125
15:19:31.551 --> 15:19:36.551
equals say this will be all and
raffle. All right, so let's test

15126
15:19:36.551 --> 15:19:41.551
this out. We'll do hardhat
deploy, or yarn, hard hat deploy

15127
15:19:41.551 --> 15:19:45.551
and see if this script works
correctly. Looks like we ran

15128
15:19:45.551 --> 15:19:49.551
into an error network config not
defined. So let's spell this

15129
15:19:49.551 --> 15:19:52.551
right. Network config. There we
go. And that looks much better.

15130
15:19:52.551 --> 15:19:55.551
Let's try this again. It looks
like our deploy scripts are

15131
15:19:55.551 --> 15:19:58.551
working well. local networks
protected, deploying mocks

15132
15:19:58.551 --> 15:20:02.551
deployed VRF coordinator v2 Mock
mocks deployed and then we went

15133
15:20:02.551 --> 15:20:08.551
ahead and deployed our raffle.
Awesome, this is massive. Now

15134
15:20:08.551 --> 15:20:11.551
we're not going to test the
deploying this to a test net

15135
15:20:11.551 --> 15:20:14.551
quite yet, because well, we
don't have any unit tests yet.

15136
15:20:14.551 --> 15:20:17.551
We need to write unit tests
before we want to ever test

15137
15:20:17.551 --> 15:20:20.551
running this on a test net. So
we have our deploy script, we

15138
15:20:20.551 --> 15:20:23.551
have our contracts, that means
it's time for us to write some

15139
15:20:23.551 --> 15:20:26.551
tests. We'll come over here
we'll create a new folder called

15140
15:20:26.551 --> 15:20:29.551
test. And for now, we'll just
make our unit tests. So unit

15141
15:20:29.551 --> 15:20:35.551
tests, and in here we create a
new file called raffle.test.js.

15142
15:20:35.551 --> 15:20:38.551
And let's write some unit tests.
Now for these unit tests, we are

15143
15:20:38.551 --> 15:20:40.551
going to be a little bit verbose
here, we're going to make our

15144
15:20:40.551 --> 15:20:43.551
coverage really, really good
here. It's not gonna be perfect,

15145
15:20:43.551 --> 15:20:46.551
but this is going to be pretty
verbose. So I'm gonna go pretty

15146
15:20:46.551 --> 15:20:49.551
quickly here. So you can feel
free to pause, slow me down,

15147
15:20:49.551 --> 15:20:53.551
speed me up whatever you need to
learn this section. It is really

15148
15:20:53.551 --> 15:20:56.552
good muscle memory to go through
writing these tests and

15149
15:20:56.552 --> 15:20:58.552
understand what you should be
thinking about when you're

15150
15:20:58.552 --> 15:21:01.552
writing these tests. So feel
free to speed up the parts You

15151
15:21:01.552 --> 15:21:04.552
already know and slow down the
new parts. Because we are going

15152
15:21:04.552 --> 15:21:08.552
to go over some new information
here. writing tests may seem

15153
15:21:08.552 --> 15:21:11.552
like a tedious process. But I
promise as you get better at

15154
15:21:11.552 --> 15:21:13.552
writing these tests, you'll
realize that these are the

15155
15:21:13.552 --> 15:21:17.552
things that you can rely on when
stuff doesn't work. And when

15156
15:21:17.552 --> 15:21:19.552
you're not sure how to code,
something, getting this muscle

15157
15:21:19.552 --> 15:21:22.552
memory down, writing these tests
is going to make you a fantastic

15158
15:21:23.552 --> 15:21:25.552
engineer. So let's go through
and we'll write some of these

15159
15:21:25.552 --> 15:21:28.552
verbose tests here to try to
make this really good and have

15160
15:21:28.552 --> 15:21:30.552
this have really good coverage.
And if you want to go back later

15161
15:21:30.552 --> 15:21:33.552
on, and see if you can give it
even more coverage, and even

15162
15:21:33.552 --> 15:21:36.552
better tests, please feel free
to do so. But let's get started.

15163
15:21:36.552 --> 15:21:39.552
Let's write some tests. So we're
going to start out pretty much

15164
15:21:39.552 --> 15:21:41.552
the same way we've been starting
everything out, we're going to

15165
15:21:41.552 --> 15:21:44.552
grab our development chains, so
that we only run our unit tests

15166
15:21:44.552 --> 15:21:49.552
on a development chain. So we'll
do const development chains,

15167
15:21:49.552 --> 15:21:55.552
equals require dot dot slash dot
dot slash helper, RD, hard hat

15168
15:21:55.552 --> 15:22:00.552
config, and then we'll say not
development chains, that

15169
15:22:00.552 --> 15:22:07.552
includes network dot name, and
describe that skip. Otherwise,

15170
15:22:07.552 --> 15:22:10.552
we'll do describe, so this first
describe is going to be our

15171
15:22:10.552 --> 15:22:16.552
raffle unit tests. And this is
going to be an async. function.

15172
15:22:16.552 --> 15:22:19.552
So raffle unit tests so that it
comes on the next line, it looks

15173
15:22:19.552 --> 15:22:21.552
a little bit better. Alright,
great. Now, what are some of the

15174
15:22:21.552 --> 15:22:23.552
main things that we're going to
need to deploy? Well, we're

15175
15:22:23.552 --> 15:22:25.552
gonna need to deploy a raffle,
we're probably going to want a

15176
15:22:26.552 --> 15:22:31.552
VRF core to a tour be to mock
graded before each, that's going

15177
15:22:31.552 --> 15:22:35.553
to be an async function, where
we go ahead and we get these

15178
15:22:35.553 --> 15:22:41.553
will say const. Employer equals
await, get named accounts.

15179
15:22:41.553 --> 15:22:44.553
So we're gonna need to import
get named accounts or require

15180
15:22:44.553 --> 15:22:46.553
get name accounts from hard hat,
then we're going to want to

15181
15:22:47.553 --> 15:22:51.553
deploy these using our fixtures.
So we can say await deployments.

15182
15:22:51.553 --> 15:22:55.553
And then we're going to import
deployments as well from hardhat

15183
15:22:55.553 --> 15:23:00.553
dot fixture, and we're going to
call all, we're going to deploy

15184
15:23:00.553 --> 15:23:03.553
everything. And again, if we
look at our one, our raffle has

15185
15:23:03.553 --> 15:23:07.553
the alt tag, and our Oh, our
mocks also have the alt tag,

15186
15:23:07.553 --> 15:23:12.553
okay, perfect. Once we deploy
everything, we can say raffle

15187
15:23:12.553 --> 15:23:17.553
equals await ethers dot get to
contract. And we got to import

15188
15:23:17.553 --> 15:23:21.553
ethers from hard hat, like so.
And we'll say it will get the

15189
15:23:21.553 --> 15:23:27.553
raffle contract and we'll
connect it to our Deployer. And

15190
15:23:27.553 --> 15:23:30.553
then we're going to do the same
thing with VRF coordinator v2

15191
15:23:30.553 --> 15:23:37.553
Mock equals await ethers dot get
contract, the RF coordinator, B

15192
15:23:37.553 --> 15:23:41.553
to MK connect this to deployer
as well. Alright, great, our

15193
15:23:41.553 --> 15:23:44.553
first set of tests describe,
they're going to be the

15194
15:23:44.553 --> 15:23:50.553
constructor. And this is going
to be an async function. And

15195
15:23:50.553 --> 15:23:55.553
let's do this. Let's create an
IT initial initializes the

15196
15:23:55.553 --> 15:24:02.553
raffle correctly, this is going
to be an async function. Now I

15197
15:24:02.553 --> 15:24:06.553
just want to make a note,
because ideally, we make our

15198
15:24:06.553 --> 15:24:12.553
tests have just one assert, or
it just keep that in mind is

15199
15:24:12.553 --> 15:24:14.553
that ideally, we want to have
just one assert for it. But

15200
15:24:14.553 --> 15:24:17.554
we're going to have a bunch
because like I said, we're being

15201
15:24:17.554 --> 15:24:19.554
a little bit loose here. So we
want to just make sure that our

15202
15:24:19.554 --> 15:24:24.554
raffle is initialized correctly.
So we'll say const raffle state,

15203
15:24:24.554 --> 15:24:28.554
and we'll get that raffle state
because we want to make sure

15204
15:24:28.554 --> 15:24:31.554
that we start in an open raffle
state. So we'll say const,

15205
15:24:31.554 --> 15:24:39.554
raffle state equals await raffle
dot get raffle state. And then

15206
15:24:39.554 --> 15:24:43.554
we want to say assert dot equal
ope and then we need to import

15207
15:24:43.554 --> 15:24:47.554
assert from Chai. So assert
equals require Chai assert dot

15208
15:24:47.554 --> 15:24:53.554
equal raffle state.to string
because again, raffle state is

15209
15:24:53.554 --> 15:24:57.554
going to be a big number. And
even though a raffle state is of

15210
15:24:57.554 --> 15:25:01.554
type raffle state, it'll return
a zero if it's open and a one if

15211
15:25:01.554 --> 15:25:06.554
it's calculating. So this gets
transformed just into a un 256.

15212
15:25:06.554 --> 15:25:09.554
When we call it like this, a
raffle state variable here will

15213
15:25:09.554 --> 15:25:13.554
be a big number. So we want to
just to string a file. So assert

15214
15:25:13.554 --> 15:25:16.554
dot equal raffle state DOT two
string zero. We'll also make

15215
15:25:16.554 --> 15:25:20.554
sure our interval gets set
correctly. So we'll do const

15216
15:25:20.554 --> 15:25:28.554
interval equals await raffle dot
get interval. And I don't know

15217
15:25:28.554 --> 15:25:32.554
if we have one of those it's
actually C inter ball see if we

15218
15:25:32.554 --> 15:25:35.554
have one of those. We don't have
a good interval let's go ahead

15219
15:25:35.554 --> 15:25:40.554
and add again interval function
so we'll do function get in

15220
15:25:40.554 --> 15:25:48.554
trouble. We have public view
returns you went to six return I

15221
15:25:48.554 --> 15:25:53.554
underscore interval will have
good interval will say raffle

15222
15:25:53.554 --> 15:25:58.555
dot get interval and will also
say assert dot equal interval.to

15223
15:25:58.555 --> 15:26:04.555
string. It should equal one Ever
is in our helper config, right?

15224
15:26:04.555 --> 15:26:06.555
Because we're using the interval
and helper config. So we say

15225
15:26:06.555 --> 15:26:11.555
interval.to string should equal.
So we'll import that as well.

15226
15:26:11.555 --> 15:26:16.555
Network config. And we'll say
the interval should equal

15227
15:26:16.555 --> 15:26:22.555
network config. Of let's also
make, get our chain ID up here,

15228
15:26:22.555 --> 15:26:29.555
chain ID, say const. Chain ID
equals network dot config, a

15229
15:26:29.555 --> 15:26:35.555
chain ID, network config of the
chain ID of interval. Alright,

15230
15:26:35.555 --> 15:26:41.555
cool. So let's test this so far,
HH test or yarn, hard hat test.

15231
15:26:41.555 --> 15:26:44.555
And cool looks like it passed.
And we have our little gas

15232
15:26:44.555 --> 15:26:47.555
output here. Awesome. Let's go
to our Hardhead config, just so

15233
15:26:47.555 --> 15:26:50.555
that it doesn't always print out
at gas, but there for now. So

15234
15:26:50.555 --> 15:26:54.555
I'm going to copy paste the gas
reporter section from our last

15235
15:26:54.555 --> 15:26:57.555
project, like so. And we're
going to have enabled gas be

15236
15:26:57.555 --> 15:27:00.555
false for now. So now if we run
a Hardhead test, again, we

15237
15:27:00.555 --> 15:27:02.555
shouldn't have that gas bid
printed out, we should just see

15238
15:27:02.555 --> 15:27:05.555
the tests and perfect, that's
what we see. And our constructor

15239
15:27:05.555 --> 15:27:09.555
test passes. Yay, what's next,
got our constructor. And we

15240
15:27:09.555 --> 15:27:11.555
probably could have written more
tests for the rest of these. But

15241
15:27:11.555 --> 15:27:14.555
let's just move on. Alright,
enter raffle, that's going to be

15242
15:27:14.555 --> 15:27:19.555
our next describe block. So it
will do describe,

15243
15:27:19.555 --> 15:27:24.555
enter, raffle. And this is going
to be an async function. And

15244
15:27:24.555 --> 15:27:30.555
we'll say it reverts when you
don't pay enough, right, because

15245
15:27:30.555 --> 15:27:32.555
one of the first things that we
check is that they're paying

15246
15:27:32.555 --> 15:27:36.556
enough. So we want to make sure
that this actually reverts if

15247
15:27:36.556 --> 15:27:40.556
they don't pay enough. So this
will be an async function. Where

15248
15:27:40.556 --> 15:27:44.556
we're going to do that same
expect await thing. So we're

15249
15:27:44.556 --> 15:27:48.556
going to import expect from
Chai, which comes from those

15250
15:27:48.556 --> 15:27:55.556
waffle matchers. And we're gonna
say await, expect raffle dot

15251
15:27:55.556 --> 15:27:59.556
enter a raffle. And we're not
going to pass any value here,

15252
15:27:59.556 --> 15:28:06.556
we're going to expect it to dot
b dot reverted with. And if we

15253
15:28:06.556 --> 15:28:09.556
look here, we want it to be
reverted with this raffle not

15254
15:28:09.556 --> 15:28:13.556
enough eath entered. So we can
put that in quotes raffle not

15255
15:28:14.556 --> 15:28:17.556
enough eath entered. Now we can
try this out. Make sure that it

15256
15:28:17.556 --> 15:28:22.556
actually works. Ah ah test dash
dash grep. Put this in quotes

15257
15:28:22.556 --> 15:28:26.556
that you don't pay enough. And
awesome. We're passing there.

15258
15:28:26.556 --> 15:28:29.556
What else do we want to test?
Well, we want to test that if

15259
15:28:29.556 --> 15:28:31.556
the raffle isn't open, we also
revert but we'll test that in a

15260
15:28:31.556 --> 15:28:34.556
little bit. As we kind of test
the rest of the functionality.

15261
15:28:34.556 --> 15:28:40.556
We want to see that it records
players when they enter. So this

15262
15:28:40.556 --> 15:28:44.556
will be an async function. And
now we'll enter the raffle.

15263
15:28:44.556 --> 15:28:47.556
First we're going to need that
raffle entrance fee. Let's go

15264
15:28:47.556 --> 15:28:50.556
ahead and save that at the top.
So we'll say let raffle VRF

15265
15:28:50.556 --> 15:28:54.556
coordinator be to mock raffle
entrance fee and then our before

15266
15:28:54.556 --> 15:28:59.556
each will say raffle entrance
fee equals a weight ethers dot

15267
15:28:59.556 --> 15:29:05.556
get entrance fee. This should be
raffle dot get entrance fee. So

15268
15:29:05.556 --> 15:29:08.556
now we have this raffle entrance
fee, you can use it to enter the

15269
15:29:08.556 --> 15:29:15.557
raffle we'll say a weight raffle
dot enter raffle with a value of

15270
15:29:15.557 --> 15:29:20.557
raffle entrance fee. And we can
make sure that our Deployer here

15271
15:29:20.557 --> 15:29:23.557
has been correctly recorded. So
since right now we're connected

15272
15:29:23.557 --> 15:29:26.557
to the Deployer. We'll just make
sure that that deployer actually

15273
15:29:26.557 --> 15:29:32.557
is in our contract. So we'll say
const player from contract

15274
15:29:32.557 --> 15:29:38.557
equals await raffle dot get
player of zero, because we

15275
15:29:38.557 --> 15:29:42.557
record them in our players array
and we have our get players

15276
15:29:42.557 --> 15:29:46.557
function which pulls them out.
And then we'll say assert dot

15277
15:29:46.557 --> 15:29:51.557
equal player, player from
contract should be the Deployer.

15278
15:29:51.557 --> 15:29:54.557
So now we can grep for this in
our hard head test. Make sure

15279
15:29:54.557 --> 15:30:00.557
this works. HH test dash dash
grep. Deployer is not defined.

15280
15:30:00.557 --> 15:30:02.557
We've got it up here. But we
actually didn't save it

15281
15:30:02.557 --> 15:30:07.557
globally. So we got to do let
common Deployer. And we'll say

15282
15:30:07.557 --> 15:30:11.557
deployer equals await get named
accounts. And we'll wrap it like

15283
15:30:11.557 --> 15:30:16.557
this to get the deployer
Awesome. Let's try this again.

15284
15:30:16.557 --> 15:30:22.557
And awesome. What else should
this do? Well, it's also

15285
15:30:22.557 --> 15:30:25.557
emitting an event. So let's make
sure it emits an event. So we'll

15286
15:30:25.557 --> 15:30:31.557
say it emits event on enter.
This will be an async function

15287
15:30:31.557 --> 15:30:34.557
as well. And this will be the
first time that we're testing to

15288
15:30:34.557 --> 15:30:38.557
make sure a function emits an
event and the syntax is going to

15289
15:30:38.557 --> 15:30:41.557
look really similar to what we
test for when we check to see if

15290
15:30:41.557 --> 15:30:47.557
an error is fired. So we're
gonna say await expect raffle

15291
15:30:47.557 --> 15:30:57.558
dot enter raffle with value of
raffle entrance fee dot two dot

15292
15:30:57.558 --> 15:31:03.558
omit and this.to dot emit we get
from During woful, these chime

15293
15:31:03.558 --> 15:31:07.558
matches for emitting events we
can do a wait expect to emit,

15294
15:31:07.558 --> 15:31:09.558
and then the event that we're
expecting to emit. So we're

15295
15:31:09.558 --> 15:31:15.558
saying to omit the raffle
contract to emit a raffle enter

15296
15:31:15.558 --> 15:31:19.558
event. We can copy this, try to
test this in our terminal. So

15297
15:31:19.558 --> 15:31:24.558
we'll say hard hat. Test dash
dash grep. Just put this in

15298
15:31:24.558 --> 15:31:32.558
quotes. And that passes as well.
Great. Let's now go ahead and

15299
15:31:32.558 --> 15:31:35.558
test to make sure that we can't
enter the raffle whenever this

15300
15:31:35.558 --> 15:31:39.558
raffle is not open or it's
calculating. So we'll say it

15301
15:31:39.558 --> 15:31:46.558
doesn't allow entrance, when
raffle is Cal cumulating. And

15302
15:31:46.558 --> 15:31:51.558
this will be an async function.
And first we'll enter will say

15303
15:31:51.558 --> 15:31:56.558
await raffle dot enter raffle

15304
15:31:56.558 --> 15:32:03.558
value is raffle entrance fee.
Now what we want to do we want

15305
15:32:03.558 --> 15:32:07.558
to get this raffle into a closed
state. So we want to get it out

15306
15:32:07.558 --> 15:32:10.558
of its open state. Well, how do
we move this raffle from raffle

15307
15:32:10.558 --> 15:32:14.558
dot open to raffle dot closed in
perform upkeep, remove the

15308
15:32:14.558 --> 15:32:18.558
raffle from raffle that open to
raffle dot calculating but

15309
15:32:18.558 --> 15:32:22.558
perform upkeep can only be
called if check upkeep returns

15310
15:32:22.558 --> 15:32:26.558
true. Otherwise, it'll revert
with raffle upkeep not needed.

15311
15:32:26.558 --> 15:32:29.558
So what we need to do is we need
to make check upkeep return

15312
15:32:29.558 --> 15:32:33.558
true. And we will pretend to be
the channeling keeper network to

15313
15:32:33.558 --> 15:32:36.559
keep calling checkup keep
waiting for it to be true. And

15314
15:32:36.559 --> 15:32:38.559
once we make it true, then we'll
pretend to be the channeling

15315
15:32:38.559 --> 15:32:42.559
keepers and call perform upkeep
to put this contract in a state

15316
15:32:42.559 --> 15:32:48.559
of calculating. Now how do we
actually do that? Well, in order

15317
15:32:48.559 --> 15:32:51.559
for checkup keep to be true, we
first need to see that we are

15318
15:32:51.559 --> 15:32:54.559
indeed open, which we are. The
next thing that we need to do

15319
15:32:54.559 --> 15:32:57.559
though, is we need to do this
time passed bit. We need to

15320
15:32:57.559 --> 15:33:02.559
actually wait that 30 seconds
for time to pass. Now, that kind

15321
15:33:02.559 --> 15:33:05.559
of sounds awful. Do we have to
wait 30 seconds for all of our

15322
15:33:05.559 --> 15:33:09.559
tests? What if our interval was
10 days when we have to wait 10

15323
15:33:09.559 --> 15:33:13.559
days to run our tests? It sounds
ridiculous. Well, hard hat

15324
15:33:13.559 --> 15:33:17.559
actually comes built in with a
ton of functions for us to

15325
15:33:17.559 --> 15:33:20.559
manipulate our blockchain to do
literally whatever we want it to

15326
15:33:20.559 --> 15:33:23.559
do. In the hard hat
documentation. There's a section

15327
15:33:23.559 --> 15:33:26.559
called Hard Hat Network
reference inside the Hard Hat

15328
15:33:26.559 --> 15:33:29.559
Network section. And in here,
there's a ton of information

15329
15:33:29.559 --> 15:33:32.559
about how the hard hat network
actually works and different

15330
15:33:32.559 --> 15:33:35.559
configs that we can do with it.
If we scroll down low enough, we

15331
15:33:35.559 --> 15:33:38.559
can see the JSON RPC methods
that we can use on this

15332
15:33:38.559 --> 15:33:41.559
blockchain, we can do eath
accounts block number call

15333
15:33:41.559 --> 15:33:44.559
chinetti. We can do all these
RPC methods that a normal

15334
15:33:44.559 --> 15:33:47.559
blockchain has. Additionally, we
can do even more than that, we

15335
15:33:47.559 --> 15:33:51.559
can use these things called Hard
Hat Network methods. Since this

15336
15:33:51.559 --> 15:33:53.559
is our local Hard Hat Network.
And we're using this for

15337
15:33:53.559 --> 15:33:57.559
testing, we want to be able to
test any scenario. And it's

15338
15:33:57.559 --> 15:34:00.559
these methods that give us the
ability to do that, you can go

15339
15:34:00.559 --> 15:34:02.559
through this and play around and
see all the different things you

15340
15:34:02.559 --> 15:34:05.559
can do. One of them in
particular is going to be set

15341
15:34:05.559 --> 15:34:07.559
storage set where you can set
storage at any place, which is

15342
15:34:07.559 --> 15:34:10.559
really fun. But some of the
special testing debugging

15343
15:34:10.559 --> 15:34:14.559
methods are going to be EVM
increase time, and EVM. Mine

15344
15:34:14.559 --> 15:34:18.560
increased time allows us to
automatically increase the time

15345
15:34:18.560 --> 15:34:22.560
of our blockchain and EVM. Mine
allows us to mine or create new

15346
15:34:22.560 --> 15:34:26.560
blocks, because if we increase
the time, it doesn't do anything

15347
15:34:26.560 --> 15:34:29.560
unless there's a new block
mined. So what we can do is we

15348
15:34:29.560 --> 15:34:34.560
can run a wait network, and
we'll import network from Hard

15349
15:34:34.560 --> 15:34:46.560
Hat Network await network dot
provider that send EVM in crease

15350
15:34:46.560 --> 15:34:49.560
time, comma, we can send a list
of parameters to send with it,

15351
15:34:49.560 --> 15:34:54.560
which for us are just going to
be our interval.to number. And

15352
15:34:54.560 --> 15:34:57.560
then we'll do plus one. Now
right now, our interval isn't

15353
15:34:57.560 --> 15:34:59.560
stored globally, so we're
probably going to want to do

15354
15:34:59.560 --> 15:35:03.560
that. So let's go ahead and do
interval. And then in our before

15355
15:35:03.560 --> 15:35:09.560
each, we'll do interval equals
await, raffle dot raffle dot get

15356
15:35:09.560 --> 15:35:11.560
interval, I'm just going to copy
this and we're going to delete

15357
15:35:11.560 --> 15:35:15.560
this whole line. Wait raffle dot
get interval. Since now we're

15358
15:35:15.560 --> 15:35:18.560
just going to call it interval
at a global level, since we're

15359
15:35:18.560 --> 15:35:20.560
going to use it a lot. Now we're
gonna say interval that to

15360
15:35:20.560 --> 15:35:24.560
number plus one. So we want to
increase the time by whatever

15361
15:35:24.560 --> 15:35:27.560
our interval is to make sure
that we can actually get that

15362
15:35:27.560 --> 15:35:30.560
checkup keep to return true. So
additionally, we're going to

15363
15:35:30.560 --> 15:35:39.560
want to do a weight network dot
provider. Dot send EVM mine with

15364
15:35:39.560 --> 15:35:42.560
an empty array just because we
just want to mine it one extra

15365
15:35:42.560 --> 15:35:46.560
block. You can also do network
dot provider that request with

15366
15:35:46.560 --> 15:35:49.560
an await here, these two would
be basically the same, but this

15367
15:35:49.560 --> 15:35:51.560
one's a little quicker, right?
So we've increased the time of

15368
15:35:51.560 --> 15:35:55.560
our blockchain. We've mined a
block to move forward. It should

15369
15:35:55.560 --> 15:35:58.561
be open time has passed. Do we
have a player? We do indeed,

15370
15:35:58.561 --> 15:36:01.561
because we've entered the
raffle. We should have a balance

15371
15:36:01.561 --> 15:36:03.561
because we've entered the right
Apple, check upkeep should now

15372
15:36:03.561 --> 15:36:07.561
return true. So we should be
able to call perform upkeep and

15373
15:36:07.561 --> 15:36:09.561
pretend to be a chain lock
keeper. So we're going to

15374
15:36:09.561 --> 15:36:13.561
pretend to be a chain the keeper
and call await raffle dot

15375
15:36:13.561 --> 15:36:18.561
perform upkeep. And we're going
to pass this some empty call

15376
15:36:18.561 --> 15:36:22.561
data just by passing a blank
array like that. And now this

15377
15:36:22.561 --> 15:36:26.561
should be in a calculating
state. So now that it's in a

15378
15:36:26.561 --> 15:36:30.561
calculating state, we can say
our enter raffle reverts

15379
15:36:30.561 --> 15:36:34.561
correctly if the raffle isn't
open. So now we'll say await,

15380
15:36:34.561 --> 15:36:41.561
expect raffle dot enter, raffle.
And we'll send it value of

15381
15:36:41.561 --> 15:36:47.561
raffle entrance fee. We're
expecting this.to dot b dot

15382
15:36:47.561 --> 15:36:55.561
reverted with that raffle
underscore underscore not open

15383
15:36:55.561 --> 15:37:02.561
error. Okay, let's try just this
in our tests now. So we'll run

15384
15:37:02.561 --> 15:37:07.561
Hardhead test dash dash grep.
Put this in quotes. And perfect

15385
15:37:07.561 --> 15:37:11.561
that passes as well.

15386
15:37:11.561 --> 15:37:13.561
Now if we run Hardhead test,
let's just test everything

15387
15:37:13.561 --> 15:37:17.561
together right now. And
everything is passing. Oh, this

15388
15:37:17.561 --> 15:37:20.561
is wonderful. Awesome. Let's
keep it going. And if we run

15389
15:37:20.561 --> 15:37:24.561
Hardhead coverage, we'll see our
coverage is bumping up, we are

15390
15:37:24.561 --> 15:37:27.561
already drastically better than
where we were before. Let's keep

15391
15:37:27.561 --> 15:37:31.561
going well, let's go ahead and
test our check upkeep now. So

15392
15:37:31.561 --> 15:37:34.561
we'll do describe, check upkeep.
And this will be an async

15393
15:37:34.561 --> 15:37:36.561
function,

15394
15:37:36.561 --> 15:37:45.562
where we'll say it returns
false. If people have been sent

15395
15:37:45.562 --> 15:37:49.562
an E, E, it's been a sync
function.

15396
15:37:49.562 --> 15:37:53.562
So we'll have everything in here
be true except for the fact that

15397
15:37:53.562 --> 15:37:57.562
nobody's entered yet. So we'll
do a weight network dot provider

15398
15:37:57.562 --> 15:38:09.562
dot send EVM increase time,
comma interval.to number plus

15399
15:38:09.562 --> 15:38:11.562
one

15400
15:38:11.562 --> 15:38:20.562
will do a weight network dot
provider. That send UVM mine. No

15401
15:38:20.562 --> 15:38:27.562
parameters. Now we're going to
call check upkeep. Now here's

15402
15:38:27.562 --> 15:38:31.562
the thing, check. upkeep is a
public function.

15403
15:38:31.562 --> 15:38:36.562
So if we just run await, raffle
dot check upkeep, and we pass

15404
15:38:36.562 --> 15:38:40.562
nothing in this is going to kick
off a transaction, because hard

15405
15:38:40.562 --> 15:38:43.562
had knows Oh, okay, it's a
public function, they're clearly

15406
15:38:43.562 --> 15:38:46.562
trying to send a transaction
here. If this was a public view

15407
15:38:46.562 --> 15:38:49.562
function, it wouldn't, it would
return that view. But the thing

15408
15:38:49.562 --> 15:38:52.562
is, I don't really want to send
a transaction. But I want to

15409
15:38:52.562 --> 15:38:56.562
simulate sending this
transaction and seeing what this

15410
15:38:56.562 --> 15:38:59.562
upkeep needed would return.
Well, I can actually get that by

15411
15:38:59.562 --> 15:39:03.562
using something called call
static, I can simulate calling

15412
15:39:03.562 --> 15:39:06.562
this transaction and seeing what
it will respond. So instead of

15413
15:39:06.562 --> 15:39:11.562
raffle dot, check upkeep, I can
do raffle dot cost static, that

15414
15:39:11.562 --> 15:39:16.563
check upkeep. And this will give
me the return of upkeep needed

15415
15:39:16.563 --> 15:39:19.563
and the bytes perform data, I
can extrapolate just the upkeep

15416
15:39:19.563 --> 15:39:26.563
needed out of this return or
writing const upkeep needed

15417
15:39:26.563 --> 15:39:34.563
equals this, and then I can do
assert not upkeep needed,

15418
15:39:34.563 --> 15:39:38.563
because right now upkeep needed
to return false. So we'll say

15419
15:39:38.563 --> 15:39:42.563
assert, not false, which is
true. If upkeep needed was true,

15420
15:39:42.563 --> 15:39:44.563
then this would be false. And
this would break. So that's what

15421
15:39:44.563 --> 15:39:48.563
we want to do. So let's go
ahead, we'll run this, see if it

15422
15:39:48.563 --> 15:39:54.563
worked. Our hat test, dash dash
grep. And we're in passing, we

15423
15:39:54.563 --> 15:40:00.563
are in business. Awesome. So
this is working perfectly. Well,

15424
15:40:00.563 --> 15:40:07.563
and let's also test that it
returns false. If raffle isn't

15425
15:40:07.563 --> 15:40:12.563
open. This will be an async
function. And we'll do

15426
15:40:12.563 --> 15:40:15.563
everything except and we'll do
everything in here. But we'll

15427
15:40:15.563 --> 15:40:19.563
make the raffle in the
calculating state. So do a

15428
15:40:19.563 --> 15:40:29.563
weight, raffle dot enter, raffle
value, raffle entrance fee await

15429
15:40:29.563 --> 15:40:33.563
network dot provider that send
and I'm just going to copy these

15430
15:40:33.563 --> 15:40:36.563
two lines here. Because we're
going to go ahead and do those.

15431
15:40:36.563 --> 15:40:42.563
We're also going to do a weight,
raffle dot perform upkeep. And

15432
15:40:42.563 --> 15:40:45.563
another way to send a blank
bytes object is to do a string

15433
15:40:45.563 --> 15:40:49.563
like 0x hardhat is smart enough
to know that this should be

15434
15:40:49.563 --> 15:40:53.563
transformed into just kind of a
blank bytes object. So either

15435
15:40:53.563 --> 15:40:56.564
one of these should work. Now
we're do const, raffle state

15436
15:40:56.564 --> 15:41:01.564
equals await, raffle dot get
raffle state and we'll Get

15437
15:41:01.564 --> 15:41:05.564
upkeep needed. So we'll say
const. upkeep needed, we'll do

15438
15:41:05.564 --> 15:41:11.564
exactly what we did above raffle
dot call static dot check

15439
15:41:11.564 --> 15:41:16.564
upkeep. Let's say excuse me a
weight, raffle dot call static.

15440
15:41:16.564 --> 15:41:22.564
Now we can do assert dot equal,
say raffle state is going to be,

15441
15:41:22.564 --> 15:41:25.564
or excuse me raffle state.to
string, it's going to be

15442
15:41:25.564 --> 15:41:30.564
calculating, and I started dot
equal upkeep needed, it's going

15443
15:41:30.564 --> 15:41:38.564
to be false. Let's run a GREP on
that. And perfect. That's also

15444
15:41:38.564 --> 15:41:41.564
working correctly. Great. Now
I'm going to skip over these

15445
15:41:41.564 --> 15:41:44.564
next two tests, because we
haven't really learned anything

15446
15:41:44.564 --> 15:41:47.564
from them. So I'm just going to
copy paste them from the GitHub,

15447
15:41:47.564 --> 15:41:50.564
we're going to return false if
enough time hasn't passed. And

15448
15:41:50.564 --> 15:41:54.564
we're going to return true. If
enough time has passed, we have

15449
15:41:54.564 --> 15:41:58.564
players Eve and is open. So
we're just asserting true down

15450
15:41:58.564 --> 15:42:00.564
here. And we're starting not
true up here, you want to pause

15451
15:42:00.564 --> 15:42:03.564
the video and copy paste these
and write these out, you

15452
15:42:03.564 --> 15:42:05.564
absolutely can copy paste them
from the GitHub repo, you

15453
15:42:05.564 --> 15:42:09.564
absolutely can't like I said,
going through this and making

15454
15:42:09.564 --> 15:42:11.564
yourself write these and making
yourself understand these tests

15455
15:42:11.564 --> 15:42:14.564
is going to make you a
substantially better coder. And

15456
15:42:14.564 --> 15:42:18.564
let's just test that it all
looks good with hh test. Now, as

15457
15:42:18.564 --> 15:42:21.564
I was recording this, I just
realized that for all of our

15458
15:42:21.564 --> 15:42:24.564
describe blocks, I've been
making them async functions

15459
15:42:24.564 --> 15:42:28.564
describe blocks actually don't
realize and can't recognize and

15460
15:42:28.564 --> 15:42:31.564
can't work with promises. So
having the be async actually

15461
15:42:31.564 --> 15:42:34.564
doesn't do anything. So in your
describe block, we want to get

15462
15:42:34.564 --> 15:42:37.565
rid of the async word because
it's actually not helping us at

15463
15:42:37.565 --> 15:42:40.565
all. In fact, it's just an extra
word, and it looks kind of

15464
15:42:40.565 --> 15:42:43.565
gross. So now all of our
describe blocks, we're gonna get

15465
15:42:43.565 --> 15:42:46.565
rid of that async keyword, and
just have them be functions. Of

15466
15:42:46.565 --> 15:42:49.565
course, all of our it's, though,
are going to be using

15467
15:42:49.565 --> 15:42:52.565
asynchronous functions, which is
what we want. So we've written

15468
15:42:52.565 --> 15:42:56.565
some tests for a checkup keep.
Now let's go ahead to perform

15469
15:42:56.565 --> 15:42:56.565
upkeep.

15470
15:42:56.565 --> 15:43:01.565
Let's create a new describe,
block, ascribe or perform

15471
15:43:01.565 --> 15:43:05.565
upkeep. This is going to be a
regular function. And in here,

15472
15:43:05.565 --> 15:43:10.565
we're going to start and say it
can only run if check upkeep is

15473
15:43:10.565 --> 15:43:14.565
true. And this will be an async
function. Because we only want

15474
15:43:14.565 --> 15:43:18.565
to perform keep to work if
checkup keep is indeed true. So

15475
15:43:18.565 --> 15:43:22.565
we'll say await raffle dot
enter. raffle we'll send it some

15476
15:43:22.565 --> 15:43:27.565
value, raffle entrance fee, I'm
sorry, there should be curly

15477
15:43:27.565 --> 15:43:32.565
braces instead. And we'll do a
weight network dot provider that

15478
15:43:32.565 --> 15:43:43.565
send EVM increase time inter
vol.to number plus one await

15479
15:43:43.565 --> 15:43:51.565
network dot provider that send
UVM mine an empty array there to

15480
15:43:51.565 --> 15:43:53.565
the reason that we're moving
time forward and moving our

15481
15:43:53.565 --> 15:43:55.565
block forward, of course is
gonna be the same thing as

15482
15:43:55.565 --> 15:43:58.565
above, we want our check upkeep
to return true. And then we're

15483
15:43:58.565 --> 15:44:04.565
gonna say const X or transaction
equals await raffel dot perform

15484
15:44:04.565 --> 15:44:11.565
upkeep. We can either do a blank
array, or we could do 0x Doesn't

15485
15:44:11.565 --> 15:44:15.565
matter. And we can assert the X.
Now if TX doesn't work, or this

15486
15:44:15.565 --> 15:44:19.566
error is out or something, this
will fail. Right. So that's how

15487
15:44:19.566 --> 15:44:22.566
we know that this actually can
work. So let's test this out. We

15488
15:44:22.566 --> 15:44:26.566
want this only to work if
checkup keep is true. And we

15489
15:44:26.566 --> 15:44:30.566
made checkup keep true by all
the stuff that we did above. So

15490
15:44:30.566 --> 15:44:35.566
now we'll do yarn hardhat test
dash dash grep with our IT block

15491
15:44:35.566 --> 15:44:40.566
here. And I spelled perform
upkeep wrong perform upkeep.

15492
15:44:40.566 --> 15:44:43.566
Let's try spelling things
correctly. And let's run that

15493
15:44:43.566 --> 15:44:47.566
test again. And great. That's
working. I will What else do we

15494
15:44:47.566 --> 15:44:52.566
want to do? We want it to revert
with raffel. upkeep not needed

15495
15:44:52.566 --> 15:44:57.566
if checkup keep is false. So in
here we're gonna say it reverts.

15496
15:44:57.566 --> 15:45:03.566
When check up keep is false.
This will be an async function.

15497
15:45:03.566 --> 15:45:08.566
And we're going to do that same
syntax await expect raffle dot

15498
15:45:08.566 --> 15:45:16.566
perform upkeep empty bytes
object that to.be reverted with.

15499
15:45:16.566 --> 15:45:18.566
And what do we want it to be
reverted with? Or hoping it's

15500
15:45:18.566 --> 15:45:24.566
reverted with this with that, we
can run this test here Hardhead

15501
15:45:24.566 --> 15:45:29.566
test dash dash grep paste that
in. And we see that is indeed

15502
15:45:29.566 --> 15:45:31.566
passing now something that
you'll notice here is that our

15503
15:45:32.566 --> 15:45:35.566
revert actually goes ahead and
reverts with all this extra

15504
15:45:35.566 --> 15:45:38.566
stuff as well. Our test is smart
enough to know that if all we do

15505
15:45:38.566 --> 15:45:42.566
is put the name of the error
that is getting reverted with

15506
15:45:42.566 --> 15:45:45.566
then it's good enough. If we
want to be super specific, we

15507
15:45:45.566 --> 15:45:49.566
can actually go ahead and make
this a string interpolation and

15508
15:45:49.566 --> 15:45:53.566
add all of these in here. So we
can add the balance that we

15509
15:45:53.566 --> 15:45:56.566
expect we can add the players
that we expect. And we can add

15510
15:45:56.566 --> 15:45:59.567
the raffle statement for now
we're just going to keep it as

15511
15:45:59.567 --> 15:46:02.567
we're expecting this but if you
want to be super specific you

15512
15:46:02.567 --> 15:46:06.567
can have your tests expect for
exactly the specific values that

15513
15:46:06.567 --> 15:46:09.567
you're looking for. But alright,
what is the last thing we should

15514
15:46:09.567 --> 15:46:12.567
expect form? Well, we should
check to see that this actually

15515
15:46:12.567 --> 15:46:16.567
gets called the raffle state
gets changed. And we admit this

15516
15:46:16.567 --> 15:46:21.567
event. So let's go ahead and add
that. We'll say it updates the

15517
15:46:21.567 --> 15:46:30.567
raffle state admits an event and
calls the VRF coordinator to be

15518
15:46:30.567 --> 15:46:34.567
an async function as well. Let's
do this. So let's go ahead and

15519
15:46:34.567 --> 15:46:37.567
let's make checkup keep true,
I'm just going to copy paste

15520
15:46:37.567 --> 15:46:40.567
these first three lines, since
it's going to be exactly the

15521
15:46:40.567 --> 15:46:42.567
same. We're going to enter the
raffle we're going to increase

15522
15:46:42.567 --> 15:46:44.567
the time we're going to mind a
new block, then we're going to

15523
15:46:44.567 --> 15:46:49.567
call perform upkeep. So we're
going to say const, TX response

15524
15:46:49.567 --> 15:46:55.567
equals await raffle dot perform
upkeep with an empty bytes

15525
15:46:55.567 --> 15:47:02.567
object, and we're going to do
const TX receipt equals await TX

15526
15:47:02.567 --> 15:47:07.567
response dot wait for one block.
From this receipt, we're gonna

15527
15:47:07.567 --> 15:47:12.567
get the request ID, we're gonna
say const Request ID equals, we

15528
15:47:12.567 --> 15:47:17.567
can get the request ID. From
this omitted event. However, we

15529
15:47:17.567 --> 15:47:21.567
should look at our VRF
coordinator mock again, when we

15530
15:47:21.567 --> 15:47:25.567
call request random words, both
in the mock and then in the

15531
15:47:25.567 --> 15:47:30.567
actual contract, you'll notice
that it also emits an event with

15532
15:47:30.567 --> 15:47:33.567
random words requested. And if
you look in here, the second

15533
15:47:33.567 --> 15:47:38.568
parameter that it has is indeed
the request ID. So in reality,

15534
15:47:38.568 --> 15:47:42.568
US omitting the request ID is
redundant, we can just use the

15535
15:47:42.568 --> 15:47:45.568
admitted Request ID from the VRF
coordinator for the purpose of

15536
15:47:45.568 --> 15:47:48.568
this course and showing you what
an event looks like. We're going

15537
15:47:48.568 --> 15:47:50.568
to leave it in there. But if you
want to go back and refactor

15538
15:47:50.568 --> 15:47:54.568
this, you would definitely want
to remove this omit. But for

15539
15:47:54.568 --> 15:47:58.568
this test, let's do TX receipt
dot events. And this is going to

15540
15:47:58.568 --> 15:48:02.568
be the first event instead of
the zero with event because

15541
15:48:02.568 --> 15:48:06.568
before this event gets emitted,
this function is going to emit

15542
15:48:06.568 --> 15:48:09.568
an event. So instead of the zero
with event, this is the first

15543
15:48:09.568 --> 15:48:12.568
event that gets emitted after
this one. So tax receipts dot

15544
15:48:12.568 --> 15:48:17.568
events of one dot args dot
request, ID, and then we're

15545
15:48:17.568 --> 15:48:23.568
gonna say cert request id.to
number is greater than zero. And

15546
15:48:23.568 --> 15:48:26.568
then we'll also assert that the

15547
15:48:26.568 --> 15:48:31.568
raffle state equals equals one.
So we're gonna do const, raffle

15548
15:48:31.568 --> 15:48:37.568
state equals await, raffle dot
get raffle state. And this

15549
15:48:37.568 --> 15:48:41.568
should actually be raffle
state.to Number, or to string

15550
15:48:41.568 --> 15:48:44.568
and then you know, do whatever
we want to do. And this is a

15551
15:48:44.568 --> 15:48:48.568
very big it, but we're going to
copy the whole thing anyways. HH

15552
15:48:48.568 --> 15:48:52.568
test, dash dash grep, paste that
in there, we run it, excuse

15553
15:48:52.568 --> 15:48:59.568
me.to string equals equals one,
transformer time and perfect, we

15554
15:48:59.568 --> 15:49:03.568
are passing Great, now it's time
for fulfill random words. And

15555
15:49:03.568 --> 15:49:06.568
this is where we're going to
learn a lot of fantastic stuff

15556
15:49:06.568 --> 15:49:09.568
here. So we're gonna make a new
describe block zoomed out a

15557
15:49:09.568 --> 15:49:15.568
little bit here. And this is
going to be our fulfill random

15558
15:49:15.568 --> 15:49:20.569
words. It's going to be a
function, of course. And in

15559
15:49:20.569 --> 15:49:23.569
here, we're actually going to
add another before each want to

15560
15:49:23.569 --> 15:49:26.569
have somebody have entered the
raffle before we run any tests

15561
15:49:26.569 --> 15:49:31.569
in here. So we're going to do a
before each, which will be an

15562
15:49:31.569 --> 15:49:37.569
async. function. And we're just
going to run await, raffle that

15563
15:49:37.569 --> 15:49:44.569
enter raffle with a value of
raffle entrance fee. And then

15564
15:49:44.569 --> 15:49:50.569
we're going to do a wait network
dot provider dot send EVM

15565
15:49:50.569 --> 15:49:58.569
increase time of interval, that
to number plus one, and then a

15566
15:49:58.569 --> 15:50:06.569
wait network dot provider dot
send EVM mine. Comma. Before

15567
15:50:06.569 --> 15:50:09.569
we've tried to do any testing of
or fulfilled random words, we're

15568
15:50:09.569 --> 15:50:11.569
gonna have somebody enter the
lottery. And we're going to have

15569
15:50:11.569 --> 15:50:15.569
increased the time and mined a
new block. Okay, cool. So the

15570
15:50:15.569 --> 15:50:17.569
first thing we want to do is
want to see that fulfill random

15571
15:50:17.569 --> 15:50:22.569
words can only be called so long
as there's a request in flight,

15572
15:50:22.569 --> 15:50:26.569
so long as there's a requested
as long as request random words

15573
15:50:26.569 --> 15:50:28.569
has been called. So we can
actually check that by running

15574
15:50:28.569 --> 15:50:34.569
it can only be called after
perform. This will be an async

15575
15:50:34.569 --> 15:50:38.569
function. And in here, we're
going to revert on some requests

15576
15:50:38.569 --> 15:50:44.569
that don't exist. So we'll do
await, expect the RF core didn't

15577
15:50:44.569 --> 15:50:51.569
a tour be to mock dot fulfill
random words. And if we look at

15578
15:50:51.569 --> 15:50:57.570
our V RF, coordinator v2 Mark in
here has the fulfill random

15579
15:50:57.570 --> 15:51:00.570
words function, which is what
the chain link node actually

15580
15:51:00.570 --> 15:51:03.570
calls and inside Add this
function in the actual contract

15581
15:51:03.570 --> 15:51:06.570
calls another contract that does
the random number verification.

15582
15:51:06.570 --> 15:51:09.570
So we're basically checking this
part right here. If the request

15583
15:51:09.570 --> 15:51:13.570
doesn't exist, we're going to
get this non existent request

15584
15:51:13.570 --> 15:51:16.570
here. And as you can see, it
needs a request ID and a

15585
15:51:16.570 --> 15:51:20.570
consumer address. So we're going
to guess zero. And the consumer

15586
15:51:20.570 --> 15:51:23.570
addresses, of course, it's gonna
be raffled out at address, we're

15587
15:51:23.570 --> 15:51:31.570
going to expect this to be
reverted, with non existent

15588
15:51:31.570 --> 15:51:35.570
request. And then we're going to
do this exact same thing with a

15589
15:51:35.570 --> 15:51:39.570
different Request ID or request
ID one. And hopefully, we're

15590
15:51:39.570 --> 15:51:42.570
also going to get non existent
requests. Now ideally, no

15591
15:51:42.570 --> 15:51:45.570
request here would ever allow
this fulfill random words to go

15592
15:51:45.570 --> 15:51:49.570
through. Now, it obviously would
be really hard for us to test

15593
15:51:49.570 --> 15:51:52.570
every single possible Request
ID, we're going to see a way in

15594
15:51:52.570 --> 15:51:56.570
the future to actually test for
a ton of these variables with

15595
15:51:56.570 --> 15:51:58.570
something called fuzz testing.
But we'll get to that in the

15596
15:51:58.570 --> 15:52:01.570
future. And I spelt the scribe
wrong, let's let's actually

15597
15:52:01.570 --> 15:52:05.570
spelled the scribe correctly, go
ahead and run this hh test dash

15598
15:52:05.570 --> 15:52:07.570
dash grep.

15599
15:52:07.570 --> 15:52:13.570
And great it passed. Now I'm
going to make just one more test

15600
15:52:13.570 --> 15:52:17.570
here, that's gonna be way too
big. But right now the test that

15601
15:52:17.570 --> 15:52:19.570
we're about to write is going to
be it's going to be a really big

15602
15:52:19.570 --> 15:52:22.570
test. And we probably want to
split it up into different

15603
15:52:22.570 --> 15:52:25.570
sections, but actually figured
that this was actually the best

15604
15:52:25.570 --> 15:52:27.570
way to show this section. And
it's going to be exactly what

15605
15:52:27.570 --> 15:52:30.570
we're going to do. When we get
to our staging test, we're going

15606
15:52:30.570 --> 15:52:33.570
to write this test literally
almost exactly the same. So

15607
15:52:33.570 --> 15:52:37.571
let's write it, this is
basically going to be the test

15608
15:52:37.571 --> 15:52:40.571
that puts everything together.
So we're going to test that this

15609
15:52:40.571 --> 15:52:47.571
indeed, so winner resets the
lottery, and sends money, which

15610
15:52:47.571 --> 15:52:50.571
is kind of a lot for a single
it, we probably would want to

15611
15:52:50.571 --> 15:52:53.571
split those into their own
pieces. But for this, we're just

15612
15:52:53.571 --> 15:52:55.571
going to put them all into one,
and it's going to be an async

15613
15:52:55.571 --> 15:52:59.571
function. Now we are going to
learn a couple of new tricks

15614
15:52:59.571 --> 15:53:02.571
here. So definitely be sure to
follow along. Now for this one,

15615
15:53:02.571 --> 15:53:05.571
we're also going to add in some
additional entrances additional

15616
15:53:05.571 --> 15:53:08.571
people who are entering this
lottery. So we'll say const,

15617
15:53:08.571 --> 15:53:14.571
additional, and trance equals
great. We're gonna have some

15618
15:53:14.571 --> 15:53:17.571
more of those fake accounts from
ethers enter our lottery here.

15619
15:53:17.571 --> 15:53:23.571
So we're gonna say const.
Starting account, index equals

15620
15:53:23.571 --> 15:53:27.571
to, since deployer equals zero,
excuse me equals one, since the

15621
15:53:27.571 --> 15:53:30.571
player is zero, so we're going
to have new accounts start from

15622
15:53:30.571 --> 15:53:35.571
index one. And we're going to do
a little for loop or let i

15623
15:53:35.571 --> 15:53:45.571
equals starting count index, i
is less than the starting count,

15624
15:53:45.571 --> 15:53:52.571
index, plus additional and trend
sees there's gonna be entrance.

15625
15:53:52.571 --> 15:53:56.571
i plus plus, we're gonna do a
little loop and connect our

15626
15:53:56.571 --> 15:53:59.571
raffle contract to these new
accounts. And then we're going

15627
15:53:59.571 --> 15:54:05.571
to have these new accounts,
enter our raffle contest. Count,

15628
15:54:05.571 --> 15:54:13.571
connected raffle equals raffle
dot connect accounts of i and do

15629
15:54:13.571 --> 15:54:16.571
we have accounts defined
somewhere we don't. So let's get

15630
15:54:16.571 --> 15:54:20.572
accounts to find somewhere.
We'll say const accounts equals

15631
15:54:20.572 --> 15:54:24.572
await ethers dot get signers.
And then we're going to do a

15632
15:54:24.572 --> 15:54:31.572
weight account connected raffle
dot enter. raffle with a value

15633
15:54:31.572 --> 15:54:34.572
of course of raffle entrance
fee,

15634
15:54:34.572 --> 15:54:37.572
we're going to connect three
additional entrance to our

15635
15:54:37.572 --> 15:54:41.572
raffle. So we're going to have a
total of four people connect

15636
15:54:41.572 --> 15:54:43.572
into this raffle. Now that we
have them in here, we're going

15637
15:54:43.572 --> 15:54:47.572
to keep note of our starting
timestamp. So we're gonna do

15638
15:54:47.572 --> 15:54:54.572
const starting timestamp equals
await, raffle dot get last

15639
15:54:54.572 --> 15:54:56.572
timestamp. And here's where
we're going to get a little bit

15640
15:54:56.572 --> 15:55:00.572
tricky. What we want to do is a
couple of things we want to we

15641
15:55:00.572 --> 15:55:05.572
want to perform upkeep, which is
going to mock being chainlink

15642
15:55:05.572 --> 15:55:09.572
keepers, which will kick off the
chain link, which will kick off

15643
15:55:09.572 --> 15:55:14.572
calling fulfill random words.
And we're going to mock doing

15644
15:55:14.572 --> 15:55:19.572
that as well. Mock being the
chain link VRF. Once we do that,

15645
15:55:19.572 --> 15:55:22.572
we can of course just check to
see okay, did the recent winner

15646
15:55:22.572 --> 15:55:26.572
get recorded the raffle get
reset just play as we said as

15647
15:55:26.572 --> 15:55:29.572
the timestamp is everything
reset. But we want to do this in

15648
15:55:29.572 --> 15:55:33.572
a specific way. If we're doing
this on a test net after we call

15649
15:55:33.572 --> 15:55:37.572
fulfill random words, we will
have to wait for the fulfill

15650
15:55:37.572 --> 15:55:40.572
random words to be called. Now
since we're working with a

15651
15:55:40.572 --> 15:55:43.572
hardhat local chain, we don't
really need to wait for

15652
15:55:43.572 --> 15:55:46.572
anything, right because we can
just say okay, boom, snap our

15653
15:55:46.572 --> 15:55:48.572
fingers and adjust our
blockchain to do whatever we

15654
15:55:48.572 --> 15:55:51.572
want. But we're going to
simulate that we do need to wait

15655
15:55:51.572 --> 15:55:55.572
for that event to be called. So
in order for us to simulate

15656
15:55:55.572 --> 15:55:59.573
waiting for that event, we once
again need to set up a listener.

15657
15:55:59.573 --> 15:56:02.573
Now if we set up a listener we
don't want this to Just to

15658
15:56:02.573 --> 15:56:06.573
finish before the listener has
is done listening, so we need to

15659
15:56:06.573 --> 15:56:09.573
once again create a new promise.
And this is going to be

15660
15:56:09.573 --> 15:56:13.573
incredibly important, especially
for our staging tests. So we're

15661
15:56:13.573 --> 15:56:17.573
going to do await, new promise.
And this is going to be exactly

15662
15:56:17.573 --> 15:56:20.573
the same as we set it up before,
it's going to be an async

15663
15:56:20.573 --> 15:56:24.573
function that's going to take
resolve and reject as

15664
15:56:24.573 --> 15:56:27.573
parameters. And we're going to
use this little arrow syntax

15665
15:56:27.573 --> 15:56:30.573
here saying, this is an async
function, basically, and we're

15666
15:56:30.573 --> 15:56:34.573
going to set up once again, that
once syntax, we're gonna say

15667
15:56:34.573 --> 15:56:39.573
raffle that once, what's the
event name, winner picked. So

15668
15:56:39.573 --> 15:56:42.573
we're gonna say, Listen, for
this winner picked event, we're

15669
15:56:42.573 --> 15:56:46.573
gonna say raffle dot once winner
picks happens, do some stuff.

15670
15:56:46.573 --> 15:56:49.573
And again, this is just an
anonymous function. So we're

15671
15:56:49.573 --> 15:56:51.573
gonna say raffle dot once the
winner picked event gets

15672
15:56:51.573 --> 15:56:56.573
emitted, do some stuff. So we're
setting this up. Now it's in

15673
15:56:56.573 --> 15:56:58.573
this function, we're going to
add all of our certs and

15674
15:56:58.573 --> 15:57:01.573
everything because we want to
wait for winter to get picked.

15675
15:57:01.573 --> 15:57:05.573
Now before the event gets fired,
though, we of course, need to

15676
15:57:05.573 --> 15:57:08.573
actually call perform and call
fulfill random words. So this is

15677
15:57:08.573 --> 15:57:11.573
going to seem like it's a little
bit backwards. But that's

15678
15:57:11.573 --> 15:57:14.573
because we want to set up our
listeners so that when we do

15679
15:57:14.573 --> 15:57:19.573
fire, the methods that will fire
the event, our listener is

15680
15:57:19.573 --> 15:57:22.573
activated and is waiting for it.
So we're going to put all of our

15681
15:57:22.573 --> 15:57:27.573
code inside of this promise.
Now, because we put it outside

15682
15:57:27.573 --> 15:57:28.573
of the promise, we put all the
code outside of the promise,

15683
15:57:28.573 --> 15:57:31.573
this promise will never get
resolved, because the listener

15684
15:57:31.573 --> 15:57:34.573
will never fire into vent. So if
down here, you know we call

15685
15:57:34.573 --> 15:57:37.574
fulfill random words with
something, you know which the

15686
15:57:37.574 --> 15:57:40.574
spelling is bad. But let's say
we call the down here, this

15687
15:57:40.574 --> 15:57:43.574
piece of code will never reach
this fulfill random words,

15688
15:57:43.574 --> 15:57:47.574
because it's always going to be
waiting for this wants to get

15689
15:57:47.574 --> 15:57:51.574
resolved. So we need to add all
of our code inside the promise.

15690
15:57:51.574 --> 15:57:55.574
But outside this raffle dot once
now we don't want to wait

15691
15:57:55.574 --> 15:57:58.574
forever, right? Maybe there is
an issue here. And we want to be

15692
15:57:58.574 --> 15:58:02.574
able to reject this, if there's
an issue. Now what we can do is

15693
15:58:02.574 --> 15:58:06.574
in our heart hat dot config, we
can add a timeout. So we can add

15694
15:58:06.574 --> 15:58:13.574
this mocha section, we can give
ourselves a timeout of 200,000

15695
15:58:13.574 --> 15:58:17.574
milliseconds, which is going to
be 200 seconds max, if this

15696
15:58:17.574 --> 15:58:21.574
event doesn't get fired in 200
seconds, this will be considered

15697
15:58:21.574 --> 15:58:24.574
a failure and this test will
fail, which is what we want. And

15698
15:58:24.574 --> 15:58:27.574
I typically like to just wrap
this in a try catch because if

15699
15:58:27.574 --> 15:58:31.574
something fails, it'll cause you
a whole bunch of headache catch

15700
15:58:31.574 --> 15:58:35.574
E. And if anything fails, we'll
also reject, there's an issue

15701
15:58:35.574 --> 15:58:38.574
with us calling some function,
we'll just say, Hey, okay,

15702
15:58:38.574 --> 15:58:41.574
that's a failure. But you fail,
that way, our promise can get

15703
15:58:41.574 --> 15:58:43.574
resolved in a timely manner,
we're going to add this code in

15704
15:58:43.574 --> 15:58:47.574
a little bit. But let's keep
going. Let's keep going. And

15705
15:58:47.574 --> 15:58:50.574
excuse me, the trycatch should
be in the ones, the ones above

15706
15:58:50.574 --> 15:58:54.574
the results, excuse me, because
this is the listener. So sorry,

15707
15:58:54.574 --> 15:58:56.574
we want the trycatch to be
inside the ones if this takes

15708
15:58:56.574 --> 15:58:59.574
too long, we want to just go
ahead and throw an error.

15709
15:58:59.574 --> 15:59:01.574
Otherwise, we're going to
resolve now outside the

15710
15:59:01.574 --> 15:59:04.574
listener, but inside of the
promise, we're going to do this

15711
15:59:04.574 --> 15:59:11.574
bit here, where we go const TX
equals await raffle dot perform

15712
15:59:11.574 --> 15:59:15.574
upkeep, and we'll pass it the
empty bytes object, we'll get

15713
15:59:15.574 --> 15:59:21.575
const TX receipt equals await TX
dot weight of one block.

15714
15:59:21.575 --> 15:59:27.575
And then we're going to do a
weight VRF core didn't a tour be

15715
15:59:27.575 --> 15:59:35.575
to mock dot fulfill random
words, CX receipt dot events of

15716
15:59:35.575 --> 15:59:41.575
one dot args dot Request ID come
a raffle that address. So then

15717
15:59:41.575 --> 15:59:43.575
the final thing that we're going
to do is we're going to get this

15718
15:59:43.575 --> 15:59:47.575
veer off coordinator be to mock
we're going to have it call

15719
15:59:47.575 --> 15:59:50.575
fulfill random words, which
takes the request ID and the

15720
15:59:50.575 --> 15:59:53.575
consumer address. So we're going
to mock it, give it the request

15721
15:59:53.575 --> 15:59:56.575
ID which we get from the
transaction receipt, and the

15722
15:59:56.575 --> 15:59:59.575
consumer address here. All
inside this promise, we're

15723
15:59:59.575 --> 16:00:02.575
setting up a listener for this
winner picked event. And then

15724
16:00:02.575 --> 16:00:05.575
we're mocking the channeling
keepers and then we're mocking

15725
16:00:05.575 --> 16:00:09.575
the chainlink VRF. And once this
function gets called this

15726
16:00:09.575 --> 16:00:14.575
function should emit a winner
picked event. So this raffle

15727
16:00:14.575 --> 16:00:18.575
that was set up that was
listening for this to get

15728
16:00:18.575 --> 16:00:22.575
emitted will pick up and go Ah
okay, I found it I found the

15729
16:00:22.575 --> 16:00:26.575
winner picked event. Now we can
go ahead and do some stuff. So

15730
16:00:26.575 --> 16:00:29.575
once the winner picked event
gets fired, we'll do a little

15731
16:00:29.575 --> 16:00:35.575
console dot log found the event
like this and we'll jump into

15732
16:00:35.575 --> 16:00:38.575
our try catch and this trycatch
is going to be basically us

15733
16:00:38.575 --> 16:00:42.575
doing all these asserts in here.
So first we want to say const

15734
16:00:42.575 --> 16:00:48.575
recent winner equals await
raffle dot get recent winner and

15735
16:00:48.575 --> 16:00:50.575
we're going to be checking just
everything in this raffle right

15736
16:00:50.575 --> 16:00:53.575
we're gonna be checking that the
recent winners right that that

15737
16:00:53.575 --> 16:00:55.575
the raffle state's been reset
the players have reversed, you

15738
16:00:55.575 --> 16:00:59.576
know, players has been reset,
etc, etc. So we'll say const

15739
16:00:59.576 --> 16:01:06.576
raffle state equals awaits
raffle dot get raffle state

15740
16:01:06.576 --> 16:01:12.576
we'll say const. Ending
timestamp equals await, raffle

15741
16:01:12.576 --> 16:01:17.576
dot get last timestamp. And
let's start doing some asserts.

15742
16:01:17.576 --> 16:01:21.576
So first we should assert that
this es players array has been

15743
16:01:21.576 --> 16:01:25.576
reset to zero. So if we call get
number of players it should be

15744
16:01:25.576 --> 16:01:32.576
zero. So we can do const num
players equals await raffle dot

15745
16:01:32.576 --> 16:01:40.576
get number of players like so.
And we can do assert dot equal

15746
16:01:40.576 --> 16:01:45.576
nine players.to string is going
to be zero. What else can we

15747
16:01:45.576 --> 16:01:52.576
assert? Well, we can assert dot
equal raffle state should be

15748
16:01:52.576 --> 16:01:59.576
back to being open. So raffle
state.to string should be zero,

15749
16:01:59.576 --> 16:02:04.576
we should assert that the ending
timestamp is now greater than

15750
16:02:04.576 --> 16:02:09.576
the starting timestamp. Because
the last timestamp should have

15751
16:02:09.576 --> 16:02:12.576
been updated. We also want to
make sure our recent winner is

15752
16:02:12.576 --> 16:02:16.576
correct. But we'll do console
dot log recent winner. Now we

15753
16:02:16.576 --> 16:02:20.576
can go to the VRF coordinator
mock. And we could simulate this

15754
16:02:20.576 --> 16:02:22.576
and try to figure out who the
random winner is to console dot

15755
16:02:22.576 --> 16:02:27.576
log accounts to. And then just
to show a bunch of them, we'll

15756
16:02:27.576 --> 16:02:35.576
do 01 and three a raffle dot
once this needs to be an async

15757
16:02:35.576 --> 16:02:38.577
function, not just a regular
function. Let's try that one

15758
16:02:38.577 --> 16:02:42.577
more time, get latest timestamp
is the correct function. So

15759
16:02:42.577 --> 16:02:45.577
let's update this with the
correct latest. Let's put latest

15760
16:02:45.577 --> 16:02:49.577
in there. Because I'm spelling
something's wrong. I sure am

15761
16:02:49.577 --> 16:02:52.577
looks like we're printing out
recent winner here when we

15762
16:02:52.577 --> 16:02:55.577
haven't even initialized it. So
let's move it up. And then we'll

15763
16:02:55.577 --> 16:02:59.577
do console dot log recent
winner. So I know this is a

15764
16:02:59.577 --> 16:03:03.577
massive test here. But let's
give it a try and see if

15765
16:03:03.577 --> 16:03:05.577
everything kind of does what we
think it should do. And it's

15766
16:03:05.577 --> 16:03:08.577
slowing down here, which is good
because we're doing a lot of

15767
16:03:08.577 --> 16:03:13.577
stuff. And uh huh, we finally
get this passing thing to come

15768
16:03:13.577 --> 16:03:17.577
out. And we did a ton of console
dot logging so so there's a lot

15769
16:03:17.577 --> 16:03:19.577
of stuff in here of the signers
are getting printed out. So

15770
16:03:19.577 --> 16:03:22.577
let's just make this a little
easier to read. We'll add dot

15771
16:03:22.577 --> 16:03:27.577
address to all these, we can see
who the winner is. So it looks

15772
16:03:27.577 --> 16:03:30.577
like the winner is going to be
account number one, which is

15773
16:03:30.577 --> 16:03:33.577
great. So what we can do now
that we know account number one

15774
16:03:33.577 --> 16:03:35.577
is going to be the winner, we
can get that winners starting

15775
16:03:35.577 --> 16:03:40.577
balance way down here before we
call fulfill random words. So

15776
16:03:40.577 --> 16:03:47.577
we'll say const winner, starting
balance equals await accounts

15777
16:03:47.577 --> 16:03:51.577
one dot get balance, yes, you
can just call get balance right

15778
16:03:51.577 --> 16:03:55.577
like that. And now that we have
the winner starting balance back

15779
16:03:55.577 --> 16:04:01.577
in our tests, we can say const
winner, ending balance equals

15780
16:04:01.577 --> 16:04:07.577
await ounce one dot get balance.
And we can make sure that this

15781
16:04:07.577 --> 16:04:11.577
winner got paid what they need.
So now we're going to do a big

15782
16:04:11.577 --> 16:04:14.577
assert with some money stuff,
just trust me, this is what the

15783
16:04:14.577 --> 16:04:18.578
math is. So we're going to do
assert dot equal winner

15784
16:04:18.578 --> 16:04:21.578
balance.to string,

15785
16:04:21.578 --> 16:04:26.578
excuse me winter ending
balance.to string should equal

15786
16:04:26.578 --> 16:04:34.578
the winner starting balance dot
add the raffle entrance fee that

15787
16:04:34.578 --> 16:04:41.578
multiplied by the additional and
trance that add the raffle

15788
16:04:41.578 --> 16:04:45.578
entrance fee that we paid.to
string. So this math is

15789
16:04:45.578 --> 16:04:49.578
basically saying the winner
should end with a balance of all

15790
16:04:50.578 --> 16:04:53.578
of the money that everybody else
added to this contract. And

15791
16:04:53.578 --> 16:04:57.578
that's it. So we can run this
test one more time. And Gosh,

15792
16:04:57.578 --> 16:05:00.578
darn it, it passed. Okay, so
there was a lot of code here.

15793
16:05:00.578 --> 16:05:03.578
And this might have been one of
the hardest pieces of this

15794
16:05:03.578 --> 16:05:06.578
entire course is going to be
this part right here. So if you

15795
16:05:06.578 --> 16:05:08.578
struggled a little bit with
this, don't let that bog you

15796
16:05:08.578 --> 16:05:11.578
down. This is probably one of
the more difficult sections of

15797
16:05:11.578 --> 16:05:15.578
this course, let's do a quick
refresher of just this test that

15798
16:05:15.578 --> 16:05:18.578
we're doing. And then we'll see
in an action when we do it. In

15799
16:05:18.578 --> 16:05:21.578
our staging test. What we did is
we're picking a winner resetting

15800
16:05:21.578 --> 16:05:23.578
the lottery and we're sending
money. Basically what we're

15801
16:05:23.578 --> 16:05:26.578
doing is we're testing that this
fulfill random words thing does

15802
16:05:26.578 --> 16:05:29.578
what we want it to do a random
winner wins and they get the

15803
16:05:29.578 --> 16:05:31.578
money. So how do we actually do
that? Well, we first started off

15804
16:05:31.578 --> 16:05:34.578
by having a bunch of random
people enter the lottery. Great.

15805
16:05:34.578 --> 16:05:38.578
Sounds good. Now what we wanted
to do was we want to call

15806
16:05:38.578 --> 16:05:42.578
perform upkeep and fulfill
random words, we want to pretend

15807
16:05:42.578 --> 16:05:45.578
that the random number was
drawn. And that's what this code

15808
16:05:45.578 --> 16:05:48.578
down here does is it calls that
random number but and what we

15809
16:05:48.578 --> 16:05:51.578
could have done was we could
have had all these assert and

15810
16:05:51.578 --> 16:05:54.578
checked all the variables. After
we did this, right. We could

15811
16:05:54.578 --> 16:05:58.579
have totally done that. However,
on a test net where we don't

15812
16:05:58.579 --> 16:06:01.579
always know exactly when a
transaction is going to finish.

15813
16:06:01.579 --> 16:06:04.579
We have to wait If we have to
listen for an event to be fired,

15814
16:06:04.579 --> 16:06:07.579
before, we could call the
transactions that would end this

15815
16:06:07.579 --> 16:06:10.579
whole thing, we needed to set
something up to listen for that

15816
16:06:10.579 --> 16:06:14.579
event to be fired. And we said,
hey, only once this event is

15817
16:06:14.579 --> 16:06:18.579
fired only once this transaction
is called, can we do our testing

15818
16:06:18.579 --> 16:06:22.579
now for our local network, we
are mocking the VRF

15819
16:06:22.579 --> 16:06:24.579
coordinators, we have control,
we know exactly when this is

15820
16:06:24.579 --> 16:06:28.579
going to run. But on a test net,
we don't. So you'll see in our

15821
16:06:28.579 --> 16:06:31.579
staging tests, we won't have any
of this here. And we'll have to

15822
16:06:31.579 --> 16:06:37.579
rely on setting up a listener to
listen for the channeling VRF

15823
16:06:37.579 --> 16:06:40.579
and the keepers to fire their
events. And that's why the

15824
16:06:40.579 --> 16:06:43.579
staging test is going to be so
important to make sure that

15825
16:06:43.579 --> 16:06:45.579
we're doing everything correct.
And that's why we set up our

15826
16:06:45.579 --> 16:06:48.579
local tests like this, so that
it mimics what we're going to be

15827
16:06:48.579 --> 16:06:51.579
doing on our statement test what
we're going to be doing on a

15828
16:06:51.579 --> 16:06:54.579
real network here. And again,
we're setting up this listener

15829
16:06:54.579 --> 16:06:58.579
and we're saying, Ah, once we do
here, this event, then we're

15830
16:06:58.579 --> 16:07:01.579
going to try to actually check
all of the balances and check

15831
16:07:01.579 --> 16:07:04.579
that everything is working as
intended. And if we don't see

15832
16:07:04.579 --> 16:07:07.579
it, we're going to reject. And
if there's a timeout, if it

15833
16:07:07.579 --> 16:07:09.579
takes more than 200 seconds,
we're going to say okay,

15834
16:07:09.579 --> 16:07:11.579
something went wrong, we're
going to cancel it. And

15835
16:07:11.579 --> 16:07:13.579
actually, I'm going to bump this
up to 300 seconds, because I

15836
16:07:13.579 --> 16:07:17.579
think 200 seconds is not going
to be enough. And depending on

15837
16:07:17.579 --> 16:07:19.579
how quick the rink B test that
is, you might have to bump this

15838
16:07:19.579 --> 16:07:27.579
up even bigger. So just keep
that in mind. But who, okay, we

15839
16:07:27.579 --> 16:07:30.579
have just built some fantastic
tests. Let's go ahead, and let's

15840
16:07:30.579 --> 16:07:36.579
just run h h test to see if all
of our tests are going to pass.

15841
16:07:36.579 --> 16:07:40.580
And well, 14 passing, everything
is passing here we are looking

15842
16:07:40.580 --> 16:07:41.580
good.

15843
16:07:41.580 --> 16:07:46.580
This is fantastic. Alright, so
now that we have our unit tests,

15844
16:07:46.580 --> 16:07:50.580
let's go ahead and create a
staging test. Our staging test

15845
16:07:50.580 --> 16:07:53.580
is going to look really similar
to that massive test that we

15846
16:07:53.580 --> 16:07:56.580
just created down here. And the
reason we set up our unit test

15847
16:07:56.580 --> 16:07:59.580
to do this a weight promise
thing with the raffle dot once

15848
16:07:59.580 --> 16:08:02.580
was because this is actually how
we're going to need to wait on a

15849
16:08:02.580 --> 16:08:06.580
test net or main net for a
winner to be picked. We cannot

15850
16:08:06.580 --> 16:08:09.580
on an actual test net, pretend
to be the chain link V REF, we

15851
16:08:09.580 --> 16:08:11.580
can pretend to be the chain link
keepers if we want. But we're

15852
16:08:11.580 --> 16:08:14.580
not going to make sure that the
10 the keepers is actually

15853
16:08:14.580 --> 16:08:17.580
working. But we are going to be
doing this because we want to

15854
16:08:17.580 --> 16:08:21.580
listen for that event to be
fired, we want to listen for the

15855
16:08:21.580 --> 16:08:25.580
chain link VRF to respond with
the winner. So let's create a

15856
16:08:25.580 --> 16:08:29.580
staging test. And this is a test
that we're going to run on an

15857
16:08:29.580 --> 16:08:33.580
actual test net here. Okay, so
we're going to create a new test

15858
16:08:33.580 --> 16:08:38.580
called raffle dot staging dot
test dot Jas and this is where

15859
16:08:38.580 --> 16:08:41.580
we're going to put our staging
test. Now we can actually code

15860
16:08:41.580 --> 16:08:44.580
this pretty quickly because most
of our staging tests is gonna

15861
16:08:44.580 --> 16:08:47.580
look real similar to our raffle
test here. So for now, let's

15862
16:08:47.580 --> 16:08:51.580
just grab this whole first part,
and then we'll adjust it as we

15863
16:08:51.580 --> 16:08:54.580
need. And then we'll close it
off. Because we're definitely

15864
16:08:54.580 --> 16:08:57.580
gonna need a raffle, we're not
going to need a VRF coordinator

15865
16:08:57.580 --> 16:09:00.580
mock because again, we're not
going to be using a mock. Since

15866
16:09:00.580 --> 16:09:02.580
we're on an actual test net, we
will need the raffle entrance

15867
16:09:02.580 --> 16:09:06.580
fee, we will need Deployer, we
will need a Deployer. And we

15868
16:09:06.580 --> 16:09:08.580
might need the interval. But
let's delete it for now we

15869
16:09:08.580 --> 16:09:11.580
probably won't need the chain
ID. So let's delete that as

15870
16:09:11.580 --> 16:09:14.580
well. Awesome. Something that we
want to keep in mind is that

15871
16:09:14.580 --> 16:09:17.580
when it comes to our staging
tests, we only want our steam

15872
16:09:17.580 --> 16:09:19.581
test to run when we're on a
test. Net, we don't need to run

15873
16:09:19.581 --> 16:09:22.581
our unit tests because our unit
tests aren't checking that

15874
16:09:22.581 --> 16:09:25.581
compatibility with a test net,
we want our unit tests to only

15875
16:09:25.581 --> 16:09:29.581
run on a local network. And we
want our staging tests to only

15876
16:09:29.581 --> 16:09:32.581
run on a test network. This is
where again, in our test, we're

15877
16:09:32.581 --> 16:09:35.581
going to check to make sure what
type of chain we're on. And

15878
16:09:35.581 --> 16:09:38.581
oops, it looks like I already
imported the development changes

15879
16:09:38.581 --> 16:09:41.581
here. So we're actually in our
staging tests, we're going to

15880
16:09:41.581 --> 16:09:44.581
check before we run any test
what kind of network we're on.

15881
16:09:44.581 --> 16:09:49.581
So we're gonna say, if our
development chains that includes

15882
16:09:49.581 --> 16:09:52.581
network dot name, we're gonna
say if our development chains

15883
16:09:52.581 --> 16:09:55.581
includes network to name, so if
the chain we're on is in the

15884
16:09:55.581 --> 16:09:58.581
development chains, and again,
we're going to use this ternary

15885
16:09:58.581 --> 16:10:01.581
operator where we say, if we're
on a development chain, do

15886
16:10:01.581 --> 16:10:03.581
something. And then if we're not
on a development chain, do

15887
16:10:03.581 --> 16:10:06.581
something else. If we are on a
development chain, what are we

15888
16:10:06.581 --> 16:10:09.581
going to do? Well want to skip
this and we can actually skip

15889
16:10:09.581 --> 16:10:13.581
this by putting in this describe
dot skip. And this will skip

15890
16:10:13.581 --> 16:10:16.581
this whole section here. And
then we can say, if we are the

15891
16:10:17.581 --> 16:10:20.581
development chain, go ahead and
do our thing. So this is some

15892
16:10:20.581 --> 16:10:23.581
really nice syntax that allows
us to skip our staging tests if

15893
16:10:23.581 --> 16:10:27.581
we're on a local network. And
additionally, we can grab this

15894
16:10:27.581 --> 16:10:30.581
syntax, go into our raffle dot
test dot j s where we have our

15895
16:10:30.581 --> 16:10:34.581
unit tests and add the bang
operator, which is the knot and

15896
16:10:34.581 --> 16:10:37.581
hit Save. And now we're saying
if we're not on a development

15897
16:10:38.581 --> 16:10:41.581
chain, skip it and only run this
if we aren't in development

15898
16:10:41.581 --> 16:10:44.581
chain. So this says run this
only on a test net or main net.

15899
16:10:44.581 --> 16:10:47.581
And then this has run this only
on a local network. Great. So we

15900
16:10:47.581 --> 16:10:50.581
have a deployer which we're
going to need. We are not going

15901
16:10:50.581 --> 16:10:54.581
to need to deploy any fixtures
because we're going to run our

15902
16:10:54.581 --> 16:10:57.581
deploy script and our contracts
should already be deployed. We

15903
16:10:57.581 --> 16:11:00.582
will need a raffle we won't need
a VRF coordinator mocks we can

15904
16:11:00.582 --> 16:11:03.582
delete that We will need the
entrance fee, and we probably

15905
16:11:03.582 --> 16:11:05.582
won't need the interval. So we
can go ahead and delete that

15906
16:11:05.582 --> 16:11:08.582
too. Alright, awesome. So we
have our describe, we have our

15907
16:11:08.582 --> 16:11:11.582
before each, let's make our
tests. And I'm just going to

15908
16:11:11.582 --> 16:11:15.582
make one giant test to test kind
of everything end to end. And

15909
16:11:15.582 --> 16:11:18.582
you can add more tests later on
yourself, if you want to our

15910
16:11:18.582 --> 16:11:22.582
staging test is going to be
really similar to this massive

15911
16:11:22.582 --> 16:11:25.582
test that we made down here. And
in fact, we're going to use most

15912
16:11:25.582 --> 16:11:27.582
of this code here as our
boilerplate. So let's create a

15913
16:11:27.582 --> 16:11:31.582
describe. And we'll say, and
we'll actually just copy this

15914
16:11:31.582 --> 16:11:34.582
describe the four random words
and paste it in here. Because

15915
16:11:34.582 --> 16:11:36.582
again, we're going to be using a
lot of the same code in our

15916
16:11:36.582 --> 16:11:42.582
staging tests here. Great. So
now we'll say it works with live

15917
16:11:42.582 --> 16:11:48.582
chain link keepers and chain
link VRF, we get a random

15918
16:11:48.582 --> 16:11:53.582
winner, acing function. So this
is going to be our test in here.

15919
16:11:53.582 --> 16:11:57.582
So in this test, we of course,
we want to enter the raffle. And

15920
16:11:57.582 --> 16:12:01.582
we shouldn't have to do anything
else except for enter this

15921
16:12:01.582 --> 16:12:03.582
raffle. Because the chain the
keepers and the only VRF are

15922
16:12:03.582 --> 16:12:06.582
going to be the ones to actually
kick off this lottery for us,

15923
16:12:06.582 --> 16:12:10.582
we'll do a quick grabbing of the
starting timestamp to have it

15924
16:12:10.582 --> 16:12:13.582
before all this kicks off. So
we'll say const starting

15925
16:12:13.582 --> 16:12:20.582
timestamp equals await raffle
dot get last to me get latest

15926
16:12:20.582 --> 16:12:23.582
timestamp, get latest timestamp,
we're gonna grab this because

15927
16:12:23.582 --> 16:12:26.582
later on, we're going to test to
see if the timestamp has indeed

15928
16:12:26.582 --> 16:12:29.582
moved forward, we want to enter
the lottery, right, we want to

15929
16:12:29.582 --> 16:12:31.582
run the command we've been
running over here all the time,

15930
16:12:31.582 --> 16:12:35.582
we want to do you know await
raffle dot enter raffle, but we

15931
16:12:35.582 --> 16:12:39.583
don't want to call it yet.
Because same as what we did over

15932
16:12:39.583 --> 16:12:43.583
here, we want to set up our
listener first. Now in here, we

15933
16:12:43.583 --> 16:12:46.583
probably should have set up our
listener before we entered the

15934
16:12:46.583 --> 16:12:50.583
raffle. However, we controlled
the blockchain. So putting it in

15935
16:12:50.583 --> 16:12:54.583
that order was is was okay. But
we want to set up the listener

15936
16:12:54.583 --> 16:12:58.583
before we enter the raffle just
in case the blockchain moves

15937
16:12:58.583 --> 16:13:01.583
really fast. And we're going to
set up the listener the exact

15938
16:13:01.583 --> 16:13:05.583
same way, we did it over here.
So we're gonna say await new

15939
16:13:05.583 --> 16:13:08.583
promise. And it's going to be an
async function that takes a

15940
16:13:08.583 --> 16:13:11.583
resolve and a reject. And we're
going to use a little arrow

15941
16:13:11.583 --> 16:13:14.583
notation here. And in here,
we're going to set up the

15942
16:13:14.583 --> 16:13:18.583
listener, we're gonna say raffle
dot once, once that winner is

15943
16:13:18.583 --> 16:13:21.583
picked, we're going to do
another async function using

15944
16:13:21.583 --> 16:13:24.583
that Arrow.

15945
16:13:24.583 --> 16:13:30.583
Arrow function syntax, we'll say
console dot log winner picked

15946
16:13:30.583 --> 16:13:35.583
the event fired. And only once
we get this winner picked, can

15947
16:13:35.583 --> 16:13:38.583
we start doing our asserts in
here, can we start making sure

15948
16:13:38.583 --> 16:13:42.583
that there's a winner, there's a
verifiably random winner, it's

15949
16:13:42.583 --> 16:13:44.583
been picked, the money has been
moved, etc. This is where we'll

15950
16:13:44.583 --> 16:13:49.583
do our try catch. And if there's
any error, we're just going to

15951
16:13:49.583 --> 16:13:52.583
automatically reject, we're
going to reject the promise. And

15952
16:13:52.583 --> 16:13:56.583
if all goes well, of course,
we're going to resolve the

15953
16:13:56.583 --> 16:13:58.583
promise. So our listener has
been set up here. We haven't

15954
16:13:58.583 --> 16:14:01.583
added our asserts here. But we
will, let's just go ahead and

15955
16:14:01.583 --> 16:14:04.583
write the rest of the test. And
then we'll go back and we'll

15956
16:14:04.583 --> 16:14:08.583
update this listener so so our
listener has been added. And

15957
16:14:08.583 --> 16:14:10.583
inside here is actually where
we're going to enter the raffle.

15958
16:14:10.583 --> 16:14:17.583
So inside here, await, raffle
dot enter raffle value is going

15959
16:14:17.583 --> 16:14:23.584
to be raffle entrance fee. And
really that's it. Right? So

15960
16:14:23.584 --> 16:14:26.584
we're setting up the listener,
setting up the listener, then

15961
16:14:26.584 --> 16:14:33.584
entering the raffle. And this
code won't complete until our

15962
16:14:33.584 --> 16:14:37.584
listener has finished listening
because again, this whole SEC is

15963
16:14:37.584 --> 16:14:40.584
in a wait. So we're gonna say
okay, cool setup, the listener,

15964
16:14:40.584 --> 16:14:43.584
wait for this to finish. And
then when it gets here, it goes

15965
16:14:43.584 --> 16:14:46.584
out okay, this is the end of the
code Are we all done executing

15966
16:14:46.584 --> 16:14:50.584
Oh, no resolve or reject hasn't
been called yet. And that's

15967
16:14:50.584 --> 16:14:52.584
because we're still waiting for
the listener to finish

15968
16:14:52.584 --> 16:14:56.584
listening. Now, once we get this
winner picked event emitted in

15969
16:14:56.584 --> 16:14:59.584
here, we're going to get that
recent winner so we'll say const

15970
16:14:59.584 --> 16:15:05.584
recent winner equals await
raffle dot get recent winner

15971
16:15:05.584 --> 16:15:10.584
will get the raffle state we'll
say const. raffle state equals

15972
16:15:10.584 --> 16:15:14.584
await raffle dot get raffle
state, we'll get the winners

15973
16:15:14.584 --> 16:15:21.584
balance. So we'll say const.
Winner balance equals await

15974
16:15:21.584 --> 16:15:25.584
recent winner. And since we're
only entering with our Deployer

15975
16:15:25.584 --> 16:15:28.584
we should check to see the
deployers balance at the end and

15976
16:15:28.584 --> 16:15:31.584
we can't do it right with this
deployer object here. So we'll

15977
16:15:31.584 --> 16:15:38.584
have to do the player account
equals await ethers dot get

15978
16:15:38.584 --> 16:15:43.584
signers, no wrap this actually
actually will just say this is

15979
16:15:43.584 --> 16:15:46.584
accounts here like that. And
then we'll just do a count of

15980
16:15:46.584 --> 16:15:49.584
zero because it counts as zero
is going to be our Deployer. So

15981
16:15:49.584 --> 16:15:52.584
our winner balance is going to
be accounts a zero dot get

15982
16:15:52.584 --> 16:15:57.584
balance. And then we're going to
do const ending timestamp equals

15983
16:15:57.584 --> 16:16:04.585
a weight raffle dot get latest
To timestamp, and we should also

15984
16:16:04.585 --> 16:16:08.585
get the starting balance. So
we'll say winner ending balance,

15985
16:16:08.585 --> 16:16:12.585
we should also get the starting
balance right after we enter. So

15986
16:16:12.585 --> 16:16:18.585
we'll say const. Winner,
starting balance equals await

15987
16:16:18.585 --> 16:16:23.585
accounts. Zero dot get balance,
so that now we can do some

15988
16:16:23.585 --> 16:16:26.585
comparisons. All right, great.
Let's do the comparisons now. So

15989
16:16:26.585 --> 16:16:30.585
we should first expect the
raffle to be reset. So we can do

15990
16:16:30.585 --> 16:16:34.585
this a few different ways. Down
here. We did number of players.

15991
16:16:34.585 --> 16:16:43.585
We can also say, await, expect
raffle dot get player 0.2 dot v

15992
16:16:43.585 --> 16:16:48.585
dot reverted, right because Get
Player zero should get reverted

15993
16:16:48.585 --> 16:16:50.585
because there's not even going
to be an object at zero. So

15994
16:16:50.585 --> 16:16:53.585
that's another way we can check
to see if our players array has

15995
16:16:53.585 --> 16:16:57.585
been reset. Next, we can do
assert dot equal recent

15996
16:16:57.585 --> 16:17:04.585
winner.to string, this should
equal our account zero dot

15997
16:17:04.585 --> 16:17:09.585
address. Okay, our Deployer What
else can we do? We will assert

15998
16:17:09.585 --> 16:17:14.585
dot equal raffle state to zero.
We want this email to go back to

15999
16:17:14.585 --> 16:17:17.585
open after we're done. And then
we finally want to make sure

16000
16:17:17.585 --> 16:17:19.585
that the money has been
transferred correctly. So we'll

16001
16:17:19.585 --> 16:17:25.585
do assert dot equal, this should
be a winner ending balance. That

16002
16:17:25.585 --> 16:17:34.585
to string should be equal to
winner starting balance, add

16003
16:17:34.585 --> 16:17:38.586
raffle entrance fee.to string.
So if we look down here, they

16004
16:17:38.586 --> 16:17:42.586
enter the raffle we check their
starting balance right after

16005
16:17:42.586 --> 16:17:45.586
they enter. And they basically
should just get that raffle

16006
16:17:45.586 --> 16:17:48.586
entrance fee back right because
they are the only ones who have

16007
16:17:48.586 --> 16:17:51.586
entered this raffle. And then we
can do one more assert, do

16008
16:17:51.586 --> 16:17:56.586
assert that the ending timestamp
is greater than the starting

16009
16:17:56.586 --> 16:18:00.586
timestamp. And then we'll of
course, say resolve. So this all

16010
16:18:00.586 --> 16:18:04.586
goes well, we resolve. If
there's an issue with any of

16011
16:18:04.586 --> 16:18:07.586
these asserts, we're going to
catch those errors and we're

16012
16:18:07.586 --> 16:18:09.586
going to reject and this is
going to be false. And this

16013
16:18:09.586 --> 16:18:12.586
whole test is gonna go ah, there
was an issue, we now have a

16014
16:18:12.586 --> 16:18:15.586
staging test that looks really
good here. Let's try

16015
16:18:15.586 --> 16:18:22.586
this out. Let's try our staging
test out from start to finish.

16016
16:18:23.586 --> 16:18:27.586
So now in order for us to test
this staging test, from end to

16017
16:18:27.586 --> 16:18:30.586
end, you first going to need to
get our sub ID for the

16018
16:18:30.586 --> 16:18:32.586
channeling fear F then we're
going to need to deploy our

16019
16:18:32.586 --> 16:18:35.586
contract using the sub ID, we're
going to need to register the

16020
16:18:35.586 --> 16:18:39.586
contract with chain link VRF.
And it's somebody we're going to

16021
16:18:39.586 --> 16:18:42.586
then need to register it with
chain link keepers. And then of

16022
16:18:42.586 --> 16:18:45.586
course, we're going to run the
staging tests. So let's do it.

16023
16:18:45.586 --> 16:18:48.586
So first thing we're going to
need to do is what? Get our sub

16024
16:18:48.586 --> 16:18:51.586
ID for chain link VRF. Okay,
great. So we're going to come

16025
16:18:51.586 --> 16:18:54.586
over to VRF dot chain dot link.
And we're going to need to

16026
16:18:54.586 --> 16:18:58.586
create a new subscription. If we
don't have enough rink B eath.

16027
16:18:58.586 --> 16:19:02.586
Let's we want to head over to
the full blockchain solidity

16028
16:19:02.586 --> 16:19:05.586
course, here, we're going to
scroll down. And we're going to

16029
16:19:05.586 --> 16:19:08.586
look for the recommended test
and here, which is ranked v. And

16030
16:19:08.586 --> 16:19:11.586
we're going to use the faucets
link to get some Rigby link, run

16031
16:19:11.586 --> 16:19:15.586
Fosses dot chain dot link, let's
switch over from COVID to a

16032
16:19:15.586 --> 16:19:18.587
cerium. Rigby, we know we're
going to need some link and some

16033
16:19:18.587 --> 16:19:23.587
eath. So let's just go ahead and
get both. Alright, great now

16034
16:19:23.587 --> 16:19:26.587
that our transaction has gone
through, let's just double check

16035
16:19:26.587 --> 16:19:30.587
our wallet here. And it looks
like we do indeed have Ethereum

16036
16:19:30.587 --> 16:19:33.587
here. And if you don't see the
link, you can head over to link

16037
16:19:33.587 --> 16:19:35.587
token contracts, Link token
contracts in the chain link

16038
16:19:35.587 --> 16:19:39.587
documentation. We'll scroll down
to Rigby, we'll grab this

16039
16:19:39.587 --> 16:19:43.587
contract address import tokens
and we'll paste it in here. Add

16040
16:19:43.587 --> 16:19:48.587
Custom tokens, import tokens.
Great. Now I can see my eath and

16041
16:19:48.587 --> 16:19:51.587
my link here, perfect. We have
some eath we have some link,

16042
16:19:51.587 --> 16:19:53.587
let's head over to V REF
subscription management. And

16043
16:19:53.587 --> 16:19:56.587
we're going to create a new
subscription. Again, we could

16044
16:19:56.587 --> 16:19:58.587
totally do this
programmatically, because the

16045
16:19:58.587 --> 16:20:02.587
user interface here is only
helping us facilitate call

16046
16:20:02.587 --> 16:20:05.587
contracts to the registration
contract that's completely

16047
16:20:05.587 --> 16:20:07.587
decentralized and on chain. So
let's go ahead and create

16048
16:20:07.587 --> 16:20:10.587
subscription will create
subscription will confirm the

16049
16:20:10.587 --> 16:20:14.587
transaction and Metamask on the
Rinkeby network will do a little

16050
16:20:14.587 --> 16:20:17.587
bit of wading in great once it's
gone through, you can go ahead

16051
16:20:17.587 --> 16:20:20.587
and click the add funds button.
I'm going to show you what it

16052
16:20:20.587 --> 16:20:23.587
looks like if you accidentally
refresh and jump off though. So

16053
16:20:23.587 --> 16:20:26.587
if you refresh and you go back
to veer off the chain dot link,

16054
16:20:26.587 --> 16:20:29.587
you should have a new active
subscription. And you'll see

16055
16:20:29.587 --> 16:20:33.587
this number here. If you click
on it, this is your subscription

16056
16:20:33.587 --> 16:20:38.587
ID great. So we can actually
take this, come back to our code

16057
16:20:38.587 --> 16:20:41.587
into our helper Hardhead config.
And we can paste our

16058
16:20:41.587 --> 16:20:45.587
subscription ID under
subscription ID for our Rinkeby

16059
16:20:45.587 --> 16:20:49.587
network here. Awesome. Now that
we have a subscription we can

16060
16:20:49.587 --> 16:20:52.587
see it's not funded with any
link. So we don't have any

16061
16:20:52.587 --> 16:20:55.587
Oracle gas here. And we don't
have any consumers. Right our

16062
16:20:55.587 --> 16:20:59.588
consumer is going to be a raffle
or a lottery contract. So let's

16063
16:20:59.588 --> 16:21:02.588
add some funds first and we
don't need to add A whole lot

16064
16:21:02.588 --> 16:21:05.588
because we're only going to be
testing once. So let's go just

16065
16:21:05.588 --> 16:21:08.588
go ahead and add to link here,
this number might change

16066
16:21:08.588 --> 16:21:10.588
depending on different costs of
the test nets and how much link

16067
16:21:10.588 --> 16:21:13.588
token there's available. So if
you're actually working on a

16068
16:21:13.588 --> 16:21:16.588
main net, be sure to head over
Doc's touching that link EVM

16069
16:21:16.588 --> 16:21:20.588
chains contract addresses, you
can read more about the costs

16070
16:21:20.588 --> 16:21:22.588
some of these different chains,
so you can figure out exactly

16071
16:21:22.588 --> 16:21:25.588
how much to put in here. And if
you go to the full blockchain

16072
16:21:25.588 --> 16:21:29.588
solidity course, Jas, we can
scroll down to Lesson Nine,

16073
16:21:29.588 --> 16:21:33.588
there's a recommended link
amounts or rinky saving tests

16074
16:21:33.588 --> 16:21:35.588
for chain link VRF. For now
we're going to put two for

16075
16:21:35.588 --> 16:21:37.588
keepers, we're going to put
eight, but feel free to refer to

16076
16:21:37.588 --> 16:21:40.588
here so you know how much to put
in. So let's go ahead and

16077
16:21:40.588 --> 16:21:43.588
confirm, we're going to approve
adding funds here, go ahead and

16078
16:21:43.588 --> 16:21:47.588
confirm. And we're now funding
our subscription to so we can

16079
16:21:47.588 --> 16:21:50.588
pay that Oracle gas to get our
random numbers. Great. And once

16080
16:21:50.588 --> 16:21:53.588
we're funded, we can close it,
we'll do a little refresh. And

16081
16:21:53.588 --> 16:21:56.588
we can see the balance is now to
link when we don't have any

16082
16:21:56.588 --> 16:22:01.588
consumers perfect. So we've got
our sub ID, we funded it. Now

16083
16:22:01.588 --> 16:22:05.588
let's go ahead and deploy our
contract. And we already know

16084
16:22:05.588 --> 16:22:08.588
that we should be all good for
deploying our contract, we go to

16085
16:22:08.588 --> 16:22:12.588
our Dotty and V will need to add
all of those same parameters

16086
16:22:12.588 --> 16:22:14.588
from our previous projects,
we'll need to shrink the RPC

16087
16:22:14.588 --> 16:22:18.588
URL, we'll need our private key.
If we want to verify we'll need

16088
16:22:18.588 --> 16:22:22.588
our ether scan API key. And if
we want to do gas output, we'll

16089
16:22:22.588 --> 16:22:25.588
need our coin market cap API
key. So let's make sure we have

16090
16:22:25.588 --> 16:22:28.588
all that. And we'll look at our
deploy script. Once again, just

16091
16:22:28.588 --> 16:22:31.588
real quick look at our helper
hardcat config just real quick,

16092
16:22:31.588 --> 16:22:34.588
and it looks like we do indeed
have everything in here. And we

16093
16:22:34.588 --> 16:22:40.589
should just be able to deploy it
in one command.

16094
16:22:40.589 --> 16:22:44.589
So we should be able to do yarn,
hard hat or just h h again,

16095
16:22:44.589 --> 16:22:51.589
ploy, dash dash network Rinkeby.
Let's go try this out. All

16096
16:22:51.589 --> 16:22:53.589
right, it looks like we've
compiled successfully, we've

16097
16:22:53.589 --> 16:22:57.589
deployed it successfully. And
we've even verified it, we can

16098
16:22:57.589 --> 16:23:00.589
go and open it up on Rinku ether
scan. And we can see our code

16099
16:23:00.589 --> 16:23:04.589
here has been verified. And it's
looking beautiful. We can read

16100
16:23:04.589 --> 16:23:07.589
from it, which is great. We can
see all these commands here now

16101
16:23:07.589 --> 16:23:09.589
that it's verified. And if we
look at the Git raffle state, we

16102
16:23:09.589 --> 16:23:12.589
should indeed see that it's
open, right, and it's going to

16103
16:23:12.589 --> 16:23:16.589
stay open until somebody ends
the raffle and updates the

16104
16:23:16.589 --> 16:23:19.589
amount of eath that the contract
actually has. Now that we've

16105
16:23:19.589 --> 16:23:22.589
deployed a contract using that
sub ID, we need to register the

16106
16:23:22.589 --> 16:23:25.589
contract with chain link V REF.
And with chain link keepers. So

16107
16:23:25.589 --> 16:23:29.589
we need to add this consumer
does tell chinley VRF. Hey, this

16108
16:23:29.589 --> 16:23:31.589
is the contract that you're
looking for now. So we're gonna

16109
16:23:31.589 --> 16:23:34.589
go back to V REF dot chain dot
link, and we're going to grab

16110
16:23:34.589 --> 16:23:38.589
this contract address, and we're
going to add it as a consumer,

16111
16:23:38.589 --> 16:23:40.589
your subscription is ready, you
can now add consumers we're

16112
16:23:40.589 --> 16:23:43.589
gonna add consumer. And again,
this website is just here to

16113
16:23:43.589 --> 16:23:47.589
help facilitate us interacting
with the contract. So we're

16114
16:23:47.589 --> 16:23:49.589
going to approve that user,
we'll go ahead and confirm and

16115
16:23:49.589 --> 16:23:52.589
the transaction is going
through. While we wait for this

16116
16:23:52.589 --> 16:23:56.589
to go through, we can go to
keepers dot chain dot link, and

16117
16:23:56.589 --> 16:23:59.589
do the same thing work with the
user interface to register a new

16118
16:23:59.589 --> 16:24:04.589
upkeep. So we'll go ahead and
add our email Hardhead free code

16119
16:24:04.589 --> 16:24:09.589
camp@gmail.com. We'll call this
raffle upkeep. We'll paste our

16120
16:24:09.589 --> 16:24:13.589
upkeep address in here we have
our admin address, and you can

16121
16:24:13.589 --> 16:24:16.589
ignore this bit right here. For
gas limit, this is going to be

16122
16:24:16.589 --> 16:24:19.590
the gas limit of the PErforM
upkeep function. If we did our

16123
16:24:19.590 --> 16:24:22.590
gas estimator, we could just
check to see how much that

16124
16:24:22.590 --> 16:24:25.590
perform upkeep costs. But for
now, I'm just going to put

16125
16:24:25.590 --> 16:24:29.590
500,000 That's probably
overkill, but that's fine. Check

16126
16:24:29.590 --> 16:24:32.590
data, we're going to keep blank
because again, our checkup keep

16127
16:24:32.590 --> 16:24:35.590
doesn't take anything. And then
starting balance, we're going to

16128
16:24:35.590 --> 16:24:38.590
put as eight. And if you forget
to put a starting balance here,

16129
16:24:38.590 --> 16:24:42.590
you can always find it later. So
let's go ahead and register,

16130
16:24:42.590 --> 16:24:45.590
we're gonna get a Metamask pop
up, we're gonna go ahead and hit

16131
16:24:45.590 --> 16:24:50.590
Confirm. And we can go back to
our VRF and see that it's indeed

16132
16:24:50.590 --> 16:24:53.590
been added and awesome, we now
have a consumer on our VRF. So

16133
16:24:53.590 --> 16:24:55.590
now let's just wait for our
keepers to go through upkeep

16134
16:24:55.590 --> 16:24:59.590
registration requests submitted
successfully on domain net, you

16135
16:24:59.590 --> 16:25:02.590
might actually have to wait a
little bit for your request to

16136
16:25:02.590 --> 16:25:04.590
go through, but I'll test that
it should automatically go

16137
16:25:04.590 --> 16:25:08.590
through. Now if we go back to
keepers dot chain dot link, we

16138
16:25:08.590 --> 16:25:12.590
should now see we now if we
scroll down to my upkeeps We

16139
16:25:12.590 --> 16:25:15.590
have a raffle upkeep here and I
have to because I accidentally

16140
16:25:15.590 --> 16:25:18.590
use the same account that I
tested on, you can ignore the

16141
16:25:18.590 --> 16:25:21.590
two you'll have one but this is
the one that we just created.

16142
16:25:21.590 --> 16:25:24.590
And we can actually see what our
balances and then what the

16143
16:25:24.590 --> 16:25:26.590
minimum balance for this
actually is. So it looks like

16144
16:25:26.590 --> 16:25:30.590
eight Link was a little bit too
low. So let's go back to Fosses

16145
16:25:30.590 --> 16:25:35.590
dot chain dot link slash rinky.
Now that we have some more link,

16146
16:25:35.590 --> 16:25:38.590
we can come back to our raffle
upkeep. And we go ahead and hit

16147
16:25:38.590 --> 16:25:43.590
add funds. And we'll add just
three. And we'll go ahead and

16148
16:25:43.590 --> 16:25:47.590
confirm we first need to give
permission to spend. We approved

16149
16:25:47.590 --> 16:25:50.590
our link transfer now let's
actually transfer the link to

16150
16:25:50.590 --> 16:25:53.590
the contract and alright funds
added successfully. So now let's

16151
16:25:53.590 --> 16:25:56.590
do a little refresh. Now we no
longer see that message saying

16152
16:25:56.590 --> 16:25:59.591
that it's underfunded and we
have our balance and we can see

16153
16:25:59.591 --> 16:26:02.591
that it's more than the minimum
balance. We have See the history

16154
16:26:02.591 --> 16:26:05.591
that we just funded this twice.
Once this actually kicks off,

16155
16:26:05.591 --> 16:26:09.591
we'll see activity type will be
like perform upkeep or something

16156
16:26:09.591 --> 16:26:12.591
got our sub ID, we've deployed
the contract, we've registered

16157
16:26:12.591 --> 16:26:14.591
with chain link V REF, we've
registered it with chain link

16158
16:26:14.591 --> 16:26:18.591
keepers. Now all we need to do
is run the staging tests. Now

16159
16:26:18.591 --> 16:26:20.591
running our staging test is
essentially going to be the same

16160
16:26:20.591 --> 16:26:24.591
as us calling this enter script,
right, because all we're doing

16161
16:26:24.591 --> 16:26:27.591
in our staging test is entering
the lottery. And then we just

16162
16:26:27.591 --> 16:26:29.591
have a whole bunch of validators
that we're running to make sure

16163
16:26:29.591 --> 16:26:33.591
that things are doing as we
expect, since our contract is

16164
16:26:33.591 --> 16:26:37.591
actually verified, what we could
do on Rigby ether scan is we can

16165
16:26:37.591 --> 16:26:39.591
actually go to this right
contract section of the

16166
16:26:39.591 --> 16:26:44.591
contract. And we could even
connect our wallets to it. And

16167
16:26:44.591 --> 16:26:48.591
once this turns from red to
green, after a little refresh,

16168
16:26:48.591 --> 16:26:51.591
we'll now see that it's green,
it's connected, we can even call

16169
16:26:51.591 --> 16:26:55.591
functions on this contract
ourself, so we could enter the

16170
16:26:55.591 --> 16:26:58.591
raffle ourself, we would add,
you know, however much eath to

16171
16:26:58.591 --> 16:27:01.591
enter the raffle, and that would
kick off the keepers in the VRF,

16172
16:27:01.591 --> 16:27:03.591
as well. So we could call it via
ether scan, we could obviously

16173
16:27:03.591 --> 16:27:06.591
call it via our staging tests
here, we could call it via our

16174
16:27:06.591 --> 16:27:09.591
scripts, we could call it via
the console, there's a ton of

16175
16:27:09.591 --> 16:27:12.591
ways to actually do this. But
moment of truth here, we're

16176
16:27:12.591 --> 16:27:15.591
gonna run our staging tests,
which is going to have us enter

16177
16:27:15.591 --> 16:27:19.591
the lottery, and set up a
listener to make sure that

16178
16:27:19.591 --> 16:27:23.591
everything works correctly. And
additionally, we'll see on our

16179
16:27:23.591 --> 16:27:26.591
raffle upkeep history, we'll see
a transaction go through, and

16180
16:27:26.591 --> 16:27:30.591
then we'll see a transaction on
our chain like VRF as well. Are

16181
16:27:30.591 --> 16:27:32.591
you ready? I sure am.

16182
16:27:32.591 --> 16:27:40.592
Let's do this. So we'll do h h,
test, dash dash network, rink B.

16183
16:27:40.592 --> 16:27:43.592
And that should be all we need
to do. In our state and tests,

16184
16:27:43.592 --> 16:27:46.592
we probably should have added
some console dot logs in here to

16185
16:27:46.592 --> 16:27:49.592
tell us hey, to tell us what
steps that we're on with each.

16186
16:27:49.592 --> 16:27:52.592
But we forgot to. So if you
follow along with the repo

16187
16:27:52.592 --> 16:27:55.592
associated with this, we've
added the console dot logs in

16188
16:27:55.592 --> 16:27:58.592
the test there. But all right,
if we go to the ether scan for

16189
16:27:58.592 --> 16:28:01.592
this contract, we go back to the
rink the ether scan for this, we

16190
16:28:01.592 --> 16:28:04.592
paste in that address, the first
step that we're doing in this

16191
16:28:04.592 --> 16:28:08.592
test, of course, while we're
setting up this listener, the

16192
16:28:08.592 --> 16:28:11.592
first transaction is going to be
entering the raffle that's going

16193
16:28:11.592 --> 16:28:13.592
to kick everything off. Right.
So if we refresh a little bit on

16194
16:28:13.592 --> 16:28:17.592
ether scan, we do indeed see
we've entered the raffle. And

16195
16:28:17.592 --> 16:28:22.592
we've updated the balance of the
raffle. Okay, awesome. So raffle

16196
16:28:22.592 --> 16:28:26.592
has been entered. Now then what
happens? Well, if the raffle has

16197
16:28:26.592 --> 16:28:30.592
been entered, if we go to raffle
dot soul, if it's open, if

16198
16:28:30.592 --> 16:28:32.592
enough time has passed, if
there's players and it has a

16199
16:28:32.592 --> 16:28:36.592
balance, which we just checked
does, this will get kicked off

16200
16:28:36.592 --> 16:28:39.592
by the keepers. So if we go to
the keepers, and we do a little

16201
16:28:39.592 --> 16:28:43.592
refresh here, after a little
bit, we do indeed see checkup

16202
16:28:43.592 --> 16:28:46.592
key passed and we see a perform
upkeep having gone through

16203
16:28:46.592 --> 16:28:50.592
great, what does perform upkeep
to well perform upkeep calls the

16204
16:28:50.592 --> 16:28:55.592
chainlink VRF. So now if we go
over to chainlink, VRF, we do a

16205
16:28:55.592 --> 16:28:59.592
refresh here, go down to
history, we do indeed see one of

16206
16:28:59.592 --> 16:29:02.592
the transactions has gone
through we can see the

16207
16:29:02.592 --> 16:29:05.592
transaction hash, the link
spent, etc. And now if we go

16208
16:29:05.592 --> 16:29:08.592
back to our tests, we do indeed
see raffle unit tests for friend

16209
16:29:08.592 --> 16:29:12.592
fulfill random request winner
pick event fired. And this means

16210
16:29:12.592 --> 16:29:16.592
that we just went through this
entire process of having a

16211
16:29:16.592 --> 16:29:20.593
perfectly truly decentralized
raffle work on an actual

16212
16:29:20.593 --> 16:29:22.593
Testament with our integration
tests working correctly.

16213
16:29:22.593 --> 16:29:25.593
Absolutely massive, huge
congratulations if you've made

16214
16:29:25.593 --> 16:29:27.593
it this far. And if you just
walk through the integration

16215
16:29:27.593 --> 16:29:30.593
test with me now bounce over
contract has now been reset to

16216
16:29:30.593 --> 16:29:33.593
zero because our wallet address
just won the lottery right and

16217
16:29:33.593 --> 16:29:36.593
got the money back. Now you
might be wondering, Hey, I see

16218
16:29:36.593 --> 16:29:40.593
the Create raffle function. And
I see enter raffle but I don't

16219
16:29:40.593 --> 16:29:43.593
see didn't the chain link nodes
just call perform upkeep and

16220
16:29:43.593 --> 16:29:46.593
fulfill random words, I'll come
no matter how often I refresh, I

16221
16:29:46.593 --> 16:29:49.593
don't see those transactions
here. Well, those are actually

16222
16:29:49.593 --> 16:29:52.593
going to be considered internal
transactions fulfill random

16223
16:29:52.593 --> 16:29:55.593
words, it's actually called
through the VRF coordinator and

16224
16:29:55.593 --> 16:29:59.593
the VRF coordinator contract
then calls for full randomness.

16225
16:29:59.593 --> 16:30:03.593
So we can go to internal
transactions. And one of these

16226
16:30:03.593 --> 16:30:06.593
transactions is going to be the
transaction to the VRF

16227
16:30:06.593 --> 16:30:10.593
coordinator contract, which
calls our contract. Same thing

16228
16:30:10.593 --> 16:30:13.593
with perform upkeep. Perform
upkeep, the chain link nodes

16229
16:30:13.593 --> 16:30:16.593
actually call through the
registry contract and then the

16230
16:30:16.593 --> 16:30:19.593
registry contract calls perform
upkeep. That's what we see here.

16231
16:30:19.593 --> 16:30:22.593
And if we go through the
internal transactions, we'll see

16232
16:30:22.593 --> 16:30:25.593
him there. Now let's look at
this enter raffle as well. And

16233
16:30:25.593 --> 16:30:28.593
since we've learned about events
and logs, we can actually go to

16234
16:30:28.593 --> 16:30:33.593
the logs section now. And we can
see our log or event being

16235
16:30:33.593 --> 16:30:37.593
emitted here we can see the name
raffle, enter, we can see the

16236
16:30:37.593 --> 16:30:40.593
topic zero which is going to
identify this entire event. And

16237
16:30:40.593 --> 16:30:44.593
then we also see this number
here which is what which is

16238
16:30:44.593 --> 16:30:48.593
index topic, one address player
and then there's no data

16239
16:30:48.593 --> 16:30:50.593
associated with this right
because we only have index

16240
16:30:50.593 --> 16:30:54.593
parameters which again show up
as topics so this is absolutely

16241
16:30:54.593 --> 16:31:01.594
phenomenal. Wow, absolutely
massive and we can rerun a unit

16242
16:31:01.594 --> 16:31:06.594
test Just by hh test in this
will only run our unit tests.

16243
16:31:06.594 --> 16:31:08.594
And we can see that these are
all passing as well, things are

16244
16:31:08.594 --> 16:31:12.594
looking fantastic here. And we
have just successfully created a

16245
16:31:12.594 --> 16:31:17.594
verifiably random, autonomous,
decentralized, raffle and or

16246
16:31:17.594 --> 16:31:21.594
lottery deployed on the
blockchain, you should be so

16247
16:31:21.594 --> 16:31:24.594
excited right now. Now, I'm not
going to show you how to push

16248
16:31:24.594 --> 16:31:26.594
this up to GitHub. However, if
you want to push this up to get

16249
16:31:26.594 --> 16:31:30.594
up, and again, tweet at me,
tweet at chainlink tweet at Free

16250
16:31:30.594 --> 16:31:33.594
Code Camp, please feel free to
do so because you just did an

16251
16:31:33.594 --> 16:31:36.594
amazing job getting this far.
And if you're gonna want to push

16252
16:31:36.594 --> 16:31:38.594
this up to GitHub, remember,
we're going to want to put a dot

16253
16:31:38.594 --> 16:31:42.594
Git ignore. In here, we add a
ton of stuff like that VS code

16254
16:31:42.594 --> 16:31:46.594
artifacts, cash deployments,
known modules, etc. Type chain

16255
16:31:47.594 --> 16:31:51.594
types, all this stuff, you can
find a sample dot Git ignore, of

16256
16:31:51.594 --> 16:31:54.594
course, in the GitHub repo
associated with this, this is an

16257
16:31:54.594 --> 16:31:58.594
advanced project, we did a lot
of really advanced things here.

16258
16:31:58.594 --> 16:32:03.594
And this is the section of the
course, where I think at this

16259
16:32:03.594 --> 16:32:06.594
point, you've got most of the
fundamentals down. And now we're

16260
16:32:06.594 --> 16:32:08.594
going to move into more front
end. And we're going to move

16261
16:32:08.594 --> 16:32:11.594
into more industry specific and
more advanced topics that are

16262
16:32:11.594 --> 16:32:15.594
really going to supercharge you
and make you one of the masters

16263
16:32:15.594 --> 16:32:17.594
of the blockchain in the smart
contract realm. So huge

16264
16:32:17.594 --> 16:32:20.594
congratulations, one more time,
definitely go celebrate,

16265
16:32:20.594 --> 16:32:22.594
definitely go for that walk,
take a quick break, let

16266
16:32:22.594 --> 16:32:25.594
everything we just learned
settling your brain and get

16267
16:32:25.594 --> 16:32:39.595
ready for the next one.

16268
16:32:39.595 --> 16:32:43.595
Alright, now we're gonna go over
the TypeScript edition of this

16269
16:32:43.595 --> 16:32:46.595
lesson, we're gonna go a little
bit quickly here, because we're

16270
16:32:46.595 --> 16:32:49.595
not learning too much new stuff
for this TypeScript edition. So

16271
16:32:49.595 --> 16:32:51.595
if you want to just follow
along, you can open up the repo

16272
16:32:51.595 --> 16:32:55.595
here and use the TypeScript
branch. One thing to note that

16273
16:32:55.595 --> 16:32:58.595
is a little bit different is
when we do our promise in our

16274
16:32:58.595 --> 16:33:01.595
tests, we're doing a weight
promise void, because we're not

16275
16:33:01.595 --> 16:33:04.595
going to be returning anything
with our promise here. But the

16276
16:33:04.595 --> 16:33:07.595
rest is going to be exactly the
same. We're going to have a hard

16277
16:33:07.595 --> 16:33:10.595
hat dot config to TypeScript
that's going to use imports.

16278
16:33:10.595 --> 16:33:13.595
Once again, everything else is
pretty much the same. We're

16279
16:33:13.595 --> 16:33:17.595
going to export the config like
we did last time. In our package

16280
16:33:17.595 --> 16:33:20.595
dot JSON. Of course, we're going
to have all of our TypeScript

16281
16:33:20.595 --> 16:33:23.595
dependencies as well. And then
our deploy scripts are going to

16282
16:33:23.595 --> 16:33:26.595
follow that same functionality
that we've used before. So now

16283
16:33:26.595 --> 16:33:30.595
our deploy scripts use a type
deploy function on our variables

16284
16:33:30.595 --> 16:33:34.595
that we export at the bottom.
And we also import the hard hat

16285
16:33:34.595 --> 16:33:37.595
runtime environment type, which
where we pull the deployments

16286
16:33:37.595 --> 16:33:40.595
get named account and networks
from in our tests. Of course,

16287
16:33:40.595 --> 16:33:44.595
we're still importing the types
of these contracts from type

16288
16:33:44.595 --> 16:33:47.595
chain slash types, like you see
here, like for example, raffle

16289
16:33:47.595 --> 16:33:51.595
is going to be signed to raffle
VRF coordinator V to mock is

16290
16:33:51.595 --> 16:33:54.595
going to be signed to type VRF
coordinator V to MK and if we

16291
16:33:54.595 --> 16:33:57.595
wanted to deploy with these
contract factories, we could as

16292
16:33:57.595 --> 16:33:59.595
well. So those are going to be
the main differences with

16293
16:33:59.595 --> 16:34:02.595
TypeScript. There's not anything
really new there. But again, if

16294
16:34:02.595 --> 16:34:04.595
you want to follow along with
TypeScript, and you want to code

16295
16:34:04.595 --> 16:34:10.595
everything in TypeScript, and
example is here for you

16296
16:34:10.595 --> 16:34:13.595
All right, welcome back. I hope
your break was absolutely

16297
16:34:13.595 --> 16:34:18.595
fantastic because now we are
getting into more advanced full

16298
16:34:18.595 --> 16:34:21.596
stack slash front end
development. We've done the back

16299
16:34:21.596 --> 16:34:24.596
end development, we've created
smart contracts, we created our

16300
16:34:24.596 --> 16:34:28.596
lottery. In our last section, we
have all this wonderful code

16301
16:34:28.596 --> 16:34:32.596
that allows us to work with our
own provably decentralized

16302
16:34:32.596 --> 16:34:35.596
lottery. In order for regular
everyday people to use our

16303
16:34:35.596 --> 16:34:39.596
lottery, we're going to need to
build a front end. Now

16304
16:34:39.596 --> 16:34:42.596
previously, we learned to build
a front end with raw HTML

16305
16:34:42.596 --> 16:34:46.596
JavaScript, with our Funmi
project, we created a front end

16306
16:34:46.596 --> 16:34:49.596
with just pure HTML and
JavaScript, just creating

16307
16:34:49.596 --> 16:34:51.596
applications with HTML and
JavaScript is great. And if

16308
16:34:51.596 --> 16:34:55.596
that's what you want to do, you
absolutely can. But doing it

16309
16:34:55.596 --> 16:34:58.596
with those vanilla protocols has
some limitations. And working

16310
16:34:58.596 --> 16:35:00.596
with a framework, like what
we're going to be working with

16311
16:35:00.596 --> 16:35:04.596
in this section is going to make
our lives a lot easier, we're

16312
16:35:04.596 --> 16:35:06.596
going to be able to develop
quicker, have more

16313
16:35:06.596 --> 16:35:10.596
functionality, and do more in
less time. As you remember back

16314
16:35:10.596 --> 16:35:13.596
to the project wasn't really a
fleshed out project, if you

16315
16:35:13.596 --> 16:35:16.596
remember, it was just a bunch of
buttons. And that was really it.

16316
16:35:16.596 --> 16:35:19.596
So working with a framework is
really going to enable us to put

16317
16:35:19.596 --> 16:35:23.596
more features and add more
styling to our applications

16318
16:35:23.596 --> 16:35:27.596
really easy. Once again, the
code for this entire section is

16319
16:35:27.596 --> 16:35:30.596
located in our lesson and is
located in this GitHub

16320
16:35:30.596 --> 16:35:33.596
repository associated with the
course. Now I have to put an

16321
16:35:33.596 --> 16:35:36.596
asterisk here, as I've said many
times, the front end sections of

16322
16:35:36.596 --> 16:35:39.596
this course are not required,
we're not going to learn

16323
16:35:39.596 --> 16:35:43.596
anything new about the back end
in this front end section. So if

16324
16:35:43.596 --> 16:35:45.596
you don't care about building
websites, all you want to do is

16325
16:35:45.596 --> 16:35:49.596
learn the smart contract aspect
of this course, you can skip

16326
16:35:49.596 --> 16:35:51.596
these sections. But if you do
want to learn how to build these

16327
16:35:51.596 --> 16:35:55.596
front end applications, if you
do want to give users and non

16328
16:35:55.596 --> 16:35:57.596
developers the abilities to
interact with our smart

16329
16:35:57.596 --> 16:36:00.597
contracts, then please continue
to watch. Now I also have to put

16330
16:36:00.597 --> 16:36:03.597
an asterix here, because if you
haven't worked with some of

16331
16:36:03.597 --> 16:36:06.597
these frameworks before, the
learning curve can seem a little

16332
16:36:06.597 --> 16:36:09.597
bit steep. And as I've said many
times, this isn't going to be a

16333
16:36:09.597 --> 16:36:12.597
front end course that would take
several more hours than what we

16334
16:36:12.597 --> 16:36:14.597
want to do for this video. So if
you've never done front end

16335
16:36:14.597 --> 16:36:18.597
before, this is one of the
sections where I do recommend

16336
16:36:18.597 --> 16:36:21.597
you follow along with one of
these optional sub lessons,

16337
16:36:21.597 --> 16:36:23.597
we're not going to play them
here. But if you follow along

16338
16:36:23.597 --> 16:36:25.597
with one of these sub lessons,
that will definitely be

16339
16:36:25.597 --> 16:36:28.597
incredibly helpful. One of the
videos that I have for the sub

16340
16:36:28.597 --> 16:36:31.597
lessons is this video right
here, how to connect your smart

16341
16:36:31.597 --> 16:36:35.597
contracts to Metamask. And it
shows a number of ways

16342
16:36:35.597 --> 16:36:37.597
connecting your smart contracts
and building kind of these these

16343
16:36:37.597 --> 16:36:41.597
front ends. It does start with a
raw HTML and JavaScript edition.

16344
16:36:41.597 --> 16:36:44.597
So you can really get some more
practice in here with HTML and

16345
16:36:44.597 --> 16:36:47.597
JavaScript. And then it moves to
index js ethers and a few other

16346
16:36:47.597 --> 16:36:50.597
next Jas based applications.
Doing it a few different ways

16347
16:36:50.597 --> 16:36:53.597
will install a new some more
insight on what you should be

16348
16:36:53.597 --> 16:36:56.597
thinking about when you're
approaching these. So this is

16349
16:36:56.597 --> 16:36:58.597
absolutely a video to watch if
you're new to front end

16350
16:36:59.597 --> 16:37:01.597
development. Additionally, for
this section, like I said, we're

16351
16:37:01.597 --> 16:37:03.597
going to be using a framework.
And in particular, we're going

16352
16:37:03.597 --> 16:37:07.597
to be using the next Jas
framework. Now. Next, Jas is a

16353
16:37:07.597 --> 16:37:11.597
react based framework. React is
a framework for building front

16354
16:37:11.597 --> 16:37:14.597
end and full stack applications.
Next, Jas is a framework on top

16355
16:37:14.597 --> 16:37:17.597
of the React framework. So if
you already know react, most of

16356
16:37:17.597 --> 16:37:20.597
this is going to come very
naturally to the reason that

16357
16:37:20.597 --> 16:37:24.597
we're using React in next Jas is
because React is easily as of

16358
16:37:24.597 --> 16:37:27.597
right now one of the most
popular frameworks and languages

16359
16:37:27.597 --> 16:37:30.597
out there. And it's no surprise
why we've got a little article

16360
16:37:30.597 --> 16:37:33.597
in the GitHub repo titled Why
you should use React js for web

16361
16:37:33.597 --> 16:37:36.597
development, which we'll go into
a little bit more. Some of the

16362
16:37:36.597 --> 16:37:38.597
biggest applications like
Facebook and Instagram use React

16363
16:37:38.597 --> 16:37:42.598
js and a number of other Fortune
500 companies and React js

16364
16:37:42.598 --> 16:37:46.598
especially in the blockchain
space is easily the most popular

16365
16:37:46.598 --> 16:37:49.598
with protocols like uniswap, and
Avi also using React Jas. Now

16366
16:37:49.598 --> 16:37:53.598
the reason we're using this next
Jas on top of React Jas is that

16367
16:37:53.598 --> 16:37:58.598
next Jas, I think makes working
with react much easier. And I

16368
16:37:58.598 --> 16:38:01.598
want us to work with the easiest
and most powerful framework out

16369
16:38:01.598 --> 16:38:04.598
there. Next, Jas is also getting
a ton of steam has some really

16370
16:38:04.598 --> 16:38:09.598
advanced but in my mind easier
to use features than just raw

16371
16:38:09.598 --> 16:38:11.598
react. Now, like I said, if
you've never worked with React

16372
16:38:11.598 --> 16:38:14.598
before, if you've never worked
with next Jas before, and you

16373
16:38:14.598 --> 16:38:16.598
want to do a little brush up,
definitely watch my video six

16374
16:38:16.598 --> 16:38:19.598
ways to connect your depth to a
wallet. And if you find yourself

16375
16:38:19.598 --> 16:38:21.598
struggling with with this
section, because the front end

16376
16:38:21.598 --> 16:38:25.598
stuff doesn't really make sense.
We also have a next Jas crash

16377
16:38:25.598 --> 16:38:28.598
course in the GitHub repo
associated with this course.

16378
16:38:28.598 --> 16:38:30.598
It's about an hour long and it
is absolutely phenomenal. Free

16379
16:38:30.598 --> 16:38:34.598
Code Camp also has some next Jas
crash courses. So if you're

16380
16:38:34.598 --> 16:38:37.598
struggling with the front of it,
go take it next Jas course, and

16381
16:38:37.598 --> 16:38:40.598
then come back to this section
or skip the front end sections

16382
16:38:40.598 --> 16:38:42.598
all together, do the rest of the
course of just the back end, and

16383
16:38:42.598 --> 16:38:45.598
then come back and do these
front end sections. We're going

16384
16:38:45.598 --> 16:38:48.598
to show you the cutting edge
ways to interact and work with

16385
16:38:48.598 --> 16:38:51.598
your front end and then also
deploy them. And if you follow

16386
16:38:51.598 --> 16:38:53.598
along correctly, by the end of
this, you'll have a website

16387
16:38:53.598 --> 16:38:56.598
deployed that you can show off
and you can send a link of it to

16388
16:38:56.598 --> 16:38:59.598
your friends. And now I know we
already showed you what this

16389
16:38:59.598 --> 16:39:01.598
looks like but I'm going to show
you it one more time just so we

16390
16:39:01.598 --> 16:39:04.598
can walk through and see exactly
what we're doing. So we're going

16391
16:39:04.598 --> 16:39:07.598
to have this decentralized
lottery where we can go ahead

16392
16:39:07.598 --> 16:39:10.598
with can connect our wallet if
not already connected. And we

16393
16:39:10.598 --> 16:39:13.598
can switch, we can switch around
between networks. And our app

16394
16:39:13.598 --> 16:39:16.598
will actually recognize it and
say, hey, the only supported

16395
16:39:16.598 --> 16:39:20.599
chains that we're working with
here are going to be 31337,

16396
16:39:20.599 --> 16:39:23.599
which is localhost, or four,
which is ring feed. And we'll

16397
16:39:23.599 --> 16:39:26.599
learn how to add this validation
into our application so that our

16398
16:39:26.599 --> 16:39:30.599
app only works when we're on a
chain that we want, then we can

16399
16:39:30.599 --> 16:39:33.599
go ahead and interact with it.
Normally, we can click a button

16400
16:39:33.599 --> 16:39:36.599
Metamask will pop up, we can go
ahead and confirm we'll get a

16401
16:39:36.599 --> 16:39:39.599
little transaction notification
saying that transaction is

16402
16:39:39.599 --> 16:39:43.599
complete. And we'll get our
front end updated. And then on

16403
16:39:43.599 --> 16:39:46.599
the back end, we'll be able to
see the chain link nodes and the

16404
16:39:46.599 --> 16:39:49.599
Chinuch V REF do their work. And
once they actually pick a

16405
16:39:49.599 --> 16:39:52.599
winner, after a refresh, we'll
be able to see that the back end

16406
16:39:52.599 --> 16:39:56.599
node was updated, we do indeed
have a previous winner. Awesome.

16407
16:39:56.599 --> 16:39:59.599
Now, not only that, we're going
to show you how to build this,

16408
16:39:59.599 --> 16:40:04.599
but also, we're going to show
you how to host it on an actual

16409
16:40:04.599 --> 16:40:07.599
site. So you'll be able to push
it up to your own blockchain.

16410
16:40:07.599 --> 16:40:11.599
And additionally, we're gonna
host it in a decentralized

16411
16:40:11.599 --> 16:40:14.599
context. So this site that we
have here is it's going to be

16412
16:40:14.599 --> 16:40:18.599
hosted on a technology that
allows us to host websites in

16413
16:40:18.599 --> 16:40:21.599
decentralized contexts as well
swore backends. And even our

16414
16:40:21.599 --> 16:40:25.599
front ends can be hosted in
decentralized context. So So I

16415
16:40:25.599 --> 16:40:27.599
hope you're incredibly excited
for this because we're going to

16416
16:40:27.599 --> 16:40:31.599
be showing you the cutting edge
tools that many of the top

16417
16:40:31.599 --> 16:40:37.599
blockchain projects use. And
let's just jump right into it.

16418
16:40:37.599 --> 16:40:40.599
Now, I'm currently in the
Hardhead smart contract lottery

16419
16:40:40.599 --> 16:40:43.599
project, the project that we
just did, we did this hard hat

16420
16:40:43.599 --> 16:40:45.599
smart contract lottery, which is
great. What we're going to do

16421
16:40:45.599 --> 16:40:48.599
now is we're going to create a
new folder, although we are

16422
16:40:48.599 --> 16:40:51.599
going to be coming back to this
folder from time to time to make

16423
16:40:51.599 --> 16:40:53.599
a couple of updates. So if you
want to keep it open, you

16424
16:40:53.599 --> 16:40:56.599
absolutely can. But for me, I'm
gonna go ahead and CD download

16425
16:40:56.599 --> 16:41:00.600
directory to kind of my main
directory for this whole course.

16426
16:41:00.600 --> 16:41:05.600
And we're going to create a new
directory called next Jas. smart

16427
16:41:05.600 --> 16:41:11.600
contract. Lottery, FCC, then
we're going to cd into next Jas

16428
16:41:11.600 --> 16:41:15.600
smart contract lottery FCC, and
go ahead and hit code period.

16429
16:41:15.600 --> 16:41:17.600
And like I said, if you want to
keep that one up and have this

16430
16:41:17.600 --> 16:41:21.600
new folder up, you absolutely
can. But basically, again, we're

16431
16:41:21.600 --> 16:41:24.600
just opening up our VS code in
this next Jas smart contract

16432
16:41:24.600 --> 16:41:27.600
lottery folder. Now for this
front end stuff, in particular,

16433
16:41:27.600 --> 16:41:30.600
if you want to be absolutely
sure you're using the same

16434
16:41:30.600 --> 16:41:33.600
versions as I am, what you can
do is you can git clone this

16435
16:41:33.600 --> 16:41:37.600
repo, and then copy the yarn dot
lock and package dot JSON, and

16436
16:41:37.600 --> 16:41:40.600
then run yarn, this will make
sure you're always using the

16437
16:41:40.600 --> 16:41:43.600
exact same packages that I'm
using, and you'll never run into

16438
16:41:43.600 --> 16:41:46.600
any weird issues. So if you do
run into an issue, one of the

16439
16:41:46.600 --> 16:41:49.600
first things to do, especially
for these front end parts is to

16440
16:41:49.600 --> 16:41:53.600
go back, make sure you have the
exact same yarn dot lock and

16441
16:41:53.600 --> 16:41:56.600
package that JSON that I do in
my examples here, and go from

16442
16:41:56.600 --> 16:41:59.600
there. Now we're here in our
front end project. And we're

16443
16:41:59.600 --> 16:42:02.600
going to create a website, we're
gonna create a front end for

16444
16:42:02.600 --> 16:42:05.600
application, like I said, we're
gonna be using next Jas, if you

16445
16:42:05.600 --> 16:42:08.600
want to follow along with the
next Jas documentation here,

16446
16:42:08.600 --> 16:42:10.600
they do have a great getting
started and walking through

16447
16:42:10.600 --> 16:42:17.600
this. So for us, we're going to
do yarn, create next app, and

16448
16:42:17.600 --> 16:42:19.600
then put a little period saying
we want our next app in this

16449
16:42:19.600 --> 16:42:22.600
directory. If you don't put this
period, it'll create it in a new

16450
16:42:22.600 --> 16:42:26.600
folder, and you'll have double
folders. Okay, awesome. So and

16451
16:42:26.600 --> 16:42:29.600
once we do this, in our little
files explorer section, we now

16452
16:42:29.600 --> 16:42:34.600
can see all the different files
that come boilerplate with this.

16453
16:42:34.600 --> 16:42:36.600
Now, let me just do a quick
walkthrough of what's going on

16454
16:42:36.600 --> 16:42:39.600
here. Again, we also go through
this in those two videos that I

16455
16:42:39.600 --> 16:42:42.601
recommended, but it doesn't hurt
to go over it twice. So node

16456
16:42:42.601 --> 16:42:44.601
modules, of course, is going to
be the package in the

16457
16:42:44.601 --> 16:42:47.601
installations pages is going to
be the different pages on our

16458
16:42:47.601 --> 16:42:50.601
site. Let me let me show you
what I mean by this. To run this

16459
16:42:50.601 --> 16:42:54.601
whole thing. Actually, we can
just run yarn, run Dev, and

16460
16:42:54.601 --> 16:42:58.601
we'll get started server on
blah, blah, blah, blah, blah,

16461
16:42:58.601 --> 16:43:01.601
you can command click it or copy
paste it into your browser. And

16462
16:43:01.601 --> 16:43:05.601
now you'll see on localhost
3000, we have our page up here.

16463
16:43:05.601 --> 16:43:09.601
Now what we can do, actually, so
index.js is going to be our

16464
16:43:09.601 --> 16:43:12.601
default page, which is, you
know, considered this slash

16465
16:43:12.601 --> 16:43:16.601
here. But what we can do is we
can create new pages. So I could

16466
16:43:16.601 --> 16:43:21.601
do new file, you know, dog dot
Jas. And then you know, just

16467
16:43:21.601 --> 16:43:25.601
copy paste index into dog to
Jas, paste it, delete everything

16468
16:43:25.601 --> 16:43:27.601
inside the div, you don't have
to follow along here and just go

16469
16:43:27.601 --> 16:43:34.601
Hi, save this, go back here. I
can now put in dog and get this.

16470
16:43:34.601 --> 16:43:37.601
So pages is going to be all kind
of these different routes to

16471
16:43:37.601 --> 16:43:40.601
these different spots on our
website. And index is going to

16472
16:43:40.601 --> 16:43:44.601
be our default, kind of like our
homepage. So I'm going to delete

16473
16:43:44.601 --> 16:43:47.601
Dardo. And inside these files is
going to be something called

16474
16:43:47.601 --> 16:43:51.601
react syntax or JSX. They come
as Jas but they're basically

16475
16:43:51.601 --> 16:43:54.601
reacts in text. Next, Jas is
based on React, you'll see these

16476
16:43:54.601 --> 16:43:59.601
pages are this weird combination
of both JavaScript and HTML. We

16477
16:43:59.601 --> 16:44:02.601
see some import stuff at this at
the top, which reminds us of

16478
16:44:02.601 --> 16:44:06.601
JavaScript and again, you'll see
some important stuff at the top

16479
16:44:06.601 --> 16:44:11.601
and then down here, you'll See,
like div head main h1 P, you'll

16480
16:44:11.601 --> 16:44:15.601
see all these like HTML tags
react index js allow us to do

16481
16:44:15.601 --> 16:44:20.602
this combination of JavaScript
and HTML. And it actually makes

16482
16:44:20.602 --> 16:44:24.602
life a lot easier. Now, you'll
also notice we're doing imports

16483
16:44:24.602 --> 16:44:27.602
in here. Remember, I told you
all this earlier, imports work

16484
16:44:27.602 --> 16:44:31.602
with our front end require does
not. So that's some of the

16485
16:44:31.602 --> 16:44:35.602
difference between node does not
equal JavaScript, right? This is

16486
16:44:35.602 --> 16:44:37.602
where the differences can start
getting a little bit confusing.

16487
16:44:37.602 --> 16:44:40.602
But the way that I usually like
to think about it is I just say,

16488
16:44:40.602 --> 16:44:45.602
no JS, excuse me, I'll just say
back end. I can J S is a little

16489
16:44:45.602 --> 16:44:49.602
different from front end. Yes.
So back end, Jas and front end

16490
16:44:49.602 --> 16:44:51.602
Jas are a little bit different.
That's kind of the way I like to

16491
16:44:51.602 --> 16:44:54.602
think about it. app.js is going
to be our entry point for

16492
16:44:54.602 --> 16:44:58.602
everything the way react and
next Jas work is everything is

16493
16:44:58.602 --> 16:45:01.602
what's called component based in
all of our files here, you're

16494
16:45:01.602 --> 16:45:05.602
gonna see this export default
function home or something along

16495
16:45:05.602 --> 16:45:10.602
those lines. What react and next
Jas do is they say, Hey, this

16496
16:45:10.602 --> 16:45:15.602
huge clump of HTML stuff that
has a hodgepodge of JavaScript

16497
16:45:15.602 --> 16:45:19.602
inside of it is considered a
component. And so all of our

16498
16:45:19.602 --> 16:45:24.602
pages get wrapped through this
underscore app.js page. So this

16499
16:45:24.602 --> 16:45:27.602
is a page but it's kind of like
the main entry point. And they

16500
16:45:27.602 --> 16:45:31.602
get stuck into this component
section of our app that Jas so

16501
16:45:31.602 --> 16:45:34.602
you can think of this on this
graph. The GS is kind of the

16502
16:45:34.602 --> 16:45:38.602
whole application or whole front
end. And on this homepage, this

16503
16:45:38.602 --> 16:45:41.602
component, we're sticking index
dot j s right in here, we're

16504
16:45:41.602 --> 16:45:44.602
swapping out component for index
dot J. S. Now API is what we

16505
16:45:44.602 --> 16:45:50.602
wanted to do if we wanted to do
like some HTTP, GET HTTP POST

16506
16:45:50.602 --> 16:45:52.602
requests, but we're not going to
do any of that. So we're going

16507
16:45:52.602 --> 16:45:55.602
to pretty much ignore API for
now public is just going to be

16508
16:45:56.602 --> 16:46:00.602
some public images like a
favicon or Versaille, that SVG

16509
16:46:00.602 --> 16:46:05.603
styles is going to be the CSS
for our project. CSS stands for

16510
16:46:05.603 --> 16:46:08.603
Cascading Style Sheets. And it's
basically a way to style your

16511
16:46:08.603 --> 16:46:11.603
HTML, we're going to change the
way we do styling and a little

16512
16:46:11.603 --> 16:46:14.603
bit, but that's basically what
these both do the ESLint I'm

16513
16:46:14.603 --> 16:46:17.603
dumping this right now we have
our dot Git ignore which we know

16514
16:46:17.603 --> 16:46:21.603
what it does. We have our next
dot config dot J. S. This is a

16515
16:46:21.603 --> 16:46:24.603
configuration file or next. Jas,
of course, we have our package

16516
16:46:24.603 --> 16:46:28.603
json, we have a readme, and we
have our yarn dot lock. So most

16517
16:46:28.603 --> 16:46:31.603
of what we're going to do is
actually going to be inside this

16518
16:46:31.603 --> 16:46:34.603
Pages folder. And we're also
going to create a couple other

16519
16:46:34.603 --> 16:46:37.603
folders that are going to be our
main stuff now, because I'm me,

16520
16:46:37.603 --> 16:46:39.603
and like I said, I love working
with prettier, I'm going to

16521
16:46:39.603 --> 16:46:43.603
automatically dump a prettier
RC, and a prettier ignore in

16522
16:46:43.603 --> 16:46:46.603
here, just so that I can format
my code a little bit nicer, you

16523
16:46:46.603 --> 16:46:49.603
can grab your prettier RC from
our last projects, you can grab

16524
16:46:49.603 --> 16:46:53.603
your prettier ignore as well. Or
you can just pause me right now

16525
16:46:53.603 --> 16:46:55.603
copy, paste them from the GitHub
repo associated with this

16526
16:46:55.603 --> 16:46:59.603
lesson, paste them in, and then
we'll do yarn, add dash dash

16527
16:46:59.603 --> 16:47:02.603
Dev, prettier, so that we can
auto format all of our code for

16528
16:47:02.603 --> 16:47:06.603
come back over to here, we can
save and boom, stuff gets auto

16529
16:47:06.603 --> 16:47:08.603
formatted. Now, again, we're
going to be using the multi

16530
16:47:08.603 --> 16:47:11.603
terminal feature. So right now I
have one running my front end.

16531
16:47:11.603 --> 16:47:14.603
So if I come back to the front
end, I hit refresh. It's still

16532
16:47:14.603 --> 16:47:16.603
running. And then I have one to
do, you know my scripts and

16533
16:47:16.603 --> 16:47:19.603
stuff. We have yarn run dev
running right now. And if we go

16534
16:47:19.603 --> 16:47:23.603
to our package, JSON, running
yarn, run dev just runs next

16535
16:47:23.603 --> 16:47:27.603
Dev. And actually, let me cancel
it and just do yarn dev yarn is

16536
16:47:27.603 --> 16:47:30.603
actually smart enough that don't
need to do run Dev, but it just

16537
16:47:30.603 --> 16:47:34.603
runs next Dev. And this next
command comes built in once we

16538
16:47:34.603 --> 16:47:37.603
installed next, which we did
when we did yarn create next

16539
16:47:37.603 --> 16:47:40.604
app. So next Jas comes with
these scripts already built in

16540
16:47:40.604 --> 16:47:45.604
for us, we want to build our
front end to enable people to

16541
16:47:45.604 --> 16:47:48.604
interact with our lottery in a
fair way, and connect with the

16542
16:47:48.604 --> 16:47:51.604
smart contract that's running.
Let's create some simple front

16543
16:47:51.604 --> 16:47:53.604
end pieces for this. So first
thing we're gonna do is we're

16544
16:47:53.604 --> 16:47:56.604
gonna go to Pages, and we're
going to go to index.js. All

16545
16:47:56.604 --> 16:48:00.604
this stuff in here is cute and
nice. And thank you next, Jas,

16546
16:48:00.604 --> 16:48:03.604
but we're going to delete it all
and delete everything except for

16547
16:48:03.604 --> 16:48:05.604
that headpiece, we're gonna
leave that up, we're just going

16548
16:48:05.604 --> 16:48:08.604
to change the name. But this way
down here, we're going to change

16549
16:48:08.604 --> 16:48:15.604
the name from Crate next app to
smart contract lottery or raffle

16550
16:48:15.604 --> 16:48:19.604
or whatever we want to do.
description will be our smart

16551
16:48:19.604 --> 16:48:23.604
contract, lottery. And then
right below the head, we're

16552
16:48:23.604 --> 16:48:28.604
going to write hello, blue, and
save. And if we look at our

16553
16:48:28.604 --> 16:48:31.604
front end, we now see that it
says smart contract lottery and

16554
16:48:31.604 --> 16:48:33.604
the top and I'm going to move
this all the way over here,

16555
16:48:33.604 --> 16:48:37.604
smart contract lottery and the
top and we see Hello, so smart

16556
16:48:37.604 --> 16:48:39.604
contract lottery. Hello, the
description here, we're not

16557
16:48:39.604 --> 16:48:41.604
going to see this is going to be
something that web scrapers and

16558
16:48:41.604 --> 16:48:45.604
stuff we're going to find.

16559
16:48:45.604 --> 16:48:48.604
Now one of the first things that
we're going to need to do is

16560
16:48:48.604 --> 16:48:50.604
we're going to need to create
that connect button. We've done

16561
16:48:50.604 --> 16:48:53.604
this in the past with raw
JavaScript, but now we're going

16562
16:48:53.604 --> 16:48:57.604
to do it with next js and react.
The one that we made previously

16563
16:48:57.604 --> 16:49:00.604
was pretty minimalistic. In
fact, we bring it back up it

16564
16:49:00.604 --> 16:49:03.604
checked to see if there was
windows that Aetherium and then

16565
16:49:03.604 --> 16:49:06.604
went and requested and connected
and said okay, cool. You're

16566
16:49:06.604 --> 16:49:09.604
connected. Now what did didn't
do was a lot of things that we

16567
16:49:09.604 --> 16:49:13.604
would want an application to do.
When we change networks, our

16568
16:49:13.604 --> 16:49:15.604
application didn't detect that
when we change users or

16569
16:49:15.604 --> 16:49:19.604
application didn't detect that
it was really stringent in the

16570
16:49:19.604 --> 16:49:22.605
functionality that it actually
had for connecting to a wallet.

16571
16:49:22.605 --> 16:49:25.605
So we're going to make our
wallet connect button,

16572
16:49:25.605 --> 16:49:28.605
incredibly powerful, so that you
can connect with the button, you

16573
16:49:28.605 --> 16:49:30.605
can switch networks, you can
switch accounts, you can pretty

16574
16:49:30.605 --> 16:49:33.605
much do anything in our
application will know our

16575
16:49:33.605 --> 16:49:36.605
application will be responsive.
So that's gonna be one of the

16576
16:49:36.605 --> 16:49:38.605
first things that we're going to
do, we're going to create a

16577
16:49:38.605 --> 16:49:42.605
header and connect button nav
bar one a little navbar here,

16578
16:49:42.605 --> 16:49:45.605
saying, hey, you know, you can
connect with this button. So

16579
16:49:45.605 --> 16:49:47.605
that's gonna be the first thing
that we're going to do. Now we

16580
16:49:47.605 --> 16:49:50.605
can build our whole connect
button in this index dot j s and

16581
16:49:50.605 --> 16:49:52.605
stick it in here. But instead,
what we're going to do is we're

16582
16:49:52.605 --> 16:49:55.605
going to make it a what's called
a component. So we're going to

16583
16:49:55.605 --> 16:49:59.605
create a new folder called
components. And we're going to

16584
16:49:59.605 --> 16:50:03.605
create a new file in here called
header.js. And you might also

16585
16:50:03.605 --> 16:50:08.605
see a lot of people do
header.js x.js and.js x do

16586
16:50:08.605 --> 16:50:11.605
literally the exact same thing,
you can do either one, I'm going

16587
16:50:11.605 --> 16:50:16.605
to do dot JSX, just to remind me
that this is a React file that

16588
16:50:16.605 --> 16:50:18.605
we're creating. This is a
component that we're creating.

16589
16:50:18.605 --> 16:50:21.605
But yeah, you can do J S JSX. If
you want to learn a little bit

16590
16:50:21.605 --> 16:50:24.605
more about components, we've got
a link to learning about

16591
16:50:24.605 --> 16:50:27.605
components. They're basically
independent and reusable bits of

16592
16:50:27.605 --> 16:50:30.605
code. They serve the same
purpose as JavaScript functions,

16593
16:50:30.605 --> 16:50:33.605
but work in isolation and return
HTML. So basically, we're going

16594
16:50:33.605 --> 16:50:37.605
to create like a little chunk of
HTML that we're going to export

16595
16:50:37.605 --> 16:50:40.605
into our index such as like what
we've done in the past, this

16596
16:50:40.605 --> 16:50:43.605
just helps modularize and reuse
this header component, you know,

16597
16:50:43.605 --> 16:50:46.605
across our project. Now, we're
only going to be using our

16598
16:50:46.605 --> 16:50:49.605
header in one area. However,
it's still nice to modularize

16599
16:50:49.605 --> 16:50:52.605
the project regardless. And to
get start, this is going to be

16600
16:50:52.605 --> 16:50:55.605
what's called a functional base
component. So we're going to

16601
16:50:55.605 --> 16:50:59.605
create basically a function
called home write really pretty

16602
16:50:59.605 --> 16:51:02.606
much exactly like what we see in
JavaScript, except it's going to

16603
16:51:02.606 --> 16:51:09.606
return some HTML. So we can do
like a little div. And my VS

16604
16:51:09.606 --> 16:51:12.606
code auto created the closing
div here. And in here, I'm going

16605
16:51:12.606 --> 16:51:15.606
to be like hi from header. This
is going to be a real

16606
16:51:15.606 --> 16:51:19.606
minimalistic component like this
is a valid component here. Now

16607
16:51:19.606 --> 16:51:23.606
we have this function that
returns HTML. And to give other

16608
16:51:23.606 --> 16:51:27.606
applications, the ability to use
this component will do export

16609
16:51:27.606 --> 16:51:32.606
default function home. And then
in our index.js, we can import

16610
16:51:32.606 --> 16:51:36.606
it with imports. Home actually,
excuse me, I'm not going to call

16611
16:51:36.606 --> 16:51:39.606
it home, we're going to call it
header, header, excuse me,

16612
16:51:39.606 --> 16:51:44.606
export default function header,
and then import header from the

16613
16:51:44.606 --> 16:51:49.606
down directory components slash
header, like so. So now we've

16614
16:51:49.606 --> 16:51:53.606
imported our header in index
such as if we go back to our

16615
16:51:53.606 --> 16:51:56.606
front end, which is still
running, we don't see it in

16616
16:51:56.606 --> 16:51:59.606
here, right? Remember,
everything goes through our app.

16617
16:51:59.606 --> 16:52:03.606
And when we're on the slash
page, that's going to go to our

16618
16:52:03.606 --> 16:52:07.606
index.js. index js is importing
our header, but it's not

16619
16:52:08.606 --> 16:52:11.606
returning our header, right, we
see. And here, we see it

16620
16:52:11.606 --> 16:52:15.606
returns. And this is the HTML
that it's returning. And as you

16621
16:52:15.606 --> 16:52:17.606
can see, there's clearly no
header in here. So now that

16622
16:52:17.606 --> 16:52:20.606
we've imported our header, we
need to actually add our header

16623
16:52:20.606 --> 16:52:24.606
in here. So we'll do header, and
then adds the closing tag right

16624
16:52:24.606 --> 16:52:27.606
here. If you don't add any
stuff, you know, in between two

16625
16:52:27.606 --> 16:52:30.606
tags, you can go ahead and just
do this one liner here, with a

16626
16:52:30.606 --> 16:52:34.606
backslash at the end saying,
Hey, this is an open and closed

16627
16:52:34.606 --> 16:52:36.606
tag here. Now that we've
imported it, what do you think

16628
16:52:36.606 --> 16:52:39.606
we'll see on the front end, now
that we've added it to our index

16629
16:52:39.606 --> 16:52:43.607
js, you're right, we see hi from
header, because we added our

16630
16:52:43.607 --> 16:52:47.607
header here. And then we see
Hello. So high from header,

16631
16:52:47.607 --> 16:52:51.607
hello, boom. Now, anything that
we do, obviously now in our

16632
16:52:51.607 --> 16:52:55.607
header.js, will see reflected on
our front end. So we can do hi

16633
16:52:55.607 --> 16:52:58.607
from header, blah, blah, blah,
you know, just a bunch of

16634
16:52:58.607 --> 16:53:00.607
dribbles, and we'll see it on
our front end. So this is going

16635
16:53:00.607 --> 16:53:03.607
to be our section where we're
going to make our header or a

16636
16:53:03.607 --> 16:53:05.607
navbar or all the functionality
for the Connect button. Now I'm

16637
16:53:05.607 --> 16:53:07.607
going to tell you something, and
some of you are going to love

16638
16:53:07.607 --> 16:53:09.607
this summer, you're going to
hate this. I'm going to show

16639
16:53:09.607 --> 16:53:13.607
you. I'm going to show you the
hard way first, then the easy

16640
16:53:13.607 --> 16:53:16.607
way. Why am I going to show you
the hard way first? Well,

16641
16:53:16.607 --> 16:53:18.607
because I want you to become
familiar with what's actually

16642
16:53:18.607 --> 16:53:21.607
going on behind the scenes and
what's actually going on with

16643
16:53:21.607 --> 16:53:23.607
some of these components because
it is really helpful when

16644
16:53:23.607 --> 16:53:26.607
building these front ends to
understand, Okay, here's what's

16645
16:53:26.607 --> 16:53:28.607
going on. If you don't
understand what's going on

16646
16:53:28.607 --> 16:53:30.607
behind the scenes, you're gonna
go to try to build more advanced

16647
16:53:30.607 --> 16:53:33.607
applications, and you're gonna
have no idea what to do because

16648
16:53:33.607 --> 16:53:35.607
you've just learned the
shortcut. I like to think of it

16649
16:53:35.607 --> 16:53:38.607
as like calculus, like we're
going to learn how to calculate

16650
16:53:38.607 --> 16:53:40.607
a derivative first, and then
we're going to learn the

16651
16:53:40.607 --> 16:53:44.607
shortcut to quickly getting
derivatives. So don't skip this

16652
16:53:44.607 --> 16:53:47.607
part, because this is going to
help you well and beyond down

16653
16:53:47.607 --> 16:53:51.607
the line. Okay, we're going to
learn this the harder way to set

16654
16:53:51.607 --> 16:53:55.607
everything up in our HTML Funmi.
We just use raw ethers to kind

16655
16:53:55.607 --> 16:53:58.607
of do everything and you
absolutely can use raw ethers to

16656
16:53:58.607 --> 16:54:01.607
do everything. However, there
are some packages especially for

16657
16:54:01.607 --> 16:54:05.607
React that make life developing
a front end substantially better

16658
16:54:05.607 --> 16:54:08.607
and in our full blockchain
solidity course, Jas. We have a

16659
16:54:08.607 --> 16:54:11.607
number of other packages that
you can use will stack

16660
16:54:11.607 --> 16:54:13.607
development and other libraries.
And if you watch this six ways

16661
16:54:13.607 --> 16:54:15.607
to connect your depth to a
wallet, you'll actually

16662
16:54:15.607 --> 16:54:18.607
understand some of the
differences. So if you haven't

16663
16:54:18.607 --> 16:54:21.608
watched that video, go back,
watch that video. But there's a

16664
16:54:21.608 --> 16:54:24.608
whole bunch of libraries that we
can use that are going to make

16665
16:54:24.608 --> 16:54:27.608
our lives a lot easier. We've
listed some of them here. React

16666
16:54:27.608 --> 16:54:30.608
Morales is the one that we're
going to be using today, they

16667
16:54:30.608 --> 16:54:32.608
have some additional plugins,
and they have probably my

16668
16:54:32.608 --> 16:54:34.608
favorite thing on the planet,
which I'm going to show you how

16669
16:54:34.608 --> 16:54:38.608
to do very soon. But these are
also open source, Ross also

16670
16:54:38.608 --> 16:54:41.608
comes with some optional
functionality to hook into your

16671
16:54:41.608 --> 16:54:44.608
own back end to give your app
even more features and even more

16672
16:54:44.608 --> 16:54:46.608
functionality. And that's the
other reason that we're doing

16673
16:54:46.608 --> 16:54:49.608
it. So and we're gonna go over
that later. And if you want to

16674
16:54:49.608 --> 16:54:52.608
use pure ethers, you absolutely
still can. A lot of these

16675
16:54:52.608 --> 16:54:55.608
packages that we're using do
rely on ethers, but we're not

16676
16:54:55.608 --> 16:54:58.608
going to use just ether. So we
go to the React Morales page.

16677
16:54:58.608 --> 16:55:01.608
And to get started, we can just
do this bit right here. So we're

16678
16:55:02.608 --> 16:55:05.608
literally going to copy this and
bring it into our project. And

16679
16:55:05.608 --> 16:55:08.608
if you go to our package that
JSON, we actually already have

16680
16:55:08.608 --> 16:55:13.608
react and react DOM. So we can
just do yarn, add Morales, and

16681
16:55:13.608 --> 16:55:19.608
react oralis. Now you'll notice
I'm not doing these as dev

16682
16:55:19.608 --> 16:55:23.608
dependencies, I didn't do yarn,
add dash dash dev here. The

16683
16:55:23.608 --> 16:55:26.608
reason is, because for our
production builds, when we

16684
16:55:26.608 --> 16:55:29.608
actually create the website
here, you will need Morales and

16685
16:55:29.608 --> 16:55:33.608
you will need react Morales we
don't need prettier to create a

16686
16:55:33.608 --> 16:55:37.608
website prettier is a tool that
we're using as developers. So in

16687
16:55:37.608 --> 16:55:40.608
all of our projects, so far,
we've been using just dev

16688
16:55:40.608 --> 16:55:43.608
dependencies. That's because
we've only been building our

16689
16:55:43.608 --> 16:55:47.608
projects for developers, our
GitHub repos, they haven't been

16690
16:55:47.608 --> 16:55:50.608
made to build a website, they've
only been to do things on the

16691
16:55:50.608 --> 16:55:53.608
back end, for our website, we're
actually going to be building a

16692
16:55:53.608 --> 16:55:56.608
front end. So we need to put
this in the dependencies

16693
16:55:56.608 --> 16:55:59.608
section, because we need to say,
Hey, these are the ones that we

16694
16:55:59.608 --> 16:56:02.609
need to bundle up together for
the front end, and you can

16695
16:56:02.609 --> 16:56:05.609
ignore these ones. And if it's
just like a tool to make our

16696
16:56:05.609 --> 16:56:07.609
lives better, it's gonna go in
dev dependencies. So we're

16697
16:56:07.609 --> 16:56:11.609
adding Morales and react
Morales. And a lot of the syntax

16698
16:56:11.609 --> 16:56:13.609
that we're going to do for our
header is actually going to be

16699
16:56:13.609 --> 16:56:16.609
really similar to what we've
been seeing so far. So let's do

16700
16:56:16.609 --> 16:56:18.609
this. And then actually, we're
just going to change this name

16701
16:56:18.609 --> 16:56:21.609
to manual header, manual header
update imports for manual

16702
16:56:21.609 --> 16:56:25.609
header, you can go ahead and hit
yes to man you all header here,

16703
16:56:25.609 --> 16:56:29.609
we're gonna copy manual header,
make sure it's in our index.js

16704
16:56:29.609 --> 16:56:31.609
it we're gonna change header to
manual header, and we're gonna

16705
16:56:31.609 --> 16:56:34.609
change how to manual header
here. And the reason we're doing

16706
16:56:34.609 --> 16:56:36.609
this is because like I said,
we're going to create a much

16707
16:56:36.609 --> 16:56:40.609
simpler header after we create
this kind of harder one. And

16708
16:56:40.609 --> 16:56:42.609
we're going to want to create
that connect button, which

16709
16:56:42.609 --> 16:56:46.609
again, we made in HTML Funmi. By
calling eath request accounts,

16710
16:56:46.609 --> 16:56:49.609
what we can do actually with
Morales is we can just do this

16711
16:56:49.609 --> 16:56:53.609
thing called Enable Web three.
So at the top, we're going to

16712
16:56:53.609 --> 16:56:57.609
import, use mirallas.

16713
16:56:57.609 --> 16:57:03.609
From react ralis. And if you go
to the React Morales page here

16714
16:57:03.609 --> 16:57:06.609
or to their GitHub, you'll learn
how to set all this up too and

16715
16:57:06.609 --> 16:57:08.609
learn more about the
documentation. So we're going to

16716
16:57:08.609 --> 16:57:11.609
import use Morales from react
Morales, and inside our function

16717
16:57:11.609 --> 16:57:17.609
here, but outside of our return,
we're going to say const, Enable

16718
16:57:17.609 --> 16:57:23.609
Web three equals use mirallas.
Now use Morales is what's known

16719
16:57:23.609 --> 16:57:27.609
as a hook as a React hook. And
it's a way to keep track of

16720
16:57:27.609 --> 16:57:30.609
state in our application. Now,
in order to use mirallas, our

16721
16:57:30.609 --> 16:57:33.609
entire application needs to be
wrapped around what's called a

16722
16:57:33.609 --> 16:57:37.609
Morales provider, which is going
to be a context provider for us.

16723
16:57:37.609 --> 16:57:39.609
And I'll explain what that means
in a minute. But basically, what

16724
16:57:39.609 --> 16:57:43.610
we need to do is we need to add
this Morales provider to our

16725
16:57:43.610 --> 16:57:50.610
app.js. So in here, we're going
to import oralis provider from

16726
16:57:50.610 --> 16:57:55.610
react oralis. And we're going to
wrap our entire app around this

16727
16:57:55.610 --> 16:57:58.610
Morales provided so we're going
to do some little parentheses

16728
16:57:58.610 --> 16:58:04.610
here. New Line, we're going to
paste morass provider like this,

16729
16:58:04.610 --> 16:58:07.610
it's going to give us the
closing tag, copy it, paste it

16730
16:58:07.610 --> 16:58:12.610
like this and save. And then in
here, we're going to write in

16731
16:58:12.610 --> 16:58:19.610
the sheet allies on Mount equals
false. This initialize on Mount

16732
16:58:19.610 --> 16:58:23.610
piece here is the optionality to
hook into a server to add some

16733
16:58:23.610 --> 16:58:26.610
more features to our website. We
don't want to hook into a server

16734
16:58:26.610 --> 16:58:28.610
for this application, we want
everything just to be open

16735
16:58:28.610 --> 16:58:30.610
source, and we don't need any of
this additional functionality.

16736
16:58:30.610 --> 16:58:33.610
So we're just going to do
initialize on Mount equals

16737
16:58:33.610 --> 16:58:35.610
false. Now that the whole thing
is wrapped in this Morales

16738
16:58:35.610 --> 16:58:38.610
provider, we go to the front end
we should be able to refresh

16739
16:58:38.610 --> 16:58:41.610
everything looks pretty much the
same. And we can start using

16740
16:58:41.610 --> 16:58:47.610
these hooks. Now this use
Morales is what's known as a

16741
16:58:47.610 --> 16:58:51.610
hook and hooks can be a little
bit confusing to understand at

16742
16:58:51.610 --> 16:58:55.610
first glance, but they're
incredibly powerful and they are

16743
16:58:55.610 --> 16:58:58.610
the de facto way for us to build
react projects. And if you're

16744
16:58:58.610 --> 16:59:01.610
familiar with class components,
we're not gonna be using class

16745
16:59:01.610 --> 16:59:04.610
components because hooks are
much better hooks allow function

16746
16:59:04.610 --> 16:59:07.610
components to have access to
state and other react feature

16747
16:59:07.610 --> 16:59:10.610
ers state being probably one of
the biggest ones and the most

16748
16:59:10.610 --> 16:59:13.610
popular ones, we want our
application to be different if

16749
16:59:13.610 --> 16:59:16.610
we're connected to Metamask,
versus if we're not, right, if

16750
16:59:16.610 --> 16:59:20.610
we go back, if we go back to our
example website here, right, if

16751
16:59:20.610 --> 16:59:23.611
we're not connected, we want to
say, Please connect to a wallet.

16752
16:59:23.611 --> 16:59:25.611
And then when we are connected,
we want to go ahead and be

16753
16:59:25.611 --> 16:59:28.611
connected. If I have, let's say,
I have some variable like, and I

16754
16:59:28.611 --> 16:59:32.611
don't have this hook here, I
have like, let connected equals

16755
16:59:32.611 --> 16:59:35.611
false, right, or enable Web
three, or is web three enabled,

16756
16:59:35.611 --> 16:59:38.611
let's say I've led connected
equals false. And then I have,

16757
16:59:38.611 --> 16:59:41.611
you know, let's say have some
button that connects us and

16758
16:59:41.611 --> 16:59:47.611
changes connected to be true,
changing connected to be true is

16759
16:59:47.611 --> 16:59:51.611
great and all but it won't
rerender our application, you

16760
16:59:51.611 --> 16:59:54.611
see, when I disconnect and I
reconnect here, our application

16761
16:59:54.611 --> 16:59:57.611
actually changes based off of
whether or not we're connected.

16762
16:59:57.611 --> 17:00:01.611
And this is what we want, we
want our front end to rerender.

16763
17:00:01.611 --> 17:00:04.611
When we're connected, if I just
use a variable like this inside

16764
17:00:04.611 --> 17:00:08.611
of our component, our front end
isn't going to rerender. Or even

16765
17:00:08.611 --> 17:00:12.611
worse, if I use it outside, our
component doesn't even know

16766
17:00:12.611 --> 17:00:15.611
anything about this changing. So
hooks are a way for us to

16767
17:00:15.611 --> 17:00:19.611
actually work with state
especially and automatically

16768
17:00:19.611 --> 17:00:22.611
rerender when something changes
and enable Web three is going to

16769
17:00:22.611 --> 17:00:25.611
be a function that we get from
this use Morales hook to do

16770
17:00:25.611 --> 17:00:28.611
that. So for a lot of our
components, instead of just

16771
17:00:28.611 --> 17:00:32.611
saying like, let web three
enabled equals true, like we did

16772
17:00:32.611 --> 17:00:35.611
in normal JavaScript, we're
going to be doing a lot of this,

16773
17:00:35.611 --> 17:00:38.611
these hooks. For the most part,
we usually want our website to

16774
17:00:38.611 --> 17:00:42.611
change based off of if some
variable has changed and enabled

16775
17:00:42.611 --> 17:00:46.611
web three is a function that we
get from this hook that says,

16776
17:00:46.611 --> 17:00:48.611
Okay, go ahead and connect
Enable Web three is basically

16777
17:00:48.611 --> 17:00:52.611
the equivalent of saying try
await Aetherium dot request,

16778
17:00:52.611 --> 17:00:55.611
like this. Now enable Web three,
the way we're going to use it

16779
17:00:55.611 --> 17:00:58.611
here only works on Metamask. But
we will show you how to get this

16780
17:00:58.611 --> 17:01:01.612
kind of this cool little module
up where we can choose between

16781
17:01:01.612 --> 17:01:05.612
different ways to connect our
app.

16782
17:01:05.612 --> 17:01:08.612
We have our enabled web three,
let's go ahead and create a

16783
17:01:08.612 --> 17:01:12.612
button, that's going to do the
same as what we did in our HTML

16784
17:01:12.612 --> 17:01:15.612
Funmi in our return, but here,
instead of hi friend header,

16785
17:01:15.612 --> 17:01:17.612
we're going to add a new
component, or we're going to add

16786
17:01:17.612 --> 17:01:20.612
a new tag, we're gonna add the
button tag, and for me it

16787
17:01:20.612 --> 17:01:24.612
automatically close to, and I'm
just gonna call it connect, I'm

16788
17:01:24.612 --> 17:01:26.612
gonna go ahead and save. Now we
see a little button that says

16789
17:01:26.612 --> 17:01:28.612
connect. And obviously, it
doesn't do anything, we're gonna

16790
17:01:28.612 --> 17:01:32.612
give this some functionality,
we're gonna say on click now

16791
17:01:32.612 --> 17:01:37.612
since again, this is a JSX
component. This isn't raw HTML,

16792
17:01:37.612 --> 17:01:41.612
in raw HTML, we can't just kind
of stick JavaScript wherever we

16793
17:01:41.612 --> 17:01:45.612
want. But in JSX files, we can
stick JavaScript kind of

16794
17:01:45.612 --> 17:01:49.612
wherever we want. So inside of
this, inside of this block of

16795
17:01:49.612 --> 17:01:52.612
HTML, we can actually stick
JavaScript in here by adding

16796
17:01:52.612 --> 17:01:55.612
these little brackets. So adding
these little brackets in our

16797
17:01:55.612 --> 17:01:58.612
jobs can return. But here, we
can add JavaScript. And what we

16798
17:01:58.612 --> 17:02:02.612
want to do is we want to have
our On Click Call Enable Web

16799
17:02:02.612 --> 17:02:06.612
three, we're going to call an
async function, we're going to

16800
17:02:06.612 --> 17:02:08.612
use the arrow syntax here, one
click, we're gonna call this

16801
17:02:08.612 --> 17:02:12.612
async function, which is just
going to be await, Enable Web

16802
17:02:12.612 --> 17:02:16.612
three, await Enable Web three,
let's add the little parentheses

16803
17:02:16.612 --> 17:02:19.612
here. And essentially, with just
this, we've done pretty much

16804
17:02:19.612 --> 17:02:23.612
everything that we had back in
this big connect function here.

16805
17:02:23.612 --> 17:02:26.612
Now if we go back to our front
end, do a little refresh, we can

16806
17:02:26.612 --> 17:02:28.612
see that right now, we can see
that I'm actually connected, I'm

16807
17:02:28.612 --> 17:02:31.612
gonna go ahead and disconnect.
I'm still connected from some of

16808
17:02:31.612 --> 17:02:34.612
the last applications I was
doing, we can hit Connect, and

16809
17:02:34.612 --> 17:02:38.612
now we see metamath does indeed
pop up, we'll hit Next connect,

16810
17:02:38.612 --> 17:02:40.612
and boom. And that's all we need
to do. Now, if we look at our

16811
17:02:40.612 --> 17:02:43.613
Metamask, it says connected.
Great. Okay, cool. So now we

16812
17:02:43.613 --> 17:02:46.613
have a way to actually connect
here, let's add some

16813
17:02:46.613 --> 17:02:48.613
functionality and make our
application smart enough to have

16814
17:02:48.613 --> 17:02:51.613
the connect button if we're
connected. And if we're not

16815
17:02:51.613 --> 17:02:54.613
connected, not have that button.
So what we'll do now is use

16816
17:02:54.613 --> 17:02:58.613
Morales comes with another hook
called is web three, enabled,

16817
17:02:58.613 --> 17:03:01.613
which is just a variable part of
our hook that keeps track of

16818
17:03:01.613 --> 17:03:04.613
whether or not our Metamask is
connected. But we can actually

16819
17:03:04.613 --> 17:03:08.613
do one better, we can actually
check to see if there's an

16820
17:03:08.613 --> 17:03:11.613
account because maybe web three
is connected. But but they

16821
17:03:11.613 --> 17:03:15.613
didn't connect it to an account.
So let's go ahead and we'll

16822
17:03:15.613 --> 17:03:19.613
import count from us. Morales
will check to see if there's an

16823
17:03:19.613 --> 17:03:22.613
account. So what we'll do is
inside of our div tags, we'll do

16824
17:03:22.613 --> 17:03:25.613
a little JavaScript, we'll do
that ternary operator again,

16825
17:03:25.613 --> 17:03:28.613
we'll put a count here with a
question mark. And we'll do that

16826
17:03:28.613 --> 17:03:32.613
that same syntax that we've seen
before, we'll say account, if

16827
17:03:32.613 --> 17:03:35.613
account exists, do this. If
there's no account, do this. And

16828
17:03:35.613 --> 17:03:39.613
if there's no account, we want
to add this Connect button. So

16829
17:03:39.613 --> 17:03:42.613
we'll go ahead and we'll stick
this in here. If there is an

16830
17:03:42.613 --> 17:03:45.613
account, we'll just show that
account, right. So we'll do div

16831
17:03:45.613 --> 17:03:50.613
backslash div in here, we'll
just say connected, like that.

16832
17:03:50.613 --> 17:03:53.613
Now if we go back to our front
end, we see connected. If we do

16833
17:03:53.613 --> 17:03:57.613
a little refresh, it'll go away.
So we'll we'll re hit Connect,

16834
17:03:57.613 --> 17:04:00.613
and now we're connected, which
is great. Let's make it even

16835
17:04:00.613 --> 17:04:04.613
smarter. We'll have it show our
account here. So instead of just

16836
17:04:04.613 --> 17:04:08.613
saying connected, we'll say
connected to I'll put some

16837
17:04:08.613 --> 17:04:10.613
JavaScript, we'll put some
JavaScript inside of our

16838
17:04:10.613 --> 17:04:14.613
JavaScript. But since this is
that HTML stuff, we got to use

16839
17:04:14.613 --> 17:04:17.613
these brackets to say JavaScript
again. So we'll put JavaScript

16840
17:04:17.613 --> 17:04:20.613
inside of the JavaScript, we'll
say connected to, we can just

16841
17:04:20.613 --> 17:04:23.614
say account. Now go back to our
front end, we see connected to

16842
17:04:23.614 --> 17:04:25.614
blah, blah, blah, blah, blah,
you'll notice if you hit

16843
17:04:25.614 --> 17:04:28.614
refresh, you'll have to
reconnect, we'll get to that in

16844
17:04:28.614 --> 17:04:30.614
a minute, what a lot of people
do is they'll do a count dot

16845
17:04:30.614 --> 17:04:35.614
slice, zero, comma six. And then
outside of the brackets, they'll

16846
17:04:35.614 --> 17:04:42.614
do dot that dot, another set of
brackets account, that slice,

16847
17:04:42.614 --> 17:04:46.614
count dot length minus four,
close that off like that, we

16848
17:04:46.614 --> 17:04:49.614
have our account, when we hit
Connect, now it says connected

16849
17:04:49.614 --> 17:04:52.614
to blah, blah, blah, hello. And
because of these hooks, when I

16850
17:04:52.614 --> 17:04:56.614
switch accounts, and I connect
with these new accounts, it even

16851
17:04:56.614 --> 17:04:59.614
automatically re renders
switching accounts. So these

16852
17:04:59.614 --> 17:05:02.614
hooks are really good for re
rendering our websites whenever

16853
17:05:02.614 --> 17:05:07.614
some value changes. For example,
if I said like, let count number

16854
17:05:07.614 --> 17:05:10.614
equals seven, and we had a
button, that updated account

16855
17:05:10.614 --> 17:05:13.614
number, our front end wouldn't
rerender unless we told it

16856
17:05:13.614 --> 17:05:16.614
specifically to rerender, which
gets really annoying. So hooks

16857
17:05:16.614 --> 17:05:19.614
kind of help us a lot with doing
that. And it allows us to keep

16858
17:05:19.614 --> 17:05:24.614
track of states between renders.

16859
17:05:24.614 --> 17:05:27.614
Now, here's something that right
now it doesn't do, if I hit

16860
17:05:27.614 --> 17:05:31.614
refresh, I have to re hit this
connect button, even though my

16861
17:05:31.614 --> 17:05:34.614
Metamask says, Hey, we're
connected. But if I refresh, I

16862
17:05:34.614 --> 17:05:36.614
have to re hit this Connect
button. Why is this happening.

16863
17:05:36.614 --> 17:05:39.614
Or when I hit refresh, our
website doesn't know that we've

16864
17:05:39.614 --> 17:05:42.614
hit enable Web three already,
right, because we basically go

16865
17:05:42.614 --> 17:05:45.614
back to blank when I refresh,
and then I have to hit Connect,

16866
17:05:45.614 --> 17:05:48.614
which is really obnoxious and
really annoying. So we want to

16867
17:05:48.614 --> 17:05:52.614
add some functionality, so that
automatically the instant we

16868
17:05:52.614 --> 17:05:55.614
render, we go ahead and we check
to see if we're already

16869
17:05:55.614 --> 17:05:58.614
connected. And if we're
connected to show this. Now to

16870
17:05:58.614 --> 17:06:03.615
do that, we can use another hook
called use effect. And this is a

16871
17:06:03.615 --> 17:06:11.615
core react hook. So we'll do
import use effect from react

16872
17:06:11.615 --> 17:06:15.615
like this. This is a core hook
directly from react. And it's

16873
17:06:15.615 --> 17:06:18.615
one of the most popular out
there along with use state. And

16874
17:06:18.615 --> 17:06:21.615
we've left some links to
learning more about the effect

16875
17:06:21.615 --> 17:06:23.615
hook in the GitHub repo
associated with this course, I'm

16876
17:06:23.615 --> 17:06:27.615
gonna give you my summary of
basically what this use effect

16877
17:06:27.615 --> 17:06:29.615
does, we basically have this
function called use effect,

16878
17:06:29.615 --> 17:06:32.615
which takes two parameters, it
takes a function as its first

16879
17:06:32.615 --> 17:06:36.615
parameter, and then second, it
optionally takes a dependency

16880
17:06:36.615 --> 17:06:40.615
array. And what this use effect
is going to do is it's going to

16881
17:06:40.615 --> 17:06:44.615
keep checking the values in this
dependency array. And if

16882
17:06:44.615 --> 17:06:48.615
anything in this dependency rate
changes, it's going to call some

16883
17:06:48.615 --> 17:06:52.615
function, and then rerender, the
front end. So for example, using

16884
17:06:52.615 --> 17:06:56.615
Morales comes with this function
called is web three enabled or

16885
17:06:56.615 --> 17:06:59.615
this variable called is what
three enabled. If we add this to

16886
17:06:59.615 --> 17:07:03.615
our dependency array, what we
can do in our use effect is do

16887
17:07:03.615 --> 17:07:10.615
console dot log, hi. And then we
can do console dot log is web

16888
17:07:10.615 --> 17:07:13.615
three enabled, what this use
effect is going to be doing is

16889
17:07:13.615 --> 17:07:16.615
it's going to constantly be
running, this is running all the

16890
17:07:16.615 --> 17:07:20.615
time. And it's going to be
listening to see if is web three

16891
17:07:20.615 --> 17:07:23.615
enabled changes, right? And
anytime we run Enable Web three

16892
17:07:23.615 --> 17:07:27.615
is web three enabled becomes
true. So so now if we go to the

16893
17:07:27.615 --> 17:07:31.615
front end, we do a little
refresh, we see high false, high

16894
17:07:31.615 --> 17:07:34.615
false. Now why do we see this
twice is web three enabled only

16895
17:07:34.615 --> 17:07:38.615
changed once? Well, this is
because of how use effect works,

16896
17:07:38.615 --> 17:07:43.616
it will automatically run on
load or right or the first time

16897
17:07:43.616 --> 17:07:48.616
it does and then it'll run
checking the value. So we're

16898
17:07:48.616 --> 17:07:50.616
basically seeing this run twice,
it runs the first time we load

16899
17:07:50.616 --> 17:07:53.616
it, and then it'll check the
value and run again. So we see

16900
17:07:53.616 --> 17:07:55.616
go twice, even though it's
really just once. But if we go

16901
17:07:55.616 --> 17:07:59.616
back here, sorry, let me just do
a quick reload again. We hit

16902
17:07:59.616 --> 17:08:04.616
Connect, we now see Hi is now
true, because it saw is what

16903
17:08:04.616 --> 17:08:07.616
three enabled change to true
because enabled web three made

16904
17:08:07.616 --> 17:08:11.616
is what enabled return true. And
it ran this again, right. So

16905
17:08:11.616 --> 17:08:14.616
that's how that actually works.
And there's a couple of

16906
17:08:14.616 --> 17:08:17.616
different ways to think about
this. Actually, we actually

16907
17:08:17.616 --> 17:08:19.616
don't even need to give this an
array. And what happens if we

16908
17:08:19.616 --> 17:08:23.616
don't give this an array? Well,
let's refresh. We'll hit

16909
17:08:23.616 --> 17:08:26.616
Connect, and we'll see it's
still ran a couple of times. So

16910
17:08:26.616 --> 17:08:31.616
if we don't give it array, no
dependency array, it'll run any

16911
17:08:31.616 --> 17:08:34.616
time something re renders. And
you need to be careful with

16912
17:08:34.616 --> 17:08:38.616
this. Because then you can get
circular renders, if you have

16913
17:08:38.616 --> 17:08:42.616
some use effect that changes
some value. And you have another

16914
17:08:42.616 --> 17:08:44.616
use effect that re renders when
that value changes while they're

16915
17:08:44.616 --> 17:08:47.616
both just going to keep changing
back and back and forth. So no

16916
17:08:47.616 --> 17:08:50.616
dependency array like this. It
will run anytime something re

16917
17:08:50.616 --> 17:08:54.616
renders we'll give it a blank
dependency array. It'll just run

16918
17:08:54.616 --> 17:08:57.616
once on load, just run one time.
So now like we have a blank

16919
17:08:57.616 --> 17:09:01.616
dependency right in here, we
reload. Right? We see that it

16920
17:09:01.616 --> 17:09:04.616
runs twice. That's actually
because we're basically re

16921
17:09:04.616 --> 17:09:07.616
rendering once in the
background. So it really is just

16922
17:09:07.616 --> 17:09:09.616
running Once but there's
something else going on in the

16923
17:09:09.616 --> 17:09:11.616
background. So it looks like
it's running twice. Now if we

16924
17:09:11.616 --> 17:09:16.616
just add is web three enabled,
do a little refresh, it'll do

16925
17:09:16.616 --> 17:09:19.616
the exact same thing, it'll run
the same amount as if this was

16926
17:09:19.616 --> 17:09:22.617
blank. But when we connect,
it'll add here. If this was a

16927
17:09:22.617 --> 17:09:27.617
blank array, when we refresh,
we'll see kick out twice, which

16928
17:09:27.617 --> 17:09:29.617
should be ones. But like I said,
there's something going on in

16929
17:09:29.617 --> 17:09:32.617
the background. If we hit
connect. Now, we don't see

16930
17:09:32.617 --> 17:09:36.617
anything here, because the blank
dependency array says, Hey, I'm

16931
17:09:36.617 --> 17:09:39.617
only going to run one time on
load. Now, if there's our stuff

16932
17:09:39.617 --> 17:09:42.617
in this array, like is web three
enabled, it's going to run

16933
17:09:42.617 --> 17:09:45.617
anytime something in this array
changes, right. So again, we'll

16934
17:09:45.617 --> 17:09:50.617
refresh will connect, we see it
ran again, after a hit Connect

16935
17:09:50.617 --> 17:09:55.617
will refresh. Hi, hi connected,
ran one more time. So so that's

16936
17:09:55.617 --> 17:09:58.617
kind of the cheat sheet here. If
we give it no dependency array,

16937
17:09:58.617 --> 17:10:01.617
it's going to run any time
anything in this project re

16938
17:10:01.617 --> 17:10:04.617
renders, if we give it a blank
dependency array, it's just

16939
17:10:04.617 --> 17:10:08.617
going to run one time, or like
we saw, it ran twice. But that's

16940
17:10:08.617 --> 17:10:10.617
because there's something else
we render in the background. And

16941
17:10:10.617 --> 17:10:13.617
if we give it dependencies in
this array, it's going to run

16942
17:10:13.617 --> 17:10:16.617
anytime something in this array
changes. And this is really

16943
17:10:16.617 --> 17:10:19.617
helpful, because oftentimes,
we're going to want our front

16944
17:10:19.617 --> 17:10:23.617
ends to rerender, this use
effect will say, oh, cool, some

16945
17:10:23.617 --> 17:10:26.617
value changed, I'm going to run
this function, and then I'm

16946
17:10:26.617 --> 17:10:30.617
going to rerender, your front
end.

16947
17:10:30.617 --> 17:10:33.617
And now we're going to use this
use effect thing to make sure

16948
17:10:33.617 --> 17:10:35.617
that when we refresh, it
remembers that we're actually

16949
17:10:35.617 --> 17:10:38.617
connected. So how do we do that
inside here, we are going to use

16950
17:10:38.617 --> 17:10:41.617
this is web three enabled thing.
And the first thing that we want

16951
17:10:41.617 --> 17:10:46.617
to just do is we want to say if
is what three enabled, then

16952
17:10:46.617 --> 17:10:49.617
we'll just return. Because if
we're already connected to web

16953
17:10:49.617 --> 17:10:52.617
three, then we don't need to do
anything. Now, if we're not

16954
17:10:52.617 --> 17:10:55.617
connected to web three, and we
don't have an account, we'll

16955
17:10:55.617 --> 17:10:58.617
want to go ahead and call Enable
Web three, right want to

16956
17:10:58.617 --> 17:11:02.618
automatically enable Web three.
So now if I go back, you'll see

16957
17:11:02.618 --> 17:11:06.618
with just this code, I'm just
always automatically calling

16958
17:11:06.618 --> 17:11:09.618
Enable Web three. But this can
get really annoying. Because if

16959
17:11:09.618 --> 17:11:13.618
I disconnect, right, let's go
disconnect everything. Now

16960
17:11:13.618 --> 17:11:18.618
refresh, it's going to always
call Enable Web three, right,

16961
17:11:18.618 --> 17:11:20.618
every time we refresh, it's
going to automatically call

16962
17:11:20.618 --> 17:11:23.618
enabled through without us even
hitting the Connect button. So

16963
17:11:23.618 --> 17:11:26.618
that's no good to we want to
actually see if we're connected.

16964
17:11:26.618 --> 17:11:29.618
So the way we do this, like I
said, we want to use our local

16965
17:11:29.618 --> 17:11:32.618
storage, again, application, or
these little, this little thing

16966
17:11:32.618 --> 17:11:37.618
here go to Application, we want
our we want our application to

16967
17:11:37.618 --> 17:11:40.618
remember that somebody hit this
connect button, and they went

16968
17:11:40.618 --> 17:11:43.618
and connected to us. So what
we're going to do is in our

16969
17:11:43.618 --> 17:11:46.618
little onClick function down
here, we're not just going to

16970
17:11:46.618 --> 17:11:49.618
call await Enable Web three,
we're also going to store a

16971
17:11:49.618 --> 17:11:53.618
little remembrance here saying,
Hey, we actually did connect

16972
17:11:53.618 --> 17:11:57.618
recently. So below this, we're
going to run window, dot local

16973
17:11:57.618 --> 17:12:07.618
storage, dot set item,
connected, comma injected. I'm

16974
17:12:07.618 --> 17:12:09.618
actually going to comment this
out for now, because my friend

16975
17:12:09.618 --> 17:12:12.618
is just going to keep popping up
like that. So what this does is

16976
17:12:12.618 --> 17:12:16.618
we're saying, okay, in our
window, because again, if you go

16977
17:12:16.618 --> 17:12:20.618
back to the window, you go to
console, a type window, you're

16978
17:12:20.618 --> 17:12:23.618
actually going to see this giant
window thing here, right, which

16979
17:12:23.618 --> 17:12:26.618
we showed you before, there's
always this window object in

16980
17:12:26.618 --> 17:12:29.618
here. And we're going to do
window dot local storage, which

16981
17:12:29.618 --> 17:12:34.618
relates to if we go to this
application section, this local

16982
17:12:34.618 --> 17:12:38.618
storage section here, that set
item connected to inject it. So

16983
17:12:38.618 --> 17:12:41.618
we're going to set a new key
value in here, we're doing it

16984
17:12:41.618 --> 17:12:44.619
like this because in the future,
maybe you want to do you know

16985
17:12:44.619 --> 17:12:48.619
connect it to Wallet connect or
connected to Coinbase wallet or

16986
17:12:48.619 --> 17:12:51.619
something, right, but we're just
gonna say injected, meaning

16987
17:12:51.619 --> 17:12:54.619
we're connected to that meta
mask. And in some versions of

16988
17:12:54.619 --> 17:12:56.619
next, Jas next, Jas has a hard
time knowing about this window

16989
17:12:56.619 --> 17:13:02.619
variable. So we can just do if
type of window does not equal

16990
17:13:02.619 --> 17:13:07.619
equal, undefined, then we're
going to do this. So we're just

16991
17:13:07.619 --> 17:13:10.619
making sure that window doesn't
equal undefined that there is a

16992
17:13:10.619 --> 17:13:13.619
window. So now if I go back to
the front end, and I hit

16993
17:13:13.619 --> 17:13:18.619
Connect, and we go ahead, and we
connect here, we'll see now in

16994
17:13:18.619 --> 17:13:23.619
our application, local storage,
we'll see we've added this

16995
17:13:23.619 --> 17:13:26.619
connected injected bit here,
we're storing in the browser

16996
17:13:26.619 --> 17:13:29.619
that we are indeed connected to
this. Now that we've added this

16997
17:13:29.619 --> 17:13:33.619
into our browser, we can roll
back up to our use effect here

16998
17:13:33.619 --> 17:13:36.619
and say, Okay, if they're
already connected, great, we'll

16999
17:13:36.619 --> 17:13:39.619
be done. But before we do
anything, let's check to see if

17000
17:13:39.619 --> 17:13:41.619
they have this here. And if they
already are connected, let's

17001
17:13:41.619 --> 17:13:47.619
just run that connect bit. So
we'll say if type of window does

17002
17:13:47.619 --> 17:13:51.619
not equal, undefined, right,
because we want to check for

17003
17:13:51.619 --> 17:13:57.619
that window object. Again, we'll
say if window dot local storage

17004
17:13:57.619 --> 17:14:02.619
dot get item connected,
connected, so if that connected

17005
17:14:02.619 --> 17:14:07.619
key exists, then we'll just run
Enable Web three. So now We have

17006
17:14:07.619 --> 17:14:11.619
some functionality in here,
which even when we refresh, it

17007
17:14:11.619 --> 17:14:14.619
will automatically run enable of
three for us. So now if I go

17008
17:14:14.619 --> 17:14:17.619
ahead and refresh the front end,
we don't have to press that

17009
17:14:17.619 --> 17:14:21.619
connect button anymore, because
it goes, Oh, I see that locally,

17010
17:14:21.619 --> 17:14:25.620
we stored this connected key
whenever you refresh. Now, it

17011
17:14:25.620 --> 17:14:28.620
checks for this first it sees it
and then runs enabled web three.

17012
17:14:28.620 --> 17:14:32.620
Now on the other side, though,
if we're in here, and now we

17013
17:14:32.620 --> 17:14:35.620
disconnect, and then we refresh.
This will show up, which is

17014
17:14:35.620 --> 17:14:38.620
really annoying. And every time
we refresh, it'll keep showing

17015
17:14:38.620 --> 17:14:40.620
up, which we don't want. We want
it to be that when we

17016
17:14:40.620 --> 17:14:44.620
disconnect, we tell it hey,
we've we've gone ahead and

17017
17:14:44.620 --> 17:14:48.620
disconnected here. So back in
our application, we can add

17018
17:14:48.620 --> 17:14:52.620
another use effect to check to
see if we've disconnected. So

17019
17:14:52.620 --> 17:14:56.620
let's create another use effect.
That's going to costly just look

17020
17:14:56.620 --> 17:14:59.620
for us being connected, we'll
say use effect, do a little

17021
17:14:59.620 --> 17:15:04.620
arrow bracket thing here. And
we're going to do this anytime.

17022
17:15:04.620 --> 17:15:06.620
And oh my goodness, anytime I
save, it's going to keep popping

17023
17:15:06.620 --> 17:15:08.620
up. So I'm just going to just
going to comment that out for

17024
17:15:08.620 --> 17:15:11.620
now. So in here, we want to say
okay, whatever, there's a

17025
17:15:11.620 --> 17:15:15.620
rerender we want to run if any
account has changed. And Morales

17026
17:15:15.620 --> 17:15:18.620
has some functionality for us to
do this as well. So from user

17027
17:15:18.620 --> 17:15:22.620
morass, we're going to import
more Alice, and then down here

17028
17:15:22.620 --> 17:15:26.620
in our use effect. Inside the
little function, we're gonna say

17029
17:15:26.620 --> 17:15:31.620
mirallas.on account, changed

17030
17:15:31.620 --> 17:15:36.620
of account, we're gonna do some
stuff. So on account changed,

17031
17:15:36.620 --> 17:15:39.620
takes a function as an input
parameter. So we'll say console

17032
17:15:39.620 --> 17:15:47.620
dot log, account, change to
account. And what we can do is

17033
17:15:47.620 --> 17:15:50.620
we can check to see if this
account is not. And we can say

17034
17:15:50.620 --> 17:15:55.620
if account equals equals no,
then if the account is null, we

17035
17:15:55.620 --> 17:15:59.620
can assume they've disconnected.
So we can say window dot local

17036
17:15:59.620 --> 17:16:05.621
storage, dot remove item,
connected, we'll also run a

17037
17:16:05.621 --> 17:16:10.621
deactivate web three function.
So from Ross, deactivate, web

17038
17:16:10.621 --> 17:16:17.621
three will also run, deactivate
web three, which is going to set

17039
17:16:17.621 --> 17:16:20.621
is web three enabled to false.
So we're going to disconnect the

17040
17:16:20.621 --> 17:16:25.621
web three, and then we're going
to say console dot log.

17041
17:16:25.621 --> 17:16:27.621
No

17042
17:16:27.621 --> 17:16:30.621
count found. So let's try this
out. Now. Let's go back to our

17043
17:16:30.621 --> 17:16:33.621
front end, we'll do a little
refresh here. So right now it

17044
17:16:33.621 --> 17:16:36.621
says we're connected. Even
though in my meta mask, we're

17045
17:16:36.621 --> 17:16:38.621
not connected, right? And to
start from scratch here, you can

17046
17:16:38.621 --> 17:16:41.621
go ahead and disconnect it. But
but my browser says, Hey, we're

17047
17:16:41.621 --> 17:16:44.621
connected, right? So now we'll
connect. And we'll actually be

17048
17:16:44.621 --> 17:16:48.621
connected right, next connect,
and it and it just overrode

17049
17:16:48.621 --> 17:16:50.621
connected, you know, with
inject, let's, let's make this

17050
17:16:50.621 --> 17:16:55.621
injected. And then we'll remove
Yep, okay, injected, we'll

17051
17:16:55.621 --> 17:16:58.621
refresh, like, connect, and now
it says injected. Okay, cool. So

17052
17:16:58.621 --> 17:17:03.621
now we're connected here. If in
here, if I just switch accounts,

17053
17:17:03.621 --> 17:17:07.621
right, let's go to Account
three, I'll connect. If we go

17054
17:17:07.621 --> 17:17:10.621
back to our console real quick,
we'll say account change to

17055
17:17:10.621 --> 17:17:14.621
blah, blah, blah, I can change
back, right, we'll go change

17056
17:17:14.621 --> 17:17:17.621
account change to blah, blah,
blah. Now, if we go back to our

17057
17:17:17.621 --> 17:17:22.621
application, go in here. And we
disconnect. Now let's disconnect

17058
17:17:22.621 --> 17:17:27.621
both of these disconnect. And
disconnect. We'll see it's now

17059
17:17:27.621 --> 17:17:31.621
been removed from local storage.
And if we go to our console,

17060
17:17:31.621 --> 17:17:36.621
it'll say, no account, change
the No, no account found and

17061
17:17:36.621 --> 17:17:39.621
removed it. Now if I hit
refresh, nothing happens here, I

17062
17:17:39.621 --> 17:17:44.622
can go ahead and connect. Right
next connect, I can refresh.

17063
17:17:44.622 --> 17:17:47.622
Oops, I need to go back in here
and re enable this. So sorry,

17064
17:17:47.622 --> 17:17:51.622
let's add this back in here. But
now it can refresh. Let's go

17065
17:17:51.622 --> 17:17:56.622
ahead and disconnect here. Let's
connect. Let's go back to the

17066
17:17:56.622 --> 17:18:02.622
console, we can connect thing
will pop up next connect, I can

17067
17:18:02.622 --> 17:18:07.622
refresh. It stays connected for
me, I can switch accounts, I can

17068
17:18:07.622 --> 17:18:12.622
go ahead and here, I can switch
accounts, I can even disconnect.

17069
17:18:12.622 --> 17:18:15.622
And it will automatically update
for me, which is what we want.

17070
17:18:15.622 --> 17:18:19.622
So now we've essentially made a
way more robust connect button,

17071
17:18:19.622 --> 17:18:24.622
where it goes back and forth
with when we're connected now.

17072
17:18:24.622 --> 17:18:28.622
Now one more thing that we might
want to do, or application is

17073
17:18:28.622 --> 17:18:30.622
when we hit Connect, we want to
maybe disable this button,

17074
17:18:30.622 --> 17:18:34.622
right? We don't want it to allow
it to be able to be pressed. So

17075
17:18:34.622 --> 17:18:36.622
I'm gonna hit Cancel, we're just
gonna add one more bit of

17076
17:18:36.622 --> 17:18:42.622
functionality here, we're going
to add this is web three enable

17077
17:18:42.622 --> 17:18:46.622
loading. And what this does is
it just checks to see if

17078
17:18:46.622 --> 17:18:49.622
Metamask has popped up. And so
what our button after the on

17079
17:18:49.622 --> 17:18:55.622
click section, we can add
disabled. Equals is web three

17080
17:18:55.622 --> 17:18:58.622
enable loading, so it'll be
disabled if we're loading here.

17081
17:18:58.622 --> 17:19:02.622
So let's go ahead and we'll
disconnect disconnect. Now we'll

17082
17:19:02.622 --> 17:19:05.622
hit Connect, and you'll see the
button can be clicked. So that

17083
17:19:05.622 --> 17:19:09.622
just makes it a little bit nice.
Turn, Next connect Bada bing,

17084
17:19:09.622 --> 17:19:14.622
bada boom, awesome, we have just
made a way more robust front end

17085
17:19:14.622 --> 17:19:17.622
than what we had before this
connect button is super slick.

17086
17:19:17.622 --> 17:19:19.622
And it allows us to kind of flip
back and forth. And our

17087
17:19:19.622 --> 17:19:23.623
application is incredibly
powerful and knows how to handle

17088
17:19:23.623 --> 17:19:28.623
all these different changes. Now
that we've learned how to do it

17089
17:19:28.623 --> 17:19:31.623
the manual way, let me give you
the Chiti way, in our

17090
17:19:31.623 --> 17:19:34.623
components, we're gonna create a
new file header dot j s, and

17091
17:19:34.623 --> 17:19:37.623
what we're going to do is we're
going to install this web three

17092
17:19:38.623 --> 17:19:40.623
UI kit, it's a front end kit,
and it has a whole bunch of

17093
17:19:40.623 --> 17:19:43.623
these components already built
for us. So we can build like a

17094
17:19:43.623 --> 17:19:47.623
header component and a connect
button component just by using

17095
17:19:47.623 --> 17:19:50.623
this. So to install, install it,
we're gonna come back here,

17096
17:19:50.623 --> 17:19:53.623
we're gonna stop our front end.
And we're just going to run

17097
17:19:53.623 --> 17:19:58.623
yarn, add web three UI kit, like
that. And again, we don't want

17098
17:19:58.623 --> 17:20:01.623
this to be a dev dependency,
because it is going to be a part

17099
17:20:01.623 --> 17:20:04.623
of our website, and then we'll
do in our header.js, we'll do

17100
17:20:05.623 --> 17:20:12.623
import connect button from web
three UI kit. And then we'll do

17101
17:20:12.623 --> 17:20:19.623
export default function header.
And then all we'll do is return

17102
17:20:19.623 --> 17:20:24.623
do like a div. And then inside
this div, we'll do next button.

17103
17:20:24.623 --> 17:20:27.623
With a little backslash here, we
aren't going to need this for

17104
17:20:27.623 --> 17:20:29.623
this project. But if we want to
be super explicit, we'll say

17105
17:20:29.623 --> 17:20:34.623
Morales off equals false. Just
again, to reiterate, hey, we're

17106
17:20:34.623 --> 17:20:37.623
not trying to connect to a
server here just to make that

17107
17:20:37.623 --> 17:20:40.623
super explicit. But this connect
button does everything, this

17108
17:20:40.623 --> 17:20:44.623
manual header thing that we just
created, does. So back in our

17109
17:20:44.623 --> 17:20:50.623
index.js, we can comment or
delete this line will do import

17110
17:20:50.623 --> 17:20:56.623
header from dot dot slash
components slash header. And

17111
17:20:56.623 --> 17:21:01.623
then instead of manual header,
we'll just do header. We start

17112
17:21:01.623 --> 17:21:04.624
our app back up with yarn dev
again,

17113
17:21:04.624 --> 17:21:08.624
we go back to the page, we do a
little refresh here, we now see

17114
17:21:08.624 --> 17:21:10.624
we have this connect Wallet
button. And it's even looks a

17115
17:21:10.624 --> 17:21:13.624
lot nicer. It's got some nice
styling to it as well, we can

17116
17:21:13.624 --> 17:21:17.624
hit Connect wallet. And it'll
give us this little ngModel

17117
17:21:17.624 --> 17:21:20.624
asking us which wallet we want
to connect to. So asking us

17118
17:21:20.624 --> 17:21:23.624
which wall we want to connect to
is kind of similar in our manual

17119
17:21:23.624 --> 17:21:28.624
header to this or set item
connected, injected, right or

17120
17:21:28.624 --> 17:21:31.624
wallet connect, it would do
connected wallet Connect for

17121
17:21:31.624 --> 17:21:34.624
trust wallet, it would it would
set item as connected wallet

17122
17:21:34.624 --> 17:21:38.624
connect, etc. So it allows us to
connect in different ways. And

17123
17:21:38.624 --> 17:21:41.624
we if we hit Metamask, we go
ahead and connect like so even

17124
17:21:41.624 --> 17:21:45.624
had some nice styling here where
it gives us our wallet address

17125
17:21:45.624 --> 17:21:49.624
here. But it also gives us our
wallet balance as well. And

17126
17:21:49.624 --> 17:21:51.624
again, if we go ahead and
disconnect, we'll see it

17127
17:21:51.624 --> 17:21:54.624
automatically disconnect. We
connect like so we can reconnect

17128
17:21:54.624 --> 17:21:57.624
like so boom, boom. If we switch
accounts, it's smart enough to

17129
17:21:57.624 --> 17:22:00.624
know that we're switching
accounts. So I know I showed you

17130
17:22:00.624 --> 17:22:02.624
kind of the hard way. But I
wanted to show you kind of

17131
17:22:02.624 --> 17:22:05.624
what's going on. It's setting
this local storage in the

17132
17:22:05.624 --> 17:22:08.624
background so that it knows
which where it's actually

17133
17:22:08.624 --> 17:22:11.624
connected. But for headers
moving forward, this is all you

17134
17:22:11.624 --> 17:22:14.624
need. And your life will be
drastically drastically easier.

17135
17:22:14.624 --> 17:22:19.624
And let's just add a centralized
lottery or decentralized raffle

17136
17:22:19.624 --> 17:22:22.624
or whatever you want to our
header as well. So it says

17137
17:22:22.624 --> 17:22:27.624
decentralized lottery, you know
the button Hello. Now that we

17138
17:22:27.624 --> 17:22:30.624
have that, what else do we need?
Well, well, the main thing that

17139
17:22:30.624 --> 17:22:33.624
this app needs to do is just
have a big button that says

17140
17:22:33.624 --> 17:22:36.624
enter the lottery. And then
ideally, you know, show how many

17141
17:22:36.624 --> 17:22:38.624
people are in the lottery and
then the recent winner as well.

17142
17:22:38.624 --> 17:22:41.624
So let's go ahead, we'll create
a new component called lottery

17143
17:22:41.624 --> 17:22:44.625
entrance. And we'll grab that
component similar to like what

17144
17:22:44.625 --> 17:22:49.625
we did with our header, we'll
drop this component right here.

17145
17:22:49.625 --> 17:22:51.625
And then our app will pretty
much be done. So let's create

17146
17:22:51.625 --> 17:22:57.625
this lottery entrance component,
lottery entrance, that Jas,

17147
17:22:57.625 --> 17:22:59.625
right and again, in the reason
we're putting these in

17148
17:22:59.625 --> 17:23:02.625
components, we could 100% Stick
it all, you know all our code in

17149
17:23:02.625 --> 17:23:05.625
here to make it more modular so
that we in the future, if we

17150
17:23:05.625 --> 17:23:08.625
want to have more pages or do
other stuff, I'm going to zoom

17151
17:23:08.625 --> 17:23:11.625
out a little bit just so that we
can see all of our code a little

17152
17:23:11.625 --> 17:23:14.625
bit easier. This is our whole
index j s. This is our whole

17153
17:23:14.625 --> 17:23:18.625
header. Let's create a new
lottery entrance app just for

17154
17:23:18.625 --> 17:23:24.625
the boilerplate code here we're
going to export default lottery

17155
17:23:24.625 --> 17:23:28.625
entrance, excuse me, export
default function, lottery

17156
17:23:28.625 --> 17:23:31.625
entrance, and this is just going
to be you know, another

17157
17:23:31.625 --> 17:23:35.625
component where we're going to
return some that JSX HTML stuff,

17158
17:23:35.625 --> 17:23:40.625
right? So we're gonna do div and
do like hi from lottery

17159
17:23:40.625 --> 17:23:45.625
entrance, Excel. And now that we
do that, we can go back to our

17160
17:23:45.625 --> 17:23:51.625
index.js. We can do import
lottery entrance from dot dot

17161
17:23:51.625 --> 17:23:57.625
slash components. Slash lottery
entrance, will stick it right

17162
17:23:57.625 --> 17:24:01.625
underneath the header like that.
And if we go back to our

17163
17:24:01.625 --> 17:24:05.625
website, we see high from
lottery entrance so our lottery

17164
17:24:05.625 --> 17:24:07.625
entrance is going to be right
underneath the header would

17165
17:24:07.625 --> 17:24:09.625
Here's what we want. And then
we'll delete this line that

17166
17:24:09.625 --> 17:24:12.625
says, Hello. So lottery
entrance, what is the what is

17167
17:24:12.625 --> 17:24:15.625
the first thing that we really
need to do in here? Well, we're

17168
17:24:15.625 --> 17:24:21.625
going to want to have a function
to call the lottery to enter the

17169
17:24:21.625 --> 17:24:24.626
lottery. Let's go ahead and do
this. Now let's go back to how

17170
17:24:24.626 --> 17:24:28.626
we did this with HTML fund me
recall that old fun function

17171
17:24:28.626 --> 17:24:31.626
like this, but doing it like
this won't rerender. And there's

17172
17:24:31.626 --> 17:24:33.626
a whole lot of other
functionality that doing it like

17173
17:24:33.626 --> 17:24:37.626
this won't give us so we're
going to use Morales to actually

17174
17:24:37.626 --> 17:24:40.626
call some of these functions,
because mirallas has in React

17175
17:24:40.626 --> 17:24:43.626
mirallas. Again, they have hooks
for us to do pretty much

17176
17:24:43.626 --> 17:24:47.626
anything we want to do. And one
of these hooks is called use web

17177
17:24:47.626 --> 17:24:50.626
three contract. And what this
does is it gives us a hook that

17178
17:24:50.626 --> 17:24:55.626
will give us the data returned
from a function called an error

17179
17:24:55.626 --> 17:24:59.626
returned, a little function that
we can use to call any function.

17180
17:24:59.626 --> 17:25:02.626
And then we also have these
really helpful is fetching in is

17181
17:25:02.626 --> 17:25:06.626
loading. So if we want everyone
to have our UI or our website,

17182
17:25:06.626 --> 17:25:09.626
do something while it's fetching
or while it's loading the

17183
17:25:09.626 --> 17:25:12.626
transaction, we can use these
two variables to do that. And

17184
17:25:12.626 --> 17:25:14.626
then all we need to do is we
just need to pass it the

17185
17:25:14.626 --> 17:25:17.626
contract information, which
similar to ethers is going to be

17186
17:25:17.626 --> 17:25:21.626
the ABI contract address, we'll
pass the function name, and then

17187
17:25:21.626 --> 17:25:24.626
any parameters for that
function. So we're going to use

17188
17:25:24.626 --> 17:25:28.626
this syntax here to make that
transaction to the blockchain.

17189
17:25:28.626 --> 17:25:30.626
And to call these functions. So
what we're going to do is we're

17190
17:25:30.626 --> 17:25:35.626
going to import us web three
contract

17191
17:25:35.626 --> 17:25:40.626
from react mirallas. And inside
our function, but before I

17192
17:25:40.626 --> 17:25:44.626
return, of course, we're going
to say const. And then we'll do

17193
17:25:44.626 --> 17:25:47.626
kind of exactly what we see in
here. For now, let's just get

17194
17:25:47.626 --> 17:25:50.626
the function, let's just get
this run contract function,

17195
17:25:50.626 --> 17:25:53.626
because this is going to be the
function that we can call to

17196
17:25:53.626 --> 17:25:57.626
actually enter the lottery. So
we'll say const, run contract

17197
17:25:57.626 --> 17:26:00.626
function, and we're actually
going to call this enter raffle.

17198
17:26:00.626 --> 17:26:05.627
And we'll say equals, use web
three contract, and we need to

17199
17:26:05.627 --> 17:26:11.627
pass the ABI, we're gonna need
to pass the contract address,

17200
17:26:11.627 --> 17:26:14.627
we're gonna need to give it the
function name, we'll need to

17201
17:26:14.627 --> 17:26:17.627
give it the params, which
actually we do know it's going

17202
17:26:17.627 --> 17:26:20.627
to be blank. But then finally,
we will need the message value.

17203
17:26:20.627 --> 17:26:23.627
Because if we remember back into
raffle doesn't take any

17204
17:26:23.627 --> 17:26:27.627
parameters, all it takes is this
message dot value bit. So that's

17205
17:26:27.627 --> 17:26:33.627
all we're going to need to pass.
So how do we get all this stuff,

17206
17:26:33.627 --> 17:26:35.627
and I'm going to leave this in
here. But we're going to comment

17207
17:26:35.627 --> 17:26:39.627
it out for now, because this is
what we need to do. But we need

17208
17:26:39.627 --> 17:26:42.627
to get all of this stuff into
our code here. So how do we

17209
17:26:42.627 --> 17:26:46.627
actually get all that stuff?
Well, ABI is easy, right? Abi

17210
17:26:46.627 --> 17:26:49.627
isn't going to change at all, no
matter what network or on ABI is

17211
17:26:49.627 --> 17:26:52.627
always going to stay the same.
Now if you've already deployed

17212
17:26:52.627 --> 17:26:55.627
your smart contracts, and you
know exactly what address it is,

17213
17:26:55.627 --> 17:26:57.627
because you've deployed to a
main net, or you've deployed to

17214
17:26:57.627 --> 17:27:00.627
a test net, all this stuff isn't
really going to change. And we

17215
17:27:00.627 --> 17:27:04.627
can just hard code it all right
into here. Or we can do what a

17216
17:27:04.627 --> 17:27:06.627
lot of people do is they'll
create a constants folder. And

17217
17:27:06.627 --> 17:27:12.627
in here, they'll add like an API
dot JSON, maybe they'll add a

17218
17:27:12.627 --> 17:27:16.627
contract addresses dot JSON. And
then they'll add maybe like an

17219
17:27:16.627 --> 17:27:19.627
index dot j s or something,
we're gonna build our

17220
17:27:19.627 --> 17:27:23.627
application in a way we can
actually test locally using our

17221
17:27:23.627 --> 17:27:26.627
own Hard Hat Network, and then
compare it to what it looks like

17222
17:27:26.627 --> 17:27:28.627
on the actual test net as well.
So we're going to make it

17223
17:27:28.627 --> 17:27:31.627
network agnostic. So the front
end works exactly the same no

17224
17:27:31.627 --> 17:27:34.627
matter what network that we're
on. And we can go back, download

17225
17:27:34.627 --> 17:27:39.627
a directory back into our CD,
hard hat smart contract lottery

17226
17:27:39.627 --> 17:27:44.628
Free Code Camp, and spin up our
node here, right with hh node or

17227
17:27:44.628 --> 17:27:48.628
yarn hard hat node. And we'll
use this as the blockchain that

17228
17:27:48.628 --> 17:27:51.628
we're going to connect to. The
thing is, if I go back here, and

17229
17:27:51.628 --> 17:27:53.628
I'm building the front end, and
I go, ah, like this would be

17230
17:27:53.628 --> 17:27:57.628
better if we did X, Y, or Z. And
maybe I changed the name of some

17231
17:27:57.628 --> 17:28:00.628
functions, you know, blah, blah,
blah, something else, I want

17232
17:28:00.628 --> 17:28:04.628
that change to be reflected on
my front end. And I want to be

17233
17:28:04.628 --> 17:28:07.628
able to code my front end as
such. So since we are the only

17234
17:28:07.628 --> 17:28:10.628
developer right now, we kind of
have the ability of where we

17235
17:28:10.628 --> 17:28:13.628
both know, the back end code and
the front end code. So something

17236
17:28:13.628 --> 17:28:16.628
that I like to do to make my
life a little bit easier is I

17237
17:28:16.628 --> 17:28:20.628
like to create an update front
end deploy script. So after we

17238
17:28:20.628 --> 17:28:24.628
deploy stuff, we run a little
script that will create this

17239
17:28:24.628 --> 17:28:27.628
constants folder for us with a
whole bunch of stuff, right?

17240
17:28:27.628 --> 17:28:30.628
It'll give an ABI, it'll give
contract addresses and anything

17241
17:28:30.628 --> 17:28:34.628
else we might need in our front
end from our back end. So what I

17242
17:28:34.628 --> 17:28:38.628
like to do is I like to come
back to my original code and an

17243
17:28:38.628 --> 17:28:42.628
update this for a new script. So
I'll come in here in this deploy

17244
17:28:42.628 --> 17:28:46.628
script, I'll create a new file,
and I'll call it oh two or even

17245
17:28:46.628 --> 17:28:54.628
like 9999, up, date, front, and
dot Jas. And the reason I do 99,

17246
17:28:54.628 --> 17:28:57.628
obviously, is because we want
this to be always the last

17247
17:28:57.628 --> 17:28:59.628
script in our deploy folder. And
then we can just write a little

17248
17:28:59.628 --> 17:29:03.628
script that's connected. We just
write a little script that's

17249
17:29:03.628 --> 17:29:06.628
connected to our front end here
so that whenever we deploy

17250
17:29:06.628 --> 17:29:09.628
contracts, no matter what chain,
we can update that constants

17251
17:29:09.628 --> 17:29:12.628
folder on our front end. So
let's go ahead and create that

17252
17:29:12.628 --> 17:29:17.628
script right now we'll do module
dot exports, equals async

17253
17:29:17.628 --> 17:29:21.628
function. And we'll add all our
stuff in here, we don't really

17254
17:29:21.628 --> 17:29:24.629
need to deploy any contracts,
because we're just updating the

17255
17:29:24.629 --> 17:29:26.629
front end. So we can just leave
the parameters of this one

17256
17:29:26.629 --> 17:29:30.629
blank. And the other thing I
like to do, because sometimes I

17257
17:29:30.629 --> 17:29:34.629
don't care about the front end,
what I'll do is I'll only update

17258
17:29:34.629 --> 17:29:37.629
the front end if we've specified
a dot env variable. So I'll

17259
17:29:38.629 --> 17:29:43.629
create a dot env variable called
up date, front end. And then

17260
17:29:43.629 --> 17:29:47.629
I'll set this to true. And now
in our script here, we can say

17261
17:29:47.629 --> 17:29:53.629
if process dot E and V dot
update, front end. And we can

17262
17:29:53.629 --> 17:29:58.629
just say like console dot log,
updating front end. And now back

17263
17:29:58.629 --> 17:30:01.629
in here, right, if a mat if I'm
in the correct directory in

17264
17:30:01.629 --> 17:30:05.629
here, if our own hard hit
Deploy,

17265
17:30:05.629 --> 17:30:07.629
you know, get this little
updating front end. And now we

17266
17:30:07.629 --> 17:30:10.629
can update front end. So let's
do it. So I'm actually going to

17267
17:30:10.629 --> 17:30:15.629
create one function called
Update contract addresses. And

17268
17:30:15.629 --> 17:30:17.629
this is going to be our function
that we're going to use to

17269
17:30:17.629 --> 17:30:19.629
update contract addresses, then
I'm going to make one called

17270
17:30:19.629 --> 17:30:23.629
Update API, where we just update
the API's and the front end so

17271
17:30:23.629 --> 17:30:25.629
so we're going to call this
update contract addresses. So

17272
17:30:25.629 --> 17:30:29.629
I'm going to create a new
function async function, update

17273
17:30:29.629 --> 17:30:35.629
contract addresses. And first,
we're going to get that raffle

17274
17:30:35.629 --> 17:30:37.629
contract since we're going to
need to get its address. So

17275
17:30:37.629 --> 17:30:40.629
we're gonna say const, raffle
equals await. And we're gonna do

17276
17:30:40.629 --> 17:30:45.629
the same thing we've been doing
ethers dot get contract, raffle,

17277
17:30:45.629 --> 17:30:48.629
and then my VS code auto
imported, it doesn't const

17278
17:30:48.629 --> 17:30:51.629
ethers equals require Hardhead,
like so. So we have raffle in

17279
17:30:51.629 --> 17:30:55.629
here. And we're gonna want to
pass this raffle address to our

17280
17:30:55.629 --> 17:30:58.629
front end, since this is going
to be a variable that we might

17281
17:30:58.629 --> 17:31:03.630
use a lot of places, we can just
add it like const, front end

17282
17:31:03.630 --> 17:31:07.630
location, addresses file,
equals, and we're going to give

17283
17:31:07.630 --> 17:31:10.630
it the relative path to where we
are now, which is going to be

17284
17:31:10.630 --> 17:31:15.630
you know, if we see the download
directory to next year's smart

17285
17:31:15.630 --> 17:31:20.630
contract lottery, FCC, I can
even just copy this, paste that

17286
17:31:20.630 --> 17:31:23.630
in here. And then it's in the
constants folder, and it's going

17287
17:31:23.630 --> 17:31:28.630
to be contract addresses dot
JSON. And let's get the ABI

17288
17:31:28.630 --> 17:31:35.630
file, we'll say const. Front and
a bi file is going to equal and

17289
17:31:35.630 --> 17:31:38.630
this is going to be nearly the
same thing. So we can just copy

17290
17:31:38.630 --> 17:31:44.630
paste that. And then we'll do
slash API dot JSON. And now in

17291
17:31:44.630 --> 17:31:48.630
our update contract addresses
function, we can say const,

17292
17:31:48.630 --> 17:31:55.630
current addresses, equals and we
can read again, in our front

17293
17:31:55.630 --> 17:31:58.630
end, we can read from this file.
So I'll usually start out with

17294
17:31:58.630 --> 17:32:01.630
just two brackets. So that's
like JSON compatible in both of

17295
17:32:01.630 --> 17:32:05.630
these files. And so to read it,
we're gonna say JSON dot parse,

17296
17:32:05.630 --> 17:32:11.630
FS dot read file sync, we're
gonna have to import, say const.

17297
17:32:11.630 --> 17:32:16.630
FS equals require, I know we've
used Fs extra in the past, but

17298
17:32:16.630 --> 17:32:19.630
this one, we're just gonna use
Fs, which is going to be our

17299
17:32:19.630 --> 17:32:27.630
front and addresses file, we're
going to read it in with UTF

17300
17:32:27.630 --> 17:32:29.630
eight encoding. So now this is
going to be our current

17301
17:32:29.630 --> 17:32:32.630
addresses. And we're going to
update the list of current

17302
17:32:32.630 --> 17:32:35.630
addresses with some new
addresses. Because our contract

17303
17:32:35.630 --> 17:32:37.630
addresses we want this to be
chain agnostic, we would do

17304
17:32:37.630 --> 17:32:40.630
something like for you know, and
then the addresses on rink B, we

17305
17:32:40.630 --> 17:32:45.631
could do 31337, and then the
addresses on our local host,

17306
17:32:45.631 --> 17:32:48.631
right, we want to be able to
keep track of all the different

17307
17:32:48.631 --> 17:32:51.631
addresses across all the
different chains. So back in our

17308
17:32:51.631 --> 17:32:58.631
function here, then we'll say if
if network, dot config dot chain

17309
17:32:58.631 --> 17:33:05.631
id.to string in contract
addresses that were config ideas

17310
17:33:05.631 --> 17:33:08.631
in there, then we're just gonna
go ahead and add this new

17311
17:33:08.631 --> 17:33:11.631
contract address in there. But
before we add this new address

17312
17:33:11.631 --> 17:33:13.631
in there, let's just check to
make sure it's not are already

17313
17:33:13.631 --> 17:33:18.631
in there. So we're just gonna
say if contract addresses of

17314
17:33:18.631 --> 17:33:23.631
network dot config dot chain
id.to string, this is so long, I

17315
17:33:23.631 --> 17:33:25.631
don't want to keep writing that
I'm gonna say const chain ID

17316
17:33:25.631 --> 17:33:31.631
equals network, config that
chain id.to string, and we're

17317
17:33:31.631 --> 17:33:36.631
just gonna use chain ID. If
chain ID and contract address

17318
17:33:36.631 --> 17:33:41.631
then if we don't already have
that includes raffle dot

17319
17:33:41.631 --> 17:33:51.631
address. We're gonna go ahead
and add this new address and

17320
17:33:51.631 --> 17:33:54.631
then if the chain ID doesn't
even exist, we're gonna go ahead

17321
17:33:54.631 --> 17:34:01.631
and do contract addresses
current addresses, equals or

17322
17:34:01.631 --> 17:34:05.631
assuming current addresses of
chain ID equals and then we'll

17323
17:34:05.631 --> 17:34:08.631
just create a new array, raffled
that out address. So we're

17324
17:34:08.631 --> 17:34:10.631
saying if the chain ID doesn't
exist in current addresses,

17325
17:34:10.631 --> 17:34:13.631
we're just going to add this new
array in there. And then

17326
17:34:13.631 --> 17:34:16.631
finally, now that we've updated
its object, we're gonna write it

17327
17:34:16.631 --> 17:34:22.631
back to this file, we'll say Fs
dot write, file sync, front and

17328
17:34:22.631 --> 17:34:26.632
addresses file. And then we're
gonna do JSON dot string of

17329
17:34:26.632 --> 17:34:29.632
five. So we're going to
Stringify this JSON object, so

17330
17:34:29.632 --> 17:34:32.632
we're just gonna go ahead and
write it back. And then bottom

17331
17:34:32.632 --> 17:34:39.632
module that exports that tags
equals all and then front end. I

17332
17:34:39.632 --> 17:34:41.632
cool. So we have a function to
update the contract addresses,

17333
17:34:41.632 --> 17:34:46.632
but we also need the ABI. So
we're gonna do date API, and

17334
17:34:46.632 --> 17:34:50.632
we're gonna create another
function async function, update

17335
17:34:50.632 --> 17:34:54.632
API. And in here, we're gonna do
the exact same thing on raffle

17336
17:34:54.632 --> 17:35:00.632
equals await ethers that
contract,

17337
17:35:00.632 --> 17:35:08.632
raffle FX dot right file, sync,
front and abi. It's just going

17338
17:35:08.632 --> 17:35:13.632
to copy paste it front end, AVI
file. And then to pass just the

17339
17:35:13.632 --> 17:35:16.632
ABI, we can actually get it
directly from this raffle

17340
17:35:16.632 --> 17:35:23.632
object, we can actually just do
raffle dot interface that format

17341
17:35:23.632 --> 17:35:29.632
ethers dot utils, dot format
types, dot JSON. If you look in

17342
17:35:29.632 --> 17:35:32.632
the ethers, Docs, ethers has
this contract dot interface

17343
17:35:32.632 --> 17:35:35.632
thing which returns an interface
which is different from a

17344
17:35:35.632 --> 17:35:38.632
solidity interface. But it
allows us basically just to get

17345
17:35:38.632 --> 17:35:41.632
the API with this one line of
code. So in our back end code

17346
17:35:41.632 --> 17:35:46.632
here, now if you run h h deploy
or H H node, we should

17347
17:35:46.632 --> 17:35:50.632
automatically update our
contract addresses in our API

17348
17:35:50.632 --> 17:35:55.632
dot JSON. So let's go and try
this. So we'll run h h node. So

17349
17:35:55.632 --> 17:35:58.632
we'll start a node, right in
this terminal over here, we'll

17350
17:35:58.632 --> 17:36:03.633
flip back to the front end. And
if we open ABI to JSON, we do

17351
17:36:03.633 --> 17:36:07.633
indeed, now see, we have the
raffle API in this file. And if

17352
17:36:07.633 --> 17:36:12.633
we go to contract addresses, we
see on network 31337, here's our

17353
17:36:12.633 --> 17:36:15.633
first address, right. And if we
deploy to different chains, this

17354
17:36:15.633 --> 17:36:18.633
will get populated with
different network IDs, and then

17355
17:36:18.633 --> 17:36:21.633
a list of addresses associated
with them. So it helps make our

17356
17:36:21.633 --> 17:36:25.633
front ends a lot easier to
maintain, and bounce around and

17357
17:36:25.633 --> 17:36:27.633
kind of test and work with. Now
that we've done all this, we can

17358
17:36:27.633 --> 17:36:31.633
actually close our hardhat smart
contract lottery Free Code Camp,

17359
17:36:31.633 --> 17:36:33.633
the hard hat project for this,
and we're just going to have all

17360
17:36:33.633 --> 17:36:37.633
of our terminals be in here. So
what we're gonna do is we're

17361
17:36:37.633 --> 17:36:40.633
gonna go down and directory CD
dot dot, and we're going to cd

17362
17:36:40.633 --> 17:36:44.633
into Oh, sorry, we're actually
we're already in their CDs, hard

17363
17:36:44.633 --> 17:36:47.633
hat, smart contract, lottery
Free Code Camp. And then in this

17364
17:36:47.633 --> 17:36:51.633
one, we're going to run hh node
or yarn hardhat node. Now we'll

17365
17:36:51.633 --> 17:36:55.633
have a local blockchain running
so we can test everything that

17366
17:36:55.633 --> 17:36:57.633
we're doing in the front end,
actually, I'm gonna move this up

17367
17:36:57.633 --> 17:37:01.633
one. So now in our first area,
here, we have our front end code

17368
17:37:01.633 --> 17:37:05.633
running, then we have our
blockchain running. And then in

17369
17:37:05.633 --> 17:37:07.633
this one, we're just going to
add, you know, whatever we want

17370
17:37:07.633 --> 17:37:09.633
to add. Now, we can actually go
ahead and hit this little X

17371
17:37:09.633 --> 17:37:13.633
button here to close the panel.
So that's just hiding the panel,

17372
17:37:13.633 --> 17:37:15.633
these are all still out, they
only get trashed when you

17373
17:37:15.633 --> 17:37:17.633
actually hit the little
trashcan. So we're just going to

17374
17:37:17.633 --> 17:37:20.633
close the panel. But all those
terminals are still running, I

17375
17:37:20.633 --> 17:37:24.633
promise back. So where were we?
Okay, back to our function here.

17376
17:37:24.633 --> 17:37:28.633
So we just automated the process
of updating our API's and then

17377
17:37:28.633 --> 17:37:31.633
updating our contracts as well.
And now we can import these into

17378
17:37:31.633 --> 17:37:34.633
our files. Now we can import
them one at a time, it'd be like

17379
17:37:34.633 --> 17:37:41.633
import API, from dot dot slash
constants, slash API, or we

17380
17:37:41.633 --> 17:37:44.634
could do something a little bit
clever is we could export these

17381
17:37:44.634 --> 17:37:47.634
in the same file. So if we
create a new file, a new

17382
17:37:47.634 --> 17:37:51.634
index.js, in here, we can import
them and then export them in

17383
17:37:51.634 --> 17:37:55.634
this one file. We can say const,
contract editor says equals

17384
17:37:55.634 --> 17:38:02.634
require dot slash contract
editor dot JSON, and then const

17385
17:38:02.634 --> 17:38:08.634
API equals require dot slash API
dot JSON. And then we'll do

17386
17:38:08.634 --> 17:38:14.634
module dot exports equals API
and contract addresses. So now

17387
17:38:14.634 --> 17:38:17.634
once we export them like this
back in our lottery entrance, we

17388
17:38:17.634 --> 17:38:22.634
can import them just in one
line. So we'll say import API

17389
17:38:22.634 --> 17:38:29.634
comma contract addresses from
dot dot slash constants. So we

17390
17:38:29.634 --> 17:38:32.634
can just specify the folder
instead of each individual

17391
17:38:32.634 --> 17:38:35.634
files, because we have this
index dot j s here, which

17392
17:38:35.634 --> 17:38:40.634
basically represents this whole
folder. Back in here, what do we

17393
17:38:40.634 --> 17:38:44.634
have now? Let's uncomment this
abi. Okay, great. We have the

17394
17:38:44.634 --> 17:38:48.634
ABI we're importing it from our
constants, folder, contract

17395
17:38:48.634 --> 17:38:51.634
addresses, we have our contract
addresses. And we're going to

17396
17:38:51.634 --> 17:38:56.634
need to specify the network ID
in just a second here. We have

17397
17:38:56.634 --> 17:38:59.634
the function name here, which is
going to be what enter the

17398
17:38:59.634 --> 17:39:04.634
raffle. There are no params. So
all we need to do so how do we

17399
17:39:04.634 --> 17:39:09.634
get both the chain ID and then
Also the message dot value will

17400
17:39:09.634 --> 17:39:11.634
change, it is something that we
can get really easily with

17401
17:39:11.634 --> 17:39:14.634
Morales, let's comment this
whole section out one more time,

17402
17:39:14.634 --> 17:39:18.634
just so I can show you something
we can do import. Once again,

17403
17:39:18.634 --> 17:39:25.635
we're going to get that use
Morales book from react Morales.

17404
17:39:25.635 --> 17:39:29.635
And what we can do is we can say
const.

17405
17:39:29.635 --> 17:39:37.635
Chain ID equals use ralis. Now,
the reason morality knows about

17406
17:39:37.635 --> 17:39:40.635
what chain we're on is because
back in our header component,

17407
17:39:40.635 --> 17:39:44.635
the header actually passes up
all the information about the

17408
17:39:44.635 --> 17:39:48.635
Metamask to the Morales
provider. And then the Morales

17409
17:39:48.635 --> 17:39:52.635
provider passes it down to all
the components inside those

17410
17:39:52.635 --> 17:39:56.635
Morales provided tags
concentrated equals use Morales.

17411
17:39:56.635 --> 17:39:59.635
And I'm just gonna do a little
console log chain ID because I

17412
17:39:59.635 --> 17:40:02.635
want to show you what it looks
like. So if we do a little

17413
17:40:02.635 --> 17:40:05.635
refresh, and we're in the
console here, we can ignore some

17414
17:40:05.635 --> 17:40:09.635
of these warnings here, but we
see the chain ID is actually 0x

17415
17:40:09.635 --> 17:40:12.635
Five, well, because I'm on the
rink B chain or the Grilley

17416
17:40:12.635 --> 17:40:15.635
chain excuse me, if I switch
back to hard hat localhost,

17417
17:40:15.635 --> 17:40:17.635
which you should know how to do
from a SEMA fun we bet if you

17418
17:40:17.635 --> 17:40:20.635
don't have hard hat localhost
and your Metamask go back to

17419
17:40:20.635 --> 17:40:23.635
that HTML font we bit follow
that along. Okay, great. Now

17420
17:40:23.635 --> 17:40:26.635
it's going to print this Oh x
bla bla bla bla bla. So that

17421
17:40:26.635 --> 17:40:30.635
might be a little bit confusing.
But this is the hex version of

17422
17:40:30.635 --> 17:40:34.635
our chain ID. Right. So let's
switch to Etherium main net. Now

17423
17:40:34.635 --> 17:40:37.635
we pronounce Oh x one, right?
Oh, x one is the hex version of

17424
17:40:37.635 --> 17:40:42.635
the number one. So chain ID
gives us the hex addition of the

17425
17:40:42.635 --> 17:40:45.635
chain ID. So I don't want the
hex addition, I want the actual

17426
17:40:45.635 --> 17:40:48.635
number. So what I'm going to do
is I'm going to say Okay, chain

17427
17:40:48.635 --> 17:40:52.635
ID, your name is actually going
to be chain ID hex. And we can

17428
17:40:52.635 --> 17:40:55.635
do console dot log chain ID hex,
but I want the number. So what

17429
17:40:55.635 --> 17:41:02.635
we can do is parse a built in
JavaScript parse int, CIN ID hex

17430
17:41:02.635 --> 17:41:06.636
like that. Now if I go back,
we'll do a little refresh here.

17431
17:41:06.636 --> 17:41:09.636
Scroll away from the warning, we
can see the one here. Now let's

17432
17:41:09.636 --> 17:41:14.636
switch to hard hat, localhost.
We'll scroll down we see 31337.

17433
17:41:14.636 --> 17:41:18.636
So use Morales chain ID returns
the hex we parse it with Parson

17434
17:41:18.636 --> 17:41:21.636
to get the actual number. Okay,
great. So we can stick the chain

17435
17:41:21.636 --> 17:41:24.636
ID into here. Now this raffle
address is something that we're

17436
17:41:24.636 --> 17:41:26.636
actually going to use a lot, we
might as well have it be at the

17437
17:41:26.636 --> 17:41:30.636
top of our code here, we aren't
going to be changing the raffle

17438
17:41:30.636 --> 17:41:32.636
address. So we don't need to put
it in a hook. We are going to

17439
17:41:32.636 --> 17:41:35.636
technically be changing the
address when we change networks.

17440
17:41:35.636 --> 17:41:39.636
But our header app takes care of
re rendering and dealing with

17441
17:41:39.636 --> 17:41:41.636
all that. So we can just make
this a constant variable. So we

17442
17:41:41.636 --> 17:41:47.636
can say const, raffle address
equals, first let's check the

17443
17:41:47.636 --> 17:41:50.636
chain ID hex and if there's a
chain ID hex and if there's not

17444
17:41:50.636 --> 17:41:52.636
a chain ID hex we're gonna do
something else. Excuse me, we're

17445
17:41:52.636 --> 17:41:56.636
gonna say chain ID hex in
contract addresses. And

17446
17:41:56.636 --> 17:41:58.636
actually, there's never gonna be
a chain ID hex. So we'll do

17447
17:41:58.636 --> 17:42:04.636
const chain ID equals Gen ID hex
parsed, Parsons, chinati hex,

17448
17:42:04.636 --> 17:42:06.636
and you might be thinking, hey,
this, these are both the same

17449
17:42:06.636 --> 17:42:09.636
name. Well, what we're doing up
here in use Morales is we're

17450
17:42:09.636 --> 17:42:13.636
saying hey, pull out the chin ID
object, and then rename it to

17451
17:42:13.636 --> 17:42:15.636
chain ID hex and down here,
we're saying, Hey, we're going

17452
17:42:15.636 --> 17:42:19.636
to create a new variable called
Chain ID. So we'll say contract

17453
17:42:19.636 --> 17:42:26.636
addresses of chain ID at zero.
So in here, we're saying this

17454
17:42:26.636 --> 17:42:30.636
network ID and this address,
otherwise, we'll just say no.

17455
17:42:30.636 --> 17:42:34.636
Okay, we're getting there. Let's
uncomment this, now we have the

17456
17:42:34.636 --> 17:42:37.636
raffle address, and we can just
stick it in here. All we do now

17457
17:42:37.636 --> 17:42:42.636
is the message dot value. If we
remember back to our raffle, we

17458
17:42:42.636 --> 17:42:46.637
actually set that fee
dynamically. So we have in here

17459
17:42:46.637 --> 17:42:48.637
we do entrance fee equals
entrance fee, which is the

17460
17:42:48.637 --> 17:42:51.637
parameter in the constructor. So
we want to call this get

17461
17:42:51.637 --> 17:42:54.637
entrance fee function. This is
one of the ways we can send a

17462
17:42:54.637 --> 17:42:57.637
transaction. And we can also
send functions, one of the ways

17463
17:42:57.637 --> 17:43:01.637
that we're going to do it right
when our lottery entrance loads,

17464
17:43:01.637 --> 17:43:05.637
we're going to run a function to
read that entrance fee value. So

17465
17:43:05.637 --> 17:43:08.637
how do we do that? Well, we can
use one of our hooks again,

17466
17:43:08.637 --> 17:43:11.637
right use effect use effect can
run right when something

17467
17:43:11.637 --> 17:43:13.637
changes, we're only going to
want to try to get that raffle

17468
17:43:13.637 --> 17:43:17.637
entrance fee if web three is
enabled. So what we can do is

17469
17:43:17.637 --> 17:43:21.637
back up in here and use Morales
will pull in that is web three

17470
17:43:21.637 --> 17:43:25.637
enabled. And we'll have our use
effect in our function, we'll

17471
17:43:25.637 --> 17:43:32.637
just say if this is web three
enabled, then we'll try to read.

17472
17:43:32.637 --> 17:43:36.637
So we can go ahead and use this
use web three, contract Wagan.

17473
17:43:36.637 --> 17:43:38.637
Let's go ahead and just copy
paste this. And we'll use the

17474
17:43:38.637 --> 17:43:44.637
same setup here. Except instead
of enter raffle, of course,

17475
17:43:44.637 --> 17:43:48.637
we're going to be doing get
entrance fee. So we're going to

17476
17:43:48.637 --> 17:43:52.637
get entrance fee. We need the
API we got it raffle address got

17477
17:43:52.637 --> 17:43:55.637
it. This is going to be the
function name is going to be get

17478
17:43:55.637 --> 17:43:59.637
entrance fee params nothing
message that value, nothing.

17479
17:43:59.637 --> 17:44:02.637
We're going to be calling this
get entrance fee function. And

17480
17:44:02.637 --> 17:44:05.637
now I finally show you how to
actually call one of these in

17481
17:44:05.637 --> 17:44:09.637
our contracts here. Use web
three contract, download our use

17482
17:44:09.637 --> 17:44:12.637
effect, we're actually going to
call get entrance fee. Now if we

17483
17:44:12.637 --> 17:44:15.637
just call get entrance fee like
this, and we say like, you know,

17484
17:44:15.637 --> 17:44:19.637
const something equals get
entrance fee and then console

17485
17:44:19.637 --> 17:44:22.637
dot log something, what do you
think's going to happen? And

17486
17:44:22.637 --> 17:44:27.638
oops, I need to import, I need
to import use effect from react.

17487
17:44:27.638 --> 17:44:33.638
There we go. We look or logs, I
don't see console dot log,

17488
17:44:33.638 --> 17:44:36.638
something won't get entrance fee
is going to be an async

17489
17:44:36.638 --> 17:44:40.638
function. Once again, we need to
wait we would need to do a wait

17490
17:44:40.638 --> 17:44:43.638
get into T, right? There's an
issue we can't call await in our

17491
17:44:43.638 --> 17:44:47.638
use effect. So what can we do?
Well, we can actually make an

17492
17:44:47.638 --> 17:44:52.638
async function, call it update
UI. And then we can stick this

17493
17:44:52.638 --> 17:44:57.638
inside of the async function
here. And we can call update UI

17494
17:44:57.638 --> 17:45:00.638
right outside of it like this.
So now we go back to our front

17495
17:45:00.638 --> 17:45:03.638
end, we do a little refresh. And
if we scroll up, we still see

17496
17:45:03.638 --> 17:45:07.638
nothing. Well, is web three
enabled actually changes. So the

17497
17:45:07.638 --> 17:45:11.638
first time that this runs, is
web three enabled probably is

17498
17:45:11.638 --> 17:45:15.638
false. But when it turns to
true, we want to we want to run

17499
17:45:15.638 --> 17:45:18.638
this section in our little
dependency array. We're going to

17500
17:45:18.638 --> 17:45:21.638
add this in here, right? And the
reason that it's false to start

17501
17:45:21.638 --> 17:45:25.638
with is because of exactly what
we showed in that manual header,

17502
17:45:25.638 --> 17:45:28.638
right? What does it do? Well,
first, we check to see after we

17503
17:45:28.638 --> 17:45:31.638
do a refresh, if window dot
local storage get item is

17504
17:45:31.638 --> 17:45:34.638
connected, then we call Enable
Web three, which will make this

17505
17:45:34.638 --> 17:45:37.638
enabled. So in our lottery
entrance, is what they're

17506
17:45:38.638 --> 17:45:42.638
enabled starts off as false when
we do a refresh. And then the

17507
17:45:42.638 --> 17:45:45.638
browser checks the local storage
says, oh, web three should be

17508
17:45:45.638 --> 17:45:48.638
enabled, let's enable it and
turn to true. So now if we hit

17509
17:45:48.638 --> 17:45:52.638
save, and we do a little refresh
in our console, we can now see

17510
17:45:52.638 --> 17:45:56.638
the logged out entrance fee. So
then we'll switch this to

17511
17:45:56.638 --> 17:46:03.638
entrance fee from contract. Now,
we also probably want to show

17512
17:46:03.638 --> 17:46:08.639
this entrance fee on our UI, if
we do let entrance fee, we'll

17513
17:46:08.639 --> 17:46:14.639
say equals blank. And we'll take
this and we'll update, you know,

17514
17:46:14.639 --> 17:46:16.639
and we'll update this just
saying entrance fee equals await

17515
17:46:16.639 --> 17:46:19.639
entrance fee. Cool. Now we have
this as kind of a global

17516
17:46:19.639 --> 17:46:22.639
variable, we can add it in here.
And then let's even do a weight

17517
17:46:22.639 --> 17:46:26.639
entrance fee. But this whole
thing in parentheses, and then

17518
17:46:26.639 --> 17:46:33.639
do.to string, and we can even
console dot log entrance fee.

17519
17:46:33.639 --> 17:46:36.639
Now we're adding in a new
browser. But there's still an

17520
17:46:36.639 --> 17:46:39.639
issue here. Let's see if you can
spot it, we'll do a little

17521
17:46:39.639 --> 17:46:41.639
refresh.

17522
17:46:41.639 --> 17:46:45.639
We don't see the entrance fee in
the UI here. But we do see it

17523
17:46:45.639 --> 17:46:47.639
good console dot log out, right.
And again, this is going to be

17524
17:46:47.639 --> 17:46:51.639
in a way here, what is going on
here will use effect is going to

17525
17:46:51.639 --> 17:46:54.639
rerender our browser, right? And
that's what we want is what

17526
17:46:54.639 --> 17:46:57.639
three enable goes from false to
true, our browser re renders

17527
17:46:57.639 --> 17:47:02.639
watch, once we get our entrance
fee, does our browser rerender?

17528
17:47:02.639 --> 17:47:06.639
No, it does not because entrance
fee is just one of these normal

17529
17:47:06.639 --> 17:47:09.639
variables, right. So we want to
actually change this from being

17530
17:47:09.639 --> 17:47:12.639
just a normal variable to being
a hook because entrance fee does

17531
17:47:12.639 --> 17:47:16.639
get updated, but it's not
triggering a rerender. So we

17532
17:47:16.639 --> 17:47:19.639
actually want to change this to
being what's called a use state

17533
17:47:19.639 --> 17:47:22.639
hook. So you can read some more
on the documentation about the

17534
17:47:22.639 --> 17:47:24.639
using the state hook, it's kind
of the same as doing let

17535
17:47:24.639 --> 17:47:28.639
entrance fee, you know, equals
blah, blah, blah, and setting it

17536
17:47:28.639 --> 17:47:32.639
below. But it also will trigger
a rerender for us. And to do it,

17537
17:47:32.639 --> 17:47:38.639
we actually do const entrance
fee, comma, set entrance fee

17538
17:47:38.639 --> 17:47:44.640
equals use state zero import use
state from react as well. So

17539
17:47:44.640 --> 17:47:47.640
basically, entrance fee is going
to be our value, right, so if we

17540
17:47:47.640 --> 17:47:50.640
do console dot log entrance fee,
it's going to print out the

17541
17:47:50.640 --> 17:47:53.640
entrance fee entrance fee is
going to be the variable we call

17542
17:47:53.640 --> 17:47:57.640
to get the entrance fee, the
entrance fee is going to be the

17543
17:47:57.640 --> 17:48:01.640
function we call to update or
set that entrance fee. And

17544
17:48:01.640 --> 17:48:04.640
whatever that this entrance fee
variable is set, we trigger a

17545
17:48:04.640 --> 17:48:08.640
rerender. From the front end, we
have the state or the actual

17546
17:48:08.640 --> 17:48:11.640
variable in the function to
update it. And then in the use

17547
17:48:11.640 --> 17:48:14.640
state here, we just give it its
starting values we're saying

17548
17:48:14.640 --> 17:48:18.640
entrance fee is going to start
out as zero. So now that we know

17549
17:48:18.640 --> 17:48:22.640
that, let's go back down here,
and instead of saying entrance

17550
17:48:22.640 --> 17:48:28.640
fee equals this, we can say
const entrance fee from call

17551
17:48:28.640 --> 17:48:32.640
equals away entrance fee.to
string and then we can say set

17552
17:48:32.640 --> 17:48:37.640
entrance fee to this entrance
fee from call. And now when we

17553
17:48:37.640 --> 17:48:40.640
set the use state, we're going
to trigger a rerender. So

17554
17:48:40.640 --> 17:48:43.640
entrance fee will actually be
populated. Now if we go to our

17555
17:48:43.640 --> 17:48:49.640
browser, do a little refresh
here. We can see that the

17556
17:48:49.640 --> 17:48:51.640
entrance fee has indeed been re
rendered here and we can

17557
17:48:51.640 --> 17:48:54.640
actually see it here. We see the
console dot log of zero here

17558
17:48:54.640 --> 17:48:56.640
even though we're doing console
dot log entrance fee because

17559
17:48:56.640 --> 17:48:59.640
this set entrance to function
hasn't finished running it

17560
17:48:59.640 --> 17:49:02.640
basically. So we're just gonna
get rid of that line will

17561
17:49:02.640 --> 17:49:06.640
refresh and Bada bing bada boom,
this huge number is kind of

17562
17:49:06.640 --> 17:49:10.640
gross. We might even want to
update it so that it looks a

17563
17:49:10.640 --> 17:49:16.640
little bit nicer. So once again,
we can import ethers, ethers

17564
17:49:16.640 --> 17:49:23.640
from ethers. And down below,
we'll do a little ethers dot

17565
17:49:23.640 --> 17:49:32.641
utils dot format units. And
we'll do entrance fee from call

17566
17:49:32.641 --> 17:49:36.641
and we'll do a comma and type
in. And if we refresh on the

17567
17:49:36.641 --> 17:49:40.641
front end, now we can see,
entrance fee is 0.1. So we can

17568
17:49:40.641 --> 17:49:45.641
even label this we'll say
entrance fee, blah, blah, blah.

17569
17:49:45.641 --> 17:49:49.641
Now if we do a little refresh on
the front end, entrance fee 0.1

17570
17:49:49.641 --> 17:49:52.641
E.

17571
17:49:52.641 --> 17:49:56.641
Finally, we have the entrance
fee, and now uses finally on our

17572
17:49:56.641 --> 17:49:59.641
function to enter the lottery.
So let's finally uncomment this

17573
17:49:59.641 --> 17:50:02.641
out. And for message value,
we're going to want to use this

17574
17:50:02.641 --> 17:50:04.641
entrance fee. And I'm realizing
it's actually better to store

17575
17:50:04.641 --> 17:50:08.641
this in its raw to string
format. So we're going to undo

17576
17:50:08.641 --> 17:50:11.641
this part that we just did.
We're going to add it down here.

17577
17:50:11.641 --> 17:50:15.641
So we're going to ethers, that
format units, entrance fee,

17578
17:50:15.641 --> 17:50:19.641
comma, ether, like that. So that
like that, and let's comment

17579
17:50:19.641 --> 17:50:22.641
this back out real quick. So
that at least in the UI, it

17580
17:50:22.641 --> 17:50:26.641
shows up at 0.1. But on the back
end, we're actually going to

17581
17:50:26.641 --> 17:50:30.641
save it as its raw, and have way
value. So we're saying that we

17582
17:50:30.641 --> 17:50:34.641
have this entrance fee and what
we can do uncomment, this, we

17583
17:50:34.641 --> 17:50:38.641
can just grab this entrance fee,
and plop it in here. So we need

17584
17:50:38.641 --> 17:50:41.641
to make a button that's gonna do
that. Now again, we want to make

17585
17:50:41.641 --> 17:50:44.641
our code that all this works,
even if we're connected to a

17586
17:50:44.641 --> 17:50:47.641
supported chain, though. So
before we even add this, right,

17587
17:50:47.641 --> 17:50:50.641
if we switch from hard hat to
like, Aetherium main net, do a

17588
17:50:50.641 --> 17:50:53.641
little refresh. We're getting
kind of get an error here,

17589
17:50:53.641 --> 17:50:58.641
because we're calling get
entrance fee.to string on an

17590
17:50:58.641 --> 17:51:01.641
address that doesn't exist,
right? So it's gonna get really

17591
17:51:01.641 --> 17:51:04.642
confused and be like, hey, what,
what are you doing here? Let's

17592
17:51:04.642 --> 17:51:07.642
add a little button here so that
we can actually enter the

17593
17:51:07.642 --> 17:51:11.642
raffle. Before we actually do
that, let's make sure that we

17594
17:51:11.642 --> 17:51:14.642
can only call the function so
long as there actually is a

17595
17:51:14.642 --> 17:51:18.642
raffle address. So we'll do
raffle address. And we'll do

17596
17:51:18.642 --> 17:51:22.642
this ternary operator once
again. So that only if this

17597
17:51:22.642 --> 17:51:26.642
raffle address is valid, right?
And it's not, no, we'll add all

17598
17:51:26.642 --> 17:51:28.642
this code here, right. So we'll
say if the raffle address

17599
17:51:28.642 --> 17:51:31.642
exists, we're going to do some
stuff. And for now, we can

17600
17:51:31.642 --> 17:51:36.642
actually just copy paste this
line, stick it in here. And then

17601
17:51:36.642 --> 17:51:41.642
otherwise, we'll say div.
Excellence div, close it off.

17602
17:51:41.642 --> 17:51:46.642
We'll save reformat, great.
We'll say no raffle address,

17603
17:51:46.642 --> 17:51:50.642
detected. Now we'll just do all
of our code in this section up

17604
17:51:50.642 --> 17:51:53.642
here. So we have this little div
here, which is great. Inside of

17605
17:51:53.642 --> 17:52:00.642
this div, let's add a button.
Button button, we'll save it got

17606
17:52:00.642 --> 17:52:05.642
a little button here, we'll have
it say, enter raffle. And we'll

17607
17:52:05.642 --> 17:52:09.642
say on click, well, we're going
to do some JavaScript. So let's

17608
17:52:09.642 --> 17:52:13.642
do some JavaScript, we want to
call an async function async

17609
17:52:13.642 --> 17:52:16.642
function. So I know the double
brackets is going to be

17610
17:52:16.642 --> 17:52:19.642
confusing, right. But these
brackets allow us to do

17611
17:52:19.642 --> 17:52:23.642
JavaScript in our HTML, or JSX,
or whatever. And these brackets

17612
17:52:23.642 --> 17:52:27.642
represent this function, it's
going to an async function. And

17613
17:52:27.642 --> 17:52:33.642
we're gonna say, await, enter
raffle. And that's it. So let's

17614
17:52:33.642 --> 17:52:35.642
go back to the front end. Now we
have a little enter raffle

17615
17:52:35.642 --> 17:52:40.642
function. If we do refresh,
let's just make sure our account

17616
17:52:40.642 --> 17:52:44.642
is reset here. So we're gonna go
down to settings, advanced,

17617
17:52:44.642 --> 17:52:48.643
reset accounts, yes. I hit ENTER
raffle. metamath does indeed pop

17618
17:52:48.643 --> 17:52:53.643
up. And we can go ahead and
confirm. Awesome, okay, we can

17619
17:52:53.643 --> 17:52:59.643
now enter our raffle. We're
doing incredibly well with this.

17620
17:52:59.643 --> 17:53:02.643
As you saw, we just got that pop
up. And that was pretty much it,

17621
17:53:02.643 --> 17:53:05.643
right? It's not very helpful for
the users who are following

17622
17:53:05.643 --> 17:53:09.643
along with this to look at this
and go, Okay, did it go through?

17623
17:53:09.643 --> 17:53:12.643
Or we did it fail, like, what,
what just happened? So what we

17624
17:53:12.643 --> 17:53:15.643
want to do is create what's
called notifications, right? We

17625
17:53:15.643 --> 17:53:18.643
want a little pop up saying,
Hey, you sent your transaction,

17626
17:53:18.643 --> 17:53:22.643
great job, we're going to use a
library. Again, we're going to

17627
17:53:22.643 --> 17:53:24.643
use the web through UI Kit,
which comes with some

17628
17:53:24.643 --> 17:53:27.643
notifications that we can go
ahead and use. So if you come to

17629
17:53:27.643 --> 17:53:31.643
this little interactive thing,
which is right in their GitHub,

17630
17:53:31.643 --> 17:53:34.643
there's a whole bunch of stuff
in here. And you can actually

17631
17:53:34.643 --> 17:53:36.643
click around and play with
different buttons and different

17632
17:53:36.643 --> 17:53:39.643
things. And you can actually go
ahead and even go to docs for

17633
17:53:39.643 --> 17:53:43.643
each one of these. And you can
go show code. And you can

17634
17:53:43.643 --> 17:53:45.643
literally like copy paste code
into your project, like whatever

17635
17:53:45.643 --> 17:53:49.643
you want to do styling and
everything for us. So back in

17636
17:53:49.643 --> 17:53:54.643
our app dot j s, we're going to
add import, no to vacations

17637
17:53:54.643 --> 17:54:01.643
provider from web three UI kit
and inside of the Morales

17638
17:54:01.643 --> 17:54:04.643
provider, but outside of the
components, we're gonna do

17639
17:54:04.643 --> 17:54:07.643
notification provider
notification provide Add it like

17640
17:54:07.643 --> 17:54:10.643
this. So it goes Morales
provider notification provider

17641
17:54:10.643 --> 17:54:13.643
component. So wrapping our
component in this notifications

17642
17:54:13.643 --> 17:54:18.643
thing, and that's notification
provider not notifications. And

17643
17:54:18.643 --> 17:54:22.643
this is going to allow us to
actually make notifications back

17644
17:54:22.643 --> 17:54:24.644
in our lottery entrance. Back in
our lottery entrance, we're

17645
17:54:24.644 --> 17:54:28.644
gonna scroll up to the top,
we're going to import a hook

17646
17:54:28.644 --> 17:54:34.644
those notifications called us
know, to the occasion from web

17647
17:54:34.644 --> 17:54:39.644
three UI kit. And this use
notification gives us this thing

17648
17:54:39.644 --> 17:54:43.644
back called a dispatch. So I'm
gonna say const, dispatch,

17649
17:54:43.644 --> 17:54:47.644
equals use notification. So use
notification returns this

17650
17:54:47.644 --> 17:54:49.644
dispatch, and this dispatch is
like a little pop up that will

17651
17:54:49.644 --> 17:54:54.644
give us so down here, when we
call this enter raffle, we're

17652
17:54:54.644 --> 17:54:56.644
gonna give it a little some
parameters in here, we're gonna

17653
17:54:56.644 --> 17:55:00.644
say on success, these functions
come with onsuccess, they come

17654
17:55:00.644 --> 17:55:05.644
with onComplete, they come with
an error, all this stuff. And

17655
17:55:05.644 --> 17:55:09.644
when this function is
successful, we'll do handle

17656
17:55:09.644 --> 17:55:12.644
success, we'll create a new
handle success function that

17657
17:55:12.644 --> 17:55:16.644
will handle the success. And
this is Patrick from the future

17658
17:55:16.644 --> 17:55:18.644
coming back to show one
additional point. I know I

17659
17:55:18.644 --> 17:55:24.644
mentioned it, but it is really
good to add this on error, colon

17660
17:55:24.644 --> 17:55:29.644
error console dot log error for
any run contract functions, even

17661
17:55:29.644 --> 17:55:33.644
the reads, If any of your run
contract functions break, you

17662
17:55:33.644 --> 17:55:36.644
won't know. So definitely want
to add this on error error

17663
17:55:36.644 --> 17:55:40.644
console dot log error to all of
your run contract functions. So

17664
17:55:40.644 --> 17:55:45.644
up here, before the return,
we'll create a new const handle

17665
17:55:45.644 --> 17:55:51.644
success. We'll say this is an
async function async function

17666
17:55:51.644 --> 17:55:55.644
that takes the transaction as
input parameters. And remember,

17667
17:55:55.644 --> 17:55:59.644
you can turn functions into
constant variables. And we'll

17668
17:55:59.644 --> 17:56:05.645
say await TX dot Wait, one, so
we'll wait for that transaction

17669
17:56:05.645 --> 17:56:08.645
to go through. And then we'll
create another function called

17670
17:56:08.645 --> 17:56:13.645
handle new notification, dx. And
you'll see why I'm doing it like

17671
17:56:13.645 --> 17:56:17.645
this in a minute. And we'll say
const and Linoone notification,

17672
17:56:17.645 --> 17:56:19.645
this is just going to be a
synchronous function because we

17673
17:56:19.645 --> 17:56:22.645
don't need it to be async. And
we're just going to call this

17674
17:56:22.645 --> 17:56:25.645
dispatch, we're going to set up
this notification basically. So

17675
17:56:26.645 --> 17:56:28.645
we'll say notify, or dispatch,
and then we'll add the

17676
17:56:28.645 --> 17:56:31.645
parameters in here. So it takes
an object as a parameter, we'll

17677
17:56:31.645 --> 17:56:38.645
say type info. Message, it's
going to be transaction

17678
17:56:38.645 --> 17:56:50.645
complete, the title is going to
be TX notification. Jose, Shawn,

17679
17:56:50.645 --> 17:56:55.645
we're going to say, top are and
then icon, we're going to say a

17680
17:56:55.645 --> 17:56:58.645
little bell.

17681
17:56:58.645 --> 17:57:01.645
And you can find all this stuff
right in here, type icon

17682
17:57:01.645 --> 17:57:05.645
position, you can read all about
the different parameters you can

17683
17:57:05.645 --> 17:57:07.645
kind of set this up with so
handle new notification handle

17684
17:57:07.645 --> 17:57:12.645
success. So we're saying, enter
raffle once this transaction is

17685
17:57:12.645 --> 17:57:16.645
successful, call this handle
success function, which is going

17686
17:57:16.645 --> 17:57:19.645
to call handle new notification.
Okay. And you'll see why we

17687
17:57:19.645 --> 17:57:22.645
split this into two instead of
just having handle success. Also

17688
17:57:22.645 --> 17:57:26.645
do the dispatch. When we press
our enter raffle button, we're

17689
17:57:26.645 --> 17:57:29.645
going to call enter raffle is
successful, we're going to call

17690
17:57:29.645 --> 17:57:31.645
handle success. We're going to
wait for that transaction to

17691
17:57:32.645 --> 17:57:35.645
finish Yes, it passes a
parameter to our handle success

17692
17:57:35.645 --> 17:57:38.645
function. And then all we're
going to do is we're going to

17693
17:57:38.645 --> 17:57:41.645
call handle new notification.
And we're going to dispatch

17694
17:57:41.645 --> 17:57:44.645
we're going to launch one of
these notifications. So back

17695
17:57:44.645 --> 17:57:49.646
here, let's hit enter raffle.
metamath pops up will confirm.

17696
17:57:49.646 --> 17:57:52.646
And after it completes, we get
this wonderful transaction

17697
17:57:52.646 --> 17:57:55.646
notification transaction
complete, right. So we've let

17698
17:57:55.646 --> 17:57:59.646
the user know, great job, you've
submitted a transaction. Great

17699
17:57:59.646 --> 17:58:03.646
work. So this is great. We're
giving our users some helpful

17700
17:58:03.646 --> 17:58:08.646
pieces here. Now let's add a
little bit more here so that the

17701
17:58:08.646 --> 17:58:11.646
users know what else is going on
with this lottery. But we need

17702
17:58:11.646 --> 17:58:13.646
to display a little bit more
data, right, let's display how

17703
17:58:13.646 --> 17:58:17.646
many people are in this lottery.
How many people are in this

17704
17:58:17.646 --> 17:58:21.646
game. And we can do that. Of
course, because we have a number

17705
17:58:21.646 --> 17:58:24.646
players command. We also
probably want to get the recent

17706
17:58:24.646 --> 17:58:27.646
winner. And we can do that as
well. Up here, we're going to

17707
17:58:27.646 --> 17:58:30.646
copy this get entrance fee,
we're going to create another

17708
17:58:30.646 --> 17:58:36.646
one called Get num players. And
this is going to call go back to

17709
17:58:36.646 --> 17:58:39.646
raffle dot soul. It's going to
call get number of players

17710
17:58:39.646 --> 17:58:43.646
actually so let's just call it
call it the same thing. Get

17711
17:58:43.646 --> 17:58:46.646
number of players and we're
going to call and get number of

17712
17:58:46.646 --> 17:58:50.646
players. And to store this
value. Once again up at the top.

17713
17:58:50.646 --> 17:58:55.646
We're going to copy this line,
paste it right and we'll do non

17714
17:58:55.646 --> 17:59:00.646
players. And then we'll do set
num players. And then we'll copy

17715
17:59:00.646 --> 17:59:05.646
this line again. A recent winner
so we'll do recent Winner.

17716
17:59:05.646 --> 17:59:11.646
Winner will do Set, recent
winner, then we'll copy this

17717
17:59:11.646 --> 17:59:16.646
again, instead of getting number
players will do get get recent

17718
17:59:16.646 --> 17:59:20.646
winner. So we'll call it get
recent winner get recent winner

17719
17:59:20.646 --> 17:59:24.646
in our use effect, let's do more
than just get the entrance fee,

17720
17:59:24.646 --> 17:59:30.647
let's get everything. So we can
say const num players, from call

17721
17:59:30.647 --> 17:59:37.647
equals, we'll do a weight, get
number of players.to string, and

17722
17:59:37.647 --> 17:59:42.647
then we'll do set set num
players do like that. So we'll

17723
17:59:42.647 --> 17:59:47.647
do set num players, num players
from call. And then we'll also

17724
17:59:47.647 --> 17:59:54.647
do const recent winner from call
this is going to be await get

17725
17:59:54.647 --> 17:59:57.647
recent winner. And we might need
to wrap this to string but I

17726
17:59:57.647 --> 18:00:01.647
think I don't think we need to.
So we'll do set recent winner

17727
18:00:01.647 --> 18:00:04.647
paste that in here. So now we've
had a number of players, we've

17728
18:00:04.647 --> 18:00:07.647
added a recent winner. Let's
come back down here. We have an

17729
18:00:07.647 --> 18:00:14.647
entrance fee. Let's go ahead and
do number of players. And we'll

17730
18:00:14.647 --> 18:00:19.647
add number of players or what
did we call it? Oh my god, we

17731
18:00:19.647 --> 18:00:23.647
called setting employers twice
oops, it's called non players,

17732
18:00:23.647 --> 18:00:27.647
scroll down players gonna be non
players, and then we'll do

17733
18:00:27.647 --> 18:00:30.647
recent winner.

17734
18:00:30.647 --> 18:00:35.647
And then we'll add in the recent
winner. Awesome. Okay, entrance

17735
18:00:35.647 --> 18:00:40.647
fees 0.1 eath number of players
to recent winner is nobody here.

17736
18:00:40.647 --> 18:00:45.647
And if we go ahead and we enter
the raffle metamath pops up.

17737
18:00:45.647 --> 18:00:48.647
We'll go ahead and confirm. Once
a transaction goes through,

17738
18:00:48.647 --> 18:00:53.647
we'll get transaction complete.
And if we do a refresh, we see

17739
18:00:53.647 --> 18:00:56.647
the number of players has
updated. But we had to refresh

17740
18:00:56.647 --> 18:00:58.647
which is kind of annoying,
right, let's enter the raffle

17741
18:00:58.647 --> 18:01:03.647
again, we'll go confirm
transaction complete. But this

17742
18:01:03.647 --> 18:01:06.648
didn't rerender. Right. So we
want to set something up so that

17743
18:01:06.648 --> 18:01:09.648
we automatically rerender. And
guess what's going to do that

17744
18:01:09.648 --> 18:01:11.648
the handle success that we were
talking about before. That's

17745
18:01:11.648 --> 18:01:15.648
right, all of this update UI
stuff, we can actually pull out

17746
18:01:15.648 --> 18:01:19.648
of the use effect. So we're
going to copy it all deleted

17747
18:01:19.648 --> 18:01:22.648
there. And we're going to have
it be its own standalone

17748
18:01:22.648 --> 18:01:26.648
function like this. And then in
our handle success, whenever

17749
18:01:26.648 --> 18:01:29.648
this successful transaction goes
through, we're going to update

17750
18:01:29.648 --> 18:01:33.648
the UI, right? So handle success
handled new notification, and

17751
18:01:33.648 --> 18:01:37.648
we're going to update the white.
So now if we go back here, let's

17752
18:01:37.648 --> 18:01:41.648
enter the lottery. Let's
confirm, we see we get the five

17753
18:01:41.648 --> 18:01:43.648
and we get transaction
Notification. Now we want to

17754
18:01:43.648 --> 18:01:47.648
test getting a recent winner
here. So what we can do,

17755
18:01:47.648 --> 18:01:51.648
actually back in our hard hat
project is we want to create a

17756
18:01:51.648 --> 18:01:54.648
new script. And I actually
already created it for you,

17757
18:01:54.648 --> 18:01:56.648
that's going to mock the
channeling VRF. And that's going

17758
18:01:56.648 --> 18:01:59.648
to mock being a keepers. So all
this is really doing is pretty

17759
18:01:59.648 --> 18:02:02.648
much exactly what our tests were
doing. If you want to pause

17760
18:02:02.648 --> 18:02:05.648
right now and look through this
yourself, pause here and add

17761
18:02:05.648 --> 18:02:09.648
this mock off chain, which is
both keepers and VRF. Or you can

17762
18:02:09.648 --> 18:02:13.648
just go to the GitHub repo here.
Just go to the GitHub repo for

17763
18:02:13.648 --> 18:02:17.648
Lesson Nine. It's already in
scripts go down to scripts

17764
18:02:17.648 --> 18:02:21.648
Markov chain, you can just copy
paste it here. Because I want to

17765
18:02:21.648 --> 18:02:24.648
test that that recent winner. So
in my hard hat, smart contract

17766
18:02:24.648 --> 18:02:30.648
lottery, so we'll do yarn,
hardhats run scripts, slash mock

17767
18:02:30.648 --> 18:02:34.648
off chain dash test network
local host, we're going to mock

17768
18:02:34.648 --> 18:02:37.648
you know, basically picking a
winner from an upkeep with

17769
18:02:37.648 --> 18:02:40.648
Request ID one, we're on a local
network. Okay, let's pretend the

17770
18:02:40.648 --> 18:02:43.648
recent winner was so and so. And
what we can do is we can do a

17771
18:02:43.648 --> 18:02:48.649
little refresh here, we can see
we have a winner updated. Boom.

17772
18:02:48.649 --> 18:02:51.649
Now we're gonna clean up the UI.
But I want to talk about a

17773
18:02:51.649 --> 18:02:53.649
couple of things. Before we do
that, because we're almost done

17774
18:02:53.649 --> 18:02:59.649
with this section. Something I
want to make really clear

17775
18:02:59.649 --> 18:03:02.649
because it confused me a little
bit is that this onsuccess isn't

17776
18:03:02.649 --> 18:03:05.649
checking that the transaction
has a block confirmation, it's

17777
18:03:05.649 --> 18:03:09.649
just checking to see that the
transaction was successfully

17778
18:03:09.649 --> 18:03:14.649
sent to Metamask. So onsuccess
checks to see a transaction is

17779
18:03:14.649 --> 18:03:16.649
successfully sent the Metamask.
And that's why up in that other

17780
18:03:17.649 --> 18:03:20.649
function, we do TX dot wait one
because that's the piece that

17781
18:03:20.649 --> 18:03:25.649
actually waits for the
transaction to be confirmed.

17782
18:03:25.649 --> 18:03:29.649
Right now we're using Morales to
make once we call that mocking

17783
18:03:29.649 --> 18:03:32.649
script, I had to refresh the
browser to see the winner here,

17784
18:03:32.649 --> 18:03:35.649
right and number of players
obviously got reset to zero,

17785
18:03:35.649 --> 18:03:39.649
which is great. That's not
ideal. Ideally, we want our UI

17786
18:03:39.649 --> 18:03:43.649
to just automatically update
when some event gets fired. In

17787
18:03:43.649 --> 18:03:47.649
our raffle contract, we get this
event emitted. Instead of in our

17788
18:03:47.649 --> 18:03:51.649
code doing this await success
here. What we could do is we

17789
18:03:51.649 --> 18:03:57.649
could set up a portion to listen
for that event being emitted and

17790
18:03:57.649 --> 18:04:00.649
update the front end
accordingly. With that knowledge

17791
18:04:00.649 --> 18:04:03.649
we can also listen for the
winner event being emitted. We

17792
18:04:03.649 --> 18:04:06.649
could update our front end
instead of having to refresh

17793
18:04:06.649 --> 18:04:09.649
it's your cue Yes, and you want
to see if you can add to this

17794
18:04:09.649 --> 18:04:14.649
right now, I highly recommend
you do. So

17795
18:04:14.649 --> 18:04:17.649
we've pretty much finished all
the functionality. And wow,

17796
18:04:17.649 --> 18:04:20.649
you've learned a ton in this
little bit, right? We've learned

17797
18:04:20.649 --> 18:04:23.649
about use effects use Morales,
all these hooks, all this stuff,

17798
18:04:23.649 --> 18:04:27.650
and we've got a front end that
very nicely handles interacting

17799
18:04:27.650 --> 18:04:29.650
with our smart contract. The
only thing is, is it looks

17800
18:04:29.650 --> 18:04:34.650
really ugly. This is kind of
gross. So let's make this look

17801
18:04:34.650 --> 18:04:37.650
at least a little bit nicer.
There's two things to think

17802
18:04:37.650 --> 18:04:39.650
about when it comes to building
these front ends. There's

17803
18:04:39.650 --> 18:04:42.650
component libraries, like web
three UI Kit, which we're using,

17804
18:04:42.650 --> 18:04:45.650
which gives us kind of like
components that give us, you

17805
18:04:45.650 --> 18:04:48.650
know, blocks of code, like this
connect button that are already

17806
18:04:48.650 --> 18:04:52.650
formatted for us. And then
there's CSS libraries that

17807
18:04:52.650 --> 18:04:55.650
actually will help us format the
rest of our stuff here. So we're

17808
18:04:55.650 --> 18:04:58.650
using one of these component
libraries. We're also going to

17809
18:04:58.650 --> 18:05:01.650
use one of these formatting
libraries, and the library that

17810
18:05:01.650 --> 18:05:03.650
we're going to use is tailwind.
And the reason that we're going

17811
18:05:03.650 --> 18:05:07.650
to use tailwind CSS is because
it's really popular. If you want

17812
18:05:07.650 --> 18:05:09.650
to learn CSS, there's some
wonderful resources that you can

17813
18:05:09.650 --> 18:05:12.650
use to learn CSS web three
schools is one that I've used a

17814
18:05:12.650 --> 18:05:16.650
ton. So there's going to be a
link to that in the GitHub repo

17815
18:05:16.650 --> 18:05:19.650
associated with this course so
that you can make your websites

17816
18:05:19.650 --> 18:05:21.650
look pretty when formatting
stuff but we are actually going

17817
18:05:21.650 --> 18:05:24.650
to work with tailwind because
it's going to make us doing CSS

17818
18:05:24.650 --> 18:05:28.650
stuff a lot easier. Since we're
using tailwind with next Jas.

17819
18:05:28.650 --> 18:05:31.650
There's actually a wonderful
little guide here for installing

17820
18:05:31.650 --> 18:05:34.650
tailwind with next Jas. And
we're gonna go basically go

17821
18:05:34.650 --> 18:05:37.650
ahead and follow along with
this. This link is available in

17822
18:05:37.650 --> 18:05:40.650
the GitHub repo associated with
this course with this lesson. So

17823
18:05:40.650 --> 18:05:42.650
we've already created our
project we've seeded into our

17824
18:05:42.650 --> 18:05:46.650
project. Now we're gonna go
ahead and install tailwind npm

17825
18:05:46.650 --> 18:05:49.650
install dash D instead, since
we're using yarn, we're going to

17826
18:05:49.650 --> 18:05:56.650
do yarn or pop this open, green
new yarn, add dash dash Dev,

17827
18:05:56.650 --> 18:05:59.650
paste those three in tailwind
CSS, post CSS and then

17828
18:05:59.650 --> 18:06:02.650
autoprefixer and it's the three
of these that are going to

17829
18:06:02.650 --> 18:06:06.651
basically make up tailwind with
next Jas. Once we have those

17830
18:06:06.651 --> 18:06:09.651
we're going to basically init
tailwind and make a config file

17831
18:06:09.651 --> 18:06:13.651
for tailwind. So we're gonna do
yarn tailwind CSS and it does p

17832
18:06:13.651 --> 18:06:18.651
yarn tailwind CSS init dash P
will run that. This is going to

17833
18:06:18.651 --> 18:06:23.651
give us this post CSS dot config
dot j s and this tailwind dot

17834
18:06:23.651 --> 18:06:26.651
config dot j s and what we're
going to want to do is literally

17835
18:06:26.651 --> 18:06:29.651
just hit this copy button, and
we're going to update our

17836
18:06:29.651 --> 18:06:35.651
tailwind.config.js tailwind Jas
so that it says okay, all of

17837
18:06:35.651 --> 18:06:40.651
this stuff, anything in Pages
anything with.js.ts dot JSX or

17838
18:06:40.651 --> 18:06:43.651
TSX. And anything in these
components, anything in those

17839
18:06:43.651 --> 18:06:47.651
two folders is going to be
considered tailwind double. We

17840
18:06:47.651 --> 18:06:49.651
want to use tailwind on these
two folders. Then we're going to

17841
18:06:49.651 --> 18:06:54.651
add the tailwind directives to
our global CSS files. So if we

17842
18:06:54.651 --> 18:06:57.651
go back, we're going to styles
Global's we're going to

17843
18:06:57.651 --> 18:07:01.651
overwrite everything in here
with ADD tailwind base and add

17844
18:07:01.651 --> 18:07:03.651
tailwind components at tailwind
utilities. And this makes it so

17845
18:07:03.651 --> 18:07:07.651
that our global CSS file uses
tailwind. Now, you'll see like

17846
18:07:07.651 --> 18:07:10.651
unknown rule at tailwind, what
we can do is we can go to

17847
18:07:10.651 --> 18:07:14.651
components, what we can do is we
can look up this post CSS

17848
18:07:14.651 --> 18:07:18.651
language support extension,
paste that in here, boom, let's

17849
18:07:18.651 --> 18:07:20.651
go ahead and install this. And
now we get those little

17850
18:07:20.651 --> 18:07:24.651
underscores to go away, which is
really nice. Now, per usual, we

17851
18:07:24.651 --> 18:07:27.651
can just do NPM, run Dev and
start adding tailwind to our

17852
18:07:27.651 --> 18:07:32.651
divs. Now what tailwind does is
allows us in our divs to set

17853
18:07:32.651 --> 18:07:35.651
everything as a class name, and
then just set some real

17854
18:07:35.651 --> 18:07:38.651
minimalistic text in these class
names here. So let's look at our

17855
18:07:38.651 --> 18:07:41.651
smart contract lottery here.
We've just tailwind did it. So

17856
18:07:41.651 --> 18:07:44.651
it already has been updated a
little bit. Let's update our

17857
18:07:44.651 --> 18:07:46.652
header here. Well, let's see. We
want to give our header a border

17858
18:07:46.652 --> 18:07:52.652
from the tailwind. We'll do a
quick search. Look a border we

17859
18:07:52.652 --> 18:07:55.652
can see all this border stuff
like border width border this

17860
18:07:55.652 --> 18:08:00.652
border that say we want a border
on the bottom, we can see we can

17861
18:08:00.652 --> 18:08:03.652
get a border on the bottom with
something like this. Let's do

17862
18:08:03.652 --> 18:08:07.652
border on the bottom with a
width of two pixels. We just do

17863
18:08:07.652 --> 18:08:11.652
border b two. So I'm going to
copy border B to do border b

17864
18:08:11.652 --> 18:08:14.652
two, I'm going to save it and
what we need to do for our CSS

17865
18:08:14.652 --> 18:08:18.652
and everything to take effect.
Go ahead and kill the front end.

17866
18:08:18.652 --> 18:08:20.652
And then we'll rerun it with
yarn Dev. Go back to our front

17867
18:08:20.652 --> 18:08:24.652
end now. Give it a little
refresh and Okay, cool. Now we

17868
18:08:24.652 --> 18:08:27.652
have a little border here. So
we're starting to add some stuff

17869
18:08:27.652 --> 18:08:31.652
and it's just not a whole lot
yet. Oh, and then we can also

17870
18:08:31.652 --> 18:08:35.652
add tailwind to me go to
Extensions. We can also look up

17871
18:08:35.652 --> 18:08:38.652
tailwind. There's a tailwind
extension here. So I'm just

17872
18:08:38.652 --> 18:08:40.652
going to add a whole bunch of
stuff in here. We're gonna do

17873
18:08:40.652 --> 18:08:44.652
flex, flex row.

17874
18:08:44.652 --> 18:08:48.652
We're gonna make our
decentralized lottery and h one

17875
18:08:48.652 --> 18:08:53.652
which stands for like header
one. Do class name equals, we'll

17876
18:08:53.652 --> 18:08:59.652
do the y dash force. We'll give
it padding the top of form the X

17877
18:08:59.652 --> 18:09:03.652
padding on the x axis of four.
We'll make it bold font and

17878
18:09:03.652 --> 18:09:06.652
we'll make the text three XL
size. So we'll make everything

17879
18:09:06.652 --> 18:09:11.652
bigger. Cool. Then we'll do one
more, we'll wrap our Connect

17880
18:09:11.652 --> 18:09:16.652
button in a div. So we'll say
div class name equals, and we'll

17881
18:09:16.652 --> 18:09:21.652
give it a an automatic left
margin. We'll do py too. So some

17882
18:09:21.652 --> 18:09:27.653
y padding, some x padding. See
what we have done. Okay. Now if

17883
18:09:27.653 --> 18:09:31.653
we zoom out a little bit, we can
see, if we close this too, we

17884
18:09:31.653 --> 18:09:34.653
can see now our Connect button
is on the side here. And they're

17885
18:09:34.653 --> 18:09:36.653
kind of separated like that. And
I think that looks nice. So

17886
18:09:36.653 --> 18:09:39.653
we're going to keep that now
we're going to go back to our

17887
18:09:39.653 --> 18:09:42.653
lottery entrance, we're going to
change this up just a hair,

17888
18:09:42.653 --> 18:09:48.653
we'll say div class name equals
P. Five, we'll make our button

17889
18:09:48.653 --> 18:09:53.653
look really nice. We'll say
class name equals background

17890
18:09:53.653 --> 18:10:00.653
blue 500. When we hover over, it
will say, background blue 700.

17891
18:10:00.653 --> 18:10:03.653
So now if I just say that, and
when we hover over it, it looks

17892
18:10:03.653 --> 18:10:07.653
a little different, that's
really nice. We'll say text is

17893
18:10:07.653 --> 18:10:12.653
white, we'll say the font is
bold, we'll give it some white

17894
18:10:12.653 --> 18:10:16.653
padding, I'll give it some x
padding, we'll have the bunbee

17895
18:10:16.653 --> 18:10:20.653
rounded, and we'll give it a
margin left auto, now looks a

17896
18:10:20.653 --> 18:10:22.653
lot better, right? That's a lot
prettier. We're just going to be

17897
18:10:22.653 --> 18:10:25.653
doing some basic CSS here just
to make it look a little bit

17898
18:10:25.653 --> 18:10:28.653
nicer, right, but just that by
itself already made this lottery

17899
18:10:28.653 --> 18:10:31.653
button look a lot cooler. Now
some functionality that we

17900
18:10:31.653 --> 18:10:34.653
didn't add here. So we need to
add a disabled, kind of like

17901
18:10:34.653 --> 18:10:39.653
what we did before. And in our
enter a raffle it comes with,

17902
18:10:39.653 --> 18:10:43.653
like I said, is loading and it
is fetching. None of our

17903
18:10:43.653 --> 18:10:45.653
transaction is loading or
fetching, we'll just make this

17904
18:10:45.653 --> 18:10:50.653
disabled. So we'll say is
loading or is fetching this will

17905
18:10:50.653 --> 18:10:52.653
be disabled. Right? Now, if we
go back to the front, we hit

17906
18:10:52.653 --> 18:10:57.653
enter raffle, go ahead and hit
confirm, we can add a CSS for

17907
18:10:57.653 --> 18:11:00.653
it. But when a transaction is
loading, they will not be able

17908
18:11:00.653 --> 18:11:02.653
to click that button anymore,
which that's something else

17909
18:11:02.653 --> 18:11:05.653
pretty that we want to do
speaking of is loading and is

17910
18:11:05.653 --> 18:11:09.654
fetching. When it's loading or
fetching, we probably want it to

17911
18:11:09.654 --> 18:11:11.654
have that like little spinny
thing right when we hit it right

17912
18:11:11.654 --> 18:11:15.654
now. And mash is pops up. And we
can confirm but it would be cool

17913
18:11:15.654 --> 18:11:18.654
if it had like a little spinny
thing here, right. So you can

17914
18:11:18.654 --> 18:11:22.654
usually just Google like how to
add spinny thing or stuff like

17915
18:11:22.654 --> 18:11:25.654
that, and you'll get something.
But you can again, you can just

17916
18:11:25.654 --> 18:11:27.654
copy paste this from my code,
I'm going to show you what I

17917
18:11:27.654 --> 18:11:31.654
ended up doing for this section.
And we're gonna say is, if is

17918
18:11:31.654 --> 18:11:35.654
loading or is fetching. And
we're going to use that ternary

17919
18:11:35.654 --> 18:11:39.654
operator all the time, then in
here, we're going to do a little

17920
18:11:39.654 --> 18:11:43.654
div. And otherwise, we're going
to do a different div for

17921
18:11:43.654 --> 18:11:44.654
loading or for fetching, we're
going to add like a little

17922
18:11:44.654 --> 18:11:54.654
spinny thing in here. So we're
going to add class name equals.

17923
18:11:54.654 --> 18:11:56.654
If we're loading, we're going to
add this little spinny thing,

17924
18:11:56.654 --> 18:11:59.654
which I'll show you what it
looks like in a second. And if

17925
18:11:59.654 --> 18:12:02.654
we're not loading, we're just
gonna do enter, raffle like

17926
18:12:02.654 --> 18:12:06.654
that. So we'll come back to the
front end, see answer raffle,

17927
18:12:06.654 --> 18:12:08.654
we'll click the button. Now we
get this cute little spinny

17928
18:12:08.654 --> 18:12:12.654
thing, confirm transaction goes
through. So anything goes away.

17929
18:12:12.654 --> 18:12:15.654
Nice. Well, let's put these on
different lines. So we'll just

17930
18:12:15.654 --> 18:12:23.654
do

17931
18:12:23.654 --> 18:12:26.654
so those will be on different
lines. Now boom, entrance fee,

17932
18:12:26.654 --> 18:12:32.654
number players recent winner,
once a lottery now will confirm

17933
18:12:32.654 --> 18:12:35.654
transaction complete number of
players has gone up and we have

17934
18:12:35.654 --> 18:12:38.654
done it. Now this looks a lot
nicer. It's clearly not perfect,

17935
18:12:38.654 --> 18:12:41.654
but it's much easier to read
than kind of that lump that we

17936
18:12:41.654 --> 18:12:43.654
had before. And the reason I
wanted to show you this was

17937
18:12:43.654 --> 18:12:46.655
really just kind of giving you
your footholds for making these

17938
18:12:46.655 --> 18:12:52.655
look a little bit nicer. This
definitely isn't a CSS course.

17939
18:12:52.655 --> 18:12:56.655
Oh, wow. Okay, this is
phenomenal. We have an app that

17940
18:12:56.655 --> 18:12:59.655
we really like. And we're like,
you know what, we want to deploy

17941
18:12:59.655 --> 18:13:02.655
this bad, Larry, let's talk
about how we can deploy this,

17942
18:13:02.655 --> 18:13:04.655
this section is going to be
optional, okay, because I'm

17943
18:13:04.655 --> 18:13:06.655
going to deploy something to
rank B and deploying to test

17944
18:13:06.655 --> 18:13:09.655
sets can take a long time. So
we're going to deploy our

17945
18:13:09.655 --> 18:13:12.655
contracts to rink B. And then
we're going to deploy our

17946
18:13:12.655 --> 18:13:16.655
website to a hosting provider.
So first, let's talk about

17947
18:13:16.655 --> 18:13:19.655
hosting providers for a quick
second, if we want to host our

17948
18:13:19.655 --> 18:13:22.655
beautiful website that we just
created, there are ways to

17949
18:13:22.655 --> 18:13:26.655
deploy it using things like for
cell or Google Cloud, or AWS.

17950
18:13:26.655 --> 18:13:28.655
Nettle. Phi is another really
popular one there, all these

17951
18:13:28.655 --> 18:13:31.655
different places that we can
deploy our application. Now, the

17952
18:13:31.655 --> 18:13:34.655
thing about these though, is
that these are all centralized

17953
18:13:34.655 --> 18:13:37.655
deployment places, having a
centralized deployment

17954
18:13:37.655 --> 18:13:40.655
application can still be
incredibly important, right? If

17955
18:13:40.655 --> 18:13:42.655
we look at ether scan for a
second ether scan is a

17956
18:13:42.655 --> 18:13:45.655
centralized application right at
the end of the day, but it's

17957
18:13:45.655 --> 18:13:48.655
still one that we've been using
a lot. However, if we want to

17958
18:13:48.655 --> 18:13:50.655
have a front end that's
decentralized. Well, that's a

17959
18:13:50.655 --> 18:13:53.655
little bit harder. The more
important thing for us is that

17960
18:13:53.655 --> 18:13:56.655
our back end, our smart
contracts are decentralized,

17961
18:13:56.655 --> 18:13:58.655
right? That's the most important
thing because that will give

17962
18:13:58.655 --> 18:14:00.655
users the ability to interact
with our logic in a

17963
18:14:00.655 --> 18:14:03.655
decentralized way. But maybe we
also want our front ends

17964
18:14:03.655 --> 18:14:07.655
decentralized. Now at some point
we will still use a centralized

17965
18:14:07.655 --> 18:14:10.655
service Like VSL to deploy an
application, and I'll show you

17966
18:14:10.655 --> 18:14:13.655
why when we get there, there's
some features that right now,

17967
18:14:14.655 --> 18:14:16.655
they're really just hard to do
without like a really solid

17968
18:14:16.655 --> 18:14:20.655
centralized back end. What's
important to keep in mind is

17969
18:14:20.655 --> 18:14:24.655
that our back end, the logic of
our contract is on a

17970
18:14:24.655 --> 18:14:28.656
decentralized blockchain. So
even if we host the front end on

17971
18:14:28.656 --> 18:14:32.656
a centralized hosting provider,
using some type of centralized

17972
18:14:32.656 --> 18:14:36.656
database to make the front end
easier to work with, the logic

17973
18:14:36.656 --> 18:14:39.656
of the application is
decentralized. And that's the

17974
18:14:39.656 --> 18:14:42.656
most important piece. So I'm
going to give you some tools

17975
18:14:42.656 --> 18:14:46.656
later on, and how to introduce
more of these feature richness.

17976
18:14:46.656 --> 18:14:50.656
If you choose to do so doing so
will add a centralized component

17977
18:14:50.656 --> 18:14:53.656
on your front end. And it's
something to keep in mind,

17978
18:14:53.656 --> 18:14:56.656
depending on how you want your
architecture. So when doing that

17979
18:14:56.656 --> 18:15:00.656
just be absolutely sure that the
smart contracts on the back end

17980
18:15:00.656 --> 18:15:04.656
are deployed are decentralized
on one of these blockchains.

17981
18:15:04.656 --> 18:15:07.656
Now, we'll learn about some of
those centralized ways to do

17982
18:15:07.656 --> 18:15:11.656
that in a later section. For
now, let's learn how to deploy

17983
18:15:11.656 --> 18:15:16.656
this front end in a more
decentralized way.

17984
18:15:16.656 --> 18:15:20.656
And the tool that we're going to
use is a tool called IPFS. Now,

17985
18:15:20.656 --> 18:15:24.656
let me explain a little bit
about how IPFS works. It's this

17986
18:15:24.656 --> 18:15:29.656
distributed decentralized data
structure. That's not exactly a

17987
18:15:29.656 --> 18:15:32.656
blockchain. But it's similar to
a blockchain. There's no mining,

17988
18:15:32.656 --> 18:15:35.656
though. But there is pinning
data, you can add data to this.

17989
18:15:35.656 --> 18:15:38.656
So let me explain how this
actually works. And you can read

17990
18:15:38.656 --> 18:15:40.656
how this works on the site,
there's going to be a link to

17991
18:15:40.656 --> 18:15:42.656
this and the GitHub repo
associated with this course. But

17992
18:15:42.656 --> 18:15:46.656
we give you my basic take on it.
So we have our code, or our

17993
18:15:46.656 --> 18:15:50.656
file, or whatever it is, right,
we have some piece of data. Now

17994
18:15:50.656 --> 18:15:53.656
as we know, when you really have
anything, you can hash that

17995
18:15:53.656 --> 18:15:57.656
thing, you can hash that data,
right, so you can get a unique

17996
18:15:57.656 --> 18:16:00.656
output. So and that's actually
the first thing that IPFS does.

17997
18:16:00.656 --> 18:16:04.656
It hashes our data to get a
unique hash, that only points to

17998
18:16:04.656 --> 18:16:09.657
that data. Yes, a massive code
file a ton of text. Yes, you can

17999
18:16:09.657 --> 18:16:13.657
encode all of that into a single
hash function, your IPFS node

18000
18:16:13.657 --> 18:16:17.657
does this hashing for you. And
every single IPFS node on the

18001
18:16:17.657 --> 18:16:21.657
planet has the exact same
hashing function, kind of like a

18002
18:16:21.657 --> 18:16:25.657
blockchain, right, they all kind
of run this same spec, the same

18003
18:16:25.657 --> 18:16:29.657
specification. So we can hash
our data on our IPFS node and

18004
18:16:29.657 --> 18:16:32.657
get this unique output. What we
can do then is we can pin that

18005
18:16:32.657 --> 18:16:36.657
data or pin that code, or pin
that file or pin that whatever,

18006
18:16:36.657 --> 18:16:40.657
to our node, we have some data,
we get a unique hash of it, all

18007
18:16:40.657 --> 18:16:43.657
it does is host this data and
have these hashes. That's it,

18008
18:16:43.657 --> 18:16:48.657
our node is connected to a
network of other IPFS nodes. So

18009
18:16:48.657 --> 18:16:51.657
there's a massive network of
people running IPFS nodes,

18010
18:16:51.657 --> 18:16:54.657
they're incredibly lightweight,
way lighter weight than any

18011
18:16:54.657 --> 18:16:57.657
other blockchain node. And they
all talk to each other. So if I

18012
18:16:57.657 --> 18:17:00.657
asked the network, hey, I want
to get this hash. All these

18013
18:17:00.657 --> 18:17:03.657
nodes would talk to each other.
And eventually they'd reach up

18014
18:17:03.657 --> 18:17:07.657
at our node saying, Oh, I found
a node that has that hash.

18015
18:17:07.657 --> 18:17:09.657
Here's the file associated with
it. Now, you might be thinking,

18016
18:17:09.657 --> 18:17:12.657
Okay, well, that's kind of
centralized, because we have the

18017
18:17:12.657 --> 18:17:15.657
data on one node here, right?
Well, you're right, well, here's

18018
18:17:15.657 --> 18:17:20.657
the thing, what other nodes can
do is they can say, oh, that

18019
18:17:20.657 --> 18:17:24.657
data looks really cool, I want
to have that persist, what they

18020
18:17:24.657 --> 18:17:27.657
can do is they can pin your
hash, they can pin your data,

18021
18:17:27.657 --> 18:17:31.657
and they'll get a copy of your
data on their node. And you can

18022
18:17:31.657 --> 18:17:36.657
keep doing this. And so you
easily allow an entire network

18023
18:17:36.657 --> 18:17:40.657
to easily replicate any code or
any data in a decentralized

18024
18:17:40.657 --> 18:17:42.657
sense. And they're incredibly
easy to spin up. And they're

18025
18:17:42.657 --> 18:17:46.658
incredibly easy to work with
something about IPFS, that makes

18026
18:17:46.658 --> 18:17:49.658
it drastically different than a
blockchain is the can't do smart

18027
18:17:49.658 --> 18:17:52.658
contract, there's no execution,
it can really only store it's

18028
18:17:52.658 --> 18:17:57.658
just decentralized storage that
IPFS can do. Now, the issue here

18029
18:17:57.658 --> 18:18:00.658
is that in order for our data to
really be decentralized, another

18030
18:18:00.658 --> 18:18:04.658
node does need to pin our data,
right? Because if we're the only

18031
18:18:04.658 --> 18:18:08.658
IPFS node that's got this hash,
it's kind of centralized on our

18032
18:18:08.658 --> 18:18:11.658
node, if our node goes down,
that data is gone, and the

18033
18:18:11.658 --> 18:18:14.658
network won't be able to access
that data anymore. So we'll talk

18034
18:18:14.658 --> 18:18:17.658
about strategies in the future
about having other people pin

18035
18:18:17.658 --> 18:18:21.658
your data. But for now, this is
a way we can host data, we can

18036
18:18:21.658 --> 18:18:25.658
send code and have it be in a
decentralized context. So unlike

18037
18:18:25.658 --> 18:18:29.658
a blockchain, where every single
node in a blockchain is going to

18038
18:18:29.658 --> 18:18:33.658
have a copy of the entire
blockchain IPFS nodes get to

18039
18:18:33.658 --> 18:18:37.658
optionally choose which data
they want to pin, and they can't

18040
18:18:37.658 --> 18:18:39.658
do any execution. So you could
have an IPFS node, half a

18041
18:18:39.658 --> 18:18:42.658
megabyte, and you could have an
IPFS node, that several

18042
18:18:42.658 --> 18:18:46.658
terabytes, it's up to the node
operators, how much data and

18043
18:18:46.658 --> 18:18:52.658
what data they want to pin. Now
that we know about IPFS.

18044
18:18:52.658 --> 18:18:57.658
Let's actually deploy our
wonderful application to IPFS so

18045
18:18:57.658 --> 18:19:00.658
that anybody can use it and
anybody can connect to it. So

18046
18:19:00.658 --> 18:19:05.658
long as our node is up. Are you
ready? Okay, get excited here.

18047
18:19:05.658 --> 18:19:08.658
We're first going to do this
kind of the Manuel Wait, because

18048
18:19:08.658 --> 18:19:10.658
I'm going to show you how to
install IPFS. And work with

18049
18:19:10.658 --> 18:19:14.658
IPFS. Hit get started, there's a
number of ways to install and

18050
18:19:14.658 --> 18:19:18.658
work with IPFS, you can get it
with a desktop application, get

18051
18:19:18.658 --> 18:19:23.658
a command line. And then we can
also add IPFS to our browser

18052
18:19:23.658 --> 18:19:28.659
using something like brave or I
think Firefox to some this IPFS

18053
18:19:28.659 --> 18:19:30.659
router is automatically built
it. But if using something like

18054
18:19:30.659 --> 18:19:33.659
Chrome, you might have to add a
little companion, because what

18055
18:19:33.659 --> 18:19:37.659
we want to do is we can actually
use those little hashes as URLs

18056
18:19:37.659 --> 18:19:41.659
for websites, right, and so we
want to be able to put that URL

18057
18:19:41.659 --> 18:19:45.659
in our browser and connect to
that node or that piece of code.

18058
18:19:45.659 --> 18:19:48.659
So what we're gonna do is we're
gonna have you install the IPFS

18059
18:19:48.659 --> 18:19:51.659
desktop, so you're gonna hit
that. And when you do that, you

18060
18:19:51.659 --> 18:19:54.659
should be able to open up IPFS.
Now, if you install it, you

18061
18:19:54.659 --> 18:19:58.659
might get this little guy, this
little box here in your upper

18062
18:19:58.659 --> 18:20:01.659
section. Otherwise, you might be
able to open it up with with

18063
18:20:01.659 --> 18:20:04.659
IPFS desktop and see it as a
regular desktop app. Well, once

18064
18:20:04.659 --> 18:20:08.659
you install it, you might see
IPFS is running, you can restart

18065
18:20:08.659 --> 18:20:11.659
stop, you can do all this stuff,
we're gonna go to the file

18066
18:20:11.659 --> 18:20:15.659
section, and we're gonna get a
little pop up that looks like

18067
18:20:15.659 --> 18:20:17.659
this. Now, I've got a ton of
stuff in here, because I've been

18068
18:20:17.659 --> 18:20:20.659
using IPFS for some time in
here, right now, you might have

18069
18:20:20.659 --> 18:20:24.659
no data. So let's just go ahead
and import some file. And maybe

18070
18:20:24.659 --> 18:20:27.659
for now we'll just import, you
know, our next dot config dot j

18071
18:20:27.659 --> 18:20:30.659
s, right? It doesn't matter,
just import something. And now

18072
18:20:30.659 --> 18:20:34.659
in here, we have this next dot
config dot j s or whatever file

18073
18:20:34.659 --> 18:20:37.659
you import it. So what we can do
with this is we can actually

18074
18:20:37.659 --> 18:20:43.659
copy the CID. And we can view
this in our browser. So if we do

18075
18:20:43.659 --> 18:20:47.659
IPFS dot dot slash slash, and we
paste it in, we hit enter, we

18076
18:20:47.659 --> 18:20:53.659
can give our browser access to
actually rendering IPFS URLs. If

18077
18:20:53.659 --> 18:20:57.659
using brave, you can just do use
a brave local IPFS node or let's

18078
18:20:57.659 --> 18:21:00.659
go ahead and download this IPFS
companion. So we'll get IPFS

18079
18:21:00.659 --> 18:21:04.659
companion, there's a Firefox
install for Chrome brave, blah,

18080
18:21:04.659 --> 18:21:07.660
blah, blah. So I'm gonna go to
the Chrome store to get it for

18081
18:21:07.660 --> 18:21:11.660
brave, we're just going to hit
Add to brave add extension. But

18082
18:21:11.660 --> 18:21:13.660
once you download it, you'll get
something that looks like this.

18083
18:21:13.660 --> 18:21:16.660
Even on a little browser
companion, we can see like

18084
18:21:16.660 --> 18:21:19.660
import, we can see stuff about
our node, if we click our node,

18085
18:21:19.660 --> 18:21:22.660
we will see a very similar
setup. But now that we have the

18086
18:21:22.660 --> 18:21:27.660
companion in our browser, we can
copy that Cid that hash. Now

18087
18:21:27.660 --> 18:21:30.660
brave, we can just do use brave
local IPFS node, and will

18088
18:21:30.660 --> 18:21:35.660
automatically get dropped into
the file. Now, if IPFS companion

18089
18:21:35.660 --> 18:21:38.660
doesn't work for you, and you
can't see the URL inside of

18090
18:21:38.660 --> 18:21:42.660
something like Google Chrome or
some other browser, what you can

18091
18:21:42.660 --> 18:21:45.660
do is you can use something
called the IPFS gateway. Now

18092
18:21:45.660 --> 18:21:49.660
using a gateway, you're not
actually directly requesting the

18093
18:21:49.660 --> 18:21:53.660
data through IPFS requesting the
data through another server,

18094
18:21:53.660 --> 18:21:56.660
which is requesting it through
IPFS. But if you are having some

18095
18:21:56.660 --> 18:22:00.660
trouble accessing these files,
you can use the gateway. So what

18096
18:22:00.660 --> 18:22:05.660
you'll do is we'll do HTTPS,

18097
18:22:05.660 --> 18:22:11.660
slash IPFS, slash and then paste
the hash code there. And you'll

18098
18:22:11.660 --> 18:22:14.660
be able to see your file. Now if
you do it like this, you won't

18099
18:22:14.660 --> 18:22:17.660
even need IPFS companion at all.
So we're going to deploy our

18100
18:22:17.660 --> 18:22:22.660
website to IPFS. So that anybody
else who wants to pin this can,

18101
18:22:22.660 --> 18:22:26.660
and we will now have the ability
to have an incorruptible, in

18102
18:22:26.660 --> 18:22:29.660
unputdownable website, which is
just awesome. We're going to

18103
18:22:29.660 --> 18:22:32.660
learn how to do this the wrong
way first, and then we're going

18104
18:22:32.660 --> 18:22:34.660
to use a tool that's going to
make it a lot easier for us.

18105
18:22:34.660 --> 18:22:39.660
Okay, so first, let's go to our
website here. And, and if you

18106
18:22:39.660 --> 18:22:41.660
want to deploy to rink B, go
ahead and feel free. Just

18107
18:22:41.660 --> 18:22:46.661
remember to make sure that your
contract addresses file updates

18108
18:22:46.661 --> 18:22:50.661
accordingly. Okay. Now, next,
Jas has the ability to create

18109
18:22:50.661 --> 18:22:54.661
static websites. And that's
going to be an important term to

18110
18:22:54.661 --> 18:22:57.661
know we're going to make a
static website. At the moment,

18111
18:22:57.661 --> 18:23:02.661
we don't want our website to be
tangled with any server stuff.

18112
18:23:02.661 --> 18:23:04.661
And the reason we we don't want
it to be tangled with any server

18113
18:23:05.661 --> 18:23:07.661
stuff is because if our website
runs with server stuff, and we

18114
18:23:07.661 --> 18:23:11.661
deploy it to IPFS, will IPFS
doesn't have the ability to run

18115
18:23:11.661 --> 18:23:14.661
any code, it just hosts code. If
our front end has any server

18116
18:23:14.661 --> 18:23:18.661
stuff, it won't work. Now, in
its current state IPFS can't

18117
18:23:18.661 --> 18:23:21.661
come to our project and know
what to do, right, it doesn't

18118
18:23:21.661 --> 18:23:24.661
know how to do yarn dev can't do
yarn Dev. So we need to put all

18119
18:23:24.661 --> 18:23:28.661
of our code into its static
equivalents. So to do that,

18120
18:23:28.661 --> 18:23:32.661
we're gonna do yarn build. And
if again, if we look at our

18121
18:23:32.661 --> 18:23:36.661
package dot JSON, it comes with
this build, which just runs next

18122
18:23:36.661 --> 18:23:39.661
build. And running this build
command is going to build our

18123
18:23:39.661 --> 18:23:42.661
code, what's called like a
production build, creating an

18124
18:23:42.661 --> 18:23:46.661
optimized production build here.
And we'll get something that

18125
18:23:46.661 --> 18:23:49.661
looks like this. And we can see
this point down here. Static,

18126
18:23:49.661 --> 18:23:53.661
automatically rendered as static
HTML uses no initial props.

18127
18:23:53.661 --> 18:23:57.661
There's some server based
applications that next Jas comes

18128
18:23:57.661 --> 18:24:00.661
with that if we use them. Our
static build won't work. And

18129
18:24:00.661 --> 18:24:04.661
actually, you'll see when we run
yarn, next export, it'll fail if

18130
18:24:05.661 --> 18:24:08.661
you have any that non static
stuff. So let's Go ahead and try

18131
18:24:08.661 --> 18:24:11.661
yarn next export. And let's see
if it fails, it didn't fail, we

18132
18:24:11.661 --> 18:24:15.661
now have a new folder called
out. And this is our folder,

18133
18:24:15.661 --> 18:24:19.661
that's just pure static code and
that we can use on IPFS. In a

18134
18:24:19.661 --> 18:24:22.661
later section, I'll show you
what it looks like when you

18135
18:24:22.661 --> 18:24:25.661
don't use some of those static
things. Both Morales and next

18136
18:24:25.661 --> 18:24:28.662
Jas have the optionality to not
have static code. So we'll just

18137
18:24:28.662 --> 18:24:31.662
want to keep that in mind. So
now that we have this out

18138
18:24:31.662 --> 18:24:35.662
folder, we can go back to IPFS.
And we can import a folder,

18139
18:24:35.662 --> 18:24:39.662
we're going to import that whole
folder in here. So hit that hit

18140
18:24:39.662 --> 18:24:43.662
that import button and go to the
folder. Where that is mine is in

18141
18:24:43.662 --> 18:24:47.662
next year smart contract lottery
out. So now we're going to

18142
18:24:47.662 --> 18:24:50.662
upload this to our IPFS node.
Once it's done, we'll get this

18143
18:24:50.662 --> 18:24:54.662
little checkmark. And we can go
through IPFS files and see our

18144
18:24:54.662 --> 18:24:58.662
output here. What we can do,
let's go ahead and pin this to

18145
18:24:58.662 --> 18:25:01.662
our node, we'll pin it to our
local node here. And now once

18146
18:25:01.662 --> 18:25:05.662
it's up, we can copy the CID and
go back to brave or chrome or

18147
18:25:05.662 --> 18:25:10.662
whatever. You type in IPFS colon
slash slash, paste that in

18148
18:25:11.662 --> 18:25:15.662
there. And we immediately get
dropped into our smart contract

18149
18:25:15.662 --> 18:25:19.662
lottery in a browser. And we see
hi from lottery, no raffle

18150
18:25:19.662 --> 18:25:22.662
address detected, because right
now the way I set mine up Was it

18151
18:25:22.662 --> 18:25:25.662
only works with, you know, our
local hard hats, let's connect

18152
18:25:25.662 --> 18:25:29.662
our Metamask we'll hit the
connect button, connect, and

18153
18:25:29.662 --> 18:25:33.662
voila, we are right back where
we were. But with our data

18154
18:25:33.662 --> 18:25:37.662
stored in IPFS, we can enter
raffle as long as our node is

18155
18:25:37.662 --> 18:25:41.662
running a confirm. And we see
exactly what we get in our local

18156
18:25:41.662 --> 18:25:46.662
browsers. So this is phenomenal.

18157
18:25:46.662 --> 18:25:49.662
Now that I've shown you how to
do this, this is the manual way

18158
18:25:49.662 --> 18:25:54.662
of adding our code to IPFS. Let
me show you the easier way of

18159
18:25:54.662 --> 18:25:57.662
adding your code to IPFS we're
gonna go to this site called

18160
18:25:57.662 --> 18:26:03.662
fleek HQ. Go to fleek.co. And to
get to it, I'm going to turn my

18161
18:26:03.662 --> 18:26:06.663
my IPFS companion note off
because of some of the oddities

18162
18:26:06.663 --> 18:26:10.663
with working with brave but now
we're here@flickr.co fleek.co

18163
18:26:10.663 --> 18:26:13.663
makes it easy to to deploy
websites and apps to the new

18164
18:26:13.663 --> 18:26:16.663
open web permissionless,
trustless, censorship resistant,

18165
18:26:16.663 --> 18:26:19.663
etc. I like to think about it as
kind of like an auto deployment

18166
18:26:19.663 --> 18:26:22.663
for our websites. And
additionally, it does some

18167
18:26:22.663 --> 18:26:25.663
things to help out with that
problem. I was talking about how

18168
18:26:25.663 --> 18:26:29.663
we want to get other nodes to
pin our data. So it helps us out

18169
18:26:29.663 --> 18:26:32.663
with that. So let me show you
what it does. So let's go ahead,

18170
18:26:32.663 --> 18:26:35.663
we'll sign up. And why don't you
know, you can sign in with

18171
18:26:35.663 --> 18:26:38.663
GitHub. So if you have your
GitHub, definitely want to sign

18172
18:26:38.663 --> 18:26:42.663
in with GitHub here. Because
we're going to use GitHub to

18173
18:26:42.663 --> 18:26:46.663
actually help us automatically
deploy. So we'll authorize fleet

18174
18:26:46.663 --> 18:26:49.663
to work with our GitHub. You've
authorized your GitHub, let's go

18175
18:26:49.663 --> 18:26:52.663
ahead and add a new site or add
new site. Now we can use fleet

18176
18:26:52.663 --> 18:26:55.663
to just automatically deploy
websites, once we push them to

18177
18:26:55.663 --> 18:27:00.663
our GitHub. So we can come to
our GitHub once again. And click

18178
18:27:00.663 --> 18:27:03.663
the little plus button, we'll do
a new repository. We'll call

18179
18:27:03.663 --> 18:27:09.663
this next Jas smart contract,
lottery Free Code Camp. We'll

18180
18:27:09.663 --> 18:27:15.663
make it public create the
repository. Let's push all this

18181
18:27:15.663 --> 18:27:18.663
code to GitHub. We did it once
before, let's do it again. We'll

18182
18:27:18.663 --> 18:27:22.663
do git add, we'll do a little
dot, then we'll do git commit

18183
18:27:22.663 --> 18:27:31.663
minus m, say like initial commit
or whatever. We'll do git

18184
18:27:31.663 --> 18:27:39.663
remote, add origin, and then
we'll grab that URL, paste it

18185
18:27:39.663 --> 18:27:45.663
right here. And then we'll just
do git push origin, main. Now we

18186
18:27:45.663 --> 18:27:48.664
go back to our application we
see it in here we can do is back

18187
18:27:48.664 --> 18:27:52.664
in our fleek. We can connect
with GitHub, we're going to say

18188
18:27:52.664 --> 18:27:56.664
only select repositories, we're
only going to do this next js

18189
18:27:56.664 --> 18:27:59.664
application, this next JS get
we're going to install an

18190
18:27:59.664 --> 18:28:04.664
Authorize. Authorize Great. So
now we're going to pick a repo

18191
18:28:04.664 --> 18:28:08.664
we've picked a repo, we're going
to choose this application. And

18192
18:28:08.664 --> 18:28:11.664
we're going to use IPFS as our
hosting service. And now we're

18193
18:28:11.664 --> 18:28:14.664
going to add our information in
here. So we're going to use the

18194
18:28:14.664 --> 18:28:18.664
main branch. Here's the repo.
There's gonna be our framework

18195
18:28:18.664 --> 18:28:23.664
is gonna be next Jas. So we're
do fleek next. Jas, we're using

18196
18:28:23.664 --> 18:28:28.664
yarn. So we're gonna do yarn
install, and yarn, run build,

18197
18:28:28.664 --> 18:28:32.664
and then yarn run export. If you
want you could also just do

18198
18:28:32.664 --> 18:28:35.664
yarn, yarn build and yarn run
export, those are gonna be the

18199
18:28:35.664 --> 18:28:38.664
same thing. Publish directory is
going to be out and then we just

18200
18:28:38.664 --> 18:28:43.664
hit Deploy site, yarn, next
export as the last command, not

18201
18:28:43.664 --> 18:28:47.664
yarn, run, export. The accident
did the wrong one, you go over

18202
18:28:47.664 --> 18:28:51.664
deploys. Click on this, go to
deploy settings and then Edit

18203
18:28:51.664 --> 18:28:57.664
Settings and then just change it
to yarn. Next, export save. Then

18204
18:28:57.664 --> 18:28:59.664
we'll go back to deploys and
trigger deploy, if you did the

18205
18:28:59.664 --> 18:29:02.664
wrong one that was just a
learning opportunity for you to

18206
18:29:02.664 --> 18:29:05.664
learn where the settings are
after you deploy. And what this

18207
18:29:05.664 --> 18:29:08.664
is going to do is we're going to
do to deploy, it's going to run

18208
18:29:08.664 --> 18:29:11.664
those three commands yarn build,
yarn export, it's going to run

18209
18:29:11.664 --> 18:29:14.664
everything. And then it's going
to deploy a site for us both on

18210
18:29:14.664 --> 18:29:20.664
IPFS. And it's going to give a
regular URL that we can use for

18211
18:29:20.664 --> 18:29:24.664
normies, if you will. And while
this deploys, you'll actually

18212
18:29:24.664 --> 18:29:28.665
see down here we have this thing
called file coin di D in deal

18213
18:29:28.665 --> 18:29:32.665
proposal, Cid IPFS. Like I said,
we need other people to host our

18214
18:29:32.665 --> 18:29:36.665
node. File coin is actually a
blockchain that helps you pin

18215
18:29:36.665 --> 18:29:40.665
your data and uses decentralized
storage to do so. And fleek

18216
18:29:40.665 --> 18:29:44.665
helps you create those deals and
helps you pin your data with

18217
18:29:44.665 --> 18:29:46.665
this filecoin Blockchain
filecoin is one definitely to

18218
18:29:46.665 --> 18:29:49.665
take a look at. And then after a
while, you might have to wait a

18219
18:29:49.665 --> 18:29:53.665
little bit. And once it's done,
get a little deployed website,

18220
18:29:53.665 --> 18:29:58.665
we go back to hosting, we click
on our thing we can see we have

18221
18:29:58.665 --> 18:30:02.665
like a little website here. And
if we click it, we get a normal

18222
18:30:02.665 --> 18:30:06.665
URL for connecting and
interacting with our website,

18223
18:30:06.665 --> 18:30:09.665
you might even see this little
IPFS thing which will connect to

18224
18:30:09.665 --> 18:30:12.665
your IPFS node. And
additionally, we scroll down in

18225
18:30:12.665 --> 18:30:16.665
here we can see current IPFS
hash, so we can just stick that

18226
18:30:16.665 --> 18:30:22.665
in, um, and Bada bing, we have
an IP Fs deployed application.

18227
18:30:22.665 --> 18:30:25.665
Now what's cool is let's say I
make some changes, you know,

18228
18:30:25.665 --> 18:30:29.665
I'll go to lottery entrance. And
I'll do, I'll scroll on the

18229
18:30:29.665 --> 18:30:35.665
bottom to recent winner, I'll
make a new div. What a close the

18230
18:30:35.665 --> 18:30:42.665
div off, we'll save git add dot
Git commit minus m, add a dot

18231
18:30:42.665 --> 18:30:46.665
git push origin mean.

18232
18:30:46.665 --> 18:30:50.665
In our GitHub, we'll do a little
refresh, add a.as, the most

18233
18:30:50.665 --> 18:30:54.665
recently added one, go back over
to fleek. Go back to hosting

18234
18:30:54.665 --> 18:30:58.665
click on the section that we
just made go to deploys, and

18235
18:30:58.665 --> 18:31:02.665
you'll see there's a new deploy
going through. So it

18236
18:31:02.665 --> 18:31:05.665
automatically deploys your new
site, it'll automatically create

18237
18:31:05.665 --> 18:31:08.666
a new IPFS hash for your new
data. However, it'll still be on

18238
18:31:08.666 --> 18:31:12.666
this holy bird, you know, or
whatever your URL is here. And

18239
18:31:12.666 --> 18:31:16.666
this is kind of just a router
for IPSs. So that people without

18240
18:31:16.666 --> 18:31:20.666
IPFS connected can also connect
to this still. And now that my

18241
18:31:20.666 --> 18:31:23.666
application is done, pushing
automatically, with fleek, we

18242
18:31:23.666 --> 18:31:29.666
can see what's up being post in
my application here. Now, like I

18243
18:31:29.666 --> 18:31:32.666
said, filecoin isn't going to be
a technology, we're gonna go too

18244
18:31:32.666 --> 18:31:36.666
deep into introduce ourselves.
But like I was just saying IPFS

18245
18:31:36.666 --> 18:31:41.666
does have this limitation. It
doesn't have data persistence,

18246
18:31:41.666 --> 18:31:44.666
you have to have people pin your
data, in order for it to stay

18247
18:31:44.666 --> 18:31:48.666
distributed, and stay
decentralized. File coin is a

18248
18:31:48.666 --> 18:31:52.666
blockchain dedicated to keeping
this data, both decentralized

18249
18:31:52.666 --> 18:31:55.666
and persistent. And to give us a
better understanding of

18250
18:31:55.666 --> 18:31:58.666
filecoin. We actually have Ali
here to give us an overview.

18251
18:31:58.666 --> 18:32:00.666
Take it away, Ali. Hello, I'm

18252
18:32:00.666 --> 18:32:03.666
Ali, and I'm a developer
advocate here at the filecoin

18253
18:32:03.666 --> 18:32:07.666
Foundation, which works closely
with protocol labs and IPFS.

18254
18:32:07.666 --> 18:32:13.666
Just a quick note, protocol Labs
is our r&d arm. So it works on

18255
18:32:13.666 --> 18:32:17.666
creating tooling and technology
for a truly open and democratic

18256
18:32:17.666 --> 18:32:20.666
internet and web. And it's
building out some of the

18257
18:32:20.666 --> 18:32:23.666
foundational tooling like IPFS,
and filecoin, which are two

18258
18:32:23.666 --> 18:32:27.666
separate projects to enable
that. And hopefully, today,

18259
18:32:27.666 --> 18:32:30.666
because you're here to build, I
want to impart on you the

18260
18:32:30.666 --> 18:32:32.666
knowledge and tools you need to
get started with both of those

18261
18:32:32.666 --> 18:32:36.666
projects. So as anyone that's
kind of played around in this

18262
18:32:36.666 --> 18:32:39.666
ecosystem, or tech, in general
would know, data is an

18263
18:32:39.666 --> 18:32:42.666
absolutely essential part of our
daily lives. And not

18264
18:32:42.666 --> 18:32:46.666
surprisingly, it's also a super
fast growing field in web three,

18265
18:32:46.666 --> 18:32:49.667
and one, that's fundamental one,
and it's one of the fundamental

18266
18:32:49.667 --> 18:32:52.667
necessities of the decentralized
web stack as well. So the

18267
18:32:52.667 --> 18:32:56.667
current model of centralization
that's grown up, and basically

18268
18:32:56.667 --> 18:32:59.667
out of a lack of an identity
layer on the internet, is one

18269
18:32:59.667 --> 18:33:02.667
where only a few big companies
offer storage, and only a few

18270
18:33:02.667 --> 18:33:05.667
entities hold our data for
authorization purposes. And this

18271
18:33:05.667 --> 18:33:08.667
is an obvious problem, both in
terms of being an attack vector

18272
18:33:08.667 --> 18:33:12.667
for data mining, so without
data, getting leaked through

18273
18:33:12.667 --> 18:33:17.667
insecure service to third
parties, and also creating a

18274
18:33:17.667 --> 18:33:20.667
data resilience problem. So
whole services go down every

18275
18:33:20.667 --> 18:33:22.667
time one of these companies
servers does and we've

18276
18:33:22.667 --> 18:33:26.667
definitely seen that. So it
really leads to the question,

18277
18:33:26.667 --> 18:33:29.667
why aren't we designing the web
for the autonomy and resilience

18278
18:33:29.667 --> 18:33:31.667
we need in the first place? And
how do we store data in a way

18279
18:33:31.667 --> 18:33:35.667
that aligns with both the
original vision of the internet

18280
18:33:35.667 --> 18:33:38.667
as an open place for knowledge
sharing and collaboration, and,

18281
18:33:38.667 --> 18:33:43.667
and, and in a way that agrees
with the web three mission as

18282
18:33:43.667 --> 18:33:46.667
well. So these are the core
problems we're solving with IPFS

18283
18:33:46.667 --> 18:33:50.667
and file coin. Firstly, IPFS is
a distributed system for storing

18284
18:33:50.667 --> 18:33:54.667
and accessing files, folders,
websites, applications and data.

18285
18:33:54.667 --> 18:33:56.667
And it's designed to be able to
work even when the networks

18286
18:33:56.667 --> 18:34:00.667
between planets, so it's a
distributed by design, it has no

18287
18:34:00.667 --> 18:34:03.667
central authority servers, and
it's designed to be offline

18288
18:34:03.667 --> 18:34:05.667
first for resilience. And it's
not just a fancy name for

18289
18:34:05.667 --> 18:34:08.667
another peer to peer network
either. Because the nice thing

18290
18:34:08.667 --> 18:34:12.667
about the IPFS protocol is the
standard it uses for addressing

18291
18:34:12.667 --> 18:34:16.667
content on the network. IPFS is
unique because rather than using

18292
18:34:16.667 --> 18:34:20.667
traditional methods we might be
with familiar with from the web,

18293
18:34:20.667 --> 18:34:24.667
like those are location parts
that point to a particular HTTP

18294
18:34:24.667 --> 18:34:28.668
address where your content may
or may not be available and

18295
18:34:28.668 --> 18:34:32.668
stored. IPFS uses content
addressing so content addressing

18296
18:34:32.668 --> 18:34:36.668
means that each piece of data,
each meme or even full file

18297
18:34:36.668 --> 18:34:39.668
system has its own unique
cryptographically verifiable

18298
18:34:39.668 --> 18:34:43.668
fingerprint, you might call it.
So if you change even one pixel

18299
18:34:43.668 --> 18:34:47.668
of your main image, for example,
then the content ID or Cid

18300
18:34:47.668 --> 18:34:52.668
associated with it also changes.
So importantly, this hash

18301
18:34:52.668 --> 18:34:55.668
function is also upgradeable. So
let's say quantum computing

18302
18:34:55.668 --> 18:34:58.668
breaks out current secure hash
algorithms, we can upgrade the

18303
18:34:58.668 --> 18:35:02.668
standard we use. And it means
you will always get the same

18304
18:35:02.668 --> 18:35:07.668
content returned by an IPFS. Cid
as what you expect. So this is

18305
18:35:07.668 --> 18:35:10.668
fundamentally important, because
when you don't have to care

18306
18:35:10.668 --> 18:35:14.668
where the data comes from, you
open up the web to massively

18307
18:35:14.668 --> 18:35:18.668
distributed storage systems.
Hello, decentralization. So now

18308
18:35:18.668 --> 18:35:21.668
we have a really important and
valuable protocol that enables

18309
18:35:21.668 --> 18:35:25.668
distribution at scale. And it
provides verifiability of data

18310
18:35:25.668 --> 18:35:28.668
to serve and retrieve content on
the web. And not just for web

18311
18:35:28.668 --> 18:35:33.668
three, either, but also for all
web, or tech use cases. The

18312
18:35:33.668 --> 18:35:36.668
problem is, and it's one that
the early internet also faced,

18313
18:35:36.668 --> 18:35:39.668
who's going to ensure the
persistence and permanence of

18314
18:35:39.668 --> 18:35:42.668
all this data on the network. So
unless you're running your own

18315
18:35:42.668 --> 18:35:46.668
nodes 24/7, or your content is
really popular or other nodes

18316
18:35:46.668 --> 18:35:49.668
decide to altruistically store
your data. Because I think it's

18317
18:35:49.668 --> 18:35:52.668
important, then this data can
become unreliable because

18318
18:35:53.668 --> 18:35:55.668
they're no longer actively
hosted on any nodes on the

18319
18:35:55.668 --> 18:35:58.668
network's. So to avoid this, you
could also turn to a pinning

18320
18:35:58.668 --> 18:36:02.668
service that you pay to keep a
copy of your content around.

18321
18:36:02.668 --> 18:36:04.668
Unfortunately, the problem with
this though, is that we're

18322
18:36:04.668 --> 18:36:07.669
heading back towards
centralization of data. And

18323
18:36:07.669 --> 18:36:11.669
we're creating new data silos
with this solution and losing

18324
18:36:11.669 --> 18:36:13.669
the trust lessness and
resilience we're looking for.

18325
18:36:13.669 --> 18:36:18.669
And these one a bad solution
prior to file coin, and it's why

18326
18:36:18.669 --> 18:36:22.669
they sprung up initially, but we
want a better solution. So this

18327
18:36:22.669 --> 18:36:26.669
is where file coin comes in. So
far coins architecture, then

18328
18:36:26.669 --> 18:36:29.669
designed to leverage a crypto
economic incentive model

18329
18:36:29.669 --> 18:36:33.669
together with cryptographic
proofs in order to ensure data

18330
18:36:33.669 --> 18:36:38.669
is stored persistently, highly
reliably and verifiably. It uses

18331
18:36:38.669 --> 18:36:41.669
these cryptographic proofs to
also enable smart contract based

18332
18:36:41.669 --> 18:36:45.669
permanence. And that means that
it's designed to be as permanent

18333
18:36:45.669 --> 18:36:48.669
as you, the data owner want it
to be. It's your data, so it's

18334
18:36:48.669 --> 18:36:52.669
your choice. It's also designed
to enable internet scale

18335
18:36:52.669 --> 18:36:55.669
capacity. It's currently the
largest distributed storage

18336
18:36:55.669 --> 18:37:00.669
network in the world with over
18 million terabytes of capacity

18337
18:37:00.669 --> 18:37:05.669
available, which is apparently
about 135 copies of the European

18338
18:37:05.669 --> 18:37:09.669
Union's nuclear program, CERN's
data which, which is kind of a

18339
18:37:09.669 --> 18:37:14.669
fun fact. It's also file coins
also designed to be and stay

18340
18:37:14.669 --> 18:37:19.669
hyper competitive on pricing due
to its market economics. And

18341
18:37:19.669 --> 18:37:23.669
this comes down to storage
deals. So to make this network

18342
18:37:23.669 --> 18:37:27.669
feasible, filecoin uses storage
deals. And these include two

18343
18:37:27.669 --> 18:37:30.669
main consensus mechanisms that
ensure both rewards for good

18344
18:37:30.669 --> 18:37:33.669
actors in the system, and
penalties for bad actors. So

18345
18:37:33.669 --> 18:37:36.669
when you make a deal with one or
more storage providers to store

18346
18:37:36.669 --> 18:37:39.669
your important data, the
provider generates a proof of

18347
18:37:39.669 --> 18:37:43.669
replication. So this proves that
the storage provider is storing

18348
18:37:43.669 --> 18:37:48.670
a unique copy of your original
data over time to make sure that

18349
18:37:48.670 --> 18:37:53.670
this data is persisted. These
storage providers must prove

18350
18:37:53.670 --> 18:37:56.670
that they still have random
subsets of this client data and

18351
18:37:56.670 --> 18:37:59.670
they create proof of space
times. And these proof this

18352
18:37:59.670 --> 18:38:04.670
proof of space time is something
that is stored on the

18353
18:38:04.670 --> 18:38:07.670
blockchain. So anyone at any
time can also check that this is

18354
18:38:07.670 --> 18:38:11.670
true. And it also makes up the
mechanism by which miners are

18355
18:38:11.670 --> 18:38:15.670
rewarded or penalized because
you have to stake Phil on the

18356
18:38:15.670 --> 18:38:19.670
network in order to become a
storage provider. So when a

18357
18:38:19.670 --> 18:38:24.670
storage deal comes to an end, or
user can you can opt to let it

18358
18:38:24.670 --> 18:38:27.670
expire or renew the deal. If you
opt for renewal, then the

18359
18:38:27.670 --> 18:38:31.670
providers again bid to host this
content. So this creates an

18360
18:38:31.670 --> 18:38:34.670
efficient market for pricing a
continual efficient market for

18361
18:38:34.670 --> 18:38:38.670
pricing as well. It can even go
negative. So the storage

18362
18:38:38.670 --> 18:38:40.670
provider can even pay you to
store your data if it's an

18363
18:38:40.670 --> 18:38:43.670
important data set due to some
of the block rewards that are

18364
18:38:43.670 --> 18:38:48.670
being offered by the filecoin
Foundation as well. So these

18365
18:38:48.670 --> 18:38:52.670
mechanisms are what built in not
just data permanence, but data

18366
18:38:52.670 --> 18:38:55.670
timeframes, sovereignty, too so
it's your data, it's your

18367
18:38:55.670 --> 18:38:57.670
choice. You can decide you want
to store your data for five

18368
18:38:57.670 --> 18:39:01.670
minutes or 500 years. It's also
your choice over how much

18369
18:39:01.670 --> 18:39:05.670
resilience you want to have that
data so or how many copies of

18370
18:39:05.670 --> 18:39:08.670
that data you want to have and
with what store to providers. So

18371
18:39:08.670 --> 18:39:13.670
this allows you to comply with
regulations like GDPR. And

18372
18:39:13.670 --> 18:39:15.670
there's a growing number of
tools in the ecosystem like

18373
18:39:15.670 --> 18:39:19.670
murmurations bit screen that are
allowing for you to do this

18374
18:39:19.670 --> 18:39:24.670
filtering. But it also gives you
some guarantees that your data,

18375
18:39:24.670 --> 18:39:27.670
you know, if one storage
provided goes down, you know,

18376
18:39:27.670 --> 18:39:30.671
surely not 10 of them are going
to go down. So that's a

18377
18:39:30.671 --> 18:39:34.671
guarantee for your resilience
there as well.

18378
18:39:34.671 --> 18:39:36.671
And this is why IPFS and
filecoin are great complements

18379
18:39:36.671 --> 18:39:40.671
of each other. So IPF s gives
you that benefit of content

18380
18:39:40.671 --> 18:39:43.671
addressing file coin gives you
persistent guarantees that even

18381
18:39:43.671 --> 18:39:45.671
if your computer or your
favorite IPFS pinning service

18382
18:39:45.671 --> 18:39:50.671
where to go away, the content
persists. Just as a quick final

18383
18:39:50.671 --> 18:39:53.671
note on these concepts as well,
IPFS and file coin is separate

18384
18:39:53.671 --> 18:39:57.671
projects, as I mentioned. So
IPFS is a protocol much like

18385
18:39:57.671 --> 18:40:02.671
HTTP, whereas file coin is a
blockchain. So IPFS is also

18386
18:40:02.671 --> 18:40:05.671
storage layer agnostic, you can
combine it with the storage

18387
18:40:05.671 --> 18:40:08.671
layer of your choice. And while
file coin was specifically

18388
18:40:08.671 --> 18:40:11.671
designed to complement it, and
we think is a great choice, you

18389
18:40:11.671 --> 18:40:15.671
can also store your IPFS data in
the cloud or an other storage

18390
18:40:15.671 --> 18:40:19.671
solutions as well. So hopefully,
you've got a good baseline for

18391
18:40:19.671 --> 18:40:22.671
why you'd want to use IPFS, and
filecoin. And for those

18392
18:40:22.671 --> 18:40:25.671
engineers out there that like a
challenge, and are interested in

18393
18:40:25.671 --> 18:40:30.671
working on the base protocols
and code of IPFS, and file coin,

18394
18:40:30.671 --> 18:40:33.671
which isn't always easy for the
average user, I'd encourage you

18395
18:40:33.671 --> 18:40:36.671
to go and take a look at the
project docs and get hubs and

18396
18:40:36.671 --> 18:40:39.671
some of the associated grants
available for extensions to

18397
18:40:39.671 --> 18:40:42.671
these open source projects. And
this is a great site here if you

18398
18:40:42.671 --> 18:40:45.671
want to get more information
into the nitty gritty and really

18399
18:40:45.671 --> 18:40:49.671
dig into the code behind IPFS
and filecoin. And extend some of

18400
18:40:49.671 --> 18:40:52.671
that. For those of you that just
want to build out of the box

18401
18:40:52.671 --> 18:40:55.671
though. And this is definitely a
camp that I often fall into. I

18402
18:40:55.671 --> 18:40:57.671
want to talk about some of the
dev tooling and storage helpers

18403
18:40:57.671 --> 18:41:01.671
that make it easy for you to get
started. So firstly, Flake Flake

18404
18:41:01.671 --> 18:41:04.671
is one of my favorite IPFS dev
tools. And projects Flake is a

18405
18:41:04.671 --> 18:41:09.672
CI CD tool that you can use to
deploy your apps for free as

18406
18:41:09.672 --> 18:41:12.672
simply as easy as you would with
some of the web tools you might

18407
18:41:12.672 --> 18:41:16.672
web to tools you might be
familiar with like Netlify

18408
18:41:16.672 --> 18:41:20.672
oversell. The big difference,
though, is fleek uses IPFS to

18409
18:41:20.672 --> 18:41:23.672
host your site or app. And it
even offers an AES domain

18410
18:41:23.672 --> 18:41:26.672
routing on their platform. So if
you're deploying a front end

18411
18:41:26.672 --> 18:41:29.672
app, I would encourage you to
use fleek to make it more

18412
18:41:29.672 --> 18:41:33.672
distributed instead of some of
the traditional web two tools.

18413
18:41:33.672 --> 18:41:37.672
It's just as easy, I promise. So
another one of my favorite tools

18414
18:41:37.672 --> 18:41:41.672
is NFT storage, storing your NFT
metadata immutably and

18415
18:41:41.672 --> 18:41:45.672
persistently, as you already
probably know, is integral to

18416
18:41:45.672 --> 18:41:48.672
keeping the main value
proposition of NF Ts, then on

18417
18:41:48.672 --> 18:41:53.672
fungibility. So if you're not
storing this data on chain,

18418
18:41:53.672 --> 18:41:57.672
which obviously can become
pretty financially unviable for

18419
18:41:57.672 --> 18:42:00.672
large files, then this is
exactly where NF T storage comes

18420
18:42:00.672 --> 18:42:03.672
in. So it was specifically
created as a public good to

18421
18:42:03.672 --> 18:42:07.672
archive and persist NF T data.
So it's free. And it takes care

18422
18:42:07.672 --> 18:42:11.672
of the complexity around firstly
creating an IPFS Cid for this

18423
18:42:11.672 --> 18:42:15.672
metadata, and then making
automatic deals with filecoin

18424
18:42:15.672 --> 18:42:19.672
storage providers. So it does
this with at least eight storage

18425
18:42:19.672 --> 18:42:21.672
providers. So eight times
redundancy and it does it with a

18426
18:42:21.672 --> 18:42:25.672
multigenerational timeframe. So
it automatically renews those

18427
18:42:25.672 --> 18:42:28.672
deals. Because it's a public
good, it's all free as well. And

18428
18:42:28.672 --> 18:42:31.672
it's also super easy to use,
because you just need because

18429
18:42:31.672 --> 18:42:36.672
it's a JavaScript service. So
you just need to say import that

18430
18:42:36.672 --> 18:42:39.672
as an NPM package or JavaScript
library and then call the API

18431
18:42:39.672 --> 18:42:45.672
and NFT dot storage takes care
of the rest. For data that isn't

18432
18:42:45.672 --> 18:42:48.673
NF T metadata as well, we built
web three dot storage, web three

18433
18:42:48.673 --> 18:42:53.673
storage is designed to give you
those same web two benefits. So

18434
18:42:53.673 --> 18:42:56.673
similar to NF T dot storage,
make it super easy for you to

18435
18:42:56.673 --> 18:43:02.673
use. And it's got JavaScript and
go client libraries.

18436
18:43:02.673 --> 18:43:05.673
While giving you you know the
power of IPFS and filecoin of

18437
18:43:05.673 --> 18:43:09.673
decentralized storage and IPFS
content addressing so it's got

18438
18:43:09.673 --> 18:43:12.673
one terabyte after terabyte, one
terabyte of free storage with

18439
18:43:12.673 --> 18:43:15.673
that. So try that out if you're
not just like trying to store

18440
18:43:15.673 --> 18:43:19.673
and obtain metadata. The next
tool is a bit more advanced.

18441
18:43:20.673 --> 18:43:23.673
It's called textil Palghat gate,
and it's for you know, more

18442
18:43:23.673 --> 18:43:27.673
advanced developers or those
looking for more flexibility to

18443
18:43:27.673 --> 18:43:31.673
interact with IPFS live peer to
peer and filecoin. It's a Docker

18444
18:43:31.673 --> 18:43:35.673
container wrapped around
filecoin and IPFS nodes. And it

18445
18:43:35.673 --> 18:43:37.673
gives you a lot of options to
configure it's a minor

18446
18:43:37.673 --> 18:43:40.673
selections and extend
functionality. It also offers

18447
18:43:40.673 --> 18:43:43.673
some bridges to several layer
ones which might be of interest

18448
18:43:43.673 --> 18:43:49.673
to developers out there. Another
one here and I'll preface this

18449
18:43:49.673 --> 18:43:52.673
by saying you need an invite to
this is ESRI tech. So it's for

18450
18:43:52.673 --> 18:43:56.673
people looking to store really
meaningful public data. It's

18451
18:43:56.673 --> 18:44:00.673
currently in alpha mode and like
I said, it requires an invite

18452
18:44:00.673 --> 18:44:03.673
because it's been built as a
public goods specifically to

18453
18:44:03.673 --> 18:44:07.673
store important information. If
you are I do have Use case

18454
18:44:07.673 --> 18:44:11.673
around this slide, please feel
free to reach out to us on this

18455
18:44:11.673 --> 18:44:16.673
project. Other final tool I'll
mention is orbit dB. So many

18456
18:44:16.673 --> 18:44:19.673
people coming to the web three
space from web two are often

18457
18:44:19.673 --> 18:44:22.673
looking for the same sort of
relational databases that we're

18458
18:44:22.673 --> 18:44:25.673
so used to in traditional
computing except in a

18459
18:44:25.673 --> 18:44:30.674
decentralized or distributed
format. And this isn't an easy

18460
18:44:30.674 --> 18:44:33.674
problem. So Oba to me is
currently in active development.

18461
18:44:33.674 --> 18:44:37.674
And because this isn't an easy
problem to solve, this isn't an

18462
18:44:37.674 --> 18:44:40.674
ideal solution for those of you
looking for an out of the box

18463
18:44:40.674 --> 18:44:44.674
experience. But if you are
looking for something like that,

18464
18:44:44.674 --> 18:44:47.674
try out orbit dB. And there's
also several other tools in the

18465
18:44:47.674 --> 18:44:51.674
ecosystem leveraging IPFS and
filecoin, including ceramic,

18466
18:44:51.674 --> 18:44:55.674
which is similar to textil power
gate, except it uses

18467
18:44:55.674 --> 18:44:58.674
decentralized identities.
Lighthouse is file drive, and

18468
18:44:58.674 --> 18:45:04.674
there's even Morales has an IPFS
API, so check those out as well.

18469
18:45:04.674 --> 18:45:07.674
So storage is really a
fundamental component on one

18470
18:45:07.674 --> 18:45:10.674
technology system. So and
there's so many use cases you

18471
18:45:10.674 --> 18:45:13.674
could dive into here. And so
hopefully, I've provided you

18472
18:45:13.674 --> 18:45:15.674
with some of the knowledge and
tools you need to get started

18473
18:45:15.674 --> 18:45:19.674
with IPFS and file Goyt. Coin
and really make powerful

18474
18:45:19.674 --> 18:45:23.674
distributed applications. And
there's just one more tool

18475
18:45:23.674 --> 18:45:26.674
that's also in active
development now. So if you look

18476
18:45:26.674 --> 18:45:29.674
closely at this diagram, you'll
notice probably unfamiliar logo

18477
18:45:29.674 --> 18:45:32.674
right at the end of the logic
layer. And that's the logo for

18478
18:45:32.674 --> 18:45:36.674
the filecoin virtual machine. So
FBM will be launching at the end

18479
18:45:36.674 --> 18:45:40.674
of this year. And we're super
excited about it. And it's going

18480
18:45:40.674 --> 18:45:44.674
to allow smart contracts,
contract use combined with like

18481
18:45:44.674 --> 18:45:48.674
colocation of storage data,
loads, so computing capabilities

18482
18:45:48.674 --> 18:45:51.674
with storage capabilities, and
will also be EVM compatible. So

18483
18:45:51.674 --> 18:45:54.674
as I said, we're super excited
for the kinds of use cases that

18484
18:45:54.674 --> 18:45:58.674
we're going to see come out of
this project as well. And you

18485
18:45:58.674 --> 18:46:02.674
can follow along here on the
website here as well. So

18486
18:46:02.674 --> 18:46:04.674
hopefully, I've given you all
the tools you need to get

18487
18:46:04.674 --> 18:46:08.675
started with IPFS. And file
coin. If you do need more

18488
18:46:08.675 --> 18:46:11.675
resources or want to get
involved, we have proto School,

18489
18:46:11.675 --> 18:46:14.675
which is interactive tutorials
on decentralized web protocols.

18490
18:46:14.675 --> 18:46:19.675
There's also NFT, school dot
Dev, or join a hackathon, check

18491
18:46:19.675 --> 18:46:22.675
out our hackathons.filecoin.io
page for all the latest

18492
18:46:22.675 --> 18:46:25.675
hackathons we're involved in.
And if you do really want to dig

18493
18:46:25.675 --> 18:46:30.675
deep and build tooling in IPFS,
and file coin or build a cool

18494
18:46:30.675 --> 18:46:34.675
project, check out our grants
options as well for that, in the

18495
18:46:34.675 --> 18:46:42.675
meantime, all please learn long
build and prosper.

18496
18:46:42.675 --> 18:46:46.675
So we've learned a ton in this
section. And that is it. So

18497
18:46:46.675 --> 18:46:49.675
let's do a summary of all the
amazing things that we've

18498
18:46:49.675 --> 18:46:52.675
learned. And then we'll go into
the TypeScript edition of this

18499
18:46:52.675 --> 18:46:55.675
because the TypeScript edition
is definitely a little bit

18500
18:46:55.675 --> 18:46:58.675
different. So let's talk.
Alright, so first, we learned

18501
18:46:58.675 --> 18:47:00.675
more about next Jas. And we
learned we can have an

18502
18:47:00.675 --> 18:47:04.675
application using next Jas. And
it's a framework that's gonna

18503
18:47:04.675 --> 18:47:06.675
allow us to build really
powerful front ends and full

18504
18:47:06.675 --> 18:47:10.675
stack applications really
easily. We learned about the

18505
18:47:10.675 --> 18:47:13.675
layout of our next JS project,
we add components in a

18506
18:47:13.675 --> 18:47:17.675
components folder, which are
basically minimalistic blocks of

18507
18:47:17.675 --> 18:47:21.675
JavaScript and HTML that we can
use to modularize and create our

18508
18:47:21.675 --> 18:47:24.675
website out of these components.
Constants is a folder that we

18509
18:47:24.675 --> 18:47:29.675
can put constant variables, Node
modules is node modules. And out

18510
18:47:29.675 --> 18:47:32.675
folders. What happens when we
export all of our code to a

18511
18:47:32.675 --> 18:47:35.675
static example, pages are going
to be basically the routes or

18512
18:47:35.675 --> 18:47:38.675
the different pages of our
website, everything goes through

18513
18:47:38.675 --> 18:47:43.675
app.js. Public is just some
public stuff styles is for any

18514
18:47:43.675 --> 18:47:47.675
CSS or styling of our
application. And then we have

18515
18:47:47.675 --> 18:47:52.676
our basic files here. In our
pages section, we have our app,

18516
18:47:52.676 --> 18:47:55.676
which is surrounded by both this
notification provider and our

18517
18:47:55.676 --> 18:47:59.676
Morales provider, all of our
components run through this app

18518
18:47:59.676 --> 18:48:03.676
on all of our pages run through
this app. So this is kind of

18519
18:48:03.676 --> 18:48:07.676
considered the entry point for
our entire application. Having

18520
18:48:07.676 --> 18:48:10.676
this Morales provider wrapped
around our notifications in

18521
18:48:10.676 --> 18:48:15.676
component means that we don't
have to pass parameters between

18522
18:48:15.676 --> 18:48:18.676
our components. And our lottery
will just know what chain ID

18523
18:48:18.676 --> 18:48:21.676
that we're on, because our
header is going to pass it up to

18524
18:48:21.676 --> 18:48:23.676
Morales provider and the Morales
provider is going to pass it

18525
18:48:23.676 --> 18:48:27.676
back down to our lottery
entrance. And we saw with our

18526
18:48:27.676 --> 18:48:30.676
manual header, the way that that
connect button works behind the

18527
18:48:30.676 --> 18:48:33.676
scenes. So it's doing some local
storage, where we're storing

18528
18:48:33.676 --> 18:48:35.676
whether or not we're actually
connected, we learned about use

18529
18:48:35.676 --> 18:48:39.676
effect, and you state and these
different hooks in our front

18530
18:48:39.676 --> 18:48:42.676
ends were one of the main
reasons we want hooks is we want

18531
18:48:42.676 --> 18:48:45.676
we want our websites to
rerender. When stuff changes, we

18532
18:48:45.676 --> 18:48:49.676
want our components to be able
to talk about the state of the

18533
18:48:49.676 --> 18:48:52.676
blockchain with each other. And
they're incredibly powerful for

18534
18:48:52.676 --> 18:48:55.676
building our React applications.
Use effect is one of the most

18535
18:48:55.676 --> 18:48:58.676
popular ones where if we don't
have a dependency array, our

18536
18:48:58.676 --> 18:49:02.676
function inside of our use
effect will run anytime

18537
18:49:02.676 --> 18:49:06.676
something re renders a blank
dependency array means it'll

18538
18:49:06.676 --> 18:49:09.676
just run once on load. And if
there are dependencies in the

18539
18:49:09.676 --> 18:49:14.676
array, it'll run any time any of
the variables in those change.

18540
18:49:14.676 --> 18:49:18.676
We also learned about the use
state hook, which is really

18541
18:49:18.676 --> 18:49:21.676
similar to saying like, let
variable equals x. But it also

18542
18:49:21.676 --> 18:49:24.676
comes with the RE rendering
ability. And it comes with some

18543
18:49:24.676 --> 18:49:26.676
other nice abilities that we
didn't really discuss here, we

18544
18:49:26.676 --> 18:49:29.677
learned how to call different
contract functions with

18545
18:49:29.677 --> 18:49:33.677
mirallas. Not only sending
transactions, but also calling

18546
18:49:33.677 --> 18:49:36.677
data. Morales is smart enough to
know that when it sees get

18547
18:49:36.677 --> 18:49:40.677
entrance fee that this is going
to be a view function. And this

18548
18:49:40.677 --> 18:49:42.677
is going to be a transaction, it
can tell the difference between

18549
18:49:42.677 --> 18:49:45.677
the two. So this one's going to
populate Metamask to pop up. And

18550
18:49:45.677 --> 18:49:48.677
this one just going to return
kind of normally like a view

18551
18:49:48.677 --> 18:49:51.677
function, what we can actually
use the same syntax between

18552
18:49:51.677 --> 18:49:54.677
sending transactions and then
calling view functions on our

18553
18:49:54.677 --> 18:49:57.677
contract, we added a button,
calling one of these Morales

18554
18:49:57.677 --> 18:50:01.677
pieces and then had an onsuccess
section where when our

18555
18:50:01.677 --> 18:50:05.677
transaction completed, we update
the UI and we add a little pop

18556
18:50:05.677 --> 18:50:08.677
up for notifications, we learned
how to deploy our code directly

18557
18:50:08.677 --> 18:50:14.677
to IPFS. And use that IPFS hash
to interact and see our code, we

18558
18:50:14.677 --> 18:50:18.677
also learned about fleek and how
fleek automatically deploys to

18559
18:50:18.677 --> 18:50:22.677
IPFS. Whenever we do a git push
to our GitHub repository, and it

18560
18:50:22.677 --> 18:50:26.677
makes continuously updating our
websites much easier. It also

18561
18:50:26.677 --> 18:50:30.677
gives us a regular canonical URL
as well. And then finally, we

18562
18:50:30.677 --> 18:50:33.677
learned about IPFS and
decentralized database storage.

18563
18:50:33.677 --> 18:50:36.677
Now you might be asking, Okay,
well, why don't we just store

18564
18:50:36.677 --> 18:50:39.677
all the data for this website on
Aetherium, or polygon or

18565
18:50:39.677 --> 18:50:41.677
avalanche, etc? And the answer
to that is that can get

18566
18:50:41.677 --> 18:50:45.677
incredibly expensive storing
data, storing a ton of data on

18567
18:50:45.677 --> 18:50:50.677
the blockchain costs a ton of
gas, whereas this is a much

18568
18:50:50.677 --> 18:50:53.677
cheaper alternative. Aetherium
avalanche and the smart contract

18569
18:50:53.677 --> 18:50:57.677
platforms aren't really meant to
be data storage layers, they're

18570
18:50:57.677 --> 18:51:00.677
meant to be logic layers, right?
Decentralized logic,

18571
18:51:00.677 --> 18:51:03.677
decentralized smart contracts,
oftentimes, yes, we're gonna

18572
18:51:03.677 --> 18:51:06.677
have to store data in them. But
when it's a ton of data, there

18573
18:51:06.677 --> 18:51:08.678
are better solutions. And there
are different solutions out

18574
18:51:08.678 --> 18:51:12.678
there for storing our data, like
IPFS and filecoin, you should be

18575
18:51:12.678 --> 18:51:15.678
incredibly proud of yourself, if
you've made it this far, because

18576
18:51:15.678 --> 18:51:18.678
you've just made a really solid
app, a really solid front end

18577
18:51:18.678 --> 18:51:21.678
application. And you've learned
how to really easily add

18578
18:51:21.678 --> 18:51:24.678
functionality for interacting
with your smart contracts. So

18579
18:51:24.678 --> 18:51:27.678
give yourself a pat on the back,
maybe even tweet this out, share

18580
18:51:27.678 --> 18:51:30.678
this really cool application
with your friends and family.

18581
18:51:30.678 --> 18:51:38.678
Take a break. And I'll see you
in the next lesson.

18582
18:51:38.678 --> 18:51:41.678
All right, welcome to one of the
fastest lessons that we're going

18583
18:51:41.678 --> 18:51:43.678
to have here. And in this
lesson, we're going to talk

18584
18:51:43.678 --> 18:51:46.678
about the hardhat starter kit.
Really quickly, I'm going to

18585
18:51:46.678 --> 18:51:49.678
walk you through it and show you
how to use it. Now we've learned

18586
18:51:49.678 --> 18:51:51.678
a lot about projects, we've
learned a lot about different

18587
18:51:51.678 --> 18:51:54.678
repos, learnt the basics of
smart contracts. And we've

18588
18:51:54.678 --> 18:51:57.678
learned a lot about front end as
well and building front ends for

18589
18:51:57.678 --> 18:52:01.678
applications. So this smart
contract kit repo comes packed

18590
18:52:01.678 --> 18:52:06.678
with a ton of starter kits that
you can use to start deploying

18591
18:52:06.678 --> 18:52:09.678
your projects right away. And as
you can see, that hard hat

18592
18:52:09.678 --> 18:52:12.678
starter kit is easily one of the
most popular ones with the most

18593
18:52:12.678 --> 18:52:15.678
stars the most forks out there.
The smart contract kit repo

18594
18:52:15.678 --> 18:52:18.678
actually comes with a ton of
frameworks, like if you want to

18595
18:52:18.678 --> 18:52:21.678
work with SWANA, if you want to
work with Python and Brownie, if

18596
18:52:21.678 --> 18:52:25.678
you want to work with foundry,
truffle, really any other

18597
18:52:25.678 --> 18:52:27.678
framework out there, you can get
started, clone one of these

18598
18:52:27.678 --> 18:52:30.678
repos, work with one of these
repos and build your project and

18599
18:52:30.678 --> 18:52:32.678
get started right away, we're
going to show you how to use the

18600
18:52:32.678 --> 18:52:37.678
hard hat starter kit. So you can
just grab the repo and go and

18601
18:52:37.678 --> 18:52:40.678
already have some boilerplate
code and a boilerplate really

18602
18:52:40.678 --> 18:52:43.678
good looking repo to start your
projects with, we come to the

18603
18:52:43.678 --> 18:52:46.678
smart contract kit, hard hat
starter kit repo here. And if

18604
18:52:46.678 --> 18:52:48.679
you're working with GitHub, you
can just go ahead and use this

18605
18:52:48.679 --> 18:52:51.679
template and it will
automatically generate you a new

18606
18:52:51.679 --> 18:52:54.679
GitHub repo with the hardest
starter kit. So let's go ahead,

18607
18:52:54.679 --> 18:52:57.679
we'll click use this template,
we come up with our own name

18608
18:52:57.679 --> 18:53:02.679
here, we'll call it make it
public create repository from

18609
18:53:02.679 --> 18:53:06.679
Template. it'll generate our
repository. And now we

18610
18:53:06.679 --> 18:53:10.679
automatically have it in our own
repo here. And we can get

18611
18:53:10.679 --> 18:53:12.679
started working with it. And we
can get started working with it.

18612
18:53:12.679 --> 18:53:15.679
If you don't want to click the
use that template button, we can

18613
18:53:15.679 --> 18:53:18.679
also just copy the URL. And in
our code editor, we can just do

18614
18:53:18.679 --> 18:53:21.679
git clone and paste that in
there. So for now, I am going to

18615
18:53:21.679 --> 18:53:24.679
get clone, but I'm going to get
clone with this repo that we

18616
18:53:24.679 --> 18:53:30.679
just created. Come back in with
the git clone, hard hat play FCC

18617
18:53:30.679 --> 18:53:34.679
or hard hat starter kit. We're
going to cd into our head play

18618
18:53:34.679 --> 18:53:38.679
FCC, and then open that up in a
new code editor. And awesome.

18619
18:53:38.679 --> 18:53:41.679
Now you'll see in this repo, it
comes packed with a ton of

18620
18:53:41.679 --> 18:53:45.679
contracts, deployments, scripts,
tasks, test, everything, you

18621
18:53:45.679 --> 18:53:48.679
name it to really get started in
a professional environment. We

18622
18:53:48.679 --> 18:53:52.679
look in the contract section, we
can see we have a couple of

18623
18:53:52.679 --> 18:53:56.679
sample contracts. We have a
contract for making an API call

18624
18:53:56.679 --> 18:54:00.679
to a chain link node, working
with keepers working with price

18625
18:54:00.679 --> 18:54:03.679
feeds, and then working with
chain link Vir Fe two. We've got

18626
18:54:03.679 --> 18:54:06.679
some test contracts and we
additionally have this fuzzing

18627
18:54:06.679 --> 18:54:09.679
folder, which we'll talk talk
about in a much later section of

18628
18:54:09.679 --> 18:54:11.679
this course, we have deployed
scripts where we start with

18629
18:54:11.679 --> 18:54:14.679
deploying mocks, then we deploy
each one of those contracts, we

18630
18:54:14.679 --> 18:54:17.679
have a sample script to read the
price from one of these

18631
18:54:17.679 --> 18:54:21.679
contracts. And we have a whole
bunch of sample tasks. Now at

18632
18:54:21.679 --> 18:54:23.679
the time of recording, instead
of scripts, this repo uses

18633
18:54:23.679 --> 18:54:26.679
tasks. But again, they're a
little bit interchangeable. And

18634
18:54:26.679 --> 18:54:29.680
of course, we have some unit
tests and some staging tests as

18635
18:54:29.680 --> 18:54:32.680
well, that you can go through
and take a look at, once we're

18636
18:54:32.680 --> 18:54:35.680
in this repo, we can run some
familiar commands here, we'll do

18637
18:54:35.680 --> 18:54:39.680
yarn, of course, to install our
all of our packages. And then

18638
18:54:39.680 --> 18:54:42.680
everything that we're going to
do, if you get lost, you can

18639
18:54:42.680 --> 18:54:45.680
always come back to this repo.
And you can follow along with

18640
18:54:45.680 --> 18:54:47.680
getting started and the
Quickstart. So we just did the

18641
18:54:47.680 --> 18:54:51.680
git clone. Now we're doing the
yarn, and then we're gonna go

18642
18:54:51.680 --> 18:54:53.680
ahead and run yarn hard hat
test. This hard hat starter kit

18643
18:54:53.680 --> 18:54:57.680
repo is very consistently up to
date, we did the last push being

18644
18:54:57.680 --> 18:55:00.680
just a few days ago, and will
constantly have some best

18645
18:55:00.680 --> 18:55:03.680
practices for building our smart
contracts and having a really

18646
18:55:03.680 --> 18:55:06.680
professional coding environment.
And it's got this really cute

18647
18:55:06.680 --> 18:55:09.680
logo. Once we've installed all
the dependencies, we can run

18648
18:55:09.680 --> 18:55:14.680
yarn, art hath test, we can run
all of the tests in the test

18649
18:55:14.680 --> 18:55:17.680
folder, which also will show us
how to interact and how to use

18650
18:55:17.680 --> 18:55:20.680
all these different contracts in
here. And they each have some

18651
18:55:20.680 --> 18:55:23.680
console dot log, so you can see
more about what's actually going

18652
18:55:23.680 --> 18:55:28.680
on when these tests actually
run. If we look in the Hardhead

18653
18:55:28.680 --> 18:55:31.680
config.js, it's got some really
familiar code in here, we have

18654
18:55:31.680 --> 18:55:34.680
all our imports at the top, we
grab a whole bunch of

18655
18:55:35.680 --> 18:55:38.680
environment variables, we've got
the ether scan plugin, we've got

18656
18:55:38.680 --> 18:55:42.680
the gas reporter, the contract
sizer, which is a plugin that

18657
18:55:42.680 --> 18:55:45.680
tells you how big your contracts
are. So named accounts,

18658
18:55:45.680 --> 18:55:48.680
different solidity versions, and
then mocha timeout as well. We

18659
18:55:48.680 --> 18:55:53.680
can of course, do yarn hard hat
node, which will run through our

18660
18:55:53.680 --> 18:55:57.680
deploy scripts, and then spin up
a new note for us, which has

18661
18:55:57.680 --> 18:56:01.680
mock chainlink tokens, mock
Oracle's mock aggregators, and

18662
18:56:01.680 --> 18:56:04.680
mock up VRF for us to go ahead
and interact with once that's

18663
18:56:04.680 --> 18:56:09.681
up, we can then of course, to
hard hat, console, dash dash

18664
18:56:09.681 --> 18:56:13.681
network localhost, and begin
interacting with contracts on

18665
18:56:13.681 --> 18:56:16.681
localhost. So we can kind of
follow along with price feed,

18666
18:56:16.681 --> 18:56:22.681
for example, and do const price
consumer B three equals await

18667
18:56:22.681 --> 18:56:29.681
ethers dot get contract, price,
consumer V three.

18668
18:56:29.681 --> 18:56:34.681
And then we can do await price
consumer B three dot get latest

18669
18:56:34.681 --> 18:56:40.681
price. Let's wrap that in a to
string. And we can see a mock

18670
18:56:40.681 --> 18:56:43.681
latest price from a contract
that uses channeling price

18671
18:56:43.681 --> 18:56:46.681
feeds. And we can interact with
any of our contracts and work

18672
18:56:47.681 --> 18:56:50.681
with any of the mocks as well in
here. If we want to deploy this

18673
18:56:50.681 --> 18:56:53.681
to an actual test net like
Rinckey, or main net will just

18674
18:56:53.681 --> 18:56:57.681
pop in our dot env file, we'll
close our node terminal, and we

18675
18:56:57.681 --> 18:57:03.681
can run yarn hardhat or just hh
deploy. And then we'll add

18676
18:57:03.681 --> 18:57:05.681
whatever tags we want to do
here. So let's just deploy our

18677
18:57:05.681 --> 18:57:08.681
price feed contract. If we go to
the price feed deploy, we scroll

18678
18:57:08.681 --> 18:57:13.681
down, we'll get the tags. Okay,
great, we'll use the feed tag,

18679
18:57:13.681 --> 18:57:18.681
dash tags feeds dash to or feed
dash dash network brings beam.

18680
18:57:18.681 --> 18:57:21.681
And while we're waiting for this
to deploy, we can go back to the

18681
18:57:21.681 --> 18:57:24.681
actual repo. And just make sure
to follow along with the

18682
18:57:24.681 --> 18:57:26.681
documentation here and the
Quickstart in all the usage and

18683
18:57:26.681 --> 18:57:29.681
everything so that you make sure
that you're working with the

18684
18:57:29.681 --> 18:57:32.681
most up to date version. There's
even documentation on running a

18685
18:57:32.681 --> 18:57:36.681
local network using a test net
or live network working with

18686
18:57:36.681 --> 18:57:39.681
Aetherium. Rigby adding your
private keys and dotting envies

18687
18:57:39.681 --> 18:57:42.681
all this stuff that you already
know, forking, which we'll learn

18688
18:57:42.681 --> 18:57:45.681
a little bit later, auto funding
your contracts for working with

18689
18:57:45.681 --> 18:57:49.682
chain link API running tests,
you can additionally run your

18690
18:57:49.682 --> 18:57:53.682
tests in parallel by adding the
dash dash parallel flag to our

18691
18:57:53.682 --> 18:57:56.682
tests. We can interact with our
deployed contracts with those

18692
18:57:56.682 --> 18:57:59.682
different tasks that we've
created linting code formatting,

18693
18:57:59.682 --> 18:58:02.682
estimated gas code coverage
fuzzing, we'll talk about later.

18694
18:58:02.682 --> 18:58:06.682
And then contributions. PRs
issues are always welcome here.

18695
18:58:06.682 --> 18:58:09.682
And once it's outputted, and
even verified, if you have

18696
18:58:09.682 --> 18:58:12.682
verification turned on, you'll
get a little task that we can

18697
18:58:12.682 --> 18:58:15.682
run to just go ahead and read
the price feed or interact with

18698
18:58:15.682 --> 18:58:18.682
the contract. So we can copy
that task out. Yarn hardhat.

18699
18:58:18.682 --> 18:58:22.682
Read price feed since it's a
task here, contract the contract

18700
18:58:22.682 --> 18:58:25.682
data which we just deployed
network Rigby. And we'll get

18701
18:58:25.682 --> 18:58:28.682
reading data price feed from
consumer contract on network,

18702
18:58:28.682 --> 18:58:31.682
Rigby price is here, which of
course, we're saying the price

18703
18:58:31.682 --> 18:58:36.682
of Aetherium is $3,033, because
it has eight decimal places. So

18704
18:58:36.682 --> 18:58:39.682
if you're ever looking to start
a new project, and you want some

18705
18:58:39.682 --> 18:58:42.682
boilerplate code, this hard hat
Starter Kit is a great place to

18706
18:58:42.682 --> 18:58:46.682
get started. And of course, you
can open it and get pod if you

18707
18:58:46.682 --> 18:58:49.682
want to just test it out and try
it and get pot in a Cloud Shell.

18708
18:58:49.682 --> 18:58:52.682
So that's it for this lesson.
Wasn't that fast. This was the

18709
18:58:52.682 --> 18:58:55.682
fastest lesson ever. So if you
want to do a little extra

18710
18:58:55.682 --> 18:58:58.682
learnings here, I would fork
this I would clone this I would

18711
18:58:58.682 --> 18:59:00.682
use this template, try to play
around with the repo a little

18712
18:59:00.682 --> 18:59:03.682
bit yourself and see what you
recognize, see what you don't

18713
18:59:03.682 --> 18:59:07.682
recognize and keep that prepped
in your mind for later so

18714
18:59:07.682 --> 18:59:09.682
Questions in the course. And
then for everyone here who is

18715
18:59:09.682 --> 18:59:13.682
TypeScript, there is, of course,
a TypeScript version of this as

18716
18:59:13.682 --> 18:59:17.682
well that you can get cloned.
And it has a nice blue logo here

18717
18:59:17.682 --> 18:59:20.682
to show that it's a little bit
different. So, that being said,

18718
18:59:20.682 --> 18:59:29.683
use the repo, have fun. Let's
get to lesson 12.

18719
18:59:29.683 --> 18:59:33.683
Alright, now we're moving on to
the hard hat ERC. 20s are the

18720
18:59:33.683 --> 18:59:36.683
section where we're going to
learn how to create our own ERC

18721
18:59:36.683 --> 18:59:42.683
20 or EIP 20 Or B E P 20 or AEP
20 any of these tokens on the

18722
18:59:42.683 --> 18:59:45.683
blockchain before we can
understand what an ERC 20 is, or

18723
18:59:45.683 --> 18:59:48.683
even what one of these tokens
are, we first need to understand

18724
18:59:48.683 --> 18:59:53.683
what is an ERC. And then also
what is an EIP in Aetherium, and

18725
18:59:53.683 --> 18:59:56.683
avalanche and finance and
polygon. All these blockchains

18726
18:59:56.683 --> 18:59:59.683
have what's called improvement
proposals. And for Aetherium,

18727
18:59:59.683 --> 19:00:03.683
they're called Aetherium
improvement proposals, or E IPs.

18728
19:00:03.683 --> 19:00:07.683
And what people would do is they
come up with these ideas to

18729
19:00:07.683 --> 19:00:11.683
improve Aetherium or improve
these layer ones like polygon,

18730
19:00:11.683 --> 19:00:15.683
Matic avalanche, etc. And on
some GitHub or some open source

18731
19:00:15.683 --> 19:00:18.683
repository, they'll add these
new EIP is they'll add these new

18732
19:00:18.683 --> 19:00:21.683
improvement ideas to make these
protocols better. Now, these

18733
19:00:21.683 --> 19:00:23.683
improvements can really be
anything, they can be anything

18734
19:00:23.683 --> 19:00:27.683
from a core blockchain update to
some standard, that is going to

18735
19:00:27.683 --> 19:00:31.683
be a best practice for the
entire community to adopt. Once

18736
19:00:31.683 --> 19:00:35.683
an EIP gets enough insight, they
also create an E RC, which

18737
19:00:35.683 --> 19:00:39.683
stands for Aetherium request for
comments. So EIP a theory and

18738
19:00:39.683 --> 19:00:43.683
improvement proposals ERC a
theory and request for comments.

18739
19:00:43.683 --> 19:00:48.683
And again, these can be like BP,
Pep, you know, etc. For all

18740
19:00:48.683 --> 19:00:51.683
these different blockchains.
Both the improvement proposals

18741
19:00:51.683 --> 19:00:54.683
and the Request for Comments,
all have these different tags,

18742
19:00:54.683 --> 19:00:56.683
now they're numbered
chronologically, so something

18743
19:00:56.683 --> 19:01:03.683
like an ERC 20 is going to be
the 20th ERC slash EIP, the ERC

18744
19:01:03.683 --> 19:01:06.683
is and the EFPs share that same
number. And there are websites

18745
19:01:06.683 --> 19:01:10.684
like EIP is that aetherium.org
That keep track of all of these

18746
19:01:10.684 --> 19:01:12.684
new Aetherium improvement
proposals, and you can actually

18747
19:01:12.684 --> 19:01:15.684
see them real time go through
the process of being adopted by

18748
19:01:15.684 --> 19:01:20.684
the community. Now, one of these
e IPs or ERC is, is going to be

18749
19:01:20.684 --> 19:01:24.684
the ERC 20 or the token standard
for smart contracts. This is an

18750
19:01:24.684 --> 19:01:28.684
improvement proposal that talks
about how to actually create

18751
19:01:28.684 --> 19:01:31.684
tokens and create these smart
contract tokens. I made a video

18752
19:01:31.684 --> 19:01:33.684
about this recently. So in the
GitHub repo associated with this

18753
19:01:33.684 --> 19:01:35.684
course, we're going to have a
sub lesson, and we're going to

18754
19:01:35.684 --> 19:01:38.684
watch a quick video that
explains more about these

18755
19:01:38.684 --> 19:01:44.684
different tokens. Now first,
let's define even what are ERC

18756
19:01:44.684 --> 19:01:49.684
20s So ERC 20s are tokens that
are deployed on a chain using

18757
19:01:49.684 --> 19:01:52.684
what's called the ERC 20 token
standard, you can read more

18758
19:01:52.684 --> 19:01:54.684
about it in the year 20 token
standard here link in the

18759
19:01:54.684 --> 19:01:56.684
description as well. But
basically, it's a smart contract

18760
19:01:56.684 --> 19:02:00.684
that actually represents a
token. So it's token or the

18761
19:02:00.684 --> 19:02:03.684
smart contract. It's both it's
really cool tether chainlink

18762
19:02:03.684 --> 19:02:07.684
unique token and dye are all
examples of ERC 20s Technically,

18763
19:02:07.684 --> 19:02:11.684
chain link is in the ERC. 677 as
there are upgrades to the ERC 20

18764
19:02:11.684 --> 19:02:15.684
that some tokens take that are
still backwards compatible with

18765
19:02:15.684 --> 19:02:18.684
ERC. 20s And so basically, you
can think of them as ERC 20s

18766
19:02:18.684 --> 19:02:21.684
with a little additional
functionality. Now why would I

18767
19:02:21.684 --> 19:02:23.684
even care to want to make an ERC
20 Well, you can do a lot of

18768
19:02:23.684 --> 19:02:26.684
really cool stuff with it. You
can make governance token, you

18769
19:02:26.684 --> 19:02:28.684
can secure an underlying
network, you can create some

18770
19:02:28.684 --> 19:02:32.684
type of synthetic acid, or
really anything else. In any

18771
19:02:32.684 --> 19:02:35.684
case, how do we build one of
these ERC? 20s How do we build

18772
19:02:35.684 --> 19:02:38.684
one of these tokens? Well, all
we have to do is build a smart

18773
19:02:38.684 --> 19:02:41.684
contract that follows the token
standard, all we have to do is

18774
19:02:41.684 --> 19:02:45.684
build a smart contract that has
these functions that has a name

18775
19:02:45.684 --> 19:02:48.684
function, symbol function,
decimals function, etc. All

18776
19:02:48.684 --> 19:02:50.685
these functions we need to be
able to transfer it, we need to

18777
19:02:50.685 --> 19:02:53.685
be able to get the balance of it
etc. And again, if you want to

18778
19:02:53.685 --> 19:02:56.685
check out some of the
improvements that are still ERC

18779
19:02:56.685 --> 19:03:01.685
20 compatible, like the ERC 677
or the ERC 777. Definitely go

18780
19:03:01.685 --> 19:03:06.685
check those out and build one of
those instead. All right,

18781
19:03:06.685 --> 19:03:10.685
awesome. Now that we know what
one of these ERC 20s is, we can

18782
19:03:10.685 --> 19:03:14.685
go ahead and create our own per
usual in the GitHub repo

18783
19:03:14.685 --> 19:03:16.685
associated with this course. We
have all the code available

18784
19:03:16.685 --> 19:03:20.685
here. If you want to just get
clone. This is going to be again

18785
19:03:20.685 --> 19:03:22.685
another one of our quicker
lessons here. So we're in our

18786
19:03:22.685 --> 19:03:25.685
terminal. We're in our VS code
here. We're going to make a new

18787
19:03:25.685 --> 19:03:31.685
directory. I'm going to call it
hard hat ERC 20 FCC will cd into

18788
19:03:31.685 --> 19:03:35.685
hard hat, your C 20 sec. And
we're going to create a new hard

18789
19:03:35.685 --> 19:03:38.685
hat project the exact same way
we've been doing it yarn add

18790
19:03:38.685 --> 19:03:43.685
dash dash dev or tab. Let's
actually open it in its own VS

18791
19:03:43.685 --> 19:03:49.685
code will do code.or file open
this folder. And okay, we're in

18792
19:03:49.685 --> 19:03:52.685
our project now. Let's create a
new hard hat project. We'll do

18793
19:03:52.685 --> 19:03:55.685
yarn, art hats.

18794
19:03:55.685 --> 19:03:59.685
We'll do create an empty hard
hat dot config dot j s here and

18795
19:03:59.685 --> 19:04:02.685
great. We've now got an empty
hard hat dot config dot j s. If

18796
19:04:02.685 --> 19:04:05.685
you want to copy paste your hard
hat dot config from a previous

18797
19:04:05.685 --> 19:04:08.685
projects you want to copy paste
your heart Have dot config or

18798
19:04:08.685 --> 19:04:11.685
your dot EMV file, because you
know we're going to need those

18799
19:04:11.685 --> 19:04:15.685
feel free to do so now, I'm just
going to update this to 8.7.

18800
19:04:15.685 --> 19:04:19.685
I'll add the rest of my stuff
later. So as we've heard this

18801
19:04:19.685 --> 19:04:23.685
EIP 20, or this ERC 20. All it
needs is to have these functions

18802
19:04:23.685 --> 19:04:26.685
in its token standard so that we
can transfer tokens, we can do

18803
19:04:26.685 --> 19:04:29.686
all the stuff in the ERC 20
contract itself, it really is

18804
19:04:29.686 --> 19:04:33.686
just keeping track of how much
of each token people have. So

18805
19:04:33.686 --> 19:04:36.686
the smart contract, kind of in a
weird way it keeps track of

18806
19:04:36.686 --> 19:04:38.686
itself. To get started, we're
going to do this kind of the

18807
19:04:38.686 --> 19:04:42.686
manual way. First, we're going
to create our own manual token

18808
19:04:42.686 --> 19:04:45.686
here, or a really minimalistic
one anyways, so let's create a

18809
19:04:45.686 --> 19:04:52.686
new folder. contracts will
create a new file called manual

18810
19:04:52.686 --> 19:04:56.686
token dot soul. Yes, I'm going
to show you kind of the hard way

18811
19:04:56.686 --> 19:04:59.686
to make it and then I'll show
you a much easier way to make

18812
19:04:59.686 --> 19:05:05.686
it. So to get started here are
usual we can do pragma, solidity

18813
19:05:05.686 --> 19:05:11.686
to carrot zero, point 8.7. And
then we'll even do spdx, license

18814
19:05:11.686 --> 19:05:18.686
identifier, MIT do contract,
manual token, and boom, let's

18815
19:05:18.686 --> 19:05:22.686
get started. The main reason
this token smart contract works

18816
19:05:22.686 --> 19:05:28.686
is that there's some balances
mapping. So we have a mapping of

18817
19:05:28.686 --> 19:05:34.686
addresses to you in 256. And
it's usually public called

18818
19:05:34.686 --> 19:05:38.686
balance of and all this does is
this mapping is obviously the

18819
19:05:38.686 --> 19:05:42.686
key is going to be every single
address on the planet, and then

18820
19:05:42.686 --> 19:05:45.686
how much they have. And
basically, when we transfer

18821
19:05:45.686 --> 19:05:50.686
tokens, transfer tokens, we're
basically just subtract from

18822
19:05:50.686 --> 19:05:56.686
address, amount, and add to to
address. So a really

18823
19:05:56.686 --> 19:05:59.686
minimalistic way to implement
this would be to create this

18824
19:05:59.686 --> 19:06:02.686
transfer function first. So
we'll create this function, I'm

18825
19:06:02.686 --> 19:06:05.686
going to call it underscore
transfer, we can do an address

18826
19:06:05.686 --> 19:06:12.687
from address to you into fifth
sixth mount. And now we'd

18827
19:06:12.687 --> 19:06:15.687
probably put some requirements,
we probably omit some events,

18828
19:06:15.687 --> 19:06:17.687
and let's make this public as
well. And really, at the end of

18829
19:06:17.687 --> 19:06:27.687
the day, is we're gonna say
balance of from minus equals

18830
19:06:27.687 --> 19:06:31.687
value, which is the same as
saying bounce of from equals

18831
19:06:31.687 --> 19:06:35.687
bounce from minus value, or
excuse me, amount, and then

18832
19:06:35.687 --> 19:06:40.687
we're gonna say balance of two,
excuse me, plus equals, which is

18833
19:06:40.687 --> 19:06:43.687
the same as saying, you know,
balance of two plus. And

18834
19:06:43.687 --> 19:06:46.687
technically, that's really all
we need, right, we probably want

18835
19:06:46.687 --> 19:06:49.687
to do some asserts ins here,
some requires to make sure all

18836
19:06:49.687 --> 19:06:52.687
of our numbers make sense. But
really, at the end of the day,

18837
19:06:52.687 --> 19:06:56.687
this is all that this function
is doing. Transfer works when

18838
19:06:56.687 --> 19:07:00.687
the caller is sending money
directly into another address.

18839
19:07:00.687 --> 19:07:03.687
But what happens if we want to
allow some smart contract to

18840
19:07:03.687 --> 19:07:06.687
work with our token, or we want
to allow somebody else to work

18841
19:07:06.687 --> 19:07:10.687
with our token, you know, maybe
to deposit it into a protocol,

18842
19:07:10.687 --> 19:07:13.687
or do some more functionality
with it, there will be some

18843
19:07:13.687 --> 19:07:15.687
approved function that will
approve that contract to do

18844
19:07:15.687 --> 19:07:21.687
that. And then we'll have a
function transfer from and this

18845
19:07:21.687 --> 19:07:24.687
function will, you know, it'll
just implement taking funds from

18846
19:07:24.687 --> 19:07:27.687
user and this will be public as
well. And then at the top will

18847
19:07:27.687 --> 19:07:31.687
be some type of allowances
mapping that will tell who's

18848
19:07:31.687 --> 19:07:34.687
allowed which address to take
how much token, which sounds a

18849
19:07:35.687 --> 19:07:36.687
little confusing, but let me
just add the mapping. So it'll

18850
19:07:36.687 --> 19:07:42.687
be a mapping of addresses to a
mapping of addresses to an

18851
19:07:42.687 --> 19:07:47.687
amount to a unit tivity sex and
this will be public allowance,

18852
19:07:47.687 --> 19:07:52.688
we're gonna say address, Patrick
is going to allow address of

18853
19:07:52.688 --> 19:07:56.688
Patrick's brother to use 25
tokens. And that's how this

18854
19:07:56.688 --> 19:08:00.688
allowance works. And in our
transfer from transfer from will

18855
19:08:00.688 --> 19:08:04.688
check this allowance mapping and
save Hmm. Did Patrick give you

18856
19:08:04.688 --> 19:08:08.688
authorization to borrow those
tokens? Oh, yes, you did. Okay,

18857
19:08:08.688 --> 19:08:11.688
we'll let you transfer from. And
I'm just, I'm just going to copy

18858
19:08:11.688 --> 19:08:13.688
paste an implementation of it,
you can check out the GitHub

18859
19:08:13.688 --> 19:08:16.688
repo as well. And it would look
something like this is we check

18860
19:08:16.688 --> 19:08:20.688
the allowed amounts, update the
allowance, and then transfer the

18861
19:08:20.688 --> 19:08:22.688
tokens. So those are some of the
main functions. So we need an

18862
19:08:22.688 --> 19:08:26.688
approved function, obviously, to
update the allowances here. And

18863
19:08:26.688 --> 19:08:33.688
usually, you'll have like a un
256 initial supply. And this

18864
19:08:33.688 --> 19:08:37.688
will be like how many tokens
there are starting with how many

18865
19:08:37.688 --> 19:08:39.688
tokens there are total,
sometimes you'll add a mint

18866
19:08:39.688 --> 19:08:42.688
function to add more functions.
But you can basically start to

18867
19:08:42.688 --> 19:08:45.688
see this contract ramping up.
One thing we could do is we

18868
19:08:45.688 --> 19:08:49.688
could go ahead go through this
spec and just line by line, you

18869
19:08:49.688 --> 19:08:52.688
know, build our token ourself.
And after we do that, it might

18870
19:08:52.688 --> 19:08:56.688
look something like this. So I'm
just copy pasted the code from

18871
19:08:56.688 --> 19:08:59.688
the GitHub repo. If you go to
contracts, manual token, I just

18872
19:08:59.688 --> 19:09:03.688
copy paste this code in here.
This is what a contract a token

18873
19:09:03.688 --> 19:09:06.688
contract might look like. Okay.
So we have all these functions,

18874
19:09:06.688 --> 19:09:09.688
we have all these arrays. We
have all this stuff. And you can

18875
19:09:09.688 --> 19:09:12.688
see in the constructor, we're
taking initial supply, and then

18876
19:09:12.688 --> 19:09:16.688
a token name and a token symbol.
The name, you know, might be

18877
19:09:16.688 --> 19:09:18.688
something like dy token. And
then the symbol might be

18878
19:09:18.688 --> 19:09:22.688
something like dy, just so that
it's easily recognizable just by

18879
19:09:22.688 --> 19:09:25.688
its name and its token.

18880
19:09:25.688 --> 19:09:28.688
coding it all from scratch, like
that is definitely something

18881
19:09:28.688 --> 19:09:31.689
that we can do. But as
engineers, we know that that's

18882
19:09:31.689 --> 19:09:33.689
probably really annoying. And we
don't actually want to do that.

18883
19:09:33.689 --> 19:09:37.689
So what can we do instead? Well,
we can use an open source

18884
19:09:37.689 --> 19:09:42.689
library, like open Zeppelin, to
actually get some boilerplate

18885
19:09:42.689 --> 19:09:45.689
code work with open Zeppelin is
almost considered kind of the

18886
19:09:45.689 --> 19:09:48.689
standard library of solidity.
They have a list of open source

18887
19:09:48.689 --> 19:09:52.689
contracts that anybody can use
and import into their contracts

18888
19:09:52.689 --> 19:09:55.689
that have a ton of boilerplate,
so that you don't have to

18889
19:09:55.689 --> 19:09:58.689
manually write everything out,
we can see all their code in

18890
19:09:58.689 --> 19:10:00.689
their GitHub repository, open
Zeppelin slash open Zeppelin

18891
19:10:00.689 --> 19:10:03.689
contracts, and we're going to be
using them a lot moving forward.

18892
19:10:03.689 --> 19:10:06.689
So for example, you can see kind
of on the left side of their

18893
19:10:06.689 --> 19:10:09.689
documentation, they have this
tokens section, and they have an

18894
19:10:09.689 --> 19:10:13.689
ERC 20, which is one of those
tokens standards. If you scroll

18895
19:10:13.689 --> 19:10:17.689
on here, they even have some
minimalistic examples of how to

18896
19:10:17.689 --> 19:10:20.689
create your own ERC 20 token.
And that's what we're going to

18897
19:10:20.689 --> 19:10:23.689
be using to build our token.
Because you see how much smaller

18898
19:10:23.689 --> 19:10:26.689
this is how much less code this
is to maintain. Let's go ahead

18899
19:10:26.689 --> 19:10:29.689
and let's use open Zeppelin for
us to create our token. So let's

18900
19:10:29.689 --> 19:10:33.689
create a new file. We'll call
our token dot soul. I'm going to

18901
19:10:33.689 --> 19:10:38.689
create our own token here. So
let's do spdx. License

18902
19:10:38.689 --> 19:10:45.689
identifier, MIT, we'll do
pragma, solidity carrot zero,

18903
19:10:45.689 --> 19:10:50.689
point 8.7, we'll do contract our
token. Now, what we're going to

18904
19:10:50.689 --> 19:10:53.689
do, we're going to import
openzeppelin contracts into our

18905
19:10:53.689 --> 19:10:56.689
hard hat project. And we're
going to do it the same way we

18906
19:10:56.689 --> 19:10:58.689
did with chain link and any
other packages in the future. So

18907
19:10:58.689 --> 19:11:04.689
we'll do yarn, add dash dash
Dev, at open Zeppelin slash

18908
19:11:04.689 --> 19:11:07.689
contracts. And this is going to
add the open Zeppelin slash

18909
19:11:07.689 --> 19:11:10.690
contracts NPM package to our
project. And one of the code

18910
19:11:10.690 --> 19:11:14.690
pieces that they have is this
ERC 20 contract that we can use

18911
19:11:14.690 --> 19:11:17.690
and we can have our token
inherit all the functions. So

18912
19:11:17.690 --> 19:11:22.690
we'll go ahead and import it
with import at openzeppelin.

18913
19:11:22.690 --> 19:11:27.690
Slash contracts slash tokens
slash ERC 20 slash ERC 20

18914
19:11:27.690 --> 19:11:31.690
ditzel. And just by importing it
like this, all we have to do is

18915
19:11:31.690 --> 19:11:35.690
have our token inherited now. So
we'll say contract. Our token is

18916
19:11:35.690 --> 19:11:39.690
ERC 20. Boom. And just like that
our token is almost done. Now

18917
19:11:39.690 --> 19:11:42.690
you might get this little wiggle
this little red line here saying

18918
19:11:42.690 --> 19:11:45.690
our token should be marked
abstract. And that's because if

18919
19:11:45.690 --> 19:11:50.690
we look into the ERC 20 dot soul
of openzeppelin We'll see that

18920
19:11:50.690 --> 19:11:53.690
it has a constructor. So in
order for us to inherit your C

18921
19:11:53.690 --> 19:11:58.690
20 token, we have to use the ERC
20 constructor and we just need

18922
19:11:58.690 --> 19:12:01.690
to give our token a name and a
symbol. But we can say in our

18923
19:12:01.690 --> 19:12:05.690
constructor, we can leave it
blank. And then right next to

18924
19:12:05.690 --> 19:12:09.690
our constructor, we'll add the
ERC 20 constructor and our name

18925
19:12:09.690 --> 19:12:13.690
will be our token. And then our
symbol will just be OT and then

18926
19:12:14.690 --> 19:12:18.690
this ERC. 20 token also comes
with something called a mint

18927
19:12:18.690 --> 19:12:21.690
functionality, which is
essentially a function that

18928
19:12:21.690 --> 19:12:24.690
allows us to create tokens,
right because right now we

18929
19:12:24.690 --> 19:12:27.690
actually get initialized with
zero tokens, right. So nobody's

18930
19:12:27.690 --> 19:12:31.690
actually allowed to have any
tokens. So we want to mint the

18931
19:12:31.690 --> 19:12:35.690
initial amount of tokens and
then who owns all those tokens

18932
19:12:35.690 --> 19:12:37.690
to start with. So usually what
you'll see is you'll see a mint

18933
19:12:37.690 --> 19:12:41.690
function like this, it'll be
passed in message that sender,

18934
19:12:41.690 --> 19:12:44.690
so whoever deploys this contract
will own all the tokens to

18935
19:12:44.690 --> 19:12:49.690
start. And then we'll give it
like an in their soul supply.

18936
19:12:49.690 --> 19:12:52.691
And then we could do like, you
went to 56 initial supply equals

18937
19:12:52.691 --> 19:12:56.691
like seven, or whatever. But
instead, a common practice is

18938
19:12:56.691 --> 19:12:59.691
just to add it to the
constructor. So you and 256

18939
19:12:59.691 --> 19:13:02.691
initial supply like that, as we
know about solidity decimals

18940
19:13:02.691 --> 19:13:09.691
don't work so great. So if I say
my initial supply is 50, that 50

18941
19:13:09.691 --> 19:13:13.691
is going to be like 50 way, and
there's all these ERC 20s come

18942
19:13:13.691 --> 19:13:16.691
with a decimals and decimals
function, which tells us how

18943
19:13:16.691 --> 19:13:21.691
many decimals we should expect
with our ERC 20. The default is

18944
19:13:21.691 --> 19:13:24.691
18. And we can override this
function if we want a different

18945
19:13:24.691 --> 19:13:28.691
amount of decimals. And if we
know the default is 18. And we

18946
19:13:28.691 --> 19:13:32.691
want to deploy 50, we might want
to do our initial supply of 50 e

18947
19:13:32.691 --> 19:13:38.691
18. Or you can also say like 50
times 10, raise the 18th or

18948
19:13:38.691 --> 19:13:41.691
whatever you want there. And in
our code when we deploy this

18949
19:13:41.691 --> 19:13:43.691
now, this is actually where
we're going to finish the

18950
19:13:43.691 --> 19:13:46.691
project. Because everything else
that we would do here, we've

18951
19:13:46.691 --> 19:13:50.691
already done, all we need to do
is make a deploy script and

18952
19:13:50.691 --> 19:13:52.691
write some tests. That's really
it. Because right now you have

18953
19:13:52.691 --> 19:13:55.691
all the skills that you need to
write a deploy script and then

18954
19:13:55.691 --> 19:13:59.691
optionally write some tests for
this project. So I highly

18955
19:13:59.691 --> 19:14:01.691
encourage you to pause the video
here and try to write your own

18956
19:14:01.691 --> 19:14:05.691
deploy script. And even if you
want to write your own tests,

18957
19:14:05.691 --> 19:14:09.691
you can always refer back To the
GitHub repo associated with this

18958
19:14:09.691 --> 19:14:13.691
lesson, as we do have a deploy
script in here, we also have a

18959
19:14:13.691 --> 19:14:16.691
TypeScript edition in here as
well that we're additionally not

18960
19:14:16.691 --> 19:14:19.691
going to go over. And of course,
if you get totally lost, there's

18961
19:14:19.691 --> 19:14:22.691
a ton of instructions in here to
help you learn more and help you

18962
19:14:22.691 --> 19:14:27.691
work with this specific
repository.

18963
19:14:27.691 --> 19:14:31.692
So let's do a quick review of
what we just learned. So ERC 20

18964
19:14:31.692 --> 19:14:37.692
tokens, or EIP 20 tokens or or b
p or p p, or any of these dash

18965
19:14:37.692 --> 19:14:41.692
20. Improvement proposals are
what's known as the token

18966
19:14:41.692 --> 19:14:45.692
standard. And the token
standard, these tokens on chain

18967
19:14:45.692 --> 19:14:48.692
actually just tokens that are
smart contracts. Now, these

18968
19:14:48.692 --> 19:14:51.692
tokens are obviously different
than the layer one tokens like

18969
19:14:51.692 --> 19:14:55.692
Aetherium, or polygon or
Avalanche or arbitration, those

18970
19:14:55.692 --> 19:14:57.692
are not going to be smart
contracts, those are going to be

18971
19:14:57.692 --> 19:15:00.692
blockchain native tokens, and
you'll hear me refer to it as

18972
19:15:00.692 --> 19:15:04.692
blockchain native tokens a lot.
versus these tokens, these ERC

18973
19:15:04.692 --> 19:15:08.692
20, these smart contract tokens,
which are just smart contracts.

18974
19:15:08.692 --> 19:15:10.692
And they're just kind of a
combination of these functions

18975
19:15:10.692 --> 19:15:14.692
that represent how many tokens
each address has, we can create

18976
19:15:14.692 --> 19:15:19.692
our own token with all the
specifications added. Or we can

18977
19:15:19.692 --> 19:15:22.692
just use openzeppelin to import
a token in now another popular

18978
19:15:22.692 --> 19:15:25.692
repo like open Zeppelin is going
to be this one from Rory capital

18979
19:15:25.692 --> 19:15:29.692
called soulmate. And they're
both aimed to be standard

18980
19:15:29.692 --> 19:15:32.692
libraries for solidity. And one
of the important things to keep

18981
19:15:32.692 --> 19:15:35.692
in mind is that these tokens
have this allowance mapping. And

18982
19:15:35.692 --> 19:15:39.692
you can allow other addresses to
have access to your tokens and

18983
19:15:39.692 --> 19:15:42.692
move your tokens around. This is
important, especially when we

18984
19:15:42.692 --> 19:15:45.692
get to later on when working
with defy when we want to give

18985
19:15:45.692 --> 19:15:48.692
some smart contract access to
our tokens so that they can

18986
19:15:48.692 --> 19:15:51.692
input it into their defy
protocol. It's also a little bit

18987
19:15:51.692 --> 19:15:54.692
tricky. And you want to make
sure you're not allowing

18988
19:15:54.692 --> 19:15:58.692
malicious contracts to interact
with your tokens. And we'll also

18989
19:15:58.692 --> 19:16:01.692
see that when we start to
interact with these tokens more

18990
19:16:01.692 --> 19:16:04.692
before any contract can interact
with our tokens, we need to

18991
19:16:04.692 --> 19:16:07.692
approve them to interact with
our tokens. And that's it. Now

18992
19:16:07.692 --> 19:16:10.693
you're a token wizard, and you
can deploy your own tokens. Take

18993
19:16:10.693 --> 19:16:18.693
a break, get that coffee, and
I'll see you in the next one.

18994
19:16:18.693 --> 19:16:22.693
All right, welcome to the next
session, we are going to be

18995
19:16:22.693 --> 19:16:24.693
learning about defy in this
session and going to be

18996
19:16:24.693 --> 19:16:28.693
programmatic, and going to be
programmatically interacting

18997
19:16:28.693 --> 19:16:31.693
with the defy protocol. I am
incredibly excited for you for

18998
19:16:31.693 --> 19:16:35.693
this session, because defi is
one of the best use cases for

18999
19:16:35.693 --> 19:16:39.693
smart contracts. And one of the
use cases that I am specifically

19000
19:16:39.693 --> 19:16:43.693
most excited for now, as I've
mentioned, the past defy stands

19001
19:16:43.693 --> 19:16:46.693
for decentralized finance, we've
left some links in the GitHub

19002
19:16:46.693 --> 19:16:50.693
repository for you to learn more
about Defy. One of the main

19003
19:16:50.693 --> 19:16:53.693
reasons we're so excited about
defy is because we move away

19004
19:16:53.693 --> 19:16:55.693
from this area of traditional
agreement. And that's what smart

19005
19:16:56.693 --> 19:16:59.693
contracts are all about. They're
about removing this centralized

19006
19:16:59.693 --> 19:17:03.693
entity, from our financial
world, and especially from these

19007
19:17:03.693 --> 19:17:06.693
financial institutions that have
a conflict of interest. They're

19008
19:17:06.693 --> 19:17:08.693
in business to make money not to
keep our money safe not to make

19009
19:17:08.693 --> 19:17:12.693
us money. And we want to work
with a system where everything

19010
19:17:12.693 --> 19:17:15.693
is transparent, especially when
it comes to our financial

19011
19:17:15.693 --> 19:17:19.693
services. So we want to move to
this world of smart contracts,

19012
19:17:19.693 --> 19:17:22.693
especially when it comes to our
money. And in my mind, defi is

19013
19:17:22.693 --> 19:17:26.693
going to be the industry that
affects the masses, the quickest

19014
19:17:26.693 --> 19:17:29.693
because of how much fair how
much better decentralized

19015
19:17:29.693 --> 19:17:33.693
finance is than centralized
finance. And at the moment, the

19016
19:17:33.693 --> 19:17:36.693
rates and the yields and the
interest that you gain in defy

19017
19:17:36.693 --> 19:17:39.693
is much better than centralized
finance, because remember, will

19018
19:17:39.693 --> 19:17:41.693
go away from these centralized
protocols, saying, hey, trust

19019
19:17:41.693 --> 19:17:45.693
us, we'll give you access to the
markets or hate trust us put

19020
19:17:45.693 --> 19:17:49.693
your money in us will keep your
money safe to this cryptographic

19021
19:17:49.693 --> 19:17:52.694
math base guarantees instead of
having to trust these companies

19022
19:17:52.694 --> 19:17:55.694
and these entities, which is
what we want. And additionally,

19023
19:17:55.694 --> 19:17:58.694
the more our Oracle networks get
better, and the more Oracle's

19024
19:17:58.694 --> 19:18:00.694
networks work with these smart
contract platforms like

19025
19:18:00.694 --> 19:18:03.694
Aetherium, like polygon, like
arbitrage them, the more data

19026
19:18:03.694 --> 19:18:06.694
and the more complex financial
products that we can do. Now,

19027
19:18:06.694 --> 19:18:10.694
one of the other reasons I'm so
crazy excited about defy is if

19028
19:18:10.694 --> 19:18:13.694
you look at this little chart
right here, it shows the

19029
19:18:13.694 --> 19:18:16.694
different markets by size. Now
this this image is a little bit

19030
19:18:16.694 --> 19:18:19.694
outdated, but it still shows you
the relative sizes of all these

19031
19:18:19.694 --> 19:18:24.694
different industries defy right
now is a $200 billion market,

19032
19:18:24.694 --> 19:18:27.694
there's about $200 billion
locked in the defy industry. And

19033
19:18:27.694 --> 19:18:30.694
I'll show you that in a minute.
Cryptocurrency actually, at the

19034
19:18:30.694 --> 19:18:35.694
time of recording isn't 360
billion. It's actually like 1.8

19035
19:18:35.694 --> 19:18:38.694
trillion. So it's a lot more
than this. But still, it's a

19036
19:18:38.694 --> 19:18:42.694
massive subset of all these
other areas like gold is a $10

19037
19:18:42.694 --> 19:18:46.694
trillion market. The stock
market is almost $100 trillion

19038
19:18:46.694 --> 19:18:50.694
global real estate, almost $300
trillion derivatives as

19039
19:18:50.694 --> 19:18:55.694
quadrillion dollars. So the FBI
is a super tiny, tiny, tiny,

19040
19:18:55.694 --> 19:18:59.694
tiny subset right now and in my
mind, all of these areas can be

19041
19:18:59.694 --> 19:19:03.694
re landscaped with Defy. So
we're ramping up, we're getting

19042
19:19:03.694 --> 19:19:06.694
there. So it's gonna be up to us
to make some of these protocols

19043
19:19:06.694 --> 19:19:09.694
and make it Much easier for
people to get into the space

19044
19:19:09.694 --> 19:19:12.694
where their finances are going
to be more fair, more

19045
19:19:12.694 --> 19:19:15.694
accountable and more
transparent. And with better

19046
19:19:15.694 --> 19:19:19.694
yield rates, we can actually see
a pretty good summary of what's

19047
19:19:19.694 --> 19:19:23.694
going on in defy this site
called defy llama. It shows

19048
19:19:23.694 --> 19:19:27.694
total value locked in all these
different decentralized

19049
19:19:27.694 --> 19:19:31.695
protocols. And we can see a lot
of these are across multiple

19050
19:19:31.695 --> 19:19:34.695
chains, right. And a lot of
these are EVM compatible chains,

19051
19:19:34.695 --> 19:19:39.695
Aetherium, Biden, smart chain,
avalanche, Fanta, drawn polygon,

19052
19:19:39.695 --> 19:19:43.695
all these are EVM, compatible
blockchains, where we can see

19053
19:19:43.695 --> 19:19:46.695
exactly how much money
independent users have put into

19054
19:19:46.695 --> 19:19:50.695
these protocols. The time of
recording Ave is the number one

19055
19:19:50.695 --> 19:19:54.695
protocol for total value locked.
So there's $22 billion locked in

19056
19:19:54.695 --> 19:19:57.695
Ave, which is the protocol that
we're going to be going over

19057
19:19:57.695 --> 19:20:00.695
today.

19058
19:20:00.695 --> 19:20:04.695
So what is Ave So are they is a
borrowing and lending protocol,

19059
19:20:04.695 --> 19:20:07.695
it allows us to borrow and lend
cryptocurrencies. So we can

19060
19:20:07.695 --> 19:20:10.695
actually put down a token as
collateral, it's kind of similar

19061
19:20:10.695 --> 19:20:14.695
to like putting money in a bank,
and earn yields on other people

19062
19:20:14.695 --> 19:20:17.695
borrowing that collateral from
us almost exactly what a bank

19063
19:20:17.695 --> 19:20:21.695
does, except for the fact it's
what's called noncustodial. To

19064
19:20:21.695 --> 19:20:24.695
the Ave team never touches our
money. Nobody ever touches the

19065
19:20:24.695 --> 19:20:27.695
money. It's all just a smart
contract. It's all just this

19066
19:20:27.695 --> 19:20:30.695
programmatic code. So we can be
rest assured, no one's going to

19067
19:20:30.695 --> 19:20:33.695
run off with our money, no one's
going to do anything bad. And we

19068
19:20:33.695 --> 19:20:35.695
also gain these higher yields.
borrowing and lending is a

19069
19:20:35.695 --> 19:20:39.695
critical piece for creating
really any interesting financial

19070
19:20:39.695 --> 19:20:42.695
applications. If you want to
short sell something, if you

19071
19:20:42.695 --> 19:20:44.695
want to leverage up on some
asset if you want to. If you

19072
19:20:44.695 --> 19:20:48.695
want to do more complex
financial products, you need

19073
19:20:48.695 --> 19:20:51.695
borrowing and lending. Now a lot
of the typical FinTech or

19074
19:20:51.695 --> 19:20:55.695
financial technology or finance
terms do apply here. And this

19075
19:20:55.695 --> 19:20:58.695
course isn't going to be a deep
dive into exactly how these

19076
19:20:58.695 --> 19:21:00.695
financial products work. And
it's also not going to be a

19077
19:21:00.695 --> 19:21:03.695
course on finance. If you want
to learn more about finance,

19078
19:21:03.695 --> 19:21:06.695
we'll leave a number of links in
our GitHub repo associated with

19079
19:21:06.695 --> 19:21:09.695
this course. So you can learn
more about finance and become

19080
19:21:09.695 --> 19:21:12.696
what I like to call a defy
quant, quantitative defy

19081
19:21:12.696 --> 19:21:15.696
engineer. And I am so excited
for more defi quants to get into

19082
19:21:15.696 --> 19:21:19.696
this space. Alright, so here we
are in the Ave application. It's

19083
19:21:19.696 --> 19:21:22.696
at testament dot Ave dot
markets, we are in the testament

19084
19:21:22.696 --> 19:21:24.696
of Avi now, everything that
we're going to do here is going

19085
19:21:24.696 --> 19:21:27.696
to work on Main net as well, but
we're going to use it on their

19086
19:21:27.696 --> 19:21:30.696
test net. Now this is actually
obvious older UI, and they have

19087
19:21:30.696 --> 19:21:33.696
a new website that looks even
better than this. But we're

19088
19:21:33.696 --> 19:21:35.696
going to be going through a lot
of the basic functionality

19089
19:21:35.696 --> 19:21:38.696
depositing taking out a loan,
potentially even shorting an

19090
19:21:38.696 --> 19:21:41.696
asset, if we want, I don't
recommend going to the site

19091
19:21:41.696 --> 19:21:43.696
because it might not work and
COVID the way you'd expect it

19092
19:21:43.696 --> 19:21:46.696
to. So for this, just sit back,
relax and watch. In order for us

19093
19:21:46.696 --> 19:21:49.696
to actually short sell or margin
trade. The first thing that

19094
19:21:49.696 --> 19:21:51.696
we're going to need to do is
actually deposit some

19095
19:21:51.696 --> 19:21:54.696
collateral, we need to deposit
some collateral in order to

19096
19:21:54.696 --> 19:21:57.696
borrow this way. If we never
repay back the loan that we took

19097
19:21:57.696 --> 19:21:59.696
out or the the amount that we
borrowed, Ave, we'll just go

19098
19:21:59.696 --> 19:22:02.696
ahead and take the collateral
that we put in here, we'll do

19099
19:22:02.696 --> 19:22:04.696
what's called a liquidation
call. And that's why this is

19100
19:22:04.696 --> 19:22:06.696
actually a little bit safer than
short selling in traditional

19101
19:22:06.696 --> 19:22:10.696
markets. Because if your
collateral is less than how much

19102
19:22:10.696 --> 19:22:12.696
you have borrowed, you'll just
immediately get liquidated, but

19103
19:22:12.696 --> 19:22:15.696
you still lose a bunch of money
so like don't get liquidated. So

19104
19:22:15.696 --> 19:22:17.696
what we want to do now is we're
gonna scroll to Aetherium, we're

19105
19:22:17.696 --> 19:22:21.696
going to connect our wallet
here, we're going to move to

19106
19:22:21.696 --> 19:22:26.696
COVID test network browser here.
And we're gonna go to this

19107
19:22:26.696 --> 19:22:29.696
deposit piece. So it already
shows our balance here we have

19108
19:22:29.696 --> 19:22:34.696
point two COVID eath. Let's
deposit 0.1.

19109
19:22:34.696 --> 19:22:39.696
We're gonna hit deposit Metamask
can pop up, confirm. But once

19110
19:22:39.696 --> 19:22:41.696
this goes through, this means
that we've have it deposited and

19111
19:22:41.696 --> 19:22:45.696
we go to our dashboard, we can
see we have some eath here,

19112
19:22:45.696 --> 19:22:49.696
point one eath got some API,
this is kind of like that

19113
19:22:49.696 --> 19:22:51.697
percentage return that we're
gonna get back for, for

19114
19:22:51.697 --> 19:22:55.697
depositing into Ave. And yes, we
can use it as collateral here,

19115
19:22:55.697 --> 19:22:59.697
we have this, this marked as yes
here. So that's exactly what

19116
19:22:59.697 --> 19:23:02.697
we're going to do. And it says
nothing borrowed. Yep, we can go

19117
19:23:02.697 --> 19:23:04.697
ahead and hit this borrow now
button. And we're gonna get

19118
19:23:04.697 --> 19:23:07.697
brought to the borrower screen,
and we're going to choose which

19119
19:23:07.697 --> 19:23:11.697
asset we want to borrow. Now,
whenever we borrow one of these,

19120
19:23:11.697 --> 19:23:15.697
there are these API's, right?
This is the percentage that over

19121
19:23:15.697 --> 19:23:17.697
the course of a year that we're
gonna have to pay, in order to

19122
19:23:17.697 --> 19:23:20.697
actually borrow this asset. The
stable one means it'll always be

19123
19:23:20.697 --> 19:23:23.697
for or variable means it
actually changes depending on

19124
19:23:23.697 --> 19:23:27.697
kind of how much liquidity the
protocol has, you can kind of

19125
19:23:27.697 --> 19:23:30.697
pick which one you want to do
stable is you're always gonna be

19126
19:23:30.697 --> 19:23:33.697
a 4% variable is going to be a
little bit riskier, but you

19127
19:23:33.697 --> 19:23:36.697
might get a lower fee. So we're
actually going to borrow some

19128
19:23:36.697 --> 19:23:40.697
dye right, because dye is a
stable coin. It's worth $1. In a

19129
19:23:40.697 --> 19:23:43.697
way, you could call this taking
out on margin because we're

19130
19:23:43.697 --> 19:23:46.697
taking out dye to borrow and
another way we could say we're

19131
19:23:46.697 --> 19:23:49.697
shorting dye which is kind of
funny to think about, but you

19132
19:23:49.697 --> 19:23:52.697
get to choose how much you want
to borrow here and you'll see

19133
19:23:52.697 --> 19:23:54.697
this this thing called Health
factor I'm going to zoom in a

19134
19:23:54.697 --> 19:23:56.697
little bit this thing called
Health factor here as we as we

19135
19:23:56.697 --> 19:24:00.697
scroll this thing. So this
health factor is how close to

19136
19:24:00.697 --> 19:24:03.697
being liquidated you are
remember how I said you can get

19137
19:24:03.697 --> 19:24:06.697
liquidated this health factor
represents how close we are to

19138
19:24:06.697 --> 19:24:08.697
getting liquidated. This means
means how close we are to always

19139
19:24:08.697 --> 19:24:12.697
saying, You know what fu we're
taking your funds. If it goes

19140
19:24:12.697 --> 19:24:15.697
below one at any time, somebody
can liquidate you and take a lot

19141
19:24:15.697 --> 19:24:18.697
of that deposit that we put in,
there's some math behind

19142
19:24:18.697 --> 19:24:21.697
actually what the health factor
actually is, you can head over

19143
19:24:21.697 --> 19:24:24.697
to the Ave documentation, which
I will leave a link in the

19144
19:24:24.697 --> 19:24:27.697
description to kind of read more
about the health factor. So

19145
19:24:27.697 --> 19:24:30.698
we're going to borrow 29 die
we're buying, we're borrowing

19146
19:24:30.698 --> 19:24:33.698
basically 30 bucks. Gonna hit
continue, I'm gonna do a

19147
19:24:33.698 --> 19:24:37.698
variable, zoom back out,
continue, we're gonna borrow

19148
19:24:37.698 --> 19:24:41.698
metamath pops up, confirm
transaction that's pending. And

19149
19:24:41.698 --> 19:24:43.698
we're gonna go to the dashboard.
And now we can see kind of our

19150
19:24:44.698 --> 19:24:48.698
new balance here, right, we can
see the point one eath,

19151
19:24:48.698 --> 19:24:52.698
deposited and 29 die. And we can
see our health factor up here,

19152
19:24:53.698 --> 19:24:55.698
you can even click this little
button, saying, hey, it

19153
19:24:55.698 --> 19:24:59.698
represents how close you are to
being liquidated, we can see the

19154
19:24:59.698 --> 19:25:03.698
value here, our eath is worth
like $200, or die is worth 30

19155
19:25:03.698 --> 19:25:05.698
bucks. So we're good. We're
pretty healthy here. In order

19156
19:25:05.698 --> 19:25:09.698
for Avi to understand and under
to price the underlying

19157
19:25:09.698 --> 19:25:12.698
collateral, so it knows how much
it can lend out. Obviously

19158
19:25:12.698 --> 19:25:15.698
another one of these protocols
that uses changing price feeds

19159
19:25:15.698 --> 19:25:17.698
to price, the underlying
collateral, many of these

19160
19:25:17.698 --> 19:25:21.698
billion dollar defy protocols
use chain link on the back end

19161
19:25:21.698 --> 19:25:24.698
to do all their pricing
mechanisms. And that's

19162
19:25:24.698 --> 19:25:27.698
essentially it, we could then
repay our debts, we could borrow

19163
19:25:27.698 --> 19:25:30.698
more assets, we could swap
assets around. And the interest

19164
19:25:30.698 --> 19:25:35.698
return, we get onto pausing our
assets is amazing. So now that

19165
19:25:35.698 --> 19:25:38.698
we learned a little bit about
how to use their UI, which is

19166
19:25:38.698 --> 19:25:41.698
hosted on IPFS, by the way,
let's go ahead and let's learn

19167
19:25:41.698 --> 19:25:45.698
how to do all this and do even
more programmatically so we can

19168
19:25:45.698 --> 19:25:50.698
become defy quanta engineers.

19169
19:25:50.698 --> 19:25:53.698
Now, like I said, we're going to
be working with the Ave v two

19170
19:25:53.698 --> 19:25:56.698
protocol, if you want to try out
the v3, you absolutely can, if

19171
19:25:56.698 --> 19:25:59.698
you can go there and play with
it right now, it still has more

19172
19:25:59.698 --> 19:26:01.698
money locked in it, which is
great. But the v3 protocol is

19173
19:26:01.698 --> 19:26:04.698
obviously the latest addition.
So we're gonna be flipping back

19174
19:26:04.698 --> 19:26:06.698
and forth between the
documentation and our code base.

19175
19:26:06.698 --> 19:26:09.698
So I recommend that you have the
documentation up as well. And

19176
19:26:09.698 --> 19:26:11.699
per usual, all of the code that
we're going to be working with

19177
19:26:11.699 --> 19:26:15.699
is in this hard hat defi Free
Code Camp repository. So let's

19178
19:26:15.699 --> 19:26:19.699
jump in. I'm in by VS code, I'm
in my folder with this course,

19179
19:26:19.699 --> 19:26:21.699
we're going to make a new
folder, we're going to call it

19180
19:26:21.699 --> 19:26:26.699
hard hat, defy FCC, we're going
to cd into it. And then we're

19181
19:26:26.699 --> 19:26:30.699
going to open it up with code
period. Or you can also do per

19182
19:26:30.699 --> 19:26:34.699
usual, File Open and then open
that folder. Now we're in a new

19183
19:26:34.699 --> 19:26:38.699
project, we're going to do yarn,
add dash dash Dev, aren't hat.

19184
19:26:38.699 --> 19:26:41.699
And we're going to add hard hat
and start up our minimalistic

19185
19:26:41.699 --> 19:26:43.699
hard hat project. Once again,
for starting up your

19186
19:26:43.699 --> 19:26:45.699
minimalistic hard hat projects,
I usually just copy paste from

19187
19:26:45.699 --> 19:26:48.699
another folder, or I just used
that hard hat starter kit that

19188
19:26:48.699 --> 19:26:51.699
we saw in the smart contract
code repo. But whatever works

19189
19:26:51.699 --> 19:26:54.699
best for you to get your project
started, you can use now that

19190
19:26:54.699 --> 19:26:58.699
we've got this, we can run yarn
hardhat. And we'll just create

19191
19:26:58.699 --> 19:27:01.699
an empty hardhat.config.js. Now
to save us some boilerplate

19192
19:27:01.699 --> 19:27:05.699
time, I am going to copy paste
my hard hat.config.js from a

19193
19:27:05.699 --> 19:27:07.699
past project into this one, just
to make it so we don't have to

19194
19:27:07.699 --> 19:27:10.699
go through that boilerplate
setup again. And I'm also going

19195
19:27:10.699 --> 19:27:13.699
to copy paste this line from our
heart at smart contract lottery.

19196
19:27:13.699 --> 19:27:15.699
Again, if you want to use your
package JSON or your yarn dot

19197
19:27:15.699 --> 19:27:18.699
lock to install dependencies,
you absolutely can. But I'm just

19198
19:27:18.699 --> 19:27:22.699
going to paste that in here and
run it. And then I'm going to

19199
19:27:22.699 --> 19:27:26.699
copy paste over my prettier
files, so that all my JavaScript

19200
19:27:26.699 --> 19:27:28.699
can be formatted the way I want
it to be. Okay, great. Now we

19201
19:27:28.699 --> 19:27:31.699
have a minimalistic project spun
up, let's go ahead and get

19202
19:27:31.699 --> 19:27:33.699
started learning how to interact
with the AVI protocol here. So

19203
19:27:33.699 --> 19:27:36.699
let's make a quick readme and
talk about what we want to be

19204
19:27:36.699 --> 19:27:38.699
able to do. So first, we're
going to want to be able to

19205
19:27:38.699 --> 19:27:42.699
learn how to programmatically
deposit collateral. And if we

19206
19:27:42.699 --> 19:27:44.699
stopped right there, that might
be enough, we'd be able to

19207
19:27:44.699 --> 19:27:47.699
programmatically deposit
collateral, and in doing so we

19208
19:27:47.699 --> 19:27:51.700
earn yield, we'd earn that
percentage return just on our

19209
19:27:51.700 --> 19:27:54.700
deposited collateral. So
accomplishing this by itself is

19210
19:27:54.700 --> 19:27:57.700
already a feat. But let's say we
want to go one step further, we

19211
19:27:57.700 --> 19:28:00.700
want to get into these more
interesting financial products.

19212
19:28:00.700 --> 19:28:03.700
So after we deposit some
collateral, we're going to learn

19213
19:28:03.700 --> 19:28:07.700
how to programmatically borrow
and other asset, the deposited

19214
19:28:07.700 --> 19:28:10.700
collateral is going to be eath,
slash wrapped eath, which we'll

19215
19:28:10.700 --> 19:28:12.700
talk about in a little bit,
we're going to borrow another

19216
19:28:12.700 --> 19:28:16.700
asset, which for this demo is
going to be dye. And the reason

19217
19:28:16.700 --> 19:28:19.700
that we're using dye is because
dye is what's known as a stable

19218
19:28:19.700 --> 19:28:22.700
coin. So dye is actually a token
on the blockchain created by

19219
19:28:23.700 --> 19:28:26.700
this maker Dow where the price
of the dye token is always

19220
19:28:26.700 --> 19:28:30.700
pegged to $1. So we're putting
down eath as collateral and

19221
19:28:30.700 --> 19:28:33.700
we're borrowing cryptocurrency,
US dollars, sort of, we're

19222
19:28:33.700 --> 19:28:36.700
borrowing this token, which
represents a US dollar and then

19223
19:28:36.700 --> 19:28:40.700
we'll just repay that I will
repay almost everything back and

19224
19:28:40.700 --> 19:28:43.700
you'll see why we don't repay
everything back in a minute. One

19225
19:28:43.700 --> 19:28:45.700
other protocol that I want to
talk about quickly is the

19226
19:28:45.700 --> 19:28:48.700
uniswap protocol. And the
uniswap protocol has become this

19227
19:28:48.700 --> 19:28:52.700
haven for trading. It's a
decentralized application that

19228
19:28:52.700 --> 19:28:56.700
allows us to trade assets and
tokens with each other on

19229
19:28:56.700 --> 19:29:00.700
something called an automated
market maker. It ends basically

19230
19:29:00.700 --> 19:29:02.700
a decentralized Stock Exchange,
but with tokens and again,

19231
19:29:02.700 --> 19:29:05.700
tokens aren't exactly stocks,
they're very different. So when

19232
19:29:05.700 --> 19:29:08.700
looking to get some of these
assets It's like wrapped

19233
19:29:08.700 --> 19:29:12.700
Aetherium or dye or link token.
On a main net, oftentimes,

19234
19:29:12.700 --> 19:29:15.700
you're going to use one of these
decentralized exchanges. And

19235
19:29:15.700 --> 19:29:18.700
obviously, these decentralized
exchanges are much fairer,

19236
19:29:18.700 --> 19:29:21.700
because everything that happens
on them is transparent, much

19237
19:29:21.700 --> 19:29:24.700
fairer than centralized finance,
everything that happens on them

19238
19:29:24.700 --> 19:29:27.700
is transparent. You can see
everything that's going on on

19239
19:29:27.700 --> 19:29:31.701
chain, which is absolutely
phenomenal. So let's go ahead

19240
19:29:31.701 --> 19:29:34.701
and get started here. And let's
just create our scripts folder.

19241
19:29:34.701 --> 19:29:36.701
Because in this project, we're
actually not going to create any

19242
19:29:36.701 --> 19:29:39.701
contracts ourselves, we're just
going to learn how to interact

19243
19:29:39.701 --> 19:29:41.701
with these protocols. If you do
want to learn how to build some

19244
19:29:41.701 --> 19:29:45.701
of these protocols, at the end
of this session, we will give

19245
19:29:45.701 --> 19:29:48.701
you a ton of links. And we'll
have a special guest explain a

19246
19:29:48.701 --> 19:29:50.701
few different ways to learn how
to build more of these

19247
19:29:50.701 --> 19:29:53.701
decentralized protocols.
Although we've already built one

19248
19:29:53.701 --> 19:29:56.701
with our decentralized lottery,
which is fantastic. Let's create

19249
19:29:56.701 --> 19:29:59.701
some scripts here. And for all
of these things, deposit

19250
19:29:59.701 --> 19:30:02.701
collateral, borrow and repay.
We'll just put this all in a new

19251
19:30:02.701 --> 19:30:06.701
script called Ave borrow dot
Jas. So we're gonna do

19252
19:30:06.701 --> 19:30:09.701
everything in here. And since
this is a script, it's going to

19253
19:30:09.701 --> 19:30:12.701
have the same setup, as we've
seen before, right, so we're

19254
19:30:12.701 --> 19:30:17.701
gonna have this main thing
around an async function. Main,

19255
19:30:17.701 --> 19:30:20.701
and then we'll have our imports,
of course at the top. Now

19256
19:30:20.701 --> 19:30:23.701
something that's important to
note, go to avi, we go to the

19257
19:30:23.701 --> 19:30:26.701
protocol, we kind of read
through the docs, and eventually

19258
19:30:26.701 --> 19:30:32.701
we would find out the protocol
treats everything as an ERC 20

19259
19:30:32.701 --> 19:30:35.701
token. And but we know that
Aetherium or the native

19260
19:30:35.701 --> 19:30:40.701
blockchain token that you're
using, isn't an ERC 20 token.

19261
19:30:40.701 --> 19:30:42.701
And the reason that treats
everything like an ERC 20 token

19262
19:30:42.701 --> 19:30:45.701
is that it's just much easier,
right? If everything's using

19263
19:30:45.701 --> 19:30:48.701
this ERC 20 token standard, it's
much easier to send in and

19264
19:30:48.701 --> 19:30:52.701
interact with stuff.

19265
19:30:52.701 --> 19:30:55.701
On a lot of these protocols,
when we go to deposit Aetherium,

19266
19:30:55.701 --> 19:30:58.701
or polygon, or arbitrary marks
cetera, what actually happens is

19267
19:30:58.701 --> 19:31:01.701
they send your Aetherium through
like what's called a web

19268
19:31:01.701 --> 19:31:07.701
gateway, and swaps it for weath,
which stands for rapt ether. And

19269
19:31:07.701 --> 19:31:12.702
it's basically Aetherium. But in
an ERC 20 token contract, so

19270
19:31:12.702 --> 19:31:14.702
what we want to do is going to
do that same thing, we're gonna

19271
19:31:14.702 --> 19:31:18.702
skip kind of using this web
gateway. And we'll just get the

19272
19:31:18.702 --> 19:31:21.702
Web Token ourselves, and we'll
use that as collateral. So in

19273
19:31:21.702 --> 19:31:25.702
our script tag, I'm going to
make another file called Get

19274
19:31:25.702 --> 19:31:29.702
weath.js. And in here, we're
actually going to go ahead, and

19275
19:31:29.702 --> 19:31:34.702
we're going to build a script
that will deposit our token for

19276
19:31:34.702 --> 19:31:37.702
web token. Okay, so let's create
the script. And there's a link

19277
19:31:37.702 --> 19:31:40.702
to the web token on ether scan,
and on Main net in the GitHub

19278
19:31:40.702 --> 19:31:44.702
repo. And the way it works, is
you actually deposit Aetherium.

19279
19:31:44.702 --> 19:31:47.702
And in return, it'll give you
the web token on Rigby right

19280
19:31:47.702 --> 19:31:53.702
now, by deposit 0.05. Go ahead
and write I'm connected to ether

19281
19:31:53.702 --> 19:31:55.702
scan, I'll go ahead and write
this transaction, I'm gonna

19282
19:31:55.702 --> 19:31:58.702
drink pee. So I don't really
care if it's if it's the actual

19283
19:31:58.702 --> 19:32:01.702
contract or not, because it's
not real money. But I'm going to

19284
19:32:01.702 --> 19:32:05.702
deposit 0.05 eath. And after our
transaction goes through, we

19285
19:32:05.702 --> 19:32:08.702
copy the contract address, we
add this token to our Metamask

19286
19:32:08.702 --> 19:32:12.702
the same way we added link will
import tokens, paste the address

19287
19:32:12.702 --> 19:32:16.702
in here, add custom token,
import tokens will now see we

19288
19:32:16.702 --> 19:32:21.702
have some wet token in here, I
deposited 0.1 before so 0.1 plus

19289
19:32:21.702 --> 19:32:26.702
0.05, which is why it shows 0.15
Because I did it twice, well,

19290
19:32:26.702 --> 19:32:29.702
while I wasn't recording. So um,
but this is how you can get this

19291
19:32:29.702 --> 19:32:32.702
wet token into your contract.
And then anytime you want, you

19292
19:32:32.702 --> 19:32:35.702
can call this withdrawal
function. And you can withdraw

19293
19:32:35.702 --> 19:32:38.702
your Aetherium out of this and
do what's called Burn your wet

19294
19:32:38.702 --> 19:32:42.702
token. So when you swap back
from weath to Aetherium, you hit

19295
19:32:42.702 --> 19:32:45.702
this withdraw and boom, you
basically swap them back because

19296
19:32:45.702 --> 19:32:49.702
this contract itself right now
is holding your Aetherium token.

19297
19:32:49.702 --> 19:32:52.703
Pretty cool, right? So in our
get wet function, we're not

19298
19:32:52.703 --> 19:32:54.703
going to add this main thing
here, we're going to create get

19299
19:32:54.703 --> 19:32:57.703
West here just as kind of a
module and we're going to import

19300
19:32:57.703 --> 19:33:00.703
it into our Ave borrow. So we're
not going to do this this main

19301
19:33:00.703 --> 19:33:03.703
thing that you see here.
Instead, we're going to create

19302
19:33:03.703 --> 19:33:08.703
an async function called Get
Wes. And then below, we're going

19303
19:33:08.703 --> 19:33:14.703
to export it. So we'll do module
dot exports equals get weath.

19304
19:33:14.703 --> 19:33:18.703
And we're going to export it so
our Avi borrow can use this get

19305
19:33:18.703 --> 19:33:21.703
West script that we're creating
right now, let's add let's go

19306
19:33:21.703 --> 19:33:23.703
ahead and do this. Well, in
order to interact with a

19307
19:33:23.703 --> 19:33:27.703
contract, we're going to need an
account. So we can do const

19308
19:33:27.703 --> 19:33:34.703
deployer equals await get named
accounts, per usual. We'll do

19309
19:33:34.703 --> 19:33:37.703
const get name accounts equals
require hardhat. My VS code

19310
19:33:37.703 --> 19:33:39.703
automatically imported that
thank you VS code now. And now

19311
19:33:39.703 --> 19:33:46.703
we want to call the deposit
function on the west contract.

19312
19:33:46.703 --> 19:33:49.703
How do we call this deposit
function on the west contract?

19313
19:33:49.703 --> 19:33:52.703
Well, how do you call any
contract? Well, what do you

19314
19:33:52.703 --> 19:33:56.703
need? You need the ABI and then
you need the contract address.

19315
19:33:56.703 --> 19:33:59.703
Drill this in. You're always
going to be the API and the

19316
19:33:59.703 --> 19:34:02.703
contract address to interact
with the contract. We know that

19317
19:34:02.703 --> 19:34:04.703
if we give we know that if we
give our project the whole

19318
19:34:04.703 --> 19:34:08.703
contract, it'll get the API but
we also know If we just do the

19319
19:34:08.703 --> 19:34:11.703
interface, that's just as good,
it won't give us all the

19320
19:34:11.703 --> 19:34:14.703
functionality, but it will tell
it will give us the API, it will

19321
19:34:14.703 --> 19:34:18.703
tell our ethers, what functions
it can use. So we're going to

19322
19:34:18.703 --> 19:34:22.703
create a new folder, create our
contracts folder. And in here,

19323
19:34:22.703 --> 19:34:24.703
we're going to create a new
folder inside of that called

19324
19:34:24.703 --> 19:34:27.703
interfaces. And this is where
we're going to create our web

19325
19:34:27.703 --> 19:34:31.704
interface. Now a web interface
is going to be really similar to

19326
19:34:31.704 --> 19:34:34.704
an ERC 20 interface. So if you
want to go ahead and try to add

19327
19:34:34.704 --> 19:34:38.704
it yourself, feel free to do so.
Or what you can just do is you

19328
19:34:38.704 --> 19:34:41.704
can come to the GitHub repo
associated with this lesson,

19329
19:34:41.704 --> 19:34:45.704
come to iOS and just copy paste,
right, you'll see the functions

19330
19:34:45.704 --> 19:34:49.704
in here are exactly the same as
an ERC 20, allowance approved

19331
19:34:49.704 --> 19:34:53.704
balance of decimals named blah,
blah, with these additional

19332
19:34:53.704 --> 19:34:56.704
deposit and withdrawal
functions. So I'm going to copy

19333
19:34:56.704 --> 19:35:00.704
all this, move back over to my
hard hat project, we'll create a

19334
19:35:00.704 --> 19:35:05.704
new file, we'll call I left dot
soul. And just to note,

19335
19:35:05.704 --> 19:35:09.704
oftentimes, a good best practice
is to have interfaces, start

19336
19:35:09.704 --> 19:35:12.704
with eyes so that you know what
to interface and then we'll

19337
19:35:12.704 --> 19:35:16.704
paste it in here. Now in order
for this to compile, we'll need

19338
19:35:16.704 --> 19:35:21.704
to use 0.4 point 19 version of
solidity. So what we can do is

19339
19:35:21.704 --> 19:35:25.704
we can come over to our, our
head.config.js. We have solidity

19340
19:35:25.704 --> 19:35:29.704
compilers, version 0.07, or
whatever versions that you have

19341
19:35:29.704 --> 19:35:32.704
in here, we can add or just
replace. So I'm going to put a

19342
19:35:32.704 --> 19:35:40.704
comma here, version 0.4 point
19. Save. And now in order to

19343
19:35:40.704 --> 19:35:45.704
make sure we can get that API,
do yarn, hardhats compile, or hh

19344
19:35:45.704 --> 19:35:48.704
compiled, and great, we compile
this interface. So now we have

19345
19:35:48.704 --> 19:35:52.704
the ABI to interact with. Now
that we have the ABI, a little

19346
19:35:52.704 --> 19:35:55.704
check mark here, let's go ahead
and get the contract address.

19347
19:35:55.704 --> 19:35:58.704
But for reasons that we're going
to learn about very soon, we're

19348
19:35:58.704 --> 19:36:01.704
actually going to work just with
main net set of getting the

19349
19:36:01.704 --> 19:36:04.704
Rinkeby test and address, I'm
going to look up with main net,

19350
19:36:04.704 --> 19:36:08.704
we're going to find the web
token on Main net. So I'm going

19351
19:36:08.704 --> 19:36:11.705
to copy the address of main net.
And again, you can just grab

19352
19:36:11.705 --> 19:36:15.705
this address from the GitHub
repo associated with this lesson

19353
19:36:15.705 --> 19:36:18.705
as well. And for now, we're
gonna say check a little check

19354
19:36:18.705 --> 19:36:22.705
mark here, and paste the address
there. So now we're have the ABI

19355
19:36:23.705 --> 19:36:25.705
compiled from an interface, and
we have the contract address for

19356
19:36:25.705 --> 19:36:28.705
main net. But let's go ahead and
create this contract now. So we

19357
19:36:28.705 --> 19:36:34.705
can say const, iOS equals await
ethers dot and then we'll need

19358
19:36:34.705 --> 19:36:38.705
to import ethers from Hardhead
as well. Ethers dot get contract

19359
19:36:38.705 --> 19:36:43.705
at this is another one of these
functions on ethers, it allows

19360
19:36:43.705 --> 19:36:46.705
us to get a contract at a
specific address, we'll say get

19361
19:36:46.705 --> 19:36:51.705
contract app, we use the iOS ABI
for now, we'll just hard code

19362
19:36:51.705 --> 19:36:54.705
this address in here. And then
we'll connect it to the

19363
19:36:54.705 --> 19:36:57.705
Deployer. So we're saying let's
get this web contract with the

19364
19:36:57.705 --> 19:37:02.705
ABI of iOS at this address
connected to Deployer. So we

19365
19:37:02.705 --> 19:37:08.705
could go ahead and run await AI
with dot deposit. And we'll set

19366
19:37:08.705 --> 19:37:11.705
value which will be some
amounts. Let's go ahead and at

19367
19:37:11.705 --> 19:37:17.705
the top, we'll say const amount
equals let's do ethers dot utils

19368
19:37:17.705 --> 19:37:24.705
dot parse, ether, and then we'll
do 0.0 0.02. So we'll deposit

19369
19:37:24.705 --> 19:37:30.705
0.02 will say const TX equals
that will do await TX dot wait

19370
19:37:30.705 --> 19:37:33.705
one wait for one block to go
through. And then we'll just get

19371
19:37:33.705 --> 19:37:40.705
the balance will say const. With
balance equals await I with that

19372
19:37:40.705 --> 19:37:44.705
balance of employer. So we're
going to call the balance of

19373
19:37:44.705 --> 19:37:48.705
function on our iWeb ERC 20
token. And then we'll just do

19374
19:37:48.705 --> 19:37:56.706
console dot log got West
balance.to string.

19375
19:37:56.706 --> 19:37:59.706
So we're using the main net
address in here. And we're gonna

19376
19:37:59.706 --> 19:38:01.706
say okay, we're going to deposit
some amount, we're going to

19377
19:38:01.706 --> 19:38:04.706
wait. And then we're gonna go
ahead and get the balance right,

19378
19:38:04.706 --> 19:38:07.706
so we're just depositing our
Aetherium so that we can get

19379
19:38:07.706 --> 19:38:13.706
that ERC 20 version of
Aetherium, that West token here.

19380
19:38:13.706 --> 19:38:16.706
Now, you might be thinking,
Okay, why are you putting the

19381
19:38:16.706 --> 19:38:19.706
main address in here? Let's
Patrick, slow down. Let's go

19382
19:38:19.706 --> 19:38:23.706
ahead and let's create a mock
Web Token contract address.

19383
19:38:23.706 --> 19:38:27.706
Let's deploy the mocks first,
and then we'll go ahead and use

19384
19:38:27.706 --> 19:38:29.706
that same setup that we've been
doing this whole time, why you

19385
19:38:29.706 --> 19:38:32.706
why you directly hard coding
this in here. Well, I've been

19386
19:38:32.706 --> 19:38:36.706
alluding to this for some time.
But there's another way that we

19387
19:38:36.706 --> 19:38:39.706
can run tests in our smart
contracts. And this is with

19388
19:38:39.706 --> 19:38:42.706
something called main net
forking, we can actually do

19389
19:38:42.706 --> 19:38:46.706
something where we fork the main
net, and run a local hard hat

19390
19:38:46.706 --> 19:38:51.706
node. That's pretending to be a
main net node. And all we have

19391
19:38:51.706 --> 19:38:55.706
to do is update our hard head
config to do so. So let's talk

19392
19:38:55.706 --> 19:38:58.706
about forking for a minute. So
on the left here, we have a

19393
19:38:58.706 --> 19:39:00.706
blockchain an example of
blockchain it's going to be

19394
19:39:00.706 --> 19:39:05.706
something similar to a test net
or main net like Rinkeby, eath,

19395
19:39:05.706 --> 19:39:09.706
main net polygon etc. This is
going to be a blockchain that we

19396
19:39:09.706 --> 19:39:12.706
deploy to. Now there are a whole
bunch of blocks in here, right?

19397
19:39:12.706 --> 19:39:15.706
We have this huge chain that we
can work with. And all this

19398
19:39:15.706 --> 19:39:18.706
information on the blockchain is
public information, like this

19399
19:39:18.706 --> 19:39:22.706
block is going to have
transaction transaction

19400
19:39:22.706 --> 19:39:25.706
transaction, each one of these
blocks is going to have a whole

19401
19:39:25.706 --> 19:39:28.706
bunch of transactions. And all
this information is on this

19402
19:39:28.706 --> 19:39:31.707
public blockchain. In addition
to all these transactions, it's

19403
19:39:31.707 --> 19:39:34.707
going to have things like price
feed contracts, it's going to

19404
19:39:34.707 --> 19:39:37.707
have things like Ave contract,
the Web token, contract, etc.

19405
19:39:37.707 --> 19:39:42.707
All this contract information is
public. So hypothetically, if

19406
19:39:42.707 --> 19:39:46.707
it's already there, we should be
basically able to copy this to

19407
19:39:46.707 --> 19:39:50.707
our local environment and do
some simulations ourselves. And

19408
19:39:50.707 --> 19:39:54.707
that's exactly what forking
does. A fork blockchain

19409
19:39:54.707 --> 19:39:58.707
literally takes a copy of an
existing blockchain like on the

19410
19:39:58.707 --> 19:40:02.707
left here and brings it on our
local computer. We actually have

19411
19:40:02.707 --> 19:40:05.707
control over our blockchain
that's running locally, because

19412
19:40:05.707 --> 19:40:08.707
it's gonna run on a local
computer, similar to hard hat.

19413
19:40:08.707 --> 19:40:12.707
Now, everything we do on this
local forked blockchain is not

19414
19:40:12.707 --> 19:40:15.707
going to affect main them,
because it's a simulated

19415
19:40:15.707 --> 19:40:18.707
blockchain. It's just running in
our local environment. So we can

19416
19:40:18.707 --> 19:40:21.707
actually interact with this
forking this kind of local

19417
19:40:21.707 --> 19:40:24.707
blockchain that resembles that
mimics the actual blockchain.

19418
19:40:24.707 --> 19:40:27.707
And here's what forking doesn't
do, it doesn't download the

19419
19:40:27.707 --> 19:40:30.707
entire blockchain into our local
setup. Anytime we reference an

19420
19:40:30.707 --> 19:40:33.707
address. Anytime we reference,
hey, there's something at a

19421
19:40:33.707 --> 19:40:37.707
specific address, we make an API
call to our Aetherium node,

19422
19:40:37.707 --> 19:40:41.707
which again, we're using alchemy
and say, hey, oh, what's at this

19423
19:40:41.707 --> 19:40:45.707
address, and it'll return just
that specific contract for us.

19424
19:40:45.707 --> 19:40:47.707
This way, we don't have to
download the whole blockchain.

19425
19:40:47.707 --> 19:40:50.707
And it's a lot quicker. And we
can also do this forking to run

19426
19:40:50.707 --> 19:40:53.707
our tests to run our scripts to
do everything. And now you might

19427
19:40:53.707 --> 19:40:55.707
be thinking, wow, Patrick, this
sounds awesome. Well, why don't

19428
19:40:55.707 --> 19:40:58.707
we just do this for everything?
Well, there's some trade offs.

19429
19:40:58.707 --> 19:41:01.707
The pros are that it's quick,
it's easy, and a test will

19430
19:41:01.707 --> 19:41:04.707
resemble what's on Main net. Now
the cons are that we need an

19431
19:41:04.707 --> 19:41:08.707
API, and we can't do everything
locally. Some contracts, some

19432
19:41:08.707 --> 19:41:11.708
contracts are complex to work
with, and mocks might just be

19433
19:41:11.708 --> 19:41:14.708
better. But using a forked
network might be a good way to

19434
19:41:14.708 --> 19:41:16.708
run your tests, it might be a
good alternate to just using

19435
19:41:16.708 --> 19:41:19.708
mocks. So it really depends on
what's right for you and right

19436
19:41:19.708 --> 19:41:23.708
for your project. But it is a
fantastic tool, especially for

19437
19:41:23.708 --> 19:41:25.708
something like Avi, where we
want to quickly test some

19438
19:41:25.708 --> 19:41:29.708
things. Now the hard forking
also will give us a bunch of

19439
19:41:29.708 --> 19:41:32.708
fake accounts. So we'll still
get a bunch of fake accounts on

19440
19:41:32.708 --> 19:41:36.708
Main net that will be given a
theorem. So we'll get fake main

19441
19:41:36.708 --> 19:41:38.708
net accounts for this forking.
So for the rest of this, we're

19442
19:41:38.708 --> 19:41:41.708
going to be using this forking
to run our scripts and run our

19443
19:41:41.708 --> 19:41:45.708
tests. If you want to go back
after this and try this all out

19444
19:41:45.708 --> 19:41:48.708
on COVID. We've got a whole
bunch of different addresses for

19445
19:41:48.708 --> 19:41:50.708
the COVID network so that you
can run these scripts directly

19446
19:41:50.708 --> 19:41:53.708
on COVID. And you can see the
transactions yourself. Just note

19447
19:41:53.708 --> 19:41:56.708
that when using COVID, you'll
want to make sure that you're

19448
19:41:56.708 --> 19:41:59.708
using the same addresses, as are
in the AVI docs for the COVID

19449
19:41:59.708 --> 19:42:03.708
network, because they do change
sometimes. Great, let's go

19450
19:42:03.708 --> 19:42:06.708
ahead, we'll go to our RT head
dot config dot j s. And now

19451
19:42:06.708 --> 19:42:09.708
we'll go to our networks, which
right now, I don't have

19452
19:42:09.708 --> 19:42:15.708
anything, I only have ranking.
And we'll add hard hat in here,

19453
19:42:15.708 --> 19:42:18.708
we'll add a little comma down
here. And we'll say, you know,

19454
19:42:18.708 --> 19:42:22.708
the chain ID of course is going
to be 31337. We'll add this

19455
19:42:22.708 --> 19:42:26.708
forking keyword. And in here,
we'll say the URL for a Forking

19456
19:42:26.708 --> 19:42:30.708
is going to be our main net RPC
URL. And this is another reason

19457
19:42:30.708 --> 19:42:34.708
why we're using alchemy. Alchemy
is fantastic at these forked

19458
19:42:34.708 --> 19:42:37.708
blockchains, and has really good
pieces here. So what we can do

19459
19:42:37.708 --> 19:42:40.708
is we can come back to our
alchemy dashboard, we'll create

19460
19:42:40.708 --> 19:42:44.708
a new app. This one will be for
Aetherium main net, and we'll

19461
19:42:44.708 --> 19:42:50.709
say forking chain. We'll say for
forking, we'll go ahead and

19462
19:42:50.709 --> 19:42:53.709
create this on a theory and main
net. Now that we have this

19463
19:42:53.709 --> 19:42:57.709
forking chain, we can do the
same thing. We'll grab our API

19464
19:42:57.709 --> 19:43:02.709
key, we'll come back to our
project, create this new file,

19465
19:43:02.709 --> 19:43:07.709
we'll create our dot env. And
we'll do main net RPC URL equals

19466
19:43:07.709 --> 19:43:10.709
and paste that in there. In our
Hardhead config, we are now

19467
19:43:10.709 --> 19:43:14.709
going to be forking from mainnet
RPC URL whenever we work with

19468
19:43:14.709 --> 19:43:18.709
the heart at blockchain. So now
that we have this in here, let's

19469
19:43:18.709 --> 19:43:22.709
go ahead and try to run this get
wet function. Because since

19470
19:43:22.709 --> 19:43:26.709
we're forking the blockchain, we
should be able to go ahead and

19471
19:43:26.709 --> 19:43:29.709
simulate this. So backing off a
borrow, we'll go ahead we'll do

19472
19:43:29.709 --> 19:43:33.709
const, get weath

19473
19:43:33.709 --> 19:43:37.709
equals require and then we'll
pull this script that dot dot

19474
19:43:37.709 --> 19:43:43.709
scripts slash get weath. And
then, in our main function,

19475
19:43:43.709 --> 19:43:48.709
we'll just run await yet. So to
run our script here, we'll do

19476
19:43:48.709 --> 19:43:55.709
yarn hard hat, run scripts
avevamo.js. And our default

19477
19:43:55.709 --> 19:43:57.709
network is hard hat. So we could
either do dash dash network hard

19478
19:43:57.709 --> 19:44:01.709
hat or just run it. And
remember, since in our config,

19479
19:44:01.709 --> 19:44:04.709
we're saying, hey, when we run
the hard hat chain, use this

19480
19:44:04.709 --> 19:44:07.709
forking, we're going to be
forking, so let's go ahead Run

19481
19:44:07.709 --> 19:44:11.709
this ran to air main. Net RPC
URL is undefined. Well, that

19482
19:44:11.709 --> 19:44:15.709
makes sense. Let's go ahead and
add this consummated RPC rel

19483
19:44:15.709 --> 19:44:21.709
equals process study and v dot
made it RPC URL. Let's try this

19484
19:44:21.709 --> 19:44:26.709
again. And we now see we got,
you know, this much weath,

19485
19:44:26.709 --> 19:44:28.709
which, again, that much wealth
is gonna be

19486
19:44:28.709 --> 19:44:35.710
1-234-567-8910 1234567 0.02
wealth, which is exactly what we

19487
19:44:35.710 --> 19:44:39.710
want. So now we have a way to
interact with main net locally,

19488
19:44:39.710 --> 19:44:42.710
which sounds kind of crazy. But
he's incredibly powerful for

19489
19:44:42.710 --> 19:44:45.710
exactly what we're doing right
here. So we have a way to fork

19490
19:44:45.710 --> 19:44:48.710
main that eath and run our
scripts and kind of test to see

19491
19:44:48.710 --> 19:44:51.710
and simulate what it would be
like to actually run these

19492
19:44:51.710 --> 19:44:55.710
transactions. So we're gonna do
like that, our get with function

19493
19:44:55.710 --> 19:44:58.710
looks good. And obviously, we
would still modularize this, we

19494
19:44:58.710 --> 19:45:01.710
put this in our helper Hardhead
config, but we're going to skip

19495
19:45:01.710 --> 19:45:04.710
doing that for now. So let's go
head back to the AVI borrow. And

19496
19:45:04.710 --> 19:45:07.710
let's go ahead and flesh the
rest of this out. Now, let's go

19497
19:45:07.710 --> 19:45:09.710
ahead and set up the rest of the
boilerplate here. So we'll do

19498
19:45:09.710 --> 19:45:13.710
const Deployer, because we need
an account, obviously equals

19499
19:45:13.710 --> 19:45:17.710
await, get named accounts. And
then we'll do const get named

19500
19:45:17.710 --> 19:45:24.710
accounts equals require. Now we
want to start interacting with

19501
19:45:24.710 --> 19:45:26.710
the ABI protocol, well, what do
we need, we're gonna need the

19502
19:45:26.710 --> 19:45:30.710
ABI and the address, nothing
changes, we're gonna need these

19503
19:45:30.710 --> 19:45:33.710
two. So what we can do is we can
go to the Ave docs. And again,

19504
19:45:33.710 --> 19:45:37.710
we're going to be on V two. And
we can go ahead and find the

19505
19:45:37.710 --> 19:45:41.710
contract address in here. Now
the way it works is they

19506
19:45:41.710 --> 19:45:44.710
actually have a contract, which
will point us to the correct

19507
19:45:44.710 --> 19:45:46.710
contract. The contract that
we're going to be doing all the

19508
19:45:46.710 --> 19:45:50.710
lending with is this lending
pool. And there's actually a

19509
19:45:50.710 --> 19:45:55.710
contract to get that contract
address. And to get the lending

19510
19:45:55.710 --> 19:45:58.710
pool address, we have to go to
the lending pool address

19511
19:45:58.710 --> 19:46:00.710
provider. It's this contract
that will tell us what the

19512
19:46:00.710 --> 19:46:03.710
address of the lending pullets.
And we can actually see the

19513
19:46:03.710 --> 19:46:06.710
deployed contract section, we
can see the address of this

19514
19:46:06.710 --> 19:46:08.710
contract. And we can see the
address of all the main ones and

19515
19:46:08.710 --> 19:46:11.711
the COVID. Once again, if you
want to play with this on COVID.

19516
19:46:11.711 --> 19:46:14.711
But we can see lending pool
address provider is going to be

19517
19:46:14.711 --> 19:46:18.711
located right here, we can copy
this address. And we'll just

19518
19:46:18.711 --> 19:46:21.711
take notes of this.

19519
19:46:21.711 --> 19:46:24.711
And that lending pool, we're
going to get from the lending

19520
19:46:24.711 --> 19:46:28.711
pelagics provider. So let's
actually create a function that

19521
19:46:28.711 --> 19:46:30.711
will get us the lending pool
address from the lending pool

19522
19:46:30.711 --> 19:46:35.711
address provider. So down here,
we'll create async function, get

19523
19:46:35.711 --> 19:46:38.711
lending pool. Now in order to
interact with this lending pool

19524
19:46:38.711 --> 19:46:41.711
address provider. Same thing,
we're going to need its address

19525
19:46:41.711 --> 19:46:44.711
and its API, we have its
address. So let's go ahead and

19526
19:46:44.711 --> 19:46:48.711
get its API, you can go ahead to
the GitHub repo associated with

19527
19:46:48.711 --> 19:46:51.711
this lesson. And just copy paste
it from the interfaces section.

19528
19:46:51.711 --> 19:46:55.711
You could also look directly on
the blockchain to see what this

19529
19:46:55.711 --> 19:46:58.711
contract looks I can create your
own interface. Or we can go

19530
19:46:58.711 --> 19:47:00.711
ahead and use the interface
right in the documentation. So

19531
19:47:00.711 --> 19:47:03.711
we have islanding Palach.
Provider, I'm just going to copy

19532
19:47:03.711 --> 19:47:07.711
this from the ABI docs. But
again, you've got a number of

19533
19:47:07.711 --> 19:47:10.711
options. And so in our contracts
in our interfaces, let's let's

19534
19:47:10.711 --> 19:47:14.711
stick iwth in interfaces here.
Let's create a new file. And

19535
19:47:14.711 --> 19:47:20.711
we'll call it I lending pool
address provider, dot soul. And

19536
19:47:20.711 --> 19:47:24.711
we'll paste it in here, we just
see we're using 0.6 point 12. So

19537
19:47:24.711 --> 19:47:27.711
be sure to in our Hardhead
config to make sure we have that

19538
19:47:27.711 --> 19:47:33.711
we don't so we're just create a
new one 0.6 point 12 And then

19539
19:47:33.711 --> 19:47:38.711
we'll compile yarn Hardhead
compile and compiles so awesome.

19540
19:47:38.711 --> 19:47:42.711
We now have the ABI here, we'll
get this contract by saying

19541
19:47:42.711 --> 19:47:50.711
const lending pool address
provider equals await ethers dot

19542
19:47:50.711 --> 19:47:59.712
get contract at will say I
lending pool address oops

19543
19:47:59.712 --> 19:48:03.712
address as I lending pool
addresses excuse me, I'm going

19544
19:48:03.712 --> 19:48:06.712
to update the name I Lenny pull
addresses provider islanding

19545
19:48:06.712 --> 19:48:11.712
pool addresses provider, we're
going to pass in that contract

19546
19:48:11.712 --> 19:48:16.712
address that we got from the
Ovid docs here. Paste that in.

19547
19:48:16.712 --> 19:48:19.712
And then we're going to connect
it to our Deployer. So we're

19548
19:48:19.712 --> 19:48:22.712
going to have our get lending
pool, get past that account

19549
19:48:22.712 --> 19:48:25.712
variable and then we'll just use
the account here to connect it

19550
19:48:25.712 --> 19:48:28.712
and the account that we're going
to pass is of course going to be

19551
19:48:28.712 --> 19:48:32.712
our Deployer. In our lending
pool address provider. There's a

19552
19:48:32.712 --> 19:48:37.712
function called Get lending pool
which returns the address of the

19553
19:48:37.712 --> 19:48:39.712
lining pool and this is going to
be the function that we're going

19554
19:48:39.712 --> 19:48:44.712
to call so we're gonna say const
lending pool address equals a

19555
19:48:44.712 --> 19:48:51.712
weight lending pool address says
probes address any pool address

19556
19:48:51.712 --> 19:48:56.712
says provider dot get lending
pool and that's it we'll have

19557
19:48:56.712 --> 19:48:59.712
the lending pool address and
then we'll have this contract

19558
19:48:59.712 --> 19:49:03.712
give us the lending pool
contract by doing const lending

19559
19:49:03.712 --> 19:49:10.712
pool equals await ethers dot get
contract Add. And we need to do

19560
19:49:10.712 --> 19:49:13.712
the same thing, the interface,
the interface, the address, and

19561
19:49:13.712 --> 19:49:17.712
then the account. So back in the
docs, we can grab the I lending

19562
19:49:17.712 --> 19:49:22.712
pool by copying this like this.
We'll go back to our contracts

19563
19:49:22.712 --> 19:49:27.712
interfaces, new file, I lending
pool, that's all. And we'll

19564
19:49:27.712 --> 19:49:30.712
paste it in. Now with this one,
if we scroll to the top, we

19565
19:49:30.712 --> 19:49:34.713
noticed that we're importing
from some local places that we

19566
19:49:34.713 --> 19:49:38.713
actually don't have in our
contracts area, we can once

19567
19:49:38.713 --> 19:49:44.713
again go ahead and add the AVI
protocol v2 from NPM. And just

19568
19:49:44.713 --> 19:49:49.713
use this as our imports. So
we'll do yarn, add dash dash dev

19569
19:49:49.713 --> 19:49:55.713
apt have a slash proto call
hyphen V two. And now that we

19570
19:49:55.713 --> 19:50:00.713
have the Add Ave protocol in our
node modules, we can update

19571
19:50:00.713 --> 19:50:03.713
these imports to point to our
node modules instead of our

19572
19:50:03.713 --> 19:50:07.713
local files. So I'm just gonna
go ahead and tell you that the

19573
19:50:07.713 --> 19:50:12.713
islanding pledge provider is
that Ave slash protocol hyphen V

19574
19:50:12.713 --> 19:50:17.713
to slash contracts slash
interfaces. And then data types

19575
19:50:17.713 --> 19:50:22.713
dot soul is gonna be at of a
protocol hyphen v2 slash

19576
19:50:22.713 --> 19:50:28.713
contracts slash, proto call
slash libraries, slash types,

19577
19:50:28.713 --> 19:50:32.713
data types, that's all again to
make sure this is right, yarn,

19578
19:50:32.713 --> 19:50:36.713
Hardhead compile or hh, compile.
And Cool. Looks like I did that

19579
19:50:36.713 --> 19:50:41.713
right? Lending pool equals await
ethers dot get contract at,

19580
19:50:41.713 --> 19:50:44.713
we're going to be using lending
pool, I lend the pool here,

19581
19:50:44.713 --> 19:50:47.713
we're going to use this lending
pool address got from the

19582
19:50:47.713 --> 19:50:51.713
addresses provider. And then the
account, which is going to be

19583
19:50:51.713 --> 19:50:57.713
our Deployer. And now we can do
return lending pool. And if we

19584
19:50:57.713 --> 19:51:03.713
want, and now that we have this
function get lending pool backup

19585
19:51:03.713 --> 19:51:08.713
in our main function, we can say
const lending pool equals a

19586
19:51:08.713 --> 19:51:12.714
weight, get lending pool and
then pass the Deployer. And then

19587
19:51:12.714 --> 19:51:15.714
we can even do a little console
dot log,

19588
19:51:15.714 --> 19:51:22.714
lending pool address and then do
lending pool dot address. And

19589
19:51:22.714 --> 19:51:24.714
since we're making it forking,
we can kind of just keep running

19590
19:51:24.714 --> 19:51:30.714
this right. So we'll do yarn
hardhat run scripts. Ave Baroda

19591
19:51:30.714 --> 19:51:33.714
Jas, there are multiple
artifacts for contract II

19592
19:51:33.714 --> 19:51:37.714
lending pool addresses provider.
And this is because in our node

19593
19:51:37.714 --> 19:51:42.714
modules, import all this stuff
from contracts and in here, and

19594
19:51:42.714 --> 19:51:45.714
there's already in islanding,
pool addresses provider in those

19595
19:51:45.714 --> 19:51:48.714
add ons slash contracts. So
actually, we don't even need

19596
19:51:48.714 --> 19:51:51.714
this, I lending pool added
service provider, we can go

19597
19:51:51.714 --> 19:51:54.714
ahead and delete it. Our time
right now is getting confused.

19598
19:51:54.714 --> 19:51:57.714
It's saying Oh, are you
referring to the one that you

19599
19:51:57.714 --> 19:52:01.714
downloaded from NPM or the one
that you made, which which one

19600
19:52:01.714 --> 19:52:04.714
do you want to use. So we'll
just make it easier for hardhat.

19601
19:52:04.714 --> 19:52:07.714
And we'll say okay, well, we'll
delete the one that we created,

19602
19:52:07.714 --> 19:52:09.714
we'll use the one that we've
downloaded here. And now we

19603
19:52:09.714 --> 19:52:12.714
should be good to run this
again. Because now there's only

19604
19:52:12.714 --> 19:52:16.714
one for to pick from, which is
the one we downloaded from NPM.

19605
19:52:16.714 --> 19:52:20.714
And perfect, we get our get
weath printout here, and then we

19606
19:52:20.714 --> 19:52:22.714
get lending pool address is
here. And this is going to be

19607
19:52:22.714 --> 19:52:26.714
the actual lending pool address
on ether Aetherium main net. So

19608
19:52:26.714 --> 19:52:29.714
if we go back to ether scan,
copy that address and paste it

19609
19:52:29.714 --> 19:52:34.714
and ether scan, we can see it's
even labeled Ave v two, and we

19610
19:52:34.714 --> 19:52:38.714
can see a ton of transactions
going through all the time. And

19611
19:52:38.714 --> 19:52:39.714
ether scan is having a hard time
keeping up with all the

19612
19:52:39.714 --> 19:52:42.714
transactions. So we've got the
lending pool address, we've got

19613
19:52:42.714 --> 19:52:47.714
some web token, what do we need
to do? Now we want a deposit of

19614
19:52:47.714 --> 19:52:50.714
what do we need in order to
deposit the token? Well, if we

19615
19:52:50.714 --> 19:52:54.715
look at the deposit function in
the avec GitHub, we can scroll

19616
19:52:54.715 --> 19:52:58.715
in here and we see it eventually
we'll call this safe transfer

19617
19:52:58.715 --> 19:53:01.715
from which is basically going to
be this transfer from function,

19618
19:53:01.715 --> 19:53:04.715
since we're calling transfer
from it's going to be this

19619
19:53:04.715 --> 19:53:08.715
contract, that's actually going
to pull the money out of our

19620
19:53:08.715 --> 19:53:12.715
wallet. So in order to give the
Ave contract, the ability to

19621
19:53:12.715 --> 19:53:15.715
pull the money out of our
wallet, we need to do what we're

19622
19:53:15.715 --> 19:53:19.715
going to need to approve the
contract. So first, before we

19623
19:53:19.715 --> 19:53:22.715
can even deposit we're gonna
need to approve it to get our

19624
19:53:22.715 --> 19:53:25.715
web token, we're gonna have to
get the Web Token first. So

19625
19:53:25.715 --> 19:53:29.715
let's get the Web Token address
we'll say const Web Token

19626
19:53:29.715 --> 19:53:33.715
address, equals and this is
where we marginalize it and get

19627
19:53:33.715 --> 19:53:36.715
it from our hard head helper
config. But for now, we can just

19628
19:53:36.715 --> 19:53:39.715
hard code it, the Web Token
contract address is going to be

19629
19:53:39.715 --> 19:53:42.715
the exact same thing as what's
in get web and then want to

19630
19:53:42.715 --> 19:53:46.715
approve. So let's write an
approved function because we're

19631
19:53:46.715 --> 19:53:48.715
going to use this a couple
times. So we'll make an async

19632
19:53:48.715 --> 19:53:54.715
function and approve ERC 20

19633
19:53:54.715 --> 19:54:00.715
And we'll take a contract
address a spender address, which

19634
19:54:00.715 --> 19:54:03.715
is going to be the contract that
we're going to give the approval

19635
19:54:03.715 --> 19:54:08.715
to to spend our token and amount
to spend so exactly how much we

19636
19:54:08.715 --> 19:54:13.715
want to prove it. And then an
account to do all this on. So in

19637
19:54:13.715 --> 19:54:19.715
here we'll say const ERC 20
token equals await ethers dot

19638
19:54:19.715 --> 19:54:24.715
get contract at. And we could
say I WEF but maybe we just want

19639
19:54:24.715 --> 19:54:28.715
like a simple ERC 20 token
interface. And we're going to

19640
19:54:28.715 --> 19:54:31.716
grab that by cheating a little
bit coin to our hard head defy

19641
19:54:31.716 --> 19:54:34.716
FCC. We're going to go to
interfaces and grab this

19642
19:54:34.716 --> 19:54:37.716
interface from here. So we're
going to copy this, paste it in

19643
19:54:37.716 --> 19:54:43.716
here New File IO ERC 20 dot som
paste and now we have an ABI for

19644
19:54:43.716 --> 19:54:48.716
ERC. 20s So we'll do get
contract that ERC 20 Actually

19645
19:54:48.716 --> 19:54:51.716
let's change this name to ERC.
20 address so we're going to get

19646
19:54:51.716 --> 19:54:57.716
the contract with the ABI of IRC
ERC 20 at contract address ERC

19647
19:54:57.716 --> 19:55:01.716
20 address and then we'll
connect it to our account here.

19648
19:55:01.716 --> 19:55:06.716
So and once we have the ERC 20
We can do const TX, we're going

19649
19:55:06.716 --> 19:55:11.716
to do that approve transaction
we'll do a weight ERC 20 token

19650
19:55:11.716 --> 19:55:18.716
dot approve spender address, and
then amount amount to spend.

19651
19:55:18.716 --> 19:55:22.716
We'll do we'll do a wait TX dot
wait for one block. And we'll do

19652
19:55:22.716 --> 19:55:27.716
a little console dot log saying
approved. Now if you don't run

19653
19:55:27.716 --> 19:55:30.716
this function before you try to
deposit you'll just get an error

19654
19:55:30.716 --> 19:55:32.716
saying hey, token is not
approved, which is a pretty

19655
19:55:32.716 --> 19:55:36.716
common error. So if you ever see
that just know, I forgot to

19656
19:55:36.716 --> 19:55:39.716
approve my token. So backup in
our main script, we'll go ahead

19657
19:55:39.716 --> 19:55:44.716
and run this function. We'll say
await approve ERC 20 with the

19658
19:55:44.716 --> 19:55:48.716
Web Token address lending pool
dot address because we want to

19659
19:55:48.716 --> 19:55:53.716
give the len pool the approval
to pull our web token from our

19660
19:55:53.716 --> 19:55:57.716
account. And then we'll give it
some amount to actually will

19661
19:55:57.716 --> 19:56:01.716
import a mount from get weath as
well. Mount we gotta go back to

19662
19:56:01.716 --> 19:56:05.716
get with an export it so we can
actually import it. So get with

19663
19:56:05.716 --> 19:56:10.716
exporting that amount that 0.02.
So we'll prove the amount and

19664
19:56:10.716 --> 19:56:12.717
then we'll connect we'll have
our Deployer do it obviously

19665
19:56:12.717 --> 19:56:14.717
because we're doing everything
with the Deployer. So we'll

19666
19:56:14.717 --> 19:56:18.717
approve the ERC 20. And then
once we approve, we can go ahead

19667
19:56:18.717 --> 19:56:22.717
and deposit it. So we'll say
console dot log, depositing

19668
19:56:22.717 --> 19:56:28.717
that. And then we'll run await
lending pool dot deposit. If we

19669
19:56:28.717 --> 19:56:33.717
look at the deposit function, we
can see all the parameters that

19670
19:56:33.717 --> 19:56:37.717
the deposit function takes. We
can also see it in the Ave v2

19671
19:56:37.717 --> 19:56:40.717
documentation and we just look
forward the posit. And we can

19672
19:56:40.717 --> 19:56:42.717
see it takes the address of the
asset that we're going to

19673
19:56:42.717 --> 19:56:46.717
deposit how much of that asset
we're going to deposit address

19674
19:56:46.717 --> 19:56:49.717
on behalf of we're going to do
it on behalf of ourself and then

19675
19:56:49.717 --> 19:56:52.717
a referral code, which right now
is just always going to be zero

19676
19:56:52.717 --> 19:56:55.717
because the referral code has
been discontinued. So we're

19677
19:56:55.717 --> 19:56:58.717
going to deposit the wet token
address, we're going to deposit

19678
19:56:58.717 --> 19:57:04.717
our web token, we're going to
posit 0.02 of that web token.

19679
19:57:04.717 --> 19:57:07.717
And then we're going to use a
deployer ash and then referral

19680
19:57:07.717 --> 19:57:09.717
code is going to be zero. And
then we'll do a little console

19681
19:57:09.717 --> 19:57:14.717
dot log the positive. So let's
try this script. Let's see if it

19682
19:57:14.717 --> 19:57:18.717
works. I'm just going to hit up
to go ahead and rerun this

19683
19:57:18.717 --> 19:57:21.717
script to rerun this command I
just ran into doing a little

19684
19:57:21.717 --> 19:57:25.717
compiling that ERC 20. That song
was compiled one solidity file,

19685
19:57:25.717 --> 19:57:29.717
got a bunch of wrapped Aetherium
lending pool address. We

19686
19:57:29.717 --> 19:57:32.717
approved it, we deposit we were
depositing it and then we

19687
19:57:32.717 --> 19:57:37.717
deposited it. So if we're
looking at our little readme

19688
19:57:37.717 --> 19:57:42.717
here, we get a little checkmark.

19689
19:57:42.717 --> 19:57:46.717
We've done step one, we've
deposited our collateral.

19690
19:57:46.717 --> 19:57:49.717
Awesome. So now we have some
collateral to use to borrow

19691
19:57:49.717 --> 19:57:53.718
other assets. Great. So now
we've deposited let's go ahead

19692
19:57:53.718 --> 19:57:56.718
and learn how to borrow now
through a couple of new lines,

19693
19:57:56.718 --> 19:58:01.718
and we'll say borrowed time. So
in order for us to borrow, we

19694
19:58:01.718 --> 19:58:05.718
probably want to know how much
we can borrow. And we want to

19695
19:58:05.718 --> 19:58:09.718
know more about our account,
right? We want to know how much

19696
19:58:09.718 --> 19:58:14.718
we have borrowed, how much we
have in collateral and how much

19697
19:58:14.718 --> 19:58:18.718
we can borrow. So there's a
function that Avi comes with

19698
19:58:18.718 --> 19:58:21.718
called Get User account data,
which will return the user's

19699
19:58:21.718 --> 19:58:24.718
account data across all
reserves, how much collateral we

19700
19:58:24.718 --> 19:58:28.718
have down the total value it in
its eath price, we have the

19701
19:58:28.718 --> 19:58:32.718
available borrows and eath
current liquidation threshold,

19702
19:58:32.718 --> 19:58:36.718
loan to value etc. Now these are
really important metrics. If we

19703
19:58:36.718 --> 19:58:39.718
have one, eath and collateral
that doesn't mean we can borrow

19704
19:58:39.718 --> 19:58:43.718
one eath of assets. Each one of
these tokens have some different

19705
19:58:43.718 --> 19:58:48.718
values like loan to value. For
example, if you have one eath

19706
19:58:48.718 --> 19:58:53.718
you can only borrow zero point
75 for the dye token, this is to

19707
19:58:53.718 --> 19:58:57.718
reduce risk of the collateral
and reduce risk of people not

19708
19:58:57.718 --> 19:59:01.718
having enough collateral down as
prices fluctuate. There's a

19709
19:59:01.718 --> 19:59:06.718
liquidation threshold of 80% if
you have one eath as collateral

19710
19:59:06.718 --> 19:59:10.718
and point 81 eath borrowed,
you'll get what's called

19711
19:59:10.718 --> 19:59:14.718
liquidated. So what is
liquidation? When you put down

19712
19:59:14.718 --> 19:59:16.718
collateral and you borrow, if
the amount that you have

19713
19:59:16.718 --> 19:59:20.718
borrowed past this liquidation
threshold is passed that 80% Or,

19714
19:59:20.718 --> 19:59:23.718
or depending on different
assets, it's different people

19715
19:59:23.718 --> 19:59:26.718
can do what's called liquidate
you. This is when they pay back

19716
19:59:26.718 --> 19:59:31.718
some of your loan that you took
out. And they also get to buy

19717
19:59:31.718 --> 19:59:34.719
some of your collateral at a
cheaper price. This keeps the

19718
19:59:35.719 --> 19:59:39.719
Ave platform solvent, and it
makes it so that there's never

19719
19:59:39.719 --> 19:59:43.719
more borrows than there are
collateral in order to borrow

19720
19:59:43.719 --> 19:59:46.719
assets, we still need that
collateral down. So basically,

19721
19:59:46.719 --> 19:59:49.719
if you borrowed more money than
you've put up, other users can

19722
19:59:49.719 --> 19:59:52.719
can take the money that you've
put up in return for them paying

19723
19:59:52.719 --> 19:59:55.719
for your loans. So we obviously
don't want this to happen. And

19724
19:59:56.719 --> 19:59:58.719
the audit protocol
programmatically doesn't want to

19725
19:59:58.719 --> 20:00:01.719
have not enough money to do
this. So they incentivize users

19726
20:00:01.719 --> 20:00:04.719
to liquidate, in case of these
failures is the protocols come

19727
20:00:04.719 --> 20:00:08.719
with this thing called a health
factor, which if this health

19728
20:00:08.719 --> 20:00:11.719
factor is below one, you go
ahead and you get liquidated,

19729
20:00:11.719 --> 20:00:15.719
the actual function to liquidate
somebody is called liquidation

19730
20:00:15.719 --> 20:00:18.719
call. So you can actually build
a bot and you can liquidate

19731
20:00:18.719 --> 20:00:21.719
users who go insolvent and you
can make a fee, you can make a

19732
20:00:21.719 --> 20:00:25.719
reward for actually doing this.
These protocols need to stay

19733
20:00:25.719 --> 20:00:28.719
solvent, they need to have
enough money to lend out. And

19734
20:00:28.719 --> 20:00:30.719
they programmatically enforced
this, which is why it's so

19735
20:00:30.719 --> 20:00:33.719
great. You can learn more about
liquidations in the liquidation

19736
20:00:33.719 --> 20:00:37.719
documentation. So this get us
account data will tell us how

19737
20:00:37.719 --> 20:00:40.719
much we have collateral, how
much we have in debt, and how

19738
20:00:40.719 --> 20:00:43.719
much we have available to borrow
based on how much collateral we

19739
20:00:43.719 --> 20:00:46.719
have. We can see the current
liquidation threshold we can see

19740
20:00:46.719 --> 20:00:49.719
the loan to value and then we
can see our health factor, which

19741
20:00:49.719 --> 20:00:53.719
is obviously really important.
If our health factor ever falls

19742
20:00:53.719 --> 20:00:56.719
below one, we get liquidated. So
we never want this hell factor

19743
20:00:56.719 --> 20:00:59.719
to fall below one when we're
borrowing assets. So let's

19744
20:00:59.719 --> 20:01:01.719
create a function that can grab
that first. So let's create a

19745
20:01:01.719 --> 20:01:08.719
new function called async.
Function get it borrow user

19746
20:01:08.719 --> 20:01:12.720
data, and we'll pass in the
lending pool contract, we'll

19747
20:01:12.720 --> 20:01:15.720
pass in the lending pool
contract and the account that we

19748
20:01:15.720 --> 20:01:18.720
want to get the data for. So we
can say const. And actually, we

19749
20:01:18.720 --> 20:01:21.720
can pull out just the values
that we want, we could pull out

19750
20:01:21.720 --> 20:01:24.720
the total collateral eath total
debt eath and the available to

19751
20:01:24.720 --> 20:01:31.720
borrow. Let's just pull out the
total collateral eath the total

19752
20:01:31.720 --> 20:01:41.720
debt if and the available,
borrows. So this equals await,

19753
20:01:41.720 --> 20:01:49.720
lending pool dot get user
account data of account. And now

19754
20:01:49.720 --> 20:01:54.720
we'll even just kind of logged
us out we'll say console dot log

19755
20:01:54.720 --> 20:02:04.720
you have total collateral eath
worth of eath the positive

19756
20:02:04.720 --> 20:02:19.720
console. Log you have total debt
eath worth of eath borrowed and

19757
20:02:19.720 --> 20:02:24.720
then console dot log you can
borrow

19758
20:02:24.720 --> 20:02:32.720
available borrows eath worth of
eath. And then we'll just return

19759
20:02:32.720 --> 20:02:36.720
available to borrow will turn
available borrows eath. And

19760
20:02:36.720 --> 20:02:39.720
we'll return or total debt, we
don't really need to return

19761
20:02:39.720 --> 20:02:41.720
total collateral we could if we
want we really just want to

19762
20:02:41.720 --> 20:02:46.720
print it out here. So now back
in our function, we can do in

19763
20:02:46.720 --> 20:02:50.720
our main function, we can run
let, I'm going to do that

19764
20:02:50.720 --> 20:02:53.721
because we're going to be
calling this a few times

19765
20:02:53.721 --> 20:03:00.721
available borrows eath. And
total debt eath

19766
20:03:00.721 --> 20:03:05.721
equals await, get borrow user
data of lending pool and

19767
20:03:05.721 --> 20:03:08.721
Deployer. And if we run this,
we'll see how much we can

19768
20:03:08.721 --> 20:03:14.721
actually borrow yarn hard hat or
just h h run scripts on a

19769
20:03:14.721 --> 20:03:18.721
borrowed.js and work on our
forked blockchain here. And

19770
20:03:18.721 --> 20:03:20.721
remember, it is going to be a
little bit slower. And this is

19771
20:03:20.721 --> 20:03:23.721
kind of one of the disadvantages
too because it does have to make

19772
20:03:23.721 --> 20:03:26.721
API calls whenever we want to
interact with these chains. And

19773
20:03:26.721 --> 20:03:29.721
then we got total collateral
eath is not defined. And that's

19774
20:03:29.721 --> 20:03:34.721
because I spelt total wrong. So
let's spell total correctly. And

19775
20:03:34.721 --> 20:03:38.721
we'll run this again. But okay,
great. So you have this month's

19776
20:03:38.721 --> 20:03:42.721
worth of eath deposited, you
have zero worth of eath borrowed

19777
20:03:42.721 --> 20:03:44.721
because we haven't borrowed
anything, and you can borrow

19778
20:03:44.721 --> 20:03:47.721
this much worth of eath.
Remember, the amount that we can

19779
20:03:47.721 --> 20:03:50.721
borrow is always going to be
less than the total amount that

19780
20:03:50.721 --> 20:03:54.721
we have as deposited. That's why
we see this lower number here.

19781
20:03:54.721 --> 20:03:57.721
So cool. So that's how much we
can borrow. Let's use that to go

19782
20:03:57.721 --> 20:04:01.721
and borrow some time. So we have
this total amount we can borrow

19783
20:04:01.721 --> 20:04:04.721
an eighth and we're gonna get to
borrow time. I promise we're

19784
20:04:04.721 --> 20:04:07.721
gonna get to borrow time, but we
need to figure out What's the

19785
20:04:07.721 --> 20:04:10.721
conversion rate of diets? We're
gonna get how much we can borrow

19786
20:04:10.721 --> 20:04:14.721
in eath. But we want to borrow
dye. So how much of dye can we

19787
20:04:14.721 --> 20:04:17.721
borrow based off of the value of
eath? And to do that, we're

19788
20:04:17.721 --> 20:04:20.721
gonna have to get the dye price.
And how are we going to do that?

19789
20:04:20.721 --> 20:04:22.721
Well, you guessed it, we're
going to use chain link price

19790
20:04:22.721 --> 20:04:25.721
feeds. If you look in the AVI
documentation, you can find

19791
20:04:25.721 --> 20:04:28.721
price Oracle, which is a
contract that you could actually

19792
20:04:28.721 --> 20:04:32.722
use right directly from Avi. But
the first thing it does is check

19793
20:04:32.722 --> 20:04:34.722
from a chain link aggregator,
which we already know how to do.

19794
20:04:34.722 --> 20:04:37.722
So we're gonna go ahead and just
call directly from the chain

19795
20:04:37.722 --> 20:04:40.722
link aggregator. So let's create
a new function function, we'll

19796
20:04:40.722 --> 20:04:44.722
call it get dye price is first
we're going to need to get that

19797
20:04:44.722 --> 20:04:48.722
interface, same thing. So you
can either go right to Hardhead

19798
20:04:48.722 --> 20:04:52.722
defy and just grab the interface
right from here, we could swap

19799
20:04:52.722 --> 20:04:56.722
this out with just an import
from chainlink NPM, as well. But

19800
20:04:56.722 --> 20:04:59.722
I'm just going to go ahead and
copy paste a new file, this is

19801
20:04:59.722 --> 20:05:04.722
going to be the Ag reg gate, Tor
v3 interface. Dot saw that we've

19802
20:05:04.722 --> 20:05:07.722
worked with so many times. Now
that we have this interface,

19803
20:05:07.722 --> 20:05:10.722
this will compile, we're
obviously looking for latest

19804
20:05:10.722 --> 20:05:13.722
round data, which will give us
this answer here, which is going

19805
20:05:13.722 --> 20:05:15.722
to be the price. So let's go
ahead and grab that. So we'll

19806
20:05:15.722 --> 20:05:21.722
say const di eath price feed
equals await ethers dot get

19807
20:05:21.722 --> 20:05:27.722
contract at and we'll use the
air, Greg a Tor v3 interface

19808
20:05:27.722 --> 20:05:30.722
will get the dye eath price feed
right from the chain link Docs.

19809
20:05:30.722 --> 20:05:35.722
So we go to docs dot chain dot
link UVM chains will go to

19810
20:05:35.722 --> 20:05:40.722
contract addresses on Aetherium.
Or look for di eath on Main net.

19811
20:05:40.722 --> 20:05:43.722
And we see di eath is right
here. So we'll grab this and

19812
20:05:43.722 --> 20:05:46.722
again, we're just hard coding it
in the GitHub repo associated

19813
20:05:46.722 --> 20:05:50.722
with it. With this, we put it in
a little config file, but we can

19814
20:05:50.722 --> 20:05:53.722
just go ahead and hard coded in.
And for this one, we don't need

19815
20:05:53.722 --> 20:05:56.722
to connect this to the deployer
account. Since we're not going

19816
20:05:56.722 --> 20:05:59.722
to be sending any transactions,
we're just going to be reading

19817
20:05:59.722 --> 20:06:02.722
from this contract, right. So
reading don't need a signer

19818
20:06:02.722 --> 20:06:08.722
sending me to signer. Now we can
say const price equals a weight

19819
20:06:08.722 --> 20:06:15.723
dye eath price feed dot latest
round data. Now latest round

19820
20:06:15.723 --> 20:06:19.723
data, as we know is going to
return us this huge thing. And

19821
20:06:19.723 --> 20:06:23.723
we only want the answer at the
first index. So another way we

19822
20:06:23.723 --> 20:06:25.723
could do this, we could just
wrap this whole thing up. And

19823
20:06:25.723 --> 20:06:28.723
then once this returns, we're
gonna say okay, just grab that

19824
20:06:28.723 --> 20:06:31.723
first index here, which will be
that price. And then we could do

19825
20:06:31.723 --> 20:06:40.723
a little console dot log, the dy
eath. Price is in price dot two,

19826
20:06:40.723 --> 20:06:43.723
like that, and then return
price. So we can go ahead and

19827
20:06:43.723 --> 20:06:46.723
run this as well test this out,
just by hitting up and then

19828
20:06:46.723 --> 20:06:51.723
enter. Depositing we deposited
this is how much we can deposit.

19829
20:06:51.723 --> 20:06:54.723
Nothing Oh, and I forgot to call
it oh, excuse me, let's go up.

19830
20:06:54.723 --> 20:07:01.723
This, let's say const dye price
equals await get dye price. And

19831
20:07:01.723 --> 20:07:05.723
tada. The dye youth price is
this big number, which of course

19832
20:07:05.723 --> 20:07:09.723
we know is going to be $3,289
which is which of course is

19833
20:07:09.723 --> 20:07:15.723
gonna be 3289 di per eath. Now
that we have the dye price, we

19834
20:07:15.723 --> 20:07:18.723
can figure out how much dye we
want to borrow. So great, we

19835
20:07:18.723 --> 20:07:21.723
have the price. Now let's figure
out the amount that we can

19836
20:07:21.723 --> 20:07:25.723
borrow in dye, we have the
amount we can borrow eath, we

19837
20:07:25.723 --> 20:07:29.723
need to convert it to die. So
we'll say const amount die to

19838
20:07:29.723 --> 20:07:36.723
borrow equals available, be the
available borrows in eath.to

19839
20:07:36.723 --> 20:07:41.723
string. And then in JavaScript,
we can do this.to string but

19840
20:07:41.723 --> 20:07:47.723
still do math. So times 0.95
times and then we'll do the

19841
20:07:47.723 --> 20:07:53.724
reciprocal of that die. So one
divided by die price.to number.

19842
20:07:53.724 --> 20:07:58.724
So this will give us the amount
of die that we can borrow. And

19843
20:07:58.724 --> 20:08:01.724
then we'll want to get this in
way. So if we print this out

19844
20:08:01.724 --> 20:08:08.724
right now, console dot log, you
can borrow.

19845
20:08:08.724 --> 20:08:14.724
Run this now, you can borrow
amount die to borrow. Not in way

19846
20:08:14.724 --> 20:08:17.724
units, which we need in way
units, but you can borrow 48

19847
20:08:17.724 --> 20:08:21.724
Die, which based off the price
looks about right. So to get the

19848
20:08:21.724 --> 20:08:27.724
correct units, we'll say const
amount, di to borrow way. That's

19849
20:08:27.724 --> 20:08:33.724
going to equal ethers dot utils
dot parse ether, MT di to

19850
20:08:33.724 --> 20:08:37.724
borrow.to string. This is just
purely the amount of dye to

19851
20:08:37.724 --> 20:08:42.724
borrow right so we get 48.79
die. But again, we want that in

19852
20:08:42.724 --> 20:08:47.724
way the die token has 18 decimal
places similar to Aetherium. So

19853
20:08:47.724 --> 20:08:50.724
we need that amount in way and
then we can go ahead and start

19854
20:08:50.724 --> 20:08:53.724
actually borrowing now. So we'll
create a new function called

19855
20:08:53.724 --> 20:08:58.724
borrow die async function,
borrow die will take the die

19856
20:08:58.724 --> 20:09:05.724
address. Take the lending pool,
take the amount die to borrow

19857
20:09:05.724 --> 20:09:09.724
and weigh in Then of course,
we'll take the account. And all

19858
20:09:09.724 --> 20:09:13.724
we'll do is we'll do const.
Borrow TX is going to be a

19859
20:09:13.724 --> 20:09:20.724
weight, lending pool dot borrow,
die address, amount die to

19860
20:09:20.724 --> 20:09:25.724
borrow. And again, we can go
right to the documentation, if

19861
20:09:25.724 --> 20:09:28.724
we want, it takes the address of
the asset, the amount, we want

19862
20:09:28.724 --> 20:09:30.724
to borrow the interest rate
mode, which is going to be

19863
20:09:30.724 --> 20:09:34.725
variable or stable, the referral
code and then address on behalf

19864
20:09:34.725 --> 20:09:37.725
of, we're going to say one for
the interest rate mode, where

19865
20:09:37.725 --> 20:09:41.725
one is going to be stable. And
then we're going to do zero or

19866
20:09:41.725 --> 20:09:44.725
this referral code because
that's debunked now, and then

19867
20:09:44.725 --> 20:09:49.725
we'll do a count, then we'll do
a wait, borrow TX dot Wait, wait

19868
20:09:49.725 --> 20:09:56.725
one transaction, and then we'll
do console dot log you've

19869
20:09:56.725 --> 20:10:00.725
borrowed. Well, and that's it.
So we now have this borrowed I

19870
20:10:00.725 --> 20:10:04.725
function. So back up in our main
function, right, now, we can

19871
20:10:04.725 --> 20:10:09.725
finally do the borrow time. So
we'll do a wait, borrow die. And

19872
20:10:09.725 --> 20:10:12.725
we'll pass those parameters in
here. So we're going to do

19873
20:10:12.725 --> 20:10:16.725
const, die token address, equals
and we're just going to hard

19874
20:10:16.725 --> 20:10:21.725
code this from main net. So we
can look up die token address,

19875
20:10:21.725 --> 20:10:24.725
main net, we'll grab this
address here, this looks like

19876
20:10:24.725 --> 20:10:27.725
this is indeed the DI token, we
check right on the object get

19877
20:10:27.725 --> 20:10:30.725
up, we could check right on the
ABI of actual code, since we're

19878
20:10:30.725 --> 20:10:32.725
just testing, we're just gonna
go ahead and grab from ether

19879
20:10:32.725 --> 20:10:36.725
scan here. So for borrow dye,
we're gonna need the dye token

19880
20:10:36.725 --> 20:10:41.725
address, we're gonna need the
lending pool contract the amount

19881
20:10:41.725 --> 20:10:46.725
of dye to borrow in way, and
then our Deployer. And then

19882
20:10:46.725 --> 20:10:51.725
we'll await borrow dye. And then
we will run this get bar user

19883
20:10:51.725 --> 20:10:55.725
data again, just print out the
information about where we are

19884
20:10:55.725 --> 20:10:58.725
after we do that. So when we can
run this, again, we should see

19885
20:10:58.725 --> 20:11:02.725
the amount that we have
borrowed, updated, our first

19886
20:11:02.725 --> 20:11:05.725
call to that function is gonna
say, Hey, you have this much eat

19887
20:11:05.725 --> 20:11:08.725
the positive Do you have nothing
borrowed, you can borrow this

19888
20:11:08.725 --> 20:11:11.725
much eath, we get the price, we
get how much we borrowed, we

19889
20:11:11.725 --> 20:11:15.726
borrow. And now it says you have
this much where the eath

19890
20:11:15.726 --> 20:11:18.726
deposited and you have this much
worth of eath borrowed and you

19891
20:11:18.726 --> 20:11:22.726
can borrow this much eat. So we
actually now have bought a bunch

19892
20:11:23.726 --> 20:11:26.726
of this dye actually borrowed.
And the reason we're doing times

19893
20:11:26.726 --> 20:11:29.726
zero point 95, we don't want to
hit that cap of the maximum

19894
20:11:29.726 --> 20:11:33.726
amount that we can borrow. So
we're saying hey, let's get 95%

19895
20:11:33.726 --> 20:11:35.726
of the amount that we actually
can borrow. So we're not going

19896
20:11:35.726 --> 20:11:39.726
to borrow everything, we're just
gonna borrow 95%. And you can

19897
20:11:39.726 --> 20:11:41.726
see that the amount of eath we
have deposited is actually

19898
20:11:41.726 --> 20:11:46.726
higher. This is because we're
actually gaining interest just

19899
20:11:46.726 --> 20:11:50.726
by having this eath deposited.
And now that we have some dye

19900
20:11:50.726 --> 20:11:54.726
borrowed, we borrowed 48 dye,
which is equivalent to this much

19901
20:11:54.726 --> 20:11:56.726
Aetherium. And then we still
have a little bit more we can

19902
20:11:56.726 --> 20:12:03.726
borrow because we only borrowed
95%, which is great.

19903
20:12:03.726 --> 20:12:07.726
Awesome, we've taken out a
borrow programmatically, let's

19904
20:12:07.726 --> 20:12:10.726
repay at least some of it here.
So we're gonna have to create a

19905
20:12:10.726 --> 20:12:15.726
new function that's going to use
the repay function in the

19906
20:12:15.726 --> 20:12:19.726
contract. So we're gonna do
async function repay, and this

19907
20:12:19.726 --> 20:12:24.726
is going to take the amount that
we want to repay the dye address

19908
20:12:24.726 --> 20:12:27.726
that we're going to repay the
lending pool and then the

19909
20:12:27.726 --> 20:12:32.726
account now to repay once again,
we're going to have to approve

19910
20:12:32.726 --> 20:12:36.726
sending our dye back to Ave So
in here, the first thing we need

19911
20:12:36.726 --> 20:12:43.726
to do is we actually need to
call wait prove ERC 20 with the

19912
20:12:43.726 --> 20:12:49.726
dye address, lending pool dot
address, mount and then

19913
20:12:49.726 --> 20:12:53.727
accounts, right because approve
ERC 20. That's the input

19914
20:12:53.727 --> 20:12:56.727
parameters it takes, and we need
to approve sending the dye back

19915
20:12:56.727 --> 20:12:59.727
to the contract. So we borrowed
it, and we're gonna send it

19916
20:12:59.727 --> 20:13:02.727
back. Now we're actually going
to send it back. So let's say

19917
20:13:02.727 --> 20:13:08.727
const, repay TX equals await,
lending, cool that repay the

19918
20:13:08.727 --> 20:13:14.727
address, amount, one account.
And then we'll say await repay

19919
20:13:14.727 --> 20:13:21.727
TX dot Wait, that will do
console dot log repaid up in our

19920
20:13:21.727 --> 20:13:25.727
main function, we're going to do
a weight repay, and we're going

19921
20:13:25.727 --> 20:13:30.727
to give it the amount dye to
borrow in way. We're gonna give

19922
20:13:30.727 --> 20:13:34.727
it the dye token address, give
it lending pool, and then we'll

19923
20:13:34.727 --> 20:13:38.727
give it deployer get you borrow
user data one more time just so

19924
20:13:38.727 --> 20:13:41.727
we can print out the final
amounts. Now, you'll notice

19925
20:13:41.727 --> 20:13:45.727
something though, we're going to
give back all of the dye that we

19926
20:13:45.727 --> 20:13:48.727
borrowed. However, we're still
going to have a dye balance,

19927
20:13:48.727 --> 20:13:51.727
you'll see that when I run this
that we're still have a little

19928
20:13:51.727 --> 20:13:54.727
bit of Aetherium borrowed,
basically, we'll still have a

19929
20:13:54.727 --> 20:13:56.727
dye balance because we'll still
have a little bit of die borrow

19930
20:13:56.727 --> 20:14:01.727
and try to figure out why before
I answer it actually. So we have

19931
20:14:01.727 --> 20:14:05.727
this tiny, tiny tiny amount of
eath borrowed here and we have a

19932
20:14:05.727 --> 20:14:08.727
much larger amount of eath
deposited so Why do we still

19933
20:14:08.727 --> 20:14:12.727
have this tiny, tiny amount of
eath borrowed? Well, the reason

19934
20:14:12.727 --> 20:14:16.727
is because as we borrow dye, we
actually accrued interest. So we

19935
20:14:16.727 --> 20:14:20.727
still owe dye back. Now what we
can do is we can do something

19936
20:14:20.727 --> 20:14:25.727
like uniswap, to actually swap
our Aetherium, for dye to repay

19937
20:14:25.727 --> 20:14:27.727
the rest of our debt here. And
that's how we could actually

19938
20:14:27.727 --> 20:14:31.727
finish repaying all the debt is
to get a little bit more dye to

19939
20:14:31.727 --> 20:14:34.728
pay off that interest that we
had accrued. And if you want,

19940
20:14:34.728 --> 20:14:37.728
you can go back and you can do
the exact same thing we did here

19941
20:14:37.728 --> 20:14:41.728
to grab the uniswap code, place
it in here to programmatically

19942
20:14:41.728 --> 20:14:45.728
repay your debt as well. But at
this point, you have just gone

19943
20:14:45.728 --> 20:14:48.728
through the entire lifecycle
here. And that is absolutely

19944
20:14:48.728 --> 20:14:53.728
massive, huge congratulations.
You've just deposited borrowed

19945
20:14:53.728 --> 20:15:00.728
and repaid tokens from the AVI
protocol. Now I'm going to go

19946
20:15:00.728 --> 20:15:03.728
briefly show you what some of
these transactions are going to

19947
20:15:03.728 --> 20:15:08.728
look like on an actual test net,
on an ether scan, you'll see

19948
20:15:08.728 --> 20:15:12.728
that when we deposit our
collateral, we actually get back

19949
20:15:12.728 --> 20:15:16.728
what's called an A token, or an
interest bearing token, these

19950
20:15:16.728 --> 20:15:20.728
tokens keep track of how much
collateral or in our case how

19951
20:15:20.728 --> 20:15:25.728
much web token we have deposited
in the AVI protocol. And when we

19952
20:15:25.728 --> 20:15:29.728
want to withdraw our wealth
back, we burn these eight

19953
20:15:29.728 --> 20:15:32.728
tokens, we remove these eight
tokens, you can see that our

19954
20:15:32.728 --> 20:15:35.728
first transaction is going to be
deposit and I wanted to show you

19955
20:15:35.728 --> 20:15:37.728
what it looks like when you
actually deposit one of these

19956
20:15:37.728 --> 20:15:40.728
tokens, this transaction
associated with this lending

19957
20:15:40.728 --> 20:15:43.728
pool, that deposit right here,
if you look at tokens transfer

19958
20:15:43.728 --> 20:15:47.728
down here, you can see we
actually we deposited, you can

19959
20:15:47.728 --> 20:15:52.728
see that we actually sent rapt
ether to the ARB a contract. Now

19960
20:15:52.728 --> 20:15:56.728
you'll also see this a weath
stuff here. So what is this a

19961
20:15:56.728 --> 20:16:00.728
with stuff. So to keep track of
how much you've actually

19962
20:16:00.728 --> 20:16:05.728
deposited into Ave, Ave will
give you your own a wealth token

19963
20:16:05.728 --> 20:16:09.728
or a token to keep track. And
this is this interest bearing

19964
20:16:09.728 --> 20:16:11.728
token, you actually can see up
here a little bit of interest

19965
20:16:11.728 --> 20:16:15.729
already for actually depositing
these tokens into the protocol.

19966
20:16:15.729 --> 20:16:19.729
And it's this token, that will
keep going up, the more people

19967
20:16:19.729 --> 20:16:21.729
borrow and the more people use
the protocol. So you can

19968
20:16:21.729 --> 20:16:24.729
actually grab this token
address, interest bearing token

19969
20:16:24.729 --> 20:16:29.729
this a token, I can import it
into my meta mask. And I can see

19970
20:16:29.729 --> 20:16:32.729
that I have 0.1, which
represents my initial deposit

19971
20:16:32.729 --> 20:16:39.729
00517 dot that dot A with and if
you keep this up long enough,

19972
20:16:39.729 --> 20:16:44.729
this number will slowly go up as
you get more and more. Because

19973
20:16:44.729 --> 20:16:48.729
the interest keep out and you
can see just went went up right

19974
20:16:48.729 --> 20:16:51.729
there, the interest will keep
changing and keep going up.

19975
20:16:51.729 --> 20:16:53.729
Obviously, we have so little
deposited that the interest

19976
20:16:53.729 --> 20:16:56.729
isn't gonna go up very quickly,
but it will go up, the more

19977
20:16:56.729 --> 20:16:59.729
people use the protocol. And
since I'm using a test net, the

19978
20:16:59.729 --> 20:17:03.729
actual usage of the protocol
isn't very high, but you get the

19979
20:17:03.729 --> 20:17:06.729
picture.

19980
20:17:06.729 --> 20:17:09.729
Awesome, you've done phenomenal
to get this far. Let's do a

19981
20:17:09.729 --> 20:17:12.729
quick recap of everything that
we've learned. And then we'll

19982
20:17:12.729 --> 20:17:16.729
head on to the next section. So
first, we learned about the web

19983
20:17:16.729 --> 20:17:20.729
token or the wrapped Aetherium
token, it's a way to tokenize

19984
20:17:20.729 --> 20:17:24.729
our Aetherium or layer one
blockchain native token. Then we

19985
20:17:24.729 --> 20:17:27.729
learned a little bit about the
AVI protocol, and how it's this

19986
20:17:27.729 --> 20:17:30.729
defy primitive for borrowing and
lending assets. And we can

19987
20:17:30.729 --> 20:17:34.729
actually gain interest by
depositing our tokens and our

19988
20:17:34.729 --> 20:17:37.729
assets into Ave we learned a
little bit of also about

19989
20:17:37.729 --> 20:17:40.729
uniswap, which is another
incredibly important defy

19990
20:17:40.729 --> 20:17:43.729
protocol, which allows us to
swap tokens between each other

19991
20:17:43.729 --> 20:17:47.729
in the decentralized context,
then we learned that we can

19992
20:17:47.729 --> 20:17:51.729
actually deposit some of our
tokens into the AVI protocol,

19993
20:17:51.729 --> 20:17:53.730
which is a decentralized
borrowing and lending platform

19994
20:17:53.730 --> 20:17:57.730
and similar to a bank will
actually gain interest on our

19995
20:17:57.730 --> 20:18:00.730
deposited tokens. But first, we
have to approve them. Because

19996
20:18:00.730 --> 20:18:04.730
anytime you want a contract to
interact with your tokens, you

19997
20:18:04.730 --> 20:18:07.730
need to approve the contract to
do so. And then we go ahead and

19998
20:18:07.730 --> 20:18:12.730
deposit once we deposited we got
the dye price. And then we

19999
20:18:12.730 --> 20:18:16.730
learned that we can actually
borrow dye we can borrow an

20000
20:18:16.730 --> 20:18:19.730
asset based off of how much
collateral we put down. And then

20001
20:18:19.730 --> 20:18:22.730
we learned how to repay it back.
We learned about forking a

20002
20:18:22.730 --> 20:18:26.730
blockchain as opposed to using
our own main blockchain. Another

20003
20:18:26.730 --> 20:18:29.730
thing to know if you are using
an RPC URL like something from

20004
20:18:29.730 --> 20:18:32.730
alchemy so awesome you've
learned a ton about defy now

20005
20:18:32.730 --> 20:18:36.730
defi is an absolutely massive
powerhouse when it comes to the

20006
20:18:36.730 --> 20:18:39.730
blockchain. And it is one of the
most important things

20007
20:18:39.730 --> 20:18:42.730
blockchains can do. If you want
to learn more about defy and

20008
20:18:42.730 --> 20:18:46.730
read more on Defy. I've got some
more links in the GitHub here so

20009
20:18:46.730 --> 20:18:48.730
that you can learn more about
defy and one of them in

20010
20:18:48.730 --> 20:18:53.730
particular that I want to show
you is this one called speed run

20011
20:18:53.730 --> 20:18:56.730
Etherium. Not only does it give
you a ton of defy examples, but

20012
20:18:56.730 --> 20:18:59.730
it gives you a whole bunch of
other examples as well. And this

20013
20:18:59.730 --> 20:19:01.730
will be a good test of
everything that you've learned

20014
20:19:01.730 --> 20:19:04.730
after you pass this course. Or
even right now if you want to or

20015
20:19:04.730 --> 20:19:08.730
whenever you want and to talk
about it a little bit more, we

20016
20:19:08.730 --> 20:19:10.730
actually have Austin Griffiths
here to talk a little bit more

20017
20:19:10.730 --> 20:19:13.730
about speed run Aetherium
himself, I'll pass it over to

20018
20:19:13.730 --> 20:19:16.730
Austin.

20019
20:19:16.730 --> 20:19:18.730
Hey, what's up, I'm Austin
Griffith, I want to show you

20020
20:19:18.730 --> 20:19:21.730
speed run Aetherium. speed run
Aetherium is a great way to get

20021
20:19:21.730 --> 20:19:25.730
started in Aetherium. If you are
a developer, it's targeted at

20022
20:19:25.730 --> 20:19:28.730
web two developers becoming web
three developers speed run a

20023
20:19:28.730 --> 20:19:32.730
theory. m.com is the website. It
takes you through both getting

20024
20:19:32.730 --> 20:19:35.731
started and kind of getting
getting an idea for the language

20025
20:19:35.731 --> 20:19:39.731
and the syntax. But that's just
the start. Just understanding

20026
20:19:39.731 --> 20:19:42.731
the language is just the start,
you feel like you're you can do

20027
20:19:42.731 --> 20:19:44.731
anything. And you're on the top
of the world when you finally

20028
20:19:44.731 --> 20:19:46.731
get the syntax of solidity
together, and you can jam

20029
20:19:46.731 --> 20:19:49.731
through a smart contract. But
really getting context with the

20030
20:19:49.731 --> 20:19:52.731
space and figuring out what
works and what doesn't, that's a

20031
20:19:52.731 --> 20:19:55.731
whole nother battle. And that's
where speed run aetherium.com

20032
20:19:55.731 --> 20:20:01.731
comes in. So let's speed run the
speed run. First, you will get

20033
20:20:01.731 --> 20:20:05.731
scaffold e down speedrun
Aetherium kind of revolves

20034
20:20:05.731 --> 20:20:09.731
around scaffold eath and uses
scaffold eath as a base, you'll

20035
20:20:09.731 --> 20:20:12.731
want to tinker around with some
ideas within solidity. And let

20036
20:20:12.731 --> 20:20:16.731
me show you what I mean by that.
So with scaffold eath, you have

20037
20:20:16.731 --> 20:20:20.731
a front end and you have your
smart contract. So scaffold eath

20038
20:20:20.731 --> 20:20:24.731
comes with hard hat out of the
box. And you will use the

20039
20:20:24.731 --> 20:20:28.731
combination of hard hat and
react to build a DAP where

20040
20:20:28.731 --> 20:20:32.731
you'll deploy both the smart
contract and the front end. And

20041
20:20:32.731 --> 20:20:37.731
this, this ability to edit your
smart contract and have your

20042
20:20:37.731 --> 20:20:41.731
front end auto adapt to it is
kind of the key to scaffold

20043
20:20:41.731 --> 20:20:44.731
ease. I just added some extra
extra exclamation points. But

20044
20:20:44.731 --> 20:20:46.731
we'll see that show up over
here. Once this contract

20045
20:20:46.731 --> 20:20:50.731
deploys, there we go, there's
that. So just real quick, again,

20046
20:20:50.731 --> 20:20:55.731
if I create like a un 256 public
counter, and we set that equal

20047
20:20:55.731 --> 20:20:59.731
to five, and then I build a
function called increment,

20048
20:20:59.731 --> 20:21:04.731
that's public that does counter
public, there we go, that does

20049
20:21:04.731 --> 20:21:07.731
counter plus, plus, you can
imagine what's going to happen

20050
20:21:07.731 --> 20:21:11.731
here. So you, you edit a little
bit of solidity, you deploy your

20051
20:21:11.731 --> 20:21:14.732
contract, and then your front
end auto adjust to that. And it

20052
20:21:14.732 --> 20:21:19.732
gives you the ability as a
developer to call those

20053
20:21:19.732 --> 20:21:22.732
functions tinker with your smart
contract to play around, you can

20054
20:21:22.732 --> 20:21:27.732
even have a console log in
there, where it you know, sets

20055
20:21:27.732 --> 20:21:32.732
says the count now is there we
go something like this. And

20056
20:21:32.732 --> 20:21:35.732
let's go ahead and deploy that.
Notice I'm doing these quick

20057
20:21:35.732 --> 20:21:38.732
iterations, I'm making small
changes in solidity, and I'm

20058
20:21:38.732 --> 20:21:41.732
seeing those changes show up in
the front end. And I'm tinkering

20059
20:21:41.732 --> 20:21:45.732
with those in the front end and
testing my assumptions. Here, if

20060
20:21:45.732 --> 20:21:50.732
we go look at our hard hat node,
when I make this increment call,

20061
20:21:50.732 --> 20:21:53.732
we should see that nice console
log there, you know, this

20062
20:21:53.732 --> 20:21:58.732
address, set the count to eight,
right? Very, very cool. So this

20063
20:21:58.732 --> 20:22:01.732
is scaffold eath. This is what
speed run Aetherium is built on

20064
20:22:01.732 --> 20:22:04.732
top of, you'll get in here,
you'll edit your smart contract,

20065
20:22:04.732 --> 20:22:06.732
then you'll edit your front end,
you'll point your front end at

20066
20:22:06.732 --> 20:22:09.732
some particular network, you'll
deploy your smart contract,

20067
20:22:09.732 --> 20:22:12.732
you'll deploy your app, it just
gives you the ability to have a

20068
20:22:12.732 --> 20:22:16.732
front end along with your smart
contract. And you'll have that

20069
20:22:16.732 --> 20:22:19.732
as you're building your smart,
smart contract. So to have this

20070
20:22:19.732 --> 20:22:22.732
front end, to tinker with your
smart contract is going to help

20071
20:22:22.732 --> 20:22:25.732
you kind of figure out how you
want to write your solidity,

20072
20:22:25.732 --> 20:22:27.732
like, is this going to be a
mapping? Is this going to be an

20073
20:22:27.732 --> 20:22:31.732
array? How am I going to track
this struct, you can kind of do

20074
20:22:31.732 --> 20:22:34.732
this in an iterative process by
just throwing it in here into

20075
20:22:34.732 --> 20:22:36.732
your smart contract and
tinkering with it on the front

20076
20:22:36.732 --> 20:22:40.732
end and trying it out and seeing
what you need to build. So

20077
20:22:40.732 --> 20:22:43.732
that's scaffold eath. And that's
the base that you'll need to get

20078
20:22:43.732 --> 20:22:47.732
started with speed run Ethereum.
Once you've you're able to have

20079
20:22:47.732 --> 20:22:49.732
this all installed, you'll
you'll have your kind of react

20080
20:22:49.732 --> 20:22:52.732
front end here with yarn start,
you'll have yarn chain, which

20081
20:22:52.732 --> 20:22:54.733
will run your your hard hat
node, then you'll do yarn

20082
20:22:54.733 --> 20:22:59.733
deploy. Once you have that setup
locally, you're ready to go with

20083
20:22:59.733 --> 20:23:02.733
speed run Aetherium. And you can
also do this right here and

20084
20:23:02.733 --> 20:23:06.733
challenge zero. So challenge
zero, gotta go zero index,

20085
20:23:06.733 --> 20:23:09.733
right, we got to be nerdy
challenge zero sets you up with

20086
20:23:09.733 --> 20:23:13.733
just getting the environment
setup, you'll you'll quest on

20087
20:23:13.733 --> 20:23:17.733
building a simple NFT example.
It's going to come with an NFT

20088
20:23:17.733 --> 20:23:20.733
smart contract. And it's going
to come with an NFT front end a

20089
20:23:20.733 --> 20:23:24.733
little kind of like minting
view, it'll come with all of

20090
20:23:24.733 --> 20:23:27.733
this stuff to do that. And it'll
walk you through basically

20091
20:23:27.733 --> 20:23:29.733
challenge the row is going to
hold your hand, it's going to

20092
20:23:29.733 --> 20:23:32.733
take you through every step
you'll have to get get you have

20093
20:23:32.733 --> 20:23:37.733
to have a certain version of
node E, L some some correct

20094
20:23:37.733 --> 20:23:40.733
range of node and yarn
installed. Watch out yarn has an

20095
20:23:40.733 --> 20:23:44.733
executable on Linux, make sure
you have the yarn, the package

20096
20:23:44.733 --> 20:23:48.733
manager. But after you have get
your node and yarn, you'll run

20097
20:23:48.733 --> 20:23:53.733
through cloning down each
challenge. You'll do an install,

20098
20:23:53.733 --> 20:23:55.733
you'll fire up the chain and
you'll fire up your front end.

20099
20:23:55.733 --> 20:23:58.733
And you'll have a working app
that lets you interface with

20100
20:23:58.733 --> 20:24:02.733
your NFT smart contract. You'll
go through here and you'll learn

20101
20:24:02.733 --> 20:24:06.733
about wallets. Then you'll start
minting NF Ts and you'll send

20102
20:24:06.733 --> 20:24:09.733
those NF T's are Round. And
that's challenge zero, it's just

20103
20:24:09.733 --> 20:24:14.733
getting you started. Here even
in challenge zero, you'll deploy

20104
20:24:14.733 --> 20:24:18.733
this NFT to Rinkeby. And you'll
also deploy an app and allow

20105
20:24:18.733 --> 20:24:22.733
your friends to go to your app
and mint in FTS on Rinkeby. So

20106
20:24:22.733 --> 20:24:25.733
that's the first challenge, it
looks like we even like dive

20107
20:24:25.733 --> 20:24:28.733
into open see and play around
with some of those mechanics.

20108
20:24:28.733 --> 20:24:32.733
The second challenge challenge
number one challenge one of

20109
20:24:32.733 --> 20:24:36.734
speed runner theory is like
where it all really starts. This

20110
20:24:36.734 --> 20:24:40.734
really shows off the superpower
of Aetherium. It sets it up. So

20111
20:24:40.734 --> 20:24:44.734
you need to build an app where a
bunch of people that don't

20112
20:24:44.734 --> 20:24:49.734
necessarily trust each other,
can coordinate and stake into a

20113
20:24:49.734 --> 20:24:51.734
smart contract. And this is
like, this is the superpower of

20114
20:24:51.734 --> 20:24:55.734
Aetherium. The ability for you,
the developer to write a few

20115
20:24:55.734 --> 20:25:00.734
simple rules to allow jerks to
coordinate financially, and not

20116
20:25:00.734 --> 20:25:03.734
greet each other and steal each
other's money, right? You're

20117
20:25:03.734 --> 20:25:06.734
we're building these financial
systems, there's, you know, game

20118
20:25:06.734 --> 20:25:09.734
theory and economics and so many
other things going on here. But

20119
20:25:09.734 --> 20:25:12.734
you as the developer, you're
writing simple rules, and you're

20120
20:25:12.734 --> 20:25:15.734
building a system that allows
people to coordinate. So

20121
20:25:15.734 --> 20:25:19.734
challenge one, we'll take you
through how to get set up with

20122
20:25:19.734 --> 20:25:22.734
your steak or docile, smart
contract, you'll install

20123
20:25:22.734 --> 20:25:25.734
everything exactly the same way,
you'll fire everything up. And

20124
20:25:25.734 --> 20:25:27.734
then it's just going to walk you
through the kinds of things that

20125
20:25:27.734 --> 20:25:29.734
you will need in your smart
contract. But you'll have to

20126
20:25:29.734 --> 20:25:33.734
write the solidity yourself. So
this is this is not going to be

20127
20:25:33.734 --> 20:25:38.734
a handheld tutorial, hell thing,
you're going to have to write

20128
20:25:38.734 --> 20:25:41.734
the smart contract yourself. And
there's some guidelines and some

20129
20:25:41.734 --> 20:25:44.734
rails that kind of help you out,
but it's not going to do it for

20130
20:25:44.734 --> 20:25:47.734
you. Okay, so that's, that's
Quest One is or that's

20131
20:25:47.734 --> 20:25:51.734
challenge. One is building a
decentralized staking app. Then

20132
20:25:51.734 --> 20:25:55.734
challenge two is building a
token vendor this so in

20133
20:25:55.734 --> 20:25:58.734
challenge one, you'll learn
things like how to send money

20134
20:25:58.734 --> 20:26:01.734
into a contract, how to have a
contract, keep track of

20135
20:26:01.734 --> 20:26:04.734
mappings. In challenge two,
you're going to learn contract

20136
20:26:04.734 --> 20:26:08.734
to contract interaction, you're
going to learn about ERC 20s,

20137
20:26:08.734 --> 20:26:11.734
you're going to learn about
specifically the approved

20138
20:26:11.734 --> 20:26:14.735
pattern, which is kind of a
jerk, it's, it's hard, it's a

20139
20:26:14.735 --> 20:26:18.735
hard thing to deal with is the
approved pattern, you need to go

20140
20:26:18.735 --> 20:26:21.735
to your token contract and
approve the vendor to take some

20141
20:26:21.735 --> 20:26:23.735
money, then in a second
transaction, you need to go to

20142
20:26:23.735 --> 20:26:27.735
the vendor and have the vendor
grab the money from the token

20143
20:26:27.735 --> 20:26:31.735
contract and do something else.
So that's that's challenge two

20144
20:26:31.735 --> 20:26:35.735
is learning about tokens and
vendors, and is starting to

20145
20:26:35.735 --> 20:26:39.735
really like get you kind of
exposed to the idea of this like

20146
20:26:39.735 --> 20:26:43.735
massive multiplayer game that is
Aetherium. And also kind of like

20147
20:26:43.735 --> 20:26:46.735
how to build these vending
machines that anybody can get

20148
20:26:46.735 --> 20:26:49.735
to, then you'll build a Dex. Now
once you've once you're done

20149
20:26:49.735 --> 20:26:53.735
with 01. And two, you're really
kind of you have a license to

20150
20:26:53.735 --> 20:26:55.735
learn at this point, you're
you're ready to really like go

20151
20:26:55.735 --> 20:26:58.735
do some damage and build some
cool things, maybe go build a

20152
20:26:58.735 --> 20:27:01.735
couple other things, but come
back and come come hit challenge

20153
20:27:01.735 --> 20:27:04.735
three, challenge three is going
to be a little bit more open

20154
20:27:04.735 --> 20:27:08.735
ended, there's going to be a
cohort of other people that are

20155
20:27:08.735 --> 20:27:11.735
also building this. And you have
to get through the first three

20156
20:27:11.735 --> 20:27:14.735
challenges to even get to
challenge three to even get to

20157
20:27:14.735 --> 20:27:17.735
this chat room. But there's a
chat room where other developers

20158
20:27:17.735 --> 20:27:20.735
that are also building their own
decks are all there together,

20159
20:27:20.735 --> 20:27:23.735
and you can kind of learn with
them and chat with them. But

20160
20:27:23.735 --> 20:27:25.735
you're going to build an
exchange. And you're going to

20161
20:27:25.735 --> 20:27:28.735
build an exchange that works in
a smart contract in a

20162
20:27:28.735 --> 20:27:33.735
decentralized way with no
centralized breaking points. And

20163
20:27:33.735 --> 20:27:35.735
what that's going to mean is
you're going to have to have

20164
20:27:35.735 --> 20:27:37.735
reserves of both eath and tokens
and you're gonna have to have a

20165
20:27:37.735 --> 20:27:41.735
pricing function and LP tokens
and all sorts of other things

20166
20:27:41.735 --> 20:27:44.735
that you'll have to learn about
as you get to it. Then challenge

20167
20:27:44.735 --> 20:27:49.735
five is a multi SIG wallet. Such
a fundamental important thing

20168
20:27:49.735 --> 20:27:52.735
about how to store your eath
safely is going to be in a multi

20169
20:27:52.735 --> 20:27:55.736
SIG wallet and how you can have
multiple identities even even

20170
20:27:55.736 --> 20:27:59.736
like the the base of like what a
Dow is, is sort of like starting

20171
20:27:59.736 --> 20:28:02.736
with a multi SIG wallet. And
you'll need to build one of

20172
20:28:02.736 --> 20:28:05.736
those you'll need to understand
call data call data is super

20173
20:28:05.736 --> 20:28:08.736
weird and complex. And
everything's a transaction even

20174
20:28:08.736 --> 20:28:10.736
when you're just poking a
contract. It's a transaction,

20175
20:28:10.736 --> 20:28:15.736
and you have to craft that call
data correctly to say, I would

20176
20:28:15.736 --> 20:28:17.736
like to call this specific
function on this specific

20177
20:28:17.736 --> 20:28:21.736
contract. So that's multisig
wallets and then it kind of ends

20178
20:28:21.736 --> 20:28:23.736
up we've got more challenges in
the pipeline, but it kind of

20179
20:28:23.736 --> 20:28:28.736
ends on build an SVG NFT so much
fun to build an NF t that crafts

20180
20:28:28.736 --> 20:28:32.736
the actual drawing in the smart
contract and renders it. So

20181
20:28:32.736 --> 20:28:36.736
that's the speed run, go speed
run Aetherium checkout scaffold,

20182
20:28:36.736 --> 20:28:39.736
eat start building, build
something awesome on Aetherium.

20183
20:28:39.736 --> 20:28:41.736
hearts, hearts, hearts, go get
them.

20184
20:28:41.736 --> 20:28:45.736
Austin Griffith is one of the
OGS when it comes to helping

20185
20:28:45.736 --> 20:28:48.736
engineers get caught up and up
to speed in the blockchain world

20186
20:28:48.736 --> 20:28:56.736
so massive thank you to Austin
for all he's done so far.

20187
20:28:56.736 --> 20:29:01.736
All right now we're gonna get
into NF T's. Let's do this. Now,

20188
20:29:01.736 --> 20:29:04.736
I've already made a number of
videos on what NF T's are and

20189
20:29:04.736 --> 20:29:06.736
how to start working with NF
T's. So we're going to watch a

20190
20:29:06.736 --> 20:29:10.736
portion of the previous Python
edition of this course where I

20191
20:29:10.736 --> 20:29:13.736
explain and a piece from a high
level and then of course, we're

20192
20:29:13.736 --> 20:29:17.736
gonna get into the ultimate NFT
tutorial. So let's learn about

20193
20:29:17.736 --> 20:29:20.736
NF T's look, NF T's are hot
right now. Nf T's also known as

20194
20:29:20.736 --> 20:29:24.736
ERC 720 ones are a token
standard that was created on the

20195
20:29:24.736 --> 20:29:28.736
Ethereum platform. Nf T stands
for non fungible token is a

20196
20:29:28.736 --> 20:29:32.736
token standard similar to the
ERC 20. Again, ERC 20 is like

20197
20:29:32.736 --> 20:29:36.737
link of a maker, all those
goodies that are found on the

20198
20:29:36.737 --> 20:29:41.737
Etherium chain. An NF T or a non
fungible token is a token that

20199
20:29:41.737 --> 20:29:44.737
is non fungible, this means that
they are starkly unique from

20200
20:29:44.737 --> 20:29:48.737
each other. And one token isn't
interchangeable with any other

20201
20:29:48.737 --> 20:29:51.737
token of its class. A good way
to think about it is $1 is

20202
20:29:51.737 --> 20:29:54.737
interchangeable with any other
dollar $1 is going to have the

20203
20:29:54.737 --> 20:29:57.737
same value of another dollar.
Those are fungible tokens that's

20204
20:29:57.737 --> 20:30:01.737
like ERC 20s one link is always
going to be equivalent to one

20205
20:30:01.737 --> 20:30:05.737
other link, by contrast is going
to be NF T's those of you nerds

20206
20:30:05.737 --> 20:30:08.737
out there, we know like a
Pokemon would be a good example

20207
20:30:08.737 --> 20:30:11.737
of an NFT you're one Pokemon is
going to have different stats,

20208
20:30:11.737 --> 20:30:14.737
different moves, sets, and isn't
interchangeable with any other

20209
20:30:14.737 --> 20:30:16.737
Pokemon, or maybe a more
relatable one. It's like a

20210
20:30:16.737 --> 20:30:20.737
trading card, or unique piece of
art or the like. So that's what

20211
20:30:20.737 --> 20:30:24.737
these NF T's are there non
fungible, non interchangeable

20212
20:30:24.737 --> 20:30:28.737
tokens that for the moment are
best represented or thought

20213
20:30:28.737 --> 20:30:32.737
about as digital pieces of art
that are incorruptible and have

20214
20:30:32.737 --> 20:30:35.737
a permanent history of whose own
them who's deployed them, etc.

20215
20:30:35.737 --> 20:30:39.737
Now, like I said, NF T's are
just a token standard. So you

20216
20:30:39.737 --> 20:30:41.737
can actually make them do much
more than just be art. You can

20217
20:30:41.737 --> 20:30:44.737
give them stats, you can make
them battle, you can do really

20218
20:30:44.737 --> 20:30:47.737
unique things with them, you can
do pretty much whatever you want

20219
20:30:47.737 --> 20:30:49.737
with them. But right now, the
easiest way to think about it,

20220
20:30:49.737 --> 20:30:51.737
and the most popular way to
think about it is by calling

20221
20:30:51.737 --> 20:31:00.737
them ah, ah, ah it's odd, or
some type of collectible or just

20222
20:31:00.737 --> 20:31:03.737
anything that's unique. Now,
they've been getting a ton of

20223
20:31:03.737 --> 20:31:05.737
buzz recently, because we've
been seeing more and more of

20224
20:31:05.737 --> 20:31:09.737
these being sold at insane
prices, like we saw x infinity

20225
20:31:09.737 --> 20:31:13.737
sell nine plots of their land
nine plots of their unique land

20226
20:31:13.737 --> 20:31:18.738
for $1.5 million. We also saw
the original creator of the Nyan

20227
20:31:18.738 --> 20:31:22.738
Cat, you know, this cat

20228
20:31:22.738 --> 20:31:26.738
sold for like 300 eath. So
apparently people really value

20229
20:31:26.738 --> 20:31:29.738
these things. So like I said,
they're just tokens that are

20230
20:31:29.738 --> 20:31:32.738
deployed on a smart contract
platform, and you can view them

20231
20:31:32.738 --> 20:31:35.738
on different NFT platforms like
open sea or wearable. And these

20232
20:31:35.738 --> 20:31:38.738
are the NFT marketplaces that
let people buy and sell them.

20233
20:31:38.738 --> 20:31:41.738
You obviously can do that
without these marketplaces,

20234
20:31:41.738 --> 20:31:44.738
because it's a decentralized but
they're helping give a good user

20235
20:31:44.738 --> 20:31:46.738
interface. Now, like many of you
out there, my initial thought to

20236
20:31:46.738 --> 20:31:49.738
NF T's was okay, this sounds
pretty dumb. But I think that

20237
20:31:49.738 --> 20:31:52.738
that was dumb. I think art does
have a lot of value. And I think

20238
20:31:52.738 --> 20:31:55.738
that artists are not always paid
fairly for what they do. And

20239
20:31:55.738 --> 20:31:57.738
this is actually a huge issue
right now in the modern day

20240
20:31:57.738 --> 20:32:00.738
world where an artist can make
some type of art people just

20241
20:32:00.738 --> 20:32:03.738
copy paste it, you know,
everywhere and, and they never

20242
20:32:03.738 --> 20:32:06.738
get attribution for what they
make. So having a really easy

20243
20:32:06.738 --> 20:32:10.738
decentralized royalty mechanism,
or some type of mechanism where

20244
20:32:10.738 --> 20:32:13.738
these artists can get accurately
comped for what they're doing, I

20245
20:32:13.738 --> 20:32:16.738
think, is really important. I
love music. I love movies, those

20246
20:32:16.738 --> 20:32:19.738
are pieces of art that I digest.
And I really like and I think

20247
20:32:19.738 --> 20:32:22.738
it's fair for them to get comped
appropriately because they are

20248
20:32:22.738 --> 20:32:24.738
providing value to my life. I
think NF T's are a great way to

20249
20:32:24.738 --> 20:32:27.738
solve this issue as kind of
having these decentralized audit

20250
20:32:27.738 --> 20:32:30.738
trails and, and royalty trails
that we can set up and, and see

20251
20:32:30.738 --> 20:32:32.738
really transparently without
having to go through some

20252
20:32:32.738 --> 20:32:35.738
centralized service. So that's
the basic gist of it. Let's talk

20253
20:32:35.738 --> 20:32:40.738
some more about the standards
ERC 721 standard are the NFT

20254
20:32:40.738 --> 20:32:43.738
standard. This is the basis of
it all there is another standard

20255
20:32:43.738 --> 20:32:47.738
that's semi fungible tokens, the
1155 We're not going to talk

20256
20:32:47.738 --> 20:32:49.738
about that here. But you can
check it out the main

20257
20:32:49.738 --> 20:32:53.738
differences between a 721 and
the ERC 20 and ERC. 20 is they

20258
20:32:53.738 --> 20:32:56.739
have a really simple mapping
between an address and how much

20259
20:32:56.739 --> 20:33:00.739
that address holds. 720 ones
have unique token IDs, each

20260
20:33:00.739 --> 20:33:03.739
token ID has a unique owner. And
in addition, they have what's

20261
20:33:03.739 --> 20:33:06.739
called a token URI, which we'll
talk about in a minute. Each

20262
20:33:06.739 --> 20:33:11.739
token is unique. Each token ID
represents a unique asset. So

20263
20:33:11.739 --> 20:33:13.739
since these assets are unique,
and we want to be able to

20264
20:33:13.739 --> 20:33:15.739
visualize them and show what
they actually look like we need

20265
20:33:15.739 --> 20:33:18.739
to define those attributes of
the object. If it's a piece of

20266
20:33:18.739 --> 20:33:21.739
art, we needed a way to define
what that art looks like. If

20267
20:33:21.739 --> 20:33:23.739
it's some type of character in a
game, we need to wait define

20268
20:33:24.739 --> 20:33:28.739
that character stats in the NFT.
This is where metadata and token

20269
20:33:28.739 --> 20:33:30.739
URI has come in. So if you know
anything about Aetherium, you

20270
20:33:30.739 --> 20:33:33.739
know that sometimes gas prices
getting pretty high, especially

20271
20:33:33.739 --> 20:33:35.739
when it comes to storing a lot
of space, it can get really,

20272
20:33:36.739 --> 20:33:38.739
really expensive. So one of your
first questions might be Well,

20273
20:33:38.739 --> 20:33:42.739
are they storing these images?
And these are pieces on chain?

20274
20:33:42.739 --> 20:33:45.739
And the answer is sometimes back
when they were coming up with NF

20275
20:33:45.739 --> 20:33:48.739
T's and artists were deploying
stuff, the eath devs and the

20276
20:33:48.739 --> 20:33:50.739
artists were like yeah, art,
let's do that art. I'm just

20277
20:33:50.739 --> 20:33:54.739
gonna deploy This one megabyte
image onto the Etherium chain.

20278
20:33:54.739 --> 20:34:00.739
And Oh god, it's so much gas
expensive, delete button.

20279
20:34:00.739 --> 20:34:05.739
Otherwise, it's not, it's not
good. And they realized that if

20280
20:34:05.739 --> 20:34:07.739
they put all this art on chain,
it's going to be incredibly

20281
20:34:07.739 --> 20:34:10.739
expensive. So to get around
this, what they did is they put

20282
20:34:10.739 --> 20:34:12.739
in the standard, what's called
the token URI. This is a

20283
20:34:12.739 --> 20:34:16.739
universally unique indicator of
what that asset or what that

20284
20:34:16.739 --> 20:34:19.739
token looks like and what the
attributes of the token are, you

20285
20:34:19.739 --> 20:34:23.739
can use something like a
centralized API, or IPFS. To

20286
20:34:23.739 --> 20:34:26.739
actually get that token URI.
Typical token URI has to return

20287
20:34:26.739 --> 20:34:29.739
something in this format like
this, where it has the name, the

20288
20:34:29.739 --> 20:34:31.739
image, location, the
description, and then any

20289
20:34:31.739 --> 20:34:35.740
attributes below, there is often
this talk of on chain metadata

20290
20:34:35.740 --> 20:34:37.740
versus off chain metadata.
Because it is so much easier and

20291
20:34:37.740 --> 20:34:40.740
cheaper to store all your
metadata off chain, a lot of

20292
20:34:40.740 --> 20:34:44.740
people will use something like
IPFS that is decentralized, but

20293
20:34:44.740 --> 20:34:46.740
does take a little bit of
centrality to keep persisting,

20294
20:34:46.740 --> 20:34:49.740
but they can also use their own
centralized API. However,

20295
20:34:49.740 --> 20:34:52.740
obviously, if that goes down,
then you lose your image, you

20296
20:34:52.740 --> 20:34:54.740
lose everything associated with
your NFT. Because of this most

20297
20:34:54.740 --> 20:34:57.740
NFT marketplaces actually can't
and won't read off on chain

20298
20:34:57.740 --> 20:35:00.740
attributes or on chain metadata,
because they're so used to

20299
20:35:00.740 --> 20:35:03.740
looking for the token URI.
Obviously, if you do off chain

20300
20:35:03.740 --> 20:35:06.740
metadata, you can't do anything
really cool or really

20301
20:35:06.740 --> 20:35:09.740
interesting or have any gains
with your NF T's. For example,

20302
20:35:09.740 --> 20:35:11.740
if you wanted to create an on
chain Pokemon game, all your

20303
20:35:11.740 --> 20:35:14.740
attributes would need to be on
chain in order for your Pokemon

20304
20:35:14.740 --> 20:35:17.740
to interact with each other.
Because if it was off chain,

20305
20:35:17.740 --> 20:35:20.740
then that becomes a lot harder
to cryptographically prove. So

20306
20:35:20.740 --> 20:35:22.740
if you're new with NF T's and
you're like wait, this is kind

20307
20:35:22.740 --> 20:35:24.740
of a lot of information, I'll
make it easy for you. If you're

20308
20:35:24.740 --> 20:35:28.740
looking to render an image, I'm
an NFT, add your image to IPFS,

20309
20:35:28.740 --> 20:35:31.740
add a metadata file pointing to
that image file on IPFS. And

20310
20:35:31.740 --> 20:35:35.740
then grab that token URI and put
it and set it as your NFT. The

20311
20:35:35.740 --> 20:35:38.740
chain link DND article does a
great job of walking you through

20312
20:35:38.740 --> 20:35:40.740
this and showing you how to do
this. So be sure to read that if

20313
20:35:40.740 --> 20:35:42.740
you're looking to learn how to
do that we're not going to cover

20314
20:35:42.740 --> 20:35:45.740
that in this video, but we will
be deploying our first NFT with

20315
20:35:45.740 --> 20:35:48.740
some on chain attributes. Again,
having your attributes on chain

20316
20:35:48.740 --> 20:35:52.740
is really going to allow you to
build really creative NF T's

20317
20:35:52.740 --> 20:35:55.740
that build games or have
interesting properties and and

20318
20:35:55.740 --> 20:35:58.740
really makes the authenticity of
your NFT guaranteed because

20319
20:35:58.740 --> 20:36:02.740
those attributes are always
going to be on chain.

20320
20:36:02.740 --> 20:36:06.740
Alright, so now that we know the
basics of approximately what an

20321
20:36:06.740 --> 20:36:11.740
NF t is, and similar to the ERC
20 You can see the E IP 721 or

20322
20:36:11.740 --> 20:36:16.741
the ERC 721 non fungible token
standard on the Aetherium, ie

20323
20:36:16.741 --> 20:36:19.741
IPs. And once again, if you
scroll down, you can see all the

20324
20:36:19.741 --> 20:36:22.741
different events and the
different functions that come

20325
20:36:22.741 --> 20:36:26.741
with creating this token. And
now everything that we're going

20326
20:36:26.741 --> 20:36:29.741
to do is going to be available
at this GitHub repo. This hard

20327
20:36:30.741 --> 20:36:33.741
hat NFT FCC, we're going to
actually go through all the code

20328
20:36:33.741 --> 20:36:39.741
down to deploying and creating
our own customized NFT. And I've

20329
20:36:39.741 --> 20:36:42.741
labeled this the ultimate NFT
repo as part of this course,

20330
20:36:42.741 --> 20:36:45.741
because we're going to go
through a lot here, we're gonna

20331
20:36:45.741 --> 20:36:50.741
go through a basic NFT, a real
minimalistic NFT and then an

20332
20:36:50.741 --> 20:36:54.741
IPFS hosted NFT. That is
dynamic. And it uses randomness

20333
20:36:54.741 --> 20:36:59.741
to generate unique NF T's so
that we can have provably rare

20334
20:36:59.741 --> 20:37:03.741
and appease or provably rare
cards or provably rare tokens or

20335
20:37:03.741 --> 20:37:07.741
stats or whatever you want. And
then we're going to do what's

20336
20:37:07.741 --> 20:37:12.741
called an SVG NFT. These are
entities that are 100 percent hosted on

20337
20:37:12.741 --> 20:37:15.741
chain, so you don't need an off
chain. So you don't need IPFS,

20338
20:37:15.741 --> 20:37:18.741
you don't need an off chain
database. And this one's also

20339
20:37:18.741 --> 20:37:21.741
going to be dynamic, where it's
going to use price feeds in

20340
20:37:21.741 --> 20:37:24.741
order to fluctuate what the
image of the entity actually

20341
20:37:24.741 --> 20:37:27.741
looks like based off the price
of some asset. And here are the

20342
20:37:27.741 --> 20:37:30.741
images that we're going to be
using. And we obviously have

20343
20:37:30.741 --> 20:37:33.741
these three adorable doggies
here. If you want to follow

20344
20:37:33.741 --> 20:37:35.741
along with the Quickstart, you
absolutely can. And I'm going to

20345
20:37:35.741 --> 20:37:38.741
do a quick overview of just
running the code to show you

20346
20:37:38.741 --> 20:37:42.741
what it's going to look like at
the end. Basically, what we're

20347
20:37:42.741 --> 20:37:44.741
going to do is we're going to
have our code, we're going to

20348
20:37:44.741 --> 20:37:50.741
run hardhat deploy dash dash
network, rink B, dash dash tags

20349
20:37:50.741 --> 20:37:53.741
main. And this is going to
deploy all of our contracts and

20350
20:37:53.741 --> 20:37:58.742
everything. And then finally, if
we go to test nets dot open c.io

20351
20:37:58.742 --> 20:38:02.742
And we grab the address of one
of these NF T's we should be

20352
20:38:02.742 --> 20:38:06.742
able to put it in here see our
actual NFT as a collection with

20353
20:38:06.742 --> 20:38:10.742
an item. Or Additionally, we can
just go right to the contract.

20354
20:38:10.742 --> 20:38:14.742
We can read the contract, we can
get the token URI, and then we

20355
20:38:14.742 --> 20:38:18.742
can copy this token here, I
paste it into our browser or any

20356
20:38:18.742 --> 20:38:22.742
IPFS is into our browser, and
then grab the image attribute

20357
20:38:22.742 --> 20:38:26.742
and see what this actually looks
like on chain. So with all that

20358
20:38:26.742 --> 20:38:30.742
being said, let's learn how to
build this ultimate NFT repo and

20359
20:38:30.742 --> 20:38:34.742
build all of these different
customizable NF T's let's jump

20360
20:38:34.742 --> 20:38:39.742
in. So once again, we're in our
terminal I'm going to create a

20361
20:38:39.742 --> 20:38:44.742
new directory. We're gonna call
it hard hat and a T for FCC.

20362
20:38:44.742 --> 20:38:47.742
We're gonna cd into that. And if
T FCC and we're going to open

20363
20:38:47.742 --> 20:38:52.742
that up with code.or, you can
hit File, Open Folder At this

20364
20:38:52.742 --> 20:38:55.742
point, you'll have gotten pretty
familiar with the setup of our

20365
20:38:55.742 --> 20:38:58.742
code bases here, feel free to
copy over or do whatever you

20366
20:38:58.742 --> 20:39:02.742
want to do for our setup, we'll
do yarn, add dash dash dev hard

20367
20:39:02.742 --> 20:39:05.742
hat. And then while that's
loading, I'm going to copy over

20368
20:39:05.742 --> 20:39:08.742
my prettier files. Because I
want to use prettier, I'm going

20369
20:39:08.742 --> 20:39:12.742
to copy over my hard
hat.config.js. And I'm also

20370
20:39:12.742 --> 20:39:16.742
going to grab my package that
Jason copied over here, I'm

20371
20:39:16.742 --> 20:39:20.742
going to delete this old package
dot JSON. And I'm just going to

20372
20:39:20.742 --> 20:39:23.742
hit Enter on this and rename the
one I just copied over from

20373
20:39:23.742 --> 20:39:26.742
package copy to package json.
And the reason I'm doing this is

20374
20:39:26.742 --> 20:39:30.742
so that I can just go ahead and
run yarn and install all this

20375
20:39:30.742 --> 20:39:33.742
stuff for me. Or we can just
come back over here and just

20376
20:39:33.742 --> 20:39:36.743
grab this lesson nine hard hat,
smart contract lottery, all that

20377
20:39:36.743 --> 20:39:40.743
stuff, again, just run that
massive piece as well. Or you

20378
20:39:40.743 --> 20:39:43.743
can copy over your package json,
and then just run yarn that will

20379
20:39:43.743 --> 20:39:45.743
do the same thing. Now we don't
have to keep doing this

20380
20:39:45.743 --> 20:39:48.743
boilerplate over and over and
over again. And then while

20381
20:39:48.743 --> 20:39:51.743
that's loading, I'm also going
to grab my Dotty and v file that

20382
20:39:51.743 --> 20:39:53.743
we've been using on a past
couple of projects, the

20383
20:39:53.743 --> 20:39:56.743
readme.md. And we'll just do
what we're gonna be doing here.

20384
20:39:56.743 --> 20:39:58.743
So we're going to make three
different contracts. One is

20385
20:39:58.743 --> 20:40:04.743
going to be a basic NFT, using
that ERC 721 standard, then

20386
20:40:04.743 --> 20:40:09.743
we're gonna do a random IPFS
hosted NF t. And then finally,

20387
20:40:09.743 --> 20:40:15.743
we're going to do a dynamic S V
G NFT. So our random NF T is

20388
20:40:15.743 --> 20:40:18.743
going to be random at creation
time, this is going to give some

20389
20:40:18.743 --> 20:40:22.743
true scarcity and some true
randomness to our NF T. And it's

20390
20:40:22.743 --> 20:40:27.743
gonna be hosted on IPFS. Our
dynamic SVG NFT is going to be

20391
20:40:27.743 --> 20:40:32.743
hosted 100 percent on chain, and the
image of it's going to change

20392
20:40:32.743 --> 20:40:35.743
based off of some parameters.
That's what makes it a dynamic

20393
20:40:35.743 --> 20:40:39.743
SVG NFT.

20394
20:40:39.743 --> 20:40:41.743
Let's go ahead and we'll create
a new folder, we'll create our

20395
20:40:41.743 --> 20:40:45.743
contracts folder, and we will
create our first NF t this is

20396
20:40:45.743 --> 20:40:49.743
going to be our basic NFT. And
I'm going to go a little bit

20397
20:40:49.743 --> 20:40:52.743
quick here, because most of what
we're going to be doing is

20398
20:40:52.743 --> 20:40:55.743
actually things that we're
already familiar with. So we'll

20399
20:40:55.743 --> 20:40:59.743
do basic NF T dot soul in a new
file. And let's go ahead and

20400
20:40:59.743 --> 20:41:04.743
let's do it. Let's go ahead and
we'll do spdx license

20401
20:41:04.743 --> 20:41:10.743
identifier, it's gonna be MIT.
We'll do pragma, solidity,

20402
20:41:10.743 --> 20:41:15.744
carrot zero, point 8.7 pragma,
solidity, and then we'll do

20403
20:41:15.744 --> 20:41:21.744
contract, basic NF t. Let me
just basic, get a t.so, like

20404
20:41:21.744 --> 20:41:25.744
that. And we'll say contract
basic NF t. And then we'll just

20405
20:41:25.744 --> 20:41:28.744
run hard at compile or yarn
hard, hit compile, and it looks

20406
20:41:28.744 --> 20:41:31.744
like we're doing well here so
far. Okay, perfect. Based off of

20407
20:41:31.744 --> 20:41:35.744
that NFT token standard, we go
back that EIP, we're going to

20408
20:41:35.744 --> 20:41:38.744
need a whole bunch of different
functions here, we're going to

20409
20:41:38.744 --> 20:41:41.744
need transfer events, we're
going to need owner events

20410
20:41:41.744 --> 20:41:44.744
bounce up, we're going to all
these different functions. And

20411
20:41:44.744 --> 20:41:48.744
we could 100 percent implement these
and transfer them exactly like

20412
20:41:48.744 --> 20:41:53.744
the ERC 20 did, or once again,
so we can use, you guessed it,

20413
20:41:53.744 --> 20:41:56.744
we're gonna be using open
Zeppelin contracts for this as

20414
20:41:56.744 --> 20:41:58.744
well. So we come back over to
open Zeppelin, we go over to

20415
20:41:58.744 --> 20:42:01.744
contracts. And we're gonna go
ahead and add this with yarn,

20416
20:42:01.744 --> 20:42:07.744
add dash dash Dev. So yarn, add
dash dash dev at opens up on

20417
20:42:07.744 --> 20:42:11.744
contracts, like so. And while
that's going through, we can

20418
20:42:11.744 --> 20:42:16.744
look at the ERC 721 of this and
we can see what creating a

20419
20:42:16.744 --> 20:42:19.744
minimalist ERC 721 looks like.
Now there's a number of

20420
20:42:19.744 --> 20:42:23.744
extensions that come with its
ERC. 721 In this example that

20421
20:42:23.744 --> 20:42:28.744
they give us. They're using ERC
721 Uri storage, which we'll

20422
20:42:28.744 --> 20:42:31.744
talk about in a little bit. So
we've added it in here. And now

20423
20:42:31.744 --> 20:42:34.744
we can actually import that ERC
21 from opens up when in our

20424
20:42:34.744 --> 20:42:39.744
contract. So we'll do import at
open Zeppelin slash contracts

20425
20:42:39.744 --> 20:42:46.744
slash token slash your C 721
slash ERC. 721 does so they use

20426
20:42:46.744 --> 20:42:49.744
a different one in the demo, but
don't worry about that. And same

20427
20:42:49.744 --> 20:42:56.745
as the ERC. 20 we're gonna say
our basic NFT is ERC 721. So

20428
20:42:56.745 --> 20:42:59.745
we're doing this inheritance,
you find the constructor, we can

20429
20:43:00.745 --> 20:43:03.745
see this has a constructor,
where it takes a name and a

20430
20:43:03.745 --> 20:43:07.745
symbol. So we're gonna want to
use this constructor and our

20431
20:43:07.745 --> 20:43:12.745
contract. So we're gonna say,
construct door.

20432
20:43:12.745 --> 20:43:16.745
And our constructor is just
going to be blank. But we'll do

20433
20:43:16.745 --> 20:43:21.745
the ERC 721 constructor and
we'll call this a doggie. And

20434
20:43:21.745 --> 20:43:25.745
the symbol will be dog just like
that. Our basic NFT we're just

20435
20:43:25.745 --> 20:43:27.745
going to have it be this doggy
here, right so it's going to be

20436
20:43:27.745 --> 20:43:31.745
an NF T of just a purely this
dog here. The name is going to

20437
20:43:31.745 --> 20:43:34.745
be doggy and the symbol is going
to be dog. Now in order to

20438
20:43:34.745 --> 20:43:39.745
create new dogs. What we're
going to do is openzeppelin code

20439
20:43:39.745 --> 20:43:43.745
comes with something called a
mint function exactly the same

20440
20:43:43.745 --> 20:43:48.745
as the ERC 20 So we're going to
create a function called mint

20441
20:43:48.745 --> 20:43:53.745
NFT this will be a public file
function that's going to return

20442
20:43:53.745 --> 20:43:58.745
you activity six. And we'll use
the safe mint function of this

20443
20:43:58.745 --> 20:44:05.745
ERC 20 or underscore safe mint
message dot sender will mint the

20444
20:44:05.745 --> 20:44:09.745
token to whoever calls this mint
function. And then we need to

20445
20:44:09.745 --> 20:44:13.745
also give this a token ID, if
we're looking back at the code

20446
20:44:13.745 --> 20:44:17.745
for the ERC 721. And again, you
can see this on GitHub as well,

20447
20:44:17.745 --> 20:44:19.745
we're gonna look at this safe
mint function, it takes an

20448
20:44:19.745 --> 20:44:24.745
address to who is going to own
the NFT. And then a token ID,

20449
20:44:24.745 --> 20:44:28.745
what is the ID of the token
based off of this address. So if

20450
20:44:28.745 --> 20:44:32.745
you have a collection of tokens
on the same smart contract, each

20451
20:44:32.745 --> 20:44:35.746
one of them needs their own
unique token ID. So what we're

20452
20:44:35.746 --> 20:44:39.746
gonna do is we're gonna create a
un 256, private variable called

20453
20:44:39.746 --> 20:44:44.746
S underscore token counter, and
it's gonna get initialized in

20454
20:44:44.746 --> 20:44:47.746
our constructor to zero, but
we'll just be explicit and say

20455
20:44:47.746 --> 20:44:51.746
es token counter equals zero.
And then in here, we'll just

20456
20:44:51.746 --> 20:44:56.746
have the token ID of this new NF
t be that token counter. And

20457
20:44:56.746 --> 20:45:00.746
then of course, we'll say s
token counter equals s token

20458
20:45:00.746 --> 20:45:04.746
counter plus one. So every time
we meant a new NFT, we up the

20459
20:45:04.746 --> 20:45:08.746
token counter, and then we'll
just return, we'll just return

20460
20:45:08.746 --> 20:45:11.746
the new tab counter. Right. And
then obviously, at the bottom,

20461
20:45:11.746 --> 20:45:14.746
we could do like function, get
token counter, this would be a

20462
20:45:14.746 --> 20:45:19.746
public view returns you in 256.
And I'm gonna go a little quick

20463
20:45:19.746 --> 20:45:22.746
here, because you've seen this
before, return s underscore

20464
20:45:22.746 --> 20:45:26.746
token counter, right, since it's
a private variable up here, the

20465
20:45:26.746 --> 20:45:29.746
public function down here to get
that token counter. So this

20466
20:45:30.746 --> 20:45:33.746
technically, is it. This is
technically an NF T. But what

20467
20:45:33.746 --> 20:45:36.746
does this look like? Well, right
now, this NF T isn't going to

20468
20:45:36.746 --> 20:45:41.746
look like anything at all, in
this EIP token standard. It has

20469
20:45:41.746 --> 20:45:44.746
this thing called a token URI.
And this is the important

20470
20:45:44.746 --> 20:45:48.746
function that tells us exactly
what this token is going to look

20471
20:45:48.746 --> 20:45:52.746
like. Like what we said in the
mini lesson here. This token URI

20472
20:45:52.746 --> 20:45:56.746
returns some type of URL or
universal resource identifier

20473
20:45:56.746 --> 20:46:00.746
that returns some JSON that
looks like this. And in this

20474
20:46:00.746 --> 20:46:03.746
JSON, we're going to have this
image part. And this image is

20475
20:46:03.746 --> 20:46:07.746
going to be a URL that's going
to point to what this image

20476
20:46:07.746 --> 20:46:10.746
actually looks like. Now this
URL can be hosted on chain, it

20477
20:46:10.746 --> 20:46:13.746
can be hosted on IPFS, it can be
hosted really wherever. But

20478
20:46:13.746 --> 20:46:16.747
ideally, we're not going to use
a centralized server to host it.

20479
20:46:16.747 --> 20:46:19.747
If this is hosted on a Google
Cloud or a centralized server or

20480
20:46:19.747 --> 20:46:22.747
whatever, and our centralized
server goes down. Well guess

20481
20:46:22.747 --> 20:46:24.747
what this MC is gonna look like,
it's not gonna look like

20482
20:46:24.747 --> 20:46:28.747
anything. So we want to use some
type of decentralized storage,

20483
20:46:28.747 --> 20:46:32.747
to get a URL, or URI to store
what this looks like. To make

20484
20:46:32.747 --> 20:46:35.747
this section a little bit easier
for you, I've actually already

20485
20:46:35.747 --> 20:46:40.747
gone ahead and hosted an image
to IPFS. For you, it's going to

20486
20:46:40.747 --> 20:46:44.747
be at IPFS dot dot slash slash,
it's going to look like this,

20487
20:46:44.747 --> 20:46:47.747
this is going to be the image
that we're going to use for our

20488
20:46:47.747 --> 20:46:51.747
dog here. If you create just
this image, though, as the token

20489
20:46:51.747 --> 20:46:56.747
URI, that's not going to work,
we need a URI that returns this,

20490
20:46:56.747 --> 20:46:59.747
with the image inside of it. Now
for this first section, have

20491
20:46:59.747 --> 20:47:01.747
already gone ahead and done that
for you as well. And that's

20492
20:47:01.747 --> 20:47:05.747
going to be located here. This
is what our token URI function

20493
20:47:05.747 --> 20:47:07.747
needs to return. So it's going
to have the name, the

20494
20:47:07.747 --> 20:47:12.747
description, the image URI,
which then points to the dog,

20495
20:47:12.747 --> 20:47:15.747
and then some attributes, etc,
etc. Now, you'll notice that the

20496
20:47:15.747 --> 20:47:21.747
image here is pointing to HTTPS,
dot dot slash slash ipfs.io. The

20497
20:47:21.747 --> 20:47:24.747
reason I did this was again,
just in case you didn't have the

20498
20:47:24.747 --> 20:47:28.747
IPFS gateway, but this would be
a lot better if this was in its

20499
20:47:28.747 --> 20:47:33.747
IPFS form. Because if the
centralized server ipfs.io, goes

20500
20:47:33.747 --> 20:47:38.747
ever goes down, this NFT will
show what it'll show nothing. So

20501
20:47:38.747 --> 20:47:44.747
it would be much better. If it
was instead of ipfs.io. It was

20502
20:47:44.747 --> 20:47:49.747
IPFS, colon slash slash, like
that, instead of ipfs.io. But

20503
20:47:49.747 --> 20:47:51.747
for now, this is what we're
going to be using. And you can

20504
20:47:51.747 --> 20:47:56.748
just go to the GitHub for this,
just to grab this for this

20505
20:47:56.748 --> 20:48:00.748
section. Right? Just go to
contracts, basic NFT, you can

20506
20:48:00.748 --> 20:48:04.748
just grab this, this, this top
part, just copy it like that. So

20507
20:48:04.748 --> 20:48:09.748
we're going to paste that the
token URI up, up, up at the top,

20508
20:48:09.748 --> 20:48:14.748
like so. Oh, it should be
returns, return. There we go.

20509
20:48:14.748 --> 20:48:17.748
Okay, cool. So we're just going
to copy paste that in here like

20510
20:48:17.748 --> 20:48:22.748
this. Like I said, even though
the token URI here is pointing

20511
20:48:22.748 --> 20:48:26.748
directly to IPFS, which is good.
If you actually go to this file,

20512
20:48:26.748 --> 20:48:31.748
the file is actually pointing to
http.ipfs.io. Again, for your NF

20513
20:48:31.748 --> 20:48:35.748
T's don't do that for this NFT.
I just did that just in case,

20514
20:48:35.748 --> 20:48:38.748
but for your NF T's don't do
that. And we're going to make

20515
20:48:38.748 --> 20:48:42.748
this a public constant variable.
Why? Well, because this token

20516
20:48:42.748 --> 20:48:44.748
you write is never going to
change. We're going to make this

20517
20:48:44.748 --> 20:48:48.748
NFT so that everybody who meets
one will have this exact same

20518
20:48:48.748 --> 20:48:52.748
adorable little puck here. And
the way we do That now is we

20519
20:48:52.748 --> 20:48:56.748
need to identify the actual
token URI function. So I'm going

20520
20:48:56.748 --> 20:48:59.748
to do it above get token
counter, we're going to say

20521
20:48:59.748 --> 20:49:08.748
function, token URI. And these
always take a UNT 256 token ID,

20522
20:49:08.748 --> 20:49:14.748
we're going to make this a
public view, override returns

20523
20:49:14.748 --> 20:49:22.748
string memory. And this needs to
return the token URI. Now, this

20524
20:49:22.748 --> 20:49:26.748
is going to be the most basic
way to create this, right. And

20525
20:49:26.748 --> 20:49:29.748
if we wanted to make this
function a little nicer, we'd

20526
20:49:29.748 --> 20:49:32.748
comment out token ID as well,
since we're actually not using

20527
20:49:32.748 --> 20:49:38.749
token ID. But we're overriding
in our in the ERC 721 that we're

20528
20:49:38.749 --> 20:49:42.749
importing. This has a token ID
function or a token URI

20529
20:49:42.749 --> 20:49:46.749
function. And we're overriding
this, right, we're not using

20530
20:49:46.749 --> 20:49:48.749
this at all, we're saying, Hey,
we're just going to use our own

20531
20:49:48.749 --> 20:49:53.749
here. And that's all we need for
this to work. And now if you

20532
20:49:53.749 --> 20:49:55.749
were to deploy this to rink B,
if you were to jump over to open

20533
20:49:55.749 --> 20:49:59.749
C test net, and you would deploy
this, this dog, this adorable

20534
20:49:59.749 --> 20:50:03.749
little pop would be what shows
up for all the minutes. So let's

20535
20:50:03.749 --> 20:50:06.749
go ahead, and let's create a
little deploy function for this.

20536
20:50:06.749 --> 20:50:11.749
So we'll do a new folder, deploy
a new file, we'll call this a

20537
20:50:11.749 --> 20:50:17.749
one deploy basic NF T dot j s.
And this is going to look real

20538
20:50:17.749 --> 20:50:19.749
similar to everything that we've
done before. So I'm going to

20539
20:50:19.749 --> 20:50:25.749
move a little bit quicker here.
const network equals require

20540
20:50:25.749 --> 20:50:33.749
hard hats, const development
chains, equals require dot dot

20541
20:50:33.749 --> 20:50:38.749
slash helper, hard hats config.
And I don't think I added that.

20542
20:50:38.749 --> 20:50:42.749
So I'm going to copy paste my
helper Hardhead config from our

20543
20:50:42.749 --> 20:50:45.749
last project. And if you get
confused, you can always just

20544
20:50:45.749 --> 20:50:49.749
come to the GitHub here, and
just go to the helper Hardhead

20545
20:50:49.749 --> 20:50:52.749
config and grab it from here, we
have that const development

20546
20:50:52.749 --> 20:50:58.749
chains, or say const verify
equals require dot dot slash

20547
20:50:58.749 --> 20:51:03.749
utils. Slash verify. We're also
going to grab our utils, I'm

20548
20:51:03.749 --> 20:51:06.749
going to copy paste so utils
folder from alas project, once

20549
20:51:06.749 --> 20:51:09.749
again, you can copy paste from
your last project, or you can

20550
20:51:09.749 --> 20:51:12.749
just go straight to the repo,
grab the verified dot j s, we're

20551
20:51:12.749 --> 20:51:14.749
going to go over these two
functions a little bit later,

20552
20:51:15.749 --> 20:51:17.750
but at least grab the verified
for now. And then we're gonna

20553
20:51:17.750 --> 20:51:21.750
start the function. So we'll do
module that exports equals async

20554
20:51:21.750 --> 20:51:29.750
function. We're gonna get get
named accounts, and deployments.

20555
20:51:29.750 --> 20:51:34.750
And we're gonna say const.
Deploy, log equals deployments

20556
20:51:34.750 --> 20:51:41.750
against deployer equals await,
get named accounts. So we'll do

20557
20:51:41.750 --> 20:51:47.750
a little log here just to get
started to do our basic NFT

20558
20:51:47.750 --> 20:51:51.750
doesn't take any constructor
parameters. So we'll say const

20559
20:51:51.750 --> 20:51:58.750
args equals a little blank here.
Then we'll do const basic NFT

20560
20:51:58.750 --> 20:52:05.750
equals await, deploy basic NF T,
exactly what we've seen before a

20561
20:52:05.750 --> 20:52:10.750
number of times at this point,
we'll say from Deployer. args is

20562
20:52:10.750 --> 20:52:14.750
going to be args. And then log,
it's going to be true. And then

20563
20:52:14.750 --> 20:52:16.750
we'll also do weight
confirmations. It's going to be

20564
20:52:16.750 --> 20:52:25.750
network dot config dot block,
confirmations, or one. Then if

20565
20:52:25.750 --> 20:52:29.750
we want to verify this, we're
going to once again do if it's

20566
20:52:29.750 --> 20:52:37.750
not development chains, dot
includes network dot name, and

20567
20:52:37.750 --> 20:52:44.750
process that EMV dot ether scan
API key will say log verifying

20568
20:52:44.750 --> 20:52:51.750
dot the dot await, verify basic
NF T dot address arguments which

20569
20:52:51.750 --> 20:52:55.751
are going to be blank, grab this
little log here, stick it right

20570
20:52:55.751 --> 20:52:59.751
underneath. And then actually in
our basic NF T. This should be

20571
20:52:59.751 --> 20:53:03.751
args not arguments. Now we have
a deploy script. Now we have a

20572
20:53:03.751 --> 20:53:07.751
basic NFT here in test data
deploy script, or any hh deploy

20573
20:53:07.751 --> 20:53:12.751
or yarn Hardhead deploy. And
oops, let's go back to the basic

20574
20:53:12.751 --> 20:53:19.751
kind of tea or mint and have tea
needs to return a UNT 256. Try

20575
20:53:19.751 --> 20:53:23.751
again. Get token counter also
needs to return a UNT forget you

20576
20:53:23.751 --> 20:53:26.751
into anywhere else. Nope. Okay,
looking good. And looks like

20577
20:53:26.751 --> 20:53:30.751
we're compiling well compiled,
deploying Well, now if you want

20578
20:53:30.751 --> 20:53:35.751
to deploy this to rink B, you
can. I recommend holding off

20579
20:53:35.751 --> 20:53:37.751
though, because we're going to
do that at the end. Now that

20580
20:53:37.751 --> 20:53:40.751
we've written a deploy script.
We've written the contract, you

20581
20:53:40.751 --> 20:53:44.751
already know what's coming next.
Yes, neat. What's next is the

20582
20:53:44.751 --> 20:53:47.751
tests now because we're not
actually learning too much more

20583
20:53:47.751 --> 20:53:50.751
here. I'm not going to walk you
through writing this test. I'm

20584
20:53:50.751 --> 20:53:53.751
going to challenge you now. How
to pause the video and write the

20585
20:53:54.751 --> 20:53:57.751
test out yourself and see how
far in this test you can

20586
20:53:57.751 --> 20:54:00.751
actually get. Remember, to test
it, you're going to want to run

20587
20:54:00.751 --> 20:54:03.751
yarn, hard hat test,

20588
20:54:03.751 --> 20:54:05.751
right, let's see if you can
actually write the test

20589
20:54:05.751 --> 20:54:09.751
yourself, then come back to the
video, see if your tests were

20590
20:54:09.751 --> 20:54:13.751
just as good or not as good as
what we did here. And of course,

20591
20:54:13.751 --> 20:54:16.751
you can always go to the GitHub
repo test sections. And if you

20592
20:54:16.751 --> 20:54:21.751
get lost, you can look at the
basic nft.test.js To follow

20593
20:54:21.751 --> 20:54:33.751
along. All right, welcome back.
Hopefully, you wrote some

20594
20:54:33.751 --> 20:54:36.752
awesome tests, taking the time
to actually do some of those

20595
20:54:36.752 --> 20:54:40.752
exercises is really going to
make you a much better engineer.

20596
20:54:40.752 --> 20:54:43.752
Following along with me, it's
awesome. But tinkering yourself

20597
20:54:43.752 --> 20:54:46.752
and trying to do everything
yourself is really what's gonna

20598
20:54:46.752 --> 20:54:49.752
make this stick. So I hope you
did pause the video. And hope

20599
20:54:49.752 --> 20:54:51.752
you did go ahead and try to
write the test for this

20600
20:54:51.752 --> 20:54:54.752
yourself, you've technically
just created a really

20601
20:54:54.752 --> 20:54:55.752
minimalistic NFT.

20602
20:54:55.752 --> 20:55:02.752
Great job. Let's kick things up
a notch. Let's move now to a

20603
20:55:02.752 --> 20:55:07.752
random IPFS hosted NFT where
we're going to do everything

20604
20:55:07.752 --> 20:55:11.752
pretty much programmatically. So
let's jump in. In our contracts,

20605
20:55:11.752 --> 20:55:16.752
we're going to create a new file
random IPFS, NFT, dot soul. Same

20606
20:55:16.752 --> 20:55:24.752
thing. spdx license identifier,
gonna be MIT pragma, solidity

20607
20:55:24.752 --> 20:55:27.752
carrot zero, point 8.7, or
whatever version you want to

20608
20:55:27.752 --> 20:55:35.752
use, will do contract random
IPFS NF? T, like so. So what is

20609
20:55:35.752 --> 20:55:39.752
this one going to do? So instead
of just minting any NFT, when we

20610
20:55:39.752 --> 20:55:47.752
meant an NF t, we will trigger a
chainlink VRF call to get us a

20611
20:55:47.752 --> 20:55:52.752
random number. Using that
number, we will get get a random

20612
20:55:52.752 --> 20:55:56.752
NF t that we're going to decide
on. And the random n of t that

20613
20:55:56.752 --> 20:55:59.752
we're going to use, it's going
to be either a pug a Shiva in

20614
20:55:59.752 --> 20:56:04.752
you, or a St. Bernard. So
whenever anybody mints NF T,

20615
20:56:04.752 --> 20:56:06.752
they're gonna get one of these
random three dogs. And we're

20616
20:56:06.752 --> 20:56:09.752
going to make this so that each
one of these dogs have a

20617
20:56:09.752 --> 20:56:12.752
different rarity, we're going to
make these dogs rare by

20618
20:56:12.752 --> 20:56:16.753
different amounts, say we want
the pug to be super rare, the

20619
20:56:16.753 --> 20:56:20.753
Shiva to be sort of rare, and
then the St. Bernard to be

20620
20:56:20.753 --> 20:56:23.753
pretty common. So probably it's
gonna be super rare Shiva in us

20621
20:56:23.753 --> 20:56:26.753
is gonna be sort of rare, St.
Bernard is going to be pretty

20622
20:56:27.753 --> 20:56:30.753
common, right? Or the most
common, if you will. So let's go

20623
20:56:30.753 --> 20:56:32.753
ahead and start building this,
we're probably gonna have to

20624
20:56:32.753 --> 20:56:36.753
make a function called like
request NF t, because we're

20625
20:56:36.753 --> 20:56:38.753
going to know that we're gonna
need to kick off a channeling

20626
20:56:38.753 --> 20:56:41.753
VRF request, we're probably
gonna have to make a function

20627
20:56:41.753 --> 20:56:47.753
fulfill random words, that's
going to take a un 256 Request

20628
20:56:47.753 --> 20:56:53.753
ID and a un 256. Array, memory
random words, as we've seen

20629
20:56:53.753 --> 20:56:57.753
before, we've done fulfill
random words in the past. And

20630
20:56:57.753 --> 20:57:00.753
let's let's even go one step
further, we'll make it so that

20631
20:57:00.753 --> 20:57:06.753
users have to pay to mint an NF
t. So this is going to be they

20632
20:57:06.753 --> 20:57:10.753
have to pay a certain amount of
eath to get the NFT and then the

20633
20:57:10.753 --> 20:57:14.753
owner of the contract and
withdraw the eath. So we're

20634
20:57:14.753 --> 20:57:17.753
basically paying the artists
here, we're paying the artists

20635
20:57:17.753 --> 20:57:20.753
to create these NF T's. And then
they can be the ones actually

20636
20:57:20.753 --> 20:57:23.753
actually withdraw the payment
for all these NF T's. And we're

20637
20:57:23.753 --> 20:57:28.753
also going to need, of course, a
function, token URI, which takes

20638
20:57:28.753 --> 20:57:32.753
a un 256. And this is once
again, same as our basic NFT

20639
20:57:32.753 --> 20:57:35.753
gonna be what this token
actually looks like. So let's go

20640
20:57:35.753 --> 20:57:37.753
ahead and get started creating
this. Now, because these red

20641
20:57:37.753 --> 20:57:40.753
lines are going to draw me
crazy. We're going to add some

20642
20:57:40.753 --> 20:57:45.753
visibility here, we'll make this
request NFT public fulfill

20643
20:57:45.753 --> 20:57:48.753
random words, we actually know
from the past is going to be

20644
20:57:48.753 --> 20:57:52.753
internal token URI is going to
be public. Let's build this

20645
20:57:52.753 --> 20:57:57.754
request NFT. And again, to
request a random number, go back

20646
20:57:57.754 --> 20:58:01.754
to EVM. Chains, we go to using
randomness, we can follow along

20647
20:58:01.754 --> 20:58:04.754
with the Dr. chain link again,
to figure out how to get this

20648
20:58:04.754 --> 20:58:07.754
random number. So since we know
we're going to be working with

20649
20:58:07.754 --> 20:58:11.754
chain link, we want to add at
chain link slash contracts. So

20650
20:58:11.754 --> 20:58:16.754
back in in our code base, we'll
add that in yarn add dash dash

20651
20:58:16.754 --> 20:58:21.754
dev at chain link slash
contracts, like so which was

20652
20:58:21.754 --> 20:58:25.754
perfect. And we can go ahead,
and we're going to import that

20653
20:58:25.754 --> 20:58:30.754
VRF consumer base V two and the
VRF coordinator interface into

20654
20:58:30.754 --> 20:58:32.754
our code because we know we're
going to use both of these. If

20655
20:58:33.754 --> 20:58:36.754
you want to just copy paste from
the docs, you absolutely can go

20656
20:58:36.754 --> 20:58:39.754
to pause here. And since we're
going to be using this view of

20657
20:58:39.754 --> 20:58:43.754
consumer base, we want to
inherit it. We're going to say

20658
20:58:43.754 --> 20:58:48.754
random IPFS and f t is V RF
consumer base V two and this

20659
20:58:48.754 --> 20:58:51.754
little, little wiggly line will
show up here saying This seems

20660
20:58:51.754 --> 20:58:54.754
to be override. So I'm just
gonna go ahead and add override

20661
20:58:54.754 --> 20:58:57.754
here. And this little wiggly
line is gonna stay there for a

20662
20:58:57.754 --> 20:59:00.754
little bit until we implement
the rest of the functions. So

20663
20:59:00.754 --> 20:59:03.754
let's go ahead and implement the
rest of those functions. Request

20664
20:59:03.754 --> 20:59:07.754
NFT, of course, is going to be
public here. And in order for us

20665
20:59:07.754 --> 20:59:10.754
to request an NF T, we're going
to need to call the coordinator

20666
20:59:10.754 --> 20:59:14.754
dot request random words where
we pass all this stuff in.

20667
20:59:14.754 --> 20:59:18.754
Right, so let's go ahead and get
all this stuff for our V REF

20668
20:59:18.754 --> 20:59:21.754
coordinator in our constructor,
so let's create a new

20669
20:59:21.754 --> 20:59:25.754
constructor. struct door. And
we're going to use the VRF

20670
20:59:25.754 --> 20:59:30.754
consumer base, the two
constructor to use to create our

20671
20:59:30.754 --> 20:59:34.754
constructor, the VRF consumer
base V two needs an address in

20672
20:59:34.754 --> 20:59:37.755
here for the VRF consumer base.
So we'll go ahead and we'll do

20673
20:59:37.755 --> 20:59:44.755
address VRF. Or did Nate Torre b
two. And then we'll pass this to

20674
20:59:44.755 --> 20:59:48.755
the VRF consumer base
constructor here, just by adding

20675
20:59:48.755 --> 20:59:51.755
that that red squiggly line has
gone away from me perfect. And

20676
20:59:51.755 --> 20:59:55.755
we want to save that address to
a global variable. So we can

20677
20:59:55.755 --> 21:00:00.755
call request random words on it.
So we're gonna go ahead up here,

20678
21:00:00.755 --> 21:00:06.755
we're going to say I underscore
var F chord. To me, Tor, we're

20679
21:00:06.755 --> 21:00:09.755
going to make this immutable VRF
coordinator. And we're going to

20680
21:00:09.755 --> 21:00:13.755
do it by saying VRF v2
interface, it's gonna be

20681
21:00:13.755 --> 21:00:19.755
private, immutable, you have
coordinator and then in our

20682
21:00:19.755 --> 21:00:24.755
constructor here, we're gonna
say IVF coordinator equals VRF,

20683
21:00:24.755 --> 21:00:29.755
coordinator v2 interface wrapped
around this like so. So we know

20684
21:00:29.755 --> 21:00:31.755
we're going to need this, we
know we're actually gonna need a

20685
21:00:31.755 --> 21:00:34.755
ton of these. So let's just add
all these variables in here,

20686
21:00:34.755 --> 21:00:37.755
we're gonna need the
coordinator, we're gonna need a

20687
21:00:37.755 --> 21:00:45.755
UNT 64 private, immutable, I
underscore subscription ID,

20688
21:00:45.755 --> 21:00:50.755
we're gonna need a bytes 32,
private, immutable,

20689
21:00:50.755 --> 21:00:57.755
I underscore gas lane, we're
gonna need a you int 32 private,

20690
21:00:57.755 --> 21:01:02.755
mutable, I underscore callback
gas limit, we're gonna need a

20691
21:01:02.755 --> 21:01:10.755
UNT 16 Private constants,
request confirmations, we're

20692
21:01:10.755 --> 21:01:16.756
gonna say it's gonna be three,
and then a un 32. Private

20693
21:01:16.756 --> 21:01:22.756
constant equals num words, which
is going to be one, and we'll

20694
21:01:22.756 --> 21:01:26.756
get this red squiggly line
saying it's mad at our our

20695
21:01:26.756 --> 21:01:30.756
constructor here. So let's go
ahead and add all of our

20696
21:01:30.756 --> 21:01:33.756
immutable variables in our
constructor. So we'll get the

20697
21:01:33.756 --> 21:01:39.756
VRF coordinator v2 from our
constructor will get the UNT 64

20698
21:01:39.756 --> 21:01:45.756
subscription ID, we'll get the
bytes 32 Gas lane, aka the key

20699
21:01:45.756 --> 21:01:52.756
hash, we'll get the un 256.
We'll do a UNT 32 callback gas

20700
21:01:52.756 --> 21:01:58.756
limit, then we'll go ahead and
do I subscription ID equals

20701
21:01:58.756 --> 21:02:06.756
subscription ID will do I gas
Lane equals gas lane will do I

20702
21:02:06.756 --> 21:02:11.756
call back gas limit equals call
back.

20703
21:02:11.756 --> 21:02:13.756
Yes limit.

20704
21:02:13.756 --> 21:02:15.756
Okay, a lot of variables set up.
But those are the variables that

20705
21:02:15.756 --> 21:02:18.756
we're going to need for the
chainlink VRF. Now we have all

20706
21:02:18.756 --> 21:02:22.756
these variables down in our
request. And if t we can request

20707
21:02:22.756 --> 21:02:26.756
a random number to get for our
random n of t, we're going to

20708
21:02:26.756 --> 21:02:32.756
say and our returns a yuan
tivity six Request ID. So in

20709
21:02:32.756 --> 21:02:37.756
here, we'll say request, Id this
request ID that we just

20710
21:02:37.756 --> 21:02:44.756
initialized I underscore VRF.
Core didn't a Tor dot request.

20711
21:02:44.756 --> 21:02:48.756
random words. And this should
look pretty familiar to what we

20712
21:02:48.756 --> 21:02:54.756
did in our lottery. I underscore
gas Lane comma, I underscore

20713
21:02:54.756 --> 21:03:03.757
subscription ID, comma, request,
con for nations. I underscore

20714
21:03:03.757 --> 21:03:08.757
callback gas limit. And then of
course num words and we can just

20715
21:03:08.757 --> 21:03:12.757
literally copy paste this from
the documentation or from our

20716
21:03:12.757 --> 21:03:16.757
last project, whatever you want
to do. So we are requesting this

20717
21:03:16.757 --> 21:03:26.757
random NFT here. Now here's the
thing, though, we want whoever

20718
21:03:26.757 --> 21:03:30.757
called this request function it
to be there and have tea, right.

20719
21:03:30.757 --> 21:03:34.757
And if we saw in our basic NFT,
when we minted the NFT, we call

20720
21:03:34.757 --> 21:03:38.757
this safe mint which needed the
owner and the token counter.

20721
21:03:38.757 --> 21:03:41.757
When we request a random number
four are NFT. It's going to

20722
21:03:41.757 --> 21:03:44.757
happen in two transactions,
right? We're going to request

20723
21:03:44.757 --> 21:03:47.757
and then later on we're going to
fulfill and it's going to be the

20724
21:03:47.757 --> 21:03:51.757
chain link node that's calling
fulfill random words. So if it

20725
21:03:51.757 --> 21:03:54.757
In the fulfill function, we just
do this safe meant message that

20726
21:03:54.757 --> 21:03:58.757
sender, the owner of this NFT is
actually going to be the chain

20727
21:03:58.757 --> 21:04:03.757
link node that fulfilled our
random words. So we don't want

20728
21:04:03.757 --> 21:04:07.757
that, what we want to do is we
want to create a mapping between

20729
21:04:07.757 --> 21:04:12.757
request IDs. And whoever called
this so that when we call

20730
21:04:12.757 --> 21:04:15.757
fulfill random words, which
returns with that exact same

20731
21:04:15.757 --> 21:04:19.757
request, ID, we can say, Ah,
okay, your request ID X, you

20732
21:04:19.757 --> 21:04:23.757
belong to the person who called
this request and of team, we're

20733
21:04:23.757 --> 21:04:26.757
going to create a mapping
between people who call this and

20734
21:04:26.757 --> 21:04:29.757
their request IDs so that when
we fulfill random words, we can

20735
21:04:29.757 --> 21:04:33.757
properly assign the dogs to
them. So up at the top, right

20736
21:04:33.757 --> 21:04:36.758
underneath here, I'm going to
call them VRF helpers, we're

20737
21:04:36.758 --> 21:04:42.758
going to create a mapping of un
256. To an address, we'll make

20738
21:04:42.758 --> 21:04:44.758
this public which we should make
it private, but we'll just make

20739
21:04:44.758 --> 21:04:50.758
it public s underscore Request
ID to sender. And then when we

20740
21:04:50.758 --> 21:04:56.758
call this request, and F T, will
set the request ID to sender of

20741
21:04:56.758 --> 21:05:03.758
Request ID equals to message dot
sender. Now, when the chain link

20742
21:05:03.758 --> 21:05:07.758
node responds with fulfill
random words, what we can do is

20743
21:05:07.758 --> 21:05:12.758
we can say address dog owner or
the NFT dog owner is going to be

20744
21:05:12.758 --> 21:05:19.758
equal to s Request ID to sender
of Request ID. This way, it's

20745
21:05:19.758 --> 21:05:21.758
not going to be the chain link
nodes that are going to own the

20746
21:05:21.758 --> 21:05:26.758
dog, but it's gonna be whoever
actually called requests. NFT.

20747
21:05:26.758 --> 21:05:29.758
Okay, cool. So we have a way to
request a random number for our

20748
21:05:29.758 --> 21:05:34.758
random NF t. Now, let's go ahead
and mint this random dog, this

20749
21:05:34.758 --> 21:05:40.758
random NF T for this for this
user. So we have the user now

20750
21:05:40.758 --> 21:05:43.758
using this mapping, what else do
we need? Well, we're gonna need

20751
21:05:43.758 --> 21:05:46.758
the token counter here. Let's go
ahead and we'll create a token

20752
21:05:46.758 --> 21:05:49.758
counter variable. So we'll
scroll up and make a new

20753
21:05:49.758 --> 21:05:56.758
section. And we'll say, un 256.
And then again, we'll just make

20754
21:05:56.758 --> 21:05:58.758
a lot of these public just to
make it easier, but you might

20755
21:05:58.758 --> 21:06:01.758
want to make this private and
use that same syntax we were

20756
21:06:01.758 --> 21:06:05.758
doing before do s underscore
since this is a stored variable,

20757
21:06:05.758 --> 21:06:09.758
token counter. And we'll grab
this token counter. And we'll

20758
21:06:09.758 --> 21:06:15.758
say you went to 56. New token ID
equals as token counter, now

20759
21:06:15.758 --> 21:06:19.759
that we have the dog owner, and
the token ID, we can go ahead

20760
21:06:19.759 --> 21:06:23.759
and mint this MFT. So we'll do
safe mint.

20761
21:06:23.759 --> 21:06:30.759
Owner, new token, ID and then
safe man is going to be squiggly

20762
21:06:30.759 --> 21:06:34.759
because our code is gonna say,
what is this? What is the safe

20763
21:06:34.759 --> 21:06:37.759
mint function? Where did you get
this from? Well, we're gonna

20764
21:06:37.759 --> 21:06:39.759
need to get it from open
Zeppelin again. So we're going

20765
21:06:39.759 --> 21:06:44.759
to go ahead and do import at
open Zeppelin slash contracts

20766
21:06:44.759 --> 21:06:53.759
slash token slash ERC. 721 slash
ERC. 720 one.so We'll say a

20767
21:06:53.759 --> 21:06:59.759
random IPFS empty is Vera of
consumer base, and also ERC 721

20768
21:06:59.759 --> 21:07:02.759
In our constructor, right after
our V RF consumer base, we're

20769
21:07:02.759 --> 21:07:08.759
going to put the ERC 721. And
same thing, we need to give it a

20770
21:07:08.759 --> 21:07:15.759
name and a symbol. So we'll call
this random IPFS NF T. Comma,

20771
21:07:15.759 --> 21:07:19.759
we'll just do Rin for random
IPFS NF team. Now safe mint

20772
21:07:19.759 --> 21:07:22.759
actually works and then it's
gonna be mad at me for this. So

20773
21:07:22.759 --> 21:07:24.759
I'm gonna do override just let
it stop getting mad at me.

20774
21:07:24.759 --> 21:07:31.759
public view override turns
string memory. Just that

20775
21:07:31.759 --> 21:07:34.759
squiggly line goes way. Okay,
cool. So great. So now we can

20776
21:07:34.759 --> 21:07:43.759
safe mint to the dog owner this
new token ID Are we done with

20777
21:07:43.759 --> 21:07:47.759
this? Absolutely not. Why not?
Well, we don't know what this

20778
21:07:47.759 --> 21:07:51.759
token looks like. And what we
set above is we want to actually

20779
21:07:51.759 --> 21:07:54.759
make these dogs different
rarities. So how do we actually

20780
21:07:54.759 --> 21:07:58.760
create these dogs with different
rarities, all we could do is we

20781
21:07:58.760 --> 21:08:03.760
create a chance array an array
to show the different chances of

20782
21:08:03.760 --> 21:08:06.760
these different dogs here. So
down below, we're going to

20783
21:08:06.760 --> 21:08:12.760
create a function and it's going
to be a public pure function

20784
21:08:12.760 --> 21:08:20.760
called get chance array. And
this is going to return you went

20785
21:08:20.760 --> 21:08:26.760
to 46 of size three in memory.
And this chance array is going

20786
21:08:26.760 --> 21:08:29.760
to represent the different
chances of the different dogs.

20787
21:08:29.760 --> 21:08:35.760
So we're gonna say return
10 3100 Or we're gonna say Max

20788
21:08:35.760 --> 21:08:38.760
chance value.

20789
21:08:38.760 --> 21:08:42.760
And up at the top under empty
variables. We're gonna say you

20790
21:08:42.760 --> 21:08:48.760
went to 56 internal constant,
Max chance value equals 100. So

20791
21:08:48.760 --> 21:08:53.760
by making this array, we're
saying index Zero has a 10 percent

20792
21:08:53.760 --> 21:08:58.760
chance of happening. We're
saying index one has a 20 percent

20793
21:08:58.760 --> 21:09:03.760
chance of happening because it's
going to be 30 minus 10. And

20794
21:09:03.760 --> 21:09:07.760
then we're saying index two is
going to have a 60 percent chance of

20795
21:09:07.760 --> 21:09:12.760
happening, because it's going to
be 10 plus 30. minus this 100.

20796
21:09:12.760 --> 21:09:15.760
This array that identified the
percentages of the different

20797
21:09:15.760 --> 21:09:20.760
dogs. We're saying the pug is
going to have a 10 percent chance,

20798
21:09:20.760 --> 21:09:25.760
Shiva in you a 20 percent chance and
the St. Bernard a 70 percent chance,

20799
21:09:25.760 --> 21:09:29.760
we're going to use it to give
this token ID that we just

20800
21:09:29.760 --> 21:09:32.760
minted its dog breed. So we're
gonna create a new function

20801
21:09:32.760 --> 21:09:37.761
called Get breed from modded
RNG. And the reason we're

20802
21:09:37.761 --> 21:09:41.761
calling a get breed from modded
RNG is exactly the same way. In

20803
21:09:41.761 --> 21:09:44.761
our lottery. We got a random
number, we're gonna say you went

20804
21:09:44.761 --> 21:09:53.761
to 56 modded RNG equals random
words of zero mod Max chance

20805
21:09:53.761 --> 21:09:57.761
value, we're going to mod any
number we get by 100. Doing it

20806
21:09:57.761 --> 21:10:00.761
like this, we're always going to
get a number between zero and

20807
21:10:00.761 --> 21:10:04.761
99. If random words zero mod Max
Chin's value is going to be

20808
21:10:04.761 --> 21:10:08.761
seven. That means we're gonna
get a pug. If we get 88. That

20809
21:10:08.761 --> 21:10:14.761
means we're gonna get a St.
Bernard, if we get a 45. We're

20810
21:10:14.761 --> 21:10:19.761
gonna get a what? That's right,
a St. Bernard, if we got a 12

20811
21:10:19.761 --> 21:10:24.761
We're getting a Shiva in you. If
the mod ID number that we get by

20812
21:10:24.761 --> 21:10:29.761
modeling this random word is
between zero and 10. It's going

20813
21:10:29.761 --> 21:10:35.761
to be pug between 10 and 30.
shiba inu between 30 and 100 St.

20814
21:10:36.761 --> 21:10:39.761
Bernard and that's how we get
these randomness values. So now

20815
21:10:39.761 --> 21:10:42.761
that we have this modded RNG, we
have this mod ID number that's

20816
21:10:42.761 --> 21:10:46.761
going to be between zero and 99.
Okay, this function called Get

20817
21:10:46.761 --> 21:10:53.761
breed from modded RNG. And this
is going to take the UN 256 mod

20818
21:10:53.761 --> 21:10:57.761
ID RNG will make this a public
pure function, and it's going to

20819
21:10:57.761 --> 21:11:02.761
return the breed of the dog. Now
the breed of the dog is going to

20820
21:11:02.761 --> 21:11:05.761
be an email similar to raffle
state that we did before. We're

20821
21:11:05.761 --> 21:11:08.761
going to do this right at the
top since this is going to be

20822
21:11:08.761 --> 21:11:14.761
what a type declaration or say
enum. Read, we're going to say

20823
21:11:14.761 --> 21:11:17.762
the zero with number is going to
the pug. The ones number is

20824
21:11:18.762 --> 21:11:22.762
going to be the Shiva in you.
And then the second one is going

20825
21:11:22.762 --> 21:11:27.762
to be the St. Bernard. So we
have the pug which is zero to

20826
21:11:27.762 --> 21:11:33.762
10. Shiva in you 10 to 30 St
Bernard 30 to 100. So get breed

20827
21:11:33.762 --> 21:11:38.762
from modded RNG public pure
returns breed. So we're gonna

20828
21:11:38.762 --> 21:11:40.762
loop through this we're gonna
say you intuitive six cumulative

20829
21:11:40.762 --> 21:11:49.762
sum equals zero, we'll say you
went to 56. size three memory

20830
21:11:49.762 --> 21:11:58.762
chance array equals yet chance
array. So we're getting that

20831
21:11:58.762 --> 21:12:00.762
chance array. So we're going to
create a little for loop we're

20832
21:12:00.762 --> 21:12:06.762
gonna say for you went to 56 i
It's gonna start with zero is

20833
21:12:06.762 --> 21:12:11.762
going to be less than the chance
array dot length. i plus plus

20834
21:12:11.762 --> 21:12:17.762
ran through that for loop here.
And we're going to say if modded

20835
21:12:17.762 --> 21:12:26.762
RNG is greater than or equal to
this cumulative sum and modded

20836
21:12:26.762 --> 21:12:34.762
RNG is less than the cumulative
sum plus chance array plus

20837
21:12:34.762 --> 21:12:41.762
wherever we are on the chance
array, then return breed of AI.

20838
21:12:41.762 --> 21:12:44.762
And then outside of this, we're
gonna say cume cumulative sum

20839
21:12:44.762 --> 21:12:49.762
plus equals chance array of I,
let's say moderate orangey

20840
21:12:49.762 --> 21:12:54.762
equals 25. And if it's 25, it
should be a Shiva in you,

20841
21:12:54.762 --> 21:12:58.763
because that's between 10 and
30. So we're saying if mod RNG,

20842
21:12:58.763 --> 21:13:03.763
which is 25 is greater than or
equal to cumulative sum, which

20843
21:13:03.763 --> 21:13:07.763
right now is zero, and it's less
than n, the Moto G is less than

20844
21:13:07.763 --> 21:13:12.763
the cumulative sum plus the
chance array of I which is going

20845
21:13:12.763 --> 21:13:17.763
to be 10 Return breed of I
cumulative sum is currently zero

20846
21:13:17.763 --> 21:13:24.763
plus chance of I which is 10 is
going to be 10. And this is not

20847
21:13:24.763 --> 21:13:28.763
true because Morarji is 25. So
since this is not true, we're

20848
21:13:28.763 --> 21:13:31.763
going to move to the second step
which is just cumulative sum,

20849
21:13:31.763 --> 21:13:35.763
plus equals chance right? So
cumulative sum will now be equal

20850
21:13:35.763 --> 21:13:38.763
to 10. And then we reached the
end of the for loop. So we'll

20851
21:13:38.763 --> 21:13:42.763
restart i is now one, so let's
try this again mod RNG is

20852
21:13:42.763 --> 21:13:45.763
greater than or equal to
cumulative sum Okay, that is

20853
21:13:45.763 --> 21:13:52.763
true cumulative sum is 10. Mod
RNG is 25. And mod RNG is less

20854
21:13:52.763 --> 21:13:57.763
than cumulative sum plus chance
re of AI, which is 30. So we're

20855
21:13:57.763 --> 21:14:03.763
saying 25 is less than 10 plus
30, which is 40. Return breed of

20856
21:14:03.763 --> 21:14:08.763
AI, this is true. So breed of AI
would be true and AI at the

20857
21:14:08.763 --> 21:14:12.763
moment is one. And if we scroll
up, that's indeed the Shiva in

20858
21:14:12.763 --> 21:14:15.763
you. So that's how this function
is going to work, it's going to

20859
21:14:15.763 --> 21:14:19.763
get us the breed from that
modeling bit. And then if for

20860
21:14:19.763 --> 21:14:22.763
some reason, some really wacky
stuff happens here, we want to

20861
21:14:22.763 --> 21:14:25.763
just go ahead and add a revert,
right, because we should be

20862
21:14:25.763 --> 21:14:28.763
returning a breed. But if we
don't return a breed, we should

20863
21:14:28.763 --> 21:14:32.763
just revert. So we're going to
create a new error at the top,

20864
21:14:32.763 --> 21:14:39.764
random IPFS NFT underscore
underscore range out of bounds.

20865
21:14:39.764 --> 21:14:42.764
The down below, we're just going
to say if for some reason you

20866
21:14:42.764 --> 21:14:47.764
don't return anything, just do a
revert random IPFS NFT range out

20867
21:14:47.764 --> 21:14:51.764
of bounds. And now we have this
function. Okay, so now we can

20868
21:14:51.764 --> 21:14:54.764
get the brief from a modded RNG.
So pack in our fulfill random

20869
21:14:54.764 --> 21:14:59.764
words function. Let's go ahead,
and we'll say, we'll uncomment

20870
21:14:59.764 --> 21:15:06.764
this will say breed, dog breed,
equals get breed for modded RNG

20871
21:15:06.764 --> 21:15:11.764
pass the modded RNG here, and
let's move this safe mint down

20872
21:15:11.764 --> 21:15:15.764
below us getting the dog breeder
so we can mint and add the dog

20873
21:15:15.764 --> 21:15:17.764
breed at the same time. So we're
gonna go ahead and safe mint

20874
21:15:17.764 --> 21:15:23.764
here.

20875
21:15:23.764 --> 21:15:26.764
Now we can do a few things to
set this dog breed here, we

20876
21:15:26.764 --> 21:15:30.764
create a mapping between the dog
breed and the token URI, and

20877
21:15:30.764 --> 21:15:34.764
then have that reflected in this
token URI function. Or what we

20878
21:15:34.764 --> 21:15:38.764
could do is we could just call a
function called Set token URI

20879
21:15:38.764 --> 21:15:41.764
and the openzeppelin ERC 721 You
have to set this token your eye

20880
21:15:41.764 --> 21:15:44.764
function yourself. However,
there is an extension in the

20881
21:15:44.764 --> 21:15:50.764
open Zeppelin code called ERC.
721 Uri storage and this version

20882
21:15:50.764 --> 21:15:55.764
of the ERC. 721 comes with a
function called Set token URI

20883
21:15:55.764 --> 21:15:59.764
where we can just call set token
URI. And this will automatically

20884
21:15:59.764 --> 21:16:04.764
update that tokens token URI to
whatever you set it as. So we're

20885
21:16:04.764 --> 21:16:09.764
going to use this extension this
set token URI in our contract.

20886
21:16:09.764 --> 21:16:12.764
And the way that we do this is
instead of doing token ERC 721

20887
21:16:12.764 --> 21:16:21.765
Year C 721 that soul will do
token ERC 721 slash extensions

20888
21:16:21.765 --> 21:16:27.765
slash your C 721 Your arise
storage. That's all. And we'll

20889
21:16:27.765 --> 21:16:35.765
say random IPFS is ERC 721 your
rice storage. Now what's cool is

20890
21:16:35.765 --> 21:16:41.765
that our constructor will still
just use ERC. 721 Because ERC

20891
21:16:41.765 --> 21:16:48.765
721 Uri storage is extending ERC
721. And then this contract just

20892
21:16:48.765 --> 21:16:52.765
comes with some additional
functions like set token URI. So

20893
21:16:52.765 --> 21:16:56.765
right after safe meant, we're
actually going to call set token

20894
21:16:56.765 --> 21:17:03.765
URI with this new item ID. And
then we're going to give it that

20895
21:17:03.765 --> 21:17:08.765
breeds token URI, we're gonna
give it a string here that

20896
21:17:08.765 --> 21:17:11.765
relates to whatever breed that
we just got based off the dog

20897
21:17:11.765 --> 21:17:15.765
breed here. Now, to do this,
what we could do is right at the

20898
21:17:15.765 --> 21:17:20.765
top and our NFT variables, we
could create a string array,

20899
21:17:20.765 --> 21:17:25.765
internal, Alt S dog token, your
eyes, we're gonna make this

20900
21:17:25.765 --> 21:17:29.765
constant where it would just be
this array of all these strings

20901
21:17:29.765 --> 21:17:32.765
that we created. But maybe in
our code, we want to make this a

20902
21:17:32.765 --> 21:17:36.765
little bit more variable. And we
want to parameterize this. And

20903
21:17:36.765 --> 21:17:38.765
that's exactly what we're going
to do. So we're going to create

20904
21:17:38.765 --> 21:17:42.765
this string array, internal s
underscore dog token, your eyes,

20905
21:17:42.765 --> 21:17:47.765
which is just going to be a list
of these URLs are these URLs

20906
21:17:47.765 --> 21:17:50.765
that point to stuff like this,
we're going to do that in our

20907
21:17:50.765 --> 21:17:54.765
code so that when we upload any
image that we want to IPFS we

20908
21:17:54.765 --> 21:17:58.766
can then upload this s dog token
you arise accordingly. In our

20909
21:17:58.766 --> 21:18:00.766
constructor, we're actually
going to take in another

20910
21:18:00.766 --> 21:18:08.766
parameter called a a string of
size three, memory dog token you

20911
21:18:08.766 --> 21:18:12.766
our eyes, we're going to pass as
a constructor parameter, these

20912
21:18:12.766 --> 21:18:17.766
different dog token you arise.
So we're going to pass it this

20913
21:18:17.766 --> 21:18:21.766
list of dog token arise. Of
course zero is going to be the

20914
21:18:21.766 --> 21:18:24.766
token URI of the pug. One is
going to be the Shiva in you and

20915
21:18:24.766 --> 21:18:26.766
two, of course is going to be
the St. Bernard. So we're going

20916
21:18:26.766 --> 21:18:31.766
to pass it this list of dog
token your eyes, and then down

20917
21:18:31.766 --> 21:18:37.766
in set token your eye from that,
that list that we created. We're

20918
21:18:37.766 --> 21:18:40.766
going to set the token URI of
this token based off of that

20919
21:18:40.766 --> 21:18:48.766
array of the UN 256 version of
that breed are casting this dog

20920
21:18:48.766 --> 21:18:53.766
breed back into you and 256 to
get its index. With that we now

20921
21:18:53.766 --> 21:18:57.766
have a way to actually,
programmatically get a provably

20922
21:18:57.766 --> 21:19:00.766
random NFT with different
randomness for different one of

20923
21:19:00.766 --> 21:19:09.766
these NF T's. Now, let's go back
up to our little, our little

20924
21:19:09.766 --> 21:19:13.766
comments we made here, limited
NFT, we trigger a chain link or

20925
21:19:13.766 --> 21:19:16.766
a VRF. To call random number, we
got the rarities down, we got

20926
21:19:16.766 --> 21:19:20.766
the minting down. Awesome. Okay,
we don't have this part, though.

20927
21:19:20.766 --> 21:19:24.766
Users have to pay to Minton NF T
and the owner of the contract

20928
21:19:24.766 --> 21:19:26.766
can withdraw the eath. Okay,
this is stuff we've already done

20929
21:19:26.766 --> 21:19:29.766
before, this should be pretty
familiar here. So back in our

20930
21:19:29.766 --> 21:19:32.766
request NF t function, we'll
make this a public payable. And

20931
21:19:32.766 --> 21:19:38.767
all we'll need to do is we'll
just say if message dot value is

20932
21:19:38.767 --> 21:19:41.767
less than some mint fee, and
actually let's go back to our

20933
21:19:41.767 --> 21:19:48.767
constructor, we'll create a mint
fee, you int 256 Mint fee.

20934
21:19:48.767 --> 21:19:53.767
And then we'll do you in 256
internal I underscore mint fee,

20935
21:19:53.767 --> 21:19:56.767
we'll make this immutable. And
then we'll just say I'm

20936
21:19:56.767 --> 21:20:01.767
intervene equals mint fee. If
message of value is less than

20937
21:20:01.767 --> 21:20:06.767
mint fee, you already know we're
going to do a revert, need more

20938
21:20:06.767 --> 21:20:11.767
eath sent, we'll create a new
air called need more eath sent

20939
21:20:12.767 --> 21:20:16.767
and actually we'll do air random
IPFS and ft underscore

20940
21:20:16.767 --> 21:20:21.767
underscore need more II sent
like that, copy this, paste it

20941
21:20:21.767 --> 21:20:25.767
here and boom. So now just by
adding this line, this is now a

20942
21:20:25.767 --> 21:20:29.767
payable function. And people
have to pay some mint fee to

20943
21:20:30.767 --> 21:20:34.767
mint their randomized NF t. Now
we're also going to want a way

20944
21:20:34.767 --> 21:20:38.767
for owner to withdraw. So we'll
scroll down a little bit. We'll

20945
21:20:38.767 --> 21:20:43.767
scroll down to here, CREATE
FUNCTION withdraw, this will be

20946
21:20:43.767 --> 21:20:46.767
public. And we only want the
owner to do this. So we could

20947
21:20:46.767 --> 21:20:51.767
create our modifier, you know, a
modifier again only owner, or

20948
21:20:51.767 --> 21:20:53.767
what we could do is use
openzeppelin. Again,

20949
21:20:53.767 --> 21:20:58.767
openzeppelin also comes with
some access code, or one of

20950
21:20:58.767 --> 21:21:03.767
them's this ownable code, and in
here, it already has the only

20951
21:21:03.767 --> 21:21:06.767
owner modifier for us, we're
just gonna go ahead and import

20952
21:21:06.767 --> 21:21:12.767
that as well. We'll do import at
openzeppelin slash contracts

20953
21:21:12.767 --> 21:21:17.768
slash access slash ownable dot
som, and we'll say contract

20954
21:21:17.768 --> 21:21:23.768
random IPFS. And if t is this,
this come ownable. And then

20955
21:21:23.768 --> 21:21:26.768
we'll make our withdrawal
function only owner. And so

20956
21:21:26.768 --> 21:21:29.768
whoever deployed this contract
is going to be set to being the

20957
21:21:29.768 --> 21:21:32.768
owner, which is what we want.
And when here, same as what

20958
21:21:32.768 --> 21:21:39.768
we've done, we'll do u and 256.
amount equals address this dot

20959
21:21:39.768 --> 21:21:47.768
balance. And then we'll do bull
success comma equals payable,

20960
21:21:47.768 --> 21:21:53.768
message dot sender, but call
value is going to be a mount and

20961
21:21:53.768 --> 21:21:56.768
then we're going to call
nothing. And then we're going to

20962
21:21:56.768 --> 21:22:04.768
say if not success. And we're
going to revert with transfer

20963
21:22:04.768 --> 21:22:09.768
failed, then on top, we're going
to do error transfer failed. I'm

20964
21:22:09.768 --> 21:22:14.768
just going to copy this a little
quicker, like so and then come

20965
21:22:14.768 --> 21:22:18.768
back down to transfer failed
paste it here. So we're gonna

20966
21:22:18.768 --> 21:22:22.768
revert random IPFS. And if T
transfer failed, perfect, so now

20967
21:22:22.768 --> 21:22:25.768
we have a withdrawal function
and a way for people to pay for

20968
21:22:25.768 --> 21:22:30.768
art here. Now we don't need this
token URI anymore, because when

20969
21:22:30.768 --> 21:22:35.768
we call set token URI, this is
going to set the token URI for

20970
21:22:35.768 --> 21:22:39.768
us because in the back ERC 721
Uri storage already has that

20971
21:22:39.768 --> 21:22:42.768
function laid out. So our
contract will already have the

20972
21:22:42.768 --> 21:22:45.768
token URI function and we don't
have to explicitly set it

20973
21:22:45.768 --> 21:22:48.768
ourselves. But we do have to
explicitly set some other ones.

20974
21:22:48.768 --> 21:22:52.768
We are going to need function
get meant fee will be a public

20975
21:22:52.768 --> 21:23:01.769
view turns you went to 36 turn I
meant fee will need function get

20976
21:23:01.769 --> 21:23:06.769
dog token your eyes, you went to
36 index, this will be a public

20977
21:23:06.769 --> 21:23:10.769
view which will returns the
string memory return s

20978
21:23:10.769 --> 21:23:17.769
underscore dog token your eyes
index will need function get

20979
21:23:17.769 --> 21:23:24.769
token counter. This will be a
public view turns you into 56

20980
21:23:24.769 --> 21:23:29.769
Return s underscore token
counter. Alright, so we just

20981
21:23:29.769 --> 21:23:32.769
wrote a ton of code here. And of
course as we taught you before,

20982
21:23:32.769 --> 21:23:36.769
we also are going to need some
events. So when we request an NF

20983
21:23:36.769 --> 21:23:43.769
T, we're going to emit an event.
So we'll omit NF T requested and

20984
21:23:43.769 --> 21:23:47.769
then we'll pass it the request.
ID in the message dot sender. So

20985
21:23:47.769 --> 21:23:56.769
up at the top will say event NF
T requested. So pet, take a un

20986
21:23:56.769 --> 21:24:02.769
256 index Request ID, and then
an address requester. And then

20987
21:24:02.769 --> 21:24:05.769
we're also going to make an
event for NF T minted for when

20988
21:24:05.769 --> 21:24:09.769
it's finally minted. And it's
going to take a breed, dog

20989
21:24:09.769 --> 21:24:16.769
breed, and an address, mentor.
So write down when we fulfill,

20990
21:24:16.769 --> 21:24:20.769
we're going to emit NFT. minted.

20991
21:24:20.769 --> 21:24:29.769
And it's going to take that dog
breed and then the dog owner.

20992
21:24:29.769 --> 21:24:34.769
Okay, we've just written a lot
of code here. So let's go ahead

20993
21:24:34.769 --> 21:24:37.770
and see if we can compile this
with H H compile, or yarn

20994
21:24:37.770 --> 21:24:40.770
Hardhead, compile. And Wow,
looks like we went ahead and

20995
21:24:40.770 --> 21:24:44.770
compiled it. This is great. So
all of our code now looks good.

20996
21:24:44.770 --> 21:24:46.770
Now might be a good time to take
a quick breather, we've just

20997
21:24:46.770 --> 21:24:49.770
written a lot of code. And it
might be good to just go over

20998
21:24:49.770 --> 21:24:52.770
all the stuff that we just went
through. A lot of this is

20999
21:24:52.770 --> 21:24:55.770
familiar, but it's still really
good to redo some of this stuff

21000
21:24:55.770 --> 21:24:58.770
and really get that muscle
memory and for these credit, an

21001
21:24:58.770 --> 21:25:01.770
NFT contract that when you mint,
one of these NF T's, you're

21002
21:25:01.770 --> 21:25:06.770
gonna get a pug a Shiva in you
or St. Bernard, based off of

21003
21:25:06.770 --> 21:25:09.770
some rarity, where the pug is
really rare. Ship it in you is

21004
21:25:09.770 --> 21:25:13.770
sort of rare in the St. Bernard
is pretty common. The way we do

21005
21:25:13.770 --> 21:25:17.770
it is we have this request NF t
function, which people have to

21006
21:25:17.770 --> 21:25:21.770
pay to call and it makes a
request to a chain link node to

21007
21:25:21.770 --> 21:25:24.770
get a random number. Once our
contract gets that random number

21008
21:25:24.770 --> 21:25:29.770
uses a chance array to figure
out which one of the NF T's

21009
21:25:29.770 --> 21:25:32.770
we're going to actually use for
this for that minting. And we're

21010
21:25:32.770 --> 21:25:35.770
going to set the token URI
accordingly. And we're going to

21011
21:25:35.770 --> 21:25:40.770
store the image data for this on
IPFS, which we haven't done yet.

21012
21:25:40.770 --> 21:25:43.770
So our deploy function for this
is going to be really the

21013
21:25:43.770 --> 21:25:46.770
interesting part of this
contract. But because we just

21014
21:25:46.770 --> 21:25:48.770
went over so much, if you want
to take a quick break quick

21015
21:25:48.770 --> 21:25:52.770
breather, and then come back, I
encourage you to do so we just

21016
21:25:52.770 --> 21:25:55.770
learned a lot. And we wrote a
lot of solidity code. So go take

21017
21:25:55.770 --> 21:25:57.770
a quick breather, and I'll see
you in a

21018
21:25:57.770 --> 21:26:05.770
minute. So let's go ahead and
get on in here, create a new

21019
21:26:05.770 --> 21:26:15.770
deploy, go to ploy, random
ipfs.js. And now this is going

21020
21:26:15.770 --> 21:26:18.771
to look really similar once
again, to the lottery contract

21021
21:26:18.771 --> 21:26:20.771
that we've already done. And we
can copy some boilerplate from

21022
21:26:21.771 --> 21:26:23.771
our code over here, we're gonna
need all this, we'll just copy

21023
21:26:23.771 --> 21:26:27.771
that, close it off with a little
curly and boom, we've already

21024
21:26:27.771 --> 21:26:29.771
got a boilerplate. Now, since
we're working with chainlink,

21025
21:26:29.771 --> 21:26:32.771
here, we are going to be working
with mocks again. So we're gonna

21026
21:26:32.771 --> 21:26:39.771
come back new file 00, deploy
mocks dot j s. And if you want,

21027
21:26:39.771 --> 21:26:42.771
you can just copy paste from the
earlier section that we did with

21028
21:26:42.771 --> 21:26:44.771
the with the raffle slash
lottery. Since we're going to be

21029
21:26:44.771 --> 21:26:48.771
doing the exact same thing here,
I'm gonna go ahead and pause and

21030
21:26:48.771 --> 21:26:51.771
you can copy paste from your
previous projects. Or if you

21031
21:26:51.771 --> 21:26:54.771
want, once again, you can just
come to the GitHub repo

21032
21:26:54.771 --> 21:26:57.771
associated with this course,
come over to the deploy. And go

21033
21:26:57.771 --> 21:27:00.771
ahead and grab the deploy mocks
right from here. If you grab

21034
21:27:00.771 --> 21:27:03.771
from the GitHub repo, we also
are going to be working with a

21035
21:27:03.771 --> 21:27:06.771
mock v3 aggregator, but I'm not
going to add that part in quite

21036
21:27:06.771 --> 21:27:09.771
yet, because we don't need it
quite yet. So go ahead and pause

21037
21:27:09.771 --> 21:27:12.771
the video right now. Copy and
paste the VRF coordinator mock

21038
21:27:12.771 --> 21:27:16.771
or pause the video and try to
write the mock code yourself.

21039
21:27:16.771 --> 21:27:19.771
Okay, great. So once you've done
that, we're of course gonna need

21040
21:27:19.771 --> 21:27:23.771
to concentrate ID network dot
config dot chain ID, because

21041
21:27:23.771 --> 21:27:25.771
we're gonna need to decide if
we're actually on a development

21042
21:27:25.771 --> 21:27:30.771
chain. So same as what we did
before then we're gonna say if

21043
21:27:30.771 --> 21:27:39.771
development chains that includes
network dot name, then we're

21044
21:27:39.771 --> 21:27:46.771
gonna say const VRF coordinator,
B to mock goes await ethers dot

21045
21:27:46.771 --> 21:27:53.771
get contract VRF. Core. The name
for the to mock similar to the

21046
21:27:53.771 --> 21:27:58.772
raffle we're gonna say let VRF
coordinate Tor v two address,

21047
21:27:58.772 --> 21:28:04.772
same, the VRF coordinator v two
address equals VRF. coordinator

21048
21:28:04.772 --> 21:28:08.772
v two mach mock that address and
then we're going to want to

21049
21:28:08.772 --> 21:28:11.772
create a subscription exactly
the same as what we did with our

21050
21:28:11.772 --> 21:28:17.772
lottery. So we're gonna say
const, TX equals weight VRF

21051
21:28:17.772 --> 21:28:23.772
coordinate tore V to mock dot
create subscription. And then

21052
21:28:23.772 --> 21:28:30.772
we'll do const TX receipt equals
weight, TX dot weight one. And

21053
21:28:30.772 --> 21:28:33.772
we're gonna get the sub ID from
this exactly the same way we did

21054
21:28:33.772 --> 21:28:37.772
it in the lottery section. So
we'll say that we need that sub

21055
21:28:37.772 --> 21:28:45.772
ID by saying sub subscription ID
will say subscription ID equals

21056
21:28:45.772 --> 21:28:52.772
TX receipt, dot events, zero.
That args got somebody. So

21057
21:28:52.772 --> 21:28:57.772
that's what we do if we're on a
development chain, else said the

21058
21:28:57.772 --> 21:29:06.772
VRF coordinate tore V to address
equals network config of the

21059
21:29:06.772 --> 21:29:13.772
chain ID dot VRF coordinate or B
to that then the subscription ID

21060
21:29:13.772 --> 21:29:19.772
equals network config. Chain ID
dot subscription ID. Perfect.

21061
21:29:19.772 --> 21:29:23.772
And then we'll just double check
our helper hard hat config. So

21062
21:29:23.772 --> 21:29:28.772
that Rigby has both the VRF
coordinator v2. And we're also

21063
21:29:28.772 --> 21:29:31.772
going to need a subscription ID.
So right now, I have our

21064
21:29:31.772 --> 21:29:34.772
subscription ID from our past
project from our lottery

21065
21:29:34.772 --> 21:29:38.773
project. But we can go ahead to
V or F dot chain link, we can go

21066
21:29:38.773 --> 21:29:42.773
to V RF, that chain link can
make sure we're on rink B here.

21067
21:29:42.773 --> 21:29:44.773
Let's see our other
subscriptions. And it looks like

21068
21:29:44.773 --> 21:29:49.773
we have one here. So I'm going
to copy this and paste it in for

21069
21:29:49.773 --> 21:29:53.773
Rigby. Now again, we can go over
to DockStar, chain link EVM

21070
21:29:53.773 --> 21:29:56.773
chains, contract addresses for
using reminisce to see more

21071
21:29:57.773 --> 21:30:00.773
parameters in here, especially
for Rigby and make sure these

21072
21:30:00.773 --> 21:30:04.773
are all correct. We have our
subscription here, we'll add a

21073
21:30:04.773 --> 21:30:07.773
new consumer very soon once we
deploy this contract if we're

21074
21:30:07.773 --> 21:30:11.773
actually going to use RankBrain.
So we'll do a little log here

21075
21:30:11.773 --> 21:30:19.773
with a bunch of hyphens. We'll
now get args equals, we'll make

21076
21:30:19.773 --> 21:30:22.773
our arguments here. And what do
we need, we need the coordinator

21077
21:30:22.773 --> 21:30:27.773
subscription, gasoline callback,
address, dog, your dog token,

21078
21:30:27.773 --> 21:30:32.773
your eyes and admin fee. So
we're going to need VRF

21079
21:30:32.773 --> 21:30:39.773
coordinator for the to address
subscription ID. And we'll need

21080
21:30:39.773 --> 21:30:46.773
the network config. Chain ID dot
gas lane. We need the network

21081
21:30:46.773 --> 21:30:53.773
config chain ID dot meant fee,
then we'll leave that work

21082
21:30:53.773 --> 21:30:59.773
config chain ID dot callback gas
limit

21083
21:30:59.773 --> 21:31:03.773
the right order? Yes it is. And
then we need the dog token your

21084
21:31:03.773 --> 21:31:12.773
eyes and the mint fee with the
done here.

21085
21:31:12.773 --> 21:31:16.773
Now what do we not have, we
don't have this array of token

21086
21:31:16.773 --> 21:31:19.774
your eyes. Now we can do this
one of a couple of ways. If you

21087
21:31:19.774 --> 21:31:24.774
go to the GitHub repo associated
with this, go to deploy, we

21088
21:31:24.774 --> 21:31:28.774
actually did the randomness for
oh three in the get here,

21089
21:31:28.774 --> 21:31:30.774
there's one section where we
just automatically say, okay,

21090
21:31:30.774 --> 21:31:33.774
great token, you rise is just
going to be these three. And

21091
21:31:33.774 --> 21:31:37.774
then if we can actually even
copy paste these CDs on IPFS,

21092
21:31:37.774 --> 21:31:41.774
these are the better ones that
actually do have the IPFS as the

21093
21:31:41.774 --> 21:31:44.774
image. And we can see them like
that. So we could just use the

21094
21:31:44.774 --> 21:31:46.774
stuff that I've already
deployed. And if you want to do

21095
21:31:46.774 --> 21:31:51.774
that, you absolutely 100 percent Can,
or what we could do is we get to

21096
21:31:51.774 --> 21:31:55.774
actually learn to upload
programmatically our own images

21097
21:31:55.774 --> 21:31:59.774
to IPFS. That sounds a lot
cooler. So let's go ahead and do

21098
21:31:59.774 --> 21:32:02.774
that. Now what I want you to do,
if you want to use your own

21099
21:32:02.774 --> 21:32:04.774
images for this, feel free to do
so. But if you want to just

21100
21:32:04.774 --> 21:32:08.774
follow along with us, then we're
going to go to the Hardhead NFT

21101
21:32:08.774 --> 21:32:14.774
FCC repo. And we're going to
grab these random NF T's from

21102
21:32:14.774 --> 21:32:17.774
him. So all you can do is you
can come to here. And we can go

21103
21:32:17.774 --> 21:32:20.774
ahead, we can right click Save
Image, Jas, we'll save it to our

21104
21:32:20.774 --> 21:32:23.774
downloads, let's actually create
a new folder, we'll call it

21105
21:32:23.774 --> 21:32:28.774
images. And the images will
create a new folder called

21106
21:32:28.774 --> 21:32:33.774
random, then we can pull it just
right into here, make the name

21107
21:32:33.774 --> 21:32:38.774
random NFT. And this is just
going to be plugged up png. So

21108
21:32:38.774 --> 21:32:42.774
we can do that for all of our
images. Now in our images tag,

21109
21:32:42.774 --> 21:32:46.774
we have the pug ship in you and
St Bernard. So we have these

21110
21:32:46.774 --> 21:32:50.774
locally. But we want to upload
these to IPFS. We want to upload

21111
21:32:50.774 --> 21:32:52.774
them in a way that anybody can
actually pin them and work with

21112
21:32:52.774 --> 21:32:56.774
them. So before we do all this
stuff, where we get the

21113
21:32:56.774 --> 21:32:59.775
arguments to deploy this
contract, we're going to need to

21114
21:32:59.775 --> 21:33:04.775
get the IPFS hashes of our
images. And there's a couple of

21115
21:33:04.775 --> 21:33:09.775
ways we can do this. We do with
our own IPFS node, which I've

21116
21:33:09.775 --> 21:33:13.775
already shown you how to do that
manually, we can also do that

21117
21:33:13.775 --> 21:33:15.775
programmatically. Now, I'm not
going to show you how to do this

21118
21:33:15.775 --> 21:33:19.775
here. However, if you go through
the IPFS documentation, you

21119
21:33:19.775 --> 21:33:22.775
actually can learn how to do
through the command line and

21120
21:33:22.775 --> 21:33:25.775
even through some scripts.
However, if we're the only node

21121
21:33:25.775 --> 21:33:27.775
that's running this, again, it's
kind of centralized. So ideally,

21122
21:33:27.775 --> 21:33:31.775
we'd want these images and these
token your eyes and this and

21123
21:33:31.775 --> 21:33:36.775
this token metadata on our own
IPFS node and some other nodes.

21124
21:33:36.775 --> 21:33:39.775
So the second way that we can
look at this is using something

21125
21:33:39.775 --> 21:33:43.775
like Hinata Hinata is a service
that basically you just pay to

21126
21:33:43.775 --> 21:33:46.775
help pin NF T for you. And this
is going to be the one that

21127
21:33:46.775 --> 21:33:49.775
we're going to be looking at
here. Now the issue with binotto

21128
21:33:49.775 --> 21:33:52.775
of course, is that we're just
paying once single centralized

21129
21:33:52.775 --> 21:33:55.775
entity to go ahead and pin our
data, we're kind of trusting

21130
21:33:55.775 --> 21:33:57.775
that they're actually going to
pin it and that they're not

21131
21:33:57.775 --> 21:34:01.775
going to go down. The final way
that we could look into actually

21132
21:34:01.775 --> 21:34:04.775
getting our data is was this
thing called NF T dot storage.

21133
21:34:04.775 --> 21:34:07.775
And if T dot storage uses the
file coin network on the back

21134
21:34:07.775 --> 21:34:11.775
end to pin our data now filecoin
is a blockchain dedicated to

21135
21:34:11.775 --> 21:34:16.775
pinning IPFS data and storing
decentralized data. For us, the

21136
21:34:16.775 --> 21:34:19.775
process is a little bit more
complicated. But NFT dot storage

21137
21:34:19.775 --> 21:34:22.775
makes it really, really easy.
Now, we're not going to go over

21138
21:34:22.775 --> 21:34:26.775
using NFT dot storage in this
video. However, if you want to

21139
21:34:26.775 --> 21:34:29.775
look into NF T dot storage, for
putting your data in the GitHub

21140
21:34:29.775 --> 21:34:32.775
repo associated with this
course, we do have a script that

21141
21:34:32.775 --> 21:34:36.775
uploads your code to NFT to
storage called in the utils

21142
21:34:36.775 --> 21:34:39.776
folder, upload to NFT. Storage.
And if you want to go and try it

21143
21:34:39.776 --> 21:34:42.776
out, I recommend that you do so
working with NF T dot storage

21144
21:34:42.776 --> 21:34:45.776
will be one of the most
persistent ways to keep our data

21145
21:34:45.776 --> 21:34:48.776
up. But it's still good to
upload your own data to your own

21146
21:34:48.776 --> 21:34:52.776
IPFS node, which we've learned
how to do manually and at least

21147
21:34:52.776 --> 21:34:54.776
get one other person also
pinning your data. And then

21148
21:34:54.776 --> 21:34:58.776
ideally, an entire decentralized
network, pinning your data,

21149
21:34:58.776 --> 21:35:02.776
which is what NFS storage helps
you do. But for now, for us,

21150
21:35:02.776 --> 21:35:04.776
we're just going to work with
pinata to keep it nice and

21151
21:35:04.776 --> 21:35:08.776
simple for this video. And then
uploading uploading our metadata

21152
21:35:08.776 --> 21:35:11.776
and our token, your eyes up to
IPFS will give us this list of

21153
21:35:12.776 --> 21:35:15.776
token your eyes for our three
dogs. So up at the top here,

21154
21:35:15.776 --> 21:35:19.776
we're going to do a little if
we're gonna say if process dot e

21155
21:35:19.776 --> 21:35:25.776
NV dot upload to pinata equals
true, yes, we're going to use

21156
21:35:25.776 --> 21:35:29.776
the string true like that. Then
we're going to upload to pinata.

21157
21:35:29.776 --> 21:35:33.776
Above here we're going to say
let's token your eyes. And we're

21158
21:35:33.776 --> 21:35:36.776
gonna say token your eyes equals
await,

21159
21:35:36.776 --> 21:35:40.776
handle token your eyes. And
we're going to create a function

21160
21:35:40.776 --> 21:35:43.776
called handle token your eyes,
which is going to upload our

21161
21:35:43.776 --> 21:35:46.776
code to pinata down outside of
this, we're going to create a

21162
21:35:46.776 --> 21:35:52.776
new function called async.
function. And we'll token your

21163
21:35:52.776 --> 21:35:56.776
eyes. And this is going to
return an array of token your

21164
21:35:56.776 --> 21:35:59.776
eyes for us to upload to our
smart contract, we're gonna say

21165
21:35:59.776 --> 21:36:03.776
token, your eyes equals this and
then way at the bottom, we're

21166
21:36:03.776 --> 21:36:06.776
gonna say return token your
rise, right, so we're going to

21167
21:36:06.776 --> 21:36:10.776
be returning this array here.
Now we need to do two things, we

21168
21:36:10.776 --> 21:36:16.776
need to both store the image in
IPFS. And then we need to store

21169
21:36:16.776 --> 21:36:20.777
the metadata in IPFS. So first,
we're going to create a store

21170
21:36:21.777 --> 21:36:23.777
images function. And this is
where we're going to actually

21171
21:36:23.777 --> 21:36:25.777
get to go to our utils. And
we're going to create a new

21172
21:36:25.777 --> 21:36:29.777
folder in here, we're going to
create a file called New File,

21173
21:36:29.777 --> 21:36:34.777
Upload to pinata dot j s, we're
going to add all of our code for

21174
21:36:34.777 --> 21:36:38.777
actually uploading to pinata in
here. Because again, pinata is

21175
21:36:38.777 --> 21:36:42.777
this service that we're going to
be using to just pin data for us

21176
21:36:42.777 --> 21:36:46.777
and work with pinata, we can go
ahead, try for free. And we can

21177
21:36:46.777 --> 21:36:56.777
create our own application.

21178
21:36:56.777 --> 21:37:00.777
And we're good to go. See the
setup here looks really similar

21179
21:37:00.777 --> 21:37:03.777
to an IPFS node, because that's
essentially what pinata is. It's

21180
21:37:03.777 --> 21:37:07.777
just an IPFS node, run by
somebody else. And we can say,

21181
21:37:07.777 --> 21:37:11.777
Hey, can you please pin this
data for us. So a manual way we

21182
21:37:11.777 --> 21:37:15.777
could do this is we could just
hit Upload Cid just like an IPFS

21183
21:37:15.777 --> 21:37:19.777
node and put the hash of some
IPFS file, and pinata would pin

21184
21:37:19.777 --> 21:37:23.777
it for us, we could also upload
a file or a folder just like an

21185
21:37:23.777 --> 21:37:26.777
IPFS node. But for us, we're
just going to leave this blank

21186
21:37:26.777 --> 21:37:29.777
because we're going to want to
do this programmatically,

21187
21:37:29.777 --> 21:37:32.777
because we're engineers. So what
we can do is we come over to our

21188
21:37:32.777 --> 21:37:36.777
profile, we'll open up API keys
and documentation. And the

21189
21:37:36.777 --> 21:37:39.777
documentation pretty much has
everything that we need to get

21190
21:37:39.777 --> 21:37:44.777
started. If you scroll down to
the pinata Node js SDK, this is

21191
21:37:44.777 --> 21:37:46.777
basically what we're going to be
working with, they've already

21192
21:37:46.777 --> 21:37:49.777
created an SDK for us that we
can work with, we're gonna go

21193
21:37:49.777 --> 21:37:53.777
ahead and install this pinata
SDK. So they're using NPM,

21194
21:37:53.777 --> 21:37:57.777
install dash to save, we're just
gonna go ahead and use yarn, add

21195
21:37:57.777 --> 21:38:02.778
dash dash dev at pinata dash
SDK, and they have all these

21196
21:38:02.778 --> 21:38:05.778
different endpoints, we can call
to actually pin data, we're

21197
21:38:05.778 --> 21:38:08.778
going to be doing pin file to
IPFS, because we're going to

21198
21:38:08.778 --> 21:38:14.778
upload our files and also pin
JSON to IPFS. Since JSON is

21199
21:38:14.778 --> 21:38:17.778
going to be the metadata, and
file is going to be the actual

21200
21:38:17.778 --> 21:38:20.778
image. And if you click on it,
it'll even give you kind of the

21201
21:38:20.778 --> 21:38:23.778
output of the SDK here. So back
in our code, now that we've

21202
21:38:23.778 --> 21:38:26.778
downloaded this, we can go ahead
and start creating this. So

21203
21:38:26.778 --> 21:38:31.778
we'll say const pinata SDK
equals require at pinata slash

21204
21:38:31.778 --> 21:38:36.778
SDK, and then we'll create a
function async function called

21205
21:38:36.778 --> 21:38:41.778
store images, it'll take an
images file path. So we're going

21206
21:38:41.778 --> 21:38:45.778
to use this function will pass
it our images, random n of t

21207
21:38:45.778 --> 21:38:48.778
file paths, and we're going to
have it store everything in that

21208
21:38:48.778 --> 21:38:51.778
folder to help us work with
paths. We're also going to

21209
21:38:51.778 --> 21:38:56.778
Install this path package. So
we're gonna do yarn, add dash

21210
21:38:56.778 --> 21:38:59.778
dash dev path, like, so, we're
just going to work with Fs as

21211
21:38:59.778 --> 21:39:03.778
well not Fs extra. So now that
that's up, we're gonna say

21212
21:39:03.778 --> 21:39:08.778
const. Path equals require path.
And in here, we're gonna say

21213
21:39:08.778 --> 21:39:16.778
const, full images, path, equals
path dot resolve, images file

21214
21:39:16.778 --> 21:39:21.778
path. So if we give that like
dot slash images, slash random,

21215
21:39:21.778 --> 21:39:25.778
you know, NF T or whatever, this
will just give us give you the

21216
21:39:25.778 --> 21:39:28.778
full output of the path. So
we're getting the full images

21217
21:39:28.778 --> 21:39:32.778
path, and then we'll say, we'll
get those files by doing const

21218
21:39:32.778 --> 21:39:37.778
files equals Fs. So we'll do
we'll grab s will say const Fs

21219
21:39:37.778 --> 21:39:43.779
equals require Fs just to read
these files in here, that read

21220
21:39:43.779 --> 21:39:47.779
DirSync. We're just going to
read the entire directory and

21221
21:39:47.779 --> 21:39:53.779
get our files back to read
DirSync full images path. And to

21222
21:39:53.779 --> 21:39:57.779
actually test that this is
working, what we're going to do

21223
21:39:57.779 --> 21:40:03.779
is we're going to do module dot
exports, equals store images.

21224
21:40:03.779 --> 21:40:06.779
And then back in our deploy
script here, we can just go

21225
21:40:06.779 --> 21:40:08.779
ahead and

21226
21:40:08.779 --> 21:40:16.779
comment out args. And we can do
import const, store images

21227
21:40:16.779 --> 21:40:22.779
equals require dot dot slash
utils, slash upload to pinata.

21228
21:40:22.779 --> 21:40:25.779
And in this script, we could
just do a little, we just call

21229
21:40:25.779 --> 21:40:31.779
this we could say await, or
images, and then we'll pass pass

21230
21:40:31.779 --> 21:40:35.779
our images location, maybe way
at the top, even outside of the

21231
21:40:35.779 --> 21:40:42.779
function, we'll say const images
location equals dot slash images

21232
21:40:42.779 --> 21:40:47.779
slash random and ft. So we'll do
a weight store images like that.

21233
21:40:47.779 --> 21:40:51.779
And we should be able to run
Hardhead deploy. Then if we add

21234
21:40:51.779 --> 21:40:57.779
some tags to this deploy thing,
module, dot exports, dot tags

21235
21:40:57.779 --> 21:41:03.779
equals, we'll say all random
IPFS. And then main, we do

21236
21:41:03.779 --> 21:41:09.779
Hardhead deployed dash dash
tags, random IPFS will also do

21237
21:41:09.779 --> 21:41:14.779
mocks believe, and I need to
create a test folder in here New

21238
21:41:14.779 --> 21:41:20.780
Folder test. And we need to add
that VF coordinator v2 Mock in

21239
21:41:20.780 --> 21:41:23.780
here. So again, I'm just copy
pasting the VRF coordinator v2

21240
21:41:23.780 --> 21:41:28.780
Mock from our raffle project.
Feel free to pause, copy, paste

21241
21:41:28.780 --> 21:41:31.780
it over, or again, everything's
available on the GitHub. So

21242
21:41:31.780 --> 21:41:35.780
we'll try one more time. Tags,
random IPFS, and mocks and boom,

21243
21:41:35.780 --> 21:41:40.780
okay, mocks deployed and perfect
pug dot png ship any png St.

21244
21:41:40.780 --> 21:41:44.780
Bernard PNG. Great. So we're
getting the files correctly

21245
21:41:44.780 --> 21:41:49.780
here. Now let's create a little
array for responses from the

21246
21:41:49.780 --> 21:41:52.780
pinata server. So we'll say
responses equals this. And we'll

21247
21:41:52.780 --> 21:41:58.780
say for each file index in files
for each one of these files in

21248
21:41:58.780 --> 21:42:04.780
here, we're gonna say const
readable stream for file equals

21249
21:42:04.780 --> 21:42:17.780
Fs dot create read stream of the
full images path slash files of

21250
21:42:17.780 --> 21:42:21.780
file index. What does this line
doing? Well, we're creating a

21251
21:42:21.780 --> 21:42:25.780
read stream. Since this is an
image file, it doesn't work

21252
21:42:25.780 --> 21:42:28.780
exactly the same as just like
push this data, right? We have

21253
21:42:28.780 --> 21:42:31.780
to create a stream where we
stream all the data inside of

21254
21:42:31.780 --> 21:42:34.780
these images. Because these
images, even though they're just

21255
21:42:34.780 --> 21:42:37.780
like a cute little image here,
they're really this kind of this

21256
21:42:37.780 --> 21:42:40.780
big file with all this bytes and
all this data in here, and then

21257
21:42:40.780 --> 21:42:46.780
we're going to send it by doing
try, we'll say const response

21258
21:42:46.780 --> 21:42:50.780
equals await. And this is where
we're going to do pinata stuff.

21259
21:42:50.780 --> 21:42:54.780
If we go back to the pinata
docks, there's some stuff about

21260
21:42:54.780 --> 21:42:57.780
keys in here. What we can do, if
you go to your profile, go to

21261
21:42:57.780 --> 21:43:02.781
API keys, we can create a new
key, we'll say this is an admin

21262
21:43:02.781 --> 21:43:06.781
key, why not? We'll give it all
the pinning access here. Maybe

21263
21:43:06.781 --> 21:43:07.781
we'll give it this, maybe we'll
just give it everything,

21264
21:43:07.781 --> 21:43:11.781
whatever you want to do. And
then we'll call this hard hat,

21265
21:43:11.781 --> 21:43:17.781
Free Code Camp key, create key.
Now we're going to want to grab

21266
21:43:17.781 --> 21:43:21.781
these and drop these into a dot
env. So the API key, go ahead

21267
21:43:21.781 --> 21:43:26.781
and copy, come back over here.
Open up our dot env. And we're

21268
21:43:26.781 --> 21:43:33.781
gonna call it our pinata. And
data API key equals that key.

21269
21:43:33.781 --> 21:43:39.781
We're going to grab the API
secret and say pinata API secret

21270
21:43:39.781 --> 21:43:42.781
equals that key. We don't need
this massive token here for what

21271
21:43:42.781 --> 21:43:44.781
we're going to do. But if you
want it, you can absolutely have

21272
21:43:44.781 --> 21:43:47.781
it. And then outside of our
store images, we're going to say

21273
21:43:47.781 --> 21:43:54.781
const pinata API key equals
price says, do you need that

21274
21:43:54.781 --> 21:44:03.781
pinata API key? And then can't
pinata. API secret equals

21275
21:44:03.781 --> 21:44:09.781
process dot E and V dot pinata
API secret. And then we'll say

21276
21:44:09.781 --> 21:44:19.781
const. pinata equals pin auta s.
DK of pinata

21277
21:44:19.781 --> 21:44:24.781
API key comma, pinata API.
Secret in order to work with

21278
21:44:24.781 --> 21:44:29.781
pinata, we need to pass it an
API key and API secret so that

21279
21:44:29.781 --> 21:44:32.781
pinata knows it's us who's
working with them. So once we

21280
21:44:32.781 --> 21:44:38.781
initialize this pinata thing, we
can now run pinata dot and then

21281
21:44:38.781 --> 21:44:42.782
do some pinata stuff, right, we
want to work with this pin file

21282
21:44:42.782 --> 21:44:45.782
to IPFS, which takes this
readable stream, which is why we

21283
21:44:45.782 --> 21:44:52.782
created that readable string, so
pinata that pin file to IPFS. Of

21284
21:44:52.782 --> 21:44:58.782
readable stream or file. And
then we're going to push this

21285
21:44:58.782 --> 21:45:02.782
response on to our responses
array. So we'll say responses

21286
21:45:02.782 --> 21:45:06.782
dot push response. And then
we're going to catch error, just

21287
21:45:06.782 --> 21:45:09.782
in case there's some weird error
here. And we'll just say console

21288
21:45:09.782 --> 21:45:14.782
dot log error, and then we're
going to return responses and

21289
21:45:14.782 --> 21:45:18.782
files. So we're going to return
all the responses from pushing

21290
21:45:18.782 --> 21:45:22.782
all these files up, and then the
files as well. Now, at this

21291
21:45:22.782 --> 21:45:25.782
current point, we can go ahead
and actually test this out

21292
21:45:25.782 --> 21:45:28.782
ourselves. So we have this in
here. If we go back to our

21293
21:45:28.782 --> 21:45:31.782
deploy, at the top, we have this
if process dot E and V dot

21294
21:45:31.782 --> 21:45:37.782
upload to Niada equals true, do
this stuff here, uploading to

21295
21:45:37.782 --> 21:45:40.782
IPFS. And the final thing we
need to do in here, of course,

21296
21:45:40.782 --> 21:45:48.782
is going to be require dot env
dot config, so that we can pull

21297
21:45:48.782 --> 21:45:52.782
in our dot env file. Down here,
we're just doing a weight store

21298
21:45:52.782 --> 21:45:57.782
images. So if we run this as is,
it should go ahead and store

21299
21:45:57.782 --> 21:46:02.782
images. So let's run that same
command, or that deploy random

21300
21:46:02.782 --> 21:46:05.782
IPFS and the MOX to run this
store images command. And if we

21301
21:46:05.782 --> 21:46:09.782
come back to our pinata, after
we run it, we'll be able to see

21302
21:46:09.782 --> 21:46:15.782
the code uploaded here. If we
run now, the script loaded IPFS

21303
21:46:15.782 --> 21:46:17.782
it'll give us a little bit of a
delay, because it needs to

21304
21:46:17.782 --> 21:46:22.783
upload these big picture files
to IPFS. or more correctly.

21305
21:46:22.783 --> 21:46:27.783
pinata, I'm gonna say uploading
to nada. And we could even say,

21306
21:46:27.783 --> 21:46:35.783
console dot log, working on file
index, done Excel. And okay,

21307
21:46:35.783 --> 21:46:38.783
great. It looks like it finished
running. So if we come back to

21308
21:46:38.783 --> 21:46:43.783
our project here, and we do a
little refresh, we see our three

21309
21:46:43.783 --> 21:46:46.783
files have been uploaded, and we
see they each come with their

21310
21:46:46.783 --> 21:46:51.783
own CID. Now, if you want, you
can go ahead and copy the CID.

21311
21:46:51.783 --> 21:46:55.783
And if you have your IPFS node,
what you can do, what we can do

21312
21:46:55.783 --> 21:47:00.783
is actually we can hit import
from IPFS. Paste it in here. And

21313
21:47:00.783 --> 21:47:05.783
we can say exactly what this is,
which is IPFS dot dot slash last

21314
21:47:05.783 --> 21:47:10.783
as the St. Bernard called St.
Bernard. Important. And now

21315
21:47:10.783 --> 21:47:14.783
we'll have it pinned on our
IPFS. I've got mine saved in a

21316
21:47:14.783 --> 21:47:17.783
little puppies file. Now that
we've got them uploaded, and

21317
21:47:17.783 --> 21:47:20.783
pinata do actually recommend you
pin your own on your own node as

21318
21:47:20.783 --> 21:47:25.783
well. So cool. So we've got a
way to get those images up onto

21319
21:47:25.783 --> 21:47:26.783
IPFS. Awesome

21320
21:47:26.783 --> 21:47:34.783
onto. Now that we've done that,
we're also going to need to

21321
21:47:34.783 --> 21:47:39.783
store the token URI metadata. So
let's go ahead and we'll delete

21322
21:47:39.783 --> 21:47:43.783
that for now. What we can do
back in here, is back up at the

21323
21:47:43.783 --> 21:47:49.783
top again, we can say const meta
data, template equals and we'll

21324
21:47:49.783 --> 21:47:53.783
create a metadata template. This
is going to have all the basics

21325
21:47:53.783 --> 21:47:57.783
of what we need for our metadata
for our token URI. So in here,

21326
21:47:57.783 --> 21:48:02.784
we'll have a name, set, it's
blank, we'll have a description,

21327
21:48:02.784 --> 21:48:06.784
which will also set as blank
will have the image which this

21328
21:48:06.784 --> 21:48:10.784
is going to be replaced with the
image URI that IPFS URI we just

21329
21:48:10.784 --> 21:48:14.784
created. And if you want to give
your NFT like any types of

21330
21:48:14.784 --> 21:48:20.784
stats, you can do some you can
create this Attributes section

21331
21:48:20.784 --> 21:48:26.784
like so. And if you give it like
traits type, cuteness, comma,

21332
21:48:26.784 --> 21:48:29.784
value 100. And this is how if
you wanted to create like

21333
21:48:29.784 --> 21:48:33.784
different cards or have
different attack, defense, HP

21334
21:48:33.784 --> 21:48:37.784
speed in different different
stats for your NF T's, you would

21335
21:48:37.784 --> 21:48:40.784
add them in this Attributes
section. Typically, you'd want

21336
21:48:40.784 --> 21:48:43.784
these attributes also stored on
chain so your contracts can

21337
21:48:43.784 --> 21:48:46.784
obviously programmatically
interact with these attributes.

21338
21:48:46.784 --> 21:48:49.784
But so now we have this metadata
data template. This is what

21339
21:48:49.784 --> 21:48:52.784
we're going to fill out for each
one of our dogs. Yes, we're

21340
21:48:52.784 --> 21:48:57.784
going to create a new function
in here called async, store

21341
21:48:57.784 --> 21:49:03.784
token URI metadata. And we'll
pass in the meta data to the

21342
21:49:03.784 --> 21:49:07.784
async function. And we'll pass
in the metadata that we get from

21343
21:49:07.784 --> 21:49:10.784
our script over here. So we have
this little template here. And

21344
21:49:10.784 --> 21:49:14.784
we're going to populate this
template based off of what we

21345
21:49:14.784 --> 21:49:17.784
get from storing data in IPFS.
So now we're going to write the

21346
21:49:17.784 --> 21:49:20.784
rest of this handle token your
eyes bit. And so we're going to

21347
21:49:20.784 --> 21:49:23.784
want to do in our data and V,
we're going to say, upload to

21348
21:49:23.784 --> 21:49:28.784
pinata equals true, so that we
can do everything and handle

21349
21:49:28.784 --> 21:49:31.784
token your eyes. So upload to
pinata, it's true, we'll scroll

21350
21:49:31.784 --> 21:49:34.784
down, we'll start creating this.
So the first thing we got to do,

21351
21:49:34.784 --> 21:49:37.784
obviously, we're gonna want to
get those responses and those

21352
21:49:37.784 --> 21:49:41.785
files, right, because it's in
the responses, pin file to IPFS

21353
21:49:41.785 --> 21:49:45.785
is going to return the hash of
the file, right, and we need

21354
21:49:45.785 --> 21:49:48.785
that hash, to add to our
metadata. So we're going to do

21355
21:49:48.785 --> 21:49:52.785
is down here, we're gonna say
const, responses, which is going

21356
21:49:52.785 --> 21:50:00.785
to be image upload, responses,
comma files, equals await, store

21357
21:50:00.785 --> 21:50:06.785
images, and then images,
location. And so this response

21358
21:50:06.785 --> 21:50:11.785
is, is going to be a list of
these responses from pinata. And

21359
21:50:11.785 --> 21:50:14.785
these responses are going to
have the hash of each one of

21360
21:50:14.785 --> 21:50:17.785
these uploaded files. So now
we're going to loop through that

21361
21:50:17.785 --> 21:50:20.785
list and upload each of the
metadata does. So we're going to

21362
21:50:20.785 --> 21:50:29.785
say for each image upload
response index, in image upload

21363
21:50:29.785 --> 21:50:31.785
responses.

21364
21:50:31.785 --> 21:50:34.785
For each one of these, we're
going to create the metadata,

21365
21:50:34.785 --> 21:50:38.785
we're going to create metadata
and then upload the metadata. So

21366
21:50:38.785 --> 21:50:45.785
we're gonna say let token URI,
metadata equals dot dot, dot

21367
21:50:45.785 --> 21:50:50.785
meta data template. So this is
some fun JavaScript, syntactic

21368
21:50:50.785 --> 21:50:54.785
sugar, which kind of means like,
unpack. So basically, we're

21369
21:50:54.785 --> 21:50:57.785
saying token URI metadata is
going to be equal to this stuff.

21370
21:50:57.785 --> 21:51:01.785
We're sticking all this stuff
into this token, your metadata

21371
21:51:01.785 --> 21:51:05.785
variable, now we're gonna say
token, your metadata. dot name

21372
21:51:05.785 --> 21:51:13.785
is going to be equal to files
of, of the index, dot replace,

21373
21:51:13.785 --> 21:51:17.785
dot png, dot png with nothing.
So files is going to be each one

21374
21:51:17.785 --> 21:51:22.786
of those files, right? It's
going to be dot png can be St

21375
21:51:22.786 --> 21:51:26.786
Bernard dot PNG, and it's going
to be Shiva dot png. And

21376
21:51:26.786 --> 21:51:28.786
basically, all we're doing is
we're saying, okay, cool, the

21377
21:51:28.786 --> 21:51:31.786
name inside of our token,
metadata is just going to be

21378
21:51:31.786 --> 21:51:34.786
pug. So we're just going to drop
the extension, basically. So

21379
21:51:34.786 --> 21:51:39.786
that's how we're gonna get the
name token, your AI metadata dot

21380
21:51:39.786 --> 21:51:46.786
description, is going to be
equal to and adore a bowl. And

21381
21:51:46.786 --> 21:51:50.786
then we're just going to get the
name, token URI metadata dot

21382
21:51:50.786 --> 21:51:53.786
name. So it's going to be an
adorable pug pup and adorable

21383
21:51:53.786 --> 21:51:57.786
St. Bernard pop or an adorable
ship and you pup token URI

21384
21:51:57.786 --> 21:52:01.786
metadata dot image, which is
probably the most important one

21385
21:52:01.786 --> 21:52:05.786
here, this is going to be, it's
going to be that IPFS extension

21386
21:52:05.786 --> 21:52:10.786
with the IPFS hash that we get
from the response. So we can get

21387
21:52:10.786 --> 21:52:19.786
that by doing image, upload
responses of the image upload

21388
21:52:19.786 --> 21:52:26.786
response index dot i IPFS. Hash,
so we can go to the pinata docs.

21389
21:52:26.786 --> 21:52:31.786
And we can see pin file to IPFS
returns in IPFS hash, the pin

21390
21:52:31.786 --> 21:52:36.786
size and the timestamp, all we
care about is the IPFS hash. And

21391
21:52:36.786 --> 21:52:41.786
we're going to use that to give
the our metadata image here. And

21392
21:52:41.786 --> 21:52:45.786
then finally, I'll do a little
console dot log uploading. And

21393
21:52:45.786 --> 21:52:52.786
then we'll say, token, your eye
metadata dot name, dot dot dot.

21394
21:52:52.786 --> 21:52:58.786
And now we'll have to store the
file or store store the JSON to

21395
21:52:58.786 --> 21:53:02.787
pinata slash IPFS. And this is
where in our upload to pinata

21396
21:53:02.787 --> 21:53:05.787
bit here, we're going to add
this function here. So we have

21397
21:53:05.787 --> 21:53:08.787
store token URI metadata. And
all we're gonna do in here, so

21398
21:53:08.787 --> 21:53:13.787
we're gonna say try const
response equals await, and nada,

21399
21:53:13.787 --> 21:53:20.787
that pin JSON to IPFS of the
metadata, right. And again, we

21400
21:53:20.787 --> 21:53:25.787
have, we want pin JSON to IPFS,
which is going to be really

21401
21:53:25.787 --> 21:53:29.787
similar. So we need to pass the
body, which is going to be the

21402
21:53:29.787 --> 21:53:31.787
JSON. And we have some optional
stuff here, but it's gonna give

21403
21:53:31.787 --> 21:53:36.787
us the same return the IPFS hash
pin, size and timestamp. And

21404
21:53:36.787 --> 21:53:39.787
then if this works, well, we're
just going to do return

21405
21:53:39.787 --> 21:53:43.787
response. Otherwise, we'll do
catch error. And then we'll just

21406
21:53:43.787 --> 21:53:50.787
do console dot log error, and
then we'll just do return null

21407
21:53:50.787 --> 21:53:53.787
and then we'll exports or token
URI metadata. And then back in

21408
21:53:54.787 --> 21:53:58.787
our deploy, we'll go ahead and
import this store token URI

21409
21:53:58.787 --> 21:54:04.787
metadata. And we'll scroll down.
And they'll do const, metadata,

21410
21:54:04.787 --> 21:54:10.787
upload response equals await,
store token URI metadata where

21411
21:54:10.787 --> 21:54:15.787
we pass the token, Uri,
metadata. And now finally, and

21412
21:54:15.787 --> 21:54:19.787
now with all of these metadata
is being uploaded are finally

21413
21:54:19.787 --> 21:54:22.787
going to have the token you
arise that we need. So we'll

21414
21:54:22.787 --> 21:54:28.787
say, token, your eyes dot push,
IPFS, slash slash, and then the

21415
21:54:28.787 --> 21:54:33.787
metadata response here, metadata
upload response dot IPFS. Hash.

21416
21:54:33.787 --> 21:54:37.787
So we finally will have this
array of IPFS hashes that points

21417
21:54:37.787 --> 21:54:40.788
to the metadata, and each one of
these metadata are pointing to

21418
21:54:40.788 --> 21:54:44.788
the image. And then we'll do a
little console dot log token.

21419
21:54:44.788 --> 21:54:50.788
You arise, uploaded, they are
and then we'll do another little

21420
21:54:50.788 --> 21:54:56.788
console dot log token your eyes.
Oh, all right. So let's go ahead

21421
21:54:56.788 --> 21:55:00.788
and run this. And let's see if
it works. In our pinata, we

21422
21:55:00.788 --> 21:55:04.788
should see both the images and
then also the metadata. If

21423
21:55:04.788 --> 21:55:08.788
process dot E and V dot upload
to pinata equals true, looks

21424
21:55:08.788 --> 21:55:12.788
like it is true. And we should
run this and handle token, your

21425
21:55:12.788 --> 21:55:17.788
eyes will both upload our images
with store images here and then

21426
21:55:17.788 --> 21:55:21.788
upload our metadata. We'll only
see it in here once because

21427
21:55:21.788 --> 21:55:24.788
again, it's gonna have the exact
same Cid right, it's gonna have

21428
21:55:24.788 --> 21:55:28.788
the same hash, so we won't get
duplicates of the same file in

21429
21:55:28.788 --> 21:55:33.788
pinata, or in our IPFS. So let's
open this up. Let's run this one

21430
21:55:33.788 --> 21:55:37.788
more time, or had deployed dash
dash tags, random IPFS and

21431
21:55:37.788 --> 21:55:40.788
mocks. Okay, it looks like we
almost worked uploading to

21432
21:55:40.788 --> 21:55:44.788
banana working on zero working
on one working on two metadata

21433
21:55:44.788 --> 21:55:50.788
template is not defined. Ha,
because I spelt meta data

21434
21:55:50.788 --> 21:55:55.788
template, meta data template,
let's spell things correctly.

21435
21:55:55.788 --> 21:55:58.788
Now let's try this again, it
working on zero is it working on

21436
21:55:58.788 --> 21:56:02.788
two image upload response is not
defined. I should spell

21437
21:56:02.788 --> 21:56:07.788
correctly. There we go. Let's,
let's do our caps correctly.

21438
21:56:07.788 --> 21:56:11.788
Let's try this one more time.
Okay, 012, uploading pug

21439
21:56:11.788 --> 21:56:14.788
uploading Shiva in you uploading
St. Bernard token your eyes

21440
21:56:14.788 --> 21:56:18.789
upload it and they're here. Now
if we grab this, and stick it

21441
21:56:18.789 --> 21:56:22.789
into our browser, or your IPFS
node, boom, we have them in

21442
21:56:22.789 --> 21:56:26.789
here. And what we can do is we
can grab this hash, we can jump

21443
21:56:26.789 --> 21:56:32.789
into our IPFS desktop, go to
files, we import from IPFS paste

21444
21:56:32.789 --> 21:56:35.789
it in here. And you know give it
the name etc, that we have it on

21445
21:56:35.789 --> 21:56:39.789
our own IPFS node as well.
Awesome. Now if we go over to

21446
21:56:39.789 --> 21:56:43.789
pinata give this a little
refresh, we can see we have

21447
21:56:43.789 --> 21:56:47.789
everything in here. So if I copy
one of these, and I go to IPFS

21448
21:56:47.789 --> 21:56:51.789
dot dot slash paste that in, we
can see the metadata in here.

21449
21:56:51.789 --> 21:56:55.789
And everything looks good. So
this is absolutely massive that

21450
21:56:55.789 --> 21:56:58.789
we've just done this because now
we can store data both on our

21451
21:56:58.789 --> 21:57:02.789
own IPFS node and at least one
other nodes so that if our

21452
21:57:02.789 --> 21:57:04.789
computer goes down or our server
goes down, and there's at least

21453
21:57:04.789 --> 21:57:11.789
somebody else who's done it.

21454
21:57:11.789 --> 21:57:14.789
Now we finally have this list of
token your eyes, we can finally

21455
21:57:14.789 --> 21:57:20.789
go back to our arguments. And
now we can do like this. And we

21456
21:57:20.789 --> 21:57:23.789
can upload all of those token
your eyes to our smart contract.

21457
21:57:23.789 --> 21:57:26.789
And then we're going to need a
mint fee as well for this. So if

21458
21:57:26.789 --> 21:57:29.789
we go to our upper heart at
config will create like a little

21459
21:57:29.789 --> 21:57:33.789
mint fee in here, say mint fee
is going to be whatever we want

21460
21:57:33.789 --> 21:57:41.789
12345678123456789 What we'll do
is 0.01 eath. So we'll even drop

21461
21:57:41.789 --> 21:57:44.789
this down one, we'll do it for
we'll do it for the Hard Hat

21462
21:57:44.789 --> 21:57:47.789
Network. And then we'll also do
it for Rinckey as well. We have

21463
21:57:47.789 --> 21:57:51.789
the arguments here. Now we can
finally deploy our contract. So

21464
21:57:51.789 --> 21:57:57.789
we'll do const random IPFS. And
if t equals await, deploy, if

21465
21:57:57.789 --> 21:58:05.790
the contract is random IPFS NF T
from Deployer. args is args. Log

21466
21:58:05.790 --> 21:58:11.790
is true. And then wait
confirmations is going to be

21467
21:58:11.790 --> 21:58:21.790
network dot config dot block for
confirm terminations, or one,

21468
21:58:21.790 --> 21:58:25.790
and great they might do another
little line here. We'll do the

21469
21:58:25.790 --> 21:58:28.790
verification bit. I'm actually
just going to copy that from our

21470
21:58:28.790 --> 21:58:33.790
deploy. Our basic I'm just going
to copy this it's going to be

21471
21:58:33.790 --> 21:58:36.790
code is going to be exactly the
same, except for we're going to

21472
21:58:36.790 --> 21:58:41.790
verify random IPFS instead of
and then actually we use args

21473
21:58:41.790 --> 21:58:44.790
instead of arguments, then that
is it. So we'll give this a

21474
21:58:44.790 --> 21:58:49.790
quick deploy test, HH deploy or
yarn Hardhead deploy. And it

21475
21:58:49.790 --> 21:58:52.790
looks like we almost worked we
almost got Everything's done.

21476
21:58:52.790 --> 21:58:56.790
Network config is not defined,
because we didn't import it. So

21477
21:58:56.790 --> 21:58:59.790
let's go ahead and import
network config from our helper

21478
21:58:59.790 --> 21:59:03.790
Hardhead. Config. So import
network config. We'll try this

21479
21:59:03.790 --> 21:59:07.790
one more time chain ID is not
defined, it's going to be chain

21480
21:59:07.790 --> 21:59:13.790
ID, that chain Id try one more
time. And awesome, it's at least

21481
21:59:13.790 --> 21:59:15.790
working for our heart Hat
Network. And then we can copy

21482
21:59:15.790 --> 21:59:19.790
this array, and just paste it in
here. Boom. And now we have this

21483
21:59:19.790 --> 21:59:23.790
token your eyes. And now back in
our dot env. Now we can set this

21484
21:59:23.790 --> 21:59:27.790
to false. Since we have all
those token neurons already, we

21485
21:59:27.790 --> 21:59:30.790
just run hard hit Deploy, we'll
just use the token heroes that

21486
21:59:30.790 --> 21:59:34.790
we already have uploaded. Yes,
we have done it. Now I know

21487
21:59:34.790 --> 21:59:38.790
you're excited to see this on
something like open See, you're

21488
21:59:38.790 --> 21:59:41.791
excited to see this right away.
But let's save deploying all

21489
21:59:41.791 --> 21:59:44.791
these to rink B for our last
thing, because again, deploying

21490
21:59:44.791 --> 21:59:47.791
to test nets is really slow. So
let's just wait until our last

21491
21:59:47.791 --> 21:59:51.791
bit and then we'll go ahead, and
we'll deploy this to rank B. But

21492
21:59:51.791 --> 21:59:53.791
before we write tests, something
that I noticed when I was

21493
21:59:53.791 --> 21:59:56.791
writing my test is that we
forgot to update the token

21494
21:59:56.791 --> 21:59:59.791
counter. So in here, before we
do, our safe, men will do s

21495
21:59:59.791 --> 22:00:03.791
token counter plus equals s
token counter, which is going to

21496
22:00:03.791 --> 22:00:07.791
be esto. Encounter equals es
token counter plus one. And

21497
22:00:07.791 --> 22:00:10.791
that's a perfect example of why
writing tests is so important.

21498
22:00:10.791 --> 22:00:12.791
Before you write any tests,
you're definitely going to need

21499
22:00:12.791 --> 22:00:16.791
to fund that subscription, which
we didn't do in here. So we need

21500
22:00:16.791 --> 22:00:25.791
to do a wait VRF coordinate Tor
V to mock dot fund, sub

21501
22:00:25.791 --> 22:00:32.791
scription. subscription ID,
comma will do fund amount, and

21502
22:00:32.791 --> 22:00:35.791
then just up at the top,
actually, we can even pull this

21503
22:00:35.791 --> 22:00:38.791
out too. Since that's not gonna
change at all. We can do let

21504
22:00:38.791 --> 22:00:44.791
token year I was like that looks
like const fund amount equals

21505
22:00:44.791 --> 22:00:46.791
cool. Or you could do you know,
you could also do ethers dot

21506
22:00:46.791 --> 22:01:00.791
parse. But as you know, before
we can even deploy to rink beam,

21507
22:01:00.791 --> 22:01:03.791
what should we do? Well, you got
it right, we should absolutely

21508
22:01:03.791 --> 22:01:08.791
100 percent write some tests. So we're
create a new file called random

21509
22:01:08.791 --> 22:01:14.791
IPFS NF t dot test dot j s. And
we can write some tests here.

21510
22:01:14.791 --> 22:01:16.791
Now, once again, there isn't
anything new that you're going

21511
22:01:16.791 --> 22:01:20.792
to learn in this test here, it's
going to be very similar to the

21512
22:01:20.792 --> 22:01:23.792
lottery tests that we've written
before. So here's what I'm going

21513
22:01:23.792 --> 22:01:27.792
to say, I'm going to highly
recommend once again, that you

21514
22:01:27.792 --> 22:01:30.792
try to write at least two or
three of your own tests, but

21515
22:01:30.792 --> 22:01:33.792
definitely write a test fulfill
random words. But I'm going to

21516
22:01:33.792 --> 22:01:37.792
encourage you to pause the video
now, please pause the video and

21517
22:01:37.792 --> 22:01:40.792
try to write some tests yourself
struggling with some of these

21518
22:01:40.792 --> 22:01:42.792
tests. And writing some of these
tests is going to be what really

21519
22:01:42.792 --> 22:01:45.792
gives you those coding muscles,
if you will, that's going to

21520
22:01:45.792 --> 22:01:47.792
give you the skills to keep
writing these tests and be

21521
22:01:47.792 --> 22:01:50.792
really fast and really
efficient. When you're building

21522
22:01:50.792 --> 22:01:53.792
these smart contracts. These
tests are the tests that protect

21523
22:01:53.792 --> 22:01:57.792
you from writing bad immutable
code. So please pause the video,

21524
22:01:57.792 --> 22:01:59.792
I'm going to copy paste from the
GitHub repo. But please take

21525
22:01:59.792 --> 22:02:08.792
this time to write some of your
own tests here.

21526
22:02:08.792 --> 22:02:12.792
Alright, great. Did you write
some tests? Hope you did. If you

21527
22:02:12.792 --> 22:02:14.792
didn't write some tests, pause
this video and go write some

21528
22:02:14.792 --> 22:02:17.792
tests. I promise you doing these
tests, writing exercises on your

21529
22:02:17.792 --> 22:02:20.792
own will help you dramatically
at this point, what have we

21530
22:02:20.792 --> 22:02:24.792
done, we've done some some
amazing stuff, we've deployed a

21531
22:02:24.792 --> 22:02:27.792
basic NFT with pretty much
nothing to it, then we've

21532
22:02:27.792 --> 22:02:31.792
deployed a provably random NFT
with random stats with random

21533
22:02:31.792 --> 22:02:35.792
traits with different rarities,
for each NF T's depending on

21534
22:02:35.792 --> 22:02:38.792
when it was minted, or who
minted it. We've stored the data

21535
22:02:38.792 --> 22:02:42.792
for this on IPFS. And we've
learned how to programmatically

21536
22:02:42.792 --> 22:02:46.792
upload our files to pinata,
which is another pinning service

21537
22:02:46.792 --> 22:02:49.792
for us. We learned a little bit
about NFT debt storage, which is

21538
22:02:49.792 --> 22:02:54.792
another way to pin data to IPFS.
And then of course, we learned

21539
22:02:54.792 --> 22:02:58.792
that if we wanted to, we could
programmatically pin data to

21540
22:02:58.792 --> 22:03:01.793
IPFS on our own node. But since
a lot of us aren't gonna be

21541
22:03:01.793 --> 22:03:04.793
running our own computers 24/7.
We went ahead and said, Okay,

21542
22:03:04.793 --> 22:03:07.793
well, we'll stick with pinata
for our default here. Now that

21543
22:03:07.793 --> 22:03:13.793
we've done all that, boom, got
another little checkmark here.

21544
22:03:13.793 --> 22:03:16.793
Now I got something to say we
don't need to host our data on

21545
22:03:16.793 --> 22:03:21.793
IPFS can actually host our data,
our metadata directly on chain

21546
22:03:21.793 --> 22:03:24.793
if we want to. However, there
are some pros and cons to IT

21547
22:03:24.793 --> 22:03:27.793
pros of hosting on IPFS, or
that's going to be cheap. And

21548
22:03:27.793 --> 22:03:32.793
the cons are that someone needs
to pin our data, right? There's

21549
22:03:32.793 --> 22:03:36.793
at least one person always needs
to have her data pinned, right?

21550
22:03:36.793 --> 22:03:39.793
It's decentralized, but you at
least need somebody to pin your

21551
22:03:39.793 --> 22:03:42.793
data, right? And using something
like file coin is a way to

21552
22:03:42.793 --> 22:03:45.793
incentivize people to pin that
data. But if you're not using

21553
22:03:45.793 --> 22:03:48.793
File coin, it's not necessarily
guaranteed the pros of doing our

21554
22:03:48.793 --> 22:03:53.793
SVG on chain NFT the data A is
on chain. And you never have to

21555
22:03:53.793 --> 22:03:56.793
worry about somebody actually
pinning the data. The cons are

21556
22:03:56.793 --> 22:04:02.793
that this is much more
expensive. These little images,

21557
22:04:02.793 --> 22:04:05.793
right here are actually
surprisingly large and storing

21558
22:04:05.793 --> 22:04:07.793
them on chain can actually get
pretty expensive. So we're going

21559
22:04:07.793 --> 22:04:10.793
to use some different images, so
much smaller images, much

21560
22:04:10.793 --> 22:04:13.793
cheaper images to work with
here. And if you want to see

21561
22:04:13.793 --> 22:04:17.793
another version of this, I have
another video, how to make NFT

21562
22:04:17.793 --> 22:04:20.793
art with on chain metadata, it
goes through pretty much what

21563
22:04:20.793 --> 22:04:23.793
we're about to go through here
as well if you want a second

21564
22:04:23.793 --> 22:04:25.793
reference, and there's a link to
this in the GitHub repo

21565
22:04:25.793 --> 22:04:29.793
associated with this course. So
instead of these PNGs that we're

21566
22:04:29.793 --> 22:04:38.793
using, we're going to use
something called SVG s. Now, an

21567
22:04:38.793 --> 22:04:42.794
SVG stands for Scalable Vector
Graphics. And these are much

21568
22:04:42.794 --> 22:04:46.794
much more minimalistic files
that we can go ahead and upload

21569
22:04:46.794 --> 22:04:49.794
to to the blockchain. So that's
why we're going to use them

21570
22:04:49.794 --> 22:04:51.794
because since there's so much
more minimalistic, they're a lot

21571
22:04:51.794 --> 22:04:53.794
cheaper to upload. Because
remember, the more data that you

21572
22:04:53.794 --> 22:04:56.794
upload to the blockchain, the
more expensive it is. Now in

21573
22:04:56.794 --> 22:05:00.794
this video, I make randomize SVG
data on chain. And here's kind

21574
22:05:00.794 --> 22:05:02.794
of an example of what one looks
like. It's just a whole bunch of

21575
22:05:02.794 --> 22:05:06.794
random lines. Not super
thrilling, but random and kind

21576
22:05:06.794 --> 22:05:09.794
of cool. And it's 100 percent. On
chain, these SVG is actually

21577
22:05:09.794 --> 22:05:12.794
work right in HTML. So if you
want to use these for your

21578
22:05:12.794 --> 22:05:16.794
websites, you can as well now
there's a link to this tutorial

21579
22:05:16.794 --> 22:05:18.794
in the GitHub repo associated
with this course, where we can

21580
22:05:18.794 --> 22:05:21.794
go ahead and try it yourself.
And we can actually play with

21581
22:05:21.794 --> 22:05:23.794
making an SVG, right, so they
have all these different

21582
22:05:23.794 --> 22:05:29.794
commands in this web through
schools.com/graphics/svg intro

21583
22:05:29.794 --> 22:05:32.794
dot ASP, you can see some of the
different commands, right, you

21584
22:05:32.794 --> 22:05:36.794
can make a rectangle you can
make a circle path is a big one

21585
22:05:36.794 --> 22:05:40.794
where you can say exactly what
the path or the line you want to

21586
22:05:40.794 --> 22:05:43.794
draw is going to look like.
There's a whole bunch of stuff

21587
22:05:43.794 --> 22:05:46.794
you can make in this SVG. And
the cool thing is, no matter how

21588
22:05:46.794 --> 22:05:50.794
big you make an SVG, the quality
is always going to be exactly

21589
22:05:50.794 --> 22:05:53.794
the same, because SVG just
explains exactly how to draw it

21590
22:05:53.794 --> 22:05:56.794
no matter how big or how little,
the image is going to be. So if

21591
22:05:56.794 --> 22:05:59.794
you want to learn more about SVG
is you want to play with SVG is

21592
22:05:59.794 --> 22:06:02.794
you know, you can come in here
and try it yourself. So with

21593
22:06:02.794 --> 22:06:04.794
that being said, that's what
we're going to store on chain.

21594
22:06:04.794 --> 22:06:07.794
So that's how we're going to
store this SVG stuff on chain.

21595
22:06:07.794 --> 22:06:09.794
But we're gonna go one step
further, we're gonna make this

21596
22:06:09.794 --> 22:06:13.794
dynamic, we're gonna make this
actually change based off of

21597
22:06:13.794 --> 22:06:17.794
some data on chain. If you go to
the GitHub repo associated with

21598
22:06:17.794 --> 22:06:20.795
this lesson, and you go to the
images, and you go to dynamic

21599
22:06:20.795 --> 22:06:24.795
NFT, you'll see two images, see
happy dot SVG, which looks like

21600
22:06:24.795 --> 22:06:29.795
this. And you'll see frown dot
SVG, which looks like this. So

21601
22:06:29.795 --> 22:06:32.795
we're going to make this NFT
dynamic in the sense that we're

21602
22:06:32.795 --> 22:06:37.795
going to say, if the price of
eath is above some number, then

21603
22:06:37.795 --> 22:06:39.795
we're going to have it be a
happy face. And then if it's

21604
22:06:39.795 --> 22:06:44.795
below that, we're going to make
it a frowny face. So our NFT is

21605
22:06:44.795 --> 22:06:47.795
going to change based off of
some real world parameters. And

21606
22:06:47.795 --> 22:06:49.795
this is obviously really
powerful and really cool,

21607
22:06:49.795 --> 22:06:53.795
because we can have an NFT that
changes based off stats, we can

21608
22:06:53.795 --> 22:06:56.795
have an NF t that changes based
off of really whatever, and

21609
22:06:56.795 --> 22:06:59.795
we're going to store all the
data 100 percent on chain, it's going

21610
22:06:59.795 --> 22:07:02.795
to be a little bit more
expensive. So that's what we're

21611
22:07:02.795 --> 22:07:08.795
going to be building here.

21612
22:07:08.795 --> 22:07:11.795
Let's go ahead, let's jump into
it. And let's do the final

21613
22:07:11.795 --> 22:07:14.795
contract for our ultimate NFT
section. So we're going to

21614
22:07:14.795 --> 22:07:17.795
create a new contract in here,
new contract, and this is going

21615
22:07:17.795 --> 22:07:24.795
to be our dynamic, SVG and F T
dot soul. And it's going to look

21616
22:07:24.795 --> 22:07:28.795
real similar to what we've been
doing. slash slash dynamic. SVG

21617
22:07:28.795 --> 22:07:37.795
and ft dot saw, slash lat spdx,
license identifier, and my team

21618
22:07:37.795 --> 22:07:46.795
pragma. solidity, Eric zero,
point 8.7. Contract, dynamic

21619
22:07:46.795 --> 22:07:52.795
SVG, NF t. Now let's talk about
what the architecture of this is

21620
22:07:52.795 --> 22:07:55.795
going to look like. It's gonna
look like pretty normal NF T,

21621
22:07:55.795 --> 22:07:58.795
with a couple of caveats. We're
gonna give it a min function to

21622
22:07:58.795 --> 22:08:02.796
mint, these NF T's are also
going to store our SVG

21623
22:08:02.796 --> 22:08:07.796
information somewhere. And then
we're going to need to have some

21624
22:08:07.796 --> 22:08:14.796
logic to say show x image or
show y image, right. And as we

21625
22:08:14.796 --> 22:08:17.796
know, that's really just going
to be switching the token URI to

21626
22:08:17.796 --> 22:08:21.796
say show X or show y. So let's
go into how we'd actually do

21627
22:08:21.796 --> 22:08:25.796
this. So first, we know this is
going to be in ERC. 721. So we

21628
22:08:25.796 --> 22:08:27.796
can go ahead and import that
from open Zeppelin. So we're

21629
22:08:27.796 --> 22:08:33.796
going to say import at open
Zeppelin slash contracts, slash

21630
22:08:33.796 --> 22:08:40.796
token slash ERC. 721 slash ERC.
721 That's all. Now we're not

21631
22:08:40.796 --> 22:08:43.796
going to call that set token URI
function that we call before so

21632
22:08:43.796 --> 22:08:47.796
we can just use the raw ERC 721
instead of an extension. So

21633
22:08:47.796 --> 22:08:52.796
we'll say our contract is ERC
721 and Now that we're making it

21634
22:08:52.796 --> 22:08:57.796
an ERC 721. We can say construct
dorm like this, then we'll call

21635
22:08:57.796 --> 22:09:01.796
the constructor of the ERC. 721,
which we're going to call this

21636
22:09:01.796 --> 22:09:10.796
dynamic SVG, and f t DSN,
dynamic SVG and s, t and f t,

21637
22:09:10.796 --> 22:09:14.796
like so then we're also going to
need a mint function. So let's

21638
22:09:14.796 --> 22:09:18.796
just create that right now say
function, mint and f t or

21639
22:09:18.796 --> 22:09:21.796
request NFT. And we'll be a
little bit looser here, we'll

21640
22:09:21.796 --> 22:09:25.796
say the user doesn't need to pay
any money for this. So this will

21641
22:09:25.796 --> 22:09:27.796
just be a public function. And
we're just going to mint them

21642
22:09:27.796 --> 22:09:31.796
and NFT. Same thing, we're just
going to call Safe mint message

21643
22:09:31.796 --> 22:09:35.796
dot sender. And of course, we
need that token count term. So

21644
22:09:35.796 --> 22:09:40.797
let's go ahead and in our top
will do you in 256, private s

21645
22:09:40.797 --> 22:09:45.797
underscore token counter, we'll
do token counter here. And then

21646
22:09:45.797 --> 22:09:47.797
after we meant we'll do tag
counter plus, there's gonna be

21647
22:09:47.797 --> 22:09:52.797
equals token counter plus one.
And then that's pretty much it,

21648
22:09:52.797 --> 22:09:55.797
we have a way to meant we've
done some of the basics here.

21649
22:09:55.797 --> 22:09:58.797
We'll even we'll be explicit
will say s token counter equals

21650
22:09:58.797 --> 22:10:02.797
zero to initialize it. But now
what is this token going to look

21651
22:10:02.797 --> 22:10:05.797
like? We want these to look like
SVGs. And we want it to be based

21652
22:10:05.797 --> 22:10:10.797
off the price of some asset in
our constructor, all right,

21653
22:10:10.797 --> 22:10:15.797
create a string memory. We'll
call it low SVG and a string

21654
22:10:15.797 --> 22:10:27.797
memory, high SVG. And in our
code will save this low SVG in

21655
22:10:27.797 --> 22:10:30.797
this highest V G. So these will
be the images, these will be

21656
22:10:30.797 --> 22:10:32.797
like the frowny face and the
smiley face that will just

21657
22:10:32.797 --> 22:10:37.797
import as input parameters here.
So as we know, we can make these

21658
22:10:37.797 --> 22:10:39.797
immutable since these are
probably not going to change. We

21659
22:10:39.797 --> 22:10:47.797
can say String, private, I
underscore low image URI. And in

21660
22:10:47.797 --> 22:10:52.797
string private, I underscore
high image URI. But if we just

21661
22:10:52.797 --> 22:10:55.797
pass the SVG data, right, the
SVG data is going to look like

21662
22:10:55.797 --> 22:11:00.797
what in this GitHub, I can go to
display the source blob here and

21663
22:11:00.797 --> 22:11:03.797
I can see exactly what this code
looks like this code here is

21664
22:11:03.797 --> 22:11:07.797
definitely not an image URI.
What we need is the image URI to

21665
22:11:07.797 --> 22:11:09.797
look something like this, right?
Now, the way that we're going to

21666
22:11:09.797 --> 22:11:12.797
pass it in is like with this SVG
code, right? Because we want to

21667
22:11:12.797 --> 22:11:15.797
just pass it the SVG code, and
then have the contract handle

21668
22:11:15.797 --> 22:11:16.797
everything else.

21669
22:11:16.797 --> 22:11:21.798
So how do we actually do this?
Well, what we can do is we can

21670
22:11:21.798 --> 22:11:28.798
create a function called SVG to
image URI. And on chain, we can

21671
22:11:28.798 --> 22:11:33.798
convert these SVGs from SVGs. To
image arise. So instead of

21672
22:11:33.798 --> 22:11:37.798
having IPFS, as their start,
we're gonna use something called

21673
22:11:37.798 --> 22:11:43.798
base 64 encoding, you can
actually encode any SVG to a

21674
22:11:43.798 --> 22:11:48.798
base 64 image URL. That's right.
It'll look something like this

21675
22:11:48.798 --> 22:11:51.798
base. 64 is group a binary to
text encoding schemes that

21676
22:11:51.798 --> 22:11:56.798
represents binary data. Or in
our case, our SVG data. Base. 64

21677
22:11:56.798 --> 22:11:59.798
is particularly prevalent in the
world wide web, or one of its

21678
22:11:59.798 --> 22:12:03.798
uses is the ability to embed
image files or other binary

21679
22:12:03.798 --> 22:12:07.798
assets inside textual assets,
such as HTML, and CSS, what we

21680
22:12:07.798 --> 22:12:12.798
can do, can actually convert all
this SVG stuff to a URL or an

21681
22:12:12.798 --> 22:12:16.798
image URI would be great, right?
That's exactly what we want, we

21682
22:12:16.798 --> 22:12:20.798
want to be able to convert this
to a URL or an image URI. Now,

21683
22:12:20.798 --> 22:12:23.798
if you take one of these images,
or these SVG images, like the

21684
22:12:23.798 --> 22:12:26.798
happy to have SVG, what we can
actually do in this happy dot

21685
22:12:26.798 --> 22:12:31.798
SVG is we can actually copy the
image address, which is going to

21686
22:12:31.798 --> 22:12:34.798
be the URL of this address. And
if we paste it back in, we'll

21687
22:12:34.798 --> 22:12:38.798
see justice file here. And in
this site, we can actually do

21688
22:12:38.798 --> 22:12:43.798
data type, remote URL, paste it
in here. And we can say encode

21689
22:12:43.798 --> 22:12:48.798
SVG to base 64. And down here,
we'll get this weird job role of

21690
22:12:48.798 --> 22:12:53.798
numbers and letters and stuff.
This base 64 encoding represents

21691
22:12:53.798 --> 22:12:56.798
the SVG that we just got and
what we can do in our browser,

21692
22:12:56.798 --> 22:13:06.799
we can type data, colon, image,
slash SVG, plus XML, semicolon,

21693
22:13:06.799 --> 22:13:11.799
base, 64, comma, and then paste
that massive thing in here and

21694
22:13:11.799 --> 22:13:16.799
Enter. And wouldn't you know it,
we get exactly that image back

21695
22:13:16.799 --> 22:13:21.799
up. So that huge, massive thing
here is the base 64 encoding of

21696
22:13:21.799 --> 22:13:24.799
this image. So with this basic C
four encoded image, we can use

21697
22:13:24.799 --> 22:13:28.799
this on chain as the image you
arrive for our images. And then

21698
22:13:28.799 --> 22:13:31.799
for our metadata. We'll just
bake that directly into our

21699
22:13:31.799 --> 22:13:34.799
token URI. You'll see what I
mean in a second. So we have a

21700
22:13:34.799 --> 22:13:38.799
way where we can actually
directly put our SVG code right

21701
22:13:38.799 --> 22:13:40.799
into our smart contracts. Let's
figure out how to do that. So we

21702
22:13:40.799 --> 22:13:44.799
have function, SVG to image URI,
so we know we're going to want

21703
22:13:44.799 --> 22:13:47.799
to probably do that same base 64
encoding on chain. We're gonna

21704
22:13:47.799 --> 22:13:50.799
100 percent do this off chain if you
want to save some gas but it's

21705
22:13:50.799 --> 22:13:53.799
kind of fun for To show how to
do this all on chain, so we'll

21706
22:13:53.799 --> 22:13:56.799
make this a public pure
function. And we'll have it

21707
22:13:56.799 --> 22:14:02.799
returns a string memory. So
we're going to give this

21708
22:14:02.799 --> 22:14:05.799
function an SVG, which we're
going to pass in from our

21709
22:14:05.799 --> 22:14:08.799
constructor. And we're going to
return a string, which is going

21710
22:14:08.799 --> 22:14:11.799
to be that base 64 encoded URL
that we just saw, while up at

21711
22:14:11.799 --> 22:14:21.799
our top will do string, private
constant, base S feed, base 64,

21712
22:14:21.799 --> 22:14:29.799
encoded SVG prefix equals that
right there. And we'll use this

21713
22:14:29.799 --> 22:14:34.799
to generate our SVG now, well,
we can do. And then we're going

21714
22:14:34.799 --> 22:14:39.799
to do string memory SVG, we're
going to encode this SVG in

21715
22:14:39.799 --> 22:14:43.800
basically for ourself by adding
the base 64 encoding on chain.

21716
22:14:43.800 --> 22:14:47.800
Now, we don't really want to
have to rewrite that ourselves.

21717
22:14:47.800 --> 22:14:49.800
So luckily for us, somebody has
already done this. And we can

21718
22:14:49.800 --> 22:14:52.800
see the GitHub repo associated
with this, this was created by

21719
22:14:52.800 --> 22:14:55.800
one of the LoopRing devs really
awesome project, if you want to

21720
22:14:55.800 --> 22:14:58.800
check that out as well. And
we're going to borrow this code

21721
22:14:58.800 --> 22:15:02.800
for our SVG on chain. So what we
can do is we can add this in

21722
22:15:02.800 --> 22:15:05.800
here, add their GitHub code,
where they have basically

21723
22:15:05.800 --> 22:15:09.800
everything that we need in here
to encode and decode basics

21724
22:15:09.800 --> 22:15:16.800
before, we can do yarn, add dash
dash Dev, base 64 Dash soul,

21725
22:15:16.800 --> 22:15:18.800
this is going to add their code
as a dependency. And once we've

21726
22:15:18.800 --> 22:15:24.800
added it, we can go ahead and
import it with import, base 64,

21727
22:15:24.800 --> 22:15:31.800
dash soul slash, base 64 dot
Sol. And this contract comes

21728
22:15:31.800 --> 22:15:37.800
with an encoder. So then we can
just do string memory, SVG base,

21729
22:15:37.800 --> 22:15:44.800
64, encoded, equals base 64 dot
ENCODE. And here's where it gets

21730
22:15:44.800 --> 22:15:45.800
a little bit weird.

21731
22:15:45.800 --> 22:15:56.800
We'll do bytes string, abi dot
ENCODE, act, SVG, and then we'll

21732
22:15:56.800 --> 22:16:04.800
return string API dot encode
packed, base 64, encoded SVG

21733
22:16:04.800 --> 22:16:09.800
prefix, comma SVG base 64
encoded, and just this function,

21734
22:16:09.800 --> 22:16:15.800
this SVG to image URI will take
in any SVG and spit us back out

21735
22:16:15.800 --> 22:16:20.801
a URL or URI that looks exactly
like this. Now, I kind of sped

21736
22:16:20.801 --> 22:16:22.801
through some stuff in here.
There's a whole bunch of new

21737
22:16:22.801 --> 22:16:26.801
stuff like ABI dot encode packed
that we did twice, what is this

21738
22:16:26.801 --> 22:16:29.801
ABI dot encode packed doing?

21739
22:16:29.801 --> 22:16:37.801
Well, let's learn about that. So
from a really, really high

21740
22:16:37.801 --> 22:16:41.801
level, this is basically how you
concatenate strings. Right, this

21741
22:16:41.801 --> 22:16:44.801
is how you combine strings
together. And we're going to

21742
22:16:44.801 --> 22:16:49.801
jump over remix to actually
explore this ABI dot encode pact

21743
22:16:49.801 --> 22:16:52.801
and this ABI encoding stuff a
little bit more. Now the section

21744
22:16:52.801 --> 22:16:56.801
that we're about to go through
is definitely advanced. And

21745
22:16:56.801 --> 22:16:59.801
we're going to be going over
some really low level stuff, and

21746
22:16:59.801 --> 22:17:03.801
how solidity works behind the
scenes, how the binary works,

21747
22:17:03.801 --> 22:17:06.801
and this thing called opcodes.
And all this crazy, low level,

21748
22:17:06.801 --> 22:17:09.801
tricky, difficult things to
understand. If you want to move

21749
22:17:09.801 --> 22:17:13.801
past this section, there are
timestamps in the GitHub repo.

21750
22:17:13.801 --> 22:17:16.801
To help you move past this.
However, I do encourage you to

21751
22:17:16.801 --> 22:17:20.801
at least try to absorb most of
this material, if you don't

21752
22:17:20.801 --> 22:17:24.801
understand it the first time.
That's 100 percent. Okay, this is more

21753
22:17:24.801 --> 22:17:28.801
advanced. Anyways, for most of
your basic projects, you won't

21754
22:17:28.801 --> 22:17:32.801
really need this information.
It's only later on once you get

21755
22:17:32.801 --> 22:17:35.801
more advanced that knowing all
this is really going to make you

21756
22:17:35.801 --> 22:17:38.801
a phenomenal solidity developer.
And when you approach this

21757
22:17:38.801 --> 22:17:42.801
section, when you approach this
sub lesson on EVM, opcodes, and

21758
22:17:42.801 --> 22:17:45.801
coding and calling, just know
that if you don't 100 percent

21759
22:17:45.801 --> 22:17:48.801
understand it the first time
that is okay, if you want to

21760
22:17:48.801 --> 22:17:52.801
watch this section a couple of
times fantastic. So if you want

21761
22:17:52.801 --> 22:17:55.801
to jump over to remix and follow
along, let's do it. Now in our

21762
22:17:55.801 --> 22:17:57.801
contract section, let's go ahead
and create a new file, we're

21763
22:17:57.801 --> 22:18:01.802
going to call it encoding dot
soul. And remember, all the code

21764
22:18:01.802 --> 22:18:03.802
that we're going to be going
with in here is going to be in

21765
22:18:03.802 --> 22:18:07.802
this sub Lesson folder of the
Hardhead NFT. FCC. And all the

21766
22:18:07.802 --> 22:18:10.802
code we're going to be working
with is going to be in this

21767
22:18:10.802 --> 22:18:13.802
encoding dot soul. And then in a
little bit, we're going to work

21768
22:18:13.802 --> 22:18:17.802
on this call anything that soul
so we're in this encoding dot

21769
22:18:17.802 --> 22:18:20.802
soul. And let's just make our
basic code here. So we'll say

21770
22:18:20.802 --> 22:18:32.802
spdx, license identifier, MIT
pragma, solidity, carrot, zero,

21771
22:18:32.802 --> 22:18:36.802
point 8.7, like that, do
contract encoding, boom,

21772
22:18:36.802 --> 22:18:40.802
compile, or Command S or ctrl S
great things are looking good.

21773
22:18:40.802 --> 22:18:44.802
Now remember, the whole purpose
for this is to first understand

21774
22:18:44.802 --> 22:18:48.802
what's going on here, and more
about this API dot encode packed

21775
22:18:48.802 --> 22:18:52.802
stuff. So let's first just write
a function that should owes us

21776
22:18:52.802 --> 22:18:55.802
wrapping API dot encode packed
with some strings and wrapping

21777
22:18:55.802 --> 22:18:59.802
it around a string is going to
return a string. So we could do

21778
22:18:59.802 --> 22:19:04.802
function, bind strings, or
concatenate strings. This will

21779
22:19:04.802 --> 22:19:08.802
be a public pure since we're not
going to be reading any storage,

21780
22:19:08.802 --> 22:19:15.802
we'll say returns string memory.
And we'll say return string, API

21781
22:19:15.802 --> 22:19:21.802
dot encode packed. I'm I'm
comma, space in here, I miss

21782
22:19:21.802 --> 22:19:25.802
you, like so. We need another
parenthesis here. Okay, great.

21783
22:19:25.802 --> 22:19:28.802
Now let's go ahead and deploy
this, we'll start a JavaScript

21784
22:19:28.802 --> 22:19:34.802
VM will deploy encoding
coding.so. We'll come down here,

21785
22:19:34.802 --> 22:19:37.802
we'll click Combine strings, and
we get that whole string output.

21786
22:19:37.802 --> 22:19:41.803
Hi, Mom, miss you. So what we're
doing here is we're encoding hi

21787
22:19:41.803 --> 22:19:46.803
mom misuse together into its
bytes form, because API dot

21788
22:19:46.803 --> 22:19:50.803
encode packed returns a bytes
object, and we are typecasting

21789
22:19:50.803 --> 22:19:53.803
it by wrapping it in this string
thing to be a string. And

21790
22:19:53.803 --> 22:19:56.803
solidity says, okay, yeah, bytes
to string, that's fine, that

21791
22:19:56.803 --> 22:20:00.803
totally works. And this API dot
encode packed are these globally

21792
22:20:00.803 --> 22:20:04.803
available methods and units. And
actually, in solidity, there's a

21793
22:20:04.803 --> 22:20:07.803
whole bunch of these, there's
this solidity cheat sheet, and

21794
22:20:07.803 --> 22:20:10.803
there's gonna be a link to this
in the GitHub repo as well, that

21795
22:20:10.803 --> 22:20:13.803
has a whole bunch of operators
and it has a whole bunch of

21796
22:20:13.803 --> 22:20:15.803
these global variables and
methods. You can see if we look

21797
22:20:15.803 --> 22:20:19.803
in here, we look for ABI dot
encode pact, we see ABI dot

21798
22:20:19.803 --> 22:20:22.803
encode pact right here, we
scroll down, we'll see some more

21799
22:20:22.803 --> 22:20:25.803
that we're familiar with as
well. Like, for example, message

21800
22:20:25.803 --> 22:20:29.803
dot sender, sender of the
message, message dot value.

21801
22:20:29.803 --> 22:20:33.803
There's a whole bunch of other
globally available methods and

21802
22:20:33.803 --> 22:20:36.803
variables that we can use when
we're coding our stuff. Now, I

21803
22:20:36.803 --> 22:20:41.803
will say though, in 0.8, point,
well, plus, you can actually do

21804
22:20:41.803 --> 22:20:47.803
string dot concat, you know,
string a, comma string B, if you

21805
22:20:47.803 --> 22:20:51.803
want to, instead of doing this
API to encode packed, but I

21806
22:20:51.803 --> 22:20:53.803
still wanted to show you the API
dot encode pack, because it's a

21807
22:20:53.803 --> 22:20:56.803
great segue into all this ABI
stuff that we're about to go

21808
22:20:56.803 --> 22:21:00.803
over. But let's focus on this
encode packed thing. So what is

21809
22:21:00.803 --> 22:21:05.803
actually going on here? Well,
before we dive deeper into this

21810
22:21:05.803 --> 22:21:09.803
encode pact, let's understand a
little bit more about what

21811
22:21:09.803 --> 22:21:12.803
happens when we send a
transaction. So when we compile

21812
22:21:12.803 --> 22:21:15.803
our code, and again, all these
pictures are going to be in the

21813
22:21:15.803 --> 22:21:18.803
GitHub repo. Remember back to
ethers.js, we had those two

21814
22:21:18.803 --> 22:21:23.804
files, we got a dot ABI file,
and a dot bin or dot binary.

21815
22:21:23.804 --> 22:21:26.804
Back in our ether symbol
storage, when we ran yarn,

21816
22:21:26.804 --> 22:21:30.804
compile. The two main files that
we got, were this symbol storage

21817
22:21:30.804 --> 22:21:34.804
that abi, which was this, you
know, this ABI thing that we've

21818
22:21:34.804 --> 22:21:38.804
become familiar with. And then
the simple storage dot bin,

21819
22:21:38.804 --> 22:21:40.804
which is the binary, which has a
whole bunch of just numbers and

21820
22:21:40.804 --> 22:21:43.804
letters and stuff we didn't
understand. And you can see that

21821
22:21:43.804 --> 22:21:47.804
in remix to, like if we were to
compile this, you get a

21822
22:21:47.804 --> 22:21:50.804
compilation details, you get a
whole bunch of stuff in here,

21823
22:21:50.804 --> 22:21:53.804
right? You can see the ABI in
here, which this is kind of like

21824
22:21:53.804 --> 22:21:56.804
a different way of viewing that
API, we also get this bytecode

21825
22:21:56.804 --> 22:22:00.804
bit and it's this object that
has the same stuff that has like

21826
22:22:00.804 --> 22:22:03.804
those random numbers and
letters. But this is actually

21827
22:22:03.804 --> 22:22:05.804
the binary this is actually
what's getting put on the

21828
22:22:05.804 --> 22:22:09.804
blockchain. It's this binary,
it's this low level stuff. Now,

21829
22:22:09.804 --> 22:22:12.804
when we actually send these
contracts to the blockchain,

21830
22:22:12.804 --> 22:22:15.804
we're sending like I said, we're
sending this binary thing.

21831
22:22:15.804 --> 22:22:17.804
That's exactly what we're
sending to the blockchain. And

21832
22:22:17.804 --> 22:22:22.804
remember how, again, back in our
ethers project, we saw what is a

21833
22:22:22.804 --> 22:22:25.804
transaction, right, a
transaction has a nonce, it has

21834
22:22:25.804 --> 22:22:29.804
a gas price guess limit to value
data, we kind of skipped over

21835
22:22:29.804 --> 22:22:31.804
the VRS a little bit, because
that's kind of that mathy

21836
22:22:31.804 --> 22:22:34.804
component of the transaction
signature. But again, back in

21837
22:22:34.804 --> 22:22:37.804
our ethos project, we did this
as well, right in our deploy

21838
22:22:37.804 --> 22:22:41.804
script, ended up sending a
transaction ourselves, using

21839
22:22:41.804 --> 22:22:46.804
just ethers. We passed a nonce,
a gas price, gas limit to value

21840
22:22:46.804 --> 22:22:50.804
data was this massive thing to
declare a contract, and then

21841
22:22:50.804 --> 22:22:53.804
also the chain ID. We didn't
work with the VAR s, because

21842
22:22:53.804 --> 22:22:56.804
ethers does that for us. But
there's also this VAR s

21843
22:22:56.804 --> 22:22:59.804
component that we don't bother
to look at. When we send a

21844
22:22:59.804 --> 22:23:04.805
transaction that actually
creates a contract, the two is

21845
22:23:04.805 --> 22:23:06.805
going to be empty. We're not
going to send this contract

21846
22:23:06.805 --> 22:23:10.805
deployment to any address. But
the data of this is going to

21847
22:23:10.805 --> 22:23:15.805
have the contract initialization
code and contract bytecode.

21848
22:23:15.805 --> 22:23:18.805
Right. So when we compile it, we
get all this code, like how do

21849
22:23:18.805 --> 22:23:21.805
you initialize the contract, and
then what the contract actually

21850
22:23:21.805 --> 22:23:24.805
looks like. So if you look at
any of the contracts that you

21851
22:23:24.805 --> 22:23:27.805
deployed, for example, I'm going
to look at our raffle that we

21852
22:23:27.805 --> 22:23:30.805
deployed. If you go to the
transactions of your contract,

21853
22:23:30.805 --> 22:23:35.805
we can see create raffle, right,
let's go to that transaction. If

21854
22:23:35.805 --> 22:23:39.805
we go down and click to see more
in the ether scan, we can see

21855
22:23:39.805 --> 22:23:42.805
this input data thing. And once
again, it's got all this random

21856
22:23:42.805 --> 22:23:47.805
garbled numbers and letters.
This is that binary data of the

21857
22:23:47.805 --> 22:23:50.805
contract initialization code and
the contract byte code right

21858
22:23:50.805 --> 22:23:53.805
what we send in our trend In
this action is this data thing,

21859
22:23:53.805 --> 22:23:58.805
we send this this weird bunch of
garbled nonsense. Now we're

21860
22:23:58.805 --> 22:24:00.805
going to head back to remix. And
I'm just going to leave this as

21861
22:24:00.805 --> 22:24:03.805
comments in here in the encoding
dot soul and the GitHub repo.

21862
22:24:03.805 --> 22:24:06.805
There's a ton of comments in
here explaining exactly what I'm

21863
22:24:06.805 --> 22:24:09.805
explaining. So if you want to
follow along there, you can as

21864
22:24:09.805 --> 22:24:12.805
well. But now in order for the
blockchain to understand, okay,

21865
22:24:12.805 --> 22:24:16.805
what do these numbers and
letters even mean? You need a

21866
22:24:16.805 --> 22:24:18.805
special reader cerium or the
blockchain needs to be able to

21867
22:24:18.805 --> 22:24:23.805
read all this stuff, it needs to
be able to map all these random

21868
22:24:23.805 --> 22:24:28.805
numbers and letters to what they
actually do. How does Aetherium

21869
22:24:28.805 --> 22:24:32.805
or polygon or avalanche know
that all this nonsense is

21870
22:24:32.805 --> 22:24:34.805
basically telling it to make a
contract, you kind of think of

21871
22:24:34.805 --> 22:24:37.805
it as saying, like, take off
your coat. The only reason that

21872
22:24:37.805 --> 22:24:41.806
we as human beings understand
what take off your coat means is

21873
22:24:41.806 --> 22:24:44.806
that we understand English,
We're all reading English, for

21874
22:24:44.806 --> 22:24:47.806
solidity. And for blockchains.
Instead of English, I read these

21875
22:24:47.806 --> 22:24:50.806
numbers and letters kind of like
words, just instead of take off

21876
22:24:50.806 --> 22:24:53.806
your coat, it's like deploy
contract, and the contract does

21877
22:24:53.806 --> 22:24:55.806
next XYZ and all this random
stuff. So this bytecode

21878
22:24:55.806 --> 22:24:58.806
represents the low level
computer instructions to make

21879
22:24:58.806 --> 22:25:00.806
our contract happen. And all
these numbers and letters

21880
22:25:00.806 --> 22:25:04.806
represent kind of an alphabet,
just like how take off your coat

21881
22:25:04.806 --> 22:25:07.806
is an alphabet. And when you
combine them like this, it makes

21882
22:25:07.806 --> 22:25:10.806
something that to us makes
sense, you can kind of think of

21883
22:25:10.806 --> 22:25:13.806
the alphabet for these as what's
called opcodes. If you go to

21884
22:25:13.806 --> 22:25:17.806
create a new tab, if you go to
EVM dot codes, we'll get to this

21885
22:25:17.806 --> 22:25:21.806
place where it just has a list
of all these instructions. On

21886
22:25:21.806 --> 22:25:25.806
the left side, you can see this
thing called opcode. And then

21887
22:25:25.806 --> 22:25:29.806
you can see name, so this opcode
section is saying, Hey, if you

21888
22:25:29.806 --> 22:25:36.806
see a 00 in this bytecode, that
00 represents this opcode stop,

21889
22:25:36.806 --> 22:25:41.806
which does what which halts
execution, if you see a 01

21890
22:25:41.806 --> 22:25:44.806
you're gonna do some addition
stuff, a 02 is multiply, there

21891
22:25:44.806 --> 22:25:49.806
are all these op codes that are
kind of like the alphabet, or

21892
22:25:49.806 --> 22:25:52.806
the language of this binary
stuff, right, and they go all

21893
22:25:52.806 --> 22:25:55.806
the way down to f f self
destruct, these op codes also

21894
22:25:55.806 --> 22:25:59.806
have, and that's what this is
reading. Right? So if we look at

21895
22:25:59.806 --> 22:26:01.806
our transaction here, and your
yours might be a little bit

21896
22:26:01.806 --> 22:26:04.806
different. Oh six, one says,
Okay, the first thing we want

21897
22:26:04.806 --> 22:26:07.806
you to do is the O six, one
opcode. And if we go to EVM,

21898
22:26:07.806 --> 22:26:12.806
opcodes, we look for six one,
it's saying push to place to buy

21899
22:26:12.806 --> 22:26:15.806
item on the stack. That's
exactly how it's reading this

21900
22:26:15.806 --> 22:26:19.806
any language that can compile
down to this opcode stuff down

21901
22:26:19.806 --> 22:26:23.807
to this specific set of
Aetherium opcodes, or EVM.

21902
22:26:23.807 --> 22:26:27.807
opcodes, is what's known as the
EVM, the Etherium virtual

21903
22:26:27.807 --> 22:26:30.807
machine. So being able to read
these op codes is sometimes

21904
22:26:30.807 --> 22:26:34.807
abstractly called the EVM, the
Etherium virtual machine, the

21905
22:26:34.807 --> 22:26:39.807
EVM basically represents all the
instructions, a computer must be

21906
22:26:39.807 --> 22:26:42.807
able to read for it to interact
with Aetherium, or Aetherium,

21907
22:26:42.807 --> 22:26:47.807
like applications. And this is
why so many blockchains all work

21908
22:26:47.807 --> 22:26:50.807
with solidity because solidity
compiles down to this bytecode

21909
22:26:50.807 --> 22:26:55.807
here, and polygon, avalanche
arbitrage Aetherium, they all

21910
22:26:55.807 --> 22:27:00.807
compiled down to the exact same
type of binary, and they all

21911
22:27:00.807 --> 22:27:03.807
have the exact same readers. Now
why are we telling you all this

21912
22:27:03.807 --> 22:27:05.807
stuff, you might be saying, hey,
Patrick, this is cool and all

21913
22:27:05.807 --> 22:27:07.807
but it looks like ABI dot encode
packed, all that does is

21914
22:27:07.807 --> 22:27:12.807
concatenate strings, abi encode
pack can do actually way more.

21915
22:27:12.807 --> 22:27:16.807
And if we look at these global
variables, API dot encode packed

21916
22:27:16.807 --> 22:27:19.807
is like what the third one down
the list because it's a non

21917
22:27:19.807 --> 22:27:23.807
standard way to encode stuff to
this binary stuff that we just

21918
22:27:23.807 --> 22:27:27.807
talked about, we can actually
encode pretty much anything we

21919
22:27:27.807 --> 22:27:32.807
want to being in this binary
format, basically. And let's

21920
22:27:32.807 --> 22:27:34.807
take a look at at encoding
something. So let's create a

21921
22:27:34.807 --> 22:27:38.807
function called encode number.
And this will be a public pure

21922
22:27:38.807 --> 22:27:41.807
function, since we're not going
to read any state, and we'll say

21923
22:27:41.807 --> 22:27:46.807
returns a bytes memory. We're
going to have this function

21924
22:27:46.807 --> 22:27:49.807
return a bytes object, we're
going to have it returned the

21925
22:27:49.807 --> 22:27:52.807
what this number is going to
look like but in binary, so

21926
22:27:52.807 --> 22:27:59.807
we'll say bytes, memory number
equals ABI dot encode one, and

21927
22:27:59.807 --> 22:28:04.808
then return number. So we're
going to encode number down to

21928
22:28:04.808 --> 22:28:08.808
it's a bi or it's binary format.
So I know a lot of times when we

21929
22:28:08.808 --> 22:28:12.808
say oh, what's the ABI what's
the ABI right? Previously, we

21930
22:28:12.808 --> 22:28:15.808
say, Oh, the ABI is, is this
thing, right? It's, it's all

21931
22:28:15.808 --> 22:28:18.808
these inputs and outputs. This
is kind of the human readable

21932
22:28:18.808 --> 22:28:21.808
version of the ABI. But again,
the ABI is the application

21933
22:28:21.808 --> 22:28:26.808
binary interface we want to
encode or numbers down to it's

21934
22:28:26.808 --> 22:28:29.808
basically it's binary, this ABI
dot ENCODE is going to be a

21935
22:28:29.808 --> 22:28:32.808
little different than like the
ABI that you see when you're

21936
22:28:32.808 --> 22:28:35.808
looking at compilation details.
This is technically like the ABI

21937
22:28:35.808 --> 22:28:39.808
technically is how to interact
with this contract. However,

21938
22:28:39.808 --> 22:28:42.808
it's not the actual binary
version of it. So we're saying,

21939
22:28:42.808 --> 22:28:46.808
okay, encode this number one
down to its binary version, so

21940
22:28:46.808 --> 22:28:49.808
that our contracts can interact
with it in a way that they

21941
22:28:49.808 --> 22:28:52.808
understand. So we're just saying
okay, Watch that number one,

21942
22:28:52.808 --> 22:28:56.808
let's make you machine readable.
And if we go, we compile this

21943
22:28:56.808 --> 22:28:59.808
and we deploy this right, let's
delete that that old contract,

21944
22:28:59.808 --> 22:29:02.808
we deploy this, we now have
combined strings and encode

21945
22:29:02.808 --> 22:29:07.808
number, we click it, we get this
big hex thing. This is how the

21946
22:29:07.808 --> 22:29:11.808
computer is going to understand
the number one. Now we can

21947
22:29:11.808 --> 22:29:14.808
encode pretty much anything
actually, we could encode a

21948
22:29:14.808 --> 22:29:17.808
string. So we'll say,

21949
22:29:17.808 --> 22:29:22.808
function, encode string, we'll
make this a public key here as

21950
22:29:22.808 --> 22:29:27.808
well. It'll return a bytes
memory, because we want to give

21951
22:29:27.808 --> 22:29:30.808
it that binary stuff or that
bites stuff. And we'll say bytes

21952
22:29:30.808 --> 22:29:37.808
memory, some string equals ABI
dot encode some string, and then

21953
22:29:37.808 --> 22:29:41.809
return some string. Now let's
compile that delete our old

21954
22:29:41.809 --> 22:29:45.809
contract, deploy that code
string, we get this big, big,

21955
22:29:45.809 --> 22:29:49.809
big object here. And this is the
binary. Now you'll notice

21956
22:29:49.809 --> 22:29:53.809
something here, there's a ton of
zeros, and those zeros take up

21957
22:29:53.809 --> 22:29:56.809
space, right, that's a lot of
space for the computer to take

21958
22:29:56.809 --> 22:29:58.809
up, even though they're not
really doing anything. They're

21959
22:29:58.809 --> 22:30:02.809
just kind of taking up space. So
solidity also comes with this

21960
22:30:02.809 --> 22:30:07.809
ABI dot encode tact, which
performs packed encoding of the

21961
22:30:07.809 --> 22:30:10.809
given arguments. And you can
read more about it in the

21962
22:30:10.809 --> 22:30:13.809
solidity docs, if you want. And
this is called the non standard

21963
22:30:13.809 --> 22:30:16.809
packed mode. And it does the
same encoding with some

21964
22:30:16.809 --> 22:30:19.809
stipulations type shorter than
32 bytes are concatenated

21965
22:30:19.809 --> 22:30:23.809
directly without padding, or
sign extension, dynamic types

21966
22:30:23.809 --> 22:30:25.809
are encoded in place. And
without the length array

21967
22:30:25.809 --> 22:30:28.809
elements are padded, but still
encoded in place, you can kind

21968
22:30:28.809 --> 22:30:31.809
of think of ENCODE packed as
sort of like a compressor,

21969
22:30:31.809 --> 22:30:34.809
right? It's the ENCODE function.
But it compresses stuff, if we

21970
22:30:34.809 --> 22:30:37.809
wanted to encode some string but
want to save space. And we

21971
22:30:37.809 --> 22:30:41.809
didn't need the perfect low
level binary of it. We could do

21972
22:30:41.809 --> 22:30:46.809
function and code string packed,
make this a public pure, and

21973
22:30:46.809 --> 22:30:51.809
have it return a bytes memory.
We could say, bytes memory, some

21974
22:30:51.809 --> 22:30:57.809
string equals ABI dot encode
packed once again, some string.

21975
22:30:57.809 --> 22:31:00.809
So we're doing a code pack
instead of a code. And we'll

21976
22:31:00.809 --> 22:31:03.809
return some string here, we'll
compile this and we'll see the

21977
22:31:03.809 --> 22:31:07.809
difference, right compile, we'll
delete our old one, we'll deploy

21978
22:31:07.809 --> 22:31:11.809
this. Now we have ENCODE string,
which again, that's what encoded

21979
22:31:11.809 --> 22:31:14.809
string is gonna give us and we
have encoded string packed,

21980
22:31:14.809 --> 22:31:19.809
which returns us this much, much
smaller bytes object. So you see

21981
22:31:19.809 --> 22:31:23.810
the size difference, if we're
trying to save gas, in code,

21982
22:31:23.810 --> 22:31:26.810
string packed is going to be a
way for us to save a lot more

21983
22:31:26.810 --> 22:31:30.810
gas. Now, abi dot encode pact is
actually really similar to

21984
22:31:30.810 --> 22:31:33.810
something that we've done
before, which is typecasting, if

21985
22:31:33.810 --> 22:31:39.810
we didn't function and code
string, bytes, public pure

21986
22:31:39.810 --> 22:31:46.810
returns, bytes, memory, bytes,
memories, some string equals

21987
22:31:46.810 --> 22:31:51.810
bytes, some string, turn some
string, these two are going to

21988
22:31:51.810 --> 22:31:54.810
look nearly identical, right? So
if we compile, we'll delete our

21989
22:31:54.810 --> 22:31:59.810
old contract, deploy this code
string bytes, which gives us

21990
22:31:59.810 --> 22:32:03.810
this and encode string pack
using the ABI to encode pack,

21991
22:32:03.810 --> 22:32:06.810
they give us the exact same
output, whereas encode strings

21992
22:32:06.810 --> 22:32:09.810
to give us this big piece. So
the two of these get the same

21993
22:32:09.810 --> 22:32:11.810
result. But behind the scenes,
they're doing something a little

21994
22:32:11.810 --> 22:32:14.810
bit different. And I'm not going
to go over exactly what that is.

21995
22:32:14.810 --> 22:32:18.810
But I've left a link inside of
the code here, if you want to

21996
22:32:18.810 --> 22:32:21.810
learn more, which is exactly
what we're doing in our NFT.

21997
22:32:21.810 --> 22:32:24.810
Right, we're doing ABR dot
encode packed, we're combining

21998
22:32:24.810 --> 22:32:28.810
two strings. By putting them
together, we're encoding them to

21999
22:32:28.810 --> 22:32:31.810
their bytes implementation to
their packed bytes

22000
22:32:31.810 --> 22:32:35.810
implementation, and then we're
just typecasting them back from

22001
22:32:35.810 --> 22:32:39.810
bytes to string. And that's how
we concatenate them. Now, at

22002
22:32:39.810 --> 22:32:39.810
this point, you

22003
22:32:39.810 --> 22:32:42.810
might be thinking, okay, cool.
Great, Patrick. I'm all set. I

22004
22:32:42.810 --> 22:32:45.810
understand this. I'm happy to go
back to my project. And if you

22005
22:32:45.810 --> 22:32:48.810
want to do that, absolutely go
for it and skip over this

22006
22:32:48.810 --> 22:32:51.810
section, but some other viewers
might be going okay, Patrick,

22007
22:32:51.810 --> 22:32:55.810
this is seems pretty cool. But
I'm sure this encode pacts in

22008
22:32:55.810 --> 22:32:59.810
this encode function aren't just
here to concatenate strings,

22009
22:32:59.810 --> 22:33:01.811
they probably have some other
function, what do they actually

22010
22:33:01.811 --> 22:33:04.811
do? Well, if that's what you're
asking, I'm glad you asked. And

22011
22:33:04.811 --> 22:33:06.811
I'm glad you're curious, because
we're going to find out. Now not

22012
22:33:06.811 --> 22:33:11.811
only can you encode stuff, like
strings and numbers, and really

22013
22:33:11.811 --> 22:33:17.811
anything, but you can decode
stuff. So I can say, function,

22014
22:33:17.811 --> 22:33:23.811
decode string, public, your
returns string memory, string

22015
22:33:23.811 --> 22:33:28.811
memory, some string equals ABI
dot decode. This is going to

22016
22:33:28.811 --> 22:33:32.811
take a couple parameters. So if
you look in the docs here, abi

22017
22:33:32.811 --> 22:33:38.811
dot decode, it takes as a first
argument, the encoded data, and

22018
22:33:38.811 --> 22:33:41.811
then it takes a tuple. You can
kind of think of it as a list

22019
22:33:41.811 --> 22:33:45.811
but not quite a list, a set of
types to decode this into and it

22020
22:33:45.811 --> 22:33:48.811
returns the number of parameters
that you gave it. So we might

22021
22:33:48.811 --> 22:33:52.811
want to say this string memory
some string Adding, let's give

22022
22:33:52.811 --> 22:33:56.811
it as input this encode string
function, the result of this

22023
22:33:56.811 --> 22:33:58.811
encode string function, right,
which again, is going to be this

22024
22:33:58.811 --> 22:34:02.811
big thing. So this is kind of
equivalent to sticking this

22025
22:34:02.811 --> 22:34:04.811
massive thing in here, but we're
just not going to stick the

22026
22:34:04.811 --> 22:34:06.811
massive thing in there, because
it's really big. So we're gonna

22027
22:34:06.811 --> 22:34:10.811
say, Let's decode the result of
ENCODE string, and let's decode

22028
22:34:10.811 --> 22:34:16.811
it into a string. Because we
need to tell solidity, hey,

22029
22:34:16.811 --> 22:34:19.811
we're going to decode this, but
it doesn't know what to decode

22030
22:34:19.811 --> 22:34:22.811
it into. It's like, okay, cool.
I can decode this, but like,

22031
22:34:22.811 --> 22:34:26.811
what, what do you want me to do
with it, and we say, Oh, this is

22032
22:34:26.811 --> 22:34:29.811
a string, so decode it into a
string. And then we can do

22033
22:34:29.811 --> 22:34:33.811
return some string. Now, once
again, we deploy that old

22034
22:34:33.811 --> 22:34:36.811
Cotters, we delete the last
contract, we deploy this new

22035
22:34:36.811 --> 22:34:40.811
one. So in code string, and code
string, whereas in code, string,

22036
22:34:40.811 --> 22:34:43.812
and code string returns this
massive thing, as a human being,

22037
22:34:43.812 --> 22:34:47.812
we're like, God, I can't read
that computers can read that.

22038
22:34:47.812 --> 22:34:50.812
But we can't really read that.
So we say, okay, let's decode

22039
22:34:50.812 --> 22:34:54.812
that back into its string form,
we hit decode string, and we get

22040
22:34:54.812 --> 22:34:58.812
back some string. And now we can
actually multi encode and multi

22041
22:34:58.812 --> 22:35:02.812
and decode, right, we can encode
as much stuff as we want. So I

22042
22:35:02.812 --> 22:35:07.812
can say function, multi ENCODE,
public pure, returns bytes

22043
22:35:07.812 --> 22:35:10.812
memory, we're going to encode a
couple of things, we'll say

22044
22:35:10.812 --> 22:35:16.812
bytes, memory, some string
equals ABI dot encode some

22045
22:35:16.812 --> 22:35:21.812
string, comma, it's bigger. So
we're going to encode two

22046
22:35:21.812 --> 22:35:25.812
strings here, we're gonna encode
some string, and it's bigger. So

22047
22:35:25.812 --> 22:35:29.812
we have two strings, we're going
to encode and we'll return some

22048
22:35:29.812 --> 22:35:33.812
string, even though it's you
know, bytes. And then we can

22049
22:35:33.812 --> 22:35:38.812
actually multi decode. So we'll
say function, multi decode, this

22050
22:35:38.812 --> 22:35:42.812
will be a public pure returns,
we'll say it returns two

22051
22:35:42.812 --> 22:35:46.812
strings, string memory, and
string memory. And instead of

22052
22:35:46.812 --> 22:35:51.812
doing string memory, some string
equals API decode, we'll say,

22053
22:35:51.812 --> 22:35:57.812
string memory, some string,
comma string memory, some other

22054
22:35:57.812 --> 22:36:03.812
string. So we're gonna get to
returns equals Avi dot decode.

22055
22:36:03.812 --> 22:36:07.812
Let's decode this multi encode
result, which is the doubly

22056
22:36:07.812 --> 22:36:12.812
encoded strings into a string
and another string. And then

22057
22:36:12.812 --> 22:36:17.812
we'll return both of these are
some string, there we go. Now

22058
22:36:17.812 --> 22:36:20.812
we'll return some string, and
then some other string,

22059
22:36:20.812 --> 22:36:24.813
I need a semicolon here. So now
when we deploy this, let's close

22060
22:36:24.813 --> 22:36:28.813
this out, deploy this new one,
right, we now have this multi in

22061
22:36:28.813 --> 22:36:32.813
code, which gives us this even
bigger bites object, right?

22062
22:36:32.813 --> 22:36:36.813
Because this is two strings
encoded. And now if we hit multi

22063
22:36:36.813 --> 22:36:38.813
decode, take a second, what do
you think it's going to put out

22064
22:36:38.813 --> 22:36:41.813
output? Let's go ahead and hit
it. Now it's gonna give us two

22065
22:36:41.813 --> 22:36:44.813
strings, right, it's gonna give
you these two strings, some

22066
22:36:44.813 --> 22:36:49.813
string, it's bigger. So we can
tell solidity to encode a bunch

22067
22:36:49.813 --> 22:36:53.813
of stuff. And then we can even
decode it by telling it, okay,

22068
22:36:53.813 --> 22:36:56.813
this big object here, it's two
strings combined, and then we

22069
22:36:56.813 --> 22:37:00.813
decode it. Now you can even
multi encode with that encode

22070
22:37:00.813 --> 22:37:04.813
pack thing, right? We could do
function, multi encode packed,

22071
22:37:04.813 --> 22:37:10.813
public pure returns, bytes
memory, and then bytes memory,

22072
22:37:10.813 --> 22:37:15.813
some string equals ABI dot
encode packed some string,

22073
22:37:15.813 --> 22:37:20.813
comma, it's bigger than return
some string, we could do this,

22074
22:37:20.813 --> 22:37:24.813
right, but this is going to give
us the packed version of these

22075
22:37:24.813 --> 22:37:29.813
two strings. So the decoding
actually isn't going to work on

22076
22:37:29.813 --> 22:37:33.813
this because this is packed
encoding. So if we tried to do,

22077
22:37:33.813 --> 22:37:38.813
I'm gonna say this doesn't work.
Try to do function, multi

22078
22:37:38.813 --> 22:37:45.813
decode, packed, public pure
returns, string memory, string

22079
22:37:45.813 --> 22:37:52.813
memory, some string equals Avi
dot decode multi encode packed

22080
22:37:52.813 --> 22:37:56.813
in a string and have exactly
what we did above to, if we do

22081
22:37:56.813 --> 22:38:00.813
return some string, what do you
think's gonna happen? Let's,

22082
22:38:00.813 --> 22:38:03.814
let's try to delete the old
contract, deploy a new one.

22083
22:38:03.814 --> 22:38:07.814
We'll do multi decode, packed,
multi encode multi decode,

22084
22:38:07.814 --> 22:38:11.814
packed, and we actually just get
an error. solidity basically

22085
22:38:11.814 --> 22:38:15.814
goes, Yeah, this looks like it's
packed. I don't know how to

22086
22:38:15.814 --> 22:38:19.814
decode that. But instead, what
we can do is we can do function

22087
22:38:19.814 --> 22:38:26.814
more to string cast packed like
this a public pure returns

22088
22:38:26.814 --> 22:38:33.814
string memory, string, memory,
some string equals string, multi

22089
22:38:33.814 --> 22:38:39.814
and code packed, return some
string. This one will work right

22090
22:38:39.814 --> 22:38:43.814
because again, this pact
encoding is kind of similar to

22091
22:38:43.814 --> 22:38:48.814
just type casting. So we'll
compile will redeploy multi

22092
22:38:48.814 --> 22:38:52.814
string cast pact, we get some
Trying, it's bigger, right? And

22093
22:38:52.814 --> 22:38:54.814
we don't have a space here. But
we should have put a space in

22094
22:38:54.814 --> 22:39:03.814
there. Now that we've learned
more about this in ABI dot

22095
22:39:03.814 --> 22:39:06.814
encode and decoding, and we know
that okay, this is what the

22096
22:39:06.814 --> 22:39:09.814
computer, this is, what
Aetherium. This is what the EVM,

22097
22:39:09.814 --> 22:39:12.814
or any EVM compatible chain is
looking for. It's looking for

22098
22:39:12.814 --> 22:39:16.814
this bytecode. It's looking for
this, this binary stuff. And we

22099
22:39:16.814 --> 22:39:19.814
just learned a little bit more
about how to encode different

22100
22:39:19.814 --> 22:39:22.814
variables into the binary into
that data bit. Well,

22101
22:39:22.814 --> 22:39:26.814
what do we do now? Now since we
know that our transactions are

22102
22:39:26.814 --> 22:39:30.814
just going to be compiled down
to this binary stuff, what we

22103
22:39:30.814 --> 22:39:35.814
can do then is we can actually
populate this data value of our

22104
22:39:35.814 --> 22:39:38.814
transactions ourselves with the
binary that code is going to

22105
22:39:38.814 --> 22:39:42.815
use. So here's our transaction
for a contract deployment, the

22106
22:39:42.815 --> 22:39:44.815
data field of the contract
deployment is going to be all

22107
22:39:44.815 --> 22:39:49.815
that binary code of the contract
for a function call, the data

22108
22:39:49.815 --> 22:39:53.815
piece is going to be what to
send to the address what data

22109
22:39:53.815 --> 22:39:57.815
what function to call on the to
address. Let's look at another

22110
22:39:57.815 --> 22:39:59.815
one of our transactions on ether
scan right on one of our

22111
22:39:59.815 --> 22:40:02.815
contracts, you don't have to I'm
going to look at enter raffle

22112
22:40:02.815 --> 22:40:06.815
from a previous section. And if
we select down, we look at input

22113
22:40:06.815 --> 22:40:09.815
data. It says function enter
raffle method ID. But if we look

22114
22:40:09.815 --> 22:40:14.815
at the original, this is what's
getting sent in the data field.

22115
22:40:14.815 --> 22:40:18.815
It's this binary, it's this hex
it's this weird, low level bytes

22116
22:40:18.815 --> 22:40:22.815
thing. This is how the Ethereum
blockchain or the or whatever

22117
22:40:22.815 --> 22:40:25.815
EVM chain you're working with
knows which function to call, it

22118
22:40:25.815 --> 22:40:29.815
translates this into a function.
And we can do the exact same

22119
22:40:29.815 --> 22:40:34.815
thing and call these functions
ourselves. So what we can

22120
22:40:34.815 --> 22:40:38.815
actually do with this crazy
newfound data and coding stuff,

22121
22:40:38.815 --> 22:40:43.815
what we can actually do is send
the data field of a transaction

22122
22:40:43.815 --> 22:40:48.815
ourself, in a transaction call
back in this ether throwback

22123
22:40:48.815 --> 22:40:52.815
where this data thing was the
contract creation code. Well,

22124
22:40:52.815 --> 22:40:56.815
instead, we could populate this
data thing with our function

22125
22:40:56.815 --> 22:41:00.815
call code, the exact function
that we want to call in the

22126
22:41:00.815 --> 22:41:04.815
binary in hex addition. Now you
might be thinking, Oh, well, why

22127
22:41:04.815 --> 22:41:08.815
would I do that, I can always
just use the interface, the ABI,

22128
22:41:08.815 --> 22:41:10.815
all that stuff, well, maybe you
don't have that maybe all you

22129
22:41:10.815 --> 22:41:14.815
have is the function name, maybe
all you have is the parameters

22130
22:41:14.815 --> 22:41:17.815
you want to send. Or maybe you
want to make your code, be able

22131
22:41:17.815 --> 22:41:21.815
to send arbitrary functions, or
make arbitrary calls or do

22132
22:41:21.815 --> 22:41:25.816
random really advanced stuff,
right, that's where sending our

22133
22:41:25.816 --> 22:41:27.816
function calls directly by
populating this data field is

22134
22:41:27.816 --> 22:41:30.816
going to be incredibly
important. So remember, I said,

22135
22:41:30.816 --> 22:41:34.816
you're always going to need the
ABI, and the contract address,

22136
22:41:34.816 --> 22:41:37.816
send a function. Now, when I
said, you always need the API.

22137
22:41:37.816 --> 22:41:41.816
Originally, we were kind of
talking about this thing, this

22138
22:41:41.816 --> 22:41:45.816
big, this big thing, which is
cool, which is the API. But this

22139
22:41:45.816 --> 22:41:48.816
is like the human readable API,
you can also do it with the non

22140
22:41:48.816 --> 22:41:52.816
human readable API. And
additionally, you don't need all

22141
22:41:52.816 --> 22:41:56.816
this stuff, you can really use
just the name of a function, and

22142
22:41:56.816 --> 22:42:00.816
then the input types to send a
function call. So the question

22143
22:42:00.816 --> 22:42:05.816
is, then, okay, how do we send?
How do we send transactions that

22144
22:42:05.816 --> 22:42:10.816
call functions with just the
data field populated? And then

22145
22:42:10.816 --> 22:42:14.816
the next question is, how do we
populate the data field? What do

22146
22:42:14.816 --> 22:42:17.816
we populate the data field with
to make one of these function

22147
22:42:17.816 --> 22:42:20.816
calls? And then how do we send
these transactions slowly,

22148
22:42:20.816 --> 22:42:25.816
actually has some more low level
keywords, namely, static call

22149
22:42:25.816 --> 22:42:29.816
and call we actually we've used
call in the past before, does

22150
22:42:29.816 --> 22:42:32.816
this code look at all familiar
to you? Well, it should, because

22151
22:42:32.816 --> 22:42:36.816
this is, we use a similar setup
in our fulfill random words for

22152
22:42:36.816 --> 22:42:40.816
our lottery, right, we sent
money doing this recent winner

22153
22:42:40.816 --> 22:42:42.816
dot call, right? Recently, it
was the address of the recent

22154
22:42:42.816 --> 22:42:46.816
winner, and we did not call. And
then we have this weird stuff in

22155
22:42:46.816 --> 22:42:49.816
this brackets here, and then
nothing in the parentheses. So

22156
22:42:49.816 --> 22:42:52.816
we did actually, essentially, we
use this call keyword

22157
22:42:52.816 --> 22:42:56.816
previously, but we didn't really
tell you what it did. So call is

22158
22:42:56.816 --> 22:42:58.816
how we can call functions to
change the state of the

22159
22:42:58.816 --> 22:43:02.817
blockchain. Static call is
basically how at a low level, we

22160
22:43:02.817 --> 22:43:05.817
call our view, or pure
functions, write static calls

22161
22:43:05.817 --> 22:43:07.817
gonna be like, okay, don't
change the state of the

22162
22:43:07.817 --> 22:43:10.817
blockchain with this one, just
give us the return value. So

22163
22:43:10.817 --> 22:43:13.817
this is kind of similar to like
a view or a pure function at low

22164
22:43:13.817 --> 22:43:17.817
level, there's also a Send word
but like, basically forget about

22165
22:43:17.817 --> 22:43:20.817
it. We're just gonna be working
with call, instead of call. And,

22166
22:43:20.817 --> 22:43:21.817
you know, later on, we'll

22167
22:43:21.817 --> 22:43:23.817
learn about another one called
delegate call. But don't worry

22168
22:43:23.817 --> 22:43:27.817
about that for now. Recent
winter duck call like this, in

22169
22:43:27.817 --> 22:43:30.817
these little squiggly brackets,
we said, Okay, we updated the

22170
22:43:30.817 --> 22:43:33.817
value directly of our
transaction in solidity. So

22171
22:43:33.817 --> 22:43:36.817
which again, if we have these
transaction fields, and we just

22172
22:43:36.817 --> 22:43:40.817
directly updated value in these
little brackets, right, we can

22173
22:43:40.817 --> 22:43:43.817
also directly update gas limited
gas price in these little

22174
22:43:43.817 --> 22:43:46.817
brackets if we wanted to as
well. And in here, these

22175
22:43:46.817 --> 22:43:49.817
parentheses is where we're going
to stick our data. Since all we

22176
22:43:49.817 --> 22:43:52.817
wanted to do with our
withdrawal. function previously

22177
22:43:52.817 --> 22:43:57.817
was send money. We said, Okay,
send money change the value that

22178
22:43:57.817 --> 22:44:00.817
we're going to send. But don't
pass any data, keep that data

22179
22:44:00.817 --> 22:44:05.817
bit empty, which is why, again,
remember how we hit this button

22180
22:44:05.817 --> 22:44:08.817
before, right and we had called
data be empty, that's

22181
22:44:08.817 --> 22:44:12.817
essentially running this command
with called data be empty with

22182
22:44:12.817 --> 22:44:17.817
this section be empty, and then
just updating the value that we

22183
22:44:17.817 --> 22:44:19.817
set with the transaction. And so
it's this section that we can

22184
22:44:19.817 --> 22:44:23.817
use to populate data to actually
call specific functions. We're

22185
22:44:23.817 --> 22:44:25.817
going to put a whole bunch more
comments here. So when our

22186
22:44:25.817 --> 22:44:27.817
squiggly brackets, we're able to
pass specific fields of a

22187
22:44:27.817 --> 22:44:31.817
transaction like value. And in
our parentheses, we're able to

22188
22:44:31.817 --> 22:44:34.817
pass data in order to call a
specific function. But in here,

22189
22:44:34.817 --> 22:44:37.817
there's no function to call
since we were just sending them

22190
22:44:37.817 --> 22:44:40.817
if we want to call a function or
send any data, we can do this in

22191
22:44:40.817 --> 22:44:49.818
the parentheses. And I think I
spelt that wrong. Now, we've

22192
22:44:49.818 --> 22:44:52.818
learned a ton here. So let's do
a quick refresher of what we

22193
22:44:52.818 --> 22:44:55.818
just learned. And then we're
going to actually learn how we

22194
22:44:55.818 --> 22:44:59.818
can call any function just by
using this syntax here. Well, we

22195
22:44:59.818 --> 22:45:02.818
learned from really high level,
if we want to combine strings,

22196
22:45:02.818 --> 22:45:05.818
we can do ABI dot encode packed
and then typecast that to a

22197
22:45:05.818 --> 22:45:09.818
string. And in newer versions of
solidity you can do, you can do

22198
22:45:09.818 --> 22:45:16.818
string dot concat, you know, Hi,
Mom, come on, miss you. In newer

22199
22:45:16.818 --> 22:45:18.818
versions of solidity. This works
as well, but not in older

22200
22:45:18.818 --> 22:45:22.818
versions of solidity. Then we
learned a lot about some low

22201
22:45:22.818 --> 22:45:25.818
level stuff we learned, okay,
when we compile our contracts,

22202
22:45:25.818 --> 22:45:29.818
we get an ABI file, and this
weird binary thing that numbers

22203
22:45:29.818 --> 22:45:33.818
and letters stuff that gets when
we deploy a contract that gets

22204
22:45:33.818 --> 22:45:37.818
sent in the data field of our
contract creation transaction.

22205
22:45:37.818 --> 22:45:40.818
So for contract creations, the
data is populated with that

22206
22:45:40.818 --> 22:45:43.818
binary code for function calls
is going to define which

22207
22:45:43.818 --> 22:45:46.818
functions to call in with what
parameters and this is what

22208
22:45:46.818 --> 22:45:49.818
we're gonna go over next. Now,
we learned that we can actually

22209
22:45:49.818 --> 22:45:54.818
encode stuff into this binary
into this low level code. And

22210
22:45:54.818 --> 22:45:58.818
any program any process that can
read this low level stuff and

22211
22:45:58.818 --> 22:46:02.818
execute accordingly, read this
EVM stuff, read the specific

22212
22:46:02.818 --> 22:46:05.818
binary that Aetherium has
specified, or the EVM has

22213
22:46:05.818 --> 22:46:09.818
specified is considered EVM.
compatible. We can encode

22214
22:46:09.818 --> 22:46:12.818
numbers, we can encode strings,
we can encode pretty much

22215
22:46:12.818 --> 22:46:16.818
anything we want to encode. To
save space, we do encode packed,

22216
22:46:16.818 --> 22:46:20.818
we can decode stuff that we've
encoded, but we can't decode

22217
22:46:20.818 --> 22:46:24.819
stuff that we encode packed, we
can multi encode stuff, and then

22218
22:46:24.819 --> 22:46:27.819
multi decode stuff. And then
finally, we can use this call

22219
22:46:27.819 --> 22:46:32.819
function and add data in here to
make any call that we want to

22220
22:46:32.819 --> 22:46:35.819
any smart contract. And this is
what we're going to learn next.

22221
22:46:35.819 --> 22:46:37.819
Alright, so now's a great time
to take a break, because we just

22222
22:46:37.819 --> 22:46:40.819
learned some really difficult
concepts. And like I said, if

22223
22:46:40.819 --> 22:46:41.819
you don't get it the first

22224
22:46:41.819 --> 22:46:49.819
time, that is okay. Alright,
welcome back. Now that we've

22225
22:46:49.819 --> 22:46:52.819
learned about this encoding
stuff, let's learn how we can

22226
22:46:52.819 --> 22:46:56.819
populate this parenthesis this
data field, so we can call any

22227
22:46:56.819 --> 22:47:00.819
function and we can do
essentially, what the blockchain

22228
22:47:00.819 --> 22:47:03.819
is going to do at the low level,
we can work with just that

22229
22:47:03.819 --> 22:47:05.819
binary, we can work with just
that bytes, we can work with

22230
22:47:05.819 --> 22:47:08.819
that hex to interact with our
smart contracts. So let's create

22231
22:47:08.819 --> 22:47:12.819
a new file. And we're gonna call
it call anything, that's all

22232
22:47:12.819 --> 22:47:16.819
start off with spdx, license
identifier, MIT. And let's talk

22233
22:47:16.819 --> 22:47:19.819
about this. Now in order to call
now in order to call a function

22234
22:47:19.819 --> 22:47:23.819
using only the data field of the
call, we need to encode the

22235
22:47:23.819 --> 22:47:26.819
function name, and the
parameters that we want to add,

22236
22:47:26.819 --> 22:47:27.819
right, because when we call a
function, we call the function

22237
22:47:27.819 --> 22:47:31.819
name. And we call the
parameters. So we need to encode

22238
22:47:31.819 --> 22:47:35.819
these down to the binary level
so that the EVM, or these

22239
22:47:35.819 --> 22:47:38.819
Aetherium based smart contracts
and solidity stuff can

22240
22:47:38.819 --> 22:47:40.819
understand what's actually going
on. In order to do this, we're

22241
22:47:40.819 --> 22:47:44.819
going to need to work with two
concepts to encode the function

22242
22:47:44.819 --> 22:47:48.819
name so that the EVM or solidity
can understand it, we actually

22243
22:47:48.819 --> 22:47:51.819
have to grab something called
the function selector. Now the

22244
22:47:51.819 --> 22:47:54.819
function selector is going to be
the first four bytes of the

22245
22:47:54.819 --> 22:47:58.819
function signature. And the
function signature is just going

22246
22:47:58.819 --> 22:48:00.819
to be a string, which defines
the function name of parameter.

22247
22:48:00.819 --> 22:48:03.820
Now, what does this actually
mean? Well, if we have a

22248
22:48:03.820 --> 22:48:06.820
transfer function, this right
here is known as the function

22249
22:48:06.820 --> 22:48:09.820
signature. So the function name
is going to be transfer. And

22250
22:48:09.820 --> 22:48:14.820
it's going to take an address
and a un 256 as its inputs, if

22251
22:48:14.820 --> 22:48:17.820
we encode this transfer
function, and then we take the

22252
22:48:17.820 --> 22:48:21.820
first four bytes of it, we get
this, which refers to the

22253
22:48:21.820 --> 22:48:25.820
function selector. So that's how
solidity knows. So in the

22254
22:48:25.820 --> 22:48:29.820
bytecode, in the binary code,
this function selector is how

22255
22:48:29.820 --> 22:48:32.820
slitting knows Oh, they're
talking about the transfer

22256
22:48:32.820 --> 22:48:35.820
function they want me to call
the transfer function. And this

22257
22:48:35.820 --> 22:48:38.820
is one of the first things that
we need to use call to call any

22258
22:48:38.820 --> 22:48:42.820
function that we want, we need
to get the function selector and

22259
22:48:42.820 --> 22:48:44.820
we can get it a number of
different ways but one of the

22260
22:48:44.820 --> 22:48:47.820
ways is by encoding the function
signature and grabbing the first

22261
22:48:47.820 --> 22:48:51.820
four bytes. So we'll create this
contract we'll do pragma

22262
22:48:51.820 --> 22:48:57.820
solidity zero point 8.7 Say
contract, call anything. And

22263
22:48:57.820 --> 22:49:00.820
we'll give this to stored
variables, give the to stored

22264
22:49:00.820 --> 22:49:04.820
variables and address public s,
underscore some amount, or some

22265
22:49:04.820 --> 22:49:10.820
address, and then you in 256,
public s underscore mount. And

22266
22:49:10.820 --> 22:49:12.820
then we'll create a function
called transfer function

22267
22:49:12.820 --> 22:49:15.820
transfer. Now normally in here,
we would actually do like

22268
22:49:15.820 --> 22:49:19.820
transfer for like an ERC 20
transfer, but we're just going

22269
22:49:19.820 --> 22:49:24.820
to do address some address, and
then you add 256 amount, amount

22270
22:49:24.820 --> 22:49:28.820
here, we'll make this a public
function. And then all we'll do

22271
22:49:28.820 --> 22:49:32.820
is we'll set S, some address
equals some address, and then s

22272
22:49:32.820 --> 22:49:36.820
amount equals amount. So here's
gonna be the function that we're

22273
22:49:36.820 --> 22:49:39.820
going to work with. And the
function selector for that

22274
22:49:39.820 --> 22:49:43.821
function is this, the function
signature is this. So it takes

22275
22:49:43.821 --> 22:49:46.821
an address some address amount,
that gets boiled down to the

22276
22:49:46.821 --> 22:49:49.821
function selector, and the
function signature. And of

22277
22:49:49.821 --> 22:49:52.821
course, in our bytecode, there's
going to be some code saying,

22278
22:49:52.821 --> 22:49:55.821
Okay, here's what this function
does, blah, blah, blah. So we

22279
22:49:55.821 --> 22:49:57.821
can actually even write a
function to get that function

22280
22:49:57.821 --> 22:50:01.821
selector. So we can say,
function, get selector and I'm

22281
22:50:01.821 --> 22:50:03.821
gonna say get selector one,
because I'm gonna show you a few

22282
22:50:03.821 --> 22:50:05.821
ways to get the function
selector, we'll make this a

22283
22:50:05.821 --> 22:50:11.821
public pure. And we'll have this
return a bytes for selector, we

22284
22:50:11.821 --> 22:50:17.821
could say select or equals bytes
for, and then we hash with a

22285
22:50:17.821 --> 22:50:25.821
check to 56 of the bytes of that
signature, which is transfer.

22286
22:50:25.821 --> 22:50:31.821
And it takes an address and a
UNT 56. Right? If we compile

22287
22:50:31.821 --> 22:50:34.821
this, and then we run it, let's
get rid of our old contract,

22288
22:50:34.821 --> 22:50:37.821
deploy, make sure we're on call
anything, if you have the other

22289
22:50:37.821 --> 22:50:41.821
one up. In here, now we have a
couple of things, we hit Get

22290
22:50:41.821 --> 22:50:47.821
selector one, we get this Oh X,
a 905, blah, blah, blah, right.

22291
22:50:47.821 --> 22:50:49.821
And that's the same as the
example I just gave. So this

22292
22:50:49.821 --> 22:50:53.821
right here tells solidity tells
our smart contract, okay, when

22293
22:50:53.821 --> 22:50:57.821
we make a call to this contract,
if you see this in the function

22294
22:50:57.821 --> 22:51:01.821
data, this is referring to our
transfer function with an

22295
22:51:01.821 --> 22:51:05.821
address and a un 256 as input
parameter. So we see address you

22296
22:51:05.821 --> 22:51:09.821
into 56. Our function knows to
execute this data here. Great.

22297
22:51:09.821 --> 22:51:12.821
And then of course, sml, and S
address are zeros. Now, while

22298
22:51:12.821 --> 22:51:15.821
we're here, we can also see,
okay, what happens if we call

22299
22:51:15.821 --> 22:51:18.821
the transfer function, right? It
takes an address and an amount,

22300
22:51:18.821 --> 22:51:21.821
so let's just give it its own
address or an address. And we'll

22301
22:51:21.821 --> 22:51:25.822
do 777 for an amount. If we hit
transfer, we have the log up,

22302
22:51:25.822 --> 22:51:28.822
right, we'll get a little
checkmark here saying success.

22303
22:51:28.822 --> 22:51:32.822
Now, if we hit S amount, we'll
get 777. And then the address

22304
22:51:32.822 --> 22:51:34.822
will be the same, right? So
that's us directly calling

22305
22:51:34.822 --> 22:51:38.822
transfer. When we directly call
transfer, we're basically

22306
22:51:38.822 --> 22:51:41.822
saying, hey, grab this function
selector, and then do some other

22307
22:51:41.822 --> 22:51:43.822
stuff, which we'll we'll tell
you the other stuff in a minute.

22308
22:51:43.822 --> 22:51:46.822
Now we have the function
selector. Okay, great. What else

22309
22:51:46.822 --> 22:51:49.822
do we need, we also now need the
parameters we want to add. So

22310
22:51:49.822 --> 22:51:54.822
we're going to need to encode
those parameters with our

22311
22:51:54.822 --> 22:51:56.822
function selector. So what we're
gonna do is we're gonna say

22312
22:51:56.822 --> 22:52:02.822
function, get data to call
transfer. And in here, we're

22313
22:52:03.822 --> 22:52:05.822
just going to have this get data
to call transfer, we're going to

22314
22:52:05.822 --> 22:52:07.822
have it take these input
parameters, and we're going to

22315
22:52:07.822 --> 22:52:11.822
encode these to work with our
function selector, we're gonna

22316
22:52:11.822 --> 22:52:18.822
say address, some address. And
if it is x, amount, public pure

22317
22:52:18.822 --> 22:52:22.822
returns, bytes memory.

22318
22:52:22.822 --> 22:52:26.822
And then we can return and use
one of those ABI and codings

22319
22:52:26.822 --> 22:52:29.822
from the cheat sheet. Now, so
far, we've just been doing API

22320
22:52:29.822 --> 22:52:32.822
and code for a lot of our
encoding. So it since we have

22321
22:52:32.822 --> 22:52:37.822
the function selector, we can
actually do ABI dot encode with

22322
22:52:37.822 --> 22:52:40.822
selector. This ABI encodes the
given arguments starting from

22323
22:52:40.822 --> 22:52:43.822
the second and prepends, the
given four byte selector. When

22324
22:52:43.822 --> 22:52:47.822
we do in Cobra selector, we're
just sticking our selector onto

22325
22:52:47.822 --> 22:52:49.822
the data that we're going to
give it. So we're going to do

22326
22:52:49.822 --> 22:52:56.822
return API dot encode with
select door. And we're going to

22327
22:52:56.822 --> 22:53:00.822
pass it the result of get
selector one, and then we're

22328
22:53:00.822 --> 22:53:05.823
going to give it some address,
and amount. So what this is

22329
22:53:05.823 --> 22:53:08.823
going to do, it's gonna give us
all the data that we need to put

22330
22:53:08.823 --> 22:53:11.823
in that data field of our
transaction, to send to this

22331
22:53:11.823 --> 22:53:15.823
contract to let this contract
know, hey, go use the transfer

22332
22:53:15.823 --> 22:53:18.823
function, pass in some address,
and then an amount. And then if

22333
22:53:18.823 --> 22:53:22.823
we compile this, we run it,
let's delete our old contract,

22334
22:53:22.823 --> 22:53:25.823
we'll deploy up, we now got a
new function called Get Data to

22335
22:53:25.823 --> 22:53:29.823
call and transfer, we'll just
pass you know, we'll just pass

22336
22:53:29.823 --> 22:53:34.823
this contract address and then
we'll also do 777 again. And so

22337
22:53:34.823 --> 22:53:37.823
this thing right here is what
we're going to put into the data

22338
22:53:37.823 --> 22:53:41.823
field of our transaction in
order for us to call transfer

22339
22:53:41.823 --> 22:53:45.823
from anywhere. So this is the
bytes This is the binary encoded

22340
22:53:45.823 --> 22:53:50.823
data of Hey, call the transfer
function with this address that

22341
22:53:50.823 --> 22:53:54.823
we specified. with, you know,
777 Mt. So what we can do once

22342
22:53:54.823 --> 22:53:57.823
we have all this, we can
actually call our transfer

22343
22:53:57.823 --> 22:54:01.823
function without even having to
directly call it. So what we can

22344
22:54:01.823 --> 22:54:07.823
do is we can say function, call
transfer function directly, or I

22345
22:54:07.823 --> 22:54:11.823
guess with binary might be a
better title, but you get the

22346
22:54:11.823 --> 22:54:16.823
gist, we'll say address some
address, you in 256 amount,

22347
22:54:16.823 --> 22:54:18.823
we'll make this a public
function. And we'll have a

22348
22:54:18.823 --> 22:54:23.823
returns a bytes four and a bool.
You'll see why in a minute. And

22349
22:54:23.823 --> 22:54:27.823
we'll do that same call thing
that we did to send our raffle

22350
22:54:27.823 --> 22:54:31.823
money. So what we'll do is,
before we did recent winner dot

22351
22:54:31.823 --> 22:54:34.823
call, right, we're going to do
some address. And then for us,

22352
22:54:34.823 --> 22:54:38.823
we're going to address this dot
call. And then we're saying this

22353
22:54:38.823 --> 22:54:41.823
contracts address which we could
put any address here address dot

22354
22:54:41.823 --> 22:54:46.824
call, and we're going to call
the encoded data that points us

22355
22:54:46.824 --> 22:54:50.824
to the transfer function with
some parameters. So we're going

22356
22:54:50.824 --> 22:54:54.824
to do address this.com. And we
could just do get data to call

22357
22:54:54.824 --> 22:54:56.824
transfer

22358
22:54:56.824 --> 22:55:01.824
address amounts, right, we could
do it like this. Or we could do

22359
22:55:01.824 --> 22:55:04.824
it kind of the wrong way. We
could do ABI dot and code with

22360
22:55:04.824 --> 22:55:10.824
select dorm, get selector one,
comma, some address, comma

22361
22:55:10.824 --> 22:55:14.824
amount. And actually, there's no
semicolon there, sorry. So those

22362
22:55:14.824 --> 22:55:18.824
are going to be the same. And
this dot call thing, right, it's

22363
22:55:18.824 --> 22:55:21.824
going to return exactly what we
saw before, it's going to return

22364
22:55:21.824 --> 22:55:23.824
a bool success. So whether or
not the transaction was

22365
22:55:23.824 --> 22:55:29.824
successful, and then bytes,
memory, returned data, which is

22366
22:55:29.824 --> 22:55:32.824
going to be you know, whatever
the call returns. So right, and

22367
22:55:32.824 --> 22:55:35.824
this is where we put like
require success, right. But for

22368
22:55:35.824 --> 22:55:40.824
us, we're just going to return
bytes, four bytes for a return

22369
22:55:40.824 --> 22:55:43.824
datum, and then success. So
we're just going to return the

22370
22:55:43.824 --> 22:55:47.824
first four bytes of whatever
data we get returned. And then

22371
22:55:47.824 --> 22:55:49.824
we're going to return whether
this was successful or not. So

22372
22:55:49.824 --> 22:55:53.824
this function is going to have
us directly call the transfer

22373
22:55:54.824 --> 22:55:57.824
function by passing these
parameters without us having to

22374
22:55:57.824 --> 22:56:01.824
do like contract dot transfer,
or, or transfer whatever, right.

22375
22:56:01.824 --> 22:56:04.824
And you can do this across
multiple contracts across

22376
22:56:04.824 --> 22:56:07.824
different contracts, just by
changing the address that you

22377
22:56:07.824 --> 22:56:10.824
call on. So let's go ahead and
compile this. We'll run this now

22378
22:56:10.824 --> 22:56:13.824
we'll delete our old contract,
we'll deploy call anything. Now

22379
22:56:13.824 --> 22:56:17.824
if we if we were. So right now
sml, and estimators are both

22380
22:56:17.824 --> 22:56:21.824
zero. Now, if we do call
transfer function directly, and

22381
22:56:21.824 --> 22:56:26.825
we'll pass in this one's
address, and then we'll do 777.

22382
22:56:26.825 --> 22:56:31.825
Now, if we pull up the logs, we
hit this, we're gonna get this

22383
22:56:31.825 --> 22:56:35.825
transaction response here. But
if we scroll down, we'll ever

22384
22:56:35.825 --> 22:56:38.825
see the decoded output, which is
a bytes for of just a bunch of

22385
22:56:38.825 --> 22:56:41.825
zeros, right? Because our
transfer doesn't actually return

22386
22:56:41.825 --> 22:56:44.825
anything. So it's just gonna be
a whole bunch of zeros, and then

22387
22:56:44.825 --> 22:56:47.825
our Boolean true, which means it
was successful. So since it was

22388
22:56:47.825 --> 22:56:51.825
successful, these two should
have changed based off of that.

22389
22:56:51.825 --> 22:56:54.825
So let's go ahead and try them
out. And we do indeed see that

22390
22:56:54.825 --> 22:56:58.825
they're changed. So we have just
directly called this transfer

22391
22:56:58.825 --> 22:57:01.825
function without having to call
the transfer function itself, we

22392
22:57:01.825 --> 22:57:05.825
can also do encode with
signature instead of selector.

22393
22:57:05.825 --> 22:57:08.825
So if we go to our cheat sheet,
there's also this encode with

22394
22:57:08.825 --> 22:57:12.825
signature down here, which takes
the string memory signature, and

22395
22:57:12.825 --> 22:57:15.825
it's equivalent to doing ABI dot
encode with selector bytes for

22396
22:57:15.825 --> 22:57:18.825
CAC bytes, you know, signature,
it's, it's equivalent to doing

22397
22:57:18.825 --> 22:57:23.825
exactly what we did up here. But
it does this step for us. So we

22398
22:57:23.825 --> 22:57:26.825
could copy this whole thing,
paste it down here, right, and

22399
22:57:26.825 --> 22:57:30.825
we could do, instead of encoded
with selector, we can do encode

22400
22:57:30.825 --> 22:57:35.825
with SIG netshare, the function
signature, and then we'll copy

22401
22:57:35.825 --> 22:57:39.825
our function signature from up
here, paste that in here.

22402
22:57:39.825 --> 22:57:43.825
Compile, we ran into a
compilation error, up, these are

22403
22:57:43.825 --> 22:57:48.825
the same call transfer function
directly SIG, called that

22404
22:57:48.825 --> 22:57:53.825
compile, leader, old contract,
deploy. Now these two are both

22405
22:57:53.825 --> 22:57:56.825
zeros again. Now if we copy the
contract address, we do call

22406
22:57:56.825 --> 22:57:59.825
contract call transfer function
directly SIG. We paste that in

22407
22:57:59.825 --> 22:58:03.826
here, we do 777, we call it, let
me check these we can see that

22408
22:58:03.826 --> 22:58:07.826
that does the exact same thing.
So this is API dot encode with

22409
22:58:07.826 --> 22:58:10.826
signature. This is abi dot
encode selector. Encode with

22410
22:58:10.826 --> 22:58:14.826
signature just turns us into the
selector for us. That's all up

22411
22:58:14.826 --> 22:58:17.826
here, we just, we encoded this
selector ourselves. Now, there

22412
22:58:17.826 --> 22:58:20.826
are a whole bunch of different
ways to get the selectors. And

22413
22:58:20.826 --> 22:58:22.826
we're not going to code these
out ourselves. I'm just gonna

22414
22:58:22.826 --> 22:58:29.826
say a bunch of different ways to
get selector. And who knows why

22415
22:58:29.826 --> 22:58:31.826
why you might want to use one of
these other reasons, right?

22416
22:58:31.826 --> 22:58:34.826
There's there's a ton of reasons
why you might want to get the

22417
22:58:34.826 --> 22:58:36.826
selector a different way. And
here's some now in this video,

22418
22:58:36.826 --> 22:58:40.826
we're not going to explain or go
over all these different all

22419
22:58:40.826 --> 22:58:43.826
these different function
selector getting methods. But if

22420
22:58:43.826 --> 22:58:45.826
you go through them in the
GitHub repo associated with this

22421
22:58:45.826 --> 22:58:48.826
course, they all have a ton of
comments to explain what they're

22422
22:58:48.826 --> 22:58:50.826
doing. Well, we are going to
show you though, it's actually

22423
22:58:50.826 --> 22:58:53.826
how to contracts can interact
with each other without actually

22424
22:58:53.826 --> 22:58:56.826
having all the code for each
contract. So we're going to make

22425
22:58:56.826 --> 22:59:00.826
a second contract that has all
this binary this byte

22426
22:59:00.826 --> 22:59:03.826
information to call the transfer
function on a different

22427
22:59:03.826 --> 22:59:06.826
contract. And we're gonna show
you how that can work. This is

22428
22:59:06.826 --> 22:59:08.826
just another contract that I've
made called call function

22429
22:59:09.826 --> 22:59:11.826
without contract. Actually, down
here, we're going to call the

22430
22:59:11.826 --> 22:59:15.826
transfer function, just by using
the address and the function

22431
22:59:15.826 --> 22:59:18.826
selector signature and stuff,
we're going to update these

22432
22:59:18.826 --> 22:59:22.826
storage variables in our call
anything contract from another

22433
22:59:22.826 --> 22:59:26.826
contract just by doing this
binary calling, if you will,

22434
22:59:26.826 --> 22:59:29.826
right, so let's compile, it's
going to deploy, we can actually

22435
22:59:29.826 --> 22:59:32.826
leave this up right, we can
leave this up is let's deploy

22436
22:59:32.826 --> 22:59:36.826
our call function without
contract, we'll pass it as an

22437
22:59:36.826 --> 22:59:40.826
input parameter, the call
anything contract address, we'll

22438
22:59:40.826 --> 22:59:45.827
deploy it. Now in here, I can
call the transfer function

22439
22:59:45.827 --> 22:59:50.827
directly by you know, maybe I'll
switch it to this, this contract

22440
22:59:50.827 --> 22:59:53.827
address this new contract
address, and we'll give it a new

22441
22:59:53.827 --> 22:59:57.827
number of 123. Right, and we'll
click call transfer function.

22442
22:59:57.827 --> 22:59:59.827
And then when we go back up
here, we see that this has

22443
22:59:59.827 --> 23:00:03.827
indeed been updated. Now doing
this call stuff is considered

22444
23:00:03.827 --> 23:00:06.827
low level. And it's a best
practice to try to avoid it when

22445
23:00:06.827 --> 23:00:09.827
you can. So if you can import an
interface, it's much better to

22446
23:00:09.827 --> 23:00:11.827
do it like that. Because you're
going to have the compiler on

22447
23:00:11.827 --> 23:00:13.827
your side, you're going to be
able to check to see if your

22448
23:00:13.827 --> 23:00:17.827
types are matching and all this
other stuff. So usually doing

22449
23:00:17.827 --> 23:00:20.827
these low level calls some
security auditor checkers might

22450
23:00:21.827 --> 23:00:24.827
say, hey, like this books been
out a little bit, you doing this

22451
23:00:24.827 --> 23:00:24.827
low level stuff.

22452
23:00:24.827 --> 23:00:28.827
But with that being said, You
have just learned a ton about

22453
23:00:28.827 --> 23:00:31.827
lower level solidity. This is
some really advanced stuff. And

22454
23:00:31.827 --> 23:00:34.827
like I said, if this was hard,
if you're kind of confused here,

22455
23:00:34.827 --> 23:00:37.827
don't worry, you can always come
back to this section and try it

22456
23:00:37.827 --> 23:00:39.827
again, when you're a little bit
more advanced, if you want to

22457
23:00:39.827 --> 23:00:43.827
try to understand it all now.
Awesome. Absolutely, we've left

22458
23:00:43.827 --> 23:00:45.827
some links in the GitHub repo
associated with this lesson that

22459
23:00:45.827 --> 23:00:48.827
I definitely recommend you check
out one of the ones you should

22460
23:00:48.827 --> 23:00:51.827
definitely check out, it's going
to be this deconstructing

22461
23:00:51.827 --> 23:00:55.827
solidity by openzeppelin, it
really breaks down exactly

22462
23:00:55.827 --> 23:00:57.827
what's going on behind the
scenes of a contract. If you

22463
23:00:57.827 --> 23:00:59.827
want to learn more about
opcodes, about low level stuff,

22464
23:00:59.827 --> 23:01:02.827
definitely give this a read, it
is a phenomenal read,

22465
23:01:02.827 --> 23:01:04.827
essentially, it breaks down a
little bit more than what we

22466
23:01:04.827 --> 23:01:08.827
went over here. A couple other
videos as well. And I've left a

22467
23:01:08.827 --> 23:01:09.827
whole bunch of links in here

22468
23:01:09.827 --> 23:01:19.827
too. With that being said, here
we are back in our NFT. And now

22469
23:01:19.827 --> 23:01:22.827
we know all about this ABI dot
encoding stuff, right and what

22470
23:01:22.827 --> 23:01:25.828
it does, and we know that ABI
dot encode packed, the way we're

22471
23:01:25.828 --> 23:01:27.828
using here is just a way to
concatenate strings. And we're

22472
23:01:27.828 --> 23:01:30.828
not using ABI dot encode for
really any of its crazy

22473
23:01:30.828 --> 23:01:33.828
superpowers, but we might in the
later section of this course. In

22474
23:01:33.828 --> 23:01:37.828
other case, so we do use this
base 64 dot encode thing that

22475
23:01:37.828 --> 23:01:41.828
we've imported, right, we
imported this base 64 dot encode

22476
23:01:41.828 --> 23:01:46.828
so that we can encode our SVG
that we pass it in to its base

22477
23:01:46.828 --> 23:01:48.828
64 encoding. I'm going to copy
paste an example here, you don't

22478
23:01:48.828 --> 23:01:51.828
have to do this. But like, for
example, we'll pass it in like

22479
23:01:51.828 --> 23:01:55.828
SVG width equals blah, blah,
blah, all this SVG stuff, kind

22480
23:01:55.828 --> 23:01:59.828
of similar to what I was showing
you before, we pass that in as

22481
23:01:59.828 --> 23:02:02.828
an input parameter here, and
output it, we're gonna get the

22482
23:02:02.828 --> 23:02:05.828
base 64 encoding of it, we're
gonna get this massive kind of

22483
23:02:05.828 --> 23:02:08.828
string here. We will test this
later to make sure that this

22484
23:02:08.828 --> 23:02:12.828
works. Normally, if I added a
function in like this right now,

22485
23:02:12.828 --> 23:02:14.828
I probably would test it right
away. For now we can just leave

22486
23:02:14.828 --> 23:02:17.828
it in here. That's going to be
great for getting this image

22487
23:02:17.828 --> 23:02:21.828
here. But we don't want just an
image, right? We were going to

22488
23:02:21.828 --> 23:02:25.828
need that metadata. We need this
to be a JSON object, not just an

22489
23:02:25.828 --> 23:02:30.828
image URL like this, we need
stick this image, this base 64

22490
23:02:30.828 --> 23:02:35.828
encoded image into this image
field of our JSON. So how do we

22491
23:02:35.828 --> 23:02:39.828
actually do this? Well, what we
can do is we know that our ERC

22492
23:02:39.828 --> 23:02:44.828
721 code comes with a token URI,
and it's that token URI that

22493
23:02:44.828 --> 23:02:48.828
points to this, which tells us
what our code is going to look

22494
23:02:48.828 --> 23:02:52.828
like. So what we can do is we
can actually base 64 encode our

22495
23:02:52.828 --> 23:02:58.828
JSON as well, to turn into a
JSON token URI. So we basically

22496
23:02:58.828 --> 23:03:01.828
four encoded this image to get
this, we're going to stick this

22497
23:03:01.828 --> 23:03:05.829
URL into our JSON. And then
we're going to base 64 encode

22498
23:03:05.829 --> 23:03:09.829
our JSON, and that's going to be
the URI that our token uses. So

22499
23:03:09.829 --> 23:03:14.829
we have our function, token URI,
right. And this takes a un 256

22500
23:03:14.829 --> 23:03:20.829
token ID, we'll say it's going
to be a public view, public view

22501
23:03:20.829 --> 23:03:24.829
override, and it returns a
string memory. So we're going to

22502
23:03:24.829 --> 23:03:29.829
override the token URI function
of the ERC 721 to whatever we

22503
23:03:29.829 --> 23:03:33.829
want it to be. And here we're
going to encode some JSON text

22504
23:03:33.829 --> 23:03:39.829
that we give our contract into a
base 64 based JSON token URI

22505
23:03:39.829 --> 23:03:45.829
just to get started we'll do a
require underscore exists. Token

22506
23:03:45.829 --> 23:03:51.829
ID, and then I'm just gonna say
your I query for non existent

22507
23:03:51.829 --> 23:03:56.829
token. And yeah, this price
should be an if not exists,

22508
23:03:56.829 --> 23:03:59.829
Revert with an error. However,
we're just going to go like

22509
23:03:59.829 --> 23:04:05.829
this. And this exists function
comes in my ear C 721. So we're

22510
23:04:05.829 --> 23:04:07.829
going to do same thing here. So
we're gonna say require this

22511
23:04:07.829 --> 23:04:10.829
token, a D exists. And again, we
can 100 percent. And probably should

22512
23:04:10.829 --> 23:04:14.829
make this an IF EXISTS token,
ID, you know, now what we want

22513
23:04:14.829 --> 23:04:17.829
to do is we want to figure out
how to make this token URI

22514
23:04:17.829 --> 23:04:23.829
return a base 64 encoded version
of this JSON. So first, we know

22515
23:04:23.829 --> 23:04:26.829
how to how to concatenate a
string, right, so that's gonna

22516
23:04:26.829 --> 23:04:28.829
be the first thing that we're
going to do. So we'll do API dot

22517
23:04:28.829 --> 23:04:33.829
and code packed. And we're going
to encode ourselves the JSON on

22518
23:04:33.829 --> 23:04:36.829
chain, we're going to use single
quotes here, because inside of

22519
23:04:36.829 --> 23:04:39.829
this API and code packed, we're
going to use double quotes in

22520
23:04:39.829 --> 23:04:43.830
here is where we're going to add
our JSON. So we'll give a name,

22521
23:04:43.830 --> 23:04:47.830
right, so the first piece of
metadata needs to be a name. So

22522
23:04:47.830 --> 23:04:52.830
we'll give it a name. And we'll
put a comma here. And we'll say

22523
23:04:52.830 --> 23:04:57.830
the name of this NF T is going
to be the name we get from, we

22524
23:04:57.830 --> 23:05:00.830
have a name function, which
returns the name. So we're gonna

22525
23:05:00.830 --> 23:05:02.830
say the name is going to be the
name. And we're gonna just

22526
23:05:02.830 --> 23:05:05.830
concatenate all this stuff, name
right there. We're gonna

22527
23:05:05.830 --> 23:05:09.830
continue on with the JSON. So we
put a little quote here, and a

22528
23:05:09.830 --> 23:05:13.830
little quote here. So we
encapsulate this name in quotes,

22529
23:05:13.830 --> 23:05:16.830
right? Because remember, we're,
we're concatenating, this big

22530
23:05:16.830 --> 23:05:19.830
string that we're making here,
we'll do a comma, we'll say,

22531
23:05:19.830 --> 23:05:23.830
description, we'll do another
quote. And this time, we're just

22532
23:05:23.830 --> 23:05:26.830
going to put the description
ourselves, and we'll say, and

22533
23:05:26.830 --> 23:05:32.830
NFT, that changes, based on the
chain link feed, we'll put an

22534
23:05:32.830 --> 23:05:35.830
end quote here and a comma, and
we'll put a comma outside the

22535
23:05:35.830 --> 23:05:42.830
quote, down here, we'll say,
attributes.

22536
23:05:42.830 --> 23:05:53.830
We'll just say, trait type, it's
going to be coolness. Comma,

22537
23:05:53.830 --> 23:06:01.830
value, me 100. Boom, to a comma
to image. We'll put a comma out

22538
23:06:01.830 --> 23:06:05.830
here. And this is where we're
going to put our image URI,

22539
23:06:05.830 --> 23:06:08.830
image URI, which we're going to
have to get from somewhere. So

22540
23:06:08.830 --> 23:06:12.830
for now, I'm just gonna say,
string.

22541
23:06:12.830 --> 23:06:16.830
Memory image URI equals i,
right, which clearly isn't an

22542
23:06:16.830 --> 23:06:18.830
image arrived. But just to make
this format and stuff, we'll

22543
23:06:18.830 --> 23:06:21.830
we'll put this there. This is
where we're going to put that

22544
23:06:21.830 --> 23:06:26.831
image URI that we get from SVG
to image URI. And then that's

22545
23:06:26.831 --> 23:06:31.831
it. I mean, close off our JSON,
though. So doing ABI dot encode

22546
23:06:31.831 --> 23:06:34.831
pack is going to concatenate
this all together. So this is

22547
23:06:34.831 --> 23:06:37.831
basically going to be a string
that looks like this. Great. But

22548
23:06:37.831 --> 23:06:43.831
how do we turn this into a base
64 encoded token you arrive so

22549
23:06:43.831 --> 23:06:45.831
that other people can read it is
we're going to typecast this

22550
23:06:45.831 --> 23:06:48.831
whole thing to bytes. And then
now that this whole thing is in

22551
23:06:48.831 --> 23:06:52.831
bytes, we can do exactly what we
did with the SVG above is now we

22552
23:06:52.831 --> 23:06:57.831
can base 64 encoded. So we'll do
base 64, dot ENCODE. And then

22553
23:06:57.831 --> 23:07:00.831
we'll just put another pair of
parentheses around this save and

22554
23:07:00.831 --> 23:07:04.831
auto formatted. And this here is
going to give us this second

22555
23:07:04.831 --> 23:07:08.831
line, right, it's going to give
us all of this bit, but it's not

22556
23:07:08.831 --> 23:07:11.831
going to give us this first bit,
right. So we just need to append

22557
23:07:11.831 --> 23:07:14.831
to this first bit now. And we
should be good to go. For basics

22558
23:07:14.831 --> 23:07:19.831
before data image SVG plus XML
basics, the form, this is the

22559
23:07:19.831 --> 23:07:24.831
prefix for images for SVG
images, right? We use that above

22560
23:07:24.831 --> 23:07:27.831
because that's the prefix for
SVG images. The prefix for base

22561
23:07:27.831 --> 23:07:32.831
64. Jason is going to be it's
going to be data application

22562
23:07:32.831 --> 23:07:36.831
JSON base 64. So we're going to
do it like this instead. Now the

22563
23:07:36.831 --> 23:07:40.831
ERC 721 has something called a
base URI that we're going to

22564
23:07:40.831 --> 23:07:43.831
override and that we're going to
use. So we're gonna say function

22565
23:07:43.831 --> 23:07:48.831
underscore base URI. This will
be internal pure. And we're

22566
23:07:48.831 --> 23:07:51.831
going to override the one that
ERC 721 has. And this is going

22567
23:07:51.831 --> 23:07:57.831
to returns a string memory. And
we're just going to return this

22568
23:07:57.831 --> 23:08:02.831
bit right here. And now we can
use this base URI. to append,

22569
23:08:02.831 --> 23:08:06.832
right, we're going to append
this first part to our base 64

22570
23:08:06.832 --> 23:08:11.832
encoded JSON. So in order to
append them, once again, we'll

22571
23:08:11.832 --> 23:08:19.832
do ABI dot ENCODE, packed. And
then we'll put this down here.

22572
23:08:19.832 --> 23:08:22.832
And we'll say, we're going to,
we're going to concatenate base

22573
23:08:22.832 --> 23:08:25.832
URI to this massive thing that
we just created. And then we

22574
23:08:25.832 --> 23:08:28.832
save and we ought to format the
now this is obviously a bytes

22575
23:08:28.832 --> 23:08:32.832
object, and we want it to be a
string. So then all we got to do

22576
23:08:32.832 --> 23:08:36.832
is typecast it as a string, but
another prints see down here,

22577
23:08:36.832 --> 23:08:39.832
and then we can actually just
return this, but basically what

22578
23:08:39.832 --> 23:08:44.832
we're doing is we're creating a
JSON string, we encode it in

22579
23:08:44.832 --> 23:08:49.832
bytes, that way we can encode it
in base 64. Once we have encoded

22580
23:08:49.832 --> 23:08:53.832
in base 64, which is going to
look like this second string,

22581
23:08:53.832 --> 23:08:57.832
it's gonna look like here out,
we then just append this initial

22582
23:08:57.832 --> 23:09:03.832
part. But for JSON objects, it's
data application JSON. We we

22583
23:09:03.832 --> 23:09:06.832
append that we do API dot encode
packed, and then cast it to

22584
23:09:06.832 --> 23:09:10.832
string and then boom, we now
have a token URI. That'll look

22585
23:09:10.832 --> 23:09:12.832
something like this. And then
all we have to do is update our

22586
23:09:12.832 --> 23:09:16.832
image URI with what we get from
our function appear, and then

22587
23:09:16.832 --> 23:09:25.832
we'll be good to go. So let's
finish this out. Let's do this.

22588
23:09:25.832 --> 23:09:29.832
So in our constructor, we're
passing a low SVG and a high

22589
23:09:29.832 --> 23:09:32.832
SVG. And what are these low SVG
is in these high SVG as well,

22590
23:09:32.832 --> 23:09:38.832
basically saying, when the price
of this asset is too low, show a

22591
23:09:38.832 --> 23:09:42.832
frown. And when the price of the
asset is high, show a smiley

22592
23:09:42.832 --> 23:09:46.833
face. So we're gonna give it
this frown, SVG, and this happy

22593
23:09:46.833 --> 23:09:50.833
SVG as input parameters, low CG
and high SVG, we probably want

22594
23:09:50.833 --> 23:09:53.833
to save those. But we don't
necessarily want to save them in

22595
23:09:53.833 --> 23:09:57.833
like their SVG format. So we
just want to store the image

22596
23:09:57.833 --> 23:10:00.833
URI, right, we will just want to
store this string up here

22597
23:10:00.833 --> 23:10:04.833
instead of the actual SVG. So
right in our constructor, we can

22598
23:10:04.833 --> 23:10:12.833
do I underscore low image URI
equals, and we have this SVG to

22599
23:10:12.833 --> 23:10:17.833
image your eye function, where
we can pass the low SVG. And

22600
23:10:17.833 --> 23:10:22.833
then we can do the same thing
for the high image URI. So now,

22601
23:10:22.833 --> 23:10:26.833
SVG image URI is going to return
something that looks like this.

22602
23:10:26.833 --> 23:10:30.833
And we're going to store just
this string this image URI on

22603
23:10:30.833 --> 23:10:34.833
chain. Now that we have the two
of those, we can use that down

22604
23:10:34.833 --> 23:10:37.833
below. In our token, Uri
function, when somebody calls

22605
23:10:37.833 --> 23:10:41.833
token, your I have token ID
zero, we're going to stick into

22606
23:10:41.833 --> 23:10:46.833
our JSON, either the low image
or I or the high image arrive.

22607
23:10:46.833 --> 23:10:48.833
And we're actually going to base
that off of the channeling price

22608
23:10:48.833 --> 23:10:51.833
feed. So how do we do that?
Well,

22609
23:10:51.833 --> 23:10:53.833
we've already worked with
channeling price feeds before so

22610
23:10:53.833 --> 23:10:56.833
let's go ahead and add it. So
yarn add dash dash dev at chain

22611
23:10:56.833 --> 23:11:00.833
link slash contracts. Once
that's done at the top, we can

22612
23:11:00.833 --> 23:11:07.833
do import at chain link slash
contracts, slash SRC slash V

22613
23:11:07.833 --> 23:11:14.833
0.8, slash interfaces, slash ag
reg gate, Tor V three interface,

22614
23:11:14.833 --> 23:11:20.833
that soul like so. And then down
here, let's comment this out.

22615
23:11:20.833 --> 23:11:23.833
For now, we're going to want to
call a price feed to figure out

22616
23:11:23.833 --> 23:11:26.834
what the price is and then show
the high image or the low image

22617
23:11:26.834 --> 23:11:28.834
based off that. So in order to
get a price feed in our

22618
23:11:28.834 --> 23:11:31.834
constructor, let's just add
another price feed address,

22619
23:11:31.834 --> 23:11:36.834
street address. And then we'll
make another variable. We'll do

22620
23:11:36.834 --> 23:11:44.834
aggregate Tor v3 interface.
Internal, immutable, I

22621
23:11:44.834 --> 23:11:48.834
underscore price feed. And we'll
say in our constructor, I price

22622
23:11:48.834 --> 23:11:56.834
feed equals aggregate Tor v3
interface at price feed,

22623
23:11:56.834 --> 23:12:00.834
address. And then what we can do
down here, the old bunch of

22624
23:12:00.834 --> 23:12:05.834
commas in here into 256 Price
comma, comma comma equals i

22625
23:12:05.834 --> 23:12:12.834
price feed that latest round
data. And what we can do is we

22626
23:12:12.834 --> 23:12:19.834
can say if price is greater than
or equal to some value, then

22627
23:12:19.834 --> 23:12:22.834
show one image dry otherwise,
show another one. So we can say

22628
23:12:22.834 --> 23:12:30.834
String memory, image URI equals
s underscore low image URI. And

22629
23:12:30.834 --> 23:12:32.834
then if the price is higher than
some value, well greater than

22630
23:12:32.834 --> 23:12:35.834
the image URI we're going to use
is going to be there's gonna be

22631
23:12:35.834 --> 23:12:40.834
AI is going to equal the high
image URI. And then we have

22632
23:12:40.834 --> 23:12:43.834
image right down here. So all we
got to do is figure out the

22633
23:12:43.834 --> 23:12:47.834
price. So we can make, and in
our mind, we'll let the mentors

22634
23:12:47.834 --> 23:12:54.834
choose the value that they want
to use. So we can say, into 256,

22635
23:12:54.834 --> 23:12:58.834
I value and we'll assign each
NFT, their own high value. So

22636
23:12:58.834 --> 23:13:02.834
we'll need to create like a
little mapping up top, we'll

22637
23:13:02.834 --> 23:13:09.835
say, mapping, you went to 56.
Two, you went to 56. Let's just

22638
23:13:09.835 --> 23:13:15.835
make this public for the heck of
it public s underscore token ID

22639
23:13:15.835 --> 23:13:22.835
to high value. And we'll say
that when they meant an NF T

22640
23:13:22.835 --> 23:13:26.835
will do s token ID to high
value, s underscore token

22641
23:13:26.835 --> 23:13:31.835
counter. We'll set that equal to
high value. So when they meant

22642
23:13:31.835 --> 23:13:34.835
they choose the high value that
they want. And then down here

22643
23:13:34.835 --> 23:13:38.835
we'll say if the price is
greater than or equal to the

22644
23:13:38.835 --> 23:13:42.835
high value of the token ID, then
we'll use the high one.

22645
23:13:42.835 --> 23:13:44.835
Otherwise, we'll just use the
low one. Oops, and this needs to

22646
23:13:44.835 --> 23:13:49.835
be you into videos x two into
256. Excuse me, since we want to

22647
23:13:49.835 --> 23:13:53.835
be able to compare them pretty
equally. And boom, our contract

22648
23:13:53.835 --> 23:13:56.835
looks really good. Now the only
thing we'd want to add in here

22649
23:13:56.835 --> 23:13:59.835
is probably an event. So we
probably want to emit an event

22650
23:13:59.835 --> 23:14:05.835
in time we met to one of these
NF T's. So we might do event

22651
23:14:05.835 --> 23:14:11.835
created NF T, will say you went
to 56 indexed token ID comma int

22652
23:14:11.835 --> 23:14:19.835
256. I value like so. And then
when we met this NFT, will do

22653
23:14:19.835 --> 23:14:25.835
emit create n t, s underscore
token counter, comma, I value.

22654
23:14:25.835 --> 23:14:29.835
And then it's best practice to
to have to update our token

22655
23:14:29.835 --> 23:14:31.835
counter before we actually do
the minting. So we'll do that as

22656
23:14:31.835 --> 23:14:35.835
well. Okay, there's a ton of
code here. And like I said, we

22657
23:14:35.835 --> 23:14:38.835
definitely would not have
written all that code without

22658
23:14:38.835 --> 23:14:41.835
having compiled to run some
tests first, but we decided we

22659
23:14:41.835 --> 23:14:45.836
want to just write it all right
off first. So and I did some

22660
23:14:45.836 --> 23:14:48.836
misspellings. Let's just make
sure everything compiles here.

22661
23:14:48.836 --> 23:14:50.836
Awesome. Everything's compiled
here. As you already know, a

22662
23:14:50.836 --> 23:14:53.836
couple things that we're going
to need to do to test this out.

22663
23:14:53.836 --> 23:14:56.836
First thing we're gonna need to
do is write our deploy function,

22664
23:14:56.836 --> 23:15:01.836
we've got our basic NFT, we've
got our random and f t, both of

22665
23:15:01.836 --> 23:15:06.836
these hosted on IPFS. Now we're
going to do a dynamic NFT that's

22666
23:15:06.836 --> 23:15:11.836
hosted 100 percent on chain, and it
changes based off the price of

22667
23:15:11.836 --> 23:15:25.836
an asset. So let's do this. Oh,
three, deploy dynamic, SVG

22668
23:15:25.836 --> 23:15:28.836
nft.js. We are no, we're gonna
need a little bit of

22669
23:15:28.836 --> 23:15:32.836
boilerplate. So let's go to our
basic NFT. And we'll just grab

22670
23:15:32.836 --> 23:15:36.836
all this the first seven lines
or so. And we'll just paste it

22671
23:15:36.836 --> 23:15:39.836
in here. What do we need for our
constructor? Well, we

22672
23:15:39.836 --> 23:15:44.836
need a price feed address, a low
SVG and a highest CG. Okay, so

22673
23:15:44.836 --> 23:15:47.836
let's get all of those. So price
feed address is something we've

22674
23:15:47.836 --> 23:15:50.836
already done before. And we can
add that into our helper

22675
23:15:50.836 --> 23:15:54.836
Hardhead config. And we'll do
one and a foreign local, we're

22676
23:15:54.836 --> 23:15:57.836
going to use what we're going to
use a mock. And if we're on

22677
23:15:57.836 --> 23:15:59.836
Rinkeby, or an actual network,
we're going to use an actual

22678
23:15:59.836 --> 23:16:03.836
address. So let's go ahead to
dark side chain that link will

22679
23:16:03.836 --> 23:16:08.836
grab a price feed address, the M
Aetherium. data feeds will go to

22680
23:16:08.836 --> 23:16:14.836
rank B, rank B and let's just
use eath USD copy that will make

22681
23:16:14.836 --> 23:16:21.836
a new entry eath USD price feed
like so. And for localhost,

22682
23:16:21.836 --> 23:16:23.836
we're good. So since we know for
localhost, we're going to need

22683
23:16:23.836 --> 23:16:27.837
to do a mock. Let's see if we
have a price feed mock. Okay,

22684
23:16:27.837 --> 23:16:31.837
now we don't, we're gonna need a
mock v3 aggregator dot soul. I

22685
23:16:31.837 --> 23:16:34.837
just copied pasted mine. If you
want, you can just go right to

22686
23:16:34.837 --> 23:16:38.837
the to a repo here. Or you can
copy from a previous section,

22687
23:16:38.837 --> 23:16:43.837
just a reminder heart at f and f
t FCC contracts asked moc v3

22688
23:16:43.837 --> 23:16:48.837
aggregator and this is using
point 06 of solidity. So we're

22689
23:16:48.837 --> 23:16:51.837
going to want to make sure that
in our hard hat dot config, we

22690
23:16:51.837 --> 23:16:55.837
have at least one 0.6 version,
which we do so we're good there.

22691
23:16:55.837 --> 23:17:18.837
That means in our deploy mocks,
we're going to want to add So

22692
23:17:18.837 --> 23:17:21.837
initial price will be 2000
decimals will be a team. So now

22693
23:17:21.837 --> 23:17:24.837
we've waited to deploy mocks for
that price feed. So we're gonna

22694
23:17:24.837 --> 23:17:30.837
say const chain ID equals
network dot config dot chain Id

22695
23:17:30.837 --> 23:17:36.837
do if development chains dot
includes network dot name, and

22696
23:17:36.837 --> 23:17:38.837
the more we need to import
development chains looks like

22697
23:17:38.837 --> 23:17:45.837
where did say const eth USD
akregator equals we'll get that

22698
23:17:45.837 --> 23:17:52.837
price feed equals awaits ethers
dot get contract Mark v3 Air

22699
23:17:52.837 --> 23:17:57.837
gate tour, and then we'll up
here we'll do let eath USD price

22700
23:17:57.837 --> 23:18:03.837
feed address eath USD price feed
address equals eath USD

22701
23:18:03.837 --> 23:18:08.838
aggregate tore that address else
will say the eath USD price feed

22702
23:18:08.838 --> 23:18:11.838
address is going to be equal to
what we find in the network

22703
23:18:11.838 --> 23:18:19.838
config. Network config. Chain ID
dot eth USD price. Okay, so we

22704
23:18:19.838 --> 23:18:24.838
have the eth USD price feed
rate. Now we need the lowest VG

22705
23:18:24.838 --> 23:18:28.838
and the high SVG. So we're going
to create a new folder in our

22706
23:18:28.838 --> 23:18:35.838
images folder. So we go CD
images, MK dir dynamic NF t. And

22707
23:18:35.838 --> 23:18:38.838
now we'll have two folders in
here dynamic which is empty and

22708
23:18:38.838 --> 23:18:41.838
random, which has all the random
stuff. If you want to use your

22709
23:18:41.838 --> 23:18:44.838
own SVGs for this, you
absolutely can. But if you want

22710
23:18:44.838 --> 23:18:48.838
to just come to my images file
and then save these images as so

22711
23:18:48.838 --> 23:18:52.838
just come right click Save image
as. Save them. and then drag and

22712
23:18:52.838 --> 23:18:54.838
drop them into your images files
here, you can absolutely do

22713
23:18:54.838 --> 23:19:00.838
that. So now that we have those,
we want to go ahead and read

22714
23:19:00.838 --> 23:19:05.838
those into our script here.
We'll say const, low SVG equals

22715
23:19:05.838 --> 23:19:10.838
a weight. And we're going to use
Fs again. So we're gonna do

22716
23:19:10.838 --> 23:19:18.838
const Fs equals require Fs, or
do await Fs dot read file sync,

22717
23:19:18.838 --> 23:19:22.838
we're going to read in this
file, which for me, it's at dot

22718
23:19:22.838 --> 23:19:29.838
slash images slash dynamic NF T
slash brown dot SVG. And we're

22719
23:19:29.838 --> 23:19:35.838
using encoding of UTF eight. And
then we'll say const. Hi, SVG

22720
23:19:35.838 --> 23:19:41.838
equals await Fs dot read file
sync. Copy this whole thing,

22721
23:19:41.838 --> 23:19:44.839
because we're using the same
stuff. This one's going to be

22722
23:19:44.839 --> 23:19:49.839
happy about SVG. And that's it.
So when price is good, we're

22723
23:19:49.839 --> 23:19:52.839
gonna do happiness, SVG, when
price is bad, we're gonna do

22724
23:19:52.839 --> 23:19:54.839
frown at SVG. Now, let's go
ahead and let's deploy this

22725
23:19:54.839 --> 23:19:59.839
contract. So we'll say arguments
or args equals, it's gonna be

22726
23:19:59.839 --> 23:20:05.839
the price feed address, low SVG,
and then high SVG. And we'll say

22727
23:20:05.839 --> 23:20:14.839
const, dynamic S, G and F T
equals await, deploy dynamic SVG

22728
23:20:14.839 --> 23:20:21.839
and f t, comma little bracket
here, from Deployer.

22729
23:20:21.839 --> 23:20:29.839
args, args log true. And the
weights confirmations, it's

22730
23:20:29.839 --> 23:20:38.839
going to be network dot config,
that block confirmations, or one

22731
23:20:38.839 --> 23:20:45.839
will do some logging, I will do
log to do that. But Larry, do

22732
23:20:45.839 --> 23:20:48.839
some verification, I'm actually
just going to copy paste that

22733
23:20:48.839 --> 23:20:50.839
from our last script, because
it's going to be exactly the

22734
23:20:50.839 --> 23:20:55.839
same copy paste. But instead of
random IPFS, it's going to be

22735
23:20:55.839 --> 23:20:59.839
dynamic SVG and f t. The rest of
this looks good. And that's just

22736
23:20:59.839 --> 23:21:05.839
about it. So we'll do module,
exports dot tags, equals and

22737
23:21:06.839 --> 23:21:14.839
we'll do all dynamic. SVG. And
we'll do main. Oh, okay. Let's

22738
23:21:14.839 --> 23:21:19.839
try to see if our deploy script
that we just created works. To

22739
23:21:19.839 --> 23:21:26.840
do h h, or yarn hardhat deployed
dash dash tags, die Namic SVG,

22740
23:21:26.840 --> 23:21:28.840
that makes sense, because we
didn't deploy the mocks. So

22741
23:21:28.840 --> 23:21:33.840
we'll do tags, dynamic SVGs. And
then also the mocks. Local

22742
23:21:33.840 --> 23:21:36.840
network detected play marks, we
deploy the marks, deploying

22743
23:21:36.840 --> 23:21:45.840
dynamic SVG, awesome. You know
what comes next? You Gosh, darn

22744
23:21:45.840 --> 23:21:50.840
right, it's time for some tests.
Now, once again, I'm going to

22745
23:21:50.840 --> 23:21:53.840
encourage you to pause the video
now and try to write your own

22746
23:21:53.840 --> 23:21:57.840
test for this test for this
section actually can be a little

22747
23:21:57.840 --> 23:22:00.840
bit tricky. Since we are going
to be manipulating the price of

22748
23:22:00.840 --> 23:22:04.840
our mock aggregator, we are
checking for these long strings,

22749
23:22:04.840 --> 23:22:08.840
and such. So be sure to use the
GitHub repository associated

22750
23:22:08.840 --> 23:22:11.840
with this lesson, in case you
get lost. Now, I want to show

22751
23:22:11.840 --> 23:22:18.840
you what this looks like on a
marketplace, like OpenCL. So we

22752
23:22:18.840 --> 23:22:22.840
are going to deploy this to rink
B. Now keep in mind test that

22753
23:22:22.840 --> 23:22:24.840
can be slow. So you might want
to be patient here. And you

22754
23:22:24.840 --> 23:22:27.840
don't even have to do it if you
don't want to. But it is kind of

22755
23:22:27.840 --> 23:22:30.840
nice to see. Okay, that's what
it really looks like. And you

22756
23:22:30.840 --> 23:22:33.840
can go to the contract on chain
once it's verified. And you can

22757
23:22:33.840 --> 23:22:35.840
read the token URI and
everything. And it's pretty fun.

22758
23:22:35.840 --> 23:22:40.840
So let's just add one more bit
to our deploy folder. Let's add

22759
23:22:40.840 --> 23:22:43.840
a mint script that just emits an
NF T for each one of these

22760
23:22:43.840 --> 23:22:47.840
contracts. So we're going to
create no for mint.js. And we're

22761
23:22:47.840 --> 23:22:52.840
just going to have each one of
these contracts mint NFT. Let's

22762
23:22:52.840 --> 23:22:57.840
go ahead and do this. So in
here, we'll do const ethers

22763
23:22:57.840 --> 23:23:03.840
network equals require arhat.
And then I'm going to do a

22764
23:23:03.840 --> 23:23:06.841
little copy paste in. I'm just
going to copy this part because

22765
23:23:06.841 --> 23:23:10.841
I know I'm going to need that.
We are going to need a deploy

22766
23:23:10.841 --> 23:23:13.841
but we're not going to need to
deploy. So I'll grab get named

22767
23:23:13.841 --> 23:23:16.841
accounts, get named accounts,
it's going to come right from

22768
23:23:16.841 --> 23:23:19.841
there. So we have a Deployer.
Our deployer is just gonna be

22769
23:23:19.841 --> 23:23:22.841
used to mint them. First we'll
mint the basic NF t. So we'll

22770
23:23:22.841 --> 23:23:29.841
say const basic NF t equals wait
ethers dot get contract, basic N

22771
23:23:29.841 --> 23:23:32.841
ft, and we'll connect the
deployer to it. And then we'll

22772
23:23:32.841 --> 23:23:38.841
say const basic mint and if T or
basic mint, TX equals await

22773
23:23:38.841 --> 23:23:45.841
basic NF T dot mint NF t. And
then we'll do a weight basic

22774
23:23:45.841 --> 23:23:50.841
mint, TX dot weight one and then
we'll do a little console dot

22775
23:23:50.841 --> 23:23:57.841
log base Again, T index zero has
token URI, we'll put in a little

22776
23:23:57.841 --> 23:24:02.841
await basic NF T dot token URI
of zero. That's it for the basic

22777
23:24:02.841 --> 23:24:09.841
entity. Now we'll do our random
IPFS and empty. So we'll say

22778
23:24:09.841 --> 23:24:16.841
const, random IPFS NF t equals
await ethers dot get contract,

22779
23:24:16.841 --> 23:24:22.841
random IPFS and f t, connected
to the Deployer. This one, we

22780
23:24:22.841 --> 23:24:26.841
need a mint fee. So we'll say
const, mint V equals await

22781
23:24:26.841 --> 23:24:31.841
random IPFS NF T dot get mint
fee. And then we'll do the mint.

22782
23:24:31.841 --> 23:24:38.841
So we'll say const, random IPFS
and ft mint, TX equals await,

22783
23:24:38.841 --> 23:24:44.842
random IPFS and F T dot request
and F team. And for this one, we

22784
23:24:44.842 --> 23:24:47.842
need to pass a value, which is
going to be the mint v.to

22785
23:24:47.842 --> 23:24:53.842
string. Now for this one, just
like what we saw in our tests,

22786
23:24:53.842 --> 23:24:57.842
we're going to have to do this
await new promise again, right,

22787
23:24:57.842 --> 23:25:01.842
because we need to wait for it
to return need to listen for

22788
23:25:01.842 --> 23:25:04.842
those events, we probably should
set up the listener first. So

22789
23:25:04.842 --> 23:25:06.842
let's actually set up the
listener first. So we're going

22790
23:25:06.842 --> 23:25:11.842
to do await new promise, and
we're gonna do async function.

22791
23:25:11.842 --> 23:25:16.842
And we're going to do resolve
reject. In here, we're gonna use

22792
23:25:16.842 --> 23:25:19.842
that, that fun little arrow
syntax in here.

22793
23:25:19.842 --> 23:25:21.842
And now since we're in this
function here, we actually set

22794
23:25:21.842 --> 23:25:27.842
the timeout resolve like this,
which means we have five minutes

22795
23:25:27.842 --> 23:25:30.842
to time this out, you might want
to bump this up even more five

22796
23:25:30.842 --> 23:25:33.842
minutes might not be enough,
this is gonna be 300

22797
23:25:33.842 --> 23:25:36.842
milliseconds here, we're gonna
do that once again. So we'll say

22798
23:25:36.842 --> 23:25:41.842
random IPFS and ft dot once.
Once we get that NFT minted

22799
23:25:41.842 --> 23:25:45.842
event, we're going to run an
async function, we're just gonna

22800
23:25:45.842 --> 23:25:50.842
do resolve. And inside here is
where we can actually put,

22801
23:25:50.842 --> 23:25:56.842
actually requesting the NFT. But
below our listener, right, so in

22802
23:25:56.842 --> 23:26:02.842
there, and then we can say if
developments chains, that

22803
23:26:02.842 --> 23:26:07.842
includes network dot name. So
let's just make sure we import

22804
23:26:07.842 --> 23:26:11.842
those development chains and
network or affect them and

22805
23:26:11.842 --> 23:26:14.842
chains that includes network dot
name. So we're on a test net,

22806
23:26:14.842 --> 23:26:17.842
this is where we go ahead and we
pretend to be those mocks. So

22807
23:26:17.842 --> 23:26:21.842
we'll say const Request ID
equals random IPFS. Oh,

22808
23:26:21.842 --> 23:26:27.843
actually, we're going to need to
do const random IPFS and ft min

22809
23:26:27.843 --> 23:26:32.843
TX receipt equals await on IPFS
and empty minted TX dot weight

22810
23:26:32.843 --> 23:26:36.843
one. So we're gonna need to get
the receipt. And from the

22811
23:26:36.843 --> 23:26:41.843
receipt, we can get the request
ID. That events one dot args dot

22812
23:26:41.843 --> 23:26:49.843
request id.to string. And then
we can do const VRF. coordinator

22813
23:26:49.843 --> 23:26:56.843
V to mock equals await ethers
dot get contract, the RF

22814
23:26:56.843 --> 23:27:00.843
coordinate for V to mock,
connect this to the Deployer.

22815
23:27:00.843 --> 23:27:06.843
And then we'll do a wait the RF
corded and a Tor V to mock that

22816
23:27:06.843 --> 23:27:12.843
fulfill random words with
Request ID, random IPFS. And if

22817
23:27:12.843 --> 23:27:20.843
T dot address, we can do console
dot log random IPFS and have T

22818
23:27:20.843 --> 23:27:29.843
index zero token URI to await
random IP. That's NF T dot token

22819
23:27:29.843 --> 23:27:37.843
URI of zero. Finally, we can do
our dynamic SVG, NF t. So we can

22820
23:27:37.843 --> 23:27:43.843
say const, high high value
equals ethers.utils.do parse

22821
23:27:43.843 --> 23:27:48.843
ether here. So we'll say
4000 $4,000 will be the high

22822
23:27:48.843 --> 23:27:55.843
value. We'll say const. Dynamic
SVG and f t equals await ethers

22823
23:27:55.843 --> 23:28:00.843
dot get contract, dynamic. SVG
and a T will connect it to the

22824
23:28:00.843 --> 23:28:09.844
deployer say const by Namic, s,
B, G, and f t mint, TX equals

22825
23:28:09.844 --> 23:28:17.844
await dynamic SVG and F T dot
mint and f t i value to string

22826
23:28:17.844 --> 23:28:24.844
then we'll just do wait. This
stat wait one. And finally

22827
23:28:24.844 --> 23:28:32.844
console dot log dynamic. SVG NFT
index zero token URI is going to

22828
23:28:33.844 --> 23:28:42.844
be a weight dynamic. SVG and ft
dot token URI of zero. Okay, I

22829
23:28:42.844 --> 23:28:44.844
think that looks good. Let's try
this on a local network. So

22830
23:28:44.844 --> 23:28:51.844
we'll do yarn hard hat deploy.
And we'll run all those scripts

22831
23:28:51.844 --> 23:28:55.844
It looks like everything worked.
So we have random, basic NFT

22832
23:28:55.844 --> 23:29:00.844
index zero has a token year, I
have this IPFS thing, random

22833
23:29:00.844 --> 23:29:04.844
IPFS NFT. index zero has this
thing. And then our SVG has this

22834
23:29:04.844 --> 23:29:07.844
giant monstrosity, okay,
perfect. And then we can even

22835
23:29:07.844 --> 23:29:12.844
check, right, we can even grab
this IPFS hash, we go to our

22836
23:29:12.844 --> 23:29:16.844
IPFS node, or if you installed
IPFS in your browser, or you're

22837
23:29:16.844 --> 23:29:18.844
working with Brave, we can just
pop it right into our browsers

22838
23:29:18.844 --> 23:29:21.844
and see what it looks like.
Right. And then if I zoom in,

22839
23:29:21.844 --> 23:29:25.844
and adorable St. Bernard, with
the image of the St. Bernard,

22840
23:29:25.844 --> 23:29:27.844
looking like that, this one's
also gonna be St. Bernard. And

22841
23:29:27.844 --> 23:29:31.844
then of course, are SVG, which
we can also copy, paste, and

22842
23:29:31.844 --> 23:29:35.844
boom, that looks great. And then
we can copy the image. And it's

22843
23:29:35.844 --> 23:29:39.844
a frowny face or shad. But
Awesome. Okay, so it's working

22844
23:29:39.844 --> 23:29:43.844
locally for us. Now, let's go
ahead and try to make this work

22845
23:29:43.844 --> 23:29:47.845
on an actual test net. So
hopefully, our helper hard hat

22846
23:29:47.845 --> 23:29:50.845
config is set up correctly. And
there's enough stuff in here

22847
23:29:50.845 --> 23:29:54.845
where we need to make sure that
we have a subscription ID,

22848
23:29:54.845 --> 23:29:56.845
right, we're going to need to
make sure we have a subscription

22849
23:29:56.845 --> 23:30:00.845
ID. And we shouldn't call the
mint function, right, because

22850
23:30:00.845 --> 23:30:03.845
we're going to need to add our
consumer to the VRF. Before we

22851
23:30:03.845 --> 23:30:07.845
can actually meant so let me
let's add some tags to our meant

22852
23:30:07.845 --> 23:30:11.845
here. So we'll do module dot
exports, dot tags equals, and

22853
23:30:11.845 --> 23:30:17.845
we'll say all comma meant a
while ago, I said okay, let's

22854
23:30:17.845 --> 23:30:22.845
add a main tag. Now we're coming
around to why we added this main

22855
23:30:22.845 --> 23:30:25.845
tag here. So what we want to do
is want to deploy all of these

22856
23:30:25.845 --> 23:30:31.845
contracts. But before we finally
meant for our IPFS one, we need

22857
23:30:31.845 --> 23:30:34.845
to add that contract to our
consumer, here's what we're

22858
23:30:34.845 --> 23:30:38.845
gonna do, we're gonna run yarn,
Hardhead, deploy dash dash

22859
23:30:38.845 --> 23:30:45.845
network Rinkeby dash dash tags
main. Now, this won't meant any

22860
23:30:45.845 --> 23:30:48.845
of our NF T's, okay, won't mean
to any of our NF T's, it'll just

22861
23:30:48.845 --> 23:30:51.845
deploy those contracts might
just sit around and wait a

22862
23:30:51.845 --> 23:30:54.845
little bit for these to actually
deploy. So this is a great time

22863
23:30:54.845 --> 23:30:56.845
to go take a break, maybe go
take a walk, get a sip of water,

22864
23:30:56.845 --> 23:30:59.845
get a cup of coffee, whatever
you want to do. Yeah, once

22865
23:30:59.845 --> 23:31:02.845
everything is deployed, then we
can go to V or F dot chain dot

22866
23:31:02.845 --> 23:31:06.845
link, we're already connected
here, we used our subscription.

22867
23:31:06.845 --> 23:31:11.845
And then we would just add our
IPFS consumer in here. And we'd

22868
23:31:11.845 --> 23:31:13.845
be good to go. And All right,
once everything goes through,

22869
23:31:13.845 --> 23:31:17.845
and we have all three of our
transactions on the blockchain,

22870
23:31:17.845 --> 23:31:21.845
we can go ahead, we can grab our
random IPFS NF T, we'll grab

22871
23:31:21.845 --> 23:31:24.846
that address, we'll come back
over to V or F dot chain dot

22872
23:31:24.846 --> 23:31:30.846
link slash rink D, we'll go to
our subscription ID, and we'll

22873
23:31:30.846 --> 23:31:35.846
add a new consumer will add that
contract address. So we'll go

22874
23:31:35.846 --> 23:31:38.846
ahead and approve and Metamask.
And once this goes through, we

22875
23:31:38.846 --> 23:31:42.846
can finish running the mint part
of our deploy folder. Once it's

22876
23:31:42.846 --> 23:31:46.846
confirmed, we can close maybe we
can do a little refresh, we

22877
23:31:46.846 --> 23:31:49.846
should see our new address added
as a subscription here. Now that

22878
23:31:49.846 --> 23:31:52.846
we've added that we can mint one
NF T from each one of these

22879
23:31:52.846 --> 23:31:58.846
contracts are in hard hats,
deploy dash dash tags meant dash

22880
23:31:58.846 --> 23:32:02.846
dash network Rinkeby. And we'll
have to wait a little bit for

22881
23:32:02.846 --> 23:32:06.846
this too. Okay, now that we have
them all minted, we should get a

22882
23:32:06.846 --> 23:32:10.846
little output like this. Right?
Basic NF t zero has token URI

22883
23:32:10.846 --> 23:32:15.846
here. Basic random IPFS NF T has
token your eye here. And then

22884
23:32:15.846 --> 23:32:19.846
our SVG has this as a token
year, right. So what can we do

22885
23:32:19.846 --> 23:32:24.846
now? Well, let me go grab, I'll
grab my wallet address and stick

22886
23:32:24.846 --> 23:32:28.846
it into Rinkeby ether scan. And
we can see we called mint

22887
23:32:28.846 --> 23:32:33.846
request and mint again. And we
created three contracts, right,

22888
23:32:33.846 --> 23:32:37.846
we created our basic NFT, our
random IPFS NFT and our dynamic

22889
23:32:37.846 --> 23:32:42.846
SVG NFT. What we can do now is
we can grab, we can copy the

22890
23:32:42.846 --> 23:32:46.846
address of our contract. And we
can go to test nets that open

22891
23:32:46.846 --> 23:32:49.846
see that i Oh,

22892
23:32:49.846 --> 23:32:53.846
and we can put that address in
the bar here in the search bar

22893
23:32:53.846 --> 23:32:57.846
here. Now this part is
incredibly, incredibly variable.

22894
23:32:57.846 --> 23:33:01.846
Okay, open C can be really slow.
And it can take open see up to a

22895
23:33:01.846 --> 23:33:05.847
couple of hours to register that
a contract has been deployed to

22896
23:33:05.847 --> 23:33:08.847
a test net. So if it doesn't
show up right away, don't be

22897
23:33:08.847 --> 23:33:11.847
discouraged. Don't let it drag
you down. But if it does, you

22898
23:33:11.847 --> 23:33:15.847
should be able to click on your
collection and see the NFT is

22899
23:33:15.847 --> 23:33:19.847
actually here. I'm going to grab
our random IPFS NFT. Let's grab

22900
23:33:19.847 --> 23:33:23.847
that contract address. I'm going
to grab that test net site open

22901
23:33:23.847 --> 23:33:27.847
c.io. Paste that address in
there. And what do you know we

22902
23:33:27.847 --> 23:33:32.847
do indeed see, random IPFS and f
t, right and I've deployed a

22903
23:33:32.847 --> 23:33:35.847
couple of them. So this one's v
two, and we have our adorable

22904
23:33:35.847 --> 23:33:38.847
Shiva in you right here. So this
is what it looks like an open C

22905
23:33:38.847 --> 23:33:43.847
now we can 100 percent verify that our
code is good even if it doesn't

22906
23:33:43.847 --> 23:33:46.847
show up on Open. See. If we go
to the contract we go to read

22907
23:33:46.847 --> 23:33:51.847
contract. And then we go to
token URI punch and zero here. A

22908
23:33:51.847 --> 23:33:56.847
query, grabbed this, stick it
into our browsers, the JSON

22909
23:33:56.847 --> 23:34:00.847
looks good. So let's grab the
image URI. Paste that in. And if

22910
23:34:00.847 --> 23:34:04.847
we can see this here, that means
that our code is good. And you

22911
23:34:04.847 --> 23:34:08.847
have successfully deployed a
number of FFTs to the

22912
23:34:08.847 --> 23:34:15.847
blockchain. We have learned a
massive amount in this course,

22913
23:34:15.847 --> 23:34:17.847
this is definitely one of the
most jam packed one. And it's

22914
23:34:17.847 --> 23:34:20.847
all about art. Right? Isn't that
crazy? Let's do a quick

22915
23:34:20.847 --> 23:34:25.847
refresher of this entire course
here. So first off, we learned

22916
23:34:25.847 --> 23:34:29.847
the basics of an NF T with our
basic NF T dot Sol, we learn

22917
23:34:29.847 --> 23:34:33.847
that these NF T's are based off
of the ERC 721 standard. And

22918
23:34:33.847 --> 23:34:37.847
that just means they have
functions like name, token, Uri,

22919
23:34:37.847 --> 23:34:43.847
etc. We learned that NF T's use
this token URI to tell us what

22920
23:34:43.847 --> 23:34:45.848
the token actually looks like a
token, your eye will look

22921
23:34:45.848 --> 23:34:49.848
something like this, it's going
to be a name a description, it's

22922
23:34:49.848 --> 23:34:52.848
going to have an image URL,
which points to a different

22923
23:34:52.848 --> 23:34:56.848
location for what the NFT
actually looks like. It'll have

22924
23:34:56.848 --> 23:34:59.848
stuff like attributes, it can
have stuff like attributes, and

22925
23:34:59.848 --> 23:35:03.848
a few other tags. This is known
as the metadata of the NFT. And

22926
23:35:03.848 --> 23:35:07.848
this tells us about the NFT. We
can also have all that metadata

22927
23:35:07.848 --> 23:35:10.848
on chain, of course, to
customize it on chain, and make

22928
23:35:10.848 --> 23:35:14.848
it look and grow and change and
be interactive on chain, we

22929
23:35:14.848 --> 23:35:17.848
learned more about IPFS, we
actually wrote a script called

22930
23:35:17.848 --> 23:35:21.848
upload to pinjarra.js, where we
can actually programmatically

22931
23:35:21.848 --> 23:35:26.848
upload images and files to
another IPFS pinning service for

22932
23:35:26.848 --> 23:35:31.848
us, we can of course, always use
our own IPFS nodes if we want.

22933
23:35:31.848 --> 23:35:35.848
Now this token URI can really be
anything. And we hosted it on

22934
23:35:35.848 --> 23:35:40.848
IPFS for our basic NFT and for
our random NFT. But for our

22935
23:35:40.848 --> 23:35:45.848
dynamic NFT, we actually hosted
the token, you're right 100 percent On

22936
23:35:45.848 --> 23:35:49.848
chain, so we didn't use IPFS.
And we made this dynamic where

22937
23:35:49.848 --> 23:35:54.848
the token URI actually changes
based off of the price of a

22938
23:35:54.848 --> 23:35:59.848
changeling price feed in our
random IPFS NFT, we gave our NFT

22939
23:35:59.848 --> 23:36:03.848
a chance we gave different
rarities to the different dogs

22940
23:36:03.848 --> 23:36:06.848
so that we could create
programmatically rare NF TS

22941
23:36:06.848 --> 23:36:10.848
where our pug is super rare. Our
Shiva is sort of rare, and our

22942
23:36:10.848 --> 23:36:13.848
St. Bernard is pretty common. So
the fact that we got to ship it

22943
23:36:13.848 --> 23:36:16.848
in you was awesome. We did some
amazing deployments, we wrote

22944
23:36:16.848 --> 23:36:19.848
some tests. Not only that, but
we learned a lot about

22945
23:36:19.848 --> 23:36:23.848
transactions, and how we can
actually add whatever data we

22946
23:36:23.848 --> 23:36:26.849
want to this data section. And a
little bit more about what our

22947
23:36:26.849 --> 23:36:29.849
transactions look like, and how
we can actually use functions,

22948
23:36:29.849 --> 23:36:33.849
selectors and function
signatures to be able to call

22949
23:36:33.849 --> 23:36:37.849
anything, right and we learn
more about ABI dot encoding, and

22950
23:36:37.849 --> 23:36:39.849
encoding packed and all this
binary stuff if you want it to

22951
23:36:39.849 --> 23:36:42.849
go deep into that. So this was
an absolutely JAM PACKED

22952
23:36:42.849 --> 23:36:45.849
session. And you should be
incredibly proud of yourself,

22953
23:36:45.849 --> 23:36:48.849
especially with your little
puppy that you can see on open

22954
23:36:48.849 --> 23:36:51.849
sea or you can see directly on
ether scan, or you can just look

22955
23:36:51.849 --> 23:36:55.849
at it and IPFS and be really
proud of what you've done. But

22956
23:36:55.849 --> 23:36:58.849
with that being said, huge
congratulations on making this

22957
23:36:58.849 --> 23:37:01.849
far. Definitely definitely
definitely take a break here,

22958
23:37:01.849 --> 23:37:12.849
and we'll see you in the next
one.

22959
23:37:12.849 --> 23:37:16.849
Okay, now we have less than
fifth team, which is going to be

22960
23:37:16.849 --> 23:37:21.849
our next JS NFT marketplace. And
if you finish this lesson, you

22961
23:37:21.849 --> 23:37:25.849
are a web three full stack
monster, this is going to be our

22962
23:37:25.849 --> 23:37:30.849
most complicated front end using
the web three stack and using a

22963
23:37:30.849 --> 23:37:33.849
lot of really advanced web
three, and blockchain tools. So

22964
23:37:33.849 --> 23:37:37.849
get really excited because we
are going to learn a ton in this

22965
23:37:37.849 --> 23:37:40.849
lesson. Now there are actually
three different repos associated

22966
23:37:40.849 --> 23:37:43.849
with this lesson. The first one
is going to be our typical hard

22967
23:37:43.849 --> 23:37:46.849
hat project. For the back end,
after the hard hat project, we

22968
23:37:46.849 --> 23:37:50.849
actually have two repos both are
going to be our front end repos,

22969
23:37:50.849 --> 23:37:53.849
and they're going to be slightly
different. In this project,

22970
23:37:53.849 --> 23:37:56.849
we're going to learn more about
how events are so important and

22971
23:37:56.849 --> 23:37:59.849
why events are so important,
especially for off chain

22972
23:37:59.849 --> 23:38:01.849
services. And so we're actually
going to look at two different

22973
23:38:01.849 --> 23:38:04.849
ways to work with them, one
using the mirallas, or a

22974
23:38:04.849 --> 23:38:07.850
centralized database, and then
one using the graph. And the

22975
23:38:07.850 --> 23:38:10.850
reason that I want to show both
of these is that oftentimes,

22976
23:38:10.850 --> 23:38:12.850
when people are looking to scale
the projects, when people are

22977
23:38:12.850 --> 23:38:16.850
looking to get things done
really quickly, taking a more

22978
23:38:16.850 --> 23:38:19.850
centralized approach can often
be a little quicker, and you can

22979
23:38:19.850 --> 23:38:22.850
sometimes add more functionality
to your website. And there's

22980
23:38:22.850 --> 23:38:24.850
still a lot of protocols that
have decentralized backends. And

22981
23:38:24.850 --> 23:38:29.850
centralized front ends. One such
example, is open sea, open sea,

22982
23:38:29.850 --> 23:38:33.850
for example, has the ability to
actually like different and fts.

22983
23:38:33.850 --> 23:38:36.850
Now, this isn't something that
we would actually want to spend

22984
23:38:36.850 --> 23:38:38.850
any gas on. But it is something
that we're gonna have to store

22985
23:38:38.850 --> 23:38:41.850
in some type of database
somewhere, so that people have

22986
23:38:41.850 --> 23:38:44.850
the ability to do that. So I
want to show you this optional

22987
23:38:44.850 --> 23:38:47.850
first way to build these front
ends, since all of our logic is

22988
23:38:47.850 --> 23:38:50.850
still going to be 100 percent. On
chain, the front end matters a

22989
23:38:50.850 --> 23:38:53.850
little bit less, because anybody
can still interact with the

22990
23:38:53.850 --> 23:38:56.850
contracts that we build on
chain. Now in web three, we

22991
23:38:56.850 --> 23:38:59.850
don't want to stay there.
However, getting an MVP done

22992
23:38:59.850 --> 23:39:02.850
getting a minimal viable project
done is really, really

22993
23:39:02.850 --> 23:39:04.850
important. So using a
centralized server, like

22994
23:39:04.850 --> 23:39:07.850
Morales, or centralized project
can make us much quicker. In

22995
23:39:07.850 --> 23:39:10.850
fact, we have been using
centralized services, like

22996
23:39:10.850 --> 23:39:13.850
alchemy, kind of throughout this
whole project. But of course, I

22997
23:39:13.850 --> 23:39:16.850
also want to show you the
decentralized way to make your

22998
23:39:16.850 --> 23:39:18.850
front end. So after we work with
Morales, we're also going to

22999
23:39:18.850 --> 23:39:21.850
show you how to use the graph
then for to do all this event

23000
23:39:21.850 --> 23:39:25.850
indexing. Now the graph is going
to be the decentralized way we

23001
23:39:25.850 --> 23:39:28.850
can make our front end and work
with these events. And the graph

23002
23:39:28.850 --> 23:39:31.850
also comes with its own graph
repo. So we'll learn all about

23003
23:39:31.850 --> 23:39:34.850
that once we get to the front
end section. But let me show you

23004
23:39:34.850 --> 23:39:37.850
what we're going to build
because it is really cool. Now

23005
23:39:37.850 --> 23:39:39.850
that we've learned a ton about
how to make NF T's what they

23006
23:39:39.850 --> 23:39:42.850
are, we're going to make our own
NFT marketplace. And like I

23007
23:39:42.850 --> 23:39:45.851
said, this is really going to be
our deep dive into all these

23008
23:39:45.851 --> 23:39:48.851
amazing front end tools. So
here's what our front end is

23009
23:39:48.851 --> 23:39:51.851
gonna look like. But what we can
do is we can connect with our

23010
23:39:51.851 --> 23:39:55.851
little connect button, we hit
Metamask Metamask pops up, we'll

23011
23:39:55.851 --> 23:39:58.851
go ahead and connect. And now
that we're connected, we can see

23012
23:39:58.851 --> 23:40:01.851
the different entities in here.
And if we're on an address

23013
23:40:01.851 --> 23:40:05.851
that's owned by us, it will say
owned by you. And if we switch

23014
23:40:05.851 --> 23:40:10.851
addresses, or UI will go ahead
and update, connect there. And

23015
23:40:10.851 --> 23:40:13.851
now we're owned by a different
address. Now, if it's owned by

23016
23:40:13.851 --> 23:40:15.851
us, we get this little hover
that says Update listing. And

23017
23:40:15.851 --> 23:40:19.851
right now it's worth 0.18.
That's what it's listed for on

23018
23:40:19.851 --> 23:40:22.851
our marketplace. If it's owned
by us, and we click it, we can

23019
23:40:22.851 --> 23:40:26.851
update it to a different price.
Let's update it to 50 eath, or

23020
23:40:26.851 --> 23:40:29.851
whatever your layer one currency
is, we'll just say new listing

23021
23:40:29.851 --> 23:40:33.851
price, we'll go ahead and
confirm. And I'll say listing

23022
23:40:33.851 --> 23:40:36.851
updated, please refresh, and
what we can do them. And we'll

23023
23:40:36.851 --> 23:40:40.851
mine some blocks on the back
end, and boom, now we see that

23024
23:40:40.851 --> 23:40:44.851
it's worth 50 here. Now if we
switch to a different account,

23025
23:40:44.851 --> 23:40:46.851
now we can see owned by blah,
blah, blah, and the hovered now

23026
23:40:46.851 --> 23:40:51.851
says by me, if his selected as a
different user, I'm gonna get

23027
23:40:51.851 --> 23:40:55.851
this transaction to actually buy
it. Now go ahead and confirm

23028
23:40:55.851 --> 23:40:57.851
that I'm gonna buy it, I get a
little pop up. This is item

23029
23:40:57.851 --> 23:41:00.851
bought successfully. Now if I do
a little refresh, we'll now see

23030
23:41:00.851 --> 23:41:04.851
that that NFT is gone from the
marketplace, since we bought it

23031
23:41:04.851 --> 23:41:07.851
right, it's no longer available
to be sold. Now what we can do

23032
23:41:07.851 --> 23:41:12.851
then is we can come over to sell
NF Ts and at the bottom, we'll

23033
23:41:12.851 --> 23:41:17.851
see a withdraw proceeds. So
whenever somebody buys an NF T,

23034
23:41:17.851 --> 23:41:20.851
the NFT marketplace actually
keeps the proceeds that actually

23035
23:41:20.851 --> 23:41:24.851
keeps the result of the sale. So
if we switch back to our address

23036
23:41:24.851 --> 23:41:28.852
that had the NF T listed, we can
now see Withdraw 50 proceeds

23037
23:41:28.852 --> 23:41:30.852
because we know that we have 50
eath, because we just bought

23038
23:41:30.852 --> 23:41:35.852
that for 50. So if we hit
withdraw, Metamask is gonna pop

23039
23:41:35.852 --> 23:41:39.852
up, we can go ahead and confirm,
wait a little bit as transaction

23040
23:41:39.852 --> 23:41:43.852
populates, and boom once it goes
through, we'll see now we have

23041
23:41:43.852 --> 23:41:46.852
zero proceeds. Right, we
withdrew everything from here.

23042
23:41:46.852 --> 23:41:50.852
So what we can do now, is we can
relist that NFT. So if we come

23043
23:41:50.852 --> 23:41:55.852
back, let's go back to the one
who just bought that NF t. If we

23044
23:41:55.852 --> 23:41:58.852
know the address and the token
ID of the NF t and we own it, we

23045
23:41:58.852 --> 23:42:00.852
can go ahead and relist it,
because we can place the address

23046
23:42:00.852 --> 23:42:05.852
in here with the token ID Give
us some sort of price, we'll

23047
23:42:05.852 --> 23:42:11.852
submit, we'll approve giving the
NFT marketplace access to our

23048
23:42:11.852 --> 23:42:15.852
NFT to our little doggie. And
then we'll go ahead and actually

23049
23:42:15.852 --> 23:42:20.852
send the transaction to actually
list the NFT on a marketplace

23050
23:42:20.852 --> 23:42:24.852
that we get NFT listed
successfully. After we remove

23051
23:42:24.852 --> 23:42:27.852
some blocks in the back end, we
can go back to the front end.

23052
23:42:27.852 --> 23:42:31.852
And we now see, it's owned by
us, instead of the original

23053
23:42:31.852 --> 23:42:35.852
owner, right and set for 10
ether. And then we can of

23054
23:42:35.852 --> 23:42:38.852
course, switch back to a
different user, and we can have

23055
23:42:38.852 --> 23:42:42.852
them actually buy. So this is
going to be a NFT marketplace

23056
23:42:42.852 --> 23:42:45.852
that's completely decentralized,
we are going to learn a ton

23057
23:42:45.852 --> 23:42:49.852
about front end a ton about
indexing a ton about events, and

23058
23:42:49.852 --> 23:42:53.852
why they are so powerful. And
I'm really excited for you for

23059
23:42:53.852 --> 23:42:55.852
this one. Because if you get
through this one, you will have

23060
23:42:55.852 --> 23:43:01.852
so many tools at your fingertips
for working with the blockchain.

23061
23:43:01.852 --> 23:43:05.852
Are you ready, let's jump in.
Let's build the contracts first,

23062
23:43:05.852 --> 23:43:07.853
and then we'll build the front
end. Let's do this. Now this

23063
23:43:07.853 --> 23:43:11.853
project is going to be based off
the Arteon project, which is a

23064
23:43:11.853 --> 23:43:15.853
completely open source
decentralized smart contract NFT

23065
23:43:15.853 --> 23:43:18.853
marketplace, I'll leave a link
to it in the GitHub repo

23066
23:43:18.853 --> 23:43:21.853
associated with this course,
ours of course, is going to be a

23067
23:43:21.853 --> 23:43:28.853
minimalistic version of this.

23068
23:43:28.853 --> 23:43:30.853
So we're in our VS code pre
normal. And we're going to

23069
23:43:30.853 --> 23:43:37.853
create a new folder here called
hard hat. And if T marketplace,

23070
23:43:37.853 --> 23:43:43.853
FCC, oops, MK dir, like them,
we're gonna cd into it. And then

23071
23:43:43.853 --> 23:43:47.853
open this up and its own VS
code. Once again, you can use

23072
23:43:47.853 --> 23:43:51.853
code period, or file open
folder, and open this folder.

23073
23:43:52.853 --> 23:43:53.853
Once we get in here, we're going
to do all of our normal stuff

23074
23:43:53.853 --> 23:43:56.853
that we've been doing throughout
the course. And once again, if

23075
23:43:56.853 --> 23:43:59.853
you want to copy paste over your
package, JSON, if you want to

23076
23:43:59.853 --> 23:44:02.853
copy paste in the modules,
whatever you want to do, feel

23077
23:44:02.853 --> 23:44:06.853
free to do so I'm gonna go ahead
actually, this repo here, we're

23078
23:44:06.853 --> 23:44:09.853
gonna scroll up and just grab
once again, this line from less

23079
23:44:09.853 --> 23:44:14.853
than nine. And just run that I
know I'm gonna be using prettier

23080
23:44:14.853 --> 23:44:16.853
so I'm just gonna go ahead and
copy paste those two prettier

23081
23:44:16.853 --> 23:44:20.853
files over prettier ignore and
prettier RC going to be using

23082
23:44:20.853 --> 23:44:23.853
them again, for linting. With
solidity we're going to use Sol

23083
23:44:23.853 --> 23:44:25.853
hint dot JSON. So we're going to
grab that dot soul hint dot

23084
23:44:25.853 --> 23:44:30.853
JSON. And the dots will hint dot
ignore. I'm also going to grab

23085
23:44:30.853 --> 23:44:33.853
the hard hat dot config dot j s
because we're going to be using

23086
23:44:33.853 --> 23:44:36.853
a really, really similar setup.
And this hard hat dot config dot

23087
23:44:36.853 --> 23:44:40.853
j s. It's got waffle in it,
ether scan, hard hat deploy

23088
23:44:40.853 --> 23:44:44.853
coverage gas reporter sizer and
Dottie and v dot config, we're

23089
23:44:44.853 --> 23:44:47.854
going to bring over our Dotty
and V. And we're also gonna

23090
23:44:47.854 --> 23:44:50.854
bring over our utils folder as
well. Right, so a lot of that

23091
23:44:50.854 --> 23:44:53.854
boilerplate we're gonna bring on
over. And now just like that,

23092
23:44:53.854 --> 23:44:56.854
since we have the hard hat dot
config dot j s in here, if we

23093
23:44:56.854 --> 23:45:01.854
run yarn, hard hat, right now,
yarn hard hat will actually see

23094
23:45:01.854 --> 23:45:05.854
we get the output like this. So
let's go ahead. And before we

23095
23:45:05.854 --> 23:45:08.854
actually write our contracts,
let's go ahead and write a

23096
23:45:08.854 --> 23:45:11.854
little doc saying what our
contract is even going to do,

23097
23:45:11.854 --> 23:45:15.854
what do we want this to do?
We're going to create a

23098
23:45:15.854 --> 23:45:19.854
decentralized NFT marketplace.
So what does that mean? What

23099
23:45:19.854 --> 23:45:23.854
will we probably need? Well,
we'll probably need some type of

23100
23:45:23.854 --> 23:45:27.854
list item function, because
we'll want to list NF T's and

23101
23:45:27.854 --> 23:45:31.854
this will be to list NF t's on
the marketplace, we'll need some

23102
23:45:31.854 --> 23:45:34.854
type of buy item to buy the NF
T's. And then we'll probably

23103
23:45:34.854 --> 23:45:38.854
need maybe like a cancel listing
or cancel item, if you no longer

23104
23:45:38.854 --> 23:45:44.854
want to sell it, maybe an update
listing, update price. And then

23105
23:45:44.854 --> 23:45:50.854
maybe a withdraw proceeds to
withdraw payment or my bot and

23106
23:45:50.854 --> 23:45:53.854
fts. So when somebody buys an
NFT, I'm gonna have to withdraw

23107
23:45:53.854 --> 23:45:56.854
it from the contract since the
contract is going to be the one

23108
23:45:56.854 --> 23:45:58.854
to actually hold those funds.
That looks pretty good to me.

23109
23:45:58.854 --> 23:46:01.854
Let's go ahead and start
building this. So let's create a

23110
23:46:01.854 --> 23:46:06.854
new folder, contracts. And let's
jump into this. So we'll create

23111
23:46:06.854 --> 23:46:09.854
a new file NFT marketplace.

23112
23:46:09.854 --> 23:46:18.854
That's all. So let's get our
boilerplate. spdx pragma,

23113
23:46:18.854 --> 23:46:24.854
solidity, carrot zero, point,
8.7, contract and ft.

23114
23:46:24.854 --> 23:46:29.855
Marketplace, boom. If we're
doing this, right, h h compile

23115
23:46:29.855 --> 23:46:33.855
or yarn Hardhead to compile or
MPX, art, hit, compile, boom,

23116
23:46:33.855 --> 23:46:37.855
things are looking good. So if
we go back to our readme, we can

23117
23:46:37.855 --> 23:46:42.855
grab these here, even stick them
in as like a little comment for

23118
23:46:42.855 --> 23:46:45.855
us to kind of reference later
on. Let's start with listing the

23119
23:46:45.855 --> 23:46:48.855
items. How are we going to keep
track of listing people's items.

23120
23:46:48.855 --> 23:46:51.855
And once again, remember, when
I'm usually coding this, I'm

23121
23:46:51.855 --> 23:46:54.855
going back and forth between
writing tests and writing the

23122
23:46:54.855 --> 23:46:57.855
actual code. We're just going to
write all the solidity in one

23123
23:46:57.855 --> 23:47:00.855
chunk, and then go write the
tests. So we're going to say,

23124
23:47:00.855 --> 23:47:05.855
these are going to be our main
functions. I'm going to start

23125
23:47:05.855 --> 23:47:09.855
with function list item. And we
are going to make this one look

23126
23:47:09.855 --> 23:47:12.855
really, really good. So we're
going to do natspec. And

23127
23:47:12.855 --> 23:47:15.855
everything, this is going to
need to be an external function,

23128
23:47:15.855 --> 23:47:18.855
right, we're probably not going
to want any of our internal

23129
23:47:18.855 --> 23:47:20.855
functions calling list item,
it's going to be called by

23130
23:47:20.855 --> 23:47:23.855
external projects or external
accounts are probably going to

23131
23:47:23.855 --> 23:47:26.855
need an address and ft address,
write the address of the NFT,

23132
23:47:26.855 --> 23:47:32.855
contract a un 256 token ID, the
ID of the token ID of the

23133
23:47:32.855 --> 23:47:34.855
contract that we're going to
use. And then we're going to

23134
23:47:34.855 --> 23:47:37.855
want to set a un 256 price. So
first off, we're probably going

23135
23:47:37.855 --> 23:47:41.855
to want the price to be greater
than zero. So maybe we'll put in

23136
23:47:41.855 --> 23:47:45.855
like a little if or require
statement here, we'll say if

23137
23:47:45.855 --> 23:47:50.855
price is less than or equal to
zero, then we'll go ahead and

23138
23:47:50.855 --> 23:47:57.855
revert with a price must be
above zero error. And then of

23139
23:47:57.855 --> 23:48:01.855
course, we'll prepend it with
the name of the contract into

23140
23:48:01.855 --> 23:48:06.856
underscores. And then at the
top, the error price must be

23141
23:48:06.856 --> 23:48:09.856
above zero. Now in order for us
to list it, we could actually do

23142
23:48:09.856 --> 23:48:13.856
this one of two ways we could
one, we could send the NFT to

23143
23:48:13.856 --> 23:48:16.856
the contract, this would require
us doing like a transfer, right,

23144
23:48:16.856 --> 23:48:21.856
we could have got the contract
hold the NFT. Now we could do

23145
23:48:21.856 --> 23:48:25.856
this, but this is going to be
kind of gas expensive for

23146
23:48:25.856 --> 23:48:29.856
someone to actually list on f t.
And we can have the owner of the

23147
23:48:29.856 --> 23:48:32.856
NFT be our NFT marketplace, we
could 100 percent do that. The issue

23148
23:48:32.856 --> 23:48:35.856
with this, though is that the
marketplace will then own the

23149
23:48:35.856 --> 23:48:38.856
NFT. And the user won't be able
to say like, Hey, I own this

23150
23:48:38.856 --> 23:48:40.856
NFT, it's in the marketplace,
they technically would be able

23151
23:48:40.856 --> 23:48:43.856
to but they would have to
withdraw it, we might do this a

23152
23:48:43.856 --> 23:48:47.856
slightly different way where we
can say owners can still hold

23153
23:48:47.856 --> 23:48:53.856
their NFT and give the
marketplace approval to sell the

23154
23:48:53.856 --> 23:48:57.856
NFT for them. Now, of course the
owners of the entity could

23155
23:48:57.856 --> 23:49:00.856
withdraw approval at any time
and the marketplace wouldn't be

23156
23:49:00.856 --> 23:49:03.856
able to sell it anymore.
However, this would be really

23157
23:49:03.856 --> 23:49:05.856
easy for people to actually
read, they would all they would

23158
23:49:05.856 --> 23:49:09.856
have to do is read like is
approved for marketplace. And

23159
23:49:09.856 --> 23:49:11.856
they can actually see if the
item was really listed or not.

23160
23:49:11.856 --> 23:49:14.856
So we're gonna go ahead and
write it this second way,

23161
23:49:14.856 --> 23:49:18.856
because that's what Ardian does.
And this is the least intrusive

23162
23:49:18.856 --> 23:49:21.856
way to have this marketplace,
right? People still will have

23163
23:49:21.856 --> 23:49:24.856
ownership of their NF Ts, and
the marketplace will just have

23164
23:49:24.856 --> 23:49:29.856
approval to actually swap and
sell their NF T once the prices

23165
23:49:29.856 --> 23:49:32.856
are met. So since we want to
make sure the marketplace has

23166
23:49:32.856 --> 23:49:36.856
approval, let's make sure the
marketplace has approval. So we

23167
23:49:36.856 --> 23:49:39.856
can call we can call this get
approved function on that token

23168
23:49:39.856 --> 23:49:44.856
ID to make sure that the
marketplace is approved to work

23169
23:49:44.856 --> 23:49:49.857
with the NFT. To do this, we're
going to need the AI ERC 720

23170
23:49:49.857 --> 23:49:53.857
interface and we can actually
grab that from open Zeppelin.

23171
23:49:53.857 --> 23:49:56.857
Right and this interface will
wrap around an address and then

23172
23:49:56.857 --> 23:50:01.857
we can call get approved on that
address. So we'll do import at

23173
23:50:01.857 --> 23:50:08.857
open Zeppelin slash contracts
slash token slash ERC 721 slash

23174
23:50:08.857 --> 23:50:13.857
I ERC 721 dot Sol. And since
we're doing an import from open

23175
23:50:13.857 --> 23:50:19.857
Zeppelin, we'll do yarn add dash
dash Dev, add open Zeppelin now

23176
23:50:19.857 --> 23:50:23.857
that we have this interface in
here, what we can do is we'll

23177
23:50:23.857 --> 23:50:33.857
say I ERC 721 NF t equals IRC
721 wrapped around this NF T

23178
23:50:33.857 --> 23:50:37.857
address that we're passing in.
And we'll say if NF T dot get

23179
23:50:37.857 --> 23:50:43.857
approved of the token ID that
we're trying to list does not

23180
23:50:43.857 --> 23:50:49.857
equal address this. So if we are
not approved, then we'll revert

23181
23:50:49.857 --> 23:50:56.857
not approved or market place.
And then we'll of course we'll

23182
23:50:56.857 --> 23:51:01.857
want to do prepend it with NFT
marketplace into underscores. So

23183
23:51:01.857 --> 23:51:06.857
error like this, Bada bing bada
boom, now that we've gotten a

23184
23:51:06.857 --> 23:51:09.857
little bit of that out of the
way, we're probably going to

23185
23:51:09.857 --> 23:51:12.857
want to have some type of data
structure to list all these NF

23186
23:51:12.857 --> 23:51:15.857
T's. And typically we get to
Okay, do we want to use an

23187
23:51:15.857 --> 23:51:17.857
array? Or do we want to use a
mapping? What do you think?

23188
23:51:17.857 --> 23:51:20.857
Before we continue? Let's pause
for a second, do you think it

23189
23:51:20.857 --> 23:51:23.857
makes more sense to put these NF
T's and an array or an A

23190
23:51:23.857 --> 23:51:25.857
mapping? And when you're
thinking about this, try to

23191
23:51:25.857 --> 23:51:28.858
think about, okay, well, people
are gonna have to buy these and

23192
23:51:28.858 --> 23:51:30.858
sell these, what makes more
sense, think about this for a

23193
23:51:30.858 --> 23:51:34.858
second, maybe pause it and write
in a comment here, what you

23194
23:51:34.858 --> 23:51:37.858
think an array or a mapping is
better. Now, if you said

23195
23:51:37.858 --> 23:51:40.858
mapping, I would agree with you.
You couldn't do an array and you

23196
23:51:40.858 --> 23:51:43.858
wouldn't necessarily be wrong,
but it's not the way that I

23197
23:51:43.858 --> 23:51:46.858
would go about that for an
array. Anytime someone wants to

23198
23:51:46.858 --> 23:51:49.858
buy an item, we're gonna have to
traverse through the array,

23199
23:51:49.858 --> 23:51:53.858
we're gonna have to make this
massive dynamic array. And that

23200
23:51:53.858 --> 23:51:56.858
might get a little bit dicey as
that array gets really, really

23201
23:51:56.858 --> 23:51:59.858
big. So we're gonna go ahead and
make this a mapping. And this is

23202
23:51:59.858 --> 23:52:03.858
probably going to be a global
variable or a state variable. So

23203
23:52:03.858 --> 23:52:05.858
up at the top, let's go ahead
and create this mapping, it's

23204
23:52:05.858 --> 23:52:09.858
going to be a mapping of
addresses of NFT addresses.

23205
23:52:09.858 --> 23:52:13.858
Right? So it's going to be the
NFT contract address mapped to

23206
23:52:13.858 --> 23:52:19.858
the NFT, token ID mapped to some
type of listing. So we'll say, a

23207
23:52:19.858 --> 23:52:26.858
mapping of address to a mapping
of UNT 256. to, well, what do we

23208
23:52:26.858 --> 23:52:28.858
want here? Well, we want we want
the price, right? So is that

23209
23:52:28.858 --> 23:52:32.858
another you went up to six. But
we also want, we also want to

23210
23:52:32.858 --> 23:52:36.858
keep track of the sellers, we
know who to send money to. So we

23211
23:52:36.858 --> 23:52:39.858
could make two mappings or we
just create a new type of type

23212
23:52:39.858 --> 23:52:42.858
listing, let's go ahead and do
that. We'll comment this out for

23213
23:52:42.858 --> 23:52:46.858
now. And so at the top, since
this is going to be a type

23214
23:52:46.858 --> 23:52:50.858
where, say, struct listing, and
in here, we're going to do a

23215
23:52:50.858 --> 23:52:55.858
utility six, the price of the NF
t, and then address the seller

23216
23:52:55.858 --> 23:52:58.858
of the NF team. And now that we
have that new typing, we can

23217
23:52:58.858 --> 23:53:03.858
uncomment this, we can say NFT,
contract address map to the NFT

23218
23:53:03.858 --> 23:53:08.859
token ID mapped to the listing,
and we'll make this a private

23219
23:53:08.859 --> 23:53:12.859
variable called S underscore
listings. Now back down in our

23220
23:53:12.859 --> 23:53:17.859
list item function, we're going
to update that s listing

23221
23:53:17.859 --> 23:53:21.859
mapping. So we're gonna say s
listing of NF T address, right,

23222
23:53:21.859 --> 23:53:25.859
the address of the NF T at the
token ID is going to equal we're

23223
23:53:25.859 --> 23:53:29.859
gonna create a listing of the
price. And then who, well the

23224
23:53:29.859 --> 23:53:32.859
seller is going to be message
that sender, right? So message

23225
23:53:32.859 --> 23:53:36.859
dot sender, they're the one
who's actually listing the item.

23226
23:53:36.859 --> 23:53:38.859
And since we're updating a
mapping here, what's the best

23227
23:53:38.859 --> 23:53:42.859
practice for update mappings,
you guessed it, we need to emit

23228
23:53:42.859 --> 23:53:46.859
an event and especially for this
project, you're gonna see why

23229
23:53:46.859 --> 23:53:49.859
emitting events, for at least
this project, this is so

23230
23:53:49.859 --> 23:53:53.859
helpful. So we're gonna go ahead
and emit an item listed event,

23231
23:53:53.859 --> 23:53:56.859
which we're going to create in
just a second. And we'll give

23232
23:53:56.859 --> 23:54:01.859
the message that sender, the NFT
address, the token ID, and the

23233
23:54:01.859 --> 23:54:06.859
price item listed. And then up
at the top, of course, but below

23234
23:54:06.859 --> 23:54:11.859
our structure, we're gonna say
event item listed will do an

23235
23:54:11.859 --> 23:54:15.859
address indexed seller

23236
23:54:15.859 --> 23:54:26.859
address indexed NFT, address,
address indexed token ID, and

23237
23:54:26.859 --> 23:54:31.859
then a un 256 price. Sorry, this
needs to be a un 256 token ID,

23238
23:54:31.859 --> 23:54:37.859
you int 56. This looks pretty
good to us. However, we probably

23239
23:54:37.859 --> 23:54:40.859
want to make sure we only list
and FTEs that haven't already

23240
23:54:40.859 --> 23:54:45.859
been listed. So we can add like
an if then in here. And this is

23241
23:54:45.859 --> 23:54:47.860
kind of where preference comes
in a little bit. But I'm

23242
23:54:47.860 --> 23:54:51.860
actually going to create a
modifier called not listed. So

23243
23:54:51.860 --> 23:54:54.860
we make sure we don't relist,
and if T's that are already

23244
23:54:54.860 --> 23:55:00.860
listed above our main functions,
or do like a little indicator

23245
23:55:00.860 --> 23:55:06.860
modifier not listed. This is
gonna take an an address NFT

23246
23:55:06.860 --> 23:55:13.860
address, a un 256 token ID and
an address owner. And what we're

23247
23:55:13.860 --> 23:55:16.860
going to say is we're going to
check, we're going to make a new

23248
23:55:16.860 --> 23:55:22.860
listing memory listing equals s
underscore listings of NFT

23249
23:55:22.860 --> 23:55:30.860
address token ID. Now we're
gonna say if listing dot price

23250
23:55:30.860 --> 23:55:33.860
is greater than zero, we're
gonna go ahead and revert with

23251
23:55:33.860 --> 23:55:40.860
already passing the NFT address
and a token ID. And of course,

23252
23:55:40.860 --> 23:55:47.860
we're going to prepend this with
NFT marketplace. And at the top,

23253
23:55:47.860 --> 23:55:52.860
we do error ft marketplace
already listed, like so. And

23254
23:55:52.860 --> 23:55:56.860
then we're going to put a little
underscore right underneath and

23255
23:55:56.860 --> 23:56:01.860
then up here, we'll do address
and if the address you went to

23256
23:56:01.860 --> 23:56:06.860
56. Okay, ID. So this modifier
looks pretty good. Let's just

23257
23:56:06.860 --> 23:56:09.860
make sure it's actually going to
compile we'll do yarn Hardhead

23258
23:56:09.860 --> 23:56:13.860
compile or hh compile. Great.
That looks good. We'll add this

23259
23:56:13.860 --> 23:56:18.860
modifier to our list item
function will do NFT address,

23260
23:56:18.860 --> 23:56:23.860
token ID message dot sender.
Cool. What else should we check

23261
23:56:23.860 --> 23:56:28.861
for here? Well, we should also
check that the NF T that's being

23262
23:56:28.861 --> 23:56:32.861
listed is owned by message dot
sender. This way only the owners

23263
23:56:32.861 --> 23:56:35.861
of the NF T can actually listed
here so let's go ahead and we'll

23264
23:56:35.861 --> 23:56:45.861
add a is owner modifier modifier
is owner NFT address token ID

23265
23:56:45.861 --> 23:56:55.861
spender you into 256 here and an
address spender I ERC 721 NF t

23266
23:56:55.861 --> 23:57:01.861
equals IRC 721 And if the
address address owner equals NF

23267
23:57:01.861 --> 23:57:08.861
T dot owner a Have a token ID.
And then we'll say if spender

23268
23:57:08.861 --> 23:57:13.861
does not equal owner. And we'll
revert with a not owner error

23269
23:57:13.861 --> 23:57:16.861
that we're going to go ahead and
create up top. So we'll say

23270
23:57:16.861 --> 23:57:22.861
error, not owner. And we'll
prepend it with NFT marketplace

23271
23:57:22.861 --> 23:57:27.861
with two underscores revert
revert not owner, then will do

23272
23:57:27.861 --> 23:57:31.861
underscore for the rest of the
code, and boom, now underneath

23273
23:57:31.861 --> 23:57:39.861
are not listed will do is owner
NFT address, token ID message

23274
23:57:39.861 --> 23:57:42.861
dot center. So now our list item
checks to see if it's already

23275
23:57:42.861 --> 23:57:48.861
listed, make sure that only the
owner of the NFT of that token,

23276
23:57:48.861 --> 23:57:51.861
Id can list it. And then it goes
ahead and lists it looking

23277
23:57:51.861 --> 23:57:55.861
nicely. Okay, cool. So that is
our list item method here. Now

23278
23:57:55.861 --> 23:57:57.861
let's go ahead and do a little
bit of natspec on

23279
23:57:57.861 --> 23:58:05.861
this. And now we have a little
natspec here, which looks really

23280
23:58:05.861 --> 23:58:09.862
professional. Alright, great. So
we have a list item function.

23281
23:58:09.862 --> 23:58:12.862
All right, what's next? Well,
maybe let's make a buy item

23282
23:58:12.862 --> 23:58:15.862
function for people to buy their
NF T's after they've been

23283
23:58:15.862 --> 23:58:21.862
listed. So let's create them do
function by item. So we'll take

23284
23:58:21.862 --> 23:58:28.862
an address, and if the address
un 256 token ID, and this will

23285
23:58:28.862 --> 23:58:33.862
be an external function. And
that will also make this payable

23286
23:58:33.862 --> 23:58:36.862
an external function because we
know only people or contracts

23287
23:58:36.862 --> 23:58:40.862
outside of this contract are
going to call by item and

23288
23:58:40.862 --> 23:58:44.862
payable so that people can spend
eath to spend eath, or whatever

23289
23:58:44.862 --> 23:58:47.862
layer one currency to actually
buy these prices, we could want

23290
23:58:47.862 --> 23:58:51.862
100 percent at channeling prices in now
for listing, we could of course,

23291
23:58:51.862 --> 23:58:57.862
add price and then do like, you
know address token price. And do

23292
23:58:57.862 --> 23:59:00.862
what we did before with chain
link price feeds to convert the

23293
23:59:00.862 --> 23:59:02.862
price of these tokens into how
much they actually cost. And we

23294
23:59:02.862 --> 23:59:06.862
could 100 percent do that with chaining
price feeds. But for simplicity,

23295
23:59:06.862 --> 23:59:08.862
we're gonna leave that off. But
I will put that as a challenge

23296
23:59:08.862 --> 23:59:12.862
to you through challenge is
going to be have this contract

23297
23:59:12.862 --> 23:59:17.862
accept payment in a subset of
tokens as well, of course, we

23298
23:59:17.862 --> 23:59:21.862
would need to give a little hint
here is channeling price feeds

23299
23:59:21.862 --> 23:59:26.862
to convert the price of the
tokens between each other, we're

23300
23:59:26.862 --> 23:59:30.862
gonna choose which NFT in which
token ID we want to buy. So

23301
23:59:30.862 --> 23:59:33.862
what's the first thing that we
probably want to do? Well, we

23302
23:59:33.862 --> 23:59:36.862
probably want to check that this
by item is actually listed. So

23303
23:59:36.862 --> 23:59:38.862
we're actually going to make a
new modifier instead of not

23304
23:59:38.862 --> 23:59:43.862
listed we'll make it is listed
up and modifiers modifier is

23305
23:59:43.862 --> 23:59:47.863
listed. And this is going to
take an address and up the

23306
23:59:47.863 --> 23:59:54.863
address un 256 token ID. And to
check to see if this is listed,

23307
23:59:54.863 --> 24:00:01.863
we'll say listing memory listing
equals s underscore listings of

23308
24:00:01.863 --> 24:00:07.863
the NFT address of the token, Id
sort of go into the mapping

23309
24:00:07.863 --> 24:00:11.863
here. And then we're just gonna
check the price. So we'll say if

23310
24:00:11.863 --> 24:00:15.863
the listing that price is less
than or equal to zero, so

23311
24:00:15.863 --> 24:00:19.863
basically, if there's no price,
if it's defaulted to zero, if

23312
24:00:19.863 --> 24:00:26.863
the price is zero, then we're
gonna say revert, not listed.

23313
24:00:26.863 --> 24:00:32.863
And after the address, token ID,
and of course, we're going to

23314
24:00:32.863 --> 24:00:36.863
prepend. And if the marketplace
and the marketplace underscore

23315
24:00:36.863 --> 24:00:40.863
underscore, not listed, and then
we're gonna copy this up here,

23316
24:00:40.863 --> 24:00:45.863
we're gonna say air listed, and
this is going to take address,

23317
24:00:45.863 --> 24:00:51.863
NFT address, and au int 256
token Id like so, the down in

23318
24:00:51.863 --> 24:00:53.863
our modifier, then we're going
to add the underscore and to add

23319
24:00:53.863 --> 24:00:56.863
the rest of our code here. So
now we have an is listed

23320
24:00:56.863 --> 24:01:00.863
modifier, we're going to check
to make sure that that NFT is

23321
24:01:00.863 --> 24:01:03.863
actually listed down here now
we're gonna say is listed

23322
24:01:03.863 --> 24:01:08.863
address and ft address or excuse
me, and if the address and token

23323
24:01:08.863 --> 24:01:16.863
ID. Now once again, we're gonna
say listing memory listed item

23324
24:01:16.863 --> 24:01:24.863
equals s underscore listings.
And if T address token ID, or

23325
24:01:24.863 --> 24:01:30.864
say if message dot value is less
than listed item dot price, then

23326
24:01:30.864 --> 24:01:36.864
we're going to revert with price
not met. Then we'll do NFT

23327
24:01:36.864 --> 24:01:43.864
address, Open ID listed item dot
price Excel so we're going to

23328
24:01:43.864 --> 24:01:47.864
create a new air price not met
error. Price not met of course

23329
24:01:47.864 --> 24:01:51.864
we're going to prepend this with
NFT marketplace to take an

23330
24:01:51.864 --> 24:01:58.864
address. And if the address you
went to 56 token ID and then a

23331
24:01:58.864 --> 24:02:05.864
UNT 256 price. So we can see exe
exactly how the price wasn't

23332
24:02:05.864 --> 24:02:09.864
met, and then back down here,
we'll get the full error. So we

23333
24:02:09.864 --> 24:02:12.864
want to make sure they're
sending us enough money. First

23334
24:02:12.864 --> 24:02:16.864
of all, when they send this
money, it needs to belong to

23335
24:02:16.864 --> 24:02:20.864
whomever listed the item. So we
actually need to keep track of

23336
24:02:20.864 --> 24:02:24.864
how much money these people
have. So let's create another

23337
24:02:24.864 --> 24:02:28.864
data structure called proceeds
where we keep track of how much

23338
24:02:28.864 --> 24:02:32.864
money people have earned selling
their NF T's. So we'll create a

23339
24:02:32.864 --> 24:02:40.864
mapping of address to you and
256. And this is going to be a

23340
24:02:40.864 --> 24:02:46.864
mapping of seller address to
amount earned. And we'll make

23341
24:02:46.864 --> 24:02:53.864
this private called S underscore
proceeds. And what we'll do is

23342
24:02:53.864 --> 24:02:58.864
when somebody buys an item, is
will update their proceeds.

23343
24:02:58.864 --> 24:03:06.864
So we'll say as proceeds of
listed item, that seller equals

23344
24:03:06.864 --> 24:03:13.865
s proceeds of illicit IO dot
seller plus MSG dot value. Now,

23345
24:03:13.865 --> 24:03:17.865
once we buy this item, we're
going to want to delete the

23346
24:03:17.865 --> 24:03:21.865
listing. So to delete a mapping
from a wreck, so to delete an

23347
24:03:21.865 --> 24:03:26.865
entry and a mapping, we just use
delete s underscore listings and

23348
24:03:26.865 --> 24:03:32.865
ft address of the token ID. So
we remove that mapping. And then

23349
24:03:32.865 --> 24:03:35.865
finally, we're going to go ahead
and transfer it. So we'll say I

23350
24:03:35.865 --> 24:03:43.865
ERC 721 and ft address, we're
going to call dot transfer from

23351
24:03:43.865 --> 24:03:49.865
the listed item dot seller to
the message dot sender with the

23352
24:03:49.865 --> 24:03:54.865
token ID. Now you'll notice
something here, we don't just

23353
24:03:54.865 --> 24:03:58.865
send the seller the money. Now
why is that? Well, solidity has

23354
24:03:58.865 --> 24:04:02.865
this concept called pull over
push. And it's considered a best

23355
24:04:02.865 --> 24:04:05.865
practice when working with
solidity, you want to shift the

23356
24:04:05.865 --> 24:04:08.865
risk associated with
transferring ether to the user.

23357
24:04:08.865 --> 24:04:12.865
So instead of sending the money
to the user, this is what we

23358
24:04:12.865 --> 24:04:16.865
don't want to do want to have
them withdraw the money, we

23359
24:04:16.865 --> 24:04:19.865
always want to shift the risk of
working with money and working

23360
24:04:19.865 --> 24:04:23.865
with eath or whatever layer one
you're working with, to the

23361
24:04:23.865 --> 24:04:27.865
actual user. So we don't want to
send them the money directly, we

23362
24:04:27.865 --> 24:04:31.865
want to create this s proceeds
data structure and we can have

23363
24:04:31.865 --> 24:04:34.865
them withdraw from it later on.
Now, we could probably do some

23364
24:04:34.865 --> 24:04:39.865
checking here. Or we could say
okay, check to make sure the NFT

23365
24:04:39.865 --> 24:04:45.865
was transferred. And if we look
at I ERC 721 though, and we're

23366
24:04:45.865 --> 24:04:49.866
looking at the transfer from
function, we don't see it

23367
24:04:49.866 --> 24:04:56.866
actually has a return. And if we
go to the IP 721 We can see that

23368
24:04:56.866 --> 24:04:59.866
none of these have a return type
though, transfer from doesn't

23369
24:04:59.866 --> 24:05:02.866
have a return type here.
However, we do see this safe

23370
24:05:02.866 --> 24:05:06.866
transfer from bit safe transfer
from it's going to be a little

23371
24:05:06.866 --> 24:05:09.866
bit better, right because if we
look at transfer from transfers

23372
24:05:09.866 --> 24:05:12.866
ownership of an entity, the
caller is responsible to confirm

23373
24:05:12.866 --> 24:05:16.866
that underscore two is capable
of receiving entities or else

23374
24:05:16.866 --> 24:05:19.866
they may be permanently lost. So
maybe instead we want to use

23375
24:05:19.866 --> 24:05:23.866
safe transfer from which throws
an error unless message sender

23376
24:05:23.866 --> 24:05:26.866
is the current owner and
authorize operator, or blah,

23377
24:05:26.866 --> 24:05:29.866
blah, blah. So instead of
transfer from we're going to

23378
24:05:29.866 --> 24:05:32.866
actually use safe transfer from
just to be a little bit safer.

23379
24:05:32.866 --> 24:05:37.866
So we'll do safe transfer from
instead of transfer from. And

23380
24:05:37.866 --> 24:05:40.866
then since we're updating a
mapping, we're going to do what,

23381
24:05:40.866 --> 24:05:45.866
you guessed it, let's omit an
event, we'll call item bot. Lab

23382
24:05:45.866 --> 24:05:50.866
will be a message that sender,
an empty address, token ID and

23383
24:05:50.866 --> 24:05:55.866
for listed item that price. So
off the top, let's create a new

23384
24:05:55.866 --> 24:06:05.866
event. To event item bought. And
this will be a an address

23385
24:06:05.866 --> 24:06:17.866
indexed fire an address indexed
NFT address an address indexed

23386
24:06:17.866 --> 24:06:22.866
token ID and then a un 236
price. Just kidding, that

23387
24:06:22.866 --> 24:06:25.866
doesn't look fantastic. This
should be intuitive six. Now it

23388
24:06:25.866 --> 24:06:32.867
looks fantastic. Now in this buy
item, we've set this up in a way

23389
24:06:32.867 --> 24:06:36.867
that is safe from something
called a reentrancy attack. And

23390
24:06:36.867 --> 24:06:38.867
we've been coding these
contracts in a way where we kind

23391
24:06:38.867 --> 24:06:42.867
of do all this state change
first. And then we transfer the

23392
24:06:42.867 --> 24:06:47.867
NFT that token or etc. But why
are we doing that? Cognitively

23393
24:06:47.867 --> 24:06:50.867
we think it might make sense.
Okay, first, maybe we should

23394
24:06:50.867 --> 24:06:54.867
actually send the NFT right,
we'd want to send the entity

23395
24:06:54.867 --> 24:06:57.867
first.

23396
24:06:57.867 --> 24:07:01.867
This is actually a huge security
vulnerability. And to understand

23397
24:07:01.867 --> 24:07:05.867
why let's learn about one The
most common hacks in blockchain,

23398
24:07:05.867 --> 24:07:08.867
the reentrant. See attack. Now
in this sub lesson, we're going

23399
24:07:08.867 --> 24:07:11.867
to talk about reentrant. C, and
in the GitHub repo associated

23400
24:07:11.867 --> 24:07:14.867
with this lesson, we're going to
have the code for everything

23401
24:07:14.867 --> 24:07:16.867
that we're going to go through
here. And the code that we're

23402
24:07:16.867 --> 24:07:21.867
looking at is based off of this
solidity by example. reentrant.

23403
24:07:21.867 --> 24:07:24.867
See example. And I have a link
to it in the GitHub repo

23404
24:07:24.867 --> 24:07:26.867
associated with this course.
Now, I have a sample contract

23405
24:07:26.867 --> 24:07:30.867
here, it's a place where you can
deposit and withdraw your eath.

23406
24:07:30.867 --> 24:07:34.867
So what it does is it has a
mapping called balances, where

23407
24:07:34.867 --> 24:07:39.867
you can call deposit, and it'll
update how much you've deposited

23408
24:07:39.867 --> 24:07:42.867
into the protocol. And then it
has a withdrawal function as

23409
24:07:42.867 --> 24:07:47.867
well. So what it does is it
first grabs your balance from

23410
24:07:47.867 --> 24:07:50.867
this balances mapping, make sure
that you have more than zero.

23411
24:07:50.867 --> 24:07:53.867
And then the way that we've been
sending eath, this whole time,

23412
24:07:53.867 --> 24:07:57.867
we do message that sender dot
call, we send the balance, and

23413
24:07:57.867 --> 24:08:01.867
then we update bounces of
message sender equals zero. Now

23414
24:08:01.867 --> 24:08:04.867
this is the line that actually
makes this contract incredibly

23415
24:08:04.867 --> 24:08:07.868
vulnerable. And if we run this
right now, though, we'll say

23416
24:08:07.868 --> 24:08:10.868
hey, no, it looks like it's
working as expected, we can go

23417
24:08:10.868 --> 24:08:16.868
to deploy a copy the accounts
that I'm working with, like that

23418
24:08:16.868 --> 24:08:23.868
in a bounce zero, we can
deposit, you know, it's going

23419
24:08:23.868 --> 24:08:28.868
away, let's go to ether, will
deposit to ether, come down,

23420
24:08:28.868 --> 24:08:33.868
what deposit now had to balance
bounces up, we'll hit withdraw,

23421
24:08:33.868 --> 24:08:36.868
now have bounces goes back to
zero. And it seems like it's

23422
24:08:36.868 --> 24:08:39.868
working as intended. Now,
there's actually a way we can

23423
24:08:39.868 --> 24:08:44.868
attack this function to drain
all the money in this contract.

23424
24:08:44.868 --> 24:08:48.868
And this is what's known as a
reentrancy attack. The two most

23425
24:08:48.868 --> 24:08:52.868
common kinds of attacks in this
space are going to be reentrancy

23426
24:08:52.868 --> 24:08:55.868
attacks, which is what we're
talking about here. And Oracle

23427
24:08:55.868 --> 24:08:58.868
attacks, which usually only
happen when a protocol doesn't

23428
24:08:58.868 --> 24:09:01.868
use the decentralized Oracle,
lucky for you, we're teaching

23429
24:09:01.868 --> 24:09:04.868
you right from the get go how to
use chain link so that you can

23430
24:09:04.868 --> 24:09:07.868
be protected. And it's these two
types of attacks that often

23431
24:09:07.868 --> 24:09:11.868
result in the most amount of
money last, there's a

23432
24:09:11.868 --> 24:09:14.868
leaderboard called rec dot news,
which keeps track of many of the

23433
24:09:14.868 --> 24:09:18.868
top attacks that have ever
happened in the defi space. With

23434
24:09:18.868 --> 24:09:21.868
many of them if you go into the
retrospectives are either an

23435
24:09:21.868 --> 24:09:25.868
Oracle attack or a reentrancy
attack. And you might be saying,

23436
24:09:25.868 --> 24:09:28.868
Hey, where are we just talking
about NF T's this, this doesn't

23437
24:09:28.868 --> 24:09:31.868
have anything to do with NF T's
we'll get there, don't worry. In

23438
24:09:31.868 --> 24:09:35.868
a new contract below, we're
going to create a new contract

23439
24:09:35.868 --> 24:09:38.868
called attack down here. And
what we'll do with this attack

23440
24:09:38.868 --> 24:09:42.868
contract is we'll grab this
reentrant vulnerable contract,

23441
24:09:42.868 --> 24:09:47.869
we'll say reentrant, vulnerable,
public reentrant vulnerable,

23442
24:09:47.869 --> 24:09:51.869
like so. And we'll save that
reentrant vulnerable contract as

23443
24:09:51.869 --> 24:09:56.869
a global variable. And we'll say
construct door address,

23444
24:09:56.869 --> 24:10:02.869
underscore ranch and vulnerable
address. And then we'll say

23445
24:10:02.869 --> 24:10:10.869
reentrant vulnerable equals
rancher and vulnerable at

23446
24:10:10.869 --> 24:10:14.869
reentrant vulnerable address.
Now what we're going to do is

23447
24:10:14.869 --> 24:10:18.869
we're going to create a function
called attack. And it's this

23448
24:10:18.869 --> 24:10:24.869
function that's going to call
withdraw in a malicious way. So

23449
24:10:24.869 --> 24:10:26.869
we're going to say attack, this
is going to be an external

23450
24:10:26.869 --> 24:10:30.869
payable contract. And we're
going to call the posit on this.

23451
24:10:30.869 --> 24:10:33.869
So we'll deposit some money
first. So we'll do reentrant

23452
24:10:33.869 --> 24:10:37.869
vulnerable dot the posit

23453
24:10:37.869 --> 24:10:42.869
will send a value of one ether.
And then immediately we will

23454
24:10:42.869 --> 24:10:49.869
call re N Trent vulnerable dot
withdraw. Now at first glance,

23455
24:10:49.869 --> 24:10:51.869
this seems pretty harmless.

23456
24:10:51.869 --> 24:10:57.869
But remember, when we call
message dot call like this to

23457
24:10:57.869 --> 24:11:01.869
send we're calling back to this
this attack contract. Now when

23458
24:11:01.869 --> 24:11:05.869
we call this attack contract, is
there a way to execute any other

23459
24:11:05.869 --> 24:11:10.869
code? Well, there is remember
how we learned about fallback

23460
24:11:10.869 --> 24:11:15.869
functions. If we put a fallback
function in here or a receive

23461
24:11:15.869 --> 24:11:20.869
function. When this code runs
call and seconds our contract

23462
24:11:20.869 --> 24:11:25.869
ether we can have it trigger our
fallback function to call

23463
24:11:25.869 --> 24:11:30.870
withdraw again. So that will
send our contract more ether

23464
24:11:30.870 --> 24:11:34.870
than it's do before we update
the balance. So let's see what

23465
24:11:34.870 --> 24:11:39.870
this looks like. So in our
fallback here, we'll say if the

23466
24:11:39.870 --> 24:11:46.870
address of reentrant vulnerable
balance is greater than or equal

23467
24:11:46.870 --> 24:11:50.870
to one ether aka we're saying if
there's money left in the

23468
24:11:50.870 --> 24:11:57.870
contract, then rancher
invulnerable dot withdraw. And

23469
24:11:57.870 --> 24:12:02.870
then we'll put to get balanced
function in our attacking

23470
24:12:02.870 --> 24:12:06.870
contract. We're going to attack
reentrant vulnerable by calling

23471
24:12:06.870 --> 24:12:10.870
withdraw. When we get to this
send section, what are we going

23472
24:12:10.870 --> 24:12:13.870
to do, we're going to have our
fallback function trigger

23473
24:12:13.870 --> 24:12:18.870
calling withdraw again. Now when
we call withdraw again, bounces

23474
24:12:18.870 --> 24:12:22.870
a message that sender hasn't
been zeroed out yet. So the

23475
24:12:22.870 --> 24:12:26.870
contract code will go, oh, you
still have some money here.

23476
24:12:26.870 --> 24:12:30.870
Let's go ahead and let's send
you that, which will then again,

23477
24:12:30.870 --> 24:12:32.870
trigger us to call withdraw. And
so we'll just keep calling

23478
24:12:32.870 --> 24:12:36.870
withdraw until we're done. So
let's see what this looks like.

23479
24:12:36.870 --> 24:12:40.870
So we compile this, and then
let's go to deploy, first, let's

23480
24:12:40.870 --> 24:12:45.870
deploy the reentrant vulnerable
contract. Alright, and we can

23481
24:12:45.870 --> 24:12:48.870
have any contract address, you
know, like the one that deployed

23482
24:12:48.870 --> 24:12:54.870
it, we can have a deposit, let's
do, we have a deposit one ether

23483
24:12:54.870 --> 24:12:59.870
deposit. Now we can check the
balances of it. Copy. Paste

23484
24:12:59.870 --> 24:13:07.871
great, is one. So now let's have
a do 10. Deposit, it took the

23485
24:13:07.871 --> 24:13:10.871
balance. And now we have this
much in here. So we have this

23486
24:13:10.871 --> 24:13:13.871
much in here. And if we
withdrew, we withdraw all of it.

23487
24:13:13.871 --> 24:13:19.871
And if we switched accounts, to
somebody else, we hit withdrew.

23488
24:13:19.871 --> 24:13:21.871
Nothing would happen because
that other account doesn't have

23489
24:13:21.871 --> 24:13:25.871
anything, which makes sense. So
there's a lot of money in here,

23490
24:13:25.871 --> 24:13:29.871
right. And if we do get balanced
with the contract, we can see

23491
24:13:29.871 --> 24:13:33.871
how much money it has, right? It
has this much money total. Now

23492
24:13:33.871 --> 24:13:36.871
what we can do on a different
account, let's choose this, this

23493
24:13:36.871 --> 24:13:40.871
brand new account, let's go
ahead and deploy the attack

23494
24:13:40.871 --> 24:13:44.871
contract. And we'll pass it the
reentrant value address as an

23495
24:13:44.871 --> 24:13:50.871
input parameter. So we'll deploy
that. And now what we'll do is

23496
24:13:50.871 --> 24:13:54.871
we'll call attack. And you'll
see even though this contract

23497
24:13:54.871 --> 24:13:58.871
doesn't have anything deposited
in the reentrant vulnerable

23498
24:13:58.871 --> 24:14:02.871
contract, we will still steal
all the funds in here or just

23499
24:14:02.871 --> 24:14:06.871
about all the funds. So right
now hit get balance, and a

23500
24:14:06.871 --> 24:14:09.871
reentrant vulnerable, here's
what it is, get balance a here

23501
24:14:09.871 --> 24:14:13.871
zero, you know, there's the
address, we had attack now, now

23502
24:14:13.871 --> 24:14:17.871
that get bounce, oh, excuse me
in public, and withdrawal should

23503
24:14:17.871 --> 24:14:22.871
be payable as well. Now we'll
pass one ether as an input

23504
24:14:22.871 --> 24:14:24.871
parameter to our attack
function, and we're going to

23505
24:14:24.871 --> 24:14:27.871
deposit just one ether. And then
we're going to withdraw. And

23506
24:14:27.871 --> 24:14:30.871
we're going to keep withdrawing,
because our fallback function is

23507
24:14:30.871 --> 24:14:34.871
going to keep calling withdraw.
And all we had to do was deposit

23508
24:14:34.871 --> 24:14:38.871
one ether, and we're gonna be
able to pull out all 11 that are

23509
24:14:38.871 --> 24:14:39.871
in here.

23510
24:14:39.871 --> 24:14:44.871
So we'll hit attack now.
Transaction went through, the

23511
24:14:44.871 --> 24:14:48.872
new balance of our contract is
12, because the one that we

23512
24:14:48.872 --> 24:14:52.872
deposited and then the 11 that
we stole, and the new balance of

23513
24:14:52.872 --> 24:14:55.872
our old contract is now zero. So
this is known as a reentrant.

23514
24:14:55.872 --> 24:14:59.872
See attack. Basically, since we
call a function in another

23515
24:14:59.872 --> 24:15:03.872
contract in the middle of our
withdraw, we allow code to run

23516
24:15:03.872 --> 24:15:06.872
on a different contract. And the
code that ran runs on this

23517
24:15:06.872 --> 24:15:11.872
contract, recalls withdraw
before balances is set to zero,

23518
24:15:11.872 --> 24:15:14.872
we get to here we call the
fallback function of our other

23519
24:15:14.872 --> 24:15:18.872
code, and it calls withdraw, and
we need to reread withdraw

23520
24:15:18.872 --> 24:15:21.872
before we get to setting
balances a message that sender

23521
24:15:21.872 --> 24:15:24.872
equals zero. So this is an
issue, obviously. And there are

23522
24:15:24.872 --> 24:15:27.872
two ways we can prevent it.
There's the easy way. And then

23523
24:15:27.872 --> 24:15:30.872
the mutex way, I don't wanna say
the hard way, it's just a

23524
24:15:30.872 --> 24:15:33.872
different way. So one of the
things you'll always see in

23525
24:15:33.872 --> 24:15:36.872
security tools is you always
want to call any external

23526
24:15:36.872 --> 24:15:40.872
contract as the last step in
your function, or the last step

23527
24:15:40.872 --> 24:15:44.872
in transaction. And we want to
update bounces to zero before we

23528
24:15:44.872 --> 24:15:48.872
call that external contract,
because of balances of message

23529
24:15:48.872 --> 24:15:53.872
sender is reset to zero before
we call external code, then if

23530
24:15:53.872 --> 24:15:56.872
it were to try to re enter this,
it would hit this require step

23531
24:15:56.872 --> 24:15:59.872
and just cancel out right here
and wouldn't be able to send any

23532
24:15:59.872 --> 24:16:03.872
ether again. So that's the first
step that we can do. The next

23533
24:16:03.872 --> 24:16:06.872
step that we can do is using
something called a mutex lock.

23534
24:16:06.872 --> 24:16:09.872
And this is what open Zeppelin
does with one of the modifiers

23535
24:16:09.872 --> 24:16:16.872
that they have, we can have some
type of a Boolean called locked

23536
24:16:16.872 --> 24:16:21.872
or something and just right at
the top, we can just say require

23537
24:16:21.872 --> 24:16:27.872
not locked. Otherwise, revert.
And then the first thing we do

23538
24:16:27.872 --> 24:16:31.873
in this contract is we can say
locked equals true. And then the

23539
24:16:31.873 --> 24:16:34.873
last thing we do in here is we
say locked equals false. And

23540
24:16:34.873 --> 24:16:40.873
using this lock in here, we only
allow one piece of code to ever

23541
24:16:40.873 --> 24:16:44.873
execute in here at a time and we
only unlock it once the code

23542
24:16:44.873 --> 24:16:48.873
finishes. Now open Zeplin comes
with a reentrancy guard which we

23543
24:16:48.873 --> 24:16:53.873
can use on our code. And it has
a modifier non reentrant which

23544
24:16:53.873 --> 24:16:56.873
does essentially what we were
talking about with our locks it

23545
24:16:56.873 --> 24:17:00.873
creates a variable called status
and changes it to enter whenever

23546
24:17:01.873 --> 24:17:05.873
a function has been entered. It
runs out code, and then changes

23547
24:17:05.873 --> 24:17:08.873
it back to not entered when it's
finishes. And whenever any code

23548
24:17:08.873 --> 24:17:11.873
runs, it just requires that it
is not entered. So if we wanted

23549
24:17:11.873 --> 24:17:20.873
to use this on our code, we can
import at open Zeppelin, slash,

23550
24:17:20.873 --> 24:17:30.873
contracts, slash security, slash
reentrancy. Guard about so we

23551
24:17:30.873 --> 24:17:34.873
can inherit the functions by
saying NFT marketplace is

23552
24:17:34.873 --> 24:17:38.873
reentrancy guard. And then any
function that we're nervous is

23553
24:17:38.873 --> 24:17:43.873
going to have this reentrant see
issue, like maybe by item, for

23554
24:17:43.873 --> 24:17:48.873
example, we would just add the
modifier non reentrant. Just

23555
24:17:48.873 --> 24:17:51.873
like that. And that'll add that
mutex, that locking mechanism

23556
24:17:51.873 --> 24:17:54.873
that we talked about. Now, the
mutex way is a little bit more

23557
24:17:54.873 --> 24:17:56.873
explicit with our security,
right? Because we're saying,

23558
24:17:56.873 --> 24:18:00.873
Hey, this is locked. This is a
non reentrant function. Still a

23559
24:18:00.873 --> 24:18:04.873
best practice, whenever you call
external code, like what we see

23560
24:18:04.873 --> 24:18:08.874
here is you do all of your state
changes before you call an

23561
24:18:08.874 --> 24:18:10.874
external contract. Now, you
might be saying, Oh, that's cool

23562
24:18:10.874 --> 24:18:13.874
at all. But what about how does
this relate to our NF Ts? Well,

23563
24:18:13.874 --> 24:18:16.874
imagine for a second, instead of
message that sender dot call,

23564
24:18:16.874 --> 24:18:21.874
this is, you know, all success
equals, you know, some NF T dot

23565
24:18:21.874 --> 24:18:24.874
transfer from, and then we do
some transfers from stuff in

23566
24:18:24.874 --> 24:18:30.874
here. And instead of doing some
fallback stuff, our NF T has our

23567
24:18:30.874 --> 24:18:35.874
NF T's function transfer from
the similis code to re enter

23568
24:18:35.874 --> 24:18:38.874
into our withdraw. If we have
our withdrawal set up like this,

23569
24:18:38.874 --> 24:18:41.874
since we're still calling an
external contract with NFT. To

23570
24:18:41.874 --> 24:18:45.874
transfer from that transfer from
in that external contract could

23571
24:18:45.874 --> 24:18:48.874
be malicious and try to re enter
our contract. As a best

23572
24:18:48.874 --> 24:18:52.874
practice, you always want to
change your state, before you

23573
24:18:52.874 --> 24:18:57.874
call any external contracts that
you might not have control of, I

23574
24:18:57.874 --> 24:18:59.874
highly recommend playing around
with this a little bit just

23575
24:18:59.874 --> 24:19:02.874
because seeing is believing. And
with that being said, again, all

23576
24:19:02.874 --> 24:19:06.874
the code for this is going to be
available in the GitHub sociated

23577
24:19:06.874 --> 24:19:09.874
with this lesson for this
reentrant vulnerable code. And

23578
24:19:09.874 --> 24:19:15.874
with that, let's go back to our
NFT project.

23579
24:19:15.874 --> 24:19:20.874
Okay, so now we know why we're
doing this safe transfer from at

23580
24:19:20.874 --> 24:19:23.874
the bottom of our function here
at the bottom of our bio,

23581
24:19:23.874 --> 24:19:27.874
because if our safe transfer
function from was a little bit

23582
24:19:27.874 --> 24:19:31.874
higher, maybe what ends up
happening is we send multiple NF

23583
24:19:31.874 --> 24:19:35.874
T's to the wrong address before
we update them. So that's why we

23584
24:19:35.874 --> 24:19:38.874
do that. And we favor push over
Paul. As we said, Here, there's

23585
24:19:38.874 --> 24:19:41.874
a whole lot of these security
tips that you'll learn going on

23586
24:19:41.874 --> 24:19:44.874
through this course and in
solidity. But this is still

23587
24:19:44.874 --> 24:19:48.875
fantastic, right, we have our by
item. And we have our list item

23588
24:19:48.875 --> 24:19:53.875
functions. Let's do a cancel
item now, or cancelled listing.

23589
24:19:53.875 --> 24:19:57.875
So we'll do a function.

23590
24:19:57.875 --> 24:20:04.875
Cancel listing we'll do the NFT
address. And the UN 256 token

23591
24:20:04.875 --> 24:20:11.875
ID. This will be an external
function. One will want to make

23592
24:20:11.875 --> 24:20:14.875
sure only the owner of this
entity can cancel it. So we'll

23593
24:20:14.875 --> 24:20:17.875
say is owner.

23594
24:20:17.875 --> 24:20:24.875
And if T address, token ID
message dot Sen. Want to make

23595
24:20:24.875 --> 24:20:29.875
sure that the NFT is actually
listed. So we'll do is listed

23596
24:20:29.875 --> 24:20:36.875
and ft address, token ID. And
great. Now to cancel this, all

23597
24:20:36.875 --> 24:20:43.875
we're going to do is we're going
to delete s listings NFT address

23598
24:20:43.875 --> 24:20:46.875
token ID, we're just going to
delete that mapping. And then

23599
24:20:46.875 --> 24:20:53.875
we'll emit an event item
cancelled message dot sender and

23600
24:20:53.875 --> 24:20:59.875
if T address and token ID. And
of course, we're going to create

23601
24:20:59.875 --> 24:21:05.875
a new event here. We'll say
event item canceled. And it will

23602
24:21:05.875 --> 24:21:15.875
be an address indexed seller
address. Index NFT address. You

23603
24:21:15.875 --> 24:21:19.875
want to 56 indexed token ID. All
right. Great. That was pretty

23604
24:21:19.875 --> 24:21:24.875
quick. Cancel listening. Boom.
Jack. Done. What's next? Okay,

23605
24:21:24.875 --> 24:21:30.876
let's update our listings. So
we'll do function update listing

23606
24:21:30.876 --> 24:21:37.876
address and if the address you
went to for the sixth token ID

23607
24:21:37.876 --> 24:21:42.876
you went to the six new price
will update the price of this of

23608
24:21:42.876 --> 24:21:51.876
this external we'll make sure
it's listed with is listed

23609
24:21:51.876 --> 24:21:59.876
say is owner do a token ID and
then we'll do message dot

23610
24:21:59.876 --> 24:22:04.876
sender. Now to update our
listing We'll just say s

23611
24:22:04.876 --> 24:22:12.876
underscore listings of NF T
address. At token ID dot price

23612
24:22:12.876 --> 24:22:16.876
equals the new price that we're
giving it. And then we'll admit,

23613
24:22:16.876 --> 24:22:20.876
we can omit like item updated.
But we can also just omit an

23614
24:22:20.876 --> 24:22:27.876
item listed with MSG dot sender
NFT address, token ID, new

23615
24:22:27.876 --> 24:22:31.876
price. Because essentially, by
updating it, we're essentially

23616
24:22:31.876 --> 24:22:34.876
just relisting it with a new
price. So we're just going to do

23617
24:22:34.876 --> 24:22:38.876
an item listed event, we only
have one more function to do, we

23618
24:22:38.876 --> 24:22:43.876
need to do a withdraw proceeds.
So we'll say function, withdraw

23619
24:22:43.876 --> 24:22:49.876
proceeds to get all the payments
for all of our entities. So

23620
24:22:49.876 --> 24:22:52.876
we'll get the the proceeds by
doing new activity six proceeds

23621
24:22:52.876 --> 24:22:57.876
equals s underscore proceeds of
MSG dot sender, right, we're

23622
24:22:57.876 --> 24:23:01.876
getting all the payments that
were collected in by item, and

23623
24:23:01.876 --> 24:23:07.876
we're saying if proceeds is less
than or equal to zero, then

23624
24:23:07.876 --> 24:23:12.877
we're going to revert with no
proceeds. And we're going to

23625
24:23:12.877 --> 24:23:16.877
make this a NFT. Marketplace
underscore underscore no

23626
24:23:16.877 --> 24:23:23.877
proceeds. Excel create at the
top error empty marketplace no

23627
24:23:23.877 --> 24:23:30.877
proceeds being otherwise, we'll
say s underscore proceeds of MSG

23628
24:23:30.877 --> 24:23:35.877
dot sender equals zero. So we're
going to reset the proceeds to

23629
24:23:35.877 --> 24:23:37.877
zero, right, we're going to do
this before we send any

23630
24:23:37.877 --> 24:23:40.877
proceeds. And then we're going
to do our traditional way we

23631
24:23:40.877 --> 24:23:43.877
send payments, so bool success

23632
24:23:43.877 --> 24:23:54.877
equals payable, message dot
sender call value is going to be

23633
24:23:54.877 --> 24:24:01.877
proceeds all blank here. And
then we could do require, you

23634
24:24:01.877 --> 24:24:05.877
know, we could do require
success, or we could say

23635
24:24:05.877 --> 24:24:15.877
if not success, reverts revert
with Aleksey marketplace,

23636
24:24:15.877 --> 24:24:19.877
transfer failed. And then we'll
make this a new air, air NFT

23637
24:24:19.877 --> 24:24:24.877
marketplace transfer failed. Put
a semicolon here. And we're

23638
24:24:24.877 --> 24:24:29.877
looking pretty good. Now we even
have a way to withdraw. So we

23639
24:24:29.877 --> 24:24:33.877
have our five functions here.
Awesome. Let's just create a

23640
24:24:33.877 --> 24:24:38.877
couple of getters. So maybe
we'll do we even copy this.

23641
24:24:38.877 --> 24:24:43.877
Paste it here we'll say getter
functions like so. And we'll do

23642
24:24:43.877 --> 24:24:47.877
function maybe we'll do get
listing. Take an address, NF T

23643
24:24:47.877 --> 24:24:56.878
address, the utilities X token
ID, external view, which returns

23644
24:24:56.878 --> 24:25:02.878
a listing in memory. And we'll
say return s underscore listings

23645
24:25:02.878 --> 24:25:12.878
of NF T address token Id like
so. And also function, get

23646
24:25:12.878 --> 24:25:19.878
proceeds of address seller,
external view returns, you went

23647
24:25:19.878 --> 24:25:26.878
to the desex return s underscore
proceeds of the seller. So we'll

23648
24:25:26.878 --> 24:25:30.878
get how much money somebody is
owed. And then any listings and

23649
24:25:30.878 --> 24:25:34.878
let's run a little compile here,
yarn, or hit Compile or hh

23650
24:25:34.878 --> 24:25:37.878
compile just to see where we
messed up. Oh, we did a mess up.

23651
24:25:37.878 --> 24:25:42.878
Wow, that's great. And now,
guess what? You have

23652
24:25:42.878 --> 24:25:47.878
successfully created a
minimalistic NFT marketplace

23653
24:25:47.878 --> 24:25:52.878
that's completely decentralized.
That is pretty wild. And that is

23654
24:25:52.878 --> 24:25:55.878
incredibly powerful. And you
should feel really excited for

23655
24:25:55.878 --> 24:25:59.878
yourself. Very cool, very good
job. But you know, we're not

23656
24:25:59.878 --> 24:26:02.878
done, we got to write some
deploys and some tests. So let's

23657
24:26:02.878 --> 24:26:05.878
jump into that. Now since we've
done this a couple of times, I

23658
24:26:05.878 --> 24:26:08.878
actually encourage you to pause
the video here and try writing

23659
24:26:08.878 --> 24:26:12.878
your own deploy scripts and your
own tests. And then go ahead and

23660
24:26:12.878 --> 24:26:15.878
come back and follow along with
us and see if you did it

23661
24:26:15.878 --> 24:26:21.878
correctly, we're going to create
a new folder called deploy. Of

23662
24:26:21.878 --> 24:26:26.878
course, we already have the hard
hat deploy in our hard hat

23663
24:26:26.878 --> 24:26:29.879
config. So we know we're good to
go here. So let's go ahead and

23664
24:26:29.879 --> 24:26:35.879
create a one. Deploy NFT
marketplace.js. Now once again,

23665
24:26:35.879 --> 24:26:38.879
you've seen a lot of this
before, so we're going to spare

23666
24:26:38.879 --> 24:26:49.879
the details do const network
equals require hard hat to

23667
24:26:49.879 --> 24:26:55.879
constant development chains,
equal equals require dot dot

23668
24:26:55.879 --> 24:27:00.879
slash help our hard hats config,
which we should have let's see.

23669
24:27:00.879 --> 24:27:02.879
Do we copy paste it over? No.
Okay, so we didn't copy paste

23670
24:27:02.879 --> 24:27:05.879
over Are helper Hardhead config
from the last project, let's go

23671
24:27:05.879 --> 24:27:08.879
ahead and grab it. Or we can
grab it from the smart contract

23672
24:27:08.879 --> 24:27:12.879
lottery and paste that in here.
And we really only need this

23673
24:27:12.879 --> 24:27:16.879
file for the development chains
here. Right for hard hat and

23674
24:27:16.879 --> 24:27:18.879
localhost, we're going to grab
the development chains from

23675
24:27:18.879 --> 24:27:25.879
that. And then we'll also grab
const. Verify, equals require,

23676
24:27:25.879 --> 24:27:29.879
get this from utils. Verify,
right? Do we have utils, we have

23677
24:27:29.879 --> 24:27:35.879
verify. Fantastic. Now we'll do
module that exports equals

23678
24:27:35.879 --> 24:27:41.879
async. an async function where
it's gonna take get named

23679
24:27:41.879 --> 24:27:49.879
accounts and deployments. From
the hard hat input parameter,

23680
24:27:49.879 --> 24:27:53.879
and then we're gonna do const.
Deploy comma log equals

23681
24:27:53.879 --> 24:28:00.879
deployments. And then const,
Deployer equals await, get named

23682
24:28:00.879 --> 24:28:04.879
accounts. Which, of course,
we're getting from our heart

23683
24:28:04.879 --> 24:28:08.880
head dot config. We have named
accounts, we have a Deployer.

23684
24:28:08.880 --> 24:28:11.880
And we have a player or whatever
you have in here from our last

23685
24:28:11.880 --> 24:28:14.880
project. And now does our entity
marketplace have a constructor?

23686
24:28:14.880 --> 24:28:18.880
Construct? Nope, no constructor.
So we know args is going to be

23687
24:28:18.880 --> 24:28:25.880
blank. And then we can say const
NFT. Marketplace equals await,

23688
24:28:25.880 --> 24:28:34.880
deploy. And if T marketplace,
say from Deployer, args is going

23689
24:28:34.880 --> 24:28:42.880
to be args. Log will be true.
And then wait confirmations will

23690
24:28:42.880 --> 24:28:50.880
be network dot config dot wait
confirmations or one, two, this

23691
24:28:50.880 --> 24:28:53.880
is going to be block on for
patients, we'll go to the

23692
24:28:53.880 --> 24:28:57.880
config, just make sure that
those are in here. I'm sorry, I

23693
24:28:57.880 --> 24:29:01.880
didn't add them in here. So
we'll do block confirmations is

23694
24:29:01.880 --> 24:29:03.880
going to be six

23695
24:29:03.880 --> 24:29:10.880
for all of our networks. So I
actually grabbed this not from

23696
24:29:10.880 --> 24:29:13.880
the last project, it looks like
I grabbed this from the hard hat

23697
24:29:13.880 --> 24:29:15.880
starter kit. So I'm just going
to add those block confirmations

23698
24:29:15.880 --> 24:29:18.880
in there. And now we're good to
go. Now we're gonna say if we're

23699
24:29:18.880 --> 24:29:23.880
not on a development chain, not
development chains that includes

23700
24:29:23.880 --> 24:29:32.880
network dot name, and process
study and be done ether scan API

23701
24:29:32.880 --> 24:29:39.880
key, then we're gonna go ahead,
we'll do log verifying. And then

23702
24:29:39.880 --> 24:29:45.880
we'll do a weight verify. And if
the markets place dot address

23703
24:29:45.880 --> 24:29:50.881
with arcs, and then we'll do
like log a whole bunch of

23704
24:29:50.881 --> 24:29:56.881
hyphens here. And then finally,
module that exports dot tags

23705
24:29:56.881 --> 24:30:04.881
equals all and then NFT Mar good
place. And we can test this

23706
24:30:04.881 --> 24:30:09.881
deploy function with yarn
Hardhead deploy. Tada, we did

23707
24:30:09.881 --> 24:30:12.881
it. Great. So now we have the
deploy function, we can verify

23708
24:30:12.881 --> 24:30:15.881
we have our contract, what else
are we probably gonna need to

23709
24:30:15.881 --> 24:30:18.881
do. Since this is an NFT
marketplace, we're probably

23710
24:30:18.881 --> 24:30:22.881
going to need some NF Ts. So
what we can do is in our

23711
24:30:22.881 --> 24:30:26.881
contracts, and we'll create a
new folder for tests got a new

23712
24:30:26.881 --> 24:30:32.881
file in here called Basic NF T
dot soul. And in here, we can

23713
24:30:32.881 --> 24:30:36.881
add that basic NF T from our
last project. Or you can just go

23714
24:30:36.881 --> 24:30:39.881
to my or you can just go to the
GitHub repo associated with this

23715
24:30:40.881 --> 24:30:44.881
course, go to contracts, test,
basic NF t, and then just copy

23716
24:30:44.881 --> 24:30:50.881
paste. That works too. So this
basic NF t that we're using is

23717
24:30:50.881 --> 24:30:55.881
just pointing to the pug as the
basic NF T for us to use just to

23718
24:30:55.881 --> 24:30:59.881
test this out. So now that we
have a basic NFT we're gonna

23719
24:30:59.881 --> 24:31:05.881
need to create new file, oh to
deploy basic NF T dot j s, and

23720
24:31:05.881 --> 24:31:08.881
we'll borrow a lot of the
boilerplate from over here. So

23721
24:31:08.881 --> 24:31:14.881
we'll copy all of this actually
paste it in. We'll say const

23722
24:31:14.881 --> 24:31:20.881
args equals blank, and we'll say
const basic NF t equals await

23723
24:31:20.881 --> 24:31:30.882
deploy basic NF T. From
Deployer. args is going to be

23724
24:31:30.882 --> 24:31:36.882
args. Log is going to be true
weight con confirmations is

23725
24:31:36.882 --> 24:31:44.882
going to be network dot config
dot block confirmations or one

23726
24:31:44.882 --> 24:31:50.882
and then we'll verify this with
if not develop meant chains dot

23727
24:31:50.882 --> 24:31:59.882
includes network dot name and
process dot EMV that ether scan

23728
24:31:59.882 --> 24:32:07.882
API key that will say log or To
find dot A dot await there if I

23729
24:32:07.882 --> 24:32:14.882
basic NFT dot address, and arcs,
module dot exports dot tags

23730
24:32:14.882 --> 24:32:19.882
equals all, and basic NFT. And
we can test both of these with

23731
24:32:19.882 --> 24:32:25.882
yarn, art had deploy. And
fantastic. Both of these have

23732
24:32:25.882 --> 24:32:28.882
been deployed. Again, you don't
have to pause. But it is a good

23733
24:32:28.882 --> 24:32:32.882
way to really hone in to really
sharpen those skills on doing

23734
24:32:32.882 --> 24:32:36.882
all this. And repetition is the
mother of all skill. So

23735
24:32:36.882 --> 24:32:39.882
repeating this stuff yourself
and thinking through these

23736
24:32:39.882 --> 24:32:42.882
problems yourself and trying to
code these things yourself, are

23737
24:32:42.882 --> 24:32:47.882
really what's going to make you
successful at this. All right,

23738
24:32:47.882 --> 24:32:51.882
awesome. Now that we have our
deploy Betson, it's time to

23739
24:32:51.882 --> 24:32:54.882
write some tests. Now, if you go
to the GitHub repo associated

23740
24:32:54.882 --> 24:32:57.882
with this course, and you go to
the test folder, the tests and

23741
24:32:57.882 --> 24:33:00.882
here are some of the robust,
we've actually written out of

23742
24:33:00.882 --> 24:33:03.882
all of our projects, there's a
lot of tests in here. Now,

23743
24:33:03.882 --> 24:33:06.882
pretty much everything in here,
we've already learned about and

23744
24:33:06.882 --> 24:33:09.883
you already know how to do you
have the ability to do it. So

23745
24:33:09.883 --> 24:33:11.883
I'm just going to go ahead and
get you started off, and we're

23746
24:33:11.883 --> 24:33:14.883
going to write one test
together. And then I highly

23747
24:33:14.883 --> 24:33:17.883
recommend you going back in, you
tried to write some tests

23748
24:33:17.883 --> 24:33:20.883
yourself, to get that code
coverage to get that test

23749
24:33:20.883 --> 24:33:24.883
coverage to be 100 percent. So let's go
ahead, we'll write one test

23750
24:33:24.883 --> 24:33:27.883
together, then you should pause
this video and try to write some

23751
24:33:27.883 --> 24:33:30.883
tests yourself. When you're done
writing tests and you think

23752
24:33:30.883 --> 24:33:33.883
you've hit 100 percent, feel free to
compare back to the test that we

23753
24:33:34.883 --> 24:33:41.883
wrote. So let's create a new
folder called tests. Test. And

23754
24:33:41.883 --> 24:33:44.883
in here, we'll do a new one
called unit. And if you want to

23755
24:33:44.883 --> 24:33:48.883
write staging tests later on,
you absolutely can we will not.

23756
24:33:48.883 --> 24:33:55.883
We'll create a new file in here
called NFT marketplace.test.js.

23757
24:33:55.883 --> 24:34:00.883
And we'll start some tests. So
we'll do const.

23758
24:34:00.883 --> 24:34:11.883
cert, expect equals require Chai
const. Network deployments,

23759
24:34:11.883 --> 24:34:21.883
ethers, equals require hard hat
const development chains equals

23760
24:34:21.883 --> 24:34:26.883
require dot dot slash dot dot
slash helper, hothead config.

23761
24:34:26.883 --> 24:34:29.883
And we're gonna do the same
setup we've been doing. We'll

23762
24:34:29.883 --> 24:34:38.883
say bang development chains dot
includes network dot name,

23763
24:34:38.883 --> 24:34:48.884
question mark, describe dot
skip. Else describe. And if NF T

23764
24:34:48.884 --> 24:34:55.884
marketplace tests, comma async
function, excuse me, this is

23765
24:34:55.884 --> 24:34:59.884
just gonna be a function.
Scrabble oval is just a

23766
24:34:59.884 --> 24:35:03.884
function, not an async function,
like so. Great. Now let's get

23767
24:35:03.884 --> 24:35:08.884
some variables and do a before
each. So we'll say NF T

23768
24:35:08.884 --> 24:35:14.884
marketplace, basic NF T, we'll
create a constant price. So

23769
24:35:14.884 --> 24:35:17.884
we're just always set the price
of all of our NF T's to the same

23770
24:35:17.884 --> 24:35:22.884
thing. This will be ethers dot
utils dot parse

23771
24:35:22.884 --> 24:35:31.884
ether 0.1. We'll say const token
ID for now will always be zero.

23772
24:35:31.884 --> 24:35:38.884
And then we'll do before each
will be an async function.

23773
24:35:38.884 --> 24:35:45.884
And we'll get out and we'll also
get Deployer. Say deployer

23774
24:35:45.884 --> 24:35:50.884
equals await, get named
accounts. We're gonna need to

23775
24:35:50.884 --> 24:35:53.884
grab getting into accounts from
hard hat as well wrap this all

23776
24:35:53.884 --> 24:35:58.884
up dot deployer Excel and then
we'll also in our heart

23777
24:35:58.884 --> 24:36:02.884
hat.config.js. Under get named
accounts, we also have something

23778
24:36:02.884 --> 24:36:05.884
called player. Now I didn't talk
about this too much. But we're

23779
24:36:05.884 --> 24:36:09.884
going to have a second account
which is defaulted to the first

23780
24:36:09.884 --> 24:36:15.884
index, right? So we can do at
the top to come up player. And

23781
24:36:15.884 --> 24:36:23.884
we can say player equals await
get named accounts dot player.

23782
24:36:23.884 --> 24:36:26.884
Now we have a player and a
deployer account will do await

23783
24:36:26.884 --> 24:36:32.885
deployments, that fixture. All
will just deploy all of those

23784
24:36:32.885 --> 24:36:37.885
contracts will run through
everything in our deploy folder.

23785
24:36:37.885 --> 24:36:41.885
We'll get our NFT marketplace.
We'll say NFT marketplace equals

23786
24:36:41.885 --> 24:36:49.885
await ethers dot get contract
and ft. marketplace. And then

23787
24:36:49.885 --> 24:36:57.885
we'll do basic NF t equals await
ethers dot get contract. Basic

23788
24:36:57.885 --> 24:37:02.885
NF T. The way ethers dot get
contract works is it defaults to

23789
24:37:02.885 --> 24:37:06.885
grab thing, whatever account is
that account zero, which right

23790
24:37:06.885 --> 24:37:09.885
now is our Deployer. If we want
to call a function on NFT

23791
24:37:09.885 --> 24:37:12.885
marketplace, with the player
being the one calling the

23792
24:37:12.885 --> 24:37:18.885
function, we would have to say,
entity marketplace equals await

23793
24:37:18.885 --> 24:37:25.885
and empty marketplace dot
connect player like this. And

23794
24:37:25.885 --> 24:37:30.885
now whenever we call a function,
we would use the player instead

23795
24:37:30.885 --> 24:37:33.885
of the Deployer. Sometimes what
I like to do and you'll see this

23796
24:37:33.885 --> 24:37:39.885
in my code, is I'll do let NFT
marketplace contract. And then

23797
24:37:39.885 --> 24:37:45.885
let NFT marketplace, and then
I'll do NFT marketplace contract

23798
24:37:45.885 --> 24:37:49.885
equals await ethers dot
contract. And then I'll connect

23799
24:37:49.885 --> 24:37:53.885
and set that to the NF T
marketplace. Yes, we can do, we

23800
24:37:53.885 --> 24:37:57.885
can automatically choose who to
connect by placing whoever want

23801
24:37:57.885 --> 24:38:00.885
to connect to write and get
contract. But sometimes it's

23802
24:38:00.885 --> 24:38:02.885
really nice to be kind of
explicit. So it's really up to

23803
24:38:02.885 --> 24:38:06.885
you. I'm going to undo all that,
I just want to re show you that

23804
24:38:06.885 --> 24:38:08.885
to make sure that you knew
that's how you kind of switch

23805
24:38:08.885 --> 24:38:10.886
around with the different
accounts and the different

23806
24:38:10.886 --> 24:38:13.886
users. Now that we have an NF T,
we're probably going to need to

23807
24:38:13.886 --> 24:38:16.886
mint the NFT so that we can
actually place it on the market.

23808
24:38:16.886 --> 24:38:20.886
So we'll do await basic NF T dot
meant NF t, and then we'll

23809
24:38:20.886 --> 24:38:24.886
approve to send it on to the
marketplace. So we'll do a wait.

23810
24:38:24.886 --> 24:38:33.886
Basic NF T dot approve and T
market place dot address token

23811
24:38:33.886 --> 24:38:38.886
ID, which is going to be zero.
And just like that, the NOC

23812
24:38:38.886 --> 24:38:41.886
marketplace remember, it can't
call approve, because it doesn't

23813
24:38:41.886 --> 24:38:45.886
own that NF t. So we need to
have the Deployer. Call

23814
24:38:45.886 --> 24:38:49.886
approved, right. And remember,
since we're not we need to put

23815
24:38:49.886 --> 24:38:53.886
basic NF T in here. Since we
didn't tell ethers who to

23816
24:38:53.886 --> 24:38:56.886
connect this to it just
automatically connected it to

23817
24:38:56.886 --> 24:38:58.886
our Deployer because that's
what's at account zero. So it's

23818
24:38:58.886 --> 24:39:03.886
the deployer calling minting it
and then the deployer approving

23819
24:39:03.886 --> 24:39:06.886
to send it to the marketplace.
Only after this approved

23820
24:39:06.886 --> 24:39:10.886
function has been called canned
the NFT marketplace called

23821
24:39:10.886 --> 24:39:14.886
transfer from all those NF T's.
Now we're just going to do one

23822
24:39:14.886 --> 24:39:20.886
test here. We're gonna say it
lists and can be bought. That's

23823
24:39:20.886 --> 24:39:24.886
it, and this will be an async
function. And we're just gonna

23824
24:39:24.886 --> 24:39:31.886
list the NFT and buy a weight
entity marketplace.if We go to

23825
24:39:31.886 --> 24:39:33.886
our energy marketplace, what are
we doing, we're listing it

23826
24:39:33.886 --> 24:39:36.886
right, we want to list the item
or with the address token ID and

23827
24:39:36.886 --> 24:39:44.886
the price. So we'll do dot list
item. Basic NF T dot address,

23828
24:39:44.886 --> 24:39:47.886
token ID is zero, which we've
defined right here. And then

23829
24:39:47.886 --> 24:39:51.887
price we've hard coded up here
as well. So we're listing it. So

23830
24:39:51.887 --> 24:39:55.887
the deployer owns the NF T, the
player is now listing it, now we

23831
24:39:55.887 --> 24:39:59.887
want to buy it, let's have the
player be the one to buy it. So

23832
24:39:59.887 --> 24:40:02.887
what we're going to do is we're
going to have to connect the

23833
24:40:02.887 --> 24:40:07.887
player to the NFT marketplace.
So we can say const player

23834
24:40:07.887 --> 24:40:13.887
connected NF T, marketplace
equals and ft marketplace dot

23835
24:40:13.887 --> 24:40:19.887
Connect. Player. And then we can
buy the item by saying a weight

23836
24:40:19.887 --> 24:40:24.887
player connected and ft
marketplace.by item. It'll be

23837
24:40:24.887 --> 24:40:27.887
the basic and if we look back at
the end of the marketplace, what

23838
24:40:27.887 --> 24:40:31.887
does buy item need, needs the
NFT address and the token ID. So

23839
24:40:31.887 --> 24:40:35.887
basic NF t that address

23840
24:40:35.887 --> 24:40:39.887
and then the token ID and after
this bot, we should check to see

23841
24:40:39.887 --> 24:40:43.887
that the player actually does
indeed own that NF team. So we

23842
24:40:43.887 --> 24:40:47.887
can say const new owner and we
check to see if that owner is

23843
24:40:47.887 --> 24:40:52.887
indeed updated. We can say basic
NFT dot owner of because NF T's

23844
24:40:52.887 --> 24:41:01.887
have an owner of function, token
ID and then we also want to see

23845
24:41:01.887 --> 24:41:04.887
that the deployer actually is
going to get paid. So we can say

23846
24:41:04.887 --> 24:41:08.887
await and if T marketplace dot
get

23847
24:41:08.887 --> 24:41:17.887
proceeds of Deployer. So now we
can do assert new owner dot two

23848
24:41:17.887 --> 24:41:29.888
string equals player and we can
assert deployer proceeds.to

23849
24:41:29.888 --> 24:41:35.888
string equals price.to string
because they should have been

23850
24:41:35.888 --> 24:41:38.888
paid that price. And that's
right, it's actually a little

23851
24:41:38.888 --> 24:41:41.888
bit easier. instead of grabbing
players from getting named

23852
24:41:41.888 --> 24:41:43.888
accounts. It's a little bit
easier just to grab it right

23853
24:41:43.888 --> 24:41:49.888
from ethers. So we'll do const
accounts equals await

23854
24:41:49.888 --> 24:41:56.888
get signers. And then we'll save
player equals accounts of one

23855
24:41:56.888 --> 24:41:59.888
just because when we connect
it's expecting it type of

23856
24:41:59.888 --> 24:42:02.888
account and then the the get
named account is a different

23857
24:42:02.888 --> 24:42:04.888
type. So Oh, it's just a little
bit easier to actually connect

23858
24:42:04.888 --> 24:42:07.888
like this. So now we'll connect
to the player like so just know

23859
24:42:07.888 --> 24:42:11.888
that player and deployer are now
different types. So you'll see a

23860
24:42:11.888 --> 24:42:15.888
little bit differences there. To
me, this is ethers that gets

23861
24:42:15.888 --> 24:42:18.888
signers. And then when we buy
the item, we're of course gonna

23862
24:42:18.888 --> 24:42:23.888
have to pass a value, it's gonna
be price, of course, we're going

23863
24:42:23.888 --> 24:42:26.888
to need to pay the price of the
NFT. And then of course, this

23864
24:42:26.888 --> 24:42:29.888
needs to be player dot address.
And that's the difference right

23865
24:42:29.888 --> 24:42:31.888
now we got to do player that
address whenever we want the

23866
24:42:31.888 --> 24:42:34.888
address of one of the ethers
accounts. And then this new

23867
24:42:34.888 --> 24:42:37.888
owner, of course, should be in a
wait. And now we can run this

23868
24:42:37.888 --> 24:42:47.888
all. In Tada, we see things
pass. So our NFT marketplace is

23869
24:42:47.888 --> 24:42:52.888
able to facilitate the buying
and selling of an NF T with

23870
24:42:52.888 --> 24:42:56.888
arbitrary humans. This is
fantastic. So we just ran the

23871
24:42:56.888 --> 24:42:58.888
single test to show a little bit
of the oddities when working

23872
24:42:58.888 --> 24:43:03.888
with NF T's and some different
accounts. But 100 percent If you feel

23873
24:43:03.888 --> 24:43:08.888
up for the challenge, take this
time, pause this video and try

23874
24:43:08.888 --> 24:43:11.889
to write some tests. Remember,
the goal here is for us to do

23875
24:43:11.889 --> 24:43:16.889
yarn hardhat coverage, and see
what our coverage is and try to

23876
24:43:16.889 --> 24:43:22.889
get it to be 100 percent coverage. If
we run it right now, we'll see

23877
24:43:22.889 --> 24:43:26.889
Oh, my goodness, we are missing
a lot of coverage. Here, we have

23878
24:43:26.889 --> 24:43:29.889
a ton of uncovered lines, on top
of uncovered functions,

23879
24:43:29.889 --> 24:43:32.889
branches, statements, etc. Try
to write some tests to get this

23880
24:43:32.889 --> 24:43:41.889
to 100 percent and then come back.
Okay, welcome back. Hopefully

23881
24:43:41.889 --> 24:43:44.889
now you've written some tests.
And when you run your tests, you

23882
24:43:44.889 --> 24:43:47.889
can get some of them, I look
like this, right. And these are

23883
24:43:47.889 --> 24:43:49.889
my tests, these are the tests
that I wrote, you could do more

23884
24:43:49.889 --> 24:43:51.889
you could do last. And let's
see, when I run yarn Hardhead

23885
24:43:51.889 --> 24:43:55.889
coverage, I even missed some
lines. And I could I could test

23886
24:43:55.889 --> 24:43:58.889
a little bit more. So make your
tests even better than the ones

23887
24:43:58.889 --> 24:44:00.889
that I made. So these are the
tests from the GitHub repo

23888
24:44:00.889 --> 24:44:03.889
associated with this. Now that
we've written some tests here,

23889
24:44:03.889 --> 24:44:06.889
let's just write a couple of
scripts. And the reason we're

23890
24:44:06.889 --> 24:44:08.889
gonna write a couple of scripts
is we're gonna need these a

23891
24:44:08.889 --> 24:44:12.889
little bit later. So we'll write
some scripts to mint, some

23892
24:44:12.889 --> 24:44:15.889
amount of teased by some NF T's
etc. And we'll need this to

23893
24:44:15.889 --> 24:44:19.889
fiddle around and play on the
front end a little bit later. So

23894
24:44:19.889 --> 24:44:23.889
to create a script, again, we've
done this perform, let's do a

23895
24:44:23.889 --> 24:44:29.889
script called mint, and list dot
j s. And this will be to mint at

23896
24:44:29.889 --> 24:44:34.889
NFT. And then immediately listed
on the marketplace. So let's

23897
24:44:34.889 --> 24:44:40.889
create an async function called
mint, and list. And down below,

23898
24:44:40.889 --> 24:44:42.889
we're going to call mint and
list I'm going to copy paste

23899
24:44:42.889 --> 24:44:45.889
with that same script thing that
we've been doing. Obviously,

23900
24:44:45.889 --> 24:44:48.889
instead of Maine, though, we're
calling this mountain list. Now

23901
24:44:48.889 --> 24:44:52.890
in this mountain list, where
it's a constant, NFT mark, and

23902
24:44:52.890 --> 24:45:01.890
of tea market, place equals
await ethers dot get contract.

23903
24:45:01.890 --> 24:45:06.890
And ft marketplace. And right
we're going to import ethers

23904
24:45:06.890 --> 24:45:09.890
from hard hat. And then we'll do
we'll grab basic NF t. So we'll

23905
24:45:09.890 --> 24:45:15.890
say const. Basic kind of T
equals await ethers dot get

23906
24:45:15.890 --> 24:45:21.890
contract. Basic NF t. And then
first we'll mint a basic NF t.

23907
24:45:22.890 --> 24:45:27.890
So we'll do console dot log,
maintained at the top. And we'll

23908
24:45:27.890 --> 24:45:32.890
do a weight or actual we'll say
const. Mint, TX equals await

23909
24:45:32.890 --> 24:45:39.890
basic NF T dot mint NF t. And
then we'll do await min TX dot

23910
24:45:39.890 --> 24:45:44.890
Wait, wait one block. And
actually we'll say const. Mint

23911
24:45:44.890 --> 24:45:50.890
TX receipt. So that equals that.
And in this receipt, here's

23912
24:45:50.890 --> 24:45:53.890
another reason why events are so
good. When we met this NFT.

23913
24:45:53.890 --> 24:45:58.890
We're omitting the token ID in
an event in this document ID

23914
24:45:58.890 --> 24:46:08.890
event. So we could say const
token ID equals mint TX receipt

23915
24:46:08.890 --> 24:46:14.890
dot events of zero. That args
dot token Id like that. And now

23916
24:46:14.890 --> 24:46:17.890
we have the token ID. And now
that we have the token ID and

23917
24:46:17.890 --> 24:46:21.890
the basic NFT. minted we can now
call on our NFT marketplace list

23918
24:46:21.890 --> 24:46:27.890
item. So now we'll say console
dot log. Approving NFT right,

23919
24:46:27.890 --> 24:46:29.891
it's gonna be real similar to
our tests here. I'm gonna say

23920
24:46:29.891 --> 24:46:36.891
const approval TX equals await
basic NFT data prove

23921
24:46:36.891 --> 24:46:42.891
NFT marketplace dot address
token ID and then we'll do a

23922
24:46:42.891 --> 24:46:49.891
weight approved TX dot wait one
and we'll do console dot log

23923
24:46:49.891 --> 24:46:54.891
listing NF t.at that and then
we'll do const TX equals await

23924
24:46:54.891 --> 24:47:00.891
and if T market market place
that list item and we'll do NFT

23925
24:47:00.891 --> 24:47:07.891
marketplace that address So can
Id do await TX dot wait one,

23926
24:47:07.891 --> 24:47:14.891
console dot log listed and cool.
And we can try this out by

23927
24:47:14.891 --> 24:47:17.891
running yarn hardhat node, which
is going to run through our

23928
24:47:17.891 --> 24:47:19.891
deploy scripts, right, it's
going to run to these deployed

23929
24:47:19.891 --> 24:47:23.891
scripts here. And then in a new
terminal, we'll run our script,

23930
24:47:23.891 --> 24:47:30.891
yarn hard hat, run scripts meant
and list dash dash network

23931
24:47:30.891 --> 24:47:34.891
localhost. And we missed an
argument, oh, we need a price as

23932
24:47:34.891 --> 24:47:39.891
well to list our entity. So
we'll create a constant price

23933
24:47:39.891 --> 24:47:49.891
equals and we'll say ethers dot
utils dot parse, ether 0.1. And

23934
24:47:49.891 --> 24:47:54.891
we'll pass the price and to the
list item. So oops, and sorry,

23935
24:47:54.891 --> 24:47:58.891
it's not the marketplace that
we're listing, the basic NF t

23936
24:47:58.891 --> 24:48:02.891
that we're listing, of course,
so run that again. And Bada

23937
24:48:02.891 --> 24:48:06.891
bing, bada boom, got some listed
events. And we can see here,

23938
24:48:06.891 --> 24:48:09.891
we're doing some listing and
awesome. So now we have a

23939
24:48:09.891 --> 24:48:12.892
script. Alright, so now that we
have a script, and we're going

23940
24:48:12.892 --> 24:48:14.892
to be writing a couple other
scripts a little bit later, we

23941
24:48:14.892 --> 24:48:19.892
essentially have a really solid
repo here are our totally

23942
24:48:19.892 --> 24:48:23.892
decentralized, NFT marketplace,
this is absolutely massive, and

23943
24:48:23.892 --> 24:48:31.892
you should be incredibly,
incredibly proud of yourself.

23944
24:48:31.892 --> 24:48:34.892
Now, of course, this is all
code. And people can interact

23945
24:48:34.892 --> 24:48:38.892
with this, if they're software
developers, which is great. But

23946
24:48:38.892 --> 24:48:42.892
we're going to want to allow
anybody to be able to interact

23947
24:48:42.892 --> 24:48:46.892
and list their own NF t's on our
marketplace. So what are we

23948
24:48:46.892 --> 24:48:50.892
going to do? Well, we're going
to want to build a front end for

23949
24:48:50.892 --> 24:48:53.892
this. And now we're gonna get
into the second part of this

23950
24:48:53.892 --> 24:48:58.892
lesson. So on lesson 15, we just
finished the backend. Now we're

23951
24:48:58.892 --> 24:49:00.892
gonna move on to the front end,
we're gonna start with this

23952
24:49:00.892 --> 24:49:05.892
morass code. The code for both
of these is pretty much nearly

23953
24:49:05.892 --> 24:49:07.892
identical. But we're going to
start with Morales, and we're

23954
24:49:07.892 --> 24:49:09.892
going to teach you how to do
both of these. And we're going

23955
24:49:09.892 --> 24:49:11.892
to teach you the difference
between the Morales and the

23956
24:49:11.892 --> 24:49:14.892
MoGraph. And kind of why we're
even using them in the first

23957
24:49:14.892 --> 24:49:17.892
place, we're going to start with
Morales. So if you want to

23958
24:49:17.892 --> 24:49:20.892
follow along with this next
section, all the code we're

23959
24:49:20.892 --> 24:49:23.892
going to be working with, is
going to be in here. So you

23960
24:49:23.892 --> 24:49:27.892
excited, I hope you are because
this is going to be a phenomenal

23961
24:49:27.892 --> 24:49:30.892
session, we are about to build
one of the most sophisticated

23962
24:49:30.892 --> 24:49:34.892
front ends that we can using the
tools that we have. And like I

23963
24:49:34.892 --> 24:49:36.892
said, we showed you a little bit
earlier what this is going to

23964
24:49:36.892 --> 24:49:39.892
look like. So let's do a quick
refresher here. So here's what

23965
24:49:39.892 --> 24:49:42.892
our front end is going to look
like. But what we can do is we

23966
24:49:42.892 --> 24:49:45.892
can connect with our little
connect button, we hit Metamask

23967
24:49:45.892 --> 24:49:48.892
Metamask pops up, we'll go ahead
and connect. And now that we're

23968
24:49:48.892 --> 24:49:53.893
connected, we can see the
different NF T's in here. And if

23969
24:49:53.893 --> 24:49:57.893
we're on an address that's owned
by us, it will say owned by you.

23970
24:49:57.893 --> 24:50:01.893
And if we switch addresses, are
you I will go ahead and update,

23971
24:50:01.893 --> 24:50:04.893
connect there. And now we're
owned by a different address.

23972
24:50:04.893 --> 24:50:06.893
Now if it's owned by us, we get
this little hover that says

23973
24:50:06.893 --> 24:50:09.893
Update listing. And right now
it's worth 0.18. That's what

23974
24:50:10.893 --> 24:50:13.893
it's listed for on our
marketplace. If it's owned by

23975
24:50:13.893 --> 24:50:16.893
us, and we click it, we can
update it to a different price.

23976
24:50:16.893 --> 24:50:20.893
Let's update it to 50 eath, or
whatever your layer one currency

23977
24:50:20.893 --> 24:50:23.893
is, we'll just save new listing
price. We'll go ahead and

23978
24:50:23.893 --> 24:50:27.893
confirm. And I'll say the
listing updated, please refresh,

23979
24:50:27.893 --> 24:50:30.893
what we can do them. And we'll
mine some blocks on the back

23980
24:50:30.893 --> 24:50:33.893
end, and boom, now we see that
it's worth 50 here. Now if we

23981
24:50:33.893 --> 24:50:37.893
switch to a different account,
now we can see owned by Baba

23982
24:50:37.893 --> 24:50:41.893
blah, and the hovered now says
by me enough is selected as a

23983
24:50:41.893 --> 24:50:45.893
different user, I'm going to get
this transaction to actually buy

23984
24:50:45.893 --> 24:50:48.893
it. Now go ahead and confirm
that I'm going to buy it, I get

23985
24:50:48.893 --> 24:50:51.893
a little pop up. This is item
bought successfully. Now if I do

23986
24:50:51.893 --> 24:50:54.893
a little refresh, we'll now see
that that NFT is gone from the

23987
24:50:55.893 --> 24:50:57.893
marketplace since we bought it
right and it's no longer

23988
24:50:57.893 --> 24:51:00.893
available to be sold. Now what
we can do then is we can come

23989
24:51:00.893 --> 24:51:05.893
over to sell NF tees. And at the
bottom, we'll see a withdraw

23990
24:51:05.893 --> 24:51:09.893
proceeds. So whenever somebody
buys an NF T, the NFT

23991
24:51:09.893 --> 24:51:13.893
marketplace actually keeps the
proceeds that actually keeps the

23992
24:51:13.893 --> 24:51:16.893
result of the sale. So if we
switch back to our address that

23993
24:51:16.893 --> 24:51:20.893
had the NFT listed, we can now
see Withdraw 50 proceeds because

23994
24:51:20.893 --> 24:51:23.893
we know that we have 50 eath,
because we just bought that for

23995
24:51:23.893 --> 24:51:27.893
50. So if we hit withdraw,
Metamask is going to pop up, we

23996
24:51:27.893 --> 24:51:31.894
can go ahead and confirm, wait a
little bit as transaction

23997
24:51:31.894 --> 24:51:35.894
populates, and boom once it goes
through, and we'll see now we

23998
24:51:35.894 --> 24:51:39.894
have zero proceeds. Right? We
withdrew everything from here.

23999
24:51:39.894 --> 24:51:42.894
So what we can do now is we can
relist that NFT. So if we come

24000
24:51:42.894 --> 24:51:47.894
back, go back to the one who
just bought that at a T if we

24001
24:51:47.894 --> 24:51:50.894
know the address and the token
ID of the NF t and we own it, we

24002
24:51:50.894 --> 24:51:54.894
can go ahead and relisted you're
gonna place the address in here

24003
24:51:54.894 --> 24:51:59.894
with the token Id give it some
sort of price. We'll submit

24004
24:51:59.894 --> 24:52:03.894
we'll approve giving the NFT
marketplace access to our or

24005
24:52:03.894 --> 24:52:07.894
NFT, to our little doggie. And
then we'll go ahead and actually

24006
24:52:07.894 --> 24:52:12.894
send the transaction to actually
list the NFT on a marketplace

24007
24:52:12.894 --> 24:52:16.894
that we get NF T listed
successfully. After we move some

24008
24:52:16.894 --> 24:52:19.894
blocks in the backend, we can go
back to the front end. And we

24009
24:52:19.894 --> 24:52:23.894
now see, it's owned by us,
instead of the original owner,

24010
24:52:23.894 --> 24:52:27.894
right and set for 10 ether. And
then we can of course, switch

24011
24:52:27.894 --> 24:52:30.894
back to a different user, and we
can have

24012
24:52:30.894 --> 24:52:36.894
them actually buy. Alright, so
now that we have the contracts,

24013
24:52:36.894 --> 24:52:39.894
we know what this looks like on
the contract side. So now let's

24014
24:52:39.894 --> 24:52:42.894
figure out how to do this on the
front end side. So let's jump

24015
24:52:42.894 --> 24:52:46.894
into our code editor. And begin
if we're on our hard hat and my

24016
24:52:46.894 --> 24:52:50.894
NFT marketplace Free Code Camp
folder. That's great. But we're

24017
24:52:50.894 --> 24:52:52.894
going to create another folder,
we're going to CD down and

24018
24:52:52.894 --> 24:52:55.894
directory. And we're going to
make a new directory. I'm going

24019
24:52:55.894 --> 24:53:01.894
to call it next Jas and if T
marketplace dash FCC. Now you

24020
24:53:01.894 --> 24:53:05.894
can do next Jas marketplace dash
mirallas FCC if you want. Again,

24021
24:53:05.894 --> 24:53:10.895
we're starting with mirallas CD
next Jas NFT marketplace FCC. So

24022
24:53:10.895 --> 24:53:14.895
now that we have this folder,
will do code dot will open up a

24023
24:53:14.895 --> 24:53:18.895
new VS code, or you can do File
Open folder and open this new

24024
24:53:18.895 --> 24:53:22.895
folder. And we can begin working
in this new folder in here. Now

24025
24:53:22.895 --> 24:53:25.895
that we're in our new project,
we're in our new folder, we're

24026
24:53:25.895 --> 24:53:30.895
gonna do exactly what we've done
before. Yarn create next app,

24027
24:53:30.895 --> 24:53:36.895
period. Okay, we've done our
setup here. Now, I don't like es

24028
24:53:36.895 --> 24:53:37.895
lint. So once again, I'm just
going to go ahead and delete

24029
24:53:37.895 --> 24:53:42.895
that. And what we're going to
add in instead is our prettier

24030
24:53:42.895 --> 24:53:45.895
stuff. So prettier, ignore
prettier RC. Again, some people

24031
24:53:45.895 --> 24:53:48.895
may strongly disagree with me on
that, but to each their own

24032
24:53:48.895 --> 24:53:50.895
right, this is what I like to
do. So this is what I'm going to

24033
24:53:50.895 --> 24:53:54.895
do. Now we have a minimalistic
react project, right? If we run

24034
24:53:54.895 --> 24:54:00.895
yarn Dev, we open up our UI on
that site, copy this, or

24035
24:54:00.895 --> 24:54:04.895
Command, click it. Tada. Welcome
to next. Jas Yeah, we've got an

24036
24:54:04.895 --> 24:54:09.895
x js application. As we know, we
go to pages, we go to index.js.

24037
24:54:09.895 --> 24:54:16.895
Let's delete everything in here.
Bom will leave the stuff and

24038
24:54:16.895 --> 24:54:19.895
head if it comes with stuff and
head will write Hi, exclamation

24039
24:54:19.895 --> 24:54:22.895
mark. We'll save we'll come
back. And now we see Hi. And

24040
24:54:22.895 --> 24:54:25.895
I'll zoom in a whole bunch.
Boom. So now we have some

24041
24:54:25.895 --> 24:54:29.895
minimalistic reacts minimalistic
next, Jas. Now, I know we

24042
24:54:29.895 --> 24:54:32.895
already started the project
here. But let's jump to the

24043
24:54:32.895 --> 24:54:35.895
readme that's given to us. And
let's talk about how we want to

24044
24:54:35.895 --> 24:54:39.895
do this what we want this to
actually look like. Well, we're

24045
24:54:39.895 --> 24:54:42.895
going to want to make a
homepage. And in this homepage,

24046
24:54:42.895 --> 24:54:46.895
we'll say we'll have it show
recently listed, NF T's homepage

24047
24:54:46.895 --> 24:54:50.896
will show recently listed
entities that will say if you

24048
24:54:50.896 --> 24:54:55.896
own the NFT, you can update the
listing. If not, you can buy the

24049
24:54:55.896 --> 24:54:58.896
listing. So we'll have that. And
then we'll have a sell page. And

24050
24:54:58.896 --> 24:55:03.896
in this page, you can list your
NFT on the marketplace. So these

24051
24:55:03.896 --> 24:55:05.896
are going to be our two main
pages, we're gonna have a

24052
24:55:05.896 --> 24:55:08.896
homepage and a sell page. Now
we're going to have a ton of

24053
24:55:08.896 --> 24:55:10.896
components, but we're really
only going to have two main

24054
24:55:10.896 --> 24:55:15.896
pages. So if we go back over to
Pages, right, right now we have

24055
24:55:15.896 --> 24:55:19.896
our apps dot j s, which serves
our app, which is cool, which

24056
24:55:19.896 --> 24:55:21.896
everything runs through. And
then we have our homepage. Let's

24057
24:55:21.896 --> 24:55:27.896
also create right now, our sell
page or selling of T dot j s.

24058
24:55:27.896 --> 24:55:30.896
And then in here, we'll just
make this really minimal, that

24059
24:55:30.896 --> 24:55:33.896
we can copy most of what's in
here, we can actually just copy

24060
24:55:33.896 --> 24:55:36.896
paste this whole thing, paste it
in here. And instead of high,

24061
24:55:36.896 --> 24:55:42.896
we'll say sell page. We'll save
that. Now if we go to our

24062
24:55:42.896 --> 24:55:48.896
localhost do debt slash sell.
And if T oops, we gotta run. Run

24063
24:55:48.896 --> 24:55:51.896
the front end again. With yarn
Dev. Sorry, we'll run yarn dev

24064
24:55:51.896 --> 24:55:55.896
again. Now we refresh. And now
we can see sell page. So sell

24065
24:55:55.896 --> 24:55:58.896
pages that slash sell page, and
then home is just going to be

24066
24:55:58.896 --> 24:56:02.896
high. Okay, cool. So we have our
two pages. Which one should we

24067
24:56:02.896 --> 24:56:07.896
work on first? Well, let's work
on our homepage. So we're going

24068
24:56:07.896 --> 24:56:10.896
to be in our index.js. I'm going
to keep this front end bit

24069
24:56:10.896 --> 24:56:13.896
running, we're going to hide it
oops, that's the opposite of

24070
24:56:13.896 --> 24:56:16.896
hiding it, push it down, we're
going to hide it like that. And

24071
24:56:16.896 --> 24:56:19.896
let's go ahead and let's start
building this. So we see in our

24072
24:56:19.896 --> 24:56:22.896
index js, we have some head
stuff here, I'm going to change

24073
24:56:22.896 --> 24:56:28.896
this to NFT. Marketplace.
Description is going to be just

24074
24:56:28.896 --> 24:56:32.897
an empty marketplace.

24075
24:56:32.897 --> 24:56:36.897
Like so Fabcon looks great. Now
if we do a little refresh, now

24076
24:56:36.897 --> 24:56:39.897
it says NFT marketplace up at
the top here, which is good.

24077
24:56:40.897 --> 24:56:42.897
That's what we want. Well in our
index page, what's one of the

24078
24:56:42.897 --> 24:56:45.897
first things that we're always
going to need to do? You guessed

24079
24:56:45.897 --> 24:56:47.897
it, we're going to need a little
connect button right? We're

24080
24:56:47.897 --> 24:56:51.897
going to need our users to be
able to connect to to web three

24081
24:56:51.897 --> 24:56:55.897
to connect to a blockchain. So
same as we've done before. Let's

24082
24:56:55.897 --> 24:56:57.897
go ahead let's create a
components folder. And we'll

24083
24:56:57.897 --> 24:57:01.897
create a header component
component Nance folder and we'll

24084
24:57:01.897 --> 24:57:06.897
create a new file The header
digests. Now remember, since

24085
24:57:06.897 --> 24:57:09.897
we've done this before, with our
front end lottery code, we can

24086
24:57:09.897 --> 24:57:12.897
always refer back to the lottery
code as well when we're building

24087
24:57:12.897 --> 24:57:16.897
this, okay. And of course, we
have all of the code for this on

24088
24:57:16.897 --> 24:57:19.897
the GitHub repo. So you can use
that to what I'm not going to

24089
24:57:19.897 --> 24:57:22.897
have you all do is last time, we
did that manual header thing,

24090
24:57:22.897 --> 24:57:24.897
right, where we had to do all
the local storage and do all

24091
24:57:24.897 --> 24:57:28.897
that crazy stuff, we're not
going to do that. This time,

24092
24:57:28.897 --> 24:57:30.897
we're going to just do it the
easy way, we're going to just

24093
24:57:30.897 --> 24:57:34.897
use the web three UI kit. So to
use this connect button, we're

24094
24:57:34.897 --> 24:57:38.897
going to do yarn, add. And we're
not going to do dash dash Dev,

24095
24:57:38.897 --> 24:57:42.897
because this connect button is a
necessary component for the

24096
24:57:42.897 --> 24:57:46.897
front end, yarn add web through
UI Kit. This also means we're

24097
24:57:46.897 --> 24:57:51.897
going to do Morales and react
mirallas. I said, and this is

24098
24:57:51.897 --> 24:57:54.897
where it might be a little
confusing. I know I said in here

24099
24:57:54.897 --> 24:57:59.897
that we have both a Morales and
other graph edition. So we're

24100
24:57:59.897 --> 24:58:02.897
still going to use the Morales
package in both of them. The

24101
24:58:02.897 --> 24:58:05.897
only difference is we're going
to use a Morales server as well

24102
24:58:05.897 --> 24:58:08.897
in our Morales edition. And
we're not going to use a morale

24103
24:58:08.897 --> 24:58:11.898
server on our the graph edition,
they're both can use the Morales

24104
24:58:11.898 --> 24:58:14.898
package because all the open
source hooks and tools are still

24105
24:58:14.898 --> 24:58:18.898
incredibly powerful, even if we
don't use the Morales server. So

24106
24:58:18.898 --> 24:58:20.898
we're still going to use the
Morales package even when we're

24107
24:58:20.898 --> 24:58:23.898
going to be using the graph.
Great. So now that we've added

24108
24:58:23.898 --> 24:58:26.898
those all, we're going to do
exactly what we did before on

24109
24:58:26.898 --> 24:58:30.898
our last next Jas process. So in
order to use our web through UI

24110
24:58:30.898 --> 24:58:40.898
component in our app, dot j, s,
and do import mirallas provider

24111
24:58:40.898 --> 24:58:45.898
quotes and without sorry, and
curly brace, it's from react

24112
24:58:45.898 --> 24:58:49.898
mirallas like that. And then
we're going to wrap our whole

24113
24:58:49.898 --> 24:58:53.898
component thing in a morass
provider. So we're gonna do

24114
24:58:53.898 --> 24:59:00.898
return, little open parentheses,
close parentheses here. We're

24115
24:59:00.898 --> 24:59:06.898
gonna do rounds provider. And
then we're gonna do in if she

24116
24:59:06.898 --> 24:59:12.898
allies on Mount is going to
equal false, because we're not

24117
24:59:12.898 --> 24:59:15.898
going to use the server yet, or
else provider. Okay, cool. Now

24118
24:59:15.898 --> 24:59:19.898
that we've wrapped our app in a
Morales provider, and go back to

24119
24:59:19.898 --> 24:59:26.898
our header, we're gonna say
Export default function header,

24120
24:59:26.898 --> 24:59:29.898
we're going to grab our Connect
button from what through your

24121
24:59:29.898 --> 24:59:35.898
eye kit. So we'll do import
connect button from web three UI

24122
24:59:35.898 --> 24:59:42.898
kits. And then in here, we're
just gonna say return. The next

24123
24:59:42.898 --> 24:59:46.898
button. Now what we can do back
in our app, J. S, is we can do

24124
24:59:46.898 --> 24:59:54.899
import, import, do header from
dot dot slash components header,

24125
24:59:54.899 --> 24:59:57.899
and we have our header, we'll
just put our header right above

24126
24:59:57.899 --> 25:00:01.899
the component. And we're going
to add some stuff to the header

24127
25:00:01.899 --> 25:00:03.899
in a bit. Let's just make sure
that we're importing the header

24128
25:00:03.899 --> 25:00:06.899
correctly. Let's go back to our
UI here. And okay, boom, we have

24129
25:00:06.899 --> 25:00:09.899
our connects button. If we click
it, you know, we'll get this

24130
25:00:09.899 --> 25:00:12.899
little pop up. And I'm way
zoomed in. So I'm going to anway

24131
25:00:12.899 --> 25:00:14.899
zoom in.

24132
25:00:14.899 --> 25:00:16.899
Now, what else do we want to put
in our header? Well, we're

24133
25:00:16.899 --> 25:00:19.899
probably going to want to like
give this like a name and make

24134
25:00:19.899 --> 25:00:22.899
this look a little bit nicer,
probably going to want to a link

24135
25:00:22.899 --> 25:00:27.899
as well to our cell NF T page.
So let's create a navbar. So

24136
25:00:27.899 --> 25:00:29.899
instead of just returning the
connect button, put this in

24137
25:00:29.899 --> 25:00:33.899
parenthesis and we'll have a
return some other stuff too. So

24138
25:00:33.899 --> 25:00:37.899
we can use this nav tag, which
usually defines like a nav bar.

24139
25:00:37.899 --> 25:00:41.899
So it's really similar to a div,
it's just another tag. Right, so

24140
25:00:41.899 --> 25:00:44.899
now we'll put everything into
this nav tag. And in next Jas,

24141
25:00:44.899 --> 25:00:51.899
we can actually make links using
the next Jas link tag. So what

24142
25:00:51.899 --> 25:00:55.899
we can do in this is link allows
us to basically connect to

24143
25:00:55.899 --> 25:01:00.899
different links or URLs in our
application, like so. So we can

24144
25:01:00.899 --> 25:01:07.899
do import link from next slash
link. And in here, let's say if

24145
25:01:07.899 --> 25:01:11.899
we want it to go to the
homepage, we can make a link.

24146
25:01:11.899 --> 25:01:18.899
And we'll say h ref equals slash
equals slash. And inside of

24147
25:01:18.899 --> 25:01:23.899
this, we would wrap this in an a
tag to make it clickable. And

24148
25:01:23.899 --> 25:01:28.899
then we could just say something
like NFT marketplace. Now if we

24149
25:01:28.899 --> 25:01:32.900
save that, we go to our front
end, we now we see have a NFT

24150
25:01:32.900 --> 25:01:35.900
marketplace button that we can
click and since we're already at

24151
25:01:35.900 --> 25:01:38.900
home, we're not going to go
anywhere. But if we copy this

24152
25:01:38.900 --> 25:01:42.900
link section, paste it below,
and we make another one for cell

24153
25:01:42.900 --> 25:01:48.900
and f t. And we title this cell
NF t. Now we save we go back to

24154
25:01:48.900 --> 25:01:52.900
our front end, we now have NFT
marketplace and sell NFT if I

24155
25:01:52.900 --> 25:01:55.900
click sell NF t we now get to
the sell page right we'll go

24156
25:01:55.900 --> 25:02:01.900
back to the homepage sell page
flip back and forth. Awesome,

24157
25:02:01.900 --> 25:02:05.900
very exciting. So now we have
have an incredibly minimalistic

24158
25:02:05.900 --> 25:02:09.900
header obviously looks terrible.
So let's do just a little bit of

24159
25:02:09.900 --> 25:02:12.900
formatting. And oftentimes
you'll do the formatting last.

24160
25:02:12.900 --> 25:02:16.900
But while we're here, we might
as well do our formatting we're

24161
25:02:16.900 --> 25:02:20.900
going to use what if you guessed
tailwind? You guessed correctly.

24162
25:02:20.900 --> 25:02:25.900
So remember, tailwind with.
Next. Jas, you can always just

24163
25:02:25.900 --> 25:02:28.900
follow along here. And we'll
grab, we'll do the exact same

24164
25:02:28.900 --> 25:02:32.900
thing we did before we'll do
yarn, add dash dash Dev, that

24165
25:02:32.900 --> 25:02:36.900
stuff right there. And then
we'll run a knit after these

24166
25:02:36.900 --> 25:02:36.900
finished

24167
25:02:36.900 --> 25:02:42.900
installing. So we'll do yarn,
and then paste that in. And

24168
25:02:42.900 --> 25:02:46.900
there we go. So now we've got
our post CSS config, we've got

24169
25:02:46.900 --> 25:02:50.900
our tailwind config. We're going
to grab tailwind.config.js.

24170
25:02:50.900 --> 25:02:54.900
Paste it in here. And then we're
going to grab Global's dot css

24171
25:02:54.900 --> 25:02:58.900
and open up Global's dot css,
paste that in there, and cool.

24172
25:02:58.900 --> 25:03:01.900
Now we have tailwind in here.
Now that we have tailwind, we

24173
25:03:01.900 --> 25:03:05.900
can do some tailwind stuff to
our header here. Let's let's

24174
25:03:05.900 --> 25:03:09.900
create a div for all of these
for everything here, we'll

24175
25:03:09.900 --> 25:03:12.901
create a little div for all the
stuff here, we'll make like a

24176
25:03:12.901 --> 25:03:15.901
big section for almost like a
big sign saying, Hey, you're at

24177
25:03:15.901 --> 25:03:20.901
the NFC marketplace, h1, which
stands for header one, and we'll

24178
25:03:20.901 --> 25:03:26.901
give it a class name of padding
y of form. Padding x of four,

24179
25:03:26.901 --> 25:03:33.901
we'll do font bold text will be
three XL, and then it'll just

24180
25:03:33.901 --> 25:03:36.901
say NFT marketplace. Now we have
this NFT marketplace, which is

24181
25:03:36.901 --> 25:03:40.901
nice bolt. Awesome. If you're on
your server you're going to kill

24182
25:03:40.901 --> 25:03:43.901
it's going to kill it with Ctrl
C, and then we're going to

24183
25:03:43.901 --> 25:03:46.901
restart it. And that's going to
pull in all the tailwind stuff.

24184
25:03:46.901 --> 25:03:51.901
And now if we refresh our local
main, we should now see okay,

24185
25:03:51.901 --> 25:03:56.901
and if T and F c, r gets place,
right, we now see this and big

24186
25:03:56.901 --> 25:03:59.901
and bold, which looks a lot
better. So let's keep going.

24187
25:03:59.901 --> 25:04:03.901
Let's give our whole nav a class
name. Equals we'll give it

24188
25:04:03.901 --> 25:04:13.901
padding of five, border bottom
to flex flex row justify just if

24189
25:04:13.901 --> 25:04:19.901
between n items center. We'll
see how that looks. Haha, looks

24190
25:04:19.901 --> 25:04:22.901
a lot better. We're now kind of
like setting this up with a

24191
25:04:22.901 --> 25:04:25.901
bottom border kind of stick and
some stuff like this, that looks

24192
25:04:25.901 --> 25:04:29.901
much much nicer already. Let's
go down here. Let's make our

24193
25:04:29.901 --> 25:04:36.901
buttons have a class name equals
lax lax row items center. And

24194
25:04:36.901 --> 25:04:40.901
like I said, this is not a
styling class. So we're not

24195
25:04:40.901 --> 25:04:43.901
really going to go over exactly
how we're styling this. And that

24196
25:04:43.901 --> 25:04:46.901
is okay. But that's going to
move that over make that look a

24197
25:04:46.901 --> 25:04:51.902
little nicer. We'll give our
link here, a class name equals

24198
25:04:51.902 --> 25:04:56.902
Mr. For P six. And we'll give
both of these the same class

24199
25:04:56.902 --> 25:05:00.902
name both these links, give them
some padding, so they moved away

24200
25:05:00.902 --> 25:05:02.902
from each other some margin to
the right, so they're away from

24201
25:05:02.902 --> 25:05:07.902
each other. And oh, I forgot to
do this Morales off equals

24202
25:05:07.902 --> 25:05:11.902
false. We need Morales auth
equals false so that we don't

24203
25:05:11.902 --> 25:05:13.902
automatically connect to a
Morales database or try to

24204
25:05:13.902 --> 25:05:15.902
connect to Morales database,
when we connect, we want to just

24205
25:05:15.902 --> 25:05:19.902
connect with our Metamask. And
we'll change this to home

24206
25:05:19.902 --> 25:05:21.902
instead of the marketplace. But
otherwise, that looks pretty

24207
25:05:21.902 --> 25:05:25.902
good home selling of T Connect
button. And we can adjust the

24208
25:05:25.902 --> 25:05:28.902
formatting of this to make it
look a little different. But I

24209
25:05:28.902 --> 25:05:29.902
think for the most part, this
looks much better,

24210
25:05:29.902 --> 25:05:35.902
right? Alright, cool, much, much
better looking header. Here, we

24211
25:05:35.902 --> 25:05:38.902
have our app.js setup with the
mouse provider headers

24212
25:05:38.902 --> 25:05:43.902
components. Let's now move on to
our index. Let's now move on to

24213
25:05:43.902 --> 25:05:47.902
showing these NF T's showing all
the NF T's in our marketplace.

24214
25:05:47.902 --> 25:05:51.902
And here's where it's going to
already start to heat up and get

24215
25:05:51.902 --> 25:05:53.902
really interesting. And actually
one more thing, we're going to

24216
25:05:53.902 --> 25:05:57.902
grab this headpiece in the index
if you haven't. And we're just

24217
25:05:57.902 --> 25:06:02.902
going to have it be in the app
JSX. So yeah, and our app.js

24218
25:06:02.902 --> 25:06:05.902
we're going to put that header
up at the top, and just put a

24219
25:06:05.902 --> 25:06:11.902
little, little div, Div. div,
like so wrapping around this

24220
25:06:11.902 --> 25:06:16.902
whole thing. This goes here. And
this way, no matter what page

24221
25:06:16.902 --> 25:06:19.902
we're on, we're always going to
have this as our header. And we

24222
25:06:19.902 --> 25:06:21.902
don't have to define it each one
of our little our things here.

24223
25:06:21.902 --> 25:06:25.902
So we'll do a refresh. And it
says head is not defined. Sorry,

24224
25:06:25.902 --> 25:06:27.902
that's because we're going to
need to copy import head from

24225
25:06:28.902 --> 25:06:32.903
next slash head. Paste it into
our app that Jas import head

24226
25:06:32.903 --> 25:06:35.903
from next head. And now we can
see we're going to empty

24227
25:06:35.903 --> 25:06:37.903
marketplace no matter what page
we're on, because we're defining

24228
25:06:37.903 --> 25:06:40.903
it at our app level. We have the
header in here, we have this

24229
25:06:40.903 --> 25:06:44.903
stuff in here, index almost has
nothing in it now. Let's do

24230
25:06:44.903 --> 25:06:48.903
this. So what do we want to do?
We want the homepage aka our

24231
25:06:48.903 --> 25:06:52.903
index to show recently listed
NFT. So the question is, how do

24232
25:06:52.903 --> 25:06:57.903
we show the recently listed NF
Ts. How do we do that? Well,

24233
25:06:58.903 --> 25:07:02.903
let's go back to our contract.
We go back to our hard hat NFT

24234
25:07:02.903 --> 25:07:05.903
marketplace So we're looking at
at the marketplace, what do we

24235
25:07:05.903 --> 25:07:08.903
have in here? How do we actually
see where NFT is stored? Well,

24236
25:07:08.903 --> 25:07:12.903
they're stored in this listings
mapping. However, how do we see

24237
25:07:12.903 --> 25:07:15.903
all of the listings that are in
here? Well, this is a mapping,

24238
25:07:15.903 --> 25:07:18.903
which means we have every single
address on the planet in here,

24239
25:07:18.903 --> 25:07:21.903
we can't loop through the
mapping, we'd have to loop

24240
25:07:21.903 --> 25:07:25.903
through every single address on
the planet, which is some

24241
25:07:25.903 --> 25:07:28.903
insanely large number that you
and I could never fathom how

24242
25:07:28.903 --> 25:07:31.903
many addresses there are. So
what are some solutions that we

24243
25:07:31.903 --> 25:07:34.903
can take to this problem, right?
Because we're obviously not

24244
25:07:34.903 --> 25:07:37.903
going to loop through
everything. So what do we do?

24245
25:07:37.903 --> 25:07:40.903
What's what's kind of the first
approach, one of the first

24246
25:07:40.903 --> 25:07:42.903
approaches would be like,
alright, Patrick, well, why

24247
25:07:42.903 --> 25:07:46.903
don't we just create an array,
an array of listings instead,

24248
25:07:46.903 --> 25:07:49.903
and this might be a good
approach. But what if then later

24249
25:07:49.903 --> 25:07:52.903
on, we also want to get some
other weird data, maybe we want

24250
25:07:52.903 --> 25:07:57.903
to get all the NF t's a user
owns NF t's a user owns, there's

24251
25:07:57.903 --> 25:08:00.903
no array of NF T's that a user
owns. Again, that's just a

24252
25:08:01.903 --> 25:08:04.903
mapping. But what if we want to
query some other weird data, or

24253
25:08:04.903 --> 25:08:10.903
query some other weird data, or
what if an array will be very

24254
25:08:10.903 --> 25:08:13.904
gas expensive, which it is, if
we make this an array to loop

24255
25:08:13.904 --> 25:08:16.904
through, it'll be incredibly gas
expensive. So we don't want to

24256
25:08:16.904 --> 25:08:19.904
have to go back and change. So
I'm going to I'm going to type

24257
25:08:19.904 --> 25:08:22.904
this out. Because this is
important. We don't want to

24258
25:08:22.904 --> 25:08:28.904
change our protocol for just the
website, we don't want to change

24259
25:08:28.904 --> 25:08:31.904
our protocol for just the
website, or we don't want to

24260
25:08:31.904 --> 25:08:34.904
much change our protocol for the
website. Because if we were to

24261
25:08:34.904 --> 25:08:37.904
make this an array, it would
become incredibly gas

24262
25:08:37.904 --> 25:08:40.904
inefficient. And it would become
much harder to use this NFT

24263
25:08:40.904 --> 25:08:43.904
marketplace because it would be
so much more expensive. And as

24264
25:08:43.904 --> 25:08:46.904
you build more and more complex
protocols, you're going to

24265
25:08:46.904 --> 25:08:50.904
realize that having an array for
every single mapping you have

24266
25:08:50.904 --> 25:08:54.904
isn't feasible. This is one of
the reasons where these events

24267
25:08:54.904 --> 25:09:00.904
come into play. So every single
time we list an NF t, we call

24268
25:09:00.904 --> 25:09:04.904
this list item function. And we
omit item listed, this item

24269
25:09:04.904 --> 25:09:09.904
listed event is stored in a data
structure that's still on chain,

24270
25:09:09.904 --> 25:09:12.904
but just smart contracts can
access it. However, guess what

24271
25:09:12.904 --> 25:09:16.904
can't access it off chain
services can access these

24272
25:09:16.904 --> 25:09:21.904
events. So what we do in this
case, is what we're going to do

24273
25:09:21.904 --> 25:09:27.904
is we will index the events off
chain and then read from our

24274
25:09:27.904 --> 25:09:30.904
database. So what we're
literally going to do is we're

24275
25:09:30.904 --> 25:09:34.904
going to set up a server to
listen for those events to be

24276
25:09:34.904 --> 25:09:39.904
fired, fired. And we will add
them to a database to query. So

24277
25:09:39.904 --> 25:09:43.904
yes, we're literally going to
take every single time an item

24278
25:09:43.904 --> 25:09:47.904
is listed, we're going to index
it in a database for ourself.

24279
25:09:47.904 --> 25:09:51.905
And then we're going to call our
centralized database to start

24280
25:09:51.905 --> 25:09:53.905
and we're going to call that
database to do that. Now the

24281
25:09:53.905 --> 25:09:58.905
question then becomes Whoa,
isn't that centralized? Hey,

24282
25:09:58.905 --> 25:10:00.905
Patrick, we're talking isn't
that centralized? What the

24283
25:10:00.905 --> 25:10:04.905
Hickety heck, and the answer to
that is, it's not necessarily.

24284
25:10:04.905 --> 25:10:08.905
So the graph is a protocol that
does exactly this. It's a

24285
25:10:08.905 --> 25:10:13.905
protocol that indexes events off
chain, and sticks them into this

24286
25:10:13.905 --> 25:10:17.905
the Graph Protocol. And it does
it in a decentralized way,

24287
25:10:17.905 --> 25:10:20.905
Morales, the way we're going to
show you first does it in a

24288
25:10:20.905 --> 25:10:23.905
centralized way, Morales is
going to do it in a centralized

24289
25:10:23.905 --> 25:10:27.905
way, which might be the route
that you want to go for speed

24290
25:10:27.905 --> 25:10:30.905
for extra bells and whistles, so
that you can do local

24291
25:10:30.905 --> 25:10:32.905
development, which is what we're
going to be focusing on here, or

24292
25:10:32.905 --> 25:10:35.905
any of the other functionality
that Morales comes with. Because

24293
25:10:35.905 --> 25:10:38.905
Morales does a lot more than
just that. That's something to

24294
25:10:38.905 --> 25:10:41.905
keep in mind too, is even though
we are adding a centralized

24295
25:10:41.905 --> 25:10:45.905
component, or logic, our smart
contracts, the real bulk of this

24296
25:10:45.905 --> 25:10:49.905
application is decentralized.
And you can verify all your

24297
25:10:49.905 --> 25:10:51.905
interactions are working with
this decentralized smart

24298
25:10:51.905 --> 25:10:54.905
contract, we've actually been
using a lot of protocols that

24299
25:10:54.905 --> 25:10:58.905
are centralized, like ether
scan, like open see, and some of

24300
25:10:58.905 --> 25:11:01.905
these centralized protocols are
really important to this space.

24301
25:11:01.905 --> 25:11:04.905
So we're showing you Morales to
get you familiar with working

24302
25:11:04.905 --> 25:11:06.905
with one of these centralized
servers, in case you optionally

24303
25:11:06.905 --> 25:11:10.905
want to make an application that
provides a centralized service.

24304
25:11:10.905 --> 25:11:12.905
And there's a ton of tools in
the space like opens up and

24305
25:11:12.905 --> 25:11:17.905
defender tenderly and more, that
are centralized, but give us

24306
25:11:17.905 --> 25:11:20.905
massive, massive benefits. We as
a community are bringing more

24307
25:11:20.905 --> 25:11:22.905
and more things to being
decentralized. And sometimes we

24308
25:11:22.905 --> 25:11:25.905
need some training wheels to get
there. And then the graph is

24309
25:11:25.905 --> 25:11:27.905
going to be the decentralized
way, which is a bit of a longer

24310
25:11:27.905 --> 25:11:30.905
process to go main net, but
we'll explain all that when we

24311
25:11:30.905 --> 25:11:33.906
get there. Let's learn how we
can list the most recently

24312
25:11:33.906 --> 25:11:37.906
listed NF T's and Morales in the
graph. Both have some really

24313
25:11:37.906 --> 25:11:40.906
solid videos, I'm going to leave
some links in the GitHub repo

24314
25:11:40.906 --> 25:11:42.906
associated with this. So if you
want to learn more, you should

24315
25:11:42.906 --> 25:11:44.906
definitely watch both of those
because they are absolutely

24316
25:11:44.906 --> 25:11:48.906
fantastic and will help you
understand this event stuff

24317
25:11:48.906 --> 25:11:51.906
better. So normally, when we
read from the blockchain, we do

24318
25:11:51.906 --> 25:11:55.906
something like contract dot get,
get listing, you know, and then

24319
25:11:55.906 --> 25:11:59.906
we put it whatever our input
parameters are. Contract double

24320
25:11:59.906 --> 25:12:02.906
blah, so instead, so we're going
to read from a database that

24321
25:12:02.906 --> 25:12:05.906
houses All the mappings and an
easier to read data structure.

24322
25:12:05.906 --> 25:12:11.906
Both Morales and the graph do
this.

24323
25:12:11.906 --> 25:12:13.906
We've been using the morass,
open source packages and tools.

24324
25:12:13.906 --> 25:12:17.906
However, Morales also comes
optionally with a server back

24325
25:12:17.906 --> 25:12:20.906
end to give your web three
applications more functionality.

24326
25:12:20.906 --> 25:12:23.906
However, there's a ton of stuff
that we're not going to cover

24327
25:12:23.906 --> 25:12:25.906
that Morales can do to help
build your web three

24328
25:12:25.906 --> 25:12:28.906
applications. So instead of me
continuing to talk about

24329
25:12:28.906 --> 25:12:31.906
Morales, and what it can do, we
have Ivan here to give a brief

24330
25:12:31.906 --> 25:12:34.906
overview of some of the other
things that Morales can do take

24331
25:12:34.906 --> 25:12:34.906
it away, and

24332
25:12:34.906 --> 25:12:38.906
my name is Ivan, I'm from
rallis. And I'm here to tell you

24333
25:12:38.906 --> 25:12:41.906
how you can speed up your
development by 10 times and I'm

24334
25:12:41.906 --> 25:12:43.906
not over exaggerating, when
you're building something, you

24335
25:12:43.906 --> 25:12:47.906
want to ensure that is scalable,
because your DAP may go global,

24336
25:12:47.906 --> 25:12:51.906
it may get viral, it may go
mainstream, it can happen. And

24337
25:12:51.906 --> 25:12:55.906
if it happens, you don't want to
start from scratch, you want to

24338
25:12:55.906 --> 25:12:59.906
use tools and services that
allow you to go fast, and also

24339
25:12:59.906 --> 25:13:02.906
to go big. And that's exactly
what mirallas provides. At

24340
25:13:02.906 --> 25:13:06.906
mirallas. We create tools, we
create infrastructure for

24341
25:13:06.906 --> 25:13:11.907
developers in a way that you
have a single workflow, and they

24342
25:13:11.907 --> 25:13:13.907
will soon explain what it means
because this is what saves you

24343
25:13:13.907 --> 25:13:16.907
time. If you have a single
workflow for doing things. And

24344
25:13:16.907 --> 25:13:20.907
workflow in web three really
means that you have to have a

24345
25:13:20.907 --> 25:13:23.907
smart contract, whether it's a
token, the game, some kind of

24346
25:13:23.907 --> 25:13:26.907
staking some kind of
marketplace, some kind of defy,

24347
25:13:26.907 --> 25:13:29.907
it will be on chain, but at the
same time, you have to connect

24348
25:13:29.907 --> 25:13:32.907
it to your back end. Because
when something happens on chain,

24349
25:13:32.907 --> 25:13:35.907
you need to monitor that. So you
can create web hooks, you can

24350
25:13:35.907 --> 25:13:39.907
create email, you can create a
push notification, you can run

24351
25:13:39.907 --> 25:13:43.907
some custom code, you can run
some calculation, you can save

24352
25:13:43.907 --> 25:13:45.907
something to the database,
everything on chain at the end

24353
25:13:45.907 --> 25:13:49.907
of the day needs to go into our
back end. And when something is

24354
25:13:49.907 --> 25:13:51.907
in your back end, it needs to go
to the front end. So for

24355
25:13:51.907 --> 25:13:55.907
example, you change the UI when
something happens on chain or

24356
25:13:55.907 --> 25:13:58.907
you change the UI. If your user
receives a transfer there is

24357
25:13:58.907 --> 25:14:02.907
above a specific threshold. Or
if your user has this NFC, you

24358
25:14:02.907 --> 25:14:06.907
can allow them access into some
kind of chat or some kind of

24359
25:14:06.907 --> 25:14:09.907
exclusive piece of content. So
at Morales, we provide you with

24360
25:14:09.907 --> 25:14:13.907
a full stack suite of tools that
is used by over 100,000

24361
25:14:13.907 --> 25:14:17.907
developers, it's really becoming
one of the most adopted tech

24362
25:14:17.907 --> 25:14:21.907
stacks in web three. And it all
starts with Morales identity,

24363
25:14:21.907 --> 25:14:24.907
which ensures that you get one
piece of code, you write one

24364
25:14:24.907 --> 25:14:26.907
piece of code and you can log in
your users across different

24365
25:14:26.907 --> 25:14:30.907
blockchains across different
wallets. And in your morale is

24366
25:14:30.907 --> 25:14:33.907
dashboard, you will get the user
profile, and you will get a web

24367
25:14:33.907 --> 25:14:36.907
session. So mirallas allows you
to manage identities because a

24368
25:14:36.907 --> 25:14:39.907
user profile can have many
different wallets from many

24369
25:14:39.907 --> 25:14:42.907
different chains connected to
it. And all of the transactions

24370
25:14:42.907 --> 25:14:45.907
will be synced from that user,
all the real time transactions

24371
25:14:45.907 --> 25:14:50.907
will be synced about that user.
And also, you have established

24372
25:14:50.907 --> 25:14:53.908
web session between your front
end whether it is a game,

24373
25:14:53.908 --> 25:14:58.908
whether it is a web website, we
ensure that you have secure

24374
25:14:58.908 --> 25:15:01.908
authenticated web sessions, and
we provide you with session

24375
25:15:01.908 --> 25:15:04.908
management. So in case you have
your own bike, and then you have

24376
25:15:04.908 --> 25:15:07.908
mirallas session identity
management, you can invalidate

24377
25:15:07.908 --> 25:15:10.908
sessions, you can log in users
and do all of that great, all of

24378
25:15:10.908 --> 25:15:13.908
these great things with one line
of code. That's very important.

24379
25:15:13.908 --> 25:15:17.908
Number two is Morales real time
I already mentioned a bit of it.

24380
25:15:17.908 --> 25:15:19.908
But basically when you have a
user, you know exactly what's

24381
25:15:19.908 --> 25:15:22.908
going on in real time. You can
run custom code, whenever a user

24382
25:15:22.908 --> 25:15:26.908
does a transaction, you can run
custom code or do a web hook or

24383
25:15:26.908 --> 25:15:29.908
email or push notification
whenever a user interacts with a

24384
25:15:29.908 --> 25:15:33.908
smart contracts or when a smart
contract simply emits an event.

24385
25:15:33.908 --> 25:15:38.908
This can be an trade in an NFC
marketplace, this can be ERC 20

24386
25:15:38.908 --> 25:15:42.908
transfer, you can be very
flexible by setting filters. So

24387
25:15:42.908 --> 25:15:46.908
you can say only give me alerts
only give me web hooks when the

24388
25:15:46.908 --> 25:15:50.908
user transfers more than 10
NFCs. Or when this token

24389
25:15:50.908 --> 25:15:54.908
transfer is above $1,000, and so
on so forth. This is morale is

24390
25:15:54.908 --> 25:15:59.908
real time very, very powerful
things. Next are mirallas SDKs.

24391
25:15:59.908 --> 25:16:02.908
So whether you're building a
website, whether you're building

24392
25:16:02.908 --> 25:16:05.908
a game where full integration
with game engines, whether

24393
25:16:05.908 --> 25:16:09.908
you're building for some other
platform, we have extensive SDKs

24394
25:16:09.908 --> 25:16:13.908
that are easy to use that allow
you to do all of this that allow

24395
25:16:13.908 --> 25:16:16.908
you to connect to Morales and do
this very, very easily. And if

24396
25:16:16.908 --> 25:16:19.908
you go to our documentation,
which I highly recommend you to

24397
25:16:19.908 --> 25:16:23.908
do, you go to Morales, Doc's dot
morales.io, if you go to Doc's

24398
25:16:23.908 --> 25:16:26.908
dot, Marisa Yo, you will first
and foremost understand what

24399
25:16:26.908 --> 25:16:28.908
mirallas is in depth. So you can
think of it kind of like

24400
25:16:28.908 --> 25:16:31.909
Firebase, but for crypto,
basically, it's a managed

24401
25:16:31.909 --> 25:16:35.909
backend, that you can connect
your front end. Also, you can

24402
25:16:35.909 --> 25:16:38.909
connect it to your own back end
using no GS SDK, it's very, very

24403
25:16:38.909 --> 25:16:41.909
easy. But what I wanted to show
you here is cross platform. So

24404
25:16:41.909 --> 25:16:44.909
for each thing we have, let's
say you want to get nfts for

24405
25:16:44.909 --> 25:16:47.909
your user, we'll show you how to
do it in simple JavaScript,

24406
25:16:47.909 --> 25:16:51.909
vanilla JavaScript, how to do it
and react, how to do it using a

24407
25:16:51.909 --> 25:16:54.909
web request. Let's say that you
just want to use a raw web

24408
25:16:54.909 --> 25:16:57.909
request. Let's say you're using
some kind of language that we

24409
25:16:57.909 --> 25:17:00.909
don't have SDK for you still can
use Morales just that you have

24410
25:17:00.909 --> 25:17:04.909
to call the raw HTTP request.
And we'll also show you how to

24411
25:17:04.909 --> 25:17:07.909
do it in Unity using C sharp in
Unity game engine. So we're

24412
25:17:07.909 --> 25:17:12.909
very, very clear cross platform.
And we are cross chain. So this

24413
25:17:12.909 --> 25:17:15.909
means for example, when you log
in the user, you can create the

24414
25:17:15.909 --> 25:17:19.909
user profile where you have the
lambda address, let's say your

24415
25:17:19.909 --> 25:17:22.909
user uses Solana then they can
easily connect Aetherium, they

24416
25:17:22.909 --> 25:17:25.909
can easily connect Binus chain,
the end, we're gonna add more

24417
25:17:25.909 --> 25:17:28.909
chain soon, they can easily
connect L Ron, to one user

24418
25:17:28.909 --> 25:17:31.909
profile. And then you have all
kinds of different wallets,

24419
25:17:31.909 --> 25:17:34.909
different chains, and you have
one single user profile one

24420
25:17:34.909 --> 25:17:37.909
single user ID. This is, by the
way, how it will look like in

24421
25:17:37.909 --> 25:17:42.909
your database. As you can see,
you're going to have a user user

24422
25:17:42.909 --> 25:17:45.909
table right here, you're going
to have all of their accounts.

24423
25:17:45.909 --> 25:17:48.909
So in this case, I only have
eath. But if I have Solana, if I

24424
25:17:48.909 --> 25:17:52.909
have other types of blockchains,
it will all be right here. And

24425
25:17:52.909 --> 25:17:56.909
this is a database that also has
all my transactions. This is a

24426
25:17:56.909 --> 25:18:00.909
database where I can set up
different listen events or smart

24427
25:18:00.909 --> 25:18:04.909
contracts. So for example, open
see I can watch open see smart

24428
25:18:04.909 --> 25:18:06.909
contracts or something else. And
it's very, very variable,

24429
25:18:06.909 --> 25:18:10.909
because this is MongoDB. This is
MongoDB, you can run MongoDB

24430
25:18:10.909 --> 25:18:13.910
queries, it's very, very
variable. So in that sense,

24431
25:18:13.910 --> 25:18:16.910
mirallas gives gives you a nice,
nice dashboard with everything

24432
25:18:16.910 --> 25:18:18.910
you need to know about your
users, their sessions, their

24433
25:18:18.910 --> 25:18:21.910
permissions, and so on, so
forth. And of course, you can

24434
25:18:21.910 --> 25:18:25.910
connect to your own back end
using the Node js SDK. So this

24435
25:18:25.910 --> 25:18:29.910
is Morales SDKs. And finally,
when we're speaking about the

24436
25:18:29.910 --> 25:18:32.910
workflow, the final thing is the
API's, which I also already

24437
25:18:32.910 --> 25:18:36.910
showed you, but the API is that
you can do RAW requests from any

24438
25:18:36.910 --> 25:18:39.910
programming language from any
kind of architecture. So using

24439
25:18:39.910 --> 25:18:42.910
this workflow, you can easily
achieve anything you want very,

24440
25:18:42.910 --> 25:18:46.910
very quickly. You really have to
try Morales it is it will change

24441
25:18:46.910 --> 25:18:49.910
your life. I can explain here
all I want, I have limited time.

24442
25:18:49.910 --> 25:18:53.910
But as you can already see, by
this presentation, you're very

24443
25:18:53.910 --> 25:18:56.910
curious, as you already can see,
by this presentation, you want

24444
25:18:56.910 --> 25:18:59.910
to try this as you already feel
by watching me here, you are

24445
25:18:59.910 --> 25:19:04.910
very, very excited. We have to
get your hands dirty. So go,

24446
25:19:04.910 --> 25:19:07.910
number one, two dogs, authorize
the sale, and go here getting

24447
25:19:07.910 --> 25:19:12.910
started connector SDK in vanilla
or react and go through all of

24448
25:19:12.910 --> 25:19:14.910
this. See the magic for
yourself. And if you want

24449
25:19:14.910 --> 25:19:17.910
practicalities, go to youtube
channel and go to morality Oh,

24450
25:19:17.910 --> 25:19:21.910
slash projects, guys, you all in
the community. Using Morales,

24451
25:19:21.910 --> 25:19:25.910
you will succeed using rallies,
you will achieve your goal. And

24452
25:19:25.910 --> 25:19:28.910
you're going to do sooner than
you expect yourself. You're

24453
25:19:28.910 --> 25:19:32.910
gonna surprise yourself. But
don't let yourself down. Go to

24454
25:19:32.910 --> 25:19:34.910
morales.io sign up, get started,

24455
25:19:34.910 --> 25:19:41.910
you guys. Now that I've
explained all of that, what does

24456
25:19:41.910 --> 25:19:42.910
this look like? Well, this is
where we're actually going to

24457
25:19:42.910 --> 25:19:46.910
start using mirallas with its
server capabilities. And we're

24458
25:19:46.910 --> 25:19:48.910
going to sign up for a server
here. And we're going to use

24459
25:19:48.910 --> 25:19:52.911
Morales as our back end for our
application. So to get set up

24460
25:19:52.911 --> 25:19:55.911
with Morales, we go to
morales.io. We can go ahead and

24461
25:19:55.911 --> 25:19:59.911
sign up for free. We'll put our
email in, we'll create some

24462
25:19:59.911 --> 25:20:03.911
password. Why are you here?
Other please specify Patrick's

24463
25:20:03.911 --> 25:20:06.911
amazing hardhat video, you don't
have to write that. But if you

24464
25:20:06.911 --> 25:20:09.911
want to write that you can. What
did you hear about Morales for

24465
25:20:09.911 --> 25:20:12.911
the first time? Well, you all
heard about it on YouTube,

24466
25:20:12.911 --> 25:20:14.911
because you heard it from me,
and then pick your roll, I'm

24467
25:20:14.911 --> 25:20:16.911
going to be a developer, we'll
hit next, I don't want to

24468
25:20:16.911 --> 25:20:19.911
subscribe. But I'm going to not
be a robot and create your

24469
25:20:19.911 --> 25:20:22.911
account. And it even gives us a
little property or create your

24470
25:20:22.911 --> 25:20:26.911
first server. So our back end is
going to use a server to do any

24471
25:20:26.911 --> 25:20:30.911
stuff on the back. So we'll
create a server. And if we were

24472
25:20:30.911 --> 25:20:32.911
going to do a main net or a
testament, we choose one of

24473
25:20:32.911 --> 25:20:35.911
those. But for now we're going
to do a local dev chain server.

24474
25:20:35.911 --> 25:20:38.911
And again, this is one of the
advantages of Morales is it

24475
25:20:38.911 --> 25:20:42.911
allows us to work with our local
dev chain. For indexing events,

24476
25:20:42.911 --> 25:20:46.911
we can actually index our events
from our local hard hat node,

24477
25:20:46.911 --> 25:20:48.911
which is incredibly, incredibly
powerful here, so check your

24478
25:20:48.911 --> 25:20:51.911
email, and we'll have an
activate my account thing,

24479
25:20:51.911 --> 25:20:54.911
email, we'll hit activate your
account. And it'll bring us back

24480
25:20:54.911 --> 25:20:56.911
here and we'll recreate and
we'll do local dev chain.

24481
25:20:56.911 --> 25:20:59.911
Alright, so now we're going to
create a new local dev chain

24482
25:20:59.911 --> 25:21:04.911
server. So we're going to call
this NFT marketplace, we're

24483
25:21:04.911 --> 25:21:06.911
going to select the region,
whatever region you want, I'm in

24484
25:21:06.911 --> 25:21:08.911
the eastern United States. So
I'm going to choose New York.

24485
25:21:08.911 --> 25:21:11.911
But whatever location works for
you, we're gonna do local dev

24486
25:21:11.911 --> 25:21:13.911
chain, and we're going to do
eath, local dev chain. And

24487
25:21:13.911 --> 25:21:15.911
again, if you're building for
polygon, if you're building for

24488
25:21:15.911 --> 25:21:17.911
avalanche, if you're building
for Phantom, if you're building

24489
25:21:17.911 --> 25:21:21.911
for any of these EVM compatible
chains, again, your eath local

24490
25:21:21.911 --> 25:21:23.911
dev chain, it's going to work
exactly the same. So we're going

24491
25:21:23.911 --> 25:21:26.911
to add instance now. And we're
going to create a new

24492
25:21:26.911 --> 25:21:30.911
application here. So we're going
to close now we have the server

24493
25:21:30.911 --> 25:21:32.912
here, and it says ganache, but
it's really hard hat. Don't

24494
25:21:32.912 --> 25:21:34.912
worry about that. Now that we
have our server up, we can go to

24495
25:21:34.912 --> 25:21:38.912
the Morales documentation, what
we're looking for is events,

24496
25:21:38.912 --> 25:21:41.912
we're looking to sync with
events. So we can even do a

24497
25:21:41.912 --> 25:21:45.912
little search in here for
events. And we see smart

24498
25:21:45.912 --> 25:21:48.912
contract events platform
Automatic Sync, and even tells

24499
25:21:48.912 --> 25:21:50.912
us a little bit more about why
do we need to sync and watch

24500
25:21:50.912 --> 25:21:53.912
smart contract events. So
basically, this server our

24501
25:21:53.912 --> 25:21:56.912
database is going to be looking
for these events to be emitted.

24502
25:21:56.912 --> 25:21:59.912
But before we can do that, we
need to hook up our application

24503
25:21:59.912 --> 25:22:02.912
to our server and if you go to
the React Morales GitHub right

24504
25:22:02.912 --> 25:22:05.912
at the top And you'll probably
see saw this before, when you

24505
25:22:05.912 --> 25:22:08.912
have this Morales provider in
their docks, they actually pass

24506
25:22:08.912 --> 25:22:11.912
an app ID and a server URL. And
this is how we can actually

24507
25:22:11.912 --> 25:22:16.912
connect directly to our servers
on mirallas. So what we're gonna

24508
25:22:16.912 --> 25:22:19.912
do is right, now we're gonna go
back to our app that Jas and

24509
25:22:19.912 --> 25:22:22.912
originally we've been saying
initialize on Mount equals

24510
25:22:22.912 --> 25:22:25.912
false. When we say this, we're
saying, Hey, we're not going to

24511
25:22:25.912 --> 25:22:28.912
use a morale server, we're just
going to use the open source

24512
25:22:28.912 --> 25:22:31.912
morass tools that y'all provide.
Now, we actually do want to use

24513
25:22:31.912 --> 25:22:33.912
their server, right, we do want
to use all these bells and

24514
25:22:33.912 --> 25:22:35.912
whistles that Morales comes with
out of the box. So we're going

24515
25:22:35.912 --> 25:22:38.912
to change that. So instead of
saying initialize on Mount

24516
25:22:38.912 --> 25:22:40.912
equals false, we're just getting
ready with the app ID and the

24517
25:22:40.912 --> 25:22:43.912
server URL. So we're going to
delete this. And just like it

24518
25:22:43.912 --> 25:22:46.912
says, in the documentation,
we're gonna give it an app ID

24519
25:22:46.912 --> 25:22:49.912
and a server URL. So we're gonna
say app ID equals, and this is

24520
25:22:49.912 --> 25:22:52.912
where as a string, we'll put our
app ID. So if we go back to our

24521
25:22:52.912 --> 25:22:56.912
Morales database, we can go to
view details. And we see all

24522
25:22:56.912 --> 25:23:00.912
this information in here. And we
can grab our application ID, we

24523
25:23:00.912 --> 25:23:04.912
can copy it, paste it in here.
And then we'll want to grab our

24524
25:23:04.912 --> 25:23:09.912
server URL, which is at the top.
So this is the URL of our unique

24525
25:23:09.912 --> 25:23:14.913
custom morale server. So we'll
say server, URL equals and then

24526
25:23:14.913 --> 25:23:16.913
paste that in there like that.
Now, if you've been following

24527
25:23:16.913 --> 25:23:18.913
along with these tutorials, you
might be thinking oh, we're

24528
25:23:18.913 --> 25:23:20.913
we're kind of just hard coding
that stuff right in there like

24529
25:23:20.913 --> 25:23:24.913
that, how that seems kind of
that seems kind of bad. Well, if

24530
25:23:24.913 --> 25:23:27.913
that's your intuition, that is
fantastic. So instead, we're

24531
25:23:27.913 --> 25:23:29.913
actually going to put these into
environment variables. So we're

24532
25:23:29.913 --> 25:23:34.913
going to create a new file, a
dot env file. And this is where

24533
25:23:34.913 --> 25:23:36.913
we're going to put all of our
environment variables. Now next,

24534
25:23:36.913 --> 25:23:39.913
Jas comes with built in support
for environment variables, which

24535
25:23:39.913 --> 25:23:43.913
allow you to do the following
use dot env, dot local to load

24536
25:23:43.913 --> 25:23:45.913
environment variables or those
environment variables to the

24537
25:23:45.913 --> 25:23:48.913
browser by prefixing. It with
next underscore public. So

24538
25:23:48.913 --> 25:23:50.913
there's a couple of different
environment variable paths we

24539
25:23:50.913 --> 25:23:53.913
can use. We can do dot env, dot
local, we can do dot env, dot

24540
25:23:53.913 --> 25:23:55.913
this dot that that the other
thing, we're just going to do

24541
25:23:55.913 --> 25:23:58.913
dot env, to keep it simple here.
But in order for our front ends,

24542
25:23:58.913 --> 25:24:01.913
to read environment variables
from our dot env file, we have

24543
25:24:01.913 --> 25:24:06.913
to do next underscore public
underscore, and next Jas will

24544
25:24:06.913 --> 25:24:09.913
look into our dot env file for
variables that start with this

24545
25:24:09.913 --> 25:24:13.913
and only stick these environment
variables into our application.

24546
25:24:13.913 --> 25:24:16.913
If we were to just do like
Morales server equals blah,

24547
25:24:16.913 --> 25:24:20.913
blah, blah, it has no idea what
this is because we need to do

24548
25:24:20.913 --> 25:24:24.913
next underscore public
underscore. And if we do that,

24549
25:24:24.913 --> 25:24:28.913
and we'll do a console dot log,
look here, process dot env. Next

24550
25:24:28.913 --> 25:24:31.913
public morale server and we
actually need to kill it and

24551
25:24:31.913 --> 25:24:34.913
restart it. And then we go back,
we do a little refresh here,

24552
25:24:34.913 --> 25:24:37.913
it'll say Look here as a do bla
bla bla, because that's what is

24553
25:24:37.913 --> 25:24:41.913
in the dot env file with that
next public. So we'll grab our

24554
25:24:41.913 --> 25:24:48.913
app ID, we'll copy it. And then
our dot env will do next public

24555
25:24:48.913 --> 25:24:52.914
app ID equals and we'll paste
that in there. We'll grab our

24556
25:24:52.914 --> 25:24:57.914
server URL, we'll go back to
here. We'll do next public

24557
25:24:57.914 --> 25:25:02.914
server URL equals, we'll paste
that like that. And now at the

24558
25:25:02.914 --> 25:25:10.914
top, we'll say const. App ID
equals process dot E and V dot

24559
25:25:10.914 --> 25:25:16.914
next, public app ID. And then
we'll say const. Server URL

24560
25:25:16.914 --> 25:25:23.914
equals process dot E and V dot
next public server URL. Now that

24561
25:25:23.914 --> 25:25:28.914
we've had these variables, we'll
stick them in like this.

24562
25:25:28.914 --> 25:25:32.914
So this is how we can connect
our application to our morale

24563
25:25:32.914 --> 25:25:35.914
server. Now, of course, we
haven't done anything yet. But

24564
25:25:35.914 --> 25:25:37.914
we're getting started, right?
This is how we're going to

24565
25:25:37.914 --> 25:25:40.914
connect to it. Now that we've
signed in, well, I told you that

24566
25:25:40.914 --> 25:25:43.914
our morale server was going to
be indexing our events. And if

24567
25:25:43.914 --> 25:25:46.914
you go to this Dashboard button,
this is our entire database.

24568
25:25:46.914 --> 25:25:49.914
Everything in this browser tab
is what's in our database right

24569
25:25:49.914 --> 25:25:51.914
now. And as you can see, right
now, there's not a whole lot of

24570
25:25:51.914 --> 25:25:55.914
anything, if we had any events
data in here, it would be in

24571
25:25:55.914 --> 25:25:58.914
here. So we need to tell our
server, hey, you need to start

24572
25:25:58.914 --> 25:26:01.914
listening for events. So we can
show the most recently listed

24573
25:26:01.914 --> 25:26:04.914
entities. So morale server, you
need to start listening, you

24574
25:26:04.914 --> 25:26:07.914
need to create a database entry
for every single one of these

24575
25:26:07.914 --> 25:26:11.914
item listed events. And whenever
somebody buys an item, right,

24576
25:26:11.914 --> 25:26:14.914
whenever somebody buys that
item, or cancels an item, you

24577
25:26:14.914 --> 25:26:17.914
need to remove that from your
database. How do we start

24578
25:26:17.914 --> 25:26:20.914
telling Morales to start
listening to our events? Well,

24579
25:26:20.914 --> 25:26:22.914
first off, well, first off,
we're gonna need to connect it

24580
25:26:22.914 --> 25:26:26.914
back to to our blockchain. And
then we're going to say, which

24581
25:26:26.914 --> 25:26:30.914
contract which events and what
to do when it hears those

24582
25:26:30.914 --> 25:26:32.915
events. So we need to connect it
and then we need to tell it what

24583
25:26:32.915 --> 25:26:35.915
to do when it hears those
events. So how do we connect our

24584
25:26:35.915 --> 25:26:38.915
mirallas server to our hard hat
blockchain? And right now, we're

24585
25:26:38.915 --> 25:26:41.915
not running one. But let's go
ahead and we'll start up our

24586
25:26:41.915 --> 25:26:45.915
hard hat, our local host
blockchain. So in one terminal,

24587
25:26:45.915 --> 25:26:48.915
we're running the front end and
another terminal will see the

24588
25:26:48.915 --> 25:26:52.915
download directory. We'll cd
into our hard hat NFT

24589
25:26:52.915 --> 25:26:56.915
marketplace dot Free Code Camp
or Free Code Camp, and we'll do

24590
25:26:56.915 --> 25:27:00.915
yarn hard hat node. And if we've
done everything correctly, it'll

24591
25:27:00.915 --> 25:27:03.915
deploy our NFT marketplace.
It'll deploy our Basic NFT and

24592
25:27:03.915 --> 25:27:07.915
then it'll start local HTTP web
socket at blah, blah, blah. So

24593
25:27:07.915 --> 25:27:09.915
that's good. So now that we have
that Node running, what we can

24594
25:27:09.915 --> 25:27:14.915
do is we can go to view details,
and go to dev chain proxy

24595
25:27:14.915 --> 25:27:18.915
server. So this dev chain proxy
server is going to be how we

24596
25:27:18.915 --> 25:27:22.915
actually tell Morales to listen
to our locally running hard hat

24597
25:27:22.915 --> 25:27:25.915
node. Now, to do this, what
you're going to need to do is

24598
25:27:25.915 --> 25:27:28.915
we're going to need to download
this what's called a reverse

24599
25:27:28.915 --> 25:27:32.915
proxy. And I have a link to this
in the GitHub as well, depending

24600
25:27:32.915 --> 25:27:35.915
on what computer you're running
on will tell you which one of

24601
25:27:35.915 --> 25:27:37.915
these we actually need to
download. And then there's some

24602
25:27:37.915 --> 25:27:40.915
troubleshooting tips down here
if you ever get lost, and if

24603
25:27:40.915 --> 25:27:46.915
you're really, really confused,
what we can do what Morales FRP

24604
25:27:46.915 --> 25:27:50.915
to download, do a quick search
on this. We even come right to

24605
25:27:50.915 --> 25:27:54.915
the documentation, connecting
ganache to Morales note for Mac

24606
25:27:54.915 --> 25:27:58.915
users download FRP dot Darwin
dot bla bla bla for the nosh

24607
25:27:58.915 --> 25:28:01.915
proxy server. So I'm on a Mac.
So I'm going to download this

24608
25:28:01.915 --> 25:28:05.915
Darwin AMD 64. And for look at
the releases, that's the first

24609
25:28:05.915 --> 25:28:08.915
one at the top, Darwin AMD 64.
So this is the one that I'm

24610
25:28:08.915 --> 25:28:10.915
going to go ahead and download.

24611
25:28:10.915 --> 25:28:13.916
I'm gonna click it, I'm going to
download it. Once I have it

24612
25:28:13.916 --> 25:28:16.916
downloaded, we're going to open
it up, and we're gonna get a

24613
25:28:16.916 --> 25:28:18.916
folder and we're gonna get a
folder that looks like this. The

24614
25:28:18.916 --> 25:28:23.916
main things that we need are
going to be f RP and FRP C dot

24615
25:28:23.916 --> 25:28:27.916
ini. F RPC is going to be the
executable it's going to be what

24616
25:28:27.916 --> 25:28:31.916
we're going to run to connect
our blockchain node to Morales,

24617
25:28:31.916 --> 25:28:34.916
and F RPC dot ini is going to be
basically the config file to do

24618
25:28:34.916 --> 25:28:38.916
this. Now, again, this is one of
the sections where downloading

24619
25:28:38.916 --> 25:28:40.916
this is going to be one of the
hardest steps here. So if you

24620
25:28:40.916 --> 25:28:43.916
get lost, please ask questions
in the GitHub, please ask

24621
25:28:43.916 --> 25:28:46.916
questions in the Morales forum,
there is a Morales forum as

24622
25:28:46.916 --> 25:28:48.916
well, where you can ask a ton of
different questions. And please

24623
25:28:48.916 --> 25:28:51.916
check out the troubleshooting as
well. But what I'm going to do

24624
25:28:51.916 --> 25:28:55.916
is I'm going to create a new
folder in here new folder called

24625
25:28:55.916 --> 25:28:58.916
F R P. And I'm doing it in here
just to make it a little easier.

24626
25:28:58.916 --> 25:29:01.916
But you could really put this
wherever you want, and then

24627
25:29:01.916 --> 25:29:03.916
always refer back to it. And
what I'm going to do is I'm

24628
25:29:03.916 --> 25:29:07.916
going to take I'm going to copy
these two files, and place it

24629
25:29:07.916 --> 25:29:12.916
into this FRP folder. So now I
have FRP C, and F RPC that ini

24630
25:29:12.916 --> 25:29:15.916
if you click on the F RPC, it's
going to be like, hey, it's

24631
25:29:15.916 --> 25:29:18.916
binary, you can't really look at
this, don't click that, it'll

24632
25:29:18.916 --> 25:29:21.916
just be a whole bunch of
nonsense, but the F RPC dot ini

24633
25:29:21.916 --> 25:29:24.916
looks like a pretty typical
config file. And this is what

24634
25:29:24.916 --> 25:29:28.916
we're going to adjust. If we
even go back to our morale

24635
25:29:28.916 --> 25:29:32.916
server, it'll give you what you
need down here. And we're using

24636
25:29:32.916 --> 25:29:36.916
hard hat. So we're going to copy
everything here. We're gonna go

24637
25:29:36.916 --> 25:29:40.916
back to our F RPC dot ini, and
then just paste whatever is in

24638
25:29:40.916 --> 25:29:43.916
there in here. And that's how
we're going to tell this F RPC

24639
25:29:43.916 --> 25:29:46.916
thing that we need to connect. I
haven't tried this out for users

24640
25:29:46.916 --> 25:29:50.916
using WsL. So if you're using
WsL, let us know in the full

24641
25:29:50.916 --> 25:29:53.917
blockchain solidity course, Jas,
make a new discussion, if you

24642
25:29:53.917 --> 25:29:56.917
haven't seen it already, saying,
Hey, I'm using WsL for the F

24643
25:29:56.917 --> 25:29:59.917
RPC. And here's what you need to
use. And then at the bottom, it

24644
25:29:59.917 --> 25:30:03.917
says, run and enjoy. I'm running
on a Mac OS, which runs Linux

24645
25:30:03.917 --> 25:30:06.917
commands, so I can just copy
this, I'll create a new

24646
25:30:06.917 --> 25:30:09.917
terminal. And what I'm going to
do is I'm going to cd into that

24647
25:30:09.917 --> 25:30:14.917
FRP folder. And I'm going to
paste that thing that I just

24648
25:30:14.917 --> 25:30:17.917
that I just copied from Ross. So
we're running that F RPC

24649
25:30:17.917 --> 25:30:22.917
executable dash c, which is dash
config, F RPC dot ini. If I hit

24650
25:30:22.917 --> 25:30:27.917
Enter, it's gonna say log into
server success, get run ID,

24651
25:30:27.917 --> 25:30:30.917
blah, blah, server, UDP port,
and then a whole bunch of other

24652
25:30:30.917 --> 25:30:33.917
stuff. If you're seeing success
stuff here, that means you did

24653
25:30:33.917 --> 25:30:37.917
it right. And you can hit CTRL C
to cancel because we're not

24654
25:30:37.917 --> 25:30:40.917
going to keep running it. Now,
if you want to just run this,

24655
25:30:40.917 --> 25:30:43.917
you absolutely can. But I'm
going to show you another way to

24656
25:30:43.917 --> 25:30:48.917
do this. And this is using the
Morales admin CLI. So everything

24657
25:30:48.917 --> 25:30:50.917
that we're doing here, all these
buttons that we're pressing,

24658
25:30:50.917 --> 25:30:53.917
Morales actually comes with this
thing called the Morales admin

24659
25:30:53.917 --> 25:30:57.917
CLI or the command line
interface. So this is a way for

24660
25:30:57.917 --> 25:30:59.917
us to connect and run all these
buttons and stuff that we're

24661
25:30:59.917 --> 25:31:02.917
pressing right from our terminal
and right from our shell. So I'm

24662
25:31:02.917 --> 25:31:05.917
going to show you a couple of
commands on how to work with the

24663
25:31:05.917 --> 25:31:08.917
admin CLI. And we're going to be
working with a lot of admin CLI

24664
25:31:08.917 --> 25:31:11.917
commands. But all we're going to
do is npm install dash g

24665
25:31:11.917 --> 25:31:15.917
Morales, admin CLI or for us
yarn Global Add. So we're going

24666
25:31:15.917 --> 25:31:20.917
to grab that will do yarn,
Global Add routes, admin CLI

24667
25:31:20.917 --> 25:31:26.917
like that. And now we should be
able to run Morales admin CLI

24668
25:31:26.917 --> 25:31:28.917
and see a whole bunch of stuff
like that. And if you ran

24669
25:31:28.917 --> 25:31:32.918
routes, admin CLI, we have all
this stuff. And one of the big

24670
25:31:32.918 --> 25:31:34.918
ones, one of the important ones
that we're going to be working

24671
25:31:34.918 --> 25:31:39.918
with is this connect local dev
chain. So running this F RPC

24672
25:31:39.918 --> 25:31:43.918
dash c dash f RPC ini. That's
going to be the same as running

24673
25:31:43.918 --> 25:31:47.918
this connect local dev chain.
Now what I like to do is jump

24674
25:31:47.918 --> 25:31:51.918
into our package dot JSON. And
we'll create an additional

24675
25:31:51.918 --> 25:31:55.918
script in here for us to just
run yarn, whatever the name is

24676
25:31:55.918 --> 25:31:57.918
that we want, and just to do
that, and just to make it a lot

24677
25:31:57.918 --> 25:32:01.918
easier for us to connect our
local dev chain so underneath

24678
25:32:01.918 --> 25:32:04.918
lint, I'm going to do a calm
Ma'am, I'm going to create a new

24679
25:32:04.918 --> 25:32:09.918
command. I'm gonna say Morales
sync. And we're going to run the

24680
25:32:09.918 --> 25:32:14.918
Morales admin CLI version of
this f RPC dash c thing. So what

24681
25:32:14.918 --> 25:32:17.918
we're going to do in here is
we're going to say mirallas

24682
25:32:17.918 --> 25:32:27.918
admin CLI, connect local dev
chain, dash dash chain, hard

24683
25:32:27.918 --> 25:32:33.918
hat, dash dash mirallas. Capital
sub domain.

24684
25:32:33.918 --> 25:32:36.918
This is where we're going to put
the subdomain of a morale

24685
25:32:36.918 --> 25:32:40.918
server, which if we go to, we go
back to our routes, admin data

24686
25:32:40.918 --> 25:32:44.918
servers, we can go back to
server details. So it's going to

24687
25:32:44.918 --> 25:32:47.918
be not the HTTPS, it's just
going to be from here all the

24688
25:32:47.918 --> 25:32:51.918
way to the.com. So not even the
port, we're going to grab that

24689
25:32:51.918 --> 25:32:54.918
we're going to paste that there.
And then we're going to do space

24690
25:32:54.918 --> 25:33:04.918
dash dash f RPC path is going to
be dot slash F RPC, slash FRP

24691
25:33:04.918 --> 25:33:07.918
slash F RPC. Now if we save
this, and we run it, it's not

24692
25:33:07.918 --> 25:33:11.918
going to work though. So if I
run yarn with our new script,

24693
25:33:11.918 --> 25:33:14.919
Morales sync, it's gonna say
specify Morales API key, it's

24694
25:33:14.919 --> 25:33:18.919
going to give us this prompt.
And in our dashboard, we have

24695
25:33:18.919 --> 25:33:21.919
our API key, which we can copy,
we can paste it, and then API

24696
25:33:21.919 --> 25:33:24.919
secret, we can copy and then
paste it. And then we'll say

24697
25:33:24.919 --> 25:33:27.919
starting connection to hard hat,
which is great. But that's

24698
25:33:27.919 --> 25:33:29.919
really annoying. And I don't
want to have to do that. So

24699
25:33:29.919 --> 25:33:31.919
we're going to Ctrl C, we're
going to kill that. And what we

24700
25:33:31.919 --> 25:33:36.919
can do is we can go into our dot
env. And we can actually add

24701
25:33:36.919 --> 25:33:40.919
those as environment variables
that Morales is expecting. So

24702
25:33:40.919 --> 25:33:44.919
when we run this Morales admin
CLI, it'll check our dot env

24703
25:33:44.919 --> 25:33:50.919
file for Morales API key, which
we can copy right here. And then

24704
25:33:50.919 --> 25:33:57.919
Morales API secret, which we can
copy, and paste right here. Now,

24705
25:33:57.919 --> 25:33:59.919
the reason that these aren't
capital and doing next public,

24706
25:33:59.919 --> 25:34:03.919
these are not going to be part
of our front end piece. These

24707
25:34:03.919 --> 25:34:06.919
are keys that we're using on the
back end to test and for our

24708
25:34:06.919 --> 25:34:10.919
local dev chain connection. So
we don't need to do next public,

24709
25:34:10.919 --> 25:34:12.919
we're just going to leave it
like this. But now if I hit up

24710
25:34:12.919 --> 25:34:15.919
and run yarn Morales sync,
again, it's not going to prompt

24711
25:34:15.919 --> 25:34:18.919
me this time, it's just gonna
say starting connection to hard

24712
25:34:18.919 --> 25:34:21.919
hat. And if you see this, this
starting connection to hard hat

24713
25:34:21.919 --> 25:34:24.919
bit, we can come back to our
servers, we'll go to dev chain

24714
25:34:24.919 --> 25:34:29.919
proxy servers, we'll hit this
disconnected button and refresh.

24715
25:34:29.919 --> 25:34:32.919
And if you see connected, you've
successfully connected our heart

24716
25:34:32.919 --> 25:34:37.919
add node, which is running here
to our Morales server, which is

24717
25:34:37.919 --> 25:34:40.919
awesome. And in fact, if you sit
on your heart had no terminal,

24718
25:34:40.919 --> 25:34:45.919
you'll see the actual RPC calls
to our blockchain here. And

24719
25:34:45.919 --> 25:34:49.919
you'll see Morales is
consistently calling f block

24720
25:34:49.919 --> 25:34:55.920
number to make sure it's up to
date with what it has. So how do

24721
25:34:55.920 --> 25:34:59.920
we tell a morale server to start
listening for events? Well,

24722
25:34:59.920 --> 25:35:02.920
there are two ways we can do
this. The first way is with the

24723
25:35:02.920 --> 25:35:06.920
user interface. So we can go to
view details, we'll go to sync.

24724
25:35:06.920 --> 25:35:09.920
And right now it says no sync
services installed. So we'll hit

24725
25:35:09.920 --> 25:35:14.920
Add a new sync. And we can see
sync and watch address and sync

24726
25:35:14.920 --> 25:35:16.920
and watch contract events, we
can watch the address for

24727
25:35:16.920 --> 25:35:20.920
transactions or we can watch
some address for any events. And

24728
25:35:20.920 --> 25:35:23.920
we can manually add all our
information here, you can select

24729
25:35:23.920 --> 25:35:26.920
the chain description, decide if
we want to optionally sync

24730
25:35:26.920 --> 25:35:29.920
historical, we could put the
topic of the event, the ABI of

24731
25:35:29.920 --> 25:35:32.920
the event, the address of the
event filter, and then a table

24732
25:35:32.920 --> 25:35:34.920
name. Or we could do all this
programmatically, which is what

24733
25:35:34.920 --> 25:35:37.920
we're going to do, we'll create
a little script that we can run,

24734
25:35:37.920 --> 25:35:40.920
tell our morale server to watch
for those scripts. And we'll see

24735
25:35:40.920 --> 25:35:44.920
our database get upgraded to
listen for those events. So back

24736
25:35:44.920 --> 25:35:48.920
in our code, we're going to
create a new file called add

24737
25:35:48.920 --> 25:35:52.920
events that Jas now we have one
terminal that's running our

24738
25:35:52.920 --> 25:35:55.920
front end one terminal that's
running our blockchain one

24739
25:35:55.920 --> 25:35:58.920
terminal that syncing our
blockchain with morass. And now

24740
25:35:58.920 --> 25:36:00.920
we're going to do another
terminal. For anything else we

24741
25:36:00.920 --> 25:36:02.920
want to do like run little
scripts become the Morales

24742
25:36:02.920 --> 25:36:05.920
docks, and you click connect
with SDK, there's a ton of

24743
25:36:05.920 --> 25:36:08.920
different ways we can actually
connect with the SDK, we've

24744
25:36:08.920 --> 25:36:10.920
already learned how to connect
with react by using React

24745
25:36:10.920 --> 25:36:14.920
Morales. Now we're going to
connect with no JS since we're

24746
25:36:14.920 --> 25:36:17.920
going to run a little Morales
script. And here's like a little

24747
25:36:17.920 --> 25:36:20.920
example of what it looks like in
the documentation. But I'm gonna

24748
25:36:20.920 --> 25:36:25.920
go ahead, so I'm gonna say const
Morales, equals require oralis

24749
25:36:25.920 --> 25:36:29.920
slash node. And we're going to
import the node extension of the

24750
25:36:29.920 --> 25:36:33.921
Morales package into our script
here, we're going to require dot

24751
25:36:33.921 --> 25:36:34.921
env

24752
25:36:34.921 --> 25:36:39.921
dot config, which means we're
going to need to install dot env

24753
25:36:39.921 --> 25:36:44.921
yarn add dash dash dev dot env.
And now we have to tell our

24754
25:36:44.921 --> 25:36:47.921
morale server all the same
information that we would need

24755
25:36:47.921 --> 25:36:49.921
to tell it on the user
interface. So one of the first

24756
25:36:49.921 --> 25:36:51.921
things that we're going to need
is the address of our contract.

24757
25:36:51.921 --> 25:36:55.921
We're gonna need to say const
contract address equals and this

24758
25:36:55.921 --> 25:36:58.921
is where we go oh, well, how do
we how do we get that contract

24759
25:36:58.921 --> 25:37:01.921
address? The easy way to do this
is we just go back where we're

24760
25:37:01.921 --> 25:37:05.921
running the blockchain And we'd
grab where that NFC marketplace

24761
25:37:05.921 --> 25:37:09.921
is deployed. And similar to our
smart contract lottery where we

24762
25:37:09.921 --> 25:37:11.921
created an update front end
script, we're gonna do the exact

24763
25:37:11.921 --> 25:37:15.921
same thing here. So back in our
heart hat, NFT marketplace, and

24764
25:37:15.921 --> 25:37:18.921
if T code, we go to our deploy
script or deploy folder, we're

24765
25:37:18.921 --> 25:37:25.921
gonna create a new file called
99 Dash update, front end dot j

24766
25:37:25.921 --> 25:37:27.921
s, and we're gonna create a
little bit of our deploy process

24767
25:37:27.921 --> 25:37:31.921
that will automatically update
our front end. So we can just

24768
25:37:31.921 --> 25:37:34.921
grab the network address from a
file that is programmatically

24769
25:37:34.921 --> 25:37:38.921
created. So we're gonna do
module dot exports equals async

24770
25:37:38.921 --> 25:37:44.921
function. And now we'll say if
process dot EMV that update

24771
25:37:44.921 --> 25:37:53.921
front end, then console dot log,
updating front end so that in

24772
25:37:53.921 --> 25:37:57.921
our dot EMV, we have update
front end equals true. And that

24773
25:37:57.921 --> 25:38:00.921
will be how we decide whether or
not we actually want to update

24774
25:38:00.921 --> 25:38:03.921
the front end. And then we'll
create a function called up date

24775
25:38:03.921 --> 25:38:07.921
contract addresses, which we
will await. And this will update

24776
25:38:07.921 --> 25:38:10.921
the contract addresses of our
front end. So let's make that

24777
25:38:10.921 --> 25:38:16.922
function. Do async function
update contract addresses, make

24778
25:38:16.922 --> 25:38:21.922
sure those are spelled the same.
So we'll say const NFT, market

24779
25:38:21.922 --> 25:38:27.922
place equals await ethers dot
get contract. And then yes, we

24780
25:38:27.922 --> 25:38:30.922
need to import const ethers
equals require hardhat, we'll

24781
25:38:30.922 --> 25:38:34.922
grab the NFT market place. And
then we're going to want to

24782
25:38:34.922 --> 25:38:39.922
write our files in here to
someplace in our front end code

24783
25:38:39.922 --> 25:38:43.922
for us, we're going to do in a
new folder constants. And we're

24784
25:38:43.922 --> 25:38:48.922
going to create a new file in
here called network mapping dot

24785
25:38:48.922 --> 25:38:52.922
JSON. And we'll have this just
be a JSON object which keeps

24786
25:38:52.922 --> 25:38:56.922
track of all of our deployments.
So if we deploy something to

24787
25:38:56.922 --> 25:38:59.922
rink V chain will keep a list
will keep a list of it will say

24788
25:38:59.922 --> 25:39:03.922
NFT marketplace will keep a list
of all the addresses of the IoT

24789
25:39:03.922 --> 25:39:08.922
marketplace, comma basic NF T,
right, and then I list of all

24790
25:39:08.922 --> 25:39:11.922
those right now we don't have
anything deployed. So we'll just

24791
25:39:11.922 --> 25:39:15.922
have it be an empty JSON object.
Now back in our deploy script in

24792
25:39:15.922 --> 25:39:19.922
the hard hat NFT marketplace
project, we're going to keep

24793
25:39:19.922 --> 25:39:22.922
track of that location. So right
at the top, we're gonna say

24794
25:39:22.922 --> 25:39:29.922
const. Front, and contracts file
equals, and we'll place where it

24795
25:39:29.922 --> 25:39:35.922
is according to your file setup.
So if I do cd dot dot slash,

24796
25:39:35.922 --> 25:39:39.922
next JS NFT, marketplace, free
code, Camp constants, network

24797
25:39:39.922 --> 25:39:42.922
mapping dot JSON, this is where
mine is. So you're going to want

24798
25:39:42.922 --> 25:39:46.922
to put it wherever your location
is in relation to your heart at

24799
25:39:46.922 --> 25:39:49.922
Mt marketplace Free Code Camp,
it's my front end contract file,

24800
25:39:49.922 --> 25:39:51.922
it's going to be right here. Now
that we have all that we're

24801
25:39:51.922 --> 25:39:55.923
going to get the chain ID. So
we're gonna say const, chain ID

24802
25:39:55.923 --> 25:40:01.923
equals network dot config dot
chain, id.to string. And we're

24803
25:40:01.923 --> 25:40:05.923
going to need to import network
from hard hat as well. And then

24804
25:40:05.923 --> 25:40:08.923
we're going to want to read from
this network mapping file to see

24805
25:40:08.923 --> 25:40:13.923
what's currently in there. So
we'll say const. Contract

24806
25:40:13.923 --> 25:40:19.923
addresses equals and we're gonna
do a JSON dot parse Fs dot read

24807
25:40:19.923 --> 25:40:28.923
file sync, front, and front and
contracts. File comma UTF,

24808
25:40:28.923 --> 25:40:33.923
eight. Now here's what we're
gonna say, if chain ID is in

24809
25:40:33.923 --> 25:40:38.923
contract. addresses, let's say
if this list of contract

24810
25:40:38.923 --> 25:40:42.923
addresses doesn't include the
marketplace, then added on,

24811
25:40:42.923 --> 25:40:46.923
we're gonna say if contract
addresses of chain ID of the

24812
25:40:46.923 --> 25:40:56.923
NFT. Marketplace will say dot
includes NF T, market, Mar get

24813
25:40:56.923 --> 25:41:02.923
place dot address, then so we'll
say contract address says chain

24814
25:41:02.923 --> 25:41:12.923
ID NFT marketplace, dot push NFT
marketplace dot address else

24815
25:41:12.923 --> 25:41:14.923
we're gonna say contract

24816
25:41:14.923 --> 25:41:20.923
address says of chain ID of NFT
marketplace, which is going to

24817
25:41:20.923 --> 25:41:28.923
be a new entry now equals NFT.
Market market place dot address.

24818
25:41:28.923 --> 25:41:31.923
So now we've updated our
contract addresses object and we

24819
25:41:31.923 --> 25:41:34.924
just need to write it back to
the network mapping. So now

24820
25:41:34.924 --> 25:41:39.924
we're gonna say Fs dot right
file sync front and contracts

24821
25:41:39.924 --> 25:41:47.924
file comma JSON dot string five
contract addresses and then at

24822
25:41:47.924 --> 25:41:51.924
the bottom we'll do module dot
exports dot tags equals and

24823
25:41:51.924 --> 25:41:56.924
we'll say all or front end. Now
what we can do is we can run

24824
25:41:56.924 --> 25:42:02.924
just this update front end
script with yarn hardhat deploy

24825
25:42:02.924 --> 25:42:07.924
dashed dash, network localhost.
And we only want to do this

24826
25:42:07.924 --> 25:42:11.924
update front end script. So we
say dash dash tags front end,

24827
25:42:11.924 --> 25:42:15.924
and we run this, and I ran into
an error FS is not defined, oh,

24828
25:42:15.924 --> 25:42:22.924
I forgot to do const Fs equals
require Fs stride again, cannot

24829
25:42:22.924 --> 25:42:26.924
set properties of undefined NFT
marketplace. Oops. And that's

24830
25:42:26.924 --> 25:42:30.924
because this line is off instead
of this line, sorry. Basically,

24831
25:42:30.924 --> 25:42:32.924
right now, what it's saying is,
it's saying, hey, this NFT

24832
25:42:32.924 --> 25:42:36.924
marketplace thing doesn't exist.
So we need to make it exists. So

24833
25:42:36.924 --> 25:42:41.924
now we'll say contract addresses
of chain ID equals a new entry

24834
25:42:41.924 --> 25:42:45.924
of NFT marketplace and adds its
first parameter, it's going to

24835
25:42:45.924 --> 25:42:52.924
be NF T, Mark gets placed dot
address, like that. Now we can

24836
25:42:52.924 --> 25:42:56.924
run it, and updating front end
looks like it's done. So if we

24837
25:42:56.924 --> 25:42:59.924
go back to our front end, we now
see we have an entry for

24838
25:42:59.924 --> 25:43:03.924
localhost with NFC marketplace
with the address in our network

24839
25:43:03.924 --> 25:43:05.924
mapping dot JSON. So if you did
that correctly, you should get

24840
25:43:05.924 --> 25:43:08.924
this. If not, if you're having a
hard time with that you can, of

24841
25:43:08.924 --> 25:43:10.924
course, just go ahead and hard
coded in but I do highly

24842
25:43:10.924 --> 25:43:12.925
recommend you do it
programmatically, because your

24843
25:43:12.925 --> 25:43:14.925
life is going to be a lot
better. So cool. We have this

24844
25:43:14.925 --> 25:43:17.925
update front end script that
works now, so we can put this

24845
25:43:17.925 --> 25:43:21.925
back off to the side. And let's
keep going. So we now have this

24846
25:43:21.925 --> 25:43:24.925
network mapping file with
contract addresses based off of

24847
25:43:24.925 --> 25:43:28.925
the chain ID. So what we can do
is we can pull that in as well,

24848
25:43:28.925 --> 25:43:35.925
we'll say const contract,
address says equals require dot

24849
25:43:35.925 --> 25:43:41.925
slash constants, slash network
mapping dot JSON. And now we can

24850
25:43:41.925 --> 25:43:44.925
get the contract address based
off the chain ID. So we'll say

24851
25:43:44.925 --> 25:43:54.925
chain ID equals process dot E
and V dot chain ID, or 31337. So

24852
25:43:54.925 --> 25:43:59.925
in our data and V, we'll make a
new entry called Chain ID. And

24853
25:43:59.925 --> 25:44:03.925
for now, we'll do 31337. And now
we can get the contract address

24854
25:44:03.925 --> 25:44:07.925
by saying contract address
equals contract addresses at the

24855
25:44:07.925 --> 25:44:15.925
chain ID of n, f t, Mark get
place of zero. So we're going to

24856
25:44:15.925 --> 25:44:18.925
go into that network mapping, go
to the chain, Id go to the NFT

24857
25:44:18.925 --> 25:44:21.925
marketplace and get the most
recently deployed NFT

24858
25:44:21.925 --> 25:44:24.925
marketplace boom. So now we have
the contract address contract

24859
25:44:24.925 --> 25:44:28.925
address says Excuse me. Now in
our add events, we'll create a

24860
25:44:28.925 --> 25:44:31.925
new function kind of similar to
what we're doing, we'll do async

24861
25:44:31.925 --> 25:44:35.925
function main. And this will be
our main function. And then of

24862
25:44:35.925 --> 25:44:38.925
course, we're going to copy
paste that main script thing

24863
25:44:38.925 --> 25:44:42.925
we've been doing this whole time
domain dot then catch blah,

24864
25:44:42.925 --> 25:44:45.925
blah, blah, we go back to the
morass documentation, though, we

24865
25:44:45.925 --> 25:44:48.925
can see we're going to need to
grab our server URL, app ID

24866
25:44:49.925 --> 25:44:52.925
master key, and then start it
up. So we're gonna do the exact

24867
25:44:52.925 --> 25:44:55.926
same thing. So once again,
sorry, before we even get into

24868
25:44:55.926 --> 25:44:57.926
our main, you can do it in your
main function, if you want.

24869
25:44:57.926 --> 25:45:02.926
We'll say const server URL
equals, and we can just grab

24870
25:45:02.926 --> 25:45:07.926
this once again, from our web.
So we'll say process web dot

24871
25:45:07.926 --> 25:45:14.926
next public Morales server URL,
we'll get the app ID equals

24872
25:45:14.926 --> 25:45:21.926
process Studien v dot next
public Morales app ID, and then

24873
25:45:21.926 --> 25:45:26.926
we'll say const, master key
equals process study v dot

24874
25:45:26.926 --> 25:45:30.926
master key. So we don't have a
master key in here yet. So we'll

24875
25:45:30.926 --> 25:45:34.926
create a new one called master
key. We'll go back to our

24876
25:45:34.926 --> 25:45:38.926
Morales front end, we'll close
out of this, we'll hit View

24877
25:45:38.926 --> 25:45:42.926
Details. And we'll grab that
master key. So we'll copy that,

24878
25:45:42.926 --> 25:45:45.926
go back to our code editor and
paste it in. And now we have a

24879
25:45:45.926 --> 25:45:49.926
master key in our web as well.
We don't want our master key on

24880
25:45:49.926 --> 25:45:52.926
our front end. So we're not
going to put next public like

24881
25:45:52.926 --> 25:45:55.926
that. Now, the first thing we're
going to do in our main function

24882
25:45:55.926 --> 25:46:00.926
is we're going to do await
Morales dot start server URL,

24883
25:46:00.926 --> 25:46:05.926
app ID and master key as the
input parameters for this will

24884
25:46:05.926 --> 25:46:11.926
do a little console dot log,
working with contract address,

24885
25:46:11.926 --> 25:46:15.926
contract address. Now we're
gonna go ahead and add all those

24886
25:46:15.926 --> 25:46:18.926
same pieces that we see on the
UI. So what are the events we

24887
25:46:18.926 --> 25:46:23.926
want to listen for? Well, if we
go back to our code here, so we

24888
25:46:23.926 --> 25:46:27.926
have our NFT marketplace, where
just type in event we have item

24889
25:46:27.926 --> 25:46:30.926
listed item bought an item
cancelled. So we have three

24890
25:46:30.926 --> 25:46:33.927
events we want to listen and a
Morales, they have this add new

24891
25:46:33.927 --> 25:46:35.927
events synced from code, which
we're basically going to be

24892
25:46:35.927 --> 25:46:38.927
following. To do this, we need
to obviously start and then

24893
25:46:38.927 --> 25:46:42.927
create our options for the
event. We have the chain address

24894
25:46:43.927 --> 25:46:47.927
topic, abi elimite, table name
and sync historical and then we

24895
25:46:47.927 --> 25:46:51.927
just do Morales dot Cloud dot
run, watch cloud event options

24896
25:46:51.927 --> 25:46:54.927
use master key. And that's
pretty much it. So we're going

24897
25:46:54.927 --> 25:46:57.927
to follow these documents here
to do our code. So let's start

24898
25:46:57.927 --> 25:47:00.927
with item listed. Let's create
some options for our IDed listed

24899
25:47:00.927 --> 25:47:05.927
event. So we'll say let item
listed options, or we could do

24900
25:47:05.927 --> 25:47:08.927
const if we want to, but I'm
just gonna do let item listed

24901
25:47:08.927 --> 25:47:12.927
options equals. And first we're
gonna need the chain ID, which

24902
25:47:12.927 --> 25:47:16.927
we have, because we're getting
it from Morales. Now the first

24903
25:47:16.927 --> 25:47:20.927
thing to point out about chain
ID is that ralis understands a

24904
25:47:20.927 --> 25:47:25.927
local chain is 1337. So even if
you're on 31337, if you're doing

24905
25:47:25.927 --> 25:47:29.927
a local development, you got to
switch it to 1337. So we're

24906
25:47:29.927 --> 25:47:33.927
going to make another variable
called Morales chain ID. And

24907
25:47:33.927 --> 25:47:41.927
we're just going to say, let
Morales chain ID equals chain ID

24908
25:47:41.927 --> 25:47:52.927
equals 31337. Question mark
311337. Otherwise, chain ID but

24909
25:47:52.927 --> 25:47:55.927
we're saying since Morales
understands that any local Dev

24910
25:47:55.927 --> 25:48:01.927
is going to be 1337, we're going
to say if chain ID equals 31337.

24911
25:48:01.927 --> 25:48:06.927
Then have Morales chain ID equal
1337. Otherwise have an equal

24912
25:48:06.927 --> 25:48:10.927
whatever whatever our chain
ideas and in our dot env we can

24913
25:48:10.927 --> 25:48:14.928
decide okay, if we want to do
rink B, localhost main net, etc.

24914
25:48:14.928 --> 25:48:17.928
We're gonna say Okay, chain ID
morass will do your Morales

24915
25:48:17.928 --> 25:48:20.928
chain ID, comma, we'll say what
else do we need? We did the

24916
25:48:20.928 --> 25:48:24.928
chain ID, we're gonna skip
description, a sync historical.

24917
25:48:24.928 --> 25:48:27.928
So hit sync historical allows
the node to go back throughout

24918
25:48:27.928 --> 25:48:30.928
the blockchain, grab all the
events ever emitted by that

24919
25:48:30.928 --> 25:48:34.928
contract. Since this is a very
small local blockchain will just

24920
25:48:34.928 --> 25:48:40.928
say sync historical is true.
Like that. Okay, what else do we

24921
25:48:40.928 --> 25:48:43.928
need? Okay, we need the topic,
the topic is going to be your

24922
25:48:43.928 --> 25:48:47.928
event information. So to get the
topic, go back to our event

24923
25:48:47.928 --> 25:48:49.928
code, and the topic is just
gonna be the name of the event,

24924
25:48:49.928 --> 25:48:52.928
plus the type of the parameters.
So we're gonna go back to our

24925
25:48:52.928 --> 25:48:56.928
code, we're gonna go back to
here, we're gonna say, topic is

24926
25:48:56.928 --> 25:49:00.928
going to be item listed, and it
takes an address, an address, an

24927
25:49:00.928 --> 25:49:06.928
address, you went to 56, and a
UNT 256, address address, you

24928
25:49:06.928 --> 25:49:10.928
interviewed six, YouTube and
six. Those problems seem like

24929
25:49:10.928 --> 25:49:13.928
that, we also need the API of
just the event, which again, we

24930
25:49:13.928 --> 25:49:18.928
can find we go back to our hard
hat project, we go to artifacts,

24931
25:49:18.928 --> 25:49:22.928
we go to contracts. And if the
marketplace dot soul NFT

24932
25:49:22.928 --> 25:49:26.928
marketplace dot JSON, our ABI
starting from here is going to

24933
25:49:26.928 --> 25:49:29.928
be the ABI of the whole
contract. And we just want that

24934
25:49:29.928 --> 25:49:33.928
item listed event. So we did
Ctrl F, and we found it here.

24935
25:49:33.928 --> 25:49:36.928
And we're going to grab from
right after it says type event,

24936
25:49:36.928 --> 25:49:39.928
we're going to copy we're going
to scroll up to write up to

24937
25:49:39.928 --> 25:49:43.928
anonymous false, right, so this
bit describes the ABI of the

24938
25:49:43.928 --> 25:49:47.928
event. So we have internal type,
address, name, seller type,

24939
25:49:47.928 --> 25:49:50.928
address, and if T address token
ID price item listed, right, so

24940
25:49:50.928 --> 25:49:54.929
this is going to be the ABI of
our just our item listed event,

24941
25:49:54.929 --> 25:49:57.929
we can take that and we just
stick it in here, hit save, and

24942
25:49:57.929 --> 25:49:59.929
mine auto format it to get rid
of the parentheses. Okay, what

24943
25:49:59.929 --> 25:50:03.929
else do we need, we have the
topic, we have the ABI, we

24944
25:50:03.929 --> 25:50:05.929
already have the address, we're
not going to do a filter. And

24945
25:50:05.929 --> 25:50:08.929
then we need a table name. So
we're going to do a new line,

24946
25:50:08.929 --> 25:50:12.929
we'll say table name, it's going
to be item listed. And this is

24947
25:50:12.929 --> 25:50:15.929
going to be the name of the
table that we update in our

24948
25:50:15.929 --> 25:50:18.929
database. So we're gonna get a
new table in here called item

24949
25:50:18.929 --> 25:50:21.929
listed, and it's just gonna be
filled with information about

24950
25:50:21.929 --> 25:50:23.929
the item listed event. And
that's it right and we would hit

24951
25:50:23.929 --> 25:50:26.929
confirm if we were doing this on
the UI. And since we're doing

24952
25:50:26.929 --> 25:50:29.929
here, we'll just hit save, this
is one of our events, we want to

24953
25:50:29.929 --> 25:50:32.929
do this for all of our events.
Let's do it now for item bought.

24954
25:50:32.929 --> 25:50:37.929
So we'll say let's, item bought
options, equals and we'll repeat

24955
25:50:37.929 --> 25:50:39.929
the process, some of the stuff
at the top is gonna be the same,

24956
25:50:39.929 --> 25:50:41.929
the chain it is gonna be the
same sync historical is gonna be

24957
25:50:41.929 --> 25:50:44.929
the same. So we can just grab
those two, paste them down here

24958
25:50:44.929 --> 25:50:48.929
for item, but the topic is going
to be different. The topic is

24959
25:50:48.929 --> 25:50:51.929
going to be item bot is the name
of the event, it's going to take

24960
25:50:51.929 --> 25:50:59.929
an address, an address, a un 256
and a un 256. The ABI is going

24961
25:50:59.929 --> 25:51:02.929
to be different. Once again,
we're gonna go to our Hardhead

24962
25:51:02.929 --> 25:51:06.929
NFT marketplace, we'll look for
a bot, you'd find this event

24963
25:51:06.929 --> 25:51:10.929
here. We'll copy this, go back,
we'll paste it in here, we now

24964
25:51:10.929 --> 25:51:16.929
have item bot, we'll give it a
table name of item bot. And then

24965
25:51:16.929 --> 25:51:24.929
one more then we have let item
cancelled options equals and

24966
25:51:24.929 --> 25:51:29.929
we'll do chain ID that's going
to be rouse chain ID gonna be

24967
25:51:29.929 --> 25:51:34.930
the same boilerplate from the
top address. Contract address

24968
25:51:34.930 --> 25:51:37.930
topic is going to be different.
The topic for this it's called

24969
25:51:37.930 --> 25:51:42.930
item cancelled, and it takes an
address, an address and a UNT

24970
25:51:42.930 --> 25:51:48.930
256 will say sync. Historical
will be true, historical is

24971
25:51:48.930 --> 25:51:52.930
true. And then we need the ABI.
Once again we can go back to our

24972
25:51:52.930 --> 25:51:57.930
hard hat, compile information we
can look for item cancelled,

24973
25:51:57.930 --> 25:52:03.930
grab that ABI of that event.
Copy that. Come back to our

24974
25:52:03.930 --> 25:52:06.930
running code pasted in. Oops and
I didn't give item canceled.

24975
25:52:06.930 --> 25:52:08.930
Let's give item canceled the

24976
25:52:08.930 --> 25:52:14.930
table name, which will be item
canceled. So now if I zoom out

24977
25:52:14.930 --> 25:52:17.930
just a hair, I now have item
cancelled options, item bought

24978
25:52:17.930 --> 25:52:21.930
options. And item listed options
are telling Ross Hey, listen for

24979
25:52:21.930 --> 25:52:25.930
these events, whenever you hear
an item canceled event, stick

24980
25:52:25.930 --> 25:52:28.930
all this stuff into a database.
Whenever you hear an item bought

24981
25:52:28.930 --> 25:52:31.930
event, stick all this in a
database, whenever it emits an

24982
25:52:31.930 --> 25:52:34.930
item listed, stick all this in
in a database so that we can

24983
25:52:34.930 --> 25:52:36.930
read from it. So we're indexing
these events so that we can

24984
25:52:36.930 --> 25:52:40.930
query them much easier. Now to
send them up to our our server

24985
25:52:40.930 --> 25:52:48.930
will say const listed response
equals await or Alice or Alice

24986
25:52:48.930 --> 25:52:55.930
dot Cloud dot run, watch
contract event will pass the

24987
25:52:55.930 --> 25:53:01.930
item listed options. And then
one more comma, and then we pass

24988
25:53:01.930 --> 25:53:05.930
an object in here where we're
just gonna say use master key is

24989
25:53:05.930 --> 25:53:08.930
going to be true. And we'll do
the same thing we'll say const

24990
25:53:08.930 --> 25:53:13.931
bot response or passing the bot
item options. So we'll say bot

24991
25:53:13.931 --> 25:53:19.931
response equals await or else
dot Cloud dot run, watch

24992
25:53:19.931 --> 25:53:28.931
contract, event, comma, item
bought options. Comma, use

24993
25:53:28.931 --> 25:53:34.931
master key that's going to be
true. And then finally Kant's

24994
25:53:34.931 --> 25:53:42.931
canceled response equals await
oralis dot Cloud dot run, watch

24995
25:53:42.931 --> 25:53:50.931
contract event, comma, item
canceled options, comma use

24996
25:53:50.931 --> 25:53:54.931
master key is going to be true.
Now this Morales dot Cloud dot

24997
25:53:54.931 --> 25:53:58.931
run API call to our server that
we're making is going to return

24998
25:53:58.931 --> 25:54:00.931
a response. And let's look at
the docs to actually see what

24999
25:54:00.931 --> 25:54:03.931
that response looks like if it
worked out. Well. In the

25000
25:54:03.931 --> 25:54:08.931
terminal, you'll see success
true. So this is the return

25001
25:54:08.931 --> 25:54:11.931
we're getting from the API. So
just to make sure everything

25002
25:54:11.931 --> 25:54:17.931
goes well, I'll do an if listed.
response dot success, we're

25003
25:54:17.931 --> 25:54:20.931
getting that success object from
the rails server, we'll just do

25004
25:54:20.931 --> 25:54:29.931
a console dot log success
database updated with watching

25005
25:54:29.931 --> 25:54:35.931
events. And then else we'll say
console dot log, something went

25006
25:54:35.931 --> 25:54:39.931
wrong with a duck. And of
course, we're not just looking

25007
25:54:39.931 --> 25:54:44.931
for let's say response dot
success to be true. We also want

25008
25:54:44.931 --> 25:54:50.931
canceled response that success
and bots response

25009
25:54:50.931 --> 25:54:55.932
is successful. Then say hey, you
did it. Otherwise say hey,

25010
25:54:55.932 --> 25:54:57.932
something went wrong. So this is
how we're going to

25011
25:54:57.932 --> 25:55:01.932
programmatically tell our server
our database to listen for

25012
25:55:01.932 --> 25:55:04.932
events. So we just do await
Murata Clodagh, run, watch

25013
25:55:04.932 --> 25:55:07.932
contract events, we pass it this
object with all these parameters

25014
25:55:07.932 --> 25:55:10.932
and flags in there. And then
that's it. And then we can send

25015
25:55:10.932 --> 25:55:14.932
them is because I put next
public Morales server URL. And

25016
25:55:14.932 --> 25:55:17.932
in my DMV, I just have next
public server URL. So let's

25017
25:55:17.932 --> 25:55:20.932
change the name here. Looks like
our server URL was wrong. And

25018
25:55:20.932 --> 25:55:24.932
our app ID name is also wrong.
So let's fix that next public

25019
25:55:24.932 --> 25:55:28.932
app ID master key looks correct.
Okay, cool. So let's know things

25020
25:55:28.932 --> 25:55:32.932
right? More Alice, like cada
run, Rasta cloud run, when we

25021
25:55:32.932 --> 25:55:36.932
run this in our database, if we
hit refresh, right now, we don't

25022
25:55:36.932 --> 25:55:41.932
see those tables in here. But
once we run this, add events.js,

25023
25:55:41.932 --> 25:55:44.932
we should call our server and we
should tell it hey, you need to

25024
25:55:44.932 --> 25:55:46.932
add these tables. And you need
to start listening for those

25025
25:55:46.932 --> 25:55:49.932
events. So in a new terminal,
we're going to run this add

25026
25:55:49.932 --> 25:55:53.932
events such as, so I'm going to
make the terminal nice big. And

25027
25:55:53.932 --> 25:55:55.932
this is where if something goes
wrong, it can be a little

25028
25:55:55.932 --> 25:55:58.932
frustrating to figure it out how
to fix this. So if you run into

25029
25:55:58.932 --> 25:56:01.932
an issue here, if something's
not working as expected, please

25030
25:56:01.932 --> 25:56:04.932
use the GitHub repo associated
with this course. And also the

25031
25:56:04.932 --> 25:56:08.932
Morales forum is here for you,
and Stack Exchange Etherium. So

25032
25:56:08.932 --> 25:56:13.932
we're going to run Node, add
events, dot j s, and we'll hit

25033
25:56:13.932 --> 25:56:17.932
enter. Okay, boom, now we see
success database updated with

25034
25:56:17.932 --> 25:56:20.932
watching events. Now, if you ran
into an issue, and you rerun it,

25035
25:56:20.932 --> 25:56:24.932
and it gets something went
wrong, there's a chance that it

25036
25:56:24.932 --> 25:56:27.932
could still be correct, right,
because it returns false. It

25037
25:56:27.932 --> 25:56:30.932
returns that there's an issue if
any of these already have the

25038
25:56:30.932 --> 25:56:34.933
table in there. So if we go back
to our database here, and we hit

25039
25:56:34.933 --> 25:56:38.933
refresh, I can now see item
bought, item canceled and item

25040
25:56:38.933 --> 25:56:40.933
listed in my database. And
again, you can see them by

25041
25:56:40.933 --> 25:56:44.933
hitting the drop down on your
server and hitting dashboard. We

25042
25:56:44.933 --> 25:56:48.933
also see event Sync Status. And
this is how our database knows

25043
25:56:48.933 --> 25:56:51.933
that it needs to be listening
for some events, and it's got

25044
25:56:51.933 --> 25:56:55.933
all the information about how to
listen for our events in here.

25045
25:56:55.933 --> 25:56:58.933
So cool. So now we are listening
for events. This is fantastic.

25046
25:56:58.933 --> 25:57:03.933
So now what this means is our
database is now listening To our

25047
25:57:03.933 --> 25:57:06.933
blockchain node, and it's
listening for events in here

25048
25:57:06.933 --> 25:57:09.933
it's listening for these item
listed item bought item,

25049
25:57:09.933 --> 25:57:12.933
cancelled events. So let's go
ahead and test this back in our

25050
25:57:12.933 --> 25:57:16.933
hardhat NFT marketplace Free
Code Camp window. We have some

25051
25:57:16.933 --> 25:57:20.933
scripts in here. One of them is
mint and list. So we went to New

25052
25:57:20.933 --> 25:57:24.933
NFT. And we listed on the
marketplace when we list an NF

25053
25:57:24.933 --> 25:57:28.933
T, well, our mirallas database
should hear that item listed

25054
25:57:28.933 --> 25:57:32.933
event and go ahead and stick it
into this item listed table that

25055
25:57:32.933 --> 25:57:35.933
it made. So for us to test this
out, let's open up our terminal

25056
25:57:35.933 --> 25:57:39.933
in our Hardhead NFT marketplace
repo. And we'll run Minton list

25057
25:57:39.933 --> 25:57:44.933
for our localhost before we
actually run it, just be sure

25058
25:57:44.933 --> 25:57:48.933
that our hard hat node is synced
up with our Morales server in

25059
25:57:48.933 --> 25:57:51.933
order for your database to
actually grab that event. Your

25060
25:57:51.933 --> 25:57:55.933
local hard hat node needs to be
connected. So we'll do yarn,

25061
25:57:55.933 --> 25:58:01.933
hard hat run scripts, mint and
list.js dash dash, network

25062
25:58:01.933 --> 25:58:05.933
localhost. Let's enter. Okay,
minting, approving listing

25063
25:58:05.933 --> 25:58:11.933
listed now if we flip back to
our database, after a quick

25064
25:58:11.933 --> 25:58:15.934
refresh, what do you know, we
see that there's an indeed an

25065
25:58:15.934 --> 25:58:18.934
item listed events in our
database, we can see information

25066
25:58:18.934 --> 25:58:21.934
about a tool we can see there's
a block hash, a timestamp, we

25067
25:58:21.934 --> 25:58:24.934
see the token ID that was
listed, we see the price of the

25068
25:58:24.934 --> 25:58:29.934
listing the transaction hash, we
see all this information about

25069
25:58:29.934 --> 25:58:32.934
our event. And now it's in this
database for us to query. So if

25070
25:58:32.934 --> 25:58:35.934
you have reached this point, you
have successfully set up an

25071
25:58:35.934 --> 25:58:38.934
indexer with the Morales
database. And you should be

25072
25:58:38.934 --> 25:58:40.934
super pumped because this is
really powerful. And now we're

25073
25:58:40.934 --> 25:58:43.934
getting advanced, we're starting
to do some advanced stuff. So if

25074
25:58:43.934 --> 25:58:46.934
you've made it this far, huge
congrats. This is already really

25075
25:58:46.934 --> 25:58:51.934
cool. Now, some other
troubleshooting help here that

25076
25:58:51.934 --> 25:58:54.934
I've run into many times myself,
let's say I've left this

25077
25:58:54.934 --> 25:58:57.934
project, and I've killed my
heart hit note, I'm going to

25078
25:58:57.934 --> 25:59:00.934
kill it right now. If I stopped,
my heart had node and I come

25079
25:59:00.934 --> 25:59:04.934
back to my Morales admin, I'm
going to view details dev chain

25080
25:59:04.934 --> 25:59:06.934
proxy server, I'm now
disconnected. And if I hit this

25081
25:59:06.934 --> 25:59:09.934
little refresh, I'm disconnected
of course, because I'm not

25082
25:59:09.934 --> 25:59:13.934
running my heart headnote
anymore. If I restart my node,

25083
25:59:13.934 --> 25:59:16.934
my note is now restarted. My
connects local dev chain command

25084
25:59:16.934 --> 25:59:20.934
is still running. If I re fresh
it, it'll now say connected,

25085
25:59:20.934 --> 25:59:24.934
which is great. However, if I go
back to my blockchain, or if I

25086
25:59:24.934 --> 25:59:28.934
go back to my hard hat, NFC
marketplace script, I run yarn,

25087
25:59:28.934 --> 25:59:31.934
hard hat script, mint and list
again, network localhost, I go

25088
25:59:31.934 --> 25:59:35.934
back to my database now, and I
do a refresh, we don't see that

25089
25:59:35.934 --> 25:59:39.934
item listed in here. So our
mirallas server is looking to

25090
25:59:39.934 --> 25:59:42.934
make sure that that the
blockchain we're working with is

25091
25:59:42.934 --> 25:59:46.934
the same one. So if we reset our
blockchain, like we did, right,

25092
25:59:46.934 --> 25:59:50.934
we canceled it and we reset it,
our database is gonna get really

25093
25:59:50.934 --> 25:59:53.935
confused. So what we have to do
is we have to hit reset local

25094
25:59:53.935 --> 25:59:58.935
chain, reset local chain, we
want to make sure that our new

25095
25:59:58.935 --> 26:00:01.935
local chain is running, and that
we're connected here. So we'll

25096
26:00:01.935 --> 26:00:04.935
hit reset local chain, and this
will tell them Ross, hey, we

25097
26:00:04.935 --> 26:00:07.935
reset the chain, it's okay,
please continue doing so. And

25098
26:00:07.935 --> 26:00:10.935
once we hit reset local chain,
we're not going to see that item

25099
26:00:10.935 --> 26:00:16.935
listed in here. However, if we
go back, and we rerun mint and

25100
26:00:16.935 --> 26:00:21.935
list network, local host with
this reset local chain. Now, if

25101
26:00:21.935 --> 26:00:24.935
we go back to our Morales
database, we hit refresh, we now

25102
26:00:24.935 --> 26:00:27.935
see that new one has gotten in
anytime you stopped your hard

25103
26:00:27.935 --> 26:00:31.935
hat note, anytime you reset your
hard hat node, the takeaway is

25104
26:00:31.935 --> 26:00:33.935
you're going to need to go to
View Details dev chain proxy

25105
26:00:33.935 --> 26:00:36.935
server and reset local chain.
Now you can do that

25106
26:00:36.935 --> 26:00:38.935
programmatically as well, we're
not going to go over how to

25107
26:00:38.935 --> 26:00:40.935
programmatically do that. But
that might be something you want

25108
26:00:40.935 --> 26:00:44.935
to add to your hard hat deploy.
The other thing to note is that

25109
26:00:44.935 --> 26:00:47.935
it didn't clear out our last
event, right, the last event.

25110
26:00:47.935 --> 26:00:52.935
And if I go one minute and list
again, after completes, we'll

25111
26:00:52.935 --> 26:00:56.935
have another event in here.

25112
26:00:56.935 --> 26:01:00.935
Okay, this is great. So all of
this is being said, the reason

25113
26:01:00.935 --> 26:01:03.935
we're doing all this in the
first place is so that in our

25114
26:01:03.935 --> 26:01:06.935
index.js we can start listening
for events. How do we show the

25115
26:01:06.935 --> 26:01:10.935
recent listen entity. So now we
have a database of listed

25116
26:01:10.935 --> 26:01:13.935
entities. So what we could do,
we could just query this item

25117
26:01:13.935 --> 26:01:16.935
listed table right and grab
everything in here. However, we

25118
26:01:16.935 --> 26:01:19.935
have an issue here, what happens
if someone buys an NFT, if

25119
26:01:19.935 --> 26:01:22.935
someone buys an NF T, the item
listed event will still be in

25120
26:01:22.935 --> 26:01:25.935
our database. But technically it
won't be on the marketplace

25121
26:01:25.935 --> 26:01:29.935
anymore. It'll be gone, it won't
be listed. So what can we do,

25122
26:01:29.935 --> 26:01:30.935
there's a number of
architectural choices we can

25123
26:01:30.935 --> 26:01:33.935
make to get around this problem
to solve this problem. But one

25124
26:01:33.935 --> 26:01:36.936
of the things we can do is
actually we can use mirallas

25125
26:01:36.936 --> 26:01:40.936
Cloud Functions. So Morales
cloud functions allow us to just

25126
26:01:40.936 --> 26:01:44.936
really add anything we want our
front end to do from the morale

25127
26:01:44.936 --> 26:01:46.936
server. And these are functions.
These are scripts that are going

25128
26:01:46.936 --> 26:01:49.936
to run on a morale server
whenever we want them to. So we

25129
26:01:49.936 --> 26:01:52.936
go to our server hit the little
drop down and we hit Cloud

25130
26:01:52.936 --> 26:01:56.936
Functions. Now this is where we
can write somewhere else stuff

25131
26:01:56.936 --> 26:02:00.936
to run on our server whenever we
want. And we are going to set up

25132
26:02:00.936 --> 26:02:03.936
our Cloud Functions in our IDE
by hitting this little drop done

25133
26:02:03.936 --> 26:02:07.936
to actually sync up our Visual
Studio code with our Cloud

25134
26:02:07.936 --> 26:02:10.936
Functions, we can just run this
command here, and it will add

25135
26:02:10.936 --> 26:02:14.936
whatever cloud functions we have
in some cloud folder to here. So

25136
26:02:14.936 --> 26:02:18.936
what we can do back in our VS
code, let's make a new folder,

25137
26:02:18.936 --> 26:02:22.936
new folder called Cloud
Functions. And in here, we'll

25138
26:02:22.936 --> 26:02:29.936
create a new file called Update,
active items.js. So in here, if

25139
26:02:29.936 --> 26:02:32.936
we were to write something like
console dot log, hi, we can

25140
26:02:32.936 --> 26:02:36.936
actually have this automatically
saved on a morale server. And

25141
26:02:36.936 --> 26:02:39.936
the way that we do this is by
running this command. Now, we

25142
26:02:39.936 --> 26:02:42.936
want to make it so that it's a
lot easier for us to run this

25143
26:02:42.936 --> 26:02:45.936
command than just always having
to run this massive thing. So

25144
26:02:45.936 --> 26:02:47.936
what we're going to do is we're
going to open up our package

25145
26:02:47.936 --> 26:02:50.936
json, and we're going to make
another Morales script here,

25146
26:02:50.936 --> 26:02:53.936
right below here, we're going to
make another Morales script,

25147
26:02:53.936 --> 26:02:57.936
we're gonna say Morales Morales
cloud, and we're going to have

25148
26:02:57.936 --> 26:03:03.936
it, run this command. So we're
going to copy this command here,

25149
26:03:03.936 --> 26:03:06.936
paste it into our package json.
So it's going to be Morales

25150
26:03:06.936 --> 26:03:11.936
admin CLI, watch cloud folder,
we don't need the Morales API

25151
26:03:11.936 --> 26:03:13.937
key, because it'll grab that
from our environment variables.

25152
26:03:13.937 --> 26:03:16.937
We don't need them rouse secret,
because it'll grab that from our

25153
26:03:16.937 --> 26:03:20.937
environment variables, we do
need the morale subdomain

25154
26:03:20.937 --> 26:03:24.937
autosave one. And then the
Morales cloud folder is going to

25155
26:03:24.937 --> 26:03:30.937
be that new Cloud Functions bid
that we made that slash cloud

25156
26:03:30.937 --> 26:03:36.937
functions, functions. Now, in a
new terminal, if I run yarn,

25157
26:03:36.937 --> 26:03:40.937
more Alice cloud, which is going
to be same as running this huge

25158
26:03:40.937 --> 26:03:44.937
function here, I hit enter,
it'll say compile, you know,

25159
26:03:44.937 --> 26:03:47.937
version, blah, blah, compiling,
blah, blah, changes uploaded

25160
26:03:47.937 --> 26:03:51.937
correctly. And if we go back to
our front end, we can see this

25161
26:03:51.937 --> 26:03:54.937
console dot log ky and our front
end being updated. And if we

25162
26:03:54.937 --> 26:03:57.937
continue to run this in our
update active items at Jas, we

25163
26:03:57.937 --> 26:04:02.937
could also write console dot
log, you'll save it. And if this

25164
26:04:02.937 --> 26:04:05.937
is still running, it'll
automatically upload it. And now

25165
26:04:05.937 --> 26:04:08.937
we can see if we do a little
refresh on our front end Cloud

25166
26:04:08.937 --> 26:04:11.937
Functions, we can see it's been
uploaded here. Now at this

25167
26:04:11.937 --> 26:04:14.937
point, if you have a ton of this
stuff running, you might see CPU

25168
26:04:14.937 --> 26:04:18.937
100 percent, you might see this little
thing pop up and the server

25169
26:04:18.937 --> 26:04:20.937
might start going a little bit
slower, we're starting to use a

25170
26:04:20.937 --> 26:04:26.937
lot of network activity here. So
I'm going to close my yarn

25171
26:04:26.937 --> 26:04:29.937
Morales cloud for now. And I'm
just going to upload it once

25172
26:04:29.937 --> 26:04:32.937
when I need to. Because we're
connected, we have it listening

25173
26:04:32.937 --> 26:04:35.937
to events, we're having it doing
more and more stuff here. And it

25174
26:04:35.937 --> 26:04:38.937
can start to put a lot of load
onto the server. So we're just

25175
26:04:38.937 --> 26:04:41.937
gonna go ahead and we're going
to cancel that out. And now the

25176
26:04:41.937 --> 26:04:44.937
CPU is a lot lower. But if we go
back to Cloud Functions, we can

25177
26:04:44.937 --> 26:04:48.937
see it's still in here. And
anytime we update our Cloud

25178
26:04:48.937 --> 26:04:50.937
Functions, it'll update our
server with those cloud

25179
26:04:50.937 --> 26:04:53.937
functions. And we'll just run
that darn morass cloud once

25180
26:04:53.937 --> 26:04:56.938
we're all done here. Anyways, so
right now we're trying to figure

25181
26:04:56.938 --> 26:04:59.938
out, Okay, we have item listed,
but if someone buys an item,

25182
26:04:59.938 --> 26:05:04.938
technically, it won't be listed
anymore. But our item listed

25183
26:05:04.938 --> 26:05:06.938
table will still have it listed.
So what we can do is we can

25184
26:05:06.938 --> 26:05:09.938
create a Cloud Function that
runs whenever we want. And like

25185
26:05:09.938 --> 26:05:12.938
I said, we can have these run
whenever we want. We can call

25186
26:05:12.938 --> 26:05:14.938
these whenever we want. But
we're going to create a Cloud

25187
26:05:14.938 --> 26:05:17.938
Function that only runs.
Whenever one of these events are

25188
26:05:17.938 --> 26:05:20.938
synced item listed item
cancelled or item bought, we're

25189
26:05:20.938 --> 26:05:24.938
going to create a new table
called active item, an active

25190
26:05:24.938 --> 26:05:27.938
item is going to say, okay,
anytime it's listed, it will be

25191
26:05:27.938 --> 26:05:30.938
active, but when it's bought or
cancelled will remove it from

25192
26:05:30.938 --> 26:05:33.938
the active item list. So we're
going to create a new table. So

25193
26:05:33.938 --> 26:05:36.938
let's go ahead and do that. We
started off with more Alice

25194
26:05:36.938 --> 26:05:40.938
thought. And then if you're IT
auditors that you don't need

25195
26:05:40.938 --> 26:05:43.938
this, we don't need to import
Morales here, because we're

25196
26:05:43.938 --> 26:05:46.938
going to upload it as a Cloud
Function. And our server already

25197
26:05:46.938 --> 26:05:49.938
just automatically injects
mirallas into our scripts. So

25198
26:05:49.938 --> 26:05:53.938
we're gonna say Morales dot
cloud, that after save, and

25199
26:05:53.938 --> 26:05:57.938
there's a whole bunch of stuff
you can do with your Morales

25200
26:05:57.938 --> 26:06:00.938
cloud. And again, you can find
these all in the documentation.

25201
26:06:00.938 --> 26:06:03.938
The after save keyword means
that anytime something gets

25202
26:06:03.938 --> 26:06:06.938
saved on a table that we
specify, we'll do something. And

25203
26:06:06.938 --> 26:06:10.938
it takes two parameters. So it
takes what table that we want to

25204
26:06:10.938 --> 26:06:13.938
do something after it's saved.
And we're gonna say item listed.

25205
26:06:13.938 --> 26:06:15.938
So we're saying anytime
something is saved to the item

25206
26:06:15.938 --> 26:06:20.938
listed table, we'll run some
async function.

25207
26:06:20.938 --> 26:06:23.938
And we'll put request in here.
Because anytime something gets

25208
26:06:23.938 --> 26:06:27.938
saved, it comes with a request.
So anytime an item listed

25209
26:06:27.938 --> 26:06:31.938
happens, we want to add it to
our active items list. And our

25210
26:06:31.938 --> 26:06:35.939
requests come with this is
flagged called confirmed. So

25211
26:06:35.939 --> 26:06:38.939
we'll say const confirmed
because every request, every

25212
26:06:38.939 --> 26:06:41.939
event actually gets triggered
twice. So once a transaction

25213
26:06:41.939 --> 26:06:45.939
goes through, it triggers a save
and then once again, once that

25214
26:06:45.939 --> 26:06:48.939
transaction is actually
confirmed, we actually only want

25215
26:06:48.939 --> 26:06:51.939
to update our active item when
the transaction is actually

25216
26:06:51.939 --> 26:06:54.939
confirmed. So we'll say const
confirmed equals request dot

25217
26:06:54.939 --> 26:07:00.939
object dot get confirmed.
Screening, get the confirmed

25218
26:07:00.939 --> 26:07:03.939
attribute from that request. And
then we're also going to make A

25219
26:07:03.939 --> 26:07:09.939
logger will say const logger
equals oralis dot Cloud dot get

25220
26:07:09.939 --> 26:07:12.939
logger. And you'll see why in a
second, we can actually write

25221
26:07:12.939 --> 26:07:17.939
logs to our Morales database
with this logs thing. So any

25222
26:07:17.939 --> 26:07:20.939
logs we can add into here, and
I'll show you that in a minute.

25223
26:07:20.939 --> 26:07:23.939
So console logger Morales dot
cloud, get logger. And then

25224
26:07:23.939 --> 26:07:26.939
we'll just do logger dot info.

25225
26:07:26.939 --> 26:07:31.939
Looking for confirmed x, and we
can actually test this right

25226
26:07:31.939 --> 26:07:35.939
now. Right, we can actually test
this right now. In our logs. We

25227
26:07:35.939 --> 26:07:40.939
should see looking for confirmed
TX Once an item listed and saved

25228
26:07:40.939 --> 26:07:42.939
now to test this out just to
test that our logger is actually

25229
26:07:42.939 --> 26:07:47.939
working. Let's run yarn, yarn
Ross cloud just update active

25230
26:07:47.939 --> 26:07:50.939
items to our to our morale
server changes uploaded

25231
26:07:50.939 --> 26:07:54.939
correctly. Okay, we'll kill it
now. And now in our where we

25232
26:07:54.939 --> 26:07:59.939
have our Minton, lists script.
Let's run Minton list. And we

25233
26:07:59.939 --> 26:08:02.939
should see on our server we
should get those logs. Now if we

25234
26:08:02.939 --> 26:08:05.939
go to our server, we do a little
refresh here. And if we look at

25235
26:08:05.939 --> 26:08:10.939
our logs now we can now see
looking for confirmed TX in our

25236
26:08:10.939 --> 26:08:13.939
server logs. Now in our logs.
Here we see we only see that

25237
26:08:13.939 --> 26:08:18.940
looking for confirmed TX once
and I just told you, it actually

25238
26:08:18.940 --> 26:08:21.940
triggers twice once when the
transaction is first sent. And

25239
26:08:21.940 --> 26:08:25.940
then once when the transaction
is confirmed, aka has block

25240
26:08:25.940 --> 26:08:28.940
confirmations. And additionally,
if we look in our database at

25241
26:08:28.940 --> 26:08:32.940
the item listed, and we scroll
all the way to the right, we can

25242
26:08:32.940 --> 26:08:36.940
see confirmed equals false. So
we only want to count this item

25243
26:08:36.940 --> 26:08:41.940
listed event interactive items
when confirmed is true. So what

25244
26:08:41.940 --> 26:08:44.940
we want to do actually is we
want to update our scripts to

25245
26:08:44.940 --> 26:08:47.940
add one block confirmation on
top of our local Hardhead

25246
26:08:47.940 --> 26:08:51.940
blockchain so that these can be
changed to confirmed now to get

25247
26:08:51.940 --> 26:08:55.940
around this. What I usually will
do in my mentalist script is

25248
26:08:55.940 --> 26:08:58.940
I'll add a new utility. So I'll
go to my utils, I'll do new

25249
26:08:58.940 --> 26:09:04.940
file, and I'll create a move
blocks.js. And this will be a

25250
26:09:04.940 --> 26:09:09.940
utility that I use to actually
move the blocks. So when we run

25251
26:09:09.940 --> 26:09:11.940
our own heart hat node, we
actually have complete control

25252
26:09:11.940 --> 26:09:14.940
over what we want our heart hat
node to do. So what we can do is

25253
26:09:14.940 --> 26:09:17.940
we can actually manually mine
nodes and actually move blocks

25254
26:09:17.940 --> 26:09:21.940
ahead so that Morales knows Oh,
okay, this transaction is

25255
26:09:21.940 --> 26:09:22.940
confirmed, right, because we're
mining the block with the

25256
26:09:22.940 --> 26:09:26.940
transaction. And that's it, and
Ross is just going to forever be

25257
26:09:26.940 --> 26:09:29.940
waiting for the next block. So
we want to add some

25258
26:09:29.940 --> 26:09:32.940
functionality to our scripts,
where we just mine a block after

25259
26:09:32.940 --> 26:09:35.940
it's done. Now, keep in mind
that if we mined like 1000

25260
26:09:35.940 --> 26:09:38.940
blocks or a ton of blocks really
quickly, Moorehouse might have a

25261
26:09:38.940 --> 26:09:41.940
hard time indexing that. So we
really want to just mined one at

25262
26:09:41.940 --> 26:09:44.940
a time and give me enough time
to index each block that we

25263
26:09:44.940 --> 26:09:47.940
mined. So we're actually going
to build a little script, we're

25264
26:09:47.940 --> 26:09:52.940
going to manually mine using
this EVM mine RPC method that

25265
26:09:52.940 --> 26:09:54.941
comes with our heart hat
blockchain. So we have this new

25266
26:09:54.941 --> 26:09:57.941
move blocks script. And let's go
ahead and make this. So instead

25267
26:09:57.941 --> 26:10:00.941
of this being our script, we're
going to have like a main

25268
26:10:00.941 --> 26:10:02.941
function at the bottom, we're
just gonna have this be a

25269
26:10:02.941 --> 26:10:05.941
utility that we're going to
import into other scripts. So

25270
26:10:05.941 --> 26:10:07.941
we're not going to need a main
function here, we're just going

25271
26:10:07.941 --> 26:10:11.941
to need to make this an async
function. And we'll call it move

25272
26:10:11.941 --> 26:10:14.941
blocks. And then we'll say
amount, which is going to be the

25273
26:10:14.941 --> 26:10:18.941
number of blocks, we want to
move, we'll also put a sleep

25274
26:10:18.941 --> 26:10:22.941
amount and default it to zero,
this sleep amount is going to be

25275
26:10:22.941 --> 26:10:26.941
an optional parameter. If we
want to move blocks and sleep

25276
26:10:26.941 --> 26:10:30.941
maybe a second between blocks to
resemble a real blockchain, we

25277
26:10:30.941 --> 26:10:34.941
can have that in here too. So we
can have it resemble a real

25278
26:10:34.941 --> 26:10:37.941
blockchain by sleeping every
time a block is moved or just

25279
26:10:37.941 --> 26:10:40.941
kind of waiting every time a
block has moved. So in our move

25280
26:10:40.941 --> 26:10:44.941
block scripts, we'll do console
dot log, moving blocks, dot that

25281
26:10:44.941 --> 26:10:49.941
dot, and we'll say for let index
equals zero, and we'll do a for

25282
26:10:49.941 --> 26:10:54.941
loop around the amount and call
that EVM. Mine in this for loop

25283
26:10:54.941 --> 26:10:59.941
index is less than amount index
plus plus a weight network. And

25284
26:10:59.941 --> 26:11:02.941
then we got to import network
oops, we got to import network

25285
26:11:02.941 --> 26:11:06.941
from hard hat here, await
network dot provider dot

25286
26:11:06.941 --> 26:11:13.941
request. And then we're going to
request the method e v, mime,

25287
26:11:13.941 --> 26:11:17.941
comma params are going to be
empty. And this is actually the

25288
26:11:17.941 --> 26:11:20.941
same way we can make raw calls
to our blockchain nodes. We

25289
26:11:20.941 --> 26:11:23.941
don't do a lot of this because
ethers abstract this under the

25290
26:11:23.941 --> 26:11:27.941
hood, but we're making a raw
call to EVM mine. Obviously, you

25291
26:11:27.941 --> 26:11:30.941
can't call EVM mine on a real
blockchain because you can't

25292
26:11:30.941 --> 26:11:34.941
just tell a blockchain node to
mine the next block. Since this

25293
26:11:34.941 --> 26:11:37.942
is our local hard hat node, we
can call the VM now we're gonna

25294
26:11:37.942 --> 26:11:42.942
say if sleep amount is greater
than zero, or just if sleep

25295
26:11:42.942 --> 26:11:47.942
mount, then we're also going to
have this script sleep or wait a

25296
26:11:47.942 --> 26:11:49.942
short duration. So up at the
top, we're actually going to

25297
26:11:49.942 --> 26:11:53.942
create a new function called
sleep, which is going to input a

25298
26:11:53.942 --> 26:11:58.942
time in milliseconds. And this
is going to return a new

25299
26:11:58.942 --> 26:12:01.942
promise, right? Because
remember, in order for us to

25300
26:12:01.942 --> 26:12:04.942
wait for some time we got to use
promises, which we've learned

25301
26:12:04.942 --> 26:12:07.942
before. And this promise is
going to take a function with

25302
26:12:07.942 --> 26:12:12.942
resolve as an input parameter.
And we're just going to say, set

25303
26:12:12.942 --> 26:12:18.942
timeout is going to be resolve,
comma, time in Ms. So the way we

25304
26:12:18.942 --> 26:12:21.942
can sleep in JavaScript is we
return a new promise. And we

25305
26:12:21.942 --> 26:12:24.942
just call this set timeout
function, which basically just

25306
26:12:24.942 --> 26:12:25.942
weights the time in
milliseconds. Now to actually

25307
26:12:25.942 --> 26:12:32.942
sleep. We'll say console dot
log, sleeping for sleep amount.

25308
26:12:32.942 --> 26:12:37.942
And then we'll do await, sleep,
sleep amount, and this is going

25309
26:12:37.942 --> 26:12:41.942
to be in milliseconds. So since
sleep returns a promise, we can

25310
26:12:41.942 --> 26:12:44.942
call it with await to say, okay,
wait for this sleep function to

25311
26:12:44.942 --> 26:12:48.942
finish. And the sleep function
is only going to finish when the

25312
26:12:48.942 --> 26:12:52.942
time in MS in time in
milliseconds finishes. So now we

25313
26:12:52.942 --> 26:12:55.942
have a function called move
blocks, which will actually

25314
26:12:55.942 --> 26:12:58.942
mined blocks on our local
blockchain, so that Morales can

25315
26:12:58.942 --> 26:13:00.942
get that block confirmation that
it's looking for now at the

25316
26:13:00.942 --> 26:13:05.942
bottom, we'll just do module dot
exports, move blocks, move

25317
26:13:05.942 --> 26:13:08.942
blocks, and then we'll also
export sleep as well, because

25318
26:13:08.942 --> 26:13:12.942
why not? Equals like that. Now,
what we can do back in our

25319
26:13:12.942 --> 26:13:17.943
Minton list, up at the top,
we'll say const, move blocks

25320
26:13:17.943 --> 26:13:24.943
equals require dot dot slash
utils slash move blocks. And

25321
26:13:24.943 --> 26:13:28.943
then we'll also import network
from ethers network. And the

25322
26:13:28.943 --> 26:13:32.943
down in our script. Just right
at the bottom, we'll just say if

25323
26:13:32.943 --> 26:13:39.943
network dot config, that chain
ID equals equals 31337 await,

25324
26:13:39.943 --> 26:13:43.943
move blocks, we'll say we'll
move to blocks and then we'll

25325
26:13:43.943 --> 26:13:47.943
also do sleep amount equals
1000. We'll wait one millisecond

25326
26:13:47.943 --> 26:13:50.943
between each block that we
mined. So sleep mount equals

25327
26:13:50.943 --> 26:13:53.943
1000, which is going to be one
millisecond. Now let's even just

25328
26:13:53.943 --> 26:13:57.943
comment all this out for a
second. We'll just run this

25329
26:13:57.943 --> 26:14:01.943
script with only this live.
Right we'll pull this up the

25330
26:14:01.943 --> 26:14:07.943
yarn hard hat, run scripts,
mentalist dash dash network,

25331
26:14:07.943 --> 26:14:12.943
local host, we'll just move the
blocks move back to our front

25332
26:14:12.943 --> 26:14:15.943
end, we'll refresh, we'll go
look at item listed. We'll

25333
26:14:15.943 --> 26:14:18.943
scroll all the way to the right,
and now we see confirmed is

25334
26:14:18.943 --> 26:14:21.943
true. And now if we were to look
in our logs, we would see that

25335
26:14:21.943 --> 26:14:25.943
logging item happened twice.
Alright, so Let's uncomment this

25336
26:14:25.943 --> 26:14:29.943
and continue. Now that we have
this now that we're learning

25337
26:14:29.943 --> 26:14:32.943
about logging, now that we're
doing all this stuff, we can say

25338
26:14:32.943 --> 26:14:35.943
If confirmed, we're going to do
some stuff. If confirmed, we're

25339
26:14:35.943 --> 26:14:37.943
going to create a table called
active item and add this to the

25340
26:14:37.943 --> 26:14:40.943
active item table. So we're
going to do a little logger dot

25341
26:14:40.943 --> 26:14:45.943
info bound item. And we'll
create a new table and a new

25342
26:14:45.943 --> 26:14:50.943
entry in this table. So we'll
say const active item equals

25343
26:14:50.943 --> 26:14:58.944
more Alice dot object dot extend
ACC active item. This we're

25344
26:14:58.944 --> 26:15:02.944
saying if active item exists,
great grab it if not create it.

25345
26:15:02.944 --> 26:15:05.944
So we're going to create this
active item table if it doesn't

25346
26:15:05.944 --> 26:15:08.944
exist, if it does exist, great,
grab it. And we're going to say

25347
26:15:08.944 --> 26:15:13.944
const active item equals new,
active item. So we're going to

25348
26:15:13.944 --> 26:15:16.944
create a new entry in this
active item table that we're

25349
26:15:16.944 --> 26:15:22.944
creating. And we'll say active
item dot set. And we can set any

25350
26:15:22.944 --> 26:15:25.944
of the columns we want for this
new table that we're creating.

25351
26:15:25.944 --> 26:15:28.944
So let's give it a marketplace
address column. So we'll say

25352
26:15:28.944 --> 26:15:35.944
market place address. And this
will come from the request dot

25353
26:15:35.944 --> 26:15:41.944
object dot get address all of
these requests from events come

25354
26:15:41.944 --> 26:15:43.944
with the address that they're
coming from, which for us is

25355
26:15:43.944 --> 26:15:46.944
going to be the marketplace
address, we'll do active item

25356
26:15:46.944 --> 26:15:52.944
that set and if T address which
these events saved come with all

25357
26:15:52.944 --> 26:15:57.944
the parameters of our event. So
we'll say request that object

25358
26:15:57.944 --> 26:16:02.944
dot get NFT address will get the
price will say active item dot

25359
26:16:02.944 --> 26:16:09.944
set price is going to be request
dot object dot get price will

25360
26:16:09.944 --> 26:16:15.944
get the token IDs will say
active item dot set token ID

25361
26:16:15.944 --> 26:16:21.944
request dot object dot get token
ID and then we'll get the seller

25362
26:16:22.944 --> 26:16:27.944
will say active item dot set
seller is going to be request

25363
26:16:27.944 --> 26:16:34.944
that object dot get seller. So
we're getting all of this

25364
26:16:34.944 --> 26:16:39.945
information from our event. And
this event update from Ross

25365
26:16:39.945 --> 26:16:41.945
automatically always comes with
the address that the event was

25366
26:16:41.945 --> 26:16:43.945
omitted from. So we're gonna
grab all that we're going to

25367
26:16:43.945 --> 26:16:46.945
create this active item table.
We're going to add all these

25368
26:16:46.945 --> 26:16:49.945
rows. We're going to add this
one row with all these columns

25369
26:16:49.945 --> 26:16:53.945
in it. Awesome. Now we'll just
do logger dot info just to do a

25370
26:16:53.945 --> 26:16:56.945
little print out. We'll say
adding address. We'll do a

25371
26:16:56.945 --> 26:17:01.945
little string interpolation
we'll say request dot object dot

25372
26:17:01.945 --> 26:17:07.945
get address period token ID with

25373
26:17:07.945 --> 26:17:14.945
request dot object dot get token
ID. And I need to close this off

25374
26:17:14.945 --> 26:17:18.945
here, better. And then outside
of the logger dot info, we'll

25375
26:17:18.945 --> 26:17:24.945
just say logger dot info,
saving. And then we just run

25376
26:17:24.945 --> 26:17:30.945
await active item dot save. And
now we have cloud function

25377
26:17:30.945 --> 26:17:34.945
that's going to create a new
entry in a new table called

25378
26:17:34.945 --> 26:17:39.945
active item anytime item listed
happens. So after item is called

25379
26:17:39.945 --> 26:17:41.945
the trigger for our cloud
function, and there are a whole

25380
26:17:41.945 --> 26:17:44.945
bunch of different triggers for
different Ross Cloud Functions.

25381
26:17:44.945 --> 26:17:48.945
If you go to the Morales docs,
we look for trigger, we can find

25382
26:17:48.945 --> 26:17:51.945
a list of all these different
triggers in here, like after

25383
26:17:51.945 --> 26:17:58.945
save for Save. After save,
before delete, after delete,

25384
26:17:58.945 --> 26:18:01.945
before save file, there's all
these different triggers to

25385
26:18:01.945 --> 26:18:04.945
trigger this cloud code. Now, if
we upload this new script to our

25386
26:18:04.945 --> 26:18:07.945
morale server with yarn morass,
cloud changes uploaded

25387
26:18:07.945 --> 26:18:09.945
correctly, okay, great, we'll
kill it. Let's go to our cloud

25388
26:18:09.945 --> 26:18:13.945
server, do a little refresh just
to make sure that it's not still

25389
26:18:13.945 --> 26:18:16.946
processing that update. Okay,
CPUs low enough. Okay, great.

25390
26:18:16.946 --> 26:18:19.946
Now in our database, we don't
see an active item table in

25391
26:18:19.946 --> 26:18:24.946
here. But if we go back to our
Hardhead script, and we call

25392
26:18:24.946 --> 26:18:29.946
mint and list, since now we have
a Cloud Function that says okay,

25393
26:18:29.946 --> 26:18:33.946
anytime an item listed event
happens, update that active item

25394
26:18:33.946 --> 26:18:37.946
table, we should see active item
update. So let's run this. And

25395
26:18:37.946 --> 26:18:40.946
remember for all of this, we
need to have our heart head node

25396
26:18:40.946 --> 26:18:43.946
running connected to Hardhat.
And if we reset our local chain,

25397
26:18:43.946 --> 26:18:46.946
we need to click that reset
local chain button. So we went

25398
26:18:46.946 --> 26:18:50.946
ahead, we ran this. Now if we go
back to our database, we give it

25399
26:18:50.946 --> 26:18:53.946
a little refresh. And right now
I actually don't see anything.

25400
26:18:53.946 --> 26:18:58.946
So if I go to my logs go to
info, I can see any errors or

25401
26:18:58.946 --> 26:19:01.946
issues in here. So it looks like
after save failed for item

25402
26:19:01.946 --> 26:19:04.946
listed for user bla bla bla,
looks like there is an issue

25403
26:19:04.946 --> 26:19:07.946
cannot read properties of
undefined reading extend. And

25404
26:19:07.946 --> 26:19:11.946
that's also in the info, I made
an issue. I didn't quite write

25405
26:19:11.946 --> 26:19:15.946
all my code, right. And if we go
back to our update active item,

25406
26:19:15.946 --> 26:19:18.946
I can see where I messed up. It
should be Morales dot object

25407
26:19:19.946 --> 26:19:22.946
with a capital O dot extent. So
what I'm going to do, then run

25408
26:19:22.946 --> 26:19:26.946
yarn morass cloud again, now
that I have this correct, we're

25409
26:19:26.946 --> 26:19:28.946
going to cancel that, we're
gonna run our mminton list

25410
26:19:28.946 --> 26:19:33.946
again, now that we've fixed our
script. And now that we've fixed

25411
26:19:33.946 --> 26:19:36.946
our script, go back to our
database, we'll give it a little

25412
26:19:36.946 --> 26:19:40.946
refresh, I can now see we have
an active item entry in

25413
26:19:40.946 --> 26:19:44.946
here. Now at this point, there
are going to be times when you

25414
26:19:44.946 --> 26:19:46.946
don't want to leave and go get a
coffee, right, or go to the

25415
26:19:46.946 --> 26:19:49.946
bathroom or go get some food.
And you're going to want to stop

25416
26:19:49.946 --> 26:19:52.946
your terminals from running. So
let's actually practice

25417
26:19:52.946 --> 26:19:55.947
restarting everything and re
getting into this local

25418
26:19:55.947 --> 26:19:57.947
development environment. Because
it can be a little weird and a

25419
26:19:57.947 --> 26:20:01.947
little tricky. So let's practice
this. So once again, let's come

25420
26:20:01.947 --> 26:20:04.947
over here. And what do we need
to do? Well, we're going to Ctrl

25421
26:20:04.947 --> 26:20:08.947
C, we're going to kill our
blockchain Ctrl C, we're going

25422
26:20:08.947 --> 26:20:11.947
to kill our connection to our
Morales server. And if we're

25423
26:20:11.947 --> 26:20:14.947
running a front end Ctrl C, that
too, now if we go to our server,

25424
26:20:14.947 --> 26:20:19.947
we go to view details. Dev chain
proxy server, if we hit status,

25425
26:20:19.947 --> 26:20:22.947
this reset button here will
still we will be disconnected

25426
26:20:22.947 --> 26:20:25.947
now. And now everything has been
disconnected. Now if we want to

25427
26:20:25.947 --> 26:20:28.947
restart everything, if we're on
our heart hat NFT marketplace

25428
26:20:28.947 --> 26:20:31.947
will run yarn Hardhead node, and
that will spin everything up

25429
26:20:31.947 --> 26:20:36.947
again, we'll run yarn Morales
sync to sync back with our

25430
26:20:37.947 --> 26:20:40.947
routes connection, we can go
back to our server will do view

25431
26:20:40.947 --> 26:20:43.947
details and we should be
connected now. Connected. Since

25432
26:20:43.947 --> 26:20:46.947
we restarted our local
blockchain, we now need to

25433
26:20:46.947 --> 26:20:49.947
remember to do reset local
chain, we'll go ahead and run

25434
26:20:49.947 --> 26:20:53.947
that. Great. If we want to
restart our front end, we can

25435
26:20:53.947 --> 26:20:57.947
restart our front end like so
now the thing is, our database

25436
26:20:57.947 --> 26:21:00.947
will still have even when we
refresh it even though we reset

25437
26:21:00.947 --> 26:21:02.947
the local blockchain, it'll
still have all this stuff in it.

25438
26:21:02.947 --> 26:21:06.947
Now these entries in here are
entries from a blockchain that

25439
26:21:06.947 --> 26:21:10.947
no longer exists. So what I
often will do is I'll click this

25440
26:21:10.947 --> 26:21:14.947
button up here, and we'll just
delete all rows in this class.

25441
26:21:14.947 --> 26:21:18.947
To confirm we do active item,
read the name of the table. And

25442
26:21:18.947 --> 26:21:21.947
let's do it for item listed too.
We'll select that edit, delete

25443
26:21:21.947 --> 26:21:26.947
all rows, item listed. Yes,
delete. We'll do a little

25444
26:21:26.947 --> 26:21:29.947
refresh. Now everything is
zeroed out here. Now we have an

25445
26:21:29.947 --> 26:21:32.947
empty database for these events
in our after save here. And now

25446
26:21:32.947 --> 26:21:35.948
that we've added that little
weight in our script, let's go

25447
26:21:35.948 --> 26:21:40.948
back to our hard hat NFT
marketplace, we'll run yarn, RT

25448
26:21:40.948 --> 26:21:48.948
hat, run scripts, mint and list
dot j s dash dash network, local

25449
26:21:48.948 --> 26:21:54.948
host. This will mint it approve
it listed and then we mined two

25450
26:21:54.948 --> 26:21:57.948
blocks to give Morales time to
index our event and then on a

25451
26:21:57.948 --> 26:22:01.948
morale server. We go ahead and
refresh we now see item listed

25452
26:22:01.948 --> 26:22:05.948
as one and active item is One
all at the same time. So that is

25453
26:22:05.948 --> 26:22:09.948
how we're going to make sure
that Morales always indexes

25454
26:22:09.948 --> 26:22:11.948
whenever we call a function,
we're just going to mind one

25455
26:22:11.948 --> 26:22:15.948
additional block to tell Morales
Hey, that transaction has indeed

25456
26:22:15.948 --> 26:22:18.948
been confirmed. So really
exciting. And we got to practice

25457
26:22:18.948 --> 26:22:21.948
closing and restarting and doing
all that good stuff, too. So now

25458
26:22:21.948 --> 26:22:26.948
this is fantastic. Now that we
have this additional

25459
26:22:26.948 --> 26:22:29.948
functionality to make it a lot
easier for someone else over

25460
26:22:29.948 --> 26:22:31.948
okay, awesome, we can check
active item. Well, we're not

25461
26:22:31.948 --> 26:22:35.948
quite done yet, right? Because
what if somebody buys an NFT, or

25462
26:22:35.948 --> 26:22:38.948
sells an entity we should have
active item be removed? Right,

25463
26:22:38.948 --> 26:22:41.948
right now there's one item
listed in one active item. But

25464
26:22:41.948 --> 26:22:45.948
if we buy an item, active item
will still show that that item

25465
26:22:45.948 --> 26:22:49.948
is active. So let's go ahead and
let's update our cloud function

25466
26:22:49.948 --> 26:22:53.948
to also say, okay, anytime an
item is bought, we remove that

25467
26:22:53.948 --> 26:22:57.948
item from being active. So let's
create another after save. Let's

25468
26:22:57.948 --> 26:22:59.948
first built this for canceling
the item. And then we'll build

25469
26:22:59.948 --> 26:23:03.948
one for buying the item. So to
make another after save to make

25470
26:23:03.948 --> 26:23:07.948
another trigger, we'll say
mirallas dot Cloud dot after

25471
26:23:07.948 --> 26:23:11.948
save, we'll say item cancelled.
And this will be an async

25472
26:23:11.948 --> 26:23:15.949
function that takes the request
as an input parameter again, and

25473
26:23:15.949 --> 26:23:16.949
we're going to do the same
thing. We're gonna say const

25474
26:23:16.949 --> 26:23:24.949
confirmed equals request that
object dot get confirmed, we'll

25475
26:23:24.949 --> 26:23:29.949
say const. Logger equals routes
dot Cloud dot get logger, like

25476
26:23:29.949 --> 26:23:34.949
so. And then we'll do logger.
Oops, lowercase L. And then

25477
26:23:34.949 --> 26:23:40.949
we'll do logger dot info,
marketplace, the little pipe

25478
26:23:40.949 --> 26:23:45.949
object and then just request dot
object. And then we'll do the

25479
26:23:46.949 --> 26:23:49.949
same thing. If confirmed. If
this transaction is confirmed

25480
26:23:49.949 --> 26:23:53.949
after one block, we're going to
remove it from active item. And

25481
26:23:53.949 --> 26:23:56.949
we're going to be using a query
to first find that active item

25482
26:23:56.949 --> 26:23:58.949
that's getting cancelled. And
you can learn more about basic

25483
26:23:58.949 --> 26:24:00.949
queries in the Morales
documentation here. So we're

25484
26:24:00.949 --> 26:24:05.949
going to get that table by
saying const active item equals

25485
26:24:05.949 --> 26:24:10.949
more outlets that object for the
capital O object dot extend

25486
26:24:10.949 --> 26:24:13.949
active item. And we're going to
create a new query. So we're

25487
26:24:13.949 --> 26:24:16.949
going to query our table before
we actually set or save

25488
26:24:16.949 --> 26:24:21.949
anything. So we're gonna say
const, query, query equals new

25489
26:24:21.949 --> 26:24:26.949
Morales dot query of active
item. So we're going to query

25490
26:24:26.949 --> 26:24:30.949
our Morales database to find an
active item that's in there,

25491
26:24:30.949 --> 26:24:33.949
that's going to match the
request here, so we can cancel

25492
26:24:33.949 --> 26:24:36.949
it. So we'll say query dot equal
to

25493
26:24:37.949 --> 26:24:44.949
marketplace address, comma
request that object dot get

25494
26:24:44.949 --> 26:24:47.949
address, we're looking for an
active item where the

25495
26:24:47.949 --> 26:24:50.949
marketplace address is going to
be the same as the address of

25496
26:24:50.949 --> 26:24:57.950
the item cancelled. We'll say
query dot equal to NF T address,

25497
26:24:57.950 --> 26:25:05.950
comma request dot object dot get
an F T address will say query

25498
26:25:05.950 --> 26:25:14.950
dot equal to token ID, comma
request dot object dot get token

25499
26:25:14.950 --> 26:25:18.950
ID. And that should be it right?
So let's look again at our

25500
26:25:18.950 --> 26:25:22.950
contract here. And what is the
item canceled give us it gives

25501
26:25:22.950 --> 26:25:25.950
us a seller NFC address and a
token ID seller and ft address

25502
26:25:25.950 --> 26:25:28.950
and a token ID. And we're
looking for NFT address and the

25503
26:25:28.950 --> 26:25:31.950
token ID, we don't need to look
for the seller, we just need to

25504
26:25:31.950 --> 26:25:33.950
look for these two. And then of
course, the marketplace address.

25505
26:25:33.950 --> 26:25:36.950
So great. So now that we have
those two, we can say logger dot

25506
26:25:36.950 --> 26:25:42.950
info, and then we'll just print
out marketplace type query. And

25507
26:25:42.950 --> 26:25:45.950
then we'll just print out this
query that we're running. And

25508
26:25:45.950 --> 26:25:51.950
then we can say const, cancelled
item equals await query dot

25509
26:25:51.950 --> 26:25:54.950
first, we're going to find the
first active item in the

25510
26:25:54.950 --> 26:25:57.950
database that has the same
marketplace address and a T

25511
26:25:57.950 --> 26:26:00.950
address and token ID that just
got cancelled. So we're going to

25512
26:26:00.950 --> 26:26:02.950
find that first cancelled item.
We'll do a little bit more

25513
26:26:02.950 --> 26:26:08.950
logger information, we'll say
logger dot info, marketplace,

25514
26:26:08.950 --> 26:26:11.950
pipe, cancelled item. And then
we'll just do some string

25515
26:26:11.950 --> 26:26:14.950
interpolation. And we'll print
out that canceled item.

25516
26:26:14.950 --> 26:26:20.950
Cancelled item and we'll say if
cancelled item. So if the query

25517
26:26:20.950 --> 26:26:23.950
doesn't find anything, it'll
return undefined. So we're

25518
26:26:23.950 --> 26:26:26.950
saying if cancelled item which
will return true if it found

25519
26:26:26.950 --> 26:26:31.950
something. So if cancelled item,
then we're gonna say logger dot

25520
26:26:31.950 --> 26:26:38.951
info. Deleting and then we'll do
request dot object dot get token

25521
26:26:38.951 --> 26:26:47.951
ID at address, request dot
object dot get address address

25522
26:26:47.951 --> 26:26:51.951
space since it was canceled, so
we're going to do a little print

25523
26:26:51.951 --> 26:26:55.951
little logging here. Take the
leading that thing since it was

25524
26:26:55.951 --> 26:27:00.951
canceled and then we're going to
run a wait canceled item dot

25525
26:27:00.951 --> 26:27:03.951
destroy and that's when we
remove it from the active item.

25526
26:27:03.951 --> 26:27:09.951
And then we'll just say else.
Logger dot info, no item found

25527
26:27:09.951 --> 26:27:19.951
with address, request dot object
dot get address, and token, Id

25528
26:27:19.951 --> 26:27:24.951
request dot object, dot get
token ID. So cool. So now we

25529
26:27:24.951 --> 26:27:27.951
have this after save here, it
looks like my terminal

25530
26:27:27.951 --> 26:27:31.951
automatically added this require
in here, which we don't want. So

25531
26:27:31.951 --> 26:27:34.951
I'm just gonna go ahead delete
that. We can upload this to our

25532
26:27:34.951 --> 26:27:38.951
Morales server by running yarn,
Morales cloud and great changes

25533
26:27:38.951 --> 26:27:41.951
uploaded correctly. And now to
test this test that this is

25534
26:27:41.951 --> 26:27:45.951
working, let's create a new
script in our hard hat NFT

25535
26:27:45.951 --> 26:27:49.951
marketplace called cancel item.
So we'll go to scripts right now

25536
26:27:49.951 --> 26:27:53.951
we have mentioned list, we'll do
new file, we'll call it cancel

25537
26:27:53.951 --> 26:27:59.951
dot Jas. We'll do cancel item,
Jas. And this will be a script.

25538
26:27:59.951 --> 26:28:02.951
So we're going to use that that
main thing here, but we're going

25539
26:28:02.951 --> 26:28:08.951
to call our function cancel. So
we'll do async function cancel,

25540
26:28:08.951 --> 26:28:12.951
and then at the top, we'll say
const token ID equals Now let's

25541
26:28:12.951 --> 26:28:17.952
go to our active item list. And
let's find a token ID that's in

25542
26:28:17.952 --> 26:28:21.952
here. Okay, token ID zero. And
so we'll use this as the token

25543
26:28:21.952 --> 26:28:26.952
ID that we want to delete. So
we'll use token ID zero. So in

25544
26:28:26.952 --> 26:28:30.952
our cancel item.js script, we'll
say const token ID equals zero

25545
26:28:30.952 --> 26:28:34.952
and let's cancel it. So we'll
say const NFT. Marketplace

25546
26:28:34.952 --> 26:28:39.952
equals await ethers dot get
contract. And yes, const ethers

25547
26:28:39.952 --> 26:28:45.952
equals require hardhat. And ft
marketplace will say const basic

25548
26:28:45.952 --> 26:28:54.952
NF t equals await ethers dot get
gets contract. Basic NF team do

25549
26:28:54.952 --> 26:29:02.952
const TX equals await NF T
marketplace dot cancel listing

25550
26:29:02.952 --> 26:29:10.952
basic NF T dot address token ID.
And we're going to call cancel

25551
26:29:10.952 --> 26:29:14.952
item should be cancelled listing
we call the cancel listing. So

25552
26:29:14.952 --> 26:29:19.952
cancelled listing Yep, like
that. And it takes the address

25553
26:29:19.952 --> 26:29:23.952
of the NFT and the token ID. So
the basic NF T dot address and

25554
26:29:23.952 --> 26:29:26.952
the token D Okay, great. And
then we'll do a weight TX dot

25555
26:29:26.952 --> 26:29:32.952
weight one. And then we'll do
console dot log NFT cancelled.

25556
26:29:32.952 --> 26:29:39.952
And then we'll say if network
dot config dot chain ID equals

25557
26:29:39.952 --> 26:29:47.952
equals 31337. We'll go ahead and
we'll do a wait move blocks to

25558
26:29:47.952 --> 26:29:51.952
two and then we'll say sleep.
Mount equals 1000. And then

25559
26:29:52.952 --> 26:29:57.953
we'll just say const. Move
blocks equals require dot dot

25560
26:29:57.953 --> 26:30:00.953
slash utils slash move blocks.
Okay, cool. That looks really

25561
26:30:00.953 --> 26:30:04.953
good. So let's go ahead and run
this yarn hardhat run scripts

25562
26:30:04.953 --> 26:30:10.953
cancel item.js dash dash
network, local host and ft

25563
26:30:10.953 --> 26:30:14.953
cancelled moving blocks
sleeping. Okay, great. Our node

25564
26:30:14.953 --> 26:30:17.953
is running. Awesome. We're
connected to our mirallas we've

25565
26:30:17.953 --> 26:30:21.953
uploaded our cloud function with
yarn Morales cloud. Now if we go

25566
26:30:21.953 --> 26:30:27.953
back to our database, do a
little refresh. Looks like I

25567
26:30:27.953 --> 26:30:31.953
have an issue here. I go to my
info it says after save failed

25568
26:30:31.953 --> 26:30:34.953
for item Cancel for user blah
blah, blah. Here's the login

25569
26:30:34.953 --> 26:30:38.953
information. Morales dot cloud
apt get latar is not a function.

25570
26:30:38.953 --> 26:30:44.953
Uh huh. Well, that makes a lot
of sense. Get water. Let's do

25571
26:30:44.953 --> 26:30:48.953
let's make this get logger.
Shall we get logger to let's re

25572
26:30:48.953 --> 26:30:52.953
upload them. Changes uploaded
correctly. And now I'm going to

25573
26:30:52.953 --> 26:30:55.953
have to manually go to active
item I'm gonna have to manually

25574
26:30:55.953 --> 26:30:58.953
delete this one will have a
delete this row. Yes, delete, do

25575
26:30:58.953 --> 26:31:01.953
a refresh. And the reason I have
to do that is because it's

25576
26:31:01.953 --> 26:31:05.953
already been saved. And we're
doing an after save. So because

25577
26:31:05.953 --> 26:31:08.953
I messed up. If you spelt that
right, you probably did, right.

25578
26:31:08.953 --> 26:31:10.953
But because I messed up, we're
gonna have to rebuild a new one.

25579
26:31:10.953 --> 26:31:14.953
And then delete that new one.
I'm going to run yarn, hard hat

25580
26:31:14.953 --> 26:31:17.953
run scripts, mint and list
network localhost. And we just

25581
26:31:17.953 --> 26:31:20.953
meant to add a new one. Let me
check the Morales database,

25582
26:31:20.953 --> 26:31:24.953
we'll do a refresh. I can see it
in here, I can see it an item

25583
26:31:24.953 --> 26:31:26.953
listed. It has a token ID of
one. So let's go ahead and

25584
26:31:26.953 --> 26:31:30.953
cancel that now. So I'm going to
change my token ID and cancel

25585
26:31:30.953 --> 26:31:34.953
item to one. And now we'll run
that script Barnhardt at run

25586
26:31:34.953 --> 26:31:38.954
scripts cancel item, network,
local host run this NFT

25587
26:31:38.954 --> 26:31:41.954
cancelled moving blocks. Now
we'll go to the front end, we'll

25588
26:31:41.954 --> 26:31:44.954
do a refresh. And we can see
it's been removed from active

25589
26:31:44.954 --> 26:31:47.954
item programmatically, which is
great. So this is where these

25590
26:31:47.954 --> 26:31:50.954
logs can be really helpful. Now
it can be a little scary to do

25591
26:31:50.954 --> 26:31:54.954
things wrong on purpose, but
learning how to use information

25592
26:31:54.954 --> 26:31:56.954
like the logging and learning
how to debug effectively is

25593
26:31:56.954 --> 26:31:59.954
going to make you a lot faster
of a coder because guess what,

25594
26:31:59.954 --> 26:32:01.954
you're not going to be perfect.
You're going to run into issues

25595
26:32:01.954 --> 26:32:04.954
understanding how to use The Log
Understanding how to read the

25596
26:32:04.954 --> 26:32:07.954
errors is going to make you much
faster developer. So now we have

25597
26:32:07.954 --> 26:32:09.954
something for cancelled item,
we're also going to need

25598
26:32:09.954 --> 26:32:12.954
something for what? Well, you
guessed it for buying the item.

25599
26:32:12.954 --> 26:32:15.954
So let's make another one of
these murales to cloud that

25600
26:32:15.954 --> 26:32:19.954
after save. And we're going to
be using most of this same exact

25601
26:32:19.954 --> 26:32:23.954
code for item bought that we use
for item cancelled, we probably

25602
26:32:23.954 --> 26:32:25.954
should turn it all into a
function. But for practice,

25603
26:32:25.954 --> 26:32:28.954
we're just going to go ahead and
do it one more time, we'll do

25604
26:32:28.954 --> 26:32:32.954
Morales dot cloud. And then my
VS code keeps sticking this in

25605
26:32:32.954 --> 26:32:37.954
for some reason. I'm going to
undo that Morales dot Cloud dot

25606
26:32:37.954 --> 26:32:42.954
after save. Item bot is the
event. There'll be an async

25607
26:32:42.954 --> 26:32:50.954
request little arrow function
here, say const confirmed equals

25608
26:32:50.954 --> 26:32:55.954
request that object dot get
confirmed will get whether this

25609
26:32:55.954 --> 26:32:58.954
transaction is confirmed. We'll
get the logger I'm just going to

25610
26:32:58.954 --> 26:33:01.954
copy paste so I get it right
this time. So I'm going to copy

25611
26:33:01.954 --> 26:33:05.954
and paste those two lines const
logger equals Morales dot Cloud

25612
26:33:05.954 --> 26:33:12.954
dot get logger logger dot info.
And we'll say If confirmed const

25613
26:33:12.954 --> 26:33:20.955
active item equals Morales dot
object dot extend active item

25614
26:33:20.955 --> 26:33:24.955
const query and for this query,
I'm actually just going to copy

25615
26:33:24.955 --> 26:33:26.955
these lines because this is
going to be exactly the same.

25616
26:33:26.955 --> 26:33:29.955
We're going to look for the NFT
address and the token ID and the

25617
26:33:29.955 --> 26:33:33.955
marketplace address. And if we
look in our NFT dot soul and up

25618
26:33:33.955 --> 26:33:36.955
to marketplace dot som alright
and bot event as the NFT

25619
26:33:36.955 --> 26:33:40.955
address. And the token ID which
is what we want to find are

25620
26:33:40.955 --> 26:33:44.955
listed and of team. So we'll run
that query. We'll do const bots

25621
26:33:44.955 --> 26:33:50.955
item equals await query dot
first, and we'll do exactly what

25622
26:33:50.955 --> 26:33:57.955
we did before. If bots item then
logger dot info, deleting

25623
26:33:57.955 --> 26:34:06.955
request dot object dot get
object ID await bought item dot

25624
26:34:06.955 --> 26:34:16.955
destroy logger dot info deleted
item with Open ID request dot

25625
26:34:16.955 --> 26:34:24.955
object dot get open ID at
address request dot object dot

25626
26:34:24.955 --> 26:34:26.955
get

25627
26:34:26.955 --> 26:34:30.955
address. And then if we don't
find it will say else. Logger

25628
26:34:30.955 --> 26:34:38.955
dot info, no item found with
address request that object dot

25629
26:34:38.955 --> 26:34:46.955
get address and token, Id
request that object dot get

25630
26:34:46.955 --> 26:34:50.955
token ID. Cool. So that looks
good. Let's go ahead and upload

25631
26:34:50.955 --> 26:34:56.956
this to the cloud. So do yarn
oralis Cloud changes uploaded

25632
26:34:56.956 --> 26:34:59.956
correctly. Let's go make sure it
looks good on our server. So

25633
26:34:59.956 --> 26:35:03.956
we'll give a morale server a
little refresh. Go to Cloud

25634
26:35:03.956 --> 26:35:07.956
Functions here. I can see the
item cancelled in here still.

25635
26:35:07.956 --> 26:35:11.956
And now I can see the item
bought after save perfect. Looks

25636
26:35:11.956 --> 26:35:14.956
like I'm at 100 percent capacity. So
we're gonna give it a second

25637
26:35:14.956 --> 26:35:17.956
just to cool down thinking give
it a little refresh and looks

25638
26:35:17.956 --> 26:35:19.956
like we're back down after our
cloud function has been

25639
26:35:19.956 --> 26:35:23.956
uploaded. Okay, cool. To test
out that this part is working.

25640
26:35:23.956 --> 26:35:26.956
Let's go ahead we'll write
another script here. Do new file

25641
26:35:26.956 --> 26:35:31.956
by item dot j s. And we'll do
the same thing right now. On our

25642
26:35:31.956 --> 26:35:35.956
database. We don't have any
active items. So we'll just run

25643
26:35:35.956 --> 26:35:40.956
real quick. We're on mint and
list. Mint a new one. We'll go

25644
26:35:40.956 --> 26:35:43.956
check our database we'll do a
little refresh. Looks like

25645
26:35:43.956 --> 26:35:47.956
active vitamins in here with a
token ID of two now. So we'll do

25646
26:35:47.956 --> 26:35:53.956
is we'll buy that token ID so
we'll say const ethers network

25647
26:35:53.956 --> 26:36:01.956
equals require arhats const move
blocks equals require dot slash

25648
26:36:01.956 --> 26:36:09.956
utils slash move blocks const
token ID equals to async

25649
26:36:09.956 --> 26:36:19.956
function by item const NFT
marketplace equals await ethers

25650
26:36:19.956 --> 26:36:26.956
dot get contract NF T
marketplace const basic NF t

25651
26:36:26.956 --> 26:36:36.957
equals await ethers dot get
contract basic NFT coms listing

25652
26:36:36.957 --> 26:36:42.957
equals await and ft market place
dot get listing basic NF T dot

25653
26:36:43.957 --> 26:36:51.957
address and the token ID will
say const price equals listing

25654
26:36:51.957 --> 26:36:56.957
that price that to string and
we'll say const Tx and this is

25655
26:36:56.957 --> 26:37:00.957
us going to actually buy it
equals await and ft marketplace

25656
26:37:00.957 --> 26:37:10.957
dot buy item basic n f t dot
address, token ID, comma. And

25657
26:37:10.957 --> 26:37:13.957
then the value of course is
going to be the price. Do await

25658
26:37:13.957 --> 26:37:21.957
TX dot wait one, console dot log
bots NF t. And then if network

25659
26:37:21.957 --> 26:37:31.957
dot config dot chain ID equals
31337, then await move blocks to

25660
26:37:31.957 --> 26:37:37.957
comma, sleep amount equals 1000.
And then this is a script of

25661
26:37:37.957 --> 26:37:39.957
course, so we're going to use
the same stuff we're using for

25662
26:37:39.957 --> 26:37:42.957
cancel. But instead of
cancelled, it's going to be

25663
26:37:42.957 --> 26:37:47.957
called by item. So we have the
item inactive item here, we run

25664
26:37:47.957 --> 26:37:55.957
yarn, art hat run scripts by
item.js Dash network, localhost.

25665
26:37:55.957 --> 26:37:59.957
Now we can test buying this
item. Okay, Bob, the NFT looping

25666
26:37:59.957 --> 26:38:02.957
blocks, we'll do a little
refresh on our database, and

25667
26:38:02.957 --> 26:38:06.957
boom, we can see the active item
is gone. And we can see, the

25668
26:38:06.957 --> 26:38:10.957
item has now been bought.
Awesome. We're almost done

25669
26:38:10.957 --> 26:38:14.957
keeping our active item, just a
table of active items. But

25670
26:38:14.957 --> 26:38:16.958
there's one more thing we should
do. We're not going to test this

25671
26:38:16.958 --> 26:38:19.958
here. But if you want to test
it, we can we actually in our

25672
26:38:19.958 --> 26:38:23.958
NFT marketplace, go to
marketplace dot Sol, we actually

25673
26:38:23.958 --> 26:38:27.958
have an update listing function
as well, that also admits an

25674
26:38:27.958 --> 26:38:32.958
item listed. So we also want to
check to see if item listed is

25675
26:38:32.958 --> 26:38:37.958
coming from update listening. So
back in our item listed Cloud

25676
26:38:37.958 --> 26:38:41.958
Function, before we actually
start saving stuff, we want to

25677
26:38:41.958 --> 26:38:45.958
check to see if it already
exists. So we're gonna say so

25678
26:38:45.958 --> 26:38:52.958
we'll say const query equals new
mirallas dot query. And sorry, I

25679
26:38:52.958 --> 26:38:56.958
keep sticking the sin of active
item. And we're going to do

25680
26:38:56.958 --> 26:38:59.958
exactly what we've been doing.
We're gonna say query dot equal

25681
26:38:59.958 --> 26:39:03.958
to NFT. Address, we're gonna
look for the NFT address request

25682
26:39:04.958 --> 26:39:11.958
dot object dot get and ft
address, query dot equal to

25683
26:39:11.958 --> 26:39:18.958
token ID, request that object
dot get token ID, query dot

25684
26:39:18.958 --> 26:39:26.958
equal to marketplace, address,
comma request dot object dot get

25685
26:39:26.958 --> 26:39:35.958
address query dot equal to
seller requests dot object dot

25686
26:39:35.958 --> 26:39:42.958
get seller will say const
already listed item equals await

25687
26:39:42.958 --> 26:39:47.958
query dot first. And then we'll
say if this item has already

25688
26:39:47.958 --> 26:39:52.958
been listed. Then we'll go ahead
and say logger dot info.

25689
26:39:52.958 --> 26:40:00.959
Deleting already listed request
dot object dot get object ID.

25690
26:40:00.959 --> 26:40:06.959
And we'll do a weight already
listed item dot destroy. And

25691
26:40:06.959 --> 26:40:16.959
then do logger dot info, deleted
item with token ID request dot

25692
26:40:16.959 --> 26:40:24.959
object dot get token ID at
address request dot object dot

25693
26:40:24.959 --> 26:40:31.959
get address since it's already
been listed, if the object has

25694
26:40:31.959 --> 26:40:33.959
already been listed, we know
that it's coming from this

25695
26:40:33.959 --> 26:40:37.959
update listing function. So
we're going to delete it first,

25696
26:40:37.959 --> 26:40:40.959
and then we'll resave it with
its new price. So and let's just

25697
26:40:40.959 --> 26:40:46.959
go ahead, and let's upload this
to the cloud yarn Morales cloud.

25698
26:40:46.959 --> 26:40:50.959
upload this to our server
changes uploaded correctly.

25699
26:40:50.959 --> 26:40:54.959
Let's go check our server, give
it a little refresh. We'll go

25700
26:40:54.959 --> 26:41:00.959
check Cloud Functions. And it
looks like our item listed query

25701
26:41:00.959 --> 26:41:04.959
for deleting is now in here. But
with all that, we now have a way

25702
26:41:04.959 --> 26:41:09.959
to constantly have this active
item table only be the items

25703
26:41:09.959 --> 26:41:12.959
that are actively on our
marketplace without having to

25704
26:41:12.959 --> 26:41:15.959
spend any additional gas in our
application. And this is going

25705
26:41:15.959 --> 26:41:18.959
to be way better for user
experience because they're not

25706
26:41:18.959 --> 26:41:21.959
going to have to pay extra gas
to keep all these entities and

25707
26:41:21.959 --> 26:41:24.959
maybe an array or some more data
structures. If you've made it

25708
26:41:24.959 --> 26:41:28.959
this far. This is easily one of
the hardest parts of this

25709
26:41:28.959 --> 26:41:31.959
course, because we're working
with a ton of technologies.

25710
26:41:31.959 --> 26:41:33.959
We're working with a smart
contract, we're working with

25711
26:41:33.959 --> 26:41:37.960
Cloud Functions, we're working
with a back end database. Now if

25712
26:41:37.960 --> 26:41:40.960
you've made it this far, you
should be incredibly incredibly

25713
26:41:40.960 --> 26:41:45.960
proud. So now let's just go
ahead, let's mint and list one

25714
26:41:45.960 --> 26:41:50.960
more NFT. So we'll do we'll run
yarn heart at run scripts, mint

25715
26:41:50.960 --> 26:41:53.960
and list network local hosts
will meant it will list it or

25716
26:41:53.960 --> 26:41:56.960
sleeping. Let's go check our
database. We'll do a refresh. We

25717
26:41:56.960 --> 26:42:01.960
see the active item in here. And
now let's learn how to call all

25718
26:42:01.960 --> 26:42:06.960
of the objects in In our active
item database here, let's do it.

25719
26:42:06.960 --> 26:42:09.960
And remember, if you ever reset
your local blockchain, you're

25720
26:42:09.960 --> 26:42:12.960
gonna have to come in here and
delete all the rows in the

25721
26:42:12.960 --> 26:42:16.960
support tables.

25722
26:42:16.960 --> 26:42:20.960
With all that being said, it's
time to finally come back to our

25723
26:42:20.960 --> 26:42:25.960
front end, and come back to our
index dot J. S and answer this

25724
26:42:25.960 --> 26:42:30.960
question. How do we show the
recently listed NF Ts, we only

25725
26:42:30.960 --> 26:42:33.960
want to show the active NF t's
on the marketplace. And now we

25726
26:42:33.960 --> 26:42:38.960
have a system for getting only
the active ones, only the ones

25727
26:42:38.960 --> 26:42:41.960
that are currently on the
market, because we're indexing

25728
26:42:41.960 --> 26:42:44.960
these events. Now, I'm going to
delete all these comments here.

25729
26:42:44.960 --> 26:42:47.960
And let's do this. So what we're
going to do is we're going to do

25730
26:42:47.960 --> 26:42:50.960
this thing called use Morales
query. So if we go to the React

25731
26:42:50.960 --> 26:42:55.960
Morales docks, there is a hook
called use Morales query. And

25732
26:42:55.960 --> 26:42:59.960
this allows us to fetch and make
queries to our database in a

25733
26:42:59.960 --> 26:43:03.960
React context. Back in here,
we're going to say, import, use

25734
26:43:03.960 --> 26:43:09.960
Morales query from react
mirallas. Now, if you look in

25735
26:43:09.960 --> 26:43:14.960
the docs here, use mouse query
returns data error is loading.

25736
26:43:14.960 --> 26:43:18.961
And this will automatically run
this query the instant our index

25737
26:43:18.961 --> 26:43:22.961
pops up. So to get the data from
the query to get all of our

25738
26:43:22.961 --> 26:43:26.961
active items from our database,
we'll say const data, and we'll

25739
26:43:26.961 --> 26:43:31.961
rename data to listed and fts.
And then we'll also check to see

25740
26:43:31.961 --> 26:43:35.961
if this query is still fetching.
So we'll say is fetching and

25741
26:43:35.961 --> 26:43:42.961
then we'll rename that to
fetching listed NF t is equals

25742
26:43:42.961 --> 26:43:46.961
use Morales query. And inside
here, this takes two input

25743
26:43:46.961 --> 26:43:49.961
parameters, it takes the table
name to do the search on and

25744
26:43:49.961 --> 26:43:54.961
then it also takes a function or
the query. So the table name

25745
26:43:54.961 --> 26:43:57.961
that we're going to be looking
for is going to be active item.

25746
26:43:57.961 --> 26:44:01.961
And then the function for the
query is going to be we're going

25747
26:44:01.961 --> 26:44:06.961
to say query dot, we'll limit it
just to 10. So we'll say only

25748
26:44:06.961 --> 26:44:12.961
the first 10, we'll do it in dot
descending order, based off the

25749
26:44:12.961 --> 26:44:16.961
token ID. And then if we wanted
to do different pages, we could

25750
26:44:16.961 --> 26:44:20.961
do this thing called dot skip
with page numbers, we're not

25751
26:44:20.961 --> 26:44:22.961
going to do page numbers here.
So we're just going to leave it

25752
26:44:22.961 --> 26:44:24.961
like this for now. And that's
it. So we're saying, okay,

25753
26:44:25.961 --> 26:44:29.961
great, grab from our database on
the active item table, grab just

25754
26:44:29.961 --> 26:44:33.961
the first 10 in descending order
of the token ID. Now it's going

25755
26:44:33.961 --> 26:44:38.961
to save the result of this to
this listed NF TS section. Now

25756
26:44:38.961 --> 26:44:43.961
to see if this is working. Let's
just do a little console dot log

25757
26:44:43.961 --> 26:44:47.961
listed NF t's just to see what
this using Ross query actually

25758
26:44:47.961 --> 26:44:50.961
returns for us. And now we have
our local blockchain Node

25759
26:44:50.961 --> 26:44:54.961
running, we have our connection
to our Morales server, and we

25760
26:44:54.961 --> 26:44:57.962
have our front end running. So
let's go to our front end, we'll

25761
26:44:57.962 --> 26:45:00.962
do a little refresh here, we'll
right click and hit Inspect,

25762
26:45:00.962 --> 26:45:04.962
we'll go to the console. And we
see we have this array being

25763
26:45:04.962 --> 26:45:08.962
spit out here. Now the first
time it console dot logs, it's

25764
26:45:08.962 --> 26:45:13.962
empty. This is because when it
initially loads listed out of

25765
26:45:13.962 --> 26:45:15.962
T's hasn't returned yet. And
it's so it's actually just going

25766
26:45:15.962 --> 26:45:18.962
to be an empty array. But when
it finishes loading, we're going

25767
26:45:18.962 --> 26:45:21.962
to get an array of size one, we
get an array of size one,

25768
26:45:21.962 --> 26:45:24.962
because active item only has one
enter right now. So we get this

25769
26:45:24.962 --> 26:45:28.962
array of size one, and we can
see it index zero, we have class

25770
26:45:28.962 --> 26:45:32.962
name active item, we have the
item ID, we have all these

25771
26:45:32.962 --> 26:45:35.962
attributes, which are going to
be created at the marketplace

25772
26:45:35.962 --> 26:45:38.962
address. And if the address the
price, the seller and the token

25773
26:45:38.962 --> 26:45:43.962
ID this is exactly what we see
in our database here. So

25774
26:45:43.962 --> 26:45:46.962
Perfect. That's exactly what we
want to be able to show these NF

25775
26:45:46.962 --> 26:45:50.962
t's on the front end. So how do
we actually show this NFT and

25776
26:45:50.962 --> 26:45:53.962
list this NF T. For people who
aren't developers and aren't

25777
26:45:53.962 --> 26:45:55.962
going to go into the console dot
log? Well, what we're going to

25778
26:45:55.962 --> 26:46:00.962
be doing is in this return here,
we'll put some parentheses

25779
26:46:00.962 --> 26:46:03.962
around this. First, we should
check to see if we are fetching

25780
26:46:03.962 --> 26:46:07.962
those listed NF T's. So we'll do
some JavaScript stuff. And we'll

25781
26:46:07.962 --> 26:46:11.962
say fetching listed NF T's and
we'll do a ternary operator. So

25782
26:46:11.962 --> 26:46:15.962
we're gonna say if we are
fetching those NF T's, let's add

25783
26:46:15.962 --> 26:46:19.962
like a little div div that just
says loading that that done,

25784
26:46:19.962 --> 26:46:22.962
we'll put a little colon here.
And if we're not fetching, we'll

25785
26:46:22.962 --> 26:46:29.962
do we'll say listed NF TS dot
map. So dot map basically loops

25786
26:46:29.962 --> 26:46:35.962
through and does some function
on all of the listed entities in

25787
26:46:35.962 --> 26:46:37.963
the function we're going to want
ours to do. And it's going to

25788
26:46:37.963 --> 26:46:41.963
take each NF t as input
parameters. So we say we're

25789
26:46:41.963 --> 26:46:44.963
going to basically loop through
each NF T. And we're going to

25790
26:46:44.963 --> 26:46:50.963
say, console dot log and F T dot
attribute attributes with an S.

25791
26:46:50.963 --> 26:46:54.963
And then inside of these inside
of this attributes are the

25792
26:46:54.963 --> 26:46:56.963
different pieces that we want.
So we're going to get those

25793
26:46:56.963 --> 26:47:01.963
pieces we'll say const we want
to show the price. The NFT

25794
26:47:01.963 --> 26:47:05.963
address, the token ID in the
marketplace address, which of

25795
26:47:05.963 --> 26:47:08.963
course is just gonna be this
one, and then the seller, that's

25796
26:47:08.963 --> 26:47:10.963
all this information that we're
going to want to show on the

25797
26:47:10.963 --> 26:47:15.963
front end will say that equals
NF T dot attributes. So we're

25798
26:47:15.963 --> 26:47:19.963
going to pull these out, and we
can see price seller token ID,

25799
26:47:19.963 --> 26:47:22.963
etc. We're going to pull those
out of NF T dot attributes. And

25800
26:47:22.963 --> 26:47:26.963
we can show those by in this
function here, we'll say return.

25801
26:47:26.963 --> 26:47:30.963
And then we'll return some HTML,
we'll do like div div. And then

25802
26:47:30.963 --> 26:47:34.963
we can say like price, price,
price,

25803
26:47:34.963 --> 26:47:44.963
period, and f t address and ft
address, token ID, token ID

25804
26:47:44.963 --> 26:47:48.963
seller, then added this for some
reason. So I'm going to delete

25805
26:47:48.963 --> 26:47:52.963
that add $1 signs before all
these for some reason, delete

25806
26:47:52.963 --> 26:47:56.963
those, save. Now if I go to the
front end, I can now see

25807
26:47:56.963 --> 26:48:01.963
information about our NFT from
our database is listed here.

25808
26:48:01.963 --> 26:48:04.963
That's fantastic. We see the
price we see the address, we see

25809
26:48:04.963 --> 26:48:08.963
the token ID we see the seller.
Now if we go back to our NFT

25810
26:48:08.963 --> 26:48:11.963
marketplace, our little our
little hard hat MC marketplace,

25811
26:48:11.963 --> 26:48:15.963
let's mint another one. Yarn
hard hat run scripts mentalist

25812
26:48:15.963 --> 26:48:19.964
Dash network localhost, we're
going to run that it's going to

25813
26:48:19.964 --> 26:48:23.964
mint one more. If we go back to
our Morales database, we do a

25814
26:48:23.964 --> 26:48:27.964
little refresh on that active
item table, we now have a new

25815
26:48:27.964 --> 26:48:31.964
item in here. So if we go back
to our front end, we give this a

25816
26:48:31.964 --> 26:48:35.964
little refresh. And boom, now we
have two items in here. So this

25817
26:48:35.964 --> 26:48:38.964
is awesome, we now have a way to
actually show the most recently

25818
26:48:38.964 --> 26:48:44.964
listed NF t's on our
marketplace, plus ah.

25819
26:48:44.964 --> 26:48:46.964
Now, of course, you might be
saying to yourself, hey,

25820
26:48:46.964 --> 26:48:51.964
Patrick, that's cool and all.
But that looks really ugly. And

25821
26:48:51.964 --> 26:48:55.964
I would agree with you. But 100 percent
agree with you. So we should

25822
26:48:55.964 --> 26:48:59.964
come up with a component to show
our listed entities that looks a

25823
26:48:59.964 --> 26:49:02.964
lot nicer. So when instead of
returning and just printing out

25824
26:49:02.964 --> 26:49:05.964
the raw information, we probably
want to show the image, right,

25825
26:49:05.964 --> 26:49:08.964
we want to show the image, we
want to make everything look a

25826
26:49:08.964 --> 26:49:10.964
lot nicer. So we're going to
create a new component that

25827
26:49:10.964 --> 26:49:13.964
we're going to return in here to
format all of our NF T's

25828
26:49:13.964 --> 26:49:17.964
appropriately. So we're gonna go
to components, we'll do new

25829
26:49:17.964 --> 26:49:21.964
file, and we're going to call NF
T box dot j s. And this is where

25830
26:49:21.964 --> 26:49:24.964
we're going to grab all the
information on how to show what

25831
26:49:24.964 --> 26:49:27.964
our NFT actually looks like. So
let's get started working on our

25832
26:49:27.964 --> 26:49:30.964
entity box, we're gonna set this
up, the way we've been setting

25833
26:49:30.964 --> 26:49:35.964
all these up would do export
default function, and ft box.

25834
26:49:35.964 --> 26:49:38.964
Now something that's a little
bit different for this one,

25835
26:49:38.964 --> 26:49:42.964
though, is that in our index, we
have all this information. So

25836
26:49:42.964 --> 26:49:47.964
we're gonna need to pass all
these variables to our NFT Box

25837
26:49:47.964 --> 26:49:50.964
component. So to do that, we'll
add them as input parameters for

25838
26:49:50.964 --> 26:49:54.964
our component here. So we'll say
price, and if the address, token

25839
26:49:54.964 --> 26:50:00.965
ID, marketplace, address, and
seller. So right now on our

25840
26:50:00.965 --> 26:50:02.965
front end, we just have a whole
bunch of text, and we even have

25841
26:50:02.965 --> 26:50:04.965
this gross warning, we're gonna
get rid of that tip. And as we

25842
26:50:04.965 --> 26:50:08.965
know, tokens have their token
URI, which points to an image

25843
26:50:08.965 --> 26:50:13.965
URI or an image URL of what the
actual token looks like. So what

25844
26:50:13.965 --> 26:50:16.965
we're going to want to do is
we're going to want to call that

25845
26:50:16.965 --> 26:50:20.965
token URI, and then call the
image URI to show the image. So

25846
26:50:20.965 --> 26:50:24.965
we're going to actually have to
wait those two API requests to

25847
26:50:24.965 --> 26:50:28.965
get the actual image. And we're
going to save that image as a

25848
26:50:28.965 --> 26:50:32.965
state variable on this component
here. So as you already know,

25849
26:50:32.965 --> 26:50:34.965
we're going to work with use
state to keep track of that

25850
26:50:34.965 --> 26:50:41.965
image URI. So we'll do import,
use state from react like this.

25851
26:50:41.965 --> 26:50:48.965
And in here, we'll say const,
image, Uri, comma set image, URI

25852
26:50:48.965 --> 26:50:53.965
equals use state. And we'll
start it off as a blank string.

25853
26:50:53.965 --> 26:50:57.965
Now let's create a function,
we're going to call it update UI

25854
26:50:57.965 --> 26:51:01.965
to update our UI and grab this
token URI and the image URI. So

25855
26:51:01.965 --> 26:51:06.965
we'll create an async function
called Update UI. And in order

25856
26:51:06.965 --> 26:51:10.965
to get the image first, we're
gonna need to get the token URI,

25857
26:51:10.965 --> 26:51:17.965
and then using the image ag from
the token URI gets the image. So

25858
26:51:17.965 --> 26:51:20.965
first thing we're gonna have to
do is get the token URI. So we

25859
26:51:20.965 --> 26:51:24.965
know how to do this with use web
three contract. So we'll do

25860
26:51:24.965 --> 26:51:29.965
import, use web three contract
from react Morales. And as we

25861
26:51:29.965 --> 26:51:31.965
know, use web through contracts
is going to need some

25862
26:51:31.965 --> 26:51:38.966
parameters. So we'll say const
run contract function, get token

25863
26:51:38.966 --> 26:51:44.966
URI, equals, use web through
contract. First, we need the ABI

25864
26:51:44.966 --> 26:51:48.966
of the NFT because we're gonna
need to call token URI. So to

25865
26:51:48.966 --> 26:51:51.966
get the ABI we're gonna need to
once again update our front end.

25866
26:51:51.966 --> 26:51:54.966
So let's comment this part out.
We'll go back to our hard hat

25867
26:51:54.966 --> 26:51:58.966
piece. And let's look in our
deploy scripts. We have this

25868
26:51:58.966 --> 26:52:03.966
update front end right now. All
this is doing is updating calm

25869
26:52:03.966 --> 26:52:05.966
object addresses. Well, that's
good. We're also going to want

25870
26:52:05.966 --> 26:52:09.966
to add API's to our front end as
well. So let's create another

25871
26:52:09.966 --> 26:52:12.966
function in here called Update
API. And we'll pass the API's as

25872
26:52:12.966 --> 26:52:17.966
well. So we'll do async function
update API. And we'll give it

25873
26:52:17.966 --> 26:52:22.966
both the basic NFT API and the
NFT marketplace API, because

25874
26:52:22.966 --> 26:52:25.966
we're going to need both of
them. So we'll say const NF T,

25875
26:52:25.966 --> 26:52:32.966
marketplace equals await ethers
dot get contract. And f t

25876
26:52:32.966 --> 26:52:35.966
marketplace, we're going to
write the ABI to the front end

25877
26:52:35.966 --> 26:52:39.966
API location, we have the front
end contracts file. So let's

25878
26:52:39.966 --> 26:52:46.966
also do a const. Front and ABI
location equals, and we'll do

25879
26:52:46.966 --> 26:52:54.966
dot dot slash next, Jas, and if
T marketplace dash FCC slash

25880
26:52:54.966 --> 26:52:56.966
constants, and instead of
actually just giving the file

25881
26:52:56.966 --> 26:53:00.966
name, we can just give it the
front end API location. And then

25882
26:53:00.966 --> 26:53:03.966
we'll actually have it generate
that file for us because we're

25883
26:53:03.966 --> 26:53:06.966
just going to overwrite the ABI
file anytime we work with it. So

25884
26:53:06.966 --> 26:53:09.966
now that we have the
marketplace, we'll just do Fs

25885
26:53:09.966 --> 26:53:16.967
dot right file sync, and we'll
do front and ABI location, and

25886
26:53:16.967 --> 26:53:26.967
ft marketplace, dot JSON. And ft
marketplace, dot interface that

25887
26:53:26.967 --> 26:53:33.967
format ethers dot utils dot
format types dot JSON. So we're

25888
26:53:33.967 --> 26:53:35.967
also going to want to do that
for the basic NF t. So we'll say

25889
26:53:35.967 --> 26:53:41.967
const basic NF t equals await
ethers dot get contract basic NF

25890
26:53:41.967 --> 26:53:47.967
T Fs dot right? file sync, it's
going to be that exact same

25891
26:53:47.967 --> 26:53:50.967
place right here. Except for
it's going to be a different

25892
26:53:50.967 --> 26:53:55.967
location, it's going to be basic
NFT dot JSON. And of course,

25893
26:53:55.967 --> 26:54:00.967
we're gonna do a comma basic NF
T, that interface dot format

25894
26:54:00.967 --> 26:54:05.967
ethers dot utils, dot format,
types dot JSON, you can find

25895
26:54:05.967 --> 26:54:08.967
this NFT marketplace that
interface in the Hardhead

25896
26:54:08.967 --> 26:54:11.967
documentation. And you can find
this in the ethers

25897
26:54:11.967 --> 26:54:15.967
documentation. So now we have
this update ABI function. Let's

25898
26:54:15.967 --> 26:54:19.967
also add this to our module that
exports so we'll do a weight up

25899
26:54:19.967 --> 26:54:23.967
the ABI like that.

25900
26:54:23.967 --> 26:54:25.967
There's a hyphen here that
shouldn't be here. And we'll run

25901
26:54:25.967 --> 26:54:31.967
just this part of our hardhat
front end, run yarn, hard hat,

25902
26:54:31.967 --> 26:54:36.967
deploy dash, dash dash tags, the
tag here is front end, front

25903
26:54:36.967 --> 26:54:39.967
end. And now it's had nothing to
compile updating front end, it's

25904
26:54:39.967 --> 26:54:42.967
done. So if we go back to our
front end, now, we go to our

25905
26:54:42.967 --> 26:54:46.967
constants, we now see two
objects in here, which are going

25906
26:54:46.967 --> 26:54:50.967
to be API's, the basic NFT, and
the NFT. Marketplace. Awesome.

25907
26:54:50.967 --> 26:54:54.967
So now that we have that, we can
import those into our front end.

25908
26:54:54.967 --> 26:55:00.968
So we can say import, and if T
marketplace, abi from dot dot

25909
26:55:00.968 --> 26:55:07.968
slash constants slash NF T,
marketplace dot JSON. And we can

25910
26:55:07.968 --> 26:55:12.968
also get the NF T API. So we'll
do import NF T, abi from that

25911
26:55:12.968 --> 26:55:18.968
the slash constants slash basic
NF T dot JSON. Now in our run

25912
26:55:18.968 --> 26:55:23.968
contract function, our token URI
function is part of the NFT API.

25913
26:55:23.968 --> 26:55:29.968
So the API will be the NFT, abi,
the contract address

25914
26:55:29.968 --> 26:55:32.968
is going to be the address of
the NFT, which we're passing in

25915
26:55:32.968 --> 26:55:36.968
as a parameter. So we'll pass an
NF T address, the function name

25916
26:55:36.968 --> 26:55:41.968
is going to be token URI, and
the params are going to be the

25917
26:55:41.968 --> 26:55:45.968
token ID, which is getting
passed as an input parameter to

25918
26:55:45.968 --> 26:55:49.968
this function to this component.
Right. And we can double check.

25919
26:55:49.968 --> 26:55:53.968
We're good to our basic NF T dot
soul, right? We scroll down, we

25920
26:55:53.968 --> 26:55:55.968
have this token URI that we're
overriding. And this is the

25921
26:55:55.968 --> 26:55:59.968
function we want to call takes
the token ID. So this the

25922
26:55:59.968 --> 26:56:02.968
function we want to call takes
the token ID. Okay, great. So in

25923
26:56:02.968 --> 26:56:08.968
our update UI, first, we'll say
const, token URI equals await

25924
26:56:08.968 --> 26:56:13.968
token URI. Now let's do a little
console dot log token your eye,

25925
26:56:13.968 --> 26:56:16.968
just to see what this returns to
make sure that update UI is

25926
26:56:16.968 --> 26:56:20.968
called, we'll add it to a use
effect, we'll say use effect.

25927
26:56:20.968 --> 26:56:23.968
And this takes an input
parameter of a function to do,

25928
26:56:23.968 --> 26:56:28.968
we'll just say Update UI. And
then we'll only have this run

25929
26:56:28.968 --> 26:56:33.968
anytime is web three enabled
changes. So we want to run

25930
26:56:33.968 --> 26:56:36.968
update UI, but we want it to be
dependent on is web three

25931
26:56:36.968 --> 26:56:41.969
enabled. And then we'll say if
it's web three enabled, then

25932
26:56:41.969 --> 26:56:44.969
update UI. So we need to add use
effect as well. So we're using

25933
26:56:44.969 --> 26:56:49.969
use state, we'll do comma, use
effect. And now we should at

25934
26:56:49.969 --> 26:56:52.969
least be reading our token URI
off the blockchain. We're not

25935
26:56:52.969 --> 26:56:54.969
going to set the image yet,
right, because we're going to

25936
26:56:54.969 --> 26:56:58.969
get the image URI from the token
neuron. Let's add this NFT box

25937
26:56:58.969 --> 26:57:02.969
to our index to see if it's
working well so far back in our

25938
26:57:02.969 --> 26:57:09.969
index Next, up at the top, we
will import NF T box from dot

25939
26:57:09.969 --> 26:57:14.969
dot slash components slash NF T
box. And down here, while we're

25940
26:57:14.969 --> 26:57:18.969
returning this will add our NF T
box component will make sure to

25941
26:57:18.969 --> 26:57:21.969
pass in all the parameters it
takes. So the price is going to

25942
26:57:21.969 --> 26:57:27.969
equal that JavaScript price. And
ft address is going to equal the

25943
26:57:27.969 --> 26:57:31.969
JavaScript entity address. The
token ID is going to equal the

25944
26:57:31.969 --> 26:57:39.969
token ID, marketplace address is
going to be marketplace address

25945
26:57:39.969 --> 26:57:43.969
seller is going to be the
seller. And you saw that warning

25946
26:57:43.969 --> 26:57:45.969
where it's saying, hey, all the
components need to all the

25947
26:57:45.969 --> 26:57:49.969
things in the mapping need to
have their unique key. So we'll

25948
26:57:49.969 --> 26:57:52.969
say key, we'll give these all a
key as well. We'll say key

25949
26:57:52.969 --> 26:57:55.969
equals this, we'll do some
string interpolation, we'll just

25950
26:57:55.969 --> 26:57:59.969
say the NFT address, combined
with the token ID can be the

25951
26:57:59.969 --> 26:58:03.969
key. So if we save that, go back
to our front end here, do a

25952
26:58:03.969 --> 26:58:08.969
little refresh marketplace
address is not defined market

25953
26:58:08.969 --> 26:58:11.969
place address. So let's make
sure we spell things right,

25954
26:58:11.969 --> 26:58:14.969
let's go back to the front end,
we'll give it a refresh is what

25955
26:58:14.969 --> 26:58:17.970
three enabled is not defined.
Oops, excuse me in the NFT box,

25956
26:58:17.970 --> 26:58:20.970
we need to grab that from us
Morales, so we'll import use

25957
26:58:20.970 --> 26:58:27.970
Morales. And in our ponents here
we'll say const is web three

25958
26:58:27.970 --> 26:58:33.970
enabled equals use Morales.
We'll save that. And one thing I

25959
26:58:33.970 --> 26:58:36.970
noticed actually is this needs
to be wrapped in squigglies.

25960
26:58:36.970 --> 26:58:39.970
Sorry, I forgot to do that. Our
component actually just takes a

25961
26:58:39.970 --> 26:58:42.970
props, props input parameter.
And we would need to do like

25962
26:58:42.970 --> 26:58:46.970
props that token ID to get token
ID. But instead, we just extract

25963
26:58:46.970 --> 26:58:50.970
it out by doing putting the
little squiggly brackets here.

25964
26:58:50.970 --> 26:58:52.970
So put the squiggly brackets
there. Great, we'll do a little

25965
26:58:52.970 --> 26:58:56.970
console dot log token, your eye,
or index.js has everything

25966
26:58:56.970 --> 26:59:00.970
updated. Here. Let's do a little
save. And we can even say if is

25967
26:59:00.970 --> 26:59:05.970
web three enabled up the UI.
Like that we'll save we'll go to

25968
26:59:05.970 --> 26:59:07.970
the front end, we'll do a little
refresh. We'll see if

25969
26:59:07.970 --> 26:59:10.970
everything's working as
expected. And as long as we're

25970
26:59:10.970 --> 26:59:13.970
on that hard had localhost and
our meta mask. And again, you

25971
26:59:13.970 --> 26:59:16.970
can ignore this error, this
warning that's up here for now.

25972
26:59:16.970 --> 26:59:20.970
And if you click this, and you
have your IPFS and brave or your

25973
26:59:20.970 --> 26:59:24.970
IPFS companion, we can now see
we're getting our token URI,

25974
26:59:24.970 --> 26:59:27.970
which is perfect. The piece that
we want now is this image bid.

25975
26:59:27.970 --> 26:59:30.970
And for this one that I'm using
it is an HTTPS, which

25976
26:59:30.970 --> 26:59:33.970
technically isn't decentralized,
right, we would need it to come

25977
26:59:33.970 --> 26:59:37.970
from instead of HTTPS, we would
need to come from IPFS colon

25978
26:59:37.970 --> 26:59:42.970
slash slash but but actually
having it as HTTPS ipfs.io. For

25979
26:59:42.970 --> 26:59:45.970
now was good, we'll explain why
in just a second. Now that we

25980
26:59:45.970 --> 26:59:50.970
are getting the token URI, we
can call this URL, and we can

25981
26:59:50.970 --> 26:59:54.970
get back the image that we want
to actually show on the front

25982
26:59:54.970 --> 26:59:58.971
end. So in here, we'll do a
little console dot log, the

25983
26:59:58.971 --> 27:00:04.971
token, URI is string
interpolation, like this, and

25984
27:00:04.971 --> 27:00:08.971
then we'll say if token URI,
we're going to need to now grab

25985
27:00:08.971 --> 27:00:12.971
this token URI, and get the
image from it. And this is where

25986
27:00:12.971 --> 27:00:14.971
we're going to get a little bit
funky. And we're going to cheat

25987
27:00:14.971 --> 27:00:17.971
a little bit. Now for our
application, not everybody is

25988
27:00:17.971 --> 27:00:22.971
going to have IPFS companion,
not every browser is IPFS

25989
27:00:22.971 --> 27:00:26.971
compatible. So we're gonna have
to actually cheat a little bit

25990
27:00:26.971 --> 27:00:29.971
here, we're actually going to
change the token Uriah from its

25991
27:00:29.971 --> 27:00:34.971
IPFS edition to an H HTTPS
edition. And this is known as

25992
27:00:34.971 --> 27:00:42.971
using an IPFS gateway, which is
a server that will return IPFS

25993
27:00:42.971 --> 27:00:47.971
files from a normal URL. So
we're going to use an IPFS

25994
27:00:47.971 --> 27:00:52.971
gateway, which we can just make
regular HTTPS calls to, and it

25995
27:00:52.971 --> 27:00:55.971
will return those IPFS files. So
technically, are we making the

25996
27:00:55.971 --> 27:00:59.971
centralized doing this? Yes. And
is that ideal? No. However,

25997
27:00:59.971 --> 27:01:02.971
until the world adopt IPFS, and
until the world adopts the

25998
27:01:02.971 --> 27:01:05.971
standards, it's kind of what we
have to do right now. Because

25999
27:01:05.971 --> 27:01:07.971
otherwise, the front end will
just show up as blank to them.

26000
27:01:07.971 --> 27:01:10.971
And we can't have that we don't
want that. So we're gonna say

26001
27:01:10.971 --> 27:01:18.971
const request URL equals token
URI dot replace IPFS, slash

26002
27:01:18.971 --> 27:01:25.971
slash with HTTP s, HTTPS.

26003
27:01:25.971 --> 27:01:28.971
slash slash ipfs.io/ipfs/so.
We're saying, if you have a

26004
27:01:28.971 --> 27:01:32.971
token URI that starts with IPFS,
that's great. But we're going to

26005
27:01:32.971 --> 27:01:35.971
switch it to using an IPFS
gateway. It's really use the

26006
27:01:35.971 --> 27:01:41.972
IPFS gateway provided by the
team that builds IPFS. So pretty

26007
27:01:41.972 --> 27:01:44.972
reliable gateway is is kind of a
cop out. Yes. Are our files

26008
27:01:44.972 --> 27:01:48.972
still on? IPFS? Yes. So it's not
the end of the world. But this

26009
27:01:48.972 --> 27:01:52.972
is just going to make calling
these API's a lot easier for us.

26010
27:01:52.972 --> 27:01:59.972
And we're going to say const
token URI. Response equals

26011
27:01:59.972 --> 27:02:02.972
await. And this is going to be a
little weird. We're going to do

26012
27:02:02.972 --> 27:02:10.972
two awaits. await a weight fetch
request, URL dot JSON. So fetch

26013
27:02:10.972 --> 27:02:15.972
is a keyword you can use in
JavaScript to fetch or get a URL

26014
27:02:15.972 --> 27:02:18.972
fetch keyword is essentially
doing the same thing as pasting

26015
27:02:18.972 --> 27:02:22.972
this into the browser, like so.
And getting this JSON response.

26016
27:02:22.972 --> 27:02:25.972
So we await to get the response.
And then we await to convert the

26017
27:02:25.972 --> 27:02:29.972
response to JSON. And that's how
we get the toggle response. So

26018
27:02:29.972 --> 27:02:33.972
we now have this object in our
JavaScript, which is perfect

26019
27:02:33.972 --> 27:02:37.972
because this object has this
image attribute that we want. So

26020
27:02:37.972 --> 27:02:39.972
we're gonna do the same thing we
did here, we're gonna use the

26021
27:02:39.972 --> 27:02:44.972
IPFS gateway, this one's already
using HTTPS that ipfs.io. But if

26022
27:02:44.972 --> 27:02:46.972
it wasn't, we would still want
to convert it. So now we're

26023
27:02:46.972 --> 27:02:53.972
gonna say const. Image URI
equals token you are i response

26024
27:02:53.972 --> 27:02:58.972
dot image. So we're gonna get
the image tag of this response

26025
27:02:58.972 --> 27:03:04.972
here. And then we're going to
say const. Image URI URL, is

26026
27:03:04.972 --> 27:03:06.972
going to equal to, and we're
gonna do the exact same thing

26027
27:03:06.972 --> 27:03:10.972
that we did up here, we're going
to use the gateway image URI dot

26028
27:03:10.972 --> 27:03:19.973
replace IPFS, colon slash slash
with HTTPS ipfs.io/ipfs. And

26029
27:03:19.973 --> 27:03:24.973
now, and that's how we get this
URL right here. And so we can

26030
27:03:24.973 --> 27:03:32.973
finally do set image URI, to
that image URL. And now we have

26031
27:03:32.973 --> 27:03:35.973
our image URI is going to be
that image right here. Now, is

26032
27:03:35.973 --> 27:03:38.973
this a little bit wonky? Yes.
Are there better ways that we

26033
27:03:38.973 --> 27:03:40.973
can do this? Yes, there's
actually a number of better ways

26034
27:03:40.973 --> 27:03:43.973
that we could do some of this,
we could actually, since we're

26035
27:03:43.973 --> 27:03:47.973
using Morales, we could render
image on our server and just

26036
27:03:47.973 --> 27:03:51.973
call our server, what else could
we do well, or test nets and

26037
27:03:51.973 --> 27:03:53.973
maintenance routes actually
comes with a bunch of hooks like

26038
27:03:53.973 --> 27:03:58.973
us NFT balance that will show us
an F TS show us how many NF T's

26039
27:03:58.973 --> 27:04:02.973
shows all this information about
NF T's but it only works on test

26040
27:04:02.973 --> 27:04:05.973
nets and main net, we'd have the
world adopt IPFS. So we don't

26041
27:04:05.973 --> 27:04:08.973
have to do this wrapping.
Unfortunately, it doesn't yet so

26042
27:04:08.973 --> 27:04:11.973
such as life. But now that we're
setting the image, alright, we

26043
27:04:11.973 --> 27:04:14.973
have this image URI, we have
what this actually looks like,

26044
27:04:14.973 --> 27:04:17.973
we're going to have this and if
we click on this, we use this in

26045
27:04:17.973 --> 27:04:21.973
our browser, it returns this
dog. So now we have the image

26046
27:04:21.973 --> 27:04:25.973
URI in our website, we can
finally use it to show what this

26047
27:04:25.973 --> 27:04:29.973
is going to look like. So
finally, we can create a return

26048
27:04:29.973 --> 27:04:33.973
in here. So down below, we'll do
return to a little div. And then

26049
27:04:33.973 --> 27:04:36.973
we'll do another div just
because I want to. And we can do

26050
27:04:36.973 --> 27:04:39.973
some JavaScript, we can say if
if that image array exists,

26051
27:04:39.973 --> 27:04:43.973
we'll do some stuff. Otherwise,
we'll do some other stuff. So if

26052
27:04:43.973 --> 27:04:47.973
it doesn't exist, maybe we'll do
a div for now. div that just

26053
27:04:47.973 --> 27:04:52.973
says loading dot the dot. And if
it does exist, for now, we'll

26054
27:04:52.973 --> 27:04:57.973
just say, just do a little div,
close the div. And we'll just

26055
27:04:57.973 --> 27:05:01.974
say found it. Now if we go back
to our front end, let's see if

26056
27:05:01.974 --> 27:05:03.974
we're good here.

26057
27:05:03.974 --> 27:05:07.974
Uh huh. If I do a refresh, we
see found it for both of these

26058
27:05:07.974 --> 27:05:12.974
NF T's. Okay, cool. So how do we
actually show these NF T's, we

26059
27:05:12.974 --> 27:05:15.974
finally have the URL that we can
use to show the NF T's. But we

26060
27:05:15.974 --> 27:05:18.974
want to actually use them next.
Jas actually comes with a

26061
27:05:18.974 --> 27:05:21.974
component called the image
component that we can use to

26062
27:05:21.974 --> 27:05:26.974
render images really easily just
by using a URI. Now, because

26063
27:05:26.974 --> 27:05:28.974
we're going to use this image
tag, and because it does some

26064
27:05:28.974 --> 27:05:31.974
optimizations on the back end,
that means that this website

26065
27:05:31.974 --> 27:05:36.974
won't be able to be deployed to
a static to a static site, like

26066
27:05:36.974 --> 27:05:40.974
IPFS. Because now our website
requires a server technically,

26067
27:05:40.974 --> 27:05:43.974
requires a server just because
we have Morales. So that might

26068
27:05:43.974 --> 27:05:45.974
be another reason, we might not
want to, since we're using this

26069
27:05:46.974 --> 27:05:49.974
image tag, we can't deploy this
statically to something like

26070
27:05:49.974 --> 27:05:54.974
IPFS is we're going to up at the
top, we're going to import image

26071
27:05:54.974 --> 27:05:59.974
from next slash image. And we're
gonna down here we're going to

26072
27:05:59.974 --> 27:06:04.974
say, instead of founded, we're
gonna go Image, we're gonna

26073
27:06:04.974 --> 27:06:08.974
close it off here, too, we're
gonna give a loader of just a

26074
27:06:08.974 --> 27:06:12.974
blank function that just gives
us the image URI. Don't worry

26075
27:06:12.974 --> 27:06:15.974
too much about loader. For now,
we're gonna say the source of

26076
27:06:15.974 --> 27:06:18.974
the image is going to be the
image URI. And then we'll give

26077
27:06:18.974 --> 27:06:23.974
it a height of maybe 200. And
then we'll give it a width of

26078
27:06:23.974 --> 27:06:27.974
also maybe 200. And if we did
this right, after we save, we

26079
27:06:27.974 --> 27:06:30.974
should see the image on our UI.
So we'll go back to our website,

26080
27:06:30.974 --> 27:06:35.974
and oh, my goodness, we can see
the dogs holy cow. This is

26081
27:06:35.974 --> 27:06:37.975
getting really exciting. We can
see the puppies, we can see the

26082
27:06:37.975 --> 27:06:40.975
images, we're definitely doing
something right here, which is

26083
27:06:40.975 --> 27:06:43.975
really exciting. Now I know I
said this before that this isn't

26084
27:06:43.975 --> 27:06:47.975
a CSS. This isn't a formatting
tutorial, because that's

26085
27:06:47.975 --> 27:06:50.975
definitely not my expertise.
However, let's make this look a

26086
27:06:50.975 --> 27:06:53.975
little bit nicer. And we're
going to use once again, the web

26087
27:06:53.975 --> 27:06:56.975
three UI kit, because the web
three UI kit has a whole bunch

26088
27:06:56.975 --> 27:06:59.975
of tools that are really, really
helpful for us to use. So if we

26089
27:06:59.975 --> 27:07:03.975
go to the web three UI kit, we
can go to that live storybook

26090
27:07:03.975 --> 27:07:07.975
Another interactive bit, and we
can scroll down to the section

26091
27:07:07.975 --> 27:07:10.975
that has called card. Or we can
make these little clickable

26092
27:07:10.975 --> 27:07:14.975
cards and we can display some
information about our nfts. So

26093
27:07:14.975 --> 27:07:20.975
let's go ahead and at the top,
we'll do import import card from

26094
27:07:20.975 --> 27:07:24.975
web three UI kit. And now
instead of just showing the

26095
27:07:24.975 --> 27:07:29.975
image, we'll wrap the image in a
card like this. We'll save that.

26096
27:07:29.975 --> 27:07:34.975
Now back on our front end, give
it a little refresh. Now we've

26097
27:07:34.975 --> 27:07:37.975
got this kind of clickable
section that looks a little bit

26098
27:07:37.975 --> 27:07:40.975
nicer. We'll even label it. And
we can even label it with a

26099
27:07:40.975 --> 27:07:43.975
title and description. Now we
can grab the title and the

26100
27:07:43.975 --> 27:07:48.975
description from the token URI
response. So up at the top,

26101
27:07:48.975 --> 27:07:51.975
let's go ahead, let's grab the
title and the description of the

26102
27:07:51.975 --> 27:07:56.975
token UI as a state variable. So
we'll say const, token name, set

26103
27:07:56.975 --> 27:08:02.975
token name, equals use state,
start off as blank, the const

26104
27:08:02.975 --> 27:08:10.975
token description, that token
description, equals use state.

26105
27:08:10.975 --> 27:08:14.975
Start off as blank to download,
we do this update UI bit, we'll

26106
27:08:14.975 --> 27:08:21.976
call set token name. So we'll
say name is token, your response

26107
27:08:21.976 --> 27:08:26.976
dot name, we'll say set token
description, which will be

26108
27:08:26.976 --> 27:08:30.976
token, your response dot
description. And then we'll use

26109
27:08:30.976 --> 27:08:34.976
those descriptions and title in
the cart. So we'll say title

26110
27:08:34.976 --> 27:08:43.976
equals token name, description
equals token description. Save

26111
27:08:43.976 --> 27:08:46.976
that. We'll look at our front
end here. Give it a little

26112
27:08:46.976 --> 27:08:50.976
refresh. Oh, and now we have the
name of the NFT. And its

26113
27:08:50.976 --> 27:08:52.976
description on our front end.
Okay, cool. Let's keep going.

26114
27:08:52.976 --> 27:08:55.976
What else do we want on this?
Well, we probably want who it's

26115
27:08:55.976 --> 27:08:59.976
owned by. So we'll put a little
div inside the card, say div,

26116
27:08:59.976 --> 27:09:02.976
maybe we'll even put the token
ID we'll do a little number.

26117
27:09:02.976 --> 27:09:05.976
With the token ID.

26118
27:09:05.976 --> 27:09:08.976
We'll do another little div, and
then we'll make this italic.

26119
27:09:08.976 --> 27:09:12.976
We'll say class name equals
italic. And then text is going

26120
27:09:13.976 --> 27:09:17.976
to be small. And we'll say owned
by, and this is where we can get

26121
27:09:17.976 --> 27:09:20.976
the seller that we're passing in
as an input parameter. And then

26122
27:09:20.976 --> 27:09:23.976
maybe underneath the image, we
want to put the price. We'll do

26123
27:09:23.976 --> 27:09:27.976
a little div here. And then
we'll say price like this.

26124
27:09:27.976 --> 27:09:30.976
However, we're probably don't
want it in way we want it in

26125
27:09:30.976 --> 27:09:35.976
human readable units. So we'll
import ethers, we'll say import

26126
27:09:35.976 --> 27:09:40.976
ethers from ethers. And then
instead of just showing the

26127
27:09:40.976 --> 27:09:44.976
price, we'll do a little, little
JavaScript and here we'll do

26128
27:09:44.976 --> 27:09:50.976
ethers dot utils dot format,
units, price, price and ether.

26129
27:09:50.976 --> 27:09:53.976
And then we'll do space eath.
And then we'll make this be

26130
27:09:53.976 --> 27:09:59.977
class name equals font bold, so
we can read how much it's listed

26131
27:09:59.977 --> 27:10:03.977
for on our marketplace. Let's go
back a high we can now see, this

26132
27:10:03.977 --> 27:10:07.977
is token ID number four. We can
see who it's owned by we'd see

26133
27:10:07.977 --> 27:10:10.977
the price of it and then more
information about the dog. Yay.

26134
27:10:10.977 --> 27:10:13.977
Now let's format all this stuff
in here a little bit nicer. So

26135
27:10:13.977 --> 27:10:17.977
let's wrap everything in a div
in one more div. And that will

26136
27:10:17.977 --> 27:10:20.977
say class name is going to be
flex. And this is going to help

26137
27:10:20.977 --> 27:10:25.977
format everything, we'll put
everything in a column items and

26138
27:10:25.977 --> 27:10:28.977
get to. And now if we look back
there, kind of like in a column

26139
27:10:28.977 --> 27:10:33.977
now, wrapping one more div, give
them some padding, last name

26140
27:10:33.977 --> 27:10:36.977
equals P to say a little bit
padding has been added. Okay,

26141
27:10:36.977 --> 27:10:40.977
nice. And then we'll go back to
our index, and we'll add some

26142
27:10:40.977 --> 27:10:44.977
formatting to our index here. So
our main one, we're going to

26143
27:10:44.977 --> 27:10:48.977
remove styles dot container,
we're just gonna say container.

26144
27:10:48.977 --> 27:10:55.977
MX auto, we're going to make an
h1 in here, class name, equals,

26145
27:10:55.977 --> 27:11:07.977
I form E X for font bold text to
XML. This is we're just gonna

26146
27:11:07.977 --> 27:11:13.977
say recently listed, then we're
going to do another div. Class,

26147
27:11:13.977 --> 27:11:20.977
name equals flex, flex wrap.
We're going to end this div

26148
27:11:20.977 --> 27:11:23.977
around our JavaScript here. And
let's look at our UI. And let's

26149
27:11:23.977 --> 27:11:26.977
see what that does. Okay, cool.
Let's go back to our index.

26150
27:11:26.977 --> 27:11:28.977
Let's remove all this stuff.
Since now we're adding that to

26151
27:11:28.977 --> 27:11:34.977
the card. Let's save. Now it's
looking a lot better, we finally

26152
27:11:34.977 --> 27:11:37.977
able to start listening our NF
Ts and then have them show up on

26153
27:11:37.977 --> 27:11:41.978
our marketplace like we see
here. Fantastic. Okay, if we go

26154
27:11:41.978 --> 27:11:44.978
to the readme homepage show
recently listen to empties. Oh,

26155
27:11:44.978 --> 27:11:48.978
my goodness, this is a check
we're done here. Now, and I know

26156
27:11:48.978 --> 27:11:50.978
what seemed like a lot of work,
but a lot of it was setting up

26157
27:11:50.978 --> 27:11:53.978
that morale server correctly.
And because we have our own back

26158
27:11:53.978 --> 27:11:56.978
end, now, we have some back end
services that we needed to

26159
27:11:56.978 --> 27:11:58.978
configure. But now that
everything's set up, the rest of

26160
27:11:58.978 --> 27:12:02.978
this is going to be easy St. Now
we are only going to want this

26161
27:12:02.978 --> 27:12:05.978
to show if we're connected to
web three. Right? Now, if we

26162
27:12:05.978 --> 27:12:09.978
click this, this still shows up.
So we're going to have to update

26163
27:12:09.978 --> 27:12:14.978
this a little bit. And in our
index.js, we're now we're

26164
27:12:14.978 --> 27:12:18.978
checking to see fetching.
Listen, NF T's right before

26165
27:12:18.978 --> 27:12:22.978
that, right? Before we do that
we actually want to see is web

26166
27:12:22.978 --> 27:12:25.978
three enabled. And this is going
to be a little bit of nested

26167
27:12:25.978 --> 27:12:28.978
tertiary operations. If web
three is enabled, then we're

26168
27:12:28.978 --> 27:12:31.978
going to do all this fetching,
listed NF T's stuff here. We're

26169
27:12:31.978 --> 27:12:35.978
gonna do everything in here. So
if it's not enabled, let's do

26170
27:12:35.978 --> 27:12:42.978
like a little div that says web
three, currently not enabled.

26171
27:12:42.978 --> 27:12:45.978
And of course, we're going to
need to grab is web three

26172
27:12:45.978 --> 27:12:49.978
enabled. So we're going to say,
for the top we'll do const is

26173
27:12:49.978 --> 27:12:53.978
what three enabled equals use
oralis as we've been doing, and

26174
27:12:53.978 --> 27:12:56.978
we're going to grab use Morales
from react Morales, we'll save

26175
27:12:56.978 --> 27:12:59.978
that go back to our front end,
give it a little refresh. If

26176
27:12:59.978 --> 27:13:02.978
we're connected, we'll see the
marketplace. If we disconnect,

26177
27:13:02.978 --> 27:13:06.978
we see web three currently not
enabled, which is what we want.

26178
27:13:06.978 --> 27:13:10.978
Perfect. So what is next in our
readme. If you only NFT, you can

26179
27:13:10.978 --> 27:13:13.978
update the listing. Let's first
let's figure out if somebody

26180
27:13:13.978 --> 27:13:16.978
actually is the owner of these
entities. Let's make it really

26181
27:13:16.978 --> 27:13:19.979
easy for the people on this
website. Well, first we can get

26182
27:13:19.979 --> 27:13:23.979
the person's Metamask by
grabbing the account from us

26183
27:13:23.979 --> 27:13:27.979
mouse, so we'll do a comma
account. So then we can easily

26184
27:13:27.979 --> 27:13:34.979
just do const is owned by user
equals seller equals equals

26185
27:13:34.979 --> 27:13:38.979
equals account. So the seller
we're getting from the contract,

26186
27:13:38.979 --> 27:13:41.979
the account we're getting from
whoever's connected here, if the

26187
27:13:41.979 --> 27:13:45.979
seller equals the account, there
is no seller equals equals

26188
27:13:45.979 --> 27:13:50.979
equals undefined. We'll just say
they're owned by you. And now

26189
27:13:50.979 --> 27:13:54.979
instead of saying owned by
seller, we can say const,

26190
27:13:54.979 --> 27:13:59.979
formatted seller address equals,
and we'll do the ternary

26191
27:13:59.979 --> 27:14:04.979
operator will say if it's on by
you, then we'll just say you

26192
27:14:04.979 --> 27:14:08.979
instead of seller. Otherwise,
we'll say seller. Now we'll say

26193
27:14:08.979 --> 27:14:11.979
owned by formatted seller
address like this. So if we go

26194
27:14:11.979 --> 27:14:16.979
back to our front end, we do a
little refresh. depending on

26195
27:14:16.979 --> 27:14:19.979
who's connected, you might see
owned by blah, blah, blah. Now

26196
27:14:19.979 --> 27:14:22.979
if I go to my Metamask, let me
go ahead and switch account to

26197
27:14:22.979 --> 27:14:27.979
account three, let's go ahead
and connect our account three,

26198
27:14:27.979 --> 27:14:31.979
we now see owned by you instead.
Right, and we can even switch

26199
27:14:31.979 --> 27:14:35.979
again, we'll switch accounts
again, we'll switch to account

26200
27:14:35.979 --> 27:14:38.979
one, we now see owned by blah,
blah, blah, like so since when

26201
27:14:38.979 --> 27:14:41.979
we switch back and forth, the
diameters of this actually

26202
27:14:41.979 --> 27:14:44.979
change which is really annoying.
So maybe we want to go one step

26203
27:14:44.979 --> 27:14:47.979
further. And we want to truncate
this seller address make it a

26204
27:14:47.979 --> 27:14:51.979
little bit smaller. So we want
to make a seller a little bit

26205
27:14:51.979 --> 27:14:54.979
smaller. So let's create a new
function. And we can create this

26206
27:14:54.979 --> 27:14:57.979
outside of the export default
function because this is going

26207
27:14:57.979 --> 27:15:02.980
to be a function that doesn't
depend on anything inside our

26208
27:15:02.980 --> 27:15:04.980
app. It's just going to be kind
of a raw function. So we're

26209
27:15:04.980 --> 27:15:08.980
going to create we'll call it
const truncate string, and this

26210
27:15:08.980 --> 27:15:13.980
is going to be a function that
takes a full string, and a

26211
27:15:13.980 --> 27:15:17.980
string length as parameters. And
we're just going to pass the

26212
27:15:17.980 --> 27:15:20.980
seller address and how long we
want to make this string. So

26213
27:15:20.980 --> 27:15:22.980
this is going to be an arrow
function we're going to do here,

26214
27:15:22.980 --> 27:15:27.980
and we're gonna say, if all
string dot length is less than

26215
27:15:27.980 --> 27:15:32.980
or equal to str Lang, return
full str. Otherwise, we'll say

26216
27:15:32.980 --> 27:15:38.980
concept ra torx equals three
little dots. And we'll say,

26217
27:15:38.980 --> 27:15:46.980
Let's separate Tor length equals
Sep. Ra Tor dot length. To make

26218
27:15:46.980 --> 27:15:52.980
con separator length, we'll say
const chars to show is going to

26219
27:15:52.980 --> 27:15:58.980
be the the string length minus
the separator length, we'll say

26220
27:15:58.980 --> 27:16:03.980
const. Front chars or front
characters is going to equal

26221
27:16:03.980 --> 27:16:10.980
math dot ceiling chars to show
divided by two const back chars

26222
27:16:10.980 --> 27:16:15.980
is going to equal math dot
floor, chars to show divided by

26223
27:16:15.980 --> 27:16:18.980
two. And if you don't understand
this math here, don't worry

26224
27:16:18.980 --> 27:16:22.980
about it. And then we're gonna
say return full string

26225
27:16:22.980 --> 27:16:31.980
substring of zero to front chars
plus the SEP IRA tour plus full

26226
27:16:31.980 --> 27:16:38.981
STR dot substring. of full STR
dot length, minus back chars.

26227
27:16:38.981 --> 27:16:41.981
And now what we can do is we can
grab this truncate STR this

26228
27:16:41.981 --> 27:16:45.981
truncate string and for is
formatted seller will say if

26229
27:16:45.981 --> 27:16:49.981
it's you will still do you but
otherwise we'll do truncate

26230
27:16:49.981 --> 27:16:54.981
string of seller or blank if
there's no seller, and we'll

26231
27:16:54.981 --> 27:16:57.981
have it be size 15. And now if
we save that, go back to our

26232
27:16:57.981 --> 27:17:01.981
front end, if it's owned by you,
it's still gonna say on by you.

26233
27:17:01.981 --> 27:17:05.981
But if we switch accounts, and
now says owned by, you know,

26234
27:17:05.981 --> 27:17:07.981
blah, blah, blah, dot the dot
blah, blah, blah with a

26235
27:17:07.981 --> 27:17:10.981
truncated address. And then
these sizes don't actually

26236
27:17:10.981 --> 27:17:13.981
change, which is a lot nicer
than them getting bigger and

26237
27:17:13.981 --> 27:17:17.981
smaller. So awesome. So now we
have this formatted even better.

26238
27:17:17.981 --> 27:17:23.981
Okay, now what do we want to do?
Well, now that we know who owns

26239
27:17:23.981 --> 27:17:27.981
the NFT, NF T, and it's
formatted pretty nicely, we need

26240
27:17:27.981 --> 27:17:30.981
to figure out a way to update
the listing. So what we want to

26241
27:17:30.981 --> 27:17:34.981
do is, once again, if it's owned
by us, and we can switch back to

26242
27:17:34.981 --> 27:17:37.981
the account, it's owned by if
it's owned by us, when we click

26243
27:17:37.981 --> 27:17:40.981
on it, we want to be able to
update the listing on the

26244
27:17:40.981 --> 27:17:43.981
marketplace. So to do this,
we're going to create a new

26245
27:17:43.981 --> 27:17:48.981
component called Update listing
ngModel. So we're gonna create a

26246
27:17:48.981 --> 27:17:56.981
new component, new file, update,
listing ngmodel.js. A ngModel is

26247
27:17:56.981 --> 27:17:59.981
something that like pops up. So
for example,

26248
27:18:00.981 --> 27:18:03.981
this little pop up here is known
as a modal. And this is what we

26249
27:18:03.981 --> 27:18:06.981
want to build. If it's owned by
us, when we click this, we want

26250
27:18:06.981 --> 27:18:09.981
it to pop up this modal thing.
So to get started, we'll do the

26251
27:18:09.981 --> 27:18:12.981
same thing we've been doing for
all of our components here,

26252
27:18:12.981 --> 27:18:18.981
we'll do export default,
function, update, listing

26253
27:18:18.981 --> 27:18:22.982
ngModel, like so. And we're
probably going to want to pass

26254
27:18:22.982 --> 27:18:25.982
it these parameters from the
entity box, probably gonna want

26255
27:18:25.982 --> 27:18:29.982
to pass these parameters. So the
ngModel knows what function it

26256
27:18:29.982 --> 27:18:32.982
needs to call in our NFT
marketplace. The way we're going

26257
27:18:32.982 --> 27:18:35.982
to update listing is we're going
to call this update listing

26258
27:18:35.982 --> 27:18:38.982
function where we need the
address token ID and then some

26259
27:18:38.982 --> 27:18:41.982
new price. So we're going to at
least need those. So we're going

26260
27:18:41.982 --> 27:18:46.982
to need the NFT address, and at
least the token ID to make this

26261
27:18:46.982 --> 27:18:48.982
little pop up, we're not going
to code it ourselves, we're

26262
27:18:48.982 --> 27:18:51.982
going to once again, use the web
three UI kit, web three UI Kit

26263
27:18:51.982 --> 27:18:55.982
has this nice pop up section,
where it has some code to work

26264
27:18:55.982 --> 27:18:59.982
with a modal. So we're going to
import that will do import

26265
27:18:59.982 --> 27:19:04.982
ngModel from web three UI kit,
like so here's what it looks

26266
27:19:04.982 --> 27:19:08.982
like we have modal and then we
have all this stuff on working

26267
27:19:08.982 --> 27:19:12.982
with the modal. So we'll do our
return, do a little modal, like

26268
27:19:12.982 --> 27:19:15.982
this. One of the key things in a
ngModel is whether or not it

26269
27:19:15.982 --> 27:19:19.982
should be visible. So it has an
is visible tag, which we're

26270
27:19:19.982 --> 27:19:22.982
actually gonna have to grab,
we're actually gonna have to

26271
27:19:22.982 --> 27:19:25.982
grab from the empty box. So
we're going to pass a little is

26272
27:19:25.982 --> 27:19:30.982
visible here as well, in our NFT
box, we need to tell our ngModel

26273
27:19:30.982 --> 27:19:32.982
when it's visible. So we'll
we'll make that code in a little

26274
27:19:33.982 --> 27:19:35.982
bit. Right now, it'll just be
blank. And inside of our

26275
27:19:35.982 --> 27:19:38.982
ngModel, we're going to want to
give an input field for how to

26276
27:19:38.982 --> 27:19:41.982
update it. So I know we've done
some regular inputs before,

26277
27:19:41.982 --> 27:19:44.982
since we've been working with
web through UI kit, let's just

26278
27:19:44.982 --> 27:19:47.982
use the input that it has as
well. So we'll do a little comma

26279
27:19:47.982 --> 27:19:51.982
input here. And inside of the
ngModel we'll create a new

26280
27:19:51.982 --> 27:19:55.982
input. So on our input field,
we'll give this a label which is

26281
27:19:55.982 --> 27:19:59.983
going to be update listing price
in L one currency. And we'll

26282
27:19:59.983 --> 27:20:03.983
just do eath. For now we'll just
hard coded as eath name will be

26283
27:20:03.983 --> 27:20:10.983
new listing price, and type is
going to equal a number we'll do

26284
27:20:10.983 --> 27:20:13.983
Little backslash here, oops,
we'll do a little backslash

26285
27:20:13.983 --> 27:20:16.983
instead of like that. So cool.
So when this modal pops up, it's

26286
27:20:16.983 --> 27:20:19.983
gonna have this input in here.
And we can actually test to see

26287
27:20:19.983 --> 27:20:24.983
if this is working. We can
import this into our NFT box,

26288
27:20:24.983 --> 27:20:30.983
we'll do import, update, listing
ngModel. From that slash,

26289
27:20:30.983 --> 27:20:32.983
update, listing ngModel oops,
and sorry, this doesn't need

26290
27:20:32.983 --> 27:20:36.983
parentheses, and at the top of
our return here, right before

26291
27:20:36.983 --> 27:20:39.983
our card will add it in. So
we'll just add another div

26292
27:20:39.983 --> 27:20:43.983
though. So that these two can be
in the same react. But we'll add

26293
27:20:43.983 --> 27:20:47.983
another div, we'll say Update
listing ngModel, like so with a

26294
27:20:47.983 --> 27:20:51.983
little backslash here. And right
now we just have to pass is

26295
27:20:51.983 --> 27:20:55.983
visible. And then for now, we're
just going to say true. So now

26296
27:20:55.983 --> 27:20:58.983
with this listing ngModel on our
front end, we do a little

26297
27:20:58.983 --> 27:21:01.983
refresh. And we get this little
box like this update listing

26298
27:21:01.983 --> 27:21:04.983
price and one currency. And we
have to close two of them.

26299
27:21:04.983 --> 27:21:08.983
Because technically we right now
both modalities are true, right.

26300
27:21:08.983 --> 27:21:11.983
So if we do a refresh, we get
this little input pop up this

26301
27:21:11.983 --> 27:21:14.983
little modal and we close it
twice, because we have two NF

26302
27:21:14.983 --> 27:21:17.983
T's if you have a ton of NF T's
here, you will have to close a

26303
27:21:17.983 --> 27:21:20.983
ton of those. So we change it to
false, we go back to the front

26304
27:21:20.983 --> 27:21:25.983
end, we do a little refresh, and
boom, now it's false. So true,

26305
27:21:25.983 --> 27:21:31.983
save, run, and it's there.
Gross, delete, delete, false,

26306
27:21:31.983 --> 27:21:34.983
save front end, it's not there
anymore. Okay, cool. So we're

26307
27:21:34.983 --> 27:21:38.983
gonna have to tell this ngModel
only to pop up when somebody

26308
27:21:38.983 --> 27:21:41.984
clicks this and have tea that
they own. So to actually toggle

26309
27:21:41.984 --> 27:21:44.984
this and actually make this
work, we're going to update our

26310
27:21:44.984 --> 27:21:48.984
card. So whenever we click our
card, we're going to create a

26311
27:21:48.984 --> 27:21:51.984
function called handle card
click that handle card click is

26312
27:21:51.984 --> 27:21:54.984
going to update a variable for
whether or not we should show

26313
27:21:54.984 --> 27:21:59.984
this ngModel. So we're going to
do is we're gonna say on click

26314
27:21:59.984 --> 27:22:03.984
of the card, aka, once we click
our dog, we're going to call

26315
27:22:03.984 --> 27:22:07.984
some function. So we're gonna
say on click, equals handle

26316
27:22:07.984 --> 27:22:11.984
card, click, animal card, click,
and we're going to make this a

26317
27:22:11.984 --> 27:22:15.984
function, we're gonna say const,
handle card click equals a

26318
27:22:15.984 --> 27:22:19.984
function, we'll use some Arrow
stuff here. And then we'll just

26319
27:22:19.984 --> 27:22:25.984
say, if it's is owned by user,
if it's on by user, we'll show

26320
27:22:25.984 --> 27:22:30.984
the ngModel. Else, we will call
the by item function, since we

26321
27:22:30.984 --> 27:22:35.984
want our whole UI to rerender.
Once we change, once we change

26322
27:22:35.984 --> 27:22:37.984
the variable to show the
ngModel, we're going to do this

26323
27:22:37.984 --> 27:22:43.984
as a US state. So we'll say
const, show ngModel. Come a set,

26324
27:22:43.984 --> 27:22:47.984
show ngModel equals use state.
And then we're going to start it

26325
27:22:47.984 --> 27:22:51.984
off being defaulted to false. So
by default, we are not going to

26326
27:22:51.984 --> 27:22:53.984
show them on down which is what
we want. But if it's owned by

26327
27:22:53.984 --> 27:22:59.984
the user, we're gonna say Set
Show ngModel to be true. And

26328
27:22:59.984 --> 27:23:04.984
then else right now we'll just
put console dot log, let's buy

26329
27:23:04.984 --> 27:23:06.984
will actually update this to
bind the item a little bit

26330
27:23:06.984 --> 27:23:10.984
later. So now instead of having
is visible be false, we'll have

26331
27:23:10.984 --> 27:23:13.984
is visible equal to show
ngModel. Or show ngModel.

26332
27:23:13.984 --> 27:23:16.984
Variable. Okay, great. So now if
we save that, we go back to our

26333
27:23:16.984 --> 27:23:21.985
UI, we right click, we hit
Inspect, if we own it, and we

26334
27:23:21.985 --> 27:23:24.985
click it, the ngModel will pop
up, and we can click it out,

26335
27:23:24.985 --> 27:23:28.985
click another one, but that will
pop up if we don't own it. So if

26336
27:23:28.985 --> 27:23:32.985
we switch accounts, Connect will
switch. We click it, nothing

26337
27:23:32.985 --> 27:23:36.985
happens. And if we go to
inspect, we go to the console,

26338
27:23:36.985 --> 27:23:40.985
we click it, we should see let's
buy pop up, which is what we do

26339
27:23:40.985 --> 27:23:44.985
see, we'll do a little refresh
here. Click we see let's buy pop

26340
27:23:44.985 --> 27:23:48.985
up, click again, let's buy click
let's pilots pilots, why? Great,

26341
27:23:48.985 --> 27:23:51.985
cool. So now we have a word for
that ngModel. To actually show

26342
27:23:51.985 --> 27:23:54.985
up correctly, let's switch back
to the person who actually owns

26343
27:23:54.985 --> 27:23:58.985
this NFT we click it, we want to
be able to when we hit OK, or

26344
27:23:58.985 --> 27:24:02.985
submit, we want to send a
transaction to update the price

26345
27:24:02.985 --> 27:24:05.985
of our NFT here, so what we can
do is in our input will have a

26346
27:24:05.985 --> 27:24:09.985
label called on change equals
and this is the function that

26347
27:24:09.985 --> 27:24:12.985
will call whenever this updates.
So we're gonna say on change

26348
27:24:12.985 --> 27:24:17.985
event is going to be a function.
And we're going to create a

26349
27:24:17.985 --> 27:24:22.985
function called set price to
update listing listing with

26350
27:24:22.985 --> 27:24:27.985
event dot target dot value. So
we want to keep track of

26351
27:24:27.985 --> 27:24:30.985
whatever we've put in here. So
when we call the function to

26352
27:24:30.985 --> 27:24:32.985
update the price, it'll just
already automatically have it.

26353
27:24:32.985 --> 27:24:36.985
So we'll create this function
and event dot target dot value

26354
27:24:36.985 --> 27:24:39.985
is going to be whatever's in
this input box here. So we'll

26355
27:24:39.985 --> 27:24:43.985
create this set price to update
listing with will have this be a

26356
27:24:43.985 --> 27:24:46.985
use date because we are going to
want to change the UI based off

26357
27:24:46.985 --> 27:24:52.985
this so we'll say const price to
up date listing with comma set

26358
27:24:52.985 --> 27:24:58.985
price to update listing with
equals use state and then we'll

26359
27:24:58.985 --> 27:25:03.986
have this be zero to start or
blank. And so now, whatever is

26360
27:25:03.986 --> 27:25:06.986
in here is going to get updated
with this. So now I can do like

26361
27:25:06.986 --> 27:25:11.986
our console dot log price update
listing with Get back to the

26362
27:25:11.986 --> 27:25:16.986
front end, oops, we need to
import use state import, use

26363
27:25:16.986 --> 27:25:21.986
state from react. Go back to the
front end, we click this, we

26364
27:25:21.986 --> 27:25:23.986
right click Inspect.

26365
27:25:23.986 --> 27:25:27.986
By type one, we can see 114, we
see 14. So let's remove the

26366
27:25:27.986 --> 27:25:31.986
console dot log now. Now what we
can do in here is we can create

26367
27:25:31.986 --> 27:25:34.986
field called on okay, this is
going to be the function that we

26368
27:25:34.986 --> 27:25:37.986
call when we hit this, okay
here, so on. Okay, it's going to

26369
27:25:37.986 --> 27:25:40.986
be equal to a function, we're
going to use a little arrow

26370
27:25:40.986 --> 27:25:44.986
notation, and we're going to
call that update listing

26371
27:25:44.986 --> 27:25:47.986
function on the blockchain,
we're going to need to grab that

26372
27:25:47.986 --> 27:25:50.986
function so we can use it. So
once again, to use that

26373
27:25:50.986 --> 27:25:55.986
function, we're going to import
use web three contract from

26374
27:25:55.986 --> 27:26:00.986
react mirallas. And as a new
hook, we'll say const run

26375
27:26:00.986 --> 27:26:06.986
contract function called Update
listing, equals use web three

26376
27:26:06.986 --> 27:26:09.986
contract. And this is going to
be a function that we're going

26377
27:26:09.986 --> 27:26:15.986
to call on our NFT marketplace.
So ABI is going to be the NFT

26378
27:26:15.986 --> 27:26:20.986
marketplace API, which we can
get by doing an import, similar

26379
27:26:20.986 --> 27:26:24.986
to what we did over here. And we
actually just copy paste from

26380
27:26:24.986 --> 27:26:30.986
our NFT box. So we'll do import
NFT marketplace API from dot dot

26381
27:26:30.986 --> 27:26:33.986
constant send it to marketplace
that JSON, we're gonna need the

26382
27:26:33.986 --> 27:26:38.986
contract address, which is going
to be an input parameter to our

26383
27:26:38.986 --> 27:26:43.987
update listing ngModel. So we
can even do a comma market place

26384
27:26:43.987 --> 27:26:48.987
address, copy this place that
here, that means in our NFT box,

26385
27:26:48.987 --> 27:26:51.987
pretty soon, we're going to have
to pass all these variables to

26386
27:26:51.987 --> 27:26:54.987
it, but we'll save that in just
a second. So NFT marketplace

26387
27:26:54.987 --> 27:26:57.987
address marketplace address
function name, is going to be

26388
27:26:57.987 --> 27:27:02.987
what it's called Update, listing
in our smart contract, and then

26389
27:27:02.987 --> 27:27:06.987
the params. So if we go to this,
we have update listing takes the

26390
27:27:06.987 --> 27:27:11.987
NFT address token ID and new
price do NFT address, which will

26391
27:27:11.987 --> 27:27:16.987
be NFT address, we'll say token
ID is going to be token ID and

26392
27:27:16.987 --> 27:27:20.987
the new price your price will
get from price to update listing

26393
27:27:20.987 --> 27:27:25.987
with but will convert it from
human readable to ethers. So

26394
27:27:25.987 --> 27:27:33.987
we'll import ethers from ethers.
And the new price will be ethers

26395
27:27:33.987 --> 27:27:39.987
dot utils dot parse ethers or
ether price to update listing

26396
27:27:39.987 --> 27:27:44.987
with or just in case it's blank,
we'll just say or zero. So we

26397
27:27:44.987 --> 27:27:48.987
have the NFT address the token
ID marketplace address in our

26398
27:27:48.987 --> 27:27:51.987
NFT box, we're gonna have to
pass those parameters in here.

26399
27:27:51.987 --> 27:27:54.987
So we have is visible, we're
also going to have token ID,

26400
27:27:54.987 --> 27:27:59.987
which is going to equal token
ID, marketplace address is going

26401
27:27:59.987 --> 27:28:05.987
to equal the marketplace
address. And the NFT address is

26402
27:28:05.987 --> 27:28:10.987
going to equal the NFT address.
And as we code and test this

26403
27:28:10.987 --> 27:28:12.987
something that's going to be
really annoying, because it's

26404
27:28:12.987 --> 27:28:15.987
really annoying for me right now
let's refresh our website. And

26405
27:28:15.987 --> 27:28:18.987
if we click it, this thing pops
up. But when I hit X, and I

26406
27:28:18.987 --> 27:28:22.988
click this, again, nothing shows
up. That's because technically

26407
27:28:22.988 --> 27:28:25.988
show ngModel is still true right
now, even though we've exited

26408
27:28:25.988 --> 27:28:30.988
out. So what we want to do in
the NFT box is in our update

26409
27:28:30.988 --> 27:28:33.988
listing ngModel we're also going
to pass it in on close, and

26410
27:28:33.988 --> 27:28:37.988
we're going to pass it a hide
ngModel variable that we're

26411
27:28:37.988 --> 27:28:41.988
going to create, and right under
Show ngModel Set Show ngModel

26412
27:28:41.988 --> 27:28:46.988
we're going to create const Eid
ngModel. And this is just going

26413
27:28:46.988 --> 27:28:51.988
to be a function, that's just
going to say set, show modal. to

26414
27:28:51.988 --> 27:28:56.988
false, we're going to pass this
function to our update modal

26415
27:28:56.988 --> 27:29:01.988
listing. So we're going to do
comma on Close. And in our modal

26416
27:29:01.988 --> 27:29:07.988
here, we're going to say, on
Close. On, cancel, we're going

26417
27:29:07.988 --> 27:29:13.988
to do, we're going to call that
on close function, or on Close

26418
27:29:13.988 --> 27:29:17.988
button pressed, we're also going
to call that on close function.

26419
27:29:17.988 --> 27:29:22.988
Now if we refresh our website,
click this modal pops up, we

26420
27:29:22.988 --> 27:29:25.988
click X, click it again, it'll
pop back up, because now we're

26421
27:29:25.988 --> 27:29:29.988
properly setting it to false and
then resetting it to true. Now

26422
27:29:29.988 --> 27:29:32.988
to actually send this update
listing function, we're going to

26423
27:29:32.988 --> 27:29:37.988
pass this another thing, another
variable, we're going to pass it

26424
27:29:37.988 --> 27:29:40.988
on Okay, which is going to be a
function as well. It's just

26425
27:29:40.988 --> 27:29:44.988
going to call update listing
that we just created. Now, it's

26426
27:29:44.988 --> 27:29:48.988
always a good idea to add an On
error. We'd say on error, take

26427
27:29:48.988 --> 27:29:54.988
that error as a function and
console dot log.

26428
27:29:54.988 --> 27:29:58.988
The error and this needs to be
in squiggly brackets like that,

26429
27:29:58.988 --> 27:30:04.989
but contract address is wrong.
So we'll make this contract, con

26430
27:30:04.989 --> 27:30:11.989
tract address and spell that
correctly. Spelled correctly.

26431
27:30:11.989 --> 27:30:14.989
Now let's go back to the UI,
we'll give it a little refresh.

26432
27:30:14.989 --> 27:30:19.989
Click, this will add one. And we
see Metamask pop up. So this is

26433
27:30:19.989 --> 27:30:22.989
working out perfectly. Now I'm
going to cancel it, and our apps

26434
27:30:22.989 --> 27:30:24.989
gonna freak out and stuff. But
that's okay, we are doing

26435
27:30:24.989 --> 27:30:28.989
fantastically okay app popped up
like that, which is good. We

26436
27:30:28.989 --> 27:30:30.989
have this little error handling,
which I like to add for all of

26437
27:30:30.989 --> 27:30:35.989
these run contract functions.
Let's also do an on success. So

26438
27:30:35.989 --> 27:30:37.989
let's say when this does go
through successfully, we'll call

26439
27:30:37.989 --> 27:30:43.989
a function called handle update,
listing success. And this will

26440
27:30:43.989 --> 27:30:45.989
be a function that we'd call
when this goes through

26441
27:30:45.989 --> 27:30:47.989
correctly. So at the top, let's
make this new function, we'll

26442
27:30:47.989 --> 27:30:51.989
say const. Handle update,
listening success is going to be

26443
27:30:51.989 --> 27:30:55.989
a new function using the arrow
syntax here. And we'll have this

26444
27:30:55.989 --> 27:31:00.989
setup a new notification for a
web application. So for us to do

26445
27:31:00.989 --> 27:31:03.989
notifications, we're going to
use web three UI Kits use

26446
27:31:03.989 --> 27:31:06.989
notification, this is going to
be that same notification

26447
27:31:06.989 --> 27:31:10.989
service that we used in our last
one. So up at the top here,

26448
27:31:10.989 --> 27:31:14.989
we'll import it, use
notification. And then we'll

26449
27:31:14.989 --> 27:31:18.989
say, right in our component,
we'll say const, dispatch equals

26450
27:31:18.989 --> 27:31:23.989
use notification. And since
we're using notifications back

26451
27:31:23.989 --> 27:31:27.989
on our app.js, we have to import
it in here. So we'll do import

26452
27:31:27.989 --> 27:31:33.989
notification provider from web
three UI kit. And inside of our

26453
27:31:33.989 --> 27:31:37.989
Morales provider, we'll add the
notification provider around our

26454
27:31:37.989 --> 27:31:44.990
header and our component, so
that we have context for this.

26455
27:31:44.990 --> 27:31:49.990
Now in our handle update listing
success, inside this function

26456
27:31:49.990 --> 27:31:54.990
will say dispatch, say type is
going to be success. message

26457
27:31:54.990 --> 27:32:01.990
will be listing updated, title
will be listing updated, please

26458
27:32:01.990 --> 27:32:10.990
refresh, please refresh and move
blocks. And then position. Top

26459
27:32:10.990 --> 27:32:17.990
right. And then we'll do on
clothes, and on clothes. And

26460
27:32:17.990 --> 27:32:23.990
we'll say set price to update
listing with back to zero. I

26461
27:32:23.990 --> 27:32:25.990
also I'm editing this a little
bit in the future. And I

26462
27:32:25.990 --> 27:32:29.990
realized that I actually forgot
to add the TX to a lot of these

26463
27:32:29.990 --> 27:32:33.990
handle functions. So on these,
whenever we call one of these

26464
27:32:33.990 --> 27:32:36.990
run contract functions, like
we've been saying they have this

26465
27:32:36.990 --> 27:32:40.990
on error in this onsuccess. Now
this onsuccess automatically

26466
27:32:40.990 --> 27:32:45.990
passes the result of the call to
whatever callback function is

26467
27:32:45.990 --> 27:32:50.990
there. So for example, up the
listing returns a transaction,

26468
27:32:50.990 --> 27:32:54.990
and we'll pass that transaction
to whatever you add to the

26469
27:32:54.990 --> 27:32:58.990
onsuccess. So now in here, you
can actually have it have a

26470
27:32:58.990 --> 27:33:00.990
transaction as an input
parameter. And this would be the

26471
27:33:00.990 --> 27:33:03.990
transaction that's going to go
on the blockchain to you know,

26472
27:33:03.990 --> 27:33:07.990
update the price. So we actually
want to change it from a regular

26473
27:33:07.990 --> 27:33:11.990
function to an async function.
So we can actually do await TX

26474
27:33:11.990 --> 27:33:14.990
dot Wait, one, because we don't
want to say, hey, success, you

26475
27:33:14.990 --> 27:33:17.990
know, listing has been updated
before the transaction actually

26476
27:33:17.990 --> 27:33:20.991
goes through. So we want the
transaction to go through first.

26477
27:33:20.991 --> 27:33:23.991
And then we want to pop the
dispatch up saying, hey, it's

26478
27:33:23.991 --> 27:33:26.991
gone through so and then
additionally, when we actually

26479
27:33:26.991 --> 27:33:31.991
call these modells on the on,
okay, on the onsuccess, we pass

26480
27:33:31.991 --> 27:33:34.991
them in just by referencing the
name of the function. So we

26481
27:33:34.991 --> 27:33:40.991
don't do this arrow syntax,
anymore like this, we just say,

26482
27:33:40.991 --> 27:33:44.991
hey, the onsuccess is going to
be this, go ahead and pass your

26483
27:33:44.991 --> 27:33:48.991
results to it. So that's how we
actually call it down here. If

26484
27:33:48.991 --> 27:33:50.991
you look at the GitHub repo
associated with this, you go to

26485
27:33:50.991 --> 27:33:54.991
components, and we go into
these. So in this video, I

26486
27:33:54.991 --> 27:33:58.991
forgot to add the await TX dot
wait one. But in the GitHub

26487
27:33:58.991 --> 27:34:01.991
repo, we have these. And when
I'm demoing things in the video

26488
27:34:01.991 --> 27:34:05.991
here, the dispatch, it's gonna
pop up before the transaction

26489
27:34:05.991 --> 27:34:07.991
actually finishes going through.
So just want to let you know,

26490
27:34:07.991 --> 27:34:11.991
and back to the video. So now we
have a little success thing

26491
27:34:11.991 --> 27:34:14.991
that'll pop up when we're
successful. And the other thing

26492
27:34:14.991 --> 27:34:18.991
is, when we call this, we are
going to omit an item listed

26493
27:34:18.991 --> 27:34:23.991
inside of our Morales dashboard,
the price should actually update

26494
27:34:23.991 --> 27:34:27.991
in our active item because of
our Cloud Functions. So we're

26495
27:34:27.991 --> 27:34:31.991
going to put this all together
now. So we're on the front end.

26496
27:34:31.991 --> 27:34:35.991
And if the marketplace owned by
you will click it. Update

26497
27:34:35.991 --> 27:34:41.991
listing to 25. We're gonna hit
OK, meta masks is gonna pop up.

26498
27:34:41.991 --> 27:34:46.991
We're gonna go ahead and confirm
and ran through an error because

26499
27:34:46.991 --> 27:34:49.991
we need to click Metamask I need
to reset my account. So I'm

26500
27:34:49.991 --> 27:34:54.991
going to do settings, advanced
reset account.

26501
27:34:54.991 --> 27:34:58.991
Okay, now let's go ahead
Metamask has popped up again,

26502
27:34:58.991 --> 27:35:03.992
we're gonna go ahead and confirm
it closed, the pop up modal, and

26503
27:35:03.992 --> 27:35:06.992
we got our little notification
there. And we can see an

26504
27:35:06.992 --> 27:35:11.992
activity we have that
transaction has indeed completed

26505
27:35:11.992 --> 27:35:14.992
So now if we go to active item,
we give it a little refresh.

26506
27:35:14.992 --> 27:35:19.992
Right now we see our item listed
event. But the issue is that

26507
27:35:19.992 --> 27:35:23.992
it's not confirmed yet. So what
we're going to need to do is

26508
27:35:23.992 --> 27:35:26.992
we're going to need to move our
blocks by one. So in our NFT

26509
27:35:26.992 --> 27:35:31.992
marketplace, we're just going to
create a new script, a new file

26510
27:35:31.992 --> 27:35:34.992
called Mind dot Jas, just to
move our blocks once, and we're

26511
27:35:34.992 --> 27:35:42.992
going to say const, move blocks,
equals require dot slash utils,

26512
27:35:42.992 --> 27:35:49.992
slash move blocks, we'll say
const blocks equals to const

26513
27:35:49.992 --> 27:35:58.992
sleep amount equals 1000 async
function mine, do await move

26514
27:35:58.992 --> 27:36:06.992
blocks will do blocks as the
parameter and then sleep sleep

26515
27:36:06.992 --> 27:36:12.992
amount will equal sleep amount.
And this will be a script. So

26516
27:36:12.992 --> 27:36:16.992
we'll add our copy paste our
that same syntax we're doing

26517
27:36:16.992 --> 27:36:20.992
here just with mine. And now we
want to just mine these two

26518
27:36:20.992 --> 27:36:27.992
blocks. So we'll run yarn, art
hat run scripts. Mind that Jas

26519
27:36:27.992 --> 27:36:33.992
dash dash network, local host.
So we're going to mine those two

26520
27:36:33.992 --> 27:36:38.992
blocks. Now if we go back to our
database, we go back to active

26521
27:36:38.992 --> 27:36:43.993
items, we can see it's been
updated because now in our item

26522
27:36:43.993 --> 27:36:50.993
listed, that 2500 event is now a
confirmed transaction, and we

26523
27:36:50.993 --> 27:36:54.993
get to confirm their excellent.
So that means since it's

26524
27:36:54.993 --> 27:36:57.993
confirmed back in our front end,
we'll give this a little

26525
27:36:57.993 --> 27:37:04.993
refresh. We can see the pup is
now worth 25 eath. Awesome. So

26526
27:37:04.993 --> 27:37:07.993
we're updating ngModel is
working perfectly. Excellent

26527
27:37:07.993 --> 27:37:10.993
job. So now let's go to the
readme. If you own the NFT, you

26528
27:37:10.993 --> 27:37:17.993
can update the listing. That's a
checkmark. Excellent. Next, what

26529
27:37:17.993 --> 27:37:20.993
do we want it to do? If you
don't own it, you can buy the

26530
27:37:20.993 --> 27:37:24.993
listing. Okay, so let's go back
to our website, let's switch

26531
27:37:24.993 --> 27:37:28.993
users to a different account,
we're probably going to want an

26532
27:37:28.993 --> 27:37:31.993
account that own some money. So
let's go ahead and send this

26533
27:37:31.993 --> 27:37:33.993
other account some money
transfer between my accounts,

26534
27:37:33.993 --> 27:37:38.993
we'll send 100 eath to account
one, confirm on our hard hat

26535
27:37:38.993 --> 27:37:41.993
chain here. Alright, great. Now
we can go ahead and switch to

26536
27:37:41.993 --> 27:37:44.993
account one, and we have 100
eath. Okay, great. As these

26537
27:37:44.993 --> 27:37:47.993
pops, each cost less than 100
eath. So that's gonna be more

26538
27:37:47.993 --> 27:37:50.993
than plenty for us to test this
out. Let's go back to this box.

26539
27:37:50.993 --> 27:37:53.993
Because I think somewhere we
said, we did a little handle

26540
27:37:53.993 --> 27:37:58.993
card click, if it's owned by the
user, have the modal pop up. If

26541
27:37:58.993 --> 27:38:02.993
not, let's do the by
functionality. So to do the by

26542
27:38:02.993 --> 27:38:04.993
functionality, we're gonna go
ahead and do another run

26543
27:38:04.993 --> 27:38:11.993
contract function. So we'll do
const run contract function,

26544
27:38:11.993 --> 27:38:17.993
we'll call this one by item. And
this will equal use web three

26545
27:38:17.993 --> 27:38:21.994
contract. And this is going to
be the ABI for the NFT

26546
27:38:21.994 --> 27:38:27.994
marketplace. API, the contract
address is going to be the

26547
27:38:27.994 --> 27:38:34.994
market place address. The
function name is going to be by

26548
27:38:34.994 --> 27:38:41.994
item, the message value is going
to be the price of the NFT.

26549
27:38:41.994 --> 27:38:44.994
Because we need to send that
amount to buy the item. And then

26550
27:38:44.994 --> 27:38:49.994
params are going to be NFT
address, which is going to be

26551
27:38:49.994 --> 27:38:54.994
the NFT address. And the token
ID, which is going to be the

26552
27:38:54.994 --> 27:38:58.994
token ID now that we have this
by item on handle card click, we

26553
27:38:58.994 --> 27:39:03.994
can say okay, said show ngModel
is true. Otherwise, we're gonna

26554
27:39:03.994 --> 27:39:09.994
call by item. And we're going to
do on air. Air is going to be a

26555
27:39:09.994 --> 27:39:12.994
function where we're just going
to console dot log the air and

26556
27:39:12.994 --> 27:39:19.994
onsuccess. It'll be a function
where we call handle by item

26557
27:39:19.994 --> 27:39:23.994
success. So we'll create a new
handler for this right

26558
27:39:23.994 --> 27:39:27.994
underneath handled cart click
the const handled by item

26559
27:39:27.994 --> 27:39:31.994
success equals a function. And
for this, we'll also have this

26560
27:39:31.994 --> 27:39:35.994
do a little notification. So
once again, we're going to

26561
27:39:35.994 --> 27:39:40.994
import we're going to import use
notification from web through UI

26562
27:39:40.994 --> 27:39:46.994
kit. We're going to say const.
Dispatch equals use

26563
27:39:46.994 --> 27:39:50.994
notification. And then in
handled by item success. We're

26564
27:39:50.994 --> 27:39:53.994
gonna say dispatch

26565
27:39:53.994 --> 27:40:04.995
type, success. Message. Item
bought. Title will also be item

26566
27:40:04.995 --> 27:40:12.995
bought. Then pole position will
be top right That's it. So

26567
27:40:12.995 --> 27:40:16.995
handle card click, if they own
it, we're going to show that

26568
27:40:16.995 --> 27:40:19.995
update listing ngModel. If they
don't already own it, someone's

26569
27:40:19.995 --> 27:40:22.995
gonna buy it. So let's go back
here. And I'm currently on an

26570
27:40:22.995 --> 27:40:25.995
account that does not own these
NF T's. Let's go ahead and click

26571
27:40:25.995 --> 27:40:29.995
it. Our Metamask does indeed
show up for 25 eath. That's

26572
27:40:30.995 --> 27:40:34.995
crazy expensive. Let's go ahead
and confirm item has been

26573
27:40:34.995 --> 27:40:37.995
bought, we'll go ahead and click
that little x, we go to our meta

26574
27:40:37.995 --> 27:40:41.995
mask, the transaction is
pending. And it's gone through.

26575
27:40:41.995 --> 27:40:45.995
This is fantastic. Okay, our
homepage is done, we can show

26576
27:40:45.995 --> 27:40:49.995
recently listed NF T's if not,
you can update the listing. If

26577
27:40:49.995 --> 27:40:52.995
not, you can buy the listing.
And now it's time for our cell

26578
27:40:52.995 --> 27:40:59.995
page. So the last thing that we
need to do is our cell page,

26579
27:40:59.995 --> 27:41:03.995
let's get this cell page, let's
get this done pages, we have our

26580
27:41:03.995 --> 27:41:07.995
cell NFT page, which right now
does a whole lot of nothing. And

26581
27:41:07.995 --> 27:41:11.995
on our front end, we go here,
there's not a whole lot here.

26582
27:41:11.995 --> 27:41:14.995
And actually, you can list your
NFT in the marketplace, we also

26583
27:41:14.995 --> 27:41:18.995
needed to add withdraw proceeds.
So I didn't add that. But that's

26584
27:41:18.995 --> 27:41:20.995
probably going to be something
we're going to want to allow

26585
27:41:20.995 --> 27:41:23.995
people to do as well. So let's
get started here. So we can

26586
27:41:23.995 --> 27:41:26.995
remove this head stuff now that
we're adding that in our main

26587
27:41:26.995 --> 27:41:31.995
page. And for us to submit a new
NFT, we're probably gonna need a

26588
27:41:31.995 --> 27:41:35.995
space to add the address of the
entity that token ID of the NFT

26589
27:41:35.995 --> 27:41:37.995
and all this other stuff. So
we're gonna need a form to do

26590
27:41:37.995 --> 27:41:41.996
this, which guess what, we can
also grab a form from the web

26591
27:41:41.996 --> 27:41:45.996
through UI kit as well. So we're
gonna go ahead in our cell NMC

26592
27:41:45.996 --> 27:41:53.996
page, we're going to import form
from web three UI kit. And we're

26593
27:41:53.996 --> 27:41:57.996
going to create a new form in
our cell page. Now, the

26594
27:41:57.996 --> 27:42:00.996
parameters we can add to our
form, again, you can find them

26595
27:42:00.996 --> 27:42:03.996
in documentation here, or we're
going to add with one of the

26596
27:42:03.996 --> 27:42:06.996
main pieces is going to be this
data piece, which is going to be

26597
27:42:06.996 --> 27:42:11.996
an object that has a list in it,
of all the different fields, we

26598
27:42:11.996 --> 27:42:14.996
can put in our form. So maybe
we'll do our first one have a

26599
27:42:14.996 --> 27:42:21.996
name of NFT address. That's
gonna be of type text, excuse

26600
27:42:21.996 --> 27:42:26.996
me, and these are all going to
be this is a list of list of

26601
27:42:26.996 --> 27:42:30.996
objects like that. Now, if we
save that, we go back to our

26602
27:42:30.996 --> 27:42:34.996
cell page, we can now see an
empty address and a little

26603
27:42:34.996 --> 27:42:37.996
Submit button. That right now
does a whole lot of nothing. So

26604
27:42:37.996 --> 27:42:41.996
we have an NFT address, it'll
take a text, maybe we'll also do

26605
27:42:41.996 --> 27:42:48.996
in foot width of 50 percent will have
the starting value be blank. And

26606
27:42:48.996 --> 27:42:52.996
the key of this will be NFT
address, what else do we need,

26607
27:42:52.996 --> 27:42:58.996
we're going to need to give it
the token ID so we'll say name,

26608
27:42:58.996 --> 27:43:04.996
token ID, type is going to be a
number value, we'll start off

26609
27:43:04.996 --> 27:43:12.996
it's blank. And then the key for
this will be token ID. Next,

26610
27:43:12.996 --> 27:43:18.996
we're going to need the price.
So we'll say name will be price.

26611
27:43:18.996 --> 27:43:25.997
In eath. type will be a number
value will be blank. And the key

26612
27:43:25.997 --> 27:43:29.997
will be price. And we don't need
to have to form tags, we'll just

26613
27:43:29.997 --> 27:43:33.997
delete that second one and have
it auto close with one tag. And

26614
27:43:33.997 --> 27:43:40.997
then in here, we'll do title
equals sell your NF T ID equals

26615
27:43:40.997 --> 27:43:44.997
main form. So cool. So now we
can take an empty address, a

26616
27:43:44.997 --> 27:43:48.997
token ID and a new price with
the title of cellular NFT.

26617
27:43:48.997 --> 27:43:51.997
Great, that looks really nice.
Right now our form doesn't do

26618
27:43:51.997 --> 27:43:53.997
anything, we probably want to
give it the functionality to

26619
27:43:54.997 --> 27:43:58.997
actually do stuff. So we'll say
on Submit, and we'll have to

26620
27:43:58.997 --> 27:44:01.997
create a new function to
actually list our NF T's. So

26621
27:44:01.997 --> 27:44:05.997
we're going to create a function
called approve and list we have

26622
27:44:05.997 --> 27:44:10.997
to approve our marketplace to
pull the NFT from our wallets.

26623
27:44:10.997 --> 27:44:14.997
So we're going to create a new
function, a sync function

26624
27:44:14.997 --> 27:44:19.997
approven list, which is going to
take a data input parameter on

26625
27:44:19.997 --> 27:44:22.997
our form, when we hit on submit,
it's automatically going to pass

26626
27:44:22.997 --> 27:44:26.997
this data object to our approved
list function. So that's how

26627
27:44:26.997 --> 27:44:29.997
we're going to get the value of
the address the value of the

26628
27:44:29.997 --> 27:44:33.997
token ID and the value of the
price. So in our async function

26629
27:44:33.997 --> 27:44:39.997
approven list, do console dot
log, approving the contract, the

26630
27:44:39.997 --> 27:44:44.997
NFT address is going to come
from this data object. So it's

26631
27:44:44.997 --> 27:44:50.997
going to be data dot data at
index zero, or zero with object

26632
27:44:50.997 --> 27:44:56.997
here is going to be our address
that input result.

26633
27:44:56.997 --> 27:45:01.998
Our token ID is going to equal
data dot data. One because

26634
27:45:01.998 --> 27:45:07.998
again, this one is going to be
our token ID that input result.

26635
27:45:07.998 --> 27:45:12.998
And then the price is going to
equal that ethers dot utils dot

26636
27:45:12.998 --> 27:45:22.998
parse units of data dot data
have to the input result, comma

26637
27:45:22.998 --> 27:45:28.998
ether.to string. So we're going
to get the price in eath. In

26638
27:45:28.998 --> 27:45:32.998
human readable form, we're going
to convert it to Aetherium

26639
27:45:32.998 --> 27:45:35.998
readable form. And then we're
going to pass it as a string

26640
27:45:35.998 --> 27:45:39.998
because this returns a big
number, which we don't want. So

26641
27:45:39.998 --> 27:45:42.998
we have the NFT address, the
token ID and the price of the

26642
27:45:42.998 --> 27:45:46.998
new listing, what we can do now
is we can say const approve

26643
27:45:46.998 --> 27:45:51.998
options equals a little function
here, the ABI which is going to

26644
27:45:51.998 --> 27:45:55.998
be our NFT abi, which we need to
import, we need to import both

26645
27:45:55.998 --> 27:46:03.998
ethers from ethers. And we also
need to import the NFT abi, for

26646
27:46:03.998 --> 27:46:07.998
its NFT ABI from dot dot
constants slash basic at A T dot

26647
27:46:07.998 --> 27:46:12.998
JSON, I just copied and pasted
from the NFT box, the contract

26648
27:46:12.998 --> 27:46:19.998
address is going to be the NFT
address, the function name is

26649
27:46:19.998 --> 27:46:26.998
going to be approve params are
going to be two, the marketplace

26650
27:46:27.998 --> 27:46:29.998
address, which we're going to
define in just a second, and

26651
27:46:29.998 --> 27:46:34.998
then the token ID will be token
ID. Now the marketplace address

26652
27:46:34.998 --> 27:46:38.998
in our NFT box, we're getting
this directly from index, an

26653
27:46:38.998 --> 27:46:42.999
index is getting it from our
database. Now we want our app to

26654
27:46:42.999 --> 27:46:46.999
be smart enough to be able to
grab the NFT marketplace itself,

26655
27:46:46.999 --> 27:46:50.999
the marketplace address. And if
we go to our constants, right

26656
27:46:50.999 --> 27:46:53.999
now, we actually have it in this
network mapping. So we're going

26657
27:46:53.999 --> 27:46:56.999
to want to grab it right up at
the top by saying const

26658
27:46:56.999 --> 27:47:02.999
marketplace address equals
network mapping, network mapping

26659
27:47:02.999 --> 27:47:07.999
of what of the chain ID of the
entity marketplace address at

26660
27:47:07.999 --> 27:47:11.999
the zero with index. So network
mapping of the chain ID, which

26661
27:47:11.999 --> 27:47:17.999
we're going to get honest chain
ID equals us Morales. Now chain

26662
27:47:17.999 --> 27:47:22.999
Id actually comes like we said
it's a wax hex form for Morales.

26663
27:47:22.999 --> 27:47:25.999
So we're gonna have to convert
the chain ID to its string

26664
27:47:25.999 --> 27:47:31.999
readable version. So we'll say
const, chain string equals chain

26665
27:47:31.999 --> 27:47:35.999
ID. And we'll do a tertiary
operator, if the chain ID

26666
27:47:35.999 --> 27:47:42.999
exists, will parse int of the
chain id.to string. So we'll

26667
27:47:42.999 --> 27:47:46.999
parse it from its hex to a more
readable version, and then do.to

26668
27:47:46.999 --> 27:47:51.999
string. And then otherwise,
we'll just say we're on 31337.

26669
27:47:51.999 --> 27:47:55.999
So chain ID string. So in the
network mapping at the chain ID

26670
27:47:55.999 --> 27:48:02.999
string, dot NFT marketplace at
index zero, that's going to be

26671
27:48:02.999 --> 27:48:06.999
our marketplace address. So we
got the marketplace address,

26672
27:48:06.999 --> 27:48:10.999
this is all we need to call the
approved function on our NFT we

26673
27:48:10.999 --> 27:48:13.999
can now call running contract
function for a proof. So we're

26674
27:48:13.999 --> 27:48:15.999
actually going to do this a
little bit differently. We're

26675
27:48:15.999 --> 27:48:23.100
just going to say const. Run
contract function equals use web

26676
27:48:23.100 --> 27:48:27.100
three contract, you could import
just run contract function, and

26677
27:48:27.100 --> 27:48:30.100
then pass all those options to
it like what we're gonna do

26678
27:48:30.100 --> 27:48:34.100
here. Now we're just gonna say
await on contract function.

26679
27:48:34.100 --> 27:48:37.100
Because this is an async
function await run contract

26680
27:48:37.100 --> 27:48:43.100
function, we're gonna say params
are going to be approve options.

26681
27:48:43.100 --> 27:48:47.100
And we're gonna say onsuccess,
we're going to do something, I'm

26682
27:48:47.100 --> 27:48:52.100
going to say on error, we're
also going to just do error,

26683
27:48:52.100 --> 27:48:59.100
little arrow function, console
dot log error. Now on success,

26684
27:48:59.100 --> 27:49:03.100
once we send this transaction,
after the Approve goes through,

26685
27:49:03.100 --> 27:49:06.100
we're going to want to call the
list function right underneath

26686
27:49:06.100 --> 27:49:13.100
this will call async async.
Function, handle approve

26687
27:49:13.100 --> 27:49:18.100
success. And this is going to
take the NFT address, the token

26688
27:49:18.100 --> 27:49:22.100
ID, and the price is it put in
parameters. So once this run

26689
27:49:22.100 --> 27:49:26.100
contract function goes through,
we're going to call

26690
27:49:26.100 --> 27:49:29.100
of handle proof success. And
we'll pass it the end of the

26691
27:49:29.100 --> 27:49:36.100
address, token ID and the price,
which will say console dot log.

26692
27:49:36.100 --> 27:49:40.100
Okay, now time to list and we'll
do the same thing. We'll do

26693
27:49:40.100 --> 27:49:45.100
const list options, equals and
this is going to be all the

26694
27:49:45.100 --> 27:49:48.100
options for calling the list
function API is going to be on

26695
27:49:48.100 --> 27:49:54.100
the marketplace this time. So
NFT market place abi, which

26696
27:49:54.100 --> 27:49:56.100
again, we're going to have to
import so I'm going to go back

26697
27:49:56.100 --> 27:50:00.100
to NFT box. We're gonna copy
that line here, paste it in the

26698
27:50:00.100 --> 27:50:04.100
top. That's going to be the API
for that contract address. It's

26699
27:50:04.100 --> 27:50:09.100
going to be the marketplace
address, which we already have.

26700
27:50:09.100 --> 27:50:14.100
function name is going to be
list item. And the params are

26701
27:50:14.100 --> 27:50:22.100
going to be NF T address of the
NFT address, token ID of token

26702
27:50:22.100 --> 27:50:28.100
ID, price of price. And now we
have those options, we can do

26703
27:50:28.100 --> 27:50:35.100
await, run contract function
with params. Of list options,

26704
27:50:35.100 --> 27:50:42.100
will say onsuccess arrow
function, handle list success,

26705
27:50:42.100 --> 27:50:47.100
which is a function we haven't
made yet. It will say on air

26706
27:50:47.100 --> 27:50:54.100
error. And we'll just say
console dot log error. Okay, so

26707
27:50:54.100 --> 27:50:58.100
let's make this handle list
success handle one spell handle

26708
27:50:58.100 --> 27:51:03.100
correctly handle the success,
this will be an async function.

26709
27:51:03.100 --> 27:51:05.100
And this is also going to call
dispatch and make a little

26710
27:51:05.100 --> 27:51:10.100
notification. So we're going to
grab that from web three UI kit,

26711
27:51:10.100 --> 27:51:16.100
use notification. We'll say
const dispatch equals use

26712
27:51:16.100 --> 27:51:22.100
notification. And now down in
handle the success say dispatch,

26713
27:51:22.100 --> 27:51:33.100
type success. Message NFT
listing, title NFT listed

26714
27:51:33.100 --> 27:51:39.100
position. top bar, and cool. And
we're also gonna have to grab us

26715
27:51:39.100 --> 27:51:46.100
Morales from react Morales. So
do import us Morales from react

26716
27:51:46.100 --> 27:51:51.100
or else. So let's import this
network mapping. Import network

26717
27:51:51.100 --> 27:51:56.100
mapping from dot dot slash
constants slash network mapping

26718
27:51:57.100 --> 27:52:00.100
dot JSON. Because I spelled
contract address wrong again,

26719
27:52:00.100 --> 27:52:03.100
good our front end we'll give it
a refresh us web three contract

26720
27:52:03.100 --> 27:52:07.100
isn't defined. Let's get that
from react moralss. Well save

26721
27:52:07.100 --> 27:52:11.100
that refresh our front end. And
tada, we're good to go here.

26722
27:52:11.100 --> 27:52:14.100
Alright, now to test this out,
we're going to want to do is

26723
27:52:14.100 --> 27:52:16.100
we're going to want to create
another script here. So we're

26724
27:52:16.100 --> 27:52:19.100
back in our heart at NFT
marketplace, we're looking at

26725
27:52:19.100 --> 27:52:22.100
our scripts. And we're going to
create a new file just called

26726
27:52:22.100 --> 27:52:27.100
mint.js. So we're not going to
list this time, we're just going

26727
27:52:27.100 --> 27:52:31.100
to mint it just going to mint an
NF t so we can list it ourselves

26728
27:52:31.100 --> 27:52:34.100
on the UI. And actually, we can
just copy our mminton list code,

26729
27:52:34.100 --> 27:52:39.100
paste it into here, and just
remove the approval and the

26730
27:52:39.100 --> 27:52:44.100
listing code. Boom, remove that,
remove this, remove this. And

26731
27:52:44.100 --> 27:52:47.100
that's all we need. And now
we'll just change the name to

26732
27:52:47.100 --> 27:52:50.100
mint. Well, we can remove price
as well. And we'll change this

26733
27:52:50.100 --> 27:52:55.100
to mint. And that's it. Now we
have a script that we can call,

26734
27:52:55.100 --> 27:52:58.100
well, we'll just mint an NFT, we
can also get rid of the NFT

26735
27:52:58.100 --> 27:53:01.100
marketplace. Actually, we will
probably want the token ID so we

26736
27:53:01.100 --> 27:53:07.100
can know what it is. So let's do
const token ID equals. So let's

26737
27:53:07.100 --> 27:53:11.100
actually get the receipt we'll
do const mint TX receipt, but

26738
27:53:11.100 --> 27:53:15.100
the receipt, I can there equals
that. And then I'm just going to

26739
27:53:15.100 --> 27:53:19.100
copy this from the mminton
receipt. Cons token ID equals

26740
27:53:19.100 --> 27:53:26.100
this, paste it into our mint.js
and then a console dot log. Got

26741
27:53:26.100 --> 27:53:33.100
token ID, string interpolates
token ID, hard hat, run scripts,

26742
27:53:33.100 --> 27:53:38.100
mins dot j s dash dash network,
local host. And we're going to

26743
27:53:38.100 --> 27:53:46.100
mint an NF T. Got token ID six
means we know m token ID six, we

26744
27:53:46.100 --> 27:53:49.100
can list this entity. Let's also
add the address. Let's do

26745
27:53:49.100 --> 27:53:56.100
console dot log NFTL. And if the
address is going to be we'll do

26746
27:53:56.100 --> 27:53:59.100
string interpolation.

26747
27:53:59.100 --> 27:54:03.100
And you know what? Let's make
this again. Mint dot j s okay

26748
27:54:03.100 --> 27:54:07.100
cool. Got token ID seven and if
the address this so what we can

26749
27:54:07.100 --> 27:54:11.100
do now we'll grab this NFT
address. So from account one,

26750
27:54:11.100 --> 27:54:13.100
let's go to Account three
because that's the account that

26751
27:54:13.100 --> 27:54:16.100
I've done my imports on now when
you switch accounts, we're going

26752
27:54:16.100 --> 27:54:22.100
to want to refresh the page as
the address seven 0.6. Submit

26753
27:54:22.100 --> 27:54:26.100
Metamask pops up. Give
permission Yes. Okay, now it's

26754
27:54:26.100 --> 27:54:31.100
time to list you now have one
pen, okay. Local host list item.

26755
27:54:31.100 --> 27:54:33.100
We can see all the data and
everything. Okay, let's go ahead

26756
27:54:33.100 --> 27:54:38.100
and confirm NFT listed Okay,
okay. Okay. Okay. So this is

26757
27:54:38.100 --> 27:54:41.100
good. Now to get Morales to
catch up to speed back in our

26758
27:54:41.100 --> 27:54:46.100
node. Let's just go ahead and
run yarn, RT hat run scripts,

26759
27:54:46.100 --> 27:54:51.100
mine dot j s dash dash network,
local host. We're going to mine

26760
27:54:51.100 --> 27:54:55.100
those two blocks. And now if we
go to our item listed, we'll

26761
27:54:55.100 --> 27:55:01.100
give this a little refresh. Go
to active item. We can see

26762
27:55:01.100 --> 27:55:05.100
there's a new item listed for
0.6 eath. In our database. This

26763
27:55:05.100 --> 27:55:09.100
is fantastic. Now that we've
listed this, if we go back to

26764
27:55:09.100 --> 27:55:13.100
now let's make And let's move on
to one more. Let's list the

26765
27:55:13.100 --> 27:55:15.100
second one, just to see that
it's actually working. Okay,

26766
27:55:15.100 --> 27:55:20.100
token ID eight. Let's grab this
address. Let's give this a

26767
27:55:20.100 --> 27:55:26.100
refresh. paste this in token ID
eight. We'll do 0.999. Let's

26768
27:55:26.100 --> 27:55:34.100
submit. we'll approve this. Yes.
Then we'll send it. Yes. Okay,

26769
27:55:34.100 --> 27:55:36.100
now let's go ahead and mine two
blocks. So I'm just going to hit

26770
27:55:36.100 --> 27:55:41.100
up and go back to mine will run
the mining, moving blocks. Okay,

26771
27:55:41.100 --> 27:55:47.100
great. Now, if we go back home,
we'll see there are three NF T's

26772
27:55:47.100 --> 27:55:51.100
now listed, we have the original
one, that we have those two that

26773
27:55:51.100 --> 27:55:56.100
we just listed eight, and seven
for 0.6 and 0.999. Listed on our

26774
27:55:56.100 --> 27:56:00.100
NFT marketplace. This is so
exciting. Our listing is working

26775
27:56:00.100 --> 27:56:03.100
correctly, okay. Now, due to the
fact that this lesson is already

26776
27:56:03.100 --> 27:56:07.100
incredibly long, actually
decided to cut the part of that

26777
27:56:07.100 --> 27:56:09.100
and then withdraw a bit, because
we don't really learn anything

26778
27:56:09.100 --> 27:56:13.100
new there. However, feel free to
jump back in to get every bit

26779
27:56:13.100 --> 27:56:16.100
associated with scores, where we
will have that withdrawal

26780
27:56:16.100 --> 27:56:20.100
functionality for you if you
want to implement it. Otherwise,

26781
27:56:20.100 --> 27:56:22.100
feel free to skip and move on
ahead. This is incredibly

26782
27:56:22.100 --> 27:56:25.100
powerful. And you should be
incredibly excited about

26783
27:56:25.100 --> 27:56:30.100
yourself. If you've made it this
far. This is awesome. You just

26784
27:56:30.100 --> 27:56:33.100
made a decentralized marketplace
and then built a front end on

26785
27:56:33.100 --> 27:56:37.100
top of it to allow anybody to
interact with your marketplace.

26786
27:56:37.100 --> 27:56:42.100
Easily. Huge, huge.
Congratulations here. Oh, this

26787
27:56:42.100 --> 27:56:45.100
is a perfect time to go take a
break and celebrate. And this is

26788
27:56:45.100 --> 27:56:48.100
a great time to ping me on
Twitter to ping me on Twitter

26789
27:56:48.100 --> 27:56:51.100
saying hey, Patrick, I just
completed the NFT marketplace.

26790
27:56:51.100 --> 27:56:55.100
Full Stack front end part of
your Free Code Camp course, I

26791
27:56:55.100 --> 27:56:59.100
now know how to build full stack
front end on top of my smart

26792
27:56:59.100 --> 27:57:02.100
contract applications. And be so
so pumped with yourself because

26793
27:57:02.100 --> 27:57:06.100
this is so awesome. I can't
understate how excited I am that

26794
27:57:06.100 --> 27:57:09.100
you've made it this far, you are
learning and working with a ton

26795
27:57:09.100 --> 27:57:12.100
of technologies, solidity smart
contracts, and front end you are

26796
27:57:12.100 --> 27:57:15.100
doing full stack you were doing
a lot of stuff here. So you

26797
27:57:15.100 --> 27:57:18.100
should be really proud of
yourself. huge congratulations,

26798
27:57:18.100 --> 27:57:22.100
be sure to absolutely give
yourself a pat on the back. And

26799
27:57:22.100 --> 27:57:27.100
then get ready to continue to
our next section.

26800
27:57:27.100 --> 27:57:31.100
Now that we've done all of this
using our Morales back end, I'm

26801
27:57:31.100 --> 27:57:34.100
about to switch it up on you,
instead of indexing all of our

26802
27:57:34.100 --> 27:57:37.100
events with a centralized
server. Now we're going to learn

26803
27:57:37.100 --> 27:57:42.100
how to build this using the
graph, which is a decentralized

26804
27:57:42.100 --> 27:57:46.100
event indexer that we can use, a
lot of the code is going to be

26805
27:57:46.100 --> 27:57:52.100
exactly the same. So instead of
us starting from a new, what

26806
27:57:52.100 --> 27:57:55.100
we're going to do, first of all
we can we can close all our

26807
27:57:55.100 --> 27:57:59.100
local stuff, we can close all of
these things, we can close all

26808
27:57:59.100 --> 27:58:03.100
of our terminals finally, which
is really exciting. And in this

26809
27:58:03.100 --> 27:58:05.100
folder, what we're going to do
is we're actually just going to

26810
27:58:06.100 --> 27:58:11.100
copy everything into a new
folder. So I'm going to CD down

26811
27:58:11.100 --> 27:58:15.100
a directory, we're going to make
a new one called next Jas. And

26812
27:58:15.100 --> 27:58:23.100
if T marketplace, the graph,
dash FCC, and all the code for

26813
27:58:23.100 --> 27:58:28.100
this section is going to be here
for front end the graph indexer

26814
27:58:28.100 --> 27:58:30.100
we're gonna have to make another
repo and we'll get to that in a

26815
27:58:30.100 --> 27:58:33.100
little bit. For all the changes,
it's going to be in this section

26816
27:58:33.100 --> 27:58:36.100
here. So what we're going to do
is we're going to make this new

26817
27:58:36.100 --> 27:58:42.100
folder, and we're going to do
copy dash R. Next, Jas and ft

26818
27:58:42.100 --> 27:58:51.100
marketplace FCC into next Jas
NFT. Marketplace, the graph FCC.

26819
27:58:51.100 --> 27:58:54.100
So we're going to copy
recursively, everything that's

26820
27:58:54.100 --> 27:58:57.100
inside that folder we just
created into this new one that

26821
27:58:57.100 --> 27:59:00.100
we're going to make a lot of
adjustments to. And this might

26822
27:59:00.100 --> 27:59:04.100
take a little bit of time to run
because we've got a lot of stuff

26823
27:59:04.100 --> 27:59:07.100
in this folder. And Alright,
once we've done that, we can cd

26824
27:59:07.100 --> 27:59:13.100
into this next Jas and ft
marketplace, the graph FCC and

26825
27:59:13.100 --> 27:59:17.100
do code period and open this up
in a new code editor. Or as

26826
27:59:17.100 --> 27:59:21.100
always, you can do File Open
folder to open it like that. Now

26827
27:59:21.100 --> 27:59:24.100
that we're in here, we're going
to learn how to do this exact

26828
27:59:24.100 --> 27:59:28.100
same project, instead of using
mirallas. But using the graph,

26829
27:59:28.100 --> 27:59:29.100
one of the things that we're
first going to do is we're

26830
27:59:29.100 --> 27:59:33.100
actually going to deploy our
contracts to rink B. So we're

26831
27:59:33.100 --> 27:59:37.100
going to grab our marketplace,
that soul, pull this over, we're

26832
27:59:37.100 --> 27:59:40.100
going to grab our hard hat
marketplace dot soul project,

26833
27:59:40.100 --> 27:59:43.100
pull it over. And first, we're
going to run our deploy script

26834
27:59:43.100 --> 27:59:46.100
on rink v. So hopefully, you've
got all your deploy stuff set up

26835
27:59:46.100 --> 27:59:49.100
correctly, so that all the
arguments can go through

26836
27:59:49.100 --> 27:59:52.100
correctly for rink v as well. So
we're gonna go ahead and run

26837
27:59:52.100 --> 27:59:58.100
this yarn, hard hat deploy dash
dash network Rinkeby. And to

26838
27:59:58.100 --> 28:00:01.100
make sure that it's going to
work for Rinkeby. Let's check

26839
28:00:01.100 --> 28:00:05.100
our hard hat config. Okay for
networks, looks like I have my

26840
28:00:05.100 --> 28:00:08.100
Rigby stuff in here for
networks. Okay, I've got my RPC

26841
28:00:08.100 --> 28:00:11.100
URL, which I'm getting from my
environment variables. If I have

26842
28:00:11.100 --> 28:00:13.100
a private key, I have a private
key, which I'm also getting from

26843
28:00:13.100 --> 28:00:17.100
environment variables, I have a
chain ID block confirmations and

26844
28:00:17.100 --> 28:00:20.100
save deployments. So let's go
ahead and run this. Now we're

26845
28:00:20.100 --> 28:00:23.100
going to go ahead and be
deploying the NFT marketplace to

26846
28:00:23.100 --> 28:00:27.100
the Rigby network. And our
deploy script also has an ID

26847
28:00:27.100 --> 28:00:30.100
some verification. So we can
verify this as well, you can't

26848
28:00:30.100 --> 28:00:33.100
really follow along with this
section without deploying a

26849
28:00:33.100 --> 28:00:36.100
marketplace to rink be here. So
deploy to rank B, or whatever

26850
28:00:36.100 --> 28:00:40.100
test net is recommended in this
lesson 15 section, and go from

26851
28:00:40.100 --> 28:00:43.100
there. Alright, great, we've
deployed our NFC marketplace.

26852
28:00:43.100 --> 28:00:46.100
Now we're gonna go ahead and
deploy our basic NFT. And once

26853
28:00:46.100 --> 28:00:48.100
these are done deploying, we can
start updating our front end

26854
28:00:48.100 --> 28:00:51.100
code to work with the graph
instead of mirallas. Okay, we've

26855
28:00:51.100 --> 28:00:54.100
verified everything to which
looks great. Now we're going to

26856
28:00:54.100 --> 28:00:58.100
verify our basic NFT. And we've
have it verified. Awesome. So

26857
28:00:58.100 --> 28:01:02.100
now we have an NFT marketplace
deployed to ring P, and a basic

26858
28:01:02.100 --> 28:01:06.100
NFT deployed to rink B. And both
of them are verified. So be sure

26859
28:01:06.100 --> 28:01:09.100
to take note of those, because
we're going to need them when

26860
28:01:09.100 --> 28:01:13.100
we're moving over to our the
graph section. So now let's grab

26861
28:01:13.100 --> 28:01:17.100
our code editor titled next Jas
and ft marketplace, the graph.

26862
28:01:17.100 --> 28:01:21.100
And let's get going. Now, we
just deployed that to rink B.

26863
28:01:21.100 --> 28:01:24.100
But we forgot to add some code
in here to update our network

26864
28:01:24.100 --> 28:01:29.100
mapping. However, if we go back
and we open back up code dot

26865
28:01:29.100 --> 28:01:36.100
dot, next Jas NFT marketplace,
FCC, in the network mapping in

26866
28:01:36.100 --> 28:01:39.100
here will now have a new entry
for rink B, if we did it

26867
28:01:39.100 --> 28:01:43.100
correctly, let's copy this
network mapping and paste it

26868
28:01:43.100 --> 28:01:47.100
over in our network, our next GS
and ft marketplace, the graph

26869
28:01:47.100 --> 28:01:50.100
section, or you can just
manually add your new entry.

26870
28:01:50.100 --> 28:01:53.100
Right. So you want to add
network ID for network

26871
28:01:53.100 --> 28:01:56.100
marketplace. And the address of
that network marketplace that

26872
28:01:56.100 --> 28:01:59.100
you just deployed, is we're
going to delete this Cloud

26873
28:01:59.100 --> 28:02:02.100
Functions bit. Goodbye, because
since we're not working with the

26874
28:02:02.100 --> 28:02:05.100
server anymore, there's not
gonna be any cloud functions or

26875
28:02:05.100 --> 28:02:08.100
any back end to run. So we're
gonna move that to trash

26876
28:02:08.100 --> 28:02:11.100
goodbye. Next, we don't need FRP
anymore, because we're not going

26877
28:02:11.100 --> 28:02:14.100
to be connecting our local
blockchain to the graph, we're

26878
28:02:14.100 --> 28:02:16.100
only going to be working with
the test net here. So let's go

26879
28:02:16.100 --> 28:02:21.100
ahead and delete that. Goodbye,
what's next in our pages, and

26880
28:02:21.100 --> 28:02:26.100
our app dot j s. Right now we're
connecting to a Morales provider

26881
28:02:26.100 --> 28:02:31.100
like this, we're going to switch
this back to initiate allies on

26882
28:02:31.100 --> 28:02:35.100
Mount, this is going to go back
to being false, we're no longer

26883
28:02:35.100 --> 28:02:38.100
going to connect to our Morales
database like this, we're just

26884
28:02:38.100 --> 28:02:41.100
going to use the hooks again.
Now with that the only thing

26885
28:02:41.100 --> 28:02:44.100
that's going to change is our
index.js. Right now, in our

26886
28:02:44.100 --> 28:02:51.100
index.js, we're getting our list
of NF TS from our Morales query.

26887
28:02:51.100 --> 28:02:54.100
So we're going to change this,
let's update our readme. So

26888
28:02:54.100 --> 28:02:58.100
we're gonna say instead of
reading the events from ralis,

26889
28:02:58.100 --> 28:03:02.100
we will first off we're going to
index them with the graph. And

26890
28:03:02.100 --> 28:03:05.100
then we're going to read from
the graph. So the question is,

26891
28:03:05.100 --> 28:03:09.100
what is the graph.

26892
28:03:09.100 --> 28:03:13.100
So the graph is going to be a
decentralized layer for storing

26893
28:03:13.100 --> 28:03:16.100
event data. So there are all
these blockchains and all these

26894
28:03:16.100 --> 28:03:19.100
different storage networks. And
the graph is and the graph is a

26895
28:03:19.100 --> 28:03:23.100
network of different nodes that
read from blockchains and index

26896
28:03:23.100 --> 28:03:27.100
this data, and it exposes an API
for us to call we can read that

26897
28:03:27.100 --> 28:03:29.100
data. Rather than just myself.
We actually have nattered

26898
28:03:29.100 --> 28:03:32.100
Abbott, who can explain it a lot
better than I can take it away.

26899
28:03:32.100 --> 28:03:33.100
And at.

26900
28:03:33.100 --> 28:03:36.100
First, I'd like to thank Patrick
for creating such a wonderful

26901
28:03:36.100 --> 28:03:39.100
educational resource and
inviting me to be a part of it.

26902
28:03:39.100 --> 28:03:42.100
My name is Nadia dabit. I'm a
developer relations engineer

26903
28:03:42.100 --> 28:03:44.100
working with the graph. The
graph is an indexing and

26904
28:03:44.100 --> 28:03:46.100
querying protocol for
decentralized networks like

26905
28:03:46.100 --> 28:03:50.100
Aetherium IPFS, dozens of other
EVM compatible networks, as well

26906
28:03:50.100 --> 28:03:53.100
as near and then the future
cosmos and Solana. Using the

26907
28:03:53.100 --> 28:03:56.100
graph developers can build and
publish open API's called

26908
28:03:56.100 --> 28:03:59.100
subgraphs that they can then use
in their applications to enable

26909
28:03:59.100 --> 28:04:02.100
better querying capabilities of
data stored on these networks,

26910
28:04:02.100 --> 28:04:05.100
including features like
filtering, sorting, relational

26911
28:04:05.100 --> 28:04:09.100
data, and full stack search.
subgraphs live in between the

26912
28:04:09.100 --> 28:04:12.100
blockchain and the UI providing
an important piece of software

26913
28:04:12.100 --> 28:04:15.100
infrastructure, a flexible
performant and decentralized API

26914
28:04:15.100 --> 28:04:19.100
layer, and the traditional tech
stack databases, servers and

26915
28:04:19.100 --> 28:04:24.100
API's query filter, sort
paginate group and join data

26916
28:04:24.100 --> 28:04:27.100
before it's returned to an
application, usually via some

26917
28:04:27.100 --> 28:04:31.100
type of HTTP request. These
types of data transformations

26918
28:04:31.100 --> 28:04:34.100
are not possible when reading
data directly from Aetherium or

26919
28:04:34.100 --> 28:04:37.100
other blockchains. Before the
graph teams had to develop and

26920
28:04:37.100 --> 28:04:40.100
operate proprietary indexing
servers. This required

26921
28:04:40.100 --> 28:04:43.100
significant engineering and
hardware resources and broke the

26922
28:04:43.100 --> 28:04:46.100
important security principles
required for decentralization,

26923
28:04:46.100 --> 28:04:49.100
how we interact with and build
on top of blockchains it's much

26924
28:04:49.100 --> 28:04:51.100
different than what we are used
to in the traditional tech

26925
28:04:51.100 --> 28:04:54.100
stack. In a blockchain data
isn't stored in a format that

26926
28:04:54.100 --> 28:04:58.100
can be easily or efficiently
consumed, or retrieved directly

26927
28:04:58.100 --> 28:05:01.101
from other applications or front
ends. The problem is that you

26928
28:05:01.101 --> 28:05:03.101
need to have the data indexed
and organized for efficient

26929
28:05:03.101 --> 28:05:07.101
retrieval. Traditionally, that's
the work that databases and web

26930
28:05:07.101 --> 28:05:10.101
servers do in this centralized
tech stack. But that in indexing

26931
28:05:10.101 --> 28:05:13.101
layer was missing in the web
three stack. Let's take a look

26932
28:05:13.101 --> 28:05:16.101
at a couple of other examples of
indexing in the real world.

26933
28:05:16.101 --> 28:05:19.101
Search engines like Google crawl
the internet indexing relevant

26934
28:05:19.101 --> 28:05:22.101
data making it available for
users to search via their web

26935
28:05:22.101 --> 28:05:25.101
interface and other API's.
Without this indexing layer,

26936
28:05:25.101 --> 28:05:28.101
it'd be hard for us to know
where and how to find relevant

26937
28:05:28.101 --> 28:05:31.101
information across the web.
Another similar analogy is a

26938
28:05:31.101 --> 28:05:35.101
library. Using an indexing
system like the Dewey Decimal

26939
28:05:35.101 --> 28:05:38.101
System, we know where to find
the book that we're looking for

26940
28:05:38.101 --> 28:05:41.101
without having to go through
book by book looking throughout

26941
28:05:41.101 --> 28:05:44.101
the entire library. The graph
serves over 2 billion queries

26942
28:05:44.101 --> 28:05:47.101
per day to many different types
of web three applications,

26943
28:05:47.101 --> 28:05:50.101
including apps in the defy
gaming and FC space. Before we

26944
28:05:50.101 --> 28:05:53.101
dig into any code, let's take a
look at how to build a sub

26945
28:05:53.101 --> 28:05:56.101
graph. To get started, you would
go to the graph.com and create a

26946
28:05:56.101 --> 28:06:00.101
new sub graph and the graph user
interface. You would then use

26947
28:06:00.101 --> 28:06:03.101
the graph CLI to scaffold out an
empty sub graph boilerplate that

26948
28:06:03.101 --> 28:06:07.101
you can then update with your
own contract information. In

26949
28:06:07.101 --> 28:06:09.101
your subgraph configuration, you
would define things like your

26950
28:06:09.101 --> 28:06:12.101
data model, the network, the
contract addresses and other

26951
28:06:12.101 --> 28:06:15.101
configurations that are specific
to the data that you would like

26952
28:06:15.101 --> 28:06:20.101
to index. For our data model, we
use Graph QL, schema definition

26953
28:06:20.101 --> 28:06:23.101
language defining top level
types as well as fields within

26954
28:06:23.101 --> 28:06:26.101
those types. When we're ready to
deploy our subgraph, so we can

26955
28:06:26.101 --> 28:06:29.101
begin testing it out and using
it in our application, we can

26956
28:06:29.101 --> 28:06:33.101
use the graph CLI running the
deploy command. Once the

26957
28:06:33.101 --> 28:06:36.101
subgraph is deployed and the
data begins to be indexed, we

26958
28:06:36.101 --> 28:06:39.101
can start testing it out using
the graphical interface directly

26959
28:06:39.101 --> 28:06:43.101
in the graph dashboard. When
we're ready to start queering,

26960
28:06:43.101 --> 28:06:45.101
our sub graph from our
application, we can use the API

26961
28:06:45.101 --> 28:06:48.101
URL that's been given to us by
the graph along with any Graph

26962
28:06:48.101 --> 28:06:53.101
QL query. If you'd like to learn
more about the graph, check out

26963
28:06:53.101 --> 28:06:57.101
the graph.com as well as Graph
Protocol, Twitter, the docs at

26964
28:06:57.101 --> 28:07:02.101
the graph.com/docs, or our
Discord at the graph.com/discord

26965
28:07:02.101 --> 28:07:04.101
Thanks matter. And now that we
have a better idea of what the

26966
28:07:04.101 --> 28:07:09.101
graph is, we can actually start
building with it. Now if we were

26967
28:07:09.101 --> 28:07:13.101
to try to run this app as it is,
it obviously would fail, right,

26968
28:07:13.101 --> 28:07:18.101
because index.js, right now is
reading from mirallas instead of

26969
28:07:18.101 --> 28:07:21.101
from the graph. So like it says
in our readme, first thing we're

26970
28:07:21.101 --> 28:07:24.101
going to need to do is we're
gonna need to index from the

26971
28:07:24.101 --> 28:07:28.101
graph, and then we can just this
project to read from the graph.

26972
28:07:28.101 --> 28:07:31.101
So let's go ahead and learn how
to build our sub graph. In order

26973
28:07:31.101 --> 28:07:35.101
for us to tell the graph network
to start indexing the events

26974
28:07:35.101 --> 28:07:39.101
from our contract, we're gonna
go to graph.com, we're gonna go

26975
28:07:39.101 --> 28:07:43.101
to products. And we're going to
go to sub graph studio, if you

26976
28:07:43.101 --> 28:07:46.101
go to products, the first thing
you see is the Graph Explorer,

26977
28:07:46.101 --> 28:07:49.101
these are already existing sub
graphs. And if you go through

26978
28:07:49.101 --> 28:07:52.101
here, you'll see a lot of
incredibly popular decentralized

26979
28:07:52.101 --> 28:07:55.101
protocols all have different sub
graphs, hosted service is going

26980
28:07:55.101 --> 28:07:57.101
to get discontinued at some
point. So we're going to skip

26981
28:07:57.101 --> 28:08:00.101
there. So let's go to sub graph
studio, this is going to help

26982
28:08:00.101 --> 28:08:03.101
enable us to create a sub graph
for other nodes to start

26983
28:08:03.101 --> 28:08:06.101
indexing our events. So we're
gonna go ahead and connect our

26984
28:08:06.101 --> 28:08:10.101
wallet with meta mask. And I'm
going to choose account one

26985
28:08:10.101 --> 28:08:15.101
here, next connect, and we're
going to want to switch off of

26986
28:08:15.101 --> 28:08:21.101
Hardhead. Local, over to the
Rinkeby test network. And I'll

26987
28:08:21.101 --> 28:08:23.101
go to Account one here. And
we're going to get a signature

26988
28:08:23.101 --> 28:08:27.101
request from the graph summary
to the website that we just

26989
28:08:27.101 --> 28:08:31.101
built. The subgraph website has
some signings functionality with

26990
28:08:31.101 --> 28:08:34.101
a database on the back end. So
we're seeing in real life,

26991
28:08:34.101 --> 28:08:38.101
exactly the methods that we just
used. So instead of signing with

26992
28:08:38.101 --> 28:08:41.101
Morales, they're just have their
own custom sign in here. So

26993
28:08:41.101 --> 28:08:44.101
we're gonna go ahead and sign in
so that the graph website knows

26994
28:08:44.101 --> 28:08:46.101
that it can interact with us.
And we can go ahead and enter

26995
28:08:46.101 --> 28:08:50.101
our email if we want. I'm gonna
go ahead and skip. And you'll

26996
28:08:50.101 --> 28:08:53.101
even get a little notification
here saying only subgraphs

26997
28:08:53.101 --> 28:08:56.101
indexing Aetherium or main net
or Rigby can be created in

26998
28:08:56.101 --> 28:09:00.101
subgraph studio. So let's go
ahead and create a subgraph. So

26999
28:09:00.101 --> 28:09:04.101
we're going to pick a cerium
Rigby and the subgraph name is

27000
28:09:04.101 --> 28:09:08.101
going to be NFT marketplace.
We'll go ahead and hit Continue.

27001
28:09:08.101 --> 28:09:11.101
Now, this is going to be our
dashboard for creating our sub

27002
28:09:11.101 --> 28:09:14.101
graph. And there's a ton of
instructions over here and

27003
28:09:14.101 --> 28:09:17.101
documentation that we can view
to get started, I'm going to add

27004
28:09:17.101 --> 28:09:20.101
this documentation to the GitHub
repo associated with this

27005
28:09:20.101 --> 28:09:24.101
course. So this NFT marketplace
sub graph is going to need its

27006
28:09:24.101 --> 28:09:27.101
own git repository itself. So
what we're going to do back in

27007
28:09:27.101 --> 28:09:30.101
here is we're going to CD down,
we're going to make a new

27008
28:09:30.101 --> 28:09:35.101
directory, and we're going to
call it graph. And if T

27009
28:09:35.101 --> 28:09:40.101
marketplace, FCC, we're going to
open that up as well. So code

27010
28:09:40.101 --> 28:09:46.101
graph NFT, marketplace, FCC, or
file open graft code marketplace

27011
28:09:46.101 --> 28:09:50.101
FCC, and in this window, we're
going to build our subgraph.

27012
28:09:50.101 --> 28:09:53.101
Locally, we're going to build
our subgraph and push it up to

27013
28:09:53.101 --> 28:09:56.101
the subgraph studio. And in
here, there's a whole bunch of

27014
28:09:56.101 --> 28:09:59.101
instructions that we can follow
along with to go ahead and

27015
28:09:59.101 --> 28:10:02.101
install. The first thing that we
need to do is install the graph

27016
28:10:02.101 --> 28:10:06.101
command line interface. And we
want to install this globally.

27017
28:10:06.101 --> 28:10:10.101
So I'm going to copy this part
here. Come back to my terminal

27018
28:10:10.101 --> 28:10:15.101
Oh, yarn, global ad and paste
that in. It's this command line

27019
28:10:15.101 --> 28:10:19.101
that's going to help us build a
graph and build instructions for

27020
28:10:19.101 --> 28:10:22.101
the graph to actually start
indexing our events. Now that

27021
28:10:22.101 --> 28:10:26.101
we've installed the globally, we
can initialize our graph code.

27022
28:10:26.101 --> 28:10:31.101
So we can copy this line. And
we'll run graph a knit dash dash

27023
28:10:31.101 --> 28:10:35.101
studio NFT marketplace and hit
enter. The protocol is going to

27024
28:10:35.101 --> 28:10:40.101
be Aetherium, or subgraph. Slug
will be NFT. marketplace. We

27025
28:10:40.101 --> 28:10:43.101
want the directory to be here,
but it's saying directory

27026
28:10:43.101 --> 28:10:46.101
already exists. So we'll just
give it NFT marketplace. And

27027
28:10:46.101 --> 28:10:49.101
then we'll move it after this.
And this is on the Rinkeby. Test

27028
28:10:49.101 --> 28:10:53.101
net. And now we want to give it
the contract address. So we want

27029
28:10:53.101 --> 28:10:56.101
to grab that address that we
just deployed. And it should be

27030
28:10:56.101 --> 28:10:59.101
now in our network mapping. So
we're going to grab that

27031
28:10:59.101 --> 28:11:04.101
contract address that we just
deployed, and paste it in here.

27032
28:11:04.101 --> 28:11:09.101
Like so. And since we've already
verified on ether scan, it

27033
28:11:09.101 --> 28:11:12.101
automatically grabs the ABI for
us from ether scan, we'll give

27034
28:11:12.101 --> 28:11:16.101
it the contract name, which is
the NFT marketplace. And it's

27035
28:11:16.101 --> 28:11:20.101
going to give us a whole bunch
of boilerplate code in this NFT

27036
28:11:20.101 --> 28:11:23.101
marketplace directory. And this
might take a couple of minutes.

27037
28:11:23.101 --> 28:11:26.101
Alright, awesome. So now that
it's done, we see subgraph NFT

27038
28:11:26.101 --> 28:11:30.101
marketplace created in NFT
marketplace. Now, I don't want

27039
28:11:30.101 --> 28:11:32.101
it to be in the seller folder.
So what I'm going to do is I'm

27040
28:11:32.101 --> 28:11:34.101
going to move it down a
directory, but you can leave it

27041
28:11:34.101 --> 28:11:38.101
where it is, if you want, I'm
going to say move, I'm going to

27042
28:11:38.101 --> 28:11:44.101
say move NFT marketplace, star
to dot slash. Now everything

27043
28:11:44.101 --> 28:11:47.101
inside of NFT marketplace will
be in this current directory.

27044
28:11:47.101 --> 28:11:50.101
And then if the marketplace will
be empty. So with that, I'm

27045
28:11:50.101 --> 28:11:53.101
gonna go ahead and delete. And
if the marketplace. Alright,

27046
28:11:53.101 --> 28:11:57.101
great. Now let me walk you
through exactly what's going on

27047
28:11:57.101 --> 28:12:00.101
here and what these files are
that we just created. So our

27048
28:12:00.101 --> 28:12:03.101
first folder is going to be
API's. In order for the graph to

27049
28:12:03.101 --> 28:12:06.101
index and read our contract
index our events, it's going to

27050
28:12:06.101 --> 28:12:11.101
need the ABI of our events. So
we've got the ABI of our entire

27051
28:12:11.101 --> 28:12:15.101
marketplace, from ether scan, if
we didn't verify an ether scan,

27052
28:12:15.101 --> 28:12:18.101
we can just create this API
folder ourself and add the NFT

27053
28:12:18.101 --> 28:12:22.101
marketplace JSON in here. Now we
have this generated folder. This

27054
28:12:22.101 --> 28:12:25.101
is an auto generated file. He
even says at the top, do not

27055
28:12:25.101 --> 28:12:29.101
edit this file directly. You can
kind of think of this as the

27056
28:12:29.101 --> 28:12:33.101
build folder, or where we
compile graph code. Node

27057
28:12:33.101 --> 28:12:35.101
modules, of course, is going to
be node modules and

27058
28:12:35.101 --> 28:12:40.101
dependencies. SRC is going to be
where we define and we tell the

27059
28:12:40.101 --> 28:12:43.101
graph, how to actually map and
how to actually work with our

27060
28:12:43.101 --> 28:12:47.101
contract. And it is a TypeScript
file. So for all of you who have

27061
28:12:47.101 --> 28:12:50.101
been just doing this in
JavaScript, I will have to teach

27062
28:12:50.101 --> 28:12:53.101
you a little bit of TypeScript
just to get through this part.

27063
28:12:53.101 --> 28:12:56.101
Then we have networks dot JSON,
which gives us all of our

27064
28:12:56.101 --> 28:12:59.101
network information about which
networks, what are the

27065
28:12:59.101 --> 28:13:01.101
addresses, and what are the
different contracts that we're

27066
28:13:01.101 --> 28:13:04.101
going to be indexing, package
dot JSON, which of course is

27067
28:13:04.101 --> 28:13:08.101
just a normal package dot JSON.
And it's got some graph scripts

27068
28:13:08.101 --> 28:13:12.101
already built in schema dot
graph. QL is going to be our

27069
28:13:12.101 --> 28:13:16.101
Graph QL schema. So this is also
going to be how we tell the

27070
28:13:16.101 --> 28:13:19.101
graph how to actually work with
our events and index our events.

27071
28:13:19.101 --> 28:13:22.101
And if you're familiar, the
schema follows the Graph QL

27072
28:13:22.101 --> 28:13:26.101
syntax. So if you've ever worked
with Graph QL, before, it's

27073
28:13:26.101 --> 28:13:30.101
going to be the exact same way,
graph. QL is a query language

27074
28:13:30.101 --> 28:13:33.101
for your API. And instead of
being kind of a relational

27075
28:13:33.101 --> 28:13:37.101
database, it can query in a more
graph type way, I'm not going to

27076
28:13:37.101 --> 28:13:40.101
go too deep into how it actually
works behind the scenes. But if

27077
28:13:40.101 --> 28:13:42.101
you want to learn more, I'm
going to leave some docs in the

27078
28:13:42.101 --> 28:13:45.101
GitHub repository associated
with this course, the sub graph

27079
28:13:45.101 --> 28:13:48.101
dot Yamo tells our subgraph how
to combine all the files

27080
28:13:48.101 --> 28:13:51.101
together. So we have data
sources, data sources, where

27081
28:13:51.101 --> 28:13:54.101
they're coming from different
addresses, different entities or

27082
28:13:54.101 --> 28:13:58.101
events, the API's where to grab
our files from different event

27083
28:13:58.101 --> 28:14:01.101
handlers, which we'll talk about
in a minute. And then the main

27084
28:14:01.101 --> 28:14:04.101
file, which is going to be our
mapping.ts, we have a TS config,

27085
28:14:04.101 --> 28:14:08.101
which is a configuration file
specific to TypeScript. And then

27086
28:14:08.101 --> 28:14:11.101
of course, we have our yarn dot
lock. With all this information

27087
28:14:11.101 --> 28:14:15.101
with all this code, we are now
going to update all this code to

27088
28:14:15.101 --> 28:14:20.101
tell the graph to start indexing
our events. So we can read our

27089
28:14:20.101 --> 28:14:22.101
events from the graph in a
decentralized context, as

27090
28:14:22.101 --> 28:14:26.101
opposed to from a centralized
database. And after we build

27091
28:14:26.101 --> 28:14:29.101
everything, we're going to run
through this off and deploy

27092
28:14:29.101 --> 28:14:32.101
code, which is to authenticate
ourselves, and then deploy our

27093
28:14:32.101 --> 28:14:36.101
code to the graph to start
indexing. So without further

27094
28:14:36.101 --> 28:14:40.101
ado, let's jump in. And let's do
this. So one of the first things

27095
28:14:40.101 --> 28:14:43.101
I'm going to do, I'm going to
add a highlighter for these dot

27096
28:14:43.101 --> 28:14:46.101
Graph QL files. So in our
extensions, we're gonna look at

27097
28:14:46.101 --> 28:14:51.101
Graph QL. And we're gonna stall
this Graph QL extension. Now

27098
28:14:51.101 --> 28:14:54.101
that we've installed it, if we
go back to schema dot graph, QL,

27099
28:14:54.101 --> 28:14:57.101
we've got it with some colors
now, which is exciting. So this

27100
28:14:57.101 --> 28:15:02.101
schema dot Graph QL is going to
define what entities we have in

27101
28:15:02.101 --> 28:15:06.101
our contract if we were to be
analogous to mirallas. These are

27102
28:15:06.101 --> 28:15:08.101
going to be how we're going to
define what our tables are going

27103
28:15:08.101 --> 28:15:10.101
to look like. And these are
going to be our events. plus

27104
28:15:10.101 --> 28:15:14.101
that active item table that we
created. So we're not going to

27105
28:15:14.101 --> 28:15:18.101
have an example entity though,
we're going to have a type

27106
28:15:18.101 --> 28:15:22.101
active item. And this is going
to be an add entity. So these

27107
28:15:22.101 --> 28:15:25.101
are the different types we have
in our graph that we can

27108
28:15:25.101 --> 28:15:27.101
actually query on, our main
thing that we're going to want

27109
28:15:27.101 --> 28:15:31.101
to query on is same as before,
it's going to be our active

27110
28:15:31.101 --> 28:15:33.101
items. And then inside of our
active items, we're going to

27111
28:15:33.101 --> 28:15:37.101
tell the graph, what parameters
each one of these active item

27112
28:15:37.101 --> 28:15:42.101
types has, well, it's going to
have an ID of type ID. So the

27113
28:15:42.101 --> 28:15:45.101
variable is ID of type ID. And
you can read more about the

27114
28:15:45.101 --> 28:15:48.101
different types in the graph
documentation. And this

27115
28:15:48.101 --> 28:15:53.101
exclamation mark means it must
have an ID. So every active item

27116
28:15:53.101 --> 28:15:56.101
needs to have and will have an
ID, we'll say there's going to

27117
28:15:56.101 --> 28:15:59.101
be a buyer, which is going to be
an address, so that's going to

27118
28:15:59.101 --> 28:16:03.101
be a byte and the buyer could be
blank, right? It could be the

27119
28:16:03.101 --> 28:16:08.101
0x 000, we're going to have all
of our active items have a

27120
28:16:08.101 --> 28:16:13.101
0000 dot.if. If no one has
bought yet, we're going to have

27121
28:16:13.101 --> 28:16:16.101
a seller, which of course is
also going to be a bytes because

27122
28:16:16.101 --> 28:16:19.101
it's going to be an address,
we're going to have an NFT

27123
28:16:19.101 --> 28:16:22.101
address. So the address of the
NFT, which will also be bytes,

27124
28:16:22.101 --> 28:16:25.101
we're going to have a token ID
which isn't going to be bytes,

27125
28:16:25.101 --> 28:16:28.101
this is going to be of type big
int, and then we're going to

27126
28:16:28.101 --> 28:16:32.101
have a price, which is also
going to be a big int. Now price

27127
28:16:32.101 --> 28:16:35.101
we're going to leave as not
required for price, we're just

27128
28:16:35.101 --> 28:16:39.101
going to have price be nullable.
So price can be null. So we have

27129
28:16:39.101 --> 28:16:42.101
an active item. Awesome. What
else are we going to need? What

27130
28:16:42.101 --> 28:16:44.101
what other tables do we have in
Morales? Well, we're going to

27131
28:16:44.101 --> 28:16:50.101
need type item listed. And this
is going to be at entity is

27132
28:16:50.101 --> 28:16:54.101
going to need an ID, it'll have
a seller. Whenever an item gets

27133
28:16:54.101 --> 28:16:57.101
listed, it's going to have a
seller right, which is going to

27134
28:16:57.101 --> 28:17:00.101
be a bytes again. And if the
address the address of the NFT,

27135
28:17:00.101 --> 28:17:05.101
which will also be bytes, the
token ID, which is going to be a

27136
28:17:05.101 --> 28:17:09.101
big int, and then the price,
which will also be a big end,

27137
28:17:09.101 --> 28:17:15.101
we're gonna need a type item
cancelled at entity

27138
28:17:15.101 --> 28:17:28.101
which will have an ID seller an
NFT address. And a token ID will

27139
28:17:28.101 --> 28:17:34.101
be a big end. And then last type
item bought will be in that

27140
28:17:34.101 --> 28:17:41.101
entity is going to have an ID
ID. It's going to be a buyer

27141
28:17:41.101 --> 28:17:43.101
bytes.

27142
28:17:43.101 --> 28:17:53.101
And then of T address a bytes
and a token ID again, and then a

27143
28:17:53.101 --> 28:17:56.101
price of beginnt. And with
Justice Information, we've

27144
28:17:56.101 --> 28:18:00.101
defined what we want our
subgraph to keep track of wants

27145
28:18:00.101 --> 28:18:03.101
to keep track of item bought
events, item, cancelled events,

27146
28:18:03.101 --> 28:18:07.101
item listed events. And then
we're going to make this new

27147
28:18:07.101 --> 28:18:10.101
active item table similar to
what we did with mirallas. And

27148
28:18:10.101 --> 28:18:13.101
it's going to be some function
of these these other three

27149
28:18:13.101 --> 28:18:17.101
events. And now we're done with
our schema dot graph. QL.

27150
28:18:17.101 --> 28:18:20.101
Awesome. So what do we do now
we're going to need to tell our

27151
28:18:20.101 --> 28:18:24.101
sub graph to actually listen for
these events. So what we can do.

27152
28:18:24.101 --> 28:18:27.101
So what we want to do to tell it
how to listen for these events,

27153
28:18:27.101 --> 28:18:33.101
is we're going to go to src
mapping.ts. It's this mapping.ts

27154
28:18:33.101 --> 28:18:37.101
file that's going to tell our
subgraph how to actually map and

27155
28:18:37.101 --> 28:18:40.101
how to actually store all the
event information that we have.

27156
28:18:40.101 --> 28:18:43.101
If you look in it right now, it
might even give you kind of a

27157
28:18:43.101 --> 28:18:47.101
sample event. So it says Export
function, handle item event.

27158
28:18:47.101 --> 28:18:49.101
This is what Maya says right
now, it takes as an input

27159
28:18:49.101 --> 28:18:54.101
parameter event item bot. So
this is saying whenever an item

27160
28:18:54.101 --> 28:18:59.101
bot event occurs, do this handle
item bot function. So anytime

27161
28:18:59.101 --> 28:19:02.101
item bot happens do this handle
item bot. And we're actually

27162
28:19:02.101 --> 28:19:07.101
getting this item bot from our
generated NFT marketplace from

27163
28:19:07.101 --> 28:19:12.101
some generated code. In the
graph. If we run graph code Gen.

27164
28:19:12.101 --> 28:19:16.101
This graph code Gen command
grabs all the stuff we have in

27165
28:19:16.101 --> 28:19:20.101
the schema dot Graph QL and puts
it in this generated file. Now

27166
28:19:20.101 --> 28:19:23.101
that I've run graph code Gen,
you'll see in here there's an

27167
28:19:23.101 --> 28:19:26.101
item bot class, you see there's
a schema, that type script. And

27168
28:19:27.101 --> 28:19:31.101
actually we can even find that
new active item class that we

27169
28:19:31.101 --> 28:19:35.101
created in our schema. So
anytime you update schema dot

27170
28:19:35.101 --> 28:19:39.101
Graph QL, you're always going to
want to run graph code Gen, so

27171
28:19:39.101 --> 28:19:42.101
you can update those types. And
if this failed, it means that

27172
28:19:42.101 --> 28:19:44.101
you messed up something in your
schema dot Graph QL. Now in our

27173
28:19:45.101 --> 28:19:48.101
mapping.ts, we're actually
importing item bought item

27174
28:19:48.101 --> 28:19:53.101
cancelled item listed from
generated and if the marketplace

27175
28:19:53.101 --> 28:19:56.101
and if the marketplace from our
generated code. These are going

27176
28:19:56.101 --> 28:19:59.101
to be our events. And we're not
going to need to do anything

27177
28:19:59.101 --> 28:20:01.101
with the NFT marketplace. We're
just going to need our event

27178
28:20:01.101 --> 28:20:04.101
information. For now. Let's go
ahead and just delete everything

27179
28:20:04.101 --> 28:20:09.101
inside our handle item bot or
whatever sample is given to you.

27180
28:20:09.101 --> 28:20:13.101
So we're importing a or events
from our generated code. And

27181
28:20:13.101 --> 28:20:16.101
then we have this line here,
which we're going to change in a

27182
28:20:16.101 --> 28:20:19.101
second. So again, we have these
three functions handle item

27183
28:20:19.101 --> 28:20:22.101
bought, handle item canceled and
handle item listed. Whenever we

27184
28:20:22.101 --> 28:20:25.101
get an item bought event, we're
going to do this function.

27185
28:20:25.101 --> 28:20:27.101
Whenever we get an item canceled
event, we're going to do this

27186
28:20:27.101 --> 28:20:32.101
function. And all this code is
defined in our sub graph dot

27187
28:20:32.101 --> 28:20:35.101
Yamo. You can see the different
entities here in a bot item

27188
28:20:35.101 --> 28:20:39.101
cancelled item listed, and the
event handlers. So it says,

27189
28:20:39.101 --> 28:20:45.101
okay, anytime this specific
event gets fired with an index

27190
28:20:45.101 --> 28:20:49.101
address, an index address index,
YouTube 36 in YouTube had six

27191
28:20:49.101 --> 28:20:52.101
call handle item bought, which
again, we're getting in here

27192
28:20:52.101 --> 28:20:56.101
handle item. But so that's
exactly how this works. So let's

27193
28:20:56.101 --> 28:21:00.101
figure out what to do when an
item bought event triggers. And

27194
28:21:00.101 --> 28:21:03.101
I think that item bought item
cancelled item lists it is a

27195
28:21:03.101 --> 28:21:08.101
little confusing. So I like to
change this to item bought as

27196
28:21:08.101 --> 28:21:16.101
item bought event item cancelled
as item cancelled event item

27197
28:21:16.101 --> 28:21:22.101
listed as item listed event. So
I'm just changing the names of

27198
28:21:22.101 --> 28:21:26.101
these three that are imported
from NFT marketplace. And now

27199
28:21:26.101 --> 28:21:30.101
I'm going to change event item
bot to item bought event. Event

27200
28:21:30.101 --> 28:21:33.101
item cancelled to item cancelled
event and event item listed to

27201
28:21:33.101 --> 28:21:37.101
item listed event. Okay, great.
And we're just going to remove

27202
28:21:37.101 --> 28:21:39.101
this line for now. And we also
don't need this line at the top

27203
28:21:39.101 --> 28:21:42.102
at the beginning, we will in a
minute, but we'll delete it for

27204
28:21:42.102 --> 28:21:46.102
now. So here's our minimalistic
code here. So whenever we list

27205
28:21:46.102 --> 28:21:50.102
an item, what do we need to do?
Well, we need to save that event

27206
28:21:50.102 --> 28:21:54.102
in our in our graph. And then we
also need to update our active

27207
28:21:54.102 --> 28:21:58.102
item, exactly as we did with
Morales. So first thing that

27208
28:21:58.102 --> 28:22:01.102
we're going to need to do is
either get or create an item

27209
28:22:01.102 --> 28:22:04.102
listed object. And something
that we need to know is that

27210
28:22:04.102 --> 28:22:09.102
each item needs a unique ID. And
we actually need to create that

27211
28:22:09.102 --> 28:22:12.102
ID. So one of the first things
I'm going to do is going to

27212
28:22:12.102 --> 28:22:18.102
create a function called Get ID
from event params. And it's

27213
28:22:18.102 --> 28:22:20.102
going to take a token ID and
here's where TypeScript comes

27214
28:22:20.102 --> 28:22:23.102
into play a little bit. In
TypeScript, we actually need to

27215
28:22:23.102 --> 28:22:26.102
define the types of our
different parameters. So token

27216
28:22:26.102 --> 28:22:31.102
ID is going to be a big int. And
we'll also take an NFT address,

27217
28:22:31.102 --> 28:22:35.102
which will take in a type of
address. And we also need to say

27218
28:22:35.102 --> 28:22:38.102
what return type or function is
going to give, which we're going

27219
28:22:38.102 --> 28:22:42.102
to return a string, we're going
to create an ID from event

27220
28:22:42.102 --> 28:22:45.102
params. And it's just going to
be a combination of the token ID

27221
28:22:45.102 --> 28:22:48.102
and the NFT address. The
combination of these two will

27222
28:22:48.102 --> 28:22:52.102
give a unique ID for each one of
these types of event. So we're

27223
28:22:52.102 --> 28:22:56.102
just gonna say return token ID,
and token ID has a function

27224
28:22:56.102 --> 28:23:03.102
called to x string, I'm gonna
say plus, and if T address.to X

27225
28:23:03.102 --> 28:23:08.102
string, like so. And big int an
address, we need to import from

27226
28:23:08.102 --> 28:23:11.102
at Graph Protocol slash graph
TX. It already imported big

27227
28:23:11.102 --> 28:23:14.102
enough for me. So I'm just going
to add address in here is the

27228
28:23:15.102 --> 28:23:17.102
two special types that come from
the graph. And then string is

27229
28:23:17.102 --> 28:23:20.102
built into TypeScript. Now that
we have a way to get a special

27230
28:23:20.102 --> 28:23:25.102
ID for each item in our function
here, we have to now either get

27231
28:23:25.102 --> 28:23:30.102
or create a new item listed. Now
right now we have an item. But

27232
28:23:30.102 --> 28:23:34.102
event we don't have an item
bought object. So the item

27233
28:23:34.102 --> 28:23:38.102
bought object is going to be
what we save, the item bought

27234
28:23:38.102 --> 28:23:42.102
event is just the raw event. So
we have to create an item bought

27235
28:23:42.102 --> 28:23:46.102
object from our item bought
event. And in TypeScript, these

27236
28:23:46.102 --> 28:23:49.102
are going to be two different
types. So we have to import

27237
28:23:49.102 --> 28:23:53.102
these item by objects. So those
actually get auto created from

27238
28:23:53.102 --> 28:23:57.102
generated schema. In here we
have active item, we have item,

27239
28:23:57.102 --> 28:24:02.102
we have an item bought class, we
have an item cancelled, etc. So

27240
28:24:02.102 --> 28:24:05.102
we're gonna have to import those
types from there. So we can say,

27241
28:24:05.102 --> 28:24:12.102
import, item listed, comma,
active item, item bought an item

27242
28:24:12.102 --> 28:24:18.102
cancelled from dot slash,
generated slash schema. Let's go

27243
28:24:18.102 --> 28:24:23.102
ahead and get or create an item
bot object. So we'll say let

27244
28:24:23.102 --> 28:24:30.102
item bot equals item bot dot
load. And this is how we load an

27245
28:24:30.102 --> 28:24:34.102
item we load its unique ID by
calling this get ID from event

27246
28:24:34.102 --> 28:24:41.102
params dot load, get ID from
event params. And we can pass

27247
28:24:42.102 --> 28:24:46.102
event dot params. That token ID

27248
28:24:46.102 --> 28:24:50.102
because an item bot event is
going to have a token ID and

27249
28:24:50.102 --> 28:24:55.102
event that params.nf T address.
Now I know we probably should

27250
28:24:55.102 --> 28:24:58.102
have done handle item listed
first but we're doing item bot

27251
28:24:58.102 --> 28:25:02.102
first. Since we're buying an
item, we probably will also have

27252
28:25:02.102 --> 28:25:05.102
an active item as well, right?
We haven't made yet an item

27253
28:25:05.102 --> 28:25:07.102
listed. But this is going to be
similar to what we did with

27254
28:25:07.102 --> 28:25:11.102
Morales. So we know that every
time we live Certain items will

27255
28:25:11.102 --> 28:25:17.102
also list an active item. So
we'll say let active item equals

27256
28:25:17.102 --> 28:25:21.102
active item that load. And we're
going to do this exact same

27257
28:25:21.102 --> 28:25:25.102
thing. So I'm just going to copy
paste it into here. And even

27258
28:25:25.102 --> 28:25:28.102
though these are going to have
the exact same ID, it doesn't

27259
28:25:28.102 --> 28:25:32.102
matter because they're the same
ID across different types. Now

27260
28:25:33.102 --> 28:25:38.102
we're gonna say, if there is no
item bot, we'll say item bot

27261
28:25:38.102 --> 28:25:45.102
equals a new item bot object.
And we'll give it an ID, which

27262
28:25:45.102 --> 28:25:49.102
is going to be exactly our ID
giving parameter here, get ID

27263
28:25:49.102 --> 28:25:52.102
from events, and pass that
there. So we're going to create

27264
28:25:52.102 --> 28:25:55.102
a new item bought here. And now
we're going to update all its

27265
28:25:55.102 --> 28:25:59.102
parameters. So back in our
schema dot graph, QL. An item

27266
28:25:59.102 --> 28:26:03.102
bought has an ID, buyer address,
token ID and price. So we're

27267
28:26:03.102 --> 28:26:10.102
gonna say, item bought, that
buyer equals event dot params

27268
28:26:10.102 --> 28:26:18.102
dot buyer, item bought.nf T
address equals event.params.nf T

27269
28:26:18.102 --> 28:26:25.102
address, item bot, dot token ID
equals event dot params dot

27270
28:26:25.102 --> 28:26:28.102
token ID. And that looks good.
And our active item will be from

27271
28:26:28.102 --> 28:26:32.102
item listed, and item listed
should give it all these

27272
28:26:32.102 --> 28:26:35.102
parameters, except for it won't
have a buyer. So we just need to

27273
28:26:35.102 --> 28:26:40.102
update the buyer on our active
item. So we'll say active item,

27274
28:26:40.102 --> 28:26:43.102
dot buyer, we'll do a little
exclamation mark. This is some

27275
28:26:43.102 --> 28:26:46.102
TypeScript stuff, saying we will
have an active item. Don't worry

27276
28:26:46.102 --> 28:26:48.102
too much about it if you're
unfamiliar with TypeScript. And

27277
28:26:48.102 --> 28:26:53.102
we'll say that equals event dot
params dot buyer. And now

27278
28:26:53.102 --> 28:26:58.102
similar to Morales, we're gonna
do item bot dot save and active

27279
28:26:58.102 --> 28:27:02.102
item with an exclamation mark
again, that save and this is how

27280
28:27:02.102 --> 28:27:06.102
we're going to save this item
bought event as an object in our

27281
28:27:06.102 --> 28:27:09.102
the Graph Protocol. And also,
we're going to update our active

27282
28:27:09.102 --> 28:27:13.102
item. So this is our full
function of handle item bought.

27283
28:27:13.102 --> 28:27:16.102
Whenever somebody buys an item,
we update a new item bought

27284
28:27:16.102 --> 28:27:21.102
object, and we update our active
item to be a new buyer, we're

27285
28:27:21.102 --> 28:27:24.102
not going to delete it from our
active items list, we're just

27286
28:27:24.102 --> 28:27:27.102
going to update it with a new
buyer. And we'll just say if it

27287
28:27:27.102 --> 28:27:30.102
has a buyer, that means it's
been bought. If it doesn't have

27288
28:27:30.102 --> 28:27:34.102
a buyer, that means it's still
on the market. Awesome. So now

27289
28:27:34.102 --> 28:27:37.102
that we've done our handle item
bot, let's now do our handle

27290
28:27:37.102 --> 28:27:39.102
item listed, which will
hopefully make our handle item

27291
28:27:39.102 --> 28:27:42.102
bot a little bit easier to
understand. So for handle item

27292
28:27:42.102 --> 28:27:45.102
listed, we're going to do the
same piece here. So we're going

27293
28:27:45.102 --> 28:27:51.102
to say let item listed equals
item listed dot load. And we're

27294
28:27:51.102 --> 28:27:55.102
gonna do the exact same thing as
what we did for all these will

27295
28:27:55.102 --> 28:27:59.102
do get ID from event params.
Like so, get a different event

27296
28:27:59.102 --> 28:28:03.102
params. And we're gonna say let
active item. And this line is

27297
28:28:03.102 --> 28:28:07.102
going to be exactly the same as
up here. So I'm just going to

27298
28:28:07.102 --> 28:28:11.102
copy paste. So we're saying,
okay, great, grab our item

27299
28:28:11.102 --> 28:28:14.102
listed, and grab our active
item, see if those objects

27300
28:28:14.102 --> 28:28:18.102
already exist. I will say if
there is no item listed, which

27301
28:28:18.102 --> 28:28:20.102
there shouldn't be, we'll go
ahead and create a new one,

27302
28:28:20.102 --> 28:28:23.102
we'll say item listed

27303
28:28:23.102 --> 28:28:28.102
equals new item listed. And its
ID is going to be from this

27304
28:28:28.102 --> 28:28:32.102
function that we created are
unique IDs. Now, unlike what we

27305
28:28:32.102 --> 28:28:37.102
did above, we're also going to
say, if there is no active item,

27306
28:28:37.102 --> 28:28:39.102
then we're going to create a new
active item, right? Because

27307
28:28:39.102 --> 28:28:42.102
we're listing an item, it
shouldn't be an active item. Now

27308
28:28:42.102 --> 28:28:44.102
this functionality is going to
make a lot more sense here,

27309
28:28:44.102 --> 28:28:47.102
right? Because if we're updating
the price of an item, active

27310
28:28:47.102 --> 28:28:51.102
item will already exist. If it's
a brand new listing, though,

27311
28:28:51.102 --> 28:28:55.102
active item will not exist. So
we'll say okay, if it doesn't

27312
28:28:55.102 --> 28:28:58.102
exist, okay, that means it's a
brand new listing, we'll say

27313
28:28:58.102 --> 28:29:03.102
item listed equals new item
listed, and then we'll give it

27314
28:29:03.102 --> 28:29:08.102
an ID. That's the same ID
methodology, paste that in. So

27315
28:29:08.102 --> 28:29:13.102
now all we got to do is update
these new objects. So I will say

27316
28:29:13.102 --> 28:29:19.102
item listed that seller equals
event dot params dot seller. And

27317
28:29:19.102 --> 28:29:22.102
I'm just going to copy paste
this line. Because this is just

27318
28:29:22.102 --> 28:29:27.102
gonna be active item dot seller
now. Oops, see me and then it'll

27319
28:29:27.102 --> 28:29:31.102
make this active item. active
item instead of item listed. And

27320
28:29:31.102 --> 28:29:33.102
what else comes with item
listed? Well, let's go to the

27321
28:29:33.102 --> 28:29:38.102
schema item listed has an NFT
address, token ID and a price.

27322
28:29:38.102 --> 28:29:45.102
So okay, so let's add those.
item listed dot NFT address

27323
28:29:45.102 --> 28:29:50.102
equals event.params.nf T
address. Copy paste this line

27324
28:29:50.102 --> 28:29:55.102
because it's gonna be the be the
exact same for active item. Now

27325
28:29:55.102 --> 28:30:02.102
item listed that token ID equals
event dot params dot token ID.

27326
28:30:02.102 --> 28:30:07.102
Copy paste this line. Same thing
for active item. Item listed dot

27327
28:30:07.102 --> 28:30:12.102
price equals event dot params
dot At price, copy, paste this

27328
28:30:12.102 --> 28:30:17.102
line for active item. And then
we just say those two. So item

27329
28:30:17.102 --> 28:30:25.102
listed that save active item.
Save. So in our protocol here,

27330
28:30:25.102 --> 28:30:28.102
if it's already been, if there
already is an active item, then

27331
28:30:28.102 --> 28:30:31.102
we just go ahead and we get that
active item. This would be for a

27332
28:30:31.102 --> 28:30:35.102
listing that we're updating. If
not, we make a new one. We

27333
28:30:35.102 --> 28:30:38.102
update it with whatever came in
through the event. And then we

27334
28:30:38.102 --> 28:30:42.102
save it to our graph protocol.
Okay, perfect. Now we only have

27335
28:30:42.102 --> 28:30:45.102
one left, item cancelled. So
let's figure out how to do item

27336
28:30:45.102 --> 28:30:48.102
cancelled, it's going to look
really similar to item bought.

27337
28:30:48.102 --> 28:30:55.102
So we'll say let item cancelled
equals item cancelled that load.

27338
28:30:55.102 --> 28:30:58.102
Again, we're going to do this
exact same Id get our that we're

27339
28:30:58.102 --> 28:31:03.102
doing for everything, we'll say
let active item equals, and I'm

27340
28:31:03.102 --> 28:31:08.102
going to zoom out a little bit
less active item equals active

27341
28:31:08.102 --> 28:31:14.102
item dot load. Or do this exact
same thing here. Boom. And then

27342
28:31:14.102 --> 28:31:20.102
we're gonna say, if not item
cancelled, which there shouldn't

27343
28:31:20.102 --> 28:31:23.102
be because this should be the
only item canceled event here.

27344
28:31:23.102 --> 28:31:30.102
We'll say item cancelled, equals
new item cancelled. And we're

27345
28:31:30.102 --> 28:31:33.102
gonna give it an ID using the
same ID methodology we've been

27346
28:31:33.102 --> 28:31:36.102
using. Now this is going to look
a little bit different. We're

27347
28:31:36.102 --> 28:31:41.102
gonna say item canceled, that
seller equals event dot params

27348
28:31:41.102 --> 28:31:47.102
dot seller. So far, so good.
Item canceled dot NFT address

27349
28:31:47.102 --> 28:31:52.102
equals event dot params dot NFT
Address item canceled dot token

27350
28:31:52.102 --> 28:31:58.102
ID equals event dot params dot
token ID. And then finally, we

27351
28:31:58.102 --> 28:32:00.102
are going to change the active
item a little bit different than

27352
28:32:00.102 --> 28:32:04.102
what we've seen. active item
exclamation mark again, ignore

27353
28:32:04.102 --> 28:32:08.102
if you're confused by that dot
buyer. And we're going to update

27354
28:32:08.102 --> 28:32:13.102
the buyer to equal address dot
from string.

27355
28:32:13.102 --> 28:32:16.102
We're going to give it what's
called the Dead address. And

27356
28:32:16.102 --> 28:32:22.102
that's this right here.
0x 1-234-567-8910 1112 1314

27357
28:32:22.102 --> 28:32:25.102
producing 718 1920 21 to two to
three to 45 to 67 to

27358
28:32:25.102 --> 28:32:34.102
8930 3130 230-334-3536 zeros
lowercase d, uppercase E,

27359
28:32:34.102 --> 28:32:38.102
lowercase A uppercase D, this is
known as the dead address. And

27360
28:32:38.102 --> 28:32:41.102
this is how we're going to
decide if an item is still on

27361
28:32:41.102 --> 28:32:45.102
the marketplace or not. Or if an
item has been bought or not. If

27362
28:32:45.102 --> 28:32:49.102
we have the dead address as its
buyer, that's going to mean that

27363
28:32:49.102 --> 28:32:51.102
the item has been cancelled. And
that's how we are going to be

27364
28:32:51.102 --> 28:32:54.102
able to tell that an item is on
the marketplace or not dead

27365
28:32:54.102 --> 28:32:58.102
address means it's been
cancelled. An empty address,

27366
28:32:58.102 --> 28:33:01.102
which is what will happen for
handle item listed means it's on

27367
28:33:01.102 --> 28:33:05.102
the market. And an actual real
address means that it's actually

27368
28:33:05.102 --> 28:33:07.102
been bought by somebody. So the
way we can tell if it's on the

27369
28:33:07.102 --> 28:33:12.102
market is it's 0x 0000000.
Because the data address is

27370
28:33:12.102 --> 28:33:15.102
obviously going to be different
than than all zeros. The data

27371
28:33:15.102 --> 28:33:18.102
address is a commonly used
address kind of as a burner

27372
28:33:18.102 --> 28:33:22.102
address that nobody owns, then
we can just say, item cancelled

27373
28:33:22.102 --> 28:33:28.102
that save an active item that
say active item, exclamation

27374
28:33:28.102 --> 28:33:33.102
mark dot save and perfect. Our
mapping file is now completed.

27375
28:33:33.102 --> 28:33:36.102
We now have three different
functions to define how to

27376
28:33:36.102 --> 28:33:39.102
handle when items are bought
events, how to handle when items

27377
28:33:39.102 --> 28:33:43.102
are cancelled event and item
listed events. And if you're

27378
28:33:43.102 --> 28:33:46.102
confused, remember all the code
for this is available on this

27379
28:33:46.102 --> 28:33:49.102
the graph section of my GitHub.
So you can just follow along

27380
28:33:49.102 --> 28:33:52.102
with the code here, if you ever
get lost or need help. And with

27381
28:33:52.102 --> 28:33:55.102
that, we're almost ready to tell
our subgraph to start listening

27382
28:33:55.102 --> 28:33:58.102
to our contracts, there's just
at least one more thing that we

27383
28:33:58.102 --> 28:34:03.102
want to do. So in our sub graph
dot Yamo, we'll see source

27384
28:34:03.102 --> 28:34:06.102
address blah, blah, blah, this
is telling us to start indexing

27385
28:34:06.102 --> 28:34:10.102
events since the beginning of
Aetherium. Now we don't really

27386
28:34:10.102 --> 28:34:13.102
want it to do that, because it
will take a really long time, we

27387
28:34:13.102 --> 28:34:15.102
want to tell our subgraph Hey,
you don't just start from

27388
28:34:15.102 --> 28:34:19.102
beginning of time, you just need
to start from right before our

27389
28:34:19.102 --> 28:34:22.102
contract was deployed. So we can
add what's called our start

27390
28:34:22.102 --> 28:34:26.102
block to tell it what block
number to start deploying. Now

27391
28:34:26.102 --> 28:34:30.102
if we have our address, which we
do right here, we can copy it,

27392
28:34:30.102 --> 28:34:35.102
we can paste it on to the rink
fee, ether scan, paste it in

27393
28:34:35.102 --> 28:34:38.102
here, or really any block
Explorer, and we'll see what

27394
28:34:38.102 --> 28:34:42.102
block number our contract was
deployed. And it looks like it

27395
28:34:42.102 --> 28:34:46.102
was this block. So I'm going to
copy that address, go back to my

27396
28:34:46.102 --> 28:34:50.102
code and say starting block,
it's going to be right here.

27397
28:34:50.102 --> 28:34:55.102
Starting block is going to be
when it was deployed, minus one.

27398
28:34:55.102 --> 28:34:58.102
So we're gonna go right before
we deployed our contract, we're

27399
28:34:58.102 --> 28:35:02.102
going to start reading any event
that is indexed from it. Now if

27400
28:35:02.102 --> 28:35:05.102
you just deployed this, it might
not have any events in it at

27401
28:35:05.102 --> 28:35:08.102
all, which we're going to fix in
just a minute so don't worry,

27402
28:35:08.102 --> 28:35:10.102
but with that all the
instructions for how to build

27403
28:35:10.102 --> 28:35:14.102
Our sub graphs are ready to be
deployed to the graph, start our

27404
28:35:14.102 --> 28:35:16.102
indexing and start working with
our instructions in a

27405
28:35:16.102 --> 28:35:22.102
decentralized context. So what
we can do now is back in the

27406
28:35:22.102 --> 28:35:27.102
graph, we actually have the auth
and deploy code right here, we

27407
28:35:27.102 --> 28:35:32.102
can copy this, this graph auth
dash dash studio, which is our

27408
28:35:32.102 --> 28:35:35.102
deploy key on how to deploy. And
we can run this in our code

27409
28:35:35.102 --> 28:35:39.102
editor. So we're going to paste
that in here, graph off dash

27410
28:35:39.102 --> 28:35:43.102
studio, hit enter. And we're
gonna say deploy key set for the

27411
28:35:43.102 --> 28:35:46.102
graph. So this is just setting
us up so that whenever we push

27412
28:35:46.102 --> 28:35:49.102
our code, it's going to push it
to this sub graph configuration

27413
28:35:49.102 --> 28:35:52.102
that we've made on their site to
help us deploy automatically.

27414
28:35:52.102 --> 28:35:55.102
Now we can do, we don't need to
enter the subgraph, because

27415
28:35:55.102 --> 28:35:59.102
we've already moved stuff down,
is we'll build the sub graph,

27416
28:35:59.102 --> 28:36:04.102
we'll run graph code Gen, we can
just run graph kojem,

27417
28:36:04.102 --> 28:36:07.102
which again, is just going to
make sure our schema dot Graph

27418
28:36:07.102 --> 28:36:11.102
QL looks good. And then we're
going to run our graph build.

27419
28:36:11.102 --> 28:36:15.102
And this graph build command is
going to compile and run all of

27420
28:36:15.102 --> 28:36:18.102
our sub graph stuff, everything
in mapping that JSON all our

27421
28:36:18.102 --> 28:36:21.102
generated code. And it's going
to put this into a real build

27422
28:36:21.102 --> 28:36:24.102
folder, the generated folder has
kind of like a pseudo build

27423
28:36:24.102 --> 28:36:27.102
folder. And then we have a real
build folder. So the generated

27424
28:36:27.102 --> 28:36:30.102
is just to build some typings
for our TypeScript. And it's

27425
28:36:30.102 --> 28:36:33.102
this build folder, this real
build folder, is what we're

27426
28:36:33.102 --> 28:36:36.102
going to actually be deploying
and sending to the graph. And we

27427
28:36:36.102 --> 28:36:40.102
can actually deploy our
subgraph. Now, with graph deploy

27428
28:36:40.102 --> 28:36:43.102
dash s studio. And if the
marketplace, which we're going

27429
28:36:43.102 --> 28:36:46.102
to run right now, now is going
to give us a version label

27430
28:36:46.102 --> 28:36:50.102
option, which we're going to
give it the 0.0 point one, since

27431
28:36:51.102 --> 28:36:54.102
this is our first version, and
it goes ahead and starts

27432
28:36:54.102 --> 28:36:58.102
deploying it to the graph, we
also get to upload our sub graph

27433
28:36:58.102 --> 28:37:02.102
to IPFS. And we have a little
hash right here for IPFS for a

27434
28:37:02.102 --> 28:37:05.102
subgraph that we could look at.
But now if you're successful, we

27435
28:37:05.102 --> 28:37:09.102
now have this build completed
thing. And we have these sub

27436
28:37:09.102 --> 28:37:12.102
graph endpoints for queries and
subscriptions. So we can

27437
28:37:12.102 --> 28:37:16.102
actually start querying and
subscribing to our sub graph.

27438
28:37:16.102 --> 28:37:20.102
But if we go back to our site
here now and we hit refresh, we

27439
28:37:20.102 --> 28:37:24.102
can now see status deployed, we
can see that we're sinking. And

27440
28:37:24.102 --> 28:37:28.102
now we have some nodes that are
listening for our events to be

27441
28:37:28.102 --> 28:37:31.102
emitted here, which is
incredibly exciting. We can go

27442
28:37:31.102 --> 28:37:34.102
to logs to see if anything went
wrong. And right now it's just

27443
28:37:34.102 --> 28:37:37.102
indexing, it's listening. It's
going through all the different

27444
28:37:37.102 --> 28:37:40.102
blocks in the blockchain,
listening for our events. And

27445
28:37:40.102 --> 28:37:43.102
then we have a playground here
where we can run some queries to

27446
28:37:43.102 --> 28:37:46.102
see different events and the
different responses from our

27447
28:37:46.102 --> 28:37:50.102
Graph QL, which right now, it's
totally blank, because we

27448
28:37:50.102 --> 28:37:53.102
haven't done anything yet. So
once again, let's pull up our

27449
28:37:53.102 --> 28:37:57.102
hard hat and ft marketplace
code, or open it up in a new

27450
28:37:57.102 --> 28:38:00.102
terminal, whatever you want to
do. And let's go ahead, and

27451
28:38:00.102 --> 28:38:05.102
let's run our mminton list
script. But for rink B, so we'll

27452
28:38:05.102 --> 28:38:11.102
do yarn, hard hat, run scripts,
mint, and list item dash dash

27453
28:38:11.102 --> 28:38:16.102
network Rinkeby. So we're going
to mint an NF T, right, this is

27454
28:38:16.102 --> 28:38:17.102
going to be to transaction, so
we're gonna have to wait a

27455
28:38:17.102 --> 28:38:20.102
little bit, and then we're going
to approve the NFT. And then

27456
28:38:20.102 --> 28:38:22.102
we're going to list it on our
marketplace. And once it's

27457
28:38:22.102 --> 28:38:26.103
listed, it's going to emit an
item listed event. And we should

27458
28:38:26.103 --> 28:38:30.103
see now we have an active item
and an item listed data in our

27459
28:38:30.103 --> 28:38:34.103
Graph QL. Now you can learn more
about now what you see here on

27460
28:38:34.103 --> 28:38:37.103
the left hand side is what's
known as a Graph QL query. Now,

27461
28:38:37.103 --> 28:38:39.103
we're not going to go over how
to do these, but I'm going to

27462
28:38:39.103 --> 28:38:42.103
leave some links in the GitHub
repository. If you want to learn

27463
28:38:42.103 --> 28:38:44.103
how to do more of these queries,
these are going to be similar to

27464
28:38:44.103 --> 28:38:47.103
what we saw with Morales. But
instead of them being kind of

27465
28:38:47.103 --> 28:38:50.103
regular table lookups. They're
in Graph QL syntax, and the

27466
28:38:50.103 --> 28:38:53.103
results of our query, end up
being over here, we can see more

27467
28:38:53.103 --> 28:38:56.103
information about our schema all
the way to the right over here.

27468
28:38:56.103 --> 28:39:00.103
But if we look at our code, now,
we've made the NFT approved it

27469
28:39:00.103 --> 28:39:04.103
we've listed it on our
marketplace. So now if we go

27470
28:39:04.103 --> 28:39:09.103
back to the graph, and we run
this query, and we do a little

27471
28:39:09.103 --> 28:39:12.103
refresh on our NFT marketplace,
we might have to wait a few

27472
28:39:12.103 --> 28:39:15.103
minutes for the graph to index
these new blocks. But in our

27473
28:39:15.103 --> 28:39:19.103
playground, we should see the
show up as a query. If you don't

27474
28:39:19.103 --> 28:39:22.103
automatically get these you can
pause the video to write these

27475
28:39:22.103 --> 28:39:27.103
into your Graph QL playground,
right? So after a few minutes,

27476
28:39:27.103 --> 28:39:30.103
refresh on ether scan, I can see
that list item transaction has

27477
28:39:30.103 --> 28:39:34.103
gone through. This means we've
emitted a new event. So if I

27478
28:39:34.103 --> 28:39:38.103
come back to my playground, and
I hit play here, oh my goodness,

27479
28:39:38.103 --> 28:39:42.103
we can see we have active items.
And we see we have item listed.

27480
28:39:42.103 --> 28:39:46.103
This is fantastic. That means in
a decentralized context, we have

27481
28:39:46.103 --> 28:39:49.103
a off chain service that is
indexing our events for our

27482
28:39:49.103 --> 28:39:52.103
contract so that we can update
our front end and we can update

27483
28:39:52.103 --> 28:39:59.103
people in a decentralized way.
This is so exciting.

27484
28:39:59.103 --> 28:40:01.103
Awesome, so now that we have
this all set up, we can finally

27485
28:40:01.103 --> 28:40:07.103
go back to our next JS project
or next Jas NFT marketplace the

27486
28:40:07.103 --> 28:40:11.103
graph FCC. The reason we did all
this is because right Now in our

27487
28:40:11.103 --> 28:40:15.103
code base for our next Jas NFT
Marketplace application, we're

27488
28:40:15.103 --> 28:40:18.103
reading from a Morales database,
which we're not going to do

27489
28:40:18.103 --> 28:40:21.103
anymore. Instead of reading from
a Morales database, we're going

27490
28:40:21.103 --> 28:40:24.103
to read from the graph, let's go
ahead and learn how to update

27491
28:40:24.103 --> 28:40:29.103
our code our index dot j, s to
read from the graph instead. So

27492
28:40:29.103 --> 28:40:31.103
to highlight this, to show this,
we're actually going to create a

27493
28:40:31.103 --> 28:40:35.103
new page, a new file, and we're
just going to call it graph,

27494
28:40:35.103 --> 28:40:39.103
example, dot j, s. And we're
just gonna make this a really

27495
28:40:39.103 --> 28:40:43.103
minimalistic page to show you
how to do a graph query. So

27496
28:40:43.103 --> 28:40:49.103
similar to index dot j, s, we're
gonna do export default graph

27497
28:40:49.103 --> 28:40:53.103
example. It's going to be a
function, or default function,

27498
28:40:54.103 --> 28:40:56.103
graph example. And we're gonna
use this tool called Apollo

27499
28:40:57.103 --> 28:41:00.103
client, copy, paste it over. And
we're going to add it with yarn,

27500
28:41:00.103 --> 28:41:07.103
add dash dash dev at a P O ll O,
slash, client, or excuse me, not

27501
28:41:07.103 --> 28:41:11.103
Dev, because we do need this on
the front end. So yarn add at

27502
28:41:11.103 --> 28:41:16.103
Apollo slash client. Oh, sorry,
we also need to do yarn, add

27503
28:41:16.103 --> 28:41:20.103
Graph QL, we need to add both of
those. And it's this Apollo

27504
28:41:20.103 --> 28:41:23.103
slash client, which is how we're
going to make queries to our

27505
28:41:23.103 --> 28:41:28.103
newly created graph. QL. So
we're gonna say import the use

27506
28:41:28.103 --> 28:41:34.103
query hook, from this package we
just installed from at a P, O,

27507
28:41:34.103 --> 28:41:39.103
ll o slash client. And we'll
also import G QL. So to create a

27508
28:41:39.103 --> 28:41:47.103
new query, we'll say const, get
active item equals g QL. And

27509
28:41:47.103 --> 28:41:51.103
we'll add this backtick here.
And we'll add all of our Graph

27510
28:41:51.103 --> 28:41:54.103
QL stuff in here, this is gonna
be equivalent to this, this is

27511
28:41:54.103 --> 28:41:57.103
Graph QL. Syntax. And we're
gonna be putting this Graph QL

27512
28:41:57.103 --> 28:42:01.103
syntax into our code base here.
But we only want to get the

27513
28:42:01.103 --> 28:42:04.103
active items. So how are we
going to get the active items?

27514
28:42:04.103 --> 28:42:08.103
Well, we can actually build it
over here on our playground

27515
28:42:08.103 --> 28:42:12.103
first, and then add it to our
code base. So we'll say we want

27516
28:42:12.103 --> 28:42:19.103
to grab the active items, we'll
grab the first five, and then

27517
28:42:19.103 --> 28:42:28.103
we'll say where the buyer is
going to be 0x 12345678. We're

27518
28:42:28.103 --> 28:42:31.103
saying where the buyer is empty.
So we're grabbing the active

27519
28:42:31.103 --> 28:42:35.103
items where there is no buyer,
and then we're going to do and

27520
28:42:35.103 --> 28:42:42.103
then we're going to get the ID,
the buyer, the seller, the NFT

27521
28:42:42.103 --> 28:42:51.103
address, token, ID and the price
from that. And if we hit run, we

27522
28:42:51.103 --> 28:42:55.103
get our active item here. So we
see here, the buyer is this

27523
28:42:55.103 --> 28:43:02.103
exact 0x 12345678 Because it
gets defaulted to zero when

27524
28:43:02.103 --> 28:43:05.103
there is no buyer. And this is
why for item cancelled, we

27525
28:43:05.103 --> 28:43:08.103
updated the buyer to be that
dead address. So if it's bought,

27526
28:43:08.103 --> 28:43:11.103
it won't be active anymore. And
if it's cancelled, it also won't

27527
28:43:11.103 --> 28:43:16.103
be active anymore. Now we can
copy this query and paste it

27528
28:43:16.103 --> 28:43:21.103
into our code. And now we have a
Graph QL query that we can use

27529
28:43:21.103 --> 28:43:24.103
for our graph example. Now in
our graph example, we'll use

27530
28:43:24.103 --> 28:43:27.103
this query with this use query
hook. So in export default

27531
28:43:27.103 --> 28:43:31.103
function, graph example, we can
say const. And it comes with a

27532
28:43:31.103 --> 28:43:35.103
whole bunch of stuff like
loading error, and then the data

27533
28:43:35.103 --> 28:43:41.103
returned equals, use query. And
then we'll just pass it this Get

27534
28:43:41.103 --> 28:43:45.103
active item, or get active
items, let's put an S on it, get

27535
28:43:45.103 --> 28:43:51.103
active items. And then we can
just return return a little div.

27536
28:43:51.103 --> 28:43:54.103
And we'll say hi in the div, and
then we'll just do console dot

27537
28:43:54.103 --> 28:43:59.103
log data. And then now we'll go
back to our app.js, where we're

27538
28:43:59.103 --> 28:44:02.103
wrapping everything in a Morales
provider, we also need to wrap

27539
28:44:02.103 --> 28:44:05.103
everything in an Apollo
provider. And we need to

27540
28:44:05.103 --> 28:44:08.103
initialize it kind of similar to
how we initialize connecting to

27541
28:44:08.103 --> 28:44:11.103
our morale server, but we're
going to initialize connecting

27542
28:44:11.103 --> 28:44:18.103
to our Graph QL. So we're gonna
say import a P O ll o provider,

27543
28:44:18.103 --> 28:44:29.103
a P O ll o client, and in mem
ory, cache from at a P O ll o

27544
28:44:29.103 --> 28:44:33.103
slash client, like that, and
then we'll have to initialize

27545
28:44:33.103 --> 28:44:36.103
this so we can delete the morale
stuff. We'll initialize this

27546
28:44:36.103 --> 28:44:43.103
client by saying const client
equals new a P O LL. O client,

27547
28:44:43.103 --> 28:44:46.103
and we'll give it the parameters
here. And you can find this all

27548
28:44:46.103 --> 28:44:49.103
in the Apollo client
documentation will say there's

27549
28:44:49.103 --> 28:44:52.103
going to be a cache to help when
we do refreshes and stuff we'll

27550
28:44:52.103 --> 28:44:55.103
say new in

27551
28:44:55.103 --> 28:45:01.103
memory cache, and we'll say
comma URI, a que where we're

27552
28:45:01.103 --> 28:45:03.103
going to be connecting. And this
is where we're going to add the

27553
28:45:03.103 --> 28:45:08.103
API for our sub graph. So if we
go back to details, we can see

27554
28:45:08.103 --> 28:45:12.103
temporary query URL and this is
a rate limited temporary query,

27555
28:45:12.103 --> 28:45:15.103
because this is just a test net,
and we're going to copy this, go

27556
28:45:15.103 --> 28:45:17.103
back to our code. And we're just
going to paste it in here. So

27557
28:45:17.103 --> 28:45:21.103
whatever you have for temporary
query URL, and your sub graph

27558
28:45:21.103 --> 28:45:24.103
studio, that's where you're
gonna paste in here. Now, this

27559
28:45:24.103 --> 28:45:28.103
client tells our Graph QL, where
it should be making those

27560
28:45:28.103 --> 28:45:31.103
queries. And we're gonna make it
to here. Now, this starts with

27561
28:45:31.103 --> 28:45:35.103
HTTPS. So is this centralized?
Yes, because we are directly

27562
28:45:35.103 --> 28:45:40.103
calling the graph website.
However, all the data is still

27563
28:45:40.103 --> 28:45:43.103
gonna be stored in this
decentralized graph indexer. And

27564
28:45:43.103 --> 28:45:46.103
kind of similar to what we did
with IPFS, we're doing this kind

27565
28:45:46.103 --> 28:45:49.103
of as a gateway to make it a lot
easier for us to connect and

27566
28:45:49.103 --> 28:45:53.103
read the data from the graph
studio. However, in the future,

27567
28:45:53.103 --> 28:45:55.103
as more protocols and more
browsers adopt the graph, and

27568
28:45:55.103 --> 28:45:59.103
IPFS, this will become a lot
easier inside of our Morales

27569
28:45:59.103 --> 28:46:03.103
provider, but outside of our
notifications provider, we're

27570
28:46:03.103 --> 28:46:11.103
gonna say a P O ll o provider,
and then client equals client.

27571
28:46:11.103 --> 28:46:15.103
And then we're going to copy the
closing tag, and put it around

27572
28:46:15.103 --> 28:46:18.103
the notification provider and
press Save. Now I'm gonna save

27573
28:46:18.103 --> 28:46:20.103
our front end, now we're going
to try to run our front end. And

27574
28:46:20.103 --> 28:46:22.103
we're gonna have to change some
stuff in here because it's going

27575
28:46:22.103 --> 28:46:27.103
to freak out. So we're gonna run
yarn Dev, for new front end. So

27576
28:46:27.103 --> 28:46:30.103
we're gonna go to our localhost
3000. And it's going to totally

27577
28:46:30.103 --> 28:46:33.103
freak out, because we still have
some morale stuff in here. And

27578
28:46:33.103 --> 28:46:36.103
that's totally okay. We, of
course, we don't need a hard hat

27579
28:46:36.103 --> 28:46:38.103
Node running. Because we're on a
test net, we don't need to be

27580
28:46:38.103 --> 28:46:41.103
synched with Morales, we don't
need to be doing any of that

27581
28:46:41.103 --> 28:46:44.103
stuff. Because we're working
with a test net, right now, it's

27582
28:46:44.103 --> 28:46:47.103
actually not freaking out, which
is great. But it shows obviously

27583
28:46:47.103 --> 28:46:50.103
nothing for recently listed. So
what we're going to do now is

27584
28:46:50.103 --> 28:46:56.103
we're gonna do slash, graph
example, and hit enter. And we

27585
28:46:56.103 --> 28:47:01.103
can see Hi, show up. But if we
go to inspect, and we go to

27586
28:47:01.103 --> 28:47:07.103
console, a console here, we can
see an object here of active

27587
28:47:07.103 --> 28:47:12.103
items, which is returned from
the graph with buyer ID, NFT,

27588
28:47:12.103 --> 28:47:15.103
address price and all this stuff
in the air. This is fantastic.

27589
28:47:15.103 --> 28:47:19.103
So okay, okay. Okay. So all we
have to do now is we just have

27590
28:47:19.103 --> 28:47:22.103
to update. So let's go ahead,
we'll kill our server. For now,

27591
28:47:22.103 --> 28:47:27.103
all we have to do is update,
instead of use mirallas query,

27592
28:47:27.103 --> 28:47:29.103
we're going to delete this. And
we're just going to query from

27593
28:47:29.103 --> 28:47:33.103
Apollo query from our Graph QL.
And everything else stays the

27594
28:47:33.103 --> 28:47:37.103
same, right? Because our NFT
box, and all the rest of the

27595
28:47:37.103 --> 28:47:40.103
code that we worked with, will
still work exactly the same. So

27596
28:47:40.103 --> 28:47:42.103
first, we just got to get our
address. So we're gonna say

27597
28:47:42.103 --> 28:47:46.103
import, same as Sell, sell NFT,
import the network mapping, so

27598
28:47:46.103 --> 28:47:49.103
I'm actually just going to copy
it. So we're going to import

27599
28:47:49.103 --> 28:47:52.103
network mapping from constants,
network mapping dot JSON. And

27600
28:47:52.103 --> 28:47:59.103
now we can say const.
Marketplace, address equals, and

27601
28:47:59.103 --> 28:48:01.103
we're going to get the exact
same way we did this and sell

27602
28:48:01.103 --> 28:48:05.103
NFT to, so we're going to grab
this line getting the chain

27603
28:48:05.103 --> 28:48:08.103
string, we'll paste that in
here, which means we're going to

27604
28:48:08.103 --> 28:48:12.103
need to get chain ID from user
Morales. And then we're gonna

27605
28:48:12.103 --> 28:48:15.103
get the marketplace address like
this. So we're going to copy

27606
28:48:15.103 --> 28:48:18.103
that line, paste it in here.
Okay, great. Now we have the

27607
28:48:18.103 --> 28:48:23.103
marketplace address. So now
we're just going to do const.

27608
28:48:23.103 --> 28:48:29.103
Loading error data, which we can
do listed. And if T is again,

27609
28:48:29.103 --> 28:48:35.103
equals, use query, and we can do
that get active items. So what

27610
28:48:35.103 --> 28:48:39.103
I'm going to do is I'm going to
create a new file and constants,

27611
28:48:39.103 --> 28:48:42.103
we're going to pass that get
active items thing in their new

27612
28:48:42.103 --> 28:48:47.103
file, we're just going to call
it sub graph queries, dot j, s.

27613
28:48:47.103 --> 28:48:53.103
And then here, we're gonna say
import G QL. From at a Apollo

27614
28:48:53.103 --> 28:49:00.103
slash client. And we'll say
const, get active items, equals

27615
28:49:00.103 --> 28:49:05.103
g QL backtick. And exactly what
we did in that great, let's go

27616
28:49:05.103 --> 28:49:07.103
back to the graph example, we'll
just copy that whole line

27617
28:49:07.103 --> 28:49:14.103
actually pasted in here. And now
we'll just do export default,

27618
28:49:14.103 --> 28:49:20.103
get active items. And we'll
import this query from sub graph

27619
28:49:20.103 --> 28:49:26.103
queries into our index dot j s.
So we'll say import, get active

27620
28:49:26.103 --> 28:49:31.103
queries are skimming apt get
active items from dot dot slash

27621
28:49:31.103 --> 28:49:37.103
constants slash sub graph
queries. And now in our use

27622
28:49:37.103 --> 28:49:41.103
query will pass Get active
items, which should return are

27623
28:49:41.103 --> 28:49:46.103
listed NF Ts. So now, we'll
change this from fetching listed

27624
28:49:46.103 --> 28:49:54.103
NF Ts to loading, loading, or we
don't have listed NF Ts. So if

27625
28:49:54.103 --> 28:49:58.103
it's loading or we don't have
listen if TS then do loading,

27626
28:49:58.103 --> 28:50:02.103
otherwise, we're going to do
another mapping, but the return

27627
28:50:02.103 --> 28:50:06.103
of the Graph QL is going to be a
little bit different. So instead

27628
28:50:06.103 --> 28:50:10.103
of listing MTS dot map, it's
going to be listed NF T's dot AQ

27629
28:50:10.103 --> 28:50:15.103
two have items, dot map and f t,
and then we're going to get

27630
28:50:15.103 --> 28:50:19.103
price. And if the address token
ID, we're not going to get

27631
28:50:19.103 --> 28:50:22.103
marketplace address, but we'll
get seller from NFT. And it's

27632
28:50:22.103 --> 28:50:25.103
not going to be returned with
attributes. So we can just do

27633
28:50:25.103 --> 28:50:29.103
console dot log NFT instead. And
then we just pass all that stuff

27634
28:50:29.103 --> 28:50:32.103
normally to, to that NFT box
exactly the way that we did

27635
28:50:32.103 --> 28:50:35.103
before. So really, we're all
we're doing is we're swapping

27636
28:50:35.103 --> 28:50:38.103
out the query methodology here,
price is going to be from price

27637
28:50:38.103 --> 28:50:41.103
price is going to be from the
query, and ft address is going

27638
28:50:41.103 --> 28:50:44.103
to be from the query token ID
from the query marketplace

27639
28:50:44.103 --> 28:50:46.103
address, that's also gonna be
slightly different, we're going

27640
28:50:46.103 --> 28:50:49.103
to get that from our own config
seller is going to be from the

27641
28:50:49.103 --> 28:50:52.103
query, and then the key is going
to be from the query as well. So

27642
28:50:52.103 --> 28:50:57.103
now if we save that, if we
restart our website, with yarn

27643
28:50:57.103 --> 28:51:00.103
Dev, and we go back to our
homepage, we should see

27644
28:51:00.103 --> 28:51:04.103
everything exactly the same,
except for the images being

27645
28:51:04.103 --> 28:51:08.103
pulled from the graph, instead
of being pulled from her Alice.

27646
28:51:08.103 --> 28:51:11.103
Let's go back to our front end,
we'll give it a nice refresh,

27647
28:51:11.103 --> 28:51:15.103
close out the console. And we'll
go to our homepage. And I forgot

27648
28:51:15.103 --> 28:51:22.103
to do use query. So let's import
use query, import, use query

27649
28:51:22.103 --> 28:51:27.103
from at a Paulo slash client.
Let's save and let's go back and

27650
28:51:27.103 --> 28:51:33.103
give that a refresh. And oh, my
goodness, we now have updated to

27651
28:51:33.103 --> 28:51:38.103
get our events from a
decentralized data structure.

27652
28:51:38.103 --> 28:51:43.103
That's freaking awesome. Now
let's talk about hosting this

27653
28:51:43.103 --> 28:51:47.103
real quickly, we are using the
image tag in here in our NFT

27654
28:51:47.103 --> 28:51:51.103
box, we are using the image tag
in here from next Jas, which

27655
28:51:51.103 --> 28:51:54.103
comes with some pre processing.
So it's a little hard to use on

27656
28:51:54.103 --> 28:51:57.103
IPFS. So we would need to update
the way we do images in order to

27657
28:51:57.103 --> 28:52:01.103
host this on IPFS. But we still
can do that. Some other options

27658
28:52:01.103 --> 28:52:04.103
we have actually are Morales, we
can actually even host our apps

27659
28:52:04.103 --> 28:52:08.103
on Morales, if we want. We can
also use things like for cell or

27660
28:52:08.103 --> 28:52:11.103
Netlify, or etc, or really any
other traditional centralized

27661
28:52:11.103 --> 28:52:14.103
hosting service. Now, if you
want to, I challenge you to

27662
28:52:14.103 --> 28:52:18.103
update this code to make it be
able to be hosted on IPFS. So

27663
28:52:18.103 --> 28:52:21.103
that you'll have an end to end
decentralized. And if the

27664
28:52:21.103 --> 28:52:24.103
marketplace first wanted to make
a PR to this code, so that it

27665
28:52:24.103 --> 28:52:28.103
can be successfully hosted
completely end to end on IPFS

27666
28:52:28.103 --> 28:52:31.103
wins and empty for me. But wow.
And with that we are done with

27667
28:52:31.103 --> 28:52:35.103
less than 15. This is an
absolutely monstrous

27668
28:52:35.103 --> 28:52:38.103
accomplishment. And if you
finish this, if you've

27669
28:52:38.103 --> 28:52:40.103
understood everything, if you've
gotten through everything so

27670
28:52:40.103 --> 28:52:43.103
far, you should feel incredibly
proud of yourself. Because this

27671
28:52:43.103 --> 28:52:46.103
is our last full stack section,
our front end section and you're

27672
28:52:46.103 --> 28:52:50.103
a full stack monster at this
point. huge congratulations, you

27673
28:52:50.103 --> 28:52:54.103
should be super, super, super
proud. And definitely take a

27674
28:52:54.103 --> 28:52:58.103
break, go get a coffee, and get
ready for the final stretch of

27675
28:52:58.103 --> 28:53:01.103
lessons 1617 and 18. Those are
gonna go by a little bit

27676
28:53:01.103 --> 28:53:04.103
quicker. I'm very excited for
you take a break, and I'll see

27677
28:53:04.103 --> 28:53:13.103
you there.

27678
28:53:13.103 --> 28:53:18.103
Right, welcome to Lesson Six
tene, where we're going to be

27679
28:53:18.103 --> 28:53:23.103
going into even more low level
code here. The hard hat upgrades

27680
28:53:23.103 --> 28:53:27.103
of course, per usual, our entire
GitHub repository is located

27681
28:53:27.103 --> 28:53:30.103
here. And additionally, we have
an optional video that you can

27682
28:53:30.103 --> 28:53:33.103
watch. If you want to learn
more, we're actually going to

27683
28:53:33.103 --> 28:53:36.103
watch a slice of that video that
explains upgradable smart

27684
28:53:36.103 --> 28:53:39.103
contracts. So let's jump in. Now
I'm editing this video much

27685
28:53:39.103 --> 28:53:42.103
later after I filmed that, hence
why I have a beard so I'll be

27686
28:53:42.103 --> 28:53:45.103
jumping in from time to time
updating some of the sections.

27687
28:53:45.103 --> 28:53:48.103
When deploying your smart
contracts on chain. We all know

27688
28:53:48.103 --> 28:53:51.103
that those smart contracts are
immutable or unchangeable. But

27689
28:53:51.103 --> 28:53:55.103
what if I told you that they
were immutable?

27690
28:53:55.103 --> 28:53:58.103
Well, technically, that wouldn't
be correct. However, smart

27691
28:53:58.103 --> 28:54:01.103
contracts actually can change
all the time. When people

27692
28:54:01.103 --> 28:54:04.103
transfer tokens when people
stake in a contract or really do

27693
28:54:04.103 --> 28:54:07.103
any type of functionality. Those
smart contracts have to update

27694
28:54:07.103 --> 28:54:09.103
their balances and update their
mappings and update their

27695
28:54:09.103 --> 28:54:12.103
variables to reflect this. The
reason that they're immutable is

27696
28:54:12.103 --> 28:54:15.103
that the logic itself never
changes and will be on chain

27697
28:54:15.103 --> 28:54:18.103
like that forever. So
technically, yes, once they are

27698
28:54:18.103 --> 28:54:20.103
deployed, they are immutable.
And this is actually one of the

27699
28:54:20.103 --> 28:54:22.103
major benefits of smart
contracts in the first place

27700
28:54:22.103 --> 28:54:25.103
that nobody can tamper with or
screw with our smart contracts

27701
28:54:25.103 --> 28:54:27.103
once we deploy them. However,
this can be an issue if, for

27702
28:54:27.103 --> 28:54:30.103
example, we want to upgrade our
smart contract or protocol to do

27703
28:54:30.103 --> 28:54:34.103
more things, or want to fix some
glaring bug or issue that we

27704
28:54:34.103 --> 28:54:37.103
have. Now even though we can't
change the specific code that's

27705
28:54:37.103 --> 28:54:39.103
been deployed to an address, we
can actually do a lot more than

27706
28:54:39.103 --> 28:54:41.103
you think. And in this video,
we're going to explain the

27707
28:54:41.103 --> 28:54:44.103
different methodologies behind
upgrading your smart contracts.

27708
28:54:44.103 --> 28:54:47.103
And then we're going to show you
how to do it with hard hat and

27709
28:54:47.103 --> 28:54:49.103
open Zeppelin huge shout out to
a lot of open Zeppelin and

27710
28:54:49.103 --> 28:54:52.103
trilobites articles that helped
me put this video together and a

27711
28:54:52.103 --> 28:54:55.103
number of other sources as well
links in the description. So

27712
28:54:55.103 --> 28:54:59.103
let's get to it. Now at first
glance, you might be thinking,

27713
28:54:59.103 --> 28:55:01.103
if you can upgrade your smart
contracts, then they're not

27714
28:55:01.103 --> 28:55:07.104
really immutable that in a way
you'd be right. So when

27715
28:55:07.104 --> 28:55:09.104
explaining kind of the different
philosophies and patterns that

27716
28:55:09.104 --> 28:55:12.104
we can use here, we do need to
keep Behind the philosophies and

27717
28:55:12.104 --> 28:55:15.104
decentralization implications
that each one of these patterns

27718
28:55:15.104 --> 28:55:17.104
have, as they do all have
different advantages and

27719
28:55:17.104 --> 28:55:21.104
disadvantages. And yes, some of
the disadvantages here are going

27720
28:55:21.104 --> 28:55:23.104
to affect the centrality. So we
need to keep that in mind. And

27721
28:55:23.104 --> 28:55:26.104
this is why it's so important
that before you go ahead and

27722
28:55:26.104 --> 28:55:29.104
jump in and start deploying
upgradable smart contracts, you

27723
28:55:29.104 --> 28:55:31.104
understand the trade offs. So
we're going to talk about three

27724
28:55:31.104 --> 28:55:34.104
different ways to upgrade your
smart contracts. The first one

27725
28:55:34.104 --> 28:55:38.104
being the not really slash
Paramor ties way to upgrade your

27726
28:55:38.104 --> 28:55:41.104
smart contracts, the social
migration method, and then the

27727
28:55:41.104 --> 28:55:44.104
method that you probably have
heard about, which is proxies,

27728
28:55:44.104 --> 28:55:47.104
which have a ton of
subcategories, like metamorphic

27729
28:55:47.104 --> 28:55:50.104
contracts, transparent
upgradable, proxies, and

27730
28:55:50.104 --> 28:55:53.104
universal upgradable proxies. So
let's talk about the not really

27731
28:55:53.104 --> 28:55:55.104
upgrading method, or the
parameterization method, or

27732
28:55:55.104 --> 28:55:58.104
whatever you want to call it.
This is the simplest way to

27733
28:55:58.104 --> 28:56:01.104
think about upgrading your smart
contracts. And it really isn't

27734
28:56:01.104 --> 28:56:04.104
upgrading our smart contracts.
Because we can't really change

27735
28:56:04.104 --> 28:56:06.104
the logic of the smart contract,
whatever logic that we've

27736
28:56:06.104 --> 28:56:09.104
written, is there, we also can
add new storage or state

27737
28:56:09.104 --> 28:56:12.104
variables. So this is really not
really upgrading. But it is

27738
28:56:12.104 --> 28:56:16.104
something to think about
upgrades is just parameterizing,

27739
28:56:16.104 --> 28:56:18.104
everything, whatever logic that
we've deployed is there, and

27740
28:56:18.104 --> 28:56:21.104
that's what we're interacting
with this function means we just

27741
28:56:21.104 --> 28:56:23.104
have a whole bunch of setter
functions. And we can update

27742
28:56:23.104 --> 28:56:26.104
certain parameters. Like maybe
we have a reward parameter that

27743
28:56:26.104 --> 28:56:30.104
gives out a token at 1 percent, every
year or something like that.

27744
28:56:30.104 --> 28:56:33.104
Maybe we have a setter function
that says, hey, update that to

27745
28:56:33.104 --> 28:56:36.104
2 percent, or update that to 4 percent. It's
just a setter function that

27746
28:56:36.104 --> 28:56:40.104
changes some variable. Now, the
advantages here, obviously, this

27747
28:56:40.104 --> 28:56:43.104
is really simple to implement.
The disadvantage is that if you

27748
28:56:43.104 --> 28:56:46.104
didn't think of some logic or
some functionality, the first

27749
28:56:46.104 --> 28:56:49.104
time you deployed their smart
contract, that's too bad, you're

27750
28:56:49.104 --> 28:56:52.104
stuck with it, you can't update
the logic or really update

27751
28:56:52.104 --> 28:56:55.104
anything with the
parameterization, aka, not

27752
28:56:55.104 --> 28:56:57.104
really method. And the other
thing you have to think about is

27753
28:56:57.104 --> 28:57:01.104
who the admins are, who has
access to these setter functions

27754
28:57:01.104 --> 28:57:04.104
to these updating functions. If
it's a single person, guess

27755
28:57:04.104 --> 28:57:07.104
what, you have a centralized
smart contract. Now of course,

27756
28:57:07.104 --> 28:57:09.104
you can add a governance
contract to be the admin

27757
28:57:09.104 --> 28:57:12.104
contract of your protocol. And
that would be a decentralized

27758
28:57:12.104 --> 28:57:14.104
way of doing this. So just keep
that in mind, you can do this

27759
28:57:14.104 --> 28:57:17.104
method just need a governance
protocol to do so another

27760
28:57:17.104 --> 28:57:20.104
example of this might be a
contract registry. And this is

27761
28:57:20.104 --> 28:57:23.104
something actually that early
versions of ABA used before you

27762
28:57:23.104 --> 28:57:25.104
call a function, you actually
check some contract registry

27763
28:57:25.104 --> 28:57:28.104
that is updated as a parameter
by somebody and you get routed

27764
28:57:28.104 --> 28:57:31.104
to the contract, and you do your
call there. Again, this really

27765
28:57:31.104 --> 28:57:33.104
doesn't allow us to have the
full functionality of upgrades

27766
28:57:33.104 --> 28:57:36.104
here, you can argue that this
registry is a mix of one of the

27767
28:57:36.104 --> 28:57:39.104
later versions. But for all
intents and purposes, this

27768
28:57:39.104 --> 28:57:41.104
doesn't really give us that
flexibility that we want for

27769
28:57:41.104 --> 28:57:44.104
upgrades. But some people might
even think that upgrading your

27770
28:57:44.104 --> 28:57:47.104
smart contract is ruining the
decent reality. And one of the

27771
28:57:47.104 --> 28:57:49.104
things that makes smart
contracts so potent is that they

27772
28:57:49.104 --> 28:57:51.104
are immutable, and that this is
one of the benefits that they

27773
28:57:51.104 --> 28:57:54.104
have. So there are some people
who think that you shouldn't add

27774
28:57:54.104 --> 28:57:57.104
any customization or any
upgradability, you should deploy

27775
28:57:57.104 --> 28:58:00.104
your contract. And then that's
it. trilobites has actually

27776
28:58:00.104 --> 28:58:04.104
argued that if you deploy your
contract, knowing that it can't

27777
28:58:04.104 --> 28:58:07.104
be changed later, you take a
little bit extra time, making

27778
28:58:07.104 --> 28:58:09.104
sure you get everything right.
And there are often less

27779
28:58:09.104 --> 28:58:12.104
security vulnerabilities because
you're just setting it

27780
28:58:12.104 --> 28:58:15.104
forgetting it and not looking at
it again. Now, if I wanted to

27781
28:58:15.104 --> 28:58:18.104
upgrade a smart contract with
this philosophy in mind, the

27782
28:58:18.104 --> 28:58:20.104
philosophy that I do want to
keep my smart contracts

27783
28:58:20.104 --> 28:58:24.104
immutable, we can instead use
the social migration method,

27784
28:58:24.104 --> 28:58:27.104
which I previously called the
Eat method. And now I think it's

27785
28:58:27.104 --> 28:58:30.104
less funny. So we're just gonna
stick with social migration, the

27786
28:58:30.104 --> 28:58:33.104
social eating method, or the
migration method is just when

27787
28:58:33.104 --> 28:58:36.104
you deploy your new contract,
not connected to the old

27788
28:58:36.104 --> 28:58:39.104
contract in any way. And by
social convention, you tell

27789
28:58:39.104 --> 28:58:42.104
everybody, hey, hey, this new
contract, this new one that we

27790
28:58:42.104 --> 28:58:45.104
just deployed? Yeah, this is the
real one now. And it's just by

27791
28:58:45.104 --> 28:58:49.104
convention of people migrating
over into using this new one,

27792
28:58:49.104 --> 28:58:51.104
that the upgrade is done, hence
my slang name of social yeet.

27793
28:58:51.104 --> 28:58:55.104
Because you use the first one
out of the way and move to the

27794
28:58:55.104 --> 28:58:58.104
second one.

27795
28:58:58.104 --> 28:59:01.104
I think I'm funny. Yeah, this
has the advantage of truly

27796
28:59:01.104 --> 28:59:04.104
always saying, Hey, this is our
immutable smart contract. And

27797
28:59:04.104 --> 28:59:07.104
this is our new one. This is
really the truest definition of

27798
28:59:07.104 --> 28:59:11.104
immutable, because since you
give it no way of being upgraded

27799
28:59:11.104 --> 28:59:15.104
in place, than if somebody calls
that contract in 50,000 years in

27800
28:59:15.104 --> 28:59:18.104
the future, it will respond
exactly the same. Another huge

27801
28:59:18.104 --> 28:59:21.104
disadvantage here is that you
have to have a totally new

27802
28:59:21.104 --> 28:59:25.104
contract address. So if you're
an ERC 20 token, for example,

27803
28:59:25.104 --> 28:59:28.104
you have to go convince all the
exchanges to list your new

27804
28:59:28.104 --> 28:59:31.104
contract address as the actual
address. Keep in mind that when

27805
28:59:31.104 --> 28:59:34.104
we do this, we do have to move
the state of the first one over

27806
28:59:34.104 --> 28:59:37.104
to the second one. So for
example, if you're an ERC token

27807
28:59:37.104 --> 28:59:41.104
moving to a new version of that
ERC token, you do, you have to

27808
28:59:41.104 --> 28:59:44.104
have a way to take all those
mappings from the first contract

27809
28:59:44.104 --> 28:59:46.104
and move it to the second one.
Obviously, there are ways to do

27810
28:59:46.104 --> 28:59:49.104
this, since everything is on
chain. But if you have a million

27811
28:59:49.104 --> 28:59:51.104
transfer calls, I don't want to
have to write the script that

27812
28:59:51.104 --> 28:59:53.104
updates everyone's balance and
figures out what everyone's

27813
28:59:53.104 --> 28:59:56.104
balance is just so I can migrate
to my new version of the

27814
28:59:56.104 --> 28:59:59.104
contract. So there's a ton of
social convention work here to

27815
28:59:59.104 --> 29:00:02.104
do. trilobites has actually
written a fantastic blog on

27816
29:00:02.104 --> 29:00:07.104
upgrading from a v1 to v2 or
etc. With this eat methodology

27817
29:00:07.104 --> 29:00:09.104
and they give a lot of steps for
moving your storage and your

27818
29:00:09.104 --> 29:00:12.104
state variables over To the new
contract. So link in the

27819
29:00:12.104 --> 29:00:14.104
description if you want to read
that. Now let's get to our big

27820
29:00:14.104 --> 29:00:16.104
ticket item. So in order to have
a really robust upgrading

27821
29:00:16.104 --> 29:00:20.104
mentality or philosophy, we need
to have some type of methodology

27822
29:00:20.104 --> 29:00:23.104
or framework that can update our
state, keep our contract address

27823
29:00:23.104 --> 29:00:27.104
and allow us to update any type
of logic in our smart contracts

27824
29:00:27.104 --> 29:00:30.104
in a easy way, which leads us to
our big ticket item is the

27825
29:00:30.104 --> 29:00:36.104
proxies. What's our big ticket
item?

27826
29:00:36.104 --> 29:00:41.104
proxies, proxies. Proxies are
the truest form of upgrades,

27827
29:00:41.104 --> 29:00:43.104
since a user can keep
interacting with the protocols

27828
29:00:43.104 --> 29:00:46.104
through these proxies, and not
even notice that anything

27829
29:00:46.104 --> 29:00:49.104
changed or even got updated.
Now, these are also the places

27830
29:00:49.104 --> 29:00:52.104
where you can screw up the
easiest. Proxies use a lot of

27831
29:00:52.104 --> 29:00:56.104
low level functionality. And the
main one being the delegate call

27832
29:00:56.104 --> 29:00:59.104
functionality. Delegate call is
a low level function where the

27833
29:00:59.104 --> 29:01:04.104
code in the target contract is
executed in the context of the

27834
29:01:04.104 --> 29:01:07.104
calling contract. And message
dot sender and message dot value

27835
29:01:07.104 --> 29:01:09.104
also don't change. So you
understand what delegate call

27836
29:01:09.104 --> 29:01:12.104
means. Now, right? Great. And in
English, this means if I

27837
29:01:12.104 --> 29:01:17.104
delegate call a function in
contract B from contract a, I

27838
29:01:17.104 --> 29:01:22.104
will do contracts B's logic in
contract a. So if contract B has

27839
29:01:22.104 --> 29:01:26.104
a function that says hey, store
this value in a variable up top,

27840
29:01:26.104 --> 29:01:30.104
I'm going to store that variable
in contract a, this is the

27841
29:01:30.104 --> 29:01:33.104
powerhouse. And this combined
with the fallback function

27842
29:01:33.104 --> 29:01:38.104
allows us to delegate all calls
through a proxy contract address

27843
29:01:38.104 --> 29:01:41.104
to some other contract, this
means that I can have one proxy

27844
29:01:41.104 --> 29:01:45.104
contract that will have the same
address forever. And I can just

27845
29:01:45.104 --> 29:01:49.104
point and route people to the
correct implementation contract

27846
29:01:49.104 --> 29:01:53.104
that has the logic, whenever I
want to upgrade, I just deploy a

27847
29:01:53.104 --> 29:01:57.104
new implementation contract and
point my proxy to that new

27848
29:01:57.104 --> 29:02:00.104
implementation. Now, whenever a
user calls a function on the

27849
29:02:00.104 --> 29:02:03.104
proxy contract, I'm going to
delegate call it to the new

27850
29:02:03.104 --> 29:02:07.104
contract, I can just call an
admin only function on my proxy

27851
29:02:07.104 --> 29:02:09.104
contract, let's call it upgrade
or something and I make all the

27852
29:02:09.104 --> 29:02:12.104
contract calls go to this new
contract. When we're talking

27853
29:02:12.104 --> 29:02:14.104
about proxies, there are four
pieces of terminology that we

27854
29:02:14.104 --> 29:02:17.104
want to keep in mind. First is
the implementation contract. The

27855
29:02:17.104 --> 29:02:20.104
implementation contract has all
of our logic and all the pieces

27856
29:02:20.104 --> 29:02:23.104
of our protocol. Whenever we
upgrade, we actually launch a

27857
29:02:23.104 --> 29:02:26.104
brand new implementation
contract, the proxy contract

27858
29:02:26.104 --> 29:02:29.104
proxy points to which
implementation is the correct

27859
29:02:29.104 --> 29:02:33.104
one. And routes everyone's calls
to the correct implementation

27860
29:02:33.104 --> 29:02:36.104
contract, you can think the
proxy contracts sits on top of

27861
29:02:36.104 --> 29:02:39.104
the implementations the user,
the user is going to be making

27862
29:02:39.104 --> 29:02:43.104
contract and function calls
through the proxy contract. And

27863
29:02:43.104 --> 29:02:46.104
then some type of admin, the
admin is the one who's going to

27864
29:02:46.104 --> 29:02:50.104
decide when to upgrade and which
contract to point to. In this

27865
29:02:50.104 --> 29:02:53.104
scenario, the other cool thing
about the proxy and delegate

27866
29:02:53.104 --> 29:02:56.104
call is that all my storage
variables are going to be stored

27867
29:02:56.104 --> 29:03:00.104
in the proxy contract and not in
the implementation contract.

27868
29:03:00.104 --> 29:03:04.104
This way, when I upgrade to a
new logic contract, all of my

27869
29:03:04.104 --> 29:03:07.104
data will stay on the proxy
contract. So whenever I want to

27870
29:03:07.104 --> 29:03:10.104
update my logic, just point to a
new implementation contract, if

27871
29:03:10.104 --> 29:03:12.104
I want to add a new storage
variable or a new type of

27872
29:03:12.104 --> 29:03:16.104
storage, I just add it in my
logic contract and the proxy

27873
29:03:16.104 --> 29:03:19.104
contract will pick it up. Now,
using proxies has a couple of

27874
29:03:19.104 --> 29:03:21.104
gotchas. And we're gonna talk
about the gotchas. And then

27875
29:03:21.104 --> 29:03:23.104
we're going to talk about the
different proxy contract

27876
29:03:23.104 --> 29:03:26.104
methodologies, because yes,
there are many proxy contract

27877
29:03:26.104 --> 29:03:29.104
methodologies as well. And this
is why trilobites doesn't really

27878
29:03:29.104 --> 29:03:31.104
recommend using upgradable
proxies for your smart

27879
29:03:31.104 --> 29:03:34.104
contracts. Because they're
fraught with a lot of these

27880
29:03:34.104 --> 29:03:37.104
potential issues. Not to
mention, again, you do still

27881
29:03:37.104 --> 29:03:40.104
have some type of admin who's
going to be upgrading your smart

27882
29:03:40.104 --> 29:03:43.104
contracts. Now, if this is a
governance protocol, then great,

27883
29:03:43.104 --> 29:03:45.104
you're decentralized. But if
this is a single group or

27884
29:03:45.104 --> 29:03:50.104
entity, then we have a problem.
The two biggest gotchas are

27885
29:03:50.104 --> 29:03:55.104
storage, clashes, and function
selector clashes. Now, what does

27886
29:03:55.104 --> 29:03:58.104
this mean? When we use delegate
call, remember, we do the logic

27887
29:03:58.104 --> 29:04:03.104
of contract B inside contract a.
So if contract B says we need to

27888
29:04:03.104 --> 29:04:07.104
set value to two, we go ahead
and set value to what these

27889
29:04:07.104 --> 29:04:11.104
smart contracts are actually
kind of dumb, we actually set

27890
29:04:11.104 --> 29:04:14.104
the value of whatever is in the
same storage location on

27891
29:04:14.104 --> 29:04:17.104
contract as contract B. So if
our contract looks like this,

27892
29:04:17.104 --> 29:04:20.104
and we have two variables and
contract a, we're still going to

27893
29:04:20.104 --> 29:04:24.104
set the first storage spot on a
contract a to the new value.

27894
29:04:24.104 --> 29:04:26.104
This is really important to know
because this means we can only

27895
29:04:26.104 --> 29:04:30.104
append new storage variables and
new implementation contracts.

27896
29:04:30.104 --> 29:04:33.104
And we can't reorder or change
old ones. This is called storage

27897
29:04:33.104 --> 29:04:36.104
clashing. And in the
implementations we're going to

27898
29:04:36.104 --> 29:04:39.104
talk about, they all address
this issue. The next one is

27899
29:04:39.104 --> 29:04:42.104
called function select or
clashes. When we tell our

27900
29:04:42.104 --> 29:04:45.104
proxies to delegate call to one
of these implementations, it

27901
29:04:45.104 --> 29:04:48.104
uses what's called a function
selector to find a function. A

27902
29:04:48.104 --> 29:04:52.104
function selector is a four byte
hash of the function name and

27903
29:04:52.104 --> 29:04:54.104
the function signature. Don't
worry about the function

27904
29:04:54.104 --> 29:04:58.104
signature for now. Now, it's
possible that a function in the

27905
29:04:58.104 --> 29:05:02.104
implementation contract has the
same function selector as an

27906
29:05:02.104 --> 29:05:05.104
admin function in the proxy
contract, which may cause you to

27907
29:05:05.104 --> 29:05:08.104
do accidentally a whole bunch of
weird stuff. For example, in

27908
29:05:08.104 --> 29:05:11.104
this sample code in front of you
even though All these functions

27909
29:05:11.104 --> 29:05:13.104
are totally different, they
actually have the same function

27910
29:05:13.104 --> 29:05:17.104
selector. So yes, we can run
into an issue where some

27911
29:05:17.104 --> 29:05:21.104
harmless function like get price
has the same function selector

27912
29:05:21.104 --> 29:05:25.104
as upgrade proxy or destroy
proxy or something like that.

27913
29:05:25.104 --> 29:05:28.104
This leads to our first of the
three implementations of the

27914
29:05:28.104 --> 29:05:32.104
proxy contracts. This is called
the transparent proxy pattern.

27915
29:05:32.104 --> 29:05:34.104
And it's actually going to be
the pattern that we're gonna be

27916
29:05:34.104 --> 29:05:37.104
demoing to you today. In this
methodology, admins are only

27917
29:05:37.104 --> 29:05:40.104
allowed to call admin functions.
And they can't call any

27918
29:05:40.104 --> 29:05:44.104
functions in the implementation
contract. And users can only

27919
29:05:44.104 --> 29:05:46.104
call functions in the
implementation contract and not

27920
29:05:46.104 --> 29:05:50.104
any admin contracts. This way,
you can't ever accidentally have

27921
29:05:50.104 --> 29:05:53.104
one of the two swapping, and
having a function selector clash

27922
29:05:53.104 --> 29:05:55.104
and you running into a big issue
where you call a function, you

27923
29:05:55.104 --> 29:05:57.104
probably shouldn't have, if
you're an admin, you're calling

27924
29:05:57.104 --> 29:06:00.104
admin functions. If your user
you're calling implementation

27925
29:06:00.104 --> 29:06:02.104
functions. So if you're an
admin, and you build some crazy,

27926
29:06:02.104 --> 29:06:05.104
awesome defi protocol, you
better come up with a new wallet

27927
29:06:05.104 --> 29:06:07.104
address because you can't
participate. The second type of

27928
29:06:07.104 --> 29:06:10.104
proxy we're going to talk about
is the universal upgradeable

27929
29:06:10.104 --> 29:06:11.104
proxy, or the

27930
29:06:11.104 --> 29:06:18.104
op amps. This version of
upgradable contracts actually

27931
29:06:18.104 --> 29:06:22.104
puts all the logic of upgrading
in the implementation itself

27932
29:06:22.104 --> 29:06:26.104
this way, the solidity compiler
will actually kick out and say,

27933
29:06:26.104 --> 29:06:29.104
Hey, we got two functions in
here that have the same function

27934
29:06:29.104 --> 29:06:31.104
selector. This is also
advantageous because we have one

27935
29:06:31.104 --> 29:06:35.104
less read that we have to do, we
no longer have to check in the

27936
29:06:35.104 --> 29:06:39.104
proxy contract if someone is an
admin or not. This saves on gas,

27937
29:06:39.104 --> 29:06:41.104
of course, and the proxy is also
a little bit smaller. Because of

27938
29:06:41.104 --> 29:06:44.104
this, the issue is that if you
deploy an implementation

27939
29:06:44.104 --> 29:06:47.104
contract, without any
upgradeable functionality,

27940
29:06:47.104 --> 29:06:51.104
you're stuck. And it's back to
the Eat method with you. And the

27941
29:06:51.104 --> 29:06:53.104
last pattern or methodology that
we're going to talk about is the

27942
29:06:53.104 --> 29:06:56.104
diamond pattern, which does a
number of things. But one of the

27943
29:06:56.104 --> 29:06:59.104
biggest things that it does, it
actually allows for multiple

27944
29:06:59.104 --> 29:07:02.104
implementation contracts. This
addresses a couple of different

27945
29:07:02.104 --> 29:07:05.104
issues. For example, if your
contract is so big, and it

27946
29:07:05.104 --> 29:07:08.104
doesn't fit into the one
contract maximum size, you can

27947
29:07:08.104 --> 29:07:11.104
just have multiple contracts
through this multi

27948
29:07:11.104 --> 29:07:14.104
implementation method. It also
allows you to make more granular

27949
29:07:14.104 --> 29:07:17.104
upgrades, like you don't have to
always deploy and upgrade your

27950
29:07:17.104 --> 29:07:20.104
entire smart contract, you can
just upgrade little pieces of

27951
29:07:20.104 --> 29:07:22.104
it. If you've chunked them out.
All the proxies mentioned here

27952
29:07:22.104 --> 29:07:25.104
have some type of Aetherium
improvement proposal, and most

27953
29:07:25.104 --> 29:07:27.104
of them are in the draft phase.
And at the end of this

27954
29:07:27.104 --> 29:07:30.104
explainer, we will do a demo of
showing you how the delegate

27955
29:07:30.104 --> 29:07:35.104
call function works. And the end
of the demo is right now. So

27956
29:07:35.104 --> 29:07:39.104
let's look at delegate call.

27957
29:07:39.104 --> 29:07:41.104
Now, we're going to learn about
how to actually build these

27958
29:07:42.104 --> 29:07:45.104
proxies how to build these
upgradable smart contracts. And

27959
29:07:45.104 --> 29:07:48.104
to do this, we first need to
learn about this delegate call

27960
29:07:48.104 --> 29:07:51.104
function. And it's going to be
really similar to the call

27961
29:07:51.104 --> 29:07:53.104
function, which we learned much
earlier. If you haven't seen

27962
29:07:53.104 --> 29:07:56.104
that, be sure to go back to our
Harnett. And if T's we have a

27963
29:07:56.104 --> 29:08:00.104
sub lesson in there, about EVM,
opcodes, and coding and calling

27964
29:08:00.104 --> 29:08:03.104
and we'll give you all the
context for delegate call. Like

27965
29:08:03.104 --> 29:08:06.104
I said, in the explainer, it's
very similar to call however,

27966
29:08:06.104 --> 29:08:10.104
the way that I think about it is
one contract says Oh, I really

27967
29:08:10.104 --> 29:08:13.104
like your function, I'm going to
borrow it myself. And we're

27968
29:08:13.104 --> 29:08:15.104
going to be looking at solidity
by example. I'll leave a

27969
29:08:15.104 --> 29:08:19.104
description in the GitHub. And
all the code for this will be in

27970
29:08:19.104 --> 29:08:22.104
the GitHub associated with this
lesson as well. Now we have two

27971
29:08:22.104 --> 29:08:25.104
contracts, we have this contract
B that we're going to be

27972
29:08:25.104 --> 29:08:28.104
deploying on remix and it looks
like a real minimalistic real

27973
29:08:28.104 --> 29:08:30.104
simple contract. We have a
couple of storage variables

27974
29:08:30.104 --> 29:08:33.104
here. And then we have a
function that updates our

27975
29:08:33.104 --> 29:08:36.104
values, we have a function
called Set VARs and updates are

27976
29:08:36.104 --> 29:08:40.104
you into public num? Now as we
learned before, whenever we have

27977
29:08:40.104 --> 29:08:43.104
some type of contract with
storage variables they get

27978
29:08:43.104 --> 29:08:47.104
stored in, in this storage data
structure that's index starting

27979
29:08:47.104 --> 29:08:51.104
from zero, right now are you
into public num is that index

27980
29:08:51.104 --> 29:08:55.104
zero, or sender's at index one,
our values and index two etc.

27981
29:08:55.104 --> 29:09:00.104
Now we're going to deploy a
contract a and now this contract

27982
29:09:00.104 --> 29:09:03.104
is actually going to use the
delegates call function. Now a

27983
29:09:03.104 --> 29:09:05.104
contract a this is going to look
a little bit different, but it's

27984
29:09:05.104 --> 29:09:08.104
still going to have this set
bars functions, except it's

27985
29:09:08.104 --> 29:09:12.104
going to make a delegate call
function call to our contract B.

27986
29:09:12.104 --> 29:09:16.104
Now in our lesson 14 with NF TS
we learned about call API dot

27987
29:09:16.104 --> 29:09:19.104
encode with signature API dot
encode etc. So if you're

27988
29:09:19.104 --> 29:09:21.104
unfamiliar with function
selectors, if you're unfamiliar

27989
29:09:21.104 --> 29:09:24.104
with if you're unfamiliar with
this syntax, be sure to go back

27990
29:09:24.104 --> 29:09:28.104
to lesson 14 To understand ABI
dot encode with signature and

27991
29:09:28.104 --> 29:09:32.104
contract dot call. The
difference here is we're doing

27992
29:09:32.104 --> 29:09:36.104
contract dot delegate call. What
this call does is something very

27993
29:09:36.104 --> 29:09:40.104
similar to call. Normally, if we
did contract dot call on this

27994
29:09:40.104 --> 29:09:43.104
contract, we would just call
this, we would just be calling

27995
29:09:43.104 --> 29:09:47.104
this function set VARs, which
would update contracts B's

27996
29:09:47.104 --> 29:09:50.104
storage, but instead we're
saying Hey, call that set VARs

27997
29:09:50.104 --> 29:09:54.104
function, and then pass this as
an input parameter, but call it

27998
29:09:54.104 --> 29:09:58.104
in our contract, call it on
contract a, we're kind of

27999
29:09:58.104 --> 29:10:02.104
borrowing a function for our
contract. And so instead, what

28000
29:10:02.104 --> 29:10:05.104
we're going to do, is we're
going to borrow this set bars

28001
29:10:05.104 --> 29:10:08.104
and run the set bars function
over here. Now the difference is

28002
29:10:08.104 --> 29:10:11.104
instead of num equals num The
variables could be named

28003
29:10:11.104 --> 29:10:15.104
different than the variables on
contract a. So instead of num

28004
29:10:15.104 --> 29:10:19.104
equals num, our contract is
going to say, hey, whatever that

28005
29:10:19.104 --> 29:10:23.104
storage of zero have that equal
to whatever we pass as an input

28006
29:10:23.104 --> 29:10:25.104
parameter. And if that's a
little bit confusing, just stay

28007
29:10:25.104 --> 29:10:28.104
with me. Let's go ahead and
let's see this in remix. So I'm

28008
29:10:28.104 --> 29:10:31.104
going to copy paste this code
into remix here. So we can kind

28009
29:10:31.104 --> 29:10:34.104
of test and see what this looks
like. Again, there's a link to

28010
29:10:34.104 --> 29:10:37.104
this in the GitHub repo
associated with this course,

28011
29:10:37.104 --> 29:10:40.104
feel free to pause the video to
grab this link. It's solidity,

28012
29:10:40.104 --> 29:10:44.104
hyphen, by hyphen,
example.org/delegate call, or

28013
29:10:44.104 --> 29:10:47.104
you can just grab the code
directly from lesson 16 Hardhead

28014
29:10:47.104 --> 29:10:49.104
upgrades. So let's compile this
code. And let me show you what I

28015
29:10:49.104 --> 29:10:53.104
mean. So I'm going to compile
it, and we'll go to the Run tab.

28016
29:10:53.104 --> 29:10:56.104
And first let's deploy this
contract beam, we'll hit Deploy,

28017
29:10:56.104 --> 29:11:00.104
we now have a contract, num,
center and value are all blank,

28018
29:11:00.104 --> 29:11:03.104
we'll update the number to
something like 777, we'll hit

28019
29:11:03.104 --> 29:11:09.104
Set VARS. Set VARs will change
the storage variable num to 777.

28020
29:11:09.104 --> 29:11:11.104
And then we're changing the
sender and the value, sender,

28021
29:11:12.104 --> 29:11:16.104
and value is zero. Now let's
deploy contract a. So we'll

28022
29:11:16.104 --> 29:11:19.104
scroll back up contract a
deploy, of course, we're on the

28023
29:11:19.104 --> 29:11:23.104
JavaScript VM. Now we have this
contract a with num value in

28024
29:11:23.104 --> 29:11:27.104
Cinder are also all blank. But
when we call set VARs, it's

28025
29:11:27.104 --> 29:11:32.104
going to borrow this set VARs
function from contract B and run

28026
29:11:32.104 --> 29:11:37.104
it in contract a, you can almost
think of it as if we're copying,

28027
29:11:37.104 --> 29:11:42.104
set VARs and pasting it into our
contract a just for one run, and

28028
29:11:42.104 --> 29:11:45.105
then immediately deleting ADM,
that's what this delegate call

28029
29:11:45.105 --> 29:11:48.105
function does. So when I call
set VARs, we're going to pass it

28030
29:11:48.105 --> 29:11:51.105
this contract address as an
input parameter. So it knows to

28031
29:11:51.105 --> 29:11:55.105
call this contract said virus
function. When I pass it the

28032
29:11:55.105 --> 29:12:00.105
address, and I pass 987. Since
we're borrowing the function,

28033
29:12:00.105 --> 29:12:03.105
we're not going to update this
num. On contract B, we're going

28034
29:12:03.105 --> 29:12:08.105
to update the num on contract a.
So when I hit Set VARs, we see

28035
29:12:08.105 --> 29:12:12.105
num now has 19. Seven, we see
Senator and we see value still

28036
29:12:12.105 --> 29:12:14.105
being zero here, because again,
we're borrowing this function

28037
29:12:14.105 --> 29:12:18.105
and running it here. Now the way
that this works, is it actually

28038
29:12:18.105 --> 29:12:22.105
doesn't look at the names of our
stored variables, it looks at

28039
29:12:22.105 --> 29:12:26.105
the storage slots. So when we
borrow this function using

28040
29:12:26.105 --> 29:12:29.105
delegate call, so we could have
this these variables we named

28041
29:12:29.105 --> 29:12:34.105
anything instead of num, we
could call this first value.

28042
29:12:34.105 --> 29:12:38.105
Senator, we could call something
else. And then value we could

28043
29:12:38.105 --> 29:12:43.105
call foo, or whatever you want
here. And when we borrow this

28044
29:12:43.105 --> 29:12:47.105
function using delegate call,
instead of grabbing the actual

28045
29:12:47.105 --> 29:12:49.105
names of the variables, our
contract will swap out these

28046
29:12:49.105 --> 29:12:53.105
variable names with the storage
slot. So it says oh, okay, well,

28047
29:12:53.105 --> 29:12:57.105
in contract B, you're accessing
the num variable, which is,

28048
29:12:57.105 --> 29:13:01.105
which is at storage slot zero.
So when we borrow set bars and

28049
29:13:01.105 --> 29:13:08.105
contract a with Delegate call,
we'll say storage slot

28050
29:13:08.105 --> 29:13:14.105
zero is going to equal that
underscore num. Which are this

28051
29:13:14.105 --> 29:13:18.105
contract storage slot zero is
first value. So we'll say first

28052
29:13:18.105 --> 29:13:23.105
value equals underscore Now,
something else is going to be

28053
29:13:23.105 --> 29:13:27.105
stored slot two, so it's gonna
say okay, storage slot two,

28054
29:13:27.105 --> 29:13:30.105
we're gonna update storage slot
two to message that sender.

28055
29:13:30.105 --> 29:13:35.105
Okay? value here is storage slot
three. So whatever's in storage,

28056
29:13:35.105 --> 29:13:39.105
slot three, will update with
message dot value like this. So

28057
29:13:39.105 --> 29:13:42.105
that's essentially what's going
on behind the scenes. So let's

28058
29:13:42.105 --> 29:13:46.105
go ahead and let's delete those
and redeploy. redeploy them. So

28059
29:13:46.105 --> 29:13:50.105
we'll deploy contract be
deployed contract a, right now

28060
29:13:50.105 --> 29:13:55.105
in B, once again, if we do 1234,
set VARs, we have 123. And then

28061
29:13:55.105 --> 29:13:59.105
contract a. Now even though
these variables have different

28062
29:13:59.105 --> 29:14:04.105
names, we could grab contract
B's address, paste it in, do

28063
29:14:04.105 --> 29:14:10.105
654, hit Set VARS. And first
value is now six by four. So

28064
29:14:10.105 --> 29:14:13.105
delegate call allows us to
borrow functions, and then just

28065
29:14:13.105 --> 29:14:17.105
transposes whatever is in here
to the storage location

28066
29:14:17.105 --> 29:14:20.105
equivalents. And the other thing
that's interesting is even if

28067
29:14:20.105 --> 29:14:24.105
you don't have variables, it'll
still save to storage slots. So

28068
29:14:24.105 --> 29:14:27.105
in contract a, if we didn't have
any of those variable names,

28069
29:14:27.105 --> 29:14:30.105
storage slot, 01, and two would
still get updated. Now here's

28070
29:14:30.105 --> 29:14:33.105
where things can get really
interesting. Let's delete our

28071
29:14:33.105 --> 29:14:38.105
contract again. And let's change
the type of our contract A's

28072
29:14:38.105 --> 29:14:43.105
first value to from a UNT to a
Boolean. Let's save that. And

28073
29:14:43.105 --> 29:14:48.105
now let's deploy contract a. Now
when we call set VARs, on our

28074
29:14:48.105 --> 29:14:53.105
contract a, it's still going to
use the Set VARs function of

28075
29:14:53.105 --> 29:14:57.105
contract B, which takes a
Yewande and assigns the first

28076
29:14:57.105 --> 29:15:01.105
storage slot that number we pass
it, but our first storage slot

28077
29:15:01.105 --> 29:15:04.105
is now a Boolean was so what do
you think's going to happen now?

28078
29:15:04.105 --> 29:15:08.105
Well, let's try it out. Let's
copy contract B's address, paste

28079
29:15:08.105 --> 29:15:12.105
it in here. We'll pass we'll do
tu tu, tu as our input

28080
29:15:12.105 --> 29:15:17.105
parameter, we'll hit Set VARS.
Our transaction actually does go

28081
29:15:17.105 --> 29:15:22.105
through. And now when we look at
first value, it says true. Hmm,

28082
29:15:22.105 --> 29:15:26.105
that's really weird. What if we
change set VARs to zero, and hit

28083
29:15:26.105 --> 29:15:31.105
Set VARS. And now, first value
is false. In storage here, when

28084
29:15:31.105 --> 29:15:34.105
we add a number with set VARs,
it's going through because it's

28085
29:15:34.105 --> 29:15:39.105
just setting the storage slot of
the boolean to a number. And

28086
29:15:39.105 --> 29:15:43.105
when solidity reads it, it goes,
Oh, well, first value is a

28087
29:15:43.105 --> 29:15:46.105
Boolean. So if it's anything
other than zero, it's going to

28088
29:15:46.105 --> 29:15:49.105
be true. So this is how you can
actually get some really weird

28089
29:15:49.105 --> 29:15:52.105
results. If your typings are
different, or if your stored

28090
29:15:52.105 --> 29:15:55.105
variants are different. What if
we made this an address. So this

28091
29:15:55.105 --> 29:15:58.105
is where working with Delegate
call can get really weird and

28092
29:15:58.105 --> 29:16:05.105
really tricky, really fast.

28093
29:16:05.105 --> 29:16:09.105
All right. Now, with all this
being said, let's turn up the

28094
29:16:09.105 --> 29:16:12.105
heat. And let me show you a
small proxy, a minimal proxy

28095
29:16:12.105 --> 29:16:16.105
example, that shows how a
contract can be used as a

28096
29:16:16.105 --> 29:16:20.105
singular address, but the
underlying code can actually

28097
29:16:20.105 --> 29:16:23.105
change. And all the code we're
gonna be working with, once

28098
29:16:23.105 --> 29:16:28.105
again, in the hardhat upgrades,
FCC sub lesson, small proxy dot

28099
29:16:28.105 --> 29:16:31.105
Sol, and you can go ahead and
copy paste this code if you want

28100
29:16:31.105 --> 29:16:34.105
to follow along. So you don't
have to code along with me here.

28101
29:16:34.105 --> 29:16:37.105
But you absolutely can if we
want. Now, I will say this is

28102
29:16:37.105 --> 29:16:41.105
going to be one of the most, if
not the most advanced section of

28103
29:16:41.105 --> 29:16:44.105
the entire course. So feel free
to go ahead and skip over this

28104
29:16:44.105 --> 29:16:47.105
sub lesson. If you want to just
move on to learning how to

28105
29:16:47.105 --> 29:16:50.105
actually build these proxies,
without really understanding

28106
29:16:50.105 --> 29:16:52.105
what's going on behind the
scenes. However, it is still

28107
29:16:52.105 --> 29:16:54.105
really powerful if you do
understand what's going on

28108
29:16:54.105 --> 29:16:57.105
behind the scenes. So I have
this minimalistic starting

28109
29:16:57.105 --> 29:17:01.105
position right here. I have
small proxy is proxy. And I'm

28110
29:17:01.105 --> 29:17:05.105
importing this proxy dot sole
thing from up in Zeplin.

28111
29:17:05.105 --> 29:17:08.105
openzeppelin has this
minimalistic proxy contract that

28112
29:17:08.105 --> 29:17:11.105
we can use to actually start
working with this delegate call.

28113
29:17:11.105 --> 29:17:14.105
Now this contract uses a lot of
assembly or what's something

28114
29:17:14.105 --> 29:17:17.105
called you'll. And it's an
intermediate language that can

28115
29:17:17.105 --> 29:17:20.105
be compiled to bytecode for
different backends. It's a sort

28116
29:17:20.105 --> 29:17:24.105
of inline assembly inside
solidity and allows you to write

28117
29:17:24.105 --> 29:17:28.105
really, really low level code
close to the opcodes. Now we're

28118
29:17:28.105 --> 29:17:30.105
not going to go over you'll but
I'll leave some links to the

28119
29:17:30.105 --> 29:17:33.105
you'll documentation if you want
to learn more. Even if you're a

28120
29:17:33.105 --> 29:17:37.105
really advanced user, you really
want to try to use as little

28121
29:17:37.105 --> 29:17:41.105
EULA as possible. Because since
it is so much lower level, it is

28122
29:17:42.105 --> 29:17:45.105
much easier to screw things up.
However, like I said, for this

28123
29:17:45.105 --> 29:17:48.105
example, we are going to be
using a little bit of you'll now

28124
29:17:48.105 --> 29:17:51.105
in this proxy that we're going
to be doing, we have this

28125
29:17:51.105 --> 29:17:55.105
delegate function, which inside
this inline assembly, which is

28126
29:17:55.105 --> 29:17:59.105
you'll, it does a whole lot of
really low level stuff. But the

28127
29:17:59.105 --> 29:18:01.105
main thing that it does is it
goes ahead and it does this

28128
29:18:01.105 --> 29:18:05.105
delegate call functionality. If
we look here, we can see it's

28129
29:18:05.105 --> 29:18:09.105
using a fallback function and a
receive function. So whenever it

28130
29:18:09.105 --> 29:18:14.105
receives a function that doesn't
recognize it'll call fallback,

28131
29:18:14.105 --> 29:18:19.105
and fallback calls our delegate
function. So anytime a proxy

28132
29:18:19.105 --> 29:18:23.105
contract receives data for a
function it doesn't recognize it

28133
29:18:23.105 --> 29:18:26.105
sends it over to some
implementation to some

28134
29:18:26.105 --> 29:18:30.105
implementation contract where it
will call it with Delegate call.

28135
29:18:30.105 --> 29:18:34.105
In our minimalistic example
here, we have a function called

28136
29:18:34.105 --> 29:18:37.105
Set implementation, which will
change where those delegate

28137
29:18:37.105 --> 29:18:40.105
calls are going to be sending.
This can be equivalent to like

28138
29:18:40.105 --> 29:18:44.105
upgrading your smart contract.
And then we have implementation

28139
29:18:44.105 --> 29:18:48.105
here to read where that
implementation contract is. Now

28140
29:18:48.105 --> 29:18:51.105
to work with proxies, we really
don't want to have anything in

28141
29:18:51.105 --> 29:18:54.105
storage, because if we do
delegate call, and that delegate

28142
29:18:54.105 --> 29:18:56.105
call changes, some storage,
we're going to screw up our

28143
29:18:56.105 --> 29:19:00.105
contract storage. The one caveat
though to this, we do still need

28144
29:19:00.105 --> 29:19:03.105
to store that implementations
address somewhere, so we can

28145
29:19:03.105 --> 29:19:08.105
call it so ERP 1976. It's called
the standard proxy storage slot,

28146
29:19:08.105 --> 29:19:11.105
which is an Aetherium
improvement proposal for having

28147
29:19:11.105 --> 29:19:15.105
certain storage slots
specifically used for proxies.

28148
29:19:15.105 --> 29:19:19.105
And in our minimalistic example
here, we set bytes 32, private

28149
29:19:19.105 --> 29:19:24.105
constant implementation slot to
that location in storage. And

28150
29:19:24.105 --> 29:19:28.105
we'll say, okay, whatever is
that this storage slot is going

28151
29:19:28.105 --> 29:19:32.105
to be the location of the
implementation address. So the

28152
29:19:32.105 --> 29:19:36.105
way our proxy is going to work
is any contract that calls this

28153
29:19:36.105 --> 29:19:39.105
proxy contract. If it's not this
set implementation function,

28154
29:19:39.105 --> 29:19:42.105
it's going to pass it over to
whatever is inside the

28155
29:19:42.105 --> 29:19:44.105
implementation slot address.
That's what we're going to build

28156
29:19:44.105 --> 29:19:49.105
here. So we have the small proxy
is proxy. And we'll create a

28157
29:19:49.105 --> 29:19:54.105
real minimalistic contract. So
we'll say contract employee,

28158
29:19:54.105 --> 29:20:00.105
mentation A, and we'll just give
it a U and 256. public value and

28159
29:20:00.105 --> 29:20:07.105
then function set value, you add
256 new value, public will say

28160
29:20:07.105 --> 29:20:12.105
value equals new value So this
is going to be our

28161
29:20:12.105 --> 29:20:16.105
implementation. So now anytime
somebody calls small proxy, or

28162
29:20:16.105 --> 29:20:21.105
small proxy contract, it's going
to delegate, call it over to our

28163
29:20:21.105 --> 29:20:26.105
implementation, a, and then save
the storage in our small proxy

28164
29:20:26.105 --> 29:20:30.105
address. So we're going to call
our small proxy with the data to

28165
29:20:30.105 --> 29:20:34.105
use this set value function
selector. So let's make it a

28166
29:20:34.105 --> 29:20:37.105
little easier just to figure out
how to get that data by creating

28167
29:20:37.105 --> 29:20:45.105
a new helper function, do
function, get data to transact.

28168
29:20:45.105 --> 29:20:48.105
And we can get the data using
the API dot encode with

28169
29:20:48.105 --> 29:20:52.105
signature that we learned in an
earlier lesson. So function get

28170
29:20:52.105 --> 29:20:58.105
data to transact, we'll pass it
a un 256 number to update. So

28171
29:20:58.105 --> 29:21:02.105
we'll give this the number we
want to call a new value. We'll

28172
29:21:02.105 --> 29:21:08.105
have this be public pure, that's
going to return a bytes.

28173
29:21:08.105 --> 29:21:14.105
Memory. And we'll just say
return ABI dot ENCODE. With

28174
29:21:14.105 --> 29:21:24.105
signature set value, you went to
56, comma, number to update.

28175
29:21:24.105 --> 29:21:28.105
So you'll remember this from our
call anything section. And if

28176
29:21:28.105 --> 29:21:30.105
you don't remember how to do
that, remember to refer back to

28177
29:21:30.105 --> 29:21:34.105
our NFT section to learn how to
call anything and use ABI dot

28178
29:21:34.105 --> 29:21:38.105
encode ABI dot encode with a
signature and call anything with

28179
29:21:38.105 --> 29:21:42.105
its raw bytes bring and get the
data to transact. And we know

28180
29:21:42.105 --> 29:21:46.105
that when we call implementation
a, from our small proxy, we're

28181
29:21:46.105 --> 29:21:49.105
going to update our small
proxies storage. So we'll create

28182
29:21:49.105 --> 29:21:52.105
a little function in solidity
just to read our storage in

28183
29:21:52.105 --> 29:21:57.105
small proxy. We're gonna say
function, read storage. And this

28184
29:21:57.105 --> 29:22:04.105
will just be a public view, will
do returns, returns you into

28185
29:22:04.105 --> 29:22:11.105
256, value at storage slot,
zero. And we are going to use a

28186
29:22:11.105 --> 29:22:13.105
little bit of assembly here
since we are doing all this low

28187
29:22:13.105 --> 29:22:18.105
level stuff. And we're going to
call the s load up code to read

28188
29:22:18.105 --> 29:22:21.105
the value at storage slot zero,
we'll say value at storage slot

28189
29:22:21.105 --> 29:22:25.105
zero, and we're going to set it
and then in assembly, this is

28190
29:22:25.105 --> 29:22:29.105
how we set things, we're going
to set it equal to s load of

28191
29:22:29.105 --> 29:22:33.105
storage slot zero, and then it
will return this value here. So

28192
29:22:33.105 --> 29:22:36.105
we're reading directly from
storage. Oops, and then we need

28193
29:22:36.105 --> 29:22:40.105
a little parenthese here. Sorry.
So now, let's go ahead and

28194
29:22:40.105 --> 29:22:43.105
deploy our small proxy. And
let's deploy our implementation

28195
29:22:43.105 --> 29:22:47.105
A. Now our small proxy has a
function called Set

28196
29:22:47.105 --> 29:22:51.105
implementation. So we're saying,
okay, anytime we call this proxy

28197
29:22:51.105 --> 29:22:55.105
contract, we're going to
delegate call the functions over

28198
29:22:55.105 --> 29:22:58.105
to here. So we're going to grab
current implementations A's

28199
29:22:58.105 --> 29:23:04.105
address, paste it into set
implementation 77. So this is

28200
29:23:04.105 --> 29:23:08.105
the data of set value you in
256, with that number to update

28201
29:23:08.105 --> 29:23:13.105
encoded in it. So if we call our
small proxy, with this data, our

28202
29:23:13.105 --> 29:23:18.105
proxy contract is gonna go, oh,
okay, this is a function. I

28203
29:23:18.105 --> 29:23:21.105
don't I don't see that function
here. We're going to call our

28204
29:23:21.105 --> 29:23:25.105
fallback, right, which again, is
coming from open Zeplin. And our

28205
29:23:25.105 --> 29:23:28.105
Fallback is going to do this
delegate, which is this low

28206
29:23:28.105 --> 29:23:30.105
level stuff, but it's basically
just doing a delegate call,

28207
29:23:30.105 --> 29:23:33.105
we're gonna call our fallback
function, and then we're gonna

28208
29:23:33.105 --> 29:23:36.105
get the function in the
implementation A, we're gonna

28209
29:23:36.105 --> 29:23:40.105
borrow this function, and we're
gonna use it on our on

28210
29:23:40.105 --> 29:23:44.105
ourselves. So if I copy this,
the implementation has been set

28211
29:23:44.105 --> 29:23:47.105
to being this address down here.
So all the logic is going to be

28212
29:23:47.105 --> 29:23:50.105
done here. So when I go ahead,
and I grabbed this, and paste it

28213
29:23:50.105 --> 29:23:53.105
into call data, and I hit
transact looks like it went

28214
29:23:53.105 --> 29:23:57.105
successfully went through. If I
read storage, now, we see that

28215
29:23:57.105 --> 29:24:01.105
it is indeed 777, which is
incredibly exciting. Now, this

28216
29:24:01.105 --> 29:24:04.105
is incredibly beneficial,
because now let's say we want to

28217
29:24:04.105 --> 29:24:07.105
go and update our code, right?
We don't like contract

28218
29:24:07.105 --> 29:24:10.105
implementation anymore. So let's
go ahead copy contract

28219
29:24:10.105 --> 29:24:14.105
implementation A. And we'll make
a new one called implementation

28220
29:24:14.105 --> 29:24:19.105
B. Now, let's say whenever
somebody calls set value, we do

28221
29:24:19.105 --> 29:24:24.105
value equals new value, plus
one, or plus two. Let's go

28222
29:24:24.105 --> 29:24:29.105
ahead, let's save this. Let's
compile this. And let's deploy

28223
29:24:29.105 --> 29:24:33.105
implementation B, we'll grab
implementation B's contract

28224
29:24:33.105 --> 29:24:37.105
address, we'll call it onset
implementation in our proxy. And

28225
29:24:37.105 --> 29:24:41.105
essentially, we have now
upgraded from implementation a

28226
29:24:41.105 --> 29:24:46.105
to implementation B. Now, if we
use this same data here, we're

28227
29:24:46.105 --> 29:24:51.105
still going to call set value
was 777. But instead, we're now

28228
29:24:51.105 --> 29:24:54.105
delegate calling to
implementation B, instead of

28229
29:24:54.105 --> 29:24:59.105
implementation A. So if I call
if I put this data into the low

28230
29:24:59.105 --> 29:25:02.105
level call data, and I hit
transact, it looks like it went

28231
29:25:02.105 --> 29:25:07.105
through. Now I read storage and
now is 779 since doing value

28232
29:25:07.105 --> 29:25:12.105
equals new value plus two so
this is a minimalistic example

28233
29:25:12.105 --> 29:25:15.105
of how upgrading actually works.
Now, this is incredibly

28234
29:25:15.105 --> 29:25:18.105
beneficial, because we can
always just tell people, Hey,

28235
29:25:18.105 --> 29:25:22.105
make all your function calls to
small proxy, and you'll be good

28236
29:25:22.105 --> 29:25:25.105
to go. But like I said before,
this also means that the

28237
29:25:25.105 --> 29:25:29.105
developers of this protocol can
essentially change the

28238
29:25:29.105 --> 29:25:32.105
underlying logic at any time.
This is why it is so important

28239
29:25:32.105 --> 29:25:36.105
to be sure to read contracts and
check to see who has the

28240
29:25:36.105 --> 29:25:39.105
developer keys. And if a
contract can be updated, if a

28241
29:25:39.105 --> 29:25:41.105
contract can be updated, and a
single person can update it,

28242
29:25:41.105 --> 29:25:44.105
well guess what, you have a
single centralized point of

28243
29:25:44.105 --> 29:25:46.105
failure. And technically the
contract isn't even

28244
29:25:46.105 --> 29:25:49.105
decentralized. Now, something
else I was talking about in the

28245
29:25:49.105 --> 29:25:54.105
video is function clashes
function selector clashes. Right

28246
29:25:54.105 --> 29:25:57.105
now, whenever we call set
implementation, the proxy

28247
29:25:57.105 --> 29:26:00.105
function sedimentation gets
called because we don't trigger

28248
29:26:00.105 --> 29:26:02.105
the fallback because we can see
the function is here. However,

28249
29:26:02.105 --> 29:26:05.105
if I have a function called Set
implementation, in our

28250
29:26:05.105 --> 29:26:08.105
implementation, this one can
never be called, whenever we

28251
29:26:08.105 --> 29:26:12.105
send a function signature of set
implementation, it's always

28252
29:26:12.105 --> 29:26:15.105
going to call the one on the
proxy. This is where the

28253
29:26:15.105 --> 29:26:17.105
transparent proxy that we're
going to be working with can

28254
29:26:17.105 --> 29:26:20.105
help us out here and the
universal upgradable proxy can

28255
29:26:20.105 --> 29:26:22.105
help us to, and I'm not going to
go too much deeper into these

28256
29:26:22.105 --> 29:26:26.105
now. But we've left some links
in the GitHub repository to

28257
29:26:26.105 --> 29:26:29.105
teach you more about these
selector clashes. And how those

28258
29:26:29.105 --> 29:26:32.105
two proxy patterns that I just
mentioned, the transparent and

28259
29:26:32.105 --> 29:26:35.105
universal upgradable can get
around these, if you're confused

28260
29:26:35.105 --> 29:26:37.105
by anything in here, go into
this discussion thread and make

28261
29:26:37.105 --> 29:26:41.105
a new discussion about proxies
make a new discussion about the

28262
29:26:41.105 --> 29:26:44.105
Assembly about the you'll set
implementation, this is a great

28263
29:26:44.105 --> 29:26:47.105
time to connect with other
people taking the course and ask

28264
29:26:47.105 --> 29:26:49.105
questions here, because I know
that this is a really advanced

28265
29:26:49.105 --> 29:26:53.105
section, and requires you
haven't gone through a lot of

28266
29:26:53.105 --> 29:26:55.105
those sub lessons that we've
gone before. And if it takes you

28267
29:26:55.105 --> 29:26:58.105
a couple times of playing around
with solidity and playing around

28268
29:26:58.105 --> 29:27:02.105
with remix, I definitely
recommend you do so this is the

28269
29:27:02.105 --> 29:27:04.105
section we're seeing really is
believing. And I want you to

28270
29:27:04.105 --> 29:27:07.105
jump into remix. And I want you
to test this. And I want you to

28271
29:27:07.105 --> 29:27:10.105
play around with this and see
what you can break and fiddle

28272
29:27:10.105 --> 29:27:13.105
with. But with all that being
said, we finally have all the

28273
29:27:13.105 --> 29:27:16.105
knowledge that we need to build
our hardhat project that deals

28274
29:27:16.105 --> 29:27:22.105
with upgrades. So let's go ahead
and jump into it.

28275
29:27:22.105 --> 29:27:26.105
Your new terminal, we're going
to do MK dir, hard hat,

28276
29:27:26.105 --> 29:27:32.105
upgrades, FCC, CD, hard hat,
upgrades, FCC, and then code

28277
29:27:32.105 --> 29:27:37.105
period, or file, open folder,
this folder here, now I'm going

28278
29:27:37.105 --> 29:27:40.105
to grab that same yarn add we've
been grabbing from less than

28279
29:27:40.105 --> 29:27:43.105
nine, we're gonna paste it in,
we're going to add all of these

28280
29:27:43.105 --> 29:27:46.105
different parameters. And once
again, we're going to copy over

28281
29:27:46.105 --> 29:27:48.105
our hard hat config from
previous sections, we're going

28282
29:27:48.105 --> 29:27:51.105
to copy over prettier. And we're
just going to get our basic

28283
29:27:51.105 --> 29:27:54.105
default setup. At this point,
you might have a setup that

28284
29:27:54.105 --> 29:27:57.105
works best for you and that you
like better. And feel free to

28285
29:27:57.105 --> 29:28:00.105
grab that as well. So I'm going
to paste the prettier is in

28286
29:28:00.105 --> 29:28:03.105
here. And I'm going to paste the
hard hat.config.js that we've

28287
29:28:03.105 --> 29:28:06.105
been using, instead of running
yarn hard hat. And now we should

28288
29:28:06.105 --> 29:28:11.105
be good to go. So let's create a
new folder called contracts. And

28289
29:28:11.105 --> 29:28:15.105
in here, we're going to create a
new file called Box dot soul.

28290
29:28:15.105 --> 29:28:17.105
And then it's this contract,
that's going to be our

28291
29:28:17.105 --> 29:28:21.105
implementation or our logic
contract. So it will say pragma,

28292
29:28:21.105 --> 29:28:28.106
solidity carrot zero point 8.7
contract box will say you into

28293
29:28:28.106 --> 29:28:36.106
256 internal value will do event
value changed you into 256 new

28294
29:28:36.106 --> 29:28:43.106
value, do function store, you
went to 36 value, this will be a

28295
29:28:43.106 --> 29:28:48.106
public function will say value
equals new value. So this store

28296
29:28:48.106 --> 29:28:52.106
function is going to update our
variable at storage slot zero,

28297
29:28:52.106 --> 29:29:00.106
internal, and then we'll just
omit value changed that new

28298
29:29:00.106 --> 29:29:06.106
value. And then we'll just
create function retrieve, which

28299
29:29:06.106 --> 29:29:11.106
will be a public view returns a
UNT 256 We'll just do return

28300
29:29:11.106 --> 29:29:16.106
value. And then we're going to
create a new function called

28301
29:29:16.106 --> 29:29:21.106
version. And this will be a
public door. And that returns a

28302
29:29:21.106 --> 29:29:26.106
un 256. And we're just going to
have this return one. So our box

28303
29:29:26.106 --> 29:29:29.106
contract here is going to be
version one. Now we're going to

28304
29:29:29.106 --> 29:29:34.106
copy all this code, paste it
into a box v two dot soul and

28305
29:29:34.106 --> 29:29:37.106
rename it to contract box v two,
we're going to update the

28306
29:29:37.106 --> 29:29:40.106
version to version two here. And
we're going to create a new

28307
29:29:40.106 --> 29:29:46.106
function called increment. And
this will be a public function.

28308
29:29:46.106 --> 29:29:52.106
And we'll say value equals value
plus one. And then we will emit

28309
29:29:52.106 --> 29:29:57.106
a value changed event with
value. We're going to have one

28310
29:29:57.106 --> 29:30:01.106
contract address originally use
the logic in box and then we're

28311
29:30:01.106 --> 29:30:05.106
going to upgrade it to the logic
in box V two. And we're going to

28312
29:30:05.106 --> 29:30:07.106
learn how to use all the tools
that we've been working with

28313
29:30:07.106 --> 29:30:11.106
here to add this logic and
create this logic And let's just

28314
29:30:11.106 --> 29:30:17.106
make sure this works, we'll do
yarn, or that compile.

28315
29:30:17.106 --> 29:30:22.106
So let's make a readme.md, we'll
say, one, we're going to upgrade

28316
29:30:22.106 --> 29:30:28.106
box to box V two. So we're going
to make a proxy contract, that's

28317
29:30:28.106 --> 29:30:32.106
gonna point to box. And then
later on, we're going to update

28318
29:30:32.106 --> 29:30:37.106
it to point to box V two. Right,
so we're going to start it up

28319
29:30:37.106 --> 29:30:40.106
pointing to box, then we're
going to have it point to box V

28320
29:30:40.106 --> 29:30:42.106
two. And that's how we're going
to upgrade it, one of the first

28321
29:30:42.106 --> 29:30:46.106
things we're going to need to do
is deploy a proxy, we can deploy

28322
29:30:46.106 --> 29:30:49.106
a proxy manually ourselves, and
we can build the proxy contracts

28323
29:30:49.106 --> 29:30:52.106
and do all that stuff. That's
our first option. Hardhead

28324
29:30:52.106 --> 29:30:57.106
deploy also comes built in with
deploying and upgrading proxies

28325
29:30:57.106 --> 29:31:00.106
itself, where we can just
specify that we want to use a

28326
29:31:00.106 --> 29:31:03.106
proxy. And we could specify the
type of proxy that we want to

28327
29:31:03.106 --> 29:31:07.106
use. So number two is just
saying using hard hat deploys,

28328
29:31:07.106 --> 29:31:11.106
built in proxies. And then
number three is open Zeppelin

28329
29:31:11.106 --> 29:31:14.106
actually has an upgrades plugin,
which allows you to write some

28330
29:31:14.106 --> 29:31:16.106
really simple scripts that
allows you to have a really

28331
29:31:16.106 --> 29:31:20.106
simple API like upgrades dot
deploy proxy, and then upgrades

28332
29:31:20.106 --> 29:31:24.106
that upgrade proxy. Now for this
section, we're going to be doing

28333
29:31:24.106 --> 29:31:28.106
the hard hat deploys built in
proxies. However, in the GitHub

28334
29:31:28.106 --> 29:31:31.106
repo associated with this, if
you go to scripts, there's other

28335
29:31:31.106 --> 29:31:34.106
upgrade examples that will show
you how to use the opens up and

28336
29:31:34.106 --> 29:31:37.106
upgrades plugin. And we're not
going to do deploy a proxy

28337
29:31:37.106 --> 29:31:40.106
manually manually, because we
essentially just showed you how

28338
29:31:40.106 --> 29:31:44.106
to do that in our sub lesson. So
we're going to show you this,

28339
29:31:44.106 --> 29:31:46.106
we're going to show you the
Hardhead deploys built in

28340
29:31:46.106 --> 29:31:48.106
proxies, and if you want to use
the openzeppelin upgrades

28341
29:31:48.106 --> 29:31:52.106
plugin, that is available in the
GitHub repo as well. So let's go

28342
29:31:52.106 --> 29:31:55.106
ahead and do this. So we're
going to go ahead and we're

28343
29:31:55.106 --> 29:31:58.106
going to make a new folder, or
deploy folder. And first, we're

28344
29:31:58.106 --> 29:32:03.106
going to make a new file called
a one, deploy box dot j s. And

28345
29:32:03.106 --> 29:32:05.106
this is going to look really
similar to everything we've been

28346
29:32:05.106 --> 29:32:11.106
doing so far. So module dot
exports, equals async function,

28347
29:32:11.106 --> 29:32:15.106
we're going to get named
accounts and deployments. The

28348
29:32:15.106 --> 29:32:20.106
arrow function will say const
deploy COMM A log equals

28349
29:32:20.106 --> 29:32:29.106
deployments const deployer
equals await, get named.

28350
29:32:29.106 --> 29:32:34.106
Accounts, do a little logging,
like this, and then we'll say

28351
29:32:34.106 --> 29:32:42.106
const, box equals await, loi,
box, comma, we'll say from

28352
29:32:42.106 --> 29:32:49.106
Deployer, comma, args like this,
we'll say weight con formations

28353
29:32:49.106 --> 29:32:56.106
is going to be network dot
config dot block confirmations

28354
29:32:56.106 --> 29:33:02.106
for Masons. And yep, we got to
grab const from hard hat. And

28355
29:33:02.106 --> 29:33:06.106
then we can add the parameter in
here for proxies. And this is

28356
29:33:06.106 --> 29:33:10.106
where we can add a ton of
information. So like I said,

28357
29:33:10.106 --> 29:33:12.106
we're going to use the
transparent upgradable proxy

28358
29:33:12.106 --> 29:33:15.106
from open Zeppelin, which if we
want to use it, we're going to

28359
29:33:15.106 --> 29:33:21.106
have to add open Zeppelin. So
we'll do yarn, add dash dash dev

28360
29:33:21.106 --> 29:33:26.106
at open Zeppelin slash
contracts. And we can tell our

28361
29:33:26.106 --> 29:33:31.106
hard hat to deploy this box
contract behind a proxy will say

28362
29:33:31.106 --> 29:33:39.106
the proxy contract is going to
be the open Zeppelin transparent

28363
29:33:39.106 --> 29:33:45.106
proxy. And we're also going to
do a via admin contract. So

28364
29:33:45.106 --> 29:33:49.106
instead of having an admin
address, for the proxy contract,

28365
29:33:49.106 --> 29:33:52.106
we're going to have the proxy
contract owned by an admin

28366
29:33:52.106 --> 29:33:55.106
contract. And doing it this way
is considered a best practice

28367
29:33:55.106 --> 29:33:59.106
for a number of reasons. But
we'll name this admin contract,

28368
29:33:59.106 --> 29:34:08.106
box proxy admin and the artifact
for this box proxy admin. So

28369
29:34:08.106 --> 29:34:12.106
we'll need to create a box proxy
admin contract to be the admin

28370
29:34:12.106 --> 29:34:17.106
of our box. So in our contracts
folder, create a new folder

28371
29:34:17.106 --> 29:34:23.106
called proxy. And in here, a new
file called Box proxy admin that

28372
29:34:23.106 --> 29:34:26.106
saw and this is going to be the
admin contract we're going to

28373
29:34:26.106 --> 29:34:30.106
have for controlling the proxy
of our box so inbox proxy admin

28374
29:34:30.106 --> 29:34:41.106
dot Saul will do SP DX license.
I then to fire MIT pragma

28375
29:34:41.106 --> 29:34:45.106
solidity, carrot zero, point
8.7,

28376
29:34:45.106 --> 29:34:51.106
say contract, box proxy admin,
like this, right? And once

28377
29:34:51.106 --> 29:34:55.106
again, we're going to use one of
the open Zetland tools in the

28378
29:34:55.106 --> 29:34:59.106
transparent folder. They have a
proxy admin dot Saul, which is

28379
29:34:59.106 --> 29:35:02.106
going to be essentially what our
box proxy admin is going to be.

28380
29:35:02.106 --> 29:35:05.106
It has some functionality, it
has some functions in here like

28381
29:35:05.106 --> 29:35:09.106
change, proxy admin, upgrade,
upgrade and call for dealing

28382
29:35:09.106 --> 29:35:12.106
with upgrades. All contracts. So
we're going to import it will do

28383
29:35:12.106 --> 29:35:18.106
import at open Zeppelin slash
contracts slash proxy slash

28384
29:35:18.106 --> 29:35:24.106
transparent, slash proxy admin,
dot soul. And we'll say our

28385
29:35:24.106 --> 29:35:30.106
Brock's box proxy admin is proxy
admin, like this. And to have

28386
29:35:30.106 --> 29:35:34.106
this box proxy admin work with
the heart at deploy plugin, our

28387
29:35:34.106 --> 29:35:37.106
constructor needs to take an
address owner as an input

28388
29:35:37.106 --> 29:35:40.106
parameter, but we're just going
to leave that blank. And then,

28389
29:35:40.106 --> 29:35:42.106
and then we need to do the proxy
admin, which is just going to be

28390
29:35:42.106 --> 29:35:45.106
blank as well. And that's it.
That's all we're going to do box

28391
29:35:45.106 --> 29:35:49.106
proxy admin contract, which just
has all of the functionalities

28392
29:35:49.106 --> 29:35:52.106
to do upgrades and change proxy
admin and all this stuff. We're

28393
29:35:52.106 --> 29:35:56.106
going to deploy our box contract
behind a proxy and opens up and

28394
29:35:56.106 --> 29:36:00.106
transparent proxy that is owned
by our Brock's proxy admin

28395
29:36:00.106 --> 29:36:04.106
contract in the template
Aetherium contracts. GitHub repo

28396
29:36:04.106 --> 29:36:08.106
is actually an examples slash
opens up on proxies branch that

28397
29:36:08.106 --> 29:36:12.106
will show you how to work with
different types of proxies. And

28398
29:36:12.106 --> 29:36:14.106
there will be a link to this in
the GitHub repo associated with

28399
29:36:14.106 --> 29:36:20.106
this course. And then we'll do
our verification, say, chains

28400
29:36:20.106 --> 29:36:24.106
dot includes. And we'll go
ahead, I'm going to copy paste

28401
29:36:24.106 --> 29:36:27.106
our hard hat helper config from
our last project, which has

28402
29:36:27.106 --> 29:36:31.106
development chains, hard hat and
local host that we export, will

28403
29:36:31.106 --> 29:36:36.106
import this as well. const
development chains equals

28404
29:36:36.106 --> 29:36:42.106
require dot slash helper hard
hat config. If development

28405
29:36:42.106 --> 29:36:48.106
chains dot includes network dot
name, and process dot env dot

28406
29:36:48.106 --> 29:36:54.106
ether scan API key log,
verifying that the same as we've

28407
29:36:54.106 --> 29:36:59.106
done a way to verify last, we're
going to copy over our utils

28408
29:36:59.106 --> 29:37:03.106
folder. So just copy, paste, we
now have verify, which will

28409
29:37:03.106 --> 29:37:11.106
import it in here. So we'll do
const verify equals require dot

28410
29:37:11.106 --> 29:37:17.106
dot slash utils, slash verify,
await verify box dot address.

28411
29:37:17.106 --> 29:37:20.106
And then args is going to be
blank. So we'll just do blank

28412
29:37:20.106 --> 29:37:25.106
here, and boom. And that's going
to be it for our box deployment.

28413
29:37:25.106 --> 29:37:29.106
So we can test this out by
running yarn Hardhead deploy,

28414
29:37:29.106 --> 29:37:33.106
see if everything works here.
And that's it done. And then we

28415
29:37:33.106 --> 29:37:38.106
should do actually, we should
add log beach true as well.

28416
29:37:38.106 --> 29:37:41.106
Let's run this again, much
better. So you can see we

28417
29:37:41.106 --> 29:37:44.106
actually deploy a couple of
contracts. So we deploy our box

28418
29:37:44.106 --> 29:37:48.106
proxy admin, which is going to
be our admin contract, then we

28419
29:37:48.106 --> 29:37:53.106
deploy box implementation. So
hard hat deploy, went ahead and

28420
29:37:53.106 --> 29:37:57.106
took our box contract and
renamed it to box implementation

28421
29:37:57.106 --> 29:38:02.106
and then deployed it, then it
deployed our box proxy here. So

28422
29:38:02.106 --> 29:38:05.106
anytime we call this address, it
actually will point to the logic

28423
29:38:05.106 --> 29:38:10.106
of our box. Now what we can do
is we can write a deploy script

28424
29:38:10.106 --> 29:38:14.106
to deploy box, the box v2
implementation, and then upgrade

28425
29:38:14.106 --> 29:38:19.106
our box to box V to create a new
deploy script called Zero to

28426
29:38:19.106 --> 29:38:25.106
deploy box v2 dot j s or deploy
box two dot j s. And we'll do

28427
29:38:25.106 --> 29:38:28.106
something really similar here.
Right, so I'm just going to copy

28428
29:38:28.106 --> 29:38:34.106
pretty much of this, paste it in
here. Now we're going to do

28429
29:38:34.106 --> 29:38:44.106
const box v two equals await,
deploy. Box v two, comma, from

28430
29:38:44.106 --> 29:38:53.106
Deployer. Log True RMS blank,
weights confirmations, it's

28431
29:38:53.106 --> 29:38:59.106
going to be network dot config
dot lock.

28432
29:38:59.106 --> 29:39:04.106
Or masons, then I'm going to
copy the verification code, copy

28433
29:39:04.106 --> 29:39:08.106
this, paste it here, server,
this is going to be box v2 dot

28434
29:39:08.106 --> 29:39:13.106
address. Okay, great. So we now
have some code where we can

28435
29:39:13.106 --> 29:39:17.106
deploy box and box v2. Now let's
go ahead and write a script to

28436
29:39:17.106 --> 29:39:23.106
actually upgrade these. So we'll
do a new folder, scripts. New

28437
29:39:23.106 --> 29:39:28.106
File, and we'll call it upgrade
box dot j s. Now we're going to

28438
29:39:28.106 --> 29:39:30.106
do it the manual way here. And
the reason we're going to do it

28439
29:39:30.106 --> 29:39:33.106
the manual way is because I want
to show you exactly the

28440
29:39:33.106 --> 29:39:36.106
functions that we're calling to
do this upgrade process.

28441
29:39:36.106 --> 29:39:40.106
However, hard hat deploy also
comes with an API to make it

28442
29:39:40.106 --> 29:39:43.106
really easy to actually just
upgrade your box contracts. This

28443
29:39:43.106 --> 29:39:47.106
is gonna be script. So we'll
start off with async function

28444
29:39:47.106 --> 29:39:52.106
main. And then we'll copy paste
our traditional script, main dot

28445
29:39:52.106 --> 29:39:54.106
then process exit blah, blah,
blah, that whole thing. We're

28446
29:39:54.106 --> 29:39:59.106
first gonna get the box proxy
admin contract. We'll say box

28447
29:39:59.106 --> 29:40:07.106
const. Box, proxy admin equals
await ethers dot get contract,

28448
29:40:07.106 --> 29:40:11.106
box proxy admin and we got to
import you Here's from Hardhead,

28449
29:40:11.106 --> 29:40:14.106
then we're going to get the
actual proxy, which is our

28450
29:40:14.106 --> 29:40:20.106
transparent proxy. So we'll say
const transparent proxy equals

28451
29:40:20.106 --> 29:40:26.106
await ethers dot get contract,
box underscore proxy. Since hard

28452
29:40:26.106 --> 29:40:28.106
hat deploy, we'll just name the
proxy the name of the

28453
29:40:28.106 --> 29:40:32.106
implementation underscore proxy.
And then of course, we're going

28454
29:40:32.106 --> 29:40:37.106
to need our box V to contract.
So say const. Box v two equals

28455
29:40:37.106 --> 29:40:44.106
await ethers dot get contract,
box V two. Now we can say const,

28456
29:40:44.106 --> 29:40:50.106
upgrade TX equals a weight box
proxy admin, that upgrade. And

28457
29:40:50.106 --> 29:40:54.106
we're going to call the upgrade
function on our box proxy admin,

28458
29:40:54.106 --> 29:40:56.106
which calls it on our
transparent proxy, which will

28459
29:40:56.106 --> 29:41:01.106
change the implementation from
box one to box two. So box proxy

28460
29:41:01.106 --> 29:41:05.106
admin, that upgrade, we're going
to upgrade the transparent proxy

28461
29:41:05.106 --> 29:41:14.106
dot address to our box B to that
address, it will look in our box

28462
29:41:14.106 --> 29:41:18.106
proxy, a box proxy has an
upgrade function which calls

28463
29:41:18.106 --> 29:41:21.106
upgrade to on our transparent
upgradeable proxy will do a

28464
29:41:21.106 --> 29:41:26.106
weight upgrade TX dot wait one.
And now to work with the

28465
29:41:26.106 --> 29:41:31.106
functions on our box v two,
we're gonna say const proxy box

28466
29:41:31.106 --> 29:41:38.106
equals await ethers dot get
contract. At box v two, we're

28467
29:41:38.106 --> 29:41:42.106
going to get the box v two ABI
however, we're going to load it

28468
29:41:42.106 --> 29:41:48.106
at the transparent proxy
address. This way ethers knows

28469
29:41:48.106 --> 29:41:51.106
okay, we're going to call all of
our functions on the transparent

28470
29:41:51.106 --> 29:41:55.106
proxy address. But this proxy
box is going to have the ABI of

28471
29:41:55.106 --> 29:42:00.106
box v2, which is what we want.
Now we can say const version

28472
29:42:00.106 --> 29:42:05.106
equals await proxy box dot
version. And we'll say console

28473
29:42:05.106 --> 29:42:10.106
dot log version. And if we want
to compare this to its original

28474
29:42:10.106 --> 29:42:14.106
implementation, before we
upgrade, we can do the same

28475
29:42:14.106 --> 29:42:18.106
thing. We can say const proxy
box v1, let's actually call this

28476
29:42:18.106 --> 29:42:23.106
proxy box V to say cost proxy
box v one is going to be this

28477
29:42:23.106 --> 29:42:26.106
exact same thing

28478
29:42:26.106 --> 29:42:34.106
equals this call box here. And
we'll do const version equals

28479
29:42:34.106 --> 29:42:41.106
weight, right proxy box v1 dot
version, console dot log

28480
29:42:41.106 --> 29:42:47.106
version, or version v1, version
v1. We'll call this version v

28481
29:42:47.106 --> 29:42:53.106
two, version v two, and proxy
box V two. So we'll get our

28482
29:42:53.106 --> 29:42:57.106
version v one will upgrade. And
then we'll see at that same

28483
29:42:57.106 --> 29:43:01.106
address what the version
function now returns. So let's

28484
29:43:01.106 --> 29:43:07.106
open our terminal. If I run
yarn, our head node will spin up

28485
29:43:07.106 --> 29:43:12.106
a node will have deployed our
admin our implementation, our

28486
29:43:12.106 --> 29:43:17.106
proxy, and then our box V to
implementation. I'll make a new

28487
29:43:17.106 --> 29:43:23.106
terminal. And I'll run yarn,
hard hat run scripts upgrade box

28488
29:43:23.106 --> 29:43:28.106
that J S dash dash network,
local host. And we should see

28489
29:43:28.106 --> 29:43:31.106
that box actually update. And
that's exactly what we see. And

28490
29:43:31.106 --> 29:43:34.106
then let's do well, it's I
forgot to do.to string in here.

28491
29:43:34.106 --> 29:43:38.106
But it goes from version one to
version two on that exact same

28492
29:43:38.106 --> 29:43:41.106
address. And with that little
code, we have successfully

28493
29:43:42.106 --> 29:43:45.106
learned how to upgrade our smart
contracts programmatically. Now,

28494
29:43:45.106 --> 29:43:49.106
like I said, in the GitHub repo
associated with this lesson, you

28495
29:43:49.106 --> 29:43:53.106
can also check out the upgrades
plugin from open Zeppelin. So to

28496
29:43:53.106 --> 29:43:56.106
work with that, you would just
do upgrades dot deploy proxy

28497
29:43:56.106 --> 29:44:01.106
proxy to call the Prepare
upgrade function, and then

28498
29:44:01.106 --> 29:44:05.106
upgrade upgrade proxy just like
that. They also have an upgrade

28499
29:44:05.106 --> 29:44:07.106
tutorial, step by step for
hardhat that you can follow

28500
29:44:07.106 --> 29:44:10.106
along with as well. Now I know
this was an advanced section.

28501
29:44:10.106 --> 29:44:14.106
And I know we went a little bit
quick here. But honestly, if you

28502
29:44:14.106 --> 29:44:16.106
just finish this section, not
only have you completed all

28503
29:44:16.106 --> 29:44:19.106
these other sections that make
you a really powerful smart

28504
29:44:19.106 --> 29:44:22.106
contract developer. But you've
learned some really advanced

28505
29:44:22.106 --> 29:44:26.106
stuff here. We've gone into low
level code like delegate call,

28506
29:44:26.106 --> 29:44:29.106
we've gotten to assembly we've
gotten to you'll we've gotten to

28507
29:44:29.106 --> 29:44:33.106
these proxy patterns, which can
really make you a an incredible

28508
29:44:33.106 --> 29:44:37.106
stand out developer in the smart
contract space. So if you just

28509
29:44:37.106 --> 29:44:40.106
finished this section, you
should be so so proud of

28510
29:44:40.106 --> 29:44:42.106
yourself because we went really
fast and because there's a lot

28511
29:44:42.106 --> 29:44:46.106
of advanced information here.
Now, like I said, 100 percent, be sure

28512
29:44:46.106 --> 29:44:50.106
to go into the discussions tab
and ask questions and connect

28513
29:44:50.106 --> 29:44:53.106
and talk to other people in the
area. Maybe look at the already

28514
29:44:53.106 --> 29:44:57.106
running discussions and jump in
and start asking other students

28515
29:44:57.106 --> 29:45:00.106
and start asking other people
about what they've learned and

28516
29:45:00.106 --> 29:45:02.106
how their proxies are going. And
if they made anything really

28517
29:45:02.106 --> 29:45:05.106
cool. If you're just excited and
you want to go to the show and

28518
29:45:05.106 --> 29:45:07.107
tell section, make a show and
tell me like hey, here's my

28519
29:45:07.107 --> 29:45:11.107
GitHub repo for doing this
upgrade section. going here and

28520
29:45:11.107 --> 29:45:14.107
be excited with that being said
go and take that coffee break go

28521
29:45:14.107 --> 29:45:18.107
take that walk go to the gym go
get excited Go tell your friends

28522
29:45:18.107 --> 29:45:22.107
we are almost done we have two
lessons left and then you're

28523
29:45:22.107 --> 29:45:26.107
home free

28524
29:45:26.107 --> 29:45:30.107
All right, welcome back to
lesson 17 For hardhat. Douse,

28525
29:45:30.107 --> 29:45:34.107
you're almost done. Now for this
section, I've actually already

28526
29:45:34.107 --> 29:45:37.107
made a video on how to code a
dowel with TypeScript and

28527
29:45:37.107 --> 29:45:41.107
solidity in JavaScript. So we're
actually just going to play this

28528
29:45:41.107 --> 29:45:43.107
video for this section. The
reason we're going to display

28529
29:45:43.107 --> 29:45:45.107
this one is because I did a lot
of work to make this one look

28530
29:45:45.107 --> 29:45:49.107
really good. And it's still
incredibly up to date. So this

28531
29:45:49.107 --> 29:45:52.107
is going to be in TypeScript and
solidity. However, we're going

28532
29:45:52.107 --> 29:45:56.107
to have the JavaScript edition
of the code base in this code

28533
29:45:56.107 --> 29:45:58.107
from the video section. If you
want the most up to date version

28534
29:45:58.107 --> 29:46:02.107
of this delta template code, you
can use, you can select this up

28535
29:46:02.107 --> 29:46:05.107
to date code, which goes to this
doubt template repo. I'll be

28536
29:46:05.107 --> 29:46:09.107
updating this repo periodically
with new Dao examples and new

28537
29:46:09.107 --> 29:46:11.107
ways to create doubts or
decentralized autonomous

28538
29:46:11.107 --> 29:46:14.107
organizations. Now, before we
learn how to code a doubt, we

28539
29:46:14.107 --> 29:46:17.107
should learn what the DAO is.
And again, I've already made a

28540
29:46:17.107 --> 29:46:19.107
video that I've put a lot of
work into. So we're going to

28541
29:46:19.107 --> 29:46:22.107
watch what a Dow is from a high
level first, then we're going to

28542
29:46:22.107 --> 29:46:25.107
learn how to code a Dow. And
then our last section is going

28543
29:46:25.107 --> 29:46:27.107
to be security and auditing. And
we're going to finish this out.

28544
29:46:27.107 --> 29:46:32.107
So Bucklin, let's learn what a
Dow is. And then let's go ahead

28545
29:46:32.107 --> 29:46:39.107
and build a Dow, let's do it.
Now, daos for decentralized

28546
29:46:39.107 --> 29:46:43.107
autonomous organizations is a
bit of an overloaded term. But

28547
29:46:43.107 --> 29:46:46.107
it typically describes any group
that is governed by a

28548
29:46:46.107 --> 29:46:49.107
transparent set of rules found
on a blockchain or smart

28549
29:46:49.107 --> 29:46:53.107
contract. And I say overloaded
because some people say bitcoin

28550
29:46:53.107 --> 29:46:55.107
is down because the miners can
choose whether or not to upgrade

28551
29:46:55.107 --> 29:46:58.107
their software. Other people
think that Dows must use

28552
29:46:58.107 --> 29:47:01.107
transparent smart contracts,
which have the rules ingrained

28553
29:47:01.107 --> 29:47:03.107
right into them. And then other
people think Tao is just a

28554
29:47:03.107 --> 29:47:06.107
buzzword, so they just slap the
name relay on to any

28555
29:47:06.107 --> 29:47:08.107
organization so that they can
get some clout. And this makes

28556
29:47:08.107 --> 29:47:14.107
for sad, Patrick. And it's not
to be confused with the Dow,

28557
29:47:14.107 --> 29:47:17.107
which was an implementation of a
Dow back in 2016, which set the

28558
29:47:17.107 --> 29:47:20.107
record for the largest hack at
that time. So there's a lot of

28559
29:47:20.107 --> 29:47:23.107
different ways to think about
and the Dow term is used in a

28560
29:47:23.107 --> 29:47:25.107
lot of different ways. But in
essence, imagine if all of the

28561
29:47:25.107 --> 29:47:29.107
users of Google were given
voting power into what Google

28562
29:47:29.107 --> 29:47:32.107
should do next. And the rules of
the voting was immutable,

28563
29:47:32.107 --> 29:47:37.107
transparent, and decentralized.
This solves an age old problem

28564
29:47:37.107 --> 29:47:40.107
of trust, centrality and
transparency, and giving the

28565
29:47:40.107 --> 29:47:43.107
power to the users of different
protocols and applications

28566
29:47:43.107 --> 29:47:46.107
instead of everything happening
behind closed doors. And this

28567
29:47:46.107 --> 29:47:49.107
voting piece is a cornerstone of
how these operate this

28568
29:47:49.107 --> 29:47:52.107
Decentralized Governance, if you
will, and it can be summarized

28569
29:47:52.107 --> 29:47:56.107
by company or organization
operated exclusively through

28570
29:47:56.107 --> 29:47:58.107
code. And to really understand
all this, we're going to look

28571
29:47:58.107 --> 29:48:02.107
under the hood of the protocol
that's setting the precedent for

28572
29:48:02.107 --> 29:48:05.107
all other doubts and compound,
then once we look at compound,

28573
29:48:05.107 --> 29:48:08.107
we'll understand what goes into
building one of these and all

28574
29:48:08.107 --> 29:48:10.107
the trade offs, all the
different architectural choices

28575
29:48:10.107 --> 29:48:14.107
mean for your group. And then in
my next video, I'm gonna have a

28576
29:48:14.107 --> 29:48:17.107
full coat along tutorial for
developers looking to build one

28577
29:48:17.107 --> 29:48:19.107
of these themselves. But be
absolutely sure to watch the

28578
29:48:19.107 --> 29:48:21.107
rest of this video because it's
going to give you all the

28579
29:48:21.107 --> 29:48:24.107
architectural fundamentals. So
you can make intelligent

28580
29:48:24.107 --> 29:48:27.107
decisions when you get to that
section. And be sure that you

28581
29:48:27.107 --> 29:48:29.107
and your Dow friends smash the
like and subscribe button. So we

28582
29:48:29.107 --> 29:48:33.107
can keep giving you the best
engineer first content on the

28583
29:48:33.107 --> 29:48:34.107
planet when

28584
29:48:34.107 --> 29:48:37.107
it comes to smart contracts.
Let's get into it. So here we

28585
29:48:37.107 --> 29:48:40.107
have the compound protocol. It's
a borrowing and lending

28586
29:48:40.107 --> 29:48:44.107
application that allows users to
borrow and lend their assets.

28587
29:48:44.107 --> 29:48:46.107
And everything about this
application is built in smart

28588
29:48:46.107 --> 29:48:49.107
contracts. Now, oftentimes,
they're gonna want to do a lot

28589
29:48:49.107 --> 29:48:52.107
of new things, maybe they want
to add a new token to allow

28590
29:48:52.107 --> 29:48:55.107
borrowing and lending, maybe
they're gonna want to change

28591
29:48:55.107 --> 29:48:57.107
some of the API parameters,
maybe they're gonna want to

28592
29:48:57.107 --> 29:48:59.107
block certain coins, there's a
lot of different things that

28593
29:48:59.107 --> 29:49:02.107
they might want to do. So that's
where we're gonna go ahead to

28594
29:49:02.107 --> 29:49:07.107
governance, this is where you
can find a user interface for

28595
29:49:07.107 --> 29:49:10.107
list of all the proposals and
all the different ballots that

28596
29:49:10.107 --> 29:49:13.107
came to be. So here's a list of
some of the governance proposals

28597
29:49:13.107 --> 29:49:16.107
that this protocol has actually
been making to improve. And

28598
29:49:16.107 --> 29:49:18.107
let's look at one of these
proposals that's currently

28599
29:49:18.107 --> 29:49:21.107
actually in process. So if we
click on the proposal, we

28600
29:49:21.107 --> 29:49:25.107
actually see everything about
this proposal, who voted for who

28601
29:49:25.107 --> 29:49:28.107
voted against and the proposal
history here. Now, the first

28602
29:49:28.107 --> 29:49:30.107
thing to one of these proposals
is somebody has to actually

28603
29:49:30.107 --> 29:49:33.107
create the proposal in a
proposed transaction. And we

28604
29:49:33.107 --> 29:49:37.107
actually see that proposed
transaction right here. If we

28605
29:49:37.107 --> 29:49:40.107
click on this, and we scroll
down, we can actually see the

28606
29:49:40.107 --> 29:49:43.107
exact parameters they used to
make this proposal. Let's go

28607
29:49:44.107 --> 29:49:47.107
ahead and decode the input data.
And we can see this is exactly

28608
29:49:47.107 --> 29:49:49.107
what this proposal looks like.
The way that they're typically

28609
29:49:49.107 --> 29:49:53.107
divided is they have a list of
addresses and the list of

28610
29:49:53.107 --> 29:49:55.107
functions to call on those
addresses. And then obviously,

28611
29:49:55.107 --> 29:49:59.107
the parameters to pass those
addresses. So this proposal is

28612
29:49:59.107 --> 29:50:03.107
saying, Hey, I would like to
call Support Market on this

28613
29:50:03.107 --> 29:50:07.107
address, set reserve factor on
this address. Here are the

28614
29:50:07.107 --> 29:50:10.107
parameters we're going to pass.
They're obviously encoded with

28615
29:50:10.107 --> 29:50:13.107
bytes. And then here's the
description string of what this

28616
29:50:13.107 --> 29:50:16.107
is doing and why we're actually
doing this. The reason we have

28617
29:50:16.107 --> 29:50:19.107
to do this proposal governance
process is that these contracts

28618
29:50:19.107 --> 29:50:22.107
likely have access controls
where only the owner of these

28619
29:50:22.107 --> 29:50:25.107
contracts can actually call
these Do functions, and the

28620
29:50:25.107 --> 29:50:28.107
owner of these two contracts is
likely going to be this

28621
29:50:28.107 --> 29:50:31.107
governance style. And values.
Zero just means that we're not

28622
29:50:31.107 --> 29:50:34.107
going to send any eath along
with these transactions, once a

28623
29:50:34.107 --> 29:50:38.107
proposal has been created, after
a short delay to becomes active,

28624
29:50:38.107 --> 29:50:40.107
and this is when people can
actually start voting on them,

28625
29:50:41.107 --> 29:50:44.107
this delay between a proposal
and an act of vote can be

28626
29:50:44.107 --> 29:50:47.107
changed or modified, depending
on your doubt, then people have

28627
29:50:47.107 --> 29:50:50.107
some time to start voting on
them. And if it passes, which

28628
29:50:50.107 --> 29:50:54.107
this one overwhelmingly did, it
reaches succeeded, we click on

28629
29:50:54.107 --> 29:50:57.107
this transaction again, and we
go to the compound governance

28630
29:50:57.107 --> 29:51:02.107
contract. And we scroll down to
contract, right as proxy, we can

28631
29:51:02.107 --> 29:51:08.107
actually see the exact function
that the people call to vote,

28632
29:51:08.107 --> 29:51:12.107
namely cast by vote, cast, vote
by signature and cast vote with

28633
29:51:12.107 --> 29:51:15.107
reason. We'll talk a little bit
about the exact differences

28634
29:51:15.107 --> 29:51:18.107
between these in our next video.
But these are the functions that

28635
29:51:18.107 --> 29:51:22.107
they're actually calling. And if
you go to the compound app, and

28636
29:51:22.107 --> 29:51:25.107
we go over to vote, this is a
user interface you can actually

28637
29:51:25.107 --> 29:51:29.107
vote through to make it easier
if you're not as tech savvy. So

28638
29:51:29.107 --> 29:51:32.107
you can vote right through this
app dot compound at finance. Or

28639
29:51:32.107 --> 29:51:35.107
you can just send the
transaction yourself. Once all

28640
29:51:35.107 --> 29:51:39.107
those votes happen. It reaches
this queued stage. Now what is

28641
29:51:39.107 --> 29:51:43.107
queued mean? Well, before a
proposal actually becomes

28642
29:51:43.107 --> 29:51:47.107
active, there's a minimum delay
between a proposal passing and a

28643
29:51:47.107 --> 29:51:51.107
proposal being executed. So
somebody has to call this cute

28644
29:51:51.107 --> 29:51:55.107
function. And it only can be
called if a vote passes. And it

28645
29:51:55.107 --> 29:51:58.107
says, OK, that postal ID has
been cued, and we're going to

28646
29:51:58.107 --> 29:52:03.107
execute it soon. Now, if we go
to a different proposal, like

28647
29:52:03.107 --> 29:52:05.107
this one, for example, we can
see it has been executed, we can

28648
29:52:05.107 --> 29:52:10.107
see somebody called this
executed function. And they

28649
29:52:10.107 --> 29:52:13.107
executed Proposal A detail. So
this is going to be a full

28650
29:52:13.107 --> 29:52:17.107
example of the lifecycle of a
proposal going through this

28651
29:52:17.107 --> 29:52:21.107
process. Now there are a couple
that even failed, a whole bunch

28652
29:52:21.107 --> 29:52:23.107
of people voted against this.
And if you scroll down, you can

28653
29:52:23.107 --> 29:52:26.107
see it was created, it was
active, and the majority of

28654
29:52:26.107 --> 29:52:30.107
people voted against. So that's
where it stops. Now oftentimes,

28655
29:52:30.107 --> 29:52:32.107
just putting one of these
proposals through isn't enough

28656
29:52:32.107 --> 29:52:36.107
to really garner some votes for
it, you generally want a forum

28657
29:52:36.107 --> 29:52:40.107
or some type of discussion place
to talk about these proposals

28658
29:52:40.107 --> 29:52:42.107
and why you liked them or don't
like them. Oftentimes, a

28659
29:52:42.107 --> 29:52:45.107
discourse is one of the main
places that people are going to

28660
29:52:45.107 --> 29:52:48.107
argue for why something is good,
or why something is bad. So

28661
29:52:48.107 --> 29:52:52.107
people can vote on these
changes. And again, snapshot

28662
29:52:52.107 --> 29:52:54.107
might be one of these tools that
you use to figure out if your

28663
29:52:54.107 --> 29:52:57.107
community even wants something
before it even goes to vote, you

28664
29:52:57.107 --> 29:53:01.107
can join one of these, and with
your tokens actually vote on

28665
29:53:01.107 --> 29:53:03.107
things without them being
executed just to get the

28666
29:53:03.107 --> 29:53:06.107
sentiment or like I said before,
you could build your protocol in

28667
29:53:06.107 --> 29:53:08.107
a way that snapshot actually
helps you with the voting

28668
29:53:08.107 --> 29:53:11.107
process. All right, now you've
seen the protocol that has been

28669
29:53:11.107 --> 29:53:14.107
influencing all the other
details on how to vote. Now, you

28670
29:53:14.107 --> 29:53:17.107
know, now that we know what a
doubt looks like,

28671
29:53:17.107 --> 29:53:19.107
let's talk about the
architecture and tools that go

28672
29:53:19.107 --> 29:53:21.107
into building one of these and
additionally the trade offs that

28673
29:53:21.107 --> 29:53:24.107
they have. And the first thing
to talk about here is going to

28674
29:53:24.107 --> 29:53:27.107
be the voting mechanism. Now
voting in Decentralized

28675
29:53:27.107 --> 29:53:31.107
Governance is critical to these
days, because sometimes they do

28676
29:53:31.107 --> 29:53:34.107
need to update and change to
keep up with the times. Not all

28677
29:53:34.107 --> 29:53:37.107
protocols need to have a Dow,
but those that do need to have a

28678
29:53:37.107 --> 29:53:40.107
doubt need a way for the
participants to engage. This is

28679
29:53:40.107 --> 29:53:43.107
one of the most important
questions to ask him to tell

28680
29:53:43.107 --> 29:53:47.107
your communities. How do I
participate? How do I engage in

28681
29:53:47.107 --> 29:53:51.107
this doubt? How do I help make
decisions and you'll find this

28682
29:53:51.107 --> 29:53:55.107
is a bit of a tricky problem to
solve. Now, an easy approach to

28683
29:53:55.107 --> 29:53:59.107
this problem is going to be
using an ERC 20 or an NFT token

28684
29:53:59.107 --> 29:54:02.107
as voting power. Similar to what
we saw with compound use the

28685
29:54:02.107 --> 29:54:06.107
comp token to vote for different
proposals seems simple enough,

28686
29:54:06.107 --> 29:54:09.107
right? Boom, problem solved
gray. Now, this actually might

28687
29:54:09.107 --> 29:54:12.107
be the right approach for
certain doubts. But it also runs

28688
29:54:12.107 --> 29:54:15.107
the risk of actually being less
fair. Because when you tokenize

28689
29:54:15.107 --> 29:54:18.107
the voting power, you're
essentially auctioning off this

28690
29:54:18.107 --> 29:54:21.107
voting power to whoever's got
the deepest pockets, whoever has

28691
29:54:21.107 --> 29:54:25.107
the most money gets to pick the
changes. So if it's only the

28692
29:54:25.107 --> 29:54:28.107
rich people who get to vote,
then it's highly likely that all

28693
29:54:28.107 --> 29:54:31.107
the changes in the protocol are
going to benefit the rich, which

28694
29:54:31.107 --> 29:54:34.107
doesn't really seem like that
great of an improvement over our

28695
29:54:34.107 --> 29:54:37.107
current world. And if T's are
interesting, because they have

28696
29:54:37.107 --> 29:54:41.107
this non fungible component, but
yet, even they still run into

28697
29:54:41.107 --> 29:54:43.107
this issue. Additionally, if you
buy a whole bunch of votes, you

28698
29:54:43.107 --> 29:54:46.107
make a bad decision and then
sell all your votes. You as an

28699
29:54:47.107 --> 29:54:49.107
individual don't really get
punished, you just punish the

28700
29:54:49.107 --> 29:54:52.107
group as a whole. But you being
malicious, you can get away with

28701
29:54:52.107 --> 29:54:55.107
pretty scot free now again, this
voting mechanism is going to be

28702
29:54:55.107 --> 29:55:00.107
correct for some groups, but for
other groups, maybe not. It

28703
29:55:00.107 --> 29:55:02.107
really just depends on what your
down community setup is going to

28704
29:55:02.107 --> 29:55:04.107
look like. Now the next one
we're going to talk about is

28705
29:55:04.107 --> 29:55:07.107
skin in the game. Now metallic
has actually written a lot about

28706
29:55:07.107 --> 29:55:10.107
this and I highly recommend you
read his article, link in the

28707
29:55:10.107 --> 29:55:13.107
description to see that the skin
in the game method means that

28708
29:55:13.107 --> 29:55:16.107
whenever you make a decision,
your vote is recorded. And if

28709
29:55:16.107 --> 29:55:21.107
that decision leads to a bad
outcome, your tokens are axed.

28710
29:55:21.107 --> 29:55:25.107
You get punished for making evil
or bad decisions for your Dao

28711
29:55:25.107 --> 29:55:27.107
and your protocol. I like this
mentality because even if you

28712
29:55:27.107 --> 29:55:30.107
buy a ton of tokens and decide
to be ill with it, you can be

28713
29:55:30.107 --> 29:55:33.107
held accountable for your bad
decisions. Now, the hardest part

28714
29:55:33.107 --> 29:55:37.107
about this, though, is gonna be
how do we decide as a community?

28715
29:55:37.107 --> 29:55:40.107
What is bad outcome? How do we
actually punish these people?

28716
29:55:40.107 --> 29:55:45.107
And that's easy, because the
answer is, I'm not sure. Now,

28717
29:55:45.107 --> 29:55:48.107
the third method of this voting
mechanism is probably one of the

28718
29:55:48.107 --> 29:55:51.107
most interesting ones, but also
the hardest ones to implement.

28719
29:55:51.107 --> 29:55:55.107
And this is proof of personhood,
or participation. Imagine that

28720
29:55:55.107 --> 29:55:58.107
all users of the compound
protocol were given a single

28721
29:55:58.107 --> 29:56:02.107
vote simply because they use the
protocol. And even if they had

28722
29:56:02.107 --> 29:56:06.107
1000 wallets, they use the
protocol. One human being means

28723
29:56:06.107 --> 29:56:09.107
one vote, this would be amazing,
and a far more fair

28724
29:56:09.107 --> 29:56:11.107
implementation where votes
couldn't actually just be

28725
29:56:11.107 --> 29:56:14.107
bought. The issue, however,
comes in something known as

28726
29:56:14.107 --> 29:56:19.107
civil resistance, how can we be
sure that it's one vote equals

28727
29:56:19.107 --> 29:56:22.107
one participant and not one
participant pretending to be

28728
29:56:22.107 --> 29:56:25.107
1000s of different people, so
they get more votes. This method

28729
29:56:25.107 --> 29:56:27.107
hasn't really been solved yet.
But I'm willing to bet some very

28730
29:56:27.107 --> 29:56:30.107
clever engineer will do some
amazing chainlink integration,

28731
29:56:30.107 --> 29:56:33.107
because proof of personhood is
basically just off chain data

28732
29:56:33.107 --> 29:56:36.107
that can be delivered on chain.
And that's exactly where

28733
29:56:36.107 --> 29:56:39.107
channeling shines. Now, as you
can see all of these methods and

28734
29:56:39.107 --> 29:56:42.107
even more that you probably
think of aren't that far

28735
29:56:42.107 --> 29:56:45.107
fetched. And we actually see
these exact same methods

28736
29:56:45.107 --> 29:56:48.107
happening in the real world.
Proof of personhood or proof of

28737
29:56:48.107 --> 29:56:51.107
participation might just be the
exact same as kind of the

28738
29:56:51.107 --> 29:56:54.107
regular government voting that
we see every day. In the United

28739
29:56:54.107 --> 29:56:57.107
States, at least one person gets
to vote for one president, you

28740
29:56:57.107 --> 29:57:00.107
can't go around making a whole
bunch of fake people and voting

28741
29:57:00.107 --> 29:57:03.107
for president. But in companies
the ERC 20 voting standard kind

28742
29:57:03.107 --> 29:57:07.107
of applies, the more shares of a
company you have maybe the more

28743
29:57:07.107 --> 29:57:09.107
voting power you have in that
company. So we can draw

28744
29:57:09.107 --> 29:57:11.107
parallels between the real world
and how voting and governance is

28745
29:57:11.107 --> 29:57:14.107
going to work in our smart
contracts. And in fact, you

28746
29:57:14.107 --> 29:57:17.107
should draw parallels and look
for inspiration from the web to

28747
29:57:17.107 --> 29:57:19.107
space. Now when it comes to
implementation of the voting, I

28748
29:57:19.107 --> 29:57:22.107
put them into two categories on
chain voting and off chain

28749
29:57:22.107 --> 29:57:25.107
voting on chain voting is
exactly what we saw with

28750
29:57:25.107 --> 29:57:29.107
compound, the smart contract on
chain, your voter, you call some

28751
29:57:29.107 --> 29:57:32.107
function called vote with your
meta mask your ledger or

28752
29:57:32.107 --> 29:57:36.107
whatever, send a transaction and
vote, you voted Congrats, you

28753
29:57:36.107 --> 29:57:38.107
can wear your little sticker now
call that function and you send

28754
29:57:38.107 --> 29:57:43.107
a transaction, you send a
transaction, what are the

28755
29:57:43.107 --> 29:57:47.107
transactions use that are kind
of annoying and kind of costly?

28756
29:57:47.107 --> 29:57:49.107
Oh, that's right gas, I imagine
you have 10,000 people in your

28757
29:57:49.107 --> 29:57:53.107
community and it costs $100 To
vote per person, you're now

28758
29:57:53.107 --> 29:57:57.107
costing your community $1
million. Anytime you want to

28759
29:57:57.107 --> 29:57:59.107
change anything. This is
obviously insane, and not very

28760
29:57:59.107 --> 29:58:01.107
sustainable for your community
pro here is that the

28761
29:58:02.107 --> 29:58:04.107
architecture is really easy.
Everything's going to be

28762
29:58:04.107 --> 29:58:06.107
transparent, everything's going
to be on chain. And that's

28763
29:58:06.107 --> 29:58:09.107
really good. But yes, the con is
that you're going to break the

28764
29:58:09.107 --> 29:58:11.107
bank account for a lot of people
potentially. Now there are a lot

28765
29:58:11.107 --> 29:58:14.107
of variations of this to help
solve some of these problems,

28766
29:58:14.107 --> 29:58:17.107
especially the gas problem. One
of the ones that I'm incredibly

28767
29:58:17.107 --> 29:58:20.107
excited for is this one called
governor's seat, where they use

28768
29:58:20.107 --> 29:58:23.107
some random sampling to do some
quadratic voting to help reduce

28769
29:58:23.107 --> 29:58:26.107
costs while increasing civil
resistance. You want to learn

28770
29:58:26.107 --> 29:58:28.107
more about that one to be sure
to read about it in the

28771
29:58:28.107 --> 29:58:31.107
description. So on chain voting
is the simplest one here. But

28772
29:58:31.107 --> 29:58:36.107
let's talk about off chain
voting. To cast the vote off to

28773
29:58:36.107 --> 29:58:39.107
decentralized context, relax,
relax, you can vote off chain

28774
29:58:39.107 --> 29:58:42.107
and still have the 100%
decentralized, you can actually

28775
29:58:42.107 --> 29:58:46.107
sign a transaction and sign a
vote without actually sending to

28776
29:58:46.107 --> 29:58:49.107
a blockchain and therefore
without actually spending any

28777
29:58:49.107 --> 29:58:53.107
gas. Instead, what you can do is
send that signed transaction to

28778
29:58:53.107 --> 29:58:57.107
a decentralized database like
IPFS, count up all the votes in

28779
29:58:57.107 --> 29:59:01.107
IPFS. And then when time comes,
deliver the result of that data

28780
29:59:01.107 --> 29:59:03.107
through something like an Oracle
like chain link to the

28781
29:59:03.107 --> 29:59:06.107
blockchain all in a single
transaction. Alternatively, what

28782
29:59:06.107 --> 29:59:10.107
you could do is you could replay
all the same transactions in a

28783
29:59:10.107 --> 29:59:13.107
single transaction to save gas,
this can reduce the voting cost

28784
29:59:13.107 --> 29:59:16.107
by up to 99%. Right now, this is
an implementation and one of the

28785
29:59:16.107 --> 29:59:20.107
most popular ways to do this is
through snapshot. And I'm just

28786
29:59:20.107 --> 29:59:22.107
dying for someone to make a
chain link integration because

28787
29:59:23.107 --> 29:59:26.107
it's going to be so much safer,
more secure and better and blah,

28788
29:59:26.107 --> 29:59:28.107
blah, blah, die for it. This is
your call to action go build

28789
29:59:28.107 --> 29:59:31.107
this thing. This option. voting
mechanism obviously saves a ton

28790
29:59:31.107 --> 29:59:35.107
of gas to the community and can
be a more efficient way to store

28791
29:59:35.107 --> 29:59:37.107
these transactions anyways,
however, it needs to be

28792
29:59:37.107 --> 29:59:40.107
implemented very carefully. If
you run your entire Dow through

28793
29:59:40.107 --> 29:59:43.107
a centralized Oracle, you are
essentially reintroducing a

28794
29:59:43.107 --> 29:59:45.107
centralized intermediary and
ruining the decent quality of

28795
29:59:45.107 --> 29:59:48.107
your application. So don't do
that. And if you made it to this

28796
29:59:48.107 --> 29:59:50.107
point of the video, give
yourself a little pat on the

28797
29:59:50.107 --> 29:59:53.107
back. You're doing fantastic.
Fantastic. Like I said, I have a

28798
29:59:53.107 --> 29:59:56.107
video coming out after this one
it's going to show you end to

28799
29:59:56.107 --> 29:59:59.107
end how to build one of these
from scratch let's learn about

28800
29:59:59.107 --> 30:00:02.107
some of the tools that you can
use to help get you up to speed

28801
30:00:02.107 --> 30:00:04.107
quicker. Now there are a number
of no code solutions that can go

28802
30:00:04.107 --> 30:00:10.107
into building one of these
dowels Tao stack Aragon. Just

28803
30:00:10.107 --> 30:00:13.107
kidding, this is Aragon, colony
and Tao house are all

28804
30:00:13.107 --> 30:00:16.107
alternatives that can actually
help you with the upside of

28805
30:00:16.107 --> 30:00:19.107
running a Dao and building a
doubt. However, if you want more

28806
30:00:19.107 --> 30:00:21.107
granular control and you don't
want to have to pay any the fees

28807
30:00:21.107 --> 30:00:24.107
associated with these protocols,
you might want to Do it from

28808
30:00:24.107 --> 30:00:26.107
scratch. Now let's talk about
some of the more Cody solutions

28809
30:00:26.107 --> 30:00:29.107
that you can use snapshot is one
of the most popular tools out

28810
30:00:29.107 --> 30:00:32.107
there for both getting the
sentiment of a Dao. And actually

28811
30:00:32.107 --> 30:00:35.107
performing that execution, users
can vote through this protocol

28812
30:00:35.107 --> 30:00:39.107
with their actual tokens, those
transaction gets stored in IPFS.

28813
30:00:39.107 --> 30:00:42.107
But none of it actually gets
executed. Unless the doubt

28814
30:00:42.107 --> 30:00:46.107
chooses to, this can be a great
way to get a feel for what your

28815
30:00:46.107 --> 30:00:50.107
Dow wants to do. And Optionally,
you can send the transactions

28816
30:00:50.107 --> 30:00:53.107
and execute the votes as well
highly recommend checking out

28817
30:00:53.107 --> 30:00:56.107
Zodiac which is a suite of
database tools for you to

28818
30:00:56.107 --> 30:00:59.107
implement into your Dallas as
well tally is another one of

28819
30:00:59.107 --> 30:01:02.107
these UIs that allows people to
see and actually vote and

28820
30:01:02.107 --> 30:01:04.107
interact with these smart
contracts through user

28821
30:01:04.107 --> 30:01:06.107
interface. So those of you who
don't know about Gnosis safe,

28822
30:01:06.107 --> 30:01:10.107
you absolutely should know Safe
is a multi SIG wallet. And the

28823
30:01:10.107 --> 30:01:12.107
reason I put this on the list,
even though it's adds kind of

28824
30:01:12.107 --> 30:01:15.107
this centrality component is
that most dowels in the

28825
30:01:15.107 --> 30:01:18.107
beginning, are probably going to
start with some type of

28826
30:01:18.107 --> 30:01:20.107
centrality, it's much easier to
be fast when you don't have

28827
30:01:20.107 --> 30:01:23.107
1000s of people to wait for a
vote. And in the beginning, any

28828
30:01:23.107 --> 30:01:26.107
protocol is going to be
centralized to some degree

28829
30:01:26.107 --> 30:01:29.107
anyways, using a multisig, we're
voting happens through only a

28830
30:01:29.107 --> 30:01:32.107
few key members can be good in
the beginning for your dials,

28831
30:01:32.107 --> 30:01:36.107
and often emergencies as well.
But just keep in mind, when you

28832
30:01:36.107 --> 30:01:39.107
add one of these, you are adding
this level of centrality, and

28833
30:01:39.107 --> 30:01:41.107
then of course opens up and
contracts we love opens up and

28834
30:01:41.107 --> 30:01:43.107
contracts. These are the
contracts that we're going to be

28835
30:01:43.107 --> 30:01:46.107
basing our Dao code along.
Alright, so that's all the

28836
30:01:46.107 --> 30:01:49.108
tools. That's the architecture.
One more thing before I let you

28837
30:01:49.108 --> 30:01:52.108
go legality, the future of Dows
is interesting for all these

28838
30:01:53.108 --> 30:01:55.108
reasons we just talked about,
but especially on a legal front,

28839
30:01:55.108 --> 30:01:58.108
does it make sense for a doubt
to live by the same regulation

28840
30:01:58.108 --> 30:02:01.108
as another company? Why would
you even force it down to do

28841
30:02:01.108 --> 30:02:03.108
something, you'd have to enforce
them to all vote a certain way

28842
30:02:03.108 --> 30:02:07.108
if the government tells you to,
it's a little gray, it's hard to

28843
30:02:07.108 --> 30:02:09.108
nail down who to even keep
accountable for these days and

28844
30:02:09.108 --> 30:02:12.108
the United States at least you
can actually form your own Dow

28845
30:02:12.108 --> 30:02:15.108
and have it legally recognized
in the state of Wyoming. This is

28846
30:02:15.108 --> 30:02:18.108
something I want to do. So we'll
just have to see what happens

28847
30:02:18.108 --> 30:02:22.108
there. Oh, at this point, you
have been injected with all the

28848
30:02:22.108 --> 30:02:25.108
Dow knowledge you need to
succeed and thrive with this new

28849
30:02:26.108 --> 30:02:29.108
amazing technology and these new
amazing concepts. And I found

28850
30:02:29.108 --> 30:02:32.108
them kill baby. All right, well,
you heard him it's time to

28851
30:02:32.108 --> 30:02:36.108
build. Like we said, All the
code is going to be located in

28852
30:02:36.108 --> 30:02:44.108
less than 17 Here, let's jump
in.

28853
30:02:44.108 --> 30:02:46.108
In this video, we're going to
show you how to build your own

28854
30:02:46.108 --> 30:02:51.108
doubt inspired by compound now
this is going to be 100% on

28855
30:02:51.108 --> 30:02:53.108
chain voting and on chain
governance. We're going to show

28856
30:02:53.108 --> 30:02:57.108
you the easiest way to spin up
an NFT or ERC 20 voting type

28857
30:02:57.108 --> 30:03:00.108
down all using solidity and
hardhat. Now if you haven't

28858
30:03:00.108 --> 30:03:03.108
watched my last video going over
the architecture of Dows, what

28859
30:03:03.108 --> 30:03:05.108
goes into one of these be
absolutely sure to watch that

28860
30:03:05.108 --> 30:03:08.108
video first and then come to
this video. Because that video

28861
30:03:08.108 --> 30:03:10.108
explains all the philosophy
behind what we're doing here

28862
30:03:10.108 --> 30:03:13.108
we're going to be using opens up
and contracts and a hard hat

28863
30:03:13.108 --> 30:03:16.108
framework to build this all in
solidity. If you want to see a

28864
30:03:16.108 --> 30:03:18.108
brand new or Pythonic version of
doing this, check the link in

28865
30:03:18.108 --> 30:03:20.108
the description because we did a
video over at the chainlink

28866
30:03:20.108 --> 30:03:23.108
hackathon recently. And
additionally, additionally, we

28867
30:03:23.108 --> 30:03:27.108
know that because we're doing
this 100% on chain gas fees are

28868
30:03:27.108 --> 30:03:30.108
going to be expensive. So I'm
really looking forward to

28869
30:03:30.108 --> 30:03:33.108
somebody doing a chain link plus
IPFS plus snapshot integration

28870
30:03:33.108 --> 30:03:36.108
so that we can do all this off
chain. And once that exists, you

28871
30:03:36.108 --> 30:03:38.108
already know I'm gonna make a
tutorial on that. And if you

28872
30:03:38.108 --> 30:03:41.108
like this style of content, be
sure to smash that like button,

28873
30:03:41.108 --> 30:03:43.108
subscribe and leave a comment in
the comment section to let me

28874
30:03:43.108 --> 30:03:45.108
know what you want to see. Next,
let me know how you want to

28875
30:03:45.108 --> 30:03:48.108
supercharge your smart contract
developer experience. So let's

28876
30:03:48.108 --> 30:03:52.108
jump in. Right, so here's what
we're going to be building,

28877
30:03:52.108 --> 30:03:55.108
we're gonna have a very basic
smart contract here, right, it's

28878
30:03:55.108 --> 30:04:00.108
called box and all it can do is
store a value and then retrieve

28879
30:04:00.108 --> 30:04:04.108
a value. But the thing is, its
ownable. And only the owner of

28880
30:04:04.108 --> 30:04:07.108
this contract can call the store
function and guess who the owner

28881
30:04:07.108 --> 30:04:10.108
is going to be the owner is
going to be the doubt. So only

28882
30:04:10.108 --> 30:04:14.108
through a process of governance,
can anyone store a different

28883
30:04:14.108 --> 30:04:16.108
function here. And once we're
done, we're going to go through

28884
30:04:16.108 --> 30:04:20.108
the entire process of proposing
voting queueing and then

28885
30:04:20.108 --> 30:04:25.108
executing a transaction in a Dao
to update our Bach contract. And

28886
30:04:25.108 --> 30:04:27.108
that's one of the beautiful
things about these these Dao

28887
30:04:27.108 --> 30:04:30.108
setups is that they're
completely modular, right. And

28888
30:04:30.108 --> 30:04:33.108
so when I go through the whole
process, I'll do Hardhead tests

28889
30:04:33.108 --> 30:04:36.108
here, which my tests right now
are set up to just do

28890
30:04:36.108 --> 30:04:40.108
everything, we're going to see
every single step that this Dow

28891
30:04:40.108 --> 30:04:44.108
is going to take. So we see box
starting value is going to be

28892
30:04:44.108 --> 30:04:47.108
zero. And then all of this stuff
is going to the governance

28893
30:04:47.108 --> 30:04:49.108
process. These are just some
some notes. Basically people are

28894
30:04:49.108 --> 30:04:53.108
voting, queueing and executing.
And then at the end, we chained

28895
30:04:53.108 --> 30:04:58.108
the value of the box contract
through a voting process. And

28896
30:04:58.108 --> 30:05:00.108
that's exactly what we're gonna
show you how to do today. Now

28897
30:05:00.108 --> 30:05:03.108
remember all the code for what
we're going to be doing here is

28898
30:05:03.108 --> 30:05:06.108
in my doubt template GitHub repo
so if you ever get lost, feel

28899
30:05:06.108 --> 30:05:10.108
free to refer back to this to
get started. And additionally,

28900
30:05:10.108 --> 30:05:13.108
if you want to see the Pythonic
version of this, feel free to go

28901
30:05:13.108 --> 30:05:16.108
back to the downmix The main
thing is though that all the

28902
30:05:16.108 --> 30:05:19.108
contracts are going to be the
same no matter what brownie hard

28903
30:05:19.108 --> 30:05:22.108
hat, dab tools, foundry, it
doesn't matter. So the first

28904
30:05:22.108 --> 30:05:25.108
part of this section is gonna be
exactly the same. And here's our

28905
30:05:26.108 --> 30:05:29.108
agenda here. First, we're gonna
write the smart contract. So if

28906
30:05:29.108 --> 30:05:31.108
you're not familiar with
Hardhead, who cares, we're gonna

28907
30:05:31.108 --> 30:05:33.108
be doing the smart contracts
first, then we are going to

28908
30:05:33.108 --> 30:05:35.108
write deployment scripts. And
this is where your hard hat

28909
30:05:35.108 --> 30:05:38.108
knowledge is going to come into
play. We're going to be writing

28910
30:05:38.108 --> 30:05:40.108
our deployment scripts in
TypeScript here, because

28911
30:05:40.108 --> 30:05:42.108
TypeScript is phenomenal. If
you're unfamiliar with

28912
30:05:42.108 --> 30:05:45.108
TypeScript, I challenge you to
rewrite this in JavaScript and

28913
30:05:45.108 --> 30:05:47.108
make a JavaScript version. And
then finally, we're going to

28914
30:05:47.108 --> 30:05:51.108
write some scripts to interact
with our governance with our

28915
30:05:51.108 --> 30:05:54.108
deployed contracts. Now, a quick
note, this isn't how I

28916
30:05:54.108 --> 30:05:57.108
originally built this, I didn't
just read smart contracts, write

28917
30:05:57.108 --> 30:05:59.108
deployment scripts, write the
scripts, and then the tests and

28918
30:05:59.108 --> 30:06:02.108
boom, I was done, I had a back
and forth between tests, smart

28919
30:06:02.108 --> 30:06:05.108
contracts, deploy scripts, etc.
If you're thinking, Oh, my

28920
30:06:05.108 --> 30:06:07.108
goodness, that's so easy for him
to go through this. So

28921
30:06:07.108 --> 30:06:10.108
seamlessly. When I originally
wrote this code, it was a lot of

28922
30:06:10.108 --> 30:06:12.108
back and forth. And that's how
you should be developing, you're

28923
30:06:12.108 --> 30:06:14.108
going to be moving between tests
and smart contracts and stuff.

28924
30:06:14.108 --> 30:06:17.108
Additionally, in this tutorial,
we are going to show you some

28925
30:06:17.108 --> 30:06:20.108
sick Hardhead skills. So you are
not only gonna learn how to

28926
30:06:20.108 --> 30:06:23.108
build a Dow, but you're gonna
learn some really advanced

28927
30:06:23.108 --> 30:06:28.108
Hardhead skills. So let's jump
in. Let's do this. So the code

28928
30:06:28.108 --> 30:06:30.108
editor I'm using is Visual
Studio code. So make sure you

28929
30:06:30.108 --> 30:06:34.108
have a code editor up and ready
to go. And you'll need a couple

28930
30:06:34.108 --> 30:06:38.108
of prerequisites here. Again,
the prerequisites are in the

28931
30:06:38.108 --> 30:06:41.108
GitHub repository, we're going
to need Git, no J, s. And yarn,

28932
30:06:41.108 --> 30:06:44.108
if you want to just clone this
repo and follow the instructions

28933
30:06:44.108 --> 30:06:47.108
here to get started, you
absolutely 100% can and then you

28934
30:06:47.108 --> 30:06:49.108
don't even need to build this
from scratch. But we're going to

28935
30:06:49.108 --> 30:06:51.108
want to learn to build this from
scratch. So let's just start git

28936
30:06:51.108 --> 30:06:56.108
dash dash version. Great, we
have Git no dash dash version.

28937
30:06:56.108 --> 30:06:59.108
Great, we have node, and then
yarn dash dash version. Great,

28938
30:06:59.108 --> 30:07:01.108
we have yarn, we can get
started. So everything that

28939
30:07:01.108 --> 30:07:04.108
we're going to be installing
here for packages is going to be

28940
30:07:04.108 --> 30:07:07.108
a dev dependency. So the first
thing we need to do is do yarn,

28941
30:07:07.108 --> 30:07:10.108
add dash dash Dev, hard hat,

28942
30:07:10.108 --> 30:07:13.108
if you'd haven't already. And
now in our folder, we're gonna

28943
30:07:13.108 --> 30:07:17.108
have node modules package dot
JSON readme and a lock. Of

28944
30:07:17.108 --> 30:07:20.108
course, now that we have that we
can run yarn RDAP, we're gonna

28945
30:07:20.108 --> 30:07:23.108
get the hard hat CLI up. And
we're going to have all this

28946
30:07:23.108 --> 30:07:25.108
stuff in here, we're just going
to create an empty hardhat dot

28947
30:07:25.108 --> 30:07:28.108
config dot j s, and we're going
to turn it to TypeScript. The

28948
30:07:28.108 --> 30:07:30.108
advanced sample TypeScript
project has a bunch of stuff

28949
30:07:30.108 --> 30:07:32.108
that I don't like. So we're just
going to create an empty

28950
30:07:32.108 --> 30:07:35.108
hardhead.config.js. And perfect,
we've got a little hard

28951
30:07:35.108 --> 30:07:39.108
hat.config.js. Now let's go
ahead and create a folder, or

28952
30:07:39.108 --> 30:07:42.108
contracts folder. And this is
where we're going to add all of

28953
30:07:42.108 --> 30:07:44.108
our contracts. So the first
thing contract that we're going

28954
30:07:44.108 --> 30:07:48.108
to need is the contracts we want
to have govern, which in our

28955
30:07:48.108 --> 30:07:52.108
case is going to be box dot
soul. Now, I am actually just

28956
30:07:52.108 --> 30:07:55.108
going to copy paste my box, that
soul here, because it's not

28957
30:07:55.108 --> 30:07:58.108
particularly interesting. But
you could really code whatever

28958
30:07:58.108 --> 30:08:01.108
you want here. So feel free to
pause the video, copy paste from

28959
30:08:01.108 --> 30:08:04.108
my GitHub repo, create your own
governance contract that you

28960
30:08:04.108 --> 30:08:06.108
want to play with, or do
whatever you want here. But for

28961
30:08:06.108 --> 30:08:09.108
us, we just have a store
function, and retrieve function,

28962
30:08:09.108 --> 30:08:12.108
and an event, and then a private
value that we're going to be

28963
30:08:12.108 --> 30:08:16.108
storing and retrieving. And
that's it. So of course, we want

28964
30:08:16.108 --> 30:08:19.108
to fix this. We're importing
from openzeppelin contracts

28965
30:08:19.108 --> 30:08:23.108
opens up is amazing. We're gonna
want to add this we'll do yarn,

28966
30:08:23.108 --> 30:08:27.108
add dash dash Dev, at opens up
on contracts. And that should

28967
30:08:27.108 --> 30:08:32.108
get rid of the box. That's all.
let's reopen box. And boom,

28968
30:08:32.108 --> 30:08:34.108
looks like we did a detour to
that perfect. And for

28969
30:08:34.108 --> 30:08:38.108
extensions, I'm using the
solidity, the one Blonko, slit

28970
30:08:38.108 --> 30:08:40.108
extension. And that's what we
get this wonderful linting

28971
30:08:40.108 --> 30:08:43.108
things here. Great. So now we
want to check to see if this

28972
30:08:43.108 --> 30:08:46.108
compiles if using remix, you can
compile with remix hard hat,

28973
30:08:46.108 --> 30:08:49.108
you're gonna see how we compile
here. Or if you're using you

28974
30:08:49.108 --> 30:08:52.108
know, Browning, we just want to
see if this compiles correctly.

28975
30:08:52.108 --> 30:08:56.108
So run yarn had a hard hit
Compile. Looks like we ran into

28976
30:08:56.108 --> 30:08:59.108
some compilation errors, because
we need to update this, let's

28977
30:08:59.108 --> 30:09:02.108
use these 8.8 of solidity we'll
try to compile again. And

28978
30:09:02.108 --> 30:09:05.108
perfect looks like we're
compiling successfully. Look

28979
30:09:05.108 --> 30:09:09.108
here, we do indeed have our
contract in here. Okay, perfect,

28980
30:09:09.108 --> 30:09:12.108
easy part out of the way.
Already. That was so quick. Now

28981
30:09:12.108 --> 30:09:14.108
let's start creating the next
part. Let's create the

28982
30:09:14.108 --> 30:09:17.108
governance part. So what we're
going to be working with to

28983
30:09:17.108 --> 30:09:21.108
build this governance platform
is we're gonna be building it

28984
30:09:21.108 --> 30:09:24.108
off of the ERC. 20 standard, so
you're gonna get an ERC 20

28985
30:09:24.108 --> 30:09:27.108
token. And that's going to be
the token that you get to vote.

28986
30:09:27.108 --> 30:09:32.108
So let's create a new file
called governance token. That's

28987
30:09:32.108 --> 30:09:36.108
all governance token dot Sol.
And this is gonna be the code

28988
30:09:36.108 --> 30:09:38.108
for the token that we use to
actually vote. Now we're going

28989
30:09:38.108 --> 30:09:42.108
to create a normal ERC 20 token.
And then we're going to extend

28990
30:09:42.108 --> 30:09:44.108
it to make it governance a bowl
and you'll understand what I

28991
30:09:44.108 --> 30:09:49.108
mean in a second. So let's go
ahead and make this spdx license

28992
30:09:49.108 --> 30:09:56.108
identifier. It's going to be MIT
pragma solidity we'll do zero

28993
30:09:56.108 --> 30:10:01.108
point 8.8. And then we'll do
contract governance token, and

28994
30:10:01.108 --> 30:10:04.108
then we'll say is ERC 20 I'm
just gonna go ahead and import

28995
30:10:04.108 --> 30:10:07.108
openzeppelin Because open
Zeppelin has a package where

28996
30:10:07.108 --> 30:10:10.108
basically has everything we need
for an ERC 20 token. So we're

28997
30:10:10.108 --> 30:10:13.108
gonna say import at open
Zeppelin slash contracts slash

28998
30:10:13.108 --> 30:10:20.108
token slash ERC 20x We can go to
their github openzeppelin

28999
30:10:20.108 --> 30:10:25.108
contracts token, your C 20 And
we'll do ERC 20 Dotto, we'll do

29000
30:10:25.108 --> 30:10:27.108
this for now.

29001
30:10:27.108 --> 30:10:31.108
token, use your C 20 ditzel.
We're gonna change this, but

29002
30:10:31.108 --> 30:10:35.108
don't worry about that yet. Now
we're going to do a un 256

29003
30:10:35.108 --> 30:10:39.108
Public Storage Max supply, it's
the best practice, but it's

29004
30:10:39.108 --> 30:10:42.108
fine, we'll give this a max
supply this much was going to be

29005
30:10:42.108 --> 30:10:48.108
1-234-567-8910 12345678. So it's
gonna be 1 million, we're gonna

29006
30:10:48.108 --> 30:10:50.108
do 1 million of these tokens.
And then we're gonna create the

29007
30:10:50.108 --> 30:10:57.108
constructor construct or your C
20. Give it governance token as

29008
30:10:57.108 --> 30:11:00.108
a name, and then our symbol is
going to be GT. And for those

29009
30:11:00.108 --> 30:11:04.108
who who don't know, when you
inherit another contract in your

29010
30:11:04.108 --> 30:11:07.108
constructor, you can use that
inherited contracts constructor

29011
30:11:07.108 --> 30:11:10.108
as well. In fact, I think you
have to So governance token G

29012
30:11:10.108 --> 30:11:14.108
team, and then we'll even call
one of these ERC 20 functions

29013
30:11:14.108 --> 30:11:18.108
called mint. And we'll mint to
message dot sender, so whoever

29014
30:11:18.108 --> 30:11:21.108
deploys this ERC 20 contract
will just meant them everything,

29015
30:11:21.108 --> 30:11:24.108
the whole Max supply. Now
normally, if this was a normal

29016
30:11:24.108 --> 30:11:28.108
ERC 20 token, you'd be all done.
But this isn't a normal ERC 20

29017
30:11:28.108 --> 30:11:31.108
token. See, when we do votes, we
need to make sure that it's

29018
30:11:31.108 --> 30:11:36.108
fair, imagine this for a second,
someone knows a hot proposal is

29019
30:11:36.108 --> 30:11:42.108
coming up, they want to vote on.
So they just buy a ton of

29020
30:11:42.108 --> 30:11:47.108
tokens. And then they dump it
after the votes over. We want to

29021
30:11:47.108 --> 30:11:50.108
avoid this. We want to avoid
people just buying and selling

29022
30:11:50.108 --> 30:11:53.108
tokens to get in on governance.
So what we do is we actually

29023
30:11:53.108 --> 30:11:57.108
create a snapshot of how many
tokens people have at a certain

29024
30:11:57.108 --> 30:12:04.108
block snapshot of tokens people
have at a certain block. And we

29025
30:12:04.108 --> 30:12:06.108
want to make sure once a
proposal goes through, we

29026
30:12:06.108 --> 30:12:09.108
actually pick a snapshot from
the past that we want to use

29027
30:12:09.108 --> 30:12:12.108
this kind of incentivizes people
to not just jump in when it's a

29028
30:12:12.108 --> 30:12:16.108
proposal and jump out because
once a proposal hits, it uses a

29029
30:12:16.108 --> 30:12:19.108
block snapshot from the past. So
we're actually going to need to

29030
30:12:19.108 --> 30:12:22.108
change this a little bit. We're
gonna change this from ERC 20 to

29031
30:12:23.108 --> 30:12:27.108
an ERC 20 votes, and we can
actually see this in open

29032
30:12:27.108 --> 30:12:32.108
Zeppelin and the extensions
slash ERC 20 votes that soul

29033
30:12:32.108 --> 30:12:37.108
contract. If we go back to IRS
to their GitHub, we can see ERC

29034
30:12:37.108 --> 30:12:39.108
20 votes, they also have a
snapshot, which is pretty

29035
30:12:39.108 --> 30:12:42.108
similar. And some of the main
functions are it has these

29036
30:12:42.108 --> 30:12:46.108
checkpoints. So these
checkpoints are basically Hey,

29037
30:12:46.108 --> 30:12:49.108
what is the snapshot? There's a
number of checkpoints, you can

29038
30:12:49.108 --> 30:12:52.108
also delegate your tokens to
different people. So maybe

29039
30:12:52.108 --> 30:12:54.108
you're not going to be available
to actually vote. So you say,

29040
30:12:54.108 --> 30:12:57.108
Hey, I'm gonna give my tokens to
somebody else. You can get how

29041
30:12:57.108 --> 30:13:02.108
many votes somebody has passed,
votes get passed, or was apply

29042
30:13:02.108 --> 30:13:06.108
it has all these functions that
make this token, much better as

29043
30:13:06.108 --> 30:13:09.108
a voting tool. Right makes it
much much better. So we're gonna

29044
30:13:09.108 --> 30:13:12.108
say our contracts governance
token is ERC 20 votes and we

29045
30:13:12.108 --> 30:13:17.108
just have to add additional
constructor, this ERC 20 permit,

29046
30:13:17.108 --> 30:13:20.108
I'm sorry, I kind of copied
pasted that. So ERC 20 permit

29047
30:13:20.108 --> 30:13:24.108
governance token. And right now
we have a governance token that

29048
30:13:24.108 --> 30:13:27.108
is a little bit more capable of
doing actual voting, right,

29049
30:13:27.108 --> 30:13:31.108
because as the snapshot has this
delegating functionality, it has

29050
30:13:31.108 --> 30:13:34.108
these checkpoints, it's going to
be much better for doing votes

29051
30:13:34.108 --> 30:13:37.108
in a fair way. The only thing
that we need to do though, is we

29052
30:13:37.108 --> 30:13:40.108
need to add some overrides,
right. And we're just gonna say

29053
30:13:40.108 --> 30:13:47.108
the functions below our
overrides required by solidity.

29054
30:13:47.108 --> 30:13:50.108
And this part is a little bit
boring. So I'm just going to

29055
30:13:50.108 --> 30:13:54.108
copy paste it, feel free to copy
paste it from my GitHub. But

29056
30:13:54.108 --> 30:13:58.108
what we're doing is anytime we
do this after token transfer,

29057
30:13:58.108 --> 30:14:02.108
and the time we transfer a
token, we want to make sure that

29058
30:14:02.108 --> 30:14:05.108
we call the after token transfer
of the ERC 20 votes. And the

29059
30:14:05.108 --> 30:14:08.108
reason that we do this is
because we want to make sure

29060
30:14:08.108 --> 30:14:11.108
that the snapshots are updated,
right, we want to make sure that

29061
30:14:11.108 --> 30:14:15.108
we know how many people have how
many tokens at each block. Same

29062
30:14:15.108 --> 30:14:18.108
thing with the mint. Same thing
with burning, we want to make

29063
30:14:18.108 --> 30:14:21.108
sure we always know how many
tokens people have at different

29064
30:14:21.108 --> 30:14:24.108
blocks or can be at different
checkpoints I should say. And

29065
30:14:24.108 --> 30:14:26.108
that's the most important bit at
which checkpoint Are you going

29066
30:14:26.108 --> 30:14:29.108
to use for your token voting. So
cool. Feel free to copy that,

29067
30:14:29.108 --> 30:14:32.108
again, from a GitHub or if you
want you can even just try the

29068
30:14:32.108 --> 30:14:35.108
rest of the tutorial without
this and see how you fare. But

29069
30:14:35.108 --> 30:14:38.108
cool. So now we have a
governance token and ERC 20

29070
30:14:38.108 --> 30:14:41.108
token that we can use for
governance. So let's try to

29071
30:14:41.108 --> 30:14:45.108
compile it. Yarn Hardhead
compile. Great, looks like

29072
30:14:45.108 --> 30:14:48.108
things are compiling
successfully. Perfect. So our

29073
30:14:48.108 --> 30:14:52.108
governance token looks good. Our
box looks good. Let's actually

29074
30:14:52.108 --> 30:14:56.108
now start creating our
governance contracts. Now we're

29075
30:14:56.108 --> 30:15:00.108
actually going to make a folder
called governance standard

29076
30:15:00.108 --> 30:15:03.108
because this is going to be the
standard governance model. This

29077
30:15:03.108 --> 30:15:06.108
is going to be this on chain ERC
20 and I plan on updating this

29078
30:15:06.108 --> 30:15:09.108
in the future with no a
governance off chain or

29079
30:15:09.108 --> 30:15:11.108
something right. So for now,
we're calling a governance

29080
30:15:11.108 --> 30:15:13.108
standard because this is the
quote unquote standard way to do

29081
30:15:13.108 --> 30:15:16.108
governance, but in the air,
we're going to need two

29082
30:15:16.108 --> 30:15:19.108
contracts actually, we're gonna
need a government work, contract

29083
30:15:19.108 --> 30:15:23.108
that soul and then we're also
going to need a time lock that

29084
30:15:23.108 --> 30:15:28.108
soul and this will make sense in
a second. So our gov contract

29085
30:15:28.108 --> 30:15:30.108
dot soul, this is going to be
the contract that has all the

29086
30:15:30.108 --> 30:15:34.108
voting code, all the voting
logic that our governance token

29087
30:15:34.108 --> 30:15:37.108
is going to use, the Time Lock
is actually going to be an

29088
30:15:37.108 --> 30:15:41.108
additional contract that is
actually the owner. So the Time

29089
30:15:41.108 --> 30:15:44.108
Lock and the governor contract
are sort of one in the same, but

29090
30:15:44.108 --> 30:15:47.108
the difference is the Time Lock
is actually going to be the

29091
30:15:47.108 --> 30:15:50.108
owner of the box contract. And
this is important because

29092
30:15:50.108 --> 30:15:54.108
whenever we propose or cue
something to a proposal to go

29093
30:15:54.108 --> 30:16:00.108
through, we want to wait, right?
We want to wait for a new vote

29094
30:16:00.108 --> 30:16:05.108
to be executed. Now, why do we
want to do that, let's say some

29095
30:16:05.108 --> 30:16:08.108
proposal goes through, that's
bad. So like, let's say we have

29096
30:16:08.108 --> 30:16:10.108
a box contract. And then a
proposal goes through that says,

29097
30:16:10.108 --> 30:16:16.108
Everyone who holds the
governance token has to pay five

29098
30:16:16.108 --> 30:16:19.108
tokens, or something like that,
right, or whatever, or who

29099
30:16:19.108 --> 30:16:21.108
knows, right? Maybe that's
something that you don't really

29100
30:16:21.108 --> 30:16:25.108
want to be a part of. So all of
these governance contracts give

29101
30:16:25.108 --> 30:16:32.108
time to give time to users to
get out, if they don't like a

29102
30:16:32.108 --> 30:16:36.108
governance update. So we always
want to have some type of

29103
30:16:36.108 --> 30:16:40.108
timeline. So once a proposal
passes, it won't go in effect

29104
30:16:40.108 --> 30:16:43.108
right away, it'll have to wait
some duration, and then go in

29105
30:16:43.108 --> 30:16:45.108
effect. So that's what the
timeline is gonna be for.

29106
30:16:45.108 --> 30:16:48.108
Governor contract is going to
have all of our actual code. Now

29107
30:16:48.108 --> 30:16:50.108
we can cheat a little bit.

29108
30:16:50.108 --> 30:16:53.108
Actually, we can cheat a lot of
a little bit. So opens up one

29109
30:16:53.108 --> 30:16:56.108
has a thing called the contracts
wizard, and there'll be a link

29110
30:16:56.108 --> 30:16:59.108
to this in the description as
well. And this opens up when

29111
30:16:59.108 --> 30:17:04.108
wizard is a way for us to write
really basic boilerplate code

29112
30:17:04.108 --> 30:17:06.108
right in there wizard. So right,
so if we go to the wizard

29113
30:17:06.108 --> 30:17:12.108
contract here, we can see we can
make an ERC 20 and NFT 1155. And

29114
30:17:12.108 --> 30:17:16.108
then finally, this gov thing
here. So we can call it give it

29115
30:17:16.108 --> 30:17:20.108
a name, we're going to call Rs.
Gov contract, during explain

29116
30:17:20.108 --> 30:17:24.108
what all this means, and give it
a voting delay, which is the

29117
30:17:24.108 --> 30:17:26.108
delay since a proposal is
created until voting starts. So

29118
30:17:26.108 --> 30:17:28.108
once you create a proposal, you
gotta wait a little bit, the

29119
30:17:28.108 --> 30:17:32.108
voting period, how long votes
should go for. And the reason

29120
30:17:32.108 --> 30:17:36.108
that this audio is important is
because they actually do votes,

29121
30:17:36.108 --> 30:17:39.108
voting period in terms of
blocks. So it's an anti pattern

29122
30:17:39.108 --> 30:17:42.108
to actually do timed based
things in smart contracts, it's

29123
30:17:42.108 --> 30:17:45.108
much better to do block based
things. So we're saying one

29124
30:17:45.108 --> 30:17:48.108
week, but it's that's going to
be you know, if if the average

29125
30:17:48.108 --> 30:17:51.108
block time is 13.2 seconds,
we're gonna figure out the weak

29126
30:17:51.108 --> 30:17:53.108
proposal threshold is going to
be the minimum number of votes

29127
30:17:53.108 --> 30:17:57.108
and account must have to create
a proposal. So maybe you only

29128
30:17:57.108 --> 30:18:01.108
want people who have a lot of
your governance token to make

29129
30:18:01.108 --> 30:18:04.108
votes quorum percentage, it's
what percentage of people need

29130
30:18:04.108 --> 30:18:08.108
to vote it all. So we're saying
4% of all token holders need to

29131
30:18:08.108 --> 30:18:11.108
vote or we could say you know,
exactly 100 tokens need to vote

29132
30:18:11.108 --> 30:18:13.108
whatever we want to do here. We
also have some updatable

29133
30:18:13.108 --> 30:18:17.108
settings we have Bravo
compatible Bravo is the compound

29134
30:18:17.108 --> 30:18:20.108
type contract. So if you want to
make it integratable, with

29135
30:18:20.108 --> 30:18:23.108
compound you can do that. Votes
comp like or ERC 20 votes, we're

29136
30:18:23.108 --> 30:18:26.108
working with this ERC 20 votes,
we always want to do a time

29137
30:18:26.108 --> 30:18:29.108
lock, we're gonna do the open
Zeplin implementation of a time

29138
30:18:29.108 --> 30:18:31.109
lock, you could also do a
compound implementation, we

29139
30:18:31.109 --> 30:18:35.109
aren't going to do upgradability
here, however, I have a number

29140
30:18:35.109 --> 30:18:37.109
of fantastic resources on how to
actually do upgradability. And

29141
30:18:37.109 --> 30:18:40.109
if we did want to do
upgradability, it adds all this

29142
30:18:40.109 --> 30:18:43.109
other stuff. We're not going to
do that for now because it makes

29143
30:18:43.109 --> 30:18:45.109
it so much longer video, and
then you can add some stuff like

29144
30:18:45.109 --> 30:18:49.109
this, but Oh, so that's pretty
much it. And I know this feels

29145
30:18:49.109 --> 30:18:51.109
like you're cheating, or we're
just going to copy this whole

29146
30:18:51.109 --> 30:18:54.109
thing, right? Copy all that
stuff that we put in copy to

29147
30:18:54.109 --> 30:18:57.109
clipboard, and we're going to
paste it in. Don't worry, I'm

29148
30:18:57.109 --> 30:19:00.109
gonna explain what's going on
now. So we have our government

29149
30:19:00.109 --> 30:19:03.109
contract. And this is governor
Governor setting Governor

29150
30:19:03.109 --> 30:19:06.109
counting simple Governor votes,
Governor votes, quorum Franco,

29151
30:19:06.109 --> 30:19:09.109
all this stuff. All these are
just implementations to make it

29152
30:19:09.109 --> 30:19:12.109
easier to be governor, Governor
counting simple is a way of

29153
30:19:12.109 --> 30:19:14.109
counting votes, Governor votes
is a way of integrating with

29154
30:19:14.109 --> 30:19:18.109
that year's 20 contract. Quorum
fraction is is a way to

29155
30:19:18.109 --> 30:19:21.109
understand quorum time lock.
Obviously, it's time lock. This

29156
30:19:21.109 --> 30:19:22.109
is going to be the base
contract. That's gonna be some

29157
30:19:22.109 --> 30:19:25.109
settings. And we're gonna talk
about this in a minute. But

29158
30:19:25.109 --> 30:19:27.109
let's go over what are the
functions here so we have voting

29159
30:19:27.109 --> 30:19:30.109
delay. This is exactly the
voting delay, which we're gonna

29160
30:19:30.109 --> 30:19:33.109
do superdad voting gelei, we're
gonna get from this governor

29161
30:19:33.109 --> 30:19:35.109
settings contract that we're
going to set in a minute your

29162
30:19:35.109 --> 30:19:38.109
voting period that we're going
to set in our gov settings,

29163
30:19:38.109 --> 30:19:40.109
which is this one right here.
And again, if you want to like

29164
30:19:40.109 --> 30:19:42.109
look at all these contracts, you
absolutely can, right, if we go

29165
30:19:42.109 --> 30:19:47.109
to contracts, governance,
extensions, we have all these in

29166
30:19:47.109 --> 30:19:50.109
here, right? So if we look at
governance settings, we can see

29167
30:19:50.109 --> 30:19:53.109
it has voting delay voting
period, proposal threshold, and

29168
30:19:53.109 --> 30:19:56.109
those are right in its
constructor. And that's exactly

29169
30:19:56.109 --> 30:19:58.109
what we're setting, right. We're
setting voting delay voting

29170
30:19:59.109 --> 30:20:01.109
period, and then the proposal
threshold, and then we're also

29171
30:20:01.109 --> 30:20:04.109
going to make this customizable
as well. And the rest of these

29172
30:20:04.109 --> 30:20:06.109
that's exactly what doing
calling the quorum from the

29173
30:20:06.109 --> 30:20:10.109
super get votes. And then again,
the super is those inherited

29174
30:20:10.109 --> 30:20:13.109
contracts, get the state and
then we have some interesting

29175
30:20:13.109 --> 30:20:16.109
functions we have proposed. This
is what we're actually going to

29176
30:20:16.109 --> 30:20:20.109
do to propose new governance we
have proposal threshold, and

29177
30:20:20.109 --> 30:20:24.109
then we have execute which
executes a cued proposal. To

29178
30:20:24.109 --> 30:20:27.109
cancel, we have executor which
we're is going to be who can

29179
30:20:27.109 --> 30:20:30.109
actually execute stuff, we're
actually going to make it

29180
30:20:30.109 --> 30:20:33.109
anybody and then supports
interface, you can basically

29181
30:20:33.109 --> 30:20:36.109
ignore. But let's make this a
little bit more customizable. So

29182
30:20:36.109 --> 30:20:39.109
we have Iboats token, this is
going to be our governance

29183
30:20:39.109 --> 30:20:41.109
token, the timeline controller
timeline, this is going to be

29184
30:20:41.109 --> 30:20:44.109
the timeline controller that we
make an amended. And again, we

29185
30:20:44.109 --> 30:20:47.109
need this because we don't want
to let any proposal just go

29186
30:20:47.109 --> 30:20:50.109
through once it passes, we want
to give people time to get out.

29187
30:20:50.109 --> 30:20:57.109
But let's add the UN 256 voting
delay as a parameter here. And

29188
30:20:57.109 --> 30:21:00.109
for voting delay, we're going to
do this, we're going to set it

29189
30:21:00.109 --> 30:21:05.109
as our governor settings, we're
going to do a UNT 256 voting

29190
30:21:05.109 --> 30:21:09.109
period. And we're going to add
that right here. And this means

29191
30:21:09.109 --> 30:21:14.109
45,000 blocks is approximately
one week. And that's what that

29192
30:21:14.109 --> 30:21:17.109
means we're going to leave
proposal threshold to zero

29193
30:21:17.109 --> 30:21:18.109
because we don't really want to
change that we want to let

29194
30:21:18.109 --> 30:21:22.109
anyone make a proposal. And then
we're just going to add you in

29195
30:21:22.109 --> 30:21:26.109
256 underscore core

29196
30:21:26.109 --> 30:21:30.109
percentage to this. So Governor
votes quorum percentage

29197
30:21:30.109 --> 30:21:33.109
corporate senators. So now this
is completely customizable, for

29198
30:21:33.109 --> 30:21:36.109
voting, delay voting period,
core percentage for whatever you

29199
30:21:36.109 --> 30:21:39.109
want it to be. And believe it or
not, that's it. Now you have a

29200
30:21:39.109 --> 30:21:42.109
simple governance contract.
Thank you, openzeppelin, for

29201
30:21:42.109 --> 30:21:46.109
doing 99% of the work for us. So
that's it. So this contract,

29202
30:21:46.109 --> 30:21:48.109
it's going to have all these
functions that we're going to go

29203
30:21:48.109 --> 30:21:52.109
over for proposing for executing
and for queuing, different

29204
30:21:52.109 --> 30:21:57.109
proposals. Right. Now we got to
make a time lock contract here.

29205
30:21:57.109 --> 30:22:00.109
And this contract is actually
going to be a lot easier. So

29206
30:22:00.109 --> 30:22:02.109
we're just going to do it from
scratch. So we're going to spdx

29207
30:22:02.109 --> 30:22:09.109
license I then to fire, my team,
do pragma solidity and let's

29208
30:22:09.109 --> 30:22:12.109
just do this your point a point
zero, and then we're going to

29209
30:22:12.109 --> 30:22:15.109
import from open Zeppelin, a
contract called the Time Lock

29210
30:22:15.109 --> 30:22:18.109
controller. So if we look at the
governance here, if this time

29211
30:22:18.109 --> 30:22:21.109
lock controller dot soul
contract, and this has all this

29212
30:22:21.109 --> 30:22:24.109
functionality in here for
creating roles, who can actually

29213
30:22:24.109 --> 30:22:28.109
propose who can execute, who's
the Time Lock admin, but it also

29214
30:22:28.109 --> 30:22:31.109
has these execute stuff in here
as well. It's gonna work in

29215
30:22:31.109 --> 30:22:34.109
tandem with our governance
contract, right? This is the

29216
30:22:34.109 --> 30:22:38.109
contract that says that makes
sure our governance contract

29217
30:22:38.109 --> 30:22:41.109
doesn't just push stuff through
willy nilly. So we're gonna say

29218
30:22:41.109 --> 30:22:45.109
we're gonna first import that
import at open Zeppelin slash

29219
30:22:45.109 --> 30:22:52.109
contracts slash governance slash
Time Lock controller. That's all

29220
30:22:52.109 --> 30:22:57.109
and then we're gonna say
contract, I'm lock is Time Lock

29221
30:22:57.109 --> 30:23:00.109
controller like that. And we'll
create our little constructor

29222
30:23:00.109 --> 30:23:05.109
here, and truck door. And this
because this takes a couple

29223
30:23:05.109 --> 30:23:09.109
different parameters, we're
gonna take a un 256 Min delay,

29224
30:23:09.109 --> 30:23:14.109
which are min delay, Min delay
is going to be along you have to

29225
30:23:14.109 --> 30:23:19.109
wait before executing. So this
is Hey, once proposal passes,

29226
30:23:19.109 --> 30:23:21.109
great, we gotta wait this
minimum delay, then we're going

29227
30:23:21.109 --> 30:23:27.109
to do a list of proposers, an
address array memory of

29228
30:23:27.109 --> 30:23:31.109
proposers. And then the
proposers is the list of

29229
30:23:31.109 --> 30:23:34.109
addresses that can propose for
us, we're just gonna say

29230
30:23:34.109 --> 30:23:37.109
everyone's gonna be able to
propose. And then last, an

29231
30:23:38.109 --> 30:23:42.109
address array, memory of
executors who can execute

29232
30:23:42.109 --> 30:23:47.109
everything, and we're just gonna
say executors who can execute

29233
30:23:47.109 --> 30:23:51.109
when a probe posle passes. And
again, we're just gonna say

29234
30:23:51.109 --> 30:23:53.109
everybody, and the reason we
need these is because we need to

29235
30:23:53.109 --> 30:23:56.109
pass these to our time lock
controller, this constructor is

29236
30:23:56.109 --> 30:24:01.109
expecting three parameters. So
we'll just do Tama controller,

29237
30:24:01.109 --> 30:24:09.109
delay, pro posers, X EQ, tours.
And that's it. So this is going

29238
30:24:09.109 --> 30:24:13.109
to be what owns everything, it's
the timelog, that's going to be

29239
30:24:13.109 --> 30:24:15.109
owning our box. It's not the
government contract, the

29240
30:24:15.109 --> 30:24:18.109
government contracts is where
we're going to send our votes

29241
30:24:18.109 --> 30:24:20.109
and stuff. But at the time lock
that actually everything needs

29242
30:24:20.109 --> 30:24:23.109
to flow through in order for
governance to actually happen,

29243
30:24:23.109 --> 30:24:26.109
because we want to make sure we
have this min delay, we go

29244
30:24:26.109 --> 30:24:28.109
through the right process and
everything. And believe it or

29245
30:24:28.109 --> 30:24:31.109
not, that's everything. That is
all the code you're going to

29246
30:24:31.109 --> 30:24:35.109
need as far as the solidity
goes, to create a governance to

29247
30:24:35.109 --> 30:24:39.109
create a Dao. So even do your
own hard hat compile, make sure

29248
30:24:39.109 --> 30:24:43.109
everything's compiled. And tada,
we've done it, you've done most

29249
30:24:43.109 --> 30:24:45.109
of the hard work. Now we're
going to flip over to actually

29250
30:24:45.109 --> 30:24:48.109
writing the scripts to deploy
and to interact with everything

29251
30:24:48.109 --> 30:24:51.109
using TypeScript here. At this
point, if you're like, Oh, I

29252
30:24:51.109 --> 30:24:54.109
already learned everything that
I wanted, I don't use hard hat,

29253
30:24:54.109 --> 30:24:57.109
I use some other tools. This is
where I challenge you to go out

29254
30:24:57.109 --> 30:24:59.109
and I challenge you to try
something else. Now if you've

29255
30:24:59.109 --> 30:25:01.109
reached this point, I just want
to give you a huge congrats,

29256
30:25:01.109 --> 30:25:04.109
because you have taken the steps
to build your own doubt build

29257
30:25:05.109 --> 30:25:07.109
your own governance model.
That's all the solidity that you

29258
30:25:07.109 --> 30:25:10.109
really need. You can take that
deploy that and you're good to

29259
30:25:10.109 --> 30:25:13.109
go. But of course, we know that
there's more to being a smart

29260
30:25:13.109 --> 30:25:16.109
contract developer than just the
solidity you got to do the

29261
30:25:16.109 --> 30:25:19.109
tooling right to let's go ahead
and we'll jump into writing

29262
30:25:19.109 --> 30:25:21.109
those TypeScript scripts to
actually do this. And again, if

29263
30:25:21.109 --> 30:25:24.109
you want to see a Python version
of this, go check out a link up

29264
30:25:24.109 --> 30:25:26.109
description to see the Pythonic
version of this. And of course,

29265
30:25:26.109 --> 30:25:29.109
don't forget to smash that like
button, subscribe, leave a

29266
30:25:29.109 --> 30:25:32.109
comment on how you're doing so
far. And, of course, give

29267
30:25:32.109 --> 30:25:34.109
yourself a pat in the back.
Great job. You're doing amazing

29268
30:25:34.109 --> 30:25:38.109
getting this far. Congrats,
let's jump in.

29269
30:25:38.109 --> 30:25:41.109
Alright, so we're back here,
we've written our smart

29270
30:25:41.109 --> 30:25:44.109
contracts already, check wasn't
that easy, right, this was way

29271
30:25:44.109 --> 30:25:46.109
easier than I thought it would
be. Now we're just gonna write

29272
30:25:46.109 --> 30:25:48.109
our deployment scripts, and then
we're gonna write our scripts to

29273
30:25:48.109 --> 30:25:52.109
interact with them. Again, my
full repo also has tests, but

29274
30:25:52.109 --> 30:25:54.109
we're just gonna write some
scripts. And then feel free to

29275
30:25:54.109 --> 30:25:57.109
check out the tests yourself. So
let's write those deployment

29276
30:25:57.109 --> 30:26:00.109
scripts to we're actually going
to be using a package for

29277
30:26:00.109 --> 30:26:03.109
deployment called Hard Hat
deploy. It is absolutely

29278
30:26:03.109 --> 30:26:06.109
phenomenal for hard hat for
making your deployments much,

29279
30:26:06.109 --> 30:26:08.109
much easier. We're gonna scroll
down to installation, and we're

29280
30:26:08.109 --> 30:26:11.109
actually gonna go ahead and
install this. So typically, you

29281
30:26:11.109 --> 30:26:13.109
could install it like this.
Well, we're gonna use yarn, but

29282
30:26:13.109 --> 30:26:16.109
we're gonna do kind of the more
safe way which looks a little

29283
30:26:16.109 --> 30:26:19.109
wonky, but I'm explaining it
right. So instead of NPM

29284
30:26:19.109 --> 30:26:22.109
install, we're gonna do yarn,
add dash dash Dev, and then this

29285
30:26:22.109 --> 30:26:26.109
whole thing right here. So we're
gonna do yarn, add dash dash

29286
30:26:26.109 --> 30:26:28.109
Dev, and then just paste that in
here. So this is gonna be at

29287
30:26:28.109 --> 30:26:33.109
nomic, labs slash hard hat,
hyphen ethers at NPM, colon,

29288
30:26:33.109 --> 30:26:35.109
hard hat, deploy ethers. And
what this is doing is we're

29289
30:26:35.109 --> 30:26:40.109
basically saying hard hat deploy
ethers is going to be overriding

29290
30:26:40.109 --> 30:26:42.109
this hardened ether thing. And
we're also going to add ethers

29291
30:26:42.109 --> 30:26:46.109
as well. And then once we add
this in, check our package json,

29292
30:26:46.109 --> 30:26:50.109
we can see we have hard hats. We
have hard hat ethers, which is

29293
30:26:50.109 --> 30:26:53.109
being overwritten by this hard
hat, deploy ethers. And then

29294
30:26:53.109 --> 30:26:58.109
additionally, we're going to
want to add on a deploy. So do

29295
30:26:58.109 --> 30:27:03.109
yarn, add dash dash Dev, hard
hat hyphen, deploy. And what

29296
30:27:03.109 --> 30:27:05.109
this is going to allow us to do
is instead of having to write

29297
30:27:05.109 --> 30:27:08.109
scripts, and do all this stuff,
that kind of makes it hard to

29298
30:27:08.109 --> 30:27:11.109
save your deployments and
everything, we're going to just

29299
30:27:11.109 --> 30:27:14.109
create a deploy folder, where
we're going to add all of our

29300
30:27:14.109 --> 30:27:17.109
deploy scripts in here. So I
absolutely love this package.

29301
30:27:17.109 --> 30:27:20.109
It's makes deployment really,
really easy. So in here, we're

29302
30:27:20.109 --> 30:27:22.109
gonna create new file, it's
going to do oh one, we're gonna

29303
30:27:22.109 --> 30:27:24.109
go step by step deploying
everything, we're gonna call

29304
30:27:24.109 --> 30:27:29.109
this deploy, govern or token dot
TypeScript, that's gonna be the

29305
30:27:29.109 --> 30:27:33.109
first thing we're going to do.
Also, we're gonna change this to

29306
30:27:33.109 --> 30:27:37.109
TypeScript. Tada, we now have
TypeScript. Yay. Now the one

29307
30:27:37.109 --> 30:27:40.109
thing that is kind of nice about
doing kind of that advanced

29308
30:27:40.109 --> 30:27:42.109
TypeScript thing at the heart
had kind of gives it the

29309
30:27:42.109 --> 30:27:45.109
beginning, is you don't have to
install all the TypeScript stuff

29310
30:27:45.109 --> 30:27:49.109
yourself. But we do. So we're
going to do yarn, add TypeScript

29311
30:27:49.109 --> 30:27:57.109
type chain, vs node at type
chain slash ethers, V five, this

29312
30:27:57.109 --> 30:28:00.109
is a lot of stuff, don't worry
type chain slash hard hat, at

29313
30:28:00.109 --> 30:28:05.109
type slash Chai, at type slash
node. And then we'll make sure

29314
30:28:05.109 --> 30:28:10.109
this is all Dev, dash dash Dev,
I know there's a lot of stuff.

29315
30:28:10.109 --> 30:28:12.109
There's all this stuff to make
it TypeScript D.

29316
30:28:12.109 --> 30:28:15.109
You can absolutely do this in
JavaScript if you want. You just

29317
30:28:15.109 --> 30:28:18.109
have to do JS files and ignore
the typing. So But feel free to

29318
30:28:18.109 --> 30:28:20.109
do whatever you want to do.
Alright, cool. And we should be

29319
30:28:20.109 --> 30:28:24.109
okay here. Let's go into our
governor token here. And we'll

29320
30:28:24.109 --> 30:28:28.109
create a deploy script. So the
Hardhead deploy GitHub repo has

29321
30:28:28.109 --> 30:28:31.109
a little demo boilerplate code
for you actually do your deploy

29322
30:28:31.109 --> 30:28:34.109
script. So feel free to
reference here if you lost or

29323
30:28:34.109 --> 30:28:37.109
confused. So what we're going to
do is we're going to import the

29324
30:28:37.109 --> 30:28:44.109
hard hat runtime environments,
from our enhanced slash types.

29325
30:28:44.109 --> 30:28:46.109
And you'll see why we need this
in just a second. And then we're

29326
30:28:46.109 --> 30:28:50.109
also going to import deploy
function from Hardhead. Deploy

29327
30:28:50.109 --> 30:28:53.109
slash types. And these are the
two main things you need to

29328
30:28:53.109 --> 30:28:55.109
create a deploy function with
pothead deploy, we're going to

29329
30:28:56.109 --> 30:29:00.109
create our function, we're going
to call it const ploy governance

29330
30:29:00.109 --> 30:29:04.109
token, it's going to be of type
deploy function. So in order for

29331
30:29:04.109 --> 30:29:06.109
these to actually work, we just
create a whole bunch of deploy

29332
30:29:06.109 --> 30:29:08.109
functions that we run with heart
hub. And this is going to be an

29333
30:29:08.109 --> 30:29:12.109
async function. That's going to
take the hard hat runtime

29334
30:29:12.109 --> 30:29:15.109
environment as an input
parameter that we're going to

29335
30:29:15.109 --> 30:29:19.109
call HRV. So when we run hard
hat deploy, which you'll see in

29336
30:29:19.109 --> 30:29:22.109
a second, we're actually passing
our fake hard hat chain that

29337
30:29:22.109 --> 30:29:25.109
gets spun up in the background
for us, right, we can even do

29338
30:29:25.109 --> 30:29:30.109
like console dot log Hello. And
if we do yarn, hard hat deploy.

29339
30:29:30.109 --> 30:29:32.109
Actually, before we even do
that, if we do yarn, hard hat

29340
30:29:32.109 --> 30:29:35.109
dash dash help, you'll see,
since we imported hard hat

29341
30:29:35.109 --> 30:29:39.109
deploy up excuse me, we need to
add this to our config. First in

29342
30:29:39.109 --> 30:29:45.109
our config, we're gonna need to
do top imports, hard hat deploy

29343
30:29:45.109 --> 30:29:49.109
top Roscoe need to import at
nomic labs slash hard hat

29344
30:29:49.109 --> 30:29:53.109
ethers, we're also going to need
to import at type chain slash

29345
30:29:53.109 --> 30:29:56.109
hard hat. And then we'll leave
it there for now. We'll have to

29346
30:29:56.109 --> 30:29:59.109
import more stuff in a second
but literally like that. Now, if

29347
30:29:59.109 --> 30:30:03.109
we do yarn hard hat that should
help we should see a new task in

29348
30:30:03.109 --> 30:30:06.109
here. And we do we actually see
a ton of new tasks right? Filled

29349
30:30:06.109 --> 30:30:10.109
with tasks, check clean compile,
console deployed. And this is

29350
30:30:10.109 --> 30:30:13.109
the new task that we have that
actually deploys all of our

29351
30:30:13.109 --> 30:30:16.109
contracts, anything that's in
this deploy folder, our head

29352
30:30:16.109 --> 30:30:19.109
will go ahead and run right now
in our deploy folder. All we

29353
30:30:19.109 --> 30:30:23.109
have is this console dot log
Hello. So if we run yarn, or hit

29354
30:30:23.109 --> 30:30:26.109
Deploy, we should See, it just
prints out hello. It'll spin up

29355
30:30:26.109 --> 30:30:29.109
a new blockchain background,
while all of our projects and

29356
30:30:29.109 --> 30:30:33.109
everything, do some type type
chain stuff, and it says you'll

29357
30:30:33.109 --> 30:30:36.109
see this a lot deploy script dot
func is not a function. And

29358
30:30:36.109 --> 30:30:38.109
that's because we actually need
to export this now. So we'll do

29359
30:30:38.109 --> 30:30:44.109
export default, deploy
governance token. That's why

29360
30:30:44.109 --> 30:30:46.109
it's getting mad at us. Now
we'll run yarn had her hard hat

29361
30:30:46.109 --> 30:30:50.109
deploy. And boom, we say hello.
So this is how we can actually

29362
30:30:50.109 --> 30:30:53.109
deploy all of our scripts. And
we can run everything that's in

29363
30:30:53.109 --> 30:30:57.109
this deploy folder in one go,
which is really helpful. So

29364
30:30:57.109 --> 30:31:00.109
let's go ahead and deploy our
governance token first. And this

29365
30:31:00.109 --> 30:31:02.109
will get a lot faster as we go
along. Don't worry, so delete

29366
30:31:02.109 --> 30:31:05.109
this. And first we're gonna do
it, we're gonna say const. We

29367
30:31:05.109 --> 30:31:08.109
need an account to deploy this
first. So we'll say const, get

29368
30:31:08.109 --> 30:31:13.109
named accounts, deployments, and
network equals HRA. And this is

29369
30:31:13.109 --> 30:31:15.109
going to be a little bit more
advanced. This is hard stuff.

29370
30:31:15.109 --> 30:31:18.109
This is this is the slick stuff
we're doing here, we're getting

29371
30:31:18.109 --> 30:31:21.109
these from our hard hat runtime
environment, which is being

29372
30:31:21.109 --> 30:31:25.109
updated from hard hat deploy. So
get named accounts is way for us

29373
30:31:25.109 --> 30:31:29.109
to actually import accounts from
our hard hat config, right into

29374
30:31:29.109 --> 30:31:31.109
our deploy script. So we're
gonna go to our hard hat config.

29375
30:31:31.109 --> 30:31:34.109
And we're gonna create a new
config that's a little bit nicer

29376
30:31:34.109 --> 30:31:37.109
than this. So first, we need to
import the hard hat config type.

29377
30:31:37.109 --> 30:31:39.109
Since we're using type scripts,
we're going to import hard hat

29378
30:31:39.109 --> 30:31:43.109
user config from hard hat slash
config. And we're going to

29379
30:31:43.109 --> 30:31:46.109
create a config. So I'm just
gonna comment this out. For now

29380
30:31:47.109 --> 30:31:50.109
we're gonna say const. Config,
it's gonna be type hard hat user

29381
30:31:50.109 --> 30:31:53.109
config. Equals, and this is
where we can add a whole bunch

29382
30:31:53.109 --> 30:31:56.109
of stuff. So let's say our
default network is going to be

29383
30:31:56.109 --> 30:32:00.109
hard hat, which is kind of our
local fake blockchain. And then

29384
30:32:00.109 --> 30:32:05.109
we're gonna say solidity is
zero, point 8.8, then we're

29385
30:32:05.109 --> 30:32:08.109
going to do this thing called
named accounts, which is what we

29386
30:32:08.109 --> 30:32:11.109
came here in the first place
for. So this is just a list of

29387
30:32:11.109 --> 30:32:14.109
accounts that we can use. So for
accounts, we'll say Deployer,

29388
30:32:14.109 --> 30:32:17.109
this will be the name of our
account that does all the

29389
30:32:17.109 --> 30:32:21.109
deploying, and we'll just say,
default, is going to be zero. So

29390
30:32:21.109 --> 30:32:26.109
whenever we run an any chain,
our zero with account is going

29391
30:32:26.109 --> 30:32:29.109
to be named Deployer. What other
thing that we need to do is we

29392
30:32:29.109 --> 30:32:32.109
need to add our networks here.
And there's actually two

29393
30:32:32.109 --> 30:32:33.109
networks that we're going to
have, we're gonna have a hard

29394
30:32:33.109 --> 30:32:39.109
hat with a chain ID of 313337.
And we're also going to have

29395
30:32:39.109 --> 30:32:44.109
local hosts of chain ID 31337.
Now, these look like they're

29396
30:32:44.109 --> 30:32:48.109
pretty much the same. And I
understand that, but they're

29397
30:32:48.109 --> 30:32:51.109
not. And you'll understand why
in a second, but we need them

29398
30:32:51.109 --> 30:32:55.109
for now. Just to tell Hardhead
hey, here are the development

29399
30:32:55.109 --> 30:32:59.109
fake blockchains that we're
working with? Okay. So this is

29400
30:32:59.109 --> 30:33:02.109
kind of our basic setup here.
Okay. I know that was kind of a

29401
30:33:02.109 --> 30:33:04.109
lot. But now that we have get
named accounts, we have network,

29402
30:33:04.109 --> 30:33:06.109
right? Because anytime you
deploy something, it's going to

29403
30:33:06.109 --> 30:33:11.109
be on a network. And when we
deploy something, if you run

29404
30:33:11.109 --> 30:33:14.109
yarn, hard hat node, what hard
hat is going to do, it's going

29405
30:33:14.109 --> 30:33:17.109
to spin up a fake blockchain in
the background. Oh, it's gonna

29406
30:33:17.109 --> 30:33:18.109
be mad at me for a second. Oh,

29407
30:33:18.109 --> 30:33:22.109
I forgot to add export, default
config, right, we need to export

29408
30:33:22.109 --> 30:33:26.109
the config. Hell hard hat that
we're using this version of

29409
30:33:26.109 --> 30:33:29.109
sling. Now if you're on a hard
hat node, you'll see why we

29410
30:33:29.109 --> 30:33:31.109
added these two networks up here
hard hat on localhost, we

29411
30:33:31.109 --> 30:33:34.109
actually get spun up our own
fake blockchain, we get

29412
30:33:34.109 --> 30:33:37.109
accounts, we get private keys,
we get everything right. This is

29413
30:33:37.109 --> 30:33:41.109
a hard hat Node running in this
terminal, right? When you run

29414
30:33:41.109 --> 30:33:44.109
hard hat node, oddly enough,
it's actually the local host

29415
30:33:44.109 --> 30:33:47.109
network. It's not the Hard Hat
Network. When using hard hat

29416
30:33:47.109 --> 30:33:50.109
deploy, it's gonna be the local
host network. Or excuse me, when

29417
30:33:50.109 --> 30:33:52.109
you use hard hat node, it's
actually going to be the local

29418
30:33:52.109 --> 30:33:55.109
host network, not the Hard Hat
Network. The Hard Hat Network is

29419
30:33:55.109 --> 30:33:58.109
what it uses when it runs tests.
localhost is when you run this

29420
30:33:58.109 --> 30:34:02.109
hard hat node and have this kind
of fake blockchain running in

29421
30:34:02.109 --> 30:34:05.109
your terminal. So that's what
the localhost is. Cool. Well,

29422
30:34:05.109 --> 30:34:08.109
Ctrl C will kill that. Alright,
great. So now stuff is actually

29423
30:34:08.109 --> 30:34:11.109
working. So get them to count
deployments is going to be a

29424
30:34:11.109 --> 30:34:12.109
whole bunch of stuff from
deployments, you'll see in a

29425
30:34:12.109 --> 30:34:14.109
second and network is the
network that we're on. Okay,

29426
30:34:14.109 --> 30:34:19.109
great. So now we're gonna grab
const deploy log equals

29427
30:34:19.109 --> 30:34:22.109
deployments, this deployments
object comes with this deploy

29428
30:34:22.109 --> 30:34:25.109
function. And this log function,
this log function is kind of

29429
30:34:25.109 --> 30:34:30.109
nice for doing logging. And then
we're gonna grab const, employer

29430
30:34:30.109 --> 30:34:35.109
equals await, get named
accounts. So we're grabbing from

29431
30:34:35.109 --> 30:34:40.109
our config, this deployer
account, right? And it's always

29432
30:34:40.109 --> 30:34:44.109
going to be the zero with index.
So it's defaulted to the zero

29433
30:34:44.109 --> 30:34:47.109
index for whatever accounts that
were with. Great. So we now have

29434
30:34:47.109 --> 30:34:49.109
an account to deploy stuff from
we have a deploy function, we

29435
30:34:49.109 --> 30:34:52.109
have all this stuff, we're
looking pretty good. Cool. So

29436
30:34:52.109 --> 30:34:58.109
sometimes they'll do like a log,
flying governance token, dot,

29437
30:34:58.109 --> 30:35:03.109
and we'll say const governance
token equals await, deploy, and

29438
30:35:03.109 --> 30:35:06.109
then the name of the contract
which is governance token,

29439
30:35:06.109 --> 30:35:08.109
comma, and these are all the
parameters that we're going to

29440
30:35:08.109 --> 30:35:13.110
pass to it. So we're gonna say
from deployer doesn't take any

29441
30:35:13.110 --> 30:35:17.110
arguments. So args is just going
to be blank. We're going to do

29442
30:35:17.110 --> 30:35:20.110
log to be true so we'll get some
logs printed out for us. And

29443
30:35:20.110 --> 30:35:24.110
then I have this wait
confirmations attribute set in

29444
30:35:24.110 --> 30:35:27.110
GitHub repo. For now we're going
to ignore this. But if you

29445
30:35:27.110 --> 30:35:29.110
follow along with my repo and
you want to auto verify stuff,

29446
30:35:29.110 --> 30:35:31.110
this is something that you're
going to want to use. So you

29447
30:35:31.110 --> 30:35:35.110
need to wait some amount of
blocks for this contract to be

29448
30:35:35.110 --> 30:35:38.110
deployed before you can actually
go ahead and verify it, right.

29449
30:35:38.110 --> 30:35:40.110
Because if you're using ether
scan or something, you're gonna

29450
30:35:40.110 --> 30:35:43.110
need to wait like, yeah, you're
gonna need to wait a few

29451
30:35:43.110 --> 30:35:45.110
minutes. So check out my GitHub
repo for this wait confirmation

29452
30:35:45.110 --> 30:35:48.110
stuff, I'm just going to ignore
it for now. Additionally, in my

29453
30:35:48.110 --> 30:35:51.110
GitHub repo, I have this verify
function, where we check to see

29454
30:35:51.110 --> 30:35:54.110
if it's on a development chain.
And if it is, we don't verify

29455
30:35:54.110 --> 30:35:56.110
it. But if it's on like ether
scan or something, we go ahead

29456
30:35:56.110 --> 30:35:59.110
and verify it. So be sure to
check the GitHub repo to learn

29457
30:35:59.110 --> 30:36:02.110
how to just auto verify without
having to do anything. Now if we

29458
30:36:02.110 --> 30:36:07.110
just do this part. And then we
can even do Floyd, governance

29459
30:36:07.110 --> 30:36:16.110
token to address governance
token dot address. And we'll do

29460
30:36:16.110 --> 30:36:24.110
yarn hardhat. Deploy. Boom. So
we spin up on a fake Hard Hat

29461
30:36:24.110 --> 30:36:27.110
Network, we do deploy governance
token to address boom. And this

29462
30:36:27.110 --> 30:36:30.110
is how we deploy a fake has
deployed this to our own little

29463
30:36:30.110 --> 30:36:34.110
network here. Great. So this
tokens been deployed, we have

29464
30:36:34.110 --> 30:36:37.110
our deploy script. Yeah, zoom
out a little bit. Let's zoom out

29465
30:36:37.110 --> 30:36:39.110
a little bit. Great. That's the
whole thing. Now we're going to

29466
30:36:39.110 --> 30:36:41.110
add one more thing here, we're
going to add something called

29467
30:36:41.110 --> 30:36:44.110
delegate function. Now, when you
actually deploy this contract,

29468
30:36:44.110 --> 30:36:47.110
nobody has voting power yet. The
reason is, because nobody has

29469
30:36:47.110 --> 30:36:51.110
the token delegated to them, we
want to delegate this token to

29470
30:36:51.110 --> 30:36:53.110
our Deployer. Right, so we're
going to call this delegate

29471
30:36:53.110 --> 30:36:56.110
function. So we're going to
create a new function called

29472
30:36:56.110 --> 30:37:01.110
const. delegate. And it's going
to be an async function. It's

29473
30:37:01.110 --> 30:37:05.110
going to take a governance token
address as a string, it's going

29474
30:37:05.110 --> 30:37:08.110
to take a delegated account,
also as a string, so we're

29475
30:37:08.110 --> 30:37:14.110
racing and say, who do we want?
Delegate? Who do we want to be

29476
30:37:14.110 --> 30:37:17.110
able to vote with our token?
Okay, so we have created this

29477
30:37:17.110 --> 30:37:20.110
async function called delegate.
And how do we do this? Well, we

29478
30:37:20.110 --> 30:37:29.110
say Kant's over its token equals
token equals await ethers dot

29479
30:37:29.110 --> 30:37:33.110
get contract at.

29480
30:37:33.110 --> 30:37:36.110
And probably for two ethers for
us from hardheaded Otto did

29481
30:37:36.110 --> 30:37:38.110
that, which is great. That's
what we want. Once it's like

29482
30:37:38.110 --> 30:37:43.110
ethers. Thank you vs. Code away.
Ether is like a contract at. And

29483
30:37:43.110 --> 30:37:47.110
we're going to say we want our
governance token, which is at

29484
30:37:47.110 --> 30:37:52.110
contract, governance token
address. And I have auto format

29485
30:37:53.110 --> 30:37:55.110
unsaved, which is why it keeps
formatting like that. This

29486
30:37:55.110 --> 30:37:58.110
should be delegated account.
Okay, cool. We have our

29487
30:37:58.110 --> 30:38:02.110
governance token contract. Now
we can do const TX or

29488
30:38:02.110 --> 30:38:07.110
transaction equals await,
governance token dot delegate

29489
30:38:07.110 --> 30:38:11.110
delegate this delegated account
here. And then we can do a wait,

29490
30:38:11.110 --> 30:38:16.110
we'll wait for this transaction
to be confirmed by one block.

29491
30:38:16.110 --> 30:38:21.110
And then we'll just do console
dot log checkpoints, wait,

29492
30:38:21.110 --> 30:38:28.110
governance token dot num
checkpoints delegated account?

29493
30:38:28.110 --> 30:38:31.110
So what is this doing? So we
have this num checkpoints

29494
30:38:31.110 --> 30:38:35.110
function which we can go check
to see on that ERC 20 token what

29495
30:38:35.110 --> 30:38:37.110
this is actually doing. But
basically what this whole thing

29496
30:38:37.110 --> 30:38:40.110
is doing, we have this delegate
function that we haven't used

29497
30:38:40.110 --> 30:38:43.110
it. But when somebody calls us,
we're saying, Hey, you can use

29498
30:38:43.110 --> 30:38:45.110
my vote, take my votes and vote
however you want. And that's

29499
30:38:45.110 --> 30:38:48.110
what these this delegate does.
Now, if we look at this token,

29500
30:38:48.110 --> 30:38:53.110
here, see 20 extensions, your
see 20 votes, we look at number

29501
30:38:53.110 --> 30:38:57.110
checkpoints, we can see how many
checkpoints that account

29502
30:38:57.110 --> 30:39:00.110
actually has reason this is so
important is because once again,

29503
30:39:00.110 --> 30:39:03.110
like I was saying when people do
a vote, they do it based off

29504
30:39:03.110 --> 30:39:06.110
some checkpoints. And anytime
you transfer a token, or

29505
30:39:06.110 --> 30:39:09.110
delegate a token, basically call
this function move voting power,

29506
30:39:09.110 --> 30:39:12.110
which happens with the back end,
which writes the checkpoint and

29507
30:39:12.110 --> 30:39:16.110
says, Hey, at checkpoint x,
here's what everybody has for

29508
30:39:16.110 --> 30:39:19.110
voting powers. And that's what
these are so important. And I

29509
30:39:19.110 --> 30:39:21.110
know I said before, it's every
block, but it's actually just

29510
30:39:21.110 --> 30:39:24.110
every checkpoint, whenever these
checkpoints are updated, that's

29511
30:39:24.110 --> 30:39:26.110
gonna be a lot cheaper on gas
than if we just did every single

29512
30:39:26.110 --> 30:39:30.110
block, right? That'd be kind of
insane. So the checkpoint for

29513
30:39:30.110 --> 30:39:33.110
this governance checkpoint, and
we'll see what that actually is

29514
30:39:33.110 --> 30:39:37.110
in just a second. So we'll even
do a wait, delegate, governance

29515
30:39:37.110 --> 30:39:44.110
token dot address, and Deployer.
And we'll say log delegated.

29516
30:39:44.110 --> 30:39:47.110
Now, when we're on this
function, John Howard hit

29517
30:39:47.110 --> 30:39:51.110
Deploy. We have one checkpoint,
which makes sense, right?

29518
30:39:51.110 --> 30:39:55.110
Because this was just deployed,
it was just delegated. This

29519
30:39:55.110 --> 30:39:58.110
address has one checkpoint.
That's it. And the reason I

29520
30:39:58.110 --> 30:40:00.110
checked for this is because if
you see zero checkpoints here,

29521
30:40:00.110 --> 30:40:03.110
it means you haven't delegated
correctly. So be sure to check

29522
30:40:03.110 --> 30:40:06.110
for checkpoints. But that's it.
We have our deployed governance

29523
30:40:06.110 --> 30:40:10.110
token contract done. Bravo.
Let's move on to the next one.

29524
30:40:10.110 --> 30:40:13.110
So what do we want to do after
we deploy our governance token?

29525
30:40:13.110 --> 30:40:17.110
Well, let's deploy that timelock
or timelock.ts. And we're going

29526
30:40:17.110 --> 30:40:20.110
to copy a lot of this stuff over
from here, so I'm actually going

29527
30:40:20.110 --> 30:40:23.110
to Oh, and then sometimes you'll
get some weird linting errors

29528
30:40:23.110 --> 30:40:26.110
here. I just do det TS ignore
there. And sometimes you'll get

29529
30:40:26.110 --> 30:40:29.110
it here too. Oh, actually, we
don't even need network. Okay,

29530
30:40:29.110 --> 30:40:32.110
cool. Yeah, you don't even need
network loops. Sometimes we get

29531
30:40:32.110 --> 30:40:35.110
some weird linting errors.
Sometimes Vyas code has a hard

29532
30:40:35.110 --> 30:40:38.110
time telling understanding like
this, this overwrite thing that

29533
30:40:38.110 --> 30:40:42.110
we did. So just run that TS
ignore if if it gives you some,

29534
30:40:42.110 --> 30:40:45.110
some engineers, anyways, yes, we
have this Oh, to deploy time

29535
30:40:45.110 --> 30:40:47.110
lock here, we're going to deploy
our time lock contract. And

29536
30:40:47.110 --> 30:40:49.110
we're going to borrow a lot of
the things that we did from

29537
30:40:49.110 --> 30:40:52.110
here, so I'm just going to come
back here are actually going to

29538
30:40:52.110 --> 30:40:56.110
copy paste these two top bits.
Again, we're gonna do const

29539
30:40:56.110 --> 30:40:59.110
deploy timelock is going to be a
deploy function, it's going to

29540
30:40:59.110 --> 30:41:04.110
be an async function that takes
the heart at runtime environment

29541
30:41:04.110 --> 30:41:08.110
as a parameter, and cool, nearly
exactly the same sorry. And then

29542
30:41:08.110 --> 30:41:10.110
we're going to grab these first
three lines, or first four

29543
30:41:10.110 --> 30:41:14.110
lines, I guess, pesos, then
we're going to be getting those

29544
30:41:14.110 --> 30:41:16.110
exact same things here. And
we're going to be doing nearly

29545
30:41:16.110 --> 30:41:21.110
the exact same thing. So we'll
do log deploying. Time Lock,

29546
30:41:21.110 --> 30:41:28.110
point time lock, will do const.
Mark equals await, deploy,

29547
30:41:28.110 --> 30:41:31.110
unlock. We'll add some
parameters in here, we'll say

29548
30:41:31.110 --> 30:41:36.110
from Deployer. Now does this
take some arguments? It

29549
30:41:36.110 --> 30:41:39.110
absolutely does. Right, we can
take a look at the Time Lock,

29550
30:41:39.110 --> 30:41:43.110
Min delay proposers and
executors. So what do we want

29551
30:41:43.110 --> 30:41:46.110
our min delay to be? Well, this
is a value that we're actually

29552
30:41:46.110 --> 30:41:49.110
going to use a lot. So what I
usually like to do is I create a

29553
30:41:49.110 --> 30:41:56.110
new file called helper. hardhats
config.ts. And right at the top,

29554
30:41:56.110 --> 30:42:01.110
I'll say Export const min.
Delay, and I'll have this delay

29555
30:42:01.110 --> 30:42:04.110
be whatever I want it to be. So
let's just go ahead and do 3600,

29556
30:42:04.110 --> 30:42:06.110
which is going to be
approximately an hour, right,

29557
30:42:06.110 --> 30:42:09.110
you gotta wait this many
seconds, I think that's an hour.

29558
30:42:09.110 --> 30:42:12.110
Without the old calculator.
There's 60 seconds, in 60

29559
30:42:12.110 --> 30:42:16.110
minutes. Great. That's gonna be
one hour. So wait 30 minutes.

29560
30:42:16.110 --> 30:42:18.110
And we're gonna go ahead and
import that here. We'll say

29561
30:42:18.110 --> 30:42:23.110
import, Min delay. Wow,
autocomplete for being great.

29562
30:42:23.110 --> 30:42:27.110
From helper from, you know, it's
down directory, helper Hardhead

29563
30:42:27.110 --> 30:42:30.110
config. And that's gonna be our
first argument here. Our second

29564
30:42:30.110 --> 30:42:32.110
argument is going to be a list
of proposals. Now we're going to

29565
30:42:32.110 --> 30:42:35.110
leave it blank for now. And also
the list of executors we're also

29566
30:42:35.110 --> 30:42:38.110
going to leave it blank for now,
we're going to update this in a

29567
30:42:38.110 --> 30:42:42.110
minute. And you'll see why once
we get there, we'll do log true.

29568
30:42:42.110 --> 30:42:44.110
This also has a wait
confirmations thing in my

29569
30:42:44.110 --> 30:42:47.110
GitHub, but we're going to skip
that for now. It also has an

29570
30:42:47.110 --> 30:42:50.110
auto verify, we're also gonna
skip that for now. Then we just

29571
30:42:50.110 --> 30:42:55.110
need to export default, deploy
timelock. And boom, we should be

29572
30:42:55.110 --> 30:42:59.110
good. So let's try to run this
on hard hat deploying. So now

29573
30:42:59.110 --> 30:43:03.110
this should run both of these
great deployed governance token

29574
30:43:03.110 --> 30:43:04.110
deployed timelock.

29575
30:43:04.110 --> 30:43:08.110
Perfect, we are cruising now
what we want to deploy that

29576
30:43:08.110 --> 30:43:10.110
governance contract now. So
let's go ahead and do that.

29577
30:43:10.110 --> 30:43:18.110
We're gonna do Oh, three LOI.
Gov, nor contract.ts. And you

29578
30:43:18.110 --> 30:43:21.110
guessed it, this is going to
look pretty similar to what we

29579
30:43:21.110 --> 30:43:24.110
just did. Right. So in our
deployed time lock, let's go

29580
30:43:24.110 --> 30:43:27.110
ahead and just grab those top
two things. We'll paste it in

29581
30:43:27.110 --> 30:43:33.110
here. We'll do const deploy,
govern or contract, there's

29582
30:43:33.110 --> 30:43:35.110
going to be an apply function,
it's going to be an async

29583
30:43:35.110 --> 30:43:40.110
function, taking a part at
runtime environment, save and

29584
30:43:40.110 --> 30:43:43.110
close this for now. And we can
even go back and grab these

29585
30:43:43.110 --> 30:43:46.110
three lines from our Oh, to
deploy time lock, paste that

29586
30:43:46.110 --> 30:43:48.110
right in here, because we're
going to need to get the exact

29587
30:43:48.110 --> 30:43:51.110
same things. And additionally,
for this, we're going to need to

29588
30:43:51.110 --> 30:43:55.110
get the governance token and the
Time Lock contract. So we'll do

29589
30:43:55.110 --> 30:44:01.110
const governance, token equals
await. Get which actually, we

29590
30:44:01.110 --> 30:44:03.110
have this, this get function
that comes from these

29591
30:44:03.110 --> 30:44:06.110
deployments, which literally
just goes out and gets these

29592
30:44:06.110 --> 30:44:10.110
deployments. So we'll say get
Gover Nance token. And then we

29593
30:44:10.110 --> 30:44:17.110
also need to get the Time Lock.
So await, get m lock. And we

29594
30:44:17.110 --> 30:44:22.110
need these to pass as parameters
for our governor contract.

29595
30:44:22.110 --> 30:44:27.110
Right? Because if we open up the
governor contract that soul, we

29596
30:44:27.110 --> 30:44:29.110
look at the constructor, it
takes the token, the Time Lock

29597
30:44:29.110 --> 30:44:33.110
voting, delay voting period and
quorum percentage as input

29598
30:44:33.110 --> 30:44:39.110
parameters. So we'll do a quick
log deploying go burn nor ello.

29599
30:44:39.110 --> 30:44:44.110
And they will do const govern
nor contract equals await,

29600
30:44:44.110 --> 30:44:48.110
deploy, and will deploy the
govern nor contract I'm not sure

29601
30:44:48.110 --> 30:44:51.110
if I'm spelling this right
always, but that's fine. And

29602
30:44:51.110 --> 30:44:54.110
we'll do the parameters once
again. So it's gonna be from

29603
30:44:54.110 --> 30:44:58.110
Deployer. args are going to be
this list of args. What's the

29604
30:44:58.110 --> 30:45:02.110
first thing that it needs? It
needs the token first and the

29605
30:45:02.110 --> 30:45:06.110
Time Lock. So we'll do
governance token dot address,

29606
30:45:06.110 --> 30:45:09.110
then it's going to need the Time
Lock that address. And it's

29607
30:45:09.110 --> 30:45:13.110
going to need a vote on voting
delay voting period and quorum

29608
30:45:13.110 --> 30:45:17.110
percentage. So these are also
values that we're going to make

29609
30:45:17.110 --> 30:45:20.110
a lot. So let's open back up
that helper Hardhead config, and

29610
30:45:20.110 --> 30:45:24.110
let's create those as well. So
we'll say Export const just

29611
30:45:24.110 --> 30:45:28.110
voting period. And we'll say
this is going to be five blocks,

29612
30:45:28.110 --> 30:45:32.110
we'll do export const voting
delay, this is going to be just

29613
30:45:32.110 --> 30:45:36.110
one block, which I know is
really quick. And then we're

29614
30:45:36.110 --> 30:45:42.110
gonna need export const Orem
percentage, which we're gonna

29615
30:45:42.110 --> 30:45:47.110
say is four 4% of voters always
need to be voting. Excuse me, 4%

29616
30:45:47.110 --> 30:45:51.110
of voters need to have voted for
a vote to pass. Great. So we're

29617
30:45:51.110 --> 30:45:55.110
going to do voting delay voting
percentage quorum percentage. So

29618
30:45:55.110 --> 30:46:05.110
we'll import those so to import
voting delay voting period, or

29619
30:46:05.110 --> 30:46:08.110
quorum percentage from helper
Hardhead config. And now that we

29620
30:46:08.110 --> 30:46:12.110
have those delay period
percentage, we can just do kind

29621
30:46:12.110 --> 30:46:16.110
of a voting delay, voting
period, farm percentage, and

29622
30:46:16.110 --> 30:46:20.110
then we'll say log is true.
Again, this one as well. It has

29623
30:46:20.110 --> 30:46:23.110
a wait confirmations and auto
verification that we're going to

29624
30:46:23.110 --> 30:46:27.110
totally ignore. And then we'll
export default, blood Governor

29625
30:46:27.110 --> 30:46:30.110
contract. Oh, Carrie, we're
getting spicy. Let's just make

29626
30:46:30.110 --> 30:46:33.110
sure this works. Yarn hardhat
deploy. We should see three

29627
30:46:33.110 --> 30:46:37.110
contracts deployed here. I think
to compile governance, token

29628
30:46:37.110 --> 30:46:40.110
deployed timelock deployed
governance contract deployed.

29629
30:46:40.110 --> 30:46:45.110
Let's go. Alright. Now, we're
not done yet. We have two more

29630
30:46:45.110 --> 30:46:47.110
deploy scripts to do. The first
one, we're going to call setup

29631
30:46:47.110 --> 30:46:51.110
governance contracts. Okay. And
this one's really important. The

29632
30:46:51.110 --> 30:46:55.110
right now our time lock contract
has no proposers and no

29633
30:46:55.110 --> 30:46:59.110
executors. Right. So we want to
change that we want to only

29634
30:46:59.110 --> 30:47:02.110
allow for the proposer to be the
governor, the governor contract

29635
30:47:02.110 --> 30:47:05.110
should be the only one that
proposes things the Time Lock,

29636
30:47:05.110 --> 30:47:07.110
and then anybody should be able
to execute the way that this

29637
30:47:07.110 --> 30:47:10.110
works. We say the governance
contract proposes something to

29638
30:47:10.110 --> 30:47:13.110
the Time Lock once it's in the
Time Lock, and it waits that

29639
30:47:13.110 --> 30:47:17.110
period. Anybody can go ahead and
execute it. So Governor contract

29640
30:47:17.110 --> 30:47:20.110
everybody votes and everything.
Once a vote passes, Governor

29641
30:47:20.110 --> 30:47:23.110
says hey, Time Lock, can you
please propose this? Tom like

29642
30:47:23.110 --> 30:47:26.110
goes yeah, sure. But we got to
wait, this minimum delay, once

29643
30:47:26.110 --> 30:47:29.110
it's been in delay happens,
anybody can execute it. Now this

29644
30:47:29.110 --> 30:47:30.110
would be really cool to do an
integration with chain link

29645
30:47:30.110 --> 30:47:33.110
keepers, by the way, for the
chain link keepers to

29646
30:47:33.110 --> 30:47:36.110
automatically execute. And I
should build the next anyways.

29647
30:47:36.110 --> 30:47:39.110
So we have to set this up so
that these work as such, so

29648
30:47:39.110 --> 30:47:42.110
we're gonna create a new deploy
thing called Oh, four, setup,

29649
30:47:42.110 --> 30:47:46.110
governance contracts dot
TypeScript. And this is going to

29650
30:47:46.110 --> 30:47:49.110
be the code that does all the
setting up. And this is gonna

29651
30:47:49.110 --> 30:47:51.110
look really similar once again,
to all of our other deploy

29652
30:47:51.110 --> 30:47:55.110
functions. So we'll go head back
from oh three, we'll paste these

29653
30:47:55.110 --> 30:47:59.110
two top ones in here, of course,
we're gonna do const setup

29654
30:47:59.110 --> 30:48:03.110
contracts, is it going to be a
deploy function, going to be an

29655
30:48:03.110 --> 30:48:08.110
async function, it's going to
take HRV art at runtime

29656
30:48:08.110 --> 30:48:11.110
environment as parameters, and
then that's the winner right

29657
30:48:11.110 --> 30:48:15.110
there. Cool. And we're gonna be
grabbing those same three from

29658
30:48:15.110 --> 30:48:17.110
the top, as you can see, that
gets a little bit easier,

29659
30:48:17.110 --> 30:48:20.110
because it's kind of repetitive,
right, we're gonna grab that bit

29660
30:48:20.110 --> 30:48:22.110
right here. And now we're gonna
get those contracts so that we

29661
30:48:22.110 --> 30:48:25.110
can interact with them. And this
is another reason why a hard hat

29662
30:48:25.110 --> 30:48:29.110
deploy is so nice, because we
can just do const timelock

29663
30:48:29.110 --> 30:48:33.110
equals await ethers that get in
the next let's go ahead and

29664
30:48:33.110 --> 30:48:38.110
import ethers from hard hat
imports. Ethers

29665
30:48:38.110 --> 30:48:44.110
from Red Hat will even drop a
little TS ignore here. Ethers

29666
30:48:44.110 --> 30:48:47.110
dot get contract, we want that
time lock contract. And we say

29667
30:48:47.110 --> 30:48:50.110
we want to attach it to the
Deployer. So whenever we call a

29668
30:48:50.110 --> 30:48:52.110
function on it, it'll be the
deployer calling that function

29669
30:48:52.110 --> 30:48:57.110
and we want to do const Governor
equals await ethers dot get

29670
30:48:57.110 --> 30:49:01.110
contract, Governor contract,
this is all going to be attached

29671
30:49:01.110 --> 30:49:05.110
to the Deployer. Right. Now,
we're gonna do log setting up

29672
30:49:05.110 --> 30:49:09.110
roles. And we're going to set up
the roles right, again, we're

29673
30:49:09.110 --> 30:49:12.110
setting it up so that only the
governor can send things to this

29674
30:49:12.110 --> 30:49:15.110
time lock, because the Time Lock
is going to be you can almost

29675
30:49:15.110 --> 30:49:17.110
think of the Time Lock as like
the president. Right. So

29676
30:49:17.110 --> 30:49:20.110
everything goes to the Senate,
the House representative, which

29677
30:49:20.110 --> 30:49:23.110
is the governor and then the
President just says yeah, sure.

29678
30:49:23.110 --> 30:49:26.110
We just got to wait this minimum
delay, but the President will be

29679
30:49:26.110 --> 30:49:27.110
the one to actually execute
everything which I'm not

29680
30:49:27.110 --> 30:49:30.110
actually sure that's how it
really works in in politics, but

29681
30:49:30.110 --> 30:49:33.110
for for now, that's that's where
we're protecting the president

29682
30:49:33.110 --> 30:49:36.110
or the time like is the only one
that can actually do anything

29683
30:49:36.110 --> 30:49:40.110
here. So the way that this works
is we're actually going to get

29684
30:49:40.110 --> 30:49:43.110
the byte codes of different
roles, right? So if you look at

29685
30:49:43.110 --> 30:49:49.110
these time locks here, so we'll
do ones up on contracts. And we

29686
30:49:49.110 --> 30:49:53.110
go to the governance here. We go
to Tama controller has these

29687
30:49:53.110 --> 30:49:57.110
things called proposal roll,
executor roll time, like admin,

29688
30:49:57.110 --> 30:50:01.110
etc. And these are just hashes
of these strings here. But these

29689
30:50:01.110 --> 30:50:05.110
are these are bytes 32 saying,
Hey, anybody who has this this

29690
30:50:05.110 --> 30:50:08.110
byte 32 is a proposer, anybody
who has this byte 32 is an

29691
30:50:08.110 --> 30:50:10.110
executor. Anybody has this byte
there and soon as time like

29692
30:50:10.110 --> 30:50:14.110
admin, etc. Right now, our
Deployer account is the time

29693
30:50:14.110 --> 30:50:17.110
like admin, and that's bad. We
don't want that we don't want

29694
30:50:17.110 --> 30:50:20.110
anyone to be a time like admin,
right? We don't want anyone to

29695
30:50:20.110 --> 30:50:24.110
have power over this time lock.
We don't want any centralized

29696
30:50:24.110 --> 30:50:26.110
force here. So what we're going
to do is we're going to const

29697
30:50:26.110 --> 30:50:30.110
we're going to get those roles.
proposer, proposer role, it's

29698
30:50:30.110 --> 30:50:35.110
going to be a weight, unlock
that row pole sir role. And if

29699
30:50:35.110 --> 30:50:38.110
you're familiar with multi call,
this would be a great time to do

29700
30:50:38.110 --> 30:50:44.110
multi call and copy paste that
whole line x EQ tour role at x

29701
30:50:44.110 --> 30:50:50.110
EQ tour roll, we're gonna copy
this whole line admin role. And

29702
30:50:50.110 --> 30:50:54.110
this is going to be on lock
admin role. So these are these

29703
30:50:54.110 --> 30:50:58.110
three roles that we need to fix,
right, and let's go ahead and

29704
30:50:58.110 --> 30:51:00.110
fix them. So the first thing
we're gonna need to do is we're

29705
30:51:00.110 --> 30:51:06.110
gonna need to do const row poser
dx equals await Time Lock dot

29706
30:51:06.110 --> 30:51:10.110
grant roll, propose a roll to
our governor dot address. So

29707
30:51:10.110 --> 30:51:14.110
saying, okay, Governor, you're
the only one who can actually do

29708
30:51:14.110 --> 30:51:17.110
anything once you tell the Time
Lock to do something. We'll wait

29709
30:51:17.110 --> 30:51:20.110
for the Time Lock period to be
over. And then we'll be done.

29710
30:51:20.110 --> 30:51:24.110
And then we'll just do an await
posit TX dot wait one block just

29711
30:51:24.110 --> 30:51:29.110
to make sure. Now we're gonna do
the const executor, TX equals

29712
30:51:29.110 --> 30:51:36.110
await Time Lock dot grant roll
executor role to nobody, we're

29713
30:51:36.110 --> 30:51:39.110
going to execute this we're
gonna give this to nobody, we're

29714
30:51:39.110 --> 30:51:41.110
going to say address zero which
is going to be something that

29715
30:51:41.110 --> 30:51:45.110
we're going to want to add if we
go to our helper or head config

29716
30:51:45.110 --> 30:51:51.111
will say Export const address
zero equals zero by you can just

29717
30:51:51.111 --> 30:51:53.111
copy paste this if you want.
There's a couple other ways you

29718
30:51:53.111 --> 30:51:56.111
can do this with ethers as well.
We're just gonna do like this. I

29719
30:51:56.111 --> 30:52:00.111
like having my conflict this and
then we just import it say

29720
30:52:00.111 --> 30:52:05.111
import at zero from dot dot
slash helper Harnett config. So

29721
30:52:05.111 --> 30:52:08.111
we're giving the executor role
to nobody, which means

29722
30:52:08.111 --> 30:52:12.111
everybody. So once a proposers
thing has gone through, anybody

29723
30:52:12.111 --> 30:52:16.111
can execute it. So we'll say
executor, TX That wait one wait

29724
30:52:16.111 --> 30:52:21.111
a block. And then got one more
to do here, we need to revoke

29725
30:52:21.111 --> 30:52:25.111
role right now our Deployer
count owns that time lock

29726
30:52:25.111 --> 30:52:28.111
controller, right. And that's
how we can actually do these

29727
30:52:28.111 --> 30:52:31.111
transactions, we can actually
grant role because our Deployer

29728
30:52:31.111 --> 30:52:34.111
account owns it now that we've
given everybody access. And

29729
30:52:34.111 --> 30:52:37.111
given all the decentralized
access we need, we want to

29730
30:52:37.111 --> 30:52:41.111
revoke that role. So const
revoke TX equals await. I'm

29731
30:52:41.111 --> 30:52:48.111
locked up revoke role, admin
role from Deployer will do Rotex

29732
30:52:48.111 --> 30:52:51.111
that wait, now guess what
anything that's um, like, wants

29733
30:52:51.111 --> 30:52:54.111
to do has to go through
governance, and nobody owns the

29734
30:52:54.111 --> 30:52:57.111
time I controller, it's
currently after this runs, it's

29735
30:52:57.111 --> 30:53:00.111
impossible for anyone to do
anything with the Time Lock

29736
30:53:00.111 --> 30:53:03.111
without governance happening.
And then of course, when the

29737
30:53:03.111 --> 30:53:07.111
export default set of contracts,
great. And then the last step

29738
30:53:07.111 --> 30:53:11.111
that we need to do here is we
need to deploy the contract that

29739
30:53:11.111 --> 30:53:14.111
we actually want to govern over
write that box contract, that

29740
30:53:14.111 --> 30:53:17.111
real basic contract. So we're
gonna create a new 105, deploy

29741
30:53:17.111 --> 30:53:21.111
box.ts. And we're gonna do some
of the same exact stuff we've

29742
30:53:21.111 --> 30:53:24.111
done right, so we're gonna grab
these two, these two here, paste

29743
30:53:24.111 --> 30:53:29.111
it in, os deploy box is going to
be a deploy function equals

29744
30:53:29.111 --> 30:53:34.111
async function, Ah, sorry, hard
hat runtime environment,

29745
30:53:34.111 --> 30:53:38.111
we're gonna grab those first
three lines, the TS ignore, just

29746
30:53:38.111 --> 30:53:42.111
like that. And now we're going
to deploy this box. So log,

29747
30:53:42.111 --> 30:53:47.111
deploying bucks, and we're going
to do const box equals await,

29748
30:53:47.111 --> 30:53:53.111
deploy box, give us some values
from our Deployer. args does

29749
30:53:53.111 --> 30:53:56.111
this have any args so open a box
dot soul, I don't see a

29750
30:53:56.111 --> 30:53:59.111
constructor. And while this is
the easiest contract out of all

29751
30:53:59.111 --> 30:54:03.111
these though, no constructor,
and then we'll just say log,

29752
30:54:03.111 --> 30:54:06.111
it's going to be true. And
again, if you want to check out

29753
30:54:06.111 --> 30:54:09.111
my GitHub repo for that
confirmations, but feel free to

29754
30:54:09.111 --> 30:54:13.111
do so it's coming here. And
right now, our deployer has

29755
30:54:13.111 --> 30:54:16.111
actually deployed this right,
not our time lock. So we want to

29756
30:54:16.111 --> 30:54:21.111
give the boxes ownership over to
our governance process. So now

29757
30:54:21.111 --> 30:54:24.111
we're going to do say const
timelock, is going to be a

29758
30:54:24.111 --> 30:54:28.111
weight ethers dot get contract.
The same thing as before.

29759
30:54:28.111 --> 30:54:33.111
timelock. We're going to grab
ethers from hardhat import

29760
30:54:33.111 --> 30:54:38.111
ethers from hard hat. And we're
gonna do a little TLS ignore,

29761
30:54:38.111 --> 30:54:42.111
it's being finicky. And then
we're going to transfer the

29762
30:54:42.111 --> 30:54:46.111
ownership of our box to this
time lock, okay, and now so this

29763
30:54:46.111 --> 30:54:49.111
is actually what's known as a
box deployment. So before we do

29764
30:54:49.111 --> 30:54:51.111
that, we have to get the box
contract. So this is a box

29765
30:54:51.111 --> 30:54:54.111
deployment object, which doesn't
have contract functions we want

29766
30:54:54.111 --> 30:54:58.111
to get the box contract object
so we to box or const box

29767
30:54:58.111 --> 30:55:06.111
contract equals await ethers dot
get contract at box and then

29768
30:55:06.111 --> 30:55:09.111
we'll just do you know box that
address. You could also do get

29769
30:55:09.111 --> 30:55:12.111
contract. Actually both of these
pretty much if you have the

29770
30:55:12.111 --> 30:55:15.111
address, you can just do box
that address. You could also do

29771
30:55:15.111 --> 30:55:17.111
get contract here. Either one
works now that we have the box

29772
30:55:17.111 --> 30:55:24.111
contract, we do const transfer
owner, dx equals await by

29773
30:55:24.111 --> 30:55:30.111
contract dot transfer TX or
schema dot transfer ownership to

29774
30:55:30.111 --> 30:55:36.111
our timelock dot address, time
walk dot address, then we just

29775
30:55:36.111 --> 30:55:43.111
do a weight transfer ownership
TX dot weight one, do a log, you

29776
30:55:43.111 --> 30:55:51.111
done it. Those are export
default. Deploy box. Oh, let's

29777
30:55:51.111 --> 30:55:56.111
see if this works. So we just
did everything. We're deploying

29778
30:55:56.111 --> 30:55:59.111
the GOV token, deploying the
timelock, which owns the

29779
30:55:59.111 --> 30:56:02.111
governance process, we're
deployed the governance process,

29780
30:56:02.111 --> 30:56:05.111
we're setting up the governance
process so that it's totally

29781
30:56:05.111 --> 30:56:08.111
decentralized. And then we
deployed and set up our box so

29782
30:56:08.111 --> 30:56:13.111
that it only can be updated
through a governance process.

29783
30:56:13.111 --> 30:56:18.111
Let's see if it works. Yarn,
hard hat deploy. Let's see if it

29784
30:56:18.111 --> 30:56:23.111
works. Bada boom, you've done
it. So you've just set up a

29785
30:56:23.111 --> 30:56:27.111
script to set this entire
governance process up so you can

29786
30:56:27.111 --> 30:56:31.111
build your own doubt. Are you
still here? Well, hell yeah, you

29787
30:56:31.111 --> 30:56:35.111
are, congratulations on getting
this far, we have one more piece

29788
30:56:35.111 --> 30:56:37.111
to go, we just got to write
those scripts. So we can

29789
30:56:37.111 --> 30:56:40.111
actually interact with this, we
can actually do a governance, we

29790
30:56:40.111 --> 30:56:42.111
can actually see exactly what
the governance process looks

29791
30:56:42.111 --> 30:56:45.111
like. Now again, if you didn't
watch my last video on Dows, be

29792
30:56:45.111 --> 30:56:47.111
sure to watch that, because
that's going to give you all the

29793
30:56:47.111 --> 30:56:51.111
context for this part here. And
if you're still watching 100%,

29794
30:56:51.111 --> 30:56:54.111
smash the like button, hit the
subscribe, leave a comment in

29795
30:56:54.111 --> 30:56:57.111
the comment section below, it
really helps the channel out. So

29796
30:56:57.111 --> 30:56:59.111
proud of you for getting this
far. We're almost there, you're

29797
30:56:59.111 --> 30:57:02.111
getting now one more to go. And
then you are home free on

29798
30:57:02.111 --> 30:57:06.111
building your doubt. Let's get
back into it.

29799
30:57:06.111 --> 30:57:08.111
Alright, so now we're going to
make some scripts to actually

29800
30:57:08.111 --> 30:57:13.111
interact with propose Q and vote
on anything that happens in our

29801
30:57:13.111 --> 30:57:16.111
Dao. And these are the scripts,
these are kind of the things

29802
30:57:16.111 --> 30:57:18.111
that you would do on your front
end when you build this when you

29803
30:57:18.111 --> 30:57:20.111
build your doubt on the front
end. Or you could do an

29804
30:57:20.111 --> 30:57:23.111
integration with snapshot or
tally or something like that.

29805
30:57:23.111 --> 30:57:26.111
And again, if you want to see
come to full functionality on

29806
30:57:26.111 --> 30:57:29.111
the GitHub, I have this test
flow.ts It's not the greatest

29807
30:57:29.111 --> 30:57:31.111
test here. But you can also
check this out, because it also

29808
30:57:31.111 --> 30:57:35.111
does a soup to nuts
demonstration of going through

29809
30:57:35.111 --> 30:57:37.111
this exact process. So let's go
ahead and start making some

29810
30:57:37.111 --> 30:57:40.111
scripts. So we're gonna create a
new folder called scripts. And

29811
30:57:40.111 --> 30:57:43.111
this is where we're going to put
all of our scripts. Now the

29812
30:57:43.111 --> 30:57:47.111
process for this is going to be
we're first going to propose

29813
30:57:47.111 --> 30:57:50.111
something right? You know, maybe
we're going to propose that our

29814
30:57:50.111 --> 30:57:55.111
box contract stores the value
77, right? Because when it first

29815
30:57:55.111 --> 30:57:57.111
gets initialized, it's going to
start with zero. So maybe we'll

29816
30:57:57.111 --> 30:58:02.111
we'll propose it could start at
77. Once proposing is done, we

29817
30:58:02.111 --> 30:58:04.111
are voting on it. Right once
proposals it and we're going to

29818
30:58:04.111 --> 30:58:07.111
vote on whether or not we want
the proposal to go through right

29819
30:58:07.111 --> 30:58:12.111
yes or no. And then if it
passes, we go to queue and

29820
30:58:12.111 --> 30:58:15.111
execute, we queue first. And
then we execute, I'm just

29821
30:58:15.111 --> 30:58:18.111
putting them both in the same
script to make it easier. So

29822
30:58:18.111 --> 30:58:21.111
let's start with propose here,
because it's going to be the

29823
30:58:21.111 --> 30:58:23.111
first thing that we're going to
do. So let's create a new

29824
30:58:23.111 --> 30:58:27.111
function. We'll call it async
function, and then we'll

29825
30:58:27.111 --> 30:58:30.111
actually export it to export
async function propose. And

29826
30:58:30.111 --> 30:58:32.111
we're going to be in here for a
little bit. So let's clear

29827
30:58:32.111 --> 30:58:35.111
everything out. And okay, cool.
So this is where we're actually

29828
30:58:35.111 --> 30:58:38.111
going to propose on our governor
contract, right? So we're going

29829
30:58:38.111 --> 30:58:40.111
to propose a new governor
contract. So the first thing

29830
30:58:40.111 --> 30:58:42.111
we're gonna need, of course, is
gonna be the governor. So you

29831
30:58:42.111 --> 30:58:49.111
can't govern nor equals await
ethers dot get contract, govern

29832
30:58:49.111 --> 30:58:52.111
or contract, right? Since we're
doing ethers, we're gonna have

29833
30:58:52.111 --> 30:58:57.111
to do import ethers from heart
app. And then we're still

29834
30:58:57.111 --> 30:59:01.111
getting that fundamental thing.
We'll do a little AT Ts ignore

29835
30:59:01.111 --> 30:59:03.111
here. Cool. So we have the
governor contract here, we're

29836
30:59:03.111 --> 30:59:06.111
going to need the box contract,
we're gonna say hey, we want to

29837
30:59:06.111 --> 30:59:10.111
propose the box contract changes
the store value. So we'll do

29838
30:59:10.111 --> 30:59:16.111
const box equals await ethers
dot get this is a gift contract,

29839
30:59:16.111 --> 30:59:19.111
we want get contract, get
contracts at box. And those are

29840
30:59:19.111 --> 30:59:22.111
the two main ones that we're
going to need just to start.

29841
30:59:22.111 --> 30:59:26.111
Now, if we look at the proposed
function, right, if we go to

29842
30:59:26.111 --> 30:59:29.111
governance, we go to Governor,
and we look at that proposed.

29843
30:59:29.111 --> 30:59:31.111
This is what it looks like. Now,
I explained this proposed

29844
30:59:31.111 --> 30:59:34.111
function in my last video. So if
you haven't seen it, be sure to

29845
30:59:34.111 --> 30:59:37.111
go back and watch it right
because it'll give you

29846
30:59:37.111 --> 30:59:39.111
everything that you need to know
here are basically we pick a

29847
30:59:39.111 --> 30:59:42.111
list of targets, which our list
is just going to be just our box

29848
30:59:42.111 --> 30:59:45.111
contract. These are the targets
that we want to call functions

29849
30:59:45.111 --> 30:59:48.111
on, we do values like how much
needed ether we want to send,

29850
30:59:48.111 --> 30:59:51.111
which we're not going to send
anything, we have bytes, a array

29851
30:59:51.111 --> 30:59:55.111
called data. So this is going to
be our encoded parameters for

29852
30:59:55.111 --> 30:59:58.111
the function that we want to
call and then a description. So

29853
30:59:58.111 --> 31:00:01.111
that's exactly what we're going
to do here. So first, we need to

29854
31:00:01.111 --> 31:00:03.111
figure out what we're going to
do. So look at Box, we're going

29855
31:00:03.111 --> 31:00:06.111
to call this store function with
this new value here. So we need

29856
31:00:06.111 --> 31:00:10.111
to encode we need to encode this
socks here. And we also need to

29857
31:00:10.111 --> 31:00:13.111
encode what we want to upgrade
it to right so we have to code

29858
31:00:13.111 --> 31:00:17.111
all the function parameters. So
we'll do const encoded function

29859
31:00:17.111 --> 31:00:21.111
call equals box and the way we
can get this box that interface

29860
31:00:21.111 --> 31:00:25.111
that encode function data and
This is what actually turns it

29861
31:00:25.111 --> 31:00:29.111
to being this bytes call data,
right? So we're encoding

29862
31:00:29.111 --> 31:00:32.111
everything and this encoded
function, you can find this in

29863
31:00:32.111 --> 31:00:36.111
the ethers documentation, we
have to pass it the function to

29864
31:00:36.111 --> 31:00:38.111
call, and then the arguments we
want to pass, right, and this is

29865
31:00:38.111 --> 31:00:42.111
how we actually get that. So
let's get these arguments here.

29866
31:00:42.111 --> 31:00:44.111
So we're gonna say args, we're
going to make our proposed

29867
31:00:44.111 --> 31:00:47.111
function a little bit modular.
So we're gonna say args is going

29868
31:00:47.111 --> 31:00:50.111
to be an array of anything, and
then we're gonna say function to

29869
31:00:50.111 --> 31:00:53.111
call is just going to be a
string, right, and then right at

29870
31:00:53.111 --> 31:00:56.111
the bottom, we're actually gonna
call this, this proposed

29871
31:00:56.111 --> 31:01:00.111
function. So we're gonna say
propose, and let's say we want

29872
31:01:00.111 --> 31:01:02.111
to give it 77, the function is
going to be what it's going to

29873
31:01:02.111 --> 31:01:06.111
be store, store. And that's a
string. And this needs to be a

29874
31:01:06.111 --> 31:01:09.111
list. So we're going to do like
this. Now, we're actually going

29875
31:01:09.111 --> 31:01:12.111
to use this all over the place.
So since we're gonna be using

29876
31:01:12.111 --> 31:01:16.111
this all over the place, we want
to stick them in this part head

29877
31:01:16.111 --> 31:01:18.111
helper config. So what we're
going to do is we're gonna say,

29878
31:01:18.111 --> 31:01:23.111
export const, new store value
equals 77. And we're gonna do

29879
31:01:23.111 --> 31:01:29.111
export const funk equals store.
And I propose, we're just going

29880
31:01:29.111 --> 31:01:33.111
to import those. So we'll do
import, new store value, and

29881
31:01:33.111 --> 31:01:38.111
also funk from helper Hardhead
dot config, and it added it in

29882
31:01:38.111 --> 31:01:41.111
for us, which is great. So we'll
just put new store value in

29883
31:01:41.111 --> 31:01:44.111
here. And then we'll put funk in
here. And I know this might look

29884
31:01:44.111 --> 31:01:46.111
a little confusing, but
basically, the first thing we're

29885
31:01:46.111 --> 31:01:48.111
gonna do is we're gonna call
this proposed function which

29886
31:01:48.111 --> 31:01:51.111
calls you know, post function up
here. Now we're going to do some

29887
31:01:51.111 --> 31:01:56.111
fun little then process that
exit zero. And then we're going

29888
31:01:56.111 --> 31:02:00.111
to do a dot catch error, which
if there's an error, basically,

29889
31:02:00.111 --> 31:02:05.111
we'll just do console dot log
error, then process that makes

29890
31:02:05.111 --> 31:02:10.111
it. And this is pretty typical
setup for a really any script

29891
31:02:10.111 --> 31:02:13.111
you work with, and hardhat. So
great. So we have constant coded

29892
31:02:13.111 --> 31:02:16.111
function call, which has this
function to call an arc. So

29893
31:02:16.111 --> 31:02:19.111
we're basically combining these
into this bytes thing. And we

29894
31:02:19.111 --> 31:02:21.111
can even print this out, you can
see what this looks like. So you

29895
31:02:21.111 --> 31:02:24.111
do console dot log, you see that
this is like this, this crazy

29896
31:02:24.111 --> 31:02:28.111
bytes thing here. And the way we
can kind of test this, we'll do

29897
31:02:28.111 --> 31:02:33.111
yarn hardhat node, which will
spin up again, our fake

29898
31:02:33.111 --> 31:02:35.111
blockchain. But additionally,
with Hardhead deploy, it will

29899
31:02:35.111 --> 31:02:39.111
deploy all of our contracts
here, right, we can see timelog

29900
31:02:39.111 --> 31:02:43.111
governance, you know, everything
that we need for testing locally

29901
31:02:43.111 --> 31:02:46.111
has already been done. So once
we have that up, we can then do

29902
31:02:46.111 --> 31:02:52.111
yarn hardhat, run scripts,
propose that TS dash dash

29903
31:02:52.111 --> 31:02:55.111
network, local host, this is
important to do, again, because

29904
31:02:55.111 --> 31:02:57.111
when you're working with a node
that's running locally, you're

29905
31:02:57.111 --> 31:02:59.111
going to be working with local
host, we'll see what it prints

29906
31:02:59.111 --> 31:03:01.111
out here.

29907
31:03:01.111 --> 31:03:05.111
Contract named Governor
contracts, Governor contract.

29908
31:03:05.111 --> 31:03:09.111
Let's try that again. And cool,
you can see this is what that

29909
31:03:09.111 --> 31:03:13.111
encoded function call and
arguments looks like is this

29910
31:03:13.111 --> 31:03:16.111
really long byte string. But if
you were to decode this, using

29911
31:03:16.111 --> 31:03:19.111
the box interface, you would get
the function call and the

29912
31:03:19.111 --> 31:03:22.111
arguments, which is really
exciting. So cool, we've encoded

29913
31:03:22.111 --> 31:03:25.111
it to bytes. And now what we
want to do, we encourage the

29914
31:03:25.111 --> 31:03:27.111
bytes, and now we're going to
create that proposal

29915
31:03:27.111 --> 31:03:32.111
transaction. So we'll do console
dot log will say pro posing, and

29916
31:03:32.111 --> 31:03:37.111
say, function to call on box
that address with args. And then

29917
31:03:37.111 --> 31:03:41.111
we also need to pass a proposal
description. So we're gonna say

29918
31:03:41.111 --> 31:03:46.111
pro pose, all description, we
would do it on new line, why

29919
31:03:46.111 --> 31:03:50.111
not? Pro pulls all this option,
which we don't have yet.

29920
31:03:50.111 --> 31:03:52.111
Alright, we're gonna get it. So
we also need to pass a proposal

29921
31:03:52.111 --> 31:03:56.111
description, right, because we
have down here, description. So

29922
31:03:56.111 --> 31:03:59.111
let's add another parameter to
our propose here. So we'll say

29923
31:03:59.111 --> 31:04:04.111
proposal description, and this
will be also a string. Down at

29924
31:04:04.111 --> 31:04:07.111
the bottom, we're going to need
a proposal description as well.

29925
31:04:07.111 --> 31:04:11.111
So we'll create a proposal or
export const proposal

29926
31:04:11.111 --> 31:04:13.111
description, there's just going
to be some string. So we'll say

29927
31:04:13.111 --> 31:04:19.111
proposal number one, door 77 In
the box, that's the description

29928
31:04:19.111 --> 31:04:22.111
here, comma proposal
description. And then we import

29929
31:04:22.111 --> 31:04:25.111
this or a helper config. Okay,
perfect. So now we have the new

29930
31:04:25.111 --> 31:04:29.111
store value, the function the
proposal description, and we can

29931
31:04:29.111 --> 31:04:32.111
now call that propose that we
were just looking at so here's

29932
31:04:32.111 --> 31:04:38.111
what we're going to do const
propose TX equals await. gov dot

29933
31:04:38.111 --> 31:04:42.111
propose. And we need to pass
those lists. So first is going

29934
31:04:42.111 --> 31:04:44.111
to be a list of targets, which
for us is just a box that

29935
31:04:44.111 --> 31:04:47.111
address right only one target.
And again, these these little

29936
31:04:47.111 --> 31:04:49.111
brackets, make it a list of
values, which is just going to

29937
31:04:49.111 --> 31:04:54.111
be zero, a list of encoded
function calls or our bytes

29938
31:04:54.111 --> 31:04:58.111
data, basically, and then the
proposal description, and then

29939
31:04:58.111 --> 31:05:02.111
we're going to do propose, TX
dot wait one. Now, if you

29940
31:05:02.111 --> 31:05:06.111
remember, from compound, this is
going to be the exact same if we

29941
31:05:06.111 --> 31:05:10.111
go back to compound back to
governance, this transaction is

29942
31:05:10.111 --> 31:05:14.111
literally going to be the same
as this created thing here.

29943
31:05:14.111 --> 31:05:17.111
Right? And if we scroll down,
like more, we can see the code

29944
31:05:17.111 --> 31:05:20.111
input data, those exact same
things on a compound proposal,

29945
31:05:20.111 --> 31:05:24.111
right? We have targets values
signatures, well okay, this CES

29946
31:05:24.111 --> 31:05:27.111
is a little bit more, this a
little bit more advanced here,

29947
31:05:27.111 --> 31:05:29.111
using signatures, but it's got
the same thing called data and

29948
31:05:29.111 --> 31:05:33.111
then a description here, okay.
Now since we have a voting

29949
31:05:33.111 --> 31:05:36.111
delay, people actually can't
vote until the voting delay

29950
31:05:36.111 --> 31:05:39.111
passes. Now, with a local
blockchain, nobody's actually

29951
31:05:39.111 --> 31:05:43.111
processing blocks and time
doesn't really pass as quick as

29952
31:05:43.111 --> 31:05:46.111
we want. And so we're just going
to speed things up for our own

29953
31:05:46.111 --> 31:05:49.111
testing purposes. So the way I
normally do this is I create

29954
31:05:49.111 --> 31:05:53.111
this this variable, all
development, exports, on

29955
31:05:53.111 --> 31:05:59.111
development chains, and I'll add
hard hat and local host. Because

29956
31:05:59.111 --> 31:06:01.111
we can actually do things with
our own local blockchain, we can

29957
31:06:01.111 --> 31:06:04.111
actually speed up time, we can
speed up blocks, we can do all

29958
31:06:04.111 --> 31:06:07.111
this crazy stuff. So usually,
I'll actually import this in

29959
31:06:07.111 --> 31:06:10.111
here. And then we'll do a quick
F. And I'll say, if we're on a

29960
31:06:10.111 --> 31:06:12.111
development chain, let's just go
ahead and speed things up for

29961
31:06:12.111 --> 31:06:18.111
us. Right. So I'll say if
development chains that includes

29962
31:06:18.111 --> 31:06:22.111
network dot name, and then we
can import network from from

29963
31:06:22.111 --> 31:06:24.111
ethers, as well. And this is
what I was talking about those

29964
31:06:24.111 --> 31:06:26.111
super six skills that you're
gonna learn. If it includes

29965
31:06:26.111 --> 31:06:29.111
network dot name, then we're
gonna go ahead and move the

29966
31:06:29.111 --> 31:06:31.111
blocks forward, right, because
if we're not on development

29967
31:06:31.111 --> 31:06:34.111
chain, we can't actually move
blocks. So what we'll do here is

29968
31:06:34.111 --> 31:06:37.111
actually I'll create a new
folder called utilities, you

29969
31:06:37.111 --> 31:06:41.111
folder, you are utils. And in
here, I'll create a script

29970
31:06:41.111 --> 31:06:46.111
called Move blocks.ts. And we're
just going to create this little

29971
31:06:46.111 --> 31:06:49.111
function called move blocks,
which moves blocks for us. And

29972
31:06:49.111 --> 31:06:51.111
you'll see how we do this. So
we're going to import network

29973
31:06:51.111 --> 31:06:54.111
from heart app, because we want
to speed up that voting delay,

29974
31:06:54.111 --> 31:06:58.111
we'll do export async function,
we'll call it move blocks. And

29975
31:06:58.111 --> 31:07:01.111
it'll take an amount, which will
be a number, so how many blocks

29976
31:07:01.111 --> 31:07:04.111
that we actually want to move.
And then we'll just do console

29977
31:07:04.111 --> 31:07:10.111
dot log moving blocks. And we'll
say for let index equals zero,

29978
31:07:10.111 --> 31:07:15.111
index is less than amount. index
plus plus, or we're going to do

29979
31:07:15.111 --> 31:07:19.111
is we're going to do a weight
network DAP provider dot request

29980
31:07:19.111 --> 31:07:25.111
request. And we're going to
request method EVM. Mine. So

29981
31:07:25.111 --> 31:07:30.111
basically, we're mining for our
local blockchain, right, so you

29982
31:07:30.111 --> 31:07:34.111
can find these docks in the hard
hat docks in the ethers docks,

29983
31:07:34.111 --> 31:07:36.111
there's a couple different
places you can find these. But

29984
31:07:36.111 --> 31:07:40.111
this is kind of this really cool
hack that we can use to actually

29985
31:07:40.111 --> 31:07:42.111
move blocks forward on our local
chain. Now, obviously, this

29986
31:07:42.111 --> 31:07:45.111
won't work on an actual chain,
because you'd actually have to

29987
31:07:45.111 --> 31:07:47.111
do the mining but on our local
chains, we can absolutely do

29988
31:07:47.111 --> 31:07:51.111
this. So we've exported this
move blocks function, and we're

29989
31:07:51.111 --> 31:07:55.111
actually gonna grab that Mark
propose, we're going to import

29990
31:07:55.111 --> 31:08:01.111
move box from utils blocks. And
we're going to say down here, if

29991
31:08:01.111 --> 31:08:04.111
we're on this development chain,
and do a weight move blocks, and

29992
31:08:04.111 --> 31:08:07.111
then we'll move blocks by that
voting delay that we were

29993
31:08:07.111 --> 31:08:09.111
talking about, right? Because we
need to wait that voting delay

29994
31:08:09.111 --> 31:08:12.111
in order to move and it looks
like an auto import it for us

29995
31:08:12.111 --> 31:08:14.111
from our helper hardware config.
I told you, we were gonna use

29996
31:08:14.111 --> 31:08:16.111
that a couple of times, but
we're gonna move blocks by that

29997
31:08:16.111 --> 31:08:19.111
voting delay. Now, this proposed
transaction does some stuff that

29998
31:08:19.111 --> 31:08:22.111
we actually want, right? So one
of the big things that it wants

29999
31:08:22.111 --> 31:08:25.111
is, is it has this proposal ID.
And if we scroll down to the

30000
31:08:25.111 --> 31:08:29.111
event that it emits, it ends up
emitting this proposal ID, we

30001
31:08:29.111 --> 31:08:33.112
actually need the proposal ID
for later on when we actually go

30002
31:08:33.112 --> 31:08:35.112
to vote. So what we're going to
do is we're actually going to do

30003
31:08:35.112 --> 31:08:41.112
const propose receipt equals
proposed text dot weight. And

30004
31:08:41.112 --> 31:08:44.112
we're going to get those events
from this proposed receipt. So

30005
31:08:44.112 --> 31:08:49.112
we're gonna say const. Proposal,
id equals proposed receipt, that

30006
31:08:49.112 --> 31:08:52.112
events, the zero with event
because that first event is the

30007
31:08:52.112 --> 31:08:56.112
only one we care about that are
your stop proposal ID. This is

30008
31:08:56.112 --> 31:09:00.112
how we get this proposal ID from
this omit also created event. A

30009
31:09:00.112 --> 31:09:03.112
couple other ways to get
proposals to get events in

30010
31:09:03.112 --> 31:09:05.112
hardhat. And I got a video on it
on my YouTube, if you want to go

30011
31:09:05.112 --> 31:09:08.112
check that out. Something else
that we want to do is maybe we

30012
31:09:08.112 --> 31:09:11.112
want to see what the deadline is
with a snapshot, you can go

30013
31:09:11.112 --> 31:09:13.112
ahead and check my GitHub to
kind of see what the snapshot

30014
31:09:13.112 --> 31:09:16.112
looks like or the deadline,
basically, how long we have to

30015
31:09:16.112 --> 31:09:18.112
vote, you know what snapshot
you're working with, and all

30016
31:09:18.112 --> 31:09:20.112
these different things. But for
now, we're just gonna stick with

30017
31:09:20.112 --> 31:09:22.112
the proposal Id be sure to check
out the GitHub for more stuff.

30018
31:09:22.112 --> 31:09:25.112
Now we want to save this
proposal ID, we want to save it

30019
31:09:25.112 --> 31:09:27.112
somewhere so that our other
scripts so that our vote and our

30020
31:09:27.112 --> 31:09:31.112
queue and execute know what this
proposal ID is going to be when

30021
31:09:31.112 --> 31:09:33.112
we run those. So what we're
going to do is we're going to

30022
31:09:33.112 --> 31:09:36.112
create this file called
proposals dot JSON. And it's

30023
31:09:36.112 --> 31:09:38.112
going to store all of our
proposals. So we're gonna say

30024
31:09:38.112 --> 31:09:42.112
pro poll, souls dot JSON, it's
going to have all of our

30025
31:09:42.112 --> 31:09:45.112
proposals in here. So what we're
going to do and we're going to

30026
31:09:45.112 --> 31:09:48.112
add this to our helper Hardhead
config, and do export const,

30027
31:09:48.112 --> 31:09:52.112
proposals, file equals proposals
dot JSON. And we're going to

30028
31:09:52.112 --> 31:09:56.112
import this at the top as well
as proposals file. And then once

30029
31:09:56.112 --> 31:09:59.112
we get this proposal ID, we're
going to do is we're going to

30030
31:09:59.112 --> 31:10:02.112
read all the current proposals.
So we're gonna say let proposals

30031
31:10:02.112 --> 31:10:08.112
equals JSON dot parse, and we're
gonna do Fs dot read file sync

30032
31:10:08.112 --> 31:10:13.112
from this probe proposals file,
and we're going to pass it to

30033
31:10:13.112 --> 31:10:18.112
UTF eight. Now, this Fs we don't
have yet, so we're going to need

30034
31:10:18.112 --> 31:10:23.112
to import Fs. So we're going to
do yarn add Fs like that. If

30035
31:10:23.112 --> 31:10:26.112
we're looking at package dot
JSON. Oops, I should have saved

30036
31:10:26.112 --> 31:10:31.112
that as Dev, but I didn't Oh,
well, doesn't really matter. Now

30037
31:10:31.112 --> 31:10:33.112
that we have that we can
actually import this into our

30038
31:10:33.112 --> 31:10:38.112
TypeScript. So we're just going
to say, import star as Fs from

30039
31:10:38.112 --> 31:10:42.112
Fs. And now we can actually use
Fs F as a way to kind of read

30040
31:10:42.112 --> 31:10:45.112
from files. Now we can get this
list of proposals. So we got two

30041
31:10:45.112 --> 31:10:48.112
proposals that JSON right now
we're just making a blank JSON.

30042
31:10:48.112 --> 31:10:51.112
So the first time we run it,
it'll just be blank. But later

30043
31:10:51.112 --> 31:10:54.112
on, it'll have stuff in it. And
the way that we're going to save

30044
31:10:54.112 --> 31:10:58.112
these proposals is we're going
to say pro proposals of network

30045
31:10:58.112 --> 31:11:02.112
dot config dot chain ID, and
this little bank to say, yes,

30046
31:11:02.112 --> 31:11:06.112
there will be a chain id.to
string, we're going to store

30047
31:11:06.112 --> 31:11:09.112
them by their chain IDs, right.
So for each network that we have

30048
31:11:09.112 --> 31:11:12.112
a proposal to we'll we'll start
like that. And then we'll do dot

30049
31:11:12.112 --> 31:11:17.112
push proposal, id.to string, and
then we'll write it back. We'll

30050
31:11:17.112 --> 31:11:23.112
do Fs dot right, file sync,
proposals file. JSON does string

30051
31:11:23.112 --> 31:11:28.112
phi, proposals, and awesome. And
that's all we need to do. So

30052
31:11:28.112 --> 31:11:30.112
let's go ahead and actually run
this. And then I have some

30053
31:11:30.112 --> 31:11:32.112
console dot logs in here saying,
Hey, here's what the proposal

30054
31:11:32.112 --> 31:11:35.112
state is, is it open? Is it
voting is it canceled, you know,

30055
31:11:35.112 --> 31:11:38.112
etc. What the proposal snapshot
is, you know, again, check my

30056
31:11:38.112 --> 31:11:42.112
GitHub for that. But what we can
do, now this is done, we can do

30057
31:11:42.112 --> 31:11:46.112
yarn, Hardhead node, spin up our
little note here. And all the

30058
31:11:46.112 --> 31:11:50.112
contracts are deployed. And then
we'll do yarn, run scripts,

30059
31:11:50.112 --> 31:11:54.112
proposed that TS dash dash
network, local host scripts

30060
31:11:54.112 --> 31:12:01.112
proposed that TS is not found.
Pro pose, yarn, hard hat, run

30061
31:12:01.112 --> 31:12:06.112
scripts, pose IDs, oops, dash
dash network, local hosts. Try

30062
31:12:06.112 --> 31:12:10.112
this again. Now you found it.
Yay. Oh, I ran into an issue.

30063
31:12:10.112 --> 31:12:12.112
Although description Moviebox
Cannot read property zero of

30064
31:12:12.112 --> 31:12:16.112
undefined. Let's see where it
got mad at me. Poser sheet dot

30065
31:12:16.112 --> 31:12:20.112
event. It is events, not event
shots again, on the localhost.

30066
31:12:20.112 --> 31:12:23.112
There we go running ran into
another issue. Posle already

30067
31:12:23.112 --> 31:12:27.112
exists. Okay, so great. So the
proposal already exists, let's

30068
31:12:27.112 --> 31:12:30.112
go ahead and just like kill the
node, restart the node, so you

30069
31:12:30.112 --> 31:12:33.112
can't have two proposals that
are exactly the same, basically,

30070
31:12:33.112 --> 31:12:35.112
right. So we can't do that, we
would need to change the

30071
31:12:35.112 --> 31:12:37.112
description or something. So
we're just going to kill the

30072
31:12:37.112 --> 31:12:39.112
node and restart. Now we're
going to run this proposal

30073
31:12:39.112 --> 31:12:44.112
again. And hopefully this one
should work this time. Community

30074
31:12:44.112 --> 31:12:49.112
Property zero of undefined owes
receipt. This needs to be await

30075
31:12:49.112 --> 31:12:53.112
because it is a promise, kill
this one more time we run it

30076
31:12:53.112 --> 31:12:55.112
once all these get deployed. And
we're gonna go ahead and run

30077
31:12:56.112 --> 31:12:58.112
this. Now you can see how much
quicker this is than if you were

30078
31:12:58.112 --> 31:13:00.112
to actually send this to a test
net right to an event a lot of

30079
31:13:00.112 --> 31:13:06.112
waiting, which is no bueno. And
we run into one more Cannot read

30080
31:13:06.112 --> 31:13:09.112
property, push them undefined.
That makes a lot of sense, too.

30081
31:13:09.112 --> 31:13:13.112
Because proposals dot JSON as
nothing for chain IDs. So

30082
31:13:13.112 --> 31:13:18.112
231337. And we'll put a little
list in here. Right now it's an

30083
31:13:18.112 --> 31:13:21.112
empty list. Now we're going to
kill this one more time, kill

30084
31:13:21.112 --> 31:13:23.112
it.

30085
31:13:23.112 --> 31:13:25.112
And then once this goes, then
we're gonna go ahead and do

30086
31:13:25.112 --> 31:13:29.112
this. Perfect. Now we're going
to run this and now it should

30087
31:13:29.112 --> 31:13:34.112
save and everything should be
peachy hunky dory. Awesome.

30088
31:13:34.112 --> 31:13:38.112
proposal number one store in the
box, we move the blocks. And if

30089
31:13:38.112 --> 31:13:41.112
we look at proposal dot JSON, we
now see there's a list of

30090
31:13:41.112 --> 31:13:44.112
proposals. And this is the
proposal ID of that one we just

30091
31:13:44.112 --> 31:13:47.112
created. Oh, okay, we made a
proposal. Awesome. Nice work,

30092
31:13:47.112 --> 31:13:50.112
we'll leave that Node running.
And hopefully we'll just do

30093
31:13:50.112 --> 31:13:54.112
things right for the voting. So
let's create this vote script

30094
31:13:54.112 --> 31:13:58.112
now. Okay, so now we proposed
it's time to vote, let's do a

30095
31:13:58.112 --> 31:14:00.112
little voting. So this is going
to look pretty similar to that

30096
31:14:00.112 --> 31:14:03.112
script, we just we just created
right. So we're in New async

30097
31:14:03.112 --> 31:14:08.112
function, we'll call this main
proposal index number, and we're

30098
31:14:08.112 --> 31:14:11.112
calling this main because we're
going to have the vote function

30099
31:14:11.112 --> 31:14:13.112
be a little bit different.
You'll see why. And at the

30100
31:14:13.112 --> 31:14:17.112
bottom, of course, we're going
to do main index dot then

30101
31:14:17.112 --> 31:14:24.112
process dot exit zero, catch
error arrow function, console

30102
31:14:24.112 --> 31:14:30.112
dot error, error, and then
process that exit. One main

30103
31:14:30.112 --> 31:14:34.112
index, we're gonna say our index
zero cost index zero. We'll do

30104
31:14:34.112 --> 31:14:36.112
like this cost index is your
postal index. So we're gonna get

30105
31:14:36.112 --> 31:14:39.112
we're gonna get that bit zero
with index, right, the first

30106
31:14:39.112 --> 31:14:42.112
index in our proposals dot JSON.
So whatever is the first one in

30107
31:14:42.112 --> 31:14:44.112
this list is what we're gonna
use, right? And that's what we

30108
31:14:44.112 --> 31:14:46.112
want right now. There's only one
so it's easy. So we're gonna get

30109
31:14:46.112 --> 31:14:49.112
that first one in here. So first
thing we're gonna need to do is

30110
31:14:49.112 --> 31:14:52.112
we're gonna need to grab the
list of proposals. So we're

30111
31:14:52.112 --> 31:14:57.112
gonna do const proposals equals
JSON dot parse, FS dot read,

30112
31:14:57.112 --> 31:15:02.112
file sync proposals file, UTF,
eight. So of course, we're going

30113
31:15:02.112 --> 31:15:05.112
to need to import a bunch of
stuff. We're going to import

30114
31:15:05.112 --> 31:15:10.112
proposals file from that a slash
a Bernhard config. And then

30115
31:15:10.112 --> 31:15:16.112
we're going to do import star as
Fs from us. Great. We have Fs,

30116
31:15:16.112 --> 31:15:19.112
we can read stuff, and we can
get those boats. Okay, cool. So

30117
31:15:19.112 --> 31:15:22.112
we have a list of proposal IDs.
Now let's get our proposal idea

30118
31:15:22.112 --> 31:15:28.112
we'll do const probo. also ID
equals proposals of network dot

30119
31:15:28.112 --> 31:15:32.112
config. And then that's not what
we want. We want to actually

30120
31:15:32.112 --> 31:15:37.112
import network, import network
from hard hat, network dot

30121
31:15:37.112 --> 31:15:43.112
config, that chain ID,
exclamation mark of proposal

30122
31:15:43.112 --> 31:15:45.112
index, which for us is going to
be zero, right? We're getting

30123
31:15:45.112 --> 31:15:48.112
that first proposal in the list
of proposals. Now we're gonna

30124
31:15:48.112 --> 31:15:52.112
choose how we want to vote. So
zero equals against one equals

30125
31:15:52.112 --> 31:15:55.112
four, and then two is abstain. I
don't know why you'd ever

30126
31:15:55.112 --> 31:15:58.112
abstain abstaining costs gas,
you could just not vote, but

30127
31:15:58.112 --> 31:16:01.112
we're gonna say const vote way
and the way we're gonna vote

30128
31:16:01.112 --> 31:16:05.112
equals one. And we can also do a
reason. So if we go back to our

30129
31:16:05.112 --> 31:16:07.112
governor, there's a couple
different functions we get to do

30130
31:16:07.112 --> 31:16:10.112
to vote, there's cast vote,
where we just cast a vote, cast,

30131
31:16:10.112 --> 31:16:14.112
vote with reason, and cast vote
with signature where we actually

30132
31:16:14.112 --> 31:16:17.112
do a signature. And I asked this
question, Hey, what is cast vote

30133
31:16:17.112 --> 31:16:19.112
by sick do on the opens up on
forum, I was like, hey, what's

30134
31:16:19.112 --> 31:16:22.112
the what is the purpose of this?
My hunch was that anyone could

30135
31:16:22.112 --> 31:16:25.112
then execute this vote on behalf
of me if I didn't send the

30136
31:16:25.112 --> 31:16:27.112
transaction. And that's exactly
what it is. This method

30137
31:16:27.112 --> 31:16:30.112
implements a meta transaction
and allows a project to

30138
31:16:30.112 --> 31:16:32.112
subsidize voting fees, the
voters can generate a signature

30139
31:16:32.112 --> 31:16:35.112
for free, and the project can
submit those and pay for the

30140
31:16:35.112 --> 31:16:38.112
gas. So this is incredibly
powerful. And this is the

30141
31:16:38.112 --> 31:16:43.112
function that allows this, this,
this cast vote by signature is

30142
31:16:43.112 --> 31:16:46.112
what allows that snapshot chain
link integration that you know,

30143
31:16:46.112 --> 31:16:49.112
hopefully one of you build, but
for us for this, since we're not

30144
31:16:49.112 --> 31:16:52.112
implementing these meta
transactions, these off chain

30145
31:16:52.112 --> 31:16:54.112
stuff, we're just going to do
cast a vote with reason why

30146
31:16:54.112 --> 31:16:57.112
because we want to give it a
reason. That's really it. So

30147
31:16:57.112 --> 31:17:03.112
we're gonna say const boat TX
response equals await. Gov nor

30148
31:17:03.112 --> 31:17:06.112
dot cast, excuse me, we need to
get the government contract. So

30149
31:17:06.112 --> 31:17:11.112
we'll do const. Gov nor equals
await ethers dot get contract.

30150
31:17:11.112 --> 31:17:14.112
Gov contract. And then if we
don't have ethers, we should get

30151
31:17:14.112 --> 31:17:18.112
ethers. Great. Let's get ethers.
And we'll ignore that. But now

30152
31:17:18.112 --> 31:17:21.112
we have the contract. So we'll
do a weight gov dot cast vote

30153
31:17:21.112 --> 31:17:25.112
with reason spell this right?
With reason. And we'll say

30154
31:17:25.112 --> 31:17:29.112
proposal ID that way. And then
the reason which we don't have a

30155
31:17:29.112 --> 31:17:33.112
reason here, so let's make a
reason. Let's say the reason is

30156
31:17:33.112 --> 31:17:39.112
reason, equals I like do cha
cha, if you know that film, you

30157
31:17:39.112 --> 31:17:41.112
should definitely comment it in
the description. We have a

30158
31:17:41.112 --> 31:17:45.112
reason so we're voting for we're
saying yes, we want we do indeed

30159
31:17:45.112 --> 31:17:49.112
want you to change the box to
77. And the reason is because I

30160
31:17:49.112 --> 31:17:52.112
like a do the Cha Cha makes
perfect sense if you don't think

30161
31:17:52.112 --> 31:17:56.112
about and then we'll do a wait,
Kotex response that wait. So I

30162
31:17:56.112 --> 31:17:59.112
do some stuff, again, checking
the state of the proposal where

30163
31:17:59.112 --> 31:18:02.112
different numbers mean, hey,
it's in process, it's voting,

30164
31:18:02.112 --> 31:18:04.112
etc, we could check on that. But
we're gonna skip that for now.

30165
31:18:04.112 --> 31:18:07.112
All we're going to do now, now
that we voted, we're going to be

30166
31:18:07.112 --> 31:18:09.112
the ones to vote. So we're just
going to once again move the

30167
31:18:09.112 --> 31:18:13.112
blocks along. Why because we
want to just get to the end of

30168
31:18:13.112 --> 31:18:16.112
that voting period. So we're
gonna do again, if velopment

30169
31:18:16.112 --> 31:18:20.112
chains, that includes network
dot name, then we're gonna do a

30170
31:18:20.112 --> 31:18:25.112
weight move blocks, voting
period, plus one. So we need to

30171
31:18:25.112 --> 31:18:28.112
import a whole bunch of stuff in
here. poses file development,

30172
31:18:28.112 --> 31:18:31.112
looks like those got auto
imported, we need to import this

30173
31:18:31.112 --> 31:18:37.112
move blocks. So import move
blocks from utils blocks, and

30174
31:18:37.112 --> 31:18:40.112
that network is in here. And
then we need voting period from

30175
31:18:40.112 --> 31:18:43.112
our helper config. voting
period. Okay, cool. And then

30176
31:18:43.112 --> 31:18:49.112
we'll do console dot log, voted,
ready to go. Now the reason that

30177
31:18:49.112 --> 31:18:52.112
I checked the proposal state is
because there's this state

30178
31:18:52.112 --> 31:18:55.112
function in the governor
contract. So if we look up

30179
31:18:55.112 --> 31:18:59.112
state, what this does is it
tells us what the state of the

30180
31:18:59.112 --> 31:19:02.112
proposals in right if it's been
executed, return that's been

30181
31:19:02.112 --> 31:19:05.112
executed, if it's been canceled,
return has been canceled. You

30182
31:19:05.112 --> 31:19:08.112
have the deadline, check to see
if it's active, check to see if

30183
31:19:08.112 --> 31:19:10.112
quorum reached all this stuff,
right? And what you're usually

30184
31:19:10.112 --> 31:19:14.112
looking for is worm reached and
vote succeeded, right? If both

30185
31:19:14.112 --> 31:19:17.112
of these happen, the proposal
state DOT succeeded, right?

30186
31:19:17.112 --> 31:19:20.112
Otherwise, it's defeated or it's
not there yet. I believe this is

30187
31:19:20.112 --> 31:19:23.112
a one and this is a zero. So if
you were to call that function

30188
31:19:23.112 --> 31:19:27.112
and get the state right, now we
should get a zero. Or excuse me,

30189
31:19:27.112 --> 31:19:29.112
we should get a one for this
having passed. If you want to do

30190
31:19:29.112 --> 31:19:32.112
that as a little extra credit,
feel free to do so. So let's see

30191
31:19:32.112 --> 31:19:34.112
if we did this right. Well,
actually, I guess we got to

30192
31:19:34.112 --> 31:19:37.112
change this just to vote. But I
just wrapped everything up into

30193
31:19:37.112 --> 31:19:40.112
main. So let's see if this
works. Yarn, hard hat run

30194
31:19:40.112 --> 31:19:44.112
scripts vote network, local
host. So we should get a little

30195
31:19:44.112 --> 31:19:48.112
console dot log at the bottom
that says voted ready to go. So

30196
31:19:48.112 --> 31:19:51.112
now we're voting. We didn't just
go to the Arctic Council, we

30197
31:19:51.112 --> 31:19:56.112
could do yarn, hard hat console,
dash dash network, local host.

30198
31:19:56.112 --> 31:19:58.112
And in here, you can actually
just check the state right in

30199
31:19:58.112 --> 31:20:02.112
here. Why not? We'll copy this
line as governor because we

30200
31:20:02.112 --> 31:20:06.112
either get contract Governor
contract. Now we can do a wait,

30201
31:20:06.112 --> 31:20:12.112
Governor, that's state of go to
the proposals dot JSON, grab

30202
31:20:12.112 --> 31:20:16.112
this, paste it in here. And we
get a for the state of this

30203
31:20:16.112 --> 31:20:19.112
right now is for I forget what
four means. It's like a proposal

30204
31:20:19.112 --> 31:20:22.112
state. The proposal state is
actually in the eye governor so

30205
31:20:22.112 --> 31:20:27.112
the interface of the governor We
can see, zero is pending, one is

30206
31:20:27.112 --> 31:20:30.112
active, two cancelled, three
defeated, and four have

30207
31:20:30.112 --> 31:20:34.112
succeeded. So we are in a
succeeded state, which is really

30208
31:20:34.112 --> 31:20:36.112
good. That's exactly what we
want. So let's go ahead and quit

30209
31:20:36.112 --> 31:20:41.112
now. Excuse me Ctrl. C, our
proposal is now in a succeeded

30210
31:20:41.112 --> 31:20:44.112
state. And we've actually moved
the blocks along the voting

30211
31:20:44.112 --> 31:20:47.112
period. So voting is now over
because we cheated. So now let's

30212
31:20:47.112 --> 31:20:52.112
go ahead and queue and execute
this to the last bit here. So

30213
31:20:52.112 --> 31:20:53.112
this is gonna look real similar
to what we've done already.

30214
31:20:53.112 --> 31:20:59.112
Right? Let's minimize this,
export async, function, Q, and

30215
31:20:59.112 --> 31:21:04.112
execute. And then at the bottom,
we'll just call queue, and

30216
31:21:04.112 --> 31:21:07.112
execute. And I'm just going to
copy paste, but it's that same

30217
31:21:07.112 --> 31:21:10.112
syntax here, then process exec
catch, blah, blah, blah, you get

30218
31:21:10.112 --> 31:21:14.112
the drill. So in order to queue
and execute, go back to the

30219
31:21:14.112 --> 31:21:16.112
governor contract, not the
governor, let's go to the

30220
31:21:16.112 --> 31:21:19.112
governor. First thing we're
going to do is call this queue.

30221
31:21:19.112 --> 31:21:24.112
Now this Q function is actually
in the governor time lock, which

30222
31:21:24.112 --> 31:21:27.112
is in this extensions here. So
we can find the governor Time

30223
31:21:27.112 --> 31:21:31.112
Lock controller here, and it
does exactly the same as propose

30224
31:21:31.112 --> 31:21:34.112
we take everything that we did
in the proposal, and then we

30225
31:21:34.112 --> 31:21:37.112
just queue it like so. So we
pass the exact same values here.

30226
31:21:37.112 --> 31:21:40.112
And that's so cute. So what
we're going to do is we're gonna

30227
31:21:40.112 --> 31:21:42.112
need to first get those exact
same values, which I told you

30228
31:21:42.112 --> 31:21:45.112
we're going to use a few times.
So we're going to import bunk,

30229
31:21:45.112 --> 31:21:51.112
new store value, proposal
description of our article

30230
31:21:51.112 --> 31:21:53.112
thing, right now that we have
all that stuff, we'll say const

30231
31:21:53.112 --> 31:21:56.112
args equals a new store value,

30232
31:21:56.112 --> 31:22:03.112
we'll do const box equals await
ethers dot get contract, let's

30233
31:22:03.112 --> 31:22:06.112
get that box contract again,
we're gonna have to import

30234
31:22:06.112 --> 31:22:11.112
ethers from our hat. And this is
going to be from we're gonna do

30235
31:22:11.112 --> 31:22:16.112
TS ignore, then we're once again
code this function call to const

30236
31:22:16.112 --> 31:22:21.112
encoded function call equals
Boxtop interface, encode

30237
31:22:21.112 --> 31:22:25.112
function data. Once again, we're
gonna do funk is the function we

30238
31:22:25.112 --> 31:22:28.112
want to call and args this is
like real similar to the our

30239
31:22:28.112 --> 31:22:31.112
proposed bit that we did. And
then we're gonna do content

30240
31:22:31.112 --> 31:22:38.112
description hash equals ethers
dot utils that get GAC 256

30241
31:22:38.112 --> 31:22:43.112
ethers dot utils, that to you,
TF eight bytes, this will make

30242
31:22:43.112 --> 31:22:47.112
sense in a second. We're also
description. So what's our

30243
31:22:47.112 --> 31:22:51.112
propose, all we did was pass our
proposal description, however,

30244
31:22:51.112 --> 31:22:54.112
it actually gets hashed on
chain, and that's what our view

30245
31:22:54.112 --> 31:22:56.112
and execute is gonna be looking
for, it's gonna be looking for

30246
31:22:56.112 --> 31:22:59.112
the description hash, instead of
just the pure description,

30247
31:22:59.112 --> 31:23:01.112
right, and it's gonna be a
little bit cheaper gas wise,

30248
31:23:01.112 --> 31:23:04.112
which is good. So now that we
have the description hash, now

30249
31:23:04.112 --> 31:23:06.112
that we have all the same
functions that we did for the

30250
31:23:06.112 --> 31:23:11.112
suppose it's time to queue them.
So do cost gov equals await

30251
31:23:11.112 --> 31:23:16.112
ethers dot get contract. Gov
contract, console dot log will

30252
31:23:16.112 --> 31:23:23.112
say we're queuing and then we'll
do cos Q, dx equals gov dot q.

30253
31:23:23.112 --> 31:23:26.112
And we're going to pass the
exact same parameters we did

30254
31:23:26.112 --> 31:23:28.112
with the pose except for what
the hash instead of the actual

30255
31:23:28.112 --> 31:23:33.112
proposal, so box that address
zero for eath, and pass that

30256
31:23:33.112 --> 31:23:38.112
code at function call. And then
the description hash rate. And

30257
31:23:38.112 --> 31:23:42.112
then we're going to do oops, is
going to be a weight here. And

30258
31:23:42.112 --> 31:23:46.112
then we're gonna do a wait. You
text Oh, wait, one, wait a block

30259
31:23:46.112 --> 31:23:50.112
there. And great, then we're all
queued up. Now we still have to

30260
31:23:50.112 --> 31:23:53.112
wait that minimum delay, right?
Remember, on our timeline, it's

30261
31:23:53.112 --> 31:23:56.112
got this min delay thing. It
says, Hey, once something gets

30262
31:23:56.112 --> 31:23:59.112
queued up, you can't just
execute it right away. You gotta

30263
31:23:59.112 --> 31:24:02.112
give people time to get out. So
we're going to speed up time

30264
31:24:02.112 --> 31:24:06.112
again, we're going to say if
development chains develop l

30265
31:24:06.112 --> 31:24:09.112
meant chains that includes and
then it looks like it auto

30266
31:24:09.112 --> 31:24:13.112
imported for me development
chains. Yes, it did. Amazing.

30267
31:24:13.112 --> 31:24:16.112
That includes network dot name.
Let's just make sure we import

30268
31:24:16.112 --> 31:24:20.112
network from Hardhead. That
includes our name, then, of

30269
31:24:20.112 --> 31:24:23.112
course, we're going to move
blocks. But we also actually

30270
31:24:23.112 --> 31:24:26.112
have to move time here as the
minimum delay is looking for

30271
31:24:26.112 --> 31:24:31.112
some time. So let's create a new
util called Move time. Okay,

30272
31:24:31.112 --> 31:24:36.112
move time that Yes. And this
util is going to allow us to

30273
31:24:36.112 --> 31:24:38.112
move time so you're learning all
the cool stuff. So we'll quickly

30274
31:24:38.112 --> 31:24:41.112
write a script to do this
important network from hard hat

30275
31:24:41.112 --> 31:24:47.112
export async function move time,
how much time will be a number

30276
31:24:47.112 --> 31:24:52.112
of Mount console dot log, moving
time, and let's say await

30277
31:24:52.112 --> 31:24:59.112
network dot provider dot send
EVM increase time and then just

30278
31:24:59.112 --> 31:25:03.112
by the amount, then we'll just
say console dot log, move

30279
31:25:03.112 --> 31:25:07.112
forward, amount seconds, it goes
forward and seconds. Cool. So

30280
31:25:07.112 --> 31:25:10.112
now we have this move time
function. That was pretty quick,

30281
31:25:10.112 --> 31:25:12.112
right? So first, we're going to
move time and we're gonna move

30282
31:25:12.112 --> 31:25:16.113
time by that min delay first,
plus one just to be safe. And

30283
31:25:16.113 --> 31:25:18.113
then we're also going to move
blocks. We're gonna do a weight

30284
31:25:18.113 --> 31:25:22.113
move time, and then a weight
move blocks. And we'll just move

30285
31:25:22.113 --> 31:25:27.113
on block. So got it Import move
blocks from utils. It imports

30286
31:25:27.113 --> 31:25:32.113
move time from those utils as
well, time. And then we also

30287
31:25:32.113 --> 31:25:35.113
have to import this min delay,
which we get from our helper.

30288
31:25:35.113 --> 31:25:38.113
Hardhead config. Great. So we
moved all that stuff. Again, if

30289
31:25:38.113 --> 31:25:41.113
this were a real chain, you just
have to wait. But since we're

30290
31:25:41.113 --> 31:25:43.113
not a real chain, we can do
whatever we want. Yes, love

30291
31:25:43.113 --> 31:25:46.113
doing whatever I want. Now that
it's all cued up, the voters

30292
31:25:46.113 --> 31:25:52.113
passed, we're looking spicy.
Let's drive this home. Xe cuting

30293
31:25:52.113 --> 31:25:57.113
do a little console dot log
executing the const execute TX

30294
31:25:57.113 --> 31:26:01.113
equals await. gov dot execute.
We're going to pass this the

30295
31:26:01.113 --> 31:26:05.113
exact same set of things we did
for the Q TX so I'm literally

30296
31:26:05.113 --> 31:26:08.113
gonna copy this. paste it down
here. And then we're just going

30297
31:26:08.113 --> 31:26:13.113
to do a weight SQ TX dot weight.
We're going to wait one block.

30298
31:26:13.113 --> 31:26:18.113
And then the final hour we'll
see if the governance updated

30299
31:26:18.113 --> 31:26:23.113
our box contract const box new
value equals await box dot

30300
31:26:23.113 --> 31:26:30.113
retrieve. And that will do
console dot log. New box value.

30301
31:26:30.113 --> 31:26:35.113
Box new value.to string Oh, so
if we did this right, it's new

30302
31:26:35.113 --> 31:26:39.113
box value to be updated. Let's
see if we did it right yarn hard

30303
31:26:39.113 --> 31:26:45.113
hat run grips Q and execute now
work localhost. Did we do it

30304
31:26:45.113 --> 31:26:50.113
right? Are we successfully done
governance? We did. That's okay.

30305
31:26:50.113 --> 31:26:52.113
We're gonna figure out what we
did wrong. Did you mean could

30306
31:26:52.113 --> 31:26:57.113
check 256 I spelt some stuff
wrong. It needs to be spelt like

30307
31:26:57.113 --> 31:27:01.113
no CK. Just just k. Okay, let's
try again. It failed before it

30308
31:27:01.113 --> 31:27:04.113
actually did. I think that's
good. Queuing moving time

30309
31:27:04.113 --> 31:27:08.113
provider EVM and crit cuz I
spelt increased time wrong. Oh,

30310
31:27:08.113 --> 31:27:15.113
no EVM increase time to just
double check. Make sure I'm

30311
31:27:15.113 --> 31:27:18.113
spelling this right T is
actually capital. So I totally

30312
31:27:18.113 --> 31:27:21.113
messed up. So it's actually
already been queued. It's been

30313
31:27:21.113 --> 31:27:25.113
queued right now on our little
node EVM increased team. So we

30314
31:27:25.113 --> 31:27:28.113
can either delete and kind of
restart, or I can just go ahead

30315
31:27:28.113 --> 31:27:31.113
and I'm just going to comment
out a bunch of stuff, we're just

30316
31:27:31.113 --> 31:27:34.113
going to skip the cueing here.
We're gonna run this one more

30317
31:27:34.113 --> 31:27:37.113
time, because it's already been
queued. And now should just

30318
31:27:37.113 --> 31:27:40.113
execute, we're gonna move time
again. But that's fine. Oh, my

30319
31:27:40.113 --> 31:27:43.113
goodness, we did it. Right. And
then normally, you would just do

30320
31:27:43.113 --> 31:27:46.113
it in one script. But this queue
would fail because it was

30321
31:27:46.113 --> 31:27:49.113
already queued. Right, you can't
queue twice, move forward. In

30322
31:27:49.113 --> 31:27:54.113
time, we move blocks we executed
and we got a new box value

30323
31:27:54.113 --> 31:27:58.113
completely using our Dow
completely decentralized voting

30324
31:27:58.113 --> 31:28:03.113
completely on chain, no third
party trust going in on here.

30325
31:28:03.113 --> 31:28:06.113
There's no voting booth, there's
no you know, spending 1000s of

30326
31:28:06.113 --> 31:28:10.113
dollars on staff, everything we
just voted on happened right in

30327
31:28:10.113 --> 31:28:13.113
front of our faces. Now, again,
I highly recommend go to my

30328
31:28:13.113 --> 31:28:16.113
GitHub repo, you take a look and
you see what's going on here.

30329
31:28:16.113 --> 31:28:18.113
Again, if you want to see
JavaScript stuff, feel free to

30330
31:28:18.113 --> 31:28:21.113
do some JavaScript stuff. But
this goes over how to just get

30331
31:28:21.113 --> 31:28:24.113
clone and get started if you
want to do that as well. But if

30332
31:28:24.113 --> 31:28:28.113
you walked with me here, if you
walked through this with me, you

30333
31:28:28.113 --> 31:28:31.113
have learned in the absolute
Khan, thank you so much for

30334
31:28:31.113 --> 31:28:35.113
being here. And I'll see you
next time.

30335
31:28:35.113 --> 31:28:40.113
All right. Now, welcome to the
final section of our course, the

30336
31:28:40.113 --> 31:28:44.113
security and auditing section,
this one is going to be a little

30337
31:28:44.113 --> 31:28:47.113
bit less coding and a little bit
more explaining. And most of

30338
31:28:47.113 --> 31:28:49.113
what we're going to be learning
about here is in this Hardhead

30339
31:28:49.113 --> 31:28:53.113
security FCC section. Throughout
this course, we've given you a

30340
31:28:53.113 --> 31:28:57.113
couple of tips about different
security features. One, we

30341
31:28:57.113 --> 31:29:00.113
talked about reentrancy, we
talked a little bit about Oracle

30342
31:29:00.113 --> 31:29:03.113
Tax, and we're going to talk
about those more. And some of

30343
31:29:03.113 --> 31:29:07.113
the tools we can use to make our
code more efficient, to look out

30344
31:29:07.113 --> 31:29:11.113
for bugs, and to make our code
more secure. So we're gonna go

30345
31:29:11.113 --> 31:29:15.113
ahead, we're gonna go over this
hard hat security FCC code base,

30346
31:29:15.113 --> 31:29:18.113
and we're going to walk through
it a little bit. So one of the

30347
31:29:18.113 --> 31:29:22.113
first things that we're going to
talk about is, what is an audit?

30348
31:29:22.113 --> 31:29:25.113
Well, an audit is going to be a
security focused code review,

30349
31:29:25.113 --> 31:29:29.113
looking for issues with your
code. So for example, let's say

30350
31:29:29.113 --> 31:29:31.113
we have some code that looks
like this, this should be a

30351
31:29:31.113 --> 31:29:34.113
little bit familiar, because we
talked about this in one of our

30352
31:29:34.113 --> 31:29:38.113
earlier sections with
reentrancy, our code, withdraw,

30353
31:29:38.113 --> 31:29:42.113
goes and sends ether and then
updates the balances, this code

30354
31:29:42.113 --> 31:29:45.113
is clearly vulnerable to a
reentrancy attack here. And this

30355
31:29:45.113 --> 31:29:48.113
is something that an auditor
would catch. Since when we

30356
31:29:48.113 --> 31:29:50.113
deploy our code, that code is
immutable. And that code will

30357
31:29:50.113 --> 31:29:54.113
always be there, it's really
important to have these security

30358
31:29:54.113 --> 31:29:57.113
reviews done before we deploy
our code to a main net, and

30359
31:29:57.113 --> 31:30:00.113
before we go live, so if you're
going to deploy some crazy,

30360
31:30:00.113 --> 31:30:02.113
massive defy protocol, and
you're gonna have billions of

30361
31:30:02.113 --> 31:30:05.113
dollars of people's money locked
into your protocol, you probably

30362
31:30:05.113 --> 31:30:07.113
want to make sure that the money
is going to go to the correct

30363
31:30:07.113 --> 31:30:12.113
places. So audits are incredibly
important for the lifecycle of

30364
31:30:12.113 --> 31:30:15.113
our projects. And we want people
to peer review, we want people

30365
31:30:15.113 --> 31:30:19.113
to review our code to make sure
that everything looks good. Now,

30366
31:30:19.113 --> 31:30:22.113
when we send our code to audit,
though, we shouldn't just say

30367
31:30:22.113 --> 31:30:25.113
hey, here's our code. Can you
check them Make sure it's good.

30368
31:30:25.113 --> 31:30:27.113
That's not going to give an
auditor enough information, they

30369
31:30:27.113 --> 31:30:30.113
need to be able to very easily
know what your code does, how to

30370
31:30:30.113 --> 31:30:34.113
work with it, and what you're
looking for. Because auditors

30371
31:30:34.113 --> 31:30:36.113
aren't going to be kind of this,
this failsafe, where if your

30372
31:30:36.113 --> 31:30:39.113
code is terrible, they're going
to catch everything. Auditors

30373
31:30:39.113 --> 31:30:42.113
are human beings too. They can
miss things as well, auditors.

30374
31:30:42.113 --> 31:30:45.113
Also, don't make sure that your
code is bug free. Like I said,

30375
31:30:45.113 --> 31:30:49.113
audits are security focused peer
reviews for your codebase. And

30376
31:30:49.113 --> 31:30:52.113
when you do send your code to
audit, you want to make sure you

30377
31:30:52.113 --> 31:30:56.113
help out your auditors as much
as possible. There's an amazing

30378
31:30:56.113 --> 31:30:59.113
tweet thread from Tinto and
previously was an open Zeplin

30379
31:30:59.113 --> 31:31:02.113
auditor with a ton of tips and
tricks for working with

30380
31:31:02.113 --> 31:31:06.113
auditors, I highly recommend you
pause the video, you click this

30381
31:31:06.113 --> 31:31:08.113
link and you read through his
tweets because they are

30382
31:31:08.113 --> 31:31:12.113
fantastic. openzeppelin has a
readiness guide to try to help

30383
31:31:12.113 --> 31:31:16.113
you make sure that you're even
ready for an audit in the first

30384
31:31:16.113 --> 31:31:18.113
place. And we've got a link to
this readiness guide in the

30385
31:31:18.113 --> 31:31:22.113
GitHub repository. The summary
of them are to add comments to

30386
31:31:22.113 --> 31:31:26.113
your code, use natspec, which we
learned about to document your

30387
31:31:26.113 --> 31:31:29.113
functions, document your
functions, document your

30388
31:31:29.113 --> 31:31:33.113
functions, test, be ready to
talk to your auditors, and be

30389
31:31:33.113 --> 31:31:36.113
prepared to give them plenty of
time. They are literally pouring

30390
31:31:36.113 --> 31:31:39.113
themselves over your code for
weeks on end to make sure

30391
31:31:39.113 --> 31:31:42.113
there's nothing wrong. If you
rush your auditors, you're gonna

30392
31:31:42.113 --> 31:31:45.113
get a rushed audit, and they're
going to miss things. So let's

30393
31:31:45.113 --> 31:31:48.113
talk about the auditing process.
In auditing process is going to

30394
31:31:48.113 --> 31:31:51.113
look like this. First, they're
going to run your tests. That's

30395
31:31:51.113 --> 31:31:54.113
the first step in order is
always going to take and right

30396
31:31:54.113 --> 31:31:56.113
there, they're gonna find okay,
do they have enough code

30397
31:31:56.113 --> 31:32:00.113
coverage? Is everything passing?
What do the tests do? What is

30398
31:32:00.113 --> 31:32:04.113
the optimal functionality, after
an auditor runs tests, they're

30399
31:32:04.113 --> 31:32:07.113
going to read specs or run your
docs. And then they're going to

30400
31:32:07.113 --> 31:32:11.113
run some fast tools like
Slither, linters and static

30401
31:32:11.113 --> 31:32:13.113
analysis. And that's going to be
one of the first things we're

30402
31:32:13.113 --> 31:32:17.113
going to talk about slither and
static analysis. So static

30403
31:32:17.113 --> 31:32:22.113
analysis is the process of just
running some program to read

30404
31:32:22.113 --> 31:32:25.113
over all your code and look for
commonly known bugs. One of the

30405
31:32:25.113 --> 31:32:28.113
most popular static analysis
tools is going to be this tool

30406
31:32:28.113 --> 31:32:31.113
called Slither. And that's going
to be one of the first things

30407
31:32:31.113 --> 31:32:34.113
we're going to do here. So let's
go ahead and open up our VS code

30408
31:32:34.113 --> 31:32:37.113
now. And we'll make a new
directory called hardhats

30409
31:32:37.113 --> 31:32:45.113
security, FCC. We'll cd into it.
We'll do code period. And we'll

30410
31:32:45.113 --> 31:32:49.113
open this up. Now what I want
you to do, instead of starting a

30411
31:32:49.113 --> 31:32:51.113
new folder, and everything is
we're going to get clone, my

30412
31:32:51.113 --> 31:32:56.113
heart had security FCC. So we'll
do git clone, our net security

30413
31:32:56.113 --> 31:33:00.113
FCC space, and then put a period
to clone it into this directory.

30414
31:33:00.113 --> 31:33:04.113
And we'll get everything like
this. Now in here, this comes

30415
31:33:04.113 --> 31:33:07.113
with a couple of different
contracts for us already, that

30416
31:33:07.113 --> 31:33:10.113
each have a different
vulnerability, one of them is

30417
31:33:10.113 --> 31:33:14.113
going to be bad RNG. This is a
contract that picks a random

30418
31:33:14.113 --> 31:33:18.113
winner of a raffle using block
difficulty and message dot

30419
31:33:18.113 --> 31:33:22.113
sender. This isn't truly random,
as the miners can influence the

30420
31:33:22.113 --> 31:33:25.113
block dot difficulty, and people
can cancel transactions. And

30421
31:33:25.113 --> 31:33:28.113
there's a ton of ton of
different vulnerabilities with

30422
31:33:28.113 --> 31:33:32.113
creating randomness in this way.
We also have this liquid pool as

30423
31:33:32.113 --> 31:33:35.113
an Oracle, the two most common
types of attacks are reentrancy,

30424
31:33:35.113 --> 31:33:39.113
which we've learned about an
Oracle manipulation attacks,

30425
31:33:39.113 --> 31:33:42.113
which luckily for you, we've
taught you about decentralized

30426
31:33:42.113 --> 31:33:44.113
Oracle's and working with chain
link, which should make you a

30427
31:33:44.113 --> 31:33:48.113
lot safer. And especially for
this section, I'm going to harp

30428
31:33:48.113 --> 31:33:51.113
on these, please, please,
please, if you taking this

30429
31:33:51.113 --> 31:33:55.113
course, please do not make a
protocol that falls victim to

30430
31:33:55.113 --> 31:33:57.113
one of these, I will feel like I
have failed you. If you build a

30431
31:33:57.113 --> 31:34:00.113
protocol where you use some
centralized oracle that gets

30432
31:34:00.113 --> 31:34:03.113
manipulated, or you build a
protocol that has a reentrancy

30433
31:34:03.113 --> 31:34:06.113
attack. The tools that I'm going
to show you right here are going

30434
31:34:06.113 --> 31:34:09.113
to help you with reentrancy. And
everything I've taught you about

30435
31:34:09.113 --> 31:34:12.113
chain link should hopefully
teach you how to not get Oracle

30436
31:34:12.113 --> 31:34:16.113
manipulated. So in this contract
here, we're using a liquidity

30437
31:34:16.113 --> 31:34:19.113
pool as an Oracle and this is
kind of some advanced defy stuff

30438
31:34:19.113 --> 31:34:23.113
here. This is a minimalistic
decentralized exchange example

30439
31:34:23.113 --> 31:34:27.113
where people can buy and sell
and swap different assets. Now

30440
31:34:27.113 --> 31:34:32.113
using this singular exchange, to
get the swap price is a terrible

30441
31:34:32.113 --> 31:34:36.113
idea. Because this is a single
protocol for a single price. The

30442
31:34:36.113 --> 31:34:39.113
price from this protocol is a
single centralized location, and

30443
31:34:39.113 --> 31:34:42.113
we don't want to get our price
from a single centralized

30444
31:34:42.113 --> 31:34:45.113
exchange. We want to get it from
many exchanges. Getting the

30445
31:34:45.113 --> 31:34:50.113
price of any asset from a single
decentralized exchange is not

30446
31:34:50.113 --> 31:34:53.113
decentralized, is somebody
manipulates the market doing

30447
31:34:53.113 --> 31:34:57.113
some crazy advanced defy things
that will ruin the price of your

30448
31:34:57.113 --> 31:35:01.113
assets. So getting the price of
your assets from a centralized

30449
31:35:01.113 --> 31:35:05.113
location is a terrible idea. We
have a metamorphic proxy here.

30450
31:35:05.113 --> 31:35:08.113
The issue here is that it's
initialized double, and we don't

30451
31:35:08.113 --> 31:35:11.113
guarantee that the contract has
been initialized. We have a

30452
31:35:11.113 --> 31:35:15.113
classic reentrancy issue here.
And then we have and then we

30453
31:35:15.113 --> 31:35:19.113
have a vault here where some
password is stored on chain and

30454
31:35:19.113 --> 31:35:22.113
we're crossing our fingers that
nobody reads this password to

30455
31:35:22.113 --> 31:35:25.113
unlock it. So we're going to run
some static analysis on these

30456
31:35:25.113 --> 31:35:29.113
contracts, see if that static
analysis can spot some of the

30457
31:35:29.113 --> 31:35:32.113
bad things in here.

30458
31:35:32.113 --> 31:35:35.113
To get started, we're going to
use a tool like I said called

30459
31:35:35.113 --> 31:35:40.113
slither slither tool was created
by this Crytek team, aka the

30460
31:35:40.113 --> 31:35:44.113
trilobites team. Now, trilobites
is one of my absolute favorite

30461
31:35:44.113 --> 31:35:47.113
auditors in the space. And I
absolutely love all the tools

30462
31:35:47.113 --> 31:35:49.113
that this team puts out, they
put up open source security

30463
31:35:49.113 --> 31:35:53.113
tools for any of us to use such
as slitter. Now to get started

30464
31:35:53.113 --> 31:35:57.113
with Slither, we actually need
to install Python first. So you

30465
31:35:57.113 --> 31:36:01.113
can also run it with Docker. But
I'm going to show you how to how

30466
31:36:01.113 --> 31:36:04.113
to work with Python first. So if
you haven't worked with Python,

30467
31:36:04.113 --> 31:36:07.113
before, you can come to
python.org/downloads and

30468
31:36:07.113 --> 31:36:09.113
download Python right from the
website, you'll know you've done

30469
31:36:09.113 --> 31:36:13.113
it right. And you can run python
three dash dash version, like

30470
31:36:13.113 --> 31:36:16.113
this. Or if you have an older
version of Python, you can run

30471
31:36:16.113 --> 31:36:19.113
Python dash dash version. Once
you install Python, you should

30472
31:36:19.113 --> 31:36:22.113
also have this tool called PIP
three installed and you can

30473
31:36:22.113 --> 31:36:27.113
check by running PIP three dash
dash version, or PIP dash dash

30474
31:36:27.113 --> 31:36:32.113
version. And we also want to
install this sock select package

30475
31:36:32.113 --> 31:36:35.113
just in case we're using weird
versions of solidity to install.

30476
31:36:35.113 --> 31:36:40.113
So select, we run PIP three,
install sock select, like that.

30477
31:36:40.113 --> 31:36:45.113
And then we can do sock, select,
use. And then we can choose the

30478
31:36:45.113 --> 31:36:49.113
version of solidity or slither
to work with. Once you have

30479
31:36:49.113 --> 31:36:52.113
those tools, you can just run
PIP three install slither

30480
31:36:52.113 --> 31:36:56.113
analyzer like so. And you can
install slither into your Python

30481
31:36:56.113 --> 31:36:58.113
environment. I'm not going to
run it because already have. You

30482
31:36:59.113 --> 31:37:01.113
can also learn how to do this
all with Docker and we'll learn

30483
31:37:01.113 --> 31:37:04.113
how to do this with Docker in a
little bit. Now in our package

30484
31:37:04.113 --> 31:37:08.113
json, we actually have command
script in our package. JSON for

30485
31:37:08.113 --> 31:37:11.113
running Slither, you'll know
you've installed slither

30486
31:37:11.113 --> 31:37:18.113
correctly. If you can run
Slither, dash dash help you get

30487
31:37:18.113 --> 31:37:21.113
an output like this. Now we can
use slither to run it on our

30488
31:37:21.113 --> 31:37:25.113
contracts folder by running this
big command here. So we'll say

30489
31:37:25.113 --> 31:37:29.113
Slither. And we want to run it
on dot slash contracts, we need

30490
31:37:29.113 --> 31:37:32.113
to tell it that it has some
psaltery mappings, and every

30491
31:37:32.113 --> 31:37:36.113
time it sees open Zeppelin, it
should use Node module slash

30492
31:37:36.113 --> 31:37:39.113
open Zeppelin and every time it
sees chain link introduced node

30493
31:37:39.113 --> 31:37:42.113
modules slash chain link. And
I'm just going to read from our

30494
31:37:42.113 --> 31:37:46.113
package json. And we're
excluding a couple of functions

30495
31:37:46.113 --> 31:37:49.113
that it runs and excluding
builder ignore, but don't worry

30496
31:37:49.113 --> 31:37:51.113
too much about that. We've
actually just run that by first

30497
31:37:51.113 --> 31:38:03.113
running yarn to install all of
our packages.

30498
31:38:03.113 --> 31:38:06.113
And after we've installed all of
our packages, we can run yarn

30499
31:38:06.113 --> 31:38:09.113
Slither. Or you can copy paste
that slither command and run it

30500
31:38:09.113 --> 31:38:14.113
directly. Now we'll get this
massive output that looks like

30501
31:38:14.113 --> 31:38:17.113
this with some red and some
green. Let's go through what's

30502
31:38:17.113 --> 31:38:20.113
actually happening here, the way
that we can read Slither, it'll

30503
31:38:20.113 --> 31:38:23.113
list out a number of lines that
have an issue and then a

30504
31:38:23.113 --> 31:38:26.113
reference to that issue. And
each one of these is separated

30505
31:38:26.113 --> 31:38:31.113
by a new line. So that's a
section that's exception, etc.

30506
31:38:31.113 --> 31:38:34.113
So if we get a red here, that
means that there is a high

30507
31:38:34.113 --> 31:38:38.113
impact issue that we definitely
should address. And it even

30508
31:38:38.113 --> 31:38:42.113
comes with a reference link that
we can copy paste and put into

30509
31:38:42.113 --> 31:38:45.113
our browser and see what the
issue is and more information

30510
31:38:45.113 --> 31:38:49.113
from the slither tool about what
that issue is and how to correct

30511
31:38:49.113 --> 31:38:54.113
it. We can see it catches our
metamorphic contract issue. It

30512
31:38:54.113 --> 31:38:57.113
says metamorphic contract is
never initialized. It is used

30513
31:38:57.113 --> 31:39:01.113
here in metamorphic dot kill.
The reason that this is a

30514
31:39:01.113 --> 31:39:05.113
massive issue, if we go to our
metamorphic contract outsole is

30515
31:39:05.113 --> 31:39:09.113
that if we deploy this contract,
somebody else could initialize

30516
31:39:09.113 --> 31:39:12.113
this code, become the owner, and
then automatically kill it

30517
31:39:12.113 --> 31:39:15.113
before we even have a chance.
This is actually something that

30518
31:39:15.113 --> 31:39:19.113
has happened in the past and has
caused a ton of issues. So if we

30519
31:39:19.113 --> 31:39:22.113
see red in the terminal, this
means Hey, massive issue, we

30520
31:39:22.113 --> 31:39:25.113
should absolutely check it out.
Now there's gonna be a ton of

30521
31:39:25.113 --> 31:39:28.113
green in here. These are
detectors that are probably low

30522
31:39:28.113 --> 31:39:32.113
impact, and they're probably
okay. And in fact, we can see,

30523
31:39:32.113 --> 31:39:35.113
it's even just calling out some
opens up on stuff here, saying,

30524
31:39:35.113 --> 31:39:38.113
Hey, we see some inline
assembly. Inline assembly is

30525
31:39:38.113 --> 31:39:41.113
kind of scary, maybe don't use
that. So you can think of green

30526
31:39:41.113 --> 31:39:44.113
as kind of a warning that
there's a low likelihood that

30527
31:39:44.113 --> 31:39:47.113
this will impact anything, but
you might want to check it out,

30528
31:39:47.113 --> 31:39:50.113
we get this different versions
of solidity used, which is just

30529
31:39:50.113 --> 31:39:52.113
saying, hey, there's a couple
different versions of solidity

30530
31:39:52.113 --> 31:39:54.113
that might be something you want
to keep in mind, maybe you

30531
31:39:54.113 --> 31:39:58.113
should use the same versions of
solidity. We have this allow old

30532
31:39:58.113 --> 31:40:00.113
versions. And this is actually
why throughout this whole

30533
31:40:00.113 --> 31:40:05.113
course, we've been using zero
point 8.7 Because zero point 8.4

30534
31:40:05.113 --> 31:40:08.113
and zero point 8.7 are
considered more stable versions

30535
31:40:08.113 --> 31:40:12.113
of solidity. So if you're using
versions outside of there, so

30536
31:40:12.113 --> 31:40:14.113
there will say hey, maybe you
want to work with a different

30537
31:40:14.113 --> 31:40:18.113
version. We have some flags in
here about maybe Hey, you should

30538
31:40:18.113 --> 31:40:21.113
make a variable constant because
it never changes which is great.

30539
31:40:21.113 --> 31:40:24.113
Uses literal with too many
digits saying hey, this Just

30540
31:40:24.113 --> 31:40:27.113
kind of hard to read, maybe you
screwed up some of the zeros,

30541
31:40:27.113 --> 31:40:31.113
loud old versions. And what's
this reentrancy in ether store

30542
31:40:31.113 --> 31:40:36.113
dot withdraw. So just by running
this slither tool, we can catch

30543
31:40:36.113 --> 31:40:39.113
a reentrancy vulnerability in
one of our contracts, which is

30544
31:40:39.113 --> 31:40:43.113
fantastic. So running the static
analysis caught at least two

30545
31:40:43.113 --> 31:40:47.113
huge vulnerabilities in our
metamorphic contract. And in our

30546
31:40:47.113 --> 31:40:50.113
reentrancy contract, it didn't
catch the issues involved at

30547
31:40:50.113 --> 31:40:55.113
sole liquidity pool, or bad RNG,
though, which is why we don't

30548
31:40:55.113 --> 31:40:57.113
only want to rely on slither
because it's not going to catch

30549
31:40:57.113 --> 31:41:02.113
everything, but it will catch a
lot of major vulnerabilities. So

30550
31:41:02.113 --> 31:41:05.113
that's how we can use Slither,
at least from a middle middle

30551
31:41:05.113 --> 31:41:08.113
stack point to get started. So
great, we just learned how to

30552
31:41:08.113 --> 31:41:11.113
work with Slither. That's one of
the first tools that are really

30553
31:41:11.113 --> 31:41:14.113
fantastic in our audit process.
And that's going to be

30554
31:41:14.113 --> 31:41:18.113
considered a fast tool for
static analysis, running tests,

30555
31:41:18.113 --> 31:41:24.113
linters, etc, are also types of
static analysis.

30556
31:41:24.113 --> 31:41:28.113
After we run a tool like that,
we enter some manual analysis

30557
31:41:28.113 --> 31:41:31.113
where we walk through the code
ourselves manually, and maybe we

30558
31:41:31.113 --> 31:41:35.113
do it in tangent with running
some slower tools, like a kitna

30559
31:41:35.113 --> 31:41:39.113
Manta Corp, and other symbolic
execution tools. Symbolic

30560
31:41:39.113 --> 31:41:43.113
Execution is where we simulate
executing transactions on the

30561
31:41:43.113 --> 31:41:46.113
blockchain. And one of these
symbolic execution tools that

30562
31:41:46.113 --> 31:41:49.113
we're going to work with is this
a kidmin tool. Again, this is a

30563
31:41:49.113 --> 31:41:52.113
trail of bits tool for doing
something called fuzz testing.

30564
31:41:52.113 --> 31:41:55.114
Now in programming, fuzzing or
fuzz testing is an automated

30565
31:41:55.114 --> 31:41:59.114
software testing technique that
involves providing invalid

30566
31:41:59.114 --> 31:42:03.114
unexpected or random data as
inputs to a computer program. In

30567
31:42:03.114 --> 31:42:06.114
a lot of our code, oftentimes,
we're going to get people

30568
31:42:06.114 --> 31:42:10.114
interacting with them in ways
that we will never think about.

30569
31:42:10.114 --> 31:42:13.114
So we want to be able to provide
random data and random

30570
31:42:13.114 --> 31:42:16.114
information to our test to see
if something weird happens that

30571
31:42:16.114 --> 31:42:20.114
we weren't expecting. So we can
actually build our own fuzz

30572
31:42:20.114 --> 31:42:24.114
tests in our hard hat projects
and run these fuzz tests, I've

30573
31:42:24.114 --> 31:42:27.114
actually created a sample of
fuzz tests, we write our fuzz

30574
31:42:27.114 --> 31:42:31.114
tests in solidity, actually, as
opposed to writing our tests in

30575
31:42:31.114 --> 31:42:34.114
JavaScript. So let's say for
example, we've built this vault

30576
31:42:34.114 --> 31:42:38.114
contract. And we think that at
first glance, hey, nobody should

30577
31:42:38.114 --> 31:42:41.114
ever be able to know the
password, and no one should ever

30578
31:42:41.114 --> 31:42:45.114
be able to unlock this contract.
Which obviously, we know is

30579
31:42:45.114 --> 31:42:48.114
ridiculous, because we know that
anybody can read anything in a

30580
31:42:48.114 --> 31:42:51.114
storage variable. So we know
that this should fail, but it

30581
31:42:51.114 --> 31:42:54.114
might be hard to write a test.
To catch that this actually

30582
31:42:54.114 --> 31:42:58.114
would fail. A good approach to
testing this would be to just

30583
31:42:58.114 --> 31:43:02.114
send a ton of random bytes 32
objects to this unlock function

30584
31:43:02.114 --> 31:43:05.114
to see if we can unlock it. We
can write a fuzz test to do

30585
31:43:05.114 --> 31:43:09.114
exactly that. So in my vault,
fuzz test dot Sol, we're

30586
31:43:09.114 --> 31:43:13.114
importing vault outsole. And so
we're saying vault fuzz test is

30587
31:43:13.114 --> 31:43:19.114
vault and we have a password of
123, ASD 123. And now we have a

30588
31:43:19.114 --> 31:43:24.114
function called a kid and a test
find password, where it's going

30589
31:43:24.114 --> 31:43:28.114
to send a ton of random data
into vault to try to make s

30590
31:43:28.114 --> 31:43:32.114
locked equal false. So we just
say s locked equals true here,

30591
31:43:32.114 --> 31:43:35.114
and our first test will try to
make s locked equals false. Now

30592
31:43:35.114 --> 31:43:38.114
we could install just the kitna,
but at this point, it's a good

30593
31:43:38.114 --> 31:43:43.114
idea to bring up our the
security toolbox from trail of

30594
31:43:43.114 --> 31:43:46.114
bits. So trail of bits has a
package called the eath security

30595
31:43:46.114 --> 31:43:50.114
toolbox, which has all their
security tools in one single

30596
31:43:50.114 --> 31:43:54.114
container kitna, Ethan o Manta
core, slither, rattle, and not

30597
31:43:54.114 --> 31:43:58.114
so smart contracts, it has all
these in the same exact package.

30598
31:43:58.114 --> 31:44:01.114
Now to work with this toolbox.
We're gonna need Docker

30599
31:44:01.114 --> 31:44:03.114
installed. So we're gonna do a
little bit of installation here.

30600
31:44:03.114 --> 31:44:06.114
And again, sometimes this can be
the hardest part of the course

30601
31:44:06.114 --> 31:44:09.114
is just installing these
packages. So we've left a link

30602
31:44:09.114 --> 31:44:13.114
to Doc's dot docker.com, get
Docker to install Docker, to

30603
31:44:13.114 --> 31:44:15.114
actually work with these tools,
you're just going to come you're

30604
31:44:15.114 --> 31:44:18.114
going to click whichever one of
these is appropriate for you to

30605
31:44:18.114 --> 31:44:21.114
install Docker, once we have
Docker installed, we can run the

30606
31:44:21.114 --> 31:44:25.114
E security toolbox by pulling it
down from the Docker equivalent

30607
31:44:25.114 --> 31:44:27.114
of GitHub. And we're going to
use a whole bunch of Docker

30608
31:44:27.114 --> 31:44:29.114
commands that I'm not going to
explain here because this isn't

30609
31:44:29.114 --> 31:44:32.114
a Docker course, if you're
looking to get into the security

30610
31:44:32.114 --> 31:44:34.114
stuff, I would definitely
recommend reading up on all

30611
31:44:34.114 --> 31:44:37.114
these commands afterwards. And
we're going to leave a ton of

30612
31:44:37.114 --> 31:44:40.114
links for you to learn more. And
in the package that JSON

30613
31:44:40.114 --> 31:44:44.114
associated with this lesson. We
even have the command to get set

30614
31:44:44.114 --> 31:44:47.114
up right in here. So we can just
run yarn toolbox, which will run

30615
31:44:47.114 --> 31:44:51.114
our Docker command like this. So
I'm just going to run yarn

30616
31:44:51.114 --> 31:44:54.114
toolbox. And if you get
something like this saying

30617
31:44:54.114 --> 31:44:57.114
cannot connect to the Docker
daemon is the Docker daemon

30618
31:44:57.114 --> 31:45:00.114
running, because I need to have
my Docker daemon running. Since

30619
31:45:00.114 --> 31:45:04.114
I installed Docker desktop. I
need to have my Docker engine

30620
31:45:04.114 --> 31:45:07.114
started and running for it to
actually be working. Again to

30621
31:45:07.114 --> 31:45:10.114
work with this. There's a lot of
Docker setup and configuration

30622
31:45:10.114 --> 31:45:13.114
that needs to happen, which I'm
going to leave a ton of

30623
31:45:13.114 --> 31:45:15.114
instructions on how to get
started with Docker. Once we

30624
31:45:15.114 --> 31:45:19.114
have Docker setup. Now we can
run yarn toolbox, which will

30625
31:45:19.114 --> 31:45:22.114
stick us into a new shell to
work with any of these tools

30626
31:45:22.114 --> 31:45:26.114
that trilobites has Out of the
box. Now our vault fuzz test

30627
31:45:26.114 --> 31:45:30.114
comes with a config as well.
This is in a Yamo file with all

30628
31:45:30.114 --> 31:45:34.114
our arguments for running a
kidnap. So it has a test limit,

30629
31:45:34.114 --> 31:45:37.114
which is how many different
runs, we should do a time delay,

30630
31:45:37.114 --> 31:45:40.114
block delay. And then of course,
some re mappings in here. This

30631
31:45:40.114 --> 31:45:43.114
darker shell will already have
the security tools already

30632
31:45:43.114 --> 31:45:50.114
installed like the Kidner test.
So we'll run a kinah test on SRC

30633
31:45:50.114 --> 31:45:58.114
slash contracts slash test slash
fuzzing slash fault fuzz test

30634
31:45:58.114 --> 31:46:05.114
dot Sol dash dash contract will
be vault fuzz test, dash dash

30635
31:46:05.114 --> 31:46:10.114
config will be SRC slash
contracts slash test slash

30636
31:46:10.114 --> 31:46:15.114
buzzing slash config dot Yamo.
And we'll go ahead and we'll hit

30637
31:46:15.114 --> 31:46:18.114
enter here, and it'll say
analyzing contract, it'll give

30638
31:46:18.114 --> 31:46:20.114
us an output like this, it will
give us an output that looks

30639
31:46:20.114 --> 31:46:24.114
like this. What it's saying is
it found a use case where it

30640
31:46:24.114 --> 31:46:29.114
could make s locked equals
false. And the use case was 123,

30641
31:46:29.114 --> 31:46:34.114
ASD 123. So when what seemed
like almost seconds, it found

30642
31:46:34.114 --> 31:46:37.114
the password to unlock our
contract. And this is why

30643
31:46:37.114 --> 31:46:41.114
running a fuzz tester can be so
powerful, we thought our

30644
31:46:41.114 --> 31:46:44.114
contract was secure, but it
immediately found the password,

30645
31:46:44.114 --> 31:46:47.114
which means anybody else could
immediately find the password.

30646
31:46:47.114 --> 31:46:49.114
And this would be an indicator
that what we're doing there is

30647
31:46:49.114 --> 31:46:53.114
not a good setup. So we'll hit
CTRL C to escape. And to leave

30648
31:46:53.114 --> 31:46:54.114
our Docker setup here,

30649
31:46:54.114 --> 31:46:58.114
we'll just write exit. Now
again, I'm going to leave a ton

30650
31:46:58.114 --> 31:47:00.114
of links to work with a
kidnapper and work with this

30651
31:47:00.114 --> 31:47:03.114
fuzz tester in the GitHub repo
associated with this lesson, so

30652
31:47:03.114 --> 31:47:09.114
that you can go ahead and learn
more. Now, if you take anything

30653
31:47:09.114 --> 31:47:13.114
away from this whole section, it
should be this right here. The

30654
31:47:13.114 --> 31:47:16.114
two most common tasks are
reentrant. See, and Oracle

30655
31:47:16.114 --> 31:47:19.114
manipulation. So if you're not
going to be an auditor, and you

30656
31:47:19.114 --> 31:47:22.114
just want to deploy things to
main net, always, always before

30657
31:47:22.114 --> 31:47:26.114
you deploy anything, the
absolute minimum that you should

30658
31:47:26.114 --> 31:47:29.114
be doing is always running
Slither. And then looking

30659
31:47:29.114 --> 31:47:33.114
manually for Oracle manipulation
and reentrancy attacks. If you

30660
31:47:33.114 --> 31:47:37.114
see in your code that you're
getting pricing information.

30661
31:47:37.114 --> 31:47:40.114
Price is a piece of data that we
as humans have assigned to

30662
31:47:40.114 --> 31:47:42.114
something if you're getting
pricing information from a

30663
31:47:42.114 --> 31:47:46.114
centralized location, rethink
that scenario, rethink what

30664
31:47:46.114 --> 31:47:49.114
you're doing there. If you're
getting a random number, if

30665
31:47:49.114 --> 31:47:51.114
you're doing any type of
automation from a centralized

30666
31:47:51.114 --> 31:47:54.114
location, rethink it and change
your strategy. The chain link

30667
31:47:54.114 --> 31:47:58.114
Oracle network has been created
for a reason to prevent getting

30668
31:47:58.114 --> 31:48:02.114
hacked like this. So please keep
these in mind before you deploy

30669
31:48:02.114 --> 31:48:05.114
anything to main that with any
type of security guarantees.

30670
31:48:05.114 --> 31:48:08.114
Okay, great. So we've learned
about the fast tools, we've

30671
31:48:08.114 --> 31:48:11.114
learned about some of the slow
tools. We didn't look into Manta

30672
31:48:11.114 --> 31:48:14.114
Corp or Mythix. But these are
also tools that you can use

30673
31:48:14.114 --> 31:48:17.114
Manta Corp is going to be
another tool from the trilobites

30674
31:48:17.114 --> 31:48:21.114
team. And Mythix is actually a
smart contract security service

30675
31:48:21.114 --> 31:48:24.114
from the consensus team, you
basically send a bot that they

30676
31:48:24.114 --> 31:48:27.114
have running in the cloud your
contracts and will do some

30677
31:48:27.114 --> 31:48:30.114
automated process to check for
security vulnerabilities. This

30678
31:48:30.114 --> 31:48:33.114
is a paid service. But if you're
going to be deploying a protocol

30679
31:48:33.114 --> 31:48:36.114
that's worth millions of
dollars, spending a few $1,000.

30680
31:48:36.114 --> 31:48:39.114
Spending a few $1,000 to make
sure it actually does. What it

30681
31:48:39.114 --> 31:48:41.114
says is going to do correctly is
definitely something that you

30682
31:48:41.114 --> 31:48:46.114
want to invest in. After you run
through this whole process. You

30683
31:48:46.114 --> 31:48:49.114
the smart contract developers
and the auditors should discuss

30684
31:48:49.114 --> 31:48:52.114
their findings. And if there's
any issues, repeat the steps,

30685
31:48:52.114 --> 31:48:56.114
repeat all the steps again after
changes are made. So this audit

30686
31:48:56.114 --> 31:48:59.114
process and making sure your
contracts are secure is a long

30687
31:48:59.114 --> 31:49:02.114
process. And then afterwards, an
auditor will finally write your

30688
31:49:02.114 --> 31:49:05.114
report with all security
vulnerabilities and everything

30689
31:49:05.114 --> 31:49:08.114
that they found in your
contracts. Typically, you'll

30690
31:49:08.114 --> 31:49:11.114
organize reports in a chart
that'll look something like

30691
31:49:11.114 --> 31:49:14.114
this, you'll label issues that
have a high chance of happening

30692
31:49:14.114 --> 31:49:17.114
and have a high impact as
critical things that have a high

30693
31:49:17.114 --> 31:49:22.114
impact, but a low likelihood as
medium, and etc. I'm also going

30694
31:49:22.114 --> 31:49:25.114
to leave some examples two
audits that have been done in

30695
31:49:25.114 --> 31:49:28.114
the past so that you can take a
look at them. And you can see

30696
31:49:28.114 --> 31:49:31.114
what a full audit looks like on
certain code. We'll be looking

30697
31:49:31.114 --> 31:49:34.114
at openzeppelin sigma prime, and
trilobites, because these are

30698
31:49:34.114 --> 31:49:37.114
three of what I think are some
of the best auditors in the

30699
31:49:37.114 --> 31:49:40.114
space. Now in the GitHub repo.
We also have a ton of other

30700
31:49:40.114 --> 31:49:44.114
tools that you can use Mythix,
mithril ethers play and

30701
31:49:44.114 --> 31:49:47.114
consensus security tools. If you
want to learn more about

30702
31:49:47.114 --> 31:49:51.114
security and auditing, I highly
recommend that after this course

30703
31:49:51.114 --> 31:49:54.114
you play the Ethernet game and
damn vulnerable Defy. These are

30704
31:49:54.114 --> 31:49:57.114
two games that will teach you a
ton about security. And we'll

30705
31:49:57.114 --> 31:50:00.114
test the chops and we'll test
everything that you've learned

30706
31:50:00.114 --> 31:50:03.114
in this course. There's also a
couple of security focused blogs

30707
31:50:03.114 --> 31:50:06.114
that I really like. One of them
in particular is wrecked dot

30708
31:50:06.114 --> 31:50:10.114
news. They keep a running list
of some of the largest hacks

30709
31:50:10.114 --> 31:50:14.114
that have ever happened in the
space and then retrospectives on

30710
31:50:14.114 --> 31:50:16.114
why those actually happened. And
they usually make it very

30711
31:50:16.114 --> 31:50:20.114
entertaining as well. We have
some articles in here as well.

30712
31:50:20.114 --> 31:50:23.114
One of the best places to look
at is this known attacks section

30713
31:50:23.114 --> 31:50:26.114
where they talk Talk about
reentrancy, Oracle manipulation,

30714
31:50:26.114 --> 31:50:30.114
front running and a ton of other
attacks that you should

30715
31:50:30.114 --> 31:50:32.114
absolutely be aware of when
writing your smart contracts,

30716
31:50:32.114 --> 31:50:35.114
we're not going to go over them
here because they do a great job

30717
31:50:35.114 --> 31:50:38.114
in these resources explaining
them, you should also check out

30718
31:50:38.114 --> 31:50:41.114
this article because I helped
write it. So definitely check

30719
31:50:41.114 --> 31:50:44.114
that out. And then we've got a
list to even more sections. So

30720
31:50:44.114 --> 31:50:48.114
this is going to be a living
section here. So please feel

30721
31:50:48.114 --> 31:50:50.114
free. If you find more things in
the future, please feel free to

30722
31:50:50.114 --> 31:50:54.114
make pull requests and update
this repository so that other

30723
31:50:54.114 --> 31:50:57.114
people can learn and know more
about security and auditing and

30724
31:50:57.114 --> 31:51:01.114
have contract examples on what
bad code looks like and how to

30725
31:51:01.114 --> 31:51:03.114
actually catch them. Even though
this was one of our quickest

30726
31:51:03.114 --> 31:51:06.114
sections. From a video
standpoint, this actually is

30727
31:51:06.114 --> 31:51:10.114
going to be one of the longest
sections of your career.

30728
31:51:10.114 --> 31:51:13.114
Security is something that is
always going to be on your mind.

30729
31:51:13.114 --> 31:51:16.114
And there's always going to be
new tools to help with security.

30730
31:51:16.114 --> 31:51:18.114
And there's always going to be
new things to think about. So

30731
31:51:18.114 --> 31:51:22.114
even though we went through this
very quickly, I would 100% want

30732
31:51:22.114 --> 31:51:25.114
you to pause this video, and
work with and try out some of

30733
31:51:25.114 --> 31:51:28.114
the tools we tried here. And
then maybe even try coming up

30734
31:51:28.114 --> 31:51:33.114
with your own vulnerabilities as
well. And with that being said,

30735
31:51:33.114 --> 31:51:38.114
you have just finished the last
section of this massive master

30736
31:51:38.114 --> 31:51:42.114
course on learning smart
contracts, solidity, web three

30737
31:51:42.114 --> 31:51:44.114
and blockchain development,

30738
31:51:44.114 --> 31:52:07.114
you should be incredibly proud
of yourself. Congratulations, I

30739
31:52:07.114 --> 31:52:11.114
and the web three community as a
whole want to congratulate you

30740
31:52:11.114 --> 31:52:16.114
for completing this absolutely
monstrosity of a tutorial, you

30741
31:52:16.114 --> 31:52:21.114
have done an amazing job to get
this far. And to watch me

30742
31:52:21.114 --> 31:52:24.114
talking to you right now. And if
you haven't finished the course,

30743
31:52:24.114 --> 31:52:28.114
go back and finish it before
coming here. We have learned so

30744
31:52:28.114 --> 31:52:33.114
much on this journey. And I can
say from the bottom of my soul

30745
31:52:33.114 --> 31:52:36.114
that I am so glad to have you in
the web three space, smart

30746
31:52:36.114 --> 31:52:40.114
contract space, the blockchain
space, the cryptocurrency space,

30747
31:52:40.114 --> 31:52:44.114
we are so excited that you're
here. I'm really looking forward

30748
31:52:44.114 --> 31:52:48.114
to seeing you in the web three
in the blockchain community. Now

30749
31:52:48.114 --> 31:52:52.114
a lot of people ask, Well, where
do I go? Now, I didn't have all

30750
31:52:52.114 --> 31:52:55.114
this newfound knowledge. I'm
armed with the intelligence of

30751
31:52:55.114 --> 31:52:59.114
the web three developer space.
Well, I've left some links in

30752
31:52:59.114 --> 31:53:03.114
the GitHub repository to lead
you to those next steps. But the

30753
31:53:03.114 --> 31:53:06.114
biggest thing that you can do
for yourself right now is go

30754
31:53:06.114 --> 31:53:10.114
take what you've learned, and
apply it somewhere. This is

30755
31:53:10.114 --> 31:53:14.114
going to be probably the most
thorough course you will ever go

30756
31:53:14.114 --> 31:53:17.114
through in this space. And you
can go tutorial to tutorial and

30757
31:53:17.114 --> 31:53:21.114
boot camp to bootcamp all you
want. But at some point, you

30758
31:53:21.114 --> 31:53:25.114
have to make that leap, and you
have to dive in. And that's

30759
31:53:25.114 --> 31:53:28.114
where the majority of the growth
is going to be anyways. So if

30760
31:53:28.114 --> 31:53:32.114
you're here, wondering where to
go next, go join a hackathon. Go

30761
31:53:32.114 --> 31:53:36.114
start jumping into issues on
GitHub repos, go start applying

30762
31:53:36.114 --> 31:53:40.114
for grants, go start applying
for jobs and say, I took

30763
31:53:40.114 --> 31:53:43.114
Patrick's massive course. Here's
my GitHub repo, work on a

30764
31:53:43.114 --> 31:53:47.114
personal project, work on
somebody else's project. Take

30765
31:53:47.114 --> 31:53:50.114
this knowledge and apply it, the
challenges that you'll run into

30766
31:53:50.114 --> 31:53:53.114
and the challenges that you'll
face. Really trying to do

30767
31:53:53.114 --> 31:53:56.114
something without me hand
holding you is where you're

30768
31:53:56.114 --> 31:54:00.114
going to learn 10 times as much
as what you've learned here.

30769
31:54:00.114 --> 31:54:03.114
I've walked through as deep down
this rabbit hole as I can take

30770
31:54:03.114 --> 31:54:08.114
you. Now it's up to you to go
out and do something with it. So

30771
31:54:08.114 --> 31:54:11.114
thank you, everybody who helped
me create this course. Thank you

30772
31:54:11.114 --> 31:54:15.114
for taking this course. And I'm
so excited to see you in the

30773
31:54:15.114 --> 31:54:20.114
community and see what you build
and see what we can create with

30774
31:54:20.114 --> 31:54:20.114
this technology.
