1
00:00:00.000 --> 00:00:03.284
如果你对区块链感兴趣，这门课很适合你。

2
00:00:03.284 --> 00:00:08.948
帕特里克·柯林斯是一位资深的软件工程师和长期的金融行业开发人员。

3
00:00:08.948 --> 00:00:12.089
一定要留下你从这门课中学到的东西的评论。

4
00:00:12.128 --> 00:00:20.469
欢迎来到终极可靠的智能合约和区块链开发人员课程，除了JavaScript，我们最近用Python

5
00:00:20.469 --> 00:00:28.984
做了这个视频的一个版本，现在有超过200万的点击量，使它成为这个星球上观看人数最多的智能合约教程。

6
00:00:28.984 --> 00:00:31.623
我们从第一门课中学到了很多东西。

7
00:00:31.623 --> 00:00:35.263
如果你喜欢Python语言，一定要看看那本。

8
00:00:35.263 --> 00:00:41.114
我们总结了从制作第一门课程中学到的所有知识，并将其整合到这个JavaScript视频中。

9
00:00:41.114 --> 00:00:48.721
如果你想开始学习web3区块链智能合约或任何这些术语，这门课程很适合你。

10
00:00:48.721 --> 00:00:54.560
它适合所有人，无论你在编程或区块链方面的经验水平如何。

11
00:00:54.560 --> 00:00:58.520
理想情况下，你知道，在开始之前，有一点JavaScript。

12
00:00:58.520 --> 00:01:01.465
但如果你没有，不用担心，我们会一路帮助你。

13
00:01:01.465 --> 00:01:05.823
如果你真的想在开始之前学习一点JavaScript, Free

14
00:01:05.823 --> 00:01:10.886
Code Camp上有一些很棒的课程可以让你学习更多，但你绝对不需要。

15
00:01:10.886 --> 00:01:15.401
实际上，任何有面向对象编程语言经验的人都可以。

16
00:01:15.401 --> 00:01:21.998
如果你是编码新手，或者你是区块链新手，这就是你应该做的。

17
00:01:21.998 --> 00:01:29.809
如果您已经对区块链或编码有了很多了解，本课程将为您提供更深入的基础知识。

18
00:01:29.891 --> 00:01:31.899
欢迎来到兔子洞的边缘。

19
00:01:32.928 --> 00:01:35.238
谁不知道，我叫帕特里克·柯林斯。

20
00:01:35.953 --> 00:01:39.551
合同工程师，开发人员提倡链连接协议。

21
00:01:39.551 --> 00:01:42.108
我生活在智能合约时代。

22
00:01:42.108 --> 00:01:46.481
我还在自己的频道上制作YouTube视频，在Twitter上发布中型帖子等等。

23
00:01:46.481 --> 00:01:50.805
教授人们关于智能合约、编码和这项新技术的知识。

24
00:01:50.805 --> 00:01:54.945
我喜欢帮助开发人员学习，成长和了解这个新的降临。

25
00:01:54.945 --> 00:01:56.892
这就是区块链和智能合约。

26
00:01:56.892 --> 00:02:03.981
我将带您踏上成为区块链专家和智能合约开发领域的向导的旅程。

27
00:02:03.981 --> 00:02:09.713
即使你不想成为一名开发人员，第一部分我们的区块链基础知

28
00:02:09.713 --> 00:02:15.445
识，会给你很多关于区块链和智能合约如何工作的基本知识。

29
00:02:15.445 --> 00:02:17.742
你能来我太激动了。

30
00:02:17.742 --> 00:02:19.587
我希望你们享受这段旅程。

31
00:02:19.587 --> 00:02:25.090
这是一个数据转储，是我在这个领域学到的所有东西的激情教育项目。

32
00:02:25.090 --> 00:02:32.466
我100%肯定，如果你跟着做，你会走到另一边，武装知识，成为

33
00:02:32.466 --> 00:02:39.842
这个不可思议的行业的积极力量，稳定和智能合约开发人员是大量的

34
00:02:39.842 --> 00:02:47.466
需求，平均年薪约14.5万美元，学习这门课程有巨大的经济机会。

35
00:02:47.466 --> 00:02:56.340
这项技术有能力彻底改变我们接触的一切，你可以成为引领这个新时代的先驱者之一。

36
00:02:56.340 --> 00:02:57.324
在我们的课程中。

37
00:02:57.324 --> 00:03:05.496
我们已经为人们提供了这些教育需求，并将他们送入区块链和智能合约领域的职业生涯。

38
00:03:05.496 --> 00:03:10.873
我们将为您提供所有的尖端工具以及如何使用它们，包括使用像D

39
00:03:10.873 --> 00:03:17.178
phi NF TS Dows、ERC 20可升级、智能合约等东西。

40
00:03:17.178 --> 00:03:24.097
我们将教你们必要的技能，来构建像Ave合成和复合这样的应用程序，数十亿美元的分散应用

41
00:03:24.097 --> 00:03:31.017
程序，或者像crypto punks或board apes这样巨大成功的非ft项目。

42
00:03:31.017 --> 00:03:38.023
陶氏就像制造商陶氏或开发商，陶氏和你在加密货币世界中看到的任何令人惊奇的东西。

43
00:03:38.023 --> 00:03:42.894
通过学习这些技能，你将拥有所有这些唾手可得的经济

44
00:03:42.894 --> 00:03:47.968
机会，并有能力成为彻底改变我们相互交往方式的先锋。

45
00:03:47.968 --> 00:03:49.138
从根本上讲。

46
00:03:49.138 --> 00:03:57.024
构建去中心化的智能合约应用程序正在构建一个更负责任的世界一个承诺牢不可破的世界，一个

47
00:03:57.024 --> 00:04:04.910
更快、更高效、财务自由的世界，一个协作的社区，将哲学和技术的威力结合到一个新系统中。

48
00:04:04.910 --> 00:04:13.866
我们将在本课程的第一课中更多地了解智能合约和去中心化应用的目的和价值，以及为什么它们如此令人兴奋。

49
00:04:13.866 --> 00:04:14.823
完成本课程。

50
00:04:14.823 --> 00:04:15.858
你就会准备好。

51
00:04:15.858 --> 00:04:22.974
所以，我想再次向你们表示衷心的感谢和崇高的敬意，因为你们迈出了进入这个领域的第一步。

52
00:04:22.974 --> 00:04:24.464
欢迎来到Web 3。

53
00:04:24.464 --> 00:04:25.505
欢迎来到区块链。

54
00:04:25.505 --> 00:04:26.709
欢迎来到智能合约。

55
00:04:26.709 --> 00:04:29.170
我们在兔子洞的尽头见。

56
00:04:29.269 --> 00:04:34.687
让我们来看看这门课的一些最佳实践，这样你

57
00:04:34.687 --> 00:04:40.105
就能最有效地学习，并尽可能地学习这门课。

58
00:04:40.280 --> 00:04:41.724
您不希望跳过此部分。

59
00:04:41.724 --> 00:04:43.643
它能帮你解决80%的问题。

60
00:04:43.643 --> 00:04:50.890
现在，在学习这门课程的过程中，百分百确定要跟随与这门课程相关的GitHub知识

61
00:04:50.890 --> 00:04:57.394
库，我们在视频描述中有一个链接，你可以完全点击跟随，并在选项卡中打开，

62
00:04:57.394 --> 00:05:05.757
因为它有Sam查询的所有代码，时间戳，可以与之互动的社区等等，它将是你观看这门课程的圣经。

63
00:05:05.757 --> 00:05:07.473
是的，我们有一个讨论标签。

64
00:05:07.473 --> 00:05:14.602
“讨论”标签是一个你可以提问的地方，与其他正在学习这门课程的开发人员进行交流。

65
00:05:14.602 --> 00:05:16.162
寻求帮助，等等。

66
00:05:16.162 --> 00:05:20.269
一定要和别人打个招呼，认识和你有相同想法的人。

67
00:05:20.319 --> 00:05:22.286
现在，区块链和智能合约运行得非常快。

68
00:05:22.322 --> 00:05:24.181
事物在不断更新。

69
00:05:25.325 --> 00:05:31.658
总是更新最新的，当我打开一些文档时，试着为你自己也打开文档。

70
00:05:31.658 --> 00:05:33.911
甚至可能把代码示例放在你旁边。

71
00:05:33.911 --> 00:05:39.507
当你写代码的时候，一定要回顾以确保你跟上进度，然后你有最新

72
00:05:39.507 --> 00:05:45.296
的样本，有时技术可能会改变，可能会有更好的方法来做一些事情。

73
00:05:45.296 --> 00:05:49.911
我们有一个文件叫时间更新，确保这是你遇到问题时第一个检查

74
00:05:49.911 --> 00:05:54.692
的地方看看是否有你错过的东西被更新了，它会按时间顺序排列。

75
00:05:54.692 --> 00:05:56.193
所以更容易找到更新。

76
00:05:56.193 --> 00:05:59.633
基本上，这就是说，总是首先参考GitHub回购。

77
00:05:59.633 --> 00:06:06.433
如果你发现了一个错误，或者有些事情没有按照你预期的方式进行，加入对话，结束讨论，

78
00:06:06.433 --> 00:06:12.893
留下一个问题，在这里提问，休息一下，我无法告诉你有多少人在一种情况下匆忙读完

79
00:06:12.893 --> 00:06:19.695
们的第一节课却没有记住那么多的信息，如果你休息一下，你的大脑记住的信息会更好。

80
00:06:19.695 --> 00:06:23.104
所以每25分钟或半小时，也许走5分钟。

81
00:06:23.104 --> 00:06:25.565
然后每两个小时休息一次。

82
00:06:25.565 --> 00:06:32.357
如果你真的想确保有什么东西深入学习了，在继续下一课之前，试着回顾并反思你在上一课上做了什么。

83
00:06:32.392 --> 00:06:35.928
但与此同时，要以自己的速度学习。

84
00:06:36.396 --> 00:06:39.194
这条航线没有合适的速度。

85
00:06:41.400 --> 00:06:44.485
一周，一个月，甚至一年，都无所谓。

86
00:06:45.404 --> 00:06:52.134
适合你的速度，你可以用YouTube视频里的小齿轮图标来改变速度。

87
00:06:52.134 --> 00:06:55.160
如果我说得太快了，你可以让我说慢一点。

88
00:06:55.160 --> 00:07:01.307
与此同时，如果我说得太慢了，你可以加快我的语速，你甚至不需要按顺序讲。

89
00:07:01.307 --> 00:07:06.443
你可以从一个话题跳到另一个话题，如果你不想学习全栈，你可以跳过全栈的东西。

90
00:07:06.443 --> 00:07:09.142
如果你不想学编码，我们可以跳过编码的部分。

91
00:07:09.142 --> 00:07:12.631
如果你只想去高级课程，那就去高级课程。

92
00:07:12.631 --> 00:07:16.152
我们非常鼓励你们停下来，回来问问题。

93
00:07:16.152 --> 00:07:19.264
区块链和智能合约世界是不可思议的协作。

94
00:07:19.264 --> 00:07:24.483
所以一定要使用像我们的GitHub知识库的讨论标签这样的工具，在Stack

95
00:07:24.483 --> 00:07:32.664
Overflow和Aetherium Stack Exchange上提问，并标记相关技术，在不同的GitHub知识库

96
00:07:32.664 --> 00:07:39.858
的GitHub知识库上提出问题，你正在工作，进入不和，Reddit, Twitter和任何其他这些社区和技术聚集的地方。

97
00:07:39.858 --> 00:07:47.677
我如此强调这些社区方面的原因是，成为一个稳定的区块链工程师不仅仅是稳定的部分。

98
00:07:47.677 --> 00:07:52.124
熟练使用这个领域的所有工具，包括获取帮助和

99
00:07:52.124 --> 00:07:56.784
提供帮助的工具，是在这里获得成功的必要条件。

100
00:07:56.784 --> 00:07:59.545
网络是庞大的，它让它充满了乐趣。

101
00:07:59.545 --> 00:08:04.150
当你继续你的旅程，你会变得更高级，你会寻找遇见其他开发者的地方。

102
00:08:04.150 --> 00:08:08.682
Hackathons是与其他工程师联系的最佳场所之一，chainlink Hackathons

103
00:08:08.682 --> 00:08:14.759
eath、global Hackathons和Dev folio Hackathons是三个很棒的Hackathons套件。

104
00:08:14.759 --> 00:08:19.447
无论你处在人生的哪个阶段，它们都是你学习的好地方。

105
00:08:19.499 --> 00:08:22.882
好了，以上就是这门课的一些最佳实践。

106
00:08:22.882 --> 00:08:31.187
你正站在兔子洞的边缘，往下看，凝视着web 3、智能合约和区块链的世界。

107
00:08:31.187 --> 00:08:34.693
如果你像我一样想要投入其中，你想要继续前进。

108
00:08:34.693 --> 00:08:38.350
让我们开始进入智能合约世界的旅程。

109
00:08:38.350 --> 00:08:43.093
这一切都从区块链的基础开始。

110
00:08:43.523 --> 00:08:45.185
我知道你很兴奋要开始编程了。

111
00:08:45.185 --> 00:08:50.475
但在我们开始之前，我们想学习一些区块链和智能合约的基础知识。

112
00:08:50.530 --> 00:08:55.894
理解这些意识形态和这些基础是如此重要，因为它将决定如何构

113
00:08:55.894 --> 00:09:01.450
建去中心化应用程序，学习区块链和坚实性的基础是至关重要的。

114
00:09:01.450 --> 00:09:07.796
但如果你已经知道区块链的基本知识，请随意跳到第二课。

115
00:09:08.547 --> 00:09:11.407
既然你来了，你可能听说过比特币。

116
00:09:11.407 --> 00:09:17.047
比特币是第一个使用称为区块链的革命性技术的协议之一。

117
00:09:17.047 --> 00:09:24.834
比特币白皮书由伪匿名的中本聪(Satoshi Nakamoto)撰写，概述了比特币如何进行点对点交易。

118
00:09:24.834 --> 00:09:26.208
在去中心化的网络中。

119
00:09:26.208 --> 00:09:32.455
这个网络由密码学，像样的日食提供动力，允许人们以去中心化的

120
00:09:32.455 --> 00:09:38.702
方式从事抵制审查的金融，这是由于它的特点，我们稍后会讲到。

121
00:09:38.702 --> 00:09:45.113
人们认为它是一种更高级的数字价值储存方式，比黄金之类的价值储存方

122
00:09:45.113 --> 00:09:51.525
式更好，这就是为什么你会听到人们通常把它称为类似黄金的数字黄金。

123
00:09:51.590 --> 00:09:57.138
在这个星球上，比特币的数量是稀缺的，或者说数量是固定的，只有你可以买卖的数量。

124
00:09:57.138 --> 00:10:04.416
你可以在白皮书中阅读更多关于最初愿景的内容，我们已经在与本课程相关的GitHub回购中链接到白皮书。

125
00:10:04.416 --> 00:10:11.137
现在，这是一个疯狂的突破，我们将学习这一切是如何实现的以及它是如何工作的。

126
00:10:11.137 --> 00:10:18.375
不过，有些人看到了这项技术，想把它做得更远一点，用这个区块链技术做更多的事情。

127
00:10:18.375 --> 00:10:22.456
几年后，一个名叫Vitalik Buterin的人，

128
00:10:22.456 --> 00:10:30.306
发布了一份名为Aetherium的新协议白皮书，该协议使用相同的区块链基础设施，但有一个额外的功能。

129
00:10:30.306 --> 00:10:36.267
2015年，他和其他一些联合创始人发布了Aetherium项目，在这

130
00:10:36.267 --> 00:10:42.228
个项目中，人们不仅可以进行去中心化的交易，还可以进行去中心化的协议，

131
00:10:42.228 --> 00:10:48.542
去中心化的组织，以及所有这些没有中央中介或中央治理力量的相互作用的方式。

132
00:10:48.542 --> 00:10:53.052
基本上，他们的想法是把这个让比特币如此伟

133
00:10:53.052 --> 00:10:57.562
大的东西，添加去中心化协议，或智能合约。

134
00:10:57.562 --> 00:11:01.338
事实上，从技术上讲，这些智能合约并不是什么新想法。

135
00:11:01.338 --> 00:11:08.982
早在1994年，一个叫尼克·扎博的人就提出了智能合约是一组指

136
00:11:08.982 --> 00:11:16.882
令以去中心化的自治方式执行，不需要第三方或中央机构来运行它们。

137
00:11:16.882 --> 00:11:21.680
它们在这些区块链或智能合约平台上诞生，比如Aetherium。

138
00:11:21.680 --> 00:11:26.923
智能合约将是我们这门课的核心内容，也是我们要发展的内

139
00:11:26.923 --> 00:11:32.167
容，你可以像看待传统合约或传统协议一样看待智能合约。

140
00:11:32.167 --> 00:11:34.854
它们只是双方之间的一套指令，

141
00:11:34.854 --> 00:11:43.491
只是它们不是写在纸上或用微软Word打印出来的，而是用代码写在这些去中心化的区块链平台上。

142
00:11:43.491 --> 00:11:45.592
这也是他们被处决的地方。

143
00:11:45.592 --> 00:11:50.280
而不是由两方，或三方，或任何涉及的多方来执行。

144
00:11:50.280 --> 00:11:54.692
这消除了中心化的问题，我们稍后会详细讨论这个问题。

145
00:11:54.692 --> 00:11:59.677
这是以太协议和比特币协议的主要区别之一。

146
00:11:59.677 --> 00:12:01.298
就是这些智能合约。

147
00:12:01.298 --> 00:12:06.118
从技术上讲，比特币确实有智能合约，但它们是图灵不完

148
00:12:06.118 --> 00:12:10.939
全的，这意味着它们没有编程语言赋予它们的所有功能。

149
00:12:10.939 --> 00:12:13.625
这是比特币开发者有意为之。

150
00:12:13.732 --> 00:12:19.463
比特币开发者将比特币视为与Aetherium相比的价值储存工具，

151
00:12:19.463 --> 00:12:26.270
而Aetherium则既是一种价值储存工具，也是促进这些去中心化协议的工具。

152
00:12:26.270 --> 00:12:30.112
现在，单是区块链上的智能合约就绝对令人难以置信。

153
00:12:30.112 --> 00:12:32.267
然而，它们也带来了一个巨大的问题。

154
00:12:32.267 --> 00:12:39.033
如果我们想让这些数字协议取代我们日常生活中的协议，它们可能需要来自现实世界区块链本身的

155
00:12:39.033 --> 00:12:45.800
数据，这些数据实际上无法与现实世界的数据进行交互，也无法读取或收听来自现实世界的数据。

156
00:12:45.800 --> 00:12:48.141
这就是所谓的甲骨文问题。

157
00:12:48.141 --> 00:12:51.933
这些区块链是确定的系统，它们是故意确定的。

158
00:12:51.933 --> 00:12:55.070
我们将在接下来的课程中更多地了解这是如何运作的。

159
00:12:55.070 --> 00:12:58.376
所以发生在他们身上的一切都发生在他们的小世界里。

160
00:12:58.376 --> 00:13:02.798
但如果要达成这些协议，就需要外部数据和外部计算。

161
00:13:02.798 --> 00:13:05.085
这就是甲骨文发挥作用的地方。

162
00:13:05.085 --> 00:13:10.772
Oracle的是任何向这些分散的区块链发送数据或运行外部计算的设备。

163
00:13:10.772 --> 00:13:16.657
然而，如果我们想让我们的应用程序保持真正的去中心化，我们就不能只

164
00:13:16.657 --> 00:13:22.542
使用一个Oracle、一个数据提供商或一个源来运行这些外部计算。

165
00:13:22.542 --> 00:13:25.095
所以我们需要一个去中心化的Oracle网络。

166
00:13:25.095 --> 00:13:30.767
类似于我们去中心化的区块链网络，你在链上的逻辑将是去中心化的，但

167
00:13:30.767 --> 00:13:36.439
你也需要你的链外数据和计算是去中心化的，结合链上的去中心化逻辑。

168
00:13:36.439 --> 00:13:43.340
有了这种下链，去中心化数据和去中心化计算产生了所谓的混合智能合约。

169
00:13:43.340 --> 00:13:51.692
我们现在使用的大多数最大的协议都是某种类型的混合智能合约或与混合智能合约交互。

170
00:13:51.692 --> 00:13:55.342
在某种程度上，这就是协议链接发挥作用的地方。

171
00:13:55.342 --> 00:14:02.467
它是一个模块化、去中心化的Oracle网络，可以将外部数据和外部计算引入我

172
00:14:02.467 --> 00:14:09.786
们的智能合约，以确保它们是端到端去中心化的，同时赋予它们协议所需的丰富特性。

173
00:14:09.848 --> 00:14:17.307
Chainlink允许我们获取数据进行维护，获取随机数或以任何有意义的方式定制我们的智能合约。

174
00:14:17.307 --> 00:14:20.794
在整个课程中，我们会用到智能合约这个术语。

175
00:14:20.794 --> 00:14:27.971
然而，每当我们说到智能合约时，我们通常会把它和混合智能合约互换使用，但要

176
00:14:27.971 --> 00:14:35.349
知道，当我们说到混合智能合约时，我们具体指的是具有某种链外组件的智能合约。

177
00:14:35.349 --> 00:14:44.148
现在，自从这些定理发布以来，许多不同的区块链或智能合约平台已经出现，如雪崩多边形、幻影和谐等。

178
00:14:44.148 --> 00:14:49.721
在本课程的大部分时间里，我们将假设我们将部署到以太坊网络。

179
00:14:49.721 --> 00:14:57.982
然而，我们在这里学到的一切都将适用于绝大多数的区块链，如多边形、雪崩、幻影和谐等，

180
00:14:57.982 --> 00:15:06.243
从理论和融资心理了解一切将给你所需的技能，你需要非常轻松地切换链，只需要一行代码。

181
00:15:06.243 --> 00:15:12.847
所以不要担心学习一种特定的工具或特定的链，因为它们大多数都可以无缝地结合在一起。

182
00:15:12.911 --> 00:15:16.477
现在，有几个智能合约平台不使用稳固性。

183
00:15:16.477 --> 00:15:20.602
但在这里学习基础知识也会让你在这些方面做得更好。

184
00:15:20.602 --> 00:15:26.082
到目前为止，以太坊拥有最多的锁定价值，是使用最多的区块链和智能合约平台。

185
00:15:26.082 --> 00:15:29.870
你也会听到这两个词交替使用。

186
00:15:29.928 --> 00:15:34.880
有时他们会说智能合约平台，有时他们会说区块链，意思差不多。

187
00:15:34.933 --> 00:15:40.495
显然，区块链可能意味着价值存储和智能合约平台，但你明白我的意思。

188
00:15:40.495 --> 00:15:47.237
同样，chainlink是最流行和最强大的去中心化Oracle网络，也是我们这门课的重点。

189
00:15:47.237 --> 00:15:50.002
Chainlink也是区块链不可知论者。

190
00:15:50.002 --> 00:15:55.779
所以在Aetherium, avalanche, Polygon Solana Terra或其他区块链上工作。

191
00:15:55.779 --> 00:16:03.673
在整个课程中，你会听到DAP或去中心化协议，或智能合约协议，或去中心化应用。

192
00:16:03.673 --> 00:16:06.001
它们的意思差不多是一样的。

193
00:16:06.001 --> 00:16:09.425
去中心化的应用程序通常是许多智能合约的组合。

194
00:16:09.425 --> 00:16:14.056
当我们讲到坚固性的时候，你会看到一个单一的智能合约是什么样子的。

195
00:16:14.056 --> 00:16:18.649
就像我说的，学习所有这些核心基础知识将使你成为一个更好的稳定性和更

196
00:16:18.649 --> 00:16:23.382
好的智能合约开发人员，在这个视频中你也会经常听到web 3这个术语。

197
00:16:23.382 --> 00:16:24.773
在这个行业中，

198
00:16:24.773 --> 00:16:35.702
web三是指区块链和智能合约是web的下一个迭代web一是指静态内容的无许可开源世界，web二是指动态内容的有

199
00:16:35.702 --> 00:16:42.261
态内容的无许可开源世界，web二是指动态内容的有许可的web，但所有的协议和逻辑都来自于控制你的信息的中央服务器。

200
00:16:42.261 --> 00:16:45.280
然后web 3又回到了无许可的web。

201
00:16:45.280 --> 00:16:51.470
但再一次，使用动态内容，而不是集中的服务器，运行你的逻辑，去中

202
00:16:51.470 --> 00:16:57.660
心化的网络，运行逻辑创建这些抵制审查的协议，这是智能合约所支持

203
00:16:57.660 --> 00:17:04.052
的通常也伴随着用户拥有他们使用的协议的想法，这是一种所有权经济。

204
00:17:04.102 --> 00:17:05.467
在这门课后面你会明白我的意思。

205
00:17:06.102 --> 00:17:12.051
很多关于这些协议和智能合约的历史和高水平，以及它们可以做什么。

206
00:17:12.103 --> 00:17:18.782
但这些智能合约到底意味着什么?我说的信任、最小化协议或牢不可破的承诺是什么?

207
00:17:18.782 --> 00:17:25.461
这些智能合约的真正增值是什么?在我们深入了解它之前，先来看看它是如何工作的。

208
00:17:25.461 --> 00:17:27.461
从技术角度来看。

209
00:17:27.461 --> 00:17:30.104
我们来看看这些的值是多少。

210
00:17:30.104 --> 00:17:35.074
我们开发所有这些技术的目的是什么?你修过这门课吗?这项技术解

211
00:17:35.074 --> 00:17:40.044
决了什么问题?在我看来，一项技术的好坏取决于它所解决的问题。

212
00:17:40.044 --> 00:17:46.192
如果它不能解决问题，那为什么还要去麻烦Mark合约，区块链web三种加密货

213
00:17:46.192 --> 00:17:52.507
币，这些都是不同的词，它们封装了我们在这样一个独特的范式中所做的事情的想法。

214
00:17:52.507 --> 00:17:58.794
我认为最简单的方法来总结这些智能合约的作用是，它们创建了信任最小化协议。

215
00:17:58.794 --> 00:18:01.202
如果你可能会挠头的话。

216
00:18:01.202 --> 00:18:06.650
一个简单得多的思考方式是，产生牢不可破的承诺。

217
00:18:06.650 --> 00:18:08.412
是的，你没听错。

218
00:18:08.412 --> 00:18:10.679
牢不可破的协议和承诺。

219
00:18:10.679 --> 00:18:16.076
此外，它们还提高了速度、效率和透明度，以及其他一些东西。

220
00:18:16.076 --> 00:18:19.339
我最近做了一个视频就是关于这个的。

221
00:18:19.339 --> 00:18:26.043
让我们来听听智能合约加密货币不可否认的价值的

222
00:18:26.043 --> 00:18:33.053
目的，从根本上重新定义我们所知道的市场和协议。

223
00:18:33.111 --> 00:18:37.268
不幸的是，你可能只听到过人们对空瓶子和钱的尖叫。

224
00:18:37.268 --> 00:18:42.094
现在，有些表情包是有趣的，但让我们忘记子弹，回到空间的本质。

225
00:18:42.094 --> 00:18:43.619
如果你已经在web 3了。

226
00:18:43.619 --> 00:18:49.620
这段视频可以发给你的朋友，解释你为什么对这个空间如此兴奋，解释我们为什么在这里。

227
00:18:49.620 --> 00:18:53.061
如果你不喜欢加密货币，那你就来对地方了。

228
00:18:53.113 --> 00:18:56.663
是的，有有趣的表情包和市场，还有一些与金钱有关的东西，所有这些东西。

229
00:18:56.663 --> 00:19:01.451
但在所有这些之外，区块链的目的与古老的小学

230
00:19:01.451 --> 00:19:06.468
牢不可破有关，承诺小指发誓，让我们得到青蛙。

231
00:19:06.468 --> 00:19:10.665
你在生活中所做的几乎每一件事都是协议或合同的结果。

232
00:19:10.665 --> 00:19:16.580
你的椅子是一个协议的结果，买卖木材组装，然后把椅子卖给一个真正的裁缝在亚马逊。

233
00:19:16.580 --> 00:19:19.325
然后你们达成协议，以40美元的价格买下这把椅子。

234
00:19:19.325 --> 00:19:26.375
你家里的灯是由电力驱动的，这是你和电力公司的协议你同意支付给他们作为回报他们会让

235
00:19:26.375 --> 00:19:33.425
灯继续亮着他们产生的电这是他们和建造涡轮机发电的工程师之间的协议你同意每个月付给

236
00:19:33.425 --> 00:19:40.475
他们一笔钱，作为回报，他们什么都不做或者我的意思是，他们会支付你的医疗费用，几乎

237
00:19:40.475 --> 00:19:47.704
你所做的每一件事，你与之互动的每一件事，都是某种形式的协议或契约在某些方面的结果。

238
00:19:47.704 --> 00:19:56.032
现在，协议和契约可能会让人觉得抽象和无聊，如果要真正理解和简化的话，我们也可以把它们称为承诺。

239
00:19:56.032 --> 00:19:57.309
当你换机油的时候。

240
00:19:57.309 --> 00:20:02.299
他们承诺会忠实地为你更换石油作为交换，当你把钱存入银行

241
00:20:02.299 --> 00:20:07.289
时，他们承诺保管好钱作为交换，他们会用你的钱发放贷款。

242
00:20:07.289 --> 00:20:14.201
当你买彩票的时候，彩票承诺给你一个公平的机会，让你买彩票来换取一大笔钱。

243
00:20:14.201 --> 00:20:16.604
当你达成这些协议的时候。

244
00:20:16.604 --> 00:20:21.630
在某种程度上，你是在要求他们小指发誓不欺骗你，公平地对待你。

245
00:20:21.630 --> 00:20:23.172
但这并不总是发生。

246
00:20:23.172 --> 00:20:32.075
让我们看看现实世界中有人打破小手指誓言的例子，早在80年代和90年代，麦当劳就开展了一项促销活动，让人们通过收集麦当劳的大富翁游戏卡来赢钱。

247
00:20:32.075 --> 00:20:33.027
这个想法很简单。

248
00:20:33.123 --> 00:20:36.748
你买麦当劳作为回报，就有机会赢得100万美元。

249
00:20:36.748 --> 00:20:42.768
你可以想象麦当劳会说嘿，大家，我保证如果你买我们的MC食品和麦乐

250
00:20:42.768 --> 00:20:48.977
鸡，我们会给你一个公平的机会赢得这笔钱，但我们最终打破了这个承诺，

251
00:20:48.977 --> 00:20:54.999
你没有一个公平的机会赢得这笔钱你的机会实际上在90年代中期是零。

252
00:20:54.999 --> 00:21:01.040
说实话，有1300万到2400万美元流入了那些不玩游戏的人的口袋。

253
00:21:01.040 --> 00:21:06.530
但一群腐败的内部人士操纵了游戏，这意味着当你在玩麦当劳的大富翁游戏时，

254
00:21:06.530 --> 00:21:11.707
你就相信了一系列的谎言和承诺，而这些谎言和承诺100%都会被打破。

255
00:21:11.707 --> 00:21:16.075
问题是，这到底是不是麦当劳的错并不重要。

256
00:21:16.127 --> 00:21:19.593
是他们做出了最终无法兑现的承诺。

257
00:21:19.593 --> 00:21:26.580
另一种思考方式是他们从你我那里偷走了2400万美元如果这个

258
00:21:26.580 --> 00:21:31.880
系统部署在区块链上是一种叫做智能合约的东西，

259
00:21:31.880 --> 00:21:40.555
它不可能欺骗这2400万美元因为智能合约是不可变的，去中心化的和透明的。

260
00:21:40.555 --> 00:21:42.630
但我马上就会回到这个问题上。

261
00:21:42.630 --> 00:21:47.195
在我们签订的所有协议和合同中，想象一下和一个10

262
00:21:47.195 --> 00:21:51.951
岁的孩子对着小指发誓，想象一下这个协议将如何执行。

263
00:21:51.951 --> 00:21:57.199
伙计，你能帮我保管好我的钱吗?如果你喜欢，你可以玩，但请在我回来的时候拿着它。

264
00:21:57.199 --> 00:21:57.819
立即。

265
00:21:57.819 --> 00:22:01.389
你可能会感到焦虑，可能会出问题。

266
00:22:01.389 --> 00:22:02.647
这个10岁的孩子可能会失去你的钱。

267
00:22:02.647 --> 00:22:08.442
你可能会想，我怎么能相信他们?他们是否会违背诺言，

268
00:22:08.442 --> 00:22:13.775
因为不值得信任的情况而感到无法呼吸?总是一次。

269
00:22:13.775 --> 00:22:20.691
我能相信这个二手车推销员给我一辆好车吗?我能相信这个写着可机洗的标签吗?还是会让我的衬衫

270
00:22:20.691 --> 00:22:27.607
缩水?我的保险公司会违背他们为我支付医疗费的承诺吗?我是帕特里克，他答应和我一起去远足。

271
00:22:27.607 --> 00:22:29.848
他，我真的会的。

272
00:22:29.848 --> 00:22:34.796
但我们目前的协议和合同的问题是，我们必须信任人民。

273
00:22:34.796 --> 00:22:36.902
我们让他们做正确的事。

274
00:22:36.902 --> 00:22:40.566
然而，他们经常被激励去做不正确的事情。

275
00:22:40.566 --> 00:22:42.539
保险公司不想赔钱。

276
00:22:42.539 --> 00:22:48.316
有时候销售人员只是想把东西从货架上拿下来，我答应和我的女朋友去远足。

277
00:22:48.316 --> 00:22:49.152
但我需要徒步旅行。

278
00:22:49.152 --> 00:22:50.427
其他地方也发生过。

279
00:22:50.427 --> 00:22:52.771
现在你可能会想，帕特里克，这看起来很酷。

280
00:22:52.771 --> 00:22:59.332
但这对我有什么影响?我们刚刚说过的麦当劳彩票在大萧条时期银行挤

281
00:22:59.332 --> 00:23:06.105
兑银行承诺保管好我们的钱当我们回去取钱的时候他们会把钱存在那里。

282
00:23:06.105 --> 00:23:13.863
当然，他们有时没有钱就像去年罗宾汉画了这幅神奇的画。

283
00:23:13.863 --> 00:23:20.263
在用户应用中，我们会给你进入市场的机会，我们承诺会给

284
00:23:20.263 --> 00:23:26.663
你一个与世界金融方面互动的公平机会，但不是这个资产。

285
00:23:26.663 --> 00:23:34.092
这个资产，这个资产还是这个资产，2008年的金融危机还记得关起门来的黑幕交易加上关于金融产

286
00:23:34.092 --> 00:23:41.521
品的谎言让世界经济陷入困境吗，你好吗?津巴布韦的恶性通货膨胀，巴西的恶性通货膨胀，有道理。

287
00:23:41.521 --> 00:23:50.318
美国的历史是一个无情的教训，值得信任的实体是臭名昭著的守信用者，我们终于有办法用智能合约来解决这个问题。

288
00:23:50.318 --> 00:23:56.318
现在，在我开始讲智能合约之前，很多人可能会想，嘿，总之很酷，

289
00:23:56.318 --> 00:24:02.318
但是，我们有适当的系统来防止这些事情，这是真的，这是伟大的。

290
00:24:02.318 --> 00:24:04.409
这是向前迈出的非常有益的一步。

291
00:24:04.409 --> 00:24:07.644
但是这些系统经常会崩溃2008年的系统就没起作用。

292
00:24:07.644 --> 00:24:10.525
有罗宾汉危机的那些肯定不起作用。

293
00:24:10.525 --> 00:24:16.259
即使这些制度适用，你去法庭试图解决它们，也许在你真正看到解决方

294
00:24:16.259 --> 00:24:22.178
案之前，你要在法庭上待上好几年，到那时，你需要钱的时间就更长了。

295
00:24:22.178 --> 00:24:27.634
那么这项技术是什么呢?这个工具能解决我们今天协议中的基

296
00:24:27.634 --> 00:24:33.294
本问题，这个工具就是智能合约区块链就是为这个工具而建的。

297
00:24:33.294 --> 00:24:36.794
现在，我将快速概述什么是智能合约。

298
00:24:36.794 --> 00:24:42.837
不过，我在描述中留下了一些链接，以便进行更深入的解释，但它们的基

299
00:24:42.837 --> 00:24:48.880
本内容是，智能合约是部署在去中心化区块链上的协议合约或一组指令。

300
00:24:48.880 --> 00:24:53.440
一旦部署了合同或指令集，它就不能被更改，

301
00:24:53.440 --> 00:24:58.229
它会自动执行，每个人都可以看到协议的条款。

302
00:24:58.229 --> 00:25:05.537
它真正的基础是代码是由分散的集体执行的，就像一群人，但一群人运行某种软件。

303
00:25:05.537 --> 00:25:13.265
这意味着任何个人或实体实际上都不能改变这些协议或改变这些传统协议中的安排条款。

304
00:25:13.265 --> 00:25:19.954
谁拥有合同，谁拥有合同的执行权，谁就可以按下开关，说，我们不会再那样做了。

305
00:25:19.954 --> 00:25:24.283
在智能合约和区块链中的web 3中，你再也不能这样做了。

306
00:25:24.283 --> 00:25:32.102
通常，这些智能合约位于去中心化的区块链上，并与去中心化的Oracle网络结合使用，以获取真实世界的资产和信息。

307
00:25:32.153 --> 00:25:36.645
如果这些话听起来像我在变出一个魔法咒语，那么，再一次，检查描述中的链接。

308
00:25:36.645 --> 00:25:38.586
如果您想了解更多关于技术含义的信息。

309
00:25:38.586 --> 00:25:41.810
如果你不是技术人员，那么你对细节不感兴趣，

310
00:25:41.810 --> 00:25:48.106
你可以把它想象成HTTPS，我打赌你们中的绝大多数人甚至不知道HTTPS代表什么。

311
00:25:48.154 --> 00:25:51.547
但你每天只要一上网就会用到它。

312
00:25:51.547 --> 00:25:58.099
那么这将如何解决麦当劳的大富翁问题呢?在传统的彩票形式中，彩票是关

313
00:25:58.099 --> 00:26:04.850
起门来执行的，有人操作并拥有彩票的代码，合同和协议，他们有权修改它。

314
00:26:04.850 --> 00:26:10.106
除了彩票公司内部的人，没有人能审计这种变化的发生。

315
00:26:10.156 --> 00:26:18.532
如果这个彩票的代码被部署到区块链上，每次黑客试图修改它，所有人都会收到通知。

316
00:26:18.532 --> 00:26:22.931
不仅如此，你甚至不能更改它，因为智能合约的条款不能更改。

317
00:26:22.931 --> 00:26:28.965
一旦部署，将该智能合约与链链接VRF Oracle结合起来，得到一个可验证的随机数。

318
00:26:28.965 --> 00:26:36.484
很快，你就有了一个完全去中心化的，不可改变的协议，不可能被黑，欺诈或

319
00:26:36.484 --> 00:26:44.004
操纵我们刚刚通过解决信任问题为公众节省了13,000,020万美元。

320
00:26:44.004 --> 00:26:48.124
这将如何解决罗宾汉的问题?罗宾汉的问题已经解决了。

321
00:26:48.160 --> 00:26:56.193
对吧?问题是，有一个中央机构可以在任何时候拨动开关，说你不能再进入这些市场了。

322
00:26:56.193 --> 00:26:59.906
我们违背了让你进入市场的承诺。

323
00:26:59.906 --> 00:27:02.961
这个问题已经通过去中心化交易解决了。

324
00:27:02.961 --> 00:27:07.099
现在已经有了，其中一个交换叫做uniswap。

325
00:27:07.162 --> 00:27:13.012
你可以交换ERC 20代币，它相当于股票，但有些是有些是，有点让人困惑。

326
00:27:13.012 --> 00:27:14.250
这个我也不讲了。

327
00:27:14.250 --> 00:27:19.538
但它没有一个中央集权的机构，可以拨动开关，破坏市场准入。

328
00:27:19.538 --> 00:27:24.473
如果这些投资者是在一个去中心化的交易所，这将

329
00:27:24.473 --> 00:27:29.634
为他们节省数亿美元，并将防止欺诈性的市场操纵。

330
00:27:29.634 --> 00:27:38.122
如何用内置在自动偿付能力检查中的透明度来解决银行的运行问题，你可以建立一个像智能合约一样的银行，它

331
00:27:38.122 --> 00:27:46.610
内置了偿付能力检查，这样就不可能到达那里，解决它意味着经纪人任何协议或任何历史教训，当信任假设被打

332
00:27:46.610 --> 00:27:55.098
破时，智能合约可以被应用，也应该被应用，特别是在一个大钱运行，拥有和控制一切的时代，我们迫切需要进

333
00:27:55.098 --> 00:28:03.761
入这样一个世界，在这个世界里，一些自私自利的中心化实体不能随意拨动开关，破坏人们获得所需服务的途径。

334
00:28:03.761 --> 00:28:08.652
我们可以从一个以品牌为基础的世界转移到一个以数学为基础的世界。

335
00:28:08.652 --> 00:28:14.046
现在，如果你与一个你不喜欢的服务互动，或者他们违背了他们的承

336
00:28:14.046 --> 00:28:19.620
诺，你唯一能做的就是走到街上的下一个服务，它会做出同样的承诺。

337
00:28:19.620 --> 00:28:28.170
你必须希望和祈祷他们真的会保留它。我们可以从那种情况发展到另一个世界，我们可以看着地图说，哦，好吧，一加一等于二。

338
00:28:28.170 --> 00:28:34.454
这就是这个协议将为我做的每一次保证，因为它是一个去中心化的自

339
00:28:34.454 --> 00:28:40.949
主代理没有动机去作恶，所有事情都是透明的，在一个大公司的公开。

340
00:28:40.949 --> 00:28:46.034
如果1 + 1 = 3对我来说更好的话，我可能会关起门来，大量

341
00:28:46.034 --> 00:28:51.120
输入一些数字，然后回来，用智能合约说，嘿，1 + 1 = 3。

342
00:28:51.172 --> 00:28:52.324
这是不可能的。

343
00:28:55.173 --> 00:29:01.551
现在，在两个协议之间做选择，一个是你必须信任一个集中的实体相信他们

344
00:29:01.551 --> 00:29:08.124
会为你做正确的事，另一个是去中心化的未被篡改的双集体，你会选择哪个。

345
00:29:08.124 --> 00:29:11.596
我要选一个不能每次都耍我的人。

346
00:29:11.596 --> 00:29:18.946
对于我所能应用的每一项协议，这项技术都是相对较新的，但我们已经看到它重塑了

347
00:29:18.946 --> 00:29:26.496
整个市场，并在继续这样做，传统的金融世界已经被反金融或去中心化的金融吃掉了。

348
00:29:26.496 --> 00:29:30.917
在这些协议中，已经有超过2000亿美元的资金用

349
00:29:30.917 --> 00:29:35.531
于帮助建立一个更公平、更负责、更透明的金融体系。

350
00:29:35.531 --> 00:29:43.034
这种反抗运动是我进入这个领域的主要原因之一，因为我们迫切需要离开我们现在的状态。

351
00:29:43.034 --> 00:29:51.146
人们获得财富的机会被某些群体吞噬了他们为了自己的利益而扭曲规则智能合约是我们通往更美好世界的门票。

352
00:29:51.146 --> 00:29:58.516
越来越多的行业也开始使用智能合约和区块链因为所有的创新和它的优势随

353
00:29:58.516 --> 00:30:06.111
着我们的发展和进步我们越来越接近实现这个概念的愿景，信任最小化协议。

354
00:30:06.180 --> 00:30:12.581
这些智能合约正在将我们需要给予他人的信任最小化，以使这些协议得以执行。

355
00:30:12.581 --> 00:30:16.948
如果信任最小化协议对你来说太困惑了，那就说不可打破的承诺。

356
00:30:16.948 --> 00:30:18.961
现在我得跟你们说实话了。

357
00:30:18.961 --> 00:30:23.708
区块链、智能合约和加密货币实际上可以做的不仅仅是信任、最小化协议。

358
00:30:23.708 --> 00:30:28.420
它们有安全方面的好处、正常运行时间方面的好处、执行方面的好处、速度方面的好处等等。

359
00:30:28.420 --> 00:30:31.445
但是先学一个再学其他的要容易得多，对吧。

360
00:30:31.445 --> 00:30:33.287
就像洒在上面的糖屑。

361
00:30:33.287 --> 00:30:34.532
这就是我们在这里的原因。

362
00:30:34.532 --> 00:30:41.990
这就是为什么我们要建设这样的未来，这就是为什么我们对此如此兴奋。

363
00:30:42.184 --> 00:30:45.917
即使只是在介绍部分，我们也学到了很多东西。

364
00:30:46.184 --> 00:30:48.748
让我们快速总结一下目前所学到的内容。

365
00:30:49.184 --> 00:30:55.842
比特币是一种数字黄金或一种价值存储方式，

366
00:30:55.842 --> 00:31:02.501
能够在用户之间以去中心化的方式进行交易。

367
00:31:02.501 --> 00:31:11.271
Aetherium和其他智能合约平台将区块链技术进一步推进，使人们能够制定智能合约和去中心化信任

368
00:31:11.271 --> 00:31:20.224
最小化协议，智能合约和去中心化应用程序可以使用所谓的去中心化Oracle网络访问和与现实世界交互。

369
00:31:20.224 --> 00:31:27.859
链链是一个去中心化的网络，它允许我们构建这些混合智能合约，它将链上逻辑与

370
00:31:27.859 --> 00:31:35.494
链下逻辑、去中心化数据和去中心化计算结合起来，使我们的逻辑完全去中心化，

371
00:31:35.494 --> 00:31:43.555
我们的数据和外部计算也完全去中心化，使我们拥有传统协议和传统合约的所有特征。

372
00:31:43.555 --> 00:31:46.567
现在像Aetherium和比特币这样的数字货币有了价值。

373
00:31:46.567 --> 00:31:53.959
即使没有智能合约部分，拥有一个抗审查的去中心化价值存储本身自然是强大的，我们

374
00:31:53.959 --> 00:32:01.546
在GitHub存储库中有一些链接，将教你这种去中心化价值存储如何颠覆传统金融。

375
00:32:01.546 --> 00:32:04.159
这也是构建智能合约的另一个重要原因。

376
00:32:04.192 --> 00:32:09.971
但同样，最简单的方法是信任最小化协议，或不可打破的承诺。

377
00:32:09.971 --> 00:32:14.520
但我们也来看看智能合约相比传统环境的其他一些特性。

378
00:32:14.520 --> 00:32:17.614
当然，第一个特征是它们是分散的。

379
00:32:17.614 --> 00:32:23.481
它们没有中央中介，运行这些区块链的不同个体被称为节点操作员。

380
00:32:23.481 --> 00:32:28.283
它是所有这1000个节点操作员的组合运行相同

381
00:32:28.283 --> 00:32:33.304
的软件运行这些算法运行这些智能合约使网络分散。

382
00:32:33.304 --> 00:32:35.782
我们将在后面深入研究它是如何工作的。

383
00:32:35.782 --> 00:32:40.775
下一个特点是这些去中心化网络的透明度和灵活性。

384
00:32:40.775 --> 00:32:45.198
因为所有这些单独的节点操作员运行软件，每个人都能看到链

385
00:32:45.198 --> 00:32:49.786
上发生的一切，这意味着没有黑幕交易，没有奇怪的事情发生。

386
00:32:49.786 --> 00:32:54.669
任何不公平的东西，人们都能看到，但不用，

387
00:32:54.669 --> 00:32:59.797
每个人都有完整的信息，必须遵守同样的规则。

388
00:32:59.797 --> 00:33:05.235
另外，这并不意味着没有隐私，区块链是伪匿名的，这意味着你在

389
00:33:05.235 --> 00:33:10.674
现实生活中不一定与某个身份挂钩，它们也有速度和效率的特点。

390
00:33:10.674 --> 00:33:16.108
对于那些曾经尝试过通过银行转账或跨海汇款的人来说，你知道，这有时需

391
00:33:16.108 --> 00:33:21.708
要两到三周的时间，而实际上，所有这些银行真正做的只是基本的数学运算。

392
00:33:21.708 --> 00:33:26.819
他们从你的结余中减去钱然后把它加到其他结余中。

393
00:33:26.819 --> 00:33:31.733
为什么要花这么长时间，在区块链中，所有的交易都是瞬间发生的。

394
00:33:31.733 --> 00:33:37.867
另一个例子是，今天在金融界工作的人都知道，清算所和结算日可能需要很长时间。

395
00:33:37.867 --> 00:33:42.154
在区块链中，不需要这些，因为它们是瞬间发生的。

396
00:33:42.202 --> 00:33:48.155
这显然要快得多，但它也使彼此之间的交互更加有效，安全和不可变。

397
00:33:48.202 --> 00:33:51.284
同样，不可变意味着它不能被改变。

398
00:33:52.203 --> 00:33:59.940
契约被部署了，就是这样，无论代码中有什么都将永远存在于代码中，它们不能以任何方式被修改或篡改。

399
00:33:59.940 --> 00:34:02.104
这意味着安全性要容易得多。

400
00:34:02.204 --> 00:34:07.865
而在一个中心化的世界里，有人可以黑进服务器，跳进数据库，改变一些数字。

401
00:34:07.865 --> 00:34:09.600
你在区块链的世界里做不到。

402
00:34:09.600 --> 00:34:14.917
由于它是去中心化的，为了黑进区块链，你必须接管一半的

403
00:34:14.917 --> 00:34:20.439
节点，而在中心化的世界里，你只需要接管一个普通的节点。

404
00:34:20.439 --> 00:34:24.539
如果你的电脑和备份电脑都坏了，你所有的数据都没了。

405
00:34:24.539 --> 00:34:29.548
在区块链的世界里，如果你的电脑和备份电脑瘫痪了，你所有的

406
00:34:29.548 --> 00:34:34.557
数据都是安全的，因为它们是在所有这些分散的节点上运行的。

407
00:34:34.557 --> 00:34:38.400
即使有100个节点或者1000个节点宕掉。

408
00:34:38.400 --> 00:34:44.481
这并不重要，因为只要一个节点拥有区块链的副本，就可以轻松入侵

409
00:34:44.481 --> 00:34:50.563
区块链，这几乎是不可能的，而且比入侵集中式服务器要困难得多。

410
00:34:50.563 --> 00:34:54.099
不仅如此，从资产的角度来说，这也更安全。

411
00:34:54.099 --> 00:34:59.405
所有您需要访问您的凭证和您资产中的信息的是您的私钥。

412
00:34:59.405 --> 00:35:02.618
这基本上就是你所有这些的密码。

413
00:35:02.618 --> 00:35:07.609
正如我们在视频中讨论的，智能合约消除了交易对手风险，消除

414
00:35:07.609 --> 00:35:12.600
了集中式中介，消除了我们在web 2中必须做的信任网关。

415
00:35:12.600 --> 00:35:18.151
当我们与用户和个人接触时，他们并不总是把我们的最佳利益放在心上智能合约，

416
00:35:18.151 --> 00:35:23.703
消除了交易对手的风险，因为一旦这些合约被创建，他们不能进入也不能修改它。

417
00:35:23.703 --> 00:35:28.899
他们不能让贪婪、自负或其他任何东西占了上风，改变协议的条款。

418
00:35:28.899 --> 00:35:35.503
就像我们说的，这就产生了信任最小化协议或者是不可打破的计划承诺。

419
00:35:35.503 --> 00:35:41.554
我们从基于品牌的协议转移到基于数学的协议，我们可以研究密码学，可

420
00:35:41.554 --> 00:35:47.794
以直接研究代码，并确切地知道某些东西将会做什么，以及它将如何执行，

421
00:35:47.794 --> 00:35:53.846
而不是必须依赖人类用智能合约和去中心化混合智能合约做正确的事情。

422
00:35:53.846 --> 00:35:59.865
做正确的事是基础设施所有这些都归结为我们可以自由地以

423
00:35:59.865 --> 00:36:05.884
我们想要的方式互动而不必担心这样的互动会毁了我们的信

424
00:36:05.884 --> 00:36:11.904
任最小化的部分，这些不可打破的承诺，让互动变得更好。

425
00:36:11.904 --> 00:36:16.799
在一个纯web - two的世界里，我们不断被项目和协

426
00:36:16.799 --> 00:36:21.694
议的信息轰炸，迫使我们朝着更有利可图的方向前进或行动。

427
00:36:21.694 --> 00:36:25.237
与智能合约相比，我们可以透明地看到一切。

428
00:36:25.237 --> 00:36:33.589
我们甚至可以参与互动成为协议和互动的部分所有者我们决定要成为其中的一部分。

429
00:36:33.589 --> 00:36:39.695
智能合约已经出现几年了。

430
00:36:39.695 --> 00:36:46.708
由于这些智能合约平台的出现，它们为哪些行业带来了什么?你可能听说过其

431
00:36:46.708 --> 00:36:53.721
中一些我们已经提到过，但让我们快速复习一下，d d代表去中心化金融。

432
00:36:53.721 --> 00:36:59.484
它让用户能够与金融和市场打交道，而不必经过一个集中的中介。

433
00:36:59.484 --> 00:37:04.174
例如，就像我们说的，有了罗宾汉，你不再需要相信罗宾

434
00:37:04.174 --> 00:37:09.052
汉会继续让你进入市场，相反，你可以在智能合约中看到。

435
00:37:09.052 --> 00:37:12.409
是的，我在2008年的金融危机中还是进入了市场。

436
00:37:12.409 --> 00:37:17.889
你永远不需要相信这些团体和机构在后台会给你正确的东西。

437
00:37:17.889 --> 00:37:23.547
你可以在区块链上透明地看到一切，你可以在记录的时

438
00:37:23.547 --> 00:37:29.442
候轻松、有效、安全地接触货币市场和复杂的金融产品。

439
00:37:29.442 --> 00:37:34.587
德飞管理的资产约为2,000亿美元，而且还在快速增长。

440
00:37:34.587 --> 00:37:40.744
如果你真的对defy感到兴奋，我们有大量的defy示例向你展示如何构建和与这些协议交互。

441
00:37:40.744 --> 00:37:41.782
在接下来的课程中。

442
00:37:41.782 --> 00:37:43.051
Dows或去中心化。

443
00:37:43.226 --> 00:37:46.716
自治组织是我们已经提到过的另一个组织。

444
00:37:46.716 --> 00:37:52.734
Dows是由链上的一组指令或智能合约完全去中心化管理的组。

445
00:37:52.734 --> 00:37:56.678
这有一些巨大的好处，让参与变得更容易。

446
00:37:56.678 --> 00:37:57.645
规则是非黑即白的。

447
00:37:57.645 --> 00:38:04.151
你可以直接在连锁投票和区块链空间中完全去中心化的治理技术上看到一切，这是

448
00:38:04.151 --> 00:38:10.657
推动我们如何发展政治和如何发展治理使其更有效，公平和合理的重要因素之一。

449
00:38:10.657 --> 00:38:15.990
你最好知道它，我们有一些例子，如何建立Dows和如何与Dows来的教训工作。

450
00:38:15.990 --> 00:38:21.724
所以一定要关注那些NF T的斯坦福不可替代代币，它们真的可以被描述为数

451
00:38:21.724 --> 00:38:27.622
字艺术或只是一种独特的资产，它们可以做更多，但我们现在将保持它的高水平。

452
00:38:27.622 --> 00:38:35.431
像董事会猿和加密朋克这样的项目彻底改变了人们获得工作报酬的方式，展示他们的创造力、地位和其他很多东西。

453
00:38:35.431 --> 00:38:40.454
是的，当然，我们也有课程向你展示如何创造和与NF - T的互动，如

454
00:38:40.454 --> 00:38:45.477
此多的其他团体和如此多的其他行业正因为这个疯狂的技术而被创造出来。

455
00:38:45.477 --> 00:38:50.562
也许在这里和我们一起结束旅程后，你们走出去，你们将成为下一

456
00:38:50.562 --> 00:38:55.648
个行业或下一个数十亿美元的想法的先驱，你们已经学到了很多。

457
00:38:55.648 --> 00:39:01.184
但是现在我们已经了解了很多高级信息，让我们最后开始，

458
00:39:01.184 --> 00:39:06.934
让我们进行第一次交易让我们准备好与这个新世界进行交互。

459
00:39:06.934 --> 00:39:15.409
在下一节中，我们将为您准备一个钱包，并向您展示交易到底是什么样子和感觉。

460
00:39:15.409 --> 00:39:17.186
让我们开始吧。

461
00:39:17.186 --> 00:39:21.350
这是Aetherium网站Aetherium。

462
00:39:21.350 --> 00:39:28.736
我们将在一个测试Aetherium区块链上进行交易，我会稍微解释一下这是什么意思。

463
00:39:28.736 --> 00:39:32.374
这将是区块链上的第一笔交易。

464
00:39:32.374 --> 00:39:36.975
现在，我们将遵循的这个过程将与多边形、雪崩

465
00:39:36.975 --> 00:39:41.796
幻影和所有其他与EVM兼容的区块链完全相同。

466
00:39:41.796 --> 00:39:43.932
我稍后也会解释这是什么意思。

467
00:39:43.932 --> 00:39:49.327
现在，只要跟着做，在这些区块链上进行交易就可以了。

468
00:39:49.327 --> 00:39:53.931
我们要做的第一件事是建立一个钱包。

469
00:39:53.931 --> 00:40:01.419
我要选择meta mask因为它是最受欢迎的钱包之一也是最容易使用的钱包之一，我们要下载它。

470
00:40:01.419 --> 00:40:06.901
我用的是brave浏览器，但它适用于Chrome、Firefox或其他任何浏览器。

471
00:40:06.901 --> 00:40:12.016
它只是浏览器右上角的一个小扩展。

472
00:40:12.016 --> 00:40:19.346
通过这种方式，我们可以在任何时候轻松地看到我们钱包里的货币，仍然是基于Aetherium的货币。

473
00:40:19.346 --> 00:40:25.592
我要为brave安装meta mask，添加到brave，添加扩展。

474
00:40:25.592 --> 00:40:30.258
现在我们可以开始与Brave合作了，这是你在开始你的

475
00:40:30.258 --> 00:40:35.105
旅程时绝对需要采取的第一步，也是最容易采取的步骤之一。

476
00:40:35.105 --> 00:40:36.734
所以我们要开始了。

477
00:40:36.734 --> 00:40:39.891
我们将创造一种全新的钱包。

478
00:40:39.891 --> 00:40:41.692
我们会点击创建钱包。

479
00:40:41.692 --> 00:40:50.044
如果你已经有了一个钱包，你可以通过我有一个种子短语来导入它，我们稍后会讨论种子短语或秘密短语。

480
00:40:50.044 --> 00:40:52.844
让我们继续创建一个新的钱包。

481
00:40:52.844 --> 00:40:59.148
当然，我们会同意帮助超掩模现在我们会创建我们的密码确保它是安全的。

482
00:40:59.148 --> 00:41:02.987
在这个演示中，我的密码就是密码。

483
00:41:02.987 --> 00:41:05.229
但请不要把它作为你的密码。

484
00:41:05.229 --> 00:41:08.633
你也可以通过这样的视频了解你的秘密恢复短语。

485
00:41:08.633 --> 00:41:11.278
这和你的肺炎是一样的。

486
00:41:11.278 --> 00:41:14.983
但是看看你的恢复短语，你会更清楚它是什么。

487
00:41:14.983 --> 00:41:19.591
再一次，他给了我们很多不同的关于如何储存和保护它的建议。

488
00:41:19.591 --> 00:41:24.041
我想说的是永远不要分享这个，绝对不要分享这个。

489
00:41:24.041 --> 00:41:27.903
我们继续，点击显示暗语。

490
00:41:27.903 --> 00:41:32.048
我在这里给你们看，因为这只是一个演示，我并不在乎。

491
00:41:32.048 --> 00:41:38.827
但是，如果您将这个秘密短语显示给其他人，他们将有权访问您的申请中的所有资金。

492
00:41:38.827 --> 00:41:46.020
这一课我们要做的是，我们要用假币，我们要用非真钱，所以没关系。

493
00:41:46.020 --> 00:41:53.573
现在为了测试和开发的目的，我总是建议使用一个完全独立的元掩码，一个完全独立的钱包。

494
00:41:53.573 --> 00:41:59.805
在整个课程中，如果你已经有了一个钱包，或者你已经有了一个元掩码，请新建

495
00:41:59.805 --> 00:42:06.216
一个，新建一个配置文件，新建一个元掩码，这将是你在整个课程中使用的钱包。

496
00:42:06.252 --> 00:42:10.690
然而，如果你真的要把钱放在这里，你绝对需要把它写下来。

497
00:42:10.690 --> 00:42:19.318
因为如果你失去了访问这个的权限，以及你所有的私钥，我们稍后会讲到，你将失去访问你的钱包的权限，你将失去访问你所有资金的权限。

498
00:42:19.318 --> 00:42:26.115
所以他们给一些建议存储这个短语和密码管理器就像一个密码,把这句话写在一张纸上,

499
00:42:26.115 --> 00:42:32.912
把它放在一个安全的位置,记住它,无论你想做什么,只要确保你有一个备份,我只是点

500
00:42:32.912 --> 00:42:40.058
击下载这个,这不是最佳实践保存到你的电脑,最好是使用密码管理器或把它写在一张纸上。

501
00:42:40.058 --> 00:42:42.492
所以我们要继续下一个。

502
00:42:42.492 --> 00:42:47.927
它会要求我们验证我们是否真的把它写下来了。

503
00:42:47.927 --> 00:42:52.725
我们继续点击确认，很好，他给了我们一些其他的建议。

504
00:42:52.725 --> 00:42:57.843
记住，一定要认真对待这些建议，特别是如果你打算用它来赚真金白银的话。

505
00:42:57.843 --> 00:43:00.835
就像我说的，对于这个演示，我们将使用测试资金。

506
00:43:00.835 --> 00:43:02.348
所以这没什么大不了的。

507
00:43:02.348 --> 00:43:10.758
但如果你投入了真正的钱，你绝对需要备份这个种子短语或秘密短语否则我们将把它称为肺炎短语。

508
00:43:10.758 --> 00:43:11.158
太棒了。

509
00:43:11.258 --> 00:43:15.868
现在我们可以看到我们钱包的界面在这里全屏显示。

510
00:43:16.259 --> 00:43:22.976
根据你的浏览器，你可以把它固定在你的浏览器上你可以点击它在右上角，

511
00:43:22.976 --> 00:43:29.286
它会下拉，你可以看到相同的界面我们的肺炎短语那个秘密短语，他们

512
00:43:29.286 --> 00:43:36.209
我们的秘密12个单词让我们进入一个新账户，我们的账户地址就在这里。

513
00:43:36.261 --> 00:43:42.839
实际上，如果我们点击它，把它复制到剪贴板上，然后找到一个叫以太扫描的

514
00:43:42.839 --> 00:43:49.612
块资源管理器，我们可以把我们的地址粘贴到这里，查看我们账户的详细信息。

515
00:43:49.612 --> 00:43:52.631
以太扫描，就像我说的，就是所谓的块浏览器。

516
00:43:52.631 --> 00:43:58.339
它是一种查看不同地址的交易和发生在区块链上的其他事件的方法。

517
00:43:58.339 --> 00:44:06.197
如果我们看一下我们刚刚在以太扫描以太主网上创建的地址，我们可以看到没有交易发生。

518
00:44:06.264 --> 00:44:14.269
没有分析，没有评论，没有平衡，没有价值，因为这是一个全新的钱包，我们

519
00:44:14.269 --> 00:44:22.511
刚刚输入以太扫描的地址代表我们唯一的地址我们唯一的钱包只能被我们识别。

520
00:44:22.511 --> 00:44:27.804
我们会再多讲一点以太扫描因为它是我们在钱包中经常使用

521
00:44:27.804 --> 00:44:33.097
的工具比如元掩码，你甚至可以点击这里创建更多的账户。

522
00:44:33.097 --> 00:44:36.608
让我们继续创建一个新帐户。

523
00:44:36.608 --> 00:44:41.017
我们称这个账户为2。

524
00:44:41.267 --> 00:44:43.750
如你所见，这个有不同的地址。

525
00:44:44.268 --> 00:44:47.493
点击这个，我们回到以太扫描。

526
00:44:49.268 --> 00:44:49.719
在这里。

527
00:44:49.719 --> 00:44:50.557
我们按回车键。

528
00:44:53.269 --> 00:44:55.869
唯一能被我们识别的，就在这里。

529
00:44:57.269 --> 00:45:05.746
没有价值，没有交易如果我们回到Metamask，点击这个小按钮，我们可以看到这里有两个不同的账户，是一样的。

530
00:45:05.746 --> 00:45:11.879
如果我们点击右上角的扩展，点击按钮，我们有两个不同的帐户。

531
00:45:11.879 --> 00:45:19.660
12字秘密恢复短语允许我们创建多个帐户，所有与相同的秘密恢复短语。

532
00:45:19.660 --> 00:45:26.144
这个秘密恢复短语会让我们访问账号1和账号2以及通过点击create

533
00:45:26.144 --> 00:45:33.415
account按钮创建的任何其他账号，因为它让你访问元掩码中的所有账号。

534
00:45:33.415 --> 00:45:38.915
我们两个账户的地址都是公开的唯一标识符，但它

535
00:45:38.915 --> 00:45:44.416
们也有一个只有我们可以识别的私人唯一标识符。

536
00:45:44.416 --> 00:45:49.720
类似于肺炎，这些是私人标识符我们不想分享也

537
00:45:49.720 --> 00:45:55.024
不想泄露他们的私人信息这就是你的账户私钥。

538
00:45:55.024 --> 00:46:02.655
助记符会让你访问多个账户，私钥只让你访问其中一个账户，点击这三

539
00:46:02.655 --> 00:46:10.534
个小点就能看到，进入账户详情，导出私钥，你只需要在这里输入密码。

540
00:46:10.534 --> 00:46:13.292
你就能看到你的私钥。

541
00:46:13.292 --> 00:46:17.957
这是你账户的私钥，你可以把私钥想

542
00:46:17.957 --> 00:46:22.623
象成你账户的密码，用来创建交易。

543
00:46:22.623 --> 00:46:27.228
我之所以在屏幕上显示我的钱是因为我不会在这里放真钱。

544
00:46:27.228 --> 00:46:30.563
这将是本教程的一次性账户。

545
00:46:30.563 --> 00:46:36.985
我再次强烈建议，你使用一次性账户，你使用的账户，你从来没有存入任何真正的钱。

546
00:46:36.985 --> 00:46:41.326
在此过程中，我将向你展示如何确保你不会那样做。

547
00:46:41.326 --> 00:46:47.161
但通常情况下，展示或分享你的私钥或你的秘密恢复短语不是一

548
00:46:47.161 --> 00:46:53.205
个好主意，如果有人得到了这个私钥，他们就能访问我的账号1。

549
00:46:53.281 --> 00:47:01.789
但是，他们无法进入我的账户如果他们拿到了我的12字康复词组或者肺炎他们就能进入两个账户。

550
00:47:01.789 --> 00:47:07.342
这就是为什么当人们说保管好你的私钥，你的比特币，你的密钥，

551
00:47:07.342 --> 00:47:13.088
你的Aetherium，他们说的是你的助记术或秘密恢复短语。

552
00:47:13.088 --> 00:47:18.444
你的私钥是私有的，你的公共地址是完全公开的。

553
00:47:18.444 --> 00:47:23.133
任何人都可以通过以太扫描或其他方式查看你的账户。

554
00:47:23.133 --> 00:47:26.348
人们分享他们的公共地址是完全可以的。

555
00:47:26.348 --> 00:47:29.735
如果您丢失了私钥，您将失去对其中一个帐户的访问权限。

556
00:47:29.735 --> 00:47:33.704
如果你失去了助记功能，你可能会失去访问所有账户的权限。

557
00:47:33.704 --> 00:47:38.131
基本上，我想说的是把它们备份起来，放在安全的地方，

558
00:47:38.131 --> 00:47:42.737
因为这门课你丢了也没关系，因为我们不会往里面投真钱。

559
00:47:42.737 --> 00:47:44.630
但在现实世界中，一定要这样做。

560
00:47:44.630 --> 00:47:44.974
和伟大的。

561
00:47:44.974 --> 00:47:47.176
这些都是主要的安全考虑因素。

562
00:47:47.176 --> 00:47:52.201
现在，如果你看右上方，就在我们点击的帐户按钮旁边，

563
00:47:52.201 --> 00:47:57.429
你会看到这个东西写着以太主网，这是我们的网络选项卡。

564
00:47:57.429 --> 00:48:02.201
如果我们点击它，我们可以看到一个列表，上面有我们目前

565
00:48:02.201 --> 00:48:07.158
可以访问的所有不同的网络，一个以太主网就是以太的主网。

566
00:48:07.158 --> 00:48:11.196
这是真正的钱被花费和用于交易的地方。

567
00:48:11.196 --> 00:48:17.592
在这门课上，我们不会使用以太主网，我们会使用一个叫做测试网的东西。

568
00:48:17.592 --> 00:48:25.401
因为我们是工程师，我们经常想要测试，看看我们的代码实际上要做什么，以及如何与它交互。

569
00:48:25.401 --> 00:48:32.725
我们将结合使用本地网络和测试网络来测试我们的智能合约。

570
00:48:32.725 --> 00:48:34.709
我们将主要使用本地网络。

571
00:48:34.709 --> 00:48:39.786
但我们会讲到这点，看看一些测试网络默认带有元掩码，我们点

572
00:48:39.786 --> 00:48:45.046
击show / hide测试网络，这将带我们进入设置页面。

573
00:48:45.046 --> 00:48:48.050
我们点击选择这个来显示列表中的测试网络。

574
00:48:48.050 --> 00:48:55.467
我们点击现在，如果我们向上滚动，我们会关闭设置，我们再次点击网络选项卡。

575
00:48:55.467 --> 00:49:01.682
现在我们可以看到所有其他的网络，如ropsten, Koven, Rinkeby和Garelli。

576
00:49:01.682 --> 00:49:09.372
这些测试网络或网络类似于Aetherium，或polygon，或Avalanche或phantom或任何其他区块链。

577
00:49:09.372 --> 00:49:13.169
我们可以把我们的账户切换到其他的测试网络。

578
00:49:13.169 --> 00:49:18.095
例如，我们点击溜冰场B，我们可以在Rinkeby测试网络上看到它。

579
00:49:18.095 --> 00:49:24.224
我们也没有Aetherium我们这里没有钱或者什么都没有，我们有一个空白的Rinkeby钱包。

580
00:49:24.224 --> 00:49:30.542
这些测试网的工作方式与Aetherium的主网络几乎相同，除了它们不是用真钱运行。

581
00:49:30.542 --> 00:49:38.916
他们使用假币作为一种学习和互动的方式，让我们看到这些不同的智能合约在拍摄时是如何一起工作的。

582
00:49:38.916 --> 00:49:43.035
溜冰场B和新冠病毒一样是最受欢迎的测试网络之一。

583
00:49:43.035 --> 00:49:51.675
然而，在本教程中，一定要检查我们的GitHub存储库，以确保你

584
00:49:51.675 --> 00:50:00.594
总是跟上最好的测试网络，因为他们的测试网络是人们出于好心运行的。

585
00:50:00.594 --> 00:50:05.574
有时候最好的版本会改变，所以一定要跟随GitHub仓库。

586
00:50:05.574 --> 00:50:09.610
我们有时也会使用COVID，或者甚至使用Grilli。

587
00:50:09.610 --> 00:50:12.490
我们将向你们展示如何使用这些不同的测试网。

588
00:50:12.490 --> 00:50:19.651
事实上，如果我们去到与这门课程相关的GitHub回购，我们可以看到推荐测试网确实是当前排名。

589
00:50:19.651 --> 00:50:25.252
这就是我们要做的，如果这个改变了，你们应该能跟上另一个测试。

590
00:50:25.302 --> 00:50:27.349
我们会留下关于如何继续的笔记。

591
00:50:28.302 --> 00:50:34.547
我们可以去里格比以太扫描，我们可以去，你可以去，林库以

592
00:50:34.547 --> 00:50:40.793
太扫描，它似乎是第一个出现在林克比点以太扫描上的东西。

593
00:50:40.793 --> 00:50:46.123
伊奥，我们可以输入相同的地址，复制粘贴。

594
00:50:46.123 --> 00:50:50.526
我们可以在林克比以太扫描上看到这个地址的一些细节。

595
00:50:50.526 --> 00:50:52.915
就像我说的，现在，它完全空白。

596
00:50:52.915 --> 00:51:00.680
这个网络接口稍后也是我们如何能够与多边形，雪崩等，我们只需要添加网络。

597
00:51:00.680 --> 00:51:02.133
但我们一会儿就会讲到。

598
00:51:02.133 --> 00:51:10.368
重申一下，测试网是免费的，用于测试我们的智能合约和主网需要花钱，而且被认为是实时的。

599
00:51:10.368 --> 00:51:17.612
现在我也想在这里提出一个警告，我们要记住，这些测试网是为了人们的心的善良而运行的。

600
00:51:17.612 --> 00:51:21.671
所以我们不想滥用它们，我们想利用它们来学习，然后继续前进。

601
00:51:21.671 --> 00:51:25.240
所以尽量不要在这些测试网络上发送十亿次交易。

602
00:51:25.240 --> 00:51:31.325
事实上，我们现在要做的是在Rinkeby测试网上发送一个交易。

603
00:51:31.325 --> 00:51:35.176
这将向我们展示它在主网上是什么样子的。

604
00:51:35.176 --> 00:51:40.697
为了让我们模拟其中的一个交易，我们要用到一个叫做水龙头的东西。

605
00:51:40.697 --> 00:51:47.861
如果你去和这门课相关的GitHub存储库，在推荐测试网的下面会有一个测试网水

606
00:51:47.861 --> 00:51:55.214
龙头，它会告诉我们最新的水龙头位置在哪里我们可以得到测试网Aetherium。

607
00:51:55.214 --> 00:52:01.567
这里是faucets。chain。link，这也是推荐的水龙头，我们

608
00:52:01.567 --> 00:52:07.921
可以把钱包地址放进去，得到一些测试网链接或测试网Aetherium。

609
00:52:07.921 --> 00:52:13.278
现在我们要做的就是把我们的钱包和瑞克比的网络连接起来。

610
00:52:13.278 --> 00:52:19.640
所以我们要下来，我们要从COVID转换到以太。

611
00:52:19.640 --> 00:52:25.867
然后我们要确保我们的元掩码在这里的Rinkeby测试网络上。

612
00:52:25.867 --> 00:52:30.147
一旦这两个都设置好了，我们将继续并点击连接钱包。

613
00:52:30.147 --> 00:52:33.147
我们要选择元蒙版。

614
00:52:33.315 --> 00:52:39.790
一旦我们这样做了，我们的元掩码实际上会弹出并说，你想连接到这个网站吗，连

615
00:52:39.790 --> 00:52:46.265
接到一个网站是我们如何让这些网站在界面上与我们的钱包和我们的元掩码互动。

616
00:52:46.316 --> 00:52:50.594
别担心，我们不会发送任何这样的事务，我们稍后会讲到这个。

617
00:52:50.594 --> 00:52:53.423
我们可以选择一个想要连接的账户。

618
00:52:53.423 --> 00:52:56.192
选择账号1，点击Next。

619
00:52:57.317 --> 00:52:59.375
然后我们继续连接。

620
00:53:00.317 --> 00:53:04.252
连接，我们可以看到我们的账户连接在这里。

621
00:53:04.318 --> 00:53:06.011
而那个小小的警告现在消失了。

622
00:53:07.318 --> 00:53:11.697
自动放到这里，我们将进行第一个测试事务。

623
00:53:11.697 --> 00:53:14.887
现在，我们不需要test link。

624
00:53:14.887 --> 00:53:16.302
所以我们把它放在一边。

625
00:53:16.302 --> 00:53:18.974
但稍后，我们会回来得到那个测试链接。

626
00:53:18.974 --> 00:53:21.652
现在我们只需要0。

627
00:53:21.652 --> 00:53:24.022
1 .测试Aetherium。

628
00:53:24.320 --> 00:53:28.223
让我们继续，通过选择红绿灯来完成安全。

629
00:53:28.223 --> 00:53:30.545
然后点击发送请求。

630
00:53:30.545 --> 00:53:36.643
这将会做的是我们要求这个水龙头给我们0。

631
00:53:36.643 --> 00:53:42.660
Aetherium测试网水龙头是我们通过测试网把钱放进钱包的一种方式。

632
00:53:42.660 --> 00:53:46.131
这就是为什么这个测试和Aetherium一文不值的原因。

633
00:53:46.131 --> 00:53:47.612
因为我们可以免费得到。

634
00:53:47.612 --> 00:53:54.497
这些在主网上是不存在的，你无法在主网上免费获得真正的Aetherium或真钱。

635
00:53:54.497 --> 00:53:57.723
所以我们在林克比我们得到了假冒的林克乙醚。

636
00:53:57.723 --> 00:53:59.643
然后点击发送请求。

637
00:53:59.643 --> 00:54:08.137
一旦我们点击Send Request，这个事务散列就会在这里弹出，它说事务已经启动，等待确认。

638
00:54:08.137 --> 00:54:12.449
这意味着其他钱包实际上会给我们发送0。

639
00:54:12.449 --> 00:54:13.136
1 .测试。

640
00:54:13.136 --> 00:54:21.825
这就是它正在进行的交易现在我们只需要等待我们的交易完成验证并通过。

641
00:54:21.825 --> 00:54:25.584
现在，如果这不能立即工作，我建议等一分钟，然后再试一次。

642
00:54:25.584 --> 00:54:28.680
但我们能做的是点击这个事务哈希。

643
00:54:28.680 --> 00:54:32.850
如果交易没有显示，我们也可以关闭这个。

644
00:54:32.850 --> 00:54:34.945
我们可以在这里复制我们的地址。

645
00:54:34.945 --> 00:54:36.889
实际上我们已经看到0了。

646
00:54:36.889 --> 00:54:38.514
在我们的钱包里。

647
00:54:38.514 --> 00:54:46.629
但我们可以回到Rinkeby以太扫描，粘贴我们的地址，我们可以看到我们现在有0。

648
00:54:46.629 --> 00:54:48.216
1个乙醚作为平衡。

649
00:54:48.216 --> 00:54:54.079
我们还可以看到，我们有一个交易，所有这些信息进入我们的钱包。

650
00:54:54.079 --> 00:54:55.579
这就是绿色的含义。

651
00:54:55.579 --> 00:55:02.052
如果你点击交易链接，你会看到类似这样的东西，但如果你没有，不用担心，因

652
00:55:02.052 --> 00:55:08.710
为在以太扫描中，如果你点击交易列表中的交易哈希，你也可以看到所有的细节。

653
00:55:08.710 --> 00:55:10.422
现在在元掩码中，我们有0。

654
00:55:10.422 --> 00:55:10.977
1容易的。

655
00:55:10.977 --> 00:55:13.755
再说一次，这是假的Aetherium。

656
00:55:13.755 --> 00:55:18.281
我们现在有了一个与钱包相关的交易，这太棒了。

657
00:55:18.331 --> 00:55:26.568
但是，如果我们切换网络，如果我们把网络切换回以太主网，你可以看到我们在理论主网上什么都没有。

658
00:55:26.568 --> 00:55:31.332
如果是ropsten，也什么都没有，只有这个0。

659
00:55:31.332 --> 00:55:31.760
1容易的。

660
00:55:31.760 --> 00:55:39.871
在Rinkeby测试网络上，如果你想练习使用另一个测试网，我们正在使用的水龙头有多个测试网。

661
00:55:39.871 --> 00:55:45.851
让我们在这一节中尝试一下这是完全可选的，你可以观看，也可以跟着做。

662
00:55:45.851 --> 00:55:51.873
但例如，我可以在我的钱包里看到，我们已经支持COVID，所以也许我会切换到COVID。

663
00:55:51.873 --> 00:55:53.691
也许我们会转向COVID。

664
00:55:53.691 --> 00:55:59.270
在下拉菜单中，我们将删除测试10 Link，因为我们只需要测试eath。

665
00:55:59.270 --> 00:56:07.336
我们会点击“我不是机器人”，然后我们会发送请求，这次会弹出相同的内容，这将是针对COVID检测网的。

666
00:56:07.336 --> 00:56:10.224
一旦我们的交易完成。

667
00:56:10.224 --> 00:56:11.630
现在，COVID也是一样。

668
00:56:11.630 --> 00:56:17.523
这里，就像我们在溜冰场B上做的一样，一旦我们的交易完成，我们会看到0。

669
00:56:17.523 --> 00:56:23.613
如果你想尝试使用另一个测试网络，请在COVID网络上进行测试。

670
00:56:23.613 --> 00:56:27.820
比如，COVID建议你去尝试一下。

671
00:56:27.820 --> 00:56:29.228
但这是完全可选的。

672
00:56:29.228 --> 00:56:34.993
我总是会参考GitHub回购，以确保您正在使用最新的水龙头和测试网。

673
00:56:34.993 --> 00:56:41.271
如果我们回头看以太扫描，我们实际上可以看到更多关于刚刚发生的事情的细节。

674
00:56:41.339 --> 00:56:45.540
到底发生了什么，我们的超面具是怎么得到0的余额的。

675
00:56:45.540 --> 00:56:45.840
1容易的。

676
00:56:45.840 --> 00:56:50.355
突然之间?如果我们向下看事务部分，我们可以

677
00:56:50.355 --> 00:56:55.086
看到这里有一个事务，某个地址给我们发送了0。

678
00:56:55.086 --> 00:56:55.641
1醚。

679
00:56:55.641 --> 00:57:03.409
如果我们单击事务散列，我们可以看到关于这个事务实际发生的更多细节。

680
00:57:03.409 --> 00:57:12.135
现在，了解这个交易中发生了什么对于学习和成为一名智能合约开发人员或仅仅参与到生态系统中是至关重要的。

681
00:57:12.135 --> 00:57:16.278
我们来看看最上面的第一点是这个事务哈希。

682
00:57:16.343 --> 00:57:23.379
这是这个区块链或这个测试网的唯一标识符，它标识这个确切的事务。

683
00:57:23.379 --> 00:57:27.078
此事务散列标识发送0。

684
00:57:27.078 --> 00:57:34.297
看到我们的地址，我们可以看到这个交易的状态是成功的，它没有中断。

685
00:57:34.345 --> 00:57:41.560
无论如何，我们可以看到交易所在的区块号我们会讲到区块，我们可

686
00:57:41.560 --> 00:57:48.775
以看到时间戳当然是交易发生的时间，我们可以看到它来自哪个账户

687
00:57:48.775 --> 00:57:56.474
如果我们继续，打开一个新选项卡，我们可以看到这是交易来自的账户。

688
00:57:56.474 --> 00:57:58.228
它有300万以太。

689
00:57:58.228 --> 00:58:00.804
当然，这是假的林基醚。

690
00:58:00.804 --> 00:58:06.048
所以这并不重要，我们都能看到是给谁的，也就是我们自己。

691
00:58:06.048 --> 00:58:11.451
这是我们的钱包地址0x106x，等等，等等，cero

692
00:58:11.451 --> 00:58:17.478
x1066，等等，等等，对了，这笔交易的价值，当然是0。

693
00:58:17.478 --> 00:58:17.929
1醚。

694
00:58:17.929 --> 00:58:22.188
那么我们看到的这些值是什么?很明显，这个值是0。

695
00:58:22.188 --> 00:58:23.695
1，因为这是我们发送的模式。

696
00:58:23.695 --> 00:58:25.482
但是我们看到这个交易费用。

697
00:58:25.482 --> 00:58:30.249
在这个天然气价格，我们悬停在工具提示，我们可以看到，如果

698
00:58:30.249 --> 00:58:35.017
你放大你的以太扫描，你可以看到支付给矿工处理交易的金额。

699
00:58:35.017 --> 00:58:42.023
我们看到一个天然气价格，这是每单位天然气的成本，具体为交易，以太和灰色。

700
00:58:42.023 --> 00:58:45.844
天然气价格越高，被纳入区块的几率就越高。

701
00:58:45.844 --> 00:58:51.902
现在，如果我们再往下滚动，点击“查看更多”，我们还可以在这里看到很多其他信息。

702
00:58:51.902 --> 00:58:56.209
现在我们只需要点击看更少的东西，只关注这两个。

703
00:58:56.209 --> 00:59:01.210
我将在后面的部分中解释所有这些。

704
00:59:01.353 --> 00:59:05.708
我们先来谈谈交易费用和汽油的概念。

705
00:59:05.708 --> 00:59:12.711
还记得我说过区块链是由所有这些不同的节点运行的吗所有这些不同的节点运行区块

706
00:59:12.711 --> 00:59:19.714
链因为它们实际上从这些区块链上发生的所有交易中获得了报酬每当你进行交易时，

707
00:59:19.714 --> 00:59:26.717
就会有一个节点或矿工或验证者运行区块链软件的人会得到一丁点Aetheriu

708
00:59:26.717 --> 00:59:34.291
m或polygon或任何你运行的区块链，他们会从本地的区块链货币中得到一点报酬。

709
00:59:34.357 --> 00:59:38.920
这种支付显然是为了激励人们继续运行节点，他们计算你支付了多

710
00:59:38.920 --> 00:59:43.641
少钱，节点操作员得到了多少报酬，这是基于你使用了多少天然气。

711
00:59:43.641 --> 00:59:46.565
这就是气体的概念。

712
00:59:46.565 --> 00:59:49.691
气体是一种计算计量单位。

713
00:59:49.691 --> 00:59:54.703
交易使用的计算量越多，你需要支付的汽油就越多。

714
00:59:54.703 --> 00:59:58.326
例如，我们会快速点击更多。

715
00:59:58.326 --> 01:00:04.408
我们可以看到这部分写着A气体限制和气体使用情况，在这个交易中

716
01:00:04.408 --> 01:00:10.693
有60,000单位的气体限制，而实际使用的是21,000单位。

717
01:00:10.693 --> 01:00:15.138
这个交易用了21单位气体。

718
01:00:15.361 --> 01:00:20.581
对于像发送以太这样非常简单的事情来说，单位气体通常非常便宜。

719
01:00:20.581 --> 01:00:26.104
但也许对于更复杂的事情，比如铸造非ft，向一些违反合同的银行

720
01:00:26.104 --> 01:00:31.813
存款，等等，这些可能会消耗更多的汽油，因为它们的计算成本更高。

721
01:00:31.813 --> 01:00:34.632
这现在有点让人困惑，不要太担心。

722
01:00:34.632 --> 01:00:36.608
但要知道，我们这里用了21000汽油。

723
01:00:36.608 --> 01:00:43.449
如果我们拿出计算器21000汽油乘以这个价格，

724
01:00:43.449 --> 01:00:49.697
乘以价格，我们得到和交易费完全一样的结果。

725
01:00:49.697 --> 01:00:55.042
汽油价格乘以你用了多少汽油，就是交易费。

726
01:00:55.042 --> 01:00:58.459
不管是谁给我们这个0。

727
01:00:58.459 --> 01:01:01.271
1以太，也支付0。

728
01:01:01.271 --> 01:01:05.917
0000525，等等来进行此交易。

729
01:01:05.917 --> 01:01:11.604
每个区块链都有不同的方法来计算气体的工作原理。

730
01:01:11.604 --> 01:01:14.128
这基本上就是它的高水平了。

731
01:01:14.128 --> 01:01:17.142
我们现在只关注总交易费。

732
01:01:17.142 --> 01:01:19.262
当然还有汽油价格。

733
01:01:19.367 --> 01:01:24.899
在我们讲完区块链的工作原理后，我会解释什么是燃烧，煤气费和其他的东西。

734
01:01:24.899 --> 01:01:31.816
现在，只要知道任何时候你在链上进行交易，你必须支付一点我称之为交易气的东西。

735
01:01:31.816 --> 01:01:37.920
例如，如果我们到Metamask，这里有两个账户，第一个账户是0。

736
01:01:37.920 --> 01:01:41.742
1，林基，第二个账户是零。

737
01:01:41.742 --> 01:01:42.453
里格比。

738
01:01:42.453 --> 01:01:44.826
如果我输入0。

739
01:01:44.826 --> 01:01:46.641
05林基·伊思。

740
01:01:46.641 --> 01:01:53.079
从这个账户到另一个账户，你觉得我还剩多少钱?让我们试

741
01:01:53.079 --> 01:01:59.518
一下，这将是你实际创建的第一个交易你将为它花费汽油。

742
01:01:59.518 --> 01:02:03.320
点击发送，我们会点击账户间转账。

743
01:02:03.371 --> 01:02:06.731
数到二，0。

744
01:02:07.372 --> 01:02:08.235
接下来，

745
01:02:08.235 --> 01:02:23.560
我们可以在这里看到一些信息关于Metamask有一些新的高级气体UI和设置，我们也会打开歌曲，所以继续点击启用增强气体UI，打开它，然后返回。

746
01:02:23.560 --> 01:02:26.596
这还是实验选项卡。

747
01:02:26.596 --> 01:02:28.729
但它也可以在“常规设置”选项卡中。

748
01:02:28.729 --> 01:02:32.324
取决于你什么时候运行这个，我们能在这里看到一个小通知。

749
01:02:32.374 --> 01:02:35.324
同样，这取决于我们使用的Metamask的版本。

750
01:02:35.375 --> 01:02:40.812
我们看到这个小的下拉框上面写着，这是你实际可以支付的一些不同类型的汽油费用。

751
01:02:40.812 --> 01:02:47.991
汽油费用可能会改变的原因，正如你在这里看到的，根据区块链的繁忙程度，你必须支付更多的汽油。

752
01:02:47.991 --> 01:02:56.043
如果很多人都在发送事务，这意味着没有足够的空间让每个人的事务通过。

753
01:02:56.043 --> 01:02:58.672
这对正在发生的事情有点过于简单化了。

754
01:02:58.672 --> 01:03:00.049
但现在不用太担心。

755
01:03:00.049 --> 01:03:01.777
现在，如果我们想发送0。

756
01:03:01.777 --> 01:03:10.711
第二个账户是0ether，我们可以看到这个气体估计部分，它表示估计，我们将支付0。

757
01:03:10.711 --> 01:03:15.445
00004792气体除了发送0。

758
01:03:15.445 --> 01:03:15.845
5容易的。

759
01:03:15.845 --> 01:03:18.911
所以在底部，我们有金额加上汽油费。

760
01:03:18.911 --> 01:03:24.379
这将是我们在这笔交易上花费的总金额0。

761
01:03:24.379 --> 01:03:25.979
我们发送的是05。

762
01:03:25.979 --> 01:03:28.094
还有这个气体部分。

763
01:03:28.094 --> 01:03:34.312
我们继续确认，我们现在看到里格比以太扫描中有一个待处理的事务。

764
01:03:34.381 --> 01:03:39.300
如果我们点击它，我们甚至能在block Explorer上点击视图。

765
01:03:39.381 --> 01:03:44.504
Rigby交易哈希会弹出根据你点击它的时间，它可能会显

766
01:03:44.504 --> 01:03:49.818
示索引，这意味着以太扫描已经接收到你的交易并试图放置它。

767
01:03:49.818 --> 01:03:53.858
如果您在这里没有看到任何东西，这意味着可能交易还没有完成。

768
01:03:53.858 --> 01:03:55.592
也许你需要再等一会儿。

769
01:03:55.592 --> 01:04:00.683
或者您可能需要回到GitHub回购并选择推荐的遗嘱和水龙头。

770
01:04:00.683 --> 01:04:04.544
你可能需要等一分钟左右，让这个完成索引。

771
01:04:04.544 --> 01:04:08.112
大约一分钟后，我们可以看到这个事务确实已经通过了。

772
01:04:08.112 --> 01:04:13.465
我们可以看到很多和上一题相同的信息，这次是0。

773
01:04:13.465 --> 01:04:14.120
05年醚。

774
01:04:14.120 --> 01:04:20.079
现在如果我们看元掩码，我们会看到账户1有0。

775
01:04:20.079 --> 01:04:24.489
它四舍五入了一点，我们点击大按钮，我们可以看到它实际上是0。

776
01:04:24.489 --> 01:04:25.626
049953年,等等。

777
01:04:25.626 --> 01:04:31.089
而另一个账户账户2正好是0。

778
01:04:31.089 --> 01:04:31.245
05.

779
01:04:31.245 --> 01:04:37.387
这是因为我们花了一些Aetherium在gas上来发送这个交易。

780
01:04:37.387 --> 01:04:42.753
现在，有了这一点信息，您就知道了如何与使用区块链的应

781
01:04:42.753 --> 01:04:48.120
用程序进行实际交互，如何发送事务以及许多非技术细节。

782
01:04:48.120 --> 01:04:51.888
这里有一些非常令人兴奋的东西，仅仅是这一点信息。

783
01:04:51.888 --> 01:04:56.188
你现在知道了如何与区块链和以太坊协议交互。

784
01:04:56.188 --> 01:05:04.478
所以如果你不想学习如何编码任何东西，你可以去如果你可以开始与Aetherium交互和与协议交互同样多的信息。

785
01:05:04.478 --> 01:05:07.898
然而，我知道你们大多数人是来学习如何编程的。

786
01:05:07.898 --> 01:05:09.675
让我们来看看Aetherium的内部结构。

787
01:05:09.675 --> 01:05:14.123
这些交易实际上发生了什么，这些气体和这些区块链是什么。

788
01:05:14.123 --> 01:05:18.373
我们来学习一下区块链的基本原理。

789
01:05:18.373 --> 01:05:23.845
现在，如果你想直接进入编码，直接从描述中获取时间戳。

790
01:05:23.845 --> 01:05:29.292
然而，确切了解区块链是如何工作的将使您成为一个非常强大的开发人员。

791
01:05:29.392 --> 01:05:31.958
我们先来看看这个。

792
01:05:33.393 --> 01:05:36.344
在这个网站上观看区块链的演示。

793
01:05:36.393 --> 01:05:42.468
现在，这个网站的创建者有一个精彩的视频和区块链一对一的精彩介绍，就在他们的网站上。

794
01:05:42.468 --> 01:05:47.699
所以如果你在寻找另一种解释，一定要看看他的视频，它绝对非常棒。

795
01:05:47.699 --> 01:05:54.216
但我们真正需要做的第一件事是为了理解区块链或者任何东西，以及这里的所有工作

796
01:05:54.216 --> 01:06:00.733
首先需要理解Sha 256，散列，或者一般的散列，让我们先理解什么是散列。

797
01:06:00.733 --> 01:06:05.513
哈希是一个唯一的固定长度的字符串，用于标识任何数据

798
01:06:05.513 --> 01:06:10.486
片段，它们是通过将一些数据片段放入哈希函数来创建的。

799
01:06:10.486 --> 01:06:14.646
在本例中，使用的哈希算法是Sha 256。

800
01:06:14.646 --> 01:06:18.793
以太坊实际上用的是这个哈希算法，

801
01:06:18.793 --> 01:06:24.238
不是Sha 256，而是Sha家族的一种。

802
01:06:24.238 --> 01:06:27.259
但这只是另一种哈希的方法。

803
01:06:27.259 --> 01:06:30.669
具体的哈希算法并不重要。

804
01:06:30.669 --> 01:06:35.697
所以在这个例子中，你只增加到6，但你可以想象它和以太一样。

805
01:06:35.697 --> 01:06:38.657
哈希，它们会得到一个不同的哈希值。

806
01:06:38.657 --> 01:06:44.668
这个应用程序中会发生的是不管我们把什么数据或信息

807
01:06:44.668 --> 01:06:50.931
放入这个数据区，你可以看到下面这个散列会发生变化。

808
01:06:50.931 --> 01:06:57.682
这些数据通过sha256哈希算法进行运算。

809
01:06:57.682 --> 01:07:00.671
它输出的是这个唯一的哈希值。

810
01:07:00.671 --> 01:07:07.214
这个散列是一个唯一的固定长度的字符串，它会像一个空白的数据块一样识别出来。

811
01:07:07.214 --> 01:07:14.741
如果我输入我的名字，比如帕特里克·柯林斯，这就是代表帕特里克·柯林斯的哈希值。

812
01:07:14.741 --> 01:07:19.774
你可以看到，即使我在这里放了很多很多

813
01:07:19.774 --> 01:07:24.807
的数据，字符串的长度不会改变，对吧。

814
01:07:24.807 --> 01:07:33.081
它总是一样的，我们几乎可以放入任何数量的数据，数据的最大大小有一个上限。

815
01:07:33.081 --> 01:07:37.262
但出于所有的目的，我们几乎可以在这里放入任何长度。

816
01:07:37.262 --> 01:07:45.127
你会注意到每次我输入Patrick Collins的时候，这个散列总是这个7e5d，对吧?我要删除，

817
01:07:45.127 --> 01:07:54.567
我要用Patrick Collins，再说一次，你是75b总是这个，这个唯一哈希总是唯一的，它总是这个固定长度的字符串。

818
01:07:54.567 --> 01:08:01.341
现在我们可以把这个想法放在这里，我们可以继续这个块的概念。

819
01:08:01.407 --> 01:08:07.740
有了这个块的概念，我们将对这个哈希进行完全相同的处理这个数据部分，但不是

820
01:08:07.740 --> 01:08:14.249
所有东西都在这里，这个单一的数据区域，我们将把这些数据分成块，修女和数据。

821
01:08:14.249 --> 01:08:18.704
所以我们要做的是我们实际上要哈希这三个来得到这个哈希

822
01:08:18.704 --> 01:08:23.331
值，我们要把这三个都放进去，我们会说这三个都是组合的。

823
01:08:23.331 --> 01:08:28.715
我们要把这三个都放到这个哈希算法里来求。

824
01:08:28.715 --> 01:08:37.568
如果我在这里输入一堆东西，我们可以看到block 1和nonce，你知道，这个nonce，和这个数据，我们会得到这个散列。

825
01:08:37.568 --> 01:08:42.773
你可以看到，屏幕变成了红色，这个方块变成了红色。

826
01:08:42.773 --> 01:08:50.037
现在，当我按下这个思维键会发生什么?当我按下这个思维键时，它会花一些时间，它会思考一会儿。

827
01:08:50.037 --> 01:08:57.068
我们可以看到这里的nonce实际上改变了，对吧?现在和以前不一样了。

828
01:08:57.068 --> 01:09:00.363
这个哈希值从4个0开始。

829
01:09:00.363 --> 01:09:02.758
好，然后后面变成绿色。

830
01:09:02.758 --> 01:09:10.066
当我们谈论挖矿的时候，我们谈论的是矿工要解决一些非常困难的问题需要花费大

831
01:09:10.066 --> 01:09:17.374
量的时间在这个例子中，矿工要解决的问题是他们必须找到一个nonce，或者

832
01:09:17.374 --> 01:09:25.088
在这个nonce部分找到一个值当在第一块用这个数据哈希时，它会从4个0开始。

833
01:09:25.088 --> 01:09:30.035
所以矿工们要解决的问题就是从4个0开始他们要做到这一点的唯一方法

834
01:09:30.035 --> 01:09:35.137
就是用蛮力，你知道，尝试一些东西所以他们尝试了一个好吧，一个没用。

835
01:09:35.137 --> 01:09:37.842
好吧，两个，不，两个没用。

836
01:09:37.842 --> 01:09:40.623
好的，5，它是从0开始的，但不是4。

837
01:09:40.623 --> 01:09:45.335
他们必须不断地尝试所有这些数字，直到他

838
01:09:45.335 --> 01:09:50.297
们到达这个数字，让我们再次点击我的数字。

839
01:09:50.418 --> 01:09:53.660
它开始的时候顶部有4个0。

840
01:09:54.419 --> 01:09:56.619
具体的问题将区块链变为区块链。

841
01:09:56.619 --> 01:10:04.274
Aetherium对矿工来说有不同的问题要解决，比特币和你的问题是不同的，但这个概念是一样的。

842
01:10:04.274 --> 01:10:12.338
所以他们必须把它，一个区块将是这个，这个概念将是所有这些数据，它将是区块号。

843
01:10:12.338 --> 01:10:14.813
就在这个瞬间，对吧。

844
01:10:14.813 --> 01:10:21.339
所以这个nonce就是解就是他们用来得到这个问题的解的数

845
01:10:21.339 --> 01:10:27.866
字，对吧?如果我去到这里，你知道，我再做一次，点击我的。

846
01:10:27.866 --> 01:10:31.453
nonces变了，对吧?从1到33128。

847
01:10:31.453 --> 01:10:37.358
因为这是允许哈希以4个0开始的nonce。

848
01:10:37.358 --> 01:10:39.858
这就是正在发生的事情。

849
01:10:39.858 --> 01:10:44.992
当区块链矿工在采矿时，他们要经历一个计算非常密集

850
01:10:44.992 --> 01:10:50.127
的过程，试图找到一个能满足任何问题的nonce。

851
01:10:50.127 --> 01:10:51.336
实际上就是这样。

852
01:10:51.336 --> 01:10:51.967
这是一个方块。

853
01:10:51.967 --> 01:10:53.958
这就是矿工们开采时所发生的事情。

854
01:10:53.958 --> 01:10:58.817
他们只是在看，试错，用蛮力试图找到这个坚果现在我们知

855
01:10:58.817 --> 01:11:03.863
道了什么是区块，让我们进入下一步，弄清楚什么是区块链。

856
01:11:03.863 --> 01:11:09.296
这里我们有一个区块链的例子。

857
01:11:09.296 --> 01:11:14.458
好的，我们有一个组合，你知道，我们在后面的方块部分，我们有一个方块的样子。

858
01:11:14.458 --> 01:11:19.427
现在这里，我们有多个不同的块，对吧，每一个都代表一个不同的块，

859
01:11:19.427 --> 01:11:24.077
但是我们在这里有一个额外的列，我们在这里有一个额外的变量。

860
01:11:24.077 --> 01:11:30.721
就像之前一样，我们有block nonce和data，对吧，我们有block nonce data，

861
01:11:30.721 --> 01:11:37.100
我们还有这个东西叫做previous right，这实际上会指向上一个block的上一个哈希值。

862
01:11:37.100 --> 01:11:42.203
例如，如果我们到区块链的最后一个块，它说前008。

863
01:11:42.203 --> 01:11:46.085
如果我们看第4块的哈希值，是00008。

864
01:11:46.085 --> 01:11:52.302
然后我们看它的前一个它是4个0,b9，我们有4个0,B,

865
01:11:52.302 --> 01:11:58.743
9，以此类推，一直到第一个方块，它的前一个都是0，对吧。

866
01:11:58.743 --> 01:12:03.535
所以前面全是0的那块，就叫做创世纪块。

867
01:12:03.535 --> 01:12:11.532
你可能听说过在创世块之前，区块链中的第一个块是之前的哈希点指向一个实际上并不存在的哈希。

868
01:12:11.532 --> 01:12:19.152
现在，你可以想象，和这个块的工作原理差不多，块螺母和日期都要经过哈希算法在区

869
01:12:19.152 --> 01:12:26.772
块链中，块nonce数据，以及之前的哈希都要经过这个哈希算法来计算哈希值?如

870
01:12:26.772 --> 01:12:34.593
果我们到这里，比如说，如果我输入Patrick，很明显，这就不再有效了，对吧?

871
01:12:34.593 --> 01:12:42.015
因为这个修女和之前哈希中的数据块结合起来，并不能解决一开始有4个0的问题。

872
01:12:42.015 --> 01:12:43.418
所以我要去把它修好。

873
01:12:43.418 --> 01:12:46.608
这是一种很容易看出它被破坏的方式。

874
01:12:46.608 --> 01:12:54.519
但是，让我们看一下，如果我破坏了这个块，就在这里，如果我破坏了这里的数据，如果

875
01:12:54.519 --> 01:13:02.430
我像帕特里克一样在这里，你可以看到这两个现在都被读取了，这两个现在都无效了，对

876
01:13:02.430 --> 01:13:10.341
吧?因为带nonce哈希的块哈希加上新数据，也就是我的名字，帕特里克已经用前一

877
01:13:10.341 --> 01:13:18.455
个块哈希了现在是一个全新的哈希，这个块仍然指向这个前一个哈希，指向这个前一个块。

878
01:13:18.455 --> 01:13:26.209
现在它是错误的，它是混乱的，现在它是疯狂的，之前的哈希也是错误的。

879
01:13:26.209 --> 01:13:33.526
对吧?这就是为什么我们说区块链是不可变的，这就是为什么它是不可变的，对吧?

880
01:13:33.526 --> 01:13:40.844
因为我返回并修改了任何东西，如果我在这里输入了a，整个区块链现在就无效了。

881
01:13:40.844 --> 01:13:46.171
因为这些都不再有nonc来解这个方程了。

882
01:13:46.171 --> 01:13:53.356
这就是为什么区块链是不可变的，因为任何时候你改变了一件事，你就会破坏其余

883
01:13:53.356 --> 01:14:00.541
的区块链，明白吗?尽管如此，如果它本来在这里，我们可以继续挖掘这些，挖掘

884
01:14:00.541 --> 01:14:07.927
所有这些但你可以看到，这将开始变得计算非常昂贵，因为我必须重做整个区块链。

885
01:14:07.927 --> 01:14:15.206
你走得越远，就越难，你知道，重新哈希和重做所有这些不同的区块链。

886
01:14:15.206 --> 01:14:20.462
这很有道理，对吧?我们有这个区块链，要改变过去的东西真的很难，但如果我们要改变，我们可以直接提醒它。

887
01:14:20.462 --> 01:14:27.287
如果我是控制区块链的人，对吧，如果我是控制这个的人，你知道，我想改变什么，过去会，好吧，很好。

888
01:14:27.287 --> 01:14:29.429
我要做的就是改变这里的状态。

889
01:14:29.429 --> 01:14:34.298
然后你知道，我的每一个，你知道，显然，这将是非常昂

890
01:14:34.298 --> 01:14:39.362
贵的计算，但这是我可以做对的如果我是区块链的拥有者。

891
01:14:39.447 --> 01:14:46.666
现在，这就是去中心化的本质或者说分布式的本质让它变得非常强大的地方。

892
01:14:46.666 --> 01:14:51.544
我们要转到分布式标签，它也被称为去中心化标签，

893
01:14:51.544 --> 01:14:56.635
它会向我们展示去中心化方式下的区块链是什么样的。

894
01:14:56.635 --> 01:15:04.285
我们有完全相同的初始设置我们要发射一个区块链，我们有第一个区块链，它和这里的一模一样。

895
01:15:04.285 --> 01:15:10.119
但我们也不止一次地有peer, peer beam和PRC当人们在谈论peer to

896
01:15:10.119 --> 01:15:16.093
peer，通过交谈进行的peer to peer交易时，这就是他们谈论的概念，对吧。

897
01:15:16.093 --> 01:15:23.764
所以我们有许多运行区块链技术的不同的对等体，它们的权重都是相等的，对吧，每一个这些

898
01:15:23.764 --> 01:15:31.435
对等体或每一个这些节点，每一个运行区块链的实体都和其他人拥有完全相同的权力，对吧。

899
01:15:31.435 --> 01:15:38.894
所以我们很容易可以告诉这区块链是正确的,或者哪些是正确的,或通过观察

900
01:15:38.894 --> 01:15:46.353
这个目的,散列在这里,正确的,或通过观察我们的区块链,因为,记住,因

901
01:15:46.353 --> 01:15:53.812
为,记住这一点,这个散列在这最后一块,将包含所有的街区,对吧,因为最

902
01:15:53.812 --> 01:16:01.713
后一个散列将前面的散列,包括以前的散列在这里,这个哈希包含了之前的哈希。

903
01:16:01.713 --> 01:16:09.692
最后这个哈希包含了这里的所有东西?我们可以看一下Piercey的哈希，它是4个0，然后

904
01:16:09.692 --> 01:16:17.857
是e4b，我们可以看最新的哈希B，它是4个0,E代表B，然后纯A，它是4个0,E代表B。

905
01:16:17.857 --> 01:16:25.907
所以所有这些对等点，所有这些节点，所有这些去中心化的，你知道这些独立的，所有这些运行区块链

906
01:16:25.907 --> 01:16:33.958
软件的独立用户，他们都是匹配的，他们的节点很容易看到彼此然后说，嗨，很好，我们都是匹配的。

907
01:16:33.958 --> 01:16:38.614
现在，我们假设a决定，你知道，在区块链上发生了

908
01:16:38.614 --> 01:16:43.271
一些他们不喜欢的事情，他们想回去改变一些东西。

909
01:16:43.271 --> 01:16:47.913
假设它们在这里改变了，很明显，它们其余的区块链无效。

910
01:16:47.913 --> 01:16:51.364
他们必须花费大量的计算能力来追赶速度。

911
01:16:51.364 --> 01:16:52.853
所以让我们继续幽默一下吧。

912
01:16:52.853 --> 01:16:55.362
假设他们做了，他们最终赶上了。

913
01:16:55.461 --> 01:16:58.138
他们最终赶上了，你知道，他们最终挖掘了所有东西。

914
01:16:58.138 --> 01:17:00.646
现在他们有一个有效的区块链。

915
01:17:00.646 --> 01:17:03.018
对吧?它解了方程。

916
01:17:03.018 --> 01:17:03.673
太棒了。

917
01:17:03.673 --> 01:17:08.530
然而，在三号街区，有了新发现，对吧?这是这里，

918
01:17:08.530 --> 01:17:13.388
它不应该在这里，这是Peer A自己放进去的。

919
01:17:13.388 --> 01:17:18.800
现在所发生的就是我们观察所有运行软件的区块

920
01:17:18.800 --> 01:17:24.213
链，我们观察所有的哈希和第5个区块的哈希。

921
01:17:24.213 --> 01:17:26.225
纯A有新的哈希值。

922
01:17:26.225 --> 01:17:28.225
这是公元前09年。

923
01:17:28.225 --> 01:17:33.992
但是纯B有不同的哈希00 e代表B，对吧?那么谁是对的呢?它会

924
01:17:33.992 --> 01:17:39.947
随着他们的新东西消失吗?还是纯B?这就是去中心化数据的用武之地。

925
01:17:39.947 --> 01:17:43.542
因为我们可以看看皮尔西皮尔西，也叫E forby。

926
01:17:43.542 --> 01:17:50.385
所以如果你是皮尔斯会说，嘿，你错了，滚出去，对的。

927
01:17:50.466 --> 01:17:56.458
纯A将不再能够参与挖矿奖励因为他们已经分叉了区块链并开始

928
01:17:56.458 --> 01:18:02.450
了他们自己的区块链就在他们自己的历史中，因为他们是唯一拥

929
01:18:02.450 --> 01:18:08.657
有这块数据的，这块数据在区块3中，而纯B和纯C什么都没有。

930
01:18:08.657 --> 01:18:13.207
这就说明了为什么在这些区块链世界中在这个去中心化的世界中，真的没

931
01:18:13.207 --> 01:18:17.900
有一个中心化的实体，你知道，纯A，你知道，可能有恶意的动机去改变。

932
01:18:17.900 --> 01:18:22.591
你知道，这是3号街区，然而，民主规则，对吧，在区块链中多

933
01:18:22.591 --> 01:18:27.282
数规则，纯vmpfc会说，嘿，你知道，这很可爱，都是泥。

934
01:18:27.282 --> 01:18:29.531
但你错了，对吧?这不对。

935
01:18:29.531 --> 01:18:35.246
现在，这可能有点抽象，你只是看着数据，你知道，在这里输入随机的东西，然后想，好吧，是

936
01:18:35.246 --> 01:18:40.962
的，那是数据，对吧?这是有道理的，你知道，只是随机的字符串在这里对我们没有任何帮助。

937
01:18:40.962 --> 01:18:46.709
如果我们到这里的令牌部分，这才是真正开始有意义的地方。

938
01:18:46.709 --> 01:18:51.222
我们在纯a纯B皮尔西有完全相同的设置。

939
01:18:51.222 --> 01:18:57.211
不同之处在于，我们没有这个数据部分，而是有这个TX

940
01:18:57.211 --> 01:19:04.878
this事务部分?这代表了这个区块中发生的所有交易，对吧?所以我

941
01:19:04.878 --> 01:19:12.067
所以我们从达西寄25美元到彬格莱，或者说寄彬格莱一共是27美分。

942
01:19:12.067 --> 01:19:13.004
1922,对吧。

943
01:19:13.004 --> 01:19:15.087
这是完全一样的。

944
01:19:15.087 --> 01:19:21.114
所有这些事务都将以和数据相同的方式进行哈希。

945
01:19:21.114 --> 01:19:27.440
这就是它如此强大的原因，因为，你知道，如果我想恶意，如果，如果我想说，嘿，

946
01:19:27.440 --> 01:19:33.426
我真的想从伊丽莎白那里给简更多的钱，所以我是泥，我回去把它换成100。

947
01:19:33.476 --> 01:19:38.030
现在，你知道，不仅我的整个区块链会失效因为那是

948
01:19:38.030 --> 01:19:42.784
很久很久以前的事了，而且我不会匹配任何其他的链。

949
01:19:42.784 --> 01:19:47.123
对吧?所以我的区块链将被整体区块链排除在外。

950
01:19:47.123 --> 01:19:49.768
那么，让我们继续来修正这个。

951
01:19:49.768 --> 01:19:57.885
这是一样的，如果在这里如果我变得恶意，我想送你知道，我想让奥黛丽小姐的钱少一些。

952
01:19:57.885 --> 01:20:04.223
也许我想送1美元，他们想的是一样的，这

953
01:20:04.223 --> 01:20:10.896
个哈希现在这个2,1不匹配BBA的哈希。

954
01:20:10.896 --> 01:20:13.917
而且跟皮尔斯的工商管理学位也不匹配。

955
01:20:13.917 --> 01:20:20.904
所以他们两个会说，嘿，你的区块链无效，它不符合多数，你知道，你出局了，对吧。

956
01:20:20.904 --> 01:20:25.732
这就是这些区块链在低水平上的工作方式。

957
01:20:25.732 --> 01:20:31.181
这一切都回到了这个，理解这个哈希思想，并以这种非常复杂的

958
01:20:31.181 --> 01:20:36.631
方式使用它，以某种密码学的方式证明，你知道，东西在哪里。

959
01:20:36.631 --> 01:20:44.073
现在，区块链的工作方式是，它不是随机的东西，放在状态部分，它实际上是在这里寻

960
01:20:44.073 --> 01:20:51.516
找与链上不同区块和不同协议交互的方法，或者，如我们之前所说，不同的智能合约。

961
01:20:51.516 --> 01:20:59.089
现在，你可能会问的下一个问题是，好吧，我怎么知道我怎么确定我就是那个人?

962
01:20:59.089 --> 01:21:06.243
比方说，我是达西，对吧?我怎么能确定是我是达西真的把钱寄到这里来了。

963
01:21:06.243 --> 01:21:08.866
我们怎么知道达西寄了25美元。

964
01:21:08.866 --> 01:21:14.293
彬格莱先生?这就是我们讨论私钥和公钥的地方。

965
01:21:14.293 --> 01:21:16.605
这就是我们要研究的。

966
01:21:16.605 --> 01:21:16.808
现在。

967
01:21:16.808 --> 01:21:19.701
让我们快速回顾一下本节所学的内容。

968
01:21:19.701 --> 01:21:25.091
到目前为止，对吧?我们已经了解到Aetherium实际上运行在这个点击检查256。

969
01:21:25.091 --> 01:21:26.165
但是我们使用Sha 256。

970
01:21:26.165 --> 01:21:28.100
对于这个演示，这并不重要。

971
01:21:28.100 --> 01:21:31.677
我们只是在讨论哈希算法。

972
01:21:31.677 --> 01:21:38.258
哈希是一个唯一的固定长度的字符串，用来标识任何数据。

973
01:21:38.258 --> 01:21:42.832
哈希算法或哈希函数是将任何类型的

974
01:21:42.832 --> 01:21:47.406
数据计算为唯一哈希的函数或算法。

975
01:21:47.490 --> 01:21:51.783
挖掘将是找到区块链问题解决方案的过程。

976
01:21:51.783 --> 01:21:56.200
在我们的例子中，问题是找到一个以4个0开头的散列。

977
01:21:56.200 --> 01:21:58.552
节点通过挖掘不同的区块获得报酬。

978
01:21:58.552 --> 01:22:04.017
问题是不同的区块链和区块链是一个块区块链基本上是块，

979
01:22:04.017 --> 01:22:09.904
nonce事务和之前的哈希的组合为这个块创建唯一的哈希。

980
01:22:09.904 --> 01:22:15.282
这取决于区块链实现，它可能有两个其他字段或不同的字段。

981
01:22:15.282 --> 01:22:22.893
区块链是去中心化和分布式的，因为许多独立用户将运行这个区块链软件。

982
01:22:22.893 --> 01:22:27.401
他们会检查，然后我们会互相比较，看看哪些区块链

983
01:22:27.401 --> 01:22:32.107
是诚实的，哪些是恶意的，在区块链世界多数规则中。

984
01:22:32.107 --> 01:22:37.608
这里的nonce是用来得到这个散列的答案或数字。

985
01:22:37.608 --> 01:22:41.850
现在nonce是一个超负荷的术语，它实际上被用于许多不同的原因。

986
01:22:41.850 --> 01:22:47.860
在这种情况下，我们用它来解决在停止或散列处得到4或5个0的问题。

987
01:22:47.860 --> 01:22:56.349
然而，在Aetherium中，它也经常被用作来自给定地址的交易数量。

988
01:22:56.497 --> 01:23:03.068
现在我们来讨论一下签名这些交易和私钥以及其他一些密码学内容?因为在区块链演示

989
01:23:03.068 --> 01:23:09.639
中，我们可以看到所有这些奇妙的交易，对吧?这一切都过去了，可我们怎么知道是达

990
01:23:09.639 --> 01:23:16.212
西干的呢?是谁送的25美元?bangli吗?对吧?我们怎么知道那真的发生了。

991
01:23:16.212 --> 01:23:21.208
这就是我们刚刚在测试网中学到的所有东西，在我们

992
01:23:21.208 --> 01:23:26.423
的元掩码账户中真正开始，在这里一点点变得有活力。

993
01:23:26.423 --> 01:23:35.270
这里我们有一个关于公钥和私钥的例子，在顶部，我们有这个私钥，这是随机生成的。

994
01:23:35.270 --> 01:23:42.422
私钥是你想要保密的密钥，因为你会用它作为你所有交

995
01:23:42.422 --> 01:23:49.872
易的秘密密码我可以任意选择任何私钥，任何我想要的。

996
01:23:49.872 --> 01:23:55.519
有了它，这个算法，或者说他们会用Aetherium的算法。

997
01:23:55.519 --> 01:24:02.957
比特币，它们都使用椭圆曲线，数字签名算法，这是数字签名算法的一个变体。

998
01:24:02.957 --> 01:24:09.186
它会创建这个这个公钥，我真的不打算深入研究这个数字签名算法。

999
01:24:09.186 --> 01:24:17.685
但是要知道，它确实使用了一些，一些我们刚学过的哈希知识结合了一些其他的东西来得到这个公数。

1000
01:24:17.685 --> 01:24:19.279
所以我不会讲得太深。

1001
01:24:19.279 --> 01:24:22.117
但我们有这个我们创建的私钥。

1002
01:24:22.117 --> 01:24:23.880
我们得到这个公钥。

1003
01:24:23.880 --> 01:24:30.269
我们希望每个人都能访问这个公钥，是的，全世界都能看到这个，这个

1004
01:24:30.269 --> 01:24:36.658
私钥，我们希望它是私有的，我们不希望人们看到这个，我们将把这个

1005
01:24:36.658 --> 01:24:43.460
私钥当做密码，对交易进行数字签名，然后人们可以用这个公钥进行验证。

1006
01:24:43.460 --> 01:24:45.589
让我们看看这到底是什么样子的。

1007
01:24:45.589 --> 01:24:51.333
我们随便选一个，更安全的，对吧?因为时间越长，就越安全。

1008
01:24:51.333 --> 01:24:58.975
如果我们现在去签名，对吧?假设我们有这个，我们想要的信息，对吧?我们会说嗨，世界，

1009
01:24:58.975 --> 01:25:06.617
对吧?我们希望这是消息，我们创建的私钥，可以用来签署数据，对吧?记得在区块链的演示

1010
01:25:06.617 --> 01:25:14.447
中，我们是我们是在哈希东西，对吧?我们用这个Shea 256哈希值来得到这个哈希值。

1011
01:25:14.510 --> 01:25:16.260
我们正在做类似的事情。

1012
01:25:17.511 --> 01:25:21.953
我们正在使用这个数字签名算法来创建这个消息签名。

1013
01:25:21.953 --> 01:25:28.769
这个算法的真正强大之处在于，你可以用你的私钥创建这

1014
01:25:28.769 --> 01:25:35.858
个消息签名，但是其他人不能从消息签名中获得你的私钥。

1015
01:25:35.858 --> 01:25:38.431
这就是它的强大之处。

1016
01:25:38.431 --> 01:25:44.598
但是，如果我们用这个公钥进行验证，那么这是这是那个，哦，403。

1017
01:25:44.598 --> 01:25:52.920
这是相同的公钥，使用这个，使用这个公钥，任何人都可以验证，让我们再次签

1018
01:25:52.920 --> 01:26:01.243
名，任何人都可以验证签名是你的，对吧?你有一个公钥一个专属于你的私钥。

1019
01:26:01.243 --> 01:26:05.328
所以你可以签署东西和公钥，任何人都可以验证一些东西。

1020
01:26:05.328 --> 01:26:12.695
任何人都可以验证这个，假设有人想从你这里伪造一笔交易，他们说，嘿，你知

1021
01:26:12.695 --> 01:26:20.062
道，这是这是这是他们的交易，他们所要做的就是验证这个签名与你的公钥是否

1022
01:26:20.062 --> 01:26:27.851
一致很容易，整个东西变成红色，因为它没有被验证，对，算法说，嘿，这是错的。

1023
01:26:27.851 --> 01:26:32.763
我们可以用同样的方式把它引入到事务中。

1024
01:26:32.763 --> 01:26:38.821
所以如果我想汇款，你知道，如果我想汇款400美元，

1025
01:26:38.821 --> 01:26:45.123
从我的地址到另一个地址，用我的私钥，我可以签署交易。

1026
01:26:45.123 --> 01:26:49.770
世界上的任何人都可以验证这笔交易。

1027
01:26:49.770 --> 01:26:56.551
这就是为什么当人们说九头蛇的钥匙，你知道，保护你的钥匙，这就是我们在我们的帐户中谈论的。

1028
01:26:56.551 --> 01:27:04.811
对吧?如果我们进入设置，我给你们看我的肺炎和私钥的唯一原因是因为这是一个，

1029
01:27:04.811 --> 01:27:13.072
这是一个垃圾箱账户，我会在这集视频结束时把它扔掉，或者我不会往里面放真钱。

1030
01:27:13.072 --> 01:27:21.476
但当我们看Metamask，这里，我们有这个肺炎短语，它允许我们很容易地得到这

1031
01:27:21.476 --> 01:27:30.097
些不同的私钥，对吧?所以肺炎短语加上，你知道的，随便什么账号就能给我们一个私钥。

1032
01:27:30.097 --> 01:27:33.524
记住短语和1的组合，我们会得到这个私钥。

1033
01:27:33.524 --> 01:27:40.388
这是我们查看账户细节时，导出私钥。

1034
01:27:40.525 --> 01:27:47.491
这就是它确认的地方，这将是我们用来签署交易的私钥，如果其他人获得了

1035
01:27:47.491 --> 01:27:54.458
这个私钥的访问权，他们就可以为我们签署交易，也可以为我们发送交易。

1036
01:27:54.526 --> 01:27:58.717
这就是为什么我们想要保持这些隐私，这样它就能以完全相同的方式工作。

1037
01:27:58.717 --> 01:28:05.039
这就是为什么隐藏你的私钥和助记法很重要现在，

1038
01:28:05.039 --> 01:28:12.511
你的Aetherium地址实际上是你的公钥的一部分。

1039
01:28:12.511 --> 01:28:17.679
现在，要在Aetherium中获取我们的地址，我们所要做的就是获取我们用私钥创建

1040
01:28:17.679 --> 01:28:22.977
的公钥，使用相同的Aetherium哈希算法对其进行哈希，然后获取最后20个字节。

1041
01:28:22.977 --> 01:28:27.400
这就是我们如何推导到我们的地址。

1042
01:28:27.400 --> 01:28:35.453
现在，知道如何获得地址的确切方法并不重要，因为它可以将区块链变为区块链，甚至也可以改变区块链。

1043
01:28:35.453 --> 01:28:44.170
但这基本上就是这些地址的衍生方式或者说公钥的衍生方式，因为公钥是公共的。

1044
01:28:44.170 --> 01:28:49.969
使用公钥和任何公开方式都没问题，但私钥不行。

1045
01:28:49.969 --> 01:28:52.008
这就是我们签署事务的方式。

1046
01:28:52.008 --> 01:28:54.549
但是请注意，这不是我们发送事务的方式。

1047
01:28:54.549 --> 01:29:01.495
这只是分配给它创建一个事务来发送，我们稍后会学习如何发送这些事务。

1048
01:29:01.495 --> 01:29:01.680
酷。

1049
01:29:01.680 --> 01:29:03.888
所以那里也有很多信息。

1050
01:29:03.888 --> 01:29:10.907
让我们快速回顾一下，你的公钥是通过在你的私钥上使用数字签名算法得到的，

1051
01:29:10.907 --> 01:29:17.727
对吧，你想要一直保持你的私钥是私有的，因为你要用你的私钥来签署交易。

1052
01:29:17.727 --> 01:29:22.298
使用您的私钥对事务进行签名时，您是唯一能够实际

1053
01:29:22.298 --> 01:29:26.869
执行此操作的人，因为您无法从消息签名获得私钥。

1054
01:29:26.869 --> 01:29:31.537
然而，使用你的公钥，你可以任何人都可以很容易

1055
01:29:31.537 --> 01:29:36.418
地验证你签署的签名实际上是你在元掩码中签署的。

1056
01:29:36.418 --> 01:29:44.198
我们的私钥位于这个帐户详细信息部分，您只需点击显示私钥并输入您的密码。

1057
01:29:44.198 --> 01:29:46.334
你会在这里得到你的私钥。

1058
01:29:46.334 --> 01:29:51.841
这里需要注意的是，在使用私钥时，通常需要十六进制形式的私钥。

1059
01:29:51.841 --> 01:29:56.856
如果我们要用私钥，比如brownie，我们稍后会

1060
01:29:56.856 --> 01:30:01.872
讲到，我们需要在前面加上0x这个我们稍后会讲到。

1061
01:30:01.872 --> 01:30:05.289
你的账户地址就是由此而来的。

1062
01:30:05.289 --> 01:30:12.123
私钥可以创建公钥，公钥可以创建地址。

1063
01:30:12.123 --> 01:30:16.373
这里有一个小的或大的障碍。

1064
01:30:16.541 --> 01:30:21.963
因为你的私钥，你想保持私有而你

1065
01:30:21.963 --> 01:30:27.386
的公钥和地址都可以是公开信息。

1066
01:30:27.542 --> 01:30:34.304
现在我们对这些区块链的底层发生了什么有了更多的了解，让我们回到我们的交易，再看看这个天

1067
01:30:34.304 --> 01:30:41.067
然气的事情，我们将看看这里实际发生了什么，特别是天然气，可能有点棘手，让你的头脑理解。

1068
01:30:41.067 --> 01:30:43.393
所以如果你不能马上得到它，也不要担心。

1069
01:30:43.393 --> 01:30:46.246
当我们看例子的时候，它会变得更有意义。

1070
01:30:46.246 --> 01:30:52.705
在我讲之前，我们先来看交易费竞价，它是与运行交易相关的成本。

1071
01:30:52.705 --> 01:30:59.891
如果我在以太扫描上滚动这个，我可以看到这个东西，说的是区块基础费每气加最大派对费每气乘以气的

1072
01:30:59.891 --> 01:31:07.234
使用量，这可能有点令人困惑，让我们实际分解Aetherium上的情况，ERP 15, 5 9。

1073
01:31:07.234 --> 01:31:11.831
再次强调，这是特定于Aetherium的，因为每个区块链可能会有一点不同。

1074
01:31:11.831 --> 01:31:17.415
但如果我们点击查看更多，我们可以看到一些有用的值，我们可以看到气体上限是21,000。

1075
01:31:17.415 --> 01:31:19.382
使用量是21,000。

1076
01:31:19.382 --> 01:31:26.455
这个交易用了21,000汽油，我们也送了21,000汽油。

1077
01:31:26.548 --> 01:31:29.976
有时在发送事务时，这取决于它是何时发送的。

1078
01:31:29.976 --> 01:31:35.695
根据具体的说明，它可能会比你想要的消耗更多的气体。

1079
01:31:35.695 --> 01:31:40.194
在你的交易中，你可以设置一个限制，嘿，我不

1080
01:31:40.194 --> 01:31:44.909
想用超过x的气体，我不想用超过x的计算单位。

1081
01:31:44.909 --> 01:31:47.411
事实上，我们去了我们的Metamask。

1082
01:31:47.411 --> 01:31:52.736
然后我们点击发送再次在账户之间转账，然后我们选择0。

1083
01:31:52.736 --> 01:32:00.416
01 eath，或者下一步可以点击这个小按钮，进入高级，我们可以编辑这个交易的一些细

1084
01:32:00.416 --> 01:32:08.278
节，其中一个是气体限制，我们可以将这个气体限制修改为2200 2300，或更多或更少，

1085
01:32:08.278 --> 01:32:15.776
因为发送Aetherium需要21000 gas Metamask默认设置为这个。

1086
01:32:15.776 --> 01:32:20.937
我们还看到了其他有趣的东西，我们看到了优先费，和最大基础费。

1087
01:32:20.937 --> 01:32:23.244
让我们拒绝这笔交易。

1088
01:32:23.244 --> 01:32:26.626
让我们回顾一下以太扫描来讨论这些。

1089
01:32:26.626 --> 01:32:31.177
所以目前在Aetherium中，根据EE IP 1559,

1090
01:32:31.177 --> 01:32:35.729
Aetherium上的每笔交易都有一个叫做基础费的东西。

1091
01:32:35.729 --> 01:32:40.490
这是您需要设置的最低汽油价格，以包括您的交易。

1092
01:32:40.555 --> 01:32:44.037
你会注意到这些都是以网关来定价的。

1093
01:32:44.037 --> 01:32:48.046
那么什么是网关呢?如果我们来到网站eath转换器。

1094
01:32:48.046 --> 01:32:48.209
com。

1095
01:32:48.209 --> 01:32:55.121
同样，在GitHub存储库中有一个链接，我们向下滚动，可以看到

1096
01:32:55.121 --> 01:33:02.033
路网关和以太5把一个以太放在这里，我可以看到一个以太有多少路。

1097
01:33:02.033 --> 01:33:06.786
从方式上来说，一个以太等于1-234-567-8990。

1098
01:33:06.786 --> 01:33:13.891
所以这是这是10亿路就是一个以太。

1099
01:33:13.891 --> 01:33:22.203
然后1-234-567-8910 1112 1314做了16 7,8队，然后18零就走了。

1100
01:33:22.203 --> 01:33:28.140
这些都是指非常非常少量的Aetherium的更简单的方法。

1101
01:33:28.140 --> 01:33:32.463
看看汽油费，基本费用是0。

1102
01:33:32.463 --> 01:33:34.269
00000004走开。

1103
01:33:34.269 --> 01:33:41.544
如果以重量为单位这个数字显然会更小。

1104
01:33:41.544 --> 01:33:49.148
如果我们取这个数，把它输入计算器，我们可以看到它等于40的重量或0。

1105
01:33:49.148 --> 01:33:52.193
0000，以太的一堆零。

1106
01:33:52.193 --> 01:33:58.681
这里的最高费用是指我们愿意为这笔交易支付的最高汽油费。

1107
01:33:58.681 --> 01:34:06.218
你可以看到我们的最高费用比我们最终支付的稍微高一些。

1108
01:34:06.218 --> 01:34:07.459
最大值是2。

1109
01:34:07.459 --> 01:34:12.236
2132什么的，我们实际支付的汽油价格在这里。

1110
01:34:12.236 --> 01:34:17.617
现在你的交易可能会有一点不同另外我们有一个最高优先费。

1111
01:34:17.617 --> 01:34:22.898
这将是我们愿意支付的最大煤气费加上我们愿意给矿工的最大小费。

1112
01:34:22.898 --> 01:34:31.016
现在在以太币中，这个基本费用最终会被消耗掉，我们可以在以太币扫描上看到消耗掉的确切数量。

1113
01:34:31.016 --> 01:34:37.561
如果我们再打开计算器，我们可以取这个汽油费，乘以我们使用的汽

1114
01:34:37.561 --> 01:34:44.107
油量，我们可以看到这确实是我们最终燃烧的Aetherium。

1115
01:34:44.107 --> 01:34:49.873
我们回到以太坊转换器，把它粘贴进去，我们可以看到这两个数字确实是相等的。

1116
01:34:49.873 --> 01:34:58.568
这意味着无论何时你发送一笔交易，都有一小部分Aetherium将永远退出流通，或者被视为烧毁。

1117
01:34:58.568 --> 01:35:03.902
所以目前，理论上作为Aetherium的一部分你的交易费用的一部分实际上会被烧掉。

1118
01:35:03.902 --> 01:35:06.664
另外一部分直接给了矿工。

1119
01:35:06.664 --> 01:35:14.466
为了算出矿工得到了多少钱，我们可以用这个数字减去燃烧的量。

1120
01:35:14.570 --> 01:35:20.866
这是Etherium为这笔交易支付给Aetherium矿工的金额，你会在下面看

1121
01:35:20.866 --> 01:35:27.162
到你的交易类型到ERP 15 5 9，这是这些交易的eip 15 5 9版本。

1122
01:35:27.162 --> 01:35:31.772
就像我说的，每个区块链都有不同的燃烧费用和燃气过程。

1123
01:35:31.772 --> 01:35:39.798
它们都有一些不同，但其中一些是区块链有有限的区块空间进行交易，你的交易被包

1124
01:35:39.798 --> 01:35:47.824
含在这些区块中的天然气价格会根据需求的多少而变化，Aetherium的基础

1125
01:35:47.824 --> 01:35:56.284
天然气费会上下变化，取决于有多少人发送交易，以及有多少人想被包含在一个区块中。

1126
01:35:56.284 --> 01:35:59.643
如果大量的人想要被包含在一个区块中。

1127
01:35:59.643 --> 01:36:02.952
这意味着大量的天然气将会被燃烧。

1128
01:36:02.952 --> 01:36:09.310
我们在GitHub存储库中留下了一个视频链接，该视频来自一位youtube用

1129
01:36:09.310 --> 01:36:15.836
户，他出色地分解了EIP 15、5、9以及更多关于气体模型实际如何工作的内容。

1130
01:36:15.836 --> 01:36:18.431
我强烈建议大家暂停这个视频，看看那个视频。

1131
01:36:18.431 --> 01:36:27.349
为了更好地理解，基本费用将通过编程算法进行调整，以尽量使所有区块的满率达到50%。

1132
01:36:27.349 --> 01:36:32.026
如果他们的客座率超过50%，这个基本费用就会自动上升。

1133
01:36:32.026 --> 01:36:35.721
如果入住率低于50%，基本费用就会下降。

1134
01:36:35.721 --> 01:36:39.110
这就是这个交易的基本原理。

1135
01:36:39.110 --> 01:36:40.141
这可能会让人有点困惑。

1136
01:36:40.141 --> 01:36:42.631
让我们快速回顾一下这里的内容。

1137
01:36:42.631 --> 01:36:48.257
有一个惟一的事务哈希，它惟一地标识这个事务。

1138
01:36:48.257 --> 01:36:54.451
在这个区块链上，我们可以看到状态，我们可以看到它被确认的区块号。

1139
01:36:54.451 --> 01:36:56.661
我们还想看一件事。

1140
01:36:56.661 --> 01:36:59.646
如果我们向上滚动，我们会看到块号和块确认。

1141
01:36:59.646 --> 01:37:02.924
这是被开采的区块数。

1142
01:37:02.924 --> 01:37:05.065
因为包含了这个块。

1143
01:37:05.065 --> 01:37:12.395
就像我们在区块链演示中看到的，区块链变得越长，它就越难被篡改，它通常越安全，你会看到

1144
01:37:12.395 --> 01:37:19.725
一些进程说他们只会在20个Block确认，30个Block确认或等等之后做一些事情。

1145
01:37:19.725 --> 01:37:26.044
他们等待这些块确认的原因是因为他们想要确保该事务实际上被包括在内。

1146
01:37:26.044 --> 01:37:31.023
我们可以看到我们的交易所在的区块以及所有与之

1147
01:37:31.023 --> 01:37:36.229
相关的交易，不同的气体使用量，气体限制等细节。

1148
01:37:36.229 --> 01:37:42.535
时间戳是事务发生的时间，我们可以看到从和到我们可以看到的值。

1149
01:37:42.535 --> 01:37:51.520
然后我们可以看到交易费用，我们在这里看到的是阻塞的基础费用每气体加上最大优先费用每气体乘以使用的气体。

1150
01:37:51.586 --> 01:38:00.378
下面是气体的详细信息，气体价格是每单位气体的成本，气体上限是我们在交易中愿意支

1151
01:38:00.378 --> 01:38:09.397
付的最大单位气体数量，使用量是我们实际得到的基本费用是每单位气体的基本网络费用。

1152
01:38:09.397 --> 01:38:16.808
所以每消耗一种汽油，最大汽油是我们愿意支付的最大汽油价格。

1153
01:38:16.808 --> 01:38:22.959
最高优先级是最高天然气价格，加上我们给矿工的小费，然后我们就能看到有多少被烧了。

1154
01:38:22.959 --> 01:38:31.056
然后我们看到交易储蓄，这是实际使用或支付的金额和返回的金额之间的差额。

1155
01:38:31.056 --> 01:38:38.066
例如，在这个交易中，我们最终选择的汽油价格比这里的最大汽油价格略低。

1156
01:38:38.066 --> 01:38:42.743
所以我们最终使用的汽油价格略低于这里的最大优先费。

1157
01:38:42.743 --> 01:38:49.342
相比之下，我们节省了一些，我们还可以看到这是一个ERP 15 59的交易，我

1158
01:38:49.342 --> 01:38:55.942
们可以看到这里的nonce，它不是0因为我展示的交易是我们的第一个none。

1159
01:38:55.942 --> 01:39:02.543
当然，我们还可以看到，发送Aetherium的交易的输入数据，输入数据是空白的。

1160
01:39:02.593 --> 01:39:06.528
但你会看到，当我们讲到智能合约时，输入数据不会是空的。

1161
01:39:06.528 --> 01:39:10.363
这将是这些交易最重要的特征之一。

1162
01:39:10.363 --> 01:39:13.117
您还会注意到，这里有一个状态选项卡。

1163
01:39:13.117 --> 01:39:19.184
这是一个高级选项卡，它显示了基于此事务更改的不同状态。

1164
01:39:19.184 --> 01:39:21.273
我们先忽略这个。

1165
01:39:21.273 --> 01:39:27.498
既然我们已经知道了区块链本身的工作原理，让我们来谈谈区块链的一些基本原理。

1166
01:39:27.498 --> 01:39:31.396
事实上，我们在之前的Freako夏令营视频中讨论过所有这些话题。

1167
01:39:31.396 --> 01:39:34.419
我们来看看这个。

1168
01:39:34.596 --> 01:39:39.449
如果你第一次听这个，有些概念似乎有点难以理解。

1169
01:39:39.449 --> 01:39:40.826
别担心。

1170
01:39:40.826 --> 01:39:47.580
随着课程的继续，当你在实际例子中看到它们时，它们会变得更有意义。

1171
01:39:47.580 --> 01:39:50.609
我绝对建议你回去重新看一看，

1172
01:39:50.609 --> 01:39:57.534
重新听一听那些你在GitHub库的讨论标签中没有得到问题的部分。

1173
01:39:57.534 --> 01:39:57.921
太棒了。

1174
01:39:57.921 --> 01:40:06.560
现在我们知道了所有的密码学部分以及所有区块链如何工作的细节，以及我们的签名是如何工作的以及所有东西是如何连接在一起的。

1175
01:40:06.600 --> 01:40:11.545
让我们来谈谈它是如何工作的，以及到底发生了什么。

1176
01:40:11.545 --> 01:40:19.156
对于很多这样的东西，每个不同的区块链都有稍微不同的算法和稍微不同的度量和标准来做很多这样的事情。

1177
01:40:19.156 --> 01:40:23.817
所以当我们讨论这些具体的实现时，请记住，确切的

1178
01:40:23.817 --> 01:40:28.478
算法可能会有一点不同，但概念仍然是完全相同的。

1179
01:40:28.478 --> 01:40:30.873
哈希和哈希函数是一样的。

1180
01:40:30.873 --> 01:40:39.553
不管你从哪里看去中心化区块链，它都是一样的不管你从哪里看，它是如何实现的，都有一点不同。

1181
01:40:39.603 --> 01:40:48.070
传统上，当你运行一个应用程序时，你会是一个连接到服务器的网站或其他东西，你会与一个集中的实体进行交互。

1182
01:40:48.070 --> 01:40:55.604
不像我们看到的区块链有多个不同的对等点，它将由一个集中的组运行。

1183
01:40:55.604 --> 01:41:01.738
现在，它仍然可以在许多不同的服务器上运行，但所有这些服务器仍将由相同

1184
01:41:01.738 --> 01:41:07.873
的集中式区块链组控制，就像我们看到的在不同独立节点的网络上运行一样。

1185
01:41:07.873 --> 01:41:09.908
当我们看到一个同行，一个同行，B·皮尔西。

1186
01:41:09.908 --> 01:41:16.556
这些是不同的独立用户在他们自己的节点上运行区块链技术的不同例子。

1187
01:41:16.556 --> 01:41:21.623
现在，当我使用节点这个术语时，我通常是指一个去中心化系统的单个实例。

1188
01:41:21.623 --> 01:41:27.092
当我说单个节点时，当我说区块链时，我指的是运行区块链软件的

1189
01:41:27.092 --> 01:41:32.561
纯a纯b纯C的一个节点，我指的是运行这项技术的一台服务器。

1190
01:41:32.561 --> 01:41:34.088
再说一次，就是这个网络。

1191
01:41:34.088 --> 01:41:39.085
正是这些节点相互作用的组合，创造了整个区块链。

1192
01:41:39.085 --> 01:41:42.436
让这些网络如此强大的是，任何人都可以加入这个网络。

1193
01:41:42.436 --> 01:41:49.943
这就是为什么要去中心化进入的障碍是一些硬件要求来获得正确的材料来运行软件。

1194
01:41:49.943 --> 01:41:53.150
然后你运行软件，任何人都可以加入这些网络并参与其中。

1195
01:41:53.150 --> 01:41:55.363
这就是它真正去中心化的原因。

1196
01:41:55.363 --> 01:42:00.226
事实上，你现在就可以到GitHub，并在几秒钟内运行你自己的Aetherium节点。

1197
01:42:00.226 --> 01:42:05.149
现在在传统世界中，应用程序由集中的实体运行。

1198
01:42:05.149 --> 01:42:09.798
如果这个实体倒闭了，或者被恶意贿赂了，或者他们想

1199
01:42:09.798 --> 01:42:14.448
要关闭，他们就是不能，因为他们是控制着一切的人。

1200
01:42:14.448 --> 01:42:17.709
相比之下，区块链就没有这个问题。

1201
01:42:17.709 --> 01:42:24.394
如果运行多个节点的一个节点或一个实体发生故障(因为有很多其他独立的节点在运

1202
01:42:24.394 --> 01:42:31.080
行，所以没关系)，只要至少有一个节点一直在运行，区块链和系统就会持续存在。

1203
01:42:31.080 --> 01:42:38.122
幸运的是，大多数最受欢迎的链，如比特币和以太坊，都有1000个或1000个节点。

1204
01:42:38.122 --> 01:42:45.801
正如我们在演示中所展示的，如果一个节点恶意操作，在某些系统中，所有其他节点都会忽略这个节点并将

1205
01:42:45.801 --> 01:42:53.480
其踢出，甚至惩罚它，因为它们可以很容易地检查其他节点并发现，好吧，这个节点与大多数节点不同步。

1206
01:42:53.480 --> 01:42:56.340
是的，当涉及到区块链时，多数决定一切。

1207
01:42:56.340 --> 01:43:02.729
每个区块链都有一个完整的列表记录了在区块链上发生的所有交易和交互我们知道如

1208
01:43:02.729 --> 01:43:09.118
果一个节点试图恶意操作，那么所有的哈希值都将不正常它们不会与其他节点匹配。

1209
01:43:09.118 --> 01:43:14.729
这赋予了区块链难以置信的强大的不可变特性，任何东西都无法改变或破坏。

1210
01:43:14.729 --> 01:43:19.070
所以本质上，我们可以把区块链看作一个去中心化的数据库。

1211
01:43:19.070 --> 01:43:25.848
对于Aetherium，它有一个额外的特性，它也可以以分散的方式进行计算。

1212
01:43:25.848 --> 01:43:30.987
现在让我们谈谈共识，工作证明和利益证明因为你们之前可能听过这些。

1213
01:43:30.987 --> 01:43:34.482
它们对区块链的实际工作方式非常重要。

1214
01:43:34.482 --> 01:43:38.058
我们通过了区块链的例子，我们做了挖掘特性。

1215
01:43:38.058 --> 01:43:40.446
这就是所谓的功的证明。

1216
01:43:40.446 --> 01:43:49.038
工作证明和牛排证明都属于共识这一范畴，而在区块链方面，共识是一个非常重要的话题。

1217
01:43:49.038 --> 01:43:57.675
共识被定义为一种机制，用于就国家或区块链的单一值达成协议，尤其是在去中心化系统中。

1218
01:43:57.675 --> 01:44:02.887
我在区块链的例子中简要地提到了这种共识机制，当我说，如果一个改

1219
01:44:02.887 --> 01:44:08.100
变是值得的，而其他两个不是，那么大多数人就会统治并把它踢出去。

1220
01:44:08.100 --> 01:44:10.303
这是共识机制的一部分。

1221
01:44:10.303 --> 01:44:18.636
一个区块链或分散系统中的共识协议大致可以被分解成两个部分，一个是链选择算法，一个是

1222
01:44:18.636 --> 01:44:26.970
内部阻力机制，就是我们正在做的挖掘部分，或者说功的证明算法就是所谓的内部阻力机制。

1223
01:44:26.970 --> 01:44:29.731
这是Aetherium和比特币目前使用的。

1224
01:44:29.731 --> 01:44:35.362
请注意，这取决于你看这段视频的时间，如果两个都出来了，那么它就不再是作品的证明。

1225
01:44:35.362 --> 01:44:43.938
现在,证明的工作被称为公民抵抗机制,因为它定义了一个方法找出块作者是谁,哪个节点

1226
01:44:43.938 --> 01:44:46.725
是节点工作我发现是谁干的,

1227
01:44:46.725 --> 01:45:01.306
是作者阻止所有其他节点可以验证它的准确的公民抵抗blockchains能力抵御用户创建大量的伪匿名身份获得不成比例的有利影响是在组系统。

1228
01:45:01.306 --> 01:45:09.329
通俗地说，这基本上是一个区块链的一种方式，以防止有人创建一堆假的区块链，以便他们可以获得越来越多的奖励。

1229
01:45:09.329 --> 01:45:13.257
现在，有两种类型的公民抵抗机制我们将在这里讨论。

1230
01:45:13.257 --> 01:45:15.864
即工作证明和权益证明。

1231
01:45:15.864 --> 01:45:19.800
让我们先更深入地谈谈功的证明，功的证明。

1232
01:45:19.800 --> 01:45:26.707
这是民事抵抗，因为单个节点必须经过一个非常昂贵的计算过程，称为挖矿，这是我们之前

1233
01:45:26.707 --> 01:45:33.615
演示过的，以找出区块链的答案，找到正确的nonce，或，或任何区块链系统已有的。

1234
01:45:33.615 --> 01:45:34.205
还有工作证明。

1235
01:45:34.205 --> 01:45:42.944
这是可行的，因为无论你创建了多少个伪匿名账户，每个账户都必须经历这个计算非常昂贵的活动来寻找功

1236
01:45:42.944 --> 01:45:51.683
的证明问题的答案，或者功的证明谜题的答案，在我们的演示中，它是找到一个有前四个零的nonce。

1237
01:45:51.683 --> 01:45:56.125
但同样的，每个区块链可能会改变谜题的工作或把问题改变得有点不同。

1238
01:45:56.125 --> 01:46:00.990
事实上，有些区块链故意让这个谜变得困难或容易，来改变

1239
01:46:00.990 --> 01:46:05.855
所谓的区块时间，区块时间是指区块发布之间的间隔时间。

1240
01:46:05.855 --> 01:46:08.769
它与这些算法的难度成正比。

1241
01:46:08.769 --> 01:46:11.127
所以这些问题是可以改变的。

1242
01:46:11.127 --> 01:46:13.763
这取决于他们想要区块链多长。

1243
01:46:13.763 --> 01:46:19.371
如果一个系统想把时间限制得非常非常长，他们只会让问题变得非常非常难。

1244
01:46:19.371 --> 01:46:22.721
如果他们想要非常短，他们会让问题变得容易很多。

1245
01:46:22.721 --> 01:46:25.922
我们会稍微讨论一下民事攻击以及它们如何影响系统。

1246
01:46:25.922 --> 01:46:31.971
但有了工作证明，这是一种可验证的方法，可以找出区块作者是谁，并进行民事抵抗。

1247
01:46:31.971 --> 01:46:35.948
现在，你需要把它和链式选择规则结合起来，形成共识。

1248
01:46:35.948 --> 01:46:42.232
现在，有一些共识协议有更多的特性，但非常非常粗略，这是我们将要看的两个部分。

1249
01:46:42.232 --> 01:46:45.278
第二部分是链式选择法则。

1250
01:46:45.278 --> 01:46:49.963
我们怎么知道哪个区块链是真正的区块链，哪个是真正的区块链在比特

1251
01:46:49.963 --> 01:46:54.801
币和Aetherium上，它们都使用一种叫做中本共识的共识形式。

1252
01:46:54.801 --> 01:47:01.076
这是功的证明和最长链式法则的结合，去中心化网络的那一边，

1253
01:47:01.076 --> 01:47:07.577
哪个区块链的链最长，或者上面的区块数最多就是他们使用的链。

1254
01:47:07.642 --> 01:47:14.575
这是很有意义的，因为每一个区块后面的链，它将需要越来越多的计算出来。

1255
01:47:14.575 --> 01:47:18.853
这就是为什么在我们的交易中，我们实际上看到了确认。

1256
01:47:18.853 --> 01:47:25.850
确认的数量是在我们的事务在一个块中通过后添加的额外块的数量。

1257
01:47:25.850 --> 01:47:33.263
所以如果我们看到确认，这意味着我们的交易所在的区块在最长的链中有两个区块在它前面。

1258
01:47:33.263 --> 01:47:37.597
现在，我想指出的是，很多人使用功的证明作为共识协议。

1259
01:47:37.597 --> 01:47:43.041
我想说的是，这有一点不准确，但有时人们会互换使用它。

1260
01:47:43.041 --> 01:47:48.373
工作量证明是整体共识协议的一部分，在比特币和以太坊中。

1261
01:47:48.373 --> 01:47:53.681
目前的一个例子是中本共识，中本共识是工作证

1262
01:47:53.681 --> 01:47:59.243
明和最长链式法则的结合，两者都非常非常重要。

1263
01:47:59.243 --> 01:48:04.863
功的证明还告诉我们这些交易费和区块奖励的去向记住，

1264
01:48:04.863 --> 01:48:10.035
当我们进行交易时，我们必须讨论天然气和交易费。

1265
01:48:10.035 --> 01:48:17.070
那么谁得到了报酬谁得到了这笔交易，这笔交易费将流向矿工或工作证明网络中

1266
01:48:17.070 --> 01:48:24.105
的验证者?他们被称为矿工在权益证明网络中，他们被称为验证者有一点不同。

1267
01:48:24.105 --> 01:48:27.665
当我们讲到功证明系统中的权益证明时我们会讲到这个。

1268
01:48:27.665 --> 01:48:32.486
所有这些节点都在相互竞争，以寻找区块链谜题的答案。

1269
01:48:32.486 --> 01:48:37.037
记住，在我们的例子中，它是要找到一个开头有4个0的散列。

1270
01:48:37.037 --> 01:48:41.962
同样，根据区块链的实现，这个谜语会有一点不同。

1271
01:48:41.962 --> 01:48:47.410
但所有的节点都在尽可能多地尝试先得到这个答案。

1272
01:48:47.410 --> 01:48:53.855
为什么?因为第一个算出区块链雷亚尔答案的节点将获得交易费，他们将从中获得报酬。

1273
01:48:53.855 --> 01:48:57.523
当一个节点得到报酬时，它们实际上是通过两种不同的方式得到报酬的。

1274
01:48:57.523 --> 01:48:59.555
一种是交易费。

1275
01:48:59.653 --> 01:49:01.986
另一块是方块奖励。

1276
01:49:02.653 --> 01:49:09.499
我们在交易中讨论过汽油价格或灰色交易?这是我们要支付给这些

1277
01:49:09.499 --> 01:49:16.583
区块链节点的交易费，这是区块链协议本身给这些节点的区块奖励。

1278
01:49:16.583 --> 01:49:21.809
你可能听说过比特币腰斩，腰斩指的是

1279
01:49:21.809 --> 01:49:27.036
区块奖励腰斩，大约每四年腰斩一次。

1280
01:49:27.036 --> 01:49:32.946
这个区块奖励增加了任何被奖励的加密货币的流通数量。

1281
01:49:32.946 --> 01:49:38.542
例如，在Aetherium中，区块奖励是提供Aetherium，而在比特币中，区块奖励是提供比特币。

1282
01:49:38.542 --> 01:49:44.532
所以这些节点相互竞争成为第一个找到交易的节点成为第一个

1283
01:49:44.532 --> 01:49:50.523
找到问题答案的节点，这样它们就能赢得区块奖励和交易费。

1284
01:49:50.523 --> 01:49:55.153
例如，像比特币这样的区块链有一个固定的时间，当它们

1285
01:49:55.153 --> 01:49:59.970
不再发放区块奖励时，矿工或节点只会从趋势中获得报酬。

1286
01:49:59.970 --> 01:50:00.756
操作费用。

1287
01:50:00.756 --> 01:50:05.506
这个油费，还是由初始交易的人支付。

1288
01:50:05.506 --> 01:50:12.126
当我们从水龙头取钱的时候，有一个服务器，另一个人为我们支付交易费用。

1289
01:50:12.126 --> 01:50:20.026
然而，当我们从一个帐户向另一个帐户发送以太币时，我们的第一个帐户实际上支付了一些交易费用来发送以太币。

1290
01:50:20.026 --> 01:50:21.105
为了证明牛排。

1291
01:50:21.105 --> 01:50:25.061
还有一笔汽油费，但这笔钱支付给了验证者，而不是矿工。

1292
01:50:25.061 --> 01:50:27.145
我们一会儿会讲到这个。

1293
01:50:27.145 --> 01:50:30.862
现在让我们谈谈在这些区块链世界中可能发生的两种类型的攻击。

1294
01:50:30.862 --> 01:50:33.317
我们先来谈谈西比尔袭击案。

1295
01:50:33.317 --> 01:50:39.292
Sybil攻击是指用户创建一大堆伪匿名账户，试图影响网络。

1296
01:50:39.292 --> 01:50:44.561
现在，很明显，在比特币和以太币上，这是非常非常困难的，因为用户需要做所

1297
01:50:44.561 --> 01:50:49.981
有这些工作来证明工作，或者有大量的抵押品和股份证明，我们再一次讨论一下。

1298
01:50:49.981 --> 01:50:53.949
另一种更普遍的攻击是51%攻击。

1299
01:50:53.949 --> 01:50:59.894
现在，正如我们看到的，作为我们共识协议的一部分，这些区块链将

1300
01:50:59.894 --> 01:51:06.038
同意最长的链是他们将要使用的链，只要它匹配网络其余51%的链。

1301
01:51:06.038 --> 01:51:11.233
这意味着如果你有最长的链，并且你有超过51%的网络剩余部分，

1302
01:51:11.233 --> 01:51:16.428
你可以在网络中做一个所谓的分叉，把网络带到你现在最长的链上。

1303
01:51:16.428 --> 01:51:21.873
显然，当单个节点或单个实体试图通过伪装成多个不同的

1304
01:51:21.873 --> 01:51:27.536
人来影响网络的正常运行，尽管他们只是同一个人或实体。

1305
01:51:27.536 --> 01:51:31.474
就像我说的，在功的证明和牛排的证明中很难做到。

1306
01:51:31.474 --> 01:51:40.378
所以你现在可以看到，区块链是非常民主的，哪个区块链有最多的购买量，是最长的区块链，整个系统将证实。

1307
01:51:40.378 --> 01:51:49.354
当节点产生一个新的块并添加到最长链中时，其他节点将遵循这个网络中其他节点都同意的最长链，将这些块添加到自己的链中并进行后续操作。

1308
01:51:49.354 --> 01:51:55.196
所以非常小的重组实际上是很常见的，当一个区块链从不同的最长链中选择一个区

1309
01:51:55.196 --> 01:52:01.202
块，把它放在上面，然后必须将它交换到另一个区块，然后继续使用不同的区块链。

1310
01:52:01.202 --> 01:52:05.776
然而，如果一组节点有足够的节点或足够的能量，它们基本上

1311
01:52:05.776 --> 01:52:10.350
可以占据网络的51%，并向它们想要的任何方向影响网络。

1312
01:52:10.350 --> 01:52:12.478
这就是所谓的51%攻击。

1313
01:52:12.478 --> 01:52:16.850
这种情况发生在以太坊这样的区块链上，而不是以太坊。

1314
01:52:16.850 --> 01:52:21.617
这就是为什么区块链越大，就越去中心化，越安全。

1315
01:52:21.673 --> 01:52:26.620
在你看完这个视频，成为一个区块链工程专家之后，我绝对建议你运

1316
01:52:26.620 --> 01:52:31.568
行一个节点，因为你将通过运行一个节点来提高整个网络的安全性。

1317
01:52:31.568 --> 01:52:39.068
因此，工作证明是了不起的，因为它使我们能够非常容易地抵御Sybil的攻击，并保持我们的区块链是去中心化和安全的。

1318
01:52:39.068 --> 01:52:41.625
然而，它也有一些缺点。

1319
01:52:41.625 --> 01:52:49.135
功的证明需要消耗大量的电力，因为每个节点都在以最快的速度运行，以赢得这场竞赛，获得奖励。

1320
01:52:49.135 --> 01:52:52.282
这显然会对环境造成影响。

1321
01:52:52.282 --> 01:52:58.169
自从“工作证明”和“中本共识”之后，许多其他的协议都采用了这个想法，朝着不

1322
01:52:58.169 --> 01:53:04.057
同的方向发展，采用了不同的民间抵抗协议，其中很多协议的目的都是要更加环保。

1323
01:53:04.057 --> 01:53:06.580
现在最流行的是股权证明。

1324
01:53:06.677 --> 01:53:11.978
有一些连锁店已经在使用这种权益证明协议，而且很活跃，很兴旺。

1325
01:53:11.978 --> 01:53:20.265
其中一些像雪崩，拉拉纳，Polygon, polka dot和Terra，另外Aetherium决定升级到eath。

1326
01:53:20.265 --> 01:53:26.632
第二，它也有权益证明算法，它还有一些其他的特征，我们稍后会讲到。

1327
01:53:26.680 --> 01:53:31.394
说句题外话，我们要学的所有工具在地球上都是有用的。

1328
01:53:31.394 --> 01:53:34.188
第二，这取决于你什么时候看，这里所有的都是有效的。

1329
01:53:34.188 --> 01:53:35.697
我们来谈谈权益证明。

1330
01:53:35.697 --> 01:53:38.618
这又是一种不同的民间抵抗机制。

1331
01:53:38.618 --> 01:53:43.869
权益节点的证明并没有解决这个难题，而是提供了一些他们将诚实行

1332
01:53:43.869 --> 01:53:49.297
事的抵押品，也就是说，他们以Aetherium为例进行了担保。

1333
01:53:49.297 --> 01:53:54.028
两个节点放置一些Aetherium作为赌注，表示它们将在网络中

1334
01:53:54.028 --> 01:53:58.913
诚实行事，如果它们在网络中行为不当，它们将被砍掉或删除一些牛排。

1335
01:53:58.913 --> 01:54:01.589
显然，这是一种非常好的民间抵抗机制。

1336
01:54:01.683 --> 01:54:08.250
因为如果你想创建一大堆匿名账户，那么每一个账户，你都需要投入一些资金。

1337
01:54:08.250 --> 01:54:13.636
如果你行为不端，你就有可能失去所有作为抵押品的钱。

1338
01:54:13.684 --> 01:54:20.547
在这个系统中，矿工实际上被称为验证器，因为他们不再绑定任何东西，他们实际上只是验证其他节点。

1339
01:54:20.547 --> 01:54:27.633
现在，不同于工作量证明，每个节点都在竞相成为第一个找到块的节点，利害关系证明

1340
01:54:27.633 --> 01:54:34.720
节点实际上是随机选择来提出新的块，然后其余的验证器将验证该节点是否提出了块。

1341
01:54:34.720 --> 01:54:43.014
老实说，就像我们在密码学课上看到的那样，其他节点通常很容易验证一个提议或交易是否诚实。

1342
01:54:43.014 --> 01:54:46.720
当我们谈论区块链时，随机性是一个非常重要的话题。

1343
01:54:46.720 --> 01:54:50.114
因为请记住，这些区块链是确定性系统。

1344
01:54:50.114 --> 01:54:52.988
他们是与世隔绝的围墙花园。

1345
01:54:52.988 --> 01:54:57.755
正如你们所知，根据定义，确定性系统不能有随机数。

1346
01:54:57.755 --> 01:55:04.061
那么我们如何选择系统中的随机验证器呢?当它从区块链变到区块链时，实际上选择节点

1347
01:55:04.061 --> 01:55:10.530
会把区块链变到区块链，但这两个，他们使用的是兰德怀疑，至少在最初的实现中是这样。

1348
01:55:10.530 --> 01:55:17.893
这是一个分散的自治组织，它共同选择随机数并共同选择哪个节点将运行。

1349
01:55:17.893 --> 01:55:22.585
接下来，我们不打算深入讨论这个问题，因为这很有可能在未来发生改变。

1350
01:55:22.585 --> 01:55:25.991
但我们在这门课后面会讲到随机解和区块链。

1351
01:55:25.991 --> 01:55:31.992
权益证明显然也有优点和缺点，优点是，这是一个很好的公民抵抗机制。

1352
01:55:31.992 --> 01:55:34.803
这是一个很好的方法来找出一个块的作者应该是谁。

1353
01:55:34.803 --> 01:55:39.909
另一个优点是计算出新块的计算成本更低，因为不是网

1354
01:55:39.909 --> 01:55:45.015
络上的每个节点都要做这个，只需要一个节点做这个。

1355
01:55:45.015 --> 01:55:48.145
然后剩下的节点只需要验证它。

1356
01:55:48.145 --> 01:55:55.134
缺点是，它通常被认为是一个不太分散的网络，因为它的前期参与成本。

1357
01:55:55.134 --> 01:56:00.456
现在，这就进入了一场哲学之争，关于如何去中心化才算足够的去中心化。

1358
01:56:00.456 --> 01:56:02.773
我认为这应该由社区来决定。

1359
01:56:02.773 --> 01:56:07.000
随着我们的进步，我想我们会越来越多地了解到去中心化是如何足够去中心化的。

1360
01:56:07.000 --> 01:56:14.264
不过，区块链工程师之间的普遍共识是，股权证明非常非常分散，非常安全。

1361
01:56:14.264 --> 01:56:19.646
这种大规模的环境影响改善是地球转向地球的两个主要原因之一。

1362
01:56:19.697 --> 01:56:21.911
第二，它减少了高达99%的环境影响。

1363
01:56:21.911 --> 01:56:26.397
现在，这些是工作量证明和权益证明的主要部分。

1364
01:56:26.397 --> 01:56:31.001
但我确实想谈谈另一个概念，它在这些生态系统中非常重要。

1365
01:56:31.001 --> 01:56:32.309
这就是可扩展性。

1366
01:56:32.309 --> 01:56:38.160
当我们讨论汽油价格时，我们说过如果很多人想要发送一个交易，汽油价格

1367
01:56:38.160 --> 01:56:44.190
会非常高，因为一个区块只有这么多的黑空间，节点只能添加这么多的音符。

1368
01:56:44.190 --> 01:56:48.604
所以当很多人想使用区块链时，汽油价格就会飙升。

1369
01:56:48.604 --> 01:56:57.278
这不是很有伸缩性，因为如果我们想把越来越多的人加入到这些区块链中，使用区块链的成本就会越来越高。

1370
01:56:57.278 --> 01:57:00.401
因为越来越多的人想要进入这些街区。

1371
01:57:00.401 --> 01:57:07.210
这意味着有多少人可以使用这个系统是有上限的，因为随着天然气价格的不断上涨，财政限制会强加给他们。

1372
01:57:07.210 --> 01:57:16.202
Aetherium也在通过转换为牛排证明来攻击工作证明对环境的影响，而且他们还在实施一种叫做分片的新方法。

1373
01:57:16.202 --> 01:57:23.878
而切分是可扩展性问题的解决方案，切分的区块链实际上只是意味着它将是区

1374
01:57:23.878 --> 01:57:31.780
块链的区块链，有一个主链，它将协调连接到这个主链上的多个链之间的一切。

1375
01:57:31.780 --> 01:57:38.390
这意味着有更多的链供人们进行交易有效地增加块空间的数量分片

1376
01:57:38.390 --> 01:57:45.000
可以大大增加区块链第一层的交易数量现在还有一个术语可能是你

1377
01:57:45.000 --> 01:57:51.838
第一次听到，第一层，我们将很快讨论第一层和第二层的可伸缩性。

1378
01:57:51.838 --> 01:57:55.722
第一层是指基础层区块链实现比特币，

1379
01:57:55.722 --> 01:58:03.948
第一层是Aetherium，第一层是雪崩，第一层是基础层区块链解决方案。

1380
01:58:03.948 --> 01:58:10.199
第二层是添加在区块链上的第二层之上的任何应用程序。

1381
01:58:10.199 --> 01:58:14.508
第二层的一些例子是链条套利，或者乐观主义。

1382
01:58:14.508 --> 01:58:21.209
套利和乐观主义非常有趣，因为它们是第二层，也希望解决可伸缩性问题。

1383
01:58:21.209 --> 01:58:25.730
套利和乐观就是所谓的卷升，他们把交易卷成一层，

1384
01:58:25.730 --> 01:58:32.219
就像Aetherium，我们不打算深入讲卷升以及它们是如何运作的。

1385
01:58:32.219 --> 01:58:40.578
但你真正需要知道的是，上卷有点像分片链，它们的安全性来自基础层来自第1层，就像Aetherium。

1386
01:58:40.578 --> 01:58:46.272
它们将事务批量发送到第一层，它们通过成为另一个区块链解决了一些可伸缩性

1387
01:58:46.272 --> 01:58:51.966
问题人们可以在上面进行事务，仍然是在这个基础的Aetherium层上。

1388
01:58:51.966 --> 01:58:53.949
它们和侧链不同。

1389
01:58:53.949 --> 01:59:01.024
因为侧链的安全性来自它们自己的协议，卷集，它们的安全性来自底层。

1390
01:59:01.024 --> 01:59:05.126
举例来说，套利和乐观主义将和Aetherium一样安全。

1391
01:59:05.126 --> 01:59:10.604
这里有一些很棒的家伙，他们更深入地研究了翻滚，我在描述中给你留了一个链接。

1392
01:59:10.604 --> 01:59:13.026
好了，我们刚刚谈了很多东西。

1393
01:59:13.026 --> 01:59:15.713
在继续之前，让我们快速回顾一下。

1394
01:59:15.713 --> 01:59:21.398
Aetherium和比特币目前都是遵循中本共识的工作量证明区块链，然而，

1395
01:59:21.398 --> 01:59:28.346
Aetherium正在转移到Aetherium 2，这将是股权分片的区块链的证明，由于工

1396
01:59:28.346 --> 01:59:34.979
，由于工作证明和牛排证明等协议，Sybil攻击被阻止了51%的攻击随着区块链的大小越来越难。

1397
01:59:34.979 --> 01:59:41.022
所以你应该运行一个节点共识机制，它允许区块链对区块链的

1398
01:59:41.022 --> 01:59:47.289
状态达成一致，分片和卷集是第一层可伸缩性问题的解决方案。

1399
01:59:47.289 --> 01:59:51.568
第一层是任何基于区块链的实现，如比特币或Aetherium。

1400
01:59:51.568 --> 01:59:57.468
区块链可伸缩性的一个问题是，对于想要进入其中的事务数量，总是没有足够的块空间。

1401
01:59:57.468 --> 02:00:04.628
这导致了非常高的汽油价格，再一次，汽油价格或与区块链互动的成本。

1402
02:00:04.719 --> 02:00:09.409
以上就是区块链的基础知识和区块链的解释。

1403
02:00:09.409 --> 02:00:16.769
有了这些信息，你现在就可以进入世界，开始与区块链打交道，并与区块链进行交互。

1404
02:00:16.769 --> 02:00:24.524
至少对发生的事情有一定程度的了解，你应该为自己能走到这一步而感到无比自豪。

1405
02:00:24.524 --> 02:00:29.221
一定要给自己一个表扬和一轮掌声。

1406
02:00:29.221 --> 02:00:34.932
现在我们已经掌握了很多基础知识和基本方法，让我们开始进入编码方面。

1407
02:00:34.932 --> 02:00:43.573
在这里，你将学习如何在这些区块链中构建智能合约，如何构建信任最小化协议。

1408
02:00:43.573 --> 02:00:45.373
并且在智能合约平台上。

1409
02:00:45.373 --> 02:00:51.902
下一节，稳定性基础，稳定性基础这一节将教给你所有的技能，让你

1410
02:00:51.902 --> 02:00:58.649
开始实际编写稳定性代码，并理解这些智能合约是如何在底层工作的。

1411
02:00:58.649 --> 02:01:05.157
所以在这一点上，绝对要给自己一个击掌，也许在GitHub的讨论中打招呼，也许在社区中打招呼，

1412
02:01:05.157 --> 02:01:12.797
在Twitter上，在Reddit上，等等，并为走到这一步感到自豪，旅程真的才刚刚开始，但你已经学到了很多。

1413
02:01:12.797 --> 02:01:14.868
让我们开始下一节。

1414
02:01:14.868 --> 02:01:19.516
让我们进入代码。

1415
02:01:19.727 --> 02:01:26.477
现在我们进入了编码部分，我需要强调绝对要使用与本课程相关的GitHub存储库。

1416
02:01:26.477 --> 02:01:32.540
如果你来到GitHub回购，向下滚动，点击我们正在上的课程，我们正在上第二课。

1417
02:01:32.540 --> 02:01:34.602
欢迎混音，简单收纳。

1418
02:01:34.602 --> 02:01:41.462
如果你点击它，它会给你大量的时间戳和其他与本课相关的有用链接。

1419
02:01:41.462 --> 02:01:47.499
此外，最大的一点是，所有的代码都将在课程标题的正下方可用。

1420
02:01:47.499 --> 02:01:54.697
这将包含我们将要使用的所有代码，以及关于如何使用这些代码的更多附加信息。

1421
02:01:54.697 --> 02:02:02.108
不过，在提问和参与讨论时，请提问和完整的区块链坚实性课程库。

1422
02:02:02.108 --> 02:02:02.485
谢谢你！

1423
02:02:02.485 --> 02:02:07.431
如果我们在资源库的顶部，向下滚动，我们有这部分的资源。

1424
02:02:07.431 --> 02:02:13.619
这就引出了GitHub讨论，你可以在本课程的GitHub讨论部分提问。

1425
02:02:13.619 --> 02:02:18.698
此外，在Stack Exchange、Aetherium或Stack Overflow上。

1426
02:02:18.698 --> 02:02:25.713
我会讲一点关于如何格式化问题和提问的最佳方式，这样你就有最高的机会在后面的课程中得到一个好的答案，

1427
02:02:25.713 --> 02:02:32.012
我强烈建议你暂停，现在就为Stack Exchange Aetherium, Stack

1428
02:02:32.012 --> 02:02:39.887
Overflow和GitHub创建帐户，如果你还没有，当然，可以在我们的GitHub存储库中找到它们的链接。

1429
02:02:39.887 --> 02:02:45.117
通常，对于每个编码部分，我将以快速概述我们将要使用的代码和

1430
02:02:45.117 --> 02:02:50.529
我们将要构建的内容作为开始，因为我们所做的一切都将基于项目。

1431
02:02:50.529 --> 02:02:51.671
这就是我们学习的方法。

1432
02:02:51.736 --> 02:02:58.323
对于我们的第一首和混音，我们会跳过它因为有很多东西要习惯。

1433
02:02:58.323 --> 02:03:00.805
现在，我强烈建议在我编写代码的时候。

1434
02:03:00.805 --> 02:03:06.112
当我在混音中做这些的时候，你们跟着我一起写代码。

1435
02:03:06.112 --> 02:03:09.885
记住，如果我编码太快或太慢，你可以改变我的速度。

1436
02:03:09.885 --> 02:03:12.238
首先，我们将跳到一个叫做remix的工具。

1437
02:03:12.238 --> 02:03:17.345
如果你不确定怎么做，在我们的GitHub知识库中有一个混合链接。

1438
02:03:17.345 --> 02:03:20.771
这是我们要写所有代码的地方。

1439
02:03:20.771 --> 02:03:25.148
欢迎来到混合IDE，或集成开发环境。

1440
02:03:25.148 --> 02:03:29.707
我们将在这里学习如何编写代码并与智能合约交互。

1441
02:03:29.707 --> 02:03:33.182
如果你愿意，你可以继续并接受帮助的混音。

1442
02:03:33.182 --> 02:03:40.062
如果你以前从未上过这门课，它会给你一个快速的回顾，一些混音的工具，我们现在会跳过它们。

1443
02:03:40.062 --> 02:03:41.874
因为我会解释所有上升的东西。

1444
02:03:41.874 --> 02:03:48.791
Remix是一个非常强大的工具，因为它有很多特性，可以让我们真正地看到并与智能合约进行交互。

1445
02:03:48.791 --> 02:03:53.542
最终，我们会离开混音，转向本地开发环境。

1446
02:03:53.542 --> 02:03:57.955
然而，混音对于学习固体的基本原理是非常棒的。

1447
02:03:57.955 --> 02:04:01.447
我强烈建议大家在开始的时候先从混音开始。

1448
02:04:01.447 --> 02:04:06.366
当你使用混合集成开发环境时，会有很多不同的东西向我们蹦出来。

1449
02:04:06.366 --> 02:04:08.310
还有很多不同的插件。

1450
02:04:08.310 --> 02:04:14.029
因为我们将使用坚固性，这将是我们用来开发智能合约的语言。

1451
02:04:14.029 --> 02:04:19.914
我们可以点击solididity插件开始，一些其他的工具会出现在旁边。

1452
02:04:19.914 --> 02:04:28.697
即使你不点击solididity插件，你仍然可以编写solididity智能合约，左手边是我们开始实际与事物交互的地方。

1453
02:04:28.697 --> 02:04:35.590
左上方最上方的按钮是我们的文件或探索目录，remix是

1454
02:04:35.590 --> 02:04:42.484
带有不同契约、不同脚本、不同测试和不同依赖关系的样板。

1455
02:04:42.484 --> 02:04:44.665
我们要把它最小化一点。

1456
02:04:44.665 --> 02:04:50.640
因此，如果你想继续，右键点击并删除除合同文件夹之外的其他文件夹，请随意。

1457
02:04:50.640 --> 02:04:54.663
或者如果你喜欢他们，也可以把他们留下。

1458
02:04:54.663 --> 02:05:02.099
我们会留下合约文件夹然后删除里面的不同文件这样我们就可以从头开始了。

1459
02:05:02.099 --> 02:05:08.132
大多数项目都带有自述文件。

1460
02:05:08.132 --> 02:05:09.536
通常是自述。

1461
02:05:09.536 --> 02:05:12.637
Md，它通常解释如何实际使用代码。

1462
02:05:12.637 --> 02:05:14.902
但为了我们的目的，我们要把这个也删掉。

1463
02:05:14.902 --> 02:05:16.184
你可以跟着我走。

1464
02:05:16.184 --> 02:05:22.877
现在我们有一个空白的混音设置，点击合同文件夹，点击小页面

1465
02:05:22.877 --> 02:05:29.571
图标创建一个新文件，一个小框会弹出，你可以开始输入文本。

1466
02:05:29.571 --> 02:05:36.887
我们会输入simple storage。Sol，。Sol告诉编译

1467
02:05:36.887 --> 02:05:44.203
器这将是一个固态文件，我们将用这个固态是智能合约的主要编码语言。

1468
02:05:44.203 --> 02:05:47.015
还有其他一些智能合约语言。

1469
02:05:47.015 --> 02:05:51.944
但到目前为止，稳固性是最主要的智能合约编码语言。

1470
02:05:51.944 --> 02:05:57.592
现在我们有了一个简单的存储。灵魂契约在右边我们可以开始用它来编码我们的固体。

1471
02:05:57.592 --> 02:05:59.915
让我们开始编码一些固体。

1472
02:05:59.915 --> 02:06:08.691
如果你点击文件按钮正下方的这个按钮它看起来像固体标志，你会看到一堆东西弹出在这里。

1473
02:06:08.756 --> 02:06:13.506
这些是我们编译固体性代码的不同参数，这样我们就可以运行它。

1474
02:06:13.506 --> 02:06:20.502
所以在任何可靠智能合约中，你首先需要的是你将要使用的可靠版本。

1475
02:06:20.502 --> 02:06:27.554
这应该总是在你的实体代码的顶部，实体是一种不断变化的语言，它会不断更新。

1476
02:06:27.554 --> 02:06:32.042
因为与其他语言相比，它相对较新，我们需要告诉我们的代码，嘿，

1477
02:06:32.042 --> 02:06:36.681
这是我想让你使用的版本，我们可以通过pragma添加固体版本。

1478
02:06:36.681 --> 02:06:37.373
坚固。

1479
02:06:37.373 --> 02:06:44.127
然后我们想用的版本，如果我们想选择一个非常具体的版本，我们可以说(0,8)

1480
02:06:44.127 --> 02:06:44.232
7.

1481
02:06:44.232 --> 02:06:48.232
到目前为止的最新版本是0。

1482
02:06:48.232 --> 02:06:48.337
8.

1483
02:06:48.760 --> 02:06:49.160
12点。

1484
02:06:51.760 --> 02:06:56.460
是很好的实践，不同版本的坚固性被认为比其他版本更稳定。

1485
02:06:56.460 --> 02:06:57.110
零点8。

1486
02:06:57.110 --> 02:07:00.357
7是被认为更稳定的版本之一。

1487
02:07:00.357 --> 02:07:05.129
这里的双斜杠被称为注释，在这些地方你可以输入一些实际上

1488
02:07:05.129 --> 02:07:10.079
不会被执行的东西不会被编译，不会被真正视为代码的一部分。

1489
02:07:10.079 --> 02:07:13.015
例如，我可以写Hello all。

1490
02:07:13.015 --> 02:07:13.967
我是帕特里克。

1491
02:07:13.967 --> 02:07:18.709
如果我们要运行这段代码，这部分代码会被完全忽略。

1492
02:07:18.709 --> 02:07:21.920
双反斜杠就是我们做注释的方式。

1493
02:07:21.920 --> 02:07:30.035
和我们的编码,我们建筑项目,一定要充分利用这个评论工具每次写一个新函数,或者你学的东

1494
02:07:30.035 --> 02:07:38.150
西你不懂,或者你学到了新的东西,你要记住,把它放在一个评论在你的代码中,你将是最有效

1495
02:07:38.150 --> 02:07:46.265
的记笔记在本课程中,通过他们的评论在你的代码,然后保存你的代码,这样你可以参考回来。

1496
02:07:46.265 --> 02:07:49.239
所以在代码中留下注释，在代码中留下注释。

1497
02:07:49.239 --> 02:07:54.104
当你以后想要引用它的时候这将是理解你在写什么的最好的方法之一。

1498
02:07:54.104 --> 02:08:01.488
现在当涉及到固体度的形式时，实际上有几种不同的写法，我们可以说我们只想用零点8。

1499
02:08:01.488 --> 02:08:01.569
7.

1500
02:08:01.569 --> 02:08:04.519
这就是我们的写法。

1501
02:08:04.767 --> 02:08:08.830
但是如果我们用一个比0。8更新版本的固体度，也许可以。

1502
02:08:08.830 --> 02:08:14.498
7告诉我们的代码我们可以接受更多的新版本，我们可以在这里放一个小插入。

1503
02:08:14.498 --> 02:08:16.816
这就是我们分辨固体的方法。

1504
02:08:16.816 --> 02:08:19.477
嘿，零点8的任何版本。

1505
02:08:19.477 --> 02:08:22.235
就这份合同而言，以上内容就可以了。

1506
02:08:22.235 --> 02:08:23.835
这意味着0,8。

1507
02:08:23.835 --> 02:08:25.821
等于0。

1508
02:08:25.821 --> 02:08:26.084
９ ０．

1509
02:08:26.084 --> 02:08:27.400
8点10点等等。

1510
02:08:27.400 --> 02:08:30.145
但如果我们想只用0。

1511
02:08:30.145 --> 02:08:36.489
17，我们可以这样输入如果我们想在特定范围内使用固体度版本，

1512
02:08:36.489 --> 02:08:42.623
我们可以这样做，我们可以说我们想要固体度版本大于或等于0。

1513
02:08:42.623 --> 02:08:45.377
但小于0,9。

1514
02:08:45.377 --> 02:08:45.475
0.

1515
02:08:45.771 --> 02:08:49.855
这意味着从0到8之间的任何编译器。

1516
02:08:50.772 --> 02:08:51.318
9点。

1517
02:08:51.318 --> 02:08:52.255
0可以。

1518
02:08:52.255 --> 02:08:54.130
这意味着0,8。

1519
02:08:54.130 --> 02:08:55.067
8行。

1520
02:08:55.772 --> 02:08:56.355
8点。

1521
02:08:56.355 --> 02:08:57.521
9可以等于0。

1522
02:08:57.521 --> 02:08:59.271
8点10就可以了。

1523
02:09:00.773 --> 02:09:00.865
9.

1524
02:09:00.865 --> 02:09:05.941
0不成立，因为它不是严格小于0。

1525
02:09:06.773 --> 02:09:07.281
00点9分。

1526
02:09:07.281 --> 02:09:08.349
1也不行。

1527
02:09:09.774 --> 02:09:12.274
我们用(0,8)

1528
02:09:12.274 --> 02:09:12.345
8.

1529
02:09:13.774 --> 02:09:21.936
完成的固体，每一个完成的部分都需要以分号结束这就是你告诉固体它是行结束的方式。

1530
02:09:21.936 --> 02:09:27.464
此外，在代码的顶部，您还需要放置所谓的spdx许可标识符。

1531
02:09:27.464 --> 02:09:32.490
这是可选的，但是一些编译器会标记你没有这样的警告。

1532
02:09:32.490 --> 02:09:35.617
这使得授权和共享代码更加容易。

1533
02:09:35.617 --> 02:09:41.987
本节课的GitHub知识库中有一个关于许可证如何工作的链

1534
02:09:41.987 --> 02:09:48.584
接来做spdx许可证标识符，我们就说spdx许可证标识符，

1535
02:09:48.584 --> 02:09:54.727
我们选择MIT, MIT许可证是限制最少的许可证之一。

1536
02:09:54.778 --> 02:10:01.504
我们的大部分代码样本都使用MIT许可一旦你有了一个版本一旦你写了这么

1537
02:10:01.504 --> 02:10:08.429
多，我们就可以继续写到编译器选项卡下拉，点击编译，这个小转折就会出现。

1538
02:10:08.429 --> 02:10:12.180
我们马上就会看到，这个契约正在被编译。

1539
02:10:12.180 --> 02:10:19.408
因为我们实际上没有合约，所以我们还没有看到合约被编译，但是我们看到编译器自动切换到零点8。

1540
02:10:19.408 --> 02:10:19.475
8.

1541
02:10:19.475 --> 02:10:24.931
编译我们的代码意味着把我们更容易读懂的代码，比如pragma,

1542
02:10:24.931 --> 02:10:31.443
solidity，并把它转换成计算机代码，或者非常具体的计算机使用指令。

1543
02:10:31.443 --> 02:10:37.485
我们将在后面的部分中讨论很多机器级代码或计算机级代码的作用。

1544
02:10:37.485 --> 02:10:42.021
如果你用的是Mac，你也可以点击S命令，它也会为你运行编译器。

1545
02:10:42.021 --> 02:10:47.449
在Windows上，它可能是Ctrl S，我们可以选择我们想要使用的编译器版本。

1546
02:10:47.449 --> 02:10:50.976
但是，如果我们在代码中指定使用0，点8。

1547
02:10:50.976 --> 02:10:55.646
8，我们点击编译按钮，它会自动切换到0点8。

1548
02:10:55.646 --> 02:10:55.697
8.

1549
02:10:55.697 --> 02:11:00.879
然而，如果我们用胡萝卜的东西，我们会明确地说，嘿，我们想要0。

1550
02:11:00.879 --> 02:11:06.191
8点10，我们可以点击编译，它会编译为0。

1551
02:11:06.191 --> 02:11:06.869
8点10。

1552
02:11:06.869 --> 02:11:15.703
因为，记住，胡萝卜说我们至少要用0，点8，一直到0的最新版本。

1553
02:11:15.703 --> 02:11:15.786
8.

1554
02:11:15.786 --> 02:11:18.369
现在让我们停留在(0,8)上。

1555
02:11:18.369 --> 02:11:18.452
8.

1556
02:11:18.787 --> 02:11:21.208
我们在代码中要做的下一件事是定义契约。

1557
02:11:21.208 --> 02:11:25.453
要获得全屏视图，你可以点击编译器按钮把它去掉。

1558
02:11:25.453 --> 02:11:28.684
要开始定义我们的合同，我们要写contract这个词。

1559
02:11:28.684 --> 02:11:34.479
这告诉稳固性下一段代码将是一个契约契约是稳固性中的一

1560
02:11:34.479 --> 02:11:40.498
个关键词，它告诉编译器这段代码的下一段将定义一个契约。

1561
02:11:40.498 --> 02:11:46.249
您可以将契约视为任何面向对象编程(如Java或JavaScript)中的类。

1562
02:11:46.249 --> 02:11:52.724
我们给契约起个名字，RS简单存储。

1563
02:11:52.724 --> 02:11:56.947
然后加上这个左右花括号。

1564
02:11:56.947 --> 02:12:02.130
左右花括号内的所有内容都是合约的内容。

1565
02:12:02.130 --> 02:12:02.933
简单的存储。

1566
02:12:02.933 --> 02:12:07.613
现在，如果我们继续，点击命令S或Ctrl S，我们可以看到这个绿色的小标记出现了。

1567
02:12:07.613 --> 02:12:14.949
如果您没有，您总是可以返回到编译器选项卡，向下滚动并点击Compile，看到小的绿色复选标记。

1568
02:12:14.949 --> 02:12:18.809
那个绿色的小标记意味着我们的代码编译成功了。

1569
02:12:18.809 --> 02:12:23.078
如果没有任何错误，我们可以假设现在就部署这个合同。

1570
02:12:23.078 --> 02:12:25.435
这将是一份有效的合同。

1571
02:12:25.435 --> 02:12:30.687
恭喜你写了第一份合同。

1572
02:12:30.794 --> 02:12:34.277
现在，实体性具有多个不同的类型或基本数据类型。

1573
02:12:34.277 --> 02:12:42.080
如果你去看稳定性文档，它在我们的GitHub仓库里，你可以读到更多关于不同类型的信息。

1574
02:12:42.080 --> 02:12:47.844
四种最基本的类型是布尔型，int型，int型，还有一个

1575
02:12:47.844 --> 02:12:53.609
地址或字节型，这是一种较低级别的类型，我们稍后会讲到。

1576
02:12:53.609 --> 02:13:01.750
一个布尔型定义了一些true false类型，一个int将是一个无符号整数，这意味着它将是一个不正不负的整数。

1577
02:13:01.797 --> 02:13:07.630
它是正的，我们有一个整数，它可以是正的或负的整数。

1578
02:13:07.630 --> 02:13:13.475
然后我们有一个地址，它将是一个地址，就像我们在元掩码中看到的。

1579
02:13:13.475 --> 02:13:16.486
还有一些其他类型的，稍后你们会学到。

1580
02:13:16.486 --> 02:13:21.764
我们有这些类型的原因是我们用它们来定义不同的变量。

1581
02:13:21.764 --> 02:13:24.667
变量基本上是不同值的持有者。

1582
02:13:24.667 --> 02:13:29.267
例如，我们可以创建一个名为“有最喜欢的数

1583
02:13:29.267 --> 02:13:33.868
字”的变量来表示某人是否有最喜欢的数字。

1584
02:13:33.868 --> 02:13:38.966
我们会把这个bull关键字放在has to renumber之前比如，

1585
02:13:38.966 --> 02:13:44.210
我们有一个变量叫做hasfavorite number，它的类型是布尔。

1586
02:13:44.210 --> 02:13:52.411
所以这个favorites number将表示true或false来设置它的值，我们可以说has favorite number = true。

1587
02:13:52.411 --> 02:13:55.318
现在最喜欢的数是真。

1588
02:13:55.318 --> 02:13:58.525
我们也可以说，has favorite number = false。

1589
02:13:58.525 --> 02:14:02.524
这个布尔值已经消褪，现在是假的。

1590
02:14:02.524 --> 02:14:09.703
对于uns，我们可以说你选择了最喜欢的数字等于，然后设置一个数字123。

1591
02:14:09.703 --> 02:14:16.835
这意味着我们最喜欢的数字是123你输入的是特殊的因为我们可以指

1592
02:14:16.835 --> 02:14:23.968
定要分配多少位给这个数字位和字节是计算机科学中非常基本的信息。

1593
02:14:23.968 --> 02:14:25.385
我们不打算在这里细讲。

1594
02:14:25.385 --> 02:14:29.460
然而，在GitHub知识库中有一个很棒的视频对它做了更多的解释。

1595
02:14:29.460 --> 02:14:33.513
基本上，它是分配给这个数字多少存储空间或内存。

1596
02:14:33.513 --> 02:14:39.999
它能有多大呢，如果我们说一个你int 8可以有8位一直到56。

1597
02:14:39.999 --> 02:14:45.521
如果你不指定它的大小，它会自动默认为256。

1598
02:14:45.521 --> 02:14:49.207
通常情况下，在编写代码时非常明确会更好。

1599
02:14:49.207 --> 02:14:53.536
通常你会看到我用int 256来表示un256。

1600
02:14:53.536 --> 02:14:59.712
我们也可以让一个int型的喜爱数等于123或int型的256。

1601
02:14:59.809 --> 02:15:04.647
我要继续，把这个布尔值加回来，我们要把它改回UNT为36。

1602
02:15:04.647 --> 02:15:11.236
让我们把最喜欢的数字改成5，我们还可以做一些叫做字符串的

1603
02:15:11.236 --> 02:15:17.825
东西，字符串，文本中最喜欢的数字等于5个字符串代表单词，

1604
02:15:17.825 --> 02:15:24.650
你可以把它们放在引号里来表示它们，它可以是一些单词或短语，

1605
02:15:24.650 --> 02:15:31.713
或者真的，真的只是键盘敲击的任何组合，结尾可以是正的或负的。

1606
02:15:31.713 --> 02:15:36.377
我们可以说- 5或+ 5，两者都是有效的，

1607
02:15:36.377 --> 02:15:45.707
因为我们也可以做addresmaddress =并从Metamask获取我们的地址。

1608
02:15:45.813 --> 02:15:50.980
然后粘贴进去，你会注意到我们用分号来结束这些代码行。

1609
02:15:50.980 --> 02:15:57.068
我们也有bytes对象，或者bytes 32，同样，表示我们希望它们是多少个字节。

1610
02:15:57.068 --> 02:16:01.667
这表示我们调用了favorites

1611
02:16:01.667 --> 02:16:06.266
bytes，我们将它设为cat。

1612
02:16:06.266 --> 02:16:13.613
字符串实际上很有趣，因为字符串实际上只是字节对象，但只有text to a

1613
02:16:13.613 --> 02:16:21.160
cat才是字符串，但可以自动转换为这些字节对象字节，对象通常看起来像0x。

1614
02:16:21.160 --> 02:16:28.709
然后是一些表示bytes对象的随机字母和数字，但cat可以自动转换为bytes。

1615
02:16:28.709 --> 02:16:35.592
我们会在以后的课程中更多地讨论字节，你们也可以做字节，2字节，3字节，5字

1616
02:16:35.592 --> 02:16:42.475
节22，你们知道我们的un的图片了我们的第六低是8位，因为8位是一个字节。

1617
02:16:42.475 --> 02:16:44.115
我们可以上升8阶。

1618
02:16:44.115 --> 02:16:48.157
我们可以做816 32，等等，一直到256。

1619
02:16:48.157 --> 02:16:53.042
例如，在下面这里，我们不能做字节64。

1620
02:16:53.042 --> 02:17:00.463
如果我们继续编译这个，我们会得到一个红色的东西。

1621
02:17:00.463 --> 02:17:06.175
如果向下滚动，我们会得到一个声明错误标识符，没有找到或不是唯一的。

1622
02:17:06.175 --> 02:17:08.446
字节64个最喜欢的字节等于猫。

1623
02:17:08.446 --> 02:17:12.000
我们甚至在我们的混音中得到了一个红色的警告标志。

1624
02:17:12.000 --> 02:17:15.297
这是混音告诉我们这一行有问题。

1625
02:17:15.297 --> 02:17:16.951
所以我们可以换回第32口。

1626
02:17:16.951 --> 02:17:21.405
因为字节32是字节所能达到的最大大小，所以您也可以只做一个

1627
02:17:21.405 --> 02:17:26.013
字节对象，这意味着它可以有任何大小，但我们通常希望是显式的。

1628
02:17:26.013 --> 02:17:30.662
现在想要了解更多关于不同类型以及如何使用它们以及它们的

1629
02:17:30.662 --> 02:17:35.485
所有不同特性的知识，请务必查看solididity文档。

1630
02:17:35.485 --> 02:17:39.217
现在，对于我们的简单存储，假设我们只想存储数字。

1631
02:17:39.217 --> 02:17:45.725
我们删掉除收藏号部分外的所有内容。

1632
02:17:45.825 --> 02:17:52.791
现在在固体性中，如果我这样做，我把等于5去掉，这个最喜欢的数字实际

1633
02:17:52.791 --> 02:17:59.969
上会被设置为一个默认值，固体性的默认值将是空值，在固体性中是零情况。

1634
02:17:59.969 --> 02:18:04.410
所以说你的intuit6个最喜欢的数字和你的25

1635
02:18:04.410 --> 02:18:09.038
6个最喜欢的数字等于0是一样的因为它被初始化为0。

1636
02:18:09.038 --> 02:18:11.564
现在，我们不初始化它。

1637
02:18:11.564 --> 02:18:15.759
所以最喜欢的数字会自动从0开始。

1638
02:18:15.828 --> 02:18:23.201
现在，如果你在写代码的时候感到困惑，一定要在代码中写注释，这样你就知道发生了什么。

1639
02:18:23.201 --> 02:18:30.338
也许，举个例子，一个很好的注释是它最初被化为0。

1640
02:18:30.338 --> 02:18:35.023
如果这让你感到困惑，你可以

1641
02:18:35.023 --> 02:18:39.709
说，这意味着这部分是注释。

1642
02:18:39.709 --> 02:18:46.743
现在我们来创建一个函数函数或方法是自包含的模块它会在我们调用它的时候为我

1643
02:18:46.743 --> 02:18:52.214
们执行一组特定的指令如果你熟悉Java, Python,

1644
02:18:52.214 --> 02:19:00.616
JavaScript或其他类似的东西函数的工作方式是完全相同的函数通过关键字funct

1645
02:19:00.616 --> 02:19:08.433
ion来识别，让我们创建一个叫store的函数它会将收藏号的值更改为一些新值。

1646
02:19:08.433 --> 02:19:14.889
而我们要改变它的数字将是传递给我们的store函数的变量。

1647
02:19:14.889 --> 02:19:20.965
我们允许store函数取一个类型为un 256的变量。

1648
02:19:20.965 --> 02:19:29.116
我们将它命名为下划线收藏号，我们将它设为公共函数，我们马上就会讲到。

1649
02:19:29.116 --> 02:19:35.353
我们要做的就是将喜爱数设置为我们刚刚传递的变量。

1650
02:19:35.353 --> 02:19:41.425
现在我们有了这个叫store的函数，它接受一些我们要给

1651
02:19:41.425 --> 02:19:47.722
它的形参它将这个喜爱号变量设为我们给这个函数的任何数字。

1652
02:19:47.722 --> 02:19:52.786
现在，让我们把它部署到一个比测试网更厚的区块链上，看看它的实际效果。

1653
02:19:52.838 --> 02:19:56.663
我们将把它部署到本地网络或JavaScript VM。

1654
02:19:56.663 --> 02:20:03.714
在我们这样做之前，首先我们要确保编译过程是正确的看起来我们有一个绿色的选中标记，这很好。

1655
02:20:03.714 --> 02:20:08.776
我们会看到这个按钮，这是我们的部署和运行事务选项卡。

1656
02:20:08.840 --> 02:20:15.332
我们的部署和运行事务选项卡为实际部署该契约提供了大量不同的配置部分。

1657
02:20:15.332 --> 02:20:19.502
首先，我们要确保我们在JavaScript VM伦敦这一块，

1658
02:20:19.502 --> 02:20:25.203
JavaScript VM意味着我们要部署到一个伪本地JavaScript VM。

1659
02:20:25.203 --> 02:20:32.943
JavaScript VM是一个假的本地区块链在这里我们可以快速模拟事务而不需要等待它们

1660
02:20:32.943 --> 02:20:40.859
通过测试网，现在不要担心伦敦和柏林的对比，注入web 3和web 3提供者我们稍后会讲到。

1661
02:20:40.859 --> 02:20:42.746
我们这里也有这个账户区。

1662
02:20:42.843 --> 02:20:51.134
当我们在假的JavaScript VM上运行时，我们得到了一大堆假的帐户，从哪里部署，我们每人得到100。

1663
02:20:51.134 --> 02:20:57.618
对于每一个假账户，你可以认为它类似于我们的元掩码账户中的元掩码，不同

1664
02:20:57.618 --> 02:21:04.293
的是，这是我们给出的假JavaScript VM Aetherium。

1665
02:21:04.293 --> 02:21:11.422
对于我们的交易，包括部署契约，我们实际上有一个气体限制，还有我们可以发送的值，我们可以选择我们的契约。

1666
02:21:11.422 --> 02:21:16.846
现在我们只有一个契约，简单存储，这将是我们将要部署的。

1667
02:21:16.846 --> 02:21:23.259
在左边，要将这个部署到假的JavaScript VM，我们会点击deploy按钮。

1668
02:21:23.259 --> 02:21:28.561
如果我们一直滚动到底部，现在，我们可以看到一个契约被部署了。

1669
02:21:28.561 --> 02:21:33.192
它说x处的简单存储，等等等等。

1670
02:21:33.192 --> 02:21:39.206
我们看到这个橙色的按钮商店在256中有这个等级文本，在

1671
02:21:39.206 --> 02:21:45.220
我们的假本地区块链上下划线，我们实际上给了每个智能合约

1672
02:21:45.220 --> 02:21:51.235
一个地址，它有一个地址，就像我们的钱包有一个地址一样。

1673
02:21:51.235 --> 02:21:57.503
如果我们点击这个复制按钮，把它放到注释中，把它放大一点，

1674
02:21:57.503 --> 02:22:03.325
我们可以看到我们刚刚部署的契约的地址，位于这个地址。

1675
02:22:03.325 --> 02:22:10.783
另外，如果你拉起这里的滑块，你会看到这个绿色的小标记上面有关于这个部署的所有信息。

1676
02:22:10.783 --> 02:22:14.805
你可以点击下拉菜单看到更多关于这个的信息。

1677
02:22:14.852 --> 02:22:23.116
您可能会注意到，您将看到一些熟悉的关键字，如状态、事务散列、从到气体等。

1678
02:22:23.116 --> 02:22:28.869
当我们部署契约时，它实际上与发送事务相同。

1679
02:22:28.869 --> 02:22:36.484
记住，任何时候我们在区块链上做任何事情，我们修改任何值，我们发送一个事务。

1680
02:22:36.484 --> 02:22:43.613
部署契约就是修改区块链来拥有这个契约，它就是修改区块链的状态。

1681
02:22:43.613 --> 02:22:50.708
如果我们通过Rinkeby，或者COVID，或者主网络发送这个信息，我们将不得不花费大量的汽油来实际部署这个合同。

1682
02:22:50.708 --> 02:22:55.484
这是对gas和事务哈希值的模拟我们的事务

1683
02:22:55.484 --> 02:23:00.260
有多少，我们把它部署到一个真实的网络中。

1684
02:23:00.260 --> 02:23:03.416
但因为是JavaScript VM，所以都是假信息。

1685
02:23:03.416 --> 02:23:09.367
现在我们有了这个大的橙色按钮商店，这个大的橙色按钮类似于我们刚创建的商店函数。

1686
02:23:09.367 --> 02:23:17.478
如果我们在这个store中添加一些数字，比如123，然后点击store按钮，我们实际上调用这个store按钮。

1687
02:23:17.478 --> 02:23:20.874
我们用假的贾西卡进行交易。

1688
02:23:20.874 --> 02:23:25.674
区块链存储号码1234收藏号码。

1689
02:23:25.859 --> 02:23:32.569
如果我们一直滚动到我们的账户，现在，你会看到我们的假账户中以太币少了一点。

1690
02:23:32.569 --> 02:23:37.463
这是因为我们花了很多时间调用这个合约。

1691
02:23:37.463 --> 02:23:43.086
如果我们把底部的这个，我用5来调用它，我调用store，你会看到

1692
02:23:43.086 --> 02:23:48.710
它闪了一秒钟，我们发送了另一个事务将值5存储在我们喜爱的数字中。

1693
02:23:48.710 --> 02:23:56.442
现在的问题可能是，这真的很酷，帕特里克，但我看不出最喜欢的数字是什么，我怎么知道这些

1694
02:23:56.442 --> 02:24:04.175
交易实际上在进行?现在，我们最喜欢的数字的可见性被设为私有，所以我们实际上看不到它。

1695
02:24:04.175 --> 02:24:06.731
我们马上会讲到可见性。

1696
02:24:06.731 --> 02:24:08.371
为了让我们能看到它。

1697
02:24:08.371 --> 02:24:11.244
我们将改变我们最喜欢的数字能见度为公共。

1698
02:24:11.244 --> 02:24:15.553
我们继续，重新编译回到deploy选项卡。

1699
02:24:15.553 --> 02:24:20.293
我们点这里的小x，表示取消合约。

1700
02:24:20.293 --> 02:24:22.373
它只是把它从窗口移走了。

1701
02:24:22.373 --> 02:24:30.818
它并没有从区块链中去除它，因为它们是不可变的，有点不可变，因为这是一个假的模拟链。

1702
02:24:30.866 --> 02:24:34.366
但是我们继续编译，现在我们再次点击Deploy。

1703
02:24:34.866 --> 02:24:38.375
向下滚动，我们的新合约现在有两个按钮。

1704
02:24:38.375 --> 02:24:40.921
一个是橙色的store按钮。

1705
02:24:40.921 --> 02:24:43.544
但是现在我们有了一个新收藏按钮。

1706
02:24:43.544 --> 02:24:51.308
这个按钮代表公共变量收藏号，它就像一个函数，告诉我收藏号是什么。

1707
02:24:51.308 --> 02:24:59.642
如果我点喜欢的数字按钮，你觉得会出现什么?还记得它初始化为什么吗?好了，让我们现在点击它。

1708
02:24:59.642 --> 02:25:06.803
我们确实看到了0，我们看到这是一个YouTube ID 6，它存储的值是0。

1709
02:25:06.869 --> 02:25:12.881
现在，如果我通过调用store函数把这个数改成5，然后点击收藏号，我们

1710
02:25:12.881 --> 02:25:18.377
确实看到，收藏号被更新为5个函数变量可以有一个作为可见性说明符，

1711
02:25:18.377 --> 02:25:24.905
我们有public, private, external和internal。

1712
02:25:24.905 --> 02:25:29.959
Public在外部和内部都是可见的，这意味着任何与这个契约

1713
02:25:29.959 --> 02:25:35.014
交互或看到这个契约的人都能看到这个收藏数函数中存储的内容。

1714
02:25:35.014 --> 02:25:40.813
你会看到在这里的固体性文档中，它说它为存储斜杠状态变量创建了一个getter函数。

1715
02:25:40.813 --> 02:25:48.199
当我们添加关键字public到收藏号时，我们实际上是在为收藏号创建一个getter

1716
02:25:48.199 --> 02:25:55.585
函数，我们基本上是在创建一个函数来返回收藏号的值，这就是这个蓝色按钮跳出来的原因。

1717
02:25:55.585 --> 02:25:59.044
因为这个蓝色按钮是一个函数，它说，嘿，

1718
02:25:59.044 --> 02:26:05.417
返回收藏号的值private意味着只有这个特定的契约才能调用这个函数。

1719
02:26:05.417 --> 02:26:11.399
至于存储，这并不意味着只有这个契约可以读取存储在这里的内容。

1720
02:26:11.399 --> 02:26:13.446
我们稍后会讲到这个。

1721
02:26:13.446 --> 02:26:17.260
通过这种方式，这是唯一可以调用收藏号函数的契约。

1722
02:26:17.260 --> 02:26:20.426
私有函数仅对当前契约可见。

1723
02:26:20.426 --> 02:26:27.296
外部函数仅在外部可见，这意味着契约之外的人可以调用该函数。

1724
02:26:27.296 --> 02:26:35.770
内部的意思是只有这个契约和它的子契约能读取它，我们稍后会讲到这个。

1725
02:26:35.770 --> 02:26:38.585
奇怪的是，变量只是函数调用。

1726
02:26:38.585 --> 02:26:45.413
当我们第一次在没有public关键字的情况下部署这个时，我们没有看到收藏号码出现在左边的原因。

1727
02:26:45.413 --> 02:26:51.363
当我们没有为函数或变量提供可见性说明符时，它们会自动作为内部部署。

1728
02:26:51.363 --> 02:26:59.213
正如我们所知，内部函数和变量只能通过这个特定的契约或派生契约调用，我们稍后会讲到。

1729
02:26:59.213 --> 02:27:01.146
我们还是公开吧。

1730
02:27:01.146 --> 02:27:07.988
现在，我们在形参前面加上下划线的原因是告诉我们，这

1731
02:27:07.988 --> 02:27:14.830
个变量不同于全局喜爱号，形参有一些不同的命名约定。

1732
02:27:14.882 --> 02:27:22.063
随着课程的深入，我们会越来越理解好的参数名称是什么，每次调用这个store函数时。

1733
02:27:22.063 --> 02:27:26.819
我们在这里改变值，我们实际上是在发送一个事务因为记住，

1734
02:27:26.819 --> 02:27:31.399
每次我们改变区块链的状态，我们都是在一个事务中做的。

1735
02:27:31.399 --> 02:27:33.086
我们可以在这里看到所有的细节。

1736
02:27:33.086 --> 02:27:38.867
如果你转到你的混音的日志记录区域的交易细节，你可以向下滚动，你

1737
02:27:38.867 --> 02:27:44.836
可以看到以单位汽油为单位的交易成本，你会看到这个周围的一些东西。

1738
02:27:44.885 --> 02:27:49.231
你会注意到，发送Aetherium的数字超过21,000。

1739
02:27:49.231 --> 02:27:52.870
那是因为我们正在做一些计算成本更高的事情。

1740
02:27:52.870 --> 02:27:56.140
我们实际上在这里存储了一个数字。

1741
02:27:56.140 --> 02:28:00.768
如果我们在商店功能内部做更多，你认为会发生什么。

1742
02:28:00.768 --> 02:28:06.807
我们不只是存储这个数，我们还可以把这个数存储在这里。

1743
02:28:06.887 --> 02:28:11.237
然后我们会更新收藏数它会说收藏数等于收藏数加1。

1744
02:28:11.237 --> 02:28:17.221
因为我们要做更多的东西，现在我们应该看到这个store函数变得更贵了。

1745
02:28:17.221 --> 02:28:22.044
让我们重新编译，我们会删除这将重新部署。

1746
02:28:22.044 --> 02:28:26.343
我们现在有一个新的契约将再次存储5。

1747
02:28:26.343 --> 02:28:31.289
现在，如果我们看一下这个交易的细节，我们向下滚动

1748
02:28:31.289 --> 02:28:36.235
到执行成本，我们确实看到天然气的数量大大增加了。

1749
02:28:36.235 --> 02:28:42.478
这是因为我们要做更多的事情，这个存储函数现在的计算成本更高了。

1750
02:28:42.478 --> 02:28:46.729
就像我说的，每个区块链计算气体的方法都有所不同。

1751
02:28:46.729 --> 02:28:54.606
但最简单的思考方式是，你做的东西越多，交易的成本就越高。

1752
02:28:54.606 --> 02:28:57.842
让我们继续，删除这一行来继续我们的例子。

1753
02:28:57.892 --> 02:29:04.306
现在我们来谈谈作用域，我们最喜欢的数字基本上在一个叫做全局作用域的

1754
02:29:04.306 --> 02:29:10.721
东西里，这意味着括号里面的任何东西都可以访问这个最喜欢的数字变量。

1755
02:29:10.721 --> 02:29:18.831
但如果我做了这样的事呢?如果我创建一个un256，叫Test var呢?我设它等于5

1756
02:29:18.831 --> 02:29:26.362
?然后我创建了一个新函数，叫做什么它会不带参数，是公共的吗?我可以访问test

1757
02:29:26.362 --> 02:29:35.439
var，然后将它更改为6之类的东西吗?我们能做到吗?让我们继续，看看编译这个时会发生什么。

1758
02:29:35.439 --> 02:29:37.544
我们实际上遇到了一个错误。

1759
02:29:37.544 --> 02:29:40.696
我们期望的初等表达式在这里。

1760
02:29:40.696 --> 02:29:43.914
那是因为我有个双问号。

1761
02:29:43.914 --> 02:29:44.638
我们现在就试试。

1762
02:29:44.638 --> 02:29:46.509
我们得到未声明的标识符。

1763
02:29:46.509 --> 02:29:54.398
当你创建变量时，我们的something函数不知道test var，它们只能在它们所在的范围内被查看。

1764
02:29:54.398 --> 02:29:57.331
如果你觉得有点困惑，就找花括号。

1765
02:29:57.331 --> 02:30:04.543
这两个花括号包含了这个部分，开头的在上面，结尾的在下面。

1766
02:30:04.543 --> 02:30:11.673
如果我直接在这些花括号里面创建一个变量，这意味着这里的所有东西都可以访问它。

1767
02:30:11.673 --> 02:30:15.821
然而，test var是在这些花括号里面创建的，

1768
02:30:15.821 --> 02:30:26.884
这意味着只有花括号里面的东西才能访问test var，因为我们的函数有些东西不在store里面，或者函数不知道test var。

1769
02:30:26.884 --> 02:30:32.794
这就是作用域的工作原理，你要看你创建的变量是否在这些花括号内。

1770
02:30:32.794 --> 02:30:37.235
这就是你如何知道其他函数是否可以用它们。

1771
02:30:37.235 --> 02:30:39.144
这就是失败的原因。

1772
02:30:39.144 --> 02:30:46.416
就像我们在文档中看到的，当我们将这个公共变量添加到收藏号时，我们暗中添加了一个函

1773
02:30:46.416 --> 02:30:53.870
数它只返回收藏号，我们也可以添加自己的函数它也返回收藏号来类似于在后端创建的函数。

1774
02:30:53.904 --> 02:31:00.255
我们可以说function，我们叫它retrieve，我们把它设为公共视图。

1775
02:31:00.255 --> 02:31:05.290
我们说它返回到56。

1776
02:31:05.290 --> 02:31:07.840
或者马上解释一下这是什么意思。

1777
02:31:07.840 --> 02:31:10.114
我们会说，返回最喜欢的数字。

1778
02:31:10.114 --> 02:31:16.633
现在，我要点击命令S，同样的，我在这一节中会做很多次。

1779
02:31:16.633 --> 02:31:21.360
记住，这相当于我到编译选项卡，点击编译。

1780
02:31:21.360 --> 02:31:26.727
如果我们到deploy选项卡，删除上一个，部署一个新的，我们就有

1781
02:31:26.727 --> 02:31:32.095
了一个检索函数，它会返回和我们最喜欢的数字返回的完全一样的东西。

1782
02:31:32.095 --> 02:31:37.629
如果我们把这个更新为5，叫做favorites number然后检索它们现在都返回5。

1783
02:31:37.629 --> 02:31:43.224
现在你可以看到，这两个函数是蓝色的，但这个函数是橙色的。

1784
02:31:43.224 --> 02:31:49.894
有什么区别?为什么这些有不同的颜色?关键在于这个视图关键字，实际

1785
02:31:49.894 --> 02:31:56.565
上在固体度中有两个关键字它们表示一个不需要消耗汽油来运行的函数。

1786
02:31:56.565 --> 02:31:59.168
这些关键词是view和pure。

1787
02:31:59.168 --> 02:32:02.071
我们也把这个变量消掉。

1788
02:32:02.071 --> 02:32:09.540
视图函数意味着我们会从这个契约中读取状态，我们会从这个契约中读取一些东西。

1789
02:32:09.540 --> 02:32:17.828
例如，我们的检索函数现在只读取收藏夹号码是多少，视图函数不允许任何状态修改。

1790
02:32:17.828 --> 02:32:21.844
你不能用视图函数更新区块链。

1791
02:32:21.844 --> 02:32:25.142
纯函数也不允许任何状态修改。

1792
02:32:25.142 --> 02:32:27.639
我们不能更新最爱的数字。

1793
02:32:27.639 --> 02:32:30.931
不仅如此，他们还禁止从区块链读取数据。

1794
02:32:30.931 --> 02:32:33.289
所以我们也无法读取最喜欢的数字。

1795
02:32:33.289 --> 02:32:40.155
相反，你可能会对一个纯函数做的是像function，在这里加

1796
02:32:40.155 --> 02:32:47.021
上public, 1 + 1，或者返回，1 + 1，这将会把

1797
02:32:47.021 --> 02:32:53.887
你变成36，也许像这样，也许有一些你想要反复使用的数学运算，

1798
02:32:53.887 --> 02:33:00.983
也许有一些你想要实现的特定算法实际上不需要读取任何存储，等等。

1799
02:33:00.983 --> 02:33:07.850
现在，如果我们调用一个视图函数，或者一个纯函数，我们实际上不需要花费任何精力。

1800
02:33:07.917 --> 02:33:09.435
因为我们只是从区块链读取数据。

1801
02:33:09.918 --> 02:33:15.060
只花汽油，我们只做一个交易，如果我们修改区块链状态。

1802
02:33:15.060 --> 02:33:22.020
你会注意到，在我们下面的小控制台，如果我调用检索，这个调用就会出现。

1803
02:33:22.020 --> 02:33:25.185
但是，它看起来与调用store函数时不同。

1804
02:33:25.185 --> 02:33:30.851
我们调用store函数，我们得到这个小的选中标记，我们得到一个散列，我们没有得到一个小的选中标记。

1805
02:33:30.920 --> 02:33:32.729
我们不会得到调用的哈希值。

1806
02:33:33.920 --> 02:33:36.823
这些蓝色按钮不进行交易。

1807
02:33:37.920 --> 02:33:40.921
嘿，我们要读的是off chain，我们要读的是这个值。

1808
02:33:40.921 --> 02:33:46.056
但是，如果你看一下这个调用的细节，这里有一个执行成本。

1809
02:33:46.056 --> 02:33:52.455
这是怎么回事?我们可以看这部分，成本只适用于契约调用。

1810
02:33:52.455 --> 02:33:57.202
如果我们有一个调用检索的函数，如果有一个更新状态的函

1811
02:33:57.202 --> 02:34:02.133
数调用一个视图或一个纯函数，这是唯一会消耗汽油的时间。

1812
02:34:02.133 --> 02:34:09.503
举个例子，如果我们的store函数不是视图函数，要在某个点调用检索，那么

1813
02:34:09.503 --> 02:34:16.873
我们就必须支付检索的代价因为从区块链读取会消耗这个计算和消耗气体调用视图

1814
02:34:16.873 --> 02:34:24.653
函数是免费的，除非你在一个消耗气体的函数中调用它，在这种情况下它会消耗气体。

1815
02:34:24.653 --> 02:34:31.022
如果我们把它留在这里，我们删除这个recompile redeploy。

1816
02:34:31.022 --> 02:34:34.545
我们找回了最喜欢的号码，它们都是免费的。

1817
02:34:34.545 --> 02:34:41.267
但如果我们在这里添加，恢复8，我们可以看到，我们的执行成本比没有检索时增

1818
02:34:41.267 --> 02:34:48.177
加了，我们可以继续，我们可以编译，我点击命令我们在这里编译，我们可以部署。

1819
02:34:48.177 --> 02:34:50.760
让我们继续并再次存储。

1820
02:34:50.928 --> 02:34:56.317
我们会点击那个事务，我们会看到没有检索函数，它更便宜。

1821
02:34:56.317 --> 02:35:01.194
同样，我们最喜欢的number变量只要它有这个公共

1822
02:35:01.194 --> 02:35:06.071
可见实度，它也被计算为返回un 256的视图函数。

1823
02:35:06.071 --> 02:35:11.313
returns关键字的意思是，在我们调用它之后这个函数会给我

1824
02:35:11.313 --> 02:35:16.555
们什么我们说这个函数会给我们这个函数会返回一个un 256。

1825
02:35:16.555 --> 02:35:22.071
当我们调用检索时，它会返回或给我们一个效用6。

1826
02:35:22.071 --> 02:35:26.712
这是调用函数的结果这

1827
02:35:26.712 --> 02:35:31.818
是调用任意函数的结果。

1828
02:35:31.932 --> 02:35:35.883
现在我们的契约已经很好了，它允许我们存储单个喜爱号码。

1829
02:35:35.932 --> 02:35:43.510
但如果我们想存储一系列喜爱的数字呢?或者我们想要存储一堆不同的人他们有不同的喜爱数字?我

1830
02:35:43.510 --> 02:35:51.088
们怎么做呢我们有几种不同的方法来处理这个问题，其中一种方法是通过创建一个所谓的人的结构。

1831
02:35:51.088 --> 02:35:53.157
或者我们创建一个新的类型。

1832
02:35:53.157 --> 02:36:00.606
在我们的实体中，我们可以创建一个people对象，它同时包含某人的姓名和他们最喜欢的数字。

1833
02:36:00.606 --> 02:36:04.466
要做到这一点，我们说struct

1834
02:36:04.466 --> 02:36:11.221
people，你去56，最喜欢的数字，和一个字符串名。

1835
02:36:11.221 --> 02:36:17.641
现在我们创建了一个新的类型，叫做people，有点像你们直觉的6，或者布尔值，或者字符串。

1836
02:36:17.641 --> 02:36:20.381
现在我们有了一个可以使用的people类型。

1837
02:36:20.381 --> 02:36:27.051
类似于我们创建一个un256的公众收藏号，我们可以做完全一样的事情。

1838
02:36:27.051 --> 02:36:31.044
但是对于people，我们可以说people public，

1839
02:36:31.044 --> 02:36:37.034
我们叫这个person，我们可以创建一个新的people并把它分配给这个变量person。

1840
02:36:37.034 --> 02:36:41.729
我们写上，等号people，公共person，等号，

1841
02:36:41.729 --> 02:36:46.605
我们在这里加上括号表示我们要创建一个新的person。

1842
02:36:46.605 --> 02:36:53.358
因为我们把它做成了一个结构体，我们在这里加了小花括号让实体知道我们会从这

1843
02:36:53.358 --> 02:37:00.111
些结构体变量中抓取，我们会说，favorites number将是2，名

1844
02:37:00.111 --> 02:37:07.241
字将是Patrick分号，然后我们可以按Ctrl S，或者我们可以继续编译。

1845
02:37:07.241 --> 02:37:13.798
如果我们继续部署这个我们现在有了一个新的person，因为

1846
02:37:13.798 --> 02:37:20.355
这是一个公共变量，它有一个getter函数叫person。

1847
02:37:20.355 --> 02:37:25.385
点击person，我们会看到新对象，最喜欢的数字是2。

1848
02:37:25.385 --> 02:37:32.751
然后名字是Patrick，看到这个0和这个1了吗，因为它们表示不同变量的下标。

1849
02:37:32.751 --> 02:37:37.485
但是对于刚接触计算机科学的人来说，特别是在计算机科学中，让我们从数字0开始。

1850
02:37:37.485 --> 02:37:42.757
索引为0的是什么呢，我们有256，叫做收藏号，保存在2。

1851
02:37:42.757 --> 02:37:47.991
然后在索引1处，我们有一个字符串，它代表Patrick的名

1852
02:37:47.991 --> 02:37:53.407
字，当你在一个实体对象中有一个变量列表时，它们会自动被索引。

1853
02:37:53.407 --> 02:37:57.946
最喜欢的数字索引为0，名字索引为1。

1854
02:37:57.946 --> 02:38:04.117
有趣的是，如果你在契约中有一大堆变量，比如我们有公共收藏

1855
02:38:04.117 --> 02:38:10.509
号，这个收藏号，实际上，从技术上讲，在存储槽的0处被索引。

1856
02:38:10.509 --> 02:38:19.173
如果我们再做一个这样的，也许你想得到6个公共兄弟最喜欢的数字，从技术上讲，这将在第一个槽被索引。

1857
02:38:19.173 --> 02:38:25.182
如果我们再做一个，也许是妹妹最喜欢的数字，这就是下一个加第二个槽。

1858
02:38:25.182 --> 02:38:31.882
最喜欢的数字是0，这个加1，这个加2，但我们在后面的课程中会学到更多。

1859
02:38:31.882 --> 02:38:35.918
类似地，最喜欢的数字是索引0名称是索引1。

1860
02:38:35.918 --> 02:38:42.392
现在我们已经做得很好了，但如果我们想要很多人我们就必须不断复制粘贴并将人们

1861
02:38:42.392 --> 02:38:48.867
的名字person改为他们最喜欢的一个，1号，3号，将他们命名为ally。

1862
02:38:48.951 --> 02:38:52.968
第三个人，他们最喜欢的数字是7。

1863
02:38:53.952 --> 02:38:56.035
会是查德之类的。

1864
02:38:58.952 --> 02:39:02.828
创建列表和大量的人，因为我们必须静态地输入他们。

1865
02:39:02.828 --> 02:39:05.211
这是一个更好的创建列表的方法。

1866
02:39:05.211 --> 02:39:13.025
让我们删掉Patrick一个更好的创建列表的方法是使用一种叫做数组的数据结构。

1867
02:39:13.025 --> 02:39:17.580
数组是一种存储列表或对象序列的方法，创建数

1868
02:39:17.580 --> 02:39:22.136
组的工作原理与初始化其他不同类型完全相同。

1869
02:39:22.136 --> 02:39:28.155
通常，我们处理对象的类型、对象的可见性，然后是变量名。

1870
02:39:28.155 --> 02:39:30.399
我们对数组做同样的事情。

1871
02:39:30.399 --> 02:39:32.844
我们想要一个people数组。

1872
02:39:32.844 --> 02:39:37.181
这些小括号表示我们想要一个人的数组。

1873
02:39:37.181 --> 02:39:41.587
我们给它一个可见性public，

1874
02:39:41.587 --> 02:39:49.298
我们叫它people你也可以对你做同样的事情比如256，

1875
02:39:49.298 --> 02:39:57.010
你可以去56个公共收藏号码列表然后在这里加上这个数组键。

1876
02:39:57.010 --> 02:40:02.120
现在收藏号码列表将是一个数组或列表，我们先把它注释掉。

1877
02:40:02.120 --> 02:40:07.614
现在，如果我要部署这个契约，删除最后一个，重新部署。

1878
02:40:07.614 --> 02:40:10.975
这里有蓝色的people按钮。

1879
02:40:10.975 --> 02:40:18.893
记住，因为它是公共的，它是一个变量，它自动被赋予一个视图函数，它被赋予一个蓝色按钮。

1880
02:40:18.960 --> 02:40:23.608
而不是只有一个显示值的按钮，它给我们一个要

1881
02:40:23.608 --> 02:40:28.256
填写的表格，它想把un256作为输入参数。

1882
02:40:28.256 --> 02:40:32.927
如果输入0，什么也得不到，如果输入1，什么也得不到。

1883
02:40:32.927 --> 02:40:36.909
不管你在盒子里放什么，对吧?现在我们什么都拿不回来了。

1884
02:40:36.962 --> 02:40:41.217
这是因为我们的人员数组或人员列表当前为空。

1885
02:40:41.217 --> 02:40:45.650
它想要的值就是你想要的对象的索引。

1886
02:40:45.650 --> 02:40:51.248
举个例子，如果在索引0处，我有帕特里克，它会显示为0的帕特

1887
02:40:51.248 --> 02:40:56.846
里克，如果不是x 1，我有约翰，或者更好一点，是帕特里克。

1888
02:40:57.964 --> 02:41:00.148
七，约翰，等等。

1889
02:41:00.148 --> 02:41:01.809
这就是它所显示的。

1890
02:41:01.809 --> 02:41:04.754
但因为它是空的，所以什么也显示不出来。

1891
02:41:04.754 --> 02:41:10.221
让我们从收藏号中移除公共变量这样我们就不会得到重复的函数，

1892
02:41:10.221 --> 02:41:15.688
我们只会得到检索函数，我们马上会演示如何添加到这个数组中。

1893
02:41:15.688 --> 02:41:24.197
这种类型的数组被称为动态数组，因为数组的大小在数组初始化时没有给定。

1894
02:41:24.197 --> 02:41:33.105
如果我们说,一个人数组并添加一个三在括号中,这意味着这个列表,或者这个数组的人只能三个人,如果

1895
02:41:33.105 --> 02:41:42.013
我们不给它一个大小,这意味着它可以是任何大小和数组的大小可以是我们增长和收缩加减的人,如果我添

1896
02:41:42.013 --> 02:41:50.923
加三个,最多只能有三个数组中,我们将使用一个动态数组,因为我们要想添加任意数量的人们这个数组。

1897
02:41:50.970 --> 02:41:59.560
我们来创建一个函数来添加people people数组，我们写入function, addperson。

1898
02:41:59.560 --> 02:42:08.005
我们会取string memory name作为输入参数，我待会再解释。

1899
02:42:08.005 --> 02:42:14.548
一个un256下划线收藏号，我们会让它成为一个公共函数，或

1900
02:42:14.548 --> 02:42:21.317
者我们会调用一个push函数这在people对象上是可用的。

1901
02:42:21.317 --> 02:42:26.551
我们会说people。push，然后我们会创建

1902
02:42:26.551 --> 02:42:31.786
一个新的people对象，它会接收收藏夹号码。

1903
02:42:31.974 --> 02:42:34.743
还有名字。

1904
02:42:34.974 --> 02:42:36.449
现在，这对你们来说可能有点棘手。

1905
02:42:36.974 --> 02:42:37.640
下来。

1906
02:42:37.640 --> 02:42:39.640
这里的人都是大写的。

1907
02:42:40.975 --> 02:42:49.725
因为大写，它指的是结构people而不是变量people，小写people指的是这个小写数组。

1908
02:42:49.725 --> 02:42:54.424
我们说我们的数组。push，或者说push相当于

1909
02:42:54.424 --> 02:42:59.123
添加，一个新的people获取喜爱的号码和名字。

1910
02:42:59.123 --> 02:43:06.164
另一种方法是我们可以创建一个人类型的变量然后像这样添加。

1911
02:43:06.164 --> 02:43:09.616
所以我们可以说，新人等于人。

1912
02:43:09.616 --> 02:43:14.469
然后我们像之前一样把括号括起来。

1913
02:43:14.469 --> 02:43:19.501
你说收藏号码将是这个输入值，这个

1914
02:43:19.501 --> 02:43:24.849
参数，我们可以说名称将是这个参数。

1915
02:43:24.849 --> 02:43:32.725
点击保存，你会得到这个错误设置，说数据位置必须存储在内存中，或者叫data for variable但没有给出。

1916
02:43:32.725 --> 02:43:37.087
现在，我们只在这里添加memory关键字，我稍后会解释它的作用。

1917
02:43:37.087 --> 02:43:40.784
当然，我们还需要将新的person添加到people。push中。

1918
02:43:40.784 --> 02:43:45.235
这就是我们将人推入people数组的方式。

1919
02:43:45.235 --> 02:43:47.523
我马上就会讲到这个记忆关键字。

1920
02:43:47.523 --> 02:43:52.435
现在回到deploy选项卡，删除最后一个契约。

1921
02:43:52.435 --> 02:43:54.227
让我们部署这个新的。

1922
02:43:54.227 --> 02:44:00.723
现在，如果我们试图查看person在people数组中的0，我们什么也得不到，

1923
02:44:00.723 --> 02:44:07.054
但我们继续添加一个人，我们将其命名为Patrick, 7将是最受欢迎的数字。

1924
02:44:07.054 --> 02:44:09.516
我们加了帕特里克，加了7。

1925
02:44:09.516 --> 02:44:16.951
现在如果我们看一下人们的0，我们应该会看到第0个人的名字叫帕特里克，最喜欢的数字是7，砰。

1926
02:44:16.951 --> 02:44:25.894
这正是我们所看到的，我们看到一个最喜欢的数字7，我们看到一个名为Patrick的字符串，我们试图加上John，然后是他的16。

1927
02:44:25.894 --> 02:44:29.485
点击添加人员，我们可以看到交易通过。

1928
02:44:29.485 --> 02:44:34.923
现在如果我们选择0的人，仍然是帕特里克，他最喜欢的数字是7。

1929
02:44:34.923 --> 02:44:40.096
但是如果我们看看指数1的人，会是约翰，他最喜欢的数字是16。

1930
02:44:40.096 --> 02:44:43.495
如果我们看两个，当然，这个应该是空白的。

1931
02:44:43.495 --> 02:44:46.390
我们确实看到这里什么都没有发生。

1932
02:44:46.390 --> 02:44:46.777
完美的。

1933
02:44:46.777 --> 02:44:53.159
这里其实有几种不同的方法来创建这个新人，就像我们之前展示的，我们可以

1934
02:44:53.159 --> 02:44:59.730
用这个括号符号，或者我们可以做的是我们可以按照参数显示的顺序添加参数。

1935
02:44:59.730 --> 02:45:03.540
人们的第一个参数是最喜欢的数字。

1936
02:45:03.540 --> 02:45:10.924
我们可以写最喜欢的数字，逗号，第二个是名字，第二个是名字。

1937
02:45:10.924 --> 02:45:18.104
如果我们保存这条，这条，我们刚创建的这条直线和上一条直线是完全一样的，我们在这里没有那么明确。

1938
02:45:18.104 --> 02:45:26.539
另一种方法通常会更好一些因为它更明确地说明了变量是什么我们甚至不需要保存到这个变量，我们可

1939
02:45:26.539 --> 02:45:34.974
以去掉整行，用我们刚刚看到的替换new person现在我们甚至不需要memory关键字。

1940
02:45:34.974 --> 02:45:38.155
现在，你可能已经看到了这个。

1941
02:45:38.155 --> 02:45:43.320
但如果我继续编译，我在这里看到一个小红色的，我就翻过去。

1942
02:45:43.320 --> 02:45:51.660
它说了一些错误，期望是分号，但得到了括号，所有这些错误都意味着你的代码没有编译。

1943
02:45:51.660 --> 02:45:53.518
它没有像预期的那样工作。

1944
02:45:53.518 --> 02:45:58.394
现在我可以到这里做一个分号重新编译，我得到一个绿色。

1945
02:45:58.394 --> 02:46:04.910
如果我删除上面这一行，然后编译它，就会得到一个黄色的东西。

1946
02:46:04.995 --> 02:46:12.724
黄色代表警告，我得到的警告是警告SPX许可证标识符，没有提供，你应该添加它。

1947
02:46:12.724 --> 02:46:14.596
我们把它加回来。

1948
02:46:14.596 --> 02:46:15.096
编译。

1949
02:46:15.096 --> 02:46:16.431
警告消失了。

1950
02:46:16.431 --> 02:46:18.608
不要停止编译你的代码。

1951
02:46:18.608 --> 02:46:19.896
所以如果你收到警告，没关系。

1952
02:46:19.896 --> 02:46:26.950
但是，听取警告通常是一个好主意，因为它们通常会提供关于如何改进智能合约的非常有见地的信息。

1953
02:46:26.997 --> 02:46:29.642
总结一下，如果它是红色的，它就坏了。

1954
02:46:30.998 --> 02:46:31.960
也许你该去看看。

1955
02:46:32.998 --> 02:46:36.935
继续编码。

1956
02:46:39.998 --> 02:46:42.764
你会注意到这里有一个记忆关键字。

1957
02:46:42.999 --> 02:46:51.051
你会注意到，如果你试图从函数中删除它，你试图编译，你实际上会遇到错误数据位置必须是内存或调用数据为参数和函数。

1958
02:46:51.100 --> 02:46:55.787
现在实际上有六个地方你可以存储数据，你有

1959
02:46:55.787 --> 02:47:00.475
堆栈，内存，存储，调用数据，代码和日志。

1960
02:47:00.475 --> 02:47:02.490
我们现在不打算细说这些。

1961
02:47:02.490 --> 02:47:10.515
但是我们将关注其中的三个大的，或者是这一节中三个重要的，它们被称为数据，内存和存储。

1962
02:47:10.515 --> 02:47:13.921
这一节，我们将讨论调用数据内存和存储。

1963
02:47:13.921 --> 02:47:15.680
这有点高级。

1964
02:47:15.680 --> 02:47:19.155
所以如果你第一次没有完全理解，那也没关系。

1965
02:47:19.155 --> 02:47:20.043
请继续。

1966
02:47:20.043 --> 02:47:28.362
即使不清楚这里发生了什么，调用数据和内存意味着变量只会暂时存在。

1967
02:47:28.362 --> 02:47:34.690
因此，这个name变量只在被称为Add Person函

1968
02:47:34.690 --> 02:47:41.018
数的事务中临时存在，甚至在函数执行之外也存在存储变量。

1969
02:47:41.100 --> 02:47:47.286
即使我们没有在上面指定它，我们最喜欢的数字也会自动转换为存储变量。

1970
02:47:47.286 --> 02:47:51.033
因为它没有在这些函数中明确定义。

1971
02:47:51.033 --> 02:47:57.347
因为在这个函数运行后我们不再需要这个name变量，我们可以将它保留为内存，或者我们可以将它保

1972
02:47:57.347 --> 02:48:03.661
留为called data，如果你不修改名字，你可以将一个参数保留为called data。

1973
02:48:03.661 --> 02:48:10.134
例如，我们不能在这里将name重新赋值给equal cat，如果我们编译，就会遇到错误。

1974
02:48:10.134 --> 02:48:15.261
类型字面值字符串cat不能隐式转换为期望名为data的类型字符串。

1975
02:48:15.261 --> 02:48:23.911
但是，如果我们把它作为内存，编译并保存它，错误就会消失调用数据是临时变量，不能被修改。

1976
02:48:23.911 --> 02:48:27.242
内存是可以修改的临时变量。

1977
02:48:27.242 --> 02:48:30.625
存储是可以修改的永久变量。

1978
02:48:30.625 --> 02:48:37.627
现在，尽管我刚刚说了实际上有六个地方我们可以访问和存储信息，我们不能说一个变

1979
02:48:37.627 --> 02:48:44.629
量是堆栈代码或日志，我们只能说内存存储称为数据，你将在后面的部分了解为什么。

1980
02:48:44.629 --> 02:48:47.339
现在，这有点过于简单化了。

1981
02:48:47.339 --> 02:48:49.227
但本质上就是这样。

1982
02:48:49.227 --> 02:48:57.507
下一个问题你可能会问，为什么我需要在这里说内存，但我不需要在这里说内存。

1983
02:48:57.507 --> 02:49:02.035
我们把内存放在这里，然后按CTRL S或编译。

1984
02:49:02.101 --> 02:49:08.051
让我们看看会发生什么，我们从固体数据位置只能指定为数组，结构或映射类型。

1985
02:49:08.101 --> 02:49:13.920
数组结构和映射被认为是内存的特殊类型和稳固性。

1986
02:49:13.920 --> 02:49:18.968
固体性自动知道你在256中的位置慢慢地知道

1987
02:49:18.968 --> 02:49:24.017
对于这个函数，UN 256只存在于内存中。

1988
02:49:24.101 --> 02:49:26.651
然而，它不确定字符串将是什么。

1989
02:49:27.101 --> 02:49:28.947
其实是很复杂的。

1990
02:49:30.101 --> 02:49:32.476
字符串实际上是一个字节数组。

1991
02:49:34.101 --> 02:49:39.074
数组，我们需要添加这个内存位因为我们需要告诉它坚固

1992
02:49:39.074 --> 02:49:44.048
性，数组结构的数据位置，或者映射字符串是一个数组。

1993
02:49:44.048 --> 02:49:46.837
这就是为什么我们需要告诉它它在内存中。

1994
02:49:46.837 --> 02:49:53.804
你会注意到我们不能在这里添加storage关键字因为这是一个函数，name变量不会被存储到任何地方。

1995
02:49:53.804 --> 02:50:02.583
它说，嘿，你不能有那个你需要让它打败内存或调用数据这是它唯一接受的两个这就是我们想要的函数在这里的样子。

1996
02:50:02.583 --> 02:50:07.170
总结一下，当把结构映射和数组作为参数添加

1997
02:50:07.170 --> 02:50:11.757
到不同的函数时需要给它们Data关键字。

1998
02:50:11.757 --> 02:50:16.435
我们将在后面的会话中了解更多关于存储内存和调用数据的知识。

1999
02:50:16.435 --> 02:50:22.133
这个列表很棒，但如果我们知道某人的名字，却不知道他们

2000
02:50:22.133 --> 02:50:28.051
最喜欢的数字呢?我们能做的就是在整个数组中寻找那个人。

2001
02:50:28.102 --> 02:50:32.368
例如，在我们的合同中，我们可以说，好的，我在找约翰。

2002
02:50:32.368 --> 02:50:34.234
好吧，我们从0开始。

2003
02:50:34.234 --> 02:50:35.900
不，那是帕特里克。

2004
02:50:36.102 --> 02:50:37.227
好吧，让我们看一个。

2005
02:50:37.227 --> 02:50:37.494
好的。

2006
02:50:37.494 --> 02:50:38.136
这是约翰。

2007
02:50:38.136 --> 02:50:38.671
哦,太棒了。

2008
02:50:39.102 --> 02:50:42.790
你最喜欢16号吗?这真的很简单，因为我们只有两个人。

2009
02:50:42.790 --> 02:50:51.652
但如果我们有数百人在这个队列中呢?我们必须一直迭代到那个人所在的索引，这显然是非常低效的。

2010
02:50:51.652 --> 02:51:00.264
还有什么方法可以存储这些信息，使其更容易和更快地访问呢?我们可以使用的另一个数据结构

2011
02:51:00.264 --> 02:51:08.876
叫做映射，你可以把映射想象成一个字典，它是一组键，每个键返回一个与该键相关的特定值。

2012
02:51:08.876 --> 02:51:13.502
我们创建一个映射变量和我们创建其他变量的方法完全一样。

2013
02:51:13.502 --> 02:51:19.961
这将是string给你的类型映射而tivity，

2014
02:51:19.961 --> 02:51:26.152
这将是我们的可见性类型关键字将是public。

2015
02:51:26.152 --> 02:51:31.052
我们叫它名字到最喜欢的数字。

2016
02:51:31.052 --> 02:51:36.905
现在我们有了一个字典，每个名字都映射到一个特定的数字。

2017
02:51:36.905 --> 02:51:40.273
让我们为add Person函数添加一些功能。

2018
02:51:40.273 --> 02:51:43.944
我们要把人加到数组中。

2019
02:51:44.102 --> 02:51:50.899
但我们也把它们添加到映射中，我们要做的是说name to favorite number。

2020
02:51:50.899 --> 02:51:58.939
App键名将等于收藏夹号码。

2021
02:51:58.939 --> 02:52:02.857
让我们继续，编译这个。

2022
02:52:03.103 --> 02:52:11.153
我们到部署屏幕，部署这个click，我们有一个新按钮，命名为收藏夹号码。

2023
02:52:11.153 --> 02:52:14.206
如果我输入帕特里克，什么都没出现。

2024
02:52:14.206 --> 02:52:17.610
输入Patrick，你会看到我得到零响应。

2025
02:52:17.610 --> 02:52:20.340
输入John，我也得到了零响应。

2026
02:52:20.340 --> 02:52:23.836
如果我输入贝卡，我也会得到零回应。

2027
02:52:23.836 --> 02:52:29.054
当你创建一个映射时，你把所有东西都初始化为它的空值，地

2028
02:52:29.054 --> 02:52:34.272
球上每一个可能的字符串现在都初始化为最喜欢的数字为0。

2029
02:52:34.272 --> 02:52:37.634
如果我们想要改变它，我们需要手动添加它。

2030
02:52:37.634 --> 02:52:41.916
让我们在映射中添加一个人。

2031
02:52:41.916 --> 02:52:43.612
我们加上帕特里克。

2032
02:52:43.612 --> 02:52:46.666
我们会说我最喜欢的数字是7。

2033
02:52:46.666 --> 02:52:53.880
看来这笔交易完成了贝卡，她最喜欢的数字是13。

2034
02:52:53.880 --> 02:52:58.012
让约翰，我们说他最喜欢的数字是16。

2035
02:52:58.012 --> 02:53:05.036
现在，如果我往上看，帕特里克，我马上就会得到帕特里克最喜欢的数字是什么，我得到了7。

2036
02:53:05.036 --> 02:53:08.243
如果我们往上看，约翰，我们马上就能回到16。

2037
02:53:08.243 --> 02:53:10.558
退后，我们可能只能回到13。

2038
02:53:10.558 --> 02:53:13.255
我们也可以在数组中看到它们。

2039
02:53:13.255 --> 02:53:19.357
因为我们一直在推零位的人，我们看到帕特里克在那里。

2040
02:53:19.357 --> 02:53:21.492
在一点钟，我们看到了贝卡。

2041
02:53:21.492 --> 02:53:30.202
在第二点，我们看到John，在我们的映射中，我们说字符串名被映射到UN 256最喜欢的数字。

2042
02:53:30.202 --> 02:53:34.057
我的很多变量，我喜欢这样显式命名。

2043
02:53:34.104 --> 02:53:38.261
这是名字到喜爱的数字。

2044
02:53:38.261 --> 02:53:44.199
现在我们处在这样一个空间假设我们非常喜欢简单的储存合同。

2045
02:53:44.199 --> 02:53:50.834
现在我们有一个收藏号，一个全局变量我们可以用store函

2046
02:53:50.834 --> 02:53:57.469
数保存收藏号，我们有一个name到收藏号的映射，我们有一

2047
02:53:57.469 --> 02:54:04.578
个新类型的数组叫做people，我们可以添加到数组和映射中。

2048
02:54:04.578 --> 02:54:09.150
使用我们创建的这个添加人功能，我们能够保存

2049
02:54:09.150 --> 02:54:13.722
多人最喜欢的号码以及一个全局最喜欢的号码。

2050
02:54:13.722 --> 02:54:20.054
假设我们非常喜欢这个合同，我们准备将它发送到测试网络，让其他人与它进行交互。

2051
02:54:20.104 --> 02:54:26.484
在以后的部分中，你会听到我说你不应该这样做直到你写了测试直到你做了一些真正简单的审计。

2052
02:54:26.484 --> 02:54:32.874
但现在，让我们继续学习如何将它部署到测试网或真实的网络中。

2053
02:54:32.874 --> 02:54:35.970
记住，测试网是用人们内心的善意来运行的。

2054
02:54:35.970 --> 02:54:40.500
如果它有点古怪，或者可能不完全像我们在这里展示的那样工作，那也没关系。

2055
02:54:40.500 --> 02:54:48.041
只要它能与JavaScript VM一起工作，您就万事俱备了，但学习如何将它们部署到真正的测试网络是一个很好的实践。

2056
02:54:48.041 --> 02:54:49.728
我们来做一下。

2057
02:54:49.728 --> 02:54:51.226
我们的合同在这里。

2058
02:54:51.226 --> 02:54:52.910
简单的存储点灵魂。

2059
02:54:52.910 --> 02:54:58.284
它被编译，编译被传递我们得到这个绿色的小标记我们进入部署部分。

2060
02:54:58.284 --> 02:54:59.808
让我们继续做拿着这个。

2061
02:54:59.808 --> 02:55:02.120
现在我们要改变环境。

2062
02:55:02.120 --> 02:55:06.812
我们在JavaScript虚拟机中工作或者类似于这种模拟环

2063
02:55:06.812 --> 02:55:11.505
境，我们现在想转移到注入web 3，或者web 3提供者。

2064
02:55:11.505 --> 02:55:16.040
如果你把鼠标悬停在inject web3上面，这里有一个非常非常小的文本。

2065
02:55:16.040 --> 02:55:21.556
但这基本上意味着我们会将元掩码或webthree钱包注入到浏览器

2066
02:55:21.556 --> 02:55:27.073
中使用就像我们对水龙头所做的一样，我们会选择我们想要使用的账户。

2067
02:55:27.073 --> 02:55:29.978
所以我要选择账户1。

2068
02:55:29.978 --> 02:55:37.412
现在我们在remix的account部分看到我们的账户，注入web 3意味着我

2069
02:55:37.412 --> 02:55:44.846
们在使用元掩码或web 3钱包，web 3提供者，当我们稍微手动地选择端点时。

2070
02:55:44.846 --> 02:55:47.088
我们现在不打算讨论这个。

2071
02:55:47.088 --> 02:55:49.956
但随着课程的深入，你会明白这是什么意思。

2072
02:55:49.956 --> 02:55:54.688
我们选择注入web 3，无论注入web 3是什么网络，或者

2073
02:55:54.688 --> 02:55:59.420
在这种情况下，我们的钱包连接到的网络将是我们部署到的网络。

2074
02:55:59.420 --> 02:56:02.494
所以这一部分，我们将部署到林克比。

2075
02:56:02.494 --> 02:56:10.334
但是，这取决于推荐的测试网和推荐的水龙头是什么，这将决定你应该部署哪个测试网。

2076
02:56:10.334 --> 02:56:11.858
对我们来说，是里格比。

2077
02:56:11.858 --> 02:56:16.980
为了进行测试记住，我们需要气体，所以我们需要一些经过测试的以太。

2078
02:56:16.980 --> 02:56:24.327
或者如果你部署到一个主网主Aetherium，你不应该来到GitHub回购的顶部，以

2079
02:56:24.327 --> 02:56:31.850
确保你有最新的水龙头，另一个地方，你可以去链接令牌合约页的链链接文档，并向下滚动排名。

2080
02:56:31.850 --> 02:56:36.531
你可以在这里测试链接，在这里测试每个链接。

2081
02:56:36.531 --> 02:56:43.334
这是另一个位置，你总是可以找到最新的水龙头，它们都指向这里。

2082
02:56:43.334 --> 02:56:48.173
现在我们正在使用注入web 3，我们可以通过

2083
02:56:48.173 --> 02:56:53.012
部署到测试网和部署到虚拟机的完全相同的步骤。

2084
02:56:53.106 --> 02:56:57.767
记住，如果你没油开这个，一定要检查水龙头是否真的开了。

2085
02:56:57.767 --> 02:57:00.582
我们会做同样的事情，我们会点击部署。

2086
02:57:00.582 --> 02:57:08.755
这次Metamask会弹出来问我们是否要部署这个，这和我们在区块链例子

2087
02:57:08.755 --> 02:57:16.928
中看到的完全一样，我们签署了交易，我们签署并发送了这个交易，这个交易的

2088
02:57:16.928 --> 02:57:25.101
数据是这个巨大的数据，它代表我们刚刚创建的合约，我们可以看到这个交易的

2089
02:57:25.101 --> 02:57:33.976
所有支付信息部署这个合约，我们发现部署它需要大约这么多的Aetherium。

2090
02:57:33.976 --> 02:57:36.519
但是，我们是在林克比测试网络上。

2091
02:57:36.519 --> 02:57:37.829
这是假的Aetherium。

2092
02:57:37.829 --> 02:57:40.215
继续，点击确认。

2093
02:57:40.215 --> 02:57:48.907
如果你弹出一个小控制台，进行混合，你会看到稍等片刻后，它会显示有这个绿色的复选标

2094
02:57:48.907 --> 02:57:57.817
记它确认了它确实通过了，我们可以继续右击，打开一个新选项卡，在以太扫描中查看这个。

2095
02:57:57.817 --> 02:58:01.891
稍等片刻后，我们就能看到交易细节了，

2096
02:58:01.891 --> 02:58:10.492
和发送Aetherium时的交易细节完全一样我们有散列，有状态，有阻塞，有确

2097
02:58:10.492 --> 02:58:17.058
有状态，有阻塞，有确认，还有时间戳这是我们两个，这是我们刚创建的合约的平均值。

2098
02:58:17.058 --> 02:58:19.280
我们没有用这个发送任何值。

2099
02:58:19.280 --> 02:58:20.920
所以这是零以太。

2100
02:58:20.920 --> 02:58:25.056
当然，我们还会看到交易费用，以及汽油价格。

2101
02:58:25.056 --> 02:58:30.219
因为，将合约部署到区块链就是在修改区块链的状态。

2102
02:58:30.219 --> 02:58:33.948
我们需要支付汽油，我们可以看到所有不同的部分。

2103
02:58:33.948 --> 02:58:35.435
正如我们所看到的，

2104
02:58:35.435 --> 02:58:44.027
气体限制和气体使用量比发送Aetherium要高得多，因为我们在链上放置了大量的数据并添加了大量的计算。

2105
02:58:44.107 --> 02:58:49.017
所以这个数字远远高于仅仅发送Aetherium的21000个数字。

2106
02:58:49.017 --> 02:58:55.934
现在，如果我们回到我们的混音并向下滚动，我们可以在这个地址看到我们的简单存储合同。

2107
02:58:55.934 --> 02:59:04.896
如果我们点击这个复制按钮，我们到溜冰场进行以太扫描，我们把它粘贴到搜索栏，我们会得到我们刚刚部署的合同。

2108
02:59:04.896 --> 02:59:10.041
我们看到第一个交易将是合同创建交易。

2109
02:59:10.107 --> 02:59:15.011
我们刚刚创建了一个交易，这是合同创建。

2110
02:59:15.011 --> 02:59:17.261
现在我们已经创建了这个契约，

2111
02:59:17.261 --> 02:59:24.172
我们有了所有与JavaScript虚拟机，或我们的伪环境，或超级伪环境完全相同的函数。

2112
02:59:24.172 --> 02:59:29.707
现在我们可以在一个真实的测试网络上做和JavaScript VM完全相同的事情。

2113
02:59:29.707 --> 02:59:33.666
你会看到如果我点击检索Metamask没有弹出。

2114
02:59:33.666 --> 02:59:36.535
因为这是一个蓝色的视图函数。

2115
02:59:36.535 --> 02:59:42.528
如果我们看0的人，这也是一个视图函数，没有弹出任何东西，命名喜爱的数字应该是空白的。

2116
02:59:42.528 --> 02:59:48.473
所以如果我现在输入帕特里克，绝对什么都不会发生，对吧?

2117
02:59:48.473 --> 02:59:54.639
返回0，因为映射用空值或空值初始化每个键，256就是0。

2118
02:59:54.639 --> 03:00:02.766
现在，我们可以继续存储一个收藏号存储当你的收藏号要修改区块链时，我

2119
03:00:02.766 --> 03:00:10.894
们的元掩码应该会弹出来让我们确认交易并签署该交易来修改区块链状态。

2120
03:00:10.894 --> 03:00:18.365
我要存储我最喜欢的数字16，点击store，元掩码会弹出，然后我们要

2121
03:00:18.365 --> 03:00:25.836
确认这个没有确认等同于US签署这个交易并将它发送给区块链来修改状态。

2122
03:00:25.836 --> 03:00:31.044
所以我们要继续确认这个，我们应该可以在以太扫描上看到这个。

2123
03:00:31.108 --> 03:00:35.561
同样，它可能需要一点时间才能真正索引或真正开始工作。

2124
03:00:35.561 --> 03:00:37.627
所以请耐心使用这些测试网。

2125
03:00:37.627 --> 03:00:42.235
再说一遍，这就是为什么在构建应用程序时，你希望

2126
03:00:42.235 --> 03:00:47.044
测试网绝对是你的最后一步，因为你必须等很长时间。

2127
03:00:47.108 --> 03:00:51.536
这给那些做这些测试的人带来了负担，让他们不得不出于好心去做这些测试。

2128
03:00:51.536 --> 03:00:55.600
因此，请尝试将此作为您实际构建过程的最后一步。

2129
03:00:55.600 --> 03:00:58.043
对我们来说，在这里学习，没关系。

2130
03:00:58.043 --> 03:01:03.675
稍等片刻后，一旦我们点击刷新，它看起来像是在以太扫描上建立索引，以太扫描

2131
03:01:03.675 --> 03:01:09.465
网站仍然在计算交易将在哪里进行混合，看起来在区块链上，这实际上已经完成了。

2132
03:01:09.465 --> 03:01:13.827
如果我们点击检索，我们确实会看到，我们最喜欢的数字是16。

2133
03:01:13.827 --> 03:01:16.396
当然，这两个仍然是空的。

2134
03:01:16.396 --> 03:01:20.483
看起来交易已经完成，以太扫描已经建立了索引。

2135
03:01:20.483 --> 03:01:26.430
现在我们继续，加一个人加上帕特里克，我最喜欢的数字是16。

2136
03:01:26.430 --> 03:01:28.284
我们将继续添加person。

2137
03:01:28.284 --> 03:01:35.323
橙色事务会弹出因为我们修改了区块链状态，点击确认。

2138
03:01:35.323 --> 03:01:39.785
我们要耐心一点等待交易完成。

2139
03:01:39.785 --> 03:01:41.818
我们应该看到这个更新。

2140
03:01:41.818 --> 03:01:42.902
还有这次更新。

2141
03:01:43.108 --> 03:01:46.785
如果我点击帕特里克最喜欢的数字，我得到16。

2142
03:01:47.108 --> 03:01:49.441
如果我打0的人，我就得到最喜欢的16号。

2143
03:01:50.108 --> 03:01:50.743
帕特里克。

2144
03:01:50.743 --> 03:01:51.251
太棒了。

2145
03:01:54.109 --> 03:02:00.447
到一个真实的测试网络，在以太网上看到这些交易是什么样子的，你应该为自

2146
03:02:00.447 --> 03:02:06.786
己感到无比自豪，一定要给自己击掌，拍拍后背，发一条推特说你有多兴奋。

2147
03:02:06.786 --> 03:02:15.381
但一定要庆祝这些小胜利，庆祝这些小胜利会给你继续前进的动力，真正激发你学习每一个新事物。

2148
03:02:15.381 --> 03:02:15.962
如此巨大的。

2149
03:02:16.109 --> 03:02:16.812
祝贺你。

2150
03:02:19.109 --> 03:02:21.198
合同到测试网，恭喜你。

2151
03:02:22.109 --> 03:02:29.493
要查看部署到不同的网络是什么样子，你需要在Metamask中做的就是切换到不同的测试网络。

2152
03:02:29.493 --> 03:02:36.505
看，如果我们切换到新冠混合自动更新，然后说，啊，注入的web 3现在是新冠测试网络。

2153
03:02:36.505 --> 03:02:42.055
我们可以再次切换到格里利，我们说，啊，注射网3现在在格里利。

2154
03:02:42.109 --> 03:02:49.216
这是我们将要部署的测试网，当然，我们需要真正的测试网Aetherium来做任何部署，所以我们不能在这里。

2155
03:02:49.216 --> 03:02:52.420
如果我们现在点击部署，Metamask就会弹出。

2156
03:02:52.420 --> 03:02:56.251
但是我们看到这个红色的小标记表示资金不足。

2157
03:02:56.251 --> 03:03:03.449
当然，稍后，我们将学习如何添加新的网络像多边形雪崩像幻影到我们的Metamask。

2158
03:03:03.449 --> 03:03:07.734
所以我们也可以从其中任何一个部署。

2159
03:03:08.109 --> 03:03:13.213
我之前提到过这个术语，但我们写的所有这些代码，当我们

2160
03:03:13.213 --> 03:03:18.515
按下这个编译按钮时，它就会编译到EVM或以太坊虚拟机。

2161
03:03:18.515 --> 03:03:21.786
不要太担心这意味着什么。

2162
03:03:21.786 --> 03:03:27.442
EVM是一种将智能合约像区块链一样部署到Aetherium的标准。

2163
03:03:27.442 --> 03:03:30.966
以及实现某种类型EVM的任何区块链。

2164
03:03:30.966 --> 03:03:35.713
你可以将固态代码部署到一些与EVM兼容的区块链的例子中，

2165
03:03:35.713 --> 03:03:40.461
比如avalanche、Phantom和polygon。

2166
03:03:40.461 --> 03:03:45.473
因为这些都是EVM兼容的，这意味着我们可以编写我们的坚固性代码，并部署到这

2167
03:03:45.473 --> 03:03:50.485
些区块链上，我稍后会向您展示如何将这些新网络添加到您的Metamask中。

2168
03:03:50.485 --> 03:03:51.797
然后是如何部署它们。

2169
03:03:51.797 --> 03:03:54.290
让我们快速回顾一下我们的第一个智能合约。

2170
03:03:54.290 --> 03:04:00.427
然后你应该休息一下，吃点冰淇淋或咖啡，因为这是你应得的。

2171
03:04:00.427 --> 03:04:00.934
祝贺你。

2172
03:04:00.934 --> 03:04:07.978
在智能合约中，你要做的第一件事就是告诉合约的稳固性，你要使用哪种版本的稳固性。

2173
03:04:07.978 --> 03:04:15.453
此外，您还需要添加spdx许可证标识符，然后必须创建契约对象并为契约命名。

2174
03:04:15.453 --> 03:04:23.848
坚固性中的契约类似于其他编程语言中的类，弯弯曲曲的括号内的所有内容都是该契约的一部分。

2175
03:04:23.848 --> 03:04:31.410
固体性中有许多不同的类型，如无符号整数、256、布尔字符串、字节、32等。

2176
03:04:31.410 --> 03:04:36.128
如果我们想创建一个新类型，我们可以创建一个叫做固体结构的东西。

2177
03:04:36.128 --> 03:04:42.254
你可以在实体中创建数组或列表，你可以在实体中创建字典，或者

2178
03:04:42.254 --> 03:04:48.593
所谓的映射或散列表，当你给它一个键时，它会吐出键所代表的值。

2179
03:04:48.593 --> 03:04:52.586
我们可以在固体中创建函数来修改区块链的状态。

2180
03:04:52.586 --> 03:04:58.936
我们还可以在实体中创建函数，它不会在纯函数中修改区块链视图的状态，

2181
03:04:58.936 --> 03:05:05.286
也不会通过区块链的状态进行修改，我们还可以在函数中指定不同的数据位

2182
03:05:05.286 --> 03:05:11.637
置，称为数据和内存，意味着数据只是临时的，只会在函数运行期间存在。

2183
03:05:11.637 --> 03:05:14.575
存储变量是永久的，永远停留在那里。

2184
03:05:14.575 --> 03:05:19.628
函数形参不能作为存储变量，因为它们只会在函数运行期间存在。

2185
03:05:19.628 --> 03:05:28.031
我们使用的所有固体性代码，当我们点击编译时，它实际上编译到这个Aetherium虚拟机规范。

2186
03:05:28.111 --> 03:05:29.744
稍后我们将进一步了解这些规范。

2187
03:05:30.111 --> 03:05:36.825
但最重要的是，再次恭喜你签了第一份合同。

2188
03:05:37.111 --> 03:05:37.111
太棒了。

2189
03:05:37.111 --> 03:05:42.444
好，我们开始讲第三课，记住，所有东西都在GitHub存储库中。

2190
03:05:42.444 --> 03:05:46.207
我们可以向下滚动，点击第三课，查看所有代码。

2191
03:05:46.207 --> 03:05:48.248
我一边拍，一边在积累这个记录。

2192
03:05:48.248 --> 03:05:53.185
在这第三课下面将会有更多的信息，而不仅仅是这里的代码，我们所有

2193
03:05:53.185 --> 03:05:58.282
的代码样本都以破折号f f c结尾，这是破折号自由代码营的意思。

2194
03:05:58.282 --> 03:06:04.172
如果你看到一个以F F C结尾的GitHub回购，知道这个仓库与这

2195
03:06:04.172 --> 03:06:10.062
门课相关，我将做一个快速的高水平的演练，我们将在这门课中构建什么。

2196
03:06:10.111 --> 03:06:14.289
所以您现在不需要编写代码，只需坐下来观看并享受。

2197
03:06:14.289 --> 03:06:17.888
在这节课中，我们将扩展到三种不同的契约。

2198
03:06:17.888 --> 03:06:23.628
假设我们希望能够从契约本身部署简单的存储契约。

2199
03:06:23.628 --> 03:06:29.050
是的，合约确实可以部署合约，我们将创建一个名为storage

2200
03:06:29.050 --> 03:06:35.195
factory。sole的合约，它将能够部署并与其他合约本身交互。

2201
03:06:35.195 --> 03:06:44.029
我们可以把它部署到JavaScript虚拟机，我们选择存储工厂，然后点击部署。

2202
03:06:44.029 --> 03:06:47.620
在我们下面的合同中，我们有很多不同的功能。

2203
03:06:47.620 --> 03:06:55.087
我们最上面的函数是这个叫crate simple storage contract的函数，我们可以点击它，它会为我们

2204
03:06:55.087 --> 03:07:02.554
创建一个简单的storage contract，然后我们可以继续与它交互，在IG 0处，它会保存一个喜爱的数字为1。

2205
03:07:02.554 --> 03:07:08.362
如果我们点击SF，得到0，就会得到1。

2206
03:07:08.362 --> 03:07:12.568
我们可以看到我们刚刚部署的简单存储契约的地址。

2207
03:07:12.568 --> 03:07:19.161
此外，我们还将学习一些坚固性特性，例如导入继承等等。

2208
03:07:19.161 --> 03:07:21.128
让我们开始吧。

2209
03:07:21.128 --> 03:07:24.915
记住，所有的代码都可以从GitHub存储库中获得。

2210
03:07:24.915 --> 03:07:31.006
所以，如果你迷路了，一定要回头看看这些合同。

2211
03:07:31.112 --> 03:07:34.724
现在我们回到了remix，我们有了简单的storage。soul。

2212
03:07:34.724 --> 03:07:40.080
如果你跳过了上一节，一定要去上完整的区块链固体课程，Jas。

2213
03:07:40.080 --> 03:07:44.568
向下滚动到第二课，欢迎混合并获取这段代码。

2214
03:07:44.568 --> 03:07:46.571
去简单的存储大底。

2215
03:07:46.571 --> 03:07:48.931
并复制粘贴这段代码到混音。

2216
03:07:48.931 --> 03:07:54.796
因为这就是我们要开始的地方，我们有一个简单的储存合同，这很好。

2217
03:07:54.796 --> 03:07:56.874
它允许我们存储最喜欢的号码。

2218
03:07:56.874 --> 03:08:01.579
它还允许我们在映射和数组中存储不同人的最喜欢的数字。

2219
03:08:01.579 --> 03:08:10.027
但如果我们想在这方面做得更深入，我们可以让合约为我们部署其他合约。

2220
03:08:10.112 --> 03:08:14.805
然后继续与其他合约中的合约进行交互，合约之

2221
03:08:14.805 --> 03:08:19.722
间的交互是稳健合约和智能合约的重要组成部分。

2222
03:08:19.722 --> 03:08:25.730
契约之间无缝交互的能力被称为可组合性。

2223
03:08:25.730 --> 03:08:28.901
智能合约是可组合的，因为它们可以很容易地相互交互。

2224
03:08:28.901 --> 03:08:34.612
当涉及到像defy这样的东西时，你可以让非常复杂的金融

2225
03:08:34.612 --> 03:08:40.536
产品非常容易地相互交互，因为它们的所有代码都在链上可用。

2226
03:08:40.536 --> 03:08:42.033
我们将学习如何做到这一点。

2227
03:08:42.033 --> 03:08:47.613
让我们保持简单的存储契约不变，我们创建一个新的契约，叫做存储工厂。

2228
03:08:47.613 --> 03:08:54.829
点击新建文件按钮输入storage, factory。salt。

2229
03:08:54.829 --> 03:08:57.160
我们先把这个关了。

2230
03:08:57.160 --> 03:09:00.250
让我们根据之前学过的知识来建立这个契约。

2231
03:09:00.250 --> 03:09:08.838
我们要做的第一件事是spdx许可标识符，我们要做MIT。

2232
03:09:08.838 --> 03:09:13.044
接下来我们总是需要的是固体版本。

2233
03:09:13.113 --> 03:09:18.890
我们会用pragma solidity我们可以用0。

2234
03:09:18.890 --> 03:09:18.953
7.

2235
03:09:18.953 --> 03:09:21.564
但对于这个，我们用(0,8)

2236
03:09:21.564 --> 03:09:25.161
然后加上胡萝卜，表示任何形式的。

2237
03:09:25.161 --> 03:09:26.467
8点左右就可以了。

2238
03:09:26.467 --> 03:09:31.672
然后加上合同名称，也就是存储工厂。

2239
03:09:31.672 --> 03:09:38.988
现在按下command S或者ctrl S或者到compile选项卡，点击compile，我们就有了常规的设置。

2240
03:09:38.988 --> 03:09:43.898
现在我们要创建一个函数，它可以实际部署简单的存储契约。

2241
03:09:43.898 --> 03:09:47.258
我们将创建一个函数，叫做function。

2242
03:09:47.258 --> 03:09:52.495
创建一个简单的存储契约，我们会让它是公共的，所以任何

2243
03:09:52.495 --> 03:09:57.935
人都需要部署一个简单的存储契约并将其保存到全局变量中。

2244
03:09:57.935 --> 03:10:04.949
但是在我们这样做之前我们的储存工厂合同怎么知道我们的简单储存合同是什么样的呢?

2245
03:10:04.949 --> 03:10:11.964
为了部署它，如果我们的存储工厂合同要部署简单存储，它就需要知道简单存储的代码。

2246
03:10:11.964 --> 03:10:19.430
一种方法是我们可以到简单的storage。soul复制pragma, solidity下面的所有东西然

2247
03:10:19.430 --> 03:10:27.043
后粘贴到我们的storage factory。soul里pragma, solidity下面的所有东西。

2248
03:10:27.114 --> 03:10:33.876
如果我们编译并保存它，它会运行在我们的存储工厂中，灵魂契约里面有两个契约。

2249
03:10:33.876 --> 03:10:40.877
它有一个简单的存储契约，里面有一个存储工厂契约，你可以到deploy选项卡，向下

2250
03:10:40.877 --> 03:10:47.878
滚动到deploy当你在存储工厂。soul上时，而不是在存储工厂上的简单存储，你

2251
03:10:47.878 --> 03:10:55.232
可以看到你可以选择部署其中一个契约，一个solidity文件可以容纳多个不同的契约。

2252
03:10:55.232 --> 03:11:01.911
现在我们有了简单的存储，这些都在存储工厂中，我们可以继续创建这个函数来部署一个简单的存储

2253
03:11:01.911 --> 03:11:07.831
控制台，我们会创建一个全局变量和创建其他全局变量的方法一样，我们会做这个类型，

2254
03:11:07.831 --> 03:11:15.271
它将是type simple storage contract，我们会给它一个可见性public。

2255
03:11:15.271 --> 03:11:17.823
我们给它一个变量名。

2256
03:11:17.823 --> 03:11:24.050
Type simple storage contract将为public，变量名将为simple storage。

2257
03:11:24.114 --> 03:11:28.652
在我们的函数中，创建简单存储契约，我们会说simple

2258
03:11:28.652 --> 03:11:33.864
storage = new, simple storage。

2259
03:11:34.114 --> 03:11:39.685
这个新关键词是，实体如何知道啊，好吧，我们将部署一个新的简单的存储合同。

2260
03:11:39.685 --> 03:11:47.415
我们继续编译这个，到deploy选项卡，确保我们在JavaScript VM上，向下滚动到契约。

2261
03:11:47.415 --> 03:11:49.336
我们会选择储存工厂。

2262
03:11:49.336 --> 03:11:52.915
记住，你需要选择存储工厂。灵魂。

2263
03:11:52.915 --> 03:11:59.257
为了显示存储工厂，我们将继续并点击Deploy。

2264
03:11:59.257 --> 03:12:03.572
现在我们看到我们的储存工厂合同有两个按钮。

2265
03:12:03.572 --> 03:12:09.050
一个是创建简单存储，另一个是简单存储契约的视图。

2266
03:12:09.050 --> 03:12:15.180
如果我们现在点击它，它会显示它目前在地址0处，因为它被初始化为空白。

2267
03:12:15.180 --> 03:12:18.555
它说目前没有部署简单的存储合同。

2268
03:12:18.555 --> 03:12:22.085
现在，如果我们打开控制台并单击create simple storage，

2269
03:12:22.085 --> 03:12:28.193
可以看到我们创建了一个名为storage factory。create simple storage contract的新函数。

2270
03:12:28.193 --> 03:12:34.089
在此过程中，我们调用了这个函数它创建并部署了一个新的简单存储契约，我们现在

2271
03:12:34.089 --> 03:12:39.985
可以看到简单存储契约的地址通过点击简单存储按钮我们可以看到与之关联的地址。

2272
03:12:39.985 --> 03:12:43.598
现在我们知道了契约是如何部署另一个契约的。

2273
03:12:43.598 --> 03:12:48.663
但问题是，在我们的存储工厂上面放这么多代码有点多余，特别是我

2274
03:12:48.663 --> 03:12:53.729
们还有一个名为Simple storage。soul的文件。

2275
03:12:53.729 --> 03:12:58.418
假设我们有一个合同里面有很多其他的合同。

2276
03:12:58.418 --> 03:13:01.915
总是复制粘贴所有这些合同将是大量的工作。

2277
03:13:01.915 --> 03:13:05.839
相反，我们能做的是使用所谓的导入。

2278
03:13:05.839 --> 03:13:08.860
我们删掉合约简单存储。

2279
03:13:08.860 --> 03:13:15.622
然后输入import。斜杠simple storage。soul。

2280
03:13:15.622 --> 03:13:22.061
这个import。slash simple storage。Seoul和复制粘贴版本的simple storage完全一样。

2281
03:13:22.115 --> 03:13:22.896
这是所有。

2282
03:13:27.115 --> 03:13:33.807
package或GitHub，我们待会再看另一个文件然后说，我们要把合同

2283
03:13:33.807 --> 03:13:40.499
粘贴到这个合同的顶部我们回到编译，然后部署，删除旧的合同，我们可以再次看

2284
03:13:40.499 --> 03:13:47.191
到storage factory。soul，我们可以部署，点击下拉菜单。

2285
03:13:47.191 --> 03:13:50.508
同样，我们可以运行完全相同的函数。

2286
03:13:50.508 --> 03:13:55.417
像这样导入我们的契约比总是复制粘贴代码要好得多。

2287
03:13:55.417 --> 03:14:02.303
通过这种方式，如果我们想要在简单存储中更改某些内容，我们只需在一个规范的位置进行更改，而不必在多个不同的位置进行更改。

2288
03:14:02.303 --> 03:14:07.895
另外，你会注意到pragma和soidity如果我们的合约在两个单独的文件中，

2289
03:14:07.895 --> 03:14:13.202
我们实际上可以有不同版本的soidity现在我们的存储工厂有胡萝卜零点8。

2290
03:14:13.202 --> 03:14:16.650
这意味着任何在。

2291
03:14:16.650 --> 03:14:19.200
这份合同的8个范围是可以的。

2292
03:14:19.200 --> 03:14:23.952
但对于简单的储存，它说的是零点8。

2293
03:14:23.952 --> 03:14:25.591
8及以上范围都可以。

2294
03:14:25.591 --> 03:14:30.197
如果我们要改变编译器版本8。

2295
03:14:30.197 --> 03:14:38.689
然后继续编译，一个混音会自动把它提升到一个更好的版本，与它们都兼容，在这种情况下是8点13。

2296
03:14:38.689 --> 03:14:45.589
但如果我们，例如，把存储工厂的固态版本改成零点7。

2297
03:14:45.589 --> 03:14:48.179
然后尝试编译它们。

2298
03:14:48.179 --> 03:14:54.590
我们实际上最终得到一个问题解析器错误源文件需要一个不同的编译器版本。

2299
03:14:54.590 --> 03:14:59.181
这是因为我们的存储工厂说，0中的任何东西。

2300
03:14:59.181 --> 03:15:00.410
7表示可以。

2301
03:15:00.410 --> 03:15:05.488
然而，我们的简单存储表示的是0点8内的任何值。

2302
03:15:05.488 --> 03:15:06.776
8及以上都可以。

2303
03:15:06.776 --> 03:15:09.063
所以这两个版本是不兼容的。

2304
03:15:09.063 --> 03:15:13.751
所以我们需要做的是我们需要确保我们的固体版本确实是兼容的。

2305
03:15:13.751 --> 03:15:16.481
让我们把版本改回来重新编译。

2306
03:15:16.481 --> 03:15:18.278
现在我们看起来又不错了。

2307
03:15:18.278 --> 03:15:26.878
既然我们有这个创建简单存储契约，每次我们调用它，它就会替换当前在公共简单存储变量中的东西。

2308
03:15:26.878 --> 03:15:33.027
让我们继续并更新它，这样我们就可以实际保持所有已部署的简单存储契约的运行列表。

2309
03:15:33.027 --> 03:15:41.444
这不是一个单独的变量，而是一个简单存储数组或列表公共简单存储数组。

2310
03:15:41.444 --> 03:15:49.017
现在，每当我们创建一个新的简单存储契约时，我们不会像这样保存它，我们要做

2311
03:15:49.017 --> 03:15:56.591
的是我们将它保存为一个内存变量通过说简单存储，简单存储等于新的简单存储。

2312
03:15:56.591 --> 03:16:00.942
我们要把这个变量加到简单的存储数组中。

2313
03:16:00.942 --> 03:16:09.548
和之前一样，这里是简单的存储数组。push，简单的存储。

2314
03:16:09.548 --> 03:16:14.450
所以我应该拼写storage，对吧?让我们继续编译，看起来不错。

2315
03:16:14.450 --> 03:16:17.783
我们将部署存储工厂部署。

2316
03:16:17.783 --> 03:16:24.828
就像这里，我们有简单的存储阵列视图按钮，我们会创建简单的存储。

2317
03:16:24.828 --> 03:16:27.367
现在我们可以查看简单的存储契约0。

2318
03:16:27.367 --> 03:16:29.429
现在一点钟什么都没有。

2319
03:16:29.429 --> 03:16:37.950
但是如果我们创建另一个简单存储契约，我们可以在索引1处看到新的简单存储契约地址。

2320
03:16:38.117 --> 03:16:43.053
好的，这很好，我们现在可以跟踪我们所有的简单存储部署。

2321
03:16:43.117 --> 03:16:49.492
但我们如何与它们交互呢，假设我们想在所有的简单存储器上调用store

2322
03:16:49.492 --> 03:16:55.868
函数从我们的存储工厂，你可以把存储工厂想象成所有简单存储器的管理者。

2323
03:16:55.868 --> 03:16:59.052
这就是我们要做的，我们来创建一个新函数。

2324
03:16:59.052 --> 03:17:07.024
我们创建一个函数，叫它sf store，它代表存储工厂商店。

2325
03:17:07.118 --> 03:17:13.939
它将花费你256，简单存储索引，和一

2326
03:17:13.939 --> 03:17:20.760
个UNT 256，下划线简单存储号。

2327
03:17:20.760 --> 03:17:23.893
还会有公开拍卖。

2328
03:17:23.893 --> 03:17:29.071
为了让你与任何合同互动，你总是需要两个东西。

2329
03:17:29.071 --> 03:17:31.514
我们会经常用到它。

2330
03:17:31.514 --> 03:17:38.243
您总是需要合同的地址和合同的ABI。

2331
03:17:38.243 --> 03:17:43.779
API代表应用程序二进制接口，API会精确地告诉我

2332
03:17:43.779 --> 03:17:49.537
们的代码如何与契约交互，我们将在后面深入讨论API。

2333
03:17:49.537 --> 03:17:53.790
但如果你到编译选项卡，点击编译，东西就在编译。

2334
03:17:53.790 --> 03:17:57.265
您可以向下滚动，并可以看到编译细节。

2335
03:17:57.265 --> 03:18:01.810
你可以在不同的合同上看到一大堆信息。

2336
03:18:01.810 --> 03:18:07.593
你可以看到合约的名称，对于我们的简单存储合约就是简单存储，你

2337
03:18:07.593 --> 03:18:13.569
可以看到一大堆元数据，比如编译器，语言输出设置，所有这些东西。

2338
03:18:13.569 --> 03:18:17.660
您可以看到确切的字节码和操作码，我们将在稍后讨论这些内容。

2339
03:18:17.660 --> 03:18:24.970
你还可以看到这个API，这个API告诉你所有不同的输入和输出以及你可以用这个契约做的所有事情。

2340
03:18:24.970 --> 03:18:32.506
例如，在我们的简单存储中，如果我们查看API索引的0，我们有一个函数add person。

2341
03:18:32.506 --> 03:18:38.752
第一个是name to favorite number，第二个是people，第

2342
03:18:38.752 --> 03:18:44.998
三个是retrieve for store，它告诉我们所有与合约交互的不同方式。

2343
03:18:44.998 --> 03:18:52.542
我们可以调用的不同函数，我们知道地址在哪里，因为我们把它们存储在这个数组中，我们的简单存储数组，我们还

2344
03:18:52.542 --> 03:19:00.086
能得到API因为我们导入simple storage。soul当你编译simple storage时。

2345
03:19:00.086 --> 03:19:04.748
正如您在编译详细信息中看到的，无论何时编译它，它都预先

2346
03:19:04.748 --> 03:19:09.584
打包了ABI，我们只需像这样导入它就可以自动获得ABI。

2347
03:19:09.584 --> 03:19:13.896
在未来，我们会看到其他方法我们可以很容易地获得API。

2348
03:19:13.896 --> 03:19:19.803
要在某个契约上调用store函数，我们首先需要获取契约对象。

2349
03:19:19.803 --> 03:19:26.151
我们能做的是，我们可以说simple storage变量叫做simple storage。

2350
03:19:26.151 --> 03:19:34.532
变量名simple storage类型的simple storage将等于一个simple storage对象。

2351
03:19:34.532 --> 03:19:40.566
不像我们上次做的那样，我们只需要把这个简单存储

2352
03:19:40.566 --> 03:19:46.864
对象的地址放在这里，同样，我们可以从数组中获取。

2353
03:19:46.864 --> 03:19:50.085
在这个函数中，我们传递的是数组下标。

2354
03:19:50.085 --> 03:19:57.031
我们可以说简单存储契约在地址简单存储阵列。

2355
03:19:57.031 --> 03:20:01.220
At index simple存储索引。

2356
03:20:01.220 --> 03:20:06.452
这个括号表示的是访问数组中不同元素的方式。

2357
03:20:06.452 --> 03:20:12.730
如果我们想让列表的第0个元素在这里，简单存储索引就会是0，我们把它传递

2358
03:20:12.730 --> 03:20:19.008
到这里，这就会给我们简单存储契约的地址，我们把它传递到这里的简单存储。

2359
03:20:19.008 --> 03:20:26.841
因为这是一个简单存储契约数组，所以我们可以使用索引访问这个简单存储契约。

2360
03:20:26.841 --> 03:20:31.988
简单存储，边数组下标

2361
03:20:31.988 --> 03:20:37.136
下划线简单存储下标。

2362
03:20:37.136 --> 03:20:44.977
现在我们将契约对象保存在index simple storage index到我们的simple storage变量。

2363
03:20:44.977 --> 03:20:48.523
我们的数组在为我们记录地址。

2364
03:20:48.523 --> 03:20:52.638
它会自动伴随ABI在这里。

2365
03:20:52.638 --> 03:20:57.504
如果这只是契约对象的地址数组，那么我们就必

2366
03:20:57.504 --> 03:21:02.370
须像这样将地址包装在一个简单的存储对象中。

2367
03:21:02.370 --> 03:21:04.361
但我们以后会讲到。

2368
03:21:04.361 --> 03:21:08.995
现在，我们要做的就是这个我们现在有了一个简单的存储契约对象。

2369
03:21:08.995 --> 03:21:14.182
现在我们有了它，就可以在简单存储契约上调用store函数了。

2370
03:21:14.182 --> 03:21:18.320
我们称之为simple storage。store。

2371
03:21:18.320 --> 03:21:23.691
我们会把简单存储号存储到它里面。

2372
03:21:23.691 --> 03:21:24.453
这太完美了。

2373
03:21:24.453 --> 03:21:28.310
如果我们现在部署这个，我们就不能读取store函数。

2374
03:21:28.310 --> 03:21:33.693
因此，让我们创建另一个函数，它可以从存储工厂的简单存储契约中读取数据。

2375
03:21:33.693 --> 03:21:37.672
我们会创建一个名为sfget的函数，

2376
03:21:37.672 --> 03:21:44.747
它代表存储工厂get，它会取一个un256下划线的简单存储索引。

2377
03:21:44.747 --> 03:21:51.136
这将是一个公共视图函数，因为我们将从简单存储契约中读取数据。

2378
03:21:51.136 --> 03:21:53.358
它会返回一个unt256。

2379
03:21:53.358 --> 03:21:56.963
我们说简单存储。

2380
03:21:57.121 --> 03:21:59.666
简单的存储。

2381
03:22:01.121 --> 03:22:06.603
当你从上面这里使用同样的语法在简单存储索引处获取契约简单存储数组时。

2382
03:22:06.603 --> 03:22:13.351
然后我们会做返回，简单的存储。

2383
03:22:13.351 --> 03:22:19.187
重新检索得到我们刚刚存储在这里的数字。

2384
03:22:19.187 --> 03:22:23.041
我应该拼写正确，这样就不会出问题了。

2385
03:22:23.041 --> 03:22:23.548
完美的。

2386
03:22:23.548 --> 03:22:28.888
现在我们要编译，部署JAVA脚本，我们要处理一个假

2387
03:22:28.888 --> 03:22:34.443
账户，我们要使用我们的存储工厂，删除目前所有的合约。

2388
03:22:34.443 --> 03:22:37.580
让我们继续部署下拉速率。

2389
03:22:37.580 --> 03:22:42.465
现在如果SF get在0处，我们什么都得不到。

2390
03:22:42.465 --> 03:22:45.261
简单存储地址0将是零。

2391
03:22:45.261 --> 03:22:47.822
让我们创建一个简单的存储合同。

2392
03:22:47.822 --> 03:22:52.667
这是一个简单的存储列表，我们得到的地址是0。

2393
03:22:52.667 --> 03:22:56.963
如果我们现在按SF，它不是0，我们得到0。

2394
03:22:57.121 --> 03:23:00.727
让我们在这个合约上存储一个值。

2395
03:23:02.121 --> 03:23:03.137
这个契约是零。

2396
03:23:05.121 --> 03:23:06.002
存储索引。

2397
03:23:06.002 --> 03:23:08.781
我们要拯救数字7。

2398
03:23:09.121 --> 03:23:11.025
我们就开顺丰店吧。

2399
03:23:13.121 --> 03:23:17.527
将值7存储到契约中。

2400
03:23:18.121 --> 03:23:22.537
我们现在SF得到0，它确实返回7。

2401
03:23:23.121 --> 03:23:26.803
如果用SF，我们什么都不会发生。

2402
03:23:27.121 --> 03:23:29.621
我们会得到这个revert error。

2403
03:23:30.121 --> 03:23:32.053
创建另一个简单的存储契约。

2404
03:23:33.122 --> 03:23:37.056
一，我们得到0，因为我们会得到默认值。

2405
03:23:37.122 --> 03:23:43.681
让我们继续简单的存储合同，索引1将存储数字16将进入顺丰商店。

2406
03:23:43.681 --> 03:23:46.522
现在我们做SF，得到一个，得到16个。

2407
03:23:46.522 --> 03:23:50.755
现在请随意暂停，尝试一下，这样你就能真正理解它。

2408
03:23:50.755 --> 03:23:58.256
快速回顾一下，我们的存储工厂契约允许我们创建简单的存储契约，然后将它保存到我们

2409
03:23:58.256 --> 03:24:05.758
的简单存储阵列中，然后我们可以调用不同的函数，我们可以从存储工厂契约中存储值。

2410
03:24:05.758 --> 03:24:12.511
然后我们可以从我们的存储工厂合同中读取我们创建的任何简单存储合同的值。

2411
03:24:12.511 --> 03:24:17.622
这是非常强大的，我们可以使这两个函数更加简单。

2412
03:24:17.622 --> 03:24:23.455
当我们调用简单存储阵列时，我们可以直接在此调用Retrieve函数。

2413
03:24:23.455 --> 03:24:27.728
然后我们用括号加上简单存储索引。

2414
03:24:27.728 --> 03:24:29.575
这将返回一个简单的存储对象。

2415
03:24:29.575 --> 03:24:35.995
我们能做的是删除这整部分然后在这里做点检

2416
03:24:35.995 --> 03:24:42.415
索，然后删除这一行，然后返回，就像这样。

2417
03:24:42.415 --> 03:24:46.372
如果您继续并保存或点击Compile，您将在那里看到绿色的复选标记。

2418
03:24:46.372 --> 03:24:50.103
我们调用的是检索函数。

2419
03:24:50.103 --> 03:24:53.535
不管这是什么，都是一个简单的存储对象。

2420
03:24:53.535 --> 03:24:54.293
如此完美。

2421
03:24:54.293 --> 03:25:01.391
我们可以在上面做同样的事情删除这部分然后点。

2422
03:25:01.391 --> 03:25:08.490
store，下划线，简单存储边号，然后保存。

2423
03:25:08.490 --> 03:25:10.384
这是完全一样的。

2424
03:25:10.384 --> 03:25:15.448
太棒了，我们现在有了一个简单的存储契约，它可以在存储工厂契约中存储变量，这

2425
03:25:15.448 --> 03:25:20.649
个存储工厂契约几乎可以像这些简单存储契约的管理器一样，部署并与它们本身交互。

2426
03:25:20.649 --> 03:25:22.623
这太棒了。

2427
03:25:22.623 --> 03:25:30.418
现在，假设我们非常喜欢这个简单的存储契约，但它不能完全满足我们的要求。

2428
03:25:30.418 --> 03:25:35.213
也许我们想要这样，当我们实际存储值不存储喜爱的数字时，

2429
03:25:35.213 --> 03:25:43.384
它存储喜爱的数字加5，出于某种原因，你想要一个契约每个人的喜爱的数字比他们想象的大5个数字。

2430
03:25:43.384 --> 03:25:46.767
但你真的很喜欢这份合同的其他条款。

2431
03:25:46.767 --> 03:25:48.778
让我们创建这个新契约。

2432
03:25:48.778 --> 03:25:50.984
我们称之为额外存储空间。

2433
03:25:51.123 --> 03:25:55.984
我们写入extra storage。soul。

2434
03:25:56.123 --> 03:26:02.331
我们会创建这个新合约，我们会像通常一样设置spdx许

2435
03:26:02.331 --> 03:26:08.539
可标识符，我们会给它pragma solidity。

2436
03:26:08.539 --> 03:26:12.748
我们用(0,8)

2437
03:26:12.748 --> 03:26:14.265
胡萝卜是0。

2438
03:26:14.265 --> 03:26:22.694
我们会说契约，额外存储如果你保存或编译，你会得到绿色的勾选标记。

2439
03:26:22.694 --> 03:26:27.130
那么我们能做什么呢?我们能做的第一件事就是复制

2440
03:26:27.130 --> 03:26:31.759
粘贴所有这些代码到这里，然后修改额外的存储契约。

2441
03:26:31.759 --> 03:26:33.565
这看起来有点多余。

2442
03:26:33.565 --> 03:26:34.794
不过还有很多工作要做。

2443
03:26:34.794 --> 03:26:42.991
还有什么方法能让额外的存储合同和简单的存储合同一样呢?这里我们可

2444
03:26:42.991 --> 03:26:51.189
以做继承，我们可以有额外的存储契约，也就是简单存储契约的子契约。

2445
03:26:51.189 --> 03:26:59.039
我们可以有额外的存储空间，用两行代码继承简单存储的所有功能。

2446
03:26:59.124 --> 03:27:05.435
因此，首先，为了让额外的存储契约了解简单存储，我们再次需要导入它。

2447
03:27:05.435 --> 03:27:10.224
我们写入import。斜杠，simple storage。soul。

2448
03:27:10.224 --> 03:27:17.047
我们的合同额外存储是简单存储。

2449
03:27:17.047 --> 03:27:19.877
我们保存或编译。

2450
03:27:20.124 --> 03:27:25.801
额外的存储契约和简单的存储契约是一样的。

2451
03:27:25.801 --> 03:27:29.374
它会继承简单存储的所有功能。

2452
03:27:29.374 --> 03:27:34.058
我们甚至可以看到，让我们继续，确保这是编译好的。

2453
03:27:34.124 --> 03:27:35.708
我们将部署它。

2454
03:27:37.124 --> 03:27:45.098
我们可以看到我们有额外的存储部署了所有简单存储的功能，如果你想要一个

2455
03:27:45.098 --> 03:27:53.073
契约继承另一个契约的所有功能，你可以导入它，说你的契约是另一个契约。

2456
03:27:53.073 --> 03:27:57.470
现在，我们可以向额外的存储契约添加额外的函数。

2457
03:27:57.470 --> 03:28:00.600
这将包括简单存储的所有功能。

2458
03:28:00.600 --> 03:28:04.031
现在，假设我们将简单存储继承为额外存储。

2459
03:28:04.031 --> 03:28:08.253
然而，简单存储中的一个函数我们并不喜欢。

2460
03:28:08.253 --> 03:28:13.825
如果我们回到我们的简单存储契约，我们的存储函数，它所做的就是取一

2461
03:28:13.825 --> 03:28:19.398
个喜爱号，然后将全局喜爱号赋值给我们在额外存储中赋予它的新号码。

2462
03:28:19.398 --> 03:28:21.861
我们希望store函数做一些不同的事情。

2463
03:28:21.861 --> 03:28:26.222
我们想让它加5，给它的任何数。

2464
03:28:26.222 --> 03:28:30.387
我们怎样才能做到这一点呢?我们可以重写函数。

2465
03:28:30.387 --> 03:28:33.366
我们会用到两个关键词。

2466
03:28:33.366 --> 03:28:35.572
它们是虚拟的，和覆盖。

2467
03:28:35.572 --> 03:28:41.072
现在，如果我要实现一个存储函数来增加存储空间，让我们看看会发生什么。

2468
03:28:41.072 --> 03:28:46.546
我们说函数商店，你到最喜欢的数字6。

2469
03:28:46.546 --> 03:28:49.315
会有一个公共活动。

2470
03:28:49.315 --> 03:28:54.361
我们不只是存储最喜欢的数字，我们说

2471
03:28:54.361 --> 03:28:59.705
最喜欢的数字等于最喜欢的数字，加5。

2472
03:28:59.705 --> 03:29:05.196
如果我们现在编译这个，我们会遇到两个不同的错误。

2473
03:29:05.196 --> 03:29:09.711
第一个会说，override function is missing, override specifier。

2474
03:29:09.711 --> 03:29:16.329
如果父契约，也就是简单存储有相同的函数，我们需要告诉实体我

2475
03:29:16.329 --> 03:29:22.948
们要重写这个store函数取而代之的是这个store函数。

2476
03:29:22.948 --> 03:29:27.682
另外，我们会得到另一个错误说试图重写非虚函数。

2477
03:29:27.682 --> 03:29:32.369
为了使函数可覆盖，您是否忘记添加virtual，

2478
03:29:32.369 --> 03:29:37.056
您需要向store函数添加virtual关键字。

2479
03:29:37.125 --> 03:29:38.819
现在它可以被重写了。

2480
03:29:41.125 --> 03:29:45.232
我们仍然有这个问题覆盖函数缺少覆盖说明符。

2481
03:29:45.232 --> 03:29:49.140
然后我们需要做的就是添加override来恢复功能。

2482
03:29:49.140 --> 03:29:54.029
现在，如果我们正确地保存所有编译文件，让我们继续并部署它。

2483
03:29:54.029 --> 03:29:55.997
我们把旧合同删掉吧。

2484
03:29:56.125 --> 03:29:57.571
JavaScript虚拟机权限帐户。

2485
03:29:59.125 --> 03:30:01.093
额外的store Reg，让我们继续部署。

2486
03:30:02.125 --> 03:30:03.267
存储合同。

2487
03:30:06.125 --> 03:30:09.075
以前，我们的store函数将存储确切的数字。

2488
03:30:09.125 --> 03:30:13.397
然而，如果我要存储5，它将存储5，加上5。

2489
03:30:13.397 --> 03:30:15.634
所以这里应该有10个。

2490
03:30:15.634 --> 03:30:21.322
让我们继续调用store，然后点击检索。

2491
03:30:21.322 --> 03:30:23.617
我们确实看到10在这里。

2492
03:30:23.617 --> 03:30:28.449
这就是我们如何进行继承，重写函数。

2493
03:30:28.449 --> 03:30:30.507
就是这样。

2494
03:30:30.507 --> 03:30:37.355
在本节中，您已经学习了大量用于拥有多个文件的非常强大的可靠性。

2495
03:30:37.355 --> 03:30:45.108
让我们快速概述一下我们所学到的内容，我们了解到我们可以使用new关键字从其他合同部署

2496
03:30:45.108 --> 03:30:52.862
合同，我们还了解到我们可以使用import关键字将其他合同导入到我们的合同和代码中。

2497
03:30:52.862 --> 03:31:00.376
import关键字与复制粘贴该文件到导入行位置相同，我们知道我们可以与其他契约交互。

2498
03:31:00.376 --> 03:31:02.813
只要我们有ABI和地址。

2499
03:31:02.813 --> 03:31:04.766
我们对ABI了解不多。

2500
03:31:04.766 --> 03:31:13.741
之后我们会学到更多，如果我们想要创建子契约并继承其他契约的功能，我们可以做继承。

2501
03:31:13.741 --> 03:31:20.190
继承功能的方法是使用is关键字并说我们的契约是另一个契约。

2502
03:31:20.190 --> 03:31:26.745
然而，如果我们想从父契约的功能进行更改，就必须重写该功能。

2503
03:31:26.745 --> 03:31:34.538
另外，我们必须将我们想要覆盖的函数设为虚拟现在我们可以有自己的store函数，做任何我们想要它做的事。

2504
03:31:34.538 --> 03:31:36.370
本节课到此结束。

2505
03:31:36.370 --> 03:31:40.660
再一次，给自己热烈的掌声，鼓励自己走到今天。

2506
03:31:40.660 --> 03:31:42.207
完成这一节。

2507
03:31:42.207 --> 03:31:46.902
你很快就得到了越来越先进的设备，所以一定要通过吃冰淇

2508
03:31:46.902 --> 03:31:51.598
淋、散步、发推特或在Reddit上发帖来庆祝小胜利。

2509
03:31:51.598 --> 03:31:56.953
恭喜你，你已经完成了这一部分。

2510
03:31:57.127 --> 03:31:58.161
好了，各位。

2511
03:31:58.161 --> 03:31:58.833
欢迎回来。

2512
03:32:00.127 --> 03:32:02.076
第四课混音Funmi。

2513
03:32:06.127 --> 03:32:09.076
可以在与本课程相关的GitHub知识库中找到。

2514
03:32:09.127 --> 03:32:13.110
我们将在这里与两个合同工作，其中一个是基础大底。

2515
03:32:13.110 --> 03:32:21.323
其中一个是价格转换Funmi。Sol将是一个合同，允许人们实际为集体商品提供资金。

2516
03:32:21.323 --> 03:32:27.801
人们可以将Aetherium，或polygon，或Avalanche，或Phantom，

2517
03:32:27.801 --> 03:32:34.280
或任何区块链原生代币发送到合同中，然后合同的所有者可以提取这些资金，做任何他们想做的事。

2518
03:32:34.280 --> 03:32:40.646
在将其部署到测试网络后，我们可以看到该合同的功能列表，这

2519
03:32:40.646 --> 03:32:47.241
将有两个红色按钮，用于标记我们的基金功能中的基金支付功能。

2520
03:32:47.241 --> 03:32:54.233
在我们的取款功能中，取款允许用户提取资金而基金允许

2521
03:32:54.233 --> 03:33:01.506
用户向合约中汇款，我们能做的是在交易中发送一些价值。

2522
03:33:01.506 --> 03:33:06.471
当我们调用这个基金函数时，我们能做的就是通过将一些

2523
03:33:06.471 --> 03:33:11.437
值粘贴到方法值部分来为这个合约提供一定数量的资金。

2524
03:33:11.437 --> 03:33:16.634
然后点击fund，我们将把钱送到部署合同中。

2525
03:33:16.634 --> 03:33:21.847
我们可以看到资助者的名单和这些地址的映射以及他们实际

2526
03:33:21.847 --> 03:33:27.061
向合同中投入了多少钱，然后我们可以从合同中提取资金。

2527
03:33:27.127 --> 03:33:33.073
但有一个特殊的例外情况只有部署这个合同的人可以把资金取出来。

2528
03:33:33.128 --> 03:33:36.075
一旦资金被取出，所有资金的金额将重置为零。

2529
03:33:36.075 --> 03:33:38.022
你兴奋吗?嗯，你应该害怕。

2530
03:33:38.128 --> 03:33:44.277
如果你已经完成了这一节，你已经完成了大部分的基础，你将准备好开始制

2531
03:33:44.277 --> 03:33:50.426
作更强大的智能合约，我们将使用通道价格feed来实际设置这些人应该

2532
03:33:50.426 --> 03:33:56.576
能够获得多少美元的资金而不是以太币，我们将在这里复习很多高级部分。

2533
03:33:56.576 --> 03:33:59.478
我会告诉你们哪些部分比较难消化。

2534
03:33:59.478 --> 03:34:02.851
所以你不需要把所有的时间都花在试图弄清楚到底发生了什么。

2535
03:34:02.851 --> 03:34:09.898
一定要使用GitHub回购为你的优势在这里和讨论选项卡保持与其他学习这一课的人联系。

2536
03:34:09.898 --> 03:34:12.160
好了，我们开始吧。

2537
03:34:12.160 --> 03:34:16.870
在这一点上，在混音中，你会有一些契约，简单的存储，存

2538
03:34:16.870 --> 03:34:21.581
储，工厂额外的存储，也许你刷新了混音，这些都消失了。

2539
03:34:21.581 --> 03:34:28.628
在这种情况下，确保你没有打开任何标签，我们将创建一个新的合同，叫做融资。

2540
03:34:28.628 --> 03:34:32.998
让我们开始创建我们的融资合同。

2541
03:34:32.998 --> 03:34:37.764
同样，我们希望它能够从用户那里获得资金和提

2542
03:34:37.764 --> 03:34:42.531
取资金，并设置以美元为单位的最低资金价值。

2543
03:34:42.531 --> 03:34:46.440
这就是我们在合同中要做的。

2544
03:34:46.440 --> 03:34:52.208
首先，让我们设置spdx许可我倾向于用MIT

2545
03:34:52.208 --> 03:34:58.240
做pragma solidity做插入0点8。

2546
03:34:58.240 --> 03:34:58.385
8.

2547
03:34:58.385 --> 03:35:01.603
我们会做bunbee。

2548
03:35:01.603 --> 03:35:02.258
太棒了。

2549
03:35:02.258 --> 03:35:05.718
我们会编译，看看效果是否不错。

2550
03:35:05.718 --> 03:35:06.504
他们确实做到了。

2551
03:35:06.504 --> 03:35:06.897
太好了。

2552
03:35:06.897 --> 03:35:08.011
让我们继续。

2553
03:35:08.011 --> 03:35:14.081
在我们开始创建所有的函数之前，让我们先加入我们要实现的不同的函数。

2554
03:35:14.129 --> 03:35:19.600
所以我们想要一个功能基金，让人们把钱投进去，我们想要一个功能

2555
03:35:19.600 --> 03:35:25.255
提取，或者这个合同的所有者实际上提取不同的出资人给我们的资金。

2556
03:35:25.255 --> 03:35:26.905
差不多就是这样了。

2557
03:35:26.905 --> 03:35:35.383
这是我们希望这个合同实现的两个主要功能，我们将实现更多的功能来帮助促进这两个功能。

2558
03:35:35.383 --> 03:35:37.535
我们先来看看基金。

2559
03:35:37.535 --> 03:35:39.279
让我们暂时取消取款。

2560
03:35:39.279 --> 03:35:40.779
让我们从乐趣开始。

2561
03:35:40.779 --> 03:35:44.004
我们希望任何人都能调用这个有趣的函数。

2562
03:35:44.004 --> 03:35:45.629
所以我们要公开这个。

2563
03:35:45.629 --> 03:35:52.269
如前所述，我们希望能够设置以美元为单位的最小字体数量。

2564
03:35:52.269 --> 03:35:54.472
这里有很多东西要考虑。

2565
03:35:54.472 --> 03:36:02.131
首先，我们可能要考虑的是，当我们在任何这些EVM区块链上创建交易时，我们如何向这个合同

2566
03:36:02.131 --> 03:36:09.970
发送eath，我们可以设置这个值字段，该值表示我们将在交易中发送多少Aetherium。

2567
03:36:09.970 --> 03:36:12.586
例如，当我们转让Aetherium时。

2568
03:36:12.586 --> 03:36:19.557
在我们不同的账户之间，我们实际上用不同数量的Aetherium填充了这个值参数。

2569
03:36:19.557 --> 03:36:28.374
事实上，我们发送的每一笔交易，都会有这些字段，它会有nonce或交易计数，帐户，汽油价格，

2570
03:36:28.374 --> 03:36:37.387
我们在以太上看到的汽油限额，扫描a，也就是交易发送到的地址，一个值就是我们正在讨论的这个值。

2571
03:36:37.387 --> 03:36:46.049
它们还会有我们发送的数据如果我们进行函数调用或部署契约，然后我们会有这个v r s组件。

2572
03:36:46.049 --> 03:36:54.930
我们不打算讲这些v r和s因为这是交易签署时发生的加密魔法，但要知道就是这样，对

2573
03:36:54.930 --> 03:37:03.812
于发送值，我们可以填充其中一些字段，例如气体限制，填充到21,000数据将为空。

2574
03:37:03.812 --> 03:37:08.738
然后这2将是我们想要发送到的事务的地址，对于函

2575
03:37:08.738 --> 03:37:13.880
数调用，我们仍然可以按照我们想要发送的方式填充。

2576
03:37:13.880 --> 03:37:18.595
我们可以调用一个函数，同时在remix中发送一个值这里有一个小的

2577
03:37:18.595 --> 03:37:23.458
下拉，是way Feeny和ether，我们现在先忽略Feeny。

2578
03:37:23.458 --> 03:37:25.708
但当然，我们有自己的方式，伟大的，伟大的。

2579
03:37:25.708 --> 03:37:28.581
我们是一个以太值这么多。

2580
03:37:28.581 --> 03:37:33.337
这样一来，为了让一个函数可以用Aetherium或任何其他原生

2581
03:37:33.337 --> 03:37:38.093
区块链货币支付，我们需要做的第一件事就是将该函数标记为可支付。

2582
03:37:38.093 --> 03:37:44.553
正是这个payable关键字让我们的字体功能变成了红色，而不是普通的

2583
03:37:44.553 --> 03:37:51.013
橙色，就像我们的钱包可以容纳资金一样，合同地址也可以容纳资金，因为每

2584
03:37:51.013 --> 03:37:57.664
次你部署一个合同，他们就会得到一个合同地址，它几乎与钱包地址完全相同。

2585
03:37:57.664 --> 03:38:04.049
所以钱包和合同都可以像Aetherium一样持有原生区块链代币。

2586
03:38:04.130 --> 03:38:10.505
你们会看到，当我们在后面的课程中使用这个时，它实际上会获得一个Aetherium的平衡。

2587
03:38:10.505 --> 03:38:14.814
既然它是可支付的，我们就可以通过使用带有message dot

2588
03:38:14.814 --> 03:38:21.487
value的solididity中的一个全局关键字来访问这个值属性，以获得某人发送的值的多少。

2589
03:38:21.487 --> 03:38:23.919
在函数中使用message。value。

2590
03:38:23.919 --> 03:38:29.064
现在，假设我们想将消息的add value设置为Aetherium的某个值。

2591
03:38:29.130 --> 03:38:36.791
假设我们想让它。假设我们想让人们用所有的交易发送至少一个以太。

2592
03:38:36.791 --> 03:38:41.416
换句话说，如果他们发送了Aetherium，他们至少需要发送一个Aetherium。

2593
03:38:41.416 --> 03:38:46.577
我们如何实现它?我们可以调用require，我们会

2594
03:38:46.577 --> 03:38:51.946
说我们想要求message。value大于1e18。

2595
03:38:51.946 --> 03:38:56.037
这里有几样东西要整理。

2596
03:38:56.037 --> 03:39:00.522
1 e18等于1乘以10的18次方，

2597
03:39:00.522 --> 03:39:07.499
也等于112345 678-910-1234 5678。

2598
03:39:07.499 --> 03:39:14.631
这是一个以太的价值，这是一个以太的价值。

2599
03:39:14.631 --> 03:39:19.937
如果我们想让message。value至少是一个eath，或者一个polygon，

2600
03:39:19.937 --> 03:39:25.115
或者什么ranch等等，我们会这样设置它，要求message。value大于1。

2601
03:39:25.115 --> 03:39:31.983
这个require关键字是一个检查器，它说，嘿，是否message。value大于1。

2602
03:39:31.983 --> 03:39:36.196
如果没有，它就会恢复，它会做所谓的带错误消息的恢复。

2603
03:39:36.196 --> 03:39:41.927
我们可以说，没有发送足够多，我们会试着在JavaScript VM上部署这个，

2604
03:39:41.927 --> 03:39:47.365
部署Funmi，点击部署，看Funmi我们看到这个fun按钮现在是红色的。

2605
03:39:47.365 --> 03:39:54.132
如果我们现在调用Funmi，我们看控制台，你可以看到我们在这里得到一个错误，再调用

2606
03:39:54.132 --> 03:40:00.900
它，我们得到一个错误，我们在这里得到一个错误，我们知道空气将是这个没有发送足够多。

2607
03:40:00.900 --> 03:40:09.669
所以我们需要做的是在这个有趣的事务中至少发送一个以太，以便这个require语句被实现。

2608
03:40:09.669 --> 03:40:14.359
回到值部分，我们可以把这个值改为1。

2609
03:40:14.359 --> 03:40:19.208
所以这是一个乙醚，或者这个方向，或者这个方向。

2610
03:40:19.208 --> 03:40:23.072
现在我们可以点击fundoh实际上需要大于1。

2611
03:40:23.132 --> 03:40:25.465
举个例子。

2612
03:40:25.465 --> 03:40:27.298
现在我们向下滚动。

2613
03:40:28.132 --> 03:40:29.007
我们会找到资金的。

2614
03:40:32.132 --> 03:40:37.390
语句表示，如果第一部分为false，则继续执行并返回此错误。

2615
03:40:37.390 --> 03:40:42.674
什么是还原?Revert可能有点令人困惑，所以我不会让这一节阻碍您的学习。

2616
03:40:42.674 --> 03:40:44.775
如果这有点让人困惑的话。

2617
03:40:44.775 --> 03:40:49.674
Revert是指撤销之前发生的任何操作，并将剩余的气体发送回。

2618
03:40:49.674 --> 03:40:56.386
那它到底是什么样子的呢?举个例子，我们有一个un 256。

2619
03:40:56.386 --> 03:40:57.809
公众的数量。

2620
03:40:57.809 --> 03:41:02.606
在基金函数中，数字等于5。

2621
03:41:02.606 --> 03:41:07.075
如果我们要继续部署它，让我们删除旧的契约。

2622
03:41:07.132 --> 03:41:10.615
部署这个新合同的数字现在是零。

2623
03:41:11.132 --> 03:41:14.439
我们把基金函数号设为5。

2624
03:41:14.439 --> 03:41:22.865
然而，如果我们调用一个基金，而这个要求没有得到满足，这个交易将恢复一个不适当的设置数字到5。

2625
03:41:22.865 --> 03:41:25.671
我们来看看这里的对数。

2626
03:41:25.671 --> 03:41:29.502
我们将值保持为0，这样我们的fun函数就会恢复。

2627
03:41:29.502 --> 03:41:36.953
我们调用fund会看到这个交易失败因为这个请求最终会返回，而number仍然是0。

2628
03:41:36.953 --> 03:41:44.390
那么问题就变成了，我们真的消耗了气体吗是的，我们消耗了气体把数字

2629
03:41:44.390 --> 03:41:51.827
变成5然后剩下的气体我们将通过这个要求返回例如，如果我们在这里有

2630
03:41:51.827 --> 03:41:59.266
大量的计算，在这里的计算中，我们需要用fun函数发送大量的气体。

2631
03:41:59.266 --> 03:42:05.689
但所有我们发送的额外气体，在这个require被返回后原始用户在它被还

2632
03:42:05.689 --> 03:42:12.296
原后，如果还原对你们来说有点困惑，不用太担心，我们会在以后的模块中讲到。

2633
03:42:12.296 --> 03:42:17.850
现在您所需要知道的是，当您执行require语句时，如果第一部分没有得

2634
03:42:17.850 --> 03:42:23.563
到满足，事务将被取消，之前的所有工作将被撤消，并且它将发送一个错误消息。

2635
03:42:23.563 --> 03:42:23.870
酷。

2636
03:42:23.870 --> 03:42:25.900
我们先把这个号码删掉。

2637
03:42:25.900 --> 03:42:28.396
我们会从全局作用域中删除它。

2638
03:42:28.396 --> 03:42:34.370
其实还有另一种方法来做这些还原，我们会在合同后面讲到。

2639
03:42:34.370 --> 03:42:37.929
到目前为止，我们做的很好。

2640
03:42:38.133 --> 03:42:43.192
然而，我们正在根据Aetherium检查消息的点值，

2641
03:42:43.192 --> 03:42:53.116
我们正在寻找一个完整的Aetherium而不是$50，我们想要检查消息的增加值大于某些数字，如$50。

2642
03:42:53.116 --> 03:43:01.046
让我们先设定我们希望人们随基金函数一起发送的最低美元价值，我们可以在

2643
03:43:01.046 --> 03:43:08.976
合同的顶部这样做，我们可以说你去了56个公共场所，最低美元等于50。

2644
03:43:08.976 --> 03:43:14.537
现在我们有一些地方可以检查最低美元，

2645
03:43:14.537 --> 03:43:20.098
我们将更新这个最低美元，使它更省油。

2646
03:43:20.098 --> 03:43:22.878
现在我们已经设置了最小USD，

2647
03:43:22.878 --> 03:43:29.180
我们希望能够要求value大于或者我们说大于或等于最小USD的消息。

2648
03:43:29.180 --> 03:43:36.134
但是最低美元是用美元来表示的，价值是用Aetherium来表示的。

2649
03:43:36.134 --> 03:43:43.899
所以我们如何将Aetherium转换成美元，这就是Oracle和chainlink将要发挥作用的地方。

2650
03:43:43.899 --> 03:43:49.135
Aetherium的美元价值是我们在区块链之外分配给Aethe

2651
03:43:49.135 --> 03:43:54.540
rium的，或者任何其他一层货币或任何其他本地智能合约平台货币。

2652
03:43:54.540 --> 03:43:59.004
因此，为了得到这个在区块链之外的值，我们必须使用去中心

2653
03:43:59.004 --> 03:44:03.634
化的Oracle网络来获得以美元表示的一个以太币的价格。

2654
03:44:03.634 --> 03:44:12.426
所以在我们继续之前，让我们更多地了解一下这些去中心化Oracle网络的体系结构以及它们所拥有的不同解决方案。

2655
03:44:12.426 --> 03:44:18.313
所以我们可以用最先进的方式创建Funmi契约，因为我们已经讨论过区

2656
03:44:18.313 --> 03:44:24.201
块链是确定性系统，这意味着它们本身不能与现实世界的数据和事件交互。

2657
03:44:24.201 --> 03:44:28.828
他们不知道Aetherium的价值，他们不知道随机数是什么。

2658
03:44:28.828 --> 03:44:34.667
他们不知道外面是不是晴天，他们不知道温度，他们不知道谁是总统，他们不知道这些信息。

2659
03:44:34.667 --> 03:44:38.134
这些区块链也不能进行任何外部计算。

2660
03:44:38.134 --> 03:44:43.555
也许您有一些了不起的人工智能模型，希望将其集成到智能合约中。

2661
03:44:43.555 --> 03:44:46.569
智能合约本身不能做任何事情。

2662
03:44:46.569 --> 03:44:50.212
正如我们所提到的，这是因为区块链在设计上是确定的。

2663
03:44:50.212 --> 03:44:52.848
这样所有的节点都能达成共识。

2664
03:44:52.848 --> 03:44:58.418
如果开始添加变量数据或随机数据，或从API调用返回的值，

2665
03:44:58.418 --> 03:45:03.591
不同的节点可能得到不同的结果，它们永远无法达成一致。

2666
03:45:03.591 --> 03:45:08.009
这被称为智能合约连接问题，或Oracle问题。

2667
03:45:08.009 --> 03:45:13.661
这是个坏消息，因为我们希望我们的智能合约能够取代传统的协议。

2668
03:45:13.661 --> 03:45:18.135
传统的协议需要数据，需要与现实世界互动。

2669
03:45:18.135 --> 03:45:21.965
这就是chainlink和区块链，Oracle的作用所在。

2670
03:45:21.965 --> 03:45:28.924
区块链Oracle将是任何与日常世界交互的设备，为智能合约提供外部数据或计算。

2671
03:45:28.924 --> 03:45:31.544
然而，整个故事甚至没有在那里。

2672
03:45:31.544 --> 03:45:36.935
如果我们使用集中式Oracle，就会重新引入一个故障点。

2673
03:45:36.935 --> 03:45:40.210
我们已经做了所有这些工作，使我们的逻辑层去中心化。

2674
03:45:40.210 --> 03:45:47.977
但是，如果我们通过集中的节点或集中的API获取数据，我们就会决定自己调用API。

2675
03:45:47.977 --> 03:45:56.023
我们正在重新引入这些信任假设，我们一直在努力摆脱这些假设，我们实际上正在破坏构建智能合约的整个目的。

2676
03:45:56.023 --> 03:46:01.447
所以我们不想通过集中的节点来获取数据或进行外部计算。

2677
03:46:01.447 --> 03:46:02.634
这些都是坏消息。

2678
03:46:02.634 --> 03:46:04.325
链条是解决方案。

2679
03:46:04.325 --> 03:46:10.827
chain link是一个分散的Oracle网络，用于将数据和外部计算引入我们的智能合约。

2680
03:46:10.827 --> 03:46:19.790
正如我们前面提到的，这产生了这些混合智能合约，它们结合了链上和链下，形成了功能丰富、功能强大的应用程序。

2681
03:46:19.790 --> 03:46:27.987
chain link是一个模块化、去中心化的Oracle网络，可以定制它来交付任何数据或进行任何您喜欢的外部计算。

2682
03:46:27.987 --> 03:46:36.053
例如，很多人说，哦，我可以对一些API进行HTTPS调用，然后我们就可以很好地进行了。

2683
03:46:36.135 --> 03:46:41.407
区块链节点不能进行这些HTTPS调用，因为它们无法达成共识。

2684
03:46:41.407 --> 03:46:44.685
如果它们在不同的时间调用节点，或者它们做了其他事情。

2685
03:46:44.685 --> 03:46:46.747
所有的共识都将被打破。

2686
03:46:46.747 --> 03:46:52.125
因此，我们需要一个分散的链链网络Oracle来做这件事，

2687
03:46:52.125 --> 03:46:57.504
然后在交易中，这个节点网络将为我们把数据转化为智能合约。

2688
03:46:57.504 --> 03:47:03.830
现在链链网络可以完全定制，带来任何你想要的数据或任何外部计算。

2689
03:47:03.830 --> 03:47:09.359
然而，进行定制可能需要一些额外的工作，有大量的链连接特性

2690
03:47:09.359 --> 03:47:15.086
可以完全去中心化，随时可以插入和使用到智能合约应用程序中。

2691
03:47:15.136 --> 03:47:20.656
这些特性是什么，第一个是数据传输通道，这是我们在应用中要用到的。

2692
03:47:20.656 --> 03:47:25.023
目前在记录的时候传输的数据超过了500亿美元。

2693
03:47:25.023 --> 03:47:33.869
在对抗世界,他们的工作方式是一个网络的链条节点获得数据从不同的交流和数据的提供者

2694
03:47:33.869 --> 03:47:42.715
和将数据通过网络分散链像笔记,链条节点使用一个值求出资产的实际价格是什么,然后交

2695
03:47:42.715 --> 03:47:51.785
付在单个事务中所谓的参考合同,饲料价格合同或者合同数据链,其他聪明的合同可以使用。

2696
03:47:51.785 --> 03:47:57.564
然后这些智能合约使用这些定价信息来支持它们的违抗程序，我们可以看到一个例子。

2697
03:47:57.564 --> 03:48:00.732
我们可以在data。chain。link看到一个例子。

2698
03:48:00.732 --> 03:48:07.823
你可以改变网络，你可以改变价格来源，你可以改变一大堆不同的信息来查看一些流行的价格来源。

2699
03:48:07.823 --> 03:48:10.010
让我们以每一美元为例。

2700
03:48:10.010 --> 03:48:17.040
在每一个美元上，我们可以看到这个由独立的链节点操作者组成的整个网络每个结点都

2701
03:48:17.040 --> 03:48:24.071
得到不同的答案，它们被网络聚合，然后在链上传递，我们可以看到它们更新的频率。

2702
03:48:24.136 --> 03:48:25.881
这些是更新的。

2703
03:48:28.136 --> 03:48:29.781
心跳一小时，看哪一个。

2704
03:48:31.136 --> 03:48:38.843
上次更新是我们可以看到Oracle的响应数量等，我们可以直接在链上看到合同地址，我们甚至

2705
03:48:38.843 --> 03:48:46.550
可以在以太扫描上查看合同，我们可以看到一些历史，我们可以看到不同Oracle的所有响应。

2706
03:48:46.550 --> 03:48:53.046
然后在底部，我们可以看到不同的用户和赞助商，保持这个网络。

2707
03:48:53.046 --> 03:48:58.151
与事务气体类似，每当节点操作符向智能合约交付数据时，链链

2708
03:48:58.151 --> 03:49:03.257
接节点操作符都会在链链接令牌中获得一点Oracle气体。

2709
03:49:03.257 --> 03:49:10.821
现在，协议的这些用户正在赞助保持这些提要，并支付与在链上传输数据相关的Oracle gas。

2710
03:49:10.821 --> 03:49:16.933
这里展示了这些数据提要的当前模型是什么样子的这些链连接节点组成的网

2711
03:49:16.933 --> 03:49:23.045
络，每个节点伸出手，获取关于资产的信息，然后在单个交易中用自己的私

2712
03:49:23.045 --> 03:49:29.530
钥签署数据，然后，一个节点将所有具有不同签名的数据交付到一个参考契约。

2713
03:49:29.530 --> 03:49:33.120
如果该节点不发送数据，则由另一个节点发送。

2714
03:49:33.120 --> 03:49:38.209
信誉是非常重要的，当你的链节点运营商如果你错过数据更新，如果你忘记

2715
03:49:38.209 --> 03:49:43.298
发送交易，你可能会很快被踢出这些网络，并没有机会在未来赚更多的钱。

2716
03:49:43.298 --> 03:49:49.171
这些数据源被该领域一些最大的协议所使用，例如合成，寿司交换化合

2717
03:49:49.171 --> 03:49:55.234
物，和Avi，每个协议都有数十亿美元，我们可以看看Doc的。链。

2718
03:49:55.234 --> 03:50:01.298
链工作与EVM合同的例子，我们将触及EVM链，向下滚动到数据源。

2719
03:50:01.298 --> 03:50:04.007
我们将向下滚动到固体部分。

2720
03:50:04.137 --> 03:50:10.975
我们可以看到一个完整的合同的例子，它使用并读取这些趋势价格提要中的一个。

2721
03:50:10.975 --> 03:50:15.575
我们甚至可以把它打开，然后混音，用它来混音。

2722
03:50:15.575 --> 03:50:19.280
看起来这个例子是从COVID的价格提要中读取的。

2723
03:50:19.280 --> 03:50:25.100
我们要用一个测试网络来观察这个工作的原因是有一组链接节点在监控测试网络。

2724
03:50:25.138 --> 03:50:27.441
让你们看看这到底是怎么回事。

2725
03:50:28.138 --> 03:50:35.915
深入本课程，我们将向您展示如何实际运行测试和使用链连接节点，而无需实际在测试网络上，这将使您的开发更快。

2726
03:50:35.915 --> 03:50:43.312
但是我强烈建议您和我一起浏览这一节，这样您就可以亲眼看到它是如何工作的。

2727
03:50:43.312 --> 03:50:46.388
让我们继续，水龙头。链条。链接斜线COVID。

2728
03:50:46.388 --> 03:50:51.400
我们将切换到新冠肺炎网络，我们将获得一些新冠肺炎的信息。

2729
03:50:51.400 --> 03:50:57.204
但请记住，查看网络标志并使用文档中的任何网络。

2730
03:50:57.204 --> 03:51:02.337
因此，为了获得COVID病毒，我们将来到水龙头，我们将关闭测试

2731
03:51:02.337 --> 03:51:07.471
链接，我们只需要和每个人呆在一起，我不是机器人，然后发送请求。

2732
03:51:07.471 --> 03:51:12.004
一旦我们的COVID Aetherium到达我们的钱包，我

2733
03:51:12.004 --> 03:51:16.695
们可以继续并关闭。我们可以查看我们的钱包，看到我们确实有0。

2734
03:51:16.695 --> 03:51:17.744
开尔文是1比1。

2735
03:51:17.744 --> 03:51:23.988
现在让我们回到我们的混合，我们将编译这个契约，并在注入的web 3上部署它。

2736
03:51:23.988 --> 03:51:28.610
我们使用注入web 3而不是JavaScript VM的原因

2737
03:51:28.610 --> 03:51:33.388
是没有链接节点的网络来监视我们的伪JavaScript VM。

2738
03:51:33.388 --> 03:51:36.852
有一个由链状节点组成的网络监视着测试网。

2739
03:51:36.852 --> 03:51:38.185
我们向下滚动。

2740
03:51:38.185 --> 03:51:44.458
我们将合同切换到价格消费者v3，然后点击部署，大量会弹出，在短暂的延迟之后，

2741
03:51:44.458 --> 03:51:50.400
我们可以看到价格供给消费者在这里，我们可以点击获取最新价格，这显示了以美

2742
03:51:50.400 --> 03:51:56.839
计算的Aetherium的最新价格你可能会好奇为什么这个数字看起来如此奇怪。

2743
03:51:56.839 --> 03:52:01.489
对于以美元计算的Aetherium价格来说，这似乎是一个很大的

2744
03:52:01.489 --> 03:52:06.289
数字，这是因为小数在固体中并不是很有效，我们稍后会讲到这个问题。

2745
03:52:06.289 --> 03:52:13.416
有一个与这个价格提要地址相关联的小数标记，它告诉我们这个价格包含多少小数。

2746
03:52:13.416 --> 03:52:15.138
文档中也有。

2747
03:52:15.138 --> 03:52:17.884
但是，我知道这个有8个小数点。

2748
03:52:17.884 --> 03:52:22.359
也就是说，Aetherium现在的价值是3262美元。

2749
03:52:22.359 --> 03:52:26.074
当然，当你继续尝试时，情况可能会有所不同。

2750
03:52:26.074 --> 03:52:30.696
在这个合同中发生了很多事情我会在Funmi的例子中解释。

2751
03:52:30.696 --> 03:52:35.089
但如果你现在想看一看，看看你是否能弄明白发生了什么，我建议你这样做。

2752
03:52:35.139 --> 03:52:43.549
价格信息是最强大的开箱即用的去中心化功能之一，您可以使用智能合约来升级它们，特别是对于去中心化金融。

2753
03:52:43.549 --> 03:52:49.502
如果您正在寻找不同价格提要的不同地址，您可以查看文档中的合同地址部

2754
03:52:49.502 --> 03:52:55.456
分，选择您想要的网络，然后向下滚动查看不同价格提要的一些不同地址。

2755
03:52:55.456 --> 03:53:01.021
例如，这个地址将给你一个英寸代币的价格，以Aetherium。

2756
03:53:01.021 --> 03:53:07.805
这个地址会告诉你苹果股票以美元计的价格，等等。

2757
03:53:07.805 --> 03:53:14.980
下一个开箱即用的去中心化应用将是引导VRF或引导可验证的随机功能障碍。

2758
03:53:14.980 --> 03:53:21.031
等我们做完彩票的例子后，我们将讨论如何在区块链中操纵随机性。

2759
03:53:21.031 --> 03:53:25.622
区块链是确定性系统，根据定义，这意味着它们不能有随机性。

2760
03:53:25.622 --> 03:53:31.714
如果你能确定一个随机数是什么，它就不再是随机的了，不是吗?因此，我们需要等待，通过查

2761
03:53:31.714 --> 03:53:37.806
看区块链之外的数据来得到一个可证明的随机数，而Oracle的数据正好可以做到这一点。

2762
03:53:37.806 --> 03:53:42.277
链链可验证随机函数是一种将可证明随机数引入智

2763
03:53:42.277 --> 03:53:46.953
能合约的方法，以保证应用程序的公平性和随机性。

2764
03:53:46.953 --> 03:53:54.261
许多协议，如将x∞组合在一起，以太卡，牛油果奶酪等，在彩票中使用通道VRF，

2765
03:53:54.261 --> 03:54:01.377
在游戏中使用随机NF T等等，我们将在后面的部分中做一个通道VRF的例子。

2766
03:54:01.377 --> 03:54:06.122
一旦我们进入彩票部分，如果你想看看你现在是否可以自己玩随机性，

2767
03:54:06.122 --> 03:54:10.868
我建议你进入Doc的链链接EVM链，并向下滚动获得一个随机数。

2768
03:54:10.868 --> 03:54:15.089
这将教你如何在应用程序中引入可证明的随机数。

2769
03:54:15.140 --> 03:54:22.597
下一个去中心化的开箱即用的链链特性是链式的保持器，它是去中心化的事件驱动执行。

2770
03:54:22.597 --> 03:54:27.637
正如我们所见，为了启动某种类型的交易，有人需要花汽油，

2771
03:54:27.637 --> 03:54:32.864
有人需要坐下来，按下开始按钮，按下交易按钮，或按下太阳。

2772
03:54:32.864 --> 03:54:34.486
但这显然是一个集中向量。

2773
03:54:34.486 --> 03:54:40.473
如果您有一个去中心化的应用程序，需要在特定时间运行，或者在特定事件触发后运行。

2774
03:54:40.473 --> 03:54:49.092
Channeling keepers是这种情况的解决方案，Channeling keepers是链式链接节点，侦听您指定要触发的不同事件的注册契约。

2775
03:54:49.092 --> 03:54:55.789
也许你说每隔10分钟，你想做点什么，或者一周做一次，或者如果某种酸的

2776
03:54:55.789 --> 03:55:02.683
价格达到某个数字，或者也许流动性池达到某个水平，无论你想编码什么事件，

2777
03:55:02.683 --> 03:55:09.381
你绝对可以让链连接节点不断监听这些触发发生并检查这些触发的不同合约。

2778
03:55:09.381 --> 03:55:15.733
一旦触发器返回true，链结节点就会执行你让链结节点做的任何动作，我们现

2779
03:55:15.733 --> 03:55:22.263
在也不打算复习链结keepers的例子，因为我们将在后面的模块中讲到它们。

2780
03:55:22.263 --> 03:55:26.761
然而，如果你想尝试一下，去Doc's触摸链接斜杠Aetherium。

2781
03:55:26.761 --> 03:55:31.630
去制作兼容的合同你们可以随意阅读文档。

2782
03:55:31.630 --> 03:55:32.528
你自己试试。

2783
03:55:32.528 --> 03:55:41.093
链条的最后一个开箱即用特性是最可定制的，但也是最难获得正确的端到端可靠性，这是我们智能合约的最终承诺。

2784
03:55:41.141 --> 03:55:47.485
我们希望它们能够做任何事情，我们希望能够接受任何输入并获得任何输出使HTTP

2785
03:55:47.485 --> 03:55:54.665
get HTTP POST请求是一种简单的方法来定制我们的链节点使其能够做任何事情。

2786
03:55:54.665 --> 03:56:00.496
还记得我们讲过如何使用API调用区块链节点本身可以做到吗?链链接节

2787
03:56:00.496 --> 03:56:06.327
点可以做到这一点，链链接节点可以直接向您指定的任何API发出请求。

2788
03:56:06.327 --> 03:56:12.771
为了做到这一点，您必须同时选择链接节点和URL斜杠数据来发送请求，

2789
03:56:12.771 --> 03:56:18.824
这比链接VRF保存器或价格提要要稍微复杂一些，因为您必须负责创

2790
03:56:18.824 --> 03:56:25.074
从许多不同的链接节点和许多不同的数据提供者获取数据的链接网络。

2791
03:56:25.141 --> 03:56:27.953
但让我们看一个混音的例子。

2792
03:56:29.141 --> 03:56:31.341
请随意观看，因为我们正在使用一个测试网。

2793
03:56:31.341 --> 03:56:34.272
正如我们所见，测试网需要一点时间。

2794
03:56:34.272 --> 03:56:36.334
只要你熟悉这个过程是怎样的。

2795
03:56:36.334 --> 03:56:37.253
这就足够了。

2796
03:56:37.253 --> 03:56:40.203
如果你不想，你可以不去尝试。

2797
03:56:40.203 --> 03:56:43.015
我们会打开，remix会通读。

2798
03:56:43.141 --> 03:56:45.521
看起来这个例子在COVID网络上。

2799
03:56:46.141 --> 03:56:48.045
编译API消费者。

2800
03:56:50.141 --> 03:56:55.046
在注射的网络3上，我们要确保我们回到了COVID检测网络。

2801
03:56:55.046 --> 03:56:56.760
我们向下滚动。

2802
03:56:56.760 --> 03:56:59.105
我们将改变API消费者的契约。

2803
03:56:59.142 --> 03:57:04.379
我们将继续并点击部署，我们将部署这个合同到COVID。

2804
03:57:04.379 --> 03:57:04.989
测试网络。

2805
03:57:04.989 --> 03:57:09.955
现在我们可以调用这个函数称为请求体积数据做一个API调用。

2806
03:57:09.955 --> 03:57:16.955
现在，就像我之前提到的，每当我们从链链接节点请求数据时，我们必须支付一点Oracle

2807
03:57:16.955 --> 03:57:24.122
gas，或者链接令牌，为了支付一些链接令牌，我们需要在API消费者契约中有链接令牌。

2808
03:57:24.122 --> 03:57:32.563
这就是所谓的获取链接令牌的基本请求和接收模型，我们回到我们的水龙头，这一次，我们将为我们的契约选择10个测试链接。

2809
03:57:32.563 --> 03:57:34.826
让我们来验证一下我们是否是人类。

2810
03:57:34.826 --> 03:57:36.320
点击发送请求。

2811
03:57:36.320 --> 03:57:38.695
这次，不是送我们Aetherium。

2812
03:57:38.695 --> 03:57:43.642
他们给我们发送了10个测试链接，这就是所谓的ERC 20令牌。

2813
03:57:43.642 --> 03:57:51.142
或者更准确地说，在ERC 677中，我们稍后会了解到这一点，我们可以在Metamask中看到资产。

2814
03:57:51.142 --> 03:57:56.618
通过导入令牌，为了获得令牌，我们将回到文档。

2815
03:57:56.618 --> 03:58:01.405
我们将查找这样的链接令牌合约，我们将访问我们

2816
03:58:01.405 --> 03:58:06.411
刚刚获得令牌的网络，对我们来说就是COVID。

2817
03:58:06.411 --> 03:58:12.109
复制这个地址，到Metamask，点击导入令牌，

2818
03:58:12.109 --> 03:58:17.808
粘贴那个地址，点击添加自定义令牌，然后导入令牌。

2819
03:58:17.808 --> 03:58:23.282
现在我们可以看到在账户1中，我们都有Aetherium和10。

2820
03:58:23.282 --> 03:58:31.626
链接，现在我们有了链接或Oracle gas，我们要把它发送给API消费者，我们要

2821
03:58:31.626 --> 03:58:39.971
复制API消费者的地址，打开元掩码，点击发送，粘贴合同地址，把资产切换到Link。

2822
03:58:39.971 --> 03:58:42.143
现在我们只发送0。

2823
03:58:42.143 --> 03:58:42.688
2个链接。

2824
03:58:42.688 --> 03:58:44.597
下一个，下一个。

2825
03:58:44.597 --> 03:58:46.487
点击确认。

2826
03:58:46.487 --> 03:58:48.946
我们会等待这笔交易完成。

2827
03:58:48.946 --> 03:58:49.779
我选0。

2828
03:58:49.779 --> 03:58:55.254
2链接，因为在这个合同中，有一个费用字符，

2829
03:58:55.254 --> 03:59:00.209
它告诉我们做一个API调用要花费多少。

2830
03:59:00.209 --> 03:59:01.742
这个实际上是0。

2831
03:59:01.742 --> 03:59:02.808
1个链接，我发送0个。

2832
03:59:02.808 --> 03:59:02.874
2.

2833
03:59:03.143 --> 03:59:04.749
为了以防万一，我们需要两次调用那个API。

2834
03:59:05.143 --> 03:59:08.583
这个函数会在后面的部分中解释。

2835
03:59:08.583 --> 03:59:15.873
但是现在,我只是想告诉你它是什么样子,做的是,一旦我们发送链接到我们的合同,我们可以

2836
03:59:15.873 --> 03:59:23.163
先检查看看体积体积为零,我们希望能获得红杉中Aetherium资产的最后24小时,我

2837
03:59:23.163 --> 03:59:30.455
们将调用此API拥有大量的原始数据,其中包括在特定的体积在过去24小时内,可这个数。

2838
03:59:30.455 --> 03:59:36.412
假设我们想从这个API将它放入我们的契约中，我们会对这个API进行HTTP get调用。

2839
03:59:36.412 --> 03:59:41.906
我们会在一个事务中发出请求。

2840
03:59:41.906 --> 03:59:50.143
在第二个事务中，chain link节点会返回值并将它存储在全局作用域中的volume变量中。

2841
03:59:50.143 --> 03:59:56.361
点击request volume data Metamask会弹出，点击确认。

2842
03:59:56.361 --> 03:59:58.820
你马上就会注意到音量没有更新。

2843
03:59:58.820 --> 04:00:05.732
这也是，因为我们需要等待两个事务，我们为请求发送一个事务。

2844
04:00:05.732 --> 04:00:10.108
然后在第二个事务中，链节点会做出响应。

2845
04:00:10.108 --> 04:00:16.894
在稍微延迟之后，链链接节点确实做出了响应，使API回调到我们的契约。

2846
04:00:16.894 --> 04:00:19.968
我们将在后面的部分中更深入地讨论这个过程。

2847
04:00:19.968 --> 04:00:25.903
我之所以想专门向您展示API调用，是因为我们将在后面的

2848
04:00:25.903 --> 04:00:32.059
课程中向您展示如何使用链接VRF和链接保存器的真实示例。

2849
04:00:32.144 --> 04:00:34.111
我知道我们已经说了很多了。

2850
04:00:35.144 --> 04:00:35.596
审查。

2851
04:00:39.144 --> 04:00:42.890
带功能的区块链令牌需要将其标记为可支付。

2852
04:00:43.144 --> 04:00:47.547
你需要合同中的某些事情发生，你希望整个交易失败。

2853
04:00:47.547 --> 04:00:50.398
如果没有发生这种情况，可以使用require语句。

2854
04:00:50.398 --> 04:00:57.756
要获取事务的Aetherium或原生区块链令牌值，可以使用全局关键字message dot value。

2855
04:00:57.756 --> 04:01:06.080
链链接是一种在智能合约去中心化环境中获取外部数据并进行外部计算的技术。

2856
04:01:06.144 --> 04:01:13.358
引导数据源或价格源是从现实世界中读取价格信息或其他数据的方法，这些数据已经为我们聚

2857
04:01:13.358 --> 04:01:20.572
合和去中心化了，引导VRF是从现实世界中获取可证明的随机数到我们的智能合约的方法。

2858
04:01:20.572 --> 04:01:24.971
Channeling keepers是一种去中心化事件驱动计算的方法。

2859
04:01:24.971 --> 04:01:32.218
我们可以设置一些触发器，比如如果这个触发器被击中，我们就可以定义这个触发器是什么，

2860
04:01:32.218 --> 04:01:39.465
我们要做的是引导任何API都是引导节点的终极定制，允许我们连接到地球上的任何东西。

2861
04:01:39.465 --> 04:01:41.286
让这个产品做好准备。

2862
04:01:41.286 --> 04:01:47.684
我们必须做最多的工作，因为它还没有一个去中心化的Oracle网络，比如链接管理员和价格提要。

2863
04:01:47.684 --> 04:01:53.044
我们将在本课程中继续学习更多关于这些通灵服务的知识。

2864
04:01:53.044 --> 04:02:01.353
现在为了弄清楚我们的消息点值是否大于我们设置的最小美元值，我们实际

2865
04:02:01.353 --> 04:02:09.662
上必须将消息点值从其第一层斜杠Aetherium转换为等值的美元。

2866
04:02:09.662 --> 04:02:14.654
那么我们要怎么做呢?首先，我们需要知道Aetherium的价格，

2867
04:02:14.654 --> 04:02:19.334
或者幻影，或者雪崩，或者任何一层，一个我们正在使用的区块链。

2868
04:02:19.334 --> 04:02:23.380
我们来创建一个函数来得到价格和转化率。

2869
04:02:23.380 --> 04:02:29.309
我们会做一个函数，得到价格，这将是我们用来得到以美元表示的房间

2870
04:02:29.309 --> 04:02:35.430
价格的函数，因此我们可以将message。value转换成美元。

2871
04:02:35.430 --> 04:02:42.975
然后我们还会做一个函数，Get转化率。

2872
04:02:42.975 --> 04:02:49.930
这些都是公共函数，我们可以调用它们，测试它们，做任何我们想做的事。

2873
04:02:49.930 --> 04:02:55.827
为了得到价格，我们需要使用其中一个链链数据源来获得定价信息。

2874
04:02:55.827 --> 04:03:02.145
我们可以看看这个合约看看使用这些价格通道是什么样子的。

2875
04:03:02.145 --> 04:03:09.160
当我们与这个价格信息交互时我们实际上是在读取其中一个合约，有一个合

2876
04:03:09.160 --> 04:03:16.176
约叫做聚合器合约它有一个函数叫做最新一轮数据，它会返回一大堆数据。

2877
04:03:16.176 --> 04:03:18.318
也就是说，这个int价格。

2878
04:03:18.318 --> 04:03:21.732
这是我们感兴趣的价格。

2879
04:03:21.732 --> 04:03:27.260
让我们看一下get价格函数看看如何调用它因为这是

2880
04:03:27.260 --> 04:03:32.789
我们在项目外与合约交互的实例，我们需要两个东西。

2881
04:03:32.789 --> 04:03:40.583
这两件事是什么，我们需要合同的ABI，还有合同的地址。

2882
04:03:40.583 --> 04:03:45.025
所以合同地址很简单，我们可以从合同地

2883
04:03:45.025 --> 04:03:49.715
址中得到合同地址这部分的链链数据供给。

2884
04:03:49.715 --> 04:03:52.361
让我们向下滚动到B银行。

2885
04:03:52.361 --> 04:03:59.379
我们可以在瑞格比上找到那个美元地址然后我们就可以在瑞格比上创建这个合同。

2886
04:03:59.379 --> 04:04:01.597
我们要抓取这个地址，复制它。

2887
04:04:01.597 --> 04:04:05.016
我们要回到我们的代码。

2888
04:04:05.146 --> 04:04:07.196
我们把地址粘贴到这里。

2889
04:04:08.146 --> 04:04:08.525
地址。

2890
04:04:10.146 --> 04:04:11.671
我们不想互动。

2891
04:04:13.146 --> 04:04:18.014
我们之前做的是简单存储我们把整个合约导入到代码中。

2892
04:04:18.014 --> 04:04:19.724
这是我们可以做的。

2893
04:04:19.724 --> 04:04:21.513
但这其实是很多代码。

2894
04:04:21.513 --> 04:04:28.901
那么我们可以做些什么呢，记住，如果我们看的是混合，我们看的是我们

2895
04:04:28.901 --> 04:04:36.521
之前编译的契约之一，ABI实际上是一种契约的不同功能和交互的列表。

2896
04:04:36.521 --> 04:04:42.980
ABI本身实际上不需要包含任何逻辑，它只需要包含，嘿，这里有你可以调用的不同函数，

2897
04:04:42.980 --> 04:04:49.123
例如，在这个合约中，我们可以调用基金，我们可以获得转化率，我们可以获得价格，它

2898
04:04:49.123 --> 04:04:55.583
还没有实现，但最终会实现从技术上讲，有另一种不需要API就可以与合约交互的方法。

2899
04:04:55.583 --> 04:04:58.180
但是现在，我们要忽略它。

2900
04:04:58.180 --> 04:05:02.064
我们如何获得API，在实体中有一个概念叫做接口。

2901
04:05:02.064 --> 04:05:04.606
让我们看一个接口的例子。

2902
04:05:04.606 --> 04:05:05.812
如果我们去github。

2903
04:05:05.812 --> 04:05:11.331
com/smart，合约套件，链链，我们可以在链链库中

2904
04:05:11.331 --> 04:05:16.851
看到很多不同的合约，我们可以去合约，src, V 0。

2905
04:05:16.851 --> 04:05:22.353
8, interfaces，我们会到aggregator v3 interface。soul。

2906
04:05:22.353 --> 04:05:30.423
如果我们看这里的实体性，我们可以看到一大堆函数声明，但没有一个逻辑在这里实现。

2907
04:05:30.423 --> 04:05:32.727
这就是所谓的接口。

2908
04:05:32.727 --> 04:05:41.385
如果我们编译它，我们实际上将得到契约的ABI，因为它定义了我们可以与契约交互的所有不同方式。

2909
04:05:41.385 --> 04:05:50.318
它并没有说，这些函数是干什么的，这很好，因为我们不需要知道这些函数是干什么的，它们会存储在契约中。

2910
04:05:50.318 --> 04:05:56.974
所以我们能做的是从代码中抓取这个接口，并将它粘贴到我们的混音中。

2911
04:05:56.974 --> 04:06:02.442
等等，如果你跟着我学，你不需要和我一起复制粘贴这个，因为我马上会给你展示一个更简单的方法。

2912
04:06:02.442 --> 04:06:04.851
所以现在，大家可以看了。

2913
04:06:04.851 --> 04:06:11.527
但是一旦我们有了这个接口聚合器v3接口，我们现在就可以使用它来进行API调用。

2914
04:06:11.527 --> 04:06:16.560
现在我们可以说，aggregator v3接口在这个地址。

2915
04:06:16.560 --> 04:06:24.387
这两者的结合，就得到了聚合器v3契约和这里的任何代码。

2916
04:06:24.387 --> 04:06:31.074
如果在这个契约地址是聚合器v3接口有效，我们可以做点版本。

2917
04:06:31.147 --> 04:06:32.459
让我们看看这个界面。

2918
04:06:34.147 --> 04:06:34.750
肯定是。

2919
04:06:39.147 --> 04:06:39.776
这份合同。

2920
04:06:42.147 --> 04:06:42.943
不同的部分。

2921
04:06:45.147 --> 04:06:47.687
版本来说明一下。

2922
04:06:47.687 --> 04:06:49.572
我要公开上市。

2923
04:06:50.147 --> 04:06:57.298
会是一个视图，它会返回un256，我们会把它分成两个步骤。

2924
04:06:57.298 --> 04:07:02.082
我们会说聚合旅游，v3接口，价格feed。

2925
04:07:02.082 --> 04:07:06.185
我们创建了一个类型为aggregator v3

2926
04:07:06.185 --> 04:07:13.322
interface = aggregator v3 interface的变量。

2927
04:07:13.322 --> 04:07:19.281
然后我们会返回那个版本的价格。

2928
04:07:19.281 --> 04:07:25.862
现在我将把这个契约部署到Rigby来展示这个git版本将返回什么。

2929
04:07:25.862 --> 04:07:34.574
但如果你不想的话，你可以不跟着做因为我们是在使用测试网，如果你愿意，你可以观看这一节，我们会进行更稀疏的测试。

2930
04:07:34.574 --> 04:07:41.030
因为我们将主要使用测试网，因为我们将使用一个实际的Oracle链链网络，

2931
04:07:41.030 --> 04:07:50.535
一旦你转到硬帽和JavaScript，所有这些本地测试将会更容易更快，非常欢迎你继续，尝试和测试这些东西。

2932
04:07:50.535 --> 04:07:57.713
但是要知道，在测试网上做一些测试可能要花更长的时间，让我们删除最后一个资金合同，我

2933
04:07:57.713 --> 04:08:05.068
们将部署这个，我们将滚动，我们将切换到注入网络3，我们将从COVID切换到溜冰场B。

2934
04:08:05.148 --> 04:08:11.498
我们要确保我们在溜冰场梁上的原因是这个地址是特定于溜冰场B的，我们要

2935
04:08:11.498 --> 04:08:17.848
交互的合约可能不是在每条链上的这个地址，我们要确保我们在溜冰场B的链

2936
04:08:17.848 --> 04:08:24.574
上，因为其他合约在不同的链上，这个版本函数显然不存在，这个函数可能出错。

2937
04:08:24.574 --> 04:08:30.513
我们继续，我们要找到我，我们要把它部署到溜冰场的V链上。

2938
04:08:30.513 --> 04:08:33.390
再说一次，你不需要跟着我，你可以看。

2939
04:08:33.390 --> 04:08:37.960
一旦契约被部署，我们现在有一个视图函数，叫做Get version。

2940
04:08:37.960 --> 04:08:44.492
我们可以看到它返回了一个变量来显示这是价格提要的第四个版本。

2941
04:08:44.492 --> 04:08:49.291
这是一种非常简单的方式来与现有的契约进行交互。

2942
04:08:49.291 --> 04:08:53.776
在我们的项目之外，我们使用这些接口之一，它可以编

2943
04:08:53.776 --> 04:08:58.449
译到API，然后将该ABI与地址结合起来调用函数。

2944
04:08:58.449 --> 04:09:02.815
随着我们越来越多地使用这些接口，它们将变得越来越有意义。

2945
04:09:02.815 --> 04:09:08.610
所以如果你现在对它有点困惑，不要气馁，你做得越多，它就会变得越容易。

2946
04:09:08.610 --> 04:09:16.310
现在，我们知道了如何调用这些函数，我们可以开始使用这个接口。

2947
04:09:16.310 --> 04:09:22.990
然而，如你所知，如果我们有一大堆接口，我们将不得不把一大堆接口放在我们代码的顶部，这看起来很难看。

2948
04:09:22.990 --> 04:09:30.260
还有什么更好的方法吗?在我们使用导入之前，我们从简单存储中导入。

2949
04:09:30.260 --> 04:09:37.296
这就是这个的全部内容，我们能做的是，我们能从数组中导入同性恋Tore v3接口。

2950
04:09:37.296 --> 04:09:42.711
以上就是全部内容，我们可以继续使用这个聚合器v3接口创建一个新契约。

2951
04:09:42.711 --> 04:09:46.542
或者我们可以直接从GitHub导入这个。

2952
04:09:46.542 --> 04:09:54.794
如果我们回到这些chainlink数据源的文档使用数据源,我们向下滚动,我们看

2953
04:09:54.794 --> 04:10:03.046
到,我们有这个导入语句,在链条削减进口合同削减证监会签证接口聚合器v3接口,这

2954
04:10:03.046 --> 04:10:11.298
个,这个导入相同的路径设置链条的GitHub库代码,而不是直接将所有代码添加到

2955
04:10:11.298 --> 04:10:19.550
我们的心情,我们能做的是我们可以从GitHub直接进口,也就是所谓的NPM包。

2956
04:10:19.550 --> 04:10:24.931
Remix很聪明，它指的是NPM包，

2957
04:10:24.931 --> 04:10:35.095
我们以后会讲到NPM，它被称为包管理器，它可以保存不同合同的版本，让

2958
04:10:35.095 --> 04:10:42.869
同合同的版本，让我们直接导入到代码库中，它直接从GitHub库创建。

2959
04:10:42.869 --> 04:10:47.450
所以remix从NPM下载这段代码，它是从这个GitHub创建的。

2960
04:10:47.450 --> 04:10:51.416
现在我们知道，如果我们导入，在，chain, link， /，收缩，src, v0。

2961
04:10:51.416 --> 04:10:57.284
8个接口聚合器v3接口。灵魂，这就像我们把整个合同贴

2962
04:10:57.284 --> 04:11:03.379
在我们的融资合同的顶部一样，这让我们的代码看起来更好。

2963
04:11:03.379 --> 04:11:08.011
现在我们有了这个可以使用的聚合器v3接口。

2964
04:11:08.011 --> 04:11:09.118
好了,好了。

2965
04:11:09.118 --> 04:11:14.492
现在我们有了一个极简的界面，它会给我们API，我们如何得到这里的

2966
04:11:14.492 --> 04:11:20.035
价格呢?文档有一个很好的例子，如果您想要使用它并尝试反向工程的话。

2967
04:11:20.035 --> 04:11:21.084
这就是我们要做的。

2968
04:11:21.150 --> 04:11:22.012
在我们的代码中。

2969
04:11:25.150 --> 04:11:32.617
接口对象叫做price feed一个aggregator v3变量叫做price feed，

2970
04:11:32.617 --> 04:11:43.007
它将等于aggregator v3 Interface contract at address这个地址和我们在下面做的完全一样。

2971
04:11:43.007 --> 04:11:48.953
我们假设这个地址的合约将拥有这个聚合器v3接口的所有功能，

2972
04:11:48.953 --> 04:11:54.900
这意味着它有这个小数函数，这个描述函数版本，获取舍入数据。

2973
04:11:54.900 --> 04:12:00.043
重要的是最新一轮数据，它在答案部分有最新的价格，

2974
04:12:00.043 --> 04:12:05.401
我们现在能做的是调用价格提要上的最新一轮数据函数。

2975
04:12:05.401 --> 04:12:09.369
我们写price feed。最新一轮数据。

2976
04:12:09.369 --> 04:12:14.331
现在如果我们看一下接口，我们会看到最新一轮数据实

2977
04:12:14.331 --> 04:12:19.293
际上并没有返回一个变量，它返回了一堆不同的变量。

2978
04:12:19.293 --> 04:12:21.528
这就是我们在合同中要返还的。

2979
04:12:21.528 --> 04:12:28.224
我们会放这些括号，我们会说，你去round ID，我们

2980
04:12:28.224 --> 04:12:34.920
甚至可以直接看文档看它还返回了什么int price，

2981
04:12:34.920 --> 04:12:41.865
你去了started out，你去了timestamp。

2982
04:12:41.865 --> 04:12:46.892
然后你去广告，回答了一遍。

2983
04:12:46.892 --> 04:12:49.892
这里有很多代码。

2984
04:12:49.892 --> 04:12:55.751
因为这个函数返回这么多不同的变量，我们必须设置一些东西来捕获它们。

2985
04:12:55.751 --> 04:12:57.667
然而，我们只关心价格。

2986
04:12:57.667 --> 04:13:01.717
我们不关心从timestamp开始的Id或在round中回答的Id。

2987
04:13:01.717 --> 04:13:09.832
所以我们能做的就是去掉它们，只留下逗号。

2988
04:13:10.151 --> 04:13:15.409
现在我们有int price = price提供最新一轮数据。

2989
04:13:15.409 --> 04:13:17.731
price是int 256的原因。

2990
04:13:17.731 --> 04:13:24.103
而不是un 256是因为一些价格或数据输入可能是负数，所以它是一个int 256。

2991
04:13:24.103 --> 04:13:25.245
所以它可以保持灵活性。

2992
04:13:25.245 --> 04:13:32.052
现在我们有了价格，这将是用美元表示的价格。

2993
04:13:32.151 --> 04:13:34.906
我们之前看过一个例子，大概是3000。

2994
04:13:35.152 --> 04:13:40.359
它返回了这个数字，因为由于多种原因，固体性对小数不起作用。

2995
04:13:40.359 --> 04:13:44.877
但我们只需要知道，这个价格提要有小数点后8位。

2996
04:13:44.877 --> 04:13:49.390
如果你想再次确认有多少小数，这个合约也有一

2997
04:13:49.390 --> 04:13:54.119
个小数函数，它会告诉你价格提要中有多少小数。

2998
04:13:54.119 --> 04:13:58.167
我们知道，message。value有小数点后18位。

2999
04:13:58.167 --> 04:14:05.226
为什么小数点后有18位?因为一个以太等于1-234-567

3000
04:14:05.226 --> 04:14:12.285
-8910 12345678这个有18个0，等于1的大数。

3001
04:14:12.285 --> 04:14:15.351
12345 678-910-1234 5678。

3002
04:14:15.351 --> 04:14:22.490
我们想让它们的小数点位置相同，对吧?因为现在这个是8，这个是18。

3003
04:14:22.490 --> 04:14:24.795
他们现在是不同的单位。

3004
04:14:24.795 --> 04:14:32.422
因此，为了使它们匹配，我们需要做的就是返回价格乘以1，也就

3005
04:14:32.422 --> 04:14:40.050
是10，或者1的10次方，等于1123456789 10。

3006
04:14:40.152 --> 04:14:44.264
Message。value，将是一个unt256。

3007
04:14:45.152 --> 04:14:47.285
price是6点的一个区间。

3008
04:14:49.152 --> 04:14:50.764
取值从n到56。

3009
04:14:54.152 --> 04:14:57.824
我们要做的就是把你加到56里。

3010
04:14:58.152 --> 04:15:02.459
把这整个括在这两个括号里，就不能进行类型转换了。

3011
04:15:02.459 --> 04:15:08.893
但有一些值，比如56和56，可以很容易地在两者之间转换。

3012
04:15:08.893 --> 04:15:13.539
当然，因为我们没有用这个get价格函数修

3013
04:15:13.539 --> 04:15:18.419
改任何状态，我们可以让这个视图返回到36。

3014
04:15:18.419 --> 04:15:21.946
如果我们保存并编译，我们就会得到那个选中标记。

3015
04:15:21.946 --> 04:15:23.088
数学可能有点棘手。

3016
04:15:23.153 --> 04:15:25.183
前几次是在固体中做的。

3017
04:15:26.153 --> 04:15:27.000
它就变得越容易。

3018
04:15:28.153 --> 04:15:33.943
引用一个这样的函数来算好，这是得到这个数最简单的方法。

3019
04:15:33.943 --> 04:15:34.330
太棒了。

3020
04:15:34.330 --> 04:15:41.034
现在我们有一个get价格函数，它将返回一个un 256，这将是Aetherium的价格。

3021
04:15:41.034 --> 04:15:46.856
就美元而言，我们所需要做的就是从Aetherium转换消息点值。

3022
04:15:46.856 --> 04:15:51.849
以美元为单位，我们来创建这个get转化率函数。

3023
04:15:51.849 --> 04:16:00.088
这个，我们将取一个输入参数un 256，它将是一个公共视图函数。

3024
04:16:00.088 --> 04:16:06.629
它将返回你到56，我们将传递给它一些eamount。

3025
04:16:06.629 --> 04:16:11.105
在另一边，我们将得到以美元表示的每一份的价值。

3026
04:16:11.153 --> 04:16:14.062
我们要做一个u。

3027
04:16:16.153 --> 04:16:16.867
得到价格。

3028
04:16:21.153 --> 04:16:23.572
这是我们为了得到Aetherium的价格而创造的。

3029
04:16:24.153 --> 04:16:30.611
u和256每笔钱的单位是美元等于每笔

3030
04:16:30.611 --> 04:16:37.069
钱的价格乘以每笔钱，然后除以118。

3031
04:16:37.153 --> 04:16:43.465
当你在做固体的乘法和除法运算时，你总是想先做乘法和加法，然后

3032
04:16:43.465 --> 04:16:49.777
再做除法，因为每个价格和每个数量都有18个额外的小数点后位如

3033
04:16:49.777 --> 04:16:56.090
果我们让它们不动的话，他们将会有36个额外的零税附加在最后。

3034
04:16:56.154 --> 04:16:57.340
所以我们需要除以一个EA团队。

3035
04:16:58.154 --> 04:17:02.118
这门课的硬帽部分测试所有的数学将会容易得多。

3036
04:17:02.118 --> 04:17:06.291
如果你现在真的在为一些数学问题而挣扎，我不会让它拖累你。

3037
04:17:06.291 --> 04:17:11.841
因为一旦我们深入人心，实际测试就会变得比在测试网上工作容易得多。

3038
04:17:11.841 --> 04:17:15.392
这个以美元表示的金额就是我们要找的数字。

3039
04:17:15.392 --> 04:17:20.618
所以我们可以继续，以美元为单位返回每一笔钱，CSB在这里返回，

3040
04:17:20.618 --> 04:17:25.677
现在我们有了一个很好的转化率函数可以快速地帮你完成数学运算。

3041
04:17:25.677 --> 04:17:27.965
假设每个人的价格是3000美元。

3042
04:17:27.965 --> 04:17:29.416
所以是3000。

3043
04:17:29.416 --> 04:17:36.444
但它会在末尾附加18个0，它匹配消息。value方式单位。

3044
04:17:36.444 --> 04:17:40.622
举个例子，我们寄一张或112345

3045
04:17:40.622 --> 04:17:50.454
678-910-1234 5678一张到这个合同中，每张应该等于3000美元。

3046
04:17:50.454 --> 04:17:54.333
为了得到价格，我们现在要算出每块价格，

3047
04:17:54.333 --> 04:18:00.868
也就是3000乘以每块的数量，也就是这个，然后除以1的18次方。

3048
04:18:00.868 --> 04:18:06.173
方法out是3123 1-234-567-8910

3049
04:18:06.173 --> 04:18:10.841
12345678乘以1001 2345678

3050
04:18:10.841 --> 04:18:19.967
1-234-567-8910乘以112345678 1-234-567-8910。

3051
04:18:20.154 --> 04:18:27.799
现在除以112345678 1-234-567-8910，等于2。

3052
04:18:27.799 --> 04:18:27.879
9.

3053
04:18:27.879 --> 04:18:34.515
是II 21，计算器算错了，是2。

3054
04:18:34.515 --> 04:18:35.302
9，不是2。

3055
04:18:35.302 --> 04:18:40.086
99，即21表示这个数小数点后有21位。

3056
04:18:40.086 --> 04:18:41.879
所以是2。

3057
04:18:41.879 --> 04:18:47.558
1 234-567-8910 1-234-567-8910 1

3058
04:18:47.558 --> 04:18:53.238
或1-234-567-8910 12345678 2900 I

3059
04:18:53.238 --> 04:18:54.321
99和一个9。

3060
04:18:54.321 --> 04:18:59.178
这就是为什么我们不用固体做小数运算的原因，

3061
04:18:59.178 --> 04:19:03.805
我们的计算器发现这个巨大的数很难算出来。

3062
04:19:03.805 --> 04:19:05.800
所以结果是四舍五入到2。

3063
04:19:05.800 --> 04:19:05.945
999.

3064
04:19:05.945 --> 04:19:12.631
第九，当我们只研究固体整数时，我们不可能失去这种精确性。

3065
04:19:12.631 --> 04:19:15.406
在固体中，这将刚好返回3000美元，

3066
04:19:15.406 --> 04:19:22.655
这是正确的一个Aetherium在3000美元的情况下每个Aetherium将是3000美元。

3067
04:19:22.655 --> 04:19:27.734
就像我说的，既然我们要建立这个契约，假设我们要在这个测试网上

3068
04:19:27.734 --> 04:19:32.983
工作，我们不会在测试网上测试这个函数，因为我们要等待交易完成。

3069
04:19:32.983 --> 04:19:39.268
如果你想继续部署这个，自己摆弄它，非常欢迎现在我们有了一个叫Get转化率的函数我

3070
04:19:39.268 --> 04:19:45.712
们可以在基金函数上使用它来确保我们在基金中发送了足够的message。value。

3071
04:19:45.712 --> 04:19:52.961
我们现在能做的是我们需要做的是得到message。value的转化率需要大于最小USD。

3072
04:19:52.961 --> 04:19:56.827
当然，现在我们的最低美元是50美元。

3073
04:19:56.827 --> 04:20:03.119
我们知道转化率将返回18个0来表示小数点后的数位，

3074
04:20:03.119 --> 04:20:09.663
我们的最低美元金额需要升级为10到50乘以1e18。

3075
04:20:09.663 --> 04:20:17.006
或者再一次，1乘以10，举18，我将把它部署到一个测试网中演示一下。

3076
04:20:17.006 --> 04:20:20.206
但是，如果你不想等的话，你可以不这样做。

3077
04:20:20.206 --> 04:20:22.506
所以我要继续部署这个确认。

3078
04:20:22.506 --> 04:20:24.306
现在我们有了这个有趣的契约。

3079
04:20:24.306 --> 04:20:29.926
如果我不输入数值，点击有趣的按钮，气体估计误差就会失败。

3080
04:20:29.926 --> 04:20:36.852
这是一个笼统的错误，意思是，嘿，你可以发送这个事务，如果你想，它很可能无法工作。

3081
04:20:36.852 --> 04:20:45.346
remix知道这可能行不通的原因是因为它可以看到这个请求并模拟交易，然后说，嘿，你没有用这个汇足够的钱。

3082
04:20:45.346 --> 04:20:51.065
然而，即使我们汇了一些钱，比如5000，它仍然会给我们这个错误。

3083
04:20:51.065 --> 04:20:52.456
因为这还不够。

3084
04:20:52.456 --> 04:20:56.278
我们现在根据每个人的价格来计算。

3085
04:20:56.278 --> 04:21:02.105
我们可以去data。chain这个链接，看看价格大概是多少。

3086
04:21:02.156 --> 04:21:04.477
所以看起来Aetherium现在的价格是3000美元。

3087
04:21:04.477 --> 04:21:07.998
这因人而异取决于你什么时候做。

3088
04:21:07.998 --> 04:21:12.787
如果Aetherium的价格是3000美元，我们的最低价格至少是50美元。

3089
04:21:12.787 --> 04:21:15.798
我们可以用50除以30000。

3090
04:21:15.798 --> 04:21:19.976
每个大概就够了。

3091
04:21:19.976 --> 04:21:25.287
如果我们用Aetherium转换器，我们用0。

3092
04:21:25.287 --> 04:21:30.419
016，我们会知道它是多少，我们用0。

3093
04:21:30.419 --> 04:21:34.862
只是为了确保我们会超过规定的数量。

3094
04:21:34.862 --> 04:21:36.051
我们把它粘贴进来。

3095
04:21:36.156 --> 04:21:37.811
我们把这个改成。

3096
04:21:40.156 --> 04:21:47.632
而不是弹出那个错误，它会继续让我们执行有趣的函数我们可以确认它，它不会失败。

3097
04:21:47.632 --> 04:21:51.878
我现在将拒绝它，因为我真的不想等待交易完成。

3098
04:21:51.878 --> 04:21:52.433
但是很好。

3099
04:21:52.433 --> 04:21:59.557
我们已经确认，我们的get转化率是一个工作的预期，了不起，伟大的工作。

3100
04:22:00.157 --> 04:22:08.950
那么接下来我们想做的是什么呢?当人们向这个合同汇钱时，我们要跟踪所有给我们汇钱的人。

3101
04:22:08.950 --> 04:22:10.957
让我们创建一些数据结构。

3102
04:22:10.957 --> 04:22:11.720
为了跟踪。

3103
04:22:11.720 --> 04:22:15.072
让我们创建一个名为funders的地址数组。

3104
04:22:15.072 --> 04:22:19.023
我们会不断增加所有给我们汇款的资助者。

3105
04:22:19.023 --> 04:22:23.157
我们说一个地址数组，或者地址列表。

3106
04:22:23.157 --> 04:22:25.675
我们会让它成为公共基金。

3107
04:22:25.675 --> 04:22:32.490
只要有人给我们寄钱，而且确实通过了，我们就会增加这个有资金的服务器列表。

3108
04:22:32.490 --> 04:22:38.290
我们说funders。push。message。sender，就像message。value。

3109
04:22:38.290 --> 04:22:39.634
Message dot

3110
04:22:39.634 --> 04:22:47.460
sender是一个始终可用的全局关键字Message dot value表示发送了多少Aetherium或多少原生区块链货币。

3111
04:22:47.460 --> 04:22:52.601
Message。sender是调用字体函数的人的地址。

3112
04:22:52.601 --> 04:22:58.760
如果我们在Rigby上message。sender将等于调用该函数的任何地址。

3113
04:22:58.760 --> 04:23:04.747
因为我们的地址在发送以太，我们要把我们的地址添加到这个资助者列表中。

3114
04:23:04.747 --> 04:23:13.026
这样我们就能追踪到所有为我们的合同捐款的了不起的捐赠者，然后也许我们

3115
04:23:13.026 --> 04:23:21.549
甚至不用把你的地址和每个人实际捐了多少钱的250个6的地址做一个映射。

3116
04:23:21.549 --> 04:23:28.092
所以我们会给你写一个地址和256个公共地址。

3117
04:23:28.092 --> 04:23:30.792
当有人为我们的合同提供资金时，

3118
04:23:30.792 --> 04:23:37.634
会说地址对资金额message。sender等于message。value。

3119
04:23:37.634 --> 04:23:41.272
现在我们有了一个功能，人们可以为我们的合同提供资金。

3120
04:23:41.272 --> 04:23:48.033
我们可以用美元来设定一个价值，我们跟踪不同的资助者，他们为我们的合同提供资金。

3121
04:23:48.033 --> 04:23:50.001
这太棒了。

3122
04:23:50.001 --> 04:23:56.258
我知道我们已经讲了很多非常复杂的数学和复杂的东西。

3123
04:23:56.258 --> 04:23:59.287
让我们快速回顾一下目前所学的内容。

3124
04:23:59.287 --> 04:24:05.053
每当我们使用契约时，我们总是需要API和地址，当编译接

3125
04:24:05.053 --> 04:24:11.033
口时，它为我们提供了与项目外部契约交互的最简单的API。

3126
04:24:11.033 --> 04:24:17.996
当您将这些编译后的接口与地址组合在一起时，我们就可以在该契约上调用该接口上的函数。

3127
04:24:17.996 --> 04:24:18.705
链链接。

3128
04:24:18.705 --> 04:24:22.421
数据提要是一种去中心化的获取真实世界信息的方式。

3129
04:24:22.421 --> 04:24:29.919
在这种情况下，我们从分散的链条节点集合中得到以美元为单位的Aetherium的价格。

3130
04:24:29.919 --> 04:24:31.633
当工作与数学和固体。

3131
04:24:31.633 --> 04:24:32.634
小数不行。

3132
04:24:32.634 --> 04:24:36.048
所以我们在做任何形式的固体数学运算时都要记住这一点。

3133
04:24:36.048 --> 04:24:40.888
我们需要确保我们的单位总是正确的，这样我们的数学运算才有意义。

3134
04:24:40.888 --> 04:24:45.573
Message。value和Message。sender，我们的

3135
04:24:45.573 --> 04:24:50.258
全局可用变量Message。sender表示消息或事务的发送方。

3136
04:24:50.258 --> 04:24:53.988
message。value表示与消息一起发送的方式的数量。

3137
04:24:53.988 --> 04:24:58.581
有一大堆不同的特殊变量和函数我们可以在任何时候访问。

3138
04:24:58.581 --> 04:25:01.458
这些在稳定性文档中都有。

3139
04:25:01.458 --> 04:25:08.076
好的，很好，我们有了一个很好的方法可以开始为我们的合同提供资金。

3140
04:25:08.076 --> 04:25:14.134
但我们的代码看起来有点乱，我们有几个不同的函数来获取价格和处理这些价

3141
04:25:14.134 --> 04:25:20.372
格，有没有办法让这个数学运算更容易使用，这就是我们要引入库概念的地方。

3142
04:25:20.372 --> 04:25:23.784
所以什么是库，我绝对推荐通过例子来检查固体性。

3143
04:25:23.784 --> 04:25:28.938
Org，在你们学习这门课程的过程中，他们也有一些很棒的例子。

3144
04:25:28.938 --> 04:25:33.459
其中一个例子是关于库的，库类似于契约。

3145
04:25:33.459 --> 04:25:36.322
但你不能声明任何状态变量也不能发送以太。

3146
04:25:36.322 --> 04:25:41.434
我们还可以使用库向不同的值添加更多的功能。

3147
04:25:41.434 --> 04:25:49.539
这是什么意思呢?我们能做的是我们能让转化率是aun 256的函数。

3148
04:25:49.539 --> 04:25:57.635
我们可以用Messer。value。get convert John，转化率。

3149
04:25:57.635 --> 04:26:04.926
我们可以添加函数，就像36是我们实际创建的对象或结构或契约。

3150
04:26:04.926 --> 04:26:10.982
那么我们该怎么做呢?好，让我们在合同文件夹中创建一个新合同，并创建一个新文件。

3151
04:26:10.982 --> 04:26:13.716
我们叫它price converter。salt。

3152
04:26:13.716 --> 04:26:20.482
我们的价格转换大底将是一个库我们将附加到un256。

3153
04:26:20.482 --> 04:26:28.108
如何创建库，什么是库?库将非常非常类似于智能合约。

3154
04:26:28.108 --> 04:26:33.565
从spdx许可证标识符开始。

3155
04:26:33.565 --> 04:26:39.859
我的团队，我们会给它一个实用度，稳定性零点八。

3156
04:26:39.859 --> 04:26:39.959
0.

3157
04:26:40.159 --> 04:26:45.809
而不是输入contract作为合同的名称，而是用library作为库的名称。

3158
04:26:45.809 --> 04:26:47.970
我们称它为价格转换器。

3159
04:26:47.970 --> 04:26:55.105
库不能有任何状态变量，也不能发送以太，库中所有的函数都在那里。

3160
04:26:55.159 --> 04:26:55.534
内核。

3161
04:26:59.160 --> 04:27:03.759
我们可以获取价格，获取版本，获取转化率，复制它们，

3162
04:27:03.759 --> 04:27:08.910
从Funmi . soul删除它们，并粘贴到我们的库中。

3163
04:27:08.910 --> 04:27:16.676
当然，因为我们在这里使用aggregator v3接口，我们也可以从Funmi复制导入。

3164
04:27:16.676 --> 04:27:25.107
因为我们不再使用三个接口和合约的集合，我们使用价格转换器，我们可以粘贴到价格转换器中。

3165
04:27:25.107 --> 04:27:29.597
现在，如果我们编译price convert at soul，我们会看到它实际上通过了。

3166
04:27:29.597 --> 04:27:32.910
现在库中的所有函数都需要是内部的。

3167
04:27:32.910 --> 04:27:41.857
我们会让这个库价格转换器有不同的功能，我们会调用活动六，例如，我们会做message。

3168
04:27:41.857 --> 04:27:50.805
value。get转化率，我们会直接得到U和256的转化率就好像这一直是它的函数一样。

3169
04:27:50.805 --> 04:27:53.063
首先，让我们把它放在内部。

3170
04:27:53.063 --> 04:27:55.518
让我们把转化率设为内部。

3171
04:27:55.518 --> 04:27:57.540
我们会在内部做一个好的版本。

3172
04:27:57.540 --> 04:28:05.367
现在我们在Funmi中有了这个库价格转换器，我们现在可以导入这个价格转换器，并在256中将它附加给您。

3173
04:28:05.367 --> 04:28:11.010
导入斜杠价格转换器。soul。

3174
04:28:11.160 --> 04:28:18.626
在Funmi中，我们将使用价格转换器为UNT 256。

3175
04:28:19.160 --> 04:28:21.192
当然，如果我们编译Funmi。

3176
04:28:23.160 --> 04:28:26.110
问题在于，转化率没有定义。

3177
04:28:26.160 --> 04:28:33.560
在库中，传递给函数的第一个变量将是它自己调用的对象。

3178
04:28:33.560 --> 04:28:38.123
在Funmi。soul中，我们先注释掉这一行。

3179
04:28:38.123 --> 04:28:46.666
如果我们用message。value。get转化率，这其实和我们在价格转换库中获取转化率或者message。

3180
04:28:46.666 --> 04:28:55.684
value是一样的，message。value将被作为输入参数传递来获取转化率，忘掉价格和版本吧我们并不关心数字。

3181
04:28:55.684 --> 04:28:58.446
我们先把它留空。

3182
04:28:58.446 --> 04:29:02.685
不需要获取转化率，我们现在可以用，

3183
04:29:02.685 --> 04:29:07.922
message。value。get转化率。

3184
04:29:07.922 --> 04:29:12.516
编译它，你会看到这里我们没有传递一个变量，尽管

3185
04:29:12.516 --> 04:29:17.111
我们的get转化率函数说，嘿，我需要一个变量。

3186
04:29:17.161 --> 04:29:23.643
同样，这样做的原因是，这个消息add value被认为是这些库函数的第一个形参。

3187
04:29:23.643 --> 04:29:24.928
这就是它的工作原理。

3188
04:29:24.928 --> 04:29:31.374
如果我们想在这里再加一个变量，比如56。

3189
04:29:31.374 --> 04:29:35.974
现在我们要传入另一个值123。

3190
04:29:35.974 --> 04:29:38.574
这个123会被赋值给这个别的东西。

3191
04:29:38.574 --> 04:29:40.964
但我们现在要把它删掉。

3192
04:29:40.964 --> 04:29:41.947
好了,好了。

3193
04:29:41.947 --> 04:29:47.089
在这样做的过程中，我们通过将大量的数学计算和价格转换内容

3194
04:29:47.089 --> 04:29:52.415
转移到我们的价格转换库。Sol中，将Funmi合同最小化。

3195
04:29:52.415 --> 04:29:56.934
其中一个最常用的，使用时间最长的

3196
04:29:56.934 --> 04:30:01.737
库叫做Safe math。Sol。

3197
04:30:01.737 --> 04:30:08.364
你可能会在很多不同的地方看到它，我们将在这里快速地切线教你安全数学。

3198
04:30:08.364 --> 04:30:10.550
让我们关闭Funmi关闭价格转换器。

3199
04:30:10.550 --> 04:30:15.403
让我们创建一个名为Safe math tester的新文件。

3200
04:30:15.403 --> 04:30:16.541
这是所有。

3201
04:30:16.541 --> 04:30:19.212
让我们从一些基本的东西开始。

3202
04:30:19.212 --> 04:30:22.263
在0版本之前，安全数学到处都是。

3203
04:30:22.263 --> 04:30:23.144
8的固体度。

3204
04:30:23.144 --> 04:30:25.679
现在几乎没有合同了。

3205
04:30:25.679 --> 04:30:31.781
发生了什么，为什么安全数学不再被广泛使用?好吧，让我们创建一个样本合同。

3206
04:30:31.781 --> 04:30:35.866
如果你不想和我一起编写代码，你可以不跟随这部分内容。

3207
04:30:35.866 --> 04:30:38.443
但如果你想，你完全可以。

3208
04:30:38.443 --> 04:30:45.749
这将是一个我们将部署在JavaScript虚拟机上的契约，我们可以使用0版本之前的任何版本。

3209
04:30:45.749 --> 04:30:46.574
8的固体度。

3210
04:30:46.574 --> 04:30:50.923
例如，我们用pragma, carrot, 0, point 6。

3211
04:30:50.923 --> 04:30:51.018
0.

3212
04:30:51.018 --> 04:30:56.066
我们会创建合同安全数学测试，点索尔。

3213
04:30:56.066 --> 04:31:02.230
现在，如果我创建一个yint 8，我将它设为公共大数。

3214
04:31:02.230 --> 04:31:06.697
我把它设为255哦，安全数学测试。

3215
04:31:06.697 --> 04:31:12.323
让我们继续，编译安全的数学测试0点6。

3216
04:31:12.323 --> 04:31:18.846
7pragma，结实度，Yewande 8的最大尺寸是255。

3217
04:31:18.846 --> 04:31:23.276
这将是我们在新的int 8中所能容纳的最大的数。

3218
04:31:23.276 --> 04:31:27.802
如果我要把它部署到一个JavaScript VM

3219
04:31:27.802 --> 04:31:32.328
或者一个测试网络，安全的数学测试器，让我们继续。

3220
04:31:32.328 --> 04:31:35.694
如果是大数字，就会得到255。

3221
04:31:35.694 --> 04:31:41.704
如果我创建一个叫ADD的函数会发生什么?

3222
04:31:41.704 --> 04:31:47.114
让大数等于大数加1 ?让我们保存它。

3223
04:31:47.114 --> 04:31:49.399
删除旧契约并进行部署。

3224
04:31:49.399 --> 04:31:56.069
好了，大数字255加1 2会怎样?很大的数字。

3225
04:31:56.162 --> 04:32:01.404
当255是a的最大值时，UNT 8可以是?点击添加。

3226
04:32:01.404 --> 04:32:04.226
现在我们来看看大的数是多少。

3227
04:32:04.226 --> 04:32:06.637
大数字被重置为零。

3228
04:32:06.637 --> 04:32:09.687
这是怎么回事?在版本0之前。

3229
04:32:09.687 --> 04:32:16.524
无符号整数和整数都是基于未检查的概念运行的，这意味着如果你超

3230
04:32:16.524 --> 04:32:23.589
过了一个数字的上限，它就会绕一圈，从它可能的最低数字开始返回。

3231
04:32:23.589 --> 04:32:28.337
如果我再多次调用加法，然后点击一个大数字，

3232
04:32:28.337 --> 04:32:33.086
假设我再多次点击加法按钮把它变回2和55。

3233
04:32:33.163 --> 04:32:35.210
然后它会继续绕到0。

3234
04:32:36.163 --> 04:32:44.769
当时流行的库是这个安全的数学库，它会检查你是否超过UN 256或直观的6，基本上，

3235
04:32:44.769 --> 04:32:52.956
它是一种方式，告诉你，嘿，你已经达到了这个数字的最大值，现在你的交易将会失败。

3236
04:32:52.956 --> 04:32:54.543
如果我们把它换成0。

3237
04:32:54.543 --> 04:33:00.244
8、稳固度，删除旧合同，去把这个换成0。

3238
04:33:00.244 --> 04:33:00.325
8.

3239
04:33:00.325 --> 04:33:02.784
我们将继续编译它。

3240
04:33:02.784 --> 04:33:07.020
现在我们把它部署到JavaScript VM。

3241
04:33:07.163 --> 04:33:09.679
如果我击中大数字，我们就能降到55以下。

3242
04:33:11.163 --> 04:33:12.256
其实失败。

3243
04:33:12.256 --> 04:33:14.521
我们还是会达到55岁以下。

3244
04:33:14.521 --> 04:33:15.536
在0版本中。

3245
04:33:16.163 --> 04:33:22.679
Solidity，他们加了这一点，它会自动检查你是否要对变量做所谓的溢出

3246
04:33:22.679 --> 04:33:29.195
或下溢，我们实际上可以通过使用unchecked关键字恢复到未检查版本。

3247
04:33:29.195 --> 04:33:34.062
如果我们把这个大数=大数+ 1括在这个未选中的括号里，我们删

3248
04:33:34.062 --> 04:33:39.092
除旧契约will compile will redeploy。

3249
04:33:39.092 --> 04:33:40.877
我们有很大的数字是55。

3250
04:33:40.877 --> 04:33:46.247
现在我们点击加法，我们再次点击大数，它又回到了零。

3251
04:33:46.247 --> 04:33:49.964
这是关于安全数学的一些内容，检查和未检查。

3252
04:33:49.964 --> 04:33:50.950
所以在版本0中。

3253
04:33:50.950 --> 04:33:59.452
76，在你们前面看到的这段代码下面，和0的代码是完全一样的。

3254
04:33:59.452 --> 04:33:59.553
8.

3255
04:33:59.553 --> 04:34:01.458
以上使用这个未选中的关键字。

3256
04:34:01.458 --> 04:34:05.070
现在你可能会想，在新版本的坚固性中，

3257
04:34:05.070 --> 04:34:14.503
为什么我要使用这个unchecked关键字?稍后您将发现，这个未选中的关键字使您的代码更省油。

3258
04:34:14.503 --> 04:34:22.594
因此，如果你绝对肯定你的数学永远不会达到一个数字的上限或下限，那么使用unchecked关键字可能是有意义的。

3259
04:34:22.594 --> 04:34:31.079
让我们回到我们的Funmi合同，在那里我们现在使用我们刚刚创建的价格转换库。

3260
04:34:31.164 --> 04:34:31.830
好了,好了。

3261
04:34:34.164 --> 04:34:35.943
这里是真正的资助。

3262
04:34:37.164 --> 04:34:45.113
在我们的库价格转换器中完成转化率的数学，我们将在Funmi的顶部导入它。

3263
04:34:45.164 --> 04:34:45.422
酷。

3264
04:34:45.422 --> 04:34:48.196
现在，我们有了有趣的方法。

3265
04:34:48.196 --> 04:34:48.712
太棒了。

3266
04:34:49.164 --> 04:34:53.471
所以我们可以允许任何人继续为这个合同提供资金，

3267
04:34:53.471 --> 04:34:58.902
并将Aetherium或任何本地区块链货币发送到这个合同。

3268
04:34:58.902 --> 04:35:03.402
现在我们要做什么?好吧，一旦所有的资助者都进行

3269
04:35:03.402 --> 04:35:08.099
了投资，我们将希望这个项目能够从合同中提取资金。

3270
04:35:08.164 --> 04:35:13.836
所以他们可以继续用这些资金为这个项目买东西。

3271
04:35:13.836 --> 04:35:17.410
我们来创建一个取款函数。

3272
04:35:17.410 --> 04:35:19.771
我们会创建一个取款函数。

3273
04:35:19.771 --> 04:35:21.283
我们会把这个公之于众。

3274
04:35:21.283 --> 04:35:26.090
因为我们将从这个合同中提取所有的资金，我们可能还需要

3275
04:35:26.090 --> 04:35:31.083
重置我们的资助者数组，并将我们的地址设置为被资助金额。

3276
04:35:31.165 --> 04:35:36.498
既然我们要把所有的资金都取出来，那笔钱应该归零了。

3277
04:35:36.498 --> 04:35:42.831
我们继续遍历供资者数组并更新映射对象这样每个供资者

3278
04:35:42.831 --> 04:35:49.418
现在都是0，因为马上，我们将从他们那里取出所有的钱。

3279
04:35:49.418 --> 04:35:53.040
为了做到这一点，我们将使用一个叫做for循环的东西。

3280
04:35:53.040 --> 04:35:58.372
什么是for循环?for循环是一种遍历某种类型的索引对象的方法，

3281
04:35:58.372 --> 04:36:03.704
或遍历某些数字范围的方法，或只是重复执行某个任务一定次数的方法。

3282
04:36:03.704 --> 04:36:08.378
例如，我们有一个数组或列表。

3283
04:36:08.378 --> 04:36:11.935
在这个名单上，我们有1234个。

3284
04:36:12.165 --> 04:36:18.230
如果我们想要得到这个数组中的所有元素，或者这个列表中的所有元素，1234。

3285
04:36:18.230 --> 04:36:23.721
我们如何得到列表中的所有元素?我们

3286
04:36:23.721 --> 04:36:29.213
会用for循环循环遍历每一个对象。

3287
04:36:29.213 --> 04:36:34.047
所以在0处，下标为1第一个下标为2，

3288
04:36:34.047 --> 04:36:38.613
第二个下标为3，最后一个下标为4。

3289
04:36:38.613 --> 04:36:44.358
所以我们将遍历索引0到3来得到所有这些元素。

3290
04:36:44.358 --> 04:36:51.120
或者也许另一个例子是如果这是A B C D, A在0处，下

3291
04:36:51.120 --> 04:36:58.116
标B在第一个下标看到第二个Indy在第三个我们将循环0到3。

3292
04:36:58.116 --> 04:37:02.116
要得到这些元素中的每一个，我们要做完全相同的事情。

3293
04:37:02.166 --> 04:37:03.959
但随着资助者的排列。

3294
04:37:06.166 --> 04:37:13.116
我们首先从for关键字开始，for关键字说，好，我们要开始一个循环。

3295
04:37:13.116 --> 04:37:17.759
在这些括号里面，我们定义了如何循环它。

3296
04:37:17.759 --> 04:37:22.859
还有反斜杠，反斜杠有点像注释的括号。

3297
04:37:22.859 --> 04:37:26.534
在这两者之间的任何内容都将是注释。

3298
04:37:26.534 --> 04:37:31.100
在for循环中，首先，我们给它一个起始索引，然

3299
04:37:31.100 --> 04:37:35.666
后我们给它一个结束索引，然后我们给它一个步长。

3300
04:37:35.666 --> 04:37:40.860
例如，我们想从0开始，到10。

3301
04:37:40.860 --> 04:37:43.492
每次都要增加1。

3302
04:37:43.492 --> 04:37:46.022
我们拨打01 234-567-8910。

3303
04:37:46.022 --> 04:37:49.461
或者从0开始，到10结束。

3304
04:37:49.461 --> 04:37:51.553
每次增加2。

3305
04:37:51.553 --> 04:37:53.488
所以是02468 10。

3306
04:37:53.488 --> 04:37:58.398
或者我们想从0到5，我们想从2到5，

3307
04:37:58.398 --> 04:38:03.308
每一步是1，我们会走2345，等等。

3308
04:38:03.308 --> 04:38:08.690
这就是这个4位的内容。

3309
04:38:08.690 --> 04:38:13.558
对于我们的起始下标，我把它放在上面，这样你们就可以引用它了。

3310
04:38:13.558 --> 04:38:18.869
我们的起始指数是你的v6变量，我们称之为投资人指数。

3311
04:38:18.869 --> 04:38:23.481
我们从雷指数等于零开始。

3312
04:38:23.481 --> 04:38:25.808
我们从0开始。

3313
04:38:25.808 --> 04:38:33.119
我们会以出资人数组的长度结束，因为我们想循环所有的出资人。

3314
04:38:33.166 --> 04:38:41.500
我们会说，funder index需要小于funders。length。

3315
04:38:41.500 --> 04:38:49.658
因此，我们的最终指数将是，只要出资人指数不再小于出资人。长度。

3316
04:38:49.658 --> 04:38:56.600
最后，我们会说funder index = funder index +

3317
04:38:56.600 --> 04:39:03.928
1，这意味着每次循环里面的代码结束，我们会把funder index加1。

3318
04:39:03.928 --> 04:39:08.522
这就是我们如何从0到1到2到3到4到5，等等。

3319
04:39:08.522 --> 04:39:13.235
另一种输入funder index = funder index +

3320
04:39:13.235 --> 04:39:21.691
1的方法是你可以直接输入funder index + +，这个+ +语法的意思是funder index =本身+ 1。

3321
04:39:21.691 --> 04:39:26.643
让我们开始遍历我们的funders数组来访问0 with元素或者第

3322
04:39:26.643 --> 04:39:31.747
一个元素，我们会说，funders of funder index。

3323
04:39:31.747 --> 04:39:37.532
我们说我们想用我们的funders对象的元素访问0。

3324
04:39:37.532 --> 04:39:42.574
这将返回一个地址给我们使用，我们会继续说，address

3325
04:39:42.574 --> 04:39:48.517
under = funders at funder index。

3326
04:39:48.517 --> 04:39:50.973
现在我们有了这个资助者地址。

3327
04:39:50.973 --> 04:39:55.019
我们想用这个来重置映射。

3328
04:39:55.019 --> 04:39:59.203
我们会说，address to

3329
04:39:59.203 --> 04:40:07.014
amount被资助的金额在funder键处现在等于0。

3330
04:40:07.167 --> 04:40:11.844
因为记住，在基金中我们会更新金额。

3331
04:40:13.167 --> 04:40:20.135
为合同提供资金，当我们从合同中提取资金时，我们会将其重置为零。

3332
04:40:20.135 --> 04:40:23.752
现在我们来看看这个投资人指数从0开始。

3333
04:40:23.752 --> 04:40:31.023
我们会得到funder的0，我们会在0和index处找到那个funder我们会把

3334
04:40:31.023 --> 04:40:38.294
那个funder的男性资助地址重置为0，然后这个for循环会更新1，它会从0移动

3335
04:40:38.294 --> 04:40:45.929
到1，它会检查funder index是否小于长度，假设funder里面有10个人。

3336
04:40:45.929 --> 04:40:48.930
如果资助者有10个人，它仍然会更少。

3337
04:40:48.930 --> 04:40:55.130
现在资助者链接将是一个地址资助者将等于资助者1，而不是0，

3338
04:40:55.130 --> 04:41:01.117
我们会获取那个地址，我们会重置那个关于被资助的地址为0，

3339
04:41:01.117 --> 04:41:07.105
然后我们会继续到2到3到4一直到我们的资助者数组的长度。

3340
04:41:07.168 --> 04:41:09.599
这就是我们在对象中循环的方式。

3341
04:41:10.168 --> 04:41:14.851
中间这个是结束索引不完全正确，因为我们实际上是

3342
04:41:14.851 --> 04:41:19.739
在检查布尔值，看它是否仍然正确，但希望你能理解。

3343
04:41:19.739 --> 04:41:22.422
所以我们重置了映射的平衡。

3344
04:41:22.422 --> 04:41:30.043
然而，我们仍然没有做两件事，我们仍然需要重置数组，使资助者为空数组。

3345
04:41:30.043 --> 04:41:34.909
然后我们还需要取出资金。

3346
04:41:34.909 --> 04:41:43.868
从我们资助这个开始，我们在调用这个基金函数的同时发送了message。value。

3347
04:41:43.868 --> 04:41:46.840
然而，我们实际上并没有取出资金。

3348
04:41:46.840 --> 04:41:54.075
要重置数组，我们可以遍历它并从这个地址数组中删除对象。

3349
04:41:54.168 --> 04:41:58.513
或者我们可以完全刷新这个变量。

3350
04:41:58.513 --> 04:42:07.034
而不是数组遍历和删除对象,我们只需要说资助者等于

3351
04:42:07.034 --> 04:42:15.555
一系列的新地址,我们将完全重置数组现在说这个字体

3352
04:42:15.555 --> 04:42:24.076
变量等于一个品牌新地址与零对象数组开始,如果我们

3353
04:42:24.076 --> 04:42:32.597
把一个放在这里,这将会有一个元素数组中开始,两个

3354
04:42:32.597 --> 04:42:42.187
两个,三个三个,等,我们将它作为一个完全空白的新数组。

3355
04:42:42.187 --> 04:42:45.393
很好，我们已经重置了数组。

3356
04:42:45.393 --> 04:42:53.954
但是我们现在如何从合同中提取资金呢?我们如何将资金寄回给调用它的人来发送

3357
04:42:53.954 --> 04:43:02.515
以太币或原生区块链货币，实际上有三种不同的方式来做这件事，我们将会研究这

3358
04:43:02.515 --> 04:43:11.316
三种方式，并说明这三种方式的区别，这三种不同的方式分别是转移，发送和调用。

3359
04:43:11.316 --> 04:43:14.512
让我们从转移开始。

3360
04:43:14.512 --> 04:43:19.902
因为转移是最简单的，而且在表面上对我们来说最有意义。

3361
04:43:19.902 --> 04:43:24.955
如果我们想把钱转移到调用取款函数的人那里，我们会

3362
04:43:24.955 --> 04:43:30.219
说message。sender。transfer。

3363
04:43:30.219 --> 04:43:38.792
然后我们可以通过address this得到合约的余额，这个关键字指的是整个合约。

3364
04:43:38.792 --> 04:43:48.202
balance，我们可以得到这个地址的原生区块链货币或Aetherium货币余额，像这样。

3365
04:43:48.202 --> 04:43:55.058
我们只需要做一件事就是我们需要类型转换我们需要将mes

3366
04:43:55.058 --> 04:44:01.915
sage。sender从地址类型转换为可支付地址类型。

3367
04:44:01.915 --> 04:44:07.878
message。sender的类型是address。

3368
04:44:08.170 --> 04:44:13.422
对于可支付的消息，发送者的类型是可支付地址，

3369
04:44:13.422 --> 04:44:21.780
为了像Aetherium一样发送本机区块链令牌，您只能使用可支付地址。

3370
04:44:21.780 --> 04:44:25.545
要做到这一点，我们只需要把它包装在这个可支付类型的脚轮。

3371
04:44:25.545 --> 04:44:33.544
这是我们发送Aetherium的第一种方式，或者说从不同的合同中发送代币，我们把我们想要发

3372
04:44:33.544 --> 04:44:41.721
送的地址包装起来，在这个payable关键字中，我们做点转移，然后我们说我们想要转移多少钱。

3373
04:44:41.721 --> 04:44:44.479
但是在转帐方面有一些问题。

3374
04:44:44.479 --> 04:44:51.134
这是一个固体性的例子，用来发送以太，这也是一个很好的参

3375
04:44:51.134 --> 04:44:57.790
考资源，如果你迷路了，我们刚刚看到的方法就是传输方法。

3376
04:44:57.790 --> 04:45:02.956
我们在之前的课程中看到，如果我把Aetherium，从一个

3377
04:45:02.956 --> 04:45:08.301
地址发送到另一个地址，它大约花费2100汽油或2100汽油。

3378
04:45:08.301 --> 04:45:13.220
气体，我们的传递函数上限是2300气体。

3379
04:45:13.220 --> 04:45:16.907
如果使用了更多的气体，则抛出一个错误。

3380
04:45:16.907 --> 04:45:22.203
我们使用的下一个将被发送，它的上限也是2300气体。

3381
04:45:22.203 --> 04:45:25.334
如果失败，它会返回一个布尔值。

3382
04:45:25.334 --> 04:45:31.244
对于transfer，如果这一行失败了，它会用send传递

3383
04:45:31.244 --> 04:45:37.154
并恢复事务，它不会传递，它会返回一个布尔值判断它是否成功。

3384
04:45:37.154 --> 04:45:45.980
所以使用send将做应付的消息发送者发送地址这个余额。

3385
04:45:45.980 --> 04:45:50.724
但我们不想在这里结束通话。

3386
04:45:50.724 --> 04:45:57.409
如果这失败了，合同将不会恢复交易，而我们只想将钱发送出去。

3387
04:45:57.409 --> 04:46:04.567
我们想要布尔发送成功等于这整部分。

3388
04:46:04.567 --> 04:46:08.271
然后我们想要成功。

3389
04:46:08.271 --> 04:46:15.049
如果这个send失败，就会抛出一个错误，说sin failed。

3390
04:46:15.171 --> 04:46:21.252
这样，如果失败了，我们仍然会通过在这里添加require语句来恢复。

3391
04:46:21.252 --> 04:46:29.858
Transfer会在传输失败时自动恢复，send只会在这里添加require语句时恢复事务。

3392
04:46:29.858 --> 04:46:30.420
太好了。

3393
04:46:30.420 --> 04:46:37.323
我们用这个调用命令发送以太币或本地货币钱包的第三种方式是什么?

3394
04:46:37.323 --> 04:46:42.588
call将是我们在稳定性代码中使用的第一个较

3395
04:46:42.588 --> 04:46:48.094
低级别的命令，因为这个调用函数实际上非常强大。

3396
04:46:48.171 --> 04:46:53.663
我们可以使用它来调用所有Aetherium中的任何函数，甚至

3397
04:46:53.663 --> 04:46:59.155
不需要有API，我们将在很久以后学习使用这个调用的高级方法。

3398
04:46:59.155 --> 04:47:06.519
现在，我们只学习如何使用它来发送Aetherium，或者你的原生区块链货币调用看起来

3399
04:47:06.519 --> 04:47:14.059
与send非常相似，我们将做payable, message。sender。call。

3400
04:47:14.172 --> 04:47:18.926
这是我们放置函数信息或关于函数的信息的地方，

3401
04:47:18.926 --> 04:47:23.680
我们想调用其他契约，实际上我们不想调用函数。

3402
04:47:23.680 --> 04:47:32.047
我们让它空着，我们可以用这两个引号来表示我们让它空着，我们想把它当作一个事务来使用。

3403
04:47:32.047 --> 04:47:37.732
正如我们在部署中看到的，总是有这个message。value bid，我们将使用这个调

3404
04:47:37.732 --> 04:47:43.417
用函数，就像它是一个常规事务一样，我们可以添加像message。value这样的东西。

3405
04:47:43.417 --> 04:47:48.614
在这里，我们要加上这些弯弯曲曲的括号。

3406
04:47:48.614 --> 04:47:53.510
我们会说，value address

3407
04:47:53.510 --> 04:48:00.856
this。balance，这个调用函数返回两个变量。

3408
04:48:00.856 --> 04:48:07.387
当一个函数返回两个变量时，我们可以把它们放在左边的括号里，这

3409
04:48:07.387 --> 04:48:14.137
两个变量，它返回的是一个布尔值，我们会调用调用success。

3410
04:48:14.137 --> 04:48:22.172
还有一个bytes对象叫做data returned，因为call允许我们调用不同的函数。

3411
04:48:22.172 --> 04:48:30.105
如果那个函数返回一些数据或返回值，我们会把它保存在数据返回变量中。

3412
04:48:30.105 --> 04:48:36.522
它还返回调用成功，如果函数被成功调用，则为真。

3413
04:48:36.522 --> 04:48:38.890
如果不是，这将是错误的。

3414
04:48:38.890 --> 04:48:45.071
由于字节对象是数组，数据返回需要在内存中。

3415
04:48:45.071 --> 04:48:51.141
对于这里的代码，我们实际上没有调用函数，所以我们不关心返回的数据。

3416
04:48:51.141 --> 04:48:57.132
和价格合约类似，我们可以删掉它，留下逗号来表示实数，

3417
04:48:57.132 --> 04:49:02.664
我们知道这个函数返回两个变量，但我们只关心一个。

3418
04:49:02.664 --> 04:49:07.697
然后类似于上面的中心部分，我们将做require cost access

3419
04:49:07.697 --> 04:49:13.011
call failed，这意味着我们要求cost access为true。

3420
04:49:13.011 --> 04:49:16.696
否则，我们将返回一个错误，表示调用失败。

3421
04:49:16.696 --> 04:49:21.156
现在学习这三者之间的区别对你们来说有点复杂。

3422
04:49:21.156 --> 04:49:22.697
不要让这拖累你的脚步。

3423
04:49:22.697 --> 04:49:28.006
在您进一步了解了一些较低级别的函数是如何工作的之后，请继续讨论这个问题。

3424
04:49:28.006 --> 04:49:35.195
再举个例子，讲一下气体是如何工作的，它很好地说明了三者之间的区别，

3425
04:49:35.195 --> 04:49:40.859
我们的传输最大值是2300气体如果失败就会抛出错误，

3426
04:49:40.859 --> 04:49:49.792
发送最大值是2300气体返回一个布尔值，如果失败，调用所有气体，所以没有封顶气体。

3427
04:49:49.792 --> 04:49:58.542
类似于send返回一个布尔值，如果它成功，或失败，就目前记录而言，使用call是实际发

3428
04:49:58.542 --> 04:50:07.292
送和接收Aetherium或你的区块链原生代币的推荐方式，如果这部分对你来说有点困惑，

3429
04:50:07.292 --> 04:50:16.449
现在，只要看看这个，看啊，这就是我们如何发送和转移Aetherium或原生区块链货币代币。

3430
04:50:16.449 --> 04:50:21.064
我会把视频的这部分删掉，但我会把这

3431
04:50:21.064 --> 04:50:25.951
些注释保留在与这门课相关的代码库中。

3432
04:50:25.951 --> 04:50:27.951
好的，很好。

3433
04:50:28.174 --> 04:50:33.951
如果我们点击编译一个有趣的肉大底，我们确实看到它是通过合规。

3434
04:50:33.951 --> 04:50:41.370
然而，这里有一个小问题，现在，任何人都可以退出这个合同。

3435
04:50:41.370 --> 04:50:44.206
所以任何人都可以投资，这是我们想要的。

3436
04:50:44.206 --> 04:50:46.766
但我们不希望任何人能够撤资。

3437
04:50:46.766 --> 04:50:52.485
我们只希望筹集资金的人能够真正提取资金。

3438
04:50:52.485 --> 04:50:57.680
我们如何设置取款函数只由合约的所有者调用呢?

3439
04:50:57.680 --> 04:51:02.404
为了做到这一点，我们要建立一些新的函数。

3440
04:51:02.404 --> 04:51:11.190
当我们部署这个合同时，我们希望自动设置它以便任何部署这个合同的人都将是这个合同的所有者。

3441
04:51:11.190 --> 04:51:17.518
然后我们可以用一些参数来设置它这样只有契约的所有者才能调用取款函数。

3442
04:51:17.518 --> 04:51:24.007
我们怎么做呢?也许我们可以创建一个函数叫做，马上给我打电话。

3443
04:51:24.007 --> 04:51:31.974
在我们部署这个契约之后，我们调用这个call me right away函数，它会将我们设置为所有者。

3444
04:51:31.974 --> 04:51:34.774
这将需要两个事务。

3445
04:51:34.774 --> 04:51:37.554
如果我们要这么做，那就太烦人了。

3446
04:51:37.554 --> 04:51:42.622
相反，固体有一个构造函数。

3447
04:51:42.622 --> 04:51:50.090
如果您熟悉其他编程语言，构造函数与其他编程语言完全相同。

3448
04:51:50.174 --> 04:51:56.224
构造函数将是在部署契约时立即调用的函数。

3449
04:51:56.224 --> 04:52:03.256
所以如果我部署Funmi。Sol，我说，最低美元等于最

3450
04:52:03.256 --> 04:52:10.550
低美元不再是50乘以1 e的18次方，它会立即更新为2。

3451
04:52:10.550 --> 04:52:18.192
因为构造函数是在同一个事务中立即被调用的函数，我们创建了这个契约，这

3452
04:52:18.192 --> 04:52:26.060
个构造函数将对我们非常有帮助，因为它允许我们按我们想要的方式设置契约。

3453
04:52:26.060 --> 04:52:31.662
例如，如果我们希望取款函数只能由契约的所有者

3454
04:52:31.662 --> 04:52:37.519
调用，我们可以让构造函数设置契约的所有者是谁。

3455
04:52:37.519 --> 04:52:42.381
我们创建一个全局变量，地址，公共所有者。

3456
04:52:42.381 --> 04:52:49.367
然后在构造函数中，我们会说owner将等于message。sender。

3457
04:52:49.367 --> 04:52:56.717
构造函数的发送方的消息将是部署契约的任何人。

3458
04:52:56.717 --> 04:53:00.667
所有者就是部署合同的人。

3459
04:53:00.667 --> 04:53:06.342
别担心，我们很快就会演示给你们看以太扫描的所有情

3460
04:53:06.342 --> 04:53:12.255
况，现在演示可能要花点时间，因为我们用的是测试网。

3461
04:53:12.255 --> 04:53:20.126
如果你现在就想测试它，那就去做吧，但是要知道，这将会花费你更多的时间。

3462
04:53:20.126 --> 04:53:25.110
现在我们已经设置了所有者，我们可以修改提款函

3463
04:53:25.110 --> 04:53:30.094
数，以便只有所有者才能真正调用这个提款函数。

3464
04:53:30.094 --> 04:53:36.288
在取款函数的顶部，也许我们想添加一个section，也许我们想说，

3465
04:53:36.288 --> 04:53:42.858
require message。sender = the owner，

3466
04:53:42.858 --> 04:53:49.241
，一个关于双等号和等号的注意事项，你可以把这个单等号看作一个集合参数。

3467
04:53:49.241 --> 04:53:53.579
当我说owner，现在设置为message。

3468
04:53:53.579 --> 04:53:59.890
sender时，double =是检查这两个变量是否相等的方法。

3469
04:53:59.890 --> 04:54:04.062
我们说的是ismessage。sender，和owner一样。

3470
04:54:04.062 --> 04:54:06.961
这就是检验等价性。

3471
04:54:06.961 --> 04:54:10.667
这是设置检查，以查看等价设置。

3472
04:54:10.667 --> 04:54:14.861
我们会说，require message。sender = =

3473
04:54:14.861 --> 04:54:19.733
owner，否则，我们会抛出一个错误，说，sender不是owner。

3474
04:54:19.733 --> 04:54:20.388
完美的。

3475
04:54:20.388 --> 04:54:28.569
现在我们有了一种快速的方法来确保撤回函数只由该契约的所有者调用。

3476
04:54:28.569 --> 04:54:36.101
假设契约中有很多函数需要成为所有者，也许契约中有很多函数

3477
04:54:36.101 --> 04:54:43.633
需要很多不同的要求，我们不想复制粘贴这一行到每一个函数。

3478
04:54:43.633 --> 04:54:47.724
那么我们能做什么呢?这时就要用到修饰语了。

3479
04:54:47.724 --> 04:54:51.242
现在，我们要删除这一行。

3480
04:54:51.242 --> 04:54:56.700
下面，我们将创建一个叫做修饰符的东西，我们的修

3481
04:54:56.700 --> 04:55:02.159
饰符将是一个关键字我们可以在函数声明中添加它。

3482
04:55:02.159 --> 04:55:08.509
要使用该功能修改函数，我们将创建一个修饰符并将其命名为惟一的owner。

3483
04:55:08.509 --> 04:55:13.864
我们要粘贴我们在取款中做的那一行。

3484
04:55:13.864 --> 04:55:19.055
在这下面，我们会加一个下划线，我现在能做的是取这个

3485
04:55:19.055 --> 04:55:24.455
唯一的所有者修饰符，把它插入到取款函数的函数声明中。

3486
04:55:24.455 --> 04:55:31.707
这个只有owner的修饰符在函数声明中发生了什么呢，我们说，对于这个

3487
04:55:31.707 --> 04:55:38.959
取款函数，在你读里面的所有代码之前，先看看唯一的owner修饰符，先

3488
04:55:38.959 --> 04:55:46.211
做里面的内容，然后再做下划线中的内容，这个下划线表示完成剩下的代码。

3489
04:55:46.211 --> 04:55:55.052
现在，当我们调用withdraw函数时，我们先执行这个require语句，然后调用剩下的代码。

3490
04:55:55.052 --> 04:56:03.881
如果这个require语句，我们在下划线下面，这将告诉我们的函数继续，并先执行所有这些代码。

3491
04:56:03.881 --> 04:56:05.520
然后运行require。

3492
04:56:05.520 --> 04:56:13.015
因为我们有这个only关键字，我们说，很好，我们有一个函数，它收回它的公共，哦，only气味修饰符。

3493
04:56:13.015 --> 04:56:14.885
让我们看看这是如何工作的。

3494
04:56:14.885 --> 04:56:18.966
它告诉我们如何先完成原始函数的所有代码。

3495
04:56:18.966 --> 04:56:20.499
我们来做一下。

3496
04:56:20.499 --> 04:56:21.566
好了，现在我们完成了。

3497
04:56:21.566 --> 04:56:27.596
现在，我们该怎么做?好，现在我们要运行require，我们要先把require放在这里。

3498
04:56:27.596 --> 04:56:34.738
这就是修饰符的工作原理，以及我们如何使用它们来提高我们的功能。

3499
04:56:34.738 --> 04:56:36.142
好吧，太棒了。

3500
04:56:36.142 --> 04:56:40.415
我们已经具备了合同的所有基本功能。

3501
04:56:40.415 --> 04:56:46.792
现在我们终于要在一个测试中运行所有的东西，并在我们眼前看到所有发生的事情。

3502
04:56:46.792 --> 04:56:49.022
你准备好了吗?让我们开始吧。

3503
04:56:49.177 --> 04:56:50.849
我们转到deploy选项卡。

3504
04:56:52.177 --> 04:56:53.808
当然要注射网三。

3505
04:56:55.177 --> 04:57:04.125
注入web 3，因为我们的价格转换器点灵魂使用的是链链甲骨文的，实际上存在，并为我们监控林克比网络。

3506
04:57:04.125 --> 04:57:09.112
现在我们向下滚动到，我们会选择Funmi合约。

3507
04:57:09.178 --> 04:57:11.016
我们将继续进行部署。

3508
04:57:12.178 --> 04:57:14.735
确保我们在林克比测试网上。

3509
04:57:16.178 --> 04:57:20.629
我们的钱包里有些垃圾，让我们继续部署，确认。

3510
04:57:20.629 --> 04:57:22.435
我们再等一会儿。

3511
04:57:22.435 --> 04:57:24.458
我把我们的日志调出来。

3512
04:57:24.458 --> 04:57:28.606
我们会等待一段时间，等待我们的合同被部署。

3513
04:57:28.606 --> 04:57:29.409
好了,好了。

3514
04:57:29.409 --> 04:57:32.557
看来我们的合同已经部署好了。

3515
04:57:32.557 --> 04:57:39.754
如果我们向下滚动，我们可以看到所有的功能，最低美元将是50美元。

3516
04:57:39.754 --> 04:57:47.176
但是有18个0，所以单位与Aetherium相同，我们的合同所有者被

3517
04:57:47.176 --> 04:57:54.817
设置为我们的地址，我们部署这个合同的瞬间，它是通过调用构造函数部署的。

3518
04:57:54.817 --> 04:58:02.665
这个地址0x106x和元掩码中的地址是一样的，当然，你的地址和我的有一点不同，

3519
04:58:02.665 --> 04:58:10.716
我们有一个funders数组，它当然是空白的，我们有一个地址数组，它也是空白的。

3520
04:58:10.716 --> 04:58:16.410
然后我们有两个函数可以用来修改区块链提现的状态它是橙色的，

3521
04:58:16.410 --> 04:58:26.031
因为我们没有支付任何Aetherium我们实际上获得了Aetherium或任何原生区块链货币基金，

3522
04:58:26.031 --> 04:58:34.278
因为fun是一个可支付函数我们将把Aetherium发送到或发送任何原生区块链货币。

3523
04:58:34.278 --> 04:58:36.419
让我们继续，看看这是如何工作的。

3524
04:58:36.419 --> 04:58:39.712
首先，让我们为这个合同提供资金。

3525
04:58:39.712 --> 04:58:46.469
再说一次，资金问题，我们得做点数学计算，因为每个人的价格在3000美元左右。

3526
04:58:46.469 --> 04:58:48.654
我们要50美元。

3527
04:58:48.654 --> 04:58:51.998
最小值是50除以3000。

3528
04:58:51.998 --> 04:58:56.871
可以用3000除以50，也可以用50除以3000。

3529
04:58:56.871 --> 04:58:58.979
我们知道在0附近。

3530
04:58:58.979 --> 04:59:04.721
02 Aetherium，应该足够本合同生效。

3531
04:59:04.721 --> 04:59:05.398
所以0。

3532
04:59:05.398 --> 04:59:13.490
02 Aetherium在这里，我们可以复制粘贴到这里。

3533
04:59:13.490 --> 04:59:16.429
当我们碰到资金时，它应该会通过。

3534
04:59:16.429 --> 04:59:18.866
我们确实看到元遮罩弹出。

3535
04:59:18.866 --> 04:59:20.790
我们将继续进行确认。

3536
04:59:20.790 --> 04:59:28.100
一旦交易完成，我们就能在以太网上看到这份合同里面有钱。

3537
04:59:28.179 --> 04:59:36.738
如果我们不加，如果我们不加一个值，我们的基金会说，气体估计失败了因为我们在这里输入的量不够。

3538
04:59:36.738 --> 04:59:44.655
事实上，我们甚至看到execution reverted没有发送足够的数据，我们完全可以发送这个事务但是，它会失败。

3539
04:59:44.655 --> 04:59:45.035
太好了。

3540
04:59:45.035 --> 04:59:51.081
现在我们的交易已经完成了，如果我们继续到溜冰场以太扫描，一旦我

3541
04:59:51.081 --> 04:59:57.127
们等待它完成在这里的索引在溜冰场以太扫描上，我们可以看到这个交

3542
04:59:57.127 --> 05:00:03.369
易实际上已经完成了资金，我们可以看到这个交易中有很多不同的细节。

3543
05:00:03.369 --> 05:00:12.007
向下滚动，你能看到所有调用fun函数的信息，气体限制气体，燃气

3544
05:00:12.007 --> 05:00:20.645
费，燃气价格，我们还能看到输入数据，我们在这里调用了基金函数。

3545
05:00:20.645 --> 05:00:22.920
稍后我们将进一步了解输入数据。

3546
05:00:22.920 --> 05:00:27.394
如果我们转到我们部署的契约，我们现在可以

3547
05:00:27.394 --> 05:00:32.093
看到两个事务，我们可以看到契约创建的事务。

3548
05:00:32.180 --> 05:00:34.954
我们还调用了一个字体方法。

3549
05:00:36.180 --> 05:00:38.805
合同的余额，现在是0。

3550
05:00:40.180 --> 05:00:43.230
因为我们发送的是0。

3551
05:00:43.230 --> 05:00:43.433
02.

3552
05:00:43.433 --> 05:00:45.161
如果代入0。

3553
05:00:46.180 --> 05:00:52.391
回到值部分，我们再次调用字体，在这个事

3554
05:00:52.391 --> 05:00:58.930
务完成后，我们应该看到这个数字从0开始。

3555
05:00:58.930 --> 05:00:59.695
02到0。

3556
05:00:59.695 --> 05:00:59.913
04.

3557
05:00:59.913 --> 05:01:07.998
现在，在我们等待一个短暂的延迟之后，我们确实看到余额已经上升到0。

3558
05:01:07.998 --> 05:01:10.649
04，这正是我们所期望的。

3559
05:01:10.649 --> 05:01:11.138
太棒了。

3560
05:01:11.138 --> 05:01:14.248
所以我们的融资机制运转正常。

3561
05:01:14.248 --> 05:01:20.452
如果我们向下到数组中，我们的地址到数组的映射，

3562
05:01:20.452 --> 05:01:26.656
我们粘贴地址，我们应该会看到电话号码显示出来。

3563
05:01:26.656 --> 05:01:29.913
如果我们去找零资助者，我们会看到我们的地址。

3564
05:01:29.913 --> 05:01:37.089
如果我们去找一家的资助者，我们也会看到我们的地址我们会看到这个调用如果我们去找

3565
05:01:37.089 --> 05:01:44.265
资助者，在我们的日志中，我们实际上会看到我们会得到一个错误我们可以在未来对我们

3566
05:01:44.265 --> 05:01:51.443
的合同做的优化是检查一个地址是否已经在资助者数组中如果它已经在那里就不添加它。

3567
05:01:51.443 --> 05:01:54.680
现在我们试着调用这个取款函数。

3568
05:01:54.680 --> 05:02:00.040
我们用一个不同的地址来调用它而不是我们最初部署契约的地址。

3569
05:02:00.040 --> 05:02:04.466
要做到这一点，滚动到这里的顶部。

3570
05:02:04.466 --> 05:02:07.657
我要去找我的超元面具了。

3571
05:02:07.657 --> 05:02:13.130
我要切换到另一个账户，点击连接。

3572
05:02:13.130 --> 05:02:19.478
现在，我们的混音应该会随着这里的新帐户而更新，你会看到如果我

3573
05:02:19.478 --> 05:02:25.826
切换回帐户1，它也会切换回帐户1，只要它们都是连接的，你可以

3574
05:02:25.826 --> 05:02:32.388
通过点击连接按钮看到哪些帐户连接到应用程序，看看哪些已经连接。

3575
05:02:32.388 --> 05:02:37.768
如果你想断开该帐户，你可以点击这三个小点，它就会断开该帐户。

3576
05:02:37.768 --> 05:02:41.431
现在我们可以看到这个账户没有连接。

3577
05:02:41.431 --> 05:02:43.931
然而，计数二是连接的。

3578
05:02:43.931 --> 05:02:50.373
让我们回到帐户1，连接帐户1，这样它们现在都是连接的。

3579
05:02:50.373 --> 05:02:59.045
但我们要切换到账户2，切换到账户2，因为账户2不是合同的所有者。

3580
05:02:59.045 --> 05:03:07.602
我们向下滚动到所有者，我们可以看到所有者的0x 1066某某账户2是0x 043。

3581
05:03:07.602 --> 05:03:09.566
一些很棒的东西。

3582
05:03:09.566 --> 05:03:16.536
当我们点击这里的取款，你认为会发生什么?好吧，我们的修改器的唯一所有者应该踢。

3583
05:03:16.536 --> 05:03:23.117
我们会得到通知如果我们发送事务，我们会得到这个错误sender不是owner。

3584
05:03:23.181 --> 05:03:24.334
我们来试试。

3585
05:03:27.181 --> 05:03:27.870
这个错误。

3586
05:03:27.870 --> 05:03:30.490
发送者不是所有者，这很完美。

3587
05:03:31.181 --> 05:03:34.906
如果我们想，我们完全可以发送这个事务。

3588
05:03:34.906 --> 05:03:39.886
但这只是浪费汽油，因为交易将会失败。

3589
05:03:39.886 --> 05:03:46.920
但是，如果我们切换回账号1，点击取款，元掩码就会

3590
05:03:46.920 --> 05:03:54.248
弹出，使我们能够确认并从这个合同地址中提取以太币。

3591
05:03:54.248 --> 05:04:01.283
现在，如果我们通过以太扫描查看合同地址，经过短暂的延迟后，我们会看到余额从0变为0。

3592
05:04:01.283 --> 05:04:03.316
回到0。

3593
05:04:03.316 --> 05:04:09.018
我们会看到我们的钱包余额从原来的增加到0。

3594
05:04:09.018 --> 05:04:10.263
04加上它是多少。

3595
05:04:10.263 --> 05:04:16.821
在短暂的延迟之后，你可以看到我们合同上的余额实际上已经回到了零。

3596
05:04:16.821 --> 05:04:22.515
现在，如果我们对正在进行融资的钱包地址进行地址到金额的操作，它就会回到0。

3597
05:04:22.515 --> 05:04:31.228
如果我们试图检查指数为0的资助者的地址，

3598
05:04:31.228 --> 05:04:39.070
我们会被呼叫到那些执行错误的资助者。

3599
05:04:40.182 --> 05:04:43.665
我们已经完成了这一节中我想讲的所有基础知识。

3600
05:04:43.665 --> 05:04:51.915
你应该为自己走到这一步而感到无比自豪，你刚刚部署了一个非常先进的智能合约，我们正在使用库和链链

3601
05:04:51.915 --> 05:05:00.165
合约来构建一些地球上最强大的应用程序，我们已经学会在智能合约中使用库来实现我们想要的任何类型。

3602
05:05:00.165 --> 05:05:06.126
我们已经学习了更多关于乘法的知识，以及稳定性和智能合约的计量单位。

3603
05:05:06.182 --> 05:05:11.822
我们已经学习了映射更多的关于数组的构造函数是做什么的，我们已经学习了如何送钱我们

3604
05:05:11.822 --> 05:05:17.603
已经学习了for循环，我们已经学习了我们实际上可以送钱的不同方式，至少从低层次上。

3605
05:05:17.603 --> 05:05:18.962
我们学了修饰语。

3606
05:05:18.962 --> 05:05:21.314
这部分是本课程中比较难的部分。

3607
05:05:21.314 --> 05:05:24.288
所以如果你完成了这个，你应该非常兴奋。

3608
05:05:24.288 --> 05:05:26.340
我们现在要过一遍代码。

3609
05:05:26.340 --> 05:05:28.603
我们会做一些调整。

3610
05:05:28.603 --> 05:05:33.021
这一节，我们要讲一些更高级的固体性。

3611
05:05:33.021 --> 05:05:36.563
所以如果你有点迷路了，不要太担心。

3612
05:05:36.563 --> 05:05:40.115
你们将来也可以自己尝试这些东西。

3613
05:05:40.115 --> 05:05:45.611
我们要修改这份合同，使它更专业一点。

3614
05:05:45.611 --> 05:05:48.789
这不会是从头到尾的惊人，但会好一点。

3615
05:05:48.789 --> 05:05:49.827
你马上就会知道为什么了。

3616
05:05:49.827 --> 05:05:54.389
我们要做的第一件事是我们要看我们要看这里的一些变量。

3617
05:05:54.389 --> 05:06:00.849
特别是业主和最低美元，业主在我们的合同中只得到一次。

3618
05:06:00.849 --> 05:06:02.860
它永远不会改变。

3619
05:06:02.860 --> 05:06:09.199
同样，最小USD只设置一次，即使在构造函数之外也是如此。

3620
05:06:09.199 --> 05:06:17.241
如果我们的变量只设置一次，我们可以用一些固体的工具让它们更省气。

3621
05:06:17.241 --> 05:06:22.133
现在，让我们编译Funmi契约，然后将其部署到一个JavaScript虚拟机上。

3622
05:06:22.183 --> 05:06:25.505
记住，我们现在就可以部署它。

3623
05:06:26.183 --> 05:06:29.792
融资，撤资，用钱做这些事是行不通的。

3624
05:06:29.792 --> 05:06:34.183
因为我们的JavaScript虚拟机上没有链式链接网络。

3625
05:06:34.183 --> 05:06:36.083
所以这些不会很好地工作。

3626
05:06:36.183 --> 05:06:38.649
但对于我们现在要做的，我们并不太在意。

3627
05:06:38.649 --> 05:06:40.582
这是我们真正关心的。

3628
05:06:40.582 --> 05:06:44.468
你肯定很在意这车到底要花多少汽油。

3629
05:06:44.468 --> 05:06:50.140
我们关心的是现在创建这个合同需要多少汽油，

3630
05:06:50.140 --> 05:06:56.083
大约859,000汽油，我们将添加一些技巧。

3631
05:06:56.183 --> 05:07:01.748
现在，为了降低这个数字，我们将在出价中添加一些东西，这将使它上升。

3632
05:07:01.748 --> 05:07:04.374
但现在，我们要学习一些技巧来降低这个数字。

3633
05:07:04.374 --> 05:07:10.127
我们要学的两个技巧是常量关键字和不可变关键字，它们的稳定性。

3634
05:07:10.184 --> 05:07:14.829
有两个关键字使得你的变量不能被改变。

3635
05:07:14.829 --> 05:07:17.796
这些关键字是常量和不可变的。

3636
05:07:17.796 --> 05:07:24.517
您可以在稳定性文档中了解更多关于它们的内容，如果您在函数外部赋值一个变量，然

3637
05:07:24.517 --> 05:07:31.238
后永远不更改它，所以如果如果它在编译时赋值，您可以继续并添加这个常量关键字。

3638
05:07:31.238 --> 05:07:33.103
我们稍后将学习存储。

3639
05:07:33.103 --> 05:07:40.724
但是，当您添加一个常量关键字时，这个最低美元不再占用存储点，也更容易读取。

3640
05:07:40.724 --> 05:07:43.911
现在我们重新编译这个，部署这个新契约。

3641
05:07:43.911 --> 05:07:46.638
看看能不能省点油。

3642
05:07:46.638 --> 05:07:51.169
我们查看事务日志，现在，我们可以获取部署成本

3643
05:07:51.169 --> 05:07:55.701
的事务成本，让我们将其与之前的成本进行比较。

3644
05:07:55.701 --> 05:08:02.078
我们节省了近19,000汽油，这几乎和运送Aetherium的成本一样多。

3645
05:08:02.078 --> 05:08:05.541
通常，常量变量有不同的命名约定。

3646
05:08:05.541 --> 05:08:09.834
通常情况下，你会像Min imaam那样把它们都大写。

3647
05:08:09.834 --> 05:08:13.802
下划线，他是CIO，所有的大写都是下划线。

3648
05:08:13.802 --> 05:08:17.902
现在我们求最小使用量D，用大写字母替换。

3649
05:08:17.902 --> 05:08:22.700
通过这种交互，我们知道这个变量是一个常数变量，如果我

3650
05:08:22.700 --> 05:08:27.684
们继续编译它并重新部署它，从现在开始读取它会便宜得多。

3651
05:08:27.684 --> 05:08:35.737
在Funmi契约中，尽管这是一个视图函数，记住，视图函数是有气体成本的当

3652
05:08:35.737 --> 05:08:43.791
被契约作为常量变量调用时，我们可以看到这个变量的执行成本21415气体。

3653
05:08:43.791 --> 05:08:47.106
让我们用内森来表示。

3654
05:08:47.185 --> 05:08:50.971
如果我们删除常量变量，我们就删除了这个契约。

3655
05:08:50.971 --> 05:08:53.725
我们重新部署，就像Funmi。

3656
05:08:53.725 --> 05:08:58.507
我们再次到达最小值ust，我们可以看到这花费了多少汽油。

3657
05:08:58.507 --> 05:09:03.136
如果它不是一个常数变量，我们可以看到汽油成本确实上升了。

3658
05:09:03.185 --> 05:09:07.736
现在在更便宜的链条上，这种气体差异可能不会有太大的区别。

3659
05:09:07.736 --> 05:09:11.874
但在像Aetherium这样更昂贵的连锁店，这将带来很大的不同。

3660
05:09:11.874 --> 05:09:17.092
例如，在Aetherium上，我们可以看到当前的天然气价格。

3661
05:09:17.092 --> 05:09:24.529
这里，我们可以看到Aetherium当前的天然气价格大约是141路，所以我们将转到

3662
05:09:24.529 --> 05:09:31.966
转换器，我们将价格乘以这个方式，我们将得到天然气价格调用我们的最小美元，就是这个数

3663
05:09:31.966 --> 05:09:39.768
字，如果我们把这个数字放回Aetherium单转换器，我们可以看到天然气价格是这么多。

3664
05:09:39.768 --> 05:09:46.023
如果我们用这个乘以Aetherium的当前价格，也就是3000美元左右。

3665
05:09:46.023 --> 05:09:53.759
将最小使用量D设为常数将花费9美元而在非常数情况下将花费几乎整整

3666
05:09:53.759 --> 05:10:01.495
一美元，你可以看到所有这些气体优化技巧将如何使你的生活变得更好。

3667
05:10:01.495 --> 05:10:03.770
我们把这个常量关键字保留在这里。

3668
05:10:03.770 --> 05:10:07.753
我们将在本课程后面的部分学习更多关于常数和存储的知识。

3669
05:10:07.753 --> 05:10:13.338
现在，当你刚刚开始学习这门课的时候，在滑倒的时候不要挣扎。

3670
05:10:13.338 --> 05:10:20.879
在一开始，特别是现在，不要担心如何使你的合同尽可能的省油。

3671
05:10:20.879 --> 05:10:23.293
尽你所能把合同写好。

3672
05:10:23.293 --> 05:10:25.262
一旦你对汽油很在行。

3673
05:10:25.262 --> 05:10:34.024
一旦你在这门课上走得更远，在固体性方面走得更深入了，你就可以回去研究气体优化了。

3674
05:10:34.024 --> 05:10:37.056
但不要让气体优化阻碍你的发展。

3675
05:10:37.186 --> 05:10:40.347
或者如果你开始为此感到压力，就随它去吧。

3676
05:10:41.186 --> 05:10:43.720
你只需要尽可能地编写你的代码。

3677
05:10:44.186 --> 05:10:47.878
简而言之，现在不要担心气体优化。

3678
05:10:48.186 --> 05:10:51.820
另一个只设置一次的变量是我们的所有者变量。

3679
05:10:51.820 --> 05:10:54.359
所有者等于消息点发送方。

3680
05:10:54.359 --> 05:11:01.474
我们在构造函数变量中设置了一次但在声明的同一行之外。

3681
05:11:01.474 --> 05:11:09.161
例如，我们在构造函数中设置它们，我们可以标记为可变的通常标记不可变变量的一个很好的惯例

3682
05:11:09.161 --> 05:11:17.028
是，我用下划线标记，这样我们就知道这些是不可变变量，它们和常量关键字节省的时间非常相似。

3683
05:11:17.028 --> 05:11:25.186
当然，Owner是一个我们不能在这一行上设置的变量因为在全局作用域内，没有函数。

3684
05:11:25.186 --> 05:11:33.979
不过，在函数内部，因为在全局作用域内，没有message sender，只有message。sender当我们在函数内部时。

3685
05:11:33.979 --> 05:11:37.616
在这里，我们可以说iowner = message。sender。

3686
05:11:37.616 --> 05:11:44.686
当然，我们会向下滚动我们会改变这个require only owner now = iowner。

3687
05:11:44.686 --> 05:11:51.895
如果我们编译这个deploy，我们可以看到有多少gas我们可以看到调用I

3688
05:11:51.895 --> 05:11:59.907
owner会有多少gas通过不可变通知，我们得到21508，我们现在继续复制。

3689
05:11:59.907 --> 05:12:03.044
我们在这里写上，不可变。

3690
05:12:03.044 --> 05:12:09.218
现在，如果我们删除immutable关键字，让我们关闭这个重新部署。

3691
05:12:09.218 --> 05:12:13.924
如果我们向下滚动到I所有者，把日志弄乱，我们向下

3692
05:12:13.924 --> 05:12:18.631
滚动到调用，向下滚动，我们看到执行成本要多得多。

3693
05:12:18.631 --> 05:12:25.083
我们用反斜杠，这里是7，或者是非不可变的。

3694
05:12:25.083 --> 05:12:30.726
在存储变量时，你们要记住这些技巧。

3695
05:12:30.726 --> 05:12:35.432
这两个节省时间的原因是，我们不是将这些变量存储

3696
05:12:35.432 --> 05:12:40.344
在存储槽中，而是将它们直接存储在契约的字节码中。

3697
05:12:40.344 --> 05:12:49.237
就像我说的，现在不要太担心这个，在后面的课程中，我们会教你们更多关于存储的知识以及很多与这些契约相关的低级知识。

3698
05:12:49.237 --> 05:12:51.742
但现在，只需要知道它们的存在。

3699
05:12:51.742 --> 05:12:57.669
如果你只设置一次变量，它们是很好的省油器。

3700
05:12:57.669 --> 05:12:59.008
好了,好了。

3701
05:12:59.187 --> 05:13:06.219
我们让合同更节能了一点，我在这门课中会讲到一些节能的概念。

3702
05:13:06.219 --> 05:13:11.140
当我们讲到更高级的部分时，我会详细分析到底发生了什么，为

3703
05:13:11.140 --> 05:13:16.237
什么会有这些气体效率以及这些气体效率产生的背后发生了什么。

3704
05:13:16.237 --> 05:13:20.141
这是一个有点杂草，这就是为什么我现在要掩盖它。

3705
05:13:20.187 --> 05:13:25.387
如果你感到困惑，别担心，我不会让气体效率影响你的速度。

3706
05:13:25.387 --> 05:13:25.787
太棒了。

3707
05:13:25.787 --> 05:13:32.539
我们有这两种气体优化?我们还能怎样让这份合同更省油呢?我们有一种更节

3708
05:13:32.539 --> 05:13:38.298
省气体的方法，就是用require语句更新require，

3709
05:13:38.298 --> 05:13:46.043
我们需要将sender不是owner存储为字符串数组，errorlog中的每一

3710
05:13:46.043 --> 05:13:53.394
g中的每一个字符都需要单独存储，这个字符串看起来不是很大，但它比另一种方法要大得多。

3711
05:13:53.394 --> 05:13:54.663
从零点开始，点8。

3712
05:13:54.663 --> 05:13:58.489
4的稳定性，你现在可以定制误差。

3713
05:13:58.489 --> 05:14:06.774
对于我们的还原，我们在顶部声明它们，然后使用if，而不是require，然后只添加一个还原语句。

3714
05:14:06.774 --> 05:14:15.323
这最终节省了很多气体，因为我们只是调用错误代码，而不是调用与空气相关的整个字符串。

3715
05:14:15.323 --> 05:14:20.445
举个例子，下面的require，还有所有的require，

3716
05:14:20.445 --> 05:14:25.568
我们可以不写这个require我们可以创建一个自定义错误。

3717
05:14:25.568 --> 05:14:32.188
在顶部，我们可以写error，而不是owner。

3718
05:14:32.188 --> 05:14:38.091
你会注意到这实际上是在合同之外的。

3719
05:14:38.091 --> 05:14:45.349
现在我们能做的是将这个error not owner向下滚动到我们唯一的

3720
05:14:45.349 --> 05:14:51.599
所有者，而不是require我们会做一个if语句，我们会说if

3721
05:14:51.599 --> 05:15:00.067
message。sender不是owner，然后我们会用一个非所有者错误进行恢复。

3722
05:15:00.188 --> 05:15:05.670
这为我们节省了很多气体，因为我们不需要储存和释放这么长的绳子。

3723
05:15:05.670 --> 05:15:12.413
在现在的很多代码中，你仍然会看到require有很多地方因为这些自定义错误在坚固性方面是很新的。

3724
05:15:12.413 --> 05:15:14.854
所以你要习惯两种写法。

3725
05:15:14.854 --> 05:15:20.619
如果在未来，这些错误的语法看起来像这样，我不会感到惊讶，因此它更可读。

3726
05:15:20.619 --> 05:15:28.654
但是现在，如果你想用一种比要求的更省油的方法，你可以用这样的方法，我们可以为这些客户更新所有的要求。

3727
05:15:28.654 --> 05:15:32.389
但现在，我把两者都留在这里，给你们看看它们的区别。

3728
05:15:32.389 --> 05:15:37.734
这个revert关键字所做的事情与要求我们做的完全相同，但没有预先设置条件。

3729
05:15:37.734 --> 05:15:43.576
你可以在函数调用中间恢复任何事务或任何函数调用。

3730
05:15:43.576 --> 05:15:48.995
现在让我们看看另一种改进合同的方法。

3731
05:15:49.189 --> 05:15:58.141
有时，人们会尝试与接受Aetherium或原生区块链令牌的合约进行交互，而不实际执行所需的函数调用。

3732
05:15:58.141 --> 05:16:05.322
例如，在JavaScript EVM中，我可以在不调用fund函数的情况下发送合约资金。

3733
05:16:05.322 --> 05:16:11.342
但是，如果我这样做，我们的基金函数会被触发吗?不，它不会被触

3734
05:16:11.342 --> 05:16:17.564
发，我们不会跟踪那个资助者，我们不会在合同中更新那个人的信息。

3735
05:16:17.564 --> 05:16:21.989
所以如果以后我们想要给予奖励或其他我们不知道的资助者的信息。

3736
05:16:21.989 --> 05:16:28.722
这并不是什么好事，因为人们会在我们不知情的情况下把合同款项寄给我们，我们就无法给他们任何信用或其他东西。

3737
05:16:28.722 --> 05:16:34.680
另外，也许他们不小心调用了错误的函数，他们他们没有使用Metamask。

3738
05:16:34.680 --> 05:16:39.223
他们没有使用工具来告诉他们，嘿，这个交易可能会失败。

3739
05:16:39.223 --> 05:16:45.452
在这种情况下我们能做什么?如果有人没有调用fun函数就发送了

3740
05:16:45.452 --> 05:16:51.888
这个合约，会发生什么?现在，如果我们要发送这份Funmi合同，

3741
05:16:51.888 --> 05:16:57.911
也就是说，它只会进入合同，而这个合同不会记录那些人的信息。

3742
05:16:57.911 --> 05:17:05.640
但实际上有一种方法，当人们向这个合约汇钱，或调用一个我们不存在的函数时，仍然会触发一些代码。

3743
05:17:05.640 --> 05:17:13.500
固体中有两个特殊的函数一个叫接收，一个叫回退。

3744
05:17:13.500 --> 05:17:21.750
在固性中，实际上有很多特殊函数其中两个是接收特殊函数。

3745
05:17:21.750 --> 05:17:29.134
以及备用的特殊功能，一个合同最多可以有一个使用已收到的外部应付款项声明的接收功能。

3746
05:17:29.190 --> 05:17:30.717
没有function关键字。

3747
05:17:32.190 --> 05:17:37.086
参数不能返回任何东西，必须具有外部可见性和可支付状态可变性。

3748
05:17:37.086 --> 05:17:43.534
这到底是什么意思?和或看起来像?让我们创建一个单独的契约来处理这个。

3749
05:17:43.534 --> 05:17:48.461
在这里，我们要创建一个新文件叫做fallback example。soul。

3750
05:17:48.461 --> 05:17:53.866
在这里，我们将添加我们的基本部分，SPX许可标识符，

3751
05:17:53.866 --> 05:17:59.271
MIT pragma, solidity 0，点8。

3752
05:17:59.271 --> 05:17:59.402
7.

3753
05:17:59.402 --> 05:18:05.460
我们会做一个契约回退的例子，就像这样，可以暂停视频来复习这一

3754
05:18:05.460 --> 05:18:11.720
点，让我们重新创建回退契约，让我们创建一个变量来测试这个函数，

3755
05:18:11.720 --> 05:18:17.577
我们会创建一个un256 public result变量。

3756
05:18:17.577 --> 05:18:19.464
我们来创建这个receive函数。

3757
05:18:19.464 --> 05:18:25.081
我们写上receive，它是外部应付账款。

3758
05:18:25.190 --> 05:18:29.936
函数，我们没有为receive添加function关键字，

3759
05:18:29.936 --> 05:18:38.611
因为solid知道receive是一个特殊的函数，无论何时我们发送Aetherium或在此合同中进行交易。

3760
05:18:38.611 --> 05:18:45.123
现在，只要没有与该事务相关的数据，这个receive函数就会被触发。

3761
05:18:45.191 --> 05:18:49.868
我们现在能做的是我们可以说result = 1。

3762
05:18:50.191 --> 05:18:56.444
让我们在JavaScript虚拟机上测试一下，我们编译这个，我们会编译这个。

3763
05:18:56.444 --> 05:19:02.591
我们会把它部署到Java虚拟机上，我们会部署我们的备胎例子。

3764
05:19:02.591 --> 05:19:11.159
我们会看到result被初始化为什么，因为我们还没有为result设置任何东西，当然，result被初始化为0。

3765
05:19:11.159 --> 05:19:16.875
但如果我们给这个合同送点Aetherium呢?接收将继续并在这里

3766
05:19:16.875 --> 05:19:22.771
被触发，我们实际上可以通过这种低级交互直接向这个合约发送一些材料。

3767
05:19:22.771 --> 05:19:31.005
但在这里，现在不要担心调用数据意味着什么，只需要知道下面这个区域是我们可以发送和处理不同函数的方式。

3768
05:19:31.005 --> 05:19:36.568
我们可以给这个事务添加参数，通过在上面这里调整上面这里的变量。

3769
05:19:36.568 --> 05:19:40.980
如果我们保持调用Data为空，它将和我们在Metamask中一样。

3770
05:19:40.980 --> 05:19:44.246
点击发送，选择合同地址。

3771
05:19:44.246 --> 05:19:50.541
同样，我们不能使用Metamask，因为这是一个虚拟机，而不是我们正在使用的网络之一。

3772
05:19:50.541 --> 05:19:56.175
如果我这样做了，例如，我把这个值改为单向的，所有的都保持为空。

3773
05:19:56.175 --> 05:20:03.905
然后我点击这个事务按钮，它和点击这个发送按钮是一样的，但只是单向发送。

3774
05:20:03.905 --> 05:20:07.287
你认为会发生什么?好吧，让我们试试。

3775
05:20:07.287 --> 05:20:12.379
我们可以在日志区域看到我们确实发送了一个事务。

3776
05:20:12.379 --> 05:20:19.253
如果你看这里的描述，你甚至可以看到它说从某某返回例子，点接收，

3777
05:20:19.253 --> 05:20:26.128
它好像调用了我们的received函数，它应该把结果更新为1。

3778
05:20:26.192 --> 05:20:31.542
如果我们点击result，现在我们可以看到结果被更新为值1。

3779
05:20:31.542 --> 05:20:33.499
我们把这个删掉。

3780
05:20:33.499 --> 05:20:36.037
让我们再次部署这个契约。

3781
05:20:36.037 --> 05:20:41.925
这一次，设这个值为0,receive会被触发。

3782
05:20:41.925 --> 05:20:43.159
我们把它拉下来。

3783
05:20:43.159 --> 05:20:44.078
点击交易。

3784
05:20:44.078 --> 05:20:48.128
让我们让调用数据为空，让值为零。

3785
05:20:48.128 --> 05:20:54.275
所以这和我们向合同中发送零Aetherium是一样的。

3786
05:20:54.275 --> 05:20:55.628
点击交易。

3787
05:20:55.628 --> 05:21:02.555
看起来已经通过了，你认为结果会是1还是0 ?你认为一个你是正确的

3788
05:21:02.555 --> 05:21:09.699
或者接收函数被触发我们现在向这个合约发送一个事务，我们不指定函数。

3789
05:21:09.699 --> 05:21:14.463
当与Funmi等其他合同合作时，我们保持通话数据为空。

3790
05:21:14.463 --> 05:21:22.730
例如，当我们调用其中一个函数时，我们实际上只是用特定的数据填充调用数据位指向上面这些函数中的一个。

3791
05:21:22.730 --> 05:21:28.642
如果我们发送一个事务并向它添加数据，我们实际上可以调用其中一个函数。

3792
05:21:28.642 --> 05:21:29.869
现在我们再试一次。

3793
05:21:29.869 --> 05:21:33.930
让我们再次删除契约，我们将重新部署打开它，

3794
05:21:33.930 --> 05:21:39.345
结果是0接收，就像我说的，只有当调用数据为空时才会触发。

3795
05:21:39.345 --> 05:21:43.873
这次如果我有一些调用数据到这个事务，你认为接收会被触发吗?

3796
05:21:43.873 --> 05:21:50.588
如果我们点击transaction和remix我们会弹出一个提示说，回退函数没有定义。

3797
05:21:50.588 --> 05:21:55.854
这是因为，当数据通过事务可靠度发送时，就会说，哦，好吧，

3798
05:21:55.854 --> 05:22:00.744
既然你在发送数据，你就不寻找接收，而是寻找某个函数。

3799
05:22:00.744 --> 05:22:03.571
我来帮你们找找这个函数。

3800
05:22:03.571 --> 05:22:07.243
我没有看到任何函数匹配0x00。

3801
05:22:07.243 --> 05:22:09.982
我要找你的备用函数。

3802
05:22:09.982 --> 05:22:13.572
Remix很聪明，知道我们没有备用函数。

3803
05:22:13.572 --> 05:22:17.143
固体中的第二个特殊函数叫做回退函数。

3804
05:22:17.193 --> 05:22:24.761
这与接收函数非常相似，不同之处在于，即使数据随事务一起发送，它也可以工作。

3805
05:22:24.761 --> 05:22:31.553
我们的后备方案就像这个回调，外部应付。

3806
05:22:31.553 --> 05:22:40.035
Fallback是另一个我们不打算放函数选择器的函数因为固位性期

3807
05:22:40.035 --> 05:22:48.783
望这个，实际上，你们已经熟悉了另一个特殊函数，我们回到Funmi。

3808
05:22:48.783 --> 05:22:53.242
例如，构造函数是另一种类型的特殊函数。

3809
05:22:53.242 --> 05:22:55.078
没有函数关键字。

3810
05:22:55.078 --> 05:22:59.548
坚固性知道，当我们部署这个契约时，这个构造函数会立即被调用。

3811
05:22:59.548 --> 05:23:02.056
现在我们有了回退函数。

3812
05:23:02.193 --> 05:23:04.161
让我们继续编译它。

3813
05:23:06.193 --> 05:23:09.660
让我们继续部署这个新契约。

3814
05:23:11.193 --> 05:23:13.923
结果，我们确实看到了，它被设为零。

3815
05:23:15.193 --> 05:23:20.065
0x00，我发送这个，然后点击交易，

3816
05:23:20.065 --> 05:23:24.668
这相当于调用合约，但没有有效函数。

3817
05:23:24.668 --> 05:23:29.630
所以我们的合同是这样的，嗯，我不明白你想告诉我什么，我建议你参考我们的备用方案。

3818
05:23:29.630 --> 05:23:33.431
如果我们点击result，我们会看到它被更新为2。

3819
05:23:33.431 --> 05:23:41.144
如果我们把这个拿走，固体就会消失，嗯，看起来你在试图发送一些Aetherium，或者调用这个合同，但没有说明你想做什么。

3820
05:23:41.144 --> 05:23:42.744
我有一个接收函数。

3821
05:23:42.744 --> 05:23:45.418
所以我要把它转发给你。

3822
05:23:45.418 --> 05:23:51.350
如果我们调用transact，我们会看到它更新回1，添加一些数据，

3823
05:23:51.350 --> 05:23:58.720
点击transact，我们会看到它更新到无数据，慢慢地更新到1例如，org有一个很

3824
05:23:58.720 --> 05:24:05.732
有一个很好的图表我们可以用它来判断是否会触发receive，或者触发Fallback。

3825
05:24:05.732 --> 05:24:09.755
如果它是空的，并且有一个receive函数，它会调用receive函数。

3826
05:24:09.755 --> 05:24:15.194
如果是data，而没有receive函数，它就会去回退函数。

3827
05:24:15.194 --> 05:24:18.527
如果没有备用功能，它可能它可能会被空气排出。

3828
05:24:18.527 --> 05:24:21.501
这里有很多非常棒的信息。

3829
05:24:21.501 --> 05:24:28.640
如何将其应用到fund mi合约中呢，Funmi中我们能做的是添加这些

3830
05:24:28.640 --> 05:24:35.780
回退和接收函数，以防有人给我们发送合约资金而不是正确调用fund函数。

3831
05:24:35.780 --> 05:24:39.008
我们能做的是添加一个接收函数。

3832
05:24:39.008 --> 05:24:43.551
如果有人不小心给它寄了钱，我们仍然可

3833
05:24:43.551 --> 05:24:48.095
以处理这个交易说，接收将是外部支付。

3834
05:24:48.194 --> 05:24:51.319
我们会有receive函数调用基金。

3835
05:24:52.194 --> 05:24:59.030
与我们的fallback函数相同的事情将有fallback external payable。

3836
05:24:59.030 --> 05:25:03.964
我们会让它自动调用基金。

3837
05:25:04.194 --> 05:25:04.747
现在，

3838
05:25:04.747 --> 05:25:13.240
如果有人不小心给我们汇了钱而没有调用我们的fund函数，它仍然会自动把钱路由到fund函数。

3839
05:25:13.240 --> 05:25:19.581
这意味着，如果有人没有给我们提供足够的资金，这笔交易仍然会被退回。

3840
05:25:19.581 --> 05:25:20.645
现在我们继续。

3841
05:25:20.645 --> 05:25:26.127
让我们切换到溜冰场B，在一个真实的测试网上进行测试，安曼溜冰场B和我的Metamask。

3842
05:25:26.195 --> 05:25:29.340
让我们切换到注射网3号。

3843
05:25:31.195 --> 05:25:32.695
我们会选择Funmi合同

3844
05:25:34.195 --> 05:25:38.928
如果超掩码出现，我就去确认这笔交易。

3845
05:25:38.928 --> 05:25:45.391
我们看到我们的Funmi合同现在我们可以看到所有者我们可以看到我是所有者，我们可以看到最低美元。

3846
05:25:45.391 --> 05:25:50.623
我们可以看到这是一个空白合同，里面没有任何资金。

3847
05:25:50.623 --> 05:25:55.082
如果我们复制地址，然后进行以太扫描，将

3848
05:25:55.082 --> 05:25:59.776
地址粘贴进去，我们可以看到这里没有以太。

3849
05:25:59.776 --> 05:26:02.923
与此相关的唯一交易就是合同的订立。

3850
05:26:02.923 --> 05:26:11.719
当我们遇到fun函数时，我们看到了之前发生的事情，我们的合同更新了一个新的余额，而资助者被添加到我们的数组中。

3851
05:26:11.719 --> 05:26:19.127
看看如果不调用基金函数直接给合约钱会怎样。

3852
05:26:19.195 --> 05:26:26.555
如果我们这样做正确，那么receive函数应该会接收它并将事务踢过字体。

3853
05:26:26.555 --> 05:26:28.768
我们复制这个地址。

3854
05:26:28.768 --> 05:26:30.899
转到元蒙版。

3855
05:26:30.899 --> 05:26:34.998
点击发送，把地址和0粘贴到这里。

3856
05:26:34.998 --> 05:26:35.571
02容易的。

3857
05:26:35.571 --> 05:26:42.445
同样，因为这应该超过以美元计算的最低金额，所以我们将进行下一个操作。

3858
05:26:42.445 --> 05:26:44.661
我来确认一下。

3859
05:26:44.661 --> 05:26:52.972
在稍微延迟之后，如果我们这样做是正确的，我们应该看到事务已经调用了这里的基金函数，现在我

3860
05:26:52.972 --> 05:27:01.283
们的事务已经完成了。在等待醚可以更新的短暂延迟之后，我们确实看到我们的余额已经更新为0。

3861
05:27:01.283 --> 05:27:03.769
02，当然，这是有道理的。

3862
05:27:03.769 --> 05:27:11.179
在这里的交易列表中，我们看到这实际上是作为一个转移而不是调用基金函数。

3863
05:27:11.179 --> 05:27:16.098
我们继续混合看看资助者是否更新了。

3864
05:27:16.196 --> 05:27:20.996
看起来它是在0和资助者的位置，我们有我们的地址。

3865
05:27:20.996 --> 05:27:27.481
如果我们把我们的地址输入到“地址”和“资助金额”中，我们就能看到我们到底资助了多少。

3866
05:27:27.481 --> 05:27:34.129
这意味着，既然我们在这里添加了receive函数，我们就必须自动调用这里的fun函数。

3867
05:27:34.196 --> 05:27:40.029
非常棒的工作，我们能够添加一个receive函数来帮助那些不小心调用

3868
05:27:40.029 --> 05:27:45.862
了错误的函数或不小心发送了合同资金，而不是正确调用了fun函数的人。

3869
05:27:45.862 --> 05:27:52.488
现在，如果他们直接调用fun函数，他们会少花一点油，但至少这次，他们会得

3870
05:27:52.488 --> 05:27:59.114
到信用，并把它添加到我们的资助者数组中因为他们发送了我们的融资合同资金。

3871
05:27:59.196 --> 05:28:02.561
我们甚至学习了固体的一些高级部分。

3872
05:28:03.196 --> 05:28:08.089
这将是我们最后一次在remix中开始我们的项目，我们现在将转

3873
05:28:08.089 --> 05:28:13.147
移到代码编辑器，在那里我们可以得到更高级的我们的设置的稳固性。

3874
05:28:13.196 --> 05:28:19.851
在很大程度上，你们已经学习了绝大多数的固体基础知识，还有很多东西我们还没有学到。

3875
05:28:19.851 --> 05:28:23.064
我们没有深入研究它们的原因是它们更高级。

3876
05:28:23.064 --> 05:28:27.434
理解它的真正用途并没有太大意义，直到后来。

3877
05:28:27.434 --> 05:28:31.931
我们会讲到itams事件，try catch函数选

3878
05:28:31.931 --> 05:28:36.609
择器，abi编码，哈希，然后是斜杠，然后是斜杠汇编。

3879
05:28:36.609 --> 05:28:43.647
然而，如果你已经走到这一步，你可能可以阅读大多数的固体代码并理解发生了什么，这绝对是非常棒的。

3880
05:28:43.647 --> 05:28:47.585
所以你应该为自己赢得热烈的掌声，因为你走到了这一步。

3881
05:28:47.585 --> 05:28:48.397
做这个。

3882
05:28:48.397 --> 05:28:55.874
让我们快速总结一下这个更高级的部分确保我们理解了我们在固体学过的东西有几个特殊的函数。

3883
05:28:55.874 --> 05:28:59.368
其中一些是接收回退和构造函数。

3884
05:28:59.368 --> 05:29:03.641
这些函数不需要function关键字。

3885
05:29:03.641 --> 05:29:06.307
相反，它可以这样叫。

3886
05:29:06.307 --> 05:29:09.115
接收和回退是两个非常特殊的函数。

3887
05:29:09.115 --> 05:29:18.000
如果数据与事务一起发送，且未指定函数，则如果存在回退函数，则事务将默认使用回退函数。

3888
05:29:18.000 --> 05:29:22.759
如果data为空，并且有一个receive函数，它会调用receive函数。

3889
05:29:22.759 --> 05:29:27.586
从长远来看，有几个关键词可以帮助我们节省汽油。

3890
05:29:27.586 --> 05:29:30.720
其中一些关键字将是常量和不可变的。

3891
05:29:30.720 --> 05:29:35.308
常量和不可变用于只能声明和更新一次的变量。

3892
05:29:35.308 --> 05:29:39.011
一旦我们说最低美元是50乘以118。

3893
05:29:39.197 --> 05:29:41.971
这个最低美元不能再改变了。

3894
05:29:43.197 --> 05:29:43.748
节省汽油。

3895
05:29:47.197 --> 05:29:56.163
然而，不可变变量只能在构造函数中声明一次，一旦声明了不可变变量，以后就不能更改它了。

3896
05:29:56.163 --> 05:30:01.336
事实上，如果我们试图更新一个不可变变量或常量变量，然后进行编

3897
05:30:01.336 --> 05:30:06.509
译，编译器会给我们一个错误，说，不能在这里写入一个可变变量。

3898
05:30:06.509 --> 05:30:10.024
或者我们试着改变一个常变量。

3899
05:30:10.024 --> 05:30:14.149
我们的编译器会说，嘿，你不能赋值给一个常数变量，抱歉。

3900
05:30:14.197 --> 05:30:20.885
在remix中，如果我们想向JavaScript虚拟机上的合约发送以太，我们可以部署该合约。

3901
05:30:20.885 --> 05:30:27.798
然后在合约中，我们只需要点击事务按钮而不需要任何调用数据并更新与事务一起发送的值。

3902
05:30:27.798 --> 05:30:32.039
如果调用数据为空，它将触发receive函数(如果它存在)。

3903
05:30:32.039 --> 05:30:38.072
但如果有数据没有指定任何

3904
05:30:38.072 --> 05:30:44.105
其他函数，它会触发回退函

3905
05:30:44.105 --> 05:30:50.139
数太棒了，你做得非常好。

3906
05:30:50.198 --> 05:30:54.713
在我们开始讲Hardhead之前，我们先来看看这一部分。

3907
05:30:54.713 --> 05:30:58.179
现在我们来看看JavaScript，理解为什么我们需要这样做。

3908
05:30:58.179 --> 05:31:02.098
让我们来了解一下如何获得帮助和遇到问题。

3909
05:31:02.098 --> 05:31:06.118
假设我们有一个Funmi合约我们刚刚完成了。

3910
05:31:06.118 --> 05:31:07.705
我们遇到了一个错误。

3911
05:31:07.705 --> 05:31:15.493
举个例子，我们忘记了payable关键字，然后我们继续编译这个compile fund，我们这样做了。

3912
05:31:15.493 --> 05:31:16.427
向下滚动。

3913
05:31:16.427 --> 05:31:21.099
很明显，这里有两个错误，我们得到了一些错误，我们向下滚动。

3914
05:31:21.099 --> 05:31:26.284
而我们看到类型错误消息点值和调用值只能是使用和可支付

3915
05:31:26.284 --> 05:31:31.470
的公共函数，使函数可支付或使用内部函数避免这种错误。

3916
05:31:31.470 --> 05:31:34.567
然后它继续播放正在播放的节目。

3917
05:31:34.567 --> 05:31:38.439
这个错误很清楚，这个错误代码很清楚。

3918
05:31:38.439 --> 05:31:43.441
它说，嘿，让函数可支付，或者使用内部函数来避免这个错误，对

3919
05:31:43.441 --> 05:31:48.443
吧?这应该很容易添加payable，然后重新编译就可以了。

3920
05:31:48.443 --> 05:31:51.810
这实际上是一个很好的例子当你遇到错误时该怎么做。

3921
05:31:51.810 --> 05:31:52.616
当你遇到错误的时候。

3922
05:31:52.616 --> 05:31:59.424
你要做的第一件事是你要试着根据错误信息找出到底发生了什么。

3923
05:31:59.424 --> 05:32:06.548
这个很直接，但有些可能会比较模糊第一步是当你试图解除阻塞试图自己修补和找出

3924
05:32:06.548 --> 05:32:13.865
错误时，对吧?因为你可能会说好吧，我会把它变成可支付的，对吧?然后你去存钱。

3925
05:32:13.865 --> 05:32:18.182
然后它给出一个不同的错误说，嘿，你知道，应付的不在这里。

3926
05:32:18.182 --> 05:32:22.976
你重新保存，重新编译，它会说，嘿，我们仍然缺少那个应付的东西。

3927
05:32:22.976 --> 05:32:26.737
第一步总是要试着自己修补和弄清楚。

3928
05:32:26.737 --> 05:32:32.525
对于这门课，我希望你们限制修补，将分类缩减到20分钟，

3929
05:32:32.525 --> 05:32:38.100
如果你修补和分类的时间超过20分钟，那就进入下一步。

3930
05:32:38.100 --> 05:32:44.124
但我也希望你自己至少花15分钟，或者100%

3931
05:32:44.124 --> 05:32:50.149
肯定，你用尽了所有的选择，你完全没有主意了。

3932
05:32:50.149 --> 05:32:53.599
所以一般来说，试着用15分钟来修补一些东西。

3933
05:32:53.599 --> 05:33:01.392
如果你在15分钟之内，你说，嘿，我百分百确定我已经尝试了我能想到的所有方法，然后你就可以进入下一步了。

3934
05:33:01.392 --> 05:33:10.280
第一步，当你遇到错误的时候你总是要做修补者，试着找出到底发生了什么。

3935
05:33:10.280 --> 05:33:12.949
试着找出到底哪里出了问题。

3936
05:33:12.949 --> 05:33:19.516
第二步，假设你修补了所有地方，都尝试了应付，你不知道这个错误是什么，也不知道如何调试。

3937
05:33:19.516 --> 05:33:25.650
第二步总是谷歌精确的误差看你能不能从中学到东西。

3938
05:33:25.650 --> 05:33:34.378
缩小一点，我把鼠标移到上面，抓取它，复制它，或者引号周围，在谷歌中搜索准确的错误花点时间浏览谷歌，

3939
05:33:34.378 --> 05:33:43.463
Stack Overflow, Stack Exchange eath，看看是否有人已经问过这个问题。

3940
05:33:43.463 --> 05:33:49.820
下面这里看起来像是有人输入错误，错过了一个值，调用虽然只能在贝宝公共函数上使用。

3941
05:33:49.820 --> 05:33:53.996
如果我们向下滚动，我们会看到有人正好碰到了这个。

3942
05:33:53.996 --> 05:33:55.589
他们继续解决了这个问题。

3943
05:33:55.589 --> 05:33:59.911
他们说，我意识到我的错误，我需要添加PayPal关键字到我自己的实现。

3944
05:33:59.911 --> 05:34:02.996
题目继续，他们加了应付账款。

3945
05:34:02.996 --> 05:34:06.350
希望这能给你启发说，啊，好，很好。

3946
05:34:06.350 --> 05:34:08.596
我需要回到这里，加上应付账款。

3947
05:34:08.596 --> 05:34:11.555
假设这个StackOverflow问题没有出现。

3948
05:34:11.555 --> 05:34:13.080
对吧?这个论坛不在这里。

3949
05:34:13.080 --> 05:34:15.837
接下来我们做什么?第一步，修补匠。

3950
05:34:15.837 --> 05:34:21.167
第二步，准确的误差，我要做第二步。

3951
05:34:21.167 --> 05:34:27.919
这门课的唯一内容是，去GitHub上的回购讨论，或者这门课的更新，具体来说，

3952
05:34:27.919 --> 05:34:36.450
去GitHub上的回购，完整的区块链固体性课程，Jas，当你们接触它的时候，它看起来会有点不同。

3953
05:34:36.450 --> 05:34:43.771
但是看看这个回购，看看这个按时间顺序更新的部分，看看你正在做的部分是否有更新。

3954
05:34:43.771 --> 05:34:46.762
显然，因为我现在在录音，所以没有更新。

3955
05:34:46.762 --> 05:34:50.958
如果你没有得到任何答案，请随时进入讨论区。

3956
05:34:50.958 --> 05:34:57.717
在这里问一个问题，对吧，这里会有一个社区的人互相帮助，希望让这变得很有趣。

3957
05:34:57.717 --> 05:34:59.088
我之所以说2。

3958
05:34:59.088 --> 05:35:03.734
5是因为在现实世界中，你不会用到我们的GitHub回购，

3959
05:35:03.734 --> 05:35:08.215
在这门课以外的课程中，你不会用到这个GitHub回购。

3960
05:35:08.215 --> 05:35:15.707
所以，在现实世界中，我仍然会给你钥匙，我会给你在任何事情上都能解除障碍的东西。

3961
05:35:15.707 --> 05:35:16.024
好的。

3962
05:35:16.024 --> 05:35:20.596
第三位将在论坛上被问到一个问题，比如stack,

3963
05:35:20.596 --> 05:35:26.312
exchange eath和stack Overflow。

3964
05:35:26.312 --> 05:35:31.135
Stack Overflow是一个像这样的问答技术

3965
05:35:31.135 --> 05:35:36.151
论坛，对吧?你可以问技术问题，然后你也可以回答它们。

3966
05:35:36.151 --> 05:35:44.904
如你所见，当你搜索这些问题时，它们会显示出来所以Stack Overflow更多是针对一般的角色编程问题Stack Exchange

3967
05:35:44.904 --> 05:35:52.198
Aetherium或Stack Exchange eath Aetherium Stack Exchange，

3968
05:35:52.198 --> 05:36:02.942
这是针对更多的基于Aetherium或EVM的问题以及所有我们要处理的固体性代码，无论是多边形，还是雪崩，无论什么，这些问题在这里都是有效的，你可以在这里提问。

3969
05:36:02.942 --> 05:36:08.349
所以你要做的就是注册或登录，在这些表单上提问并格式化你的问题，你要注册GitHub，

3970
05:36:08.349 --> 05:36:14.915
你要注册Stack Exchange，你要注册Stack Overflow，这样你就可以参与这些论坛。

3971
05:36:14.915 --> 05:36:18.138
事实上，如果你还没有，让我们现在就注册GitHub。

3972
05:36:18.138 --> 05:36:25.431
让我来给你们介绍一下这些问题的格式，因为你的问题格式越好，你得到答案的机会就越大。

3973
05:36:25.431 --> 05:36:33.377
记住，当在这些论坛上提问时，当在这些讨论社区中提问时，人们回答这些问题是出于他们的善

3974
05:36:33.377 --> 05:36:41.513
意，对吗?所以如果你没有得到回复，很有可能没有人知道，也许是你的问题格式不太好，等等。

3975
05:36:41.513 --> 05:36:44.439
所以我们将学习如何提出真正的好问题。

3976
05:36:44.439 --> 05:36:47.268
如果你是区块链的新手，不要跳过这部分。

3977
05:36:47.268 --> 05:36:53.089
好了，这就是那件能给你超能力的东西让你从任何遇到的编码问题中解脱出来。

3978
05:36:53.089 --> 05:36:54.582
所以不要跳过这个升级。

3979
05:36:54.582 --> 05:36:55.891
一定要跟着做。

3980
05:36:55.891 --> 05:36:56.163
好的。

3981
05:36:56.163 --> 05:37:00.007
所以，如果你还没有一个GitHub，你确实需要一封电子邮件开始。

3982
05:37:00.007 --> 05:37:03.668
我要登录了，我为这个视频创建了一个一次性账户。

3983
05:37:03.668 --> 05:37:11.019
我们要做的是，注册GitHub，输入你的

3984
05:37:11.019 --> 05:37:18.371
邮箱，点击创建账号，他们会给我们发邮件。

3985
05:37:18.371 --> 05:37:23.096
回到我们的电子邮件，我们有发射代码，把它粘贴进来。

3986
05:37:23.096 --> 05:37:26.577
这是一些信息。

3987
05:37:26.577 --> 05:37:31.452
我们将选择免费版本。

3988
05:37:31.452 --> 05:37:32.630
和美妙的。

3989
05:37:32.630 --> 05:37:34.296
现在我们已经创建了一个GitHub配置文件。

3990
05:37:34.296 --> 05:37:39.983
现在回到智能合约孩子完整区块链的课程，Jas，我将创建一个新的讨论，一

3991
05:37:39.983 --> 05:37:45.833
个新的线程，我希望你们都在上面评论，以确保你们理解如何格式化和如何提问。

3992
05:37:45.833 --> 05:37:48.125
好了，练习的主线。

3993
05:37:48.125 --> 05:37:49.971
格式的问题。

3994
05:37:49.971 --> 05:37:50.432
哦。

3995
05:37:50.432 --> 05:37:52.832
我们回到这里。

3996
05:37:53.202 --> 05:37:59.788
首先，我要把这个问题用两种方式来表达，然后我们要把它表达得非常非常好。

3997
05:37:59.788 --> 05:38:04.443
第一种格式不好的方式，就是没有提供足够的信息。

3998
05:38:04.443 --> 05:38:11.265
我们要做的是复制这一期我们要做的是我们会说，

3999
05:38:11.265 --> 05:38:17.468
嘿，我在混音方面遇到了麻烦，出现了错误。

4000
05:38:17.468 --> 05:38:23.408
有人能帮帮我吗?为什么这不是一个很好的格式问题?如果这是我的问

4001
05:38:23.408 --> 05:38:29.540
题，这里没有足够的信息，我，作为一个帮手，不知道这个人在问什么。

4002
05:38:29.540 --> 05:38:31.105
我们来做点别的。

4003
05:38:31.105 --> 05:38:36.800
我要做的是复制整个合同所有的乐趣，读取大

4004
05:38:36.800 --> 05:38:42.781
底，粘贴到这里，然后说，嗨，我这里有问题。

4005
05:38:42.781 --> 05:38:50.218
有人能帮忙吗?我要在这里开始讨论点击开始讨论，它的格式很奇怪。

4006
05:38:50.218 --> 05:38:53.235
再说一次，这里没有足够的信息。

4007
05:38:53.235 --> 05:38:55.235
我不知道是什么问题。

4008
05:38:55.235 --> 05:38:58.703
但至少对于这个，我们有一些代码，我们有一些方法来进行调试。

4009
05:38:58.703 --> 05:38:59.810
这就好一点了。

4010
05:38:59.810 --> 05:39:01.185
但还是没有那么好。

4011
05:39:01.185 --> 05:39:02.685
我们来编辑这个。

4012
05:39:02.685 --> 05:39:03.989
为了让它变得更好。

4013
05:39:03.989 --> 05:39:10.170
点击三点，点击编辑，我们能做的就是使用Markdown语法，强烈建议大家学习

4014
05:39:10.170 --> 05:39:16.515
一点Markdown语法，这基本上是一些语法帮助我们在GitHub上进行讨论。

4015
05:39:16.515 --> 05:39:20.949
另外，Stack Overflow和Stack Exchange的问题也简单多了。

4016
05:39:20.949 --> 05:39:25.443
所以我们要格式化这段代码通过在开头

4017
05:39:25.443 --> 05:39:30.203
加上这三个反勾，然后在代码末尾也加。

4018
05:39:30.203 --> 05:39:35.493
另外，接下来，前三个反勾，我们要输入所以lid

4019
05:39:35.493 --> 05:39:41.703
did T它告诉格式或者用固体度来格式化这里的代码。

4020
05:39:41.703 --> 05:39:46.944
现在如果我们更新讨论，我们会注意到这里有一些很好的突出显示。

4021
05:39:46.944 --> 05:39:50.091
这样就更容易理解了。

4022
05:39:50.091 --> 05:39:54.055
对吧?这比以前更容易读了。

4023
05:39:54.055 --> 05:39:56.677
然而，它仍然不够具体。

4024
05:39:56.677 --> 05:40:00.530
我们已经给出了大量的代码，但我们还没有给出具体的答案。

4025
05:40:00.530 --> 05:40:03.503
所以这个问题很难回答。

4026
05:40:03.503 --> 05:40:05.153
让我们说得更具体一些。

4027
05:40:05.153 --> 05:40:07.240
让我们再来编辑一下这个问题。

4028
05:40:07.240 --> 05:40:13.423
我们来具体说明一下，看这里，我们的问题是关于这个函数的。

4029
05:40:13.423 --> 05:40:19.140
我们要复制这个函数然后删除这里的所有东西。

4030
05:40:19.203 --> 05:40:22.106
现在我们有了这段代码。

4031
05:40:23.204 --> 05:40:24.677
让它变得更具体。

4032
05:40:26.204 --> 05:40:29.026
函数，我遇到了一个错误。

4033
05:40:31.204 --> 05:40:33.833
我们要做的是回到这里，我们要把它翻转过来。

4034
05:40:33.833 --> 05:40:39.156
我们要复制这个如果想的话，我们可以提取代码但是我们要把这个错误格式化成这样。

4035
05:40:39.204 --> 05:40:43.769
然后我们会说谁能告诉我这是怎么回事?

4036
05:40:43.769 --> 05:40:48.588
更新?这是一个非常非常容易调试的问题。

4037
05:40:48.588 --> 05:40:52.695
对吧?我们有一些极简的代码，我们有我们得到的错误。

4038
05:40:52.695 --> 05:41:00.139
谁能告诉我这是怎么回事?很明显，这个问题的答案是加上应付。

4039
05:41:00.204 --> 05:41:09.089
有人可能会说，嘿，比如，你需要在这里加上应付，我希望你们都练习一下如何格式化，用你们自己的格式化问题对它进行评论。

4040
05:41:09.089 --> 05:41:12.027
这样你们就能理解如何进行格式化。

4041
05:41:12.027 --> 05:41:13.497
还有这个减记格式。

4042
05:41:13.497 --> 05:41:18.576
就是这种格式，这门课在Stack Overflow或Stack

4043
05:41:18.576 --> 05:41:26.113
Exchange上提问时也是一样的，继续练习，如果你想创建更多的讨论，请随意创建新的讨论。

4044
05:41:26.113 --> 05:41:29.898
如果你想用Stack Overflow或Stack Exchange

4045
05:41:29.898 --> 05:41:37.135
eath强烈推荐你也用Stack Overflow或Stack Exchange eath，因为它们的索引比GitHub好得多。

4046
05:41:37.204 --> 05:41:39.928
当然，大家也可以在这个GitHub里随意提问。

4047
05:41:39.928 --> 05:41:44.432
现在我已经给了你们一些基本的纲要，我们将观看一个我制作的视频，

4048
05:41:44.432 --> 05:41:48.937
它将更深入地讲解为什么以及如何格式化所有这些问题以及使用什么。

4049
05:41:48.937 --> 05:41:52.537
我们来看一下。

4050
05:41:52.537 --> 05:41:58.203
每个开发者都遇到过这种情况。

4051
05:41:58.203 --> 05:42:02.505
有东西坏了，或者你不知道什么，但你没有时间让这些阻止你。

4052
05:42:02.505 --> 05:42:09.257
人们应该采取一系列步骤来最大化解决任何编码问题的机会，但你会惊讶地发现，目前很少有

4053
05:42:09.257 --> 05:42:16.174
开发人员有效地使用这个超级功能，我们在第一个方面花的时间最少，因为它只是修补和实验。

4054
05:42:16.205 --> 05:42:17.505
当你遇到问题的时候。

4055
05:42:19.205 --> 05:42:25.825
想想可能会有用，也许可以尝试在整个文件中打印语句，学习一些调试技巧，但不要太骄傲，只做了第一步。

4056
05:42:25.825 --> 05:42:28.786
这不应该是随便乱跑。

4057
05:42:28.786 --> 05:42:36.626
这应该是试图准确指出代码中哪里出了问题，这样您就可以提出一个有效的问题，或者自己找出问题所在。

4058
05:42:36.626 --> 05:42:40.882
所以要准确地指出哪里出了问题，因为在接下来的步骤中您将需要它。

4059
05:42:40.882 --> 05:42:43.117
不管怎样，接下来，检查文档。

4060
05:42:43.117 --> 05:42:45.783
不是所有的工具都有很好的文档。

4061
05:42:45.783 --> 05:42:53.677
但是花点时间浏览文档是找到答案的快速方法，你会想要学习如何用Command F或Control F搜索网页。

4062
05:42:53.677 --> 05:42:59.549
这样，你就可以在页面上查找特定的关键词，或者希望他们有一个很好的搜索栏。

4063
05:42:59.549 --> 05:43:01.598
有时文档可能非常密集。

4064
05:43:01.598 --> 05:43:04.169
所以也许你会进入下一步，那就是做一个网络搜索。

4065
05:43:04.169 --> 05:43:08.696
在一天结束的时候，好的软件工程师私下里只是专业的谷歌人。

4066
05:43:08.696 --> 05:43:16.756
这是他们最强大的工具之一，能够在网上搜索已经遇到过你刚刚遇到的问题的人，然后解决它。

4067
05:43:16.756 --> 05:43:22.170
大多数像谷歌这样的搜索引擎都有一些工具，你可以使用这些工具来更具体地了解你要找的东西。

4068
05:43:22.170 --> 05:43:26.884
通常对于特定的错误，最好的做法是复制准确的错误，并将其与引号粘贴

4069
05:43:26.884 --> 05:43:31.747
到搜索栏中，或者在位置上使用Asterix，你的错误可能太具体了。

4070
05:43:31.747 --> 05:43:39.057
你将从论坛和问答网站中获得大部分的结果，这将引导我们进入下一步，在这些论坛和问答网站中提问。

4071
05:43:39.057 --> 05:43:45.831
只要确保在你提问之前，你已经在谷歌上做了充足的搜索。

4072
05:43:45.831 --> 05:43:48.784
这样你就不会浪费自己和别人的时间。

4073
05:43:48.784 --> 05:43:56.529
通过问问题，你发誓你会向我保证，在某个时刻，你会回去帮助其他人学习，也很好。

4074
05:43:56.529 --> 05:44:02.006
在问问题之前，我们应该知道哪里是最好的提问地点。

4075
05:44:02.006 --> 05:44:08.837
这就是为什么我将不同类型的论坛和QA网站进行分类，请随时暂停阅读。

4076
05:44:08.837 --> 05:44:15.322
这里有一些具体的例子，这些索引代码基础形式，如Stack Overflow，索引仓库，

4077
05:44:15.322 --> 05:44:21.506
如GitHub问题，索引技术，特定的论坛，如我们的slash eat dev或未索

4078
05:44:21.506 --> 05:44:28.144
的讨论平台，如chainlink discord，这些类别的关键区别之一是索引关键字。

4079
05:44:28.206 --> 05:44:35.140
我们通常希望在论坛上问问题，网络爬虫已经通过，并将他们插入他们的数据库或以这种方式索引他们。

4080
05:44:35.140 --> 05:44:41.156
三周后，当我们回头看我们写的代码时，当我们忘记它是做什么的时候，我们可以不知道发生了什么。

4081
05:44:41.156 --> 05:44:47.583
这将帮助其他遇到相同问题的开发人员，反过来，他们可能会在后面帮助您解决问题。

4082
05:44:47.583 --> 05:44:53.706
理想情况下，您的大多数问题都应该在这些索引表单中提出，因为它们具有可搜索性和可发现性。

4083
05:44:53.706 --> 05:45:00.371
然而，有些问题更适合DMS, Twitter或discord，它们不是索引，我们在这里做了一个小

4084
05:45:00.371 --> 05:45:07.175
图表，找出张贴你的问题的最佳位置，请随意暂停视频看一看或阅读我们的博客和描述的图片以及另一个看它。

4085
05:45:07.206 --> 05:45:15.013
当然，在这些论坛发布之前，一定要阅读他们的规则，因为他们可能会声明某些问题是专门为本准备的。

4086
05:45:15.013 --> 05:45:17.991
但基本上分解是这样的。

4087
05:45:17.991 --> 05:45:23.840
理论的大方向或观点的问题可以在一般的问答论坛，如Quora或特定的技术论坛，

4088
05:45:23.840 --> 05:45:31.536
如特定的reddits或discord论坛，具体的编码问题也可以在这些论坛，但通常会得到更多的关注在

4089
05:45:31.536 --> 05:45:39.386
更多的关注在编码论坛，如Stack Overflow或Stack Exchange社区，通常的问题是，

4090
05:45:39.386 --> 05:45:45.391
哦，我应该把这张贴在堆栈URL?flow或者Stack Exchange社区是非常模糊的。

4091
05:45:45.391 --> 05:45:47.340
有时候你在哪个网站上发帖并不重要。

4092
05:45:47.340 --> 05:45:53.656
现在，如果您在非常熟悉的技术上遇到bug或问题，并且您认为它不应该出现

4093
05:45:53.656 --> 05:46:00.153
故障，那么这就是您将问题放入他们的开放源代码存储库并可能改进工具的机会。

4094
05:46:00.207 --> 05:46:08.514
他们没有开放源代码库，你把封闭源代码扔进垃圾桶，但开玩笑的是，封闭源代码技术在我们的生活中也有一席之地。

4095
05:46:08.514 --> 05:46:13.181
此外，如果你正在学习一个教程，他们有一个Git回购与它相

4096
05:46:13.181 --> 05:46:18.016
关联，就像我所有的视频一样，这将是最好的地方留下你的问题。

4097
05:46:18.016 --> 05:46:22.804
所以尽管我很讨厌这么说，但把你的问题放到我的GitHub知

4098
05:46:22.804 --> 05:46:27.592
识库中比把它放在YouTube评论中更有效地回答你的问题。

4099
05:46:27.592 --> 05:46:32.341
现在，最后，Discord，元素，电子邮件，短信或任何其他这些未

4100
05:46:32.341 --> 05:46:37.239
被索引的聊天仍然是问问题的好地方，但请尝试使用它们作为最后的手段。

4101
05:46:37.239 --> 05:46:45.439
如果他们确实回答了你的一个问题，也许回去把这个问题和答案添加到我们刚才讨论过的其他论坛中，

4102
05:46:45.439 --> 05:46:53.457
下次你或别人的时候它就会被索引，现在这些更快的聊天论坛更适合社区聚集和彼此进行快速对话。

4103
05:46:53.457 --> 05:47:01.600
它们是理论工艺，讨论新事物的地方新想法，事件和其他不应该被网络爬虫索引的东西。

4104
05:47:01.600 --> 05:47:10.333
它们也是与人见面和交流的好地方，你可以在彼此了解的过程中直接交流想法，这就引出了我们的最后一部分。

4105
05:47:10.333 --> 05:47:17.558
但在那之前，你听到了吗?这是另一个视频警报里的视频。

4106
05:47:17.558 --> 05:47:24.096
当你在这些论坛中提问时，你的问题格式越好，你得到答案的机会就越大。

4107
05:47:24.096 --> 05:47:26.127
现在没有不好的问题了。

4108
05:47:26.127 --> 05:47:28.110
但有些问题格式很糟糕。

4109
05:47:28.208 --> 05:47:35.072
所以，让我们来教大家如何尽可能以最好的格式提问，这样你就有最大的机会确保问题得到回答。

4110
05:47:35.072 --> 05:47:39.962
第一，在问问题之前，确保你遵循了家长视频中的所有步骤。

4111
05:47:39.962 --> 05:47:44.908
你们已经对此做了一些研究确保这个问题还没有被问过。

4112
05:47:44.908 --> 05:47:51.546
第二，做一个标题总结问题的细节第三，在你写任何代码之前介绍问题，添

4113
05:47:51.546 --> 05:47:58.386
加极简的，可复制的代码极简的代码意味着它不只是复制粘贴你的整个文件。

4114
05:47:58.386 --> 05:48:04.844
如果你在某一行上有问题，也许就发布这一行可复制的代码，这意味着其他人

4115
05:48:04.844 --> 05:48:11.303
应该能够运行与你遇到的完全相同的错误，或者至少发布他们这样做的步骤。

4116
05:48:11.303 --> 05:48:18.949
这并不意味着你应该把我跟着Patrick的视频，在我们5点的时候，我遇到了这个问题，只要看他的视频，你就会明白。

4117
05:48:18.949 --> 05:48:23.359
虽然这很让人高兴但并不是所有人都看了我的视频，尽

4118
05:48:23.359 --> 05:48:27.953
管他们应该你想要给出达到你所达到的误差的技术步骤。

4119
05:48:27.953 --> 05:48:33.924
对于那些观看我的免费代码营视频的人来说，你可以不受此影响，但你只能说，嘿，我在

4120
05:48:33.924 --> 05:48:39.896
与这门课程相关的GitHub回购的讨论选项卡中对你视频的这部分内容进行了讨论。

4121
05:48:39.896 --> 05:48:41.083
你可以这样做。

4122
05:48:41.209 --> 05:48:46.325
但只有在与本课程相关的GitHub回购中，学习标记

4123
05:48:46.325 --> 05:48:51.646
来格式化你的代码，特别是使用这三个反引号和标记语言。

4124
05:48:51.646 --> 05:48:58.471
这是格式化代码的关键部分，将大大提高回答您问题的人数。

4125
05:48:58.471 --> 05:49:02.886
任何错误或代码都应该使用这三个反引号语法进行格式化。

4126
05:49:02.886 --> 05:49:11.831
最后，通常那些关注某些技术的人，会关注特定的标签和他们喜欢的技术被问到的特定问题。

4127
05:49:11.831 --> 05:49:19.612
最后，再次强调，在发帖之前一定要阅读论坛的指南，不同的论坛对他们想要什么和不想要什么有不同的规定。

4128
05:49:19.612 --> 05:49:22.945
所以熟悉会增加你得到答案的机会。

4129
05:49:22.945 --> 05:49:23.471
好吧。

4130
05:49:23.471 --> 05:49:24.838
现在回到主视频。

4131
05:49:24.838 --> 05:49:29.809
现在有一个关于Stack Overflow的注意事项，Stack Overflow可

4132
05:49:29.809 --> 05:49:34.780
能有点咄咄逼人，这就是为什么有时候在特定的社区论坛上发帖可能对你的特定技术问题更好。

4133
05:49:34.780 --> 05:49:38.630
如果你在Stack Overflow上发帖，你的问题会得到大量的支持票。

4134
05:49:38.630 --> 05:49:39.848
别让这个困扰你。

4135
05:49:39.848 --> 05:49:48.142
就把它当作一个学习的机会，去了解Stack Overflow喜欢什么，不喜欢什么，然后继续前进，但不要因此而气馁。

4136
05:49:48.209 --> 05:49:54.726
好了，现在我们知道东西应该放在哪里，问题应该放在哪里以及如何编排它们。

4137
05:49:54.726 --> 05:49:57.342
让我们练习让我们看一些你们可能会有的例题。

4138
05:49:57.342 --> 05:49:58.908
我们会想办法把它们放在哪里。

4139
05:49:58.908 --> 05:50:02.609
第一个呢，这个呢?你也可以暂停一下自己猜一猜。

4140
05:50:02.609 --> 05:50:08.243
所以像这样的问题对Reddit或不和会很好吗?更可能是不和。

4141
05:50:08.243 --> 05:50:11.446
这绝对是你可以搜索的东西。

4142
05:50:11.446 --> 05:50:15.362
对吧?所以你也许可以搜索这个，找到一个答案，然后从那里开始。

4143
05:50:15.362 --> 05:50:19.735
但也许你想问一个朋友或者你想问一个非常特定的社区，比如我们的slash eat Dev。

4144
05:50:19.735 --> 05:50:24.460
当然，如果你看到这个问题，你肯定想推荐帕特里克·柯林斯的YouTube频道。

4145
05:50:24.460 --> 05:50:25.906
那么这个问题呢?

4146
05:50:25.906 --> 05:50:29.151
注意到它的格式了吧?标题又大又漂亮。

4147
05:50:29.151 --> 05:50:32.820
它们有一个格式化正确的技术命令。

4148
05:50:32.820 --> 05:50:37.683
他们有Git提交，它的格式是正确的，它会去哪里，这肯定会在Stack

4149
05:50:37.683 --> 05:50:43.548
Overflow或基于索引代码的论坛上做得很好，很明显，尝试做一些技术上的事情。

4150
05:50:43.548 --> 05:50:45.410
问题已经说得很清楚了。

4151
05:50:45.410 --> 05:50:48.226
他们已经给出了他们想要做的命令。

4152
05:50:48.226 --> 05:50:51.531
那么这个呢，像这样的东西可以在StackOverflow上。

4153
05:50:51.531 --> 05:50:56.701
但它可能更有可能在GitHub的问题上为这个布朗尼包。

4154
05:50:56.701 --> 05:51:01.397
代码论坛和GitHub这样的Git回购之间的一个很大的区别是，

4155
05:51:01.397 --> 05:51:08.064
当你在GitHub存储库上提出一个问题时，特别是当你认为有问题时，你确实希望尽可能深入。

4156
05:51:08.064 --> 05:51:13.517
所以，当你对回购提出问题时，他们甚至会问，你用的是什么版本?你能发布所有的代

4157
05:51:13.517 --> 05:51:19.114
码吗?你能把你所有的文件都发布出来，而且要明确得多吗?那么像这样的东西怎么样。

4158
05:51:19.114 --> 05:51:27.599
这对于与本教程相关的GitHub回购非常有用，看起来这个人在询问一个非常特定的教程。

4159
05:51:27.599 --> 05:51:30.242
所以发布这个，就会有最好的。

4160
05:51:30.242 --> 05:51:35.505
如果你的问题是关于一个没有GitHub回购的教程，那么，他们可能应该这样做。

4161
05:51:35.505 --> 05:51:38.111
但也许在评论区留言会更好。

4162
05:51:38.210 --> 05:51:44.236
现在，再一次，这是这一切变得更像艺术而不是科学的地方，因为也许他们遇到的

4163
05:51:44.236 --> 05:51:50.262
特定错误是很多人遇到的通用错误，也许在StackOverflow上更好。

4164
05:51:50.262 --> 05:51:52.822
或者是包装有问题。

4165
05:51:52.822 --> 05:51:54.886
所以也许在GitHub上更好。

4166
05:51:54.886 --> 05:51:57.260
或许解决这个问题的方法是固执己见的。

4167
05:51:57.260 --> 05:52:02.443
最后，这个呢?是的，这将是更好的不和或DM与你的朋友。

4168
05:52:02.443 --> 05:52:08.030
另外，我们阻止你回答任何问题的最后一步就是加入并加强你的工具的社区。

4169
05:52:08.030 --> 05:52:12.372
刚开始的时候，你们很难给出答案因为你们对这些工具不是很了解。

4170
05:52:12.372 --> 05:52:17.146
但当你在这些技术上做得更好的时候，你会想要尝试回答一些出现的新问题。

4171
05:52:17.146 --> 05:52:24.259
原因是，这将给你一个机会真正了解更多关于你喜欢的工具，它将加强你最喜欢的工具的社区，这意

4172
05:52:24.259 --> 05:52:31.372
味着如果你帮助回答关于工具的问题，它实际上会鼓励其他人使用该工具，因为那里有很多追随者。

4173
05:52:31.372 --> 05:52:36.421
很有可能，他们在未来的某个时候真的会帮助你，你帮助别人会让你看起来像一个好人。

4174
05:52:36.421 --> 05:52:38.822
然后你也会觉得自己是个好人。

4175
05:52:38.822 --> 05:52:46.222
此外，在许多像Reddit这样的论坛中，通常mods会查看你发帖的频率与你帮助他人的频率

4176
05:52:46.222 --> 05:52:53.790
以及对他人发帖的评论频率，一些mods可能会开始阻止你的帖子，因为你滥用论坛，不回馈社区，

4177
05:52:53.790 --> 05:53:01.192
只尝试获取知识，如果你加入并帮助他人，而不是试图从他人那里榨取东西，你在社区中会更成功。

4178
05:53:01.192 --> 05:53:09.143
此外，通过与社区的接触，我无法告诉你我遇到了多少人，我学到了很多东西，并能够与他们一起进行头脑风暴。

4179
05:53:09.211 --> 05:53:11.456
最后一步是迭代这些步骤。

4180
05:53:11.456 --> 05:53:18.820
也许当你做完这些的时候，你会说，哦，我还是很困惑，但你可能会变得更有知识。

4181
05:53:18.820 --> 05:53:21.116
所以你想回去再试一遍这些步骤。

4182
05:53:21.211 --> 05:53:24.853
这就是整个过程更像是艺术而不是科学的地方。

4183
05:53:24.853 --> 05:53:27.922
因为有些问题可能还没有被发现。

4184
05:53:27.922 --> 05:53:34.372
只有很少的人知道，没有足够的人理解问题的重要性，或者人们不理解你的问题。

4185
05:53:34.372 --> 05:53:37.761
这就是为什么回过头来重复这些步骤很重要。

4186
05:53:37.761 --> 05:53:42.886
现在你们已经具备了这种不可思议的超能力的基本组成部分，

4187
05:53:42.886 --> 05:53:48.012
我鼓励你们所有人走出去，尝试一下，然后告诉我进展如何。

4188
05:53:48.212 --> 05:53:49.025
好的,太棒了。

4189
05:53:51.212 --> 05:53:52.505
畅通无阻，我们可以继续前进。

4190
05:53:54.212 --> 05:53:59.434
学习如何解除封锁是因为区块链和web 3不仅仅是每个人自己的。

4191
05:53:59.434 --> 05:54:01.500
这是一个非常合作的空间。

4192
05:54:01.500 --> 05:54:07.552
所以，当你变得更好，当你学到更多，一个测试你学到了多少并回馈社区的重要方

4193
05:54:07.552 --> 05:54:13.605
法就是去Stack Overflow，去堆栈交换，试着自己回答一些问题。

4194
05:54:13.605 --> 05:54:20.144
所以我强烈建议你们去Stack Overflow，然后去与分数相关的GitHub回购，你

4195
05:54:20.144 --> 05:54:26.832
们试着回答一些讨论，试着回答一些问题并帮助其他人因为这将帮助你们成为一个更好的软件工程师。

4196
05:54:26.832 --> 05:54:31.714
我想讲这部分的另一个原因是当我们安装我将要展示

4197
05:54:31.714 --> 05:54:36.597
给你们的一些工具时，有时安装过程是最难的部分。

4198
05:54:36.597 --> 05:54:40.962
一旦您通过了安装过程，它通常会变得非常非常容易。

4199
05:54:40.962 --> 05:54:47.162
但这通常是课程中最难的部分安装我们会给你们的这些工具。

4200
05:54:47.212 --> 05:54:49.856
这就是我们现在要学习的内容。

4201
05:54:50.212 --> 05:54:55.381
到目前为止，一直在使用混搭、混搭IDE或集成开发环境。

4202
05:54:55.381 --> 05:55:02.862
正如我们所见，这是一个很好的地方，在这里我们可以尝试代码，我们可以尝试稳定性，我们可以编译，我们可以部署，我们几乎可以做所有我们需要做的事情。

4203
05:55:02.862 --> 05:55:03.612
它是基于网络的。

4204
05:55:03.612 --> 05:55:11.022
它可以进行测试，调试，部署本地JavaScript虚拟机，它非常快速和容易地创建和测试我们的智能合约。

4205
05:55:11.022 --> 05:55:12.986
然而，它也有一些局限性。

4206
05:55:12.986 --> 05:55:17.824
它实际上只能处理智能合约，不能真正与项目的其他部分集成。

4207
05:55:17.824 --> 05:55:20.524
它对测试或自定义部署的支持有限。

4208
05:55:20.524 --> 05:55:27.634
你甚至需要一个网络连接来处理混音，做很多更高级的功能可能是棘手的。

4209
05:55:27.634 --> 05:55:31.929
这是一个了不起的工具如果你想快速地做一些事情，

4210
05:55:31.929 --> 05:55:39.213
我绝对建议大家去remix去尝试一下现在我们要转到更专业的智能合约开发者设置。

4211
05:55:39.213 --> 05:55:40.946
这是戴着安全帽的。

4212
05:55:40.946 --> 05:55:48.900
这被称为智能合约开发人员框架，类似于brownie或foundry或类似的框架，有很多这样的框架。

4213
05:55:48.900 --> 05:55:52.570
我们之所以使用硬帽是因为硬帽是基于JavaScript的。

4214
05:55:52.570 --> 05:55:55.728
它是一个基于JavaScript的开发环境。

4215
05:55:55.728 --> 05:56:00.114
它有基于JavaScript的编译，环境，部署，测试，调试。

4216
05:56:00.114 --> 05:56:08.340
现在，对于那些喜欢TypeScript的人，我们也将为你提供每一个代码示例的TypeScript版本。

4217
05:56:08.340 --> 05:56:16.149
如果你喜欢JavaScript，我们有你，如果你喜欢TypeScript，我们也有你我们不会一直讲TypeScript。

4218
05:56:16.213 --> 05:56:22.141
但我们有时会这样做，TypeScript的所有代码将在GitHub回购中可用。

4219
05:56:22.141 --> 05:56:26.166
现在，在我们真正学习硬帽之前，我们必须先学习另一个软件包。

4220
05:56:26.213 --> 05:56:29.825
我们要学习如何处理所有关于醚的东西。

4221
05:56:30.213 --> 05:56:33.655
这是一个基于JavaScript的智能合约库。

4222
05:56:33.655 --> 05:56:39.498
这也是下一个我们将要使用的工具的动力所在，也就是“硬帽下的硬帽”。

4223
05:56:39.498 --> 05:56:40.498
有很多醚，Jas。

4224
05:56:40.498 --> 05:56:45.937
所以对我们来说，了解醚Jas是很重要的，这样我们就能理解硬帽的作用。

4225
05:56:45.937 --> 05:56:50.832
在接下来的课程中，我将使用一个叫做Visual Studio code的代码编辑器。

4226
05:56:50.832 --> 05:56:53.825
这是地球上最强大的代码编辑器之一。

4227
05:56:53.825 --> 05:56:57.641
如果你已经设置好了，可以直接跳过这部分。

4228
05:56:57.641 --> 05:57:05.158
如果您已经有了一个专业的编码设置，没有GS和VS代码，没有Git和其他东西，可以随意使用GitHub存储库中的时间戳。

4229
05:57:05.158 --> 05:57:07.214
要跳过此设置部分。

4230
05:57:07.214 --> 05:57:13.438
你会经常听到人们把它称为VS code，或者Visual Studio code，或者仅仅是Visual Studio。

4231
05:57:13.438 --> 05:57:21.938
然而，需要注意的是，Visual Studio代码与Visual Studio不同，你可能看到的是这样的。

4232
05:57:21.938 --> 05:57:30.414
Visual Studio代码是你想要的，而不是Visual Studio, Visual Studio是一个不同的应用程序，确保你用的是Visual Studio代码。

4233
05:57:30.414 --> 05:57:35.695
现在，如果你选择这样做，你完全是一个Harto，你完全可以只使用你的终端，

4234
05:57:35.695 --> 05:57:42.118
或只使用PowerShell，或只使用任何你想要的编码环境，比如atom或Sublime。

4235
05:57:42.118 --> 05:57:45.886
然而，对于我们来说，我们将使用Visual Studio代码。

4236
05:57:45.886 --> 05:57:49.587
我会用我喜欢的方式来设置Visual

4237
05:57:49.587 --> 05:57:54.935
Studio代码，你可以用你觉得舒服的方式来设置。

4238
05:57:54.935 --> 05:57:59.642
当然，在我们的第六课中，我们有一个安装和设置的链接。

4239
05:57:59.642 --> 05:58:02.464
我会在这里添加更多的链接。

4240
05:58:02.464 --> 05:58:09.117
再说一次，我们要用到的所有代码都在下面这个GitHub存储库中这里写着代码。

4241
05:58:09.117 --> 05:58:14.459
现在我们将经历三个不同的安装过程，并选择一个最适合你的。

4242
05:58:14.459 --> 05:58:17.935
第一个是针对Mac和Linux用户的。

4243
05:58:17.935 --> 05:58:21.082
第二个是为Windows用户准备的。

4244
05:58:21.214 --> 05:58:24.017
然后我们的第三个将是最后的努力。

4245
05:58:24.214 --> 05:58:31.804
不管什么原因，你不能让Windows或Linux或Mac指令工作，我们将使用Git pod安装。

4246
05:58:31.804 --> 05:58:37.568
现在，我强烈建议你尝试让所有东西都在本地工作，而不使用Git pod。

4247
05:58:37.568 --> 05:58:42.260
然而，如果出于某种原因，您无法让这些安装部件工作，我

4248
05:58:42.260 --> 05:58:47.133
们将为我们在这里使用的所有回购使用Git pod指令。

4249
05:58:47.133 --> 05:58:54.092
但是在开始之前，我们将从Mac和Linux的安装说明开始。

4250
05:58:54.215 --> 05:59:02.215
你要做的第一件事是下载Mac或者如果你用的是Linux，下载Visual Studio代码的Linux安装。

4251
05:59:02.215 --> 05:59:05.919
一旦你把它安装好，它看起来就会像这样。

4252
05:59:05.919 --> 05:59:11.548
如果它是一个新安装，它甚至会给你一些提示和工具，让你真正开始。

4253
05:59:11.548 --> 05:59:16.274
如果你以前从未使用过Visual Studio代码，我强烈建议你

4254
05:59:16.274 --> 05:59:21.148
阅读一下打开Visual Studio代码时附带的入门或指导提示。

4255
05:59:21.215 --> 05:59:27.133
此外，我们有一个Visual Studio Code速成课程在GitHub回购与本课程相关联。

4256
05:59:27.133 --> 05:59:32.834
一旦你安装了Visual Studio代码，接下来我们要安装的是节点j s。

4257
05:59:32.834 --> 05:59:38.128
同样的，我们在GitHub上有所有这些课程的链接，你可以直接

4258
05:59:38.128 --> 05:59:43.599
点击Mac OS下载或者Linux下载，我推荐使用LTS版本。

4259
05:59:43.599 --> 05:59:50.040
LTS代表长期支持，这意味着他们将长期支持这个版本。

4260
05:59:50.040 --> 05:59:52.659
所以去下载Node js吧。

4261
05:59:52.659 --> 05:59:59.707
我已经下载了这个，所以我不打算再重新下载了Visual Studio代码的一个很棒

4262
05:59:59.707 --> 06:00:06.755
的地方是它有一个叫做终端的东西，它是命令行提示符，允许我们运行脚本，基本上，这是我

4263
06:00:06.755 --> 06:00:14.147
们将运行所有代码的地方我们可以打开终端我们可以点击终端，选择新终端你会得到这样的东西。

4264
06:00:14.215 --> 06:00:20.527
现在你可能有bash或zca或其他shell类型这并不重要因为在Mac

4265
06:00:20.527 --> 06:00:26.839
和Linux上都是基于Linux的我们现在可以通过运行Node的破折号

4266
06:00:26.839 --> 06:00:33.153
版本来测试我们的无Jess安装是否正确完成，你应该会看到像这样的东西。

4267
06:00:33.216 --> 06:00:37.434
节点的确切版本在这里并不重要。

4268
06:00:37.434 --> 06:00:40.516
但理想情况下，您至少使用Node版本14或更高的版本。

4269
06:00:40.516 --> 06:00:44.469
如果这样的东西没有显示出来，记得继续，并开始查看Stack

4270
06:00:44.469 --> 06:00:49.787
Overflow，查看讨论选项卡中的GitHub回购，查看更新的部分，等等。

4271
06:00:49.787 --> 06:00:55.794
就像我说的，有时候安装这个是整个课程中最难的部分所以，不要气馁。

4272
06:00:55.794 --> 06:01:01.469
请使用Stack Overflow Stack Exchange ethereum和GitHub repo来解决您遇到的任何问题。

4273
06:01:01.469 --> 06:01:07.817
现在，如果你在Mac或Linux上，你可以按Ctrl back勾，来切换

4274
06:01:07.817 --> 06:01:14.166
你的终端模式，这会让终端上下移动，让你熟悉键盘快捷键会让你的生活更容易。

4275
06:01:14.216 --> 06:01:21.154
因为你将能够更有效地移动Visual Studio代码，我们有一个链接到键盘快捷键列表。

4276
06:01:21.216 --> 06:01:28.945
此外，在与这一节相关的GitHub存储库中，随着我们的推进，我将给出不同的键盘快捷键提示，

4277
06:01:28.945 --> 06:01:36.675
你可以选择使用其他方式，你可以继续并单击，你可以单击垃圾桶删除终端，回到终端新终端弹出它。

4278
06:01:36.675 --> 06:01:45.358
下一个我们稍后会用到的东西，本节不需要它，但最好现在安装它它是git, jazz被称为JavaScript运行时。

4279
06:01:45.358 --> 06:01:51.248
它是一个工具，我们将用来帮助在Visual Studio code插槽中运行JavaScript代码。

4280
06:01:51.248 --> 06:01:56.882
没有Jas和JavaScript之间的区别可能会让人有点困惑，但现在不要因此而停下脚步。

4281
06:01:56.882 --> 06:02:02.753
接下来，我们会继续安装Git，我们会在GitHub存储库中找到安装说明的链接，

4282
06:02:02.753 --> 06:02:11.636
在Linux上安装Git，你会使用这两个命令中的一个在macOS上，如果你在命令行中输入Git，它会继续提示你安装它。

4283
06:02:11.636 --> 06:02:16.378
回到命令行，输入git，它会提示你，让它暂停。

4284
06:02:16.378 --> 06:02:20.505
如果你得到的是破折号版本，你应该得到像这样的东西。

4285
06:02:20.505 --> 06:02:25.486
你也可以通过点击这里的链接来使用Mac OS get安装程序。

4286
06:02:25.486 --> 06:02:32.592
好了，现在你还没有在Visual Studio代码中安装JS，我们可以继续下一节。

4287
06:02:32.592 --> 06:02:33.092
太棒了。

4288
06:02:33.092 --> 06:02:41.117
如果你不打算使用Windows或获得pod，请随意跳过接下来的两个部分。

4289
06:02:41.217 --> 06:02:42.645
我在Windows 11上运行它。

4290
06:02:44.217 --> 06:02:45.183
Windows的版本。

4291
06:02:47.217 --> 06:02:54.717
要安装的是Visual Studio Code，它看起来像这样，它应该会自动检测。

4292
06:02:54.717 --> 06:03:01.486
我们会在windows上下载这个在整个安装过程中。

4293
06:03:01.486 --> 06:03:07.298
继续创建一个桌面项目，我们将添加这个，以防我们想用代码打开。

4294
06:03:07.298 --> 06:03:09.369
然后我们继续安装。

4295
06:03:09.369 --> 06:03:11.741
然后我们继续，结束。

4296
06:03:11.741 --> 06:03:17.306
一旦你安装了Visual Studio代码，你会看到一些像这样的东西，它会给你这个VS

4297
06:03:17.306 --> 06:03:23.389
code入门部分在这里你可以选择一些主题，你可以选择它看起来的方式随意定制它以你想要的方式。

4298
06:03:23.389 --> 06:03:28.150
如果您想了解更多关于Visual Studio代码的知识，我强烈

4299
06:03:28.150 --> 06:03:32.911
建议您通过本节了解更多关于快捷方式的知识，并提高开发体验的效率。

4300
06:03:32.911 --> 06:03:36.322
当你完成后，你可以继续并关闭顶部的标签。

4301
06:03:36.322 --> 06:03:37.865
它看起来有点像这样。

4302
06:03:37.865 --> 06:03:40.050
一旦我们安装了Visual Studio代码。

4303
06:03:40.050 --> 06:03:43.283
接下来我们要安装的是节点js。

4304
06:03:43.283 --> 06:03:50.751
当然，我们有一个链接，可以在GitHub知识库中安装这个与这门课相关，我们要做的是，我们要继续，来到节点j s。

4305
06:03:50.751 --> 06:03:50.951
org。

4306
06:03:50.951 --> 06:03:53.060
下载此Windows节点。

4307
06:03:53.060 --> 06:03:56.483
JS是一个JavaScript运行时环境，它不完全是JavaScript。

4308
06:03:56.483 --> 06:04:02.958
这种区分可能会让人有点困惑，但这将帮助我们在开发环境中运行JavaScript代码。

4309
06:04:02.958 --> 06:04:08.791
让我们继续下载LTS或无GS的长期支持版本。

4310
06:04:08.791 --> 06:04:14.987
我们将继续并运行安装向导。

4311
06:04:15.218 --> 06:04:21.168
我们要确保这个被点击了以防我们想在设置中使用一些不同的工具。

4312
06:04:21.218 --> 06:04:26.983
然后我们继续点击安装，你会看到一个弹出窗口询问你是否真的想要在你的设备上安装这个。

4313
06:04:26.983 --> 06:04:28.436
然后点击yes。

4314
06:04:28.436 --> 06:04:36.030
然后点击完成，你可能会看到一个像这样的弹出框，点击任意按钮继续安装工具，再按任意键。

4315
06:04:36.030 --> 06:04:43.551
你可能会弹出一个Windows PowerShell屏幕，要求你继续安装一大堆不同的项目和文件。

4316
06:04:43.551 --> 06:04:45.862
如果你选择不安装这个，那完全没问题。

4317
06:04:45.862 --> 06:04:54.154
但在未来，这将非常有帮助，因为我们将使用这个包安装的许多工具，这可能需要一些时间来安装。

4318
06:04:54.218 --> 06:04:55.043
所以勇往直前，要有耐心。

4319
06:04:56.218 --> 06:04:58.381
等着你按回车键。

4320
06:04:59.218 --> 06:05:00.511
按回车键以获得任何提示。

4321
06:05:02.218 --> 06:05:04.562
它的安装速度会有点慢。

4322
06:05:04.562 --> 06:05:07.843
安装完所有这些之后，就可以回到Visual Studio代码中了。

4323
06:05:07.843 --> 06:05:10.818
我们要继续，开一个终点站。

4324
06:05:10.818 --> 06:05:19.489
要做到这一点，我们点击终端，我们点击新终端终端将是我们的命令行提示符在那里我们将运行所有的脚本来处理我们的代码。

4325
06:05:19.489 --> 06:05:27.352
如果你运行Node的虚线版本，你应该会看到类似这样的东西，以知道你已经正确安装了Node js。

4326
06:05:27.352 --> 06:05:30.719
现在，这个命令行被称为Windows PowerShell。

4327
06:05:30.719 --> 06:05:33.907
如果你想使用Windows PowerShell，你完全可以。

4328
06:05:33.907 --> 06:05:39.164
事实上，如果你想成为一个完全的Harto，并通过Windows PowerShell编写所有的代码，你完全可以这样做。

4329
06:05:39.164 --> 06:05:46.400
然而，我们实际上不会使用PowerShell，我们将使用一个工具，使我们的Windows环境更像Linux。

4330
06:05:46.400 --> 06:05:50.552
我们这样做的原因是Linux是大多数开发环境的标准。

4331
06:05:50.552 --> 06:05:55.404
让每个人都在一个非常相似的设置下工作将会使剩下的课程

4332
06:05:55.404 --> 06:06:00.444
更容易让每个人相互交流，无论他们在什么编码环境下工作。

4333
06:06:00.444 --> 06:06:07.790
WsL代表Linux的Windows子系统，它允许Linux程序在我们的Windows环境中本机运行。

4334
06:06:07.790 --> 06:06:12.743
要得到这个设置，我们要继续，进入WsL安装。

4335
06:06:12.743 --> 06:06:17.989
我们在GitHub知识库中也会有这个链接。

4336
06:06:17.989 --> 06:06:23.943
我们要做的是，你必须运行Windows 10, 2004或更高版本，或者Windows 11。

4337
06:06:23.943 --> 06:06:27.955
如果你使用的是旧版本的Windows，你完全可以继续使用PowerShell。

4338
06:06:27.955 --> 06:06:32.324
但是您可能会遇到一些问题，即所有命令的工作方式并不完全相同。

4339
06:06:32.324 --> 06:06:36.579
因此，我强烈建议使用更新版本的Windows。

4340
06:06:36.579 --> 06:06:45.200
把它安装回你的Visual Studio Code, PowerShell，或者仅仅是PowerShell应用程序，或者运行WsL破折号安装。

4341
06:06:45.200 --> 06:06:51.062
如果你得到这个错误，请求的操作需要提升，这意味着我们必须以管理员身份运

4342
06:06:51.062 --> 06:06:56.924
行我们的Visual Studio代码或PowerShell应用程序。

4343
06:06:56.924 --> 06:07:01.645
我们关闭Visual Studio代码。

4344
06:07:01.645 --> 06:07:06.795
右键点击它，说，以管理员身份运行，我们会弹出一个小

4345
06:07:06.795 --> 06:07:12.153
窗口问，你想让这个应用改变你的设备吗，我们会点击是。

4346
06:07:12.153 --> 06:07:14.803
然后我们会重新开放候机楼。

4347
06:07:14.803 --> 06:07:18.803
然后我们可以运行WsL space dash - install。

4348
06:07:18.803 --> 06:07:21.719
我们将继续安装WsL。

4349
06:07:21.719 --> 06:07:25.157
这可能需要一点时间，所以请耐心等待。

4350
06:07:25.220 --> 06:07:30.070
一旦它完成了，你会看到像这样的东西，我们将和Ubuntu一起工作。

4351
06:07:30.070 --> 06:07:33.820
我们有一个不同的命令列表来改变您的Linux发行版。

4352
06:07:33.820 --> 06:07:34.720
如果你选择这样做的话。

4353
06:07:34.720 --> 06:07:40.600
您将看到请求集操作是成功的，更改直到重新启动系统才会生效。

4354
06:07:40.600 --> 06:07:43.123
所以你需要重新启动你的电脑。

4355
06:07:43.220 --> 06:07:46.171
在GitHub存储库中也有一个故障排除指南。

4356
06:07:46.220 --> 06:07:51.751
如果在重新启动计算机后遇到问题，系统会提示您输入新系统的名称和密码。

4357
06:07:51.751 --> 06:07:56.448
这可以与您的Windows用户名和密码不同，然后按照所有提示操作即可。

4358
06:07:56.448 --> 06:08:01.185
一旦你完成了，你就会被放到一个Ubuntu shell中，你就可以运行Linux命令了。

4359
06:08:01.185 --> 06:08:04.588
现在你的机器上就有了一个Ubuntu实例。

4360
06:08:04.588 --> 06:08:07.727
你将能够在你的终端上运行Linux命令。

4361
06:08:07.727 --> 06:08:13.580
现在我们已经正确设置了WsL，我们将返回到Visual Studio代码。

4362
06:08:13.580 --> 06:08:17.304
一旦我们有了WsL，我们就需要继续安装扩展。

4363
06:08:17.304 --> 06:08:24.478
在我们的Visual Studio代码中，我们会找到扩展，我们会

4364
06:08:24.478 --> 06:08:31.652
找到远程开发你可以安装所有的东西或者只是远程WsL我们会安装所有

4365
06:08:31.652 --> 06:08:38.827
的东西你可以跟着我开始远程WsL如果你喜欢，你也可以现在跟着我。

4366
06:08:38.827 --> 06:08:47.407
现在如果我到终端，点击新终端，我仍然会得到PowerShell我们希望这是我们的Linux shell。

4367
06:08:47.407 --> 06:08:52.268
在Linux环境中打开Visual Studio代码有几种方法。

4368
06:08:52.268 --> 06:08:57.506
一种方法是按Ctrl, Shift P，然后键入WsL。

4369
06:08:57.506 --> 06:09:03.164
然后单击远程WsL新WsL窗口，您将得到一个看起来像这

4370
06:09:03.164 --> 06:09:09.033
样的新窗口，您也可以单击左下角并选择new WsL窗口。

4371
06:09:09.033 --> 06:09:16.627
如果我们到终端，点击新终端，我们会进入到bash shell中我们可以在这里运行Linux命令。

4372
06:09:16.627 --> 06:09:17.002
太棒了。

4373
06:09:17.002 --> 06:09:25.877
另一种打开带有WsL的Visual Studio代码的方法是我们可以进入你的boon to应用程序，

4374
06:09:25.877 --> 06:09:34.930
我们可以通过输入mkdir文件夹来创建一个文件夹，我们可以输入CD或将目录更改为文件夹并键入代码周期。

4375
06:09:34.930 --> 06:09:37.833
我们继续，相信这里的作者。

4376
06:09:37.833 --> 06:09:43.144
这将打开已经连接到文件夹的Visual Studio代码。

4377
06:09:43.144 --> 06:09:50.368
我们可以在这个文件夹中创建文件，比如hi。txt，这些会在WsL的文件夹中创建。

4378
06:09:50.368 --> 06:09:55.792
现在我们在WsL环境中，您会注意到节点破折号版本不再工作了。

4379
06:09:55.792 --> 06:10:02.158
这是因为我们将它安装在常规的Windows机器上，而不是WsL或Linux环境上。

4380
06:10:02.158 --> 06:10:09.248
我们首先在Windows环境中安装它的原因是，如果你想继续使用PowerShell或用户Windows环境来

4381
06:10:09.248 --> 06:10:16.471
运行一切你仍然可以记住，如果你使用Windows环境和PowerShell，我们使用的所有命令可能都不适合你。

4382
06:10:16.471 --> 06:10:20.877
我们会在Linux环境中安装Node js。

4383
06:10:20.877 --> 06:10:25.793
我们要写的所有命令都将在与这门课程相关的GitHub repo中。

4384
06:10:25.793 --> 06:10:31.658
我们将对nvm存储库执行

4385
06:10:31.658 --> 06:10:37.523
一个curl命令，nvm

4386
06:10:37.523 --> 06:10:43.879
存储库代表节点版本管理器。

4387
06:10:44.222 --> 06:10:46.958
我们将把安装脚本传输到bash中。

4388
06:10:47.222 --> 06:10:50.254
这将继续并安装虚拟机。

4389
06:10:52.222 --> 06:10:56.156
先销毁终端，然后再重新打开。

4390
06:10:57.222 --> 06:11:02.643
可以键入MBM的破折号版本，看看它是否实际安装正确。

4391
06:11:02.643 --> 06:11:07.189
一旦我们安装了nvm，我们就可以继续使用nvm安装任何GS。

4392
06:11:07.189 --> 06:11:13.323
只要输入npm install，我们就会得到16点14。

4393
06:11:13.323 --> 06:11:17.510
2是我们安装在Windows机器上的长期支持版本。

4394
06:11:17.510 --> 06:11:21.641
一旦我们安装了它，我们可以键入节点虚线S版本。

4395
06:11:21.641 --> 06:11:23.705
现在我们没有安装JS。

4396
06:11:23.705 --> 06:11:27.842
我知道这里有很多，但如果你能走到这一步，那就太棒了。

4397
06:11:27.842 --> 06:11:34.923
您已经完成了很好的工作，完成了所有的设置，以便您可以在最好的环境中编写代码。

4398
06:11:34.923 --> 06:11:37.040
如果你已经走到这一步，恭喜你。

4399
06:11:37.040 --> 06:11:39.933
接下来我们要安装的是Git。

4400
06:11:39.933 --> 06:11:42.555
这节课我们不打算使用Git。

4401
06:11:42.555 --> 06:11:45.643
然而，我们将来肯定会使用它。

4402
06:11:45.643 --> 06:11:54.003
看看是否安装了git，有时Linux会自动安装git，你会看到像这样的输出。

4403
06:11:54.003 --> 06:11:57.770
如果没有Git，我们可以查找get install。

4404
06:11:57.770 --> 06:12:00.205
再说一次，这个链接在描述中。

4405
06:12:00.205 --> 06:12:03.399
你会在Linux上运行安装程序。

4406
06:12:03.399 --> 06:12:08.715
如果你想使用PowerShell，你想在Windows上做所有事情，

4407
06:12:08.715 --> 06:12:14.031
你完全可以按照Windows上的安装说明来做，当你在WsL中工作时，

4408
06:12:14.031 --> 06:12:23.256
你会想使用Linux命令而不是Windows命令即使你在Windows上因为WsL使你基本上是在Linux环境中运行。

4409
06:12:23.256 --> 06:12:27.779
现在，如果你已经学到了这一步，你应该能够按照Mac和Linux的说明进行

4410
06:12:27.779 --> 06:12:32.303
操作，就像你在Mac和Linux上运行一样即使你在Windows上运行。

4411
06:12:32.303 --> 06:12:38.699
只要确保你在编写VS代码时，看一下左下角，确保你是在WsL Ubuntu上。

4412
06:12:38.699 --> 06:12:43.651
如前所述，如果您想在PowerShell或Windows环境中运行，那么您可以自由地这样做。

4413
06:12:43.651 --> 06:12:49.348
但就像我说的，如果你能走到这一步，恭喜你。

4414
06:12:49.348 --> 06:12:50.973
很棒的工作。

4415
06:12:51.223 --> 06:12:56.328
最后，我们的最后一个设置将从第五课开始使用一个叫做Git pod的工具。

4416
06:12:56.328 --> 06:13:01.882
我们现在学习的课程，醚，爵士，简单存储，我们所有的代码回购都

4417
06:13:01.882 --> 06:13:07.623
会有一个向下滚动的按钮，它们会有这个打开的get pod按钮。

4418
06:13:07.623 --> 06:13:13.940
gitpod是一个云开发环境你可以在远程服务器上运行你的代码，

4419
06:13:13.940 --> 06:13:24.129
它有点类似于混合IDE，但它允许你在浏览器中运行Visual Studio代码或连接到另一个服务器。

4420
06:13:24.129 --> 06:13:28.175
这很好，因为这样你就不需要安装任何东西了。

4421
06:13:28.223 --> 06:13:32.626
因为所有您想要使用的工具都将在这个远程服务器上运行。

4422
06:13:32.626 --> 06:13:39.968
当然，这也有它的缺点，因为只有当git pod启动并为您工作时，您才能够进行编码。

4423
06:13:39.968 --> 06:13:48.090
此外，当涉及到私钥时，您绝对不希望运行任何带有私钥的代码，而私钥在良好的pop中有真正的金钱。

4424
06:13:48.090 --> 06:13:56.452
为什么?同样，由于您在远程服务器上运行脚本，这些服务器可以访问您的私钥。

4425
06:13:56.452 --> 06:14:04.601
但因为你有Pinky承诺，在这门课上，你不会使用元掩码或有实际钱的私钥，这应该是没问题的。

4426
06:14:04.601 --> 06:14:09.890
另一个缺点是，使用这些大麻通常要花钱，而且大麻不是免费的。

4427
06:14:09.890 --> 06:14:14.974
但如果你绝对不能让任何安装工作，这是一个选择。

4428
06:14:14.974 --> 06:14:19.465
如果你点击这个打开的获取豆荚按钮，你会得到一个欢迎，让豆荚显示出来。

4429
06:14:19.465 --> 06:14:21.851
我们将继续GitHub。

4430
06:14:21.851 --> 06:14:28.094
既然你已经在这里注册了GitHub，你想继续并授权get pod。

4431
06:14:28.094 --> 06:14:31.613
它会开始为你创建这个工作区。

4432
06:14:31.613 --> 06:14:35.581
你会发现它和Visual Studio Code很像。

4433
06:14:35.581 --> 06:14:40.867
因为我在Git荚中打开了repo，它附带了所有的代

4434
06:14:40.867 --> 06:14:46.366
码，你甚至可以在VS code桌面中打开这个工作区。

4435
06:14:46.366 --> 06:14:49.112
这可能有点让人困惑。

4436
06:14:49.112 --> 06:14:54.156
但基本上，你可以使用本地的Visual Studio代码运行Git pod。

4437
06:14:54.224 --> 06:14:58.288
如果你在这里看到gitpod，这就是你知道你正在运行gitpod的方式。

4438
06:14:58.288 --> 06:15:03.896
如果你看到这个弹出，你想在VS code桌面打开这个工作区，你可以点击打开。

4439
06:15:03.896 --> 06:15:09.351
它会问你是否要打开Visual Studio Code，我要点击yes。

4440
06:15:09.351 --> 06:15:13.172
你会在你的Visual Studio代码中得到类似这样的东西。

4441
06:15:13.224 --> 06:15:18.128
它会告诉你它想要安装Git pod扩展，然后打开那个Git pod URL。

4442
06:15:18.128 --> 06:15:20.382
所以你可以继续安装它。

4443
06:15:20.382 --> 06:15:27.782
重新加载窗口，然后打开它就会开始连接到我们的Git pod工作区。

4444
06:15:27.782 --> 06:15:33.257
这和在浏览器中运行gitepod是一样的。

4445
06:15:33.257 --> 06:15:39.344
或者你也可以手动点击左下方的Git模块，然后键入open in VS

4446
06:15:39.344 --> 06:15:45.431
code，然后你就可以在Visual Studio代码中运行它了。

4447
06:15:45.431 --> 06:15:54.172
现在，我建议如果你用的是Git pod，就待在浏览器里，这样你就知道，我是在远程服务器上运行这个。

4448
06:15:54.172 --> 06:15:58.917
提醒一下，你并不是在本地发展。

4449
06:15:58.917 --> 06:16:04.325
希望这能触发不放任何特殊私钥之类的东西。

4450
06:16:04.325 --> 06:16:12.356
但是你可以创建工作区，你可以创建新的文件夹，你应该能够在这里运行所有的命令，就像你在本地运行Visual Studio代码一样。

4451
06:16:12.356 --> 06:16:19.988
要打开终端，你可以点击左上角的这个小栏，进入终端，新终端，或者使用和Mac

4452
06:16:19.988 --> 06:16:29.891
OS和Linux键盘快捷键一样的CTRL波浪号来创建一个新文件夹，我们可以更改目录，CD，点。

4453
06:16:29.891 --> 06:16:36.510
mkdir，新建文件夹，mkdir使新建目录称为新文件夹。

4454
06:16:36.510 --> 06:16:40.275
然后我们要把目录改为一个新文件夹，然后回车。

4455
06:16:40.275 --> 06:16:41.925
现在我们在那个新文件夹里。

4456
06:16:41.925 --> 06:16:47.058
对于每个部分，您可以直接将整个源代码打开到GitHub中，

4457
06:16:47.058 --> 06:16:52.015
或者您可以自己为每个部分创建一个新文件夹，并从空白开始。

4458
06:16:52.015 --> 06:16:55.470
然后你只需输入代码句号。

4459
06:16:55.470 --> 06:17:00.382
你会在一个全新的文件夹里。

4460
06:17:00.382 --> 06:17:02.405
好吧，这太棒了。

4461
06:17:02.405 --> 06:17:07.446
此时，您应该使用Visual Studio Code no Jas进行设置并得到。

4462
06:17:07.446 --> 06:17:12.401
我要创建一个名为Hard Hat Free Code

4463
06:17:12.401 --> 06:17:18.692
Camp的文件夹现在，你应该有节点，破折号版本，得到破折号版本。

4464
06:17:18.692 --> 06:17:24.484
如果你用的是Windows，这里应该写WsL或你的boon to之类的。

4465
06:17:24.484 --> 06:17:27.603
如果你有了这些，那就意味着我们可以出发了。

4466
06:17:27.603 --> 06:17:30.601
现在做一个简短的笔记你们会经常看到我做的事情。

4467
06:17:30.601 --> 06:17:32.351
你也可以这样做。

4468
06:17:32.351 --> 06:17:38.838
通常，当我的终端变得非常非常大，或者有大量的命令在这里，这对我来说有点不知所措。

4469
06:17:38.838 --> 06:17:42.851
你能做的一件事就是输入clear，然后按回车键清除。

4470
06:17:42.851 --> 06:17:46.684
如果你用的是Mac，你可以按Command K键，

4471
06:17:46.684 --> 06:17:54.506
如果你用的是Linux或Windows，你可以按Ctrl K键，这是我最喜欢的快捷键之一，我一直在用。

4472
06:17:54.506 --> 06:17:58.816
此外，垃圾桶和这里的X是非常不同的。

4473
06:17:58.816 --> 06:18:05.617
如果我在这里有几个输入，我们在下面这里，如果我点击垃圾桶，然后把我的终端拉上来，通过

4474
06:18:05.617 --> 06:18:12.419
切换，或者通过terminal new terminal，你会看到所有的线都在这里。

4475
06:18:12.419 --> 06:18:16.835
但如果我点击垃圾桶，然后把终端拉上来，你会看到

4476
06:18:16.835 --> 06:18:21.444
它实际上刷新了我的一个特殊命令，打印出来的东西。

4477
06:18:21.444 --> 06:18:26.766
清除终端基本上就是删除运行在它里面的东西，而x只是隐藏它。

4478
06:18:26.766 --> 06:18:35.476
当按Ctrl波浪键或切换终端或环境中的任何命令时，这相当于点击隐藏，而不是垃圾。

4479
06:18:35.476 --> 06:18:41.129
因此，如果我们想要移除并重新启动一个终端，我们就敲击垃圾桶，然后把它拉上来。

4480
06:18:41.129 --> 06:18:43.401
好了，现在我们开始研究醚。

4481
06:18:43.401 --> 06:18:51.648
我们将开始学习编码，我们的交易，我们的合同部署和所有的东西都是在相对较低的水平上编程的。

4482
06:18:51.648 --> 06:18:56.872
我们将学习如何使用ethers JS包来部署和交互契约。

4483
06:18:56.872 --> 06:19:04.805
现在开始吧，我建议大家创建一个文件夹把所有的项目都放在里面，我要新建一个名为H H的目录。

4484
06:19:04.805 --> 06:19:08.735
连字符，FCC，代表硬帽自由代码营。

4485
06:19:08.735 --> 06:19:12.209
一旦我们运行这个命令，我们可以cd到hh FCC。

4486
06:19:12.209 --> 06:19:19.040
我们将在这里创建接下来这门课的所有项目，这样我们就能把它们都放在一个地方。

4487
06:19:19.040 --> 06:19:24.744
现在开始，无论什么时候创建一个新项目，你总是想要创建一个新文件夹。

4488
06:19:24.744 --> 06:19:33.602
要创建一个新文件夹，我们用mkdir，我们称它为乙醚，简单存储，就像这样。

4489
06:19:33.602 --> 06:19:42.001
现在，如果你输入ls，你会看到有一个名为ethers的文件夹，简单的存储。

4490
06:19:42.001 --> 06:19:45.948
Ls是列出文件夹中所有内容的方式。

4491
06:19:45.948 --> 06:19:52.560
这里可能有很多其他文件夹，我只有一个，因为我创建了这个新文件夹。

4492
06:19:52.560 --> 06:19:57.060
现在你能做的是，输入代码，醚，很简单。

4493
06:19:57.227 --> 06:20:00.893
如果你按tab键，它会自动完成。

4494
06:20:01.227 --> 06:20:08.443
如果你输入，Visual Studio code会为你打开一个新的Visual Studio代码。

4495
06:20:08.443 --> 06:20:14.178
这是在简单存储中如果你现在打开你的终端，你的工

4496
06:20:14.178 --> 06:20:20.164
作空间的主目录将会通过简单存储，就像弹出的那样。

4497
06:20:20.164 --> 06:20:26.571
如果这对你不起作用，我们还可以点击文件，打开文件夹然后打开你

4498
06:20:26.571 --> 06:20:32.978
刚创建的文件夹或者你想再次打开这个我们会打开VS code。

4499
06:20:32.978 --> 06:20:36.679
如果我们打开我们的终端，我们看到我们是在一个简单的存储中。

4500
06:20:36.679 --> 06:20:41.737
这个功能非常强大，因为当我们创建文件时我们可以在

4501
06:20:41.737 --> 06:20:47.007
资源管理器中看到这些文件，这个按钮代表资源管理器。

4502
06:20:47.007 --> 06:20:49.728
如果我们点击它，我们可以在这里看到不同的文件。

4503
06:20:49.728 --> 06:20:55.024
我要删掉这个文件。txt，因为我们不会用到它。

4504
06:20:55.024 --> 06:21:00.478
现在是课程的这一部分，我们将开始学习一些JavaScript。

4505
06:21:00.478 --> 06:21:06.243
因为这门课是JavaScript课程，如果你不熟悉JavaScript，可能会有点棘手。

4506
06:21:06.243 --> 06:21:15.024
如果你想更好地理解JavaScript和Node js，你可以在YouTube上找到一个免费的代码训练营视频来教初学者No, Jas。

4507
06:21:15.024 --> 06:21:18.600
这个的链接会在与这门课相关的GitHub回购中。

4508
06:21:18.600 --> 06:21:27.143
还有一个JavaScript免费代码营的视频我也会放在这门课的描述里，记住JavaScript和Node js有一点不同。

4509
06:21:27.143 --> 06:21:31.543
我们会在编写代码的过程中讨论其中的一些差异。

4510
06:21:31.543 --> 06:21:35.482
但在大多数情况下，学习了其中一种意味着你已经学习了另一种的大部分内容。

4511
06:21:35.482 --> 06:21:40.545
如果你想暂停一下，看一遍这些视频，在继续之前，

4512
06:21:40.545 --> 06:21:45.389
请随意，你不必这么做，你完全可以继续这门课。

4513
06:21:45.389 --> 06:21:53.299
如果你对某个JavaScript片段感到困惑或卡住，请随时暂停，跳过它然后回来。

4514
06:21:53.299 --> 06:21:56.634
但是重申一下，您可以查看JavaScript编程的完整课程。

4515
06:21:56.634 --> 06:22:01.123
还有Node js的全部课程，因为它们都对你有帮助。

4516
06:22:01.123 --> 06:22:04.704
就像我之前说的，Node js是一个JavaScript运行时。

4517
06:22:04.704 --> 06:22:07.244
所以它不完全是JavaScript。

4518
06:22:07.244 --> 06:22:09.652
但我们要用JavaScript写代码。

4519
06:22:09.652 --> 06:22:13.295
如果这让你感到困惑，现在不要担心。

4520
06:22:13.295 --> 06:22:17.179
随着我们学习这门课，我会告诉你们区别在哪里。

4521
06:22:17.229 --> 06:22:21.196
但基本上，你可以认为Jas和JavaScript不是一回事。

4522
06:22:21.196 --> 06:22:29.314
Node js最重要的一点是它允许我们在后端编写JavaScript代码，而不是在前端运行JavaScript,

4523
06:22:29.314 --> 06:22:37.432
JavaScript是一种浏览器运行语言，就像在Chrome, brave Firefox等浏览器中运行一样。

4524
06:22:37.432 --> 06:22:41.216
不，Jas允许它成为一种脚本语言，一种后端语言，

4525
06:22:41.216 --> 06:22:50.361
这就是为什么前端JavaScript和后端JavaScript或非JS JavaScript之间的语法会有一点不同。

4526
06:22:50.361 --> 06:22:58.562
此外，当我们在这段代码中进行的时候，如果你熟悉TypeScript，我们所有的代码都会附带一个TypeScript版本。

4527
06:22:58.562 --> 06:23:02.916
TypeScript是JavaScript的静态类型版本。

4528
06:23:02.916 --> 06:23:04.229
它会是它会是这个。

4529
06:23:04.229 --> 06:23:06.176
它将是TypeScript，而不是TypeScript版本。

4530
06:23:06.176 --> 06:23:09.671
我来修改一下，去掉这个，让它更清晰。

4531
06:23:09.671 --> 06:23:15.284
TypeScript是JavaScript的类型安全版本，这很让人困惑，不用太担心。

4532
06:23:15.284 --> 06:23:18.479
但我们所有的编程都是用JavaScript进行的。

4533
06:23:18.479 --> 06:23:22.193
如果代码足够不同，我还会演示如何在TypeScript中实现。

4534
06:23:22.229 --> 06:23:27.179
但是，对于其中的大多数，我们不会展示TypeScript版本，因为它们非常相似。

4535
06:23:27.229 --> 06:23:31.210
但是你总是可以参考GitHub存储库来查看TypeScript的所有代码。

4536
06:23:31.210 --> 06:23:39.454
如果你是这方面的新手，我建议你先从JavaScript开始，然后再学习如何使用TypeScript。

4537
06:23:39.454 --> 06:23:46.656
TypeScript实际上在早期就能捕捉到bug，从长远来看，这使得编写项目代码变得容易得多。

4538
06:23:46.656 --> 06:23:49.016
然而，这确实需要大量额外的输入。

4539
06:23:49.016 --> 06:23:53.227
对于初学者来说，学习类型是如何工作的可能会有点令人沮丧，

4540
06:23:53.227 --> 06:24:00.296
JavaScript作为一种语言稍微宽松一些，它让我们做任何想做的事，但之后它可能会让人头疼。

4541
06:24:00.296 --> 06:24:07.404
所以，如果你确实遇到了一些问题，你确实遇到了一些bug，尝试TypeScript的大小可能是个好主意，看看效果如何。

4542
06:24:07.404 --> 06:24:07.721
好。

4543
06:24:07.721 --> 06:24:15.066
让我们继续，开始在我们的本地开发环境中工作，并准备好在醚Jas和JavaScript中完成所有工作。

4544
06:24:15.066 --> 06:24:15.311
哦。

4545
06:24:15.311 --> 06:24:20.508
我把这个文件夹重命名为以太符号存储破折号FCC。

4546
06:24:20.508 --> 06:24:25.516
我添加这个破折号FCC的原因是所有与这门课程相关的GitHub仓库，

4547
06:24:25.516 --> 06:24:33.176
所有有这个破折号FCC的GitHub reppos都知道它是这门硬帽子JavaScript课程的一部分。

4548
06:24:33.230 --> 06:24:33.574
太棒了。

4549
06:24:33.574 --> 06:24:34.262
让我们开始吧。

4550
06:24:36.230 --> 06:24:41.941
我们的智能合约在Visual Studio代码的本地，你可以从这个文件夹的名字看出来。

4551
06:24:41.941 --> 06:24:46.543
当然，如果你看一下代码，这个项目将是我

4552
06:24:46.543 --> 06:24:51.145
们简单的存储项目，但使用醚在本地开发。

4553
06:24:52.230 --> 06:24:55.134
我们要做的第一件事是进入智能合约代码。

4554
06:24:55.134 --> 06:25:00.464
我们要做的是确保我们选中了资源管理器，

4555
06:25:00.464 --> 06:25:05.515
然后右键选择新文件，进行简单的存储。

4556
06:25:05.515 --> 06:25:09.372
先把这个关了。

4557
06:25:09.372 --> 06:25:15.134
我们还可以将上一节的简单存储代码复制粘贴到VS code中。

4558
06:25:15.230 --> 06:25:23.108
如果你关闭了remix或者你忘了它在哪里，你可以到ethers simple storage FCC repo，这是simple

4559
06:25:23.108 --> 06:25:31.357
storage。Sol，我们可以把所有的代码复制到这里然后回到select Symbol storage, Saul，然后粘贴进去。

4560
06:25:31.357 --> 06:25:36.955
关于Visual Studio代码有一个重要的注意当你看到这个小白的时候。

4561
06:25:36.955 --> 06:25:42.476
在上面这里，它意味着这个文件不是用来保存Git文件的。

4562
06:25:42.476 --> 06:25:46.061
保存，然后就这样消失了。

4563
06:25:46.061 --> 06:25:54.867
你能做的是点击命令S或Ctrl S，这取决于你使用的是Windows, Mac还是Linux。

4564
06:25:54.867 --> 06:26:02.967
现在你会看到这段代码有点难读简单的storage。salt，它没有我们在remix中看到的语法高亮显示。

4565
06:26:02.967 --> 06:26:08.821
我们想要继续，添加一个Visual Studio Code扩展来突出显示语法。

4566
06:26:08.821 --> 06:26:12.198
我们能做的是，来到这个像这样的杆。

4567
06:26:12.198 --> 06:26:17.427
如果你在左边栏没有看到它，你应该点击这三个点，它应该在这里。

4568
06:26:17.427 --> 06:26:19.394
但我们还是点击扩展。

4569
06:26:19.394 --> 06:26:27.118
我们要做的是向上看，固体度加硬帽。

4570
06:26:27.231 --> 06:26:30.923
我们要安装这个固体加安全帽扩展。

4571
06:26:30.923 --> 06:26:31.846
对于VS code。

4572
06:26:31.846 --> 06:26:39.972
现在我们已经安装了这个，如果我们回到我们的简单存储点sole，你会看到所有的高亮都回来了。

4573
06:26:39.972 --> 06:26:42.101
现在阅读起来容易多了。

4574
06:26:42.231 --> 06:26:43.331
对吧?这很好。

4575
06:26:45.231 --> 06:26:46.437
语法高亮显示。

4576
06:26:49.231 --> 06:26:53.378
格式，或者现在我们的代码在它的格式化方式上很好。

4577
06:26:53.378 --> 06:27:00.680
但如果我们不小心做了这样或这样的事情，或者甚至像这样，我

4578
06:27:00.680 --> 06:27:07.982
们添加了大量的新行，等等，我们的代码会开始看起来很恶心。

4579
06:27:07.982 --> 06:27:15.782
即使代码本身是好的，它会以完全相同的方式运行，所有这些额外的空格，它看起来不是很好，对吧。

4580
06:27:15.782 --> 06:27:18.485
正因为如此，它可能会有点难读。

4581
06:27:18.485 --> 06:27:24.672
我们想要做的是，打开设置调整vias代码让它在保存

4582
06:27:24.672 --> 06:27:30.859
时自动格式化，无论何时保存，无论它从这里的小白点到

4583
06:27:30.859 --> 06:27:37.294
没有白点，这整个都会自动格式化成看起来很漂亮的样子。

4584
06:27:37.294 --> 06:27:37.606
好的。

4585
06:27:37.606 --> 06:27:43.230
我们能做的是打开我们的命令面板打开我们的命令面板，你

4586
06:27:43.230 --> 06:27:48.854
能点击查看命令面板，我们会得到一个像这样的小弹出框。

4587
06:27:48.854 --> 06:27:57.565
另一种打开命令面板的方法是点击command Shift P，或者Ctrl Shift P，这取决于你的Mac, Linux或者Windows。

4588
06:27:57.565 --> 06:28:04.544
我们要做的是输入设置，然后打开设置JSON，我们不想打开默认设置JSON。

4589
06:28:04.544 --> 06:28:06.356
我们不想碰这些。

4590
06:28:06.356 --> 06:28:08.595
但是我们希望打开JSON设置。

4591
06:28:08.595 --> 06:28:12.062
您还会注意到有用户设置和工作空间设置。

4592
06:28:12.062 --> 06:28:14.216
这些部分我们也可以调整。

4593
06:28:14.216 --> 06:28:17.113
我们将直接进入JSON设置。

4594
06:28:17.113 --> 06:28:21.215
所以所以我这里已经有一些东西了，但你的可能是空白的。

4595
06:28:21.215 --> 06:28:23.365
或者你这里也可能有一些东西。

4596
06:28:23.365 --> 06:28:31.306
所以我们要做的是如果你在这里已经有东西了，我们要加一个逗号，然后我们要做引号，固体。

4597
06:28:31.306 --> 06:28:38.062
闭上括号，我们要做一个小冒号，像这样。

4598
06:28:38.062 --> 06:28:41.763
这意味着我们将对Visual Studio代码应用一些设置。

4599
06:28:41.763 --> 06:28:50.741
当我们处理固体时，我们会在这里添加一个编辑器，这是Doc默认的物质编辑器。

4600
06:28:50.741 --> 06:28:58.124
你甚至可能会弹出一个窗口告诉你一些不同的东西我们可以使用默认格式或者我们的默认格式，

4601
06:28:58.124 --> 06:29:05.333
或者是Nanak foundation。hard hat，连字符solidity。

4602
06:29:05.333 --> 06:29:14.202
这意味着任何时候我们要格式化我们的代码，它将使用硬帽固态性插件，作为它的默认格

4603
06:29:14.202 --> 06:29:23.299
式，或者硬帽固态性插件自带一些格式，以及许多其他真正有用的工具，供我们编写代码。

4604
06:29:23.299 --> 06:29:28.483
现在我们有了这个部分，接下来我们要做的是在保存中添加format。

4605
06:29:28.483 --> 06:29:36.483
如果还没有，我们可以把它添加到JSON文件中，但我不会把它添加到JSON文件中，我会把它添加到整个文件中。

4606
06:29:36.483 --> 06:29:42.112
如果我们打开命令面板，输入设置，打开用户设置，这是

4607
06:29:42.112 --> 06:29:47.741
另一个很好的地方我们可以在这里查看UI的添加设置。

4608
06:29:47.741 --> 06:29:49.939
所以这两个本质上是一样的。

4609
06:29:49.939 --> 06:29:56.448
只是这个有刻度盘和更多的上下文而JSON只会说，给我它的原始代码。

4610
06:29:56.448 --> 06:29:57.958
这告诉我们更多。

4611
06:29:57.958 --> 06:29:59.216
你可以用任何一个。

4612
06:29:59.216 --> 06:30:02.414
但我们要寻找格式，onsave。

4613
06:30:02.414 --> 06:30:07.200
如果你还没检查过的话，你会想要检查的。

4614
06:30:07.200 --> 06:30:13.587
这意味着每次我们保存VS code时，它都会试图为我们格式化代码。

4615
06:30:13.587 --> 06:30:16.200
现在我们已经检查了这个，我们添加了settings。JSON。

4616
06:30:16.233 --> 06:30:17.905
记住，我们要保存它。

4617
06:30:19.233 --> 06:30:20.686
白点，表示没得救。

4618
06:30:22.233 --> 06:30:22.995
然后结束。

4619
06:30:22.995 --> 06:30:24.233
让我把这个也画出来。

4620
06:30:25.234 --> 06:30:31.807
在这里，我们添加一些随机的新空格，你想让它看起来有点丑，然后保存它。

4621
06:30:31.807 --> 06:30:36.618
它会自动重新格式化，看起来更好。

4622
06:30:36.618 --> 06:30:41.447
如果我们这样做，我们会保存它，重新格式化它，让

4623
06:30:41.447 --> 06:30:46.487
它看起来更好这个让你和其他看你代码的人更容易读。

4624
06:30:46.487 --> 06:30:48.137
这真的很好。

4625
06:30:48.137 --> 06:30:54.524
这行用于设置。JSON的代码位于完整的区块链学习课程中。

4626
06:30:54.524 --> 06:30:54.620
js。

4627
06:30:54.620 --> 06:31:03.141
你也可以复制粘贴它，我们会覆盖默认格式或者另一种叫做pretty的格式。

4628
06:31:03.141 --> 06:31:07.844
但最好有一个默认格式，如果将来不想添加

4629
06:31:07.844 --> 06:31:12.796
更漂亮的代码，就可以使用默认的格式化器。

4630
06:31:12.796 --> 06:31:13.296
太棒了。

4631
06:31:13.296 --> 06:31:18.537
在进行格式化时，我们还要为JavaScript代码添加一个默认格式。

4632
06:31:18.537 --> 06:31:24.055
为了进行测试，让我们创建新文件，我们将其命名为deploy。Jas。

4633
06:31:24.055 --> 06:31:32.116
在这里，我们可以做一些函数Hi console。log,

4634
06:31:32.116 --> 06:31:39.602
Hi，然后添加然后让它看起来有点恶心，也许像这样。

4635
06:31:39.602 --> 06:31:44.698
如果你点击保存，它会自动格式化，这很好，你可

4636
06:31:44.698 --> 06:31:50.027
以通过返回命令面板来关闭它，说，保存不格式化。

4637
06:31:50.027 --> 06:31:53.122
这样它就会被保存而不被格式化。

4638
06:31:53.122 --> 06:32:00.332
添加其他格式的方法是安装另一个扩展名，这个名为pretty tier。

4639
06:32:00.332 --> 06:32:03.355
我们可以在这里查找更漂亮的和扩展。

4640
06:32:03.355 --> 06:32:06.924
你会想要安装这个漂亮的代码格式化器。

4641
06:32:06.924 --> 06:32:09.480
我们要安装这个。

4642
06:32:09.480 --> 06:32:18.178
很好，现在它安装得更漂亮了，它是一个表单，一种代码格式，它适用于很多语言，比如Python, JavaScript，甚至是solididity。

4643
06:32:19.235 --> 06:32:22.806
很快我们就会在JavaScript和solidity中使用pretty。

4644
06:32:22.806 --> 06:32:27.328
但现在，我们要用更漂亮的JavaScript，我们可以

4645
06:32:27.328 --> 06:32:31.850
通过打开命令面板来启用它，我们会打开首选项，打开设置。

4646
06:32:31.850 --> 06:32:37.735
和我们添加固体性部分一样，我们将添加JavaScript部分。

4647
06:32:37.735 --> 06:32:42.419
我们会在这里加一个逗号，一些引号，括号，我

4648
06:32:42.419 --> 06:32:47.328
们会输入JavaScript，结束冒号括号。

4649
06:32:47.328 --> 06:32:53.936
我们将在door。default或matter处做同样的事情。

4650
06:32:53.936 --> 06:32:58.670
Net，然后在这里，我们要做e s

4651
06:32:58.670 --> 06:33:04.520
BENP，更漂亮的连字符VS code。

4652
06:33:04.520 --> 06:33:08.718
这将使JavaScript的默认编辑器更漂亮。

4653
06:33:08.718 --> 06:33:14.922
就像我说的，很快，我们就会有更好的覆盖这两个对于可靠性和JavaScript。

4654
06:33:14.922 --> 06:33:21.703
我们会给一些更漂亮的参数，这样无论谁使用你的代码，他们都会有完全相同的格式。

4655
06:33:21.703 --> 06:33:27.147
现在我们有了更漂亮的默认编辑器，如果我们返回来

4656
06:33:27.147 --> 06:33:32.828
部署。js，然后点击保存，它的格式应该是这样的。

4657
06:33:32.828 --> 06:33:35.156
现在，我们继续做这样的事情。

4658
06:33:35.156 --> 06:33:39.510
如果我们继续这样做，它会重新格式化成像这样像这样。

4659
06:33:39.510 --> 06:33:44.504
另外，如果你想回到命令面板，打开用户设置，

4660
06:33:44.504 --> 06:33:51.401
而不是JSON模式，我们会到默认格式，或者你甚至可以选择默

4661
06:33:51.401 --> 06:33:57.586
以选择默认格式或所有语言，如果你想对所有格式化器使用更漂亮。

4662
06:33:57.586 --> 06:33:58.686
请随便说。

4663
06:33:58.686 --> 06:34:07.093
很好，得到了JavaScript格式，让我们开始写一些JavaScript代码。

4664
06:34:07.236 --> 06:34:07.569
太棒了。

4665
06:34:10.236 --> 06:34:15.155
学习如何使用JavaScript实际部署我们的契约。

4666
06:34:15.236 --> 06:34:20.812
这将教会我们很多关于事务的知识以及在底层发生了什么，甚至在混搭中底

4667
06:34:20.812 --> 06:34:26.558
层发生了什么，混搭中，我们通常只需要点击编译按钮，然后点击部署按钮。

4668
06:34:26.558 --> 06:34:27.912
就是这样。

4669
06:34:27.912 --> 06:34:32.410
在JavaScript中，我们会创建自己的函数来帮助我们完成这两件事。

4670
06:34:32.410 --> 06:34:38.684
正如我提到的，这是课程的一部分我们将开始使用JavaScript，如果你喜欢，也可以选择TypeScript。

4671
06:34:38.684 --> 06:34:42.628
就像我说的，所有这些部分都有TypeScript版本。

4672
06:34:42.628 --> 06:34:49.460
让我们设置deployout js脚本来部署简单的storage。soul。

4673
06:34:49.460 --> 06:34:55.202
那么我们该如何开始呢?首先，让我们学习如何使用JavaScript和Node js运行脚本。

4674
06:34:55.202 --> 06:35:02.541
如果你想打印行，或者只是打印一些东西到你的终端，我们可以做一个叫做console。log的东西。

4675
06:35:02.541 --> 06:35:06.104
如果我点击console。log，嗨，点击保存。

4676
06:35:06.104 --> 06:35:08.661
我打开我的终端。

4677
06:35:08.661 --> 06:35:11.267
现在可以运行Node deploy了。

4678
06:35:11.267 --> 06:35:11.454
js。

4679
06:35:11.454 --> 06:35:13.285
它会打印出high

4680
06:35:13.285 --> 06:35:20.611
node这是我们想用node js运行JavaScript代码的方式。

4681
06:35:20.611 --> 06:35:25.068
其他你可能熟悉的语言，有时我们会用Python，你知道，

4682
06:35:25.068 --> 06:35:30.799
deployuppy，或者Java, C deploy。Java，等等。

4683
06:35:30.799 --> 06:35:35.362
但是对于JavaScript，由于前端和后端JavaScript是不同的。

4684
06:35:35.362 --> 06:35:37.143
我们在后端用node运行代码。

4685
06:35:37.237 --> 06:35:43.665
有了JavaScript，你可以做很多你会看到的东西，比如固体，稍微松散的结构。

4686
06:35:43.665 --> 06:35:48.961
如果我想创建一个变量，我可以说，让变量

4687
06:35:48.961 --> 06:35:54.537
等于5，这类似于你和256，变量等于5。

4688
06:35:54.537 --> 06:35:58.503
但在JavaScript中，我们使用let或var或const。

4689
06:35:58.503 --> 06:36:03.862
然后我可以打印出来，我可以写console。log variable。

4690
06:36:03.862 --> 06:36:10.808
JavaScript是可选的你是否需要分号。

4691
06:36:10.808 --> 06:36:13.658
这里，我觉得更漂亮，默认使用分号。

4692
06:36:13.658 --> 06:36:16.926
我们会在不久的将来把这些东西在你的候机楼里处理掉。

4693
06:36:16.926 --> 06:36:24.475
一旦你开始输入文件名，如果你按tab键，它就会自动补全剩下的文件名

4694
06:36:24.475 --> 06:36:32.253
按tab键，它就会自动补全如果我们按回车键，就会得到Hi，然后是5。

4695
06:36:32.253 --> 06:36:35.086
因为这个输出Hi，然后输出5。

4696
06:36:35.086 --> 06:36:39.605
JavaScript会自动从文件顶部的代码开始。

4697
06:36:39.605 --> 06:36:42.058
首先是console。log，然后是变量。

4698
06:36:42.058 --> 06:36:43.499
还有这个。

4699
06:36:43.499 --> 06:36:51.753
但是，一个好的实践是将所有您想要做的事情都打包到一个main函数中，然后运行那个main函数。

4700
06:36:51.753 --> 06:36:58.269
但我们能做的是在顶部这里，我们写上function，意思，添

4701
06:36:58.269 --> 06:37:04.786
加括号和一些括号，在底部加上右括号，然后点击保存为自动格式。

4702
06:37:04.786 --> 06:37:10.134
现在，如果我们运行这个，什么也不会发生，因为我们已经把所有的代码包装在一个主函数中。

4703
06:37:10.134 --> 06:37:17.830
如果我现在运行node deployed to Jess，什么都不会发生，因为我需要调用main函数。

4704
06:37:17.830 --> 06:37:22.045
如果我取下面这个main函数，调用main，

4705
06:37:22.045 --> 06:37:29.134
我们的代码中的job实际上会说，啊，脚本的第一行实际上是这个main函数。

4706
06:37:29.134 --> 06:37:33.452
现在如果我执行node deploy。j s，它会运行到high和5，这就是我们想要的。

4707
06:37:33.452 --> 06:37:38.046
现在，这将是我们大部分脚本的设置，包括我们写的

4708
06:37:38.046 --> 06:37:42.641
脚本，当我们进入硬帽，然而，有一个主要的区别。

4709
06:37:42.641 --> 06:37:47.983
我们用的不是常规函数，而是async函数。

4710
06:37:47.983 --> 06:37:50.872
我们要用异步编程来实现这个。

4711
06:37:50.872 --> 06:37:59.303
现在，如果我接下来说的对你来说真的很困惑不要让它减慢你的速度，请继续观看JavaScript课程来了解更多关于这方面的知识。

4712
06:37:59.303 --> 06:38:02.113
但我也会告诉你们，这是一个async函数。

4713
06:38:02.113 --> 06:38:06.009
这是我们在使用它时需要注意的。

4714
06:38:06.009 --> 06:38:11.723
但我还是想给你们简单介绍

4715
06:38:11.723 --> 06:38:17.438
一下异步编程的背景知识。

4716
06:38:17.438 --> 06:38:20.531
到目前为止，我们所做的编程都是同步的。

4717
06:38:20.531 --> 06:38:27.017
稳健性是编程语言的一个例子，同步，同步意味着它一行接一行。

4718
06:38:27.017 --> 06:38:34.145
如果我们的代码是这样的，这是同步写入，我们的main函数是第一个被调用的。

4719
06:38:34.145 --> 06:38:37.721
然后是console。log，变量等于5，然后是console。log。

4720
06:38:37.721 --> 06:38:42.566
这是JavaScript的同步编程，所有的实体都是同步编程的。

4721
06:38:42.566 --> 06:38:45.273
在使用神谕的时候会有一些例外。

4722
06:38:45.273 --> 06:38:46.972
但目前，一切都是同步的。

4723
06:38:46.972 --> 06:38:53.223
JavaScript可以是异步的，这意味着我们实际上可以让代码同时运行。

4724
06:38:53.223 --> 06:38:57.980
我喜欢用一个很好的例子来理解烹饪的区别。

4725
06:38:57.980 --> 06:39:06.239
在同步编程中，对于烹饪，你可能会把爆米花放进微波炉，等待爆米花完成。

4726
06:39:06.239 --> 06:39:10.294
然后，也许你会给大家倒酒。

4727
06:39:10.294 --> 06:39:12.317
这就是同步编程。

4728
06:39:12.317 --> 06:39:18.560
现在，对你来说，把爆米花放进微波炉里，然后盯着它，等着它吃完可能有点奇怪。

4729
06:39:18.560 --> 06:39:25.039
然后倒饮料，你通常可以在爆米花在微波炉里加热的时候倒饮料。

4730
06:39:25.039 --> 06:39:27.608
这就是异步编程的用得上的地方。

4731
06:39:27.608 --> 06:39:33.905
如果为这个电影之夜做准备，我们是异步的，你会做的就是把爆米花放进微波炉里。

4732
06:39:33.905 --> 06:39:40.090
当爆米花在微波炉里，或者给所有人喝的饮料，然后你会等爆

4733
06:39:40.090 --> 06:39:46.275
米花吃完，因为你没有什么可做的，但你等爆米花吃完再倒饮

4734
06:39:46.275 --> 06:39:52.690
料是没有意义的，你可以直接直接倒饮料，然后等爆米花吃完。

4735
06:39:52.690 --> 06:39:57.560
所以异步编程是一种不用等待任务完成就能完成任务的方式。

4736
06:39:57.560 --> 06:40:05.192
这在JavaScript中非常有利默认情况下允许我们进行异步编程，但有时我们需要等待爆米花完成。

4737
06:40:05.239 --> 06:40:13.916
例如，如果不只是倒饮料，那么下一件事可能就是在爆米花上撒盐而不是倒饮料。

4738
06:40:13.916 --> 06:40:19.489
当然，如果我们想在爆米花上放盐，我们必须等爆米花从微波炉里出来。

4739
06:40:19.489 --> 06:40:27.949
所以即使把爆米花放在微波炉里有这个等待时间我们需要能够告诉我们的代码我想让你等待它或者不，你很好。

4740
06:40:27.949 --> 06:40:30.142
你可以继续做另一个任务。

4741
06:40:30.142 --> 06:40:32.287
这就是区别所在。

4742
06:40:32.287 --> 06:40:37.311
我会在GitHub上留下一些与这门课相关的链接来更好地

4743
06:40:37.311 --> 06:40:42.336
理解这个函数有这个等待期的函数返回一个叫做问题的东西。

4744
06:40:42.336 --> 06:40:48.453
如果把爆米花放进微波炉是JavaScript中的一个函数，那它就是一个基于承诺的函数。

4745
06:40:48.453 --> 06:40:52.593
承诺可以是待定的，可以是履行的，也可以是拒绝的。

4746
06:40:52.593 --> 06:40:55.450
这样我们就能知道爆米花是否做好了。

4747
06:40:55.450 --> 06:41:03.699
如果我们的爆米花是一个方法，把爆米花放进微波炉，是JavaScript中的一个函数，当我们在等待爆米花完成时，它处于挂起状态。

4748
06:41:03.699 --> 06:41:07.530
当爆米花吃完的时候，它就满足了。

4749
06:41:07.530 --> 06:41:11.646
如果我们中途中止，停止等待，它就会被拒绝。

4750
06:41:11.646 --> 06:41:14.699
所以把爆米花放进微波炉里是一个承诺。

4751
06:41:14.699 --> 06:41:23.418
有了这个承诺，我们必须告诉我们的代码，嘿，我们想让你等爆米花吃完或者你可以继续做一些事情。

4752
06:41:23.418 --> 06:41:26.324
让我们用一些JavaScript语法把这些放在一起。

4753
06:41:26.324 --> 06:41:29.453
再说一遍，我们要安排这个电影之夜。

4754
06:41:29.453 --> 06:41:32.840
我们要做爆米花，给大家倒饮料。

4755
06:41:32.840 --> 06:41:34.879
然后我们要开始看电影。

4756
06:41:34.879 --> 06:41:40.043
让我们写一些伪代码来假设如果这是一个函数这段代码是什么样的。

4757
06:41:40.043 --> 06:41:44.128
我们创建了一个函数叫setup, Movie Night。

4758
06:41:44.128 --> 06:41:49.076
在这里，我们会说，好的，我们首先要做什么?好了，我们要做爆米花了。

4759
06:41:49.076 --> 06:41:51.306
假设我们有一个煮爆米花的函数。

4760
06:41:51.306 --> 06:41:56.530
所以我们会说，好吧，做爆米花，然后我们要做的下一件事是我们要倒饮料，或者喝。

4761
06:41:56.530 --> 06:41:59.755
我们调用一些倒饮料函数。

4762
06:41:59.755 --> 06:42:04.944
事情是这样的，我们只想在爆米花煮熟后才开始看电影。

4763
06:42:04.944 --> 06:42:11.551
一旦我们的饮料被倒了，如果其中任何一个返回了一个承诺，如果其中任

4764
06:42:11.551 --> 06:42:18.158
何一个返回了一个承诺，比如煮爆米花，我们就需要告诉这里的代码等待

4765
06:42:18.158 --> 06:42:25.178
爆米花完成因为煮爆米花将是一个我们可以说，让状态等于煮爆米花的函数。

4766
06:42:25.241 --> 06:42:29.812
当爆米花在煮的时候，状态就会结束。

4767
06:42:29.812 --> 06:42:32.923
一旦爆米花煮熟了，它就满足了。

4768
06:42:32.923 --> 06:42:36.413
如果爆米花碎了，微波炉爆炸了，这个状态就会被拒绝。

4769
06:42:36.413 --> 06:42:40.105
但我们不希望状态处于挂起状态。

4770
06:42:40.105 --> 06:42:44.963
在我们继续之前，我们只想在这两个函数完成后开始我们的电影。

4771
06:42:44.963 --> 06:42:47.885
假设它们都返回这些承诺。

4772
06:42:47.885 --> 06:42:51.174
所以我们需要告诉我们的代码，嘿，你得等等。

4773
06:42:51.174 --> 06:42:55.641
或者你不得不等着爆米花和劣质的饮料喝完。

4774
06:42:55.641 --> 06:43:01.141
我们现在能做的是不用太深入了解这些是如何工作的，我们能做的最简单的

4775
06:43:01.141 --> 06:43:06.641
事情之一你们会看到我们经常使用这种语法就是把这个函数变成异步函数。

4776
06:43:06.641 --> 06:43:12.895
当我们的函数是异步的，我们可以访问一个名为await的关键字。

4777
06:43:12.895 --> 06:43:19.150
await关键字告诉任何基于承诺的函数等待该承诺被实现或拒绝。

4778
06:43:19.150 --> 06:43:22.553
所以我们说好，我们想等爆米花熟了。

4779
06:43:22.553 --> 06:43:24.952
然后我们要等着倒饮料。

4780
06:43:24.952 --> 06:43:27.579
然后我们就可以开始看电影了。

4781
06:43:27.579 --> 06:43:31.952
只有这两个都完成了，电影才会在这里开始。

4782
06:43:31.952 --> 06:43:36.241
这就是为什么在我们所有的代码中，你会看到await关键字被大量使用。

4783
06:43:36.241 --> 06:43:38.391
但它只能在异步函数中使用。

4784
06:43:38.391 --> 06:43:45.257
基本上，当你看到await关键字时，被调用的函数是基于承诺的。

4785
06:43:45.257 --> 06:43:49.487
在这个函数完成之前我们不想进行下一个步骤。

4786
06:43:49.487 --> 06:43:53.185
以上是关于承诺和异步编程的更多内容。

4787
06:43:53.242 --> 06:43:54.320
希望你们明白了。

4788
06:43:56.242 --> 06:43:59.195
在描述中了解更多关于异步编程的信息。

4789
06:43:59.242 --> 06:44:04.225
我之所以要讲这个是因为我们要用到的大部分函数都是异步的。

4790
06:44:04.225 --> 06:44:09.177
例如，当我们部署契约时，我们必

4791
06:44:09.177 --> 06:44:14.129
须做什么?我们得等它被部署好。

4792
06:44:14.242 --> 06:44:19.876
如果我们不使用同步编程，只让函数main像这样，会发生的是我们会写

4793
06:44:19.876 --> 06:44:25.511
一些像contract。deploy这样的代码，我们不会等它完成。

4794
06:44:25.511 --> 06:44:33.956
显然，如果我们不等待它完成，我们试图在一个尚未完成部署的契约上运行一些代码，它将无法工作。

4795
06:44:33.956 --> 06:44:42.046
我们想这样做，我们想让主函数是一个async函数，这样我们就可以等待契约部署，我们可以

4796
06:44:42.046 --> 06:44:50.136
等待事情发生，我们可以等待爆米花完成，我们可以灵活地告诉代码是等待爆米花完成还是继续。

4797
06:44:50.136 --> 06:44:56.209
现在我们有了一个async函数的main函数，我们要往下面的main函数中添加一些代码。

4798
06:44:56.209 --> 06:45:00.527
这里添加的代码是一些用于处理异步函数的语法。

4799
06:45:00.527 --> 06:45:04.258
如果这部分让人困惑，我现在就说，绝对的，不用担心。

4800
06:45:04.258 --> 06:45:06.042
如果你以后想理解的话。

4801
06:45:06.042 --> 06:45:06.442
这很好。

4802
06:45:06.442 --> 06:45:13.431
但对于那些跟随我们的人，我们只会添加

4803
06:45:13.431 --> 06:45:20.420
一个add然后抓住空气你可以自己跟随

4804
06:45:20.420 --> 06:45:28.187
输入这个或者你可以复制粘贴到你的代码中。

4805
06:45:28.243 --> 06:45:32.874
基本上，这允许我们做的是我们的主函数，这是一个异步函数。

4806
06:45:32.874 --> 06:45:40.984
当我们调用main函数时，这是另一种语法用来等待它基本完成然后打印它得到的任何错误。

4807
06:45:40.984 --> 06:45:48.093
这就是我们这么做的原因，再说一次，如果这一大块代码，如果你想知道这一大块代码是怎么回事，老实说，现在，只需要复制粘贴它。

4808
06:45:48.093 --> 06:45:48.543
太好了。

4809
06:45:48.543 --> 06:45:51.385
我们有异步函数main，我们有一些代码。

4810
06:45:51.385 --> 06:45:56.275
然后我们有这段代码，它基本上调用了主异步函数。

4811
06:45:56.275 --> 06:45:56.865
好了,好了。

4812
06:45:56.865 --> 06:45:58.581
我先把这些都删掉。

4813
06:45:58.581 --> 06:46:02.639
但你仍然可以在与本课程相关的GitHub回购中找到常见的。

4814
06:46:02.639 --> 06:46:03.052
太棒了。

4815
06:46:03.052 --> 06:46:07.925
好的，现在我们有了真正的基本设置，让我们继续，开始编码。

4816
06:46:07.925 --> 06:46:13.147
如果这个set apart让人困惑，async await让人困惑，不要太担心。

4817
06:46:13.147 --> 06:46:15.354
随着我们的进步，它会变得更有意义。

4818
06:46:15.354 --> 06:46:21.937
我们所有的代码基本上都会在这个async函数main中，它将是我们部署简单

4819
06:46:21.937 --> 06:46:28.342
存储。灵魂存储的主脚本deploy脚本将完全复制remix中发生的事情，

4820
06:46:28.342 --> 06:46:35.461
在remix中，我们总是做的第一件事是什么?我们要做的第一件事是编译所有的代码。

4821
06:46:35.461 --> 06:46:40.036
我们还需要在JavaScript项目中编译代码。

4822
06:46:40.036 --> 06:46:45.360
为了编译我们的简单存储契约，我们将使用一个名为Silk Jas的工具，

4823
06:46:45.360 --> 06:46:51.293
JavaScript实际上有一种方法可以直接将项目安装到我们的设置和文件夹中。

4824
06:46:51.293 --> 06:46:54.800
如果我们向下滚动这个丝绸Jas就是我们要找的。

4825
06:46:54.800 --> 06:47:00.903
因为它有一种通过相对路径来编译导入其他合约的方法，所以您可以在这个自述文

4826
06:47:00.903 --> 06:47:07.177
件和大多数文档中看到类似这样的部分，如果它与JavaScript兼容的话。

4827
06:47:07.177 --> 06:47:15.444
对于Node js的使用，它说通过Node js使用最新的稳定版本的固体编译器，你可以通过NPM NPM install安装它。

4828
06:47:15.444 --> 06:47:19.340
NPM就是所谓的包管理器。

4829
06:47:19.340 --> 06:47:24.332
我们实际上通过安装没有Jess来安装NPM，对吧，如果

4830
06:47:24.332 --> 06:47:29.325
我们没有破折号版本，你也应该能够安装NPM破折号版本。

4831
06:47:29.325 --> 06:47:32.604
它附带的另一个工具叫做core pack。

4832
06:47:32.604 --> 06:47:35.122
你可以输入核心包破折号版本，

4833
06:47:35.122 --> 06:47:41.958
现在我们可以用NPM安装NPM安装丝绸，然而，我喜欢纱线包管理器稍微好一点。

4834
06:47:41.958 --> 06:47:47.899
我们实际上要安装yarn包管理器来做所有的包管理。

4835
06:47:47.899 --> 06:47:53.976
如果你进入安装页面，安装纱线的新方法是运行core pack enable。

4836
06:47:53.976 --> 06:47:56.604
旧的方法是用NPM安装。

4837
06:47:56.604 --> 06:48:03.888
如果你继续运行核心包启用后，完成，你应该能够运行纱线破折号版本。

4838
06:48:03.888 --> 06:48:12.163
或者，你可以只运行NPM i dash g core pack，然后你可以运行core pack enable。

4839
06:48:13.244 --> 06:48:17.519
最后的选择是你可以运行NPM i dash g纱。

4840
06:48:17.519 --> 06:48:20.829
这将为您的系统全局安装yarn。

4841
06:48:20.829 --> 06:48:24.431
但这被认为是过时的安装纱线的方式。

4842
06:48:24.431 --> 06:48:26.767
理想情况下，你运行core pack enable。

4843
06:48:26.767 --> 06:48:33.211
但在任何情况下，在你运行这些之后，如果你运行纱线破折号版本，你应该得到像这样的东西。

4844
06:48:33.211 --> 06:48:39.182
现在我们有了纱线，我们可以使用纱线来安装我们所有的项目，而不是NPM。

4845
06:48:39.244 --> 06:48:47.175
回到silk Jas中，上面写着npm install soak，我们可以做npm install

4846
06:48:47.175 --> 06:48:55.754
sock的纱线等等物，也就是yarn, add sock，这实际上会继续并将solc安装到我们的项目中。

4847
06:48:55.754 --> 06:49:02.050
如果我们打开文件夹，你会看到它添加了几个不同的文件夹，它首先添加了一个包。

4848
06:49:02.050 --> 06:49:09.198
JSON包。JSON是一个文件，它告诉我们很多关于项目的信息以及它所使用的依赖关系。

4849
06:49:09.245 --> 06:49:14.083
例如，我们已经安装了soap包0。

4850
06:49:15.245 --> 06:49:20.520
yarn点锁告诉我们项目中所有不同包的确切版本。

4851
06:49:20.520 --> 06:49:25.800
例如，这一点之所以如此重要，是因为solc也有大量的依赖项。

4852
06:49:25.800 --> 06:49:32.045
yarn dot lock告诉我们solc的确切版本以及solchen的所有不同依赖关系。

4853
06:49:32.045 --> 06:49:33.911
我们添加的任何其他项目。

4854
06:49:33.911 --> 06:49:37.402
这是自动生成的文件，不要直接编辑该文件。

4855
06:49:37.402 --> 06:49:40.517
最后一点是，我们有这个节点模块文件夹。

4856
06:49:40.517 --> 06:49:46.371
这个节点模块文件夹会是我们刚刚下载的所有安装代码所在的地方，

4857
06:49:46.371 --> 06:49:52.030
例如，如果我们看节点模块，我们会看到有一个sock文件夹。

4858
06:49:52.030 --> 06:49:59.174
在这个sock文件夹中是所有与我们刚刚安装的soap包相关的代码。

4859
06:49:59.245 --> 06:50:02.122
因为我们是在(0,8)处工作。

4860
06:50:03.245 --> 06:50:05.470
想要安装那个特定的版本。

4861
06:50:06.245 --> 06:50:12.770
要做纱线，在0点8处加入solc。

4862
06:50:17.245 --> 06:50:20.800
在我们的package。JSON中，你现在可以看到零点8。

4863
06:50:21.245 --> 06:50:24.245
固定在我们的依赖部分生闷气。

4864
06:50:25.246 --> 06:50:28.865
可以只加盐版像纱线加零点八。

4865
06:50:29.246 --> 06:50:31.686
零点八有个问题。

4866
06:50:33.246 --> 06:50:34.246
8点。

4867
06:50:36.246 --> 06:50:42.934
你可以找到不同的版本，不同的版本，如果你去sulk Jas的版本，然后标签，好的，很好。

4868
06:50:42.934 --> 06:50:51.066
既然我们已经出售了合同，我们就有能力实际编译我们的契约，我们可以在代码

4869
06:50:51.066 --> 06:50:59.432
中编译它们，并在点击Deploy时自动运行它，或者我们可以单独编译它们。

4870
06:50:59.432 --> 06:51:07.877
如果您想在此之后返回，本节是一个雕塑Jas存储库中的示例，它向您展示了如何在代码中实际编译silk。

4871
06:51:07.877 --> 06:51:12.371
实际上，我们将使用soap Jas命令分别编译它们。

4872
06:51:12.371 --> 06:51:18.164
yarn命令既可用于安装依赖项，也可用于运行脚本。

4873
06:51:18.164 --> 06:51:25.150
如果你打开sulk Jas向下滚动，它说为了使用命令行，你实际上需要全局安装它。

4874
06:51:25.150 --> 06:51:31.035
如果你想要全局安装它使用yarn全局添加solc在零点8。

4875
06:51:31.035 --> 06:51:34.263
7 Dash固定你可以绝对向前走。

4876
06:51:34.263 --> 06:51:40.116
然而，由于我们在这个文件夹中，它有yarn。lock package

4877
06:51:40.116 --> 06:51:46.659
json和节点模块yarn将足够聪明，知道i你在这个文件夹中寻找的是浸泡。

4878
06:51:46.659 --> 06:51:51.468
因此，我们实际上可以继续使用yarn和solc Jess编译我

4879
06:51:51.468 --> 06:51:56.277
们的合同，如果你想查看所有不同的命令，我们可以只运行yarn。

4880
06:51:56.277 --> 06:52:01.020
Jas帮助，你会看到它会吐出一个列

4881
06:52:01.020 --> 06:52:05.763
表，列出了软Jas的所有不同选项。

4882
06:52:05.763 --> 06:52:14.747
你也可以运行纱线，所以Jas破折号版本只是为了确保我们是正确的版本，这确实是零点8。

4883
06:52:14.747 --> 06:52:14.818
7.

4884
06:52:14.818 --> 06:52:21.916
现在要真正编译我们在soul的简单存储，让我们运行遵从命令

4885
06:52:21.916 --> 06:52:29.014
我们将运行yarn，所以J S，破折号bin因为我们想要二

4886
06:52:29.014 --> 06:52:36.358
进制破折号ABI因为我们也想要ABI破折号包含路径节点模块。

4887
06:52:36.358 --> 06:52:44.419
因为我们想在节点模块中包含任何契约或文件，这个项目中我们不使用任何契约或文件，但在未来，您将需

4888
06:52:44.419 --> 06:52:52.480
要包括这个破折号包含路径节点模块做破折号基本路径的period，这个period意味着基本路径

4889
06:52:52.480 --> 06:53:00.715
将是这个文件夹破折号O period，这意味着我们将输出编译后的二进制文件和ABI到这个文件夹。

4890
06:53:00.715 --> 06:53:03.996
最后，简单的存储。灵魂。

4891
06:53:03.996 --> 06:53:10.617
因为这是我们想要编译的契约，所以可以从简单存储到简单存储自动完成它。

4892
06:53:10.617 --> 06:53:18.908
输入simple，然后按Tab键，然后回车，你会看到它在运行这个命令来编译合约。

4893
06:53:18.908 --> 06:53:21.707
您将看到两个文件得到输出。

4894
06:53:21.707 --> 06:53:27.980
一个叫做Simple Storage soul的API在Simple Storage Sol中强

4895
06:53:27.980 --> 06:53:34.385
调Simple Storage dot bin，这个ABI显然是这个合同的ABI，它在未来会需要。

4896
06:53:34.385 --> 06:53:40.264
然后bin将是二进制，或者是这个代码的底层，然后重新混音。

4897
06:53:40.264 --> 06:53:46.448
如果你编译简单的存储，那就是灵魂，你可以看

4898
06:53:46.448 --> 06:53:52.632
看遵从性细节，像我们刚得到的ABI，或者字

4899
06:53:52.632 --> 06:53:59.112
节码，如果你看这个对象，它和二进制是一样的。

4900
06:53:59.248 --> 06:53:59.984
好了,好了。

4901
06:54:02.248 --> 06:54:08.755
现在，很明显，如果你点击你的键盘，你可以循环使用你最近的终端命令。

4902
06:54:08.755 --> 06:54:13.791
如果你能找到足够多的，我们可以看到刚才运行的这个命令每次

4903
06:54:13.791 --> 06:54:18.828
都能找到一大堆，每当我们想要重新编译时，这是非常烦人的。

4904
06:54:18.828 --> 06:54:25.981
所以我们能做的就是在我们的package。JSON中添加一个脚本部分，为我们缩短一些yarn脚本。

4905
06:54:25.981 --> 06:54:34.829
我们要做的是回到我们的包中，点JSON，很多逗号，我们会添加一个叫做scripts的部分，添加冒号和括号。

4906
06:54:34.829 --> 06:54:40.414
在这里，我们会说只要我们说compile，我们就会运行这个长命令。

4907
06:54:40.414 --> 06:54:43.171
所以我要编译我们会加一些引号。

4908
06:54:43.171 --> 06:54:45.017
我们把它粘贴到这里。

4909
06:54:45.017 --> 06:54:53.441
现在不用把所有东西都敲出来，只要我们在和package json所在的文件夹里，我们就可以运行yarn compile。

4910
06:54:53.441 --> 06:55:02.037
这将为我们运行整个脚本而不需要我们把所有的东西都打出来脚本是一个非常有用的方法让我们更容易运行长命令。

4911
06:55:02.037 --> 06:55:02.931
好的，很好。

4912
06:55:02.931 --> 06:55:07.875
现在我们的代码已经编译好了，这就相当于US

4913
06:55:07.875 --> 06:55:12.819
点击了这个编译按钮，我们就可以进行部署了。

4914
06:55:13.248 --> 06:55:15.048
现在我们有了简单的存储。

4915
06:55:16.248 --> 06:55:18.581
让我们学习一下如何部署这个东西。

4916
06:55:19.248 --> 06:55:21.780
我们把它部署到两个不同的地方，

4917
06:55:21.780 --> 06:55:29.715
我们部署到一个JavaScript虚拟机，或者我们注入的web 3，和我们的Metamask。

4918
06:55:29.715 --> 06:55:32.301
我们先来学习一下，做JavaScript虚拟机。

4919
06:55:32.301 --> 06:55:39.011
然后我们将学习如何使用注入的web 3，或元掩码或连接到实际的测试网。

4920
06:55:39.011 --> 06:55:46.150
为了将这个部署到JavaScript虚拟邀请I'm in或假区块链，我们需要得到假区块链。

4921
06:55:46.150 --> 06:55:54.249
将来，我们将使用Hardhead运行时环境作为我们的JavaScript虚拟机，也就是我们的假区块链。

4922
06:55:54.249 --> 06:55:58.233
但在这一节中，我希望大家使用一个叫ganache的工具。

4923
06:55:58.233 --> 06:56:01.095
在GitHub存储库中有一个链接。

4924
06:56:01.095 --> 06:56:04.150
Ganache类似于混音中的虚拟机。

4925
06:56:04.150 --> 06:56:09.842
它是一个假的区块链，我们可以在本地运行它来实际测试、部署和运行代码。

4926
06:56:09.842 --> 06:56:14.732
这也是观察区块链中发生的事情的好方法。

4927
06:56:14.732 --> 06:56:21.982
让我们继续并在安装甘纳许应用程序后旋转它，甘纳许应用程序看起来有点像这样。

4928
06:56:21.982 --> 06:56:27.874
要想快速启动一个假区块链，你可以点击“快速开始”。

4929
06:56:27.874 --> 06:56:33.765
这将启动一个假的区块链在你的电脑上本地运行，这非常棒。

4930
06:56:33.765 --> 06:56:39.084
它有一大堆的假账户就像混音有一大堆的假账户有100以

4931
06:56:39.084 --> 06:56:44.609
太币每个ganache有一大堆的假账户有100以太币。

4932
06:56:44.609 --> 06:56:52.749
它们还附带私钥，我们可以在应用程序中使用私钥来实际控制这些假账户。

4933
06:56:52.749 --> 06:56:55.767
记住，不要在公共区块链上使用这些私钥。

4934
06:56:55.767 --> 06:57:00.749
它们只是用于开发目的，因为很多人知道我们代码中的这些私钥。

4935
06:57:00.749 --> 06:57:07.257
我们需要做的第一件事是连接到区块链remix在幕后做这个，如果我们

4936
06:57:07.257 --> 06:57:13.964
选择JavaScript虚拟机remix会选择它自己运行的假区块链。

4937
06:57:13.964 --> 06:57:18.795
如果我们选择注入web 3，我们知道，元掩码会弹出，它连接到我们的

4938
06:57:18.795 --> 06:57:23.627
元掩码，这个连接remix所做的，实际上是在做一些非常有趣的事情。

4939
06:57:23.627 --> 06:57:27.456
它不只是通过某种神奇的力量连接到我们的元蒙版。

4940
06:57:27.456 --> 06:57:33.383
它实际上连接到我们的元掩码，它有一个连接到幕后的区块链。

4941
06:57:33.383 --> 06:57:37.943
如果你打开你的元掩码，向下选择网络选

4942
06:57:37.943 --> 06:57:42.758
择广告网络，你会弹出一个像这样的UI。

4943
06:57:42.758 --> 06:57:49.583
如果我们返回并点击这里的选择网络，我们可以看到关于这些不同网络的信息。

4944
06:57:49.583 --> 06:57:55.500
我们可以看到的一件主要事情是，所有这些网络都有一个叫做RPC URL的东西。

4945
06:57:55.500 --> 06:57:58.650
RPC是远程过程调用的缩写。

4946
06:57:58.650 --> 06:58:02.750
URL是统一资源定位器。

4947
06:58:02.750 --> 06:58:08.406
这个RPC URL表示连接到某人正在运行的区块链节点，

4948
06:58:08.406 --> 06:58:13.853
这个URL连接我们进行API调用并与区块链节点交互。

4949
06:58:13.853 --> 06:58:18.353
区块链节点与软件一起运行，其中一些节点公开API调用。

4950
06:58:18.353 --> 06:58:23.121
如果你看看非政府组织Aetherium的网站，实际上有指导你

4951
06:58:23.121 --> 06:58:27.889
运行自己的区块链节点为一个真正的区块链像Aetherium。

4952
06:58:27.889 --> 06:58:34.250
其中大多数都有破折号HTTP点ADR等标志来公开这些RPC端点。

4953
06:58:34.250 --> 06:58:40.726
如果你想运行你自己的节点，你自己真正的区块链节点，而不是使用meta掩码或任何其他我们将通过的

4954
06:58:40.726 --> 06:58:47.202
提供者，你可以使用go Aetherium，或任何你正在与软件合作的区块链来运行你自己的笔记。

4955
06:58:47.251 --> 06:58:54.870
但正是这个RPC URL允许我们连接到Rinkeby，如果在Rinkeby ropsten上，如果我们在ropsten主网上如果我们在主网上，等等。

4956
06:58:54.870 --> 06:59:02.529
这将是我们连接ganache区块链的方式我们将在这个应用程序中运行。

4957
06:59:02.529 --> 06:59:07.616
如果你看甘纳许的顶部，有一个部分叫做RPC服务器。

4958
06:59:07.616 --> 06:59:10.464
这是ganache节点的端点。

4959
06:59:10.464 --> 06:59:15.026
我们能做的是复制这个，回到VS代码，粘

4960
06:59:15.026 --> 06:59:19.829
贴到这里，看看能不能连接而不是HTTP。

4961
06:59:19.829 --> 06:59:25.426
有了这些大写字母，我们用小写字母B代替大写字母B，因为小写字母更正确，看起来更好。

4962
06:59:25.426 --> 06:59:26.443
现在我们有了终点。

4963
06:59:26.443 --> 06:59:34.070
假设，有了这个，我们就可以开始对这个端点进行调用和API调用，进入这个JSON RPC规范。

4964
06:59:34.070 --> 06:59:41.876
链接会在GitHub repo中，我们可以看到不同的调用，我们可以直接对节点进行调用，获得不同的信息。

4965
06:59:41.876 --> 06:59:44.630
每个人都被哈希阻塞，每个人都被数字阻塞。

4966
06:59:44.630 --> 06:59:47.155
所有这些精彩的作品都在这里。

4967
06:59:47.155 --> 06:59:51.331
直接调用这些API是有点烦人的。

4968
06:59:51.331 --> 06:59:56.631
如果你想自己做，你完全可以使用像Axios或fetch这样的API端点。

4969
06:59:56.631 --> 07:00:04.691
不过，我们将使用rapper与节点交互并与区块链节点进行部署和交互等操作。

4970
07:00:04.691 --> 07:00:08.182
这就是醚最终发挥作用的地方。

4971
07:00:08.182 --> 07:00:17.166
Ethers js是最流行的基于JavaScript的工具包之一，它允许我们与不同的区块链交互，并有所有这些rapper

4972
07:00:17.166 --> 07:00:26.151
进行所有这些API调用，并使用Aetherium、polygon、avalanche和任何EVM兼容的链做所有这些事情。

4973
07:00:26.151 --> 07:00:30.427
另一个做同样事情的非常受欢迎的包是web 3。

4974
07:00:30.427 --> 07:00:30.497
js。

4975
07:00:30.497 --> 07:00:35.430
你们可能听说过这个你们可能会在这门课和你们的网络三之旅中更多地看到它。

4976
07:00:35.430 --> 07:00:42.974
我们使用醚的原因是醚是驱动硬帽环境的主要工具，我自己也很喜欢它。

4977
07:00:42.974 --> 07:00:48.477
请记住，如果你对这些东西感到困惑，你可以回到他们的文档中去安装它。

4978
07:00:48.477 --> 07:00:56.078
你可以在这里看到，你可以运行npm install ethers，我们只需要做yarn，添加ethers。

4979
07:00:56.252 --> 07:01:01.902
现在你应该在你的package json中看到，我们在这里添加了醚。

4980
07:01:01.902 --> 07:01:02.302
太棒了。

4981
07:01:02.302 --> 07:01:06.040
现在回到代码中，我们将把醚导入到部署中。

4982
07:01:06.040 --> 07:01:13.355
Js脚本，这样我们就可以使用所有附带的工具所以我们说const ethers = require ethers。

4983
07:01:13.355 --> 07:01:18.740
对于上过这门课TypeScript版本的同学，这将是import而不

4984
07:01:18.740 --> 07:01:24.284
是require因为这里有醚，我们可以在main函数中创建提供者对象。

4985
07:01:24.284 --> 07:01:30.832
我们把醚放到主函数外面的原因是我们想把包放到脚本里。

4986
07:01:30.832 --> 07:01:34.514
在调用main之前，我们要确保所有这些都是首先完成的。

4987
07:01:34.514 --> 07:01:37.845
你会看到这是我们脚本的正常设置。

4988
07:01:37.845 --> 07:01:45.886
在顶部，我们导入任何依赖项或外部包，我们有我们的main函数，然后我们在底部调用我们的main函数。

4989
07:01:45.886 --> 07:01:51.252
Const是一个类似于let的关键字，因此不能更改醚。

4990
07:01:51.252 --> 07:01:52.527
所以我们不能改变这个。

4991
07:01:52.527 --> 07:01:58.477
我们的ethers变量，任何时候我们使用const require都是一个导入ethers包的函数。

4992
07:01:58.477 --> 07:02:00.490
现在remix在幕后完成了所有这些工作。

4993
07:02:00.490 --> 07:02:06.609
但我们在代码中要做的是我们会说const provider =

4994
07:02:06.609 --> 07:02:13.321
new醚。providers。JSON RPC provider。

4995
07:02:13.321 --> 07:02:18.506
然后我们会把这个字符串作为提供者传递。

4996
07:02:18.506 --> 07:02:23.110
我们说，我们要连接到这个URL。

4997
07:02:23.110 --> 07:02:23.617
太棒了。

4998
07:02:23.617 --> 07:02:29.173
这就是我们的脚本连接到区块链的方式，本地区块链。

4999
07:02:29.173 --> 07:02:31.217
现在让我们拿一个真正的钱包来。

5000
07:02:31.217 --> 07:02:38.039
有了私钥，余额和所有的东西，我们可以在甘纳许里看到我们所有的钱包和私钥。

5001
07:02:38.039 --> 07:02:40.846
建立这个的方法是使用const。

5002
07:02:40.846 --> 07:02:45.117
钱包等于新醚点钱包。

5003
07:02:45.117 --> 07:02:50.861
这个钱包函数有几个输入参数，比如私钥和提供者，

5004
07:02:50.861 --> 07:02:56.356
私钥会到Kenosha，只选择其中一个私钥。

5005
07:02:56.356 --> 07:02:58.562
我们将把这个直接粘贴到代码中。

5006
07:02:58.562 --> 07:03:01.945
然后我们会输入逗号provider并保存。

5007
07:03:01.945 --> 07:03:06.873
现在，直接将私钥粘贴到代码中是一个巨大的禁忌。

5008
07:03:06.873 --> 07:03:10.134
我们以后会学习如何避免这种情况。

5009
07:03:10.134 --> 07:03:17.591
现在还好，因为我们只是使用ganache私钥中的一个，你没有任何与这个账户相关的资金风险。

5010
07:03:17.591 --> 07:03:23.504
仅这两条线就为我们提供了与智能合约交互所需的一切，它们为我们提供了与区

5011
07:03:23.504 --> 07:03:29.586
块链的连接，并为我们提供了一个带私钥的钱包，以便我们可以签署不同的交易。

5012
07:03:29.586 --> 07:03:32.640
如果你还记得区块链基础部分的话。

5013
07:03:32.640 --> 07:03:37.815
这是我们用来签署所有交易的私钥，用来加密我们的交易。

5014
07:03:37.815 --> 07:03:44.456
现在我们有了提供者和钱包，让我们继续从这两个文件中获取契约对象。

5015
07:03:44.456 --> 07:03:52.629
为了部署我们的契约，我们需要ABI和契约的二进制编译代码。

5016
07:03:52.629 --> 07:03:58.991
我们需要从这两个文件中读取要从这两个文件中读取，我们需要使用一个叫Fs的包。

5017
07:03:58.991 --> 07:04:04.871
回到顶部，我们写入const f = require f，我

5018
07:04:04.871 --> 07:04:10.948
一直自动保存，你会看到，我做了些什么然后我的白点就会消失很多。

5019
07:04:10.948 --> 07:04:16.474
这是因为我的手指有一个习惯，每当我停止打字，我就保存，所以

5020
07:04:16.474 --> 07:04:22.192
请记住要尽早和经常保存，这个Fs额外应该直接与你的节点项目。

5021
07:04:22.254 --> 07:04:29.407
但如果没有，你总是可以用yarn添加它，额外添加Fs，你应该在我们的包。JSON中看到它。

5022
07:04:29.407 --> 07:04:36.785
现在我们可以得到ABI和二进制文件，我们可以说const, ABI = Fs。

5023
07:04:36.785 --> 07:04:45.111
read file sync，这意味着我们要同步地从这个文件中读取，我们可以异步地进行。

5024
07:04:45.111 --> 07:04:47.254
但是我们想等待这个文件完成。

5025
07:04:47.254 --> 07:04:48.520
我们说读取文件同步。

5026
07:04:48.520 --> 07:04:54.200
取决于你的VS代码，如果你滚动，你甚至可能会得到一些关于这个函数弹出的

5027
07:04:54.200 --> 07:05:00.044
信息，像这样，这非常有用，我们可以看到我们需要我们想要读取的文件的路径。

5028
07:05:00.044 --> 07:05:06.420
然后是任意选项，以及路径我们想要读取的文件在ABI中，位于。

5029
07:05:06.420 --> 07:05:12.584
/ simple storage，下划线下划线simple

5030
07:05:12.584 --> 07:05:19.387
storage。AVI然后我们要做一个逗号UT f8是UTF。

5031
07:05:19.387 --> 07:05:22.544
8是我们为这个文件所做的编码。

5032
07:05:22.544 --> 07:05:24.189
现在不要太担心这意味着什么。

5033
07:05:24.254 --> 07:05:25.754
所以我们需要ABI。

5034
07:05:29.255 --> 07:05:30.610
第二个文件。

5035
07:05:34.255 --> 07:05:35.608
简单的存储点bin。

5036
07:05:38.255 --> 07:05:39.683
点读文件同步。

5037
07:05:43.255 --> 07:05:48.613
这里是。/，simple storage soul,

5038
07:05:48.613 --> 07:05:56.032
simple storage。bin，然后是编码选项，它应该是这样的。

5039
07:05:56.032 --> 07:06:00.482
现在我们有了二进制文件，也有了ABI，我们可以创建一

5040
07:06:00.482 --> 07:06:05.105
个称为契约工厂的东西，不要将它与以太中的工厂模式混淆。

5041
07:06:05.105 --> 07:06:09.392
契约工厂只是一个可以用来部署契约的对象。

5042
07:06:09.392 --> 07:06:15.235
我们写入const，合约工

5043
07:06:15.235 --> 07:06:21.079
厂= new醚。合约工厂。

5044
07:06:21.255 --> 07:06:25.996
我们会传递它，API二进制。

5045
07:06:28.255 --> 07:06:37.053
通过ABI，这样我们的代码就知道如何与合约进行交互，显然，因为这是我们钱包里的主要编译代码，所以

5046
07:06:37.053 --> 07:06:46.036
我们有一个私钥，可以用来签署部署合约，然后我通常会写一些console。log，比如部署这些等待。

5047
07:06:46.036 --> 07:06:52.390
我们可以通过const将契约部署到醚。

5048
07:06:52.390 --> 07:06:59.570
合同等于等待，合同工厂点部署。

5049
07:06:59.570 --> 07:07:06.780
这是我们第一次看到await关键字，你只能在async函数中使用await关键字。

5050
07:07:06.780 --> 07:07:15.256
我们想要await关键字的原因是我们告诉代码在这里停止，等待契约部署。

5051
07:07:15.256 --> 07:07:19.974
这个await关键字意味着它将在这个契约工厂中解析承

5052
07:07:19.974 --> 07:07:24.874
诺契约。deploy中使用await返回一个契约对象。

5053
07:07:24.874 --> 07:07:28.732
现在我可以写console。log contract。

5054
07:07:28.732 --> 07:07:34.025
让我们看看运行这段代码时会发生什么，

5055
07:07:34.025 --> 07:07:39.319
我们向上滚动，看到正在部署，请稍等。

5056
07:07:39.319 --> 07:07:43.256
然后我们看到这个巨大的物体被打印出来。

5057
07:07:43.256 --> 07:07:45.890
这是我们刚刚部署的契约对象。

5058
07:07:45.890 --> 07:07:51.378
事实上，如果我们转到我们的ganache，我们可

5059
07:07:51.378 --> 07:07:56.867
以看到我们用于钱包的地址余额略少，交易计数为1。

5060
07:07:56.867 --> 07:08:03.306
如果我们用的是松露，我们就能看到这里的契约我们用的是安全帽，所以你看不到这里的契约。

5061
07:08:03.306 --> 07:08:08.193
但如果你去事务，我们确实能看到我们刚刚创建的事务。

5062
07:08:08.193 --> 07:08:09.917
这类似于以太扫描。

5063
07:08:09.917 --> 07:08:18.385
但对于本地区块链，我们能看到发送者地址，创建地址，价值，汽油价格，所有这些与合同相关的东西。

5064
07:08:18.385 --> 07:08:20.272
您还可以看到不同的块。

5065
07:08:20.272 --> 07:08:23.636
因为我们只进行了一次交易，只有一个区块被挖出。

5066
07:08:23.636 --> 07:08:24.588
这太棒了。

5067
07:08:24.588 --> 07:08:27.948
我们还有其他与之相关的东西。

5068
07:08:27.948 --> 07:08:28.717
伟大的工作。

5069
07:08:28.717 --> 07:08:34.729
您刚刚部署了一个契约到您自己的本地区块链与醚。

5070
07:08:34.729 --> 07:08:35.079
雅。

5071
07:08:35.256 --> 07:08:38.117
这太棒了，太棒了。

5072
07:08:41.256 --> 07:08:43.922
如果这里不使用await关键字。

5073
07:08:45.256 --> 07:08:46.056
我们的代码停止。

5074
07:08:48.257 --> 07:08:49.257
然后继续前进。

5075
07:08:51.257 --> 07:08:52.207
部署函数完成。

5076
07:08:53.257 --> 07:08:54.444
我们用这个代替。

5077
07:08:57.257 --> 07:09:04.774
这一承诺处于待定状态，因为我们的代码实际上是在契约完成部署之前完成的。

5078
07:09:04.774 --> 07:09:10.426
这里我们看到promise pending，这就是await关键字如此重要的原因。

5079
07:09:10.426 --> 07:09:16.394
我们说，嘿，等待这个完成await关键字也解决了一个承诺。

5080
07:09:16.394 --> 07:09:20.555
它会等待承诺退出，这是待定状态。

5081
07:09:20.555 --> 07:09:24.030
然后它会返回挂起承诺返回的东西。

5082
07:09:24.030 --> 07:09:29.663
因此合同工厂部署返回一个返回合同的承诺。

5083
07:09:29.663 --> 07:09:33.190
事实上，如果我们去查看ethers文档，我们会找到deploy。

5084
07:09:33.190 --> 07:09:37.944
这里我们可以看到合同工厂的方法。

5085
07:09:37.944 --> 07:09:45.293
如果我们看一下函数的定义，它说契约工厂。deploy有一大堆参数，

5086
07:09:45.293 --> 07:09:52.866
有些重写了这个箭头表示这是它返回的东西，它返回一个分解为契约的承诺。

5087
07:09:52.866 --> 07:09:59.190
这就是为什么我们需要await关键字因为合同工厂自己部署只是返回一个承诺。

5088
07:09:59.257 --> 07:10:05.973
但如果我们确实等待合同工厂点部署，我们说它返回一个承诺，该承诺解析为一个合同。

5089
07:10:05.973 --> 07:10:10.007
我们正在等待它完成部署以解析到契约对象。

5090
07:10:10.007 --> 07:10:12.157
这将是一个很大的不同。

5091
07:10:12.257 --> 07:10:12.847
很棒的工作。

5092
07:10:15.257 --> 07:10:15.722
重要的。

5093
07:10:18.257 --> 07:10:18.707
功能。

5094
07:10:21.257 --> 07:10:22.764
函数的名字。

5095
07:10:22.764 --> 07:10:24.164
很棒的工作。

5096
07:10:28.258 --> 07:10:28.639
巧克力酱。

5097
07:10:28.639 --> 07:10:30.002
肖恩，这太棒了。

5098
07:10:31.258 --> 07:10:32.054
再多一点。

5099
07:10:34.258 --> 07:10:37.612
在Metamask中，我们可以添加一大堆东西。

5100
07:10:38.258 --> 07:10:41.758
加上气体限制，我们就能在计算趋势时增加一些价值。

5101
07:10:41.758 --> 07:10:43.758
我们可以按下交易按钮。

5102
07:10:43.758 --> 07:10:50.185
我们知道，当我们使用Metamask时，我们想要在我们的账户之间转账，我们

5103
07:10:50.185 --> 07:10:56.786
可以选择汽油价格，我们的优先费，所有这些东西，我们实际上也可以在醚中做这些。

5104
07:10:56.786 --> 07:11:05.369
如果我们想等待合同工厂进行部署，但有一定的天然气价格，我们可以在部署函数中添加这些覆盖。

5105
07:11:05.369 --> 07:11:12.313
Visual Studio代码的另一个很巧妙的技巧是如果你点击命令或控制，这

5106
07:11:12.313 --> 07:11:19.258
取决于你的设置，你可以点击进入一个函数看它在哪里定义以及关于这个函数的一切。

5107
07:11:19.258 --> 07:11:27.008
如果我点击命令，我可以看到我现在在Node modules ethers project contract source of Ts，所有这些东西。

5108
07:11:27.008 --> 07:11:32.503
我可以准确地看到契约工厂对象上这个deploy函数的函

5109
07:11:32.503 --> 07:11:37.999
数定义，它向我们展示了与我们在文档中看到的相同的代码。

5110
07:11:37.999 --> 07:11:43.237
我们有一个deploy函数，它接受一些参数，然后它返回这

5111
07:11:43.237 --> 07:11:48.664
个小分号意味着它返回一个承诺，它分解为一个契约，这非常好。

5112
07:11:48.664 --> 07:11:53.991
这里的这些实际上是我们可以用括号指定的覆盖列表。

5113
07:11:53.991 --> 07:11:59.538
我们能做的是在deploy函数中加上括号指定一

5114
07:11:59.538 --> 07:12:05.086
些东西例如，我们可以指定天然气价格为某个数字。

5115
07:12:05.086 --> 07:12:11.339
现在如果我们要运行这个，我们会部署这个合约它的价格是这样的，我们

5116
07:12:11.339 --> 07:12:17.592
可以添加一个气体限制，我们可以在部署函数中添加一大堆不同的覆盖。

5117
07:12:17.592 --> 07:12:25.652
我们还能做什么?我们可以等待一定数量的块来完成我们的合同，所以我们已经部署了合同。

5118
07:12:25.652 --> 07:12:31.329
但也许我们想等一个区块以确保它真的连接到链上。

5119
07:12:31.329 --> 07:12:33.083
所以我们可以说const。

5120
07:12:33.259 --> 07:12:39.135
部署接收等于等待，契约点部署事务点等

5121
07:12:39.135 --> 07:12:45.339
待，并指定我们实际想等待的确认的数量。

5122
07:12:45.339 --> 07:12:49.433
所以我们将等待一个街区确认，以确保这发生了。

5123
07:12:49.433 --> 07:12:54.685
然后我们可以做console。log，这个部署收据选项。

5124
07:12:54.685 --> 07:13:02.538
如果我们现在运行代码,我们可以看到所有这些信息对我们的交易,我们可以清楚地看到

5125
07:13:02.538 --> 07:13:10.391
我们的交易是什么样子,我们可以看到有两个没有因为我们创建一个合同是这个巧克力酱

5126
07:13:10.391 --> 07:13:18.244
我们得到了私钥的地址,我们看到我们创建的合同地址交易指数,我们可以看到气体使用

5127
07:13:18.244 --> 07:13:26.097
气体使用事务日志块开花散列,我们可以看到所有这些信息对我们的交易,我想让你们注

5128
07:13:26.097 --> 07:13:34.153
意的是部署收据和部署事务，我想让你们把这两者分开，因为这会让你们的生活容易得多。

5129
07:13:34.153 --> 07:13:40.965
我们来做一个快速的console。log，这是部署事务。

5130
07:13:40.965 --> 07:13:48.679
然后是console。logcontract。deploy transaction。

5131
07:13:48.679 --> 07:13:54.075
然后我要复制这一行只需要输入Command C或Ctrl。

5132
07:13:54.075 --> 07:13:55.224
C在这里。

5133
07:13:55.224 --> 07:13:58.031
这是部署。

5134
07:13:58.031 --> 07:14:00.870
这是交易收据。

5135
07:14:00.870 --> 07:14:05.410
然后这个部署是收据是交易收据。

5136
07:14:05.410 --> 07:14:08.150
我将把它重命名为transaction receipt。

5137
07:14:08.150 --> 07:14:13.805
为了让它更清楚一点，哪个是哪个，我们再运行一遍。

5138
07:14:13.805 --> 07:14:19.193
当你等待区块确认时，你只会得到一张交易收据。

5139
07:14:19.260 --> 07:14:25.103
否则，你将得到契约对象，它带有部署事务，这个区别稍后将更加重要。

5140
07:14:25.103 --> 07:14:32.760
但我想让你们知道两种事务接收的区别是你在等待块确认时得到

5141
07:14:32.760 --> 07:14:40.417
的，部署事务或事务响应，事务响应是你在创建事务时得到的。

5142
07:14:40.417 --> 07:14:46.791
交易收据，交易响应，它们是不同的收据是你等待交易完成时得到的。

5143
07:14:46.791 --> 07:14:48.604
然后反应就是你最初得到的。

5144
07:14:48.604 --> 07:14:49.505
有意义吗?好了,好了。

5145
07:14:49.505 --> 07:14:51.373
我们要把这些删掉。

5146
07:14:51.373 --> 07:14:56.937
但这些行将在与GitHub相关的代码中。

5147
07:14:56.937 --> 07:15:04.138
当我们打印出这些收据时，所有这些都在这里，因为部署合约实际上就是

5148
07:15:04.138 --> 07:15:11.339
发送一个交易，就像我们之前说过的，如果我们想知道背后到底发生了什

5149
07:15:11.339 --> 07:15:18.993
么，我们可以自己创建一个交易通过指定交易信息，我们自己创建一个合约。

5150
07:15:18.993 --> 07:15:25.593
那么我们要怎么做呢?让我们再次部署这个契约，但只纯粹使用事务数据。

5151
07:15:25.593 --> 07:15:28.093
我们写一个console。log。

5152
07:15:28.261 --> 07:15:32.761
让我们只使用事务数据进行部署。

5153
07:15:34.261 --> 07:15:42.118
你可以部署或发送纯粹的事务数据，你可以发送任何事务，这给你无限的流量。

5154
07:15:42.118 --> 07:15:48.252
你想要发送的事务的能力，我们能做的是我们可以说const，或者

5155
07:15:48.252 --> 07:15:54.584
说是让TX代表我们的事务等于，我们可以把所有的事务信息加到这里。

5156
07:15:54.584 --> 07:15:59.485
首先我们需要的是我们的坚果，或者我们只使用一

5157
07:15:59.485 --> 07:16:04.386
次的数字回到我们的交易计数，这里有四笔交易。

5158
07:16:04.386 --> 07:16:08.448
所以我们要用现时5，因为这是一个我们以前没用过的现时。

5159
07:16:08.448 --> 07:16:12.761
每次您发送一个事务时，它都会附带其中一个nonces。

5160
07:16:12.761 --> 07:16:21.337
是的，nonce是一个被过度使用的术语，我们在区块链基础课程中看到过，我们用nonce来解决这个难题。

5161
07:16:21.337 --> 07:16:29.053
Nonces也被用在钱包和签名者中，用来发送交易，它们为每一笔交易使用不同的Nonces。

5162
07:16:29.053 --> 07:16:34.554
所以nonce，当我们谈论钱包时，我们谈论的是一个与唯一交易相关的数字。

5163
07:16:34.554 --> 07:16:41.244
当我们讨论区块链挖矿是用来解决这个困难问题的值时，它们的意思是一样的。

5164
07:16:41.244 --> 07:16:42.682
它们都表示只使用过一次的数字。

5165
07:16:42.682 --> 07:16:45.025
但是它们在不同的环境下是不同的。

5166
07:16:45.025 --> 07:16:52.294
所以我们要用这个号码只能使用一次这个独特的数量为一个事务发送,所以我

5167
07:16:52.294 --> 07:16:59.563
们会说现时标志是五个,我们将选择一个天然气价格,这里,我们将用巧克力

5168
07:16:59.563 --> 07:17:04.908
酱的天然气价格,我们要选择一个气体限制一些大数量,

5169
07:17:04.908 --> 07:17:14.745
我们将使用1123456,我们就使用我们会说两个是没有,对,就像我们看到在我们的收据和响应。

5170
07:17:14.745 --> 07:17:18.181
因为我们正在创建一个合约值将是零。

5171
07:17:18.181 --> 07:17:23.762
因为我们正在创建一个契约，我们不想发送一个以太多边形或雪崩。

5172
07:17:23.762 --> 07:17:29.706
然后数据就是二进制位中的大量二进制对象。

5173
07:17:29.706 --> 07:17:34.515
在二进制部分，我们要复制这一大块二进制，在这

5174
07:17:34.515 --> 07:17:39.325
里加一些引号，我们要写0x，然后粘贴到这里。

5175
07:17:39.325 --> 07:17:43.469
这个巨大的数据块就是我们发送的二进制数据。

5176
07:17:43.469 --> 07:17:50.724
当你发送事务时，你有这个数据对象你可以填充这个东西，我们用二进制代

5177
07:17:50.724 --> 07:17:58.200
码填充我们的数据对象它告诉区块链部署智能合约的理论它看起来就像这样。

5178
07:17:58.262 --> 07:18:02.175
最后，我们要加上链ID。

5179
07:18:02.262 --> 07:18:10.033
正如我们之前在Metamask看到的，如果我们回到我们的网络，每一个EVM链都有一个不同的链ID Etherium。

5180
07:18:10.033 --> 07:18:14.928
主网为一ropsten为三Rinke, B网为四COVID为42等。

5181
07:18:14.928 --> 07:18:21.481
其他的EVM链，比如avalanche和polygon，也会有它们唯一的链ID，

5182
07:18:21.481 --> 07:18:29.346
或者ganache，我们可以看到网络ID出现在一些人身上是1337，所以我们可以把它粘贴到这里。

5183
07:18:29.346 --> 07:18:33.976
有些人遇到了链ID和网络ID不同的问题。

5184
07:18:33.976 --> 07:18:36.753
链ID实际上是31337。

5185
07:18:36.753 --> 07:18:43.178
因此，如果您对此有问题，请尝试31337，但它应该是1337。

5186
07:18:43.262 --> 07:18:47.329
这是一个信息传播的交易，非常棒。

5187
07:18:47.329 --> 07:18:49.929
但是，这个事务没有签名。

5188
07:18:49.929 --> 07:18:55.782
现在没有人发送这个交易这只是某人想做的交易细

5189
07:18:55.782 --> 07:19:01.635
节，我们需要签署这个交易，然后发送到区块链。

5190
07:19:01.635 --> 07:19:07.322
Cons sign, TX response = await,

5191
07:19:07.322 --> 07:19:14.295
wallet。sign transaction，我们可以传递那个TX对象。

5192
07:19:14.295 --> 07:19:21.032
然后我们用JavaScript写一个console。log，记录sign TX的响应。

5193
07:19:21.032 --> 07:19:22.339
和固体一样。

5194
07:19:22.339 --> 07:19:27.463
如果你在一些代码之前输入两个反斜杠，它将不会运行该代码。

5195
07:19:27.463 --> 07:19:31.663
所以我要继续，注释掉上面的三行。

5196
07:19:31.663 --> 07:19:37.163
我这样做的方法是通过高亮部分然后按Command反斜杠，或者你也可以

5197
07:19:37.163 --> 07:19:42.663
按Ctrl反斜杠，但这是一个键盘快捷键你可以用它快速注释掉整个部分。

5198
07:19:42.663 --> 07:19:48.617
我这样做的原因是我想让你们看看当我们运行scientex响应

5199
07:19:48.617 --> 07:19:54.572
钱包签名交易回到nosh中会发生什么，我们看到这里有四个块。

5200
07:19:54.572 --> 07:19:59.077
我问一下，如果我们执行这个带符号事务并得到带符号事务响应，

5201
07:19:59.077 --> 07:20:03.739
我们会传播另一个块吗?我们来看看run no deploy。

5202
07:20:03.739 --> 07:20:06.437
Js，我们得到这个巨大的东西。

5203
07:20:06.437 --> 07:20:13.534
但如果回到ganache刷新，我们不会看到另一个事务发送。

5204
07:20:13.534 --> 07:20:18.816
这是因为我们只是在这里签署一个事务，并没有真正发送它。

5205
07:20:18.816 --> 07:20:20.908
签名事务响应。

5206
07:20:20.908 --> 07:20:27.772
这里的这个大数字表示的是签名事务，而不是分币事务，这是不同的。

5207
07:20:27.772 --> 07:20:32.326
你可以通过稍微改变这一行来发送一个事务。

5208
07:20:32.326 --> 07:20:39.406
我们把scientex response改成sendtx response =

5209
07:20:39.406 --> 07:20:47.756
await wallet。send transaction TX然后一旦我们在这里发送事务，

5210
07:20:47.756 --> 07:20:56.108
事务，我们可以做一个等待，发送事务响应，那个等待，一个，我们会等待一个块确认以确保事务实际通过。

5211
07:20:56.108 --> 07:20:57.832
我们可以运行node。

5212
07:20:57.832 --> 07:20:58.004
js。

5213
07:20:58.264 --> 07:20:59.591
看起来已经结束了。

5214
07:21:01.264 --> 07:21:02.914
这里有个错误。

5215
07:21:05.264 --> 07:21:05.576
在这里。

5216
07:21:10.264 --> 07:21:18.451
TX没有正确的螺母，这只是为了一些练习，让我们继续，把它输入谷歌，看看我们会得到什么。

5217
07:21:18.451 --> 07:21:25.535
我们实际上有一个四年前的三Jas的网，试图叫leaf chosen，等等，等等，等等，等等。

5218
07:21:25.535 --> 07:21:29.448
看起来这是他们遇到的元掩码问题。

5219
07:21:29.448 --> 07:21:33.174
他们说，你必须在元掩码中重置你的账户，我们可以这么做。

5220
07:21:33.174 --> 07:21:35.898
但让我们把它说得更具体一点。

5221
07:21:35.898 --> 07:21:37.247
比如说醚。

5222
07:21:37.247 --> 07:21:42.434
JS看起来我们没有。从这个记录来看，我们没有关于这个推车的Stack

5223
07:21:42.434 --> 07:21:48.538
Exchange eath或Stack Overflow的问题，因为这很简单。

5224
07:21:48.538 --> 07:21:50.539
我们的交易没有正确的时间。

5225
07:21:50.539 --> 07:21:57.895
但这是一个在Stack Overflow或Stack Exchange Aetherium上提出这个问题的好时机，这样它就会首先出现。

5226
07:21:57.895 --> 07:22:05.199
所以我们实际上没有得到正确的坚果，我们要让这个变成四个你可以看到这里account有一个四个，TX有一个五个。

5227
07:22:05.199 --> 07:22:07.756
所以我们希望这个是4。

5228
07:22:07.756 --> 07:22:14.976
一个更简单的方法总是得到正确的nonce实际上是调用钱包中的交易计数。

5229
07:22:14.976 --> 07:22:22.989
回到ethers文档，这里有一些很好的例子关于如何分配消息以及如何发送这些消息。

5230
07:22:22.989 --> 07:22:26.693
我们可以用权重钱包。获取交易计数来获取坚果。

5231
07:22:26.693 --> 07:22:31.955
回到代码中，我们可以写const尼尼= await，哦，复制粘贴，

5232
07:22:31.955 --> 07:22:37.537
await wallet。get transaction count。

5233
07:22:37.537 --> 07:22:40.155
然后我们可以把nonce放在这里。

5234
07:22:40.265 --> 07:22:42.580
现在，让我们再运行一次。

5235
07:22:44.265 --> 07:22:45.931
有一个确实通过了。

5236
07:22:45.931 --> 07:22:47.931
我们可以用甘纳许来验证。

5237
07:22:48.265 --> 07:22:52.144
确实看到了，我们现在在第5块，有一个额外的交易。

5238
07:22:52.144 --> 07:22:54.515
现在我们可以继续，再运行一次。

5239
07:22:54.515 --> 07:22:58.317
我们永远都不用担心自己更新这个nonce。

5240
07:22:58.317 --> 07:23:07.098
因为我们只是调用wallet。get transaction count来不断更新它，当前块是6，我们额外的事务确实经过了非常棒的过程。

5241
07:23:07.098 --> 07:23:09.788
我向你们展示了如何签署交易。

5242
07:23:09.788 --> 07:23:12.827
但我们没有签署中央注入的交易。

5243
07:23:12.827 --> 07:23:21.281
为什么不呢?如果你点击命令或控制点击，或者你去etherthers的文档，我们可以看到发送事务的代码。

5244
07:23:21.281 --> 07:23:23.428
首先，它做一些检查提供程序的事情。

5245
07:23:23.428 --> 07:23:24.968
有一些填充事务的东西。

5246
07:23:24.968 --> 07:23:30.407
但我们可以看到，在它发送事务之前，甚至在以太中，它先签

5247
07:23:30.407 --> 07:23:35.846
署事务，然后调用这个。provider。send事务。

5248
07:23:35.846 --> 07:23:44.717
如果你像这里一样调用带有事务细节的send transaction，这和先签名然后用提供者发送它是一样的。

5249
07:23:44.717 --> 07:23:45.396
好了,好了。

5250
07:23:45.396 --> 07:23:50.618
我们已经学习了如何使用纯JavaScript和纯醚发送事务。

5251
07:23:50.618 --> 07:23:57.314
这其中的一个主要收获的每次改变区块链,每次我们改变状态,每次我

5252
07:23:57.314 --> 07:24:04.010
们使用天然气,我们发送一个事务,看起来几乎一模一样,是区别的数

5253
07:24:04.010 --> 07:24:10.706
据,这些数据对我们说这是数据创建一个新合同,当我们做交易,比如

5254
07:24:10.706 --> 07:24:17.837
添加人或存储数据,我们将通过在我们的相关事务将是数据调用这些函数。

5255
07:24:17.837 --> 07:24:21.646
当我们在醚或Hardhead中调用函数时。

5256
07:24:21.646 --> 07:24:26.868
我们不会做这种原始const, TX，然后列出所有的东西就像这里列

5257
07:24:26.868 --> 07:24:32.250
出原始数据，对吧?因为这是非常非常难的醚和硬帽会让这个过程容易很多。

5258
07:24:32.250 --> 07:24:36.474
现在，我们继续，注释掉这整个部分，如果我们复制这整个，

5259
07:24:36.474 --> 07:24:43.516
然后点击Command，斜杠，或者control斜杠，或者其他快捷方式，这就会注释掉这个。

5260
07:24:43.516 --> 07:24:51.556
让我们继续，取消这一节的注释，这样我们就可以使用以太来部署我们的契约，这比这个奇怪的TX更容易阅读。

5261
07:24:51.556 --> 07:24:52.136
哦,很酷。

5262
07:24:52.266 --> 07:24:55.604
所以我们修改了脚本，像这样部署我们的契约。

5263
07:24:55.604 --> 07:25:02.051
现在我们已经部署了我们的契约，我们可以学习如何通过代码与我们的契约交互，

5264
07:25:02.051 --> 07:25:08.141
就像我们在remix中点击这些按钮一样，我们将在这里为自己编写代码。

5265
07:25:08.141 --> 07:25:13.045
如果我们看符号存储，我们有一个add person for store的按钮。

5266
07:25:13.045 --> 07:25:15.199
然后我们还有这些视图函数。

5267
07:25:15.199 --> 07:25:21.551
最简单的是检索函数，它获取喜爱的数字，检索返回喜爱的数字。

5268
07:25:21.551 --> 07:25:26.066
我们可以在醚类中通过const调用它。

5269
07:25:26.066 --> 07:25:30.999
当前最喜欢的数字等于等待。

5270
07:25:31.267 --> 07:25:32.109
合同。

5271
07:25:32.109 --> 07:25:33.266
我们检索。

5272
07:25:37.267 --> 07:25:45.167
从契约工厂返回的东西，只要我们等待它，契约对象就会附带API中描述的所有功能。

5273
07:25:45.167 --> 07:25:49.317
这就是为什么我们必须把API传递给我们的合同工厂。

5274
07:25:49.317 --> 07:25:54.594
如果我们看一下我们的API部分，我们可以看到它有很多信

5275
07:25:54.594 --> 07:26:00.067
息关于我们可以调用的不同函数以及它的类型和返回类型等等。

5276
07:26:00.067 --> 07:26:04.781
例如，如果我查检索，我可以看到下面这里，我们

5277
07:26:04.781 --> 07:26:09.496
有检索，我们可以看到这个函数的名字将被检索。

5278
07:26:09.496 --> 07:26:13.939
输出是un256，类型为Nuun 256。

5279
07:26:13.939 --> 07:26:17.567
这个有点难读，因为它没有格式化。

5280
07:26:17.567 --> 07:26:20.974
因为我们调用这个。API，它会有点难读。

5281
07:26:20.974 --> 07:26:22.912
但我们可以改成。JSON。

5282
07:26:22.912 --> 07:26:30.683
然后你会看到它被高亮了一点，我甚至可以用pretty来设置format document。

5283
07:26:30.683 --> 07:26:36.183
你会看到它的格式现在更容易阅读了，然后返回去检索。

5284
07:26:36.183 --> 07:26:42.530
我们可以看到，这段代码定义了Retrieve函数能做什么和不能做什么。

5285
07:26:42.530 --> 07:26:44.353
我要把它改成艾比。

5286
07:26:44.353 --> 07:26:47.314
看起来我的格式还在，这很好。

5287
07:26:47.314 --> 07:26:49.557
这比以前容易读多了。

5288
07:26:49.557 --> 07:26:55.060
正如我所说，ABI或应用程序二进制接口对于处理我们的契约非常重要。

5289
07:26:55.060 --> 07:27:00.146
如果我们的代码只是这么大的字节码，任何处理器

5290
07:27:00.146 --> 07:27:05.233
都很难反编译它或者理解这里的函数到底是什么。

5291
07:27:05.267 --> 07:27:10.302
有一些反编译器选项，比如以太VM, IO /反编译。

5292
07:27:10.302 --> 07:27:13.784
这可以将一些字节码反编译到实体中。

5293
07:27:13.784 --> 07:27:17.138
但是要做到完全正确是非常棘手的。

5294
07:27:17.268 --> 07:27:25.183
所以让ABI说，嘿，这一堆代码，这一堆数字和乱糟糟的废话就是这个，要容易得多。

5295
07:27:25.268 --> 07:27:32.203
当我们将这个字节码部署到区块链上，并在上面调用函数时，如果这些函数存在，代码将自动允许调用它们。

5296
07:27:32.203 --> 07:27:36.649
但是为了让我们的代码知道它们的存在，给它一个API要容易得多。

5297
07:27:36.649 --> 07:27:39.590
我们可以得到当前最喜欢的数字，像这样。

5298
07:27:39.590 --> 07:27:44.655
让我们继续，控制台。log，当前最喜欢的数字。

5299
07:27:44.655 --> 07:27:49.300
现在我们已经编辑了这段代码，我们将把它缩小一点。

5300
07:27:49.300 --> 07:27:55.280
现在我们已经编辑了这段代码，我们将连接organ nosh实例，我们将

5301
07:27:55.280 --> 07:28:01.260
连接一个钱包和我们从ganache顶部获得的私钥，我们将获取ABI和合

5302
07:28:01.260 --> 07:28:07.583
同的二进制文件，并将它们连接到一个新的合同工厂对象，该对象连接到那个钱包。

5303
07:28:07.583 --> 07:28:12.910
那个钱包将会是实际部署契约的那个，我们会用const contract = await

5304
07:28:12.910 --> 07:28:18.486
contract factory。deploy来部署契约，我们会等待一个区块让事务完成。

5305
07:28:18.486 --> 07:28:20.705
事实上，我们不打算使用交易收据。

5306
07:28:20.705 --> 07:28:23.767
现在，我们把这部分删掉。

5307
07:28:23.767 --> 07:28:25.895
我们不打算在这里做这些。

5308
07:28:25.895 --> 07:28:27.509
我先把它删掉。

5309
07:28:27.509 --> 07:28:30.220
不过，我将在GitHub回购中将这部分注释掉。

5310
07:28:30.220 --> 07:28:35.471
然后我们会调用契约检索它会返回当前最喜爱的数字。

5311
07:28:35.471 --> 07:28:39.996
因为这是一个视图函数，这个契约调用不会花费我们任何汽油。

5312
07:28:39.996 --> 07:28:45.106
如果我们看一下简单的存储，我们可以看到检索是一个视图函数。

5313
07:28:45.106 --> 07:28:51.384
记住，视图和纯函数，如果在契约函数外部调用不会消耗任何能量，我们只

5314
07:28:51.384 --> 07:28:57.853
是读取区块链，我们不会改变链上的任何变量，我们不会改变区块链的状态。

5315
07:28:57.853 --> 07:28:59.430
这样就不需要汽油了。

5316
07:28:59.430 --> 07:29:01.983
让我们继续运行这个。

5317
07:29:01.983 --> 07:29:05.697
太好了，我们要出动了，请稍等。

5318
07:29:05.697 --> 07:29:08.197
然后我们得到这个大数字的响应。

5319
07:29:08.197 --> 07:29:15.855
这个大数字的响应是什么?Big number是ethers应用程序附带的一个库，它帮助我们处理数字。

5320
07:29:15.855 --> 07:29:21.877
如果你向下滚动，他们甚至有一个部分说为什么我可以只用数字，你会期望当前最喜

5321
07:29:21.877 --> 07:29:28.062
欢的数字是0，但它返回这个奇怪的十六进制表示他的大数字为真这个奇怪的大数字。

5322
07:29:28.062 --> 07:29:32.935
所以固体性不能使用小数点，而JavaScript在小数点方面有困难。

5323
07:29:32.935 --> 07:29:39.538
这就是为什么不使用数字的更具体的理由，你会看到很多时候你会看到像0这

5324
07:29:39.538 --> 07:29:46.336
样的字符串，你会看到JavaScript使用这样的字符串，或者大数字。

5325
07:29:46.336 --> 07:29:53.031
现在，如果我试图在JavaScript中传递一个这样的数字，这个数字太大，JavaScript无法理解。

5326
07:29:53.031 --> 07:29:56.596
所以在处理醚的时候，我们想要使用大的数字或字符串。

5327
07:29:56.596 --> 07:29:59.050
现在我们可以通过添加使它更容易读。

5328
07:29:59.050 --> 07:30:04.075
到字符串的末尾，打印出这个大数字的字符串版本。

5329
07:30:04.075 --> 07:30:10.600
现在，如果我重新运行这段代码，我们可以看到我们得到0，这也是有道理的，因为

5330
07:30:10.600 --> 07:30:17.126
我们的喜爱的数字被初始化为0值，如果没有指定，而我们还没有调用store。

5331
07:30:17.126 --> 07:30:17.715
所以太棒了。

5332
07:30:17.715 --> 07:30:19.734
所以，这是非常完美的。

5333
07:30:19.734 --> 07:30:22.165
这就是我们目前最喜欢的数字。

5334
07:30:22.269 --> 07:30:25.220
让我们让这个console。log更符合语法。

5335
07:30:25.269 --> 07:30:28.069
我们将使用一种叫做字符串插值的方法。

5336
07:30:28.270 --> 07:30:31.536
我们可以用变量来插值字符串。

5337
07:30:32.270 --> 07:30:34.236
在JavaScript中处理字符串时，使用双引号。

5338
07:30:34.270 --> 07:30:40.673
但是，如果您想将变量与实际字符串混合使用，则可以使用反引号。

5339
07:30:40.673 --> 07:30:47.975
我们会在这里使用一些反勾，我们会在这里说要调用的当前最喜欢的号码。

5340
07:30:47.975 --> 07:30:56.650
为了告诉JavaScript这是一个我们想要读取的变量，我们在它周围加了一个美元符号和一个括号，像这样。

5341
07:30:56.650 --> 07:31:02.873
现在，如果我们再次运行这段代码，它会说，部署，请等待，我们得到当前最喜欢的数

5342
07:31:02.873 --> 07:31:09.096
字是0，因为JavaScript会说，好，这是一个字符串，美元符号，花括号看

5343
07:31:09.096 --> 07:31:15.320
起来像是某个变量或者JavaScript你想让我解释它然后关闭它，然后回勾。

5344
07:31:15.320 --> 07:31:15.658
酷。

5345
07:31:15.658 --> 07:31:17.703
所以我们现在最喜欢的数字是0。

5346
07:31:17.703 --> 07:31:17.903
太好了。

5347
07:31:17.903 --> 07:31:22.112
让我们通过调用store函数来更新契约的编号。

5348
07:31:22.112 --> 07:31:30.920
我们写入const，事务响应= await，契约。store，然后加上7。

5349
07:31:30.920 --> 07:31:34.650
因为7是一个很小的数字，你可以像7一样传递它。

5350
07:31:34.650 --> 07:31:37.555
但是像一个字符串中的7一样传递它也可以。

5351
07:31:37.555 --> 07:31:44.056
再说一次，这是因为如果我们想传递一个疯狂的大数字，JavaScript会很混乱。

5352
07:31:44.056 --> 07:31:50.413
所以通常最好的做法是将变量作为字符串传递给契约函数，尽管这可能会有点混乱。

5353
07:31:50.413 --> 07:31:56.943
醚足够聪明，知道第七个字符串实际上是7这个数字，然后我们可以使用const。

5354
07:31:56.943 --> 07:32:05.609
收到的事务等于等待事务响应，即等待，1。

5355
07:32:05.609 --> 07:32:08.558
我们在这里等一个街区。

5356
07:32:08.558 --> 07:32:16.406
这类似于契约。部署。事务。等等，这里的语法和上面的有点不同。

5357
07:32:16.406 --> 07:32:17.795
因为这是使用代工厂。

5358
07:32:17.795 --> 07:32:20.686
这是在契约上调用一个函数。

5359
07:32:20.686 --> 07:32:24.849
因此，当我们调用契约上的函数时，我们得到一个事务响应。

5360
07:32:24.849 --> 07:32:28.908
当我们等待事务响应完成时，我们将获得事务收据。

5361
07:32:28.908 --> 07:32:37.271
现在我可以用const, updated, favorites 2 = await on track。retrieve。

5362
07:32:37.271 --> 07:32:40.886
然后是console。log updated。

5363
07:32:40.886 --> 07:32:46.669
最喜欢的数字是，我们会做一点字符串插值，更新，

5364
07:32:46.669 --> 07:32:52.202
最喜欢的数字是这样的?现在让我们继续运行它。

5365
07:32:52.202 --> 07:32:57.381
在这个过程中，我们会部署合约，获取初始值，我

5366
07:32:57.381 --> 07:33:02.561
们会调用store来更新合约这将消耗gas。

5367
07:33:02.561 --> 07:33:10.324
这是一个交易，我们会得到交易响应，然后我们会得到交易收据，我们不会对交易收据做

5368
07:33:10.324 --> 07:33:18.287
任何事情，我想让你们知道这两个是不同的交易响应和交易收据，你们以后会明白为什么。

5369
07:33:18.287 --> 07:33:21.754
然后我们会得到更新后的收藏夹号码，然后我们会把它打印出来。

5370
07:33:21.754 --> 07:33:23.124
我们来做这个。

5371
07:33:23.124 --> 07:33:24.575
嘣，完美。

5372
07:33:24.575 --> 07:33:30.554
正在部署中，请稍候，当前收藏编号为0，更新收藏编号为7。

5373
07:33:30.554 --> 07:33:37.869
到ganache实例，到交易，可以看到，顶部有合约调用，

5374
07:33:37.869 --> 07:33:45.969
有sender，合约地址，汽油价格，所有这些，交易数据在这里。

5375
07:33:45.969 --> 07:33:50.714
这个事务数据是在事务对象的数据槽中发送的。

5376
07:33:50.714 --> 07:33:56.951
乙醚只是在后端为我们做这些所以我们不需要在那里创建大的事务对象。

5377
07:33:56.951 --> 07:33:58.026
好吧，太棒了。

5378
07:33:58.026 --> 07:34:02.779
您已经成功地将契约部署到自己的本地ganac

5379
07:34:02.779 --> 07:34:07.532
he实例或自己的JavaScript虚拟机。

5380
07:34:07.532 --> 07:34:09.053
这太棒了。

5381
07:34:09.272 --> 07:34:10.933
现在我们把它整理一下。

5382
07:34:12.272 --> 07:34:18.917
我们有我们的连接区块链和我们的私钥直接存储在我们的代码中，我们将这段代

5383
07:34:18.917 --> 07:34:25.562
码推到GitHub或其他一些代码库，如果你愿意，将能够看到我们的代码。

5384
07:34:25.562 --> 07:34:33.126
如果我们查看我代码的ploy。js，这里还有别的东西，我们实际上没有看到私钥或RPC URL。

5385
07:34:33.126 --> 07:34:38.644
这是怎么回事?记住，如果你泄露了你的私钥，谁有你的私钥谁就拥有你的资金。

5386
07:34:38.644 --> 07:34:43.852
即使这是一个假的私钥，里面没有真正的钱，我们还是不想硬

5387
07:34:43.852 --> 07:34:49.061
编码我们的私钥到代码中，以防我们不小心和别人共享代码。

5388
07:34:49.061 --> 07:34:55.647
那么我们能做什么呢?其中一个最流行的方法是创建一个叫做。EMV文件或环境变量的东西。

5389
07:34:55.647 --> 07:35:02.367
如果你熟悉环境变量，你可以在终端中设置它们，但我们会在。env中设置它们。

5390
07:35:02.367 --> 07:35:05.698
你要做的是创建一个。env文件。

5391
07:35:05.698 --> 07:35:09.322
这是一个你储存敏感信息的文件。

5392
07:35:09.322 --> 07:35:12.990
这将是一份文件，我们永远不会和任何人分享。

5393
07:35:12.990 --> 07:35:18.072
这个点env文件将把我们选择的变量插入到代码的环境中。

5394
07:35:18.072 --> 07:35:21.780
举个例子，如果我把终端拉上来，

5395
07:35:21.780 --> 07:35:28.457
然后输入echo cat，这将反映cat环境变量的值。

5396
07:35:28.457 --> 07:35:31.273
现在还没有猫的环境变量。

5397
07:35:31.273 --> 07:35:36.611
然而，如果我输入export, cat = dog，然后

5398
07:35:36.611 --> 07:35:41.950
我输入echo $ sign cat，我得到dog输出。

5399
07:35:41.950 --> 07:35:47.011
这就是环境变量，它是终端或脚本环境中的变量，

5400
07:35:47.011 --> 07:35:57.595
因为我不想输入export，私钥等于等等，每次，我们要做的是将它们插入到这个。env文件中。

5401
07:35:57.595 --> 07:36:02.073
当这个。env，我们可以输入私钥等于。

5402
07:36:02.073 --> 07:36:07.813
我们可以从脚本中获取这个私钥，像这样粘贴进来。

5403
07:36:07.813 --> 07:36:14.196
注意，有些工具会在私钥醚的开头查找0x，而硬帽足够聪明，两者都可

5404
07:36:14.196 --> 07:36:20.580
以，但如果你遇到了一些问题，要知道有时你可能需要把0x放在前面。

5405
07:36:20.580 --> 07:36:20.856
太好了。

5406
07:36:20.856 --> 07:36:22.873
现在我们在环境变量中有一个私钥。

5407
07:36:22.873 --> 07:36:25.382
我们现在怎么办?在我们的部署中。

5408
07:36:25.382 --> 07:36:33.606
Js，我们想抓取这个环境变量并把它插入到我们的脚本中，这样我们的脚本就能把它插入到我们的环境中。

5409
07:36:33.606 --> 07:36:35.885
我们要添加一个叫做。env的工具。

5410
07:36:35.885 --> 07:36:40.148
为了让它更简单，我们将使用yarn，添加。env。

5411
07:36:40.148 --> 07:36:47.220
如果我们看一下。env包，可以阅读更多关于它的内容，以及如何用NPM添加它。

5412
07:36:47.273 --> 07:36:49.442
同样，我们只是使用纱线添加。

5413
07:36:51.273 --> 07:36:53.083
这需要点E和V的点配置。

5414
07:36:54.273 --> 07:36:56.862
所有的环境变量。

5415
07:36:59.273 --> 07:37:04.527
点EMV配置，我们应该在我们的包中看到JSON，我们看到。

5416
07:37:04.527 --> 07:37:05.035
太好了。

5417
07:37:05.035 --> 07:37:09.149
现在我们把它拉进来了，我们实际上可以访问私钥环境变量，

5418
07:37:09.149 --> 07:37:14.636
你可以在JavaScript中访问环境变量，使用process。EMV。

5419
07:37:14.636 --> 07:37:21.309
我们不把私钥放在这里，而是把整个都删掉用process。EMV

5420
07:37:21.309 --> 07:37:27.982
替换私钥，然后保存，它会重新格式化以确保它能正常工作，我们可以

5421
07:37:27.982 --> 07:37:35.086
在保存后点击，往上往上往上，回到no deploy to Jas。

5422
07:37:35.086 --> 07:37:37.523
我们看到我们得到了完全相同的设置。

5423
07:37:37.523 --> 07:37:41.515
如果我们回滚，你可以看到一个交易确实进行了。

5424
07:37:41.515 --> 07:37:47.963
如果你想再次检查这是否打印出了你的私钥，我们可以执行console。

5425
07:37:47.963 --> 07:37:54.601
log，按study通过运行私钥，我们可以看到私钥确实来自于环境变量。

5426
07:37:54.601 --> 07:37:55.256
太棒了。

5427
07:37:55.256 --> 07:38:00.533
我们的RPC URL并不是我们需要保护的东西，也许我们

5428
07:38:00.533 --> 07:38:06.007
会使用一个特定的API键或者一个只有我们想要访问的端点。

5429
07:38:06.007 --> 07:38:08.627
我们不希望任何人使用我们的RPC端点。

5430
07:38:08.627 --> 07:38:12.197
我们也要把这个添加到。env文件中。

5431
07:38:12.197 --> 07:38:13.581
在。env中。

5432
07:38:13.581 --> 07:38:22.177
复制这个时，我要说RPC URL =，然后粘贴到这里，就像这样。

5433
07:38:22.274 --> 07:38:23.580
我们把这里删掉。

5434
07:38:25.274 --> 07:38:28.369
例如，process。env。RPC URL。

5435
07:38:30.274 --> 07:38:30.940
再运行一次。

5436
07:38:33.274 --> 07:38:37.886
我们应该得到完全相同的响应，因为我们所做的只是用

5437
07:38:37.886 --> 07:38:42.499
环境变量替换RPC URL，这将与之前完全相同。

5438
07:38:42.499 --> 07:38:45.379
所以我们继续运行这个，我们得到了完全相同的响应。

5439
07:38:45.379 --> 07:38:51.460
如果我们去ganache，我们看到我们确实得到了一个交易，这是完美的。

5440
07:38:51.460 --> 07:38:52.052
太棒了。

5441
07:38:52.052 --> 07:38:56.878
我们已经学习了如何向点环境文件中添加环境变量。

5442
07:38:56.878 --> 07:39:05.791
以防万一，我们想要共享我们的代码，或者我们把我们的代码推到GitHub，我们会在后面的章节中做，我们不会意外地暴露我们的私钥或RPC url。

5443
07:39:05.791 --> 07:39:10.694
现在我们项目中的所有代码，如果我们把它推到GitHub，或者和别人

5444
07:39:10.694 --> 07:39:15.597
共享，所有这些代码都会被推到GitHub，包括我们的。env文件。

5445
07:39:15.597 --> 07:39:22.493
但是，如果你看一下我这门课的代码示例，你会发现这里没有。env文件。

5446
07:39:22.493 --> 07:39:30.190
这怎么可能呢?无论什么项目，我们都要创建一个。gitignore文件。

5447
07:39:30.275 --> 07:39:32.408
在这里，我们要代入v。

5448
07:39:34.275 --> 07:39:35.147
节点模块。

5449
07:39:38.275 --> 07:39:43.758
使用版本控制，这我们稍后会做，我们不会把。env文件推送到GitHub。

5450
07:39:43.758 --> 07:39:45.989
我们也不会推入已知的模块。

5451
07:39:45.989 --> 07:39:51.483
如果我们回到我的例子，我们没有看到。env文件，但是我们看

5452
07:39:51.483 --> 07:39:56.978
到了一个。env。的例子，只是给你们展示一下它是什么样的。

5453
07:39:56.978 --> 07:40:01.118
所以我把它们放在这里并不重要。

5454
07:40:01.275 --> 07:40:05.681
现在，如果您非常偏执，那么在运行脚本和运行命令时，实际上还可以做一些其他事情。

5455
07:40:05.681 --> 07:40:12.560
假设您不想将私钥放入。env文件中，因为您担心会不小心将其推到上面。

5456
07:40:12.560 --> 07:40:18.647
您所能做的就是在RPC URL中添加您的私钥，作为命令行中的环境变量。

5457
07:40:18.647 --> 07:40:27.608
在运行Node deploy之前，你也可以这么做，你可以说RPC URL =，粘贴你的RPC。

5458
07:40:27.608 --> 07:40:31.275
然后你可以说私钥。

5459
07:40:31.275 --> 07:40:36.937
等于，然后粘贴您的私钥，然后执行节点部署。

5460
07:40:36.937 --> 07:40:37.106
js。

5461
07:40:37.276 --> 07:40:41.921
在运行脚本之前设置它们与在。env中设置它们完全相同。

5462
07:40:41.921 --> 07:40:48.294
如果我们点击run，我们会看到完全相同的输出，这意味着我们的RPC URL和私钥成功通过。

5463
07:40:48.294 --> 07:40:50.176
对于密钥管理来说，这种方式很好。

5464
07:40:50.176 --> 07:40:52.964
但我们这样做的权利，会更好。

5465
07:40:52.964 --> 07:40:58.969
但这还是让我有点紧张在我们的开发环境中用假私钥，把代码放在这样的。env

5466
07:40:58.969 --> 07:41:04.974
文件中是可以的，对吧?因为我们不在乎这把钥匙是否被黑，就像没人用它一样。

5467
07:41:04.974 --> 07:41:08.663
但当我们搬到一个更专业的环境时，这可能会有点可怕。

5468
07:41:08.663 --> 07:41:17.226
那么，我们怎样才能使它更加安全呢?我们能做的是加密私钥并将加密密钥存储在本地。

5469
07:41:17.276 --> 07:41:24.259
这样的话，如果有人因为某种原因进入了我们的账户，我们的私钥就不会以纯文本的形式存在，而是被加密了。

5470
07:41:24.259 --> 07:41:27.568
你需要知道一个只有你知道的密码才能进入。

5471
07:41:27.568 --> 07:41:34.854
怎么加呢?首先，我们要创建一个名为encrypt key的新文件。

5472
07:41:34.854 --> 07:41:35.072
js。

5473
07:41:35.072 --> 07:41:39.228
这是一些我们将要用来加密密钥的代码。

5474
07:41:39.276 --> 07:41:41.977
我们会将它存储在本地而不是纯文本形式的私钥。

5475
07:41:41.977 --> 07:41:47.479
这将使我们更加安全，这样私钥就不会以纯文本的形式挂在这里。

5476
07:41:47.479 --> 07:41:50.636
因此，让我们继续构建脚本来加密我们的私钥。

5477
07:41:50.636 --> 07:41:53.485
因此，我们将使用与部署脚本完全相同的设置。

5478
07:41:53.485 --> 07:41:56.876
我们要做一个async函数main。

5479
07:41:57.276 --> 07:42:00.050
然后在下面这里，我将继续复制部署js。

5480
07:42:00.050 --> 07:42:03.405
我们将使用完全相同的设置，并粘贴它。

5481
07:42:03.405 --> 07:42:04.179
好了,好了。

5482
07:42:04.179 --> 07:42:07.799
我们要用醚J s r点乘E V。

5483
07:42:07.799 --> 07:42:12.859
所以我们要把这些加到const ethers = require

5484
07:42:12.859 --> 07:42:18.552
ethers const FS = require FS extra。

5485
07:42:18.552 --> 07:42:22.221
然后require。env。

5486
07:42:22.221 --> 07:42:23.128
配置。

5487
07:42:23.128 --> 07:42:29.047
现在，在。env中，我们有这个私钥。

5488
07:42:29.047 --> 07:42:37.324
如果你不想以他们的方式获得私钥你可以这样做你可以输入私钥等于然后你知道，节点，任何你想运行的脚本。

5489
07:42:37.324 --> 07:42:41.277
我们将设置这个脚本来运行加密密钥一次。

5490
07:42:41.277 --> 07:42:46.975
然后我们可以从工作区的任何地方删除私钥这样它就不再是纯文本了。

5491
07:42:46.975 --> 07:42:54.358
我们想做的是我们想说const wallet，我们会创建一个新的wallet，但有一点不同。

5492
07:42:54.358 --> 07:43:01.131
我们写入= new醚。钱包，进程。E和V。私钥。

5493
07:43:01.131 --> 07:43:04.725
这里需要私钥。

5494
07:43:04.725 --> 07:43:10.018
但一旦我们创建了这个钱包，我们会说const。

5495
07:43:10.018 --> 07:43:17.111
Encrypted JSON key = await ethers。encrypt，

5496
07:43:17.111 --> 07:43:25.218
这个encrypt函数会返回一个加密的JSON key我们可以在本地存储它我们只能用密码解密它。

5497
07:43:25.218 --> 07:43:26.922
它有两个参数。

5498
07:43:26.922 --> 07:43:30.147
它需要一个私钥密码和一个私钥。

5499
07:43:30.277 --> 07:43:35.023
在。EMV中，我们要创建一个私钥密码。

5500
07:43:35.023 --> 07:43:37.800
我要说这是密码。

5501
07:43:37.800 --> 07:43:39.543
但显然，这是一个糟糕的密码。

5502
07:43:39.543 --> 07:43:41.657
你不应该用密码作为你的密码。

5503
07:43:41.657 --> 07:43:46.229
但现在，我们还是把它作为密码吧因为我要加密这个大密钥。

5504
07:43:46.277 --> 07:43:51.760
我们将通过密码过程研究和v点私钥密码来加密它。

5505
07:43:51.760 --> 07:43:57.851
我们还会传递私钥，它是ethers，它是wallet。encrypt。

5506
07:43:57.851 --> 07:44:01.920
我们还会传递process。EMV。private key。

5507
07:44:01.920 --> 07:44:04.998
现在让我们继续运行它。

5508
07:44:04.998 --> 07:44:11.833
然后我们用console。log注销这个加密的JSON键看看运行时会发生什么。

5509
07:44:11.833 --> 07:44:15.435
要运行这个，我们要执行，node, encrypt key。

5510
07:44:15.435 --> 07:44:15.575
js。

5511
07:44:15.575 --> 07:44:16.545
然后回车。

5512
07:44:16.545 --> 07:44:23.932
我们会看到控制台注销后会发生什么这个JSON对象是密钥加密后的样子。

5513
07:44:23.932 --> 07:44:28.362
它有地址这个ID版本，所有这些东西。

5514
07:44:28.362 --> 07:44:32.182
所有这些都是这个密钥的加密版本。

5515
07:44:32.182 --> 07:44:37.541
如果有人进入我们的账户看到了这个，他们需要知道密码来解密这

5516
07:44:37.541 --> 07:44:42.900
个私钥，他们需要知道密码来解密这个JSON对象到一个私钥。

5517
07:44:42.900 --> 07:44:47.084
现在我们要做的是，我们已经加密了，我们要保存它。

5518
07:44:47.084 --> 07:44:51.952
我们会写Fs。write，文件同步，我们会传递给。/。

5519
07:44:51.952 --> 07:44:59.166
encrypted key。JSON，逗号encrypted JSON key。

5520
07:44:59.278 --> 07:45:02.528
我们将它保存到一个新文件名为。encrypted key。JSON。

5521
07:45:02.528 --> 07:45:06.153
然后传递给它我们刚做的加密密钥。

5522
07:45:06.278 --> 07:45:10.911
如果我们打开文件资源管理器，运行这个命令，你会看到我们得

5523
07:45:10.911 --> 07:45:15.544
到一个新文件叫做。encrypted key。JSON。

5524
07:45:15.544 --> 07:45:18.944
就是这个加密密钥，太棒了。

5525
07:45:18.944 --> 07:45:22.601
现在我们要在。gitignore中做的是add。

5526
07:45:22.601 --> 07:45:28.850
encrypted key。JSON，这样我们就不会不小心把这个推到GitHub。

5527
07:45:28.850 --> 07:45:34.754
现在我们有了加密密钥我们可以从。env文件中删除私钥。

5528
07:45:34.754 --> 07:45:41.244
我们还可以从WMV文件中删除私钥密码，这样密码就不会以纯文本的形式存在。

5529
07:45:41.279 --> 07:45:43.442
既然我们有加密的密钥。

5530
07:45:45.279 --> 07:45:48.569
我们可以改变我们实际获得钱包的方式。

5531
07:45:49.279 --> 07:45:56.691
Top，我们通过这样传递私钥来获取钱包，我们不会这样做，我们会使用我们刚创建的加密密钥。

5532
07:45:56.691 --> 07:46:05.379
我们要做的是写入const encrypted JSON = Fs。read file sync。

5533
07:46:05.379 --> 07:46:12.488
这个斜杠。encrypted key。JSON，逗号utf8，这个Fs。

5534
07:46:12.488 --> 07:46:20.586
read file sync将从加密的key。JSON读取到加密的JSON变量中。

5535
07:46:20.586 --> 07:46:25.517
接下来，我们将用这个加密的密钥创建一个钱包。

5536
07:46:25.517 --> 07:46:29.589
我们写入，let wallet = new醚。

5537
07:46:29.589 --> 07:46:35.079
wallet。fromencrypted JSON sync。

5538
07:46:35.079 --> 07:46:41.798
所有这些与醚相关的命令，我们都能在加密的JSON同步文档中找

5539
07:46:41.798 --> 07:46:48.517
到它们同步获取加密的JSON和一个密码，并返回一个钱包对象。

5540
07:46:48.517 --> 07:46:52.589
我们将把刚读过的加密JSON传递给它。

5541
07:46:52.589 --> 07:47:00.769
然后我们要传递它password我们要做的是process。EMP。private key password。

5542
07:47:00.769 --> 07:47:07.725
最后，这里用let的原因是我们需要将这个钱包连接回提供者。

5543
07:47:07.725 --> 07:47:10.625
如果你看这里，我们并没有将钱包与供应商连接。

5544
07:47:10.625 --> 07:47:16.422
当我们与合同工厂进行交易时，我们需要确保钱包知道这里的提供者。

5545
07:47:16.422 --> 07:47:22.946
我们可以说，wallet = await wallet。connect provider。

5546
07:47:22.946 --> 07:47:30.555
现在，如果我们使用私钥密码作为环境变量运行deploy. j s，它仍然应该部署。

5547
07:47:30.555 --> 07:47:34.787
私钥密码=密码，这很糟糕。

5548
07:47:34.787 --> 07:47:42.394
这就是我们现在使用的，node deploy。js，我们得到的输出应该和我们一直

5549
07:47:42.394 --> 07:47:50.002
以来看到的一样我们不再把私钥放在。env文件中不再是明文形式，而是这个加密密钥。

5550
07:47:50.002 --> 07:47:56.683
以防有人入侵我们的电脑，除非他们知道密码，否则他们仍然无法发送新的交易。

5551
07:47:56.683 --> 07:47:57.457
这太棒了。

5552
07:47:57.457 --> 07:48:02.441
还有一件事要知道，如果你输入历史，如果有人进入了你的

5553
07:48:02.441 --> 07:48:07.618
电脑，黑客会在你的bash历史中看到私钥密码等于密码。

5554
07:48:07.618 --> 07:48:12.565
如果你运行历史，破折号c，你会清除历史。

5555
07:48:12.565 --> 07:48:20.589
现在如果我输入history，我只能看到我最近写的命令是history，这真的只是加密和保护密钥安全的最基本的一些。

5556
07:48:20.589 --> 07:48:25.873
有人能黑进你的电脑，读取你的加密私钥，这似乎很荒谬。

5557
07:48:25.873 --> 07:48:32.287
但随着项目越来越大，了解私钥安全性和私钥安全性非常重要，

5558
07:48:32.287 --> 07:48:38.473
这门课只讲最基本的内容告诉大家如何加密密钥如何更安全。

5559
07:48:38.473 --> 07:48:46.192
在接下来的课程中，我们将只使用这种语法和。env文件中的私钥。

5560
07:48:46.280 --> 07:48:49.496
在接下来的课程中我们这样做的原因是它更简单，

5561
07:48:49.496 --> 07:48:55.346
我真的希望Hardhead增加一些额外的特性使私钥加密更安全也更容易在未来使用。

5562
07:48:55.346 --> 07:48:56.412
他们很可能会。

5563
07:48:56.412 --> 07:49:02.665
我们可以这么做的另一个原因是你们已经郑重宣誓过在这门课期间你们不会使用一个有任何真钱的账户，

5564
07:49:02.665 --> 07:49:09.055
你们只会使用在Aetherium上有测试的私钥或者像我们从ganache那里得到的这个假私钥。

5565
07:49:09.055 --> 07:49:15.519
事实上，我只是想在智能合约工具中进一步完善这个，在solidity课程中完全阻塞，Jas

5566
07:49:15.519 --> 07:49:22.131
GitHub repo在讨论选项卡中，你去到公告，我创建了一个叫。end pledge。

5567
07:49:22.131 --> 07:49:29.246
因为最近我看到太多的人跟随一个教程，而这个教程并没有告诉他们这样做的安全风险。

5568
07:49:29.246 --> 07:49:33.229
我已经做了这个。EMV的承诺，我希望每个人都能跳上去阅读。

5569
07:49:33.281 --> 07:49:37.749
如果你同意，在下面留下评论，说我会很安全的，我

5570
07:49:37.749 --> 07:49:42.412
会很安全的，确保你阅读了，你明白这里发生了什么。

5571
07:49:42.412 --> 07:49:44.182
我这么做不是为了吓你。

5572
07:49:44.281 --> 07:49:52.979
因为，在一天结束的时候，如果你使用Metamask，它只包含在这门课程期间资助的测试，你永远都不用担心你的密钥被泄露。

5573
07:49:52.979 --> 07:49:54.121
只是测试一下。

5574
07:49:54.121 --> 07:49:59.156
谁在乎呢?如果你使用的是元掩码或者你使用的是有资金的元掩码。

5575
07:49:59.156 --> 07:50:03.055
所以我要读一下誓言，因为它真的很重要。

5576
07:50:03.055 --> 07:50:05.603
当你和真正的基金打交道时，你就会明白这一点。

5577
07:50:05.603 --> 07:50:10.625
如果你说，嘿，我没有和真正的基金合作，我不在乎，很好，不管怎样。

5578
07:50:10.625 --> 07:50:16.471
但是当你用真正的资金工作时，当你决定，嘿，我真的想把它部署到一个真正的网络上。

5579
07:50:16.471 --> 07:50:18.330
现在我需要真钱。

5580
07:50:18.330 --> 07:50:19.969
回到这个誓言上来。

5581
07:50:19.969 --> 07:50:24.531
滚动底部，说我将是安全的，并确保你阅读和理解这一点。

5582
07:50:24.531 --> 07:50:29.755
好吧，我的承诺是，我郑重发誓我绝不会在任何与真正

5583
07:50:29.755 --> 07:50:35.197
资金有关的。env文件中放入私钥或秘密短语或肺炎。

5584
07:50:35.197 --> 07:50:41.282
基本上，你基本上不会有你的私钥或你的肺炎短语，以纯文本的形式，在任何地方。

5585
07:50:41.282 --> 07:50:49.068
你们都只将私钥放在一个只测试过FF链接或其他加密货币的web文件中。

5586
07:50:49.068 --> 07:50:53.082
因为如果你的私钥只有测试净资金，那就太好了。

5587
07:50:53.082 --> 07:51:00.377
我不在乎，我们知道如果我们忘记了一个。Git忽略，我们把我们的关键短语推到GitHub，即使

5588
07:51:00.377 --> 07:51:07.832
是一秒钟，或者甚至在互联网上显示我们的关键斜杠短语，无论它可能在一秒钟，它应该被认为是折衷的。

5589
07:51:07.832 --> 07:51:10.340
你应该立即取出所有资金。

5590
07:51:10.340 --> 07:51:16.046
所以即使你部署了你的私钥到一个网站，然后立即删除你的网站，你会想，哦，

5591
07:51:16.046 --> 07:51:21.427
可能没有人访问过它，你应该认为私钥泄露了，你应该删除你所有的资金。

5592
07:51:21.427 --> 07:51:23.467
再说一次，这只是针对真正的基金。

5593
07:51:23.467 --> 07:51:25.832
如果只测试了您的私钥，资金就会受到损害。

5594
07:51:25.832 --> 07:51:30.832
谁在乎呢?我一直这么做，你们一直看到我这么做，因为它只包含测试基金。

5595
07:51:30.832 --> 07:51:37.413
如果在这门课结束的时候，你想偷走我所有的测试资金，我的意思是，尽情享受吧，这对我来说最坏的情况是很烦人的。

5596
07:51:37.413 --> 07:51:42.560
如果我不确定我的账户里是否有真正的资金，我会假设它有真正的资金。

5597
07:51:42.560 --> 07:51:47.904
所以如果你不知道它是否有真正的资金，假设它有真正的资金，你就不会把它用于开发目的。

5598
07:51:47.904 --> 07:51:55.229
最后，我意识到，即使我点击添加帐户在我的元掩码或其他eath钱包，我将得到一个新的私钥，但它将

5599
07:51:55.229 --> 07:52:02.710
共享相同的秘密短语slash pneumonic在元掩码或其他eath钱包中生成的所有其他帐户。

5600
07:52:02.710 --> 07:52:09.734
如果我在元掩码中，点击创建账户，我会得到新账户的新私钥。

5601
07:52:09.734 --> 07:52:17.267
然而，我用“创建帐户”按钮创建的所有这些帐户都有完全相同的肺炎短语或秘密短语。

5602
07:52:17.267 --> 07:52:21.731
如果我导入一个有私钥的账户，它会有一个不同的肺炎短语。

5603
07:52:21.731 --> 07:52:25.861
但是我在钱包里生成的所有的都有相同的短语。

5604
07:52:25.861 --> 07:52:26.492
好了,好了。

5605
07:52:26.492 --> 07:52:28.018
希望这讲得通。

5606
07:52:28.018 --> 07:52:29.713
我这里有一些附加的承诺。

5607
07:52:29.713 --> 07:52:35.266
对于这个过程，我只会使用资金与一个全新的从未使用过元掩码或其他eath钱包。

5608
07:52:35.266 --> 07:52:40.161
再次强调，这并不是要吓到你，如果你只是使用一个全新的元掩码，你不

5609
07:52:40.161 --> 07:52:45.057
必担心任何这些，只需要在你开始查看真正的钱和真正的私钥时参考它。

5610
07:52:45.057 --> 07:52:51.181
我知道我的帐户与我的私钥在测试网上是相同的，它是在主网上。

5611
07:52:51.181 --> 07:52:59.172
就像我告诉你,我的私钥Rinkeby是一样的我私钥主要净,如果我必须使用私钥与真正

5612
07:52:59.172 --> 07:53:07.163
的基金在未来,直到我100%确定我做什么,我总是会使用其中一个加密的方法,帕特里克

5613
07:53:07.163 --> 07:53:15.546
给你们一些更好的加密的东西我没有展示或使用命令行方式通过私钥,然后删除命令行历史之后。

5614
07:53:15.546 --> 07:53:19.655
如果我没有实际部署任何东西来实现它或者使用真正资金的私钥。

5615
07:53:19.655 --> 07:53:21.180
我不需要担心。

5616
07:53:21.283 --> 07:53:22.217
看看这个。

5617
07:53:24.283 --> 07:53:24.944
你有信心。

5618
07:53:27.283 --> 07:53:32.473
我说这些是为了给你们灌输信心这些是我们需要思考的问题。

5619
07:53:32.473 --> 07:53:33.044
好了,好了。

5620
07:53:33.044 --> 07:53:37.092
在这里，我会很安全。

5621
07:53:37.283 --> 07:53:38.638
砰，我就安全了。

5622
07:53:41.283 --> 07:53:43.425
推特，把这个放到一个巨大的推特线程里。

5623
07:53:43.425 --> 07:53:43.960
放手去做吧。

5624
07:53:44.283 --> 07:53:51.819
了解这一点的人越多，了解他们的WMV文件和私钥的安全风险的人越多，就越好。

5625
07:53:51.819 --> 07:53:53.694
感谢大家的聆听。

5626
07:53:53.694 --> 07:53:57.231
我知道我肯定夸大了这一点，但它真的很重要。

5627
07:53:57.284 --> 07:53:59.784
让我们继续这门课。

5628
07:54:02.284 --> 07:54:02.705
在这里完成。

5629
07:54:05.284 --> 07:54:10.431
现在把这些都清理一下当我们在自动保存时，VS code插件可以自动格式化。

5630
07:54:10.431 --> 07:54:17.801
但是，在将来，如果其他人遇到我们的存储库，他们可能没有Vyas代码的自动格式或开启。

5631
07:54:17.801 --> 07:54:20.534
所以我们想给用户一种格式化他们代码的方法。

5632
07:54:20.534 --> 07:54:22.827
所以它与我们使用的风格相匹配。

5633
07:54:22.827 --> 07:54:26.265
所以我们有漂亮的扩展安装。

5634
07:54:26.265 --> 07:54:32.246
我们还可以添加pretty tier作为Node js模块，它可以告诉其他

5635
07:54:32.246 --> 07:54:38.227
没有Vyas代码的用户如何准确地格式化他们的JavaScript和坚固性。

5636
07:54:38.284 --> 07:54:43.336
这里有一个更漂亮的插件，在我们的GitHub回购中有一个链接。

5637
07:54:43.336 --> 07:54:51.318
向下滚动，我们可以看到如何使用npm install dash save Dev来安装，

5638
07:54:51.318 --> 07:54:58.939
同样，我们将使用yarn，我们将使用yarn，然后添加更漂亮的插件solidity。

5639
07:54:58.939 --> 07:55:04.509
我们同时安装了pretty tier和solidity插件。

5640
07:55:04.509 --> 07:55:08.398
如果我们检查我们的包JSON，我们可以看到这两个已经被添加了。

5641
07:55:08.398 --> 07:55:15.606
我们现在能做的是创建一个新文件叫做。pretty, R。C。

5642
07:55:15.606 --> 07:55:20.122
在这个文件中，我们可以定义一些花括号。

5643
07:55:20.122 --> 07:55:25.948
在这里，我们可以为我们的实体性和JavaScript定义我们想

5644
07:55:25.948 --> 07:55:31.962
要的东西，例如，我们的简单存储的制表符宽度为412344个空格。

5645
07:55:31.962 --> 07:55:35.703
也许我们应该改变这一点。

5646
07:55:35.703 --> 07:55:38.742
我们希望制表符宽度为2。

5647
07:55:38.742 --> 07:55:46.983
我们会把它保存在这里，然后回到简单存储，保存到这里，它会自动格式化为r。pretty RC。

5648
07:55:46.983 --> 07:55:51.971
在我们的设置中，我们有默认的solidity编辑器，我们的硬帽，

5649
07:55:51.971 --> 07:55:57.427
solidity插件，默认的meta JavaScript是更漂亮的。

5650
07:55:57.427 --> 07:56:04.216
代码一，当我们在这里添加更漂亮的RC时，这个文件将优先于默认

5651
07:56:04.216 --> 07:56:11.006
配置，只要我们下载了节点模块中的模块，我们可以在这里看到它。

5652
07:56:11.006 --> 07:56:14.120
我们有这个。pretty rc文件。

5653
07:56:14.285 --> 07:56:16.006
我要用表格结账。

5654
07:56:17.285 --> 07:56:25.774
我们现在有一件事我不喜欢那就是末尾的分号，所以我们要做semi

5655
07:56:25.774 --> 07:56:34.538
- boss，我要保存它，回来部署保存你会看到分号自动消失了。

5656
07:56:34.538 --> 07:56:42.336
我还要加上use制表符false，因为我想使用空格，然后加上单引号false。

5657
07:56:42.336 --> 07:56:48.699
这样，我们总是用双引号，而不是单引号，在JavaScript中，你可以用单

5658
07:56:48.699 --> 07:56:55.234
引号或双引号，来定义字符串，但我们要这样做，无论你用什么引号，它都是双引号。

5659
07:56:55.285 --> 07:57:01.300
然后，对于所有的开源回购，以及所有的项目，都需要自述文件。

5660
07:57:01.300 --> 07:57:07.285
Md自述文件通常是人们放置关于你的项目的指令或信息或类似东西的地方。

5661
07:57:07.285 --> 07:57:13.372
这样一来，当任何人看到你的项目时，他们就会知道你的readme。MDs，

5662
07:57:13.372 --> 07:57:22.841
我们的Markdown语法是怎么回事，记得我们在试着讨论的时候，我们使用了一些有趣的技巧来格式化代码中的实体性。

5663
07:57:22.841 --> 07:57:26.389
格式化的过程是完全一样的。

5664
07:57:26.389 --> 07:57:27.786
Md文件进行记录。

5665
07:57:27.786 --> 07:57:29.973
他们都将使用降价。

5666
07:57:29.973 --> 07:57:37.995
事实上，如果我们按Ctrl, Shift V，你会进入标记的预览模式你会在我的头盔预览中看到#号。

5667
07:57:37.995 --> 07:57:40.730
这醚简单的存储FCC是巨大的。

5668
07:57:40.730 --> 07:57:43.714
它看起来像一个标题在顶部。

5669
07:57:43.714 --> 07:57:46.253
按Command Shift V查看你的。

5670
07:57:46.253 --> 07:57:53.163
Windows和Linux用户使用“Ctrl”、“Shift V”。

5671
07:57:53.286 --> 07:58:01.882
我们要做的最后一件事是我们要把它部署到一个测试网上并在测试网上与它交互，我们要使用林克比测试网上。

5672
07:58:01.882 --> 07:58:07.777
但是一定要使用GitHub仓库推荐的测试网。

5673
07:58:07.777 --> 07:58:14.692
现在看一下我们的代码，您可能已经对如何实际进行这个细微的更改有了很好的了解。

5674
07:58:14.692 --> 07:58:22.105
根据上一节的内容，我们知道我们只需要一个RPC URL和一个私钥，就可以开始在区块链上进行事务处理了。

5675
07:58:22.105 --> 07:58:27.436
我们可能需要一个rinkbrpc URL，和一个rink私钥。

5676
07:58:27.436 --> 07:58:34.606
我们在哪能找到这两个，如果你想自己做所有事情，在完全去中心化的环境中，我们可以运行一个rink

5677
07:58:34.606 --> 07:58:41.777
B版本的geth，我们可以本地运行它，然后连接到我们的来宾节点，我们不打算在这里展示怎么做。

5678
07:58:41.777 --> 07:58:44.238
但是，这是100%可以做到的。

5679
07:58:44.238 --> 07:58:49.897
相反，我们将在与本课程相关的GitHub回购中使用第三方RPC URL。

5680
07:58:49.897 --> 07:58:56.008
转到第五课，我们可以向下滚动找到炼金术的链接。

5681
07:58:56.008 --> 07:59:00.853
Alchemy有一个节点作为服务，并允许我们连接到任何他们支持的区块链，

5682
07:59:00.853 --> 07:59:05.565
两个替代方案可能是quick node、Morales或infura。

5683
07:59:05.565 --> 07:59:07.787
这些都有节点作为服务选项。

5684
07:59:07.787 --> 07:59:13.608
但我们将与Alchemy合作，因为它是我最喜欢的一个，我们可以继续，免费开始，或

5685
07:59:13.608 --> 07:59:19.575
者登录或创建一个新帐户，我将继续，注册我们的硬帽free Code Camp用户。

5686
07:59:19.575 --> 07:59:23.254
我们将选择以太坊区块链生态系统。

5687
07:59:23.254 --> 07:59:25.189
让我们继续创建第一个应用程序。

5688
07:59:25.287 --> 07:59:28.434
这将是我们称之为自由代码营。

5689
07:59:28.434 --> 07:59:28.893
RT的帽子。

5690
07:59:29.287 --> 07:59:33.327
app的名字是以太，简单存储，

5691
07:59:33.327 --> 07:59:38.445
FCC，网络是我们选择溜冰场B的地方。

5692
07:59:38.445 --> 07:59:45.703
但是你可以看到，我们实际上可以选择的不仅仅是溜冰场B，我们可以选择真正的科万，溜冰场B, ropsten。

5693
07:59:45.703 --> 07:59:50.382
第二层，套利和乐观，我们将使用溜冰场B。

5694
07:59:50.382 --> 07:59:52.474
我们来创建这个应用。

5695
07:59:52.474 --> 07:59:55.811
我们将选择免费计划并点击Continue。

5696
07:59:55.811 --> 07:59:58.171
我们将跳过增加支付。

5697
07:59:58.171 --> 08:00:02.483
如果您想tweet您的推荐代码，请随意tweet您的推荐代码。

5698
08:00:02.483 --> 08:00:03.860
我们先跳过。

5699
08:00:03.860 --> 08:00:06.172
我们会把它的容量保持在上限。

5700
08:00:06.172 --> 08:00:08.631
因为我们没有我们这里没有钥匙。

5701
08:00:08.631 --> 08:00:13.693
然后你是怎么知道我们的在Patrick And Free Code Camp上喊我的然后点击Let's go。

5702
08:00:13.693 --> 08:00:22.524
现在我们来到了炼金术仪表板，在这里我们可以看到大量关于节点的信息以及连接到节点的不同方式等等。

5703
08:00:22.524 --> 08:00:28.078
这和ganache的RPC服务器端点非常相似，只是它是

5704
08:00:28.078 --> 08:00:33.838
一个连接，只是它是一个连接到真实测试网或真实主网的连接。

5705
08:00:33.838 --> 08:00:38.884
我们现在能做的是选择我们刚制作的app。

5706
08:00:38.884 --> 08:00:40.494
我们可以按View键。

5707
08:00:40.494 --> 08:00:45.716
我们可以看到这里我们得到一个API key key，我们添加一个HTTP端点我们也得到一个WebSocket。

5708
08:00:45.716 --> 08:00:48.703
我们只关心HTTP端点。

5709
08:00:48.703 --> 08:00:52.583
这将是连接到溜冰场B的RPC URL。

5710
08:00:52.583 --> 08:00:57.960
我们现在能做的就是复制这个到Visual Studio代码中。

5711
08:00:57.960 --> 08:01:03.771
在我们的。env中，我们可以把这些替换成它们的实际测试值和值。

5712
08:01:03.771 --> 08:01:09.042
对于RPC URL，我们会删除这个用Rigby RPC行替换它。

5713
08:01:09.042 --> 08:01:17.697
现在我们如何为一个有实际秩的测试集获取私钥呢?我们可以在这里使用元遮罩。

5714
08:01:17.697 --> 08:01:25.988
回到浏览器，到元掩码，选择三个点，到账户详细信息，导出私钥。

5715
08:01:25.988 --> 08:01:30.660
在这里你可以导出私钥，输入密

5716
08:01:30.660 --> 08:01:35.667
码，你就有了元掩码账户的私钥。

5717
08:01:35.667 --> 08:01:43.046
现在，请记住，请不要继续使用一个真正有钱的元掩码。

5718
08:01:43.046 --> 08:01:47.984
一个快速的检查方法是打开你的网络选项卡，看看是否在任何一个主

5719
08:01:47.984 --> 08:01:53.088
要的网络或有实际资金的网络上，你看到任何资金，我没有任何资金。

5720
08:01:53.088 --> 08:01:53.999
所以我知道我可以走了。

5721
08:01:53.999 --> 08:01:57.377
如果你有测试这些钱，那没关系，因为那反正是假钱。

5722
08:01:57.377 --> 08:02:03.021
而且，大多数浏览器都有一个配置文件机制，您可以在其中创建一个新的配置文件供您使用。

5723
08:02:03.021 --> 08:02:09.271
现在我已经复制了我的私钥，我们可以回到Visual Studio代码，把密钥粘贴到这里。

5724
08:02:09.271 --> 08:02:13.185
现在我有一个私钥，里面有实际的rink。

5725
08:02:13.185 --> 08:02:13.736
太棒了。

5726
08:02:13.736 --> 08:02:19.001
记住，如果你情绪低落，就到水龙头。链条。链接/

5727
08:02:19.001 --> 08:02:24.495
里格比那里做些测试，我不是机器人，会发出请求的。

5728
08:02:24.495 --> 08:02:31.130
现在我们有了溜冰场的私钥，我们现在可以在实际测试中运行这个。

5729
08:02:31.130 --> 08:02:36.483
Net，我们看一下代码，我们看到我们从r。end获取一个RPC URL，

5730
08:02:36.483 --> 08:02:41.689
我们从Yun V获取一个私钥，它指向我们的溜冰场D Metamask。

5731
08:02:41.689 --> 08:02:43.617
我们的溜冰场B区块链。

5732
08:02:43.617 --> 08:02:50.089
让我们在contract deployment下面添加一个console。log这样我们就知道它的地址了。

5733
08:02:50.089 --> 08:02:55.384
我们会做console。log，我们会做一些字符

5734
08:02:55.384 --> 08:03:00.901
串插值，契合。address契合。address。

5735
08:03:00.901 --> 08:03:02.271
好的，很好。

5736
08:03:02.271 --> 08:03:04.966
现在让我们继续运行它。

5737
08:03:04.966 --> 08:03:07.508
我们用node deploy·J。

5738
08:03:07.508 --> 08:03:11.513
请稍等，你会发现这需要更长的时间。

5739
08:03:11.513 --> 08:03:17.797
因为我们部署到一个测试网络而不是我们自己的伪本地区块链，测试网络

5740
08:03:17.797 --> 08:03:24.082
和真实网络通常会花更长的时间，因为它们需要等待块传播交易，等等。

5741
08:03:24.082 --> 08:03:29.224
但稍等片刻后，我们确实会看到我们在这里得到一个合同地址。

5742
08:03:29.289 --> 08:03:30.482
我们现在有一个最喜欢的数字。

5743
08:03:31.289 --> 08:03:38.715
又慢了，因为我们在等待下一个交易完成来更新数字，然后，看起来我们成功更新了它。

5744
08:03:38.715 --> 08:03:47.616
有一点很重要如果你运行命令，想要终止它，你可以按Ctrl C，它就会停止。

5745
08:03:47.616 --> 08:03:52.543
终端中任何你想要终止Ctrl的命令。

5746
08:03:52.543 --> 08:03:55.648
C是你的免费卡，这将会杀死它。

5747
08:03:55.648 --> 08:03:57.239
不管它在哪里，都能阻止它。

5748
08:03:57.239 --> 08:03:59.950
我们以后会经常使用Ctrl C。

5749
08:03:59.950 --> 08:04:07.298
抓取这个合同地址到Frank V，扫描粘贴

5750
08:04:07.298 --> 08:04:14.647
进来，这里有两个交易，这里有一个合同创建。

5751
08:04:14.647 --> 08:04:17.605
我们还可以调用一个store函数。

5752
08:04:17.605 --> 08:04:18.727
这太棒了。

5753
08:04:18.727 --> 08:04:25.193
我们已经使用自己的代码成功地将合约部署到皱纹链中。

5754
08:04:25.193 --> 08:04:28.918
恭喜你，这是巨大的。

5755
08:04:28.918 --> 08:04:33.979
现在通过以太扫描，我们实际上可以验证并发布我们的合同代码。

5756
08:04:33.979 --> 08:04:41.090
什么是验证和发布代码?现在，我们的代码看起来像一个巨大的字节码沙鼠。

5757
08:04:41.090 --> 08:04:45.964
任何直接在链上看合约的人都会看到这一大堆字节码，

5758
08:04:45.964 --> 08:04:50.838
我们可以用反编译器把字节码反编译成它实际的样子。

5759
08:04:50.838 --> 08:04:55.027
但这通常需要很长时间和大量的处理能力。

5760
08:04:55.027 --> 08:05:02.734
相反，我们可以通过验证和发布代码让它更简单，你可以点击验证和发布。

5761
08:05:02.734 --> 08:05:08.994
我们可以向下滚动，我们可以添加编译器信息在以太扫描和其他块探索器上编译它。

5762
08:05:08.994 --> 08:05:13.665
这是一个单文件编译器的版本是零点8。

5763
08:05:13.665 --> 08:05:13.754
7.

5764
08:05:13.754 --> 08:05:16.199
它是MIT授权的开源软件。

5765
08:05:16.199 --> 08:05:17.991
让我们继续。

5766
08:05:17.991 --> 08:05:23.798
我们要复制粘贴我们的固体度代码到这一大块。

5767
08:05:23.798 --> 08:05:24.191
粘贴。

5768
08:05:24.191 --> 08:05:28.933
我们没有任何构造函数参数，因此可以跳过此部分。

5769
08:05:28.933 --> 08:05:32.745
我们没有任何库或任何其他杂项设置。

5770
08:05:32.745 --> 08:05:37.874
我们会选择I'm not a robot然后点击verify and publish。

5771
08:05:37.874 --> 08:05:40.991
你可能得等几分钟，但太棒了。

5772
08:05:40.991 --> 08:05:43.719
我们的合同编制成功了。

5773
08:05:43.719 --> 08:05:49.431
现在如果我们回到合同源代码，我们可以在这里看到所有代码。

5774
08:05:49.431 --> 08:05:58.224
如果我们抓取合同地址，把它放到搜索中，然后进入合同，我们会得到一个绿色的勾号。

5775
08:05:58.291 --> 08:06:02.215
我们可以看到，任何人都可以阅读我们的源代码。

5776
08:06:02.291 --> 08:06:10.385
另外，那些我们看到并混合用于从合同中读取和写入的按钮，分别在这个读合同和这个写合同中。

5777
08:06:10.385 --> 08:06:17.613
如果我们读取契约，并检索最近的数字，我们确实会看到这里有7，因为我们最近存储了7。

5778
08:06:17.613 --> 08:06:23.662
很好，快速提示，这可能已经为您验证过了，因为以太扫描可能足够智能，可以注意到许

5779
08:06:23.662 --> 08:06:29.711
多人正在部署相同的字节码，它已经为您验证过了，所以不管怎样，继续执行这些步骤。

5780
08:06:29.711 --> 08:06:36.541
我们刚刚做的代码验证非常简单直接，因为我们的代码非常简单直接。

5781
08:06:36.541 --> 08:06:42.087
使用更大更复杂的代码会使验证过程变得有点困难。

5782
08:06:42.087 --> 08:06:45.597
此外，我们并不总是想要在以太扫描上点击按钮。

5783
08:06:45.597 --> 08:06:48.225
为了验证我们的代码，我们希望以编程的方式进行验证。

5784
08:06:48.225 --> 08:06:55.427
因此，在后面的部分中，我们将学习如何直接通过代码编辑器验证所有的代码，您可以想象在我们的炼金

5785
08:06:55.427 --> 08:07:02.629
术中部署到任何EVM链的过程是如此简单，我们可以轻松地创建一个新的应用程序和更改我们的网络。

5786
08:07:02.629 --> 08:07:09.325
您可以看到，将这个RPC URL和您的私钥切换到另一个链上工作是多么容易。

5787
08:07:09.325 --> 08:07:13.775
这个过程同样适用于和谐幻影，雪崩等。

5788
08:07:13.775 --> 08:07:19.154
如果我们想要切换链，我们只需切换RPC

5789
08:07:19.154 --> 08:07:24.818
URL和私钥，其他的一切都将完全相同。

5790
08:07:24.818 --> 08:07:29.430
现在，Alchemy还向我们展示并教会了我们很多关于事务

5791
08:07:29.430 --> 08:07:34.207
和幕后发生的事情的知识，包括一个称为mempool的概念。

5792
08:07:34.207 --> 08:07:39.647
为了帮助我们更多地了解我们刚刚发送的那些事务，以及如何与Alchemy一起工作。

5793
08:07:39.647 --> 08:07:45.238
为了更多地了解我们的事务，我们请了炼金术团队的Albert为我们做一些演示。

5794
08:07:45.292 --> 08:07:50.012
大家好，我是炼金术公司的Albert，我是推特上的科技界人

5795
08:07:50.012 --> 08:07:54.895
士，如果你想参与其中并对这部分视频提出任何问题，请随时关注。

5796
08:07:54.895 --> 08:08:02.240
但是非常高兴能在这里加入Patrick，他将解释使用alchemy提交事务时幕后发生了什么。

5797
08:08:02.292 --> 08:08:08.746
我们有大量的工具来提供一个可以看到正在发生的事情的窗口，这样你就

5798
08:08:08.746 --> 08:08:15.201
可以进行调试，以防你的网站出现使用错误，或者有挂起的事务被卡住。

5799
08:08:15.201 --> 08:08:19.625
不管是什么，我们提供了一个窗口，可以看到你所控制的数据。

5800
08:08:19.625 --> 08:08:22.662
请记住，您提交的所有事务都记录在区块链上。

5801
08:08:22.662 --> 08:08:26.529
它们不受炼金术的控制，也不受任何其他服务提供商的控制。

5802
08:08:26.529 --> 08:08:32.212
我们只是一扇窗户，我们只是管道管道对你有用。

5803
08:08:32.292 --> 08:08:34.324
让我来告诉你们这到底是什么意思。

5804
08:08:35.292 --> 08:08:36.525
仪表板上有一堆应用程序。

5805
08:08:37.292 --> 08:08:39.986
我用过很多不同的项目。

5806
08:08:40.292 --> 08:08:45.372
一个是最近激活的，它是我目前设置的连接到我的元掩码。

5807
08:08:45.372 --> 08:08:47.533
这里使用自定义RPC提供程序。

5808
08:08:47.533 --> 08:08:49.767
我把脸画小一点。

5809
08:08:49.767 --> 08:08:52.885
你们可以看到，我把Rinkeby拼错了。

5810
08:08:52.885 --> 08:08:58.708
但现在，我的我的网络通过炼金术连接到林克比测试网络。

5811
08:08:58.708 --> 08:09:00.800
这就是这个应用。

5812
08:09:00.800 --> 08:09:07.361
如果我点击仪表板上的这里，你可以看到这里，有很多非常有趣的统计数据，这是你可能会用到的第一个东西。

5813
08:09:07.361 --> 08:09:11.955
如果您想进一步了解您的应用程序，您可以到这

5814
08:09:11.955 --> 08:09:16.768
里查看您的应用程序当前每秒使用多少计算单元。

5815
08:09:16.768 --> 08:09:21.072
这对于炼金术的使用和理解是非常有用的。

5816
08:09:21.072 --> 08:09:27.935
但这也很有用，比如，中值响应时间是多少，33毫秒已经很好了。

5817
08:09:27.935 --> 08:09:34.543
如果它开始增加，那么你可能想知道，你知道，这里发生了什么，成功率，它已经有点低了。

5818
08:09:34.543 --> 08:09:39.714
因此，这是一个提示，我可以点击这个选项卡查看最近的无效请求。

5819
08:09:39.714 --> 08:09:45.890
我可以看到，有一堆失败的事务，其中事务已经发送或

5820
08:09:45.890 --> 08:09:52.325
者nonce太低，等等，我可以用这个选项卡来调试。

5821
08:09:52.325 --> 08:09:54.193
所以这个成功率非常有用。

5822
08:09:54.293 --> 08:09:56.228
吞吐量是有限的。

5823
08:09:58.293 --> 08:10:02.631
请求或你的网站正在被垃圾邮件发送，你可能会开始被阻止一些请求。

5824
08:10:02.631 --> 08:10:08.225
这就是在这里查看他们的并发请求的有用之处，过去24小时

5825
08:10:08.225 --> 08:10:13.819
内的成功率与过去1小时相比，过去24小时内的请求总数。

5826
08:10:13.819 --> 08:10:19.879
这与计算单元不同，因为每个请求可以有不同级别的计算成本。

5827
08:10:19.879 --> 08:10:23.189
用计算单位来衡量计算成本。

5828
08:10:23.189 --> 08:10:27.143
总请求数就是绝对请求的实际数量。

5829
08:10:27.143 --> 08:10:29.793
当然，还有无效请求的数量。

5830
08:10:29.793 --> 08:10:30.150
酷。

5831
08:10:30.150 --> 08:10:37.102
有一件事很有趣当我提交一笔交易时，我这里就有一笔，我想发送让我们在我

5832
08:10:37.102 --> 08:10:44.055
的账户之间转账，我只会将它发送到Rinkeby eath的一小部分。

5833
08:10:44.055 --> 08:10:50.141
但我有意地将我的气费编辑得非常非常低，这样节点就

5834
08:10:50.141 --> 08:10:56.228
不会将交易发送到挖矿，否则就没有挖矿者会去捡它。

5835
08:10:56.228 --> 08:11:00.606
你可以看到我把优先费和最高费除以了一吨。

5836
08:11:00.606 --> 08:11:01.731
所以它非常低。

5837
08:11:01.731 --> 08:11:07.047
它可能会确认在MME Max UI中，你会看到事务已经挂起了一段时间。

5838
08:11:07.047 --> 08:11:09.015
我们会转到mempool选项卡。

5839
08:11:09.015 --> 08:11:11.900
这是另一个非常有用的可视化。

5840
08:11:11.900 --> 08:11:19.263
记忆池是一种等待场所，我喜欢把它想象成餐厅的候车室，如果你在那里进

5841
08:11:19.263 --> 08:11:26.627
行交易，你在那里等待被挖掘，记忆池有点像你在那里等待入座的候车室。

5842
08:11:26.627 --> 08:11:31.422
每个交易都有不同的状态，你总想看到的

5843
08:11:31.422 --> 08:11:36.484
是矿交易，因为这表示你的交易是成功的。

5844
08:11:36.484 --> 08:11:38.198
现在它是区块链的一部分。

5845
08:11:38.294 --> 08:11:42.494
mempool，每个节点都有自己的固定区域。

5846
08:11:42.494 --> 08:11:44.227
我可以给你们展示这个快速的可视化图。

5847
08:11:44.294 --> 08:11:47.638
记住，区块链是由节点网络运行的。

5848
08:11:48.294 --> 08:11:53.766
节点或运行定理的每台计算机，软件都维护了区块链的副本。

5849
08:11:53.766 --> 08:11:58.246
作为开发人员，您必须使用这些节点向区块链发出请求。

5850
08:11:58.294 --> 08:12:03.261
现在您可以使用炼金术，您可以使用另一个RPC提供程序，您可以旋转您自己的节点，如果您愿意的话。

5851
08:12:03.261 --> 08:12:07.010
但无论如何，您都需要使用节点与链通信。

5852
08:12:07.010 --> 08:12:14.711
现在每个节点除了拥有整个区块链状态的副本之外，还拥有事务的本地内存。

5853
08:12:14.711 --> 08:12:16.618
这叫做mempool。

5854
08:12:16.618 --> 08:12:22.961
因此，如果存在等待挖掘的挂起事务，则可以将它们视为在内存池中。

5855
08:12:22.961 --> 08:12:24.617
这就是我们现在看到的。

5856
08:12:24.617 --> 08:12:30.652
如果我们点开我目前用的Metamask RPC的应用，

5857
08:12:30.652 --> 08:12:36.465
你可以看到这里有，这个不是正确的，这个是用于起皱的。

5858
08:12:36.465 --> 08:12:42.032
对于所有的事务，你可以看到在大脑的某个地方有更多的下落有一个是待处

5859
08:12:42.032 --> 08:12:47.600
理的，这个是待处理的，它和这个是匹配的，它被发送到0x C BB。

5860
08:12:47.600 --> 08:12:52.622
如果我们点击这个事务散列，就会得到调试所需的所有信息。

5861
08:12:52.622 --> 08:12:59.491
你可以看到它来自我的当前地址，0x, 5f，然后是2x, C, BB。

5862
08:12:59.491 --> 08:13:02.778
这是我要发送的值。

5863
08:13:02.778 --> 08:13:06.214
这是我附上的这笔交易的汽油费。

5864
08:13:06.214 --> 08:13:10.095
你会注意到这是非常低的，即使对于Rinkeby测试网络。

5865
08:13:10.095 --> 08:13:18.617
知道这个，看到这个事务已经挂起了1分46秒，它是在这个时候发送的，我可能应该修复它。

5866
08:13:18.617 --> 08:13:24.456
在这里，你可以使用metamath RPC, meta - meta掩码API。

5867
08:13:24.456 --> 08:13:25.423
然后加速。

5868
08:13:25.423 --> 08:13:30.456
然后我要用自动高速来更新汽油费用。

5869
08:13:30.456 --> 08:13:38.645
如果我们回到仪表板回到我们的应用程序，你会看到最近有一些新的无效请求。

5870
08:13:38.645 --> 08:13:46.723
这是因为我们重新提交了一个事务，然后在他们最近的请求中，我们快速刷新一下。

5871
08:13:46.723 --> 08:13:50.618
你可以看到我们发送了一个原始事务，这个是已知的。

5872
08:13:50.618 --> 08:13:56.646
之前还有一个，但它的结果是get事务收据成功。

5873
08:13:56.646 --> 08:14:03.664
然后如果我们回到mempool，你会看到，没有更多挂起的事务，只有删除，替换和挖矿。

5874
08:14:03.664 --> 08:14:10.874
因此，第5个事务现在已经成功，您可以继续开发和维护应用程序的其余部分了。

5875
08:14:10.874 --> 08:14:12.821
谢谢，希望对大家有用。

5876
08:14:12.821 --> 08:14:19.102
如果有任何问题请告诉我。

5877
08:14:19.296 --> 08:14:25.594
现在，除了TypeScript部分(我将在最后完成)，您已经成功完成了本节。

5878
08:14:25.594 --> 08:14:27.233
哇，你学到了很多东西。

5879
08:14:27.233 --> 08:14:29.957
让我们快速回顾一下所学的内容。

5880
08:14:29.957 --> 08:14:37.876
首先，我们学习了如何用Node js创建新项目，我们学习了Node关键字的作用以及如何使用Node关键字。

5881
08:14:37.876 --> 08:14:42.675
为了在我们的本地开发环境中运行JavaScript，我们了解

5882
08:14:42.675 --> 08:14:47.635
到可以使用yarn或NPM在本地包中添加不同的外部包依赖关系。

5883
08:14:47.635 --> 08:14:56.187
我们可以在package。JSON中看到这些依赖项，我们知道它们已经被安装了，因为它们被安装到node modules文件夹中，我们还

5884
08:14:56.187 --> 08:15:04.740
可以创建一个脚本部分，在这里我们可以最小化需要运行到单个关键字中的长命令，例如compile，我们可以只运行yarn compile。

5885
08:15:04.740 --> 08:15:09.678
为了编译我们所有的代码，我们学习了JavaScript脚本

5886
08:15:09.678 --> 08:15:14.787
的基本设置，我们在顶部导入包，在底部有一些主要的执行器函数。

5887
08:15:14.787 --> 08:15:22.334
然后我们在中间有main函数，我们使用async关键字让我们的函数可以使用

5888
08:15:22.334 --> 08:15:29.881
异步编程，我们访问await关键字，意思是，嘿，等待这个承诺完成它的事情。

5889
08:15:29.881 --> 08:15:35.411
我们能够使用RPC URL连接到我们想要的任何区块链，然

5890
08:15:35.411 --> 08:15:41.139
后我们能够通过这样做将我们的提供者连接到醚中的钱包或私钥。

5891
08:15:41.139 --> 08:15:49.597
说到这里，我们已经学习了ethers包，这是一个工具，让我们的生活更容易与JavaScript中的区块链交互，如果

5892
08:15:49.597 --> 08:15:58.055
我们决定，我们还学习了我们可以加密我们的私钥，这样即使我们的电脑被黑客攻击，我们的私钥也不会以明文的形式到处乱放。

5893
08:15:58.055 --> 08:16:01.852
我们已经学会了如何通过加密密钥运行脚本。

5894
08:16:01.852 --> 08:16:06.871
我们已经学习了如何获取ABI或应用程序二进制接口，以及如何将我们的代码

5895
08:16:06.871 --> 08:16:12.035
二进制部署到区块链，我们还学习了如何以编程方式将我们的契约部署到区块链。

5896
08:16:12.035 --> 08:16:15.533
然后我们还学习了如何以编程方式与契约交互。

5897
08:16:15.533 --> 08:16:21.230
此外，我们还学习了如何在VS代码的设置点JSON中添加默认编辑器。

5898
08:16:21.230 --> 08:16:26.856
但是我们也学习了如何通过使用一个。beautitier rc文件来覆

5899
08:16:26.856 --> 08:16:32.649
盖这些设置，我们可以自动格式化我们的代码，使它看起来更好，更容易阅读。

5900
08:16:32.649 --> 08:16:38.756
最后，我们学习了如何将这些合同部署到一个真实的测试网或真实的网络中。

5901
08:16:38.756 --> 08:16:43.404
然后我们终于学会了手动验证合同源代码的方法。

5902
08:16:43.404 --> 08:16:45.690
就像我说的，我们会学到很多捷径。

5903
08:16:45.690 --> 08:16:48.909
在接下来的章节中，会有很多方法让这一切变得简单。

5904
08:16:48.909 --> 08:16:54.361
哦，你们已经取得了惊人的成绩，给自己一个表扬，休息一下，

5905
08:16:54.361 --> 08:16:59.619
跑一圈，为自己走了这么远感到骄傲，我们还有很多路要走。

5906
08:16:59.619 --> 08:17:02.195
但你已经走了很长的路。

5907
08:17:02.195 --> 08:17:03.279
祝贺你。

5908
08:17:03.279 --> 08:17:09.207
或者休息5到10分钟，准备好了再回来。

5909
08:17:09.297 --> 08:17:13.125
现在我还想给大家展示的是TypeScript的附加内容。

5910
08:17:13.125 --> 08:17:21.598
然而，如果你对TypeScript版本不感兴趣(你不必感兴趣)，那么你就完了，我们只需要做一些改变来使这个TypeScript兼容。

5911
08:17:21.598 --> 08:17:24.647
当然，首先，我们要更改我们的部署。

5912
08:17:24.647 --> 08:17:31.765
Ts和加密密钥，我们要改变我们的部署和加密密钥从。js2。

5913
08:17:31.765 --> 08:17:31.926
ts。

5914
08:17:31.926 --> 08:17:36.996
然后我们也要把这些需求换成导入。

5915
08:17:36.996 --> 08:17:41.910
所以我们要从醚中导入醚，

5916
08:17:41.910 --> 08:17:47.234
我们要从额外的f中导入f。

5917
08:17:47.234 --> 08:17:52.588
然后我们会导入。TMP / config。

5918
08:17:52.588 --> 08:17:57.201
然后我们要复制这些，我们要把它们粘贴

5919
08:17:57.201 --> 08:18:02.072
到这里，删除或注释掉要求，好的，很好。

5920
08:18:02.072 --> 08:18:04.388
现在，如果我们尝试运行Node deploy。

5921
08:18:04.388 --> 08:18:09.199
Ts，我们会得到不能在模块外使用输入语句。

5922
08:18:09.199 --> 08:18:17.412
在JavaScript中，如果我们想在模块外部使用import语句，我们会在这里做一些类似于type module的事情。

5923
08:18:17.412 --> 08:18:21.139
但在TypeScript中，我们甚至不需要这些。

5924
08:18:21.139 --> 08:18:24.369
我们需要做的就是在TypeScript注释中运行它。

5925
08:18:24.369 --> 08:18:28.937
要添加TypeScript，我们要做yarn，添加TypeScript。

5926
08:18:28.937 --> 08:18:31.887
我们还要加上TS节点。

5927
08:18:31.887 --> 08:18:34.710
TS节点是node的TypeScript版本。

5928
08:18:34.710 --> 08:18:38.504
现在我们已经添加了，我们可以尝试TS节点部署。

5929
08:18:38.504 --> 08:18:38.641
ts。

5930
08:18:38.641 --> 08:18:41.609
我们仍然会遇到一个错误。

5931
08:18:41.609 --> 08:18:45.316
如果你向上滚动，我们会得到一些错误。

5932
08:18:45.316 --> 08:18:53.502
我们会说，找不到Module Fs额外的声明文件，我们需要添加它们的TypeScript版本。

5933
08:18:53.502 --> 08:18:57.392
所以我们要做斜杠f型的纱线。

5934
08:18:57.392 --> 08:19:01.447
如果我们再运行一次，应该还是不能用。

5935
08:19:01.447 --> 08:19:02.447
但原因不同。

5936
08:19:02.447 --> 08:19:04.584
是的，我们会买这种类型的。

5937
08:19:04.584 --> 08:19:06.944
Undefined不能赋值给类型字节。

5938
08:19:06.944 --> 08:19:11.502
比如我们得到这个的原因是因为TypeScript中的pro

5939
08:19:11.502 --> 08:19:16.061
cess。EMV私钥技术上来说，是字符串类型，或未定义的。

5940
08:19:16.061 --> 08:19:20.553
我们需要告诉Typescript和和钱包对象。

5941
08:19:20.553 --> 08:19:24.513
Encrypt函数寻找类型字符串，而不是字符串或未定义。

5942
08:19:24.513 --> 08:19:28.267
我们只需要告诉TypeScript这不是undefined。

5943
08:19:28.267 --> 08:19:29.899
所以我们可以在这里放一声巨响。

5944
08:19:29.899 --> 08:19:37.095
在我们使用处理，研究和成为的地方，哦，我也要在部署时这样做。

5945
08:19:37.095 --> 08:19:38.513
砰，看起来不错。

5946
08:19:38.513 --> 08:19:41.997
现在我们已经在这里添加了所有内容，我们运行TS node deploy。

5947
08:19:41.997 --> 08:19:46.699
t，我们会看到和使用正则节点时完全一样的输出。

5948
08:19:46.699 --> 08:19:50.365
只要私钥密码在。env文件中。

5949
08:19:50.365 --> 08:19:52.502
如果我们运行TS节点和加密密钥。

5950
08:19:52.502 --> 08:19:55.891
t，我们会得到和之前一样的设置。

5951
08:19:55.891 --> 08:19:58.361
我们会得到一个新的加密key。JSON。

5952
08:19:58.361 --> 08:20:01.799
这就是让TypeScript兼容所需要做的。

5953
08:20:01.799 --> 08:20:07.971
你应该为自己赢得热烈的掌声，因为你走了这么远，知道了安全帽下到底发生了什么。

5954
08:20:07.971 --> 08:20:12.785
我们将要学习的下一个工具是关于这些交易以及如何

5955
08:20:12.785 --> 08:20:17.600
与这些区块链交互的，这绝对是巨大的，非常巨大。

5956
08:20:17.600 --> 08:20:19.109
祝贺你。

5957
08:20:19.299 --> 08:20:26.953
好了，现在我们已经学习了ethers js以及如何进行更多的原始JavaScript编码，现在我们将进入hardhat。

5958
08:20:26.953 --> 08:20:31.523
通过以太符号存储，我们看到部署合约可能需要大量代码。

5959
08:20:31.523 --> 08:20:34.300
还有很多事我们都没做。

5960
08:20:34.300 --> 08:20:37.146
就像我们没有保存合同的部署位置一样。

5961
08:20:37.146 --> 08:20:40.252
所以我们必须记住它每次被部署在哪里。

5962
08:20:40.252 --> 08:20:42.565
而不是通过编程方式添加它。

5963
08:20:42.565 --> 08:20:45.961
我们没有在这里编写任何测试，我们必须构建自己的测试基础设施。

5964
08:20:45.961 --> 08:20:48.414
也许我们想让它成为一个跨链应用。

5965
08:20:48.414 --> 08:20:56.987
我们想要的不仅仅是一个私钥和RPC URL，你完全可以通过以太和这样的小脚本在JavaScript中使用你的智能合约。

5966
08:20:56.987 --> 08:21:00.461
但是我们需要一个更健壮的框架来完成这一切。

5967
08:21:00.461 --> 08:21:03.170
这就是“安全帽”发挥作用的地方。

5968
08:21:03.300 --> 08:21:08.721
Hardhead很容易成为最流行的智能合约开发框架之一。

5969
08:21:08.721 --> 08:21:14.726
它被大量使用在数十亿美元的协议中，比如Ave uniswap，寿司交换等等。

5970
08:21:14.726 --> 08:21:16.791
事实上，我最近在Twitter上做了一个调查。

5971
08:21:16.791 --> 08:21:21.232
尽管我的很多内容更偏向于brownie和Pythonic,

5972
08:21:21.232 --> 08:21:27.972
Hardhead远远超出了最流行的框架，Hardhead很快就成为了最先进的框架之一。

5973
08:21:27.972 --> 08:21:33.113
Hardhead是一个开发环境，它允许基于JavaScript的开发，有点

5974
08:21:33.113 --> 08:21:38.393
像我们看到的乙醚，它给了我们更多的工具来集成我们的代码和我们想做的常见事情。

5975
08:21:38.393 --> 08:21:42.086
它具有不可思议的可扩展性，并且具有非常好的调试特性。

5976
08:21:42.086 --> 08:21:44.053
这是一个非常棒的工具。

5977
08:21:44.053 --> 08:21:45.873
我们继续，开始吧。

5978
08:21:45.873 --> 08:21:50.250
如果你想跟随代码，来到GitHub回购并向下滚动。

5979
08:21:50.300 --> 08:21:54.061
第六课的心脏有简单的存储，所有的代码都在这里。

5980
08:21:54.061 --> 08:21:58.604
提醒一下，你想要从这些存储库中下载所有的代码，

5981
08:21:58.604 --> 08:22:06.900
你可以通过做一个git克隆，你要做的是找到你想要放代码的文件夹，然后运行git克隆。

5982
08:22:06.900 --> 08:22:11.419
然后获取要克隆的URL，粘贴进去。

5983
08:22:11.419 --> 08:22:15.070
现在，你可以CD到你的新文件夹，

5984
08:22:15.070 --> 08:22:23.059
里面有所有直接从GitHub下载的东西，但只能作为备份或自己下载代码。

5985
08:22:23.059 --> 08:22:25.001
但现在，跟着我就行了。

5986
08:22:25.001 --> 08:22:26.201
好，我们开始吧。

5987
08:22:26.301 --> 08:22:29.139
让我们使用安全帽创建我们的下一个项目。

5988
08:22:30.301 --> 08:22:34.926
我们要做的叫做Hard Hat，简单的存储dash FCC或Free Code Camp。

5989
08:22:34.926 --> 08:22:39.037
我们又要用那个简单的储存合同合作了。

5990
08:22:39.037 --> 08:22:47.701
但是在“硬帽”中，我们将向你展示大量奇妙的工具，我们可以使用它们使我们的编码生活变得更容易。

5991
08:22:47.701 --> 08:22:53.497
我在一个全新的VS code中，我们会创建一个新文件夹来运行所有这些。

5992
08:22:53.497 --> 08:22:58.833
要创建一个全新的文件夹你可以使

5993
08:22:58.833 --> 08:23:04.169
用mkdir，简单的CC存储。

5994
08:23:04.301 --> 08:23:09.301
现在我们可以把cd转换成硬帽简单存储的cd，并输入代码，句号。

5995
08:23:09.301 --> 08:23:14.916
这将在该文件夹中打开一个新的Visual Studio代码。

5996
08:23:14.916 --> 08:23:20.650
现在如果我们打开终端，你会看到我们确实在那个文件夹里。

5997
08:23:20.650 --> 08:23:27.775
如果这对你不起作用，你当然还可以点击“文件”，打开文件夹，选择你想要打开的文件夹。

5998
08:23:27.775 --> 08:23:29.507
你就在那个文件夹里。

5999
08:23:29.507 --> 08:23:37.081
现在我们有了使用硬帽工作的文件夹设置，我们可以开始设置我们的环境，使用硬帽框架非

6000
08:23:37.081 --> 08:23:44.846
常专业，在我们整个区块链坚实性课程中获得硬帽文档的链接，是的，硬帽文档是现象级的。

6001
08:23:44.846 --> 08:23:48.268
我强烈建议大家在学习这部分的时候把它拿出来。

6002
08:23:48.268 --> 08:23:55.646
因为它将给你几乎所有你需要知道的工作与硬帽，你可以简单地继续到教程并开始。

6003
08:23:55.646 --> 08:24:03.474
如果您想在这里暂停视频并通读教程，我建议您这样做，它将为您提供许多关于如何使用hardhat的信息。

6004
08:24:03.474 --> 08:24:04.531
还有更多关于安全帽的。

6005
08:24:04.531 --> 08:24:07.340
然而，我们将直接跳到设置环境。

6006
08:24:07.340 --> 08:24:10.571
我们还没有在Linux或Mac OS上安装g。

6007
08:24:10.571 --> 08:24:15.492
对于使用Windows的人，我为你们设置了WsL。

6008
08:24:15.492 --> 08:24:19.142
因此，您只需遵循Linux的说明即可。

6009
08:24:19.302 --> 08:24:23.391
现在要创建一个新的安全帽项目，您实际上可以直接在这里运行这些步骤。

6010
08:24:23.391 --> 08:24:30.275
而不是NPM，我们会用yarn，但如果你想用NPM，你完全可以这样做，硬帽Doc会说，run

6011
08:24:30.275 --> 08:24:37.159
NPM init，是的，我们会在里面运行yarn，这会在这个文件夹里为我们创建一个新项目。

6012
08:24:37.159 --> 08:24:44.682
我们给它一个名字，如果我们想让它设为这个硬帽符号存储FF FCC，我们只要按回车键，就会给它一个版本。

6013
08:24:44.682 --> 08:24:46.063
如果我们想要1。

6014
08:24:46.063 --> 08:24:47.904
0点哦，我们按回车键。

6015
08:24:47.904 --> 08:24:51.515
我们现在跳过描述，只要按回车键。

6016
08:24:51.515 --> 08:24:53.968
这里我们也要按回车键。

6017
08:24:53.968 --> 08:24:58.932
这个也可以输入这个也可以输入这个也可以输入这个也可以输入。

6018
08:24:58.932 --> 08:25:00.762
这些都是空的。

6019
08:25:00.762 --> 08:25:02.948
如果我们看package json，

6020
08:25:02.948 --> 08:25:11.452
我们现在看到我们有一个名字Hardhead符号存储FCC我们有一个版本我们有一个main我们实际上要删除这个main然后我们还有一个许可证。

6021
08:25:11.452 --> 08:25:13.875
Yarn为我们设置了这个package json。

6022
08:25:13.875 --> 08:25:18.592
现在我们要做yarn，在app中添加破折号。

6023
08:25:18.592 --> 08:25:26.302
到目前为止，我们运行的都是yarn add，然后不管包的名字是什么。

6024
08:25:26.302 --> 08:25:30.477
但对于我们所做的大部分工作，我们真的想做纱线添加dash Dev。

6025
08:25:30.477 --> 08:25:33.017
这其中的原因有点微妙。

6026
08:25:33.017 --> 08:25:36.124
但是我们可以在这里看到关于StackOverflow问题的一些信息。

6027
08:25:36.124 --> 08:25:39.945
主要的区别是运行项目需要依赖项。

6028
08:25:39.945 --> 08:25:43.641
而开发依赖只需要开发。

6029
08:25:43.641 --> 08:25:51.771
大部分情况下，我们只会做开发，当我们讲到这门课的前端部分时，我们会安装更多的包不仅仅是开发需要的。

6030
08:25:51.771 --> 08:25:55.760
现在在我们安装硬帽的同一个目录中，你可以运行MPX硬帽。

6031
08:25:55.760 --> 08:26:01.795
因此，关于MPX的一个简单说明是，与NPM等价的纱线只是纱线。

6032
08:26:01.795 --> 08:26:06.139
所以纱线变成NPM，相当于MPX的纱线也是纱线。

6033
08:26:06.139 --> 08:26:13.909
所以几乎任何时候你看到MPX，做点什么，你可以用纱线替换MPX，它会做完全一样的事情。

6034
08:26:13.909 --> 08:26:17.754
如果你想用NPM或MPX运行这个，你完全可以这样做。

6035
08:26:17.754 --> 08:26:20.528
对我们来说，我们要运行纱线硬帽。

6036
08:26:20.528 --> 08:26:25.793
我们会看到我们会被提示开始创建一个hardhat项目，运行yarn hardhat。

6037
08:26:25.793 --> 08:26:30.593
我们会看到这个非常可爱的提示，说欢迎来到Hardhead。

6038
08:26:30.593 --> 08:26:38.641
你想做什么，创建一个基本的示例项目，创建一个高级的示例项目，可以推进一些项目使用类型脚本或创建一个空的硬帽。

6039
08:26:38.641 --> 08:26:38.931
配置。

6040
08:26:38.931 --> 08:26:39.027
js。

6041
08:26:39.027 --> 08:26:42.337
对于我们来说，我们只需要选择创建一个基本的示例项目。

6042
08:26:42.337 --> 08:26:47.384
这将为我们提供一个非常简单的硬帽子项目的所有样板。

6043
08:26:47.384 --> 08:26:50.472
安全帽项目路径就是我们现在所在的这个文件夹。

6044
08:26:50.472 --> 08:26:53.942
你想添加一个Git。gitignore吗?是的，我们当然需要。

6045
08:26:53.942 --> 08:26:56.204
因为我们将使用。env文件。

6046
08:26:56.303 --> 08:27:02.041
你想安装这个样本项目的依赖与纱线在nomic实验室硬帽在一个理论和华夫

6047
08:27:02.041 --> 08:27:07.779
在柴?我们将继续说yes，然后我会稍微解释一下所有这些依赖关系是什么。

6048
08:27:07.779 --> 08:27:09.588
我们现在就同意吧。

6049
08:27:09.588 --> 08:27:14.350
我们会安装所有这些依赖项。

6050
08:27:14.350 --> 08:27:20.289
现在，如果我们查看我们的包JSON，我们可以看到我们添加了许多依赖项，如nomic labs, Hardhead

6051
08:27:20.289 --> 08:27:26.229
ethers，而不是MacLeods, Hardhead，华夫饼，Chai, Aetherium，华夫饼和醚。

6052
08:27:26.304 --> 08:27:29.490
显然，我们已经对醚很熟悉了，但其他的可能有点新。

6053
08:27:29.490 --> 08:27:30.735
我们稍后再谈。

6054
08:27:30.735 --> 08:27:35.654
很好，我们现在有一个示例硬帽样板项目。

6055
08:27:35.654 --> 08:27:38.004
让我们来看看我们刚刚安装的东西。

6056
08:27:38.004 --> 08:27:45.116
首先我们有一个合同文件夹，它是预先填充与问候外底是真正的简约合同在这里。

6057
08:27:45.116 --> 08:27:49.649
接下来，您将看到节点模块，这当然是我们安装的JavaScript依赖项。

6058
08:27:49.649 --> 08:27:57.890
我想知道的是因为当我第一次开始研究这个的时候它真的让我很困惑有些节点模块以加号开始，然后很多没有。

6059
08:27:57.890 --> 08:28:02.663
这两者的区别是什么呢?这些外部节点模块被称为作用域

6060
08:28:02.663 --> 08:28:07.437
包，它有效地允许NPM包成为命名空间或yarn包。

6061
08:28:07.437 --> 08:28:12.504
这允许组织明确哪些包是正式的，哪些不是。

6062
08:28:12.504 --> 08:28:17.507
例如，如果一个包在Angular中有作用域，那么它就是由Angular核心团队发布的。

6063
08:28:17.507 --> 08:28:22.293
这和我们知道的任何带有AP ens域的东西都是由ens域团队

6064
08:28:22.293 --> 08:28:27.240
完成的，任何带有异常实验室的东西都是由创建安全帽的团队完成的。

6065
08:28:27.304 --> 08:28:32.625
这就是为什么这个在nomic实验室，硬帽醚在nomic实验室，华夫有@号，

6066
08:28:32.625 --> 08:28:37.659
因为我们知道它是由nomic实验室团队发布的，然后我们有一个脚本部分。

6067
08:28:37.659 --> 08:28:44.757
我们将在这里添加我们想要编写的任何和所有脚本，比如部署契约，与契约交互等。

6068
08:28:44.757 --> 08:28:46.210
然后是一个测试文件夹。

6069
08:28:46.304 --> 08:28:48.500
我们还没有开始构建任何测试。

6070
08:28:49.304 --> 08:28:51.828
对于使用智能合约非常重要。

6071
08:28:52.305 --> 08:28:57.271
样本测试文件夹为我们提供了测试智能合约的最简单的测试。

6072
08:28:57.271 --> 08:29:03.371
我们当然有gitignore，它当然预先填充了一些重要的东西来忽略，比如Dotty和V。

6073
08:29:03.371 --> 08:29:08.105
还有节点模块因为节点模块可能会被推到GitHub上。

6074
08:29:08.105 --> 08:29:12.494
最大的变化之一就是增加了这个安全帽。

6075
08:29:12.494 --> 08:29:13.011
配置。

6076
08:29:13.011 --> 08:29:13.183
js。

6077
08:29:13.183 --> 08:29:19.216
这个文件虽然很简单，但是现在，你可以把它看作我们编写的所有脚本的入口点，

6078
08:29:19.216 --> 08:29:25.250
它是一个配置文件，它决定了我们其余的代码如何工作，以及如何与区块链交互。

6079
08:29:25.305 --> 08:29:28.605
当然，我们还有package。JSON，我们从自述文件开始。

6080
08:29:28.605 --> 08:29:34.305
还记得我们第一次运行纱线硬帽时，我们被提示了这篇入门文章。

6081
08:29:34.305 --> 08:29:42.337
现在，如果我们运行yarn Hardhead，我们实际上会得到所有不同选项和命令的输出，我们可以用它来运行hard hat。

6082
08:29:42.337 --> 08:29:50.741
现在，如果你遇到一个问题，你运行纱线，安全帽，这弹出，但你没有看到安全帽。

6083
08:29:50.741 --> 08:29:51.068
配置。

6084
08:29:51.068 --> 08:29:56.204
Js在你的文件夹中，这可能意味着在更高级别的文件夹中有一个硬帽。

6085
08:29:56.204 --> 08:30:01.662
config。js，或者在更高级别的文件夹中有一个带硬帽的节点模块。

6086
08:30:01.662 --> 08:30:07.535
如果发生了这种情况，也许可以CD到一个目录下，做一点LS，看看你是否有一个安全帽。

6087
08:30:07.535 --> 08:30:07.996
配置。

6088
08:30:07.996 --> 08:30:10.765
Js或节点模块在前面的文件夹。

6089
08:30:10.765 --> 08:30:15.474
因为我看到很多工程师在这方面都有一些不同的问题。

6090
08:30:15.474 --> 08:30:21.256
我的朋友CAMI将解释几个不同的故障排除提示，您可以尝试避免这些常见错误。

6091
08:30:21.305 --> 08:30:24.620
作为一个开发人员，最讨厌处理环境问题的是一组问题。

6092
08:30:24.620 --> 08:30:25.883
我叫卡米拉·拉莫斯。

6093
08:30:25.883 --> 08:30:30.237
我是支持图形协议的边缘节点的DevRel工程师。

6094
08:30:30.305 --> 08:30:34.406
我将向你们展示如何解决两个你们在做这个项目时可能会遇到的常见问题。

6095
08:30:34.406 --> 08:30:35.656
安装好安全帽后。

6096
08:30:35.656 --> 08:30:42.559
在新项目文件夹中运行命令和px hard hat，你会期望得到一个这样的选项菜单，但有时你不会得到它。

6097
08:30:42.559 --> 08:30:46.409
当你遇到这个错误时，有一个解决方法。

6098
08:30:46.409 --> 08:30:51.628
这通常意味着你有一个不应该在的配置文件，删除它会消除这个错误。

6099
08:30:51.628 --> 08:30:58.337
为了找到要删除的文件，你要做的是运行命令MPX hardhats space，连字符，连字符verbose。

6100
08:30:58.337 --> 08:31:04.560
如果你有文件，它会告诉你文件的位置，它会告诉你文件的确切位置，这样你就可以删除它。

6101
08:31:04.560 --> 08:31:12.240
在你删除了这个配置文件后，你应该能够在你的项目文件夹中运行MPX硬帽，并得到我们所期望的数量。

6102
08:31:12.306 --> 08:31:14.067
另一个很常见的问题。

6103
08:31:15.306 --> 08:31:21.256
时间是忘记npm安装，当你在处理别人在GitHub上做的回购时。

6104
08:31:21.306 --> 08:31:29.629
假设你正在拉下一些你和合作者一起做的代码，然后突然，它不适合你了，你可能只需要npm install。

6105
08:31:29.629 --> 08:31:36.034
所以在你的终端中，直接导航到这个项目所在的位置，然后运行npm install命令。

6106
08:31:36.034 --> 08:31:42.900
如果在您没有处理代码的时候安装了任何新的包，这些包将在

6107
08:31:42.900 --> 08:31:49.767
本地为您安装，这样当您运行代码时，它将能够成功地运行。

6108
08:31:50.306 --> 08:31:53.738
在原始状态下，我们可以用hardhat做一些主要的事情，

6109
08:31:53.738 --> 08:32:00.358
这些是我们可以用hardhat运行的一些主要任务不同的任务或者只是不同的命令，我们可以用hardhat运行。

6110
08:32:00.358 --> 08:32:07.967
例如，我们可以使用yarn hardhat计数，这将打印出我们可以使用Hardhead的假账户列表。

6111
08:32:07.967 --> 08:32:15.597
类似于我们使用ganache时使用的假账户列表，我们可以通过运行yarn Hardhead compile来编译我们的合同。

6112
08:32:15.597 --> 08:32:22.796
非常类似于我们对醚Jas和soap Jas所做的，你会看到，当我们运行compile

6113
08:32:22.796 --> 08:32:29.996
时，我们会得到一个缓存，这将是访问固体文件的一种快速方式，我们也会得到一个工件部分。

6114
08:32:29.996 --> 08:32:36.283
这个artifacts文件夹包含我们在这里查看的关于编译后的代码的所有

6115
08:32:36.283 --> 08:32:42.751
信息，例如，现在我们可以查看构建信息，并看到大量关于编译后的合同的信息。

6116
08:32:42.751 --> 08:32:46.576
如果你在看合同，我们可以看到更多的编译信息。

6117
08:32:46.576 --> 08:32:49.662
然后如果我们看一下安全帽，斜杠控制台。

6118
08:32:49.662 --> 08:32:51.695
因此，我们可以看到更多的编译信息。

6119
08:32:51.695 --> 08:32:55.687
所以我们所有的遵从性信息都将在这个artifacts文件夹中。

6120
08:32:55.687 --> 08:33:03.789
当你编译这个artifacts文件夹的时候你想看看底层发生了什么。

6121
08:33:03.789 --> 08:33:07.645
我们还可以运行一些其他的硬帽子任务。

6122
08:33:07.645 --> 08:33:10.797
但我们会边走边说的。

6123
08:33:10.797 --> 08:33:18.307
现在我们已经有了一些硬帽子的基础知识，让我们继续，试着做一些我们之前对醚做过的相同的事情，只不过是用硬帽子。

6124
08:33:18.307 --> 08:33:24.069
我们要做的第一件事就是编写智能合约并与之交互。

6125
08:33:24.069 --> 08:33:28.419
让我们把greeter。soul重命名为simple

6126
08:33:28.419 --> 08:33:34.275
storage。soul，你可以点击文件并回车，然后就可以重命名了。

6127
08:33:34.275 --> 08:33:40.815
否则，你可以继续，右键点击，删除它，然后创建一个新文件并命名为simple storage。soul。

6128
08:33:40.815 --> 08:33:45.384
我们将从之前的简单存储中复制粘贴所有的代码到这个文件中，

6129
08:33:45.384 --> 08:33:52.729
我们可以通过运行yarn hardhat compile来确保我们的简单存储正在正确编译。

6130
08:33:52.729 --> 08:33:57.721
哇，看起来我们遇到了一个项目无法编译的问题。

6131
08:33:57.721 --> 08:34:00.474
请参阅下面文件的实性编译版本的原因。

6132
08:34:00.474 --> 08:34:03.745
它与配置中的任何配置编译器都不匹配。

6133
08:34:03.745 --> 08:34:09.373
是这样的，合约/符号存储是Sol零点8。

6134
08:34:09.373 --> 08:34:09.438
8.

6135
08:34:09.438 --> 08:34:11.929
啊，好吧，让我们继续修复它们。

6136
08:34:11.929 --> 08:34:15.374
我们可以打开。config。js。

6137
08:34:15.374 --> 08:34:17.625
现在来简单介绍一下打开文件。

6138
08:34:17.625 --> 08:34:24.863
如果你在Mac上点击Command P，你就可以开始输入文件名以更快地获取文件。

6139
08:34:24.863 --> 08:34:30.077
如果你用的是Linux或Windows，你可以输入Ctrl p，这

6140
08:34:30.077 --> 08:34:35.292
会弹出有趣的是，如果你输入man p或Ctrl p然后点击大于键。

6141
08:34:35.292 --> 08:34:44.242
这将把你拉到命令面板，知道命令面板，命令面板，搜索文件，搜索命令在我们的Hardhead点配置。

6142
08:34:44.242 --> 08:34:50.082
Jas，我要向下滚动到module。exports把这个改成0。8。

6143
08:34:50.082 --> 08:34:50.178
8.

6144
08:34:50.178 --> 08:34:57.574
我们要为简单存储编译的版本，它会是相同的版本而这个硬帽在寻找。

6145
08:34:57.574 --> 08:35:04.082
让我们通过点击yarn Hardhead compile来运行相同的命令，我们看到成功编译了一个固体文件。

6146
08:35:04.082 --> 08:35:06.404
我们现在应该在工件中看到这一点。

6147
08:35:06.404 --> 08:35:08.497
如果我们去找藏物和契约。

6148
08:35:08.497 --> 08:35:13.277
我们现在在这里看到两个合同，大存储和简单存储我们可以看到大量关

6149
08:35:13.277 --> 08:35:18.058
于简单存储的信息我们还可以在信息和构建信息中看到更低级的信息。

6150
08:35:18.058 --> 08:35:23.808
好了，现在我们有了简单的存储契约，接下来我们可能要做的是学习如何部署它。

6151
08:35:23.808 --> 08:35:26.759
这是我们将要编写部署脚本的地方。

6152
08:35:26.759 --> 08:35:30.058
现在，在本节中，我将向您展示如何编写部署脚本。

6153
08:35:30.058 --> 08:35:33.262
但是在下一节，我们要做一些不同的事情。

6154
08:35:33.309 --> 08:35:36.936
但这仍然会教你如何写脚本以及如何在heart app中使用脚本。

6155
08:35:36.936 --> 08:35:44.324
我们会看到示例脚本。js，然后按回车键重命名它来部署。js。

6156
08:35:44.324 --> 08:35:50.145
如果你想阅读这里所有的评论，你完全可以，我们会把它们全部删除。

6157
08:35:50.145 --> 08:35:53.912
一个快速的键盘快捷键是，如果你按Command

6158
08:35:53.912 --> 08:35:59.809
A或Ctrl A，你会高亮显示文件中的所有文本，我们会把它们全部删除。

6159
08:35:59.809 --> 08:36:01.696
现在我们要从头开始。

6160
08:36:01.696 --> 08:36:05.715
这里部署脚本的设置和部署脚本的设置非常相似。

6161
08:36:05.715 --> 08:36:13.260
在上一节中，我们将在顶部进行导入，我们将有async main函数，然后我们将调用main函数。

6162
08:36:13.309 --> 08:36:16.636
我们来定义main函数，称它为async。

6163
08:36:16.636 --> 08:36:20.722
函数main，像这样，然后我们调用main函数。

6164
08:36:20.722 --> 08:36:26.779
如果你想从上一节复制

6165
08:36:26.779 --> 08:36:33.442
粘贴这个，你完全可以。

6166
08:36:33.442 --> 08:36:41.675
我们来定义域。

6167
08:36:42.309 --> 08:36:43.361
砰，就这样。

6168
08:36:45.309 --> 08:36:47.059
会把我逼疯的。

6169
08:36:48.309 --> 08:36:51.380
更漂亮，我们的坚固性更漂亮的插件。

6170
08:36:52.309 --> 08:36:57.997
纱线，添加破折号Dev，

6171
08:36:57.997 --> 08:37:03.212
越来越漂亮，插入固体。

6172
08:37:03.212 --> 08:37:09.242
然后我们可以继续创建。pretty,

6173
08:37:09.242 --> 08:37:15.607
rc文件，我们会添加制表符，带四个，使

6174
08:37:15.607 --> 08:37:22.643
用制表符，假，半假，然后单引号，也是假。

6175
08:37:22.643 --> 08:37:27.310
现在我们将经常使用这个更漂亮的rc文件设置。

6176
08:37:27.310 --> 08:37:31.678
在以后的课程中，如果你想复制粘贴它，你也可以这么做。

6177
08:37:31.678 --> 08:37:37.758
我们还会添加一个。pretty tier, ignore，它告诉pretty tier不要格式化某些

6178
08:37:37.758 --> 08:37:43.960
文件，我们不想让pretty tier花大量时间格式化所有文件，我将从GitHub repo复制粘贴。

6179
08:37:43.960 --> 08:37:51.276
所以你也可以从GitHub回购中复制粘贴，你会找到这部分的所有代码，就像我说的，在与这门课相关的GitHub回购中。

6180
08:37:51.310 --> 08:38:00.278
现在，与上一节不同的是，我们必须更手动地获取契约代码，使用硬帽，实际上有很多不同的方法来获取编译后的契约。

6181
08:38:00.310 --> 08:38:03.631
我们要做的第一种方法，实际上是使用醚。

6182
08:38:03.631 --> 08:38:08.465
这就是第一个令人困惑的变化。

6183
08:38:08.465 --> 08:38:12.950
之前，我们做了const ethers equals require ethers。

6184
08:38:12.950 --> 08:38:17.226
这就是我们继续研究乙醚的方法。

6185
08:38:17.226 --> 08:38:23.500
但是，您会注意到在我们的开发依赖项中，我们有一个称为Hard Hat醚的依赖项。

6186
08:38:23.500 --> 08:38:28.649
硬帽醚是一个包，实际上包装硬帽与它自己的内建醚。

6187
08:38:28.649 --> 08:38:35.738
这是非常有利的，因为它允许hard hat跟踪不同脚本的不同部署，以及为我们做的所有其他事情。

6188
08:38:35.738 --> 08:38:42.903
所以我们不是直接从醚中导入醚，而是直接从硬帽中导入醚。

6189
08:38:42.903 --> 08:38:48.293
这一开始可能会让人有点困惑，但如果我们想要用醚和心脏，

6190
08:38:48.293 --> 08:38:53.884
通常最好从心脏取出来你仍然可以这样做，醚还是一样的工作。

6191
08:38:53.884 --> 08:38:59.953
但是“硬帽”不一定知道不同的合同工厂，你们马上就会看到这一点。

6192
08:38:59.953 --> 08:39:07.117
现在我们正在引进醚，我们实际上可以立即抓住一个使用醚的合同工厂。

6193
08:39:07.117 --> 08:39:12.471
我们可以说const simple storage

6194
08:39:12.471 --> 08:39:19.111
factory = await醚。get contract。

6195
08:39:19.111 --> 08:39:22.829
工厂存储简单。

6196
08:39:22.829 --> 08:39:29.262
所以为了得到一个简单的仓库，代工厂，我们可以只做等待醚点代工厂。

6197
08:39:29.311 --> 08:39:31.721
如果我们直接从ethers中进行拉取，

6198
08:39:31.721 --> 08:39:38.573
包ethers不知道这个契约文件夹ethers也不知道我们已经编译了simple storage。soul。

6199
08:39:38.573 --> 08:39:40.277
它存在于我们的文物中。

6200
08:39:40.277 --> 08:39:44.794
另一方面，Hard Hat确实知道契约文件夹，也确实知道它已

6201
08:39:44.794 --> 08:39:49.311
经编译好了，这就是为什么这个简单的存储工厂抓取工作得如此好。

6202
08:39:49.311 --> 08:39:55.574
一旦我们有了我们的工厂，我们可以做我们在前一节中所做的相同的事情，并部署契约。

6203
08:39:55.574 --> 08:39:59.363
我们来做一个快速的console。log。

6204
08:39:59.363 --> 08:40:05.695
部署地板，契约完成，然后我们会用康德的简单存储=

6205
08:40:05.695 --> 08:40:14.138
await simple store edge factory。

6206
08:40:14.138 --> 08:40:22.053
Deploy，用这一小段代码，我们已经能够部署简单存储契约，

6207
08:40:22.053 --> 08:40:30.234
，然后等待确保它被部署，我们可以用await，简单存储，部署。

6208
08:40:30.311 --> 08:40:30.983
就是这样。

6209
08:40:33.312 --> 08:40:35.016
并运行这个部署脚本。

6210
08:40:37.312 --> 08:40:40.262
我们必须放入一个私钥，我们必须放入一个RPC URL。

6211
08:40:40.312 --> 08:40:43.562
现在，这两种情况我们都没有定义。

6212
08:40:44.312 --> 08:40:50.541
你认为这个脚本真的可以工作吗?或者你认为它会坏掉吗?因为我们没有定义我们要给你部署什么。

6213
08:40:50.541 --> 08:40:52.213
我们也没找到私钥。

6214
08:40:52.312 --> 08:40:54.778
好了，让我们来试试这个。

6215
08:40:56.312 --> 08:41:05.026
在我们的终端通过运行yarn, hard hat, run，脚本斜杠部署。j, s。

6216
08:41:05.026 --> 08:41:09.712
这里我按tab键，执行自动补全，看看会发生什么。

6217
08:41:09.712 --> 08:41:14.245
我们有部署合同，上面写着完成，但仅此而已。

6218
08:41:14.245 --> 08:41:18.249
那么到底发生了什么?我们在这里再加一行。

6219
08:41:18.312 --> 08:41:20.712
我们写console。log。

6220
08:41:24.312 --> 08:41:26.682
部署，契约到。

6221
08:41:26.682 --> 08:41:30.520
然后我们会添加简单的存储。

6222
08:41:31.312 --> 08:41:31.867
地址。

6223
08:41:31.867 --> 08:41:33.374
让我们现在运行这个。

6224
08:41:36.312 --> 08:41:40.249
我们得到了部署合同，然后我们得到了合同地址。

6225
08:41:40.312 --> 08:41:43.278
嗯，这是怎么回事。

6226
08:41:47.312 --> 08:41:53.713
Hard Hat Network是一个本地Aetherium网络节点，专为开发

6227
08:41:53.713 --> 08:42:00.279
而设计，类似于ganache，它允许您部署您的合同，运行您的测试和调试您的代码。

6228
08:42:00.312 --> 08:42:09.139
每当我们在硬帽中运行一个命令，或者一个脚本和硬帽，或者一个任务和硬帽，我们默认部署到这个假的硬帽网络。

6229
08:42:09.139 --> 08:42:16.681
这个Hard Hat Network非常类似于ganache，除了它没有这个UI，而是在我们的脚本的后台运行。

6230
08:42:16.681 --> 08:42:18.531
事实上，如果我们用安全帽。

6231
08:42:18.531 --> 08:42:18.967
配置。

6232
08:42:18.967 --> 08:42:27.113
Js中，我们可以向下滚动到这个导出section的模块底部，并添加更多关于默认网络的信息。

6233
08:42:27.113 --> 08:42:35.872
现在，如果这个模块中没有任何东西可以导出，默认情况下，它会添加这个，default network hardhat。

6234
08:42:35.872 --> 08:42:43.201
所以当我们运行一个脚本时，不指定网络，它会自动使用这个假的Hard Hat network。

6235
08:42:43.201 --> 08:42:49.041
这个假的Hard Hat Network自动附带一个RPC URL和一个私钥。

6236
08:42:49.041 --> 08:42:50.990
所以你甚至不需要加一个。

6237
08:42:50.990 --> 08:42:54.726
这是与Hardhead合作的主要优势之一。

6238
08:42:54.726 --> 08:42:57.741
它会自动给你这个假区块链。

6239
08:42:57.741 --> 08:43:01.205
这些假私钥，如果你想更明确一点的话。

6240
08:43:01.205 --> 08:43:07.590
我总是建议更明确一点，我们可以将默认网络添加到专家模块中。

6241
08:43:07.590 --> 08:43:11.154
现在我们的默认网络被显式地声明为hard hat。

6242
08:43:11.154 --> 08:43:15.877
但是，在您运行的任何脚本中，您都可以选择想要使用的任何网络。

6243
08:43:15.877 --> 08:43:22.093
如果我想明确地说，我想在假的Hard Hat网络上运行我们的deploy

6244
08:43:22.093 --> 08:43:27.791
脚本，我可以用yarn，运行脚本，deploy。js, dash,

6245
08:43:27.791 --> 08:43:34.872
Network，这是我们告诉她，嘿，我们想在Hard Hat网络上运行这个脚本。

6246
08:43:34.872 --> 08:43:37.829
希望你们能明白这是怎么回事。

6247
08:43:37.829 --> 08:43:46.027
有了这个网络标志，在不同的链、不同的区块链、不同的私钥等之间切换变得非常容易。

6248
08:43:46.027 --> 08:43:51.264
我们在硬帽上设置了默认网络，我们还可以在这里添加其他网络。

6249
08:43:51.314 --> 08:43:56.230
我们要做的是增加一个网络部分。

6250
08:43:56.314 --> 08:43:58.536
我们要定义任何我们想要的网络部分。

6251
08:43:58.536 --> 08:44:03.434
记得在这里加个注释这样你的Visual Studio代码就不会对你发火了。

6252
08:44:03.434 --> 08:44:08.823
最近，我们和里格比合作我们在这里添加一个里格比网络。

6253
08:44:08.823 --> 08:44:13.001
所以我们会说另一家电视台会很酷。

6254
08:44:13.001 --> 08:44:21.035
现在我应该可以把网络标志改为Rigby了，对吧?嗯，不完全是。

6255
08:44:21.035 --> 08:44:28.830
如果你试着运行它，你会得到无效值未定义的硬帽配置网络。

6256
08:44:28.830 --> 08:44:33.722
Rigby，那个URL，它希望你告诉它，嘿，URL是什么，因

6257
08:44:33.722 --> 08:44:38.614
为这不是硬帽网络，我们需要告诉硬帽我们要如何连接到溜冰场B。

6258
08:44:38.614 --> 08:44:44.720
这就是我们之前学过的很多东西会派上用场的地方，同样，和我们之前做的完全一样。

6259
08:44:44.720 --> 08:44:51.861
我们将创建一个新的Dotty v文件，我们将在这个。env文件中添加Rigby URL。

6260
08:44:51.861 --> 08:44:55.847
记住，。env是r。get忽略以防万一。

6261
08:44:55.847 --> 08:45:02.091
在我们的Dotty环境中，我们会从alcmi添加那个RPC URL在我们说RPC URL之前。

6262
08:45:02.091 --> 08:45:10.647
但由于我们可能希望跨多个网络工作，所以最好准确指定每个URL所代表的网络。

6263
08:45:10.647 --> 08:45:17.456
我们写入Rynkeby RPC URL =然后将URL粘贴到这里。

6264
08:45:17.456 --> 08:45:22.914
现在，你可能已经猜到了，我们可以把我们的URL添加到我们的Rinkeby网络。

6265
08:45:22.914 --> 08:45:28.126
为了可读性，我通常喜欢将它们作为变量添加到专家模块的正上方。

6266
08:45:28.126 --> 08:45:30.517
我写上const Rynkeby。

6267
08:45:30.517 --> 08:45:31.403
RPC

6268
08:45:31.403 --> 08:45:39.970
URL等于进程点E和V点Rynkeby RPC URL。

6269
08:45:40.315 --> 08:45:45.695
再一次，我们会从环境变量中提取那个Rinckey RPC URL。

6270
08:45:45.695 --> 08:45:51.429
当然，为了把那个环境变量拉进来，我们需要再次使用那个。env包。

6271
08:45:51.429 --> 08:45:56.380
为了把它添加进去，我们要添加dash dev。EMV。

6272
08:45:56.380 --> 08:46:00.743
在Hardhead配置的顶部，

6273
08:46:00.743 --> 08:46:09.179
我们会添加require。EMV，然后做。配置来启用配置。

6274
08:46:09.179 --> 08:46:13.781
现在这意味着我们应该能够从我们的点环境中拉我们的rink RPC URL。

6275
08:46:13.781 --> 08:46:21.205
现在我们有了在我们的Rinkeby网络，我们可以添加URL Rinckey RPC URL。

6276
08:46:21.315 --> 08:46:21.653
太棒了。

6277
08:46:21.653 --> 08:46:23.782
我们有一个用于不同网络的RPC URL。

6278
08:46:24.315 --> 08:46:30.899
我们通常还需要什么?嗯，我们通常需要一个私钥来使用一个实际的网络，或者它不会自动给我们一个橄榄

6279
08:46:30.899 --> 08:46:37.625
球的私钥，因为Hardhead不能只给我们测试和以太，我们需要一个实际的帐户一个实际的测试网络。

6280
08:46:37.625 --> 08:46:39.762
硬脑党控制不了这些。

6281
08:46:39.762 --> 08:46:43.121
我们需要给它一个真实的URL和一个真实的私钥。

6282
08:46:43.121 --> 08:46:48.556
要添加私钥，你需要添加一个叫做账户的东西，你需要添加一个你

6283
08:46:48.556 --> 08:46:53.992
想给硬帽的账户列表，我们只需要添加一个，这就是我们的私钥。

6284
08:46:53.992 --> 08:46:56.901
对于私钥，我们会做完全相同的事情。

6285
08:46:56.901 --> 08:47:03.569
我们说const private key = process。env。private key。

6286
08:47:03.569 --> 08:47:12.269
因为这个私钥是真实测试网的真实私钥，我们需要从元掩码中获取这个。

6287
08:47:12.316 --> 08:47:20.225
它会到元掩码，三个点，账户详细信息，导出私钥，然后在这里添加密码。

6288
08:47:20.316 --> 08:47:26.008
然后在。env中加上私钥=然后加上私钥。

6289
08:47:26.008 --> 08:47:31.779
现在我知道我已经说过100次了，但是为了学习这个，请不要

6290
08:47:31.779 --> 08:47:37.758
使用连接任何真钱的真密钥，以防万一，请使用一个新的元掩码。

6291
08:47:37.758 --> 08:47:39.282
我知道我说过很多次了。

6292
08:47:39.282 --> 08:47:42.125
但有些人会说，不，我会没事的，我会很安全的。

6293
08:47:42.125 --> 08:47:46.231
为了超级超级安全，请使用全新的元遮罩。

6294
08:47:46.231 --> 08:47:50.848
现在我们有了私钥，我们要把它加到这里帐户私钥。

6295
08:47:50.848 --> 08:47:52.396
现在我们有了一个账户。

6296
08:47:52.396 --> 08:47:58.343
我还想做的一件事是给出网络的链ID，对于里格比来说，

6297
08:47:58.343 --> 08:48:07.037
这将是每一个EVM基网络的新链ID EVM网络基本上意味着它的坚固性起作用。

6298
08:48:07.037 --> 08:48:11.066
这包括所有的测试网，有一个很好的网站叫chainless。

6299
08:48:11.066 --> 08:48:16.052
Org，它可能会关闭，也可能不会关闭，它有一个不同网络的列表。

6300
08:48:16.052 --> 08:48:21.725
例如，你可以在这里看到一个理论主网有一个字节的链ID和智能链

6301
08:48:21.725 --> 08:48:27.399
是56，雪崩，4311幻影，歌剧250，多边形，137等等。

6302
08:48:27.399 --> 08:48:31.867
每一个与EVM兼容的链都有自己的链ID，

6303
08:48:31.867 --> 08:48:37.899
等级为V，链ID用于添加链ID，对后面的内容很有帮助。

6304
08:48:37.899 --> 08:48:39.300
我们以后会讲到这个。

6305
08:48:39.300 --> 08:48:41.792
但现在，请确保添加了链id。

6306
08:48:41.792 --> 08:48:46.574
好的，现在我们有了RPC URL，我们有了私钥，我们可以继续测

6307
08:48:46.574 --> 08:48:51.512
试将它部署到一个实际的测试网络，实际上在这里做了一些错误的事情。

6308
08:48:51.512 --> 08:48:53.184
我们会在这里得到一个错误。

6309
08:48:53.184 --> 08:48:58.248
我希望你们自己去找出并调试这个错误。

6310
08:48:58.317 --> 08:48:59.254
你准备好了。

6311
08:48:59.254 --> 08:49:00.894
好吧，我们开始吧。

6312
08:49:03.317 --> 08:49:09.768
脚本，部署点j s，破折号网络Rinkeby。

6313
08:49:11.317 --> 08:49:16.850
这个奇怪的错误，我们已经部署了契约。

6314
08:49:16.850 --> 08:49:24.203
我们知道，在部署脚本中，我们至少到达这一行，然后我们会得到一个错误，我

6315
08:49:24.203 --> 08:49:31.768
很可能会听到，不能读取属性没有读取发送事务，如果你想，你完全可以到这里。

6316
08:49:31.768 --> 08:49:38.546
但它似乎很难理解私钥或账户是什么。

6317
08:49:38.546 --> 08:49:46.710
你觉得我会建议我们怎么做呢?如果不清楚的话，在做了一些分类和调试之后，我们将复制这个空气。

6318
08:49:46.710 --> 08:49:50.418
我们来到谷歌，把它粘贴进去。

6319
08:49:50.418 --> 08:49:55.398
看起来我们确实从stackexchange Etherium那里得到了一个问题。

6320
08:49:55.398 --> 08:49:58.523
看起来和我们现在做的很像。

6321
08:49:58.523 --> 08:49:59.475
我们向下滚动。

6322
08:49:59.475 --> 08:50:05.269
他们运行的脚本和我们几乎完全一样，他们使用MPX而不是yarn。

6323
08:50:05.269 --> 08:50:08.189
他们有一个非常简单的部署文件。

6324
08:50:08.317 --> 08:50:11.017
让我们向下滚动，看看答案都说了些什么。

6325
08:50:11.317 --> 08:50:14.178
看到我的私钥没有正确填充的错误。

6326
08:50:14.317 --> 08:50:18.575
也会使用环境变量我很确定环境变量有用吗

6327
08:50:18.575 --> 08:50:24.592
但是我们在你的脑海里有第二个想法，Jas，我认为它应该是帐户而不是帐户，

6328
08:50:24.592 --> 08:50:30.442
这对我来说是有效的，让我们回到我们的头部配置，看看这是不是真的发生了。

6329
08:50:30.442 --> 08:50:33.280
嗯，我们把account放在这里，应该是account。

6330
08:50:33.280 --> 08:50:34.762
我们把它换到账户上。

6331
08:50:34.762 --> 08:50:36.150
我们会清空终点站。

6332
08:50:36.150 --> 08:50:37.675
我们再运行一遍。

6333
08:50:37.675 --> 08:50:38.175
嗯嗯。

6334
08:50:38.175 --> 08:50:41.937
现在它的读数变长了一点，这很好。

6335
08:50:41.937 --> 08:50:45.979
这意味着我们可能会把它部署到B溜冰场，这是我们想看到的。

6336
08:50:45.979 --> 08:50:46.348
太棒了。

6337
08:50:46.348 --> 08:50:51.055
现在我们可以看到部署合同到，这里有一个合同地址。

6338
08:50:51.055 --> 08:50:52.518
所以我们要拿到这份合同。

6339
08:50:52.518 --> 08:50:56.365
我们来看看以太扫描，这就是以太扫描的编号。

6340
08:50:56.365 --> 08:50:58.528
我们继续，把这个粘贴进去。

6341
08:50:58.528 --> 08:50:58.949
太棒了。

6342
08:50:58.949 --> 08:51:02.416
我们的合同是26秒前创建的。

6343
08:51:02.416 --> 08:51:02.940
完美的。

6344
08:51:02.940 --> 08:51:07.794
现在对于这部分，你不必把它部署到溜冰场跟我一起，如果你跟着我。

6345
08:51:07.794 --> 08:51:08.698
这就足够了。

6346
08:51:08.698 --> 08:51:11.603
所以请记住，飞行测试需要很长时间。

6347
08:51:11.603 --> 08:51:14.718
所以这次，你不用和我一起部署。

6348
08:51:14.718 --> 08:51:16.218
好了,好了。

6349
08:51:16.218 --> 08:51:20.068
所以我们在溜冰场部署了安全帽。

6350
08:51:20.068 --> 08:51:21.032
这太棒了。

6351
08:51:21.032 --> 08:51:27.275
现在我们注意到，我们的合同没有得到验证?我们是否需要重新检查

6352
08:51:27.275 --> 08:51:33.518
并验证并发布所有这些内容?幸运的是，我们实际上不需要这样做。

6353
08:51:33.518 --> 08:51:40.753
那么我们能做什么呢?好了，回到部署脚本中，我们可以添加一些代码，以便在部署后立即进行自动验证。

6354
08:51:40.753 --> 08:51:42.204
我们来做一下。

6355
08:51:42.204 --> 08:51:50.484
在主函数的正下方，我们会创建一个新函数，叫verify，我们会写async function, verify。

6356
08:51:50.484 --> 08:51:55.418
我们要让这个函数通过一些参数，我们

6357
08:51:55.418 --> 08:52:00.644
要通过契约，地址，和一些参数或契约。

6358
08:52:00.644 --> 08:52:05.645
因为简单存储没有构造函数，所以简单存储的参数是空的。

6359
08:52:05.645 --> 08:52:11.842
但在未来，当我们有契约有构造函数时，实参将被填充。

6360
08:52:11.842 --> 08:52:16.550
当我们到达那里时，你会明白我的意思，我们至少需要合同地址，

6361
08:52:16.550 --> 08:52:20.934
我们会在这里添加一些代码来在部署后自动验证我们的合同。

6362
08:52:20.934 --> 08:52:25.590
这种自动验证过程适用于以太扫描等块探测器，但可能不

6363
08:52:25.590 --> 08:52:30.247
适用于eath、pler或其他块探测器等块探测器。

6364
08:52:30.247 --> 08:52:35.652
但如果你想在这些其他的块探索器上进行验证，我相信它们也有一个API允许你这样做。

6365
08:52:35.652 --> 08:52:44.319
现在，ether scan在大多数其他区块探索者的网站上都有一个部分叫做API文档，或者与API相关的东西。

6366
08:52:44.319 --> 08:52:49.022
这些是我们通过编程与以太扫描交互的方法，并用它们来做一些事情。

6367
08:52:49.022 --> 08:52:55.284
我们能做的主要事情之一是我们能通过这个API验证我们的契约。

6368
08:52:55.284 --> 08:52:59.852
以太扫描在这里甚至有一个教程叫做以编程方式验证契约。

6369
08:52:59.852 --> 08:53:07.207
这个的链接会在GitHub回购中，他们有一个API端点我们可以向它发出一些请求来验证我们的合同。

6370
08:53:07.207 --> 08:53:11.533
现在，我们完全可以进行原始API调用并遵循这里的教程。

6371
08:53:11.533 --> 08:53:15.790
但实际上有一种比本教程更简单的方法。

6372
08:53:15.790 --> 08:53:21.254
Hardhead是一个可扩展的框架，这意味着您可以向其添加插件。

6373
08:53:21.319 --> 08:53:25.105
文档中甚至有一个高级部分叫做构建插件。

6374
08:53:25.105 --> 08:53:32.132
如果我们向下滚动到底部，我们可以看到nomic labs团队或Hardhead团队创建的一些流行插件。

6375
08:53:32.132 --> 08:53:34.456
还有一些社区插件。

6376
08:53:34.456 --> 08:53:42.013
最常用的Hardhead插件之一将是这个硬帽以太扫描插件，使这个验证过程非常非常容易。

6377
08:53:42.013 --> 08:53:50.384
安装它，你可以运行npm Install bash，把dev保存在nomic labs harden ether scan，然后把它添加到我们的hard hat。config中。

6378
08:53:50.384 --> 08:53:53.709
既然我们用的是纱线，我们就继续用纱线。

6379
08:53:53.709 --> 08:53:59.509
回到我们的代码，我们会做yarn，添加破折号Dev,

6380
08:53:59.509 --> 08:54:06.425
at nomic, labs，斜杠硬帽斜杠连字符，以太扫描。

6381
08:54:06.425 --> 08:54:14.184
现在我们有了这个插件，我们可以去我们的硬帽点配置，滚动到顶部，添加这个插件do

6382
08:54:14.184 --> 08:54:23.336
require at nomic labs / hard hat, ether scan。

6383
08:54:23.336 --> 08:54:28.497
现在我们有了这个插件，硬帽文档有更多关于用法的信息，

6384
08:54:28.497 --> 08:54:33.658
如何实际使用这个插件，以及如何使用它运行不同的命令。

6385
08:54:33.658 --> 08:54:38.227
为了让我们使用这种验证，我们实际上需要一个来自以太扫描的API密钥。

6386
08:54:38.227 --> 08:54:42.746
这基本上是一个密码，允许我们使用以太扫描API。

6387
08:54:42.746 --> 08:54:44.981
接下来我们要讲以太扫描。

6388
08:54:44.981 --> 08:54:47.014
现在我们要去签到了。

6389
08:54:47.014 --> 08:54:51.256
我们要点击注册并创建一个账户。

6390
08:54:51.320 --> 08:54:53.320
我们将继续创建一个帐户。

6391
08:54:54.320 --> 08:54:57.268
通过单击验证链接来验证我们的注册。

6392
08:54:57.320 --> 08:54:58.591
然后点击登录。

6393
08:54:58.591 --> 08:54:59.862
现在我们已经登录了。

6394
08:55:00.320 --> 08:55:02.582
在左手边，我们可以向下滚动到API键。

6395
08:55:03.320 --> 08:55:06.320
，并创建一个新的API密钥。

6396
08:55:09.320 --> 08:55:11.270
它代表着硬帽自由代码营。

6397
08:55:12.320 --> 08:55:18.695
key会复制这个，然后回到我们的代码，我们会把这个添加到某个地方，因为API key基本上被认为是密码。

6398
08:55:18.695 --> 08:55:22.029
你觉得我们应该把这个加在哪里?它就在。env中。

6399
08:55:22.029 --> 08:55:27.739
在。env中，我们会添加一个新条目ether scan API key。

6400
08:55:27.739 --> 08:55:32.133
我们会添加刚得到的那个API键。

6401
08:55:32.133 --> 08:55:39.335
现在我们有了API键，回到Hardhead的配置中，我们要在模块。exports中创建一个新节，

6402
08:55:39.335 --> 08:55:46.237
告诉hardhat我们有这个ether scan API键，或者新节叫ether scan。

6403
08:55:46.321 --> 08:55:51.370
在这里，我们会说API key is going to ether

6404
08:55:51.370 --> 08:55:56.880
scan API key我们会在这里定义它和我们定义其他键的方式一样。

6405
08:55:56.880 --> 08:56:04.493
因此我们写入const, ether scan API key = process。env。ether scan API key。

6406
08:56:04.493 --> 08:56:11.633
如果出现这样的东西，你可以按回车键，它会自动补全，这很好。

6407
08:56:11.633 --> 08:56:12.008
太好了。

6408
08:56:12.008 --> 08:56:19.921
现在我们有一个以太扫描API键在心脏文档中，它告诉我们通过添加这个，我们得到一个新任务叫verify。

6409
08:56:19.921 --> 08:56:21.302
让我们试一下。

6410
08:56:21.302 --> 08:56:23.676
打开我们的终端。

6411
08:56:23.676 --> 08:56:25.879
我们会做纱线，RT帽。

6412
08:56:25.879 --> 08:56:27.894
让我们看看会出现什么。

6413
08:56:27.894 --> 08:56:31.172
哇，我们确实有了新的证据。

6414
08:56:31.172 --> 08:56:35.476
当我们使纱线硬帽更用力时，它实际上会看到我们的硬帽。

6415
08:56:35.476 --> 08:56:35.786
配置。

6416
08:56:35.786 --> 08:56:37.286
Js和检查任何插件。

6417
08:56:37.286 --> 08:56:42.003
如果有新的插件，它会添加它们作为我们可以做的新任务。

6418
08:56:42.003 --> 08:56:47.237
您可以通过执行yarn或MPX Harnett验证破折号

6419
08:56:47.237 --> 08:56:52.659
网络、部署的合同地址和任何构造函数参数来手动验证您的合同。

6420
08:56:52.659 --> 08:56:55.830
但我们想要比这更程序化一点。

6421
08:56:55.830 --> 08:57:01.637
我们要做的是返回去创建这个验证函数，知道如何通过命令行来做是很好

6422
08:57:01.637 --> 08:57:07.626
的如果你将来想手动验证某些东西，你可以，让我们来创建这个验证函数。

6423
08:57:07.626 --> 08:57:11.033
我们将使用我们的合同地址和一些论点。

6424
08:57:11.033 --> 08:57:15.741
为了我们的目的，我们要做console。log

6425
08:57:15.741 --> 08:57:20.655
验证契约这样我们就知道我们可能需要等待一段时间。

6426
08:57:20.655 --> 08:57:27.644
在我们的代码中，我们可以使用运行包从硬帽运行任何任务。

6427
08:57:27.644 --> 08:57:35.966
在最上面，我们会从硬帽导入run run允许我们运行任何硬帽任务。

6428
08:57:35.966 --> 08:57:40.845
在我们的代码中，我们会做一个等待运行。

6429
08:57:40.845 --> 08:57:43.857
然后我们就可以这样做了。

6430
08:57:43.857 --> 08:57:47.773
现在它允许你在运行中添加不同的参数。

6431
08:57:47.773 --> 08:57:53.870
通常最好的做法是把它们加到这里这样我们就能清楚地知道我们在做什么。

6432
08:57:53.870 --> 08:58:00.795
如果我们做yarn hardhat验证破折号帮助，我们可以看到我们实际上可以传递什么参数。

6433
08:58:00.795 --> 08:58:03.625
看起来我们可以传递Verify参数。

6434
08:58:03.625 --> 08:58:05.303
我们用冒号来验证。

6435
08:58:05.303 --> 08:58:13.127
如果你去到GitHub的验证任务，你会发现你能做的不仅仅是验证，你能做验证，获取最

6436
08:58:13.127 --> 08:58:20.951
小构建，验证，获取构造函数参数，验证，验证，这是我们要处理的，还有一些其他子任务。

6437
08:58:20.951 --> 08:58:26.016
进入run的第二个参数将是一个实际参数的列表。

6438
08:58:26.016 --> 08:58:29.949
第二个参数是验证任务的子任务。

6439
08:58:29.949 --> 08:58:33.550
这将是一个包含实际参数的对象。

6440
08:58:33.550 --> 08:58:40.529
这里我们传入一个地址，这将是我们的契约

6441
08:58:40.529 --> 08:58:47.877
地址，然后是我们的构造或参数，这将是弧。

6442
08:58:47.877 --> 08:58:53.075
通常，这里的这个就足够我们在main函数中使

6443
08:58:53.075 --> 08:58:58.273
用这个验证契约了，但我们还要再添加一个东西。

6444
08:58:58.323 --> 08:59:00.667
因为在实践中，有时会出现一些错误。

6445
08:59:00.667 --> 08:59:05.144
运行等待时经常出现的错误之一是契约已经经过了验证。

6446
08:59:05.144 --> 08:59:10.983
实际上你很可能会遇到这种情况，因为以太扫描会变得足够智能，通过看到足够多的字节

6447
08:59:10.983 --> 08:59:16.823
码，这些字节码完全是简单的存储，它会开始自动验证任何看起来像简单存储的字节码。

6448
08:59:16.823 --> 08:59:20.751
然后这个await会抛出一个错误，这是我们想避免的。

6449
08:59:20.751 --> 08:59:26.886
我们能做的是在这个await上添加一个try catch。

6450
08:59:26.886 --> 08:59:29.385
在外面，我们要加一个try。

6451
08:59:29.385 --> 08:59:33.688
我们要加上这些小托架来包裹我们的重量。

6452
08:59:33.688 --> 08:59:36.880
然后我们要把球接住。

6453
08:59:36.880 --> 08:59:42.291
这被称为尝试，捕捉和固体也有尝试捕捉。

6454
08:59:42.291 --> 08:59:46.465
但基本上，这个e将是这部分抛出的任何错误。

6455
08:59:46.465 --> 08:59:52.688
所以我们要做的是我们会说如果这个消息已经被验证了，那么我们就继续。

6456
08:59:52.688 --> 08:59:53.797
我们说if e。

6457
08:59:53.797 --> 08:59:54.627
消息。

6458
08:59:54.627 --> 08:59:59.036
到小写，我们要确保它是

6459
08:59:59.036 --> 09:00:03.846
小写那已经包含在那里了。

6460
09:00:03.846 --> 09:00:12.026
如果是5，我们就会用console。log这样。

6461
09:00:12.026 --> 09:00:15.854
否则，就写成console。log e。

6462
09:00:15.854 --> 09:00:22.909
我们这样做的原因是因为这些错误，我们的验证函数将中断，我们的整个脚本将结束。

6463
09:00:22.909 --> 09:00:28.909
我们不希望整个脚本结束，我们希望如果验证不成功，我们的脚本还能继续，因为这没什么大不了的。

6464
09:00:28.909 --> 09:00:35.291
我知道这看起来像很多代码，请随意从GitHub repo复制粘贴它，继续。

6465
09:00:35.291 --> 09:00:36.065
但是太棒了。

6466
09:00:36.065 --> 09:00:40.609
因此，我们现在有了一个使用hardhat中的verify任务的验证函数。

6467
09:00:40.609 --> 09:00:49.098
让我们在主函数中使用这个，就在deploy下面，我们写console。log deployte2，然后是契约地址。

6468
09:00:49.098 --> 09:00:53.609
但在我们调用这个main函数之前，让我们快速思考一下。

6469
09:00:53.609 --> 09:01:02.021
当我们部署到RT Hat网络时会发生什么?嗯，记住，如果我们部署到我们的硬帽网络，我们的合同需要验证我需要扫

6470
09:01:02.021 --> 09:01:10.590
描吗?我们知道有一个我们知道有一个冰场以太扫描，我们知道有一个COVID以太扫描，我们知道有一个主网简易扫描。

6471
09:01:10.590 --> 09:01:14.190
但有硬头牌以太扫描吗?不，当然不是。

6472
09:01:14.324 --> 09:01:19.035
对吧?硬运行时环境是我们机器的本地网络。

6473
09:01:19.035 --> 09:01:23.942
因此，我们在以太扫描上验证硬帽网络部署合同是没有意义的。

6474
09:01:23.942 --> 09:01:29.799
当我们使用本地网络时，我们实际上不想调用这个verify函数。

6475
09:01:29.799 --> 09:01:33.001
这就是链id非常有用的地方。

6476
09:01:33.001 --> 09:01:40.272
我们能做的是检查我们运行的网络是一个活动网络还是一个测试网络，或者它是一

6477
09:01:40.272 --> 09:01:47.544
个实际上可以被验证的网络，我们可以通过导入这样的网络来获得网络配置信息。

6478
09:01:47.544 --> 09:01:55.040
我们可以做console。log network。config。

6479
09:01:55.040 --> 09:01:59.569
现在，如果我运行yarn, art，点击运行脚本部署。

6480
09:01:59.569 --> 09:01:59.744
js。

6481
09:01:59.744 --> 09:02:07.696
在我们的硬帽网络中，因为我没有传递网络标志，我们得到了像这样的大量输出。

6482
09:02:07.696 --> 09:02:11.544
我们的网络点配置包含大量关于当前网络的信息，

6483
09:02:11.544 --> 09:02:19.589
你会在这里看到Hardhead网络的链ID实际上是31337天然气价格，它被设置为自动阻塞天

6484
09:02:19.589 --> 09:02:25.712
格，它被设置为自动阻塞天然气限制当前的Aetherium，我们正在工作，以及所有这些其他部分。

6485
09:02:25.712 --> 09:02:27.798
这个链ID非常重要。

6486
09:02:27.798 --> 09:02:33.158
因为我们可以用这个链ID来判断哪个是测试网，哪个是活动网络。

6487
09:02:33.158 --> 09:02:38.435
记住，运行这个脚本和运行破折号网络是一样的，

6488
09:02:38.435 --> 09:02:43.234
你会看到我们的频道ID仍然是31337。

6489
09:02:43.234 --> 09:02:48.944
再说一次，那是因为我们心中的默认网络有配置，它是硬帽，也就是说，

6490
09:02:48.944 --> 09:02:54.477
每次我们运行一个脚本时，我们都在偷偷地用破折号网络硬帽运行它。

6491
09:02:54.477 --> 09:02:56.815
现在我们只需要在测试网上验证。

6492
09:02:56.815 --> 09:03:02.521
我们能做的是，如果network。config，那

6493
09:03:02.521 --> 09:03:08.228
个chain ID等于等于等于4，也就是B。ad。

6494
09:03:08.325 --> 09:03:14.975
JavaScript的等号和等号几乎是一样的，只是没有

6495
09:03:14.975 --> 09:03:20.886
进行类型转换，这意味着在JavaScript中，

6496
09:03:20.886 --> 09:03:28.769
4等于4,4等于字符串4，但如果你使用4等于等于4，这是错误的。

6497
09:03:28.769 --> 09:03:34.751
这是真的= = 4 = = =也为真，4 = = =

6498
09:03:34.751 --> 09:03:40.734
字符串4也为真，但4 = = = =字符串4将为假。

6499
09:03:40.734 --> 09:03:43.954
你可以在这里做任何你想做的事。

6500
09:03:43.954 --> 09:03:48.870
我们想说，如果network。config。Trinity

6501
09:03:48.870 --> 09:03:53.786
是4，如果我们在Rinkeby，那么我们可以继续进行验证。

6502
09:03:53.786 --> 09:03:59.611
但我们还希望确保只验证以太扫描API键是否存在。

6503
09:03:59.611 --> 09:04:02.328
所以我们也可以在这里是site，

6504
09:04:02.328 --> 09:04:09.801
这个双&的意思是我们可以说process。env。ether scan API key。

6505
09:04:09.801 --> 09:04:16.507
这是我们在这里做的一些布尔技巧，基本上，我们的第一个条件我们说如果network。

6506
09:04:16.507 --> 09:04:23.868
config chinati等于等于等于4，这个部分可以是真或假，很明显，对吧?我们运行的

6507
09:04:23.868 --> 09:04:31.067
行的链ID可能是最难的网络，这意味着这个不等于4，或者是Rinckey，这意味着这个等于4。

6508
09:04:31.067 --> 09:04:33.136
但这一边没有条件。

6509
09:04:33.136 --> 09:04:40.402
那么这一边是怎么工作的呢?在JavaScript中，如果一个对象存在，并且您试图将其转换为布尔值，那么它将被转换为true。

6510
09:04:40.402 --> 09:04:43.289
如果它不存在，它将被转换为false。

6511
09:04:43.289 --> 09:04:51.563
在JavaScript中，如果任何一个scan API key存在，如果VI中的数据中有这个，这就成立。

6512
09:04:51.563 --> 09:04:53.676
如果不是，这就是假的。

6513
09:04:53.676 --> 09:04:58.514
另一种解读这一行的方式是如果network。config

6514
09:04:58.514 --> 09:05:06.808
Trinity是为AKA准备的，如果我们在溜曲棍场B上，以太扫描API键存在，然后做一些事情。

6515
09:05:06.808 --> 09:05:08.459
这就是我们要做的。

6516
09:05:08.459 --> 09:05:09.319
在这里，

6517
09:05:09.319 --> 09:05:23.084
我们要运行verify函数并将合约地址传递给它它将是Simple Storage。address构造函数参数我们知道它将是空的。

6518
09:05:23.084 --> 09:05:31.262
因为verify函数是async函数，它处理承诺之类的，我们要在这里添加await关键字。

6519
09:05:31.326 --> 09:05:31.664
太棒了。

6520
09:05:34.327 --> 09:05:35.850
但我们还没有完成。

6521
09:05:38.327 --> 09:05:45.241
在我们部署合同和发送合同的瞬间，以太扫描可能还不知

6522
09:05:45.241 --> 09:05:52.432
道交易，以太扫描可能需要一秒钟才能跟上区块链的位置。

6523
09:05:52.432 --> 09:05:59.165
因此，最好的做法是等待几个区块被挖出，直到真正运行验证过程。

6524
09:05:59.165 --> 09:06:02.670
我们实际上已经学习了如何使用部署事务做到这一点。

6525
09:06:02.670 --> 09:06:10.233
在我们验证运行之前，我们想运行一个权值，简单的存储。

6526
09:06:10.327 --> 09:06:14.458
部署事务等等，6。

6527
09:06:19.327 --> 09:06:21.184
然后我们将运行我们的验证过程。

6528
09:06:22.327 --> 09:06:24.638
现在测试一下，你完全可以。

6529
09:06:25.327 --> 09:06:30.447
继续，因为再次强调，在测试网上测试所有这些需要额外的时间。

6530
09:06:30.447 --> 09:06:36.654
我要完成剩下的main函数，然后我要把所有的都运行起来。

6531
09:06:36.654 --> 09:06:37.602
好的,很酷。

6532
09:06:37.602 --> 09:06:43.704
我们已经部署了我们的契约，我们已经自动地通过编程验证了我们的契约。

6533
09:06:43.704 --> 09:06:49.445
接下来是什么?上次我们做了什么，我们开始与合约互动。

6534
09:06:49.445 --> 09:06:50.903
我们来做const。

6535
09:06:50.903 --> 09:06:57.016
当前值等于等待简单的存储点检索。

6536
09:06:57.016 --> 09:07:01.562
获取当前值，简单的存储，仅此而已。

6537
09:07:01.562 --> 09:07:08.408
我们有一个检索函数，它返回喜爱的数字，所以让我们获取当前值。

6538
09:07:08.408 --> 09:07:14.596
我们写console。log，当前

6539
09:07:14.596 --> 09:07:20.784
值是然后是一些字符串插值，当前值。

6540
09:07:20.784 --> 09:07:28.394
然后我们继续通过做cons来更新当前值。

6541
09:07:28.394 --> 09:07:35.001
事务响应等于等待简单存储，该存储将

6542
09:07:35.001 --> 09:07:41.997
存储数字7，然后我们将等待事务响应。

6543
09:07:41.997 --> 09:07:48.994
等待，我们将等待一个块，让事务通过。

6544
09:07:48.994 --> 09:07:54.983
我们会通过说const updated value = await

6545
09:07:54.983 --> 09:08:00.972
simple storage。retrieve来获取更新后的值。

6546
09:08:00.972 --> 09:08:06.700
然后我们将做控制台日志。

6547
09:08:06.700 --> 09:08:12.128
新增的值为更新后的值。

6548
09:08:12.128 --> 09:08:12.620
太棒了。

6549
09:08:12.620 --> 09:08:15.143
这就是我们的整个脚本。

6550
09:08:15.328 --> 09:08:20.051
如果我把它缩小一点，我知道这里会小一点，我们有一

6551
09:08:20.051 --> 09:08:24.972
个巨大的主函数，它是做什么的?它部署了我们的契约。

6552
09:08:24.972 --> 09:08:28.182
如果我们在一个测试网上，它会验证我们的契约。

6553
09:08:28.182 --> 09:08:30.489
然后它将值更新为7。

6554
09:08:30.489 --> 09:08:33.198
下面是验证函数。

6555
09:08:33.328 --> 09:08:37.734
我们有一段代码调用main函数。

6556
09:08:37.734 --> 09:08:39.818
现在在硬帽网络上运行这个。

6557
09:08:39.818 --> 09:08:44.819
你认为会发生什么?让我们试试yarn，或者net run脚本。

6558
09:08:44.819 --> 09:08:45.871
部署点j s。

6559
09:08:45.871 --> 09:08:50.927
好了，很好，我们得到了之前看到的情况我们得到

6560
09:08:50.927 --> 09:08:55.984
了部署契约部署契约到当前值为0，更新值为7。

6561
09:08:55.984 --> 09:08:57.777
这里没有关于验证的内容。

6562
09:08:57.777 --> 09:08:59.234
这正是我们想要的。

6563
09:08:59.234 --> 09:09:00.818
现在是关键时刻。

6564
09:09:00.818 --> 09:09:03.040
让我们在Rinkeby身上试试这个。

6565
09:09:03.040 --> 09:09:11.777
我们会做yarn, RT hat运行脚本，部署。j s, dash dash网络Rinkeby。

6566
09:09:11.777 --> 09:09:16.184
它的速度会慢很多，因为很明显，现在我们正在

6567
09:09:16.184 --> 09:09:20.802
部署一个实际的测试网，在那里方块需要被挖掘。

6568
09:09:20.802 --> 09:09:22.910
我们看到我们还没有部署合同。

6569
09:09:22.910 --> 09:09:24.757
现在我们的合同已经部署好了。

6570
09:09:24.757 --> 09:09:29.515
我们知道，我们目前正在等待六个区块的确认，以便我们继续进行验证。

6571
09:09:29.515 --> 09:09:34.593
我应该加上console。log，等

6572
09:09:34.593 --> 09:09:39.672
待阻塞x这样我们就不会有校园怪圈了。

6573
09:09:39.672 --> 09:09:44.356
等等，我们现在要做什么?看起来我们遇到了这个错误，没有

6574
09:09:44.356 --> 09:09:49.040
这样的文件或目录，看起来我们的代码在这里没有正确编译。

6575
09:09:49.040 --> 09:09:50.463
这就是我要做的。

6576
09:09:50.463 --> 09:09:53.805
我们要把藏物删除，丢进垃圾桶。

6577
09:09:53.805 --> 09:09:55.968
我们也要删除我们的缓存。

6578
09:09:55.968 --> 09:10:00.700
当你用硬盘命令运行脚本时，我们会尝试重新运行它，Hardhead会

6579
09:10:00.700 --> 09:10:05.432
自动为你重新编译它，特别是在没有artifacts文件夹的情况下。

6580
09:10:05.432 --> 09:10:12.391
我们会重新运行这个命令和心跳，它会先编译我们可以看到它确实这样做了。

6581
09:10:12.391 --> 09:10:15.203
然后它将继续进行重新部署。

6582
09:10:15.329 --> 09:10:20.554
希望这一次，它应该能够找到刚刚编译的契约，

6583
09:10:20.554 --> 09:10:30.507
这一次在我删除artifacts文件夹之后，我们实际上确实获得了一些成功的编译。

6584
09:10:30.507 --> 09:10:38.471
我们可以在这里看到成功提交的源代码，在区块探索中等待验证结果，成功验证的合同简

6585
09:10:38.471 --> 09:10:46.435
单存储在以太扫描，甚至给了我们一个链接，我们可以继续和命令点击或控制点击进入。

6586
09:10:46.435 --> 09:10:49.837
我们可以看到合同确实得到了验证。

6587
09:10:49.837 --> 09:10:51.560
这太棒了。

6588
09:10:51.560 --> 09:10:53.283
这太完美了。

6589
09:10:53.283 --> 09:11:02.100
现在我们已经获得了一个成功的deploy。j脚本，它可以部署、验证并与代码交互。

6590
09:11:02.100 --> 09:11:03.280
这太棒了。

6591
09:11:03.280 --> 09:11:05.123
这个安全帽看起来很酷。

6592
09:11:05.123 --> 09:11:08.265
我们还能像我之前展示的那样用安全帽做什么。

6593
09:11:08.265 --> 09:11:10.845
安全帽附带了这些任务。

6594
09:11:10.845 --> 09:11:18.472
Hardhead的任务数量可以通过我们编写插件来扩展，我们实际上可以在hardhat中编写我们自己的任务。

6595
09:11:18.472 --> 09:11:25.040
在我们的Hardhead。config中，它可以默认这个任务帐户，我们可

6596
09:11:25.040 --> 09:11:31.608
以看到任务帐户，打印帐户列表，只打印帐户列表在这里实际上去心脏有文档了解

6597
09:11:31.608 --> 09:11:38.176
更多关于创建我们自己的任务，你可以定义任务的方法之一是直接在我们的心脏。

6598
09:11:38.176 --> 09:11:38.637
配置。

6599
09:11:38.637 --> 09:11:38.790
js。

6600
09:11:38.790 --> 09:11:45.652
但通常情况下，人们会有一个叫做任务的新文件夹，他们把所有的任务都放在那里。

6601
09:11:45.652 --> 09:11:48.444
现在，我要把这部分删掉。

6602
09:11:48.444 --> 09:11:49.930
我们要创建我们自己的任务。

6603
09:11:49.930 --> 09:11:55.435
您会注意到，现在我们已经删除了该部分，如果我们运行yarn RDAP，

6604
09:11:55.435 --> 09:12:00.784
我们将不再在这里看到accounts任务，因为我们已经删除了该任务。

6605
09:12:00.784 --> 09:12:03.969
让我们创建自己的新任务。

6606
09:12:03.969 --> 09:12:07.296
我们称它为街区号。

6607
09:12:07.296 --> 09:12:07.525
js。

6608
09:12:07.525 --> 09:12:12.524
我们会用这个来得到当前的块号或者我们正在处理的区块链。

6609
09:12:12.524 --> 09:12:14.201
让我们创建这个任务。

6610
09:12:14.331 --> 09:12:22.823
首先，我们需要导入任务函数，我们可以通过输入const task = require arhat / config来获得它。

6611
09:12:22.823 --> 09:12:26.759
hard hat斜杠配置具有任务功能。

6612
09:12:26.759 --> 09:12:31.398
要定义一个任务，我们现在可以说任务，给它一个名字

6613
09:12:31.398 --> 09:12:36.231
和一个描述，这个名字将是block number。

6614
09:12:36.331 --> 09:12:41.314
然后描述会打印出当前的块号。

6615
09:12:41.314 --> 09:12:47.098
现在我们有了这个任务，我们可以对它做一些事情，我们可以通过使

6616
09:12:47.098 --> 09:12:52.882
用。add命令向它添加不同的参数，它允许我们向任务传递参数。

6617
09:12:52.882 --> 09:13:01.314
然后我们还可以设置动作来定义任务应该为我们做什么，我们只需要做点设置动作。

6618
09:13:01.314 --> 09:13:04.664
然后定义我们想要这个函数做什么。

6619
09:13:04.664 --> 09:13:10.745
我们将使它成为一个async函数，它将接受一个输入，

6620
09:13:10.745 --> 09:13:16.594
任务参数，它将为空，还有HR E，我马上会定义它。

6621
09:13:16.594 --> 09:13:19.706
现在，让我快速解释一下语法。

6622
09:13:19.706 --> 09:13:25.246
这看起来可能有点奇怪，但这就是所谓的JavaScript箭头函数。

6623
09:13:25.246 --> 09:13:30.158
在JavaScript中，实际上可以定义函数，甚至不需要使用function关键字。

6624
09:13:30.158 --> 09:13:37.238
例如，如果我们回到deploy函数，我们有async函数verify在这里。

6625
09:13:37.331 --> 09:13:44.331
然而，我们也可以用另一种方式来定义它就是完全不使用函数词，实

6626
09:13:44.331 --> 09:13:49.231
际上把这整个东西变成一个变量，我们可以说，

6627
09:13:49.231 --> 09:13:58.332
我们可以说const verify将是一个async函数它接受契约地址和实参。

6628
09:13:58.332 --> 09:14:01.428
这是函数的定义。

6629
09:14:01.428 --> 09:14:04.009
这两条线本质上是等价的。

6630
09:14:04.009 --> 09:14:10.776
使用function关键字和将函数作为变量之间有一些细微的区别。

6631
09:14:10.776 --> 09:14:14.457
但对于这门课来说，它们基本上是一样的。

6632
09:14:14.457 --> 09:14:19.935
这意味着，它本身是一个函数，只是没有赋值给变量。

6633
09:14:19.935 --> 09:14:23.019
但本质上，这两个是完全一样的。

6634
09:14:23.019 --> 09:14:25.174
这就是我们在这里做的语法。

6635
09:14:25.174 --> 09:14:30.436
你可以想象这有点像const block task =

6636
09:14:30.436 --> 09:14:37.647
async function，它接受params，然后运行那个箭头函数。

6637
09:14:37.647 --> 09:14:40.204
或者你可以认为它是异步的。

6638
09:14:40.204 --> 09:14:48.998
函数，块任务参数，然后函数定义，这些本质上都是一样的。

6639
09:14:48.998 --> 09:14:55.849
主要的区别是我们没有给函数命名，我们没有给它这个block task变量。

6640
09:14:55.849 --> 09:15:00.251
这在JavaScript中称为匿名函数，因为它没有名称。

6641
09:15:00.251 --> 09:15:05.610
现在我们在这里有了函数，我们现在可以调用一些函数来获得块号。

6642
09:15:05.610 --> 09:15:11.931
我们如何在运行任务时获得块号呢，我们自动传递匿名函数，任

6643
09:15:11.931 --> 09:15:18.253
务参数，在这里，我们没有，但我们也传递这个hrii对象。

6644
09:15:18.332 --> 09:15:22.211
这个HRV是核心运行时环境。

6645
09:15:23.332 --> 09:15:28.264
部署脚本，这和这里的要求基本相同。

6646
09:15:28.264 --> 09:15:33.045
所以这个HRV可以访问很多相同的东西，

6647
09:15:33.045 --> 09:15:38.078
这个HRV可以访问很多和硬帽包一样的包。

6648
09:15:38.078 --> 09:15:43.434
所以我们可以用Hae点醚，就像从hard hat导入醚一样。

6649
09:15:43.434 --> 09:15:50.833
在我们的ethers包中，我们可以使用很多函数比如。Pro, biter。get block number。

6650
09:15:50.833 --> 09:15:55.522
我们把这个保存到一个变量const blocked

6651
09:15:55.522 --> 09:16:02.087
number =中，这将是一个同步的，所以我们要在这里添加一个权重。

6652
09:16:02.087 --> 09:16:05.953
然后我们写console。log block number。

6653
09:16:05.953 --> 09:16:13.047
或者更好的是，我们将字符串插值这个，并像这样说当前块号。

6654
09:16:13.047 --> 09:16:17.649
现在，如果我试着运行这个任务，你会注意到它没有出

6655
09:16:17.649 --> 09:16:22.252
现在任务的核心Atlas中，让我们来做yarn。

6656
09:16:22.333 --> 09:16:22.792
艺术的应用。

6657
09:16:22.792 --> 09:16:25.283
我没看到这里的街区号。

6658
09:16:26.333 --> 09:16:32.739
因为我们需要将它添加到我们的confi

6659
09:16:32.739 --> 09:16:39.146
g。config将添加require。

6660
09:16:39.333 --> 09:16:46.761
为了导入它，我们添加一个导出模块我稍后会解释它是做什么的。

6661
09:16:46.761 --> 09:16:53.365
但现在我们已经要求它，如果我运行纱线硬帽，现在看到阻塞是我可以使用的任务之一。

6662
09:16:53.365 --> 09:16:59.618
现在对于一根纱线，艺术帽块数，我们得到当前块数为零。

6663
09:16:59.618 --> 09:17:07.942
这是有意义的因为这是我们的硬帽网络的默认值，每次运行它都会重置。

6664
09:17:07.942 --> 09:17:12.971
但如果我跑纱线，硬帽区A号破折号网络瑞克比，你觉得我会

6665
09:17:12.971 --> 09:17:18.000
得到什么?同样，一个更大的数字，当前的区块编号在这里。

6666
09:17:18.000 --> 09:17:25.756
因为这是Rigby的实际区块数而我们的心脏广告网络的区块数将为零因为它

6667
09:17:25.756 --> 09:17:33.734
每次都会重置，我们运行其中一个脚本现在脚本和任务基本上可以做相同的事情。

6668
09:17:33.734 --> 09:17:39.885
它们都可以与合约交互，它们都可以部署智能合约，它们几乎都可以做任何事情。

6669
09:17:39.885 --> 09:17:47.684
作为一般的经验法则，我更喜欢脚本，因为我并不总是认为从命令行添加特殊的东西是有意义的。

6670
09:17:47.684 --> 09:17:51.587
所以我更喜欢脚本，但你也会看到大量的任务和例子。

6671
09:17:51.587 --> 09:17:54.952
我认为任务对于特定的用例来说非常好。

6672
09:17:54.952 --> 09:18:01.944
但在大多数情况下，我们基本上只使用脚本，但最好了解任务是什么样子的以及如何使用它。

6673
09:18:01.944 --> 09:18:07.940
我认为任务更适合于插件，脚本更适合于您自己的本地开发环境。

6674
09:18:07.940 --> 09:18:13.934
但如果你想做任何事都有任务，你完全可以做到。

6675
09:18:13.934 --> 09:18:18.268
正如您开始看到的，这个配置块非常强大。

6676
09:18:18.334 --> 09:18:24.350
我们可以用它来修改我们的整个代码库和我们的整个项目，给我们的项目更多的功能。

6677
09:18:24.350 --> 09:18:30.074
它还能做什么?现在，正如你所看到的，每次我们使用一个硬帽网络，每次我们运行一个

6678
09:18:30.074 --> 09:18:35.798
脚本，我们运行那个脚本，然后硬帽网络就被删除了，对吧?我们不能再和合同互动了。

6679
09:18:35.798 --> 09:18:39.318
其实我们有办法运作一个安全帽网络。

6680
09:18:39.318 --> 09:18:43.301
类似于我们运行带有用户界面的ganache网络。

6681
09:18:43.301 --> 09:18:48.398
我们能做的是在硬帽运行纱线，RT帽节点。

6682
09:18:48.398 --> 09:18:52.009
它会在本地网络上旋转一个节点，

6683
09:18:52.009 --> 09:18:57.548
和ganache完全一样，只是在我们的终端上。

6684
09:18:57.548 --> 09:19:00.966
这里启动了HTTP和WebSocket。

6685
09:19:00.966 --> 09:19:03.211
JSON此地址的RPC服务器。

6686
09:19:03.211 --> 09:19:10.033
就像nosh一样，它包含了各种不同的帐户和私钥，这太棒了。

6687
09:19:10.033 --> 09:19:17.311
你会注意到，有趣的是，我们运行的这个节点不在硬帽网络上，我们可以创

6688
09:19:17.311 --> 09:19:24.811
建一个新终端尝试与它交互，只需要点击这个小加号按钮，创建一个新终端。

6689
09:19:24.811 --> 09:19:30.949
同样，我使用bash，但基于您的操作系统，您可以使用不同的shell。

6690
09:19:30.949 --> 09:19:39.236
在这里，让我们继续运行yarn arhat运行脚本，部署。j s，看看会发生什么。

6691
09:19:39.335 --> 09:19:44.801
我们的典型设置发生了，我们部署一个契约，我们得到一个契约地址，我们更新值。

6692
09:19:44.801 --> 09:19:51.268
但如果我们看一下我们的节点，它看起来没有任何事务经过这里我们没有看到任何锁定。

6693
09:19:51.268 --> 09:19:59.690
这是怎么回事?我们的硬帽网络和这个本地运行的网络是不同的。

6694
09:19:59.690 --> 09:20:03.980
这个本地运行的网络通常被称为本地主机。

6695
09:20:03.980 --> 09:20:06.506
所以它和硬帽网络有点不同。

6696
09:20:06.506 --> 09:20:11.285
它仍然使用硬帽运行时环境，但不是默认的硬帽网络。

6697
09:20:11.335 --> 09:20:17.112
当我们运行一个节点时它被认为是独立的网络。

6698
09:20:17.112 --> 09:20:19.207
超过脚本持续时间的。

6699
09:20:19.335 --> 09:20:24.109
所以我们可以通过在硬机头上添加一个新网络来与它进行交互。

6700
09:20:24.109 --> 09:20:24.496
配置。

6701
09:20:24.496 --> 09:20:30.062
Js，我们将创建一个新网络并称之为local host。

6702
09:20:30.335 --> 09:20:36.198
和上面一样，我们给它一个URL账户和一个chain ID。

6703
09:20:36.198 --> 09:20:43.522
对于URL，我们可以从终端获得那个URL，我会放一个运行的yarn硬帽节点。

6704
09:20:43.522 --> 09:20:50.860
通过复制粘贴到这里，我们可以加一个逗号，我们会给它一个链ID 31337。

6705
09:20:50.860 --> 09:20:58.488
因为即使它被认为是不同的网络，它实际上和安全帽有相同的链ID。

6706
09:20:58.488 --> 09:21:03.887
有趣的是，我知道我刚刚说过我们要给它账户，但实际上我们不需要给它账户。

6707
09:21:03.887 --> 09:21:10.836
因为当我们运行这个localhost硬帽时它会自动给我们这10个假账户。

6708
09:21:10.836 --> 09:21:18.926
你可以把这个localhost的账户想成，已经把它们放在了，谢谢，硬帽子。

6709
09:21:18.926 --> 09:21:23.271
但现在，如果我们回到这里，让我们清空终端。

6710
09:21:23.336 --> 09:21:25.169
让我们重新运行脚本。

6711
09:21:28.336 --> 09:21:28.669
宿主

6712
09:21:28.669 --> 09:21:31.919
现在我们应该指向这个节点。

6713
09:21:33.336 --> 09:21:38.936
在这个脚本中，我们应该在这个节点的末尾看到一些日志输出。

6714
09:21:38.936 --> 09:21:41.069
按下回车键。

6715
09:21:41.069 --> 09:21:48.499
我们在部署脚本上看到正常的东西，我们翻回节点哇，我们在这里看到大量的日志记录。

6716
09:21:48.499 --> 09:21:54.814
与ganache类似，我们可以看到一大堆关于刚刚发生的事情的不同日志，我们可

6717
09:21:54.814 --> 09:22:01.129
以看到一个合同被部署，我们可以看到地址，来自值的事务哈希，gas和块号等等。

6718
09:22:01.129 --> 09:22:08.736
我们还可以看到契约调用调用store函数来更新收藏号的值。

6719
09:22:08.736 --> 09:22:14.146
这对于在本地JavaScript VM或硬帽网络上快速测试和处理

6720
09:22:14.146 --> 09:22:19.727
事物来说是非常强大的，能够看到您的契约如何在真实的测试网络上交互。

6721
09:22:19.727 --> 09:22:23.167
这比使用真正的测试网要快得多。

6722
09:22:23.167 --> 09:22:30.337
另外，和我们之前说的一样，任何在终端上运行的进程，我们可以用Ctrl C终止它。

6723
09:22:30.337 --> 09:22:36.067
因此，如果您想停止节点然后重新启动它，可以按Ctrl键。

6724
09:22:36.067 --> 09:22:42.949
C来停止它，然后再运行同样的命令来重新旋转你的节点Ctrl C停止它。

6725
09:22:42.949 --> 09:22:45.207
然后你就可以重新开始了。

6726
09:22:45.337 --> 09:22:53.227
另一种阻止它的方法，当然，是如果你点击垃圾桶，它会删除整个终端，我们把一个终端拉回来，我们可以再次运行它。

6727
09:22:53.227 --> 09:22:58.898
记住，如果你点击X，它不会删除终端，只是隐藏了它。

6728
09:22:58.898 --> 09:23:02.983
我们的硬帽节点现在还在运行因为我刚刚点击了它。

6729
09:23:02.983 --> 09:23:05.320
所以我把它拉上来，我可以看到它确实还在运行。

6730
09:23:05.320 --> 09:23:10.014
但如果我删除candidate，然后它把终端拉回来，我可以看到它不再运行了。

6731
09:23:10.014 --> 09:23:12.723
所以运行脚本非常好。

6732
09:23:12.723 --> 09:23:19.082
但是，如果我不想编写整个脚本来做一些事情呢?如果我只

6733
09:23:19.082 --> 09:23:25.687
是想修补区块链呢?嗯，硬帽子里装着一个叫控制台的东西。

6734
09:23:25.687 --> 09:23:27.583
控制台是一个JavaScript环境。

6735
09:23:27.583 --> 09:23:31.176
为了运行JavaScript命令与任何区块链交互，

6736
09:23:31.176 --> 09:23:41.527
我们可以通过运行yarn、hardhat、console跳转到控制台，然后如果我们想在溜冰场B、主网多边形、雪崩等上工作，可以运行任何网络标志。

6737
09:23:41.527 --> 09:23:43.495
这就是网络本地主机。

6738
09:23:43.495 --> 09:23:49.998
现在我们被放到了shell中在shell中，我们可以做所有在部署脚本中做的事情。

6739
09:23:49.998 --> 09:23:56.123
我们甚至不需要运行这些导入，因为所有带有硬帽的内容都会自动导入到我们的控制台。

6740
09:23:56.123 --> 09:24:00.814
举个例子，假设我想要一个简单的仓储合同工厂。

6741
09:24:00.814 --> 09:24:03.238
我可以画出这条直线。

6742
09:24:03.238 --> 09:24:09.544
我可以说const，简单存储，工厂等

6743
09:24:09.544 --> 09:24:16.202
于等待醚。get合同工厂，有简单存储。

6744
09:24:16.338 --> 09:24:18.385
现在我可以部署这个了。

6745
09:24:19.338 --> 09:24:21.588
复制这一行，粘贴它。

6746
09:24:25.338 --> 09:24:27.872
我们刚刚部署了另一个简单的存储器。

6747
09:24:28.338 --> 09:24:35.671
我们可以做等待简单的存储。检索。

6748
09:24:36.338 --> 09:24:40.250
我得到的返回值将是一个值为0的大数字。

6749
09:24:40.250 --> 09:24:46.751
我还可以进行事务处理，这样我就可以做一个权重，简单的存储。

6750
09:24:46.751 --> 09:24:55.284
那个store让我们做55如果我点击两次，我可以回到简单的storage。retrieve。

6751
09:24:55.338 --> 09:24:59.276
调用这个函数，可以看到大数的值是55。

6752
09:24:59.338 --> 09:25:02.450
现在，这是一个很好的方法来快速与任何我们想要的区块链交互。

6753
09:25:02.450 --> 09:25:06.134
现在，您可以通过按Ctrl C两次退出shell。

6754
09:25:06.134 --> 09:25:11.285
或者你也可以你也可以垃圾箱你的终端，如果你感到困惑。

6755
09:25:11.285 --> 09:25:19.588
这个主机可以与任何网络，我们甚至可以做纱，硬帽主机破折号网络硬帽。

6756
09:25:19.588 --> 09:25:23.181
我们会被丢进一个安全帽网络。

6757
09:25:23.338 --> 09:25:30.948
这里运行的节点和这里不同，这里只在命令执行期间运行。

6758
09:25:30.948 --> 09:25:34.989
所以当我们取消这个命令时，这个硬帽网络就被取消了。

6759
09:25:34.989 --> 09:25:36.449
把这个也关了。

6760
09:25:36.449 --> 09:25:39.741
我们也可以做纱线，硬帽，控制台，

6761
09:25:39.741 --> 09:25:47.767
破折号网络Rinkeby Rigby，或多边形或测试网或主网或任何我们想要的。

6762
09:25:47.767 --> 09:25:53.699
我们可以做ethers。provider这样的事情也可以做await ethers。

6763
09:25:53.699 --> 09:26:00.339
provider。get block number，查看Rigby的block number。

6764
09:26:00.339 --> 09:26:06.063
我们还可以部署合同，更新合同，我们可以做任何我们想做的事情，你可以

6765
09:26:06.063 --> 09:26:11.787
在这些控制台中做任何事情，它们是快速测试和修补与合同交互的好方法。

6766
09:26:11.787 --> 09:26:17.102
还有一些其他的任务真的很有帮助。

6767
09:26:17.102 --> 09:26:21.699
您将看到，在我删除工件和手动删除缓存之前。

6768
09:26:21.699 --> 09:26:27.855
好吧，要自己做，你也可以只运行纱线硬头，清洁。

6769
09:26:27.855 --> 09:26:31.289
这样就会删除藏物文件夹清空你的缓存。

6770
09:26:31.339 --> 09:26:33.097
我们已经知道编译是做什么的。

6771
09:26:34.339 --> 09:26:38.205
Hardhead最擅长的就是运行测试。

6772
09:26:38.205 --> 09:26:40.605
目前我们还没有进行测试。

6773
09:26:40.605 --> 09:26:46.258
然而，运行测试对于智能合约的开发过程绝对是至关重要的。

6774
09:26:46.258 --> 09:26:50.109
将来我们会花很多时间来写真正好的测试。

6775
09:26:50.109 --> 09:26:58.954
编写测试如此重要的原因是，我们想要确保我们的代码完全做我们想要它做的事情，特别是在挑战和

6776
09:26:58.954 --> 09:27:07.799
去中心化的智能合约世界中，我们所有的代码都将是开源的，任何人都可以与之交互，并可能利用。

6777
09:27:07.799 --> 09:27:12.954
还有像req。news这样的网站，它们经历了大量之前的黑客攻击，以及它

6778
09:27:12.954 --> 09:27:18.258
们是如何被黑客攻击的，以及智能合约中发生了什么使得这些黑客攻击得以发生。

6779
09:27:18.258 --> 09:27:24.427
所以测试，编写真正强大的测试总是我们的第一道防线。

6780
09:27:24.427 --> 09:27:26.114
我们有这个样本测试。

6781
09:27:26.114 --> 09:27:28.840
Js，它在hardhat的基本包中默认自带。

6782
09:27:28.840 --> 09:27:32.611
但你可能已经知道了，我们要重命名并改变它。

6783
09:27:32.611 --> 09:27:35.923
我们将重命名这个为test deploy。js。

6784
09:27:35.923 --> 09:27:41.081
我们要把这里所有的东西都删掉，重新开始。

6785
09:27:41.081 --> 09:27:46.710
我们希望能够在本地测试所有的稳定性代码，这样我们就能确切地知道它在做什么。

6786
09:27:46.710 --> 09:27:52.840
我们可以用一种程序化的方式来确保我们的代码做我们想要它做的事情。

6787
09:27:52.840 --> 09:27:56.740
因此，让我们为简单的存储契约编写一个基本测试。

6788
09:27:56.740 --> 09:28:01.684
这样我们就能确定它在做我们想要它做的事。

6789
09:28:01.684 --> 09:28:10.298
Hard Hat测试与Mocha框架一起工作，这是一个基于JavaScript的框架，用于运行我们的测试，

6790
09:28:10.298 --> 09:28:19.076
你实际上可以直接在实体中编写测试，如果你愿意的话，关于纯实体测试更好还是用现代编程语言测试更好，有一点反复。

6791
09:28:19.076 --> 09:28:28.029
有观点认为，使用现代编程语言进行测试，可以更灵活地进行更多交互和测试智能合约的工作。

6792
09:28:28.029 --> 09:28:32.768
但是用我们进行测试的理由是我们想要尽可能接近代码。

6793
09:28:32.768 --> 09:28:40.043
在记录的时候，大多数项目使用现代编程语言(如JavaScript)进行绝大部分的测试。

6794
09:28:40.043 --> 09:28:42.105
这就是我们要用到的。

6795
09:28:42.105 --> 09:28:47.698
为了开始我们的摩卡测试，我们要写一个描述函数。

6796
09:28:47.698 --> 09:28:53.624
description是一个摩卡能识别的关键字，

6797
09:28:53.624 --> 09:28:59.550
它有两个参数，一个字符串，我们现在只写简单存储。

6798
09:28:59.550 --> 09:29:05.820
然后也取一个函数，我们可以创建函数，测试func然

6799
09:29:05.820 --> 09:29:12.091
后在这里写一些东西，然后把它传递给我们这里的描述。

6800
09:29:12.091 --> 09:29:16.069
但通常的做法是让它成为一个匿名函数，

6801
09:29:16.069 --> 09:29:24.912
我们可以通过输入function来创建，在这里输入一个空形参，然后是这样的括号。

6802
09:29:24.912 --> 09:29:29.270
我们的describe函数接受一个名称，一个字符串和一个函数。

6803
09:29:29.341 --> 09:29:34.781
另一种经常在description中看到函数的方式是使用匿名函数语法。

6804
09:29:34.781 --> 09:29:39.822
你可能会看到这些括号，一个箭头，还有一些

6805
09:29:39.822 --> 09:29:44.864
括号，这两个基本上是一样的，有一些不同。

6806
09:29:44.864 --> 09:29:51.716
第二个实际上是最佳实践，但你要知道，你可能在其他测试中也会看到这个箭头语法。

6807
09:29:51.716 --> 09:29:56.308
我们已经描述了一个样本存储和这里的函数，它将包含我们所有的测试。

6808
09:29:56.341 --> 09:29:58.376
在每个描述块中。

6809
09:29:59.341 --> 09:30:07.472
一个叫做a在每个函数之前，还有一堆It's Our在每个函数之前会告诉我们在每次命中之前要做什么。

6810
09:30:07.472 --> 09:30:10.695
所以我们会有大量的它然后在每一个之前都有a。

6811
09:30:10.695 --> 09:30:14.919
所有id都将是我们实际编写运行测试代码的地方。

6812
09:30:14.919 --> 09:30:21.971
在每一个都有一些代码告诉我们在每一个命中之前要做什么

6813
09:30:21.971 --> 09:30:29.023
之前，我们还可以有描述，在描述的内部，在每一个都有更

6814
09:30:29.023 --> 09:30:36.075
多之前有这些嵌套的描述对分离和模块化测试非常有帮助。

6815
09:30:36.075 --> 09:30:40.761
但是对于这一个，我们将有一个像这样的设置。

6816
09:30:40.761 --> 09:30:44.008
在这个演示中，我们只会有一个。

6817
09:30:44.008 --> 09:30:50.148
因此，在实际运行测试之前，为了测试我们的智能合约，我们可能需要首先部署智能合约。

6818
09:30:50.148 --> 09:30:57.859
在我们的before each内部，我们会传递一个函数给我们的before each，它会告诉我们的测试框架在每个测试之前做什么。

6819
09:30:57.859 --> 09:31:01.817
我们会像这样传递一个async函数给它。

6820
09:31:01.817 --> 09:31:06.103
在这里，我们希望部署简单的存储契约。

6821
09:31:06.103 --> 09:31:12.748
要做到这一点，我们需要获取ethers框架并执行我们在部署脚本中所做的操作。

6822
09:31:12.748 --> 09:31:16.205
在这里，我们在顶部我们会说const。

6823
09:31:16.342 --> 09:31:23.230
以太，等于要求艺术从安全帽进口以太。

6824
09:31:23.342 --> 09:31:28.966
然后在我们的每个函数之前，我们会

6825
09:31:28.966 --> 09:31:34.942
说等待醚点获得简单存储的合同工厂。

6826
09:31:34.942 --> 09:31:39.630
我们会把这个赋值给const。

6827
09:31:39.630 --> 09:31:43.138
简单存储工厂。

6828
09:31:43.138 --> 09:31:50.178
然后我们会逃跑，简单的存储工厂。部署。

6829
09:31:50.178 --> 09:31:50.669
酷。

6830
09:31:50.669 --> 09:31:56.042
让我们把它赋给一个简单的可变成本。

6831
09:31:56.042 --> 09:32:03.081
现在，因为现在，我们的简单存储和简单存储工厂的作用域只是在每个之前的内部，我

6832
09:32:03.081 --> 09:32:10.306
们实际上需要把这些变量粘在每个之前的外部，所以我们所有的事件都可以与它们交互。

6833
09:32:10.306 --> 09:32:15.291
与其让简单存储，工厂，和简单存储，成为常量变

6834
09:32:15.291 --> 09:32:20.277
量，我们将在它们之外定义它们用let关键字。

6835
09:32:20.343 --> 09:32:27.205
然后我们说让简单存储工厂然后我们把它初始化为零。

6836
09:32:27.205 --> 09:32:29.739
然后我们会说led简易存储器。

6837
09:32:29.739 --> 09:32:34.113
现在，如果你有一大堆。我们用另一种方式初始化，

6838
09:32:34.113 --> 09:32:40.390
你可以用JavaScript写它们，让简单存储工厂逗号，简单存储。

6839
09:32:40.390 --> 09:32:42.064
这是完全一样的。

6840
09:32:42.064 --> 09:32:43.817
然后我们可以去掉这个const关键字。

6841
09:32:43.817 --> 09:32:47.454
因为它不是常数，因为我们分配了它。

6842
09:32:47.454 --> 09:32:52.936
现在我们有了简单的存储，工厂和简单的存储我们可以在init函数中使用。

6843
09:32:52.936 --> 09:32:54.643
现在我们在每个部分之前都有一个。

6844
09:32:54.643 --> 09:32:57.898
因此，在每个测试之前，我们将部署简单的存储契约。

6845
09:32:57.898 --> 09:33:02.278
因此，我们有一个全新的合同来与我们的每一个测试进行交互。

6846
09:33:02.343 --> 09:33:06.946
在ID内部，这是我们想要这个特定测试做

6847
09:33:06.946 --> 09:33:11.549
什么的地方，然后描述实际做那个的代码。

6848
09:33:11.549 --> 09:33:18.815
所以我们说它应该从一个最喜欢的数字0开始。

6849
09:33:18.815 --> 09:33:22.280
这说明了这个测试应该做什么。

6850
09:33:22.280 --> 09:33:26.861
然后我们会添加async函数来做这个。

6851
09:33:26.861 --> 09:33:29.129
我们说async function。

6852
09:33:29.129 --> 09:33:33.698
在这里，我们会写代码来

6853
09:33:33.698 --> 09:33:38.268
确保合约能做到这一点。

6854
09:33:38.343 --> 09:33:40.247
我们说const。

6855
09:33:40.247 --> 09:33:45.834
当前值，等于等待，简单存储。

6856
09:33:46.343 --> 09:33:46.859
检索。

6857
09:33:50.343 --> 09:33:53.246
看看当前值是否为零。

6858
09:33:54.343 --> 09:33:59.666
了吗?我们可以说const，期望值等于0。

6859
09:33:59.666 --> 09:34:05.727
我们能做的是我们能使用断言关键字，或期望关

6860
09:34:05.727 --> 09:34:12.077
键字，我们会从一个叫Chai的包导入这两个。

6861
09:34:12.077 --> 09:34:20.171
我们实际上是在下载基本参数时自动安装Chai的。

6862
09:34:20.171 --> 09:34:22.722
在顶部，我们会说const。

6863
09:34:22.722 --> 09:34:28.013
Chai，我非常喜欢尽可能多地使用

6864
09:34:28.013 --> 09:34:33.616
断言，因为我认为这样的语法更有意义。

6865
09:34:33.616 --> 09:34:37.055
但是在某些情况下，我们需要使用expect来代替。

6866
09:34:37.055 --> 09:34:43.281
断言有很多内建的函数帮助我们确保这是我们期望的结果。

6867
09:34:43.344 --> 09:34:46.786
我可以断言。等于当前值。

6868
09:34:48.344 --> 09:34:52.277
记住，这是一个很大的数，逗号，期望值。

6869
09:34:52.277 --> 09:34:58.810
我断言这个检索将返回0，这将是我们的期望值。

6870
09:34:58.810 --> 09:35:03.934
现在要运行这个，我们要运行纱线，艺术帽测试。

6871
09:35:03.934 --> 09:35:09.950
我们看到我们得到了一个像这样的输出应该以最喜欢的数字0开始，它确实通过了。

6872
09:35:09.950 --> 09:35:16.131
你会注意到，如果我把这个改成1，这是不对的，它会崩溃

6873
09:35:16.131 --> 09:35:22.312
它会说art Pass或不传递断言错误期望0等于1。

6874
09:35:22.312 --> 09:35:27.671
它期望0等于1，这不是我们想要的。

6875
09:35:27.671 --> 09:35:30.021
我们想让0等于0。

6876
09:35:30.021 --> 09:35:31.648
让我们再运行一遍。

6877
09:35:31.648 --> 09:35:35.183
多达应该从最喜欢的数字零开始，它已经过去了。

6878
09:35:35.183 --> 09:35:36.102
好的,太棒了。

6879
09:35:36.102 --> 09:35:42.183
这就是我们写一个测试的方法，让我们再写一个测试，以确保一切正常。

6880
09:35:42.183 --> 09:35:50.583
当我们调用store函数时，它应该更新，因为当我们调用store函数时，我们希望收藏号更新。

6881
09:35:50.583 --> 09:35:53.688
我们也会让它成为一个async函数。

6882
09:35:53.688 --> 09:35:56.188
把我们的东西加进去。

6883
09:35:56.345 --> 09:35:58.011
所以我们用const。

6884
09:36:01.345 --> 09:36:05.000
当我们调用store时，它会更新到7。

6885
09:36:05.345 --> 09:36:07.000
我们可以说const。

6886
09:36:11.345 --> 09:36:12.761
存储点存储。

6887
09:36:16.345 --> 09:36:17.126
值。

6888
09:36:21.345 --> 09:36:22.046
重量。

6889
09:36:22.046 --> 09:36:24.291
现在让我们得到当前值。

6890
09:36:25.345 --> 09:36:26.031
const。

6891
09:36:32.345 --> 09:36:33.046
检索。

6892
09:36:37.345 --> 09:36:37.918
价值。

6893
09:36:37.918 --> 09:36:41.475
到字符串，逗号期望的值。

6894
09:36:44.345 --> 09:36:46.395
这些试验通过跑纱硬头试验进行。

6895
09:36:47.345 --> 09:36:48.782
这两个测试都做了

6896
09:36:51.345 --> 09:36:59.657
只骗了一个测试，我实际上可以运行一个测试通过运行yarn, art app，测试，dash dash grep。

6897
09:36:59.657 --> 09:37:04.570
我可以在这里的任何文本中搜索任何关键词。

6898
09:37:04.570 --> 09:37:07.741
我要用grep来表示store函数。

6899
09:37:07.741 --> 09:37:13.583
因为store关键字不在这个tax中，它只在这个的文本中。

6900
09:37:13.583 --> 09:37:18.535
如果我使用grep store，它应该只运行我们的第二个测试，确

6901
09:37:18.535 --> 09:37:23.488
实如此，我们可以只运行特定测试的另一种方法是使用only关键字。

6902
09:37:23.488 --> 09:37:27.011
我们可以这样输入。only。

6903
09:37:27.011 --> 09:37:30.409
然后我们可以运行纱线，艺术帽测试。

6904
09:37:30.409 --> 09:37:34.596
它应该只运行，这应该在调用store时更新。

6905
09:37:34.596 --> 09:37:40.613
确实是这样，然后我们删除这个保存，再运行，它也会运行。

6906
09:37:40.613 --> 09:37:41.505
太棒了。

6907
09:37:41.505 --> 09:37:49.749
现在，您将看到编写这些测试的另一种方式是使用expect关键字而不是assert。

6908
09:37:49.749 --> 09:37:52.919
所以你会看到期望的现值。

6909
09:37:52.919 --> 09:37:53.951
字符串。

6910
09:37:53.951 --> 09:38:01.346
点乘等于期望值，这两条线做完全相同的事情。

6911
09:38:01.346 --> 09:38:04.536
这取决于你想用哪一个。

6912
09:38:04.536 --> 09:38:07.524
这就是我们要做的所有测试。

6913
09:38:07.524 --> 09:38:07.952
现在。

6914
09:38:07.952 --> 09:38:11.059
这是一份很棒的工作。

6915
09:38:11.059 --> 09:38:18.821
现在我们有了一些测试，我们可以开始测试，看看每个功能实际消耗多少气体。

6916
09:38:18.821 --> 09:38:23.853
安全帽最流行的扩展之一是安全帽气体记者。

6917
09:38:23.853 --> 09:38:28.802
这是一个附加到我们所有测试的扩展，自动给我们一个

6918
09:38:28.802 --> 09:38:33.958
像这样的输出，它告诉我们每个功能大约消耗多少气体。

6919
09:38:33.958 --> 09:38:41.853
我们向下滚动到这里，我们可以阅读如何安装npm安装Hardhead气体报告器的说明，我们将用它来安装纱线。

6920
09:38:41.853 --> 09:38:46.932
所以我们选纱线，加上安全

6921
09:38:46.932 --> 09:38:52.012
帽，气体记者，冲刺戴夫。

6922
09:38:52.346 --> 09:38:57.132
现在这个包已经安装好了，我们可以进入我们的配置，在

6923
09:38:57.132 --> 09:39:01.918
这里添加一些参数，这样我们就可以使用这个瓦斯坑了。

6924
09:39:01.918 --> 09:39:07.855
但是在以太扫描部分下面，我们要添加一个叫做gas reporter的新部分。

6925
09:39:07.855 --> 09:39:13.003
要让它运行，无论何时我们运行测试我们都会启用它都是true。

6926
09:39:13.003 --> 09:39:20.013
然后在最上面，我们可以添加它通过添加require hardhat gas reporter。

6927
09:39:20.013 --> 09:39:25.043
现在我们有了它，我们可以做纱线硬帽测试，在

6928
09:39:25.043 --> 09:39:30.313
我们运行测试后，它会自动运行这个气体报告器。

6929
09:39:30.313 --> 09:39:32.966
所以我们看到我们的测试继续运行。

6930
09:39:32.966 --> 09:39:40.001
然后我们得到这样的输出它告诉我们契约和方法的成本是多少。

6931
09:39:40.001 --> 09:39:47.177
我们的存储函数大概消耗这么多汽油简单的存储大概消耗这么多汽油。

6932
09:39:47.177 --> 09:39:52.902
这对于弄清如何尽可能优化我们的气体非常有帮助。

6933
09:39:52.902 --> 09:39:55.560
现在我通常喜欢更进一步。

6934
09:39:55.560 --> 09:40:00.153
有这样的气体输出是很好的，但我们可以让它更好。

6935
09:40:00.153 --> 09:40:04.281
我喜欢通过输出文件把它输出到一个文件。

6936
09:40:04.281 --> 09:40:10.440
是的，report。txt然后我的。get ignore把它加到这里，

6937
09:40:10.440 --> 09:40:18.008
但是做gas report。txt语句把gas report推到GitHub并不重要。

6938
09:40:18.008 --> 09:40:19.329
做没有颜色的事才是真。

6939
09:40:19.329 --> 09:40:26.019
我们添加这个的原因是，当我们输出到一个文件时，颜色基本上会变得混乱。

6940
09:40:26.019 --> 09:40:30.578
然后我们能做的最大的加法就是在这里加一种货币。

6941
09:40:30.578 --> 09:40:36.761
这样我们就可以得到像Aetherium这样的区块链每个功能的美元成本。

6942
09:40:36.761 --> 09:40:39.418
现在为了在这里得到货币，

6943
09:40:39.418 --> 09:40:49.825
我们实际上需要从玉米市值中得到一个API密钥，就像我们在以太扫描中做的一样，你可以到硬币市值，

6944
09:40:49.825 --> 09:40:56.248
玉米市值API，得到你的API密钥，然后我们就可以注册了。

6945
09:40:56.248 --> 09:40:59.248
选择一个基本的计划。

6946
09:40:59.248 --> 09:41:04.671
我们会同意并创建我的账户，我们会收到电子邮件验证。

6947
09:41:04.671 --> 09:41:06.905
我们来验证一下。

6948
09:41:06.905 --> 09:41:11.414
现在在硬币市值仪表盘上，我们可以复制密钥。

6949
09:41:11.414 --> 09:41:17.668
是的，你猜对了，我们要怎么处理这个键，我们要把它放到。env文件中，或者说，

6950
09:41:17.668 --> 09:41:23.594
coin market cap, API key =然后像这样粘贴进去。

6951
09:41:23.594 --> 09:41:32.276
现在我们在这里有了玉米市值API键，我们可以返回我们的头点配置，并将其添加到玉米市值参数中。

6952
09:41:32.276 --> 09:41:40.095
我们和上面做的完全一样，我们用const，硬币，市值，API键=

6953
09:41:40.095 --> 09:41:48.648
process。EMV，硬币市值，API键，然后我们把这个放在这里。

6954
09:41:48.648 --> 09:41:55.435
这实际上是对玉米市值进行API调用，每当我们运行气体报告时。

6955
09:41:55.435 --> 09:42:01.912
这就是为什么有时你会看到我把它注释掉，然后又取消注释，因为我不总是希望它进行这个API调用。

6956
09:42:01.912 --> 09:42:10.708
但现在我们能做的是现在它被启用了，我们有一个输出文件，我们可以看到货币，我们有API密钥，我们能做的就是运行yarn hardhat测试。

6957
09:42:10.708 --> 09:42:16.015
所有测试都通过后，我们会看到气体报告。

6958
09:42:16.015 --> 09:42:20.729
tx T，我们可以从它里面读取气体报告。

6959
09:42:20.729 --> 09:42:27.139
现在每笔交易都有了美元价格，看起来在当前的价格下，Aetherium

6960
09:42:27.139 --> 09:42:33.738
是3000美元/人，天然气价格是43 Gwei，商店功能将花费6美元。

6961
09:42:33.738 --> 09:42:37.112
而简单的存储功能则需要64美元。

6962
09:42:37.112 --> 09:42:41.851
目前的Hardhead气体报告器实际上有一些不同的选择，尽管，如果你要部署到不同的

6963
09:42:41.851 --> 09:42:46.590
网络，例如，与binance, Polygon, Avalanche或hecho。

6964
09:42:46.590 --> 09:42:53.641
例如，假设我们想要部署这个多边形，让我们看看在我们的WMV UHD

6965
09:42:53.641 --> 09:43:00.693
广告令牌中部署这个多边形将花费多少钱，现在我们将重新运行这个测试。

6966
09:43:00.693 --> 09:43:05.249
如果我们看一下消耗T的汽油报告会看到pol

6967
09:43:05.249 --> 09:43:09.806
ygon的汽油价格现在大约是37格雷/桶。

6968
09:43:09.806 --> 09:43:13.243
Matic的费用是自动147和美元。

6969
09:43:13.243 --> 09:43:18.494
现在我们可以看到调用简单存储方法的代价是0美元。

6970
09:43:18.494 --> 09:43:18.655
00.

6971
09:43:18.655 --> 09:43:20.682
这当然是四舍五入，

6972
09:43:20.682 --> 09:43:33.296
但调用store会非常非常便宜而部署合约只需要3美分，我习惯为gas报告器选择false每当我不想使用gas时。

6973
09:43:33.349 --> 09:43:33.704
太棒了。

6974
09:43:36.349 --> 09:43:41.709
我们没有指定这些环境变量Hardhead可能会对我们有点不满。

6975
09:43:41.709 --> 09:43:44.411
通常我会在这里添加一些代码。

6976
09:43:44.411 --> 09:43:48.250
这些变量总是被填充，因为我们没有指定rink

6977
09:43:48.250 --> 09:43:53.661
prpc URL, rringprpc URL将是未定义的。

6978
09:43:53.661 --> 09:43:56.036
这可能会造成一些错误。

6979
09:43:56.036 --> 09:44:00.750
通常，我们会在这里添加一个或参数，这些双管道的意思是或，

6980
09:44:00.750 --> 09:44:08.494
在JavaScript中，如果我们说某个变量等于某物或某物，实际发生的是我们会说，rink,

6981
09:44:08.494 --> 09:44:14.725
们会说，rink, RPC URL将等于process。E和V。rink, RPC URL。

6982
09:44:14.725 --> 09:44:19.720
但如果这个rink, RPC URL不存在，它会是这里的其他东西。

6983
09:44:19.720 --> 09:44:23.914
我可能会写一些类似于HTTPS的东西。

6984
09:44:23.914 --> 09:44:30.178
举个例子，或者类似的例子，这样我就不会因为不使用B级而让安全帽抓狂。

6985
09:44:30.178 --> 09:44:33.604
我们可以对所有这些做类似的事情。

6986
09:44:33.604 --> 09:44:39.807
你会在很多代码设置中看到这种语法。

6987
09:44:39.807 --> 09:44:47.127
在进入This的TypeScript版本之前，我要展示的最后一件事是测试覆盖率。

6988
09:44:47.127 --> 09:44:55.492
随着课程的推进，我将向你们展示更多的工具，你们可以使用它们来确保我们的简单存储合同是安全的。

6989
09:44:55.492 --> 09:45:00.936
如果我们在现实生活中部署，我们会采取一切可能的措施来防止任何黑客攻击。

6990
09:45:00.936 --> 09:45:03.688
其中一个工具叫做固体覆盖率。

6991
09:45:03.688 --> 09:45:06.850
这也是一个我们可以在代码中使用的硬帽插件。

6992
09:45:06.850 --> 09:45:11.608
可靠性覆盖是一个经过所有测试并查看示例存

6993
09:45:11.608 --> 09:45:16.366
储点Sol中实际覆盖了多少行代码的项目。

6994
09:45:16.366 --> 09:45:17.942
这是一个很好的提示。

6995
09:45:17.942 --> 09:45:24.462
如果我们不覆盖某一行代码，稳定性覆盖率就会说，嘿，你没有对这行代码进行任何测试，也许你应该为它编写一些测试。

6996
09:45:24.462 --> 09:45:28.242
我们可以用添加所有包的相同方式添加固体覆盖率。

6997
09:45:28.242 --> 09:45:36.269
npm安装破折号，保存Dev，或者因为我们使用的是纱线，纱线，添加破折号Dev，固体覆盖率。

6998
09:45:36.269 --> 09:45:42.009
然后我们可以把它添加到配置中，就像我们把所有东西都添加到配置中一样，

6999
09:45:42.009 --> 09:45:47.919
进入我们的配置，我们会写requisolidity coverage。

7000
09:45:47.919 --> 09:45:56.421
我们可以在下面添加一些配置件，但我们只使用默认的现在我们可以做的是运行yarn, RT hat覆盖。

7001
09:45:56.421 --> 09:46:03.318
这将通过我们的测试并打印出一个像这样的文件，我们还会得到一个文件，叫做coverage。

7002
09:46:03.318 --> 09:46:10.842
JSON，它基本上是这个图表的细分部分把coverage。JSON放到。get ignore中。

7003
09:46:10.842 --> 09:46:14.981
我知道我们还没见过。Git ignore，做它应该做的。

7004
09:46:14.981 --> 09:46:23.617
但是我们很快就会看到这里大约50%的代码simple storage。soul中50%的语句都被覆盖了。

7005
09:46:23.617 --> 09:46:29.854
大约三分之二的函数和50%的线，它甚至会告诉我们哪些线没有被测试，

7006
09:46:29.854 --> 09:46:35.713
我们可以看到31和32简单的剑，大底没有被覆盖，这很有意义，因

7007
09:46:35.713 --> 09:46:41.951
31到32是添加人函数，我们没有调用，我们没有添加到我们的测试。

7008
09:46:41.951 --> 09:46:47.298
如果您想花点时间暂停一下，并通过编写更多的测试来实现100%

7009
09:46:47.298 --> 09:46:52.824
的可靠性覆盖率，我强烈建议您这样做，这将是一个很好的学习练习。

7010
09:46:52.824 --> 09:46:54.661
我们还将添加coverage文件夹。

7011
09:46:54.661 --> 09:47:01.266
覆盖相邻和覆盖文件夹，我稍后会解释。get ignore文件夹的作用。

7012
09:47:01.266 --> 09:47:09.304
最后一件事，我们没有讲到这里是什么是nomic labs硬帽华夫饼。

7013
09:47:09.304 --> 09:47:13.629
我们谈论了爸爸和V心和以太扫描任务气体报告。

7014
09:47:13.629 --> 09:47:15.924
那么今天，这是什么?好吧，

7015
09:47:15.924 --> 09:47:24.399
我们可以搜索这个并找出它到底是什么Hardhead华夫实际上是一个与华夫测试框架一起工作的插件。

7016
09:47:24.399 --> 09:47:32.574
华夫是其中一个框架它允许我们做一些非常高级的测试，我们很快就会使用一些看起来非常类似的语法。

7017
09:47:32.574 --> 09:47:36.775
随着我们的继续，我们会向你们展示更多的华夫饼工具。

7018
09:47:36.775 --> 09:47:43.188
好了，这一节的下一部分，我会讲一下它的TypeScript版本。

7019
09:47:43.188 --> 09:47:50.098
但无论如何，你已经成功创建了你的第一个Hardhead项目，你已经做了很多了不起的事情。

7020
09:47:50.098 --> 09:47:57.285
在这节课中，让我们快速复习一下到目前为止我们学过的内容，我们学习了如何启动我们自己的硬帽项目。

7021
09:47:57.352 --> 09:48:05.565
现在我们可以运行yarn, hardhat，并看到一个任务列表和不同的事情，我们可以用hardhat。

7022
09:48:05.565 --> 09:48:08.818
我们知道了安全帽会找这个安全帽。

7023
09:48:08.818 --> 09:48:09.218
配置。

7024
09:48:09.218 --> 09:48:09.351
js。

7025
09:48:09.351 --> 09:48:17.401
这是我们运行的任何任务的入口点从hard hat开始，我们知道我们可以把我们的合同添加到合同文件夹。

7026
09:48:17.401 --> 09:48:22.107
然后我们通过运行yarn来编译，art半编译，我

7027
09:48:22.107 --> 09:48:26.813
们了解到所有的遵从都进入了工件，然后缓存也一样。

7028
09:48:26.813 --> 09:48:31.707
如果我们想要清除重置，我们可以删除这两个文件或者只运行yarn, hard hat clean。

7029
09:48:31.707 --> 09:48:38.860
因此我们了解到，我们可以使用脚本或任务来实际部署、交互和使用智能合约做事情。

7030
09:48:38.860 --> 09:48:42.194
我们还了解到，在本课程的其余部分中，我将使用脚本。

7031
09:48:42.194 --> 09:48:44.997
但如果你愿意，你也可以使用任务。

7032
09:48:44.997 --> 09:48:50.580
这个问题我已经问过无数次了有什么区别吗?似乎没有人真正知道它们的主要区别是什么。

7033
09:48:50.580 --> 09:48:53.319
但我认为主要的区别在于任务是为插件准备的。

7034
09:48:53.319 --> 09:48:59.616
脚本是为本地开发的，这是思维限制器，我们知道我们可以导入一大堆东西，包

7035
09:48:59.616 --> 09:49:05.913
括从hardhat导入脚本的任务，我们可以使用async函数获取契约并

7036
09:49:05.913 --> 09:49:12.210
部署它们，我们实际上可以通过编程验证它们使用hardhat和硬帽插件。

7037
09:49:12.210 --> 09:49:17.165
另外，我们还可以和我们和醚的相互作用非常相似。

7038
09:49:17.165 --> 09:49:19.203
我们编写了一个很棒的验证脚本。

7039
09:49:19.203 --> 09:49:24.014
我们也写了自己的任务，我们写了整个空间的第一个测试。

7040
09:49:24.014 --> 09:49:27.686
我们展示了我们的测试将会是什么样子。

7041
09:49:27.686 --> 09:49:30.066
我们讲了一点它们的重要性。

7042
09:49:30.066 --> 09:49:37.393
我真的应该强调写好测试将是真正的专业环境和业余项目的区别。

7043
09:49:37.393 --> 09:49:42.505
每当我审核智能合约时，或者每当我接到一个项目，有人让我看一看时。

7044
09:49:42.505 --> 09:49:45.788
当然，我首先看的是自述文件。

7045
09:49:45.788 --> 09:49:47.917
我看的第二件事是测试。

7046
09:49:47.917 --> 09:49:54.305
如果测试结果不好，我通常会告诉他们，嘿，你需要回到绘图板上，你需要升级你的测试。

7047
09:49:54.353 --> 09:50:00.708
所以测试真的非常非常重要，特别是在这个领域，我们学到了更多可以使用的环境变量。

7048
09:50:00.708 --> 09:50:05.892
我们学习了一些工具来了解我们的测试有多好，其中之一就是覆盖率。

7049
09:50:05.892 --> 09:50:12.089
我们还了解了一个气体报告器，以了解当我们实际部署到一个真实的网络时，它将花费多少。

7050
09:50:12.089 --> 09:50:19.196
我们学到了很多关于硬帽配置的知识，以及如何将多个网络添加到我们的硬头中，我们可以将

7051
09:50:19.196 --> 09:50:26.304
我们的项目变成EVM代码，与任何网络一起工作，我们开始使用开发依赖而不是常规依赖。

7052
09:50:26.353 --> 09:50:30.553
readme是我不打算在这里深入讲解的东西。

7053
09:50:30.553 --> 09:50:38.124
readme有点像GitHub存储库的欢迎页面，它应该让你理解你的代码是做什么的。

7054
09:50:38.124 --> 09:50:39.983
成为太空网络的一部分。

7055
09:50:39.983 --> 09:50:44.892
成为区块链生态系统的一员不仅仅是你自己编写代码那么简单。

7056
09:50:44.892 --> 09:50:48.974
您希望其他人与您的代码和项目进行交互和参与。

7057
09:50:48.974 --> 09:50:50.509
我还没有向你展示如何使用GitHub。

7058
09:50:50.509 --> 09:50:54.784
但别担心，我们会但是如果你看我的心脏有简单的存储自述。

7059
09:50:54.784 --> 09:51:02.321
如果你向下滚动，通常，你会想要有一个入门部分在那里你定义如何设置所有的代码以及如何设置所有的东

7060
09:51:02.321 --> 09:51:10.020
西一个快速入门部分，可能还有一个使用部分和一些测试部分，它教会人们如何实际使用和与你的代码交互。

7061
09:51:10.020 --> 09:51:13.830
因为我们只是学习更多的代码部分，而不是自述部分。

7062
09:51:13.830 --> 09:51:17.104
现在，我们不打算讨论如何制作一份出色的自述文件。

7063
09:51:17.104 --> 09:51:22.374
不过，我会在GitHub存储库中留下一个与这门课程相关的链接，链接到这个最佳自述模板。

7064
09:51:22.374 --> 09:51:28.932
它真的是一个非常棒的自述模板你可以复制到任何你的项目中使它们看起来非常好给它们一

7065
09:51:28.932 --> 09:51:35.654
个非常好的设置，这样其他的开发人员就可以来到你的项目中，学习和参与你所编写的代码。

7066
09:51:35.654 --> 09:51:42.754
但好吧，你已经学到了很多东西，你应该为自己感到无比骄傲，为自己走到今天感到无比兴奋。

7067
09:51:42.754 --> 09:51:45.133
现在我要跳到TypeScript部分。

7068
09:51:45.133 --> 09:51:48.676
所以对于那些使用TypeScript进行编码的人，请随意跟随。

7069
09:51:48.676 --> 09:51:55.314
对于那些没有读过的人，你们刚刚完成了关于重击的基础部分，但请坚持下去，接下来

7070
09:51:55.314 --> 09:52:02.128
的部分将是真正细化和磨练你的技能的部分，并为你提供使用这些框架的所有基本知识。

7071
09:52:02.128 --> 09:52:10.934
所以一定要关注接下来的两个部分，我们为你准备了更多精彩的内容，我们才刚刚开始深入智能合约生态系统。

7072
09:52:10.934 --> 09:52:14.741
坐好那一圈，喝好咖啡，回头见。

7073
09:52:14.741 --> 09:52:19.386
现在我们用TypeScript来做这个。

7074
09:52:19.386 --> 09:52:22.710
我将从JavaScript部分开始。

7075
09:52:22.710 --> 09:52:30.992
然而，如果在未来，你想开始一个新的Hardhead项目，你实际上可以开始一个新的项目与纱线，硬帽。

7076
09:52:30.992 --> 09:52:38.032
然后用TypeScript做一个优秀的高级示例项目，你会添加大量的插件。

7077
09:52:38.032 --> 09:52:41.082
你需要等待一段时间才能上传所有内容。

7078
09:52:41.082 --> 09:52:43.699
你等待，等待一段时间，直到所有东西都下载完成。

7079
09:52:43.699 --> 09:52:49.260
我们不会这么做，因为我将向你们展示如何将它转换成JavaScript，无论如何，如果在以后的章节中，

7080
09:52:49.260 --> 09:52:54.600
当我们使用JavaScript进行编码时，如果你想使用TypeScript进行编码，你完全可以。

7081
09:52:54.600 --> 09:52:58.032
但让我们继续，告诉你们主要的区别是什么。

7082
09:52:58.032 --> 09:53:04.105
现在，高级TypeScript将添加一大堆包，你可能需要，也可能不需要，我将在下一课中讨论其中一些。

7083
09:53:04.105 --> 09:53:07.010
但有一些是你绝对需要的。

7084
09:53:07.010 --> 09:53:14.495
它们分别是attypechain / ethers / vfive, attypechain， /

7085
09:53:14.495 --> 09:53:21.980
hard hat, attypescript, attypes， / Chai, attypes，

7086
09:53:21.980 --> 09:53:30.079
/ node, attypes / moko, TS节点，type chain和TypeScript。

7087
09:53:30.079 --> 09:53:35.071
我在GitHub上有一个与这门课相关的链接，我有一个纱线广

7088
09:53:35.071 --> 09:53:40.064
告，你可以复制粘贴，如果你想复制粘贴到你的项目中去运行它。

7089
09:53:40.064 --> 09:53:42.116
哎呀，我应该把它们作为开发依赖项添加进去。

7090
09:53:42.116 --> 09:53:48.580
我们要让它们快速成为开发依赖项，只需要删除这两行，在这里加一个逗号。

7091
09:53:48.580 --> 09:53:50.644
太棒了，看起来好多了。

7092
09:53:50.644 --> 09:53:56.815
当然，我们要做的是将所有JavaScript转换为TypeScript。

7093
09:53:56.815 --> 09:54:03.581
任何有js的地方，我们都会放上Ts，显然，如果你用TypeScript从头开始编码，你会做。

7094
09:54:03.581 --> 09:54:04.482
ts从一开始。

7095
09:54:04.482 --> 09:54:08.974
这包括我们的hardhat。config，这也将是TypeScript。

7096
09:54:08.974 --> 09:54:11.784
另外，我们会添加一个TS config。JSON。

7097
09:54:11.784 --> 09:54:14.804
这将是我们的TypeScript配置。

7098
09:54:14.804 --> 09:54:17.260
通常情况下，我们会使用这样的设置。

7099
09:54:17.260 --> 09:54:20.414
你可以从与本课程相关的GitHub回购中复制这个。

7100
09:54:20.414 --> 09:54:26.265
它基本上是在告诉TypeScript, TypeScript的什么版本以及使用TypeScript需要包含什么文件。

7101
09:54:26.265 --> 09:54:29.356
现在让我们从deploy。TypeScript开始。

7102
09:54:29.356 --> 09:54:35.782
通常，我们不使用require，而是使用import，我们会做完全一样的事情。

7103
09:54:35.782 --> 09:54:40.822
我们将从安全帽导入醚运行网络。

7104
09:54:40.822 --> 09:54:48.956
然后在验证函数中，我们会添加我们会添加这些实参的类型。

7105
09:54:48.956 --> 09:54:51.956
合约地址是一个字符串。

7106
09:54:51.956 --> 09:54:55.044
args是一个参数数组。

7107
09:54:55.044 --> 09:55:01.784
我们会说它是任何数组，因为它可以是字符串，可以是数字，可以是气球，可以是任何东西。

7108
09:55:01.784 --> 09:55:08.990
我们还会说，对于IE，它可以是any，尽管这在技术上是一个错误类型，为了简单起见，我们将用any。

7109
09:55:08.990 --> 09:55:09.497
现在。

7110
09:55:09.497 --> 09:55:12.844
我们所有的TypeScript脚本都包含在TS配置中，

7111
09:55:12.844 --> 09:55:19.168
或者任何TypeScript文件都是手动添加到这里的，我们的整个scripts文件夹都在这里，这很好。

7112
09:55:19.168 --> 09:55:21.480
现在我们要在这里加入醚。

7113
09:55:21.480 --> 09:55:23.943
如果我们看看我们的硬头。

7114
09:55:23.943 --> 09:55:24.419
配置。

7115
09:55:24.419 --> 09:55:29.220
ts，我们在这里仍然使用require，我们需要将它替换为导入，

7116
09:55:29.220 --> 09:55:33.721
你可以使用。env / config来获取你的。env文件。

7117
09:55:33.721 --> 09:55:37.611
现在我们已经导入了所有内容，回到我们的部署。

7118
09:55:37.611 --> 09:55:40.136
t，我们可以看到绒毛已经消失了。

7119
09:55:40.136 --> 09:55:47.734
如果你想更明确，我们可以继续添加import at nomic labs slash hard hat醚，就像这样。

7120
09:55:47.734 --> 09:55:55.615
我们不需要在这里导入它的原因是这两个包也与Hardhead醚，所以他们自动导入它。

7121
09:55:55.615 --> 09:55:59.595
但如果你想要非常明确，你可以这样添加它。

7122
09:55:59.595 --> 09:56:01.166
现在，我们差不多可以开始了。

7123
09:56:01.166 --> 09:56:04.357
但是请记住，我们的Harnett点配置也导入了我们的任务。

7124
09:56:04.357 --> 09:56:10.063
我们需要更新我们的任务或块号为TypeScript fide。

7125
09:56:10.063 --> 09:56:17.221
当然，这里不是const require，而是从斜杠配置导入task。

7126
09:56:17.221 --> 09:56:21.839
我们要确保从locknumber导出任务为默认值。

7127
09:56:21.839 --> 09:56:25.433
我们会像这样执行export default task。

7128
09:56:25.433 --> 09:56:29.134
现在我们应该可以运行脚本了。

7129
09:56:29.134 --> 09:56:34.918
所以我们可以做纱线，艺术帽，运行脚本，员工。

7130
09:56:34.918 --> 09:56:35.058
ts。

7131
09:56:35.058 --> 09:56:37.865
如果我们愿意，我们可以做网络安全帽。

7132
09:56:37.865 --> 09:56:38.808
而可畏。

7133
09:56:38.808 --> 09:56:43.663
现在，当我们进行测试的时候，这里的情况就有点不同了。

7134
09:56:43.663 --> 09:56:46.741
让我们继续，改变这个required to import。

7135
09:56:46.741 --> 09:56:48.894
只是为了让它开心。

7136
09:56:48.894 --> 09:56:53.655
让我们试着运行纱线，艺术头测试，我们得到了一大堆错误，

7137
09:56:53.655 --> 09:56:58.770
在VS code中实际上会继续从linter得到这些错误。

7138
09:56:58.770 --> 09:57:03.685
作为一名开发人员，在这个领域中遇到的最棘手的事情之

7139
09:57:03.685 --> 09:57:08.797
一是调用契约中的函数，而这些函数并不存在，反之亦然。

7140
09:57:08.797 --> 09:57:11.594
我们不会调用确实存在的契约函数。

7141
09:57:11.594 --> 09:57:16.941
现在，契约的类型只是契约类型，这没什么用，

7142
09:57:16.941 --> 09:57:22.035
因为契约类型不一定有我们想要的所有功能。

7143
09:57:22.035 --> 09:57:27.316
我们希望我们的契约是契约类型，但我们希望它们是我们的契约类型，因为

7144
09:57:27.316 --> 09:57:32.758
如果它们是我们的契约类型，它们就可以具有我们希望它们具有的所有功能。

7145
09:57:32.758 --> 09:57:41.282
要让合约有正确的类型，我们可以使用这个叫type chain的工具，它能让合约有正确的类型type chain有一个强化的插件，它

7146
09:57:41.282 --> 09:57:49.938
允许我们同时使用type chain和TypeScript, type chain / hard hat是我们已经安装过的东西之一。

7147
09:57:49.938 --> 09:57:54.157
要把它添加到我们的硬帽子，我们只需要进入硬帽子配置，

7148
09:57:54.157 --> 09:57:59.675
并在import @ type chain / arhat中添加它。

7149
09:57:59.675 --> 09:58:07.603
一旦我们把它导入到我们的配置中，如果我们运行yarn hardhat，我们会得到一个叫做type

7150
09:58:07.603 --> 09:58:16.358
chain的新任务，你读一下描述，它说为编译后的契约生成类型链类型，这将使我们所有的契约都有自己的类型。

7151
09:58:16.358 --> 09:58:21.173
我们可以有一个简单存储变量类型为简单存储契约，这

7152
09:58:21.173 --> 09:58:25.989
样更好，因为我们总能准确地知道每个契约能做什么。

7153
09:58:25.989 --> 09:58:30.289
为了创造这个，我们运行纱线，罗汉式链条。

7154
09:58:30.289 --> 09:58:37.429
这将创建一个名为type chain / types的新文件夹。

7155
09:58:37.429 --> 09:58:44.851
有了所有契约的类型，你甚至可以进入简单存储子Ts，它将有所有不同的函数和所有与简单存

7156
09:58:44.851 --> 09:58:52.273
储契约有关的东西自动编码为Typescript和JavaScript，这非常有帮助。

7157
09:58:52.273 --> 09:58:54.890
我还没有给你们展示这是什么。

7158
09:58:54.890 --> 09:59:02.909
但在。Git ignore中，我们通常想在。Git ignore中添加type chain和type chain dash类型，这样我们就不会把它们推到GitHub中。

7159
09:59:02.909 --> 09:59:09.046
现在回到我们的测试中，我们将在这里添加这些不同对象的确切类型。

7160
09:59:09.046 --> 09:59:12.973
我们会从刚创建的文件夹中导入它们。

7161
09:59:12.973 --> 09:59:19.804
我们会导入简单存储，逗号，简单存储下划线下划线

7162
09:59:19.804 --> 09:59:26.635
工厂从。点斜杠类型，ain斜杠类型，简单存储工

7163
09:59:26.635 --> 09:59:34.063
厂将是简单存储工厂然后民用存储当然，将是简单存储。

7164
09:59:34.063 --> 09:59:41.715
那么现在我们让简单存储工厂这是一种类型，简单存储，下

7165
09:59:41.715 --> 09:59:49.662
划线工厂，然后是简单存储，这是一种类型的简单存储合同。

7166
09:59:49.662 --> 09:59:58.484
如果我们命令点击到简单存储，我们可以看到所有我们所知道和喜欢的契约函数，都在这里。

7167
09:59:58.484 --> 10:00:02.796
此外，我们拥有实际合同本身的所有功能。

7168
10:00:02.796 --> 10:00:07.971
一旦我们这样做了，我们就很好了我们只需要在这里有一些新的东西。

7169
10:00:07.971 --> 10:00:11.686
领代工厂还型醚点代工厂。

7170
10:00:11.686 --> 10:00:16.692
我们只需要把它包装成一个简单的存储工厂类型。

7171
10:00:16.692 --> 10:00:19.534
我们就像这样裹一下。

7172
10:00:19.534 --> 10:00:24.068
我们会说，作为简单的存储，我将会像工厂一样。

7173
10:00:24.068 --> 10:00:25.459
可以开始了。

7174
10:00:25.459 --> 10:00:28.676
现在我们已经添加了所有这些，我们可以运行纱线，硬头测试。

7175
10:00:28.676 --> 10:00:31.101
我们的测试运行是正常的，

7176
10:00:31.101 --> 10:00:37.975
但是有了TypeScript和这些额外的输入，我们的生活大大改善了。

7177
10:00:37.975 --> 10:00:44.358
这就是你需要知道的关于TypeScript的所有知识，可重用，所有的分支都有一

7178
10:00:44.358 --> 10:00:50.905
个可选的TypeScript分支，你可以使用它来引用和使用TypeScript。

7179
10:00:51.360 --> 10:00:54.886
我们已经学习了所有不同的事情的基础，我们可以用hardhat。

7180
10:00:54.886 --> 10:00:59.653
接下来的几堂课，硬帽趣味梗和硬帽智能合约

7181
10:00:59.653 --> 10:01:04.660
彩票将成为我们在硬帽学习的所有工具的基础。

7182
10:01:04.660 --> 10:01:10.478
第八课将介绍全栈以及使用前端和构建全栈应用程序。

7183
10:01:10.478 --> 10:01:15.478
通过这门课程将给你所有的工具，开始你的web三旅程。

7184
10:01:15.478 --> 10:01:21.069
但如果你只是想学习基础知识，一定要把第九课学完。

7185
10:01:21.069 --> 10:01:26.601
如果你一直读到第十八课，你就会知道这个领域的所有前沿工具。

7186
10:01:26.601 --> 10:01:31.310
这样你就能轻松地成为该领域最优秀的开发人员之一。

7187
10:01:31.310 --> 10:01:33.835
所以希望你能坚持到最后。

7188
10:01:33.835 --> 10:01:40.497
这节课最重要的部分之一就是将我们的代码推送到GitHub，然后发一条推特庆祝我

7189
10:01:40.497 --> 10:01:47.160
们将我们的第一个智能合约第一个web 3 GitHub仓库推送到GitHub。

7190
10:01:47.160 --> 10:01:54.851
所以在继续下一课之前，一定要把这段代码放到GitHub上。

7191
10:01:54.851 --> 10:02:03.580
如果你想发一条推特来庆祝，但一定要去GitHub部分，因为我说过，很多时候网络空间是一个难以置信的

7192
10:02:03.580 --> 10:02:12.310
协作社区与GitHub或GitLab，或任何其他版本控制工具合作对你在这个领域的成功是必不可少的。

7193
10:02:12.360 --> 10:02:14.265
所以一定要做到这一点。

7194
10:02:14.265 --> 10:02:14.900
好吧。

7195
10:02:16.361 --> 10:02:19.694
我们课程的“资助我”部分。

7196
10:02:21.361 --> 10:02:28.404
我们将上传我们的第一个代码库到GitHub如果你从来没有做过这个，这一节我们将学习更

7197
10:02:28.404 --> 10:02:35.615
多关于hardhat的知识使用我们已经使用过的熟悉的契约库，也就是fund me契约。

7198
10:02:35.615 --> 10:02:42.075
如果你正在使用与本课程相关的GitHub回购，你可以向下滚动到Hardhead Funmi。

7199
10:02:42.075 --> 10:02:45.884
所有的代码都在我们的回购单上。

7200
10:02:45.884 --> 10:02:51.454
如果你想做一个快速的开始，你可以把它克隆到CVU中，然后运行yarn，然

7201
10:02:51.454 --> 10:02:57.180
后运行yarn hardhat部署这个，我将简要地向你展示它是什么样子的。

7202
10:02:57.180 --> 10:03:02.533
在VS code中，你可以做gitclone，抓

7203
10:03:02.533 --> 10:03:07.886
取包，cd进去，然后输入code period。

7204
10:03:07.886 --> 10:03:10.161
在新的VS代码中打开它。

7205
10:03:10.161 --> 10:03:13.570
一旦你进入文件夹，你可以继续运行纱线。

7206
10:03:13.570 --> 10:03:20.009
要安装与此项目一起工作的所有依赖项，您计划使用测试网或以太扫描或货币市值，请

7207
10:03:20.009 --> 10:03:26.619
随意使用私钥RPC URL、玉米市值密钥和以太扫描密钥填写您的Dotty和V。

7208
10:03:26.619 --> 10:03:34.264
然后你就可以跟着自述使用这个回购来运行纱线，硬帽部署。

7209
10:03:34.361 --> 10:03:37.651
它会展示如何部署一些契约和一些模拟等等。

7210
10:03:37.651 --> 10:03:42.199
所以让我们自己来建造它吧。

7211
10:03:42.199 --> 10:03:49.094
现在我们要为这个项目创建一个新目录，它的设置和我们之前见过的一样。

7212
10:03:49.094 --> 10:03:51.360
MK dir，安全帽。

7213
10:03:51.360 --> 10:03:56.683
我，FCC，我们将在Funmi cd到心脏，FCC，然后输入代码期。

7214
10:03:56.683 --> 10:04:05.299
如果代码段不适合你，你完全可以点击文件，打开文件夹，就像我们之前展示的那样。

7215
10:04:05.299 --> 10:04:07.080
现在，我们在一个全新的文件夹里。

7216
10:04:07.080 --> 10:04:09.497
我们要在这里加上安全帽。

7217
10:04:09.497 --> 10:04:15.912
我们要去跑纱线，加上冲刺戴夫，戴安全帽。

7218
10:04:15.912 --> 10:04:20.492
现在我们有了hardhat，在我们的包JSON和

7219
10:04:20.492 --> 10:04:25.263
节点模块中，我们可以继续运行yarn，启动app。

7220
10:04:25.263 --> 10:04:32.200
它会说，你想做什么?我将在这里选择高级示例项目，向您展示如何进行。

7221
10:04:32.200 --> 10:04:35.395
我们要用一种我认为最有效的方式来设置。

7222
10:04:35.395 --> 10:04:37.598
我们继续做高级示例项目。

7223
10:04:37.598 --> 10:04:39.412
是的，我们要把它作为根结点。

7224
10:04:39.412 --> 10:04:41.062
是的，我们想添加一个Git忽略。

7225
10:04:41.062 --> 10:04:45.112
它还希望我们添加许多样例项目依赖项。

7226
10:04:45.112 --> 10:04:46.762
我们点击确定。

7227
10:04:46.762 --> 10:04:52.002
但我们最终不会用到所有这些我会告诉你们哪些是我们不会用到的以及为什么。

7228
10:04:52.002 --> 10:04:56.807
但现在，让我们继

7229
10:04:56.807 --> 10:05:01.612
续并点击yes。

7230
10:05:02.362 --> 10:05:03.603
好吧，太棒了。

7231
10:05:06.362 --> 10:05:06.495
在这里。

7232
10:05:08.362 --> 10:05:08.808
在这里。

7233
10:05:11.362 --> 10:05:16.674
模块，也就是同样的脚本同样的测试也一样。

7234
10:05:16.674 --> 10:05:20.599
这里有一个。E和V。的例子。

7235
10:05:20.599 --> 10:05:21.806
它还附带。

7236
10:05:21.806 --> 10:05:23.250
Es lint文件。

7237
10:05:23.250 --> 10:05:25.361
es绒线，RC点j s。

7238
10:05:25.361 --> 10:05:25.583
es。

7239
10:05:25.583 --> 10:05:30.278
Lint被称为JavaScript linter，它可以帮

7240
10:05:30.278 --> 10:05:35.136
助您查找并自动修复我使用的JavaScript代码中的问题。

7241
10:05:35.136 --> 10:05:37.963
我不是ES lint的大粉丝，所以我通常不使用它。

7242
10:05:37.963 --> 10:05:40.608
我要把这两个删掉。

7243
10:05:40.608 --> 10:05:43.658
如果你想保留它们，你完全可以忽略。Git。

7244
10:05:43.658 --> 10:05:48.790
我们将在这节课中最终理解这个文件的作用NPM ignore帮

7245
10:05:48.790 --> 10:05:53.922
助忽略文件如果你想将你的项目升级为NPM包，我们不会这么做。

7246
10:05:53.922 --> 10:05:57.459
如果你想删除这个，你也可以pretty或忽略它，然后pretty DRC。

7247
10:05:57.459 --> 10:05:59.072
我们已经知道它们的作用了，小提示。

7248
10:05:59.072 --> 10:06:05.122
还有hint ignore，我们一会儿会讲到，还有Hardhead config，

7249
10:06:05.122 --> 10:06:13.091
它已经包含了ropsten网络，gas报告器和ether扫描包。JSON以及所有附加包，自述文件更健壮一些。

7250
10:06:13.091 --> 10:06:14.982
当然，我们的纱线点锁定。

7251
10:06:14.982 --> 10:06:20.887
这个高级项目看起来和我们将要处理的很相似。

7252
10:06:20.887 --> 10:06:24.230
现在我想谈谈这个灵魂暗示。

7253
10:06:24.230 --> 10:06:29.568
溶剂溶剂被称为固体洗涤器我们可以用它来洗涤我们的

7254
10:06:29.568 --> 10:06:35.130
代码洗涤是运行一个程序来分析代码的潜在错误的过程。

7255
10:06:35.130 --> 10:06:42.363
它也做一些格式化，通常情况下，Lint是对JavaScript代码进行Lint的一种方法。

7256
10:06:42.363 --> 10:06:47.991
hint是一种对固体性代码进行lint的方法，我们用pretty来格式化我们的代码，

7257
10:06:47.991 --> 10:06:55.363
我们可以用soul hint来lint，我们的代码，它们经常互换使用，尽管这并不完全正确，因为它们有一点不同。

7258
10:06:55.363 --> 10:07:03.459
我们可以通过运行yarn、sole hint在代码上运行这个lint，然后输入我们想要lint的文件的名称。

7259
10:07:03.459 --> 10:07:10.903
我们做合同，斜杠然后你就可以开始了一切看起来都很好，什么都不会发生。

7260
10:07:10.903 --> 10:07:16.583
假设我们有一个变量我们没有明确说它的可见性。

7261
10:07:16.583 --> 10:07:23.815
这并不是最佳实践，因为在理想情况下，我们总是确切地说明某些变量的可见性。

7262
10:07:23.815 --> 10:07:25.266
这显然是默认的。

7263
10:07:25.364 --> 10:07:27.478
但通常更明确一点会更好。

7264
10:07:28.364 --> 10:07:35.450
yarn，所以hint，契约启动，它会给我们一个警告，说我们应该显式地

7265
10:07:35.450 --> 10:07:42.739
标记状态的可见性，这个linter是检查运行代码的一些最佳实践的好方法。

7266
10:07:42.739 --> 10:07:47.801
所以我们肯定会在周围留一个小提示。

7267
10:07:47.801 --> 10:07:52.855
现在我们已经在这里得到了一个回购，让我们在这里添加一些常见的设置部件。

7268
10:07:52.855 --> 10:07:54.170
所以在pretty中。

7269
10:07:54.170 --> 10:07:59.073
Rc，我们要把这个换成我们一直用的那个。

7270
10:07:59.073 --> 10:08:03.538
表单us选项卡的选项卡为假，半假，单引号，也是假。

7271
10:08:03.538 --> 10:08:09.781
我们将更新更漂亮的。ignore node模块，package。JSON图

7272
10:08:09.781 --> 10:08:16.025
像构件，缓存覆盖率ID。v。*，自述，覆盖率以及其他你想添加到这里的东西。

7273
10:08:16.025 --> 10:08:18.804
滚动到合约文件夹。

7274
10:08:18.804 --> 10:08:22.610
我们要把这个greeting。soul换成fund me。soul。

7275
10:08:22.610 --> 10:08:25.625
现在让我们在这里添加契约。

7276
10:08:25.625 --> 10:08:34.301
如果你跟着回购，你会进入合同文件夹，这里还有一个文件夹合同看起来有点不同。

7277
10:08:34.301 --> 10:08:41.030
如果你有这些契约，从remix中窃取，让我们从remix中获取它们因为我们要对它们做一些改变。

7278
10:08:41.030 --> 10:08:46.566
如果你没有再做混音了，也许你不应该，因为你应该休息一下，

7279
10:08:46.566 --> 10:08:52.301
你可以跳到第四课的混音Funmi跳到这里，从里面拿到合约。

7280
10:08:52.364 --> 10:08:56.140
只要去乐趣v破折号免费代码营教程，并从那里获取代码。

7281
10:08:56.140 --> 10:08:59.490
我们会抓取fun me和price converter。soul。

7282
10:08:59.490 --> 10:09:05.429
删除旧文件，创建一个新文件，命名为fundme。song。

7283
10:09:05.429 --> 10:09:06.880
粘贴进去。

7284
10:09:06.880 --> 10:09:11.745
然后我们要创建价格转换器。

7285
10:09:11.745 --> 10:09:12.792
这是所有。

7286
10:09:12.792 --> 10:09:17.500
现在我们有我们的Funmi和我们的价格转换合同在这里。

7287
10:09:17.500 --> 10:09:24.882
现在我们要做的第一件事我们上次做的第一件事之一是我们运行yarn compile以确保我们的代码按我们想要的方式运行。

7288
10:09:24.882 --> 10:09:32.380
在我们点击编译之前，我们需要做的一件事是进入Hardhead。config，我们要确保我们在正确的固体度版本上。

7289
10:09:32.380 --> 10:09:34.538
所以是(0,8)

7290
10:09:34.538 --> 10:09:34.918
8在这里。

7291
10:09:34.918 --> 10:09:39.247
让我们继续尝试编译。

7292
10:09:39.365 --> 10:09:42.605
所以我们可以运行纱线硬头编译。

7293
10:09:44.365 --> 10:09:45.783
这里会有一个错误。

7294
10:09:47.365 --> 10:09:53.880
未安装从合约导入的合约，请尝试使用npm安装它。

7295
10:09:53.880 --> 10:10:00.069
在混音中，我们直接从NPM和GitHub导入chainlink slash合同。

7296
10:10:00.069 --> 10:10:07.318
但在我们的本地代码中，我们必须明确地告诉Hardhead，从哪里获得这

7297
10:10:07.318 --> 10:10:13.946
个，我们想要从NPM包管理器下载这个，我们可以通过运行yarn，

7298
10:10:13.946 --> 10:10:22.233
在chainlink slash contracts中添加破折号dev来下载它。

7299
10:10:23.365 --> 10:10:27.615
现在我们已经将它下载到我们的文件中，我们将能够在这里的Node模块中看到它。

7300
10:10:27.615 --> 10:10:34.235
Hardhead现在足够聪明，知道在chain link斜杠契约将指向我们所拥有的节点模块。

7301
10:10:34.235 --> 10:10:41.508
所以我们现在可以运行yarn Hardhead编译boom，现在我们可以看到编译成功的三个固体文件。

7302
10:10:41.508 --> 10:10:48.575
现在我们的契约在这里，代码编译成功了。

7303
10:10:48.575 --> 10:10:53.348
我们可能会想要部署我们的代码?在最后一节中，我们使用了脚本模块。

7304
10:10:53.348 --> 10:10:56.225
我们制作了自己的手动部署脚本。

7305
10:10:56.366 --> 10:11:04.866
然而，你会注意到，你越是使用原始醚，甚至只是使用硬帽跟踪我们所有的部署就会变得有点棘手。

7306
10:11:04.866 --> 10:11:08.753
如果只使用部署脚本，它不会将部署保存到任何文件中。

7307
10:11:08.753 --> 10:11:16.769
此外，在部署脚本中包含用于部署的所有内容可能会使测试和部署脚本不能完全协同工作。

7308
10:11:16.769 --> 10:11:21.307
还有一些其他的事情可能会有点棘手，我们实际上要用一个包

7309
10:11:21.307 --> 10:11:26.015
来解决我刚才提到的所有问题，还有一些其他的事情会更容易。

7310
10:11:26.015 --> 10:11:30.313
我说的这个包就是硬帽部署包。

7311
10:11:30.313 --> 10:11:34.579
在与本课程相关的GitHub存储库中有这个包的链接。

7312
10:11:34.579 --> 10:11:38.307
它是一个用于可复制部署和易于测试的硬帽插件。

7313
10:11:38.366 --> 10:11:42.738
如果我们向下滚动到安装，我们可以看到我们用正常的方式安装它。

7314
10:11:42.738 --> 10:11:43.958
他们使用的是npm。

7315
10:11:43.958 --> 10:11:46.529
我们要继续用纱线。

7316
10:11:46.529 --> 10:11:51.384
为了添加它，我们会使用yarn，添加hardhat dash deploy。

7317
10:11:51.384 --> 10:11:56.075
当然，我们要做的是冲刺戴夫。

7318
10:11:56.075 --> 10:12:01.970
一旦完成部署这个require语句到我们的硬帽子。

7319
10:12:01.970 --> 10:12:02.595
配置。

7320
10:12:02.595 --> 10:12:02.803
js。

7321
10:12:02.803 --> 10:12:06.316
再一次，配置基本上是我们的入口点。

7322
10:12:06.316 --> 10:12:08.445
我们就从这里开始。

7323
10:12:08.445 --> 10:12:11.111
我们可以删除我们的deploy。

7324
10:12:11.111 --> 10:12:11.779
js脚本。

7325
10:12:11.779 --> 10:12:18.103
现在如果我们运行yarn hardhat，你会看到这里有一堆新任务，

7326
10:12:18.103 --> 10:12:24.428
其中一个是这个部署任务，这个部署任务将是我们用来部署契约的主要任务。

7327
10:12:24.428 --> 10:12:32.754
我们不会在scripts文件夹中写入部署脚本，我们会创建一个新文件夹，我们可以通过mkdir deploy创建一个新文件夹。

7328
10:12:32.754 --> 10:12:35.915
或者你也可以右键点击，点击新建文件夹。

7329
10:12:35.915 --> 10:12:40.673
这个deploy文件夹将是许多硬帽部署模块用于部署代码的地方。

7330
10:12:40.673 --> 10:12:43.301
这将是我们写剧本的地方。

7331
10:12:43.301 --> 10:12:46.735
要编写脚本，我们通常需要在这里添加一个东西。

7332
10:12:46.735 --> 10:12:52.992
因为我们将在所有脚本中使用ethers JS，所以我们想在这里将Hardhead deploy ethers添加到包中。

7333
10:12:52.992 --> 10:12:59.367
现在，我们不只是做yarn，添加dash dev来部署醚，我们要做一些有点奇怪的事情。

7334
10:12:59.367 --> 10:13:04.817
我们会使用yarn add或npm install dash Dev，我们会像这样安装它。

7335
10:13:04.817 --> 10:13:06.055
我复制一下。

7336
10:13:06.055 --> 10:13:08.071
你可以直接从回购协议上抄下来。

7337
10:13:08.071 --> 10:13:12.296
我们会选择yarn，添加dash Dev，然后粘贴到这里。

7338
10:13:12.367 --> 10:13:20.500
我们所做的是在nomic实验室，我们用过的硬帽醚，我们用硬帽部署醚覆盖它。

7339
10:13:20.500 --> 10:13:24.334
记得我们在上一个项目中是如何使用硬帽醚的吗?

7340
10:13:24.334 --> 10:13:28.070
所以这个安全帽可以覆盖以太来使用安全帽部署。

7341
10:13:28.070 --> 10:13:35.167
我们使用硬帽部署醚，所以硬帽部署可以覆盖Hardhead, Hardhead会覆盖醚，这很有趣。

7342
10:13:35.167 --> 10:13:43.144
当你这样说的时候，这将使醚能够跟踪和记住我们在合同中实际做的所有不同的部署。

7343
10:13:43.144 --> 10:13:48.736
看看我们的JSON包，我们可以看到nomic labs仪表盘有醚。

7344
10:13:48.736 --> 10:13:51.259
现在它的版本是MPM。

7345
10:13:51.259 --> 10:13:52.747
Hardhead部署醚。

7346
10:13:52.747 --> 10:13:57.368
这是我们的package。JSON，意思是hardhat ethers包

7347
10:13:57.368 --> 10:14:02.118
现在被hardhat deploy ethers包覆盖，这就是我们想要的。

7348
10:14:02.118 --> 10:14:03.055
好了,好了。

7349
10:14:03.055 --> 10:14:08.313
现在我们有了这个设置，我们可以开始写部署脚本了，Hart的工作方式是所

7350
10:14:08.313 --> 10:14:13.722
有添加到deploy文件夹的脚本在我们运行yarn，硬帽部署时都会运行。

7351
10:14:13.722 --> 10:14:18.499
因此，一个好的实践通常是给它们编号，以便它们按照您希望的顺序运行。

7352
10:14:18.499 --> 10:14:24.687
因为我们只有一个合同，我们想要部署Funmi合同，我们将执行01

7353
10:14:24.687 --> 10:14:32.810
deploy Funmi Jas，在这个脚本中，我们将在这里定义如何部署基本合同。

7354
10:14:32.810 --> 10:14:35.819
好，我们在部署Funmi脚本中。

7355
10:14:35.819 --> 10:14:41.008
传统上，我们做了什么，我们做了导入，我们做了主函数。

7356
10:14:41.008 --> 10:14:45.630
然后我们调用main function, Hardhead deploy

7357
10:14:45.630 --> 10:14:50.253
有点不同，我们仍然会导入库和包，但我们不会有main function。

7358
10:14:50.253 --> 10:14:59.141
当我们运行Hardhead deploy时，我们也不会调用main函数Harnett deploy实际上会调用我们指定的函数。

7359
10:14:59.141 --> 10:15:00.240
在这个脚本里。

7360
10:15:00.240 --> 10:15:06.279
我们要做的是创建一个函数，命名为deploy funk。

7361
10:15:06.368 --> 10:15:12.690
我们会导出这个deploy函数作为Hardhead deploy寻找的默认函数，因此我们可

7362
10:15:12.690 --> 10:15:19.013
以说，module that exports。default = deploy funk。

7363
10:15:19.013 --> 10:15:24.284
为了测试它，我们可以继续执行console。log，嗨。

7364
10:15:24.284 --> 10:15:29.505
然后在我们的终端，运行纱线，安全帽，部署。

7365
10:15:29.505 --> 10:15:33.214
哎呀，把括号去掉。

7366
10:15:33.214 --> 10:15:33.767
对不起。

7367
10:15:33.767 --> 10:15:34.967
再运行一次。

7368
10:15:34.967 --> 10:15:39.175
我们可以看到它运行了这里的deploy func。

7369
10:15:39.175 --> 10:15:44.057
如果这个语法更容易理解，可以使用这个语法我们

7370
10:15:44.057 --> 10:15:49.162
会在运行时环境中将心脏作为参数传递给这个函数。

7371
10:15:49.162 --> 10:15:57.758
但是，如果我们转到heart hat部署文档，向下滚动到示例脚本，语法看起来有点不同。

7372
10:15:57.758 --> 10:16:01.969
让我来解释一下这是怎么回事以及我们要怎么写我们的。

7373
10:16:01.969 --> 10:16:08.961
与其像这样定义所有东西，并定义函数名，就像我们之前做的那样，我们实际上要使

7374
10:16:08.961 --> 10:16:16.143
用一个无名称的同步函数，我们要使它成为一个匿名函数，就像我们之前看到的那样。

7375
10:16:16.143 --> 10:16:23.877
相反，我们会像这样说async参数，我将在运行时环境中传递我们的参数。

7376
10:16:23.877 --> 10:16:26.335
这是一个箭头函数。

7377
10:16:26.335 --> 10:16:31.589
然后我们将把这整个东西包装在模块。exports中。

7378
10:16:31.589 --> 10:16:39.702
我们会说，module。exports，等于这个async函数，像这样。

7379
10:16:39.702 --> 10:16:47.190
这里的语法和上面的几乎一样，我们只是没有async函数的名字。

7380
10:16:47.190 --> 10:16:50.046
这就是我们要设置它的方法。

7381
10:16:50.046 --> 10:16:56.797
但是如果这个语法对你来说有一点困惑你可以随意使用上面的这个因为这两个是一样的。

7382
10:16:56.797 --> 10:17:04.569
接下来大部分文档做的是它从我们将要使用的HRV中取出变量和函数。

7383
10:17:04.569 --> 10:17:07.210
HRV是运行时环境的核心。

7384
10:17:07.210 --> 10:17:12.467
当我们运行部署脚本时，heart hat deploy会自动调

7385
10:17:12.467 --> 10:17:17.894
用这个函数，并将硬帽对象传递给它，就像硬帽简单存储中的后面一样。

7386
10:17:17.894 --> 10:17:19.674
在我们的部署脚本中。

7387
10:17:19.674 --> 10:17:24.322
我们在网络中运行的以太来自于硬帽，而不是硬帽。

7388
10:17:24.370 --> 10:17:27.512
我们来自HRV，这基本上和安全帽是一样的。

7389
10:17:27.512 --> 10:17:34.735
对于我们的脚本，当使用const时，我们将只使用来自陪审团的两个变量。

7390
10:17:34.735 --> 10:17:38.052
获取命名帐户。

7391
10:17:38.052 --> 10:17:40.845
和部署。

7392
10:17:41.370 --> 10:17:43.666
这个语法可能看起来有点奇怪。

7393
10:17:44.370 --> 10:17:47.042
一种从树中提取这些变量的方法。

7394
10:17:47.370 --> 10:17:54.570
这和树。获取命名帐户和HRA。部署是一样的。

7395
10:17:54.570 --> 10:17:59.606
但像这样把它们拉出来意味着我们不需要再在一开始加树了。

7396
10:17:59.606 --> 10:18:04.644
此外，JavaScript还有一种叫做“语法糖”的东西。

7397
10:18:04.644 --> 10:18:11.314
所以我们不用像这样在两行上做，我们可以在一行上做整位。

7398
10:18:11.314 --> 10:18:18.094
相反，我们只是外推这两个变量，就在函数声明中。

7399
10:18:18.094 --> 10:18:21.956
这条线和这条线是一样的。

7400
10:18:21.956 --> 10:18:28.636
这是一个使用箭头符号的异步、无名称函数，或者使用这里的部署脚本。

7401
10:18:28.636 --> 10:18:31.658
我们默认用module。exports导出它。

7402
10:18:31.658 --> 10:18:33.036
我不知道那是不是很多。

7403
10:18:33.036 --> 10:18:35.588
另一个是这里有很多语法糖。

7404
10:18:35.588 --> 10:18:39.475
但如果这对你来说真的很困惑，请随意使用上面的方法。

7405
10:18:39.475 --> 10:18:44.871
当我们提到get named accounts时，你也可以只做一个3。

7406
10:18:44.871 --> 10:18:50.423
get named accounts，或者一个3。deployment。

7407
10:18:50.423 --> 10:18:59.303
所以希望，这很清楚上面的部分和下面的部分是一样的，你觉得用哪个更舒服就用哪个。

7408
10:18:59.371 --> 10:19:02.799
但是好了，现在我们已经解决了所有的问题，让我们继续这个脚本。

7409
10:19:02.799 --> 10:19:07.302
我们使用这个部署对象，通过这个部署对象得到两个

7410
10:19:07.302 --> 10:19:12.002
函数，这两个函数是deploy函数和log函数。

7411
10:19:12.002 --> 10:19:15.080
我们写入const，即部署日志=部署。

7412
10:19:15.080 --> 10:19:19.287
我们会把这两个函数从部署中取出来。

7413
10:19:19.287 --> 10:19:23.203
然后我们还会做const Deployer。

7414
10:19:23.371 --> 10:19:26.447
等号等待，获得命名帐户。

7415
10:19:28.371 --> 10:19:35.523
这个新的部署函数，这个新的日志函数，我们从这个奇怪的get named accounts函数获取部署者帐户。

7416
10:19:35.523 --> 10:19:42.306
这个get named accounts函数是什么呢，这个get named accounts是一种获取指定账户的方法。

7417
10:19:42.371 --> 10:19:47.215
在使用以太时，我们在使用以太时看到，我们实际上可以根

7418
10:19:47.215 --> 10:19:52.246
据每个网络的Account部分中的数字获得我们的帐户。

7419
10:19:52.246 --> 10:19:58.412
举个例子，在这个私钥列表中，私钥0私钥1私钥2，

7420
10:19:58.412 --> 10:20:04.578
记住哪个可能有点混乱所以我们可以在底部添加一个叫

7421
10:20:04.578 --> 10:20:10.746
做命名帐户的部分我们可以在帐户数组中命名每个点。

7422
10:20:10.746 --> 10:20:12.467
我们用命名账户。

7423
10:20:12.467 --> 10:20:17.129
其中一个帐户将命名为Deployer。

7424
10:20:17.129 --> 10:20:22.725
默认情况下，带account的0是Deployer。

7425
10:20:22.725 --> 10:20:28.904
我们还可以指定哪个数字将是跨不同链的部署者帐户。

7426
10:20:28.904 --> 10:20:36.819
例如，在Rigby上，我们希望部署者帐户是第一个位置，我们可以这样做，在hard hat上，我们可以这样做。

7427
10:20:36.819 --> 10:20:38.404
我们可以创建多个用户。

7428
10:20:38.404 --> 10:20:46.657
例如，如果我们想为某个测试做一个用户，我们会在这里说default是1或任何我们想要的东西。

7429
10:20:46.657 --> 10:20:52.802
回到我们的部署，我们说我们要从命名账户中抓取部署者账户。

7430
10:20:52.802 --> 10:20:57.752
最后，我们要获取链ID原因很快就会清楚了。

7431
10:20:57.752 --> 10:21:04.277
我们写入const, chain ID = network。config。chain ID。

7432
10:21:04.277 --> 10:21:12.318
现在，我们如何实际部署这个资金我合同?我们想一下这个问题。

7433
10:21:12.372 --> 10:21:16.581
在做混音的时候，这很简单，对吧?我们刚把它部署到一个测试网上。

7434
10:21:16.581 --> 10:21:21.572
啊，这就是问题所在，把它部署到溜冰场上，测试网有点慢。

7435
10:21:21.572 --> 10:21:28.628
我们并不总是想要部署到这些慢速测试网甚至是一个主网当我们修补和摆弄我们的合同时，我们知

7436
10:21:28.628 --> 10:21:35.684
道那将是非常糟糕的，我们真的想部署到一个测试网作为我们在本地完成所有测试后的最后一站。

7437
10:21:35.684 --> 10:21:42.635
或者我们可以将其部署到一个测试中，以查看一些非常特定的代码是否工作，例如，使用链链接文档。

7438
10:21:42.635 --> 10:21:45.597
所以理想情况下，我们先把它部署到本地网络。

7439
10:21:45.597 --> 10:21:52.835
但我们能这么做吗?如果我们看一下价格转换器，点Seoul，这里有这个硬编码地址，这个0x

7440
10:21:52.835 --> 10:22:00.073
地址，如果我们去Doc的点chain链接EVM链，Aetherium数据供给的合同地址。

7441
10:22:00.073 --> 10:22:03.854
那个地址是第eth USD，是专门给Rinkeby的。

7442
10:22:03.854 --> 10:22:10.759
如果我们在安全帽网络工作呢?例子吗?默认网络吗?安全帽。

7443
10:22:10.759 --> 10:22:15.587
就像我之前说的，如果你不写这部分，它就会自动成为默认网络。

7444
10:22:15.587 --> 10:22:19.730
但如果我们指向硬帽子网络，硬网络是一个空白的区块链。

7445
10:22:19.730 --> 10:22:24.360
每次脚本完成时，它都会被销毁，即使我们使用本地节点，

7446
10:22:24.360 --> 10:22:29.169
这个价格提要契约也不存在，其中一个代码不会用数据更新。

7447
10:22:29.169 --> 10:22:34.591
那么我们该怎么办呢?我们如何在本地测试和与代码交互?我们有办法做到这一点吗?我们可

7448
10:22:34.591 --> 10:22:40.147
以这样做的一种方法我们稍后会学到一点实际上是fork一个区块链，你可以把东西硬编码。

7449
10:22:40.147 --> 10:22:45.741
但通常，最好还是弄清楚如何使用所谓的mock来完成所有事情。

7450
10:22:45.741 --> 10:22:53.717
Stack Overflow上有一个很好的问题，什么是mock，而mock主要用于单元测试，这个我们稍后会讲到。

7451
10:22:53.717 --> 10:22:57.760
被测试对象可能依赖于其他复杂对象。

7452
10:22:57.760 --> 10:23:06.601
为了隔离对象的行为，需要用模拟真实对象行为的mock替换其他对象。

7453
10:23:06.601 --> 10:23:10.891
简而言之，模拟就是创建模拟真实对象行为的对象。

7454
10:23:10.891 --> 10:23:13.928
现在，这可能看起来有很多单词。

7455
10:23:13.928 --> 10:23:20.717
但基本上，我们想做的是我们想做一个假的价格供给合同我们可以使用，我们可以在本地工作时控制它。

7456
10:23:20.717 --> 10:23:25.995
回到这里，我在这里留个便条说，当选择本地

7457
10:23:25.995 --> 10:23:31.273
主机或硬帽网络时，我们想要使用mock。

7458
10:23:31.273 --> 10:23:36.017
好的，很好，我们可以用一个模拟，我们一会儿会学习如何制作一个。

7459
10:23:36.017 --> 10:23:41.956
好吧，当我们想要改变链，例如，回到点。

7460
10:23:41.956 --> 10:23:51.023
点链链接EVM链，合同地址，有很多不同的区块链有价格供给。

7461
10:23:51.023 --> 10:23:56.109
在每一个区块链上，eth美元价格feed会有一点不同。

7462
10:23:56.109 --> 10:24:02.461
例如，我们在看ETH美元，Aetherium主网的ETH美元地址与Rigby的ETH

7463
10:24:02.461 --> 10:24:08.814
美元地址是不同的，这是有意义的，它们是不同链上完全不同的合同，它们有非常相似的功能。

7464
10:24:08.814 --> 10:24:10.169
它们做着几乎完全相同的事情。

7465
10:24:10.169 --> 10:24:12.115
但它们仍然是不同的。

7466
10:24:12.115 --> 10:24:17.621
我们还需要一种方法来模块化或参数化，这里的这个地址，这样无论我们部

7467
10:24:17.621 --> 10:24:23.127
署到哪个链，我们都不需要改变任何代码，我们总是可以让代码完全相同。

7468
10:24:23.127 --> 10:24:27.293
我们不需要到这里来翻转值翻转变量之类的。

7469
10:24:27.293 --> 10:24:30.986
下面的内容我们要记住这些。

7470
10:24:30.986 --> 10:24:32.856
现在为了参数化。

7471
10:24:32.856 --> 10:24:37.598
我们实际上想要分清轻重缓急，对我们的基本灵魂做一点重构。

7472
10:24:37.598 --> 10:24:42.675
重构基本上意味着回去改变代码的工作方式。

7473
10:24:42.675 --> 10:24:50.804
现在我们有这个构造函数构造函数是每当我们部署契约时自动被调用的函数。

7474
10:24:50.804 --> 10:24:56.357
现在它没有做很多事情它只是将owner变量更新为契约中发送的对象。

7475
10:24:56.357 --> 10:24:59.066
但实际上我们可以做的远不止这些。

7476
10:24:59.066 --> 10:25:04.979
因为这个构造函数和其他函数一样是一个函数，我们可以让它

7477
10:25:04.979 --> 10:25:11.111
接受参数，我们希望它拥有的其中一个参数是价格提要的地址。

7478
10:25:11.111 --> 10:25:14.077
让我们继续，添加这个，看看如何重构所有这些代码。

7479
10:25:14.077 --> 10:25:19.701
我们会在这里为构造函数添加构造函数地址和价格提要。

7480
10:25:19.701 --> 10:25:21.078
当我们部署契约时。

7481
10:25:21.078 --> 10:25:25.511
现在我们将根据我们所处的链向它传递第eth个USD价格提要地址。

7482
10:25:25.511 --> 10:25:34.098
如果我们在溜冰场B，我们将使用这个地址如果一个多边形将使用不同的一个b&b，不同的一个，Gnosis hecho，雪崩等，你知道的。

7483
10:25:34.098 --> 10:25:36.582
我们要像这样把它边缘化。

7484
10:25:36.582 --> 10:25:39.448
现在，我们的构造函数接受了价格提要的参数，

7485
10:25:39.448 --> 10:25:49.685
我们实际上可以在价格转换器中保存一个aggregator v3接口对象作为全局变量，我们只需创建一个aggregator v3 interface类型

7486
10:25:49.685 --> 10:25:56.375
一个aggregator v3 interface类型的价格提要变量，同样，我们从chainlink repo导入它，这是一个被编译到ABI的接口对象。

7487
10:25:56.375 --> 10:26:00.510
如果将ABI与up匹配到一个地址，就会得到一个可以与之交互的契约。

7488
10:26:00.510 --> 10:26:01.899
我们在这里做同样的事情。

7489
10:26:01.899 --> 10:26:08.093
我们会说，聚合Tor, v3接口，公共价格提要，配给

7490
10:26:08.093 --> 10:26:14.287
然后调用这个价格提要地址这样它们就不会有相同的名称。

7491
10:26:14.287 --> 10:26:22.754
在构造函数中，我们会说，price feed =我们会做和价格转换

7492
10:26:22.754 --> 10:26:31.222
器= aggregate一样的事情在价格feed地址的三个接口中。

7493
10:26:31.222 --> 10:26:36.589
就像现在，我们有这个可变的模块化的

7494
10:26:36.589 --> 10:26:42.273
价格提要地址，取决于我们在哪个链上。

7495
10:26:42.273 --> 10:26:47.937
现在，我们能做的是获取这个价格提要地址，我们能把它用于我们的价格转换器。

7496
10:26:47.937 --> 10:26:55.585
那么我们在哪里使用价格转换器呢?提醒一下，我们用的价格转换器是256。

7497
10:26:55.585 --> 10:26:59.646
我们把它用作256单元类型上的一个库。

7498
10:26:59.646 --> 10:27:03.568
我们调用message。value。get转化率。

7499
10:27:03.568 --> 10:27:10.371
我们看一下价格转换器，我们有这个函数get conversion rate，它以FML作为初始参数，因

7500
10:27:10.371 --> 10:27:17.309
为这是一个库，它会自动将message。value传递给这个get conversion rate函数。

7501
10:27:17.375 --> 10:27:24.907
但我们也可以传入这个价格提要，因此我们不再需要在get价格中硬编码它。

7502
10:27:24.907 --> 10:27:27.185
我们来看看怎么做。

7503
10:27:27.185 --> 10:27:32.323
我们能做的是，我们能做message。value。get转化率，我们会在这里插入价格feed。

7504
10:27:32.323 --> 10:27:37.794
然后我们需要更新get转换速率用逗号这样它有第二个参数，

7505
10:27:37.794 --> 10:27:42.876
因为，记住，初始参数将是message。value。

7506
10:27:42.876 --> 10:27:47.328
第二个参数就是我们在这里定义的。

7507
10:27:47.328 --> 10:27:53.601
我们写s amount，逗号agreg gate torv3接口。

7508
10:27:53.601 --> 10:27:57.601
我们称之为价格供给。

7509
10:27:57.601 --> 10:28:05.409
现在，当我们调用get价格函数时，我们可以把价格信息传递给get价格函数。

7510
10:28:05.409 --> 10:28:08.010
上面这里是get price。

7511
10:28:08.010 --> 10:28:12.402
你猜它是一个集合或者

7512
10:28:12.402 --> 10:28:17.235
三个接口叫做价格供给。

7513
10:28:17.235 --> 10:28:22.893
现在我们不再需要在价格提要中硬编码。

7514
10:28:22.893 --> 10:28:28.501
我们可以删除这些行，让它像这样编译，这太棒了。

7515
10:28:28.501 --> 10:28:34.666
快速复习一下，我们将价格提要地址参数化并通过构造函数将其作为

7516
10:28:34.666 --> 10:28:40.831
全局变量保存到聚合器v3接口类型中，或者将其传递给get转化

7517
10:28:40.831 --> 10:28:46.998
率函数，后者将其传递给get价格函数，然后调用最新一轮数据。

7518
10:28:46.998 --> 10:28:54.511
我们也许可以让它更简单，也许可以去掉get价格函数把这段代码放在get转化率中。

7519
10:28:54.511 --> 10:28:55.629
但我们先把它放在这里。

7520
10:28:55.629 --> 10:28:58.549
现在我们已经完成了重构，让我们确保它工作。

7521
10:28:58.549 --> 10:29:03.910
Yarn Hardhead，编译，无效值未定义hardhat。config。networks。

7522
10:29:03.910 --> 10:29:07.243
让我们快速进入配置。

7523
10:29:07.377 --> 10:29:10.011
这是因为默认网络需要在网络之外。

7524
10:29:10.011 --> 10:29:10.884
我的错误。

7525
10:29:10.884 --> 10:29:12.550
让我们再试一次。

7526
10:29:12.550 --> 10:29:15.803
我拼错了接口和价格转换器。

7527
10:29:15.803 --> 10:29:21.286
提醒一下，如果出现这样的错误，通常，你可以命令点击或控制点击在

7528
10:29:21.286 --> 10:29:26.770
编辑器中打开文件，这会节省你很多时间，我们会定义行并找到文件。

7529
10:29:26.770 --> 10:29:28.589
但是，让我们把它拼写正确。

7530
10:29:28.589 --> 10:29:30.131
让我们再试一次。

7531
10:29:30.131 --> 10:29:31.036
而可畏。

7532
10:29:31.036 --> 10:29:33.812
看起来编译是正确的。

7533
10:29:33.812 --> 10:29:39.970
我们有一些警告，看起来这些警告是关于这个git版本的，因为我们跟踪了这

7534
10:29:39.970 --> 10:29:46.304
个，我们在下面创建了一个新的价格变量，我们刚创建了一个全局价格自由变量。

7535
10:29:46.377 --> 10:29:50.996
让我们直接删除get版本函数因为我们并不需要它。

7536
10:29:50.996 --> 10:29:54.546
我们只使用Git版本来演示如何实际开始使用接口。

7537
10:29:54.546 --> 10:29:58.156
然后我们再编译一次。

7538
10:29:58.156 --> 10:30:00.444
Boom编译成功。

7539
10:30:00.444 --> 10:30:01.121
太棒了。

7540
10:30:01.377 --> 10:30:03.196
现在我们重构了代码。

7541
10:30:04.377 --> 10:30:07.894
发送地址取决于我们所在的网络。

7542
10:30:08.377 --> 10:30:08.699
太好了。

7543
10:30:12.377 --> 10:30:15.611
Funmi脚本，让我们学习如何实际部署它的其余部分。

7544
10:30:15.611 --> 10:30:20.033
为了部署契约，我们记得在上一节中，我们使用契约工厂(

7545
10:30:20.033 --> 10:30:24.627
点击deploy)，我们只需使用这个deploy函数。

7546
10:30:24.627 --> 10:30:30.849
要使用部署函数，我们写入const Funmi，这是契约的名称，等于await。

7547
10:30:30.849 --> 10:30:39.584
我们会调用这个deploy函数，我们正在部署的契约的名字，然后是我们想在这里添加的覆盖列表。

7548
10:30:39.584 --> 10:30:45.015
我们会说谁在部署这个我们会说它来自部署者。

7549
10:30:45.015 --> 10:30:53.344
我们会把任何参数传递给构造函数在这个args片段中，我们刚添加了一个Argh。

7550
10:30:53.344 --> 10:31:01.878
这些括号，是参数列表，我们会把价格提要地址放在这里，我们马上会演示怎么做，把价格提要地址放在这里。

7551
10:31:01.878 --> 10:31:08.674
然后我们还会在这里做一些自定义日志记录这样我们就不需要做所有这些我们一直在做的console。log之类的东西。

7552
10:31:08.674 --> 10:31:11.414
我们需要在这里放点东西。

7553
10:31:11.414 --> 10:31:13.442
我们得把地址写在这里。

7554
10:31:13.442 --> 10:31:18.301
你可以用这个反斜杠*在你的代码中间放一个公共符号。

7555
10:31:18.378 --> 10:31:22.902
我们不能用const address =，你知道地址，然后把它放在这里。

7556
10:31:22.902 --> 10:31:25.139
我是说，我们可以，但我们现在没有优先考虑。

7557
10:31:25.139 --> 10:31:27.733
对吧?我们又回到了硬编码的阶段。

7558
10:31:27.733 --> 10:31:36.530
那么我们能做些什么呢?我们可以用链ID来做一些事情比如，

7559
10:31:36.530 --> 10:31:44.700
如果链ID是x，用地址Y，如果链ID是Z，用地址A。

7560
10:31:44.700 --> 10:31:47.378
我们可以做这样的东西。

7561
10:31:47.378 --> 10:31:51.190
为了启用这个功能，我们实际上从Ave GitHub中取出了一个页面。

7562
10:31:51.190 --> 10:31:58.644
Ave是另一个在多条链上的协议它必须将它们的代码部署到多条链上并使用多个不同的地址。

7563
10:31:58.644 --> 10:32:02.473
所以它们所做的就是使用一些不同的有用的技巧。

7564
10:32:02.473 --> 10:32:05.503
但其中一个主要的是使用这个助手硬帽配置。

7565
10:32:05.503 --> 10:32:09.778
现在他们在使用TypeScript和JavaScript，但这是一样的。

7566
10:32:09.778 --> 10:32:15.926
通过这个配置，它们有不同的变量，这取决于它们实际所在的网络。

7567
10:32:15.926 --> 10:32:19.706
根据它们所在的网络，它们使用不同的变量。

7568
10:32:19.706 --> 10:32:24.632
所以他们使用这个网络配置来做我们想做的事情。

7569
10:32:24.632 --> 10:32:32.051
我们要做的是在根目录下创建一个新文件，点击这里，新建文件。

7570
10:32:32.051 --> 10:32:38.795
我们称它为helper, hard hat config。j s。

7571
10:32:38.795 --> 10:32:41.212
这就是我们要定义网络配置的地方。

7572
10:32:41.212 --> 10:32:48.056
这里我们会说，如果你在网络上，a，使用这个地址网络，是这个，使用这个地址，等等。

7573
10:32:48.056 --> 10:32:51.264
我们要创建一个叫const的对象。

7574
10:32:51.264 --> 10:32:52.247
网络配置。

7575
10:32:53.379 --> 10:32:55.120
等于我们要在这里加上一堆东西。

7576
10:32:55.379 --> 10:32:58.040
我们现在使用的主要网络是不稳定的。

7577
10:32:58.379 --> 10:33:00.409
链ID是4。

7578
10:33:04.379 --> 10:33:06.083
Rinkeby命名。

7579
10:33:12.379 --> 10:33:16.575
为第eth美元价格提要的B级价格提要地址。

7580
10:33:16.575 --> 10:33:22.009
我们会从文档或GitHub中复制，然后粘贴到这里。

7581
10:33:22.009 --> 10:33:29.772
现在我们有了一个简单的方法来跟踪不同的价格提供不同的合同地址在不同的链。

7582
10:33:29.772 --> 10:33:33.729
举个例子，我们也想部署到Polygon上。

7583
10:33:33.729 --> 10:33:38.361
首先，我们需要什么?我们需要一个多边形的链ID。

7584
10:33:38.361 --> 10:33:42.845
因此，一个快速的小谷歌搜索将我们带到多边形文档。

7585
10:33:42.845 --> 10:33:45.148
我们看到链ID是137。

7586
10:33:45.148 --> 10:33:46.301
所以我用137。

7587
10:33:46.301 --> 10:33:51.231
这里有个小括号，我们写上name polygon。

7588
10:33:51.231 --> 10:33:55.057
然后是逗号，USD，价格供给。

7589
10:33:55.057 --> 10:33:59.036
然后我们将在多边形上添加eth USD的价格饲料。

7590
10:33:59.036 --> 10:34:05.649
docstoc, chain link, polygon或Matic然后我们会查找eth, USD。

7591
10:34:05.649 --> 10:34:08.109
砰，我们看到它就在这里。

7592
10:34:08.109 --> 10:34:11.157
我们抓取了这个地址，然后粘贴进去。

7593
10:34:11.157 --> 10:34:15.625
那硬脑派呢?网络?我们马上就会讲到这个，别担心。

7594
10:34:15.625 --> 10:34:18.661
然后在底部，我们需要导出这个网络配置。

7595
10:34:18.661 --> 10:34:20.864
所以我们的其他脚本可以使用它。

7596
10:34:20.864 --> 10:34:26.396
我们会写module。exports = network config。

7597
10:34:26.396 --> 10:34:35.270
我们将从这个文件中导出一些东西，这就是为什么我们这样做而不是我之前展示的默认方式。

7598
10:34:35.270 --> 10:34:41.317
回到我们的脚本，现在，我们能做什么?首先，我们要导入网络配置。

7599
10:34:41.380 --> 10:34:43.210
所以我们用const。

7600
10:34:47.380 --> 10:34:52.560
我们会导入它，我们会找到目录来帮助我们的Hardhead配置和保存。

7601
10:34:52.560 --> 10:34:57.058
我想再提一遍，这样大家就不会困惑了。

7602
10:34:57.058 --> 10:35:02.509
这里的语法，带花括号的常量网络

7603
10:35:02.509 --> 10:35:07.960
配置和使用const是一样的。

7604
10:35:07.960 --> 10:35:13.913
Helper config等于这个，这个Helper config是整个文件。

7605
10:35:13.913 --> 10:35:22.080
然后const network config等于Hopper config。network config。

7606
10:35:22.080 --> 10:35:28.822
这个索引是一种简单的方法来推断或从这个文件中提取网络配置。

7607
10:35:28.822 --> 10:35:30.051
这就是它的工作原理。

7608
10:35:30.051 --> 10:35:34.163
这就是为什么我们在底部导出它，这样我们就能做到，

7609
10:35:34.163 --> 10:35:40.331
请使用GitHub存储库提问和讨论特别是关于JavaScript的东西。

7610
10:35:40.331 --> 10:35:40.822
好了,好了。

7611
10:35:40.822 --> 10:35:47.756
现在我们已经把这个网络配置好了，我们现在可以做这部分，我们说如果中国d z使用一个如果链ID是x使用y。

7612
10:35:47.756 --> 10:35:53.003
因为我们的helper配置很好地符合这种字典，

7613
10:35:53.003 --> 10:35:58.251
键值对样式，我们能做的是我们可以说const。

7614
10:35:58.251 --> 10:35:59.154
乙美元。

7615
10:35:59.381 --> 10:36:07.439
价格提要地址等于链ID处的网络配置，因为如果Francina D，或者它

7616
10:36:07.439 --> 10:36:13.706
是这个对象，French entity polygon，

7617
10:36:13.706 --> 10:36:23.781
它将是这个位于第eth个美元价格提要的对象，我们将把这个保存到第eth个美元价格提要地址。

7618
10:36:23.781 --> 10:36:27.438
现在不管我们在哪个链上，只要我们运行硬帽部署，

7619
10:36:27.438 --> 10:36:33.800
如果我运行yarn，硬帽部署dash dash network Rinkeby。

7620
10:36:33.800 --> 10:36:35.804
这个链ID是4。

7621
10:36:35.804 --> 10:36:38.881
它会使用这个价格提要地址。

7622
10:36:38.881 --> 10:36:47.181
如果我用破折号测试网络多边形，我记得把环P和多边形都加到网络中，就像这里，通道将是137。

7623
10:36:47.181 --> 10:36:49.523
它将使用这个价格提要地址。

7624
10:36:49.523 --> 10:36:50.729
这太棒了。

7625
10:36:50.729 --> 10:36:52.574
这正是我们想要的。

7626
10:36:52.574 --> 10:37:00.653
但这是我们想要的一切吗?当我在编程和演讲的时候，你们中那些一直在提问的人，你们可能会想，好吧，你谈到了这个标记的事情。

7627
10:37:00.653 --> 10:37:02.834
你谈到了localhost和硬帽。

7628
10:37:02.834 --> 10:37:07.092
我们如何在本地进行测试呢?就像我们如何去测试网和主网。

7629
10:37:07.092 --> 10:37:11.965
但是如果是本地网络呢?这正是我们现在要讨论的。

7630
10:37:11.965 --> 10:37:19.529
我们已经模块化了，我们的代码和参数化了我们的代码这样我们就会使用基于链的地址。

7631
10:37:19.529 --> 10:37:23.972
但如果我们使用一个连价格提要地址都没有的链呢?

7632
10:37:23.972 --> 10:37:28.610
我们在那里做什么?这就是我们创建模拟契约的地方。

7633
10:37:28.610 --> 10:37:34.849
这里模拟契约的思想是，如果契约不存在，我们

7634
10:37:34.849 --> 10:37:41.088
为本地测试部署它的最小版本，或者本地测试。

7635
10:37:41.088 --> 10:37:45.982
部署模拟在技术上是一个部署脚本。

7636
10:37:45.982 --> 10:37:52.563
回到deploy文件夹我们要做的是创建一个新文件，命名为00

7637
10:37:52.563 --> 10:37:59.144
Dash deploy mocks。js，我们从00开始。

7638
10:37:59.144 --> 10:38:07.713
因为这几乎就像预部署的东西，我们只这样做，有时我们并不总是部署模拟，我们不需要部署模拟到Rinkeby，

7639
10:38:07.713 --> 10:38:17.106
或polygon或Aetherium主网，因为这些已经有这些价格提要，我们实际上将部署我们自己的模拟价格提要契约。

7640
10:38:17.106 --> 10:38:24.736
在我们的部署Funmi脚本中，我们将使用我们自己的契约，而不是已经建立的契约。

7641
10:38:24.736 --> 10:38:30.333
如果我们是在一个没有任何价格的网络上，那么就很少有合同，比如hard hat或loccos。

7642
10:38:30.382 --> 10:38:32.769
让我们编写部署模拟脚本。

7643
10:38:34.382 --> 10:38:36.801
看起来和我们部署的Funmi几乎一样。

7644
10:38:37.382 --> 10:38:41.043
如果你想把它设置成这样，完全可以。

7645
10:38:41.382 --> 10:38:46.335
我要复制这个，这部分，粘贴到这里，因为初始部分是完全相同的。

7646
10:38:47.382 --> 10:38:54.569
哦，这里，我刚刚意识到我们调用这个网络而没有定义，JavaScript会足够聪明，知道这个网络从哪里来。

7647
10:38:54.569 --> 10:38:56.303
但这可能会让人有点困惑。

7648
10:38:56.303 --> 10:39:00.244
所以最好是显式的，用const。

7649
10:39:00.244 --> 10:39:06.230
网络等于需要安全帽，这个网络的东西来自安全帽。

7650
10:39:06.230 --> 10:39:08.262
我们要抓住这条线。

7651
10:39:08.262 --> 10:39:11.398
我们也会在脚本的顶部使用它。

7652
10:39:11.398 --> 10:39:14.164
上面部分看起来也一样抓取这三行，

7653
10:39:14.164 --> 10:39:22.462
粘贴到deploydeployer chain ID，这里都是一样的，因为我们准备部署一些东西。

7654
10:39:22.462 --> 10:39:24.811
现在我们要部署一个新契约。

7655
10:39:24.811 --> 10:39:28.335
但如果我们看看我们的合同文件夹，这是我们现在所有的。

7656
10:39:28.383 --> 10:39:33.383
我们需要将这个mock这个假合约添加到合约文件夹中。

7657
10:39:33.383 --> 10:39:42.317
现在我们能做的是，在合约文件夹中，我们想把这个文件和其他文件分开这样我们就知道，这不是项目的一部分，但它是测试的一部分。

7658
10:39:42.317 --> 10:39:44.859
右键点击创建新文件夹。

7659
10:39:44.859 --> 10:39:49.856
我们可以叫它mocks，或者test，我喜欢叫它test。

7660
10:39:49.856 --> 10:39:54.741
在这个文件夹中，我们可以右键创建一个新文件，我要创建

7661
10:39:54.741 --> 10:39:59.814
一个新文件，命名为mock, v3聚合，撕下那个灵魂。

7662
10:39:59.814 --> 10:40:06.037
这就是我们自己定义模拟价格提要聚合器的地方。

7663
10:40:06.037 --> 10:40:12.854
那么我们如何创建自己的假价格饲料合同，以便在本地测试一切呢?

7664
10:40:12.854 --> 10:40:19.216
我们能做的一件事是去链接GitHub回购，浏览合同找到其

7665
10:40:19.216 --> 10:40:26.261
一个价格反馈地址，源8，或者我们会回到源我们可能会检查v6。

7666
10:40:26.383 --> 10:40:35.334
看起来我们可以找到一些东西，四处看看然后复制粘贴所有这些代码，但复制所有这些代码看起来真的很痛苦。

7667
10:40:35.383 --> 10:40:40.103
现在我们完全可以复制粘贴代码到这里，但我们要做一些更聪明的事情。

7668
10:40:40.103 --> 10:40:43.487
链式回购实际上有一些模仿。

7669
10:40:43.487 --> 10:40:47.002
如果我们看合约，SRC V 0。

7670
10:40:47.002 --> 10:40:55.932
他们实际上有一个模拟v3 aggregator。soul在这里，我们可以使用我们的模拟。

7671
10:40:55.932 --> 10:41:02.250
我们可以复制粘贴所有东西，但我们需要修改一点因为它在做点。点的东西。

7672
10:41:02.250 --> 10:41:08.980
它与文件结构中本地的其他契约进行通信而这些契约不会在我们的文件结构中。

7673
10:41:08.980 --> 10:41:13.154
相反，我们能做的是利用这个节点模块包，

7674
10:41:13.154 --> 10:41:19.746
我们可以说pragma, solidity，胡萝卜0，点6。

7675
10:41:19.746 --> 10:41:22.867
0，我们将使用那个包正在执行的相同版本。

7676
10:41:22.867 --> 10:41:30.600
然后在链上导入/收缩/ SRC / v0。

7677
10:41:30.600 --> 10:41:30.716
6.

7678
10:41:30.716 --> 10:41:37.437
斜杠测试斜杠嘲笑，B，三蛋，Reg，基佬撕裂了灵魂。

7679
10:41:37.437 --> 10:41:44.860
然后我们会添加，当然，我们会添加spdx，许可标识符，MIT。

7680
10:41:44.860 --> 10:41:47.867
这就是我们所需要的。

7681
10:41:47.867 --> 10:41:54.917
如果我们像这样导入代码，请记住，这与复制粘贴这个契约到我们的

7682
10:41:54.917 --> 10:42:02.203
项目完全相同，当然，这个路径解析指向它在节点模块中的实际位置。

7683
10:42:02.203 --> 10:42:08.018
现在，实际上，我可以运行纱线硬帽编译，它也会编译这个合同。

7684
10:42:08.018 --> 10:42:13.384
当然，我们有一个问题，编译器版本不匹配。

7685
10:42:13.384 --> 10:42:18.597
对吧?这是怎么回事呢，你们将会遇到这样的情况，你们将会

7686
10:42:18.597 --> 10:42:24.005
与合同工作，这与你们的可靠性不一样，因为合同一直在部署。

7687
10:42:24.005 --> 10:42:27.385
在版本0中有大量的契约。

7688
10:42:27.385 --> 10:42:28.940
4、固体度0。

7689
10:42:28.940 --> 10:42:29.273
5 0。

7690
10:42:29.273 --> 10:42:35.488
678，或者910亿，或者150亿，或者以后会有多少个固体版本。

7691
10:42:35.488 --> 10:42:42.654
在配置中，在hard hat。config中，滚动到底部时，我们可以滚动到定义固体度版本的地方。

7692
10:42:42.654 --> 10:42:50.000
我们可以添加多个固体版本，这样我们的编译器就能编译多个固体版本。

7693
10:42:50.000 --> 10:42:52.846
为了做到这一点，我们会说，Lyd, T。

7694
10:42:52.846 --> 10:42:57.150
我们会把它变成一个对象，我们会在这里加上逗号。

7695
10:42:57.150 --> 10:43:03.352
在我们的solidity对象中，我们会放入编译器我们会有一个编译器列表。

7696
10:43:03.352 --> 10:43:07.035
第一个是0点8点。

7697
10:43:07.035 --> 10:43:07.085
8.

7698
10:43:07.085 --> 10:43:10.255
第二个版本是0。

7699
10:43:10.255 --> 10:43:15.190
6，点6，然后保存。

7700
10:43:15.385 --> 10:43:17.723
我想把它格式化成这样，这很好。

7701
10:43:17.723 --> 10:43:25.623
现在，我们可以继续，重新运行，yarn, Hardhead，编译，然后成功编译了五个固体文件。

7702
10:43:25.623 --> 10:43:29.333
这意味着我们的Mark V聚合器也应该被编译。

7703
10:43:29.385 --> 10:43:37.978
如果我们看工件，在链链，确实看到这个在链链斜杠合同斜杠SRC投标，和一个v0。

7704
10:43:37.978 --> 10:43:38.045
6.

7705
10:43:38.045 --> 10:43:42.237
在测试中，我们看到这个模拟聚合器。soul，它已经编译过了。

7706
10:43:42.237 --> 10:43:42.761
太棒了。

7707
10:43:42.761 --> 10:43:51.729
现在我们已经编译了模拟契约，现在我们有了一个契约，可以用来将假价格提要部署到区块链。

7708
10:43:51.729 --> 10:43:57.051
那么我们要怎么做呢?这和我们在Funmi合约上的做法是一样的。

7709
10:43:57.051 --> 10:44:03.251
这里我们要添加一个if语句，我们不想把这个模拟合约部

7710
10:44:03.251 --> 10:44:09.451
署到一个测试网络或一个有价格feed的网络上，我们可

7711
10:44:09.451 --> 10:44:15.652
以这样做，如果链ID不等于某个链ID，然后部署标记。

7712
10:44:15.652 --> 10:44:17.736
这是一种伪代码。

7713
10:44:17.736 --> 10:44:19.174
显然，这段代码实际上无法工作。

7714
10:44:19.174 --> 10:44:25.368
相反，我喜欢的是指定哪些链将是我的开发链，哪些链将是我可以部署这

7715
10:44:25.368 --> 10:44:31.756
些模拟到的链，在我的助手，hard hat配置中，我会定义这些链。

7716
10:44:31.756 --> 10:44:36.494
我写上const，开发链，等于，然后

7717
10:44:36.494 --> 10:44:41.233
我写上hard hat，和本地主机。

7718
10:44:41.233 --> 10:44:43.368
我要导出这些。

7719
10:44:43.368 --> 10:44:49.450
回到我的deploy模拟中，我将用const导入它们。

7720
10:44:49.450 --> 10:44:57.336
开发链等于require。dot。slash helper Hardhead config。

7721
10:44:57.336 --> 10:45:05.558
现在我要说if development chains。includes chain ID。

7722
10:45:05.558 --> 10:45:10.948
这个includes keyword基本上是一个检查变量是否

7723
10:45:10.948 --> 10:45:16.519
在数组内的函数，然后我们会继续部署Max，这就是我们想要做的。

7724
10:45:16.519 --> 10:45:21.052
我们会做log，这是从部署中得到的，基本上是console。log。

7725
10:45:21.052 --> 10:45:28.198
我们会说本地网络检测到，部署模拟。

7726
10:45:28.386 --> 10:45:33.471
我们会做一个权值策略，我们会部署我们新的

7727
10:45:33.471 --> 10:45:38.812
模拟v3聚合器模拟v3聚合器会做一个逗号。

7728
10:45:38.812 --> 10:45:40.955
这里有个冒号。

7729
10:45:40.955 --> 10:45:46.996
如果我们想要更具体，我们可以说契约v3聚合器我们

7730
10:45:46.996 --> 10:45:53.290
已经说过了我们会说从部署者我们会说日志记录是真的。

7731
10:45:53.387 --> 10:45:58.749
然后我们需要传递一些参数，我们需要传递模拟v3聚合器的构造函数

7732
10:45:58.749 --> 10:46:04.111
参数，这是什么?好吧，让我们去docs chain去寻找答案。

7733
10:46:04.111 --> 10:46:08.656
或者您也可以直接访问Node modules chainlink,

7734
10:46:08.656 --> 10:46:13.340
SRC v06, tests，然后一直到mock v3，聚合出来。

7735
10:46:13.387 --> 10:46:17.177
你也可以在这里找到构造函数，无论你喜欢哪个，

7736
10:46:17.177 --> 10:46:24.587
有时我发现更容易读GitHub Ctrl + F或Command + F作为构造函数。

7737
10:46:24.587 --> 10:46:28.264
我们看到它需要一个小数和一个初值。

7738
10:46:28.264 --> 10:46:34.146
如果我们通读这段代码，我们就会知道小数对

7739
10:46:34.146 --> 10:46:40.323
象等价于小数参数等价于小数函数和初始结果。

7740
10:46:40.387 --> 10:46:45.227
最初的答案基本上就是价格提要从什么开始，我们实际

7741
10:46:45.227 --> 10:46:50.269
上要选择价格提要的价格，这很好，因为这很适合测试。

7742
10:46:50.269 --> 10:46:56.762
我通常喜欢把小数和初值定义在函数之外的地方这样我以后就可以用到它了。

7743
10:46:56.762 --> 10:47:00.967
你可以在我们的助手Hardhead配置中再次添加它。

7744
10:47:00.967 --> 10:47:01.160
js。

7745
10:47:01.160 --> 10:47:05.224
我可以用常量小数= 8。

7746
10:47:05.224 --> 10:47:09.490
然后const初始答案。

7747
10:47:09.490 --> 10:47:14.610
等于，我们用2000。

7748
10:47:14.610 --> 10:47:18.046
既然我们有小数，我们用2000，

7749
10:47:18.046 --> 10:47:23.845
然后是123456788小数点位，然后我们也导出这些。

7750
10:47:23.845 --> 10:47:26.683
导出小数，并导出初始应答。

7751
10:47:26.683 --> 10:47:34.388
当然，我们可以，你知道，const小数在上面等于8然后初始答案，然后在下面用它们。

7752
10:47:34.388 --> 10:47:35.998
但我喜欢这样做。

7753
10:47:35.998 --> 10:47:36.608
所以让步。

7754
10:47:36.608 --> 10:47:39.184
现在我们要把它们导入这里。

7755
10:47:39.388 --> 10:47:40.911
Const开发链。

7756
10:47:40.911 --> 10:47:42.625
还有小数点。

7757
10:47:43.388 --> 10:47:45.814
获取了初始答案，我们将保存它。

7758
10:47:47.388 --> 10:47:50.165
构造函数看起来先写小数，再写初值。

7759
10:47:50.165 --> 10:47:55.638
在论证中，我们先做小数，再做初解，等等。

7760
10:47:55.638 --> 10:48:00.574
然后我们就完成了我们会做一个快速的日志箱部署。

7761
10:48:00.574 --> 10:48:09.084
然后，我还喜欢在所有部署脚本的末尾加一行，就像，嘿，部署脚本结束了。

7762
10:48:09.084 --> 10:48:12.557
在此之后的其他内容将是一个不同的部署脚本。

7763
10:48:12.557 --> 10:48:13.421
好的，很好。

7764
10:48:13.421 --> 10:48:15.888
现在我们部署的模拟脚本实际上已经完成。

7765
10:48:15.888 --> 10:48:18.472
但是我们的部署Funmi脚本还没有完全完成。

7766
10:48:18.472 --> 10:48:24.077
有没有一种方法可以让我们只运行部署模拟脚本?嗯，是的，有。

7767
10:48:24.077 --> 10:48:25.581
很好，谢谢关心。

7768
10:48:25.581 --> 10:48:31.389
我们可以在部署模拟脚本的底部做的是，添加一个导出

7769
10:48:31.389 --> 10:48:37.441
点标记(=)的模块，我们将写入all和marks。

7770
10:48:37.441 --> 10:48:46.286
现在我们能做的是如果我们运行yarn, hardhat deploy，我们可以添加这个标志。

7771
10:48:46.388 --> 10:48:50.325
它将只运行具有特殊标记的部署脚本。

7772
10:48:50.388 --> 10:48:56.629
因此，我们将运行mock标记，这意味着它将只运行部署模拟脚本。

7773
10:48:56.629 --> 10:49:03.323
哦，实际上，在我们的助手配置开发链中是硬帽和localhost。

7774
10:49:03.389 --> 10:49:07.369
我说，我们要用链ID来做，抱歉，我们要这样做，

7775
10:49:07.369 --> 10:49:15.158
我们要用development chains。includes network。name。

7776
10:49:15.389 --> 10:49:20.168
因为我们的helper配置使用的是名称而不是链id，

7777
10:49:20.168 --> 10:49:24.948
所以如果开发链包含网络名称，那么我们将继续部署模拟。

7778
10:49:24.948 --> 10:49:28.711
让我们继续，运行这个故事点击部署破折号标签，mocks。

7779
10:49:28.711 --> 10:49:32.660
完美的是，我们确实看到我们的模拟被部署在这里。

7780
10:49:32.660 --> 10:49:36.839
这个对数为真意味着它会吐出这样的东西。

7781
10:49:36.839 --> 10:49:42.614
它会说契约，它正在部署，它正在进行的事务它会说它被部署在哪

7782
10:49:42.614 --> 10:49:48.389
里，有多少气体，这意味着我们部署的Mach脚本运行得很好。

7783
10:49:48.389 --> 10:49:51.503
现在我们的部署模拟脚本已经完美地工作了。

7784
10:49:51.503 --> 10:49:57.339
那么我们如何将其应用到部署Funmi脚本中呢?我们在这里也要做同样的事。

7785
10:49:57.389 --> 10:50:05.889
我们不会让eth USD price feed address为常量，我们会说let at USD price you'd variable这样我们就能更新它。

7786
10:50:05.889 --> 10:50:13.026
我们会说，如果development chains。include network。

7787
10:50:13.026 --> 10:50:21.353
name，我们可以用hardhat deploy做的是我们可以用一个叫get的命令获取最新的部署。

7788
10:50:21.353 --> 10:50:22.686
所以我们用const。

7789
10:50:22.686 --> 10:50:29.068
eth USD聚合器= await deployment dot get。

7790
10:50:29.068 --> 10:50:33.781
然后是我们部署的Mach v3聚合器的合约名称，

7791
10:50:33.781 --> 10:50:41.441
如果你想用get代替deployment。get，我们完全可以，只需要这样做。

7792
10:50:41.441 --> 10:50:43.176
它们完全一样。

7793
10:50:43.176 --> 10:50:48.833
我们会得到这样的地址然后我们会说eth USD价格提要

7794
10:50:48.833 --> 10:50:54.491
地址等于那个eth USD聚合器合约。address。

7795
10:50:54.491 --> 10:51:02.675
然后如果我们不在开发链上，如果我们没有部署一个mock，我们只会做我们之前做过的事情。

7796
10:51:02.675 --> 10:51:04.873
使用网络配置。

7797
10:51:04.873 --> 10:51:06.163
哦，我的天哪。

7798
10:51:06.163 --> 10:51:15.159
现在，我们已经完成了所有这些步骤，让我们在底部添加一个小的log东西，只有一些连字符。

7799
10:51:15.159 --> 10:51:21.841
现在，我们应该有一个非常健壮的脚本，可以在本地开发链、测试网链和主

7800
10:51:21.841 --> 10:51:28.523
网链之间切换，并允许我们在不改变任何稳定性的情况下部署到任何地方。

7801
10:51:28.523 --> 10:51:35.323
然后我们用这个，这个USD价格输入地址，把它写进日志里。

7802
10:51:35.323 --> 10:51:40.105
然后在底部，我们可以做module。exports。

7803
10:51:40.105 --> 10:51:45.439
tags =然后我们做所有的然后我们把这个叫做Funmi。

7804
10:51:45.439 --> 10:51:47.406
现在是关键时刻了。

7805
10:51:47.406 --> 10:51:52.898
如果我们都做到了，对吧，我们应该就能运行纱线，戴上安全帽。

7806
10:51:52.898 --> 10:51:57.644
它应该适用于我们的本地连锁店，我们的安全帽连锁店。

7807
10:51:57.644 --> 10:52:00.881
它应该也适用于我们提供的任何测试网。

7808
10:52:00.881 --> 10:52:02.635
让我们试一试。

7809
10:52:02.635 --> 10:52:04.178
纱，硬头部署。

7810
10:52:04.390 --> 10:52:05.622
让我们看看这是否有效。

7811
10:52:05.622 --> 10:52:06.050
太棒了。

7812
10:52:07.390 --> 10:52:15.325
部署到我们的硬帽网络，我们可以看到我们继续部署了模拟，我们在这里画了下划线。

7813
10:52:15.390 --> 10:52:18.999
然后我们部署了福米在这个地址部署了这么多毒气。

7814
10:52:18.999 --> 10:52:25.745
那么，关于安全帽部署还有什么了不起的地方呢?当我们运行我们的本地区块链，我们

7815
10:52:25.745 --> 10:52:32.669
自己的区块链节点时，硬帽部署将自动运行所有的部署脚本并将它们添加到我们的节点。

7816
10:52:32.669 --> 10:52:37.857
现在如果我运行yarn, hard hat node，我们

7817
10:52:37.857 --> 10:52:43.046
会自旋一个新的区块链节点，但它上面已经有所有已部署的契约。

7818
10:52:43.046 --> 10:52:51.100
每次我们旋转一个局部节点，它就会自动打包我们想要的契约。

7819
10:52:51.100 --> 10:52:55.817
我们将在林克比的一个测试网上演示这个过程。

7820
10:52:55.817 --> 10:53:03.950
但在我们在Rinkeby上进行测试之前，我要在这里添加一点自动验证，因为我们在上节课中做过。

7821
10:53:03.950 --> 10:53:07.079
我们也想展示如何在硬帽部署中做到这一点。

7822
10:53:07.079 --> 10:53:13.806
在我们部署Funmi之后，我们可以做类似的事情，我们会说，如果开发者链包含network。

7823
10:53:13.806 --> 10:53:21.132
name，我们会说，如果开发者链不包含network。name，因为我们不想在本地网络上进行验证。

7824
10:53:21.132 --> 10:53:25.394
我们会说if not development chains。

7825
10:53:25.394 --> 10:53:31.505
包括network。name，感叹号，也就是bang的意思是not当我们谈论布尔值时。

7826
10:53:31.505 --> 10:53:39.644
所以我们说，如果网络的名字不是开发链，我们想继续验证，和上次一样。

7827
10:53:39.644 --> 10:53:44.275
如果process。env。ether

7828
10:53:44.275 --> 10:53:48.907
扫描API key，我们就会继续验证。

7829
10:53:48.907 --> 10:53:54.754
在我们有验证代码之前，在我们的部署代码中，我们要做一些不同的事情。

7830
10:53:54.754 --> 10:54:03.572
这里的部署脚本中没有验证代码，我们实际上要创建一个名为utils的新文件夹，它代表实用程序。

7831
10:54:03.572 --> 10:54:08.646
这就是我们要添加不同脚本的地方我们可以在不同的部署中使用。

7832
10:54:08.646 --> 10:54:16.044
因为假设我们有50个Deploy脚本，我们不会创建50个Deploy函数，我们只会将它们添加到utils文

7833
10:54:16.044 --> 10:54:23.582
件夹，在utils文件夹中，或者创建一个名为verify。js的新文件，我们会将上一个项目的代码添加到这里。

7834
10:54:23.582 --> 10:54:31.002
如果你愿意，你可以从上一个项目复制粘贴到这个项目，或者你可以暂停视频自己打出来。

7835
10:54:31.002 --> 10:54:36.900
因为我们在这里使用的是run命令，我们将执行const run = require RT hat。

7836
10:54:36.900 --> 10:54:44.642
然后在底部，我们会做模块导出。

7837
10:54:44.642 --> 10:54:48.079
导出等于验证。

7838
10:54:48.392 --> 10:54:56.860
现在我们在utils文件夹中有了一个验证脚本，回到deploy Funmi中我们将写入const。

7839
10:54:56.860 --> 10:55:00.642
验证= require。dot。slash utils。

7840
10:55:00.642 --> 10:55:01.725
削减验证。

7841
10:55:01.725 --> 10:55:10.206
因为现在在我们的验证Jas中，我们有很多trycatch的东西，我们可以做一个等待。

7842
10:55:10.206 --> 10:55:17.497
Verify和Verify再次接受契约地址和参数列表。

7843
10:55:17.497 --> 10:55:24.004
我们写入await verify, fundme。address然后是参数列表。

7844
10:55:24.004 --> 10:55:26.737
为了使参数列表更容易输入。

7845
10:55:26.737 --> 10:55:34.672
你可以输入const args，等于然后我们会把我们的eth USD price

7846
10:55:34.672 --> 10:55:42.806
feed放在这里然后用args替换这个然后把这个args放到下面的第二个参数中。

7847
10:55:42.806 --> 10:55:44.564
好的，很好。

7848
10:55:44.564 --> 10:55:49.451
现在让我们把它部署到Rinkeby测试网中，我们需要什么来部署

7849
10:55:49.451 --> 10:55:54.496
到Rinkeby测试网中呢?好吧，让我们先进入我们的安全帽配置。

7850
10:55:54.496 --> 10:56:01.554
清理一下，我们不需要这个账户任务，我删掉它，我不需要这个注释。

7851
10:56:01.554 --> 10:56:03.102
我把这个也删掉。

7852
10:56:03.102 --> 10:56:07.345
让我们进入网络部分，我们不会使用ropsten。

7853
10:56:07.345 --> 10:56:09.154
所以我们要把它扔掉。

7854
10:56:09.154 --> 10:56:15.651
然而，我们将使用溜冰场B, URL将是相同的Rinkeby RPC URL。

7855
10:56:15.651 --> 10:56:19.500
我们将在这里定义它，就像我们之前做的那样。

7856
10:56:19.500 --> 10:56:28.404
如果你想从上一个项目复制粘贴，请随意，

7857
10:56:28.404 --> 10:56:37.309
你也可以跟着我或者快进，计数是一样的。

7858
10:56:37.309 --> 10:56:42.293
我要复制粘贴之前的气体报告器。

7859
10:56:42.293 --> 10:56:50.151
所以我们要加上这个恒定的玉米市值API关键值等于过程。EMV。玉米市值API关键值。

7860
10:56:50.151 --> 10:56:56.952
对以太扫描API键Licious做同样的事情，把所有东西都添加到这里。

7861
10:56:56.952 --> 10:56:57.426
现在。

7862
10:56:57.426 --> 10:57:02.250
我们已经有了以太扫描部分，我们要让气

7863
10:57:02.250 --> 10:57:07.342
体报告器为假，因为我现在真的不想用它。

7864
10:57:07.393 --> 10:57:10.343
最后，我们要在这里再加一个东西。

7865
10:57:10.393 --> 10:57:15.308
记得在我们上一个项目中，在我们实际验证之前，我们等待一些块确认。

7866
10:57:15.308 --> 10:57:18.020
这样，乙醚扫描就能确保赶上进度。

7867
10:57:18.020 --> 10:57:25.046
我们可以在hard hat。config中做同样的事情，我们可以为

7868
10:57:25.046 --> 10:57:32.073
每个测试网添加一个区域来决定我们要等待多少块，我将添加6个块确认。

7869
10:57:32.073 --> 10:57:34.827
现在回到我们的部署Funmi。

7870
10:57:34.827 --> 10:57:39.351
在一个新的部分，我可以添

7871
10:57:39.351 --> 10:57:43.875
加等待确认的网络点配置。

7872
10:57:43.875 --> 10:57:50.882
那块上的运动，或一个是或一个意味着如果没有块确认，

7873
10:57:50.882 --> 10:57:57.329
在我们的Hardhead点配置将只等待一个块。

7874
10:57:57.394 --> 10:58:04.092
同样，我们想要等待大约6个区块确认的原因是我们想给以太扫描一个索引我们的交易的机会。

7875
10:58:04.092 --> 10:58:07.853
我添加了一个链ID 42，当它应该是我的错误。

7876
10:58:07.853 --> 10:58:13.145
当然，我们需要我们的。env文件，在那里我们添加了我们从上一个会话的所

7877
10:58:13.145 --> 10:58:18.590
有东西，RIP ERP CRL私钥以太扫描API，然后是硬币市值API。

7878
10:58:18.590 --> 10:58:20.294
好了，关键时刻。

7879
10:58:20.294 --> 10:58:21.539
我们来试试这个。

7880
10:58:21.539 --> 10:58:28.672
如果我们运行纱线Hardhead部署破折号网络Rinkeby。

7881
10:58:28.672 --> 10:58:35.213
它不应该部署任何标记，因为在模拟部署中有这个if语句。

7882
10:58:35.213 --> 10:58:41.071
但它应该使用正确的价格提要地址部署我们的Funmi合同。

7883
10:58:41.071 --> 10:58:43.519
然后它会继续进行验证。

7884
10:58:43.519 --> 10:58:52.139
由于我们在等待六个区块的确认，我们甚至可以通过添加破折号标签和运行资金标签来超级安全。

7885
10:58:52.139 --> 10:58:56.306
但我们只打算做纱线部署网络Rigby。

7886
10:58:56.306 --> 10:58:58.201
让我们看看会发生什么。

7887
10:58:58.201 --> 10:59:00.855
好的，我们正在部署资金。

7888
10:59:00.855 --> 10:59:05.375
我们可以看到Funmi的事务，这是日志

7889
10:59:05.375 --> 10:59:09.895
功能，部署Funmi时日志是true。

7890
10:59:09.895 --> 10:59:17.093
一旦它有了交易，它就会给我们交易，一旦我们有了地址，它就会给我们地址。

7891
10:59:17.093 --> 10:59:22.463
所以我们要等6个区块确认，让这个交易完成。

7892
10:59:22.463 --> 10:59:26.795
现在我们看到我们已经用X数量的天然气部署了这个合同地址。

7893
10:59:26.795 --> 10:59:29.233
现在我们正在进行验证程序。

7894
10:59:29.233 --> 10:59:34.504
在验证过程中，我们可以打开瑞克比以太扫描，把我

7895
10:59:34.504 --> 10:59:39.775
们的地址贴在这里，看看我们确实创建了这份合同。

7896
10:59:39.775 --> 10:59:43.791
现在看来我们已经通过以太扫描成功验证了合同。

7897
10:59:43.791 --> 10:59:48.767
因此，如果我们点击刷新，我们确实可以看到契约已经得到验证。

7898
10:59:48.767 --> 10:59:49.309
太棒了。

7899
10:59:49.309 --> 10:59:49.986
好吧。

7900
10:59:49.986 --> 10:59:51.245
这太棒了。

7901
10:59:51.245 --> 10:59:58.450
我们的部署脚本看起来很棒，我们能够部署到本地链，我们能够部署到测试，如果我们想，我

7902
10:59:58.450 --> 11:00:05.655
们可以部署到任何我们想要的网络，只需要更新我们的硬帽配置，然后更新我们的助手配置。

7903
11:00:05.655 --> 11:00:07.220
这太棒了。

7904
11:00:07.395 --> 11:00:09.153
到目前为止做得很好。

7905
11:00:13.395 --> 11:00:13.868
我们的测试。

7906
11:00:16.395 --> 11:00:20.179
我们的Funmi合同，让它看起来更专业一点。

7907
11:00:20.179 --> 11:00:24.854
我会讲一些语法以及一些惯例存在的原因。

7908
11:00:24.854 --> 11:00:29.331
我们不会对所有的项目都这么做。

7909
11:00:29.395 --> 11:00:34.569
但是知道这些是很好的，并且在我们继续工作和处理我们的合同时最好记住它们。

7910
11:00:34.569 --> 11:00:41.084
在我们学习的过程中，我们将学习为什么这些约定会存在包括学习一些低水平的固体性。

7911
11:00:41.084 --> 11:00:42.264
所以不要跳过这部分。

7912
11:00:42.264 --> 11:00:43.789
当我们讲到后面的部分时。

7913
11:00:43.789 --> 11:00:50.508
我们会稍微宽松一点，对代码样式指南不那么严格，但这基本上是我们现在要讲的。

7914
11:00:50.508 --> 11:00:57.953
现在，你可能会在这里看到这个事件资助的东西，请暂时忽略它，在之前的例子中，我很早之前就介绍了这些事件。

7915
11:00:57.953 --> 11:01:01.248
现在我们将在后面的课程中学习事件。

7916
11:01:01.248 --> 11:01:04.067
所以现在请忽略这个资助的活动。

7917
11:01:04.067 --> 11:01:06.525
我们来稍微调整一下契约。

7918
11:01:06.525 --> 11:01:12.122
现在我说的是调整它，让它看起来更专业一点，更专业一点，我说的是固体风格

7919
11:01:12.122 --> 11:01:17.879
指南，有一些命名和排序的约定，我们可以遵循，让我们的代码看起来更好一点。

7920
11:01:17.879 --> 11:01:23.002
现在，就像我说的，这将是一点可选的，因为它可能有点啰嗦。

7921
11:01:23.002 --> 11:01:25.753
这并没有太大的区别。

7922
11:01:25.753 --> 11:01:30.750
但是它可以大大提高契约的可读性，使代码看起来更好。

7923
11:01:30.750 --> 11:01:38.157
所以，如果你想，你可以通过这个风格指南，了解更多关于什么类型的固体看起来很好，什么使它看起来不好。

7924
11:01:38.157 --> 11:01:42.819
但是，这是这里的一些风格指南，我们不会完全遵循风格指南。

7925
11:01:42.819 --> 11:01:47.679
但我们会尽最大努力让代码遵循样式指南，我们在GitHub仓

7926
11:01:47.679 --> 11:01:52.707
库中有样式指南的链接，这一节我们可以读到更多关于布局的内容。

7927
11:01:52.707 --> 11:02:01.348
但我们主要想看的是布局的顺序，我们想从导入开始有pragma语句，导入，接口，库，然后是契约。

7928
11:02:01.348 --> 11:02:06.576
然后在每个契约类型声明、状态变量、事件、修饰符和函数内部。

7929
11:02:06.576 --> 11:02:11.706
回到这里，确保我们跟上了进度，我们先要pragma。

7930
11:02:11.706 --> 11:02:15.936
很好，我们确实做到了，然后我们需要导入。

7931
11:02:15.936 --> 11:02:17.814
好的，太棒了，我们也有。

7932
11:02:17.814 --> 11:02:22.735
样式指南中没有的是错误代码，这是我们接下来需要的。

7933
11:02:22.735 --> 11:02:25.701
接下来是错误代码。

7934
11:02:25.701 --> 11:02:30.052
现在我们将在这里遇到我们的第一个更新。

7935
11:02:30.052 --> 11:02:37.350
最近，添加合同名称、一些下划线以及错误名称已经成为一种最佳实践。

7936
11:02:38.397 --> 11:02:39.672
当你遇到错误的时候。

7937
11:02:40.397 --> 11:02:44.328
更容易理解哪个合约抛出了错误。

7938
11:02:44.397 --> 11:02:48.907
对于这个，我们会说error Funmi, two下划线not

7939
11:02:48.907 --> 11:02:53.708
owner，然后我们会向下滚动到我们的revert，设置成这样。

7940
11:02:53.708 --> 11:02:56.257
这样，当我们遇到这个错误时，

7941
11:02:56.257 --> 11:03:03.724
我们就知道错误来自Funmi契约，而不是来自聚合器v3接口、价格转换器或其他契约。

7942
11:03:03.724 --> 11:03:06.397
这就是我们要写错误代码的方式。

7943
11:03:06.397 --> 11:03:10.227
如果我们有任何没有导入的接口或库，我们将在这里添加它们。

7944
11:03:10.227 --> 11:03:12.708
最后，我们加入契约。

7945
11:03:12.708 --> 11:03:15.593
在这个文件中，我们只有一个合同。

7946
11:03:15.593 --> 11:03:16.773
这是我们的Funmi合同。

7947
11:03:16.773 --> 11:03:17.166
太棒了。

7948
11:03:17.166 --> 11:03:22.563
现在我们要学习的下一件事，就样式指南而言，是这个叫做natspec的东西。

7949
11:03:22.563 --> 11:03:27.708
natspec是以太自然语言规范格式的缩写。

7950
11:03:27.708 --> 11:03:34.380
它基本上是一种记录我们的代码的方法，受Doxygen的启发，使用Doxygen风格的注释和

7951
11:03:34.380 --> 11:03:41.052
标签来帮助记录我们的代码，你可以点击这里的链接在固体文档了解更多关于Doxygen的信息。

7952
11:03:41.052 --> 11:03:45.167
如果我们向下滚动文档，在这里，我们可以看到一个使用natspec的示例。

7953
11:03:45.167 --> 11:03:51.968
每当我们有一个需要文档的契约或函数时，我们可以向它添加一些如下所示的语法。

7954
11:03:51.968 --> 11:03:59.423
举个例子，如果我们想把这个添加到代码中，我们可以添加一个注释来解释这个融资合同来开始一

7955
11:03:59.423 --> 11:04:07.053
个natspec，你可以用三个反斜杠，或者一个反斜杠，两颗星，然后在这里再加一个结束星。

7956
11:04:07.053 --> 11:04:11.955
我们放在这个评论区的所有东西基本上都变成了评论。

7957
11:04:11.955 --> 11:04:18.509
在合同的开始，我们会用Add符号来解释，这个合同是什么，

7958
11:04:18.509 --> 11:04:25.064
它很有趣，我们的合同将是一个众筹合同，我们会再加一颗星。

7959
11:04:25.064 --> 11:04:33.865
我们可以加上它的作者，也就是你的名字，当然我要写上帕特里克·柯林斯，然后我们

7960
11:04:33.865 --> 11:04:42.898
会加上一个通知，这是给人们的一种提示我们可以说这个合同是演示一个样本融资合同。

7961
11:04:42.898 --> 11:04:49.064
我们还可以添加apt Dev，这是专门针对开发人员的说明。

7962
11:04:49.064 --> 11:04:52.785
我们可以说这实现了价格提要作为我们的库。

7963
11:04:52.785 --> 11:04:58.862
我们想在这里添加这些标记的原因实际上是因为我们可以使用natspec自动为我

7964
11:04:58.862 --> 11:05:04.779
们创建文档，如果我们下载，那么我们可以实际运行solc dash的user

7965
11:05:04.779 --> 11:05:11.017
doc, dash dash dev doc，和我们的文件名来自动生成文档。

7966
11:05:11.017 --> 11:05:17.512
因此，这对于以后与协议交互的其他开发人员自动创建文档也非常有帮助。

7967
11:05:17.512 --> 11:05:21.725
你可以使用这个natspec来实现任意多或任意少的函数。

7968
11:05:21.725 --> 11:05:24.698
我们中的大多数人可能不会制作文档。

7969
11:05:24.698 --> 11:05:31.914
因此，如果我们认为某些函数或代码的某些部分对其他开发人员来说有点棘手，我们就会遵循这些指导原则。

7970
11:05:31.914 --> 11:05:35.347
既然已经在合同内了，我们就可以按照合同的顺序行事了。

7971
11:05:35.347 --> 11:05:41.158
我们首先从类型声明开始，我们实际上没有任何类型声

7972
11:05:41.158 --> 11:05:47.212
明，除非我们使用的是UN 256类型的价格转换器。

7973
11:05:47.212 --> 11:05:48.228
好了,好了。

7974
11:05:48.399 --> 11:05:52.136
接下来，在我们的类型声明之后，我们要做状态变量。

7975
11:05:52.136 --> 11:05:58.217
在这个状态变量部分，我们要改变一些状态变量的名称。

7976
11:05:58.217 --> 11:06:00.989
这里我们用一些常见的状态函数。

7977
11:06:00.989 --> 11:06:09.711
在实度样式指南中，有点坚持命名样式，我们用大写字母和小写字母，我们用大写字母加下划线。

7978
11:06:09.711 --> 11:06:13.617
但是，这些命名变量将在以后的本节中进行更改。

7979
11:06:13.617 --> 11:06:19.722
如果你看的是和这门课相关的GitHub回购，这些会和你看到的有些不同。

7980
11:06:19.722 --> 11:06:25.449
然而，现在，我们将让它们保持原样，因为我们要改变它们的原因还不是很清楚。

7981
11:06:25.449 --> 11:06:26.049
别担心。

7982
11:06:26.049 --> 11:06:29.229
所以这些名字很快就会改变，但不是现在。

7983
11:06:29.229 --> 11:06:32.664
好的，在状态变量之后是事件和修饰语。

7984
11:06:32.664 --> 11:06:35.589
我们没有任何事件，但我们有一个修饰语。

7985
11:06:35.589 --> 11:06:37.096
我们复制这个。

7986
11:06:37.096 --> 11:06:41.349
实际上，我们把这条注释删掉。

7987
11:06:41.349 --> 11:06:45.250
然后粘贴修改器到这里。

7988
11:06:45.250 --> 11:06:50.127
对了，看起来好像我们这里没有自动格式化。

7989
11:06:50.127 --> 11:06:53.870
我们要取消注释不可变，它会自动自动格式化。

7990
11:06:53.870 --> 11:06:54.549
好了,好了。

7991
11:06:54.549 --> 11:06:55.927
我们现在没有格式了。

7992
11:06:55.927 --> 11:06:56.266
和酷。

7993
11:06:56.266 --> 11:06:57.999
现在我们有了修饰语。

7994
11:06:57.999 --> 11:07:02.418
接下来，我们在这里，然后我们有所有的函数。

7995
11:07:02.418 --> 11:07:02.888
太好了。

7996
11:07:02.888 --> 11:07:07.624
我们实际上想要把函数按我刚才打印的顺序分组。

7997
11:07:07.624 --> 11:07:12.721
我们想要的构造函数是我们已经接收并返回的，我们确实有回落和接收。

7998
11:07:12.721 --> 11:07:17.161
我们要复制这些，然后删除这个注释。

7999
11:07:17.161 --> 11:07:23.111
我们要让那些退伍军人希斯看起来像是先接球的。

8000
11:07:23.111 --> 11:07:24.722
我们把它写在这里。

8001
11:07:24.722 --> 11:07:29.238
然后是外部功能，然后是公共功能，内部功能，私人功能。

8002
11:07:29.400 --> 11:07:30.685
我们有public public。

8003
11:07:30.685 --> 11:07:31.435
就是这样。

8004
11:07:32.400 --> 11:07:34.193
把下面这部分删掉。

8005
11:07:34.193 --> 11:07:34.537
好的。

8006
11:07:34.537 --> 11:07:34.881
酷。

8007
11:07:36.400 --> 11:07:40.336
我们可以在函数的网络规范中使用这种语法。

8008
11:07:40.400 --> 11:07:47.188
例如，对于资助它，我们甚至可以复制粘贴，我们会删除标题，我

8009
11:07:47.188 --> 11:07:53.976
们会删除作者，我们只说添加，注意，这个功能，资助这个合同。

8010
11:07:53.976 --> 11:07:57.867
我们甚至可以在这里留下一些关于开发的内容。

8011
11:07:57.867 --> 11:08:00.866
如果我们有参数，你可以做apt puram。

8012
11:08:00.866 --> 11:08:03.305
比如参数是什么。

8013
11:08:03.305 --> 11:08:11.096
然后如果我们有返回，我们可以说返回，或者返回，然后它为文档返回什么。

8014
11:08:11.096 --> 11:08:15.835
因为这里没有任何参数，也不返回任何东西，我们可以让它像这样。

8015
11:08:15.835 --> 11:08:20.368
很好，我们刚刚修改了我们的合同使它的格式更漂亮。

8016
11:08:20.368 --> 11:08:20.836
伟大的工作。

8017
11:08:20.836 --> 11:08:26.945
现在，就像我说的，我们实际上要改变状态函数的名称，我们要在这里添加一些函数。

8018
11:08:26.945 --> 11:08:32.061
如果我们跟随GitHub回购，现在契约的状态看起来会有点不同。

8019
11:08:32.061 --> 11:08:37.127
但这就说得通了为什么要改变一下。

8020
11:08:37.400 --> 11:08:41.700
好了，现在我们已经清理好了，我们要部署标记，部署Funmi。

8021
11:08:41.700 --> 11:08:43.917
让我们继续并开始编写一些测试。

8022
11:08:43.917 --> 11:08:50.339
写完这些测试后，我们会运行那个气体估计器使用那个气体估计器，

8023
11:08:50.339 --> 11:08:56.334
我们会返回，我们会再次更新这个契约使它使用和工作更便宜。

8024
11:08:56.400 --> 11:09:04.721
记住，这将是编写这些测试的优势之一，我们如何优化我们的合同，使其更快，更省油，等

8025
11:09:04.721 --> 11:09:13.043
等，我们要确保我们编写真正好的测试，这将是我们进入这些更专业的测试设置的第一步。

8026
11:09:13.043 --> 11:09:16.226
我们要跳转到测试文件夹，删除这个样本测试。

8027
11:09:16.226 --> 11:09:16.384
js。

8028
11:09:16.384 --> 11:09:21.336
在上一节中，我们讲了一个非常简单的测试，这很好。

8029
11:09:21.336 --> 11:09:26.263
然而，当我们的项目越来越大时，我们会想要开始测试越来越多

8030
11:09:26.263 --> 11:09:31.190
不同的东西，我们会越来越多地进行至少两种不同类型的测试。

8031
11:09:31.190 --> 11:09:34.949
如果cd到test文件夹，我们会创建一个名为staging的目录。

8032
11:09:34.949 --> 11:09:38.778
然后我们要创建另一个名为unit的目录。

8033
11:09:38.778 --> 11:09:44.137
现在如果我们看一下我们的测试文件夹，我们现在有一个登台文件夹，和一个单元测试文件夹。

8034
11:09:44.137 --> 11:09:47.146
现在我们要讨论两种不同类型的测试。

8035
11:09:47.146 --> 11:09:49.363
第一个是单元测试。

8036
11:09:49.401 --> 11:09:56.350
那么什么是单元测试呢?单元测试是一种软件测试方法，通过它可以测试源代码的各个单元。

8037
11:09:56.401 --> 11:10:03.972
基本上，我们想做的是在我们的合同中，我们想测试我们的代码的最小部分，以确保它们正常工作。

8038
11:10:03.972 --> 11:10:10.463
一旦我们的小块测试工作了，我们想要做一个分阶段测试或集成测试。

8039
11:10:10.463 --> 11:10:15.083
这可能是我们在测试网络或某些实际网络上运行代码的地方。

8040
11:10:15.083 --> 11:10:19.615
你可以想到一个阶段性测试，它是你部署到主网之前的最后一站。

8041
11:10:19.615 --> 11:10:24.341
它们并不总是100%必要的，但它们真的非常非常有帮助。

8042
11:10:24.401 --> 11:10:30.576
记住，我们确实想要认真对待我们使用测试网的程度，但我们绝对百分之百想

8043
11:10:30.576 --> 11:10:36.934
要确保所有东西都在本地工作，我们进行单元测试，我们在本地运行所有代码。

8044
11:10:36.934 --> 11:10:45.205
然后，我们可以在实际的测试网络上使用分期测试，以确保我们的代码将与实际的其他契约一起工作。

8045
11:10:45.205 --> 11:10:53.368
单元测试可以在本地硬帽网络或分叉硬帽网络中完成，我们很快会讲到这个，现在，

8046
11:10:53.368 --> 11:11:01.090
让我们来构建这些单元测试，这些单元测试基本上就是我们在上一节中看到的。

8047
11:11:01.090 --> 11:11:04.057
让我们开始写一些单元测试。

8048
11:11:04.057 --> 11:11:09.910
让我们创建一个新的测试，我们将它命名为。test。j s。

8049
11:11:09.910 --> 11:11:12.402
我们会在这里开始测试

8050
11:11:12.402 --> 11:11:16.763
现在，我们在之前的上一节中进行了测试，但这里的测试看起来有点不同，

8051
11:11:16.763 --> 11:11:23.635
我们实际上将使用hardhat deploy，来自动设置我们的测试，就像这两个部署函数都已经运行了一样。

8052
11:11:23.635 --> 11:11:25.140
让我们开始吧。

8053
11:11:25.140 --> 11:11:31.336
所以我们还是会用我们将要描述的相同的设置，我们会说，资助我。

8054
11:11:31.336 --> 11:11:39.111
这个会像这样有一个async函数。

8055
11:11:39.111 --> 11:11:43.748
在这里，我们会在每一个之前有一个，我们会有一

8056
11:11:43.748 --> 11:11:48.386
些hits和一些description等等。

8057
11:11:48.386 --> 11:11:56.918
既然我们要对它进行单元测试，这里的测试会稍微重一点，然后是我们的上一个项目，但在未来，我们会稍微轻一点用一些测试。

8058
11:11:56.918 --> 11:11:58.350
让我们开始吧。

8059
11:11:58.350 --> 11:12:04.565
如果我们现在做硬头纱测试，我们不会有一个合格的。

8060
11:12:04.565 --> 11:12:13.272
现在，如果我们使用纱线硬帽覆盖，我们会得到像这样的东西，说，嘿，你漏掉了很多东西。

8061
11:12:13.272 --> 11:12:16.402
所以让我们试着用我们的测试覆盖更多的行。

8062
11:12:16.402 --> 11:12:21.787
我们可以这样做的一种方法是我们可以根据不同的函数来分组测试。

8063
11:12:21.787 --> 11:12:25.936
因此，让我们在构造函数周围进行第一组测试。

8064
11:12:25.936 --> 11:12:31.533
为了在第一个描述中做到这一点，我们可以添加另一个描述，让这个

8065
11:12:31.533 --> 11:12:37.130
描述只是构造函数，这个更大的作用域将用于整个Funmi契约。

8066
11:12:37.130 --> 11:12:41.149
这个里面的所有东西都是给构造函数的。

8067
11:12:41.149 --> 11:12:43.859
这也是一个async函数。

8068
11:12:43.859 --> 11:12:46.753
这些任务只针对构造函数。

8069
11:12:46.753 --> 11:12:51.199
但是在我们开始这个描述之前，我们可能需要部署我们的Funmi契约。

8070
11:12:51.199 --> 11:12:52.703
我们来学习一下怎么做。

8071
11:12:52.703 --> 11:12:56.822
我们会在每个之前做一个a，这将是一个async函数。

8072
11:12:56.822 --> 11:13:03.353
我们将使用硬帽部署来部署Funmi契约。

8073
11:13:03.353 --> 11:13:09.943
因为我们使用硬帽部署，我们的Funmi合同将与我们的模拟和一切。

8074
11:13:09.943 --> 11:13:13.816
在每个之前，我们来做HDMI。

8075
11:13:13.816 --> 11:13:19.302
然后这里，我们要部署Funmi，我们要在这里部署Funmi

8076
11:13:19.302 --> 11:13:24.979
契约首先从Harnett deploy中拉入我们的部署对象。

8077
11:13:24.979 --> 11:13:29.903
我们写const deployment = require hardhat。

8078
11:13:29.903 --> 11:13:35.337
这个部署对象有一个叫fixture的功能它允许

8079
11:13:35.337 --> 11:13:41.009
我们运行整个deploy文件夹带尽可能多的标签。

8080
11:13:41.009 --> 11:13:45.435
您会注意到，我在两个脚本中都添加了这个alt标记。

8081
11:13:45.435 --> 11:13:50.822
这意味着在这个部署东西fixture中，它将是一个等待的fixture部署。

8082
11:13:50.822 --> 11:13:58.014
如果我运行deployment。fixture，我将在本地网络上运行deploy脚本并部

8083
11:13:58.014 --> 11:14:05.371
署所有可以在脚本和测试中使用的契约，我们可以部署deploy文件夹中的所有内容只需这一行。

8084
11:14:05.371 --> 11:14:06.616
这不是很有帮助吗?

8085
11:14:06.616 --> 11:14:12.154
现在，一旦我们所有的合同都部署好了，我们可以开始得到他们

8086
11:14:12.154 --> 11:14:17.692
会说，基金我等于等待以太，我们也会拉一个以太一些硬帽子。

8087
11:14:17.692 --> 11:14:21.797
点，这就是安全帽部署有用的地方。

8088
11:14:21.797 --> 11:14:27.361
同样，很难部署rapt ether使用一个叫Get contract的函

8089
11:14:27.361 --> 11:14:33.081
数，这个Get contract函数将获取我们告诉它的任何契约的最新部署。

8090
11:14:33.081 --> 11:14:35.725
我们会说，给我一个乐趣契约。

8091
11:14:35.725 --> 11:14:41.469
所以这将给我们最新的李部署的Funmi合同在这一行。

8092
11:14:41.469 --> 11:14:45.239
现在Funmi等于这条线。

8093
11:14:45.404 --> 11:14:48.216
现在我们要用Funmi做一些交易。

8094
11:14:48.404 --> 11:14:48.870
测试它。

8095
11:14:52.404 --> 11:14:54.453
想要连接资金我。

8096
11:14:57.404 --> 11:15:04.070
消失得到命名帐户，就像我们在部署脚本中所做的一样。

8097
11:15:04.070 --> 11:15:09.200
然后我们只需要从我们的tap导入它在我们的部署脚本中

8098
11:15:09.200 --> 11:15:14.331
我们导入了在我们的部署函数的输入参数中获取命名帐户。

8099
11:15:14.404 --> 11:15:19.576
记住，获取命名帐户和部署是从硬帽运行时环境中抽象出来

8100
11:15:19.576 --> 11:15:24.748
的，就像我说的，硬帽运行时环境基本上和硬帽是一样的。

8101
11:15:24.748 --> 11:15:28.617
我们可以像这样导入它，实际上像这样。

8102
11:15:28.617 --> 11:15:32.911
因为我们实际上只需要从获取命名帐户中抽象部署者。

8103
11:15:32.911 --> 11:15:37.522
现在我们能做的是将部署者连接到Fund Me账户。

8104
11:15:37.522 --> 11:15:44.129
每当我们调用一个带有fundme的函数时，它会自动从玩家账户中取出，这很好。

8105
11:15:44.129 --> 11:15:48.155
另一种方法是你可以直接从你心中的配置获得不同的账户。

8106
11:15:48.155 --> 11:15:53.193
你可以用const accounts = await ethers。get

8107
11:15:53.193 --> 11:15:59.594
signers, ethers。get signers将返回网络中这个帐户部分中的任何东西。

8108
11:15:59.594 --> 11:16:06.940
如果你用的是默认的网络硬帽，它会给你一个10个假账户的列表我们可以用它，当然，可以用const。

8109
11:16:06.940 --> 11:16:09.940
账户1等于账户。

8110
11:16:09.940 --> 11:16:15.945
更正确的做法是账户0等于账户0，然后这样操作。

8111
11:16:15.945 --> 11:16:18.808
我们将把注释放在一边，以防将来需要引用它。

8112
11:16:18.808 --> 11:16:19.388
好了,好了。

8113
11:16:19.388 --> 11:16:21.071
现在我们有了Funmi合同。

8114
11:16:21.071 --> 11:16:23.940
让我们继续编写一些测试来测试构造函数。

8115
11:16:23.940 --> 11:16:27.785
我们可能需要使用下面这个deployer对象。

8116
11:16:27.785 --> 11:16:30.245
我们会让部署者在上面。

8117
11:16:30.405 --> 11:16:32.642
我们要在这里做一些繁琐的事情。

8118
11:16:33.405 --> 11:16:38.896
deployer =等，获取命名帐户，点部署者。

8119
11:16:39.405 --> 11:16:44.388
我们将把它包装起来这样我们就能获取这个部署者对象并将它赋值为这样的声明。

8120
11:16:44.388 --> 11:16:52.947
在这里，我们会创建第一个测试，我们会说它会正确设置Agra Gator地址。

8121
11:16:52.947 --> 11:16:57.354
逗号将使它成为一个async函数。

8122
11:16:57.354 --> 11:17:01.809
我们写入const response = await

8123
11:17:01.809 --> 11:17:08.321
fundme。让我们在这里得到这个价格提要，fundme。price提要。

8124
11:17:08.405 --> 11:17:16.309
然后我们要确保这个价格提要将与我们的mkv 3聚合器相同因为我们将在本地运行这些测试。

8125
11:17:16.309 --> 11:17:21.139
我们应该把标记3v3聚合器放在最上面。

8126
11:17:21.139 --> 11:17:25.186
让我们模拟v3聚合存储。

8127
11:17:25.406 --> 11:17:30.957
我们会用同样的方式获取这个地址，mockbee Three aggregator = await

8128
11:17:30.957 --> 11:17:37.897
ethers。get contract mockbee Three aggregator，我们也会把这个连接到部署者。

8129
11:17:37.897 --> 11:17:42.433
我们会说，cert。equals cert。equal

8130
11:17:42.433 --> 11:17:48.651
response, lockv3 aggregator。address。

8131
11:17:48.651 --> 11:17:54.156
当然我们会说const。

8132
11:17:54.156 --> 11:17:57.281
断言= require gy。

8133
11:17:57.281 --> 11:17:59.406
从大疆导入。

8134
11:17:59.406 --> 11:18:00.252
好的,很酷。

8135
11:18:00.406 --> 11:18:03.175
现在，我们来试试这个。

8136
11:18:03.175 --> 11:18:04.175
纱线建筑工人。

8137
11:18:04.175 --> 11:18:04.559
测试。

8138
11:18:05.406 --> 11:18:07.180
response拼写错误。

8139
11:18:07.180 --> 11:18:08.873
让我们再试一次。

8140
11:18:08.873 --> 11:18:09.518
太棒了。

8141
11:18:10.406 --> 11:18:17.263
意味着我们确实正确地将价格提要地址分配给了Mach v3聚合器。

8142
11:18:17.263 --> 11:18:18.242
好了,好了。

8143
11:18:18.406 --> 11:18:18.729
太棒了。

8144
11:18:21.406 --> 11:18:21.929
构造函数。

8145
11:18:24.406 --> 11:18:28.371
它们更多的是演示它们的样子，我们现在将跳过为它们编写测试。

8146
11:18:28.371 --> 11:18:32.356
我们会直接从合同中删除它们。

8147
11:18:32.406 --> 11:18:35.889
如果您想继续为它们编写一些测试，并将它们留在示例中以供学习。

8148
11:18:35.889 --> 11:18:41.033
你完全可以暂停视频，写一些测试，如果你愿意的话，但我们会跳过这些。

8149
11:18:41.033 --> 11:18:46.130
接下来，我们将继续资助和运行一些有趣的测试。

8150
11:18:46.130 --> 11:18:48.478
我们来写描述基金。

8151
11:18:48.478 --> 11:18:50.854
这将是一个异步函数。

8152
11:18:50.854 --> 11:18:55.656
在这里，我们要做一些测试。

8153
11:18:55.656 --> 11:19:02.092
如果我们要一行一行地看，我们首先应该看什么?我们应该看看这个要求

8154
11:19:02.092 --> 11:19:08.529
行我们应该写一个测试看看这个契约是否真的失败?如果不够，就发送。

8155
11:19:08.529 --> 11:19:15.530
如果没有发送足够的eath，它就会失败这是异步函数吗?

8156
11:19:15.530 --> 11:19:22.012
现在，我们如何测试是否出现故障?现在我们已经完成了

8157
11:19:22.012 --> 11:19:29.273
言等于操作，但是如果某些操作失败，我们可能会遇到问题。

8158
11:19:29.273 --> 11:19:37.193
例如，如果我运行await fund me。fund，但我没有传递任何值给这个事务。

8159
11:19:37.193 --> 11:19:38.324
让我们看看会发生什么。

8160
11:19:38.324 --> 11:19:39.734
我进行纱线硬头试验。

8161
11:19:39.734 --> 11:19:44.242
我们的测试实际上是要打破VM异常。

8162
11:19:44.407 --> 11:19:49.519
在处理用原因字符串返回的事务时，您需要花费更多的时间。

8163
11:19:49.519 --> 11:19:51.990
所以我们的测试会中断，这很好。

8164
11:19:51.990 --> 11:19:53.823
我们想让它破裂。

8165
11:19:53.823 --> 11:19:57.540
但我们想告诉我们的测试，这是可以的。

8166
11:19:57.540 --> 11:20:00.073
对吧?我想告诉你这没什么。

8167
11:20:00.073 --> 11:20:05.182
我们可以这样做，这就是华夫饼测试发挥作用的地方。

8168
11:20:05.182 --> 11:20:07.034
通过华夫和测试，

8169
11:20:07.034 --> 11:20:15.140
我们实际上可以做的是使用expect关键字并期望事务被恢复和事务失败。

8170
11:20:15.140 --> 11:20:23.084
这里我们不使用断言，而是运行一个wait expect fundme。fun 2。

8171
11:20:23.084 --> 11:20:30.409
2点乘B，那是还原的实际上我们在这里更具体地说

8172
11:20:30.409 --> 11:20:37.734
要还原然后精确的还原误差，你需要花更多的时间。

8173
11:20:37.734 --> 11:20:41.997
如果我们运行我们的测试，哎呀，expect没有定义。

8174
11:20:41.997 --> 11:20:45.426
所以我们要从柴那里进口。

8175
11:20:45.426 --> 11:20:53.177
这chai被华夫饼覆盖了，我们看到它确实是Pass，这是完美的。

8176
11:20:53.177 --> 11:20:58.311
所以现在我们有了一种既断言事物又预期事物失败的方法。

8177
11:20:58.311 --> 11:21:01.278
太棒了，即使有特定的失败代码。

8178
11:21:01.408 --> 11:21:01.758
完美的。

8179
11:21:01.758 --> 11:21:03.408
让我们在这里编写更多的测试。

8180
11:21:04.408 --> 11:21:08.023
希望它正确地更新此数据结构。

8181
11:21:09.408 --> 11:21:17.541
它会更新资金数额的数据结构，这将是一个异步函数。

8182
11:21:17.541 --> 11:21:21.214
在这里，我们需要调用fund v。fund。

8183
11:21:21.214 --> 11:21:27.149
然而，我们需要在这个事务中传递一些值。

8184
11:21:27.149 --> 11:21:33.158
现在，我们只硬编码我们要发送的值，比如const。

8185
11:21:33.158 --> 11:21:41.469
发送值将是112345 678-910-1234 5678，这将是一个eath。

8186
11:21:41.469 --> 11:21:46.604
另一种写法是，我们可以使用ethers实用程序，让它更容易阅读。

8187
11:21:46.604 --> 11:21:51.908
因为所有这些0都有点让人困惑，很难第一眼看出这到底是什么。

8188
11:21:51.908 --> 11:21:59.543
我们将使用ethers。utils。parse ether，这个parse

8189
11:21:59.543 --> 11:22:07.178
ethers实用程序将这个转换成那个有18个0的，这让事情变得简单多了。

8190
11:22:07.178 --> 11:22:15.534
如果你去乙醚文档，还有一个零件单位函数你可以转换任何单位，乙醚或Gwei。

8191
11:22:15.534 --> 11:22:20.588
或者不管你想做什么，你可以将任何数字转换为你输入的任何其他Aetherium。

8192
11:22:20.588 --> 11:22:23.599
这是基金的设定值。

8193
11:22:23.599 --> 11:22:28.195
这肯定会大于我们的最低50美元。

8194
11:22:28.195 --> 11:22:35.710
调用这个fun函数后，我们会说const response将等于一个权重，fundme。address

8195
11:22:35.710 --> 11:22:43.373
to Mt funding address to Mt funding for部署者。address。

8196
11:22:43.373 --> 11:22:49.159
因为记住，这是每个地址和他们实际资助的金额的映射。

8197
11:22:49.159 --> 11:22:54.251
如果我们使用部署者地址，它会给我们实际发送的数量。

8198
11:22:54.251 --> 11:22:57.830
现在我们可以运行assert。equal response。

8199
11:22:57.830 --> 11:23:04.900
到字符串，对吧，因为这个响应将是那个帐户提供资金的大数字版本。

8200
11:23:04.900 --> 11:23:08.128
这应该和我们的发送值相同。

8201
11:23:08.128 --> 11:23:08.999
字符串。

8202
11:23:08.999 --> 11:23:15.337
既然发送价值，我们的一个应该是完全相同的金额，我们的资金，我们可以只运

8203
11:23:15.337 --> 11:23:21.857
行这一个测试，或运行纱线，艺术帽子，测试，dash dash grep。

8204
11:23:21.857 --> 11:23:27.774
我们把它加在引号里允许为这个金额提供资金。

8205
11:23:27.774 --> 11:23:35.634
看起来我们在这里遇到了一个问题，因为我们不需要在地址处部署，我们可以在这里部署。

8206
11:23:35.634 --> 11:23:38.742
太好了，看来我们真的要过去了。

8207
11:23:38.742 --> 11:23:45.309
现在如果我们甚至运行纱线Hardhead覆盖现在会看到我们得到了至少一点更多的覆盖在这里。

8208
11:23:45.309 --> 11:23:46.959
还是不会很好。

8209
11:23:46.959 --> 11:23:48.748
但我们有更好的覆盖。

8210
11:23:48.748 --> 11:23:52.777
我们有一些语句，一些分支，至少有一些函数。

8211
11:23:52.777 --> 11:23:53.771
这太棒了。

8212
11:23:53.771 --> 11:23:54.650
让我们继续。

8213
11:23:54.650 --> 11:23:58.215
我们的有趣功能测试完成了吗?好吧，可能不是。

8214
11:23:58.215 --> 11:24:03.901
我们还能用fun函数做什么?我们也在把资助者添加到资助者数组中。

8215
11:24:03.901 --> 11:24:07.441
我们来测试一下。

8216
11:24:07.441 --> 11:24:15.442
所以它将资助者添加到资助者数组中一直是一个异步函数。

8217
11:24:15.442 --> 11:24:22.753
我们说await fund意思是基金值将是发送值。

8218
11:24:22.753 --> 11:24:27.071
我们会说const response =

8219
11:24:27.071 --> 11:24:32.901
await fundme。在索引0处调用资助者数组。

8220
11:24:32.901 --> 11:24:39.767
这里是，fundunder = await fundme。funders为0。

8221
11:24:39.767 --> 11:24:44.972
然后我们会说断言。等于投资人应该和部署者一样。

8222
11:24:44.972 --> 11:24:47.060
让我们继续运行这个测试。

8223
11:24:47.060 --> 11:24:48.460
我们会见面几次。

8224
11:24:48.460 --> 11:24:55.845
我们会把GREP改到数组下面这样它就能找到这一行。

8225
11:24:55.845 --> 11:24:56.861
和完善。

8226
11:24:56.861 --> 11:24:59.377
看来那个也要过去了。

8227
11:24:59.377 --> 11:24:59.764
太好了。

8228
11:24:59.764 --> 11:25:06.237
因此，资金流入，最低金额流入，我们的数据结构也在更新。

8229
11:25:06.237 --> 11:25:06.788
太棒了。

8230
11:25:06.788 --> 11:25:11.143
现在我们可以再啰嗦一点用这个有趣的函数做更多的测试。

8231
11:25:11.143 --> 11:25:13.743
但我认为在大多数情况下，我们已经得到了要点，对吧。

8232
11:25:13.743 --> 11:25:17.246
现在让我们继续看取款函数。

8233
11:25:17.246 --> 11:25:21.076
我们要创建一个新的描述或提取。

8234
11:25:21.076 --> 11:25:26.142
这将是一个async函数。

8235
11:25:26.410 --> 11:25:29.070
我们来看看取款函数是怎么做的。

8236
11:25:29.410 --> 11:25:34.071
合同的所有者将能够得到余额，拿回钱。

8237
11:25:34.071 --> 11:25:38.770
我们还会重置每个用户完成的所有数量。

8238
11:25:38.770 --> 11:25:40.910
我们来做一些提取。

8239
11:25:40.910 --> 11:25:49.282
现在为了让我们测试提取，我们可能首先希望合同中确实有一些钱，所以我们实际上可

8240
11:25:49.282 --> 11:25:57.875
以做的是在每个描述之前添加另一笔钱，在我们运行任何测试之前自动为合同提供资金。

8241
11:25:57.875 --> 11:26:02.536
我们可以在每个async函数之前说。

8242
11:26:02.536 --> 11:26:07.457
我们可以说await, fund me。fund。

8243
11:26:07.457 --> 11:26:09.988
值，发送值。

8244
11:26:10.411 --> 11:26:16.818
现在我们所有的测试都在这个提取范围内，我们首先要用每个人的资金。

8245
11:26:16.818 --> 11:26:20.927
假设它可以取钱，取钱。

8246
11:26:20.927 --> 11:26:27.185
从单个创建者，这将是一个异步函数。

8247
11:26:27.185 --> 11:26:31.926
这是一个稍微长一点的测试。

8248
11:26:31.926 --> 11:26:38.973
我将把它设置为一个安排，行动和断言测试。

8249
11:26:38.973 --> 11:26:45.169
arrange act assert是一种编写测试的方式，你想要安排测试，然后你想要操作。

8250
11:26:45.169 --> 11:26:48.478
然后你要运行断言，一会儿你就会明白我的意思。

8251
11:26:48.478 --> 11:26:56.220
所以我们要安排这个测试，我们要设置这个测试，我们要实际检查我们是否正确地从一个创建者提取以太。

8252
11:26:56.220 --> 11:27:02.533
首先，我们要得到融资合同的初始余额和部署者的初始余额。

8253
11:27:02.533 --> 11:27:05.199
所以我们用const。

8254
11:27:05.199 --> 11:27:11.455
从我开始，余额，等于等待，资助我。

8255
11:27:11.455 --> 11:27:17.344
提供者，获取余额，资助我。地址。

8256
11:27:17.344 --> 11:27:23.724
我们从基金V合同的余额开始在它得到一些资金后。

8257
11:27:23.724 --> 11:27:31.540
我们也会开始花费，部署你的余额等待，

8258
11:27:31.540 --> 11:27:39.356
资助我。提供者，得到部署雇主的余额。

8259
11:27:39.412 --> 11:27:44.668
我们得到了Funmi的初始余额，我们得到了雇主的初始余额这样我们

8260
11:27:44.668 --> 11:27:50.089
就可以稍后测试这些数字有多少变化基于我们调用取款函数时发生的事情。

8261
11:27:50.089 --> 11:27:55.459
现在我们已经完成了一点设置，我们可以运行这个取款函数，我们可以在这里执行这个动作。

8262
11:27:55.459 --> 11:28:03.697
我们会说const, transactionresponse = await, fundme。withdraw。

8263
11:28:03.697 --> 11:28:09.998
然后我们可以说const，

8264
11:28:09.998 --> 11:28:16.300
事务接收等于等待事务响应。

8265
11:28:16.300 --> 11:28:20.879
等待，一个，现在我们应该能够检查整

8266
11:28:20.879 --> 11:28:25.459
个基金再平衡已经添加到部署者余额。

8267
11:28:25.459 --> 11:28:32.554
现在我们可以说const结束，基金我余额等于

8268
11:28:32.554 --> 11:28:39.649
一个权重在我上提供者。get余额虚幻。地址。

8269
11:28:39.649 --> 11:28:46.546
然后我们可以说const ending deployer balance =

8270
11:28:46.546 --> 11:28:55.258
await, fundme。provider。get balance of deployer。

8271
11:28:55.258 --> 11:29:00.300
现在我们可以看看这些数字是否正确。

8272
11:29:00.412 --> 11:29:04.809
所以我们可以说断言。equal =

8273
11:29:04.809 --> 11:29:13.347
endfundme结余将是零，对吧，因为我们刚刚取出了所有的钱。

8274
11:29:13.413 --> 11:29:15.993
所以期末资金余额应该是零。

8275
11:29:17.413 --> 11:29:25.996
点等于初始资金余额加上初始部署余额。

8276
11:29:25.996 --> 11:29:34.344
初始资金余额加上初始雇主余额应该等于最终雇主余额。

8277
11:29:34.413 --> 11:29:39.749
因为我们取的是初始部署者的余额加上初始基金来平衡，因为我们刚

8278
11:29:39.749 --> 11:29:45.263
刚取出了所有的初始基金，我们的余额应该等于最终部署者的机器人。

8279
11:29:45.263 --> 11:29:52.302
这里有几点注意，因为Funmi balance是从区块链调用的，它的类型是一

8280
11:29:52.302 --> 11:29:59.527
个大数，我们想用大数。加，而不是这里的加号，因为它会它会让处理大数更容易一些。

8281
11:29:59.527 --> 11:30:05.413
我们不从Funmi balance开始，而是从balance。add开始。

8282
11:30:05.413 --> 11:30:06.038
像这样。

8283
11:30:06.038 --> 11:30:07.379
这应该是件好事。

8284
11:30:07.379 --> 11:30:16.235
关于这个还有一件事，当我们调用withdraw时，我们的Deployer做了我们的Deployer花了一点汽油。

8285
11:30:16.235 --> 11:30:19.847
所以这实际上是不准确的。

8286
11:30:19.847 --> 11:30:26.701
我们实际上还需要计算汽油成本，所以我们不需要做点加汽油成本。

8287
11:30:26.701 --> 11:30:28.480
我们也必须这么做。

8288
11:30:28.480 --> 11:30:34.671
字符串，因为大的数字是对象，所以恒等式有点奇怪。

8289
11:30:34.671 --> 11:30:39.302
为了测试它们是否相等，我们将它们都设为字符串。

8290
11:30:39.302 --> 11:30:42.413
现在我们没有汽油成本了。

8291
11:30:42.413 --> 11:30:47.476
我们来看看如何从这个交易中得到汽油成本。

8292
11:30:47.476 --> 11:30:51.610
我们可以把它添加到Are any deployer bounce，我们可以在这里运行这个断言。

8293
11:30:51.610 --> 11:30:55.887
我们能做的就是从交易收据中找到汽油成本。

8294
11:30:55.887 --> 11:31:00.880
我将向你们展示一些在VS code中可以使用的非凡技巧。

8295
11:31:00.880 --> 11:31:04.366
如果使用不同的编辑器，那么不必太担心这个。

8296
11:31:04.414 --> 11:31:08.299
我们可以在VS code中创建断点。

8297
11:31:08.299 --> 11:31:12.730
修改未验证的断点文件以重新启动错误会话，或者

8298
11:31:12.730 --> 11:31:17.363
我们把它放在这里，放在事务接收创建后的这一行。

8299
11:31:17.414 --> 11:31:24.223
但是在结束Funmi带之前，这个断点的作用是它在这一行停止脚本，

8300
11:31:24.223 --> 11:31:31.033
并允许我们进入一个叫做调试控制台的东西，查看正在发生的所有变量。

8301
11:31:31.033 --> 11:31:36.525
在这个时候，我们想看看交易收据，看看总汽油费用是否在里面。

8302
11:31:36.525 --> 11:31:44.142
这对于进入测试和脚本并查看到底哪里出了问题也非常有帮助。

8303
11:31:44.142 --> 11:31:47.758
我们能做的就是往下看遇到bug这一节。

8304
11:31:47.758 --> 11:31:50.315
如果它不在那里，你可以点击其他视图。

8305
11:31:50.414 --> 11:31:57.628
我们可以单击这个JavaScript调试终端，它将在我们的终端部分创建一个新终端。

8306
11:31:57.628 --> 11:32:04.461
现在发生的是，如果我们运行纱线，硬帽测试，它会运行我们的测试和一切。

8307
11:32:04.461 --> 11:32:06.610
但是当它到达这个断点时，它就会停止。

8308
11:32:06.610 --> 11:32:08.183
目前，没有汽油成本。

8309
11:32:08.183 --> 11:32:10.117
我们先把这个删掉。

8310
11:32:10.117 --> 11:32:12.233
这样我们就可以编译和工作。

8311
11:32:12.233 --> 11:32:21.091
但是如果我们运行yarn Hardhead test，它会说调试器已经附加，开始运行我们的测试。

8312
11:32:21.091 --> 11:32:23.814
它会在这条线上停下来。

8313
11:32:23.814 --> 11:32:32.351
如果我们看左边的变量部分，我们可以看到这里有很多变量。

8314
11:32:32.351 --> 11:32:35.866
我们可以读到更多关于发生了什么。

8315
11:32:35.866 --> 11:32:42.869
如果我们转到调试控制台，我们可以输入诸如事务收据之类的东西，

8316
11:32:42.869 --> 11:32:49.872
我们可以看到大量关于事务收据对象的信息，我们要找的是这个事务

8317
11:32:49.872 --> 11:32:57.344
收据，我们可以在调试控制台或这里查看，如果这里与gas有关的话。

8318
11:32:57.415 --> 11:33:01.344
看起来有一个很大的气体使用量。

8319
11:33:01.415 --> 11:33:03.972
还有一个有效的天然气价格。

8320
11:33:05.415 --> 11:33:11.200
用过的乘以汽油价格会得到我们支付的所有汽油钱。

8321
11:33:11.200 --> 11:33:16.250
现在我们已经算出了在这个交易收据中有使用过的汽油和

8322
11:33:16.250 --> 11:33:21.300
有效的汽油价格变量，我们也可以在这里的文件中找到。

8323
11:33:21.300 --> 11:33:30.248
不过，有时自己找出我们能做什么会更快，我们可以通过点击这里这个小东西退出调试器。

8324
11:33:30.248 --> 11:33:36.526
返回终端将垃圾桶的JavaScript调试器，我们将删除断点。

8325
11:33:36.526 --> 11:33:42.421
我们会获取这两个变量我们可以通过输入

8326
11:33:42.421 --> 11:33:48.316
const从事务接收对象中取出它们。

8327
11:33:48.415 --> 11:33:55.874
是的，使用逗号有效的汽油价格等于交易收据。

8328
11:33:55.874 --> 11:34:02.336
再一次，通过这个花括号语法，我们可以用它从另一个对象中取出对象。

8329
11:34:02.336 --> 11:34:07.799
现在我们有了这两个对象，我们可以创建一个const gas

8330
11:34:07.799 --> 11:34:14.016
cost或总gas cost等于使用的gas乘以有效gas价格。

8331
11:34:14.016 --> 11:34:18.966
因为这两个都是大数，我们可以用一个

8332
11:34:18.966 --> 11:34:23.916
叫做。mol的大数函数把它们相乘。

8333
11:34:23.916 --> 11:34:28.522
现在我们有了总天然气成本，我们可以下来我们

8334
11:34:28.522 --> 11:34:33.349
可以说最终部署者余额加上用于串的天然气成本。

8335
11:34:33.349 --> 11:34:36.149
这两个应该是等价的。

8336
11:34:36.149 --> 11:34:40.350
我知道我们在这部分要做很多数学运算和很多新东西。

8337
11:34:40.350 --> 11:34:43.399
我想快速回顾一下我们刚刚学过的内容。

8338
11:34:43.399 --> 11:34:48.591
首先，合约的字体带有提供者，我们也可以用ethers。provider。get

8339
11:34:48.591 --> 11:34:54.449
balance，但我们用fun v。provider因为我们用Funmi合约的提供者。

8340
11:34:54.449 --> 11:34:56.494
我们在这里用什么并不重要。

8341
11:34:56.494 --> 11:35:02.940
我们只是想使用provider对象的get balanced函数，它为我们获取任何契约的平衡。

8342
11:35:02.940 --> 11:35:06.284
我们做同样的事情开始痛惜平衡。

8343
11:35:06.416 --> 11:35:14.749
我们需要初始余额的原因是我们想将其与期末余额进行比较看看是否所有的钱都去了正确的地方，然后调用提款函数。

8344
11:35:14.749 --> 11:35:20.339
从交易收据上，我们查到了汽油使用量和价格。

8345
11:35:20.339 --> 11:35:26.701
如果你想调试你的JavaScript代码，你可以添加一个断点，比如go to run

8346
11:35:26.701 --> 11:35:33.216
into bug，打开你的调试JavaScript终端，这与常规的bash终端不同。

8347
11:35:33.216 --> 11:35:38.899
当您在这里运行JavaScript命令时，它们将在断点所在的位置停止。

8348
11:35:38.899 --> 11:35:41.845
然后你可以读取不同的变量，看到不同的东西在哪里。

8349
11:35:41.845 --> 11:35:42.845
利用这些知识。

8350
11:35:42.845 --> 11:35:50.505
我们从交易收据中提取出天然气使用量和有效天然气价格，用它来计算该交易的天然气总成本，然后我们

8351
11:35:50.505 --> 11:35:58.332
得到了最终基金，我们平衡了最终部署者余额，并使用所有这些变量来确保所有的钱都花在了正确的地方。

8352
11:35:58.332 --> 11:36:05.583
我们可以通过运行yarn Hardhead测试来检查，

8353
11:36:05.583 --> 11:36:12.298
因为这里有空格，我们可以看到我们的测试确实通过了。

8354
11:36:12.298 --> 11:36:13.145
伟大的工作。

8355
11:36:13.145 --> 11:36:17.481
如果我们不加汽油成本，我们已经加了。

8356
11:36:17.481 --> 11:36:23.395
对于弦，我们会看到这样的东西，我们会看到数字

8357
11:36:23.395 --> 11:36:29.578
有一点偏差，因为我们没有预测我们没有计算气体。

8358
11:36:29.578 --> 11:36:35.970
所以当我们做这样的计算时我们总是要确保我们用的是气体。

8359
11:36:35.970 --> 11:36:40.320
另一个非常强大的调试工具我们不打算在这里讲。

8360
11:36:40.320 --> 11:36:47.010
但了解它很重要因为它真的很有用你可以在你的solid with hard hat中使用console。log。

8361
11:36:47.010 --> 11:36:52.032
如果你在一个心形帽子项目中，你只需要导入hard hat斜杠/ console。soul。

8362
11:36:52.032 --> 11:36:58.899
然后在你的实体中，你可以输入console。log，然后输入你想要的任何东西。

8363
11:36:58.899 --> 11:37:06.269
当你执行这些函数时，类似于我们在JavaScript中做console。log，这些实际上会把console。log输出到你的终端。

8364
11:37:06.269 --> 11:37:13.820
这里有一个例子，如果你运行yarn，硬帽测试，你有那些console。log，你会看到像这样的东西被打印出来。

8365
11:37:13.820 --> 11:37:19.085
因此，除了Visual Studio Code调试器之外，导入硬帽斜杠console。

8366
11:37:19.085 --> 11:37:24.351
Sol，以及在您的solidity中使用console。log也是一种有效的调试策略。

8367
11:37:24.351 --> 11:37:30.318
请暂停这个视频，在我们的一些合同中执行这个，并在我们的测试中尝试它。

8368
11:37:30.318 --> 11:37:36.592
我们测试了当只有一个出资人的情况下取款效果很好，

8369
11:37:36.592 --> 11:37:42.343
让我们测试一下如果有多个出资人的情况下取款，

8370
11:37:42.343 --> 11:37:48.618
们会这样做，假设允许我们从多个出资人那里取款。

8371
11:37:48.618 --> 11:37:53.349
为什么这是一个异步函数。

8372
11:37:53.349 --> 11:38:01.327
让我们做这个等待Funmi不好玩，但与许多不同的帐户。

8373
11:38:01.327 --> 11:38:05.050
我们可以创建一大堆不同的账户，通过const

8374
11:38:05.050 --> 11:38:11.314
accounts = await ethers。get signers。

8375
11:38:11.314 --> 11:38:16.871
我们可以遍历这些账户让每个账户调用基金函数。

8376
11:38:16.871 --> 11:38:19.547
我们要用一个for循环来做这个。

8377
11:38:19.547 --> 11:38:24.785
我们说，for let i =我们从账户

8378
11:38:24.785 --> 11:38:30.285
的第一个索引开始因为带索引的0将是部署者。

8379
11:38:30.285 --> 11:38:35.306
假设i = 1小于6。

8380
11:38:35.306 --> 11:38:37.621
我们用i + +。

8381
11:38:37.621 --> 11:38:40.792
在这里，我们用const。

8382
11:38:40.792 --> 11:38:47.233
和我的合同Funmi连接的合同等于等待。

8383
11:38:47.233 --> 11:38:54.504
me点连接两个账户，I，我们需要调用这个连接函数因为现

8384
11:38:54.504 --> 11:39:01.775
在如果我们滚动到顶部，Funmi合约连接到部署者账户。

8385
11:39:01.775 --> 11:39:07.302
当我们用Funmi调用一个事务时，部署者就是调用该事务

8386
11:39:07.302 --> 11:39:13.034
的帐户，我们需要创建新的对象来连接到所有这些不同的帐户。

8387
11:39:13.034 --> 11:39:19.490
我们说，基金连接合约，它连接到其中一个不同账户。基金。

8388
11:39:19.490 --> 11:39:23.276
这就是我们做价值，发送价值的地方。

8389
11:39:23.276 --> 11:39:25.736
不好意思，我们用await。

8390
11:39:25.736 --> 11:39:26.116
太好了。

8391
11:39:26.116 --> 11:39:28.973
这就是我们的值域部分。

8392
11:39:28.973 --> 11:39:33.812
和上面一样，我们需要获取初始余额。

8393
11:39:33.812 --> 11:39:37.096
我们可以复制这两行，然后粘贴到这里。

8394
11:39:37.096 --> 11:39:41.919
现在我们进入行为，我将再次调用取款函数。

8395
11:39:41.919 --> 11:39:46.427
我们说const，事务操作response

8396
11:39:46.427 --> 11:39:50.935
= await和MI。withdraw。

8397
11:39:50.935 --> 11:39:59.657
我们要做和上面做的完全一样的事情，得到交易收据和汽油费用，这样我们就能把一切都弄清楚。

8398
11:39:59.657 --> 11:40:02.128
一旦我们完成了行为，我们就进入断言。

8399
11:40:02.128 --> 11:40:10.704
我们要做一些和上面做的非常相似的事情，比如这个，整个第一部分是完全一样的。

8400
11:40:10.704 --> 11:40:15.419
我们还想确保资助者被正确重置。

8401
11:40:15.419 --> 11:40:20.387
我们要确保这个资助者数组被正确重置。

8402
11:40:20.387 --> 11:40:27.549
要做到这一点，我们实际上可以检查一下，如果查看带有位置的0会抛出一个错误我们可以运行wait

8403
11:40:27.549 --> 11:40:35.180
expect fundme。get on me。funder on me。funders (0)

8404
11:40:35.180 --> 11:40:40.167
这应该会恢复所以我们写入await expect

8405
11:40:40.167 --> 11:40:47.024
Funmi。funders。2。b。reverted然后我们要遍历

8406
11:40:47.024 --> 11:40:53.258
们要遍历所有这些账户并确保它确保或者说在映射中，所有的金额都为零。

8407
11:40:53.258 --> 11:41:00.837
我们会说，对于I = 1小于6,I +

8408
11:41:00.837 --> 11:41:08.816
+，我们会说assert。equal。

8409
11:41:08.816 --> 11:41:15.653
等，基金我点地址到基金金额，

8410
11:41:15.653 --> 11:41:22.003
我拿到地址的账户应该是零。

8411
11:41:22.003 --> 11:41:27.629
我们要确保所有这些映射都被正确地更新为零。

8412
11:41:27.629 --> 11:41:28.887
我们来测试一下。

8413
11:41:28.887 --> 11:41:33.703
我们有多个创建者，我们会回到终端，我们

8414
11:41:33.703 --> 11:41:38.520
会点击，我们会改变这个或这个GREP。

8415
11:41:38.520 --> 11:41:41.020
我们看看这是否能通过。

8416
11:41:41.020 --> 11:41:45.735
确实如此，这意味着我们的提款功能在有多个资助者的情

8417
11:41:45.735 --> 11:41:50.640
况下也能很好地运作知道了这一点我们就能开心地睡觉了。

8418
11:41:50.640 --> 11:41:55.411
现在我们绝对想要100%想要测试的另一件事是我们唯一的所

8419
11:41:55.411 --> 11:42:00.182
有者修改器在工作，我们希望只有所有者能够从这里提取资金。

8420
11:42:00.182 --> 11:42:05.248
我们创建一个新会话，它只允

8421
11:42:05.248 --> 11:42:10.314
许所有者提款只允许你提款。

8422
11:42:10.420 --> 11:42:13.862
这将是一个异步函数。

8423
11:42:17.420 --> 11:42:19.657
Accounts =醚。get signed再次。

8424
11:42:20.420 --> 11:42:24.666
Const攻击者等于一个账号。

8425
11:42:27.421 --> 11:42:34.921
帐户将会是某个随机的攻击者将这个攻击者连接到一个新的合约，我

8426
11:42:34.921 --> 11:42:42.421
们说const攻击者连接的合约等于等待DB。connect。

8427
11:42:42.421 --> 11:42:47.674
攻击者。地址，不好意思是。连接攻击者。

8428
11:42:47.674 --> 11:42:55.695
因为我们不只是连接地址，而是连接攻击者是帐户对象的帐户。

8429
11:42:55.695 --> 11:43:01.814
然后我们会做一个等待，期望

8430
11:43:01.814 --> 11:43:07.933
攻击者连接契约。撤回。2。

8431
11:43:07.933 --> 11:43:14.524
b。返回，他们应该不能撤回。

8432
11:43:14.524 --> 11:43:22.813
让我们继续，我们甚至可以复制这整个如果我们想要点击，我们会删除这部分。

8433
11:43:22.813 --> 11:43:24.582
我们把它粘贴进去。

8434
11:43:24.582 --> 11:43:25.307
和繁荣。

8435
11:43:25.307 --> 11:43:32.711
这意味着当其他帐户试图调用取款时，会自动返回，这就是我们想要的。

8436
11:43:32.711 --> 11:43:39.921
现在我们可以更明确地确保抛出了正确的错误代码，而不仅仅是将其还原。

8437
11:43:39.921 --> 11:43:47.155
对，它可以被还原因为他们发送了以太他们做了一些奇怪的事情，我们要确保它被还原为我们特定的错误代码。

8438
11:43:47.155 --> 11:43:49.711
现在我们有这个非所有者错误代码。

8439
11:43:49.711 --> 11:43:56.959
但最好的做法是将合约名加上下划线，然后是自定义错误。

8440
11:43:56.959 --> 11:44:02.954
当您将来有大量不同的合同，并且不确定错误来自何处时，这使它变得容易得多。

8441
11:44:02.954 --> 11:44:10.624
我们要快速地更新这个把它改成，基金我下划线下划线，而不是所有者，现在我们能做的是现在我们

8442
11:44:10.624 --> 11:44:18.470
有了这个自定义错误，我们可以说，撤回那个要用它进行还原，然后我们可以在这里添加自定义错误。

8443
11:44:18.470 --> 11:44:25.596
现在，如果我们重新运行我们的测试，只允许所有者提取，我们需要在这里做一个等待。

8444
11:44:25.596 --> 11:44:28.320
是我的错，等到周四，再找签名。

8445
11:44:28.320 --> 11:44:30.286
现在我们再试一次。

8446
11:44:30.422 --> 11:44:35.274
我们确实超越了完美。

8447
11:44:35.422 --> 11:44:35.937
好了,好了。

8448
11:44:35.937 --> 11:44:37.577
我们这里有一些基本的单元测试。

8449
11:44:38.422 --> 11:44:40.588
很快就能写一些分段测试。

8450
11:44:41.422 --> 11:44:46.025
这样做，让我们继续添加气体估计器。

8451
11:44:46.422 --> 11:44:49.732
我们会看到这些函数的收缩消耗了多少气体。

8452
11:44:49.732 --> 11:44:52.760
看来硬脑集团的气体记者已经到了。

8453
11:44:52.760 --> 11:44:54.539
让我们向下滚动。

8454
11:44:54.539 --> 11:44:56.827
我们会做真实的气体报告。

8455
11:44:56.827 --> 11:44:59.555
这里我们不考虑硬币市值。

8456
11:44:59.555 --> 11:45:01.772
我们只看GUI。

8457
11:45:01.772 --> 11:45:03.210
你可以像这样注释掉它。

8458
11:45:03.210 --> 11:45:05.452
现在重新运行我们所有的测试

8459
11:45:05.452 --> 11:45:08.036
所以我们说纱线，我们的测试。

8460
11:45:08.036 --> 11:45:13.993
这样我们就会得到气体输出在气体报告的破折号文本中。

8461
11:45:13.993 --> 11:45:17.896
看来我们所有的测试都通过了，太好了。

8462
11:45:17.896 --> 11:45:22.234
现在我们来看看气体报告看看发生了什么。

8463
11:45:22.234 --> 11:45:27.194
嗯，看起来筹款功能消耗了大量的汽油，取款功能，

8464
11:45:27.194 --> 11:45:32.155
带一些客人去我们会看到最小值，最大值和平均值。

8465
11:45:32.155 --> 11:45:36.114
当然，我们可以看到每个合同的实际产出成本是多少。

8466
11:45:36.114 --> 11:45:40.385
当然，我们并不真正关心MOQ聚合器，因为我们从未真正使用过它。

8467
11:45:40.422 --> 11:45:45.798
假设我们看一下这些的平均气体量我们会说，嗯，这看起来比我们最初预期的要多很多。

8468
11:45:45.798 --> 11:45:48.329
有没有什么办法能让我们把价格降低一点。

8469
11:45:48.423 --> 11:45:52.711
如果我们回到我们的资金契约，我们看一下我们的取款函数。

8470
11:45:52.711 --> 11:45:57.507
我们注意到一件事，哦，实际上有一种方法可以让这个便宜很多。

8471
11:45:57.507 --> 11:46:05.368
它和一个叫做存储变量的东西有关，也就是我们一直在研究的全局变量。

8472
11:46:05.423 --> 11:46:12.009
让我给你们画一幅图，我们来看看第一个气体优化技术你可以用它来解决这些问题。

8473
11:46:12.009 --> 11:46:14.284
这和R Funmi有关。

8474
11:46:14.423 --> 11:46:19.819
缩并这些状态变量以及它们是如何存储的以及这个缩并

8475
11:46:19.819 --> 11:46:25.216
是如何跟踪所有这些东西的，这一节将会更高级一些。

8476
11:46:25.216 --> 11:46:29.919
这里我要说明一下，这是高级的部分，如果你想跳过它，你可以，

8477
11:46:29.919 --> 11:46:34.298
因为现在我们要讲到气体优化，知道这些信息还是很有用的。

8478
11:46:34.298 --> 11:46:38.177
所以如果你现在想跳过它，然后再回来，你完全可以。

8479
11:46:38.177 --> 11:46:44.914
我们来谈谈当我们保存或存储这些全局变量时会发生什么。

8480
11:46:44.914 --> 11:46:46.947
这些存储变量。

8481
11:46:46.947 --> 11:46:50.372
我接下来要讲的都在文档里了。

8482
11:46:50.423 --> 11:46:59.001
这里有一个链接，在与这门课相关的GitHub回购中，当我们有一个全局变量，或者这些变量永久存在时，它们会

8483
11:46:59.001 --> 11:47:07.580
被卡在一个叫做存储的东西中，你可以把存储想象成一个巨大的数组，或者一个我们实际创建的所有变量的巨大列表。

8484
11:47:07.580 --> 11:47:14.307
当我们有一个叫Son of storage的契约，我们有一个叫收藏号的变量，我们基本上是说

8485
11:47:14.307 --> 11:47:21.034
我们想让收藏号变量持久存在，对吧，我们在很多例子中看到过，我们有一个收藏号变量我们总是可以

8486
11:47:21.034 --> 11:47:27.762
调用它来查看收藏号的契约是什么，它持久存在的方式是，它被存储在一个叫storage的地方。

8487
11:47:27.762 --> 11:47:33.865
存储框是一个与契约相关的巨大列表存储段中的每个变量和

8488
11:47:33.865 --> 11:47:40.203
每个值都被插入到这个存储阵列中的一个32字节长的槽中。

8489
11:47:40.203 --> 11:47:47.392
例如，数字25在它的字节实现中是000加上一大堆的0 19。

8490
11:47:47.392 --> 11:47:49.820
这是人民币256的十六进制版本。

8491
11:47:49.820 --> 11:47:56.327
这就是为什么我们要做这么多十六进制的翻译，字节实现一个元256。

8492
11:47:56.424 --> 11:47:59.746
每个商店看到的增量就像一个数组从0开始。

8493
11:47:59.746 --> 11:48:04.544
例如，我们的下一个全局变量或者下一个

8494
11:48:04.544 --> 11:48:09.342
存储变量被分配到下一个可用的槽位上。

8495
11:48:09.424 --> 11:48:15.240
举个例子，金条从它们的公牛版本2，十六进制中转换过来

8496
11:48:15.240 --> 11:48:21.281
我们把bool变量修改为真值X版的真布尔值0x001。

8497
11:48:21.281 --> 11:48:29.620
每次保存一个额外的全局变量，或者更准确地说，保存一个存储变量时，它都会占用一个额外的存储槽。

8498
11:48:29.620 --> 11:48:37.167
那长度是动态的，或者可以改变长度的变量呢?那动态的东西呢?对于动态值，比如动态

8499
11:48:37.167 --> 11:48:44.714
数组，或者映射数组中的元素或者映射中的元素实际上是用某种类型的哈希函数存储的。

8500
11:48:44.714 --> 11:48:53.281
你可以在文档中看到那些特定的函数，对象本身会占用一个存储槽，但它不会是整个数组。

8501
11:48:53.281 --> 11:48:57.227
例如，我的数组变量，在存储槽2处，

8502
11:48:57.227 --> 11:49:06.282
并没有整个数组在存储槽2处，实际上只有数组的长度，数组的长度存储在存储槽2处。

8503
11:49:06.282 --> 11:49:11.840
但举个例子，如果我们用数组。push 222，我们会做一些

8504
11:49:11.840 --> 11:49:17.591
哈希函数，你可以在文档中看到那是什么，我们会存储数字222。

8505
11:49:17.591 --> 11:49:26.328
在存储的那个位置，222的十六进制是0x0000d，所以它被存储在这个疯狂的位置。

8506
11:49:26.425 --> 11:49:32.780
这很好，这是有意的，因为32字节可能不足以存储数组如果数组变得很大。

8507
11:49:32.780 --> 11:49:37.634
把数组里的元素放在后面的数字里是没有意义的因为数

8508
11:49:37.634 --> 11:49:42.691
组的大小是可以改变的你永远不知道你需要多少子序列。

8509
11:49:42.691 --> 11:49:46.942
对于我的数组，它有一个存储槽来存放映射的长度。

8510
11:49:46.942 --> 11:49:50.809
它也有一个存储点类似于数组，但它是空白的。

8511
11:49:50.809 --> 11:49:55.355
但它故意是空白的，这样固体就知道，这里有一

8512
11:49:55.355 --> 11:50:00.118
个映射，它需要一个存储槽来正确地连接函数功。

8513
11:50:00.118 --> 11:50:06.070
有趣的是，常量变量和不可变变量不会在存储中占据位置。

8514
11:50:06.070 --> 11:50:14.358
这是因为常量变量实际上是契约字节码本身的一部分，这听起来有点奇怪。

8515
11:50:14.425 --> 11:50:23.065
但是你可以想象固体的作用是当它看到常量变量名称时它就会自动把它和它实际的数字交换。

8516
11:50:23.065 --> 11:50:29.186
你可以把not in storage看作是一个指向123的指针它不占用存储槽。

8517
11:50:29.186 --> 11:50:36.358
当函数中有变量时，这些变量只在函数的持续时间内存在。

8518
11:50:36.425 --> 11:50:38.334
他们不会停留在合同内。

8519
11:50:39.425 --> 11:50:40.511
它们不是永久的。

8520
11:50:42.425 --> 11:50:46.025
比如new var和其他var不会被添加到存储中。

8521
11:50:46.426 --> 11:50:48.783
被添加到自己的内存数据结构中。

8522
11:50:49.426 --> 11:50:51.700
在函数运行完成后删除。

8523
11:50:52.426 --> 11:51:00.587
我们会问，为什么我们需要这个memory关键字，特别是当它涉及到字符串时，我们之前看到我们必须说字符串内存。

8524
11:51:00.587 --> 11:51:06.360
字符串需要它的原因是字符串技术上是动态大小的数组。

8525
11:51:06.426 --> 11:51:13.019
我们需要告诉固体性，嘿，我们要在存储位置做这个，或者我们要把它做到内存位置在那里我们可以擦除它。

8526
11:51:13.019 --> 11:51:15.671
数组和映射会占用更多的空间。

8527
11:51:15.671 --> 11:51:20.837
所以慢慢地，只是想确定，我们在哪里处理它存储是一个内存，你必须

8528
11:51:20.837 --> 11:51:26.171
告诉我，我需要知道我是否需要在我们的存储数据结构中为它分配空间。

8529
11:51:26.171 --> 11:51:29.104
再说一次，这里的所有东西你都可以在固体性文档中读到。

8530
11:51:29.104 --> 11:51:34.688
在与这门课相关的GitHub回购中，如果你去契约，我们实际上有一个契约示

8531
11:51:34.688 --> 11:51:40.273
例部分叫做Fun with storage，在那里你可以玩和看很多东西。

8532
11:51:40.273 --> 11:51:46.824
我们甚至写了一个叫deploy storage fun的小脚本，

8533
11:51:46.824 --> 11:51:53.375
它会打印出一些不同变量的存储位置，你可以试试，如果你想挑战任何人

8534
11:51:53.375 --> 11:51:59.926
写一些函数来找到数组元素的存储槽，以及映射，然后找到其中的数据。

8535
11:51:59.926 --> 11:52:05.583
我们在这里使用一个叫Get storage app的函数，它允许我们在任意一个槽处获得存储。

8536
11:52:05.583 --> 11:52:10.942
这是为了加强这一点即使你有一个私有或内部的功能。

8537
11:52:10.942 --> 11:52:12.619
任何人都可以阅读。

8538
11:52:12.619 --> 11:52:15.551
任何人都能从区块链上读出任何东西。

8539
11:52:15.551 --> 11:52:21.376
你可以测试它如果你自己克隆或复制粘贴代码。

8540
11:52:21.426 --> 11:52:27.328
然后您可以运行纱线部分在部署破折号测试标签，存储。

8541
11:52:27.427 --> 11:52:30.367
您将为该存储运行deploy脚本。

8542
11:52:30.427 --> 11:52:35.153
你会看到打印出每个存储槽的存储

8543
11:52:35.153 --> 11:52:39.880
位置用一个有趣的契约作为例子。

8544
11:52:39.880 --> 11:52:45.439
你当然可能会问，好吧，帕特里克，你为什么要告诉我这些?我们只是想

8545
11:52:45.439 --> 11:52:50.998
把油价降下来?你为什么要告诉我仓库的事?我之所以告诉你仓库的事。

8546
11:52:50.998 --> 11:52:55.577
无论何时你读写存储，你都要消耗大量的汽油。

8547
11:52:55.577 --> 11:53:00.194
记得我说过，当我们编译代码时，我们把它编译成一些疯狂的奇怪的字节码。

8548
11:53:00.194 --> 11:53:03.268
让我在混音上给你们看看这是什么样子。

8549
11:53:03.268 --> 11:53:06.668
我们去遵从细节，我们可以去字节码。

8550
11:53:06.668 --> 11:53:10.284
我们看到这个奇怪的十六进制对象0，等等等等。

8551
11:53:10.284 --> 11:53:12.749
但我们也看到这些叫做操作码的东西。

8552
11:53:12.749 --> 11:53:15.974
这个字节码代表了这些操作码。

8553
11:53:15.974 --> 11:53:21.099
这些操作码中的每一个都代表这个字节码中所有内容的一小部分。

8554
11:53:21.099 --> 11:53:27.045
事实上，在我们的心帽中，我们可以去工件，构建信息，我们可以看到，我们可

8555
11:53:27.045 --> 11:53:32.991
以在构建信息中看到这些操作代码，我们可以为操作代码执行命令F或控制F。

8556
11:53:32.991 --> 11:53:36.539
我们可以看到不同合同的操作代码。

8557
11:53:36.539 --> 11:53:39.891
这些操作代码表示机器代码正在做什么。

8558
11:53:39.891 --> 11:53:46.302
它们代表了实际运行代码和处理代码所需要的计算量。

8559
11:53:46.302 --> 11:53:49.314
计算气体的方法是通过这些操作码。

8560
11:53:49.314 --> 11:53:50.953
这里有几个列表。

8561
11:53:50.953 --> 11:53:53.656
但这里我要用这个EVM操作码。

8562
11:53:53.656 --> 11:53:57.777
同样的，在GitHub中有一个与这一课相关的链接。

8563
11:53:57.777 --> 11:54:03.362
如果我们向下滚动，我们可以确切地看到每一个操作码要花费多少。

8564
11:54:03.428 --> 11:54:11.800
举个例子，每次相加，它消耗3个气体，每次相乘，这是5个气体，减去3个气

8565
11:54:11.800 --> 11:54:20.412
体，我们有所有这些操作代码在函数中消耗不同数量的气体，这是一个样本契约。

8566
11:54:20.412 --> 11:54:24.828
如果我们做加法，每次相加都要消耗3汽油。

8567
11:54:24.828 --> 11:54:29.858
任何时候我们保存到内存中，都会消耗其他操作码的汽油。

8568
11:54:29.858 --> 11:54:33.566
这些操作码加起来显示了我们实际使用了多少汽油。

8569
11:54:33.566 --> 11:54:41.561
现在，让我们来看看这些操作码它们花费了多少钱510 3 3，余额是700。

8570
11:54:41.561 --> 11:54:45.252
所以要达到平衡需要大量的气体。

8571
11:54:45.252 --> 11:54:46.444
让我们继续。

8572
11:54:46.444 --> 11:54:52.028
获取一个帐户代码的侧面是大量的气体复制和帐户代码到内存中。

8573
11:54:52.028 --> 11:54:58.993
但是，我的天啊，这是什么呢?从储存到储存要花一吨

8574
11:54:58.993 --> 11:55:06.250
汽油，也就是2万汽油，从储存到装载要花800汽油。

8575
11:55:06.250 --> 11:55:14.261
这是两个最重要的操作码s load和s store, s store代表存储负载和存储存储。

8576
11:55:14.261 --> 11:55:19.234
只要其中一个操作码被触发，我们就得花上八万到两万。

8577
11:55:19.234 --> 11:55:23.615
你知道，这里有个大大的星号，因为这可能会改变很多。

8578
11:55:23.615 --> 11:55:28.348
但作为开发人员，我们每次使用存储都要消耗大量的汽油。

8579
11:55:28.348 --> 11:55:37.229
随时与我们合作在储存一些东西,我们想要男孩,这是花了我大量的气体和最好的惯例或确

8580
11:55:37.229 --> 11:55:46.110
保我们知道我们正在与一个存储变量,我们要花大量的气体是附加一个年代强调正确的在他

8581
11:55:46.110 --> 11:55:54.991
们面前代表存储正确所以我们说地址资助的数量将会是一个存储变量奇迹是一个存储变量。

8582
11:55:54.991 --> 11:55:57.479
Owner不会是一个存储变量。

8583
11:55:57.479 --> 11:55:58.229
它是不可变的。

8584
11:55:58.229 --> 11:56:01.515
不可变变量的最佳实践是前缀。

8585
11:56:01.515 --> 11:56:05.877
带有I下划线的常量值也不在存储中。

8586
11:56:05.877 --> 11:56:11.445
对于常值，我们希望它们保持上限，就像aggregator v3接口公共价格提要。

8587
11:56:11.445 --> 11:56:14.329
是的，你知道这是一个存储变量。

8588
11:56:14.329 --> 11:56:16.618
我们想在它后面加上一个S下划线。

8589
11:56:16.618 --> 11:56:22.074
我们要再做一点重构，我们适当地添加了这些来更新所有东西。

8590
11:56:22.074 --> 11:56:30.782
所以这里不是owner，而是I下划线owner，开发人员会读到这个，我们会说，这比普通变量便宜多了。

8591
11:56:30.782 --> 11:56:31.683
好的，太好了。

8592
11:56:31.683 --> 11:56:33.106
我要用这个。

8593
11:56:33.106 --> 11:56:35.481
我为我的修饰符下划线为owner。

8594
11:56:35.481 --> 11:56:36.042
太棒了。

8595
11:56:36.042 --> 11:56:40.534
主人在这里吗?在构造函数中。

8596
11:56:40.534 --> 11:56:43.286
我自己的下划线所有者是message。sender。

8597
11:56:43.286 --> 11:56:44.857
价格提要是一个存储变量。

8598
11:56:44.857 --> 11:56:53.357
作为开发者，我们应该在阅读时看到s下划线，然后说，好吧，我们花了很多汽油来存储这个。

8599
11:56:53.429 --> 11:56:53.866
完美的。

8600
11:56:53.866 --> 11:56:54.616
好了,好了。

8601
11:56:54.616 --> 11:56:55.678
让我们继续。

8602
11:56:55.678 --> 11:56:56.053
太好了。

8603
11:56:57.429 --> 11:56:58.095
业主。

8604
11:57:01.429 --> 11:57:08.135
在VS code中?如果你按Command F，或者Ctrl F，然后按下

8605
11:57:08.135 --> 11:57:14.842
这个向下的箭头，你就能找到并替换所有这些地址，用s下划线地址，替换为Mt。

8606
11:57:14.842 --> 11:57:16.014
像这样打。

8607
11:57:16.014 --> 11:57:19.806
因为我更新了一个，我得到了一个退格，没有。

8608
11:57:19.806 --> 11:57:21.707
现在这些都更新了。

8609
11:57:21.707 --> 11:57:24.300
让我们对资助者做同样的事情。

8610
11:57:24.300 --> 11:57:25.848
让我们到处更新。

8611
11:57:25.848 --> 11:57:27.784
它的出资人就是出资人。

8612
11:57:27.784 --> 11:57:29.332
我们可能在这里加倍了。

8613
11:57:29.430 --> 11:57:30.180
是的。

8614
11:57:30.430 --> 11:57:31.219
让我们撤销它。

8615
11:57:31.219 --> 11:57:33.166
我们已经更新了所有的AI所有者。

8616
11:57:33.430 --> 11:57:35.200
现在它更新了所有的价格信息。

8617
11:57:36.430 --> 11:57:38.365
饲料，我们将更新它与ES价格饲料。

8618
11:57:39.430 --> 11:57:40.414
在这里蜷成一团。

8619
11:57:40.414 --> 11:57:41.304
我们把它撤销。

8620
11:57:41.304 --> 11:57:41.866
好了,好了。

8621
11:57:42.430 --> 11:57:47.938
我们已经更新了这里的所有内容，我们可以向下滚动哦，不好意思，这里也翻倍了。

8622
11:57:47.938 --> 11:57:48.344
对不起。

8623
11:57:48.344 --> 11:57:52.724
我们可以绿色地浏览代码，我们对存储

8624
11:57:52.724 --> 11:57:57.362
进行读写的次数比我们需要的要多得多。

8625
11:57:57.430 --> 11:58:05.085
这就是我们要讲的取款功能，它似乎对读取和写入存储很可疑。

8626
11:58:05.085 --> 11:58:07.495
让我们看看我们在做什么。

8627
11:58:07.495 --> 11:58:12.160
首先，我可以看到我们在做一个for循环。

8628
11:58:12.160 --> 11:58:17.230
每次我们执行for循环时，我们只是不断地遍历所有这些代码。

8629
11:58:17.230 --> 11:58:23.259
每次我们在这里做一个比较选项时我们都会问，我们的funder index是

8630
11:58:23.259 --> 11:58:29.288
否小于sfunders。length?S funders。length，这

8631
11:58:29.288 --> 11:58:35.643
意味着我们的funders数组越长，我们从存储中读取的次数就越多，这非常昂贵。

8632
11:58:35.643 --> 11:58:44.591
我们还会调用这个，天哪，我们从存储中读取很多数据并保存到这个内存变量中，然后用它更新我们的存储变量。

8633
11:58:44.591 --> 11:58:44.784
哇。

8634
11:58:44.784 --> 11:58:52.912
我们从这里的存储中读取大量数据，我们从这里的存储中读取大量数据，然后我们必须重置我们的资助者数组，这是没有办法的。

8635
11:58:52.912 --> 11:58:59.881
这就是我们对存储的读写，我们还可以创建一个取款函数，这更便宜。

8636
11:58:59.881 --> 11:59:06.065
我们来创建一个函数，叫做cheap withdraw。

8637
11:59:06.065 --> 11:59:12.931
这将使用我们刚刚学到的知识，使提款更便宜，更省油。

8638
11:59:12.931 --> 11:59:15.366
我们将保持公共支付。

8639
11:59:15.366 --> 11:59:20.811
如果它是唯一的所有者，我们不会改变任何东西。

8640
11:59:20.811 --> 11:59:26.384
但对于这部分，我们能做什么呢，我们不想一直从存储器中读取。

8641
11:59:26.431 --> 11:59:29.618
我们不希望一直从存储中读取数据。

8642
11:59:29.618 --> 11:59:32.641
我们把读取的存储空间翻倍了。

8643
11:59:32.641 --> 11:59:37.544
相反，我们能做的是，我们可以一次性将整个数组读入

8644
11:59:37.544 --> 11:59:42.447
内存，然后从内存中读取而不是不断地从存储中读取。

8645
11:59:42.447 --> 11:59:45.269
这将使我们的生活更便宜。

8646
11:59:45.269 --> 11:59:48.559
我们可以创建一个地址数组。

8647
11:59:48.559 --> 11:59:52.481
内存资助者等于s下划线，资助者。

8648
11:59:52.481 --> 11:59:59.394
现在我们开始明白为什么对于函数中的数组和字符串，我们会问，这个内存是

8649
11:59:59.394 --> 12:00:06.511
存储空间吗?这是什么?我们告诉它，我们希望它是内存因为内存会便宜很多。

8650
12:00:06.511 --> 12:00:13.217
现在我们把它存到我们的资助者那里，哦，注意一下，映射不能在内存中。

8651
12:00:13.217 --> 12:00:13.610
对不起。

8652
12:00:13.610 --> 12:00:16.036
他们太奇怪太古怪了。

8653
12:00:16.036 --> 12:00:18.742
所以洪水现在不能让你这样做。

8654
12:00:18.742 --> 12:00:24.698
但现在我们已经将存储变量保存到内存变量中了，我们可以从这

8655
12:00:24.698 --> 12:00:30.655
个内存变量中读写，这非常非常便宜，然后在完成后更新存储。

8656
12:00:30.655 --> 12:00:36.486
我们现在要做的是为你写入v6，基金或指数等于0，

8657
12:00:36.486 --> 12:00:42.075
我们基本上会重写所有东西但只使用这个内存数组。

8658
12:00:42.075 --> 12:00:42.752
代替。

8659
12:00:42.752 --> 12:00:48.401
我们会说funder index小于funders。length而不是s

8660
12:00:48.401 --> 12:00:54.522
funders。length，然后我们会说funder index + +。

8661
12:00:54.522 --> 12:01:01.082
然后在这里，我们会做几乎完全相同的事情，除了我们会说地址funder =

8662
12:01:01.082 --> 12:01:09.466
funders，使用我们的内存数组，而不是s, funders有funder index。

8663
12:01:09.466 --> 12:01:14.156
然后我们会说s地址到资金。

8664
12:01:14.156 --> 12:01:16.449
资金等于零。

8665
12:01:16.449 --> 12:01:23.171
我们在这里重置我们的资助者映射，我们用内存变量代替，

8666
12:01:23.171 --> 12:01:30.153
然后我们要做同样的事情s下划线资助者=新地址数组为零。

8667
12:01:30.153 --> 12:01:36.309
然后我们会做同样的事情bool success，逗号=

8668
12:01:36.309 --> 12:01:40.185
sowner。callvalue,

8669
12:01:40.185 --> 12:01:49.307
address这个balance，我们什么都不发送，然后需要success。

8670
12:01:49.307 --> 12:01:57.989
就像那个，抱歉，是声呐上的艾奥娜现在我们有了这个功能我们认为它更便宜，让我们回到我们的测试。

8671
12:01:57.989 --> 12:02:03.333
让我们在这里运行同样的多重测试，但用的是更便宜的函数。

8672
12:02:03.333 --> 12:02:08.776
我知道复制粘贴可能有点麻烦，但我们还是复制整个测试。

8673
12:02:08.776 --> 12:02:13.582
把它粘贴到下面，把名字改一下改为cheap

8674
12:02:13.582 --> 12:02:18.618
withdraw, testing。完成。

8675
12:02:18.618 --> 12:02:24.168
在这里，在这个巨大的it中，我们要改变的是我们要

8676
12:02:24.168 --> 12:02:29.718
把提现变成更便宜的提现，剩下的测试是完全一样的。

8677
12:02:29.718 --> 12:02:38.120
有了这个，让我们看看如果我们成功地让提取函数更便宜用更便宜的提取，我们现在把终端分开。

8678
12:02:38.120 --> 12:02:43.718
我们做纱线，艺术帽测试，这将运行我们的气体估计器，因为它现在是启用的。

8679
12:02:43.718 --> 12:02:47.504
当然，我们所有的功能都被破坏了因为我们重新命名了所有的东西。

8680
12:02:47.504 --> 12:02:56.142
所以我们会快速替换出资人，改变出资人，询问出资人。

8681
12:02:56.142 --> 12:03:01.163
然后我们将把价格供给改成询问价格供给。

8682
12:03:01.163 --> 12:03:05.842
那我们有主人吗?我们没有主人，也没有任何地方。

8683
12:03:05.842 --> 12:03:07.653
我们需要改变这个。

8684
12:03:07.653 --> 12:03:09.347
地址到资助金额。

8685
12:03:09.347 --> 12:03:10.750
我们到这里来。

8686
12:03:10.750 --> 12:03:12.734
地址到资助金额。

8687
12:03:12.734 --> 12:03:13.765
adderstone。

8688
12:03:13.765 --> 12:03:14.717
资金充足。

8689
12:03:14.717 --> 12:03:18.004
我们还需要什么来改变价格?我们给资助者定价。

8690
12:03:18.004 --> 12:03:19.348
好吧，我想我们改变了一切。

8691
12:03:19.348 --> 12:03:20.651
好了，现在我们来试试这个测试。

8692
12:03:20.651 --> 12:03:22.032
纱线硬头试验。

8693
12:03:22.032 --> 12:03:23.268
好的，很好。

8694
12:03:23.268 --> 12:03:25.099
一切都过去了。

8695
12:03:25.099 --> 12:03:28.908
我们进行了更便宜的提取测试。

8696
12:03:28.908 --> 12:03:35.124
现在，如果我们看这里的气体输出，我们的气体报告，缩小一点，我们可

8697
12:03:35.124 --> 12:03:41.536
以看到更便宜的提取和提取之间的区别，我们看到了一些非常有趣的事情。

8698
12:03:41.536 --> 12:03:47.504
这里我们看到，平均来说，我们的廉价提款比我们的常规提款要贵。

8699
12:03:47.504 --> 12:03:55.183
这样做的原因是，如果我们的测试是更便宜的提取，我们只测试了多重提取。

8700
12:03:55.183 --> 12:03:57.966
所以我们不得不重新设置更多的账户。

8701
12:03:57.966 --> 12:04:01.299
但严格来说，这也是它的最大值。

8702
12:04:01.433 --> 12:04:08.814
如果我们比较更便宜的提款的最大值，提款的最大值，看起来更便宜的提款确实更便宜。

8703
12:04:08.814 --> 12:04:17.576
如果我们去到我们的硬帽。配置，我们添加我们的API键回来，我们甚至可以做的是在我们的测试，我们可以从

8704
12:04:17.576 --> 12:04:25.286
一个单一的资金撤回eath，复制，粘贴它，只是改变撤回为更便宜的撤回，重新运行它与关键，

8705
12:04:25.286 --> 12:04:35.100
现在做yarn Hardhead测试，我们可以看到确切地多少美元，我们将节省如果我们运行这个在Matic区块链。

8706
12:04:35.100 --> 12:04:39.434
现在我们回去，重新打开气体报告。

8707
12:04:39.434 --> 12:04:43.869
我们可以看到，在最小值的情况下，更便宜的取款实际上会更贵一点。

8708
12:04:43.869 --> 12:04:52.261
这实际上是有道理的，因为如果我们看资金，如果我们只需要在只有一个资助者的情况下取款，那么这个循环只运行一次。

8709
12:04:52.261 --> 12:04:57.637
我们更便宜的提款也会做同样的事情但它会有额外的东西，把它们

8710
12:04:57.637 --> 12:05:03.014
都装进去，我们看到储蓄，在我们的合同中，我们的资助者越多。

8711
12:05:03.014 --> 12:05:06.991
如此自动，我们可以看到我们几乎没有保存任何东西。

8712
12:05:06.991 --> 12:05:12.719
但如果我再修改一次，再运行一次测试。

8713
12:05:12.719 --> 12:05:16.671
现在我们可以看到人们节省了几分钱。

8714
12:05:16.671 --> 12:05:20.950
这就是我们如何开始优化我们的合同，使其越来越便宜。

8715
12:05:20.950 --> 12:05:22.571
这两美分只是平均水平。

8716
12:05:22.571 --> 12:05:28.466
它甚至没有比较最大值和最大值，最大值的气体量比平均值多很多。

8717
12:05:28.466 --> 12:05:33.885
我们刚学了一大堆东西。

8718
12:05:33.885 --> 12:05:39.926
接下来的部分可能会让你们有些人抓狂因为我们要再重构一次代码如果你不想重构的话

8719
12:05:39.926 --> 12:05:45.967
你想把所有的测试都留给s下划线你完全可以但是留给其他使用我们应用程序的用户。

8720
12:05:45.967 --> 12:05:53.339
处理s下划线有点恶心实际上会让我们的代码对使用它的人来说更混乱。

8721
12:05:53.339 --> 12:05:57.202
另外，现在所有的状态函数都是公共的。

8722
12:05:57.202 --> 12:06:01.193
实际上内部变量和私有变量也更便宜。

8723
12:06:01.193 --> 12:06:07.181
我们不需要让每一个变量都是公共的，因为任何人都可以从链上读取它们。

8724
12:06:07.181 --> 12:06:13.699
我们还会做一个重构我们会设置这些的可见性为private还是internal，基于它

8725
12:06:13.699 --> 12:06:20.373
们是否需要为private或internal，然后我们会在函数的底部创建getter。

8726
12:06:20.435 --> 12:06:26.249
最低美元，我们可以公开这个因为我们想让其他人知道我们合同的最低美元是多

8727
12:06:26.249 --> 12:06:32.231
少，不需要经过仓库，我们的合同的所有者对于其他人或其他合同来说并不重要。

8728
12:06:32.231 --> 12:06:39.265
我们可以把这个设为私有，然后在底部的函数get owner。

8729
12:06:39.265 --> 12:06:46.801
这是一个公共视图，返回我的所有者，把地

8730
12:06:46.801 --> 12:06:54.735
址变成资助者，因为资助者也可以是私人的。

8731
12:06:54.735 --> 12:07:02.361
在底部，我们会说function, get funder，然后我们会传递一

8732
12:07:02.361 --> 12:07:09.163
个un236 index, public U, turns，地址，

8733
12:07:09.163 --> 12:07:18.028
return作为index的资助者，Mt funding的地址也可以是private。

8734
12:07:18.028 --> 12:07:25.145
在底部，我们会创建函数，获取地址和资金。

8735
12:07:25.145 --> 12:07:29.607
这将在公共视图返回下

8736
12:07:29.607 --> 12:07:34.516
取一个地址，你到56。

8737
12:07:34.516 --> 12:07:43.075
我们将会返还投资人的资金这个做了，这个做了，这个做了。

8738
12:07:43.075 --> 12:07:46.774
然后是价格供给，函数得到价格供给。

8739
12:07:46.774 --> 12:07:48.977
这也将是公共视图，

8740
12:07:48.977 --> 12:07:56.813
它返回三个界面的汇总tour它将返回因此，我将选择价格feed。

8741
12:07:56.813 --> 12:07:57.255
哦,好的。

8742
12:07:57.255 --> 12:08:02.403
我们这样做的原因是我们想让s有下划线这样我们作为开发人员

8743
12:08:02.403 --> 12:08:07.736
就能知道，这是一个存储变量，我想在如何与它交互时非常小心。

8744
12:08:07.736 --> 12:08:12.078
但我们不希望与我们的代码交互的人不得不处理这些东西。

8745
12:08:12.078 --> 12:08:16.274
我们想给他们一个有意义的API，简单易读。

8746
12:08:16.274 --> 12:08:19.225
我们在底部添加这些getter函数来完成这个。

8747
12:08:19.225 --> 12:08:24.806
从长远来看，改变可见性也能节省一些汽油，因为我们会从私有变量或

8748
12:08:24.806 --> 12:08:30.388
内部变量调用，这是更便宜的汽油，当然，我们需要再升级一次测试。

8749
12:08:30.388 --> 12:08:34.805
就像我说的，如果你想只留下S下划线，那完全没问题。

8750
12:08:34.805 --> 12:08:41.417
因此，s下划线价格提要现在将被替换为获取价格提要，

8751
12:08:41.417 --> 12:08:48.029
s下划线资金金额现在将被替换为获取地址到资金金额。

8752
12:08:48.029 --> 12:08:54.569
现在要改变SW，强调资助者，以获得资助者。

8753
12:08:54.569 --> 12:09:00.029
我们要改变艾奥娜，她们脑子里没有别的东西，我们不需要改变她们。

8754
12:09:00.029 --> 12:09:01.029
我想这就是一切。

8755
12:09:01.029 --> 12:09:06.151
我们只找s下划线，我们看不到，I下划线，我们也看不到。

8756
12:09:06.151 --> 12:09:11.156
让我们再运行一次测试，以确保重构正确。

8757
12:09:11.156 --> 12:09:13.911
看起来我们做得很棒。

8758
12:09:13.911 --> 12:09:16.148
好了，我们刚学到了很多。

8759
12:09:16.148 --> 12:09:18.161
我们对代码进行了大量的重构。

8760
12:09:18.161 --> 12:09:21.469
这里的一切看起来都非常非常好。

8761
12:09:21.469 --> 12:09:24.049
我们可以再做一次气体优化。

8762
12:09:24.049 --> 12:09:32.647
还有一个针对错误的优化就是我们可以将所有的需求更新为。

8763
12:09:32.647 --> 12:09:37.772
因为如果没有require，我们实际上是在存储这个巨大的字符

8764
12:09:37.772 --> 12:09:42.898
串，这个巨大的文本数组在chain上，这些错误码就便宜多了。

8765
12:09:42.898 --> 12:09:43.667
但这是可选的。

8766
12:09:43.667 --> 12:09:44.643
如果你想这么做的话。

8767
12:09:44.643 --> 12:09:49.826
我们这样做的全部原因是我们要通过样式指南来更新这里的东西。

8768
12:09:49.826 --> 12:09:54.971
我们有public internal private，底部是

8769
12:09:54.971 --> 12:10:00.288
我们的view斜杠纯函数它们就是我们刚添加的这些getter。

8770
12:10:00.437 --> 12:10:02.130
现在我们的样式看起来很好。

8771
12:10:03.437 --> 12:10:05.402
气体，我们已经学了很多关于储存的知识。

8772
12:10:06.437 --> 12:10:12.216
让我们快速回顾一下我们刚刚学过的东西因为我们已经讲了很多了。

8773
12:10:12.216 --> 12:10:15.737
就像我说的，这是这门课比较难的部分。

8774
12:10:15.737 --> 12:10:22.237
我们希望跨契约执行和事务持久化的任何可变变量。

8775
12:10:22.237 --> 12:10:27.690
我们保存到一个叫做storage的大数组中这个数组的索引是从0开始的。

8776
12:10:27.690 --> 12:10:34.211
第一个变量契约中的第一个值被存储为0。

8777
12:10:34.211 --> 12:10:38.008
下一个被存储为1，以此类推。

8778
12:10:38.008 --> 12:10:46.723
动态数组和映射以及其他动态大小的对象使用特定的哈希函数，您可以在文档中找到这

8779
12:10:46.723 --> 12:10:55.438
些动态数据结构的元素的位置，以确定内存变量、常量变量和不可变变量不在存储中。

8780
12:10:55.438 --> 12:11:02.178
谈论存储如此重要的一个主要原因是因为从存储中加载的

8781
12:11:02.178 --> 12:11:08.919
操作码从存储中读取和写入到存储的操作码都非常耗油。

8782
12:11:08.919 --> 12:11:13.771
所以在任何地方，我们都想减少从存储中读取和加载的数量。

8783
12:11:13.771 --> 12:11:19.904
这是最简单的省油方法之一，可以优化我们的代码，使其省油。

8784
12:11:19.904 --> 12:11:23.067
就像我说的，有些气体的东西可能有点棘手，有点令人困惑。

8785
12:11:23.067 --> 12:11:25.341
所以如果你不能马上明白，也没关系。

8786
12:11:25.438 --> 12:11:26.295
完全没问题。

8787
12:11:28.438 --> 12:11:35.861
比如，他在说什么?就像我说的，这是一些更高级的东西它会出现的，你对坚固性做的越多，你对这里的一切做的越多。

8788
12:11:35.861 --> 12:11:37.126
所以不要让它给你带来压力。

8789
12:11:37.126 --> 12:11:38.994
不要让它阻止你继续前进。

8790
12:11:38.994 --> 12:11:41.995
你在这里做得很好。

8791
12:11:41.995 --> 12:11:42.683
到目前为止。

8792
12:11:42.683 --> 12:11:46.647
我们已经编写了一些非常好的单元测试。

8793
12:11:46.647 --> 12:11:49.469
现在让我们编写一些分段测试。

8794
12:11:49.469 --> 12:11:53.728
这些是我们可以在实际的测试网上使用的测试。

8795
12:11:53.728 --> 12:12:01.871
这个测试是在我们部署了一些代码后运行的只是为了看看一切是否都按照我们想要的方式运行。

8796
12:12:01.871 --> 12:12:03.882
我们来创建一个新文件。

8797
12:12:03.882 --> 12:12:06.326
我们就叫它资助我吧。

8798
12:12:06.326 --> 12:12:09.659
网点分期网点试验，网点j s。

8799
12:12:09.659 --> 12:12:13.628
它看起来和我们刚才在单元测试中做的很像。

8800
12:12:13.628 --> 12:12:15.929
我们假设这是在一个测试网上。

8801
12:12:15.929 --> 12:12:21.929
这些是我们要运行的测试，就在我们把它部署到主网之前，这是你们开发

8802
12:12:21.929 --> 12:12:27.930
旅程的最后一步，我们要确保在实际的测试网上一切都大致正确地运行。

8803
12:12:27.930 --> 12:12:34.742
我们要做的是我们要做同样的事情描述，资助我，我要快速地过一遍这些测试，因为我们

8804
12:12:34.742 --> 12:12:41.554
之前基本上写过这种类型的测试，所以我们会说，在每个之前，它将是一个async。

8805
12:12:41.554 --> 12:12:42.419
函数。

8806
12:12:42.419 --> 12:12:46.403
我们将做与单元测试相同的事情。

8807
12:12:46.403 --> 12:12:50.860
我们会有一个Funmi变量，我们会有我们的let

8808
12:12:50.860 --> 12:12:56.989
Deployer，我们会有我们的常量send value =醚。

8809
12:12:56.989 --> 12:12:57.739
跑龙套。

8810
12:12:57.739 --> 12:13:03.596
Rs的醚(1)在这里，我们要做const。

8811
12:13:03.596 --> 12:13:05.262
获取命名帐户。

8812
12:13:05.439 --> 12:13:11.772
= require hardhats，我们会说，deployer =

8813
12:13:11.772 --> 12:13:18.105
weight，获取命名帐户，我们会把它括起来，点deployer。

8814
12:13:18.105 --> 12:13:25.216
我们会说fun me = await醚。get contract。

8815
12:13:25.439 --> 12:13:31.742
我，逗号，我们将把它连接到部署器，我们不会部署这个，我们不会像单元测试中

8816
12:13:31.742 --> 12:13:38.045
那样做任何fixture，因为在分段测试中，我们假设它已经部署在这里了。

8817
12:13:38.045 --> 12:13:43.867
我们也不需要模拟因为在一个阶段中，我们假设我们在一个测试网络上，现在我们

8818
12:13:43.867 --> 12:13:49.852
可以包装整个东西来确保我们在一个测试网络上通过使用我们的helper配置。

8819
12:13:49.852 --> 12:13:58.032
在寻找我们的开发链时，我们可以说我们只在开发链上运行我们的description位。

8820
12:13:58.032 --> 12:14:01.117
首先，我们说const。

8821
12:14:01.117 --> 12:14:08.891
开发链等于需求，我们会把那个助手配置拉进来。

8822
12:14:08.891 --> 12:14:14.507
我们会说，development chains。includes network。name。

8823
12:14:14.507 --> 12:14:20.932
我们会说if开发者链包含network。name，我们会跳过实际上我们可

8824
12:14:20.932 --> 12:14:27.358
以用这个跳过，我们会用一个叫做三元运算符的东西它基本上就像一个if语句。

8825
12:14:27.358 --> 12:14:29.790
你可以把它看作F的一种特殊类型。

8826
12:14:29.790 --> 12:14:32.832
我有一个链接到这个和GitHub回购与这门课相关。

8827
12:14:32.832 --> 12:14:36.725
下面是一些JavaScript文档，展示了它的实际应用。

8828
12:14:36.725 --> 12:14:39.797
你说，好，返回是成员。

8829
12:14:39.797 --> 12:14:43.225
如果是真的，就给2美元。

8830
12:14:43.440 --> 12:14:45.100
否则有一个B $10。

8831
12:14:45.100 --> 12:14:47.062
差不多就是这样了。

8832
12:14:47.440 --> 12:14:52.833
另一种思考方式是，你说，让变量等于真，然

8833
12:14:52.833 --> 12:14:58.226
后我们可以说，让某个var等于变量问题。

8834
12:14:58.226 --> 12:15:02.455
是吗?还是没有?有些var最终会是Yes。

8835
12:15:02.455 --> 12:15:04.472
因为变量为真。

8836
12:15:04.472 --> 12:15:07.593
如果variable为false，那么一些var将为no。

8837
12:15:07.593 --> 12:15:14.159
字面意思是，如果变量，那么某个var等于yes。

8838
12:15:14.159 --> 12:15:14.773
其他的事情。

8839
12:15:14.773 --> 12:15:20.423
var等于不，这些直线实际上是完全一样的。

8840
12:15:20.423 --> 12:15:22.079
这个更简洁一点。

8841
12:15:22.079 --> 12:15:22.915
真的是这样。

8842
12:15:22.915 --> 12:15:24.588
这就是这个算子的作用。

8843
12:15:24.588 --> 12:15:27.524
我们会说开发链包括network。name。

8844
12:15:27.524 --> 12:15:34.725
如果我们的网络是一个发展链，我们也会从硬帽和醚中引入网络。

8845
12:15:34.725 --> 12:15:39.882
然后我们会做被跳过的描述这告诉我们的测试跳过这

8846
12:15:39.882 --> 12:15:45.265
整个描述，然后我们会在这里放这个小冒号然后保存。

8847
12:15:45.265 --> 12:15:53.321
现在我们只会在不在开发链上的情况下运行这个，我们想使用完全相同的语法，我们会在这里进行

8848
12:15:53.321 --> 12:16:01.566
单元测试，我们会做完全相同的事情，我们会粘贴它会让它相反通过在这里打一个小结，插入冒号。

8849
12:16:01.566 --> 12:16:07.801
所以现在，我们的单元测试只在开发链上运行在我们的分期测试中，只在测试网络上运行。

8850
12:16:07.801 --> 12:16:08.325
完美的。

8851
12:16:08.325 --> 12:16:14.012
这就是我们想要的，允许人们投资，拥有和提取。

8852
12:16:14.012 --> 12:16:19.638
这当然是一个async函数，我们可以让它很健壮，但我们

8853
12:16:19.638 --> 12:16:25.474
只说await, fundme。fund将会发送一个值。

8854
12:16:25.474 --> 12:16:30.155
然后我们说我身上的重量。撤回。

8855
12:16:30.155 --> 12:16:33.583
CERT等于require try。

8856
12:16:33.583 --> 12:16:38.426
现在我们来做一个蹩脚的最后一个，我们说const ending

8857
12:16:38.426 --> 12:16:48.114
balance等于一个weight on me。provider。get balance, fundme。address。

8858
12:16:48.114 --> 12:16:53.118
然后我们说assert。= ending balance。

8859
12:16:53.118 --> 12:16:57.677
to string，逗号0作为字符串，我们只会在测试网

8860
12:16:57.677 --> 12:17:02.405
络上运行这个，我只会再运行一次，向你们展示它的实际操作。

8861
12:17:02.405 --> 12:17:07.273
请再次跳过这部分，因为我们将使用一个测试网，我将

8862
12:17:07.273 --> 12:17:12.141
运行纱线，硬帽部署dash测试网Rinkeby。

8863
12:17:12.141 --> 12:17:16.241
它将贯穿我们的部署。

8864
12:17:16.241 --> 12:17:23.783
在它全部部署之后，我们将运行我们的阶段测试，以确保在真实测试网络上，即使有价格提要，一切都能工作，

8865
12:17:23.783 --> 12:17:33.942
我需要执行const development chains = require。。斜杠。斜杠helper heart config。

8866
12:17:33.942 --> 12:17:40.924
现在对于run yarn, hard hat测试，我们将看到我们的单元测试被运行。

8867
12:17:40.924 --> 12:17:49.312
但如果我们用纱线来测试Rinkeby的dash网络，我们不会进行9个测试，我们只会进行单独的阶段测试。

8868
12:17:49.312 --> 12:17:55.526
当然，这要慢得多，因为我们是在一个测试网上。

8869
12:17:55.526 --> 12:18:03.651
Net会写所有这些测试，我们可以写一些脚本。

8870
12:18:03.651 --> 12:18:10.153
然后我们会把这个推到GitHub上让它成为我们的第一个智能合约GitHub仓

8871
12:18:10.153 --> 12:18:13.746
库，当涉及到区块链时，当涉及到智能合约时，

8872
12:18:13.746 --> 12:18:23.330
与社区互动与开源互动作为GitHub的一部分，或git实验室或任何你正在使用的git托管服务在这里是成功的关键。

8873
12:18:23.330 --> 12:18:24.775
让我们来写脚本。

8874
12:18:24.775 --> 12:18:28.114
然后我们上传到GitHub开始建立我们的投资组合。

8875
12:18:28.114 --> 12:18:33.196
首先，我们要创建一个脚本来与我们的代码fund。js交互。

8876
12:18:33.196 --> 12:18:36.242
这和我们的测试非常相似。

8877
12:18:36.242 --> 12:18:37.652
这样，在未来。

8878
12:18:37.652 --> 12:18:46.323
如果我们想要快速地为我们的合同提供资金，我们可以运行这个，我们可以做到，我们会做我们一直在做的相同的事情，我们会做一个async函数main。

8879
12:18:46.323 --> 12:18:51.204
下面，我要复制粘贴这个因为我们会经常用到复制粘贴。

8880
12:18:51.204 --> 12:18:54.156
我们把这个语法粘贴到这里。

8881
12:18:54.156 --> 12:18:58.308
所以让我们写一个脚本，让我们能够为我们的合同提供资金。

8882
12:18:58.308 --> 12:19:04.846
首先，我们需要const get命名帐户就像我们在测试中一样，

8883
12:19:04.846 --> 12:19:13.073
equals require arhat我们会说const Deployer。

8884
12:19:13.073 --> 12:19:18.276
等价者等待着尚未命名的账户，就像这样。

8885
12:19:18.276 --> 12:19:26.693
然后我们说const fund me = await ethers。get contract。

8886
12:19:26.693 --> 12:19:29.146
从资金通信部署。

8887
12:19:29.146 --> 12:19:37.710
和我们的测试几乎完全一样，然后我们会做一个console。log funding contract然后

8888
12:19:37.710 --> 12:19:46.443
我们会做const transaction response = await funding。fund。

8889
12:19:46.443 --> 12:19:51.146
对于这个值，我们会用ethers。

8890
12:19:51.146 --> 12:19:55.849
utils来解析ether (0)

8891
12:19:55.849 --> 12:20:00.943
1或者别的什么，不管你想做什么，我们当然需要导入醚，看起来我们已经有了。

8892
12:20:00.943 --> 12:20:06.026
我们写await transaction response。wait for one transaction。

8893
12:20:06.026 --> 12:20:10.914
然后我们会做console。log funding，

8894
12:20:10.914 --> 12:20:19.376
我们可以运行yarn运行这个小脚本，RT head node运行一个本地节点部署所有契约。

8895
12:20:19.376 --> 12:20:24.311
我们将通过运行yarn，硬帽运行脚本基金。j s破折号

8896
12:20:24.311 --> 12:20:29.246
网络localhost来看看我们的脚本看起来是否ok。

8897
12:20:29.246 --> 12:20:32.278
而且看起来资金不错。

8898
12:20:32.443 --> 12:20:36.765
现在我们写一个提取脚本提取那个js。

8899
12:20:37.443 --> 12:20:43.120
甚至可以让我们的本地主机节点继续运行，因为我们将撤回我们刚刚资助它的资金。

8900
12:20:43.120 --> 12:20:45.720
我们要做完全相同的设置。

8901
12:20:45.720 --> 12:20:54.027
我们甚至可以复制这个主位到我们的withdraw，顶部会做async函数main会说const

8902
12:20:54.027 --> 12:21:03.395
deployer = await，得到命名帐户，哇，我按下回车，我的VS code自动导入了它，这很好。

8903
12:21:03.444 --> 12:21:08.116
也许你的也会，也许不会如果它不会，你只需要把它写出来或者从另一个复制粘贴。

8904
12:21:08.116 --> 12:21:13.824
然后我们会做cars Funmi = await醚。get contract on me，当然。

8905
12:21:13.824 --> 12:21:16.300
这是完全一样的。

8906
12:21:16.300 --> 12:21:21.791
现在我们要写console。log funding data。我们说const

8907
12:21:21.791 --> 12:21:27.845
transaction response = await on v。withdraw,

8908
12:21:27.845 --> 12:21:35.027
await transaction response。wait 1，然后是console。log。

8909
12:21:35.027 --> 12:21:36.377
明白了吗?回来。

8910
12:21:36.377 --> 12:21:41.745
我们可以通过运行yarn，硬打运行脚本，提取破折号网

8911
12:21:41.745 --> 12:21:47.321
络localhost来测试这个，我们会看到它是否有效。

8912
12:21:47.321 --> 12:21:50.391
很好，我们的剧本开始运作了。

8913
12:21:50.391 --> 12:21:53.777
Fantastic以惊人的速度写出了两个剧本。

8914
12:21:53.777 --> 12:22:00.088
现在我们有了一种方法，可以通过脚本轻松地与代码和契约进行交互。

8915
12:22:00.088 --> 12:22:09.056
在我们把这些很棒的代码推到GitHub之前我还想讲一点。JSON。

8916
12:22:09.056 --> 12:22:14.962
我之前已经向您展示了一些这方面的内容，但是我们可以添加这个脚本部分，使

8917
12:22:14.962 --> 12:22:21.037
我们的工作变得容易得多，并将所有这些长时间的测试压缩为一个yarn脚本。

8918
12:22:21.037 --> 12:22:26.298
通常，在common package。JSON中，你会看到

8919
12:22:26.298 --> 12:22:31.559
一个列表供人们查看，然后自动运行，其中最常见的是test。

8920
12:22:31.559 --> 12:22:35.335
为了进行测试，我们要做纱线，硬帽测试。

8921
12:22:35.335 --> 12:22:42.805
所以现在不是运行纱线，硬头测试，有人可以直接来到你的包，一旦它被保存，只运行纱线测试。

8922
12:22:42.805 --> 12:22:49.953
这将从你的脚本部分获取这个测试，它将运行yarn heart at test和Bada bing, Bada boom，好的，酷。

8923
12:22:49.953 --> 12:22:55.916
我们还想在这里做什么呢?我们可能需要一个测试阶段来运

8924
12:22:55.916 --> 12:23:01.880
行硬头纱测试dash dash和Rinkeby网络。

8925
12:23:01.880 --> 12:23:03.208
我不打算运行它。

8926
12:23:03.208 --> 12:23:07.945
但这可能是我们想要的东西，我们可能需要一些毛线。

8927
12:23:07.945 --> 12:23:11.087
我们给你们简单展示了一下绒毛的事情。

8928
12:23:11.087 --> 12:23:16.361
所以我们会有一个纱线线头，它会运行纱线，鞋底提示。

8929
12:23:16.445 --> 12:23:20.122
然后我们就有了合约文件夹。

8930
12:23:20.445 --> 12:23:22.445
任何从灵魂开始的东西。

8931
12:23:24.445 --> 12:23:32.195
它会运行灵魂提示，这里所有的代码它会在这里给我们一些警告，我们几乎都可以忽略。

8932
12:23:32.195 --> 12:23:39.887
梭伦实际上有一个自动修复，我们可以添加自动修复，通过做纱线修复，我们会说纱线。

8933
12:23:39.887 --> 12:23:43.315
提示一下，合同一开始就砍了。

8934
12:23:43.315 --> 12:23:45.831
我们用破折号固定。

8935
12:23:45.831 --> 12:23:52.169
现在我们运行纱线，绒线修复，它会自动修复，没有什么可以自动修复的。

8936
12:23:52.169 --> 12:23:53.159
所以什么都没发生。

8937
12:23:53.159 --> 12:23:54.587
但无论如何，拥有它是件好事。

8938
12:23:54.587 --> 12:23:59.159
然后我们可以使用我们的formatter，我们会格式化我们的代码格式，

8939
12:23:59.159 --> 12:24:05.430
它会做yarn, pretty, dash, write to，我们会用一个句点来做所有的事情。

8940
12:24:05.430 --> 12:24:07.612
然后我们可以做纱线格式。

8941
12:24:07.612 --> 12:24:13.833
它会解决我们所有的，它会解决我们的一切，这很好。

8942
12:24:13.833 --> 12:24:16.547
然后我们就能有保险了。

8943
12:24:16.547 --> 12:24:25.446
通过运行纱线的硬帽覆盖，现在我们可以运行纱线的覆盖，会给我们这个美妙的小覆盖报告。

8944
12:24:25.446 --> 12:24:25.979
太棒了。

8945
12:24:25.979 --> 12:24:28.245
所以我们的包装看起来很棒。

8946
12:24:28.446 --> 12:24:30.463
也许我们还会讲到package json。

8947
12:24:31.446 --> 12:24:31.890
的名字。

8948
12:24:31.890 --> 12:24:34.667
我们称它为安全帽。

8949
12:24:38.446 --> 12:24:39.571
就是你的名字。

8950
12:24:41.446 --> 12:24:45.334
我们会在这里给出一个版本。

8951
12:24:45.334 --> 12:24:45.889
为1。

8952
12:24:45.889 --> 12:24:47.666
0点哦，糟糕。

8953
12:24:48.446 --> 12:24:51.253
让我们用图标代替空格。

8954
12:24:53.446 --> 12:24:54.906
我们不使用ES lint。

8955
12:24:57.446 --> 12:24:59.913
我们可以删除纱线点锁，重新安装。

8956
12:25:00.446 --> 12:25:00.867
无论什么。

8957
12:25:00.867 --> 12:25:02.972
我们没有自述，不过没关系。

8958
12:25:03.446 --> 12:25:11.736
想回去，就像我说的，去看看最好的自述模板，去更新你的自述模板，让它们看起来像这样棒，你也可以这么做。

8959
12:25:11.736 --> 12:25:16.334
但除此之外，我们还有一个很棒的代码回购。

8960
12:25:16.334 --> 12:25:23.429
我们要怎么处理它?我们在GitHub上花了太多时间，我们一直在研究所有这些好的中心。

8961
12:25:23.429 --> 12:25:28.612
是时候加入GitHub和我们自己的第一个存储库了。

8962
12:25:28.612 --> 12:25:34.296
让我们继续，让我们在第七课完整区块链固体课程中实现它，是的，有一个链

8963
12:25:34.296 --> 12:25:39.981
接到这个GitHub快速入门，我们将遵循它来建立我们的第一个存储库。

8964
12:25:39.981 --> 12:25:47.836
这将是你开始构建作品集的时刻，而GitHub对你的开发之旅至关重要。

8965
12:25:47.836 --> 12:25:55.007
这将是你的门户网站，你会在这里说，嘿，看看我参与的所有很酷的产品，我正在与之合作，我正在参与其中。

8966
12:25:55.007 --> 12:26:00.603
如果你之前已经做过GitHub，我强烈建议你仍然把它推到GitHub，作为你做过的证明。

8967
12:26:00.603 --> 12:26:04.161
然后你也可以在推特上对我说，嘿，看看我已经走了多远。

8968
12:26:04.161 --> 12:26:10.369
看看我都做了什么，看看我学习智能合约有多棒，现在要兴奋得不得了，这个快速入门将

8969
12:26:10.369 --> 12:26:16.577
带你创建一个存储库，创建一个分支，教授所有这些东西，我们将遵循GitHub文档

8970
12:26:16.577 --> 12:26:22.947
中的说明，向GitHub添加本地托管代码，我们已经有了一个项目，我们正在推进它。

8971
12:26:22.947 --> 12:26:30.275
因为Windows用户用的是WsL，你只需要遵循Mac或Linux的说明，我们要做的

8972
12:26:30.275 --> 12:26:37.603
第一件事是在你的GitHub配置文件中，或者在你的GitHub登录中，我们会点击这个

8973
12:26:37.603 --> 12:26:44.756
小加号，点击新存储库，你想叫它什么都行，我们叫它hard hat, fund me

8974
12:26:44.756 --> 12:26:52.259
b code camp，你可以写个描述，从编码营学习，Patrick，关于智能合约。

8975
12:26:52.447 --> 12:26:56.990
我们会把它公开，因为我们想让其他人看到你很出色，学习智能合约。

8976
12:26:56.990 --> 12:27:00.266
我们让它保持空白，然后点击创建存储库。

8977
12:27:00.266 --> 12:27:02.528
现在，这是我们的公共代码库。

8978
12:27:02.528 --> 12:27:08.184
这是我们的第一个，如果你已经做过这些，这将是你的第一个智能合约。

8979
12:27:08.184 --> 12:27:15.505
它甚至还有一些说明，教我们如何从命令行创建一个新的存储库，你可以

8980
12:27:15.505 --> 12:27:23.056
按照这个来做，或者像这样我们要做的第一件事是初始化一个git分支。

8981
12:27:23.056 --> 12:27:26.395
从你应该已经安装Git的时候开始。

8982
12:27:26.448 --> 12:27:29.930
记住，你可以通过运行git的破折号版本来检查。

8983
12:27:29.930 --> 12:27:33.555
Git和GitHub有点不同，Git被称为版本控制。

8984
12:27:33.555 --> 12:27:39.706
它允许我们对代码进行更改，但保留所有代码更改的历史。

8985
12:27:39.706 --> 12:27:44.585
GitHub是一个我们可以推送所有这些更改并跟踪所有代码的地方。

8986
12:27:44.585 --> 12:27:48.026
我们要做的第一件事是创建一个新的分支。

8987
12:27:48.026 --> 12:27:51.743
我不会太深入地解释Git以及如何使用Git。

8988
12:27:51.743 --> 12:27:57.792
但是如果你想了解Git Free Code Camp，当然有一个针对初学者的Git和GitHub视频。

8989
12:27:57.792 --> 12:28:05.781
我们会用gitinitdash bmain创建这个新分支，现在你的Visual Studio代码会自动开始格式化一些东西。

8990
12:28:05.781 --> 12:28:06.747
如果有，那就太好了。

8991
12:28:06.747 --> 12:28:08.431
如果没有，也不用担心。

8992
12:28:08.431 --> 12:28:15.438
但在左边你会看到有些东西是绿色的，有些东西是灰色的，打开那个。Git ignore，你会

8993
12:28:15.438 --> 12:28:22.605
看到所有灰色的东西都是我们在这个。Git ignore里的东西这是有意的，这是我们想要的。

8994
12:28:22.605 --> 12:28:27.512
这只是一些突出显示，嘿，这些绿色的东西是你在GitHub上使用的。

8995
12:28:27.512 --> 12:28:30.227
这些灰色的东西是你没有和GitHub合作的东西。

8996
12:28:30.227 --> 12:28:31.040
这就是我们想要的。

8997
12:28:31.040 --> 12:28:37.422
你不需要推送工件、现金、覆盖率或节点模块，人们可以在自己的机器上安装和

8998
12:28:37.422 --> 12:28:43.988
编译，如果我们使用Dotty和V，我们肯定不想推送我们的Dotty和V。

8999
12:28:43.988 --> 12:28:48.601
我们不需要推高coverage。JSON，其他的我们都需要。

9000
12:28:48.601 --> 12:28:57.038
接下来，在初始化主分支之后，你现在应该能在终端上运行gitstatus看到这个巨大的红色

9001
12:28:57.038 --> 12:29:01.640
输出所有这些没有被跟踪的东西，我们没有任何提交，

9002
12:29:01.640 --> 12:29:13.913
我们现在能做的是我们可以用gitaddperiod标记所有代码，然后用gitcommit提交，我们会一次运行一个而不是一起运行。

9003
12:29:13.913 --> 12:29:19.112
在运行git add之前，我也会将部署添加到这个列表中，因为GitHub并不需要

9004
12:29:19.112 --> 12:29:24.311
知道我所做的所有不同的部署，特别是当我对本地主机进行大量部署时，它们不需要知道。

9005
12:29:24.311 --> 12:29:29.370
我们将把它添加到，然后运行gitadd。

9006
12:29:29.449 --> 12:29:34.126
如果我们做一个git状态，我们可以看到我们所

9007
12:29:34.126 --> 12:29:39.017
有的代码都被分阶段提交了作为代码历史的一部分。

9008
12:29:39.017 --> 12:29:46.367
然后快速浏览一下这些文件确保你的。E和V文件不在这里。

9009
12:29:46.449 --> 12:29:51.077
现在我们要运行gitcommit dash m然后是这个提交的消息，

9010
12:29:51.077 --> 12:29:58.563
我们会运行gitcommit dash m，我们可以说，初始提交，或者在这个消息中你想要的任何东西，first

9011
12:29:58.563 --> 12:30:05.234
commit, initial commit，管它呢，它会说，创建模式，等等等等，所有这些文件。

9012
12:30:05.234 --> 12:30:09.855
如果我们调用gitstatus，它在branch main上是空白的，没什么要提交。

9013
12:30:09.855 --> 12:30:11.754
然后你可能会得到这样的结果。

9014
12:30:11.754 --> 12:30:15.489
如果您在自动添加您的姓名和电子邮件之前从未使用过Git。

9015
12:30:15.489 --> 12:30:17.563
我们有点困惑了。

9016
12:30:17.563 --> 12:30:20.120
我们马上会讲到这个。

9017
12:30:20.120 --> 12:30:24.629
接下来，我们能做的是复制GitHub回购的URL。

9018
12:30:24.629 --> 12:30:29.606
你可以通过复制这里或顶部的URL来获取它。

9019
12:30:29.606 --> 12:30:33.110
我们要做的是添加这个作为远程回购。

9020
12:30:33.110 --> 12:30:33.836
要做到这一点。

9021
12:30:33.836 --> 12:30:39.932
我们执行gitremote add，给这个远程回购起个名字。

9022
12:30:39.932 --> 12:30:40.496
对我们来说。

9023
12:30:40.496 --> 12:30:44.788
我们写上origin，然后把URL粘贴到这里。

9024
12:30:44.788 --> 12:30:48.314
我们现在说原点远程回购是好的。

9025
12:30:48.450 --> 12:30:57.417
在这个URL处，我们运行git remote dash v，我们可以看到取回的原点repo在这个分支处。

9026
12:30:57.417 --> 12:31:00.926
push的原点回购也在这个分支。

9027
12:31:00.926 --> 12:31:05.678
当我们想获取新代码时，获取代码会从这里获取它。

9028
12:31:05.678 --> 12:31:09.116
如果我们想把代码往上推，我们想把代码给GitHub。

9029
12:31:09.116 --> 12:31:10.873
我们也会从这里开始。

9030
12:31:10.873 --> 12:31:14.387
现在我们用那个远程URL设置了新的远程。

9031
12:31:14.387 --> 12:31:17.958
现在我们要把这些改变推送到github。

9032
12:31:17.958 --> 12:31:18.212
com。

9033
12:31:18.212 --> 12:31:26.139
我们的方法是用gitpush，我们选择要推送到哪个远程，我们会推送原点。

9034
12:31:26.139 --> 12:31:34.842
然后我们要推到哪个分支我们要推到缅因州，它可能会提示你输入用户名和密码，可能是你的电子邮件等。

9035
12:31:34.842 --> 12:31:38.917
如果身份验证不适合你，你可以切换到设置。

9036
12:31:38.917 --> 12:31:45.652
或者如果你向下滚动到开发者设置，个人访问令牌并创建生成新的令

9037
12:31:45.652 --> 12:31:52.387
牌，一些令牌，给自己回购访问权，写访问权，然后点击生成令牌。

9038
12:31:52.450 --> 12:31:54.550
并尝试使用这个令牌作为您的密码。

9039
12:31:55.450 --> 12:32:03.111
使用GitHub文档和与本课程相关的GitHub讨论，如果你迷路了或某些东西不工作，如这里所示。

9040
12:32:03.111 --> 12:32:08.069
但一旦完成，一旦你正确地添加了所有的信息，你就会回到你的get，

9041
12:32:08.069 --> 12:32:13.183
你会有你的第一个GitHub回购，所有的代码和所有的东西都像这样。

9042
12:32:13.183 --> 12:32:18.028
一旦你完成了这一步，一旦你做到了，你绝对应该庆祝。

9043
12:32:18.028 --> 12:32:24.631
如果你愿意，你可以在区块链社区拍摄一个推特网页三个社区绝对是这个协作空间。

9044
12:32:24.631 --> 12:32:28.090
所以Twitter加密是很多人聚集在一起分享想法的地方。

9045
12:32:28.090 --> 12:32:32.766
所以一定要庆祝和分享，非常非常兴奋。

9046
12:32:32.766 --> 12:32:34.054
然后发这样的推特。

9047
12:32:34.054 --> 12:32:41.029
和你的朋友击掌，在Twitter上分享，在Discord上分享，在Reddit上分享，为你所取得的成就感到兴奋，我们还有很多事情要做。

9048
12:32:41.029 --> 12:32:46.608
但通过完成这一部分，你已经做得很好了，我很高兴你开始下一部分。

9049
12:32:46.608 --> 12:32:51.705
现在，我们不打算讲TypeScript的附加内容因为这里没有什么新内容。

9050
12:32:51.705 --> 12:33:00.308
但是，如果你想要看到TypeScript，请随时进入与本课程相关的GitHub存储库。

9051
12:33:00.451 --> 12:33:01.293
好的,太棒了。

9052
12:33:03.451 --> 12:33:04.466
心曾逗过我。

9053
12:33:07.451 --> 12:33:14.744
这将是我们的HTML / JavaScript来资助我，你可以在我的GitHub回购上找到我们将要讲到的所有代码。

9054
12:33:14.744 --> 12:33:19.659
在这一节中，我们将开始了解Node js后端JavaScript和

9055
12:33:19.659 --> 12:33:24.723
浏览器中的JavaScript或前端JavaScript之间的区别。

9056
12:33:24.723 --> 12:33:32.143
如果你来到与本课相关的GitHub回购，我们的主版本将使用被认为是更好的前端JavaScript。

9057
12:33:32.143 --> 12:33:41.140
但如果有些前端JavaScript让人困惑，我们也不会添加JS，你们很快就会明白我说的这些区别是什么意思。

9058
12:33:41.140 --> 12:33:44.924
现在，人们可以在任何时候通过编程与我们的智能合约进行交互。

9059
12:33:44.924 --> 12:33:48.031
然而，我们的大多数用户都不是竞争对手。

9060
12:33:48.031 --> 12:33:54.403
所以我们需要创建一个网站，我们需要创建一个用户界面让他们与我们的智能合约和协议进行交互。

9061
12:33:54.403 --> 12:33:58.778
这就是这一节要教我们的，它会介绍如何构建这些全栈。

9062
12:33:58.778 --> 12:34:01.515
在智能合约的基础上构建这些前端。

9063
12:34:01.515 --> 12:34:05.701
现在，我想向你们展示当我们完成它的时候，它实际上是什么样子的。

9064
12:34:05.701 --> 12:34:11.652
因为在这里，我们要做我们的第一个前端我们的第一个网站使用区块链使用web 3。

9065
12:34:11.652 --> 12:34:14.387
这将是一个极简的网站。

9066
12:34:14.387 --> 12:34:20.434
正如你在这里看到的，我们不会有任何样式，我们只会向你展示如何获得功能。

9067
12:34:20.434 --> 12:34:26.665
此外，我们将做一些不建议的事情，绝对不是最佳实践。

9068
12:34:26.665 --> 12:34:33.092
我们这样做的原因和在数学课上一样，在你们学习导数的技巧之前，先学习导数是什么。

9069
12:34:33.092 --> 12:34:38.807
我们首先是这样教的，这样当你与网站互动时，你就能理解网站上发生了什么。

9070
12:34:38.807 --> 12:34:39.887
当你和他们一起工作时。

9071
12:34:39.887 --> 12:34:45.402
我们已经在Foston身上看到了，触摸连接我们的钱包和水龙头的链接。

9072
12:34:45.452 --> 12:34:53.920
所有去中心化的应用程序都有这个网站，有这样的设置，你可以连接你的钱包，然后通过点击按钮进行交互，这些按钮会调用区块链的函数。

9073
12:34:53.920 --> 12:34:57.346
这将是我们的极简网站，正是这样做的。

9074
12:34:57.346 --> 12:35:00.735
所以这一节将会教你在引擎盖下发生了什么。

9075
12:35:00.735 --> 12:35:04.706
因此，您可以真正理解如何在专业级别上构建这些应用程序。

9076
12:35:04.706 --> 12:35:13.404
对于这一部分，如果你不想跟我一起写代码，你完全可以不写但是，跟我一起写代码肯定会把所有东西都刻在你的记忆里。

9077
12:35:13.452 --> 12:35:16.639
这就是应用程序的样子。

9078
12:35:17.452 --> 12:35:23.277
网站，它连接到我们的硬帽子，我们的本地区块链，但它会像在真正的测试网

9079
12:35:23.277 --> 12:35:29.102
络上一样运行，你会注意到的第一件事是在我们的元掩码中，我们没有连接。

9080
12:35:29.102 --> 12:35:36.658
点击连接，元掩码会弹出问我们是否想连接，我们会连接到它。

9081
12:35:36.658 --> 12:35:39.536
现在我们可以在Funmi和我们的心脏互动了。

9082
12:35:39.536 --> 12:35:46.833
你会注意到这里的两个按钮是我们很熟悉的函数，我们有提现函数，这是我们刚刚创建的提现函数。

9083
12:35:46.833 --> 12:35:49.498
当然，我们这里还有基金功能，

9084
12:35:49.498 --> 12:35:56.733
我们推送或发送Aetherium或Matic或其他原生区块链代币到智能合约。

9085
12:35:56.733 --> 12:35:58.276
我们可以通过这个用户界面来实现。

9086
12:35:58.276 --> 12:36:04.927
连接好后，如果我们想看到平衡，我们可以右键点击，点击检查，来到控制台。

9087
12:36:04.927 --> 12:36:10.961
我们将把智能合约的当前余额打印到JavaScript控制台。

9088
12:36:10.961 --> 12:36:15.703
现在还没有人资助这个项目，我们可以降低，我们可以选择我们想要资助的金额。

9089
12:36:15.703 --> 12:36:17.203
例如，0。

9090
12:36:17.203 --> 12:36:23.713
1，每个，我们继续，我们点击基金，元面具会弹出，我们会得到一个小委员会说，基金与0。

9091
12:36:23.713 --> 12:36:23.773
1.

9092
12:36:23.773 --> 12:36:28.786
它会给我们发送0所需的所有事务细节。

9093
12:36:28.786 --> 12:36:32.436
在我们的智能合约中，我们可以点击确认。

9094
12:36:32.436 --> 12:36:39.523
在它被确认之后在我们本地区块链上被开采之后，我们得到了平衡，我们现在看到它是0。

9095
12:36:39.523 --> 12:36:39.610
1.

9096
12:36:39.610 --> 12:36:46.065
我们可以再次调用fund，我们可以有多个出资人，我们可以在不同的账户和不同金额的基金之间切换。

9097
12:36:46.065 --> 12:36:50.357
我们可以看到资金金额的增加，然后我们可以调用退出函数。

9098
12:36:50.357 --> 12:36:54.846
只要我们是所有者，我们就可以确认我们可以从融资合同中取出所有的钱。

9099
12:36:54.846 --> 12:36:55.927
我们会得到平衡。

9100
12:36:55.927 --> 12:36:58.082
现在我们将看到余额重置为零。

9101
12:36:58.082 --> 12:37:00.162
这就是我们要建的东西。

9102
12:37:00.162 --> 12:37:01.405
你准备好了吗?我当然是。

9103
12:37:01.453 --> 12:37:02.380
让我们开始吧。

9104
12:37:04.453 --> 12:37:05.514
网站与web三。

9105
12:37:07.453 --> 12:37:09.843
我们的GitHub回购，所以请随时关注那里。

9106
12:37:10.453 --> 12:37:17.185
如果你心里想的是Funmi dash Free Code Camp repo，我们仍然想要打开这个。

9107
12:37:17.185 --> 12:37:22.323
但我们还需要创建一个新的Visual Studio代码来处理新的repo。

9108
12:37:22.323 --> 12:37:25.673
让我们向下CD一个目录。

9109
12:37:25.673 --> 12:37:33.372
输入mkdir，将其命名为HTML，资助我免费代码营。

9110
12:37:33.372 --> 12:37:34.617
我们会讲到的。

9111
12:37:34.617 --> 12:37:37.561
我们输入代码period来打开它。

9112
12:37:37.561 --> 12:37:44.388
你也可以做File Open Folder，但我们只想在一个新的Visual Studio Code中打开它。

9113
12:37:44.388 --> 12:37:50.269
新的VS代码会弹出，但在我们翻到那个之前，我们想要CD下CD回到

9114
12:37:50.269 --> 12:37:56.335
硬帽的乐趣，我们免费的代码营地，因为我们仍然会使用这里的所有东西。

9115
12:37:56.335 --> 12:38:00.799
在使用这个文件夹和这个回购的智能合约中，

9116
12:38:00.799 --> 12:38:08.389
当你建立daps或连接到区块链的网站时，你通常会有两个存储库或回购。

9117
12:38:08.454 --> 12:38:10.660
一个是智能合约，就像我们在这里看到的。

9118
12:38:10.660 --> 12:38:13.875
这是我们的回购，它拥有智能合约的所有代码。

9119
12:38:13.875 --> 12:38:16.695
然后你也会有一个前端斜杠网站。

9120
12:38:16.695 --> 12:38:21.025
它将是这两个回购的组合，它们组成了完整的堆栈。

9121
12:38:21.025 --> 12:38:28.457
当人们说到全栈时，他们说的是智能合约，这是我们的后端，

9122
12:38:28.457 --> 12:38:37.267
加上HTML / JavaScript /网站，这是我们的前端。

9123
12:38:37.267 --> 12:38:42.604
智能合约是后端，HTML / JavaScript /网站是我们的前端。

9124
12:38:42.604 --> 12:38:44.204
所以我们已经有了后路。

9125
12:38:44.204 --> 12:38:51.628
现在我们要建立我们的前端，我们要保持它因为我们需要它来测试和我们的前端交互。

9126
12:38:51.628 --> 12:38:52.135
太棒了。

9127
12:38:52.135 --> 12:38:56.120
我们现在有了这个新文件夹，HTML Funmi, Free Code Camp。

9128
12:38:56.120 --> 12:39:01.863
这门课不是一门如何学习前端的课程，我们会教你一些前端的概念。

9129
12:39:01.863 --> 12:39:10.256
但如果你想学习完整的传统前端课程，还是那句话，你可以看看Free Code Camp，他们有很多很

9130
12:39:10.256 --> 12:39:18.821
棒的教程，我教你前端，如果你继续跟我学，你肯定会对前端和前端有一个基本的了解以及它与智能合约的关系。

9131
12:39:18.821 --> 12:39:22.405
此外，您不必做前端部分或整个堆栈部分。

9132
12:39:22.455 --> 12:39:28.013
如果你只想上这门课，学习后端，学习JavaScript，学习稳定性，

9133
12:39:28.013 --> 12:39:33.245
学习如何以编程方式执行智能合约，那么你完全可以跳过这些前端部分。

9134
12:39:33.245 --> 12:39:41.061
然而，如果你想学习如何建立令人兴奋的网站，并且你想让除了开发人员之外的其他人与你的协议进行交互，你肯定想要观看这一部分。

9135
12:39:41.061 --> 12:39:44.005
在我们开始写代码之前。

9136
12:39:44.005 --> 12:39:50.355
当使用使用区块链的这些网站之一时，我们需要了解到底发生了什么。

9137
12:39:50.355 --> 12:39:53.094
我最近做了一个关于这个的视频。

9138
12:39:53.094 --> 12:39:58.512
让我们快速看一段视频，这样我们就能更快地了

9139
12:39:58.512 --> 12:40:04.190
解这些与区块链互动的网站背后到底发生了什么。

9140
12:40:04.190 --> 12:40:05.322
好吧。

9141
12:40:05.322 --> 12:40:13.008
所以我们在这里，有一个网站或前端，在一些我们已经部署的智能合约之上，现在它是什么并不重要。

9142
12:40:13.008 --> 12:40:19.582
这是典型的界面，你会看到浓缩到一个非常非常简单的水平。

9143
12:40:19.582 --> 12:40:24.191
通常，你会看到像连接功能，Metamask，或其他钱包连接器之类

9144
12:40:24.191 --> 12:40:28.946
的东西会弹出，我们会点击，Next，我们会连接这里甚至会说，连接。

9145
12:40:28.946 --> 12:40:33.418
我们还可以执行函数，我们可以与智能合约交互，我们可以确认等等。

9146
12:40:33.455 --> 12:40:40.995
对吧?这是你可能会看到的比如Avi我点击应用程序上的连接，它会说，嘿，你想如何连接?我会选择Metamask。

9147
12:40:40.995 --> 12:40:47.901
我要把我的Metamask改成main net，但你们明白了吧?这是一个简单的例子。

9148
12:40:47.901 --> 12:40:52.416
那么当我们连接时浏览器中到底发生了什么

9149
12:40:52.416 --> 12:40:57.170
呢?我们需要做的是，右键点击，点击检查。

9150
12:40:57.170 --> 12:41:01.122
在右边，我们会看到调试器在这里。

9151
12:41:01.122 --> 12:41:07.601
现在如果我们转到资源，在浏览器的顶部，你会看到一些东西。

9152
12:41:07.601 --> 12:41:15.656
如果你往下看这里，我们会看到这个URL，它现在将是我的localhost。

9153
12:41:15.656 --> 12:41:19.578
我们还会看到元蒙版和幻影和一大堆其他的东西。

9154
12:41:19.578 --> 12:41:24.973
我们在这里看到的其他东西将是从浏览器扩展中注入的。

9155
12:41:24.973 --> 12:41:33.406
我们看到这个元蒙版的原因是因为我安装了元蒙版?我在这里看到Phantom的原因是因为我安装了Phantom应用程序。

9156
12:41:33.456 --> 12:41:38.813
Meta面具，当然，是一个EVM，钱包和幻影是一个基于索拉纳的钱包。

9157
12:41:38.813 --> 12:41:44.969
安装了这些扩展后会发生什么它们会自动注入到JavaS

9158
12:41:44.969 --> 12:41:51.125
cript中的窗口对象中，我们向下滚动到控制台这里，

9159
12:41:51.125 --> 12:41:57.520
你可以找到控制台，你可以点击这里，点击上面的任何东西。

9160
12:41:57.520 --> 12:41:59.294
我们输入window。

9161
12:41:59.456 --> 12:42:06.646
我们会看到有一个大窗口对象和所有这些东西，对吧?这个窗口对象代表了我们的窗

9162
12:42:06.646 --> 12:42:13.836
口?现在，如果我们一直滚动到底部，我们做window。Aetherium。

9163
12:42:13.836 --> 12:42:15.978
我们在这里也看到了一个物体。

9164
12:42:15.978 --> 12:42:22.698
这个window。Aetherium对象只存在于你有一个元掩码或者像browser这

9165
12:42:22.698 --> 12:42:29.579
样的元掩码或者如果你想看其他的web3wallet你可以用window。Solana。

9166
12:42:29.579 --> 12:42:32.407
右边是Alana我们看到这个窗口点了Solana。

9167
12:42:32.407 --> 12:42:36.403
现在让我们看看一个没有安装Metamask或phantom的浏览器。

9168
12:42:36.457 --> 12:42:40.494
你认为窗口中会发生什么现在让我们继续右键点击检查。

9169
12:42:40.494 --> 12:42:41.931
我们去控制台。

9170
12:42:41.931 --> 12:42:44.507
现在让我们看看这里发生了什么。

9171
12:42:44.507 --> 12:42:49.190
如果我们去查资料，我们首先我们没有在这里看到超元面具或索拉纳的资料。

9172
12:42:49.190 --> 12:42:53.837
如果我们到控制台，我们仍然能看到窗口如果我放大一点。

9173
12:42:53.837 --> 12:42:55.027
我们仍然可以看到窗户。

9174
12:42:55.027 --> 12:43:01.878
但如果我做window。Aetherium如果我们什么都得不到，或者如果我做window。Solana，我们也什么都得不到。

9175
12:43:01.878 --> 12:43:07.955
为了让浏览器知道有一个Metamask，或者有一个幻影，这些扩展会自

9176
12:43:07.955 --> 12:43:14.211
动将这些添加到窗口对象中，这是我们可以在JavaScript中检查的。

9177
12:43:14.211 --> 12:43:21.653
这些钱包如此重要的原因是内置在它们的底层，它们有一个区块链节点连接到它们。

9178
12:43:21.653 --> 12:43:25.178
为了和区块链互动，我们总是需要一个笔记。

9179
12:43:25.178 --> 12:43:30.951
你可能在alchemy或FIRA看到过url，因为你需要它们与区块链交互，

9180
12:43:30.951 --> 12:43:37.974
alchemy和infura都是第三方区块链的例子，你可以与它们交互，基本上可以租用它们。

9181
12:43:37.974 --> 12:43:43.149
但是您需要它们来创建一个提供程序，或者一个将事务发送到的节点。

9182
12:43:43.149 --> 12:43:48.362
你可以用JavaScript来做，比如这是炼金术文档你

9183
12:43:48.362 --> 12:43:53.769
把炼金术URL，插入到某个对象中然后用它来发送你的事务。

9184
12:43:53.769 --> 12:43:56.832
这是一种可以在后端完成的方法。

9185
12:43:56.832 --> 12:44:04.957
但在前端，你通常想要使用的是你只想使用用户的Metamask，或他们的Solana或他们的钱包作为主要钱包。

9186
12:44:04.957 --> 12:44:11.362
现在，有很多其他不同类型的钱包可以连接，比如ledger、mu、Coinbase、wallet、connect等。

9187
12:44:11.362 --> 12:44:14.232
有不同的方法来设置它们。

9188
12:44:14.232 --> 12:44:22.000
但它们的作用都是一样的，它们暴露了一些URL，它们暴露了一些底层节点，它们给了我们那个URL。

9189
12:44:22.000 --> 12:44:23.830
他们给了我们提供者。

9190
12:44:23.830 --> 12:44:27.879
metamath的方法是用window。Aetherium。

9191
12:44:27.879 --> 12:44:29.910
这就是我们的URL。

9192
12:44:29.910 --> 12:44:32.151
这就是我们的联系。

9193
12:44:32.151 --> 12:44:40.208
事实上，如果你走到Metamask，点击那三个小点，展开视野。

9194
12:44:40.208 --> 12:44:44.828
点击添加网络，然后点击X，我们就可以进入网络了。

9195
12:44:44.828 --> 12:44:50.292
你可以看到我在这里的所有这些区块链都有一个RPC URL，

9196
12:44:50.292 --> 12:44:55.569
这是HTTP RPC URL连接的区块链，不，它在运行。

9197
12:44:55.569 --> 12:44:59.299
我刚好有一台在本地运行。

9198
12:44:59.458 --> 12:45:05.186
所有这些都有一个节点RPC URL你可以在你的元掩码中看到它们。

9199
12:45:05.186 --> 12:45:08.919
这个连接到Fira，这些都连接到Fira。

9200
12:45:08.919 --> 12:45:10.716
都是一样的东西。

9201
12:45:10.716 --> 12:45:13.728
Meta mask可以很好地获取URL，

9202
12:45:13.728 --> 12:45:20.505
并将其粘贴到浏览器中在window。Aetherium或window。Solana中等等。

9203
12:45:20.505 --> 12:45:22.867
这是我们需要知道的最主要的东西。

9204
12:45:22.867 --> 12:45:25.333
我们总是需要和区块链联系。

9205
12:45:25.333 --> 12:45:28.627
而这些浏览器钱包就是一种简单的方法。

9206
12:45:28.627 --> 12:45:29.734
有意义吗?太好了。

9207
12:45:29.734 --> 12:45:31.672
让我们现在就来学习这些知识。

9208
12:45:31.672 --> 12:45:33.232
我们来应用它。

9209
12:45:33.232 --> 12:45:36.909
在这里，让我们快速自述一下。

9210
12:45:36.909 --> 12:45:37.102
医学博士。

9211
12:45:37.102 --> 12:45:40.064
这样我们就可以谈谈我们要做什么了。

9212
12:45:40.064 --> 12:45:47.408
在这一节中，我们将使用原始HTML / JavaScript结合智能合约来构建这个网站。

9213
12:45:47.459 --> 12:45:48.001
稍后。

9214
12:45:52.459 --> 12:45:54.666
现代堆栈来建立我们的网站。

9215
12:45:55.459 --> 12:46:02.901
首先理解如何用HTML和JavaScript做所有的事情，会让我们以后的工作变得容易得多。

9216
12:46:02.901 --> 12:46:07.859
但正如我们所知，所有的网站都使用HTML作为他们看起来的脚手架。

9217
12:46:07.859 --> 12:46:13.104
我们来为网站创建HTML，命名为index。HTML。

9218
12:46:13.104 --> 12:46:20.878
这将是我们网站的基本框架或者说基本骨架。

9219
12:46:20.878 --> 12:46:26.912
在VS code中，如果你输入感叹号index。HTML，然后点击第

9220
12:46:26.912 --> 12:46:33.125
一个弹出的东西，它会自动填充你的代码你的文件用一些基本的HTML设置。

9221
12:46:33.125 --> 12:46:35.018
如果它没有为你做这个，

9222
12:46:35.018 --> 12:46:42.249
请随意从与这门课程相关的GitHub存储库中复制粘贴基本设置，我们有我们的文档类型。

9223
12:46:42.249 --> 12:46:47.785
HTML，我们有一些HTML标记告诉我们这中间的所有东西都将是HTML，这很好。

9224
12:46:47.785 --> 12:46:50.310
然而，为了简单起见，我们不需要这些内容中的大部分。

9225
12:46:50.310 --> 12:46:52.295
我们要让它简单一点。

9226
12:46:52.295 --> 12:46:55.131
我们要删除这条线，这条线和这条线。

9227
12:46:55.131 --> 12:46:58.180
我们要改标题来资助我的应用。

9228
12:46:58.180 --> 12:47:02.371
然后在我们的身体内部，我们可以做一些事情，比如，你好。

9229
12:47:02.371 --> 12:47:06.901
现在我们有了用这个来创建一个网站的基本框架。

9230
12:47:06.901 --> 12:47:10.426
要在网站上展示这个，我们可以做两件事中的一件。

9231
12:47:10.426 --> 12:47:16.131
如果您正在使用Visual Studio代码，我将建议您安装扩展活动服务器。

9232
12:47:16.131 --> 12:47:17.069
它看起来像这样。

9233
12:47:17.069 --> 12:47:23.910
我将有这个扩展的扩展ID在GitHub库中与这门课程相关，这将允许我们很容易地旋转一个HTML网站。

9234
12:47:23.910 --> 12:47:26.168
我们继续安装这个。

9235
12:47:26.168 --> 12:47:30.052
如果你不用Visual Studio Code，我马上会给你展示另一种方法。

9236
12:47:30.052 --> 12:47:35.270
一旦安装了这个，你应该在底部有一个小的go live按钮。

9237
12:47:35.270 --> 12:47:41.028
如果没有，你可以打开你的命令面板，你可以点击视图命令面板打开，你可以输入live

9238
12:47:41.028 --> 12:47:48.227
server然后说open with live server我们只需要点击这个go live按钮。

9239
12:47:48.227 --> 12:47:54.348
它会说开始它会用index。HTML打开你的浏览器。

9240
12:47:54.348 --> 12:47:58.543
我们的网站叫Save on 1207。

9241
12:47:58.543 --> 12:47:59.293
0,0。

9242
12:47:59.293 --> 12:47:59.376
1.

9243
12:47:59.376 --> 12:48:05.348
这被称为环回，或本地主机端点，我们在端口5501上。

9244
12:48:05.348 --> 12:48:11.015
如果你不熟悉这些端口，现在不用担心，这里有index。HTML。

9245
12:48:11.015 --> 12:48:15.348
如果我们把这个改成what's good，点击保存。

9246
12:48:15.348 --> 12:48:18.991
如果它没有自动刷新，我们会到这里刷新。

9247
12:48:18.991 --> 12:48:20.495
我们可以在这里看到。

9248
12:48:20.495 --> 12:48:26.755
如果你以前从未创建过网站，你基本上已经做过了，恭喜你，你可能会得到这个。

9249
12:48:26.755 --> 12:48:27.673
Vs代码文件夹。

9250
12:48:27.673 --> 12:48:27.804
一个。

9251
12:48:27.804 --> 12:48:32.899
vs code文件夹允许你为你正在处理的回购做专门的设置，为你

9252
12:48:32.899 --> 12:48:37.994
的vs code的代码编辑器做专门的设置，但我们现在会忽略它。

9253
12:48:37.994 --> 12:48:43.266
如果你不用Visual Studio Code，你能做的就是在浏览器中运行这个。

9254
12:48:43.266 --> 12:48:47.443
你能做的一件事就是右键点击它，我用的是Mac。

9255
12:48:47.443 --> 12:48:51.593
在Finder中点击显示，也就是显示它的位置。

9256
12:48:51.593 --> 12:48:54.788
你可以双击它，嘣，它就在你的浏览器里运行了。

9257
12:48:54.788 --> 12:49:00.022
它不是指向你的本地主机，而是直接指向你的本地文件路径。

9258
12:49:00.022 --> 12:49:03.558
现在我们可以做的最后一个版本我强烈建议你们不要做。

9259
12:49:03.558 --> 12:49:10.601
但这是另一种选择，我们会为你下载一个不使用Jas的包，它允许我们提供HTTP。

9260
12:49:10.601 --> 12:49:18.936
我们会像安装其他包一样安装它，我们可以用yarn，添加破折号dev HTTP连字符服务器。

9261
12:49:18.936 --> 12:49:22.296
你可能仍然想要添加它。

9262
12:49:22.461 --> 12:49:31.222
现在，我们会得到这个HTTP服务器包的一些节点模块，我们会得到一个package json，当然，还有一个yarn。lock。

9263
12:49:31.222 --> 12:49:35.430
我们能做的就是停止下面的这个，停止运行中的服务器。

9264
12:49:35.430 --> 12:49:38.936
回到网站，刷新，现在是空白。

9265
12:49:38.936 --> 12:49:41.558
我们可以运行yarn HTTP服务器。

9266
12:49:41.558 --> 12:49:43.815
这个也会做同样的事情。

9267
12:49:43.815 --> 12:49:47.810
如果我们过来，我们刷新一下，我们会看到什么是好的。

9268
12:49:47.810 --> 12:49:50.211
现在这个有点挑剔。

9269
12:49:50.211 --> 12:49:56.898
在你做了改变之后，比如，嘿，有什么好，你可能需要关闭它，然后重新打开它，然后刷新它。

9270
12:49:56.898 --> 12:50:04.409
我强烈建议，如果你用的是Visual Studio代码，你一定要用这个go live按钮，因为它会更好地反映你的更改。

9271
12:50:04.461 --> 12:50:05.880
让我们继续，点击go Live按钮。

9272
12:50:07.461 --> 12:50:08.147
弹出。

9273
12:50:08.147 --> 12:50:09.225
好的,很酷。

9274
12:50:12.461 --> 12:50:17.917
标题当然是Funmi app，我们可以在标题部分看到。

9275
12:50:17.917 --> 12:50:25.788
让我们更新这个HTML，让它有那些按钮，它就能连接和使用我们的区块链和任何区块链。

9276
12:50:25.788 --> 12:50:30.045
在HTML中你还能做的一件事是你可以在HTML中编写JavaScript。

9277
12:50:30.045 --> 12:50:36.106
我们可以通过做这个脚本标签，然后我们做一个结束脚本标签。

9278
12:50:36.106 --> 12:50:40.651
script标签里面的任何东西都是JavaScript。

9279
12:50:40.651 --> 12:50:46.806
我可以写console。log，加上一堆惊叹号，我要保存它。

9280
12:50:46.806 --> 12:50:52.675
我们会回到我们的前端，我们会右击，我们会点击检查，我们会到控制台。

9281
12:50:52.675 --> 12:50:57.711
我们可以看到Hi打印出来，我们刷新，我们可以看到Hi从script标签打

9282
12:50:57.711 --> 12:51:02.747
印出来，我们保存它，我们移回去，我们看到Hi从script标签打印出来。

9283
12:51:02.747 --> 12:51:05.494
我知道有点小。

9284
12:51:05.494 --> 12:51:06.655
让我放大。

9285
12:51:06.655 --> 12:51:07.622
好了,好了。

9286
12:51:07.622 --> 12:51:12.255
我们可以在这里输入JavaScript，它在script标签的内

9287
12:51:12.255 --> 12:51:17.033
部我们将在这里编写JavaScript来编写前端将与之交互的函数。

9288
12:51:17.033 --> 12:51:25.332
现在，正如我们之前看到的，在这个小控制台，我们可以检查窗口点以太，看看Metamask或安装。

9289
12:51:25.332 --> 12:51:29.526
再说一次，我们正在使用的很多东西实际上都在Metamask文档中。

9290
12:51:29.526 --> 12:51:34.882
如果你去他们的基础部分，他们会讲一点提供者，也就是这个窗口。

9291
12:51:34.882 --> 12:51:40.774
Aetherium，你可以在元掩码文档中读到如何直接与元掩码交互。

9292
12:51:40.774 --> 12:51:48.620
现在使用window。Aetherium只是我们连接区块链的方法之一，实际上有多种方法因为有多种不同的钱包。

9293
12:51:48.620 --> 12:51:54.190
但现在，我们只打算假装窗口点Aetherium和元蒙版是唯一的扩展。

9294
12:51:54.190 --> 12:51:57.494
所以我们要做的是检查Aetherium的风是否存在。

9295
12:51:57.494 --> 12:51:59.890
这是我们应该做的第一件事。

9296
12:51:59.890 --> 12:52:08.203
因为如果这个不存在，这意味着它们不能连接到区块链，我们要做的第一件事之一是我们要检查它是否存在。

9297
12:52:08.203 --> 12:52:13.261
我们可以这样做如果我们可以说Aetheri

9298
12:52:13.261 --> 12:52:18.319
um不等于的窗口类型为undefined。

9299
12:52:18.319 --> 12:52:22.985
然后我们用console。log，我看到一个元掩码。

9300
12:52:22.985 --> 12:52:28.005
所以现在如果我们保存，我们回到我们的前端，我们确实看到了一个超掩模。

9301
12:52:28.005 --> 12:52:32.779
我有一个没有Metamask的谷歌Chrome，如果我们在控制

9302
12:52:32.779 --> 12:52:37.708
台中查看，我们点击刷新它，我们的实时服务器正在运行的相同URL。

9303
12:52:37.708 --> 12:52:42.383
我没有看到元掩码因为它没有看到元掩码。

9304
12:52:42.383 --> 12:52:43.335
我们可以做别的。

9305
12:52:43.463 --> 12:52:50.479
console。log，没有元掩码刷新，我们仍然看到ICD一个元掩码，我们有一个元掩码。

9306
12:52:50.479 --> 12:52:55.807
你不需要打开一个浏览器，但我们看到Chrome没有元掩码，因为它没有元掩码。

9307
12:52:55.807 --> 12:53:03.495
现在我们能做的是，我们可以自动尝试连接到元掩码如果我们看到有一个元掩码，对吧?记得之前，当我们点击连

9308
12:53:03.495 --> 12:53:11.183
接按钮时，元掩码会弹出，说，你确定要连接吗?我们能做的是，你能在meta mask文档中找到这个，我

9309
12:53:11.183 --> 12:53:19.025
们能运行这个eath request accounts方法，这基本上是我们连接Metamask的方式。

9310
12:53:19.025 --> 12:53:23.479
现在，这是由一个新的EIP和一个旧的文档指定的。

9311
12:53:23.479 --> 12:53:27.790
在较早的教程中，您可能会看到Aetherium dot enable，它实际上做了完全相同的事情。

9312
12:53:27.790 --> 12:53:34.987
所以我们能做的是，我们可以说，一个铈，不好意思，窗口。Aetherium。请求。

9313
12:53:34.987 --> 12:53:39.379
我们可以让方法F请求账户。

9314
12:53:39.379 --> 12:53:41.712
我们把它保存起来。

9315
12:53:41.712 --> 12:53:44.587
现在回到浏览器，我们会看到，

9316
12:53:44.587 --> 12:53:51.775
你会看到Metamask，它会弹出，让我们连接，我们可以选择一个账户。

9317
12:53:51.775 --> 12:53:56.903
点击连接，会自动将元掩码连接到网站。

9318
12:53:56.903 --> 12:54:01.157
现在如果我们看我们的元蒙版，我们可以看到这个连接的小东西。

9319
12:54:01.157 --> 12:54:04.413
它说我们的一号账户现在连接到我们的网站上了。

9320
12:54:04.463 --> 12:54:11.689
这意味着网站现在可以对我们的元掩码进行API调用，我们仍然必须是批准他们的人。

9321
12:54:11.689 --> 12:54:16.939
但它可以继续连接并尝试运行事务，这很好，这是我们想要的。

9322
12:54:16.939 --> 12:54:21.026
如果你想断开连接，我们可以点击那个小按钮，点击断开这个账户。

9323
12:54:21.026 --> 12:54:27.226
我们现在的代码是每当我们点击刷新，这个就会弹出这非常烦人。

9324
12:54:27.226 --> 12:54:32.545
我们要做的是把它包装成一个异步函数，和我们之前做的

9325
12:54:32.545 --> 12:54:38.078
完全一样，我们会创建一个叫Connect的异步函数。

9326
12:54:38.078 --> 12:54:40.971
我们把这里的花括号括起来。

9327
12:54:40.971 --> 12:54:44.316
然后我们把它格式化一下，让它看起来更好看。

9328
12:54:44.316 --> 12:54:48.655
现在保存，回到网站，刷新。

9329
12:54:48.655 --> 12:54:51.293
然后我们继续断开连接。

9330
12:54:51.464 --> 12:54:56.262
如果我们刷新Metamask不会一直问我们，你想连接吗，你想连接这里吗，

9331
12:54:56.262 --> 12:55:00.928
你想连接吗，因为我们需要调用这个连接函数我们可以在这里添加一个小按钮。

9332
12:55:00.928 --> 12:55:06.141
在script标签下面，我们会添加一个button标签。

9333
12:55:06.141 --> 12:55:07.480
这是打开按钮标签。

9334
12:55:07.480 --> 12:55:09.153
这是关闭按钮标签。

9335
12:55:09.153 --> 12:55:15.526
在开始按钮标签声明中，我们会给它一个ID，它将是Connect button。

9336
12:55:15.526 --> 12:55:22.089
我们写上onclick = Connect connections函数。

9337
12:55:22.089 --> 12:55:30.498
我们将这个按钮命名为connect在这些小按钮标签之间，我们将它命名为connect当我们点击它时，它会调用connect函数。

9338
12:55:30.498 --> 12:55:35.412
保存，回到前端，我们可以看到有一个连接按钮。

9339
12:55:35.464 --> 12:55:41.946
现在如果我们按连接，Metamask会弹出，我们点击next，像这样连接。

9340
12:55:41.946 --> 12:55:44.064
嘭，现在我们连在一起了。

9341
12:55:44.064 --> 12:55:49.498
我们甚至可以在这里执行一点await等待它完成后再继续。

9342
12:55:49.498 --> 12:55:54.683
连接之后，我们可以说console。log connected。

9343
12:55:54.683 --> 12:55:59.115
让我们来测试一下，我们回到Metamask。

9344
12:55:59.115 --> 12:56:03.600
我们会在这里断开连接，如果没有必要的话，尽量不要上主网。

9345
12:56:03.600 --> 12:56:07.328
运行连接，点击下一个连接。

9346
12:56:07.465 --> 12:56:10.965
现在我们看到一个小的console。log显示为connected。

9347
12:56:10.965 --> 12:56:11.631
好了,好了。

9348
12:56:11.631 --> 12:56:14.152
我们也可以相应地更新我们的网站。

9349
12:56:14.152 --> 12:56:17.339
这样我们就可以让用户知道我们是联网的。

9350
12:56:17.465 --> 12:56:22.947
我们可以抓取connect button元素ID并在连接后说我们已连接。

9351
12:56:22.947 --> 12:56:27.076
等待连接后，我们可以执行document。

9352
12:56:27.076 --> 12:56:33.368
getelement by ID Connect button。

9353
12:56:33.368 --> 12:56:40.431
然后我们说。inner HTML = connected，像这样。

9354
12:56:40.431 --> 12:56:44.412
而不是在这里说不最小化，我们会做相反的事情。

9355
12:56:44.412 --> 12:56:45.858
我们复制这一行。

9356
12:56:45.858 --> 12:56:51.723
我们说的不是连接，而是请安装元掩码。

9357
12:56:51.723 --> 12:56:55.846
然后保存回到前端，点击连接。

9358
12:56:55.846 --> 12:56:59.915
如果我们已经连接了，它就会自动变成连接。

9359
12:56:59.915 --> 12:57:02.350
如果我们没有连接，它会弹出，我们会连接起来。

9360
12:57:02.350 --> 12:57:04.990
现在我们有了这个按钮，上面写着连接，这很好。

9361
12:57:04.990 --> 12:57:08.101
现在我们已经知道我们是有联系的。

9362
12:57:08.101 --> 12:57:12.955
我们已经把超元面具连接到前端了。

9363
12:57:12.955 --> 12:57:16.215
现在我们要在这里做一些函数。

9364
12:57:16.215 --> 12:57:24.015
这是我们想要创建更多功能和按钮的地方它们将使用我们非常熟悉的包。

9365
12:57:24.015 --> 12:57:28.111
现在，当我们编码的时候，我们的脚本部分会变得越来越大，越来越大。

9366
12:57:28.111 --> 12:57:32.666
通常情况下，我们希望把代码放在JavaScript文件中。

9367
12:57:32.666 --> 12:57:38.531
我们继续，到这里来，创建一个新文件，命名为index。js。

9368
12:57:38.531 --> 12:57:43.115
我们不会把JavaScript放在这些脚本标签中，我们

9369
12:57:43.115 --> 12:57:47.869
会把它放在这个索引中然后把这个索引文件导入到HTML中。

9370
12:57:47.869 --> 12:57:52.415
我们要做的是我们实际上只需要获取这个函数。

9371
12:57:52.466 --> 12:57:54.836
我们要复制它，暂时删除所有内容。

9372
12:57:55.466 --> 12:58:00.372
粘贴到ext。js中，然后在index。

9373
12:58:00.372 --> 12:58:06.014
HTML中，我们会告诉脚本标签使用index。

9374
12:58:06.014 --> 12:58:06.239
js。

9375
12:58:06.466 --> 12:58:12.887
我们只要说源等于。/下标。js。

9376
12:58:12.887 --> 12:58:20.235
然后我们会说，这个的类型是文本/ JavaScript。

9377
12:58:20.235 --> 12:58:27.207
现在，如果我们保存它，我们保存index。HTML，我们回到前端，我们做一点刷新。

9378
12:58:27.207 --> 12:58:30.672
我们确保我们会继续断开连接。

9379
12:58:30.672 --> 12:58:35.799
再进行一次刷新，即使是在索引中。

9380
12:58:35.799 --> 12:58:39.983
Js在不同文件中，因为我们做的是SRC = index。

9381
12:58:39.983 --> 12:58:46.841
js，我们将它导入到HTML中，当我们点击Connect时，它仍然调用Connect函数。

9382
12:58:46.841 --> 12:58:52.415
这就是我们如何将JavaScript分离到自己的js文件中这是我们比较熟悉的。

9383
12:58:52.466 --> 12:59:00.883
如果你看一下与这门课相关的GitHub回购，以及索引。j，你会看到我们的Connect函数，我们添加了一些生活

9384
12:59:00.883 --> 12:59:09.300
质量的东西，我们添加了一些try catch来减少处理错误，如果你愿意，你可以自己添加这些try catch。

9385
12:59:09.300 --> 12:59:13.029
但我不会在这个视频中演示它们。

9386
12:59:13.029 --> 12:59:20.060
现在我们要创

9387
12:59:20.060 --> 12:59:28.263
建有趣的函数。

9388
12:59:28.263 --> 12:59:33.123
之后，我们会

9389
12:59:33.123 --> 12:59:38.794
创建取款函数。

9390
12:59:38.794 --> 12:59:42.094
这是前端JavaScript代码的地方。

9391
12:59:42.094 --> 12:59:45.057
没有g有一点不同。

9392
12:59:45.057 --> 12:59:46.095
在任何JS中，

9393
12:59:46.095 --> 12:59:54.696
我们都使用require关键字在前端JavaScript中导入依赖项，但你不能使用require，它也不能正常工作。

9394
12:59:54.696 --> 12:59:59.677
稍后，我们将使用Import关键字，这是更好的方法。

9395
12:59:59.677 --> 13:00:05.105
这是我们的第一个不同点在前端使用Import关键字要比requi

9396
13:00:05.105 --> 13:00:10.534
re关键字好得多，特别是因为require关键字实际上不起作用。

9397
13:00:10.534 --> 13:00:14.376
对于那些可能在这种变化中挣扎的人。

9398
13:00:14.376 --> 13:00:23.172
再说一次，在与此相关的GitHub回购中，我们有一个Node js版本，在那里你可以使用require关

9399
13:00:23.172 --> 13:00:32.139
键字，你只需要通过自述文件下载一些包，运行一些脚本，基本上把使用require的代码转换成使用导入的代码。

9400
13:00:32.139 --> 13:00:36.324
但是我们会教你使用导入来处理前端代码的方法。

9401
13:00:36.324 --> 13:00:45.237
现在你会看到，当我们进入下一个Jas时，我们仍然会从节点模块下载代码，并使用yarn锁和json包等。

9402
13:00:45.237 --> 13:00:49.372
总结一下，我们还是要做纱线添加。

9403
13:00:49.372 --> 13:00:55.183
但在框架之外当我们使用原始JavaScript，原始HTML设置时，就像我们在这里做的，

9404
13:00:55.183 --> 13:01:00.731
我们不会做yarn, add节点模块会为框架添加节点模块，比如next react。

9405
13:01:00.731 --> 13:01:04.631
但是对于原始JavaScript，我们将使用不同的语法，我很快将向您展示这种语法。

9406
13:01:04.631 --> 13:01:07.175
下面开始构造基金函数。

9407
13:01:07.175 --> 13:01:12.046
为了创造有趣的功能，我们通常会做什么?我们会创建一个叫fund的异步函数。

9408
13:01:12.046 --> 13:01:20.994
在这个函数中，我们可能想要取一些以太作为参数，因为我们想要用一些以太来为它提供资金。

9409
13:01:20.994 --> 13:01:29.991
当我们调用这个函数时，我们可能想运行console。log会在这里做一点字符串插值。

9410
13:01:29.991 --> 13:01:36.855
资金数额，点点点点，这些分号简直要把我逼疯了。

9411
13:01:36.855 --> 13:01:43.419
我要添加一个。pretty。rc文件到这里，我要在这里添加pretty。

9412
13:01:43.468 --> 13:01:45.155
否则我就要疯了。

9413
13:01:46.468 --> 13:01:52.123
Dev，这里是pretty tier，这样我们就可以用pretty tier来格式化JavaScript。

9414
13:01:52.123 --> 13:01:52.226
js。

9415
13:01:52.226 --> 13:01:57.480
我按下command S，它看起来确实是这样的，自动格式化现在，不

9416
13:01:57.480 --> 13:02:02.894
管分号是什么，我们都可以像调用connect一样调用这个有趣的函数。

9417
13:02:02.894 --> 13:02:06.817
在index。HTML中，我们可能会创建一个新按钮。

9418
13:02:06.817 --> 13:02:07.261
按钮。

9419
13:02:07.261 --> 13:02:15.025
我们给它一个ID fund会说on click = fund。

9420
13:02:15.025 --> 13:02:18.139
我们写上基金。

9421
13:02:18.468 --> 13:02:21.517
这将是我们的按钮，保存，我们看我们的前端。

9422
13:02:21.517 --> 13:02:27.740
调用fund按钮时，我们说funding with undefined因为这里我们没有给它传递一个金额。

9423
13:02:27.740 --> 13:02:34.418
回到我们的index console。log funding with我们要确保我们能调用Funmi函数。

9424
13:02:34.418 --> 13:02:40.119
我们再复制这一行我们写上type of window。Aetherium不等于undefined。

9425
13:02:40.119 --> 13:02:42.822
我们将尝试在这里提供资金来发送交易。

9426
13:02:42.822 --> 13:02:50.115
什么东西是我们绝对永远需要的?我们需要一个到区块链的提供者斜杠连接。

9427
13:02:50.115 --> 13:02:56.205
我们需要一个签名者，一个钱包，一个有汽油的人

9428
13:02:56.205 --> 13:03:02.296
来发送它，然后我们可能需要与我们交互的合同。

9429
13:03:02.296 --> 13:03:05.759
为了拿到合同，我们需要ABI和地址。

9430
13:03:05.759 --> 13:03:09.287
有了这些，我们可以发送任何事务。

9431
13:03:09.287 --> 13:03:13.598
所以要找到我们的提供者，我们要继续，再次使用醚。

9432
13:03:13.598 --> 13:03:18.946
现在，我们要用稍微不同的方式来做，尽管之前，我们处理醚的方式是我

9433
13:03:18.946 --> 13:03:24.294
们说const ethers = require ethers。

9434
13:03:24.294 --> 13:03:26.389
这就是我们拉醚的方法。

9435
13:03:26.389 --> 13:03:30.904
就像我刚才说的，require在前面行不通。

9436
13:03:30.904 --> 13:03:34.699
我们不希望用node modules包来安装醚。

9437
13:03:34.699 --> 13:03:39.344
我们能做的是转到乙醚文档。

9438
13:03:39.344 --> 13:03:41.925
如果你去入门部分，向下滚动，

9439
13:03:41.925 --> 13:03:49.484
他们有一个部分是关于使用Node js导入的，使用require或imports。

9440
13:03:49.484 --> 13:03:54.707
他们也有一些使用网页浏览器的文档。

9441
13:03:54.707 --> 13:04:03.069
我们不使用节点模块，而是将ethers库复制到自己的目录中，然后自己提供服务。

9442
13:04:03.069 --> 13:04:07.795
所以我们要做的是，我们可以到这里，复制这个大文

9443
13:04:07.795 --> 13:04:12.728
件，也就是醚，但在前端加法，然后回到我们的文件。

9444
13:04:12.728 --> 13:04:16.220
我们在这里新建一个文件。

9445
13:04:16.470 --> 13:04:18.360
叫醚。

9446
13:04:18.360 --> 13:04:19.960
我们做5。

9447
13:04:19.960 --> 13:04:21.560
6点esm。

9448
13:04:21.560 --> 13:04:21.996
分钟。

9449
13:04:21.996 --> 13:04:22.286
js。

9450
13:04:24.470 --> 13:04:26.603
把那个大东西贴在这里。

9451
13:04:28.470 --> 13:04:30.486
当我保存它时，它会自动格式化。

9452
13:04:31.470 --> 13:04:38.012
很大的文件，里面有以太的所有东西，但是如果你愿意的话，前端是违抗的。

9453
13:04:38.012 --> 13:04:41.916
现在我们能做的是把它导入到索引中。

9454
13:04:41.916 --> 13:04:42.094
js。

9455
13:04:42.094 --> 13:04:47.606
这里我们不用require，而是用import

9456
13:04:47.606 --> 13:04:55.755
ethers然后我们引用刚刚得到的文件ethers dash 5。

9457
13:04:55.755 --> 13:04:57.326
6点esm。

9458
13:04:57.326 --> 13:04:57.754
分钟。

9459
13:04:57.754 --> 13:04:58.039
js。

9460
13:04:58.039 --> 13:05:01.232
现在，我们只需要在HTML

9461
13:05:01.232 --> 13:05:07.374
JavaScript课程中做文件导入的复制粘贴。

9462
13:05:07.374 --> 13:05:13.142
在未来的课程与Node js，我们将做纱线，添加醚，有点像我们通常看到的。

9463
13:05:13.142 --> 13:05:17.897
像React和我们将要使用的下一个Jas这样的

9464
13:05:17.897 --> 13:05:22.859
框架将自动将这些纱线添加包转换为前端的五个版本。

9465
13:05:22.859 --> 13:05:26.373
但在这一节中，这是我们导入ethers包的方式。

9466
13:05:26.373 --> 13:05:31.622
现在我们要做的另一件事是在前端，我们要把这个从type text

9467
13:05:31.622 --> 13:05:37.364
/ JavaScript改成type module changes。

9468
13:05:37.364 --> 13:05:45.792
类型模块允许我们将模块导入到代码中，我们会导入这个，我们还会导入另一个模块。

9469
13:05:45.792 --> 13:05:46.437
太棒了。

9470
13:05:46.437 --> 13:05:49.686
现在回到前端，对connect按钮做一点刷新，

9471
13:05:49.686 --> 13:05:55.619
我们得到connect is not defined at HTML button。

9472
13:05:55.619 --> 13:05:55.767
上。

9473
13:05:55.767 --> 13:06:00.936
点击，这里我们不从前端调用Connect按钮，我们要

9474
13:06:00.936 --> 13:06:06.304
从index。HTML中移除这些点击，进入index。

9475
13:06:06.304 --> 13:06:10.007
Js，并在这里添加连接按钮。

9476
13:06:10.007 --> 13:06:12.346
所以我们用const。

9477
13:06:12.346 --> 13:06:16.467
连接按钮= document, dot

9478
13:06:16.467 --> 13:06:21.674
get element by ID，连接按钮。

9479
13:06:21.674 --> 13:06:25.487
然后我们说const。

9480
13:06:25.487 --> 13:06:33.204
一个按钮等于Doc，你的意思是。get element by ID。

9481
13:06:33.204 --> 13:06:36.890
一个按钮，连接按钮的概念是连接按钮。

9482
13:06:36.890 --> 13:06:39.539
有趣按钮就是有趣按钮。

9483
13:06:39.539 --> 13:06:43.056
然后我们说connect button。

9484
13:06:43.056 --> 13:06:46.749
点击等于连接。

9485
13:06:46.749 --> 13:06:49.208
还有一个按钮。

9486
13:06:49.208 --> 13:06:52.486
点击等于喜欢。

9487
13:06:52.486 --> 13:06:55.881
我们回到我们的前端，稍微刷新一下。

9488
13:06:55.881 --> 13:06:57.071
我们现在点击连接。

9489
13:06:57.071 --> 13:07:01.698
它确实在工作，我们会去到Metamask

9490
13:07:01.698 --> 13:07:06.557
断开连接，刷新，点击连接，砰，它又弹出了。

9491
13:07:06.557 --> 13:07:11.611
这只是因为那个类型是module，如果它是text斜杠JavaScript，点击

9492
13:07:11.611 --> 13:07:16.793
按钮添加到这里，但因为我们做的是模块，我们会在JavaScript中添加那些点击。

9493
13:07:16.793 --> 13:07:21.537
现在我们有了醚，我们能做的是我们甚至可以做一个小小

9494
13:07:21.537 --> 13:07:26.471
的console。log，把醚粘贴到这里，或者更好。

9495
13:07:26.471 --> 13:07:28.777
我们将把它添加到Connect按钮的正上方。

9496
13:07:28.777 --> 13:07:37.622
回到前端，我们会进行刷新我们会在前端看到整个ethers对象这很完美，这正是我们想要的。

9497
13:07:37.622 --> 13:07:42.280
既然我们有这两个变量，我们可以把它更新为，connect

9498
13:07:42.280 --> 13:07:48.103
button。innerHTML = connected，这里也是。

9499
13:07:48.103 --> 13:07:56.916
Connects button。innerHTML = please install meta mask因为现在connect button将等同于运行这个document。get element by ID。

9500
13:07:56.916 --> 13:07:58.027
和伟大的。

9501
13:07:58.027 --> 13:08:03.138
让我们回到继续我们的字体函数。

9502
13:08:03.472 --> 13:08:07.916
我们写入const provider = new ethers。

9503
13:08:07.916 --> 13:08:13.472
providers。web3provider window。Aetherium。

9504
13:08:13.472 --> 13:08:17.618
webthree provider是ether中的一个对象，

9505
13:08:17.618 --> 13:08:26.049
它允许我们基本上围绕Metamask这样的东西，webthree provider非常类似于我们之前使用的JSON RPC

9506
13:08:26.049 --> 13:08:32.685
provider，我们在那里放入那个端点，我们的炼金法端点，或者当我们使用Metamask时。

9507
13:08:32.685 --> 13:08:33.237
这里，

9508
13:08:33.237 --> 13:08:42.265
无论我们在网络部分有什么端点web3provider接受那个HTTP端点并自动为我们插入到以太中。

9509
13:08:42.265 --> 13:08:48.972
这行代码基本上是看我们的Metamask，然后说，啊，好的，我在里面找到了HTTP端点，Metamask。

9510
13:08:48.972 --> 13:08:52.239
这就是我们要用的提供者。

9511
13:08:52.239 --> 13:08:55.084
因为我们的提供者连接到我们的超掩模。

9512
13:08:55.084 --> 13:09:00.464
这里，我们可以获得签署人或者我们可以通过运行const

9513
13:09:00.464 --> 13:09:07.239
signer = provider。get signer来获得钱包，

9514
13:09:07.239 --> 13:09:14.015
钱包，这将返回从提供者连接的钱包，同样，我们的提供者是Metamask。

9515
13:09:14.015 --> 13:09:20.140
如果我们连接到账户1，它会返回账户1作为连

9516
13:09:20.140 --> 13:09:26.266
接到账户2的签名者，它会返回账户2，等等。

9517
13:09:26.266 --> 13:09:34.873
现在，我要在这里添加console。log signer，然后翻到前面看看点击基金按钮时会发生什么。

9518
13:09:34.873 --> 13:09:43.123
这里有我们的JSON RPC签名者，签名者将是我们连接到前端的帐户。

9519
13:09:43.123 --> 13:09:45.373
现在我们有了提供者，有了签名者。

9520
13:09:45.473 --> 13:09:50.182
现在，我们需要通过获取API和地址来获取契约。

9521
13:09:50.182 --> 13:09:52.311
我们需要写const。

9522
13:09:52.311 --> 13:09:58.439
契约等于什么?我们怎样才能拿到合同呢?这就是我们需要

9523
13:09:58.439 --> 13:10:04.567
知道ABI和地址的地方通常你会看到很多项目做的因为一

9524
13:10:04.567 --> 13:10:10.932
旦契约被部署，地址就会改变它们会有某种类型的常量文件。

9525
13:10:10.932 --> 13:10:17.243
他们会新建一个名为constants。js的文件。

9526
13:10:17.473 --> 13:10:24.769
在这里，他们会添加地址和API之类的东西供我们在基金部分使用。

9527
13:10:24.769 --> 13:10:29.412
现在，当我们在开发的时候，当我们在构建的时候，这个，后端和前端团队

9528
13:10:29.412 --> 13:10:34.196
将会有一些交互，或者如果你只是在做整个堆栈，你将会和他们的后端交互。

9529
13:10:34.196 --> 13:10:40.013
这就是为什么把前端和后端代码都放在身边是如此重要的原因。

9530
13:10:40.013 --> 13:10:46.997
如果我们回到Hardhead，资助我们刚刚做的项目，我们可以在这里找到ABI。

9531
13:10:46.997 --> 13:10:53.034
再一次，如果我们去看工件，去看合同，我们可以去资助我。灵魂，资助

9532
13:10:53.034 --> 13:10:59.260
我。JSON，我们可以在这里找到ABI，它将是这里这个巨大的东西。

9533
13:10:59.260 --> 13:11:07.349
你可以继续，你甚至可以复制这整个东西在这个小括号里这个小括号，我们可以复制这个。

9534
13:11:07.349 --> 13:11:09.880
然后我们可以回到我们的常数。

9535
13:11:09.880 --> 13:11:09.981
js。

9536
13:11:09.981 --> 13:11:15.825
我们可以将它保存为变量，我们写入Export

9537
13:11:15.825 --> 13:11:21.670
const Avi e =然后粘贴到这里。

9538
13:11:21.670 --> 13:11:24.534
然后回到index。js中，

9539
13:11:24.534 --> 13:11:31.286
我们可以用importapi from constants导入它。

9540
13:11:31.286 --> 13:11:32.067
哦。

9541
13:11:32.067 --> 13:11:33.942
好了,好了。

9542
13:11:33.942 --> 13:11:36.910
我们有了API。

9543
13:11:36.910 --> 13:11:42.044
地址呢，因为我们要在本地运行这个，我们想要

9544
13:11:42.044 --> 13:11:47.424
得到本地运行合约的合约地址，我们有几种方法。

9545
13:11:47.424 --> 13:11:54.167
一种方法是你可以打开两个窗口一个是你的前端代码，一个是你的后端代码，一个是你的后端

9546
13:11:54.167 --> 13:12:00.911
代码，你可以运行yarn，硬帽节点，它会为我们旋转区块链节点，并在这里给我们地址。

9547
13:12:00.911 --> 13:12:01.956
或者我们能做什么。

9548
13:12:01.956 --> 13:12:07.843
这可能会更容易一些在你的窗口中用你的前端代码创建一个新的终端。

9549
13:12:07.843 --> 13:12:09.735
现在我们有两个终端在运行。

9550
13:12:09.735 --> 13:12:18.344
然后是第二个，我们将向下CD。CD。然后CD，在Me Free Code Camp上。

9551
13:12:18.344 --> 13:12:22.084
在这里，我们要运行纱线，艺术头节点。

9552
13:12:22.084 --> 13:12:28.254
这将在这里的第二个终端上旋转我们的本地区块链，我们

9553
13:12:28.254 --> 13:12:34.671
在这里部署资金我部署那个地址，等等，等等，就在这里。

9554
13:12:34.671 --> 13:12:38.046
提醒一下，如果我点这个x，它会隐藏终端。

9555
13:12:38.046 --> 13:12:46.491
我总能用终端新终端把它拉出来，我总能把它藏起来，但它仍然在我的终端里运行。

9556
13:12:46.491 --> 13:12:47.652
所以我要把它藏起来。

9557
13:12:47.652 --> 13:12:52.546
我能做的是回到常量文件夹，在最上面，

9558
13:12:52.546 --> 13:12:57.441
我们可以输入导出const合约地址。

9559
13:12:57.441 --> 13:13:01.558
等于，我们把终端拉上来。

9560
13:13:01.558 --> 13:13:07.238
然后我们去取，上面写着，把我部署在这里的资金取出来。

9561
13:13:07.238 --> 13:13:11.507
我们复制那个地址，加上引号，然后粘贴进去。

9562
13:13:11.507 --> 13:13:17.211
现在我们还导出了合约地址，然后在索引中。

9563
13:13:17.211 --> 13:13:23.378
Js将导入带有逗号的合同地址。

9564
13:13:23.475 --> 13:13:27.551
现在我们有了ABI和合同地址。

9565
13:13:28.475 --> 13:13:34.089
可以做什么，我们可以说const contract = new醚。

9566
13:13:34.089 --> 13:13:39.875
contract，我们会传递契约地址，传递API，我们会传递签署人。

9567
13:13:39.875 --> 13:13:47.572
现在我们有了连接到签署人的ethers契约对象，我们有了契约地址，我们有了契约abi，现在

9568
13:13:47.572 --> 13:13:54.926
我们有了契约对象，我们就可以开始进行交易了就像我们之前做交易一样我们可以运行const

9569
13:13:54.926 --> 13:14:02.966
transaction response = a weight contract。fund。

9570
13:14:02.966 --> 13:14:11.544
然后我们会传递一个值ethers。utils。parse, ether ether mount。

9571
13:14:11.544 --> 13:14:17.361
这就是我们创建事务的方式。

9572
13:14:17.361 --> 13:14:22.559
如果你现在拿这个，我们到前面，给它一点刷新，确保我们是连

9573
13:14:22.559 --> 13:14:27.943
接的，我们点击基金，我们会得到这个错误值必须是一个字符串。

9574
13:14:27.943 --> 13:14:33.105
这是因为在这个坐垫上，它被传递进来的时候是空的。

9575
13:14:33.105 --> 13:14:36.234
通常，我们会直接把参数传递给函数。

9576
13:14:36.234 --> 13:14:40.076
但我们现在要做的是我们要硬编码这个。

9577
13:14:40.076 --> 13:14:41.342
所以我们用const。

9578
13:14:41.342 --> 13:14:45.682
在坐骑等于时，我们设为77，或者其他我们觉得有趣的东西。

9579
13:14:45.682 --> 13:14:51.278
现在，你觉得会发生什么?我们得到了另一个空气，内部交易成本的

9580
13:14:51.278 --> 13:14:57.062
资金不足，或者你可能会得到其他错误，但你会得到一个奇怪的错误。

9581
13:14:57.062 --> 13:15:02.122
这是因为我们现在还没有连接到本地硬头节点。

9582
13:15:02.122 --> 13:15:07.611
如果我们看一下我们的超掩膜，我们目前没有连接到正确的区块链，我们

9583
13:15:07.611 --> 13:15:13.101
连接到溜冰场B，或主网或其他什么，我们需要连接到我们的本地主机。

9584
13:15:13.101 --> 13:15:18.112
看看网络，这里已经有一个本地主机对象了。

9585
13:15:18.112 --> 13:15:19.992
但我们还是要特别具体一点。

9586
13:15:19.992 --> 13:15:26.209
我们会在这里添加一个新的网络，我们会添加一个叫做硬帽的东西，本地主机。

9587
13:15:26.209 --> 13:15:28.882
点击添加网络，添加Hardhead。

9588
13:15:28.882 --> 13:15:37.126
这里的本地主机，RPC URL，我们可以从节点区域找到，我们可以滚动到节点运行的地方，我们

9589
13:15:37.126 --> 13:15:45.555
可以复制这个URL并粘贴到新的RPC URL，链ID是31337货币符号是go或ether。

9590
13:15:45.555 --> 13:15:51.677
尽管这个弹出窗口说它可能有一个不同的货币符号，我们将把eath放在这里。

9591
13:15:51.677 --> 13:15:57.427
没有块资源管理器，对吧?因为这是本地区块链，我们不会有块资源管理器。

9592
13:15:57.477 --> 13:15:58.444
点击保存。

9593
13:15:58.477 --> 13:16:00.680
现在我们在这里有了一个账户，这很好。

9594
13:16:01.477 --> 13:16:02.572
到我们当地的区块链。

9595
13:16:04.477 --> 13:16:06.445
看，我们戴上了本地安全帽。

9596
13:16:06.445 --> 13:16:07.778
我们彼此相连。

9597
13:16:08.477 --> 13:16:09.560
让我们刷新。

9598
13:16:09.560 --> 13:16:11.976
让我们再运行一次基金。

9599
13:16:13.477 --> 13:16:15.412
事务确实会弹出。

9600
13:16:15.412 --> 13:16:16.315
这太棒了。

9601
13:16:17.477 --> 13:16:22.789
我们没有钱，我们破产了，我们在当地也没有硬头Aetherium。

9602
13:16:22.789 --> 13:16:29.381
我们需要将一个账户从硬帽导入到元掩码中，这是可以做到

9603
13:16:29.381 --> 13:16:36.227
的任何账户都可以这样做，只要有私钥，就能得到这些账户。

9604
13:16:36.227 --> 13:16:40.910
我们会导入0计数的私钥到元掩码中。

9605
13:16:40.910 --> 13:16:49.430
复制私钥，回到前端，点击元掩码，点击这个大按钮，点击导入账户。

9606
13:16:49.477 --> 13:16:53.132
键入私钥，然后粘贴私钥到这里。

9607
13:16:53.132 --> 13:17:00.110
简单说明一下，如果你选择json文件，记得在ether部分，我们如何将

9608
13:17:00.110 --> 13:17:07.288
密钥加密到带密码的json文件中，你可以用带密码的json文件导入账户。

9609
13:17:07.288 --> 13:17:12.319
如果你加密一个密钥，你想把它添加到元掩码，你可以像这样添加它。

9610
13:17:12.319 --> 13:17:16.977
现在，我们将使用私钥，粘贴私钥，然后点击导入。

9611
13:17:16.977 --> 13:17:21.687
我们现在有了一个帐户，一个新帐户和一个

9612
13:17:21.687 --> 13:17:26.398
帐户3，从本地区块链中有大量的eth。

9613
13:17:26.477 --> 13:17:32.665
再刷新一次，然后连接，确保账户3是连接的。

9614
13:17:32.665 --> 13:17:35.681
如果不是，我们会按下连接按钮。

9615
13:17:35.681 --> 13:17:38.670
现在我们的账户3是连接到这里的。

9616
13:17:38.670 --> 13:17:40.763
然后我们就会开始投资。

9617
13:17:40.763 --> 13:17:46.838
现在我们可以为合同提供资金，点击确认。

9618
13:17:46.838 --> 13:17:54.300
如果我们看，我们的前端什么都不会发生，因为我们确认后没有告诉前端做任何事，但如果我们去区块链，我们

9619
13:17:54.300 --> 13:18:01.763
可以看到我们的fun函数被调用我们刚刚在我们自己的前端区块链上完成了第一次交易，这是了不起的工作。

9620
13:18:01.763 --> 13:18:04.461
但这可能会让用户感到困惑。

9621
13:18:04.461 --> 13:18:06.865
如果这里什么都没发生，它们就会击中趣味函数。

9622
13:18:06.865 --> 13:18:09.363
大家会觉得，哦，好吧，很酷。

9623
13:18:09.363 --> 13:18:14.858
发生了什么?现在，我们可能想让它变得更明显一些刚刚发生的事情。

9624
13:18:14.858 --> 13:18:19.723
还有一件事我想告诉你们，你们不需要跟着做，如果我点了基金，然后

9625
13:18:19.723 --> 13:18:24.589
我点了拒绝，它会崩溃，就像，嘿，你点了拒绝，我不知道该怎么做。

9626
13:18:24.589 --> 13:18:27.986
我们将通过添加try catch让代码更健壮一些。

9627
13:18:27.986 --> 13:18:34.446
因此，我们将告诉JavaScript尝试运行这个事务。

9628
13:18:34.446 --> 13:18:41.127
如果它捕捉到一个错误，就到console。log，那个错误。

9629
13:18:41.127 --> 13:18:46.216
现在，如果我点击基金，然后点击拒绝，它仍然会有

9630
13:18:46.216 --> 13:18:51.528
点疯狂，但至少我们抓住了它，它不会破坏所有东西。

9631
13:18:51.528 --> 13:18:52.078
好的,很酷。

9632
13:18:52.078 --> 13:18:53.931
我们这里有一个事务响应。

9633
13:18:53.931 --> 13:18:57.228
当我们有资金的时候，我们的前端就会很好。

9634
13:18:57.228 --> 13:19:02.228
你资助了我，我我超级困惑。

9635
13:19:02.228 --> 13:19:06.396
还有一点，你们可能会碰到很多次。

9636
13:19:06.396 --> 13:19:07.707
当我们这样做的时候。

9637
13:19:07.707 --> 13:19:10.812
如果你得到一个像这样的错误。

9638
13:19:10.812 --> 13:19:18.932
JS查询，同时格式化输出从RPC, nonce到高期望不是太但得到的形式，你肯定会看到这整个很多。

9639
13:19:18.932 --> 13:19:20.385
下面是解决这个问题的方法。

9640
13:19:20.479 --> 13:19:25.360
发生这种情况的原因是，您关闭了您的硬帽节点，然后重新

9641
13:19:25.360 --> 13:19:30.429
启动它，您的心脏节点说，好吧，我重新开始，我从零开始。

9642
13:19:30.479 --> 13:19:33.733
但Metamask还不够聪明，

9643
13:19:33.733 --> 13:19:42.412
我们要做的是来到Metamask，按下这个大按钮，到设置，到高级，然后重置账户。

9644
13:19:42.412 --> 13:19:44.608
是的，我们要重置它。

9645
13:19:44.608 --> 13:19:51.750
这并不是理想情况下你想在本地网络上用一个有实际资金的实际账户来做的事情，这是可以的。

9646
13:19:51.750 --> 13:19:57.029
如果你重置了账户，重置了节点，我们可以点击确认。

9647
13:19:57.029 --> 13:19:59.079
它不再给我们那个误差了。

9648
13:19:59.079 --> 13:20:02.077
这就是提示，你要重置螺母，

9649
13:20:02.077 --> 13:20:08.305
使我们的Metamask和区块链与nonce数字同步。

9650
13:20:08.479 --> 13:20:09.720
我们有这个事务响应。

9651
13:20:10.479 --> 13:20:15.659
我们的前端给用户一些提示，嘿，交易通过了。

9652
13:20:15.659 --> 13:20:19.593
我们要做的是听区块链来结束这个。

9653
13:20:19.593 --> 13:20:23.806
所以我们要么监听TX被挖掘。

9654
13:20:23.806 --> 13:20:27.248
或者我们可以听一个事件。

9655
13:20:27.479 --> 13:20:28.626
我们还没有了解到事件的进展。

9656
13:20:28.626 --> 13:20:29.019
但我们会的。

9657
13:20:29.479 --> 13:20:33.399
因为我们还没有了解到事件，我们只需要听TX被挖掘。

9658
13:20:33.399 --> 13:20:41.858
为了监听要挖掘的事务，我们会创建一个新函数叫做，监听，

9659
13:20:41.858 --> 13:20:50.004
或事务挖掘这将接受一个事务响应和一个提供者作为输入。

9660
13:20:50.004 --> 13:20:53.085
现在你会注意到这不是一个async函数。

9661
13:20:53.085 --> 13:20:54.159
对于本节。

9662
13:20:54.159 --> 13:20:57.301
这是有意的，我们不希望它是一个异步函数。

9663
13:20:57.301 --> 13:20:58.408
你马上就会知道为什么了。

9664
13:20:58.480 --> 13:21:03.795
我们将使用JavaScript承诺的异步功能来发挥它的巨大优势。

9665
13:21:03.795 --> 13:21:08.352
这就是为什么JavaScript在前端工作得这么好因为它是异步的。

9666
13:21:08.352 --> 13:21:14.130
我们会创建这个函数监听待挖掘的交易，我们会在fund函数中等待。

9667
13:21:14.130 --> 13:21:16.922
我们会让这个返回一个承诺。

9668
13:21:16.922 --> 13:21:19.381
让我们继续，让我们学习如何构建它。

9669
13:21:19.480 --> 13:21:23.299
我们会说console。log，字符串插值，我们会说挖掘。

9670
13:21:23.299 --> 13:21:28.125
然后在这里，我们写上transaction response。hash。

9671
13:21:28.125 --> 13:21:34.447
我们所有的事务响应对象都有一个散列，它只是表示这个散列。

9672
13:21:34.447 --> 13:21:39.537
我们会做一些数据点，放到控制台这里，等

9673
13:21:39.537 --> 13:21:44.896
待事务被挖掘，然后我们会返回一个新承诺。

9674
13:21:44.896 --> 13:21:53.191
我们要返回一个promise的原因是我们需要为区块链创建一个监听器。

9675
13:21:53.191 --> 13:21:55.377
我们想要监听这个事件的发生。

9676
13:21:55.480 --> 13:22:04.221
但我们想告诉JavaScript，等这个东西看完，等这个东西看完。

9677
13:22:04.221 --> 13:22:06.770
这就有点棘手了。

9678
13:22:06.770 --> 13:22:07.880
在我们的基金功能中。

9679
13:22:07.880 --> 13:22:16.035
在我们创建事务之后，我们基本上想告诉JavaScript嘿，等待这个TX完成。

9680
13:22:16.035 --> 13:22:22.962
我们的代码看起来就像等待监听事务mine一样简单。

9681
13:22:22.962 --> 13:22:30.369
我们会给它传递transaction响应和提供者。

9682
13:22:30.369 --> 13:22:33.462
我们说，嘿，听这个事务结束。

9683
13:22:33.462 --> 13:22:38.873
我们使用await关键字，因为await关键字说，好，我们会在这里停止。

9684
13:22:38.873 --> 13:22:41.231
直到这个函数完全完成。

9685
13:22:41.231 --> 13:22:46.756
在这个listen for事务中，我们必须定义如何监听这个。

9686
13:22:46.756 --> 13:22:50.874
我们会说，监听这个事务是否完成。

9687
13:22:50.874 --> 13:22:59.658
醚实际上为我们提供了一种监听事务和监听事件的方法，同样，我们还没有学过这方面的知识，但现在不用担心。

9688
13:22:59.658 --> 13:23:01.481
我们可以去醚的文档。

9689
13:23:01.481 --> 13:23:03.081
我们可以向上看一次。

9690
13:23:03.081 --> 13:23:04.281
收缩点一次。

9691
13:23:04.481 --> 13:23:09.730
有很多监听器我们可以用来监听事件监听不同的事情发生，我

9692
13:23:09.730 --> 13:23:15.174
们可以做这个provider。once我们监听一些事件。

9693
13:23:15.174 --> 13:23:20.217
一旦那个事件触发，我们调用我们定义的其他函数。

9694
13:23:20.217 --> 13:23:22.323
现在，我们还没有讲到事件。

9695
13:23:22.323 --> 13:23:24.623
还是那句话，不要太担心这个。

9696
13:23:24.623 --> 13:23:29.840
我们可以等待的事件之一是我们可以等待交易收据完成，因为

9697
13:23:29.840 --> 13:23:35.057
一旦我们得到了交易收据，这意味着交易实际上已经完成了。

9698
13:23:35.057 --> 13:23:39.610
我们将使用这个provider。once语法来等待事务

9699
13:23:39.610 --> 13:23:44.333
接收，这将是我们的事件，这不是真正的事件，但先不用担心。

9700
13:23:44.333 --> 13:23:49.052
然后我们会调用我们定义的监听器函数，你也可以调用provider。

9701
13:23:49.052 --> 13:23:53.784
On，它将在任何时候触发你的事件触发提供者，

9702
13:23:53.784 --> 13:23:58.302
只要触发一次，我们只关心这个事务经过一次。

9703
13:23:58.302 --> 13:24:00.671
我们传递的是提供者对象。

9704
13:24:00.671 --> 13:24:06.097
我们会说provider。once我们的事件这将是transaction

9705
13:24:06.097 --> 13:24:12.127
response。哈希，提供于transaction response。哈希。

9706
13:24:12.127 --> 13:24:17.882
一旦我们得到这个散列，它马上就会得到，我们会调用监听器函数。

9707
13:24:17.882 --> 13:24:22.903
现在我们可以像这样创建一个函数监听器，然后把监听器传入这里。

9708
13:24:22.903 --> 13:24:28.075
但这里我们要做一个匿名函数，因为这是我们通常看到的这些循环的语法。

9709
13:24:28.075 --> 13:24:34.174
到目前为止，我们只做了provider。一次来做这个匿名函数，这里我们只做两个小括号。

9710
13:24:34.174 --> 13:24:36.014
这个箭头符号。

9711
13:24:36.014 --> 13:24:39.762
这个单独代表一个匿名函数。

9712
13:24:39.762 --> 13:24:44.257
所以我们说，嘿，有一个函数，它不带任何参数，也没有任

9713
13:24:44.257 --> 13:24:48.926
何代码，这个箭头函数，这整个过程表明这是一个匿名函数。

9714
13:24:48.926 --> 13:24:53.820
我们说，一旦事务哈希发生，这就是你想要执行的函数。

9715
13:24:53.820 --> 13:24:55.416
它现在什么都做不了。

9716
13:24:55.416 --> 13:24:56.857
但让我们做点什么吧。

9717
13:24:56.857 --> 13:25:00.842
一旦这个transaction。response完成，

9718
13:25:00.842 --> 13:25:10.291
我们会取一个transtransaction received作为输入参数，或者我们的回调函数，或者我们的listener函数。

9719
13:25:10.291 --> 13:25:19.399
我们要做的是，console。log，用一些字符串插值完成，

9720
13:25:19.399 --> 13:25:28.205
交易收据，那个确认，确认，然后用交易收据，确认，确认完成。

9721
13:25:28.205 --> 13:25:36.257
一旦这个provider。一旦看到有一个事务哈希，它就会把事务接收作为输入夯实器给监听器函数，

9722
13:25:36.257 --> 13:25:44.482
这和我们一直看到的语法是一样的，一旦事务响应完成，我们就会得到事务接收，我们可以用它做一些事情。

9723
13:25:44.482 --> 13:25:46.482
我们看它有多少块确认。

9724
13:25:46.482 --> 13:25:48.876
对我们来说，这应该一直是1。

9725
13:25:48.876 --> 13:25:53.829
如果我们保存这个，回到我们的前端，点击基金，它会

9726
13:25:53.829 --> 13:25:58.783
起作用，我们会给用户一些提示它起作用了，这很好。

9727
13:25:58.783 --> 13:26:02.040
但这并不是我们想要的那样。

9728
13:26:02.040 --> 13:26:09.670
这个console。log就在我们执行await，监听transaction mine之后完成，然后我

9729
13:26:09.670 --> 13:26:17.451
们返回，点击fund，点击confirm，它实际上并没有按照我们想要的顺序进行，它去挖掘它说完成的东西。

9730
13:26:17.451 --> 13:26:22.670
然后它说完成一次行程确认这里发生了什么，我们

9731
13:26:22.670 --> 13:26:27.889
应该在写完成之前写完成，因为这是我们的顺序。

9732
13:26:27.889 --> 13:26:30.939
但看起来好像是单词，顺序不对。

9733
13:26:30.939 --> 13:26:38.252
这里发生了什么，将要发生的是当我们调用listen for transaction mine，

9734
13:26:38.252 --> 13:26:46.500
或者listen for transaction时，mine函数会启动，但它会启动一次，作为它自己的进程。

9735
13:26:46.500 --> 13:26:49.626
因此，await listen for

9736
13:26:49.626 --> 13:26:56.045
transaction，我的将启动侦听器，但它不等待这个侦听器找到事务响应。

9737
13:26:56.045 --> 13:27:03.015
这个函数会在provider。once结束之前结束。

9738
13:27:03.015 --> 13:27:10.959
启动监听器后，它会运行到下一行代码，也就是console。log，完成。

9739
13:27:10.959 --> 13:27:14.640
我们的前端，我们会说，哦，哦，你刚才踢开了一个监听器。

9740
13:27:14.640 --> 13:27:19.273
让我再下去检查一下，看看是不是完成了。

9741
13:27:19.273 --> 13:27:22.548
如果它完成了，我就去做它让我做的事。

9742
13:27:22.548 --> 13:27:25.433
这就是所谓的事件循环起作用的地方。

9743
13:27:25.483 --> 13:27:32.730
我们不需要等待这个提供者完成，我们将这个被提供的立即添加到这个叫做事件循环的队列中。

9744
13:27:32.730 --> 13:27:37.992
我们的前端会定期检查它是否完成。

9745
13:27:37.992 --> 13:27:39.959
所以我们要调整我们的代码。

9746
13:27:39.959 --> 13:27:45.391
我们等待听者听完，这就是我们要讲承诺的地方。

9747
13:27:45.391 --> 13:27:49.915
我们要做的是调整这个函数，让它返回一个承诺。

9748
13:27:49.915 --> 13:27:53.431
以后我们还会多次用到这个语法。

9749
13:27:53.484 --> 13:28:01.284
我们要做的是说，嘿，我们要等听者听完，我们要把这整件事包装成一个承诺。

9750
13:28:01.284 --> 13:28:04.449
我们会说return, new promise。

9751
13:28:04.449 --> 13:28:09.776
promise接受函数本身作为输入参数。

9752
13:28:09.776 --> 13:28:13.394
再一次，我们将使用这种匿名函数符号。

9753
13:28:13.394 --> 13:28:17.198
它需要两个输入参数进行解析和拒绝。

9754
13:28:17.198 --> 13:28:23.502
resolve说，嘿，如果这个承诺工作正常，调用这个resolve函数。

9755
13:28:23.502 --> 13:28:28.422
对我们来说，这个承诺是在听者听完的时候完成的。

9756
13:28:28.484 --> 13:28:33.841
如果有某种类型的超时，我们会拒绝，我们不会写拒绝函数。

9757
13:28:33.841 --> 13:28:38.960
但将来，如果要在生产中执行此操作，则需要添加一些超时作为reject参数。

9758
13:28:38.960 --> 13:28:45.316
基本上，你会说，嘿，一旦监听器听完，我们会解析如果它花了太长时间，我们会说，ask

9759
13:28:45.316 --> 13:28:52.139
for you，你花了太长时间，而不是关闭它，在这里，我们会关闭它围绕提供者这个东西。

9760
13:28:52.139 --> 13:28:55.216
返回新承诺，决心，拒绝。

9761
13:28:55.216 --> 13:29:02.294
只有当这个交易被终止，我们才会解决这个承诺，像这样。

9762
13:29:02.294 --> 13:29:10.151
这里发生了什么，我们会立刻把解析放入提供者中。

9763
13:29:10.151 --> 13:29:17.341
我们说，一旦找到这个事务哈希，我们会调用这个函数，我们会说console。

9764
13:29:17.341 --> 13:29:24.726
log，然后我们会解析这个承诺只会在调用resolve或reject时返回。

9765
13:29:24.726 --> 13:29:31.375
我们告诉它只resolve只finish这个函数一次。

9766
13:29:31.485 --> 13:29:34.308
事务响应。哈希会被找到，

9767
13:29:34.308 --> 13:29:43.016
因为它会在provider。的小圆括号里面一次，承诺只会在它被触发后解决。

9768
13:29:43.016 --> 13:29:44.130
这是一个事件。

9769
13:29:44.130 --> 13:29:51.162
如果这真的让人困惑，复制粘贴这个，然后继续，我们会更深入地了解前端的内容。

9770
13:29:51.162 --> 13:29:57.517
所以希望，这是清楚的，如果不是绝对跳到GitHub讨论开始问这个东西。

9771
13:29:57.517 --> 13:30:03.207
但现在我们已经更新了这个，我们可以回到我们的前端，我们可以点击基金按钮。

9772
13:30:03.207 --> 13:30:05.925
希望这一次，一切都能顺利进行。

9773
13:30:05.925 --> 13:30:10.412
我们点击确认，我们看到挖矿完成，然后我们看到完成。

9774
13:30:10.485 --> 13:30:15.648
原因还是因为，我们的await关键字现在是waiting，它

9775
13:30:15.648 --> 13:30:20.985
说，哦，你在返回一个承诺，我需要等待，我需要等待它解决或拒绝。

9776
13:30:20.985 --> 13:30:29.618
我们只在提供者找到这个事务哈希和这个事务收据时解决承诺，这是这个监听事务mine。

9777
13:30:29.618 --> 13:30:32.818
在以后的章节中，所有这些都将被抽象出来。

9778
13:30:32.818 --> 13:30:37.549
生活将会变得简单很多，但重要的是要理解这里到底发生了什么。

9779
13:30:37.549 --> 13:30:37.936
太棒了。

9780
13:30:37.936 --> 13:30:44.637
所以现在我们给前端一些指示，告诉它发生了什么。

9781
13:30:44.637 --> 13:30:49.604
我们的娱乐功能做得很好，不，不完全是。

9782
13:30:49.604 --> 13:30:54.451
为什么不呢?因为现在我们把每个数都硬编码为0。

9783
13:30:54.451 --> 13:30:54.502
1.

9784
13:30:54.502 --> 13:31:01.930
在前端，我们可能不想硬编码它，我们可能希望允许用户根据他们的意愿投资多少或少。

9785
13:31:01.930 --> 13:31:05.739
我们需要把它从一个按钮变成一个输入表单。

9786
13:31:05.739 --> 13:31:09.167
要做到这一点，我们需要回到HTML。

9787
13:31:09.167 --> 13:31:11.454
回到index。HTML。

9788
13:31:11.454 --> 13:31:15.356
我们要改变这个有趣的部分，我们要添加一些表单信息。

9789
13:31:15.356 --> 13:31:22.223
我们将保持这个按钮不变，或者我们将添加一个小文本框来输入他们想要的内容。

9790
13:31:22.223 --> 13:31:24.971
我要创建一个标签，写上for，

9791
13:31:24.971 --> 13:31:33.216
写上fund这个标签写上eath amount，然后关闭标签，这基本上就是要创建一个标签。

9792
13:31:33.216 --> 13:31:37.879
如果我们回到我们的前端，我们现在只有这个Etham out标签，它没有标记任何东西。

9793
13:31:37.879 --> 13:31:43.026
现在我们要创建一个输入，我们要给它一个eath amount的ID。

9794
13:31:43.026 --> 13:31:47.899
我们给它一个0的占位符。

9795
13:31:47.899 --> 13:31:48.002
1.

9796
13:31:48.002 --> 13:31:51.829
然后我们关闭输入。

9797
13:31:51.829 --> 13:31:58.693
现在如果我们翻到前面，我们有每个数量，标记这个小文本框的占位符是0。

9798
13:31:58.693 --> 13:31:58.749
1.

9799
13:31:58.749 --> 13:32:02.020
我们可以在这里添加一些东西，诸如此类。

9800
13:32:02.020 --> 13:32:06.786
还有一件事，如果你有一些标签，但你没有在它们之间放任何东西，

9801
13:32:06.786 --> 13:32:11.236
你实际上可以缩短它，只需要在后面放一个小的结尾，像这样。

9802
13:32:11.236 --> 13:32:19.316
如果标签之间没有任何东西，你可以像这样关闭它们，这两个是等价的，嘣嘣嘣，它们是一样的。

9803
13:32:19.316 --> 13:32:19.621
太好了。

9804
13:32:19.621 --> 13:32:23.319
当我们调用fund时，我们正在调用fund，我们没有传递任何参数。

9805
13:32:23.319 --> 13:32:32.140
让我们更新fund不再是硬编码eamount，我们会让fund函数由我们在fund函

9806
13:32:32.140 --> 13:32:40.962
数的eamount输入框中输入的内容填充，而不是const eamount = 0。

9807
13:32:40.962 --> 13:32:41.060
1.

9808
13:32:41.060 --> 13:32:46.909
我们从eath amount ID中获取document。

9809
13:32:46.909 --> 13:32:53.970
getelement by ID eath amount。value。

9810
13:32:53.970 --> 13:33:00.656
所以我们要在这个输入框中抓取任意值，在我们的索引中。

9811
13:33:00.656 --> 13:33:06.320
Js，我们有console。log资金与每个数额，如果在我们的前端，我们做1。

9812
13:33:06.320 --> 13:33:06.403
7.

9813
13:33:06.403 --> 13:33:11.567
点击fund，我们在控制台。log中看到，funding with 1。

9814
13:33:11.567 --> 13:33:11.647
7.

9815
13:33:11.647 --> 13:33:12.937
得到1。

9816
13:33:12.937 --> 13:33:13.017
7.

9817
13:33:13.017 --> 13:33:19.674
我们有趣的部分确认，它会挖掘它，完成它，然后说，完成。

9818
13:33:19.674 --> 13:33:20.174
太棒了。

9819
13:33:20.174 --> 13:33:22.978
现在我们在这里添加了一个小文本框。

9820
13:33:22.978 --> 13:33:25.962
因此，人们可以根据自己的意愿提供多少资金。

9821
13:33:25.962 --> 13:33:29.418
太好了，这整件事可以看作是一种形式。

9822
13:33:29.418 --> 13:33:34.437
还有一个表单标签，但我们现在只使用这个。

9823
13:33:34.437 --> 13:33:35.830
好的，很好。

9824
13:33:35.830 --> 13:33:41.065
我们做了大量的资金，我们不断为我们的合同提供资金，我们不断

9825
13:33:41.065 --> 13:33:46.300
添加更多的东西，我们可能需要一个按钮来跟踪这里实际有多少。

9826
13:33:46.300 --> 13:33:48.782
让我们添加一个非常简单的平衡按钮。

9827
13:33:48.782 --> 13:33:52.978
我把这个移到下面，这样更好。

9828
13:33:52.978 --> 13:33:57.294
我们写入button id = balance button。

9829
13:33:57.294 --> 13:34:00.794
我们称它为get balance。

9830
13:34:00.794 --> 13:34:03.978
现在我们有了一个平衡按钮。

9831
13:34:03.978 --> 13:34:06.723
它什么都不会做因为我们没有得到平衡函数。

9832
13:34:06.723 --> 13:34:08.402
让我们回到下标。

9833
13:34:08.402 --> 13:34:08.605
js。

9834
13:34:08.605 --> 13:34:14.694
我们会创建一个getbounce函数async函数getbounce。

9835
13:34:14.694 --> 13:34:17.834
我们就像之前做的那样。

9836
13:34:17.834 --> 13:34:25.880
如果type window。Aetherium不等于undefined，那么我们将执行const

9837
13:34:25.880 --> 13:34:32.417
provider = new ethers ethers。providers。

9838
13:34:32.417 --> 13:34:41.972
web3provider of window, Aetherium将执行const balance = await

9839
13:34:41.972 --> 13:34:48.174
provider。get balance，合约地址，同样，我们在顶部导入，

9840
13:34:48.174 --> 13:34:58.567
然后我们将执行console。log ethers。utils。format, ether, bounce这个格式ether

9841
13:34:58.567 --> 13:35:07.453
unce这个格式ether function ethers utils，你可以在文档中找到它，使阅读醚，格式化的数字更容易阅读。

9842
13:35:07.453 --> 13:35:15.163
和之前做的一样，我们要向上，复制这条有趣的按钮行，粘贴这里写balance button

9843
13:35:15.163 --> 13:35:23.049
= document。getelement by ID, balance button。

9844
13:35:23.049 --> 13:35:28.544
然后我们会说balance button on click = get

9845
13:35:28.544 --> 13:35:34.826
balance，我们会回到前端，我们会快速刷新，我们会get balance。

9846
13:35:34.826 --> 13:35:39.154
现在我们可以看到控制台的余额，我们可以用1来投资。

9847
13:35:39.154 --> 13:35:44.401
8，我们会弹出基金metamath，我们会继续

9848
13:35:44.401 --> 13:35:49.649
并确认挖矿完成，我们会点击平衡，现在我们在3。

9849
13:35:49.649 --> 13:35:49.761
8.

9850
13:35:49.761 --> 13:35:50.890
太棒了。

9851
13:35:50.890 --> 13:35:53.747
好了，我们继续。

9852
13:35:53.747 --> 13:35:57.116
接下来我们要做什么呢，我们要在这里吃掉取款函数。

9853
13:35:57.116 --> 13:36:01.301
我们来创建它它看起来和我们之前做过的很像。

9854
13:36:01.301 --> 13:36:06.556
在index。HTML上，我们创建一个新按钮我们可以

9855
13:36:06.556 --> 13:36:12.015
复制这一行，粘贴到下面，调用这个withdraw按钮。

9856
13:36:12.015 --> 13:36:14.134
我们称之为取款。

9857
13:36:14.134 --> 13:36:20.902
然后在下标中，做同样的事情，复制这个，粘贴到下面。

9858
13:36:20.902 --> 13:36:25.341
drop button是document get

9859
13:36:25.341 --> 13:36:29.965
element by ID，提取按钮，提取按钮。

9860
13:36:29.965 --> 13:36:31.910
点击等于退出。

9861
13:36:31.910 --> 13:36:35.168
下面画一个取款函数。

9862
13:36:35.168 --> 13:36:38.111
我们继续，选择async。

9863
13:36:38.111 --> 13:36:42.689
函数withdraw，会做和我们上面做的完全一样的事情。

9864
13:36:42.689 --> 13:36:49.278
我甚至可以从get balance中复制所有内容然后删除balance部分。

9865
13:36:49.278 --> 13:36:55.695
如果window。Aetherium的类型不等于undefined，那么我们将在这里获取提供者。

9866
13:36:55.695 --> 13:37:00.239
和基金合同一样，我们会抓住签名者和合同。

9867
13:37:00.239 --> 13:37:02.039
我们来看看这两条线。

9868
13:37:02.039 --> 13:37:06.040
将它们粘贴到这里称为signer = provider。get signer。

9869
13:37:06.040 --> 13:37:08.385
合同等于新合同，等等等等。

9870
13:37:08.385 --> 13:37:08.764
好的,很酷。

9871
13:37:08.764 --> 13:37:12.833
现在我们要做的和我们对fun函数做的完全一样。

9872
13:37:12.833 --> 13:37:19.735
我们会做一个try, catch，然后在这里添加catch, catch error, console。log error。

9873
13:37:19.735 --> 13:37:23.978
在try中，我们会写const transaction

9874
13:37:23.978 --> 13:37:30.264
response = await, contractdot withdraw。

9875
13:37:30.264 --> 13:37:33.102
我们不需要在这里添加任何参数。

9876
13:37:33.102 --> 13:37:41.119
哦，然后我们执行一个console。log，退出，然后我们会得到这个事务响应。

9877
13:37:41.119 --> 13:37:44.052
然后我们会听到这个交易是否也被挖掘。

9878
13:37:44.052 --> 13:37:50.024
通过运行Wait, listen for transaction mine,

9879
13:37:50.024 --> 13:37:55.996
transaction response，逗号，provider，就这样了，

9880
13:37:55.996 --> 13:38:02.283
因为我们可以重用listen for transaction mine的功能。

9881
13:38:02.283 --> 13:38:08.061
现在刷新，确保连接，检查当前余额，也就是3。

9882
13:38:08.061 --> 13:38:08.156
8.

9883
13:38:08.156 --> 13:38:11.203
现在我们要撤退了。

9884
13:38:11.490 --> 13:38:15.036
看到正在退出的控制台。log，点击确认。

9885
13:38:15.036 --> 13:38:17.446
看起来我们已经完成了，

9886
13:38:17.446 --> 13:38:24.677
如果我们看我们的Metamask，我们的反弹会增加这里添加的数量。

9887
13:38:24.677 --> 13:38:32.290
如果我们达到平衡，我们确实看到0，我们甚至可以再次检查这个是否有效，我们可以看到余额是9。

9888
13:38:32.290 --> 13:38:32.423
99.

9889
13:38:32.423 --> 13:38:35.839
让我们继续，甚至用99英镑来资助它。

9890
13:38:35.839 --> 13:38:39.013
很好，确认，看起来已经完成了。

9891
13:38:39.013 --> 13:38:41.354
我们的元蒙版现在显示99。

9892
13:38:41.354 --> 13:38:41.523
00.

9893
13:38:41.523 --> 13:38:46.438
如果我们继续取款，确认取款已经完成，

9894
13:38:46.438 --> 13:38:51.627
我们可以看到我们的余额回到了9999。

9895
13:38:51.627 --> 13:38:55.973
现在我们回去换衣服。

9896
13:38:55.973 --> 13:38:57.343
嘿，什么是好东西。

9897
13:38:57.343 --> 13:38:59.601
我们将刷新我们的前端。

9898
13:38:59.601 --> 13:39:08.347
现在我们可以看到你已经做到了，我们已经创建了一个极简的网站，允许我们连接到区块链，并从前端调用功能。

9899
13:39:08.347 --> 13:39:14.523
对于一个网站来说，这绝对是巨大的，你应该为自己感到无比自豪和兴奋。

9900
13:39:14.523 --> 13:39:16.841
这绝对是一个极简的版本。

9901
13:39:16.841 --> 13:39:20.797
我们将使用更强大、更现代的前端框架。

9902
13:39:20.797 --> 13:39:28.441
但是当我们使用这些更高级的前端时，这会让你对幕后发生的事情有一个确切的了解，我们会改进它们的风格。

9903
13:39:28.491 --> 13:39:30.491
它们看起来比这个好一点。

9904
13:39:31.491 --> 13:39:34.694
赛义德，你刚刚了解了这些前端是如何工作的。

9905
13:39:34.694 --> 13:39:36.903
现在你知道了如何把东西往上推，

9906
13:39:36.903 --> 13:39:45.007
我强烈建议你开始把所有这些项目都推到你的GitHub上，它们将是你实际完成工作的记录你已经构建了这些智能合约。

9907
13:39:45.007 --> 13:39:51.765
如果你想获得实习机会，如果你想帮助其他GitHub项目，这将是一个记录，嘿，我能做这个，

9908
13:39:51.765 --> 13:39:58.216
我能做什么，看看我知道怎么做，所以恭喜你的第一个完整的堆栈或你的第一个前端应用程序。

9909
13:39:58.216 --> 13:40:02.118
在我们继续之前，让我们快速复习一下我们在这里学到的所有东西。

9910
13:40:02.118 --> 13:40:06.053
第一，通常，你需要存储库或代码库。

9911
13:40:06.053 --> 13:40:13.473
为了让智能合约的后端与前端是不同的存储库，前端代码将是HTML和JavaScript的组合。

9912
13:40:13.473 --> 13:40:21.157
当我们有一个像meta mask这样的钱包时，我们将这些基于浏览器的钱包注入到浏览器的窗口对象中，比如window。Aetherium。

9913
13:40:21.157 --> 13:40:28.991
每个浏览器在这里都有不同的扩展，我们这样做的原因是，我们想连接到构建在元掩码中的RPC URL。

9914
13:40:28.991 --> 13:40:36.556
以这种方式,我们犯同样的API调用RPC URL和我们一样在安全帽在醚混音为我们所做的,等

9915
13:40:36.556 --> 13:40:44.121
我们创建我们的第一个承诺的基础功能有一个侦听器开始,我们用一个承诺说,嘿,我们要等待侦听器

9916
13:40:44.121 --> 13:40:51.686
来完成,因为这是一个基于承诺的功能,我们设置一个重量侦听交易思想和我们等待这个交易完成,这

9917
13:40:51.686 --> 13:40:59.253
样我们的前端,一旦完成我们的交易经历,我们可以告诉用户它已经完成了我们可以继续做其他事情。

9918
13:40:59.253 --> 13:41:04.412
为自己鼓掌，让我们进入下一个部分。

9919
13:41:04.492 --> 13:41:07.025
好了，欢迎来到下一部分。

9920
13:41:08.492 --> 13:41:16.614
第九，我们的硬帽智能合约抽签，这一节的所有代码都可以在与这门课相关的GitHub回购中找到。

9921
13:41:16.614 --> 13:41:18.427
好了，让我给你们展示一下我们要做的东西。

9922
13:41:18.427 --> 13:41:22.692
我将展示前端登录，如果你不想，你不必做前端登录。

9923
13:41:22.692 --> 13:41:26.599
但前端确实给了我们一个很好的方法来可视化我们正在构建的彩票。

9924
13:41:26.599 --> 13:41:35.015
在这里，我们正在构建一个应用程序，允许用户完全去中心化，允许我们参与一个公平的，可验证的随机抽签。

9925
13:41:35.015 --> 13:41:41.379
这个应用程序可以解决我们之前讨论过的麦当劳问题。

9926
13:41:41.379 --> 13:41:45.965
首先，我们有这个Kinect Wallet按钮，我们会点击它连接到meta mask。

9927
13:41:45.965 --> 13:41:50.404
在这里，我们将展示如何连接到不仅仅是Metamask钱包连接

9928
13:41:50.404 --> 13:41:54.992
到信任钱包，数学钱包，任何这些钱包，我们还会展示如何定制更多。

9929
13:41:54.992 --> 13:41:56.984
所以我们要连接到超面具。

9930
13:41:56.984 --> 13:42:03.224
这里，我们选择从Hardhead导入的账户，选择下一步，选择Connect。

9931
13:42:03.224 --> 13:42:10.158
记住，对于我们的前端位，我们会去设置高级重置帐户，如果我们使用的是全新的安全帽区块链。

9932
13:42:10.158 --> 13:42:13.943
现在，前端看起来不是很好，但我们有一个进入抽奖按钮。

9933
13:42:13.943 --> 13:42:20.262
我们有一个关于当前玩家数量的UI，然后是抽奖中最多的赢家。

9934
13:42:20.262 --> 13:42:25.242
我们可以进入抽奖，允许任何人支付0。

9935
13:42:25.242 --> 13:42:25.742
1容易的。

9936
13:42:25.742 --> 13:42:31.585
要进入智能合约，我们会得到一个小交易说交易完成了，我们得到当

9937
13:42:31.585 --> 13:42:37.429
前玩家的数量是1，我们可以继续参加抽奖任何人都可以参加抽奖。

9938
13:42:37.493 --> 13:42:46.071
智能合约会跟踪所有参与者，我们会在计时器上运行这个，彩票会自动触发某人中奖。

9939
13:42:46.071 --> 13:42:53.880
为了得到一个纯可验证的随机数，我们将使用链链VRF来得到一个纯可验证的随机数。

9940
13:42:53.880 --> 13:42:58.803
然后我们要用链环保持器来触发自动化，

9941
13:42:58.803 --> 13:43:04.001
在每到一个时间间隔时自动选出一个赢家。

9942
13:43:04.001 --> 13:43:10.438
一旦饲养员开始，他们会选出一个中奖者，我们的去中心化彩票会说前一次中奖者是某某人。

9943
13:43:10.493 --> 13:43:15.877
他们将从这个彩票中获得所有的钱这是一个完全公平的去中心化彩票，我们将把我们的合同称

9944
13:43:15.877 --> 13:43:21.393
为raffle。soul但你可以叫它lottery。soul或其他任何你想要的名字。

9945
13:43:21.393 --> 13:43:23.459
我们要让它看起来非常非常漂亮。

9946
13:43:23.459 --> 13:43:25.689
现在我们回到了Visual Studio代码中。

9947
13:43:25.689 --> 13:43:27.262
这将是一个项目。

9948
13:43:27.262 --> 13:43:34.935
如果你学会了这一点，你就有了学习其他所有智能合约概念的技能，你将能够在这个领域做伟大的事情。

9949
13:43:34.935 --> 13:43:43.493
这将是您的旗舰项目，这将是您在本教程中最激动和最自豪的项目。

9950
13:43:43.493 --> 13:43:47.738
我们来创建一个新文件夹。

9951
13:43:47.738 --> 13:43:53.904
我们要做mkdir，硬帽智能合约抽签，FCC或者智能合约抽

9952
13:43:53.904 --> 13:44:00.283
签，随便你怎么叫，然后我们要进入硬帽智能合约抽签免费代码营。

9953
13:44:00.283 --> 13:44:05.624
我们会输入code period，或者我们会在一个新文件夹中打开它，随便你怎么做。

9954
13:44:05.624 --> 13:44:10.461
现在我们在新文件夹中，我们要创建新的安全帽项目。

9955
13:44:10.461 --> 13:44:16.397
所以我们要做纱线，添加破折号dev硬帽。

9956
13:44:16.397 --> 13:44:22.619
我们的节点模块是package。JSON和yarn。lock。

9957
13:44:22.619 --> 13:44:24.114
现在我们来做纱帽。

9958
13:44:24.114 --> 13:44:32.127
开始新项目时，我们会选择create一个空的hard hat。config。js因为我们知道基本项目是什么样子的。

9959
13:44:32.127 --> 13:44:37.327
我们会给这个项目我们想要看到的自定义，我们会创建一个空的hard hat。config。

9960
13:44:37.327 --> 13:44:40.597
现在我们有了一个空白的硬头。

9961
13:44:40.597 --> 13:44:41.114
配置。

9962
13:44:41.114 --> 13:44:43.094
这里几乎什么都没有。

9963
13:44:43.094 --> 13:44:44.822
所以我们完全是从零开始。

9964
13:44:44.822 --> 13:44:47.400
现在我们要把所有的依赖项都加进来。

9965
13:44:47.494 --> 13:44:54.838
通常情况下，你会在构建的过程中依次添加它们但我们只是将它们都添加在一行中，它们有很多。

9966
13:44:54.838 --> 13:45:03.003
我们留下了一个拷贝，粘贴完整的区块链固体性课程js的整个部分，你只需要复制，粘贴，所以你可以一次安装所有东西。

9967
13:45:03.003 --> 13:45:06.332
抓住这条线，它就会包含我们之前讨论过的所有内容。

9968
13:45:06.332 --> 13:45:10.382
按下回车键，就能安装所有这些。

9969
13:45:10.494 --> 13:45:17.528
当您创建越来越多的项目时，您就会知道您喜欢什么依赖项以及您喜欢使用什么工具。

9970
13:45:17.528 --> 13:45:24.178
记住，在一天结束的时候，最适合你和最适合工作的工具是你最喜欢的工具。

9971
13:45:24.178 --> 13:45:29.287
从来没有真正的万能工具，几乎总是会有权衡。

9972
13:45:29.287 --> 13:45:33.930
好了，现在我们已经安装了所有的依赖项，如果我们看一下我们的包，JSON会有大量的

9973
13:45:33.930 --> 13:45:38.690
开发依赖项，我们会在Node模块中有所有的东西在yarn。lock中有所有的东西。

9974
13:45:38.690 --> 13:45:45.427
当然，正如我们所知道的，为了使其中任何一个实际工作，我们需要将它们添加到Hardhead配置中。

9975
13:45:45.494 --> 13:45:48.036
现在，这里也有很多东西要添加进去。

9976
13:45:48.494 --> 13:45:53.193
同样，如果你想在智能合约，彩票，FCC中找到核心，

9977
13:45:53.193 --> 13:46:02.029
然后进入Hardhead配置，你可以复制粘贴所有东西放到你的项目中这样你就不必总是自己打出来。

9978
13:46:02.029 --> 13:46:09.850
Meclabs Hardhead waffle anomic labs开始以太扫描更难部署的分割覆盖，或有气体记者心脏有合同大小，这是我们还没有谈到的。

9979
13:46:09.850 --> 13:46:10.807
但我们会的别担心。

9980
13:46:10.807 --> 13:46:13.057
然后require。env。config。

9981
13:46:13.057 --> 13:46:18.807
你们都知道，所有这些小分号都冒出来了，这简直要把我逼疯了。

9982
13:46:18.807 --> 13:46:21.447
再一次，我们可以创建一个更漂亮的点，RC。

9983
13:46:21.447 --> 13:46:27.995
如果你也想从你以前的项目中复制这个，你可以这么做。

9984
13:46:27.995 --> 13:46:31.628
我在这里添加的一个东西是打印宽度为100。

9985
13:46:31.628 --> 13:46:35.672
这只是改变了一行在转入新行之前的长度。

9986
13:46:35.672 --> 13:46:37.187
这是唯一的区别。

9987
13:46:37.187 --> 13:46:40.806
如果我们点击保存，它们就消失了，谢天谢地。

9988
13:46:40.806 --> 13:46:45.114
现在如果我们看固体度的版本，我们现在用的是0,7。

9989
13:46:45.114 --> 13:46:45.161
3.

9990
13:46:45.161 --> 13:46:47.945
让我们把它更新为8。

9991
13:46:47.945 --> 13:46:48.245
8或8。

9992
13:46:48.245 --> 13:46:49.745
7，或者任何你想用的。

9993
13:46:49.745 --> 13:46:54.600
现在我们已经有了所有的基本设置，我们可以开始编写智能合约了。

9994
13:46:54.600 --> 13:47:03.253
首先，我们需要创建一个新文件夹，叫做contract，用来存储所有的合同。

9995
13:47:03.253 --> 13:47:09.035
我们来创建一个新文件叫lottery。soul或者raffle。soul，随便你怎么叫。

9996
13:47:09.035 --> 13:47:11.219
我要叫我的抽奖。灵魂。

9997
13:47:11.219 --> 13:47:15.341
你可能会看到索引的事情时常发生。

9998
13:47:15.341 --> 13:47:19.695
这是我们的硬帽子，固体扩展，索引所有的节点模块。

9999
13:47:19.695 --> 13:47:24.209
它知道如何高亮显示内容，知道如何处理固体性文件中的所有内容。

10000
13:47:24.209 --> 13:47:26.331
这就是它出现时的情况。

10001
13:47:26.331 --> 13:47:30.066
在我们开始创建它之前，让我们先弄清楚我们要做什么。

10002
13:47:30.066 --> 13:47:32.199
我们要创建抽奖合同。

10003
13:47:32.199 --> 13:47:37.424
我们希望人们能做什么?好吧，我们可能希望人们能够进入彩票，

10004
13:47:37.424 --> 13:47:42.649
你知道，支付一定的金额，我们可能希望能够随机选择一个赢家。

10005
13:47:42.649 --> 13:47:47.446
但我们希望它是可验证的随机的，我们希望它没有被碗篡改过。

10006
13:47:47.496 --> 13:47:52.347
我们还希望每隔X分钟、几年或几个月选出一次

10007
13:47:52.347 --> 13:47:57.430
获胜者，也就是说，我们希望这是完全自动化的。

10008
13:47:57.496 --> 13:48:03.257
所以我们想部署智能合约几乎不需要维护几乎没有人再碰它。

10009
13:48:03.257 --> 13:48:04.737
它会自动一直运行下去。

10010
13:48:04.737 --> 13:48:06.285
这就是智能合约的力量。

10011
13:48:06.285 --> 13:48:12.157
正如我们所知，由于我们选择了一个随机数，并且我们有一些事件驱动的执行，我们知

10012
13:48:12.157 --> 13:48:18.185
道我们将需要使用一个链链接Oracle，因为我们将需要从区块链外部获得随机性。

10013
13:48:18.185 --> 13:48:22.116
我们需要自动执行。

10014
13:48:22.116 --> 13:48:27.733
因为智能合约可以自动执行，所以我们需要有人自动触发这些合约。

10015
13:48:27.733 --> 13:48:31.846
为了触发选择赢家，我们必须使用链链保持器。

10016
13:48:31.846 --> 13:48:34.396
这就是我们的全部代码。

10017
13:48:34.496 --> 13:48:37.254
现在，我通常喜欢在开始任何项目之前这样做。

10018
13:48:37.496 --> 13:48:43.417
我做头脑风暴的原因是，我们不想一开始就什么都不做，我们想对我们要构建的东西有一个很

10019
13:48:43.417 --> 13:48:49.338
好的想法，这样我们就可以为它编写测试，这样我们就可以知道我们的方向是否正确，等等。

10020
13:48:49.338 --> 13:48:53.157
现在我们对我们的目标有了一个很好的想法，让我们构建它。

10021
13:48:53.157 --> 13:48:57.237
按惯例，我们用spdx许可证标识符。

10022
13:48:57.237 --> 13:49:02.972
我的团队会在这里写pragma solidity, 0点8。

10023
13:49:02.972 --> 13:49:10.634
7，甚至缩小，只要一毛毛就会被丢弃我们会说合同，抽奖，我们甚至可以确保我们没有疯掉通

10024
13:49:10.634 --> 13:49:18.297
过做一点纱线Hardhead编译编译成功，我们希望它能够进入彩票希望我们能够进入它。

10025
13:49:18.297 --> 13:49:21.763
也许我们会创建一个函数，叫enter raffle。

10026
13:49:21.763 --> 13:49:25.309
我们还想做什么呢，我们想随机选出一个赢家。

10027
13:49:25.309 --> 13:49:30.684
也许我们可以创建一个函数，随机选择一个赢家。

10028
13:49:30.684 --> 13:49:32.934
现在让我们随便选一个。

10029
13:49:32.934 --> 13:49:35.425
我们来做抽奖的事吧。

10030
13:49:35.425 --> 13:49:40.754
在过去，我们已经创建了像Funmi这样的项目，在那里人们可以向我们的合约发送以

10031
13:49:40.754 --> 13:49:46.221
太币，或者使用基于某些美元价值的消息点值向我们的智能合约发送任何原生区块链令牌。

10032
13:49:46.221 --> 13:49:52.063
对于这款游戏，我们将使用以美元为基础的入场费，这将是本地资产。

10033
13:49:52.063 --> 13:49:56.862
所以对于我们的抽奖，我们不需要设置美元价格，我们只需要设置最低价格。

10034
13:49:56.862 --> 13:50:00.005
在上面，我们取最小价格。

10035
13:50:00.005 --> 13:50:02.339
所以我们要收256的入场费。

10036
13:50:02.339 --> 13:50:07.392
现在我们从上一节学到的一些知识应该用到这里，我们现

10037
13:50:07.392 --> 13:50:12.446
在知道这个入场费将是一个什么，它将是一个存储变量。

10038
13:50:12.497 --> 13:50:17.981
我们在它前面加上s下划线我们设一个私有变量因为我们总想设置可见性。

10039
13:50:17.981 --> 13:50:20.444
但是让我们让入场费是可配置的。

10040
13:50:20.444 --> 13:50:22.441
现在让我们创建一个构造函数。

10041
13:50:22.441 --> 13:50:26.323
我们会在构造函数中设置这个入口费，

10042
13:50:26.323 --> 13:50:34.087
构造函数会取一个UNT 2的6次方入口费，s下划线入口费等于入口费。

10043
13:50:34.087 --> 13:50:38.890
如果我们只设置一次，我们也可以将它设为常数或不可变变量。

10044
13:50:38.890 --> 13:50:44.984
我们把它设为一个不可变变量这样可以节省一些汽油我们把它从S

10045
13:50:44.984 --> 13:50:51.078
换成I现在我们说你面试了6个私人不可变I入场费等于入场费。

10046
13:50:51.078 --> 13:50:54.514
现在我们可能想让其他用户看到入场费。

10047
13:50:54.514 --> 13:50:59.724
在下面，我们可以创建函数get入口费，这将是一个公共视图函数

10048
13:50:59.724 --> 13:51:05.108
它将返回一个UN到集合Next，我们将写入return入口费。

10049
13:51:05.108 --> 13:51:08.514
现在我们有一个功能，用户可以调用它来获取入场费。

10050
13:51:08.514 --> 13:51:13.040
但我们，作为开发者，可以利用AI入场费知道这是一个不可变的变量。

10051
13:51:13.040 --> 13:51:20.103
这是相当便宜的天然气明智的我们读从进入抽奖活动,我们做了大量的这些之前,我们

10052
13:51:20.103 --> 13:51:27.166
需要做的是我们只需要需要消息点值大于我强调入场费,我们之前学到的关于这些错误

10053
13:51:27.166 --> 13:51:34.229
代码,所以我们可以使用需要消息点价值,或者我们可以做其中的一个客户,也就是更

10054
13:51:34.229 --> 13:51:41.294
多的天然气高效,因为不是存储这个字符串,我们只需要在智能合约中存储错误代码。

10055
13:51:41.294 --> 13:51:42.137
我们来做一下。

10056
13:51:42.137 --> 13:51:47.681
相反，我们会说，如果消息点值小于我们的眼睛入口

10057
13:51:47.681 --> 13:51:53.225
费用，那么我们就会用一些错误代码恢复整个交易。

10058
13:51:53.225 --> 13:52:00.924
我们将使用命名raffle的最佳实践。

10059
13:52:00.924 --> 13:52:03.450
我们抓取这个箭头代码。

10060
13:52:03.450 --> 13:52:10.578
如果用户没有发送足够的值将会返回，但没有输入足够的eath现在我们知道他们调用了

10061
13:52:10.578 --> 13:52:17.707
有足够值的raffle，我们可能会想要跟踪所有实际进入我们的raffle的用户。

10062
13:52:17.707 --> 13:52:20.707
这样，当我们选出赢家时，我们就知道谁有希望。

10063
13:52:20.707 --> 13:52:23.921
让我们在顶部错误处创建一个玩家数组。

10064
13:52:23.921 --> 13:52:28.411
然后为了让它看起来更好，我们在这里做一点注释。

10065
13:52:28.411 --> 13:52:29.971
我们说状态变量。

10066
13:52:29.971 --> 13:52:35.022
我们将把存储变量和非存储变量合并到状态变量部分。

10067
13:52:35.022 --> 13:52:37.859
我们会做地址数组播放器。

10068
13:52:37.859 --> 13:52:45.770
当然，玩家必须在存储中，因为我们会经常修改这个，我们会一直加减玩家。

10069
13:52:45.770 --> 13:52:49.958
我们要做的是，s players也会将这个设为私有。

10070
13:52:49.958 --> 13:52:56.514
我们将使这个地址为可支付的玩家因为其中一个玩家赢了，我们将需要支付给他们。

10071
13:52:56.514 --> 13:52:59.728
我们将使这个地址作为玩家的可支付私有。

10072
13:52:59.728 --> 13:53:06.114
既然我们要将这个设为私有，知道谁在播放器数组中是很好的，我们甚至会用函数itplayer。

10073
13:53:06.114 --> 13:53:12.405
这将是一个返回其中一个玩家地址的公共视图。

10074
13:53:12.405 --> 13:53:16.958
我们会返回s players of index会有这个函数，

10075
13:53:16.958 --> 13:53:22.879
取un256 index作为输入参数，我们知道players将是一个存储变量。

10076
13:53:22.879 --> 13:53:29.981
我们会把它加到我们的抽奖中，我们当然希望我们的抽奖是公开的，是可支付的。

10077
13:53:29.981 --> 13:53:35.869
因为我们让人们发送message。value，我们希望任何人都能进入我们的抽奖。

10078
13:53:35.869 --> 13:53:38.467
这将是公共的，可支付的，这将是完美的。

10079
13:53:38.467 --> 13:53:45.963
现在我们有了数组，有人进入了抽奖，我们会写s players。push message。sender。

10080
13:53:45.963 --> 13:53:51.806
这实际上不起作用，因为message。sender不是一个可支付地址。

10081
13:53:51.806 --> 13:53:56.837
因此，我们需要将其类型转换为一个可支付地址，只需将其包装在可支付中。

10082
13:53:56.837 --> 13:54:01.239
现在我们有了一种跟踪所有参加抽奖的玩家的方法。

10083
13:54:01.239 --> 13:54:07.386
我们还没有讲的一个概念是事件。

10084
13:54:07.386 --> 13:54:10.277
事件对我们的智能合约非常重要。

10085
13:54:10.277 --> 13:54:17.911
每当更新动态对象(如数组或映射)时，我们总是希望在小于10时省略一个事件。

10086
13:54:17.911 --> 13:54:26.125
特别是低于15的Jas和if T市场，这些事件将非常有意义，特别是对前端开发者。

10087
13:54:26.125 --> 13:54:30.951
所以现在事件对你来说可能有点奇怪，我们来解释一下。

10088
13:54:30.951 --> 13:54:33.637
但随着我们继续，它们会变得越来越有意义。

10089
13:54:33.637 --> 13:54:36.428
我们将开始向智能合约中添加事件。

10090
13:54:36.428 --> 13:54:39.800
每当我们更新这些动态大小的数据结构之一时。

10091
13:54:39.800 --> 13:54:41.656
并学习更多关于事件和如何使用它们的知识。

10092
13:54:41.656 --> 13:54:44.270
我们将观看另一个解释所有事件的视频。

10093
13:54:44.270 --> 13:54:47.450
你可以把这个视频作为一个副业来学习。

10094
13:54:47.450 --> 13:54:48.921
但是让我们来学习所有的事件。

10095
13:54:48.921 --> 13:54:55.833
现在，如果你用过固体，你可能见过这些叫做事件的东西或者你可能没见过类似事件的东西。

10096
13:54:55.833 --> 13:55:01.221
但你总是想知道链链或图或其他一些链外协议是如何在底层工作的。

10097
13:55:01.221 --> 13:55:08.714
在这个视频中，我们将学习在固体中记录和事件，在以太扫描中查看这些事件，然后在安全帽中使用它们。

10098
13:55:08.714 --> 13:55:11.999
现在是以太坊虚拟机，简称EVM。

10099
13:55:11.999 --> 13:55:15.245
这使得很多区块链能够运行，比如Aetherium。

10100
13:55:15.245 --> 13:55:19.435
EVM有一个叫做日志功能的功能。

10101
13:55:19.500 --> 13:55:24.025
当区块链上发生事情时，EVM将这些东西写到一个叫做它的日志的特

10102
13:55:24.025 --> 13:55:28.696
定数据结构中，我们实际上可以从我们运行的区块链节点读取这些日志。

10103
13:55:28.696 --> 13:55:36.000
事实上，如果您运行一个节点或连接到一个节点，您可以通过F get logs调用来获取日志。

10104
13:55:36.000 --> 13:55:40.008
在这些日志中有一个重要的日志记录，叫做事件。

10105
13:55:40.008 --> 13:55:43.448
这是我们今天要讨论的主要部分。

10106
13:55:43.500 --> 13:55:48.033
事件允许您以一种比实际将信息保存到存储变量

10107
13:55:48.033 --> 13:55:52.567
等更省油的方式将信息打印到日志记录结构中。

10108
13:55:52.567 --> 13:55:58.371
这些事件和日志存在于智能合约无法访问的特殊数据结构中。

10109
13:55:58.371 --> 13:56:04.639
这就是为什么它更便宜的原因，因为智能合约可以访问它们，所以如果在这里权衡，我们仍

10110
13:56:04.639 --> 13:56:10.907
然可以打印一些对我们重要的信息，而不必把它保存在存储变量中，这会占用更多的汽油。

10111
13:56:10.907 --> 13:56:17.501
这些事件中的每一个都与在这些事务中发出该事件的智能合约或帐户地址相关联。

10112
13:56:17.501 --> 13:56:19.839
倾听这些事件非常有帮助。

10113
13:56:19.839 --> 13:56:25.190
举个例子，你想在每次有人调用传递函数时都做些什么。

10114
13:56:25.190 --> 13:56:34.009
而不是总是读取所有的变量并寻找可以翻转和切换的内容，你所要做的就是说，监听事件。

10115
13:56:34.009 --> 13:56:36.551
因此，一个事务发生，一个事件被触发。

10116
13:56:36.551 --> 13:56:38.262
我们可以听这些事件。

10117
13:56:38.262 --> 13:56:40.813
这就是许多链下基础设施的工作方式。

10118
13:56:40.813 --> 13:56:47.049
当你在一个网站上，当一个交易完成时网站会重新加载，它实际上是在监听那

10119
13:56:47.049 --> 13:56:53.286
个交易来完成监听那个事件被触发，这样它就可以重新加载或者做其他事情。

10120
13:56:53.286 --> 13:56:55.957
这对前端非常重要。

10121
13:56:55.957 --> 13:57:01.132
它对链结和链结网络中的图也非常重要。

10122
13:57:01.132 --> 13:57:07.876
链式链接节点实际上监听请求数据事件，以获取随机数、进行API调用等。

10123
13:57:07.876 --> 13:57:10.376
有时候事情太多了。

10124
13:57:10.376 --> 13:57:17.534
你需要以一种有意义的方式为它们建立索引这样你就可以查询以后发生的所有事件。

10125
13:57:17.534 --> 13:57:23.018
图监听这些事件并将它们存储在图中，以便稍后查询。

10126
13:57:23.018 --> 13:57:25.362
所以事件是非常强大的。

10127
13:57:25.501 --> 13:57:26.693
它们有广泛的用途。

10128
13:57:27.501 --> 13:57:30.066
测试和其他一些东西，但你应该能理解。

10129
13:57:30.502 --> 13:57:31.052
真的病了。

10130
13:57:33.502 --> 13:57:38.859
它们是什么样的，我们如何使用它们，以及我们如何在智能合约开发套件中使用它们。

10131
13:57:38.859 --> 13:57:41.312
这就是事件的样子。

10132
13:57:41.312 --> 13:57:43.792
这里有一个事件叫stored number。

10133
13:57:43.792 --> 13:57:47.592
我们有了一种新的事件叫做存储数。

10134
13:57:47.592 --> 13:57:52.251
我们说，嘿，稳健，嘿，智能合约，我们有了这个

10135
13:57:52.251 --> 13:57:56.911
新的事件，我们将省略未来类型化存储数的东西。

10136
13:57:56.911 --> 13:58:01.846
当我们触发这个事件时，它会有这四个参数，它会有一个唯一的256。

10137
13:58:01.846 --> 13:58:02.983
被叫旧号码。

10138
13:58:02.983 --> 13:58:09.028
你感兴趣吗?是新号码吗?你被吓倒了吗?加一个号码和一个地址，叫中心。

10139
13:58:09.028 --> 13:58:17.108
聪明的人可能会注意到这里还有一个关键字，索引到关键字这是一个非常重要的关键字。

10140
13:58:17.108 --> 13:58:22.015
当我们忽略其中一个事件时，有两种形参，即索

10141
13:58:22.015 --> 13:58:27.157
引形参和非索引形参，最多可以有三个索引形参。

10142
13:58:27.157 --> 13:58:28.879
它们也被称为主题。

10143
13:58:28.879 --> 13:58:33.090
如果你看到一个主题，你就知道那将是一个索引参数。

10144
13:58:33.090 --> 13:58:40.295
索引参数是比非索引参数更容易搜索和查询的参数。

10145
13:58:40.295 --> 13:58:46.036
事实上，我们推荐F获取日志功能，它甚至有一个参数允许我们搜索特定的主题。

10146
13:58:46.036 --> 13:58:49.847
所以它比没有索引的更容易搜索。

10147
13:58:49.847 --> 13:58:56.453
没有索引的更难搜索，因为它们是ABI编码的，为了解码它们，您必须了解API。

10148
13:58:56.502 --> 13:59:02.619
现在，它告诉我们的智能合约这里有一种新的存储数字类型，一种新的事

10149
13:59:02.619 --> 13:59:08.928
件类型，我们需要发出该事件以便将数据存储到EVM的日志数据结构中。

10150
13:59:08.928 --> 13:59:12.125
要做到这一点，我们需要做一些像这样的东西。

10151
13:59:12.125 --> 13:59:17.128
这就是我们触发事件时的样子，它看起来与调用函数非常相似。

10152
13:59:17.128 --> 13:59:21.034
你先叫棒球手套，然后是比赛的名字。

10153
13:59:21.034 --> 13:59:24.115
然后把你喜欢的参数都加进去。

10154
13:59:24.115 --> 13:59:30.454
这是一个智能合约的完整例子，它有一个事件，这将是我们在安全帽中讲过的例子。

10155
13:59:30.503 --> 13:59:36.083
在智能合约中，只要有人调用store函数，我们就会省略这个事件。

10156
13:59:36.083 --> 13:59:42.866
这是一个事务的例子，我们调用值为1的store函数，让我们

10157
13:59:42.866 --> 13:59:49.649
看看日志，看看这个事件实际上会是什么样子一个事件会被分解，

10158
13:59:49.649 --> 13:59:56.434
比如契约或帐户的地址，事件从主题发出或事件数据的索引参数。

10159
13:59:56.503 --> 14:00:01.416
这是ABI编码的事件的非索引参数。

10160
14:00:01.503 --> 14:00:07.555
这是什么意思?这意味着我们取那些没有索引的参数，我们将它们与它们的API或

10161
14:00:07.555 --> 14:00:13.608
应用程序二进制接口相匹配，通过编码算法将它们泵入，然后，这就是我们得到的。

10162
14:00:13.608 --> 14:00:16.248
如果你有API，它们很容易解码。

10163
14:00:16.248 --> 14:00:24.875
如果你没有ABI，它们就很难解码这些非索引参数，将更少的气体泵入日志。

10164
14:00:24.875 --> 14:00:29.958
现在在这个特定的合同中，因为我们已经验证了代码，我们验证了合同

10165
14:00:29.958 --> 14:00:35.206
以太扫描知道ABI是什么，我们可以在Deke或解码模式中查看它。

10166
14:00:35.206 --> 14:00:41.440
十六进制模式显然是非解码模式，或者在其原始、十六进制或编码模式中。

10167
14:00:41.503 --> 14:00:45.921
你可以在solidity文档中阅读更多关于这些事件布局的内容。

10168
14:00:45.921 --> 14:00:50.693
这就是事件的基本介绍。

10169
14:00:50.693 --> 14:00:57.279
,对于你们中那些想看剩下的视频,和谁想真正实践自己使用事件,有一个链接到这些视频和视频

10170
14:00:57.279 --> 14:01:03.865
相关的代码库,如果你想玩,如果你想了解更多,所以随时准备参考完整的区块链可靠性,雅,如

10171
14:01:03.865 --> 14:01:10.452
果你想要更深入事件现在我们回来了,我们学到了更多关于事件,让我们添加一些事件来本合同。

10172
14:01:10.504 --> 14:01:15.004
记住，这些事件被发送到智能合约外部的数据存储。

10173
14:01:15.004 --> 14:01:23.237
让我们创建一个名为raffle的事件为命名事件输入一个良好的语法，命名事件，将函数名颠倒。

10174
14:01:23.237 --> 14:01:26.361
对于enter raffle，我们会说raffle entered。

10175
14:01:26.361 --> 14:01:33.004
在状态变量下面的顶部，但在构造函数上面，我们会创建一个叫做events的新部分。

10176
14:01:33.004 --> 14:01:35.754
我们将创建第一个事件。

10177
14:01:35.754 --> 14:01:38.143
我们会做event, raffle, Enter。

10178
14:01:38.143 --> 14:01:44.900
我们让这个raffle enter带一个索引参数，它会是一个地址索引播放器。

10179
14:01:44.900 --> 14:01:48.827
在interraffle中，我们会说省略raffle enter。

10180
14:01:48.827 --> 14:01:51.471
我们将传递它message。sender。

10181
14:01:51.471 --> 14:01:53.585
我现在要删除这些注释。

10182
14:01:53.585 --> 14:01:56.149
但在编写代码时，请随意保留它们。

10183
14:01:56.149 --> 14:02:04.391
现在，在抽奖编码过程的这一部分，我可能已经开始编写一些测试和部署脚本了。

10184
14:02:04.391 --> 14:02:08.453
我们这样做的原因是，它有助于在开发过程中测试我们的功能。

10185
14:02:08.504 --> 14:02:13.627
通常，当我在写智能合约的时候，我经常在部署脚本，合约和

10186
14:02:13.627 --> 14:02:18.941
测试之间来回切换以确保所有事情都完全符合我这门课的目的。

10187
14:02:18.941 --> 14:02:22.722
为了方便你们学习和理解，我们不打算这么做。

10188
14:02:22.722 --> 14:02:30.412
我们将继续编写我们的智能合约，几乎完成，然后转移到部署脚本和测试。

10189
14:02:30.505 --> 14:02:35.130
所以从极简的意义上来说，我们基本上为人们提供了一种参与抽奖的方式。

10190
14:02:35.130 --> 14:02:37.786
现在我们需要一种随机挑选赢家的方法。

10191
14:02:37.786 --> 14:02:41.436
这就是我们需要链链VRF和链链保持者的地方。

10192
14:02:41.436 --> 14:02:45.226
让我们再看一些关于链条VRF的课程。

10193
14:02:45.226 --> 14:02:47.115
学习链链管理员。

10194
14:02:47.115 --> 14:02:49.250
我们之前做过一些相关的视频。

10195
14:02:49.250 --> 14:02:50.718
我们将播放这些视频。

10196
14:02:50.718 --> 14:02:58.387
所以你可以学习到taling VRF版本2是如何工作的，以及链链接保持器是如何工作的，然后我们回来，我们将把它们添加到我们的合同中。

10197
14:02:58.387 --> 14:03:02.241
如果你已经熟悉它们，并且已经玩过它们，请跳过这些部分。

10198
14:03:02.241 --> 14:03:04.398
我们会在这里建造它们。

10199
14:03:04.505 --> 14:03:05.335
嗨，我的名字是史蒂文流体。

10200
14:03:06.505 --> 14:03:08.064
看链环节VRF。

10201
14:03:10.505 --> 14:03:12.117
我们应该注意不同的心智模式。

10202
14:03:12.505 --> 14:03:15.005
向你展示使用它的感觉。

10203
14:03:15.505 --> 14:03:23.105
关于Vera版本2，需要知道的一件重要的事情是，与Vera 1模式不同，您将为与Link的合同提

10204
14:03:23.105 --> 14:03:30.705
供资金，相反，您将为订阅提供资金，这基本上是一个允许您为多个消费者合同提供资金并保持平衡的帐户。

10205
14:03:30.705 --> 14:03:34.695
让我们深入到文档中，看看使用Vera fie two的外观和感觉是怎样的。

10206
14:03:34.695 --> 14:03:36.552
为了展示一下这个。

10207
14:03:36.552 --> 14:03:41.201
我将直接进入链链接文档中的获取随机数指南。

10208
14:03:41.201 --> 14:03:44.739
因此，我们将介绍一些我们今天将要使用的技术的要求。

10209
14:03:44.739 --> 14:03:49.409
它要求我们做的第一件事是确保我们在林克比测试网上。

10210
14:03:49.409 --> 14:03:51.795
让我们跳到林克比。

10211
14:03:51.795 --> 14:03:54.375
确保我的元蒙版在这里解锁。

10212
14:03:54.505 --> 14:04:00.305
现在我在Rinkeby上，很好，我应该可以用VIP版测试网了。

10213
14:04:00.305 --> 14:04:03.521
现在我们要跳到订阅管理器。

10214
14:04:03.521 --> 14:04:07.091
订阅管理器是我们管理订阅帐户的地方。

10215
14:04:07.091 --> 14:04:12.663
基本上，这是你把资金投入的地方以便能够在许多不同的链条上使用它。

10216
14:04:12.663 --> 14:04:17.521
我们将在这里连接我们的钱包以便使用订阅应用。

10217
14:04:17.521 --> 14:04:21.109
然后我们会创建一个新的订阅。

10218
14:04:21.109 --> 14:04:24.589
这里用我的地址作为订阅地址。

10219
14:04:24.589 --> 14:04:26.755
我会批准的。

10220
14:04:26.755 --> 14:04:30.742
一旦交易被确认，我们的订阅就会被创建。

10221
14:04:30.742 --> 14:04:33.360
好了，现在我们有了订阅。

10222
14:04:33.506 --> 14:04:35.472
基本上，这就是我们要资助它的账户。

10223
14:04:35.506 --> 14:04:39.030
然后我们就可以用这个账户处理所有的Miss请求。

10224
14:04:39.030 --> 14:04:44.946
我要在这里放10个链接，你想放多少就放多少。

10225
14:04:44.946 --> 14:04:50.026
你所要求的每个随机数的价格和链接，都将基于

10226
14:04:50.026 --> 14:04:55.349
给定链上的当前汽油价格，以及你所选择的汽油。

10227
14:04:55.349 --> 14:04:58.878
在我们的资金已经添加之后，让我们继续添加一个消费者契约。

10228
14:04:58.878 --> 14:05:02.193
它问我们消费者地址，我们还没有消费者地址。

10229
14:05:02.193 --> 14:05:08.883
让我们继续，跳过文档，创建一个将请求一个数字的契约。

10230
14:05:08.883 --> 14:05:15.215
如果你向下滚动，你会看到Vera向消费者支付的费用这个灵魂契约我们可以在混合中打开它，让我们跳到这里。

10231
14:05:15.215 --> 14:05:19.872
我们会注意到合同顶部有一些不同的东西，我们有一些输入。

10232
14:05:19.872 --> 14:05:27.934
现在你有了VRF，消费者基础版本2，我们有了一个VRF协调器的接口，还有一个链接令牌接口的引用。

10233
14:05:27.934 --> 14:05:32.133
所有这些都是在Rinkeby网络的示例代码中指定的。

10234
14:05:32.133 --> 14:05:36.306
然后您可以参考文档，以了解您要部署到的任何链。

10235
14:05:36.306 --> 14:05:39.768
然后你会在这里看到一些新的选项。

10236
14:05:39.768 --> 14:05:45.828
关键的哈希选项是你指定汽油的方式在文档中有描述。

10237
14:05:45.828 --> 14:05:54.210
根据你为给定链选择的键哈希值对随机数请求设置的气体限制不同。

10238
14:05:54.210 --> 14:05:59.916
举个例子，在一个理论主网上，我们有200个键哈希500个维基哈希和1000个灰键哈希。

10239
14:05:59.916 --> 14:06:04.687
你也可以在我们的合同中看到听说我们有一个回调评估，由你负责。

10240
14:06:04.687 --> 14:06:11.055
根据你想在实现随机数中消耗多少汽油，你应该适当地设置这个值。

10241
14:06:11.055 --> 14:06:13.184
接下来是请求确认。

10242
14:06:13.184 --> 14:06:15.882
所以在验证过程中这是你无法控制的。

10243
14:06:15.882 --> 14:06:23.618
但现在，取决于你所在的链，取决于请求和你想要发出的请求的类型性质，你实际上可以改变这个数字。

10244
14:06:23.618 --> 14:06:28.529
一个最重要和有用的特性它给了你更多的灵活性和

10245
14:06:28.529 --> 14:06:33.664
对VRF的控制你可以指定你想要的随机数的数量。

10246
14:06:33.664 --> 14:06:41.491
所以你指定数字单词，然后这将指定你从网络返回到56的随机数。

10247
14:06:41.491 --> 14:06:47.507
在构造函数中，我们会看到协调器的地址和链接令牌的地址。

10248
14:06:47.507 --> 14:06:51.268
然后您将看到，在部署契约时将创建订阅ID。

10249
14:06:51.268 --> 14:06:53.744
我要把它取下来。

10250
14:06:53.744 --> 14:07:00.607
如果你还记得我们在找到订阅后创建订阅时，我们看到这个订阅ID，现在我部署这个时，我将使用那个订阅ID。

10251
14:07:00.607 --> 14:07:03.229
我们有两个看起来很熟悉的方法，

10252
14:07:03.229 --> 14:07:13.717
一个是随机数实现方法它接收到的随机性将由Oracle局实现，还有一个是请求随机词，这是我们向Oracle发起请求的方式。

10253
14:07:13.717 --> 14:07:16.861
所以我认为我们实际上已经准备好去部署它了。

10254
14:07:16.861 --> 14:07:21.894
所以让我们跳转到部署屏幕，选择正确的合同，在我们的例子中，就是你的FB to consumer。

10255
14:07:21.894 --> 14:07:27.457
我要确保我是在注射web 3上这样我们就可以部署到Rinkeby网络。

10256
14:07:27.507 --> 14:07:29.201
我将粘贴订阅ID到这里。

10257
14:07:29.507 --> 14:07:35.409
在部署之前，让我们继续为事务支付。

10258
14:07:35.508 --> 14:07:40.841
一旦网络确认了，就会显示在这里，我们就能复制这个地址，然后

10259
14:07:40.841 --> 14:07:46.174
以消费者的身份添加这个地址并授权这个合同使用我的订阅帐户。

10260
14:07:46.174 --> 14:07:51.019
让我们继续并授权给他们另

10261
14:07:51.019 --> 14:07:56.269
一个Metamask事务。

10262
14:07:56.508 --> 14:07:59.472
好的，我们可以让你订阅，我们可以看到我们资助了多少链接。

10263
14:07:59.472 --> 14:08:01.032
我们可以看到我们的消费者契约。

10264
14:08:01.032 --> 14:08:07.219
通过这样做，我们授权消费者契约对随机性发出请求。

10265
14:08:07.219 --> 14:08:09.915
让我们继续，在这里要求随机性。

10266
14:08:09.915 --> 14:08:12.721
所以我们要回到我们在这里部署的合同。

10267
14:08:12.721 --> 14:08:16.344
我们将使用这里的remix界面，让事情变得简单。

10268
14:08:16.344 --> 14:08:18.436
我要求一些随机性。

10269
14:08:18.436 --> 14:08:24.974
显然，这将使用我在合同中指定的所有配置，只是硬编码在这里。

10270
14:08:24.974 --> 14:08:26.542
我们会讲到随机的单词。

10271
14:08:26.542 --> 14:08:30.814
所以我们要点击随机请求，确认里格比交易。

10272
14:08:30.814 --> 14:08:36.258
一旦事务返回，我们会注意到我们实际上有一个请求。

10273
14:08:36.258 --> 14:08:41.944
然后我们要做的是等待神使调用合约上的随机数实现。

10274
14:08:41.944 --> 14:08:47.475
然后我们将所有这些随机单词存储在这个随机单词中，存储变量。

10275
14:08:47.475 --> 14:08:50.793
让我们继续检查，看看我们的随机数字是否从Oracle返回。

10276
14:08:50.793 --> 14:08:52.554
我将在这里进入随机单词。

10277
14:08:52.554 --> 14:08:56.901
让我们请求数组的第0项看起来我们得到了一个随机数。

10278
14:08:56.901 --> 14:09:01.697
因为我们要求两个随机数，所以在索引1中也应该有一项。

10279
14:09:01.697 --> 14:09:04.650
好了，我们我们有了随机性。

10280
14:09:04.650 --> 14:09:12.022
如果我们回到订阅管理器应用，你会看到这里有一个事件历史项，我们会看到我们花了第三点，三个链接

10281
14:09:12.022 --> 14:09:19.394
来得到那两个随机数字，我们刚刚经历了一段旅程来看看它是什么样子和感觉使用Veera版本2，现

10282
14:09:19.394 --> 14:09:26.285
在我们已经了解了更多关于链链接VRF的知识，我希望你们能花点时间去doxa chain

10283
14:09:26.285 --> 14:09:34.460
link看看这样你们就能理解到底发生了什么，我们将用这个样本契约来创建我们的函数它将随机选择获胜者。

10284
14:09:34.509 --> 14:09:41.898
这是一个在链上的契约，它与一个可验证的随机链节点相协调，给我们一个随机数，你可以直接在链

10285
14:09:41.898 --> 14:09:49.456
上看代码，或者你可以直接到链上的GitHub看所有的代码，看看这是如何被证明是随机发生的。

10286
14:09:49.509 --> 14:09:52.396
我们会在与这门课相关的GitHub回购中找到这个链接。

10287
14:09:52.396 --> 14:09:58.230
所以我们要在这里创建一个函数叫做随机选择一个赢家，这个函数将

10288
14:09:58.230 --> 14:10:04.259
被链链守护者网络调用这样它就可以自动运行而不需要我们与它交互。

10289
14:10:04.259 --> 14:10:10.526
实际上，当我们更新这个的时候，我想在这里加一些星号表示视图/纯函数。

10290
14:10:10.526 --> 14:10:18.609
现在我们随机选择赢家函数，我们实际上不打算将它设为公共函数我们将设为外部函数，外部函数比公共函数便宜一点。

10291
14:10:18.609 --> 14:10:26.807
因为实体性知道我们自己的契约可以调用它，我们实际上也会改变这个函数的名字，很快，我们会稍微讲到这个。

10292
14:10:26.807 --> 14:10:33.309
为了选出随机赢家，我们需要做两件事，首先我们需要请求随机数。

10293
14:10:33.309 --> 14:10:36.545
一旦我们得到它，就用它做点什么。

10294
14:10:36.545 --> 14:10:39.754
因此链链VRF是一个双事务处理过程。

10295
14:10:39.754 --> 14:10:41.917
这实际上是故意的。

10296
14:10:41.917 --> 14:10:47.450
在两个事务中使用随机数实际上也比在一个事务中使用随机数好得多。

10297
14:10:47.450 --> 14:10:53.583
如果只有一个事务，那么人们可以尝试模拟调用这个事务，我们很快会学

10298
14:10:53.583 --> 14:10:59.716
习如何模拟调用这些事务，看看他们可以操作什么，以确保他们是赢家。

10299
14:10:59.716 --> 14:11:01.440
我们要确保这是绝对公平的。

10300
14:11:01.510 --> 14:11:07.978
没有人能操纵智能合约让他们成为彩票的中奖者，这个函数会请求它。

10301
14:11:07.978 --> 14:11:11.221
然后在第二个函数中，随机数将被返回。

10302
14:11:11.221 --> 14:11:18.700
在我们从链条网络中获得随机数的交易中，也就是我们将钱寄给赢家的时候。

10303
14:11:18.700 --> 14:11:27.004
如果我们去看chain chain的文档，chain chain节点调用的函数是这个函数，这个函数叫fulfillment random

10304
14:11:27.004 --> 14:11:36.408
words，这是请求函数，我们甚至可以把它改成request random winner，让它更清楚，然后我们会让一个函数实现random words。

10305
14:11:36.510 --> 14:11:44.748
这将是一个内部覆盖，我们稍后会解释一下，现在实现随机数实现随机数。

10306
14:11:44.748 --> 14:11:52.331
这个词来自于一个计算机科学术语，但你基本上可以把它看作完全随机数，因为我们可以得到多个随机数。

10307
14:11:52.331 --> 14:11:57.547
现在为了使我们的抽奖合同VRF成为一个碗，我们必须导入链链接代码，

10308
14:11:57.547 --> 14:12:02.923
我们可以回到文档，我们只需要抓取这条底线我们马上会抓取这条上边的线。

10309
14:12:02.923 --> 14:12:06.667
我们要做import，我把它写出来。

10310
14:12:06.667 --> 14:12:13.069
但如果你想复制粘贴，你可以at chain link /合同/ SRC / v0。

10311
14:12:13.069 --> 14:12:17.093
8、斜杠V RF，消费者基数，b二点Sol。

10312
14:12:17.093 --> 14:12:22.940
既然我们导入的是chainlink，斜杠合同，我们需要通过运

10313
14:12:22.940 --> 14:12:28.983
行yarn，添加dash dev在chainlink斜杠合同。

10314
14:12:28.983 --> 14:12:32.646
现在我们有了这个，我们应该可以像这样导入。

10315
14:12:32.646 --> 14:12:41.438
我们需要使我们的抽奖VRF消费者基础加倍，我们需要继承VRF消费者基础进入我们的节

10316
14:12:41.438 --> 14:12:50.445
点模块在链链接src, v08 VRF，消费者基础v2，它带有这个函数实现随机单词。

10317
14:12:50.511 --> 14:12:57.911
你可以看到它是一个内部虚函数，虚意味着它会被覆盖，它在消费者基数v2的范围

10318
14:12:57.911 --> 14:13:05.511
内的原因是VRF协调器，我们待会儿会用到它知道它可以调用这个实现随机词函数。

10319
14:13:05.511 --> 14:13:07.939
这就是我们要重写的函数。

10320
14:13:07.939 --> 14:13:13.752
回到我们的raffle。salt中，我们继承它的方式是VRF消费者基数v2。

10321
14:13:13.752 --> 14:13:21.752
现在如果我们向下滚动到满足随机单词，我们可以添加输入参数满足药丸随机

10322
14:13:21.752 --> 14:13:29.752
单词，这将是un256，请求ID和un256，一个内存数组随机单词。

10323
14:13:29.752 --> 14:13:34.606
如果我们点击Save我们的linter会注意到，这就是我所期望的，

10324
14:13:34.606 --> 14:13:39.461
我期望我们覆盖Fill random words，它接受这些参数。

10325
14:13:39.511 --> 14:13:47.070
现在，如果我们查看文档中的构造函数，我们需要传递VRF消费者基V TOS构造函数，并传递VRF协调器。

10326
14:13:47.070 --> 14:13:52.300
同样，这个V RF协调器是进行随机数验证的契约的地址。

10327
14:13:52.300 --> 14:13:57.530
因此，就在我们的构造函数旁边，将VRF消费者基数V

10328
14:13:57.530 --> 14:14:02.761
添加到构造函数，我们需要传递VRF协调器v2地址。

10329
14:14:02.761 --> 14:14:06.254
在主构造函数中，我们也会把它作为形参添加。

10330
14:14:06.254 --> 14:14:13.251
我们会说地址VRF核心到Nate Torre v2，然后我们会把这个

10331
14:14:13.251 --> 14:14:20.248
作为VRF消费者的参数传递到现在为止我们应该不再看到那个小下划线了。

10332
14:14:20.248 --> 14:14:24.664
我们应该能够运行纱线没有编译。

10333
14:14:24.664 --> 14:14:25.341
太棒了。

10334
14:14:25.512 --> 14:14:30.085
我们可以看到编译成功的两个文件，我们的代码运行良好。

10335
14:14:30.085 --> 14:14:34.946
我经常做的一件事是我讨厌一直运行纱线硬帽，

10336
14:14:34.946 --> 14:14:39.577
因为那对我的小大脑来说有太多的键要处理。

10337
14:14:39.577 --> 14:14:45.226
我想写的键越少越好hard hat也希望我们写的键越少越好。

10338
14:14:45.226 --> 14:14:51.345
所以hard hat附带了一个速记和自动完成的速记是一个NPM包，它安装了一个全局可访

10339
14:14:51.345 --> 14:14:57.465
问的二进制文件，叫做H H，它运行项目的本地安装的硬帽，并支持shell自动完成任务。

10340
14:14:57.465 --> 14:15:02.931
我们能做的是我们会从NPM开始，像这样，但我们会用yarn

10341
14:15:02.931 --> 14:15:08.397
安装它，我们会运行yarn，全局，添加hardhat速记。

10342
14:15:08.512 --> 14:15:15.167
这将会做什么呢，我们可以看到这里安装了hard hat速记和二进制文件H, H和Hardhead补全。

10343
14:15:15.167 --> 14:15:22.489
现在不运行yarn, Hardhead compile，我们仍然可以运行，我们可以只运

10344
14:15:22.489 --> 14:15:29.812
行h h compile，运行h h和我们在本地目录运行Hardhead命令是一样的。

10345
14:15:29.812 --> 14:15:36.308
现在我们需要我们的请求随机赢家函数请求一个随机赢家。

10346
14:15:36.308 --> 14:15:37.795
让我们回到文档中。

10347
14:15:37.795 --> 14:15:39.167
我们来看看怎么做。

10348
14:15:39.167 --> 14:15:43.804
我们可以看看这个请求随机单词的函数，看看它是如何工作的。

10349
14:15:43.804 --> 14:15:45.419
关于协调器地址的Vera。

10350
14:15:45.512 --> 14:15:53.388
我们继续调用这个request random words函数，我们需要在协调器契约上调用这个函数来获得协调器契约。

10351
14:15:53.388 --> 14:15:57.851
我们将使用Vera v2协调器接口和Vir的协调器地址。

10352
14:15:57.851 --> 14:16:00.076
我们要记录下这些。

10353
14:16:00.076 --> 14:16:02.038
我们可以在阿肯色州再次这样做。

10354
14:16:02.038 --> 14:16:05.663
因素，我们有地址被传递给我们的局的消费者基础。

10355
14:16:05.663 --> 14:16:07.939
我们也把它作为一个状态函数。

10356
14:16:07.939 --> 14:16:13.450
首先，让我们得到一个接口，这样我们就可以与合约进行交互，我们也可以从chain

10357
14:16:13.450 --> 14:16:19.669
link导入通过import at chain link /合约/ SRC /费用0。

10358
14:16:19.669 --> 14:16:28.152
8、斜线接口面斜线VRF线到导师V到接口点Sol。

10359
14:16:28.152 --> 14:16:33.453
现在我们导入了这个接口，和价格提要一样，我们

10360
14:16:33.453 --> 14:16:38.754
可以做VRF，协调器v2，接口VRF协调器。

10361
14:16:38.754 --> 14:16:43.490
然后我们可以用地址保存协调器的范围所以我们可

10362
14:16:43.490 --> 14:16:48.442
以说VRF协调器等于这个地址VRF协调器否决。

10363
14:16:48.513 --> 14:16:53.906
我们会把那个地址包装在接口周围这样我们就可以使用这个VRF协调器契约了。

10364
14:16:53.906 --> 14:16:57.893
现在我们只需要在构造函数中设置一次VRF协调器。

10365
14:16:57.893 --> 14:17:02.450
我们能做的最好的事情是，私有的，不可变的。

10366
14:17:02.450 --> 14:17:07.444
好，我们来写private，不可变，你有一个coordinator我们把名字改成I，下划线，

10367
14:17:07.444 --> 14:17:12.873
the ref coordinator这样我们就知道你的coordinator确实是一个不可变变量。

10368
14:17:12.873 --> 14:17:18.020
为了请求随机单词，我们需要给它一些参数，我将把这一行复

10369
14:17:18.020 --> 14:17:23.168
制到我们的契约中，这样我们就能确切地讨论它发生了什么。

10370
14:17:23.168 --> 14:17:25.594
我们不需要AES请求ID。

10371
14:17:25.594 --> 14:17:29.886
我要强调的不是协调，而是对协调的恐惧。

10372
14:17:29.886 --> 14:17:35.989
我们会在VRF协调器契约上调用请求随机词，我们需要给它传递散列键

10373
14:17:35.989 --> 14:17:42.092
或者汽油，我更喜欢叫它汽油通道，我们去链链接，Doc去契约地址。

10374
14:17:42.092 --> 14:17:49.027
我们向下滚动可以看到不同的气体通道不同为不同的网络配置参数是关键散列将是汽油

10375
14:17:49.027 --> 14:17:55.962
的关键哈希,这告诉链条节点的最大价格你愿意支付你的客人和方式例如,如果天然气

10376
14:17:55.962 --> 14:18:03.080
价格飞涨,这是要花费你很多钱,随机数设定一个上限,我们将使它因此随机数不回来。

10377
14:18:03.080 --> 14:18:07.956
为了选择一个气体通道，我们可能需要把这个气体通道或者这个键哈希存储在某个地方。

10378
14:18:07.956 --> 14:18:11.448
我们把它也设为构造函数的形参。

10379
14:18:11.448 --> 14:18:13.415
我们把它保存为状态函数。

10380
14:18:13.514 --> 14:18:19.433
我们用逗号字节32，汽油或键散列，随便你怎么叫。

10381
14:18:19.433 --> 14:18:21.416
然后我们会得到一个新的状态函数。

10382
14:18:21.514 --> 14:18:23.395
我们只设置一次。

10383
14:18:24.514 --> 14:18:27.169
私人的,不可变的。

10384
14:18:33.514 --> 14:18:38.314
汽油就是汽油。

10385
14:18:38.514 --> 14:18:42.447
现在，我们可以把这个换掉，我强调汽油。

10386
14:18:42.514 --> 14:18:48.799
接下来，我们需要一个订阅ID，订阅ID将是我们为请求提供资金所需的订阅。

10387
14:18:48.799 --> 14:18:55.874
实际上链上有一个契约，我们可以用它来为任何这些外部数据或外部计算位的订阅提供资金。

10388
14:18:55.874 --> 14:19:00.418
在这份合同中，有一个订阅列表供人们提出请求。

10389
14:19:00.418 --> 14:19:06.254
我们需要订阅ID用于请求随机数并支付链接Oracl

10390
14:19:06.254 --> 14:19:12.324
e gas，订阅ID也可能是我们将传递给彩票的参数。

10391
14:19:12.324 --> 14:19:15.936
再一次，滚动到构造函数，我们会添加一个新形参。

10392
14:19:15.936 --> 14:19:22.449
我们的订阅ID不需要是un 256，它可以小一点，用un 64。

10393
14:19:22.515 --> 14:19:28.613
我们会传递一个un64订阅ID，我们会创建一个un64。

10394
14:19:28.613 --> 14:19:33.229
因为我们只设置一次所以我们将它设为私有的，不可变的。

10395
14:19:33.229 --> 14:19:38.317
我在下面加下划线，我们写isubscription

10396
14:19:38.317 --> 14:19:43.405
ID = subsubscription ID。

10397
14:19:43.515 --> 14:19:44.276
好的,太棒了。

10398
14:19:46.515 --> 14:19:46.668
ID。

10399
14:19:50.515 --> 14:19:56.925
confirmation是一个UN 16，它表示链链接节点在响应之前应该等待多少个确认。

10400
14:19:56.925 --> 14:20:02.020
如果你发出一个请求，只有一个区块确认，你可能不会发送

10401
14:20:02.020 --> 14:20:07.115
因为你害怕某种区块链重组之类的，我们不会太担心这个。

10402
14:20:07.115 --> 14:20:09.192
实际上我们要让这个常数为3。

10403
14:20:09.192 --> 14:20:14.444
所以我们甚至不用让它是每可摊平的我们要让它是一个常数。

10404
14:20:14.444 --> 14:20:20.150
我们会说，a you int 16 Private constant

10405
14:20:20.150 --> 14:20:28.207
request, confirations = 3，我们在这里用大写字母和下划线表示常量变量。

10406
14:20:28.207 --> 14:20:31.983
现在我们将抓取请求确认并将其插入这里。

10407
14:20:31.983 --> 14:20:39.853
下一个是回调气体限制回调气体限制是回调请求使用的气体量的限制你的契约满足随机单词，

10408
14:20:39.853 --> 14:20:47.915
这设置了随机单词可以满足的计算量的限制这是一个很好的方法来保护我们不消耗太多的气体。

10409
14:20:47.915 --> 14:20:53.989
举个例子，如果我们不小心用一种方式来编码我们的契约，实现随机单词是非常昂贵的。

10410
14:20:53.989 --> 14:20:56.410
它会阻止随机数的响应。

10411
14:20:56.516 --> 14:21:01.791
我们要将这个参数设为相当大因为我们想根据我们如何编码我们的随机数来改变它。

10412
14:21:01.791 --> 14:21:06.349
在构造函数中，我们再加一个，我们会加int 32。

10413
14:21:06.349 --> 14:21:13.434
因为这个的大小是un32回调，气体限制，我们将把

10414
14:21:13.434 --> 14:21:20.816
子顶部保存为un32，私有，不可变，我下划线回调。

10415
14:21:20.816 --> 14:21:21.816
是的限制。

10416
14:21:21.816 --> 14:21:23.982
我们保存这个。

10417
14:21:23.982 --> 14:21:29.815
我回电话限气等于回电话对，限气。

10418
14:21:29.815 --> 14:21:31.922
然后我们拿这个，把它粘在这里。

10419
14:21:31.922 --> 14:21:37.625
好了，我们还有一个数的单词，这就是我们想要得到的随机数，我们只需要一个。

10420
14:21:37.625 --> 14:21:42.177
我们会回到顶部，我们会创建一个你的int 32。

10421
14:21:42.177 --> 14:21:45.661
我们把它也设为私有常数。

10422
14:21:45.661 --> 14:21:48.722
Num个单词等于1，因为我们只需要一个随机数。

10423
14:21:48.722 --> 14:21:55.096
这是我们需要为试管受精协调器添加的最后一件事。request随机单词。

10424
14:21:55.096 --> 14:21:57.374
这个request random

10425
14:21:57.374 --> 14:22:04.778
words函数返回一个请求ID一个256个请求ID一个唯一的ID它定义了谁在请求这个以及所有其他信息。

10426
14:22:04.778 --> 14:22:08.016
如果我们想保存它，我们可以用u和256。

10427
14:22:08.016 --> 14:22:11.583
IVF协调器请求随机单词。

10428
14:22:11.583 --> 14:22:15.141
现在，我们将用这个请求ID发出一个事件。

10429
14:22:15.141 --> 14:22:20.464
我们稍后会讲为什么要这样做，在顶部创建一个新事件。

10430
14:22:20.516 --> 14:22:23.463
这里我们不遵循命名规则。

10431
14:22:23.516 --> 14:22:30.434
因为我们要稍微改变一下函数的名字，我们要调用这个requested raffle winner。

10432
14:22:30.516 --> 14:22:36.183
我们会取一个un256索引的请求ID。

10433
14:22:37.517 --> 14:22:42.093
我们会省略请求的抽奖获胜者请求ID。

10434
14:22:42.517 --> 14:22:46.374
现在我们有了一个函数，我们可以使用链链接VRF来请求一个随机赢家。

10435
14:22:46.374 --> 14:22:51.974
现在，我们要把这个设置好让链链管理员在一个区间上调用它，但我们一会儿再做这个。

10436
14:22:51.974 --> 14:22:56.221
现在，我们来看看得到随机数后要做什么。

10437
14:22:56.221 --> 14:23:01.498
一旦我们得到了这个随机数，我们就想从

10438
14:23:01.498 --> 14:23:06.775
上面的参与者数组中随机选出一个赢家。

10439
14:23:06.775 --> 14:23:09.420
那么我们该怎么办呢?好吧，我们进去吧。

10440
14:23:09.420 --> 14:23:14.199
我们用模块函数随机选一个赢家。

10441
14:23:14.199 --> 14:23:19.588
现在我们会得到一个由随机单词或随机数组成的数组，因为我们只请求一

10442
14:23:19.588 --> 14:23:24.978
个随机单词，这个随机单词数组的大小将是1，其中包含一个随机单词。

10443
14:23:24.978 --> 14:23:26.501
现在这个随机的单词是aun 256。

10444
14:23:26.501 --> 14:23:29.481
所以这个随机的单词可能是这样的。

10445
14:23:29.481 --> 14:23:37.129
显然没有连字符，但也可以是非常大的东西比如我们的players数组只有这么大。

10446
14:23:37.129 --> 14:23:44.285
那么我们如何从这个潜在的巨大随机数中得到一个随机赢家呢，我们可以

10447
14:23:44.285 --> 14:23:51.665
使用模函数，模运算，取N个模，剩下的是在操作数a除以等等等等等等。

10448
14:23:51.665 --> 14:23:57.250
这是什么意思呢?我们可以使用mod函数从玩家数组中获取一个随机数。

10449
14:23:57.250 --> 14:24:01.600
假设我们的players数组。不好意思，我们的s players数组的大小是10。

10450
14:24:01.600 --> 14:24:03.850
一个随机数是200。

10451
14:24:03.850 --> 14:24:09.787
我们如何从玩家数组中随机选出一个人，假设我们的随机数是202。

10452
14:24:09.787 --> 14:24:17.279
如果是202，也就是我们的随机数，对10取余，基本上就是202除以10。

10453
14:24:17.279 --> 14:24:23.354
但是我们不用小数，我们只要问，好，10除以202是多少倍。

10454
14:24:23.354 --> 14:24:28.131
余数是多少，没有被202整除的是什么?

10455
14:24:28.131 --> 14:24:37.184
20乘以10等于200，剩下两个，所以2不能被平均除，或者说除以200。

10456
14:24:37.184 --> 14:24:41.255
也就是说202对10取余等于2。

10457
14:24:41.255 --> 14:24:43.222
这就是模块函数的工作原理。

10458
14:24:43.222 --> 14:24:46.469
我们可以用它来得到一个介于。

10459
14:24:46.518 --> 14:24:54.862
所以我们总是会得到一个0到9之间的数，这很好，因为这很好，因为这是数组中10个人的下标。

10460
14:24:54.862 --> 14:24:56.448
我们在这里用一下。

10461
14:24:56.448 --> 14:25:03.329
我们会说un256的winner索引将等于随机单词，在索引0处，因

10462
14:25:03.329 --> 14:25:10.419
为我们只得到一个随机单词模块，S下划线players。length。

10463
14:25:10.419 --> 14:25:18.097
这将给我们随机赢家的索引来得到赢家的地址将做地址应付，

10464
14:25:18.097 --> 14:25:25.207
最近的赢家等于s个玩家在这个赢家的索引上，太棒了。

10465
14:25:25.207 --> 14:25:32.966
现在我们有了得到这个随机数的人的地址，这个人将是我们可验证的随机赢家。

10466
14:25:32.966 --> 14:25:37.468
现在，向别人吹嘘你是最近的冠军可能有点酷。

10467
14:25:37.518 --> 14:25:42.226
让我们看一下顶部我们为最近的中奖者创建一个新的状

10468
14:25:42.226 --> 14:25:46.934
态变量把这个状态变量放到一个叫做彩票变量的部分。

10469
14:25:46.934 --> 14:25:55.059
我们会说，addressprivate s下划线recent winner它会以nobody开始但当我们

10470
14:25:55.059 --> 14:26:03.184
得到winner时，更新它用s recent winner = recent winner我们可能想让人

10471
14:26:03.184 --> 14:26:11.311
们知道这是谁冬天在下面，我们可以做函数获取recent winner，这将是一个返回那个地址的公共视图。

10472
14:26:11.311 --> 14:26:18.519
然后我们会说，return s下划线recent winner，因为，recent winner将是一个存储变量。

10473
14:26:18.519 --> 14:26:24.011
现在我们有了最近的冠军，我们还能做什么?我们可能会把合同里的钱寄给他们。

10474
14:26:24.011 --> 14:26:31.872
我们要做的和之前送钱一样，我们要做公牛成功，逗号，空白等

10475
14:26:31.872 --> 14:26:39.733
于最近的赢家，调用value，它将是这个点balance

10476
14:26:39.733 --> 14:26:47.876
的地址，我们要把合同中的所有钱都送出去，并不传递任何数据。

10477
14:26:47.876 --> 14:26:53.967
现在我们可以说，要求，你知道，成功，不管怎样，我们会更省气一点。

10478
14:26:53.967 --> 14:27:00.219
我们会说，如果不是success，我们会返回一个新的transfer failed error。

10479
14:27:00.219 --> 14:27:06.635
我们会到顶部，契约的错误名称是raffle，下划线，下划线，transfer failed，像这

10480
14:27:06.635 --> 14:27:13.185
样，然后回到下面，我们可以做revert, raffle transfer failed，像这样。

10481
14:27:13.185 --> 14:27:19.729
现在我们已经选出了获胜者，现在，我们还没有办法跟踪之前的获胜者名单。

10482
14:27:19.729 --> 14:27:21.656
我们要省略一个事件。

10483
14:27:21.656 --> 14:27:25.614
所以总是会有很容易查询的赛事获胜者的双重历史。

10484
14:27:25.614 --> 14:27:31.196
我们会在events部分创建一个新事件叫做event winner chosen。

10485
14:27:31.196 --> 14:27:36.841
这将是一个地址索引赢家。

10486
14:27:36.841 --> 14:27:44.734
向下滚动，我们会看到MIT winner选择了最近的获奖者的地址。

10487
14:27:44.734 --> 14:27:46.376
看起来不错。

10488
14:27:46.520 --> 14:27:47.785
这个看起来不错。

10489
14:27:49.520 --> 14:27:54.790
这里的这个小下划线表示，嘿，这是一个未使用的函数形参，因为我们没

10490
14:27:54.790 --> 14:28:00.060
有使用这个，但我们仍然需要实现随机词来获取请求ID和随机词数组。

10491
14:28:00.060 --> 14:28:04.828
但我们不用Request ID，我们可以注释掉Request

10492
14:28:04.828 --> 14:28:09.596
ID这部分，这告诉我们的函数，我们知道你需要un 256。

10493
14:28:09.596 --> 14:28:11.435
但我们不会使用请求ID。

10494
14:28:11.435 --> 14:28:12.316
我们把它放在这里。

10495
14:28:12.316 --> 14:28:13.770
但我们把它留空。

10496
14:28:13.770 --> 14:28:16.020
现在让我们在这里运行一点编译。

10497
14:28:16.020 --> 14:28:22.651
我们将使用yarn, hard hat, compile，或hh compile，我们将看看编码是否正确。

10498
14:28:22.651 --> 14:28:24.421
实际上，我们没有看到任何错误。

10499
14:28:24.520 --> 14:28:27.091
如此完美，我们可以继续。

10500
14:28:30.520 --> 14:28:34.445
我们有一种方法可以验证得到一个随机赢家。

10501
14:28:34.520 --> 14:28:35.634
这太棒了。

10502
14:28:38.520 --> 14:28:44.389
它只能选择一个可验证的赢家，但它也可以通过编程完成这一切，并

10503
14:28:44.389 --> 14:28:50.454
自动触发选择一个随机赢家基于某个时间间隔，而无需我们与它交互。

10504
14:28:50.454 --> 14:28:51.978
在去中心化的背景下。

10505
14:28:51.978 --> 14:28:59.703
为了让我们根据一些参数自动触发智能合约可能是一个时间参数，可能是某个资产的价格是某个

10506
14:28:59.703 --> 14:29:07.429
数字，可能是流动性池中有一定数量的钱或者任何你想要的触发器，我们可以使用链链保持器。

10507
14:29:07.429 --> 14:29:08.029
为了做到这一点。

10508
14:29:08.029 --> 14:29:12.070
斯蒂文再一次做到了，一个惊人的介绍链守门员。

10509
14:29:12.070 --> 14:29:16.852
所以我们将跟随另一个子视频部分，史蒂文解释链链守护者酱，

10510
14:29:16.852 --> 14:29:21.806
他将使用COVID测试网，但一定要使用文档中的任何测试网。

10511
14:29:21.806 --> 14:29:23.483
当你玩这个，尝试这个的时候。

10512
14:29:23.521 --> 14:29:24.552
我叫史蒂文·冯。

10513
14:29:26.521 --> 14:29:31.975
链链接管理员网络，以使你的合同自动化，并让他们访问链外计算。

10514
14:29:31.975 --> 14:29:33.052
让我们开始吧。

10515
14:29:33.052 --> 14:29:37.133
所以我们今天要看的是我们要从链接文档网页开始。

10516
14:29:37.133 --> 14:29:40.682
如果你向下滚动一点，你会发现使用链链保持器。

10517
14:29:40.682 --> 14:29:45.425
要建立一个完整的智能合约有两个部分。

10518
14:29:45.425 --> 14:29:50.521
首先，你需要通过实现这两个方法来编写一个兼容的智能合约。

10519
14:29:50.521 --> 14:29:55.298
其次，你要注册智能合约以便与通道管理员网络进行维护。

10520
14:29:55.298 --> 14:29:57.816
我们来做这两件事。

10521
14:29:57.816 --> 14:30:02.198
让我们从复制和部署我们已经得到的示例代码开始。

10522
14:30:02.198 --> 14:30:07.078
点击一下就可以混音了，我们看到的是一个非常非常简单的契约。

10523
14:30:07.078 --> 14:30:08.833
这只是一个简单的计数器。

10524
14:30:08.833 --> 14:30:11.208
我们可以看到这里有一个计数器。

10525
14:30:11.208 --> 14:30:13.859
所以它只有一个简单的数字。

10526
14:30:13.859 --> 14:30:22.140
然后你可以指定何时创建契约和更新间隔，然后契约会验证，是否有足够的时间。

10527
14:30:22.140 --> 14:30:23.728
如果有，我们就更新计数器。

10528
14:30:23.728 --> 14:30:32.430
你会注意到chinley兼容或者时间记录网络兼容契约使用了两个非常重要的方法它们是这个时间记录兼容接口的一部分。

10529
14:30:32.430 --> 14:30:38.743
第一个是检查维护，检查维护是特殊的，因为这是发生链外计算的地方。

10530
14:30:38.743 --> 14:30:41.727
这是一个没有在chain上运行的方法。

10531
14:30:41.727 --> 14:30:46.449
这是由一个来自通道保持网络的节点运行的。

10532
14:30:46.449 --> 14:30:51.487
这样做的好处是这里使用的气体不是气体，而是链状的。

10533
14:30:51.487 --> 14:30:53.797
这只是由一个链条节点运行。

10534
14:30:53.797 --> 14:30:58.925
然后发生的是，如果检查维护方法返回，就需要维护。

10535
14:30:58.925 --> 14:31:01.410
然后它将继续执行维护。

10536
14:31:01.410 --> 14:31:05.945
在链上，你可以在链上生成数据，然后传递进来。

10537
14:31:05.945 --> 14:31:07.419
这叫做支票数据。

10538
14:31:07.522 --> 14:31:11.747
然后它就变成了被传递到执行维护的执行数据。

10539
14:31:11.747 --> 14:31:18.183
因此，执行维护方法是你想要验证事情是否正确的地方。

10540
14:31:18.183 --> 14:31:24.332
这些东西实际上应该被修改并在链上运行，然后使状态发生变化。

10541
14:31:24.332 --> 14:31:28.472
所以，让我们继续编译这份合同，并将其部署到COVID网络中。

10542
14:31:28.522 --> 14:31:32.231
让我们继续，在remix中，我们可以做这个编译。

10543
14:31:32.231 --> 14:31:35.763
我们将直接编译和部署到COVID。

10544
14:31:35.763 --> 14:31:42.662
所以动物园管理员网络目前在拍摄这段视频时，可以在COVID和主网的理论上使用。

10545
14:31:42.662 --> 14:31:44.958
我们来玩反合约。

10546
14:31:44.958 --> 14:31:48.970
让我们看看什么没有超过每30秒更新一次。

10547
14:31:48.970 --> 14:31:50.751
让我们继续部署。

10548
14:31:50.751 --> 14:31:55.360
所以meta mask可以要求一点报酬，以便我将这个合同部署到COVID网络。

10549
14:31:55.360 --> 14:31:57.360
看起来是直播的。

10550
14:31:57.360 --> 14:32:02.426
现在我要做的是，我要拿这个保管契约，复制它的地址。

10551
14:32:02.426 --> 14:32:05.722
现在我们要注册维护合同。

10552
14:32:05.722 --> 14:32:13.890
我们将跳到支持冠军守护者网络的应用程序，有几种不同的使用方式，你可以直接与注册表合同交互。

10553
14:32:13.890 --> 14:32:16.475
但是有一个非常非常好的界面可以让你这样做。

10554
14:32:16.475 --> 14:32:21.115
让我们继续注册一个新的维护，它给我一个错误，说你需要连接你的钱包。

10555
14:32:21.115 --> 14:32:22.052
我们来做一下。

10556
14:32:22.052 --> 14:32:25.877
这里我要连接钱包，让它访问我的账户。

10557
14:32:25.877 --> 14:32:29.137
然后，我们就可以注册了。

10558
14:32:29.137 --> 14:32:32.368
这里我要用电子邮件地址。

10559
14:32:32.368 --> 14:32:34.641
我会给我的合同起个简单的名字。

10560
14:32:34.641 --> 14:32:39.877
我会把部署合同上的地址粘贴进来，然后给它加个汽油限额。

10561
14:32:39.877 --> 14:32:45.433
检查数据是一种特殊的东西你可以在同一个合同上注册多个维护通过传递数据来

10562
14:32:45.433 --> 14:32:50.989
指定你希望如何运行checkup keep，我们将忽略这是一个可选的。

10563
14:32:50.989 --> 14:32:59.051
然后我们会给它一个10左右的初始余额，它会继续使用Metamask在网络上注册交易。

10564
14:32:59.051 --> 14:33:06.200
一旦确认了，我的保养费就应该在网络上注册然后用10个链接来启动。

10565
14:33:06.200 --> 14:33:11.785
如果我们继续查看维护，我们可以看到它注册了。

10566
14:33:11.785 --> 14:33:19.321
当下一轮的keeper节点执行时，大概应该是每个块，我们应该看到check

10567
14:33:19.321 --> 14:33:27.470
upkeep方法将返回嘿，upkeep实际上是需要的因为时间戳是30秒之前的。

10568
14:33:27.470 --> 14:33:30.210
然后我们应该继续进行维护。

10569
14:33:30.210 --> 14:33:35.158
在remix中，我可以把它放大，我们可以从契约

10570
14:33:35.158 --> 14:33:40.323
的方法中看到，如果我们检查计数器，它将从0开始。

10571
14:33:40.323 --> 14:33:48.539
只要30秒过去，我们就能再次击中计数器，我们就会看到通道守护者网络按照我的合同执行了维护。

10572
14:33:48.539 --> 14:33:55.803
好了，我们刷新一下，我们看到维护的余额减少了大约01点link。

10573
14:33:55.803 --> 14:34:02.835
我们还应该在我们的合同中看到，我们的计数器现在已经通过执行维护方法调用的证明进行了更新。

10574
14:34:02.835 --> 14:34:10.245
现在我们的柜台显示我们的合同正在被链链管理员网络批准。

10575
14:34:10.245 --> 14:34:12.462
一切都如我们所愿。

10576
14:34:12.462 --> 14:34:17.505
正如你所看到的，创建一个与管理员网络兼容的合同是非常非常容易的。

10577
14:34:17.505 --> 14:34:25.476
很容易登记维护，并开始看到你的合同自动化和期权计算工作完美无缺。

10578
14:34:25.524 --> 14:34:33.805
现在，我们已经学习了更多关于链链接保持器是如何工作的，如果你想花点时间浏览文档，并打开下面的打开和混合按钮。

10579
14:34:33.805 --> 14:34:39.876
你们可以用其中的一个在测试网上自己看看它的作用，请随意，我们

10580
14:34:39.876 --> 14:34:46.151
将使用一个设置非常类似于链条文档中的keepers计数器设置。

10581
14:34:46.151 --> 14:34:52.945
现在让我们更新我们的代码，让这个请求随机数自动发生使用链链接保持器。

10582
14:34:52.945 --> 14:34:58.146
如果我们看一下这个合同的例子就能了解到更多关于这个工作的真正重要的东西。

10583
14:34:58.146 --> 14:35:02.086
我们需要一个检查维护和一个执行维护函数在我们的代码中。

10584
14:35:02.086 --> 14:35:07.238
这不是请求随机赢家，而是我们要改变的执行维护。

10585
14:35:07.238 --> 14:35:11.730
但首先让我们让这个check upkeep checkup keep函数基

10586
14:35:11.730 --> 14:35:16.345
本上是检查我们是否该获取一个随机数来更新最近的赢家并将所有的资金发送给他们。

10587
14:35:16.345 --> 14:35:17.917
我们来创建这个函数。

10588
14:35:17.917 --> 14:35:21.556
我将在这里添加一些注释，以便大家清楚发生了什么。

10589
14:35:21.556 --> 14:35:25.633
也许我还会用natspec来告诉开发者这个函数是怎么回事。

10590
14:35:25.633 --> 14:35:28.839
我们会创建这个函数check upkeep。

10591
14:35:28.839 --> 14:35:35.945
如果我们看看这个需要什么，它需要外部覆盖外部覆盖。

10592
14:35:35.945 --> 14:35:41.474
如果我们看到这个override关键字，这意味着可能在其他地方有一个执行维护。

10593
14:35:41.524 --> 14:35:46.574
如果我们滚动到顶部，我们会导入这个keeper兼容接口，

10594
14:35:46.574 --> 14:35:51.445
这样我们就能确保我们在代码中实现了检查维护和执行维护。

10595
14:35:51.524 --> 14:35:56.270
如果你想，你可以在这里导入keeper compatible或者在代码中导入keeper compatible接口。

10596
14:35:56.270 --> 14:36:04.940
我们要做import at chain link /合约/ SRC / v0。

10597
14:36:04.940 --> 14:36:11.979
8点2接口/ keeper兼容接口这是灵魂现在我们要说契约抽奖

10598
14:36:11.979 --> 14:36:19.018
是Veera消费者基础v2和keeper兼容接口这个keepe

10599
14:36:19.018 --> 14:36:26.287
r兼容接口继承确保我们添加了检查保持和执行维护，我们会添加一点。

10600
14:36:26.287 --> 14:36:33.754
如果我们回头看文档我们可以看到checkup keep接受一个叫做Data check Data的字节作为输入参数。

10601
14:36:33.754 --> 14:36:36.213
我们用的是叫做data的字节。

10602
14:36:36.213 --> 14:36:38.075
检查数据作为参数。

10603
14:36:38.075 --> 14:36:45.328
这个check upkeep字节调用数据允许我们在调用check upkeep函数时指定我们想要的任何东西。

10604
14:36:45.328 --> 14:36:52.259
让这个检查数据为bytes类型意味着我们甚至可以指定它来调用其他函数，有很多高

10605
14:36:52.259 --> 14:36:59.368
级的事情你可以做，只要有一个输入形参作为bytes类型，我们会让它保持简单一点。

10606
14:36:59.368 --> 14:37:01.650
我们不打算用这个校验数据。

10607
14:37:01.650 --> 14:37:05.840
类似于下面我们不使用Request ID，我们可以注释掉它。

10608
14:37:05.840 --> 14:37:10.040
但是，我们仍然需要确保这个参数是名为data的字节类型。

10609
14:37:10.040 --> 14:37:17.223
不管怎样，让我们继续注释这个check upkeep函数，我们

10610
14:37:17.223 --> 14:37:24.639
会说这是一个函数，链链接看守节点调用它们寻找返回true的函数。

10611
14:37:24.639 --> 14:37:30.346
回头看看文档，我们可以看到这个检查upkeep返回和upkeep

10612
14:37:30.346 --> 14:37:37.837
needed和执行数据，同样，我们将忽略这个upkeep needed是真还是假。

10613
14:37:37.837 --> 14:37:42.421
如果它为真，那就意味着是时候获得一个新的

10614
14:37:42.421 --> 14:37:47.235
随机数了，后面的随机数应为真，以便返回真。

10615
14:37:47.235 --> 14:37:52.005
为了让它成为请求随机赢家的时间，应该发生什么，

10616
14:37:52.005 --> 14:37:56.776
我们的时间间隔应该已经过去了，我们还没有定义。

10617
14:37:56.776 --> 14:38:03.052
但我们将彩票应该至少有一个球员，并有一些。

10618
14:38:03.052 --> 14:38:10.367
然后我们的订阅由Link提供资金类似于channeling Vir，如果你的订阅需要由Link提供资金，

10619
14:38:10.367 --> 14:38:17.542
同样的事情需要发生在check upkeep和keepers上，以运行你的订阅需要由Link提供资金。

10620
14:38:17.542 --> 14:38:23.864
现在我们要在这里再添加一个元素，我们说彩票应该处于

10621
14:38:23.864 --> 14:38:30.187
开放状态，这是我们在等待随机数返回时要避免的情况。

10622
14:38:30.187 --> 14:38:32.388
当我们请求一个随机的赢家时。

10623
14:38:32.388 --> 14:38:36.576
从技术上讲，我们处于一种奇怪的状态，我们在等待一个随机的数字返回。

10624
14:38:36.576 --> 14:38:39.052
我们真的不应该允许任何新玩家加入。

10625
14:38:39.052 --> 14:38:43.668
我们要做的是创建一个状态函数告诉我们彩票是否开放。

10626
14:38:43.668 --> 14:38:51.412
在等待随机数返回的过程中，我们会处于封闭或计算状态。

10627
14:38:51.526 --> 14:38:57.746
现在我们可以在契约顶部做的是，我们可以说Boolean private, s下划线是open。

10628
14:38:57.746 --> 14:39:02.473
我们可以把它设为真，如果我们是开放的，否则设为假。

10629
14:39:02.473 --> 14:39:08.797
如果我们有很多不同的状态呢?如果我们想让它像挂起，打开，关闭，

10630
14:39:08.797 --> 14:39:14.714
计算等?我们有很多不同的状态?我们可以把它写成U和256。

10631
14:39:14.714 --> 14:39:16.401
二等兵强调国家。

10632
14:39:16.401 --> 14:39:23.227
我们可以跟踪状态，比如0 b等待，1重新打开，关闭，3，正在计算，等等。

10633
14:39:23.227 --> 14:39:25.737
但这可能有点棘手。

10634
14:39:25.737 --> 14:39:30.795
在我们的代码中，更好的跟踪这些的方法是使用枚举枚举，

10635
14:39:30.795 --> 14:39:35.465
它可以用来创建自定义类型，使用一组有限的常量值。

10636
14:39:35.527 --> 14:39:44.182
例如，我们可以创建一个状态，锁定非活动，这是智能合约的一个新类型，我们会创建一个新类型。

10637
14:39:44.182 --> 14:39:49.871
回到变量的布局，智能合约类型应该是合约的第一项。

10638
14:39:49.871 --> 14:39:52.899
所以我们要创造一个叫做抽奖状态的新状态。

10639
14:39:52.899 --> 14:39:58.713
现在，我们只需要让它是开放的，我们只需要开放或计算。

10640
14:39:58.713 --> 14:40:01.776
当我们创建一个这样的enum时，

10641
14:40:01.776 --> 14:40:09.245
我们在暗中创建一个un256，其中0等于open, 1等于computing。

10642
14:40:09.245 --> 14:40:15.050
然而，这是更明确的，我们知道每一个数字的实际含义。

10643
14:40:15.050 --> 14:40:22.456
现在我们已经创建了这个名为raffle state的新类型，我们可以创建一个类型为raffle state的新彩票状态变量。

10644
14:40:22.527 --> 14:40:27.607
声明其他变量的方法和声明其他变量完全一样，我们将命名它的类型，它将是raffle state。

10645
14:40:27.607 --> 14:40:29.727
这是一个存储变量。

10646
14:40:29.727 --> 14:40:38.246
我们会在构造函数中执行私有s下划线raffle state，当我们启动合约时，我们应该打开这个raffle。

10647
14:40:38.246 --> 14:40:43.442
所以我们说s，抽奖状态等于我们可以用un256。

10648
14:40:43.527 --> 14:40:46.799
像这样包装在类型抽奖状态。

10649
14:40:48.527 --> 14:40:51.060
显式，并说raffle state DOT open。

10650
14:40:52.527 --> 14:40:58.264
抽奖状态处于开放状态，我们只希望检查保持工作，如果彩票实际上是开放的。

10651
14:40:58.264 --> 14:41:02.291
此外，我们可能希望人们只有在法律电池打开的情况下才能进入。

10652
14:41:02.291 --> 14:41:06.949
因此，让我们继续创建另一个if语句，并在彩票未打开时进行还原。

10653
14:41:06.949 --> 14:41:14.323
我们可以说，如果s_ raffle state不等于raffle

10654
14:41:14.323 --> 14:41:23.773
state DOT open，那么我们会返回一个新错误，我们会创建raffle。

10655
14:41:23.773 --> 14:41:29.096
当然，在顶部会产生错误，抽奖不开放。

10656
14:41:29.096 --> 14:41:34.449
另外，当我们请求一个随机单词时，让我们往下看。

10657
14:41:34.528 --> 14:41:38.769
让我们将状态更新为正在计算，这样其他人就不能跳转到这里。

10658
14:41:38.769 --> 14:41:46.259
就在我们的VRF协调器。request上面，random words将做s下划线raffle

10659
14:41:46.259 --> 14:41:55.052
state = raffle state dot计算，这样就没有人能进入我们的彩票，没有人能触发新的更新。

10660
14:41:55.052 --> 14:41:59.522
然后一旦我们完成在我们选出赢家之后，我们

10661
14:41:59.522 --> 14:42:04.217
会说s抽奖状态等于抽奖状态DOT再次打开。

10662
14:42:04.217 --> 14:42:12.232
我们忘记做的另一件事是，在我们从s个玩家中选出胜者后，我们需要重置我们的玩家数组。

10663
14:42:12.232 --> 14:42:18.773
所以让我们在这里添加这些以及players = new address payable。

10664
14:42:18.773 --> 14:42:20.953
大小为0的数组。

10665
14:42:20.953 --> 14:42:23.001
我们会重置抽奖状态。

10666
14:42:23.001 --> 14:42:24.778
我们会重置我们的players数组。

10667
14:42:24.778 --> 14:42:25.528
好了,好了。

10668
14:42:25.528 --> 14:42:31.087
现在我们已经学习了enum，让我们把它添加到这里的checkup keep中，我们会检查这四个东西。

10669
14:42:31.087 --> 14:42:36.997
如果他们都通过了检查键将为真，并将触发链，饲养员请求一个新的随机赢家。

10670
14:42:36.997 --> 14:42:39.575
首先，我们说bool is open。

10671
14:42:39.575 --> 14:42:43.793
它等于抽奖状态。

10672
14:42:43.793 --> 14:42:50.303
打开等于等于s下划线抽奖状态。

10673
14:42:50.303 --> 14:42:55.662
所以你可以认为这个布尔值是开的，如果抽奖状态是开

10674
14:42:55.662 --> 14:43:01.021
的，它将为真，如果抽奖状态是其他状态，它将为假。

10675
14:43:01.021 --> 14:43:01.436
太好了。

10676
14:43:01.529 --> 14:43:04.013
我们还没有打开布尔值，稍后可以检查。

10677
14:43:04.529 --> 14:43:10.329
我们需要吗?我们需要检查时间间隔是否超过好吧，我们还没有时间间隔。

10678
14:43:10.329 --> 14:43:12.306
我们来创建一个时间区间。

10679
14:43:12.306 --> 14:43:17.750
为了检查时间，我们可以使用另一个全局可用的变量block。timestamp

10680
14:43:17.750 --> 14:43:25.918
block那个timestamp返回区块链的当前时间戳来获得当前时间戳，我们需要block。timestamp。

10681
14:43:25.918 --> 14:43:33.988
但要得到如果已经经过了足够的时间，我们需要得到当前block。timestamp减去最后一个block timestamp，这是我们还没有的。

10682
14:43:33.988 --> 14:43:38.195
让我们继续，创建一个状态变量来跟踪上一个块的时间戳。

10683
14:43:38.195 --> 14:43:41.156
这是我们要建立的一个新的状态函数。

10684
14:43:41.156 --> 14:43:43.568
我选u和256。

10685
14:43:43.568 --> 14:43:49.215
私有下划线最后的时间戳。。

10686
14:43:49.529 --> 14:43:57.232
当我们部署这个契约时，我们会用当前时间戳s lasttimestamp = block。timestamp更新这个。

10687
14:43:57.232 --> 14:43:58.560
好的,太棒了。

10688
14:43:58.560 --> 14:44:01.294
现在我们有了最后一个块时间戳。

10689
14:44:01.529 --> 14:44:07.929
但是我们需要检查当前时间戳和上一个时间戳之间的差异是否大于某个间隔。

10690
14:44:07.929 --> 14:44:09.829
我们还需要创建一个区间。

10691
14:44:09.829 --> 14:44:18.196
这是一个间隔，这是以秒为单位的数字表示我们想要等待的时间间隔。

10692
14:44:18.196 --> 14:44:21.142
让我们继续把这个也添加到构造函数中。

10693
14:44:21.142 --> 14:44:22.291
这里加个逗号。

10694
14:44:22.291 --> 14:44:23.751
我们用u和256。

10695
14:44:23.751 --> 14:44:24.322
时间间隔。

10696
14:44:24.322 --> 14:44:32.496
我们将创建另一个全局变量u和256 Private的下划线间隔。

10697
14:44:32.496 --> 14:44:36.130
在构造函数中，我们说s interval = interval。

10698
14:44:36.130 --> 14:44:39.482
interval在我们设置之后不会改变。

10699
14:44:39.482 --> 14:44:45.497
我们不设存储变量，而是设为不可变变量，这样可以省点油。

10700
14:44:45.497 --> 14:44:46.400
好的,完美的。

10701
14:44:46.530 --> 14:44:51.063
现在我们有了所有这些，我实际上创建一个布尔值来检查是否有足够的时间过去。

10702
14:44:51.063 --> 14:44:56.322
我们说布尔时间流逝等于当前块那个

10703
14:44:56.322 --> 14:45:01.910
时间戳减去s下划线last时间戳。

10704
14:45:01.910 --> 14:45:08.702
我们应该检查一下它是否大于i_ interval。

10705
14:45:08.702 --> 14:45:11.330
我们用布尔值检查我们是否打开。

10706
14:45:11.330 --> 14:45:15.482
如果我们是开放的，它就为真，我们会有一个布尔值来判断时间是否足够。

10707
14:45:15.530 --> 14:45:17.545
如果时间足够长，这将是正确的。

10708
14:45:18.530 --> 14:45:21.481
检查?而我们应该检查一下我们是否有足够的玩家。

10709
14:45:21.530 --> 14:45:26.719
我们会写Boolean has players =我们

10710
14:45:26.719 --> 14:45:31.909
会检查s是否下划线players。length大于零。

10711
14:45:31.909 --> 14:45:36.434
如果s players。length大于0，则为真，否则为假。

10712
14:45:36.434 --> 14:45:43.592
我们还会看看是否有余额我们写入Boolean has balance = address。

10713
14:45:43.592 --> 14:45:46.461
这个点结余大于零。

10714
14:45:46.461 --> 14:45:53.330
最后，我们要把所有这些布尔值转化为我们要找的返回变量。

10715
14:45:53.330 --> 14:45:55.711
我们会说Boolean up keep needed。

10716
14:45:55.711 --> 14:46:01.809
等号是开放的，时间流逝了。

10717
14:46:01.809 --> 14:46:07.190
作为玩家和平衡，就像这样，所有这

10718
14:46:07.190 --> 14:46:12.908
些结合在一起就是布尔维持所需要的。

10719
14:46:12.908 --> 14:46:18.343
如果这个返回true，是时候请求一个新的随机数了，是时候结束抽奖了。

10720
14:46:18.343 --> 14:46:22.007
如果这是错误的，现在还不是时候，还不是结束彩票的时候。

10721
14:46:22.007 --> 14:46:29.995
现在，如果我们去chainlink，文档维护需要，实际上需要返回布尔维护需要一些字节内存执行数据。

10722
14:46:29.995 --> 14:46:34.090
我们需要更新我们需要更新这里的函数。

10723
14:46:34.090 --> 14:46:39.431
并返回所需的全部维护，逗号，

10724
14:46:39.431 --> 14:46:44.392
字节内存，执行数据*斜杠。

10725
14:46:44.531 --> 14:46:52.449
因为我们已经初始化了Boolean，在这里保持需要，我们不需要说需要的维护类型在这里。

10726
14:46:52.531 --> 14:46:56.740
因为这将自动返回执行的数据是我们可以使用的东西。

10727
14:46:56.740 --> 14:46:59.580
如果我们想做体检，继续做一些其他的事情。

10728
14:46:59.580 --> 14:47:02.202
这要看检查进展如何了。

10729
14:47:02.202 --> 14:47:03.959
我们真的不需要它做任何其他事情。

10730
14:47:03.959 --> 14:47:05.292
所以我们可以让它保持原样。

10731
14:47:05.292 --> 14:47:05.577
正确的。

10732
14:47:05.577 --> 14:47:13.875
现在我们有了检查维护，我们有了一种方法来检查是否该触发选择彩票或抽奖的随机赢家。

10733
14:47:13.875 --> 14:47:18.433
现在我们已经学习了如何实际执行这个触发器，

10734
14:47:18.433 --> 14:47:22.991
让我们编写在这个返回true后执行的函数。

10735
14:47:22.991 --> 14:47:29.203
这将是我们的执行维护函数，我们可以在chainlink文档中再次看到一个例子。

10736
14:47:29.203 --> 14:47:35.760
现在当要选择一个随机赢家时，实际上，我们要做的是我们要调用这个request random winner函数。

10737
14:47:35.760 --> 14:47:43.290
与其有这个额外的函数，不如把请求随机赢家函数转换成这个执行维护函数。

10738
14:47:43.290 --> 14:47:49.268
一旦check upkeep返回true，链连接节点将自动调用这个执行维护函数。

10739
14:47:49.268 --> 14:47:53.810
在函数request random winner中，我们重命名它来执行维护。

10740
14:47:53.810 --> 14:48:01.339
我们让它接受输入参数bytes，叫作Data，执行数据bytes，叫作Data，执行数据。

10741
14:48:01.339 --> 14:48:03.642
在检查keep中，我们必须执行数据，

10742
14:48:03.642 --> 14:48:11.193
我们会自动将它传递给我们的performance keep，我们不会传递任何东西来执行维护，我们可以像这样将它注释掉。

10743
14:48:11.193 --> 14:48:18.193
由于执行维护实际上是在与管理员兼容的接口中标识的，所以现在必须重写该函数。

10744
14:48:18.193 --> 14:48:21.992
在继续之前，我们要做一点验证。

10745
14:48:21.992 --> 14:48:25.286
因为现在任何人都可以调用我们的执行维护函数。

10746
14:48:25.286 --> 14:48:28.881
我们要确保它只在checkup keep为真时被调用。

10747
14:48:28.881 --> 14:48:33.282
一个简单的方法是调用我们自己的checkup keep函数。

10748
14:48:33.282 --> 14:48:35.467
现在，现在，检查保持它是外部。

10749
14:48:35.467 --> 14:48:38.321
我们不能调用checkup keep函数。

10750
14:48:38.321 --> 14:48:43.532
我们把它改成public这样我们的智能合约也能调用checkup keep函数。

10751
14:48:43.532 --> 14:48:48.752
既然我们已经在执行维护中公开了它，我们就可以调用checkup，继

10752
14:48:48.752 --> 14:48:53.972
续不传递任何东西，然后返回所需的维护和我们并不真正关心的执行数据。

10753
14:48:53.972 --> 14:48:57.938
所以我们会我们会把球举起来。

10754
14:48:57.938 --> 14:49:00.785
我们不关心执行数据。

10755
14:49:00.785 --> 14:49:04.422
我们把这个空着= check up keep。

10756
14:49:04.422 --> 14:49:07.277
然后传递给它一个空白的数据。

10757
14:49:07.277 --> 14:49:11.807
现在，我们要确保这是正确的以便继续研究这个函数。

10758
14:49:11.807 --> 14:49:17.349
我们可以在这里写一个require，但我们会做if not up

10759
14:49:17.349 --> 14:49:24.451
keep needed，然后我们会用一个新的错误来恢复，我们会创建raffle。

10760
14:49:24.533 --> 14:49:25.949
不需要维护。

10761
14:49:29.533 --> 14:49:33.385
这样遇到这个错误的人就能看到为什么会出现这个错误。

10762
14:49:33.385 --> 14:49:37.549
所以我们把合同的余额传过去以防这里没有以太。

10763
14:49:37.549 --> 14:49:41.000
我们将添加players。length，以防没有玩家。

10764
14:49:41.000 --> 14:49:45.464
我们会添加一个un256s下划线抽奖状态。

10765
14:49:45.464 --> 14:49:49.199
确保抽奖真的开了。

10766
14:49:49.199 --> 14:49:57.769
当然，我们需要在顶部空气中创造这种空气，不需要抽奖维护，这将需

10767
14:49:57.769 --> 14:50:06.340
要un 256当前平衡un 256非玩家，你去适合6抽奖状态。

10768
14:50:06.340 --> 14:50:09.713
我们的代码看起来非常专业。

10769
14:50:09.713 --> 14:50:10.499
这太棒了。

10770
14:50:10.499 --> 14:50:17.926
现在我们忘记在fullrandomwords中做的事情因为我们忘记了每次选中赢家时重置时间戳。

10771
14:50:17.926 --> 14:50:25.199
我们还想重置时间戳，这样我们就可以等待另一个时间间隔，让人们参与那个时间间隔的抽奖。

10772
14:50:25.199 --> 14:50:28.307
我们向下滚动到实现随机单词。

10773
14:50:28.307 --> 14:50:32.194
在我们重置之后，玩家也会重置时间戳。

10774
14:50:32.194 --> 14:50:34.920
好的，很好，我想我们差不多完成了。

10775
14:50:34.920 --> 14:50:40.398
让我们添加一点natspec，让它看起来更

10776
14:50:40.398 --> 14:50:45.876
专业，并给正在阅读我们合同的人更多的信息。

10777
14:50:45.876 --> 14:50:51.894
所以让我们在标题处加上标题我们会说一个抽奖合同样本会说作者

10778
14:50:51.894 --> 14:50:57.913
将是我帕特里克·柯林斯或者你也可以在那里写上你自己的名字。

10779
14:50:57.913 --> 14:51:04.518
这个合约是为了创建一个未经篡改的去中心化智能合约。

10780
14:51:04.518 --> 14:51:13.284
然后加上Dev，这实现了链VRF v2，和链keepers。

10781
14:51:13.284 --> 14:51:14.346
好的,太棒了。

10782
14:51:14.346 --> 14:51:22.057
我们有类型声明，我们有状态变量，我们有彩票变量，它们仍然是状态变量，我们有事件。

10783
14:51:22.057 --> 14:51:24.134
现在是我们函数的时间了。

10784
14:51:24.134 --> 14:51:28.596
之后，我们做了一些natspec，至少在检查维护方面。

10785
14:51:28.596 --> 14:51:33.937
如果你想在进入、抽奖、执行维护等方面添加更多的natspec，你完全可以这么做。

10786
14:51:33.937 --> 14:51:37.472
然后在底部，我们有视图/纯getter函数。

10787
14:51:37.472 --> 14:51:43.034
我们看看，这里还需要其他getter函数吗?我们可能想让人们有机会获得抽奖状态。

10788
14:51:43.034 --> 14:51:51.934
我们做一个函数，得到抽奖状态，这将是一个公共，你返回一个抽奖状态。

10789
14:51:51.934 --> 14:52:00.784
我们会说返回s下划线raffle state，我们可能想让人们有机会得到单词数。

10790
14:52:00.784 --> 14:52:04.393
这里跑起来有点有趣。

10791
14:52:04.393 --> 14:52:11.130
如果我们做function，获取num words，公共视图返

10792
14:52:11.130 --> 14:52:17.867
回，你去6个返回num words，你会看到有趣的事情发生了。

10793
14:52:17.867 --> 14:52:21.034
我们打开编译器并运行hh compile。

10794
14:52:21.034 --> 14:52:23.700
希望这里一切正常。

10795
14:52:23.700 --> 14:52:28.470
哦，所有东西都不能用因为我没有正确导入这个。

10796
14:52:28.534 --> 14:52:29.846
让我们来解决这个问题。

10797
14:52:31.534 --> 14:52:33.975
我还错过了几件事。

10798
14:52:35.535 --> 14:52:38.090
这就是为什么当你编译的时候，最好把它编译为players。length。

10799
14:52:38.090 --> 14:52:39.571
让我们再试一次。

10800
14:52:39.571 --> 14:52:42.071
我把interval拼错了。

10801
14:52:42.071 --> 14:52:49.190
我下划线intervol strike再次编译，看看我犯了多少拼写错误。

10802
14:52:49.190 --> 14:52:50.293
就是这样。

10803
14:52:50.293 --> 14:52:55.831
我在error中下划线，然后粘贴它，我们会得到另一个错误。

10804
14:52:55.831 --> 14:53:02.166
函数调用中参数的类型无效，从字面字符串到被请求数据的字节的隐式转换无效。

10805
14:53:02.166 --> 14:53:04.857
因为我们传递的是空字符串。

10806
14:53:04.857 --> 14:53:09.201
checkup keep需要调用data data实际上对字符串不起作用。

10807
14:53:09.201 --> 14:53:11.344
所以我们需要把这个字节变成内存。

10808
14:53:11.344 --> 14:53:13.196
编译器现在对我们很满意。

10809
14:53:13.196 --> 14:53:14.975
我把时间戳拼错了。

10810
14:53:14.975 --> 14:53:19.841
这是小写的s你可能会在Check维护上看到一些潦草的字

10811
14:53:19.841 --> 14:53:24.889
迹，我们可以把这个设为视图函数因为我们没有修改任何状态。

10812
14:53:24.889 --> 14:53:28.535
但是我想公开它的原因我稍后会告诉你们。

10813
14:53:28.535 --> 14:53:32.002
但最后我们得到了我想要的黄色曲线。

10814
14:53:32.002 --> 14:53:37.456
如果我们运行hh compile，我们也应该在编译器中看到一个警告。

10815
14:53:37.535 --> 14:53:39.035
好了，我们看到这些黄色的曲线。

10816
14:53:39.535 --> 14:53:41.535
变量可以保持未赋值。

10817
14:53:43.535 --> 14:53:46.092
因为这是饲养员要找的。

10818
14:53:46.535 --> 14:53:50.502
函数状态可变性可以限制为函数检查键的视图。

10819
14:53:50.502 --> 14:53:55.177
如果你想，你可以创建一个视图，但我将保持它是公开的，原因我稍后会告诉你。

10820
14:53:55.177 --> 14:54:03.355
最后，函数状态可变性可以被限制为纯这就是我想要展示给你们的因为num words实际上

10821
14:54:03.355 --> 14:54:11.724
在字节码中，因为它是一个常量变量技术上来说它不是从存储中读取的，因此这可以是一个纯函数。

10822
14:54:11.724 --> 14:54:18.095
返回num words并不会在存储中读取，它会直接去读取数字1。

10823
14:54:18.095 --> 14:54:24.177
因此，在稳定的情况下获取num个单词num个单词是一个常数变量，它将

10824
14:54:24.177 --> 14:54:30.260
字面上完全相同地说，我们将在这里返回1，我们可能还想获得玩家的数量。

10825
14:54:30.260 --> 14:54:35.328
我们创建一个函数，获取玩家数量。

10826
14:54:35.536 --> 14:54:41.536
这将是一个公共视图，返回一个un256。

10827
14:54:42.536 --> 14:54:44.993
下划线players。length。

10828
14:54:47.536 --> 14:54:49.260
想要最新的时间戳。

10829
14:54:51.536 --> 14:54:52.536
时间戳。

10830
14:54:52.536 --> 14:54:55.980
公共视图在256后返回。

10831
14:54:58.536 --> 14:55:02.925
返回s下划线最后的时间戳。

10832
14:55:05.536 --> 14:55:07.269
要做的请求确认。

10833
14:55:09.536 --> 14:55:10.551
询证函。

10834
14:55:14.536 --> 14:55:22.346
常量函数返回你到56转请求确认。

10835
14:55:22.346 --> 14:55:26.107
好了，我们这里有一些很棒的getter。

10836
14:55:26.107 --> 14:55:33.454
一些视图/纯函数，我们有办法得到一个随机数我们有办法在去中心化的环境中。

10837
14:55:33.536 --> 14:55:34.989
自动自动执行。

10838
14:55:36.536 --> 14:55:40.468
这是一种让人们参加抽奖的方式。

10839
14:55:40.536 --> 14:55:48.036
我们有一个无懈可击的方法来解决创建一个真正公平的分散彩票的问题。

10840
14:55:48.036 --> 14:55:49.107
我的天啊。

10841
14:55:49.107 --> 14:55:53.108
让我们再做一次编译。

10842
14:55:53.108 --> 14:55:54.958
这些只是警告。

10843
14:55:54.958 --> 14:55:56.273
我们可以开始了。

10844
14:55:56.273 --> 14:55:58.800
我们的代码编译成功了。

10845
14:55:58.800 --> 14:56:04.789
就像我说的，通常情况下，这绝对不是你写智能合约的方

10846
14:56:04.789 --> 14:56:10.778
式，几乎不可能写一个完整的智能合约而不犯任何错误。

10847
14:56:10.778 --> 14:56:19.416
不用在文档之间翻来覆去，我自己已经写了很多遍这个合同，但我仍然犯了一大堆错误。

10848
14:56:19.416 --> 14:56:26.216
所以任何人在这个过程中犯错误都是完全合理的。

10849
14:56:26.216 --> 14:56:29.176
并在此过程中使用资源并编写测试。

10850
14:56:29.176 --> 14:56:33.251
现在我们已经创建了我们的抽奖点首尔，是时候添加其他东西了。

10851
14:56:33.251 --> 14:56:39.478
我们会到这里，创建一个新文件夹，并按惯例添加deploy文件夹。

10852
14:56:39.537 --> 14:56:45.072
我们将做我们已经做过几次的事情，我们将创建一些脚本来部署我们的抽奖合同。

10853
14:56:45.072 --> 14:56:52.198
对于我们的抽奖契约，这里有几件事我们要注意第一件事是我们的构造函数现在绝对是巨大的。

10854
14:56:52.198 --> 14:56:56.487
这里有大量的参数需要我们考虑。

10855
14:56:56.537 --> 14:57:00.946
让我们看一下构造函数，看看是否有已经与之交互的契约。

10856
14:57:00.946 --> 14:57:02.519
VRF，协调器v2。

10857
14:57:02.519 --> 14:57:10.070
这是合同地址，入场费，没有汽油，没有订阅ID没有回调，guestimate no和间隔。

10858
14:57:10.070 --> 14:57:10.270
不。

10859
14:57:10.270 --> 14:57:16.214
知道这是一个地址应该是一个提示，我们可能需要部署一些mock。

10860
14:57:16.214 --> 14:57:22.488
为此，因为我们需要与项目外部的VRF协调器合同进行交互。

10861
14:57:22.537 --> 14:57:27.782
但是让我们继续，首先开始我们的抽奖部署脚本，我们知道我们将不得不部署一些模拟。

10862
14:57:27.782 --> 14:57:29.355
我们要记住这一点。

10863
14:57:29.355 --> 14:57:31.037
让我们创建一个新文件。

10864
14:57:31.037 --> 14:57:33.912
哦，第一，部署抽奖。

10865
14:57:33.912 --> 14:57:34.162
js。

10866
14:57:34.162 --> 14:57:39.457
让我们开始部署抽奖合同。

10867
14:57:39.457 --> 14:57:42.331
这看起来和我们之前做过的很像。

10868
14:57:42.331 --> 14:57:43.473
我们在这里再做一遍。

10869
14:57:43.538 --> 14:57:48.089
如果您想使用以前的部署脚本作为参考，我绝对建议您这样做。

10870
14:57:48.089 --> 14:57:54.587
但让我们从exports = async函数的模块开始。

10871
14:57:54.587 --> 14:58:02.905
这需要获得指定的帐户和部署。

10872
14:58:02.905 --> 14:58:08.605
作为输入参数，然后我们用const。

10873
14:58:08.605 --> 14:58:13.557
部署日志等于部署，然后我们会说const，

10874
14:58:13.557 --> 14:58:18.038
部署者，等于await，获取命名帐户。

10875
14:58:18.038 --> 14:58:25.656
让我们进入导出到的配置和更新模块我将复制粘贴这个，因此雇主将默认为账号0

10876
14:58:25.656 --> 14:58:33.487
而玩家将默认为账号1，如果你想把这个写出来，请随时暂停并写出你的名字账号。

10877
14:58:33.487 --> 14:58:36.796
现在，我们的心帽里会有很多样板。

10878
14:58:36.796 --> 14:58:37.183
配置。

10879
14:58:37.183 --> 14:58:37.312
js。

10880
14:58:37.312 --> 14:58:45.792
所以，请随时使用这节课的GitHub回购文件，或之前作为参考编写的名为accounts Deployer的脚本。

10881
14:58:45.792 --> 14:58:53.502
我们还会有一个玩家名帐户，这样我们就可以区分不同的用户或不同的玩家，他们与我们的合同进行交互。

10882
14:58:53.538 --> 14:58:54.961
但现在，我们要抓取部署器。

10883
14:58:56.538 --> 14:58:57.070
开始。

10884
14:58:59.538 --> 14:59:05.177
Raffle = await ploy, Raffle，逗号，

10885
14:59:05.177 --> 14:59:10.454
然后把所有的东西都加进去，对吧?这是来自Deployer。

10886
14:59:10.538 --> 14:59:13.014
参数，我们会有大量的参数。

10887
14:59:14.539 --> 14:59:15.506
回到这个话题。

10888
14:59:15.506 --> 14:59:18.167
然后log就为真。

10889
14:59:19.539 --> 14:59:25.280
需要等待确认，我们需要在Hardhead配置中使用更多的样板文件，我们在这里没有网络。

10890
14:59:25.280 --> 14:59:27.089
我们加上网络信息。

10891
14:59:27.089 --> 14:59:31.233
所以我们可以得到那些区块确认在这里也会是具体的。

10892
14:59:31.233 --> 14:59:35.539
默认网络将是硬帽。

10893
14:59:35.539 --> 14:59:41.426
然后我们会说网络，我们会添加我们的网络信息它将与heart

10894
14:59:41.426 --> 14:59:48.329
hub一起工作，它的链ID是31337英里，我们也会把它放在这里。

10895
14:59:48.329 --> 14:59:56.030
区块确认只设置为这一列，我们还将在林克比网络上进行一些阶段性测试。

10896
14:59:56.030 --> 15:00:02.210
我们将在这里添加溜冰场B，链ID为4，区块确认为6，

10897
15:00:02.210 --> 15:00:08.153
我们需要添加一个URL，然后为URL添加一些帐户。

10898
15:00:08.153 --> 15:00:10.433
我们已经做过100次了。

10899
15:00:10.433 --> 15:00:11.748
我们用const。

10900
15:00:11.748 --> 15:00:18.872
rinky dink可以是RPC URL = process study和v。rake,

10901
15:00:18.872 --> 15:00:25.996
RPC URL，那是私钥，等等，等等，我们将添加所有这些相同的变量从我们的上一个项目。

10902
15:00:25.996 --> 15:00:30.605
我要求大家暂停一下复制粘贴上一个项目中的所有变量。

10903
15:00:30.605 --> 15:00:35.498
因为运行rink, prpc, URL，私钥玉米市值和以太

10904
15:00:35.498 --> 15:00:40.391
扫描，我们还要确保你的文件夹，不好意思，是新文件。env。

10905
15:00:40.391 --> 15:00:44.649
我们会把所有的信息都放到这里我们的rink, prpc,

10906
15:00:44.649 --> 15:00:49.668
URL，私钥，以太扫描API密钥，还有我们的硬币市值API密钥。

10907
15:00:49.668 --> 15:00:54.199
现在我们有了私钥或环prpc URL在URL B

10908
15:00:54.199 --> 15:00:59.298
RPC URL下，对于账户，我们只需要添加那个私钥。

10909
15:00:59.298 --> 15:01:05.155
对于network config。block con，

10910
15:01:05.155 --> 15:01:14.701
我们需要从Hardhead导入network，这看起来像我的VS code自动为我做的。

10911
15:01:14.701 --> 15:01:15.426
谢谢VS code。

10912
15:01:15.426 --> 15:01:17.898
这就是我们抽奖的方式。

10913
15:01:17.898 --> 15:01:21.453
显然，我们有大量的论点需要解释。

10914
15:01:21.453 --> 15:01:22.435
让我们开始吧。

10915
15:01:22.540 --> 15:01:24.830
让我们看看我们的抽奖构造函数，看看我们需要得到什么。

10916
15:01:24.830 --> 15:01:32.082
好的，首先我们需要通过协调器v2得到的东西，我们将使用我们在Funmi项目中使用的相同的策略使用

10917
15:01:32.082 --> 15:01:39.487
模拟，如果我们在开发链上，如果我们在测试网络上，或在活动网络上，使用实际的合同地址，让我们开始吧。

10918
15:01:39.487 --> 15:01:47.095
让我们继续，重新创建那个助手，hardhat config。js并创建那个const。

10919
15:01:47.095 --> 15:01:47.983
网络。

10920
15:01:47.983 --> 15:01:54.149
Config，它等于hard hat，我们将使用mock。

10921
15:01:54.149 --> 15:01:56.258
所以我们现在不需要把它放在这里。

10922
15:01:56.258 --> 15:02:02.444
但是对于溜冰场B，让我们继续，但是这里有一个外国人，所以名字将是Rinkeby。

10923
15:02:02.444 --> 15:02:10.477
我们要去看链链文档，VRF合同，我们要去找林克比的射频协调器。

10924
15:02:10.477 --> 15:02:14.222
测试网，我们会抓取这个地址，把它放在这里，

10925
15:02:14.222 --> 15:02:19.572
我们会说V RF core做了一个8圈V 2，砰，就像这样。

10926
15:02:19.572 --> 15:02:27.407
回到我们的部署抽奖中，我们要选择是否在网络配置中使用vrf协调器v2或者我

10927
15:02:27.407 --> 15:02:35.243
们部署的一些模拟，当然，这导致我们必须部署一个模拟，让我们创建新文件00。

10928
15:02:35.243 --> 15:02:36.665
部署标志。

10929
15:02:36.665 --> 15:02:36.883
js。

10930
15:02:36.883 --> 15:02:43.460
同样的事情，modules exports equals async

10931
15:02:43.460 --> 15:02:49.844
function，它在运行时环境中获取命名帐户和部署，作为它的输入

10932
15:02:49.844 --> 15:02:56.616
变量，或者do const deploy COMM log =部署。

10933
15:02:56.616 --> 15:03:03.365
然后是const, Deployer = await, get named

10934
15:03:03.365 --> 15:03:10.844
accounts, Excel，然后我们会抓取链ID我们只会在开发链上部署这个。

10935
15:03:10.844 --> 15:03:17.023
我们写入const chain ID = network。config。chain ID。

10936
15:03:17.023 --> 15:03:20.420
现在我们只想部署模拟，如果我们在开发链上。

10937
15:03:20.420 --> 15:03:25.069
再一次，我们将进入我们的助手配置，我们将在这里添加那些开发链。

10938
15:03:25.069 --> 15:03:32.741
我们写上const，开发链等于硬帽，还有localhost。

10939
15:03:32.741 --> 15:03:36.541
然后我们要导出这两个。

10940
15:03:36.541 --> 15:03:44.374
因此，模块，点导出，等于网络配置和开发机会。

10941
15:03:44.374 --> 15:03:51.819
在我们的部署模拟中，我们想要抓取那些说const development

10942
15:03:51.819 --> 15:04:00.713
chains，等于require。。斜杠helper hardhat config。

10943
15:04:00.713 --> 15:04:09.168
现在我们可以检查开发链是否包含我们当前所在的网络。

10944
15:04:09.168 --> 15:04:16.902
如果我们在开发链中，我们将继续记录本地网络，即受保护的部署框。

10945
15:04:16.902 --> 15:04:23.037
现在我们必须部署一个模拟VRF协调器，我们在哪

10946
15:04:23.037 --> 15:04:29.439
里得到一个模拟VRF协调器，让我们继续创建一个。

10947
15:04:29.542 --> 15:04:30.961
我们去了链条。

10948
15:04:30.961 --> 15:04:33.090
还是GitHub，我们用的是合约。

10949
15:04:33.542 --> 15:04:33.649
0.

10950
15:04:39.542 --> 15:04:42.491
马赫点索尔，我们将用它作为我们的模拟。

10951
15:04:42.542 --> 15:04:49.269
在合约文件夹中，我们会创建一个新文件test新文件V RF core，

10952
15:04:49.269 --> 15:04:57.727
在一个core中，两个mock。Sol，我们会导入这个mock，让它成为我们的mock。

10953
15:04:57.727 --> 15:05:00.245
我们用spdx。

10954
15:05:00.245 --> 15:05:05.772
我们会做pragma, solidity，胡萝卜0，第8点。

10955
15:05:05.772 --> 15:05:10.309
0，或者7，或者其他我们想要的，我们输入import

10956
15:05:10.309 --> 15:05:15.197
at chainlink /合同/ SRC / v0。

10957
15:05:15.197 --> 15:05:15.311
8.

10958
15:05:15.542 --> 15:05:18.558
斜杠，mock，斜杠VRF。

10959
15:05:23.542 --> 15:05:27.912
我们会检查它是否用Hardhead编译器编译，看起来它也在编译。

10960
15:05:27.912 --> 15:05:28.299
太棒了。

10961
15:05:28.299 --> 15:05:33.620
现在我们有了模拟契约，就可以实际部署它了。

10962
15:05:33.620 --> 15:05:38.293
所以我们做一个权重loi, RF核心de ne

10963
15:05:38.293 --> 15:05:44.186
Tor V到Mach逗号，然后我们在这里给它我们的参数。

10964
15:05:44.186 --> 15:05:45.870
我们会说from Deployer。

10965
15:05:45.870 --> 15:05:50.808
Log是正确的，然后我们来做论证。

10966
15:05:50.808 --> 15:05:54.762
那么VRF协调器v2 Mk的参数是什么呢?

10967
15:05:54.762 --> 15:05:59.673
如果我们打开VRF协调器v2 Mock，就在我们的VS代码中，

10968
15:05:59.673 --> 15:06:06.011
或者在GitHub上，我们实际上可以看到，我们将滚动到构造函数，它需要两个东西。

10969
15:06:06.011 --> 15:06:09.214
它需要一个基本费用和天然气价格的链接。

10970
15:06:09.214 --> 15:06:13.908
第一个是什么?第一个是const基础费用。

10971
15:06:13.908 --> 15:06:19.182
如果我们回到文档，我们可以看到溢价部分是0。

10972
15:06:19.182 --> 15:06:25.123
25链接B，这意味着每个请求的基本费用是0。

10973
15:06:25.123 --> 15:06:27.139
每个请求25个链接。

10974
15:06:27.139 --> 15:06:32.068
所以任何时候我们想在林基上请求一个随机数，它的代价都是0。

10975
15:06:32.068 --> 15:06:32.237
25.

10976
15:06:32.237 --> 15:06:35.118
链接，或者你可以认为它是0。

10977
15:06:35.118 --> 15:06:37.480
25 .甲骨文气提出此请求。

10978
15:06:37.480 --> 15:06:43.846
回到我们的部署模拟中，我们可以说以V为基数等于，我们可以像这里的Rinckey一样执行25，

10979
15:06:43.846 --> 15:06:49.936
等等，等等，或者我们可以执行ethers。utils。parse eath, of 0。

10980
15:06:49.936 --> 15:06:50.132
25.

10981
15:06:50.132 --> 15:06:54.754
我在这里写上注释，设为0。

10982
15:06:54.754 --> 15:06:58.139
25是保险费，成本是0。

10983
15:06:58.139 --> 15:07:00.284
25链接每个请求。

10984
15:07:00.284 --> 15:07:04.076
记住，这个花费为0的原因。

10985
15:07:04.076 --> 15:07:09.193
每个请求25个链接与价格提要相比没有任何成本，因为价格提要。

10986
15:07:09.193 --> 15:07:16.024
如果我们回头看一个链接链，每一个价格提要都是由一组协议赞助的这些协议

10987
15:07:16.024 --> 15:07:22.855
已经为所有这些请求支付了，因为没有赞助商，我们是唯一要求随机性的人，

10988
15:07:22.855 --> 15:07:29.887
我们将是真正赞助得到这个随机数的人，那么第二个东西将是天然气价格链接。

10989
15:07:29.887 --> 15:07:33.376
让我们在这里创建另一个const。

10990
15:07:33.376 --> 15:07:34.626
汽油价格挂钩。

10991
15:07:34.626 --> 15:07:42.797
但这实际上是一个计算值是一个基于链条的天然气价格的计算值。

10992
15:07:42.797 --> 15:07:48.897
举个例子，如果我们在Aetherium上请求一个随机的数字，

10993
15:07:48.897 --> 15:07:54.998
而地球的价格飙升到大约十亿美元，那么天然气将会非常非常昂贵。

10994
15:07:54.998 --> 15:08:02.548
当链结节点响应链结节点支付气费，给我们随机性，并进行外部执行

10995
15:08:02.548 --> 15:08:10.351
时，链结节点实际上是在返回随机性或执行维护等时支付气费的节点。

10996
15:08:10.351 --> 15:08:16.851
如果我们去到我们的raffle。soul，向下滚动执行维护，或实现随机单词，实际上

10997
15:08:16.851 --> 15:08:23.511
是链条节点调用这两个函数并为此支付气体，它们得到Oracle气体支付来抵消这些成本。

10998
15:08:23.511 --> 15:08:29.859
但如果地球的价格，或任何本地区块链的价格暴涨，链条就会连接自己来支付煤气费。

10999
15:08:29.859 --> 15:08:35.172
所以链条节点有一个计算价格每个环节有一个计算变量叫做天然

11000
15:08:35.172 --> 15:08:40.486
气价格，它根据实际链条的价格波动，所以它们永远不会破产。

11001
15:08:41.544 --> 15:08:46.415
基本上，一个请求的价格是根据那个区块链的汽油价格变化的，你可以把这想

11002
15:08:46.415 --> 15:08:51.431
成是每个汽油的链接，如果你愿意，现在我们可以把它设为我们想要的任何值。

11003
15:08:51.431 --> 15:08:58.169
我们把它设为1123456789，也就是1123456789。

11004
15:08:58.169 --> 15:09:03.481
现在我们有了基本费用和汽油价格链接，我们会抓取这个基本费用，

11005
15:09:03.481 --> 15:09:11.450
我们会让这些作为VR和弦的参数，输入V来模拟，我们会说实际上我们可以删除它会说const,

11006
15:09:11.450 --> 15:09:18.889
args等于基本费用，汽油价格链接，然后我们可以取这个args变量，把它放到这里。

11007
15:09:18.889 --> 15:09:25.556
现在我们可以执行log mocks deployed，然后我们可以执行log这一行像这样让人们

11008
15:09:25.556 --> 15:09:32.223
知道deploy脚本已经完成，然后我们将执行一个导出。tags = all和mocks的模块。

11009
15:09:32.223 --> 15:09:40.732
现在我们已经部署了协调器v2 Mock的视图，我们将回到抽奖环节，并围绕它编写一些代码。

11010
15:09:40.732 --> 15:09:43.945
与我们刚刚对部署模拟所做的类似。

11011
15:09:43.945 --> 15:09:50.254
我们可以说，如果开发链包含network。name，我们会做一些事情。

11012
15:09:50.254 --> 15:09:54.303
我们需要从我们的助手Hardhead配置中导入开发链。

11013
15:09:54.303 --> 15:09:56.839
我们需要从安全帽导入网络。

11014
15:09:56.839 --> 15:09:59.708
我的VS code自动添加了他们哇，谢谢VS code。

11015
15:09:59.708 --> 15:10:02.883
我们用const args把这个变量设为下面这里。

11016
15:10:02.883 --> 15:10:03.811
插入参数。

11017
15:10:03.811 --> 15:10:11.891
我们的第一个参数需要是这个Vera fi to coordinator让我们创建一个

11018
15:10:11.891 --> 15:10:20.165
变量让VRF core需要torby来处理如果我们在开发链上，我们会抓取那个模拟契约。

11019
15:10:20.165 --> 15:10:27.891
所以我们会说const PRF, Cor de ATAR V to mock等于await

11020
15:10:27.891 --> 15:10:36.132
ether。get contract, RF连线到NATO Tor的连线V两个MK，然后我们可以

11021
15:10:36.132 --> 15:10:44.375
以设置RF协调器V两个地址等于VRF core denater V两个mach。address。

11022
15:10:44.375 --> 15:10:44.968
酷。

11023
15:10:44.968 --> 15:10:48.052
我们这里有地址。

11024
15:10:48.052 --> 15:10:52.732
否则，如果我们不在本地网络上，VRF v2协

11025
15:10:52.732 --> 15:10:57.412
调器地址将简单地从我们的网络配置中派生出来。

11026
15:10:57.412 --> 15:11:02.987
所以让我们也从我们的助手Hardhead配置中导入网络配置，

11027
15:11:02.987 --> 15:11:08.562
我们会说else VRF协调器v2地址等于链ID的网络配置。

11028
15:11:08.562 --> 15:11:14.416
不好意思，我们需要chain ID。chain ID = network。

11029
15:11:14.416 --> 15:11:21.062
config。chain ID, VR协调器V的chain ID到chain ID。

11030
15:11:21.062 --> 15:11:23.675
你是协调者v2。

11031
15:11:23.675 --> 15:11:24.771
好的,完美的。

11032
15:11:24.771 --> 15:11:28.627
我们已经得到了与VRF协调器v2地址一起工作的设置。

11033
15:11:28.627 --> 15:11:33.486
我们的抽奖还需要什么?我们需要入场费，我们可能会根据我们所在的连

11034
15:11:33.486 --> 15:11:38.498
锁店改变入场费，我们在一个更贵的连锁店，我们可能会让它比其他的高。

11035
15:11:38.546 --> 15:11:43.754
让我们回到我们的助手Hardhead配置并基于区

11036
15:11:43.754 --> 15:11:48.962
块链设置入口费用，对于NP，也许我们想让它为0。

11037
15:11:48.962 --> 15:11:49.545
01容易的。

11038
15:11:49.545 --> 15:11:54.201
所以我们可以说，ethers。utils, parse ether (0)

11039
15:11:54.201 --> 15:11:54.407
01.

11040
15:11:54.407 --> 15:12:00.336
再次感谢VS code为我自动添加这个。

11041
15:12:00.336 --> 15:12:07.283
我们还需要心脏应用的入口费，我们还可以在这里设置默认值，让我们更明确一点。

11042
15:12:07.283 --> 15:12:08.817
所以我们写31337。

11043
15:12:08.817 --> 15:12:15.923
这个的名字是Art app，我们不需要给它一个协调器v2地址因为我们会部署一个模拟。

11044
15:12:15.923 --> 15:12:17.447
但我们要收入场费。

11045
15:12:17.546 --> 15:12:20.084
我们给它同样的入场费。

11046
15:12:20.546 --> 15:12:22.958
写入ethers。utils。parse ether 0。

11047
15:12:22.958 --> 15:12:23.211
01 E。

11048
15:12:23.211 --> 15:12:24.163
好了,好了。

11049
15:12:24.546 --> 15:12:27.059
在这里的部署中，

11050
15:12:27.059 --> 15:12:33.659
我们可以说const入口费用等于网络配置。

11051
15:12:33.659 --> 15:12:37.433
门票链ID。

11052
15:12:37.433 --> 15:12:40.654
让我们开始填充弧线。

11053
15:12:40.654 --> 15:12:43.301
第一个是fe2协调器地址。

11054
15:12:43.301 --> 15:12:44.777
下一个是入场费。

11055
15:12:44.777 --> 15:12:45.930
明白了吗?明白了。

11056
15:12:45.930 --> 15:12:47.853
现在我们需要加油道。

11057
15:12:47.853 --> 15:12:54.199
在Rigby和其他网络上，我们可以选择不同的汽油通道，让我们从Rinckey获取唯一的汽油通

11058
15:12:54.199 --> 15:13:00.545
道，30，灰色的散列键，让我们把这个，当然，放到我们的网络配置中作为汽油，把它放在这里，我们

11059
15:13:00.545 --> 15:13:07.030
是硬帽子，我们的mock实际上并不关心我们在什么汽油通道上工作，因为我们无论如何都会模拟汽油。

11060
15:13:07.030 --> 15:13:12.772
所以我们可以说gas lane，我们可以继续使用相同的或者其他的，这并不重要。

11061
15:13:12.772 --> 15:13:18.427
这里我们说const，汽油等于网络配置。

11062
15:13:18.547 --> 15:13:22.598
链证，汽油，我们去加油通道。

11063
15:13:23.547 --> 15:13:27.710
把它插入参数数组，我们有这个，有这个，还有这个。

11064
15:13:27.710 --> 15:13:29.637
现在是订阅ID的时候了。

11065
15:13:29.637 --> 15:13:36.684
如果你还没读过docstoc chain link关于chain link VRF，我强烈建

11066
15:13:36.684 --> 15:13:43.731
议你读一下这样你就能理解这个订阅ID是什么我们知道我们可以通过前端创建订阅ID通过这个网站V

11067
15:13:43.731 --> 15:13:50.932
RF。chain。link，这很好但如果我们在所有本地链上，我们可以在这里获得订阅ID没问题。

11068
15:13:50.932 --> 15:13:53.756
但在本地网络上就有点难了。

11069
15:13:53.756 --> 15:13:58.333
现在我要教你如何创建和资助订阅这完全是程序化的。

11070
15:13:58.333 --> 15:14:01.186
如果你不想，你甚至不需要使用UI。

11071
15:14:01.186 --> 15:14:08.297
然而，这门课的目的是，我们仍然会使用用户界面，我们仍然会使用那个网站来获取我们自己的订阅id。

11072
15:14:08.297 --> 15:14:13.835
但是您可以100%自动化创建订阅ID和资助订阅ID的过程。

11073
15:14:13.835 --> 15:14:20.984
因为当你创建和资助订阅id时，你只是在智能合约上调用create subscription和fund subscription。

11074
15:14:20.984 --> 15:14:29.354
在我们的开发链上，我们有vrf协调器v2 Mock，我们要做的是在我们的开发链上，我们要创建那个订阅。

11075
15:14:29.354 --> 15:14:35.333
我们会说const transaction response = await

11076
15:14:35.333 --> 15:14:41.785
VRF coordinator v2 Mock。create subption。

11077
15:14:41.785 --> 15:14:46.969
然后我们运行const transaction receipt =

11078
15:14:46.969 --> 15:14:54.039
weight trends action response。Wait，等待一个区块确认。

11079
15:14:54.039 --> 15:14:58.874
在这个事务接收中，我们可以通过订阅发送一

11080
15:14:58.874 --> 15:15:03.709
个事件这是另一个发送事件非常有用的地方。

11081
15:15:03.709 --> 15:15:11.305
事实上，如果我们打开一个Vera v2协调器标记，我们寻找create subscription，我们看到我们

11082
15:15:11.305 --> 15:15:18.902
用subscription ID创建了subscription，我们实际上可以从我们的事务收据中获得这个事件。

11083
15:15:18.902 --> 15:15:23.214
现在要分配它，让我们在这里创建一个子订阅ID。

11084
15:15:23.214 --> 15:15:28.268
然后我们说订阅ID = transaction

11085
15:15:28.268 --> 15:15:34.203
receipt events。args。subid。

11086
15:15:34.203 --> 15:15:40.698
如果您想了解更多关于如何在硬件中使用事件的知识，请务必观看事件视频。

11087
15:15:40.698 --> 15:15:47.863
现在我们有了订阅，我们需要在真实的网络上为订阅提供资金，您需要链接令牌来实际为订阅提供资金。

11088
15:15:47.863 --> 15:15:52.259
模拟的当前迭代允许您在没有链接令牌的情况下资助订阅。

11089
15:15:52.259 --> 15:16:00.279
我们能做的是运行一个F君标，如果协调器B到Mach。基金订阅，

11090
15:16:00.279 --> 15:16:07.781
我们给它一个订阅ID我们需要做一些基本的这个，我们可以创建

11091
15:16:07.781 --> 15:16:12.179
些变量，我们说const VRF，

11092
15:16:12.179 --> 15:16:24.082
订阅基金金额等于ethers。utils。parse ether，我们说30 VRF订阅。

11093
15:16:24.082 --> 15:16:26.215
我们把它粘贴到这里。

11094
15:16:26.215 --> 15:16:29.310
我们也可以在真实的测试网络或直播网络中这样做。

11095
15:16:29.310 --> 15:16:34.735
但是为了让我们熟悉用户界面，我们不打算用编程的方式做一个测试网。

11096
15:16:34.735 --> 15:16:37.725
对于测试网，我们将使用到目前为止我们所做的。

11097
15:16:37.725 --> 15:16:41.059
或者我们可以添加订阅ID和助手配置。

11098
15:16:41.059 --> 15:16:47.303
我们写入订阅ID，我们在这里放一些东西，让它为零。

11099
15:16:47.303 --> 15:16:52.715
但稍后，当我们实际创建订阅时，我们将更新订阅ID。

11100
15:16:52.715 --> 15:16:58.456
订阅ID等于网络配置。

11101
15:16:58.456 --> 15:17:02.471
更改订阅ID的ID。

11102
15:17:02.471 --> 15:17:03.578
完美的。

11103
15:17:03.578 --> 15:17:07.715
现在我们可以把它添加到arguments数组中。

11104
15:17:07.715 --> 15:17:15.049
我们还需要订阅ID吗，我们需要一个回调气体限制或者回调，气体限制会因网络而异。

11105
15:17:15.049 --> 15:17:18.972
再一次，我们要进入辅助配置回调气体限制。

11106
15:17:18.972 --> 15:17:23.844
对我们来说，我们设定的上限是50万汽油。

11107
15:17:23.844 --> 15:17:27.286
我们设气体极限是5。

11108
15:17:27.286 --> 15:17:28.367
123年500000年。

11109
15:17:28.367 --> 15:17:28.760
气体。

11110
15:17:28.760 --> 15:17:31.430
对于安全帽，我们做同样的事情。

11111
15:17:31.430 --> 15:17:37.018
我们可以说const，回调，gas limit = network

11112
15:17:37.018 --> 15:17:44.470
config, chain ID，回调，gas limit，抓取这个，放到参数数组中。

11113
15:17:44.550 --> 15:17:47.200
我们还需要什么?我们现在需要的是区间。

11114
15:17:47.550 --> 15:17:50.397
也可以将这个网络更改为网络。

11115
15:17:51.550 --> 15:17:57.050
对于hard hat和Rigby来说，间隔将只有30秒。

11116
15:17:57.050 --> 15:17:58.827
我们在这里做同样的事情。

11117
15:17:58.827 --> 15:17:59.382
表示常量。

11118
15:17:59.550 --> 15:18:03.484
间隔等于网络配置。

11119
15:18:07.550 --> 15:18:10.856
拿上这个，放到数组的最后。

11120
15:18:12.550 --> 15:18:15.946
现在我们有了一个参数数组，把它放在这里，很好。

11121
15:18:15.946 --> 15:18:18.963
抽奖合同构造函数里的所有东西。

11122
15:18:18.963 --> 15:18:19.273
太好了。

11123
15:18:19.273 --> 15:18:20.617
这看起来棒极了。

11124
15:18:20.617 --> 15:18:24.683
我们有等待确认我们有日志参数Deployer。

11125
15:18:24.683 --> 15:18:29.487
好吧，接下来呢?好了，让我们继续添加验证部分。

11126
15:18:29.550 --> 15:18:34.994
再一次，创建一个新文件夹utils，新文件verify。

11127
15:18:34.994 --> 15:18:35.142
js。

11128
15:18:35.142 --> 15:18:41.484
我们可以从上一个项目复制粘贴这个，也可以从与这门课相关的GitHub回

11129
15:18:41.484 --> 15:18:48.009
购中获取这个，一旦我们在这里有了验证脚本，我们会通过const来导入它。

11130
15:18:48.009 --> 15:18:54.860
验证等于要求。点。斜杠助手Hardhead配置。

11131
15:18:54.860 --> 15:19:01.142
然后我们可以在下面添加同样的代码来验

11132
15:19:01.142 --> 15:19:07.425
证我们的合同，如果我们不在开发链上。

11133
15:19:07.425 --> 15:19:15.117
我们有研究v。ether扫描API key的进程，然后我们

11134
15:19:15.117 --> 15:19:23.075
会验证log。然后等待验证raffle。address和弧。

11135
15:19:23.075 --> 15:19:28.955
现在我们用一大堆连字符的对数表示脚本已经完成module。exports。

11136
15:19:28.955 --> 15:19:34.519
tags = this will be all and raffle。

11137
15:19:34.519 --> 15:19:37.228
好了，我们来测试一下。

11138
15:19:37.228 --> 15:19:44.217
我们将执行硬帽部署，或者yarn，硬帽部署，看看这个脚本是否正确工作。

11139
15:19:44.217 --> 15:19:48.173
看来我们遇到了网络配置未定义的错误。

11140
15:19:48.173 --> 15:19:49.789
我们把这个拼对。

11141
15:19:49.789 --> 15:19:50.503
网络配置。

11142
15:19:50.503 --> 15:19:51.074
好了。

11143
15:19:51.074 --> 15:19:52.359
这样看起来好多了。

11144
15:19:52.551 --> 15:19:53.585
让我们再试一次。

11145
15:19:55.551 --> 15:19:56.205
工作得很好。

11146
15:19:58.551 --> 15:20:05.451
部署VRF协调器v2模拟部署，然后我们继续部署我们的抽奖。

11147
15:20:05.451 --> 15:20:07.951
太棒了，这是巨大的。

11148
15:20:07.951 --> 15:20:14.499
现在我们还不打算测试将它部署到测试网中，因为我们还没有任何单元测试。

11149
15:20:14.551 --> 15:20:18.851
在我们想要在测试网络上测试运行之前，我们需要编写单元测试。

11150
15:20:18.851 --> 15:20:23.801
所以我们有了部署脚本，有了合同，这意味着我们是时候编写一些测试了。

11151
15:20:23.801 --> 15:20:26.757
我们到这里创建一个新文件夹test。

11152
15:20:26.757 --> 15:20:29.032
现在，我们只做单元测试。

11153
15:20:29.032 --> 15:20:34.680
单元测试，在这里我们创建一个名为raffle的新文件。

11154
15:20:34.680 --> 15:20:35.067
测试。

11155
15:20:35.067 --> 15:20:35.260
js。

11156
15:20:35.551 --> 15:20:36.981
让我们写一些单元测试。

11157
15:20:38.551 --> 15:20:42.173
这里有点啰嗦，我们要让我们的覆盖面非常非常好。

11158
15:20:42.173 --> 15:20:45.389
这不会是完美的，但会很啰嗦。

11159
15:20:45.389 --> 15:20:47.171
我很快地讲完。

11160
15:20:47.171 --> 15:20:52.689
所以你们可以随意暂停，让我慢下来，加快我学习这一部分的速度。

11161
15:20:52.689 --> 15:20:59.518
通过编写这些测试并理解在编写这些测试时应该考虑什么，这是非常好的肌肉记忆。

11162
15:20:59.518 --> 15:21:03.487
所以，请随意加快你已经知道的部分，放慢新部分。

11163
15:21:03.487 --> 15:21:06.952
因为我们要讲一些新知识。

11164
15:21:06.952 --> 15:21:09.689
编写测试似乎是一个乏味的过程。

11165
15:21:09.689 --> 15:21:16.896
但是我保证，当你更好地编写这些测试时，你会意识到当某些东西不能工作时，你可以依靠这些东西。

11166
15:21:16.896 --> 15:21:23.823
当你不确定如何编码时，记下这些肌肉记忆，编写这些测试将使你成为一个出色的工程师。

11167
15:21:23.823 --> 15:21:29.489
我们来做一遍我们会写一些冗长的测试来让它变得很好让它有很好的覆盖率。

11168
15:21:29.489 --> 15:21:35.409
如果你想稍后再回去，看看你是否能给它更多的覆盖范围，更好的测试，请随时这样做。

11169
15:21:35.409 --> 15:21:36.456
让我们开始吧。

11170
15:21:36.552 --> 15:21:37.599
让我们编写一些测试。

11171
15:21:39.552 --> 15:21:46.355
与我们开始所有事情的方式相同，我们将抓取我们的开发链，这样我们只在开发链上运行单元测试。

11172
15:21:46.355 --> 15:21:53.118
我们会写const development chains，等于require。。斜杠。

11173
15:21:53.118 --> 15:21:59.252
。斜杠helper RD, hard hat config，然后我们会说not

11174
15:21:59.252 --> 15:22:06.174
development chains，这包括network。name，并描述那个跳过。

11175
15:22:06.174 --> 15:22:12.197
否则，我们将使用描述，第一个描述将是抽奖单元测试。

11176
15:22:12.197 --> 15:22:15.390
这将是一个异步。

11177
15:22:15.390 --> 15:22:16.260
函数。

11178
15:22:16.552 --> 15:22:20.164
抽奖单元测试让它出现在下一行，看起来好一点。

11179
15:22:20.164 --> 15:22:20.647
好了,好了。

11180
15:22:20.647 --> 15:22:28.737
现在，我们需要部署的一些主要的东西是什么?我们需要部署一个抽奖，我们可能需要一个VRF核心到一

11181
15:22:28.737 --> 15:22:37.001
个tour在每个之前进行模拟分级，那将是一个async函数，我们将在那里得到这些会说const。

11182
15:22:37.001 --> 15:22:41.345
雇主等于等待，得到指定的帐户。

11183
15:22:41.553 --> 15:22:49.460
我们需要导入getnames accounts或require从hardhat获取name accounts，然后我们需要使用fixture部署这些。

11184
15:22:49.460 --> 15:22:51.429
所以我们可以说等待部署。

11185
15:22:51.553 --> 15:22:56.197
然后我们还会从hardhat。fixture

11186
15:22:56.197 --> 15:23:01.053
导入部署，我们会调用所有，我们会部署所有东西。

11187
15:23:01.053 --> 15:23:08.654
再看一下我们的，我们的raffle有alt标签，我们的mock也有alt标签，很好。

11188
15:23:08.654 --> 15:23:15.749
一旦我们部署了所有东西，我们可以说raffle = await醚。get to contract。

11189
15:23:15.749 --> 15:23:19.486
我们要从安全帽进口醚，就像这样。

11190
15:23:19.486 --> 15:23:27.026
我们会说它会得到抽奖合同我们会把它连接到我们的部署者。

11191
15:23:27.026 --> 15:23:32.641
然后我们会对VRF协调器v2做同样的事情，Mock = await

11192
15:23:32.641 --> 15:23:40.129
ethers。get contract, RF协调器，B到MK，也把这个连接到部署器。

11193
15:23:40.129 --> 15:23:45.671
好的，我们的第一组测试描述了，它们将是构造函数。

11194
15:23:45.671 --> 15:23:49.942
这将是一个async函数。

11195
15:23:49.942 --> 15:23:51.693
我们来做这个。

11196
15:23:51.693 --> 15:23:56.727
让我们创建一个IT初始化抽奖正

11197
15:23:56.727 --> 15:24:01.762
确初始化，这将是一个异步函数。

11198
15:24:01.762 --> 15:24:07.962
现在我要做一个标记，因为理想情况下，我们让我们的测试只有一

11199
15:24:07.962 --> 15:24:14.377
个断言，或者它只是记住，理想情况下，我们希望它只有一个断言。

11200
15:24:14.377 --> 15:24:18.295
但是我们会有一堆因为就像我说的，我们在这里有点松散。

11201
15:24:18.295 --> 15:24:21.938
我们要确保抽奖被正确初始化。

11202
15:24:21.938 --> 15:24:30.467
所以我们说const raffle state，我们会得到那个raffle state因为我们想确保我们从一个开放的raffle state开始。

11203
15:24:30.467 --> 15:24:38.284
我们说const, raffle state = await raffle。get raffle state。

11204
15:24:38.284 --> 15:24:44.657
然后我们要说assert。equal ope然后我们需要从Chai导入assert。

11205
15:24:44.657 --> 15:24:49.384
因此，断言= require Chai断言。equal raffle state。

11206
15:24:49.384 --> 15:24:55.102
到字符串，因为raffle state将是一个大数字。

11207
15:24:55.102 --> 15:25:02.844
即使抽奖状态是raffle state类型，如果它是打开的，它会返回0如果它在计算中，它会返回1。

11208
15:25:02.844 --> 15:25:06.392
这就变成了un 256。

11209
15:25:06.554 --> 15:25:10.506
当我们这样调用它时，抽奖状态函数会是一个很大的数。

11210
15:25:10.506 --> 15:25:12.791
我们只是想把文件串起来。

11211
15:25:12.791 --> 15:25:15.689
断言。equal raffle state dot 2string 0。

11212
15:25:15.689 --> 15:25:19.172
我们还要确保区间设置正确。

11213
15:25:19.172 --> 15:25:26.268
我们写入const interval = await raffle。get interval。

11214
15:25:26.268 --> 15:25:33.363
我不知道我们是否有这样的一个，实际上是C国际球，看看我们是否有这样一个。

11215
15:25:33.363 --> 15:25:41.472
我们没有一个很好的区间我们继续，再加上区间函数我们会遇到麻烦。

11216
15:25:41.472 --> 15:25:49.792
我们有公共视图返回，你去6返回我下划线interval将会有好的interval将

11217
15:25:49.792 --> 15:25:58.316
会说raffle。get interval也会说断言。equal interval。

11218
15:25:58.316 --> 15:25:59.117
字符串。

11219
15:25:59.117 --> 15:26:06.194
它在helper配置中应该等于1 Ever，对吧?因为我们正在使用interval和helper配置。

11220
15:26:06.194 --> 15:26:07.200
所以我们说间隔。

11221
15:26:07.200 --> 15:26:08.974
字符串应该等于。

11222
15:26:08.974 --> 15:26:11.312
我们也要导入它。

11223
15:26:11.555 --> 15:26:12.827
网络配置。

11224
15:26:16.555 --> 15:26:17.932
网络配置。

11225
15:26:22.555 --> 15:26:24.848
chain ID，写上const。

11226
15:26:29.555 --> 15:26:34.587
chain ID, interval的chain ID的网络配置。

11227
15:26:35.555 --> 15:26:35.930
酷。

11228
15:26:41.555 --> 15:26:43.081
酷毙了，好像过去了。

11229
15:26:44.555 --> 15:26:45.087
输出。

11230
15:26:45.087 --> 15:26:45.474
太棒了。

11231
15:26:47.555 --> 15:26:50.361
它并不总是在气体中打印出来，但现在是这样。

11232
15:26:50.555 --> 15:26:55.412
我要复制粘贴上一个项目的气体报告部分，像这样。

11233
15:26:55.412 --> 15:26:58.227
我们现在会让enabled gas为假。

11234
15:26:58.227 --> 15:27:04.538
现在如果我们进行硬脑测试，我们不应该打印出汽油价格，我们应该只看测试结果，完美，这就是我们所看到的。

11235
15:27:04.538 --> 15:27:06.313
我们的构造函数测试通过了。

11236
15:27:06.313 --> 15:27:08.933
接下来是什么，我们的构造函数。

11237
15:27:08.933 --> 15:27:11.401
我们可能可以为剩下的这些编写更多的测试。

11238
15:27:11.401 --> 15:27:12.440
我们继续吧。

11239
15:27:12.440 --> 15:27:16.950
输入raffle，这将是我们的下一个描述块。

11240
15:27:16.950 --> 15:27:20.620
所以它会描述，进入，抽奖。

11241
15:27:20.620 --> 15:27:24.062
这将是一个async函数。

11242
15:27:24.062 --> 15:27:32.948
当你支付的钱不够的时候，我们会说它会恢复，因为我们首先检查的一件事是他们支付的钱足够多。

11243
15:27:32.948 --> 15:27:37.889
所以我们要确保如果他们不支付足够的钱，这种情况会发生逆转。

11244
15:27:37.889 --> 15:27:40.047
这将是一个async函数。

11245
15:27:40.047 --> 15:27:43.841
我们会做同样的期望等待。

11246
15:27:43.841 --> 15:27:50.277
所以我们要从Chai中导入expect，它来自华夫饼matcher。

11247
15:27:50.277 --> 15:27:56.505
我们会说await, expect raffle。enter a raffle。

11248
15:27:56.505 --> 15:28:05.314
我们不打算在这里传递任何值，我们期望它。b。

11249
15:28:05.314 --> 15:28:10.822
如果我们看这里，我们希望它恢复到这个抽奖没有足够的人进入。

11250
15:28:10.822 --> 15:28:15.460
所以我们可以把它加引号抽奖，没有足够的每一个进入。

11251
15:28:15.460 --> 15:28:16.602
现在我们可以试一下。

11252
15:28:16.602 --> 15:28:18.703
确保它确实有效。

11253
15:28:18.703 --> 15:28:20.834
啊，啊，测试，冲刺，冲刺，grep。

11254
15:28:20.834 --> 15:28:24.222
把这个加引号，说明你付的钱不够。

11255
15:28:24.222 --> 15:28:25.022
而可畏。

11256
15:28:25.022 --> 15:28:26.355
我们正经过那里。

11257
15:28:26.556 --> 15:28:32.047
我们还想测试什么?我们想要测试如果抽奖没有打开，我们也会恢复但我们一会儿会测试。

11258
15:28:32.047 --> 15:28:34.456
当我们测试剩下的功能时。

11259
15:28:34.556 --> 15:28:39.698
我们希望看到它在玩家进入时记录他们。

11260
15:28:40.556 --> 15:28:42.280
将是一个异步函数。

11261
15:28:44.556 --> 15:28:47.056
首先我们需要抽奖券入场费。

11262
15:28:47.556 --> 15:28:49.081
前进，把它保存在顶端。

11263
15:28:50.556 --> 15:28:55.683
协调员是模拟抽奖入场费，然后我们每个人之前

11264
15:28:55.683 --> 15:29:01.056
都会说抽奖入场费等于一个权重醚点得到入场费。

11265
15:29:01.056 --> 15:29:05.087
这应该是抽奖，并获得入场费。

11266
15:29:05.087 --> 15:29:07.661
现在我们有了这个抽奖入场费，

11267
15:29:07.661 --> 15:29:17.041
你可以用它来进入抽奖我们说一个weight raffle。enter raffle带着抽奖入场费的值。

11268
15:29:17.041 --> 15:29:21.842
我们可以确保这里的Deployer已经被正确记录。

11269
15:29:21.842 --> 15:29:24.249
既然现在我们连上了部署者。

11270
15:29:24.249 --> 15:29:28.387
我们只要确保这个部署者确实在我们的合同中。

11271
15:29:28.387 --> 15:29:35.880
我们写入const playerfromcontract = await raffle。get

11272
15:29:35.880 --> 15:29:44.490
playerof0，因为我们在players数组中记录了它们我们有get players函数把它们取出来。

11273
15:29:44.490 --> 15:29:51.470
然后我们说断言。equal player, player from contract应该是部署者。

11274
15:29:51.557 --> 15:29:54.007
现在我们可以在头部测试中得到答案了。

11275
15:29:54.557 --> 15:29:55.557
这个作品。

11276
15:29:55.557 --> 15:29:57.857
HH test dash dash grep。

11277
15:30:00.557 --> 15:30:01.326
我们把它放在这里。

11278
15:30:02.557 --> 15:30:03.223
在全球范围内。

11279
15:30:03.223 --> 15:30:06.223
所以我们要让普通的部署者。

11280
15:30:07.557 --> 15:30:10.057
部署者=等待获取命名帐户。

11281
15:30:11.557 --> 15:30:14.466
这能让部署人员觉得很棒。

11282
15:30:16.557 --> 15:30:17.779
而可畏。

11283
15:30:22.557 --> 15:30:23.341
发出一个事件。

11284
15:30:23.341 --> 15:30:25.048
我们要确保它触发一个事件。

11285
15:30:25.557 --> 15:30:28.302
它在进入时触发事件。

11286
15:30:31.557 --> 15:30:31.895
也

11287
15:30:34.557 --> 15:30:43.346
确保函数触发一个事件，并且语法看起来与我们检查是否触发错误时的测试非常相似。

11288
15:30:43.346 --> 15:30:50.239
我们会说await expect raffle。enter

11289
15:30:50.239 --> 15:30:58.796
raffle withvalue raffle入口费。2。省略和这个。

11290
15:30:58.796 --> 15:31:00.384
在woful期间，

11291
15:31:00.384 --> 15:31:09.207
这些编钟匹配发射事件我们可以做一个wait expect to emit，然后是我们期望发射的事件。

11292
15:31:09.207 --> 15:31:15.885
我们说省略raffle契约来触发raffle进入事件。

11293
15:31:15.885 --> 15:31:19.229
我们可以复制这个，试着在终端中测试它。

11294
15:31:19.229 --> 15:31:21.136
所以我们称之为安全帽。

11295
15:31:21.136 --> 15:31:22.890
测试dash dash grep。

11296
15:31:22.890 --> 15:31:25.332
把这个加引号。

11297
15:31:25.332 --> 15:31:28.428
这也可以通过。

11298
15:31:28.428 --> 15:31:29.202
太好了。

11299
15:31:29.202 --> 15:31:33.761
现在让我们继续进行测试，以确保在抽奖

11300
15:31:33.761 --> 15:31:38.321
未开启或正在计算时我们不能进入抽奖。

11301
15:31:38.321 --> 15:31:45.954
所以我们说它不允许进入，当抽奖是卡尔累积。

11302
15:31:45.954 --> 15:31:48.977
这将是一个async函数。

11303
15:31:48.977 --> 15:31:53.797
首先我们会进入我们会说等待raffle。

11304
15:31:53.797 --> 15:31:59.824
enter raffle value是抽奖入场费。

11305
15:31:59.824 --> 15:32:05.933
现在我们要做的是让抽奖进入一个封闭状态。

11306
15:32:05.933 --> 15:32:08.367
我们想让它脱离开放状态。

11307
15:32:08.367 --> 15:32:15.496
那么，我们如何在执行维护中将这个抽奖从抽奖点打开移动到抽奖点关闭，从抽奖

11308
15:32:15.496 --> 15:32:22.824
中移除抽奖点打开到抽奖点计算，但执行维护只能在检查维护返回true时调用。

11309
15:32:22.824 --> 15:32:26.424
否则，它将恢复与抽奖维护不需要。

11310
15:32:26.558 --> 15:32:29.808
我们需要做的是让checkupkeep返回true。

11311
15:32:29.808 --> 15:32:36.291
我们会假装自己是通灵守护者网络，继续呼叫检查，等待它是真的。

11312
15:32:36.291 --> 15:32:43.913
一旦我们实现了它，我们就会假装自己是通灵守护者，并调用执行维护者，将这个契约置于计算状态。

11313
15:32:43.913 --> 15:32:52.809
现在我们要怎么做呢?好吧，为了让检查保持正确，我们首先需要看到我们确实是开放的，我们确实是开放的。

11314
15:32:52.809 --> 15:32:56.927
接下来我们要做的是，我们要把这段时间过了一点。

11315
15:32:56.927 --> 15:33:01.268
我们需要等30秒时间过去。

11316
15:33:01.268 --> 15:33:03.296
这听起来有点可怕。

11317
15:33:03.296 --> 15:33:07.795
所有的检查都要等30秒吗?如果我们的间隔是10天，

11318
15:33:07.795 --> 15:33:12.474
而我们必须等待10天才能进行测试呢?这听起来很荒谬。

11319
15:33:12.474 --> 15:33:20.674
硬帽实际上内置了大量的函数让我们操作区块链来做我们想让它做的任何事。

11320
15:33:20.674 --> 15:33:22.404
在硬帽文档中。

11321
15:33:22.404 --> 15:33:27.334
在硬帽网络部分中有一个叫做硬帽网络参考的部分。

11322
15:33:27.334 --> 15:33:33.965
在这里，有大量关于硬帽网络如何工作的信息以及我们可以用它做的不同配置。

11323
15:33:33.965 --> 15:33:41.995
如果我们向下滚动足够低，我们可以看到我们可以在这个区块链上使用的JSON RPC方法，我们可以做每个帐户块编号调用chinetti。

11324
15:33:41.995 --> 15:33:45.225
我们可以执行正常区块链所具有的所有RPC方法。

11325
15:33:45.225 --> 15:33:50.809
此外，我们还可以做更多，我们可以使用这些叫做Hard Hat Network的方法。

11326
15:33:50.809 --> 15:33:52.613
因为这是我们本地的硬帽网络。

11327
15:33:52.613 --> 15:33:56.869
我们用它来测试，我们希望能够测试任何场景。

11328
15:33:56.869 --> 15:34:02.905
正是这些方法给了我们这样做的能力，你可以通过这个来尝试看看你能做的所有不同的事情。

11329
15:34:02.905 --> 15:34:08.125
其中一个特别的是设置存储设置，你可以在任何地方设置存储，这非常有趣。

11330
15:34:08.125 --> 15:34:14.130
但一些特殊的测试调试方法是EVM增加时间，和EVM。

11331
15:34:14.130 --> 15:34:20.147
我增加的时间允许我们自动增加区块链和EVM的时间。

11332
15:34:20.147 --> 15:34:28.244
挖矿允许我们挖矿或创建新的区块，因为如果我们增加时间，它不会做任何事情，除非有一个新的区块被挖出。

11333
15:34:28.244 --> 15:34:35.182
我们能做的是运行一个等待网络，我们从Hard Hat

11334
15:34:35.182 --> 15:34:44.522
network导入network等待网络。提供者它在crease时间发

11335
15:34:44.522 --> 15:34:53.330
e时间发送EVM，逗号，我们可以发送一组参数，对我们来说就是我们的间隔。

11336
15:34:53.330 --> 15:34:54.067
数量。

11337
15:34:54.067 --> 15:34:55.717
然后是+ 1。

11338
15:34:55.717 --> 15:34:59.813
现在，我们的区间不是全局存储的，所以我们可能需要这样做。

11339
15:34:59.813 --> 15:35:01.971
我们来做interval。

11340
15:35:01.971 --> 15:35:06.853
然后在before each中，我们写上interval = await,

11341
15:35:06.853 --> 15:35:12.527
raffle。raffle。get interval，我要复制这个我们要删除这整行。

11342
15:35:12.527 --> 15:35:14.397
等待抽奖点得到间隔。

11343
15:35:14.397 --> 15:35:19.271
因为现在我们将在全局层面上称它为interval，因为我们将经常使用它。

11344
15:35:19.271 --> 15:35:21.560
现在我们要对它进行积分。

11345
15:35:21.560 --> 15:35:28.910
所以我们要增加时间无论我们的间隔是多少以确保我们能让checkup keep返回true。

11346
15:35:28.910 --> 15:35:36.185
另外，我们要做一个权值网络。提供者。

11347
15:35:36.185 --> 15:35:42.887
Dot发送带有空数组的EVM mine，因为我们只是想多挖一个块。

11348
15:35:42.887 --> 15:35:46.443
你也可以用network。provider这个请求，

11349
15:35:46.443 --> 15:35:52.463
这里有一个await，这两个基本是一样的，不过这个要快一些?所以我们增加了区块链的时间。

11350
15:35:52.463 --> 15:35:54.785
为了前进，我们在一个街区埋了地雷。

11351
15:35:54.785 --> 15:35:56.729
应该开门的时间已经过去了。

11352
15:35:56.729 --> 15:36:00.216
我们有播放器吗?我们确实有，因为我们已经参与抽奖了。

11353
15:36:00.216 --> 15:36:04.294
我们应该有一个平衡，因为我们已经输入了正确的苹果，检查维护现在应该返回true。

11354
15:36:04.294 --> 15:36:08.830
所以我们应该可以调用执行维护并假装自己是链锁管理员。

11355
15:36:08.830 --> 15:36:14.727
所以我们要假装自己是一个锁链，看守人，调用等待抽奖，执行维护。

11356
15:36:14.727 --> 15:36:21.595
我们将通过这样传递一个空数组来传递一些空调用数据。

11357
15:36:21.595 --> 15:36:24.888
现在它应该处于计算状态。

11358
15:36:24.888 --> 15:36:32.866
现在它处于计算状态，我们可以说，如果抽奖没有打开，我们的进入抽奖将正确地返回。

11359
15:36:32.866 --> 15:36:38.238
现在我们写await, expect raffle。enter, raffle。

11360
15:36:38.238 --> 15:36:43.672
我们会把抽奖门票的价值寄给它。

11361
15:36:43.672 --> 15:36:46.005
这是我们所期待的。

11362
15:36:46.005 --> 15:36:47.536
To。b。

11363
15:36:47.536 --> 15:36:56.116
revertwithraffle下划线下划线不打开错误。

11364
15:36:56.116 --> 15:37:00.893
好了，让我们在测试中试试这个。

11365
15:37:00.893 --> 15:37:04.856
所以我们要运行Hardhead测试dash dash grep。

11366
15:37:04.856 --> 15:37:06.413
把这个加引号。

11367
15:37:06.413 --> 15:37:11.361
完美地通过了。

11368
15:37:11.561 --> 15:37:14.870
现在如果我们运行Hardhead测试，让我们现在一起测试所有东西。

11369
15:37:14.870 --> 15:37:16.760
一切都在流逝。

11370
15:37:16.760 --> 15:37:18.192
哦，这太棒了。

11371
15:37:18.192 --> 15:37:18.613
太棒了。

11372
15:37:18.613 --> 15:37:19.665
让我们继续。

11373
15:37:19.665 --> 15:37:26.998
如果我们进行Hardhead的报道，我们会看到我们的覆盖率在上升，我们已经比以前好了很多。

11374
15:37:26.998 --> 15:37:31.294
让我们继续，让我们继续测试我们的检查维护现在。

11375
15:37:31.294 --> 15:37:33.164
我们会做描述，检查和维护。

11376
15:37:33.164 --> 15:37:41.527
这是一个async函数，它会返回false。

11377
15:37:41.527 --> 15:37:49.447
如果有人收到E, E，这是一个同步功能。

11378
15:37:49.562 --> 15:37:54.831
我们让这里的一切都为真除了还没有人进入这个事实。

11379
15:37:54.831 --> 15:38:00.417
我们做一个权值网络。提供者。

11380
15:38:00.417 --> 15:38:06.404
发送EVM增加时间，逗号间隔。

11381
15:38:06.404 --> 15:38:11.181
对number +

11382
15:38:11.181 --> 15:38:17.021
1会做一个权重网络。

11383
15:38:17.021 --> 15:38:19.824
发送UVM地雷。

11384
15:38:19.824 --> 15:38:21.728
没有参数。

11385
15:38:21.728 --> 15:38:26.044
现在我们调用check maintenance。

11386
15:38:26.044 --> 15:38:28.953
事情是这样的，对了。

11387
15:38:28.953 --> 15:38:31.387
维护是一项公共职能。

11388
15:38:31.562 --> 15:38:38.387
如果我们运行await, raffle。check upkeep，然后什么都不传递进来这就

11389
15:38:38.387 --> 15:38:45.212
会启动一个事务，因为hard had知道，这是一个公共函数，显然他们想在这里发送一个事务。

11390
15:38:45.212 --> 15:38:48.847
如果这是公共视图函数，它不会，它会返回那个视图。

11391
15:38:48.847 --> 15:38:51.812
但问题是，我并不想发送事务。

11392
15:38:51.812 --> 15:38:57.862
但是我想模拟发送这个事务，看看这个维护需要返回什么。

11393
15:38:57.862 --> 15:39:05.847
我可以通过调用static来得到它，我可以模拟调用这个事务，看它会做出什么响应。

11394
15:39:05.847 --> 15:39:12.514
所以我可以用raffle。check maintenance，来代替raffle。cost static，也就是check maintenance。

11395
15:39:12.514 --> 15:39:20.890
这将给我返回的upkeep needed和字节执行数据，我可以从这个返回中推断出需要

11396
15:39:20.890 --> 15:39:27.671
的upkeep或者写const upkeep needed等于这个，

11397
15:39:27.671 --> 15:39:37.644
然后我可以断言not upkeep needed，因为现在upkeep needed返回false。

11398
15:39:37.644 --> 15:39:40.696
我们会说assert，而不是false，这是true。

11399
15:39:40.696 --> 15:39:43.337
如果维护需要是真的，那么这将是假的。

11400
15:39:43.337 --> 15:39:44.014
这个会断裂。

11401
15:39:44.014 --> 15:39:45.444
这就是我们要做的。

11402
15:39:45.444 --> 15:39:49.143
让我们继续，我们运行这个，看看它是否有效。

11403
15:39:49.143 --> 15:39:51.949
我们的帽子测试，dash dash grep。

11404
15:39:51.949 --> 15:39:56.038
我们只是顺带而过，我们在做生意。

11405
15:39:56.038 --> 15:39:56.824
太棒了。

11406
15:39:56.824 --> 15:39:59.676
所以这是完美的。

11407
15:39:59.676 --> 15:40:05.511
我们还要测试它是否返回false。

11408
15:40:05.511 --> 15:40:07.963
如果没有抽奖。

11409
15:40:07.963 --> 15:40:11.063
这将是一个异步函数。

11410
15:40:11.063 --> 15:40:15.013
我们会做所有的事情除了我们会在这里做所有的事情。

11411
15:40:15.013 --> 15:40:18.828
但是我们会在计算状态下抽奖。

11412
15:40:18.828 --> 15:40:26.539
做一个weight, raffle。enter, raffle value,

11413
15:40:26.539 --> 15:40:34.251
raffle入口费等待network。provider，发送我复制这两行。

11414
15:40:34.251 --> 15:40:36.464
因为我们会继续做这些。

11415
15:40:36.563 --> 15:40:42.086
我们还会做一个重量，抽奖，并执行维护。

11416
15:40:42.563 --> 15:40:47.605
另一种发送空白字节对象的方法是像0x这样的字符串ha

11417
15:40:47.605 --> 15:40:52.841
rdhat很聪明，知道这应该被转换成一个空白字节对象。

11418
15:40:52.841 --> 15:40:54.804
所以这两个都可以。

11419
15:40:54.804 --> 15:41:02.460
现在我们做const, raffle state = await, raffle。get raffle state然后我们会get upkeep needed。

11420
15:41:02.460 --> 15:41:03.770
所以我们用const。

11421
15:41:03.770 --> 15:41:12.055
维护需要，我们将做我们上面做的抽奖点调用静态点检查维护。

11422
15:41:12.055 --> 15:41:16.399
我们说一个权重，raffle点叫静态。

11423
15:41:16.564 --> 15:41:23.979
现在我们可以断言。equal，说抽奖状态是。不好意思，是抽奖状态。

11424
15:41:23.979 --> 15:41:31.960
to string，它会计算，我开始。equal upkeep needed，它会是假的。

11425
15:41:31.960 --> 15:41:35.134
我们来做个GREP。

11426
15:41:35.134 --> 15:41:36.657
和完善。

11427
15:41:36.657 --> 15:41:39.443
它也能正常工作。

11428
15:41:39.443 --> 15:41:39.753
太好了。

11429
15:41:39.753 --> 15:41:44.985
现在我将跳过接下来的两个测试，因为我们没有从它们中学到任何东西。

11430
15:41:44.985 --> 15:41:50.318
我将从GitHub复制粘贴它们，如果时间不够，我们将返回false。

11431
15:41:50.318 --> 15:41:52.241
我们会返回true。

11432
15:41:52.241 --> 15:41:56.150
如果足够的时间过去了，我们就有了玩家Eve，并且是开放的。

11433
15:41:56.150 --> 15:41:58.697
所以我们在下面断言为真。

11434
15:41:58.697 --> 15:42:06.415
我们开始的时候在这里不为真，你想暂停视频复制粘贴这些，把它们写出来，你完全可以从GitHub回购中复制

11435
15:42:06.415 --> 15:42:14.286
粘贴它们，你绝对不能像我说的那样，通过这些，让自己写这些，让自己理解这些测试会让你成为一个更好的程序员。

11436
15:42:14.286 --> 15:42:17.964
让我们用hh test测试一下是否一切正常。

11437
15:42:17.964 --> 15:42:23.895
现在，当我在记录这个的时候，我意识到对于我们所有的描述块，我一直

11438
15:42:23.895 --> 15:42:29.827
在让它们异步函数描述块实际上不能实现，不能识别，不能与承诺工作。

11439
15:42:29.827 --> 15:42:32.483
使用be async实际上什么都做不了。

11440
15:42:32.483 --> 15:42:37.717
在描述块中，我们要去掉async字因为它对我们一点帮助都没有。

11441
15:42:37.717 --> 15:42:40.828
事实上，这只是一个多余的词，看起来有点恶心。

11442
15:42:40.828 --> 15:42:46.371
现在我们所有的描述块，我们会去掉async关键字，只让它们是函数。

11443
15:42:46.371 --> 15:42:51.707
当然，我们所有的。会使用异步函数，这是我们想要的。

11444
15:42:51.707 --> 15:42:54.498
所以我们写了一些测试以备体检。

11445
15:42:54.498 --> 15:42:56.565
现在让我们继续执行维护。

11446
15:42:56.565 --> 15:43:01.965
让我们创建一个新的描述、阻塞、归属或执行维护。

11447
15:43:01.965 --> 15:43:04.565
这是一个常规函数。

11448
15:43:04.565 --> 15:43:10.823
在这里，我们开始说它只能在check维护为真时运行。

11449
15:43:10.823 --> 15:43:13.081
这将是一个async函数。

11450
15:43:13.081 --> 15:43:18.289
因为我们只希望在检查keep确实为真时执行keep to work。

11451
15:43:18.289 --> 15:43:20.734
我们写入await raffle。enter。

11452
15:43:20.734 --> 15:43:28.676
我们会给它一些价值，抽奖门票，对不起，应该用花括号代替。

11453
15:43:28.676 --> 15:43:33.521
我们将做一个权重网络点提供

11454
15:43:33.521 --> 15:43:38.740
程序发送EVM增加时间间隔。

11455
15:43:38.740 --> 15:43:45.090
到number + 1 await network。provider发

11456
15:43:45.090 --> 15:43:51.621
送UVM mine一个空数组的原因是我们要将时间向前移动并将块向前移动，

11457
15:43:51.621 --> 15:43:57.790
当然这和上面是一样的，我们希望check upkeep返回true。

11458
15:43:57.790 --> 15:44:05.211
然后我们会说const X或transaction = await rafel。performupkeep。

11459
15:44:05.211 --> 15:44:11.940
我们可以用空数组，也可以用0x。

11460
15:44:11.940 --> 15:44:13.440
我们可以断言X。

11461
15:44:13.440 --> 15:44:18.168
如果TX不工作，或者这个错误出现了，这个就会失败。

11462
15:44:18.168 --> 15:44:18.549
正确的。

11463
15:44:18.549 --> 15:44:21.232
这就是为什么我们知道这是可行的。

11464
15:44:21.232 --> 15:44:22.327
我们来测试一下。

11465
15:44:22.327 --> 15:44:25.973
我们希望这只在checkup keep为真时工作。

11466
15:44:25.973 --> 15:44:30.303
我们用上面的方法让检查保持正确。

11467
15:44:30.303 --> 15:44:35.923
现在我们用IT块做纱线硬帽测试。

11468
15:44:35.923 --> 15:44:40.387
我把perform upkeep拼错了。

11469
15:44:40.566 --> 15:44:42.475
让我们试着拼写正确。

11470
15:44:43.566 --> 15:44:44.221
再次测试。

11471
15:44:44.221 --> 15:44:44.876
和伟大的。

11472
15:44:44.876 --> 15:44:45.859
这是工作。

11473
15:44:47.566 --> 15:44:51.058
想做什么?我们希望它恢复与拉斐尔。

11474
15:44:52.566 --> 15:44:54.441
如果checkup keep为false。

11475
15:44:57.566 --> 15:45:00.266
当检查keep为假。

11476
15:45:03.566 --> 15:45:07.965
我们将使用相同的语法await expect raffle。

11477
15:45:07.965 --> 15:45:14.125
execute upkeep empty bytes object that to。

11478
15:45:14.125 --> 15:45:16.294
被还原为。

11479
15:45:16.566 --> 15:45:21.941
我们想让它还原成什么呢?或者希望它与这个和那个恢复，我们可以在这里运

11480
15:45:21.941 --> 15:45:27.316
行这个测试Hardhead测试dash dash grep粘贴进去。

11481
15:45:27.316 --> 15:45:36.166
我们看到它确实在传递你会注意到这里我们的revert会继续进行并将所有这些额外的东西都进行了还原。

11482
15:45:36.166 --> 15:45:43.652
我们的测试足够聪明，它知道如果我们所做的只是放入要返回的错误的名称，那么它就足够好了。

11483
15:45:43.652 --> 15:45:51.193
如果我们想要特别具体，我们可以继续把它变成一个字符串插值然后把所有这些都加进去。

11484
15:45:51.193 --> 15:45:55.766
所以我们可以增加我们期望的平衡我们可以增加我们期望的球员。

11485
15:45:55.766 --> 15:46:01.489
我们现在可以添加raffle语句我们将保持它和我们预期的一样但

11486
15:46:01.489 --> 15:46:07.397
如果你想要非常具体你可以让你的测试期望得到你想要的确切的具体值。

11487
15:46:07.397 --> 15:46:15.300
好吧，我们最不应该期待的是什么?我们应该检查一下这个是否被称为抽奖状态被改变了。

11488
15:46:15.300 --> 15:46:16.963
我们承认这个事件。

11489
15:46:16.963 --> 15:46:19.423
我们把它加起来。

11490
15:46:19.423 --> 15:46:25.960
我们会说它更新抽奖状态，承认一个事件，

11491
15:46:25.960 --> 15:46:32.154
并调用VRF协调器作为一个异步函数。

11492
15:46:32.154 --> 15:46:33.042
让我们开始吧。

11493
15:46:33.042 --> 15:46:40.698
让checkup keep为真，复制粘贴前三行，因为它们是完全一样的。

11494
15:46:40.698 --> 15:46:46.124
我们将进入抽奖我们将增加时间我们将关注一个新区块，然后我们将调用执行维护。

11495
15:46:46.124 --> 15:46:52.060
我们会说const, TX response = await raffle。

11496
15:46:52.060 --> 15:46:57.996
performupkeep with一个空字节对象，我们会说const TX

11497
15:46:57.996 --> 15:47:05.027
receipt = await TX response。wait for一个block。

11498
15:47:05.027 --> 15:47:08.597
从这个收据，我们会得到请求ID，

11499
15:47:08.597 --> 15:47:14.400
我们会说const请求ID等于，我们能得到请求ID。

11500
15:47:14.400 --> 15:47:16.400
从这个省略的事件。

11501
15:47:16.400 --> 15:47:24.042
然而，我们应该再次查看VRF协调器模拟，当我们在模拟中调用请求随机单词

11502
15:47:24.042 --> 15:47:31.685
时，然后在实际的契约中调用，您将注意到它还发出一个请求随机单词的事件。

11503
15:47:31.685 --> 15:47:37.277
看这里，第二个参数确实是请求ID。

11504
15:47:37.277 --> 15:47:42.542
所以在现实中，US省略请求ID是多余的，我们可以只使用VRF协调器

11505
15:47:42.542 --> 15:47:47.968
中允许的请求ID，这是本课程的目的，并向您展示一个事件是什么样子的。

11506
15:47:47.968 --> 15:47:49.223
我们把它放在那里。

11507
15:47:49.223 --> 15:47:53.968
但如果你想回去重构这个，你肯定会想删除这个省略。

11508
15:47:53.968 --> 15:47:57.171
但是对于这个测试，让我们做TX收据点事件。

11509
15:47:57.171 --> 15:48:01.963
这将是第一个事件而不是0 with event因

11510
15:48:01.963 --> 15:48:06.955
为在这个事件被触发之前，这个函数将会触发一个事件。

11511
15:48:06.955 --> 15:48:11.500
这不是带事件的0，这是这个之后触发的第一个事件。

11512
15:48:11.500 --> 15:48:20.027
税单。events。one。args。request, ID，然后我们会说，cert request ID。

11513
15:48:20.027 --> 15:48:22.977
To number大于0。

11514
15:48:22.977 --> 15:48:28.948
然后我们还会断言抽奖状态等于等于1。

11515
15:48:28.948 --> 15:48:36.515
我们将使用const, raffle state = await, raffle。get raffle state。

11516
15:48:36.515 --> 15:48:39.822
这应该是抽奖状态。

11517
15:48:39.822 --> 15:48:43.805
到Number，或者到string，然后你知道，做任何我们想做的。

11518
15:48:43.805 --> 15:48:48.318
这是一个很大的函数，但我们还是要复制整个式子。

11519
15:48:48.318 --> 15:48:52.786
HH test，破折号grep，粘贴到这里，我们运行它，不好意思。

11520
15:48:52.786 --> 15:48:58.242
to string = = 1，转换时间和完美，

11521
15:48:58.242 --> 15:49:03.245
我们正在通过很好，现在是时候实现随机单词了。

11522
15:49:03.245 --> 15:49:06.771
我们将在这里学到很多奇妙的东西。

11523
15:49:06.771 --> 15:49:11.093
我们要创建一个新的描述块把这里缩小一点。

11524
15:49:11.093 --> 15:49:16.039
这就是我们要完成的随机单词。

11525
15:49:16.039 --> 15:49:19.718
当然，这是一个函数。

11526
15:49:19.718 --> 15:49:27.142
在这里，在我们进行任何测试之前我们实际上会在每个想要参与抽奖的人之前添加另一个。

11527
15:49:27.142 --> 15:49:32.045
我们会在每个之前做一个a，这将是一个async。

11528
15:49:32.045 --> 15:49:32.902
函数。

11529
15:49:32.902 --> 15:49:38.132
我们要运行await, raffle那个进

11530
15:49:38.132 --> 15:49:43.362
入raffle带有raffle入场费的值。

11531
15:49:43.362 --> 15:49:48.890
然后我们要做一个等待网络。提供者。

11532
15:49:48.890 --> 15:49:57.020
发送EVM增加时间间隔，到number + 1，然

11533
15:49:57.020 --> 15:50:04.500
1，然后一个等待网络。提供者。发送EVM mine。

11534
15:50:04.500 --> 15:50:05.327
逗号。

11535
15:50:05.327 --> 15:50:10.762
在我们尝试对随机单词做任何测试或满足之前，我们会让一些人进入抽奖。

11536
15:50:10.762 --> 15:50:14.235
我们将增加时间，挖出一个新的区块。

11537
15:50:14.235 --> 15:50:14.968
好的,很酷。

11538
15:50:14.968 --> 15:50:20.912
我们要做的第一件事是看看满足随机词只能被调用只要有

11539
15:50:20.912 --> 15:50:27.095
一个请求在运行，只要有一个请求只要请求随机词被调用。

11540
15:50:27.095 --> 15:50:32.189
我们可以通过运行来检查它只能在执行之后被调用。

11541
15:50:32.189 --> 15:50:35.093
这将是一个异步函数。

11542
15:50:35.093 --> 15:50:40.117
在这里，我们会回复一些不存在的请求。

11543
15:50:40.117 --> 15:50:44.602
所以我们将做等待，期望射频核心

11544
15:50:44.602 --> 15:50:49.388
没有一个巡回是模拟点实现随机词。

11545
15:50:49.388 --> 15:50:57.955
如果我们看我们的V RF，协调器v2 Mark在这里有实现随机单词函数，这是

11546
15:50:57.955 --> 15:51:06.523
链链接节点实际调用的在实际契约中添加这个函数调用另一个契约来进行随机数验证。

11547
15:51:06.570 --> 15:51:08.820
我们基本上是在检查这部分。

11548
15:51:09.570 --> 15:51:13.796
不存在，我们会得到这个不存在的请求。

11549
15:51:13.796 --> 15:51:17.570
如您所见，它需要一个请求ID和一个使用者地址。

11550
15:51:17.570 --> 15:51:19.382
所以我们要猜0。

11551
15:51:19.382 --> 15:51:25.694
消费者地址，当然，它会在address被

11552
15:51:25.694 --> 15:51:32.007
抽抽，我们会期望这个被还原，不存在请求。

11553
15:51:32.007 --> 15:51:38.103
然后我们会用不同的Request ID或Request ID 1做同样的事情。

11554
15:51:38.103 --> 15:51:41.659
希望我们也能得到不存在的请求。

11555
15:51:41.659 --> 15:51:46.021
理想情况下，这里的任何请求都不会允许这个满足的随机单词通过。

11556
15:51:46.021 --> 15:51:51.689
很明显，要测试每一个可能的Request ID是很困难的，

11557
15:51:51.689 --> 15:51:57.553
我们将在未来看到一种方法，通过模糊测试来测试大量的这些变量。

11558
15:51:57.553 --> 15:51:58.880
我们以后会讲到这个。

11559
15:51:58.880 --> 15:52:07.370
我把scribe拼错了，让我们把scribe拼对，继续运行这个hh test dash grep。

11560
15:52:07.570 --> 15:52:09.438
它很好地过去了。

11561
15:52:13.570 --> 15:52:15.699
给你，那就太大了。

11562
15:52:17.570 --> 15:52:19.784
我们将要写的是这将是一个非常大的考验。

11563
15:52:19.784 --> 15:52:26.383
我们可能想把它分成不同的部分，但实际上这是最好的方式来展示这个部分。

11564
15:52:26.383 --> 15:52:28.379
这正是我们要做的。

11565
15:52:28.379 --> 15:52:33.355
当我们开始进行阶段测试时，我们将把这个测试写得几乎完全相同。

11566
15:52:33.355 --> 15:52:38.951
让我们写下来，这基本上是一个把所有东西放在一起的测试。

11567
15:52:38.951 --> 15:52:45.599
我们将测试这一点，赢家重置彩票，并送钱，这对一个人

11568
15:52:45.599 --> 15:52:52.248
来说有点多，我们可能会想把这些分成他们自己的部分。

11569
15:52:52.248 --> 15:52:56.122
但对于这个，我们会把它们都放到一个里面，这将是一个async函数。

11570
15:52:56.122 --> 15:52:59.764
现在我们要学习一些新技巧。

11571
15:52:59.764 --> 15:53:01.602
所以一定要按照我说的去做。

11572
15:53:01.602 --> 15:53:07.465
现在对于这个，我们也要加入一些额外的入口额外的进入抽签的人。

11573
15:53:07.465 --> 15:53:12.191
我们写入const, extra, trance = great。

11574
15:53:12.191 --> 15:53:17.523
我们会让更多来自以太的假账户进入我们的抽奖。

11575
15:53:17.571 --> 15:53:20.142
我们会说const。

11576
15:53:23.571 --> 15:53:31.333
因为部署者等于0，不好意思是等于1，因为玩家是0，所以我们会有新账户从索引1开始。

11577
15:53:31.333 --> 15:53:38.247
我们要做一个for循环或者让i等于起

11578
15:53:38.247 --> 15:53:41.704
始计数index,

11579
15:53:41.704 --> 15:53:52.461
i小于起始计数index，加上附加趋势看到，会有入口。

11580
15:53:52.571 --> 15:53:58.452
I + +，我们要做一个小循环把我们的抽奖合同和这些新账户联系起来。

11581
15:53:58.452 --> 15:54:04.771
然后我们会有这些新客户，参加抽奖比赛。

11582
15:54:04.771 --> 15:54:10.124
计数，连接抽签等于。连接i的账

11583
15:54:10.124 --> 15:54:15.834
户我们是否在其他地方定义了账户。

11584
15:54:15.834 --> 15:54:18.334
我们去找个地方记账吧。

11585
15:54:18.334 --> 15:54:22.503
我们写入const accounts = await ethers。get signed。

11586
15:54:22.503 --> 15:54:29.201
然后我们要做一个权重账户连接抽签。回车。

11587
15:54:29.201 --> 15:54:37.965
抽奖与价值当然抽奖入场费，我们将连接三个额外的入口到我们的抽奖。

11588
15:54:37.965 --> 15:54:42.105
我们总共有四个人参与抽奖。

11589
15:54:42.105 --> 15:54:46.238
现在我们已经在这里有了它们，我们将记录我们的起始时间戳。

11590
15:54:46.238 --> 15:54:54.877
我们写入const starting timestamp = await, raffle。get last timestamp。

11591
15:54:54.877 --> 15:54:56.959
这里我们会有一点棘手。

11592
15:54:56.959 --> 15:55:04.643
我们想要做的是我们想要执行一些事情我们想要执行upkeep，它将模仿链链守护者，

11593
15:55:04.643 --> 15:55:11.944
它将启动链链，它将启动调用fulfillment random words。

11594
15:55:11.944 --> 15:55:15.555
我们也会嘲笑这样做。

11595
15:55:15.555 --> 15:55:18.014
模拟链接VRF。

11596
15:55:18.014 --> 15:55:23.025
一旦我们这样做了，我们当然可以检查看看最近的赢家是否被

11597
15:55:23.025 --> 15:55:28.222
记录了抽奖被重置了就像我们说的时间戳一样，一切都重置了。

11598
15:55:28.222 --> 15:55:30.460
但是我们想用一种特殊的方式来做。

11599
15:55:30.460 --> 15:55:38.887
如果我们在一个测试网络上做这个在我们调用完成随机单词之后，我们将不得不等待完成随机单词被调用。

11600
15:55:38.887 --> 15:55:43.834
既然我们是在硬帽本地连锁店工作，我们不需要等待任何东西，对吧因为

11601
15:55:43.834 --> 15:55:48.782
我们可以说，好，砰，打响指，调整我们的区块链做任何我们想做的事。

11602
15:55:48.782 --> 15:55:53.402
但我们会模拟我们需要等待事件被调用。

11603
15:55:53.402 --> 15:55:59.510
因此，为了模拟等待该事件，我们再次需要设置一个侦听器。

11604
15:55:59.573 --> 15:56:08.233
如果我们建立一个监听器我们不希望它在监听器完成监听之前结束，所以我们需要再次创建一个新的承诺。

11605
15:56:08.233 --> 15:56:12.948
这将是非常重要的，特别是对于我们的分期测试。

11606
15:56:12.948 --> 15:56:15.477
我们来看看await, new promise。

11607
15:56:15.477 --> 15:56:18.542
这将和我们之前设置的完全一样，

11608
15:56:18.542 --> 15:56:25.081
这将是一个async函数将resolve和reject作为参数。

11609
15:56:25.081 --> 15:56:32.340
我们会用这个小箭头语法说，这是一个async函数，我们会再次设置once语法，

11610
15:56:32.340 --> 15:56:39.228
我们会说raffle once，事件名是什么，winner chosen。

11611
15:56:39.228 --> 15:56:46.508
我们会说，听，对于这个winner chosen事件，我们会说raffle。一旦winner chosen发生，做一些事情。

11612
15:56:46.573 --> 15:56:49.027
再说一次，这只是一个匿名函数。

11613
15:56:49.573 --> 15:56:53.376
我们说raffle。一旦winner chosen事件被触发，做一些事情。

11614
15:56:53.376 --> 15:56:55.425
我们把这个设置好了。

11615
15:56:55.425 --> 15:57:01.523
现在它在这个函数中，我们要把所有的cert加上因为我们想等冬天被选中。

11616
15:57:01.573 --> 15:57:08.001
在事件被触发之前，我们当然需要调用，执行，调用，fullrandomwords。

11617
15:57:08.001 --> 15:57:10.952
所以这看起来有点倒退。

11618
15:57:10.952 --> 15:57:15.977
但那是因为我们想要设置监听器当我们触发触

11619
15:57:15.977 --> 15:57:21.003
发事件的方法时，监听器会被激活并等待它。

11620
15:57:21.003 --> 15:57:24.861
我们会把所有的代码都放在这个承诺里面。

11621
15:57:24.861 --> 15:57:32.823
现在，因为我们把它放在promise外面，我们把所有的代码放在promise外面，这个promise永远不会被解决，因为监听器永远不会触发到vent。

11622
15:57:32.823 --> 15:57:38.349
如果在下面这里，我们调用fullrandom words with something，你知道哪个拼写不好。

11623
15:57:38.349 --> 15:57:43.111
但假设我们调用下面这里，这段代码永远不会到达这

11624
15:57:43.111 --> 15:57:48.081
个完全随机单词，因为它总是在等待这个想要被解析。

11625
15:57:48.081 --> 15:57:51.446
所以我们需要在承诺中添加所有的代码。

11626
15:57:51.574 --> 15:57:57.669
但是在这个抽奖点外面我们不想永远等下去，对吧?也许这里有问题。

11627
15:57:57.669 --> 15:58:01.113
如果有问题，我们希望能够拒绝它。

11628
15:58:01.113 --> 15:58:05.636
现在我们能做的是在我们的heart hat。config中，我们能添加一个超时。

11629
15:58:05.636 --> 15:58:11.726
我们可以添加这个mocha部分，我们可以给自己一个200,

11630
15:58:11.726 --> 15:58:17.816
000毫秒的超时，也就是200秒，如果这个事件在200秒内

11631
15:58:17.816 --> 15:58:24.328
没有被触发，这将被认为是失败，这个测试将失败，这是我们想要的。

11632
15:58:24.328 --> 15:58:31.639
我通常喜欢用try catch来表示因为如果失败了，就会引起一大堆头疼的catch E。

11633
15:58:31.639 --> 15:58:39.360
如果任何东西失败了，我们也会拒绝，我们调用一些函数是有问题的，我们会说，嘿，好，这是一个失败。

11634
15:58:39.360 --> 15:58:44.416
但如果失败了，我们的承诺就能及时得到解决，我们稍后会加入这段代码。

11635
15:58:44.416 --> 15:58:45.889
让我们继续。

11636
15:58:45.889 --> 15:58:47.081
让我们继续。

11637
15:58:47.081 --> 15:58:53.875
不好意思，trycatch应该在那些，在结果上面的那些，不好意思，因为这是监听器。

11638
15:58:53.875 --> 15:58:59.518
抱歉，我们希望trycatch在其中如果这花费太长时间，我们会抛出一个错误。

11639
15:58:59.574 --> 15:59:05.559
否则，我们会在监听器外部解析，但在promise内部，我们会在这里做这一点，

11640
15:59:05.559 --> 15:59:14.064
我们会去const TX = await raffle。perform upkeep，我们会把空字节对象传递

11641
15:59:14.064 --> 15:59:21.469
把空字节对象传递给它，我们会得到const TX receipt = await TX。一个block的权重。

11642
15:59:21.575 --> 15:59:27.851
然后我们会做一个权重VRF核心没有一个t

11643
15:59:27.851 --> 15:59:34.440
our是mock。实现随机单词，CX收据。

11644
15:59:34.440 --> 15:59:40.717
事件。args。请求ID来抽奖那个地址。

11645
15:59:40.717 --> 15:59:46.021
最后我们要做的是我们会让这个转向协调器变成mock我们会让它调

11646
15:59:46.021 --> 15:59:51.325
用fullrandomwords，它接受请求ID和消费者地址。

11647
15:59:51.325 --> 15:59:57.763
我们会模拟它，给它从事务收据中获取的请求ID，还有这里的消费者地址。

11648
15:59:57.763 --> 16:00:02.075
在这个承诺中，我们为这个获胜者挑选的事件设置了一个监听器。

11649
16:00:02.075 --> 16:00:06.747
然后我们嘲笑通灵守护者然后我们嘲笑链链VRF。

11650
16:00:06.747 --> 16:00:13.195
一旦这个函数被调用这个函数就会发出一个winner chosen事件。

11651
16:00:13.195 --> 16:00:18.709
所以这个被设置的用来监听这个信号发射的抽奖会捡起来，

11652
16:00:18.709 --> 16:00:23.800
然后说，好吧，我找到它了，我找到赢家选择事件了。

11653
16:00:23.800 --> 16:00:26.251
现在我们可以继续做一些事情了。

11654
16:00:26.251 --> 16:00:33.413
一旦winner chosen事件被触发，我们会做一个console。log像这样找到事件然

11655
16:00:33.413 --> 16:00:40.575
后我们会跳转到我们的trycatch这个trycatch基本上就是我们在这里做所有这些断言。

11656
16:00:40.575 --> 16:00:48.406
首先我们要写const recent winner = await raffle。get

11657
16:00:48.406 --> 16:00:58.196
recent winner我们要检查抽奖中的所有内容我们要检查最近的赢家抽奖状态被重置玩家被重置，等等等等。

11658
16:00:58.196 --> 16:01:02.246
所以我们说const raffle state =

11659
16:01:02.246 --> 16:01:08.242
waitraffle。get raffle state我们说const。

11660
16:01:08.242 --> 16:01:14.440
结束时间戳等于等待，抽奖点获取最后的时间戳。

11661
16:01:14.440 --> 16:01:17.406
让我们开始做一些断言。

11662
16:01:17.576 --> 16:01:22.401
因此，首先我们应该断言这个es players数组已重置为零。

11663
16:01:22.401 --> 16:01:26.042
如果我们调用getnumber of players，它应该是0。

11664
16:01:26.042 --> 16:01:31.125
我们可以用const num players = await

11665
16:01:31.125 --> 16:01:36.379
raffle。get number players，像这样。

11666
16:01:36.379 --> 16:01:41.576
我们可以断言。等于9个参与人。

11667
16:01:41.576 --> 16:01:43.992
到字符串将是零。

11668
16:01:43.992 --> 16:01:48.596
我们还能断言什么?我们可以断言。

11669
16:01:48.596 --> 16:01:54.641
equal raffle状态应该是开放的。

11670
16:01:54.641 --> 16:01:56.477
抽奖状态。

11671
16:01:56.477 --> 16:02:01.413
string应该为0，我们应该断

11672
16:02:01.413 --> 16:02:06.350
言结束时间戳现在大于开始时间戳。

11673
16:02:06.350 --> 16:02:10.176
因为最后的时间戳应该已经更新了。

11674
16:02:10.176 --> 16:02:13.050
我们还想确保我们最近的赢家是正确的。

11675
16:02:13.050 --> 16:02:15.965
我们用console。log recent winner。

11676
16:02:15.965 --> 16:02:18.769
现在我们可以转到VRF协调器模拟。

11677
16:02:18.769 --> 16:02:23.805
我们可以模拟这个过程并试着找出随机的赢家是谁来控制。记录帐户。

11678
16:02:23.805 --> 16:02:30.174
然后我们来展示一些，我们用01和3来做raffle。

11679
16:02:30.174 --> 16:02:37.524
once这需要是一个async函数，而不仅仅是一个普通函数。

11680
16:02:37.524 --> 16:02:42.305
让我们再试一次，get latest timestamp是正确的函数。

11681
16:02:42.305 --> 16:02:44.661
让我们用正确的最新更新这个。

11682
16:02:44.661 --> 16:02:46.119
把latest写在这里。

11683
16:02:46.119 --> 16:02:48.763
因为我拼写错了。

11684
16:02:48.763 --> 16:02:53.842
看起来好像我们还没初始化就打印出了最近的赢家。

11685
16:02:53.842 --> 16:02:54.779
我们把它上移。

11686
16:02:54.779 --> 16:02:57.992
然后我们写console。log recent winner。

11687
16:02:57.992 --> 16:03:00.860
我知道这是一个巨大的考验。

11688
16:03:00.860 --> 16:03:05.243
让我们试一试，看看是否一切都符合我们的要求。

11689
16:03:05.243 --> 16:03:08.993
这里的速度在放缓，这是好事，因为我们正在做很多事情。

11690
16:03:08.993 --> 16:03:13.764
啊哈，我们终于把这个过去的东西拿出来了。

11691
16:03:13.764 --> 16:03:19.441
我们做了很多console。logging这里有很多签名者的东西被打印出来。

11692
16:03:19.441 --> 16:03:21.814
让我们把它写得容易一点。

11693
16:03:21.814 --> 16:03:26.545
我们把。address加到所有这些，我们就知道谁是赢家了。

11694
16:03:26.545 --> 16:03:30.827
看起来赢家是一号账户，这很好。

11695
16:03:30.827 --> 16:03:35.538
我们现在能做的是，我们知道1号帐户将是赢家，我们可以让赢家的初始余

11696
16:03:35.538 --> 16:03:40.249
额在调用complederrandom words之前一直到这里。

11697
16:03:40.249 --> 16:03:44.872
我们写入const winner，初始余额= await

11698
16:03:44.872 --> 16:03:52.139
accounts 1。get balance，你可以像这样调用get balance。

11699
16:03:52.139 --> 16:03:57.496
现在我们在测试中有了winner的初始余额，我们可以说const

11700
16:03:57.496 --> 16:04:04.529
winner，结束余额= await ounce one。get balance。

11701
16:04:04.529 --> 16:04:09.512
我们可以确保获胜者得到他们需要的报酬。

11702
16:04:09.512 --> 16:04:15.105
现在我们要做一个关于钱的断言，相信我，这就是数学运算。

11703
16:04:15.105 --> 16:04:19.744
我们要做断言。equal winner balance。

11704
16:04:19.744 --> 16:04:24.448
到弦，对不起冬天结束平衡。

11705
16:04:24.448 --> 16:04:30.651
到字符串应该等于赢家的起始余

11706
16:04:30.651 --> 16:04:36.854
额点加上抽奖入场费乘以额外的

11707
16:04:36.854 --> 16:04:43.501
恍惚加上我们支付的抽奖入场费。

11708
16:04:43.501 --> 16:04:44.193
字符串。

11709
16:04:44.193 --> 16:04:48.760
这个计算基本上是说，赢家最终应该得

11710
16:04:48.760 --> 16:04:53.328
到所有其他人加到合同中的钱的余额。

11711
16:04:53.328 --> 16:04:54.188
就是这样。

11712
16:04:54.188 --> 16:04:56.764
所以我们可以再做一次测试。

11713
16:04:56.764 --> 16:04:58.509
天啊，该死的，它通过了。

11714
16:04:58.509 --> 16:05:00.474
这里有很多代码。

11715
16:05:00.578 --> 16:05:06.028
这可能是整个课程中最难的部分之一就是这部分。

11716
16:05:06.028 --> 16:05:08.778
所以如果你在这个问题上有一点挣扎，不要让它使你陷入困境。

11717
16:05:08.778 --> 16:05:16.110
这可能是这门课比较难的部分之一，让我们快速复习一下我们正在做的这个测试。

11718
16:05:16.110 --> 16:05:18.335
当我们做的时候，我们会看到一个动作。

11719
16:05:18.335 --> 16:05:19.316
在我们的分期测试中。

11720
16:05:19.316 --> 16:05:22.806
我们所做的就是选出一个中奖者重新设置彩票，然后给钱。

11721
16:05:22.806 --> 16:05:29.734
基本上，我们所做的就是测试这个完成随机单词的东西是否达到了我们的要求随机赢家胜出，他们得到了钱。

11722
16:05:29.734 --> 16:05:34.178
我们要怎么做呢?首先，我们让一群随机的人参加抽奖。

11723
16:05:34.178 --> 16:05:34.478
太好了。

11724
16:05:34.578 --> 16:05:35.349
听起来不错。

11725
16:05:38.578 --> 16:05:44.205
执行维护并实现随机单词时，我们希望假装抽取了随机数。

11726
16:05:44.205 --> 16:05:52.807
这就是下面这段代码的作用它调用那个随机数但是我们可以做的是我们可以有所有这些断言并检查所有的变量。

11727
16:05:52.807 --> 16:05:54.036
在我们做完这个之后。

11728
16:05:54.036 --> 16:05:56.020
我们完全可以这么做。

11729
16:05:56.020 --> 16:06:01.527
然而，在一个测试网络上，我们并不总是确切地知道一个事务将在何时结束。

11730
16:06:01.579 --> 16:06:06.645
我们必须等待如果我们必须监听一个事件被触发，在这之前，我们可以调

11731
16:06:06.645 --> 16:06:11.712
用事务来结束整个事情，我们需要设置一些东西来监听那个事件被触发。

11732
16:06:11.712 --> 16:06:18.526
我们说，只有当这个事件被触发时只有当这个事务被调用时，我们才能对本地网

11733
16:06:18.526 --> 16:06:25.340
络进行测试，我们模仿VRF协调器，我们有控制，我们知道它什么时候运行。

11734
16:06:25.340 --> 16:06:27.117
但在一个测试网上，我们没有。

11735
16:06:27.117 --> 16:06:30.688
所以你会在我们的阶段性测试中看到，我们这里不会有任何这些。

11736
16:06:30.688 --> 16:06:39.507
我们必须要建立一个监听器来监听通灵的VRF和守卫者来触发他们的事件。

11737
16:06:39.507 --> 16:06:44.579
这就是为什么分期测试是如此重要，以确保我们做的每件事都是正确的。

11738
16:06:44.579 --> 16:06:52.429
这就是为什么我们要设置这样的本地测试，这样它就能模拟我们在语句测试中要做的事情也就是我们在真实网络中要做的事情。

11739
16:06:52.429 --> 16:06:57.879
再一次，我们设置了这个监听器我们说，啊，一旦我们在这里做了这

11740
16:06:57.879 --> 16:07:03.511
个事件，然后我们会试着检查所有的余额并检查一切都按照预期运行。

11741
16:07:03.511 --> 16:07:05.872
如果我们看不到它，我们就会拒绝。

11742
16:07:05.872 --> 16:07:11.382
如果有一个超时，如果时间超过200秒，我们会说，好，出错了，我们会取消它。

11743
16:07:11.382 --> 16:07:16.398
实际上，我要把时间增加到300秒，因为我觉得200秒不够用。

11744
16:07:16.398 --> 16:07:21.445
根据冰场B测试的速度，你可能要把它放大。

11745
16:07:21.445 --> 16:07:24.911
记住这一点。

11746
16:07:24.911 --> 16:07:29.293
我们刚刚做了一些很棒的测试。

11747
16:07:29.293 --> 16:07:36.483
让我们继续，让我们运行h h测试，看看是否所有的测试都能通过。

11748
16:07:36.579 --> 16:07:41.380
好的，14个传球，所有的都传球了，我们看起来很好。

11749
16:07:41.580 --> 16:07:42.929
这太棒了。

11750
16:07:46.580 --> 16:07:49.338
让我们继续创建一个分段测试。

11751
16:07:50.580 --> 16:07:54.644
看起来和我们刚才在下面创建的大型测试非常相似。

11752
16:07:54.644 --> 16:08:00.226
我们设置单元测试的原因是用抽奖点来做权重承诺因为这实

11753
16:08:00.226 --> 16:08:05.808
际上是我们需要在测试网或主网上等待赢家被选中的方式。

11754
16:08:05.808 --> 16:08:11.225
我们不能在一个真实的测试网中，假装是链链V REF，我们可以假装是链链管理员，如果我们想的话。

11755
16:08:11.225 --> 16:08:14.924
但我们不能确保这10个看守人真的在工作。

11756
16:08:14.924 --> 16:08:19.733
但我们这样做是因为我们想要监听事件被触发，

11757
16:08:19.733 --> 16:08:24.313
我们想要监听链接VRF对获胜者作出响应。

11758
16:08:24.313 --> 16:08:26.354
让我们创建一个阶段性测试。

11759
16:08:26.354 --> 16:08:30.849
这个测试我们将在一个真实的测试网上进行。

11760
16:08:30.849 --> 16:08:34.772
好，我们要创建一个新的测试叫做raffle。

11761
16:08:34.772 --> 16:08:40.301
staging。test。Jas这是我们要进行分期测试的地方。

11762
16:08:40.301 --> 16:08:46.630
现在我们可以很快地编写这个代码因为我们的大部分阶段性测试看起来和我们的抽奖测试非常相似。

11763
16:08:46.630 --> 16:08:51.783
现在，我们只看第一部分，然后根据需要进行调整。

11764
16:08:51.783 --> 16:08:53.206
然后我们把它关闭。

11765
16:08:53.206 --> 16:09:00.235
因为我们肯定需要抽奖，我们不需要VRF协调器模拟因为我们不会使用模拟。

11766
16:09:00.235 --> 16:09:06.037
因为我们在一个真实的测试网上，我们需要抽奖入场费，我们需要部署者，我们需要部署者。

11767
16:09:06.037 --> 16:09:07.416
我们可能需要这个区间。

11768
16:09:07.416 --> 16:09:10.264
先把它删掉吧我们可能不需要chain ID了。

11769
16:09:10.264 --> 16:09:11.776
把这个也删掉。

11770
16:09:11.776 --> 16:09:12.169
太棒了。

11771
16:09:12.169 --> 16:09:18.665
我们要记住的一点是，当涉及到阶段性测试时，我们只希望在进行测试时运行蒸汽测试。

11772
16:09:18.665 --> 16:09:27.023
我们不需要运行我们的单元测试因为我们的单元测试不会检查与测试网的兼容性，我们希望我们的单元测试只在本地网络上运行。

11773
16:09:27.023 --> 16:09:30.597
我们希望我们的分期测试只在测试网络上运行。

11774
16:09:30.597 --> 16:09:35.331
在我们的测试中，我们要检查我们用的是哪种链。

11775
16:09:35.331 --> 16:09:38.781
哎呀，看起来我已经在这里导入了开发更改。

11776
16:09:38.781 --> 16:09:44.530
所以我们实际上在进行分期测试，在我们运行任何测试之前，我们要检查我们所使用的网络是什么样的。

11777
16:09:44.581 --> 16:09:53.151
我们会说，如果我们的开发链包含network。name，我们会说如果我们的开发链包含network to

11778
16:09:53.151 --> 16:10:01.886
name，那么如果我们所处的链在开发链中，同样，我们会使用这个三元运算符，如果我们在开发链中，做些什么。

11779
16:10:01.886 --> 16:10:04.269
如果我们不在开发链上，那就做点别的。

11780
16:10:04.269 --> 16:10:12.269
如果我们在开发链上，我们要做什么?我们想跳过这个我们可以通过输入description。skip跳过这个。

11781
16:10:12.269 --> 16:10:14.750
这将跳过这一整部分。

11782
16:10:14.750 --> 16:10:19.744
然后我们可以说，如果我们是开发链，继续做我们的事情。

11783
16:10:19.744 --> 16:10:25.181
这是很好的语法它允许我们在本地网络上跳过分段测试。

11784
16:10:25.181 --> 16:10:30.081
另外，我们可以抓取这个语法，进入我们的raffle。test。j s

11785
16:10:30.081 --> 16:10:34.981
里面有单元测试然后添加bang运算符，也就是knot，然后点击保存。

11786
16:10:34.981 --> 16:10:41.831
现在我们说，如果我们不在开发链上，跳过它，只在我们不在开发链上时运行这个。

11787
16:10:41.831 --> 16:10:44.481
这就是说只能在测试网或主网上运行。

11788
16:10:44.581 --> 16:10:46.924
这个只在本地网络上运行。

11789
16:10:46.924 --> 16:10:47.205
太好了。

11790
16:10:47.581 --> 16:10:49.665
有一个我们需要的部署人员。

11791
16:10:50.581 --> 16:10:57.387
需要部署任何fixture，因为我们将运行部署脚本，而契约应该已经部署好了。

11792
16:10:57.387 --> 16:11:04.361
我们将需要抽奖，我们不需要VRF协调模拟，我们可以删除，我们将需要门票费用，我们可能不需要间隔。

11793
16:11:04.361 --> 16:11:05.734
我们可以把这个也删掉。

11794
16:11:05.734 --> 16:11:06.598
好的,太棒了。

11795
16:11:06.598 --> 16:11:10.349
我们有了描述，我们有了之前，让我们做测试。

11796
16:11:10.349 --> 16:11:15.259
我要做一个巨大的测试从头到尾测试所有东西。

11797
16:11:15.259 --> 16:11:23.828
如果你想的话，你可以在以后自己添加更多的测试我们的阶段性测试和我们在下面做的大规模测试非常相似。

11798
16:11:23.828 --> 16:11:26.891
实际上，我们将使用这里的大部分代码作为我们的样板。

11799
16:11:26.891 --> 16:11:28.133
我们来创建一个描述。

11800
16:11:28.133 --> 16:11:34.132
我们会说，我们实际上只是复制这个描述四个随机单词并粘贴到这里。

11801
16:11:34.132 --> 16:11:38.323
因为我们将在这里的分段测试中使用很多相同的代码。

11802
16:11:38.323 --> 16:11:38.903
太好了。

11803
16:11:38.903 --> 16:11:44.601
所以现在我们说它适用于活的链链保持器和链链

11804
16:11:44.601 --> 16:11:50.300
VRF，我们得到一个随机赢家，ace函数。

11805
16:11:50.300 --> 16:11:53.425
这就是我们的测试。

11806
16:11:53.582 --> 16:11:57.264
在这个测试中，我们当然要参加抽奖。

11807
16:11:57.582 --> 16:12:01.788
除了参加抽奖，我们什么都不用做。

11808
16:12:01.788 --> 16:12:06.879
因为链，管理员和唯一的VRF将为我们真正开启这个抽奖，

11809
16:12:06.879 --> 16:12:11.970
我们将快速抓取开始时间戳，在所有这一切开始之前拥有它。

11810
16:12:11.970 --> 16:12:20.260
因此我们写入const starting timestamp = await raffle。get last to

11811
16:12:20.260 --> 16:12:28.695
me get最新时间戳，get最新时间戳，我们将获取这个因为稍后，我们将测试时间戳是否真的向前移动，我们想进入抽奖，

11812
16:12:28.695 --> 16:12:37.277
我们想运行我们一直在这里运行的命令，我们想做await raffle。enter raffle，但我们还不想调用它。

11813
16:12:37.277 --> 16:12:42.430
因为和这里一样，我们想先设置监听器。

11814
16:12:42.430 --> 16:12:46.963
在这里，我们可能应该在进入抽奖之前设置好监听器。

11815
16:12:46.963 --> 16:12:49.375
然而，我们控制了区块链。

11816
16:12:49.375 --> 16:12:52.260
所以按这个顺序是可以的。

11817
16:12:52.260 --> 16:12:59.123
但我们想在进入抽奖之前设置监听器以防区块链移动得非常快。

11818
16:12:59.123 --> 16:13:03.549
我们会用完全相同的方式设置监听器，我们在这里做过。

11819
16:13:03.549 --> 16:13:05.933
我们会说，等待新承诺。

11820
16:13:05.933 --> 16:13:09.599
这将是一个接受解析和拒绝的异步函数。

11821
16:13:09.599 --> 16:13:12.318
我们在这里用一个小箭头符号。

11822
16:13:12.318 --> 16:13:18.215
在这里，我们会设置监听器，我们会说raffle。once，一

11823
16:13:18.215 --> 16:13:24.310
旦胜者被选中，我们会用那个Arrow来做另一个async函数。

11824
16:13:24.583 --> 16:13:31.812
箭头函数语法，我们写入console。log winner chosen the event fired。

11825
16:13:31.812 --> 16:13:37.864
只有当我们选中了这个赢家，我们才能在这里进行断言，我们才能确保有

11826
16:13:37.864 --> 16:13:43.916
一个赢家，有一个可验证的随机赢家，它被选中了，钱被转移了，等等。

11827
16:13:43.916 --> 16:13:45.852
我们就在这里尝试接球。

11828
16:13:45.852 --> 16:13:52.333
如果有任何错误，我们会自动拒绝，我们会拒绝承诺。

11829
16:13:52.333 --> 16:13:56.828
如果一切顺利，当然，我们会解决这个承诺。

11830
16:13:56.828 --> 16:13:58.126
我们的监听器已经设置好了。

11831
16:13:58.126 --> 16:13:59.683
我们还没有在这里添加断言。

11832
16:13:59.683 --> 16:14:02.883
但是我们会的，让我们继续写剩下的测试。

11833
16:14:02.883 --> 16:14:08.244
然后我们返回，更新这个监听器我们的监听器被添加了。

11834
16:14:08.244 --> 16:14:10.550
这里是我们抽奖的地方。

11835
16:14:10.583 --> 16:14:14.818
在这里，等待，raffle。enter

11836
16:14:14.818 --> 16:14:20.169
raffle value将是raffle门票。

11837
16:14:20.169 --> 16:14:22.341
就是这样了。

11838
16:14:22.341 --> 16:14:28.838
对吧?我们设置了监听器，设置了监听器，然后进入抽奖。

11839
16:14:28.838 --> 16:14:33.432
这段代码直到监听器听完才会完

11840
16:14:33.432 --> 16:14:38.026
成因为整个SEC都在等待中。

11841
16:14:38.026 --> 16:14:41.734
我们会说，设置很好，监听器，等待它完成。

11842
16:14:41.734 --> 16:14:49.770
然后当它到达这里时，它会出去好了，这是代码的结束我们都执行完了吗?哦，没有解析或拒绝还没有被调用。

11843
16:14:49.770 --> 16:14:53.155
这是因为我们还在等待听者听完。

11844
16:14:53.155 --> 16:15:00.295
一旦我们把这个winner chosen事件发出到这里，我们就会得到那个最近的winner我们会说const

11845
16:15:00.295 --> 16:15:08.890
recent winner = await raffle。get recent winner将会得到抽奖状态我们会说const。

11846
16:15:08.890 --> 16:15:15.459
抽奖状态等于等待抽奖点获得抽奖状态，我们将得到获胜者的余额。

11847
16:15:15.459 --> 16:15:17.834
所以我们用const。

11848
16:15:17.834 --> 16:15:22.422
赢家平衡等于等待最近的赢家。

11849
16:15:22.422 --> 16:15:31.092
因为我们只进入部署者我们应该检查部署者的平衡在最后我们不能用这个部署者对象做正确的事情。

11850
16:15:31.092 --> 16:15:36.896
所以我们要写player account = await

11851
16:15:36.896 --> 16:15:44.773
ethers。get signers，不用换行这实际上会说这是这样的账户。

11852
16:15:44.773 --> 16:15:49.390
然后我们会做一个计数为0的计数因为0将被计算为我们的部署者。

11853
16:15:49.390 --> 16:15:53.122
赢家余额将是账户a乘以余额。

11854
16:15:53.122 --> 16:15:59.163
然后我们要做const ending timestamp =一个weight

11855
16:15:59.163 --> 16:16:06.158
raffle。get latest to timestamp，我们也应该得到初始余额。

11856
16:16:06.158 --> 16:16:12.335
我们说赢家期末余额，我们也应该在进入后得到初始余额。

11857
16:16:12.335 --> 16:16:14.251
所以我们用const。

11858
16:16:14.251 --> 16:16:19.274
赢家，初始余额等于等待账户。

11859
16:16:19.274 --> 16:16:24.108
零导得到平衡，现在我们可以做一些比较。

11860
16:16:24.108 --> 16:16:24.917
好的，很好。

11861
16:16:24.917 --> 16:16:26.297
现在我们来做比较。

11862
16:16:26.297 --> 16:16:29.635
所以我们首先应该期待抽奖被重置。

11863
16:16:29.635 --> 16:16:32.172
我们可以用几种不同的方法来做。

11864
16:16:32.172 --> 16:16:32.806
下来。

11865
16:16:32.806 --> 16:16:34.393
我们做了很多球员。

11866
16:16:34.585 --> 16:16:42.423
我们也可以说，等待，期待抽奖，得到玩家0。

11867
16:16:43.585 --> 16:16:50.447
点返回，因为Get Player 0应该会被返回因为在0处甚至没有对象。

11868
16:16:50.447 --> 16:16:54.369
这是另一种检查players数组是否重置的方法。

11869
16:16:54.369 --> 16:16:58.335
接下来，我们可以断言。equal recent winner。

11870
16:16:58.335 --> 16:17:05.140
对于字符串，这应该等于我们的帐户0。address。

11871
16:17:05.140 --> 16:17:11.928
好的，我们的部署者我们还能做什么?我们断言。equal抽奖状态为零。

11872
16:17:11.928 --> 16:17:15.635
我们想让这封邮件在我们完成后重新打开。

11873
16:17:15.635 --> 16:17:19.221
最后，我们要确保钱被正确地转移了。

11874
16:17:19.221 --> 16:17:25.031
所以我们断言。equal，这应该是赢家结束的余额。

11875
16:17:25.031 --> 16:17:30.205
那到弦要等于中奖者的起

11876
16:17:30.205 --> 16:17:35.851
始余额，加上抽奖入场费。

11877
16:17:35.851 --> 16:17:36.451
字符串。

11878
16:17:36.451 --> 16:17:43.103
如果我们往下看，他们进入抽奖我们在他们进入后检查他们的初始余额。

11879
16:17:43.103 --> 16:17:49.552
他们基本上应该拿回抽奖的入场费因为他们是唯一参加抽奖的人。

11880
16:17:49.552 --> 16:17:57.176
然后我们可以再做一个断言，断言结束时间戳大于开始时间戳。

11881
16:17:57.176 --> 16:17:59.667
然后我们当然会说resolve。

11882
16:17:59.667 --> 16:18:02.141
如果一切顺利，我们就解决。

11883
16:18:02.141 --> 16:18:09.222
如果这些断言有问题，我们会捕捉到这些错误，然后拒绝，这将为假。

11884
16:18:09.222 --> 16:18:14.938
整个测试会这样，有一个问题，我们现在有一个分期测试，看起来很好。

11885
16:18:14.938 --> 16:18:16.489
我们来试试这个。

11886
16:18:16.489 --> 16:18:22.359
让我们从头到尾尝试我们的分期测试。

11887
16:18:23.586 --> 16:18:30.489
所以现在为了让我们测试这个阶段性测试，从头到尾，你首先需要得到我们的通道恐惧F

11888
16:18:30.489 --> 16:18:37.392
的子ID然后我们需要使用子ID部署我们的合同，我们需要用链链接VRF注册合同。

11889
16:18:37.392 --> 16:18:41.946
我们需要把它注册到链链管理员那里。

11890
16:18:41.946 --> 16:18:44.749
当然，我们还要进行阶段性测试。

11891
16:18:44.749 --> 16:18:45.486
我们开始做吧。

11892
16:18:45.586 --> 16:18:49.672
我们要做的第一件事是什么?获取链接VRF的子ID。

11893
16:18:49.672 --> 16:18:50.292
好了,好了。

11894
16:18:50.292 --> 16:18:53.137
下面我们来看看VRF。chain。link。

11895
16:18:53.137 --> 16:18:56.173
我们需要创建一个新的订阅。

11896
16:18:56.173 --> 16:18:58.458
如果我们没有足够的冰球场。

11897
16:18:58.586 --> 16:19:04.586
让我们进入完整的区块链固体性课程，在这里，我们要向下滚动。

11898
16:19:04.586 --> 16:19:08.344
我们要寻找推荐的测试，这里，排名是v。

11899
16:19:08.344 --> 16:19:15.881
我们将使用水龙头链接得到一些Rigby链接，运行Fosses。chain。link，让我们从COVID转换到铈。

11900
16:19:15.881 --> 16:19:18.914
里格比，我们知道我们需要一些联系和证据。

11901
16:19:18.914 --> 16:19:21.864
所以我们把两者都取下来。

11902
16:19:21.864 --> 16:19:27.570
好的，很好，现在我们的交易已经完成了，让我们再检查一下我们的钱包。

11903
16:19:27.570 --> 16:19:30.780
看起来我们确实有以太坊。

11904
16:19:30.780 --> 16:19:36.483
如果你没有看到链接，你可以转到link令牌合约，link令牌合约在link文档中。

11905
16:19:36.483 --> 16:19:43.264
我们向下滚动到Rigby，我们抓取这个合同地址导入令牌，然后粘贴到这里。

11906
16:19:43.264 --> 16:19:45.845
添加自定义令牌，导入令牌。

11907
16:19:45.845 --> 16:19:46.328
太好了。

11908
16:19:46.328 --> 16:19:49.654
现在我可以看到我的eath和我的链接，完美。

11909
16:19:49.654 --> 16:19:53.398
我们有一些我们有一些链接，让我们转到V REF订阅管理。

11910
16:19:53.398 --> 16:19:55.692
我们将创建一个新的订阅。

11911
16:19:55.692 --> 16:20:01.103
同样，我们完全可以通过编程来完成，因为这里的用户界面只帮助我

11912
16:20:01.103 --> 16:20:06.515
们促进对注册契约的调用契约，注册契约是完全去中心化和链上的。

11913
16:20:06.515 --> 16:20:12.691
让我们继续创建订阅将创建订阅将确认交易在Rinkeby网络上的M

11914
16:20:12.691 --> 16:20:19.062
etamask将进行一些操作很好一旦通过，你可以点击添加资金按钮。

11915
16:20:19.062 --> 16:20:23.393
我将向你们展示如果你不小心刷新并跳下去会是什么样子。

11916
16:20:23.393 --> 16:20:28.744
如果你刷新，然后返回离开chain。link，你应该有一个新的活动订阅。

11917
16:20:28.744 --> 16:20:30.602
你会看到这个数字。

11918
16:20:30.602 --> 16:20:34.242
如果你点击它，这是你的订阅ID很好。

11919
16:20:34.242 --> 16:20:40.341
我们可以用这个，回到我们的代码到我们的助手Hardhead配置中。

11920
16:20:40.341 --> 16:20:46.373
我们可以把我们的订阅ID贴在我们的Rinkeby网络的订阅ID下面。

11921
16:20:46.373 --> 16:20:46.897
太棒了。

11922
16:20:46.897 --> 16:20:51.387
现在我们有一个订阅，我们可以看到它没有任何链接的资金。

11923
16:20:51.387 --> 16:20:53.349
所以这里没有神谕气体。

11924
16:20:53.349 --> 16:20:54.976
我们没有任何消费者。

11925
16:20:54.976 --> 16:20:58.962
对，我们的消费者将是抽奖或抽签合同。

11926
16:20:58.962 --> 16:21:04.702
让我们先加入一些资金我们不需要加入很多因为我们只需要测试一次。

11927
16:21:04.702 --> 16:21:11.757
我们在这里添加一个link，这个数字可能会根据测试网的不同成本和可用的link令牌的数量而变化。

11928
16:21:11.757 --> 16:21:17.824
所以如果你真的在主网上工作，一定要浏览Doc的链接EVM链的合同地址，

11929
16:21:17.824 --> 16:21:23.719
你可以阅读更多关于这些不同链的成本，所以你可以弄清楚在这里放多少钱。

11930
16:21:23.719 --> 16:21:28.900
如果你上完整的区块链固体性课程，Jas，我们可以向下滚动到第

11931
16:21:28.900 --> 16:21:34.254
九课，有一个推荐的链接数量或链链接VRF的rinky保存测试。

11932
16:21:34.254 --> 16:21:39.398
现在我们要放2个给keepers，我们要放8个，但请随意参考这里，这样你就知道要放多少了。

11933
16:21:39.398 --> 16:21:44.054
我们来确认一下，我们要批准增加资金，请确认一下。

11934
16:21:44.054 --> 16:21:49.765
我们现在正在资助我们的订阅，这样我们就可以支付甲骨文的汽油来获得随机数。

11935
16:21:49.765 --> 16:21:50.055
太好了。

11936
16:21:50.055 --> 16:21:53.342
一旦我们得到资金，我们就可以关闭它，我们会稍微刷新一下。

11937
16:21:53.342 --> 16:21:57.981
我们可以看到，当我们没有任何消费者的时候，平衡就变成了链接。

11938
16:21:57.981 --> 16:22:01.095
我们有了我们的sub ID，我们资助了它。

11939
16:22:01.095 --> 16:22:04.164
现在让我们继续部署我们的契约。

11940
16:22:04.164 --> 16:22:10.259
我们已经知道，我们应该可以很好地部署我们的契约，我们到Dotty, V需

11941
16:22:10.259 --> 16:22:16.525
要添加之前项目中所有相同的参数，我们需要缩小RPC URL，我们需要私钥。

11942
16:22:16.525 --> 16:22:20.007
如果我们想要验证，我们需要以太扫描API密钥。

11943
16:22:20.007 --> 16:22:24.188
如果我们想做气体输出，我们需要我们的硬币市场市值API密钥。

11944
16:22:24.188 --> 16:22:25.968
我们要确保所有这些都有。

11945
16:22:25.968 --> 16:22:27.682
我们将查看部署脚本。

11946
16:22:27.682 --> 16:22:34.200
再一次，快速看一下我们的helper hardcat配置，快速看一下，看起来我们确实有所有的东西。

11947
16:22:34.200 --> 16:22:40.463
我们应该能够在一个命令中部署它。

11948
16:22:40.589 --> 16:22:48.266
所以我们应该能做纱线，硬帽或只是h h再次，策略，dash dash网络Rinkeby。

11949
16:22:48.266 --> 16:22:50.876
我们去试试吧。

11950
16:22:50.876 --> 16:22:55.189
好的，看起来我们编译成功了，部署成功了。

11951
16:22:55.189 --> 16:22:59.379
我们已经验证过了，我们可以用环宫以太扫描打开它。

11952
16:22:59.379 --> 16:23:01.985
我们可以看到我们的代码已经被验证过了。

11953
16:23:01.985 --> 16:23:03.699
它看起来很漂亮。

11954
16:23:03.699 --> 16:23:05.684
我们可以从中阅读，这很好。

11955
16:23:05.684 --> 16:23:08.169
我们可以在这里看到所有这些命令，现在它已经被验证了。

11956
16:23:08.169 --> 16:23:13.398
如果我们看一下Git抽奖状态，我们应该看到它是打开的，它会一

11957
16:23:13.398 --> 16:23:18.802
直保持打开直到有人结束抽奖并更新合同实际拥有的eath的数量。

11958
16:23:18.802 --> 16:23:24.017
现在我们已经使用那个子ID部署了一个契约，我们需要用chain link V REF注册契约。

11959
16:23:24.017 --> 16:23:25.350
还有链条看守人。

11960
16:23:25.350 --> 16:23:28.867
所以我们需要加上这个消费者确实告诉chinley VRF。

11961
16:23:28.867 --> 16:23:31.046
嘿，这就是你现在要找的合同。

11962
16:23:31.046 --> 16:23:36.201
回到vref。chain。link，我们会抓取这个合约地址，我们会把它

11963
16:23:36.201 --> 16:23:41.504
添加为消费者，你的订阅准备好了，你现在可以添加消费者了我们会添加消费者。

11964
16:23:41.504 --> 16:23:46.899
这个网站只是为了帮助我们与合同进行互动。

11965
16:23:46.899 --> 16:23:51.303
所以我们会批准这个用户，我们会继续并确认，然后交易就会进行下去。

11966
16:23:51.303 --> 16:24:00.072
在等待它通过的同时，我们可以访问keepers。chain。link，并对用户界面进行同样的操作，注册一个新的upkeep。

11967
16:24:00.072 --> 16:24:05.395
所以我们将继续添加我们的电子邮件Hardhead免费代码camp@gmail。

11968
16:24:05.395 --> 16:24:05.636
com。

11969
16:24:05.636 --> 16:24:08.055
我们把这叫做抽奖维护。

11970
16:24:08.055 --> 16:24:14.847
我们把维护地址粘贴到这里我们有管理地址，你可以忽略这一点。

11971
16:24:14.847 --> 16:24:18.827
对于气体限制，这将是PErforM维护函数的气体限制。

11972
16:24:18.827 --> 16:24:23.661
如果我们用气体估算器，我们可以看看执行维护的成本是多少。

11973
16:24:23.661 --> 16:24:29.090
但现在，我只放50万这可能有点多，但没关系。

11974
16:24:29.090 --> 16:24:33.574
检查数据，我们将保持空白因为我们的检查keep不会取任何东西。

11975
16:24:33.574 --> 16:24:36.161
然后是初始余额，设为8。

11976
16:24:36.161 --> 16:24:40.426
如果你忘记在这里写上初始余额，你总能在后面找到它。

11977
16:24:40.426 --> 16:24:46.145
注册，会弹出一个Metamask，点击确认。

11978
16:24:46.145 --> 16:24:53.393
我们可以回到我们的VRF，看到它确实被添加了，很好，我们现在有一个消费者在我们的VRF上。

11979
16:24:53.393 --> 16:24:59.224
现在让我们等待我们的管理员通过在域名网上成功提交的维护注册请求，你

11980
16:24:59.224 --> 16:25:05.056
可能需要等一段时间才能让你的请求通过，但我会测试它是否会自动通过。

11981
16:25:05.056 --> 16:25:13.219
现在回到keepers。chain。link，我们现在应该看到如果向下滚动到我的upkeeps，这里有一

11982
16:25:13.219 --> 16:25:21.540
个抽奖的upkeep因为我不小心使用了我测试的同一个账户，你可以忽略这两个你会有一个但这是我们刚刚创建的。

11983
16:25:21.590 --> 16:25:25.923
我们可以看到我们的余额以及最小余额是多少。

11984
16:25:25.923 --> 16:25:28.812
所以看起来连克8有点太低了。

11985
16:25:28.812 --> 16:25:32.933
让我们回到Fosses。chain。link / rinky。

11986
16:25:32.933 --> 16:25:37.380
现在我们有了更多的链接，我们可以回到我们的抽奖维护。

11987
16:25:37.380 --> 16:25:39.352
然后点击添加资金。

11988
16:25:39.352 --> 16:25:41.470
再加3。

11989
16:25:41.470 --> 16:25:46.751
我们将继续并确认我们首先需要获得支出许可。

11990
16:25:46.751 --> 16:25:52.923
我们批准了我们的链接转移，现在让我们实际转移链接到合同，好了，资金添加成功。

11991
16:25:52.923 --> 16:25:54.524
现在我们来刷新一下。

11992
16:25:54.524 --> 16:26:01.419
现在我们不再看到资金不足的信息，我们有我们的余额，我们可以看到它超过了最低余额。

11993
16:26:01.419 --> 16:26:04.066
我们已经看过我们两次资助这个项目的历史。

11994
16:26:04.066 --> 16:26:09.484
一旦这个启动，我们会看到活动类型会像，执行维护，或者，有我们的子ID，

11995
16:26:09.484 --> 16:26:15.057
我们部署了合约，我们注册了链链V REF，我们注册了链链keepers。

11996
16:26:15.057 --> 16:26:18.190
现在我们要做的就是进行分段测试。

11997
16:26:18.190 --> 16:26:26.705
现在运行我们的分期测试本质上和我们调用这个回车脚本是一样的，对吧，因为我们在分期测试中所做的就是进入彩票。

11998
16:26:26.705 --> 16:26:33.402
然后我们运行一大堆验证器来确保事情按照我们的预期进行，因为我们的合同实际上

11999
16:26:33.402 --> 16:26:40.280
是经过验证的，我们可以在Rigby以太扫描上做的是我们可以到合同的右边部分。

12000
16:26:40.280 --> 16:26:44.073
我们甚至可以把我们的钱包连接到它。

12001
16:26:44.073 --> 16:26:52.851
一旦它从红色变成绿色，稍作刷新后，我们会看到它是绿色的，它是连接的，我们甚至可以调用这个契约上的

12002
16:26:52.851 --> 16:27:01.813
函数，所以我们可以自己进入抽奖，我们会添加，不管进入抽奖有多少，这也会启动VRF中的keeper。

12003
16:27:01.813 --> 16:27:06.267
我们可以通过以太扫描调用它，我们可以通过这里的分段测试调用它，我们可

12004
16:27:06.267 --> 16:27:10.854
以通过脚本调用它，我们可以通过控制台调用它，有很多方法可以做到这一点。

12005
16:27:10.854 --> 16:27:16.061
但关键时刻，我们要运行阶段性测试，这将让我们进

12006
16:27:16.061 --> 16:27:21.268
入抽奖，并设置一个监听器，以确保一切正常工作。

12007
16:27:21.268 --> 16:27:25.670
此外，我们会在抽奖维护历史中看到一个交易，然

12008
16:27:25.670 --> 16:27:30.273
后我们会在我们的链上看到一个交易，比如VRF。

12009
16:27:30.273 --> 16:27:32.495
你准备好了吗?我当然是。

12010
16:27:32.591 --> 16:27:34.216
让我们开始吧。

12011
16:27:40.592 --> 16:27:42.362
这就是我们要做的。

12012
16:27:43.592 --> 16:27:49.541
我们可能应该在这里添加一些console。log来告诉我们每个步骤是什么。

12013
16:27:49.592 --> 16:27:50.480
但是我们忘记了。

12014
16:27:52.592 --> 16:27:56.280
与此相关的是，我们在测试中添加了console点日志。

12015
16:27:56.280 --> 16:28:04.285
好吧，如果我们去以太扫描这个合约，我们回到溜冰场以太扫描这个，我们粘贴那个地址，这是我

12016
16:28:04.285 --> 16:28:12.290
们在测试中做的第一步，当然，当我们设置这个监听器时，第一个交易将进入抽奖这将启动一切。

12017
16:28:12.290 --> 16:28:12.480
正确的。

12018
16:28:12.480 --> 16:28:17.247
所以如果我们在以太扫描上刷新一点，我们确实可以看到我们进入了抽奖。

12019
16:28:17.247 --> 16:28:20.592
我们更新了抽奖的余额。

12020
16:28:20.592 --> 16:28:21.668
好的,太棒了。

12021
16:28:21.668 --> 16:28:23.592
抽奖已经开始了。

12022
16:28:23.592 --> 16:28:30.430
接下来会发生什么?如果抽奖已经进入，如果我们进入raffle。soul，如果它是开放的，如

12023
16:28:30.430 --> 16:28:37.269
果足够的时间过去了，如果有玩家并且它有一个平衡，就像我们刚刚检查的那样，它会被看守人踢掉。

12024
16:28:37.269 --> 16:28:44.353
如果我们去到keepers，我们在这里做一点刷新，过了一会儿，我们确实

12025
16:28:44.353 --> 16:28:51.640
看到通过了检查键我们看到执行维护已经通过了很好，执行维护的是链链VRF。

12026
16:28:51.640 --> 16:28:58.022
如果我们到chainlink, VRF，刷新，到历史记录，我们

12027
16:28:58.022 --> 16:29:04.610
确实看到一个交易通过了我们可以看到交易哈希值，花费的链接，等等。

12028
16:29:04.610 --> 16:29:11.559
现在如果我们回到我们的测试，我们确实看到抽奖单元测试的朋友满足随机请求赢家选择事件被触发。

12029
16:29:11.559 --> 16:29:17.057
这意味着我们刚刚经历了一个完整的过程，在我们的集成测试正常工

12030
16:29:17.057 --> 16:29:22.556
作的情况下，在一个真正的圣经上有一个完全真正的分散抽奖工作。

12031
16:29:22.593 --> 16:29:25.978
如果你能走到这一步，绝对非常非常祝贺你。

12032
16:29:25.978 --> 16:29:34.524
如果你和我一起通过整合测试，现在合同被重置为零，因为我们的钱包地址刚刚中了彩票，拿回了钱。

12033
16:29:34.524 --> 16:29:38.270
现在你可能会想，嘿，我看到了创建抽奖功能。

12034
16:29:38.270 --> 16:29:43.179
我看到了抽奖，但我没有看到链链接节点没有调用执行维护和

12035
16:29:43.179 --> 16:29:48.270
完成随机单词，我不管刷新多久都会来，我没有看到这些交易。

12036
16:29:48.270 --> 16:29:53.898
那些实际上会被认为是内部事务实现随机词，它实际上是通

12037
16:29:53.898 --> 16:29:59.526
过VRF协调器调用的VRF协调器契约调用完全随机性。

12038
16:29:59.593 --> 16:30:02.283
我们可以看内部交易。

12039
16:30:03.593 --> 16:30:09.765
transactions将是VRF协调器契约的事务，它调用我们的契约。

12040
16:30:09.765 --> 16:30:11.593
执行维护也是一样。

12041
16:30:11.593 --> 16:30:18.374
执行维护，链链接节点实际上通过注册表契约调用，然后注册表契约调用执行维护。

12042
16:30:18.374 --> 16:30:19.499
这就是我们在这里看到的。

12043
16:30:19.593 --> 16:30:23.050
如果我们查一下内部交易，就能找到他。

12044
16:30:23.050 --> 16:30:25.287
现在让我们来看看这个抽奖。

12045
16:30:25.287 --> 16:30:30.287
既然我们已经了解了事件和日志，我们现在就可以进入日志部分了。

12046
16:30:30.287 --> 16:30:35.229
我们可以看到我们的日志或事件在这里发出我们可以看到名称ra

12047
16:30:35.229 --> 16:30:40.343
ffle, enter，我们可以看到主题0它将识别整个事件。

12048
16:30:40.343 --> 16:30:47.945
然后我们在这里也看到这个数字它是索引主题，一个地址播放器然后没有与

12049
16:30:47.945 --> 16:30:55.779
此相关的数据因为我们只有索引参数再次显示为主题所以这绝对是现象级的。

12050
16:30:55.779 --> 16:31:01.143
哇，绝对庞大，我们可以重新运行一个单

12051
16:31:01.143 --> 16:31:06.507
元测试，在这里只运行我们的单元测试。

12052
16:31:06.594 --> 16:31:09.990
我们可以看到这些都在过去，这里看起来很好。

12053
16:31:09.990 --> 16:31:16.210
我们刚刚成功地在区块链上创建了一个可验证的随机

12054
16:31:16.210 --> 16:31:22.430
的，自主的，分散的，抽奖的，你现在应该很兴奋。

12055
16:31:22.430 --> 16:31:25.142
现在，我不打算展示如何将它推到GitHub。

12056
16:31:25.142 --> 16:31:29.975
然而，如果你想把它推到上面，再一次，发推给我，发推给chainlink

12057
16:31:29.975 --> 16:31:34.948
发推给Free Code Camp，请随意这么做，因为你已经做得很好了。

12058
16:31:34.948 --> 16:31:39.260
如果你想把这个推到GitHub，记住，我们会放一个。Git ignore。

12059
16:31:39.260 --> 16:31:45.780
在这里，我们添加了大量的东西，比如VS代码工件、现金部署、已知模块等。

12060
16:31:45.780 --> 16:31:51.664
类型链类型，所有这些，你可以在GitHub repo中找到。

12061
16:31:51.664 --> 16:31:58.529
Git忽略的例子，这是一个高级项目，我们在这里做了很多非常高级的事情。

12062
16:31:58.594 --> 16:32:05.868
这是课程的一部分，我认为在这一点上，你们已经掌握了大部分的基础知识。

12063
16:32:05.868 --> 16:32:07.731
现在我们要进入更多的前端。

12064
16:32:07.731 --> 16:32:12.402
我们将进入更具体的行业和更高级的主题，这些主题将会

12065
16:32:12.402 --> 16:32:17.260
让你更有动力，让你成为智能合约领域区块链的大师之一。

12066
16:32:17.260 --> 16:32:24.904
所以热烈的祝贺，再一次，一定要去庆祝，

12067
16:32:24.904 --> 16:32:31.743
一定要去散步，休息一下，让我们刚学

12068
16:32:31.743 --> 16:32:38.986
东西沉淀你的大脑，为下一个做准备。

12069
16:32:39.595 --> 16:32:44.426
好了，现在我们来复习一下这节课的TypeScript版本，我们会稍

12070
16:32:44.426 --> 16:32:49.404
微快一点，因为在这个TypeScript版本中我们学不到太多新东西。

12071
16:32:49.404 --> 16:32:53.939
如果你想继续学习，你可以在这里打开repo并使用TypeScript分支。

12072
16:32:53.939 --> 16:32:58.958
有一点需要注意的是当我们在测试中执行我们的承诺时，我们做的

12073
16:32:58.958 --> 16:33:04.152
是一个无效的权值承诺，因为我们不会用我们的承诺返回任何东西。

12074
16:33:04.152 --> 16:33:06.282
但是剩下的是完全一样的。

12075
16:33:06.282 --> 16:33:10.542
我们会有一个硬帽。config到TypeScript它会用到导入。

12076
16:33:10.595 --> 16:33:13.232
再一次，其他的东西都差不多。

12077
16:33:13.595 --> 16:33:16.595
像上次一样导出配置。

12078
16:33:17.595 --> 16:33:17.982
点JSON。

12079
16:33:20.595 --> 16:33:21.562
依赖关系也是如此。

12080
16:33:23.595 --> 16:33:26.201
遵循我们之前使用过的相同功能。

12081
16:33:26.595 --> 16:33:32.431
我们的部署脚本对在底部导出的变量使用类型部署函数。

12082
16:33:32.431 --> 16:33:39.995
我们还导入了硬帽运行时环境类型，在我们的测试中，我们从该类型中获取部署的命名帐户和网络。

12083
16:33:39.995 --> 16:33:46.625
当然，我们仍然在从链斜杠类型导入这些契约的类型，就像你在这里看到的，例如，

12084
16:33:46.625 --> 16:33:57.737
raffle将被签署到raffle VRF协调器V将被签署到类型VRF协调器V到MK如果我们想部署这些契约工厂，我们也可以。

12085
16:33:57.737 --> 16:34:00.063
这就是TypeScript的主要区别。

12086
16:34:00.063 --> 16:34:01.844
没有什么新鲜的东西。

12087
16:34:01.844 --> 16:34:05.602
但是，如果你想学习TypeScript，

12088
16:34:05.602 --> 16:34:11.805
你想用TypeScript编写代码，这里有个例子，好的，欢迎回来。

12089
16:34:11.805 --> 16:34:20.428
我希望你的休息绝对是美妙的，因为现在我们正在进入更高级的全栈斜线前端开发。

12090
16:34:20.428 --> 16:34:25.055
我们做了后端开发，我们创建了智能合约，我们创建了彩票。

12091
16:34:25.055 --> 16:34:32.971
在我们的最后一节中，我们将使用所有这些出色的代码来处理我们自己的去中心化彩票。

12092
16:34:32.971 --> 16:34:39.225
为了让日常生活中的普通人使用我们的彩票，我们需要建立一个前端。

12093
16:34:39.225 --> 16:34:45.198
之前，我们学过用原始HTML JavaScript构建前端，在我们的Funmi项目中，我们只用

12094
16:34:45.198 --> 16:34:51.299
纯HTML和JavaScript创建前端，只用HTML和JavaScript创建应用程序非常棒。

12095
16:34:51.299 --> 16:34:54.662
如果这是你想做的，你完全可以做到。

12096
16:34:54.662 --> 16:34:57.966
但是，使用这些普通协议进行操作有一些限制。

12097
16:34:57.966 --> 16:35:03.729
使用一个框架，就像我们在这一节中将要使用的那样会让我们的生活更容易，

12098
16:35:03.729 --> 16:35:09.153
我们将能够更快地开发，有更多的功能，在更短的时间内做更多的事情。

12099
16:35:09.153 --> 16:35:15.442
你们还记得，这个项目并不是一个真正的项目，如果你们还记得的话，它只是一堆按钮。

12100
16:35:15.442 --> 16:35:16.503
就是这样。

12101
16:35:16.596 --> 16:35:24.329
使用框架能让我们很容易地将更多的特性和样式添加到应用中。

12102
16:35:24.329 --> 16:35:32.477
同样，这整个部分的代码都位于我们的课程中，并且位于与课程相关的GitHub存储库中。

12103
16:35:32.477 --> 16:35:37.716
这里我要打个星号，我说过很多次了，这门课的前端部分不

12104
16:35:37.716 --> 16:35:43.158
是必修课，我们不会在前端部分学到任何关于后端的新内容。

12105
16:35:43.158 --> 16:35:50.047
如果你对网站建设不感兴趣，你想做的就是学习这门课的智能合约，你可以跳过这些部分。

12106
16:35:50.047 --> 16:35:54.759
但如果您确实想学习如何构建这些前端应用程序，如果您确实想让用

12107
16:35:54.759 --> 16:35:59.471
户和非开发人员能够与我们的智能合约进行交互，那么请继续观看。

12108
16:35:59.471 --> 16:36:07.018
我还要在这里加上一个星号，因为如果你以前没有使用过这些框架，学习曲线可能会显得有点陡峭。

12109
16:36:07.018 --> 16:36:13.430
我已经说过很多次了，这不会是一门比本视频多花几个小时的前端课程。

12110
16:36:13.430 --> 16:36:18.082
如果你从来没学过前端，这是我建议你跟随这些可

12111
16:36:18.082 --> 16:36:22.734
选的课程之一的部分，我们不会在这里播放它们。

12112
16:36:22.734 --> 16:36:26.482
但如果你跟随其中一个子课程，那肯定会非常有帮助。

12113
16:36:26.482 --> 16:36:33.212
我为这门课准备的一个视频就是这个视频，如何将智能合约连接到Metamask。

12114
16:36:33.212 --> 16:36:38.212
它展示了连接你的智能合约和建立这些这些前端的许多方法。

12115
16:36:38.212 --> 16:36:41.473
它确实从原始HTML和JavaScript版本开始。

12116
16:36:41.597 --> 16:36:45.065
你可以在这里得到更多HTML和JavaScript的练习。

12117
16:36:45.065 --> 16:36:48.993
然后它转移到index js醚和其他一些基于Jas的应用程序。

12118
16:36:48.993 --> 16:36:55.954
用几种不同的方法来做会让你对处理这些问题时应该考虑什么有更多的新见解。

12119
16:36:55.954 --> 16:36:59.946
如果你是前端开发新手，这段视频绝对值得一看。

12120
16:36:59.946 --> 16:37:02.547
此外，就像我说的，对于这一节，我们将使用一个框架。

12121
16:37:02.547 --> 16:37:06.069
特别地，我们将使用下一个Jas框架。

12122
16:37:06.069 --> 16:37:06.359
现在。

12123
16:37:06.359 --> 16:37:08.951
其次，Jas是一个基于反应的框架。

12124
16:37:08.951 --> 16:37:13.050
React是一个用于构建前端和全堆栈应用程序的框架。

12125
16:37:13.050 --> 16:37:15.678
接下来，Jas是React框架之上的一个框架。

12126
16:37:15.678 --> 16:37:18.148
如果你已经知道了react，

12127
16:37:18.148 --> 16:37:28.032
大部分内容就会很自然地理解我们在下一个Jas中使用react的原因是因为react是目前最流行的框架和语言之一。

12128
16:37:28.032 --> 16:37:35.977
所以我们在GitHub上有一篇小文章标题是，为什么你应该使用React js进行网页开发，这一点并不奇怪，我们会深入一点。

12129
16:37:35.977 --> 16:37:42.792
一些最大的应用程序，如Facebook和Instagram使用React js和一些其他的财富500强公司，

12130
16:37:42.792 --> 16:37:49.356
React js特别是在区块链领域是最受欢迎的协议，如uniswap, Avi也使用React Jas。

12131
16:37:49.356 --> 16:37:58.024
现在我们在React Jas之上使用next Jas的原因是，我认为next Jas使React的工作更容易。

12132
16:37:58.024 --> 16:38:01.836
我希望我们使用最简单，最强大的框架。

12133
16:38:01.836 --> 16:38:09.770
接下来，Jas也得到了大量的蒸汽有一些非常高级的，但在我看来比原始反应更容易使用的功能。

12134
16:38:09.770 --> 16:38:18.379
现在，就像我说的，如果你以前从来没有使用过React，如果你从来没有使用过next Jas，如果你想做一点复习，一定要看我的视频，六种将你的深度与钱包联系起来的方法。

12135
16:38:18.379 --> 16:38:23.598
如果你发现自己在这部分很挣扎，因为前端的东西真的没有意义。

12136
16:38:23.598 --> 16:38:28.542
我们也有一个下Jas速成课程在GitHub回购与本课程相关。

12137
16:38:28.598 --> 16:38:30.401
它大约有一个小时长，绝对是非凡的。

12138
16:38:30.598 --> 16:38:33.664
代码营也有一些Jas的速成课程。

12139
16:38:34.598 --> 16:38:39.767
在前面挣扎，去上下一个Jas课程，然后回到这部分，或者把

12140
16:38:39.767 --> 16:38:44.936
前面的部分都跳过，只做后面的部分，然后回来做前面的部分。

12141
16:38:44.936 --> 16:38:50.631
我们将向您展示与前端交互和工作的前沿方法，然后还将部署它们。

12142
16:38:50.631 --> 16:38:57.198
如果你做得对，到最后，你就会有一个可以展示的网站，你可以把它的链接发送给你的朋友。

12143
16:38:57.198 --> 16:39:03.859
现在我知道我们已经给你们展示了它是什么样子的但我要再给你们展示一遍这样我们就能看清楚我们在做什么。

12144
16:39:03.859 --> 16:39:10.198
所以我们将有这种去中心化的彩票，我们可以继续连接我们的钱包，如果还没有连接。

12145
16:39:10.198 --> 16:39:12.968
我们可以在不同的网络之间切换。

12146
16:39:12.968 --> 16:39:15.315
我们的应用会识别它并说，嘿，

12147
16:39:15.315 --> 16:39:23.030
我们这里唯一支持的链将是31337，这是localhost，或者4，这是ring feed。

12148
16:39:23.030 --> 16:39:32.002
我们会学习如何将这个验证添加到我们的应用中这样我们的应用只在我们想要的链上工作，然后我们可以继续和它交互。

12149
16:39:32.002 --> 16:39:40.150
通常，我们可以点击一个按钮，Metamask会弹出，我们可以继续，并确认我们会得到一个小的交易通知，说交易完成了。

12150
16:39:40.150 --> 16:39:42.632
我们会更新我们的前端。

12151
16:39:42.632 --> 16:39:47.995
然后在后端，我们将能够看到链条节点和Chinuch V REF做他们的工作。

12152
16:39:47.995 --> 16:39:55.964
一旦他们选出了一个优胜者，在刷新之后，我们就能看到后端节点被更新了，我们确实有一个之前的优胜者。

12153
16:39:55.964 --> 16:39:56.471
太棒了。

12154
16:39:56.599 --> 16:40:04.795
现在，不仅如此，我们将向你们展示如何构建这个，而且，我们将向你们展示如何在一个实际的网站上托管它。

12155
16:40:04.795 --> 16:40:07.499
所以你可以把它推到你自己的区块链。

12156
16:40:07.599 --> 16:40:11.954
此外，我们将把它托管在一个去中心化的环境中。

12157
16:40:11.954 --> 16:40:20.887
所以我们这里的这个网站它将被托管在一种技术上，它允许我们在去中心化的环境中托管网站，也可以托管后端。

12158
16:40:20.887 --> 16:40:24.978
甚至我们的前端也可以托管在去中心化的环境中。

12159
16:40:24.978 --> 16:40:33.937
我希望你们对此感到非常兴奋，因为我们将向你们展示许多顶级区块链项目使用的最前沿工具。

12160
16:40:33.937 --> 16:40:37.394
我们直接开始吧。

12161
16:40:37.599 --> 16:40:44.824
现在，我正在Hardhead智能合约抽签项目中，我们刚刚做的那个项目，我们做了这个硬帽智能合约抽签，这很棒。

12162
16:40:44.824 --> 16:40:52.277
我们现在要做的是创建一个新文件夹，尽管我们会时不时地回到这个文件夹做一些更新。

12163
16:40:52.277 --> 16:40:54.276
所以如果你想让它保持开放，你完全可以。

12164
16:40:54.276 --> 16:41:00.534
不过我还是选择CD下载目录这门课的主目录。

12165
16:41:00.600 --> 16:41:05.053
我们要创建一个新目录next Jas。

12166
16:41:05.600 --> 16:41:06.400
合同。

12167
16:41:11.600 --> 16:41:15.534
智能合约抽签FCC，继续，点击代码期。

12168
16:41:15.600 --> 16:41:19.729
就像我说的，如果你想保留那个文件夹和这个新文件夹，你完全可以。

12169
16:41:19.729 --> 16:41:25.300
但基本上，我们只是在Jas智能合约彩票文件夹中打开我们的VS代码。

12170
16:41:25.300 --> 16:41:31.666
对于这个前端的东西，特别是，如果你想绝对确保你使用的是和我相同的版本，你能做的是，你

12171
16:41:31.666 --> 16:41:38.032
可以用git克隆这个repo，然后复制yarn。lock和package。JSON，

12172
16:41:38.032 --> 16:41:44.400
然后运行yarn，这将确保你总是使用和我完全相同的包，你永远不会遇到任何奇怪的问题。

12173
16:41:44.400 --> 16:41:50.559
如果你真的遇到问题，首先要做的事情之一，特别是对于这些前端部分，就是返回，确保你有完全

12174
16:41:50.559 --> 16:41:56.863
相同的yarn。lock和package JSON，我在我的例子中做的，然后从那里开始。

12175
16:41:56.863 --> 16:41:58.968
现在我们在我们的前端项目中。

12176
16:41:58.968 --> 16:42:03.595
我们将创建一个网站，我们将创建一个应用程序的前端，就像我说的，

12177
16:42:03.595 --> 16:42:11.059
我们将使用下一个Jas，如果你想要跟随下一个Jas的文档，他们确实有一个很好的开始，并走过这个过程。

12178
16:42:11.059 --> 16:42:20.015
对于我们，我们会做yarn，创建下一个app，然后放一个小句点表示我们希望下一个app在这个目录中。

12179
16:42:20.015 --> 16:42:25.091
如果你不放句号，它会创建一个新文件夹，你会有两个文件夹。

12180
16:42:25.091 --> 16:42:26.009
好的,太棒了。

12181
16:42:26.009 --> 16:42:34.521
一旦我们这样做了，在我们的文件资源管理器部分，我们现在可以看到所有不同的文件样板。

12182
16:42:34.600 --> 16:42:36.790
现在，让我快速回顾一下这里发生了什么。

12183
16:42:36.790 --> 16:42:42.158
同样，我们在我推荐的两个视频中也讲过这个，复习两遍也无妨。

12184
16:42:42.158 --> 16:42:47.797
节点模块，当然是安装页面中的包会是我们网站上的不同页面。

12185
16:42:47.797 --> 16:42:49.911
让我给你们展示一下我的意思。

12186
16:42:49.911 --> 16:42:51.372
来管理整件事。

12187
16:42:51.372 --> 16:42:56.456
实际上，我们可以运行yarn，运行Dev，然后开始服务器，

12188
16:42:56.456 --> 16:43:01.366
等等，等等，你可以命令点击它或者复制粘贴到你的浏览器中。

12189
16:43:01.366 --> 16:43:05.533
你会看到在localhost 3000上，我们的页面在这里。

12190
16:43:05.601 --> 16:43:08.134
现在我们能做的是，索引。

12191
16:43:09.601 --> 16:43:12.854
默认页面，也就是这里的斜杠。

12192
16:43:12.854 --> 16:43:15.774
但我们能做的是创建新的页面。

12193
16:43:15.774 --> 16:43:19.482
所以我可以做新文件，你知道，狗点Jas。

12194
16:43:19.482 --> 16:43:25.041
然后复制粘贴index到dog到Jas，粘贴，删除div里面

12195
16:43:25.041 --> 16:43:30.601
的所有内容，你不需要遵循这里，点击，嗨，保存这个，回到这里。

12196
16:43:30.601 --> 16:43:34.378
我现在可以输入狗来得到这个。

12197
16:43:34.601 --> 16:43:39.431
所以页面就是这些到网站不同位置的不同路径。

12198
16:43:39.431 --> 16:43:43.124
index是默认值，就像主页一样。

12199
16:43:43.124 --> 16:43:44.846
我要删除达尔多。

12200
16:43:44.846 --> 16:43:48.889
在这些文件中会有一些东西叫做反应语法或JSX。

12201
16:43:48.889 --> 16:43:52.289
它们以Jas的形式出现，但基本上是文本中的反应。

12202
16:43:52.289 --> 16:43:59.288
Jas是基于React的，你会看到这些页面是JavaScript和HTML的奇怪组合。

12203
16:43:59.288 --> 16:44:05.726
我们在顶部看到一些import的东西，这让我们想起了JavaScript，你会在顶部看到一

12204
16:44:05.726 --> 16:44:12.164
些重要的东西然后在下面这里，你会看到，像div head main h1 P，你会看到所有

12205
16:44:12.164 --> 16:44:18.746
这些像HTML标签react index js让我们做JavaScript和HTML的组合。

12206
16:44:18.746 --> 16:44:21.698
这实际上让生活简单了很多。

12207
16:44:21.698 --> 16:44:24.952
你也会注意到我们在这里做了导入。

12208
16:44:24.952 --> 16:44:30.015
记住，我之前告诉过你，导入工作与我们的前端要求不。

12209
16:44:30.015 --> 16:44:37.570
这就是node不等于JavaScript之间的区别?这就是区别开始变得有点混乱的地方。

12210
16:44:37.602 --> 16:44:43.776
但我通常喜欢的思考方式是，我只说，没有JS，不好意思，我只说后端。

12211
16:44:43.776 --> 16:44:47.175
我可以J S有点不同于前端。

12212
16:44:47.175 --> 16:44:47.437
是的。

12213
16:44:47.437 --> 16:44:50.539
所以后端Jas和前端Jas有点不同。

12214
16:44:50.539 --> 16:44:52.338
这是我喜欢的思考方式。

12215
16:44:52.338 --> 16:44:52.548
应用程序。

12216
16:44:52.548 --> 16:44:59.518
js将是所有反应方式的入口点Jas的下一个工作是所有的东西都是基于我们所有文

12217
16:44:59.518 --> 16:45:06.489
件的组件，你会看到这个export default函数home或类似的东西。

12218
16:45:06.489 --> 16:45:09.891
Jas接下来要做的是，嘿，

12219
16:45:09.891 --> 16:45:18.268
这个包含大量JavaScript的HTML东西被认为是一个组件。

12220
16:45:18.268 --> 16:45:23.231
所有的页面都是通过这个下划线app包装的。

12221
16:45:23.231 --> 16:45:23.795
js页面。

12222
16:45:23.795 --> 16:45:27.118
这是一个页面，但它有点像主要的入口。

12223
16:45:27.118 --> 16:45:33.412
它们被卡在我们应用的组件部分Jas你可以在这张图上想一下。

12224
16:45:33.412 --> 16:45:36.852
GS是整个应用程序或整个前端。

12225
16:45:36.852 --> 16:45:43.470
在这个主页上，这个分量，我们把index。j放在这里，我们把component换成了index。j。

12226
16:45:43.470 --> 16:45:43.568
年代。

12227
16:45:43.568 --> 16:45:52.094
API是我们想做的如果我们想做一些HTTP GET HTTP POST请求，但我们不会做这些。

12228
16:45:52.094 --> 16:45:58.192
我们现在会忽略API public是一些公共图像比如favicon

12229
16:45:58.192 --> 16:46:04.291
或Versaille, SVG styles将是我们项目的CSS。

12230
16:46:04.291 --> 16:46:06.667
CSS是层叠样式表的缩写。

12231
16:46:06.667 --> 16:46:12.528
这基本上是一种样式化HTML的方法，我们会稍微改变一下样式化的方法，但这基本上就

12232
16:46:12.528 --> 16:46:18.389
是它们的作用ESLint我现在正在转储这个我们有。Git忽略，我们知道它的作用。

12233
16:46:18.389 --> 16:46:20.618
下一个。config。J。

12234
16:46:20.618 --> 16:46:20.749
年代。

12235
16:46:20.749 --> 16:46:22.841
这是一个配置文件或下一个。

12236
16:46:22.841 --> 16:46:28.022
Jas，当然，我们有package json，有readme，还有yarn。lock。

12237
16:46:28.022 --> 16:46:32.213
我们要做的大部分都在Pages文件夹中。

12238
16:46:32.213 --> 16:46:38.507
我们还会创建另外几个文件夹这将是我们的主要内容，因为我是我，我喜欢用pretty tier，我将自

12239
16:46:38.507 --> 16:46:44.801
动转储一个pretty RC，和一个pretty ignore在这里，这样我可以把我的代码格式化得

12240
16:46:44.801 --> 16:46:51.353
更好，你可以从我们上一个项目中获取你的pretty RC，你也可以获取你的pretty ignore。

12241
16:46:51.353 --> 16:46:58.359
或者你可以暂停我从与这节课相关的GitHub repo复制粘贴过来，然后我们会写yarn，

12242
16:46:58.359 --> 16:47:06.924
添加dash Dev，更漂亮，这样我们就能自动格式化所有的代码回到这里，我们可以保存，然后东西就自动格式化了。

12243
16:47:06.924 --> 16:47:09.364
现在，再一次，我们将使用多终端功能。

12244
16:47:09.364 --> 16:47:11.506
现在有一个在我的前端运行。

12245
16:47:11.603 --> 16:47:14.012
回到前端，点刷新。

12246
16:47:14.603 --> 16:47:14.840
运行。

12247
16:47:16.603 --> 16:47:16.857
的东西。

12248
16:47:16.857 --> 16:47:18.840
我们现在让yarn运行开发。

12249
16:47:19.603 --> 16:47:23.790
到我们的包，JSON，运行yarn，运行dev就会运行下一个dev。

12250
16:47:23.790 --> 16:47:31.484
实际上，让我取消它，只运行yarn dev yarn非常聪明，它不需要运行dev，它只运行next dev。

12251
16:47:31.484 --> 16:47:37.758
这个next命令会在安装next时内建，这是我们在yarn create next app时做的。

12252
16:47:37.758 --> 16:47:43.894
下一个Jas附带了这些已经为我们构建的脚本，我们希望构建我们的前端，使

12253
16:47:43.894 --> 16:47:50.030
人们能够以公平的方式与我们的彩票进行交互，并与正在运行的智能合约连接。

12254
16:47:50.030 --> 16:47:52.248
让我们为此创建一些简单的前端部件。

12255
16:47:52.248 --> 16:47:56.182
我们要做的第一件事是到Pages，然后到index。

12256
16:47:56.182 --> 16:47:56.287
js。

12257
16:47:56.287 --> 16:47:58.899
这里的东西都很可爱。

12258
16:47:58.899 --> 16:48:06.434
下一个谢谢你，Jas，但我们会把它全部删除除了那个头饰，我们会把它保留下来，我们只会更改名字。

12259
16:48:06.434 --> 16:48:11.911
下面这里，我们将把名称从Crate next

12260
16:48:11.911 --> 16:48:17.389
app改为智能合约彩票或raffle等等。

12261
16:48:17.389 --> 16:48:20.840
描述将是我们的智能合约，彩票。

12262
16:48:20.840 --> 16:48:26.654
然后在正下方，我们写上hello，蓝色，然后保存。

12263
16:48:26.654 --> 16:48:32.414
如果我们看前端，我们会看到智能合约抽签和顶部我要把这个移到

12264
16:48:32.414 --> 16:48:38.175
这里，智能合约抽签和顶部我们看到，你好，这是智能合约抽签。

12265
16:48:38.175 --> 16:48:45.450
你好，这里的描述，我们不会看到这将是一些我们将会找到的东西。

12266
16:48:45.604 --> 16:48:50.210
现在我们需要做的第一件事是我们需要创建那个连接按钮。

12267
16:48:50.210 --> 16:48:55.541
我们过去用原始JavaScript做过这个，但现在我们要用next js和react来做。

12268
16:48:55.541 --> 16:48:58.836
我们之前做的那个非常简约。

12269
16:48:58.836 --> 16:49:06.204
事实上，我们把它带回来，它检查是否有窗口Aetherium，然后去请求和连接，说，好，酷。

12270
16:49:06.204 --> 16:49:07.046
你连接。

12271
16:49:07.046 --> 16:49:11.636
没有做的是我们希望应用程序做的很多事情。

12272
16:49:11.636 --> 16:49:17.096
当我们改变网络时，我们的应用程序没有检测到当我们改变用户

12273
16:49:17.096 --> 16:49:22.556
或应用程序没有检测到它在连接到钱包的功能上是非常严格的。

12274
16:49:22.605 --> 16:49:28.842
我们要让我们的钱包连接按钮，非常强大，你可以连接到按钮，你可以切换网

12275
16:49:28.842 --> 16:49:35.080
络，你可以切换账户，你可以在我们的应用中做任何事我们的应用会有响应。

12276
16:49:35.080 --> 16:49:40.146
这是我们要做的第一件事之一，我们要创建一个头文件并连接

12277
16:49:40.146 --> 16:49:45.401
按钮导航栏1在这里一个小导航栏，说，你可以连接这个按钮。

12278
16:49:45.401 --> 16:49:47.346
这是我们要做的第一件事。

12279
16:49:47.346 --> 16:49:51.121
现在我们可以在这个index。js中建立整个连接按钮并插入到这里。

12280
16:49:51.121 --> 16:49:54.700
但是相反，我们要做的是我们要把它变成一个叫做分量的东西。

12281
16:49:54.700 --> 16:49:58.201
我们要创建一个名为components的新文件夹。

12282
16:49:58.201 --> 16:50:02.121
我们将在这里创建一个新文件header。

12283
16:50:02.121 --> 16:50:02.250
js。

12284
16:50:02.250 --> 16:50:06.564
你可能也会看到很多人做头部动作。

12285
16:50:06.564 --> 16:50:06.972
js x。

12286
16:50:06.972 --> 16:50:07.584
js和。

12287
16:50:07.584 --> 16:50:12.344
js x做了完全相同的事情，你可以用任何一个，

12288
16:50:12.344 --> 16:50:17.105
我要用。JSX，提醒我这是一个React文件。

12289
16:50:17.105 --> 16:50:18.533
这是我们创建的一个组件。

12290
16:50:18.605 --> 16:50:19.938
但是你可以做JS JSX。

12291
16:50:21.605 --> 16:50:25.088
关于组件的更多信息，我们有一个学习组件的链接。

12292
16:50:25.088 --> 16:50:27.811
它们基本上是独立的、可重用的代码位。

12293
16:50:27.811 --> 16:50:32.339
它们的作用与JavaScript函数相同，但独立工作并返回HTML。

12294
16:50:32.339 --> 16:50:38.338
基本上，我们会创建一小段HTML然后导出到索引中就像我们

12295
16:50:38.338 --> 16:50:44.552
过去做的那样，这有助于在整个项目中模块化和重用这个头组件。

12296
16:50:44.552 --> 16:50:47.536
现在，我们只会在一个区域使用我们的头部。

12297
16:50:47.536 --> 16:50:50.686
然而，无论如何，对项目进行模块化仍然很好。

12298
16:50:50.686 --> 16:50:54.655
首先，这就是所谓的基函数组分。

12299
16:50:54.655 --> 16:50:57.322
我们会创建一个函数home

12300
16:50:57.322 --> 16:51:04.504
write和JavaScript中的很像，只是它会返回一些HTML。

12301
16:51:04.504 --> 16:51:08.181
我们可以做一个小div。

12302
16:51:08.181 --> 16:51:11.444
我的VS代码在这里自动创建结束div。

12303
16:51:11.444 --> 16:51:14.021
在这里，我要说hi from header。

12304
16:51:14.021 --> 16:51:19.288
这将是一个真正的极简分量就像这是一个有效分量一样。

12305
16:51:19.288 --> 16:51:22.295
现在我们有了这个返回HTML的函数。

12306
16:51:22.295 --> 16:51:29.299
并且要给其他应用程序，使用这个组件的能力将做导出默认功能回家。

12307
16:51:29.299 --> 16:51:31.073
然后在指数中。

12308
16:51:31.073 --> 16:51:33.543
Js，我们可以用imports来导入它。

12309
16:51:33.543 --> 16:51:40.743
Home，不好意思，我不叫它Home，我们叫它header header，不好意思，export default

12310
16:51:40.743 --> 16:51:48.458
function header，然后import header从下目录components / header，像这样。

12311
16:51:48.458 --> 16:51:54.177
现在我们已经在index中导入了头文件如果我们回到还在运行的前端，

12312
16:51:54.177 --> 16:51:59.551
我们在这里看不到头文件?记住，所有东西都要通过我们的应用程序。

12313
16:51:59.606 --> 16:52:03.963
当我们在斜杠页面时，它会到我们的索引。

12314
16:52:03.963 --> 16:52:04.105
js。

12315
16:52:04.105 --> 16:52:10.481
Index js导入了头文件，但没有返回头文件。

12316
16:52:10.481 --> 16:52:12.065
这里，我们看到它返回了。

12317
16:52:12.065 --> 16:52:14.753
这是它返回的HTML。

12318
16:52:14.753 --> 16:52:17.133
如你所见，这里显然没有标题。

12319
16:52:17.133 --> 16:52:21.043
现在我们已经导入了头文件，我们需要在这里添加头文件。

12320
16:52:21.043 --> 16:52:24.812
我们做header，然后在这里添加结束标签。

12321
16:52:24.812 --> 16:52:29.762
如果你不添加任何东西，你知道，在两个标签之间，你可以只

12322
16:52:29.762 --> 16:52:34.896
做这一行，在末尾有一个反斜杠，说，嘿，这是一个开闭标签。

12323
16:52:34.896 --> 16:52:39.371
现在我们已经导入了它，你认为我们会在前端看到什么，现在我们已经将它添加到index

12324
16:52:39.371 --> 16:52:44.392
js中，你是对的，我们看到hi from header，因为我们在这里添加了header。

12325
16:52:44.392 --> 16:52:45.963
然后我们看到Hello。

12326
16:52:45.963 --> 16:52:48.352
这么高的头，你好，轰。

12327
16:52:48.352 --> 16:52:51.987
现在，我们做的任何事情，显然都在header中。

12328
16:52:51.987 --> 16:52:54.463
Js，将看到反映在我们的前端。

12329
16:52:54.463 --> 16:53:00.016
所以我们可以从头球做hi，等等，等等，你知道，只是一堆运球，我们会看到它在我们的前端。

12330
16:53:00.016 --> 16:53:05.321
这将是我们的部分我们将在这里创建我们的标题或导航栏或连接按钮的所有功能。

12331
16:53:05.321 --> 16:53:08.940
现在我要告诉你们一些事情，你们有些人会喜欢这个夏天，有些人会讨厌这个夏天。

12332
16:53:08.940 --> 16:53:09.807
我要展示给你看。

12333
16:53:09.807 --> 16:53:13.764
我先给你演示一下困难的方法，然后简单的方法。

12334
16:53:13.764 --> 16:53:20.348
为什么我要先给你看看艰难的方式?因为我想让你们熟悉幕后发生的事情以及这些组

12335
16:53:20.348 --> 16:53:26.933
件发生的事情因为在构建这些前端时理解这些是很有帮助的，好，这是发生的事情。

12336
16:53:26.933 --> 16:53:34.770
如果你不了解幕后发生了什么，你就会去尝试构建更高级的应用程序，你将不知道该做什么因为你只是学习了捷径。

12337
16:53:34.770 --> 16:53:43.251
我喜欢把它想象成微积分，就像我们先学习如何计算导数，然后学习快速求导的捷径。

12338
16:53:43.251 --> 16:53:48.114
所以不要跳过这部分，因为这将对你大有帮助。

12339
16:53:48.114 --> 16:53:53.575
好的，我们将会用比较难的方法来学习在HTML Funmi中设置所有东西。

12340
16:53:53.575 --> 16:53:59.236
我们可以用生醚来做任何事情你完全可以用生醚来做任何事情。

12341
16:53:59.236 --> 16:54:08.038
然而，有一些软件包特别为React，使生活开发前端实质性更好，在我们的完整区块链坚实的过程中，Jas。

12342
16:54:08.038 --> 16:54:12.591
我们有许多其他的包，你可以使用它们来堆叠开发和其他库。

12343
16:54:12.591 --> 16:54:17.531
如果你看了这六种将你的深度与钱包联系起来的方法，你就会真正理解其中的一些区别。

12344
16:54:17.531 --> 16:54:20.857
如果你还没看过那个视频，回去看看那个视频。

12345
16:54:20.857 --> 16:54:25.689
但是有很多库可以让我们的生活变得更容易。

12346
16:54:25.689 --> 16:54:27.213
我们在这里列出了其中的一些。

12347
16:54:27.213 --> 16:54:35.642
React Morales是我们今天要用的，他们有一些额外的插件，他们可能有这个星球上我最喜欢的东西，我很快会向你们展示如何做。

12348
16:54:35.642 --> 16:54:40.259
但这些也是开源的，Ross还提供了一些可选的功能，可以

12349
16:54:40.259 --> 16:54:45.048
连接到你自己的后端，为你的应用程序提供更多的特性和功能。

12350
16:54:45.048 --> 16:54:46.706
这也是我们这么做的另一个原因。

12351
16:54:46.706 --> 16:54:48.574
这个我们稍后再讲。

12352
16:54:48.574 --> 16:54:51.765
如果你想用纯醚，你完全可以。

12353
16:54:51.765 --> 16:54:56.758
我们使用的很多包都依赖于以太，但我们不会只使用以太。

12354
16:54:56.758 --> 16:54:58.508
我们进入反应莫拉莱斯的页面。

12355
16:54:58.608 --> 16:55:01.139
我们先从这里开始。

12356
16:55:02.608 --> 16:55:05.369
我要把这个复制到我们的项目中。

12357
16:55:05.608 --> 16:55:10.165
如果你去JSON包，我们实际上已经有了react和react DOM。

12358
16:55:10.165 --> 16:55:14.849
所以我们可以只做纱线，加入莫拉莱斯，然后反应口腔。

12359
16:55:14.849 --> 16:55:23.269
现在你会注意到我没有把这些作为开发依赖项，我没有把yarn添加到这里。

12360
16:55:23.269 --> 16:55:27.571
原因是，对于我们的产品构建，当我们在这里创建网站时，

12361
16:55:27.571 --> 16:55:37.170
你会需要Morales你会需要react Morales我们不需要更漂亮的网站，更漂亮的是我们作为开发者使用的工具。

12362
16:55:37.170 --> 16:55:41.239
所以在我们所有的项目中，到目前为止，我们只使用了开发依赖。

12363
16:55:41.239 --> 16:55:47.594
这是因为我们一直在为开发人员建立项目，我们的GitHub repos，他们没

12364
16:55:47.594 --> 16:55:54.117
有建立一个网站，他们只做后端的事情，对于我们的网站，我们实际上要建立一个前端。

12365
16:55:54.117 --> 16:55:58.886
所以我们需要把它放在依赖项部分，因为我们需要说，嘿，

12366
16:55:58.886 --> 16:56:03.473
这些是我们需要在前端捆绑在一起的，你可以忽略这些。

12367
16:56:03.473 --> 16:56:07.258
如果它只是一个让我们的生活更美好的工具，那它就属于开发依赖。

12368
16:56:07.258 --> 16:56:09.854
加上莫拉莱斯，反应莫拉莱斯。

12369
16:56:09.854 --> 16:56:15.959
我们要为头文件做的很多语法实际上和我们目前看到的非常相似。

12370
16:56:15.959 --> 16:56:16.740
我们来做这个。

12371
16:56:16.740 --> 16:56:22.624
然后，我们要把这个名字改成manual header, manual header更新导入为manual

12372
16:56:22.624 --> 16:56:29.415
header，你可以点击yes to man所有的header，我们要复制manual header，确保它在索引中。

12373
16:56:29.415 --> 16:56:33.209
我们要把页眉改成手动页眉，这里也要改成手动页眉。

12374
16:56:33.209 --> 16:56:40.270
我们这样做的原因是，就像我说的，我们将在创建这个难的头文件之后创建一个更简单的头文件。

12375
16:56:40.270 --> 16:56:44.386
我们会创建那个连接按钮，这是我们在HTML Funmi中做的。

12376
16:56:44.386 --> 16:56:51.542
通过调用每个请求账户，我们可以用Morales做这个叫Enable Web 3。

12377
16:56:51.542 --> 16:56:57.418
在顶部，我们要导入，使用米拉拉。

12378
16:56:57.609 --> 16:56:59.157
react ralis报道。

12379
16:57:03.609 --> 16:57:07.892
或者到他们的GitHub，你也会学到如何设置所有这些，并了解更多关于文档的知识。

12380
16:57:07.892 --> 16:57:14.084
我们会从react Morales导入use Morales，在函数内部，但在return

12381
16:57:14.084 --> 16:57:20.415
之外，我们会说const, Enable Web three = use mirallas。

12382
16:57:20.415 --> 16:57:25.333
现在使用Morales就是所谓的钩子React钩子。

12383
16:57:25.333 --> 16:57:28.809
它是在应用程序中跟踪状态的一种方法。

12384
16:57:28.809 --> 16:57:37.547
现在，为了使用mirallas，我们的整个应用程序需要围绕所谓的Morales提供程序进行包装，它将是我们的上下文提供程序。

12385
16:57:37.609 --> 16:57:38.962
我马上会解释这是什么意思。

12386
16:57:39.609 --> 16:57:43.948
我们需要做的是将Morales提供者添加到我们的应用中。

12387
16:57:43.948 --> 16:57:44.173
js。

12388
16:57:44.173 --> 16:57:51.547
在这里，我们要从react oralis导入oralis provider。

12389
16:57:51.547 --> 16:57:58.990
我们将把整个应用围绕这个莫拉莱斯提供我们将在这里做一些小括号。

12390
16:57:58.990 --> 16:58:03.063
New Line，我们会像这样粘贴morass

12391
16:58:03.063 --> 16:58:09.085
provider，它会给我们结束标签，复制，像这样粘贴，然后保存。

12392
16:58:09.085 --> 16:58:16.766
然后在这里，我们会在表格中写上盟军Mount = false。

12393
16:58:16.766 --> 16:58:24.902
这个初始化挂载部分是连接到服务器的可选性，为我们的网站添加更多的功能。

12394
16:58:24.902 --> 16:58:30.578
我们不希望这个应用程序与服务器挂钩，我们希望一切都是开源的，我们不需要任何额外的功能。

12395
16:58:30.610 --> 16:58:33.782
我们会在Mount上做初始化= false。

12396
16:58:33.782 --> 16:58:40.429
现在整个东西都被包装在这个Morales提供程序中了，我们去到前端我们应该能够刷新所有看起来几乎一样的东西。

12397
16:58:40.429 --> 16:58:42.832
我们可以开始用这些钩子了。

12398
16:58:42.832 --> 16:58:50.358
这个使用叫做钩子钩子乍一看可能会让人有点困惑，但它

12399
16:58:50.358 --> 16:58:57.884
们非常强大它们是我们建立react项目的实际方式。

12400
16:58:57.884 --> 16:59:06.444
如果你熟悉类组件,我们不会使用类组件因为钩子是更好的钩子函数允许组件访问状态和其它人的反应特性状态可能是

12401
16:59:06.444 --> 16:59:15.004
其中一个最大的和最受欢迎的人,我们希望我们的应用程序是不同的,如果我们连接到Metamask,而如果我们

12402
16:59:15.004 --> 16:59:23.564
没有,对,如果我们回去,如果我们回到我们的示例网站这里,是的,如果我们不联系,我们想说,请连接到钱包上。

12403
16:59:23.611 --> 16:59:26.026
当我们被连接时，我们想要向前走并被连接。

12404
16:59:26.026 --> 16:59:31.796
假设我有一些变量，比如，这里没有钩子，我有，let connected = false，或

12405
16:59:31.796 --> 16:59:37.695
者启用Web 3，或者启用Web 3，假设我有，led connected = false。

12406
16:59:37.695 --> 16:59:44.122
然后我有一个连接我们的按钮改变连接为真，改变

12407
16:59:44.122 --> 16:59:50.549
连接为真很好但它不会重新呈现我们的应用，当我

12408
16:59:50.549 --> 16:59:57.561
断开连接时，我们的应用会根据我们是否连接而改变。

12409
16:59:57.611 --> 17:00:01.544
这就是我们想要的，我们想要我们的前端重新渲染。

12410
17:00:01.611 --> 17:00:08.048
连接时，如果我在组件中使用这样的变量，前端不会重新渲染。

12411
17:00:08.048 --> 17:00:14.059
更糟糕的是，如果我在外面使用它，我们的组件甚至不知道这个变化的任何事情。

12412
17:00:14.059 --> 17:00:19.857
钩子是我们处理状态的一种方式特别是当有东西改变时自动重新渲染启用

12413
17:00:19.857 --> 17:00:25.837
Web 3是我们从这个函数中得到的使用Morales钩子来做这个。

12414
17:00:25.837 --> 17:00:30.842
对于很多组件，我们不会像普通JavaScript那样，只说，让web

12415
17:00:30.842 --> 17:00:36.143
three enabled = true，我们会做很多这个，这些钩子。

12416
17:00:36.143 --> 17:00:44.594
在大多数情况下，我们通常希望我们的网站改变基于如果一些变量改变了启用web 3是我们从这个钩子中获得的功能它

12417
17:00:44.594 --> 17:00:53.046
说，好，继续连接启用web 3基本上相当于说try await Aetherium。request，像这样。

12418
17:00:53.046 --> 17:00:56.857
现在启用web3，我们这里使用它的方式只适用于Metamask。

12419
17:00:56.857 --> 17:01:05.494
我们会展示如何建立这个很酷的小模块在这里我们可以选择连接应用的不同方式。

12420
17:01:05.612 --> 17:01:12.196
我们已经启用了web3，让我们创建一个按钮，这和我们在返回的HTML Funmi中所做的一样，

12421
17:01:12.196 --> 17:01:18.780
但这里，我们不添加hi friend header，我们要添加一个新组件，或者我们要添加一个新

12422
17:01:18.780 --> 17:01:25.366
标签，我们要添加button标签，对我来说它会自动关闭，我把它命名为connect，然后保存。

12423
17:01:25.366 --> 17:01:26.849
现在我们看到一个小按钮，上面写着连接。

12424
17:01:26.849 --> 17:01:35.715
显然，它什么都不做，我们会给它一些功能，我们会说on click now因为这是JSX组件。

12425
17:01:35.715 --> 17:01:41.902
这不是原始HTML，在原始HTML中，我们不能随便把JavaScript放哪。

12426
17:01:41.902 --> 17:01:46.678
但在JSX文件中，我们可以随意放置JavaScript。

12427
17:01:46.678 --> 17:01:53.644
在这一段HTML中，我们可以通过添加这些小括号把JavaScript写在这里。

12428
17:01:53.644 --> 17:01:56.349
所以在我们的工作中加入这些小括号可以回来。

12429
17:01:56.349 --> 17:01:57.922
但在这里，我们可以添加JavaScript。

12430
17:01:57.922 --> 17:02:02.921
我们要做的是我们要有On Click Call Enable web3，

12431
17:02:02.921 --> 17:02:09.447
我们会调用一个async函数，我们会在这里使用箭头语法，一键式，我们会调用这个async函数，

12432
17:02:09.447 --> 17:02:16.808
它就是await, Enable web3, await Enable web3，我们在这里加一个小括号。

12433
17:02:16.808 --> 17:02:23.547
本质上，通过这个，我们已经完成了在这个大的连接函数中所做的所有事情。

12434
17:02:23.612 --> 17:02:29.992
现在回到前端，稍微刷新一下，我们现在可以看到，我已经连接上了，我要断开连接。

12435
17:02:29.992 --> 17:02:38.870
我还连接着之前做的一些应用，我们可以点击连接，现在我们看到metamath确实弹出了，我们点击下一步连接，然后嘣。

12436
17:02:38.870 --> 17:02:39.805
这就是我们要做的。

12437
17:02:39.805 --> 17:02:42.033
现在，如果我们看我们的Metamask，它说连接。

12438
17:02:42.033 --> 17:02:42.348
太好了。

12439
17:02:42.348 --> 17:02:42.927
好的,很酷。

12440
17:02:42.927 --> 17:02:50.631
现在我们有了连接的方法，让我们添加一些功能让我们的应用足够智能，在连接时有连接按钮。

12441
17:02:50.631 --> 17:02:53.163
如果我们没有联系，就没有那个按钮。

12442
17:02:53.163 --> 17:02:58.111
我们现在要做的是使用Morales附带的另一个钩子叫做iswebthree,

12443
17:02:58.111 --> 17:03:03.580
enabled，这是我们钩子的一个可变部分，它跟踪我们的Metamask是否连接。

12444
17:03:03.580 --> 17:03:10.888
但我们可以做得更好，我们可以检查是否有账户因为也许web 3是连接的。

12445
17:03:10.888 --> 17:03:13.679
但是但是他们没有把它和账户联系起来。

12446
17:03:13.679 --> 17:03:16.924
我们继续，导入count。

12447
17:03:16.924 --> 17:03:19.957
莫拉莱斯会去查是否有账户。

12448
17:03:19.957 --> 17:03:27.693
我们要做的是在div标签内部，我们会用一点JavaScript，我们会再次使用三元运算符，我们会在这里放一个带问号的计数。

12449
17:03:27.693 --> 17:03:33.763
用之前学过的语法，我们说账户，如果账户存在，就这么做。

12450
17:03:33.763 --> 17:03:35.313
如果没有账户，就这么做。

12451
17:03:35.313 --> 17:03:39.350
如果没有帐户，我们要添加这个连接按钮。

12452
17:03:39.350 --> 17:03:41.799
我们继续，把它插在这里。

12453
17:03:41.799 --> 17:03:44.776
如果有一个账户，我们就会显示这个账户。

12454
17:03:44.776 --> 17:03:50.528
我们在这里写div反斜杠，我们写connected，像这样。

12455
17:03:50.613 --> 17:03:53.129
现在如果我们回到我们的前端，我们看到连接。

12456
17:03:53.613 --> 17:03:55.581
稍作调整，它就会消失。

12457
17:03:57.613 --> 17:03:59.596
现在我们联系在一起了，这很好。

12458
17:04:00.613 --> 17:04:01.050
更聪明。

12459
17:04:01.050 --> 17:04:03.300
我们要在这里显示我们的账户。

12460
17:04:04.613 --> 17:04:11.279
说连接，我们会说连接到，我会在我们的JavaScript中放入一些JavaScript。

12461
17:04:11.279 --> 17:04:16.422
但因为这是HTML的东西，我们要用括号来表示JavaScript。

12462
17:04:16.422 --> 17:04:21.145
我们会把JavaScript放在JavaScript里面，我们会说connected to，我们会说account。

12463
17:04:21.145 --> 17:04:26.725
现在回到我们的前端，我们看到连接到，等等，等等，你会注意到，如果你点击刷新，你需

12464
17:04:26.725 --> 17:04:32.306
要重新连接，我们马上会讲到这个，很多人会做一个count。slice (0,6)

12465
17:04:32.306 --> 17:04:38.273
然后在括号外面，他们会写。那个。另一组括号帐户，那片，

12466
17:04:38.273 --> 17:04:44.682
count。length - 4，像这样关闭，我们有了我们

12467
17:04:44.682 --> 17:04:50.872
们的帐户，当我们点击连接时，它会说连接到某某，某某，你好。

12468
17:04:50.872 --> 17:04:59.047
因为这些挂钩，当我切换账户，连接到这些新账户时，它甚至会自动重新呈现切换账户。

12469
17:04:59.047 --> 17:05:03.998
这些钩子对于重新渲染我们的网站非常有用每当一些值发生变化时。

12470
17:05:03.998 --> 17:05:09.980
例如，如果我说，让count number = 7，我们有一个按钮，那个

12471
17:05:09.980 --> 17:05:16.130
更新的账号，我们的前端不会重新播放，除非我们特别告诉它重新播放，这很烦人。

12472
17:05:16.130 --> 17:05:18.375
钩子在这方面帮助很大。

12473
17:05:18.375 --> 17:05:24.457
它允许我们跟踪渲染之间的状态。

12474
17:05:24.614 --> 17:05:33.489
现在它没有做的是，如果我点击刷新，我必须重新点击连接按钮，即使我的Metamask说，嘿，我们连接了。

12475
17:05:33.489 --> 17:05:35.786
但如果我刷新，我必须重新点击连接按钮。

12476
17:05:35.786 --> 17:05:36.544
为什么会这样。

12477
17:05:36.614 --> 17:05:42.239
或者当我刷新时，我们的网站不知道我们已经点击了启用Web 3，因为当我

12478
17:05:42.239 --> 17:05:47.864
刷新时，我们会回到空白状态，然后我必须点击连接，这非常讨厌，非常烦人。

12479
17:05:47.864 --> 17:05:56.114
我们想添加一些功能，在我们渲染的瞬间自动地，我们继续检查，看我们是否已经连接了。

12480
17:05:56.114 --> 17:05:58.114
如果我们连接起来展示这个。

12481
17:05:58.114 --> 17:06:02.460
要做到这一点，我们可以使用另一个钩子use effect。

12482
17:06:02.460 --> 17:06:05.720
这是一个核心反应钩子。

12483
17:06:05.720 --> 17:06:12.215
我们会像这样做import use effect from react。

12484
17:06:12.215 --> 17:06:14.881
这是一个核心钩子直接从react。

12485
17:06:14.881 --> 17:06:18.360
它和使用状态是最受欢迎的。

12486
17:06:18.360 --> 17:06:24.441
我们在这门课相关的GitHub repo中留下了一些关于effect钩子的

12487
17:06:24.441 --> 17:06:30.522
链接，我会给你们总结这个use effect的作用，我们有这个函数叫use

12488
17:06:30.522 --> 17:06:36.932
effect，它有两个形参，第一个形参是一个函数，第二个形参是一个依赖数组。

12489
17:06:36.932 --> 17:06:44.053
这个使用效果的作用是它会不断检查依赖数组中的值。

12490
17:06:44.053 --> 17:06:51.199
如果依赖率中有任何变化，它会调用某个函数，然后在前端重新渲染。

12491
17:06:51.199 --> 17:06:58.680
举个例子，使用Morales附带了一个函数叫做iswebthree enabled或者这个变量叫做iswhatthree enabled。

12492
17:06:58.680 --> 17:07:05.760
如果我们把它添加到依赖数组中，我们在使用效果中可以做的是做console。log, hi。

12493
17:07:05.760 --> 17:07:11.137
然后我们可以让console。log iswebthree

12494
17:07:11.137 --> 17:07:16.886
enabled，这个使用效果会做的是它会一直运行，一直运行。

12495
17:07:16.886 --> 17:07:25.815
它会监听webthree是否启用了更改，对吧?只要我们运行启用Web 3 Web 3启用就会变为true。

12496
17:07:25.815 --> 17:07:31.860
现在如果我们到前端，我们做一点刷新，我们看到高假，高假。

12497
17:07:31.860 --> 17:07:39.680
为什么我们会看到两次web 3只启用了一次?这是因为use effect的工

12498
17:07:39.680 --> 17:07:47.706
作方式，它会自动运行在load或right或第一次运行时，然后它会运行检查值。

12499
17:07:47.706 --> 17:07:53.056
我们基本上看到这个运行了两次，它在我们加载它的第一次运行，然后它会检查值并再次运行。

12500
17:07:53.056 --> 17:07:55.124
所以我们看到了两次，尽管实际上只有一次。

12501
17:07:55.124 --> 17:07:59.091
回到这里，抱歉，我再快速重新加载一次。

12502
17:07:59.091 --> 17:08:04.238
我们点击连接，我们现在看到Hi为真，因为它看到的是3enabled的改变为

12503
17:08:04.238 --> 17:08:09.386
真因为enabled的webthree make是enabled的返回真。

12504
17:08:09.386 --> 17:08:11.287
然后它又运行了一遍。

12505
17:08:11.287 --> 17:08:13.252
这就是它的工作原理。

12506
17:08:13.252 --> 17:08:16.405
有几种不同的方法来考虑这个问题。

12507
17:08:16.405 --> 17:08:18.829
实际上，我们甚至不需要给它一个数组。

12508
17:08:18.829 --> 17:08:22.830
如果我们不给它一个数组会发生什么?让我们刷新一下。

12509
17:08:22.830 --> 17:08:26.412
点击Connect，我们会看到它仍然运行了几次。

12510
17:08:26.412 --> 17:08:32.909
如果我们不给它数组，没有依赖数组，它会在任何重渲染的时候运行。

12511
17:08:32.909 --> 17:08:34.882
你得小心点。

12512
17:08:34.882 --> 17:08:41.173
因为你可以得到循环渲染，如果你有一些使用效果改变了一些值。

12513
17:08:41.173 --> 17:08:47.282
你还有另一个使用效果当那个值改变时重新呈现而它们都将不断地来回改变。

12514
17:08:47.282 --> 17:08:48.916
没有这样的依赖数组。

12515
17:08:48.916 --> 17:08:53.583
它会在任何东西重新呈现的时候运行我们会给它一个空白的依赖数组。

12516
17:08:53.583 --> 17:08:56.166
它只在加载时运行一次，只运行一次。

12517
17:08:56.166 --> 17:09:00.029
这里有一个空白依赖项，我们重新加载。

12518
17:09:00.029 --> 17:09:02.171
对吧?我们看到它运行了两次。

12519
17:09:02.171 --> 17:09:06.393
那实际上是因为我们在后台重新渲染一次。

12520
17:09:06.393 --> 17:09:09.960
它实际上只是运行一次但在后台还有其他事情在进行。

12521
17:09:09.960 --> 17:09:11.201
看起来它运行了两次。

12522
17:09:11.201 --> 17:09:19.879
如果我们只添加启用了的webthree，稍微刷新一下，它会做完全一样的事情，它会运行和空白时一样的时间。

12523
17:09:19.879 --> 17:09:21.774
但当我们连接时，它会在这里加上。

12524
17:09:21.774 --> 17:09:28.068
如果这是一个空白数组，刷新时，我们会看到踢出两次，应该是1。

12525
17:09:28.068 --> 17:09:30.424
但就像我说的，有些事情正在发生。

12526
17:09:30.424 --> 17:09:31.462
如果我们点击连接。

12527
17:09:31.462 --> 17:09:38.289
现在，我们看不到任何东西，因为空白依赖数组说，嘿，我只会在加载时运行一次。

12528
17:09:38.289 --> 17:09:44.807
如果数组中有我们的东西，比如是否启用web 3，它会在数组中任何东西改变时运行。

12529
17:09:44.807 --> 17:09:51.569
再次，我们会刷新连接，我们看到它再次运行，在点击连接后会刷新。

12530
17:09:51.569 --> 17:09:54.426
嗨，嗨，连接，再跑一遍。

12531
17:09:54.426 --> 17:09:56.929
这是一个小抄。

12532
17:09:56.929 --> 17:10:02.315
如果我们不给它依赖数组，它会随时运行项目re渲染中的任何东西，如果我们

12533
17:10:02.315 --> 17:10:07.855
给它一个空白的依赖数组，它只会运行一次，或者像我们看到的，它会运行两次。

12534
17:10:07.855 --> 17:10:10.458
但那是因为我们在背景中渲染了其他东西。

12535
17:10:10.458 --> 17:10:15.600
如果我们在这个数组中给它依赖项，它就会在数组中任何东西改变的时候运行。

12536
17:10:15.600 --> 17:10:22.947
这真的很有帮助，因为通常，我们想要前端重新渲染，这个use effect

12537
17:10:22.947 --> 17:10:30.499
会说，哦，酷，一些值改变了，我要运行这个函数，然后我要重新渲染，你的前端。

12538
17:10:30.617 --> 17:10:36.038
现在我们要用这个use effect来确保刷新时，它记得我们是连接的。

12539
17:10:36.038 --> 17:10:40.047
我们在这里怎么做呢，我们将使用这个web3启用的东西。

12540
17:10:40.047 --> 17:10:47.467
我们要做的第一件事是我们要说if is what three enabled，然后我们会返回。

12541
17:10:47.467 --> 17:10:51.650
因为如果我们已经连接到web 3，那么我们不需要做任何事情。

12542
17:10:51.650 --> 17:11:00.522
现在，如果我们没有连接到web 3，我们没有账号，我们会调用启用web 3，自动启用web 3。

12543
17:11:00.522 --> 17:11:07.392
现在如果我返回，你会看到这段代码，我总是自动调用Enable Web 3。

12544
17:11:07.392 --> 17:11:08.988
但这真的很烦人。

12545
17:11:08.988 --> 17:11:13.260
因为如果我断开连接，让我们断开所有东西。

12546
17:11:13.260 --> 17:11:18.460
刷新，它会总是调用启用Web 3，每次刷新，

12547
17:11:18.460 --> 17:11:23.424
它会自动调用启用，甚至不需要点击连接按钮。

12548
17:11:23.424 --> 17:11:26.568
所以这对我们想要看看是否有连接是没有好处的。

12549
17:11:26.618 --> 17:11:34.026
我们这样做的方式，像我说的，我们想使用本地存储，应用程序，或者这些小东西到

12550
17:11:34.026 --> 17:11:41.635
应用程序，我们想让我们的应用程序记住有人点击了这个连接按钮，他们连接到我们。

12551
17:11:41.635 --> 17:11:47.288
我们要做的是在下面的onClick函数中，我们不仅会调用await

12552
17:11:47.288 --> 17:11:54.142
Enable web3，我们还会在这里存储一点记忆说，嘿，我们最近确实连接了。

12553
17:11:54.142 --> 17:12:00.616
在这下面，我们会运行window。local storage。

12554
17:12:00.616 --> 17:12:06.674
set item, connected，逗号inject。

12555
17:12:06.674 --> 17:12:11.586
我现在要把这个注释掉，因为我的朋友会一直像这样出现。

12556
17:12:11.586 --> 17:12:19.089
这做的是，在我们的窗口中，因为如果你回到窗口，到控制台，一个类型窗

12557
17:12:19.089 --> 17:12:26.821
口，你会看到这个巨大的窗口，我们之前展示过，这里总是有这个窗口对象。

12558
17:12:26.821 --> 17:12:32.590
我们要做window。local storage，这与。如果我们到

12559
17:12:32.590 --> 17:12:38.359
这个应用程序部分，这个本地存储部分，那个连接到注入的set项有关。

12560
17:12:38.359 --> 17:12:45.117
我们会在这里设置一个新的键值，我们这样做是因为在未来，也许你想把它连接到Wallet

12561
17:12:45.117 --> 17:12:53.325
connect或连接到Coinbase Wallet之类的，但我们会说注入，意思是我们连接到元掩码。

12562
17:12:53.325 --> 17:12:57.419
在next的某些版本中，Jas很难知道这个窗口变量。

12563
17:12:57.419 --> 17:13:06.369
我们可以这样做如果type of window不等于等于undefined，我们会这样做。

12564
17:13:06.369 --> 17:13:10.946
我们只是确保窗口不等于未定义存在一个窗口。

12565
17:13:10.946 --> 17:13:19.532
现在如果我回到前端，点击连接，然后连接到这里，我们会看到在应用程序中，本地存储，

12566
17:13:19.532 --> 17:13:28.333
我们会看到我们在这里添加了这个连接注入位，我们在浏览器中存储了我们确实连接到这个。

12567
17:13:28.333 --> 17:13:36.987
现在我们已经将它添加到浏览器中，我们可以回滚到这里的使用效果，说，好的，如果它们已经连接，很好，我们就完成了。

12568
17:13:36.987 --> 17:13:40.241
但在我们做任何事之前，让我们看看他们是否有这个。

12569
17:13:40.241 --> 17:13:44.038
如果它们已经连接了，让我们运行连接位。

12570
17:13:44.038 --> 17:13:46.633
我们会说if type of

12571
17:13:46.633 --> 17:13:53.306
window不等于undefined，因为我们要检查window对象。

12572
17:13:53.306 --> 17:13:59.903
同样，我们会说if window。local storage。get item connected,

12573
17:13:59.903 --> 17:14:06.369
connected，如果那个connected key存在，我们会运行Enable Web 3。

12574
17:14:06.369 --> 17:14:13.832
这里有一些功能，刷新时，它会自动运行enable of three。

12575
17:14:13.832 --> 17:14:19.415
现在如果我刷新前端，我们就不用再按连接键了，因为它会

12576
17:14:19.415 --> 17:14:24.999
说，我看到本地，每当刷新时，我们都存储了这个连接键。

12577
17:14:24.999 --> 17:14:28.573
现在，它首先检查这个，它看到它，然后运行启用的web 3。

12578
17:14:28.620 --> 17:14:34.170
现在在另一边，如果我们在这里，现在我们断开连接，然后刷新。

12579
17:14:34.170 --> 17:14:36.345
这个会显示出来，这真的很烦人。

12580
17:14:36.345 --> 17:14:39.471
每次刷新，它都会一直显示，这是我们不想看到的。

12581
17:14:39.471 --> 17:14:45.812
我们希望当我们断开连接时，我们告诉它，我们已经在这里断开了。

12582
17:14:45.812 --> 17:14:52.353
回到我们的应用中，我们能添加另一个使用效果来检查我们是否断开连接。

12583
17:14:52.353 --> 17:14:54.527
让我们创建另一个使用效果。

12584
17:14:54.527 --> 17:15:01.587
这是很昂贵的只要我们连接起来，我们说使用效果，在这里做一个小箭头括号。

12585
17:15:01.587 --> 17:15:04.455
我们随时都可以这么做。

12586
17:15:04.620 --> 17:15:06.687
我的天啊，每次保存，它都会一直跳出来。

12587
17:15:06.687 --> 17:15:08.777
我现在要把它注释掉。

12588
17:15:08.777 --> 17:15:14.794
在这里，我们想说，不管怎样，如果任何账户发生了变化，我们想运行一个重新播放。

12589
17:15:14.794 --> 17:15:17.942
莫拉莱斯也为我们提供了一些功能。

12590
17:15:17.942 --> 17:15:23.716
从user morass，我们会导入更多Alice，然后在下面这里的使用效果。

12591
17:15:23.716 --> 17:15:28.048
在这个小函数中，我们会写mirallas。

12592
17:15:28.048 --> 17:15:34.652
换了换了，我们要做点什么。

12593
17:15:34.652 --> 17:15:38.520
帐户更改时，取一个函数作为输入参数。

12594
17:15:38.520 --> 17:15:44.447
我们写入console。log，帐户，更改为帐户。

12595
17:15:44.447 --> 17:15:49.792
我们能做的就是检查这个账户是否存在。

12596
17:15:49.792 --> 17:15:57.588
我们可以说，如果account = = no，那么如果account为null，我们可以假设它们已经断开。

12597
17:15:57.588 --> 17:16:02.551
我们可以说window。local storage。remove item,

12598
17:16:02.551 --> 17:16:08.037
connected，我们还会运行一个deactivate web three函数。

12599
17:16:08.037 --> 17:16:12.203
从Ross，去激活，web3也会运行，

12600
17:16:12.203 --> 17:16:19.001
去激活web3，这将把web3设为enabled为false。

12601
17:16:19.001 --> 17:16:25.530
我们会断开web 3，然后我们会说console。log。

12602
17:16:25.621 --> 17:16:28.161
没有发现计数。

12603
17:16:28.161 --> 17:16:29.242
我们来试一下。

12604
17:16:29.242 --> 17:16:29.438
现在。

12605
17:16:29.438 --> 17:16:32.741
让我们回到我们的前端，我们在这里做一点刷新。

12606
17:16:32.741 --> 17:16:34.692
现在它说我们是相连的。

12607
17:16:34.692 --> 17:16:39.859
虽然在我的元掩码里，我们并没有连接，对吧?为了从头开始，你可以断开连接。

12608
17:16:39.859 --> 17:16:43.489
但是我的浏览器说，嘿，我们连上了，对吧?现在我们连接起来。

12609
17:16:43.489 --> 17:16:51.310
我们实际上是连接的，下一个连接，它会重写连接，用注入，让这个被注入。

12610
17:16:51.310 --> 17:16:57.871
然后我们删除，是的，注入，我们会刷新，比如，连接，现在它说注入。

12611
17:16:57.871 --> 17:16:58.386
好的,很酷。

12612
17:16:58.386 --> 17:17:00.496
现在我们连在一起了。

12613
17:17:00.496 --> 17:17:06.906
如果在这里，如果我只是切换帐户，让我们到帐户3，我将连接。

12614
17:17:06.906 --> 17:17:11.503
如果我们快速回到控制台，我们会说账户更改为等等等

12615
17:17:11.503 --> 17:17:16.293
等，我也可以更改回来，我们会把账户更改为等等等等。

12616
17:17:16.293 --> 17:17:19.417
现在，回到我们的应用程序，到这里。

12617
17:17:19.417 --> 17:17:20.823
我们会断开联系。

12618
17:17:20.823 --> 17:17:24.621
现在我们把这两个都断开。

12619
17:17:24.621 --> 17:17:25.871
和断开。

12620
17:17:25.871 --> 17:17:29.653
我们会看到它现在已经从本地存储中删除了。

12621
17:17:29.653 --> 17:17:37.147
如果我们到控制台，它会说，no account，改变no, no account found，并删除它。

12622
17:17:37.147 --> 17:17:41.621
如果我点击刷新，这里什么都没发生，我可以继续连接。

12623
17:17:41.621 --> 17:17:44.454
下一个连接，我可以刷新。

12624
17:17:44.622 --> 17:17:47.081
哦，我需要回到这里重新启用这个。

12625
17:17:47.622 --> 17:17:49.392
把这个加回来。

12626
17:17:49.392 --> 17:17:50.900
但现在它可以刷新了。

12627
17:17:51.622 --> 17:17:53.638
在这里断开连接。

12628
17:17:53.638 --> 17:17:54.767
我们联系了。

12629
17:17:56.622 --> 17:18:03.168
控制台，我们可以连接的东西会弹出下次连接，我可以刷新。

12630
17:18:03.168 --> 17:18:07.855
它为我保持连接，我可以切换帐户，我可以继

12631
17:18:07.855 --> 17:18:12.543
续，我可以切换帐户，我甚至可以断开连接。

12632
17:18:12.622 --> 17:18:15.574
它会自动为我更新，这是我们想要的。

12633
17:18:15.622 --> 17:18:24.537
现在我们做了一个更健壮的连接按钮，当我们连接时，它可以来回移动。

12634
17:18:24.622 --> 17:18:29.405
我们还需要做一件事，或者说应用程序当我们点击连接时，

12635
17:18:29.405 --> 17:18:34.372
我们需要禁用这个按钮，对吧?我们不希望它允许它被按压。

12636
17:18:34.372 --> 17:18:43.131
我点击取消，我们还要在这里添加一个功能，我们要添加这是web3enable loading。

12637
17:18:43.131 --> 17:18:47.740
它的作用是检查Metamask是否弹出。

12638
17:18:47.740 --> 17:18:53.331
我们的按钮在点击部分之后，我们可以添加disabled。

12639
17:18:53.331 --> 17:18:58.571
=是web3enable loading，如果我们在这里加载，它会被禁用。

12640
17:18:58.622 --> 17:19:01.888
我们继续，断开，断开。

12641
17:19:02.622 --> 17:19:05.186
点击Connect，你会看到可以点击这个按钮。

12642
17:19:05.622 --> 17:19:07.622
只是让它看起来更漂亮。

12643
17:19:09.622 --> 17:19:17.571
Bada boom，棒极了，我们刚刚做了一个方式更强大的前端比我们之前的连接按钮是超级光滑。

12644
17:19:17.622 --> 17:19:19.300
它让我们可以来回翻转。

12645
17:19:19.622 --> 17:19:25.732
应用程序非常强大，知道如何处理所有这些不同的更改。

12646
17:19:25.732 --> 17:19:33.929
现在我们已经学会了如何用手动的方式来做，让我用Chiti的方式来做，在组件中，我们会创建一个新的文件头。

12647
17:19:33.929 --> 17:19:42.442
js，我们要做的是安装这个webthree UI工具包，这是一个前端工具包，它已经为我们构建了很多这些组件。

12648
17:19:42.442 --> 17:19:47.823
我们可以通过使用这个来创建header组件和connect按钮组件。

12649
17:19:47.823 --> 17:19:52.148
为了安装它，我们会回到这里，我们会停止我们的前端。

12650
17:19:52.148 --> 17:19:56.559
我们会运行yarn, addweb3uikit，像这样。

12651
17:19:56.559 --> 17:20:03.973
再说一次，我们不想让它成为一个开发依赖项，因为它将成为我们网站的一部分，然后我们会在标题中做。

12652
17:20:03.973 --> 17:20:10.477
js，我们会import connect button from web3uitkit。

12653
17:20:10.477 --> 17:20:15.956
然后我们会导出default function header。

12654
17:20:15.956 --> 17:20:20.671
然后我们要做的就是返回一个div。

12655
17:20:20.671 --> 17:20:24.461
在这个div中，我们用next button。

12656
17:20:24.623 --> 17:20:28.023
这里有个反斜杠，这个项目不需要这个。

12657
17:20:28.023 --> 17:20:31.558
但如果我们想要非常明确，我们会说Morales off = false。

12658
17:20:31.558 --> 17:20:38.311
重申一下，我们这里并不是要连接到服务器，只是为了更明确一点。

12659
17:20:38.311 --> 17:20:43.590
这个连接按钮可以做所有事情，这个我们刚创建的手动头可以。

12660
17:20:43.590 --> 17:20:45.131
回到我们的索引。

12661
17:20:45.131 --> 17:20:50.010
Js，我们可以注释或删除这一行将import header

12662
17:20:50.010 --> 17:20:56.067
from。dot。slash components / header。

12663
17:20:56.067 --> 17:21:00.803
我们不用手动标头，而是直接标头。

12664
17:21:00.803 --> 17:21:05.227
我们再次用yarn dev启动我们的应用，回到页面，我

12665
17:21:05.227 --> 17:21:09.816
们在这里做一点刷新，我们现在看到我们有这个连接钱包按钮。

12666
17:21:09.816 --> 17:21:11.081
它甚至看起来好多了。

12667
17:21:11.081 --> 17:21:14.887
它也有一些很好的样式，我们可以点击连接钱包。

12668
17:21:14.887 --> 17:21:19.899
它会给我们这个小ngModel询问我们想连接到哪个钱包。

12669
17:21:19.899 --> 17:21:27.642
问我们想连接到哪面墙在我们的手动头文件中类似于设置物品连接，注入，右或钱包连

12670
17:21:27.642 --> 17:21:35.385
接，它会为信任钱包设置连接钱包连接，它会它会将物品设置为连接钱包连接，等等。

12671
17:21:35.385 --> 17:21:38.242
所以它允许我们以不同的方式联系。

12672
17:21:38.242 --> 17:21:45.899
如果我们点击Metamask，我们继续连接这里有一些漂亮的样式它会在这里给我们钱包地址。

12673
17:21:45.899 --> 17:21:49.209
但它也让我们的钱包余额。

12674
17:21:49.209 --> 17:21:52.804
如果我们继续断开连接，我们会看到它自动断开。

12675
17:21:52.804 --> 17:21:55.481
我们就像这样连接，这样我们就可以重新连接，砰，砰。

12676
17:21:55.481 --> 17:21:59.382
如果我们换了账户，它会很聪明地知道我们在换账户。

12677
17:21:59.382 --> 17:22:01.364
我知道我用了很艰难的方式让你明白了。

12678
17:22:01.364 --> 17:22:03.442
但我想向你们展示这是怎么回事。

12679
17:22:03.442 --> 17:22:09.089
它在后台设置这个本地存储以便它知道它实际连接到哪里。

12680
17:22:09.089 --> 17:22:11.827
但是对于头部向前移动，这就是你所需要的。

12681
17:22:11.827 --> 17:22:14.521
你的生活会变得非常非常容易。

12682
17:22:14.624 --> 17:22:21.957
我们可以在标题处添加一个集中的抽签或者分散的抽奖或者任何你想要的。

12683
17:22:21.957 --> 17:22:26.558
上面写着去中心化彩票，你知道那个按钮，你好。

12684
17:22:26.558 --> 17:22:34.474
现在我们有了这个，我们还需要什么?嗯，嗯，这个应用需要做的主要事情是有一个大按钮，说进入彩票。

12685
17:22:34.474 --> 17:22:38.591
然后理想情况下，你知道，展示有多少人参加了抽奖，然后是最近的中奖者。

12686
17:22:38.624 --> 17:22:42.024
让我们继续，我们将创建一个名为lottery entry的新组件。

12687
17:22:42.024 --> 17:22:49.543
我们会抓取那个组件就像我们处理头文件一样，我们会把这个组件放到这里。

12688
17:22:49.625 --> 17:22:51.038
然后我们的应用就差不多完成了。

12689
17:22:51.625 --> 17:22:57.539
这个彩票入口组件，那个Jas，对，我们把这些放在组件里的原因是，

12690
17:22:57.539 --> 17:23:05.302
我们可以100%把所有的代码都放在这里，让它更模块化，所以我们在未来，如果我们想要更

12691
17:23:05.302 --> 17:23:12.142
我们想要更多的页面或做其他事情，我将把它缩小一点这样我们就能更容易地看到所有的代码。

12692
17:23:12.142 --> 17:23:13.590
这是整个指标js。

12693
17:23:13.590 --> 17:23:15.053
这是整个标题。

12694
17:23:15.053 --> 17:23:23.973
我们来创建一个新的彩票入口应用这是样板代码我们将导出默认彩票入口，不好意思，是导出

12695
17:23:23.973 --> 17:23:32.893
默认函数，彩票入口，这将是另一个组件我们将返回一些JSX HTML的东西，对吧?我

12696
17:23:32.893 --> 17:23:41.815
们用div，然后用hi from lottery entrance, Excel。

12697
17:23:41.815 --> 17:23:46.160
现在我们做了这些，我们可以回到索引。

12698
17:23:46.160 --> 17:23:46.374
js。

12699
17:23:46.374 --> 17:23:53.198
我们可以从。点。斜杠组件导入彩票入口。

12700
17:23:53.198 --> 17:23:59.800
Slash彩票入口，把它贴在标题下面，像这样。

12701
17:23:59.800 --> 17:24:08.291
如果我们回到我们的网站，我们看到彩票入口在上面所以我们的彩票入口就在标题下面，这是我们想要的。

12702
17:24:08.291 --> 17:24:10.247
然后我们会删除这一行，Hello。

12703
17:24:10.247 --> 17:24:16.108
那么抽签入口，我们首先需要做的是什么呢?

12704
17:24:16.108 --> 17:24:21.969
我们想要有一个函数来调用彩票来进入彩票。

12705
17:24:21.969 --> 17:24:23.297
我们来做这个。

12706
17:24:23.297 --> 17:24:30.986
现在我们回到HTML是怎么做的回想一下这个有趣的函数，但是这样做不会重新播放。

12707
17:24:30.986 --> 17:24:35.934
还有很多其他的功能像这样做不会给我们所以我们要用Morale

12708
17:24:35.934 --> 17:24:41.047
s来调用其中的一些函数，因为mirallas在React中有。

12709
17:24:41.047 --> 17:24:45.001
再说一次，它们有钩子让我们做几乎任何我们想做的事。

12710
17:24:45.001 --> 17:24:48.314
其中一个钩子叫做use web three contract。

12711
17:24:48.314 --> 17:24:52.956
它的作用是给我们一个钩子它会给我们从一个叫error

12712
17:24:52.956 --> 17:24:59.564
returned的函数返回的数据，一个我们可以用来调用任何函数的小函数。

12713
17:24:59.626 --> 17:25:03.077
然后我们还有这些非常有用的isfetingisloading。

12714
17:25:03.077 --> 17:25:07.724
如果我们想让每个人都有UI或网站，在抓取或加

12715
17:25:07.724 --> 17:25:12.371
载事务时做点什么，我们可以用这两个变量来做。

12716
17:25:12.371 --> 17:25:17.774
然后我们只需要给它传递契约信息，类似于ethers，它将

12717
17:25:17.774 --> 17:25:23.371
是ABI契约地址，我们将传递函数名，然后是函数的任何参数。

12718
17:25:23.371 --> 17:25:28.559
我们将使用这里的语法将事务发送到区块链。

12719
17:25:28.626 --> 17:25:29.483
调用这些函数。

12720
17:25:30.626 --> 17:25:37.263
我们将从react mirallas进口web三合同。

12721
17:25:37.263 --> 17:25:43.400
在函数内部，当然在我返回之前，我们要说const。

12722
17:25:43.400 --> 17:25:46.376
然后我们就像在这里看到的那样。

12723
17:25:46.376 --> 17:25:55.359
现在，我们来求这个函数，我们来求这个合约函数，因为这是我们可以调用的进入彩票的函数。

12724
17:25:55.359 --> 17:26:00.576
我们会说const，运行合约函数，我们会调用这个enter raffle。

12725
17:26:00.626 --> 17:26:09.281
我们会说=，使用web3contract，我们需要传递ABI，我们需要传递契约

12726
17:26:09.281 --> 17:26:18.159
地址，我们需要给它函数名，我们需要给它params，实际上我们知道它将是空白的。

12727
17:26:18.159 --> 17:26:20.529
但最后，我们将需要消息值。

12728
17:26:20.627 --> 17:26:26.950
因为如果我们记得，back into raffle不带任何参数，它只带这个message。value bit。

12729
17:26:26.950 --> 17:26:30.488
这就是我们要通过的。

12730
17:26:30.488 --> 17:26:34.738
那么我们怎么得到这些东西呢，我把这些留在这里。

12731
17:26:34.738 --> 17:26:38.801
但我们现在要把它注释掉，因为这是我们需要做的。

12732
17:26:38.801 --> 17:26:41.890
但我们需要把所有这些东西都放到代码中。

12733
17:26:41.890 --> 17:26:46.385
那么我们是怎么得到这些东西的呢?ABI很简单，对吧?

12734
17:26:46.385 --> 17:26:51.053
Abi不会改变，无论在什么网络上，Abi都会保持不变。

12735
17:26:51.053 --> 17:26:55.576
如果你已经部署了你的智能合约，你知道它的确切地址，因为你已经部

12736
17:26:55.576 --> 17:27:00.246
署到一个主网，或者部署到一个测试网，所有这些东西都不会真的改变。

12737
17:27:00.246 --> 17:27:03.272
我们可以把它硬编码到这里。

12738
17:27:03.272 --> 17:27:06.454
或者我们可以像很多人做的那样创建一个常数文件夹。

12739
17:27:06.454 --> 17:27:14.341
在这里，他们会添加API。JSON，也许他们会添加合约地址。JSON。

12740
17:27:14.341 --> 17:27:21.010
然后他们会添加一个索引。js之类的东西，我们会建立一个我们可以在本地使用我

12741
17:27:21.010 --> 17:27:27.679
们自己的硬帽网络进行测试的应用程序，然后将它与实际测试网上的情况进行比较。

12742
17:27:27.679 --> 17:27:29.427
所以我们要让它成为网络不可知论者。

12743
17:27:29.427 --> 17:27:33.198
所以不管我们用的是什么网络前端都是一样的。

12744
17:27:33.198 --> 17:27:39.392
我们可以回去，下载一个目录到CD上，硬帽智能合约抽签免费

12745
17:27:39.392 --> 17:27:45.808
代码营，然后旋转我们的节点，用hh节点或yarn硬帽节点。

12746
17:27:45.808 --> 17:27:49.818
我们用这个作为我们要连接的区块链。

12747
17:27:49.818 --> 17:27:55.289
问题是，如果我回到这里，我在做前端，我想，啊，如果我们做X Y或Z会更好。

12748
17:27:55.289 --> 17:28:03.447
也许我改变了一些函数的名字，等等，等等，我希望这些改变能反映在前端。

12749
17:28:03.447 --> 17:28:06.305
我希望能够这样编码我的前端。

12750
17:28:06.305 --> 17:28:12.981
由于我们是目前唯一的开发人员，我们有能力在我们都知道的地方，后端代码和前端代码。

12751
17:28:12.981 --> 17:28:19.775
我想做的是让我的生活更简单我想做的是创建一个更新前端部署脚本。

12752
17:28:19.775 --> 17:28:26.767
在我们部署完东西之后，我们运行一个小脚本它会为我们创建这个包含很多东西的常量文

12753
17:28:26.767 --> 17:28:33.940
件夹?它会给出ABI，它会给出合同地址以及我们前端从后端可能需要的任何其他信息。

12754
17:28:33.940 --> 17:28:40.351
所以我喜欢做的是回到我的原始代码并为一个新的脚本更新这个。

12755
17:28:40.351 --> 17:28:45.817
我进入部署脚本，创建一个新文件，命名为oh two

12756
17:28:45.817 --> 17:28:51.503
或者9999,up date front和。Jas。

12757
17:28:51.503 --> 17:28:58.471
我用99的原因很明显，是因为我们希望它始终是deploy文件夹中的最后一个脚本。

12758
17:28:58.471 --> 17:29:01.136
然后我们可以写一个连接的小脚本。

12759
17:29:01.136 --> 17:29:05.976
我们只需要写一个小脚本连接到我们的前端这样当我们部署

12760
17:29:05.976 --> 17:29:10.817
契约时，无论链是什么，我们都能更新前端的常量文件夹。

12761
17:29:10.817 --> 17:29:18.144
现在我们来创建这个脚本我们写入module。exports = async function。

12762
17:29:18.144 --> 17:29:24.939
我们会把所有的东西都加进去，我们不需要部署任何契约，因为我们只是更新前端。

12763
17:29:24.939 --> 17:29:26.962
所以我们可以把这个的参数留为空。

12764
17:29:26.962 --> 17:29:32.070
我喜欢做的另一件事，因为有时我不关心前端，我

12765
17:29:32.070 --> 17:29:37.179
只会在我们指定了一个。env变量时更新前端。

12766
17:29:37.179 --> 17:29:42.809
我创建一个。env变量叫做up date, front end。

12767
17:29:42.809 --> 17:29:45.006
然后设这个为真。

12768
17:29:45.006 --> 17:29:52.343
现在在我们的脚本中，我们可以说if process。E和V。update，前端。

12769
17:29:52.343 --> 17:29:57.517
我们可以说，console。log，更新前端。

12770
17:29:57.517 --> 17:30:02.270
现在回到这里，如果一个mat如果我在正确的目录中，如果

12771
17:30:02.270 --> 17:30:07.200
我们自己的硬点击Deploy，你知道，得到这个更新前端。

12772
17:30:07.200 --> 17:30:08.596
现在我们可以更新前端。

12773
17:30:08.596 --> 17:30:09.321
我们开始做吧。

12774
17:30:09.321 --> 17:30:15.190
我要创建一个函数，叫Update contract addresses。

12775
17:30:15.190 --> 17:30:20.339
这将是我们用来更新契约地址的函数，然后我将创建一个名为update

12776
17:30:20.339 --> 17:30:25.488
API的函数，我们将更新API和前端我们将调用这个更新契约地址。

12777
17:30:25.488 --> 17:30:31.399
我要创建一个新函数async function，更新合约地址。

12778
17:30:31.399 --> 17:30:37.488
首先，我们要拿到那个抽奖合同因为我们需要知道它的地址。

12779
17:30:37.488 --> 17:30:39.661
我们写入const, raffle = await。

12780
17:30:39.661 --> 17:30:44.990
我们会做同样的事情我们做过ethers。get contract, raffle，然后我的VS

12781
17:30:44.990 --> 17:30:50.547
code自动导入，它不会const ethers = require Hardhead，像这样。

12782
17:30:50.547 --> 17:30:51.891
我们这里有抽奖。

12783
17:30:51.891 --> 17:30:59.044
我们要想通过这抽奖活动地址我们的前端,因为这将是一个变量,我们

12784
17:30:59.044 --> 17:31:06.197
可能会使用很多地方,我们可以把它像const,前端位置,文件地

12785
17:31:06.197 --> 17:31:13.350
址,等于,我们要给我们现在的相对路径,也就是你知道,如果我们看

12786
17:31:13.350 --> 17:31:20.968
到下载目录合同明年的智能彩票,FCC,我甚至可以复制,粘贴在这里。

12787
17:31:20.968 --> 17:31:26.576
然后是常量文件夹，这里是合约地址。JSON。

12788
17:31:26.576 --> 17:31:30.926
我们来获取ABI文件，我们用const。

12789
17:31:30.926 --> 17:31:37.613
Front和bi文件将会等于这几乎是一样的。

12790
17:31:37.613 --> 17:31:39.630
我们可以复制粘贴它。

12791
17:31:39.630 --> 17:31:43.330
然后是/ API。JSON。

12792
17:31:43.330 --> 17:31:50.218
现在在更新契约地址函数中，我们可以说const，当前地

12793
17:31:50.218 --> 17:31:57.106
址，等于我们可以在前端读取，我们可以从这个文件中读取。

12794
17:31:57.106 --> 17:31:59.480
我通常会从两个括号开始。

12795
17:31:59.480 --> 17:32:02.328
这两个文件都是JSON兼容的。

12796
17:32:02.328 --> 17:32:06.561
要读取它，我们会说JSON。parse FS。

12797
17:32:06.561 --> 17:32:11.531
read file sync，我们需要导入const。

12798
17:32:11.630 --> 17:32:19.889
FS = require，我知道我们以前用过FS extra，但这个，我们只使用FS，

12799
17:32:19.889 --> 17:32:28.148
它将是我们的front and addresses文件，我们将用utf8编码将它读入。

12800
17:32:28.148 --> 17:32:30.112
这就是我们的当前地址。

12801
17:32:30.112 --> 17:32:34.430
我们会用一些新地址更新当前地址列表。

12802
17:32:34.430 --> 17:32:42.514
因为我们的合同地址我们希望它是链不可知的，我们会做一些事情，比如冰场B上的地址，我们可

12803
17:32:42.514 --> 17:32:50.788
以做31337，然后是本地主机上的地址，对，我们希望能够跟踪所有不同链上的所有不同地址。

12804
17:32:50.788 --> 17:32:58.876
回到函数中，我们写入if if network。config。chain id。

12805
17:32:58.876 --> 17:33:04.178
输入合约地址，这是配置思想，

12806
17:33:04.178 --> 17:33:09.860
然后我们会添加这个新合约地址。

12807
17:33:09.860 --> 17:33:14.320
但在我们添加这个新地址之前，让我们检查一下它是否已经在那里了。

12808
17:33:14.320 --> 17:33:21.171
我们写入if契约地址。config。chain id。

12809
17:33:21.171 --> 17:33:29.420
to string，这太长了，我不想一直写下去，我要说const chain ID = network，配置那个chain ID。

12810
17:33:29.420 --> 17:33:33.648
到string，我们将使用chain ID。

12811
17:33:33.648 --> 17:33:38.094
如果链ID和合同地址，那么如果

12812
17:33:38.094 --> 17:33:42.837
我们还没有，那就包括抽签。地址。

12813
17:33:42.837 --> 17:33:51.144
我们会添加这个新地址如果链ID不存在，我们会输

12814
17:33:51.144 --> 17:33:59.451
入合约地址当前地址，等于或者假设链ID等于的当

12815
17:33:59.451 --> 17:34:08.122
前地址然后我们会创建一个新数组，抽抽出那个地址。

12816
17:34:08.122 --> 17:34:13.104
我们说，如果链ID在当前地址中不存在，我们就会把这个新数组添加进去。

12817
17:34:13.104 --> 17:34:17.736
最后，我们已经更新了它的对象，我们要把它写回这个文件，我们写入Fs。

12818
17:34:17.736 --> 17:34:23.596
write, file sync, front And addresses file。

12819
17:34:23.596 --> 17:34:26.854
然后是JSON。string (5)

12820
17:34:26.854 --> 17:34:31.782
我们会Stringify这个JSON对象，我们会把它写回去。

12821
17:34:31.782 --> 17:34:39.293
然后是输出标签= all的底部模块然后是前端。

12822
17:34:39.293 --> 17:34:39.763
我很酷。

12823
17:34:39.763 --> 17:34:43.737
因此，我们有一个更新契约地址的函数，但我们还需要ABI。

12824
17:34:43.737 --> 17:34:50.822
我们要做date API，我们要创建另一个函数async function, update API。

12825
17:34:50.822 --> 17:34:58.525
在这里，我们要对raffle equals await醚做完全相同的事情，

12826
17:34:58.525 --> 17:35:06.438
raffle FX。right file, sync, front和abi。

12827
17:35:06.438 --> 17:35:11.489
它会复制粘贴到AVI文件的前端。

12828
17:35:11.489 --> 17:35:19.109
然后传递ABI，我们可以直接从这个raffle对象获取它，我们可以用raffle。

12829
17:35:19.109 --> 17:35:28.032
interface format ethers。utils。format types。JSON。

12830
17:35:28.032 --> 17:35:36.563
如果你看醚类文档，醚类有合约点接口的东西它返回的接口不同于固体接口。

12831
17:35:36.563 --> 17:35:40.360
但它允许我们只用一行代码就能得到API。

12832
17:35:40.360 --> 17:35:45.403
后端代码中，如果运行h h deploy或h h

12833
17:35:45.403 --> 17:35:51.287
node，我们会自动更新API。JSON中的合约地址。

12834
17:35:51.287 --> 17:35:53.336
我们来试试这个。

12835
17:35:53.336 --> 17:35:55.139
我们运行h h node。

12836
17:35:55.139 --> 17:36:00.763
我们从这个终端开始一个节点，我们将翻转到前端。

12837
17:36:00.763 --> 17:36:07.099
如果我们打开ABI to JSON，我们确实，看，我们在这个文件中有raffle API。

12838
17:36:07.099 --> 17:36:13.570
如果我们查看合同地址，我们在网络31337上看到，这是我们的第一个地址。

12839
17:36:13.570 --> 17:36:20.568
如果我们部署到不同的链上，这将被填充不同的网络id，然后是与它们相关的地址列表。

12840
17:36:20.568 --> 17:36:26.445
所以它帮助我们的前端更容易维护，更容易弹跳，更容易测试和工作。

12841
17:36:26.445 --> 17:36:35.433
现在我们已经完成了所有这些，我们可以关闭硬帽智能合约抽签免费代码营，这个硬帽项目，我们将把所有终端都放在这里。

12842
17:36:35.433 --> 17:36:40.994
我们要做的是往下，目录CD。。然后CD进入。哦，抱歉，我们

12843
17:36:40.994 --> 17:36:46.747
实际上已经在他们的CD中了，硬帽，智能合约，抽签免费代码营。

12844
17:36:46.747 --> 17:36:50.934
然后在这个中，我们会运行hh node或yarn hardhat node。

12845
17:36:50.934 --> 17:36:57.823
现在我们有一个本地区块链运行，所以我们可以测试我们在前端做的所有事情，实际上，我要把这个移上来。

12846
17:36:57.823 --> 17:37:04.720
现在在我们的第一个区域，这里，我们有我们的前端代码运行，然后我们有区块链运行。

12847
17:37:04.720 --> 17:37:07.836
然后在这个式子中，我们要加，你知道，我们想加什么就加什么。

12848
17:37:07.836 --> 17:37:11.508
现在，我们可以继续按这个小X键来关闭面板。

12849
17:37:11.508 --> 17:37:16.775
这只是隐藏了面板，这些都还在外面，只有当你击中小垃圾桶时，它们才会被丢弃。

12850
17:37:16.775 --> 17:37:18.370
所以我们要关闭面板。

12851
17:37:18.370 --> 17:37:21.383
但所有的终端都还在运行，我保证。

12852
17:37:21.383 --> 17:37:24.508
我们说到哪了?好，回到我们的函数。

12853
17:37:24.633 --> 17:37:30.039
所以我们只是自动化了更新API的过程，然后更新我们的合同。

12854
17:37:30.039 --> 17:37:32.075
现在我们可以把这些导入到我们的文件中。

12855
17:37:32.075 --> 17:37:38.450
现在我们可以一次导入一个，就像import API，从。。斜杠常量，

12856
17:37:38.450 --> 17:37:45.575
斜杠API，或者我们可以做一些更聪明的事情我们可以把这些导出到同一个文件中。

12857
17:37:45.575 --> 17:37:47.961
如果我们创建一个新文件，一个新索引。

12858
17:37:47.961 --> 17:37:52.500
Js，在这里，我们可以导入然后导出到这个文件中。

12859
17:37:52.500 --> 17:37:59.221
我们可以说const，合约编辑器说= require。/合约编辑器。

12860
17:37:59.221 --> 17:38:06.734
JSON，然后const API = require。/ API。JSON。

12861
17:38:06.734 --> 17:38:13.834
然后我们会做模块。export = API和合约地址。

12862
17:38:13.834 --> 17:38:20.441
一旦我们像这样导出它们回到彩票入口，我们可以在一行中导入它们。

12863
17:38:20.441 --> 17:38:28.817
我们输入import API，逗号，合约地址from。。

12864
17:38:28.817 --> 17:38:33.709
我们可以指定文件夹而不是每个单独的文件，因为我

12865
17:38:33.709 --> 17:38:38.602
们有这个索引。j s，它基本上代表整个文件夹。

12866
17:38:38.602 --> 17:38:42.900
回到这里，我们现在有什么?让我们取消注释这个abi。

12867
17:38:42.900 --> 17:38:43.700
好了,好了。

12868
17:38:43.700 --> 17:38:50.650
我们有ABI我们从常量，文件夹，合约地址导入它，我们有合约地址。

12869
17:38:50.650 --> 17:38:55.896
我们马上就需要指定网络ID。

12870
17:38:55.896 --> 17:39:00.117
我们这里有函数名，它将是进入抽奖的。

12871
17:39:00.117 --> 17:39:01.729
没有参数。

12872
17:39:01.729 --> 17:39:08.869
我们需要做的是如何同时获得chain ID和message。value也会改变，

12873
17:39:08.869 --> 17:39:17.795
这是我们用Morales很容易得到的，让我们再把这一整部分注释掉，这样我就能展示我们可以导入的东西。

12874
17:39:17.795 --> 17:39:25.518
再一次，我们将从react Morales得到use Morales的书。

12875
17:39:25.635 --> 17:39:29.532
我们能做的是写入const。

12876
17:39:29.635 --> 17:39:32.809
Chain ID = use ralis。

12877
17:39:37.635 --> 17:39:42.320
我们所处的链是因为在我们的头组件中，头实际上将所有关

12878
17:39:42.320 --> 17:39:47.005
于Metamask的信息传递给Morales提供者。

12879
17:39:47.005 --> 17:39:51.688
然后Morales提供者将它传递给那些Morale

12880
17:39:51.688 --> 17:39:56.560
s提供的标签中的所有组件集中等于使用Morales。

12881
17:39:56.635 --> 17:40:01.477
我要写一个小的控制台日志链ID因为我想让你们看看它是什么样子的。

12882
17:40:01.477 --> 17:40:08.314
如果我们做一个小的刷新,我们这里在控制台,在这里我们可以忽略这些警告,但实际上我们看到链式ID 0

12883
17:40:08.314 --> 17:40:15.290
x 5、好吧,因为我在溜冰场B链或Grilley链对不起,如果我切换回安全帽localhost,你应

12884
17:40:15.290 --> 17:40:22.687
该知道如何从某有趣我们打赌如果你没有安全帽localhost和Metamask回到HTML字体我们一点。

12885
17:40:22.687 --> 17:40:23.318
好了,好了。

12886
17:40:23.318 --> 17:40:26.169
现在它会打印这个哦x等等等等。

12887
17:40:26.169 --> 17:40:28.603
这可能有点让人困惑。

12888
17:40:28.603 --> 17:40:31.409
但这是链ID的十六进制形式。

12889
17:40:31.409 --> 17:40:31.796
正确的。

12890
17:40:31.796 --> 17:40:34.183
让我们切换到以太主网。

12891
17:40:34.183 --> 17:40:38.801
现在我们读x 1，对吧?x1是1的十六进制形式。

12892
17:40:38.801 --> 17:40:43.028
chain ID是chain ID的十六进制加法。

12893
17:40:43.028 --> 17:40:45.920
我要的不是十六进制加法，我要的是实际的数字。

12894
17:40:45.920 --> 17:40:51.860
我要做的是我要说，好，chain ID，你的名字实际上是chain ID hex。

12895
17:40:51.860 --> 17:40:55.206
我们可以写console。log chain ID十六进制，但我要的是数字。

12896
17:40:55.206 --> 17:41:03.235
我们能做的是解析JavaScript内置的parse int CIN ID十六进制。

12897
17:41:03.235 --> 17:41:06.502
现在回到这里，我们来刷新一下。

12898
17:41:06.636 --> 17:41:09.120
滚动警告，我们可以看到这里的一个。

12899
17:41:09.636 --> 17:41:11.974
切换到硬帽子，localhost。

12900
17:41:14.636 --> 17:41:19.761
用Morales chain ID返回十六进制，用Parson解析得到实际数字。

12901
17:41:19.761 --> 17:41:20.323
好了,好了。

12902
17:41:20.323 --> 17:41:22.226
所以我们可以把链ID放在这里。

12903
17:41:22.226 --> 17:41:30.861
这个抽奖地址我们会经常用到，我们不妨把它放在代码的顶部，我们不会改变抽奖地址。

12904
17:41:30.861 --> 17:41:32.054
所以我们不需要把它放在钩子里。

12905
17:41:32.054 --> 17:41:35.586
从技术上讲，我们在改变网络的时候也会改变地址。

12906
17:41:35.636 --> 17:41:39.898
但我们的头应用负责重新渲染和处理所有这些。

12907
17:41:39.898 --> 17:41:41.373
我们可以把它设为常数。

12908
17:41:41.373 --> 17:41:46.465
我们可以说const, raffle address =，首先让我们检查chain

12909
17:41:46.465 --> 17:41:52.055
ID十六进制如果有chain ID十六进制如果没有chain ID十六进制我们就做别的。

12910
17:41:52.055 --> 17:41:56.227
不好意思，我们会说链ID十六进制合同地址。

12911
17:41:56.227 --> 17:41:58.202
事实上，永远不会有链条ID妖术。

12912
17:41:58.202 --> 17:42:06.836
我们用const chain ID = Gen ID hex parsed, Parsons, chinati hex，你可能会想，这两个名字是一样的。

12913
17:42:06.836 --> 17:42:11.162
我们在上面用Morales做的是我们说，拉出下巴ID对象，

12914
17:42:11.162 --> 17:42:18.175
然后重命名为chain ID hex在下面这里，我们说，我们要创建一个新变量chain ID。

12915
17:42:18.175 --> 17:42:23.019
我们说链ID在0处的契约地址。

12916
17:42:23.019 --> 17:42:30.567
在这里，我们说这个网络ID和这个地址，否则，我们会说不。

12917
17:42:30.636 --> 17:42:32.198
好了，我们快到了。

12918
17:42:34.636 --> 17:42:36.921
抽奖地址，我们可以把它放在这里。

12919
17:42:37.636 --> 17:42:39.540
是消息点值。

12920
17:42:42.636 --> 17:42:45.127
实际上是动态设置费用。

12921
17:42:46.637 --> 17:42:50.110
我们让入口费等于入口费，这是构造函数中的参数。

12922
17:42:50.110 --> 17:42:52.687
我们把这个叫做get入口费函数。

12923
17:42:52.687 --> 17:42:55.187
这是我们发送事务的一种方式。

12924
17:42:55.187 --> 17:43:00.169
我们还可以发送函数，其中一种方法是当彩票入

12925
17:43:00.169 --> 17:43:05.390
口加载时，我们会运行一个函数来读取入场费值。

12926
17:43:05.390 --> 17:43:10.754
我们怎么做呢?我们可以再次使用其中一个钩子，当某些东西发生变化时，使

12927
17:43:10.754 --> 17:43:16.119
用效果可以运行，我们只会在启用web 3的情况下尝试获得抽奖入场费。

12928
17:43:16.119 --> 17:43:22.096
所以我们能做的就是回到这里，用Morales来拉进来，这是启用的web 3。

12929
17:43:22.096 --> 17:43:27.176
我们会在函数中有使用效果，我们会说如果

12930
17:43:27.176 --> 17:43:32.524
这是web3启用的，然后我们会试着读取。

12931
17:43:32.637 --> 17:43:36.572
我们可以继续使用这个，使用web 3，合同瓦根。

12932
17:43:36.637 --> 17:43:37.981
我们来复制粘贴这个。

12933
17:43:38.637 --> 17:43:40.162
同样的设置。

12934
17:43:44.637 --> 17:43:47.348
我们会得到入场费的。

12935
17:43:48.637 --> 17:43:49.669
领取入场费。

12936
17:43:52.637 --> 17:43:52.737
它。

12937
17:43:55.637 --> 17:43:59.565
入场费params没有什么信息，没有什么价值。

12938
17:43:59.637 --> 17:44:02.391
我们会调用这个get入口费函数。

12939
17:44:02.637 --> 17:44:06.837
现在我给你们展示如何调用合同中的一个。

12940
17:44:06.837 --> 17:44:12.121
使用web三合同，下载我们的使用效果，我们其实是要打电话领入场费的。

12941
17:44:12.121 --> 17:44:19.924
如果我们像这样调用get入口费，我们说，const某某等于get入口费然后是console。

12942
17:44:19.924 --> 17:44:27.558
log某某，你认为会发生什么?哦，我需要导入，我需要从react导入use effect。

12943
17:44:27.638 --> 17:44:28.775
好了。

12944
17:44:33.638 --> 17:44:37.138
一些不能获得入场费的内容将是一个async函数。

12945
17:44:37.138 --> 17:44:44.304
再说一次，我们需要等待我们需要等待进入T，对吧?在我们的使用效果中有一个不能调用await的问题。

12946
17:44:44.304 --> 17:44:50.342
那么我们能做什么呢?我们可以做一个async函数，叫它update UI。

12947
17:44:50.342 --> 17:44:55.388
然后我们可以把这个放在async函数里面。

12948
17:44:55.388 --> 17:44:59.064
我们可以在它外面调用updatuui，像这样。

12949
17:44:59.064 --> 17:45:01.944
现在我们回到我们的前端，我们做一点刷新。

12950
17:45:01.944 --> 17:45:04.104
如果我们向上滚动，我们仍然什么也看不到。

12951
17:45:04.104 --> 17:45:07.037
web3是否启用，实际上是变化的。

12952
17:45:07.037 --> 17:45:11.976
这个第一次运行时，是否启用web3可能是false。

12953
17:45:11.976 --> 17:45:17.824
但当它为true时，我们想。我们想在我们的依赖数组中运行这个section。

12954
17:45:17.824 --> 17:45:26.432
我们要把这个加进去，对吧?它一开始为假的原因正是因为我们在手册头文件中所显示的?它是做什么的?首先，我们在刷新后检查，如

12955
17:45:26.432 --> 17:45:35.041
果window。local storage get item被连接，然后我们调用Enable web3，这会使这个启用。

12956
17:45:35.041 --> 17:45:41.734
在我们的彩票入口中，它们所启用的在刷新时开始为假。

12957
17:45:41.734 --> 17:45:47.722
然后浏览器检查本地存储说，web3应该是启用的，让我们启用它并为true。

12958
17:45:47.722 --> 17:45:54.532
如果我们点击保存，然后刷新控制台，我们就能看到注销费。

12959
17:45:54.532 --> 17:45:59.573
那么我们就把这个从合同中换成入场费。

12960
17:45:59.573 --> 17:46:04.844
现在，我们可能还想在UI上显示这个入口费，

12961
17:46:04.844 --> 17:46:10.115
如果我们让入口费，我们会说= blank。

12962
17:46:10.115 --> 17:46:17.281
我们会用这个来更新，我们会更新这个说入口费等于等待入口费。

12963
17:46:17.281 --> 17:46:17.548
酷。

12964
17:46:17.548 --> 17:46:21.092
现在我们有了一个全局变量，我们可以把它加到这里。

12965
17:46:21.092 --> 17:46:23.452
我们还可以收举重入场费。

12966
17:46:23.452 --> 17:46:26.876
括号里的整个式子，然后。

12967
17:46:26.876 --> 17:46:33.401
到字符串，我们甚至可以控制台点日志入口费用。

12968
17:46:33.639 --> 17:46:35.439
现在我们正在添加一个新的浏览器。

12969
17:46:36.639 --> 17:46:37.147
问题在这里。

12970
17:46:39.639 --> 17:46:41.389
刷新。

12971
17:46:41.639 --> 17:46:44.477
我们在UI中看不到门票。

12972
17:46:45.639 --> 17:46:46.623
控制台。注销，对。

12973
17:46:47.639 --> 17:46:54.115
在某种程度上，这里所发生的将会使用effect来重新渲染我们的浏览器?这就是我

12974
17:46:54.115 --> 17:47:00.591
们想要的三使能从false变为true，我们的浏览器重新渲染看，一旦我们拿到入

12975
17:47:00.591 --> 17:47:07.400
场费，我们的浏览器会重新渲染吗?不，它没有，因为入场费只是这些正常变量之一，对吧。

12976
17:47:07.400 --> 17:47:16.120
我们想把这个从一个普通变量变成一个钩子因为入口费会被更新，但它不会触发重新渲染。

12977
17:47:16.120 --> 17:47:19.832
我们想把这个改成所谓的use state钩子。

12978
17:47:19.832 --> 17:47:24.391
你可以阅读更多关于使用state钩子的文档，

12979
17:47:24.391 --> 17:47:28.951
它类似于让入口费等于什么的，然后设置在下面。

12980
17:47:28.951 --> 17:47:31.638
但它也会为我们触发回放。

12981
17:47:31.638 --> 17:47:37.835
要做到这一点，我们实际上用const入口费用，逗号，set

12982
17:47:37.835 --> 17:47:44.246
入口费用等于使用状态0 import使用状态也从react。

12983
17:47:44.246 --> 17:47:52.661
基本上，入口费就是我们的值，如果我们用console。log入口费，它会打印出入口

12984
17:47:52.661 --> 17:48:01.282
费入口费将是我们调用的获取入口费的变量，入口费将是我们调用的更新或设置入口费的函数。

12985
17:48:01.282 --> 17:48:05.164
不管这个入场费变量是什么，我们都会触发一个渲染。

12986
17:48:05.164 --> 17:48:10.553
在前端，我们有状态或函数中的实际变量来更新它。

12987
17:48:10.553 --> 17:48:17.306
然后在这里的使用状态，我们给它它的初始值我们说入口费开始是零。

12988
17:48:17.306 --> 17:48:23.690
现在我们知道了，回到下面这里，我们不说入口费等于这个，我们

12989
17:48:23.690 --> 17:48:30.295
可以说const入口费from call等于away入口费。

12990
17:48:30.295 --> 17:48:36.223
字符串，然后我们可以说，将入口费用设置为这个入口费用从调用。

12991
17:48:36.223 --> 17:48:40.425
现在当我们设置使用状态时，我们会触发一个重新渲染。

12992
17:48:40.425 --> 17:48:42.590
所以入场费实际上是会增加的。

12993
17:48:42.590 --> 17:48:47.306
到浏览器，稍微刷新一下。

12994
17:48:47.306 --> 17:48:52.623
我们可以看到入场费确实已经重新呈现在这里，我们实际上可以在这里看到。

12995
17:48:52.623 --> 17:49:00.122
我们在这里看到console。log(0)虽然我们在做console。log入口费用因为这个set入口函数还没有运行完。

12996
17:49:00.122 --> 17:49:06.990
我们删掉这一行会刷新Bada bing Bada boom，这个巨大的数字有点恶心。

12997
17:49:06.990 --> 17:49:12.213
我们甚至可能想要更新它，让它看起来更好一些。

12998
17:49:12.213 --> 17:49:17.990
同样，我们可以导入醚，从醚中导入醚。

12999
17:49:17.990 --> 17:49:22.242
在下面，我们会写一些ethers。

13000
17:49:22.242 --> 17:49:26.996
utils。format units。

13001
17:49:26.996 --> 17:49:34.847
我们会写入会费从电话我们会写一个逗号，然后输入。

13002
17:49:34.847 --> 17:49:39.728
如果我们在前端刷新，现在我们可以看到，入场费是0。

13003
17:49:39.728 --> 17:49:39.798
1.

13004
17:49:39.798 --> 17:49:45.553
我们甚至可以把它标记为入场费，等等等等。

13005
17:49:45.641 --> 17:49:49.516
如果我们在前端做一点刷新，入场费是0。

13006
17:49:49.641 --> 17:49:51.141
E。

13007
17:49:52.641 --> 17:49:58.044
最后，我们有入场费，现在在我们的函数上使用Finally进入彩票。

13008
17:49:58.044 --> 17:49:59.793
最后把注释去掉。

13009
17:49:59.793 --> 17:50:03.034
至于信息价值，我们要用这个入场费。

13010
17:50:03.034 --> 17:50:06.926
我意识到把它存储为raw到字符串的格式更好。

13011
17:50:06.926 --> 17:50:09.941
我们要撤销刚才做过的这部分。

13012
17:50:09.941 --> 17:50:11.541
我们要把它加到下面。

13013
17:50:11.641 --> 17:50:17.149
我们要用以太，这是单位的格式，入场费，逗号，以太，像这样。

13014
17:50:17.149 --> 17:50:20.926
就像这样，让我们很快地把这个注释掉。

13015
17:50:20.926 --> 17:50:23.493
至少在UI中，它显示为0。

13016
17:50:23.493 --> 17:50:23.558
1.

13017
17:50:23.558 --> 17:50:29.053
但在后端，我们会把它保存为原始的，有很大的价值。

13018
17:50:29.053 --> 17:50:37.891
我们有这个入场费，我们可以取消注释，我们可以抓取这个入场费，放到这里。

13019
17:50:37.891 --> 17:50:40.348
我们需要做一个按钮来做这个。

13020
17:50:40.348 --> 17:50:45.810
现在，我们想让我们的代码能够正常工作，即使我们连接到一个受支持的链。

13021
17:50:45.810 --> 17:50:51.391
所以在我们添加这个之前，如果我们从安全帽切换到Aetherium主网，做一点刷新。

13022
17:50:51.391 --> 17:50:57.159
这里我们会得到一个错误，因为我们调用了get入口费。

13023
17:50:57.159 --> 17:51:02.519
连接到一个不存在的地址，对吧?所以它会非常困惑，就像，嘿，你在这

13024
17:51:02.519 --> 17:51:08.048
里做什么?让我们在这里添加一个小按钮，这样我们就可以实际进入抽奖。

13025
17:51:08.048 --> 17:51:15.642
在我们这样做之前，让我们确保我们只能在有抽奖地址的情况下调用函数。

13026
17:51:15.642 --> 17:51:17.570
我们来抽奖吧。

13027
17:51:17.570 --> 17:51:21.012
我们再做一次三元算符。

13028
17:51:21.012 --> 17:51:27.378
只有在这个抽奖地址有效的情况下，对吧?它不是，不，我们把所有的代码都加在这里。

13029
17:51:27.378 --> 17:51:30.536
我们会说，如果抽奖地址存在，我们会做一些事情。

13030
17:51:30.536 --> 17:51:35.835
现在，我们可以复制粘贴这一行，粘贴到这里。

13031
17:51:35.835 --> 17:51:38.823
否则，我们会写div。

13032
17:51:38.823 --> 17:51:41.459
卓越div，关闭它。

13033
17:51:41.642 --> 17:51:43.963
保存重新格式化，很好。

13034
17:51:46.642 --> 17:51:47.158
检测到。

13035
17:51:50.642 --> 17:51:50.829
在这里。

13036
17:51:50.829 --> 17:51:53.079
这里有个小div，很不错。

13037
17:51:53.642 --> 17:51:56.803
这个div，让我们添加一个按钮。

13038
17:52:00.642 --> 17:52:04.782
这里有一个小按钮，我们会让它写着，进入抽奖。

13039
17:52:05.642 --> 17:52:09.007
比如onclick，我们会做一些JavaScript。

13040
17:52:09.642 --> 17:52:14.086
做一些JavaScript，我们想调用一个async函数。

13041
17:52:14.086 --> 17:52:17.583
我知道双括号会让人困惑，对吧。

13042
17:52:17.583 --> 17:52:22.372
这些括号允许我们在HTML或JSX中使用JavaScript。

13043
17:52:22.372 --> 17:52:27.314
这些括号代表这个函数，它将是一个async函数。

13044
17:52:27.314 --> 17:52:31.182
我们会说，等待，进入抽奖。

13045
17:52:31.182 --> 17:52:32.559
就是这样。

13046
17:52:32.559 --> 17:52:34.455
让我们回到最前面。

13047
17:52:34.455 --> 17:52:36.308
现在我们有一个小的抽奖函数。

13048
17:52:36.308 --> 17:52:41.508
刷新时，确保账户在这里重置。

13049
17:52:41.508 --> 17:52:45.811
下面是设置，高级，重置账户，是的。

13050
17:52:45.811 --> 17:52:46.980
我按ENTER抽奖。

13051
17:52:46.980 --> 17:52:48.815
Metamath确实出现了。

13052
17:52:48.815 --> 17:52:51.573
我们可以继续确认。

13053
17:52:51.573 --> 17:52:55.643
太好了，我们现在可以抽奖了。

13054
17:52:55.643 --> 17:52:59.443
我们在这方面做得非常好。

13055
17:52:59.643 --> 17:53:01.258
如你所见，我们刚刚弹出了这个窗口。

13056
17:53:02.643 --> 17:53:08.815
对吧?如果用户一直在看这个，然后说，好了，它通过了吗?或者我们失

13057
17:53:08.815 --> 17:53:14.987
败了，就像，刚刚发生了什么?我们要做的是创建所谓的通知，对吧?我

13058
17:53:14.987 --> 17:53:21.159
们希望弹出一个小窗口说，嘿，你发送了交易，干得好，我们要使用库。

13059
17:53:21.159 --> 17:53:26.708
我们会通过UI Kit使用web, UI Kit中有一些通知我们可以继续使用。

13060
17:53:26.708 --> 17:53:33.543
如果你找到这个互动的东西，就在他们的GitHub里，这里有很多东西。

13061
17:53:33.543 --> 17:53:36.938
你可以点击和玩不同的按钮和不同的东西。

13062
17:53:36.938 --> 17:53:40.857
你甚至可以去文档查看每一个。

13063
17:53:40.857 --> 17:53:42.642
你可以去展示代码。

13064
17:53:42.642 --> 17:53:48.785
你可以复制粘贴代码到你的项目中，做任何你想做的样式等等。

13065
17:53:48.785 --> 17:53:54.960
回到app。js中，我们会添加import，不，to vacations provider

13066
17:53:54.960 --> 17:54:00.586
from web3uikit在Morales provider内部，但在组件外部，

13067
17:54:00.586 --> 17:54:07.861
我们会做notificationprovider notificationprovider像这样添加它。

13068
17:54:07.861 --> 17:54:11.108
它是Morales提供者通知提供者组件。

13069
17:54:11.108 --> 17:54:18.239
把组件包装在这个通知中，那是通知提供者而不是通知。

13070
17:54:18.239 --> 17:54:23.410
这将允许我们在彩票入口中发出通知。

13071
17:54:23.410 --> 17:54:29.419
回到我们的彩票入口，我们会滚动到顶部，我们会导入一个

13072
17:54:29.419 --> 17:54:35.660
钩子那些通知叫我们知道，从web3uitkit到场合。

13073
17:54:35.660 --> 17:54:41.187
这个使用通知返回给我们这个叫做调度的东西。

13074
17:54:41.187 --> 17:54:45.258
所以我要说const dispatch = use notification。

13075
17:54:45.258 --> 17:54:51.916
use notification返回这个分派，这个分派就像一个小弹出框它会给我们下面这

13076
17:54:51.916 --> 17:54:57.490
里，当我们调用这个enter raffle时，我们会在这里给它一些参数，

13077
17:54:57.490 --> 17:55:05.234
我们会说onsuccess，这些函数带有onsuccess, onComplete，带有错误，等等。

13078
17:55:05.234 --> 17:55:14.177
当这个函数成功时，我们会做handle success，我们会创建一个新的handle success函数来处理success。

13079
17:55:14.177 --> 17:55:18.244
这是来自未来的帕特里克回来展示另外一点。

13080
17:55:18.244 --> 17:55:25.836
我知道我提到过，但添加这个on error非常好，冒号error console。

13081
17:55:25.836 --> 17:55:34.170
log error对于任何运行契约函数，甚至是读取，如果任何运行契约函数出错，你不会知道。

13082
17:55:34.170 --> 17:55:40.390
当然要把这个加到所有的运行契约函数中。logerror。

13083
17:55:40.390 --> 17:55:46.355
在上面这里，在返回之前，我们会创建一个新的const句柄success。

13084
17:55:46.355 --> 17:55:54.660
我们说这是一个async函数async函数接受事务作为输入参数。

13085
17:55:54.660 --> 17:55:58.872
记住，你可以把函数变成常数变量。

13086
17:55:58.872 --> 17:56:06.295
我们写入await TX。Wait 1，我们会等待事务通过。

13087
17:56:06.295 --> 17:56:10.721
然后我们会创建另一个函数handhandle new notification dx。

13088
17:56:10.721 --> 17:56:14.660
你们马上就会明白我为什么要这样做。

13089
17:56:14.660 --> 17:56:20.895
我们会说const和Linoone notification，这将是一个同步函数因为我们不需要它是异步的。

13090
17:56:20.895 --> 17:56:25.454
我们会调用这个dispatch，我们会设置这个notification。

13091
17:56:25.454 --> 17:56:29.502
我们会说通知或分派，然后我们会在这里添加参数。

13092
17:56:29.502 --> 17:56:33.395
它接受一个对象作为参数，我们说type info。

13093
17:56:33.395 --> 17:56:39.184
Message是transaction

13094
17:56:39.184 --> 17:56:48.020
complete，标题是TX notification。

13095
17:56:48.020 --> 17:56:53.028
何塞，肖恩，我们会说，顶部是

13096
17:56:53.028 --> 17:56:58.395
然后图标，我们会说一个小铃铛。

13097
17:56:58.645 --> 17:57:03.363
你可以在这里找到所有这些东西，键入图标位置，你可以读到所有不同的参数你可以用它来

13098
17:57:03.363 --> 17:57:08.200
设置handle new notification handle success。

13099
17:57:08.200 --> 17:57:12.626
我们说，一旦交易成功，就输入raffle，调用这个handle

13100
17:57:12.626 --> 17:57:18.195
success函数，它会调用handle new notification。

13101
17:57:18.195 --> 17:57:18.445
好的。

13102
17:57:18.445 --> 17:57:22.359
你会明白为什么我们把它分成两个而不是只处理成功。

13103
17:57:22.359 --> 17:57:23.628
还要做调度。

13104
17:57:23.628 --> 17:57:30.119
当我们按下enter raffle按钮时，我们会调用enter raffle issuccessful，我们会调用handle success。

13105
17:57:30.119 --> 17:57:36.058
我们会等待事务完成，是的，它传递一个参数给handle success函数。

13106
17:57:36.058 --> 17:57:40.118
然后我们要做的是调用handle new notification。

13107
17:57:40.118 --> 17:57:44.171
我们会调度。我们会启动其中一个通知。

13108
17:57:44.171 --> 17:57:46.978
回到这里，点击回车抽奖。

13109
17:57:46.978 --> 17:57:49.478
Metamath会弹出确认。

13110
17:57:49.646 --> 17:57:54.868
在它完成后，我们得到这个奇妙的事务通知，事务完成。

13111
17:57:54.868 --> 17:57:59.201
我们让用户知道，很好，你提交了一个事务。

13112
17:57:59.201 --> 17:57:59.917
伟大的工作。

13113
17:57:59.917 --> 17:58:01.069
这很好。

13114
17:58:01.069 --> 17:58:04.547
我们在这里为用户提供了一些有用的内容。

13115
17:58:04.547 --> 17:58:11.026
现在让我们在这里再加一点这样用户就能知道这个抽奖还发生了什么。

13116
17:58:11.026 --> 17:58:15.712
但是我们需要显示更多的数据，让我们显示一下有多少人参加了这个抽奖。

13117
17:58:15.712 --> 17:58:17.908
这个游戏里有多少人。

13118
17:58:17.908 --> 17:58:19.153
我们可以这样做。

13119
17:58:19.153 --> 17:58:22.449
当然，因为我们有很多玩家的命令。

13120
17:58:22.449 --> 17:58:24.951
我们可能还想获得最近的获胜者。

13121
17:58:24.951 --> 17:58:26.323
我们也可以这样做。

13122
17:58:26.323 --> 17:58:33.083
在上面这里，我们会复制这个get入口费，我们会创建另一个叫做get num players。

13123
17:58:33.083 --> 17:58:37.435
这将调用go back to raffle。soul。

13124
17:58:37.435 --> 17:58:43.301
它会调用get number of players我们把它叫做同样的东西。

13125
17:58:43.301 --> 17:58:47.120
获取玩家数量，我们将调用并获取玩家数量。

13126
17:58:47.120 --> 17:58:48.747
为了储存这个值。

13127
17:58:48.747 --> 17:58:50.441
再来看看顶部。

13128
17:58:50.646 --> 17:58:56.201
我们将复制这一行，粘贴到右边我们将选择非玩家。

13129
17:58:56.201 --> 17:58:58.899
然后我们会写setnum players。

13130
17:58:58.899 --> 17:59:01.917
然后再复制这一行。

13131
17:59:01.917 --> 17:59:05.476
最近的赢家，所以我们用最近的赢家。

13132
17:59:05.646 --> 17:59:11.346
Winner会做Set，最近的Winner，然后我们再复制

13133
17:59:11.346 --> 17:59:17.046
这个，而不是获取数字玩家会做get获取最近的Winner。

13134
17:59:17.046 --> 17:59:21.678
我们称它为，get近期赢家，get近期赢家，

13135
17:59:21.678 --> 17:59:26.521
我们要做的不仅仅是入场费，我们要得到所有东西。

13136
17:59:26.521 --> 17:59:30.704
我们可以说const num players，

13137
17:59:30.704 --> 17:59:35.980
从callequals，我们会做一个权重，得到玩家的数量。

13138
17:59:35.980 --> 17:59:41.754
到字符串，然后我们用setsetnum，玩家会这样做。

13139
17:59:41.754 --> 17:59:45.953
我们会写setnum players, num players from call。

13140
17:59:45.953 --> 17:59:50.545
然后我们还会做const recent winner from

13141
17:59:50.545 --> 17:59:55.286
call这将是await get recent winner。

13142
17:59:55.286 --> 17:59:59.614
我们可能需要把这个用绳子包起来但我觉得我觉得没必要。

13143
17:59:59.614 --> 18:00:02.504
我们将setrecent winner粘贴到这里。

13144
18:00:02.504 --> 18:00:05.697
现在我们有了很多选手，我们又增加了一位最近的冠军。

13145
18:00:05.697 --> 18:00:06.997
让我们回到这里。

13146
18:00:06.997 --> 18:00:08.959
我们要收入场费。

13147
18:00:08.959 --> 18:00:13.334
我们来看看玩家人数。

13148
18:00:13.334 --> 18:00:21.751
我们会增加玩家的数量，我们怎么称呼它?我的天啊，我们叫设置雇主两

13149
18:00:21.751 --> 18:00:30.432
次哦，它叫非玩家，向下滚动玩家将是非玩家，然后我们会选最近的赢家。

13150
18:00:30.647 --> 18:00:33.693
然后我们会加入最近的获胜者。

13151
18:00:33.693 --> 18:00:34.318
太棒了。

13152
18:00:35.647 --> 18:00:36.115
费用为0。

13153
18:00:40.647 --> 18:00:45.563
如果我们继续进入抽奖元数据就会弹出。

13154
18:00:45.647 --> 18:00:46.947
我们去确认一下。

13155
18:00:48.647 --> 18:00:51.066
我们会完成交易的。

13156
18:00:53.647 --> 18:00:55.414
玩家数量已更新

13157
18:00:56.647 --> 18:01:02.721
这有点烦人，让我们再次进入抽奖，我们将确认交易完成。

13158
18:01:02.721 --> 18:01:04.373
但这并没有重现。

13159
18:01:04.373 --> 18:01:04.663
正确的。

13160
18:01:04.663 --> 18:01:07.898
我们想要设置一些东西以便自动渲染。

13161
18:01:07.898 --> 18:01:11.381
猜猜我们要怎么处理我们之前讲过的成功。

13162
18:01:11.381 --> 18:01:16.862
没错，所有这些更新UI的东西，我们都能从使用效果中拉出来。

13163
18:01:16.862 --> 18:01:19.920
所以我们要把它全部复制删除。

13164
18:01:19.920 --> 18:01:23.848
我们要让它成为一个独立的函数，像这样。

13165
18:01:23.848 --> 18:01:28.943
然后在句柄success中，每当成功的事务通过，我们都会更新UI ?因此，

13166
18:01:28.943 --> 18:01:35.555
handle success handled new notification，我们会更新白色。

13167
18:01:35.555 --> 18:01:38.862
现在回到这里，我们进入抽奖。

13168
18:01:38.862 --> 18:01:43.020
让我们确认一下，我们看到我们得到了5，我们得到了transaction Notification。

13169
18:01:43.020 --> 18:01:46.138
现在我们想测试一下，在这里获得一个最近的赢家。

13170
18:01:46.138 --> 18:01:52.203
在我们的硬帽项目中，我们能做的是创建一个新脚本。

13171
18:01:52.203 --> 18:01:56.016
实际上我已经为你们创建了它，它将模拟通灵VRF。

13172
18:01:56.016 --> 18:01:57.760
这是对守门员的嘲笑。

13173
18:01:57.760 --> 18:02:01.548
所有这些都和我们的测试所做的差不多。

13174
18:02:01.548 --> 18:02:08.873
如果您现在想暂停并自己查看它，请在这里暂停并添加这个mock off链，它既是keepers又是VRF。

13175
18:02:08.873 --> 18:02:11.616
或者你可以直接去GitHub回购。

13176
18:02:11.616 --> 18:02:14.448
去GitHub上的第九课复习就可以了。

13177
18:02:14.448 --> 18:02:20.460
它已经在脚本中了到脚本马尔可夫链中，你可以复制粘贴到这里。

13178
18:02:20.460 --> 18:02:22.981
因为我想测试一下最近的赢家。

13179
18:02:22.981 --> 18:02:31.132
在我的智能合约彩票中，我们会做yarn，硬帽运行脚本，斜杠模拟，链破折号测试网

13180
18:02:31.132 --> 18:02:39.494
络本地主机，我们会模拟基本上从维护中选择一个赢家请求ID 1，我们在本地网络上。

13181
18:02:39.494 --> 18:02:41.954
好吧，让我们假设最近的冠军是某某人。

13182
18:02:41.954 --> 18:02:48.093
我们能做的是在这里刷新一下，我们能看到我们更新了一个winner。

13183
18:02:48.093 --> 18:02:48.489
繁荣。

13184
18:02:48.649 --> 18:02:50.225
现在我们要清理UI。

13185
18:02:51.649 --> 18:02:52.165
有几件事。

13186
18:02:53.649 --> 18:02:55.470
这一部分。

13187
18:02:59.649 --> 18:03:05.304
因为它让我有点困惑，这个onsuccess并没有检查交易是

13188
18:03:05.304 --> 18:03:10.960
否有块确认，它只是检查交易是否成功发送到Metamask。

13189
18:03:10.960 --> 18:03:15.601
因此onsuccess检查一个事务是否成功发送了Metamask。

13190
18:03:15.601 --> 18:03:20.454
这就是为什么在另一个函数中，我们用TX。

13191
18:03:20.454 --> 18:03:25.550
wait 1因为这是等待事务被确认的部分。

13192
18:03:25.649 --> 18:03:31.055
现在我们使用Morales来制作一旦我们调用嘲讽脚本，我必须刷新

13193
18:03:31.055 --> 18:03:36.631
浏览器来查看这里的获胜者，对吧，玩家的数量显然被重置为零，这很好。

13194
18:03:36.631 --> 18:03:37.823
这并不理想。

13195
18:03:37.823 --> 18:03:43.377
理想情况下，我们希望UI在某些事件被触发时自动更新。

13196
18:03:43.377 --> 18:03:46.479
在我们的抽奖合同中，我们放出这个事件。

13197
18:03:46.479 --> 18:03:49.993
而不是在我们的代码中等待成功。

13198
18:03:49.993 --> 18:03:54.598
我们可以做的是，我们可以设置一个部分

13199
18:03:54.598 --> 18:03:59.460
来监听被触发的事件，并相应地更新前端。

13200
18:03:59.460 --> 18:04:03.438
有了这些知识，我们还可以监听发出的winner事件。

13201
18:04:03.438 --> 18:04:08.688
我们可以更新我们的前端而不是刷新这是你的提示是的，

13202
18:04:08.688 --> 18:04:14.149
你想看看你现在是否可以添加这个，我强烈建议你这样做。

13203
18:04:14.149 --> 18:04:17.131
我们基本上完成了所有的功能。

13204
18:04:17.131 --> 18:04:22.726
哇，你从这一点中学到了很多东西，对吧?我们学过使用效果使用莫拉莱斯，

13205
18:04:22.726 --> 18:04:28.486
所有这些挂钩，所有这些东西，我们有一个前端很好地处理与智能合约的交互。

13206
18:04:28.486 --> 18:04:30.582
唯一的问题是，它看起来真的很丑。

13207
18:04:30.582 --> 18:04:32.446
这有点恶心。

13208
18:04:32.446 --> 18:04:36.096
让我们让这个看起来好一点。

13209
18:04:36.096 --> 18:04:39.334
在构建这些前端时，有两件事需要考虑。

13210
18:04:39.334 --> 18:04:44.511
还有组件库，比如我们正在使用的web3uitkit，它给我们提

13211
18:04:44.511 --> 18:04:49.857
供组件，给我们提供代码块，比如这个连接按钮它已经为我们格式化了。

13212
18:04:49.857 --> 18:04:55.188
还有一些CSS库可以帮助我们格式化剩下的东西。

13213
18:04:55.188 --> 18:04:57.582
我们正在使用这些组件库中的一个。

13214
18:04:57.582 --> 18:05:02.602
我们还将使用这些格式化库中的一个，我们将要使用的库是tailwind。

13215
18:05:02.602 --> 18:05:06.824
我们使用顺风CSS的原因是它非常流行。

13216
18:05:06.824 --> 18:05:12.846
如果你想学习CSS，有一些很棒的资源你可以用来学习CSS web三所学校是我用过很多次的一个。

13217
18:05:12.846 --> 18:05:19.338
这门课的GitHub repo中会有一个链接这样你就能让你的网站在格式化

13218
18:05:19.338 --> 18:05:25.830
时看起来更漂亮但我们实际上会使用顺风因为它会让我们做CSS的东西更容易。

13219
18:05:25.830 --> 18:05:28.518
因为我们要用下一个Jas的顺风。

13220
18:05:28.650 --> 18:05:32.850
实际上，这里有一个很棒的小指南，安装顺风与下Jas。

13221
18:05:32.850 --> 18:05:36.277
我们基本上会继续做下去。

13222
18:05:36.277 --> 18:05:40.462
此链接可在与本课程相关的GitHub回购中获得。

13223
18:05:40.462 --> 18:05:43.132
我们已经创建了我们的项目我们已经在项目中植入了种子。

13224
18:05:43.132 --> 18:05:50.384
现在我们要安装顺风npm安装破折号D，因为我们使用的是纱线，我们要做

13225
18:05:50.384 --> 18:05:55.716
纱线或者打开这个，绿色的新纱线，添加破折号Dev，

13226
18:05:55.716 --> 18:06:05.317
粘贴这三个在顺风CSS, post CSS和自动修复器这三个将基本组成下一个Jas的顺风。

13227
18:06:05.317 --> 18:06:10.412
一旦我们有了这些，我们基本上会init tailwind并为tailwind创建一个配置文件。

13228
18:06:10.412 --> 18:06:17.175
我们会做yarn tailwind CSS它会做p yarn tailwind CSS init dash p会运行它。

13229
18:06:17.175 --> 18:06:23.481
这将给我们这个post CSS。config。j s和这个tailwind。

13230
18:06:23.481 --> 18:06:30.451
config。j s我们要做的就是点击这个复制按钮，然后更新我们的tailwind。

13231
18:06:30.451 --> 18:06:31.051
配置。

13232
18:06:31.051 --> 18:06:39.234
js的顺风Jas，这样它就会说，所有这些东西，Pages中的任何东西。

13233
18:06:39.234 --> 18:06:39.400
js。

13234
18:06:39.400 --> 18:06:40.811
ts。JSX或TSX。

13235
18:06:40.811 --> 18:06:47.370
这些分量中的任何东西，这两个文件夹中的任何东西都被认为是顺风双位数。

13236
18:06:47.370 --> 18:06:48.973
我们想在这两个文件夹上使用顺风。

13237
18:06:48.973 --> 18:06:53.831
然后我们将把顺风指令添加到全局CSS文件中。

13238
18:06:53.831 --> 18:06:57.976
如果我们返回到styles Global我们会用addtailwind

13239
18:06:57.976 --> 18:07:02.952
base覆盖这里的所有东西并在tailwind utilities中添加顺风组件。

13240
18:07:02.952 --> 18:07:06.184
这使得我们的全局CSS文件使用顺风。

13241
18:07:06.184 --> 18:07:12.880
现在，你会看到一个未知的规则，我们能做的是我们能去组件，我们能做的是我

13242
18:07:12.880 --> 18:07:19.576
们能找到这个post CSS语言支持扩展，粘贴到这里，让我们来安装它。

13243
18:07:19.576 --> 18:07:23.401
现在这些小下划线消失了，这很好。

13244
18:07:23.401 --> 18:07:27.984
现在，像往常一样，我们可以只执行NPM，运行Dev并开始为我们的div添加顺风。

13245
18:07:27.984 --> 18:07:32.714
tailwind所做的是允许我们在div中设置所有

13246
18:07:32.714 --> 18:07:37.635
东西为类名，然后在这些类名中设置一些非常简单的文本。

13247
18:07:37.635 --> 18:07:40.023
让我们来看看智能合约抽签。

13248
18:07:40.023 --> 18:07:41.395
我们只是顺风而行。

13249
18:07:41.395 --> 18:07:43.719
所以它已经更新了一些。

13250
18:07:43.719 --> 18:07:44.989
让我们在这里更新头文件。

13251
18:07:44.989 --> 18:07:45.481
好吧，让我们看看。

13252
18:07:45.481 --> 18:07:48.352
我们想给我们的头球一个顺风的边界。

13253
18:07:48.352 --> 18:07:50.752
我们会快速搜索一下。

13254
18:07:50.752 --> 18:07:56.863
看看边界，我们可以看到所有这些边界，比如边界宽度边界这个边界说我们

13255
18:07:56.863 --> 18:08:03.160
想在底部有一个边界，我们可以看到我们可以在底部有一个边界，就像这样。

13256
18:08:03.160 --> 18:08:06.838
让我们在底部做一个宽度为两个像素的边框。

13257
18:08:06.838 --> 18:08:08.479
我们只计算边界b2。

13258
18:08:08.479 --> 18:08:16.493
所以我要复制边界B为边界b2，我要保存它我们需要做的是我们的CSS和所有生效的东西。

13259
18:08:16.493 --> 18:08:18.524
来吧，把前端给杀了。

13260
18:08:18.652 --> 18:08:19.906
然后我们用纱线戴夫重新运行。

13261
18:08:20.652 --> 18:08:21.152
现在结束。

13262
18:08:21.152 --> 18:08:24.009
让它稍微刷新一下，好，很好。

13263
18:08:24.652 --> 18:08:25.861
这里有一点边界。

13264
18:08:27.652 --> 18:08:29.889
只是还不是很多。

13265
18:08:31.652 --> 18:08:34.152
添加顺风到我去扩展。

13266
18:08:35.652 --> 18:08:36.080
顺风。

13267
18:08:36.080 --> 18:08:37.901
这里有顺风延伸。

13268
18:08:38.652 --> 18:08:40.109
我要在这里加一大堆东西。

13269
18:08:40.652 --> 18:08:44.385
Flex, Flex row。

13270
18:08:44.652 --> 18:08:51.274
我们要做去中心化的彩票，h 1代表头像1。

13271
18:08:51.274 --> 18:08:55.433
用类名=，我们用y破折号。

13272
18:08:55.433 --> 18:09:01.652
我们让它填充form的顶部在X轴4上填充X。

13273
18:09:01.652 --> 18:09:05.329
我们将它设为粗体，并将文本设为3xl大小。

13274
18:09:05.329 --> 18:09:07.152
我们把所有东西都变大。

13275
18:09:07.152 --> 18:09:07.568
酷。

13276
18:09:07.568 --> 18:09:12.861
然后我们再做一个，我们将连接按钮包装在div中。

13277
18:09:12.861 --> 18:09:19.485
我们写入div class name =，然后给它一个自动左距。

13278
18:09:19.485 --> 18:09:20.818
我们还要做py。

13279
18:09:20.818 --> 18:09:24.071
填充y，填充x。

13280
18:09:24.071 --> 18:09:26.200
看看我们做了什么。

13281
18:09:26.200 --> 18:09:26.683
好的。

13282
18:09:26.683 --> 18:09:34.033
如果我们缩小一点，我们可以看到，如果我们把这个也关闭，我们可以看到连接按钮在这边。

13283
18:09:34.033 --> 18:09:35.553
它们就像这样分开了。

13284
18:09:35.553 --> 18:09:36.486
我觉得这看起来不错。

13285
18:09:36.486 --> 18:09:41.166
我们将保留这个现在我们将回到抽签入口，我们

13286
18:09:41.166 --> 18:09:45.846
将稍微改变一下，我们将说div类名= P。

13287
18:09:45.846 --> 18:09:50.081
五，我们会让按钮看起来很漂亮。

13288
18:09:50.081 --> 18:09:54.541
我们说类名= background blue 500。

13289
18:09:54.541 --> 18:10:00.429
鼠标悬停时，它会显示，背景蓝700。

13290
18:10:00.653 --> 18:10:06.319
现在如果我这样说，当我们把鼠标悬停在它上面时，它看起来有点不同，这很好。

13291
18:10:06.319 --> 18:10:13.994
我们设文本为白色，字体为粗体，给它一些白色填充，给它一些x填充，给

13292
18:10:13.994 --> 18:10:21.903
它一个圆角，给它一个左距自动，现在看起来好多了，对吧?这样漂亮多了。

13293
18:10:21.903 --> 18:10:29.938
我们会在这里做一些基本的CSS让它看起来更漂亮一些，但这本身已经让这个彩票按钮看起来更酷了。

13294
18:10:29.938 --> 18:10:32.415
这里有一些我们没有添加的功能。

13295
18:10:32.415 --> 18:10:36.153
我们需要添加一个disabled，就像我们之前做的那样。

13296
18:10:36.153 --> 18:10:42.707
在我们的抽奖中，就像我说的，是加载和抓取。

13297
18:10:42.707 --> 18:10:46.342
我们的事务都没有加载或抓取，我们将禁用它。

13298
18:10:46.342 --> 18:10:51.025
我们说isloading或isfetch这将被禁用。

13299
18:10:51.025 --> 18:10:57.753
对吧?回到前面，点击回车，点击确认，我们可以为它添加CSS。

13300
18:10:57.753 --> 18:11:06.161
但当事务正在加载时，它们将不能再点击按钮，这是我们想要做的另一件事，即加载和取回。

13301
18:11:06.161 --> 18:11:11.838
当它在加载或取回时，我们可能希望它在我们点击它时有一个小的旋转的东西。

13302
18:11:11.838 --> 18:11:13.068
土豆泥就会冒出来。

13303
18:11:13.068 --> 18:11:18.054
我们可以确认，但如果它有一个小旋转的东西会很酷，对吧。

13304
18:11:18.054 --> 18:11:24.082
你通常可以用谷歌来添加旋转之类的东西，你会得到一些东西。

13305
18:11:24.082 --> 18:11:29.654
但是你可以，你可以从我的代码中复制粘贴这个，我会给你展示这一节我是怎么做的。

13306
18:11:29.654 --> 18:11:33.145
我们要说的是，if is loading or is fetch。

13307
18:11:33.145 --> 18:11:39.864
我们会一直使用三元运算符，然后在这里，我们要做一点div。

13308
18:11:39.864 --> 18:11:47.879
否则，我们会为加载或取回做一个不同的div，我们会在这里添加一个小旋转的东西。

13309
18:11:47.879 --> 18:11:54.330
我们要添加类名=。

13310
18:11:54.654 --> 18:11:59.240
如果我们在加载，我们会添加这个小旋转的东西，我马上会给你们展示它是什么样子的。

13311
18:11:59.240 --> 18:12:02.916
如果我们没有加载，我们就会做enter，抽奖。

13312
18:12:02.916 --> 18:12:07.412
我们会回到最前面，看到答案抽奖，我们会点击按钮。

13313
18:12:07.412 --> 18:12:11.130
现在我们有了这个可爱的小旋转装置，确认交易通过。

13314
18:12:11.130 --> 18:12:12.526
所以任何东西都消失了。

13315
18:12:12.654 --> 18:12:12.850
好了。

13316
18:12:12.850 --> 18:12:14.866
我们把它们放在不同的直线上。

13317
18:12:15.654 --> 18:12:20.529
这样做的话，它们

13318
18:12:20.529 --> 18:12:25.404
会在不同的线上。

13319
18:12:25.404 --> 18:12:30.698
现在热潮，入场费，数量玩家最近中奖，一旦抽奖现在就

13320
18:12:30.698 --> 18:12:35.992
会确认交易完成，玩家数量已经上升，我们已经做到了。

13321
18:12:35.992 --> 18:12:37.298
现在看起来好多了。

13322
18:12:37.298 --> 18:12:42.011
它显然不是完美的，但它比我们之前看到的肿块更容易阅读。

13323
18:12:42.011 --> 18:12:48.955
我想给你们看这个的原因是给你们一个基础让这些看起来更好。

13324
18:12:48.955 --> 18:12:52.455
这绝对不是一门CSS课程。

13325
18:12:52.655 --> 18:12:53.173
哦,哇。

13326
18:12:53.173 --> 18:12:55.024
好吧，这太了不起了。

13327
18:12:56.655 --> 18:12:57.311
我们真的很喜欢。

13328
18:12:59.655 --> 18:13:08.018
这很糟糕，Larry，让我们谈谈如何部署它，这部分是可选的，因为我要部署一些B级的东西部署到测试集会花很长时间。

13329
18:13:08.018 --> 18:13:10.691
所以我们要把合同用在B上。

13330
18:13:10.691 --> 18:13:14.690
然后我们将把我们的网站部署到托管提供商。

13331
18:13:14.690 --> 18:13:20.809
首先，让我们简单讲一下托管提供商，如果我们想托管我们刚刚创建的漂亮网站，

13332
18:13:20.809 --> 18:13:26.589
有很多方法可以使用for cell或谷歌Cloud或AWS来部署它。

13333
18:13:26.655 --> 18:13:26.861
荨麻。

13334
18:13:28.655 --> 18:13:31.163
我们可以在不同的地方部署应用程序。

13335
18:13:31.655 --> 18:13:39.479
关于这些，这些都是集中式部署的地方，拥有一个集中式部署应用程序仍然是非常重要的，对吧?如果我

13336
18:13:39.479 --> 18:13:47.474
们再看一遍以太扫描以太扫描是一个集中的应用程序在一天结束的时候，但它仍然是我们经常使用的一个。

13337
18:13:47.474 --> 18:13:50.051
然而，如果我们想要一个去中心化的前端。

13338
18:13:50.051 --> 18:13:51.534
这就有点难了。

13339
18:13:51.534 --> 18:13:56.549
对我们来说更重要的是我们的后端，我们的智能合约是去中心化的，对吧?这是

13340
18:13:56.549 --> 18:14:01.565
最重要的一点，因为这将使用户能够以去中心化的方式与我们的逻辑进行交互。

13341
18:14:01.565 --> 18:14:04.467
但也许我们也希望前端去中心化。

13342
18:14:04.467 --> 18:14:11.262
在某种程度上，我们仍然会使用像VSL这样的集中服务来部署一个应用程序，我将向你们展示为什么

13343
18:14:11.262 --> 18:14:18.058
当我们到达那里的时候，现在有一些特性，如果没有一个真正可靠的集中式后端，它们真的很难实现。

13344
18:14:18.058 --> 18:14:26.229
重要的是要记住我们的后端，我们合同的逻辑是基于去中心化的区块链。

13345
18:14:26.229 --> 18:14:32.369
因此，即使我们将前端托管在一个集中式宿主提供程序上，使用某种

13346
18:14:32.369 --> 18:14:38.714
类型的集中式数据库使前端更易于使用，应用程序的逻辑也是分散的。

13347
18:14:38.714 --> 18:14:40.708
这是最重要的部分。

13348
18:14:40.708 --> 18:14:46.591
我稍后会给你们一些工具，以及如何引入更多这些丰富的特性。

13349
18:14:46.656 --> 18:14:51.600
如果您选择这样做，那么将在前端添加一个集中式组件。

13350
18:14:51.600 --> 18:14:55.703
这是要记住的，取决于你想要怎样的架构。

13351
18:14:55.703 --> 18:15:04.588
所以在这样做的时候，一定要确保后端部署的智能合约是在其中一个区块链上去中心化的。

13352
18:15:04.656 --> 18:15:09.215
现在，我们将在后面的部分中学习一些中心化的方法。

13353
18:15:09.215 --> 18:15:16.539
现在，让我们学习如何以一种更分散的方式部署这个前端。

13354
18:15:16.656 --> 18:15:20.281
我们将要使用的工具叫做IPFS。

13355
18:15:20.656 --> 18:15:23.910
让我稍微解释一下IPFS是如何工作的。

13356
18:15:24.656 --> 18:15:27.881
分布式分散数据结构。

13357
18:15:29.656 --> 18:15:30.124
区块链。

13358
18:15:30.124 --> 18:15:31.670
但它和区块链很相似。

13359
18:15:32.656 --> 18:15:32.956
虽然。

13360
18:15:35.656 --> 18:15:37.740
让我来解释一下这是如何运作的。

13361
18:15:38.656 --> 18:15:42.480
在这个网站上是如何工作的，会有一个链接到这个和这个课程相关的GitHub回购。

13362
18:15:42.480 --> 18:15:44.722
但我们给你我的基本看法。

13363
18:15:44.722 --> 18:15:50.338
我们有代码，或者文件，或者别的什么，我们有一些数据。

13364
18:15:50.338 --> 18:15:57.946
现在我们知道，当你有任何东西的时候，你可以哈希那个东西，你可以哈希那个数据，对吧，所以你可以得到一个唯一的输出。

13365
18:15:57.946 --> 18:16:00.558
这是IPFS做的第一件事。

13366
18:16:00.656 --> 18:16:05.370
它哈希我们的数据得到一个唯一的哈希值，只指向那个数据。

13367
18:16:05.370 --> 18:16:08.465
是的，大量的代码文件，大量的文本。

13368
18:16:08.465 --> 18:16:15.323
是的，你可以把所有这些都编码到一个哈希函数中，你的IPFS节点为你做这个哈希。

13369
18:16:15.323 --> 18:16:20.930
地球上的每一个IPFS节点都有完全相同的哈希函数，有

13370
18:16:20.930 --> 18:16:26.538
点像区块链，对吧，它们都运行相同的规范，相同的规范。

13371
18:16:26.538 --> 18:16:30.721
我们可以哈希IPFS节点上的数据并得到这个唯一的输出。

13372
18:16:30.721 --> 18:16:36.794
我们能做的是将数据或代码，或文件或其他东西固定到节点上，我们有一些数

13373
18:16:36.794 --> 18:16:43.046
据，我们得到它的唯一哈希值，它所做的就是托管这些数据并拥有这些哈希值。

13374
18:16:43.046 --> 18:16:48.312
就是这样，我们的节点连接到其他IPFS节点的网络。

13375
18:16:48.312 --> 18:16:55.657
所以IPFS节点有一个庞大的网络，它们非常轻，比其他区块链节点轻得多。

13376
18:16:55.657 --> 18:16:57.180
他们都互相交谈。

13377
18:16:57.180 --> 18:17:00.088
如果我问网络，嘿，我想得到这个散列。

13378
18:17:00.088 --> 18:17:02.108
所有这些节点会相互通信。

13379
18:17:02.108 --> 18:17:07.588
最终他们会到达我们的节点，说，哦，我找到了一个有这个散列的节点。

13380
18:17:07.657 --> 18:17:08.736
这是与之相关的文件。

13381
18:17:09.657 --> 18:17:16.644
好吧，这有点集中，因为我们在一个节点上有数据，对吧?你是对的，事情是这

13382
18:17:16.644 --> 18:17:23.631
样的，其他节点能做的是他们会说，数据看起来很酷，我想让它保持，他们能做

13383
18:17:23.631 --> 18:17:30.818
的是固定你的散列，固定你的数据，他们会在他们的节点上得到你的数据的副本。

13384
18:17:30.818 --> 18:17:32.950
你可以一直这样做。

13385
18:17:32.950 --> 18:17:40.829
所以你很容易允许整个网络在去中心化的意义上轻松复制任何代码或任何数据。

13386
18:17:40.829 --> 18:17:42.173
它们非常容易向上旋转。

13387
18:17:42.173 --> 18:17:48.973
使用IPFS非常容易，这使得它与区块链截然不同它不能做智

13388
18:17:48.973 --> 18:17:56.017
能合约，没有执行，它只能存储IPFS只能进行去中心化存储。

13389
18:17:56.017 --> 18:18:02.915
现在的问题是为了让我们的数据真正去中心化，需要另一个节点来固定我们的数据，对吧?

13390
18:18:02.915 --> 18:18:13.954
因为如果我们是唯一的IPFS节点有这个散列，它就集中在我们的节点上，如果我们的节点坏了，数据就没了，网络就不能再访问这些数据了。

13391
18:18:13.954 --> 18:18:18.238
我们以后会讨论让别人固定你的数据的策略。

13392
18:18:18.238 --> 18:18:24.948
但就目前而言，这是我们托管数据的一种方式，我们可以发送代码并将其置于去中心化的上下文中。

13393
18:18:24.948 --> 18:18:26.370
不像区块链，

13394
18:18:26.370 --> 18:18:38.229
区块链中的每个节点都有整个区块链的副本IPFS节点可以选择它们想要固定的数据，它们不能执行任何操作。

13395
18:18:38.229 --> 18:18:43.927
你可以有一个IPFS节点，半兆字节，你可以有一个IPFS节点，

13396
18:18:43.927 --> 18:18:49.443
几tb，这取决于节点操作符，有多少数据，他们想固定什么数据。

13397
18:18:49.443 --> 18:18:52.443
现在我们知道了IPFS。

13398
18:18:52.658 --> 18:19:00.447
让我们把这个奇妙的应用程序部署到IPFS中，这样任何人都可以使用它，任何人都可以连接到它。

13399
18:19:00.447 --> 18:19:02.432
只要节点是向上的。

13400
18:19:02.432 --> 18:19:05.496
你准备好了吗?好了，兴奋起来吧。

13401
18:19:05.658 --> 18:19:10.122
我们首先要做的是Manuel Wait，因为我要向你们展示如何安装IPFS。

13402
18:19:10.122 --> 18:19:10.916
并与IPFS合作。

13403
18:19:10.916 --> 18:19:19.824
点击开始，有很多种方式可以安装和使用IPFS，你可以通过桌面应用程序获取它，通过命令行。

13404
18:19:19.824 --> 18:19:24.766
然后我们还可以在浏览器中添加IPFS比如brave

13405
18:19:24.766 --> 18:19:29.708
或者Firefox这个IPFS路由器是自动构建的。

13406
18:19:29.708 --> 18:19:37.651
但如果使用像Chrome这样的东西，你可能需要添加一个小伙伴，因为我们想做的是我们实际上可以使用那

13407
18:19:37.651 --> 18:19:45.594
些小散列作为网站的URL，对吧，所以我们想能够把那个URL放在浏览器中并连接到那个节点或那段代码。

13408
18:19:45.659 --> 18:19:50.309
我们要做的是让你安装IPFS桌面，你要点击它。

13409
18:19:50.309 --> 18:19:53.184
当你这样做的时候，你应该能够打开IPFS。

13410
18:19:53.184 --> 18:19:59.003
现在，如果你安装它，你可能会得到这个小东西，在你上面部分的这个小框。

13411
18:19:59.003 --> 18:20:04.059
否则，您可能可以在IPFS桌面中打开它，并将其视为普通的桌面应用程序。

13412
18:20:04.059 --> 18:20:09.924
一旦你安装了它，你可能会看到IPFS在运行，你可以重启停止，你可

13413
18:20:09.924 --> 18:20:15.790
以做所有这些，我们会到文件部分，我们会看到一个像这样的小弹出框。

13414
18:20:15.790 --> 18:20:21.103
这里有很多东西，因为我用IPFS已经有一段时间了，现在，你可能没有数据。

13415
18:20:21.103 --> 18:20:23.896
我们来导入一些文件。

13416
18:20:23.896 --> 18:20:30.201
也许现在我们只导入。config。js，对吧?没关系，输入点东西就行了。

13417
18:20:30.201 --> 18:20:35.298
在这里，我们有next。config。js或者其他你导入的文件。

13418
18:20:35.298 --> 18:20:38.820
我们能做的就是复制CID。

13419
18:20:38.820 --> 18:20:42.303
我们可以在浏览器中查看。

13420
18:20:42.303 --> 18:20:48.001
如果我们输入IPFS。。斜杠，然后粘贴进去，按回车键，

13421
18:20:48.001 --> 18:20:53.278
我们就能让浏览器访问到实际渲染的IPFS url。

13422
18:20:53.278 --> 18:20:59.709
如果使用brave，你可以使用brave本地IPFS节点或者让我们继续下载这个IPFS伙伴。

13423
18:20:59.709 --> 18:21:05.150
我们会得到IPFS companion，还有Chrome brave的Firefox安装，等等等等。

13424
18:21:05.150 --> 18:21:11.337
我要去Chrome商店为brave下载，我们要点击添加到brave添加扩展。

13425
18:21:11.337 --> 18:21:13.628
但是一旦你下载了它，你会得到像这样的东西。

13426
18:21:13.660 --> 18:21:21.315
甚至在一个小的浏览器上，我们可以看到导入，我们可以看到关于节点的东西，如果我们点击节点，我们会看到非常相似的设置。

13427
18:21:21.315 --> 18:21:27.250
但是现在我们在浏览器中有了同伴，我们可以复制Cid那个散列。

13428
18:21:27.250 --> 18:21:33.755
勇敢，我们可以使用勇敢本地IPFS节点，它会自动被放到文件中。

13429
18:21:33.755 --> 18:21:37.246
现在，如果IPFS同伴对你不起作用，

13430
18:21:37.246 --> 18:21:45.392
你不能看到像谷歌Chrome或其他浏览器里面的URL，你能做的就是使用IPFS网关。

13431
18:21:45.392 --> 18:21:50.274
现在使用网关，实际上并不是直接通过IPFS请求数据，而是通

13432
18:21:50.274 --> 18:21:55.326
过另一个服务器请求数据，而另一个服务器通过IPFS请求数据。

13433
18:21:55.326 --> 18:22:00.088
但如果访问这些文件有问题，可以使用网关。

13434
18:22:00.088 --> 18:22:04.005
我们要做的是HTTPS，

13435
18:22:04.005 --> 18:22:10.535
斜杠IPFS，然后把哈希代码粘贴到这里。

13436
18:22:10.535 --> 18:22:12.802
你就能看到你的档案了。

13437
18:22:12.802 --> 18:22:16.184
如果你这样做，你甚至不需要IPFS陪伴。

13438
18:22:16.184 --> 18:22:18.831
所以我们将把我们的网站部署到IPFS。

13439
18:22:18.831 --> 18:22:23.845
所以任何人都可以把这个钉在，我们现在将有能力

13440
18:22:23.845 --> 18:22:28.860
有一个廉洁的，不可篡改的网站，这真是太棒了。

13441
18:22:28.860 --> 18:22:34.625
我们要先学习如何用错误的方法来做，然后我们要用一个工具让我们做起来容易得多。

13442
18:22:34.660 --> 18:22:38.266
好的，首先，我们来看看我们的网站。

13443
18:22:39.660 --> 18:22:41.437
想要部署到B溜冰场，请随意。

13444
18:22:41.660 --> 18:22:47.406
记住要确保你的合同处理相应的文件更新。

13445
18:22:47.406 --> 18:22:47.744
好的。

13446
18:22:47.744 --> 18:22:51.661
接下来，Jas拥有创建静态网站的能力。

13447
18:22:51.661 --> 18:22:56.818
这是一个很重要的术语我们要做一个静态网站。

13448
18:22:56.818 --> 18:23:02.580
目前，我们不希望我们的网站与任何服务器的东西纠缠在一起。

13449
18:23:02.661 --> 18:23:07.783
我们不希望它与任何服务器的东西纠缠在一起的原因是如果我们的网站与服务器的东西一

13450
18:23:07.783 --> 18:23:13.038
起运行，我们将它部署到IPFS, IPFS没有能力运行任何代码，它只是托管代码。

13451
18:23:13.038 --> 18:23:16.040
如果我们的前端有任何服务器的东西，它就不能工作。

13452
18:23:16.040 --> 18:23:23.582
现在，在它当前的状态下，IPFS无法进入我们的项目并知道该做什么，对吧，它不知道如何进行纱线开发不能进行纱线开发。

13453
18:23:23.582 --> 18:23:27.497
所以我们需要把我们所有的代码放到它的静态等等物中。

13454
18:23:27.497 --> 18:23:30.385
为了做到这一点，我们要做纱线构建。

13455
18:23:30.385 --> 18:23:36.915
如果我们再看一下我们的package。JSON，它附带这个构建，它只会运行下一个构建。

13456
18:23:36.915 --> 18:23:44.693
运行这个构建命令将构建我们的代码，这被称为生产构建，在这里创建一个优化的生产构建。

13457
18:23:44.693 --> 18:23:47.398
我们会得到像这样的东西。

13458
18:23:47.398 --> 18:23:49.168
我们可以看到下面这个点。

13459
18:23:49.168 --> 18:23:53.594
静态的，自动渲染为静态HTML不使用初始道具。

13460
18:23:53.661 --> 18:23:58.902
如果我们使用下一个Jas会附带一些基于服务器的应用程序。

13461
18:23:58.902 --> 18:24:00.350
我们的静态构建不起作用。

13462
18:24:00.350 --> 18:24:07.333
实际上，你会看到，当我们运行yarn时，如果你有非静态的东西，它就会失败。

13463
18:24:07.333 --> 18:24:09.422
所以让我们继续尝试纱线的下一个出口。

13464
18:24:09.422 --> 18:24:13.906
看看它是否失败，它没有失败，我们现在有了一个新文件夹。

13465
18:24:13.906 --> 18:24:19.273
这是我们的文件夹，这是纯静态代码我们可以在IPFS上使用。

13466
18:24:19.273 --> 18:24:24.511
在后面的部分中，我将向您展示当您不使用这些静态内容时它是什么样子的。

13467
18:24:24.511 --> 18:24:27.947
Morales和next Jas都可以选择不使用静态代码。

13468
18:24:27.947 --> 18:24:30.025
我们要记住这一点。

13469
18:24:30.025 --> 18:24:33.695
现在我们有了这个out文件夹，我们可以回到IPFS。

13470
18:24:33.695 --> 18:24:38.599
我们可以导入一个文件夹，我们会导入整个文件夹在这里。

13471
18:24:38.599 --> 18:24:42.062
点击导入按钮，进入文件夹。

13472
18:24:42.062 --> 18:24:46.102
我是在明年的智能合约抽签中选出的。

13473
18:24:46.102 --> 18:24:49.062
现在我们要上传这个到IPFS节点。

13474
18:24:49.062 --> 18:24:51.694
一旦完成，我们会得到这个小的复选标记。

13475
18:24:51.694 --> 18:24:55.407
我们可以浏览IPFS文件，看看这里的输出。

13476
18:24:55.407 --> 18:25:00.950
我们能做的是，把它固定在节点上，我们把它固定在本地节点上。

13477
18:25:00.950 --> 18:25:06.339
现在一旦它启动了，我们可以复制CID，回到勇敢或铬或其他。

13478
18:25:06.339 --> 18:25:11.989
输入IPFS冒号/斜杠，粘贴进去。

13479
18:25:11.989 --> 18:25:17.017
我们马上就进入了浏览器中的智能合约抽奖。

13480
18:25:17.017 --> 18:25:24.672
我们看到嗨来自彩票，没有检测到抽奖地址，因为现在我设置我的方法是它只与我们本地的安全帽工

13481
18:25:24.672 --> 18:25:32.328
作，让我们连接我们的Metamask我们点击连接按钮，连接，瞧，我们又回到了原来的地方。

13482
18:25:32.328 --> 18:25:38.758
但是由于我们的数据存储在IPFS中，只要我们的节点运行确认，我们就可以进入抽奖。

13483
18:25:38.758 --> 18:25:42.912
我们可以看到我们在本地浏览器中得到了什么。

13484
18:25:42.912 --> 18:25:46.349
这是惊人的。

13485
18:25:46.662 --> 18:25:51.793
现在我已经向您展示了如何做到这一点，这是将代码添加到IPFS的手动方法。

13486
18:25:51.793 --> 18:25:58.412
让我给你们展示一下将代码添加到IPFS的更简单的方法我们将访问这个叫做fleek HQ的网站。

13487
18:25:58.412 --> 18:25:59.537
快去吧。

13488
18:25:59.537 --> 18:25:59.724
有限公司

13489
18:25:59.724 --> 18:26:00.719
说到这里，

13490
18:26:00.719 --> 18:26:09.876
我要关掉我的IPFS伴注因为使用brave时有些奇怪的地方现在我们是here@flickr。

13491
18:26:09.876 --> 18:26:10.400
fleek。

13492
18:26:10.400 --> 18:26:16.803
Co使将网站和应用程序部署到新的开放网络变得容易，无需许可，无需信任，不受审查等。

13493
18:26:16.803 --> 18:26:20.663
我喜欢把它看作是我们网站的自动部署。

13494
18:26:20.663 --> 18:26:24.433
此外，它还做了一些事情来帮助解决这个问题。

13495
18:26:24.433 --> 18:26:28.372
我讲的是如何让其他节点固定我们的数据。

13496
18:26:28.372 --> 18:26:30.098
这对我们很有帮助。

13497
18:26:30.098 --> 18:26:31.646
我来给大家演示一下。

13498
18:26:31.646 --> 18:26:33.324
让我们开始吧，我们来注册。

13499
18:26:33.324 --> 18:26:35.968
为什么你不知道呢，你可以在GitHub上登录。

13500
18:26:35.968 --> 18:26:39.996
如果你有GitHub，一定要在这里用GitHub登录。

13501
18:26:39.996 --> 18:26:45.012
因为我们将使用GitHub来帮助我们自动部署。

13502
18:26:45.012 --> 18:26:47.741
所以我们将授权舰队与我们的GitHub工作。

13503
18:26:47.741 --> 18:26:51.598
你已经授权了你的GitHub，让我们继续添加一个新的网站或添加新的网站。

13504
18:26:51.598 --> 18:26:56.469
现在我们可以使用舰队来自动部署网站，一旦我们把它们推送到我们的GitHub。

13505
18:26:56.469 --> 18:26:59.694
所以我们可以再次来到我们的GitHub。

13506
18:26:59.694 --> 18:27:03.072
点击加号按钮，我们会新建一个仓库。

13507
18:27:03.072 --> 18:27:08.951
我们将称之为Jas智能合约，抽奖免费代码营。

13508
18:27:08.951 --> 18:27:13.452
我们将使它公开，创建存储库。

13509
18:27:13.452 --> 18:27:16.329
让我们把所有这些代码推到GitHub。

13510
18:27:16.329 --> 18:27:18.281
我们以前做过一次，再来一次。

13511
18:27:18.281 --> 18:27:22.423
我们用gitadd，我们用一个点，

13512
18:27:22.423 --> 18:27:29.490
然后我们用gitcommit - m，比如初始提交之类的。

13513
18:27:29.490 --> 18:27:33.478
我们输入gitremote,

13514
18:27:33.478 --> 18:27:40.600
addorigin，然后抓取URL，粘贴到这里。

13515
18:27:40.600 --> 18:27:44.818
然后我们写gitpush origin, main。

13516
18:27:44.818 --> 18:27:49.464
现在我们回到我们的应用程序，在这里我们可以做的是回到我们的fleek。

13517
18:27:49.464 --> 18:27:53.413
连接到GitHub，我们会说，only select

13518
18:27:53.413 --> 18:28:00.401
repository，我们只会做这个next js应用，我们会安装一个Authorize。

13519
18:28:00.401 --> 18:28:01.712
授权好了。

13520
18:28:01.712 --> 18:28:08.351
现在我们要选择一个回购我们已经选择了一个回购，我们要选择这个应用程序。

13521
18:28:08.351 --> 18:28:10.926
我们将使用IPFS作为我们的托管服务。

13522
18:28:10.926 --> 18:28:13.378
现在我们要在这里添加我们的信息。

13523
18:28:13.378 --> 18:28:15.397
我们要用主分支。

13524
18:28:15.397 --> 18:28:16.463
这是回购。

13525
18:28:16.463 --> 18:28:20.276
我们的框架会是下一个Jas。

13526
18:28:20.276 --> 18:28:22.130
我们接下来做fleek。

13527
18:28:22.130 --> 18:28:24.008
Jas，我们用的是纱线。

13528
18:28:24.008 --> 18:28:30.264
我们会做yarn install，然后yarn run build，然后yarn run export。

13529
18:28:30.264 --> 18:28:36.125
如果你想，你也可以只做纱线，纱线构建和纱线运行输出，这是一样的。

13530
18:28:36.125 --> 18:28:44.760
发布目录会被取出然后我们点击Deploy site, yarn，下一个export，这是最后一个命令，不是yarn，是run, export。

13531
18:28:44.760 --> 18:28:48.138
事故做错了，你去检查一下部署。

13532
18:28:48.138 --> 18:28:55.356
点击这个，进入部署设置，然后编辑设置，然后把它改为yarn。

13533
18:28:55.356 --> 18:28:57.017
接下来，导出保存。

13534
18:28:57.017 --> 18:29:04.914
然后我们会回到部署并触发部署，如果你做错了这只是一个学习的机会让你知道部署后设置在哪里。

13535
18:29:04.914 --> 18:29:12.140
这个会做的是部署，它会运行这三个命令yarn build, yarn export，它会运行所有东西。

13536
18:29:12.140 --> 18:29:15.051
然后它将在IPFS上为我们两个部署一个站点。

13537
18:29:15.051 --> 18:29:21.975
它会给我们一个常规的URL我们可以用它来做规范。

13538
18:29:21.975 --> 18:29:29.772
当这个部署时，你会在下面看到我们在交易提议中有一个叫做file coin di D的东西Cid IPFS。

13539
18:29:29.772 --> 18:29:32.936
就像我说的，我们需要其他人来管理节点。

13540
18:29:32.936 --> 18:29:39.931
文件币实际上是一个区块链，它可以帮助您固定数据，并使用去中心化存储来实现这一点。

13541
18:29:39.931 --> 18:29:47.321
fleek帮助你创建这些交易，帮助你用这个文件币固定你的数据区块链文件币绝对是一个值得一看的。

13542
18:29:47.321 --> 18:29:50.310
过了一段时间，你可能要等一会儿。

13543
18:29:50.310 --> 18:29:55.206
一旦完成，得到一个部署的小网站，我们回到托管，

13544
18:29:55.206 --> 18:30:00.315
我们点击我们的东西我们可以看到这里有一个小网站。

13545
18:30:00.315 --> 18:30:01.742
如果我们点击它，

13546
18:30:01.742 --> 18:30:10.488
我们会得到一个正常的链接和网站交互的URL，你甚至会看到这个小IPFS它会连接到你的IPFS节点。

13547
18:30:10.488 --> 18:30:16.527
另外，我们向下滚动到这里我们能看到当前的IPFS哈希，我们可以

13548
18:30:16.527 --> 18:30:22.566
把它插入Bada bing，我们有一个IPFS部署的应用程序。

13549
18:30:22.665 --> 18:30:27.465
现在酷的是，假设我做了一些改变，你知道，我将去彩票入口。

13550
18:30:27.465 --> 18:30:33.923
我要做的是，滚动到底部最近的获奖者，我要新建一个div。

13551
18:30:33.923 --> 18:30:40.198
关闭div，我们保存gteadd。gitcommit -

13552
18:30:40.198 --> 18:30:46.474
m，添加一个。gtepush origin mean。

13553
18:30:46.665 --> 18:30:49.798
在GitHub中，我们会刷新，添加一个。

13554
18:30:50.665 --> 18:30:53.353
最近加了一个，回去看看fleek。

13555
18:30:54.665 --> 18:31:02.126
点击我们刚刚做的部分进入部署，你会看到一个新的部署正在进行。

13556
18:31:02.126 --> 18:31:07.288
它会自动部署你的新网站，它会自动为你的新数据创建一个新的IPFS散列。

13557
18:31:07.288 --> 18:31:12.327
但是，它还是会在这个神圣的鸟上，你知道，不管你的URL是什么。

13558
18:31:12.327 --> 18:31:15.117
这只是一个IPSs的路由器。

13559
18:31:15.117 --> 18:31:19.569
没有IPFS连接的人也可以连接到这个。

13560
18:31:19.569 --> 18:31:28.447
现在我的应用完成了，用fleek自动推送，我们可以看到我的应用中post了什么。

13561
18:31:28.447 --> 18:31:34.536
现在，就像我说的，文件币不会成为一种技术，我们会深入介绍我们自己。

13562
18:31:34.536 --> 18:31:38.749
但就像我刚才说的，IPFS确实有这个限制。

13563
18:31:38.749 --> 18:31:47.411
它没有数据持久性，你必须让人固定你的数据，以便它保持分布式和去中心化。

13564
18:31:47.411 --> 18:31:53.416
File coin是一个专门用于保存这些数据的区块链，既分散又持久。

13565
18:31:53.416 --> 18:31:56.072
为了让我们更好地理解文件币。

13566
18:31:56.072 --> 18:31:58.563
我们请到了阿里来给我们概述一下。

13567
18:31:58.666 --> 18:31:59.838
把它拿走，艾莉。

13568
18:32:00.666 --> 18:32:07.599
我是filecoin基金会的开发人员倡导者，该基金会与协议实验室和IPFS密切合作。

13569
18:32:07.666 --> 18:32:12.142
提醒一下，协议实验室是我们的研发部门。

13570
18:32:13.666 --> 18:32:18.607
为真正开放和民主的互联网和网络创造工具和技术。

13571
18:32:18.607 --> 18:32:25.993
它正在构建一些基本的工具，比如IPFS和文件币，这是两个独立的项目来实现它。

13572
18:32:25.993 --> 18:32:33.208
希望今天，因为你们是来建设的，我想传授给你们开始这两个项目所需的知识和工具。

13573
18:32:33.208 --> 18:32:42.156
所以，任何在这个生态系统或科技领域摸混过的人都会知道，数据是我们日常生活中绝对必不可少的一部分。

13574
18:32:42.156 --> 18:32:47.299
毫不奇怪，这也是网络三和网络一中一个增长非常快的领域，

13575
18:32:47.299 --> 18:32:52.253
这是最基本的一点，也是去中心化网络栈的基本需求之一。

13576
18:32:52.253 --> 18:32:58.705
所以目前的集中化模式，基本上是由于互联网上缺乏身份层，只有少

13577
18:32:58.705 --> 18:33:05.158
数几家大公司提供存储，只有少数实体为授权目的保存我们的数据。

13578
18:33:05.158 --> 18:33:11.907
这是一个明显的问题，作为数据挖掘的攻击载体，没有数据，就

13579
18:33:11.907 --> 18:33:18.899
会通过不安全的服务泄露给第三方，同时也会产生数据弹性问题。

13580
18:33:18.899 --> 18:33:24.070
因此，每次这些公司的服务器出现故障，整个服务就会瘫痪，我们肯定看到过这种情况。

13581
18:33:24.070 --> 18:33:30.669
这就引出了一个问题，为什么我们不在设计网页的时候就考虑到我们需

13582
18:33:30.669 --> 18:33:37.268
要的自主性和弹性呢?我们如何以一种既符合互联网作为知识共享和合

13583
18:33:37.268 --> 18:33:43.867
作的开放场所的最初愿景，又符合web三的使命的方式来存储数据。

13584
18:33:43.867 --> 18:33:47.479
这些就是我们用IPFS和文件币解决的核心问题。

13585
18:33:47.479 --> 18:33:54.602
首先，IPFS是一个用于存储和访问文件、文件夹、网站、应用程序和数据的分布式系统。

13586
18:33:54.667 --> 18:33:59.438
它被设计成即使在行星之间的网络中也能工作，所以它是分布式

13587
18:33:59.438 --> 18:34:04.381
的，它没有中央权威服务器，它被设计成首先离线，以适应环境。

13588
18:34:04.381 --> 18:34:07.446
它也不仅仅是另一个点对点网络的花哨名称。

13589
18:34:07.446 --> 18:34:14.042
因为IPFS协议的优点是它使用标准来寻址网络上的内容。

13590
18:34:14.042 --> 18:34:21.458
IPFS是独特的，因为它不使用传统的方法，我们可能从网上熟悉，比如那些位

13591
18:34:21.458 --> 18:34:29.081
置部分，指向一个特定的HTTP地址，你的内容可能可用，也可能不存储在那里。

13592
18:34:29.081 --> 18:34:35.326
IPFS使用内容寻址，所以内容寻址意味着每一块数据，每一个模因，甚

13593
18:34:35.326 --> 18:34:41.572
至整个文件系统都有它自己独特的可加密验证的指纹，你可以这么称呼它。

13594
18:34:41.572 --> 18:34:50.340
因此，如果您更改了主图像的一个像素，那么与它相关的内容ID或Cid也会更改。

13595
18:34:50.340 --> 18:34:54.068
重要的是，这个哈希函数也是可升级的。

13596
18:34:54.068 --> 18:34:59.702
假设量子计算突破了当前的安全哈希算法，我们可以升级我们使用的标准。

13597
18:34:59.702 --> 18:35:04.810
这意味着您将始终获得由IPFS返回的相同内容。

13598
18:35:04.810 --> 18:35:06.635
正如你所期望的那样。

13599
18:35:06.635 --> 18:35:11.551
所以这是非常重要的，因为当你不需要关心数据从哪里

13600
18:35:11.551 --> 18:35:16.468
来的时候，你就向大规模分布式存储系统开放了网络。

13601
18:35:16.468 --> 18:35:18.068
你好,权力下放。

13602
18:35:18.068 --> 18:35:23.068
所以现在我们有了一个非常重要和有价值的协议，可以实现大规模分发。

13603
18:35:23.068 --> 18:35:27.603
它还提供了数据的可验证性，以服务和检索web上的内容。

13604
18:35:27.603 --> 18:35:33.244
这不仅仅是针对web 3，而是针对所有的web或技术用例。

13605
18:35:33.244 --> 18:35:41.001
问题是，这也是早期互联网也面临的问题，谁来确保网络上所有数据的持久性和持久性。

13606
18:35:41.001 --> 18:35:48.603
所以，除非你每天24小时都在运行自己的节点，或者你的内容非常受欢迎，或者其他节点决定无私地存储你的数据。

13607
18:35:48.603 --> 18:35:56.110
因为我认为这很重要，那么这些数据就会变得不可靠因为它们不再活跃地驻留在网络的任何节点上。

13608
18:35:56.110 --> 18:36:02.600
因此，为了避免这种情况，你也可以求助于固定服务，你可以付费保存你的内容的副本。

13609
18:36:02.668 --> 18:36:07.356
不幸的是，这样做的问题是，我们正朝着数据集中化的方向发展。

13610
18:36:07.356 --> 18:36:13.630
我们用这个解决方案创建了新的数据仓库，失去了我们正在寻找的不信任和弹性。

13611
18:36:13.669 --> 18:36:22.106
在文件币出现之前，这是一个糟糕的解决方案，这也是它们最初出现的原因，但我们想要一个更好的解决方案。

13612
18:36:22.106 --> 18:36:24.469
这就是文件币的用武之地。

13613
18:36:24.469 --> 18:36:31.068
到目前为止，货币架构设计利用加密经济激励模型和

13614
18:36:31.068 --> 18:36:37.954
加密证明，以确保数据持久存储，高度可靠和可验证。

13615
18:36:37.954 --> 18:36:42.294
它还使用这些加密证明来支持基于智能合约的持久性。

13616
18:36:42.294 --> 18:36:47.439
这意味着它被设计成像数据所有者希望的那样永久。

13617
18:36:47.439 --> 18:36:49.454
这是你的数据，所以是你的选择。

13618
18:36:49.454 --> 18:36:53.097
它还旨在实现互联网规模的容量。

13619
18:36:53.097 --> 18:37:01.606
它是目前世界上最大的分布式存储网络拥有超过1800万兆兆字节的可用容量，这

13620
18:37:01.606 --> 18:37:10.346
显然是135份欧盟核项目的拷贝，欧洲核子研究中心的数据，这是一种有趣的事实。

13621
18:37:10.346 --> 18:37:19.259
由于市场经济的原因，它的文件币也被设计成在定价上保持高度竞争。

13622
18:37:19.259 --> 18:37:21.914
这要归结于存储协议。

13623
18:37:21.914 --> 18:37:26.135
因此，为了使这个网络可行，filecoin使用存储协议。

13624
18:37:26.135 --> 18:37:33.446
其中包括两种主要的共识机制，确保对系统中良好参与者的奖励和对不良参与者的惩罚。

13625
18:37:33.446 --> 18:37:40.356
因此，当您与一个或多个存储提供者达成协议以存储重要数据时，提供者会生成复制证明。

13626
18:37:40.356 --> 18:37:45.461
因此，这证明了存储提供者在一段时间内存储原

13627
18:37:45.461 --> 18:37:50.566
始数据的唯一副本，以确保该数据被持久保存。

13628
18:37:50.566 --> 18:37:58.447
这些存储提供商必须证明他们仍然拥有该客户端数据的随机子集，并且他们创建了空间时间的证明。

13629
18:37:58.447 --> 18:38:05.161
这些证明这个时空的证明是存储在区块链上的。

13630
18:38:05.161 --> 18:38:07.936
任何人在任何时候都可以验证这是正确的。

13631
18:38:07.936 --> 18:38:13.410
它也构成了奖励或惩罚矿工的机制，因为你必须

13632
18:38:13.410 --> 18:38:18.884
把Phil放在网络上，才能成为存储提供商。

13633
18:38:18.884 --> 18:38:25.911
因此，当一个存储协议到期时，用户可以选择让它到期或续签协议。

13634
18:38:25.911 --> 18:38:30.336
如果您选择续订，那么提供者将再次出价托管该内容。

13635
18:38:30.336 --> 18:38:35.741
这就创造了一个有效的定价市场一个持续有效的定价市场。

13636
18:38:35.741 --> 18:38:37.455
它甚至可以变成负数。

13637
18:38:37.455 --> 18:38:42.525
因此，如果是重要的数据集，存储提供商甚至可以付钱

13638
18:38:42.525 --> 18:38:47.807
给你存储数据，因为文件币基金会也提供了一些块奖励。

13639
18:38:47.807 --> 18:38:55.873
这些机制不仅内置了数据的持久性，还内置了数据的时限和主权，所以这是你的数据，是你的选择。

13640
18:38:55.873 --> 18:38:59.073
您可以决定将数据存储5分钟还是500年。

13641
18:38:59.073 --> 18:39:03.776
你也可以选择你想要多少弹性的数据或者你想

13642
18:39:03.776 --> 18:39:08.479
要多少副本的数据以及用什么存储给提供商。

13643
18:39:08.479 --> 18:39:13.231
这让你能够遵守GDPR等法规。

13644
18:39:13.231 --> 18:39:20.373
在这个生态系统中，有越来越多的工具，比如低语位屏，可以让你进行这种过滤。

13645
18:39:20.373 --> 18:39:25.037
但它也保证了你的数据，你知道，如果一

13646
18:39:25.037 --> 18:39:29.961
个存储器坏了，肯定不会有10个都坏了。

13647
18:39:29.961 --> 18:39:34.580
这也是你恢复力的保证。

13648
18:39:34.671 --> 18:39:37.583
这就是为什么IPFS和文件币是很好的互补。

13649
18:39:37.583 --> 18:39:43.107
因此，IPF s为你提供了内容寻址的好处，file coin为你提供了持

13650
18:39:43.107 --> 18:39:48.785
久的保证，即使你的计算机或你最喜欢的IPFS固定服务消失了，内容也会持久。

13651
18:39:48.785 --> 18:39:55.355
作为对这些概念的最后一个简要说明，正如我所提到的，IPFS和文件币是独立的项目。

13652
18:39:55.355 --> 18:40:01.153
因此，IPFS是一个很像HTTP的协议，而文件币是一个区块链。

13653
18:40:01.153 --> 18:40:06.705
因此，IPFS也是存储层不可知的，您可以将它与您所选择的存储层结合起来。

13654
18:40:06.705 --> 18:40:11.894
虽然文件币是专门为补充它而设计的，我们认为这是一个很好的选择，

13655
18:40:11.894 --> 18:40:16.750
但你也可以将你的IPFS数据存储在云或其他存储解决方案中。

13656
18:40:16.750 --> 18:40:21.852
希望你已经对为什么要使用IPFS和文件币有了一个很好的基线。

13657
18:40:21.852 --> 18:40:28.197
对于那些喜欢挑战，对IPFS的基本协议和代码以及文件币感兴

13658
18:40:28.197 --> 18:40:34.542
趣的工程师来说，这对一般用户来说并不容易，我鼓励你们去看看

13659
18:40:34.542 --> 18:40:40.889
项目文档，获得用于扩展这些开源项目的hub和一些相关拨款。

13660
18:40:40.889 --> 18:40:48.380
如果你想了解更多细节，深入研究IPFS和文件币背后的代码，这个网站很不错。

13661
18:40:48.380 --> 18:40:49.867
并将其扩展。

13662
18:40:49.867 --> 18:40:52.956
对于那些只想在盒子里建造的人。

13663
18:40:52.956 --> 18:40:55.479
这是我经常加入的一个阵营。

13664
18:40:55.479 --> 18:41:00.132
我想谈谈一些开发工具和存储助手，它们使您可以轻松上手。

13665
18:41:00.132 --> 18:41:03.441
首先，Flake是我最喜欢的IPFS开发工具之一。

13666
18:41:03.441 --> 18:41:10.238
projectflake是一个CI CD工具你可以用它来免费部署你的应用就像

13667
18:41:10.238 --> 18:41:17.214
你使用一些你可能熟悉的网络工具一样简单，比如Netlify oversell。

13668
18:41:17.214 --> 18:41:21.817
不过，最大的区别是fleek使用IPFS托管您的站点或应用程序。

13669
18:41:21.817 --> 18:41:24.901
它甚至在其平台上提供AES域路由。

13670
18:41:24.901 --> 18:41:33.606
所以如果你在部署一个前端应用，我会鼓励你使用fleek让它更分布式，而不是一些传统的web 2工具。

13671
18:41:33.672 --> 18:41:35.395
这很简单，我保证。

13672
18:41:37.672 --> 18:41:43.564
是非功能性存储，将非功能性元数据永久持久地存储，正如你可能已经知道

13673
18:41:43.564 --> 18:41:49.636
的，这对于保持非功能性t的主要价值主张是不可或缺的，然后是可替代性。

13674
18:41:49.636 --> 18:41:55.100
因此，如果您不将数据存储在链上(这显然对大文件来说

13675
18:41:55.100 --> 18:42:00.783
在经济上是不可行的)，那么这正是NF T存储的用途。

13676
18:42:00.783 --> 18:42:05.542
因此，它被专门创建为一种公共产品，用于归档和持久化NF - T数据。

13677
18:42:05.542 --> 18:42:06.380
所以它是免费的。

13678
18:42:06.380 --> 18:42:10.794
它首先为这个元数据创建一个IPFS

13679
18:42:10.794 --> 18:42:16.768
Cid，然后与文件币存储提供者进行自动处理。

13680
18:42:16.768 --> 18:42:19.982
因此，它至少与八个存储提供商一起实现了这一点。

13681
18:42:19.982 --> 18:42:23.442
所以是8倍的冗余，而且是在多代人的时间框架内完成的。

13682
18:42:23.442 --> 18:42:25.917
所以它会自动更新这些交易。

13683
18:42:25.917 --> 18:42:28.376
因为它是公共产品，所以都是免费的。

13684
18:42:28.376 --> 18:42:33.688
它也非常容易使用，因为你只需要因为它是一个JavaScript服务。

13685
18:42:33.688 --> 18:42:38.680
你只需要把它作为NPM包或JavaScript

13686
18:42:38.680 --> 18:42:43.672
库导入然后调用API NFT点存储处理剩下的。

13687
18:42:43.672 --> 18:42:48.513
对于不是NF T元数据的数据，我们建立了web 3点

13688
18:42:48.513 --> 18:42:53.355
存储，web 3点存储旨在给你同样的web 2好处。

13689
18:42:53.355 --> 18:42:57.012
类似于ntf点存储，使用起来非常简单。

13690
18:42:57.012 --> 18:43:02.445
它有JavaScript和客户端库。

13691
18:43:02.673 --> 18:43:07.771
当你知道IPFS和去中心化存储和IPFS内容寻址的

13692
18:43:07.771 --> 18:43:12.869
文件币的力量时，它有一万亿又一万亿的免费存储空间。

13693
18:43:12.869 --> 18:43:16.983
如果你不只是想存储和获取元数据，可以试试这个。

13694
18:43:16.983 --> 18:43:19.534
下一个工具更高级一些。

13695
18:43:20.673 --> 18:43:25.704
它被称为textil Palghat gate，它是为更高级的开发

13696
18:43:25.704 --> 18:43:30.735
人员或那些寻找更灵活的与IPFS实时点对点和文件币交互的人设计的。

13697
18:43:30.735 --> 18:43:35.101
它是一个包裹在文件币和IPFS节点周围的Docker容器。

13698
18:43:35.101 --> 18:43:39.731
它给了你很多选项来配置它是一个小的选择和扩展功能。

13699
18:43:39.731 --> 18:43:45.863
它还提供了一些连接到几个层的桥梁，可能会引起开发人员的兴趣。

13700
18:43:45.863 --> 18:43:52.043
这里还有一个，我先说你们需要一张邀请函这是ESRI技术。

13701
18:43:52.043 --> 18:43:56.266
所以它是为那些想要存储真正有意义的公共数据的人准备的。

13702
18:43:56.266 --> 18:44:00.900
它目前处于alpha模式，就像我说的，它需要一个

13703
18:44:00.900 --> 18:44:05.535
邀请，因为它是作为一个公共产品专门存储重要信息。

13704
18:44:05.535 --> 18:44:12.266
如果你在这张幻灯片上有用例，请随时联系我们。

13705
18:44:12.266 --> 18:44:15.825
我要提到的最后一个工具是轨道dB。

13706
18:44:15.825 --> 18:44:22.119
这么多从web 2来到web 3空间的人经常在寻找我们在

13707
18:44:22.119 --> 18:44:28.639
传统计算中习惯使用的关系数据库，除了去中心化或分布式格式。

13708
18:44:28.639 --> 18:44:31.042
这不是一个简单的问题。

13709
18:44:31.042 --> 18:44:33.568
所以欧巴对我来说目前正在积极开发中。

13710
18:44:33.674 --> 18:44:41.351
因为这不是一个容易解决的问题，这并不是一个理想的解决方案，对于那些寻求开箱即用体验的人来说。

13711
18:44:41.351 --> 18:44:45.460
但如果你在寻找类似的东西，试试dB轨道。

13712
18:44:45.460 --> 18:44:51.108
生态系统中还有其他一些工具利用IPFS和文件币，包

13713
18:44:51.108 --> 18:44:56.983
括陶瓷，它类似于纺织电源门，除了它使用去中心化身份。

13714
18:44:56.983 --> 18:45:04.581
Lighthouse是文件驱动器，甚至Morales也有IPFS API，你也可以去看看。

13715
18:45:04.674 --> 18:45:08.601
所以存储是一个技术系统的基本组成部分。

13716
18:45:08.601 --> 18:45:11.726
这里有很多用例。

13717
18:45:11.726 --> 18:45:17.377
希望我已经为你们提供了一些开始使用IPFS和文件Goyt所需的知识和工具。

13718
18:45:17.377 --> 18:45:21.388
并真正实现强大的分布式应用。

13719
18:45:21.388 --> 18:45:25.768
现在还有一个工具也在积极开发中。

13720
18:45:25.768 --> 18:45:31.424
所以如果你仔细看这个图，你可能会注意到在逻辑层的末尾有一个不熟悉的logo。

13721
18:45:31.424 --> 18:45:34.397
这是文件币虚拟机的标志。

13722
18:45:34.397 --> 18:45:37.448
所以FBM将在今年年底推出。

13723
18:45:37.448 --> 18:45:39.577
我们对此非常兴奋。

13724
18:45:39.577 --> 18:45:45.396
它将允许智能合约，合约的使用结合存储数据的托

13725
18:45:45.396 --> 18:45:51.480
管，负载，计算能力和存储能力，也将兼容EVM。

13726
18:45:51.480 --> 18:45:58.074
就像我说的，我们对我们将从这个项目中看到的各种用例非常兴奋。

13727
18:45:58.074 --> 18:46:02.372
你也可以在这个网站上跟着看。

13728
18:46:02.372 --> 18:46:05.957
希望我已经给了你们开始使用IPFS所需的所有工具。

13729
18:46:05.957 --> 18:46:07.013
和文件硬币。

13730
18:46:07.013 --> 18:46:14.626
如果你确实需要更多的资源或想参与其中，我们有proto School，这是一个去中心化web协议的交互式教程。

13731
18:46:14.675 --> 18:46:20.675
也有NFT, school dot Dev，或者加入一个黑客松，看看我们的黑客松。

13732
18:46:20.675 --> 18:46:21.119
filecoin。

13733
18:46:21.119 --> 18:46:24.029
IO页面，我们参与的所有最新的黑客马拉松。

13734
18:46:24.029 --> 18:46:30.191
如果你真的想在IPFS中深入挖掘和构建工具，

13735
18:46:30.191 --> 18:46:36.353
文件币或构建一个很酷的项目，检查我们的拨款选

13736
18:46:36.353 --> 18:46:42.515
项以及，与此同时，所有请学习长期构建和繁荣。

13737
18:46:42.675 --> 18:46:45.295
我们在这一节学到了很多。

13738
18:46:45.295 --> 18:46:46.329
就是这样。

13739
18:46:46.675 --> 18:46:50.013
让我们总结一下我们所学到的所有神奇的东西。

13740
18:46:50.013 --> 18:46:56.165
然后我们会讲到它的TypeScript版本因为TypeScript版本肯定有点不同。

13741
18:46:56.165 --> 18:46:56.928
我们来谈谈。

13742
18:46:56.928 --> 18:46:59.435
好的，首先，我们了解了下一个Jas。

13743
18:46:59.435 --> 18:47:02.379
我们知道我们可以用next Jas做一个应用。

13744
18:47:02.379 --> 18:47:09.045
这个框架可以让我们很容易地构建强大的前端和全栈应用程序。

13745
18:47:09.045 --> 18:47:16.110
我们学习了下一个JS项目的布局，我们在components文件夹中添加了组件，这基本上

13746
18:47:16.110 --> 18:47:23.175
是JavaScript和HTML的极简块，我们可以使用这些组件模块化和创建我们的网站。

13747
18:47:23.175 --> 18:47:28.982
Constants是一个可以放置常量变量的文件夹，Node modules是Node modules。

13748
18:47:28.982 --> 18:47:30.043
取出文件夹。

13749
18:47:30.043 --> 18:47:38.933
当我们将所有代码导出到静态示例时会发生什么呢，页面基本上是我们网站的路由或不同页面，所有东西都通过app。

13750
18:47:38.933 --> 18:47:39.105
js。

13751
18:47:39.105 --> 18:47:46.263
Public是一些公共的东西，样式适用于任何CSS或应用的样式。

13752
18:47:46.263 --> 18:47:49.342
这是我们的基本文件。

13753
18:47:49.342 --> 18:47:55.759
在pages部分，我们有我们的app，它被这个通知提供程序和Morales提供

13754
18:47:55.759 --> 18:48:02.342
程序包围，我们所有的组件都通过这个app在我们所有的页面上都通过这个app运行。

13755
18:48:02.342 --> 18:48:07.151
这是整个应用程序的入口点。

13756
18:48:07.151 --> 18:48:11.645
将Morales提供程序封装在组件中的

13757
18:48:11.645 --> 18:48:16.376
通知中意味着我们不必在组件之间传递参数。

13758
18:48:16.376 --> 18:48:18.993
我们的彩票会知道我们在哪个链ID上，

13759
18:48:18.993 --> 18:48:26.120
因为header会把它传递给Morales提供者而Morales提供者会把它传递回我们的彩票入口。

13760
18:48:26.120 --> 18:48:30.971
我们看到了手动头文件中，连接按钮在幕后的工作方式。

13761
18:48:30.971 --> 18:48:37.680
它在做一些本地存储，我们在那里存储不管我们是否连接，我们学习使用效果，你说这些

13762
18:48:37.680 --> 18:48:44.390
不同的钩子在我们前端是我们想要钩子的主要原因之一是我们想要我们的网站重新播放。

13763
18:48:44.390 --> 18:48:50.914
当东西发生变化时，我们希望我们的组件能够彼此谈论区块链的状态。

13764
18:48:50.914 --> 18:48:54.176
它们在构建React应用时非常强大。

13765
18:48:54.176 --> 18:48:59.870
Use effect是最流行的一种如果我们没有依赖数组，我们的Use

13766
18:48:59.870 --> 18:49:07.743
effect中的函数将在任何时候运行重新渲染一个空白的依赖数组意味着它只会在加载时运行一次。

13767
18:49:07.743 --> 18:49:14.596
如果数组中有依赖项，它会在任何变量发生变化时运行。

13768
18:49:14.676 --> 18:49:21.003
我们还学了use state钩子，它类似于，let variable = x。

13769
18:49:21.003 --> 18:49:23.455
但它也带有RE渲染能力。

13770
18:49:23.455 --> 18:49:30.238
它还有其他一些很好的功能我们这里没有讨论，我们学过如何用mirallas调用不同的契约函数。

13771
18:49:30.238 --> 18:49:33.880
不仅要发送事务，还要调用数据。

13772
18:49:33.880 --> 18:49:40.042
Morales很聪明，知道当它看到get门票时这将是一个视图函数。

13773
18:49:40.042 --> 18:49:43.005
这将是一个交易，它可以区分两者的区别。

13774
18:49:43.005 --> 18:49:45.395
这个将会在Metamask中弹出。

13775
18:49:45.395 --> 18:49:53.252
这个会像视图函数一样返回，我们可以在发送事务和调用契约视图函数之间使用相同的语法，我们

13776
18:49:53.252 --> 18:50:01.109
添加了一个按钮，调用其中一个Morales片段然后有一个onsuccess部分当我们的

13777
18:50:01.109 --> 18:50:09.333
事务完成时，我们更新UI并为通知添加一个小弹出框，我们学习了如何将代码直接部署到IPFS。

13778
18:50:09.333 --> 18:50:14.130
使用IPFS散列来交互和查看我们的代码，我们还学习

13779
18:50:14.130 --> 18:50:18.927
了fleek以及fleek如何自动部署到IPFS。

13780
18:50:18.927 --> 18:50:26.086
每当我们向GitHub仓库推送git时，它就会使我们的网站不断更新变得更容易。

13781
18:50:26.086 --> 18:50:29.257
它也为我们提供了一个规范的URL。

13782
18:50:29.257 --> 18:50:33.621
最后，我们学习了IPFS和去中心化数据库存储。

13783
18:50:33.677 --> 18:50:40.071
现在你可能会问，好吧，为什么我们不把这个网站的所有数据存储在Aetherium,

13784
18:50:40.071 --> 18:50:51.581
polygon或avalanche上呢?这个问题的答案是存储数据会非常昂贵，在区块链上存储大量的数据会消耗大量的汽油，而这是一个更便宜的选择。

13785
18:50:51.581 --> 18:50:58.152
以太雪崩和智能合约平台并不是数据存储层，而是逻辑层，对吧?去中

13786
18:50:58.152 --> 18:51:04.935
心化逻辑，去中心化智能合约，通常，是的，我们需要在其中存储数据。

13787
18:51:04.935 --> 18:51:07.355
但当它是大量的数据时，有更好的解决方案。

13788
18:51:07.355 --> 18:51:13.235
有不同的解决方案来存储数据，比如IPFS和文件币，如果你已经做到了这一步，你应

13789
18:51:13.235 --> 18:51:19.267
该为自己感到非常自豪，因为你已经做了一个非常可靠的应用，一个非常可靠的前端应用。

13790
18:51:19.267 --> 18:51:24.474
您还学习了如何非常轻松地添加与智能合约交互的功能。

13791
18:51:24.474 --> 18:51:30.626
所以，给自己一点鼓励吧，甚至可以在推特上发布，与你的朋友和家人分享这个非常酷的应用程序。

13792
18:51:30.678 --> 18:51:32.598
休息一下。

13793
18:51:38.678 --> 18:51:42.130
好了，欢迎来到我们最快的一节课。

13794
18:51:42.130 --> 18:51:45.152
在这节课中，我们将讨论硬帽入门套件。

13795
18:51:45.152 --> 18:51:48.801
很快地，我会给你们演示一下如何使用它。

13796
18:51:48.801 --> 18:51:54.066
现在我们学到了很多关于项目的知识，我们学到了很多关于不同回购的知识，学到了智能合约的基础知识。

13797
18:51:54.066 --> 18:51:58.505
我们也学到了很多关于前端的知识以及为应用程序构建前端的知识。

13798
18:51:58.505 --> 18:52:03.201
因此，这个智能合约套件repo附带了大量的启

13799
18:52:03.201 --> 18:52:07.898
动套件，您可以使用它们立即开始部署您的项目。

13800
18:52:07.898 --> 18:52:14.203
正如你所看到的那样，这个硬帽入门套件很容易成为最受欢迎的装备之一，拥有最多的明星和叉子。

13801
18:52:14.203 --> 18:52:18.722
智能合约套件repo实际上附带了大量的框架，比如如果你想使用SWANA，

13802
18:52:18.722 --> 18:52:27.510
如果你想使用Python和Brownie，如果你想使用foundry, truffle，任何其他的框架，你可以开始，克隆其中一个repo，使

13803
18:52:27.510 --> 18:52:34.290
可以开始，克隆其中一个repo，使用其中一个repo来构建你的项目，然后立即开始，我们将向你展示如何使用hard hat starter套件。

13804
18:52:34.290 --> 18:52:40.208
你可以直接拿着repo去做已经有了一些样板代码和一个样板非常好看的repo来开始你的项

13805
18:52:40.208 --> 18:52:46.264
目，我们来看看智能合约工具包，这里是hard hat starter kit repo。

13806
18:52:46.264 --> 18:52:53.679
如果你正在使用GitHub，你可以直接使用这个模板，它会自动生成一个新的GitHub回购与最难的启动工具包。

13807
18:52:53.679 --> 18:52:57.804
我们继续，点击使用这个模板，这里有我们自己的名字，我们将它命名为，

13808
18:52:57.804 --> 18:53:03.306
make它public create repository from template。

13809
18:53:03.306 --> 18:53:05.658
它会生成我们的存储库。

13810
18:53:05.658 --> 18:53:09.575
现在我们自动在自己的回购中有了它。

13811
18:53:09.575 --> 18:53:11.397
我们可以开始处理它了。

13812
18:53:11.397 --> 18:53:12.615
我们可以开始处理它了。

13813
18:53:12.679 --> 18:53:16.743
如果你不想点击使用模板按钮，我们也可以复制URL。

13814
18:53:16.743 --> 18:53:20.329
在代码编辑器中，我们可以复制粘贴到这里。

13815
18:53:20.329 --> 18:53:25.804
现在，我将得到clone，但我将用我们刚创建的这个repo得到clone。

13816
18:53:25.804 --> 18:53:32.187
回来与git克隆，硬帽玩FCC或硬帽启动套件。

13817
18:53:32.187 --> 18:53:37.760
我们将cd放入我们的头部播放FCC，然后在一个新的代码编辑器中打开它。

13818
18:53:37.760 --> 18:53:38.546
而可畏。

13819
18:53:38.679 --> 18:53:43.669
现在你会看到在这个回购中，它打包了大量的合同，部署，脚本，

13820
18:53:43.669 --> 18:53:48.488
任务，测试，一切，你能想到的，真正开始在一个专业的环境。

13821
18:53:48.488 --> 18:53:53.763
我们看一下合同部分，我们可以看到我们有一些合同样本。

13822
18:53:53.763 --> 18:53:58.362
我们有一个合同，对一个链节点进行API调用，与负责价

13823
18:53:58.362 --> 18:54:03.138
格feed的饲养员合作，然后与链Vir Fe 2合作。

13824
18:54:03.138 --> 18:54:10.801
我们有一些测试合同，还有这个模糊文件夹，我们会在后面的课程中讲到，我们有部署脚本，

13825
18:54:10.801 --> 18:54:18.279
我们从部署模拟开始，然后部署每一个合同，我们有一个示例脚本从这些合同中读取价格。

13826
18:54:18.279 --> 18:54:21.079
我们有一大堆的样本任务。

13827
18:54:21.079 --> 18:54:23.933
现在在记录的时候，这个回购使用的不是脚本，而是任务。

13828
18:54:23.933 --> 18:54:26.373
但是，它们是可以互换的。

13829
18:54:26.373 --> 18:54:32.778
当然，我们还有一些单元测试和一些分段测试，你们可以看一看，一旦我们在这个回购中，

13830
18:54:32.778 --> 18:54:39.024
我们可以在这里运行一些熟悉的命令，我们会做yarn，当然，来安装我们所有的包。

13831
18:54:39.024 --> 18:54:44.130
然后我们要做的所有事情，如果你迷路了，你总是可以回到这个回购。

13832
18:54:44.130 --> 18:54:46.939
你可以跟随入门和快速入门。

13833
18:54:46.939 --> 18:54:48.280
我们只是做了git克隆。

13834
18:54:48.280 --> 18:54:52.764
现在我们在做纱线，然后我们要继续做纱线硬帽测试。

13835
18:54:52.764 --> 18:54:58.902
这个hard hat starter kit repo是非常持续更新的，我们在几天前刚刚

13836
18:54:58.902 --> 18:55:05.180
发布了最后一个推送，它将不断提供一些构建智能合约的最佳实践，并拥有一个真正专业的编码环境。

13837
18:55:05.180 --> 18:55:06.883
它有一个非常可爱的标志。

13838
18:55:06.883 --> 18:55:12.477
一旦我们安装了所有的依赖项，我们就可以运行yarn, art had test，

13839
18:55:12.477 --> 18:55:19.470
我们可以在test文件夹中运行所有的测试，它也会告诉我们如何交互以及如何使用这里所有这些不同的契约。

13840
18:55:19.470 --> 18:55:26.346
它们每个都有一些console。log，因此您可以看到更多关于这些测试实际运行时实际发生的情况。

13841
18:55:26.346 --> 18:55:28.970
如果我们查看Hardhead配置。

13842
18:55:28.970 --> 18:55:35.500
Js里面有一些很熟悉的代码，我们在顶部有所有的导入，我们抓取一大堆环境变量，

13843
18:55:35.500 --> 18:55:44.608
我们有ether scan插件，我们有gas reporter，合约大小器，这是一个告诉你合约大小的插件。

13844
18:55:44.608 --> 18:55:48.489
命名帐户，不同的固态版本，还有摩卡超时。

13845
18:55:48.489 --> 18:55:57.041
当然，我们可以做yarn硬帽节点，它会运行在我们的部署脚本中，然后为我们旋转一个新的注释，它

13846
18:55:57.041 --> 18:56:05.593
有模拟链链令牌，模拟Oracle的模拟聚合器，模拟VRF以便我们继续进行交互，然后我们当然可

13847
18:56:05.593 --> 18:56:14.146
以，到硬帽，控制台，破折号网络localhost，开始与localhost上的契约进行交互。

13848
18:56:14.146 --> 18:56:21.702
我们可以遵循价格供给，例如，const price消费

13849
18:56:21.702 --> 18:56:29.538
者b3 = await醚。get合约，价格，消费者v3。

13850
18:56:29.681 --> 18:56:35.181
然后我们可以等待价格消费者B 3点得到最新的价格。

13851
18:56:35.181 --> 18:56:38.281
我们把它包装成一个to字符串。

13852
18:56:38.281 --> 18:56:43.926
我们可以看到来自使用通道价格提要的合约的模拟最新价格。

13853
18:56:43.926 --> 18:56:49.415
我们可以与我们的任何合同进行交互也可以与这里的任何模拟进行工作。

13854
18:56:49.415 --> 18:56:55.229
如果我们想把它部署到一个实际的测试网络，比如Rinckey，或者主网会弹出我们的。

13855
18:56:55.229 --> 18:57:01.612
env文件，我们会关闭节点终端，我们可以运行yarn hardhat或hh deploy。

13856
18:57:01.612 --> 18:57:04.784
然后我们会在这里添加任何我们想要的标签。

13857
18:57:04.784 --> 18:57:06.557
我们来部署价格供给合约。

13858
18:57:06.557 --> 18:57:10.616
如果我们转到价格提要部署，向下滚动，我们会得到标签。

13859
18:57:10.616 --> 18:57:18.600
好的，很好，我们将使用feed标签，dash标签提供dash或提供dash网络带来的光束。

13860
18:57:18.681 --> 18:57:22.270
在我们等待这个部署的时候，我们可以回到实际的回购。

13861
18:57:22.270 --> 18:57:30.759
一定要跟随这里的文档和快速入门所有的用法和所有的东西这样你就能确保你使用的是最新的版本。

13862
18:57:30.759 --> 18:57:37.131
甚至还有关于使用测试网或与Aetherium一起工作的活动网络运行本地网络的文档。

13863
18:57:37.131 --> 18:57:45.529
Rigby添加你的私钥和点羡慕所有这些你已经知道的东西，分叉，我们稍后会学到一点，自动资助你的

13864
18:57:45.529 --> 18:57:53.927
合同使用链链接API运行测试，你可以额外的并行运行你的测试通过在我们的测试中添加虚线并行标志。

13865
18:57:53.927 --> 18:58:02.632
我们可以与部署的契约与我们创建的不同任务进行交互检测代码格式，估计气体代码覆盖模糊，我们将在后面讨论。

13866
18:58:02.682 --> 18:58:04.173
然后是贡献。

13867
18:58:06.682 --> 18:58:11.497
一旦它被输出，甚至被验证，如果你打开了验证，你会得到

13868
18:58:11.497 --> 18:58:16.313
一个小任务我们可以运行它来读取价格提要或与合约交互。

13869
18:58:16.313 --> 18:58:17.839
我们可以把这个任务复制出来。

13870
18:58:17.839 --> 18:58:18.523
纱线建筑工人。

13871
18:58:18.682 --> 18:58:24.878
阅读价格提要，因为这是一个任务，合同数据，我们刚刚部署的网络Rigby。

13872
18:58:24.878 --> 18:58:30.540
我们将从网络上的消费者合同中获取读取数据价格，Rigby价格在这里，当

13873
18:58:30.540 --> 18:58:36.364
然，我们说Aetherium的价格是3033美元，因为它有小数点后8位。

13874
18:58:36.364 --> 18:58:43.391
因此，如果你想开始一个新的项目，并且你想要一些样板代码，这个硬帽初学者工具包是一个很好的开始。

13875
18:58:43.391 --> 18:58:49.635
当然，你可以打开它，得到豆荚，如果你想测试一下，尝试一下，在云壳里得到豆荚。

13876
18:58:49.682 --> 18:58:51.082
这节课就到这里。

13877
18:58:51.082 --> 18:58:51.932
没那么快。

13878
18:58:52.682 --> 18:58:53.699
有史以来最快的一课。

13879
18:58:55.682 --> 18:59:01.980
在这里学习，我会分叉，会克隆，我会使用这个模板，试着自己尝试一下

13880
18:59:01.980 --> 18:59:08.475
回购看看你认识什么，不认识什么，把它准备好，以备以后课程中的问题。

13881
18:59:08.475 --> 18:59:15.488
对于所有使用TypeScript的人，当然也有一个TypeScript版本你可以克隆它。

13882
18:59:15.488 --> 18:59:19.617
它有一个漂亮的蓝色标志，表明它有点不同。

13883
18:59:19.617 --> 18:59:24.895
也就是说，用回购，玩得开心。

13884
18:59:24.895 --> 18:59:29.299
让我们开始第十二课。

13885
18:59:29.683 --> 18:59:32.830
好了，现在我们开始讲硬帽ERC。

13886
18:59:33.683 --> 18:59:41.666
部分，我们将学习如何创建我们自己的ERC 20或EIP 20或B EP 20或AEP 20区块链上

13887
18:59:41.666 --> 18:59:49.812
的任何这些令牌，在我们了解ERC 20是什么，甚至这些令牌是什么之前，我们首先需要了解什么是ERC。

13888
18:59:49.812 --> 18:59:55.450
还有Aetherium的EIP，雪崩，金融和多边形。

13889
18:59:55.450 --> 18:59:58.683
所有这些区块链都有所谓的改进建议。

13890
18:59:58.683 --> 19:00:03.612
对于Aetherium，它们被称为Aetherium改进建议，或E IPs。

13891
19:00:03.683 --> 19:00:08.240
人们会做的是想出这些想法来改进Aether

13892
19:00:08.240 --> 19:00:13.016
ium或改进这些层，如多边形，马蒂奇雪崩等。

13893
19:00:13.016 --> 19:00:21.083
在一些GitHub或一些开源存储库中，他们会添加这些新的EIP他们会添加这些新的改进想法使这些协议更好。

13894
19:00:21.083 --> 19:00:26.176
现在，这些改进可以是任何东西，它们可以是任何东西，从核

13895
19:00:26.176 --> 19:00:31.269
心区块链更新到一些标准，这将是整个社区采用的最佳实践。

13896
19:00:31.269 --> 19:00:38.328
一旦EIP获得了足够的洞察力，他们还会创建E RC，即Aetherium请求评论。

13897
19:00:38.328 --> 19:00:43.616
因此，EIP理论和改进建议ERC理论和征求意见。

13898
19:00:43.683 --> 19:00:47.933
这些公司可以是英国石油公司、活力公司等。

13899
19:00:48.683 --> 19:00:50.055
这些不同的区块链。

13900
19:00:51.683 --> 19:00:58.602
和评论请求，都有这些不同的标签，现在它们按时间顺序编号，所以像ERC 20

13901
19:00:58.602 --> 19:01:05.521
这样的东西将是第20个ERC / EIP, ERC和efp共享相同的数字。

13902
19:01:05.521 --> 19:01:08.360
有一些网站，比如EIP是aetherium。

13903
19:01:08.360 --> 19:01:16.699
他们跟踪所有这些新的Aetherium改进建议，你可以实时看到它们通过被社区采用的过程。

13904
19:01:16.699 --> 19:01:23.934
现在，其中一个ip或ERC将成为ERC 20或智能合约的令牌标准。

13905
19:01:23.934 --> 19:01:30.897
这是一个改进方案，讨论了如何实际创建令牌和创建这些智能合约令牌。

13906
19:01:30.897 --> 19:01:32.287
我最近做了一个关于这个的视频。

13907
19:01:32.287 --> 19:01:40.311
在与这门课相关的GitHub回购中，我们会有一节课，我们会看一个简短的视频来解释更多关于这些不同代币的内容。

13908
19:01:40.311 --> 19:01:47.737
首先，让我们定义什么是ERC 20。ERC 20是部署在一个链上的令牌，使用所谓

13909
19:01:47.737 --> 19:01:55.350
的ERC 20令牌标准，你可以在描述中的20年令牌标准链接中阅读更多关于它的信息。

13910
19:01:55.350 --> 19:01:59.054
但基本上，它是一个智能合约，它实际上代表一个代币。

13911
19:01:59.054 --> 19:02:01.395
它是代币或智能合约。

13912
19:02:01.395 --> 19:02:09.160
这两者都很酷，链链独特的令牌和染料都是ERC 20的例子技术上讲，链链属于ERC。

13913
19:02:09.160 --> 19:02:15.836
677，因为有升级到ERC 20的一些令牌仍然向后兼容ERC。

13914
19:02:15.836 --> 19:02:20.756
所以基本上，你可以把它们看作是带有一些额外功能的ERC。

13915
19:02:20.756 --> 19:02:24.913
我为什么要做ERC 20呢，你可以用它做很多很酷的东西。

13916
19:02:24.913 --> 19:02:32.102
你可以创建治理令牌，你可以保护底层网络，你可以创建某种类型的合成酸，或者其他任何东西。

13917
19:02:32.102 --> 19:02:40.168
在任何情况下，我们如何建立一个这样的ERC?我们怎么造一个代币?我们要做的就是建立一个遵循令牌

13918
19:02:40.168 --> 19:02:48.406
标准的智能合约，我们要做的就是建立一个智能合约它有这些函数有名称函数，符号函数，小数函数，等等。

13919
19:02:48.406 --> 19:02:52.399
所有这些功能我们都需要能够传递它，我们需要能够得到它的平衡等等。

13920
19:02:52.399 --> 19:03:00.455
如果你想检查一些仍然兼容ERC 20的改进，比如ERC 677或ERC 777。

13921
19:03:00.455 --> 19:03:05.650
一定要去看看，然后建造一个这样的东西。

13922
19:03:05.650 --> 19:03:07.136
好吧，太棒了。

13923
19:03:07.136 --> 19:03:15.600
现在我们知道了这些ERC 20中的一个是什么，我们可以继续，在与本课程相关的GitHub回购中创建我们自己的。

13924
19:03:15.600 --> 19:03:16.943
我们这里有所有可用的代码。

13925
19:03:16.943 --> 19:03:18.878
如果你只想克隆。

13926
19:03:18.878 --> 19:03:22.077
这又是一节速成课。

13927
19:03:22.077 --> 19:03:23.072
我们在终点站。

13928
19:03:23.072 --> 19:03:24.330
我们在VS代码中。

13929
19:03:24.330 --> 19:03:26.528
我们要创建一个新目录。

13930
19:03:26.528 --> 19:03:33.193
我叫它硬帽ERC 20 FCC将cd变成硬帽，你的C 20秒。

13931
19:03:33.193 --> 19:03:40.409
我们将创建一个新的安全帽项目和我们之前做的完全一样，yarn add dash dev或tab。

13932
19:03:40.409 --> 19:03:45.330
让我们在它自己的VS code中打开它。

13933
19:03:45.330 --> 19:03:47.652
或文件打开此文件夹。

13934
19:03:47.652 --> 19:03:50.410
好了，我们现在在我们的项目中。

13935
19:03:50.410 --> 19:03:52.151
让我们创建一个新的安全帽项目。

13936
19:03:52.151 --> 19:03:55.485
我们会做纱线，艺术帽。

13937
19:03:55.685 --> 19:03:59.930
我们会创建一个空的hardhat。config。j s，很好。

13938
19:03:59.930 --> 19:04:02.438
我们现在有一个空的硬帽。config。js。

13939
19:04:02.438 --> 19:04:08.369
如果你想从之前的项目中复制粘贴你的hard hat。config你想复制粘贴你的heart

13940
19:04:08.369 --> 19:04:15.488
Have。config或者你的。EMV文件，因为你知道我们会需要这些你可以现在就这么做，我要把它更新到8。

13941
19:04:15.488 --> 19:04:15.553
7.

13942
19:04:15.685 --> 19:04:18.057
我待会再加我的东西。

13943
19:04:19.685 --> 19:04:21.081
EIP 20，或者ERC 20。

13944
19:04:23.685 --> 19:04:28.204
在它的代币标准中，我们可以转让代币，我们可以在ERC

13945
19:04:28.204 --> 19:04:33.419
20合同中做所有的事情，它实际上只是跟踪每个人有多少代币。

13946
19:04:33.419 --> 19:04:36.892
智能合约以一种奇怪的方式保持着自我跟踪。

13947
19:04:36.892 --> 19:04:39.341
首先，我们要用手工的方法来做。

13948
19:04:39.341 --> 19:04:46.892
首先，我们要在这里创建我们自己的手动令牌，或者是一个非常简单的令牌，让我们创建一个新文件夹。

13949
19:04:46.892 --> 19:04:53.574
契约将创建一个名为manual token。soul的新文件。

13950
19:04:53.574 --> 19:04:59.876
好的，我先给大家演示一下比较难的做法然后再给大家演示一种简单得多的做法。

13951
19:04:59.876 --> 19:05:07.876
开始之前我们通常会做pragma, solidity to carrot 0，第8点。

13952
19:05:07.876 --> 19:05:07.971
7.

13953
19:05:07.971 --> 19:05:14.031
然后我们还会写spdx，许可标识符，

13954
19:05:14.031 --> 19:05:19.419
MIT做合约，手动令牌，开始吧。

13955
19:05:19.419 --> 19:05:26.266
令牌智能合约工作的主要原因是存在一些余额映射。

13956
19:05:26.266 --> 19:05:31.195
所以我们有256页的地址映射。

13957
19:05:31.195 --> 19:05:37.359
它通常是公共的，叫做balance of它所做的就是这个

13958
19:05:37.359 --> 19:05:43.744
映射很明显关键是这个星球上的每一个地址，然后是他们有多少。

13959
19:05:43.744 --> 19:05:49.317
基本上，当我们转移代币，转移代币时，我们基

13960
19:05:49.317 --> 19:05:55.156
本上只是从地址，金额中减去，然后加到地址中。

13961
19:05:55.156 --> 19:06:00.855
实现这个的最简单的方法就是先创建传递函数。

13962
19:06:00.855 --> 19:06:05.895
我们将创建这个函数，我将它命名为下划线传输，

13963
19:06:05.895 --> 19:06:10.936
我们可以做一个地址从地址到你到第五第六挂载。

13964
19:06:10.936 --> 19:06:16.801
现在我们可能会加上一些要求，我们可能会省略一些事件，让我们把这个也公开。

13965
19:06:16.801 --> 19:06:24.733
实际上，在一天结束的时候，我们会说balance of from - equals value，

13966
19:06:24.733 --> 19:06:34.318
这和说bounce of from = bounce from - value，不好意思，是amount是一样的，然

13967
19:06:34.318 --> 19:06:43.409
一样的，然后我们会说balance of 2，不好意思，是+ equals，这和说balance of 2 +是一样的。

13968
19:06:43.409 --> 19:06:50.916
技术上来说，这就是我们需要的，对吧，我们可能需要在这里做一些断言，一些要求来确保所有的数字都有意义。

13969
19:06:50.916 --> 19:06:55.287
但实际上，在一天结束的时候，这就是这个函数所做的一切。

13970
19:06:55.287 --> 19:07:00.618
当呼叫者直接把钱送到另一个地址时，转账就起作用了。

13971
19:07:00.687 --> 19:07:08.289
但是如果我们想让智能合约使用我们的令牌，或者我们想让其他人使用我们的令牌，也

13972
19:07:08.289 --> 19:07:16.093
许把它存入协议，或者用它做更多的功能，会有一些被批准的功能会批准合约来做这些。

13973
19:07:16.093 --> 19:07:21.495
然后我们会有一个功能转移，这个功能会，你知道，

13974
19:07:21.495 --> 19:07:26.428
它会实现从用户那里获取资金，这也是公共的。

13975
19:07:26.428 --> 19:07:31.472
然后在顶部会是某种类型的许可映射它会告诉谁被允许在哪

13976
19:07:31.472 --> 19:07:36.517
个地址取多少令牌，这听起来有点混乱，但让我添加映射。

13977
19:07:36.517 --> 19:07:42.731
这将是地址的映射到地址的映射到单位性的数

13978
19:07:42.731 --> 19:07:48.945
量这将是公共许可，我们将说地址，帕特里克

13979
19:07:48.945 --> 19:07:55.160
将允许帕特里克的弟弟的地址使用25代币。

13980
19:07:55.160 --> 19:07:57.688
这就是这项津贴的运作方式。

13981
19:07:57.688 --> 19:08:03.291
在我们的transfer from中，会检查这个允许映射并保存。

13982
19:08:03.291 --> 19:08:08.228
帕特里克授权你借那些代币了吗?哦，不，你说了。

13983
19:08:08.228 --> 19:08:09.934
好吧，我们让你从。

13984
19:08:09.934 --> 19:08:14.259
我将复制粘贴它的一个实现，你也可以查看GitHub repo。

13985
19:08:14.259 --> 19:08:20.881
它看起来是这样的，我们检查允许的金额，更新限额，然后转移代币。

13986
19:08:20.881 --> 19:08:22.171
这是一些主要的功能。

13987
19:08:22.171 --> 19:08:26.375
显然，我们需要一个被认可的功能，来更新这里的津贴。

13988
19:08:26.375 --> 19:08:32.501
通常，你会有一个un256的初始供给。

13989
19:08:32.501 --> 19:08:41.139
这就像有多少令牌从总共有多少令牌开始，有时你会添加一个薄荷函数来添加更多的函数。

13990
19:08:41.139 --> 19:08:44.161
但是你基本上可以看到这个合约在上升。

13991
19:08:44.161 --> 19:08:51.114
我们可以做的一件事是，我们可以继续，通过这个规范，一行一行地，你知道，自己构建我们的令牌。

13992
19:08:51.114 --> 19:08:54.211
在我们这样做之后，它可能看起来像这样。

13993
19:08:54.211 --> 19:08:57.425
我只是复制粘贴了GitHub回购的代码。

13994
19:08:57.425 --> 19:09:01.524
到合约，手动令牌，复制粘贴这段代码。

13995
19:09:01.524 --> 19:09:04.830
这就是令牌合约的样子。

13996
19:09:04.830 --> 19:09:05.068
好的。

13997
19:09:05.068 --> 19:09:07.868
我们有了所有这些函数，所有这些数组。

13998
19:09:07.868 --> 19:09:08.999
我们有所有这些东西。

13999
19:09:08.999 --> 19:09:14.720
你可以在构造函数中看到，我们取初始供给，然后是令牌名和令牌符号。

14000
19:09:14.720 --> 19:09:17.555
它的名字，你知道，可能是dy token之类的。

14001
19:09:17.555 --> 19:09:25.557
然后这个符号可以是dy这样的，这样就可以很容易地通过它的名字和符号来识别它。

14002
19:09:25.688 --> 19:09:29.480
从头开始编码，这绝对是我们可以做到的。

14003
19:09:29.480 --> 19:09:32.439
但作为工程师，我们知道这可能真的很烦人。

14004
19:09:32.439 --> 19:09:33.626
实际上我们并不想这样做。

14005
19:09:33.689 --> 19:09:40.377
那么我们能做些什么呢?我们可以使用一个开源库，比如开放的Zeppelin，

14006
19:09:40.377 --> 19:09:47.066
来得到一些样板代码，而开放的Zeppelin几乎被认为是一种稳定的标准库。

14007
19:09:47.066 --> 19:09:55.354
他们有一个开源合同的列表，任何人都可以使用并导入到他们的合同中，其中有大量的样板文件，所以你不需要手动把所有东西都写出来，

14008
19:09:55.354 --> 19:10:03.642
我们可以在GitHub仓库中看到他们的所有代码，打开Zeppelin /打开Zeppelin合同，我们以后会经常使用它们。

14009
19:10:03.689 --> 19:10:08.197
例如，你可以在他们文档的左边看到，他们有这个令牌

14010
19:10:08.197 --> 19:10:12.705
部分，他们有一个ERC 20，这是令牌标准之一。

14011
19:10:12.705 --> 19:10:19.089
如果你滚动到这里，他们甚至有一些关于如何创建自己的ERC 20令牌的简单例子。

14012
19:10:19.089 --> 19:10:22.016
那就是我们要用来构建令牌的东西。

14013
19:10:22.016 --> 19:10:25.914
因为你可以看到这个有多小需要维护的代码有多少。

14014
19:10:25.914 --> 19:10:29.220
让我们继续，让我们使用打开Zeppelin来创建我们的令牌。

14015
19:10:29.220 --> 19:10:30.785
让我们创建一个新文件。

14016
19:10:30.785 --> 19:10:32.720
我们将令牌命名为。soul。

14017
19:10:32.720 --> 19:10:36.092
我要在这里创建我们自己的令牌。

14018
19:10:36.092 --> 19:10:37.726
我们来求spdx。

14019
19:10:37.726 --> 19:10:46.235
许可标识符MIT，我们用pragma, solidity胡萝卜0，点8。

14020
19:10:46.235 --> 19:10:48.578
7，我们会做代币契约。

14021
19:10:48.578 --> 19:10:54.516
现在，我们要做的是，我们要把openzeppelin合同导入到我们的安全帽项目中。

14022
19:10:54.516 --> 19:10:58.555
我们会像处理chain link和未来的其他包一样处理它。

14023
19:10:58.555 --> 19:11:05.146
所以我们会做纱线，添加破折号Dev，在打开齐柏林斜杠合同。

14024
19:11:05.146 --> 19:11:09.584
这将添加开放齐柏林砍合同NPM包到我们的项目。

14025
19:11:09.584 --> 19:11:17.471
其中一段代码就是我们可以使用的ERC 20契约我们可以让令牌继承所有的函数。

14026
19:11:17.471 --> 19:11:22.602
我们用importatopenzeppelin导入它。

14027
19:11:22.690 --> 19:11:28.065
/ /合约/ /代币/ / ERC 20 / / ERC 20

14028
19:11:28.065 --> 19:11:33.413
通过像这样导入它，我们要做的就是继承我们的令牌。

14029
19:11:33.413 --> 19:11:34.766
我们用契约。

14030
19:11:34.766 --> 19:11:36.077
我们的代币是ERC 20。

14031
19:11:36.077 --> 19:11:36.399
繁荣。

14032
19:11:36.399 --> 19:11:39.237
就这样，我们的代币差不多完成了。

14033
19:11:39.237 --> 19:11:44.500
现在你可能会看到这条小红线表示我们的标记应该被标记为抽象。

14034
19:11:44.500 --> 19:11:51.724
这是因为如果我们研究openzeppelin的ERC 20点灵魂，我们会看到它有一个构造函数。

14035
19:11:51.724 --> 19:12:00.540
因此，为了继承你的c20令牌，我们必须使用ERC 20构造函数，我们只需要给我们的令牌一个名称和一个符号。

14036
19:12:00.540 --> 19:12:04.034
但我们可以在构造函数中，让它为空。

14037
19:12:04.034 --> 19:12:10.769
然后就在构造函数旁边，我们会添加ERC 20构造函数我们的名字就是我们的令牌。

14038
19:12:10.769 --> 19:12:15.241
然后我们的符号就是OT和ERC。

14039
19:12:15.241 --> 19:12:21.145
20个token还带有一个叫做mint的函数，它本质上是一个允许我们

14040
19:12:21.145 --> 19:12:27.050
创建token的函数，因为现在我们实际上是用0个token初始化的。

14041
19:12:27.050 --> 19:12:30.062
所以实际上没有人被允许持有任何代币。

14042
19:12:30.062 --> 19:12:36.109
我们想要铸造最初数量的代币然后谁拥有这些代币。

14043
19:12:36.109 --> 19:12:40.611
通常你会看到一个像这样的薄荷函数，它会传递给

14044
19:12:40.611 --> 19:12:45.113
发送者，所以部署这个契约的人将拥有所有令牌。

14045
19:12:45.113 --> 19:12:49.519
然后我们就像给他们灵魂供给一样。

14046
19:12:49.690 --> 19:12:54.277
然后初始供给是56，等于7，等等。

14047
19:12:54.277 --> 19:12:58.711
但是，通常的做法是将它添加到构造函数中。

14048
19:12:58.711 --> 19:13:04.737
256个初始供给就像这样，我们知道固体度小数并不好用。

14049
19:13:04.737 --> 19:13:11.966
如果我说我的初始供给是50，这个50就是50，所有这些ERC

14050
19:13:11.966 --> 19:13:20.400
20都有一个小数和小数函数，它告诉我们ERC 20应该有多少个小数。

14051
19:13:20.400 --> 19:13:21.791
默认为18。

14052
19:13:21.791 --> 19:13:25.891
如果我们想要不同数量的小数，我们可以重写这个函数。

14053
19:13:25.891 --> 19:13:28.091
如果我们知道默认值是18。

14054
19:13:28.091 --> 19:13:32.894
我们想要部署50，我们可能想要初始供应50 e18。

14055
19:13:32.894 --> 19:13:39.841
或者你也可以说，50乘以10,18次方，或者任何你想要的。

14056
19:13:39.841 --> 19:13:44.035
在我们的代码中当我们部署这个时，这实际上是我们完成项目的地方。

14057
19:13:44.035 --> 19:13:51.207
因为我们在这里要做的其他事情，我们已经做过了，我们需要做的就是创建一个部署脚本并编写一些测试。

14058
19:13:51.207 --> 19:13:51.755
真的是这样。

14059
19:13:51.755 --> 19:13:58.778
因为现在您已经具备了编写部署脚本所需的所有技能，然后还可以为这个项目编写一些测试。

14060
19:13:58.778 --> 19:14:02.557
因此，我强烈建议您在此暂停视频，并尝试编写自己的部署脚本。

14061
19:14:02.557 --> 19:14:09.898
即使你想写自己的测试，你也可以参考与这节课相关的GitHub回购，因为我们在这

14062
19:14:09.898 --> 19:14:17.429
里有一个部署脚本，我们也在这里有一个TypeScript版本，我们不打算再讲了。

14063
19:14:17.429 --> 19:14:22.385
当然，如果您完全迷失了方向，这里有大量的说明可以

14064
19:14:22.385 --> 19:14:27.548
帮助您了解更多信息，并帮助您使用这个特定的存储库。

14065
19:14:27.691 --> 19:14:30.970
让我们快速回顾一下刚刚学过的内容。

14066
19:14:31.692 --> 19:14:37.837
代币，或EIP 20代币，或bp或p p，或这些破折号20中的任何一个。

14067
19:14:37.837 --> 19:14:42.273
改进建议就是所谓的令牌标准。

14068
19:14:42.273 --> 19:14:48.060
而令牌标准，这些链上的令牌实际上只是智能合约的令牌。

14069
19:14:48.060 --> 19:14:52.242
现在，这些代币明显不同于第一层代币，如Aetherium，

14070
19:14:52.242 --> 19:15:02.627
或polygon或Avalanche或arbitration，它们不会是智能合约，它们将是区块链原生代币，你会听到我经常把它称为区块链原生代币。

14071
19:15:02.627 --> 19:15:08.629
而不是这些代币，这些ERC 20，这些智能合约代币，它们只是智能合约。

14072
19:15:08.692 --> 19:15:13.936
它们只是这些表示每个地址有多少令牌的函数的组合，

14073
19:15:13.936 --> 19:15:18.743
我们可以用添加的所有规范创建我们自己的令牌。

14074
19:15:18.743 --> 19:15:26.803
或者我们可以用openzeppelin来导入代币现在另一个像open Zeppelin一样流行的回购将是这个来自Rory资本的叫soulmate的。

14075
19:15:26.803 --> 19:15:30.739
它们都旨在成为坚固性的标准库。

14076
19:15:30.739 --> 19:15:35.446
要记住的一件重要的事情是这些令牌有这个允许映射。

14077
19:15:35.446 --> 19:15:40.804
你可以允许其他地址访问你的令牌并移动你的令牌。

14078
19:15:40.804 --> 19:15:45.616
这很重要，特别是当我们稍后使用defy时，当我们想给令牌一

14079
19:15:45.616 --> 19:15:50.428
些智能合约访问权，这样它们就可以把它输入到defy协议中。

14080
19:15:50.428 --> 19:15:52.031
这也有点棘手。

14081
19:15:52.031 --> 19:15:57.692
你要确保你不允许恶意合约与你的代币交互。

14082
19:15:57.692 --> 19:16:02.118
我们还会看到，当我们开始与这些代币进行更多的交互时，在任何合

14083
19:16:02.118 --> 19:16:06.692
同可以与我们的代币交互之前，我们需要批准它们与我们的代币交互。

14084
19:16:06.692 --> 19:16:07.392
就是这样。

14085
19:16:07.392 --> 19:16:10.407
现在您是令牌向导，可以部署自己的令牌了。

14086
19:16:10.407 --> 19:16:18.557
休息一下，喝杯咖啡，下期见。

14087
19:16:18.693 --> 19:16:24.457
好了，欢迎来到下一节课，我们将在这一节课中学习defy，

14088
19:16:24.457 --> 19:16:29.811
它将是程序化的，并将与defy协议进行程序化的交互。

14089
19:16:29.811 --> 19:16:36.630
在这一节课上，我为您感到非常兴奋，因为defi是智能合约的最佳用例之一。

14090
19:16:36.630 --> 19:16:43.008
我现在特别兴奋的一个用例，正如我所提到的，过去的defy代表去中心化金融，

14091
19:16:43.008 --> 19:16:49.559
我们在GitHub存储库中留下了一些链接，让你们了解更多关于defy的信息。

14092
19:16:49.559 --> 19:16:54.951
我们对defy如此兴奋的一个主要原因是，我们脱离了这个传统共识的领域。

14093
19:16:54.951 --> 19:16:57.771
这就是智能合约的意义所在。

14094
19:16:57.771 --> 19:17:06.271
他们要把这个中心化的实体，从我们的金融世界中移除，特别是从那些有利益冲突的金融机构中移除。

14095
19:17:06.271 --> 19:17:09.226
他们做生意是为了赚钱而不是为了保护我们的钱不是为了赚钱。

14096
19:17:09.226 --> 19:17:16.209
我们希望与一个一切都透明的体系合作，特别是在金融服务方面。

14097
19:17:16.209 --> 19:17:21.483
因此，我们希望进入智能合约的世界，特别是在涉及到我们的资金时。

14098
19:17:21.483 --> 19:17:26.774
在我看来，defi将会是影响大众的行业，最

14099
19:17:26.774 --> 19:17:32.065
快因为去中心化金融比中心化金融更公平更好。

14100
19:17:32.065 --> 19:17:39.497
目前，你在defy中获得的利率，收益和利息要比集中金融好得多，因为记住，它不再

14101
19:17:39.497 --> 19:17:46.929
使用这些集中协议，你会说，嘿，相信我们，我们会让你进入市场或者不相信我们，把你

14102
19:17:46.929 --> 19:17:54.744
的钱放在我们这里会保证你的钱的安全而不是不得不相信这些公司和实体，这是我们想要的。

14103
19:17:54.744 --> 19:17:57.240
此外，我们的Oracle网络越完善，

14104
19:17:57.240 --> 19:18:06.394
Oracle网络与智能合约平台如Aetherium, polygon，套利平台的合作越多，我们就能提供更多的数据和更复杂的金融产品。

14105
19:18:06.394 --> 19:18:14.903
我对defy如此兴奋的另一个原因是如果你看这个小图表，它按规模显示了不同的市场。

14106
19:18:14.903 --> 19:18:21.080
现在这个图像有点过时了，但它仍然向你展示了所有这些不同行业的相对规模

14107
19:18:21.080 --> 19:18:27.439
现在是一个2000亿美元的市场，大约有2000亿美元被锁定在这个行业。

14108
19:18:27.439 --> 19:18:29.122
我马上给你们看。

14109
19:18:29.122 --> 19:18:33.660
加密货币实际上，在记录的时候并不是3600亿。

14110
19:18:33.660 --> 19:18:35.439
实际上是1。

14111
19:18:35.439 --> 19:18:36.115
8万亿年。

14112
19:18:36.115 --> 19:18:37.641
所以事情远不止这些。

14113
19:18:37.641 --> 19:18:43.746
但它仍然是所有其他领域的一个巨大子集，就像黄金市场是一个10万亿美元的市场。

14114
19:18:43.746 --> 19:18:52.277
股票市场几乎是100万亿美元的全球房地产，衍生品几乎是300万亿美元的千万亿美元。

14115
19:18:52.277 --> 19:19:01.253
所以FBI现在是一个非常非常非常非常非常小的分支，在我看来，所有这些领域都可以通过Defy重新规划。

14116
19:19:01.253 --> 19:19:03.928
所以我们正在努力，我们正在达到目标。

14117
19:19:03.928 --> 19:19:09.171
因此，制定这些协议将取决于我们，让人们更容易

14118
19:19:09.171 --> 19:19:14.653
进入他们的财务将更公平、更负责和更透明的空间。

14119
19:19:14.653 --> 19:19:22.953
有了更好的产出率，我们可以很好地总结这个网站上发生的事情，这个网站叫做“反抗美洲驼”。

14120
19:19:22.953 --> 19:19:28.294
它显示了锁定在所有这些不同的去中心化协议中的总价值。

14121
19:19:28.294 --> 19:19:32.345
我们可以看到很多是跨多个链的。

14122
19:19:32.345 --> 19:19:39.380
其中很多是与EVM兼容的链，Aetherium, Biden, smart chain, avalanche,

14123
19:19:39.380 --> 19:19:47.695
Fanta, drawn polygon，所有这些都是与EVM兼容的区块链，我们可以确切地看到独立用户在这些协议中投入了多少钱。

14124
19:19:47.695 --> 19:19:52.602
记录Ave的时间是对总价值锁定的第一协议。

14125
19:19:52.602 --> 19:20:00.195
所以有220亿美元被锁定在Ave，这就是我们今天要讲的协议。

14126
19:20:00.695 --> 19:20:07.135
Ave是一个借贷协议，它允许我们借贷加密货币。

14127
19:20:07.135 --> 19:20:14.283
我们可以用代币作为抵押品，这有点类似于把钱存在银行，从其他人向我们

14128
19:20:14.283 --> 19:20:21.432
借抵押品中获得收益这和银行的做法几乎完全一样，除了它被称为非托管。

14129
19:20:21.432 --> 19:20:23.465
给Ave团队的永远不要碰我们的钱。

14130
19:20:23.465 --> 19:20:24.958
没人碰过这些钱。

14131
19:20:24.958 --> 19:20:26.589
这只是一个智能合约。

14132
19:20:26.589 --> 19:20:28.504
这些都是编程代码。

14133
19:20:28.504 --> 19:20:33.325
所以我们可以放心，没有人会卷走我们的钱，没有人会做坏事。

14134
19:20:33.325 --> 19:20:34.712
我们也获得了更高的收益率。

14135
19:20:34.712 --> 19:20:40.326
借贷是创建真正有趣的金融应用程序的关键部分。

14136
19:20:40.326 --> 19:20:44.409
如果你想卖空某物，如果你想提高某资产的杠杆率如果你想。

14137
19:20:44.409 --> 19:20:49.781
如果你想做更复杂的金融产品，你就需要借贷。

14138
19:20:49.781 --> 19:20:55.039
现在很多典型的金融科技或金融技术或金融术语都适用于这里。

14139
19:20:55.039 --> 19:20:59.516
这门课不会深入研究这些金融产品是如何运作的。

14140
19:20:59.516 --> 19:21:01.559
这门课也不是关于金融的。

14141
19:21:01.559 --> 19:21:07.254
如果你想了解更多关于金融的知识，我们将在我们的GitHub回购中留下一些与这门课程相关的链接。

14142
19:21:07.254 --> 19:21:13.083
你可以学到更多金融知识，成为我所说的逆量化工程师，逆量化工程师。

14143
19:21:13.083 --> 19:21:16.321
我很高兴有更多的挑战者进入这个领域。

14144
19:21:16.321 --> 19:21:19.258
好了，这是Ave应用程序。

14145
19:21:19.258 --> 19:21:28.083
它在Ave。市场上，我们现在在Avi的市场上，我们在这里所做的一切都将在主网上工作，但我们将在他们的测试网上使用它。

14146
19:21:28.083 --> 19:21:33.117
这显然是旧的UI，他们有一个新网站看起来比这个更好。

14147
19:21:33.117 --> 19:21:38.532
但我们将经历很多基本功能，存款，贷款，甚至可能做空资产，如果我们想，

14148
19:21:38.532 --> 19:21:43.789
我不建议去这个网站，因为它可能不会工作和冠状病毒的方式，你期待它。

14149
19:21:43.789 --> 19:21:45.851
所以，坐好，放松，看着。

14150
19:21:45.851 --> 19:21:48.596
为了让我们做空或保证金交易。

14151
19:21:48.596 --> 19:21:55.433
我们需要做的第一件事实际上是存放一些抵押品，我们需要存放一些抵押品以便以这种方式借款。

14152
19:21:55.433 --> 19:22:03.838
如果我们永远无法偿还我们借的贷款或者我们借的钱，Ave，我们就会直接拿走我们放在这里的抵押品，我们会进行所谓的清算赎回。

14153
19:22:03.838 --> 19:22:07.187
这就是为什么这实际上比传统市场的卖空更安全。

14154
19:22:07.187 --> 19:22:15.508
因为如果你的抵押品少于你所借的，你会立即被清算，但你仍然会损失一大笔钱，所以不要被清算。

14155
19:22:15.508 --> 19:22:24.323
所以我们现在要做的是滚动到Aetherium，我们要在这里连接我们的钱包，我们要在这里移动到COVID测试网络浏览器。

14156
19:22:24.323 --> 19:22:27.357
我们要讲的是存款部分。

14157
19:22:27.357 --> 19:22:32.196
这里已经显示出平衡了，点2 /。

14158
19:22:32.196 --> 19:22:34.196
我们存0。

14159
19:22:34.196 --> 19:22:34.321
1.

14160
19:22:34.696 --> 19:22:38.889
我们要去存款，超膜会弹出，确认。

14161
19:22:39.696 --> 19:22:46.299
这个通过了，这意味着我们已经把它存入了我们到仪表板上，我们可以看到这里有

14162
19:22:46.299 --> 19:22:52.903
一些，第一点有一些API，这有点像我们将从存入Ave中得到的回报百分比。

14163
19:22:52.903 --> 19:22:58.123
是的，我们可以用它作为抵押品，我们有这个，这里标记为是。

14164
19:22:58.123 --> 19:23:00.506
这就是我们要做的。

14165
19:23:00.506 --> 19:23:01.886
上面说没有借过。

14166
19:23:01.886 --> 19:23:03.960
是的，我们可以点击这个“立即借用”按钮。

14167
19:23:03.960 --> 19:23:09.180
我们将进入借款人界面，我们将选择我们想借的资产。

14168
19:23:09.180 --> 19:23:14.047
现在，每当我们借用其中一个，就有了这些API，对吧?

14169
19:23:14.047 --> 19:23:18.915
这是为了借到这笔资产，我们在一年内需要支付的百分比。

14170
19:23:18.915 --> 19:23:26.822
稳定的意味着它永远是for变量的意思是它会根据协议的流动性变化而变化，你可以选择

14171
19:23:26.822 --> 19:23:34.729
你想要的是哪一个稳定的是你总是4%的变量会有一点风险，但你可能会得到更低的费用。

14172
19:23:34.729 --> 19:23:39.297
所以我们实际上要借一些染料，因为染料是稳定的硬币。

14173
19:23:39.297 --> 19:23:40.230
它值1美元。

14174
19:23:40.230 --> 19:23:49.070
在某种程度上，你可以称之为保证金提取因为我们提取染料去借另一种方式我们可以说我们在做空染料这听起来有点有趣，但你

14175
19:23:49.070 --> 19:23:57.911
可以选择你想借多少你会看到这个叫做健康因子的东西我把它放大一点当我们滚动这个东西的时候，这个叫做健康因子的东西。

14176
19:23:57.911 --> 19:24:02.475
健康因子表示你离被清算有多近记得我说过你

14177
19:24:02.475 --> 19:24:07.268
可以被清算健康因子表示我们离被清算有多近。

14178
19:24:07.268 --> 19:24:11.897
这意味着我们接近于总是说，你知道我们拿了你的钱。

14179
19:24:11.897 --> 19:24:19.605
如果它在任何时候低于1，就会有人对你进行清算并拿走我们存入的大量存款，健康因素背后有

14180
19:24:19.605 --> 19:24:27.497
一些数学运算，你可以去Ave文档，我会在描述中留一个链接来阅读更多关于健康因素的内容。

14181
19:24:27.497 --> 19:24:31.698
我们要借29个骰子，我们要借30元。

14182
19:24:31.698 --> 19:24:36.404
点击继续，输入一个变量，缩小，继续，我们

14183
19:24:36.404 --> 19:24:41.347
会借用metamath弹出，确认事务挂起。

14184
19:24:41.347 --> 19:24:42.682
我们要去仪表盘。

14185
19:24:42.682 --> 19:24:49.967
现在我们可以看到新的余额，我们可以看到每个点，存入，29个死亡。

14186
19:24:49.967 --> 19:24:56.920
我们可以在这里看到我们的健康系数，你甚至可以点击这个小按钮，说，嘿，它代表你离被

14187
19:24:56.920 --> 19:25:03.873
清算有多近，我们可以在这里看到价值，我们的生命值200美元，或者死亡值30美元。

14188
19:25:03.873 --> 19:25:04.364
所以我们没问题。

14189
19:25:04.364 --> 19:25:05.276
我们在这里很健康。

14190
19:25:05.276 --> 19:25:12.138
为了让Avi了解并为基础抵押品定价，这样它就知道能借出多少钱。

14191
19:25:12.138 --> 19:25:18.123
显然，另一种协议使用了改变价格对价格的反馈，也就是基础抵押品，

14192
19:25:18.123 --> 19:25:23.915
很多数十亿美元的协议在后端使用了链连接来实现所有的定价机制。

14193
19:25:23.915 --> 19:25:29.766
这就是它的本质，我们可以偿还债务，我们可以借更多资产，我们可以交换资产。

14194
19:25:29.766 --> 19:25:34.649
我们暂停资产的利息回报是惊人的。

14195
19:25:34.649 --> 19:25:42.587
现在我们学了一点如何使用他们的UI，它是在IPFS上托管的，顺便说一下，让我们继

14196
19:25:42.587 --> 19:25:50.525
续，让我们学习如何做所有这些，让我们更编程地做，这样我们就可以成为量子工程师了。

14197
19:25:50.698 --> 19:25:55.784
现在，就像我说的，我们将使用Ave v 2协议，如果你想尝试v3，

14198
19:25:55.784 --> 19:26:00.870
你完全可以，如果你现在可以去那里玩，它仍然锁定了更多的钱，这很好。

14199
19:26:00.870 --> 19:26:03.101
但是v3协议显然是最新加入的。

14200
19:26:03.101 --> 19:26:06.660
我们会在文档和代码库之间来回切换。

14201
19:26:06.698 --> 19:26:09.456
所以我建议你们把文档也准备好。

14202
19:26:09.698 --> 19:26:15.032
通常，我们将要使用的所有代码都在这个硬帽定义的Free code Camp库中。

14203
19:26:15.032 --> 19:26:16.150
让我们开始吧。

14204
19:26:16.150 --> 19:26:20.768
这里是by VS code，这里是这门课的文件夹，我们要新建一

14205
19:26:20.768 --> 19:26:25.387
个文件夹，命名为hard hat，违抗FCC，然后cd到里面。

14206
19:26:25.387 --> 19:26:29.099
然后我们将用代码期来打开它。

14207
19:26:29.099 --> 19:26:33.408
或者你也可以按惯例，打开文件，然后打开那个文件夹。

14208
19:26:33.408 --> 19:26:38.635
现在我们在做一个新项目，我们要做纱线，添加dash Dev，不是帽子。

14209
19:26:38.699 --> 19:26:42.339
我们将添加安全帽开始我们的极简安全帽项目。

14210
19:26:42.339 --> 19:26:50.664
再一次，为了启动您的极简的硬帽项目，我通常只是从另一个文件夹复制粘贴，或者我只是使用我们在智能合约代码repo中看到的硬帽启动工具包。

14211
19:26:50.664 --> 19:26:57.215
但是无论你用什么方法来启动你的项目，你都可以使用现在我们有了这个，我们可以运行yarn hardhat。

14212
19:26:57.215 --> 19:26:59.512
我们将创建一个空的硬帽。

14213
19:26:59.512 --> 19:26:59.817
配置。

14214
19:26:59.817 --> 19:26:59.918
js。

14215
19:26:59.918 --> 19:27:04.546
现在为了节省一些制作样板的时间，我要复制粘贴我的安全帽。

14216
19:27:04.546 --> 19:27:04.952
配置。

14217
19:27:04.952 --> 19:27:09.682
Js从一个过去的项目到这个，只是使它，这样我们就不必再通过那个样板设置。

14218
19:27:09.682 --> 19:27:13.652
我还要复制粘贴智能合约彩票的这句话。

14219
19:27:13.699 --> 19:27:18.021
同样，如果你想使用你的JSON包或yarn点锁来安装依赖项，你完全可以。

14220
19:27:18.021 --> 19:27:21.190
我要把它粘贴到这里，然后运行。

14221
19:27:21.190 --> 19:27:28.010
然后复制粘贴到我的漂亮文件上，这样所有的JavaScript都可以按照我想要的方式格式化。

14222
19:27:28.010 --> 19:27:28.403
好了,好了。

14223
19:27:28.403 --> 19:27:33.572
现在我们已经有了一个极简的项目，让我们继续，开始学习如何在这里与AVI协议交互。

14224
19:27:33.572 --> 19:27:37.062
让我们快速自述一下并讨论一下我们希望能够做什么。

14225
19:27:37.062 --> 19:27:41.953
首先，我们希望能够学习如何以编程方式存放抵押品。

14226
19:27:41.953 --> 19:27:47.276
如果我们停在这里，那可能就足够了，我们就能程序化地存入抵押品，

14227
19:27:47.276 --> 19:27:52.771
这样我们就能获得收益，我们就能从存入的抵押品中获得百分比回报率。

14228
19:27:52.771 --> 19:27:55.356
因此，完成这一任务本身已经是一项壮举。

14229
19:27:55.356 --> 19:28:00.649
但假如我们想更进一步，我们想进入这些更有趣的金融产品。

14230
19:28:00.700 --> 19:28:08.175
在存入一些抵押品之后，我们将学习如何通过编程借入其他资产，存入的抵押品将是斜

14231
19:28:08.175 --> 19:28:15.650
线包装的，我们稍后会讲到，我们将借入另一种资产，在这个演示中，它将是dye。

14232
19:28:15.650 --> 19:28:19.896
我们使用染料的原因是染料被称为稳定的硬币。

14233
19:28:19.896 --> 19:28:27.527
染料实际上是由道琼斯公司创造的区块链上的一个代币染料代币的价格总是固定在1美元。

14234
19:28:27.527 --> 19:28:35.391
我们把每一个作为抵押品，我们借加密货币，美元，我们借这个代币，它代表一美元，然

14235
19:28:35.391 --> 19:28:43.458
后我们将偿还它，我将偿还几乎所有的东西你马上就会明白为什么我们不偿还所有的东西。

14236
19:28:43.458 --> 19:28:46.527
我想快速讨论的另一个协议是uniswap协议。

14237
19:28:46.527 --> 19:28:49.914
uniswap协议已经成为交易的避风港。

14238
19:28:49.914 --> 19:28:54.684
这是一个去中心化的应用程序，允许我们在一个

14239
19:28:54.684 --> 19:28:59.454
叫做自动做市商的东西上彼此交易资产和代币。

14240
19:28:59.454 --> 19:29:05.257
它基本上结束了一个去中心化的证券交易所，但是有代币，代币并不是确切的股票，它们非常不同。

14241
19:29:05.257 --> 19:29:10.768
所以当你想要得到这些资产的时候就像包装好的Aetherium或染料或链接代币。

14242
19:29:10.768 --> 19:29:15.454
在主网上，通常，你会使用这些去中心化交换之一。

14243
19:29:15.454 --> 19:29:20.368
很明显，这些去中心化的交易所更加公平，因为在它们上面发生的一切都

14244
19:29:20.368 --> 19:29:25.436
是透明的，比中心化的金融公平得多，在它们上面发生的一切都是透明的。

14245
19:29:25.436 --> 19:29:30.343
你可以看到链上发生的一切，这绝对是现象级的。

14246
19:29:30.343 --> 19:29:32.653
让我们从这里开始。

14247
19:29:32.653 --> 19:29:34.605
我们来创建脚本文件夹。

14248
19:29:34.701 --> 19:29:40.335
因为在这个项目中，我们并不会自己创建任何契约，我们只会学习如何与这些协议交互。

14249
19:29:40.335 --> 19:29:46.601
如果您确实想学习如何构建其中一些协议，在本节课的最后，我们将为您提供大量链接。

14250
19:29:46.601 --> 19:29:51.911
我们将有一位特别嘉宾解释几种不同的方法来学习如何构建更多的去中心化协议。

14251
19:29:51.911 --> 19:29:56.044
虽然我们已经用去中心化彩票建立了一个，这很棒。

14252
19:29:56.044 --> 19:29:57.628
让我们在这里创建一些脚本。

14253
19:29:57.628 --> 19:30:01.055
对于所有这些东西，存入抵押品，借入和偿还。

14254
19:30:01.055 --> 19:30:05.210
我们将把这些都放到一个名为Ave borrow。Jas的新脚本中。

14255
19:30:05.210 --> 19:30:07.586
所以我们要在这里做所有事。

14256
19:30:07.586 --> 19:30:12.251
因为这是一个脚本，它会有相同的设置，就像我们之前看到

14257
19:30:12.251 --> 19:30:17.097
的一样，我们会有这个主要的东西围绕一个async函数。

14258
19:30:17.097 --> 19:30:20.442
主菜单，然后是我们的进口菜单，当然是在最上面。

14259
19:30:20.442 --> 19:30:26.836
有件事很重要，我们去avi，我们去协议，我们通读文档，

14260
19:30:26.836 --> 19:30:32.995
最终我们会发现协议把所有东西都当作ERC 20令牌。

14261
19:30:32.995 --> 19:30:40.614
但我们知道Aetherium或你正在使用的原生区块链代币不是ERC 20代币。

14262
19:30:40.701 --> 19:30:46.601
把所有东西都当成ERC 20代币的原因是这样更容易，对吧?如果

14263
19:30:46.601 --> 19:30:52.501
所有东西都使用ERC 20令牌标准，那么发送和交互就容易得多。

14264
19:30:52.701 --> 19:30:59.970
在很多这样的协议中，当我们要存入以太币，或多边形，或任意标记等等，实际发生的情况是，他

14265
19:30:59.970 --> 19:31:07.239
们将你的以太币通过所谓的网络网关发送，并将其交换为weath，即rapt ether。

14266
19:31:07.239 --> 19:31:09.668
基本上就是Aetherium。

14267
19:31:09.668 --> 19:31:17.074
但在ERC 20令牌合约中，我们想做的是做同样的事情，我们会跳过使用这个网络网关。

14268
19:31:17.074 --> 19:31:21.352
我们自己就会得到网络令牌，我们会用它作为抵押品。

14269
19:31:21.352 --> 19:31:26.035
在script标签中，我将创建另一个文件getweath。

14270
19:31:26.035 --> 19:31:26.168
js。

14271
19:31:26.168 --> 19:31:35.130
在这里，我们会继续，我们会建立一个脚本来存放我们的令牌为web令牌。

14272
19:31:35.130 --> 19:31:36.701
好了，让我们创建脚本。

14273
19:31:36.701 --> 19:31:40.960
在以太扫描和GitHub回购中有一个到web令牌的链接。

14274
19:31:40.960 --> 19:31:44.572
它的工作方式是，你把Aetherium存起来。

14275
19:31:44.702 --> 19:31:49.321
作为回报，它会给你里格比的网络代币，存入0。

14276
19:31:49.321 --> 19:31:49.511
05.

14277
19:31:49.511 --> 19:31:56.152
继续写，我连接到以太扫描，我继续写这个交易，我要喝尿。

14278
19:31:56.152 --> 19:32:00.831
所以我并不在乎这是不是真正的合同，因为这不是真正的钱。

14279
19:32:00.831 --> 19:32:02.292
但我要存入0。

14280
19:32:02.292 --> 19:32:02.751
05年容易的。

14281
19:32:02.751 --> 19:32:11.393
交易完成后，我们复制合同地址，将这个令牌添加到Metamask中就像添加链接一样导入令

14282
19:32:11.393 --> 19:32:20.035
牌，将地址粘贴到这里，添加自定义令牌，导入令牌会看到这里有一些wet令牌，我存入了0。

14283
19:32:20.035 --> 19:32:21.066
0前面是1。

14284
19:32:21.066 --> 19:32:21.782
1 + 0。

14285
19:32:21.782 --> 19:32:23.959
05，这就是为什么它显示为0。

14286
19:32:23.959 --> 19:32:27.809
因为我做了两次，嗯，在我没有录音的时候。

14287
19:32:27.809 --> 19:32:31.102
这就是把这个湿代币写进合同的方法。

14288
19:32:31.102 --> 19:32:34.502
你可以随时调用这个取款函数。

14289
19:32:34.502 --> 19:32:39.029
你可以把你的Aetherium取出来然后做所谓的烧掉你的湿代币。

14290
19:32:39.029 --> 19:32:44.333
当你从weather换回Aetherium时，你按下取款键，然后你基

14291
19:32:44.333 --> 19:32:49.638
本上就把它们换回来了因为合约本身现在持有你的Aetherium代币。

14292
19:32:49.702 --> 19:32:54.226
很酷，对吧?在get wet函数中，我们不会在这里添加这个主函数，我们会在

14293
19:32:54.226 --> 19:32:58.750
这里创建get West作为一个模块我们会将它导入Ave borrow中。

14294
19:32:58.750 --> 19:33:01.957
所以我们不打算做你们在这里看到的这个主要的东西。

14295
19:33:01.957 --> 19:33:06.325
相反，我们将创建一个名为Get Wes的异步函数。

14296
19:33:06.325 --> 19:33:09.864
下面，我们要导出它。

14297
19:33:09.864 --> 19:33:14.509
我们写module。exports = get weather。

14298
19:33:14.703 --> 19:33:22.356
我们要导出它这样我们的Avi borrow就可以使用我们正在创建的get West脚本，让我们添加让我们来做这个。

14299
19:33:22.356 --> 19:33:26.369
为了与合同交互，我们需要一个账户。

14300
19:33:26.369 --> 19:33:33.555
我们可以按惯例执行const deployer = await get named accounts。

14301
19:33:33.555 --> 19:33:37.082
我们写入const getname accounts = require hardhat。

14302
19:33:37.082 --> 19:33:39.392
我的VS code自动导入了，谢谢VS code。

14303
19:33:39.392 --> 19:33:46.582
现在我们要调用西边契约的存款函数。

14304
19:33:46.703 --> 19:33:51.771
我们如何称呼西部合同的存款功能?那合同怎么称呼呢?

14305
19:33:51.771 --> 19:33:56.638
那你需要什么?你需要ABI，然后你需要合同地址。

14306
19:33:56.703 --> 19:33:57.399
把这个钻进去。

14307
19:33:59.703 --> 19:34:02.003
与合同交互的合同地址。

14308
19:34:02.703 --> 19:34:09.998
如果我们知道如果我们给我们的项目整个合同，它会得到API但我们也知道如果我们只做接口，那也

14309
19:34:09.998 --> 19:34:17.457
一样好，它不会给我们所有的功能，但它会告诉它会给我们API，它会告诉我们它可以使用什么功能。

14310
19:34:17.457 --> 19:34:21.799
我们要创建一个新文件夹，创建合约文件夹。

14311
19:34:21.799 --> 19:34:25.211
在这里，我们会在里面创建一个新文件夹叫做interfaces。

14312
19:34:25.211 --> 19:34:28.274
这就是我们要创建网页界面的地方。

14313
19:34:28.274 --> 19:34:32.623
现在一个web界面将会非常类似于ERC 20的界面。

14314
19:34:32.623 --> 19:34:36.672
如果你想自己添加，请随意。

14315
19:34:36.672 --> 19:34:42.549
或者你可以直接访问与这节课相关的GitHub回购，

14316
19:34:42.549 --> 19:34:48.897
到iOS上复制粘贴，你会看到这里的功能和ERC 20完

14317
19:34:48.897 --> 19:34:55.481
完全一样，允许批准的小数点余额，还有这些额外的存取款功能。

14318
19:34:55.481 --> 19:35:03.976
复制所有这些，回到我的安全帽项目，创建一个新文件，命名为I left。soul。

14319
19:35:03.976 --> 19:35:08.756
需要注意的是，通常，最好的做法是有接口，从眼睛开

14320
19:35:08.756 --> 19:35:13.736
始，这样你就知道接口是什么然后我们把它粘贴到这里。

14321
19:35:13.736 --> 19:35:17.359
现在为了编译它，我们需要使用0。

14322
19:35:17.359 --> 19:35:19.818
4分19版牢固性。

14323
19:35:19.818 --> 19:35:23.867
所以我们能做的是，我们可以回过头来。

14324
19:35:23.867 --> 19:35:24.260
配置。

14325
19:35:24.260 --> 19:35:24.391
js。

14326
19:35:24.391 --> 19:35:27.059
我们有坚实的编译器，版本0。

14327
19:35:27.059 --> 19:35:31.514
07或者其他版本的，我们可以添加或者替换。

14328
19:35:31.514 --> 19:35:35.551
我在这里加个逗号，版本0。

14329
19:35:35.551 --> 19:35:36.906
4点19分。

14330
19:35:36.906 --> 19:35:37.583
保存。

14331
19:35:37.583 --> 19:35:41.989
现在为了确保我们能得到那个API，做yarn,

14332
19:35:41.989 --> 19:35:47.929
hardhats编译，或者hh编译，很好，我们编译这个接口。

14333
19:35:47.929 --> 19:35:50.304
现在我们有了ABI来进行交互。

14334
19:35:50.304 --> 19:35:55.654
现在我们有了ABI，这里有一个小的复选标记，让我们继续并获取合同地址。

14335
19:35:55.704 --> 19:35:58.419
但是因为我们很快就会学到的原因，

14336
19:35:58.419 --> 19:36:07.754
我们实际上只会使用主网络集来获取Rinkeby测试和地址，我将在主网络上查找，我们将在主网络上找到web令牌。

14337
19:36:07.754 --> 19:36:10.229
所以我要复制主网的地址。

14338
19:36:10.229 --> 19:36:16.067
同样，你也可以从与这节课相关的GitHub回购中获取这个地址。

14339
19:36:16.067 --> 19:36:21.043
现在，我们会在这里打个勾，然后把地址粘贴到这里。

14340
19:36:21.043 --> 19:36:26.080
现在我们有了从接口编译的ABI，我们有了主网的合同地址。

14341
19:36:26.080 --> 19:36:28.330
现在让我们继续创建这个契约。

14342
19:36:28.330 --> 19:36:37.117
我们可以说const, iOS = await ethers。然后我们还需要从Hardhead导入ethers。

14343
19:36:37.117 --> 19:36:44.966
Ethers。get contract at这是Ethers上的另一个功能，它允许我们在特定地址上获取

14344
19:36:44.966 --> 19:36:52.816
合约，我们说get contract app，我们现在用的是iOS ABI，我们在这里硬编码这个地址。

14345
19:36:52.816 --> 19:36:55.092
然后我们将它连接到部署器。

14346
19:36:55.092 --> 19:37:02.068
我们说，让我们与ABI的iOS在这个地址连接到Deployer。

14347
19:37:02.068 --> 19:37:07.276
所以我们可以继续运行await AI并进行点存款。

14348
19:37:07.276 --> 19:37:10.450
我们会设置一些数值。

14349
19:37:10.450 --> 19:37:14.953
让我们继续，在顶部，我们写上const amount

14350
19:37:14.953 --> 19:37:21.882
=我们写上ethers。utils。parse, ether，然后我们写上0。

14351
19:37:21.882 --> 19:37:22.220
0 0。

14352
19:37:22.220 --> 19:37:22.445
02.

14353
19:37:22.445 --> 19:37:24.805
存入0。

14354
19:37:24.805 --> 19:37:32.475
02会说const TX =这就会做await TX。wait one等待一个block通过。

14355
19:37:32.475 --> 19:37:36.505
然后我们会得到余额会说const。

14356
19:37:36.505 --> 19:37:42.015
与雇主的差额等于等待我与雇主的差额。

14357
19:37:42.015 --> 19:37:47.020
我们将调用iWeb ERC 20令牌上的balance函数。

14358
19:37:47.020 --> 19:37:54.659
然后我们用console。log得到West balance。

14359
19:37:54.659 --> 19:37:56.333
字符串。

14360
19:37:56.706 --> 19:37:58.856
这里我们用的是主网络地址。

14361
19:37:59.706 --> 19:38:01.899
说好吧，我们要存入一些钱，我们要等待。

14362
19:38:01.899 --> 19:38:07.747
然后我们要继续保持平衡，我们把Aetherium存进去这样我们就能

14363
19:38:07.747 --> 19:38:13.596
得到ERC 20版本的Aetherium，也就是这个West代币。

14364
19:38:13.706 --> 19:38:19.170
现在，你可能会想，好吧，为什么你把主地址放在这里?帕特里克，走慢点。

14365
19:38:19.170 --> 19:38:23.635
让我们继续，让我们创建一个模拟Web Token合同地址。

14366
19:38:23.706 --> 19:38:31.826
让我们先部署模拟，然后我们继续使用我们一直在做的相同的设置，为什么你要直接硬编码这个在这里。

14367
19:38:31.826 --> 19:38:34.610
我已经提到这个有一段时间了。

14368
19:38:34.610 --> 19:38:38.706
但我们还有另一种方法可以在智能合约中运行测试。

14369
19:38:38.706 --> 19:38:47.028
这就是所谓的主网分叉，我们可以在主网分叉的地方，运行一个本地硬帽节点。

14370
19:38:47.028 --> 19:38:50.253
这是假装成网络主节点。

14371
19:38:50.253 --> 19:38:54.706
我们所要做的就是更新我们的硬头配置来做到这一点。

14372
19:38:54.706 --> 19:38:57.050
我们来谈谈分叉的问题。

14373
19:38:57.050 --> 19:39:02.023
在左边这里，我们有区块链区块链的一个例子它类似于一个测

14374
19:39:02.023 --> 19:39:06.996
试网或主网像Rinkeby, eath，主网多边形等。

14375
19:39:06.996 --> 19:39:10.127
这将是我们部署到的区块链。

14376
19:39:10.127 --> 19:39:14.994
这里有一大堆方块，对吧?我们有一个巨大的链条可以利用。

14377
19:39:14.994 --> 19:39:20.741
区块链上的所有信息都是公共信息，比如这

14378
19:39:20.741 --> 19:39:26.792
个区块将有交易，每个区块将有一大堆交易。

14379
19:39:26.792 --> 19:39:29.528
所有这些信息都在这个公共区块链上。

14380
19:39:29.528 --> 19:39:37.657
除了所有这些交易，它还会有价格供给合约，它会有Ave合约，网络代币，合约等。

14381
19:39:37.707 --> 19:39:40.852
所有这些合同信息都是公开的。

14382
19:39:42.707 --> 19:39:50.373
它已经在那里了，我们基本上可以把它复制到我们的本地环境中，自己做一些模拟。

14383
19:39:50.373 --> 19:39:53.216
这正是分叉所做的。

14384
19:39:53.216 --> 19:40:01.564
一个分叉区块链取一个现有区块链的副本就像左边的这个，把它带到我们的本地计算机上。

14385
19:40:01.564 --> 19:40:08.653
我们实际上可以控制本地运行的区块链，因为它会在本地计算机上运行，类似于hard hat。

14386
19:40:08.707 --> 19:40:16.168
现在，我们在这个局部分叉区块链上所做的一切都不会影响到主区块链，因为它是一个模拟区块链。

14387
19:40:16.168 --> 19:40:18.152
它只是在我们当地的环境中运行。

14388
19:40:18.152 --> 19:40:24.657
所以我们实际上可以与这个分叉互动这种局部的区块链类似于模仿实际的区块链。

14389
19:40:24.707 --> 19:40:29.516
这就是分叉所不做的，它不会下载整个区块链到我们的本地设置中。

14390
19:40:29.516 --> 19:40:31.069
任何时候我们引用一个地址。

14391
19:40:31.069 --> 19:40:38.355
当我们引用某个特定地址的东西时，我们调用一个API到Aetherium节点，同

14392
19:40:38.355 --> 19:40:45.641
样，我们使用了炼金术，然后说，这个地址有什么，它就会为我们返回那个特定的契约。

14393
19:40:45.707 --> 19:40:47.671
这样，我们就不用下载整个区块链了。

14394
19:40:47.707 --> 19:40:48.771
而且速度也快得多。

14395
19:40:50.707 --> 19:40:52.816
我们的测试运行我们的脚本来完成所有的事情。

14396
19:40:53.707 --> 19:40:55.167
你会想，哇，帕特里克，这听起来太棒了。

14397
19:40:55.707 --> 19:40:58.658
我们什么都这么做吗?嗯，这是需要权衡的。

14398
19:40:58.707 --> 19:41:03.034
优点是它快速、简单，而且测试与主网上的类似。

14399
19:41:03.034 --> 19:41:07.264
缺点是我们需要一个API，我们不能在本地做所有事情。

14400
19:41:07.264 --> 19:41:12.023
有些契约，有些契约处理起来比较复杂，而mock可能更好。

14401
19:41:12.023 --> 19:41:16.953
但是使用分叉网络可能是运行测试的好方法，它可能是只使用mock的一个很好的替代方法。

14402
19:41:16.953 --> 19:41:20.774
所以这真的取决于什么对你和你的项目是正确的。

14403
19:41:20.774 --> 19:41:26.129
但是它是一个非常棒的工具，特别是对于像Avi这样我们想要快速测试一些东西的工具。

14404
19:41:26.129 --> 19:41:30.347
硬分叉也会给我们一堆假账号。

14405
19:41:30.347 --> 19:41:35.134
所以我们仍然会在主网上得到一堆假账户，我们会给出一个定理。

14406
19:41:35.134 --> 19:41:37.658
所以我们会得到这个分叉的假的主网络账户。

14407
19:41:37.658 --> 19:41:42.035
接下来，我们将使用这个分叉来运行脚本和测试。

14408
19:41:42.035 --> 19:41:46.108
如果你想在这之后回去，在COVID上尝试所有这些。

14409
19:41:46.108 --> 19:41:51.095
我们为COVID网络提供了一大堆不同的地址，所以你可以直接在COVID上运行这些脚本。

14410
19:41:51.095 --> 19:41:53.127
你可以自己看到交易。

14411
19:41:53.127 --> 19:41:57.748
请注意，在使用COVID时，您需要确保使用的地址与AVI

14412
19:41:57.748 --> 19:42:02.535
文档中为COVID网络使用的地址相同，因为它们有时会更改。

14413
19:42:02.535 --> 19:42:06.242
很好，我们继续，我们会到RT head。config。js。

14414
19:42:06.242 --> 19:42:12.514
现在我们来看看我们的网络，现在我什么都没有，我只有排名。

14415
19:42:12.514 --> 19:42:17.408
我们在这里加上安全帽，在下面加上一个小逗号。

14416
19:42:17.408 --> 19:42:21.623
我们会说，链ID当然是31337。

14417
19:42:21.623 --> 19:42:23.691
我们将添加这个分叉关键字。

14418
19:42:23.691 --> 19:42:28.930
在这里，我们会说Forking的URL将是我们的主网RPC URL。

14419
19:42:28.930 --> 19:42:32.216
这是我们使用炼金术的另一个原因。

14420
19:42:32.216 --> 19:42:36.803
炼金术公司在这些分叉的区块链方面非常出色，而且有非常好的区块链。

14421
19:42:36.803 --> 19:42:41.298
我们能做的是回到炼金术仪表盘，我们会创建一个新应用。

14422
19:42:41.298 --> 19:42:46.408
这个将用于Aetherium主网，我们将说分叉链。

14423
19:42:46.408 --> 19:42:52.539
我们会说，对于分叉，我们会继续在一个理论和主网上创建这个。

14424
19:42:52.539 --> 19:42:56.353
现在我们有了分叉链，我们可以做同样的事情。

14425
19:42:56.353 --> 19:43:04.644
获取API键，回到项目，创建这个新文件，创建。env。

14426
19:43:04.644 --> 19:43:08.878
我们写上main net RPC URL =，然后粘贴到这里。

14427
19:43:08.878 --> 19:43:16.146
在我们的Hardhead配置中，我们现在将从主网RPC URL分叉每当我们在区块链使用心脏。

14428
19:43:16.146 --> 19:43:21.709
现在我们有了这个，让我们继续运行这个get wet函数。

14429
19:43:21.709 --> 19:43:27.328
因为我们要用叉子叉区块链，我们应该可以继续模拟这个。

14430
19:43:27.328 --> 19:43:33.215
收回一个借式，我们继续我们执行const, get weath =

14431
19:43:33.215 --> 19:43:40.173
require然后我们拉这个脚本。。scripts / get weath。

14432
19:43:40.173 --> 19:43:45.676
然后，在主函数中，我们运行await yet。

14433
19:43:45.676 --> 19:43:53.116
为了在这里运行我们的脚本，我们将运行yarn hard hat，运行脚本avevamo。

14434
19:43:53.116 --> 19:43:53.375
js。

14435
19:43:53.375 --> 19:43:56.293
我们的默认网络是硬帽。

14436
19:43:56.293 --> 19:43:59.042
所以我们要么做网络硬帽，要么直接运行。

14437
19:43:59.042 --> 19:44:03.982
记住，因为在我们的配置中，我们说，嘿，当我们运行硬帽链时，使

14438
19:44:03.982 --> 19:44:09.088
用这个分叉，我们将会分叉，所以让我们继续运行这个跑到空气总管。

14439
19:44:09.088 --> 19:44:10.812
Net RPC URL未定义。

14440
19:44:10.812 --> 19:44:12.442
嗯，这很有道理。

14441
19:44:12.442 --> 19:44:20.160
让我们继续并添加这个完善的RPC rel等于过程研究和v点使它RPC URL。

14442
19:44:20.160 --> 19:44:22.155
让我们再试一次。

14443
19:44:22.155 --> 19:44:25.709
我们现在看到，我们有这么多财富，同样，

14444
19:44:25.709 --> 19:44:31.509
这笔财富将是1-234-567-8910 1234567 0。

14445
19:44:31.509 --> 19:44:35.972
财富，这正是我们想要的。

14446
19:44:35.972 --> 19:44:41.010
现在我们有了一种本地与主网交互的方法，这听起来有点疯狂。

14447
19:44:41.010 --> 19:44:44.431
但我们在这里做的正是他的强大之处。

14448
19:44:44.431 --> 19:44:52.460
所以我们有办法fork main，运行我们的脚本，并进行某种测试，看看和模拟实际运行这些事务是什么样子的。

14449
19:44:52.460 --> 19:44:56.201
我们这样做，我们的get with函数看起来很好。

14450
19:44:56.201 --> 19:45:02.553
显然，我们仍然会将它模块化，我们把它放到助手Hardhead配置中，但我们现在跳过这个。

14451
19:45:02.553 --> 19:45:04.428
让我们回到AVI borrow。

14452
19:45:04.428 --> 19:45:06.960
让我们继续把剩下的部分充实起来。

14453
19:45:06.960 --> 19:45:09.290
现在，让我们继续，在这里设置样板的其余部分。

14454
19:45:09.290 --> 19:45:15.376
我们用const Deployer，因为我们需要一个帐户，显然= await，得到命名帐户。

14455
19:45:15.376 --> 19:45:20.306
然后我们用const get named accounts = require。

14456
19:45:20.306 --> 19:45:25.466
现在我们想开始与ABI协议交互，我们需要什么，

14457
19:45:25.466 --> 19:45:30.852
我们需要ABI和地址，没有变化，我们需要这两个。

14458
19:45:30.852 --> 19:45:33.090
所以我们能做的就是去Ave医院。

14459
19:45:33.090 --> 19:45:35.443
我们还是在v2上。

14460
19:45:35.443 --> 19:45:39.487
我们可以在这里找到合同地址。

14461
19:45:39.487 --> 19:45:44.981
现在的工作方式是，他们实际上有一个合同，它会指引我们找到正确的合同。

14462
19:45:44.981 --> 19:45:49.025
我们要做所有贷款的合同就是这个贷款池。

14463
19:45:49.025 --> 19:45:53.742
合同地址是通过合同获得的。

14464
19:45:53.742 --> 19:45:59.000
要获得借出池地址，我们必须访问借出池地址提供者。

14465
19:45:59.000 --> 19:46:02.235
这份合同会告诉我们出借人的地址。

14466
19:46:02.235 --> 19:46:06.972
我们可以看到部署契约部分，我们可以看到这个契约的地址。

14467
19:46:06.972 --> 19:46:09.145
我们可以看到所有主要的地址和新冠病毒。

14468
19:46:09.145 --> 19:46:11.613
再说一次，如果你想在COVID上玩这个。

14469
19:46:11.711 --> 19:46:17.644
但我们可以看到贷款池地址提供者将位于这里，我们可以复制这个地址。

14470
19:46:17.644 --> 19:46:21.553
我们来做一下笔记。

14471
19:46:21.711 --> 19:46:25.863
而这个贷款池，我们将从贷款远洋供应商那里获得。

14472
19:46:25.863 --> 19:46:31.961
让我们创建一个函数从贷款池地址提供者获取贷款池地址。

14473
19:46:31.961 --> 19:46:36.301
下面这里，我们会创建async function，获取lending pool。

14474
19:46:36.301 --> 19:46:39.497
现在为了与这个借贷池地址提供程序交互。

14475
19:46:39.497 --> 19:46:43.456
同样的，我们需要它的地址和它的API，我们有它的地址。

14476
19:46:43.456 --> 19:46:49.226
我们来获取它的API，你可以去到与这节课相关的GitHub回购。

14477
19:46:49.226 --> 19:46:51.616
从接口部分复制粘贴。

14478
19:46:51.711 --> 19:46:58.011
你也可以直接在区块链上看这个合同是什么样子的，我可以创建你自己的界面。

14479
19:46:58.011 --> 19:47:00.573
或者我们可以直接使用文档中的接口。

14480
19:47:00.573 --> 19:47:01.952
所以我们有岛屿帕拉赫。

14481
19:47:01.952 --> 19:47:05.254
提供者，我将从ABI文档中复制这个。

14482
19:47:05.254 --> 19:47:08.044
但同样，你有很多选择。

14483
19:47:08.044 --> 19:47:12.677
所以在我们的契约中在我们的界面中，让我们让我们坚持在界面中。

14484
19:47:12.677 --> 19:47:14.304
让我们创建一个新文件。

14485
19:47:14.304 --> 19:47:20.211
我们称它为I借出池地址提供者。soul。

14486
19:47:20.211 --> 19:47:23.773
我们把它粘贴到这里，我们看到我们用的是0。

14487
19:47:23.773 --> 19:47:24.398
6点12。

14488
19:47:24.398 --> 19:47:31.743
所以一定要在Hardhead配置中确保我们没有创建一个新的0。

14489
19:47:31.743 --> 19:47:38.627
6点12，然后我们会编译纱线Hardhead编译，编译太棒了。

14490
19:47:38.711 --> 19:47:45.758
现在我们有了ABI，我们会通过const借出池地址提供者= await

14491
19:47:45.758 --> 19:47:53.006
ethers。get contract at will来获取契约说I借出

14492
19:47:53.006 --> 19:47:59.449
池地址哦，地址作为借出池地址不好意思，我要更新名称I Lenny

14493
19:47:59.449 --> 19:48:06.697
pull addresses provider islding pool

14494
19:48:06.697 --> 19:48:15.356
addresses provider，我们要传递从Ovid文档中得到的契约地址。

14495
19:48:15.356 --> 19:48:16.542
粘贴进去。

14496
19:48:16.712 --> 19:48:19.212
然后我们会把它连接到部署器。

14497
19:48:19.712 --> 19:48:24.524
我们会有get lending pool，通过这个账户变量然

14498
19:48:24.524 --> 19:48:29.498
后我们会用这个账户来连接它我们要通过的账户当然是我们的部署者。

14499
19:48:29.498 --> 19:48:31.924
在我们的贷款池地址提供程序。

14500
19:48:31.924 --> 19:48:39.086
有一个函数得到贷款池返回衬里的地址池,这将是我们

14501
19:48:39.086 --> 19:48:46.248
要调用的函数所以我们会说const贷款池说地址=

14502
19:48:46.248 --> 19:48:53.410
重量贷款池地址探测地址池任何地址提供者说点得到贷

14503
19:48:53.410 --> 19:49:00.572
款池就是这样我们会贷款池的地址,然后我们将本合同

14504
19:49:00.572 --> 19:49:08.633
给我们贷款通过常量池合同贷款池=等待醚添加点得到合同。

14505
19:49:08.633 --> 19:49:14.712
我们需要做同样的事情，接口，接口，地址，然后是帐户。

14506
19:49:14.712 --> 19:49:20.131
回到文档中，我们可以通过这样复制来获取I的出借池。

14507
19:49:20.131 --> 19:49:26.779
我们会回到合约界面，new file, I lending pool，就是这样。

14508
19:49:26.779 --> 19:49:28.271
然后粘贴进去。

14509
19:49:28.271 --> 19:49:36.000
现在有了这个，如果我们滚动到顶部，我们会注意到我们从一些本地的地方导入这

14510
19:49:36.000 --> 19:49:43.729
些在我们的契约区域中是没有的，我们可以再一次从NPM添加AVI协议v2。

14511
19:49:43.729 --> 19:49:46.629
用这个作为我们的导入。

14512
19:49:46.629 --> 19:49:53.923
所以我们会写yarn，加上破折号dev和一个斜杠原型，叫做连字符v2。

14513
19:49:53.923 --> 19:49:59.066
现在我们在节点模块中有了Add Ave协议，我

14514
19:49:59.066 --> 19:50:04.434
们可以更新这些导入以指向节点模块而不是本地文件。

14515
19:50:04.434 --> 19:50:09.963
我将继续告诉你们，隔离质押提供者

14516
19:50:09.963 --> 19:50:15.838
是Ave /协议V /契约/接口。

14517
19:50:15.838 --> 19:50:22.108
然后数据类型。soul是一个协议的缩写v2斜杠契约斜杠，原型调用

14518
19:50:22.108 --> 19:50:28.574
斜杠库，斜杠类型，数据类型，这些都是为了确保这是正确的，yarn,

14519
19:50:28.574 --> 19:50:34.650
Hardhead compile或者hh, compile。

14520
19:50:34.650 --> 19:50:35.212
和酷。

14521
19:50:35.212 --> 19:50:42.043
看起来我做对了吗?出借池等于await醚。get contract at，

14522
19:50:42.043 --> 19:50:48.874
我们将使用出借池，我在这里出借池，我们将使用从地址提供者获得的出借池地址。

14523
19:50:48.874 --> 19:50:52.874
然后是账户，也就是我们的部署者。

14524
19:50:52.874 --> 19:50:56.551
现在我们可以做还贷池。

14525
19:50:56.551 --> 19:51:03.080
如果我们想，现在我们有了这个函数get lending pool backup在main函数中，

14526
19:51:03.080 --> 19:51:12.058
我们可以说const lending pool = a weight, get lending pool然后传递给Deployer。

14527
19:51:12.058 --> 19:51:16.671
然后我们还可以写console。

14528
19:51:16.671 --> 19:51:22.149
log，借出池地址然后写借出池。地址。

14529
19:51:22.149 --> 19:51:25.714
既然我们让它分叉，我们就可以一直这样运行下去。

14530
19:51:25.714 --> 19:51:29.414
所以我们会做纱线硬帽运行脚本。

14531
19:51:29.414 --> 19:51:35.651
Ave Baroda Jas，有多个用于合同II贷款池地址提供者的构件。

14532
19:51:35.651 --> 19:51:41.211
这是因为在节点模块中，从契约导入所有这些在这里，在islding

14533
19:51:41.211 --> 19:51:46.946
中，在那些addons / slash契约中，已经有池地址提供者。

14534
19:51:46.946 --> 19:51:52.664
实际上，我们甚至不需要这个，I lending pool addserviceprovider，我们可以删除它。

14535
19:51:52.664 --> 19:51:54.614
我们现在的时代越来越混乱了。

14536
19:51:54.714 --> 19:52:02.599
它会说，哦，你是指你从NPM下载的那个还是你自己做的那个，你想用哪个。

14537
19:52:02.599 --> 19:52:04.615
所以我们要让硬帽子更容易。

14538
19:52:04.714 --> 19:52:09.285
我们会删除我们创建的那个，我们会使用我们下载的那个。

14539
19:52:09.285 --> 19:52:11.369
现在我们应该可以再运行一次了。

14540
19:52:11.369 --> 19:52:16.649
因为现在只有一个可供选择，也就是我们从NPM下载的那个。

14541
19:52:16.714 --> 19:52:21.836
很好，我们在这里得到了我们的get weath打印结果，然后我们在这里得到了贷款池地址。

14542
19:52:21.836 --> 19:52:26.460
这将是以太以太主网上的实际贷款池地址。

14543
19:52:26.460 --> 19:52:32.328
如果我们回到以太扫描，复制这个地址并粘贴到以太扫描，我们可以看

14544
19:52:32.328 --> 19:52:38.386
到它甚至被标记为Ave v2，我们可以看到大量的交易一直在进行。

14545
19:52:38.386 --> 19:52:40.294
以太扫描很难跟上所有的事务。

14546
19:52:40.294 --> 19:52:47.711
我们有了借阅池地址，有了web令牌，我们需要做什么?现在我们想要存款，

14547
19:52:47.711 --> 19:52:54.916
为了存入代币我们需要什么?看一下avec GitHub中的存款函数，

14548
19:52:54.916 --> 19:53:01.909
滚动到这里，我们会看到它最终我们会调用这个安全转账它基本上是这个转

14549
19:53:01.909 --> 19:53:09.115
函数，因为我们调用了转账它将是这个合约，它实际上会从钱包中取出钱。

14550
19:53:09.115 --> 19:53:13.690
所以为了给Ave合同，从我们的钱包里取出钱的

14551
19:53:13.690 --> 19:53:18.266
能力，我们需要做我们需要做的事情来批准合同。

14552
19:53:18.266 --> 19:53:25.508
首先，在我们存钱之前我们需要批准它来获得我们的网络令牌，我们需要先获得网络令牌。

14553
19:53:25.508 --> 19:53:30.078
我们来获取Web Token地址我们写入const Web

14554
19:53:30.078 --> 19:53:35.436
Token地址，等于这是我们边缘化它的地方从硬头助手配置中获取它。

14555
19:53:35.436 --> 19:53:43.197
但现在，我们可以硬编码，Web Token契约地址将和get Web中的完全相同，然后想要批准。

14556
19:53:43.197 --> 19:53:47.857
让我们写一个被认可的函数因为我们会用到它几次。

14557
19:53:47.857 --> 19:53:55.142
我们会做一个async函数并批准ERC 20，我们

14558
19:53:55.142 --> 19:54:02.427
会取一个合约地址一个花费者地址，这将是我们要批准花

14559
19:54:02.427 --> 19:54:10.005
费代币的合约和花费的金额，我们想要证明它的确切数量。

14560
19:54:10.005 --> 19:54:13.069
然后有一个账户来做这些。

14561
19:54:13.069 --> 19:54:20.924
这里我们写const ERC 20 token = await ethers dot get contract at。

14562
19:54:20.924 --> 19:54:27.286
我们可以说I WEF但也许我们只是想要一个简单的ERC 20代币接口。

14563
19:54:27.286 --> 19:54:31.896
我们将通过欺骗一点硬币来抓住这一点，我们的硬脑袋违抗联邦通信委员会。

14564
19:54:31.896 --> 19:54:35.650
我们去界面，从这里抓取这个界面。

14565
19:54:35.650 --> 19:54:43.993
我们复制这个，粘贴到这里新建文件IO ERC 20。som粘贴现在我们有了ERC的ABI。

14566
19:54:43.993 --> 19:54:50.096
所以我们会签订合同，实际上，让我们把这个名字改成。

14567
19:54:50.096 --> 19:54:55.769
所以我们要和IRC ERC 20的ABI签订合同，在合同

14568
19:54:55.769 --> 19:55:01.645
地址ERC 20的地址，然后我们将它连接到我们这里的账户。

14569
19:55:01.716 --> 19:55:10.056
一旦我们有了ERC 20，我们可以做const TX，我们会做那个批准事务我们会做

14570
19:55:10.056 --> 19:55:18.601
一个ERC 20 token。批准花费者地址，然后是amount to spend。

14571
19:55:18.716 --> 19:55:21.841
我们会做一个wait TX。wait一个block。

14572
19:55:22.716 --> 19:55:25.941
一个小的控制台。log表示批准。

14573
19:55:27.716 --> 19:55:33.516
这个函数在你尝试存入之前你会得到一个错误，说，token未被批准，这是一个很常见的错误。

14574
19:55:33.516 --> 19:55:37.490
如果你看到这个，我忘记批准我的代币了。

14575
19:55:37.490 --> 19:55:41.409
在主脚本中备份，我们继续运行这个函数。

14576
19:55:41.409 --> 19:55:47.705
我们会说await approve ERC 20带有Web令牌地址借出

14577
19:55:47.705 --> 19:55:54.182
池。address因为我们想给len池批准从账户中提取我们的Web令牌。

14578
19:55:54.182 --> 19:56:00.028
然后我们会给它一些实际上也会从get weath导入一个坐骑。

14579
19:56:00.028 --> 19:56:04.890
Mount我们需要返回导出它，这样我们才能导入它。

14580
19:56:04.890 --> 19:56:07.974
导出这个0。

14581
19:56:07.974 --> 19:56:08.135
02.

14582
19:56:08.135 --> 19:56:14.372
我们会证明这个量然后我们会连接显然我们会让部署器来做因为所有事情都是用部署器来做的。

14583
19:56:14.372 --> 19:56:15.897
所以我们会批准ERC 20。

14584
19:56:15.897 --> 19:56:19.717
一旦我们批准了，我们就可以把钱存进去了。

14585
19:56:19.717 --> 19:56:23.104
我们写入console。log，存放那个。

14586
19:56:23.104 --> 19:56:27.942
然后我们运行await lending pool。deposit。

14587
19:56:27.942 --> 19:56:35.450
如果我们看存款函数，我们可以看到存款函数的所有参数。

14588
19:56:35.450 --> 19:56:40.117
我们也可以在Ave v2文档中看到它，我们只是期待这个位置。

14589
19:56:40.117 --> 19:56:47.544
我们可以看到它取的是我们要存入的资产的地址我们要代存的资产的多少我们

14590
19:56:47.544 --> 19:56:55.190
要代存一个地址然后是一个引用代码，它现在总是0因为引用代码已经停止了。

14591
19:56:55.190 --> 19:57:02.479
我们要存入wet令牌地址，我们要存入web令牌，我们设为0。

14592
19:57:02.479 --> 19:57:04.512
那个web令牌的02。

14593
19:57:04.717 --> 19:57:08.517
然后我们会使用部署器灰然后引用代码将是零。

14594
19:57:08.517 --> 19:57:11.304
然后我们写一个console。log。

14595
19:57:11.304 --> 19:57:13.288
让我们试试这个脚本。

14596
19:57:13.288 --> 19:57:15.061
让我们看看它是否有效。

14597
19:57:15.061 --> 19:57:23.029
我要重新运行这个脚本重新运行我在编译ERC 20时遇到的这个命令。

14598
19:57:23.029 --> 19:57:29.436
那首歌被编译成一个完整的文件，得到了一堆包装好的以太坊贷款池地址。

14599
19:57:29.436 --> 19:57:33.828
我们批准了，我们存了我们存了，然后存了。

14600
19:57:33.828 --> 19:57:42.560
如果我们看这个自述文件，我们会得到一个小的选中标记。

14601
19:57:42.717 --> 19:57:46.640
我们完成了第一步，我们存放了抵押品。

14602
19:57:46.717 --> 19:57:47.092
太棒了。

14603
19:57:49.717 --> 19:57:50.544
其他资产。

14604
19:57:50.544 --> 19:57:50.957
太好了。

14605
19:57:53.718 --> 19:57:58.931
现在通过几行新台词学习如何借用，我们会说借来的时间。

14606
19:57:58.931 --> 19:58:04.651
为了让我们借钱，我们可能想知道我们能借多少。

14607
19:58:04.651 --> 19:58:10.148
我们想了解更多关于我们账户的情况，对吗?我们想

14608
19:58:10.148 --> 19:58:15.646
知道我们借了多少，抵押品有多少，我们能借多少。

14609
19:58:15.646 --> 19:58:21.614
Avi附带了一个函数，叫做获取用户账户数据，它将返回

14610
19:58:21.614 --> 19:58:27.582
所有准备金的用户账户数据，我们有多少抵押品，它的总价

14611
19:58:27.582 --> 19:58:33.780
值，我们有可用的借款和当前清算阈值，贷款与价值之比等。

14612
19:58:33.780 --> 19:58:36.217
这些都是非常重要的指标。

14613
19:58:36.217 --> 19:58:40.843
如果我们有一项资产和抵押品那并不意味着我们可以借到一项资产。

14614
19:58:40.843 --> 19:58:45.801
每一个代币都有一些不同的值，比如贷款价值比。

14615
19:58:45.801 --> 19:58:53.392
例如，如果你有一个，你只能借0.75染料代币，这是为了降低

14616
19:58:53.392 --> 19:59:00.984
抵押品的风险，降低人们没有足够抵押品的风险，因为价格波动。

14617
19:59:00.984 --> 19:59:06.228
有一个80%的清算门槛如果你有一个作为抵

14618
19:59:06.228 --> 19:59:11.472
押品和81点的借款，你会得到所谓的清算。

14619
19:59:11.472 --> 19:59:18.417
那么什么是清算呢?当你抵押贷款的时候，如果你借的钱超过了清算阈

14620
19:59:18.417 --> 19:59:25.363
值超过了80%或者，根据不同的资产，不同的人可以对你进行清算。

14621
19:59:25.363 --> 19:59:29.586
这是他们偿还你贷款的时候。

14622
19:59:29.586 --> 19:59:33.891
他们还可以以更低的价格购买你的一些抵押品。

14623
19:59:33.891 --> 19:59:39.781
这就保证了Ave平台的偿付能力，这使得借款永远

14624
19:59:39.781 --> 19:59:45.929
不会超过抵押品为了借入资产，我们仍然需要抵押品。

14625
19:59:45.929 --> 19:59:53.396
所以基本上，如果你借的钱比你还的多，其他用户就可以拿走你还的钱作为回报，让他们偿还你的贷款。

14626
19:59:53.396 --> 19:59:55.428
所以我们显然不希望这种情况发生。

14627
19:59:55.428 --> 20:00:00.346
审计协议在程序上不想没有足够的钱来做这件事。

14628
20:00:00.346 --> 20:00:08.363
所以他们鼓励用户进行清算，以防这些失败协议中有一个叫做健康因子的东西，

14629
20:00:08.363 --> 20:00:15.922
如果健康因子低于1，你就会被清算，清算某人的实际功能叫做清算调用。

14630
20:00:15.922 --> 20:00:23.719
所以你可以建立一个机器人，你可以清算那些破产的用户，你可以赚一笔钱，你可以通过这样做获得奖励。

14631
20:00:23.719 --> 20:00:28.451
这些协议需要保持偿付能力，他们需要有足够的钱来放贷。

14632
20:00:28.451 --> 20:00:30.957
他们通过程序执行了这一点，这就是它如此伟大的原因。

14633
20:00:30.957 --> 20:00:34.600
您可以在清算文件中了解更多关于清算的信息。

14634
20:00:34.600 --> 20:00:39.257
这个账户数据会告诉我们有多少抵押品，我们有多

14635
20:00:39.257 --> 20:00:43.915
少债务，根据抵押品的多少我们可以借到多少钱。

14636
20:00:43.915 --> 20:00:51.589
我们可以看到当前的清算阈值我们可以看到贷款价值比然后我们可以看到健康因子，这显然非常重要。

14637
20:00:51.589 --> 20:00:55.052
如果我们的健康系数低于1，我们就会被清算。

14638
20:00:55.052 --> 20:00:59.173
所以我们不希望这个地狱因子在我们借入资产时低于1。

14639
20:00:59.173 --> 20:01:01.096
我们先来创建一个函数。

14640
20:01:01.096 --> 20:01:04.959
让我们创建一个新函数async。

14641
20:01:04.959 --> 20:01:10.910
函数让它借用户数据，我们会传入借贷池契约，我

14642
20:01:10.910 --> 20:01:16.862
们会传入借贷池契约和我们想要获取数据的帐户。

14643
20:01:16.862 --> 20:01:17.814
所以我们可以说const。

14644
20:01:17.814 --> 20:01:25.386
实际上，我们可以提取出我们想要的值，我们可以提取出总抵押品总债务和可借款。

14645
20:01:25.386 --> 20:01:31.535
让我们拿出总抵押品包

14646
20:01:31.535 --> 20:01:37.684
含总债务和可用借款。

14647
20:01:37.684 --> 20:01:43.280
这个等于await，借贷池。

14648
20:01:43.280 --> 20:01:48.478
get账户的用户账户数据。

14649
20:01:48.478 --> 20:01:56.731
现在我们要注销我们写console。

14650
20:01:56.731 --> 20:02:06.360
log你有总抵押物价值正的console。

14651
20:02:06.360 --> 20:02:13.802
日志你有总债务eath借来的

14652
20:02:13.802 --> 20:02:21.244
价值，然后控制台点日志你可以

14653
20:02:21.244 --> 20:02:29.220
借来可用的eath借来的价值。

14654
20:02:29.220 --> 20:02:36.369
然后我们会返回available to borrow将available borrow变为eath。

14655
20:02:36.369 --> 20:02:43.136
我们将返回总债务，我们不需要返回总抵押品如果我们想的话，我们只需要把它打印出来。

14656
20:02:43.136 --> 20:02:50.121
现在回到我们的函数中，我们可以在main函数中做，我们可以运行let，我

14657
20:02:50.121 --> 20:02:57.302
要这样做因为我们会调用它几次available borrows eath。

14658
20:02:57.302 --> 20:03:06.157
而总负债等于等待，得到借款池和部署器的借款用户数据。

14659
20:03:06.157 --> 20:03:10.627
如果我们运行这个，我们会看到我们实际上可以借

14660
20:03:10.627 --> 20:03:15.302
多少纱线硬帽或只是h h运行脚本在一个借来的。

14661
20:03:15.302 --> 20:03:18.283
Js和工作在我们的分叉区块链这里。

14662
20:03:18.283 --> 20:03:20.287
记住，它会慢一点。

14663
20:03:20.287 --> 20:03:26.475
这也是缺点之一因为当我们想要与这些链交互时它必须进行API调用。

14664
20:03:26.475 --> 20:03:29.121
然后我们得到了总抵押物没有定义。

14665
20:03:29.121 --> 20:03:31.830
那是因为我拼错了。

14666
20:03:31.830 --> 20:03:34.251
让我们正确拼写total。

14667
20:03:34.251 --> 20:03:35.990
我们再运行一遍。

14668
20:03:35.990 --> 20:03:37.005
好吧，很好。

14669
20:03:37.005 --> 20:03:45.931
你存了这个月的钱，你借了零钱因为我们什么都没借，你可以借这么多钱。

14670
20:03:45.931 --> 20:03:51.990
记住，我们可以借的金额总是小于我们存入的总金额。

14671
20:03:51.990 --> 20:03:54.593
这就是为什么我们看到这个较低的数字。

14672
20:03:54.721 --> 20:03:55.054
太酷了。

14673
20:03:55.054 --> 20:03:56.625
这就是我们可以借的数额。

14674
20:03:57.721 --> 20:03:58.971
借点时间。

14675
20:04:01.721 --> 20:04:03.884
八分之一，我们就能借点时间了。

14676
20:04:04.721 --> 20:04:11.180
我们可以借点时间，但我们需要弄清楚饮食的转化率是多少?我们要知道每个人能借多少钱。

14677
20:04:11.180 --> 20:04:12.884
但是我们想借染料。

14678
20:04:12.884 --> 20:04:19.151
那么，根据地球的价值，我们能借多少染料呢?要做到这一点，我们得拿到染料的价格。

14679
20:04:19.151 --> 20:04:22.984
我们要怎么做呢?好吧，你猜对了，我们将使用链式价格反馈。

14680
20:04:22.984 --> 20:04:30.382
如果你查看AVI文档，你可以找到price Oracle，这是一个你可以直接从AVI使用的合同。

14681
20:04:30.382 --> 20:04:34.689
但它做的第一件事是从链链接聚合器检查，这我们已经知道怎么做了。

14682
20:04:34.722 --> 20:04:38.436
我们会直接从链链接聚合器调用。

14683
20:04:38.436 --> 20:04:46.099
我们来创建一个新函数函数，我们叫它get dye price首先我们需要得到接口，一样的。

14684
20:04:46.099 --> 20:04:51.152
你可以直接去Hardhead defy从这里抓取接口，

14685
20:04:51.152 --> 20:04:56.394
我们也可以用从chainlink NPM导入来交换这个。

14686
20:04:56.394 --> 20:05:03.183
我要复制粘贴一个新文件，这将是agreg gate, Tor v3接口。

14687
20:05:03.183 --> 20:05:05.993
多特看到我们合作过那么多次。

14688
20:05:05.993 --> 20:05:14.239
现在我们有了这个接口，它会编译，我们显然在寻找最新一轮数据，它会给我们这个答案，也就是价格。

14689
20:05:14.239 --> 20:05:15.342
我们来抓取这个。

14690
20:05:15.342 --> 20:05:22.228
所以我们会说const di eath price feed = await ethers dot get

14691
20:05:22.228 --> 20:05:30.675
contract at我们会使用air, Greg Tor v3接口将从链链接文档中获取dye eath price feed。

14692
20:05:30.722 --> 20:05:38.106
我们去docs。chain。link UVM链会去Aetherium的合同地址。

14693
20:05:38.106 --> 20:05:40.567
或者在主网上寻找di。

14694
20:05:40.722 --> 20:05:42.436
我们看到di在这里。

14695
20:05:43.722 --> 20:05:47.152
我们只是在与之关联的GitHub回购中硬编码它。

14696
20:05:47.152 --> 20:05:52.175
有了这个，我们把它放在一个小配置文件中，但我们可以直接硬编码进去。

14697
20:05:52.175 --> 20:05:55.609
对于这个，我们不需要将它连接到部署者帐户。

14698
20:05:55.609 --> 20:06:01.037
因为我们不会发送任何交易，我们只会从合约中读取数据。

14699
20:06:01.037 --> 20:06:04.597
所以阅读不需要一个签名者把我发送给签名者。

14700
20:06:04.597 --> 20:06:13.587
现在我们可以说const price等于weight dye eath price feed。最新一轮数据。

14701
20:06:13.587 --> 20:06:19.384
我们知道，最新一轮数据会返回这么大的值。

14702
20:06:19.384 --> 20:06:22.477
我们只要求第一个指标的值。

14703
20:06:22.477 --> 20:06:25.550
另一种方法是，我们可以把这整个包起来。

14704
20:06:25.550 --> 20:06:30.691
一旦这个返回，我们会说，抓取第一个指标，也就是那个价格。

14705
20:06:30.691 --> 20:06:36.846
然后我们可以写一个console。log，也就是dy。

14706
20:06:36.846 --> 20:06:42.437
价格在Price。2中，像这样，然后返回价格。

14707
20:06:42.437 --> 20:06:47.119
我们可以运行这个测试一下，点击上，然后回车。

14708
20:06:47.119 --> 20:06:51.563
我们存了这是我们能存的。

14709
20:06:51.723 --> 20:06:54.675
没什么哦，我忘了叫它哦，不好意思，我们上去吧。

14710
20:06:54.723 --> 20:07:01.167
这个，我们说const染料价格等于await get染料价格。

14711
20:07:01.723 --> 20:07:01.985
这样。

14712
20:07:05.723 --> 20:07:12.182
我们知道是3289美元当然是3289 di /每人。

14713
20:07:12.182 --> 20:07:18.011
现在我们有了染料的价格，我们可以计算出我们要借多少染料。

14714
20:07:18.011 --> 20:07:19.434
太好了，我们有价格了。

14715
20:07:19.434 --> 20:07:27.417
现在我们算一下染料可以借多少，我们有了泥土可以借多少，我们需要把它转换成死亡。

14716
20:07:27.417 --> 20:07:36.373
所以我们说const amount die to borrow = available，即eath中可用的借位数。

14717
20:07:36.373 --> 20:07:37.223
字符串。

14718
20:07:37.223 --> 20:07:40.473
在JavaScript中，我们可以这样做。

14719
20:07:40.473 --> 20:07:43.115
要串，但还是要做数学。

14720
20:07:43.115 --> 20:07:44.293
所以乘以0。

14721
20:07:44.293 --> 20:07:49.852
95乘以，然后求这个骰子的倒数。

14722
20:07:49.852 --> 20:07:52.562
1除以模具价格。

14723
20:07:52.562 --> 20:07:53.433
数量。

14724
20:07:53.724 --> 20:07:58.320
这就是我们可以借的骰子的数量。

14725
20:07:58.724 --> 20:08:00.452
那我们就把这事搞定。

14726
20:08:01.724 --> 20:08:08.561
现在，console。log，你可以借用。

14727
20:08:08.724 --> 20:08:13.543
现在运行这个，你可以借到钱死借到。

14728
20:08:14.724 --> 20:08:20.771
单位，我们需要单位，但你可以借48模，从价格上看差不多。

14729
20:08:20.771 --> 20:08:26.962
为了得到正确的单位，我们用const amount, di来借位。

14730
20:08:26.962 --> 20:08:34.137
这将等于ethers。utils。parse ether, MT di借位。

14731
20:08:34.137 --> 20:08:34.757
字符串。

14732
20:08:34.757 --> 20:08:39.807
这只是借来的染料的数量，对吧，我们得到48。

14733
20:08:39.807 --> 20:08:40.307
79年死亡。

14734
20:08:40.307 --> 20:08:47.411
但同样，我们希望die token有18位小数点后的位置，类似于Aetherium。

14735
20:08:47.411 --> 20:08:51.805
所以我们需要这笔钱然后我们就可以开始借钱了。

14736
20:08:51.805 --> 20:08:59.527
我们会创建一个新函数，叫borrow die async function, borrow die会取die地址。

14737
20:08:59.527 --> 20:09:04.325
拿着贷款池，拿着要借的钱，

14738
20:09:04.325 --> 20:09:09.124
算一算当然，我们要算账户。

14739
20:09:09.124 --> 20:09:11.649
我们要做的就是用const。

14740
20:09:11.649 --> 20:09:16.020
Borrow TX是一个权重，借出池。Borrow,

14741
20:09:16.020 --> 20:09:21.232
die address, die to Borrow的数量。

14742
20:09:21.232 --> 20:09:27.429
同样，我们可以直接去文档，如果我们想，它取资产的地址，

14743
20:09:27.429 --> 20:09:33.166
金额，我们想借用利率模式，它是可变的或稳定的，引用

14744
20:09:33.166 --> 20:09:39.364
码然后地址代表，我们说利率模式是1，其中1是稳定的。

14745
20:09:39.364 --> 20:09:48.203
然后我们会做0或者这个引用代码因为它已经被揭穿了，然后我们会做一个计数，然后我们会做一

14746
20:09:48.203 --> 20:09:57.249
个等待，借入TX。wait，等待一个事务，然后我们会做console。log你已经借入。

14747
20:09:57.249 --> 20:09:58.560
好了，就这些了。

14748
20:09:58.560 --> 20:10:01.249
现在我们有了这个借用的I函数。

14749
20:10:01.249 --> 20:10:06.788
回到我们的主函数，好了，现在，我们终于可以做借阅时间了。

14750
20:10:06.788 --> 20:10:09.248
我们用wait，借die。

14751
20:10:09.248 --> 20:10:11.567
我们将把这些参数传入这里。

14752
20:10:11.567 --> 20:10:18.610
我们会写const, die令牌地址，等于我们会从主网硬编码这个。

14753
20:10:18.610 --> 20:10:25.967
我们可以查到die token地址，main net，我们会在这里抓取这个地址，这看起来确实是DI token，我们可以

14754
20:10:25.967 --> 20:10:33.325
在get up对象上检查，我们可以在实际代码的ABI上检查，因为我们只是在测试，我们会在这里从ether scan抓取。

14755
20:10:33.325 --> 20:10:39.578
对于借染料，我们需要染料令牌地址，我们需

14756
20:10:39.578 --> 20:10:45.832
要借出池合约借染料的数量，然后是部署者。

14757
20:10:45.832 --> 20:10:48.499
然后我们将等待借来的染料。

14758
20:10:48.499 --> 20:10:56.486
然后我们会再次运行这个getbar用户数据，打印出我们所处位置的信息。

14759
20:10:56.486 --> 20:11:04.316
当我们运行这个的时候，我们应该看到我们已经借了多少，更新，我们对那个函数的第一个调用会说，嘿，你

14760
20:11:04.316 --> 20:11:12.146
有这么多吃正数你什么都没借吗，你可以借这么多，我们得到价格，我们得到我们借了多少，我们借了多少。

14761
20:11:12.146 --> 20:11:20.226
现在它说你存了这么多钱你借了这么多钱你可以借这么多钱。

14762
20:11:20.226 --> 20:11:25.106
所以我们现在买了一堆借来的染料。

14763
20:11:25.106 --> 20:11:31.365
我们之所以要乘以0.95，是因为我们不想达到我们能借到的最大金额的上限。

14764
20:11:31.365 --> 20:11:35.070
所以我们说，嘿，让我们得到我们实际可以借到的金额的95%

14765
20:11:35.070 --> 20:11:38.887
所以我们不打算全部借，我们只借95%

14766
20:11:38.887 --> 20:11:42.226
你可以看到，我们已经存入的土地的数量实际上更高。

14767
20:11:42.226 --> 20:11:48.659
这是因为我们实际上从存款中获得了利息。

14768
20:11:48.659 --> 20:11:55.036
现在我们借了一些染料，我们借了48个染料，这相当于这么多的乙醚。

14769
20:11:55.036 --> 20:12:03.591
然后我们还有一点可以借因为我们只借了95%这很好。

14770
20:12:03.726 --> 20:12:09.154
太棒了，我们已经有程序地借出了，让我们至少在这里偿还一部分。

14771
20:12:09.154 --> 20:12:16.277
我们需要创建一个新函数它将使用契约中的偿还函数。

14772
20:12:16.277 --> 20:12:23.285
所以我们要做异步函数偿还,这是需要我们想要偿还的数

14773
20:12:23.285 --> 20:12:30.293
额的染料地址我们会偿还贷款池帐户现在偿还再次,我们

14774
20:12:30.293 --> 20:12:37.301
将不得不批准发送染料回到大街在这里,我们需要做的第

14775
20:12:37.301 --> 20:12:44.309
一件事就是我们实际上需要调用等证明ERC 20与染

14776
20:12:44.309 --> 20:12:52.440
料地址,贷款池点地址,然后山账户,因为通过伦理委员会20。

14777
20:12:52.440 --> 20:12:57.489
这是它需要的输入参数，我们需要批准将染料发回合同。

14778
20:12:57.489 --> 20:12:59.927
所以我们借了它，我们要把它还回去。

14779
20:12:59.927 --> 20:13:01.977
现在我们要把它送回去。

14780
20:13:01.977 --> 20:13:04.238
我们写const，

14781
20:13:04.238 --> 20:13:11.527
偿还TX等于await，借出，酷偿还地址，金额，一个账户。

14782
20:13:11.527 --> 20:13:20.150
然后我们写入await传回TX。Wait，这将在主函数中执行console。

14783
20:13:20.150 --> 20:13:29.227
log传回，我们将执行一个权重值传回，然后我们将给它以某种方式借出的染料的数量。

14784
20:13:29.227 --> 20:13:34.813
我们会给它染料令牌地址，给它借贷池，然后我们会给它部

14785
20:13:34.813 --> 20:13:40.615
署者让你再借一次用户数据这样我们就能打印出最终的金额。

14786
20:13:40.615 --> 20:13:46.133
现在，你会注意到一些事情，我们会把所有借来的染料都还给你。

14787
20:13:46.133 --> 20:13:53.620
然而，我们仍然会有一个染料平衡，当我运行这个时，你会看到我们仍然会有一些借来的Aetherium，

14788
20:13:53.620 --> 20:14:00.803
基本上，我们仍然会有一个染料平衡，因为我们仍然会有一些借来的die，试着在我回答之前找出原因。

14789
20:14:00.803 --> 20:14:08.433
所以我们在这里借了这么少，这么少的钱而我们存了更多的钱为什么我们还借

14790
20:14:08.433 --> 20:14:16.289
了这么少，这么少的钱呢?原因是，当我们借染料时，我们实际上产生了利息。

14791
20:14:16.289 --> 20:14:17.907
所以我们还欠染料。

14792
20:14:17.907 --> 20:14:26.574
现在我们可以做的是做一些像uniswap这样的事情，用我们的Aetherium交换染料来偿还剩下的债务。

14793
20:14:26.574 --> 20:14:33.812
这就是我们偿还所有债务的方法得到更多的染料来偿还我们积累的利息。

14794
20:14:33.812 --> 20:14:34.876
如果你愿意，

14795
20:14:34.876 --> 20:14:43.211
你可以回去做和这里完全一样的事情获取uniswap代码，把它放在这里，以编程方式偿还你的债务。

14796
20:14:43.211 --> 20:14:47.464
但在这一点上，你刚刚经历了整个生命周期。

14797
20:14:47.464 --> 20:14:51.105
这绝对是巨大的，巨大的祝贺。

14798
20:14:51.105 --> 20:14:58.278
您刚刚从AVI协议中存放了借入并偿还的令牌。

14799
20:14:58.278 --> 20:15:07.094
现在我将简要地向你们展示这些交易在实际的测试网络上是什么样子的，在以太扫描上，你们

14800
20:15:07.094 --> 20:15:15.910
会看到，当我们存入抵押品时，我们实际上得到了所谓的A代币，或带息代币，这些代币记录

14801
20:15:15.910 --> 20:15:24.728
了抵押品的数量，或者在我们的例子中，记录了我们在AVI协议中存入了多少web代币。

14802
20:15:24.728 --> 20:15:31.470
当我们想要收回我们的财富,我们燃烧这八令牌,我们删除这些八令牌,

14803
20:15:31.470 --> 20:15:38.212
你可以看到我们的第一个事务是存款,我想告诉你它是什么样子当你存款

14804
20:15:38.212 --> 20:15:45.165
的令牌,这个事务相关的贷款池,这里的存款,如果你看看令牌传输下面,

14805
20:15:45.165 --> 20:15:52.331
你可以看到我们实际沉积,可以看到,我们全神贯注的醚发送到ARB合同。

14806
20:15:52.331 --> 20:15:55.417
现在你也会看到这个东西。

14807
20:15:55.417 --> 20:15:57.442
那么这个a和东西是什么。

14808
20:15:57.442 --> 20:16:02.398
因此，为了记录你在Ave实际存了多少钱，

14809
20:16:02.398 --> 20:16:07.355
Ave会给你自己的财富代币或代币来记录。

14810
20:16:07.355 --> 20:16:15.665
这是这个带利息的令牌，你可以看到上面这里已经有一点兴趣了把这些令牌存入协议。

14811
20:16:15.729 --> 20:16:21.292
而这个代币，会持续上涨，因为借出的人越多，使用这个协议的人就越多。

14812
20:16:21.292 --> 20:16:28.519
你可以获取这个token address, interest bearing token这是一个token，我可以将它导入元掩码。

14813
20:16:28.519 --> 20:16:30.479
我可以看到我有0。

14814
20:16:30.479 --> 20:16:37.246
1，这代表我的初始存款00517乘以那个点A如果你保

14815
20:16:37.246 --> 20:16:44.014
持这个时间足够长，这个数字会随着你越来越多慢慢增加。

14816
20:16:44.014 --> 20:16:51.676
因为利率在外面，你可以看到它在这里上升，利率会一直变化，一直上升。

14817
20:16:51.729 --> 20:16:57.879
显然，我们的存款很少，利率不会很快上升，但使用协议的人越多，利率就会上升。

14818
20:16:57.879 --> 20:17:06.354
由于我使用的是一个测试网，协议的实际使用量不是很高，但你可以想象一下。

14819
20:17:06.729 --> 20:17:09.118
太棒了，你能走到这一步真是太了不起了。

14820
20:17:09.729 --> 20:17:11.929
快速回顾一下我们学到的东西。

14821
20:17:12.729 --> 20:17:14.443
进入下一节。

14822
20:17:16.729 --> 20:17:24.118
令牌或包装的Aetherium令牌，它是令牌化我们的Aetherium或第一层区块链原生令牌的一种方式。

14823
20:17:24.118 --> 20:17:30.118
然后我们学习了一点AVI协议，以及它是如何作为借用和借出资产的违抗原语的。

14824
20:17:30.118 --> 20:17:37.049
我们可以获得利益通过沉淀我们的令牌和资产Ave uniswap

14825
20:17:37.049 --> 20:17:43.980
我们也学会了一点,这是另一个非常重要的违背协议,它允许我们互相

14826
20:17:43.980 --> 20:17:50.911
交换标记之间的分散的情况下,我们知道我们可以存一些令牌到AVI

14827
20:17:50.911 --> 20:17:58.516
协议,这是一个分散的借款和贷款平台,类似于银行会获得利息我们把令牌。

14828
20:17:58.516 --> 20:18:00.237
但首先，我们得批准他们。

14829
20:18:00.237 --> 20:18:06.491
因为在任何时候，您希望契约与令牌交互，您都需要批准契约来实现此目的。

14830
20:18:06.491 --> 20:18:11.628
然后我们继续存入一旦存入我们就得到染料的价格。

14831
20:18:11.628 --> 20:18:19.230
然后我们知道我们实际上可以借到。我们可以借到一种资产基于我们提供的抵押品的多少。

14832
20:18:19.230 --> 20:18:21.306
然后我们学会了如何回报。

14833
20:18:21.306 --> 20:18:26.158
我们学习了叉子区块链，而不是使用我们自己的主区块链。

14834
20:18:26.158 --> 20:18:31.647
另一件要知道的事情是，如果你正在使用一个RPC URL，比如炼金术，你已经

14835
20:18:31.647 --> 20:18:37.285
学习了很多关于违抗的东西，现在defi绝对是一个巨大的动力，当它涉及区块链。

14836
20:18:37.285 --> 20:18:40.630
这是区块链可以做的最重要的事情之一。

14837
20:18:40.630 --> 20:18:43.776
如果你想了解更多关于defy的信息，请阅读更多defy的内容。

14838
20:18:43.776 --> 20:18:48.943
我在GitHub里有更多的链接这样你们就可以了解更多关于defy的知

14839
20:18:48.943 --> 20:18:54.110
识其中一个我特别想给你们看的是speed run Etherium。

14840
20:18:54.110 --> 20:18:59.246
它不仅提供了大量的反例，还提供了一大堆其他的例子。

14841
20:18:59.246 --> 20:19:02.968
这将是对你们通过这门课后所学内容的一次很好的测试。

14842
20:19:02.968 --> 20:19:08.893
甚至现在，如果你想或者什么时候你想多讲一点，实际上我们请到了Austin

14843
20:19:08.893 --> 20:19:16.301
Griffiths来多讲一点关于Aetherium的极速运行，我将把它交给Austin。

14844
20:19:16.730 --> 20:19:19.649
你好，我是奥斯丁·格里菲斯，我想让你看看极速跑Aetherium。

14845
20:19:19.649 --> 20:19:23.020
极速跑Aetherium是开始Aetherium的好方法。

14846
20:19:23.020 --> 20:19:29.110
如果你是一个开发人员，它的目标是web二开发人员成为web三开发人员的速度运行理论。

14847
20:19:29.110 --> 20:19:29.236
m。

14848
20:19:29.236 --> 20:19:30.378
Com是网站。

14849
20:19:30.378 --> 20:19:36.649
它会带你开始学习，并对语言和语法有个大概的了解。

14850
20:19:36.649 --> 20:19:38.353
但这仅仅是个开始。

14851
20:19:38.353 --> 20:19:42.993
理解语言只是一个开始，你会觉得自己无所不能。

14852
20:19:42.993 --> 20:19:47.911
当你终于把实体的语法整合在一起时，你就站在了世界的顶端，你可以通过一个智能合约。

14853
20:19:47.911 --> 20:19:53.665
但真正了解空间的背景，弄清楚什么可行，什么不可行，那是另一场战斗。

14854
20:19:53.665 --> 20:19:55.484
这就是高速运行的aetherium。

14855
20:19:55.484 --> 20:19:56.492
Com进来了。

14856
20:19:56.492 --> 20:19:59.634
让我们快速跑，快速跑。

14857
20:19:59.634 --> 20:20:05.964
首先，你会得到支架快速运行Aetherium是围绕支架基座旋

14858
20:20:05.964 --> 20:20:12.295
转的，并使用支架基座作为基础，你会想要在固体中修补一些想法。

14859
20:20:12.295 --> 20:20:14.668
我来解释一下我的意思。

14860
20:20:14.668 --> 20:20:19.569
因此，有了scaffold eath，就有了前端和智能合约。

14861
20:20:19.569 --> 20:20:23.159
所以脚手架上有一顶硬帽子。

14862
20:20:23.159 --> 20:20:27.646
您将结合使用硬帽和反应来构建一个D

14863
20:20:27.646 --> 20:20:32.397
AP，在其中您将部署智能合约和前端。

14864
20:20:32.397 --> 20:20:37.165
这种编辑你的智能合约并让你的前端自

14865
20:20:37.165 --> 20:20:41.934
动适应它的能力是简化脚手架的关键。

14866
20:20:41.934 --> 20:20:44.425
我加了几个额外的感叹号。

14867
20:20:44.425 --> 20:20:45.961
我们会在这里看到。

14868
20:20:45.961 --> 20:20:48.924
一旦合同生效，就这样了。

14869
20:20:48.924 --> 20:20:55.276
很快的，如果我创建一个un256的公共计数器，我们把它设为5，然后我

14870
20:20:55.276 --> 20:21:00.507
建立一个叫做increment的函数，这是public，

14871
20:21:00.507 --> 20:21:07.981
它对抗public，好了，它对抗plus, plus，你可以想象这里会发生什么。

14872
20:21:07.981 --> 20:21:14.338
所以你，你编辑一点稳定性，你部署你的合同，然后你的前端自动调整。

14873
20:21:14.338 --> 20:21:23.171
作为开发者，它让你能够调用这些函数对智能合约进行修改，你甚至

14874
20:21:23.171 --> 20:21:32.300
可以有一个控制台登录在那里，集合说计数现在在那里，我们这样做。

14875
20:21:32.300 --> 20:21:34.232
让我们继续部署它。

14876
20:21:34.232 --> 20:21:40.841
注意我在做这些快速的迭代，我在固体上做了小的改变，我看到这些改变在前端显现出来。

14877
20:21:40.841 --> 20:21:45.107
我在前端对它们进行修补并测试我的假设。

14878
20:21:45.107 --> 20:21:51.458
这里，如果我们看一下硬帽节点，当我调用这个增量调用时，我们

14879
20:21:51.458 --> 20:21:58.028
应该会看到控制台日志，这个地址，将计数设为8 ?非常非常酷。

14880
20:21:58.028 --> 20:21:59.506
这就是脚手架。

14881
20:21:59.506 --> 20:22:07.333
这就是speed run Aetherium的基础，你进入这里，编辑你的智能合约，然后编辑你的前端，将你

14882
20:22:07.333 --> 20:22:15.312
的前端指向某个特定的网络，部署你的智能合约，部署你的应用程序，它让你能够拥有一个与智能合约同时存在的前端。

14883
20:22:15.312 --> 20:22:18.909
当你构建你的智能合约时，你会拥有这些。

14884
20:22:18.909 --> 20:22:26.092
有了这个前端，对智能合约进行修改能帮你弄清楚如何写实度，比如这是一个

14885
20:22:26.092 --> 20:22:33.275
映射吗?这是一个数组吗?如何跟踪这个结构呢，你可以在迭代过程中完成只

14886
20:22:33.275 --> 20:22:40.460
需把它扔到智能合约中在前端对其进行修改并进行尝试，看看需要构建什么。

14887
20:22:40.460 --> 20:22:41.655
这就是脚手架。

14888
20:22:41.655 --> 20:22:45.669
这是开始快速运行以太坊所需的基础。

14889
20:22:45.669 --> 20:22:50.344
一旦你能把这些都安装好，你就会有你的反应前端纱线开始，

14890
20:22:50.344 --> 20:22:55.194
你会有纱线链，它会运行你的硬帽节点，然后你会做纱线展开。

14891
20:22:55.194 --> 20:23:00.683
一旦你在本地有了这个设置，你就可以快速运行Aetherium了。

14892
20:23:00.683 --> 20:23:03.751
你也可以在这里这么做，挑战零。

14893
20:23:03.751 --> 20:23:09.580
挑战零，必须有0索引，对吧，我们得很书呆子挑战零让你

14894
20:23:09.580 --> 20:23:15.634
建立环境设置，你会你会探索建立一个简单的非功能性例子。

14895
20:23:15.634 --> 20:23:18.410
它将附带一个非ft智能合约。

14896
20:23:18.410 --> 20:23:25.800
它会有一个非功能性前端有点像minting视图，它会有所有这些东西来做那个。

14897
20:23:25.800 --> 20:23:32.639
它会带你完成基本的挑战这一行将会握住你的手，它会带你完成每一步你必须

14898
20:23:32.639 --> 20:23:39.478
得到你必须有一个特定版本的节点E, L一些正确范围的节点和纱线安装。

14899
20:23:39.478 --> 20:23:45.184
注意yarn在Linux上有可执行文件，确保你有yarn，包管理器。

14900
20:23:45.184 --> 20:23:51.750
但是，在获得节点和纱线之后，您将对每个挑战进行克隆。

14901
20:23:51.750 --> 20:23:55.699
你会安装，你会点燃链条，你会点燃你的前端。

14902
20:23:55.733 --> 20:24:00.170
您将拥有一个工作的应用程序，它允许您与非ft智能合约进行交互。

14903
20:24:00.170 --> 20:24:03.571
你会从这里学到关于钱包的知识。

14904
20:24:03.571 --> 20:24:07.833
然后你将开始铸造NF T，你将发送那些NF T是圆形的。

14905
20:24:07.833 --> 20:24:11.240
这是第0个挑战，这只是你的开始。

14906
20:24:11.240 --> 20:24:15.999
在这里，即使在零挑战中，你也要把这个非杀伤性武器部署到林克比。

14907
20:24:15.999 --> 20:24:22.470
你还可以部署一个应用程序，允许你的朋友使用你的应用程序，并在Rinkeby的FTS中mint。

14908
20:24:22.470 --> 20:24:28.682
这是第一个挑战，看起来我们甚至想要投入到开放的环境中并尝试一些机制。

14909
20:24:28.733 --> 20:24:36.333
第二个挑战挑战第一个挑战快跑者理论的挑战之一是一切真正开始的地方。

14910
20:24:36.333 --> 20:24:39.527
这确实显示了Aetherium的超能力。

14911
20:24:39.527 --> 20:24:40.415
它设置好了。

14912
20:24:40.415 --> 20:24:45.311
因此，你需要构建一个应用程序，让一群

14913
20:24:45.311 --> 20:24:50.208
互不信任的人可以协调并入股智能合约。

14914
20:24:50.208 --> 20:24:52.334
这就像，这是Aetherium的超能力。

14915
20:24:52.334 --> 20:25:00.815
作为开发者，你有能力编写一些简单的规则，让那些混蛋们在财务上协调一致，而不是互相问候

14916
20:25:00.815 --> 20:25:09.499
和偷对方的钱，对吧?我们正在建立这些金融系统，这里有博弈论和经济学还有很多其他的东西。

14917
20:25:09.499 --> 20:25:15.511
但是你作为开发者，你在编写简单的规则，你在构建一个允许人们协调的系统。

14918
20:25:15.511 --> 20:25:20.597
挑战一，我们会教你如何设置你的牛排或者驯服，智能合约，

14919
20:25:20.597 --> 20:25:25.495
你会以完全相同的方式安装所有东西，你会启动所有东西。

14920
20:25:25.495 --> 20:25:29.019
然后它会带你了解智能合约中需要的东西。

14921
20:25:29.019 --> 20:25:31.448
但是你必须自己写固体。

14922
20:25:31.448 --> 20:25:39.980
这不是一个手持教程，你需要自己编写智能合约。

14923
20:25:39.980 --> 20:25:44.910
有一些指导方针和轨道可以帮到你，但它不会帮到你。

14924
20:25:44.910 --> 20:25:48.334
好了，这就是任务一，这就是挑战。

14925
20:25:48.334 --> 20:25:51.267
一个是开发去中心化的赌注应用程序。

14926
20:25:51.267 --> 20:25:56.707
挑战二是建立代币供应商在挑战一中，你会学到

14927
20:25:56.707 --> 20:26:02.147
如何向合同中汇款，如何拥有合同，跟踪映射。

14928
20:26:02.147 --> 20:26:09.027
在挑战两个,你要学习合同,合同互动,你会了解ERC 20多岁,你要

14929
20:26:09.027 --> 20:26:15.907
学习专门批准的模式,这是一个混蛋,,是很困难的,这是一个困难的事情

14930
20:26:15.907 --> 20:26:22.787
处理是批准的模式,你需要去你的令牌合同和批准供应商采取一些钱,然后

14931
20:26:22.787 --> 20:26:29.670
在第二个交易,你需要去供应商和供应商的钱从令牌合同,做其他的事情。

14932
20:26:29.670 --> 20:26:35.994
第二个挑战是学习代币和供应商，并开始让你接

14933
20:26:35.994 --> 20:26:42.319
触到大型多人游戏Aetherium的概念。

14934
20:26:42.319 --> 20:26:48.062
也有点像如何建立这些自动贩卖机，让任何人都能买到，然后你就建立了一个Dex。

14935
20:26:48.062 --> 20:26:50.194
现在，一旦你一旦你处理完01。

14936
20:26:50.194 --> 20:26:56.591
第二，在这一点上你真的有学习的许可，你已经准备好去做一些破坏和

14937
20:26:56.591 --> 20:27:03.194
建造一些很酷的东西，也许去建造一些其他的东西，但是回来，来，来，

14938
20:27:03.194 --> 20:27:09.592
来挑战三，挑战三将是更开放的一点，将会有其他的人也在建造这个。

14939
20:27:09.592 --> 20:27:15.412
你必须通过前三个挑战才能挑战第三个才能进入这个聊天室。

14940
20:27:15.412 --> 20:27:23.480
但这里有一个聊天室，其他正在构建自己平台的开发者都在那里，你可以和他们一起学习，一起聊天。

14941
20:27:23.480 --> 20:27:24.957
但你要建立一个交易所。

14942
20:27:24.957 --> 20:27:33.303
你要建立一个在智能合约中以去中心化的方式工作的交易所没有集中的断点。

14943
20:27:33.303 --> 20:27:38.535
这意味着你必须同时拥有存款和代币的储备你必须有一

14944
20:27:38.535 --> 20:27:43.985
个定价函数和LP代币以及所有其他你需要学习的东西。

14945
20:27:43.985 --> 20:27:46.831
挑战五是一个多SIG钱包。

14946
20:27:46.831 --> 20:27:53.802
这样一个基本的重要的事情如何存储你的eath安全将是在一个多SIG钱包，

14947
20:27:53.802 --> 20:28:00.968
你可以有多个身份，甚至像什么是道琼斯的基础，有点像从一个多SIG钱包开始。

14948
20:28:00.968 --> 20:28:06.680
你需要建立一个你需要理解的调用数据调用数据是非常奇怪和复杂的。

14949
20:28:06.680 --> 20:28:09.972
所有事情都是交易即使你只是戳了戳合同。

14950
20:28:09.972 --> 20:28:18.260
这是一个事务，你必须正确地编写调用数据，说，我想在这个特定的契约上调用这个特定的函数。

14951
20:28:18.260 --> 20:28:25.362
这就是multisig钱包然后它就结束了我们还有更多的挑战在进行中，但它就结

14952
20:28:25.362 --> 20:28:32.464
束了构建一个SVG NFT构建一个在智能合约中制作实际绘图并渲染它非常有趣。

14953
20:28:32.464 --> 20:28:39.683
这就是极速跑，极速跑Aetherium checkout脚手架，开始建造，在Aetherium上建造一些很棒的东西。

14954
20:28:39.736 --> 20:28:41.680
心，心，心，去抓住他们。

14955
20:28:41.736 --> 20:28:49.042
Austin Griffith是OGS中的一员，帮助工程师跟

14956
20:28:49.042 --> 20:28:56.593
上区块链世界的步伐，非常感谢Austin到目前为止所做的一切。

14957
20:28:56.736 --> 20:29:00.042
好了，现在我们开始讲NF - T。

14958
20:29:00.042 --> 20:29:01.171
让我们开始吧。

14959
20:29:01.736 --> 20:29:05.820
我已经做了一些关于什么是NF T以及如何开始使用NF T的视频。

14960
20:29:05.820 --> 20:29:11.227
所以我们将观看之前的Python版本的部分内容，我将在其中进行解释，

14961
20:29:11.227 --> 20:29:16.316
并从更高的层面进行讲解，然后当然，我们将进入最终的非功能性教程。

14962
20:29:16.316 --> 20:29:19.617
让我们来了解一下NF - T看，NF - T现在很火。

14963
20:29:19.617 --> 20:29:25.908
Nf T也被称为ERC 720，是在以太坊平台上创建的令牌标准。

14964
20:29:25.908 --> 20:29:31.176
Nf T代表不可替代的令牌，是一个类似于ERC 20的令牌标准。

14965
20:29:31.176 --> 20:29:37.848
ERC 20就像一个制造者的环节，所有的好东西都在以太链上找到了。

14966
20:29:37.848 --> 20:29:45.382
NF T或不可替代的令牌是不可替代的令牌，这意味着它们彼此完全独特。

14967
20:29:45.382 --> 20:29:49.684
而且一个令牌不能与同类的任何其他令牌互换。

14968
20:29:49.684 --> 20:29:56.091
一种很好的思考方式是1美元可以和其他任何一美元互换1美元和另一美元的价值是相同的。

14969
20:29:56.091 --> 20:30:02.803
这些是可替换的代币，就像ERC 20s一个链接总是等价于另一个链接，相比之下，将

14970
20:30:02.803 --> 20:30:09.515
是NFT的那些书呆子，我们知道就像口袋妖怪将是一个很好的例子，你是一个口袋妖怪将

14971
20:30:09.515 --> 20:30:16.227
有不同的属性，不同的移动，套，不能与任何其他口袋妖怪互换，或可能是一个更相关的。

14972
20:30:16.227 --> 20:30:19.737
它就像一张交易卡，或一件独特的艺术品或类似的东西。

14973
20:30:19.737 --> 20:30:27.713
这就是这些NF T的含义不可替代，不可互换的符号，目前最好的表现形式或被认为是

14974
20:30:27.713 --> 20:30:35.689
数字艺术作品，它们是不可腐蚀的，有一个永久的历史，谁拥有它们谁使用它们，等等。

14975
20:30:35.737 --> 20:30:39.185
现在，就像我说的，NF - T只是一个象征性的标准。

14976
20:30:39.737 --> 20:30:41.441
能让它们不仅仅是艺术。

14977
20:30:41.737 --> 20:30:48.037
给他们提供属性，你可以让他们战斗，你可以用他们做真正独特的事情，你可以对他们做任何你想做的事情。

14978
20:30:48.037 --> 20:30:54.955
但现在，最简单的思考方式，也是最流行的思考方式是称它们为

14979
20:30:54.955 --> 20:31:01.874
啊，啊，啊它很奇怪，或某种类型的收藏品或任何独特的东西。

14980
20:31:01.874 --> 20:31:08.047
现在，他们最近得到了大量的关注，因为我们看到越来越多的这些土地以疯狂的价格

14981
20:31:08.047 --> 20:31:14.220
出售，就像我们看到x∞以1美元的价格出售他们的9块土地9块他们独特的土地。

14982
20:31:14.220 --> 20:31:14.945
500万年。

14983
20:31:14.945 --> 20:31:19.471
我们还看到了Nyan猫的最初创造

14984
20:31:19.471 --> 20:31:24.281
者，你知道，这只猫卖了300英镑。

14985
20:31:24.281 --> 20:31:27.358
显然人们很重视这些东西。

14986
20:31:27.358 --> 20:31:35.214
就像我说的，它们只是部署在智能合约平台上的代币，你可以在不同的非ft平台上查看它们，比如公海或可穿戴平台。

14987
20:31:35.214 --> 20:31:38.687
这些是非金融市场让人们买卖它们。

14988
20:31:38.738 --> 20:31:45.014
显然，没有这些市场你也能做到，因为它是去中心化的，但它们有助于提供良好的用户界面。

14989
20:31:45.014 --> 20:31:48.806
现在，像你们中的许多人一样，我最初对NF T的想法是好的，这听起来很蠢。

14990
20:31:48.806 --> 20:31:50.347
但我觉得那很蠢。

14991
20:31:50.347 --> 20:31:52.081
我认为艺术确实有很多价值。

14992
20:31:52.081 --> 20:31:55.492
而且我认为艺术家们的报酬并不总是公平的。

14993
20:31:55.492 --> 20:32:00.479
这实际上是当今世界的一个大问题一个艺术家可以创作某种类型的艺术作品人

14994
20:32:00.479 --> 20:32:05.466
们只是复制粘贴它，你知道，到处都是，他们从来没有得到他们作品的归属。

14995
20:32:05.466 --> 20:32:10.155
所以，有一个非常简单的分散版税机制，或者某种类型的机制，让这些

14996
20:32:10.155 --> 20:32:14.996
艺术家可以准确地获得他们所做的事情的报酬，我认为这是非常重要的。

14997
20:32:14.996 --> 20:32:15.625
我喜欢音乐。

14998
20:32:15.625 --> 20:32:18.238
我喜欢电影，那是我能消化的艺术作品。

14999
20:32:18.238 --> 20:32:23.590
我真的很喜欢，我认为他们得到适当的补偿是公平的，因为他们为我的生活提供了价值。

15000
20:32:23.590 --> 20:32:28.550
我认为NF T是解决这个问题的一个很好的方法，因为它有一些分散的审计跟踪，以

15001
20:32:28.550 --> 20:32:33.642
及我们可以建立的专利追踪，并且可以非常透明地看到，而不需要通过一些集中的服务。

15002
20:32:33.642 --> 20:32:35.118
这就是它的基本要点。

15003
20:32:35.118 --> 20:32:41.118
让我们多谈谈标准ERC 721标准是非ft标准。

15004
20:32:41.118 --> 20:32:48.338
这是它的基础还有另一种标准是半可替换代币，1155我们不打算在这里讨论这个。

15005
20:32:48.338 --> 20:32:52.938
但是你可以看看721和ERC 20和ERC之间的主要区别。

15006
20:32:52.938 --> 20:32:58.024
20是他们有一个非常简单的映射在一个地址和这个地址的容量之间。

15007
20:32:58.024 --> 20:33:02.045
720个有唯一的令牌ID，每个令牌ID有唯一的所有者。

15008
20:33:02.045 --> 20:33:06.439
另外，它们还有一个叫令牌URI的东西，我们一会儿会讲到。

15009
20:33:06.439 --> 20:33:07.989
每个令牌都是唯一的。

15010
20:33:07.989 --> 20:33:11.322
每个令牌ID表示一个唯一的资产。

15011
20:33:11.322 --> 20:33:17.739
由于这些资产是唯一的，我们希望能够可视化它们并显示它们实际的样子我们需要定义对象的那些属性。

15012
20:33:17.739 --> 20:33:21.535
如果它是一件艺术品，我们就需要一种方法去定义这种艺术品的样子。

15013
20:33:21.535 --> 20:33:26.646
如果它是游戏中的某种类型的角色，我们需要等待在NFT中定义角色属性。

15014
20:33:26.646 --> 20:33:29.230
这就是元数据和令牌URI的用武之地。

15015
20:33:29.230 --> 20:33:37.246
如果你对Aetherium有所了解，你就会知道有时候汽油价格会非常高，特别是当它需要储存大量空间时，它会变得非常非常贵。

15016
20:33:37.246 --> 20:33:42.619
你的第一个问题可能是，他们储存了这些图像吗?这些是链上的碎片吗?答案是，

15017
20:33:42.619 --> 20:33:50.381
有时候当他们想出NF T的时候，美工们在部署东西的时候，开发人员和美工们说，是的，艺术，让我们做艺术吧。

15018
20:33:50.381 --> 20:33:54.673
我要把这个一兆字节的图像放到以太链上。

15019
20:33:54.739 --> 20:34:00.627
天啊，汽油太贵了，删除按钮。

15020
20:34:00.739 --> 20:34:03.525
否则，就不好了。

15021
20:34:05.739 --> 20:34:08.196
他们把所有的艺术品都挂起来，会非常贵的。

15022
20:34:08.196 --> 20:34:12.339
为了解决这个问题，他们加入了标准，也就是令牌URI。

15023
20:34:12.339 --> 20:34:17.797
这是一个通用的唯一指示器，可以指示该资产或令牌是什么样子以及

15024
20:34:17.797 --> 20:34:23.437
令牌的属性是什么，您可以使用集中的API或IPFS之类的东西。

15025
20:34:23.437 --> 20:34:25.089
来获取那个令牌URI。

15026
20:34:25.089 --> 20:34:31.007
典型的令牌URI必须以这样的格式返回一些东西，其中有名称，图像，位置，

15027
20:34:31.007 --> 20:34:36.587
描述，以及下面的任何属性，通常有关于链上元数据和链外元数据的讨论。

15028
20:34:36.587 --> 20:34:42.900
因为在链外存储所有元数据要容易得多，成本也低得多，很多人会使用像去中心化的IPFS

15029
20:34:42.900 --> 20:34:49.213
这样的东西，但确实需要一点中心性来保持持久性，但他们也可以使用自己的中心化API。

15030
20:34:49.213 --> 20:34:54.030
然而，很明显，如果它下降了，你就失去了你的形象，你就失去了与非功能性相关的一切。

15031
20:34:54.030 --> 20:35:02.055
因此，大多数非ft市场实际上不能也不会读取链属性或链元数据，因为它们太习惯于查找令牌URI了。

15032
20:35:02.055 --> 20:35:09.040
显然，如果你使用链外元数据，你就不能做任何很酷或很有趣的事情，也不能从你的NF T中获得任何收益。

15033
20:35:09.040 --> 20:35:16.161
举个例子来说吧，如果你想要创造一款基于链的Pokemon游戏，你的所有属性都必须是基于链的，这样你的Pokemon才能与其他Pokemon进行互动。

15034
20:35:16.161 --> 20:35:20.543
因为如果它是链外的，那就很难用密码学来证明了。

15035
20:35:20.543 --> 20:35:24.379
如果你是NF - T的新手，你可能会想，等等，这有很多信息，我会让你简单点。

15036
20:35:24.379 --> 20:35:31.490
如果你想渲染一个图像，我是一个非ft，把你的图像添加到IPFS，添加一个元数据文件指向IPFS上的图像文件。

15037
20:35:31.490 --> 20:35:35.422
然后抓取那个令牌URI，把它设置为你的NFT。

15038
20:35:35.422 --> 20:35:39.851
chain link DND这篇文章很好地介绍了这一点，并向您展示了如何做到这一点。

15039
20:35:39.851 --> 20:35:46.865
所以，如果你想学习如何做到这一点，一定要阅读这个视频我们不打算在这个视频中讨论，但我们将部署我们的第一个非函数链属性。

15040
20:35:46.865 --> 20:35:54.761
同样地，将你的属性放在链上能够让你创造出真正有创意的NFT去创造游戏或

15041
20:35:54.761 --> 20:36:02.658
拥有有趣的属性，并且能够保证你的NFT的真实性因为这些属性总是在链上。

15042
20:36:02.740 --> 20:36:08.804
好了，现在我们知道了NF t是什么，和ERC 20类似的基本知识。

15043
20:36:08.804 --> 20:36:16.891
你可以在Aetherium上看到eip721或ERC 721不可替代的令牌标准，即IP。

15044
20:36:16.891 --> 20:36:24.314
再一次，如果你向下滚动，你能看到所有不同的事件和创建这个令牌的不同函数。

15045
20:36:24.314 --> 20:36:29.200
现在我们要做的所有事情都可以在这个GitHub回购中找到。

15046
20:36:29.200 --> 20:36:33.994
这个硬帽NFT FCC，我们将通过所有的

15047
20:36:33.994 --> 20:36:38.788
代码来部署和创建我们自己的定制的NFT。

15048
20:36:38.788 --> 20:36:45.300
我把这称为终极非功能性回购作为这门课的一部分，因为我们在这里会讲到很多，我们会讲到一个

15049
20:36:45.300 --> 20:36:51.812
基本的非功能性回购，一个真正的极简的非功能性回购然后是一个IPFS主持的非功能性回购。

15050
20:36:51.812 --> 20:36:52.954
这是动态的。

15051
20:36:52.954 --> 20:36:59.199
它使用随机性来生成独特的NF T，这样我们就可以获得稀

15052
20:36:59.199 --> 20:37:05.445
有稀有的卡片，稀有的代币或属性，或者任何你想要的东西。

15053
20:37:05.445 --> 20:37:08.991
然后我们将进行所谓的SVG非ft。

15054
20:37:08.991 --> 20:37:14.531
这些实体是100%托管在链上的，所以你不需要一个外链。

15055
20:37:14.531 --> 20:37:17.635
所以你不需要IPFS，不需要链下数据库。

15056
20:37:17.635 --> 20:37:22.252
这个也是动态的，它会使用价格供给来

15057
20:37:22.252 --> 20:37:26.870
根据资产的价格波动实体的实际形象。

15058
20:37:26.870 --> 20:37:29.551
这是我们将要使用的图像。

15059
20:37:29.551 --> 20:37:32.508
显然我们还有这三只可爱的小狗。

15060
20:37:32.508 --> 20:37:35.169
如果你想跟随快速入门，你完全可以。

15061
20:37:35.169 --> 20:37:41.257
我将快速概述一下运行代码的过程向你们展示最后的结果。

15062
20:37:41.257 --> 20:37:44.845
基本上，我们要做的是我们要有我们的代码，

15063
20:37:44.845 --> 20:37:50.947
我们要运行hardhat部署破折号网络，rink B，破折号标签主。

15064
20:37:50.947 --> 20:37:54.510
这将部署我们所有的合同和一切。

15065
20:37:54.510 --> 20:37:58.433
最后，如果我们去测试nets。open c。

15066
20:37:58.433 --> 20:38:07.186
我们抓取其中一个NFT的地址，我们应该能够把它放在这里，看到我们实际的NFT作为一个项目的集合。

15067
20:38:07.186 --> 20:38:10.614
另外，我们可以直接看合同。

15068
20:38:10.742 --> 20:38:18.179
我们可以读取契约，获取令牌URI，然后复制这个令牌，粘贴到浏

15069
20:38:18.179 --> 20:38:25.617
览器中，然后获取image属性，看看chain上是什么样子。

15070
20:38:25.617 --> 20:38:30.260
说了这么多，让我们学习如何建立这个终极的非功能性回

15071
20:38:30.260 --> 20:38:34.903
购和建立所有这些不同的可定制的NFT让我们开始吧。

15072
20:38:34.903 --> 20:38:40.825
同样，在终端中，我要创建一个新目录。

15073
20:38:40.825 --> 20:38:44.575
我们叫它“硬帽”和“T”代表FCC。

15074
20:38:44.742 --> 20:38:45.903
我们要用cd。

15075
20:38:47.742 --> 20:38:49.182
这就是代码。

15076
20:38:52.742 --> 20:38:57.819
Point，你已经很熟悉我们代码库的设置了，可以随意复制或做任何你想

15077
20:38:57.819 --> 20:39:02.897
做的设置，我们会做yarn，添加dash dev hard hat。

15078
20:39:02.897 --> 20:39:06.592
在加载的时候，我要复制一些漂亮的文件。

15079
20:39:06.592 --> 20:39:10.742
因为我想用更漂亮的，我要把我的安全帽复制过来。

15080
20:39:10.742 --> 20:39:11.242
配置。

15081
20:39:11.242 --> 20:39:11.408
js。

15082
20:39:11.408 --> 20:39:19.304
我还要抓取Jason复制到这里的包，我要删除这个旧的package。JSON。

15083
20:39:19.304 --> 20:39:25.096
然后按回车键把刚才复制过来的这个重命名为package copy到package json。

15084
20:39:25.096 --> 20:39:31.373
我这样做的原因是，我可以直接运行纱线，为我安装所有这些东西。

15085
20:39:31.373 --> 20:39:40.181
或者我们可以回到这里，看看第九课的内容安全帽，智能合约彩票，所有这些东西，同样运行这一大块。

15086
20:39:40.181 --> 20:39:44.361
或者你可以复制你的json包，然后运行yarn，它会做同样的事情。

15087
20:39:44.361 --> 20:39:47.885
现在我们不需要一遍又一遍地做这个样板了。

15088
20:39:47.885 --> 20:39:54.043
当它加载时，我还会抓取我的Dotty和v文件我们在过去的几个项目中使用过，自述文件。

15089
20:39:54.043 --> 20:39:54.143
医学博士。

15090
20:39:54.143 --> 20:39:56.593
我们就做我们该做的事吧。

15091
20:39:56.743 --> 20:39:58.457
我们要做三种不同的契约。

15092
20:39:58.743 --> 20:40:03.303
使用ERC 721标准，然后我们将

15093
20:40:03.303 --> 20:40:08.132
做一个随机的IPFS托管的NF t。

15094
20:40:08.132 --> 20:40:13.443
最后，我们要做一个动态的sv G非傅里叶变换。

15095
20:40:13.443 --> 20:40:22.076
所以我们的随机NF - T在创造时是随机的，这给了我们的NF - T一些真正的稀缺性和一些真正的随机性。

15096
20:40:22.076 --> 20:40:24.692
它将被托管在IPFS上。

15097
20:40:24.692 --> 20:40:29.289
我们的动态SVG非ft将100%托管

15098
20:40:29.289 --> 20:40:34.143
在链上，它的图像将根据一些参数而改变。

15099
20:40:34.143 --> 20:40:39.243
这就是使它成为动态SVG非ft的原因。

15100
20:40:39.743 --> 20:40:47.437
我们来创建一个新文件夹，我们来创建合约文件夹，我们来创建我们的第一个ntf这将是我们的基本NFT。

15101
20:40:47.437 --> 20:40:55.225
这里我讲得快一点，因为我们要做的大部分实际上都是我们已经熟悉的东西。

15102
20:40:55.225 --> 20:40:58.143
所以我们将在一个新文件中做基本的NF T。soul。

15103
20:40:58.143 --> 20:41:00.780
我们来做一下。

15104
20:41:00.780 --> 20:41:07.795
我们来看看spdx许可标识符，它是MIT。

15105
20:41:07.795 --> 20:41:12.467
我们会做pragma, solidity，胡萝卜0，第8点。

15106
20:41:12.467 --> 20:41:17.849
语用，固性，然后我们学收缩，基本的NF - t。

15107
20:41:17.849 --> 20:41:20.691
我来取一个基本的t。

15108
20:41:20.691 --> 20:41:22.010
就像这样。

15109
20:41:22.010 --> 20:41:24.276
缩并基本NF t。

15110
20:41:24.276 --> 20:41:30.340
然后我们会努力运行编译或者yarn，点击编译，到目前为止看起来我们做得很好。

15111
20:41:30.340 --> 20:41:31.017
好的,完美的。

15112
20:41:31.017 --> 20:41:37.665
基于那个非ft令牌标准，我们回到那个EIP，我们将需要一大堆不同的函数，我

15113
20:41:37.665 --> 20:41:44.494
们将需要转移事件，我们将需要所有者事件反弹，我们将会用到所有这些不同的函数。

15114
20:41:44.494 --> 20:41:50.589
我们可以百分之百地实现这些并像ERC 20那样转移它们，或者再

15115
20:41:50.589 --> 20:41:56.881
一次，我们可以使用，你猜对了，我们也会使用公开的齐柏林飞船合同。

15116
20:41:56.881 --> 20:41:59.201
我们回来打开齐柏林飞艇，再看合同。

15117
20:41:59.201 --> 20:42:03.444
我们要把它和纱线一起加入，加入dash Dev。

15118
20:42:03.444 --> 20:42:08.985
纱，加上破折号开发在打开合同，像这样。

15119
20:42:08.985 --> 20:42:13.670
在这个过程中，我们可以看看ERC 721我们可

15120
20:42:13.670 --> 20:42:18.355
以看到创建一个极简ERC 721是什么样子的。

15121
20:42:18.355 --> 20:42:21.981
现在它的ERC附带了许多扩展。

15122
20:42:21.981 --> 20:42:24.744
在题目给我们的这个例子中。

15123
20:42:24.744 --> 20:42:30.002
他们使用的是ERC 721 Uri存储，我们稍后会讲到。

15124
20:42:30.002 --> 20:42:31.260
我们把它加到这里。

15125
20:42:31.260 --> 20:42:35.399
现在我们可以从我们的合同中导入ERC 21。

15126
20:42:35.399 --> 20:42:44.177
我们会在open Zeppelin输入/合约/令牌/你的c721 / ERC。

15127
20:42:44.177 --> 20:42:49.282
所以他们在演示中使用了另一个，但不用担心这个。

15128
20:42:49.282 --> 20:42:50.930
和伦理委员会一样。

15129
20:42:50.930 --> 20:42:56.151
我们会说我们的基本非功能性是ERC 721。

15130
20:42:56.151 --> 20:43:04.151
我们在做这个继承，你找到构造函数，我们可以看到它有一个构造函数，它接受一个名字和一个符号。

15131
20:43:04.151 --> 20:43:08.633
我们需要使用构造函数和契约。

15132
20:43:08.633 --> 20:43:12.521
我们会说，建造门。

15133
20:43:12.745 --> 20:43:15.795
构造函数是空的。

15134
20:43:16.745 --> 20:43:21.306
ERC 721构造器，我们叫它小狗。

15135
20:43:21.745 --> 20:43:24.094
它的标志就是这样的狗。

15136
20:43:25.745 --> 20:43:30.278
它是这只狗，对吧所以它将是一个NF T，仅仅是这只狗。

15137
20:43:30.278 --> 20:43:33.880
名字是doggy，符号是dog。

15138
20:43:33.880 --> 20:43:35.995
现在为了创造新的狗。

15139
20:43:35.995 --> 20:43:42.341
我们要做的是openzeppelin代码带有一个叫做m

15140
20:43:42.341 --> 20:43:48.687
int的函数和erc20完全一样我们要创建一个叫做mi

15141
20:43:48.687 --> 20:43:55.035
nt NFT的函数这是一个公共文件函数它会返回活动6。

15142
20:43:55.035 --> 20:44:01.054
我们将使用ERC 20的safe mint函数或者下划线safe

15143
20:44:01.054 --> 20:44:08.390
mint message。sender将向调用这个mint函数的人铸造令牌。

15144
20:44:08.390 --> 20:44:14.697
然后我们还需要给它一个令牌ID，如果我们回头看ERC 721的代码。

15145
20:44:14.697 --> 20:44:22.911
你也可以在GitHub上看到这个，我们会看这个safe mint函数，它接受一个地址，到谁将拥有NFT。

15146
20:44:22.911 --> 20:44:28.278
然后是令牌ID，基于这个地址的令牌ID是什么。

15147
20:44:28.278 --> 20:44:34.969
因此，如果在同一个智能合约上有一组令牌，那么每个令牌都需要自己唯一的令牌ID。

15148
20:44:34.969 --> 20:44:42.232
我们要做的是创建一个un256，私有变量s_ token counter，它会在

15149
20:44:42.232 --> 20:44:49.677
构造函数中初始化为0，但我们会显式地说，es token counter = 0。

15150
20:44:49.677 --> 20:44:56.336
然后在这里，我们有这个新nft的标记ID是那个标记计数器。

15151
20:44:56.336 --> 20:45:01.795
当然，我们会说s token counter等于s token counter加1。

15152
20:45:01.795 --> 20:45:09.665
每次我们想要一个新的NFT时，我们向上取令牌计数器，然后我们会返回，我们会返回新的标签计数器。

15153
20:45:09.665 --> 20:45:09.955
正确的。

15154
20:45:09.955 --> 20:45:17.126
然后很明显，在底部，我们可以做function，获取令牌计数器，这将是一个公共视图在256中返回你。

15155
20:45:17.126 --> 20:45:22.127
这里我讲得快一点，因为你们之前见过这个，返回s_ token

15156
20:45:22.127 --> 20:45:29.296
counter，因为上面是私有变量，下面是公共函数来获取token counter。

15157
20:45:29.296 --> 20:45:31.693
严格来说，就是这样。

15158
20:45:31.693 --> 20:45:33.166
严格来说这是NF T。

15159
20:45:33.166 --> 20:45:41.090
但这看起来像什么呢?现在，在这个EIP令牌标准中，这个NF T看起来什么都不像。

15160
20:45:41.090 --> 20:45:43.299
它有一个叫令牌URI的东西。

15161
20:45:43.299 --> 20:45:48.999
这是一个很重要的函数它告诉我们这个令牌到底是什么样的。

15162
20:45:48.999 --> 20:45:51.665
就像我们在小课上说的。

15163
20:45:51.665 --> 20:45:59.817
这个令牌URI返回某种类型的URL或通用资源标识符，它返回类似这样的JSON。

15164
20:45:59.817 --> 20:46:02.796
在这个JSON中，我们会有这个图像部分。

15165
20:46:02.796 --> 20:46:08.696
这个图像将是一个URL它将指向这个图像的实际样子。

15166
20:46:08.696 --> 20:46:13.496
这个URL可以托管在chain上，可以托管在IPFS上，可以托管在任何地方。

15167
20:46:13.496 --> 20:46:16.700
但理想情况下，我们不会使用一个集中的服务器来托管它。

15168
20:46:16.747 --> 20:46:22.126
如果这是托管在谷歌云或中央服务器上，我们的中央服务器宕机了。

15169
20:46:22.126 --> 20:46:25.254
猜猜这个主持人长什么样子，什么都不像。

15170
20:46:25.254 --> 20:46:32.136
我们想要使用某种去中心化存储，来获得一个URL或URI来存储它的样子。

15171
20:46:32.136 --> 20:46:38.811
为了使本节对您来说更容易一些，我实际上已经将一个图像托管到IPFS中。

15172
20:46:38.811 --> 20:46:43.425
对你来说，它会是@ IPFS。。斜杠，它

15173
20:46:43.425 --> 20:46:48.271
会是这样的，这就是我们要用在狗身上的图像。

15174
20:46:48.271 --> 20:46:53.068
如果你只是创建这个图像，作为令牌URI，那是行

15175
20:46:53.068 --> 20:46:58.074
不通的，我们需要一个URI返回这个，里面有图像。

15176
20:46:58.074 --> 20:47:01.347
对于第一部分，我们已经做过了。

15177
20:47:01.347 --> 20:47:03.320
它就在这里。

15178
20:47:03.320 --> 20:47:06.323
这就是令牌URI函数需要返回的内容。

15179
20:47:06.323 --> 20:47:14.366
它会有名字，描述，图片URI，然后指向狗，还有一些属性，等等。

15180
20:47:14.366 --> 20:47:21.008
你会注意到这里的图片指向HTTPS，点。/ / ipfs。

15181
20:47:21.008 --> 20:47:21.192
io。

15182
20:47:21.192 --> 20:47:29.522
我这样做的原因是，以防你没有IPFS网关，但如果它是IPFS形式会更好。

15183
20:47:29.522 --> 20:47:32.884
因为如果中央服务器ipfs。

15184
20:47:32.884 --> 20:47:38.424
io，当它下降时，NFT就会显示它什么也显示不出来。

15185
20:47:38.424 --> 20:47:41.009
所以会好很多。

15186
20:47:41.009 --> 20:47:43.566
如果不是ipfs。

15187
20:47:43.566 --> 20:47:43.762
io。

15188
20:47:43.762 --> 20:47:49.069
是IPFS，冒号，斜杠，像这样，而不是IPFS。

15189
20:47:49.069 --> 20:47:49.238
io。

15190
20:47:49.238 --> 20:47:51.298
但现在，这是我们要用的。

15191
20:47:51.298 --> 20:47:57.248
你可以到GitHub上，抓取这部分的内容。

15192
20:47:57.248 --> 20:48:04.494
对吧?打开契约，基本的非ft，你可以抓取这个，这个，上面的部分，像这样复制。

15193
20:48:04.494 --> 20:48:10.384
我们会把令牌URI粘贴到上面，像这样。

15194
20:48:10.384 --> 20:48:13.384
哦，应该是return。

15195
20:48:13.384 --> 20:48:14.474
好了。

15196
20:48:14.748 --> 20:48:15.224
好的,很酷。

15197
20:48:17.748 --> 20:48:18.075
这一点。

15198
20:48:22.748 --> 20:48:24.655
直接到IPFS，这很好。

15199
20:48:26.748 --> 20:48:29.594
文件实际上指向http。

15200
20:48:29.594 --> 20:48:29.901
ipf。

15201
20:48:29.901 --> 20:48:30.054
io。

15202
20:48:31.748 --> 20:48:33.715
T在非时态中不会这样做。

15203
20:48:35.748 --> 20:48:37.454
但是对于你的NF - T，不要这样做。

15204
20:48:38.748 --> 20:48:40.748
这是一个公共常数变量。

15205
20:48:42.748 --> 20:48:43.881
你写的东西永远不会变。

15206
20:48:44.748 --> 20:48:50.442
这样每个遇到它的人都能得到这个可爱的小冰球。

15207
20:48:50.442 --> 20:48:55.814
我们现在做的方法是我们需要识别实际的令牌URI函数。

15208
20:48:55.814 --> 20:49:02.506
我在上面写get token counter，我们说function, token URI。

15209
20:49:02.506 --> 20:49:09.298
这些总是使用一个unt256令牌ID，我们会让它

15210
20:49:09.298 --> 20:49:16.373
成为一个公共视图，override返回字符串内存。

15211
20:49:16.373 --> 20:49:21.248
这需要返回令牌URI。

15212
20:49:21.248 --> 20:49:26.414
现在，这将是最基本的方法来创造它，对吧。

15213
20:49:26.414 --> 20:49:33.510
如果我们想让这个函数更好一点，我们也可以注释掉令牌ID，因为我们实际上没有使用令牌ID。

15214
20:49:33.510 --> 20:49:39.415
但是我们在我们进口的ERC 721中重写了。

15215
20:49:39.415 --> 20:49:43.291
它有一个令牌ID函数或一个令牌URI函数。

15216
20:49:43.291 --> 20:49:49.076
我们要重写这个，对吧，我们根本不用这个，我们说，嘿，我们要在这里用我们自己的。

15217
20:49:49.076 --> 20:49:52.354
这就是我们需要的一切。

15218
20:49:52.354 --> 20:49:57.734
现在如果你把这个放到B溜冰场，如果你跳到C测试网，

15219
20:49:57.734 --> 20:50:03.114
你会把这个，这只狗，这个可爱的小pop会一直出现。

15220
20:50:03.114 --> 20:50:06.699
让我们继续，让我们为此创建一个小小的deploy函数。

15221
20:50:06.749 --> 20:50:14.601
我们创建一个新文件夹，部署一个新文件，我们称它为one deploy basic NF T·js。

15222
20:50:14.601 --> 20:50:19.191
这看起来和我们之前做过的很像。

15223
20:50:19.191 --> 20:50:22.749
所以我要在这里移动快一点。

15224
20:50:22.749 --> 20:50:29.312
Const network = require hard hats, Const development

15225
20:50:29.312 --> 20:50:36.129
chains， = require。dot。slash helper, hard hats config。

15226
20:50:36.129 --> 20:50:38.589
我想我没有加进去。

15227
20:50:38.749 --> 20:50:43.369
所以我要复制粘贴我的助手Hardhead配置从我们的上一个项目。

15228
20:50:43.369 --> 20:50:50.580
如果你有困惑，你可以到这里的GitHub，到助手Hardhead配置，从这里获取它，

15229
20:50:50.580 --> 20:50:59.165
我们有const开发链，或者说const verify = require。dot / utils。

15230
20:50:59.165 --> 20:51:00.248
削减验证。

15231
20:51:00.248 --> 20:51:08.632
我们还会抓取我们的utils，我要复制粘贴从alas项目中抓取utils文件夹，同样，你可以从上一个项目中复

15232
20:51:08.632 --> 20:51:17.016
制粘贴，或者你可以直接到repo，抓取经过验证的。j，我们稍后会讲到这两个函数，但至少现在要抓取经过验证的。

15233
20:51:17.016 --> 20:51:18.875
然后我们开始这个函数。

15234
20:51:18.875 --> 20:51:22.782
我们会写modulethatexports = async function。

15235
20:51:22.782 --> 20:51:29.491
我们会得到指定账户和部署。

15236
20:51:29.750 --> 20:51:31.942
我们会说const。

15237
20:51:34.750 --> 20:51:40.282
针对部署器= await，获取指定帐户。

15238
20:51:41.750 --> 20:51:50.394
这里有一个小日志，只是为了开始做我们的基本非函数不接受任何构造函数参数。

15239
20:51:50.394 --> 20:51:55.250
所以我们说const args等于这里的一个小空白。

15240
20:51:55.250 --> 20:52:01.649
然后我们用const basic NFT = await，

15241
20:52:01.649 --> 20:52:10.035
部署basic NFT，我们之前见过很多次了现在我们从Deployer调用。

15242
20:52:10.035 --> 20:52:11.765
Args将是Args。

15243
20:52:11.765 --> 20:52:14.050
然后是log，它是正确的。

15244
20:52:14.050 --> 20:52:16.057
然后我们还会做重量确认。

15245
20:52:16.057 --> 20:52:24.400
它将是network。config。block, confirmation，或者1。

15246
20:52:24.400 --> 20:52:31.038
如果我们想验证这个，我们会再做一次如果它不是development

15247
20:52:31.038 --> 20:52:39.486
chains，。includes network。name。process EMV。

15248
20:52:39.486 --> 20:52:47.130
ether。scan API key会说log verifying。the。

15249
20:52:47.130 --> 20:52:56.385
await，验证基本NF T。address参数它会是空的，抓取这个小日志，把它放在下面。

15250
20:52:56.385 --> 20:52:58.670
然后在基本的NF - T中。

15251
20:52:58.670 --> 20:53:00.912
这应该是参数而不是参数。

15252
20:53:00.912 --> 20:53:02.718
现在我们有了一个部署脚本。

15253
20:53:02.718 --> 20:53:09.636
现在我们在测试数据部署脚本中有了一个基本的非ft，或者任何hh部署或yarn Hardhead部署。

15254
20:53:09.636 --> 20:53:14.415
哦，让我们回到最基本的茶或薄荷

15255
20:53:14.415 --> 20:53:19.195
茶需要返回一个UNT 256。

15256
20:53:19.195 --> 20:53:20.073
再试一次。

15257
20:53:20.073 --> 20:53:24.651
Get令牌计数器也需要返回一个UNT忘记你到其他任何地方。

15258
20:53:24.651 --> 20:53:24.901
不。

15259
20:53:24.901 --> 20:53:25.851
好的，看起来不错。

15260
20:53:25.851 --> 20:53:33.595
看起来我们正在编译编译，部署，如果你想把它部署到溜冰场B，你可以。

15261
20:53:33.595 --> 20:53:37.412
但我建议你先别急，因为我们最后才会这么做。

15262
20:53:37.412 --> 20:53:39.154
现在我们已经编写了部署脚本。

15263
20:53:39.154 --> 20:53:42.751
我们已经写好了合同，你已经知道接下来要做什么了。

15264
20:53:42.751 --> 20:53:43.396
是的,整洁。

15265
20:53:43.396 --> 20:53:47.944
接下来要做的是测试因为我们还没有学到太多东西。

15266
20:53:47.944 --> 20:53:50.460
我不会带领你们完成这个测试。

15267
20:53:50.460 --> 20:53:51.969
我现在要挑战你。

15268
20:53:51.969 --> 20:53:58.322
如何暂停视频，自己写测试，看看你能在测试中走多远。

15269
20:53:58.322 --> 20:54:05.528
记住，要测试它，你需要运行纱线，硬帽测试，让我们看看你是否真的可以自

15270
20:54:05.528 --> 20:54:12.735
己编写测试，然后回到视频中，看看你的测试是否和我们在这里做的一样好。

15271
20:54:12.735 --> 20:54:16.170
当然，你可以去GitHub的回购测试部分。

15272
20:54:16.170 --> 20:54:20.172
如果你迷路了，你可以看看基本的非功能性语言。

15273
20:54:20.172 --> 20:54:20.522
测试。

15274
20:54:20.522 --> 20:54:22.803
跟随。

15275
20:54:22.803 --> 20:54:27.855
好了，欢迎回来。

15276
20:54:27.855 --> 20:54:34.097
希望你写了一些很棒的测试，花时间做一

15277
20:54:34.097 --> 20:54:40.686
些练习真的会让你成为一个更好的工程师。

15278
20:54:40.752 --> 20:54:42.571
跟着我走，太棒了。

15279
20:54:43.752 --> 20:54:47.502
所有事都亲力亲为才能让你坚持下去。

15280
20:54:47.502 --> 20:54:49.202
我希望你们暂停了视频。

15281
20:54:49.202 --> 20:54:55.693
希望你们能够自己编写这个测试，从技术上讲，你们已经创建了一个非常简单的非ft。

15282
20:54:55.752 --> 20:54:56.802
伟大的工作。

15283
20:54:56.802 --> 20:55:00.185
让我们来个升级。

15284
20:55:02.752 --> 20:55:09.475
随机IPFS托管的NFT，在那里我们几乎可以编程地完成所有事情。

15285
20:55:09.475 --> 20:55:10.521
让我们开始吧。

15286
20:55:10.521 --> 20:55:16.290
在我们的契约中，我们将创建一个新文件随机IPFS, NFT。soul。

15287
20:55:16.290 --> 20:55:17.407
同样的事情。

15288
20:55:17.407 --> 20:55:25.842
spdx许可标识符，MIT pragma, soidity carrot 0，点8。

15289
20:55:25.842 --> 20:55:34.152
7、无论你想用什么版本，都会做合同随机IPFS NF吗?T，像这样。

15290
20:55:34.152 --> 20:55:41.391
那么这个会做什么呢?因此，当我们指的是NFT时，我们将触发一

15291
20:55:41.391 --> 20:55:48.872
个链链接VRF调用来获得一个随机数，而不是仅仅铸造任何nff。

15292
20:55:48.872 --> 20:55:54.945
利用这个数，我们将得到一个随机的NF t我们将决定它。

15293
20:55:54.945 --> 20:56:00.863
我们要用的随机n (t)要么是哈巴狗，要么是湿婆，要么是圣。

15294
20:56:00.863 --> 20:56:01.603
伯纳德。

15295
20:56:01.603 --> 20:56:06.379
所以无论什么时候有人铸造NF T，他们都会随机得到这三只狗中的一只。

15296
20:56:06.379 --> 20:56:12.913
我们要让每只狗都有不同的稀有度，我们要让这些狗有不同的稀

15297
20:56:12.913 --> 20:56:19.681
有度，比如我们想让哈巴狗超级稀有，湿婆狗有点稀有，然后圣。

15298
20:56:19.681 --> 20:56:21.372
伯纳德很普通。

15299
20:56:21.372 --> 20:56:25.176
所以湿婆在我们身上可能是非常罕见的，圣。

15300
20:56:25.176 --> 20:56:30.091
伯纳德很常见，对吧?或者是最常见的。

15301
20:56:30.091 --> 20:56:36.495
让我们开始构建这个，我们可能需要创建一个函数叫request

15302
20:56:36.495 --> 20:56:42.685
NF t，因为我们知道我们需要启动一个通道VRF请求，我们

15303
20:56:42.685 --> 20:56:49.304
可能需要让一个函数满足随机单词，那将需要一个请求ID和一个。

15304
20:56:49.304 --> 20:56:57.395
数组，记忆随机单词，就像我们之前看到的，我们过去完成过随机单词。

15305
20:56:57.395 --> 20:57:03.946
让我们让我们更进一步，我们将使用户必须付费铸造NF t。

15306
20:57:03.946 --> 20:57:08.972
所以这将是他们必须支付一定数额的土地来

15307
20:57:08.972 --> 20:57:13.998
获得非所有权然后合同的所有者收回土地。

15308
20:57:13.998 --> 20:57:18.817
所以我们基本上是在付钱给这些艺术家，我们付钱给这些艺术家来创作这些NF - T。

15309
20:57:18.817 --> 20:57:23.212
然后他们就可以收回所有这些NF T的支付。

15310
20:57:23.212 --> 20:57:29.334
当然，我们还需要一个函数，令牌URI，它需要un 256。

15311
20:57:29.334 --> 20:57:35.068
这和我们的基本非函数函数是一样的这就是这个代币的实际样子。

15312
20:57:35.068 --> 20:57:36.939
让我们开始创建这个。

15313
20:57:36.939 --> 20:57:39.437
因为这些红线会把我逼疯的。

15314
20:57:39.437 --> 20:57:45.371
我们会在这里添加一些可见性，我们会让这个请求NFT公共履行

15315
20:57:45.371 --> 20:57:51.511
随机单词，我们实际上从过去知道它将是内部令牌URI将是公共。

15316
20:57:51.511 --> 20:57:53.685
让我们构建这个请求NFT。

15317
20:57:53.685 --> 20:57:58.141
同样，要请求一个随机数，请返回EVM。

15318
20:57:58.141 --> 20:58:02.304
链，我们使用随机性，我们可以跟随博士。

15319
20:58:02.304 --> 20:58:05.383
又是链式链接，来弄清楚如何得到这个随机数。

15320
20:58:05.383 --> 20:58:11.487
既然我们知道我们将使用chain link，我们想要添加at chain link斜杠契约。

15321
20:58:11.487 --> 20:58:15.814
回到我们的代码库中，我们将在yarn中添加dash

15322
20:58:15.814 --> 20:58:22.220
dev在chain link中添加slash合同，就像这样，这是完美的。

15323
20:58:22.220 --> 20:58:27.421
我们可以继续，我们会导入VRF消费者基v2和VRF协

15324
20:58:27.421 --> 20:58:32.622
调器接口到我们的代码中因为我们知道我们会用到这两个。

15325
20:58:32.622 --> 20:58:37.393
如果你想从文档中复制粘贴，你完全可以到这里的暂停。

15326
20:58:37.393 --> 20:58:42.325
既然我们要使用这种消费者基础的观点，我们就想继承它。

15327
20:58:42.325 --> 20:58:47.291
我们会说随机IPFS和tf是vrf消费者基数v2

15328
20:58:47.291 --> 20:58:52.465
这条小的，小的摆动线会在这里显示说，这似乎是覆盖。

15329
20:58:52.465 --> 20:58:54.957
我要在这里添加override。

15330
20:58:54.957 --> 20:59:00.550
这条小的摆动线会在那里停留一段时间直到我们实现剩下的函数。

15331
20:59:00.550 --> 20:59:03.338
下面我们来实现剩下的函数。

15332
20:59:03.338 --> 20:59:06.420
当然，Request NFT在这里会是公共的。

15333
20:59:06.420 --> 20:59:14.683
为了让我们请求一个NF T，我们需要调用协调器。request random words我们传递所有这些东西的地方。

15334
20:59:14.754 --> 20:59:22.539
好，让我们在构造函数中为vref协调器获取所有这些东西，让我们创建一个新的构造函数。

15335
20:59:22.539 --> 20:59:23.396
结构体的门。

15336
20:59:23.396 --> 20:59:30.007
我们会使用VRF消费者基数，两个构造函数用来创建我们的构造函数，

15337
20:59:30.007 --> 20:59:36.206
VRF消费者基数v2需要一个地址在这里用于VRF消费者基数。

15338
20:59:36.206 --> 20:59:38.939
我们继续，我们会处理VRF。

15339
20:59:38.939 --> 20:59:41.523
或者内特·托瑞赢了两个。

15340
20:59:41.523 --> 20:59:46.396
然后我们会把这个传递给VRF消费者基础构

15341
20:59:46.396 --> 20:59:51.513
造函数，只需要添加那个红色的曲线就可以了。

15342
20:59:51.513 --> 20:59:55.021
我们想把这个地址保存到全局变量中。

15343
20:59:55.021 --> 20:59:58.139
我们可以在上面调用request random words。

15344
20:59:58.139 --> 21:00:04.916
我们继续到上面这里，我们说I下划线var F和弦。

15345
21:00:04.916 --> 21:00:08.817
对我来说，Tor，我们将使这个不可变VRF协调器。

15346
21:00:08.817 --> 21:00:15.295
我们会说VRF v2接口，它将是私有的，不可变

15347
21:00:15.295 --> 21:00:21.773
的，你有协调器然后在我们的构造函数中，我们会说

15348
21:00:21.773 --> 21:00:28.817
试管协调器= VRF协调器v2接口像这样包装起来。

15349
21:00:28.817 --> 21:00:32.355
所以我们知道我们会需要这个，我们知道我们实际上会需要很多这个。

15350
21:00:32.355 --> 21:00:39.555
让我们把这些变量都加进来，我们需要协调器，我们需要一个ut64

15351
21:00:39.555 --> 21:00:47.684
private，不可变，I下划线订阅ID，我们需要一个bytes 32

15352
21:00:47.684 --> 21:00:57.207
private，不可变，I下划线gas lane，我们需要一个you int 32

15353
21:00:57.207 --> 21:01:06.033
private，不可变，I下划线callback gas limit，我们需

15354
21:01:06.033 --> 21:01:15.791
需要一个ut16 private常量，请求确认，我们会说它是3，然后是un32。

15355
21:01:15.791 --> 21:01:21.866
私有常量= num words，也就是1，我们会得到

15356
21:01:21.866 --> 21:01:27.941
这条红色的弯弯曲曲的线表示它对我们的构造函数很生气。

15357
21:01:27.941 --> 21:01:32.791
让我们继续，在构造函数中加入所有不可变变量。

15358
21:01:32.791 --> 21:01:40.842
我们会从构造函数得到VRF协调器v2会得到un64订阅ID，我们会得

15359
21:01:40.842 --> 21:01:48.893
到字节32 Gas lane，也就是键哈希，我们会得到un 256。

15360
21:01:48.893 --> 21:01:56.344
我们会做一个unt32回调气体限制，然后

15361
21:01:56.344 --> 21:02:03.795
我们会继续做我订阅ID等于订阅ID我做气

15362
21:02:03.795 --> 21:02:11.620
体通道等于气体通道我回调气体限制等于回调。

15363
21:02:11.756 --> 21:02:13.556
是的限制。

15364
21:02:13.756 --> 21:02:14.709
好了，设置了很多变量。

15365
21:02:15.756 --> 21:02:17.876
我们需要的链链VRF。

15366
21:02:18.756 --> 21:02:21.089
这些变量在我们的请求中。

15367
21:02:22.756 --> 21:02:27.374
对于我们的随机n (t)我们会说，

15368
21:02:27.374 --> 21:02:31.992
我们会返回一个主动性6的请求ID。

15369
21:02:31.992 --> 21:02:36.507
在这里，我们写入request, Id这

15370
21:02:36.507 --> 21:02:41.022
个我们刚初始化的请求Id，下划线VRF。

15371
21:02:41.022 --> 21:02:44.522
核心没有发送洋葱网络请求。

15372
21:02:44.756 --> 21:02:45.542
随机的单词。

15373
21:02:48.756 --> 21:02:50.526
在我们的抽奖中。

15374
21:02:54.756 --> 21:03:01.724
订阅ID，逗号，请求，国家。

15375
21:03:03.757 --> 21:03:05.163
回调气体限制。

15376
21:03:08.757 --> 21:03:15.069
从文档中复制粘贴或者从上一个项目中复制粘贴，随便你怎么做。

15377
21:03:15.069 --> 21:03:19.176
所以我们在这里请求这个随机的非ft。

15378
21:03:19.176 --> 21:03:24.935
事情是这样的，我们希望调用这

15379
21:03:24.935 --> 21:03:30.694
个请求函数的人能在那里喝茶。

15380
21:03:30.757 --> 21:03:38.690
如果我们在基本的NFT中看到，当我们铸造NFT时，我们调用这个安全铸币厂它需要所有者和令牌计数器。

15381
21:03:38.757 --> 21:03:40.994
当我们请求一个随机数时，四个是非ft。

15382
21:03:41.757 --> 21:03:46.429
发生在两个交易中，对吧?我们会先请求，然后再执行，履行这

15383
21:03:46.429 --> 21:03:51.101
将是调用，履行random words，的链式链接节点。

15384
21:03:51.101 --> 21:03:56.666
所以如果它在履行函数中，我们只执行这个安全意味着的消息，这

15385
21:03:56.666 --> 21:04:02.231
个非函数的所有者实际上将是满足我们的随机单词的链链接节点。

15386
21:04:02.231 --> 21:04:08.721
我们不想那样，我们想做的是在请求id之间创建一个映射。

15387
21:04:08.721 --> 21:04:16.424
不管谁调用了这个，当我们调用complededrandom words，它返回完全相同的请

15388
21:04:16.424 --> 21:04:24.127
求ID时，我们可以说，啊，你的请求ID X，你属于调用这个请求的人和团队，我们会在调用这个

15389
21:04:24.127 --> 21:04:32.002
的人和他们的请求ID之间创建一个映射这样当我们实现随机单词时，我们可以正确地将狗分配给他们。

15390
21:04:32.002 --> 21:04:40.145
在上面，就在这下面，我称它们为VRF助手，我们将创建一个un 256的映射。

15391
21:04:40.145 --> 21:04:48.987
对于一个地址，我们将它设为public本应设为private，但我们将它设为public s下划线请求ID To sender。

15392
21:04:48.987 --> 21:04:51.876
然后当我们调用这个请求时，F

15393
21:04:51.876 --> 21:05:00.958
T会设置请求ID为sender request ID等于message。sender。

15394
21:05:00.958 --> 21:05:09.439
现在，当链节点用随机数完成响应时，我们能做的是我们可以说地

15395
21:05:09.439 --> 21:05:17.921
址狗主人或非ft狗主人将等于s请求ID到请求ID的发送者。

15396
21:05:17.921 --> 21:05:26.266
这样，就不是拥有狗的链接节点，而是真正调用请求的节点。

15397
21:05:26.266 --> 21:05:26.593
非功能性测试。

15398
21:05:26.758 --> 21:05:27.234
好的,很酷。

15399
21:05:29.758 --> 21:05:30.631
随机NF t。

15400
21:05:34.758 --> 21:05:38.215
这个用户的随机NF T。

15401
21:05:40.758 --> 21:05:44.805
利用这个映射，我们还需要什么?我们这里需要一个代币柜台。

15402
21:05:44.805 --> 21:05:47.699
让我们继续，我们将创建一个令牌计数器变量。

15403
21:05:47.699 --> 21:05:50.535
我们会向上滚动，创建一个新section。

15404
21:05:50.535 --> 21:05:52.979
我们说，un256。

15405
21:05:52.979 --> 21:05:59.809
然后，我们会把很多这些设为公共，这样更简单，但你可能会想设为私有

15406
21:05:59.809 --> 21:06:06.639
使用我们之前做过的语法dos_因为这是一个存储变量，令牌计数器。

15407
21:06:06.639 --> 21:06:08.944
我们会抓取这个代币计数器。

15408
21:06:08.944 --> 21:06:11.528
我们就说你到了56岁。

15409
21:06:11.528 --> 21:06:16.367
新的令牌ID等于作为令牌计数器，现在我们有了狗

15410
21:06:16.367 --> 21:06:21.417
的主人和令牌ID，我们可以继续并铸造这个MFT。

15411
21:06:21.417 --> 21:06:23.563
我们用安全薄荷。

15412
21:06:23.759 --> 21:06:31.365
所有者，新令牌，ID然后safe man会是弯弯曲曲的因为代码会问，这是什

15413
21:06:31.365 --> 21:06:39.177
么?什么是安全薄荷函数?你从哪儿弄来的?我们得再从开着的齐柏林飞艇上取下来。

15414
21:06:39.177 --> 21:06:47.909
我们将继续，在open Zeppelin上输入/合约/令牌/ ERC。

15415
21:06:47.909 --> 21:06:50.009
721斜杠ERC。

15416
21:06:50.009 --> 21:06:51.209
720一个。

15417
21:06:51.209 --> 21:06:58.145
所以我们会说一个随机的空IPFS是消费者基数的Vera和ERC 721，在我

15418
21:06:58.145 --> 21:07:05.081
们的构造函数中，就在我们的V RF消费者基数之后，我们将放入ERC 721。

15419
21:07:05.081 --> 21:07:10.678
同样的，我们需要给它一个名字和一个符号。

15420
21:07:10.678 --> 21:07:14.742
我们称其为随机IPFS NF T。

15421
21:07:14.742 --> 21:07:18.687
逗号，我们只做随机IPFS NF团队的Rin。

15422
21:07:18.687 --> 21:07:22.559
现在安全薄荷真的起作用了然后它会为此生我的气。

15423
21:07:22.559 --> 21:07:24.723
所以我要重写它，让它不再生我的气。

15424
21:07:24.759 --> 21:07:30.249
公共视图覆盖转换字符串内存。

15425
21:07:31.759 --> 21:07:32.877
弯弯曲曲的线。

15426
21:07:32.877 --> 21:07:33.436
好的,很酷。

15427
21:07:33.436 --> 21:07:33.893
太好了。

15428
21:07:34.759 --> 21:07:39.925
安全薄荷给狗主人这个新的代币

15429
21:07:39.925 --> 21:07:45.092
ID我们说完了吗?绝对不是。

15430
21:07:45.092 --> 21:07:48.791
为什么不呢?我们不知道这个代币长什么样。

15431
21:07:48.791 --> 21:07:53.548
我们在上面设置的是我们想要让这些狗变得不同寻常。

15432
21:07:53.548 --> 21:07:59.323
那么我们如何创造这些稀有狗，我们所能做的就是创建一

15433
21:07:59.323 --> 21:08:05.099
个机会数组一个数组来显示这些不同狗出现的不同机会。

15434
21:08:05.099 --> 21:08:10.307
下面，我们要创建一个函数它是一个公共纯函

15435
21:08:10.307 --> 21:08:15.776
数，叫做get chance array。

15436
21:08:15.776 --> 21:08:23.612
这将返回内存中大小为3的46。

15437
21:08:23.612 --> 21:08:29.707
这个概率数组将代表不同狗的不同概率。

15438
21:08:29.760 --> 21:08:38.529
所以我们说，返回10 3100或者我们说，最大机会值。

15439
21:08:38.760 --> 21:08:41.360
在上面空变量下面。

15440
21:08:42.760 --> 21:08:48.366
内部常数为56，最大机会值为100。

15441
21:08:48.760 --> 21:08:55.343
通过创建这个数组，我们说索引0有10%的概率发生。

15442
21:08:55.343 --> 21:09:03.350
指数1发生的概率是20%因为它是30 - 10。

15443
21:09:03.350 --> 21:09:11.410
然后我们说指数2有60%的概率发生，因为它是10 + 30。

15444
21:09:11.410 --> 21:09:12.600
减去这个100。

15445
21:09:12.760 --> 21:09:16.072
这个数组确定了不同狗的比例。

15446
21:09:16.072 --> 21:09:23.705
我们说哈巴狗有10%的机会，湿婆在你身上有20%的机会，圣。

15447
21:09:23.705 --> 21:09:30.794
Bernard有70%的几率，我们会用它来给这个代币ID我们刚刚铸造了它的狗的品种。

15448
21:09:30.794 --> 21:09:35.723
我们会创建一个新函数叫Get breed from modded RNG。

15449
21:09:35.723 --> 21:09:41.507
我们调用get breed from modded RNG的原因是完全相同的。

15450
21:09:41.507 --> 21:09:42.301
在我们的抽奖中。

15451
21:09:42.301 --> 21:09:49.697
我们有一个随机数，我们说你有56个modded RNG等于0的随机

15452
21:09:49.697 --> 21:09:57.094
单词mod最大的机会值，我们将对我们得到的任何数字mod 100。

15453
21:09:57.094 --> 21:10:00.894
这样做，我们总是会得到一个0到99之间的数。

15454
21:10:00.894 --> 21:10:05.099
如果随机单词为0，对Max Chin的值进行mod将是7。

15455
21:10:05.099 --> 21:10:07.336
也就是说我们要养只哈巴狗。

15456
21:10:07.336 --> 21:10:08.217
如果我们得到88。

15457
21:10:08.217 --> 21:10:11.450
这意味着我们会得到一个圣。

15458
21:10:11.450 --> 21:10:13.932
伯纳德，如果我们得到45。

15459
21:10:13.932 --> 21:10:17.711
我们会得到什么?没错，圣。

15460
21:10:17.711 --> 21:10:21.914
伯纳德，如果我们得到12我们就会得到湿婆。

15461
21:10:21.914 --> 21:10:28.761
如果我们通过建模这个随机单词得到的mod ID号在0到10之间。

15462
21:10:28.761 --> 21:10:32.416
10岁到30岁之间的是哈巴狗。

15463
21:10:32.416 --> 21:10:35.563
街30号至100号之间的柴犬。

15464
21:10:36.761 --> 21:10:39.367
这就是我们如何得到这些随机值的。

15465
21:10:39.761 --> 21:10:44.729
我们有这个modded RNG，我们有这个mod ID号它将在0到99之间。

15466
21:10:44.729 --> 21:10:49.094
这个函数叫Get breed from modded RNG。

15467
21:10:49.094 --> 21:10:54.465
这将使用un256 mod ID RNG将

15468
21:10:54.465 --> 21:10:59.837
使这成为一个公共纯函数，它将返回狗的品种。

15469
21:10:59.837 --> 21:11:05.416
现在狗的品种将是一个类似于我们之前做过的抽奖状态的电子邮件。

15470
21:11:05.416 --> 21:11:12.203
我们将在顶部做这个因为这将是一个类型声明或enum。

15471
21:11:12.203 --> 21:11:16.761
读，我们会说带数字的0是给哈巴狗的。

15472
21:11:16.761 --> 21:11:20.568
这个数字就是你体内的湿婆。

15473
21:11:20.568 --> 21:11:23.796
第二个是St。

15474
21:11:23.796 --> 21:11:24.485
伯纳德。

15475
21:11:24.485 --> 21:11:27.962
我们有哈巴狗，从0到10。

15476
21:11:27.962 --> 21:11:32.262
湿婆在你身上10到30圣伯纳德30到100。

15477
21:11:32.262 --> 21:11:37.358
所以从改装的RNG公共纯返回品种。

15478
21:11:37.358 --> 21:11:42.135
所以我们会循环这个我们会说直觉上6

15479
21:11:42.135 --> 21:11:46.912
的累积和等于0，我们会说你到56。

15480
21:11:46.912 --> 21:11:55.253
大小为3的内存机会数组等于一个机会数组。

15481
21:11:55.253 --> 21:11:59.149
我们得到了这个机会数组。

15482
21:11:59.149 --> 21:12:03.774
所以我们要创建一个小的for循环我们会说，for

15483
21:12:03.774 --> 21:12:10.713
you到56i它将从0开始小于chance array。length。

15484
21:12:10.713 --> 21:12:14.574
我+ +在这里运行了for循环。

15485
21:12:14.574 --> 21:12:21.342
我们会说如果modded RNG大于

15486
21:12:21.342 --> 21:12:27.358
或等于这个累积和并且modded

15487
21:12:27.358 --> 21:12:34.502
RNG小于累积和加上机会数组加上机会数

15488
21:12:34.502 --> 21:12:41.647
数组上的任何位置，那么返回AI的品种。

15489
21:12:41.762 --> 21:12:50.580
然后在这外面，我们会说累积和加上等于I的机会数组，我们说中等橙色的等于25。

15490
21:12:50.580 --> 21:12:56.860
如果是25，那应该是湿婆在你体内，因为那是在10到30之间。

15491
21:12:56.860 --> 21:13:04.664
所以我们说，如果mod RNG，也就是25大于或等于累积和，

15492
21:13:04.664 --> 21:13:14.029
现在是0，并且小于n, Moto G小于累积和加上I的机会数组I的机会数

15493
21:13:14.029 --> 21:13:22.874
机会数组将是10返回的品种I的累积和目前是0加上I的机会I是10将是10。

15494
21:13:22.874 --> 21:13:26.496
这不是真的，因为莫拉吉才25岁。

15495
21:13:26.496 --> 21:13:31.360
既然这不是真的，我们就进入第二步也就是累积和，

15496
21:13:31.360 --> 21:13:36.013
加上等于概率，对吧?所以累积和现在等于10。

15497
21:13:36.013 --> 21:13:38.213
然后我们到达了for循环的末尾。

15498
21:13:38.213 --> 21:13:42.969
重新开始，i现在等于1，我们再试一次mod

15499
21:13:42.969 --> 21:13:48.631
RNG大于等于累加和，这是对的，累加和等于10。

15500
21:13:48.631 --> 21:13:50.237
Mod RNG是25。

15501
21:13:50.237 --> 21:13:56.969
mod RNG小于AI的累积和加上机会re，也就是30。

15502
21:13:56.969 --> 21:14:02.143
25小于10 + 30，等于40。

15503
21:14:02.143 --> 21:14:05.096
回归人工智能的品种，这是真的。

15504
21:14:05.096 --> 21:14:09.601
所以人工智能的繁殖是正确的，人工智能目前是一个。

15505
21:14:09.601 --> 21:14:12.903
如果我们向上滚动，那确实是你体内的湿婆。

15506
21:14:12.903 --> 21:14:18.548
这就是这个函数的工作原理，它会让我们从那个建模点得到品种。

15507
21:14:18.548 --> 21:14:26.613
然后如果由于某种原因，这里发生了一些非常奇怪的事情，我们想要继续并添加一个回复，对吧，因为我们应该返回一个品种。

15508
21:14:26.613 --> 21:14:29.484
但如果我们不返回一个品种，我们就应该返回。

15509
21:14:29.484 --> 21:14:34.563
我们将在顶部创建一个新错误，随机IPFS NFT下

15510
21:14:34.563 --> 21:14:39.643
划线下划线range out of bounds。

15511
21:14:39.764 --> 21:14:48.354
下面这个，我们会说如果因为某种原因你没有返回任何东西，只要做一个revert random IPFS NFT range out of bounds。

15512
21:14:48.354 --> 21:14:50.321
现在我们有了这个函数。

15513
21:14:50.321 --> 21:14:53.264
好了，现在我们可以从modded RNG中获取摘要。

15514
21:14:53.264 --> 21:14:55.893
所以在我们的实现随机单词函数中。

15515
21:14:55.893 --> 21:15:02.638
我们继续，我们会说，我们取消注释这里会说，breed, dog breed，

15516
21:15:02.638 --> 21:15:09.561
等于get breed for modded RNG传递modded RNG，

15517
21:15:09.561 --> 21:15:16.485
然后把这个安全薄荷移到下面获取狗的繁殖者这样我们就可以薄荷并同时添加狗的繁殖。

15518
21:15:16.485 --> 21:15:22.564
所以我们要继续在这里安全地薄荷。

15519
21:15:23.764 --> 21:15:28.799
现在我们可以做一些事情来设置这个狗的品种，我们在狗的品种和令

15520
21:15:28.799 --> 21:15:34.002
牌URI之间创建一个映射，然后让它反映在这个令牌URI函数中。

15521
21:15:34.002 --> 21:15:42.674
或者我们可以调用一个函数叫做Set令牌URI和openzeppelin ERC 721你必须自己设置这个令牌你的眼睛函数。

15522
21:15:42.674 --> 21:15:47.525
然而，在开放的齐柏林代码中有一个扩展叫做ERC。

15523
21:15:47.525 --> 21:15:51.626
721 Uri存储和这个版本的ERC。

15524
21:15:51.626 --> 21:15:57.979
721附带了一个叫做Set token URI的函数，我们可以调用Set token URI。

15525
21:15:57.979 --> 21:16:03.982
这将自动更新那个令牌令牌URI为你设置的任何值。

15526
21:16:03.982 --> 21:16:09.684
我们将在契约中使用这个扩展集令牌URI。

15527
21:16:09.764 --> 21:16:17.101
我们这样做的方式不是用令牌ERC 721 Year C 721

15528
21:16:17.101 --> 21:16:25.385
soul会用令牌ERC 721 /扩展/你的C 721 /你的存储。

15529
21:16:25.385 --> 21:16:26.522
这是所有。

15530
21:16:26.522 --> 21:16:33.265
随机IPFS是ERC 721你的大米储存。

15531
21:16:33.265 --> 21:16:40.092
现在最酷的是，我们的构造函数仍然只使用ERC。

15532
21:16:40.092 --> 21:16:45.641
因为ERC 721 Uri存储扩展了ERC 721。

15533
21:16:45.641 --> 21:16:52.493
这个契约附带了一些附加函数，比如set token URI。

15534
21:16:52.493 --> 21:16:59.542
就在safe的意思之后，我们会调用set令牌URI带有这个新项目ID。

15535
21:16:59.542 --> 21:17:05.868
然后我们会给它那个breedtoken URI，我们会在

15536
21:17:05.868 --> 21:17:12.420
这里给它一个字符串它与我们刚从狗的品种得到的任何品种相关。

15537
21:17:12.420 --> 21:17:18.377
现在，要做到这一点，我们可以在顶部我们的非ft变量，我们可以

15538
21:17:18.377 --> 21:17:24.334
创建一个字符串数组，内部，Alt S dog token，你

15539
21:17:24.334 --> 21:17:30.490
的眼睛，我们要让这个常量它就是我们创建的所有这些字符串的数组。

15540
21:17:30.490 --> 21:17:34.288
但在我们的代码中，我们想让这个变量更多一点。

15541
21:17:34.288 --> 21:17:36.383
我们要把它参数化。

15542
21:17:36.383 --> 21:17:37.939
这正是我们要做的。

15543
21:17:37.939 --> 21:17:44.634
我们会创建这个字符串数组，内部s下划线狗牌，你的眼睛，这将是

15544
21:17:44.634 --> 21:17:51.329
这些url的列表这些url指向这样的东西，我们会在代码中做这

15545
21:17:51.329 --> 21:17:58.249
个这样当我们上传任何图片到IPFS时我们就可以上传这个s狗牌。

15546
21:17:58.249 --> 21:18:06.046
在构造函数中，我们会引入另一个形参叫做一个大小为3的字符串，memory

15547
21:18:06.046 --> 21:18:15.143
dog token，我们会把它作为构造函数形参传递，这些不同的dog token。

15548
21:18:15.143 --> 21:18:19.352
我们要传递给它这个狗标记的列表。

15549
21:18:19.352 --> 21:18:22.749
当然，0将是哈巴狗的令牌URI。

15550
21:18:22.749 --> 21:18:25.946
一个是你体内的湿婆，第二个当然是圣。

15551
21:18:25.946 --> 21:18:26.208
伯纳德。

15552
21:18:26.208 --> 21:18:31.663
我们会把这个狗标记你的眼睛的列表传给它，然后

15553
21:18:31.663 --> 21:18:37.119
从我们创建的列表中往下到set标记你的眼睛。

15554
21:18:37.119 --> 21:18:44.716
我们会设置这个令牌的URI基于那个数组的UN 256版本

15555
21:18:44.716 --> 21:18:52.314
的那个品种将这个狗的品种转换回你和256来获取它的索引。

15556
21:18:52.314 --> 21:18:57.425
有了这个，我们就有了一种方法，通过编程得到一个可证

15557
21:18:57.425 --> 21:19:02.536
明的随机非函数对于不同的非函数T具有不同的随机性。

15558
21:19:02.536 --> 21:19:08.149
现在，让我们回到我们的小评论，我们在这里做的小

15559
21:19:08.149 --> 21:19:14.007
评论，有限的非ft，我们触发一个链链接或VRF。

15560
21:19:14.007 --> 21:19:17.750
要打随机数，我们就得把稀有物品和铸币都弄下来。

15561
21:19:17.750 --> 21:19:18.242
太棒了。

15562
21:19:18.242 --> 21:19:20.580
好吧，不过我们没有这部分。

15563
21:19:20.766 --> 21:19:25.454
用户必须支付给Minton NF T，合同的所有者可以收回土地。

15564
21:19:25.454 --> 21:19:28.952
这是我们之前做过的，应该很熟悉。

15565
21:19:28.952 --> 21:19:32.516
回到我们的requestnft函数，我们会让它成为公共支付。

15566
21:19:32.516 --> 21:19:40.477
我们只需要说如果message。value小于某个mint fee，我们回到

15567
21:19:40.477 --> 21:19:48.648
构造函数，我们会创建一个mint fee, int 256 mint fee。

15568
21:19:48.767 --> 21:19:55.155
然后我们会在256内部I下划线mint fee，我们会让它是不可变的。

15569
21:19:55.155 --> 21:19:58.885
然后我们会说I'm intervention = mint fee。

15570
21:19:58.885 --> 21:20:05.923
如果message of value小于mint fee，你已经知道我们会做一个回复，

15571
21:20:05.923 --> 21:20:14.434
需要更多eath sent，我们会创建一个新的air叫做，需要更多eath sent实际上我们会做air

15572
21:20:14.434 --> 21:20:22.619
random IPFS和，下面加上，下面加上，需要更多II sent，复制这个，粘贴到这里，好了。

15573
21:20:22.619 --> 21:20:26.889
现在只要加上这一行，这就是一个可支付函数。

15574
21:20:26.889 --> 21:20:32.444
人们需要支付一些铸币费来铸币他们的随机NF t。

15575
21:20:32.444 --> 21:20:36.100
现在我们还需要一种让所有者提款的方法。

15576
21:20:36.100 --> 21:20:38.258
我们往下滚动一点。

15577
21:20:38.258 --> 21:20:44.077
向下滚动到这里，createfunction withdraw，这是公共的。

15578
21:20:44.077 --> 21:20:46.042
我们只希望所有者这样做。

15579
21:20:46.042 --> 21:20:53.403
我们可以创建修饰符，一个修饰符只有owner，或者我们可以使用openzeppelin。

15580
21:20:53.403 --> 21:21:00.575
同样，openzeppelin也带有一些访问代码，或者说其中一个是这个可

15581
21:21:00.575 --> 21:21:07.947
拥有代码，在这里，它已经为我们提供了唯一的所有者修饰符，我们将继续导入它。

15582
21:21:07.947 --> 21:21:13.259
我们会输入import at openzeppelin /合同/

15583
21:21:13.259 --> 21:21:18.905
access / owable。som，我们会说合同随机IPFS。

15584
21:21:18.905 --> 21:21:22.629
如果t是这个，这个是可拥有的。

15585
21:21:22.629 --> 21:21:26.315
然后我们让取款函数只有所有者。

15586
21:21:26.315 --> 21:21:31.241
因此，无论谁部署了这个合同，都将被设置为所有者，这是我们想要的。

15587
21:21:31.241 --> 21:21:36.155
在这里，和我们做的一样，我们做u和256。

15588
21:21:36.155 --> 21:21:40.686
金额等于地址这个点余额。

15589
21:21:40.686 --> 21:21:47.576
然后我们会写success，逗号= payable, message。

15590
21:21:47.576 --> 21:21:55.452
sender，但callvalue将是一个mount然后我们将调用什么都不调用。

15591
21:21:55.452 --> 21:21:59.208
然后我们会说if not success。

15592
21:21:59.208 --> 21:22:04.295
我们会用transfer failed进行恢复，然后在上

15593
21:22:04.295 --> 21:22:09.383
面，我们会用error transfer failed。

15594
21:22:09.383 --> 21:22:17.664
我要复制得快一点，像这样然后返回到传输失败粘贴到这里。

15595
21:22:17.664 --> 21:22:19.948
我们将恢复随机IPFS。

15596
21:22:19.948 --> 21:22:26.393
如果转账失败，那就太好了，现在我们有了取款功能，让人们可以在这里为艺术品付款。

15597
21:22:26.393 --> 21:22:33.535
现在我们不再需要这个令牌URI了，因为当我们调用set令牌URI时，它会

15598
21:22:33.535 --> 21:22:40.678
为我们设置令牌URI因为在ERC 721 URI存储中已经有了这个函数。

15599
21:22:40.678 --> 21:22:46.218
我们的契约已经有令牌URI函数了，我们不需要自己显式地设置它。

15600
21:22:46.218 --> 21:22:48.668
但我们需要显式地设置一些其他的。

15601
21:22:48.768 --> 21:22:56.301
我们需要function get意味着fee将是一个公共视图转到36转我的

15602
21:22:56.301 --> 21:23:03.834
意思是fee将需要function get dog token你的眼睛，你

15603
21:23:03.834 --> 21:23:05.870
到36 index，

15604
21:23:05.870 --> 21:23:19.311
这将是一个公共视图它将返回字符串内存返回s下划线狗token你的眼睛索引将需要function get token counter。

15605
21:23:19.311 --> 21:23:27.824
这将是一个公共视图，把你变成56返回的下划线令牌计数器。

15606
21:23:27.824 --> 21:23:30.894
好了，我们刚刚写了很多代码。

15607
21:23:30.894 --> 21:23:35.118
当然，就像我们之前教过的，我们还需要一些事件。

15608
21:23:35.118 --> 21:23:40.107
当我们请求一个NF T时，我们会触发一个事件。

15609
21:23:40.107 --> 21:23:45.644
因此，我们将省略nft请求，然后将请求传递给它。

15610
21:23:45.644 --> 21:23:47.456
消息点发送方中的ID。

15611
21:23:47.456 --> 21:23:54.010
所以在上面会说事件nft请求。

15612
21:23:54.010 --> 21:24:01.785
pet，取一个un256索引请求ID，然后是地址请求器。

15613
21:24:01.785 --> 21:24:07.126
然后我们还会为ntf minted创建一个事件当它最终被minted时。

15614
21:24:07.126 --> 21:24:13.096
它需要一个品种，狗的品种，和一个地址，导师。

15615
21:24:13.096 --> 21:24:19.644
所以写下来，当我们完成时，我们将发射非ft。

15616
21:24:19.644 --> 21:24:20.519
铸造。

15617
21:24:20.769 --> 21:24:29.621
它会选择狗的品种，然后是狗的主人。

15618
21:24:29.769 --> 21:24:33.236
我们刚刚写了很多代码。

15619
21:24:34.769 --> 21:24:38.680
看看我们是否可以用H H编译，或者yarn Hardhead编译。

15620
21:24:38.680 --> 21:24:41.479
哇，看起来我们继续编译了它。

15621
21:24:41.479 --> 21:24:42.382
这太棒了。

15622
21:24:42.382 --> 21:24:44.575
现在所有的代码看起来都很好。

15623
21:24:44.770 --> 21:24:47.837
现在可能是休息一下的好时候了，我们刚刚写了很多代码。

15624
21:24:47.837 --> 21:24:51.822
复习一下我们刚刚讲过的内容可能会更好。

15625
21:24:51.822 --> 21:24:58.231
很多这是熟悉的，但它仍然是真的很好，重做一些东西，真正得到肌肉记忆和这些

15626
21:24:58.231 --> 21:25:04.820
信用，一个NFT合同，当你铸造，其中一个NFT，你将得到一个湿婆在你或圣。

15627
21:25:04.820 --> 21:25:08.820
伯纳德，基于某种稀有性，而哈巴狗真的很罕见。

15628
21:25:08.820 --> 21:25:11.166
在圣。

15629
21:25:11.166 --> 21:25:12.753
伯纳德很普通。

15630
21:25:12.753 --> 21:25:17.630
我们的方法是，我们有一个请求NF - t函数，人们需要

15631
21:25:17.630 --> 21:25:22.689
付费调用它向一个链连接节点发出一个请求以获得一个随机数。

15632
21:25:22.689 --> 21:25:27.354
一旦我们的契约得到了随机数使用一个机会数

15633
21:25:27.354 --> 21:25:32.254
组来找出我们将使用哪个NF T来进行铸造。

15634
21:25:32.254 --> 21:25:34.735
我们会相应地设置令牌URI。

15635
21:25:34.735 --> 21:25:40.693
我们会把图像数据存储在IPFS上，这个我们还没做过。

15636
21:25:40.770 --> 21:25:45.603
这里的deploy函数将是合约中有趣的部分。

15637
21:25:45.603 --> 21:25:53.399
但是因为我们已经讲了这么多了，如果你们想休息一下喘口气，然后再回来，我鼓励你们这样做我们学到了很多。

15638
21:25:53.399 --> 21:25:55.140
我们写了很多坚固性代码。

15639
21:25:55.140 --> 21:25:58.597
快去喘口气吧，我们一会儿见。

15640
21:25:58.597 --> 21:26:00.398
我们继续，

15641
21:26:00.398 --> 21:26:11.208
在这里创建一个新的deploy，进入ploy，随机ipfs。

15642
21:26:11.208 --> 21:26:11.558
js。

15643
21:26:11.558 --> 21:26:19.512
这和我们之前做过的彩票合约非常相似。

15644
21:26:19.512 --> 21:26:28.347
我们可以从这里的代码中复制一些样板，我们需要所有这些，我们复制这个，用一个小花括号结束然后，我们就得到了一个样板。

15645
21:26:28.347 --> 21:26:32.032
现在，因为我们在使用chainlink，在这里，我们将再次使用mock。

15646
21:26:32.032 --> 21:26:37.705
返回new file 00, deploymocks。js。

15647
21:26:37.705 --> 21:26:43.908
如果你愿意，你可以从前面的部分复制粘贴我们用raffle / lottery做的。

15648
21:26:43.908 --> 21:26:51.192
因为我们将在这里做完全相同的事情，我将继续，暂停，你可以从以前的项目中复制粘贴。

15649
21:26:51.192 --> 21:26:57.371
或者，如果你愿意，你可以到与这门课相关的GitHub回购，到部署。

15650
21:26:57.371 --> 21:27:00.121
然后从这里获取部署模拟。

15651
21:27:00.121 --> 21:27:08.658
如果你从GitHub回购中抓取，我们还将使用一个模拟v3聚合器，但我还不打算把那部分添加进去，因为我们还不需要它。

15652
21:27:08.658 --> 21:27:10.721
现在请暂停视频。

15653
21:27:10.721 --> 21:27:16.703
复制并粘贴VRF协调器模拟或暂停视频并尝试自己编写模拟代码。

15654
21:27:16.771 --> 21:27:17.278
好了,好了。

15655
21:27:19.771 --> 21:27:26.187
集中ID network。config。chain ID，因为我们需要决定我们是否在开发链上。

15656
21:27:26.187 --> 21:27:33.640
和我们之前做的一样我们会说如果开发链包含network。name，我们

15657
21:27:33.640 --> 21:27:40.880
会说const VRF coordinator, B to mock

15658
21:27:40.880 --> 21:27:48.548
goes await ethers。get contract VRF。

15659
21:27:48.548 --> 21:27:49.103
核心。

15660
21:27:49.103 --> 21:27:55.893
模拟的名字类似于抽奖我们会说，让VRF协调Tor

15661
21:27:55.893 --> 21:28:03.533
v两个地址，相同，VRF协调器v两个地址等于VRF。

15662
21:28:03.533 --> 21:28:07.924
协调器v2mach mock那个地址然后

15663
21:28:07.924 --> 21:28:12.535
我们要创建一个订阅就像我们对彩票做的一样。

15664
21:28:12.535 --> 21:28:17.645
我们会说const TX = weight VRF coordinate

15665
21:28:17.645 --> 21:28:22.755
tore V to mock。create subscription。

15666
21:28:22.755 --> 21:28:30.216
然后我们会写const TX receipt = weight, TX。

15667
21:28:30.216 --> 21:28:35.411
我们会从这里获取子ID和我们在彩票部分做的完全一样。

15668
21:28:35.411 --> 21:28:41.866
我们需要那个子ID通过subsubscription ID我们会说，

15669
21:28:41.866 --> 21:28:49.272
subscription ID = TX receipt。events, 0。

15670
21:28:49.272 --> 21:28:52.147
args找到了某人。

15671
21:28:52.147 --> 21:29:00.043
这就是我们在开发链上所做的，如果VRF

15672
21:29:00.043 --> 21:29:07.939
坐标V到地址等于链ID点VRF坐标的网

15673
21:29:07.939 --> 21:29:15.837
络配置或者B到那订阅ID等于网络配置。

15674
21:29:15.837 --> 21:29:18.689
链ID。订阅ID。

15675
21:29:18.689 --> 21:29:19.475
完美的。

15676
21:29:19.772 --> 21:29:23.518
然后我们会再次检查我们的助手安全帽配置。

15677
21:29:23.772 --> 21:29:27.392
Rigby同时拥有VRF协调器v2。

15678
21:29:28.772 --> 21:29:30.403
需要一个订阅ID。

15679
21:29:31.772 --> 21:29:35.209
订阅ID来自我们过去的彩票项目。

15680
21:29:35.209 --> 21:29:42.706
但是我们可以走到V或者F。链链，我们可以走到vrf，这个链链可以确保我们在溜冰场B上。

15681
21:29:42.773 --> 21:29:44.042
让我们看看我们的其他订阅。

15682
21:29:44.773 --> 21:29:46.042
我们这里有一个。

15683
21:29:49.773 --> 21:29:50.106
里格比。

15684
21:29:53.773 --> 21:30:01.789
链，合同地址，使用回忆，看到更多参数，特别是Rigby，确保这些都是正确的。

15685
21:30:01.789 --> 21:30:09.773
我们这里有订阅，我们很快会添加一个新的消费者一旦我们部署了这个契约如果我们要使用RankBrain。

15686
21:30:09.773 --> 21:30:14.740
我们在这里用连字符写一个小log。

15687
21:30:14.740 --> 21:30:20.616
我们现在会得到args =，我们会在这里做参数。

15688
21:30:20.616 --> 21:30:25.216
我们需要什么，我们需要协调员订阅，汽油回调，

15689
21:30:25.216 --> 21:30:30.027
地址，狗，你的狗token，你的眼睛和管理费。

15690
21:30:30.027 --> 21:30:37.966
因此，我们将需要VRF协调器来处理订阅ID。

15691
21:30:37.966 --> 21:30:41.805
我们还需要网络配置。

15692
21:30:41.805 --> 21:30:44.288
链ID点气道。

15693
21:30:44.288 --> 21:30:52.855
我们需要网络配置链ID点意味着费用，然后我们将留

15694
21:30:52.855 --> 21:31:01.423
下工作配置链ID点回调气体限制正确的顺序?是的。

15695
21:31:01.423 --> 21:31:06.695
然后我们需要狗的记

15696
21:31:06.695 --> 21:31:12.553
号你的眼睛和铸币费。

15697
21:31:12.773 --> 21:31:17.215
现在我们没有什么，我们没有标记你眼睛的数组。

15698
21:31:17.215 --> 21:31:19.330
我们有几种方法可以做到这一点。

15699
21:31:19.330 --> 21:31:26.325
如果你去到与此相关的GitHub回购，去部署，我们实际上做了随机，哦，3

15700
21:31:26.325 --> 21:31:33.515
在get这里，有一个部分我们会自动说，好，很好的令牌，你上升的就是这三个。

15701
21:31:33.515 --> 21:31:42.015
如果我们能复制粘贴这些cd到IPFS上，这些是更好的有IPFS作为图像的cd。

15702
21:31:42.015 --> 21:31:43.466
我们可以看到它们像这样。

15703
21:31:43.466 --> 21:31:45.937
所以我们可以用我已经部署好的东西。

15704
21:31:45.937 --> 21:31:51.092
如果你想这样做，你绝对百分之百可以，或者我们可以做的

15705
21:31:51.092 --> 21:31:56.248
是我们可以学习通过编程上传我们自己的图像到IPFS。

15706
21:31:56.248 --> 21:31:57.942
听起来酷多了。

15707
21:31:57.942 --> 21:31:59.974
我们来做一下。

15708
21:31:59.974 --> 21:32:03.940
现在我想让你们做的是，如果你们想用你们自己的图像来做这个，请随意。

15709
21:32:03.940 --> 21:32:09.601
但如果你想跟着我们，那我们就去Hardhead NFT FCC回购。

15710
21:32:09.601 --> 21:32:14.921
我们将从他那里随机获取这些NF - T。

15711
21:32:14.921 --> 21:32:16.986
所以你能做的就是到这里来。

15712
21:32:16.986 --> 21:32:24.329
我们可以继续，右键点击保存图像Jas，我们将它保存到下载，我们创建一个新文件夹，命名为images。

15713
21:32:24.329 --> 21:32:29.475
图像会创建一个名为random的新文件夹，然后我

15714
21:32:29.475 --> 21:32:34.621
们可以把它拉到这里，命名为random NFT。

15715
21:32:34.621 --> 21:32:38.349
这是png格式的。

15716
21:32:38.349 --> 21:32:41.174
我们可以对所有的图像这样做。

15717
21:32:41.174 --> 21:32:45.574
现在在我们的图片标签中，我们有你和圣伯纳德的哈巴狗船。

15718
21:32:45.574 --> 21:32:47.218
这是局部的。

15719
21:32:47.218 --> 21:32:49.503
但我们想把这些上传到IPFS。

15720
21:32:49.503 --> 21:32:53.070
我们想以一种任何人都能钉住它们并使用它们的方式上传它们。

15721
21:32:53.070 --> 21:32:57.844
在我们做这些之前，在我们得到部署契约的参

15722
21:32:57.844 --> 21:33:02.619
数之前，我们需要得到图像的IPFS散列。

15723
21:33:02.619 --> 21:33:06.332
有几种方法可以做到这一点。

15724
21:33:06.332 --> 21:33:14.282
我们用我们自己的IPFS节点来做，我已经向你们展示了如何手动做，我们也可以通过编程来做。

15725
21:33:14.282 --> 21:33:16.041
现在，我不会告诉你们怎么做。

15726
21:33:16.041 --> 21:33:24.068
但是，如果您仔细阅读IPFS文档，您实际上可以通过命令行甚至通过一些脚本了解如何执行该操作。

15727
21:33:24.068 --> 21:33:27.375
但是，如果我们是唯一运行这个的节点，这就有点集中了。

15728
21:33:27.375 --> 21:33:32.034
理想情况下，我们希望这些图像和这些标记你的眼睛这个和这

15729
21:33:32.034 --> 21:33:36.694
个标记元数据在我们自己的IPFS节点和其他一些节点上。

15730
21:33:36.775 --> 21:33:44.842
我们看待这个问题的第二种方式是使用Hinata Hinata是一种服务，基本上你只要付钱就能帮你固定NF - T。

15731
21:33:44.842 --> 21:33:48.397
这就是我们要看的。

15732
21:33:48.397 --> 21:33:53.506
现在，binotto的问题当然是，我们只是付钱给一个单一的中心实

15733
21:33:53.506 --> 21:33:58.775
体去锁定我们的数据，我们有点相信他们真的会锁定数据，他们不会下降。

15734
21:33:58.775 --> 21:34:04.724
最后一种获取数据的方法叫做nnf T导存储。

15735
21:34:04.775 --> 21:34:09.007
如果T点存储使用后端文件币网络来固定我们的数据，

15736
21:34:09.007 --> 21:34:15.709
那么filecoin就是一个专门用于固定IPFS数据和存储分散数据的区块链。

15737
21:34:15.709 --> 21:34:18.742
对我们来说，这个过程有点复杂。

15738
21:34:18.742 --> 21:34:21.152
但是非ft点存储让它变得非常非常简单。

15739
21:34:21.152 --> 21:34:25.108
现在，我们不打算在这个视频中使用非函数存储器。

15740
21:34:25.108 --> 21:34:30.935
然而，如果你想了解NFT T点存储，为了把你的数据放在与这门课程相关的GitHub

15741
21:34:30.935 --> 21:34:37.759
repo中，我们有一个脚本，可以将你的代码上传到NFT存储称为utils文件夹，上传到NFT。

15742
21:34:37.759 --> 21:34:38.134
存储。

15743
21:34:38.134 --> 21:34:45.877
如果你想尝试一下，我建议你使用NF T点存储将是保持我们数据最持久的方法之一。

15744
21:34:45.877 --> 21:34:54.398
但将您自己的数据上传到您自己的IPFS节点仍然很好，我们已经学习了如何手动操作，至少让另一个人也固定您的数据。

15745
21:34:54.398 --> 21:35:01.309
理想情况下，一个完整的去中心化网络，将您的数据固定在一起，这就是NFS存储所能帮助您做到的。

15746
21:35:01.309 --> 21:35:06.088
但是现在，对于我们来说，我们只需要用皮纳塔来保持这个视频的美观和简单。

15747
21:35:06.088 --> 21:35:14.534
然后上传上传我们的元数据和代币，你的眼睛到IPFS会给我们这个代币列表你的眼睛给我们的三只狗。

15748
21:35:14.534 --> 21:35:20.167
在上面这里，我们会做一点如果我们会说if process。env。

15749
21:35:20.167 --> 21:35:27.338
upload to pinata = true，对，我们会像这样使用字符串true。

15750
21:35:27.338 --> 21:35:29.650
然后上传到皮纳塔。

15751
21:35:29.776 --> 21:35:33.066
在上面这里我们会说，让我们标记你的眼睛。

15752
21:35:33.776 --> 21:35:38.242
token your eyes = await, handle token your eyes。

15753
21:35:38.242 --> 21:35:43.750
我们会创建一个叫handle token your eyes的函数，它会把

15754
21:35:43.750 --> 21:35:49.407
我们的代码上传到下面的pinata里面，我们会创建一个叫async的新函数。

15755
21:35:49.407 --> 21:35:50.354
函数。

15756
21:35:50.354 --> 21:35:53.061
我们会标记你的眼睛。

15757
21:35:53.061 --> 21:36:00.821
这将返回一个令牌数组你的眼睛让我们上传到智能合约，我们会说token，你的眼睛等

15758
21:36:00.821 --> 21:36:08.582
于这个然后在底部，我们会说return token你的上升，我们会返回这个数组。

15759
21:36:08.582 --> 21:36:14.204
现在我们需要做两件事，我们都需要在IPFS中存储图像。

15760
21:36:14.204 --> 21:36:18.087
然后我们需要将元数据存储在IPFS中。

15761
21:36:18.087 --> 21:36:22.294
首先，我们要创建一个store images函数。

15762
21:36:22.294 --> 21:36:24.577
这就是我们要用到效用的地方。

15763
21:36:24.577 --> 21:36:28.803
我们会在这里创建一个新文件夹，我们会创建一个名为new

15764
21:36:28.803 --> 21:36:37.099
file的文件Upload to pinata。js，我们会把上传到pinata的所有代码都添加到这里。

15765
21:36:37.099 --> 21:36:46.015
因为，pinata是一项服务我们将使用它来为我们固定数据并与pinata一起工作，我们可以继续，免费尝试。

15766
21:36:46.015 --> 21:36:51.210
我们可以创建自

15767
21:36:51.210 --> 21:36:56.406
己的应用程序。

15768
21:36:56.777 --> 21:36:58.088
我们可以开始了。

15769
21:37:00.777 --> 21:37:03.495
IPFS节点，因为这就是皮纳塔的本质。

15770
21:37:03.777 --> 21:37:06.562
只是一个IPFS节点，由别人运行。

15771
21:37:07.777 --> 21:37:10.443
你能帮我们固定这些数据吗。

15772
21:37:11.777 --> 21:37:17.756
我们可以像IPFS节点一样点击上传Cid然后放入一些IPFS文件的散列，

15773
21:37:17.756 --> 21:37:24.234
pinata会为我们固定它，我们也可以像IPFS节点一样上传一个文件或文件夹。

15774
21:37:24.234 --> 21:37:30.838
但对我们来说，我们要把这个空着因为我们要用编程的方式来做，因为我们是工程师。

15775
21:37:30.838 --> 21:37:36.156
我们能做的是打开我们的配置文件，打开API键和文档。

15776
21:37:36.156 --> 21:37:40.341
文档几乎包含了我们开始所需的所有内容。

15777
21:37:40.341 --> 21:37:46.237
如果你向下滚动到pinata Node js SDK，这基本上是我们将要使用的，他

15778
21:37:46.237 --> 21:37:52.134
们已经为我们创建了一个SDK我们可以使用，我们将继续安装这个pinata SDK。

15779
21:37:52.134 --> 21:37:58.453
他们使用NPM，安装破折号来保存，我们将继续使用yarn，在pinata

15780
21:37:58.453 --> 21:38:06.001
dash SDK中添加破折号dev，他们有所有这些不同的端点，我们可以调用pin数据，

15781
21:38:06.001 --> 21:38:13.199
数据，我们将把文件pin到IPFS，因为我们要上传文件，也要把JSON固定到IPFS。

15782
21:38:13.199 --> 21:38:18.019
因为JSON是元数据，而file是实际图像。

15783
21:38:18.019 --> 21:38:21.896
如果你点它，它甚至会给你这里SDK的输出。

15784
21:38:21.896 --> 21:38:26.578
回到代码中，现在我们已经下载了这个，我们可以开始创建这个。

15785
21:38:26.578 --> 21:38:33.511
我们会说const pinata SDK = require at pinata slash

15786
21:38:33.511 --> 21:38:40.444
SDK，然后我们会创建一个async函数store images，它会取一个图像文件路径。

15787
21:38:40.444 --> 21:38:45.527
我们将使用这个函数将我们的图像传递给它，随机的n (t)个文件路

15788
21:38:45.527 --> 21:38:50.611
径，我们会让它把所有东西都存储在那个文件夹里来帮助我们处理路径。

15789
21:38:50.611 --> 21:38:53.896
我们还会安装这个路径包。

15790
21:38:53.896 --> 21:39:00.970
我们要做yarn，添加dash dev path，我们也要用Fs而不是Fs extra。

15791
21:39:00.970 --> 21:39:04.187
现在它已经建立了，我们会说const。

15792
21:39:04.187 --> 21:39:06.236
Path = require Path。

15793
21:39:06.236 --> 21:39:11.505
在这里，我们会说const, full images, path

15794
21:39:11.505 --> 21:39:17.105
= path。resolve, images file path。

15795
21:39:17.105 --> 21:39:20.811
如果我们给出。/ images， /

15796
21:39:20.811 --> 21:39:26.988
random, NF T之类的，这就会给你路径的全部输出。

15797
21:39:26.988 --> 21:39:34.049
我们得到了完整的图像路径，然后我们会说，我们会通过const files = Fs来获取这些文件。

15798
21:39:34.049 --> 21:39:38.133
我们会抓取s我们会说const Fs =

15799
21:39:38.133 --> 21:39:44.261
require Fs来读取这里的文件，读取DirSync。

15800
21:39:44.261 --> 21:39:52.965
我们只需要读取整个目录然后取回文件来读取DirSync完整图像路径。

15801
21:39:52.965 --> 21:39:55.231
为了测试这个是否有效，

15802
21:39:55.231 --> 21:40:03.680
我们要做的是我们要做module。exports， = store images。

15803
21:40:03.779 --> 21:40:10.985
然后回到部署脚本，我们可以注释掉args。

15804
21:40:10.985 --> 21:40:16.583
我们可以输入import const, store images =

15805
21:40:16.583 --> 21:40:22.677
require。。/ utils / upload to pinata。

15806
21:40:22.779 --> 21:40:29.825
在这个脚本中，我们可以做一点，我们可以调用这个我们可以说await，或者images，然

15807
21:40:29.825 --> 21:40:36.871
后我们会传递我们的images location，也许在最上面，甚至在函数的外面，我们会

15808
21:40:36.871 --> 21:40:44.240
说const images location =。/ images / random和ft。

15809
21:40:44.240 --> 21:40:47.624
我们会做一个这样的权重存储图像。

15810
21:40:47.779 --> 21:40:50.712
我们应该能运行硬头部署。

15811
21:40:51.779 --> 21:40:56.579
这个deploy的一些标签，模块，点导出，点标

15812
21:40:56.579 --> 21:41:01.379
签等于，我们说all random IPFS。

15813
21:41:01.379 --> 21:41:08.611
然后主要，我们做Hardhead部署的破折号标签，随机IPFS

15814
21:41:08.611 --> 21:41:15.843
也会做模拟相信，我需要在这里创建一个测试文件夹，新文件夹测试。

15815
21:41:15.843 --> 21:41:20.980
我们需要在这里添加VF协调器v2 Mock。

15816
21:41:20.980 --> 21:41:26.075
我只是复制粘贴VRF协调器v2 Mock从我们的抽奖项目。

15817
21:41:26.075 --> 21:41:31.576
请随意暂停，复制，粘贴，或再次，一切都可以在GitHub上。

15818
21:41:31.576 --> 21:41:33.240
我们再试一次。

15819
21:41:33.240 --> 21:41:40.698
标签，随机IPFS，和模拟，然后，好的，模拟部署和完美的pug。png ship任何png St。

15820
21:41:40.780 --> 21:41:41.565
伯纳德PNG。

15821
21:41:41.565 --> 21:41:41.993
太好了。

15822
21:41:44.780 --> 21:41:45.113
在这里。

15823
21:41:49.780 --> 21:41:50.430
皮纳塔服务器。

15824
21:41:50.430 --> 21:41:52.180
所以我们说响应等于这个。

15825
21:41:52.780 --> 21:41:59.830
比如对于files中的每个文件索引对于这里的每个文件，我们会说const

15826
21:41:59.830 --> 21:42:09.230
readable stream for file = Fs。create read stream

15827
21:42:09.230 --> 21:42:18.435
of the full images path斜杠files of file index。

15828
21:42:18.435 --> 21:42:22.551
这条线是干什么的?我们正在创建一个读流。

15829
21:42:22.551 --> 21:42:27.647
因为这是一个图像文件，它的工作原理和推送数据不完全一样，

15830
21:42:27.647 --> 21:42:32.380
对吧?我们必须创建一个流来传输这些图像中的所有数据。

15831
21:42:32.380 --> 21:42:39.871
因为这些图像，虽然只是一个可爱的小图像，它们其实是一个很大的文件里面有这么多字节和数

15832
21:42:39.871 --> 21:42:47.541
据，然后我们会通过try发送它，我们会说const response = await。

15833
21:42:47.541 --> 21:42:50.652
我们要在这里做皮纳塔。

15834
21:42:50.780 --> 21:42:55.360
如果我们再去皮纳塔码头，这里有一些关于钥匙的东西。

15835
21:42:55.360 --> 21:43:00.844
我们能做的是，如果你去你的个人资料，去API密钥，我们可以创建一个新

15836
21:43:00.844 --> 21:43:06.329
密钥，我们说这是一个管理密钥，为什么不呢?我们给它所有的固定访问权。

15837
21:43:06.329 --> 21:43:09.340
也许我们可以给它这个，也许我们可以给它一切，你想做什么都行。

15838
21:43:09.340 --> 21:43:14.638
然后我们把这个叫做hard hat, Free Code Camp key, create key。

15839
21:43:14.638 --> 21:43:20.076
现在我们要抓取这些并把它们放到。env中。

15840
21:43:20.076 --> 21:43:24.158
API键，复制到这里。

15841
21:43:24.158 --> 21:43:25.797
打开。env。

15842
21:43:25.797 --> 21:43:29.628
我们就叫它皮纳塔吧。

15843
21:43:29.628 --> 21:43:33.543
data API键等于那个键。

15844
21:43:33.781 --> 21:43:40.495
我们会获取API秘密，然后说皮纳塔API秘密等于那个密钥。

15845
21:43:40.495 --> 21:43:43.329
我们不需要这么大的代币。

15846
21:43:43.329 --> 21:43:44.881
但如果你想要，你绝对可以拥有它。

15847
21:43:44.881 --> 21:43:52.804
然后在store image之外，我们会说const pinata API key

15848
21:43:52.804 --> 21:44:00.727
= price意思是，你需要那个pinata API key吗?然后不能皮纳塔。

15849
21:44:00.727 --> 21:44:07.813
API秘密等于工艺点E和V点皮纳塔API秘密。

15850
21:44:07.813 --> 21:44:10.892
然后我们说const。

15851
21:44:10.892 --> 21:44:16.447
Pinata = Pinata s。

15852
21:44:16.447 --> 21:44:22.053
DK的皮纳塔API键逗号，皮纳塔API。

15853
21:44:22.053 --> 21:44:24.228
为了和皮纳塔一起工作，

15854
21:44:24.228 --> 21:44:32.138
我们需要传递一个API密钥和API秘密，这样皮纳塔就知道是我们在和他们一起工作。

15855
21:44:32.138 --> 21:44:37.732
一旦我们初始化了这个pinata，我们就可以运行pinata。

15856
21:44:37.732 --> 21:44:45.492
然后做一些pinata的事情，我们想用这个pin文件到IPFS，它接受这个可读流，这就

15857
21:44:45.492 --> 21:44:52.351
可读流，这就是为什么我们创建了那个可读字符串，所以pinata那个pin文件到IPFS。

15858
21:44:52.351 --> 21:44:55.161
可读流或文件的。

15859
21:44:55.161 --> 21:45:01.126
然后我们把这个响应推到我们的响应数组中。

15860
21:45:01.126 --> 21:45:03.915
因此我们写上responsresponsdot。push response。

15861
21:45:03.915 --> 21:45:08.489
然后我们会捕捉错误，以防这里出现奇怪的错误。

15862
21:45:08.489 --> 21:45:15.104
我们写入console。log error，然后我们会返回响应和文件。

15863
21:45:15.104 --> 21:45:21.848
我们会返回推入这些文件的所有响应，然后是文件。

15864
21:45:21.848 --> 21:45:26.264
现在，在这个点上，我们可以继续，自己测试一下。

15865
21:45:26.264 --> 21:45:27.549
这里有这个。

15866
21:45:27.549 --> 21:45:32.697
如果我们回到deploy，在顶部，我们有这个If process。E和V。

15867
21:45:32.697 --> 21:45:37.985
upload to Niada = true，在这里做这些，上传到IPFS。

15868
21:45:37.985 --> 21:45:44.119
最后我们要做的，当然是require。env。

15869
21:45:44.119 --> 21:45:49.988
config，这样我们就能拉入。env文件。

15870
21:45:49.988 --> 21:45:53.273
下面这里，我们只是做一个权重存储图像。

15871
21:45:53.273 --> 21:45:58.273
如果我们这样运行它，它会继续存储图像。

15872
21:45:58.273 --> 21:46:05.232
让我们运行相同的命令，或者部署随机IPFS和MOX来运行这个store images命令。

15873
21:46:05.232 --> 21:46:11.945
如果我们回到我们的皮纳塔，在我们运行它之后，我们可以看到上传的代码。

15874
21:46:11.945 --> 21:46:16.501
如果我们现在运行，脚本加载IPFS它会给我们一

15875
21:46:16.501 --> 21:46:21.058
点延迟，因为它需要上传这些大图文件到IPFS。

15876
21:46:21.058 --> 21:46:22.610
或者更准确地说。

15877
21:46:22.783 --> 21:46:25.878
皮纳塔，我选上传到nada。

15878
21:46:27.783 --> 21:46:34.340
控制台点日志，工作在文件索引，做Excel。

15879
21:46:35.783 --> 21:46:36.021
太好了。

15880
21:46:36.021 --> 21:46:37.640
看起来它已经跑完了。

15881
21:46:38.783 --> 21:46:47.356
我们的项目，我们做了一点刷新，我们看到我们的三个文件已经上传，我们看到他们每个都有自己的CID。

15882
21:46:47.356 --> 21:46:51.618
现在，如果您愿意，您可以继续复制CID。

15883
21:46:51.783 --> 21:46:58.928
如果你有IPFS节点，你能做的是，我们能做的是从IPFS导入。

15884
21:46:58.928 --> 21:47:00.298
粘贴到这里。

15885
21:47:00.298 --> 21:47:06.572
我们可以确切地说这是什么，IPFS。

15886
21:47:06.572 --> 21:47:08.150
伯纳德叫圣。

15887
21:47:08.150 --> 21:47:08.851
伯纳德。

15888
21:47:08.851 --> 21:47:09.728
重要的。

15889
21:47:09.728 --> 21:47:12.989
现在我们把它固定在我们的IPFS上。

15890
21:47:12.989 --> 21:47:15.765
我把我的放在一个小狗档案里了。

15891
21:47:15.765 --> 21:47:21.110
现在我们已经上传了它们，皮纳塔建议你也把自己的钉在自己的节点上。

15892
21:47:21.110 --> 21:47:21.765
太酷了。

15893
21:47:21.765 --> 21:47:26.090
我们有办法把这些图像上传到IPFS上。

15894
21:47:26.090 --> 21:47:27.325
太棒了。

15895
21:47:27.325 --> 21:47:32.147
现在我们已经完成了这些，我们

15896
21:47:32.147 --> 21:47:36.970
还需要存储令牌URI元数据。

15897
21:47:36.970 --> 21:47:40.583
我们先把它删掉。

15898
21:47:40.583 --> 21:47:45.995
我们能在这里做的，是回到顶部，我们可以说const元

15899
21:47:45.995 --> 21:47:51.408
数据，template =我们会创建一个元数据模板。

15900
21:47:51.408 --> 21:47:56.957
这将包含令牌URI元数据所需的所有基本内容。

15901
21:47:56.957 --> 21:48:04.107
在这里，我们有一个名称，它是空白的，我们有一个描述，它也设置为空白

15902
21:48:04.107 --> 21:48:11.258
会有一个图像它将被替换为我们刚创建的图像URI即IPFS URI。

15903
21:48:11.258 --> 21:48:16.359
如果你想给你的NFT像任何类型的统计，你可以做一

15904
21:48:16.359 --> 21:48:21.461
些你可以像这样创建这个Attributes部分。

15905
21:48:21.461 --> 21:48:27.274
如果你给它traits type, cute，逗号，值100。

15906
21:48:27.274 --> 21:48:33.434
如果你想为你的NF T创建不同的卡或者拥有不同的

15907
21:48:33.434 --> 21:48:39.594
攻击、防御和HP速度，你可以在属性部分添加它们。

15908
21:48:39.594 --> 21:48:46.732
通常，您希望这些属性也存储在链中，这样您的契约可以明显地通过编程与这些属性交互。

15909
21:48:46.784 --> 21:48:49.084
现在我们有了这个元数据模板。

15910
21:48:49.784 --> 21:48:52.184
我们要为每只狗狗填写表格。

15911
21:48:52.784 --> 21:48:59.646
在这里创建一个新函数叫async，用来存储令牌URI元数据。

15912
21:48:59.646 --> 21:49:04.672
我们会把元数据传递给async函数。

15913
21:49:04.672 --> 21:49:08.736
我们会传入从这里的脚本中得到的元数据。

15914
21:49:08.736 --> 21:49:10.497
我们有了这个模板。

15915
21:49:10.497 --> 21:49:16.187
我们会根据在IPFS中存储的数据来填充这个模板。

15916
21:49:16.187 --> 21:49:19.671
现在我们要写剩下的句柄token你的眼睛位。

15917
21:49:19.671 --> 21:49:23.700
我们会在数据和V中这样做，我们会说，upload to

15918
21:49:23.700 --> 21:49:29.521
pinata = true，这样我们就能做所有事情并处理token你的眼睛。

15919
21:49:29.521 --> 21:49:33.214
上传到皮纳塔，这是真的，我们向下滚动，开始创建这个。

15920
21:49:33.214 --> 21:49:40.133
我们要做的第一件事，显然，我们要得到那些响应和那些文件，因为它在响应中，pin

15921
21:49:40.133 --> 21:49:47.585
file to IPFS会返回文件的哈希值，我们需要那个哈希值，来添加到元数据中。

15922
21:49:47.585 --> 21:49:54.875
我们会在下面这里，我们会说const, responses，这将是image upload,

15923
21:49:54.875 --> 21:50:04.385
responses，逗号files，等于await, store images，然后images, location。

15924
21:50:04.385 --> 21:50:11.375
所以这个反应，将是这些来自皮纳塔的反应的列表。

15925
21:50:11.375 --> 21:50:15.768
这些响应会有每个上传文件的哈希值。

15926
21:50:15.768 --> 21:50:19.835
现在我们要遍历这个列表上传每一个元数据。

15927
21:50:19.835 --> 21:50:25.710
对于每个图片上传响应索

15928
21:50:25.710 --> 21:50:31.585
引，在图片上传响应中。

15929
21:50:31.785 --> 21:50:38.531
对于每一个，我们将创建元数据，我们将创建元数据，然后上传元数据。

15930
21:50:38.531 --> 21:50:47.260
我们说，让令牌URI，元数据=。点。元数据模板。

15931
21:50:47.260 --> 21:50:53.385
这是一些有趣的JavaScript，语法糖，意思是，解包。

15932
21:50:53.385 --> 21:50:57.735
基本上，我们说令牌URI元数据将等于这个东西。

15933
21:50:57.785 --> 21:51:05.118
我们把所有这些东西都放到这个token中，你的元数据变量，现在我们说token，你的元数据。

15934
21:51:05.118 --> 21:51:10.372
。name将等于。index的files。

15935
21:51:10.372 --> 21:51:15.626
replace。png。png什么都没有。

15936
21:51:15.626 --> 21:51:20.819
files就是这些文件中的每一个，对吧?可以是St

15937
21:51:20.819 --> 21:51:26.428
Bernard。png，也可以是Shiva。png。

15938
21:51:26.428 --> 21:51:31.933
基本上，我们所做的就是说，好，很好，令牌内部的名称，元数据将是pug。

15939
21:51:31.933 --> 21:51:34.539
所以我们要放弃扩展。

15940
21:51:34.539 --> 21:51:40.236
这就是我们得到name令牌的方式，你的AI元数

15941
21:51:40.236 --> 21:51:46.182
据。description，将等于并崇拜一个碗。

15942
21:51:46.182 --> 21:51:50.992
然后我们会得到名字，令牌URI metadata。name。

15943
21:51:50.992 --> 21:51:53.926
这是一只可爱的哈巴狗和可爱的圣。

15944
21:51:53.926 --> 21:52:01.760
Bernard pop或者一个可爱的船你小狗令牌URI元数据。image，这可能是

15945
21:52:01.760 --> 21:52:09.595
这里最重要的一个，这将是，它将是我们从响应中得到的带有IPFS哈希的IPFS扩展。

15946
21:52:09.595 --> 21:52:14.865
我们可以通过image upload

15947
21:52:14.865 --> 21:52:22.478
response index。iipfs得到这个。

15948
21:52:22.478 --> 21:52:26.570
哈希，我们可以去找皮纳塔的医生。

15949
21:52:26.786 --> 21:52:31.587
我们可以在IPFS哈希中看到pin文件到IPFS的

15950
21:52:31.587 --> 21:52:36.389
返回，pin大小和时间戳，我们只关心IPFS哈希。

15951
21:52:36.389 --> 21:52:41.395
我们将用它来给出我们的元数据图像。

15952
21:52:41.395 --> 21:52:45.458
最后，我再写一个console。log upload。

15953
21:52:45.458 --> 21:52:52.674
然后我们说，token，你的eye metadata。name。。

15954
21:52:52.786 --> 21:52:59.919
现在我们需要存储文件或存储JSON到pinata / IPFS。

15955
21:52:59.919 --> 21:53:05.176
这就是我们上传到皮纳塔的地方，我们要在这里添加这个函数。

15956
21:53:05.176 --> 21:53:06.987
我们有存储令牌URI元数据。

15957
21:53:06.987 --> 21:53:12.895
这里我们要做的是，try const response =

15958
21:53:12.895 --> 21:53:19.007
await, nada，将JSON引脚到元数据的IPFS。

15959
21:53:19.007 --> 21:53:26.238
我们想要将JSON固定到IPFS中，这是非常相似的。

15960
21:53:26.238 --> 21:53:29.913
我们需要传递主体，也就是JSON。

15961
21:53:29.913 --> 21:53:36.377
这里有一些可选的东西，但它会给我们相同的返回值IPFS散列pin，大小和时间戳。

15962
21:53:36.377 --> 21:53:40.303
如果这个可行，我们只需要返回响应。

15963
21:53:40.303 --> 21:53:42.367
否则，我们会执行catch error。

15964
21:53:42.367 --> 21:53:46.344
然后我们用console。log error，

15965
21:53:46.344 --> 21:53:52.916
然后我们用return null然后我们用exports或令牌URI元数据。

15966
21:53:52.916 --> 21:53:59.537
然后回到部署中，我们将继续导入这个存储令牌URI元数据。

15967
21:53:59.537 --> 21:54:01.599
我们向下滚动。

15968
21:54:01.599 --> 21:54:07.384
他们会执行const，元数据，upload response

15969
21:54:07.384 --> 21:54:13.749
= await，存储令牌URI元数据我们传递令牌URI，元数据。

15970
21:54:13.749 --> 21:54:22.251
现在，随着所有这些元数据的上传我们最终会得到我们需要的令牌。

15971
21:54:22.251 --> 21:54:27.637
我们会说，令牌，你的眼睛。push, IPFS，斜

15972
21:54:27.637 --> 21:54:33.240
杠，然后这里是元数据响应，元数据上传响应。IPFS。

15973
21:54:33.240 --> 21:54:33.630
散列。

15974
21:54:33.787 --> 21:54:41.388
我们最终会得到这个指向元数据的IPFS哈希数组，每一个元数据都指向图像。

15975
21:54:41.388 --> 21:54:44.654
然后我们写一个console。log令牌。

15976
21:54:44.788 --> 21:54:53.649
你升起，上传，它们然后我们再做一个console。log标记你的眼睛。

15977
21:54:53.649 --> 21:54:54.941
哦，好吧。

15978
21:54:54.941 --> 21:54:57.615
让我们继续运行这个。

15979
21:54:57.615 --> 21:54:59.408
让我们看看它是否有效。

15980
21:54:59.408 --> 21:55:04.507
在我们的皮纳塔中，我们应该同时看到图像和元数据。

15981
21:55:04.507 --> 21:55:09.755
如果process。E和V。upload to pinata = true，看起来它是真的。

15982
21:55:09.755 --> 21:55:14.311
我们应该运行这个并处理令牌，你的眼睛会上传我

15983
21:55:14.311 --> 21:55:19.076
们的图像和store图像然后上传我们的元数据。

15984
21:55:19.076 --> 21:55:24.692
我们只会在这里看到它一次因为它会有完全相同的Cid对吧，它会有相同

15985
21:55:24.692 --> 21:55:30.480
的哈希值，所以我们不会在pinata或IPFS中得到相同文件的副本。

15986
21:55:30.480 --> 21:55:32.172
我们把它打开。

15987
21:55:32.172 --> 21:55:38.055
让我们再运行一次，或者已经部署了破折号标签，随机IPFS和模拟。

15988
21:55:38.055 --> 21:55:42.699
好的，看起来我们上传到香蕉上的工作几乎是

15989
21:55:42.699 --> 21:55:47.343
零的，一个的，两个的元数据模板没有定义。

15990
21:55:47.343 --> 21:55:55.703
哈，因为我拼写了元数据模板，元数据模板，让我们正确拼写。

15991
21:55:55.788 --> 21:56:01.645
现在让我们再试一次，它在0处工作它在2处工作图像上传响应没有定义。

15992
21:56:01.645 --> 21:56:03.550
我应该拼写正确。

15993
21:56:03.550 --> 21:56:04.566
好了。

15994
21:56:04.566 --> 21:56:07.532
让我们，让我们把帽子写对。

15995
21:56:07.788 --> 21:56:09.862
让我们再试一次。

15996
21:56:11.788 --> 21:56:13.538
上传Shiva在你上传St。

15997
21:56:14.788 --> 21:56:16.493
上传就可以了。

15998
21:56:18.789 --> 21:56:23.047
进入我们的浏览器，或者你的IPFS节点，砰，我们在这里有它们。

15999
21:56:23.047 --> 21:56:28.024
我们能做的就是抓取这个散列，进入IPFS

16000
21:56:28.024 --> 21:56:33.250
桌面，找到文件，从IPFS导入粘贴到这里。

16001
21:56:33.250 --> 21:56:37.574
给它起个名字等等，我们在自己的IPFS节点上也有它。

16002
21:56:37.574 --> 21:56:38.145
太棒了。

16003
21:56:38.145 --> 21:56:44.931
现在我们回到皮纳塔，刷新一下，我们可以看到所有东西都在这里了。

16004
21:56:44.931 --> 21:56:51.723
如果我复制其中一个，然后到IPFS。。斜杠粘贴进去，我们可以看到这里的元数据。

16005
21:56:51.789 --> 21:56:53.428
一切看起来都很好。

16006
21:56:55.789 --> 21:57:03.664
我们这么做是因为现在我们可以将数据存储在我们自己的IPFS节点和至少一

16007
21:57:03.664 --> 21:57:11.539
个其他节点上，所以如果我们的计算机或服务器宕机了，至少还有其他人在做。

16008
21:57:11.789 --> 21:57:17.149
现在我们终于有了这个标记列表，我们终于可以回到我们的论点。

16009
21:57:17.149 --> 21:57:19.903
现在我们可以这样做。

16010
21:57:19.903 --> 21:57:23.740
我们可以把这些标记上传到我们的智能合约里。

16011
21:57:23.789 --> 21:57:26.455
然后我们还需要一笔额外的费用。

16012
21:57:26.789 --> 21:57:32.145
我们到上面的config会在这里创建一个mint fee, mint

16013
21:57:32.145 --> 21:57:38.289
fee是我们想要的任何值12345678123456789，我们会做的是0。

16014
21:57:38.289 --> 21:57:39.164
01容易的。

16015
21:57:39.164 --> 21:57:45.122
我们将把这个放到下面，我们将为我们将为Hard Hat Network做这个。

16016
21:57:45.122 --> 21:57:47.312
我们也会为林基做同样的事。

16017
21:57:47.312 --> 21:57:48.950
我们在这里有争论。

16018
21:57:48.950 --> 21:57:51.466
现在我们终于可以部署我们的契约了。

16019
21:57:51.466 --> 21:57:54.346
我们用const random IPFS。

16020
21:57:54.346 --> 21:57:58.792
如果t等于await，则部署，如果契约是来

16021
21:57:58.792 --> 21:58:03.451
自Deployer的随机IPFS NF t。

16022
21:58:03.451 --> 21:58:05.051
Args就是Args。

16023
21:58:05.051 --> 21:58:06.613
日志是真的。

16024
21:58:06.613 --> 21:58:08.000
然后wait

16025
21:58:08.000 --> 21:58:16.789
confirations将是network。config。block for

16026
21:58:16.789 --> 21:58:24.886
confirm terminations，很好，这里可能还有一行。

16027
21:58:24.886 --> 21:58:26.551
我们来验证一下。

16028
21:58:26.551 --> 21:58:29.273
我要从部署中复制这个。

16029
21:58:29.273 --> 21:58:36.472
我们的基本的，我要复制这个它的代码是完全一样的，除了我们要验证

16030
21:58:36.472 --> 21:58:43.671
随机IPFS而不是实际上我们使用args而不是参数，就是这样。

16031
21:58:43.671 --> 21:58:49.123
所以我们会给它一个快速部署测试，HH部署或yarn Hardhead部署。

16032
21:58:49.123 --> 21:58:52.740
看起来我们就快成功了我们就快搞定了一切都搞定了。

16033
21:58:52.790 --> 21:58:56.531
没有定义网络配置，因为我们没有导入它。

16034
21:58:56.790 --> 21:59:00.341
让我们继续从我们的助手Hardhead导入网络配置。

16035
21:59:00.341 --> 21:59:00.823
配置。

16036
21:59:00.823 --> 21:59:02.547
导入网络配置。

16037
21:59:02.547 --> 21:59:11.123
我们再试一次，当chain ID没有定义时，它是chain ID，那个chain ID再试一次。

16038
21:59:11.123 --> 21:59:14.990
太棒了，它至少对我们的帽子网络有用。

16039
21:59:14.990 --> 21:59:18.066
然后我们可以复制这个数组，粘贴到这里。

16040
21:59:18.066 --> 21:59:18.373
繁荣。

16041
21:59:18.373 --> 21:59:20.713
现在我们有了这个信物你的眼睛。

16042
21:59:20.713 --> 21:59:22.436
现在回到。env。

16043
21:59:22.436 --> 21:59:24.332
现在我们可以将它设为false。

16044
21:59:24.332 --> 21:59:32.445
因为我们已经有了所有的令牌神经元，我们只需要运行大力点击Deploy，我们只需要使用我们已经上传的令牌英雄。

16045
21:59:32.445 --> 21:59:33.893
是的，我们做到了。

16046
21:59:33.893 --> 21:59:40.290
现在我知道你很高兴看到这个像打开看，你很高兴看到这个马上。

16047
21:59:40.290 --> 21:59:46.097
但是让我们把所有这些都部署到溜冰场B上直到最后，因为部署到测试网是非常慢的。

16048
21:59:46.097 --> 21:59:51.483
让我们等到最后一点然后我们继续，我们把它部署到B级。

16049
21:59:51.483 --> 21:59:57.153
但是在编写测试之前，我在编写测试时注意到，我们忘记更新令牌计数器。

16050
21:59:57.153 --> 22:00:04.291
在这里，在我们做之前，我们的保险箱，男人会做s代币计数器加上等于s代币计数器，也就是esto。

16051
22:00:04.291 --> 22:00:07.362
相遇等于es个token counter加1。

16052
22:00:07.362 --> 22:00:10.742
这就是为什么编写测试如此重要的一个完美的例子。

16053
22:00:10.791 --> 22:00:16.052
在编写任何测试之前，您肯定需要为订阅提供资金，这一点我们在这里没有做。

16054
22:00:16.052 --> 22:00:21.289
所以我们需要做一个等待VRF坐

16055
22:00:21.289 --> 22:00:26.877
标Tor V来模拟。基金，订阅。

16056
22:00:26.877 --> 22:00:31.509
订阅ID，逗号表示基金金额，然后

16057
22:00:31.509 --> 22:00:36.141
在上面，我们甚至可以把它拉出来。

16058
22:00:36.141 --> 22:00:37.991
因为这一点都不会改变。

16059
22:00:37.991 --> 22:00:44.924
我们可以让令牌年看起来像const基金金额等于很酷。

16060
22:00:44.924 --> 22:00:47.902
或者你也可以。你也可以做醚。解析。

16061
22:00:47.902 --> 22:00:56.846
但如你所知，在我们部署到冰场横梁之前，我们该怎么办?

16062
22:00:56.846 --> 22:01:05.791
好吧，你是对的，我们绝对应该百分之百地编写一些测试。

16063
22:01:05.791 --> 22:01:11.348
我们创建了一个新文件叫做random IPFS NF t。test。js。

16064
22:01:11.348 --> 22:01:14.593
我们可以在这里写一些测试。

16065
22:01:14.791 --> 22:01:22.592
再说一次，你们在这个测试中不会学到什么新东西，它和我们之前写过的彩票测试非常相似。

16066
22:01:22.592 --> 22:01:27.646
这就是我要说的，我再次强烈建议，你们自己写至少

16067
22:01:27.646 --> 22:01:32.921
两到三个测试，但一定要写一个满足随机单词的测试。

16068
22:01:32.921 --> 22:01:40.945
但是我鼓励你们现在暂停视频，请暂停视频试着自己写一些测试。

16069
22:01:40.945 --> 22:01:49.569
而编写这些测试将真正锻炼你的编程能力，如果你愿意的话，这将给你持续编写这些测试的技能并且非常快速和有效。

16070
22:01:49.569 --> 22:01:51.824
当你构建这些智能合约时。

16071
22:01:51.824 --> 22:01:56.014
这些测试可以防止您编写糟糕的不可变代码。

16072
22:01:56.014 --> 22:01:59.234
请暂停视频，我要从GitHub回购中复制粘贴。

16073
22:01:59.234 --> 22:02:03.713
但是请利用这段时间在这

16074
22:02:03.713 --> 22:02:08.600
里编写一些您自己的测试。

16075
22:02:08.792 --> 22:02:09.695
好了,好了。

16076
22:02:09.695 --> 22:02:12.211
你写测试了吗?希望你看过。

16077
22:02:12.792 --> 22:02:15.022
没有写一些测试，暂停视频，去写一些测试。

16078
22:02:15.022 --> 22:02:22.555
我保证你做这些测试，自己写练习会在这一点上极大地帮助你，我们做了什么，我们做了一些一些令人

16079
22:02:22.555 --> 22:02:27.242
惊奇的东西，我们部署了一个基本的几乎什么都没有的NFT，

16080
22:02:27.242 --> 22:02:37.622
然后我们部署了一个可证明的随机的NFT，随机的统计和随机的特征与不同的罕见，每个NFT取决于它是什么时候铸造的，或谁铸造的。

16081
22:02:37.622 --> 22:02:39.876
我们将数据存储在IPFS中。

16082
22:02:39.876 --> 22:02:47.073
我们还学会了如何通过编程将文件上传到pinata，这是另一种固定服务。

16083
22:02:47.073 --> 22:02:52.252
我们学习了一些关于非金融债务存储的知识，这是将数据固定到IPFS的另一种方法。

16084
22:02:52.252 --> 22:02:59.809
当然，我们知道如果我们想，我们可以通过编程将数据固定到我们自己节点上的IPFS。

16085
22:02:59.809 --> 22:03:03.268
但因为我们中的很多人不会每天24小时都在运行自己的电脑。

16086
22:03:03.268 --> 22:03:07.293
我们继续说，好吧，我们将坚持使用皮纳塔作为默认值。

16087
22:03:07.293 --> 22:03:13.694
现在我们完成了所有这些，砰，这里又有一个小的勾号。

16088
22:03:13.793 --> 22:03:22.465
现在我要说的是，我们不需要将数据存储在IPFS上如果我们愿意，我们可以直接将数据和元数据存储在链上。

16089
22:03:22.465 --> 22:03:27.529
然而，在IPFS上托管的IT优点和缺点各有不同，或者说它将会很便宜。

16090
22:03:27.529 --> 22:03:36.131
缺点是需要有人来固定我们的数据，对吧?至少有一个人需要固定她的数据，对吧?它是去中心化的，

16091
22:03:36.131 --> 22:03:44.543
但你至少需要有人来固定你的数据，对吧?使用文件币之类的东西是一种激励人们钉住数据的方式。

16092
22:03:44.543 --> 22:03:51.938
但如果你不使用文件币，就不能保证在数据A在链上的情况下在链上执行SVG的优点。

16093
22:03:51.938 --> 22:03:56.093
而且你永远不用担心有人会把数据钉在里面。

16094
22:03:56.093 --> 22:04:00.348
缺点是这种方法要昂贵得多。

16095
22:04:00.348 --> 22:04:07.285
这些小图像，实际上非常大存储在链上会非常昂贵。

16096
22:04:07.285 --> 22:04:12.507
所以我们要用一些不同的图片，小得多的图片，便宜得多的图片。

16097
22:04:12.507 --> 22:04:19.993
如果你想看这个的另一个版本，我有另一个视频，如何用链元数据制作非ft艺术，它包含了我们将

16098
22:04:19.993 --> 22:04:27.480
要在这里讨论的内容如果你想要第二个参考，在与这门课程相关的GitHub回购中有一个链接。

16099
22:04:27.480 --> 22:04:32.190
所以我们不使用这些p

16100
22:04:32.190 --> 22:04:37.371
ng，而是使用SVG。

16101
22:04:37.371 --> 22:04:41.437
现在，SVG代表可缩放向量图形。

16102
22:04:41.437 --> 22:04:47.810
这些都是非常简单的文件我们可以把它们上传到区块链。

16103
22:04:47.810 --> 22:04:52.370
这就是我们要用它们的原因因为它们更简洁，上传也更便宜。

16104
22:04:52.370 --> 22:04:56.380
因为记住，上传到区块链的数据越多，开销就越高。

16105
22:04:56.380 --> 22:04:59.714
在这个视频中，我在链上随机化SVG数据。

16106
22:04:59.714 --> 22:05:01.919
这里有一个例子，它是什么样的。

16107
22:05:01.919 --> 22:05:03.682
只是一堆随机的行。

16108
22:05:03.682 --> 22:05:07.132
不是超级刺激，但随机和有点酷。

16109
22:05:07.132 --> 22:05:08.148
这是100%。

16110
22:05:08.148 --> 22:05:10.758
在链上，这些SVG实际上可以在HTML中正常工作。

16111
22:05:10.758 --> 22:05:15.401
如果你想在你的网站上使用这些，你也可以在GitHub上

16112
22:05:15.401 --> 22:05:20.217
找到与这门课相关的教程链接，在那里我们可以自己尝试一下。

16113
22:05:20.217 --> 22:05:27.455
我们可以制作一个SVG，他们通过学校在这个网站上有各种不同的命令。

16114
22:05:27.455 --> 22:05:34.796
com/graphics/svg引入。ASP，你可以看到一些不同的命令，对吧，你可以做

16115
22:05:34.796 --> 22:05:42.138
一个矩形你可以做一个圆路径是一个很大的路径，你可以确切地说你想画的路径或线是什么样的。

16116
22:05:42.138 --> 22:05:44.955
在SVG中可以制作很多东西。

16117
22:05:44.955 --> 22:05:50.615
最酷的是，无论你制作的SVG有多大，其质量总是完全相同的，因

16118
22:05:50.615 --> 22:05:56.465
为SVG只是精确地解释了如何绘制图像，无论图像有多大或有多小。

16119
22:05:56.465 --> 22:06:02.336
如果你想了解更多关于SVG的知识想玩SVG，你可以来这里自己尝试一下。

16120
22:06:02.336 --> 22:06:04.760
也就是说，这就是我们要在链上储存的东西。

16121
22:06:04.794 --> 22:06:07.743
这就是我们如何在链上存储SVG的东西。

16122
22:06:07.794 --> 22:06:14.919
但我们要更进一步，我们要让这个动态，我们要让这个根据链上的一些数据改变。

16123
22:06:14.919 --> 22:06:20.020
如果你去到与这节课相关的GitHub回购，你去到图像，你去到动态非

16124
22:06:20.020 --> 22:06:25.122
函数函数，你会看到两个图像，看到happy。SVG，看起来像这样。

16125
22:06:25.122 --> 22:06:29.384
你会看到皱眉。SVG，它看起来像这样。

16126
22:06:29.384 --> 22:06:34.268
我们将使这个非ft动态也就是说，如果每个价

16127
22:06:34.268 --> 22:06:39.152
格高于某个数字，那么我们将让它是一张笑脸。

16128
22:06:39.152 --> 22:06:43.604
如果它低于这个值，我们会把它变成一张皱眉的脸。

16129
22:06:43.604 --> 22:06:47.545
所以我们的非ft会根据一些真实世界的参数而改变。

16130
22:06:47.545 --> 22:06:54.485
这显然是非常强大和酷的，因为我们可以有一个基于统计的变化的非函数函数，我们可以有一

16131
22:06:54.485 --> 22:07:01.595
个基于任何变化的非函数函数t，我们要将所有的数据百分之百地存储在链上，这将会有点贵。

16132
22:07:01.595 --> 22:07:08.564
这就是我们要做的。

16133
22:07:08.795 --> 22:07:10.553
让我们开始吧，开始吧。

16134
22:07:11.795 --> 22:07:13.777
我们最终的非ft部分的合同。

16135
22:07:14.795 --> 22:07:22.128
在这里创建一个新契约，新契约，这将是我们的动态SVG和ftdot灵魂。

16136
22:07:22.128 --> 22:07:27.144
这看起来和我们刚才做的很像。

16137
22:07:27.144 --> 22:07:28.413
动态的。

16138
22:07:28.413 --> 22:07:33.577
SVG和ft点锯，斜杠lat spdx，

16139
22:07:33.577 --> 22:07:38.742
许可证标识符，和我的团队的pragma。

16140
22:07:38.742 --> 22:07:43.320
固体，Eric 0，点8。

16141
22:07:43.320 --> 22:07:43.477
7.

16142
22:07:43.477 --> 22:07:47.638
契约，动态SVG, NF t。

16143
22:07:47.638 --> 22:07:53.695
现在我们来谈谈它的架构是什么样的。

16144
22:07:53.695 --> 22:07:56.937
它看起来很像正常的NF - T，有几点需要注意。

16145
22:07:56.937 --> 22:08:04.436
我们会给它一个min函数来mint，这些NF T也会把我们的SVG信息存储在某个地方。

16146
22:08:04.436 --> 22:08:08.747
然后我们需要一些逻辑

16147
22:08:08.747 --> 22:08:13.490
来显示x图像或y图像。

16148
22:08:13.490 --> 22:08:19.151
正如我们所知，那只会切换令牌URI说show X或show y。

16149
22:08:19.151 --> 22:08:22.054
我们来看看怎么做。

16150
22:08:22.054 --> 22:08:24.957
首先，我们知道这是在ERC中。

16151
22:08:24.957 --> 22:08:25.215
721.

16152
22:08:25.215 --> 22:08:27.445
我们可以从齐柏林飞船上导入它。

16153
22:08:27.445 --> 22:08:35.517
我们会说import at open Zeppelin /合约/令牌/ ERC。

16154
22:08:35.517 --> 22:08:37.123
721斜杠ERC。

16155
22:08:37.123 --> 22:08:38.844
就这些。

16156
22:08:38.844 --> 22:08:47.524
现在我们不会调用之前调用的那个集令牌URI函数所以我们可以使用原始的ERC 721而不是扩展。

16157
22:08:47.524 --> 22:08:53.577
所以我们会说我们的合同是ERC 721现在我们把它变成ERC 721。

16158
22:08:53.577 --> 22:08:59.446
我们可以像这样构造宿舍，然后调用ERC的构造函数。

16159
22:08:59.446 --> 22:09:05.713
721，我们称之为动态SVG，还有ftdsn，

16160
22:09:05.713 --> 22:09:14.161
动态SVG和s t f t，像这样然后我们还需要一个薄荷函数。

16161
22:09:14.161 --> 22:09:19.374
我们现在就来创建它比如function mint和ft或者request NFT。

16162
22:09:19.374 --> 22:09:24.934
这里我们会稍微宽松一点，我们会说用户不需要为此支付任何钱。

16163
22:09:24.934 --> 22:09:26.629
所以这只是一个公共活动。

16164
22:09:26.629 --> 22:09:28.240
我们要把它们和NFT都造出来。

16165
22:09:28.240 --> 22:09:32.462
同样的，我们会调用Safe mint message。sender。

16166
22:09:32.462 --> 22:09:35.462
当然，我们需要令牌计数项。

16167
22:09:35.462 --> 22:09:40.232
让我们继续，在我们的顶部，在256，私有s，

16168
22:09:40.232 --> 22:09:45.003
下划线，令牌计数器，我们在这里写令牌计数器。

16169
22:09:45.003 --> 22:09:50.135
然后在我们的意思是我们会做标签计数器加，这里会是= token计数器加1。

16170
22:09:50.135 --> 22:09:55.745
差不多就是这样了，我们有一种方法意味着我们已经做了一些基本的。

16171
22:09:55.797 --> 22:10:00.130
我们甚至会显式地说s token counter = 0来初始化它。

16172
22:10:00.130 --> 22:10:04.504
现在这个代币会是什么样子呢?我们想让他们看起来像svg。

16173
22:10:04.504 --> 22:10:12.693
我们希望它基于构造函数中某些资产的价格，创建一个字符串内存。

16174
22:10:12.693 --> 22:10:19.051
我们称其为低SVG字符串内存为高SVG。

16175
22:10:19.051 --> 22:10:23.670
在我们的代码中，我们会把这个低

16176
22:10:23.670 --> 22:10:28.597
的SVG保存到这个最高的vg中。

16177
22:10:28.597 --> 22:10:35.181
这些是图像，这些是皱眉的脸和微笑的脸它们会作为输入参数导入。

16178
22:10:35.181 --> 22:10:39.659
正如我们所知，我们可以让它们成为不可变的因为它们可能不会改变。

16179
22:10:39.659 --> 22:10:46.712
我们可以说String, private，下划线，low image URI。

16180
22:10:46.712 --> 22:10:51.441
在string private中，我强调了high image URI。

16181
22:10:51.441 --> 22:10:58.504
但如果我们只传递SVG数据，SVG数据看起来就像。在这个GitHub中，我可以

16182
22:10:58.504 --> 22:11:05.567
在这里显示源blob我可以确切地看到代码是什么样的这段代码肯定不是图像URI。

16183
22:11:05.567 --> 22:11:09.076
我们需要的是像这样的图像URI，对吧?现在，

16184
22:11:09.076 --> 22:11:16.734
我们传递它的方式是通过SVG代码，对吧?因为我们只想向它传递SVG代码，然后让契约处理其他一切。

16185
22:11:16.797 --> 22:11:21.438
那么我们要怎么做呢?我们能做的是创

16186
22:11:21.438 --> 22:11:26.353
建一个名为SVG的函数来图像URI。

16187
22:11:26.353 --> 22:11:31.170
在链上，我们可以把svg转化成svg。

16188
22:11:31.170 --> 22:11:32.441
使形象出现。

16189
22:11:32.441 --> 22:11:38.794
我们不再使用IPFS，而是使用64进制编码，

16190
22:11:38.794 --> 22:11:45.147
你可以将任何SVG编码为64进制图像URL。

16191
22:11:45.147 --> 22:11:46.178
这是正确的。

16192
22:11:46.178 --> 22:11:49.012
它看起来就像这个底。

16193
22:11:49.012 --> 22:11:53.572
64是将表示二进制数据的二进制编码方案分组为文本编码方案。

16194
22:11:53.572 --> 22:11:55.910
或者在我们的例子中，是SVG数据。

16195
22:11:55.910 --> 22:11:56.313
基地。

16196
22:11:56.313 --> 22:12:04.206
64在万维网上特别流行，它的用途之一是在文本资产中嵌入图像文件或其他二进制资

16197
22:12:04.206 --> 22:12:08.152
产，如HTML和CSS，我们能做的是，

16198
22:12:08.152 --> 22:12:20.410
将所有这些SVG转换为URL或图像URI，这很好，对吧?这正是我们想要的，我们想要能够将这个转换为URL或图像URI。

16199
22:12:20.410 --> 22:12:26.181
如果你取其中一幅图像，或者这些SVG图像，比如happy to have

16200
22:12:26.181 --> 22:12:33.076
SVG，在这个happy。SVG中我们能做的是复制图像地址，也就是这个地址的URL。

16201
22:12:33.076 --> 22:12:36.221
如果我们把它粘贴回来，我们会在这里看到司法文件。

16202
22:12:36.221 --> 22:12:41.943
在这个网站中，我们可以做数据类型，远程URL，粘贴到这里。

16203
22:12:41.943 --> 22:12:44.909
我们可以说将SVG编码为64进制。

16204
22:12:44.909 --> 22:12:51.099
在下面这里，我们会得到这个奇怪的工作角色，数字，字母之类的。

16205
22:12:51.099 --> 22:12:57.961
这个64进制编码表示我们刚得到的SVG我们可以在浏览器

16206
22:12:57.961 --> 22:13:05.077
中做什么，我们可以输入data，冒号，图像，斜杠SVG，

16207
22:13:05.077 --> 22:13:12.195
加上XML，分号，进位64，逗号，然后粘贴到这里，回车。

16208
22:13:12.195 --> 22:13:16.957
你不知道吗，我们就能还原出那个画面。

16209
22:13:16.957 --> 22:13:22.275
这个巨大的东西就是这个图像的64进制编码。

16210
22:13:22.275 --> 22:13:28.153
有了这个基本的c4编码的图像，我们可以使用这个链作为你到达的图像。

16211
22:13:28.153 --> 22:13:29.656
然后是元数据。

16212
22:13:29.656 --> 22:13:32.256
我们将把它直接烘焙到令牌URI中。

16213
22:13:32.256 --> 22:13:34.035
你马上就会明白我的意思。

16214
22:13:34.035 --> 22:13:39.549
因此，我们有了一种方法，可以直接将SVG代码放入智能合约中。

16215
22:13:39.549 --> 22:13:40.549
我们来看看怎么做。

16216
22:13:40.549 --> 22:13:47.179
我们有函数，SVG to image URI，我们知道我们可能会在chain上做同样的64进制编码。

16217
22:13:47.179 --> 22:13:55.681
如果你想省点油，我们会百分之百地在链上做这个但是展示如何在链上做这个很有趣，所以我们将它设为一个公共纯函数。

16218
22:13:55.681 --> 22:13:59.452
我们会让它返回一个字符串内存。

16219
22:13:59.452 --> 22:14:06.322
我们将给这个函数一个SVG，它将从构造函数传入。

16220
22:14:06.322 --> 22:14:08.934
我们会返回一个字符串，

16221
22:14:08.934 --> 22:14:20.094
也就是我们刚才看到的64进制编码的URL，而在上面我们会做string, private常量，

16222
22:14:20.094 --> 22:14:27.218
string, private常量，以S为基数的feed，以64为基数的编码SVG前缀等于这个。

16223
22:14:27.218 --> 22:14:33.024
我们会用这个来生成我们的SVG，我们可以这么做。

16224
22:14:33.024 --> 22:14:38.379
然后我们会做字符串内存SVG，我们会为我们自己编

16225
22:14:38.379 --> 22:14:43.735
码这个SVG通过在chain上添加64进制编码。

16226
22:14:43.800 --> 22:14:47.733
现在，我们不想自己重写它。

16227
22:14:47.800 --> 22:14:49.406
幸运的是，已经有人这么做了。

16228
22:14:49.800 --> 22:14:56.918
查看与此相关的GitHub回购，这是由一个LoopRing开发人员创建的非常棒的项目，如果你也想看看的话。

16229
22:14:56.918 --> 22:15:00.111
我们将为我们的SVG链借用这段代码。

16230
22:15:00.111 --> 22:15:06.112
我们能做的是在这里添加这个，添加他们的GitHub代码，这里有我们需

16231
22:15:06.112 --> 22:15:11.583
要的所有编码和解码基础的东西，我们可以做yarn，添加dash

16232
22:15:11.583 --> 22:15:18.292
Dev, base 64 dash soul，这将添加他们的代码作为依赖。

16233
22:15:18.292 --> 22:15:23.013
一旦我们添加了它，我们就可以导入导入，

16234
22:15:23.013 --> 22:15:28.729
以64为底，破折号，斜杠，以64为底。Sol。

16235
22:15:28.729 --> 22:15:33.206
这份合同附带一个编码器。

16236
22:15:33.206 --> 22:15:41.956
然后我们可以做string memory, SVG base64 encoded，等于base64。ENCODE。

16237
22:15:41.956 --> 22:15:45.747
这里就有点奇怪了。

16238
22:15:45.800 --> 22:15:54.035
我们会使用bytes string, abi。ENCODE, act, SVG，然后我们会

16239
22:15:54.035 --> 22:16:02.087
返回string API。ENCODE packed, base 64, encoded

16240
22:16:02.087 --> 22:16:09.956
SVG prefix, comma SVG base 64 encoded，这个函数，

16241
22:16:09.956 --> 22:16:19.107
这个SVG to image URI会接收任何SVG，然后返回一个URL或URI，看起来就像这样。

16242
22:16:19.107 --> 22:16:21.729
现在，我在这里快速浏览了一些内容。

16243
22:16:21.729 --> 22:16:27.754
还有很多新的东西，比如ABI。encode pack我们做了两次，

16244
22:16:27.754 --> 22:16:33.597
这个ABI。encode pack是干什么的?让我们来了解一下。

16245
22:16:33.597 --> 22:16:41.001
从一个非常非常高的层面来说，这基本上就是连接字符串的方式。

16246
22:16:41.001 --> 22:16:43.710
这就是把字符串组合在一起的方法。

16247
22:16:43.710 --> 22:16:51.978
我们会跳过remix来探索这个ABI点编码契约和这个ABI编码的东西。

16248
22:16:51.978 --> 22:16:56.456
我们接下来要讲的部分绝对是高级的。

16249
22:16:56.456 --> 22:17:05.227
我们将会讨论一些非常低层次的东西，固体在幕后是如何工作的，二进制是如何工作的，还有这个叫做操作码的东西。

16250
22:17:05.227 --> 22:17:08.733
所有这些疯狂的，低级的，棘手的，难以理解的事情。

16251
22:17:08.733 --> 22:17:13.733
如果你想跳过这一节，在GitHub回购中有时间戳。

16252
22:17:13.801 --> 22:17:15.145
帮你度过难关。

16253
22:17:16.801 --> 22:17:22.448
如果你第一次听不懂，至少试着吸收大部分内容。

16254
22:17:22.448 --> 22:17:23.565
这是100%。

16255
22:17:23.565 --> 22:17:25.325
好的，这个更高级。

16256
22:17:25.325 --> 22:17:30.637
无论如何，对于大多数基本项目，您并不真正需要这些信息。

16257
22:17:30.637 --> 22:17:37.377
只有当你变得更高级的时候，知道所有这些才会让你成为一名出色的可靠性开发人员。

16258
22:17:37.377 --> 22:17:44.572
当你开始学习这一节的时候，当你开始学习EVM，操作码，编码和调用这一节的时候，

16259
22:17:44.572 --> 22:17:51.768
你要知道如果你第一次不能百分百理解也没关系，如果你想多看几次这一节那就太棒了。

16260
22:17:51.768 --> 22:17:55.229
所以如果你想跳过去混音和跟随，让我们做。

16261
22:17:55.229 --> 22:17:59.995
在合约部分，我们创建一个新文件，命名为encoding。soul。

16262
22:17:59.995 --> 22:18:06.602
记住，我们在这里用到的所有代码都会在Hardhead NFT的子课程文件夹中。

16263
22:18:06.602 --> 22:18:06.868
FCC。

16264
22:18:06.868 --> 22:18:11.598
我们要处理的所有代码都在这个encoding。soul中。

16265
22:18:11.598 --> 22:18:18.005
再过一会儿，我们会把这个叫做灵魂的东西我们在这个encoding。soul中。

16266
22:18:18.005 --> 22:18:20.038
我们先写一下基本代码。

16267
22:18:20.038 --> 22:18:25.508
我们会说spdx许可标识符MIT

16268
22:18:25.508 --> 22:18:33.373
pragma solidity胡萝卜0点8。

16269
22:18:33.373 --> 22:18:40.737
7、像那样，做缩约编码，boom，编译，或者Command S或ctrl S伟大的东西都看起来不错。

16270
22:18:40.802 --> 22:18:49.119
记住，这里的目的是首先理解这里发生了什么，以及更多关于这个API。encode pack的东西。

16271
22:18:49.119 --> 22:18:53.944
让我们先写一个函数它应该把API。encode包装

16272
22:18:53.944 --> 22:18:58.769
成一些字符串把它包装成一个字符串会返回一个字符串。

16273
22:18:58.769 --> 22:19:03.837
我们可以做函数，绑定字符串，或者连接字符串。

16274
22:19:03.837 --> 22:19:12.140
这将是一个公共纯函数因为我们不会读取任何存储，我们会说返回字符串内存。

16275
22:19:12.140 --> 22:19:17.656
我们会说，返回string, API。encode packing。

16276
22:19:17.656 --> 22:19:22.602
我是我是逗号，空格在这里，我想你，就像这样。

16277
22:19:22.602 --> 22:19:24.802
这里还需要一个括号。

16278
22:19:24.802 --> 22:19:25.602
好了,好了。

16279
22:19:25.802 --> 22:19:32.016
现在我们来部署这个，我们会启动一个JavaScript VM来部署编码。

16280
22:19:32.016 --> 22:19:32.230
所以。

16281
22:19:32.230 --> 22:19:37.755
到下面这里，点击合并字符串，我们得到整个字符串输出。

16282
22:19:37.802 --> 22:19:38.864
嗨，妈妈，想你。

16283
22:19:41.803 --> 22:19:47.673
因为API。encode wrapped返回一个bytes对象，我

16284
22:19:47.673 --> 22:19:53.544
们通过将它包装在这个字符串中，将它转换为字符串来对它进行类型转换。

16285
22:19:53.544 --> 22:19:57.615
固体性说，好的，字节到字符串，没问题，这完全可行。

16286
22:19:57.615 --> 22:20:02.464
这个API点编码是这些全局可用的方法和单元。

16287
22:20:02.464 --> 22:20:07.247
实际上，在固体性中，有很多这样的，有这个固体性小抄，

16288
22:20:07.247 --> 22:20:14.975
在GitHub的repo中也会有链接，它有一大堆的操作符它有一大堆的全局变量和方法。

16289
22:20:14.975 --> 22:20:19.032
你可以看到，如果我们看这里，我们寻找ABI。encode pact，

16290
22:20:19.032 --> 22:20:24.403
我们看到ABI。encode pact在这里，我们向下滚动，我们会看到更多我们熟悉的东西。

16291
22:20:24.403 --> 22:20:29.727
例如，message。sender, message的sender, message。value。

16292
22:20:29.803 --> 22:20:36.409
还有很多其他全局可用的方法和变量我们在编写代码时可以使用。

16293
22:20:36.409 --> 22:20:38.469
现在，我要说，在0。

16294
22:20:38.469 --> 22:20:44.770
8点，加上，你实际上可以用string。concat，你知道，字符串a，字符串B，

16295
22:20:44.770 --> 22:20:50.917
如果你想，而不是用这个API。encode pack，但我还是想给你们看API。

16296
22:20:50.917 --> 22:20:57.065
encode pack，因为这是一个很好的过渡到我们将要讲到的所有ABI的东西。

16297
22:20:57.065 --> 22:20:59.950
但让我们关注这个编码打包的东西。

16298
22:20:59.950 --> 22:21:05.820
那么到底发生了什么呢?在深入研究这个编码约定之

16299
22:21:05.820 --> 22:21:11.691
前，让我们稍微了解一下在发送事务时发生了什么。

16300
22:21:11.691 --> 22:21:16.381
当我们编译代码时，所有这些图片都会在GitHub回购中。

16301
22:21:16.381 --> 22:21:17.644
回想一下醚。

16302
22:21:17.644 --> 22:21:23.717
js，我们有两个文件，一个是。ABI文件，一个是。bin或。binary。

16303
22:21:23.804 --> 22:21:27.234
回到我们的以太符号存储，当我们运行纱线，编译。

16304
22:21:27.234 --> 22:21:36.183
我们得到的两个主要文件，一个是符号存储abi，也就是这个，我们已经很熟悉的abi。

16305
22:21:36.183 --> 22:21:42.704
然后是简单的storage。bin，它是二进制，里面有一堆数字，字母和我们不懂的东西。

16306
22:21:42.704 --> 22:21:49.209
你可以在remix中看到，如果我们要编译这个，你会得到编译细节，你会在这

16307
22:21:49.209 --> 22:21:55.714
里得到一大堆东西，对吧?你可以在这里看到ABI，这是一种观察API的不同

16308
22:21:55.714 --> 22:22:02.581
方式，我们还得到这个字节码位它是这个对象有相同的东西有那些随机的数字和字母。

16309
22:22:02.581 --> 22:22:06.459
但这实际上是二进制这实际上是放在区块链上的。

16310
22:22:06.459 --> 22:22:09.344
这是二元的，这是低级的东西。

16311
22:22:09.344 --> 22:22:15.753
现在，当我们把这些合约发送到区块链时，我们发送的是像我说的，我们发送的是二进制的东西。

16312
22:22:15.804 --> 22:22:17.625
这就是我们要发给区块链的东西。

16313
22:22:17.804 --> 22:22:25.981
还记得吗，在我们的ethers项目中，我们看到了什么是交易，对吧，交易有nonce，

16314
22:22:25.981 --> 22:22:33.769
它有天然气价格猜测限制值数据，我们略过了VRS，因为这是交易签名的数学组成部分。

16315
22:22:33.769 --> 22:22:42.677
但在我们的ethos项目中，我们也这样做了，就在我们的deploy脚本中，我们自己发送了一个事务，只使用醚。

16316
22:22:42.677 --> 22:22:47.187
我们通过了一个nonce，一个天然气价格，天然气限制

16317
22:22:47.187 --> 22:22:51.698
到价值数据是这个庞大的东西来声明合同，然后是链ID。

16318
22:22:51.698 --> 22:22:55.130
我们没有与VAR合作，因为ethers为我们做了这些。

16319
22:22:55.130 --> 22:22:58.961
但还有一个VAR的分量我们不去看。

16320
22:22:58.961 --> 22:23:05.412
当我们发送一个真正创建契约的事务时，2将是空的。

16321
22:23:05.412 --> 22:23:08.499
我们不会把这个合同部署发送到任何地址。

16322
22:23:08.499 --> 22:23:15.721
但是这个数据会有合约初始化代码和合约字节码。

16323
22:23:15.805 --> 22:23:16.043
正确的。

16324
22:23:18.805 --> 22:23:22.313
初始化契约，然后看看契约的实际样子。

16325
22:23:22.313 --> 22:23:28.226
所以如果你看你部署的任何合同，例如，我要看我们部署的抽奖。

16326
22:23:28.226 --> 22:23:35.497
如果你去看合同的交易，我们可以看到创造抽奖，好吧，让我们去看那个交易。

16327
22:23:35.497 --> 22:23:40.805
如果我们向下点击看更多以太扫描，我们可以看到这个输入数据。

16328
22:23:40.805 --> 22:23:45.055
再一次，它有所有这些随机的乱码数字和字母。

16329
22:23:45.055 --> 22:23:51.471
这是合约初始化代码和合约字节码的二进制数据我们在这

16330
22:23:51.471 --> 22:23:57.888
个动作中发送的是这个数据，我们发送这个奇怪的乱码。

16331
22:23:57.888 --> 22:23:59.648
现在我们要回去混音了。

16332
22:23:59.648 --> 22:24:03.756
我将把这个作为注释留在这里在encoding。soul和GitHub repo中。

16333
22:24:03.805 --> 22:24:07.305
这里有大量的评论解释了我所解释的内容。

16334
22:24:07.305 --> 22:24:09.998
所以如果你想在那里跟随，你也可以。

16335
22:24:09.998 --> 22:24:18.518
现在为了让区块链理解，这些数字和字母到底是什么意思?你需要一个特殊的读取器铈或者区块

16336
22:24:18.518 --> 22:24:27.242
链需要能够读取所有这些东西，它需要能够将所有这些随机的数字和字母映射到它们实际的功能。

16337
22:24:27.242 --> 22:24:31.906
Aetherium, polygon或avalanche是如何知道所有

16338
22:24:31.906 --> 22:24:36.705
这些无意义的内容都是在告诉它去签订契约，你可以将其理解为，脱下你的外套。

16339
22:24:36.705 --> 22:24:45.186
作为人类，我们理解脱掉外套的唯一原因是我们理解英语。我们都在阅读英语，为了坚固。

16340
22:24:45.186 --> 22:24:46.138
对于区块链来说也是如此。

16341
22:24:46.138 --> 22:24:55.113
我读的不是英语，而是这些数字和字母，就像读单词一样，而不是脱下你的外套，这就像部署合同，合同做的是下一步的XYZ和所有这些随机的东西。

16342
22:24:55.113 --> 22:24:59.509
这个字节码代表了使契约发生的底层计算机指令。

16343
22:24:59.509 --> 22:25:05.494
所有这些数字和字母都代表了一个字母表，就像脱下你的外套是一个字母表一样。

16344
22:25:05.494 --> 22:25:13.117
当你像这样把它们组合在一起时，对我们来说这是有意义的，你可以把这些字母想象成所谓的操作码。

16345
22:25:13.117 --> 22:25:21.539
如果你去创建一个新标签，如果你去EVM。codes，我们会看到这个地方它有一个所有这些指令的列表。

16346
22:25:21.539 --> 22:25:25.150
在左边，你可以看到这个叫做操作码的东西。

16347
22:25:25.150 --> 22:25:33.221
然后你可以看到名字,这操作码段是说,嘿,如果你看到一个00在这个

16348
22:25:33.221 --> 22:25:41.292
字节码,00代表这个操作码停止,这是暂停执行,如果你看到一个01

16349
22:25:41.292 --> 22:25:49.363
你会做一些另外的东西,02年繁殖,这些op像字母代码,或二进制的

16350
22:25:49.363 --> 22:25:58.193
语言材料,对,他们一路f f自我摧毁,这些op代码也有,这是什么阅读。

16351
22:25:58.193 --> 22:26:02.271
对吧?如果我们看一下我们的交易，你的和你的可能有一点不同。

16352
22:26:02.271 --> 22:26:06.627
哦，6,1说，好的，我们想让你做的第一件事是O 6，一个操作码。

16353
22:26:06.627 --> 22:26:13.733
如果我们去EVM，操作码，我们找6 1，它说的是push to place，在栈上购买商品。

16354
22:26:13.733 --> 22:26:18.729
这正是它读取这个的方式任何语言都可以编译到这个操作码的

16355
22:26:18.729 --> 22:26:23.726
东西到这个特定的Aetherium操作码集，或EVM。

16356
22:26:23.807 --> 22:26:28.169
操作码，即以太坊虚拟机EVM。

16357
22:26:28.169 --> 22:26:36.162
因此，能够读取这些操作代码有时被抽象地称为EVM，即以太虚拟机，EVM基本上代表了所有的指令，

16358
22:26:36.162 --> 22:26:44.156
计算机必须能够读取指令才能与Aetherium或Aetherium进行交互，就像应用程序一样。

16359
22:26:44.156 --> 22:26:53.008
这就是为什么这么多区块链都是用固体来工作的，因为固体编译到这个字节码，还有多边形，雪

16360
22:26:53.008 --> 22:27:02.072
崩套利Aetherium，它们都编译到完全相同类型的二进制，它们都有完全相同的读取器。

16361
22:27:02.072 --> 22:27:07.106
为什么我们要告诉你这些东西，你可能会说，嘿，Patrick，这很酷但它看起来像ABI。

16362
22:27:07.106 --> 22:27:12.726
encode pack，它所做的只是连接字符串，ABI encode pack实际上能做的更多。

16363
22:27:12.807 --> 22:27:19.152
如果我们看一下这些全局变量，API。encode pack就

16364
22:27:19.152 --> 22:27:25.497
像列表上的第三个因为这是一种非标准的方式来将东西编码成我们刚

16365
22:27:25.497 --> 22:27:31.842
刚讲过的二进制东西，我们基本上可以用二进制格式编码任何东西。

16366
22:27:31.842 --> 22:27:34.116
让我们来看看编码。

16367
22:27:34.116 --> 22:27:36.708
我们来创建一个函数encode number。

16368
22:27:36.708 --> 22:27:43.736
这将是一个公共纯函数，因为我们不会读取任何状态，我们会说返回一个字节内存。

16369
22:27:43.736 --> 22:27:52.534
我们会让这个函数返回一个bytes对象，我们会让它返回这个数字会是什么样子但是是二进制的，我们会

16370
22:27:52.534 --> 22:28:01.332
说bytes, memory number = ABI。encode 1，然后返回number。

16371
22:28:01.332 --> 22:28:06.715
我们将把number编码为bi或二进制格式。

16372
22:28:06.715 --> 22:28:11.771
我知道很多时候当我们说，ABI是什么ABI是什么，对吗?

16373
22:28:11.771 --> 22:28:17.008
之前，我们说，哦，ABI是，对吧?它是所有这些输入和输出。

16374
22:28:17.008 --> 22:28:19.755
这是ABI的人类可读版本。

16375
22:28:19.755 --> 22:28:26.984
ABI是我们想要编码的应用程序二进制接口它基本上是二进制的，这

16376
22:28:26.984 --> 22:28:34.214
个ABI。encode会和你在编译细节时看到的ABI有些不同。

16377
22:28:34.214 --> 22:28:39.130
这在技术上就像ABI技术上是如何与合同交互的。

16378
22:28:39.130 --> 22:28:41.876
然而，它并不是真正的二进制版本。

16379
22:28:41.876 --> 22:28:50.299
所以我们说，好吧，把数字1编码成它的二进制版本，这样我们的契约就能以一种他们能理解的方式与它交互。

16380
22:28:50.299 --> 22:28:54.808
所以我们只是说，好，看第一个，让我们让你的机器可读。

16381
22:28:54.808 --> 22:29:00.540
如果我们编译这个，部署这个，删掉那个旧契约，部署这个，我们现在

16382
22:29:00.540 --> 22:29:06.458
有了组合字符串和编码数字，点击它，我们得到这个大十六进制的东西。

16383
22:29:06.458 --> 22:29:10.980
计算机就是这样理解数字1的。

16384
22:29:10.980 --> 22:29:15.665
现在我们几乎可以编码任何东西，我们可以编码一个字符串。

16385
22:29:15.665 --> 22:29:23.152
我们会说，函数，编码字符串，这里也设为公钥。

16386
22:29:23.152 --> 22:29:29.775
它会返回一个字节内存，因为我们想给它二进制的东西或者它咬的东西。

16387
22:29:29.775 --> 22:29:34.335
我们会说bytes memory, some字符串=

16388
22:29:34.335 --> 22:29:39.071
ABI。encode一些字符串，然后返回一些字符串。

16389
22:29:39.071 --> 22:29:46.843
现在我们编译它，删除旧契约，部署代码串，我们得到这个很大很大的对象。

16390
22:29:46.843 --> 22:29:48.429
这是二进制。

16391
22:29:48.429 --> 22:29:53.378
现在你会注意到一些东西，这里有大量的0，这些0占据了空间，

16392
22:29:53.378 --> 22:29:58.498
对吧，这对计算机来说是很大的空间，即使它们并没有真正做什么。

16393
22:29:58.498 --> 22:30:00.615
它们只是有点占地方。

16394
22:30:00.615 --> 22:30:08.642
因此，可靠性还伴随着ABI点编码策略，它对给定的参数执行打包编码。

16395
22:30:08.642 --> 22:30:12.047
如果你想，你可以在固体性文档中读到更多相关内容。

16396
22:30:12.047 --> 22:30:14.443
这被称为非标准包装模式。

16397
22:30:14.443 --> 22:30:19.526
它做同样的编码，但有一些规定，小于32字节的类型

16398
22:30:19.526 --> 22:30:24.609
直接连接而不填充，或符号扩展，动态类型编码到位。

16399
22:30:24.609 --> 22:30:33.285
没有填充长度数组元素，但仍然被编码，你可以把ENCODE打包成某种压缩器，对吧?它是ENCODE函数。

16400
22:30:33.285 --> 22:30:37.402
但如果我们想编码一些字符串但又想节省空间，它会压缩东西。

16401
22:30:37.402 --> 22:30:40.927
我们不需要完美的低水平二进制。

16402
22:30:40.927 --> 22:30:49.110
我们可以把函数和代码串打包，把它设为公共纯，然后让它返回一个字节内存。

16403
22:30:49.110 --> 22:30:57.709
我们可以说，bytes memory，某个字符串等于ABI。encode packing，还是某个字符串。

16404
22:30:57.809 --> 22:31:00.209
所以我们做的是代码包而不是代码。

16405
22:31:00.809 --> 22:31:08.055
这里返回一些字符串，我们会编译这个，我们会看到区别，编译，我们会删除旧的，我们会部署这个。

16406
22:31:08.055 --> 22:31:13.407
现在我们有ENCODE string，这也是encoded string要给我们的我们

16407
22:31:13.407 --> 22:31:18.885
有encoded string wrapped，它返回给我们这个小得多的bytes对象。

16408
22:31:18.885 --> 22:31:27.013
你可以看到大小的差异，如果我们想要节省汽油，在代码中，字符串包装将是我们节省更多汽油的一种方式。

16409
22:31:27.013 --> 22:31:35.183
abi。encode pact实际上和我们之前做过的很相似，也就是类型转换，

16410
22:31:35.183 --> 22:31:43.353
如果我们没有函数和代码字符串，字节，公共纯返回，字节，内存，字节，内存，一些

16411
22:31:43.353 --> 22:31:51.523
字符串等于字节，一些字符串，翻转一些字符串，这两个看起来几乎是一样的，对吧?

16412
22:31:51.523 --> 22:31:59.693
如果我们编译，我们会删除旧的契约，部署这个代码字符串bytes，它给我们这个

16413
22:31:59.693 --> 22:32:08.081
用ABI编码字符串包，它们给我们完全相同的输出，而编码字符串给我们这个大片段。

16414
22:32:08.081 --> 22:32:10.000
所以这两个结果是一样的。

16415
22:32:10.000 --> 22:32:12.410
但在幕后，他们正在做一些有点不同的事情。

16416
22:32:12.410 --> 22:32:14.717
具体是什么我就不细讲了。

16417
22:32:14.810 --> 22:32:21.757
但我在这里的代码中留下了一个链接，如果你想了解更多，这正是我们在非功能性测试中所做的。

16418
22:32:21.810 --> 22:32:25.531
我们在做ABR。encode packing，我们在组合两个字符串。

16419
22:32:25.531 --> 22:32:31.071
通过将它们放在一起，我们将它们编码到它们的字节实现到它们

16420
22:32:31.071 --> 22:32:36.810
的打包字节实现，然后我们只是将它们从字节类型转换回字符串。

16421
22:32:36.810 --> 22:32:39.143
这就是我们连接它们的方法。

16422
22:32:39.143 --> 22:32:41.236
现在，在这一点上，你可能会想，好吧，酷。

16423
22:32:41.236 --> 22:32:41.973
很好,帕特里克。

16424
22:32:41.973 --> 22:32:42.563
我都准备好了。

16425
22:32:42.563 --> 22:32:43.524
我理解这一点。

16426
22:32:43.524 --> 22:32:45.190
我很高兴回去做我的项目。

16427
22:32:45.190 --> 22:32:53.476
如果你想这么做，那就跳过这部分，但是其他一些观众可能会说，好吧，帕特里克，这看起来很酷。

16428
22:32:53.476 --> 22:32:58.951
但我相信这个encode函数中的encode pact不仅仅是用来连接字符串

16429
22:32:58.951 --> 22:33:04.572
的，它们可能还有其他函数，它们到底是做什么的?如果你是问这个，我很高兴你问了。

16430
22:33:04.572 --> 22:33:06.534
我很高兴你很好奇，因为我们会找到答案的。

16431
22:33:06.534 --> 22:33:15.268
现在你不仅可以编码东西，比如字符串和数字，以及任何东西，你还可以解码东西。

16432
22:33:15.268 --> 22:33:21.158
我可以说，函数，解码字符串，公共，你的返回字符串内

16433
22:33:21.158 --> 22:33:27.285
存，字符串内存，某个字符串等于ABI。decode。

16434
22:33:27.285 --> 22:33:30.359
这需要几个参数。

16435
22:33:30.359 --> 22:33:35.110
看文档，abi。decode，它的第一

16436
22:33:35.110 --> 22:33:39.861
个参数是，编码的数据，然后是一个元组。

16437
22:33:39.861 --> 22:33:48.181
你可以把它想象成一个列表但不完全是一个列表，一组要解码的类型它会返回你给它的参数的数量。

16438
22:33:48.181 --> 22:33:53.811
所以我们可能会说这个字符串内存一些字符串添加，让我们把它作为输入这个

16439
22:33:53.811 --> 22:33:59.442
编码字符串函数，这个编码字符串函数的结果，对吧，它会是这么大的东西。

16440
22:33:59.442 --> 22:34:06.303
这相当于把这个大的东西放在这里，但是我们不把这个大的东西放在这里，因为它真的很大。

16441
22:34:06.303 --> 22:34:12.525
我们会说，解码ENCODE string的结果，解码成一个字符串。

16442
22:34:12.525 --> 22:34:20.161
因为我们需要告诉固体，嘿，我们要解码这个，但它不知道解码成什么。

16443
22:34:20.161 --> 22:34:21.261
这就像，好吧，酷。

16444
22:34:21.261 --> 22:34:28.739
我可以解码这个，但是，你想让我怎么处理它，我们说，哦，这是一个字符串，那么解码成一个字符串。

16445
22:34:28.739 --> 22:34:31.120
然后我们可以返回一些字符串。

16446
22:34:31.120 --> 22:34:36.995
现在，再一次，我们部署旧的科特斯，删除上一个合同，然后部署这个新合同。

16447
22:34:36.995 --> 22:34:42.271
所以在代码串中，在代码串中，而在代码串中，代码串返回大

16448
22:34:42.271 --> 22:34:47.744
量的东西，作为人类，我们会想，天哪，我看不懂电脑能看懂。

16449
22:34:47.812 --> 22:34:49.262
但我们无法真正读懂。

16450
22:34:50.812 --> 22:34:55.812
回到它的字符串形式，我们点击解码字符串，我们得到一些字符串。

16451
22:34:55.812 --> 22:35:02.431
现在我们可以进行多重编码，多重解码，对吧，我们可以想编码多少就编码多少。

16452
22:35:02.431 --> 22:35:10.782
我可以说function multiencode, public pure，返回字节内存，我们会编

16453
22:35:10.782 --> 22:35:19.133
码一些东西，我们会说bytes，内存，一些字符串等于ABI。ENCODE一些字符串，逗号，它更大。

16454
22:35:19.133 --> 22:35:25.565
我们会在这里编码两个字符串，我们会编码一些字符串，它更大一些。

16455
22:35:25.565 --> 22:35:32.619
我们有两个字符串，我们会编码并返回一些字符串，即使它是字节。

16456
22:35:32.619 --> 22:35:35.452
然后我们就可以进行多重解码。

16457
22:35:35.452 --> 22:35:40.570
我们会说function multi decode，这是一个公

16458
22:35:40.570 --> 22:35:45.689
共纯返回，我们会说它返回两个字符串，字符串内存，和字符串内存。

16459
22:35:45.689 --> 22:35:52.166
而不是做字符串内存，一些字符串等于API解码，我们会说，

16460
22:35:52.166 --> 22:35:58.412
字符串内存，一些字符串，逗号字符串内存，另一些字符串。

16461
22:35:58.412 --> 22:36:03.612
我们会得到returns = Avi。decode。

16462
22:36:03.812 --> 22:36:11.949
让我们解码这个多重编码的结果，它是双重编码的字符串变成一个字符串和另一个字符串。

16463
22:36:11.949 --> 22:36:17.395
然后我们返回这两个都是一些字符串，好了。

16464
22:36:17.395 --> 22:36:22.249
现在我们返回一个字符串，然后是另一个字符串，这里我需要一个分号。

16465
22:36:22.249 --> 22:36:26.368
当我们部署这个的时候，把它关闭，部署这个新的，

16466
22:36:26.368 --> 22:36:35.146
现在我们有了这个multiin代码，这就得到了这个更大的bites对象?因为这是两个编码的字符串。

16467
22:36:35.146 --> 22:36:40.435
如果我们点击多重解码，花点时间，你觉得它会输出什么?让我们继续并点击它。

16468
22:36:40.435 --> 22:36:46.345
现在它会给我们两个字符串，对吧，它会给你这两个字符串，一些更大的字符串。

16469
22:36:46.345 --> 22:36:50.337
我们可以告诉固体度来编码一堆东西。

16470
22:36:50.337 --> 22:36:57.444
然后我们甚至可以通过告诉它来解码它，好的，这个大对象，它是两个字符串的组合，然后我们解码它。

16471
22:36:57.444 --> 22:37:03.605
现在你甚至可以用编码包进行多重编码?我们可以用function, multiencode

16472
22:37:03.605 --> 22:37:10.606
packed, public pure returns, bytes memory，然后是bytes

16473
22:37:10.606 --> 22:37:18.307
memory, some string = ABI。encode packed some string，逗号，

16474
22:37:18.307 --> 22:37:25.729
它比return some string大，我们可以这样做，对吧，但这将给我们这两个字符串的打包版本。

16475
22:37:25.729 --> 22:37:32.253
解码实际上对这个无效因为这是打包编码。

16476
22:37:32.253 --> 22:37:36.485
如果我们试着这么做，我会说这行不通。

16477
22:37:36.485 --> 22:37:43.303
尝试执行function, multidecode，包装，公共纯返回，

16478
22:37:43.303 --> 22:37:50.121
字符串内存，字符串内存，somestring = Avi。decode

16479
22:37:50.121 --> 22:37:56.744
multiencode包装在字符串中就像我们上面做的那样，如果我们返

16480
22:37:56.744 --> 22:38:03.759
回一些字符串，你认为会发生什么?让我们试着删除旧的合同，部署一个新的。

16481
22:38:03.814 --> 22:38:10.502
我们会做多重解码，打包，多重编码多重解码，打包，我们会得到一个错误。

16482
22:38:10.502 --> 22:38:14.414
固体基本上是这样的，是的，这里看起来很拥挤。

16483
22:38:14.414 --> 22:38:16.523
我不知道怎么解码。

16484
22:38:16.523 --> 22:38:20.870
但相反，我们能做的是我们能做更多的函数对string

16485
22:38:20.870 --> 22:38:29.898
cast打包像这样一个public pure返回string memory, string, memory,

16486
22:38:29.898 --> 22:38:37.256
some string = string, multi然后代码打包，返回一些字符串。

16487
22:38:37.256 --> 22:38:45.359
这个可以正常工作，因为这个契约编码有点类似于类型转换。

16488
22:38:45.359 --> 22:38:53.666
我们会编译并重新部署多字符串强制转换契约，我们得到一些尝试，它更大，对吧?我们这里没有空的地方。

16489
22:38:53.666 --> 22:38:55.617
但我们应该在这里留个空格。

16490
22:38:55.617 --> 22:39:02.099
现在我们已经在ABI点编码和解码中了解了更多，

16491
22:39:02.099 --> 22:39:08.581
我们知道，这是计算机，这是Aetherium。

16492
22:39:08.581 --> 22:39:11.914
这就是EVM，或者任何与EVM兼容的链所寻找的。

16493
22:39:11.914 --> 22:39:13.639
它在寻找这个字节码。

16494
22:39:13.639 --> 22:39:16.242
它在寻找这个，这个二进制的东西。

16495
22:39:16.242 --> 22:39:22.402
我们刚刚学了一点关于如何将不同的变量编码成二进制到数据位。

16496
22:39:22.402 --> 22:39:30.578
那我们现在怎么办?既然我们知道我们的事务将被编译成二进制的东西，

16497
22:39:30.578 --> 22:39:39.010
我们能做的就是我们自己用代码将要使用的二进制填充我们事务的数据值。

16498
22:39:39.010 --> 22:39:47.670
这是合约部署的事务，合约部署的数据字段将是函数调用的所有合

16499
22:39:47.670 --> 22:39:56.331
约二进制代码，数据块将是发送到地址的数据调用到地址的函数。

16500
22:39:56.331 --> 22:40:04.252
让我们来看看另一笔交易以太扫描就在我们的一份合同上，你们不需要我要看看上一节的进入抽奖。

16501
22:40:04.252 --> 22:40:07.011
如果我们选择向下，我们会查看输入数据。

16502
22:40:07.011 --> 22:40:08.978
它说function enter raffle method ID。

16503
22:40:08.978 --> 22:40:14.735
但如果我们看原始数据，这是数据字段发送的数据。

16504
22:40:14.815 --> 22:40:19.142
这是二进制，这是十六进制这是奇怪的，低级字节的东西。

16505
22:40:19.142 --> 22:40:27.847
这就是以太坊区块链或任何你正在使用的EVM链知道调用哪个函数的方式，它将其转换为一个函数。

16506
22:40:27.847 --> 22:40:33.386
我们可以做完全相同的事情，自己调用这些函数。

16507
22:40:33.386 --> 22:40:39.704
我们能用这些新发现的数据和编码做什么呢，

16508
22:40:39.704 --> 22:40:46.022
我们能做的是将事务的数据字段，在事务调用

16509
22:40:46.022 --> 22:40:52.340
中发送回以太回调中数据就是合约创建代码。

16510
22:40:52.340 --> 22:40:57.265
相反，我们可以用函数调用代码填充这个数据，也

16511
22:40:57.265 --> 22:41:02.190
就是我们想在十六进制加法二进制中调用的函数。

16512
22:41:02.190 --> 22:41:08.889
现在你可能会想，哦，好吧，我为什么要这样做，我总是可以使用接口，ABI，所

16513
22:41:08.889 --> 22:41:15.589
有的东西，好吧，也许你没有这些也许你只有函数名，也许你只有你想发送的参数。

16514
22:41:15.589 --> 22:41:22.591
或者你想让你的代码，能够发送任意函数，或者进行任意调用，或者做一些非

16515
22:41:22.591 --> 22:41:29.593
常高级的事情，这就是通过填充数据字段直接发送函数调用非常重要的地方。

16516
22:41:29.593 --> 22:41:35.578
记住，我说过，你总是需要ABI和契约地址，发送一个函数。

16517
22:41:35.578 --> 22:41:37.713
当我说，你总是需要API。

16518
22:41:37.816 --> 22:41:45.170
最初，我们讨论的是这个东西，这个很大的东西，很酷，就是API。

16519
22:41:45.170 --> 22:41:50.101
但这就像人类可读的API，你也可以用非人类可读的API。

16520
22:41:50.101 --> 22:41:54.901
另外，你不需要所有这些东西，你可以只使

16521
22:41:54.901 --> 22:41:59.701
用函数名，然后输入类型来发送函数调用。

16522
22:41:59.701 --> 22:42:08.527
那么问题是，我们如何发送?如何发送调用仅填充数据字段的函数的事务?下一个问题是，如

16523
22:42:08.527 --> 22:42:17.353
何填充数据字段?我们用什么填充数据字段来进行这些函数调用呢?然后我们如何缓慢地发送

16524
22:42:17.353 --> 22:42:26.179
这些事务，有一些更低级的关键字，即静态调用和调用我们以前用过调用，这些代码你们熟悉

16525
22:42:26.179 --> 22:42:35.005
吗?它应该是这样的，因为这是，我们在彩票的实现随机单词中使用了类似的设置，对吧，我

16526
22:42:35.005 --> 22:42:44.477
们通过最近的winner点调用来发送资金?最近，这是最近的获奖者的地址，我们没有打电话。

16527
22:42:44.477 --> 22:42:49.612
然后括号里有一些奇怪的东西，括号里什么都没有。

16528
22:42:49.612 --> 22:42:56.077
我们之前用过这个call关键字，但我们没有告诉你它是做什么的。

16529
22:42:56.077 --> 22:42:59.494
调用是我们如何调用函数来改变区块链的状态。

16530
22:42:59.494 --> 22:43:04.952
静态调用基本上是在底层，我们调用视图或纯函数，写静态调

16531
22:43:04.952 --> 22:43:10.613
用会像这样，不要用这个改变区块链的状态，只给我们返回值。

16532
22:43:10.613 --> 22:43:17.910
这类似于低级别的视图或纯函数，也有Send词但基本上还是算了吧。

16533
22:43:17.910 --> 22:43:20.488
我们只会用call，而不是call。

16534
22:43:20.488 --> 22:43:23.259
稍后，我们会学到另一个叫委托调用。

16535
22:43:23.259 --> 22:43:25.080
但现在不用担心这个。

16536
22:43:25.080 --> 22:43:33.572
最近的冬鸭调用是这样的，在这些弯弯曲曲的小括号中，我们说，好，我们直接更新了我们的交易的值。

16537
22:43:33.572 --> 22:43:39.617
如果我们有这些交易字段，我们直接在这些小括号里更新价值，对吧，

16538
22:43:39.617 --> 22:43:45.663
我们也可以直接在这些小括号里更新天然气有限价格如果我们想的话。

16539
22:43:45.663 --> 22:43:49.160
在这里，这些括号是我们要存放数据的地方。

16540
22:43:49.160 --> 22:43:51.628
因为我们的退出是为了做什么。

16541
22:43:51.628 --> 22:43:53.928
以前的功能是送钱。

16542
22:43:53.928 --> 22:43:58.767
我们说，好吧，送钱改变我们要送的值。

16543
22:43:58.767 --> 22:44:05.247
但不要传递任何数据，保持数据位为空，这就是为什么，记住我们之前是怎么

16544
22:44:05.247 --> 22:44:11.727
点击这个按钮的我们调用了data be empty，这实际上是运行这

16545
22:44:11.727 --> 22:44:18.591
个命令，调用了data be空这个部分为空，然后更新我们用事务设置的值。

16546
22:44:18.591 --> 22:44:23.372
这部分我们可以用来填充数据来调用特定的函数。

16547
22:44:23.372 --> 22:44:25.368
我们会在这里放更多的注释。

16548
22:44:25.368 --> 22:44:29.259
因此，当我们使用弯弯曲曲的括号时，我们能够传递一个事务的特定字段，比如value。

16549
22:44:29.259 --> 22:44:34.117
在括号里，我们可以传递数据来调用一个特定的函数。

16550
22:44:34.117 --> 22:44:43.105
但在这里，没有函数可以调用因为我们只是发送它们如果我们想调用函数或发送任何数据，我们可以在括号中做。

16551
22:44:43.105 --> 22:44:47.834
我想我拼错了。

16552
22:44:47.834 --> 22:44:50.718
现在，我们已经学到了很多。

16553
22:44:50.718 --> 22:44:53.428
让我们快速复习一下刚刚学过的内容。

16554
22:44:53.428 --> 22:44:59.172
然后我们将学习如何调用任何函数通过使用这里的语法。

16555
22:44:59.172 --> 22:45:06.193
我们从很高级的地方学过，如果我们想组合字符串，我们可以做ABI。encode wrapped，然后类型转换为字符串。

16556
22:45:06.193 --> 22:45:09.176
在solidity的新版本中，

16557
22:45:09.176 --> 22:45:15.741
你可以做string。concat，你知道，嗨，妈妈，来吧，想你。

16558
22:45:15.741 --> 22:45:17.507
在新的固体版本中。

16559
22:45:17.507 --> 22:45:20.197
这同样有效，但在较老版本的固体中无效。

16560
22:45:20.197 --> 22:45:28.974
然后我们学到了很多低级的东西，当我们编译合同时，我们得到一个ABI文件，这个奇

16561
22:45:28.974 --> 22:45:37.751
怪的二进制文件，数字和字母当我们部署合同时它被发送到合同创建事务的数据字段中。

16562
22:45:37.818 --> 22:45:42.898
对于契约创建，数据会被二进制代码填充函数调用会定

16563
22:45:42.898 --> 22:45:47.979
义调用哪个函数用什么形参这就是我们接下来要讲的。

16564
22:45:47.979 --> 22:45:54.394
现在，我们知道了我们可以把东西编码成二进制，编码成低级代码。

16565
22:45:54.394 --> 22:46:01.106
任何程序任何进程，只要能读取这个底层的东西并相应执行，读取这个EVM的东西，读

16566
22:46:01.106 --> 22:46:07.818
取Aetherium指定的特定二进制文件，或者EVM指定的，都被认为是EVM。

16567
22:46:07.818 --> 22:46:08.632
兼容的。

16568
22:46:08.632 --> 22:46:14.468
我们可以编码数字，我们可以编码字符串，我们几乎可以编码任何我们想编码的东西。

16569
22:46:14.468 --> 22:46:20.109
为了节省空间，我们会打包编码，我们可以解码已经编码的东西，但

16570
22:46:20.109 --> 22:46:25.750
我们不能解码打包编码的东西，我们可以多重编码，然后多重解码。

16571
22:46:25.750 --> 22:46:33.676
最后，我们可以使用调用函数在这里添加数据来对智能合约进行任何调用。

16572
22:46:33.676 --> 22:46:35.723
这就是我们接下来要学的。

16573
22:46:35.819 --> 22:46:39.751
好了，现在是休息的好时间了，因为我们刚刚学了一些非常难的概念。

16574
22:46:39.751 --> 22:46:44.345
就像我说的，如果你第一次没有理解，没关系。

16575
22:46:44.345 --> 22:46:47.432
好了，欢迎回来。

16576
22:46:47.432 --> 22:46:54.220
现在我们已经学习了编码，让我们学习如何填充这个括号这个数据域，这样我

16577
22:46:54.220 --> 22:47:01.008
们就可以调用任何函数，我们基本上可以做，区块链在底层要做什么，我们可

16578
22:47:01.008 --> 22:47:07.996
以使用二进制，我们可以使用字节，我们可以使用十六进制来与智能合约交互。

16579
22:47:07.996 --> 22:47:09.474
让我们创建一个新文件。

16580
22:47:09.474 --> 22:47:15.752
我们会调用它调用任何东西，这些都是从spdx开始的，许可标识符，MIT。

16581
22:47:15.752 --> 22:47:17.287
我们来谈谈这个。

16582
22:47:17.287 --> 22:47:22.781
为了调用为了只使用调用的数据字段来调用一个函数，我们需要编码函数名，

16583
22:47:22.781 --> 22:47:28.115
以及我们想要添加的参数，因为当我们调用一个函数时，我们调用函数名。

16584
22:47:28.115 --> 22:47:30.115
我们称之为参数。

16585
22:47:30.115 --> 22:47:35.022
所以我们需要将这些编码到二进制级别，这样EVM或这

16586
22:47:35.022 --> 22:47:39.930
些基于以太的智能合约和实体就能理解实际发生了什么。

16587
22:47:39.930 --> 22:47:45.555
为了做到这一点，我们需要使用两个概念来编码函数名，这样EVM

16588
22:47:45.555 --> 22:47:51.369
或实体就能理解它，我们实际上必须抓取一个叫做函数选择器的东西。

16589
22:47:51.369 --> 22:47:56.019
现在函数选择器将是函数签名的前四个字节。

16590
22:47:56.019 --> 22:48:00.786
函数签名是一个字符串，它定义了函数的形参名。

16591
22:48:00.819 --> 22:48:07.270
这到底是什么意思呢?如果我们有一个传递函数，这就是函数的特征。

16592
22:48:07.270 --> 22:48:09.520
函数名是transfer。

16593
22:48:09.520 --> 22:48:16.256
它会取一个地址和256作为它的输入，如果我们编码这个传递函

16594
22:48:16.256 --> 22:48:22.992
数，然后取它的前四个字节，我们得到这个，它指向函数选择器。

16595
22:48:22.992 --> 22:48:24.992
这就是固体是如何知道的。

16596
22:48:24.992 --> 22:48:30.058
在字节码中，在二进制代码中，这个函数选择器是劈开知

16597
22:48:30.058 --> 22:48:35.328
道的，哦，他们说的是传递函数他们想让我调用传递函数。

16598
22:48:35.328 --> 22:48:41.924
这是我们使用调用来调用任何我们想要的函数时需要做的第一件事之一，我们需要得到函数选择

16599
22:48:41.924 --> 22:48:48.521
器我们可以通过很多不同的方式得到它但其中一种方式是通过编码函数签名并获取前四个字节。

16600
22:48:48.521 --> 22:48:54.070
我们创建这个契约，pragma solidity 0,8。

16601
22:48:54.070 --> 22:48:57.177
7说合同，什么都可以。

16602
22:48:57.177 --> 22:49:03.748
我们把这个赋给存储的变量，赋给存储的变量并赋给public s，下划线表示某

16603
22:49:03.748 --> 22:49:10.320
个数量，或者某个地址，然后在256中，public s下划线表示mount。

16604
22:49:10.320 --> 22:49:13.241
然后我们会创建一个函数叫做传递函数传递。

16605
22:49:13.241 --> 22:49:20.191
通常在这里，我们会做一个像ERC 20的转账，但我们只会做一个地址一个地

16606
22:49:20.191 --> 22:49:27.336
址，然后你在这里添加256个金额，这里是金额，我们会让它成为一个公共函数。

16607
22:49:27.336 --> 22:49:34.070
然后我们要做的就是设S，某个地址等于某个地址，然后S的金额等于金额。

16608
22:49:34.070 --> 22:49:37.820
这就是我们要处理的函数。

16609
22:49:37.820 --> 22:49:42.968
这个函数的函数选择器是这个，函数签名是这个。

16610
22:49:42.968 --> 22:49:49.368
它取一个地址一个地址量，它被归结为函数选择器和函数签名。

16611
22:49:49.368 --> 22:49:55.476
当然，在字节码中，会有一些代码说，好，这是这个函数的功能，等等等等。

16612
22:49:55.476 --> 22:49:58.402
我们甚至可以写一个函数来得到那个函数选择器。

16613
22:49:58.402 --> 22:50:06.852
我们可以说，function, getselector我要说，getselector 1，因为我会给你们展示一些获取函数选择器的方法，我们会把这个设为公共纯。

16614
22:50:06.852 --> 22:50:11.164
我们会让这个返回一个bytes for

16615
22:50:11.164 --> 22:50:19.108
selector，我们可以说selector = bytes for，

16616
22:50:19.108 --> 22:50:25.691
然后我们哈希到签名的56个字节，也就是transfer。

16617
22:50:25.821 --> 22:50:29.545
它需要一个地址和一个UNT 56。

16618
22:50:31.821 --> 22:50:38.227
这个，然后我们运行它，让我们摆脱旧的合同，部署，确保我们随时待命，如果你有另一个。

16619
22:50:38.227 --> 22:50:41.765
在这里，我们有一些东西，我们点击Get

16620
22:50:41.765 --> 22:50:47.725
selector 1，我们得到这个哦X，一个905，等等等等。

16621
22:50:47.821 --> 22:50:49.493
这和我刚才举的例子是一样的。

16622
22:50:49.821 --> 22:50:56.984
这里告诉我们的是可靠度告诉我们的智能合约，当我们调用这个合约时，如果你在函数

16623
22:50:56.984 --> 22:51:04.337
数据中看到这个，它指的是我们的传递函数有一个地址和一个un256作为输入参数。

16624
22:51:04.337 --> 22:51:06.280
所以我们看到你进入56。

16625
22:51:06.280 --> 22:51:09.230
我们的函数知道执行这里的数据。

16626
22:51:09.230 --> 22:51:09.623
太好了。

16627
22:51:09.821 --> 22:51:12.221
当然，sml和S地址都是0。

16628
22:51:12.821 --> 22:51:21.288
我们在这里，我们也可以看到，如果我们调用传递函数会发生什么?它需要一个地址和一个金额，所以我们给它自己的地址或地址。

16629
22:51:21.288 --> 22:51:23.132
我们可以用777。

16630
22:51:23.132 --> 22:51:28.768
如果我们点击转移，我们会打开日志，我们会在这里得到一个小的标记，表示成功。

16631
22:51:28.822 --> 22:51:31.355
如果达到S值，就得到777。

16632
22:51:32.822 --> 22:51:35.383
都是一样的，对吧?这就是我们直接调用的转移。

16633
22:51:35.383 --> 22:51:43.789
当我们直接调用转移时，我们基本上是在说，抓取这个函数选择器，然后做一些其他的事情，我们一会儿会告诉你们其他的事情。

16634
22:51:43.822 --> 22:51:45.558
现在我们有了函数选择器。

16635
22:51:45.558 --> 22:51:46.189
好了,好了。

16636
22:51:46.822 --> 22:51:49.628
我们还需要我们想要添加的参数。

16637
22:51:49.822 --> 22:51:55.388
我们需要用函数选择器来编码这些参数。

16638
22:51:55.388 --> 22:52:00.640
我们要做的是，function，获取数据，调用transfer。

16639
22:52:00.640 --> 22:52:07.804
在这里，我们会有这个get data来调用transfer，我们会让它接受这些输入参数，

16640
22:52:07.804 --> 22:52:14.644
我们会对这些进行编码以与我们的函数选择器一起工作，我们会说address，某个地址。

16641
22:52:14.644 --> 22:52:22.640
如果它是x, amount, public pure返回字节内存。

16642
22:52:22.822 --> 22:52:27.822
然后我们可以返回并使用小抄中的ABI和代码之一。

16643
22:52:27.822 --> 22:52:31.676
到目前为止，我们一直在做API和编码。

16644
22:52:31.676 --> 22:52:38.222
因为我们有函数选择器，我们可以用ABI。encode with selector。

16645
22:52:38.222 --> 22:52:43.516
这个ABI从第二个参数和前置参数开始编码给定的参数，即给定的四字节选择器。

16646
22:52:43.516 --> 22:52:49.063
当我们在Cobra选择器中做时，我们只是把选择器粘到我们会给它的数据上。

16647
22:52:49.063 --> 22:52:54.408
我们会返回API。encode with select door。

16648
22:52:54.408 --> 22:52:59.261
我们会把get selector 1的结

16649
22:52:59.261 --> 22:53:04.357
果传递给它，然后我们会给它一些地址和数量。

16650
22:53:04.357 --> 22:53:11.154
它会给我们所有需要放到交易数据域中的数据，发送给这个合

16651
22:53:11.154 --> 22:53:18.203
约让这个合约知道，使用传递函数，传入一个地址和一个金额。

16652
22:53:18.203 --> 22:53:23.602
然后我们编译这个，运行它，删除旧合同，然后部署，

16653
22:53:23.602 --> 22:53:34.177
我们有一个新函数叫Get Data来调用和转移，我们只传递这个合同地址然后我们再做一次777。

16654
22:53:34.177 --> 22:53:42.661
这里这个东西是我们要放到事务数据域中的以便我们能从任何地方调用转移。

16655
22:53:42.661 --> 22:53:51.623
这是字节，这是二进制编码的数据，用我们指定的地址调用传递函数。

16656
22:53:51.623 --> 22:53:53.156
你知道，777mt。

16657
22:53:53.156 --> 22:54:00.823
一旦我们有了这些，我们可以调用传递函数而不用直接调用它。

16658
22:54:00.823 --> 22:54:09.686
我们能做的是，我们可以说函数，直接调用传递函数，我想用二进制可能是一个更好的标题，

16659
22:54:09.686 --> 22:54:18.117
但你知道要点，我们会说地址某个地址，你在256中，我们会让它成为一个公共函数。

16660
22:54:18.117 --> 22:54:21.244
我们会有a返回一个字节4和一个bool。

16661
22:54:21.244 --> 22:54:23.353
你马上就会知道为什么了。

16662
22:54:23.353 --> 22:54:28.161
我们会像送奖券时那样打电话。

16663
22:54:28.161 --> 22:54:33.937
我们要做的是，在我们做recent winner。call之前，我们要做一些地址。

16664
22:54:33.937 --> 22:54:37.073
然后对我们来说，我们要处理这个点调用。

16665
22:54:37.073 --> 22:54:43.308
然后我们说这个契约地址我们可以把任何地址放在这里地址。

16666
22:54:43.308 --> 22:54:49.774
调用，我们将调用编码的数据它指向带有一些参数的传递函数。

16667
22:54:49.774 --> 22:54:52.004
所以我们要解决这个问题。

16668
22:54:52.004 --> 22:54:52.200
com。

16669
22:54:52.200 --> 22:55:00.574
我们可以获取数据来调用转移地址金额，对，我们可以这样做。

16670
22:55:00.574 --> 22:55:03.044
或者我们也可以用一种错误的方法。

16671
22:55:03.044 --> 22:55:11.193
我们可以用ABI。和code，用select dorm，得到selector 1，逗号，一些地址，逗号amount。

16672
22:55:11.193 --> 22:55:14.146
抱歉，这里没有分号。

16673
22:55:14.146 --> 22:55:16.372
所以它们是一样的。

16674
22:55:16.372 --> 22:55:22.352
这个点调用的东西，它会返回我们之前看到的，它会返回bool success。

16675
22:55:22.352 --> 22:55:27.364
无论事务是否成功，然后是字节，内存，

16676
22:55:27.364 --> 22:55:32.098
返回的数据，也就是调用返回的东西。

16677
22:55:32.098 --> 22:55:35.350
这就是我们需要成功的地方，对吧。

16678
22:55:35.350 --> 22:55:42.013
但对我们来说，我们只会返回字节，一个返回数据有四个字节，然后成功。

16679
22:55:42.013 --> 22:55:47.146
我们只会返回返回数据的前四个字节。

16680
22:55:47.146 --> 22:55:49.690
然后我们会返回这个是否成功。

16681
22:55:49.690 --> 22:55:55.590
这个函数会让我们直接调用传递函数通过传递这些

16682
22:55:55.590 --> 22:56:01.760
参数而不需要我们做契约。转移，或者转移什么的。

16683
22:56:01.824 --> 22:56:08.157
你可以在多个合同中这样做在不同的合同中，只需要改变你调用的地址。

16684
22:56:08.157 --> 22:56:09.823
让我们来编译这个。

16685
22:56:09.823 --> 22:56:13.582
我们现在运行这个删除旧合同，部署调用任何东西。

16686
22:56:13.582 --> 22:56:14.908
现在如果我们如果我们。

16687
22:56:14.908 --> 22:56:18.109
现在sml和估计量都是0。

16688
22:56:18.109 --> 22:56:26.735
现在，如果我们直接调用转移函数，我们会传入这个的地址，然后我们会做777。

16689
22:56:26.825 --> 22:56:33.491
如果我们调出日志，点击这个，我们会得到这个事务响应。

16690
22:56:33.491 --> 22:56:42.200
但如果向下滚动，我们会看到解码后的输出，也就是一串0的字节，对吧?因为我们的转移实际上没有返回任何东西。

16691
22:56:42.200 --> 22:56:47.028
它会是一堆0，然后我们的布尔值为真，这意味着成功了。

16692
22:56:47.028 --> 22:56:51.758
既然成功了，这两个就应该在此基础上做出改变。

16693
22:56:51.825 --> 22:56:53.497
我们来试一下。

16694
22:56:54.825 --> 22:56:55.792
他们改变了。

16695
22:56:58.825 --> 22:57:05.750
函数而不必调用传递函数本身，我们也可以用签名而不是选择器进行编码。

16696
22:57:05.825 --> 22:57:12.860
如果我们去我们的小抄，下面这里也有这个encode with signature，它接受字符串内存签名，它等价于做ABI。

16697
22:57:12.860 --> 22:57:20.934
encode with selector bytes for CAC bytes，你知道，signature，它等价于做我们在上面做的事情。

16698
22:57:20.934 --> 22:57:23.199
但它为我们完成了这一步。

16699
22:57:23.199 --> 22:57:30.179
我们可以复制这整个东西，粘贴到这里，我们可以不用selector编码，

16700
22:57:30.179 --> 22:57:39.753
我们可以用SIG netshare编码，函数签名，然后我们会从上面这里复制函数签名，粘贴到这里。

16701
22:57:39.825 --> 22:57:45.353
编译时，我们碰到了编译错误，上来，这些都是直接调用SIG的转移函数，

16702
22:57:45.353 --> 22:57:51.857
叫做Compile, leader, old contract, deploy。

16703
22:57:51.857 --> 22:57:54.375
现在这两个又都是0。

16704
22:57:54.375 --> 22:57:58.954
现在如果我们复制合同地址，我们直接调用合同呼叫转移功能SIG。

16705
22:57:58.954 --> 22:58:05.761
我们把它粘贴到这里，我们把它叫做777，让我检查一下我们可以看到它做了完全相同的事情。

16706
22:58:05.761 --> 22:58:08.316
这是API。encode with signature。

16707
22:58:08.316 --> 22:58:10.061
这是abi。encode selector。

16708
22:58:10.061 --> 22:58:13.873
Encode with signature只是把我们变成了selector。

16709
22:58:13.873 --> 22:58:17.235
这些都在上面，我们自己编码了这个选择器。

16710
22:58:17.235 --> 22:58:20.580
有很多不同的方法来获取选择器。

16711
22:58:20.580 --> 22:58:22.283
我们不会自己把这些编码出来。

16712
22:58:22.283 --> 22:58:27.747
这里有很多不同的获取selector的方法。

16713
22:58:27.747 --> 22:58:35.626
谁知道为什么呢为什么你会想用其他的理由，对吧?有很多原因可以解释为什么你想用不同的方式获得selector。

16714
22:58:35.626 --> 22:58:43.404
在这个视频中，我们不打算解释或复习所有这些不同的所有这些不同的函数选择器获取方法。

16715
22:58:43.404 --> 22:58:48.995
但如果你在与本课程相关的GitHub回购中浏览它们，它们都有大量注释来解释它们在做什么。

16716
22:58:48.995 --> 22:58:55.645
我们会向你们展示，合约之间是如何交互的而不需要每个合约的所有代码。

16717
22:58:55.645 --> 22:59:04.219
我们来做第二个契约它包含所有的二进制这个字节信息来调用另一个契约上的传递函数。

16718
22:59:04.219 --> 22:59:06.333
我们将向你展示这是如何工作的。

16719
22:59:06.333 --> 22:59:10.342
这是我做的另一个契约，叫做call function without contract。

16720
22:59:10.342 --> 22:59:18.056
实际上,下面,我们将调用传递函数,通过使用函数选择器的地址和签名和东西,

16721
22:59:18.056 --> 22:59:25.770
我们会更新这些存储变量调用什么合同从另一个合同就这样二进制打电话,如果你

16722
22:59:25.770 --> 22:59:33.484
愿意,是的,让我们编译、部署,我们就可以离开这了吧,我们可以离开这个让我

16723
22:59:33.484 --> 22:59:41.629
们部署调用函数没有合同,我们将把它作为输入参数,只要是合同地址，我们就部署。

16724
22:59:41.629 --> 22:59:48.268
在这里，我可以直接调用传递函数。也许我可以把它切换到这里，

16725
22:59:48.268 --> 22:59:54.679
这个合约地址这个新的合约地址，我们给它一个新数字123。

16726
22:59:54.679 --> 22:59:57.695
好的，我们点击呼叫转移函数。

16727
22:59:57.827 --> 23:00:01.093
然后当我们回到这里，我们看到这个确实被更新了。

16728
23:00:01.093 --> 23:00:04.284
现在做这种电话工作被认为是低水平的。

16729
23:00:04.284 --> 23:00:07.160
最好的做法是尽量避免。

16730
23:00:07.160 --> 23:00:10.318
如果你能导入一个接口，最好这样做。

16731
23:00:10.318 --> 23:00:16.646
因为编译器在你这边，你就能检查你的类型是否匹配等等。

16732
23:00:16.646 --> 23:00:24.827
通常在做这些低级调用时一些安全审计检查人员可能会说，嘿，比如这本书出了一点，你在做这些低级的东西。

16733
23:00:24.827 --> 23:00:29.810
但话虽如此，你们已经学到了很多关于低能级固体的知识。

16734
23:00:29.810 --> 23:00:31.531
这是一些非常高级的东西。

16735
23:00:31.531 --> 23:00:36.513
就像我说的，如果这很难，如果你有点困惑，别担心，你可以回到这

16736
23:00:36.513 --> 23:00:41.663
部分再试一次，当你更高级一点的时候，如果你想现在就试着理解它。

16737
23:00:41.663 --> 23:00:42.187
太棒了。

16738
23:00:42.187 --> 23:00:49.861
当然，我们在GitHub上留下了一些与这节课相关的链接我强烈建议你们去看看其中一个你们一定要

16739
23:00:49.861 --> 23:00:57.536
去看看的链接，它将是openzeppelin对实体的解构，它真正地分解了契约幕后发生的事情。

16740
23:00:57.536 --> 23:01:05.730
如果你想了解更多关于操作码的知识，关于低级别的东西，一定要读一读这个，它是一个了不起的读本，本质上，它比我们刚才讲的分解得要多一些。

16741
23:01:05.730 --> 23:01:07.665
还有其他几个视频。

16742
23:01:07.665 --> 23:01:10.303
我在这里也留下了很多链接。

16743
23:01:10.303 --> 23:01:18.239
话虽如此，现在我们又回到了非功能性的节目。

16744
23:01:18.239 --> 23:01:22.013
现在我们知道了ABI点编码的所有东西以及它的作用，

16745
23:01:22.013 --> 23:01:27.448
我们知道ABI点编码包装，我们在这里使用的方法只是连接字符串的一种方法。

16746
23:01:27.448 --> 23:01:33.643
我们不会用ABI。encode来实现它的超能力，但我们会在后面的课程中用到。

16747
23:01:33.643 --> 23:01:38.906
在另一种情况下，我们使用我们导入的以64为基数的点编码，

16748
23:01:38.906 --> 23:01:47.177
我们导入这个以64为基数的点编码这样我们就可以编码我们传递给SVG的以64为基数的编码。

16749
23:01:47.177 --> 23:01:49.565
我要复制粘贴一个例子，你不需要这么做。

16750
23:01:49.565 --> 23:01:58.066
比如，我们会传入SVG width =等等，所有这些SVG的东西，有点类似于我之前给你们看的，

16751
23:01:58.066 --> 23:02:06.387
我们把它作为输入参数传入，然后输出，我们会得到它的64进制编码，我们会得到这个巨大的字符串。

16752
23:02:06.387 --> 23:02:09.150
稍后我们将对此进行测试，以确保其工作正常。

16753
23:02:09.150 --> 23:02:13.957
通常情况下，如果我现在像这样添加一个函数，我可能会立即测试它。

16754
23:02:13.957 --> 23:02:15.336
现在我们可以把它放在这里。

16755
23:02:15.336 --> 23:02:18.086
这对得到这张图很有帮助。

16756
23:02:18.086 --> 23:02:22.935
但我们不只是想要一个图像，对吧?我们需要元数据。

16757
23:02:22.935 --> 23:02:28.719
我们需要这是一个JSON对象，而不仅仅是像这样的图像URL，我们需

16758
23:02:28.719 --> 23:02:34.680
要将这个图像，这个base64编码的图像粘贴到JSON的图像字段中。

16759
23:02:34.680 --> 23:02:41.786
那么我们要怎么做呢?我们能做的是，我们知道我们的ERC 721代码带有一

16760
23:02:41.786 --> 23:02:49.090
个令牌URI，正是那个令牌URI指向这个，它告诉我们我们的代码是什么样的。

16761
23:02:49.090 --> 23:02:57.128
我们能做的是我们也能以64为基数编码我们的JSON，把它变成一个JSON令牌URI。

16762
23:02:57.128 --> 23:03:03.021
我们对这个图像进行了编码得到这个，我们将把这个URL插入到JSON中。

16763
23:03:03.021 --> 23:03:09.579
然后我们用64进制编码JSON，那将是令牌使用的URI。

16764
23:03:09.579 --> 23:03:12.844
我们有了函数，令牌URI。

16765
23:03:12.844 --> 23:03:18.192
这需要一个un 256令牌ID，我们会说它将是一

16766
23:03:18.192 --> 23:03:23.540
个公共视图，公共视图覆盖，它返回一个字符串内存。

16767
23:03:23.540 --> 23:03:30.695
所以我们将重写ERC 721的令牌URI函数，让它变成我们想要的样子。

16768
23:03:30.695 --> 23:03:37.928
这里我们将把合约中的一些JSON文本编码成一个基于base6

16769
23:03:37.928 --> 23:03:45.162
4的JSON令牌URI首先，我们需要一个下划线exists。

16770
23:03:45.162 --> 23:03:52.283
Token ID，然后我说你的I查询不存在的Token。

16771
23:03:52.283 --> 23:03:57.863
对，这个价格应该是如果不存在，返回错误。

16772
23:03:57.863 --> 23:04:00.216
但是，我们要这样做。

16773
23:04:00.216 --> 23:04:04.764
这个存在函数在我的耳朵里，c721。

16774
23:04:04.764 --> 23:04:06.729
我们在这里做同样的事情。

16775
23:04:06.729 --> 23:04:08.568
我们会说，需要这个令牌，D存在。

16776
23:04:08.568 --> 23:04:09.872
同样，我们可以百分之百。

16777
23:04:09.872 --> 23:04:15.959
也许应该把这个设为IF EXISTS令牌ID，现在我们要做的是

16778
23:04:15.959 --> 23:04:22.047
弄清楚如何让这个令牌URI返回这个JSON的64进制编码版本。

16779
23:04:22.047 --> 23:04:28.151
首先，我们知道如何连接一个字符串，这是我们要做的第一件事。

16780
23:04:28.151 --> 23:04:30.000
我们会用API。和代码打包。

16781
23:04:30.000 --> 23:04:35.102
我们将在chain上编码JSON，这里我们将使用单引号，

16782
23:04:35.102 --> 23:04:42.392
因为在这个API和代码包中，我们将在这里使用双引号这是我们将添加JSON的地方。

16783
23:04:42.392 --> 23:04:47.563
我们会给出一个名字，第一个元数据需要是一个名字。

16784
23:04:47.563 --> 23:04:49.417
我们给它起个名字。

16785
23:04:49.417 --> 23:04:51.559
我们在这里加个逗号。

16786
23:04:51.559 --> 23:05:00.030
我们会说这个NF T的名字是我们得到的名字，我们有一个名字函数，它会返回这个名字。

16787
23:05:00.030 --> 23:05:02.071
所以我们会说名字就是名字。

16788
23:05:02.071 --> 23:05:05.145
我们要把这些东西连起来，名字就在这里。

16789
23:05:05.145 --> 23:05:07.417
我们将继续讨论JSON。

16790
23:05:07.417 --> 23:05:11.022
这里加个引号，这里也加个引号。

16791
23:05:11.022 --> 23:05:16.483
我们把这个名字封装在引号里，对吧?因为记住，我们是在连接，我们在这里做的这个

16792
23:05:16.483 --> 23:05:22.088
大字符串，我们会用逗号，我们会说，description，我们会用另一个引号。

16793
23:05:22.088 --> 23:05:28.778
这一次，我们会把描述自己放进去，我们会说，NFT，基于

16794
23:05:28.778 --> 23:05:35.716
链链接提要的变化，我们会在这里放一个结束引号和一个逗号，

16795
23:05:35.716 --> 23:05:42.655
我们会在引号外面放一个逗号，在下面这里，我们会说，属性。

16796
23:05:42.830 --> 23:05:47.289
我们会说，特质

16797
23:05:47.289 --> 23:05:52.387
类型，应该是酷。

16798
23:05:53.830 --> 23:05:55.480
价值，我是100。

16799
23:05:55.480 --> 23:05:58.781
砰，到一个逗号的图像。

16800
23:06:01.830 --> 23:06:02.110
在这里。

16801
23:06:05.830 --> 23:06:08.636
image URI，我们需要从某处获取。

16802
23:06:08.830 --> 23:06:12.718
现在，我要说的是string。

16803
23:06:12.830 --> 23:06:17.263
内存图像URI等于i，对吧，这显然不是到达的图像。

16804
23:06:17.263 --> 23:06:19.846
但是为了形成这种格式，我们把它放在这里。

16805
23:06:19.846 --> 23:06:25.414
这是我们把从SVG得到的图像URI放入图像URI的地方。

16806
23:06:25.414 --> 23:06:26.989
就这样了。

16807
23:06:26.989 --> 23:06:29.766
我的意思是关闭JSON。

16808
23:06:29.766 --> 23:06:34.210
做ABI。encode pack会把这些连在一起。

16809
23:06:34.210 --> 23:06:37.259
这基本上就是一个像这样的字符串。

16810
23:06:37.259 --> 23:06:37.544
太好了。

16811
23:06:37.544 --> 23:06:42.072
但是我们怎么把它变成一个64进制编码的令牌让其

16812
23:06:42.072 --> 23:06:46.798
他人可以读它呢?我们要把整个东西类型转换成字节。

16813
23:06:46.798 --> 23:06:54.363
现在这一切都是以字节为单位的，我们就可以像上面的SVG那样进行64进制编码了。

16814
23:06:54.363 --> 23:06:56.943
我们用64进制。ENCODE。

16815
23:06:56.943 --> 23:07:01.749
然后我们在这个保存并自动格式化旁边再加一对括号。

16816
23:07:01.749 --> 23:07:10.584
这里会给我们第二行，对吧，它会给我们这所有的位，但不会给我们第一个位，对吧。

16817
23:07:10.584 --> 23:07:12.847
我们现在只需要把第一点加进去。

16818
23:07:12.847 --> 23:07:14.201
我们应该可以出发了。

16819
23:07:14.201 --> 23:07:20.499
数据图像SVG之前的基础知识加上XML基础知识，这是图像SVG

16820
23:07:20.499 --> 23:07:26.798
图像的前缀，对吧?我们在上面使用它是因为它是SVG图像的前缀。

16821
23:07:26.798 --> 23:07:28.003
64进制的前缀。

16822
23:07:28.003 --> 23:07:33.581
Jason将会是数据应用JSON，以64为基数。

16823
23:07:33.581 --> 23:07:36.206
所以我们要这样做。

16824
23:07:36.206 --> 23:07:42.492
ERC 721有一个叫做基URI的东西我们会重写它我们会使用它。

16825
23:07:42.492 --> 23:07:45.468
我们说，function，下划线，base URI。

16826
23:07:45.468 --> 23:07:47.795
这是内纯的。

16827
23:07:47.795 --> 23:07:50.896
我们要推翻ERC 721的决定。

16828
23:07:50.896 --> 23:07:54.307
这将返回一个字符串内存。

16829
23:07:54.307 --> 23:07:58.997
我们将返回这里的这一点。

16830
23:07:58.997 --> 23:08:01.747
现在我们可以使用这个基URI。

16831
23:08:01.747 --> 23:08:07.848
我们要把第一部分附加到64编码的JSON中。

16832
23:08:07.848 --> 23:08:15.110
为了追加它们，我们再次写入ABI。ENCODE, wrapped。

16833
23:08:15.110 --> 23:08:19.569
然后把这个写下来。

16834
23:08:19.832 --> 23:08:25.170
我们会说，我们会把基URI连接到我们刚创建的这个庞大的东西。

16835
23:08:25.170 --> 23:08:31.181
然后我们保存，我们应该格式化这显然是一个字节对象，我们希望它是一个字符串。

16836
23:08:31.181 --> 23:08:39.660
然后我们要做的是将它类型转换为字符串，但另一个打印看到下面这里，然后我们实际上只返回这个，但

16837
23:08:39.660 --> 23:08:48.139
基本上我们所做的是创建一个JSON字符串，我们用字节编码它，这样我们就可以用64进制编码它。

16838
23:08:48.139 --> 23:08:53.182
一旦我们用64进制编码，就像第二个字符串，

16839
23:08:53.182 --> 23:08:58.225
就像这里，然后我们只需要附加这个初始部分。

16840
23:08:58.225 --> 23:09:03.044
但对于JSON对象，它是数据应用程序JSON。

16841
23:09:03.044 --> 23:09:09.882
我们添加API。encode packed，然后将它转换为字符串，然后我们就有了一个令牌URI。

16842
23:09:09.882 --> 23:09:11.454
就像这样。

16843
23:09:11.454 --> 23:09:19.635
然后我们要做的就是更新我们的图像URI用我们从函数appear中得到的东西，然后我们就可以开始了。

16844
23:09:19.635 --> 23:09:23.323
我们把这个做完。

16845
23:09:23.323 --> 23:09:25.388
让我们开始吧。

16846
23:09:25.832 --> 23:09:29.979
在构造函数中，我们传递了一个低SVG和一个高SVG。

16847
23:09:29.979 --> 23:09:34.671
这些低SVG是什么，在这些高SVG中也是什么，

16848
23:09:34.671 --> 23:09:39.159
基本上是说，当资产的价格太低时，表现出不满。

16849
23:09:39.159 --> 23:09:43.098
当资产价格高的时候，露出笑脸。

16850
23:09:43.098 --> 23:09:51.483
我们将给它这个皱眉，SVG和这个快乐SVG作为输入参数，低CG和高SVG，我们可能想要保存它们。

16851
23:09:51.483 --> 23:09:55.306
但我们不一定要以SVG格式保存它们。

16852
23:09:55.306 --> 23:10:02.445
我们只需要存储图像URI，我们只需要存储上面这个字符串而不是实际的SVG。

16853
23:10:02.445 --> 23:10:09.808
在构造函数中，我们可以I _ low image URI =，

16854
23:10:09.808 --> 23:10:17.409
我们有这个SVG来成像你的眼睛函数，我们可以传递low SVG。

16855
23:10:17.409 --> 23:10:22.095
然后我们可以对高图像URI做同样的事情。

16856
23:10:22.095 --> 23:10:26.770
现在，SVG imageuri将返回像这样的东西。

16857
23:10:26.833 --> 23:10:31.155
我们将只存储这个字符串这个图像URI在chain上。

16858
23:10:31.155 --> 23:10:35.110
现在我们有了这两个，我们可以在下面使用它。

16859
23:10:35.110 --> 23:10:40.930
在我们的token Uri函数中，当有人调用token时，你的I

16860
23:10:40.930 --> 23:10:46.751
有令牌ID为0，我们会插入到JSON中，低图像或I或高图像到达。

16861
23:10:46.833 --> 23:10:49.196
而我们实际上是基于价格供给的。

16862
23:10:49.196 --> 23:10:55.062
我们怎么做呢?好吧，我们之前已经使用过价格传输，所以让我们继续并添加它。

16863
23:10:55.062 --> 23:10:58.236
所以纱加破折号开发在链条斜杠合同。

16864
23:10:58.236 --> 23:11:02.868
在顶部完成之后，我们可以import at

16865
23:11:02.868 --> 23:11:07.942
chain link / SRC / v0。

16866
23:11:07.942 --> 23:11:16.478
8、斜杠接口，斜杠ag reg gate, Tor V三个接口，那灵魂就像这样。

16867
23:11:16.478 --> 23:11:20.639
然后下面这里，把它注释掉。

16868
23:11:20.833 --> 23:11:27.352
现在，我们想调用一个价格提要来找出价格然后根据这个显示高的图像或低的图像。

16869
23:11:27.352 --> 23:11:32.963
为了在构造函数中获得价格提要，我们添加另一个价格提要地址，街道地址。

16870
23:11:32.963 --> 23:11:35.946
然后我们再设一个变量。

16871
23:11:35.946 --> 23:11:40.994
我们会聚合Tor v3接口。

16872
23:11:40.994 --> 23:11:46.146
内部的，不可变的，我强调价格供给。

16873
23:11:46.146 --> 23:11:51.723
我们会在构造函数中说，I price feed =聚

16874
23:11:51.723 --> 23:11:57.300
合Tor v3接口，在price feed，地址处。

16875
23:11:57.300 --> 23:12:02.958
然后我们可以在这里做的是，这里的一堆逗号变成256

16876
23:12:02.958 --> 23:12:09.749
Price，逗号，逗号= i Price提供最新一轮数据。

16877
23:12:09.749 --> 23:12:15.778
我们能做的是我们可以说如果价格大于或等于某

16878
23:12:15.778 --> 23:12:22.096
个值，那么显示一个图像干，否则，显示另一个。

16879
23:12:22.096 --> 23:12:30.199
所以我们可以说字符串内存，图像URI等于s下划线low图像URI。

16880
23:12:30.199 --> 23:12:34.610
然后如果价格高于某个值，大于我们将要使

16881
23:12:34.610 --> 23:12:39.255
用的图像URI AI将等于高图像URI。

16882
23:12:39.255 --> 23:12:41.884
下面这里是图像。

16883
23:12:41.884 --> 23:12:44.161
我们要做的就是算出价格。

16884
23:12:44.161 --> 23:12:51.990
所以我们可以，我们会让导师选择他们想要使用的价值。

16885
23:12:51.990 --> 23:12:58.562
所以我们可以说，在256中，I值我们会给每个非ft赋值，它们自己的高值。

16886
23:12:58.562 --> 23:13:06.047
我们需要在上面创建一个小映射，我们说，映射，你到56。

16887
23:13:06.047 --> 23:13:08.342
第二，你去了56。

16888
23:13:08.342 --> 23:13:12.569
让我们把它设为public public

16889
23:13:12.569 --> 23:13:17.431
s的下划线令牌ID设为high value。

16890
23:13:17.431 --> 23:13:22.067
我们会说，当他们说nft会做s token ID to

16891
23:13:22.067 --> 23:13:27.390
high value, s下划线token counter。

16892
23:13:27.390 --> 23:13:30.167
我们设它等于高值。

16893
23:13:30.167 --> 23:13:33.851
所以当他们选择他们想要的高值时。

16894
23:13:33.851 --> 23:13:42.763
然后在下面这里，如果价格大于或等于令牌ID的高值，那么我们就使用高值的那个。

16895
23:13:42.835 --> 23:13:44.028
否则，我们就用低的那个。

16896
23:13:44.835 --> 23:13:47.496
把你变成视频x 2变成256。

16897
23:13:49.835 --> 23:13:52.286
能够相当平等地比较它们。

16898
23:13:53.835 --> 23:13:54.657
看起来不错。

16899
23:13:56.835 --> 23:13:57.869
可能是一个事件。

16900
23:13:59.835 --> 23:14:03.597
我们遇到了其中一个NF T。

16901
23:14:05.835 --> 23:14:12.235
创建NF T，会说你去了56索引token ID, int 256。

16902
23:14:12.235 --> 23:14:14.368
我认为是这样的。

16903
23:14:14.368 --> 23:14:19.848
然后当我们遇到这个非ft时，会做emit create

16904
23:14:19.848 --> 23:14:25.735
nt, s下划线token counter，逗号，I值。

16905
23:14:25.835 --> 23:14:31.157
最好的做法是在造币之前更新令牌计数器。

16906
23:14:31.157 --> 23:14:32.106
我们也会做这个。

16907
23:14:32.106 --> 23:14:34.343
这里有很多代码。

16908
23:14:34.343 --> 23:14:39.342
就像我说的，我们肯定不会在没有编译运行一些测

16909
23:14:39.342 --> 23:14:44.569
试的情况下写所有的代码，但我们决定先把它写好。

16910
23:14:44.569 --> 23:14:46.436
所以我犯了一些拼写错误。

16911
23:14:46.436 --> 23:14:48.736
让我们确保所有东西都编译好了。

16912
23:14:48.836 --> 23:14:49.073
太棒了。

16913
23:14:49.073 --> 23:14:49.988
所有的东西都在这里。

16914
23:14:50.836 --> 23:14:53.787
我们需要做几件事来验证这一点。

16915
23:14:53.836 --> 23:14:58.707
我们需要做的第一件事是写部署函数，我们有基本的NFT，

16916
23:14:58.707 --> 23:15:03.398
我们有random和ft，这两个都托管在IPFS上。

16917
23:15:03.398 --> 23:15:08.582
现在我们要做一个100%托管在链上的

16918
23:15:08.582 --> 23:15:13.767
动态非ft，它会根据资产的价格变化。

16919
23:15:13.767 --> 23:15:17.870
我们来做这个。

16920
23:15:17.870 --> 23:15:26.012
哦，第三个，动态部署，SVG nft。

16921
23:15:26.012 --> 23:15:26.129
js。

16922
23:15:26.129 --> 23:15:29.545
我们不，我们需要一些样板文件。

16923
23:15:29.545 --> 23:15:31.415
让我们来看看基本的非ft。

16924
23:15:31.415 --> 23:15:35.196
我们来看看前七行。

16925
23:15:35.196 --> 23:15:37.224
我们把它粘贴到这里。

16926
23:15:37.224 --> 23:15:44.042
构造函数需要什么?我们需要一个价格提要地址，一个低SVG和一个最高CG。

16927
23:15:44.042 --> 23:15:45.867
好了，我们把这些都拿出来。

16928
23:15:45.867 --> 23:15:48.853
价格提要地址我们之前做过。

16929
23:15:48.853 --> 23:15:51.836
我们可以把它添加到我们的助手Hardhead配置中。

16930
23:15:51.836 --> 23:15:56.986
我们会做一个和一个foreign local，我们会用我们会用的一个mock。

16931
23:15:56.986 --> 23:16:00.302
如果我们在林克比，或者一个实际的网络上，我们就会使用一个实际的地址。

16932
23:16:00.302 --> 23:16:07.066
让我们继续到黑暗面链，链接会抓取一个价格feed地址，M Aetherium。

16933
23:16:07.066 --> 23:16:13.142
数据提要将进入排名B，排名B，让我们使用每一个美元

16934
23:16:13.142 --> 23:16:19.463
拷贝，它将像这样创建一个新的条目每一个美元价格提要。

16935
23:16:19.463 --> 23:16:22.153
对于localhost，没问题。

16936
23:16:22.153 --> 23:16:24.649
因为我们知道对于localhost，我们需要做一个模拟。

16937
23:16:24.649 --> 23:16:27.293
让我们看看是否有价格供给模拟。

16938
23:16:27.293 --> 23:16:31.646
现在我们不需要了，我们需要一个模拟v3 aggregator。soul。

16939
23:16:31.646 --> 23:16:32.949
我只是复制粘贴了我的。

16940
23:16:32.949 --> 23:16:36.037
如果你愿意，你可以直接去这里的回购。

16941
23:16:36.037 --> 23:16:41.553
或者你可以从前一节复制，只是提醒心脏在f和f t

16942
23:16:41.553 --> 23:16:47.989
FCC合同问moc v3聚合器，这是使用固体的06点。

16943
23:16:47.989 --> 23:16:53.043
我们要确保在hardhat。config中，至少有一个0。

16944
23:16:53.043 --> 23:16:55.709
6版本，我们做的很好。

16945
23:16:55.837 --> 23:17:04.792
这意味着在我们的部署模拟中，

16946
23:17:04.792 --> 23:17:12.467
我们想要添加，初始价格将

16947
23:17:12.467 --> 23:17:21.423
2000小数将是一个团队。

16948
23:17:21.423 --> 23:17:24.087
因此，现在我们一直在等待为该价格提要部署模拟。

16949
23:17:24.087 --> 23:17:31.835
因此我们写入const chain ID = network。config。chain ID

16950
23:17:31.835 --> 23:17:38.572
do if development chains。包含network。name，

16951
23:17:38.572 --> 23:17:46.657
我们越需要导入development chains看起来就像我们所说的const eth USD

16952
23:17:46.657 --> 23:17:55.416
akregator =我们将得到price feed = waitethers。get contract

16953
23:17:55.416 --> 23:18:04.006
Mark v3 Air gate tour，然后我们会在上面这里我们会让eusd价格提要地址eusd价

16954
23:18:04.006 --> 23:18:12.599
sd价格提要地址等于eusd总地址那个地址否则就会说eusd价格提要地址将等于我们在网络配置中找到的。

16955
23:18:12.599 --> 23:18:14.503
网络配置。

16956
23:18:14.503 --> 23:18:17.931
链ID点eth美元价格。

16957
23:18:17.931 --> 23:18:22.549
好的，我们有了第eth美元价格供给率。

16958
23:18:22.549 --> 23:18:25.870
现在我们需要最低的VG和最高的SVG。

16959
23:18:25.870 --> 23:18:30.380
我们要在images文件夹中创建一个新文件夹。

16960
23:18:30.380 --> 23:18:35.125
CD图像，mkdir动态NF t。

16961
23:18:35.125 --> 23:18:40.647
这里我们有两个文件夹dynamic，一个是空的，一个是随机的，里面有所有随机的东西。

16962
23:18:40.647 --> 23:18:43.893
如果你想使用你自己的svg，你完全可以这么做。

16963
23:18:43.893 --> 23:18:50.991
但是如果你想打开我的图像文件然后将这些图像保存为右键点击save image as。

16964
23:18:50.991 --> 23:18:51.606
拯救他们。

16965
23:18:51.606 --> 23:18:55.231
然后拖放到你的图片文件里，你完全可以这么做。

16966
23:18:55.231 --> 23:19:03.041
现在我们有了这些，我们想继续把它们读入我们的脚本。

16967
23:19:03.041 --> 23:19:06.504
我们说const, low SVG等于一个权重。

16968
23:19:06.504 --> 23:19:09.170
我们将再次使用f。

16969
23:19:09.170 --> 23:19:15.825
我们写入const Fs = require Fs，或者await Fs。

16970
23:19:15.825 --> 23:19:22.120
read file sync，我们将读取这个文件，对我来说，它是at。

16971
23:19:22.120 --> 23:19:28.596
images / dynamic NF T / brown。SVG。

16972
23:19:28.596 --> 23:19:32.450
我们使用utf8编码。

16973
23:19:32.450 --> 23:19:34.869
然后我们说const。

16974
23:19:34.869 --> 23:19:39.355
嗨，SVG = await Fs。read file sync。

16975
23:19:39.355 --> 23:19:43.597
复制整个式子，因为我们用的是一样的东西。

16976
23:19:43.597 --> 23:19:46.089
这个人对SVG很满意。

16977
23:19:46.089 --> 23:19:47.255
就是这样。

16978
23:19:47.255 --> 23:19:53.275
价格好时，我们会用SVG表示幸福，价格不好时，我们会用SVG表示不满。

16979
23:19:53.275 --> 23:19:55.484
现在，让我们继续，部署这个契约。

16980
23:19:55.484 --> 23:20:04.454
我们说arguments或args =，这是价格提要地址，low SVG，然后high SVG。

16981
23:20:04.454 --> 23:20:11.941
我们写入const dynamic S G F T等于await,

16982
23:20:11.941 --> 23:20:21.699
deploy dynamic SVG和F T，这里逗号小括号，来自Deployer。

16983
23:20:21.839 --> 23:20:24.553
Args, Args log true。

16984
23:20:29.839 --> 23:20:37.288
将是network。config，那将阻止确认，

16985
23:20:37.288 --> 23:20:44.117
或者有人会做一些日志，我将做log来做这个。

16986
23:20:44.117 --> 23:20:52.068
Larry，你来验证一下，我将从上一个脚本中复制粘贴这个，因为这将是完全相同的复制粘贴。

16987
23:20:52.068 --> 23:20:57.008
但不是随机IPFS，而是动态SVG和f t。

16988
23:20:57.008 --> 23:20:58.731
其余部分看起来不错。

16989
23:20:58.731 --> 23:21:00.666
这就差不多了。

16990
23:21:00.666 --> 23:21:09.461
我们会写module, exports。tags =我们都是动态的。

16991
23:21:09.461 --> 23:21:09.985
SVG。

16992
23:21:09.985 --> 23:21:12.345
我们来做main。

16993
23:21:12.345 --> 23:21:13.525
哦,好的。

16994
23:21:13.525 --> 23:21:19.516
让我们试着看看刚刚创建的部署脚本是否有效。

16995
23:21:19.516 --> 23:21:23.800
要做h h，或yarn hardhat部署的破折号标签，

16996
23:21:23.800 --> 23:21:28.697
die Namic SVG，这是有意义的，因为我们没有部署模拟。

16997
23:21:28.697 --> 23:21:31.128
我们会做标签，动态svg。

16998
23:21:31.128 --> 23:21:33.161
然后是嘲笑。

16999
23:21:33.161 --> 23:21:39.743
本地网络检测到游戏标记，我们部署标记，部署动态SVG，太棒了。

17000
23:21:39.743 --> 23:21:48.340
你知道接下来会发生什么吗?天啊，太对了，是时候做些检查了。

17001
23:21:48.340 --> 23:21:53.331
现在，我再一次鼓励你们暂停视频试着为这个测

17002
23:21:53.331 --> 23:21:58.323
试写一个自己的测试这一节实际上会有点棘手。

17003
23:21:58.323 --> 23:22:05.373
因为我们要操纵模拟聚合器的价格，所以我们要检查这些长字符串等等。

17004
23:22:05.373 --> 23:22:10.772
所以一定要使用与这节课相关的GitHub存储库，以防你迷失方向。

17005
23:22:10.772 --> 23:22:18.036
现在，我想向你们展示这在市场上是什么样子的，比如OpenCL。

17006
23:22:18.036 --> 23:22:21.033
所以我们要把这个布置到B溜冰场。

17007
23:22:21.033 --> 23:22:23.219
记住，测试可能很慢。

17008
23:22:23.219 --> 23:22:24.494
所以你最好耐心点。

17009
23:22:24.494 --> 23:22:26.949
如果你不想，你甚至可以不做。

17010
23:22:26.949 --> 23:22:28.390
但还是很高兴看到的。

17011
23:22:28.390 --> 23:22:30.340
好吧，这才是真正的样子。

17012
23:22:30.340 --> 23:22:33.220
你可以去链上的合同，一旦它被验证。

17013
23:22:33.220 --> 23:22:35.040
你可以读取令牌URI等等。

17014
23:22:35.040 --> 23:22:35.767
这很有趣。

17015
23:22:35.840 --> 23:22:39.952
让我们再往deploy文件夹中添加一位。

17016
23:22:40.840 --> 23:22:44.430
一个薄荷脚本，它为每个合约发出一个NF T。

17017
23:22:44.430 --> 23:22:46.856
我们要为mint创建no。

17018
23:22:46.856 --> 23:22:46.987
js。

17019
23:22:46.987 --> 23:22:52.275
我们要让每一份合同都成为非功能性的。

17020
23:22:52.275 --> 23:22:54.658
我们来做这个。

17021
23:22:54.658 --> 23:23:00.840
在这里，我们写const ethers network = require arhat。

17022
23:23:00.840 --> 23:23:04.808
然后我要做一点复制粘贴。

17023
23:23:04.808 --> 23:23:08.774
我要复制这部分因为我知道我需要它。

17024
23:23:08.774 --> 23:23:12.660
我们需要部署，但我们不需要部署。

17025
23:23:12.660 --> 23:23:17.095
我将抓取记名账户，它将从这里开始。

17026
23:23:17.095 --> 23:23:18.213
我们有一个部署者。

17027
23:23:18.213 --> 23:23:20.691
我们的部署人员只是用来制造它们的。

17028
23:23:20.691 --> 23:23:22.291
首先我们制造基本的NF t。

17029
23:23:22.291 --> 23:23:27.137
因此我们写入const basic NF t = wait ethers。

17030
23:23:27.137 --> 23:23:31.983
get contract, basic N ft，我们将把部署器连接到它。

17031
23:23:31.983 --> 23:23:36.286
然后我们说const basic mint如果T或basic

17032
23:23:36.286 --> 23:23:41.737
mint, TX等于await basic NF T。mint NF T。

17033
23:23:41.737 --> 23:23:47.820
然后我们会做一个weight basic mint TX。weight

17034
23:23:47.820 --> 23:23:54.077
1然后我们会做一个console。logbase同样，tindex 0有

17035
23:23:54.077 --> 23:24:00.856
令牌URI，我们会放入一个await basic NF T。令牌URI 0。

17036
23:24:00.856 --> 23:24:03.541
这就是基本实体的内容。

17037
23:24:03.541 --> 23:24:08.091
现在我们将随机执行IPFS并为空。

17038
23:24:08.091 --> 23:24:14.114
因此我们写入const, random IPFS NF t = await

17039
23:24:14.114 --> 23:24:21.441
ethers。get contract, random IPFS和f t，连接到部署器。

17040
23:24:21.441 --> 23:24:23.912
这个案子，我们需要一大笔钱。

17041
23:24:23.912 --> 23:24:29.502
我们写入const, mint V = await random IPFS NF T。get mint fee。

17042
23:24:29.502 --> 23:24:31.679
然后我们再做薄荷。

17043
23:24:31.841 --> 23:24:36.362
我们会说const, random IPFS和ft mint,

17044
23:24:36.362 --> 23:24:42.779
TX等于await, random IPFS和ftdot request和fteam。

17045
23:24:42.779 --> 23:24:47.681
对于这个，我们需要传递一个值，它将是薄荷v。

17046
23:24:47.681 --> 23:24:48.432
字符串。

17047
23:24:48.432 --> 23:24:55.916
对于这个，就像我们在测试中看到的一样，我们需要再次执行await new

17048
23:24:55.916 --> 23:25:04.648
promise，因为我们需要等待它返回需要监听那些事件，我们可能应该先设置监听器。

17049
23:25:04.648 --> 23:25:06.270
让我们先设置监听器。

17050
23:25:06.270 --> 23:25:11.757
我们要写await new promise，我们要写async function。

17051
23:25:11.842 --> 23:25:14.745
我们要做的是解析拒绝。

17052
23:25:16.842 --> 23:25:19.772
这里有趣的小箭头语法。

17053
23:25:19.842 --> 23:25:27.902
既然我们在这个函数中，我们就像这样设置超时解析，这意味着我们有5分钟的时间让

17054
23:25:27.902 --> 23:25:36.175
它暂停，你可能想把它再放大一点5分钟可能不够，这里是300毫秒，我们再做一次。

17055
23:25:36.175 --> 23:25:39.252
我们说随机IPFS和ft导。

17056
23:25:39.252 --> 23:25:46.719
一旦我们得到那个非ft mintedevent，我们会运行一个async函数，我们会做resolve。

17057
23:25:46.719 --> 23:25:53.334
这里面是我们可以放的地方，实际上是请求非ft。

17058
23:25:53.334 --> 23:25:58.427
但在listener下面，对吧，在这里，然后我们可以说if

17059
23:25:58.427 --> 23:26:04.925
developments chains，这包括network。name。

17060
23:26:04.925 --> 23:26:13.632
我们要确保导入这些开发链和网络或影响它们和包含network。name的链。

17061
23:26:13.632 --> 23:26:17.648
我们在一个测试网上，这是我们前进的地方，我们假装是那些模拟动物。

17062
23:26:17.648 --> 23:26:21.442
我们写入const Request ID = random IPFS。

17063
23:26:21.442 --> 23:26:26.380
哦，实际上，我们需要const random IPFS和ft min TX

17064
23:26:26.380 --> 23:26:33.053
receipt = await on IPFS和empty minted TX。weight 1。

17065
23:26:33.053 --> 23:26:35.789
所以我们得拿到收据。

17066
23:26:35.789 --> 23:26:39.499
从收据中，我们可以得到请求ID。

17067
23:26:39.499 --> 23:26:43.112
那个事件。args。request id。

17068
23:26:43.112 --> 23:26:44.254
字符串。

17069
23:26:44.254 --> 23:26:47.936
然后我们可以做const VRF。

17070
23:26:47.936 --> 23:26:54.179
协调器V要模拟等于等待醚点得到契约，

17071
23:26:54.179 --> 23:27:00.770
V要模拟的射频坐标，将其连接到部署器。

17072
23:27:00.843 --> 23:27:06.421
然后我们会做一个等待RF编码和一个Tor V

17073
23:27:06.421 --> 23:27:12.000
来模拟满足随机单词的请求ID，随机IPFS。

17074
23:27:12.000 --> 23:27:18.883
如果T。address，我们可以做console。log

17075
23:27:18.883 --> 23:27:26.504
random IPFS让T索引为0令牌URI来等待随机IP。

17076
23:27:26.504 --> 23:27:31.218
那是nft导令牌URI (0)

17077
23:27:31.218 --> 23:27:36.343
最后，我们可以进行动态SVG (NF t)。

17078
23:27:36.343 --> 23:27:42.206
所以我们可以说const high high value =醚。

17079
23:27:42.206 --> 23:27:42.751
跑龙套。

17080
23:27:42.751 --> 23:27:44.786
在这里解析以太。

17081
23:27:44.786 --> 23:27:49.398
所以我们设4000美元4000美元是最高的值。

17082
23:27:49.398 --> 23:27:51.175
我们用const。

17083
23:27:51.175 --> 23:27:57.892
动态SVG和ft等于await醚。get契约，动态的。

17084
23:27:57.892 --> 23:28:05.135
SVG和一个T会把它连接到部署器比如const由Namic, s,

17085
23:28:05.135 --> 23:28:12.597
B, G和ftmint, TX等于await dynamic SVG

17086
23:28:12.597 --> 23:28:20.719
和ft。mint和fti value to string然后我们就等待。

17087
23:28:20.719 --> 23:28:23.094
这个数据等一等。

17088
23:28:23.094 --> 23:28:27.674
最后是console。log dynamic。

17089
23:28:27.674 --> 23:28:36.602
SVG非函数索引0令牌URI将是一个权重动态。

17090
23:28:36.602 --> 23:28:41.392
SVG和ft点令牌URI为零。

17091
23:28:41.392 --> 23:28:43.544
好的，我觉得看起来不错。

17092
23:28:43.544 --> 23:28:44.677
让我们在本地网络上试试。

17093
23:28:44.677 --> 23:28:48.118
所以我们要做纱线硬帽部署。

17094
23:28:48.118 --> 23:28:53.876
我们会运行所有的脚本，看起来一切正常。

17095
23:28:53.876 --> 23:29:01.360
所以我们有随机的，基本的非ft指数0有一个代币年，我有这个IPFS，随机的IPFS非ft。

17096
23:29:01.360 --> 23:29:03.037
索引0有这个。

17097
23:29:03.037 --> 23:29:06.621
然后我们的SVG有这个巨大的怪物，很好。

17098
23:29:06.621 --> 23:29:13.344
然后我们甚至可以检查，我们甚至可以抓取这个IPFS散列，我们到我们的IPFS节点，或者如果你在

17099
23:29:13.344 --> 23:29:20.212
浏览器中安装了IPFS，或者你使用Brave，我们可以直接把它弹出到浏览器中，看看它是什么样子。

17100
23:29:20.212 --> 23:29:20.527
正确的。

17101
23:29:20.527 --> 23:29:22.844
如果我放大，可爱的圣。

17102
23:29:22.844 --> 23:29:25.110
伯纳德，画着圣。

17103
23:29:25.110 --> 23:29:27.377
伯纳德，像这样，这也是圣。

17104
23:29:27.377 --> 23:29:27.643
伯纳德。

17105
23:29:27.643 --> 23:29:33.219
当然，还有SVG，我们也可以复制粘贴，看起来很棒。

17106
23:29:33.219 --> 23:29:35.156
然后我们可以复制图像。

17107
23:29:35.156 --> 23:29:37.317
它是一个皱眉的脸或阴脸。

17108
23:29:37.317 --> 23:29:38.159
但是太棒了。

17109
23:29:38.159 --> 23:29:40.762
好吧，它在本地为我们工作。

17110
23:29:40.762 --> 23:29:45.344
现在，让我们继续，试着在一个实际的测试网上工作。

17111
23:29:45.344 --> 23:29:49.145
所以，希望我们的助手硬帽配置设置正确。

17112
23:29:49.145 --> 23:29:56.980
这里有足够的东西我们需要确保我们有订阅ID，我们需要确保我们有订阅ID。

17113
23:29:56.980 --> 23:30:03.304
我们不应该调用mint函数，因为我们需要将消费者添加到VRF。

17114
23:30:03.304 --> 23:30:08.120
在我们真正理解之前我给我们的意思加上一些标签。

17115
23:30:08.120 --> 23:30:13.626
我们会写module。exports。tags =，

17116
23:30:13.626 --> 23:30:18.921
我们会说all，之前我说过，让我们添加一个主标签。

17117
23:30:18.921 --> 23:30:23.232
现在我们来看看为什么要在这里添加这个主标签。

17118
23:30:23.232 --> 23:30:26.688
所以我们想要做的是部署所有这些契约。

17119
23:30:26.688 --> 23:30:34.742
但在我们最终打算使用IPFS之前，我们需要将合同添加到我们的消费者，我们要做的是，我们要运行yarn,

17120
23:30:34.742 --> 23:30:42.796
Hardhead，部署dash dash网络Rinkeby dash dash tags main。

17121
23:30:42.796 --> 23:30:48.234
现在，这并不意味着我们的任何NF T，好吧，这并不意味着我们的任

17122
23:30:48.234 --> 23:30:53.673
何NF T，它只是部署那些契约可能只是坐在那里等待这些真正部署。

17123
23:30:53.673 --> 23:30:59.202
所以这是休息的好时机，可以去散步，喝点水，喝杯咖啡，做任何你想做的事。

17124
23:30:59.202 --> 23:31:06.779
部署完毕后，我们可以到V或F。chain。link，这里已经连接了，我们用了订阅。

17125
23:31:06.845 --> 23:31:11.038
然后我们把IPFS消费者加进来。

17126
23:31:11.845 --> 23:31:12.285
好好去吧。

17127
23:31:13.845 --> 23:31:20.829
区块链上有三个交易，我们可以获取随机IPFS NF T，获

17128
23:31:20.829 --> 23:31:27.813
取地址，然后回到V或F。chain。link / rink

17129
23:31:27.813 --> 23:31:34.797
D，找到订阅ID，然后添加一个新的消费者，添加合约地址。

17130
23:31:34.797 --> 23:31:37.297
所以我们会批准超掩模。

17131
23:31:37.297 --> 23:31:42.158
一旦完成了这些操作，我们就可以完成运行deploy文件夹的mint部分。

17132
23:31:42.158 --> 23:31:49.384
确认后，我们可以关闭也许可以稍微刷新一下，我们应该能看到新地址被添加为订阅。

17133
23:31:49.384 --> 23:31:54.770
现在我们已经添加了，我们可以从每个戴着安全帽的合同中创造一

17134
23:31:54.770 --> 23:32:00.157
个NF T，部署破折号标签意味着破折号网络Rinkeby。

17135
23:32:00.157 --> 23:32:03.338
这个我们也得等一会儿。

17136
23:32:03.338 --> 23:32:08.354
好了，现在我们已经把它们都铸造好了，我们应该得到像这样的输出。

17137
23:32:08.354 --> 23:32:11.168
对吧?基本NF t0在这里有令牌URI。

17138
23:32:11.168 --> 23:32:14.958
基本随机IPFS NF T标记了你的眼睛。

17139
23:32:14.958 --> 23:32:18.535
然后我们的SVG用这个作为令牌年。

17140
23:32:18.535 --> 23:32:26.670
那么我们现在能做什么呢?让我去拿我的钱包地址然后把它放进瑞克比以太扫描。

17141
23:32:26.670 --> 23:32:30.620
我们再次调用了mint request和mint。

17142
23:32:30.620 --> 23:32:38.439
我们创建了三种契约，我们创建了基本的非ft，随机IPFS非ft和动态SVG非ft。

17143
23:32:38.439 --> 23:32:44.354
我们现在能做的是，我们可以复制合同的地址。

17144
23:32:44.354 --> 23:32:49.245
我们可以去测试网络打开，看到那个i，哦，我

17145
23:32:49.245 --> 23:32:54.136
们可以把那个地址放在这里的栏里在搜索栏里。

17146
23:32:54.136 --> 23:32:57.699
这部分变化非常大。

17147
23:32:57.846 --> 23:32:59.753
好吧，open C是非常慢的。

17148
23:33:01.846 --> 23:33:06.373
注册合同部署到测试网需要几个小时。

17149
23:33:06.373 --> 23:33:09.397
所以如果它没有马上出现，也不要气馁。

17150
23:33:09.397 --> 23:33:10.747
不要让它拖累你。

17151
23:33:10.747 --> 23:33:16.659
但如果是这样，您应该可以单击您的集合，并看到NFT实际上在这里。

17152
23:33:16.659 --> 23:33:19.034
我将随机取IPFS NFT。

17153
23:33:19.034 --> 23:33:21.159
我们去拿那个合同地址。

17154
23:33:21.159 --> 23:33:23.915
我要抓取那个测试网站打开c。

17155
23:33:23.915 --> 23:33:24.052
io。

17156
23:33:24.052 --> 23:33:25.983
把那个地址粘贴进去。

17157
23:33:25.983 --> 23:33:33.535
你知道我们确实看到了什么，随机IPFS和f t，对，我已经部署了一些。

17158
23:33:33.535 --> 23:33:36.925
这是v2，我们可爱的湿婆就在你体内。

17159
23:33:36.925 --> 23:33:44.597
这就是它在open C中看起来的样子，现在我们可以100%验证我们的代码是好的，即使它没有在open中显示出来。

17160
23:33:44.597 --> 23:33:44.797
看到的。

17161
23:33:44.797 --> 23:33:47.513
如果我们去看合同，我们会去阅读合同。

17162
23:33:47.513 --> 23:33:51.513
然后我们到令牌URI打孔，这里是0。

17163
23:33:51.513 --> 23:33:57.492
一个查询，抓取这个，插入到我们的浏览器，JSON看起来很好。

17164
23:33:57.492 --> 23:33:59.298
让我们获取图像URI。

17165
23:33:59.298 --> 23:34:00.201
粘贴进去。

17166
23:34:00.201 --> 23:34:04.275
如果我们能看到这里，这意味着我们的代码是好的。

17167
23:34:04.275 --> 23:34:10.013
您已经成功地将许多fft部署到区块链。

17168
23:34:10.013 --> 23:34:17.508
我们在这门课中学到了很多东西，这绝对是最果酱的一门。

17169
23:34:17.508 --> 23:34:18.543
这都是关于艺术的。

17170
23:34:18.543 --> 23:34:23.750
对吧?这是不是很疯狂?让我们快速复习一下这门课。

17171
23:34:23.750 --> 23:34:28.539
首先，我们学习了基本的NF T dot Sol的基础

17172
23:34:28.539 --> 23:34:33.513
知识，我们知道这些NF T是基于ERC 721标准的。

17173
23:34:33.513 --> 23:34:38.137
这意味着它们有name, token, Uri等函数。

17174
23:34:38.137 --> 23:34:46.982
我们学过NF - T使用这个令牌URI来告诉我们这个令牌实际上看起来像什么一个令牌，你的眼睛看起来像

17175
23:34:46.982 --> 23:34:56.005
这样，它会是一个名字一个描述，它会有一个图像URL，它指向一个不同的位置，显示NFT实际看起来像什么。

17176
23:34:56.005 --> 23:35:00.863
它会有像属性这样的东西，它可以有像属性这样的东西，还有一些其他标签。

17177
23:35:00.863 --> 23:35:03.466
这被称为非ft的元数据。

17178
23:35:03.466 --> 23:35:05.562
这告诉我们关于非功能性的。

17179
23:35:05.562 --> 23:35:12.229
我们也可以在chain上有所有的元数据，当然，在chain上自定义它，让它在chain上看，增长，改变

17180
23:35:12.229 --> 23:35:19.028
和交互，我们学习了更多关于IPFS的知识，我们实际上写了一个脚本叫upload to pinjarra。

17181
23:35:19.028 --> 23:35:25.398
js中，我们可以通过编程方式将图片和文件上传到另一个IPFS固定服

17182
23:35:25.398 --> 23:35:31.768
务中，当然，如果我们愿意，我们总是可以使用我们自己的IPFS节点。

17183
23:35:31.848 --> 23:35:34.493
这个令牌URI可以是任何东西。

17184
23:35:35.848 --> 23:35:39.727
IPFS是我们的基本非ft和随机非ft。

17185
23:35:40.848 --> 23:35:47.714
动态非ft，我们实际上托管令牌，你是对的100%在链上，所以我们没有使用IPFS。

17186
23:35:47.714 --> 23:35:54.663
我们做了这个动态，令牌URI实际上是根据我们的随机IPFS非功能性饲料

17187
23:35:54.663 --> 23:36:01.612
的价格变化而变化的，我们给我们的非功能性饲料一个机会我们给不同的狗不同

17188
23:36:01.612 --> 23:36:08.562
的稀有物所以我们可以创建编程罕见的NF TS我们的哈巴狗是超级稀有的。

17189
23:36:08.562 --> 23:36:10.941
我们的湿婆有点稀有，而我们的圣。

17190
23:36:10.941 --> 23:36:12.112
伯纳德很普通。

17191
23:36:12.112 --> 23:36:14.733
所以我们能把它送到你这里真是太棒了。

17192
23:36:14.733 --> 23:36:17.414
我们做了一些惊人的部署，写了一些测试。

17193
23:36:17.414 --> 23:36:25.038
不仅如此，我们还学习了很多关于事务的知识，以及如何向这个数据部分添加我们想要的任何数据。

17194
23:36:25.038 --> 23:36:32.809
更多的是关于我们的事务是什么样子的，以及我们如何使用函数，选择器和函数签名来调用

17195
23:36:32.809 --> 23:36:40.776
任何东西，我们还学习了ABI点编码，编码包和所有二进制的东西如果你想深入了解的话。

17196
23:36:40.776 --> 23:36:43.224
所以这绝对是一个JAM拥挤的会议。

17197
23:36:43.224 --> 23:36:49.367
你应该为自己感到无比自豪，尤其是你的小狗你可以在公海上看到或者你可以直接

17198
23:36:49.367 --> 23:36:55.510
在以太扫描上看到，或者你可以只看它和IPFS，并为你所做的感到非常自豪。

17199
23:36:55.510 --> 23:36:59.009
话虽如此，恭喜你能走这么远。

17200
23:36:59.009 --> 23:37:05.369
一定要在这里休息

17201
23:37:05.369 --> 23:37:12.525
一下，我们下期见。

17202
23:37:12.849 --> 23:37:18.991
好了，现在我们只有不到5个团队，这将是我们下一个JS非ft市场。

17203
23:37:18.991 --> 23:37:24.662
如果你完成了这节课，你就是一个web三全栈怪物，

17204
23:37:24.662 --> 23:37:33.642
这将是我们使用web三栈最复杂的前端使用很多非常高级的web三和区块链工具。

17205
23:37:33.642 --> 23:37:38.134
所以大家要兴奋起来，因为这节课我们将学到很多东西。

17206
23:37:38.134 --> 23:37:41.610
实际上有三种不同的回购与这一课相关。

17207
23:37:41.610 --> 23:37:44.389
第一个是我们典型的安全帽项目。

17208
23:37:44.389 --> 23:37:52.949
对于后端，在安全帽项目之后，我们实际上有两个回购都是我们的前端回购，它们略有不同。

17209
23:37:52.949 --> 23:38:00.107
在这个项目中，我们将更多地了解事件是如何如此重要以及为什么事件如此重要，特别是对于链外服务。

17210
23:38:00.107 --> 23:38:07.392
所以我们实际上要看两种不同的方法来处理它们，一种是mirallas，或一个集中的数据库，另一种是使用图表。

17211
23:38:07.392 --> 23:38:14.801
我想展示这两种方法的原因是，当人们想要扩大项目规模时，当人们想要快速完成事

17212
23:38:14.801 --> 23:38:22.210
情时，采用更集中的方法通常会更快一些，有时你可以给你的网站添加更多的功能。

17213
23:38:22.210 --> 23:38:24.688
还有很多协议都有去中心化的后端。

17214
23:38:24.688 --> 23:38:26.568
以及集中前端。

17215
23:38:26.568 --> 23:38:33.787
其中一个例子是，开放的海洋，例如，开放的海洋有能力喜欢不同的和fts。

17216
23:38:33.850 --> 23:38:37.172
现在，这不是我们真正想要花费汽油的东西。

17217
23:38:37.172 --> 23:38:42.968
但是我们必须把它存储在某种数据库中，这样人们才有能力这样做。

17218
23:38:42.968 --> 23:38:49.209
所以我想给你们展示这个可选的第一种方法来构建这些前端，因为我们所有的逻辑仍然是100%的。

17219
23:38:49.209 --> 23:38:55.627
在链上，前端不那么重要，因为任何人都可以与我们在链上建立的合约进行交互。

17220
23:38:55.627 --> 23:38:58.183
在web 3中，我们不想停留在那里。

17221
23:38:58.183 --> 23:39:03.241
然而，完成一个MVP，完成一个最小的可行项目是非常非常重要的。

17222
23:39:03.241 --> 23:39:07.650
所以使用中央服务器，像Morales，或中央项目可以让我们更快。

17223
23:39:07.650 --> 23:39:13.006
事实上，我们一直在使用中心化服务，就像炼金术一样，贯穿整个项目。

17224
23:39:13.006 --> 23:39:17.145
当然，我也想向你们展示去中心化的方法来制作你的前端。

17225
23:39:17.145 --> 23:39:22.357
在我们和莫拉莱斯合作之后，我们还会向你们展示如何使用这个图表来做所有这些事件索引。

17226
23:39:22.357 --> 23:39:28.146
现在这个图表将会是一个去中心化的方式我们可以做我们的前端和处理这些事件。

17227
23:39:28.146 --> 23:39:30.550
这个图表还自带一个graph repo。

17228
23:39:30.550 --> 23:39:33.833
等我们讲到前端部分的时候，我们会学到所有这些。

17229
23:39:33.833 --> 23:39:37.582
让我给你们展示一下我们要做的东西因为它真的很酷。

17230
23:39:37.582 --> 23:39:42.250
既然我们已经学习了大量关于如何使非功能性T成为他们是什么，我们将创建我们自己的非功能性市场。

17231
23:39:42.250 --> 23:39:47.083
就像我说的，这将是我们对所有这些惊人的前端工具的深入研究。

17232
23:39:47.083 --> 23:39:49.576
这就是我们前端的样子。

17233
23:39:49.576 --> 23:39:56.818
但我们能做的是用连接按钮连接，我们点击Metamask, Metamask弹出，我们继续连接。

17234
23:39:56.818 --> 23:40:00.402
现在我们连在一起了，我们可以看到这里不同的实体。

17235
23:40:00.402 --> 23:40:04.689
如果我们在一个属于我们的地址上，它会显示为你所有。

17236
23:40:04.689 --> 23:40:10.441
如果我们切换地址，或者UI会更新，连接到那里。

17237
23:40:10.441 --> 23:40:12.719
现在我们的地址不一样了。

17238
23:40:12.719 --> 23:40:15.678
如果它是我们的，我们会看到这个小的盘旋，上面写着Update listing。

17239
23:40:15.678 --> 23:40:17.394
现在它值0。

17240
23:40:17.394 --> 23:40:17.534
18.

17241
23:40:17.534 --> 23:40:20.588
我们的市场上就是这么标价的。

17242
23:40:20.588 --> 23:40:24.786
如果它是我们的，我们点击它，就可以更新到不同的价格。

17243
23:40:24.786 --> 23:40:32.251
让我们把它更新到每先令50美元，或者不管你的第一层货币是什么，我们只会说新的上市价格，我们将继续进行确认。

17244
23:40:32.251 --> 23:40:36.291
我会说，listing updated，请刷新，我们能做什么。

17245
23:40:36.291 --> 23:40:42.051
我们在后面挖一些区块，嘣，现在我们看到它值50。

17246
23:40:42.051 --> 23:40:47.996
如果我们切换到另一个账户，我们可以看到所有者等等等等，此时

17247
23:40:47.996 --> 23:40:54.146
悬浮键会说，如果他被选为另一个用户，我将通过这个交易购买它。

17248
23:40:54.146 --> 23:40:57.368
现在请确认我是否要买，我就会看到一个小弹出框。

17249
23:40:57.368 --> 23:40:58.741
这是购买成功的项目。

17250
23:40:58.741 --> 23:41:06.883
现在如果我稍微刷新一下，我们就会看到非功能性从市场上消失了，因为我们正确地购买了它，它不再可以出售。

17251
23:41:06.883 --> 23:41:14.800
现在我们能做的就是卖出NF t，在底部，我们会看到提取收益。

17252
23:41:14.800 --> 23:41:22.574
所以当有人购买NFT时，NFT市场实际上保留了收益实际上保留了销售的结果。

17253
23:41:22.574 --> 23:41:27.123
因此，如果我们切换回我们列出的NF T的地址，我们现在可以看到提

17254
23:41:27.123 --> 23:41:31.816
取50收益，因为我们知道我们每人有50，因为我们刚刚以50买了它。

17255
23:41:31.816 --> 23:41:38.072
如果我们点击取款，Metamask就会弹出，我们可以继

17256
23:41:38.072 --> 23:41:44.561
续确认，等一会交易填充，一旦它通过，我们就会看到零收益。

17257
23:41:44.561 --> 23:41:46.742
对，我们把这里的东西都撤走了。

17258
23:41:46.852 --> 23:41:49.899
所以我们现在能做的，就是重新列出非功能性药物。

17259
23:41:50.852 --> 23:41:55.296
回到刚刚买了NF t的那个。

17260
23:41:55.852 --> 23:42:04.626
知道NFT的地址和令牌ID我们就拥有了它，我们可以继续并重新列出它，因为我们可以把地址和

17261
23:42:04.626 --> 23:42:13.400
令牌ID放在这里给我们一个价格，我们会提交，我们会批准把NFT的市场访问权给我们的小狗。

17262
23:42:13.400 --> 23:42:18.251
然后我们会发送交易，让

17263
23:42:18.251 --> 23:42:23.544
非ft在市场上成功上市。

17264
23:42:23.544 --> 23:42:27.802
在我们移除后端的一些障碍物后，我们可以回到前端。

17265
23:42:27.852 --> 23:42:34.342
我们现在看到，它归我们所有，而不是原来的主人，对吧，设为10以太币。

17266
23:42:34.342 --> 23:42:40.004
然后我们当然可以切换回不同的用户，我们可以让他们真正购买。

17267
23:42:40.004 --> 23:42:45.728
这将是一个完全去中心化的非功能性市场，我们将学习大量关于前端的知

17268
23:42:45.728 --> 23:42:51.452
识大量关于索引的知识大量关于事件的知识，以及为什么它们如此强大。

17269
23:42:51.452 --> 23:42:54.118
这次我真的为你感到兴奋。

17270
23:42:54.118 --> 23:43:01.759
因为如果你通过了这个，你将有很多工具在你的指尖与区块链一起工作。

17271
23:43:01.852 --> 23:43:03.658
准备好了吗，我们开始吧。

17272
23:43:05.852 --> 23:43:07.005
然后我们来做前端。

17273
23:43:07.005 --> 23:43:07.479
让我们开始吧。

17274
23:43:07.853 --> 23:43:14.772
这个项目将基于Arteon项目，它是一个完全开源的去中

17275
23:43:14.772 --> 23:43:17.847
心化智能合约非金融市场，

17276
23:43:17.847 --> 23:43:28.611
我会在与这门课相关的GitHub上留下它的链接，当然我们的，将是这个的一个极简版本。

17277
23:43:28.853 --> 23:43:30.112
我们在VS code pre normal中。

17278
23:43:30.853 --> 23:43:35.297
在这里创建一个名为hard hat的新文件夹。

17279
23:43:37.853 --> 23:43:42.885
FCC，哦，MK dir，和他们一样，我们要用cd。

17280
23:43:43.853 --> 23:43:46.098
打开它和它自己的VS代码。

17281
23:43:47.853 --> 23:43:51.780
代码期，或文件打开文件夹，并打开此文件夹。

17282
23:43:52.853 --> 23:43:55.900
一旦我们到了这里，我们要做所有我们在整个课程中一直在做的正常的事情。

17283
23:43:55.900 --> 23:44:03.138
再说一次，如果你想复制粘贴到JSON包上，如果你想复制粘贴到模块里，不管你想

17284
23:44:03.138 --> 23:44:10.567
做什么，请随意我要继续，这个repo，我们要向上滚动，再次抓取，这一行小于9。

17285
23:44:10.567 --> 23:44:16.201
然后运行这个，我知道我要用的是pretty所以我要复制粘贴这两个pretty

17286
23:44:16.201 --> 23:44:21.984
文件到pretty忽略和pretty RC会再次使用它们，用于linting。

17287
23:44:21.984 --> 23:44:24.286
对于solidity，我们将使用Sol hint。JSON。

17288
23:44:24.286 --> 23:44:26.170
我们会抓取那个。soul hint。JSON。

17289
23:44:26.170 --> 23:44:28.868
这些点表示忽略。

17290
23:44:28.868 --> 23:44:35.259
我还会使用hardhat。config。js因为我们会使用一个非常非常相似的设置。

17291
23:44:35.259 --> 23:44:37.071
这个。config。js。

17292
23:44:37.071 --> 23:44:41.883
它有华夫饼，以太扫描，硬帽部署覆盖气体报告大小

17293
23:44:41.883 --> 23:44:46.695
器和多蒂和v点配置，我们将带来我们的多蒂和v。

17294
23:44:46.695 --> 23:44:49.604
我们还会带来我们的utils文件夹。

17295
23:44:49.604 --> 23:44:52.644
好了，我们会带来很多样板文件。

17296
23:44:52.644 --> 23:44:58.040
现在就像这样，因为我们有硬帽。配置。j s在这里，如果我们

17297
23:44:58.040 --> 23:45:03.624
运行yarn，现在，yarn硬帽会看到我们得到像这样的输出。

17298
23:45:03.624 --> 23:45:04.804
我们继续。

17299
23:45:04.804 --> 23:45:11.312
在写合同之前，我们先写一份文件说明合同的内容，我们

17300
23:45:11.312 --> 23:45:17.820
希望它做什么?我们将创建一个去中心化的非金融市场。

17301
23:45:17.820 --> 23:45:25.701
这是什么意思呢?我们可能需要什么?我们可能需要某种类型的列表项函数，因为我们想要列

17302
23:45:25.701 --> 23:45:33.582
出NF T而这将是在市场上列出NF T，我们需要某种类型的购买项目来购买NF T。

17303
23:45:33.582 --> 23:45:38.622
然后我们可能需要取消列表或取消项目，如果

17304
23:45:38.622 --> 23:45:43.916
你不想再卖它，可能需要更新列表，更新价格。

17305
23:45:43.916 --> 23:45:51.001
然后可能会有一个提款程序来提款或者我的bot和fts。

17306
23:45:51.001 --> 23:45:57.803
当有人购买非担保债券时，我将不得不从合同中撤回它因为合同将是真正持有这些资金的合同。

17307
23:45:57.803 --> 23:45:58.786
在我看来还不错。

17308
23:45:58.854 --> 23:46:00.854
让我们开始做这个。

17309
23:46:01.854 --> 23:46:03.494
新文件夹，合同。

17310
23:46:03.494 --> 23:46:05.447
让我们开始吧。

17311
23:46:06.854 --> 23:46:09.742
一个新的文件非ft市场。

17312
23:46:09.854 --> 23:46:11.520
这是所有。

17313
23:46:11.520 --> 23:46:16.353
让我们得到我们的样板。

17314
23:46:18.854 --> 23:46:22.501
固体度，胡萝卜0，点，8。

17315
23:46:24.854 --> 23:46:26.319
市场,繁荣。

17316
23:46:29.855 --> 23:46:35.315
或纱线Hardhead编译或MPX，艺术，击中，编译，boom，事情看起来很好。

17317
23:46:35.315 --> 23:46:39.762
如果我们回到自述文件，我们可以在这里抓取这些，

17318
23:46:39.762 --> 23:46:44.403
甚至把它们放在这里作为我们以后参考的一个小注释。

17319
23:46:44.403 --> 23:46:46.089
让我们从列出项目开始。

17320
23:46:46.089 --> 23:46:48.760
我们要如何记录人们的物品。

17321
23:46:48.855 --> 23:46:55.387
再说一次，记住，当我编写这个代码的时候，我会在编写测试和编写实际代码之间来回切换。

17322
23:46:55.387 --> 23:46:59.613
我们只需要把所有的固体度写在一个数据块里，然后再写测试。

17323
23:46:59.613 --> 23:47:04.188
我们会说，这些是我们的主要函数。

17324
23:47:04.188 --> 23:47:07.315
我将从函数列表项开始。

17325
23:47:07.315 --> 23:47:10.910
我们要让这个看起来非常非常好。

17326
23:47:10.910 --> 23:47:12.521
我们来做natspec。

17327
23:47:12.521 --> 23:47:19.811
这需要一个外部函数，我们可能不希望任何内部函数调用list item，

17328
23:47:19.811 --> 23:47:26.685
它将被外部项目或外部帐户调用可能需要一个地址和ft地址，写NFT的

17329
23:47:26.685 --> 23:47:33.977
址，契约一个un256令牌ID，我们将要使用的契约的令牌ID的ID。

17330
23:47:33.977 --> 23:47:36.113
然后我们要设置一个un256的价格。

17331
23:47:36.113 --> 23:47:40.417
首先，我们可能希望价格大于0。

17332
23:47:40.417 --> 23:47:46.156
也许我们会在这里放入一个if或require语句，

17333
23:47:46.156 --> 23:47:56.258
我们会说如果price小于或等于0，然后我们会返回一个price must高于0的错误。

17334
23:47:56.258 --> 23:48:02.820
当然，我们会在它前面加上合约的名字下划线。

17335
23:48:02.820 --> 23:48:07.324
在顶部，误差价格必须大于零。

17336
23:48:07.324 --> 23:48:13.881
现在为了让我们把它列出来，我们实际上可以用两种方式来做其中一种，我们可以把非功能性

17337
23:48:13.881 --> 23:48:20.439
的东西发送到合同中，这需要我们做一个转移，对吧，我们可以让合同持有非功能性的东西。

17338
23:48:20.439 --> 23:48:27.763
现在我们可以这样做了，但是这对于在f t上列出的人来说有点油贵。

17339
23:48:27.763 --> 23:48:32.363
我们可以让非功能性的所有者成为我们的非功能性市场，我们可以百分之百做到这一点。

17340
23:48:32.363 --> 23:48:36.006
但问题是，市场将拥有非功能性货币。

17341
23:48:36.006 --> 23:48:42.158
用户不能说，嘿，我拥有这个NFT，它在市场上，从技术上讲，他

17342
23:48:42.158 --> 23:48:48.310
们可以但他们必须撤回它，我们可以用一种稍微不同的方式我们可以

17343
23:48:48.310 --> 23:48:54.669
说所有者仍然可以持有他们的NFT并给市场批准为他们出售NFT。

17344
23:48:54.669 --> 23:49:02.133
当然，实体的所有者可以在任何时候撤回批准，市场就不能再出售它了。

17345
23:49:02.133 --> 23:49:09.498
然而，这对人们来说真的很容易阅读，他们所要做的就是阅读，就像被批准进入市场一样。

17346
23:49:09.498 --> 23:49:11.822
他们实际上可以看到项目是否真的列出了。

17347
23:49:11.856 --> 23:49:16.793
所以我们继续用第二种方式来写，因为这是阿迪安的方法。

17348
23:49:16.793 --> 23:49:23.505
这是建立这个市场的最不具侵入性的方式，对吧?人们仍然拥有他们的NF T的所

17349
23:49:23.505 --> 23:49:30.218
有权，而市场将获得批准，一旦价格达到，就可以实际互换和出售他们的NF T。

17350
23:49:30.218 --> 23:49:36.396
既然我们想要确保市场得到了批准，那就确保市场得到了批准。

17351
23:49:36.396 --> 23:49:39.969
我们可以在令牌ID上调用这个get

17352
23:49:39.969 --> 23:49:45.856
approved函数来确保市场被批准与NFT一起工作。

17353
23:49:45.856 --> 23:49:53.789
要做到这一点，我们需要AI ERC 720接口，我们实际上可以从开放的齐柏林抓取。

17354
23:49:53.857 --> 23:50:00.031
对，这个接口将围绕一个地址，然后我们可以调用该地址获得批准。

17355
23:50:00.031 --> 23:50:05.051
我们会在open Zeppelin输入/合约/令牌

17356
23:50:05.051 --> 23:50:10.273
/ ERC 721 / I ERC 721。Sol。

17357
23:50:10.273 --> 23:50:18.710
因为我们要从open Zeppelin进行导入，我们会做yarn add dash

17358
23:50:18.710 --> 23:50:26.941
Dev, add open Zeppelin现在我们有了这个接口，我们能做的是我

17359
23:50:26.941 --> 23:50:35.790
们会说I ERC 721 NF t = IRC 721围绕着我们传入的NF t地址。

17360
23:50:35.790 --> 23:50:40.667
我们会说，如果NF T dot得到批准

17361
23:50:40.667 --> 23:50:45.544
我们试图列出的令牌ID不等于地址这个。

17362
23:50:45.544 --> 23:50:53.123
所以如果我们没有被批准，我们就会回复not approved or market place。

17363
23:50:53.123 --> 23:51:01.539
然后我们当然会把它用非ft市场加上下划线。

17364
23:51:01.539 --> 23:51:07.171
像这样的错误，嗒嗒嗒嗒，现在我们已经解决了一些问题，

17365
23:51:07.171 --> 23:51:13.020
我们可能需要某种类型的数据结构来列出所有这些NF T。

17366
23:51:13.020 --> 23:51:20.972
通常我们会问，我们要用数组吗?还是要使用映射?你怎么看?在我们继续之前?让我们暂停一下，你认为

17367
23:51:20.972 --> 23:51:28.924
把这些NF T和数组或者a映射放在一起更有意义吗?当你考虑这个的时候，试着想想，好吧，人们会买

17368
23:51:28.924 --> 23:51:36.876
这些卖这些，什么更有意义，想一下这个，也许暂停一下，在这里写个评论，你认为数组或映射哪个更好。

17369
23:51:36.876 --> 23:51:39.288
现在，如果你说映射，我会同意你的观点。

17370
23:51:39.288 --> 23:51:45.513
你不能用数组，你不一定会错，但这不是我用数组的方法。

17371
23:51:45.513 --> 23:51:53.202
只要有人想买东西，我们就得遍历数组，我们就得创建这个巨大的动态数组。

17372
23:51:53.202 --> 23:51:56.996
这可能有点冒险因为数组变得非常非常大。

17373
23:51:56.996 --> 23:51:59.211
我们要把它变成一个映射。

17374
23:51:59.211 --> 23:52:03.599
这可能是一个全局变量或状态变量。

17375
23:52:03.599 --> 23:52:09.781
在顶部，让我们继续创建这个映射，这将是一个非ft地址的地址映射。

17376
23:52:09.858 --> 23:52:18.288
对吧?它将是NFT契约地址映射到NFT，令牌ID映射到某种类型的列表。

17377
23:52:18.288 --> 23:52:24.451
所以我们会说，一个地址的映射到一个unt256的映射。

17378
23:52:24.451 --> 23:52:30.562
我们在这里想要什么?我们想要我们想要价格，对吧?这是另一个你用了6年的。

17379
23:52:30.562 --> 23:52:36.406
但我们也想，我们也想跟踪卖家，我们知道把钱寄给谁。

17380
23:52:36.406 --> 23:52:41.524
我们可以创建两个映射或者我们只创建一个新的类型类型列表，我们来做这个。

17381
23:52:41.524 --> 23:52:43.072
我们现在将对此进行注释。

17382
23:52:43.072 --> 23:52:49.700
所以在顶部，因为这将是一种类型，比如说，结构列表，在这里，

17383
23:52:49.700 --> 23:52:56.558
我们将做一个效用6,NF t的价格，然后解决NF团队的卖家。

17384
23:52:56.558 --> 23:53:03.861
现在我们有了新的类型，我们可以取消注释这个，我们可以说NFT，契约地址映

17385
23:53:03.861 --> 23:53:11.367
射到NFT令牌ID映射到列表，我们会把这个设为私有变量，叫做S下划线列表。

17386
23:53:11.367 --> 23:53:18.318
现在回到我们的列表项函数，我们要更新那个列表映射。

17387
23:53:18.318 --> 23:53:21.622
我们会说nst地址的s列表，

17388
23:53:21.622 --> 23:53:28.231
nst在令牌ID处的地址将等于我们会创建一个价格的列表。

17389
23:53:28.231 --> 23:53:36.792
那么谁呢，卖家将会是发送者的信息，对吧?message。sender是列出项目的人。

17390
23:53:36.859 --> 23:53:43.491
既然我们在更新映射，更新映射的最佳实践是什么，你猜对了，我们需要发射一个事

17391
23:53:43.491 --> 23:53:50.303
件特别是对于这个项目，你会看到为什么发射事件，至少对于这个项目，这很有帮助。

17392
23:53:50.303 --> 23:53:56.059
我们会触发一个itemlistevent，我们马上就会创建它。

17393
23:53:56.059 --> 23:54:03.208
我们将给出发送者的消息、非ft地址、令牌ID和列出的价格项。

17394
23:54:03.208 --> 23:54:10.722
然后在最上面，但在结构下面，我们会说event

17395
23:54:10.722 --> 23:54:19.543
item list会做一个地址索引卖家地址索引非ft，

17396
23:54:19.543 --> 23:54:28.366
地址，地址索引令牌ID，然后是一个un 256价格。

17397
23:54:28.366 --> 23:54:32.826
抱歉，这需要一个un256令牌ID，你int 56。

17398
23:54:32.826 --> 23:54:35.632
这看起来很好。

17399
23:54:35.632 --> 23:54:41.732
然而，我们可能想要确保我们只列出那些还没有列出的fte。

17400
23:54:41.732 --> 23:54:44.747
我们可以在这里加上if then。

17401
23:54:44.747 --> 23:54:47.532
这就是偏好起作用的地方。

17402
23:54:47.532 --> 23:54:51.579
但我要创建一个修饰符not lists。

17403
23:54:51.579 --> 23:54:57.219
我们确保我们没有重新列出，如果T已经列在我们的主

17404
23:54:57.219 --> 23:55:02.860
要函数上面，或者像一个没有列出的小指示器修饰符。

17405
23:55:02.860 --> 23:55:05.494
这需要一个地址，

17406
23:55:05.494 --> 23:55:12.082
一个un256令牌ID和一个地址所有者。

17407
23:55:12.082 --> 23:55:18.574
我们要做的是检查，我们要创建一个新的列表内存

17408
23:55:18.574 --> 23:55:25.066
列表= s NFT地址令牌ID的下划线列表。

17409
23:55:25.066 --> 23:55:32.339
现在我们会说，如果listing。price大于0，

17410
23:55:32.339 --> 23:55:39.053
我们会继续并恢复已经传递的NFT地址和令牌ID。

17411
23:55:39.053 --> 23:55:46.029
当然，我们将以非功能性市场为开端。

17412
23:55:46.029 --> 23:55:52.405
在顶部，我们做错误的市场已经列出，像这样。

17413
23:55:52.405 --> 23:55:57.078
然后我们在下面加一个下划线然后在上

17414
23:55:57.078 --> 23:56:02.026
面这里，我们写上地址如果地址是56。

17415
23:56:02.026 --> 23:56:02.776
好的,ID。

17416
23:56:02.776 --> 23:56:05.692
这个修饰符看起来不错。

17417
23:56:05.692 --> 23:56:11.237
让我们确保它真的要编译我们用yarn Hardhead compile或hh compile。

17418
23:56:11.237 --> 23:56:11.630
太好了。

17419
23:56:11.630 --> 23:56:12.679
看起来不错。

17420
23:56:12.679 --> 23:56:21.110
我们将添加这个修饰符到我们的列表项函数将做非ft地址，令牌ID message。sender。

17421
23:56:21.110 --> 23:56:21.526
酷。

17422
23:56:21.526 --> 23:56:23.726
我们还应该检查什么?

17423
23:56:23.726 --> 23:56:31.210
我们还应该检查所列出的NF T是否属于message。sender。

17424
23:56:31.210 --> 23:56:39.033
这样只有NFT的所有者可以在这里列出所以我们继续，我们将添加一个is owner

17425
23:56:39.033 --> 23:56:47.639
modifier modifier is owner NFT address token

17426
23:56:47.639 --> 23:56:55.462
ID spender你到这里的256和一个地址spender I ERC 721

17427
23:56:55.462 --> 23:57:05.244
NFT = IRC 721如果地址地址所有者等于NFT。owner a有一个token ID。

17428
23:57:05.244 --> 23:57:10.500
然后我们会说，如果消费者不等于所有者。

17429
23:57:10.500 --> 23:57:16.161
我们会返回一个非所有者错误我们会在上面创建这个错误。

17430
23:57:16.161 --> 23:57:18.488
我们会说error，而不是owner。

17431
23:57:18.488 --> 23:57:25.412
我们会在它前面加上两个下划线“revert revert not

17432
23:57:25.412 --> 23:57:29.956
owner”然后在剩下的代码中加上下划线，

17433
23:57:29.956 --> 23:57:40.344
下面没有列出的是“owner NFT address”令牌ID message。center。

17434
23:57:40.344 --> 23:57:44.850
现在我们的列表项检查它是否已经被列出，确保

17435
23:57:44.850 --> 23:57:49.572
只有那个令牌的NFT的所有者Id可以列出它。

17436
23:57:49.572 --> 23:57:52.254
然后它会继续，很好地列出它。

17437
23:57:52.254 --> 23:57:52.975
好的,很酷。

17438
23:57:52.975 --> 23:57:55.401
这是我们的列表项方法。

17439
23:57:55.401 --> 23:57:58.368
现在让我们继续做一点关于这个的natspec。

17440
23:57:58.368 --> 23:58:06.635
现在我们有一个小的natspec，看起来非常专业。

17441
23:58:06.635 --> 23:58:07.602
好了,好了。

17442
23:58:07.602 --> 23:58:09.667
我们有一个列表项函数。

17443
23:58:09.862 --> 23:58:16.433
好了，接下来是什么?也许我们可以做一个购买物品的函数，让人们在NF T上市后购买它们。

17444
23:58:16.433 --> 23:58:20.337
我们来创建它们，函数按项。

17445
23:58:20.337 --> 23:58:22.939
我们取一个地址，

17446
23:58:22.939 --> 23:58:30.747
如果地址un256令牌ID，这将是一个外部函数。

17447
23:58:30.747 --> 23:58:39.535
这也会使这个可支付函数成为一个外部函数因为我们知道只有这个合同之外的人或合同会按项目

17448
23:58:39.535 --> 23:58:48.532
和可支付进行调用这样人们就可以按项目和可支付进行调用，或者任何一层货币来购买这些价格，

17449
23:58:48.532 --> 23:58:57.112
我们可以想要100%的引导价格现在上市，当然，我们可以添加价格然后做地址代币价格。

17450
23:58:57.112 --> 23:59:02.603
然后像我们之前对链链价格提要所做的那样，将这些代币的价格转换为它们的实际成本。

17451
23:59:02.603 --> 23:59:05.695
我们完全可以通过链接价格来实现这一点。

17452
23:59:05.695 --> 23:59:07.700
但为了简单起见，我们不讲这个。

17453
23:59:07.700 --> 23:59:15.330
但我将把它作为一个挑战，通过挑战将使这个合同也接受令牌子集中的支

17454
23:59:15.330 --> 23:59:22.960
付，当然，我们需要在这里给出一个小提示，即引导价格feed来转换

17455
23:59:22.960 --> 23:59:30.590
令牌之间的价格，我们将选择我们想要购买的令牌ID中的哪个NFT。

17456
23:59:30.590 --> 23:59:36.671
我们首先要做的是什么?我们可能想检查这个by项是否被列出。

17457
23:59:36.671 --> 23:59:44.298
我们将创建一个新的modifier而不是未列出我们将使它被列出modifiers modifier被列出。

17458
23:59:44.298 --> 23:59:50.418
这需要一个地址，加上地址un256令牌ID。

17459
23:59:50.418 --> 23:59:55.034
为了检查这个是否被列出了，我们会说，

17460
23:59:55.034 --> 24:00:08.113
listmemoreslistingequals s，标记的NFT地址的下划线列表，Id进入映射这里。

17461
24:00:08.113 --> 24:00:10.738
然后我们再看看价格。

17462
24:00:10.738 --> 24:00:18.741
我们会说，如果列表中那个价格小于或等于零，基本上，如果没有价格，如果它默认

17463
24:00:18.741 --> 24:00:26.744
为零，如果价格为零，那么我们会说，revert, not listing。

17464
24:00:26.863 --> 24:00:33.314
在地址之后，令牌ID，当然，我们要前置。

17465
24:00:33.314 --> 24:00:39.936
如果市场和市场下划线下划线，没有列出，然后我们把这个复制到这里，

17466
24:00:39.936 --> 24:00:46.558
我们说air lists，这将取地址，NFT地址，和au int

17467
24:00:46.558 --> 24:00:55.251
256令牌Id像这样，在我们的修饰符中向下，然后我们将添加下划线并添加剩下的代码。

17468
24:00:55.251 --> 24:01:02.104
现在我们有了一个islists修饰符，我们要检查以确保NFT确实列在下面这里现在我们

17469
24:01:02.104 --> 24:01:09.121
要说的是islistaddressft address，不好意思，如果地址和令牌ID。

17470
24:01:09.121 --> 24:01:13.945
再一次，我们会说，listing memory

17471
24:01:13.945 --> 24:01:20.659
listitem = sunderline listings。

17472
24:01:20.659 --> 24:01:27.674
如果T地址令牌ID，或者如果message。value小于

17473
24:01:27.674 --> 24:01:34.931
列出的item。price，那么我们将返回price未满足。

17474
24:01:34.931 --> 24:01:40.012
然后我们会做NFT address, Open ID listitem。

17475
24:01:40.012 --> 24:01:46.224
price Excel我们会创建一个新的air price not met error。

17476
24:01:46.224 --> 24:01:52.654
价格没有满足，当然，我们将在此之前与非ft市场采取一个地址。

17477
24:01:52.654 --> 24:02:00.355
如果你去的地址是56代币ID，然后一个UNT 256价格。

17478
24:02:00.355 --> 24:02:04.879
我们可以看到exe中价格是如何不满足的，

17479
24:02:04.879 --> 24:02:09.404
然后回到下面这里，我们会得到完整的错误。

17480
24:02:09.404 --> 24:02:12.489
所以我们要确保他们给我们寄了足够的钱。

17481
24:02:12.489 --> 24:02:18.412
首先，当他们汇钱的时候，钱必须属于列出物品的人。

17482
24:02:18.412 --> 24:02:23.109
所以我们实际上需要跟踪这些人有多少钱。

17483
24:02:23.109 --> 24:02:31.676
让我们创建另一个名为收益的数据结构在这里我们记录人们出售NF T所赚的钱。

17484
24:02:31.676 --> 24:02:37.264
我们会创建一个地址到你和256的映射。

17485
24:02:37.264 --> 24:02:45.208
这将是卖家地址到收入的映射。

17486
24:02:45.208 --> 24:02:51.419
我们将这个私有叫做s_。

17487
24:02:51.419 --> 24:02:58.777
我们会做的是，当有人买了一件东西，就会更新他们的收益。

17488
24:02:58.864 --> 24:03:04.444
所以我们会说作为上市商品的收益，

17489
24:03:04.444 --> 24:03:13.164
卖家等于s非法IO乘以卖家的收益加上MSG的价值。

17490
24:03:13.164 --> 24:03:18.324
现在，一旦我们买了这个东西，我们会想要删除清单。

17491
24:03:18.324 --> 24:03:23.832
因此，要从残骸中删除一个映射，要删除一个条目和一个映射，我

17492
24:03:23.832 --> 24:03:29.341
们只需使用delete s下划线列表和令牌ID的ft地址。

17493
24:03:29.341 --> 24:03:31.817
我们移除这个映射。

17494
24:03:31.817 --> 24:03:35.115
最后，我们要转移它。

17495
24:03:35.115 --> 24:03:42.372
我们会说I ERC 721和ft address，我们会调用。

17496
24:03:42.372 --> 24:03:50.566
transfer从列出的项目。卖家到带有令牌ID的消息。sender。

17497
24:03:50.566 --> 24:03:56.477
现在你会注意到，我们不仅仅是把钱寄给卖家。

17498
24:03:56.477 --> 24:04:01.058
为什么呢?固体有个概念叫拉比推。

17499
24:04:01.058 --> 24:04:08.807
当使用固体时，它被认为是最佳实践，您希望将与传输以太相关的风险转移给用户。

17500
24:04:08.865 --> 24:04:16.589
所以我们不想把钱寄给用户，我们不想让他们把钱取出来，我们总是想把和钱

17501
24:04:16.589 --> 24:04:24.541
打交道的风险转移到实际用户身上，把和钱打交道的风险转移到实际用户身上。

17502
24:04:24.541 --> 24:04:33.316
所以我们不想直接把钱寄给他们，我们想要创建这个收益数据结构，我们可以让他们以后从其中提取。

17503
24:04:33.316 --> 24:04:35.896
现在，我们可以在这里做一些检查。

17504
24:04:35.896 --> 24:04:41.316
或者我们可以说，好的，检查以确保非功能性转移。

17505
24:04:41.316 --> 24:04:46.721
如果我们看ierc 721，我们看从函数

17506
24:04:46.721 --> 24:04:52.127
的转移，我们没有看到它实际上有一个返回。

17507
24:04:52.127 --> 24:04:56.554
如果我们去ip721，我们可以看到这些都没有返回

17508
24:04:56.554 --> 24:05:01.167
类型，transfer from这里没有返回类型。

17509
24:05:01.167 --> 24:05:09.602
然而，我们确实看到了这种从位到位的安全传输它将会更好一些，对吧因为如果我们看从转移

17510
24:05:09.602 --> 24:05:18.243
到转移一个实体的所有权，调用者有责任确认下划线2能够接收实体否则它们可能会永久丢失。

17511
24:05:18.243 --> 24:05:22.832
也许我们想使用安全传输，它会抛出一个错误，除

17512
24:05:22.832 --> 24:05:27.421
非消息发送方是当前所有者和授权操作符，等等。

17513
24:05:27.421 --> 24:05:32.817
所以我们用安全的转移而不是从，只是为了更安全一点。

17514
24:05:32.866 --> 24:05:37.449
所以我们要做安全转移而不是转移。

17515
24:05:37.866 --> 24:05:45.456
既然我们要更新映射，我们会做什么，你猜对了，我们省略一个事件，我们调用item bot。

17516
24:05:45.456 --> 24:05:52.962
实验室将消息发送者，一个空地址，令牌ID和列出的项目，价格。

17517
24:05:52.962 --> 24:05:56.728
在上面，我们创建一个新事件。

17518
24:05:56.728 --> 24:06:00.348
到事件项目购买。

17519
24:06:00.348 --> 24:06:07.212
这将是一个地址索引fire一个

17520
24:06:07.212 --> 24:06:14.076
地址索引非ft地址一个地址索引

17521
24:06:14.076 --> 24:06:20.942
令牌ID然后是un236价格。

17522
24:06:20.942 --> 24:06:23.966
开个玩笑，看起来不太好。

17523
24:06:23.966 --> 24:06:25.416
这应该是直观的。

17524
24:06:25.416 --> 24:06:27.481
现在看起来棒极了。

17525
24:06:27.481 --> 24:06:32.004
现在在这个购买项目中，我们已经将其设置为

17526
24:06:32.004 --> 24:06:36.528
一种安全的方式，可以避免所谓的重入攻击。

17527
24:06:36.528 --> 24:06:41.104
我们对这些契约的编码方式是先进行所有的状态变化。

17528
24:06:41.104 --> 24:06:44.588
然后我们将NFT转换为令牌或其他。

17529
24:06:44.588 --> 24:06:49.315
但我们为什么要这么做呢?从认知上来说，我们认为这是有道理的。

17530
24:06:49.315 --> 24:06:57.367
首先，也许我们应该发送非功能性，我们想先发送实体。

17531
24:06:57.867 --> 24:07:00.697
这实际上是一个巨大的安全漏洞。

17532
24:07:01.867 --> 24:07:06.496
为什么让我们来学习区块链中最常见的黑客，重入。

17533
24:07:06.496 --> 24:07:07.028
看到攻击。

17534
24:07:07.028 --> 24:07:09.998
在这节课中，我们将讨论可重入。

17535
24:07:09.998 --> 24:07:16.033
C，在与这节课相关的GitHub回购中，我们会有我们在这里要讲的所有东西的代码。

17536
24:07:16.033 --> 24:07:20.914
我们正在看的代码是基于这个示例的坚固性。

17537
24:07:20.914 --> 24:07:21.707
可重入。

17538
24:07:21.867 --> 24:07:22.467
看到的例子。

17539
24:07:24.867 --> 24:07:25.798
与本课程相关。

17540
24:07:26.867 --> 24:07:30.804
在这里，您可以存取款。

17541
24:07:30.867 --> 24:07:35.639
它有一个叫余额的映射，你可以叫

17542
24:07:35.639 --> 24:07:40.731
存款，它会更新你存入协议的金额。

17543
24:07:40.731 --> 24:07:43.217
它还有取款功能。

17544
24:07:43.217 --> 24:07:50.818
它首先从这个余额映射中获取你的余额，确保你的余额大于零。

17545
24:07:50.867 --> 24:07:56.191
然后我们一直发送eath的方式，我们发送sender。call的

17546
24:07:56.191 --> 24:08:01.516
消息，我们发送余额，然后我们更新消息sender = 0的弹跳。

17547
24:08:01.516 --> 24:08:05.375
这条线实际上让这份合同变得非常脆弱。

17548
24:08:05.375 --> 24:08:12.753
如果我们现在运行这个，我们会说，嘿，不，它看起来像预期的那样

17549
24:08:12.753 --> 24:08:20.131
工作，我们可以部署一个我正在使用的帐户的副本，比如在反弹为0

17550
24:08:20.131 --> 24:08:27.509
时，我们可以存入，你知道，它消失了，让我们到以太，将存入到以

17551
24:08:27.509 --> 24:08:35.626
太，下降，现在的存款要平衡反弹上升，我们点击提取，现在反弹回到0。

17552
24:08:35.626 --> 24:08:37.904
而且看起来效果很好。

17553
24:08:37.904 --> 24:08:44.786
现在，我们有一种方法可以攻击这个函数耗尽合同中的所有钱。

17554
24:08:44.868 --> 24:08:47.949
这就是所谓的重入攻击。

17555
24:08:48.868 --> 24:08:55.257
这个领域常见的攻击类型是可重入性攻击，也就是我们在这里讨论的。

17556
24:08:55.257 --> 24:09:00.436
Oracle攻击，通常只发生在协议不使用去中心化Oracle的情况下，

17557
24:09:00.436 --> 24:09:05.468
幸运的是，我们从一开始就教会您如何使用链链接，这样您就可以受到保护。

17558
24:09:05.468 --> 24:09:11.850
这两种类型的攻击通常导致最多的钱最后，有一个被称为rec

17559
24:09:11.850 --> 24:09:18.461
点新闻的排行榜，它跟踪许多在defi空间发生过的顶级攻击。

17560
24:09:18.461 --> 24:09:24.190
如果你回顾一下，其中很多都是Oracle攻击或可重入攻击。

17561
24:09:24.190 --> 24:09:31.680
你可能会说，嘿，我们在哪里只讨论NF T这个，这和NF T没有任何关系我们会讲到的，别担心。

17562
24:09:31.680 --> 24:09:37.037
在下面的新契约中，我们将创建一个新契约，叫做attack。

17563
24:09:37.037 --> 24:09:42.567
我们对这个攻击契约做的是我们会抓取这个可重入脆弱

17564
24:09:42.567 --> 24:09:48.328
契约，我们会说可重入脆弱，公共可重入脆弱，像这样。

17565
24:09:48.328 --> 24:09:53.386
我们将把可重入脆弱契约保存为全局变量。

17566
24:09:53.386 --> 24:10:00.835
我们会说，构造门地址，下划线牧场和易受害地址。

17567
24:10:00.835 --> 24:10:04.913
然后我们说reentrant vulnerable =

17568
24:10:04.913 --> 24:10:12.767
rancher和vulnerable at reentrant vulnerable address。

17569
24:10:12.767 --> 24:10:17.885
现在我们要做的是创建一个叫做attack的函数。

17570
24:10:17.885 --> 24:10:24.475
这个函数会恶意地调用withdraw。

17571
24:10:24.475 --> 24:10:27.935
这里是攻击，这是一个外部支付合同。

17572
24:10:27.935 --> 24:10:30.735
我们把它叫做这个位置。

17573
24:10:30.869 --> 24:10:32.636
我们先存点钱。

17574
24:10:33.869 --> 24:10:40.369
脆弱点的位置将发送一个以太的值。

17575
24:10:40.369 --> 24:10:47.344
然后我们马上调用renn Trent vulnerable dot withdraw。

17576
24:10:47.344 --> 24:10:51.794
乍一看，这似乎是无害的。

17577
24:10:51.869 --> 24:10:56.312
记住，当我们像这样调用message。

17578
24:10:56.312 --> 24:11:01.223
call来发送时我们回调的是这个攻击契约。

17579
24:11:01.223 --> 24:11:06.274
调用攻击契约时，是否有办法执行其他代

17580
24:11:06.274 --> 24:11:11.606
码?还记得我们是如何学习回退函数的吗。

17581
24:11:11.606 --> 24:11:16.546
如果我们在这里放一个回退函数或者一个接收函数。

17582
24:11:16.546 --> 24:11:21.821
当这段代码运行调用和秒我们的合同醚，我们

17583
24:11:21.821 --> 24:11:27.097
可以让它触发我们的回退函数再次调用撤回。

17584
24:11:27.097 --> 24:11:33.603
这将给我们的合同发送比更新余额之前更多的以太。

17585
24:11:33.603 --> 24:11:36.163
我们看看这是什么样子的。

17586
24:11:36.163 --> 24:11:43.063
在我们的退一步中，我们会说如果可重入脆弱

17587
24:11:43.063 --> 24:11:49.963
余额的地址大于或等于1以太币也就是说，如

17588
24:11:49.963 --> 24:11:57.209
果合同中还有钱，那么牧场主无懈可击。撤回。

17589
24:11:57.209 --> 24:12:03.377
然后在攻击契约中加入平衡函数。

17590
24:12:03.377 --> 24:12:07.394
我们要通过呼叫撤退来攻击易受攻击的再入者。

17591
24:12:07.394 --> 24:12:15.588
当我们讲到发送部分时，我们要做什么呢，我们会让我们的回退函数触发再次调用withdraw。

17592
24:12:15.588 --> 24:12:22.298
现在，当我们再次调用withdraw时，将反弹一个发送方尚未归零的消息。

17593
24:12:22.298 --> 24:12:26.801
合同代码会说，你还有一些钱。

17594
24:12:26.870 --> 24:12:31.785
让我们继续，让我们把它发送给你，这将再次触发我们调用撤回。

17595
24:12:31.785 --> 24:12:34.509
我们会一直调用退出，直到完成为止。

17596
24:12:34.509 --> 24:12:36.738
我们看看这是什么样子的。

17597
24:12:36.870 --> 24:12:44.148
我们编译这个，然后开始部署，首先，部署可重入脆弱契约。

17598
24:12:44.148 --> 24:12:49.719
好的，我们可以有任何合同地址，你知道，比如部署它的那个，我

17599
24:12:49.719 --> 24:12:55.484
们可以有一个存款，让我们这样做，我们有一个存款一个以太存款。

17600
24:12:55.484 --> 24:12:58.641
现在我们可以查一下余额了。

17601
24:12:58.641 --> 24:12:59.079
副本。

17602
24:12:59.079 --> 24:13:01.547
贴得好，就是一个。

17603
24:13:01.547 --> 24:13:04.902
现在我们来做10。

17604
24:13:04.902 --> 24:13:08.226
存款，它拿走了余额。

17605
24:13:08.226 --> 24:13:09.954
现在这里有这么多。

17606
24:13:09.954 --> 24:13:11.513
这里有这么多。

17607
24:13:11.513 --> 24:13:13.763
如果我们退出，那就是全部退出。

17608
24:13:13.871 --> 24:13:19.775
如果我们把账户转到别人名下，我们点取款。

17609
24:13:19.871 --> 24:13:23.585
什么都不会发生，因为另一个账户什么都没有，这也说得通。

17610
24:13:23.585 --> 24:13:26.193
所以这里有很多钱，对吧。

17611
24:13:26.193 --> 24:13:33.553
如果我们与合同达成平衡，我们就能看到它有多少钱，对吧?它总共有这么多钱。

17612
24:13:33.553 --> 24:13:41.395
现在我们可以在另一个账户上做什么，我们选择这个全新的账户，我们来部署攻击契约。

17613
24:13:41.395 --> 24:13:46.299
我们将把可重入值address作为输入参数传递给它。

17614
24:13:46.299 --> 24:13:48.299
所以我们会部署它。

17615
24:13:48.299 --> 24:13:52.023
现在我们要做的是调用攻击。

17616
24:13:52.023 --> 24:13:58.005
你会看到，即使这个合约没有任何东西存入可重入脆弱合

17617
24:13:58.005 --> 24:14:04.228
约，我们仍然会窃取这里所有的资金或者几乎所有的资金。

17618
24:14:04.228 --> 24:14:11.853
现在点击获取余额，一个可重入易受攻击者，这里是，获取余额a这里是0，这是地址，

17619
24:14:11.853 --> 24:14:19.478
我们现在有了攻击，现在得到反弹，哦，不好意思在公共场合，提款也应该是可支付的。

17620
24:14:19.478 --> 24:14:25.952
现在我们将传递一个以太作为攻击函数的输入参数，我们将只存入一个以太。

17621
24:14:25.952 --> 24:14:27.574
然后我们就会退出。

17622
24:14:27.574 --> 24:14:32.746
我们会继续退出，因为我们的回退函数会继续调用退出。

17623
24:14:32.746 --> 24:14:39.746
我们所要做的就是存入一个以太币，我们就能取出里面的11个以太币。

17624
24:14:39.871 --> 24:14:42.000
所以我们现在就开始进攻。

17625
24:14:44.871 --> 24:14:49.428
合同的新余额是12，因为我们存入的1和

17626
24:14:49.428 --> 24:14:54.226
我们偷走的11，旧合同的新余额现在是0。

17627
24:14:54.226 --> 24:14:55.774
这被称为重入体。

17628
24:14:55.872 --> 24:14:56.561
看到攻击。

17629
24:14:59.872 --> 24:15:05.041
在提取过程中，我们允许代码在不同的契约上运行。

17630
24:15:05.041 --> 24:15:13.830
在这个合约上运行的代码，在余额设置为零之前召回withdraw，我们在这里调用其他代码的回退函数，

17631
24:15:13.830 --> 24:15:22.440
它调用withdraw，我们需要重读withdraw在我们设置一个sender等于零的消息之前。

17632
24:15:22.440 --> 24:15:24.043
这显然是个问题。

17633
24:15:24.043 --> 24:15:26.216
我们有两种方法可以预防它。

17634
24:15:26.216 --> 24:15:27.302
有个简单的方法。

17635
24:15:27.302 --> 24:15:31.568
还有互斥锁的方式，我不想说难的方式，它只是一种不同的方式。

17636
24:15:31.568 --> 24:15:36.664
你在安全工具中经常看到的一件事是你总是希望调用任

17637
24:15:36.664 --> 24:15:41.760
何外部契约作为函数的最后一步，或事务的最后一步。

17638
24:15:41.760 --> 24:15:48.033
我们希望在调用外部契约之前将bounce更新为零，因为消息发送方

17639
24:15:48.033 --> 24:15:54.306
的余额在调用外部代码之前被重置为零，然后如果它试图重新输入这个，

17640
24:15:54.306 --> 24:16:00.581
它会碰到这个require步骤然后在这里取消，无法再次发送以太。

17641
24:16:00.581 --> 24:16:03.161
这是我们能做的第一步。

17642
24:16:03.161 --> 24:16:06.821
下一步我们可以使用一个叫做互斥锁的东西。

17643
24:16:06.872 --> 24:16:12.325
这就是open Zeppelin用他们的一个修饰符所做的，

17644
24:16:12.325 --> 24:16:22.855
我们可以有一些布尔类型叫做locked或者别的什么，就在最上面，我们可以说require not locked。

17645
24:16:22.855 --> 24:16:24.625
否则,恢复。

17646
24:16:24.625 --> 24:16:30.983
然后我们在契约中做的第一件事是，我们可以说locked = true。

17647
24:16:30.983 --> 24:16:34.618
然后我们在这里做的最后一件事是我们说locked = false。

17648
24:16:34.618 --> 24:16:39.995
在这里使用这个锁，我们一次只允许一段代

17649
24:16:39.995 --> 24:16:45.373
码在这里执行我们只在代码完成时解锁它。

17650
24:16:45.373 --> 24:16:50.405
现在open Zeplin带有一个可重入保护，我们可以在我们的代码中使用。

17651
24:16:50.405 --> 24:16:56.996
它有一个修饰符non - reentrant它的作用和我们在锁中讨论的一

17652
24:16:56.996 --> 24:17:03.587
样它创建一个名为status的变量并在函数被输入时将其更改为enter。

17653
24:17:03.587 --> 24:17:07.794
它运行完代码，然后在完成时将其更改为未输入。

17654
24:17:07.794 --> 24:17:11.050
无论什么时候运行任何代码，它只要求不输入它。

17655
24:17:11.050 --> 24:17:18.607
如果我们想在代码中使用这个，我们可以在open

17656
24:17:18.607 --> 24:17:27.808
Zeppelin导入，斜杠，合同，斜杠安全，斜杠重入。

17657
24:17:27.808 --> 24:17:35.922
守卫，所以我们可以继承功能，说非入口市场是可重入守卫。

17658
24:17:35.922 --> 24:17:41.499
然后任何我们担心的函数都会有这个可重入的see问题，

17659
24:17:41.499 --> 24:17:48.364
比如by item，我们会添加修饰符non reentrant。

17660
24:17:48.364 --> 24:17:49.315
就像这样。

17661
24:17:49.315 --> 24:17:52.856
这会增加互斥锁，也就是我们讲过的锁机制。

17662
24:17:52.856 --> 24:17:58.098
互斥锁的方式对我们的安全性来说更加明确，对吧?因为我们说，嘿，这是锁着的。

17663
24:17:58.098 --> 24:18:00.227
这是一个不可重入函数。

17664
24:18:00.227 --> 24:18:04.743
这仍然是一个最佳实践，当你调用外部代码时，就像我们

17665
24:18:04.743 --> 24:18:09.440
在这里看到的，你在调用外部契约之前做所有的状态更改。

17666
24:18:09.440 --> 24:18:11.159
现在，你可能会说，哦，这太酷了。

17667
24:18:11.159 --> 24:18:18.384
但是这和我们的NF t有什么关系呢?想象一下，不是sender。call的消息，

17668
24:18:18.384 --> 24:18:25.249
你知道，所有的成功等于，你知道，一些nft。传输，然后我们从这里做一些传输。

17669
24:18:25.249 --> 24:18:30.752
而不是做一些后备的东西，我们的NF T有我们的NF

17670
24:18:30.752 --> 24:18:36.696
T的功能转移从similis代码重新进入我们的提取。

17671
24:18:36.696 --> 24:18:41.670
如果我们像这样设置取款，因为我们仍然调用与NFT的外部合同。

17672
24:18:41.670 --> 24:18:48.284
从外部合同中的转移可能是恶意的，并试图重新进入我们的合同。

17673
24:18:48.284 --> 24:18:54.596
作为最佳实践，在调用任何可能无法控制的外部契约之前，您总是希

17674
24:18:54.596 --> 24:19:01.120
望改变自己的状态，我强烈建议您尝试一下这个方法，因为眼见为实。

17675
24:19:01.120 --> 24:19:09.606
话虽如此，这个的所有代码都会在GitHub中提供与这个可重入脆弱代码相关的课程。

17676
24:19:09.606 --> 24:19:15.737
说到这里，让我们回到我们的非功能性项目。

17677
24:19:15.874 --> 24:19:22.100
好了，现在我们知道了为什么我们要从我们的函数的底部在我们的生物的

17678
24:19:22.100 --> 24:19:28.326
底部进行这个安全转移，因为如果我们的安全转移函数从稍微高一点，可

17679
24:19:28.326 --> 24:19:34.749
能最终会发生的是我们在更新它们之前将多个NF T发送到错误的地址。

17680
24:19:34.749 --> 24:19:36.207
这就是我们这么做的原因。

17681
24:19:36.207 --> 24:19:37.540
我们赞成推倒保罗。

17682
24:19:37.540 --> 24:19:43.818
就像我们说的，在这门课中，你会学到很多安全技巧。

17683
24:19:43.818 --> 24:19:47.187
但这仍然很好，我们有我们的by项。

17684
24:19:47.187 --> 24:19:49.625
我们有列表项函数。

17685
24:19:49.625 --> 24:19:53.708
现在我们来做一个取消项目，或取消列表。

17686
24:19:53.875 --> 24:19:57.701
我们来做一个函数。

17687
24:19:57.875 --> 24:20:02.350
取消名单，我们来做非ft地址。

17688
24:20:04.875 --> 24:20:05.108
ID。

17689
24:20:05.108 --> 24:20:09.074
这是一个外部函数。

17690
24:20:11.875 --> 24:20:14.357
当然，只有这个实体的所有者才能取消它。

17691
24:20:14.875 --> 24:20:17.644
说的是主人。

17692
24:20:17.875 --> 24:20:23.125
如果T地址，令牌ID消息点森。

17693
24:20:24.875 --> 24:20:27.925
确保NFT确实被列出了。

17694
24:20:29.875 --> 24:20:32.675
ft地址，令牌ID。

17695
24:20:32.675 --> 24:20:33.841
和伟大的。

17696
24:20:36.875 --> 24:20:41.620
我们要做的是删除s的列表NFT地

17697
24:20:41.620 --> 24:20:46.366
址令牌ID，我们要删除那个映射。

17698
24:20:46.366 --> 24:20:50.604
然后我们会发出一个事件项cancelled

17699
24:20:50.604 --> 24:20:56.255
message。sender和if T地址和令牌ID。

17700
24:20:56.255 --> 24:21:01.475
当然，我们会在这里创建一个新事件。

17701
24:21:01.475 --> 24:21:04.475
我们说event item cancelled。

17702
24:21:04.475 --> 24:21:11.875
它将是一个地址索引的卖家地址。

17703
24:21:11.875 --> 24:21:14.875
索引非ft地址。

17704
24:21:14.875 --> 24:21:17.616
你想56索引令牌ID。

17705
24:21:17.616 --> 24:21:18.261
好吧。

17706
24:21:18.261 --> 24:21:18.648
太好了。

17707
24:21:18.648 --> 24:21:20.284
真快啊。

17708
24:21:20.284 --> 24:21:21.677
取消听力。

17709
24:21:21.677 --> 24:21:22.086
繁荣。

17710
24:21:22.086 --> 24:21:22.495
杰克。

17711
24:21:22.495 --> 24:21:22.904
完成了。

17712
24:21:22.904 --> 24:21:27.294
接下来是什么?好了，让我们更新一下我们的清单。

17713
24:21:27.294 --> 24:21:35.432
我们会做函数更新listing address如果你

17714
24:21:35.432 --> 24:21:43.570
去的第6个令牌ID的地址你去的6个新价格会更新这个的

17715
24:21:43.570 --> 24:21:51.708
价格这个外部的价格我们会确保它被列出列出的是说所有者

17716
24:21:51.708 --> 24:22:00.476
做一个令牌ID然后我们会做message。sender。

17717
24:22:00.476 --> 24:22:03.771
现在更新我们的列表，

17718
24:22:03.771 --> 24:22:09.703
我们只说s下划线列表的NF T地址。

17719
24:22:09.703 --> 24:22:15.438
令牌ID。price等于我们给它的新价格。

17720
24:22:15.438 --> 24:22:18.842
然后我们承认，我们可以省略item updated。

17721
24:22:18.842 --> 24:22:23.396
但我们也可以省略一个带有MSG点发送

17722
24:22:23.396 --> 24:22:28.203
者非ft地址，令牌ID，新价格的项目。

17723
24:22:28.203 --> 24:22:33.548
因为本质上，通过更新它，我们本质上只是用一个新的价格重新列出它。

17724
24:22:33.548 --> 24:22:41.256
我们只需要做一个项目列表事件，我们只需要做一个函数，我们需要做一个提取收益。

17725
24:22:41.256 --> 24:22:49.476
我们写函数，提取收益来得到所有实体的所有支付。

17726
24:22:49.476 --> 24:22:56.224
我们会通过new activity得到收益6progress=s_

17727
24:22:56.224 --> 24:23:03.585
progressmsg。sender，对吧，我们会得到所有按项目收集的支

17728
24:23:03.585 --> 24:23:11.152
支付，我们说如果progress小于等于0，那么我们将返回没有收益的情况。

17729
24:23:11.152 --> 24:23:14.009
我们要把它变成非功能性的。

17730
24:23:14.009 --> 24:23:17.810
市场没有收益。

17731
24:23:17.810 --> 24:23:25.065
Excel在顶部创建错误空市场没有收益，否则，我

17732
24:23:25.065 --> 24:23:32.623
们会说s下划线收益的MSG。sender = 0。

17733
24:23:32.623 --> 24:23:38.283
所以我们要把收益重置为零，对吧，我们要在发送任何收益之前这么做。

17734
24:23:38.283 --> 24:23:43.380
然后我们会用传统的方式发送支付，bool

17735
24:23:43.380 --> 24:23:50.261
success = payable, message。

17736
24:23:50.261 --> 24:23:57.652
sender callvalue将是收益，这里全部为空。

17737
24:23:57.652 --> 24:24:04.060
然后我们可以要求，你知道，我们可以要

17738
24:24:04.060 --> 24:24:10.468
求成功，或者我们可以说，如果不成功，

17739
24:24:10.468 --> 24:24:16.877
返回与Aleksey市场，转移失败。

17740
24:24:16.877 --> 24:24:22.127
然后我们将使它成为一个新的空气，空气非ft市场转移失败。

17741
24:24:22.127 --> 24:24:23.877
这里加个分号。

17742
24:24:23.877 --> 24:24:26.409
我们看起来很好。

17743
24:24:26.409 --> 24:24:29.231
现在我们甚至有办法取款了。

17744
24:24:29.231 --> 24:24:31.808
这里有五个函数。

17745
24:24:31.808 --> 24:24:32.359
太棒了。

17746
24:24:32.359 --> 24:24:35.422
我们来创建几个getter。

17747
24:24:35.422 --> 24:24:38.694
也许我们可以复制这个。

17748
24:24:38.877 --> 24:24:42.747
粘贴到这里，getter函数是这样的。

17749
24:24:43.877 --> 24:24:46.290
函数，我们可以用getlisting。

17750
24:24:47.877 --> 24:24:53.282
地址，实用程序X令牌ID，外部

17751
24:24:53.282 --> 24:24:58.687
视图，它在内存中返回一个列表。

17752
24:24:58.687 --> 24:25:03.639
我们会说，返回nnft地址令

17753
24:25:03.639 --> 24:25:08.592
牌Id的下划线列表，像这样。

17754
24:25:08.592 --> 24:25:17.606
还有函数，获取地址卖家的收益，外部视图回报，

17755
24:25:17.606 --> 24:25:25.801
你去到desex回报s下划线卖家的收益。

17756
24:25:25.801 --> 24:25:29.136
我们就能知道某人欠了多少钱。

17757
24:25:29.136 --> 24:25:36.746
然后是任何清单让我们在这里运行一个小的编译，yarn，或者点击compile或者hh compile看看我们搞砸了哪里。

17758
24:25:36.746 --> 24:25:37.778
哦，我们搞砸了。

17759
24:25:37.878 --> 24:25:39.648
哇，太好了。

17760
24:25:42.878 --> 24:25:50.262
成功地创建了一个极简的、完全去中心化的非金融市场。

17761
24:25:50.262 --> 24:25:51.800
这太疯狂了。

17762
24:25:51.800 --> 24:25:53.844
这是非常强大的。

17763
24:25:53.844 --> 24:25:56.420
你应该为自己感到高兴。

17764
24:25:56.420 --> 24:25:58.114
很酷，做得很好。

17765
24:25:58.114 --> 24:26:02.369
但你知道，我们还没有完成，我们还得写一些部署和测试。

17766
24:26:02.369 --> 24:26:03.555
让我们开始吧。

17767
24:26:03.555 --> 24:26:11.462
既然我们已经做过几次了，我实际上鼓励您在这里暂停视频，并尝试编写自己的部署脚本和测试。

17768
24:26:11.462 --> 24:26:16.479
然后再回来跟我们一起看是否做对了，我们

17769
24:26:16.479 --> 24:26:21.497
会创建一个名为deploy的新文件夹。

17770
24:26:21.497 --> 24:26:27.163
当然，我们已经在我们的硬帽配置中部署了硬帽。

17771
24:26:27.163 --> 24:26:28.734
我们知道可以开始了。

17772
24:26:28.734 --> 24:26:31.164
我们来创建一个1。

17773
24:26:31.164 --> 24:26:33.628
部署非ft市场。

17774
24:26:33.628 --> 24:26:33.842
js。

17775
24:26:33.842 --> 24:26:42.696
再说一次，你们以前见过很多这样的，所以我们就不讲细节了do const network =

17776
24:26:42.696 --> 24:26:50.566
require hard hat to constant development

17777
24:26:50.566 --> 24:27:00.800
chains，等于= require。点。斜杠帮助我们的hard hats配置，我们应该让我们看看。

17778
24:27:00.879 --> 24:27:01.828
是复制粘贴吗?不。

17779
24:27:02.879 --> 24:27:06.729
以上是从上一个项目的助手Hardhead配置，让我们继续并抓住它。

17780
24:27:06.729 --> 24:27:10.879
或者我们可以从智能合约抽签中获取并粘贴到这里。

17781
24:27:10.879 --> 24:27:15.279
我们只需要这个文件用于开发链。

17782
24:27:15.279 --> 24:27:19.338
对于硬帽和本地主机，我们将从中获取开发链。

17783
24:27:19.338 --> 24:27:22.895
然后我们还会抓取const。

17784
24:27:22.895 --> 24:27:27.124
Verify = require，从utils中获取。

17785
24:27:27.124 --> 24:27:30.499
验证,对吧?我们有效用吗，我们核实过了。

17786
24:27:30.499 --> 24:27:31.533
太棒了。

17787
24:27:31.533 --> 24:27:36.414
现在我们来做modules that exports equals async。

17788
24:27:36.414 --> 24:27:45.079
一个async函数，它将获取命名帐户和部署。

17789
24:27:45.079 --> 24:27:52.027
从硬帽输入参数，然后我们要做const。

17790
24:27:52.027 --> 24:27:55.141
Deploy, log = deployment。

17791
24:27:55.141 --> 24:28:01.450
然后是const, Deployer = await，获取命名帐户。

17792
24:28:01.450 --> 24:28:05.879
当然，我们从hearthead。config中得到。

17793
24:28:05.879 --> 24:28:08.746
我们有命名帐户，我们有一个部署者。

17794
24:28:08.880 --> 24:28:12.208
我们这里有个我们上个项目的玩家。

17795
24:28:12.208 --> 24:28:16.848
现在我们的实体市场有构造函数了吗?构造?不，没有构造函数。

17796
24:28:16.848 --> 24:28:19.435
我们知道args是空的。

17797
24:28:19.435 --> 24:28:22.768
然后我们可以说const NFT。

17798
24:28:22.768 --> 24:28:26.750
市场等于等待，部署。

17799
24:28:26.750 --> 24:28:31.852
如果T市场，比如从部署者，

17800
24:28:31.852 --> 24:28:36.170
args将是args。

17801
24:28:36.170 --> 24:28:38.363
Log为真。

17802
24:28:38.363 --> 24:28:44.377
然后等待确认将是network。config。

17803
24:28:44.377 --> 24:28:50.391
wait confirmation或者一二，这

17804
24:28:50.391 --> 24:28:56.930
将是阻塞病人的，我们会进入配置，确保这些都在这里。

17805
24:28:56.930 --> 24:28:59.439
抱歉，我没把它们加进来。

17806
24:28:59.439 --> 24:29:06.563
所有网络的区块确认都是6个。

17807
24:29:06.563 --> 24:29:14.229
实际上我不是从上一个项目中获取的，它看起来像是我从安全帽入门套件中获取的。

17808
24:29:14.229 --> 24:29:16.255
我要把这些区块确认加进去。

17809
24:29:16.255 --> 24:29:17.426
现在我们可以开始了。

17810
24:29:17.426 --> 24:29:24.336
现在我们要说的是，如果我们不在开发链上，不在

17811
24:29:24.336 --> 24:29:28.105
开发链上包括网络。名称，

17812
24:29:28.105 --> 24:29:38.786
进程研究和以太扫描API key，然后我们会继续，我们会做日志验证。

17813
24:29:38.786 --> 24:29:42.202
然后我们会做一个重量验证。

17814
24:29:42.202 --> 24:29:47.432
如果市场上的。address带圆弧，

17815
24:29:47.432 --> 24:29:52.081
那么我们会在这里写一大堆连字符。

17816
24:29:52.081 --> 24:29:56.843
最后，导出点标记的模块等于所

17817
24:29:56.843 --> 24:30:01.947
有，然后NFT Mar好地方。

17818
24:30:01.947 --> 24:30:08.608
我们可以用纱线硬头部署来测试这个部署功能。

17819
24:30:08.608 --> 24:30:09.981
太达，我们成功了。

17820
24:30:09.981 --> 24:30:10.281
太好了。

17821
24:30:10.281 --> 24:30:15.996
现在我们有了部署功能，我们可以验证契约，我们还需要做什么。

17822
24:30:15.996 --> 24:30:20.692
由于这是一个非功能性的市场，我们可能需要一些非功能性的t。

17823
24:30:20.692 --> 24:30:25.736
所以我们能做的是在我们的合同中，我们会为测试创建一个新文

17824
24:30:25.736 --> 24:30:30.781
件夹在这里有一个新文件叫Basic NF T。soul。

17825
24:30:30.781 --> 24:30:35.569
在这里，我们可以添加我们上一个项目的基本NF T。

17826
24:30:35.569 --> 24:30:40.374
或者你可以去我的或者你可以去和这门课相关的GitH

17827
24:30:40.374 --> 24:30:45.372
ub回购，去契约，测试，基本NF t，然后复制粘贴。

17828
24:30:45.372 --> 24:30:46.847
这也很有效。

17829
24:30:46.847 --> 24:30:51.812
所以我们使用的基本NF t只是指向哈

17830
24:30:51.812 --> 24:30:56.777
巴狗作为我们用来测试的基本NF t。

17831
24:30:56.777 --> 24:31:02.721
现在我们有了一个基本的NFT我们需要创建一个新文件，来

17832
24:31:02.721 --> 24:31:08.666
部署基本的NFT T。js，我们会从这里借用很多样板。

17833
24:31:08.666 --> 24:31:13.181
我们把这些都复制粘贴进来。

17834
24:31:13.181 --> 24:31:18.167
我们会说const args = blank，我们会说const

17835
24:31:18.167 --> 24:31:24.088
basic NF t = await deploy basic NF t。

17836
24:31:24.088 --> 24:31:26.729
从部署人员。

17837
24:31:26.729 --> 24:31:31.303
Args将是Args。

17838
24:31:31.303 --> 24:31:37.853
Log将是true weight。config。block

17839
24:31:37.853 --> 24:31:45.532
confirmation或1然后我们将用if not develop

17840
24:31:45.532 --> 24:31:50.727
meant chains。包括network。

17841
24:31:50.727 --> 24:32:00.665
name和process。EMV，以太扫描API key，它会说Log或to find。

17842
24:32:00.665 --> 24:32:08.119
A。等待在那里如果我basic NFT。address和arcs,

17843
24:32:08.119 --> 24:32:16.931
module。exports。tags = all和basic NFT。

17844
24:32:16.931 --> 24:32:22.063
我们可以用纱线来测试这两种方法。

17845
24:32:22.063 --> 24:32:23.590
和美妙的。

17846
24:32:23.590 --> 24:32:26.501
这两种方法都已得到部署。

17847
24:32:26.501 --> 24:32:27.977
再说一次，你不需要停顿。

17848
24:32:27.977 --> 24:32:33.463
但这是一种很好的方法，可以让你在做所有这些事情的时候真正地磨砺自己的技能。

17849
24:32:33.463 --> 24:32:36.517
重复是所有技能之母。

17850
24:32:36.517 --> 24:32:41.604
所以自己重复这些东西，自己思考这些问题，自己尝

17851
24:32:41.604 --> 24:32:46.914
试编码这些东西，是真正能让你在这方面成功的东西。

17852
24:32:46.914 --> 24:32:48.373
好吧，太棒了。

17853
24:32:48.373 --> 24:32:52.656
现在我们有了部署Betson，是时候编写一些测试了。

17854
24:32:52.656 --> 24:32:58.111
现在，如果你去到与这门课程相关的GitHub repo，你去到测试文件

17855
24:32:58.111 --> 24:33:03.566
夹，测试这里有一些健壮的，实际上我们所有的项目都写过，这里有很多测试。

17856
24:33:03.566 --> 24:33:09.682
这里的几乎所有东西，我们都已经学过了你们也已经知道怎么做了你们有能力去做。

17857
24:33:09.682 --> 24:33:13.765
我要继续，让你们开始，我们要一起写一个测试。

17858
24:33:13.765 --> 24:33:22.435
然后我强烈建议你回去，你试着自己写一些测试，让代码覆盖率让测试覆盖率达到100%。

17859
24:33:22.435 --> 24:33:28.583
让我们继续，我们将一起编写一个测试，然后你应该暂停这个视频，试着自己编写一些测试。

17860
24:33:28.583 --> 24:33:35.476
当您完成了编写测试，并且认为自己已经达到了100%时，请随意与我们编写的测试进行比较。

17861
24:33:35.476 --> 24:33:40.459
让我们创建一个名为tests的新文件夹。

17862
24:33:40.459 --> 24:33:41.052
测试。

17863
24:33:41.052 --> 24:33:43.866
在这里，我们要做一个新的单位。

17864
24:33:43.866 --> 24:33:48.817
如果你想稍后再写分段测试，你完全可以，我们不会。

17865
24:33:48.883 --> 24:33:54.883
我们会在这里创建一个新文件叫做NFT marketplace。

17866
24:33:54.883 --> 24:33:55.327
测试。

17867
24:33:55.883 --> 24:33:58.709
我们会开始做一些测试

17868
24:34:00.883 --> 24:34:07.849
cert, expect = require Chai const。

17869
24:34:11.883 --> 24:34:19.340
以太，等于需要硬帽const开发链等

17870
24:34:19.340 --> 24:34:26.798
于需要点。点。斜杠助手，急性子配置。

17871
24:34:26.883 --> 24:34:29.514
我们要做和之前一样的安排。

17872
24:34:29.883 --> 24:34:37.049
说bang发展链点包括网络

17873
24:34:37.049 --> 24:34:44.216
点名称、问号、描述点跳过。

17874
24:34:44.216 --> 24:34:46.549
其他描述。

17875
24:34:46.549 --> 24:34:49.971
如果nft市场测试，

17876
24:34:49.971 --> 24:34:57.843
逗号async函数，不好意思，这只是一个函数。

17877
24:34:57.843 --> 24:35:02.464
Scrabble oval只是一个函数，而不是一个异步函数，像这样。

17878
24:35:02.464 --> 24:35:02.851
太好了。

17879
24:35:02.851 --> 24:35:07.124
现在我们取一些变量，在每个变量之前做a。

17880
24:35:07.124 --> 24:35:14.470
我们说NF T市场，基本的NF T，我们会创造一个不变的价格。

17881
24:35:14.470 --> 24:35:18.427
我们总是将所有NF T的价格设为相同。

17882
24:35:18.427 --> 24:35:23.868
这将是ether。utils。parse ether 0。

17883
24:35:23.868 --> 24:35:24.008
1.

17884
24:35:24.008 --> 24:35:31.461
我们说const令牌ID现在总是0。

17885
24:35:31.884 --> 24:35:38.759
然后我们在每个将是一个async函数之前。

17886
24:35:38.884 --> 24:35:44.222
我们会出去的，我们也会救出迪布耶尔。

17887
24:35:45.884 --> 24:35:48.902
等号等待，获得命名帐户。

17888
24:35:50.884 --> 24:35:59.074
抓取从硬帽子进入帐户，以及把这一切。部署器Excel，然后我们也会在我们的心帽子。

17889
24:35:59.074 --> 24:35:59.454
配置。

17890
24:35:59.454 --> 24:35:59.580
js。

17891
24:35:59.580 --> 24:36:03.503
在get named accounts下面，我们还有一个叫做player的东西。

17892
24:36:03.503 --> 24:36:05.312
这个我没有讲太多。

17893
24:36:05.312 --> 24:36:10.225
但是我们会有第二个账户它被默认为第一个索

17894
24:36:10.225 --> 24:36:15.384
引，对吧?所以我们可以在顶部做上来的玩家。

17895
24:36:15.384 --> 24:36:23.752
我们可以说，player = await getnames accounts。player。

17896
24:36:23.884 --> 24:36:29.384
现在我们有了一个玩家和一个部署者帐户来等待部署，这是固定的。

17897
24:36:29.384 --> 24:36:37.800
所有这些契约都会在deploy文件夹中运行。

17898
24:36:37.885 --> 24:36:39.726
我们将拥有我们的非功能性市场。

17899
24:36:41.885 --> 24:36:46.766
等待醚点得到合同和ft。

17900
24:36:46.766 --> 24:36:48.393
市场。

17901
24:36:49.885 --> 24:36:56.996
我们会做基本的NF t等于等待醚点得到合同。

17902
24:36:57.885 --> 24:36:58.212
NF T。

17903
24:37:02.885 --> 24:37:07.885
grab东西，无论帐户0是什么，也就是我们的部署者。

17904
24:37:07.885 --> 24:37:16.718
如果我们想在非ft市场上调用一个函数，玩家是调用函数的人，

17905
24:37:16.718 --> 24:37:25.248
我们就必须说，实体市场等于等待和空市场点连接玩家像这样。

17906
24:37:25.248 --> 24:37:31.588
现在，每当我们调用一个函数时，我们都会使用player而不是Deployer。

17907
24:37:31.588 --> 24:37:38.901
有时我喜欢做的是你们会在我的代码中看到，我要让非功能性市场契约。

17908
24:37:38.901 --> 24:37:41.790
然后让NFT市场，

17909
24:37:41.790 --> 24:37:48.212
然后我写NFT市场合约等于等待醚。合约。

17910
24:37:48.212 --> 24:37:52.456
然后我将把它连接到NF - T市场。

17911
24:37:52.456 --> 24:37:59.813
是的，我们可以这样做，我们可以自动选择谁连接谁想要连接写和得到合同。

17912
24:37:59.813 --> 24:38:02.099
但有时候直白一点真的很好。

17913
24:38:02.099 --> 24:38:03.072
所以这真的取决于你。

17914
24:38:03.072 --> 24:38:11.120
我将撤销所有这些，我只是想重新演示一下确保你们知道这是如何在不同的帐户和不同的用户之间切换的。

17915
24:38:11.120 --> 24:38:16.836
现在我们有了一个非功能性T，我们可能需要制造非功能性T，这样我们就可以把它投放到市场上。

17916
24:38:16.886 --> 24:38:23.508
所以我们会等待基本的NF T，然后我们会批准把它送到市场上。

17917
24:38:23.508 --> 24:38:24.753
我们先等一下。

17918
24:38:24.886 --> 24:38:30.636
基本NF T点批准和T市场地

17919
24:38:30.636 --> 24:38:36.386
点点地址令牌ID，这将是零。

17920
24:38:36.386 --> 24:38:42.886
就像这样，NOC市场记住，它不能要求批准，因为它不拥有NF t。

17921
24:38:42.886 --> 24:38:45.347
所以我们需要部署者。

17922
24:38:45.347 --> 24:38:46.869
电话通过了，对。

17923
24:38:46.869 --> 24:38:51.219
记住，因为我们不是我们需要在这里加入基本的NF T。

17924
24:38:51.219 --> 24:38:58.580
因为我们没有告诉ether谁来连接它它会自动连接到我们的部署者因为这是帐户0。

17925
24:38:58.580 --> 24:39:05.467
所以是由部署者调用并制造它然后由部署者批准将它发送到市场。

17926
24:39:05.467 --> 24:39:12.821
只有在这个被批准的功能被调用之后，才能将所有这些NFT的转移称为非功能性市场。

17927
24:39:12.821 --> 24:39:15.771
现在我们只做一个测试。

17928
24:39:15.771 --> 24:39:20.000
我们会说它可以被买到。

17929
24:39:20.000 --> 24:39:23.419
就是这样，这将是一个async函数。

17930
24:39:23.419 --> 24:39:30.486
我们打算把NFT上市然后买下一个举重实体市场。

17931
24:39:30.486 --> 24:39:38.066
如果我们去我们的能源市场，我们要做什么，我们要把它列出，我们要列出项目，或者用地址令牌ID和价格。

17932
24:39:38.066 --> 24:39:41.475
我们用。listitem。

17933
24:39:41.475 --> 24:39:47.368
基本的nft点地址，令牌ID为0，我们已经在这里定义了。

17934
24:39:47.368 --> 24:39:50.299
然后是价格，这里也有硬编码。

17935
24:39:50.299 --> 24:39:51.569
所以我们把它列出来。

17936
24:39:51.569 --> 24:39:59.628
所以部署者拥有NF T，玩家现在将其列在列表中，现在我们想要购买它，让玩家成为购买者。

17937
24:39:59.628 --> 24:40:05.430
所以我们要做的就是将玩家与非功能性市场连接起来。

17938
24:40:05.430 --> 24:40:09.799
所以我们可以说const player connected NF T,

17939
24:40:09.799 --> 24:40:14.543
marketplace =和ft marketplace。Connect。

17940
24:40:14.543 --> 24:40:15.199
的球员。

17941
24:40:15.199 --> 24:40:23.188
然后我们可以通过说一个重量播放器连接到ft市场来购买这个物品。

17942
24:40:23.188 --> 24:40:23.848
通过项目。

17943
24:40:23.848 --> 24:40:31.628
它将是最基本的，如果我们回头看市场的末端，购买物品需要什么，需要非ft地址和令牌ID。

17944
24:40:31.628 --> 24:40:37.412
因此，基本的NF和这个地址，然后是令牌ID，在这个机

17945
24:40:37.412 --> 24:40:43.420
器人之后，我们应该检查，看看玩家确实拥有那个NF团队。

17946
24:40:43.420 --> 24:40:48.980
所以我们可以说const new owner然后检查那个owner是否确实更新了。

17947
24:40:48.980 --> 24:40:56.441
我们可以说基本的NFT。owner of因为NFT有一个函

17948
24:40:56.441 --> 24:41:04.161
数的所有者，令牌ID然后我们还想看到部署者实际上会得到报酬。

17949
24:41:04.161 --> 24:41:11.744
我们可以说await和if T。get Deployer的收益。

17950
24:41:11.744 --> 24:41:20.338
现在我们可以断言new owner。2string

17951
24:41:20.338 --> 24:41:29.277
= player我们可以断言deployer收益。

17952
24:41:29.277 --> 24:41:31.820
字符串等于价格。

17953
24:41:31.820 --> 24:41:36.677
因为他们应该为此付出代价。

17954
24:41:36.677 --> 24:41:39.405
这是对的，实际上更简单一些。

17955
24:41:39.405 --> 24:41:42.173
而不是通过获取命名帐号来获取玩家。

17956
24:41:42.173 --> 24:41:45.157
直接从醚中获取会更容易一些。

17957
24:41:45.157 --> 24:41:51.129
我们写const accounts = await get signers。

17958
24:41:51.129 --> 24:41:56.975
然后我们将save player = 1的账户因为当我们连接

17959
24:41:56.975 --> 24:42:03.017
时，它期望它类型的账户然后get named账户是不同的类型。

17960
24:42:03.017 --> 24:42:05.316
哦，这样连接起来更简单一点。

17961
24:42:05.316 --> 24:42:10.841
现在我们要连接到player要知道player和deployer是不同类型的。

17962
24:42:10.841 --> 24:42:13.724
你会看到一些不同。

17963
24:42:13.724 --> 24:42:16.232
对我来说，是醚得到了签名者。

17964
24:42:16.232 --> 24:42:20.820
然后当我们买这个东西的时候，我们当然需要传递一

17965
24:42:20.820 --> 24:42:25.609
个值，它是价格，当然，我们需要支付NFT的价格。

17966
24:42:25.609 --> 24:42:28.316
当然，这需要是player。address。

17967
24:42:28.316 --> 24:42:33.870
这就是现在的区别我们需要player那个地址每当我们需要其中一个以太账户的地址时。

17968
24:42:33.870 --> 24:42:36.678
然后这个新主人，当然，应该在等待。

17969
24:42:36.678 --> 24:42:38.396
现在我们可以运行这一切了。

17970
24:42:38.396 --> 24:42:43.141
在多田，我们看着事情过去。

17971
24:42:43.141 --> 24:42:48.420
因此，我们的非功能性市场能够促

17972
24:42:48.420 --> 24:42:54.051
进任意人类对非功能性产品的买卖。

17973
24:42:54.051 --> 24:42:55.360
这太棒了。

17974
24:42:55.360 --> 24:43:01.755
所以我们只是运行了一个测试，以显示一点奇怪的工作时，与NF T和一些不同的帐户。

17975
24:43:01.755 --> 24:43:09.838
但是百分之百如果你已经准备好接受这个挑战，请暂停这个视频，试着写一些测试。

17976
24:43:09.838 --> 24:43:14.819
记住，这里的目标是为我们做纱线硬帽覆盖率，并看到我

17977
24:43:14.819 --> 24:43:19.800
们的覆盖率是什么，并试图得到它是100%的覆盖率。

17978
24:43:19.800 --> 24:43:25.951
如果我们现在播放，我们会看到天哪，我们遗漏了很多内容。

17979
24:43:25.951 --> 24:43:31.098
在这里，我们有大量未覆盖的行，在未覆盖的函数、分支、语句等之上。

17980
24:43:31.098 --> 24:43:37.529
尝试编写一些测试以使其达到100%，然后返回。

17981
24:43:37.529 --> 24:43:40.200
好了，欢迎回来。

17982
24:43:40.200 --> 24:43:43.269
希望现在您已经编写了一些测试。

17983
24:43:43.269 --> 24:43:47.139
当你做测试的时候，你可以得到其中的一些，我是这样的，对吧。

17984
24:43:47.139 --> 24:43:50.475
这些是我的测试，这些是我写的测试，你可以做更多，你可以做最后。

17985
24:43:50.475 --> 24:43:54.155
让我想想，当我写硬头纱报道时，我甚至漏掉了几行。

17986
24:43:54.155 --> 24:43:56.698
我可以再多测试一下。

17987
24:43:56.698 --> 24:43:59.281
所以你的测试要比我做的更好。

17988
24:43:59.281 --> 24:44:01.872
这些是来自GitHub回购的测试与此相关。

17989
24:44:01.872 --> 24:44:05.751
现在我们已经编写了一些测试，让我们编写几个脚本。

17990
24:44:05.751 --> 24:44:09.973
我们要写几个脚本的原因是我们稍后会用到这些。

17991
24:44:09.973 --> 24:44:14.668
所以我们会写一些脚本来创造，一些被NF T戏弄的东西等等。

17992
24:44:14.668 --> 24:44:19.630
我们稍后会用到这个在前端摆弄一下。

17993
24:44:19.630 --> 24:44:27.212
要创建一个脚本，我们已经执行过了，让我们创建一个名为mint的脚本，以及list。js。

17994
24:44:27.212 --> 24:44:30.134
这将在NFT铸币。

17995
24:44:30.134 --> 24:44:33.986
然后马上上市了。

17996
24:44:33.986 --> 24:44:39.269
让我们创建一个名为mint和list的异步函数。

17997
24:44:39.269 --> 24:44:45.298
在下面，我们将调用mint然后用我们一直在做的脚本复制粘贴列表。

17998
24:44:45.298 --> 24:44:48.650
很明显，我们不叫它Maine，而是叫它mountain list。

17999
24:44:48.650 --> 24:44:55.503
在这个山地列表中，它是一个常数，NFT标记，

18000
24:44:55.503 --> 24:45:01.734
在茶叶市场中，位置等于等待醚点得到合约。

18001
24:45:01.890 --> 24:45:03.441
和金融市场。

18002
24:45:06.890 --> 24:45:07.499
从安全帽。

18003
24:45:07.499 --> 24:45:09.374
然后我们取基本的NF - t。

18004
24:45:09.890 --> 24:45:10.890
表示常量。

18005
24:45:15.890 --> 24:45:16.676
合同。

18006
24:45:16.676 --> 24:45:17.757
基本NF t。

18007
24:45:22.890 --> 24:45:26.988
我们用console。log，保持在顶部。

18008
24:45:27.890 --> 24:45:30.973
做一个权值，或者我们用const。

18009
24:45:32.890 --> 24:45:35.690
基本NF T点薄荷NF T。

18010
24:45:39.890 --> 24:45:41.675
等等，等一个街区。

18011
24:45:41.675 --> 24:45:44.264
实际上我们要说的是const。

18012
24:45:44.890 --> 24:45:45.890
TX收据。

18013
24:45:45.890 --> 24:45:47.890
所以这个等于这个。

18014
24:45:50.890 --> 24:45:52.740
这也是为什么赛事如此精彩的原因。

18015
24:45:53.890 --> 24:45:59.723
我们在这个文档ID事件中省略了一个事件中的令牌ID。

18016
24:45:59.723 --> 24:46:04.826
我们可以说const令牌ID = mint

18017
24:46:04.826 --> 24:46:10.660
TX receipt。events of 0。

18018
24:46:10.660 --> 24:46:13.905
args。token Id是这样的。

18019
24:46:13.905 --> 24:46:15.906
现在我们有了令牌ID。

18020
24:46:15.906 --> 24:46:18.690
现在我们有了令牌ID和基本的非ft。

18021
24:46:18.690 --> 24:46:22.290
我们现在可以调用我们的非ft市场列表项目。

18022
24:46:22.290 --> 24:46:25.590
现在我们写入console。log。

18023
24:46:25.590 --> 24:46:29.382
批准非功能性测试，和我们这里的测试很相似。

18024
24:46:29.382 --> 24:46:35.760
我要说const approval TX = await basic NFT data

18025
24:46:35.760 --> 24:46:43.473
prove NFT marketplace。address token ID然后我们会做一个weight

18026
24:46:43.473 --> 24:46:50.891
ight approved TX。wait 1然后我们会做console。log listing NFT。

18027
24:46:50.891 --> 24:46:56.906
然后我们会做const TX = await如果T market

18028
24:46:56.906 --> 24:47:04.236
marketplace那个列表项我们会做NFT marketplace那个地址

18029
24:47:04.236 --> 24:47:11.568
个地址所以Id可以做await TX。wait one，控制台。log列表，很酷。

18030
24:47:11.568 --> 24:47:16.027
我们可以通过运行yarn hardhat node来验

18031
24:47:16.027 --> 24:47:20.652
证这个，它会运行我们的部署脚本，它会运行到这些部署脚本。

18032
24:47:20.652 --> 24:47:25.405
然后在一个新的终端，我们会运行我们的脚本，yarn

18033
24:47:25.405 --> 24:47:31.491
hard hat，运行脚本，列出破折号网络localhost。

18034
24:47:31.491 --> 24:47:36.908
我们错过了一个论点，我们还需要一个价格来列出我们的实体。

18035
24:47:36.908 --> 24:47:37.682
因此，

18036
24:47:37.682 --> 24:47:48.779
我们创建一个常数价格等于我们写入ether。utils。parse, ether 0。

18037
24:47:48.779 --> 24:47:48.937
1.

18038
24:47:48.937 --> 24:47:53.197
然后我们将价格和传递给列表项。

18039
24:47:53.197 --> 24:47:57.583
哦，抱歉，这不是我们要上市的市场，当然

18040
24:47:57.583 --> 24:48:02.201
是我们要上市的基本NF t，再运行一遍。

18041
24:48:02.201 --> 24:48:05.448
Bada bing, Bada boom，列出了一些事件。

18042
24:48:05.448 --> 24:48:08.891
我们可以看到，我们在做一些清单，很好。

18043
24:48:08.891 --> 24:48:10.181
现在我们有了一个脚本。

18044
24:48:10.181 --> 24:48:17.452
好了，现在我们有了一个脚本，稍后我们还会写几个其他的脚本，

18045
24:48:17.452 --> 24:48:24.222
我们基本上有了一个非常可靠的回购这是我们完全去中心化的

18046
24:48:24.222 --> 24:48:31.746
金融市场，这绝对是巨大的，你们应该为自己感到非常非常自豪。

18047
24:48:31.892 --> 24:48:33.576
当然，这些都是代码。

18048
24:48:34.892 --> 24:48:38.569
有了这个，如果他们是软件开发人员，这很好。

18049
24:48:38.892 --> 24:48:45.825
我们想让任何人都能在我们的市场上进行互动，列出他们自己的NF - t。

18050
24:48:45.825 --> 24:48:51.098
那我们要怎么做呢?我们要为它做一个前端。

18051
24:48:51.098 --> 24:48:54.360
现在我们要进入这节课的第二部分。

18052
24:48:54.360 --> 24:48:57.953
第十五课，我们刚讲了后端。

18053
24:48:57.953 --> 24:49:01.793
现在我们来看看前面，我们从这个沼泽代码开始。

18054
24:49:01.793 --> 24:49:06.197
这两个程序的代码几乎完全相同。

18055
24:49:06.197 --> 24:49:09.315
但我们将从莫拉莱斯开始，我们将教你如何做这两件事。

18056
24:49:09.315 --> 24:49:12.247
我们会教你们莫拉莱斯和莫图的区别。

18057
24:49:12.247 --> 24:49:16.925
我们一开始为什么要用它们，我们从莫拉莱斯开始。

18058
24:49:16.925 --> 24:49:23.463
如果你想继续下一节的内容，我们要用到的所有代码，都在这里。

18059
24:49:23.463 --> 24:49:28.886
所以你们很兴奋，我希望你们很兴奋，因为这将是一个非凡的会议，

18060
24:49:28.886 --> 24:49:34.130
我们将建立一个最复杂的前端，我们可以使用我们所拥有的工具。

18061
24:49:34.130 --> 24:49:37.334
就像我说的，我们之前向你们展示过这是什么样子的。

18062
24:49:37.334 --> 24:49:39.055
让我们快速复习一下。

18063
24:49:39.055 --> 24:49:41.613
这就是前端的样子。

18064
24:49:41.613 --> 24:49:47.954
但我们能做的是用连接按钮连接，我们点击Metamask, Metamask弹出，我们继续连接。

18065
24:49:47.954 --> 24:49:53.203
现在我们连接起来了，我们可以看到不同的NF T在这里。

18066
24:49:53.203 --> 24:49:57.831
如果我们在一个属于我们的地址上，它会显示为你所有。

18067
24:49:57.893 --> 24:50:02.565
如果我们交换地址，我将继续更新，连接到那里。

18068
24:50:02.565 --> 24:50:04.789
现在我们的地址不一样了。

18069
24:50:04.893 --> 24:50:07.617
如果它是我们的，我们会看到这个小的盘旋，上面写着Update listing。

18070
24:50:07.617 --> 24:50:09.013
现在它值0。

18071
24:50:09.013 --> 24:50:09.116
18.

18072
24:50:09.116 --> 24:50:12.854
我们的市场上就是这么标价的。

18073
24:50:12.854 --> 24:50:16.842
如果它是我们的，我们点击它，就可以更新到不同的价格。

18074
24:50:16.893 --> 24:50:22.840
让我们将其更新到50每先令，或无论你的第一层货币是什么，我们将节省新的上市价格。

18075
24:50:22.840 --> 24:50:24.375
我们去确认一下。

18076
24:50:24.375 --> 24:50:28.859
我会说，列表更新了，请刷新，我们能做什么。

18077
24:50:28.859 --> 24:50:33.343
我们在后面挖一些区块，嘣，现在我们看到它值50。

18078
24:50:33.343 --> 24:50:39.765
如果我们切换到另一个账户，我们可以看到所有者是Baba blah，

18079
24:50:39.765 --> 24:50:45.993
此时盘旋显示，由我足够被选为另一个用户，我将通过这个交易购买它。

18080
24:50:45.993 --> 24:50:49.618
现在请确认我是否要买，我就会看到一个小弹出框。

18081
24:50:49.618 --> 24:50:51.214
这是购买成功的项目。

18082
24:50:51.214 --> 24:50:58.893
现在如果我稍微刷新一下，我们就会看到NFT从市场上消失了，因为我们正确地购买了它，它不再可以出售。

18083
24:50:58.893 --> 24:51:02.532
现在我们能做的就是过来卖NF t恤。

18084
24:51:02.532 --> 24:51:06.508
在底部，我们会看到提取收益。

18085
24:51:06.508 --> 24:51:14.793
所以当有人购买NFT时，NFT市场实际上保留了收益实际上保留了销售的结果。

18086
24:51:14.793 --> 24:51:17.670
因此，如果我们切换回列出NFT的地址，

18087
24:51:17.670 --> 24:51:24.030
我们现在可以看到提取50收益，因为我们知道我们每人有50，因为我们刚刚以50买了它。

18088
24:51:24.030 --> 24:51:30.447
如果我们点击取款，Metamask就会弹出，我们可以继续

18089
24:51:30.447 --> 24:51:37.094
确认，等待一会，交易填充，一旦它通过，我们就会看到零收益。

18090
24:51:37.094 --> 24:51:39.760
对吧?我们把这里的一切都撤走了。

18091
24:51:39.894 --> 24:51:42.168
所以我们现在能做的就是重新列出非功能性。

18092
24:51:42.894 --> 24:51:50.790
回到刚刚以T买下它的那个如果我们知道nnf T的地址和令牌ID并且我们

18093
24:51:50.790 --> 24:51:58.687
拥有它，我们可以继续重新上市你会把地址和令牌ID放在这里给它一个价格。

18094
24:51:58.687 --> 24:52:05.481
我们会提交，我们会批准让非功能性市场进入我们的或非功能性的，我们的小狗。

18095
24:52:05.481 --> 24:52:09.821
然后我们会发送交易，

18096
24:52:09.821 --> 24:52:15.465
让NFT在市场上成功上市。

18097
24:52:15.465 --> 24:52:19.506
当我们在后端移动一些块后，我们可以回到前端。

18098
24:52:19.506 --> 24:52:25.598
我们现在看到，它归我们所有，而不是原来的主人，对吧，设为10以太币。

18099
24:52:25.598 --> 24:52:32.539
然后我们当然可以切换回不同的用户，我们可以让他们真正购买。

18100
24:52:32.539 --> 24:52:39.227
好了，现在我们有了合同，我们知道合同这一边是什么样子的。

18101
24:52:39.227 --> 24:52:42.168
现在我们来看看如何在前面做这个。

18102
24:52:42.168 --> 24:52:44.163
让我们进入代码编辑器。

18103
24:52:44.163 --> 24:52:49.281
如果我们戴着安全帽，带着我的NFT市场免费代码营文件夹，就开始吧。

18104
24:52:49.281 --> 24:52:50.119
太好了。

18105
24:52:50.119 --> 24:52:53.336
但我们要创建另一个文件夹，我们要下到CD和目录。

18106
24:52:53.336 --> 24:52:55.303
我们要创建一个新目录。

18107
24:52:55.303 --> 24:53:00.962
我称它为下一个Jas，如果T marketplace dash FCC。

18108
24:53:00.962 --> 24:53:05.401
现在你可以做下一个Jas市场dash mirallas FCC，如果你想的话。

18109
24:53:05.401 --> 24:53:10.582
再一次，我们开始与mirallas CD下Jas非ft市场FCC。

18110
24:53:10.582 --> 24:53:19.270
现在我们有了这个文件夹，点击code。打开一个新的VS code，或者你也可以点击File open folder打开这个新文件夹。

18111
24:53:19.270 --> 24:53:22.520
我们可以在这个新文件夹中开始工作。

18112
24:53:22.520 --> 24:53:29.040
现在我们在我们的新项目中，我们在我们的新文件夹中，我们要做我们之前做过的事情。

18113
24:53:29.040 --> 24:53:31.485
Yarn创建下一个应用，句号。

18114
24:53:31.485 --> 24:53:34.632
好的，我们已经完成了我们的设置。

18115
24:53:34.632 --> 24:53:36.963
现在，我不喜欢棉绒。

18116
24:53:36.963 --> 24:53:38.228
我还是要把它删掉。

18117
24:53:38.228 --> 24:53:43.153
我们要加入的是更漂亮的东西。

18118
24:53:43.153 --> 24:53:44.808
所以更漂亮的，忽略更漂亮的RC。

18119
24:53:44.808 --> 24:53:49.927
同样，有些人可能会强烈反对我的观点，但每个人都有自己的权利，这就是我喜欢做的事。

18120
24:53:49.927 --> 24:53:51.024
这就是我要做的。

18121
24:53:51.024 --> 24:53:56.126
现在我们有了一个极简反应项目，对吧?如果我们运行yarn

18122
24:53:56.126 --> 24:54:01.957
Dev，我们打开那个站点上的UI，复制这个，或者命令，点击它。

18123
24:54:01.957 --> 24:54:02.269
这样。

18124
24:54:02.269 --> 24:54:03.269
欢迎收看下一期节目。

18125
24:54:03.269 --> 24:54:06.145
是的，我们有一个xjs应用程序。

18126
24:54:06.145 --> 24:54:09.504
我们知道，我们去页面，我们去索引。

18127
24:54:09.504 --> 24:54:09.660
js。

18128
24:54:09.895 --> 24:54:13.452
把这里的都删掉。

18129
24:54:16.895 --> 24:54:20.109
如果有东西，头会写嗨，感叹号。

18130
24:54:20.109 --> 24:54:21.555
我们会拯救，我们会回来。

18131
24:54:21.555 --> 24:54:22.519
现在我们看到Hi。

18132
24:54:22.519 --> 24:54:24.366
我放大一大堆。

18133
24:54:24.366 --> 24:54:24.649
繁荣。

18134
24:54:24.649 --> 24:54:28.791
现在我们有了一些极简的反应下一个，Jas。

18135
24:54:28.791 --> 24:54:31.640
我知道我们已经开始这个项目了。

18136
24:54:31.640 --> 24:54:34.104
让我们跳到自述文件。

18137
24:54:34.104 --> 24:54:39.028
我们来讨论一下我们想怎么做我们想让它看起来是什么样的。

18138
24:54:39.028 --> 24:54:41.640
我们要做一个主页。

18139
24:54:41.640 --> 24:54:47.693
在这个主页上，我们会说，我们会让它显示最近上市的，NFT的主页

18140
24:54:47.693 --> 24:54:53.942
会显示最近上市的实体，它会说，如果你拥有NFT，你可以更新列表。

18141
24:54:53.942 --> 24:54:56.219
如果没有，您可以购买该列表。

18142
24:54:56.219 --> 24:54:57.095
我们会得到这个。

18143
24:54:57.095 --> 24:54:58.571
然后我们会有一个销售页面。

18144
24:54:58.571 --> 24:55:03.114
在这个页面上，你可以在市场上列出你的非ft。

18145
24:55:03.114 --> 24:55:07.137
这将是我们的两个主页，我们将有一个主页和一个销售页面。

18146
24:55:07.137 --> 24:55:11.292
现在我们有很多组件，但我们实际上只有两个主页。

18147
24:55:11.292 --> 24:55:15.867
回到Pages，现在我们有apps。js，它

18148
24:55:15.867 --> 24:55:20.650
服务于我们的app，很酷，所有东西都贯穿其中。

18149
24:55:20.650 --> 24:55:21.633
然后是我们的主页。

18150
24:55:21.633 --> 24:55:27.797
我们现在也来创建，我们的销售页面或者说销售T·j。

18151
24:55:27.896 --> 24:55:35.831
然后在这里，我们把这个最小化，这样我们就可以复制这里的大部分内容，实际上我们可以复制粘贴这整个东西，粘贴到这里。

18152
24:55:35.831 --> 24:55:38.896
我们用卖出页来代替高价。

18153
24:55:38.896 --> 24:55:40.580
我们把它保存起来。

18154
24:55:40.580 --> 24:55:45.605
现在如果我们去我们的本地主机做债务削减出售。

18155
24:55:45.605 --> 24:55:48.314
如果T出现了，我们就得跑了。

18156
24:55:48.314 --> 24:55:49.830
再运行前端。

18157
24:55:49.830 --> 24:55:50.518
与纱线Dev。

18158
24:55:50.518 --> 24:55:52.229
对不起，我们再运行纱线开发。

18159
24:55:52.229 --> 24:55:53.229
现在我们刷新。

18160
24:55:53.229 --> 24:55:55.162
现在我们可以看到销售页面了。

18161
24:55:55.162 --> 24:55:59.149
出售页面，也就是斜杠出售页面，然后首页就会很高。

18162
24:55:59.149 --> 24:55:59.847
好的,很酷。

18163
24:55:59.847 --> 24:56:01.434
我们有了两页。

18164
24:56:01.434 --> 24:56:06.626
我们应该先做哪一个?好了，让我们开始做主页吧。

18165
24:56:06.626 --> 24:56:08.811
所以我们在索引中。

18166
24:56:08.811 --> 24:56:08.912
js。

18167
24:56:08.912 --> 24:56:16.654
我要保持前端的运行，我们要隐藏它哦，这是隐藏它的对立面，把它压下去，我们要像这样隐藏它。

18168
24:56:16.654 --> 24:56:19.025
让我们继续，让我们开始建造这个。

18169
24:56:19.025 --> 24:56:24.053
在index js中，我们有一些头部的东西，我要把这个改成NFT。

18170
24:56:24.053 --> 24:56:25.316
市场。

18171
24:56:25.316 --> 24:56:32.706
描述将只是一个空洞的市场。

18172
24:56:32.897 --> 24:56:34.574
Fabcon看起来很棒。

18173
24:56:36.897 --> 24:56:39.845
上面写着NFT市场，这很好。

18174
24:56:40.897 --> 24:56:41.509
这就是我们想要的。

18175
24:56:42.897 --> 24:56:48.312
我们总要做的第一件事是什么?你猜对了，我们需要一个连接按钮，

18176
24:56:48.312 --> 24:56:53.547
对吧?我们需要我们的用户能够连接到web 3连接到区块链。

18177
24:56:53.547 --> 24:56:55.388
和我们之前做的一样。

18178
24:56:55.388 --> 24:56:57.473
我们来创建一个组件文件夹。

18179
24:56:57.473 --> 24:57:05.054
我们会创建一个头组件组件Nance文件夹我们会创建一个新文件头摘要。

18180
24:57:05.054 --> 24:57:13.542
记住，因为我们之前做过这个，用我们的前端彩票代码，当我们构建这个时，我们总是可以引用彩票代码。

18181
24:57:13.542 --> 24:57:17.634
当然，我们在GitHub回购上有所有的代码。

18182
24:57:17.634 --> 24:57:22.836
你们可以用它我不会让你们都做的是上节课，我们做了手动头文件的事情，

18183
24:57:22.836 --> 24:57:28.039
对吧，我们要做所有的本地存储和所有那些疯狂的事情，我们不会做那些。

18184
24:57:28.039 --> 24:57:32.445
这次，我们用简单的方法，我们用web3uikit。

18185
24:57:32.445 --> 24:57:36.230
为了使用这个连接按钮，我们要做纱线，添加。

18186
24:57:36.230 --> 24:57:40.715
我们不打算做dash Dev，因为这个连接按钮是

18187
24:57:40.715 --> 24:57:45.388
前端的必要组件，yarn通过uikit添加web。

18188
24:57:45.388 --> 24:57:50.117
这也意味着我们要用Morales反应mirallas。

18189
24:57:50.117 --> 24:57:53.727
我说，这可能有点让人困惑。

18190
24:57:53.727 --> 24:57:59.077
我知道我在这里说过我们有莫拉莱斯和其他图表版本。

18191
24:57:59.077 --> 24:58:02.642
所以我们仍然会在这两种情况下使用莫拉莱斯包。

18192
24:58:02.642 --> 24:58:07.015
唯一不同的是，我们将在我们的莫拉莱斯版本中使用一个莫拉莱斯服务器。

18193
24:58:07.015 --> 24:58:12.831
我们不会在图表版本中使用士气服务器，它们都可以使用Morales包因为

18194
24:58:12.831 --> 24:58:18.648
所有的开源钩子和工具仍然非常强大，即使我们不使用Morales服务器。

18195
24:58:18.648 --> 24:58:22.270
所以我们还是要用莫拉莱斯集合即使我们要用这个图。

18196
24:58:22.270 --> 24:58:22.575
太好了。

18197
24:58:22.575 --> 24:58:28.460
现在我们把它们都加起来了，我们要做的和之前的Jas反应一样。

18198
24:58:28.460 --> 24:58:34.358
为了通过app中的UI组件使用我们的web，点j

18199
24:58:34.358 --> 24:58:40.502
s，并导入mirallas provider引号抱

18200
24:58:40.502 --> 24:58:47.139
歉，还有花括号，它来自react mirallas。

18201
24:58:47.139 --> 24:58:52.516
然后我们将把整个组件封装到morass provider中。

18202
24:58:52.516 --> 24:59:00.107
我们要返回，这里有小的左括号，这里有小的右括号。

18203
24:59:00.107 --> 24:59:03.338
我们要进行查房。

18204
24:59:03.338 --> 24:59:05.450
然后我们要做的是，

18205
24:59:05.450 --> 24:59:15.075
如果她在Mount上盟军将等于false，因为我们还不打算使用服务器，或者提供者。

18206
24:59:15.075 --> 24:59:15.607
好的,很酷。

18207
24:59:15.607 --> 24:59:23.102
现在我们已经在Morales提供程序中包装了我们的应用，回到我们的头部，我们会说Export

18208
24:59:23.102 --> 24:59:30.598
default function header，我们会从你的eye kit中抓取连接按钮。

18209
24:59:30.598 --> 24:59:36.357
我们会从web3uitkit导入连接按钮。

18210
24:59:36.357 --> 24:59:41.635
然后在这里，我们会说返回。

18211
24:59:41.635 --> 24:59:43.285
下一个按钮。

18212
24:59:43.285 --> 24:59:45.736
现在我们能在应用J中做什么。

18213
24:59:45.736 --> 24:59:50.479
S，我们可以输入导入，输入header from。。/

18214
24:59:50.479 --> 24:59:58.737
components header，我们有header，我们把header放在组件的正上方。

18215
24:59:58.737 --> 25:00:02.157
我们会在标题中添加一些东西。

18216
25:00:02.157 --> 25:00:04.320
我们要确保导入的头文件正确。

18217
25:00:04.320 --> 25:00:05.679
回到UI。

18218
25:00:05.679 --> 25:00:07.833
好了，我们有了连接按钮。

18219
25:00:07.833 --> 25:00:10.560
如果我们点击它，就会弹出这个小窗口。

18220
25:00:10.560 --> 25:00:11.678
我放大了。

18221
25:00:11.678 --> 25:00:14.649
我要把它放大。

18222
25:00:14.899 --> 25:00:20.127
现在，我们还想在头文件中放入什么呢?我们可能会给它起个名字让它看起

18223
25:00:20.127 --> 25:00:25.356
来更好看一些，可能还会给我们的cell NF - T页面一个链接。

18224
25:00:25.356 --> 25:00:27.474
我们来创建一个导航栏。

18225
25:00:27.474 --> 25:00:33.632
除了返回连接按钮，把这个放在括号里我们还会返回一些其他的东西。

18226
25:00:33.632 --> 25:00:37.834
我们可以使用这个nav标签，它通常定义一个导航栏。

18227
25:00:37.899 --> 25:00:41.222
它和div很像，只是另一个标签。

18228
25:00:41.899 --> 25:00:43.999
现在我们把所有东西都放到nav标签里。

18229
25:00:44.899 --> 25:00:50.899
我们可以使用下一个Jas链接标签来链接。

18230
25:00:51.899 --> 25:01:00.011
这个链接允许我们连接到应用中不同的链接或url，像这样。

18231
25:01:00.011 --> 25:01:04.850
我们可以输入import link from next / link。

18232
25:01:04.850 --> 25:01:11.823
在这里，如果我们想让它到主页，我们可以做一个链接。

18233
25:01:11.899 --> 25:01:17.149
我们说h ref =斜杠=斜杠。

18234
25:01:18.899 --> 25:01:23.495
这个，我们把它包装在一个a标签中，使它可点击。

18235
25:01:23.899 --> 25:01:28.039
那么我们就可以说非功能性市场。

18236
25:01:28.899 --> 25:01:37.794
保存下来，我们到我们的前端，我们现在看到有一个非ft市场按钮，我们可以点击，因为我们已经在家里，我们不打算去任何地方。

18237
25:01:37.794 --> 25:01:43.566
但如果我们复制这个链接，粘贴到下面，我们为cell和f t创建另一个链接。

18238
25:01:43.566 --> 25:01:46.232
我们把这个细胞命名为NF t。

18239
25:01:46.232 --> 25:01:53.566
现在我们保存，回到我们的前端，我们现在有非ft市场，出售非ft如果我点

18240
25:01:53.566 --> 25:02:00.900
击出售NFT我们现在就会进入出售页面我们会回到主页出售页面，来回翻转。

18241
25:02:00.900 --> 25:02:02.752
太棒了，非常令人兴奋。

18242
25:02:02.752 --> 25:02:07.807
现在我们有了一个极简的标题显然看起来很糟糕。

18243
25:02:07.807 --> 25:02:10.426
我们来做一点格式化。

18244
25:02:10.426 --> 25:02:12.794
通常你会在最后进行格式化。

18245
25:02:12.900 --> 25:02:20.838
但是既然我们在这里，我们也可以做我们的格式我们要用如果你猜的是顺风呢?你猜对了。

18246
25:02:20.900 --> 25:02:23.141
所以记住，顺风。

18247
25:02:23.141 --> 25:02:23.572
下一个。

18248
25:02:25.900 --> 25:02:26.779
跟着这里走。

18249
25:02:28.900 --> 25:02:34.114
我们之前做过的事情，我们会做纱线，添加dash Dev，就是这里的东西。

18250
25:02:34.114 --> 25:02:37.952
然后我们将运行针织后，这些完成安装。

18251
25:02:37.952 --> 25:02:42.267
我们先做纱线，然后粘贴进去。

18252
25:02:42.267 --> 25:02:43.633
好了。

18253
25:02:43.633 --> 25:02:48.166
现在我们有了post CSS配置，我们有了tailwind配置。

18254
25:02:48.166 --> 25:02:50.099
我们要抓住顺风。

18255
25:02:50.099 --> 25:02:50.499
配置。

18256
25:02:50.499 --> 25:02:50.632
js。

18257
25:02:50.900 --> 25:02:51.915
粘贴到这里。

18258
25:02:54.900 --> 25:02:58.833
打开Global的。css，粘贴进去，冷却。

18259
25:02:58.900 --> 25:03:00.323
现在我们有顺风了。

18260
25:03:01.900 --> 25:03:05.003
可以在我们的头部做一些顺风动作。

18261
25:03:05.900 --> 25:03:12.128
为这里的所有东西创建一个div，我们会为这里的所有东西创建一个小div，

18262
25:03:12.128 --> 25:03:18.356
我们会为一个大的部分，几乎像一个大的标志，说，嘿，你在NFC市场，h1，

18263
25:03:18.356 --> 25:03:24.933
代表header 1，我们会给它一个类名padding y of form。

18264
25:03:24.933 --> 25:03:27.480
填充x = 4，

18265
25:03:27.480 --> 25:03:34.805
字体加粗文本是3xl，然后它会说，非ft市场。

18266
25:03:34.805 --> 25:03:37.454
现在我们有了非ft市场，这是一个很好的螺栓。

18267
25:03:37.454 --> 25:03:37.946
太棒了。

18268
25:03:37.946 --> 25:03:44.377
如果你在服务器上，你会用Ctrl C杀死它，然后我们会重启它。

18269
25:03:44.377 --> 25:03:46.805
这就会把所有的顺风都拉进来。

18270
25:03:46.901 --> 25:03:52.017
现在如果我们刷新local main，我们现在应该会看到，

18271
25:03:52.017 --> 25:03:58.722
如果T和F c r得到了位置，我们现在可以看到这个又大又粗的，看起来好多了。

18272
25:03:58.722 --> 25:03:59.793
我们继续。

18273
25:03:59.901 --> 25:04:02.409
让我们给整个导航起一个类名。

18274
25:04:03.901 --> 25:04:09.982
填充五，边框底部要伸缩行

18275
25:04:09.982 --> 25:04:16.064
对齐，如果n项之间居中。

18276
25:04:16.064 --> 25:04:18.523
我们来看看结果如何。

18277
25:04:18.523 --> 25:04:20.511
哈哈，看起来好多了。

18278
25:04:20.511 --> 25:04:27.460
我们现在设置的是底部边框之类的东西像这样，看起来已经好很多了。

18279
25:04:27.460 --> 25:04:28.748
我们往下看。

18280
25:04:28.748 --> 25:04:36.336
让我们的按钮有一个类名= lax lax row items center。

18281
25:04:36.336 --> 25:04:39.863
就像我说的，这不是一门造型课。

18282
25:04:39.863 --> 25:04:43.432
我们不打算详细讲如何对它进行样式化。

18283
25:04:43.432 --> 25:04:44.251
这没什么。

18284
25:04:44.251 --> 25:04:47.918
但是这会把它移过去让它看起来更好看一些。

18285
25:04:47.918 --> 25:04:52.074
我们将在这里给出链接，类名等于Mr。

18286
25:04:52.074 --> 25:04:52.936
对于p6。

18287
25:04:52.936 --> 25:04:58.234
我们会给这两个相同的类名这两个链接，给它们一些

18288
25:04:58.234 --> 25:05:03.764
填充，让它们彼此远离一些右边距，让它们彼此远离。

18289
25:05:03.764 --> 25:05:08.252
哦，我忘了做这个，Morales off = false。

18290
25:05:08.252 --> 25:05:10.963
我们需要Morales auth = false，

18291
25:05:10.963 --> 25:05:17.687
这样我们就不会自动连接到Morales数据库或尝试连接到Morales数据库，当我们连接时，我们只想连接到Metamask。

18292
25:05:17.687 --> 25:05:20.768
我们将把它换成家庭而不是市场。

18293
25:05:20.768 --> 25:05:24.368
但除此之外，T Connect按钮在国内的销量看起来相当不错。

18294
25:05:24.368 --> 25:05:28.552
我们可以调整这个的格式让它看起来有点不同。

18295
25:05:28.552 --> 25:05:34.964
但我认为在大多数情况下，这个看起来好多了，对吧?好了，很酷，标题看起来好多了。

18296
25:05:34.964 --> 25:05:36.581
这是我们的应用程序。

18297
25:05:36.581 --> 25:05:39.683
Js设置与鼠标提供程序头组件。

18298
25:05:39.683 --> 25:05:42.104
现在让我们看看我们的索引。

18299
25:05:42.104 --> 25:05:47.838
现在让我们继续展示这些NF T展示我们市场上的所有NF T。

18300
25:05:47.902 --> 25:05:52.473
这就是它开始升温的地方变得非常有趣。

18301
25:05:52.473 --> 25:05:56.886
事实上，还有一件事，如果你还没有，我们将在索引中找到这个头饰。

18302
25:05:56.886 --> 25:06:00.783
我们会让它在应用JSX中。

18303
25:06:00.783 --> 25:06:02.562
我们的应用程序。

18304
25:06:02.562 --> 25:06:08.281
js中，我们会把那个头文件放在顶部，然后放一个小div。

18305
25:06:08.281 --> 25:06:12.789
Div，像这样围绕着整个东西。

18306
25:06:12.789 --> 25:06:13.998
这个放在这里。

18307
25:06:13.998 --> 25:06:19.521
这样一来，无论我们在哪个页面，我们总是会把这个作为标题。

18308
25:06:19.521 --> 25:06:21.870
我们不需要定义这里的每一个东西。

18309
25:06:21.902 --> 25:06:23.256
我们会进行刷新。

18310
25:06:23.256 --> 25:06:25.320
它说头没有定义。

18311
25:06:25.902 --> 25:06:29.919
这是因为我们需要从下一个斜杠头复制导入头。

18312
25:06:29.919 --> 25:06:33.666
将它粘贴到我们的应用，Jas从下一个头部导入头部。

18313
25:06:33.666 --> 25:06:38.837
现在我们可以看到，不管我们在哪个页面，我们都会清空市场，因为我们在应用程序层面定义了它。

18314
25:06:38.837 --> 25:06:44.225
这里有header，这里有这个，index几乎什么都没有。

18315
25:06:44.225 --> 25:06:45.169
让我们开始吧。

18316
25:06:45.169 --> 25:06:51.066
我们要怎么做呢?我们希望主页即我们的索引显示最近列出的非ft。

18317
25:06:51.066 --> 25:06:55.699
所以问题是，我们如何显示最近列出的NF t。

18318
25:06:55.699 --> 25:07:00.804
我们怎么做呢?好吧，让我们回到我们的合同上来。

18319
25:07:00.804 --> 25:07:06.091
我们回到我们的硬帽非金融市场，所以我们在看市场，我们在这里有什么?

18320
25:07:06.091 --> 25:07:11.379
我们如何实际看到非功能性物质存储在哪里?它们存储在这个列表映射中。

18321
25:07:11.379 --> 25:07:17.488
但是，我们如何看到这里所有的列表呢?这是一个映射，这意味着我们

18322
25:07:17.488 --> 25:07:23.597
有地球上的每一个地址在这里，我们不能遍历映射，我们必须遍历地球

18323
25:07:23.597 --> 25:07:30.103
上的每一个地址，这是一个疯狂的大数字你和我永远无法知道有多少地址。

18324
25:07:30.103 --> 25:07:36.785
那么我们有什么办法来解决这个问题呢?因为我们显然不会遍历所有东西。

18325
25:07:36.785 --> 25:07:41.666
那么我们该怎么办呢?第一个方法是什么，第一个方法之一是，

18326
25:07:41.666 --> 25:07:48.639
Patrick，我们为什么不创建一个数组，一个清单的数组呢，这可能是一个好方法。

18327
25:07:48.639 --> 25:07:54.192
但如果之后，我们还想得到一些其他奇怪的数据，也许我们想得到用户拥

18328
25:07:54.192 --> 25:07:59.745
有的所有NF t用户拥有的NF t，用户拥有的NF t没有数组。

18329
25:07:59.745 --> 25:08:02.236
这只是一个映射。

18330
25:08:02.236 --> 25:08:08.970
但如果我们想查询其他一些奇怪的数据，或者查询其他一些奇怪的数据，或者

18331
25:08:08.970 --> 25:08:15.904
一个数组会非常消耗气体，如果我们让这个数组进行循环，它会非常消耗气体。

18332
25:08:15.904 --> 25:08:18.182
所以我们不想回去改变。

18333
25:08:18.182 --> 25:08:20.356
我要把这个打出来。

18334
25:08:20.356 --> 25:08:21.827
因为这很重要。

18335
25:08:21.827 --> 25:08:27.817
我们不想仅仅为网站改变协议，我们不想仅仅为网

18336
25:08:27.817 --> 25:08:33.808
站改变协议，或者我们不想为网站改变太多协议。

18337
25:08:33.808 --> 25:08:38.454
因为如果我们把它做成一个数组，它会变得非常低效。

18338
25:08:38.454 --> 25:08:43.516
使用非金融市场将变得更加困难，因为它将变得更加昂贵。

18339
25:08:43.516 --> 25:08:51.822
当您构建越来越复杂的协议时，您将意识到为每个映射使用一个数组是不可行的。

18340
25:08:51.822 --> 25:08:56.281
这就是这些事件发挥作用的原因之一。

18341
25:08:56.281 --> 25:09:02.463
所以每次我们列出一个NF t，我们调用这个列表项函数。

18342
25:09:02.463 --> 25:09:07.029
我们省略了列项事件，列项事件存储在链上

18343
25:09:07.029 --> 25:09:11.836
的数据结构中，但只有智能合约可以访问它。

18344
25:09:11.836 --> 25:09:17.395
然而，猜猜什么不能访问它链外服务可以访问这些事件。

18345
25:09:17.395 --> 25:09:22.723
在这种情况下，我们要做的是，我们要做

18346
25:09:22.723 --> 25:09:28.348
的是索引链外的事件然后从数据库中读取。

18347
25:09:28.348 --> 25:09:35.887
我们要做的是设置一个服务器来监听那些被触发的事件。

18348
25:09:35.887 --> 25:09:39.493
我们将把它们添加到数据库中进行查询。

18349
25:09:39.493 --> 25:09:47.838
是的，我们会把每一项都列出来，我们会在数据库中为自己建立索引。

18350
25:09:47.904 --> 25:09:53.589
然后我们会调用我们的中央数据库来启动我们会调用那个数据库来完成这个。

18351
25:09:53.589 --> 25:09:59.214
现在的问题是，哇，这不是中心化吗?帕特里克，我

18352
25:09:59.214 --> 25:10:04.840
们说的不是中央集权吗?管他呢，答案是，不一定。

18353
25:10:04.905 --> 25:10:08.343
这个图就是这样一个协议。

18354
25:10:08.905 --> 25:10:15.146
该协议索引链外事件，并将它们插入到图协议中。

18355
25:10:15.146 --> 25:10:21.863
它以一种分散的方式来实现，莫拉莱斯，我们首先要展示的是一种集中的方式，莫拉莱

18356
25:10:21.863 --> 25:10:28.580
斯将以一种集中的方式来实现它，这可能是你想要加快速度的路线额外的铃铛和口哨，

18357
25:10:28.580 --> 25:10:35.476
这样你就可以进行本地开发，这就是我们这里要关注的，或者莫拉莱斯提供的其他功能。

18358
25:10:35.476 --> 25:10:37.837
因为莫拉莱斯做的远不止这些。

18359
25:10:37.837 --> 25:10:43.038
这也是要记住的，即使我们添加了一个集中的组件，或者逻辑，

18360
25:10:43.038 --> 25:10:47.869
我们的智能合约，这个应用程序的真正主体是去中心化的。

18361
25:10:47.869 --> 25:10:54.774
你可以通过这个去中心化的智能合约来验证你所有的交互，我们实际上已经使用了很多中

18362
25:10:54.774 --> 25:11:01.857
心化的协议，比如以太扫描，比如开放查看，其中一些中心化的协议对这个领域非常重要。

18363
25:11:01.905 --> 25:11:10.842
因此，我们向您展示Morales是为了让您熟悉如何使用这些集中式服务器之一，以防您想要创建一个提供集中式服务的应用程序。

18364
25:11:10.905 --> 25:11:19.114
在这个领域有大量的工具，比如打开和温柔防守等等，这些都是集中的，但给我们带来了巨大的好处。

18365
25:11:19.114 --> 25:11:22.262
作为一个社区，我们正在把越来越多的东西去中心化。

18366
25:11:22.262 --> 25:11:24.773
有时我们需要一些辅助工具才能到达那里。

18367
25:11:24.773 --> 25:11:31.387
然后是去中心化的方式，这是一个较长的过程，但当我们讲到那里，我们会解释所有的。

18368
25:11:31.387 --> 25:11:36.397
让我们学习一下如何在图中列出最近被列出的NF T和Morales。

18369
25:11:36.397 --> 25:11:41.551
两者都有一些非常不错的视频，我将在GitHub上留下一些相关的链接。

18370
25:11:41.551 --> 25:11:49.206
所以如果你想了解更多，你一定要看这两个视频，因为它们绝对很棒，会帮助你更好地理解这个事件。

18371
25:11:49.206 --> 25:11:53.898
通常，当我们从区块链读取时，我们会做一些类似于契约。

18372
25:11:53.898 --> 25:11:58.772
get, get列表的操作，然后我们把输入参数放进去。

18373
25:11:58.772 --> 25:12:05.856
契约双blah，取而代之的是，我们将从一个包含所有映射和更容易读取的数据结构的数据库中读取。

18374
25:12:05.906 --> 25:12:11.734
莫拉莱斯和图表都是这样做的。

18375
25:12:11.906 --> 25:12:13.872
我们一直在使用沼泽、开源包和工具。

18376
25:12:13.906 --> 25:12:20.855
然而，莫拉莱斯还可选择与服务器后端，给您的web三个应用程序更多的功能。

18377
25:12:20.906 --> 25:12:26.560
然而，有很多我们不会讲到的东西莫拉莱斯可以帮助你构建web三应用。

18378
25:12:26.560 --> 25:12:31.836
所以我不再继续谈论莫拉莱斯，以及它能做什么，我们请伊万来简要

18379
25:12:31.836 --> 25:12:37.112
概述一下莫拉莱斯能做的其他一些事情，我叫伊万，我来自拉利斯。

18380
25:12:37.112 --> 25:12:44.260
我在这里告诉你如何将你的开发速度提高10倍，我没有过分夸张，当你在创建一个东西时，你想要确保它

18381
25:12:44.260 --> 25:12:51.561
是可扩展的，因为你的DAP可能会走向全球，可能会像病毒一样传播，可能会成为主流，这是可能发生的。

18382
25:12:51.561 --> 25:13:00.388
如果这种情况发生了，你不想从头开始，你想使用工具和服务，让你走得更快，也做得更大。

18383
25:13:00.388 --> 25:13:02.638
这正是米拉拉所提供的。

18384
25:13:02.638 --> 25:13:03.487
在mirallas。

18385
25:13:03.487 --> 25:13:08.802
我们创建工具，我们为开发人员创建基础设施，以一种单一工作流

18386
25:13:08.802 --> 25:13:14.117
的方式，他们很快就会解释它的含义，因为这可以节省您的时间。

18387
25:13:14.117 --> 25:13:16.590
如果你有一个单一的工作流程。

18388
25:13:16.590 --> 25:13:23.617
web 3中的工作流意味着你必须有一个智能合约，无论是代币，游戏，某种赌

18389
25:13:23.617 --> 25:13:30.841
注，某种市场，某种违抗，它都是在链上的，但同时，你必须将它连接到你的后端。

18390
25:13:30.841 --> 25:13:34.068
因为当链上发生一些事情时，你需要监控它。

18391
25:13:34.068 --> 25:13:41.331
你可以创建web hook，你可以创建电子邮件，你可以创建一个推送通知，你可以运行一些自定义代码，

18392
25:13:41.331 --> 25:13:48.446
你可以运行一些计算，你可以保存一些东西到数据库，所有链上的东西在一天结束时都需要进入我们的后端。

18393
25:13:48.446 --> 25:13:51.626
当有东西在你的后端，它需要到前端。

18394
25:13:51.626 --> 25:13:56.757
例如，当链上发生一些事情时你改变UI或者你改变UI。

18395
25:13:56.757 --> 25:14:00.611
如果用户接收到的转账超过了一个特定的阈值。

18396
25:14:00.611 --> 25:14:08.165
或者如果你的用户拥有这种NFC，你可以允许他们访问某种类型的聊天或某种类型的独家内容。

18397
25:14:08.165 --> 25:14:12.873
所以在Morales，我们为你提供了一整套的工具套件，

18398
25:14:12.873 --> 25:14:19.152
被超过10万的开发者使用，它真的成为了web 3中最被采用的技术栈之一。

18399
25:14:19.152 --> 25:14:24.160
这一切都始于Morales身份，它确保你得到一段代码，你

18400
25:14:24.160 --> 25:14:29.347
写一段代码，你可以登录你的用户在不同的区块链，不同的钱包。

18401
25:14:29.347 --> 25:14:34.245
在你的士气仪表盘里，你会得到用户资料，你会得到一个网页会话。

18402
25:14:34.245 --> 25:14:41.480
因此mirallas允许您管理身份，因为一个用户配置文件可以有许多不同的钱包，来自许多连接到它的不同链。

18403
25:14:41.480 --> 25:14:48.326
所有的事务都会从那个用户同步，所有的实时事务都会和那个用户同步。

18404
25:14:48.326 --> 25:14:55.231
而且，你已经在你的前端建立了网络会话，无论是游戏还是网站，

18405
25:14:55.231 --> 25:15:02.376
我们确保你有安全的经过认证的网络会话，我们为你提供会话管理。

18406
25:15:02.376 --> 25:15:07.506
如果你有自己的自行车，然后你有mirallas会话身份管理，你可以使会

18407
25:15:07.506 --> 25:15:12.783
话无效，你可以登录用户，所有这些很好，所有这些很好的事情都只用一行代码。

18408
25:15:12.783 --> 25:15:13.814
这非常重要。

18409
25:15:13.908 --> 25:15:17.845
第二个是莫拉莱斯实时我已经提到了一点。

18410
25:15:17.908 --> 25:15:20.908
但基本上当你有一个用户时，你就能实时知道发生了什么。

18411
25:15:20.908 --> 25:15:27.299
你可以在用户进行交易时运行自定义代码，也可以在用户与智能合约进行交互时运行自定义代码

18412
25:15:27.299 --> 25:15:33.844
或进行web hook、电子邮件或推送通知，也可以在智能合约发出事件时运行自定义代码。

18413
25:15:33.908 --> 25:15:42.627
这可以是NFC市场中的交易，这可以是ERC 20传输，你可以通过设置过滤器非常灵活。

18414
25:15:42.627 --> 25:15:49.369
所以你可以说，当用户传输超过10个nfc时，只给我提醒只给我web hook。

18415
25:15:49.369 --> 25:15:53.701
或者当这个代币转账超过1000美元时，等等。

18416
25:15:53.701 --> 25:15:57.858
这是士气，是实时的，非常非常强大的东西。

18417
25:15:57.858 --> 25:15:59.743
接下来是mirallas sdk。

18418
25:15:59.908 --> 25:16:08.217
所以，无论你是在建立一个网站，还是在开发一款与游戏引擎完全整合的游戏，还是在为其他平台开发游戏，我们都有

18419
25:16:08.217 --> 25:16:16.527
大量易于使用的sdk，让你可以做所有这些事情，让你可以连接到Morales，非常非常容易地完成这些事情。

18420
25:16:16.527 --> 25:16:22.447
如果你去看我们的文档，我强烈建议你去看，你去看Morales, Doc's。Morales。

18421
25:16:22.447 --> 25:16:27.609
如果你去Doc's dot, Marisa Yo，你首先会深入了解mirallas是什么。

18422
25:16:27.609 --> 25:16:34.892
所以你可以把它想象成Firebase，但对于加密来说，它基本上是一个托管后端，你可以连接你的前端。

18423
25:16:34.892 --> 25:16:39.102
此外，你也可以不使用GS SDK将其连接到自己的后端，这非常非常简单。

18424
25:16:39.102 --> 25:16:41.666
但我想在这里展示的是跨平台。

18425
25:16:41.666 --> 25:16:44.853
对于每一件事，假设你想为你的用户获取nfts，

18426
25:16:44.853 --> 25:16:52.477
我们会展示如何用简单的JavaScript，香草JavaScript来做，如何做和反应，如何用web请求来做。

18427
25:16:52.477 --> 25:16:55.253
假设您只想使用一个原始web请求。

18428
25:16:55.253 --> 25:17:02.775
假设你使用的是某种语言，我们没有SDK你仍然可以使用Morales，只是你需要调用原始HTTP请求。

18429
25:17:02.775 --> 25:17:07.400
我们还会展示如何在Unity中使用C调在Unity游戏引擎中实现它。

18430
25:17:07.400 --> 25:17:10.330
所以我们非常非常清楚跨平台。

18431
25:17:10.330 --> 25:17:12.126
我们是交叉链的。

18432
25:17:12.126 --> 25:17:17.309
这意味着，例如，当你登录用户时，你可以创建用户配置文件其中有lambda地址，

18433
25:17:17.309 --> 25:17:29.271
假设你的用户使用Solana他们可以很容易地连接Aetherium，他们可以很容易地连接Binus链，最后，我们很快会添加更多链，他们可以很容易地连接L Ron到一个用户配置文件。

18434
25:17:29.271 --> 25:17:35.597
然后你有各种不同的钱包，不同的链，你有一个单一的用户配置文件一个单一的用户ID。

18435
25:17:35.597 --> 25:17:38.940
顺便说一下，这就是它在数据库中的样子。

18436
25:17:38.940 --> 25:17:45.859
如你所见，这里会有一个用户用户表，你会有他们所有的账户。

18437
25:17:45.909 --> 25:17:47.531
在这种情况下，我只有eth。

18438
25:17:48.909 --> 25:17:52.591
有了其他类型的区块链，它就都在这里了。

18439
25:17:52.909 --> 25:17:56.210
这个数据库也包含了我所有的事务。

18440
25:17:56.909 --> 25:18:01.489
数据库，我可以设置不同的监听事件或智能合约。

18441
25:18:01.489 --> 25:18:05.840
例如，我可以看open see智能合约或其他东西。

18442
25:18:05.840 --> 25:18:08.417
这是非常非常多变的，因为这是MongoDB。

18443
25:18:08.417 --> 25:18:12.813
这是MongoDB，你可以运行MongoDB查询，它非常非常可变。

18444
25:18:12.813 --> 25:18:20.624
从这个意义上说，mirallas提供了一个非常非常好的仪表板，其中包含了您需要了解的关于用户的所有信息，他们的会话、权限等等。

18445
25:18:20.624 --> 25:18:25.299
当然，你也可以使用Node js SDK连接到自己的后端。

18446
25:18:25.299 --> 25:18:26.926
这是莫拉莱斯sdk。

18447
25:18:26.926 --> 25:18:33.264
最后，当我们说到工作流时，最后一件事是API的，我也已经展示过了，

18448
25:18:33.264 --> 25:18:39.410
但API是你可以从任何编程语言，任何类型的体系结构做RAW请求。

18449
25:18:39.410 --> 25:18:43.648
所以使用这个工作流程，你可以很容易地实现任何你想要的非常非常快。

18450
25:18:43.648 --> 25:18:47.345
你一定要试试莫拉莱斯它会改变你的生活。

18451
25:18:47.345 --> 25:18:49.812
我想怎么解释都可以，我时间有限。

18452
25:18:49.910 --> 25:18:55.597
但正如你们已经看到的，通过这个演示，你们非常好奇，正如你们已经看到的，通过这

18453
25:18:55.597 --> 25:19:01.435
个演示，你们想要尝试一下正如你们已经看到我在这里的感觉一样，你们非常非常兴奋。

18454
25:19:01.435 --> 25:19:04.146
我们得亲自动手。

18455
25:19:04.146 --> 25:19:13.073
所以，第一个，两个狗，授权销售，然后到这里开始连接器SDK在香草或反应，并通过所有这些。

18456
25:19:13.073 --> 25:19:14.175
自己去看看魔法吧。

18457
25:19:14.175 --> 25:19:20.877
如果你想要实践，去youtube频道和道德频道哦，斜杠项目，伙计们，你们都在社区里。

18458
25:19:20.877 --> 25:19:25.592
利用莫拉莱斯，你就会成功利用拉力赛，你就会达到你的目标。

18459
25:19:25.592 --> 25:19:28.496
你会比你想象的要快。

18460
25:19:28.496 --> 25:19:30.469
你会让自己大吃一惊的。

18461
25:19:30.469 --> 25:19:32.367
但是不要让自己失望。

18462
25:19:32.367 --> 25:19:33.347
去找莫拉莱斯。

18463
25:19:33.347 --> 25:19:35.910
我报名，开始吧，伙计们。

18464
25:19:35.910 --> 25:19:40.942
现在我已经解释了所有这些，这是什么样子的?这就是我

18465
25:19:40.942 --> 25:19:46.176
们真正开始使用mirallas及其服务器功能的地方。

18466
25:19:46.176 --> 25:19:48.082
我们要在这里注册一个服务器。

18467
25:19:48.082 --> 25:19:51.730
我们将使用Morales作为应用程序的后端。

18468
25:19:51.730 --> 25:19:54.577
为了和莫拉莱斯见面，我们去找莫拉莱斯。

18469
25:19:54.577 --> 25:19:54.688
io。

18470
25:19:54.688 --> 25:19:56.995
我们可以免费报名。

18471
25:19:56.995 --> 25:20:00.462
我们输入电子邮件，设置密码。

18472
25:20:00.462 --> 25:20:06.339
你为什么在这里?另外，请指定帕特里克令人惊叹的硬帽视频，你不必写那个。

18473
25:20:06.339 --> 25:20:08.149
但如果你想写，你可以写。

18474
25:20:08.149 --> 25:20:12.762
你第一次听说莫拉莱斯是什么情况?好吧，你们都在YouTube上听说过，因为你们是从我

18475
25:20:12.762 --> 25:20:17.376
这里听说的，然后选择你们的名单，我要成为一个开发人员，我们将点击下一个，我不想订阅。

18476
25:20:17.376 --> 25:20:20.249
但我不会像机器人一样为你创建账户。

18477
25:20:20.249 --> 25:20:23.661
它甚至会给我们一些属性，或者创建你的第一个服务器。

18478
25:20:23.661 --> 25:20:28.063
我们的后端将使用一个服务器来完成后面的所有工作。

18479
25:20:28.063 --> 25:20:29.757
因此，我们将创建一个服务器。

18480
25:20:29.757 --> 25:20:33.152
如果我们要做一个主网或遗嘱，我们会从中选择一个。

18481
25:20:33.152 --> 25:20:35.813
但现在我们要做的是本地开发链服务器。

18482
25:20:35.911 --> 25:20:41.536
这也是《Morales》的一大优势，即它让我们能够与本地开发者合作。

18483
25:20:41.536 --> 25:20:47.628
对于事件索引，我们可以从本地硬帽节点索引我们的事件，这非常非常强大，检查你

18484
25:20:47.628 --> 25:20:53.720
的邮件，我们会有一个激活我的账户的东西，电子邮件，我们会点击激活你的账户。

18485
25:20:53.720 --> 25:20:56.873
它会把我们带回这里，我们会重新创造，我们会做本地开发链。

18486
25:20:56.911 --> 25:21:00.428
好了，现在我们要创建一个新的本地开发链服务器。

18487
25:21:00.428 --> 25:21:07.758
我们将称之为非功能性市场，我们将选择一个地区，你想要哪个地区都行，我在美国东部。

18488
25:21:07.758 --> 25:21:08.842
所以我选择纽约。

18489
25:21:08.911 --> 25:21:13.729
但无论你在哪里工作，我们都会做本地开发链，我们会做每个本地开发链。

18490
25:21:13.729 --> 25:21:18.498
再一次，如果你是为polygon，为avalanche，为Phantom，为

18491
25:21:18.498 --> 25:21:23.394
任何一个与EVM兼容的链，再一次，你的每个本地开发链，它的工作原理都是一样的。

18492
25:21:23.394 --> 25:21:25.007
我们现在要添加实例。

18493
25:21:25.007 --> 25:21:27.911
我们要在这里创建一个新应用程序。

18494
25:21:27.911 --> 25:21:32.670
现在我们要关闭服务器了，上面写着ganache，但它真的很硬。

18495
25:21:32.670 --> 25:21:33.428
别担心那个。

18496
25:21:33.428 --> 25:21:40.745
现在我们已经启动了服务器，我们可以去Morales文档，我们要找的是事件，我们要和事件同步。

18497
25:21:40.745 --> 25:21:44.472
我们甚至可以在这里搜索事件。

18498
25:21:44.472 --> 25:21:52.123
我们看到智能合约事件平台自动同步，甚至告诉我们为什么我们需要同步和观察智能合约事件。

18499
25:21:52.123 --> 25:21:56.864
基本上，这个服务器我们的数据库将寻找这些要触发的事件。

18500
25:21:56.912 --> 25:22:03.573
但在这之前，我们需要将应用连接到服务器如果你去顶部的React Morales GitHub，你可能见过

18501
25:22:03.573 --> 25:22:10.234
这个，当你有这个Morales provider在他们的码头，他们会传递一个应用ID和一个服务器URL。

18502
25:22:10.234 --> 25:22:15.271
这就是我们直接连接mirallas服务器的方法。

18503
25:22:15.271 --> 25:22:23.153
我们要做的是，现在我们要回到我们的应用Jas最初我们说过，initialize on Mount = false。

18504
25:22:23.153 --> 25:22:30.365
当我们这么说的时候，我们是在说，嘿，我们不会使用士气服务器，我们只会使用你们提供的开源泥沼工具。

18505
25:22:30.365 --> 25:22:35.404
现在，我们确实想使用他们的服务器，对吧，我们确实想使用莫拉莱斯提供的所有这些花哨的东西。

18506
25:22:35.404 --> 25:22:36.662
所以我们要改变这一点。

18507
25:22:36.662 --> 25:22:41.420
这里不说initialize on Mount = false，这里只准备了应用ID和服务器URL。

18508
25:22:41.420 --> 25:22:42.945
我们要把这个删掉。

18509
25:22:42.945 --> 25:22:47.673
就像文档中说的，我们会给它一个app ID和一个服务器URL。

18510
25:22:47.673 --> 25:22:51.740
我们写入app ID =，这是我们将app ID作为字符串的地方。

18511
25:22:51.740 --> 25:22:55.827
回到莫拉莱斯数据库，我们可以查看细节。

18512
25:22:55.827 --> 25:22:58.412
我们可以在这里看到所有这些信息。

18513
25:22:58.412 --> 25:23:02.782
我们可以抓取应用ID，复制粘贴到这里。

18514
25:23:02.782 --> 25:23:07.296
然后我们会获取服务器URL，在顶部。

18515
25:23:07.296 --> 25:23:11.525
这是我们唯一定制士气服务器的URL。

18516
25:23:11.525 --> 25:23:15.879
我们写入server URL =然后像这样粘贴进去。

18517
25:23:15.879 --> 25:23:24.257
现在，如果你一直在跟随这些教程，你可能会想，哦，我们我们只是把那些东西硬编码在那里，就像这样，那看起来好像那看起来有点糟糕。

18518
25:23:24.257 --> 25:23:26.946
如果这是你的直觉，那太棒了。

18519
25:23:26.946 --> 25:23:29.600
相反，我们要把这些放到环境变量中。

18520
25:23:29.600 --> 25:23:33.355
我们要创建一个新文件。env文件。

18521
25:23:33.355 --> 25:23:36.558
这就是我们要放所有环境变量的地方。

18522
25:23:36.558 --> 25:23:41.771
接下来，Jas内置了对环境变量的支持，它允许您执行以下操作:使用。

18523
25:23:41.771 --> 25:23:46.984
env和。local将环境变量或那些环境变量通过前缀加载到浏览器。

18524
25:23:46.984 --> 25:23:48.644
它的下一个下划线为public。

18525
25:23:48.644 --> 25:23:51.257
我们可以使用几种不同的环境变量路径。

18526
25:23:51.257 --> 25:23:57.343
我们可以做。env，。local，我们可以做。env，。这个。那个另一件事，我们要做。env，保持简单。

18527
25:23:57.343 --> 25:24:05.596
但是为了我们的前端，从我们的。env文件中读取环境变量，我们必须执行下一个下划线public下划线，下

18528
25:24:05.596 --> 25:24:13.850
一个Jas将在我们的。env文件中查找以this开头的变量，并只将这些环境变量插入到我们的应用程序中。

18529
25:24:13.913 --> 25:24:18.574
如果我们只写，Morales服务器等于，等等，等等，它不

18530
25:24:18.574 --> 25:24:23.403
知道这是什么，因为我们接下来要做的是，下划线，公共下划线。

18531
25:24:23.403 --> 25:24:28.538
如果我们这样做，我们会写一个console。log，看这里，process。env。

18532
25:24:28.538 --> 25:24:32.404
下一个公共士气服务器，我们实际上需要杀死它，重新启动它。

18533
25:24:32.404 --> 25:24:40.646
然后我们返回，在这里做一点刷新，它会说，Look here as a do等等等等，因为这是下一个公共的。env文件中的内容。

18534
25:24:40.646 --> 25:24:44.246
抓取我们的app ID，复制它。

18535
25:24:44.246 --> 25:24:51.828
然后我们的。env会写next public app ID =然后粘贴到这里。

18536
25:24:51.828 --> 25:24:55.914
获取服务器URL，回到这里。

18537
25:24:55.914 --> 25:25:01.602
我们写next public server URL =，像这样粘贴。

18538
25:25:01.602 --> 25:25:05.625
现在在顶部，我们用const。

18539
25:25:05.625 --> 25:25:12.914
App ID等于process。E和V。接下来是公共App ID。

18540
25:25:12.914 --> 25:25:15.545
然后我们说const。

18541
25:25:15.545 --> 25:25:22.802
服务器URL等于进程点E和V点下一个公共服务器URL。

18542
25:25:22.802 --> 25:25:28.826
现在我们有了这些变量，我们像这样把它们代进去。

18543
25:25:28.914 --> 25:25:33.229
这就是我们将应用程序连接到士气服务器的方法。

18544
25:25:33.229 --> 25:25:35.597
当然，我们还什么都没做。

18545
25:25:35.597 --> 25:25:38.543
但我们才刚刚开始，对吧?这就是我们连接它的方式。

18546
25:25:38.543 --> 25:25:43.520
现在我们已经登录了，我告诉过你我们的士气服务器将为我们的活动建立索引。

18547
25:25:43.520 --> 25:25:46.864
如果你点击Dashboard按钮，这是我们的整个数据库。

18548
25:25:46.914 --> 25:25:50.010
浏览器选项卡中的所有内容都是数据库中的内容。

18549
25:25:50.010 --> 25:25:56.117
就像你看到的，现在，没有很多东西，如果我们有任何事件数据在这里，它会在这里。

18550
25:25:56.117 --> 25:25:59.897
我们需要告诉服务器，你需要开始监听事件。

18551
25:25:59.897 --> 25:26:02.314
所以我们可以展示最近被列出的实体。

18552
25:26:02.314 --> 25:26:09.075
所以士气服务器，你需要开始监听，你需要为每一个列出的事件创建一个数据库条目。

18553
25:26:09.075 --> 25:26:16.986
无论何时有人买了一件商品，无论何时有人买了一件商品，或者取消了一件商品，你都需要从数据库中删除它。

18554
25:26:16.986 --> 25:26:24.553
我们怎么开始让莫拉莱斯开始监听我们的活动?首先，首先，我们要把它连接回我们的区块链。

18555
25:26:24.553 --> 25:26:31.098
然后我们会说，哪个契约哪些事件以及当它听到这些事件时该怎么做。

18556
25:26:31.098 --> 25:26:34.570
所以我们需要连接它然后我们需要告诉它当它听到这些事件时要做什么。

18557
25:26:34.570 --> 25:26:39.690
那么，我们如何将mirallas服务器连接到我们的硬帽子区块链?现在，我们还没有这样的计划。

18558
25:26:39.690 --> 25:26:44.415
我们先打开硬帽子，本地主机区块链。

18559
25:26:44.415 --> 25:26:50.355
在一个终端上，我们运行前端另一个终端会看到下载目录。

18560
25:26:50.355 --> 25:26:58.022
我们将进入我们的硬帽非ft市场点自由代码营或自由代码营，我们将做纱线硬帽节点。

18561
25:26:58.022 --> 25:27:02.259
如果我们做的一切都是正确的，它将部署我们的非金融市场。

18562
25:27:02.259 --> 25:27:07.656
它会部署我们的Basic NFT然后它会启动本地HTTP web套接字等等。

18563
25:27:07.656 --> 25:27:08.264
这很好。

18564
25:27:08.264 --> 25:27:15.315
现在节点已经运行了，我们能做的是查看细节，然后到dev链代理服务器。

18565
25:27:15.315 --> 25:27:23.125
这个开发链代理服务器就是我们告诉Morales监听本地运行的硬帽节点的方式。

18566
25:27:23.125 --> 25:27:29.222
现在，要做到这一点，你需要做的是我们需要下载这个所谓的反向代理。

18567
25:27:29.222 --> 25:27:37.107
我在GitHub上也有一个链接，根据你运行的电脑会告诉你我们需要下载哪一个。

18568
25:27:37.107 --> 25:27:43.476
如果你迷路了，如果你真的很困惑，这里有一些排除故障的技巧，

18569
25:27:43.476 --> 25:27:49.406
我们可以做什么，莫拉莱斯FRP可以下载，快速搜索一下。

18570
25:27:49.406 --> 25:27:54.460
我们甚至直接进入文档，将ganache连接到Morales note，供Mac

18571
25:27:54.460 --> 25:27:59.515
用户下载FRP dot Darwin dot等等等等，用于nosh代理服务器。

18572
25:27:59.515 --> 25:28:00.315
我用的是Mac电脑。

18573
25:28:00.315 --> 25:28:02.767
我要下载这个Darwin AMD 64。

18574
25:28:02.767 --> 25:28:07.415
看看发布版本，这是第一个在顶部的，Darwin AMD 64。

18575
25:28:07.415 --> 25:28:10.850
这就是我要下载的。

18576
25:28:10.915 --> 25:28:13.115
我要点击它，下载它。

18577
25:28:13.916 --> 25:28:18.752
下载后，我们会打开它，我们会得到一个文件夹我们会得到一个像这样的文件夹。

18578
25:28:18.752 --> 25:28:24.109
我们需要的主要材料是FRP和FRP·ini。

18579
25:28:24.109 --> 25:28:24.287
F

18580
25:28:24.287 --> 25:28:35.169
RPC将是可执行文件它将是我们将运行的用来连接区块链节点到Morales的文件，F RPC。ini将是做这个的配置文件。

18581
25:28:35.169 --> 25:28:40.549
这是其中一节下载这将是最难的步骤之一。

18582
25:28:40.549 --> 25:28:48.541
所以如果你迷路了，请在GitHub上提问，请在莫拉莱斯论坛上提问，也有一个莫拉莱斯论坛，在那里你可以问很多不同的问题。

18583
25:28:48.541 --> 25:28:50.677
也请查看故障排除。

18584
25:28:50.677 --> 25:28:56.150
我要做的是在这里创建一个新文件夹叫做F R P。

18585
25:28:56.150 --> 25:28:58.821
我在这里做它只是为了让它更简单一点。

18586
25:28:58.916 --> 25:29:02.737
但你可以把它放在任何你想放的地方，然后总是引用它。

18587
25:29:02.737 --> 25:29:09.555
我要做的是我要复制这两个文件，把它们放到这个FRP文件夹里。

18588
25:29:09.555 --> 25:29:16.761
现在我有了FRP C和frpc那ini如果你点F RPC，它会像，嘿，它是二进制的，你不

18589
25:29:16.761 --> 25:29:23.968
能看这个，不要点那个，它只是一堆废话，但frpc。ini看起来是一个非常典型的配置文件。

18590
25:29:23.968 --> 25:29:26.443
这就是我们要调整的。

18591
25:29:26.443 --> 25:29:31.836
即使我们回到我们的士气服务器，它也会给你你需要的东西。

18592
25:29:31.836 --> 25:29:33.416
我们要用安全帽。

18593
25:29:33.416 --> 25:29:35.853
所以我们要复制这里的所有东西。

18594
25:29:35.853 --> 25:29:41.566
我们会回到frpc。ini，然后把这里的东西粘贴到这里。

18595
25:29:41.566 --> 25:29:45.254
这就是我们如何告诉这个frpc我们需要连接。

18596
25:29:45.254 --> 25:29:47.536
我还没有为使用WsL的用户尝试过这个功能。

18597
25:29:47.536 --> 25:29:52.296
因此，如果你正在使用WsL，请在完整的区块链固体性课程中让我们知道，Jas，

18598
25:29:52.296 --> 25:29:57.057
进行一个新的讨论，如果你还没有看过它，说，嘿，我正在为F RPC使用WsL。

18599
25:29:57.057 --> 25:29:58.557
这是你需要用到的。

18600
25:29:58.557 --> 25:30:01.142
然后在底部写着，跑步享受。

18601
25:30:01.142 --> 25:30:07.297
我在Mac OS上运行，它运行Linux命令，所以我可以复制这个，我会创建一个新终端。

18602
25:30:07.297 --> 25:30:10.794
我要做的是把它cd到FRP文件夹里。

18603
25:30:10.794 --> 25:30:16.390
我要把我刚从罗斯那里复制的东西粘贴过来。

18604
25:30:16.390 --> 25:30:22.135
我们运行那个frpc可执行文件，破折号c，也就是破折号配置，frpc。ini。

18605
25:30:22.135 --> 25:30:25.744
如果我按回车键，它会显示登录服务器成功，

18606
25:30:25.744 --> 25:30:31.158
获取运行ID，等等，服务器，UDP端口，还有一大堆其他东西。

18607
25:30:31.158 --> 25:30:34.450
如果你在这里看到了成功的东西，那就意味着你做对了。

18608
25:30:34.450 --> 25:30:39.117
你可以按CTRL C取消因为我们不会一直运行它。

18609
25:30:39.117 --> 25:30:41.817
现在，如果你想运行这个，你完全可以。

18610
25:30:41.817 --> 25:30:44.472
但我要给你们展示另一种方法。

18611
25:30:44.472 --> 25:30:47.646
这是使用Morales管理命令行。

18612
25:30:47.646 --> 25:30:56.317
我们在这里做的所有事情，我们按下的所有这些按钮，都有一个叫做管理CLI的东西或者命令行界面。

18613
25:30:56.317 --> 25:31:02.547
这是我们连接和运行所有这些按钮和东西的一种方式我们在终端和shell中按下这些按钮和东西。

18614
25:31:02.547 --> 25:31:06.338
因此，我将向您展示几个关于如何使用管理CLI的命令。

18615
25:31:06.338 --> 25:31:09.338
我们将使用大量的管理CLI命令。

18616
25:31:09.338 --> 25:31:14.850
但我们要做的是npm install dash g Morales, admin CLI或者我们的yarn Global Add。

18617
25:31:14.850 --> 25:31:21.802
我们会去做yarn, Global Add routes，这样的admin CLI。

18618
25:31:21.802 --> 25:31:28.345
现在我们应该可以运行Morales admin CLI看到一大堆这样的东西。

18619
25:31:28.345 --> 25:31:31.606
如果你运行路由，admin CLI，我们有所有这些东西。

18620
25:31:31.606 --> 25:31:37.968
其中一个大的，也是最重要的是我们要处理的是连接本地开发者链。

18621
25:31:37.968 --> 25:31:41.295
运行这个F RPC破折号c破折号F RPC ini。

18622
25:31:41.295 --> 25:31:45.816
这和运行connect本地开发链是一样的。

18623
25:31:45.816 --> 25:31:49.672
现在我要做的是进入我们的package。JSON。

18624
25:31:49.672 --> 25:31:57.572
我们会在这里创建一个附加的脚本来运行yarn，不管我们想要什么名字，为了这样做，为了让

18625
25:31:57.572 --> 25:32:05.473
我们更容易连接本地的开发链在lint下面，我要做一个平静的，女士，我要创建一个新命令。

18626
25:32:05.473 --> 25:32:07.615
我选莫拉莱斯同步。

18627
25:32:07.615 --> 25:32:14.180
我们会运行这个frpc dash c的Morales admin CLI版本。

18628
25:32:14.180 --> 25:32:22.463
这里我们要做的是mirallas admin CLI，

18629
25:32:22.463 --> 25:32:31.054
连接本地开发链，破折号链，硬帽，破折号mirallas。

18630
25:32:31.054 --> 25:32:33.644
大写子域。

18631
25:32:33.918 --> 25:32:38.807
这是我们将放置士气服务器子域的地方，如果我们回到我

18632
25:32:38.807 --> 25:32:43.697
们的路线，管理数据服务器，我们可以回到服务器细节。

18633
25:32:43.697 --> 25:32:48.563
这不是HTTPS，而是从这里一直到。

18634
25:32:48.563 --> 25:32:48.756
com。

18635
25:32:48.756 --> 25:32:53.348
不包括端口，我们要抓取它粘贴到这里。

18636
25:32:53.348 --> 25:32:59.266
然后我们要写，f RPC路径是。/ f

18637
25:32:59.266 --> 25:33:05.496
RPC， / FRP / f RPC。

18638
25:33:05.496 --> 25:33:09.273
如果我们保存这个，然后运行它，它就不能工作了。

18639
25:33:09.273 --> 25:33:16.817
如果我用我们的新脚本Morales sync运行yarn，它会说指定Morales API key，它会给我们这个提示。

18640
25:33:16.817 --> 25:33:23.866
在仪表板中，我们有API key，我们可以复制粘贴它，还有API secret，我们可以复制粘贴它。

18641
25:33:23.866 --> 25:33:27.308
然后我们说开始连接到硬帽，这很好。

18642
25:33:27.308 --> 25:33:28.454
但那真的很烦人。

18643
25:33:28.454 --> 25:33:29.739
我可不想这么做。

18644
25:33:29.739 --> 25:33:31.485
按Ctrl C，把它扼杀掉。

18645
25:33:31.485 --> 25:33:34.869
我们能做的就是进入。env。

18646
25:33:34.869 --> 25:33:40.652
我们可以把这些作为莫拉莱斯期望的环境变量。

18647
25:33:40.652 --> 25:33:44.946
当我们运行Morales admin CLI时，它会检查。

18648
25:33:44.946 --> 25:33:49.981
env文件是否有Morales API key，我们可以复制到这里。

18649
25:33:49.981 --> 25:33:57.272
然后是Morales API secret，我们可以复制粘贴到这里。

18650
25:33:57.272 --> 25:34:03.452
现在，这些不是资本的原因是，它们不会成为我们的前端部分。

18651
25:34:03.452 --> 25:34:08.569
这些是我们在后端用于测试和本地开发链连接的键。

18652
25:34:08.569 --> 25:34:12.207
所以我们不需要做next public，就这样吧。

18653
25:34:12.207 --> 25:34:19.064
但是现在如果我点击并运行yarn Morales同步，这次它不会提示我，它只会说开始连接到安全帽。

18654
25:34:19.064 --> 25:34:24.636
如果你看到这个，开始连接到硬帽位，我们可以回到我们的服务器，

18655
25:34:24.636 --> 25:34:29.838
我们会到开发链代理服务器，我们会点击这个断开按钮，刷新。

18656
25:34:29.919 --> 25:34:38.252
如果你看到连接，你已经成功连接了我们的心脏添加节点，它正在运行到我们的莫拉莱斯服务器上，太棒了。

18657
25:34:38.252 --> 25:34:45.495
事实上，如果你坐在没有终端的心脏上，你会看到对区块链的实际RPC调用。

18658
25:34:45.495 --> 25:34:49.995
你会看到莫拉莱斯一直在调

18659
25:34:49.995 --> 25:34:54.872
用f区号以确保它是最新的。

18660
25:34:54.872 --> 25:35:01.570
那么我们如何告诉士气服务器开始监听事件呢?有两种方法。

18661
25:35:01.570 --> 25:35:03.808
第一种方法是用户界面。

18662
25:35:03.808 --> 25:35:06.792
我们可以去查看细节，我们会去同步。

18663
25:35:06.920 --> 25:35:09.242
现在它说没有安装同步服务。

18664
25:35:09.920 --> 25:35:11.049
添加一个新的同步。

18665
25:35:14.920 --> 25:35:20.592
观察合约事件，我们可以观察交易的地址也可以观察任何事件的某个地址。

18666
25:35:20.592 --> 25:35:26.911
我们可以在这里手动添加所有信息，你可以选择链描述，决定是否要同步历史，

18667
25:35:26.911 --> 25:35:33.051
我们可以放入事件的主题，事件的ABI，事件过滤器的地址，然后是表名。

18668
25:35:33.051 --> 25:35:40.216
或者我们可以通过编程来完成这一切，这就是我们将要做的，我们会创建一个可以运行的小脚本，告诉士气服务器去监视这些脚本。

18669
25:35:40.216 --> 25:35:44.329
我们会看到我们的数据库升级到监听这些事件。

18670
25:35:44.329 --> 25:35:51.387
回到代码中，我们会创建一个名为add events that Jas的新文件现在

18671
25:35:51.387 --> 25:35:58.446
我们有一个终端在运行前端一个终端在运行区块链一个终端在同步区块链和morass。

18672
25:35:58.446 --> 25:36:00.134
现在我们来做另一个终端。

18673
25:36:00.134 --> 25:36:05.768
对于任何我们想做的事，比如运行小脚本变成Morales码头，点击connect with SDK，我

18674
25:36:05.768 --> 25:36:11.402
们有很多不同的方式可以连接SDK，我们已经学过如何通过使用react Morales连接react。

18675
25:36:11.402 --> 25:36:16.661
现在我们将不连接JS因为我们将运行一个小的Morales脚本。

18676
25:36:16.661 --> 25:36:20.227
这是文档中的一个小例子。

18677
25:36:20.227 --> 25:36:26.554
但我要继续，我写入const Morales，等于require oralis slash node。

18678
25:36:26.554 --> 25:36:34.287
我们要导入Morales包的节点扩展到我们的脚本中，我们需要。env。

18679
25:36:34.287 --> 25:36:42.463
config，这意味着我们需要安装。env yarn添加。dev。env。

18680
25:36:42.463 --> 25:36:49.128
现在我们必须告诉士气服务器我们需要在用户界面上告诉它的所有信息。

18681
25:36:49.128 --> 25:36:51.889
我们首先需要的是合同的地址。

18682
25:36:51.921 --> 25:36:59.169
我们需要写上const合约地址=这就是我们要去的地方我们怎么得到合约地址

18683
25:36:59.169 --> 25:37:06.619
呢?最简单的方法是我们回到运行区块链的地方我们会抓取NFC市场部署的地方。

18684
25:37:06.619 --> 25:37:12.873
类似于智能合约彩票我们创建了一个更新前端脚本，这里我们要做完全相同的事情。

18685
25:37:12.873 --> 25:37:21.863
回到我们的非ft市场，如果T code，我们到我们的部署脚本或部署文件夹，我们会创建一个新文件

18686
25:37:21.863 --> 25:37:30.854
叫做99 Dash update，前端。j s，我们会创建一些部署进程它会自动更新我们的前端。

18687
25:37:30.854 --> 25:37:35.403
所以我们可以从程序创建的文件中获取网络地址。

18688
25:37:35.403 --> 25:37:39.748
我们要写module。exports = async function。

18689
25:37:39.748 --> 25:37:46.746
现在我们说if process。EMV那个更新前端，

18690
25:37:46.746 --> 25:37:57.243
然后console。log，更新前端在。EMV中，我们有更新前端= true。

18691
25:37:57.243 --> 25:38:01.550
这将是我们决定是否要更新前端的方式。

18692
25:38:01.550 --> 25:38:06.478
然后我们会创建一个函数叫做up date contract addresses，我们会等待它。

18693
25:38:06.478 --> 25:38:09.904
这将更新我们前端的合同地址。

18694
25:38:09.904 --> 25:38:11.734
我们来做这个函数。

18695
25:38:11.734 --> 25:38:19.382
执行async函数更新契约地址，确保它们拼写相同。

18696
25:38:19.382 --> 25:38:26.122
所以我们写const NFT, market place = await醚。get contract。

18697
25:38:26.122 --> 25:38:32.646
然后，是的，我们需要导入const ethers = require hardhat，我们将占领非ft市场。

18698
25:38:32.646 --> 25:38:37.793
然后我们要把文件写到这里到前端代码的某

18699
25:38:37.793 --> 25:38:43.212
个地方，我们要在一个新的文件夹常数中做。

18700
25:38:43.212 --> 25:38:49.193
我们将在这里创建一个新文件network mapping。JSON。

18701
25:38:49.193 --> 25:38:54.954
这是一个JSON对象它记录所有部署。

18702
25:38:54.954 --> 25:39:03.075
所以如果我们部署一些东西，V链会保持一个列表，它会保持一个列表，它会说，非金融市场将保持一个

18703
25:39:03.075 --> 25:39:11.196
所有的物联网市场地址的列表，基本的NFT，对，然后我列出所有这些，现在我们没有部署任何东西。

18704
25:39:11.196 --> 25:39:13.829
我们让它是一个空JSON对象。

18705
25:39:13.829 --> 25:39:21.022
现在回到我们在硬帽非ft市场项目中的部署脚本中，我们将跟踪那个位置。

18706
25:39:21.022 --> 25:39:23.460
在顶部，我们会说const。

18707
25:39:23.460 --> 25:39:28.051
前面，和合同文件等于，我们将

18708
25:39:28.051 --> 25:39:32.971
放置它的位置根据你的文件设置。

18709
25:39:32.971 --> 25:39:41.750
如果我输入cd。。/ next JS NFT，市场，free code, Camp常量，网络映射。JSON，这就是我的所在。

18710
25:39:41.750 --> 25:39:46.070
所以你会想把它放在任何你的位置在Mt marketplace

18711
25:39:46.070 --> 25:39:50.822
Free Code Camp，它是我的前端合同文件，它就在这里。

18712
25:39:50.822 --> 25:39:53.561
现在我们有了所有这些，我们要得到链ID。

18713
25:39:53.561 --> 25:39:59.823
我们写入const, chain ID = network。config。chain ID。

18714
25:39:59.823 --> 25:40:00.723
字符串。

18715
25:40:00.723 --> 25:40:05.288
我们还需要从硬帽导入网络。

18716
25:40:05.288 --> 25:40:11.195
然后我们要从这个网络映射文件中读取看当前在那里有什么。

18717
25:40:11.195 --> 25:40:12.922
所以我们用const。

18718
25:40:12.922 --> 25:40:19.210
合约地址等于。我们要做一个JSON。parse。

18719
25:40:19.210 --> 25:40:26.285
Fs。read文件同步，front front和合约。

18720
25:40:26.285 --> 25:40:29.361
文件，UTF, 8。

18721
25:40:29.361 --> 25:40:34.650
这是我们要说的，如果chain ID在契约中。

18722
25:40:34.650 --> 25:40:41.036
地址，我们说如果这个合同地址列表不包括市场，然

18723
25:40:41.036 --> 25:40:47.423
后加上，我们会说如果合同地址的链ID的NFT。

18724
25:40:47.423 --> 25:40:53.807
市场会说。包括NFT，市场，Mar

18725
25:40:53.807 --> 25:41:01.318
get地点。地址，然后我们会说合约地址说

18726
25:41:01.318 --> 25:41:08.829
说链ID NFT市场，push NFT市

18727
25:41:08.829 --> 25:41:15.964
市场。地址否则我们会说合约地址说链ID

18728
25:41:15.964 --> 25:41:24.605
NFT市场，这将是一个新的条目现在等于NFT。

18729
25:41:24.605 --> 25:41:28.668
市场市场地点点地址。

18730
25:41:28.923 --> 25:41:34.502
现在我们更新了合约地址对象我们只需要把它写回网络映射。

18731
25:41:34.502 --> 25:41:40.194
现在我们写入Fs。right file sync front and

18732
25:41:40.194 --> 25:41:43.374
contractfile, JSON。

18733
25:41:43.374 --> 25:41:54.090
string五个合约地址然后在底部我们写入module。exports。tags =我们写入all or front end。

18734
25:41:54.090 --> 25:41:58.847
现在我们能做的是运行这个更新前端脚本用yarn

18735
25:41:58.847 --> 25:42:05.466
hardhat deploy虚线虚线，网络localhost。

18736
25:42:05.466 --> 25:42:09.457
我们只想做这个更新前端脚本。

18737
25:42:09.457 --> 25:42:17.517
所以我们说，破折号标签前端，我们运行这个，我遇到了一个错误FS is not defined，哦，

18738
25:42:17.517 --> 25:42:25.743
我忘了const FS = require FS stride，不能设置未定义的非功能性市场的属性。

18739
25:42:25.743 --> 25:42:26.070
哦。

18740
25:42:26.070 --> 25:42:30.174
这是因为这条线是关闭的，而不是这条线。

18741
25:42:30.174 --> 25:42:34.831
基本上，现在，它说的是，它说的是，嘿，这个非金融市场不存在。

18742
25:42:34.831 --> 25:42:36.615
所以我们要让它存在。

18743
25:42:36.615 --> 25:42:43.947
现在我们说链ID的合约地址等于NFT市场的一个新条目并添加它

18744
25:42:43.947 --> 25:42:51.524
的第一个参数，它将是NFT, Mark得到放置点地址，像这样。

18745
25:42:51.524 --> 25:42:56.268
现在我们可以运行它了，更新前端看起来已经完成了。

18746
25:42:56.268 --> 25:43:04.440
如果我们回到我们的前端，我们现在看到我们有一个为localhost with NFC marketplace的条目，地址在我们的网络映射。JSON中。

18747
25:43:04.440 --> 25:43:06.111
如果做对了，就会得到这个。

18748
25:43:06.111 --> 25:43:14.088
如果没有，如果你有困难你当然可以，直接硬编码进去但我强烈建议你用编程的方式来做，因为你的生活将会好很多。

18749
25:43:14.088 --> 25:43:14.378
太酷了。

18750
25:43:14.378 --> 25:43:19.194
我们有这个更新前端脚本，现在可以工作了，所以我们可以把它放回一边。

18751
25:43:19.194 --> 25:43:20.527
让我们继续。

18752
25:43:20.527 --> 25:43:25.686
现在我们有了这个网络映射文件，其中包含基于链ID的合同地址。

18753
25:43:25.686 --> 25:43:32.494
我们能做的是把它也拉进来，我们说const contract,

18754
25:43:32.494 --> 25:43:40.401
address说= require。斜杠常数，斜杠网络映射。JSON。

18755
25:43:40.401 --> 25:43:44.236
现在我们可以根据链ID获取合同地址。

18756
25:43:44.236 --> 25:43:49.257
所以链ID等于进程点E和V

18757
25:43:49.257 --> 25:43:54.279
点链ID，或者31337。

18758
25:43:54.279 --> 25:43:59.521
在数据和V中，我们会新建一个名为Chain ID的项。

18759
25:43:59.521 --> 25:44:01.362
现在我们用31337。

18760
25:44:01.362 --> 25:44:07.397
现在我们可以通过说合同地址等于合同地址在链

18761
25:44:07.397 --> 25:44:13.433
ID n f t Mark处得到0的位置。

18762
25:44:13.433 --> 25:44:17.958
所以我们将进入网络映射，进入链，我将进入非

18763
25:44:17.958 --> 25:44:22.699
功能性市场并获得最近部署的非功能性市场繁荣。

18764
25:44:22.699 --> 25:44:26.367
现在我们有了合同地址合同地址写着，对不起。

18765
25:44:26.367 --> 25:44:32.763
在添加事件中，我们会创建一个新函数类似于我们正在做的，我们会写async function main。

18766
25:44:32.763 --> 25:44:35.021
这是我们的主要功能。

18767
25:44:35.021 --> 25:44:43.155
当然，我们会复制粘贴主脚本这个我们一直在做的时间域点然后catch等等，我们回

18768
25:44:43.155 --> 25:44:51.498
到沼泽文档，我们会看到我们需要获取服务器URL, app ID主键，然后启动它。

18769
25:44:51.498 --> 25:44:53.451
所以我们要做完全一样的事情。

18770
25:44:53.451 --> 25:44:57.892
抱歉，在我们进入main之前，你可以在main函数中做。

18771
25:44:57.926 --> 25:45:05.383
我们写入const serverurl =，我们可以再次从web中获取这个。

18772
25:45:05.383 --> 25:45:12.485
我们说process web。next public Morales服务器URL，我们会得到app

18773
25:45:12.485 --> 25:45:20.022
ID = process Studien v。next public Morales app ID，然后

18774
25:45:20.022 --> 25:45:27.560
后我们会说const, master key = process study v。master key。

18775
25:45:27.560 --> 25:45:30.226
所以我们这里还没有万能钥匙。

18776
25:45:30.226 --> 25:45:33.354
我们新建一个master key。

18777
25:45:33.354 --> 25:45:39.392
回到Morales前端，关闭这个，点击查看细节。

18778
25:45:39.392 --> 25:45:41.458
我们去拿万能钥匙。

18779
25:45:41.458 --> 25:45:44.991
复制这个，回到代码编辑器，粘贴进去。

18780
25:45:44.991 --> 25:45:47.796
现在我们的网站上也有了一个万能钥匙。

18781
25:45:47.796 --> 25:45:50.610
我们不希望我们的万能钥匙在前端。

18782
25:45:50.610 --> 25:45:53.110
所以我们不会像这样公开下一个。

18783
25:45:53.110 --> 25:45:59.659
主函数中我们要做的第一件事是await Morales。

18784
25:45:59.659 --> 25:46:06.208
start服务器URL, app ID和主键作为输入参数

18785
25:46:06.208 --> 25:46:12.992
这会做一个console。log，使用合同地址，合同地址。

18786
25:46:12.992 --> 25:46:17.576
现在我们要添加UI中所有相同的片段。

18787
25:46:17.576 --> 25:46:22.672
那么我们想听的事件是什么呢?如果我们回到这里的代码，

18788
25:46:22.672 --> 25:46:29.926
我们有非ft市场，在这里输入event我们有商品列表，商品购买，商品取消。

18789
25:46:29.926 --> 25:46:36.392
我们有三个要听的事件和一个Morales，他们有这个从代码同步的添加新事件，我们基本上会遵循这个。

18790
25:46:36.392 --> 25:46:41.096
要做到这一点，我们显然需要开始并为事件创建选项。

18791
25:46:41.096 --> 25:46:46.879
我们有链地址主题，abi elimite，表名，同步历史然后我们

18792
25:46:46.879 --> 25:46:52.663
只做Morales。Cloud。run，观看云事件选项使用主键。

18793
25:46:52.663 --> 25:46:54.031
差不多就是这样了。

18794
25:46:54.031 --> 25:46:57.140
我们将遵循这些文档来编写代码。

18795
25:46:57.140 --> 25:46:58.688
让我们从列出的项目开始。

18796
25:46:58.688 --> 25:47:01.350
让我们为id列出的事件创建一些选项。

18797
25:47:01.350 --> 25:47:09.830
我们说，let item lists options，如果我们想的话也可以用const，这里我要写的是，let item lists options equals。

18798
25:47:09.830 --> 25:47:15.943
首先我们需要链ID，我们已经有了，因为我们要从莫拉莱斯那里得到。

18799
25:47:15.943 --> 25:47:22.411
关于chain ID首先要指出的是，ralis知道本地链是1337。

18800
25:47:22.411 --> 25:47:29.249
所以即使你用的是31337，如果你在做本地开发，你也要切换到1337。

18801
25:47:29.249 --> 25:47:33.588
我们再设一个变量叫做莫拉莱斯链ID。

18802
25:47:33.588 --> 25:47:38.876
我们就说，让莫拉莱斯的

18803
25:47:38.876 --> 25:47:44.164
链ID等于31337。

18804
25:47:44.164 --> 25:47:48.079
问号311337。

18805
25:47:48.079 --> 25:47:49.853
否则，chain

18806
25:47:49.853 --> 25:48:01.834
ID但是我们说因为Morales知道任何本地Dev都是1337，我们说如果chain ID等于31337。

18807
25:48:01.927 --> 25:48:04.910
那么莫拉莱斯链ID等于1337。

18808
25:48:06.927 --> 25:48:14.863
无论链的想法是什么，在点环境中我们可以决定，如果我们想做rink B, localhost main net等等。

18809
25:48:14.928 --> 25:48:19.893
我们会说，好，链ID morass会做你的Morales链ID，逗号，我们还需要

18810
25:48:19.893 --> 25:48:24.859
什么?我们做了chain ID，我们会跳过description，一个同步历史。

18811
25:48:24.928 --> 25:48:31.435
点击同步历史允许节点返回整个区块链，获取契约发出的所有事件。

18812
25:48:31.435 --> 25:48:37.583
因为这是一个非常小的本地区块链只会说sync history is true。

18813
25:48:37.583 --> 25:48:38.566
像这样。

18814
25:48:38.566 --> 25:48:45.061
好吧，我们还需要什么?好的，我们需要主题，主题将是你的事件信息。

18815
25:48:45.061 --> 25:48:51.428
要获得主题，回到我们的事件代码，主题将是事件的名称，加上参数的类型。

18816
25:48:51.428 --> 25:49:00.199
我们会回到代码，我们会回到这里，我们会说，topic is going to item lists，它有一个

18817
25:49:00.199 --> 25:49:09.134
地址，一个地址，一个地址，一个地址，你去了56，一个UNT 256，地址地址，你采访了6,YouTube和6。

18818
25:49:09.134 --> 25:49:14.685
那些问题看起来是这样的，我们还需要事件的API，我们可

18819
25:49:14.685 --> 25:49:20.237
以找到我们回到我们的硬帽项目，我们去工件，我们去契约。

18820
25:49:20.237 --> 25:49:28.673
如果市场。灵魂非ft市场。JSON，我们从这里开始的ABI将是整个合同的ABI。

18821
25:49:28.673 --> 25:49:31.100
我们只需要item列出事件。

18822
25:49:31.100 --> 25:49:33.789
我们按Ctrl F，我们在这里找到了它。

18823
25:49:33.928 --> 25:49:39.019
我们会在它说到type event之后进行抓取，我们会复制我们会向上

18824
25:49:39.019 --> 25:49:44.261
滚动到anonymous false，对吧，这一点描述了事件的ABI。

18825
25:49:44.261 --> 25:49:51.898
我们有内部类型，地址，名称，卖家类型，地址，如果T地址令牌ID price item lists，对吧，

18826
25:49:51.898 --> 25:49:59.535
这将是我们item lists事件的ABI，我们可以把它插入这里，点击保存，然后自动格式化它，去掉括号。

18827
25:49:59.535 --> 25:50:05.765
好，我们还需要什么，我们有主题，有ABI，我们已经有地址，我们不需要过滤器。

18828
25:50:05.765 --> 25:50:07.200
然后我们需要一个表名。

18829
25:50:07.200 --> 25:50:12.103
我们要新建一行，我们写入表名，它将是item lists。

18830
25:50:12.103 --> 25:50:16.329
这将是数据库中更新的表的名称。

18831
25:50:16.329 --> 25:50:22.640
我们会在这里得到一个新表，叫做item lists，它会填满关于item lists事件的信息。

18832
25:50:22.640 --> 25:50:25.816
这就对了，如果我们在UI上做这个，我们会点击确认。

18833
25:50:25.816 --> 25:50:31.309
因为我们在这里做，我们点击保存，这是我们的一个事件，我们想对所有事件都这样做。

18834
25:50:31.309 --> 25:50:32.832
让我们现在就为购买的物品结账。

18835
25:50:32.929 --> 25:50:37.625
我们写入item bought options，等于我们会重复这

18836
25:50:37.625 --> 25:50:42.322
个过程，顶部的一些东西是一样的，链也是一样的同步历史也是一样的。

18837
25:50:42.322 --> 25:50:48.025
我们可以抓取这两个，粘贴到item下面，但主题是不同的。

18838
25:50:48.025 --> 25:50:52.834
主题将是item bot是事件的名称，它将取一个地

18839
25:50:52.834 --> 25:50:57.643
址，一个地址，一个un 256和一个un 256。

18840
25:50:57.643 --> 25:51:00.691
ABI将会有所不同。

18841
25:51:00.691 --> 25:51:07.187
再一次，我们要去我们的Hardhead非ft市场，我们会寻找一个机器人，你会在这里找到这个活动。

18842
25:51:07.187 --> 25:51:15.976
我们复制这个，返回，粘贴到这里，我们有了item bot，我们给它一个表名item bot。

18843
25:51:15.976 --> 25:51:24.690
然后还有一个我们有let item cancelled options =我

18844
25:51:24.690 --> 25:51:33.404
们将做chain ID这将是唤醒chain ID将是来自顶层地址的相同样板。

18845
25:51:33.404 --> 25:51:36.381
合同地址的主题将有所不同。

18846
25:51:36.381 --> 25:51:44.719
这个的主题叫做item cancelled，它有一个地址，一个地址和一个unt256会说sync。

18847
25:51:44.719 --> 25:51:49.180
历史将是真实的，历史是真实的。

18848
25:51:49.180 --> 25:51:50.742
然后我们需要ABI。

18849
25:51:50.742 --> 25:51:55.782
再一次，我们可以回到我们的安全帽，编译信息

18850
25:51:55.782 --> 25:52:00.822
我们可以寻找取消的项目，获取事件的ABI。

18851
25:52:00.822 --> 25:52:01.893
收到

18852
25:52:01.893 --> 25:52:05.011
回到粘贴进来的运行代码。

18853
25:52:05.011 --> 25:52:06.830
哦，我没有给出项目取消。

18854
25:52:06.930 --> 25:52:12.766
让我们给item cancelled一个表名，它将是item cancelled。

18855
25:52:12.766 --> 25:52:18.360
缩小一点，就有取消选项和购买选项。

18856
25:52:18.360 --> 25:52:27.336
项目列表选项告诉罗斯，听这些事件，每当你听到一个项目取消事件，把所有这些东西都存入数据库。

18857
25:52:27.336 --> 25:52:35.336
当你听到一个物品购买事件时，把所有这些都存入数据库，当它发出一个列出的物品时，把所有这些都存入数据库以便我们可以从中读取。

18858
25:52:35.336 --> 25:52:38.372
所以我们为这些事件建立索引，这样我们就能更容易地查询它们。

18859
25:52:38.372 --> 25:52:44.837
现在把它们发送到我们的服务器会说const列

18860
25:52:44.837 --> 25:52:50.420
出的响应等于await或者Alice。

18861
25:52:50.420 --> 25:52:57.768
Cloud。run，观察契约事件会传递列出的选项。

18862
25:52:57.768 --> 25:53:06.716
再加一个逗号，然后我们传递一个对象到这里我们会说use master key是true。

18863
25:53:06.716 --> 25:53:12.479
我们会做同样的事情我们会说const bot response或传递bot item选项。

18864
25:53:12.479 --> 25:53:19.433
我们写入bot response = await或else。Cloud。

18865
25:53:19.433 --> 25:53:26.967
run, watch合约，事件，逗号，item bought options。

18866
25:53:26.967 --> 25:53:32.388
逗号，使用主键，这是真的。

18867
25:53:32.388 --> 25:53:39.214
最后康德的取消响应等于await oralis。Cloud。run,

18868
25:53:39.214 --> 25:53:44.835
watch contract event，逗号，item

18869
25:53:44.835 --> 25:53:52.866
cancelled options，逗号use master key将为真。

18870
25:53:52.866 --> 25:53:59.269
这个Morales。Cloud。run对服务器的API调用会返回一个响应。

18871
25:53:59.269 --> 25:54:03.167
让我们看一下文档看看如果它成功了，反应是什么样的。

18872
25:54:03.167 --> 25:54:03.439
好。

18873
25:54:03.439 --> 25:54:06.877
在终点站，你会看到真正的成功。

18874
25:54:06.877 --> 25:54:10.253
这是我们从API获得的返回值。

18875
25:54:10.253 --> 25:54:15.031
为了确保一切顺利，我列出一个if。

18876
25:54:15.031 --> 25:54:22.668
Response。success，我们从rails服务器获取那个success

18877
25:54:22.668 --> 25:54:30.502
对象，我们只做一个console。log success数据库，用监视事件更新。

18878
25:54:30.502 --> 25:54:37.145
然后我们会写console。log，鸭子出问题了。

18879
25:54:37.145 --> 25:54:43.744
当然，我们不只是要求response。success为真。

18880
25:54:43.744 --> 25:54:52.032
我们还希望取消响应成功和机器人响应成功。

18881
25:54:52.032 --> 25:54:54.151
然后说，嘿，你做到了。

18882
25:54:54.151 --> 25:54:56.716
否则就说嘿，出问题了。

18883
25:54:56.716 --> 25:55:02.265
这就是我们通过编程告诉服务器和数据库监听事件的方式。

18884
25:55:02.265 --> 25:55:08.832
我们只需要等待Murata Clodagh，运行，观察契约事件，我们将这个带有参数和标志的对象传递给它。

18885
25:55:08.832 --> 25:55:09.782
就这样了。

18886
25:55:09.782 --> 25:55:14.581
然后我们就可以发送了因为我放了下一个公共莫拉莱斯服务器的URL。

18887
25:55:14.581 --> 25:55:17.386
在我的车管所，我只有下一个公共服务器的URL。

18888
25:55:17.386 --> 25:55:18.899
我们把名字改一下。

18889
25:55:18.899 --> 25:55:20.640
看来我们的服务器地址是错的。

18890
25:55:20.640 --> 25:55:22.865
我们的应用ID名也错了。

18891
25:55:22.865 --> 25:55:26.839
让我们修复下一个公共app ID主键看起来正确。

18892
25:55:26.839 --> 25:55:27.515
好的,很酷。

18893
25:55:27.515 --> 25:55:32.405
让我们来了解一下，好吗?更像Alice, cada运行，

18894
25:55:32.405 --> 25:55:38.867
Rasta云运行，当我们在数据库中运行这个时，如果刷新，我们看不到这些表。

18895
25:55:38.867 --> 25:55:41.528
但一旦我们运行这个，添加事件。

18896
25:55:41.528 --> 25:55:45.474
Js，我们应该调用服务器告诉它，你需要添加这些表。

18897
25:55:45.474 --> 25:55:47.247
你需要开始倾听这些事件。

18898
25:55:47.247 --> 25:55:53.614
在一个新终端中，我们会运行这个添加事件，比如，我要把终端弄大一点。

18899
25:55:53.614 --> 25:55:57.994
这就是如果出现问题，弄清楚如何解决这个问题会让人有点沮丧的地方。

18900
25:55:57.994 --> 25:56:04.243
所以如果你在这里遇到了问题，如果有些东西没有按照预期工作，请使用与本课程相关的GitHub回购。

18901
25:56:04.243 --> 25:56:08.673
莫拉莱斯论坛和Stack Exchange ethereum也在这里。

18902
25:56:08.673 --> 25:56:14.270
我们运行Node，添加事件，点js，然后回车。

18903
25:56:14.270 --> 25:56:18.624
好了，现在我们看到成功数据库更新了监视事件。

18904
25:56:18.624 --> 25:56:23.176
如果你遇到一个问题，你重新运行它，它出现了一些错

18905
25:56:23.176 --> 25:56:27.728
误，它仍然有可能是正确的，因为它返回false。

18906
25:56:27.728 --> 25:56:31.793
它返回有一个问题，如果其中任何一个已经有表在那里。

18907
25:56:31.793 --> 25:56:39.725
回到数据库，点击刷新，我就能看到购买，取消和数据库中列出的商品。

18908
25:56:39.725 --> 25:56:44.674
同样，你可以通过点击服务器上的下拉菜单和仪表盘看到它们。

18909
25:56:44.674 --> 25:56:46.610
我们还可以看到事件同步状态。

18910
25:56:46.610 --> 25:56:51.131
这就是我们的数据库知道它需要监听一些事件的

18911
25:56:51.131 --> 25:56:55.869
方式，它在这里有所有关于如何监听事件的信息。

18912
25:56:55.933 --> 25:56:56.266
太酷了。

18913
25:56:56.266 --> 25:56:57.932
现在我们在监听事件。

18914
25:56:58.933 --> 25:57:04.826
这意味着我们的数据库正在监听区块链节点，它在监听这里的

18915
25:57:04.826 --> 25:57:10.719
事件它在监听这些项目列出的项目购买的项目，取消的事件。

18916
25:57:10.719 --> 25:57:15.983
所以让我们继续，在我们的硬帽非ft市场自由代码营窗口中测试它。

18917
25:57:15.983 --> 25:57:17.870
我们这里有一些脚本。

18918
25:57:17.870 --> 25:57:19.682
其中之一是薄荷和名单。

18919
25:57:19.682 --> 25:57:21.147
所以我们去了New NFT。

18920
25:57:21.147 --> 25:57:27.113
当我们在市场上列出一个NF T时，我们的mirallas数据库应

18921
25:57:27.113 --> 25:57:33.266
该听到这个项目列出的事件并继续将它插入到它所创建的项目列出的表中。

18922
25:57:33.266 --> 25:57:38.218
为了验证这一点，让我们打开Hardhead非金融市场回购的终端。

18923
25:57:38.218 --> 25:57:44.917
在实际运行之前，我们会为localhost运行明顿列表，确保我们

18924
25:57:44.917 --> 25:57:51.617
的硬帽节点与Morales服务器同步以便数据库能够获取那个事件。

18925
25:57:51.617 --> 25:57:54.666
需要连接本地硬帽节点。

18926
25:57:54.666 --> 25:57:59.617
所以我们会做纱线，硬帽运行脚本，薄荷和列表。

18927
25:57:59.617 --> 25:58:02.575
Js破折号，网络localhost。

18928
25:58:02.575 --> 25:58:03.432
让我们进入。

18929
25:58:03.432 --> 25:58:12.283
好的，minting，批准列表现在如果我们回到数据库，在快速刷新之后，你知道吗，我们看到我们的

18930
25:58:12.283 --> 25:58:21.322
数据库中确实有一个项目列出了事件，我们可以看到一个工具的信息我们可以看到一个块哈希，一个时间戳，

18931
25:58:21.322 --> 25:58:30.362
我们可以看到列出的令牌ID，我们可以看到清单的价格交易哈希，我们可以看到所有这些关于事件的信息。

18932
25:58:30.362 --> 25:58:32.552
现在它在数据库中供我们查询。

18933
25:58:32.552 --> 25:58:37.837
因此，如果您已经达到了这一点，那么您已经成功地使用Morales数据库设置了一个索引器。

18934
25:58:37.837 --> 25:58:40.425
你应该非常兴奋，因为这真的很强大。

18935
25:58:40.425 --> 25:58:43.610
现在我们进入高级阶段，我们开始做一些高级的东西。

18936
25:58:43.610 --> 25:58:45.772
如果你已经走到这一步，恭喜你。

18937
25:58:45.772 --> 25:58:47.318
这已经很酷了。

18938
25:58:47.318 --> 25:58:52.946
现在，这里还有一些我自己遇到过很多次的故障排除帮助，假设我

18939
25:58:52.946 --> 25:58:58.770
已经离开了这个项目，我已经停止了我的心跳，我现在就要停止它。

18940
25:58:58.770 --> 25:59:06.217
如果我停止，我的心脏有节点，我回到我的Morales管理，我将查看详细的开发链代理服务器，我现在断开了。

18941
25:59:06.217 --> 25:59:12.291
如果我点击这个刷新，我就断开了，因为我不再运行我的心脏标题。

18942
25:59:12.291 --> 25:59:15.114
如果我重新启动节点，我的笔记也重新启动了。

18943
25:59:15.114 --> 25:59:18.000
我的连接本地dev链命令仍在运行。

18944
25:59:18.000 --> 25:59:21.822
如果我刷新它，它会显示connected，这很好。

18945
25:59:21.822 --> 25:59:29.466
但是，如果我回到区块链，或者回到NFC市场脚本，我运行yarn, hardhat脚本，mint，然

18946
25:59:29.466 --> 25:59:37.267
后再次列表，network localhost，我回到数据库，然后刷新，我们不会看到这里列出的项目。

18947
25:59:37.267 --> 25:59:43.684
因此，我们的mirallas服务器正在寻找确保我们正在使用的区块链是相同的。

18948
25:59:43.684 --> 25:59:51.327
如果我们重置区块链，就像我们做的，取消它然后重置它，我们的数据库就会很混乱。

18949
25:59:51.327 --> 25:59:56.392
我们要做的是点击重置局部链，重置局部链，我

18950
25:59:56.392 --> 26:00:01.458
们要确保新的局部链在运行，并且连接到这里。

18951
26:00:01.458 --> 26:00:07.671
我们点击重置本地链，这将告诉他们罗斯，嘿，我们重置了链，没关系，请继续这样做。

18952
26:00:07.671 --> 26:00:12.312
一旦我们点击重置局部链，我们不会看到这个项列在这里。

18953
26:00:12.312 --> 26:00:21.197
但是，如果我们回去，重新运行mint和list网络，本地主机和这个重置本地链。

18954
26:00:21.197 --> 26:00:28.519
回到Morales数据库，点击刷新，就能看到新数据进入只要你停止了硬帽注释，

18955
26:00:28.519 --> 26:00:35.649
只要你重置了硬帽节点，你就需要到查看详细信息dev链代理服务器重置本地链。

18956
26:00:35.649 --> 26:00:39.709
你也可以用编程的方式来做，我们不打算讲如何用编程的方式来做。

18957
26:00:39.709 --> 26:00:42.839
但这可能是你想在你的安全帽部署中添加的东西。

18958
26:00:42.839 --> 26:00:47.883
另一件需要注意的事是它没有清除上一个事件，对吧。

18959
26:00:47.935 --> 26:00:56.786
如果我在完成后再列出一分钟，这里会有另一个事件。

18960
26:00:56.935 --> 26:00:58.180
好吧，这太棒了。

18961
26:01:00.935 --> 26:01:04.176
我们做的所有这些首先是为了在索引中。

18962
26:01:04.176 --> 26:01:05.917
我们可以开始监听事件。

18963
26:01:05.917 --> 26:01:08.338
我们如何显示最近的侦听实体。

18964
26:01:08.338 --> 26:01:11.335
现在我们有了一个列出实体的数据库。

18965
26:01:11.335 --> 26:01:16.273
我们能做的是，查询这个itemlists表格并抓取这里的所有东西。

18966
26:01:16.273 --> 26:01:23.535
然而，我们有一个问题，如果有人买了一个NFT，会发生什么，如果有人买了一个NFT，项目列出的事件仍然在我们的数据库中。

18967
26:01:23.535 --> 26:01:26.386
但严格来说，它不会再出现在市场上了。

18968
26:01:26.386 --> 26:01:28.579
它会消失，不会被列出来。

18969
26:01:28.579 --> 26:01:33.499
我们能做什么呢，我们可以做很多架构选择来绕过这个问题来解决这个问题。

18970
26:01:33.499 --> 26:01:37.936
但我们能做的一件事是我们能使用mirallas云功能。

18971
26:01:37.936 --> 26:01:45.120
所以Morales云功能让我们能够在士气服务器上添加任何我们想要的前端操作。

18972
26:01:45.120 --> 26:01:45.858
这些是函数。

18973
26:01:45.858 --> 26:01:49.567
这些脚本可以随时在士气服务器上运行。

18974
26:01:49.567 --> 26:01:53.516
我们到服务器点击下拉菜单，点击云功能。

18975
26:01:53.516 --> 26:01:59.212
现在我们可以在其他地方写入东西以便随时在服务器上运行。

18976
26:01:59.212 --> 26:02:06.950
我们会在IDE中设置云功能通过点击这个小滴来同步我们的Visual Studio代码

18977
26:02:06.950 --> 26:02:14.689
和云功能，我们可以在这里运行这个命令，它会把我们在某个云文件夹中的云功能添加到这里。

18978
26:02:14.689 --> 26:02:21.426
我们能在VS代码中做的是，创建一个新文件夹，名为Cloud Functions。

18979
26:02:21.426 --> 26:02:27.857
在这里，我们会创建一个新文件Update, active items。

18980
26:02:27.857 --> 26:02:28.075
js。

18981
26:02:28.075 --> 26:02:36.613
在这里，如果我们写console。log，我们可以自动保存到士气服务器上。

18982
26:02:36.613 --> 26:02:39.478
我们的方法是运行这个命令。

18983
26:02:39.478 --> 26:02:45.739
现在，我们想让运行这个命令变得容易得多而不是总是要运行这个庞大的东西。

18984
26:02:45.739 --> 26:02:52.789
我们要做的是打开我们的package json，我们会在这里创建另一个Morales脚本，就在这下面，我们会

18985
26:02:52.789 --> 26:02:59.840
创建另一个Morales脚本，我们会写Morales Morales cloud，我们会有它，运行这个命令。

18986
26:02:59.840 --> 26:03:05.461
我们将复制这个命令，粘贴到我们的package json中。

18987
26:03:05.461 --> 26:03:13.903
这是Morales admin CLI, watchcloud folder，我们不需要Morales API键，因为它会从环境变量中获取那个。

18988
26:03:13.937 --> 26:03:21.750
我们不需要唤醒秘密，因为它会从环境变量中获取它，我们需要士气子域autosave。

18989
26:03:21.750 --> 26:03:27.343
然后Morales云文件夹是新的云

18990
26:03:27.343 --> 26:03:32.937
功能出价我们做了斜杠云功能，函数。

18991
26:03:32.937 --> 26:03:40.623
现在，在一个新的终端，如果我运行yarn，更多Alice cloud，这和

18992
26:03:40.623 --> 26:03:48.517
运行这个大函数是一样的，我按回车键，它会显示编译，版本，编译，修改上传正确。

18993
26:03:48.517 --> 26:03:54.396
如果我们回到我们的前端，我们可以看到这个console。log ky我们的前端正在更新。

18994
26:03:54.396 --> 26:04:01.871
如果我们继续在Jas的更新活动项中运行这个，我们还可以写入console。log，保存它。

18995
26:04:01.871 --> 26:04:05.454
如果这个还在运行，它会自动上传。

18996
26:04:05.454 --> 26:04:11.264
现在我们可以看到如果我们稍微刷新一下我们的前端云功能，我们可以看到它已经上传了。

18997
26:04:11.264 --> 26:04:17.435
此时，如果你有很多这样的东西在运行，你可能会看到CPU 100%，你可

18998
26:04:17.435 --> 26:04:23.784
能会看到这个小东西弹出，服务器可能会开始变慢，我们开始使用大量网络活动。

18999
26:04:23.784 --> 26:04:28.004
现在我要结束我的莫拉莱斯故事了。

19000
26:04:28.004 --> 26:04:30.625
需要的时候我只上传一次。

19001
26:04:30.625 --> 26:04:35.567
因为我们是连接的，我们让它听事件，我们让它在这里做越来越多的事情。

19002
26:04:35.567 --> 26:04:38.199
它会开始给服务器带来大量的负载。

19003
26:04:38.199 --> 26:04:41.307
我们要把它消掉。

19004
26:04:41.307 --> 26:04:42.780
现在的CPU就低很多了。

19005
26:04:42.780 --> 26:04:46.537
回到云功能，我们可以看到它还在这里。

19006
26:04:46.537 --> 26:04:51.410
当我们更新云功能时，它会用这些云功能更新我们的服务器。

19007
26:04:51.410 --> 26:04:54.814
完事后我们就去运行那该死的沼泽云。

19008
26:04:54.814 --> 26:05:03.188
不管怎样，现在我们正试图弄清楚，好吧，我们有商品列出来，但如果有人买了一件商品，严格来说，它将不再列出来。

19009
26:05:03.188 --> 26:05:05.971
但是我们的项目列表表仍然会列出它。

19010
26:05:05.971 --> 26:05:09.438
我们能做的是创建一个云功能，它可以随时运行。

19011
26:05:09.438 --> 26:05:12.276
就像我说的，我们可以让它们随时运行。

19012
26:05:12.276 --> 26:05:13.709
我们可以随时调用它们。

19013
26:05:13.709 --> 26:05:16.148
但我们要创建一个只运行的云功能。

19014
26:05:16.148 --> 26:05:23.931
当这些事件中有一个被同步时取消或购买，我们会创建一个名为活动项目的新表，活动项目会

19015
26:05:23.931 --> 26:05:31.905
说，任何时候它被列出，它都是活动的，但当它被购买或取消时，它会从活动项目列表中删除。

19016
26:05:31.905 --> 26:05:33.695
我们要创建一个新表。

19017
26:05:33.695 --> 26:05:35.282
我们来做一下。

19018
26:05:35.282 --> 26:05:37.412
我们从爱丽丝的想法开始。

19019
26:05:37.412 --> 26:05:45.776
如果你是IT审核员，你不需要这个，我们不需要在这里导入Morales，因为我们将把它作为云功能上传。

19020
26:05:45.776 --> 26:05:49.723
我们的服务器已经自动向我们的脚本中注入mirallas。

19021
26:05:49.723 --> 26:05:58.179
我们在保存后写上Morales。cloud，你可以用Morales cloud做很多事情。

19022
26:05:58.179 --> 26:06:00.840
这些都可以在文档中找到。

19023
26:06:00.938 --> 26:06:06.674
after save关键字意味着在指定的表上保存数据时，我们将执行一些操作。

19024
26:06:06.674 --> 26:06:08.398
它有两个参数。

19025
26:06:08.398 --> 26:06:12.318
它取保存后我们想要做的表。

19026
26:06:12.318 --> 26:06:13.841
我们会说item lists。

19027
26:06:13.938 --> 26:06:20.824
只要有东西保存到item列表中，我们就会运行async函数。

19028
26:06:20.938 --> 26:06:22.364
我们会把请求写在这里。

19029
26:06:23.938 --> 26:06:26.043
保存后，它附带一个请求。

19030
26:06:27.938 --> 26:06:31.338
发生时，我们希望将其添加到活动项列表中。

19031
26:06:31.938 --> 26:06:35.648
随之而来的请求被标记为确认请求。

19032
26:06:35.939 --> 26:06:40.749
我们用const confirmed因为每个请求，每个事件都会被触发两次。

19033
26:06:40.749 --> 26:06:46.576
一旦事务通过，它会触发保存，一旦事务被确

19034
26:06:46.576 --> 26:06:52.404
认，我们只希望在事务被确认时更新活动项。

19035
26:06:52.404 --> 26:06:57.605
我们写入const confirmed = request。object。get confirmed。

19036
26:06:57.605 --> 26:07:02.204
筛选，从该请求获得确认的属性。

19037
26:07:02.204 --> 26:07:10.234
然后我们还会让一个logger会说const logger = oralis。Cloud。get logger。

19038
26:07:10.234 --> 26:07:17.237
你马上就会明白为什么，我们可以用这个log写log到我们的Morales数据库。

19039
26:07:17.237 --> 26:07:20.890
所以我们可以把任何对数加到这里，我马上会演示给你们看。

19040
26:07:20.939 --> 26:07:23.412
控制台记录器莫拉莱斯。云，找到记录器。

19041
26:07:23.939 --> 26:07:26.839
我们只写logger。info。

19042
26:07:26.939 --> 26:07:32.126
寻找确定的x，我们现在就可以验证它。

19043
26:07:32.126 --> 26:07:34.813
好吧，我们现在就可以测试一下。

19044
26:07:34.813 --> 26:07:35.563
在日志里。

19045
26:07:35.563 --> 26:07:43.532
我们应该看到寻找确认TX一旦一个项目列出和保存现在测试这只是为了测试我们的记录器是实际工作。

19046
26:07:43.532 --> 26:07:51.549
让我们运行纱线，纱线罗斯云只是更新活动项目到我们的士气服务器更改上传正确。

19047
26:07:51.549 --> 26:07:53.176
好吧，我们现在就杀了它。

19048
26:07:53.176 --> 26:07:57.355
现在我们有了明顿，列表脚本。

19049
26:07:57.355 --> 26:07:59.188
让我们运行明顿列表。

19050
26:07:59.188 --> 26:08:02.389
我们应该能在服务器上看到这些日志。

19051
26:08:02.389 --> 26:08:05.048
到服务器，这里刷新一下。

19052
26:08:05.048 --> 26:08:11.507
如果我们现在看看我们的日志，我们现在可以看到在我们的服务器日志中寻找确认的TX。

19053
26:08:11.507 --> 26:08:12.334
现在在log中。

19054
26:08:12.334 --> 26:08:17.009
这里我们看到我们只会寻找一次确认的TX我刚刚告诉过

19055
26:08:17.009 --> 26:08:21.685
你们，它实际上会触发两次一次是在事务第一次发送时。

19056
26:08:21.685 --> 26:08:26.569
一旦交易被确认，也就是区块确认。

19057
26:08:26.569 --> 26:08:34.617
另外，如果我们查看数据库中列出的项目，并一直向右滚动，我们可以看到确认等于假。

19058
26:08:34.617 --> 26:08:41.214
因此，我们只想在确认为真时计算此项目列出的事件交互项目。

19059
26:08:41.214 --> 26:08:46.937
我们要做的是更新我们的脚本，在我们的本地Hardhead区块链

19060
26:08:46.937 --> 26:08:52.661
上添加一个块确认，这样这些就可以被更改为确认，来解决这个问题。

19061
26:08:52.661 --> 26:08:57.058
在我的mentalist脚本中，我通常会添加一个新的工具。

19062
26:08:57.058 --> 26:09:02.560
我到utils，新建文件，然后创建一个move blocks。

19063
26:09:02.560 --> 26:09:02.766
js。

19064
26:09:02.766 --> 26:09:08.649
这是我用来移动方块的工具。

19065
26:09:08.649 --> 26:09:13.908
当我们运行自己的心帽节点时，我们实际上可以完全控制我们想让心帽节点做什么。

19066
26:09:13.908 --> 26:09:18.697
我们能做的是，我们可以手动挖掘节点并向前移动区块，这样Morales

19067
26:09:18.697 --> 26:09:23.627
就知道，哦，好吧，这个交易被确认了，对吧，因为我们正在用交易挖掘区块。

19068
26:09:23.627 --> 26:09:28.500
就这样，罗斯就只能永远等着下一个街区了。

19069
26:09:28.500 --> 26:09:33.430
所以我们想在脚本中添加一些功能，在它完成后我们只挖掘一个块。

19070
26:09:33.430 --> 26:09:40.035
现在，请记住，如果我们快速挖出1000块或一吨块，Moorehouse可能很难索引它。

19071
26:09:40.035 --> 26:09:45.181
所以我们每次只挖矿一个，给我足够的时间索引每一个挖矿的数据块。

19072
26:09:45.181 --> 26:09:47.289
我们会建立一个小脚本，

19073
26:09:47.289 --> 26:09:54.190
我们会手动挖矿使用这个EVM挖矿RPC方法它和我们的心帽区块链一起来的。

19074
26:09:54.190 --> 26:09:55.784
我们有了这个新的move blocks脚本。

19075
26:09:55.784 --> 26:09:57.330
我们来做这个。

19076
26:09:57.330 --> 26:10:05.730
这不是我们的脚本，我们会在底部有一个主函数，我们会让这是一个实用程序我们会导入到其他脚本中。

19077
26:10:05.730 --> 26:10:10.392
这里我们不需要一个主函数，我们只需要把它变成一个async函数。

19078
26:10:10.392 --> 26:10:12.246
我们称之为move blocks。

19079
26:10:12.246 --> 26:10:16.617
然后我们写入amount，这是我们想要移动的块的数量，

19080
26:10:16.617 --> 26:10:24.389
我们还会设置一个sleep amount默认为0，这个sleep amount将是一个可选参数。

19081
26:10:24.389 --> 26:10:32.607
如果我们想移动方块，在方块之间休息一秒钟，就像一个真正的区块链，我们也可以在这里有它。

19082
26:10:32.607 --> 26:10:40.141
所以我们可以让它像一个真正的区块链，通过在方块移动时休眠，或者在方块移动时等待。

19083
26:10:40.141 --> 26:10:46.628
在移动块脚本中，我们会写console。log，移动块，点那个点，我们会说，for

19084
26:10:46.628 --> 26:10:53.115
let index = 0，我们会绕着amount做一个for循环称之为EVM。

19085
26:10:53.115 --> 26:10:59.544
我在for循环中的index小于amount index加上一个权值网络。

19086
26:10:59.544 --> 26:11:07.731
然后我们要导入network哦，我们要从硬帽导入network, await network。provider。request。

19087
26:11:07.731 --> 26:11:16.207
然后我们会请求方法ev mime逗号params都是空的。

19088
26:11:16.207 --> 26:11:20.734
这和我们对区块链节点进行原始调用的方式是一样的。

19089
26:11:20.734 --> 26:11:26.891
我们没有做很多这样的事情，因为以太把它抽象在引子下，但我们对EVM做了一个原始的调用。

19090
26:11:26.891 --> 26:11:34.166
显然，您不能在一个真正的区块链上调用EVM挖矿，因为您不能只是告诉区块链节点挖下一个块。

19091
26:11:34.166 --> 26:11:41.299
因为这是我们的本地硬帽节点，我们可以调用VM现在我们会说如果sleep amount

19092
26:11:41.299 --> 26:11:48.433
大于0，或者只是sleep mount，那么我们也会让这个脚本休眠或等待一小段时间。

19093
26:11:48.433 --> 26:11:55.760
在上面，我们会创建一个新函数叫做sleep，它会输入一个以毫秒为单位的时间。

19094
26:11:55.760 --> 26:12:00.411
这将返回一个新的承诺，对吧?因为记住，为了让我们

19095
26:12:00.411 --> 26:12:05.257
等待一段时间我们必须使用承诺，这是我们之前学过的。

19096
26:12:05.257 --> 26:12:10.243
这个承诺将取一个具有解析的函数作为输入参数。

19097
26:12:10.243 --> 26:12:17.535
我们会说，settimeout将是resolve，逗号，Ms中的time。

19098
26:12:17.535 --> 26:12:21.528
JavaScript的睡眠方式是返回一个新承诺。

19099
26:12:21.528 --> 26:12:25.595
我们把这个叫做set timeout函数，它基本上是以毫秒为单位对时间进行加权。

19100
26:12:25.595 --> 26:12:26.525
现在来看看真正的睡眠。

19101
26:12:26.525 --> 26:12:32.708
我们用console。log表示睡眠量。

19102
26:12:32.942 --> 26:12:39.275
然后我们用await, sleep, sleep amount，单位是毫秒。

19103
26:12:39.275 --> 26:12:45.322
既然sleep返回了一个promise，我们可以用await调用它，等待这个sleep函数完成。

19104
26:12:45.322 --> 26:12:52.127
睡眠函数只有在以毫秒为单位的时间结束时才会结束。

19105
26:12:52.127 --> 26:12:57.714
现在我们有了一个叫move blocks的函数，它会在我们的本地区块链上挖掘block，

19106
26:12:57.714 --> 26:13:04.189
这样Morales就能确认它正在寻找的block现在在底部，我们只需要做module。exports,

19107
26:13:04.189 --> 26:13:10.666
move blocks, move blocks，然后我们还会导出sleep，为什么不呢?就像这样。

19108
26:13:10.666 --> 26:13:16.957
现在，我们能在明顿列表中做的是，在顶部，我们会说const, move

19109
26:13:16.957 --> 26:13:24.328
blocks = require。。/ utils / move blocks。

19110
26:13:24.328 --> 26:13:28.332
然后我们还会从以太网络导入网络。

19111
26:13:28.332 --> 26:13:30.085
在我们的脚本中是向下的。

19112
26:13:30.085 --> 26:13:37.935
就在底部，我们会说if network。config，那个chain ID = = 31337 await,

19113
26:13:37.935 --> 26:13:46.076
move blocks，我们会说我们会移动到blocks然后我们也会说sleep amount = 1000。

19114
26:13:46.076 --> 26:13:49.688
每挖一个区块，我们会等待一毫秒。

19115
26:13:49.688 --> 26:13:52.943
所以sleep mount等于1000，也就是1毫秒。

19116
26:13:52.943 --> 26:13:56.387
现在让我们把这些都评论一下。

19117
26:13:56.387 --> 26:13:59.800
我们只运行这个脚本。

19118
26:13:59.800 --> 26:14:07.680
好的，我们会把这个拉上来，纱线硬帽，运行脚本，mentalist破折号网络，

19119
26:14:07.680 --> 26:14:15.561
本地主机，我们只会移动块移动回我们的前端，我们会刷新，我们会去看列出的项目。

19120
26:14:15.561 --> 26:14:19.133
我们往右滚动，现在我们看到确认为真。

19121
26:14:19.133 --> 26:14:23.713
现在如果我们查看我们的日志，我们会看到记录项发生了两次。

19122
26:14:23.713 --> 26:14:26.756
好了，我们取消注释，继续。

19123
26:14:26.756 --> 26:14:34.943
现在我们有了这个现在我们学习了日志记录，现在我们做了所有这些事情，我们可以说If confirmed，我们将要做一些事情。

19124
26:14:34.943 --> 26:14:38.807
如果确认，我们将创建一个名为active item的表并将其添加到active item表中。

19125
26:14:38.807 --> 26:14:42.306
我们要做一个logger。info bound item。

19126
26:14:42.306 --> 26:14:47.580
我们将在这个表中创建一个新表和一个新条目。

19127
26:14:47.580 --> 26:14:51.951
因此我们写入const active item = more

19128
26:14:51.951 --> 26:14:57.343
Alice。object。extend ACC active item。

19129
26:14:57.343 --> 26:15:02.878
这里我们说的是，如果活动项存在，抓取它，如果不创建它。

19130
26:15:02.944 --> 26:15:07.801
我们会创建这个活动项目表如果它不存在，很好，抓取它。

19131
26:15:07.801 --> 26:15:12.360
我们会说const active item = new, active item。

19132
26:15:12.360 --> 26:15:17.705
我们要在这个活动项目表中创建一个新条目。

19133
26:15:17.705 --> 26:15:20.943
我们说active item。set。

19134
26:15:20.943 --> 26:15:25.895
我们可以为新建的表格设置任意列。

19135
26:15:25.944 --> 26:15:28.232
我们给它一个市场地址列。

19136
26:15:28.944 --> 26:15:31.239
市场地址。

19137
26:15:35.944 --> 26:15:42.213
object。get address所有这些来自事件的请求都带

19138
26:15:42.213 --> 26:15:46.662
有它们来自的地址，对我们来说，这是市场地址，

19139
26:15:46.662 --> 26:15:55.157
我们会做active item set如果T地址，这些事件保存的带有事件的所有参数。

19140
26:15:55.157 --> 26:16:02.219
我们会说request那个object。get NFT address会得到价

19141
26:16:02.219 --> 26:16:08.557
格会说active item。set price将会是request。

19142
26:16:08.557 --> 26:16:15.438
object。get price将会得到令牌ID会说active item。

19143
26:16:15.438 --> 26:16:19.603
set令牌ID request。object。

19144
26:16:19.603 --> 26:16:31.194
get令牌ID然后我们会得到卖方会说active item。set seller将会请求那个object。get seller。

19145
26:16:31.194 --> 26:16:37.147
我们从事件中得到所有这些信息。

19146
26:16:37.147 --> 26:16:42.366
Ross的事件更新总是自动带有事件被遗漏的地址。

19147
26:16:42.366 --> 26:16:45.419
我们会抓取所有我们会创建这个活动项目表。

19148
26:16:45.419 --> 26:16:47.145
我们要把所有这些行相加。

19149
26:16:47.145 --> 26:16:50.267
我们要把这一行加上所有这些列。

19150
26:16:50.267 --> 26:16:50.783
太棒了。

19151
26:16:50.783 --> 26:16:54.833
现在我们用logger。info来打印一下。

19152
26:16:54.833 --> 26:16:56.221
我们说addingaddress。

19153
26:16:56.221 --> 26:17:01.901
我们会做一点字符串插值我们会说request。object。get

19154
26:17:01.901 --> 26:17:11.714
addressperiod token ID with request。object。get token ID。

19155
26:17:11.714 --> 26:17:15.745
我得把这堵上，堵得更好。

19156
26:17:15.745 --> 26:17:22.500
然后在logger。info之外，我们会说logger。info，保存。

19157
26:17:22.500 --> 26:17:27.634
然后运行await activeitem。save。

19158
26:17:27.634 --> 26:17:32.812
现在我们有了云功能，它会在新表中创建一个新

19159
26:17:32.812 --> 26:17:37.991
的条目，叫做活动条目，只要列出的条目发生。

19160
26:17:37.991 --> 26:17:44.897
后项称为云功能的触发器，不同的罗斯云功能有很多不同的触发器。

19161
26:17:44.945 --> 26:17:53.599
如果你去莫拉莱斯的文档，我们寻找触发器，我们可以在这里找到所有这些不同的触发器的列表，比如在save之后为save。

19162
26:17:53.599 --> 26:17:58.579
保存后，删除前，删除后，保存文件前，

19163
26:17:58.579 --> 26:18:03.006
有各种不同的触发器来触发云代码。

19164
26:18:03.006 --> 26:18:09.178
现在，如果我们把这个新脚本上传到士气服务器上并正确上传纱线沼泽和云更改，好，很好，我们可以杀死它。

19165
26:18:09.178 --> 26:18:15.064
回到云服务器，稍微刷新一下确保它没有继续处理更新。

19166
26:18:15.064 --> 26:18:16.183
好的，cpu足够低。

19167
26:18:16.183 --> 26:18:16.793
好了,好了。

19168
26:18:16.946 --> 26:18:20.284
在数据库中，这里没有活动项目表。

19169
26:18:20.284 --> 26:18:28.253
但如果我们回到Hardhead脚本，调用mint和list，因为现在我们有一个云

19170
26:18:28.253 --> 26:18:36.422
函数，它说，任何时候，项目列表事件发生，更新活动项目表，我们应该看到活动项目更新。

19171
26:18:36.422 --> 26:18:37.564
让我们运行这个。

19172
26:18:37.564 --> 26:18:42.300
记住，我们需要让心头节点连接到硬帽。

19173
26:18:42.300 --> 26:18:46.325
如果我们重置本地链，我们需要点击重置本地链按钮。

19174
26:18:46.325 --> 26:18:48.053
所以我们继续，我们运行了这个。

19175
26:18:48.053 --> 26:18:51.720
回到数据库，稍微刷新一下。

19176
26:18:51.720 --> 26:18:53.849
现在我什么都没看到。

19177
26:18:53.946 --> 26:18:59.657
如果我打开我的日志到信息，我可以看到任何错误或问题。

19178
26:18:59.657 --> 26:19:07.673
所以看起来在保存失败后，为用户列出的项目，等等，等等，看起来有一个问题，不能读取未定义的读扩展的属性。

19179
26:19:07.673 --> 26:19:10.526
这也在信息里，我出了个问题。

19180
26:19:10.526 --> 26:19:13.071
我并没有写完所有的代码。

19181
26:19:13.071 --> 26:19:17.296
回到更新活动项，我能看到我搞砸了哪里。

19182
26:19:17.296 --> 26:19:21.252
它应该是带有大写O点范围的Morales点对象。

19183
26:19:21.252 --> 26:19:26.583
我要做的是，再次运行yarn morass cloud，现在我已经把它修改好了，我

19184
26:19:26.583 --> 26:19:31.914
们要取消它，我们要再次运行mminton list，现在我们已经修复了我们的脚本。

19185
26:19:31.914 --> 26:19:36.561
现在我们已经修复了脚本，回到数据库，稍微

19186
26:19:36.561 --> 26:19:41.208
刷新一下，我可以看到这里有一个活动条目。

19187
26:19:41.208 --> 26:19:48.300
在这一点上，有些时候你不想离开去喝杯咖啡，或者去上个厕所或者去吃点东西。

19188
26:19:48.300 --> 26:19:51.418
你需要停止终端的运行。

19189
26:19:51.418 --> 26:19:56.677
让我们练习重新启动所有东西重新进入本地开发环境。

19190
26:19:56.677 --> 26:19:58.759
因为这可能会有点奇怪，有点棘手。

19191
26:19:58.759 --> 26:20:00.196
我们来练习一下。

19192
26:20:00.196 --> 26:20:02.375
我们再来看这里。

19193
26:20:02.375 --> 26:20:11.222
我们需要做什么?按Ctrl C，终止区块链按Ctrl C，终止到Morales服务器的连接。

19194
26:20:11.222 --> 26:20:16.587
如果我们在前端运行Ctrl C，现在如果我们到服务器，我们去查看细节。

19195
26:20:16.587 --> 26:20:23.087
开发链代理服务器，如果我们点击状态，这个重置按钮仍然会我们现在将断开。

19196
26:20:23.087 --> 26:20:25.008
现在一切都被切断了。

19197
26:20:25.008 --> 26:20:33.916
现在如果我们想重新启动一切，如果我们在我们的心帽非ft市场将运行yarn Hardhead节点，这将再次旋转一切，

19198
26:20:33.916 --> 26:20:42.982
我们将运行yarn Morales同步与我们的路由连接同步，我们可以回到我们的服务器将查看细节，我们现在应该连接了。

19199
26:20:42.982 --> 26:20:43.517
连接。

19200
26:20:43.517 --> 26:20:50.232
因为我们重新启动了本地区块链，我们现在需要记住执行重置本地链，我们会继续运行那个。

19201
26:20:50.232 --> 26:20:50.660
太好了。

19202
26:20:50.660 --> 26:20:56.786
如果我们想重新启动前端，我们可以像这样重新启动前端现在的问题是，我们的数据库

19203
26:20:56.786 --> 26:21:02.913
仍然会有即使我们刷新它即使我们重置本地区块链，它仍然会有所有这些东西在里面。

19204
26:21:02.947 --> 26:21:08.013
现在这里的这些项是来自一个不再存在的区块链的项。

19205
26:21:08.013 --> 26:21:14.881
我通常会点击上面这个按钮，然后删除这个类中的所有行。

19206
26:21:14.947 --> 26:21:18.619
为了确认我们做的活动项目，读取表的名称。

19207
26:21:18.947 --> 26:21:20.423
让我们对列出的项目也这样做。

19208
26:21:21.947 --> 26:21:23.928
所有行，列出项目。

19209
26:21:23.928 --> 26:21:25.060
是的,删除。

19210
26:21:26.947 --> 26:21:27.309
刷新。

19211
26:21:27.309 --> 26:21:29.067
这里所有的都是0。

19212
26:21:29.947 --> 26:21:32.518
这些事件的空数据库在我们的后保存在这里。

19213
26:21:32.947 --> 26:21:40.773
我们在脚本中添加了一些权重，让我们回到我们的硬帽非ft市场，我们将运行yarn, RT

19214
26:21:40.773 --> 26:21:49.328
hat，运行脚本，mint和list。j s dash dash network，本地主机。

19215
26:21:49.328 --> 26:21:53.967
这会让它被铸造，被列出来然后我们挖出两个区块给莫

19216
26:21:53.967 --> 26:21:58.800
拉莱斯时间来索引我们的活动然后在一个士气服务器上。

19217
26:21:58.800 --> 26:22:05.173
我们继续并刷新，现在我们看到项目被列出为一个，活动项目同时是一个。

19218
26:22:05.173 --> 26:22:10.922
这就是我们如何确保，当我们调用一个函数时，Morales总是索引，我们

19219
26:22:10.922 --> 26:22:16.672
只需要介意一个额外的块，告诉Morales，嘿，那个事务确实被确认了。

19220
26:22:16.672 --> 26:22:17.654
真的很令人兴奋。

19221
26:22:17.654 --> 26:22:21.578
我们还练习了关闭和重新开始，做了所有的好事情。

19222
26:22:21.578 --> 26:22:23.614
这太棒了。

19223
26:22:23.614 --> 26:22:31.340
现在我们有了这个额外的功能让其他人更容易操作好，很好，我们可以检查活动项目。

19224
26:22:31.340 --> 26:22:36.429
我们还没做完呢，对吧?因为如果有人购买了非功能性的，或者出售了

19225
26:22:36.429 --> 26:22:41.684
一个实体我们应该移除活动项目?对，现在一件活动物品里只列了一件。

19226
26:22:41.684 --> 26:22:46.510
但如果我们买了一件商品，活动商品仍然会显示该商品是活动的。

19227
26:22:46.510 --> 26:22:55.301
让我们继续，让我们更新我们的云功能，也就是说，当一个商品被购买时，我们将该商品从活动状态中移除。

19228
26:22:55.301 --> 26:22:57.454
我们在保存后再创建一个。

19229
26:22:57.454 --> 26:22:59.226
让我们首先构建这个来取消项目。

19230
26:22:59.226 --> 26:23:01.431
然后我们会建立一个购买项目。

19231
26:23:01.431 --> 26:23:10.053
为了在保存后再创建一个触发器，我们写入mirallas。Cloud。after save，我们写入item cancelled。

19232
26:23:10.053 --> 26:23:16.530
这将是一个async函数它再次将请求作为输入参数，我们会做同样的事情。

19233
26:23:16.530 --> 26:23:19.578
我们说const confirmed =

19234
26:23:19.578 --> 26:23:25.674
request那个object。get confirmed，我们说const。

19235
26:23:25.674 --> 26:23:30.124
Logger等于routes。Cloud。get Logger，像这样。

19236
26:23:30.124 --> 26:23:32.316
然后是logger。

19237
26:23:32.316 --> 26:23:33.894
哦，小写的L。

19238
26:23:33.894 --> 26:23:37.232
然后我们会写logger。info。

19239
26:23:37.232 --> 26:23:44.094
marketplace，这个小管道对象然后是request。object。

19240
26:23:44.094 --> 26:23:47.466
然后我们做同样的事情。

19241
26:23:47.466 --> 26:23:48.138
如果确认。

19242
26:23:48.138 --> 26:23:53.631
如果这个事务在一个块后被确认，我们将从活动项中删除它。

19243
26:23:53.631 --> 26:23:57.749
我们将使用一个查询首先找到被取消的活动项。

19244
26:23:57.749 --> 26:24:00.556
您可以在Morales文档中了解更多关于基本查询的知识。

19245
26:24:00.556 --> 26:24:05.954
我们将通过const active item = more outlets

19246
26:24:05.954 --> 26:24:11.499
那个对象对于大写的O对象。extend active item来获得那个表。

19247
26:24:11.499 --> 26:24:13.399
我们会创建一个新的查询。

19248
26:24:13.399 --> 26:24:17.626
在设置或保存数据之前，我们会先查询表格。

19249
26:24:17.626 --> 26:24:24.756
我们会说const, query, query = new Morales。query of active item。

19250
26:24:24.756 --> 26:24:29.323
我们会查询Morales数据库找到一个活

19251
26:24:29.323 --> 26:24:34.120
动项，它会匹配这里的请求，我们可以取消它。

19252
26:24:34.120 --> 26:24:37.977
我们会说query。equal to

19253
26:24:37.977 --> 26:24:46.550
marketaddress，逗号request那个对象。get address，

19254
26:24:46.550 --> 26:24:52.981
我们在寻找一个活动项目其中市场地址将与取消项目的地址相同。

19255
26:24:52.981 --> 26:25:00.537
我们会说query。equal = nft address，逗号request。

19256
26:25:00.537 --> 26:25:07.527
object。get一个ft address会说query。equal =

19257
26:25:07.527 --> 26:25:15.085
token ID，逗号request。object。get token ID。

19258
26:25:15.085 --> 26:25:19.802
应该是这样吧?让我们再看一下我们的契约。

19259
26:25:19.802 --> 26:25:26.686
取消的项目给我们一个卖家NFC地址和一个令牌ID卖家ft地址和一个令牌ID。

19260
26:25:26.686 --> 26:25:32.512
我们正在寻找非ft地址和令牌ID，我们不需要寻找卖家，我们只需要寻找这两个。

19261
26:25:32.512 --> 26:25:33.887
当然，还有市场地址。

19262
26:25:33.950 --> 26:25:34.337
太好了。

19263
26:25:36.950 --> 26:25:42.473
Info，然后我们会打印出marketplace类型的查询。

19264
26:25:42.950 --> 26:25:45.700
然后我们会打印出我们正在运行的这个查询。

19265
26:25:45.950 --> 26:25:52.916
然后我们可以说const, cancelled item = await query。

19266
26:25:52.916 --> 26:26:00.045
首先，我们会找到数据库中第一个活动的项目它有相同的市场地址T地址和刚刚被取消的令牌ID。

19267
26:26:00.045 --> 26:26:01.984
我们要找到第一个被取消的项。

19268
26:26:01.984 --> 26:26:10.021
我们会再做一点logger information，我们会说logger。info, marketplace, pipe, cancelled item。

19269
26:26:10.021 --> 26:26:12.672
然后我们做一些字符串插值。

19270
26:26:12.672 --> 26:26:14.838
我们会打印出取消的项目。

19271
26:26:14.950 --> 26:26:19.330
取消项目，我们会说if Cancelled item。

19272
26:26:20.950 --> 26:26:23.404
没有找到任何东西，它将返回undefined。

19273
26:26:23.950 --> 26:26:27.653
说if cancelled item如果找到了东西，它会返回true。

19274
26:26:27.653 --> 26:26:32.380
如果取消了项目，那么我们会说logger。info。

19275
26:26:32.380 --> 26:26:38.885
删除，然后我们会request。object。get令牌ID

19276
26:26:38.885 --> 26:26:45.390
at address, request。object。get

19277
26:26:45.390 --> 26:26:53.196
address地址空间，因为它被取消了，这里我们会打印一些日志记录。

19278
26:26:53.196 --> 26:26:57.509
从它被取消的时候开始取它的前导然后我们运行一个wait

19279
26:26:57.509 --> 26:27:03.899
cancelled item。destroy这就是我们从活动项中移除它的时候。

19280
26:27:03.951 --> 26:27:06.751
然后我们就说else。

19281
26:27:09.951 --> 26:27:16.793
with address, request。object。

19282
26:27:16.793 --> 26:27:23.165
get address, and token, Id。

19283
26:27:23.165 --> 26:27:23.879
太酷了。

19284
26:27:23.879 --> 26:27:31.704
现在我们在保存之后有了这个，看起来我的终端自动在这里添加了这个require，这是我们不想要的。

19285
26:27:31.704 --> 26:27:33.644
我要把它删掉。

19286
26:27:33.644 --> 26:27:39.882
我们可以上传这到我们的莫拉莱斯服务器运行纱线，莫拉莱斯云和伟大的变化上传正确。

19287
26:27:39.882 --> 26:27:47.826
现在，为了测试这个测试是否有效，让我们在硬帽非ft市场中创建一个名为cancel item的新脚本。

19288
26:27:47.826 --> 26:27:54.628
我们现在进入脚本我们已经提到了list，我们写入new file，我们将它命名为cancel。Jas。

19289
26:27:54.628 --> 26:27:57.144
我们会取消的，Jas。

19290
26:27:57.144 --> 26:27:59.660
这将是一个脚本。

19291
26:27:59.951 --> 26:28:05.522
我们要用这个主要的东西，但我们要调用我们的函数cancel。

19292
26:28:05.522 --> 26:28:10.187
我们会写async function cancel，然后在

19293
26:28:10.187 --> 26:28:15.014
顶部，我们会写const令牌ID =现在我们回到活动项列表。

19294
26:28:15.014 --> 26:28:18.214
让我们在这里找到一个令牌ID。

19295
26:28:18.214 --> 26:28:19.525
令牌ID为0。

19296
26:28:19.525 --> 26:28:24.035
我们用这个作为我们要删除的令牌ID。

19297
26:28:24.035 --> 26:28:26.285
我们使用令牌ID 0。

19298
26:28:26.285 --> 26:28:27.904
在取消项中。

19299
26:28:27.904 --> 26:28:32.309
js脚本，我们写入const令牌ID = 0，然后取消它。

19300
26:28:32.309 --> 26:28:33.951
所以我们说const NFT。

19301
26:28:33.951 --> 26:28:38.002
市场等于等待醚点得到合同。

19302
26:28:38.002 --> 26:28:42.047
是的，const醚=需要硬帽。

19303
26:28:42.047 --> 26:28:46.986
ft市场会说const basic NF

19304
26:28:46.986 --> 26:28:52.420
t = await醚。get get契约。

19305
26:28:52.420 --> 26:28:59.325
基本NF团队做const TX等于等待NF

19306
26:28:59.325 --> 26:29:06.888
T市场点取消列出基本NF T点地址令牌ID。

19307
26:29:06.888 --> 26:29:14.698
我们调用cancelitemshoulbecancellisting我们调用cancel listing。

19308
26:29:14.698 --> 26:29:17.710
所以取消了上市是的，就像这样。

19309
26:29:17.710 --> 26:29:21.693
它接受NFT的地址和令牌ID。

19310
26:29:21.693 --> 26:29:25.141
基本的NF T点地址和标记D，很好。

19311
26:29:25.141 --> 26:29:27.952
然后我们用权重TX点权重1。

19312
26:29:27.952 --> 26:29:32.752
然后我们写console。log nftcancelled。

19313
26:29:32.952 --> 26:29:41.475
然后我们写入if network。config。chain ID = = 31337。

19314
26:29:41.475 --> 26:29:49.916
我们会继续，我们会做一个等待，移动block到2，然后我们会说sleep。

19315
26:29:49.916 --> 26:29:51.179
Mount = 1000。

19316
26:29:51.179 --> 26:29:54.738
然后我们就说const。

19317
26:29:54.738 --> 26:29:59.403
移动块= require。dot / utils /移动块。

19318
26:29:59.403 --> 26:29:59.953
好的,很酷。

19319
26:29:59.953 --> 26:30:01.215
看起来真不错。

19320
26:30:01.215 --> 26:30:06.247
让我们继续运行这个yarn hardhat运行脚本取消项。

19321
26:30:06.247 --> 26:30:13.280
Js破折号网络，本地主机和ft取消移动块睡眠。

19322
26:30:13.280 --> 26:30:14.152
好了,好了。

19323
26:30:14.152 --> 26:30:15.470
我们的节点正在运行。

19324
26:30:15.470 --> 26:30:15.883
太棒了。

19325
26:30:15.883 --> 26:30:21.091
我们连接到我们的mirallas我们上传了我们的云功能与纱线莫拉莱斯云。

19326
26:30:21.091 --> 26:30:26.425
回到数据库，稍微刷新一下。

19327
26:30:26.425 --> 26:30:29.133
看来我有麻烦了。

19328
26:30:29.133 --> 26:30:34.021
我打开我的信息，它说保存失败后取消用户等等。

19329
26:30:34.021 --> 26:30:35.651
这是登录信息。

19330
26:30:35.651 --> 26:30:38.825
莫拉莱斯点云容易得到侧侧不是一个函数。

19331
26:30:38.953 --> 26:30:39.553
嗯嗯。

19332
26:30:39.553 --> 26:30:42.753
那就说得通了。

19333
26:30:42.753 --> 26:30:43.753
得到水。

19334
26:30:44.953 --> 26:30:46.715
让我们让这个得到记录器。

19335
26:30:48.953 --> 26:30:49.674
上传。

19336
26:30:49.674 --> 26:30:51.444
正确上传更改。

19337
26:30:52.953 --> 26:30:58.103
必须手动到活动项目，我要手动删除这个，会有一个删除这一行。

19338
26:30:58.103 --> 26:30:59.410
是的，删除，刷新。

19339
26:30:59.410 --> 26:31:03.133
我必须这么做的原因是它已经被保存了。

19340
26:31:03.133 --> 26:31:05.100
我们在做一个after保存。

19341
26:31:05.100 --> 26:31:06.485
因为我搞砸了。

19342
26:31:06.485 --> 26:31:08.855
如果你拼对了，你很有可能拼对了。

19343
26:31:08.953 --> 26:31:10.921
但因为我搞砸了，我们得重新建一个。

19344
26:31:10.953 --> 26:31:12.789
然后删除那个新的。

19345
26:31:14.953 --> 26:31:17.268
运行脚本，薄荷和列表网络localhost。

19346
26:31:17.953 --> 26:31:19.090
本来是要加一个新的。

19347
26:31:20.953 --> 26:31:22.114
我们会进行刷新。

19348
26:31:24.953 --> 26:31:25.171
上市。

19349
26:31:25.171 --> 26:31:26.080
它的令牌ID为1。

19350
26:31:26.953 --> 26:31:27.920
现在取消。

19351
26:31:30.953 --> 26:31:31.698
一到一。

19352
26:31:34.953 --> 26:31:40.085
脚本取消项目，网络，本地主机运行此NFT取消移动块。

19353
26:31:40.085 --> 26:31:42.574
现在我们到前端，我们进行刷新。

19354
26:31:42.574 --> 26:31:46.773
我们可以看到它被编程地从活动项中移除，这很好。

19355
26:31:46.773 --> 26:31:49.212
这就是这些日志真正有用的地方。

19356
26:31:49.212 --> 26:31:54.969
现在，故意犯错可能有点可怕，但学习如何使用日志等信息和学习如何有

19357
26:31:54.969 --> 26:32:00.906
效调试将使你成为一个更快的程序员，因为你猜怎么着，你不会是完美的。

19358
26:32:00.906 --> 26:32:07.215
你将会遇到一些问题，了解如何使用日志，了解如何读取错误将使你成为更快的开发人员。

19359
26:32:07.215 --> 26:32:12.904
现在我们有了取消项目的东西，我们还需要什么东西?你买东西的时候就猜对了。

19360
26:32:12.954 --> 26:32:16.588
我们在保存后再画一幅壁画。

19361
26:32:16.588 --> 26:32:25.237
我们会使用与item cancelled完全相同的item bought代码，我们可能应该把它们都变成一个函数。

19362
26:32:25.237 --> 26:32:30.068
但是为了练习，我们要再做一遍，我们用莫拉莱斯点云。

19363
26:32:30.068 --> 26:32:34.183
然后我的VS代码因为某种原因一直插入这个。

19364
26:32:34.183 --> 26:32:38.863
我要在保存后撤销Morales。Cloud。

19365
26:32:38.863 --> 26:32:40.863
项目机器人是事件。

19366
26:32:40.863 --> 26:32:47.990
这里会有一个async request小箭头函数，const confirmed

19367
26:32:47.990 --> 26:32:57.079
equals requestobjectdot get confirmed将获取这个事务是否被确认。

19368
26:32:57.079 --> 26:33:00.854
我们会得到记录器，我只需要复制粘贴，所以这次我做对了。

19369
26:33:00.854 --> 26:33:09.235
我要复制粘贴这两行const logger = Morales。Cloud。get logger logger。info。

19370
26:33:09.235 --> 26:33:17.671
我们写入If confirmed const active item = Morales。object。

19371
26:33:17.671 --> 26:33:26.919
extend active item const query对于这个查询，我实际上要复制这些行因为这是完全相同的。

19372
26:33:26.955 --> 26:33:31.180
我们将寻找非ft地址、令牌ID和市场地址。

19373
26:33:31.180 --> 26:33:37.429
如果我们在我们的非ft。soul和到marketplace。som right和bot event中寻找非ft地址。

19374
26:33:37.429 --> 26:33:42.080
我们想要找到的令牌ID被列出来了。

19375
26:33:42.080 --> 26:33:43.580
我们会运行那个查询。

19376
26:33:43.580 --> 26:33:52.523
我们将const bots item = await query。first，我们将和之前做的一样。

19377
26:33:52.523 --> 26:34:01.345
如果bots项目，那么logger。info，

19378
26:34:01.345 --> 26:34:09.400
删除请求点对象点获取对象ID等待购买项目点

19379
26:34:09.400 --> 26:34:17.455
毁logger。info删除项目与开放ID

19380
26:34:17.455 --> 26:34:27.429
求点对象点获取开放ID地址请求点对象点获取地址。

19381
26:34:27.429 --> 26:34:30.344
如果我们没有找到，它会说else。

19382
26:34:30.344 --> 26:34:38.743
Logger点信息，没有找到地址请求对象点获取地址

19383
26:34:38.743 --> 26:34:47.479
和token, Id请求对象点获取token Id。

19384
26:34:47.479 --> 26:34:47.806
酷。

19385
26:34:47.806 --> 26:34:49.051
看起来不错。

19386
26:34:49.051 --> 26:34:52.684
让我们把它上传到云端。

19387
26:34:52.684 --> 26:34:57.398
所以纱口云的变化上传正确。

19388
26:34:57.398 --> 26:34:59.709
让我们确保它在我们的服务器上看起来不错。

19389
26:34:59.709 --> 26:35:03.027
所以我们要给士气服务器一点刷新。

19390
26:35:03.027 --> 26:35:04.905
去这里的云功能。

19391
26:35:04.905 --> 26:35:07.820
我还能看到这个项目被取消了。

19392
26:35:07.956 --> 26:35:11.481
现在我可以看到保存完美后购买的项目。

19393
26:35:11.956 --> 26:35:13.432
就像我有百分之百的能力。

19394
26:35:14.956 --> 26:35:20.489
为了冷静思考，让它稍微刷新一下，看起来我们在上传了云功能后回到了原来的状态。

19395
26:35:20.489 --> 26:35:21.222
好的,很酷。

19396
26:35:21.222 --> 26:35:23.755
来测试这部分是否正常工作。

19397
26:35:23.956 --> 26:35:26.294
让我们继续，我们再写一个脚本。

19398
26:35:26.956 --> 26:35:28.165
乘以项·j s。

19399
26:35:28.165 --> 26:35:31.229
我们现在做同样的事情。

19400
26:35:31.956 --> 26:35:32.498
数据库。

19401
26:35:32.498 --> 26:35:34.599
我们没有任何有效的物品。

19402
26:35:35.956 --> 26:35:36.789
真正的快。

19403
26:35:36.789 --> 26:35:38.705
我们在薄荷和名单上。

19404
26:35:38.705 --> 26:35:39.955
造一个新的。

19405
26:35:40.956 --> 26:35:43.313
检查我们的数据库，我们会做一点刷新。

19406
26:35:43.956 --> 26:35:47.130
其中含有活性维生素，ID为2

19407
26:35:47.956 --> 26:35:56.107
是我们会买令牌ID会说const醚网络=需要罗汉co

19408
26:35:56.107 --> 26:36:04.258
nst移动块=需要点削减跑龙套削减移动块const标

19409
26:36:04.258 --> 26:36:12.409
记ID =异步函数逐项const非功能性测试市场=等

19410
26:36:12.409 --> 26:36:20.560
待醚点得到合同NF T市场const基本NF T =

19411
26:36:20.560 --> 26:36:28.711
等待醚点得到合同清单基本非功能性测试coms等于等待

19412
26:36:28.711 --> 26:36:36.862
和英国《金融时报》的市场点得到清单基本NF T点地址

19413
26:36:36.862 --> 26:36:45.013
和令牌ID会说const价格等于清单,价格字符串，我

19414
26:36:45.013 --> 26:36:47.521
们会说const

19415
26:36:47.521 --> 26:37:01.001
Tx这实际上是我们要买它等于await和ft marketplace。buy item

19416
26:37:01.001 --> 26:37:10.094
ketplace。buy item basic n ft。address，令牌ID，逗号。

19417
26:37:10.094 --> 26:37:13.448
然后价值当然是价格。

19418
26:37:13.448 --> 26:37:19.290
做等待TX点等待一个，控制台点日志机器人NF t。

19419
26:37:19.290 --> 26:37:27.148
然后如果network。config。chain ID = 31337，那么await

19420
26:37:27.148 --> 26:37:35.006
move blocks to comma, sleep amount = 1000。

19421
26:37:35.006 --> 26:37:40.317
当然，这是一个脚本，我们将使用与cancel相同的东西。

19422
26:37:40.317 --> 26:37:44.086
但它不会被取消，而是被item调用。

19423
26:37:44.086 --> 26:37:52.284
我们这里有一个非活动项目，我们运行yarn, art，按项目运行脚本。

19424
26:37:52.284 --> 26:37:55.693
. js Dash network, localhost。

19425
26:37:55.957 --> 26:37:58.090
现在我们可以测试是否购买该道具。

19426
26:37:59.957 --> 26:38:05.579
block，我们会在数据库上做一点刷新，我们会看到活动项消失了。

19427
26:38:05.579 --> 26:38:08.803
我们可以看到，这个物品现在已经被购买了。

19428
26:38:08.803 --> 26:38:09.418
太棒了。

19429
26:38:09.418 --> 26:38:14.612
我们几乎完成了活动项的保存，这是一个活动项的表。

19430
26:38:14.612 --> 26:38:16.034
但我们还有一件事要做。

19431
26:38:16.034 --> 26:38:17.161
我们不打算在这里测试。

19432
26:38:17.161 --> 26:38:22.613
但是如果你想测试它，我们可以在我们的非ft市场，去市场。

19433
26:38:22.613 --> 26:38:28.845
Sol，我们实际上也有一个更新列表功能，它也允许一个项目被列出。

19434
26:38:28.845 --> 26:38:35.216
因此，我们还想检查所列出的项目是否来自更新监听。

19435
26:38:35.216 --> 26:38:39.676
回到我们的项目列表Cloud Function，在

19436
26:38:39.676 --> 26:38:44.315
我们真正开始保存东西之前，我们想检查它是否已经存在。

19437
26:38:44.315 --> 26:38:51.450
我们会说我们会说const query = new mirallas。query。

19438
26:38:51.450 --> 26:38:55.398
抱歉，我一直在写活动项的sin。

19439
26:38:55.398 --> 26:38:58.361
我们要做我们一直在做的事。

19440
26:38:58.361 --> 26:39:00.351
我们会说query。= NFT。

19441
26:39:00.351 --> 26:39:08.305
地址，我们会寻找非ft地址request。object。get和ft地址，

19442
26:39:08.305 --> 26:39:17.549
query。等于令牌ID, request那个对象。get令牌ID, query。等于

19443
26:39:17.549 --> 26:39:27.008
。等于市场，地址，逗号request。object。get Address query。

19444
26:39:27.008 --> 26:39:33.027
等于seller requests。object。get

19445
26:39:33.027 --> 26:39:44.208
seller会说const already listing item等于await query。first。

19446
26:39:44.208 --> 26:39:48.922
然后我们会说这个项目是否已经被列出了。

19447
26:39:48.922 --> 26:39:52.781
然后我们继续，写入logger。info。

19448
26:39:52.958 --> 26:40:00.827
删除已经列出的请求。对象。get对象ID。

19449
26:40:00.959 --> 26:40:06.441
我们会做一个已经列出的权重item。destroy。

19450
26:40:06.959 --> 26:40:13.183
然后执行logger。info, deleted item with

19451
26:40:13.183 --> 26:40:20.322
token ID request。object。get token ID at

19452
26:40:20.322 --> 26:40:28.010
address request。object。get address因为它已经被列出

19453
26:40:28.010 --> 26:40:35.518
被列出了，如果对象已经被列出了，我们知道它来自这个update listing函数。

19454
26:40:35.518 --> 26:40:40.039
我们先删除它，然后用新的价格重新保存它。

19455
26:40:40.039 --> 26:40:46.865
让我们继续，把这个上传到云纱线莫拉莱斯云。

19456
26:40:46.959 --> 26:40:50.883
上传这个到我们的服务器更改上传正确。

19457
26:40:50.959 --> 26:40:54.303
我们去检查一下服务器，稍微刷新一下。

19458
26:40:54.959 --> 26:40:56.991
检查云功能。

19459
26:41:00.959 --> 26:41:02.620
用于删除的现在在这里。

19460
26:41:04.959 --> 26:41:09.999
要使这个活动项目表始终只包含在市场上活动的项

19461
26:41:09.999 --> 26:41:15.039
目，而不需要在应用程序中花费任何额外的资源。

19462
26:41:15.039 --> 26:41:19.443
这将对用户体验有更好的改善因为他们不需要支付额

19463
26:41:19.443 --> 26:41:24.039
外的汽油来保存所有这些实体和数组或其他数据结构。

19464
26:41:24.039 --> 26:41:25.520
如果你已经走到这一步。

19465
26:41:25.520 --> 26:41:31.906
这很容易成为这门课最难的部分之一，因为我们要处理大量的技术。

19466
26:41:31.959 --> 26:41:37.451
我们正在使用智能合约，我们正在使用云功能，我们正在使用后端数据库。

19467
26:41:37.451 --> 26:41:41.391
如果你能走到这一步，你应该感到非常非常自豪。

19468
26:41:41.391 --> 26:41:46.594
现在让我们继续，让我们创造并列出另一个非ft。

19469
26:41:46.594 --> 26:41:54.353
我们会运行yarn heart在运行脚本，mint和列表网络本地主机将意味着它会列出它或睡觉。

19470
26:41:54.353 --> 26:41:55.730
我们去查一下数据库。

19471
26:41:55.730 --> 26:41:56.664
我们会进行刷新。

19472
26:41:56.664 --> 26:41:59.069
我们在这里看到了活动项目。

19473
26:41:59.069 --> 26:42:06.881
现在我们来学习如何调用活动项目数据库中的所有对象。

19474
26:42:06.960 --> 26:42:11.687
记住，如果你要重置你的本地区块链，

19475
26:42:11.687 --> 26:42:16.693
你需要到这里来删除支持表中的所有行。

19476
26:42:16.960 --> 26:42:24.427
说了这么多，是时候回到我们的前端了，回到我们的index。J。

19477
26:42:24.427 --> 26:42:26.637
然后回答这个问题。

19478
26:42:26.637 --> 26:42:33.369
我们如何显示最近上市的NF t，我们只想显示市场上活跃的NF t。

19479
26:42:33.369 --> 26:42:37.950
现在我们有了一个系统只获取活跃的药物，只获取目

19480
26:42:37.950 --> 26:42:42.531
前市场上的药物，因为我们要为这些事件建立索引。

19481
26:42:42.531 --> 26:42:44.864
现在，我要删除这里所有的注释。

19482
26:42:44.960 --> 26:42:45.744
我们来做这个。

19483
26:42:47.960 --> 26:42:49.681
这个叫做使用莫拉莱斯查询。

19484
26:42:50.960 --> 26:42:55.543
莫拉莱斯码头，有一个钩子叫使用莫拉莱斯查询。

19485
26:42:55.960 --> 26:43:00.826
这允许我们在React上下文中获取并查询数据库。

19486
26:43:00.826 --> 26:43:07.626
回到这里，我们会说，导入，使用Morales query从react mirallas。

19487
26:43:07.626 --> 26:43:14.878
现在，如果你看这里的文档，使用鼠标查询返回数据错误加载。

19488
26:43:14.960 --> 26:43:19.427
这将在索引弹出时自动运行这个查询。

19489
26:43:19.427 --> 26:43:23.327
为了从查询中获取数据从数据库中获取所有活动项，

19490
26:43:23.327 --> 26:43:29.262
我们会说const data，并将data重命名为lists和fts。

19491
26:43:29.262 --> 26:43:33.993
然后我们还会检查这个查询是否还在取回。

19492
26:43:33.993 --> 26:43:38.997
因此我们写入isfetch然后我们将它重命名为feting

19493
26:43:38.997 --> 26:43:44.175
listnftis = use Morales query。

19494
26:43:44.175 --> 26:43:48.670
在这里，它接受两个输入参数，它接受要进

19495
26:43:48.670 --> 26:43:53.403
行搜索的表名然后它还接受一个函数或查询。

19496
26:43:53.403 --> 26:43:57.912
我们要找的表名是active item。

19497
26:43:57.961 --> 26:44:05.428
然后查询的函数是我们说query。我们把它限制为10。

19498
26:44:05.428 --> 26:44:13.468
我们只说前10个，我们按点降序来做，基于令牌ID。

19499
26:44:13.468 --> 26:44:21.896
如果我们想处理不同的页码，我们可以用。skip来处理页码，这里我们不打算处理页码。

19500
26:44:21.896 --> 26:44:23.568
所以我们现在就把它放在这里。

19501
26:44:23.568 --> 26:44:24.068
就是这样。

19502
26:44:24.068 --> 26:44:32.961
我们说，很好，从数据库中抓取活动项表，只抓取令牌ID降序排列的前10个。

19503
26:44:32.961 --> 26:44:38.544
现在它会把结果保存到nfts部分。

19504
26:44:38.544 --> 26:44:40.884
现在看看这是否有效。

19505
26:44:40.884 --> 26:44:48.697
让我们来做一些console。log列出ntf看看这个使用Ross查询的结果是什么。

19506
26:44:48.697 --> 26:44:56.199
现在我们有了本地区块链节点运行，我们有了到Morales服务器的连接，我们有了前端运行。

19507
26:44:56.199 --> 26:45:02.495
让我们到前端，我们在这里做一点刷新，我们右键点击，点击检查，我们会到控制台。

19508
26:45:02.495 --> 26:45:05.843
我们看到这个数组被输出到这里。

19509
26:45:05.843 --> 26:45:09.378
第一次console。logs时，它是空的。

19510
26:45:09.378 --> 26:45:14.716
这是因为当它最初从T中列出的加载还没有返回时。

19511
26:45:14.716 --> 26:45:16.914
它实际上是一个空数组。

19512
26:45:16.914 --> 26:45:24.212
但当它完成加载时，我们会得到一个大小为1的数组，我们会得到一个大小为1的数组，因为活动项目现在只有一个回车。

19513
26:45:24.212 --> 26:45:30.170
我们得到这个大小为1的数组，我们看到它的索引为0，我们有类名active

19514
26:45:30.170 --> 26:45:36.295
item，我们有项目ID，我们有所有这些属性，这些都将在市场地址处创建。

19515
26:45:36.295 --> 26:45:43.598
如果地址，价格，卖家和令牌ID这就是我们在数据库中看到的。

19516
26:45:43.598 --> 26:45:44.290
如此完美。

19517
26:45:44.290 --> 26:45:48.273
这正是我们想要的能够在前端显示这些NF t。

19518
26:45:48.273 --> 26:45:51.673
那么我们如何显示这个非函数和列出这个非函数T呢?

19519
26:45:51.673 --> 26:45:56.587
对于那些不是开发人员也不打算去查看控制台。日志的人?我们

19520
26:45:56.587 --> 26:46:01.502
要做的是在这里的return中，我们在它周围加一些括号。

19521
26:46:01.502 --> 26:46:05.131
首先，我们应该检查我们是否正在获取那些列出的NF T。

19522
26:46:05.131 --> 26:46:07.223
我们会做一些JavaScript的东西。

19523
26:46:07.223 --> 26:46:11.703
我们会说抓取列出的NF T我们会做一个三元运算符。

19524
26:46:11.703 --> 26:46:15.224
我们会说，如果我们要获取这些NF T，

19525
26:46:15.224 --> 26:46:21.342
我们添加一个小div div表示加载完成，我们在这里放一个小冒号。

19526
26:46:21.342 --> 26:46:26.748
如果我们不取回，我们会说，listnfts。map。

19527
26:46:26.748 --> 26:46:31.897
点映射基本上是遍历并在所有列出的实

19528
26:46:31.897 --> 26:46:37.349
体上做一些函数在我们想要做的函数中。

19529
26:46:37.349 --> 26:46:40.629
它会把每个NF t作为输入参数。

19530
26:46:40.629 --> 26:46:43.979
所以我们说我们基本上要循环通过每个NF T。

19531
26:46:43.979 --> 26:46:50.869
我们会说，console。log和ft。attribute attribute，加上S。

19532
26:46:50.963 --> 26:46:55.963
然后在这些里面在这些属性里面是我们想要的不同部分。

19533
26:46:55.963 --> 26:47:01.173
我们要得到这些块我们用const表示价格。

19534
26:47:01.173 --> 26:47:08.043
NFT地址，市场地址中的令牌ID，当然就是这个，然后卖家，这就是

19535
26:47:08.043 --> 26:47:15.129
我们要在前端显示的所有信息它会说等于ntf。attributes。

19536
26:47:15.129 --> 26:47:20.108
我们会把这些拉出来，我们会看到price seller token ID，等等。

19537
26:47:20.108 --> 26:47:22.672
我们将把这些从ntf导属性中取出来。

19538
26:47:22.672 --> 26:47:26.897
我们可以用这个函数来表示，我们写上return。

19539
26:47:26.963 --> 26:47:30.338
然后返回一些HTML，比如div div。

19540
26:47:30.963 --> 26:47:38.547
我们可以说像价格，价格，价格，期间，和ft地址和ft地址，

19541
26:47:38.547 --> 26:47:47.439
token ID, token ID卖家，然后出于某种原因添加这个。

19542
26:47:47.439 --> 26:47:53.748
出于某种原因，我要把前面加$1的符号删掉，保存。

19543
26:47:53.748 --> 26:48:01.878
现在如果我去到前端，我现在可以看到我们的非功能性金融的信息从我们的数据库列在这里。

19544
26:48:01.963 --> 26:48:02.749
这太棒了。

19545
26:48:04.963 --> 26:48:06.963
我们看到的是卖家的令牌ID。

19546
26:48:08.963 --> 26:48:13.454
市场，我们的小，我们的小硬帽MC市场，让我们再造一个。

19547
26:48:13.454 --> 26:48:20.816
纱线硬帽运行脚本mentalist Dash网络localhost，我们将运行它将铸造更多。

19548
26:48:20.816 --> 26:48:28.725
回到Morales数据库，对活动项目表做一点刷新，这里有了一个新项目。

19549
26:48:28.725 --> 26:48:32.839
如果我们回到我们的前端，我们给它一点刷新。

19550
26:48:32.839 --> 26:48:35.339
嘭，现在我们有了两项。

19551
26:48:35.339 --> 26:48:40.080
这太棒了，我们现在有了一种方法来显示

19552
26:48:40.080 --> 26:48:44.821
我们市场上最近列出的NF t，加上。

19553
26:48:44.964 --> 26:48:49.259
当然，你可能会对自己说，嘿，帕特里克，这很酷。

19554
26:48:49.259 --> 26:48:51.472
但那看起来真的很丑。

19555
26:48:51.472 --> 26:48:53.258
我同意你的观点。

19556
26:48:53.258 --> 26:48:55.081
但是百分之百同意你的说法。

19557
26:48:55.081 --> 26:49:00.406
因此，我们应该想出一个组件来显示我们列出的实体，它看起来要好得多。

19558
26:49:00.406 --> 26:49:09.285
当我们不返回并打印出原始信息时，我们可能想要显示图像，我们想要显示图像，我们想让一切看起来更好。

19559
26:49:09.285 --> 26:49:14.830
所以我们要创建一个新组件我们要在这里返回它来适当地格式化我们所有的NF T。

19560
26:49:14.830 --> 26:49:20.794
我们将进入组件，我们将写入新文件，我们将调用nftbox。js。

19561
26:49:20.794 --> 26:49:26.229
这是我们要获取所有信息的地方关于如何显示我们的非功能性函数是什么样子的。

19562
26:49:26.229 --> 26:49:29.284
让我们开始处理实体框，我们会设置这个，

19563
26:49:29.284 --> 26:49:35.877
我们设置这些的方法是export default function和ft box。

19564
26:49:35.964 --> 26:49:42.705
这里有一点不同，在我们的索引中，我们有所有这些信息。

19565
26:49:42.705 --> 26:49:48.385
我们需要把所有这些变量传递给我们的非ft Box组件。

19566
26:49:48.385 --> 26:49:52.071
为此，我们将把它们作为输入参数添加到组件中。

19567
26:49:52.071 --> 26:49:58.754
我们会说价格，如果地址，令牌ID，市场，地址和卖家。

19568
26:49:58.754 --> 26:50:04.610
现在在我们的前端，我们只有一大堆的文本，我们甚至有这个粗鄙的警告，我们要去掉这个提示。

19569
26:50:04.610 --> 26:50:13.261
我们知道，令牌有它们的令牌URI，它指向一个图像URI或实际令牌的图像URL。

19570
26:50:13.261 --> 26:50:20.698
我们要做的是调用那个令牌URI，然后调用图像URI来显示图像。

19571
26:50:20.698 --> 26:50:26.276
我们需要等这两个API请求才能得到实际图像。

19572
26:50:26.276 --> 26:50:31.352
我们将把这个图像保存为这个分量的状态函数。

19573
26:50:31.352 --> 26:50:35.981
如你所知，我们将使用use state来跟踪图像URI。

19574
26:50:35.981 --> 26:50:41.739
我们会像这样使用state from react。

19575
26:50:41.965 --> 26:50:50.320
在这里，我们说const image Uri，逗号set image Uri = use state。

19576
26:50:50.320 --> 26:50:53.794
我们会从一个空字符串开始。

19577
26:50:53.965 --> 26:51:01.706
现在我们来创建一个函数，我们将其命名为update UI来更新UI并获取这个令牌URI和图像URI。

19578
26:51:01.706 --> 26:51:05.817
我们会创建一个叫Update UI的异步函数。

19579
26:51:05.817 --> 26:51:11.675
为了先获取图像，我们需要获取令牌URI，然后

19580
26:51:11.675 --> 26:51:17.534
使用令牌URI中的image ag获取图像。

19581
26:51:17.534 --> 26:51:20.626
首先我们要做的是获取令牌URI。

19582
26:51:20.626 --> 26:51:24.098
我们知道如何使用web3contract。

19583
26:51:24.098 --> 26:51:29.048
所以我们会做导入，使用web三合同从react Morales。

19584
26:51:29.048 --> 26:51:33.076
正如我们所知，通过合同使用网络需要一些参数。

19585
26:51:33.076 --> 26:51:37.484
我们说const run contract function,

19586
26:51:37.484 --> 26:51:42.605
get令牌URI，等于，使用web through contract。

19587
26:51:42.605 --> 26:51:48.499
首先，我们需要NFT的ABI因为我们需要调用令牌URI。

19588
26:51:48.499 --> 26:51:51.919
为了得到ABI，我们需要再次更新我们的前端。

19589
26:51:51.966 --> 26:51:53.441
我们把这部分注释掉。

19590
26:51:54.966 --> 26:51:55.316
一块。

19591
26:51:55.316 --> 26:51:57.912
让我们看看部署脚本。

19592
26:51:58.966 --> 26:52:01.062
现在就更新前端。

19593
26:52:03.966 --> 26:52:04.490
对象的地址。

19594
26:52:04.490 --> 26:52:05.080
那很好。

19595
26:52:05.966 --> 26:52:08.353
在我们的前端添加API。

19596
26:52:09.966 --> 26:52:11.585
函数叫做Update API。

19597
26:52:12.966 --> 26:52:13.288
好。

19598
26:52:13.288 --> 26:52:16.352
我们会用async函数更新API。

19599
26:52:17.966 --> 26:52:24.621
基本的非ft API和非ft市场API，因为我们都需要它们。

19600
26:52:24.621 --> 26:52:31.860
我们写入const NF T, market = await ethers dot get contract。

19601
26:52:31.860 --> 26:52:39.299
在市场中，我们将写入ABI到前端API位置，我们有前端合同文件。

19602
26:52:39.299 --> 26:52:41.716
我们也来做一个const。

19603
26:52:41.716 --> 26:52:46.523
Front和ABI location等于。。/

19604
26:52:46.523 --> 26:52:53.421
next是Jas，如果T marketplace dash FCC

19605
26:52:53.421 --> 26:53:00.320
FCC /常量，我们不只是给出文件名，我们可以直接给出前端API位置。

19606
26:53:00.320 --> 26:53:06.778
然后我们会让它为我们生成那个文件因为我们会在任何时候覆盖ABI文件。

19607
26:53:06.778 --> 26:53:13.747
现在我们有了marketplace，我们只需要Fs。right file sync，

19608
26:53:13.747 --> 26:53:20.717
还有front和ABI location, ft marketplace。JSON。

19609
26:53:20.717 --> 26:53:25.758
还有ft marketplace，。interface,

19610
26:53:25.758 --> 26:53:32.780
format ethers。utils。format types。JSON。

19611
26:53:32.780 --> 26:53:35.515
对于基本的NF t我们也要这样做。

19612
26:53:35.515 --> 26:53:41.751
因此我们写入const basic NF t = await ethers。

19613
26:53:41.751 --> 26:53:48.809
get contract basic NF t Fs。对吧?文件同步，也就是这个地方。

19614
26:53:48.809 --> 26:53:54.655
除了它将是一个不同的位置，它将是基本的NFT。JSON。

19615
26:53:54.655 --> 26:54:01.803
当然，我们会做一个逗号，基本的NFT，接口。format ethers。

19616
26:54:01.803 --> 26:54:09.747
utils，点格式，类型。JSON，你可以在Hardhead文档中找到这个接口。

19617
26:54:09.747 --> 26:54:12.819
你可以在乙醚文档中找到这个。

19618
26:54:12.819 --> 26:54:15.441
现在我们有了这个更新ABI函数。

19619
26:54:15.441 --> 26:54:23.744
让我们把它添加到导出的模块中，这样我们就可以像这样对ABI进行加权。

19620
26:54:23.967 --> 26:54:25.458
这里有个连字符不应该出现在这里。

19621
26:54:25.967 --> 26:54:31.536
只是我们硬帽前端的这一部分，运行纱线，硬帽，部

19622
26:54:31.536 --> 26:54:37.105
署破折号，破折号标签，这里的标签是前端，前端。

19623
26:54:37.105 --> 26:54:40.173
现在它没有什么需要编译更新前端了，它完成了。

19624
26:54:40.173 --> 26:54:44.828
如果我们回到我们的前端，现在我们去我们的常量，我们现在在这里看

19625
26:54:44.828 --> 26:54:49.483
到两个对象，它们将是API的，基本的非函数函数，和非函数函数。

19626
26:54:49.483 --> 26:54:50.257
市场。

19627
26:54:50.257 --> 26:54:50.773
太棒了。

19628
26:54:50.967 --> 26:54:54.905
现在我们有了这些，我们可以把它们导入到前端。

19629
26:54:54.967 --> 26:55:00.404
我们可以说import, if T marketplace,

19630
26:55:00.404 --> 26:55:06.568
abi from。。/常数/ NF T, market。JSON。

19631
26:55:06.568 --> 26:55:09.689
我们也可以得到NF T API。

19632
26:55:09.689 --> 26:55:17.394
我们会导入nft，从这个斜杠常数斜杠基本NF T。JSON。

19633
26:55:17.394 --> 26:55:23.891
现在在我们的run contract函数中，令牌URI函数是NFT API的一部分。

19634
26:55:23.968 --> 26:55:28.905
API将是NFT, abi，契约地址将

19635
26:55:28.905 --> 26:55:33.843
是NFT的地址，我们将它作为参数传入。

19636
26:55:33.843 --> 26:55:39.375
我们会传递一个NF T地址，函数名是令牌URI,

19637
26:55:39.375 --> 26:55:47.905
params是令牌ID，它会作为输入参数传递给这个函数，传递给这个组件。

19638
26:55:47.905 --> 26:55:48.280
正确的。

19639
26:55:48.280 --> 26:55:49.780
我们可以再检查一下。

19640
26:55:49.968 --> 26:55:55.381
我们对基本的NF T点灵魂很满意，对吧?向下滚动，我们有这个要重写的令牌URI。

19641
26:55:55.381 --> 26:55:59.039
这是我们要调用的函数，接受令牌ID。

19642
26:55:59.039 --> 26:56:02.015
我们要调用的函数接受令牌ID。

19643
26:56:02.015 --> 26:56:02.586
好了,好了。

19644
26:56:02.586 --> 26:56:09.671
在更新UI中，首先，我们说const，令牌URI = await令牌URI。

19645
26:56:09.671 --> 26:56:15.214
现在我们来做一个console。log令牌看看它会返回什么确保updatuui

19646
26:56:15.214 --> 26:56:20.900
被调用，我们会把它添加到一个use effect中，我们说use effect。

19647
26:56:20.968 --> 26:56:26.001
这需要一个函数的输入参数，我们可以说Update UI。

19648
26:56:26.001 --> 26:56:32.240
我们只会让这个在任何时候运行当web 3启用更改时。

19649
26:56:32.240 --> 26:56:37.561
我们想运行updatuui，但我们希望它依赖于已启用的webthree。

19650
26:56:37.561 --> 26:56:42.397
然后我们说，如果它启用了web3，那么更新UI。

19651
26:56:42.397 --> 26:56:44.158
所以我们还需要增加使用效果。

19652
26:56:44.158 --> 26:56:48.104
我们用use state，逗号，use effect。

19653
26:56:48.104 --> 26:56:52.419
现在我们至少应该从区块链读取令牌URI。

19654
26:56:52.419 --> 26:56:57.445
我们还不打算设置图像，因为我们要从令牌神经元获取图像URI。

19655
26:56:57.445 --> 26:57:05.095
让我们把这个NFT框添加到我们的索引中，看看它在我们的索

19656
26:57:05.095 --> 26:57:12.746
引中是否工作得很好。接下来，在顶部，我们将导入ntf框。

19657
26:57:12.746 --> 26:57:20.690
在下面这里，当我们返回时它会添加我们的NF T box组件会确保传入它所接受的所有参数。

19658
26:57:20.690 --> 26:57:24.461
价格等于JavaScript价格。

19659
26:57:24.461 --> 26:57:29.608
ft地址等于JavaScript实体地址。

19660
26:57:29.608 --> 26:57:35.674
令牌ID将等于令牌ID，市场

19661
26:57:35.674 --> 26:57:42.175
地址将是市场地址卖家将是卖家。

19662
26:57:42.175 --> 26:57:49.313
你看到那个警告说，所有组件需要映射中的所有东西都需要有唯一的键。

19663
26:57:49.313 --> 26:57:52.193
我们会说key，我们也会给它们一个key。

19664
26:57:52.193 --> 26:58:00.169
我们会说key = this，我们会做一些字符串插值，我们会说NFT地址，加上令牌ID可以是key。

19665
26:58:00.169 --> 26:58:04.773
保存一下，回到我们的前端，做一点

19666
26:58:04.773 --> 26:58:09.665
刷新，市场地址是未定义的市场地址。

19667
26:58:09.665 --> 26:58:16.346
让我们确保拼写正确，让我们回到前端，我们给它一个刷新3enabled是没有定义的。

19668
26:58:16.346 --> 26:58:21.773
不好意思，在非功能性的盒子里，我们需要从我们的莫拉莱斯那里抓取那个，所以我们将导入使用莫拉莱斯。

19669
26:58:21.773 --> 26:58:30.570
在ponents中我们会说const isweb3enabled = use Morales。

19670
26:58:30.570 --> 26:58:32.170
我们把它保存起来。

19671
26:58:32.170 --> 26:58:36.919
我注意到的一件事是这个需要用弯弯曲曲的东西包起来。

19672
26:58:36.970 --> 26:58:38.208
对不起，我忘记了。

19673
26:58:39.970 --> 26:58:41.418
道具，道具输入参数。

19674
26:58:42.970 --> 26:58:45.123
道具令牌ID来获取令牌ID。

19675
26:58:46.970 --> 26:58:50.901
通过在这里画上弯弯曲曲的括号。

19676
26:58:50.970 --> 26:58:52.103
把弯弯曲曲的括号放在这里。

19677
26:58:52.970 --> 26:58:55.749
控制台点日志标记，你的眼睛，或索引。

19678
26:58:56.970 --> 26:58:57.407
更新。

19679
26:58:57.407 --> 26:58:57.719
这里。

19680
26:58:57.719 --> 26:58:59.156
我们来保存一下。

19681
26:59:00.970 --> 26:59:03.183
web 3启用了UI。

19682
26:59:05.970 --> 26:59:07.451
前端，我们会做一点刷新。

19683
26:59:07.970 --> 26:59:09.747
一切都如预期般顺利。

19684
26:59:10.970 --> 26:59:13.170
在那个硬有localhost和我们的元掩码。

19685
26:59:13.970 --> 26:59:16.919
可以忽略这个错误，这个警告。

19686
26:59:16.970 --> 26:59:25.731
如果你点这个，你有你的IPFS和brave或你的IPFS同伴，我们现在能看到我们得到令牌URI，这很完美。

19687
26:59:25.731 --> 26:59:27.873
我们现在想要的是这个图像出价。

19688
26:59:27.970 --> 26:59:32.812
我用的这个是HTTPS，严格来说它不是去中心化的，

19689
26:59:32.812 --> 26:59:42.303
我们需要它来自而不是HTTPS，我们需要来自IPFS冒号，斜杠，但实际上它是HTTPS IPFS。

19690
26:59:42.303 --> 26:59:42.469
io。

19691
26:59:42.469 --> 26:59:45.330
现在是好的，我们马上会解释为什么。

19692
26:59:45.330 --> 26:59:48.242
现在我们得到了令牌URI，

19693
26:59:48.242 --> 26:59:55.188
我们可以调用这个URL，我们可以取回我们想要在前端显示的图像。

19694
26:59:55.188 --> 27:00:03.669
在这里，我们会做一个console。log，令牌URI是字符串插值，像这样，

19695
27:00:03.669 --> 27:00:11.704
然后我们会说，if令牌URI，我们需要抓取这个令牌URI，从中获取图像。

19696
27:00:11.704 --> 27:00:14.145
这就是我们要做的有点古怪的事情。

19697
27:00:14.145 --> 27:00:15.625
我们要稍微作弊一下。

19698
27:00:15.625 --> 27:00:23.616
对于我们的应用程序，不是每个浏览器都有IPFS，不是每个浏览器都能兼容IPFS。

19699
27:00:23.616 --> 27:00:26.298
这里我们要稍微作弊一下，

19700
27:00:26.298 --> 27:00:33.006
我们要把令牌Uriah从IPFS版本改成H HTTPS版本。

19701
27:00:33.006 --> 27:00:39.355
这被称为使用IPFS网关，它是一个服务器，

19702
27:00:39.355 --> 27:00:45.100
将从一个普通的URL返回IPFS文件。

19703
27:00:45.100 --> 27:00:49.702
我们将使用IPFS网关，我们可以对它进行常规

19704
27:00:49.702 --> 27:00:54.304
的HTTPS调用，它会返回那些IPFS文件。

19705
27:00:54.304 --> 27:00:57.771
所以从技术上讲，我们是让中央集权来做这个吗?是的。

19706
27:00:57.771 --> 27:00:59.237
这是理想的吗?不。

19707
27:00:59.237 --> 27:01:05.528
然而，在世界采用IPFS之前，在世界采用IPFS标准之前，这是我们现在必须要做的。

19708
27:01:05.528 --> 27:01:07.937
否则，前端就会显示为空白。

19709
27:01:07.971 --> 27:01:09.987
我们不能这样，我们不想这样。

19710
27:01:10.971 --> 27:01:18.331
const请求URL等于令牌URI点替换I

19711
27:01:18.331 --> 27:01:25.691
PFS，斜杠斜杠与HTTP, HTTPS。

19712
27:01:25.971 --> 27:01:26.828
/ / ipfs。

19713
27:01:26.828 --> 27:01:27.363
io / ipf /。

19714
27:01:28.971 --> 27:01:31.740
以IPFS开头的令牌URI，这很好。

19715
27:01:32.971 --> 27:01:34.825
切换到使用IPFS网关。

19716
27:01:35.971 --> 27:01:40.889
IPFS网关由构建IPFS的团队提供。

19717
27:01:41.972 --> 27:01:43.972
可靠网关是一种逃避。

19718
27:01:43.972 --> 27:01:44.172
是的。

19719
27:01:44.972 --> 27:01:46.178
还在吗?ipf吗?是的。

19720
27:01:46.178 --> 27:01:48.273
所以这不是世界末日。

19721
27:01:48.972 --> 27:01:52.907
会让我们更容易调用这些API。

19722
27:01:52.972 --> 27:01:57.808
我们会说const令牌URI。

19723
27:01:59.972 --> 27:02:00.206
等待。

19724
27:02:00.206 --> 27:02:02.034
这有点奇怪。

19725
27:02:02.972 --> 27:02:04.222
两个等待。

19726
27:02:04.222 --> 27:02:09.597
等待一个权重获取请求，URL。JSON。

19727
27:02:10.972 --> 27:02:12.167
是一个关键字，

19728
27:02:12.167 --> 27:02:20.876
你可以在JavaScript中使用它来获取URL获取关键字本质上是做同样的事情，像这样粘贴到浏览器中。

19729
27:02:20.876 --> 27:02:22.844
得到这个JSON响应。

19730
27:02:22.972 --> 27:02:24.402
所以我们等待得到答复。

19731
27:02:25.972 --> 27:02:26.987
响应JSON。

19732
27:02:26.987 --> 27:02:29.653
这就是我们得到切换响应的方式。

19733
27:02:29.972 --> 27:02:37.709
JavaScript中有了这个对象，这很完美因为这个对象有我们想要的图像属性。

19734
27:02:37.709 --> 27:02:44.125
和这里一样，我们会用IPFS网关，这个已经用HTTPS了。

19735
27:02:44.125 --> 27:02:44.278
io。

19736
27:02:44.278 --> 27:02:46.489
但如果它不是，我们仍然想要转换它。

19737
27:02:46.489 --> 27:02:48.782
现在我们要说const。

19738
27:02:48.782 --> 27:02:54.722
Image URI = token you are i response dot Image。

19739
27:02:54.722 --> 27:02:59.385
我们会得到这个响应的图像标签。

19740
27:02:59.385 --> 27:03:02.902
然后我们会说const。

19741
27:03:02.902 --> 27:03:09.983
imagururl等于，我们会做和上面一样的事情，我们会使用gateway

19742
27:03:09.983 --> 27:03:18.022
imagururi。replace IPFS，冒号/斜杠/ HTTPS IPFS。

19743
27:03:18.022 --> 27:03:19.072
io / ipf。

19744
27:03:19.072 --> 27:03:23.743
这就是我们得到这个URL的方式。

19745
27:03:23.743 --> 27:03:30.706
最后我们可以把imageururi设置为那个imageurl。

19746
27:03:30.706 --> 27:03:35.515
现在我们有了图像URI就是这个图像。

19747
27:03:35.515 --> 27:03:37.396
这是不是有点不靠谱?是的。

19748
27:03:37.396 --> 27:03:44.344
有没有更好的方法可以做到这一点?是的,实际上有很多更好的方法,我们可以做一些,我们可以,因

19749
27:03:44.344 --> 27:03:51.292
为我们使用的是莫拉莱斯,我们可以使图像在我们的服务器上,就叫我们的服务器,我们还能做什么,

19750
27:03:51.292 --> 27:03:58.240
或测试网和维护路线实际上有一大堆像我们这样的非功能性测试平衡将向我们展示一个F TS告诉我

19751
27:03:58.240 --> 27:04:05.343
们有多少NF T显示所有这信息NF T的但它只适用于测试网和主要网,我们会采用ipf的世界。

19752
27:04:05.343 --> 27:04:07.214
所以我们不需要进行包装。

19753
27:04:07.214 --> 27:04:09.544
不幸的是，它还没有那么像生活。

19754
27:04:09.544 --> 27:04:14.861
现在我们设置了图像，我们有了这个图像URI，我们有了它的实际样子，

19755
27:04:14.861 --> 27:04:20.179
我们会有这个如果我们点这个，我们在浏览器中使用它，它会返回这个狗。

19756
27:04:20.179 --> 27:04:27.446
现在我们网站上有了图像URI，我们终于可以用它来展示它的样子了。

19757
27:04:27.446 --> 27:04:30.403
最后，我们可以在这里创建一个return。

19758
27:04:30.403 --> 27:04:33.295
下面，我们会返回一个div。

19759
27:04:33.295 --> 27:04:36.197
然后我们再做一个div，因为我想做。

19760
27:04:36.197 --> 27:04:41.160
我们可以用JavaScript写如果图像数组存在，我们会做一些事情。

19761
27:04:41.160 --> 27:04:43.472
否则，我们就做点别的。

19762
27:04:43.472 --> 27:04:46.989
如果它不存在，也许我们先做一个div。

19763
27:04:46.989 --> 27:04:49.908
Div上面写着loading。the。

19764
27:04:49.908 --> 27:04:56.661
如果它确实存在，我们会说，输入一个小div，关闭这个div。

19765
27:04:56.661 --> 27:04:58.747
我们就说找到了。

19766
27:04:58.747 --> 27:05:03.849
现在如果我们回到我们的前端，让我们看看我们是否做得好。

19767
27:05:03.974 --> 27:05:04.374
嗯嗯。

19768
27:05:07.974 --> 27:05:08.450
NF T。

19769
27:05:08.450 --> 27:05:09.323
好的,很酷。

19770
27:05:12.974 --> 27:05:15.593
终于有了我们可以用来显示NF T的URL。

19771
27:05:15.974 --> 27:05:17.552
想要真正使用它们。

19772
27:05:18.974 --> 27:05:25.826
组件叫做image组件，我们可以用它来很容易地渲染图像，只需要使用一个URI。

19773
27:05:25.826 --> 27:05:31.629
现在，因为我们要使用这个图像标签，因为它在后端做了一些优化，

19774
27:05:31.629 --> 27:05:37.240
这意味着这个网站不能被部署到静态到静态网站，比如IPFS。

19775
27:05:37.240 --> 27:05:43.236
因为现在我们的网站需要一个服务器技术上来说，需要一个服务器因为我们有莫拉莱斯。

19776
27:05:43.236 --> 27:05:49.837
这可能是另一个原因，因为我们使用的是图像标签，我们不能将它静态部署

19777
27:05:49.837 --> 27:05:56.640
到像IPFS这样的东西我们要在顶部，我们要从下一个斜杠图像导入图像。

19778
27:05:56.640 --> 27:06:04.373
我们会在下面这里我们会说，我们不会用created，而是用Image，我

19779
27:06:04.373 --> 27:06:12.107
们也会在这里关闭它，我们会给一个加载器一个空白函数它只给我们图像URI。

19780
27:06:12.107 --> 27:06:14.006
不要太担心加载器。

19781
27:06:14.006 --> 27:06:17.906
现在，我们会说图像的源将是图像URI。

19782
27:06:17.906 --> 27:06:21.007
然后我们将它的高度设为200。

19783
27:06:21.007 --> 27:06:24.923
然后宽度也设为200。

19784
27:06:24.923 --> 27:06:29.380
如果我们做得对，保存之后，我们应该能在UI上看到图像。

19785
27:06:29.380 --> 27:06:35.198
所以我们回到我们的网站，哦，我的天，我们可以看到狗的天哪。

19786
27:06:35.198 --> 27:06:36.704
这真是令人兴奋。

19787
27:06:36.704 --> 27:06:41.700
我们可以看到小狗，我们可以看到图像，我们肯定在做一些事情，这真的很令人兴奋。

19788
27:06:41.700 --> 27:06:44.338
我知道我之前说过这不是CSS。

19789
27:06:44.338 --> 27:06:49.325
这不是一个格式化教程，因为那绝对不是我的专长。

19790
27:06:49.325 --> 27:06:51.775
不过，让我们把它做得好看一点。

19791
27:06:51.775 --> 27:06:59.506
我们还会用到，web3uitkit，因为web3uitkit有很多非常有用的工具。

19792
27:06:59.506 --> 27:07:04.248
如果我们到web3uikit，我们能到那个实时故事书

19793
27:07:04.248 --> 27:07:08.991
另一个交互位，我们能向下滚动到调用了card的部分。

19794
27:07:08.991 --> 27:07:14.708
或者我们可以制作这些可点击的小卡片我们可以显示一些关于nfts的信息。

19795
27:07:14.708 --> 27:07:22.182
让我们继续，在顶部，我们会从web 3uitkit导入导入卡。

19796
27:07:22.182 --> 27:07:28.590
现在不只是显示图像，我们将像这样将图像包装在卡片中。

19797
27:07:28.590 --> 27:07:29.820
我们把它保存起来。

19798
27:07:29.975 --> 27:07:34.087
现在回到我们的前端，稍微刷新一下。

19799
27:07:34.975 --> 27:07:38.229
有了这种可点击的部分，看起来更好一些。

19800
27:07:38.229 --> 27:07:39.245
我们甚至会给它贴上标签。

19801
27:07:39.245 --> 27:07:42.100
我们甚至可以给它贴上标题和描述。

19802
27:07:42.100 --> 27:07:47.337
现在我们可以从令牌URI响应获取标题和描述。

19803
27:07:47.337 --> 27:07:54.128
在顶部，我们抓取令牌UI的标题和描述作为状态变量。

19804
27:07:54.128 --> 27:08:02.484
我们会说const，令牌名，set令牌名，等于use state，一

19805
27:08:02.484 --> 27:08:10.841
开始为空，const令牌描述，那个令牌描述，等于use state。

19806
27:08:10.975 --> 27:08:17.120
从空白开始下载，我们调用这个updatuitbit，我们调用settoken name。

19807
27:08:17.120 --> 27:08:23.333
我们说name is token，你的response。name，我们说set token

19808
27:08:23.333 --> 27:08:29.547
description，也就是token，你的response。description。

19809
27:08:29.547 --> 27:08:33.642
然后我们将在购物车中使用这些描述和标题。

19810
27:08:33.642 --> 27:08:36.080
我们说title

19811
27:08:36.080 --> 27:08:43.090
=令牌名description =令牌描述。

19812
27:08:43.090 --> 27:08:44.190
保存。

19813
27:08:44.190 --> 27:08:45.957
我们来看看我们的前端。

19814
27:08:45.957 --> 27:08:47.467
给它一点新鲜感。

19815
27:08:47.467 --> 27:08:50.274
对了，现在我们有了NFT的名字。

19816
27:08:50.274 --> 27:08:51.925
和它的描述在我们的前端。

19817
27:08:51.925 --> 27:08:52.297
好的,很酷。

19818
27:08:52.297 --> 27:08:52.873
让我们继续。

19819
27:08:52.976 --> 27:08:56.500
我们还想要什么?我们可能想知道它的主人是谁。

19820
27:08:56.500 --> 27:09:02.925
我们会在card里面放一个div，也许我们会放一个令牌ID我们会写一个小数字。

19821
27:09:02.976 --> 27:09:05.809
使用令牌ID。

19822
27:09:05.976 --> 27:09:08.926
我们再画一个div，然后把它变成斜体。

19823
27:09:08.976 --> 27:09:11.320
我们说类名= italic。

19824
27:09:13.976 --> 27:09:14.652
要小。

19825
27:09:17.976 --> 27:09:20.507
我们作为输入参数传入的卖家。

19826
27:09:20.976 --> 27:09:23.492
也许在图片下面，我们想写上价格。

19827
27:09:23.976 --> 27:09:25.235
这里有一个小div。

19828
27:09:27.976 --> 27:09:32.588
然而，我们可能不希望它以人类可读的单位出现。

19829
27:09:32.588 --> 27:09:37.583
我们会输入ethers，我们会说import ethers from ethers。

19830
27:09:37.583 --> 27:09:39.963
然后我们不只是显示价格，

19831
27:09:39.963 --> 27:09:50.874
而是用一点JavaScript这里我们用ethers。utils。format，单位，价格，价格和ether。

19832
27:09:50.976 --> 27:09:52.449
然后我们会做太空旅行。

19833
27:09:53.976 --> 27:10:01.330
类名等于字体加粗，所以我们可以读它在我们的市场上列出多少。

19834
27:10:01.330 --> 27:10:05.460
让我们回到高点我们可以看到，这是令牌ID 4。

19835
27:10:05.460 --> 27:10:10.681
我们可以看到它的主人，它的价格，还有更多关于狗的信息。

19836
27:10:10.681 --> 27:10:10.877
耶。

19837
27:10:10.977 --> 27:10:13.783
现在让我们把这些东西格式化得好看一点。

19838
27:10:13.977 --> 27:10:16.993
让我们把一个div里的内容再打包一个div。

19839
27:10:17.977 --> 27:10:19.649
比如类名将是flex。

19840
27:10:20.977 --> 27:10:26.262
格式化所有内容，我们将把所有内容放在一个列项目中，然后。

19841
27:10:26.262 --> 27:10:31.322
现在再看这里，就像在列中，再包装一个div，

19842
27:10:31.322 --> 27:10:36.614
给它们一些填充，姓= P表示填充已经被添加了。

19843
27:10:36.614 --> 27:10:37.239
好了,好了。

19844
27:10:37.239 --> 27:10:42.813
然后回到下标，给下标添加一些格式。

19845
27:10:42.813 --> 27:10:48.910
我们的主函数，我们将删除styles。container，我们将写入container。

19846
27:10:48.977 --> 27:10:55.960
MX auto，我们在这里写一个h1，类名，

19847
27:10:55.960 --> 27:11:02.944
等于，我用E X表示粗体字体，文本，XML。

19848
27:11:02.944 --> 27:11:08.079
这是最近列出的，然后

19849
27:11:08.079 --> 27:11:13.215
我们再做一个div。

19850
27:11:13.215 --> 27:11:17.352
类，名称等于伸缩，伸缩包装。

19851
27:11:17.352 --> 27:11:22.215
我们将在这里结束关于JavaScript的div。

19852
27:11:22.215 --> 27:11:23.405
让我们看看UI。

19853
27:11:23.405 --> 27:11:24.892
我们来看看这是怎么回事。

19854
27:11:24.892 --> 27:11:25.451
好的,很酷。

19855
27:11:25.451 --> 27:11:26.823
让我们回到索引。

19856
27:11:26.977 --> 27:11:27.892
我们把这些东西都去掉。

19857
27:11:28.977 --> 27:11:29.738
这张卡。

19858
27:11:29.738 --> 27:11:30.785
让我们拯救。

19859
27:11:34.977 --> 27:11:40.147
能够开始倾听我们的NF t，然后让它们出现在我们的市场上，就像我们在这里看到的。

19860
27:11:40.147 --> 27:11:40.825
太棒了。

19861
27:11:40.825 --> 27:11:44.723
好的，如果我们去自述主页看看最近听空的。

19862
27:11:44.723 --> 27:11:47.863
天啊，这是我们签的支票。

19863
27:11:47.863 --> 27:11:52.332
我知道看起来工作量很大，但其中很大一部分是正确设置士气服务器。

19864
27:11:52.332 --> 27:11:57.299
因为我们有自己的后端，现在，我们有一些需要配置的后端服务。

19865
27:11:57.299 --> 27:12:00.692
但现在一切都准备好了，剩下的就简单了圣。

19866
27:12:00.692 --> 27:12:04.995
现在我们只需要显示连接到web 3的情况。

19867
27:12:04.995 --> 27:12:07.885
对吧?现在，如果我们点击这个，这个仍然会显示出来。

19868
27:12:07.885 --> 27:12:11.523
所以我们要把它更新一下。

19869
27:12:11.523 --> 27:12:13.068
在我们的指数中。

19870
27:12:13.068 --> 27:12:16.789
Js，我们现在检查取回。

19871
27:12:16.789 --> 27:12:23.617
听着，NF T就在那之前，对吧?在我们这样做之前，我们实际上想看看是否启用了web 3。

19872
27:12:23.617 --> 27:12:26.995
这是一些嵌套的三级运算。

19873
27:12:26.995 --> 27:12:31.639
如果web3是启用的，那么我们会做所有这些取回，这里列出了nft的东西。

19874
27:12:31.639 --> 27:12:33.748
我们什么都要在这里做。

19875
27:12:33.748 --> 27:12:38.573
如果它没有启用，我们写一个小div，

19876
27:12:38.573 --> 27:12:42.863
写webthree，当前未启用。

19877
27:12:42.978 --> 27:12:46.437
当然，我们需要抓取iswebthree enabled。

19878
27:12:46.437 --> 27:12:53.167
我们会说，对于顶部我们会做const即threenabled = use oralis就像我们一直做的那样，

19879
27:12:53.167 --> 27:12:59.774
我们会从react Morales中抓取use Morales，我们会保存它回到我们的前端，给它一点刷新。

19880
27:12:59.774 --> 27:13:02.043
如果我们连接起来，我们就能看到市场。

19881
27:13:02.043 --> 27:13:06.913
如果我们断开连接，我们会看到web 3目前没有启用，这是我们想要的。

19882
27:13:06.978 --> 27:13:07.415
完美的。

19883
27:13:07.415 --> 27:13:09.290
下面是自述文件。

19884
27:13:10.978 --> 27:13:11.878
更新清单。

19885
27:13:13.978 --> 27:13:15.896
实际上是这些实体的所有者。

19886
27:13:16.978 --> 27:13:18.758
对这个网站上的人来说很容易。

19887
27:13:19.979 --> 27:13:26.364
这个人的Metamask通过从鼠标上抓取帐户，所以我们做一个逗号帐户。

19888
27:13:26.364 --> 27:13:31.021
然后我们可以很容易地写const由user =

19889
27:13:31.021 --> 27:13:35.882
seller = = = account拥有。

19890
27:13:35.882 --> 27:13:41.575
我们从合同中得到的卖家，我们从关联方那里得到的账

19891
27:13:41.575 --> 27:13:47.269
户，如果卖家等于账户，没有卖家等于等于没有定义。

19892
27:13:47.269 --> 27:13:50.172
我们就说它们是你的。

19893
27:13:50.172 --> 27:13:58.373
现在我们不说由卖方所有，我们可以说const，格式化的卖方地址等于，

19894
27:13:58.373 --> 27:14:06.093
我们做三元操作符会说如果它是由你开的，那么我们就说你而不是卖方。

19895
27:14:06.093 --> 27:14:07.929
否则，我们会说卖方。

19896
27:14:07.929 --> 27:14:11.282
现在我们说由格式化的销售者地址拥有，像这样。

19897
27:14:11.282 --> 27:14:15.792
如果我们回到我们的前端，我们做一点刷新。

19898
27:14:15.792 --> 27:14:19.733
根据用户的不同，你可能会看到所有者等等等等。

19899
27:14:19.733 --> 27:14:22.830
如果我到Metamask，

19900
27:14:22.830 --> 27:14:29.979
把账户切换到账户3，连接到账户3，我们现在看到的是属于你的。

19901
27:14:29.979 --> 27:14:36.705
对，我们甚至可以再次切换，我们会再次切换帐户，我们会切换到帐户1，我们现在看到拥

19902
27:14:36.705 --> 27:14:43.432
有，等等，等等，就像这样当我们来回切换时，这个直径实际上是变化的，这真的很烦人。

19903
27:14:43.432 --> 27:14:45.317
也许我们想更进一步。

19904
27:14:45.317 --> 27:14:49.179
我们要截断这个卖家地址让它变小一点。

19905
27:14:49.179 --> 27:14:52.312
我们想让卖家变小一点。

19906
27:14:52.312 --> 27:14:53.788
我们来创建一个新函数。

19907
27:14:53.788 --> 27:14:58.339
我们可以在export default函数外面创

19908
27:14:58.339 --> 27:15:03.081
建这个因为这是一个不依赖于应用内部任何东西的函数。

19909
27:15:03.081 --> 27:15:04.606
它只是一个原始函数。

19910
27:15:04.606 --> 27:15:09.620
我们将创建。我们将它命名为const truncate

19911
27:15:09.620 --> 27:15:15.750
string，这将是一个以完整字符串和字符串长度作为参数的函数。

19912
27:15:15.750 --> 27:15:20.776
我们会传递卖家地址以及这个字符串的长度。

19913
27:15:20.776 --> 27:15:26.123
这是我们要做的一个箭头函数，我们会说，如果所有string。

19914
27:15:26.123 --> 27:15:31.115
length小于等于str Lang，返回完整的str。

19915
27:15:31.115 --> 27:15:37.265
否则，我们会说ra torx等于三个小点。

19916
27:15:37.265 --> 27:15:43.480
我们会说，让我们分离Tor的长度等于Sep。

19917
27:15:43.480 --> 27:15:45.730
Ra Tor点长度。

19918
27:15:45.730 --> 27:15:52.578
要设置分隔符长度，我们说const chars来

19919
27:15:52.578 --> 27:15:59.426
表示字符串长度减去分隔符长度，我们说const。

19920
27:15:59.426 --> 27:16:04.544
前面的字符等于math。ceiling

19921
27:16:04.544 --> 27:16:16.130
chars除以两个const后面的字符等于math。floor chars除以两个。

19922
27:16:16.130 --> 27:16:19.583
如果你不明白这个数学公式，不用担心。

19923
27:16:19.583 --> 27:16:26.773
然后我们会说，返回0到front字符的完整字符串子串

19924
27:16:26.773 --> 27:16:33.963
加上SEP IRA tour加上完整的STR。子串。

19925
27:16:33.963 --> 27:16:38.747
完整的STR点长度，减去后面的字符。

19926
27:16:38.981 --> 27:16:47.438
现在我们能做的是抓取这个截断的STR这个截断的字符串for被格式化的seller会说如果它

19927
27:16:47.438 --> 27:16:55.896
是，你仍然会做你否则我们会做截断的字符串卖方或空白，如果没有卖方，我们会让它的大小为15。

19928
27:16:55.896 --> 27:17:01.918
现在如果我们保存它，回到我们的前端，如果它属于你，它仍然会显示为你。

19929
27:17:01.981 --> 27:17:08.925
但如果我们切换帐户，现在说拥有，你知道，等等，等等，点，点，等等，加上一个删减的地址。

19930
27:17:08.925 --> 27:17:14.425
这些尺寸实际上不会改变，这比它们变大变小要好得多。

19931
27:17:14.425 --> 27:17:15.123
所以太棒了。

19932
27:17:15.123 --> 27:17:17.789
现在我们把它格式化得更好了。

19933
27:17:17.981 --> 27:17:24.094
好了，现在我们要做什么?好了，现在我们知道了谁拥有NFT,

19934
27:17:24.094 --> 27:17:29.997
NFT的格式也非常好，我们需要想出一种方法来更新清单。

19935
27:17:29.997 --> 27:17:35.690
我们想做的是，如果它属于我们，我们可以切换回账户，它属于如

19936
27:17:35.690 --> 27:17:41.581
果它属于我们，当我们点击它时，我们希望能够更新市场上的列表。

19937
27:17:41.581 --> 27:17:47.027
为此，我们要创建一个新组件Update listing ngModel。

19938
27:17:47.027 --> 27:17:54.888
我们会创建一个新组件，新文件，更新，列出ngmodel。

19939
27:17:54.888 --> 27:17:55.134
js。

19940
27:17:55.134 --> 27:17:58.821
ngModel会弹出来。

19941
27:17:58.821 --> 27:18:02.996
例如，这个弹出的小窗口叫做模态。

19942
27:18:02.996 --> 27:18:04.600
这就是我们想要建立的。

19943
27:18:04.600 --> 27:18:08.384
如果它属于我们，点这个时，我们希望它弹出这个模态。

19944
27:18:08.384 --> 27:18:13.909
开始之前，我们会对所有组件做同样的事情，export default

19945
27:18:13.909 --> 27:18:20.084
function update, listing ngModel，像这样。

19946
27:18:20.084 --> 27:18:27.505
我们可能会想要从实体框传递这些参数，可能会想要传递这些参数。

19947
27:18:27.505 --> 27:18:31.876
所以ngModel知道它需要在非ft市场中调用什么函数。

19948
27:18:31.876 --> 27:18:39.403
更新listing的方法是调用这个update listing函数这里我们需要地址令牌ID和一些新的价格。

19949
27:18:39.403 --> 27:18:41.184
所以我们至少需要这些。

19950
27:18:41.184 --> 27:18:48.432
我们需要NFT地址，至少是令牌ID来让这个小弹出，我们不会自己编码它，我们将再次使用web

19951
27:18:48.432 --> 27:18:56.809
three uikit, web three uikit有这个很好的弹出部分，它有一些代码来处理模态。

19952
27:18:56.809 --> 27:19:03.339
我们会从web3uitkit导入ngModel这是它看起来的

19953
27:19:03.339 --> 27:19:09.870
样子我们有modal然后我们有所有这些关于modal的东西。

19954
27:19:09.870 --> 27:19:13.178
我们会做返回，做一个模态，像这样。

19955
27:19:13.178 --> 27:19:17.134
ngModel的关键之一是它是否应该是可见的。

19956
27:19:17.134 --> 27:19:24.151
它有一个isvisible标签，我们需要从空框中抓取。

19957
27:19:24.151 --> 27:19:31.548
我们也会在这里传递一点isvisible，在我们的NFT框中，我们需要告诉ngModel它什么时候是可见的。

19958
27:19:31.548 --> 27:19:34.093
我们一会儿就会写代码。

19959
27:19:34.093 --> 27:19:35.241
现在，它只会是空白的。

19960
27:19:35.241 --> 27:19:39.439
在ngModel内部，我们会给如何更新它一个输入字段。

19961
27:19:39.439 --> 27:19:46.604
我知道我们之前做过一些常规输入，因为我们通过uikit处理过web，让我们也使用它的输入。

19962
27:19:46.604 --> 27:19:48.696
我们在这里输入一个逗号。

19963
27:19:48.696 --> 27:19:52.304
在ngModel内部，我们会创建一个新的输入。

19964
27:19:52.304 --> 27:19:59.261
在输入字段中，我们会给它一个标签它会更新L货币的标价。

19965
27:19:59.261 --> 27:20:00.733
我们只做每个。

19966
27:20:00.733 --> 27:20:07.721
现在我们只是硬编码每个名字都是新的挂牌价格，类型将等于一个数字

19967
27:20:07.721 --> 27:20:14.935
我们在这里做一个小反斜杠，哦，我们要做一个小反斜杠而不是像这样。

19968
27:20:14.935 --> 27:20:15.315
太酷了。

19969
27:20:15.315 --> 27:20:18.386
当这个模态弹出时，这里会有这个输入。

19970
27:20:18.386 --> 27:20:21.590
我们可以测试一下这是否有效。

19971
27:20:21.590 --> 27:20:29.120
我们可以将它导入到非ft框中，我们会导入，更新，列出ngModel。

19972
27:20:29.120 --> 27:20:33.690
从斜杠，更新，listing ngModel抱歉，这里不需

19973
27:20:33.690 --> 27:20:38.260
要括号，在返回的顶部，就在我们的card将它添加进去之前。

19974
27:20:38.260 --> 27:20:40.352
我们再加一个div。

19975
27:20:40.352 --> 27:20:42.998
这样它们就可以发生相同的反应。

19976
27:20:42.998 --> 27:20:49.383
但我们会添加另一个div，我们会说Update listing ngModel，像这样，这里有一个反斜杠。

19977
27:20:49.383 --> 27:20:52.427
现在我们只需要通过是可见的。

19978
27:20:52.427 --> 27:20:55.411
现在，我们只会说true。

19979
27:20:55.411 --> 27:20:59.333
前端有了这个listing ngModel，我们做了一点刷新。

19980
27:20:59.333 --> 27:21:03.140
我们得到这个小框，像这个更新列表价格和一种货币。

19981
27:21:03.140 --> 27:21:04.876
我们必须关闭其中两个。

19982
27:21:04.983 --> 27:21:08.921
因为技术上来说我们现在两种模式都成立。

19983
27:21:08.983 --> 27:21:13.694
如果我们进行刷新，我们会得到这个小输入弹出这个小模式然后关闭它两

19984
27:21:13.694 --> 27:21:18.554
次，因为我们有两个NF T如果这里有很多NF T，你需要关闭很多。

19985
27:21:18.554 --> 27:21:25.189
我们把它改成false，回到前端，做一点刷新，然后它就变成false了。

19986
27:21:25.189 --> 27:21:28.661
没错，保存，运行，它就在那里。

19987
27:21:28.661 --> 27:21:33.883
Gross, delete, delete, false, save前端，它已经不在那里了。

19988
27:21:33.883 --> 27:21:34.433
好的,很酷。

19989
27:21:34.433 --> 27:21:40.852
我们需要告诉这个ngModel只有当有人点击这个并拥有自己的茶时才会弹出。

19990
27:21:40.852 --> 27:21:45.250
为了切换这个，让它工作，我们需要更新纸牌。

19991
27:21:45.250 --> 27:21:48.775
每当我们点击我们的纸牌时，我们会创建一个叫做handle

19992
27:21:48.775 --> 27:21:55.951
cardclick的函数handle cardclick会更新一个变量来决定我们是否应该显示这个ngModel。

19993
27:21:55.951 --> 27:22:04.896
我们会做的是，在点击牌时，也就是，一旦我们点击狗，我们会调用一些函数。

19994
27:22:04.896 --> 27:22:11.700
我们会说onclick = handle card click animal card click，我们会把它

19995
27:22:11.700 --> 27:22:18.629
变成一个函数，我们会说const handle card click =一个函数，我们会用一些Arrow的东西。

19996
27:22:18.629 --> 27:22:26.871
然后我们会说，如果它是由用户拥有的，如果它是由用户打开的，我们会显示ngModel。

19997
27:22:26.871 --> 27:22:33.361
否则，我们将调用by item函数，因为我们希望重新呈现整个UI。

19998
27:22:33.361 --> 27:22:39.284
一旦我们改变，一旦我们改变变量来显示ngModel，我们会做这个作为US state。

19999
27:22:39.284 --> 27:22:42.584
我们写入const, show ngModel。

20000
27:22:42.584 --> 27:22:45.825
来一组，显示ngModel = use state。

20001
27:22:45.825 --> 27:22:49.734
然后我们开始时将它默认为false。

20002
27:22:49.734 --> 27:22:53.262
默认情况下，我们不会显示向下，这是我们想要的。

20003
27:22:53.262 --> 27:22:59.466
但如果它是用户所有的，我们会说设置Show ngModel为true。

20004
27:22:59.466 --> 27:23:07.301
然后else现在我们输入console。log，我们买之后会更新这个来绑定项目。

20005
27:23:07.301 --> 27:23:12.904
这里不是isvisible be false，而是isvisible = show ngModel。

20006
27:23:12.904 --> 27:23:13.864
或者显示ngModel。

20007
27:23:13.984 --> 27:23:14.359
变量。

20008
27:23:14.359 --> 27:23:14.921
好了,好了。

20009
27:23:16.984 --> 27:23:21.846
UI，我们右键点击，点击检查，如果我们拥有它，我们点击它，

20010
27:23:21.846 --> 27:23:28.554
ngModel会弹出，我们可以点击它，点击另一个，但如果我们不拥有它，它会弹出。

20011
27:23:28.554 --> 27:23:31.542
所以如果我们切换账号，Connect也会切换。

20012
27:23:31.542 --> 27:23:33.494
我们点击它，什么也没发生。

20013
27:23:33.494 --> 27:23:38.350
如果我们去检查，到控制台，点击它，我们应该会看到。

20014
27:23:38.350 --> 27:23:43.207
我们买弹出，这就是我们看到的，我们在这里刷新一下。

20015
27:23:43.207 --> 27:23:49.178
点击我们看到让我们买弹出，再次点击，让我们买点击让我们飞行员，为什么?不错,很酷。

20016
27:23:49.178 --> 27:23:51.065
现在我们有了这个ngModel的词。

20017
27:23:51.065 --> 27:23:57.879
为了正确显示，让我们切换回实际拥有这个非函数的人我们点击它，我们想要能够当我们点击

20018
27:23:57.879 --> 27:24:04.693
确定，或者提交，我们想要发送一个交易来更新这个非函数的价格，所以我们能做的是在我们

20019
27:24:04.693 --> 27:24:11.509
的输入中有一个标签叫on change equals这是每当这个更新时调用的函数。

20020
27:24:11.509 --> 27:24:15.568
我们会说onchange event是一个函数。

20021
27:24:15.568 --> 27:24:20.365
我们会创建一个名为setprice的函数来更新lis

20022
27:24:20.365 --> 27:24:25.348
tingwithevent。target。value。

20023
27:24:25.348 --> 27:24:29.307
我们想要记录我们在这里放入的东西。

20024
27:24:29.307 --> 27:24:32.951
当我们调用函数更新价格时，它已经自动有了。

20025
27:24:32.985 --> 27:24:39.467
我们将创建这个函数而event。target。value将是输入框中的任何东西。

20026
27:24:39.467 --> 27:24:40.952
我们会创建这个set

20027
27:24:40.952 --> 27:24:53.878
price来更新列表将它设为使用日期因为我们想要基于这个来改变UI因此我们会说const price to update listwithcomma set price to

20028
27:24:53.878 --> 27:25:01.902
update listing with equals use state然后我们会让它开始时为0或为空。

20029
27:25:01.902 --> 27:25:05.938
那么现在，无论这里的是什么都会被这个更新。

20030
27:25:05.938 --> 27:25:12.117
现在我可以做我们的console。log价格更新列表

20031
27:25:12.117 --> 27:25:18.297
回到前端，我们需要导入使用状态导入，使用状态从反应。

20032
27:25:18.297 --> 27:25:23.886
回到前端，点击这个，右键点击检查。

20033
27:25:23.986 --> 27:25:26.562
第一类，我们看到114，我们看到14。

20034
27:25:27.986 --> 27:25:29.173
控制台点日志。

20035
27:25:31.986 --> 27:25:36.936
这个函数就是我们碰到这个时调用的函数，等等。

20036
27:25:36.936 --> 27:25:43.059
它将等于一个函数，我们将使用一个小箭头符号，我们将调用那

20037
27:25:43.059 --> 27:25:49.401
个更新列表函数在区块链上，我们需要抓取那个函数以便使用它。

20038
27:25:49.401 --> 27:25:57.282
要使用那个函数，我们会从react mirallas导入use web3contract。

20039
27:25:57.282 --> 27:26:00.293
作为一个新的钩子，我们说const

20040
27:26:00.293 --> 27:26:07.379
run合约函数Update listing，等于use webthree合约。

20041
27:26:07.379 --> 27:26:12.936
这将是我们在非金融市场上调用的一个函数。

20042
27:26:12.936 --> 27:26:17.605
ABI将是非ft市场API，我们可以

20043
27:26:17.605 --> 27:26:22.534
通过导入得到它，类似于我们在这里做的。

20044
27:26:22.534 --> 27:26:26.017
我们只需要从非ft框中复制粘贴。

20045
27:26:26.017 --> 27:26:33.388
我们会从。。constant导入非ft集市API将JSON发送到

20046
27:26:33.388 --> 27:26:40.760
集市，我们需要合约地址，这将是更新列表ngModel的输入参数。

20047
27:26:40.760 --> 27:26:47.287
我们甚至可以做一个逗号marketplace地址，复制这里的这个地方，这意味

20048
27:26:47.287 --> 27:26:53.987
着在我们的NFT框中，很快，我们将把所有这些变量传递给它，但我们马上会保存它。

20049
27:26:53.987 --> 27:26:57.564
NFT市场地址，市场地址函数名，

20050
27:26:57.564 --> 27:27:03.602
将是Update，列在智能合约中，然后是params。

20051
27:27:03.602 --> 27:27:10.865
如果我们到这里，我们有更新列表取非ft地址令牌ID新价格做

20052
27:27:10.865 --> 27:27:18.128
非ft地址，这将是非ft地址，我们说令牌ID将是令牌ID新

20053
27:27:18.128 --> 27:27:25.642
价格你的价格将从价格更新列表中得到但将它从人类可读转换为醚。

20054
27:27:25.642 --> 27:27:29.802
所以我们从醚中导入醚。

20055
27:27:29.802 --> 27:27:35.284
新的价格将是ethers。utils。parse

20056
27:27:35.284 --> 27:27:44.422
ethers或ether price来更新列表如果它是空的，我们就说or 0。

20057
27:27:44.422 --> 27:27:51.936
我们有NFT地址令牌ID市场地址在我们的NFT框中，我们需要在这里传递那些参数。

20058
27:27:51.987 --> 27:27:57.833
我们有isvisible，我们还有令牌ID，

20059
27:27:57.833 --> 27:28:03.415
它将等于令牌ID，市场地址将等于市场地址。

20060
27:28:03.415 --> 27:28:08.487
NFT地址将等于NFT地址。

20061
27:28:08.487 --> 27:28:15.748
当我们编码和测试这个的时候这很烦人，因为这对我来说很烦人让我们刷新一下网站。

20062
27:28:15.748 --> 27:28:17.715
如果我们点击它，这个东西就会弹出。

20063
27:28:17.715 --> 27:28:21.209
但当我点X，点这个，还是没有显示。

20064
27:28:21.209 --> 27:28:26.246
这是因为从技术上讲，show ngModel现在仍然为真，即使我们退出了。

20065
27:28:26.246 --> 27:28:32.525
我们要在NFT框中做的是在我们的更新列表ngModel中我们也会在关闭时将它传递进来，

20066
27:28:32.525 --> 27:28:37.781
我们会传递给它一个隐藏的ngModel变量这是我们将要创建的，在Show

20067
27:28:37.781 --> 27:28:45.083
ngModel Set Show ngModel下面我们会创建const Eid ngModel。

20068
27:28:45.083 --> 27:28:51.665
这是一个函数，它会说set, show modal。

20069
27:28:51.665 --> 27:28:57.552
如果是false，我们将把这个函数传递给update模态列表。

20070
27:28:57.552 --> 27:29:00.455
我们在Close处用逗号。

20071
27:29:00.455 --> 27:29:05.445
在我们的模式中，我们会说，on Close。

20072
27:29:05.445 --> 27:29:11.607
On，取消，我们会调用它On close function，或者On close

20073
27:29:11.607 --> 27:29:17.925
button pressed，我们也会调用它On close function。

20074
27:29:17.988 --> 27:29:23.928
如果我们刷新网站，点击这个模态就会弹出，点击X，再点击一次，

20075
27:29:23.928 --> 27:29:29.670
它就会弹出，因为现在我们正确地将它设为假然后将它重置为真。

20076
27:29:29.670 --> 27:29:34.934
现在要发送这个更新列表函数，我们要传递另一个东

20077
27:29:34.934 --> 27:29:40.428
西，另一个变量，我们要传递它，它也会是一个函数。

20078
27:29:40.428 --> 27:29:44.254
它会调用我们刚创建的updatlisting。

20079
27:29:44.254 --> 27:29:47.375
现在，添加一个On错误总是一个好主意。

20080
27:29:47.375 --> 27:29:54.854
我们会说on error，把这个error作为一个函数和console。log。

20081
27:29:54.988 --> 27:30:01.750
错误和这个需要用括号括起来，但是合同地址是错误的。

20082
27:30:01.750 --> 27:30:09.575
所以我们要写这份合同，合同地址并拼写正确。

20083
27:30:09.575 --> 27:30:11.747
拼写正确。

20084
27:30:11.989 --> 27:30:14.939
现在回到UI，给它一点刷新。

20085
27:30:14.989 --> 27:30:16.864
单击，这将添加一个。

20086
27:30:16.864 --> 27:30:18.973
我们看到Metamask出现了。

20087
27:30:19.989 --> 27:30:20.989
效果很好。

20088
27:30:22.989 --> 27:30:23.881
会吓坏的。

20089
27:30:24.989 --> 27:30:28.726
很棒的应用就这样出现了，这很好。

20090
27:30:28.989 --> 27:30:33.284
有这个小错误处理，我想为所有这些运行契约函数添加这个。

20091
27:30:33.284 --> 27:30:35.579
让我们再来谈谈成功。

20092
27:30:35.579 --> 27:30:42.560
当这个成功通过时，我们会调用一个函数叫作handle update，列出成功。

20093
27:30:42.560 --> 27:30:46.284
这是一个当它正确通过时我们会调用的函数。

20094
27:30:46.284 --> 27:30:48.609
在顶部，我们创建这个新函数，我们设为const。

20095
27:30:48.609 --> 27:30:54.655
处理更新，监听成功将是一个使用箭头语法的新函数。

20096
27:30:54.655 --> 27:30:59.639
我们会让这个为一个web应用程序设置一个新的通知。

20097
27:30:59.639 --> 27:31:04.405
要做通知，我们会使用web3uitkits使

20098
27:31:04.405 --> 27:31:09.389
用通知，这和我们上一个使用的通知服务是一样的。

20099
27:31:09.389 --> 27:31:13.682
在上面这里，我们会导入它，使用通知。

20100
27:31:13.682 --> 27:31:20.368
然后我们会说，在我们的组件中，我们会说const, dispatch = use notification。

20101
27:31:20.368 --> 27:31:24.623
因为我们在应用中使用通知。

20102
27:31:24.623 --> 27:31:26.654
Js，我们必须把它导入这里。

20103
27:31:26.654 --> 27:31:32.150
我们会从web3uitkit导入通知提供者。

20104
27:31:32.150 --> 27:31:38.390
在Morales提供程序内部，我们会在header和

20105
27:31:38.390 --> 27:31:44.871
组件周围添加通知提供程序，这样我们就有了相关的上下文。

20106
27:31:44.990 --> 27:31:49.514
在我们的句柄更新列表success中，这个函数会

20107
27:31:49.514 --> 27:31:54.227
说dispatch，说type将是success。

20108
27:31:54.227 --> 27:32:01.406
消息将被更新，标题将被更新，

20109
27:32:01.406 --> 27:32:07.561
请刷新，请刷新和移动块。

20110
27:32:07.561 --> 27:32:10.132
然后是位置。

20111
27:32:10.132 --> 27:32:11.615
右上方。

20112
27:32:11.615 --> 27:32:17.240
然后我们再讨论衣服，再讨论衣服。

20113
27:32:17.240 --> 27:32:23.679
我们会说set price to update listing with back to 0。

20114
27:32:23.679 --> 27:32:25.735
我还会在以后编辑一下这个。

20115
27:32:25.735 --> 27:32:31.056
我意识到我忘了给很多句柄函数添加TX。

20116
27:32:31.056 --> 27:32:38.723
当我们调用这些运行契约函数时，就像我们说的，他们在onsuccess中有这个。

20117
27:32:38.723 --> 27:32:46.406
现在这个onsuccess自动地将调用的结果传递给那里的任何回调函数。

20118
27:32:46.406 --> 27:32:50.900
例如，上面的列表返回一个事务，我们将把该事

20119
27:32:50.900 --> 27:32:55.610
务传递给添加到onsuccess的任何东西。

20120
27:32:55.610 --> 27:33:00.168
在这里，你可以让它有一个事务作为输入参数。

20121
27:33:00.168 --> 27:33:04.974
这个交易将会在区块链上更新价格。

20122
27:33:04.974 --> 27:33:09.891
我们想把它从常规函数改成异步函数。

20123
27:33:09.891 --> 27:33:18.580
我们可以用await TX。Wait, 1，因为我们不想说，成功，在事务执行之前，列表已经更新了。

20124
27:33:18.580 --> 27:33:20.892
所以我们希望首先进行事务处理。

20125
27:33:20.991 --> 27:33:25.755
然后我们想弹出调度说，嘿，它通过了然后另外，

20126
27:33:25.755 --> 27:33:34.635
当我们在onsuccess上调用这些模型时，我们通过引用函数的名字把它们传递进来。

20127
27:33:34.635 --> 27:33:39.988
我们不再使用箭头语法，像这样，我们只说，嘿，

20128
27:33:39.988 --> 27:33:45.829
onsuccess将是这个，把你的结果传递给它。

20129
27:33:45.829 --> 27:33:48.667
这就是我们在下面的称呼。

20130
27:33:48.667 --> 27:33:53.406
如果你看与此相关的GitHub回购，你会进入组件，我们会进入这些。

20131
27:33:53.406 --> 27:33:57.680
在这个视频中，我忘了加上await TX。wait 1。

20132
27:33:57.680 --> 27:33:59.925
但在GitHub回购中，我们有这些。

20133
27:33:59.925 --> 27:34:06.991
我在视频中演示的时候，调度会在事务完成之前弹出。

20134
27:34:06.991 --> 27:34:09.391
我想让你们知道，回到视频。

20135
27:34:09.391 --> 27:34:13.885
当我们成功时，会弹出一个成功的小窗口。

20136
27:34:13.885 --> 27:34:20.492
另一件事是，当我们调用这个时，我们会省略Morales仪表板中

20137
27:34:20.492 --> 27:34:27.313
列出的一个项目，价格实际上应该在活动项目中更新因为我们的云功能。

20138
27:34:27.313 --> 27:34:30.184
现在我们把这些都放在一起。

20139
27:34:30.184 --> 27:34:31.861
所以我们在前端。

20140
27:34:31.991 --> 27:34:35.429
如果你拥有的市场会点击它。

20141
27:34:35.991 --> 27:34:37.249
清单至25。

20142
27:34:41.991 --> 27:34:49.591
我们将继续并确认并运行一个错误因为我们需要点击Metamask，我需要重置我的帐户。

20143
27:34:49.591 --> 27:34:54.879
我要设置，高级重置账户。

20144
27:34:54.991 --> 27:35:00.339
Metamask又弹出来了，我们要确认它

20145
27:35:00.339 --> 27:35:05.955
关闭了，弹出模式，我们得到了我们的小通知。

20146
27:35:05.955 --> 27:35:14.942
我们可以看到一个活动，事务已经完成，我们到活动项，给它一点刷新。

20147
27:35:14.992 --> 27:35:18.106
现在我们看到我们的item列出了事件。

20148
27:35:19.992 --> 27:35:21.458
这还没有得到证实。

20149
27:35:23.992 --> 27:35:26.242
我们需要把积木移动1个。

20150
27:35:26.992 --> 27:35:34.767
我们会创建一个新脚本，一个叫做Mind。Jas的新文件，只移动我们的block一次，

20151
27:35:34.767 --> 27:35:43.653
我们会说const move blocks，等于require。/ utils / / move

20152
27:35:43.653 --> 27:35:50.317
blocks，我们会说const blocks等于const sleep

20153
27:35:50.317 --> 27:35:59.018
amount等于1000 async function mine, do await move

20154
27:35:59.018 --> 27:36:09.942
blocks将do blocks作为参数然后sleep sleep amount将等于sleep amount。

20155
27:36:09.942 --> 27:36:12.499
这将是一个脚本。

20156
27:36:12.499 --> 27:36:18.280
所以我们要添加复制粘贴和我这里做的语法一样。

20157
27:36:18.280 --> 27:36:21.680
现在我们要挖掘这两个区块。

20158
27:36:21.680 --> 27:36:26.155
所以我们将运行纱线，美术和脚本。

20159
27:36:26.155 --> 27:36:30.753
注意Jas dash dash网络，本地主机。

20160
27:36:30.753 --> 27:36:34.468
所以我们要在这两个街区开矿。

20161
27:36:34.468 --> 27:36:40.597
现在回到数据库，回到活动项目，我们可以看到它

20162
27:36:40.597 --> 27:36:46.726
被更新了因为在我们列出的项目中，2500事件

20163
27:36:46.726 --> 27:36:53.135
现在是一个已确认的交易，我们可以确认它们很好。

20164
27:36:53.135 --> 27:36:58.796
这意味着，既然它已经在我们的前端确认了，我们将给它一点刷新。

20165
27:36:58.796 --> 27:37:03.386
我们可以看到这只幼崽现在每只价值25英镑。

20166
27:37:03.386 --> 27:37:04.304
太棒了。

20167
27:37:04.304 --> 27:37:07.381
我们在更新ngModel，它运行得很好。

20168
27:37:07.381 --> 27:37:08.145
优秀的工作。

20169
27:37:08.145 --> 27:37:09.670
现在我们来看自述文件。

20170
27:37:09.670 --> 27:37:13.362
如果您拥有NFT，则可以更新清单。

20171
27:37:13.362 --> 27:37:15.408
这是一个勾号。

20172
27:37:15.408 --> 27:37:16.484
太好了。

20173
27:37:16.484 --> 27:37:21.459
接下来，我们想让它做什么?如果你不拥有它，你可以买下它。

20174
27:37:21.459 --> 27:37:30.343
好，回到我们的网站，把用户切换到另一个账户，我们可能需要一个拥有一些钱的账户。

20175
27:37:30.343 --> 27:37:34.816
让我们继续，在我的账户之间转账给另一个账户，我

20176
27:37:34.816 --> 27:37:39.484
们每人汇100到账户1，确认在我们的安全帽链上。

20177
27:37:39.484 --> 27:37:40.221
好了,好了。

20178
27:37:40.221 --> 27:37:43.760
现在我们可以转到1号账户，我们各有100元。

20179
27:37:43.760 --> 27:37:44.402
好了,好了。

20180
27:37:44.402 --> 27:37:46.721
这些棒棒糖，每只不到100块。

20181
27:37:46.721 --> 27:37:49.659
这对我们来说足够测试了。

20182
27:37:49.659 --> 27:37:50.897
让我们回到这个盒子。

20183
27:37:50.993 --> 27:37:58.680
因为我想我们说过，我们做了一个手柄card click，如果它属于用户，就会弹出模式。

20184
27:37:58.680 --> 27:38:01.659
如果没有，我们用by函数。

20185
27:38:01.659 --> 27:38:07.009
要做by函数，我们要做另一个run合约函数。

20186
27:38:07.009 --> 27:38:14.605
我们用const run合约函数，按项调用这个。

20187
27:38:14.605 --> 27:38:18.596
而这将等于使用web三合同。

20188
27:38:18.596 --> 27:38:23.151
这将是非金融市场的ABI。

20189
27:38:23.151 --> 27:38:30.450
API，合同地址将是市场地址。

20190
27:38:30.450 --> 27:38:35.891
函数名将是按项的，消

20191
27:38:35.891 --> 27:38:41.877
息值将是非函数的价格。

20192
27:38:41.994 --> 27:38:44.502
因为我们需要汇款来购买物品。

20193
27:38:44.994 --> 27:38:51.265
params将是非ft地址，这将是非ft地址。

20194
27:38:51.265 --> 27:38:56.593
令牌ID，也就是令牌ID现在我们在句柄cardclick上有了这

20195
27:38:56.593 --> 27:39:02.089
个by item，我们可以说，show ngModel为true。

20196
27:39:02.089 --> 27:39:05.119
否则，我们会按项调用。

20197
27:39:05.119 --> 27:39:07.837
我们将在直播中进行。

20198
27:39:07.837 --> 27:39:14.061
Air会是一个函数我们会用console。log Air和onsuccess。

20199
27:39:14.061 --> 27:39:20.522
这是一个调用handle by item success的函数。

20200
27:39:20.522 --> 27:39:24.465
我们会在处理过的推车下面创建一个新的处理程序点击const

20201
27:39:24.465 --> 27:39:29.633
handled by item success = a function。

20202
27:39:29.633 --> 27:39:33.739
对于这个，我们还会让它做一个小通知。

20203
27:39:33.739 --> 27:39:41.354
再一次，我们将导入我们将从web通过UI kit导入use notification。

20204
27:39:41.354 --> 27:39:44.354
我们要说的是const。

20205
27:39:44.354 --> 27:39:47.851
分派等于使用通知。

20206
27:39:47.851 --> 27:39:50.422
然后在处理的项目成功。

20207
27:39:50.422 --> 27:39:56.377
我们会说调度类型，成功。

20208
27:39:56.377 --> 27:39:57.843
消息。

20209
27:39:57.843 --> 27:40:00.043
项目购买。

20210
27:40:00.043 --> 27:40:05.822
标题也将购买的项目。

20211
27:40:05.822 --> 27:40:12.304
那么杆位就在右上方就这样。

20212
27:40:12.304 --> 27:40:18.042
handle cardclick，如果他们拥有它，我们会显示更新清单ngModel。

20213
27:40:18.042 --> 27:40:20.595
如果他们还没有拥有它，总有人会买的。

20214
27:40:20.595 --> 27:40:21.695
我们回到这里。

20215
27:40:21.695 --> 27:40:24.776
我现在的账户不拥有这些NF T。

20216
27:40:24.776 --> 27:40:26.137
让我们继续点击它。

20217
27:40:26.137 --> 27:40:29.351
我们的超面具确实出现了25次。

20218
27:40:29.351 --> 27:40:32.047
太贵了。

20219
27:40:32.047 --> 27:40:40.280
我们来确认商品已经被购买，点击那个小x，进入元掩码，交易正在等待中。

20220
27:40:40.280 --> 27:40:41.851
它通过了。

20221
27:40:41.995 --> 27:40:43.167
这太棒了。

20222
27:40:45.995 --> 27:40:49.732
最近列出的NF T如果没有，你可以更新列表。

20223
27:40:49.995 --> 27:40:51.395
没有，你可以买到。

20224
27:40:52.995 --> 27:40:53.461
页面。

20225
27:40:59.995 --> 27:41:07.677
让我们得到这个单元格页面，让我们得到这个完成页面，我们有我们的单元格非ft页面，它现在什么都不做。

20226
27:41:07.677 --> 27:41:11.927
在我们的前端，我们到这里，这里没有很多。

20227
27:41:11.995 --> 27:41:16.902
实际上，你可以在市场上列出你的非功能性资产，我们还需要添加提取收益。

20228
27:41:16.902 --> 27:41:18.194
所以我没有加上这个。

20229
27:41:18.194 --> 27:41:22.029
但这可能也是我们希望允许人们去做的事情。

20230
27:41:22.029 --> 27:41:23.373
我们从这里开始。

20231
27:41:23.373 --> 27:41:27.302
我们可以去掉这个头部的东西现在我们把它添加到主页上了。

20232
27:41:27.302 --> 27:41:31.939
要提交一个新的NFT，我们可能需要一个

20233
27:41:31.939 --> 27:41:36.822
空格来添加实体地址NFT的令牌ID等等。

20234
27:41:36.822 --> 27:41:43.392
我们需要一个表单来做这个，你猜怎么着，我们也可以通过UI kit从web获取一个表单。

20235
27:41:43.392 --> 27:41:47.884
我们将继续在单元格NMC页面中，我

20236
27:41:47.884 --> 27:41:52.642
们将从web3uitkit导入表单。

20237
27:41:52.642 --> 27:41:57.241
我们将在单元格页面中创建一个新表单。

20238
27:41:57.241 --> 27:42:05.101
我们可以添加到表单中的参数，同样可以在文档中找到，或者我们将添加一个主要部分就

20239
27:42:05.101 --> 27:42:12.962
是这个数据块，它是一个对象里面有一个列表，所有不同的字段，我们可以放入表单中。

20240
27:42:12.962 --> 27:42:17.329
也许我们会做第一个有一个非ft地址的名字。

20241
27:42:17.329 --> 27:42:22.935
它的类型是text，不好意思，

20242
27:42:22.935 --> 27:42:28.168
这些都是这是一个对象的列表。

20243
27:42:28.168 --> 27:42:35.635
现在，如果我们保存它，回到单元格页面，我们能看到一个空地址和一个小小的Submit按钮。

20244
27:42:35.635 --> 27:42:37.749
那现在什么都做不到。

20245
27:42:37.749 --> 27:42:43.122
我们有一个非ft地址，它会有一个文本，也许我

20246
27:42:43.122 --> 27:42:48.496
们也会在英尺宽为50%的情况下让起始值为空。

20247
27:42:48.496 --> 27:42:57.401
这个的键将是NFT地址，我们还需要什么呢，我们需要给它一个令牌ID我

20248
27:42:57.401 --> 27:43:06.307
们会说name，令牌ID, type将是一个数字值，开始时它是空的。

20249
27:43:06.307 --> 27:43:11.946
这个的键是令牌ID。

20250
27:43:11.946 --> 27:43:15.757
接下来，我们需要知道价格。

20251
27:43:15.757 --> 27:43:18.804
我们说name will be price。

20252
27:43:18.996 --> 27:43:19.773
容易的。

20253
27:43:19.773 --> 27:43:24.440
类型将是一个数字，值将为空。

20254
27:43:25.997 --> 27:43:26.797
将是价格。

20255
27:43:29.997 --> 27:43:33.679
删除第二个，让它用一个标签自动关闭。

20256
27:43:33.997 --> 27:43:41.617
然后在这里，我们会写title = sell your NF T ID = main form。

20257
27:43:41.617 --> 27:43:42.168
太酷了。

20258
27:43:42.168 --> 27:43:48.925
所以现在我们可以取一个空地址、一个令牌ID和一个标题为cellular NFT的新价格。

20259
27:43:48.997 --> 27:43:50.447
太好了，看起来真不错。

20260
27:43:51.997 --> 27:43:56.130
任何事情，我们可能想给它功能来做一些事情。

20261
27:43:56.130 --> 27:44:01.770
我们会在Submit上，然后我们需要创建一个新函数来列出NF - T。

20262
27:44:01.770 --> 27:44:06.341
所以我们要创建一个叫做批准和列表的函数，我们必须

20263
27:44:06.341 --> 27:44:10.913
批准我们的市场，从我们的钱包中取出非功能性产品。

20264
27:44:10.997 --> 27:44:18.505
我们要创建一个新函数，一个同步函数approven list，它会在表单上取一个数据输入参

20265
27:44:18.505 --> 27:44:26.013
数，当我们点击submit时，它会自动将这个数据对象传递给approved list函数。

20266
27:44:26.013 --> 27:44:32.292
这就是我们获取地址值令牌ID值和价格值的方法。

20267
27:44:32.292 --> 27:44:37.110
在async函数approven list中，

20268
27:44:37.110 --> 27:44:44.234
doconsole。log，审批契约，非ft地址将来自这个数据对象。

20269
27:44:44.234 --> 27:44:50.049
所以它将是data。data在索引0处，或者0

20270
27:44:50.049 --> 27:44:56.877
with object这里将是我们的地址，输入结果。

20271
27:44:56.997 --> 27:45:00.857
令牌ID等于data。data。

20272
27:45:01.998 --> 27:45:07.901
同样，这个将是我们的令牌ID输入结果。

20273
27:45:07.998 --> 27:45:16.070
然后价格将等于ethers。utils。data。

20274
27:45:16.070 --> 27:45:23.498
data的解析单位与输入结果，逗号ether。

20275
27:45:23.498 --> 27:45:24.398
字符串。

20276
27:45:24.398 --> 27:45:28.398
这就是每单位的价格。

20277
27:45:28.398 --> 27:45:33.670
在人类可读的形式中，我们将把它转换为Aetherium可读的形式。

20278
27:45:33.670 --> 27:45:39.722
然后我们将它作为字符串传递因为这返回一个大数字，这是我们不想要的。

20279
27:45:39.722 --> 27:45:43.502
我们有了NFT地址，令牌ID和新列表的价格，

20280
27:45:43.502 --> 27:45:52.095
我们现在能做的是我们可以说const approve options等于这里的一个小函数，ABI将是

20281
27:45:52.095 --> 27:45:58.283
这里的一个小函数，ABI将是我们的NFT ABI，我们需要导入它，我们需要从ethers导入两个醚。

20282
27:45:58.283 --> 27:46:05.705
我们还需要导入NFT abi，它的NFT abi from。dot

20283
27:46:05.705 --> 27:46:14.252
constants / slash basic at at at T dot

20284
27:46:14.252 --> 27:46:21.224
JSON，我刚从NFT框复制粘贴过来，合约地址将是NFT地址，

20285
27:46:21.224 --> 27:46:32.696
函数名将是approve params将是2，市场地址，我们马上会定义，然后令牌ID将是令牌ID。

20286
27:46:32.696 --> 27:46:41.424
NFT框中的市场地址，我们直接从索引中获取，索引从数据库中获取。

20287
27:46:41.424 --> 27:46:48.507
现在我们希望我们的应用足够智能，能够抓取非ft市场本身，即市场地址。

20288
27:46:48.507 --> 27:46:53.249
如果我们看我们的常数，现在，我们实际上在这个网络映射中有它。

20289
27:46:53.249 --> 27:46:57.701
我们想在最上面抓取它通过const

20290
27:46:57.701 --> 27:47:09.224
marketaddress =网络映射，网络映射的是实体市场地址的链ID在0处带索引。

20291
27:47:09.224 --> 27:47:16.951
所以链ID的网络映射，我们会得到真实的链ID等于我们莫拉莱斯。

20292
27:47:16.951 --> 27:47:22.919
链Id实际上就像我们说的，它是莫拉莱斯的蜡制六边形。

20293
27:47:22.999 --> 27:47:27.522
我们需要将chain ID转换为字符串可读版本。

20294
27:47:27.522 --> 27:47:32.149
因此我们写入const，链式字符串=链式ID。

20295
27:47:32.149 --> 27:47:40.585
我们用一个第三运算符，如果chain ID存在，就解析int (chain ID)

20296
27:47:40.585 --> 27:47:41.671
字符串。

20297
27:47:41.671 --> 27:47:46.811
因此，我们将从十六进制解析到一个更可读的版本，然后执行。

20298
27:47:46.811 --> 27:47:47.516
字符串。

20299
27:47:47.516 --> 27:47:51.826
否则，我们就说31337。

20300
27:47:51.999 --> 27:47:53.179
chain ID string。

20301
27:47:55.999 --> 27:48:04.558
string。。NFT市场在索引0处，那将是我们的市场地址。

20302
27:48:04.558 --> 27:48:13.499
我们得到了市场地址，这就是我们调用非功能性核准函数所需要的，我们现在可以调用运行契约函数作为证明。

20303
27:48:13.499 --> 27:48:15.753
所以我们实际上要做的有点不同。

20304
27:48:15.753 --> 27:48:18.676
我们会说const。

20305
27:48:18.676 --> 27:48:23.860
runcontractfunction = use web3contract，

20306
27:48:23.860 --> 27:48:30.375
你可以导入runcontractfunction，然后把所有选项传递给它，就像我们这里要做的那样。

20307
27:48:30.375 --> 27:48:33.961
现在我们要说的是await oncontractfunction。

20308
27:48:34.100 --> 27:48:43.007
因为这是一个async函数，等待运行合约函数，我们会说params将是批准选项。

20309
27:48:43.100 --> 27:48:50.022
我们会说onsuccess，我们会做一些事情，我要说onerror，

20310
27:48:50.022 --> 27:48:57.149
我们也会说error，小箭头函数，console。log error。

20311
27:48:57.149 --> 27:49:03.374
成功后，一旦我们发送这个事务，在审批通过后，我们

20312
27:49:03.374 --> 27:49:09.600
会调用下面的列表函数调用async async。

20313
27:49:09.600 --> 27:49:13.673
功能，处理审批成功。

20314
27:49:13.673 --> 27:49:20.879
这将使用非ft地址，令牌ID，以及价格，将它放入参数中。

20315
27:49:20.879 --> 27:49:27.310
这个运行契约函数通过后，我们会调用handle proof success。

20316
27:49:27.310 --> 27:49:35.990
我们会把地址的末尾，令牌ID和价格传递给它，它会说console。log。

20317
27:49:36.100 --> 27:49:39.433
好了，现在是列出清单的时间了，我们会做同样的事情。

20318
27:49:40.100 --> 27:49:45.415
const list options，等于这将是

20319
27:49:45.415 --> 27:49:50.731
所有调用列表函数API的选项这次将在市场上出现。

20320
27:49:50.731 --> 27:49:56.766
NFT market place abi，我们还要导入它我要回到NFT方框。

20321
27:49:56.766 --> 27:50:00.290
我们复制这一行，粘贴到上面。

20322
27:50:00.290 --> 27:50:03.655
那将是合约地址的API。

20323
27:50:03.655 --> 27:50:09.015
这将是市场地址，我们已经有了。

20324
27:50:09.100 --> 27:50:12.375
函数名将是列表项。

20325
27:50:14.100 --> 27:50:19.000
将是NFT地址的ntf地址，令

20326
27:50:19.000 --> 27:50:23.900
牌ID的令牌ID，价格的价格。

20327
27:50:23.900 --> 27:50:26.583
现在我们有了这些选项，

20328
27:50:26.583 --> 27:50:32.927
我们可以执行await，用params运行契约函数。

20329
27:50:32.927 --> 27:50:39.166
列表选项的onsuccess箭头函数，处

20330
27:50:39.166 --> 27:50:45.405
理列表成功，这是一个我们还没有做的函数。

20331
27:50:45.405 --> 27:50:47.714
它会在空气错误上显示。

20332
27:50:47.714 --> 27:50:52.749
我们写入console。log error。

20333
27:50:52.749 --> 27:50:57.744
让这个句柄列表成功处理一个拼写句柄正

20334
27:50:57.744 --> 27:51:03.018
确处理成功，这将是一个async函数。

20335
27:51:03.100 --> 27:51:06.037
这也会调用dispatch并发出一个小通知。

20336
27:51:06.037 --> 27:51:11.911
我们会从web3uitkit中抓取这个，使用通知。

20337
27:51:11.911 --> 27:51:17.261
我们说const dispatch = use notification。

20338
27:51:17.261 --> 27:51:24.688
然后在处理成功中输入dispatch，输入success。

20339
27:51:24.688 --> 27:51:29.263
消息非帖列表，标

20340
27:51:29.263 --> 27:51:33.838
题非帖列表位置。

20341
27:51:33.838 --> 27:51:35.499
顶部酒吧，很酷。

20342
27:51:35.499 --> 27:51:42.035
我们还得把莫拉莱斯抓来。

20343
27:51:42.035 --> 27:51:46.673
所以一定要把莫拉莱斯从react引进来。

20344
27:51:46.673 --> 27:51:49.705
我们导入这个网络映射。

20345
27:51:49.705 --> 27:51:57.521
导入网络映射从点。点。斜杠常数/斜杠网络映射点JSON。

20346
27:51:57.521 --> 27:52:03.981
因为我又把合同地址拼错了，好的，我们的前端我们会刷新一下我们的网页，三个合同没有定义。

20347
27:52:03.981 --> 27:52:06.286
让我们从react moral中得到答案。

20348
27:52:06.286 --> 27:52:08.833
好吧，保存，刷新我们的前端。

20349
27:52:08.833 --> 27:52:10.966
好了，我们可以开始了。

20350
27:52:11.100 --> 27:52:15.761
好了，现在要测试这个，我们要做的是我们要在这里创建另一个脚本。

20351
27:52:15.761 --> 27:52:19.640
所以我们回到了非ft市场的内心，我们在看我们的脚本。

20352
27:52:19.640 --> 27:52:22.417
我们要创建一个新文件mint。

20353
27:52:22.417 --> 27:52:22.575
js。

20354
27:52:22.575 --> 27:52:31.521
这次我们不打算列出它，我们只打算创建一个ntf我们可以自己在UI上列出它。

20355
27:52:31.521 --> 27:52:40.067
实际上，我们可以复制mminton列表代码，粘贴到这里，然后删除审批和列表代码。

20356
27:52:40.067 --> 27:52:43.615
轰，移开那个，移开这个，移开这个。

20357
27:52:43.615 --> 27:52:45.047
这就是我们需要的。

20358
27:52:45.047 --> 27:52:47.293
现在我们把名字改成薄荷吧。

20359
27:52:47.293 --> 27:52:48.938
我们也可以去掉价格。

20360
27:52:48.938 --> 27:52:50.664
我们把这个换成薄荷糖。

20361
27:52:50.664 --> 27:52:51.793
就是这样。

20362
27:52:51.793 --> 27:52:58.623
现在我们有了一个可以调用的脚本，我们只需要创建一个非功能性的，我们也可以摆脱非功能性的市场。

20363
27:52:58.623 --> 27:53:02.881
实际上，我们可能需要令牌ID，以便知道它是什么。

20364
27:53:02.881 --> 27:53:06.068
我们写const令牌ID =。

20365
27:53:06.068 --> 27:53:13.350
让我们实际获取收据我们用const mint TX收据，但是收据，我可以在这里等于它。

20366
27:53:13.350 --> 27:53:17.528
然后我要把这个从羊绒收据上抄下来。

20367
27:53:17.528 --> 27:53:22.211
Cons令牌ID等于这个，粘贴到mint中。

20368
27:53:22.211 --> 27:53:25.433
Js，然后是console。log。

20369
27:53:25.433 --> 27:53:30.831
得到令牌ID，字符串插值令牌ID，硬帽子，

20370
27:53:30.831 --> 27:53:36.487
运行脚本，分钟。j s破折号网络，本地主机。

20371
27:53:36.487 --> 27:53:39.623
我们要创造一个NF - T。

20372
27:53:39.623 --> 27:53:47.134
Got token ID 6表示我们知道m token ID 6，我们可以列出这个实体。

20373
27:53:47.134 --> 27:53:48.530
让我们还添加地址。

20374
27:53:48.530 --> 27:53:51.287
让我们做console。log NFTL。

20375
27:53:51.287 --> 27:53:58.957
如果地址是我们会做字符串插值。

20376
27:53:59.100 --> 27:54:01.811
你知道吗?让我们再做一次。

20377
27:54:03.100 --> 27:54:03.353
酷。

20378
27:54:07.100 --> 27:54:09.528
现在我们就去找这个非ft地址。

20379
27:54:11.100 --> 27:54:15.964
转到帐户3，因为这是我导入的帐户当你

20380
27:54:15.964 --> 27:54:21.100
切换帐户时，我们会刷新页面为地址70。

20381
27:54:21.100 --> 27:54:21.200
6.

20382
27:54:21.200 --> 27:54:23.307
弹出Submit Metamask。

20383
27:54:23.307 --> 27:54:24.816
给予许可是的。

20384
27:54:24.816 --> 27:54:29.245
好了，现在是时候列出你现在有一支笔了。

20385
27:54:29.245 --> 27:54:30.938
本地主机列表项。

20386
27:54:31.100 --> 27:54:32.366
我们可以看到所有的数据和一切。

20387
27:54:33.100 --> 27:54:35.994
并确认非功能性清单好的，好的。

20388
27:54:35.994 --> 27:54:36.432
好的。

20389
27:54:36.432 --> 27:54:36.870
好的。

20390
27:54:38.100 --> 27:54:38.310
好。

20391
27:54:41.100 --> 27:54:41.438
节点。

20392
27:54:46.100 --> 27:54:49.433
我的点j的破折号网络，本地主机。

20393
27:54:51.100 --> 27:54:52.166
那两个街区。

20394
27:54:55.100 --> 27:54:57.836
给它一点新鲜感。

20395
27:54:57.836 --> 27:54:59.730
转到活动项目。

20396
27:55:01.100 --> 27:55:03.132
有一个新项为0。

20397
27:55:03.132 --> 27:55:03.525
6容易的。

20398
27:55:03.525 --> 27:55:04.574
在我们的数据库中。

20399
27:55:05.100 --> 27:55:05.927
棒极了。

20400
27:55:09.100 --> 27:55:12.033
现在让我们再来做一个。

20401
27:55:13.100 --> 27:55:14.854
第二个，看看它是否真的有效。

20402
27:55:15.100 --> 27:55:16.306
令牌ID为8。

20403
27:55:16.306 --> 27:55:18.374
让我们抓住这个地址。

20404
27:55:20.100 --> 27:55:20.800
刷新。

20405
27:55:20.800 --> 27:55:23.700
将此粘贴到令牌ID 8中。

20406
27:55:23.700 --> 27:55:24.800
我们用0。

20407
27:55:24.800 --> 27:55:25.100
999.

20408
27:55:26.100 --> 27:55:26.861
提交。

20409
27:55:26.861 --> 27:55:29.273
我们会批准的。

20410
27:55:29.273 --> 27:55:29.780
是的。

20411
27:55:29.780 --> 27:55:32.192
那我们就把它寄出去。

20412
27:55:32.192 --> 27:55:32.699
是的。

20413
27:55:34.100 --> 27:55:35.287
现在我们去挖两个街区的矿。

20414
27:55:36.100 --> 27:55:40.553
上去再回去矿就会跑矿，搬块。

20415
27:55:41.100 --> 27:55:41.568
太好了。

20416
27:55:47.100 --> 27:55:53.990
现在列出来了，我们有原来的那个，我们有刚才列出来的两个8和0的7。

20417
27:55:53.990 --> 27:55:54.536
6和0。

20418
27:55:54.536 --> 27:55:54.770
999.

20419
27:55:54.770 --> 27:55:57.100
在我们的非ft市场上上市。

20420
27:55:57.100 --> 27:55:58.433
这太令人兴奋了。

20421
27:55:58.433 --> 27:56:00.792
我们的列表运行正常。

20422
27:56:00.792 --> 27:56:09.680
现在，由于这节课已经非常长了，我决定删掉这部分，然后把它删掉一点，因为我们并没有学到什么新东西。

20423
27:56:09.680 --> 27:56:14.379
然而，请随时回到与分数相关的每一个比特，

20424
27:56:14.379 --> 27:56:19.313
如果你想要实现它，我们将为你提供退出功能。

20425
27:56:19.313 --> 27:56:21.372
否则，请跳过并继续前进。

20426
27:56:21.372 --> 27:56:22.561
这是非常强大的。

20427
27:56:22.561 --> 27:56:25.734
你应该为自己感到无比兴奋。

20428
27:56:25.734 --> 27:56:27.876
如果你已经走到这一步。

20429
27:56:27.876 --> 27:56:29.145
这太棒了。

20430
27:56:29.145 --> 27:56:37.034
你只是做了一个去中心化的市场，然后在它上面建立了一个前端，允许任何人与你的市场进行交互。

20431
27:56:37.100 --> 27:56:37.700
很容易。

20432
27:56:37.700 --> 27:56:38.800
巨大的,巨大的。

20433
27:56:38.800 --> 27:56:40.900
祝贺你在这里。

20434
27:56:42.100 --> 27:56:44.480
是休息和庆祝的最佳时机。

20435
27:56:45.100 --> 27:56:51.048
在推特上给我打电话，说嘿，帕特里克，我刚刚完成了非ft市场。

20436
27:56:51.100 --> 27:57:00.084
全栈前端是免费代码营课程的一部分，我现在知道如何在我的智能合约应用程序之上构建全栈前端。

20437
27:57:00.084 --> 27:57:03.300
要对自己充满信心，因为这太棒了。

20438
27:57:03.300 --> 27:57:08.996
我无法低估我有多兴奋，你已经走到这一步，你正在学习和使用大量的技

20439
27:57:08.996 --> 27:57:14.693
术，可靠的智能合约，前端你正在做完整的堆栈你在这里做了很多东西。

20440
27:57:14.693 --> 27:57:16.889
所以你应该为自己感到骄傲。

20441
27:57:16.889 --> 27:57:21.755
恭喜你，一定要给自己一个表扬。

20442
27:57:21.755 --> 27:57:26.993
然后准备继续我们的下一部分。

20443
27:57:27.100 --> 27:57:35.755
现在我们已经使用我们的Morales后端完成了所有这些工作，我将对您进行切换，而不是用一个集中的服务器索引我们所有的事件。

20444
27:57:35.755 --> 27:57:41.610
现在我们要学习如何用图表来构建这个，这是一个去中心

20445
27:57:41.610 --> 27:57:47.700
化的事件索引器我们可以使用，很多代码都是完全一样的。

20446
27:57:47.700 --> 27:57:54.884
所以我们不需要重新开始，我们要做的是，首先我们可以关闭所有本地的东西，

20447
27:57:54.884 --> 27:58:02.274
我们可以关闭所有这些东西，我们最终可以关闭所有的终端，这真的很令人兴奋。

20448
27:58:02.274 --> 27:58:08.944
在这个文件夹中，我们要做的是将所有内容复制到一个新文件夹中。

20449
27:58:08.944 --> 27:58:14.782
我将向下CD一个目录，我们将新建一个名为next Jas的目录。

20450
27:58:14.782 --> 27:58:22.671
如果T市场，这个图表，虚线FCC，以及这部分的所有代码都将在这里

20451
27:58:22.671 --> 27:58:30.561
用于前端的图表索引器我们将需要进行另一个回购我们稍后会讲到这个。

20452
27:58:30.561 --> 27:58:33.290
所有的变化，都在这一部分。

20453
27:58:33.290 --> 27:58:40.269
我们要做的是创建这个新文件夹，复制破折号R。

20454
27:58:40.269 --> 27:58:46.890
接下来，Jas和ft市场FCC变成下一个Jas非ft。

20455
27:58:46.890 --> 27:58:50.809
市场，图表FCC。

20456
27:58:51.100 --> 27:58:59.286
我们要递归地复制，所有在那个文件夹里的东西我们刚创建到这个新文件夹里我们要做很多调整。

20457
27:58:59.286 --> 27:59:04.800
这个可能要花点时间因为这个文件夹里有很多东西。

20458
27:59:04.800 --> 27:59:10.712
好的，一旦我们完成了这些，我们就可以进入下一个Jas和ft

20459
27:59:10.712 --> 27:59:16.625
市场，FCC图，做代码周期，在一个新的代码编辑器中打开它。

20460
27:59:16.625 --> 27:59:20.772
或者像往常一样，你可以用File Open folder来打开它。

20461
27:59:20.772 --> 27:59:26.657
现在我们在这里，我们要学习如何做这个完全相同的项目，而不是使用mirallas。

20462
27:59:26.657 --> 27:59:32.410
但是使用这个图表，我们首先要做的一件事是我们实际上要把合约部署到溜冰场B。

20463
27:59:32.410 --> 27:59:40.690
所以我们要抓住我们的市场，那个灵魂，把它停下来，我们要抓住我们的硬帽市场。灵魂项目，把它停下来。

20464
27:59:40.690 --> 27:59:43.521
首先，我们要在rink v上运行部署脚本。

20465
27:59:43.521 --> 27:59:50.477
希望你已经正确地设置了所有的部署，这样所有的参数都能正确地通过。

20466
27:59:50.477 --> 27:59:57.300
所以我们要继续这个故事，戴上安全帽部署破折号网络。

20467
27:59:57.300 --> 28:00:00.427
并确保它对林克比有效。

20468
28:00:00.427 --> 28:00:02.366
让我们检查一下我们的安全帽配置。

20469
28:00:02.366 --> 28:00:06.845
对于网络，我把Rigby的东西放在这里了。

20470
28:00:06.845 --> 28:00:10.576
好的，我有我的RPC URL，我从环境变量中获取它。

20471
28:00:10.576 --> 28:00:17.913
如果我有一个私钥，我有一个私钥，我也从环境变量中获得，我有一个链ID块确认和保存部署。

20472
28:00:17.913 --> 28:00:19.489
让我们继续运行这个。

20473
28:00:19.489 --> 28:00:24.336
现在我们将继续，将非ft市场部署到Rigby网络。

20474
28:00:24.336 --> 28:00:27.964
我们的部署脚本也有一个ID进行验证。

20475
28:00:27.964 --> 28:00:34.427
我们也可以验证这一点，如果你不部署一个溜冰场就不能跟着这一节走。

20476
28:00:34.427 --> 28:00:40.358
所以部署到B级，或者在第15课中推荐的任何测试网，然后从那里开始。

20477
28:00:40.358 --> 28:00:42.995
很好，我们已经部署了NFC市场。

20478
28:00:43.100 --> 28:00:45.591
现在我们要继续部署我们的基本非ft。

20479
28:00:46.100 --> 28:00:50.450
部署完成后，我们可以开始更新前端代码，以使用图而不是mirallas。

20480
28:00:50.450 --> 28:00:53.100
好了，我们已经核实过了，一切都很正常。

20481
28:00:53.100 --> 28:00:55.411
现在我们要验证基本的非ft。

20482
28:00:55.411 --> 28:00:57.181
我们已经核实过了。

20483
28:00:57.181 --> 28:00:57.705
太棒了。

20484
28:00:57.705 --> 28:01:03.453
现在我们在P环上部署了一个非功能性市场，在B环上部署了一个基本的非功能性市场。

20485
28:01:03.453 --> 28:01:05.299
这两个都得到了验证。

20486
28:01:05.299 --> 28:01:11.854
所以一定要注意这些，因为我们在学习图形部分的时候会用到它们。

20487
28:01:11.854 --> 28:01:17.035
现在让我们抓取名为next Jas and ft marketplace的代码编辑器，即图表。

20488
28:01:17.100 --> 28:01:18.410
让我们开始吧。

20489
28:01:21.100 --> 28:01:24.683
但是我们忘记在这里添加一些代码来更新我们的网络映射。

20490
28:01:24.683 --> 28:01:32.994
但是，如果我们回去，打开代码，下一个Jas NFT市场，FCC，在这里的网络映

20491
28:01:32.994 --> 28:01:41.305
射中会有一个新的B溜冰场条目，如果我们做得正确，让我们复制这个网络映射并粘贴到

20492
28:01:41.305 --> 28:01:50.043
我们的网络中，我们的下一个GS和ft市场，图表部分，或者你可以手动添加你的新条目。

20493
28:01:50.100 --> 28:01:50.412
正确的。

20494
28:01:53.100 --> 28:01:53.640
市场。

20495
28:01:56.100 --> 28:01:59.709
我们要删除这个云功能。

20496
28:01:59.709 --> 28:02:06.155
再见，因为既然我们不再使用服务器，就不会有任何云功能或任何后端要运行。

20497
28:02:06.155 --> 28:02:08.423
所以我们要把它移到垃圾再见。

20498
28:02:08.423 --> 28:02:15.666
接下来，我们不再需要FRP了，因为我们不需要把我们的本地区块链连接到图上，我们只需要使用这里的测试网。

20499
28:02:15.666 --> 28:02:17.821
我们把它删掉。

20500
28:02:17.821 --> 28:02:22.253
再见，接下来是什么，还有我们的app。j。s。

20501
28:02:22.253 --> 28:02:30.803
现在我们像这样连接到一个Morales提供者，我们将把它切换回去在Mount上启动盟友，

20502
28:02:30.803 --> 28:02:39.548
这将返回为false，我们不再像这样连接到我们的Morales数据库，我们将再次使用钩子。

20503
28:02:39.548 --> 28:02:42.942
现在唯一要改变的是指数。

20504
28:02:42.942 --> 28:02:43.047
js。

20505
28:02:43.047 --> 28:02:44.638
现在，在我们的指数中。

20506
28:02:44.638 --> 28:02:50.884
js中，我们从Morales查询中获取NF TS的列表。

20507
28:02:51.100 --> 28:02:53.893
我们要改变这个，让我们更新自述文件。

20508
28:02:54.100 --> 28:03:01.782
我们不会从ralis读取事件，我们会首先用图表索引它们。

20509
28:03:01.782 --> 28:03:04.050
然后我们从图中读出。

20510
28:03:04.050 --> 28:03:08.877
问题是，图像是什么。

20511
28:03:09.100 --> 28:03:13.600
因此，这个图形将是一个分散的层，用于存储事件数据。

20512
28:03:13.600 --> 28:03:17.338
所以有了所有这些区块链和所有这些不同的存储网络。

20513
28:03:17.338 --> 28:03:22.290
这个图是，这个图是一个不同节点的网络，从区块链中读取数据并

20514
28:03:22.290 --> 28:03:27.242
建立索引，它为我们提供了一个API来调用我们可以读取数据。

20515
28:03:27.242 --> 28:03:28.099
而不仅仅是我自己。

20516
28:03:28.099 --> 28:03:32.053
我们跟阿伯特聊过了，他比我更能解释清楚。

20517
28:03:32.100 --> 28:03:32.957
和在。

20518
28:03:33.100 --> 28:03:39.046
首先，我要感谢帕特里克创建了这么棒的教育资源，并邀请我成为其中的一员。

20519
28:03:39.100 --> 28:03:40.237
我叫Nadia dabit。

20520
28:03:42.100 --> 28:03:42.946
处理图表。

20521
28:03:44.100 --> 28:03:52.510
对去中心化网络，如Aetherium IPFS，数十个其他EVM兼容网络，以及近未来宇宙和索拉纳的查询协议。

20522
28:03:52.510 --> 28:03:59.736
使用图，开发人员可以构建和发布称为子图的开放API，然后在他们的应用程序中使用这些子图来

20523
28:03:59.736 --> 28:04:06.962
实现对存储在这些网络上的数据更好的查询功能，包括过滤、排序、关系数据和全堆栈搜索等功能。

20524
28:04:06.962 --> 28:04:14.074
子图位于区块链和UI之间，提供了一个重要的软件基础设施，一个灵活的性能

20525
28:04:14.074 --> 28:04:21.186
和分散的API层，以及传统技术堆栈数据库，服务器和API的查询过滤器，

20526
28:04:21.186 --> 28:04:28.503
排序分页组和连接数据之前返回到应用程序，通常通过某种类型的HTTP请求。

20527
28:04:28.503 --> 28:04:34.950
当直接从Aetherium或其他区块链读取数据时，这些类型的数据转换是不可能的。

20528
28:04:34.950 --> 28:04:39.217
在图表团队必须开发和操作专有索引服务器之前。

20529
28:04:39.217 --> 28:04:45.199
这需要大量的工程和硬件资源，打破了去中心化所需的重要安全原则，我们

20530
28:04:45.199 --> 28:04:51.363
如何与区块链交互并在其上构建，这与我们在传统技术栈中习惯的非常不同。

20531
28:04:51.363 --> 28:04:59.890
在区块链中，数据不是以可以轻松或有效地使用或直接从其他应用程序或前端检索的格式存储的。

20532
28:04:59.890 --> 28:05:03.663
问题是，您需要为数据建立索引并进行组织，以便进行有效的检索。

20533
28:05:03.663 --> 28:05:09.053
传统上，这是数据库和网络服务器在这个集中式技术栈中所做的工作。

20534
28:05:09.053 --> 28:05:12.134
但是在索引层，在web三栈中是缺失的。

20535
28:05:12.134 --> 28:05:16.051
让我们来看看现实世界中的其他几个索引示例。

20536
28:05:16.101 --> 28:05:23.464
像谷歌这样的搜索引擎抓取互联网索引相关数据，使用户可以通过他们的web界面和其他API进行搜索。

20537
28:05:23.464 --> 28:05:29.493
如果没有这个索引层，我们就很难知道在哪里以及如何在网络上找到相关信息。

20538
28:05:29.493 --> 28:05:31.601
另一个类似的类比是图书馆。

20539
28:05:31.601 --> 28:05:36.808
使用像杜威十进制系统这样的索引系统，我们知道在哪里找到

20540
28:05:36.808 --> 28:05:42.016
我们要找的书，而不必一本书一本书地在整个图书馆里寻找。

20541
28:05:42.016 --> 28:05:49.522
该图表每天为许多不同类型的web三应用程序提供超过20亿次查询，包括挑战游戏和FC领域的应用程序。

20542
28:05:49.522 --> 28:05:53.331
在深入研究任何代码之前，让我们看看如何构建子图。

20543
28:05:53.331 --> 28:05:55.269
首先，你要看图表。

20544
28:05:55.269 --> 28:05:58.810
Com，并创建一个新的子图和图形用户界面。

20545
28:05:58.810 --> 28:06:06.825
然后，您可以使用图CLI构建一个空子图样板，然后用您自己的契约信息更新该样板。

20546
28:06:06.825 --> 28:06:15.726
在子图配置中，您将定义数据模型、网络、契约地址和其他特定于您想要索引的数据的配置。

20547
28:06:15.726 --> 28:06:23.624
对于我们的数据模型，我们使用Graph QL，一种定义顶级类型以及这些类型中的字段的模式定义语言。

20548
28:06:23.624 --> 28:06:32.360
当我们准备好部署子图，以便开始测试它并在应用程序中使用它时，我们可以使用运行deploy命令的图形CLI。

20549
28:06:32.360 --> 28:06:40.592
一旦部署了子图并开始为数据建立索引，我们就可以在图形指示板中直接使用图形界面对其进行测试。

20550
28:06:40.592 --> 28:06:48.726
当我们准备好开始quering时，我们的应用程序的子图，我们可以使用图提供给我们的API URL，以及任何graph QL查询。

20551
28:06:48.726 --> 28:06:53.691
如果你想了解更多关于这张图的信息，请查看这张图。

20552
28:06:53.691 --> 28:06:57.863
com以及Graph Protocol、Twitter、Graph上的文档。

20553
28:06:57.863 --> 28:07:00.998
或我们的Discord在图表中。

20554
28:07:00.998 --> 28:07:02.527
谢谢很重要。

20555
28:07:02.527 --> 28:07:07.851
现在我们对这个图有了更好的了解，我们就可以开始用它来构建了。

20556
28:07:07.851 --> 28:07:14.132
如果我们试着运行这个应用，它显然会失败，因为index。

20557
28:07:14.132 --> 28:07:18.757
Js，现在从mirallas而不是从图中读取。

20558
28:07:18.757 --> 28:07:23.397
就像自述文件里说的，我们要做的第一件事是我们要

20559
28:07:23.397 --> 28:07:28.038
从图中建立索引，然后我们就可以从图中读取数据。

20560
28:07:28.101 --> 28:07:30.632
让我们继续学习如何构建子图。

20561
28:07:31.101 --> 28:07:37.810
为了让图形网络开始索引合同中的事件，我们需要用到图形。

20562
28:07:37.810 --> 28:07:39.810
Com，我们要讲产品。

20563
28:07:39.810 --> 28:07:47.951
我们要去子图工作室，如果你去产品，你首先看到的是图资源管理器，这些都是已经存在的子图。

20564
28:07:47.951 --> 28:07:56.258
如果你仔细看这里，你会看到很多非常流行的去中心化协议都有不同的子图，托管服务会在某个时刻停止。

20565
28:07:56.258 --> 28:07:57.346
我们跳过这里。

20566
28:07:57.346 --> 28:08:04.051
让我们进入子图工作室，这将帮助我们为其他节点创建子图，开始为我们的事件索引。

20567
28:08:04.051 --> 28:08:07.549
我们要把钱包和meta mask连接起来。

20568
28:08:07.549 --> 28:08:15.914
我要在这里选择账号1，下一个连接，我们要关掉Hardhead。

20569
28:08:15.914 --> 28:08:19.981
本地，转到林克比测试网络。

20570
28:08:19.981 --> 28:08:21.859
然后转到账户1。

20571
28:08:21.859 --> 28:08:27.413
我们会得到一个签名请求从图表汇总到我们刚刚建立的网站。

20572
28:08:27.413 --> 28:08:32.469
子图网站有一些签名功能，后端有一个数据库。

20573
28:08:32.469 --> 28:08:36.377
我们在现实生活中看到的，正是我们刚刚使用的方法。

20574
28:08:36.377 --> 28:08:40.901
所以他们没有和莫拉莱斯签约，而是在这里有自己的定制标识。

20575
28:08:40.901 --> 28:08:45.050
我们要登录，这样图形网站就可以和我们互动了。

20576
28:08:45.050 --> 28:08:47.412
我们可以输入我们的邮箱。

20577
28:08:47.412 --> 28:08:49.248
我要跳过了。

20578
28:08:49.248 --> 28:08:57.101
你甚至会在这里得到一个小通知说，只有索引Aetherium或main net或Rigby的子图可以在子图工作室中创建。

20579
28:08:57.101 --> 28:08:59.767
我们来创建一个子图。

20580
28:08:59.767 --> 28:09:05.871
所以我们要选一个铈里格比子图的名字是NFT市场。

20581
28:09:05.871 --> 28:09:07.969
我们继续并点击Continue。

20582
28:09:08.101 --> 28:09:11.378
这将是我们创建子图的仪表盘。

20583
28:09:11.378 --> 28:09:15.933
这里有大量的说明和文档我们可以查看，我将把这些

20584
28:09:15.933 --> 28:09:20.488
文档添加到与这门课程相关的GitHub回购中。

20585
28:09:20.488 --> 28:09:25.351
所以这个非ft市场子图需要它自己的git仓库。

20586
28:09:25.351 --> 28:09:34.157
这里我们要做的是CD向下，创建一个新目录，命名为graph。

20587
28:09:34.157 --> 28:09:39.375
如果T市场，FCC，我们也会开放它。

20588
28:09:39.375 --> 28:09:44.590
代码图NFT，市场FCC，或者文件开放接枝代码

20589
28:09:44.590 --> 28:09:50.033
市场FCC，在这个窗口中，我们将构建我们的子图。

20590
28:09:50.101 --> 28:09:54.083
在本地，我们会构建子图并把它推到子图工作室。

20591
28:09:54.083 --> 28:09:59.429
在这里，有一大堆指导我们可以按照指导进行安装。

20592
28:09:59.429 --> 28:10:03.543
我们需要做的第一件事是安装图形命令行接口。

20593
28:10:03.543 --> 28:10:05.969
我们想要在全球范围内安装这个。

20594
28:10:06.101 --> 28:10:08.396
我把这部分复制过来。

20595
28:10:10.101 --> 28:10:13.133
纱线，全球广告，然后粘贴进去。

20596
28:10:15.101 --> 28:10:21.574
这将帮助我们建立一个图表，并为图表建立指令，从而为我们的事件建立索引。

20597
28:10:21.574 --> 28:10:26.037
既然已经安装了全局变量，我们就可以初始化图形代码了。

20598
28:10:26.101 --> 28:10:28.036
所以我们可以复制这条线。

20599
28:10:31.101 --> 28:10:33.423
然后按回车键。

20600
28:10:35.101 --> 28:10:37.184
为Aetherium，或子图。

20601
28:10:37.184 --> 28:10:38.600
鼻涕虫将非ft。

20602
28:10:38.600 --> 28:10:39.600
市场。

20603
28:10:40.101 --> 28:10:43.825
希望目录在这里，但它说目录已经存在。

20604
28:10:43.825 --> 28:10:45.790
所以我们只给它非ft市场。

20605
28:10:45.790 --> 28:10:47.481
然后我们把它移到后面。

20606
28:10:47.481 --> 28:10:48.766
这是在林克比球场上。

20607
28:10:48.766 --> 28:10:49.288
测试网络。

20608
28:10:49.288 --> 28:10:52.288
现在我们要给它合同地址。

20609
28:10:52.288 --> 28:10:55.201
我们想获取刚刚部署的地址。

20610
28:10:55.201 --> 28:10:57.519
它现在应该在我们的网络映射中。

20611
28:10:57.519 --> 28:11:04.019
我们会抓取刚刚部署的合约地址，并粘贴到这里。

20612
28:11:04.101 --> 28:11:04.694
像这样。

20613
28:11:09.101 --> 28:11:15.434
自动从以太扫描中为我们抓取ABI，我们给它一个合约名，这就是非金融市场。

20614
28:11:15.434 --> 28:11:21.101
它会在这个非ft市场目录中给我们一大堆样板代码。

20615
28:11:21.101 --> 28:11:23.005
这可能要花几分钟。

20616
28:11:23.101 --> 28:11:23.901
好的,太棒了。

20617
28:11:26.101 --> 28:11:28.767
在非ft市场创建的市场。

20618
28:11:30.101 --> 28:11:31.051
它应该在卖家文件夹里。

20619
28:11:32.101 --> 28:11:37.287
往下移动一个目录，但你也可以把它留在原来的地方，如果你

20620
28:11:37.287 --> 28:11:42.473
想的话，我要说移动，我要说移动非ft市场，星号为。/。

20621
28:11:42.473 --> 28:11:47.051
现在NFT市场中的所有内容都将在当前目录中。

20622
28:11:47.101 --> 28:11:49.151
然后如果市场空了。

20623
28:11:50.101 --> 28:11:51.372
继续删除。

20624
28:11:51.372 --> 28:11:52.541
如果市场。

20625
28:11:53.101 --> 28:11:53.445
太好了。

20626
28:11:57.101 --> 28:11:59.687
这是我们刚创建的文件。

20627
28:12:00.101 --> 28:12:01.751
第一个文件夹是API的。

20628
28:12:03.101 --> 28:12:08.197
索引并读取我们的契约索引我们的事件，它需要我们的事件的ABI。

20629
28:12:08.197 --> 28:12:13.887
我们有整个市场的ABI，从以太扫描，如果我们没有验证以太扫描，我

20630
28:12:13.887 --> 28:12:19.577
们可以自己创建这个API文件夹，并在这里添加非ft市场JSON。

20631
28:12:19.577 --> 28:12:21.669
现在我们有了这个生成的文件夹。

20632
28:12:21.669 --> 28:12:23.394
这是一个自动生成的文件。

20633
28:12:23.394 --> 28:12:26.609
他甚至在顶部说，不要直接编辑这个文件。

20634
28:12:26.609 --> 28:12:32.621
你可以把它看作构建文件夹，或者我们编译图形代码的地方。

20635
28:12:32.621 --> 28:12:36.038
节点模块，当然是节点模块和依赖项。

20636
28:12:36.038 --> 28:12:43.593
SRC将是我们定义和告诉图形，如何映射以及如何使用契约的地方。

20637
28:12:43.593 --> 28:12:45.316
它是一个TypeScript文件。

20638
28:12:45.316 --> 28:12:53.051
对于所有刚刚用JavaScript做过这个的人，我将会教你们一些TypeScript来完成这一部分。

20639
28:12:53.101 --> 28:12:59.553
然后是network。JSON，它提供了所有网络信息关于哪个网络，地址是什么，以及我们要索

20640
28:12:59.553 --> 28:13:06.005
引的不同契约是什么，package。JSON，当然只是一个普通的package。JSON。

20641
28:13:06.005 --> 28:13:10.458
它有一些已经内置在schema。graph中的图形脚本。

20642
28:13:10.458 --> 28:13:13.101
QL将是我们的Graph QL模式。

20643
28:13:13.101 --> 28:13:19.054
这也是我们告诉图形如何处理事件和索引事件的方式。

20644
28:13:19.101 --> 28:13:22.501
如果您熟悉的话，该模式遵循Graph QL语法。

20645
28:13:22.501 --> 28:13:28.527
如果你之前用过Graph QL，它会是完全一样的，图。

20646
28:13:28.527 --> 28:13:30.755
QL是API的查询语言。

20647
28:13:30.755 --> 28:13:39.726
它不是一种关系数据库，它可以以一种更图形的方式进行查询，我不打算深入讨论它的幕后工作原理。

20648
28:13:39.726 --> 28:13:48.545
但如果你想了解更多，我会在GitHub存储库中留下一些与这门课程相关的文档，子图。Yamo告诉子图如何将所有文件组合在一起。

20649
28:13:48.545 --> 28:13:54.154
我们有数据源，它们来自不同的地址，不同的实体或事件，

20650
28:13:54.154 --> 28:14:00.196
API从不同的事件处理程序中获取文件，我们一会儿会讲到。

20651
28:14:00.196 --> 28:14:02.910
然后是主文件，也就是我们的映射。

20652
28:14:02.910 --> 28:14:07.455
ts，我们有一个ts配置，这是一个TypeScript特定的配置文件。

20653
28:14:07.455 --> 28:14:09.815
当然，我们还有纱线点锁。

20654
28:14:09.815 --> 28:14:18.513
有了所有这些信息和所有这些代码，我们现在要更新所有这些代码来告诉图形开始为我们的事件建立索引。

20655
28:14:18.513 --> 28:14:24.721
因此，我们可以在分散的上下文中从图中读取事件，而不是从集中的数据库中。

20656
28:14:24.721 --> 28:14:29.593
在我们构建完所有东西之后，我们将运行这个并部署代码，这

20657
28:14:29.593 --> 28:14:34.646
是为了验证我们自己，然后将我们的代码部署到图中开始索引。

20658
28:14:34.646 --> 28:14:37.208
废话不多说，让我们开始吧。

20659
28:14:37.208 --> 28:14:38.315
我们来做这个。

20660
28:14:38.315 --> 28:14:43.837
首先我要做的是，为这些。Graph QL文件添加一个高亮显示。

20661
28:14:43.837 --> 28:14:46.767
在扩展中，我们会看到Graph QL。

20662
28:14:46.767 --> 28:14:50.600
我们会拖延这个Graph QL扩展。

20663
28:14:50.600 --> 28:14:56.658
现在我们已经安装了它，如果我们回到schema。graph, QL，我们现在有了一些颜色，这是令人兴奋的。

20664
28:14:56.658 --> 28:15:05.391
所以这个模式点图QL将定义我们的契约中有什么实体如果我们要类似mirallas。

20665
28:15:05.391 --> 28:15:08.529
这就是我们如何定义表格的样子。

20666
28:15:08.529 --> 28:15:09.850
这些就是我们的事件。

20667
28:15:09.850 --> 28:15:12.592
加上我们创建的活动项目表。

20668
28:15:12.592 --> 28:15:18.834
我们不会有一个实体示例，我们会有一个类型活动项。

20669
28:15:18.834 --> 28:15:21.367
这将是一个加法实体。

20670
28:15:21.367 --> 28:15:26.204
这些是我们在图中可以查询的不同类型，我们要

20671
28:15:26.204 --> 28:15:31.273
查询的主要内容和之前一样，它是我们的活动项。

20672
28:15:31.273 --> 28:15:36.353
然后在活动项目内部，我们会告诉图形，每个活

20673
28:15:36.353 --> 28:15:41.434
动项目类型有什么参数，它将有一个ID类型。

20674
28:15:41.434 --> 28:15:43.394
变量是ID类型的ID。

20675
28:15:43.394 --> 28:15:47.524
你可以在图表文档中阅读更多关于不同类型的信息。

20676
28:15:47.524 --> 28:15:51.354
这个感叹号意味着它一定有一个ID。

20677
28:15:51.354 --> 28:15:59.966
所以每个活动物品都需要并且将会有一个ID，我们说将会有一个买家，这将是一个地址，这

20678
28:15:59.966 --> 28:16:08.790
将是一个字节买家可以是空的，对吧?它可以是0x000，所有的活动项目都有0000点。

20679
28:16:08.790 --> 28:16:08.962
如果。

20680
28:16:08.962 --> 28:16:14.203
如果还没有人买，我们就会有一个卖家，这当然也会是一

20681
28:16:14.203 --> 28:16:19.445
个字节因为它将是一个地址，我们会有一个非ft地址。

20682
28:16:19.445 --> 28:16:25.406
NFT的地址，也将是字节，我们将有一个令牌ID，它不会是字节，这

20683
28:16:25.406 --> 28:16:31.367
将是大int类型的，然后我们将有一个价格，它也将是一个大int。

20684
28:16:31.367 --> 28:16:37.008
现在我们不需要price，我们让price为可空。

20685
28:16:37.008 --> 28:16:38.300
所以价格可以为零。

20686
28:16:38.300 --> 28:16:39.789
所以我们有一个活动项目。

20687
28:16:39.789 --> 28:16:40.182
太棒了。

20688
28:16:40.182 --> 28:16:46.236
我们还需要什么?我们在莫拉莱斯还有什么别的桌子?我们需要列出类型item。

20689
28:16:46.236 --> 28:16:52.640
这将是实体需要一个ID，它将有一个卖家。

20690
28:16:52.640 --> 28:16:57.901
无论什么时候一件商品被列出，它都会有一个销售权，也就是一个字节。

20691
28:16:57.901 --> 28:17:04.613
如果地址NFT的地址，也将是字节，令牌ID，

20692
28:17:04.613 --> 28:17:14.986
也将是一个大int，然后是价格，也将是一个大end，我们将需要一个类

20693
28:17:14.986 --> 28:17:23.835
将需要一个类型项取消在实体它将有一个ID seller一个NFT地址。

20694
28:17:23.835 --> 28:17:29.301
令牌ID将是一个重要的结尾。

20695
28:17:29.301 --> 28:17:37.963
最后一种类型的商品将在实体中有一个ID ID。

20696
28:17:37.963 --> 28:17:42.767
它将是一个买家字节。

20697
28:17:43.101 --> 28:17:48.553
然后是T地址的一个字节和一个令

20698
28:17:48.553 --> 28:17:54.006
牌ID，然后是一个开始的价格。

20699
28:17:54.006 --> 28:17:59.185
在Justice Information中，我们定义了子图想要

20700
28:17:59.185 --> 28:18:04.364
跟踪的东西想要跟踪物品购买事件，物品，取消事件，物品列出事件。

20701
28:18:04.364 --> 28:18:09.846
然后我们将创建这个新的活动项目表类似于mirallas。

20702
28:18:09.846 --> 28:18:13.522
它是其他三个事件的函数。

20703
28:18:13.522 --> 28:18:16.679
现在我们完成了模式点图。

20704
28:18:16.679 --> 28:18:16.889
QL。

20705
28:18:17.101 --> 28:18:17.445
太棒了。

20706
28:18:20.101 --> 28:18:22.870
子图来监听这些事件。

20707
28:18:24.101 --> 28:18:30.601
我们要告诉它如何监听这些事件，我们会去到src mapping。

20708
28:18:30.601 --> 28:18:30.801
ts。

20709
28:18:30.801 --> 28:18:32.601
就是这个映射。

20710
28:18:32.601 --> 28:18:40.051
Ts文件会告诉子图如何映射以及如何存储所有的事件信息。

20711
28:18:40.101 --> 28:18:43.901
如果你现在看它，它甚至可能给你一个例子事件。

20712
28:18:43.901 --> 28:18:46.967
它说Export function, handle item event。

20713
28:18:47.101 --> 28:18:51.101
这是Maya现在说的，它作为一个输入参数事件项目机器人。

20714
28:18:51.101 --> 28:18:58.133
也就是说，当一个项目bot事件发生时，执行这个处理项目bot函数。

20715
28:18:58.133 --> 28:19:01.101
每当item bot发生时，这个就处理item bot。

20716
28:19:01.101 --> 28:19:08.684
我们实际上从我们生成的非ft市场中从一些生成的代码中得到这个项目机器人。

20717
28:19:08.684 --> 28:19:09.767
在图中。

20718
28:19:09.767 --> 28:19:11.850
如果我们运行图形代码Gen。

20719
28:19:12.101 --> 28:19:19.783
这个图代码Gen命令获取我们在模式点graph QL中的所有东西，并将其放入这个生成的文件中。

20720
28:19:19.783 --> 28:19:25.862
现在我运行了图形代码Gen，你会看到这里有一个项目机器人类，有一个模式，类型脚本。

20721
28:19:25.862 --> 28:19:32.628
我们甚至可以找到我们在模式中创建的新活动项类。

20722
28:19:32.628 --> 28:19:40.379
每当你更新schema。Graph QL时，你总是需要运行Graph代码Gen，这样你就能更新那些类型。

20723
28:19:40.379 --> 28:19:43.720
如果失败了，这意味着您在模式点图QL中搞砸了一些东西。

20724
28:19:43.720 --> 28:19:45.497
现在在我们的映射中。

20725
28:19:45.497 --> 28:19:50.274
Ts，我们实际上是导入商品购买商品取消商

20726
28:19:50.274 --> 28:19:55.291
品从生成的和如果市场如果市场从生成的代码。

20727
28:19:55.291 --> 28:19:56.901
这些是我们的事件。

20728
28:19:56.901 --> 28:19:59.901
我们不需要在非功能性市场上做任何事情。

20729
28:19:59.901 --> 28:20:01.624
我们只需要我们的事件信息。

20730
28:20:01.624 --> 28:20:02.004
现在。

20731
28:20:02.004 --> 28:20:09.020
我们删掉句柄项目bot里面的所有东西不管样本是什么。

20732
28:20:09.101 --> 28:20:12.762
我们从生成的代码中导入事件。

20733
28:20:13.101 --> 28:20:16.406
然后是这条线，我们马上要改变它。

20734
28:20:16.406 --> 28:20:21.491
同样，我们有这三个函数处理物品购买，处理物品取消和处理物品列出。

20735
28:20:21.491 --> 28:20:25.049
每当我们得到一个物品购买事件，我们就会执行这个函数。

20736
28:20:25.101 --> 28:20:27.778
每当我们得到一个项目取消事件，我们就会用这个函数。

20737
28:20:27.778 --> 28:20:32.304
所有这些代码都定义在子图。Yamo中。

20738
28:20:32.304 --> 28:20:38.204
您可以在列出的bot项目和事件处理程序中看到不同的实体。

20739
28:20:38.204 --> 28:20:44.688
它说，无论何时这个特定事件触发一个索引地址，一个索引地址索引，

20740
28:20:44.688 --> 28:20:52.846
YouTube中的YouTube 36有6个调用句柄项目买了，这里是句柄项目。

20741
28:20:52.846 --> 28:20:55.354
这就是它的工作原理。

20742
28:20:55.354 --> 28:20:59.773
那么让我们来看看当购买事件触发时该怎么做。

20743
28:20:59.773 --> 28:21:04.434
我觉得买的，取消的清单有点让人困惑。

20744
28:21:04.434 --> 28:21:11.573
所以我想把这个改成，买的东西是买的东西，取消

20745
28:21:11.573 --> 28:21:18.713
的东西是取消的东西，列出的东西是列出的东西。

20746
28:21:18.713 --> 28:21:25.490
所以我只是改变了这三个从NFT市场进口的名称。

20747
28:21:25.490 --> 28:21:29.649
现在我要把事件，item bot，改成，item bought，事件。

20748
28:21:29.649 --> 28:21:34.197
取消的事件项目到取消的事件和列出的事件项目到列出的事件。

20749
28:21:34.197 --> 28:21:34.971
好了,好了。

20750
28:21:34.971 --> 28:21:37.649
现在我们把这条线去掉。

20751
28:21:37.649 --> 28:21:42.295
一开始我们也不需要顶部的这一行，等下会用到，但现在先把它删掉。

20752
28:21:42.295 --> 28:21:44.682
这是我们的极简代码。

20753
28:21:44.682 --> 28:21:51.308
当我们列出一个项目时，我们需要做什么?我们需要把这个事件保存到图中。

20754
28:21:51.308 --> 28:21:56.628
然后我们还需要更新活动项，就像我们对莫拉莱斯所做的一样。

20755
28:21:56.628 --> 28:22:01.786
首先我们需要做的是获取或创建一个item列表对象。

20756
28:22:01.786 --> 28:22:06.211
我们需要知道的是每件物品都需要一个唯一的ID。

20757
28:22:06.211 --> 28:22:09.205
我们需要创建那个ID。

20758
28:22:09.205 --> 28:22:17.085
我要做的第一件事是创建一个函数叫Get ID from event params。

20759
28:22:17.085 --> 28:22:21.239
它需要一个令牌ID这就是TypeScript发挥作用的地方。

20760
28:22:21.239 --> 28:22:25.546
在TypeScript中，我们实际上需要定义不同形参的类型。

20761
28:22:25.546 --> 28:22:28.211
令牌ID是一个大int。

20762
28:22:28.211 --> 28:22:33.462
我们还会取一个非ft地址，它会取一种地址类型。

20763
28:22:33.462 --> 28:22:42.387
我们还需要说明返回类型或函数会给出什么，我们会返回一个字符串，我们会从事件参数创建一个ID。

20764
28:22:42.387 --> 28:22:46.157
它将是令牌ID和NFT地址的组合。

20765
28:22:46.157 --> 28:22:51.467
这两者的组合将为每种类型的事件提供唯一的ID。

20766
28:22:51.467 --> 28:22:56.874
我们会说，返回令牌ID，令牌ID有一个函数，

20767
28:22:56.874 --> 28:23:02.528
叫做xstring，我要说，加上，如果T地址。

20768
28:23:02.528 --> 28:23:04.292
到X字符串，像这样。

20769
28:23:04.292 --> 28:23:09.786
和大int地址，我们需要导入at图形协议斜杠图形TX。

20770
28:23:09.786 --> 28:23:11.731
它对我来说已经足够大了。

20771
28:23:11.731 --> 28:23:16.456
所以我要在这里添加地址是来自图的两种特殊类型。

20772
28:23:16.456 --> 28:23:18.118
字符串被内置到TypeScript中。

20773
28:23:18.118 --> 28:23:22.681
现在我们已经有了为函数中的每个项获取特殊I

20774
28:23:22.681 --> 28:23:27.244
D的方法，现在我们必须获取或创建一个新项。

20775
28:23:27.244 --> 28:23:29.624
现在我们有一个项目。

20776
28:23:29.624 --> 28:23:33.139
但是如果我们没有购买物品。

20777
28:23:33.139 --> 28:23:39.789
物品购买对象将是我们保存的东西，物品购买事件只是原始事件。

20778
28:23:39.789 --> 28:23:44.339
我们需要从itembought事件中创建一个itembought对象。

20779
28:23:44.339 --> 28:23:47.944
在TypeScript中，这是两种不同的类型。

20780
28:23:47.944 --> 28:23:50.456
我们需要按对象导入这些项。

20781
28:23:50.456 --> 28:23:54.168
这些是从生成的模式中自动创建的。

20782
28:23:54.168 --> 28:24:01.789
在这里我们有活动道具，道具，道具购买类别，道具取消等等。

20783
28:24:01.789 --> 28:24:04.363
我们需要从这里导入这些类型。

20784
28:24:04.363 --> 28:24:11.017
我们可以说，导入，项目列表，逗号，活动项目，

20785
28:24:11.017 --> 28:24:17.067
项目购买项目取消从。斜杠，生成斜杠模式。

20786
28:24:17.067 --> 28:24:21.602
让我们继续，获取或创建一个项目机器人对象。

20787
28:24:21.602 --> 28:24:26.888
我们写入let item bot = item bot。load。

20788
28:24:26.888 --> 28:24:32.679
这就是我们加载一个项目的方式我们加载它的唯一ID通过调用这个getid from

20789
28:24:32.679 --> 28:24:39.050
event params。load, getid from event params。

20790
28:24:39.050 --> 28:24:44.166
我们可以传递event。params。

20791
28:24:44.166 --> 28:24:51.495
那个令牌ID因为一个项目bot事件会有一个令牌ID和一个params事件。

20792
28:24:51.495 --> 28:24:52.478
nf T地址。

20793
28:24:52.478 --> 28:24:58.429
我知道我们可能应该先处理itemlists但我们先处理itembot。

20794
28:24:58.429 --> 28:25:05.305
既然我们买了一个物品，我们可能也会有一个活动物品，对吧?我们还没有列出一个项目。

20795
28:25:05.305 --> 28:25:07.553
这和我们对莫拉莱斯的处理是类似的。

20796
28:25:07.553 --> 28:25:13.462
所以我们知道，每当我们活着的时候，某些项目也会列出一个活动项目。

20797
28:25:13.462 --> 28:25:18.502
我们说，let激活项目等于加载的激活项目。

20798
28:25:18.502 --> 28:25:21.429
我们要做同样的事情。

20799
28:25:21.429 --> 28:25:24.379
我要复制粘贴到这里。

20800
28:25:24.379 --> 28:25:31.779
即使这些有完全相同的ID，也没关系因为它们在不同类型中是相同的ID。

20801
28:25:31.779 --> 28:25:35.692
现在我们会说，如果没有item bot，

20802
28:25:35.692 --> 28:25:41.368
我们会说item bot =一个新的item bot对象。

20803
28:25:41.368 --> 28:25:46.062
我们会给它一个ID，也就是我们这里的ID赋

20804
28:25:46.062 --> 28:25:50.757
值参数，从事件中获取ID，然后传递给那里。

20805
28:25:50.757 --> 28:25:53.183
我们要在这里创建一个新的物品。

20806
28:25:53.183 --> 28:25:55.816
现在我们要更新所有的参数。

20807
28:25:55.816 --> 28:25:58.387
回到我们的模式点图QL。

20808
28:25:58.387 --> 28:26:02.446
购买的物品有ID、买家地址、令牌ID和价格。

20809
28:26:02.446 --> 28:26:05.526
我们会说，itembought,

20810
28:26:05.526 --> 28:26:13.035
buyer等于event。params。buyer, itembought。

20811
28:26:13.035 --> 28:26:16.368
T地址等于事件。

20812
28:26:16.368 --> 28:26:17.168
参数个数。

20813
28:26:17.168 --> 28:26:25.482
nf T地址，项目bot，点token ID =事件点params点token ID。

20814
28:26:25.482 --> 28:26:26.434
看起来不错。

20815
28:26:26.434 --> 28:26:34.164
我们的活动物品将来自于被列出的物品，被列出的物品会给它所有这些参数，除了它不会有买家。

20816
28:26:34.164 --> 28:26:37.924
所以我们只需要向买家更新我们的活动物品。

20817
28:26:37.924 --> 28:26:42.390
我们写上active item，点buyer，加上一个感叹号。

20818
28:26:42.390 --> 28:26:45.502
这是一些TypeScript的东西，表示我们将有一个活动项。

20819
28:26:45.502 --> 28:26:47.932
如果你不熟悉TypeScript，不要太担心。

20820
28:26:47.932 --> 28:26:52.312
我们说它等于event。params。buyer。

20821
28:26:52.312 --> 28:26:56.822
和Morales类似，我们会做item bot。

20822
28:26:56.822 --> 28:27:06.972
save和带感叹号的活动item，也就是保存这就是我们将item bought事件保存为图形协议对象的方式。

20823
28:27:06.972 --> 28:27:09.382
同时，我们会更新活动项。

20824
28:27:09.382 --> 28:27:12.960
这是我们处理商品购买的完整功能。

20825
28:27:13.102 --> 28:27:19.377
每当有人买了一件物品，我们就更新一个新的物品购买对象，我们将活动物品更新为

20826
28:27:19.377 --> 28:27:25.823
一个新的买家，我们不会从活动物品列表中删除它，我们只会用一个新的买家更新它。

20827
28:27:25.823 --> 28:27:29.102
我们会说如果它有买家，那就意味着它被买了。

20828
28:27:29.102 --> 28:27:32.987
如果没有买家，那就意味着它还在市场上。

20829
28:27:32.987 --> 28:27:33.511
太棒了。

20830
28:27:33.511 --> 28:27:41.049
现在我们已经完成了handle item bot，下面来做我们列出的handle item，这将使我们的handle item bot更容易理解。

20831
28:27:41.049 --> 28:27:44.315
对于handle itemlists，我们会在这里做相同的部分。

20832
28:27:44.315 --> 28:27:50.020
我们说，let itemlists = itemlists。load。

20833
28:27:50.020 --> 28:27:56.932
我们会做和所有这些完全一样的事情从事件params中获取ID。

20834
28:27:56.932 --> 28:27:59.495
像这样，获取一个不同的事件参数。

20835
28:27:59.495 --> 28:28:01.855
然后我们说，让激活项目。

20836
28:28:01.855 --> 28:28:05.659
这条线和上面这条线是一样的。

20837
28:28:05.659 --> 28:28:07.829
我只需要复制粘贴。

20838
28:28:07.829 --> 28:28:14.983
我们说，很好，抓取我们列出的项目，抓取我们的活动项目，看那些对象是否已经存在。

20839
28:28:14.983 --> 28:28:20.053
我会说如果没有item被列出，这是不应该的，我们会创建一个新的，

20840
28:28:20.053 --> 28:28:24.966
我们说item lists = new item lists。

20841
28:28:24.966 --> 28:28:30.702
它的ID将来自我们创建的这个函数是唯一的ID。

20842
28:28:30.702 --> 28:28:36.272
现在，不像我们上面做的那样，我们还会说，如果没有活动项目，那么我们将创建一

20843
28:28:36.272 --> 28:28:41.843
个新的活动项目，对吧?因为我们列出了一个项目，所以它不应该是一个活动项目。

20844
28:28:41.843 --> 28:28:48.610
现在这个功能在这里更有意义了，对吧?因为如果我们更新一个商品的价格，活动商品将已经存在。

20845
28:28:48.610 --> 28:28:52.835
但是，如果它是一个全新的列表，活动项目将不存在。

20846
28:28:52.835 --> 28:28:58.038
我们会说，如果它不存在，这意味着它是一个全新的列表，我们会说item

20847
28:28:58.038 --> 28:29:03.548
lists = new item lists，然后我们会给它一个ID。

20848
28:29:03.548 --> 28:29:07.655
这是相同的ID方法，粘贴进去。

20849
28:29:07.655 --> 28:29:11.911
现在我们要做的就是更新这些新对象。

20850
28:29:11.911 --> 28:29:18.625
我写上item lists, seller = event。params。seller。

20851
28:29:18.625 --> 28:29:21.002
复制粘贴这一行。

20852
28:29:21.002 --> 28:29:24.836
因为这将是active item。seller。

20853
28:29:24.836 --> 28:29:28.456
哦，看到我，然后它就会变成这个活动项目。

20854
28:29:28.456 --> 28:29:30.714
活动项目而不是列出的项目。

20855
28:29:30.714 --> 28:29:38.018
列出的项目还包括什么?好了，让我们转到列出的具有非ft地址、令牌ID和价格的模式项。

20856
28:29:38.102 --> 28:29:41.477
好，我们把它们加起来。

20857
28:29:45.102 --> 28:29:46.213
=事件。

20858
28:29:46.213 --> 28:29:46.768
参数个数。

20859
28:29:46.768 --> 28:29:47.879
nf T地址。

20860
28:29:50.102 --> 28:29:54.711
因为它对活动项是完全一样的。

20861
28:29:55.102 --> 28:30:01.990
项目列出token ID = event。params。token ID。

20862
28:30:02.102 --> 28:30:03.640
复制粘贴这一行。

20863
28:30:03.640 --> 28:30:05.716
活动项目也是一样。

20864
28:30:07.102 --> 28:30:13.741
在价格，复制，粘贴这一行活动项目。

20865
28:30:13.741 --> 28:30:16.281
然后我们就说这两个。

20866
28:30:16.281 --> 28:30:20.835
保存活动项目的项目列表。

20867
28:30:20.835 --> 28:30:21.501
保存。

20868
28:30:21.501 --> 28:30:30.132
在我们的协议中，如果它已经是，如果已经有一个活动项，那么我们就继续，我们得到那个活动项。

20869
28:30:30.132 --> 28:30:32.964
这将是一个清单，我们正在更新。

20870
28:30:32.964 --> 28:30:34.757
如果没有，我们就做一个新的。

20871
28:30:34.757 --> 28:30:37.472
我们用通过事件传入的信息更新它。

20872
28:30:37.472 --> 28:30:39.972
然后我们把它保存到我们的图形协议中。

20873
28:30:39.972 --> 28:30:40.875
好的,完美的。

20874
28:30:40.875 --> 28:30:43.302
现在我们只剩下一个了，项目取消了。

20875
28:30:43.302 --> 28:30:48.052
我们来看看如何取消商品，这看起来和购买商品很像。

20876
28:30:48.102 --> 28:30:54.992
我们说，let item cancelled = item cancelled that load。

20877
28:30:55.102 --> 28:31:01.811
同样，我们会做相同的Id get我们会做所有的事情，我们会说，let active

20878
28:31:01.811 --> 28:31:09.340
item =，我把它缩小一点active item = active item。load。

20879
28:31:09.340 --> 28:31:12.482
或者做同样的事情。

20880
28:31:12.482 --> 28:31:12.958
繁荣。

20881
28:31:12.958 --> 28:31:17.924
然后我们会说，if not item cancelled，这是

20882
28:31:17.924 --> 28:31:23.052
不应该的因为这应该是这里唯一的item cancelled事件。

20883
28:31:23.102 --> 28:31:28.860
我们说item cancelled，等于new item cancelled。

20884
28:31:30.102 --> 28:31:33.343
用我们用过的相同的ID方法给它一个ID。

20885
28:31:33.343 --> 28:31:35.713
现在这个看起来有点不同。

20886
28:31:35.713 --> 28:31:42.136
我们会说item cancelled，那个seller等于event。params。seller。

20887
28:31:42.136 --> 28:31:43.791
到目前为止，一切顺利。

20888
28:31:43.791 --> 28:31:49.864
项目取消的。NFT地址=事件。params。NFT地址项目取消

20889
28:31:49.864 --> 28:31:55.938
的。token ID =事件。params。token ID。

20890
28:31:55.938 --> 28:32:01.118
最后，我们要改变活动项与我们之前看到的稍微不同。

20891
28:32:01.118 --> 28:32:06.387
活动项目感叹号，如果你被那个点买家搞糊涂了，就忽略它。

20892
28:32:06.387 --> 28:32:12.985
我们将把buyer更新为equal address。fromstring。

20893
28:32:13.102 --> 28:32:15.843
我们会给它一个所谓的死亡地址。

20894
28:32:16.102 --> 28:32:18.690
就是这个。

20895
28:32:22.102 --> 28:32:29.494
产生718 1920 21到2到3到45到67到8930 3130

20896
28:32:29.494 --> 28:32:37.784
230-334-3536零小写d，大写E，小写A大写d，这被称为死地址。

20897
28:32:37.784 --> 28:32:42.477
这就是我们决定一件商品是否还在市场上的方法。

20898
28:32:42.477 --> 28:32:44.789
或者是否购买了某件物品。

20899
28:32:44.789 --> 28:32:49.972
如果我们有死亡地址作为买家，那就意味着物品已经被取消了。

20900
28:32:49.972 --> 28:32:56.640
这就是我们如何能够告诉一个项目是否在市场上或死亡地址意味着它被取消了。

20901
28:32:56.640 --> 28:33:01.736
空的地址，也就是句柄item所列出的情况，意味着它在市场上。

20902
28:33:01.736 --> 28:33:05.843
而真正的真实地址意味着它确实被某人买走了。

20903
28:33:05.843 --> 28:33:09.416
所以我们判断它是否在市场上的方法是，它是0x 0000000。

20904
28:33:09.416 --> 28:33:14.610
因为数据地址显然不等于全0。

20905
28:33:14.610 --> 28:33:22.380
数据地址是一种常用的地址类似于无人拥有的一次性地址，然后我们可

20906
28:33:22.380 --> 28:33:30.151
以说，项目取消保存一个活动项目说活动项目，感叹号点保存和完美。

20907
28:33:30.151 --> 28:33:32.937
我们的映射文件现在已经完成。

20908
28:33:33.102 --> 28:33:42.049
现在我们有三个不同的函数来定义如何处理物品被购买的事件、如何处理物品被取消的事件和物品列出的事件。

20909
28:33:42.049 --> 28:33:47.602
如果你不明白，记住所有的代码都可以在我的GitHub的图形部分找到。

20910
28:33:47.602 --> 28:33:51.625
所以，如果你迷路或需要帮助，你可以跟着这里的代码走。

20911
28:33:51.625 --> 28:33:58.964
有了这些，我们就差不多准备好让子图开始监听契约了，我们至少还有一件事要做。

20912
28:33:58.964 --> 28:34:03.733
在子图。Yamo中，我们会看到源地址等等等等，这

20913
28:34:03.733 --> 28:34:08.702
告诉我们开始索引Aetherium开始以来的事件。

20914
28:34:08.702 --> 28:34:14.427
现在我们不希望它这样做，因为这会花很长时间，我们想告诉我们的

20915
28:34:14.427 --> 28:34:20.152
子图，你不能从时间的开始开始，你只需要从契约被部署之前开始。

20916
28:34:20.152 --> 28:34:25.757
我们可以添加起始块告诉它开始部署的块号是多少。

20917
28:34:25.757 --> 28:34:33.091
如果我们有地址，就在这里，我们可以复制它，粘贴到溜冰场费用，以太扫描，

20918
28:34:33.091 --> 28:34:40.635
粘贴到这里，或者任何块资源管理器，我们会看到我们的合同部署的块号是多少。

20919
28:34:40.635 --> 28:34:42.977
看起来是这个街区。

20920
28:34:42.977 --> 28:34:50.031
我要复制那个地址，回到我的代码，写上起始块，它就在这里。

20921
28:34:50.102 --> 28:34:55.021
起始块是它被展开的时间，减1。

20922
28:34:55.102 --> 28:35:01.602
我们会在部署契约之前，开始读取任何被索引的事件。

20923
28:35:01.602 --> 28:35:09.919
现在，如果你部署了这个，它可能根本没有任何事件，我们马上就会解决这个问题，不要担心，但有了这个，所有

20924
28:35:09.919 --> 28:35:18.237
关于如何构建子图的指令都准备好部署到图中了，开始我们的索引，开始在去中心化的上下文中使用我们的指令。

20925
28:35:18.237 --> 28:35:25.737
我们现在能做的是回到图中，我们这里有auth和deploy代码，我们可

20926
28:35:25.737 --> 28:35:33.452
以复制这个，这个图auth破折号studio，这是关于如何部署的部署键。

20927
28:35:33.452 --> 28:35:35.502
我们可以在代码编辑器中运行它。

20928
28:35:35.502 --> 28:35:40.216
粘贴到这里，绘制dash studio，回车。

20929
28:35:40.216 --> 28:35:43.347
我们会说，这个图的部署键集。

20930
28:35:43.347 --> 28:35:52.053
这只是设置以便我们在推送代码时，它会推送到我们在他们网站上做的子图配置来帮助我们自动部署。

20931
28:35:52.102 --> 28:35:58.418
现在我们不需要输入子图，因为我们已经把东西往下移动了，我们会构建子图，

20932
28:35:58.418 --> 28:36:07.983
我们会运行图代码Gen，我们可以运行图kojem，这将确保我们的schema。graph QL看起来很好。

20933
28:36:07.983 --> 28:36:10.966
然后我们要运行我们的图表构建。

20934
28:36:11.102 --> 28:36:18.802
这个图构建命令会编译并运行所有子图的东西，所有映射JSON的东西所有生成的代码。

20935
28:36:18.802 --> 28:36:24.392
它会把这个放到一个真正的构建文件夹中，生成的文件夹有点像一个伪构建文件夹。

20936
28:36:24.392 --> 28:36:26.182
然后我们有一个真正的构建文件夹。

20937
28:36:26.182 --> 28:36:29.584
生成的是为TypeScript构建一些类型。

20938
28:36:29.584 --> 28:36:35.721
这个构建文件夹，这个真正的构建文件夹，是我们要部署并发送到图中的东西。

20939
28:36:35.721 --> 28:36:38.387
我们可以展开子图。

20940
28:36:38.387 --> 28:36:40.798
现在，使用图形部署dash的studio。

20941
28:36:40.798 --> 28:36:48.856
如果市场，也就是我们现在要运行的，会给我们一个版本标签选项，我们会给它0。

20942
28:36:48.856 --> 28:36:53.612
零点一，因为这是我们的第一个版本，它会继续并开始

20943
28:36:53.612 --> 28:36:58.568
将它部署到图中，我们也会上传我们的子图到IPFS。

20944
28:36:58.568 --> 28:37:03.508
我们在这里有一个小哈希是IPFS的子图我们可以看一下。

20945
28:37:03.508 --> 28:37:07.515
但如果你成功了，我们就完成了这个构建。

20946
28:37:07.515 --> 28:37:11.512
我们有这些用于查询和订阅的子图端点。

20947
28:37:11.512 --> 28:37:16.031
我们可以开始查询和订阅子图。

20948
28:37:16.102 --> 28:37:23.784
回到我们的网站，点击刷新，我们可以看到状态部署，我们可以看到我们正在下沉。

20949
28:37:23.784 --> 28:37:30.479
现在我们有一些节点在监听我们要在这里发出的事件，这非常令人兴奋。

20950
28:37:30.479 --> 28:37:32.892
我们可以查看日志，看看是否出了什么问题。

20951
28:37:32.892 --> 28:37:35.263
现在它只是在索引，在监听。

20952
28:37:35.263 --> 28:37:39.829
它正在通过区块链的所有不同区块，监听我们的事件。

20953
28:37:39.829 --> 28:37:45.235
然后我们在这里有一个游乐场，在那里我们可以运行一些查询，从我们的Graph

20954
28:37:45.235 --> 28:37:51.373
QL中查看不同的事件和不同的响应，现在，它是完全空白的，因为我们还没有做任何事情。

20955
28:37:51.373 --> 28:37:58.808
所以，再一次，让我们拿出我们的安全帽和ft市场代码，或在一个新的终端打开它，无论你想做什么。

20956
28:37:58.808 --> 28:38:02.898
让我们继续，让我们运行mminton列表脚本。

20957
28:38:02.898 --> 28:38:06.999
但对于溜冰场B，我们会做yarn, hard hat, run

20958
28:38:06.999 --> 28:38:12.292
scripts, mint，和列表项dash network Rinkeby。

20959
28:38:12.292 --> 28:38:19.610
所以我们要创造一个NFT，对吧，这是一个交易，所以我们要等一会儿，然后我们要批准NFT。

20960
28:38:19.610 --> 28:38:21.566
然后我们会把它上市。

20961
28:38:21.566 --> 28:38:25.135
一旦它被列出，它就会发出一个itemlists事件。

20962
28:38:25.135 --> 28:38:30.610
现在我们应该看到，在Graph QL中有一个活动项和一个列出数据的项。

20963
28:38:30.610 --> 28:38:36.803
现在您可以了解更多关于左边所看到的是所谓的Graph QL查询。

20964
28:38:36.803 --> 28:38:41.055
现在，我们不打算讲如何做这些，但我会在GitHub存储库中留下一些链接。

20965
28:38:41.055 --> 28:38:45.323
如果你想学习如何做更多这样的查询，这些将与我们在莫拉莱斯中看到的类似。

20966
28:38:45.323 --> 28:38:48.189
但它们不是常规的表查找。

20967
28:38:48.189 --> 28:38:56.056
它们是Graph QL语法的，我们的查询结果，在这里，我们可以看到更多关于模式的信息一直到右边。

20968
28:38:56.103 --> 28:39:02.769
但是如果我们看看我们的代码，现在，我们已经获得了NFT的批准我们已经在我们的市场上上市了。

20969
28:39:02.769 --> 28:39:07.067
现在如果我们回到这个图表，我们运行这个查询，

20970
28:39:07.067 --> 28:39:14.492
我们在我们的非ft市场上做一点刷新，我们可能要等几分钟图表才能索引这些新块。

20971
28:39:14.492 --> 28:39:18.199
但是在我们的操场上，我们应该把show看作一个查询。

20972
28:39:18.199 --> 28:39:24.465
如果你没有自动得到这些你可以暂停视频把这些写进你的Graph QL游

20973
28:39:24.465 --> 28:39:30.916
乐场，对吧?所以几分钟后，刷新以太扫描，我可以看到列表项交易已经通过。

20974
28:39:30.916 --> 28:39:33.424
这意味着我们已经触发了一个新事件。

20975
28:39:33.424 --> 28:39:40.040
如果我回到操场，点击这里的play，天哪，我们可以看到活动项目。

20976
28:39:40.040 --> 28:39:41.977
我们看到我们列出了项目。

20977
28:39:42.103 --> 28:39:43.149
这太棒了。

20978
28:39:46.103 --> 28:39:51.093
一个链下服务，它为我们的合同索引我们的事件，这样我们就

20979
28:39:51.093 --> 28:39:56.083
可以更新我们的前端，我们可以以去中心化的方式更新人员。

20980
28:39:56.083 --> 28:39:58.828
这太令人兴奋了。

20981
28:39:59.103 --> 28:40:07.656
太棒了，现在我们都设置好了，我们终于可以回到我们的下一个JS项目或下一个Jas非ft市场FCC图。

20982
28:40:07.656 --> 28:40:12.971
我们这么做的原因是，在我们的下一个Jas非ft Marketplace应用

20983
28:40:12.971 --> 28:40:18.431
程序的代码库中，我们正在从Morales数据库中读取数据，我们将不再这样做。

20984
28:40:18.431 --> 28:40:23.517
我们不从莫拉莱斯数据库中读取数据，而是从图中读取数据，我们

20985
28:40:23.517 --> 28:40:28.780
来学习一下如何更新代码index。j, s来从图中读取数据。

20986
28:40:28.780 --> 28:40:36.275
为了突出显示这个，我们要创建一个新页面，一个新文件，我们将它命名为graph example。j s。

20987
28:40:36.275 --> 28:40:42.822
我们会让这个页面变得非常简洁来展示如何进行图形查询。

20988
28:40:42.822 --> 28:40:49.585
类似于index。j, s，我们要做一个导出默认图形的例子。

20989
28:40:49.585 --> 28:40:54.551
这是一个函数，或者默认函数，图的例子。

20990
28:40:54.551 --> 28:40:58.349
我们将使用阿波罗客户端工具，复制粘贴过来。

20991
28:40:58.349 --> 28:41:04.201
我们将用纱线添加它，在P O ll O添加破折号dev，斜

20992
28:41:04.201 --> 28:41:10.053
杠，客户端，不好意思，不是dev，因为我们在前端需要这个。

20993
28:41:10.053 --> 28:41:12.686
所以纱线添加在阿波罗斜杠客户端。

20994
28:41:12.686 --> 28:41:18.636
哦，抱歉，我们还需要做yarn，添加Graph QL，我们需要添加这两个。

20995
28:41:18.636 --> 28:41:24.740
这是Apollo斜杠客户端，我们将通过它对新创建的图表进行查询。

20996
28:41:24.740 --> 28:41:24.998
QL。

20997
28:41:24.998 --> 28:41:29.636
我们会说，从这个刚刚安装的包导入use

20998
28:41:29.636 --> 28:41:35.496
query hook从P O ll O客户端。

20999
28:41:35.496 --> 28:41:37.709
我们还会导入gql。

21000
28:41:37.709 --> 28:41:46.436
要创建一个新查询，我们说const, get active item = gql。

21001
28:41:46.436 --> 28:41:48.969
我们在这里加上这个反勾。

21002
28:41:48.969 --> 28:41:54.516
我们会把所有的Graph QL的东西都加进去，这和这个是等价的，这是Graph QL。

21003
28:41:54.516 --> 28:41:54.878
语法。

21004
28:41:54.878 --> 28:41:59.136
我们将把这个Graph QL语法放到我们的代码库中。

21005
28:41:59.136 --> 28:42:01.723
但我们只想得到活性项。

21006
28:42:01.723 --> 28:42:10.660
那么我们如何得到活性物质呢?我们可以先把它建在操场上，然后把它添加到代码库中。

21007
28:42:10.660 --> 28:42:18.847
我们会说我们想要抓取活动物品，我们会抓取前5个，

21008
28:42:18.847 --> 28:42:27.035
然后我们会说买家的位置是0x 12345678。

21009
28:42:27.035 --> 28:42:29.627
我们说的是买家是空的。

21010
28:42:29.627 --> 28:42:35.613
我们抓取没有买家的活动物品，然后我们

21011
28:42:35.613 --> 28:42:41.266
会然后我们会得到ID，买家，卖家，

21012
28:42:41.266 --> 28:42:47.918
非ft地址，代币，ID和从中得到的价格。

21013
28:42:47.918 --> 28:42:52.730
如果我们点击运行，我们在这里得到活动项。

21014
28:42:52.730 --> 28:42:57.863
这里，买家是0x12345678

21015
28:42:57.863 --> 28:43:02.997
因为没有买家时，它会被默认为0。

21016
28:43:02.997 --> 28:43:07.119
这就是为什么取消项目，我们更新买家的死亡地址。

21017
28:43:07.119 --> 28:43:09.321
如果它被买了，它就不再活跃了。

21018
28:43:09.321 --> 28:43:12.568
如果它被取消，它也将不再活跃。

21019
28:43:12.568 --> 28:43:17.134
现在，我们可以复制这个查询并将其粘贴到代码中。

21020
28:43:17.134 --> 28:43:22.189
现在我们有了一个可以用于图形示例的Graph QL查询。

21021
28:43:22.189 --> 28:43:25.945
在我们的图形示例中，我们将使用这个查询和这个使用查询钩子。

21022
28:43:25.945 --> 28:43:29.748
在export default函数，图的例子中，我们可以说const。

21023
28:43:29.748 --> 28:43:37.540
它附带了一大堆东西，比如加载错误，然后返回的数据等于，使用查询。

21024
28:43:37.540 --> 28:43:46.264
然后我们会传递这个Get active item，或者Get active items，我们在上面加个S, Get active items。

21025
28:43:46.264 --> 28:43:50.909
然后我们可以返回一个小div。

21026
28:43:51.103 --> 28:43:54.737
在div中输入hi，然后输入console。log data。

21027
28:43:54.737 --> 28:43:57.752
然后回到我们的应用程序。

21028
28:43:57.752 --> 28:44:04.103
js中，我们将所有内容包装到Morales提供程序中，我们还需要将所有内容包装到Apollo提供程序中。

21029
28:44:04.103 --> 28:44:12.769
我们需要初始化它类似于初始化连接到士气服务器的方式，但我们要初始化连接到Graph QL。

21030
28:44:12.769 --> 28:44:19.997
我们会说导入一个po ll O提供者，一个po ll O

21031
28:44:19.997 --> 28:44:27.225
客户端，在内存中，缓存来自po ll O斜杠客户端，像这

21032
28:44:27.225 --> 28:44:34.971
样，然后我们需要初始化这个，这样我们就可以删除士气这些东西。

21033
28:44:34.971 --> 28:44:41.819
我们通过写上const client = new a P O LL来初始化这个客户机。

21034
28:44:41.819 --> 28:44:44.837
O客户端，我们会在这里给它参数。

21035
28:44:44.837 --> 28:44:53.313
你们可以在阿波罗客户端文档中找到这些会说，当我们进行刷新等操作时，会有一个缓存

21036
28:44:53.313 --> 28:45:01.790
来帮助我们在内存缓存中写入new，我们会写入逗号URI，一个我们要连接的地方。

21037
28:45:01.790 --> 28:45:04.796
这就是我们要为子图添加API的地方。

21038
28:45:04.796 --> 28:45:10.121
如果我们回到细节，我们可以看到临时查询URL这是一个速率限制的

21039
28:45:10.121 --> 28:45:15.619
临时查询，因为这只是一个测试网，我们要复制这个，回到我们的代码。

21040
28:45:15.619 --> 28:45:16.941
我们把它粘贴到这里。

21041
28:45:16.941 --> 28:45:23.534
不管你有什么临时查询URL，还有你的子图形工作室，这就是你要粘贴到这里的地方。

21042
28:45:23.534 --> 28:45:28.436
现在，这个客户机告诉我们的Graph QL，它应该在哪里执行这些查询。

21043
28:45:28.436 --> 28:45:29.959
我们会走到这里的。

21044
28:45:29.959 --> 28:45:31.441
这要从HTTPS说起。

21045
28:45:31.441 --> 28:45:37.295
这是中心化的吗?是的，因为我们直接调用了图形网站。

21046
28:45:37.295 --> 28:45:42.835
然而，所有的数据仍然会存储在这个分散的图索引器中。

21047
28:45:42.835 --> 28:45:51.436
类似于我们对IPFS所做的，我们把它作为一个入口，让我们更容易连接和从图形工作室读取数据。

21048
28:45:51.436 --> 28:45:57.362
然而，在未来，随着更多的协议和浏览器采用图和IPFS，

21049
28:45:57.362 --> 28:46:04.166
这在Morales提供程序内部会变得容易得多，但在通知提供程序

21050
28:46:04.166 --> 28:46:10.971
程序外部，我们会说P O ll O提供程序，然后客户端等于客户端。

21051
28:46:11.103 --> 28:46:17.103
然后我们复制结束标签，把它放在通知提供程序周围，然后按Save。

21052
28:46:17.103 --> 28:46:19.944
现在我要拯救我们的前端，现在我们要试着跑我们的前端。

21053
28:46:19.944 --> 28:46:23.040
我们得改变一下这里的一些东西因为它要崩溃了。

21054
28:46:23.040 --> 28:46:26.711
所以我们要运行纱线Dev，为新前端。

21055
28:46:26.711 --> 28:46:28.817
我们会到本地主机3000。

21056
28:46:28.817 --> 28:46:32.864
它会完全崩溃的，因为我们这里还有一些鼓舞士气的东西。

21057
28:46:32.864 --> 28:46:34.053
这完全没问题。

21058
28:46:34.053 --> 28:46:36.490
当然，我们不需要一个运行的硬帽节点。

21059
28:46:36.490 --> 28:46:41.348
因为我们在一个测试网上，我们不需要和莫拉莱斯同步，我们不需要做任何那些事情。

21060
28:46:41.348 --> 28:46:45.995
因为我们正在使用一个测试网，现在，它实际上没有崩溃，这很好。

21061
28:46:45.995 --> 28:46:48.430
但它显然没有显示最近上市。

21062
28:46:48.430 --> 28:46:55.275
我们现在要做的是斜杠，图形例子，然后回车。

21063
28:46:55.275 --> 28:46:57.740
我们可以看到嗨，出现。

21064
28:46:57.740 --> 28:47:05.945
但如果我们去检查，我们去控制台，这里有一个控制台，我们可以看到一个活动物

21065
28:47:05.945 --> 28:47:14.150
品的对象，它从图中返回，有买家ID，非ft，地址价格，所有这些都在空中。

21066
28:47:14.150 --> 28:47:15.007
这太棒了。

21067
28:47:15.103 --> 28:47:15.955
好吧，好吧。

21068
28:47:15.955 --> 28:47:16.282
好的。

21069
28:47:19.103 --> 28:47:19.545
更新。

21070
28:47:19.545 --> 28:47:21.561
让我们继续，我们将关闭服务器。

21071
28:47:22.103 --> 28:47:27.941
我们要做的是更新，而不是使用mirallas query，我们要删除这个。

21072
28:47:27.941 --> 28:47:31.070
我们将从Apollo查询从Graph QL查询。

21073
28:47:31.070 --> 28:47:39.909
其他的都保持不变，对吧?因为我们的非ft框，以及我们使用过的所有其他代码，仍然会完全相同地工作。

21074
28:47:39.909 --> 28:47:41.401
首先，我们得找到我们的地址。

21075
28:47:41.401 --> 28:47:47.803
我们会说导入，和Sell一样，Sell NFT，导入网络映射，我要复制它。

21076
28:47:47.803 --> 28:47:51.857
我们将从常量导入network mapping network mapping。JSON。

21077
28:47:51.857 --> 28:47:54.695
现在我们可以说const。

21078
28:47:54.695 --> 28:48:02.665
集市，地址等于，我们会用完全相同的方式，把非ft卖给，我们会抓取这一行，获取链

21079
28:48:02.665 --> 28:48:10.636
字符串，我们会把它粘贴到这里，这意味着我们需要从用户Morales获取链ID。

21080
28:48:10.636 --> 28:48:13.922
然后我们要像这样得到市场地址。

21081
28:48:13.922 --> 28:48:16.524
我们复制这一行，粘贴到这里。

21082
28:48:16.524 --> 28:48:17.155
好了,好了。

21083
28:48:17.155 --> 28:48:19.769
现在我们有了市场地址。

21084
28:48:19.769 --> 28:48:22.926
现在我们要做const。

21085
28:48:23.103 --> 28:48:27.167
加载错误数据，我们可以列出。

21086
28:48:29.103 --> 28:48:34.245
等于，使用查询，我们可以获取活动项。

21087
28:48:35.103 --> 28:48:41.062
我要做的是创建一个新文件和常量，我们要在新文件中传递get active

21088
28:48:41.062 --> 28:48:47.022
items这个东西，我们叫它subgraph queries。j s。

21089
28:48:47.103 --> 28:48:51.303
然后这里，我们会输入gql。

21090
28:48:53.103 --> 28:48:54.526
降低客户端。

21091
28:49:00.103 --> 28:49:01.151
g QL反勾。

21092
28:49:05.103 --> 28:49:09.699
回到图的例子，我们复制粘贴到这里的整行。

21093
28:49:09.699 --> 28:49:15.703
现在我们只需要export default，获取活动项。

21094
28:49:15.703 --> 28:49:22.960
我们将把这个查询从子图查询导入到索引。js中。

21095
28:49:22.960 --> 28:49:28.734
我们会说，import, get active queries are

21096
28:49:28.734 --> 28:49:34.838
skimming apt get active items from。。

21097
28:49:34.838 --> 28:49:42.103
现在在我们的use查询中将传递Get活动项，它应该返回列出的NF t。

21098
28:49:42.103 --> 28:49:47.658
现在，我们把这个从获取列出的nft变成

21099
28:49:47.658 --> 28:49:53.214
加载，加载，或者我们没有列出的nft。

21100
28:49:53.214 --> 28:49:59.178
如果它在加载，或者我们没有监听TS然后执行加载，否则，

21101
28:49:59.178 --> 28:50:05.364
我们会做另一个映射，但Graph QL的返回会有点不同。

21102
28:50:05.364 --> 28:50:10.293
不列出MTS。map，而是列出NF T。AQ

21103
28:50:10.293 --> 28:50:15.447
两个有物品，点映射和f T，然后我们得到价格。

21104
28:50:15.447 --> 28:50:21.603
如果地址令牌ID，我们不会得到市场地址，但我们会从NFT得到卖家。

21105
28:50:21.603 --> 28:50:24.136
它不会返回属性。

21106
28:50:24.136 --> 28:50:26.764
我们可以用console。log NFT代替。

21107
28:50:26.764 --> 28:50:32.413
然后我们就像之前一样，把所有的东西，正常地传递到非ft框。

21108
28:50:32.413 --> 28:50:38.914
我们我们做的一切都是真的,我们这里换掉查询方法,价格将会从价格价格是查

21109
28:50:38.914 --> 28:50:45.415
询,和英国《金融时报》的地址将会从查询令牌ID从查询市场地址,这也是会

21110
28:50:45.415 --> 28:50:51.918
略有不同,我们会得到从我们自己的配置卖方将从查询,然后关键是要从查询。

21111
28:50:51.918 --> 28:50:59.978
现在如果我们保存它，如果我们用yarn Dev重新启动我们的网站，回到我们的主页，我

21112
28:50:59.978 --> 28:51:08.038
们应该会看到一切都是一样的，除了图片是从图表中提取的，而不是从Alice那里提取的。

21113
28:51:08.103 --> 28:51:12.395
让我们回到我们的前端，我们给它一个很好的刷新，关闭控制台。

21114
28:51:12.395 --> 28:51:14.179
我们将进入我们的主页。

21115
28:51:14.179 --> 28:51:16.824
我忘了使用查询。

21116
28:51:16.824 --> 28:51:24.361
我们从Paulo斜杠客户端导入使用查询。

21117
28:51:24.361 --> 28:51:28.884
保存一下，返回来刷新一下。

21118
28:51:28.884 --> 28:51:33.275
哦，天哪，我们现在更新了，

21119
28:51:33.275 --> 28:51:38.004
从分散的数据结构中获取事件。

21120
28:51:38.103 --> 28:51:40.085
太棒了。

21121
28:51:43.103 --> 28:51:47.817
很快地，我们在我们的非ft框中使用图像标签，我们在

21122
28:51:47.817 --> 28:51:52.531
这里使用下一个Jas的图像标签，它带有一些预处理。

21123
28:51:52.531 --> 28:51:54.287
在IPFS上使用有点困难。

21124
28:51:54.287 --> 28:51:58.182
因此，我们需要更新我们处理图像的方式，以便在IPFS上托管它。

21125
28:51:58.182 --> 28:51:59.769
但我们仍然可以这样做。

21126
28:51:59.769 --> 28:52:05.499
我们还有其他选项，比如Morales，我们甚至可以在Morales上托管我们的应用。

21127
28:52:05.499 --> 28:52:11.906
我们还可以使用for cell或Netlify等，或者其他任何传统的集中式主机服务。

21128
28:52:11.906 --> 28:52:17.836
现在，如果您愿意，我建议您更新这段代码，使其能够驻留在IPFS上。

21129
28:52:17.836 --> 28:52:20.460
这样你就有了一个端到端的去中心化。

21130
28:52:20.460 --> 28:52:29.119
如果市场首先想对这段代码做一个PR，这样它就可以成功地完全端到端托管在IPFS获胜和空为我。

21131
28:52:29.119 --> 28:52:29.506
但哇。

21132
28:52:29.506 --> 28:52:32.169
这样我们就完成了少于15的任务。

21133
28:52:32.169 --> 28:52:35.960
这绝对是一个巨大的成就。

21134
28:52:35.960 --> 28:52:42.436
如果你完成了这个，如果你理解了所有的内容，如果你已经完成了目前为止的所有内容，你应该为自己感到无比自豪。

21135
28:52:42.436 --> 28:52:48.332
因为这是我们最后一个全栈部分，我们的前端部分你现在是一个全栈怪物了。

21136
28:52:48.332 --> 28:52:52.516
恭喜你，你应该非常非常非常骄傲。

21137
28:52:52.516 --> 28:52:59.139
一定要休息一下，去喝杯咖啡，为1617和18课的最后一部分做准备。

21138
28:52:59.139 --> 28:53:01.453
这些会过得快一点。

21139
28:53:01.453 --> 28:53:06.828
我很高兴你能休息

21140
28:53:06.828 --> 28:53:12.203
一下，到时候见。

21141
28:53:13.103 --> 28:53:21.277
好了，欢迎来到第六课第十课，我们将学习更低级的代码。

21142
28:53:21.277 --> 28:53:27.296
当然，按照惯例，我们的整个GitHub存储库都位于这里。

21143
28:53:27.296 --> 28:53:30.366
另外，我们还有一个可选的视频供你观看。

21144
28:53:30.366 --> 28:53:36.553
如果你想了解更多，我们将观看一段视频来解释可升级的智能合约。

21145
28:53:36.553 --> 28:53:37.403
让我们开始吧。

21146
28:53:37.403 --> 28:53:45.052
现在我在拍完这个视频很久之后才开始编辑这个视频，这就是为什么我有胡子，所以我会时不时地插入更新一些部分。

21147
28:53:45.103 --> 28:53:47.418
在链上部署智能合约时。

21148
28:53:48.103 --> 28:53:50.857
这些智能合约是不可变的。

21149
28:53:51.103 --> 28:53:57.289
如果我告诉你它们是不可变的呢?严格来说，这是不对的。

21150
28:53:57.289 --> 28:54:00.393
然而，智能合约实际上随时都可能发生变化。

21151
28:54:00.393 --> 28:54:05.293
当人们转让代币时，当人们入股合同时，或真正执行任何类型的功能时。

21152
28:54:05.293 --> 28:54:10.293
这些智能合约必须更新它们的余额、更新它们的映射和更新它们的变量来反映这一点。

21153
28:54:10.293 --> 28:54:16.065
它们不可变的原因是逻辑本身永远不会改变，并且会永远这样在链上。

21154
28:54:16.065 --> 28:54:19.021
所以从技术上讲，是的，一旦它们被部署，它们就是不可变的。

21155
28:54:19.021 --> 28:54:25.758
这实际上是智能合约的主要好处之一，一旦我们部署了智能合约，就没有人能篡改或破坏它。

21156
28:54:25.758 --> 28:54:34.296
然而，如果我们想要升级智能合约或协议来做更多的事情，或者想要修复一些明显的bug或问题，这就会成为一个问题。

21157
28:54:34.296 --> 28:54:39.424
现在，即使我们不能改变部署到一个地址的特定代码，我们实际上可以做的比你想象的多得多。

21158
28:54:39.424 --> 28:54:44.054
在本视频中，我们将解释升级智能合约背后的不同方法。

21159
28:54:44.103 --> 28:54:49.429
然后我们将向你们展示如何使用头盔和打开齐柏林飞艇大声喊出许多齐柏林飞艇和

21160
28:54:49.429 --> 28:54:54.903
三叶虫的开放文章，它们帮助我整理了这个视频以及许多其他来源和描述中的链接。

21161
28:54:54.903 --> 28:54:56.103
让我们开始吧。

21162
28:54:56.103 --> 28:55:00.986
乍一看，你可能会想，如果你能升级智能合约，

21163
28:55:00.986 --> 28:55:06.103
那么它们就不是不可变的在某种程度上你是对的。

21164
28:55:06.103 --> 28:55:11.918
所以，在解释我们可以在这里使用的不同的哲学和模式时，我们确实需要

21165
28:55:11.918 --> 28:55:17.916
了解每一种模式的哲学和去中心化含义，因为它们都有不同的优点和缺点。

21166
28:55:17.916 --> 28:55:21.878
是的，这里的一些缺点会影响中心性。

21167
28:55:21.878 --> 28:55:22.910
所以我们要记住这一点。

21168
28:55:22.910 --> 28:55:29.923
这就是为什么在你开始部署可升级的智能合约之前，你必须先了解其中的利弊。

21169
28:55:29.923 --> 28:55:33.366
我们将讨论三种不同的方式来升级智能合约。

21170
28:55:33.366 --> 28:55:39.309
第一个是用非斜杠参数绑定的方法来升级你的智能合约，社会

21171
28:55:39.309 --> 28:55:45.252
迁移方法，然后是你可能听说过的方法，那就是代理，它有很

21172
28:55:45.252 --> 28:55:51.416
多子类，比如变形合约，透明可升级代理，和通用可升级代理。

21173
28:55:51.416 --> 28:55:56.577
我们来谈谈非升级方法，或者参数化方法，或者随便你怎么称呼它。

21174
28:55:56.577 --> 28:56:00.104
这是考虑升级智能合约的最简单方法。

21175
28:56:00.104 --> 28:56:02.530
它并没有升级我们的智能合约。

21176
28:56:02.530 --> 28:56:09.554
因为我们不能真正改变智能合约的逻辑，不管我们写了什么逻辑，我们也可以添加新的存储或状态变量。

21177
28:56:09.554 --> 28:56:11.504
所以这并不是真正的升级。

21178
28:56:11.504 --> 28:56:16.970
但升级需要考虑的是参数化，我们部署的所有逻辑都在那里，这就是

21179
28:56:16.970 --> 28:56:22.437
我们与这个函数交互的地方意味着我们有一大堆setter函数。

21180
28:56:22.437 --> 28:56:23.974
我们可以更新某些参数。

21181
28:56:23.974 --> 28:56:30.043
比如我们有一个奖励参数，每年以1%的利率发放代币。

21182
28:56:30.104 --> 28:56:34.687
也许我们有一个setter函数，它说，嘿，把这个更新为2%，或者把那个更新为4%。

21183
28:56:34.687 --> 28:56:37.416
它只是一个改变变量的setter函数。

21184
28:56:37.416 --> 28:56:41.507
这里的优点，很明显，实现起来很简单。

21185
28:56:41.507 --> 28:56:48.422
缺点是，如果你在第一次部署智能合约时，没有考虑到一些逻辑或功能，那就太糟

21186
28:56:48.422 --> 28:56:55.530
糕了，你被它困住了，你无法更新逻辑或真正更新参数化的任何东西，也就是方法。

21187
28:56:55.530 --> 28:57:02.476
另一件你需要考虑的事是谁是管理员，谁有权访问这些setter函数和这些更新函数。

21188
28:57:02.476 --> 28:57:06.290
如果是一个人，你猜怎么着，你有一个集中式智能合约。

21189
28:57:06.290 --> 28:57:10.354
当然，现在可以添加治理契约作为协议的管理契约。

21190
28:57:10.354 --> 28:57:12.661
这是一种去中心化的方式。

21191
28:57:12.661 --> 28:57:19.419
记住，你可以用这个方法只需要一个治理协议另一个例子可能是契约注册表。

21192
28:57:19.419 --> 28:57:24.690
这是ABA早期版本在调用函数之前使用的东西，你会检查合约

21193
28:57:24.690 --> 28:57:30.151
注册表它被某人更新为参数你会被路由到合约，然后在那里调用。

21194
28:57:30.151 --> 28:57:36.881
同样，这确实不允许我们在这里拥有升级的全部功能，你可以争辩说这个注册表是后期版本的混合。

21195
28:57:36.881 --> 28:57:41.491
但无论如何，这并没有给我们提供我们想要的升级的灵活性。

21196
28:57:41.491 --> 28:57:46.304
但有些人甚至可能认为，升级智能合约正在破坏体面的现实。

21197
28:57:46.304 --> 28:57:51.294
智能合约如此强大的原因之一就是它是不可变的，这是它的好处之一。

21198
28:57:51.294 --> 28:57:57.776
有些人认为你不应该添加任何自定义或可升级性，你应该部署你的契约。

21199
28:57:57.776 --> 28:57:58.758
就这样了。

21200
28:57:58.758 --> 28:58:03.369
Trilobites认为，如果你在部署合同时，知道它

21201
28:58:03.369 --> 28:58:08.158
以后不能更改，你就会多花一点时间，确保一切都是正确的。

21202
28:58:08.158 --> 28:58:14.087
而且通常安全漏洞更少因为你只是设置它忘记它，不再看它。

21203
28:58:14.087 --> 28:58:20.063
现在，如果我想用这个理念来升级一个智能合约，我想让我的智能合约

21204
28:58:20.063 --> 28:58:26.039
保持不变的理念，我们可以用社会迁移方法，我之前叫它Eat方法。

21205
28:58:26.039 --> 28:58:27.572
现在我觉得没那么好笑了。

21206
28:58:27.572 --> 28:58:32.356
我们会继续讲社会迁移，也就是社会饮食法，或者说

21207
28:58:32.356 --> 28:58:37.140
迁移法是指你部署新契约，与旧契约没有任何联系。

21208
28:58:37.140 --> 28:58:44.246
按照社会惯例，你告诉所有人，嘿，嘿，这个新合同，这个我们刚刚部署的新合同?是啊，这是真的了。

21209
28:58:44.246 --> 28:58:51.071
按照惯例，人们迁移到使用这个新软件时，升级就完成了，因此我的俚语名称是social yeet。

21210
28:58:51.104 --> 28:58:57.831
因为你用了第一个移到第二个。

21211
28:58:58.104 --> 28:58:59.014
我觉得我很有趣。

21212
28:59:01.104 --> 28:59:03.858
总是说，嘿，这是我们的不可变智能合约。

21213
28:59:04.104 --> 28:59:05.054
这是我们的新产品。

21214
28:59:07.104 --> 28:59:12.122
不可变，因为你不给它任何升级的方法，如果有

21215
28:59:12.122 --> 28:59:17.379
人在5万年后调用契约，它的响应是完全一样的。

21216
28:59:17.379 --> 28:59:22.170
另一个巨大的缺点是你必须有一个全新的合同地址。

21217
28:59:22.170 --> 28:59:29.942
因此，如果你是一个ERC 20代币，例如，你必须说服所有的交易所列出你的新合同地址作为实际地址。

21218
28:59:29.942 --> 28:59:34.998
记住，当我们这样做的时候，我们必须把第一个的状态移到第二个。

21219
28:59:34.998 --> 28:59:40.018
例如，如果一个ERC令牌移动到该ERC令牌的新版本，你必须有

21220
28:59:40.018 --> 28:59:45.039
一种方法从第一个契约中获取所有映射并将其移动到第二个契约中。

21221
28:59:45.039 --> 28:59:47.776
显然，有很多方法可以做到这一点，因为所有东西都在链上。

21222
28:59:47.776 --> 28:59:56.504
但如果你有100万个转帐电话，我不想编写一个脚本来更新每个人的余额并计算每个人的余额，这样我就可以迁移到我的新版本的合同。

21223
28:59:56.504 --> 28:59:59.213
所以这里有很多社会习俗方面的工作要做。

21224
28:59:59.213 --> 29:00:04.815
Trilobites写了一篇很棒的博客关于从v1升级到v2等等。

21225
29:00:04.815 --> 29:00:11.246
在这个eat方法中他们给出了很多步骤来移动你的存储和状态变量到新的契约中。

21226
29:00:11.246 --> 29:00:13.265
如果你想阅读，请在描述中链接。

21227
29:00:13.265 --> 29:00:14.483
现在让我们开始我们的高价项目。

21228
29:00:14.483 --> 29:00:22.876
因此，为了拥有真正强大的升级心态或理念，我们需要某种类型的方法或框架，能够更新我们的状态，保持我们

21229
29:00:22.876 --> 29:00:31.270
的合同地址，并允许我们以一种简单的方式更新智能合同中的任何类型的逻辑，这将导致我们的大项目是代理。

21230
29:00:31.270 --> 29:00:37.483
我们的大项目是什么?代理,代理。

21231
29:00:37.483 --> 29:00:42.373
代理是最真实的升级形式，因为用户可以通过这些代

21232
29:00:42.373 --> 29:00:47.476
理继续与协议交互，甚至不会注意到任何更改或更新。

21233
29:00:47.476 --> 29:00:50.925
现在，这些也是你最容易搞砸的地方。

21234
29:00:50.925 --> 29:00:53.519
代理使用大量低级功能。

21235
29:00:53.519 --> 29:00:56.733
最主要的是委托调用功能。

21236
29:00:56.733 --> 29:01:04.878
委托调用是一个低级函数，目标契约中的代码在调用契约的上下文中执行。

21237
29:01:04.878 --> 29:01:07.722
message。sender和message。value也不变。

21238
29:01:07.722 --> 29:01:09.367
你们明白委托调用的意思了吧。

21239
29:01:09.367 --> 29:01:10.314
现在,对吗?太好了。

21240
29:01:10.314 --> 29:01:11.455
在英语中，

21241
29:01:11.455 --> 29:01:20.357
这意味着如果我从合同a委托调用合同B中的函数，我将在合同a中执行合同B的逻辑。

21242
29:01:20.357 --> 29:01:25.498
如果缩并B有一个函数说，嘿，把这个值存储在上面的一个

21243
29:01:25.498 --> 29:01:30.639
变量中，我要把这个变量存储在缩并a中，这就是幂函数。

21244
29:01:30.639 --> 29:01:37.264
这与回退功能相结合，允许我们通过代理合同地址将所有调用委托给其

21245
29:01:37.264 --> 29:01:44.104
他合同，这意味着我可以拥有一个代理合同，它将永远拥有相同的地址。

21246
29:01:44.104 --> 29:01:50.845
我可以指向和路由人们到正确的实现契约，它具有逻辑，每当我想要升

21247
29:01:50.845 --> 29:01:57.804
级时，我只需要部署一个新的实现契约并将我的代理指向那个新的实现。

21248
29:01:57.804 --> 29:02:04.436
现在，每当用户调用代理契约上的函数时，我就会把它委托给新契约，我可以只调用代理契约

21249
29:02:04.436 --> 29:02:11.069
上的管理函数，我们叫它upgrade什么的然后我让所有的契约调用都指向这个新契约。

21250
29:02:11.069 --> 29:02:15.056
当我们讨论代理时，我们需要记住四个术语。

21251
29:02:15.056 --> 29:02:16.817
首先是实施合同。

21252
29:02:16.817 --> 29:02:20.879
实现契约包含我们的所有逻辑和协议的所有部分。

21253
29:02:20.879 --> 29:02:29.297
每当我们升级时，我们实际上启动一个全新的实现契约，代理契约的代理指向哪个实现是正确的。

21254
29:02:29.297 --> 29:02:35.912
并将每个人的调用路由到正确的实现契约，你可以认为代理契约

21255
29:02:35.912 --> 29:02:42.765
位于用户的实现之上，用户将通过代理契约进行契约和函数调用。

21256
29:02:42.765 --> 29:02:49.523
然后是某种类型的管理员，管理员将决定何时升级和指向哪个合约。

21257
29:02:49.523 --> 29:02:54.780
在这个场景中，关于代理和委托调用的另一件很酷的事情是，我的

21258
29:02:54.780 --> 29:03:00.038
所有存储变量都将存储在代理契约中，而不是存储在实现契约中。

21259
29:03:00.104 --> 29:03:05.934
这样，当我升级到一个新的逻辑契约时，我的所有数据都将保留在代理契约上。

21260
29:03:05.934 --> 29:03:11.619
所以每当我想要更新我的逻辑，只要指向一个新的实现契约，如果我想要添加一个新的存

21261
29:03:11.619 --> 29:03:17.304
储变量或一种新的存储类型，我只要把它添加到我的逻辑契约中，代理契约就会接收它。

21262
29:03:17.304 --> 29:03:19.349
现在，使用代理有一些问题。

21263
29:03:19.349 --> 29:03:20.717
我们来谈谈这些陷阱。

21264
29:03:20.717 --> 29:03:27.088
然后我们将讨论不同的代理合同方法，因为是的，也有很多代理合同方法。

21265
29:03:27.088 --> 29:03:31.604
这就是为什么三叶虫不建议为你的智能合约使用可升级的代理。

21266
29:03:31.604 --> 29:03:35.009
因为他们充满了很多潜在的问题。

21267
29:03:35.009 --> 29:03:40.546
更不用说，您仍然有一些类型的管理员将升级您的智能合约。

21268
29:03:40.546 --> 29:03:43.844
现在，如果这是一个治理协议，那么很好，你是去中心化的。

21269
29:03:43.844 --> 29:03:47.646
但如果这是一个单独的团体或实体，那我们就有问题了。

21270
29:03:47.646 --> 29:03:53.834
最大的两个问题是存储、冲突和函数选择器冲突。

21271
29:03:53.834 --> 29:04:00.488
这是什么意思呢?当我们使用委托调用时，记住，我们在契约a中执行契约B的逻辑。

21272
29:04:00.488 --> 29:04:07.855
如果合约B说我们需要将值设为2，我们就会将值设为智能合

21273
29:04:07.855 --> 29:04:15.222
约的愚蠢之处，我们会将值设为合约B中相同存储位置的值。

21274
29:04:15.222 --> 29:04:24.037
如果我们的契约是这样的，我们有两个变量和契约a，我们仍然会将契约a的第一个存储点设为新值。

21275
29:04:24.104 --> 29:04:30.039
知道这一点非常重要，因为这意味着我们只能追加新的存储变量和新的实现契约。

21276
29:04:30.104 --> 29:04:31.961
我们不能重新订购或更换旧的。

21277
29:04:33.104 --> 29:04:33.574
冲突。

21278
29:04:36.104 --> 29:04:38.193
他们都在讨论这个问题。

21279
29:04:39.104 --> 29:04:41.045
调用函数选择或冲突。

21280
29:04:42.104 --> 29:04:47.954
代理将调用委托给这些实现之一，它使用所谓的函数选择器来查找函数。

21281
29:04:47.954 --> 29:04:52.918
函数选择器是函数名和函数签名的四字节散列。

21282
29:04:52.918 --> 29:04:55.237
现在不要担心函数签名。

21283
29:04:55.237 --> 29:05:01.142
现在，实现契约中的函数可能与代理契约中的管理函数具有相

21284
29:05:01.142 --> 29:05:07.267
同的函数选择器，这可能会导致您意外地做一大堆奇怪的事情。

21285
29:05:07.267 --> 29:05:13.707
例如，在你面前的这个示例代码中即使所有这些函数完全不同，它们实际上有相同的函数选择器。

21286
29:05:13.707 --> 29:05:19.370
是的，我们可能会遇到这样的问题，一些无害的函数，比如get price具有

21287
29:05:19.370 --> 29:05:25.033
与upgrade proxy或destroy proxy相同的函数选择器。

21288
29:05:25.104 --> 29:05:29.071
这就引出了代理契约的三个实现中的第一个。

21289
29:05:29.071 --> 29:05:31.974
这称为透明代理模式。

21290
29:05:32.104 --> 29:05:35.138
这就是我们今天要演示的模式。

21291
29:05:35.138 --> 29:05:38.764
在这种方法中，管理员只允许调用管理函数。

21292
29:05:38.764 --> 29:05:42.770
它们不能调用实现契约中的任何函数。

21293
29:05:42.770 --> 29:05:47.310
而且用户只能调用实现契约中的函数，而不能调用任何管理契约。

21294
29:05:47.310 --> 29:05:52.588
这样，你就不会意外地有两个交换，有一个函数选择器冲突，你在调用函数时

21295
29:05:52.588 --> 29:05:57.866
遇到一个大问题，你可能不应该有，如果你是一个管理员，你调用管理函数。

21296
29:05:57.866 --> 29:06:00.409
如果你的用户正在调用实现函数。

21297
29:06:00.409 --> 29:06:06.402
所以如果你是一个管理员，你建立了一些疯狂的，了不起的定义协议，你最好想出一个新的钱包地址，因为你不能参与。

21298
29:06:06.402 --> 29:06:12.011
我们要讨论的第二种代理是通用可升级代理，或运算放大器。

21299
29:06:12.011 --> 29:06:20.702
这个版本的可升级契约实际上把所有的升级逻辑都放在了实现本身中，可靠

21300
29:06:20.702 --> 29:06:29.394
度编译器会跳出来，说，嘿，这里有两个函数，它们有相同的函数选择器。

21301
29:06:29.394 --> 29:06:37.854
这也是有利的，因为我们少了一个阅读，我们必须做，我们不再需要检入代理合同，如果某人是管理员或不是。

21302
29:06:37.854 --> 29:06:40.734
这节省了汽油，当然，代理也小了一点。

21303
29:06:40.734 --> 29:06:47.865
因此，问题在于，如果部署的是实现契约，而没有任何可升级的功能，那么就会陷入困境。

21304
29:06:47.865 --> 29:06:50.468
现在我们回到Eat方法。

21305
29:06:50.468 --> 29:06:55.329
我们要讲的最后一种模式或方法是菱形模式，它有很多作用。

21306
29:06:55.329 --> 29:07:00.265
但它做的最大的事情之一是，它实际上允许多个实现契约。

21307
29:07:00.265 --> 29:07:02.431
这解决了几个不同的问题。

21308
29:07:02.431 --> 29:07:07.164
例如，如果您的契约非常大，并且它不适合一个契约

21309
29:07:07.164 --> 29:07:12.104
的最大大小，您可以通过这个多实现方法有多个契约。

21310
29:07:12.104 --> 29:07:20.168
它还允许你进行更细粒度的升级，比如你不必总是部署和升级整个智能合约，你可以只升级它的一小部分。

21311
29:07:20.168 --> 29:07:21.038
如果你把它们切成块。

21312
29:07:21.038 --> 29:07:26.215
这里提到的所有代理都有某种类型的Aetherium改进建议，其中大多数都处于草案阶段。

21313
29:07:26.215 --> 29:07:31.661
在这个解释的最后，我们会做一个演示演示委托调用函数是如何工作的。

21314
29:07:31.661 --> 29:07:34.693
演示到此结束。

21315
29:07:34.693 --> 29:07:38.961
我们来看委托调用。

21316
29:07:39.104 --> 29:07:44.845
现在，我们将学习如何构建这些代理如何构建这些可升级的智能合约。

21317
29:07:44.845 --> 29:07:48.525
要做到这一点，我们首先需要了解这个委托调用函数。

21318
29:07:48.525 --> 29:07:52.404
它和我们之前学过的调用函数非常相似。

21319
29:07:52.404 --> 29:07:55.022
如果你还没看过，一定要回到我们的Harnett。

21320
29:07:55.022 --> 29:08:02.793
如果是T，我们有一节课，关于EVM，操作码，编码和调用我们会给你们委托调用的所有上下文。

21321
29:08:02.793 --> 29:08:07.673
就像我在解释中说的，这和调用非常相似但是，我认为它是一

21322
29:08:07.673 --> 29:08:12.554
个契约说，哦，我真的很喜欢你的函数，我自己也要借用它。

21323
29:08:12.554 --> 29:08:14.604
我们将通过例子来研究固体的性质。

21324
29:08:14.604 --> 29:08:16.691
我会在GitHub上留下描述。

21325
29:08:16.691 --> 29:08:21.294
所有的代码都会在GitHub中与这节课相关。

21326
29:08:21.294 --> 29:08:28.659
现在我们有两个合同，一个是合同B，我们将在混音时使用它看起来是一个非常简约的非常简单的合同。

21327
29:08:28.659 --> 29:08:30.344
这里有几个存储变量。

21328
29:08:30.344 --> 29:08:38.575
然后我们有一个函数来更新我们的值，我们有一个叫做Set VARs的函数更新你是public

21329
29:08:38.575 --> 29:08:46.623
num吗?我们之前学过，每当我们有某种类型的契约与存储变量，它们被存储在这个索引从0开始

21330
29:08:46.623 --> 29:08:55.038
的存储数据结构中，现在你进入公共num是索引0，还是发送者的索引1，我们的值和索引2等等。

21331
29:08:55.104 --> 29:09:02.748
现在我们要部署一个合约a，现在这个合约将使用委托调用函数。

21332
29:09:02.748 --> 29:09:07.006
合同a这看起来有点不同，但它仍然有这个set

21333
29:09:07.006 --> 29:09:12.039
bars函数，除了它会调用委托调用函数调用合同B。

21334
29:09:12.104 --> 29:09:18.326
在我们关于NF TS的第14课中，我们学习了调用API dot encode和签名API dot encode等。

21335
29:09:18.326 --> 29:09:23.788
如果你不熟悉函数选择器，如果你不熟悉如果你不熟悉这个语法，一定要回到第14课来理

21336
29:09:23.788 --> 29:09:29.387
解ABI。encode with signature和contract。call。

21337
29:09:29.387 --> 29:09:33.704
不同的是，这里我们做的是合约。委托调用。

21338
29:09:33.704 --> 29:09:37.071
这个调用的作用和调用非常相似。

21339
29:09:37.071 --> 29:09:44.918
通常情况下，如果我们对契约进行契约式。调用，我们只会调用这个函数集VARs，

21340
29:09:44.918 --> 29:09:52.765
这将更新契约B的存储，但相反，我们说，调用那个集VARs函数，然后将它作为输

21341
29:09:52.765 --> 29:10:00.612
入参数传递，但在契约中调用它，在契约a中调用它，我们在契约中借用了一个函数。

21342
29:10:00.612 --> 29:10:06.991
相反，我们要做的是，我们要借用这个set bars然后运行这里的set bars函数。

21343
29:10:06.991 --> 29:10:13.858
不同的是，这些变量的命名可以不同于契约a中的变量。

21344
29:10:13.858 --> 29:10:18.636
所以不是num等于num，我们的契约会说，嘿，不

21345
29:10:18.636 --> 29:10:23.414
管那个存储0的值等于我们传递的作为输入参数的值。

21346
29:10:23.414 --> 29:10:25.459
如果有一点困惑，请继续听我讲。

21347
29:10:25.459 --> 29:10:27.645
让我们来看看混音版。

21348
29:10:27.645 --> 29:10:30.317
我将复制粘贴这段代码到这里的remix中。

21349
29:10:30.317 --> 29:10:32.845
我们可以测试一下，看看这是什么样子。

21350
29:10:32.845 --> 29:10:39.329
同样，在与这门课程相关的GitHub回购中有这个链接，请随时暂停视频获取这个链接。

21351
29:10:39.329 --> 29:10:42.270
它是固体，连字符，连字符，例子。

21352
29:10:42.270 --> 29:10:47.354
或者你可以直接从第16课Hardhead升级中获取代码。

21353
29:10:47.354 --> 29:10:48.197
让我们编译这段代码。

21354
29:10:48.197 --> 29:10:49.362
让我来告诉你我是什么意思。

21355
29:10:49.362 --> 29:10:52.974
我要编译它，然后到运行选项卡。

21356
29:10:53.104 --> 29:10:58.484
首先部署合约光束，点击部署，现在我们有了合约，num, center

21357
29:10:58.484 --> 29:11:03.865
和value都是空的，我们将数字更新为777，点击Set VARS。

21358
29:11:03.865 --> 29:11:08.912
设置VARs会将存储变量num更改为777。

21359
29:11:09.104 --> 29:11:13.318
然后我们改变sender和value, sender, value为0。

21360
29:11:13.318 --> 29:11:15.318
现在让我们部署契约a。

21361
29:11:15.318 --> 29:11:19.970
当然，我们在JavaScript VM上。

21362
29:11:19.970 --> 29:11:24.828
现在我们在Cinder中有这个带有num值的合同也都是空的。

21363
29:11:24.828 --> 29:11:31.726
但当我们调用集合VARs时，它会从契约B中借用集合VARs函数并在

21364
29:11:31.726 --> 29:11:38.624
契约a中运行，你几乎可以把它想象成我们在复制集合VARs并将它粘贴

21365
29:11:38.624 --> 29:11:45.734
到契约a中只运行一次，然后立即删除ADM，这就是委托调用函数的作用。

21366
29:11:45.734 --> 29:11:50.291
当我调用集合VARs时，我们会把合约地址作为输入参数传递给它。

21367
29:11:50.291 --> 29:11:53.725
所以它知道调用这个合约病毒函数。

21368
29:11:53.725 --> 29:11:57.021
当我传递地址时，我传递987。

21369
29:11:57.021 --> 29:12:01.750
因为我们借用了这个函数，所以我们不会更新这个num。

21370
29:12:01.750 --> 29:12:05.565
在契约B中，我们将更新契约a中的num。

21371
29:12:05.565 --> 29:12:09.038
当我点击Set VARs时，我们看到num现在有19。

21372
29:12:09.038 --> 29:12:15.292
7，我们看到参议员，我们看到value仍然是0，因为我们再次借用了这个函数，并在这里运行。

21373
29:12:15.292 --> 29:12:23.319
它的工作原理是，它并不查看存储变量的名称，而是查看存储槽。

21374
29:12:23.319 --> 29:12:28.569
当我们使用委托调用借用这个函数时，我们可以有这些变量我

21375
29:12:28.569 --> 29:12:34.015
们可以命名为任何东西而不是num，我们可以叫它第一个值。

21376
29:12:34.105 --> 29:12:36.492
参议员，我们可以叫别的名字。

21377
29:12:38.105 --> 29:12:41.021
调用foo，或者任何你想要的。

21378
29:12:43.105 --> 29:12:51.355
函数使用委托调用，而不是获取变量的实际名称，我们的契约将用存储槽交换这些变量名称。

21379
29:12:51.355 --> 29:12:59.006
它说，哦，好的，在契约B中，你访问的是num变量，它在0号存储槽。

21380
29:12:59.006 --> 29:13:05.727
当我们借用set条并与委托调用收缩a时，

21381
29:13:05.727 --> 29:13:12.449
我们会说存储槽0将等于那个下划线num。

21382
29:13:12.449 --> 29:13:16.793
也就是这个契约存储槽0是第一个值。

21383
29:13:16.793 --> 29:13:23.423
我们会说，firstvalue =下划线，现在，另一些东西会被存储在

21384
29:13:23.423 --> 29:13:30.054
插槽2中，它会说，好，存储插槽2，我们会更新存储插槽2来通知发送者。

21385
29:13:30.105 --> 29:13:33.028
好吧?这里的值是存储槽位3。

21386
29:13:35.105 --> 29:13:38.838
槽3将像这样更新消息点值。

21387
29:13:39.105 --> 29:13:41.621
这基本上就是幕后发生的事情。

21388
29:13:42.105 --> 29:13:44.898
让我们删除这些并重新部署。

21389
29:13:44.898 --> 29:13:45.786
重新部署。

21390
29:13:46.105 --> 29:13:54.323
我们将部署合同，部署合同a，现在在B中，同样，如果我们执行1234，设置var，我们有123。

21391
29:13:54.323 --> 29:13:55.794
缩并a。

21392
29:13:55.794 --> 29:14:00.844
尽管这些变量名称不同，我们还是可以获取合同B的

21393
29:14:00.844 --> 29:14:05.894
地址，粘贴进去，输入654，点击设置VARS。

21394
29:14:05.894 --> 29:14:09.578
第一个值是6 × 4。

21395
29:14:09.578 --> 29:14:17.637
委托调用允许我们借用函数，然后把这里的东西转置到对应的存储位置。

21396
29:14:17.637 --> 29:14:23.851
另一件有趣的事是即使你没有变量，它仍然会保存到存储槽中。

21397
29:14:23.851 --> 29:14:29.514
在契约a中，如果我们没有这些变量名，存储槽01和2仍然会被更新。

21398
29:14:29.514 --> 29:14:32.157
事情会变得非常有趣。

21399
29:14:32.157 --> 29:14:34.252
我们再把合同删掉吧。

21400
29:14:34.252 --> 29:14:41.271
让我们将契约A的第一个值的类型从UNT改为布尔值。

21401
29:14:41.271 --> 29:14:42.604
让我们保存它。

21402
29:14:42.604 --> 29:14:45.282
现在部署契约a。

21403
29:14:45.282 --> 29:14:51.965
当我们调用集合VARs时，在契约a中，它仍然会使用契约B的集合VARs

21404
29:14:51.965 --> 29:14:58.648
函数，它接受一个Yewande并分配我们传递给它的第一个存储槽，但我们

21405
29:14:58.648 --> 29:15:05.524
的第一个存储槽现在是一个布尔值所以你们认为现在会发生什么?让我们试一下。

21406
29:15:05.524 --> 29:15:08.845
我们把合同B的地址复制过来，粘贴在这里。

21407
29:15:08.845 --> 29:15:14.406
我们用tu tu作为输入参数，点击Set VARS。

21408
29:15:14.406 --> 29:15:17.651
我们的交易确实完成了。

21409
29:15:17.651 --> 29:15:21.557
现在当我们看第一个值时，它说为真。

21410
29:15:21.557 --> 29:15:23.292
嗯，那真的很奇怪。

21411
29:15:23.292 --> 29:15:26.750
如果我们将set VARs改为0，然后点击set VARs。

21412
29:15:26.750 --> 29:15:29.169
现在，第一个值为假。

21413
29:15:29.169 --> 29:15:34.115
在这里的存储中，当我们添加一个带有集合var的数字时，

21414
29:15:34.115 --> 29:15:38.695
它会通过因为它只是将布尔值的存储槽设置为一个数字。

21415
29:15:38.695 --> 29:15:43.460
当固体读取它时，它会说，哦，好吧，第一个值是布尔值。

21416
29:15:43.460 --> 29:15:46.443
所以如果它不是0，它就是对的。

21417
29:15:46.443 --> 29:15:49.473
这就是为什么你会得到一些奇怪的结果。

21418
29:15:49.473 --> 29:15:53.136
如果类型不同，或者存储的变量不同。

21419
29:15:53.136 --> 29:15:54.636
如果我们把这改成地址呢。

21420
29:15:54.636 --> 29:15:59.518
这就是使用委托调用会变

21421
29:15:59.518 --> 29:16:04.845
得非常奇怪和棘手的地方。

21422
29:16:05.105 --> 29:16:05.715
好吧。

21423
29:16:09.105 --> 29:16:09.319
热量。

21424
29:16:12.105 --> 29:16:20.415
示例，它展示了如何将合同用作单数地址，但底层代码实际上可以更改。

21425
29:16:20.415 --> 29:16:26.219
我们要用到的所有代码，还是那句话，在硬帽升级，FCC子课程，

21426
29:16:26.219 --> 29:16:31.830
小代理。Sol中，你可以复制粘贴这些代码，如果你想学的话。

21427
29:16:31.830 --> 29:16:34.007
所以你不需要跟我一起写代码。

21428
29:16:34.105 --> 29:16:35.811
但如果我们愿意，你完全可以。

21429
29:16:37.105 --> 29:16:41.927
这将是整个课程中最先进的部分之一。

21430
29:16:41.927 --> 29:16:44.622
所以请随意跳过这节课。

21431
29:16:44.622 --> 29:16:51.305
如果您只想继续学习如何实际构建这些代理，而不真正了解幕后发生了什么。

21432
29:16:51.305 --> 29:16:55.032
然而，如果您确实了解幕后发生的事情，它仍然非常强大。

21433
29:16:55.032 --> 29:16:58.438
这是最简的起始位置。

21434
29:16:58.438 --> 29:17:00.402
我有小代理就是代理。

21435
29:17:00.402 --> 29:17:05.030
我要从Zeplin导入proxy。sole这个东西。

21436
29:17:05.105 --> 29:17:11.055
Openzeppelin有这个极简的代理契约，我们可以用它实际开始处理这个委托调用。

21437
29:17:11.105 --> 29:17:14.789
这个契约使用了大量的集合或者所谓的"你会"

21438
29:17:14.789 --> 29:17:19.443
它是一种可以编译为不同后端字节码的中间语言。

21439
29:17:19.443 --> 29:17:27.383
它是一种内嵌的程序集，它允许你写非常非常低级别的代码，接近操作码。

21440
29:17:27.383 --> 29:17:32.261
现在我们不复习了但是如果你们想了解更多我会给你们一些文档的链接。

21441
29:17:32.261 --> 29:17:38.105
即使您是一个非常高级的用户，您也希望尽量少使用EULA。

21442
29:17:38.105 --> 29:17:43.556
因为它的级别要低得多，所以更容易把事情搞砸。

21443
29:17:43.556 --> 29:17:51.040
然而，就像我说的，在这个例子中，我们会用到一点。在我们将要做的这个代理

21444
29:17:51.040 --> 29:17:58.524
中，我们有这个委托函数，在这个内联程序集中，它会做很多非常低级的事情。

21445
29:17:58.524 --> 29:18:02.875
但它做的主要事情是它继续它做这个委托调用功能。

21446
29:18:02.875 --> 29:18:08.105
看这里，它使用了一个回退函数和一个接收函数。

21447
29:18:08.105 --> 29:18:11.423
当它接收到一个无法识别的函数时，

21448
29:18:11.423 --> 29:18:17.438
它会调用fallback，而fallback调用委托函数。

21449
29:18:17.438 --> 29:18:23.740
因此，每当代理契约接收到一个它不识别的函数的数据时，它就会将

21450
29:18:23.740 --> 29:18:30.043
它发送到某个实现到某个实现契约，在那里它将用委托调用调用它。

21451
29:18:30.105 --> 29:18:38.531
在我们最简单的例子中，我们有一个叫Set implementation的函数，它会改变那些委托调用发送的位置。

21452
29:18:38.531 --> 29:18:41.975
这相当于升级你的智能合约。

21453
29:18:41.975 --> 29:18:47.741
然后我们在这里有实现来读取实现契约的位置。

21454
29:18:47.741 --> 29:18:52.340
要使用代理，我们真的不想在存储中有任何东西，因为如果我们进行委

21455
29:18:52.340 --> 29:18:57.089
托调用，而委托调用发生了变化，一些存储，我们就会把契约存储搞砸。

21456
29:18:57.089 --> 29:19:04.566
需要注意的是，我们仍然需要把实现地址存储在某处，我们可以叫它ERP 1976。

21457
29:19:04.566 --> 29:19:07.419
它被称为标准代理存储槽，

21458
29:19:07.419 --> 29:19:15.028
这是Aetherium的改进建议，用于指定特定的存储槽用于代理。

21459
29:19:15.105 --> 29:19:23.695
在这个最简单的例子中，我们设置bytes 32，私有常量实现槽到存储中的那个位置。

21460
29:19:23.695 --> 29:19:31.533
我们会说，不管这个存储槽是什么它就是实现地址的位置。

21461
29:19:31.533 --> 29:19:36.793
代理的工作方式是任何调用这个代理契约的契约。

21462
29:19:36.793 --> 29:19:42.990
如果它不是这个集合实现函数，它会把它传递到实现槽地址内的任何东西。

21463
29:19:42.990 --> 29:19:44.432
这就是我们要在这里建立的。

21464
29:19:44.432 --> 29:19:47.382
我们有一个小代理。

21465
29:19:47.382 --> 29:19:51.308
我们将创建一个真正的极简契约。

21466
29:19:51.308 --> 29:19:58.443
我们写合同雇员，心理状态A，我们给它一个U和256。

21467
29:19:58.443 --> 29:20:05.733
然后函数集value，你添加256个新值，public会

21468
29:20:05.733 --> 29:20:13.023
说value = new value，这就是我们的实现。

21469
29:20:13.023 --> 29:20:19.644
只要有人调用小代理，或者小代理契约，它就会委托，

21470
29:20:19.644 --> 29:20:26.542
调用它到我们的实现a，然后把存储存到小代理地址中。

21471
29:20:26.542 --> 29:20:32.676
我们会用数据调用我们的小代理来使用这个集值函数选择器。

21472
29:20:32.676 --> 29:20:38.820
让我们让它变得更简单一些通过创建一个新的helpe

21473
29:20:38.820 --> 29:20:44.964
r函数，dofunction，获取数据到事务处理。

21474
29:20:45.105 --> 29:20:51.025
我们可以使用我们在前一课中学过的带有签名的API点编码来获取数据。

21475
29:20:51.025 --> 29:20:57.711
函数获取数据到transact，我们将传递给它一个un256数字来更新。

21476
29:20:57.711 --> 29:21:01.645
我们给这个数字一个新值。

21477
29:21:01.645 --> 29:21:07.999
我们将它设为public pure，它将返回一个字节。

21478
29:21:08.105 --> 29:21:08.771
内存。

21479
29:21:08.771 --> 29:21:13.326
我们会说返回ABI。ENCODE。

21480
29:21:14.105 --> 29:21:19.569
签名集值，你去56，

21481
29:21:19.569 --> 29:21:23.941
逗号，数字更新。

21482
29:21:24.105 --> 29:21:27.588
你们应该记得我们的任意部分。

21483
29:21:28.105 --> 29:21:34.149
你不记得怎么做了，记得回看我们的非ft部分，学习如何调用任何东西，并使用ABI。

21484
29:21:34.149 --> 29:21:41.252
encode ABI。encode与签名，调用任何带有原始字节的东西，带来和获取数据进行交易。

21485
29:21:41.252 --> 29:21:48.225
我们知道，当我们从小代理调用实现a时，我们会更新小代理存储。

21486
29:21:48.225 --> 29:21:53.006
我们会在实体中创建一个小函数来读取小代理中的存储。

21487
29:21:53.006 --> 29:21:56.202
我们会说函数，读取存储。

21488
29:21:56.202 --> 29:22:01.849
这将是一个公共视图，它会返回

21489
29:22:01.849 --> 29:22:07.901
到256，在存储槽处的值，0。

21490
29:22:07.901 --> 29:22:13.978
我们将在这里使用一点汇编因为我们做的都是低级的东西。

21491
29:22:13.978 --> 29:22:20.267
我们会调用s load up代码来读取0号存储槽位的值，我们会说0号

21492
29:22:20.267 --> 29:22:26.556
存储槽位的value，我们会设置它然后在汇编中，这是我们设置东西的方

21493
29:22:26.556 --> 29:22:32.846
式，我们会设置它等于0号存储槽位的s load，然后它会返回这个值。

21494
29:22:32.846 --> 29:22:34.884
我们直接从存储中读取。

21495
29:22:34.884 --> 29:22:37.732
哦，然后我们需要一个小括号。

21496
29:22:37.732 --> 29:22:38.138
对不起。

21497
29:22:38.138 --> 29:22:41.223
现在，让我们继续部署我们的小代理。

21498
29:22:41.223 --> 29:22:43.188
让我们部署实现A。

21499
29:22:43.188 --> 29:22:47.966
现在我们的小代理有一个名为Set implementation的函数。

21500
29:22:47.966 --> 29:22:55.460
我们会说，任何时候调用这个代理契约，我们都会委托调用函数到这里。

21501
29:22:55.460 --> 29:23:02.819
我们会抓取当前实现A的地址，粘贴到集合实现77中。

21502
29:23:02.819 --> 29:23:09.105
这是你在256中的数据值，里面编码了要更新的数字。

21503
29:23:09.105 --> 29:23:17.850
如果我们调用小代理，用这些数据，我们的代理契约会说，哦，这是一个函数。

21504
29:23:17.850 --> 29:23:19.875
我没有，我没有看到这个函数。

21505
29:23:19.875 --> 29:23:24.551
我们将调用我们的fallback，对吧，它同样来自open Zeplin。

21506
29:23:24.551 --> 29:23:31.198
我们的Fallback会做这个委托，这是低级别的东西，但它基本上只是做一个委托调用，

21507
29:23:31.198 --> 29:23:40.695
我们会调用我们的Fallback函数，然后我们会在实现a中得到这个函数，我们会借用这个函数，我们会在我们自己身上使用它。

21508
29:23:40.695 --> 29:23:45.558
如果我复制这个，实现被设置为下面这个地址。

21509
29:23:45.558 --> 29:23:47.533
所有的逻辑都在这里完成了。

21510
29:23:47.533 --> 29:23:54.717
我抓取这个，粘贴到调用数据中，点击交易，看起来它成功通过了。

21511
29:23:54.717 --> 29:24:00.333
如果我读存储，现在，我们看到它确实是777，这是非常令人兴奋的。

21512
29:24:00.333 --> 29:24:08.305
现在，这是非常有益的，因为现在我们想要更新我们的代码，对吧?我们不再喜欢契约执行了。

21513
29:24:08.305 --> 29:24:11.105
我们来复制契约实现A。

21514
29:24:11.105 --> 29:24:14.191
我们新建一个，叫做实现B。

21515
29:24:14.191 --> 29:24:18.075
现在，我们说每当有人调用setvalue时，

21516
29:24:18.075 --> 29:24:23.195
我们做value = new value + 1或+ 2。

21517
29:24:23.195 --> 29:24:25.938
让我们继续，保存它。

21518
29:24:25.938 --> 29:24:27.521
让我们编译这个。

21519
29:24:27.521 --> 29:24:32.008
我们部署实现B，获取实现B的契约

21520
29:24:32.008 --> 29:24:36.777
地址，我们在代理中称它为起始实现。

21521
29:24:36.777 --> 29:24:42.637
实际上，我们已经从实现a升级到实现B。

21522
29:24:42.637 --> 29:24:49.137
现在，如果我们用同样的数据，我们仍然会调用setvalue = 777。

21523
29:24:49.137 --> 29:24:55.395
但相反，我们现在是委托调用实现B，而不是实现A。

21524
29:24:55.395 --> 29:25:02.688
如果我调用。如果我把这个数据放到低级调用数据中，然后点击事务，它看起来通过了。

21525
29:25:02.688 --> 29:25:08.226
现在我读取storage，现在是779因为value =

21526
29:25:08.226 --> 29:25:13.765
new value + 2这是一个关于升级的简单例子。

21527
29:25:13.765 --> 29:25:22.377
现在，这是非常有益的，因为我们总是可以告诉人们，嘿，让你所有的函数调用到小代理，你会很好。

21528
29:25:22.377 --> 29:25:30.505
但正如我前面所说，这也意味着该协议的开发人员可以在任何时候从本质上更改底层逻辑。

21529
29:25:30.505 --> 29:25:36.882
这就是为什么一定要阅读合同并查看谁拥有开发人员密钥是如此重要。

21530
29:25:36.882 --> 29:25:44.396
如果一个合同可以更新，如果一个合同可以更新，一个人可以更新它，你猜怎么着，你就有了一个集中的故障点。

21531
29:25:44.396 --> 29:25:46.744
从技术上讲，这份合同甚至没有去中心化。

21532
29:25:46.744 --> 29:25:53.501
现在，我在视频中谈到的另一件事是函数冲突函数选择器冲突。

21533
29:25:53.501 --> 29:26:01.782
现在，当我们调用set实现时，代理函数沉降会被调用因为我们不会触发回退因为我们可以看到函数在这里。

21534
29:26:01.782 --> 29:26:07.905
然而，如果我有一个叫Set implementation的函数，在我们的实现中，这个永远不能被调

21535
29:26:07.905 --> 29:26:14.029
用，每当我们发送一个Set implementation的函数签名时，它总是会调用代理上的那个。

21536
29:26:14.029 --> 29:26:22.311
这就是我们要使用的透明代理可以帮助我们的地方通用可升级代理可以帮助我们，我现在不打算深入讲这些。

21537
29:26:22.311 --> 29:26:28.329
但我们在GitHub存储库中留下了一些链接，以教您更多关于这些选择器冲突的知识。

21538
29:26:28.329 --> 29:26:37.024
以及我刚才提到的两种代理模式，透明的和通用的可升级模式是如何解决这些问题的，如果你对这里的任何内容感到困惑，

21539
29:26:37.024 --> 29:26:45.719
请进入这个讨论环节，对代理进行新的讨论对程序集进行新的讨论对你将设置的实现进行新的讨论，这是一个与其他选修这

21540
29:26:45.719 --> 29:26:54.416
门课的人联系并提问的好时机，因为我知道这是一个非常高级的部分，这要求你们没有学过很多我们之前学过的次级课程。

21541
29:26:54.416 --> 29:26:58.841
如果这需要你花上几次时间来处理固相和混音，我强

21542
29:26:58.841 --> 29:27:03.460
烈建议你这样做这是我们看到的真正值得相信的部分。

21543
29:27:03.460 --> 29:27:04.819
我要你开始混音。

21544
29:27:04.819 --> 29:27:06.152
我想让你测试一下。

21545
29:27:06.152 --> 29:27:10.308
我想让你们玩玩这个看看你们能打破什么，摆弄什么。

21546
29:27:10.308 --> 29:27:17.665
但是说了这么多，我们终于拥有了构建处理升级的硬帽项目所需的所有知识。

21547
29:27:17.665 --> 29:27:21.865
让我们开始吧。

21548
29:27:22.105 --> 29:27:29.371
你的新终端，我们会执行mkdir, hard hat，升级，FCC, CD, hard

21549
29:27:29.371 --> 29:27:36.468
hat，升级，FCC，然后代码周期，或者文件，打开文件夹，这个文件夹，现在我要抓取那

21550
29:27:36.468 --> 29:27:44.072
个yarn add我们从小于9处抓取，我们要把它粘贴进去，我们要添加所有这些不同的参数。

21551
29:27:44.072 --> 29:27:49.155
再一次，我们要复制我们的硬帽子配置从以前的章节，我们要复制漂亮。

21552
29:27:49.155 --> 29:27:51.789
我们会得到基本的默认设置。

21553
29:27:51.789 --> 29:27:56.219
在这一点上，你可能有一个最适合你和你更喜欢的设置。

21554
29:27:56.219 --> 29:27:57.969
你也可以随便拿这个。

21555
29:27:57.969 --> 29:28:00.298
我要把漂亮的粘贴到这里。

21556
29:28:00.298 --> 29:28:02.039
我要把安全帽粘上去。

21557
29:28:02.039 --> 29:28:02.329
配置。

21558
29:28:02.329 --> 29:28:05.200
Js，我们一直在使用，而不是运行纱线安全帽。

21559
29:28:05.200 --> 29:28:07.105
现在我们应该可以开始了。

21560
29:28:07.105 --> 29:28:10.643
让我们创建一个名为contract的新文件夹。

21561
29:28:10.643 --> 29:28:15.040
在这里，我们将创建一个名为Box。soul的新文件。

21562
29:28:15.105 --> 29:28:19.505
然后是这个契约，这将是我们的实现或逻辑契约。

21563
29:28:19.505 --> 29:28:24.318
所以它会说pragma, solidity carrot零点8。

21564
29:28:24.318 --> 29:28:31.726
7合约框会说你进入256个内部值将做事件值

21565
29:28:31.726 --> 29:28:38.076
改变你进入256个新值，做函数存储，

21566
29:28:38.076 --> 29:28:46.896
你进入36个值，这将是一个公共函数会说值等于新值。

21567
29:28:46.896 --> 29:28:53.619
这个store函数会在内部的0号存储槽更新变量，

21568
29:28:53.619 --> 29:29:00.623
然后我们会省略value changed那个新值。

21569
29:29:00.623 --> 29:29:05.936
然后我们会创建函数检索，这将是一个公共

21570
29:29:05.936 --> 29:29:11.529
视图返回一个unt256我们只做返回值。

21571
29:29:11.529 --> 29:29:16.699
然后我们会创建一个新函数叫做version。

21572
29:29:16.699 --> 29:29:19.326
这将是一扇公共大门。

21573
29:29:19.326 --> 29:29:21.574
返回un256。

21574
29:29:21.574 --> 29:29:25.089
我们只会有这个返回值。

21575
29:29:25.089 --> 29:29:28.106
盒子契约是版本1。

21576
29:29:28.106 --> 29:29:33.193
现在我们要复制所有这些代码，粘贴到v2。soul中并将其重

21577
29:29:33.193 --> 29:29:38.456
命名为contract v2，我们将把这个版本更新到版本2。

21578
29:29:38.456 --> 29:29:42.525
我们要创建一个新函数，叫做increment。

21579
29:29:42.525 --> 29:29:45.912
这将是一个公共活动。

21580
29:29:46.106 --> 29:29:49.949
我们设value = value + 1。

21581
29:29:52.106 --> 29:29:54.913
带有值的值更改事件。

21582
29:29:57.106 --> 29:30:03.875
合同地址最初使用盒子里的逻辑，然后我们将把它升级到盒子v2里的逻辑。

21583
29:30:03.875 --> 29:30:10.325
我们将学习如何使用我们在这里使用过的所有工具来添加这个逻辑并

21584
29:30:10.325 --> 29:30:16.992
创建这个逻辑，让我们确保它工作，我们将使用yarn，或者编译。

21585
29:30:17.106 --> 29:30:18.798
让我们做一个自述文件。

21586
29:30:22.106 --> 29:30:23.582
盒子到盒子v2。

21587
29:30:28.106 --> 29:30:29.306
指向盒子。

21588
29:30:32.106 --> 29:30:34.041
它指向盒子v2。

21589
29:30:37.106 --> 29:30:40.201
指向盒子，那么我们让它指向盒子v2。

21590
29:30:40.201 --> 29:30:45.216
这就是我们要升级它的方式，我们首先要做的一件事就是部署一个代理，我

21591
29:30:45.216 --> 29:30:50.231
们可以自己手动部署一个代理，我们可以建立代理合同，做所有这些事情。

21592
29:30:50.231 --> 29:30:51.516
这是我们的第一选择。

21593
29:30:51.516 --> 29:31:00.351
Hardhead部署也内置在部署和升级代理本身中，我们可以只指定想要使用代理。

21594
29:31:00.351 --> 29:31:03.316
我们可以指定我们想要使用的代理的类型。

21595
29:31:03.316 --> 29:31:08.248
第二点说的是使用硬帽部署，内置代理。

21596
29:31:08.248 --> 29:31:14.639
第三点是Zeppelin有一个升级插件，它允许你写一些非常简单的脚本，

21597
29:31:14.639 --> 29:31:21.213
允许你有一个非常简单的API，比如升级。部署代理，然后升级那个升级代理。

21598
29:31:21.213 --> 29:31:26.532
在本节中，我们将进行内建代理的硬帽部署。

21599
29:31:26.532 --> 29:31:34.895
然而，在与此相关的GitHub回购中，如果你去脚本，有其他的升级示例，将向你展示如何使用打开和升级插件。

21600
29:31:34.895 --> 29:31:41.912
我们不会手动部署代理手动部署代理，因为我们在子课中已经演示过了。

21601
29:31:41.912 --> 29:31:46.609
我们会向你们展示这个，我们会向你们展示Hardhead部署内置代理，如果你

21602
29:31:46.609 --> 29:31:51.306
想使用openzeppelin升级插件，那在GitHub回购中也是可用的。

21603
29:31:51.306 --> 29:31:53.033
我们来做这个。

21604
29:31:53.033 --> 29:31:57.235
我们会创建一个新文件夹，也就是部署文件夹。

21605
29:31:57.235 --> 29:32:02.702
首先，我们创建一个新文件，名为1,deploy box。js。

21606
29:32:02.702 --> 29:32:06.326
这看起来和我们之前做过的很像。

21607
29:32:06.326 --> 29:32:14.735
module。exports = async function，我们会得到命名帐户和部署。

21608
29:32:14.735 --> 29:32:20.449
箭头函数会写const deploy COMM A log =

21609
29:32:20.449 --> 29:32:28.929
deployment const deployer = await, get named。

21610
29:32:29.106 --> 29:32:35.694
Accounts，做一些记录，像这样，然后我们说const, box =

21611
29:32:35.694 --> 29:32:42.831
await, loi, box，逗号，我们说from Deployer，逗号，

21612
29:32:42.831 --> 29:32:45.942
args像这样，我们说weight

21613
29:32:45.942 --> 29:32:57.106
conformation将是network。config。block confirations for Masons。

21614
29:32:57.106 --> 29:33:01.506
是的，我们要从硬帽获取const。

21615
29:33:01.506 --> 29:33:05.267
然后我们可以在这里添加代理的参数。

21616
29:33:05.267 --> 29:33:08.846
这就是我们可以添加大量信息的地方。

21617
29:33:08.846 --> 29:33:17.525
就像我说的，我们将使用开放齐柏林飞船的透明可升级代理，如果我们想使用它，我们必须添加开放齐柏林飞船。

21618
29:33:17.525 --> 29:33:24.124
所以我们会做纱线，添加破折号开发打开齐柏林斜杠合同。

21619
29:33:24.124 --> 29:33:31.693
我们可以告诉我们的硬帽在代理后面部署这个盒

21620
29:33:31.693 --> 29:33:39.623
子契约会说代理契约将是开放的齐柏林透明代理。

21621
29:33:39.623 --> 29:33:44.588
我们还会做via管理合同。

21622
29:33:44.588 --> 29:33:52.499
代理合同不再是管理地址，而是由管理合同拥有。

21623
29:33:52.499 --> 29:33:56.639
这样做被认为是一种最佳实践，原因有很多。

21624
29:33:56.639 --> 29:34:02.077
但是我们将为这个管理契约、盒子代理

21625
29:34:02.077 --> 29:34:07.515
管理和这个盒子代理管理的工件命名。

21626
29:34:07.515 --> 29:34:12.953
因此，我们需要创建一个盒子代理管理合同作为我们的盒子的管理。

21627
29:34:12.953 --> 29:34:18.213
在合约文件夹中，新建一个名为proxy的文件夹。

21628
29:34:18.213 --> 29:34:20.784
这里有个新文件，

21629
29:34:20.784 --> 29:34:35.895
叫做Box代理管理这是管理合同用来控制Box的代理收件箱代理管理。Saul会做SP DX许可。

21630
29:34:35.895 --> 29:34:44.742
然后我点燃MIT实用主义，胡萝卜0，点8。

21631
29:34:44.742 --> 29:34:50.381
7，比如合同，盒子代理管理，像这样，对吧?再一

21632
29:34:50.381 --> 29:34:56.267
次，我们将使用透明文件夹中的Zetland工具。

21633
29:34:56.267 --> 29:35:02.059
他们有一个代理管理。Saul，这和我们的box代理管理是一样的。

21634
29:35:02.106 --> 29:35:09.706
它有一些功能，这里有一些功能，比如更改，代理管理，升级，升级和处理升级的调用。

21635
29:35:09.706 --> 29:35:10.352
所有合同。

21636
29:35:10.352 --> 29:35:16.262
我们要导入它会在open Zeppelin处导入

21637
29:35:16.262 --> 29:35:22.173
斜杠合同斜杠代理斜杠透明，斜杠代理管理，点灵魂。

21638
29:35:22.173 --> 29:35:28.847
我们会说我们的Brock's box代理管理是代理管理，像这样。

21639
29:35:28.847 --> 29:35:34.132
为了让这个框代理管理与deploy plugin中的心脏一起工作，我

21640
29:35:34.132 --> 29:35:39.573
们的构造函数需要接受一个地址所有者作为输入参数，但我们将把它保留为空。

21641
29:35:39.573 --> 29:35:42.735
然后我们需要做代理管理，这也是空白的。

21642
29:35:42.735 --> 29:35:43.412
就是这样。

21643
29:35:43.412 --> 29:35:51.772
这就是我们要做的box代理管理合同，它有所有的功能来进行升级和更改代理管理等等。

21644
29:35:51.772 --> 29:35:57.482
我们将在代理后面部署我们的盒子合同，并开放透明的代理，它属

21645
29:35:57.482 --> 29:36:03.193
于模板Aetherium合同中的Brock的代理管理合同。

21646
29:36:03.193 --> 29:36:11.783
GitHub回购实际上是一个例子斜杠打开代理分支，将向你展示如何使用不同类型的代理。

21647
29:36:11.783 --> 29:36:15.206
在与这门课相关的GitHub回购中会有一个链接。

21648
29:36:15.206 --> 29:36:20.948
然后我们会进行验证，比如，链。包含。

21649
29:36:20.948 --> 29:36:26.940
我们继续，我要复制粘贴我们的硬帽助手配置从我们的上一个项

21650
29:36:26.940 --> 29:36:32.932
目，它有开发链，我们导出的硬帽和本地主机，也会导入这个。

21651
29:36:32.932 --> 29:36:40.391
Const开发链= require。slash helper hard hat config。

21652
29:36:40.391 --> 29:36:46.318
如果development chains。包括network。

21653
29:36:46.318 --> 29:36:53.010
name和process。env。ether scan API key

21654
29:36:53.010 --> 29:36:59.512
ey log，验证和我们上次验证的方法一样，我们将复制utils文件夹。

21655
29:36:59.512 --> 29:37:05.299
复制粘贴，我们有验证，它会导入到这里。

21656
29:37:05.299 --> 29:37:10.361
我们写入const verify = require。dot /

21657
29:37:10.361 --> 29:37:17.006
utils，斜杠verify, await verify box。address。

21658
29:37:17.106 --> 29:37:18.864
然后args是空的。

21659
29:37:20.106 --> 29:37:21.182
这里，砰。

21660
29:37:25.106 --> 29:37:30.942
我们可以通过运行Hardhead deploy纱线来测试，看看是否一切正常。

21661
29:37:30.942 --> 29:37:32.187
就这样完成了。

21662
29:37:32.187 --> 29:37:38.018
然后我们还应该加上log beach true。

21663
29:37:38.106 --> 29:37:40.009
让我们再运行一遍，效果更好。

21664
29:37:41.106 --> 29:37:42.987
实际上部署了几个契约。

21665
29:37:44.106 --> 29:37:50.155
代理管理，这将是我们的管理契约，然后我们部署盒子实现。

21666
29:37:50.155 --> 29:37:55.847
hardhat deploy，将我们的盒子契约重

21667
29:37:55.847 --> 29:38:01.778
命名为盒子实现然后部署它，然后部署我们的盒子代理。

21668
29:38:01.778 --> 29:38:05.912
任何时候我们调用这个地址，它都会指向盒子的逻辑。

21669
29:38:05.912 --> 29:38:14.710
现在我们能做的是写一个部署脚本来部署box v2实现，然后把我们的box升级到V

21670
29:38:14.710 --> 29:38:23.728
创建一个新的部署脚本叫做Zero来部署box v2。j或者部署box two。j。

21671
29:38:23.728 --> 29:38:26.486
我们会做一些类似的事情。

21672
29:38:26.486 --> 29:38:31.806
好的，我要复制大部分的内容，粘贴到这里。

21673
29:38:31.806 --> 29:38:40.106
现在我们要做const box v2 = await, deploy。

21674
29:38:40.106 --> 29:38:45.369
框v2，逗号，来自Deployer。

21675
29:38:45.369 --> 29:38:52.162
logtrue RMS空白，权重确认，它将

21676
29:38:52.162 --> 29:38:58.956
是network。config。lock。

21677
29:38:59.106 --> 29:39:03.902
或者masons，然后复制验证码，复制这个，粘贴到这

21678
29:39:03.902 --> 29:39:08.699
里，server，这是box v2。address。

21679
29:39:08.699 --> 29:39:09.715
好了,好了。

21680
29:39:09.715 --> 29:39:14.439
现在我们有了一些可以部署box和v2的代码。

21681
29:39:14.439 --> 29:39:19.235
现在让我们写一个脚本来升级这些。

21682
29:39:19.235 --> 29:39:22.525
新建一个文件夹，scripts。

21683
29:39:22.525 --> 29:39:26.518
新建文件，命名为upgrade box。js。

21684
29:39:26.518 --> 29:39:28.912
现在我们用手工的方法来做。

21685
29:39:28.912 --> 29:39:36.052
我们用手动的方式是因为我想给你们展示我们调用的函数来完成这个升级过程。

21686
29:39:36.106 --> 29:39:42.810
不过，硬帽部署还提供了一个API，可以非常容易地升级您的盒式契约。

21687
29:39:42.810 --> 29:39:44.347
这将是一个脚本。

21688
29:39:44.347 --> 29:39:47.418
我们从async函数main开始。

21689
29:39:47.418 --> 29:39:53.868
然后复制粘贴传统脚本，main。然后process exit等等，等等，等等。

21690
29:39:53.868 --> 29:39:57.834
我们得先拿到代理管理合同。

21691
29:39:57.834 --> 29:39:59.761
我们写上box const。

21692
29:39:59.761 --> 29:40:07.367
Box, proxy admin = await ethers。get contract, Box

21693
29:40:07.367 --> 29:40:15.751
proxy admin我们需要导入这里来自Hardhead，然后我们会得到实际的代理，这是我们的透明代理。

21694
29:40:15.751 --> 29:40:19.773
因此我们写入const transparent proxy =

21695
29:40:19.773 --> 29:40:24.963
await ethers。get contract, box下划线proxy。

21696
29:40:24.963 --> 29:40:30.043
由于是硬帽部署，我们将用实现下划线代理的名称命名代理。

21697
29:40:30.043 --> 29:40:34.483
当然，我们需要盒子V收缩。

21698
29:40:34.483 --> 29:40:35.548
所以写上const。

21699
29:40:35.548 --> 29:40:41.550
方框v 2等于等待醚。得到契约，方框v 2。

21700
29:40:41.550 --> 29:40:49.614
现在我们可以说const，升级TX等于一个权重箱代理admin，也就是升级。

21701
29:40:49.614 --> 29:40:54.804
我们会在盒子代理管理上调用升级函数，它会在透明

21702
29:40:54.804 --> 29:40:59.994
代理上调用它，这会将实现从盒子1改变到盒子2。

21703
29:40:59.994 --> 29:41:07.836
盒子代理管理，也就是升级，我们将把透明代理。address升

21704
29:41:07.836 --> 29:41:15.678
级到盒子B到那个地址，它会在盒子代理中查找，盒子代理有一个升

21705
29:41:15.678 --> 29:41:23.784
级函数调用我们的透明可升级代理会执行一个权重升级TX。等一下。

21706
29:41:23.784 --> 29:41:29.472
现在要处理box v2上的函数，我们会说const proxy

21707
29:41:29.472 --> 29:41:35.527
box = await ethers。get contract。

21708
29:41:35.527 --> 29:41:40.561
在v2处，我们会得到v2abi然

21709
29:41:40.561 --> 29:41:45.596
而，我们会在透明代理地址加载它。

21710
29:41:45.596 --> 29:41:51.958
这样醚类就知道了，我们会在透明代理地址上调用所有的函数。

21711
29:41:51.958 --> 29:41:57.563
但是这个代理盒子会有ABI (v2)这就是我们想要的。

21712
29:41:57.563 --> 29:42:03.088
现在我们可以说const version = await proxy box。version。

21713
29:42:03.088 --> 29:42:06.296
我们写上console。log version。

21714
29:42:06.296 --> 29:42:14.428
如果我们想在升级之前，把这个和它原来的实现进行比较，我们可以做同样的事情。

21715
29:42:14.428 --> 29:42:21.933
我们可以说const代理框v1，我们实际上称这

21716
29:42:21.933 --> 29:42:29.439
个代理框V表示代理框v1等于这个等价的调用框。

21717
29:42:29.439 --> 29:42:36.944
我们会写const version = weight，右边代理框v1。

21718
29:42:36.944 --> 29:42:44.450
version console。log version，或者版本v1。

21719
29:42:44.450 --> 29:42:51.211
我们称这个为v2, v2，代理框为v2。

21720
29:42:51.211 --> 29:42:54.868
所以我们会得到版本v1会升级。

21721
29:42:54.868 --> 29:43:00.378
然后我们会看到在同一个地址，版本函数现在返回了什么。

21722
29:43:00.378 --> 29:43:02.806
让我们打开终端。

21723
29:43:02.806 --> 29:43:04.953
如果我运行yarn，

21724
29:43:04.953 --> 29:43:15.689
我们的头节点会旋转一个节点会部署我们的admin我们的实现，我们的代理，然后我们的box V到实现。

21725
29:43:15.689 --> 29:43:17.892
我要做一个新的终端。

21726
29:43:17.892 --> 29:43:26.439
我将运行纱线，硬帽运行脚本升级框，即J S破折号网络，本地主机。

21727
29:43:26.439 --> 29:43:29.286
我们会看到这个框在更新。

21728
29:43:29.286 --> 29:43:30.810
这正是我们所看到的。

21729
29:43:30.810 --> 29:43:33.123
然后我们来做，我忘了做。

21730
29:43:33.123 --> 29:43:34.002
在这里串线。

21731
29:43:34.106 --> 29:43:38.481
但它在同一个地址上从版本1到版本2。

21732
29:43:38.481 --> 29:43:44.829
通过这一小段代码，我们已经成功地学会了如何以编程方式升级智能合约。

21733
29:43:44.829 --> 29:43:52.668
现在，就像我说的，在与这一课相关的GitHub回购中，你也可以从打开Zeppelin检查升级插件。

21734
29:43:52.668 --> 29:43:58.029
要处理这个，你只需要执行升级。deploy proxy代理来调

21735
29:43:58.029 --> 29:44:03.391
用Prepare upgrade函数，然后像这样升级升级代理。

21736
29:44:03.391 --> 29:44:08.006
他们也有一个升级教程，一步一步的hardhat，你可以跟随以及。

21737
29:44:08.006 --> 29:44:10.006
现在我知道这是高级部分。

21738
29:44:10.106 --> 29:44:12.731
我知道我们讲得有点快了。

21739
29:44:14.106 --> 29:44:20.021
只需完成本节，您就不仅完成了使您成为真正强大的智能合同开发人员的所有其他部分。

21740
29:44:20.021 --> 29:44:22.751
但你在这里学到了一些非常高级的东西。

21741
29:44:22.751 --> 29:44:29.420
我们研究了一些低级代码，比如委托调用，我们研究了汇编，我们研

21742
29:44:29.420 --> 29:44:36.090
究了这些代理模式，它们能让你成为智能合约领域中杰出的开发者。

21743
29:44:36.090 --> 29:44:43.753
如果你刚刚看完这部分，你应该为自己感到非常非常自豪，因为我们讲得非常快，因为这里有很多先进的信息。

21744
29:44:43.753 --> 29:44:51.820
现在，就像我说的，百分之百，一定要进入讨论选项卡，问问题，与该地区的其他人联系和交谈。

21745
29:44:51.820 --> 29:44:56.405
也许可以看看已经开始的讨论，并开始询问其他学生，开始

21746
29:44:56.405 --> 29:45:00.991
询问其他人他们学到了什么，以及他们的代理进行得如何。

21747
29:45:00.991 --> 29:45:02.296
如果他们做了什么很酷的东西。

21748
29:45:02.296 --> 29:45:10.003
如果你只是很兴奋，你想去展示和展示部分，做一个展示，告诉我，嘿，这是我做这个升级部分的GitHub回购。

21749
29:45:10.003 --> 29:45:16.337
到这里来，为这句话感到兴奋去喝杯咖啡休息去散步去

21750
29:45:16.337 --> 29:45:22.671
健身房去兴奋去告诉你的朋友我们快完成了我们还有两

21751
29:45:22.671 --> 29:45:29.535
节课，然后你就自由了好了，欢迎回到第十七课给硬帽们。

21752
29:45:29.535 --> 29:45:31.249
杜丝，你快完成了。

21753
29:45:31.249 --> 29:45:38.460
在本节中，我已经做了一个视频，讲的是如何用TypeScript和JavaScript中的固体性来编写销子。

21754
29:45:38.460 --> 29:45:41.878
我们只播放这一节的视频。

21755
29:45:41.878 --> 29:45:45.865
我们要展示这个的原因是因为我做了很多工作让这个看起来很好。

21756
29:45:45.865 --> 29:45:48.416
它仍然是令人难以置信的最新的。

21757
29:45:48.416 --> 29:45:51.059
这将在TypeScript和solidity中。

21758
29:45:51.059 --> 29:45:56.805
但是，我们将在视频部分的代码中有JavaScript版本的代码库。

21759
29:45:56.805 --> 29:46:04.664
如果你想要这个增量模板代码的最新版本，你可以使用，你可以选择这个最新的代码，它会进入这个怀疑模板回购。

21760
29:46:04.664 --> 29:46:11.768
我将定期用新的Dao示例和新方法来更新这个回购，以创建疑问或分散自治组织。

21761
29:46:11.768 --> 29:46:15.507
现在，在我们学习如何编码一个怀疑之前，我们应该了解什么是DAO。

21762
29:46:15.507 --> 29:46:18.440
再说一次，我已经做了一个视频，我花了很多功夫。

21763
29:46:18.440 --> 29:46:23.276
我们先从高层次上看一下什么是道琼斯指数，然后再学习如何编码道琼斯指数。

21764
29:46:23.276 --> 29:46:25.950
最后一节是安全与审计。

21765
29:46:25.950 --> 29:46:27.043
我们要把这个做完。

21766
29:46:27.107 --> 29:46:30.090
Bucklin，让我们学习一下什么是道琼斯指数。

21767
29:46:32.107 --> 29:46:35.545
建立一个道琼斯指数，让我们这么做吧。

21768
29:46:39.107 --> 29:46:42.773
自治组织是一个有点超载的术语。

21769
29:46:43.107 --> 29:46:49.623
它通常描述由区块链或智能合约上的一组透明规则管理的任何组。

21770
29:46:49.623 --> 29:46:55.899
我说过载，是因为有人说比特币下跌了，因为矿工可以选择是否升级他们的软件。

21771
29:46:55.899 --> 29:47:01.624
其他人则认为Dows必须使用透明的智能合约，这种合约的规则已经根深蒂固。

21772
29:47:01.624 --> 29:47:07.573
然后其他人认为道只是一个流行词，所以他们就把接力这个名字贴在任何组织上，这样他们就能获得一些影响力。

21773
29:47:07.573 --> 29:47:09.734
这让人很难过，帕特里克。

21774
29:47:09.734 --> 29:47:14.308
不要把它和道琼斯指数搞混了，道琼斯指数是2016

21775
29:47:14.308 --> 29:47:19.074
年道琼斯指数的实现，创下了当时最大的黑客攻击记录。

21776
29:47:19.074 --> 29:47:23.807
所以有很多不同的思考方式道指这个术语有很多不同的用法。

21777
29:47:23.807 --> 29:47:29.831
但本质上，想象一下，如果谷歌的所有用户都被赋予了谷歌下一步应该做什么的投票权。

21778
29:47:29.831 --> 29:47:34.526
投票的规则是不变的，透明的，分散的。

21779
29:47:34.526 --> 29:47:40.070
这解决了信任、中心性和透明度的老问题，并将权力交给

21780
29:47:40.070 --> 29:47:45.615
不同协议和应用程序的用户，而不是一切都在关起门来。

21781
29:47:45.615 --> 29:47:50.927
这个投票部分是这些如何运作去中心化治理的基石，如果你

21782
29:47:50.927 --> 29:47:56.240
愿意的话，它可以被专门通过代码运作的公司或组织总结。

21783
29:47:56.240 --> 29:48:03.767
为了真正理解这一切，我们要深入了解协议的背后它为所有其他的怀疑和复合设定了先例，然后一旦我们了

21784
29:48:03.767 --> 29:48:11.294
解复合，我们就会明白构建其中一个的过程以及所有的权衡，所有不同的架构选择对你的团队意味着什么。

21785
29:48:11.294 --> 29:48:17.785
在我的下一个视频中，我将为开发者提供一个完整的教程，帮助他们自己构建一个这样的工具。

21786
29:48:17.785 --> 29:48:22.525
但是一定要看这个视频的剩余部分因为它会给你所有的架构基础知识。

21787
29:48:22.525 --> 29:48:26.007
所以当你到达那个部分时，你可以做出明智的决定。

21788
29:48:26.007 --> 29:48:28.884
一定要让你和道琼斯的朋友们点击“点赞”和“订阅”按钮。

21789
29:48:28.884 --> 29:48:35.503
因此，当涉及到智能合约时，我们可以继续为您提供地球上最好的工程师第一内容。

21790
29:48:35.503 --> 29:48:36.434
让我们开始吧。

21791
29:48:36.434 --> 29:48:38.499
这里我们有一个复合协议。

21792
29:48:38.499 --> 29:48:44.042
它是一个借贷应用程序，允许用户借贷他们的资产。

21793
29:48:44.107 --> 29:48:46.572
这个应用程序的一切都是在智能合约中构建的。

21794
29:48:46.572 --> 29:48:53.347
通常，他们会想做很多新事情，也许他们想添加一个新的令牌来允许借贷，也许他们

21795
29:48:53.347 --> 29:49:00.123
想改变一些API参数，也许他们想阻止某些货币，他们可能想做很多不同的事情。

21796
29:49:00.123 --> 29:49:05.349
这就是我们要讲到治理的地方，在这里你可以找到一

21797
29:49:05.349 --> 29:49:10.575
个用户界面列出所有的提案和所有不同的投票结果。

21798
29:49:10.575 --> 29:49:15.852
这里是一些治理建议的列表，该协议实际上已经做出了改进。

21799
29:49:15.852 --> 29:49:19.143
让我们来看看其中一个目前正在进行中的提议。

21800
29:49:19.143 --> 29:49:27.293
如果我们点击提案，我们会看到提案的所有内容，谁投了票谁投了反对票，还有提案的历史。

21801
29:49:27.293 --> 29:49:32.654
这些提案的第一件事是有人必须在提案的交易中创建提案。

21802
29:49:32.654 --> 29:49:36.607
我们可以在这里看到提议的交易。

21803
29:49:36.607 --> 29:49:42.589
如果我们点击这个，向下滚动，我们可以看到他们用来提出这个建议的确切参数。

21804
29:49:42.589 --> 29:49:45.583
让我们继续解码输入数据。

21805
29:49:45.583 --> 29:49:48.057
我们可以看到这就是这个提案的样子。

21806
29:49:48.057 --> 29:49:54.370
它们通常的划分方式是它们有一个地址列表和一个调用这些地址的函数列表。

21807
29:49:54.370 --> 29:49:57.683
显然，还有传递这些地址的参数。

21808
29:49:57.683 --> 29:50:06.124
所以这个提议说，嘿，我想在这个地址上呼叫支持市场，在这个地址上设置备用因子。

21809
29:50:06.124 --> 29:50:08.558
这是我们要传递的参数。

21810
29:50:08.558 --> 29:50:10.365
它们显然是用字节编码的。

21811
29:50:10.365 --> 29:50:15.139
这是描述字符串说明它在做什么以及为什么要这样做。

21812
29:50:15.139 --> 29:50:22.023
我们必须进行这个建议治理过程的原因是，这些契约可能具有访问控制，只有这些契约

21813
29:50:22.023 --> 29:50:28.907
的所有者才能实际调用这些do函数，而这两个契约的所有者很可能是这种治理风格。

21814
29:50:28.907 --> 29:50:29.457
和价值观。

21815
29:50:29.457 --> 29:50:35.846
零仅仅意味着我们不会在这些交易中发送任何信息，一旦提案被创建，在短暂

21816
29:50:35.846 --> 29:50:42.235
的延迟后变为活跃状态，这是人们真正开始投票的时候，提案和投票行为之间

21817
29:50:42.235 --> 29:50:48.813
的延迟可以被改变或修改，这取决于你的怀疑，然后人们有一些时间开始投票。

21818
29:50:48.813 --> 29:50:57.732
如果它通过了，就像这个压倒性地通过了，它达到了成功，我们再次点击这个事务，然后我们进入复合治理契约。

21819
29:50:57.732 --> 29:51:04.943
我们向下滚动到合同，权利作为代理，我们实际上可以看到人们

21820
29:51:04.943 --> 29:51:12.412
调用投票的确切功能，即投票投票，投票，签名投票和理性投票。

21821
29:51:12.412 --> 29:51:16.537
我们会在下一集视频中讨论它们之间的确切区别。

21822
29:51:16.537 --> 29:51:19.607
但这些是它们实际调用的函数。

21823
29:51:19.607 --> 29:51:24.124
如果你去复合应用，我们去投票，这是一个用户界

21824
29:51:24.124 --> 29:51:28.848
面，你可以投票，让它更容易，如果你不是技术通。

21825
29:51:28.848 --> 29:51:31.916
所以你可以直接在财经的app。compound中投票。

21826
29:51:31.916 --> 29:51:34.530
或者您可以自己发送交易。

21827
29:51:34.530 --> 29:51:36.287
一旦所有的投票都发生了。

21828
29:51:36.287 --> 29:51:38.188
它到达这个排队阶段。

21829
29:51:38.188 --> 29:51:43.305
那么排队是什么意思呢?在提案真正生效之

21830
29:51:43.305 --> 29:51:48.693
前，提案通过和执行之间有一个最小的延迟。

21831
29:51:48.693 --> 29:51:51.640
所以必须有人调用这个可爱的函数。

21832
29:51:51.640 --> 29:51:54.506
而且只有在投票通过的情况下才能宣布选举结果。

21833
29:51:54.506 --> 29:51:59.357
它说，好的，邮政ID已经被提示，我们很快就会执行它。

21834
29:51:59.357 --> 29:52:04.158
现在，如果我们看一个不同的提议，比如这个，我们可以看

21835
29:52:04.158 --> 29:52:09.145
到它已经被执行了，我们可以看到有人叫这个被执行的函数。

21836
29:52:09.145 --> 29:52:11.475
他们执行了提案A的细节。

21837
29:52:11.475 --> 29:52:17.551
这将是一个完整的提案生命周期的例子通过这个过程。

21838
29:52:17.551 --> 29:52:22.025
现在有一些甚至失败了，很多人投了反对票。

21839
29:52:22.025 --> 29:52:27.376
如果你向下滚动，你可以看到它被创建了，它是活跃的，大多数人投了反对票。

21840
29:52:27.376 --> 29:52:28.963
到此为止。

21841
29:52:28.963 --> 29:52:35.267
现在，通常情况下，仅仅通过这些提案中的一个并不足以真正获得一些选票，你通常需

21842
29:52:35.267 --> 29:52:41.571
要一个论坛或某种类型的讨论场所来讨论这些提案，以及你为什么喜欢或不喜欢它们。

21843
29:52:41.571 --> 29:52:47.907
通常情况下，话语是人们争论为什么某事是好的，或者为什么某事是坏的主要场所之一。

21844
29:52:47.907 --> 29:52:50.522
所以人们可以对这些改变进行投票。

21845
29:52:50.522 --> 29:52:59.415
再说一遍，snapshot可能是其中一种工具，你可以用它来判断你的社区是否需要一些东西，甚至在它进行投票之前，你可以加入其中一个，

21846
29:52:59.415 --> 29:53:08.445
用你的令牌实际上对事物进行投票，而不执行它们，只是为了获得情绪，或者像我之前说的，你可以构建你的协议，快照实际上帮助你进行投票过程。

21847
29:53:08.445 --> 29:53:13.589
好了，现在你已经看到了影响投票的所有其他细节的协议。

21848
29:53:13.589 --> 29:53:21.549
现在，你知道，现在我们知道了一个怀疑是什么样子的，让我们谈谈构建其中一个的架构和工具，以及它们之间的权衡。

21849
29:53:21.549 --> 29:53:25.433
首先要讨论的是投票机制。

21850
29:53:25.433 --> 29:53:33.657
现在，在去中心化治理中投票是至关重要的，因为有时他们确实需要更新和改变，以跟上时代。

21851
29:53:33.657 --> 29:53:39.624
不是所有的协议都需要有一个陶氏指数，但那些需要有疑问的协议需要一种让参与者参与的方式。

21852
29:53:39.624 --> 29:53:44.210
这是问他告诉你的社区的最重要的问题之一。

21853
29:53:44.210 --> 29:53:48.725
我如何参与?我该如何面对这种怀疑?我如何帮

21854
29:53:48.725 --> 29:53:53.456
助你做决定，你会发现这是一个很难解决的问题。

21855
29:53:53.456 --> 29:53:59.844
现在，解决这个问题的一个简单方法是使用ERC 20或NFT令牌作为投票权。

21856
29:53:59.844 --> 29:54:07.762
类似于我们看到的复合使用comp令牌来为不同的提案投票似乎很简单，对吧?问题解决了，格雷。

21857
29:54:07.762 --> 29:54:11.175
现在，这实际上可能是解决某些疑问的正确方法。

21858
29:54:11.175 --> 29:54:13.821
但它也存在实际上不那么公平的风险。

21859
29:54:13.821 --> 29:54:18.667
因为当你把投票权代币化的时候，你实际上是在拍卖这个

21860
29:54:18.667 --> 29:54:23.707
投票权给那些最有钱的人，那些最有钱的人可以选择改变。

21861
29:54:23.707 --> 29:54:29.135
所以如果只有富人有权投票，那么很有可能协议中的所有变化都

21862
29:54:29.135 --> 29:54:34.757
会让富人受益，这对我们现在的世界来说似乎并不是很大的改善。

21863
29:54:34.757 --> 29:54:41.419
如果T很有趣，因为它们有不可替代的成分，但是，即使它们仍然会遇到这个问题。

21864
29:54:41.419 --> 29:54:45.547
此外，如果你买了一大堆选票，你就做出了一个糟糕的决定，然后卖掉了所有的选票。

21865
29:54:45.547 --> 29:54:49.857
你作为一个个体并不会受到惩罚，你只是在惩罚整个群体。

21866
29:54:49.857 --> 29:54:54.724
但如果你是恶意的，你可以毫发无损地离开现在再说一次，这

21867
29:54:54.724 --> 29:54:59.773
个投票机制对一些群体是正确的，但对另一些群体，可能不是。

21868
29:54:59.773 --> 29:55:02.428
这完全取决于你的底层社区设置是什么样子的。

21869
29:55:02.428 --> 29:55:04.868
下一个我们要讲的是博弈中的风险。

21870
29:55:04.868 --> 29:55:10.213
metal已经写了很多关于这方面的文章，我强烈建议你阅读他的文章，链接在描述

21871
29:55:10.213 --> 29:55:15.700
中，看看游戏方法中的皮肤意味着无论何时你做了一个决定，你的投票都会被记录下来。

21872
29:55:15.700 --> 29:55:21.022
如果这个决定导致了一个糟糕的结果，您的代币将被砍掉。

21873
29:55:21.107 --> 29:55:25.673
你为你的道和你的礼仪做了邪恶或错误的决定，你会受到惩罚。

21874
29:55:25.673 --> 29:55:31.994
我喜欢这种心态，因为即使你买了一吨代币，并决定用它生病，你可以为你的错误决定负责。

21875
29:55:31.994 --> 29:55:38.188
现在，最困难的部分是，作为一个社区，我们如何做出决定?什么是

21876
29:55:38.188 --> 29:55:44.589
坏结果?我们要如何惩罚这些人?这很简单，因为答案是，我不确定。

21877
29:55:44.589 --> 29:55:51.058
现在，这个投票机制的第三个方法可能是最有趣的一个，但也是最难实现的一个。

21878
29:55:51.107 --> 29:55:54.218
这是人格或参与的证明。

21879
29:55:55.107 --> 29:56:00.710
仅仅因为使用了该协议，所有复合协议的用户都获得了一票。

21880
29:56:00.710 --> 29:56:04.520
即使他们有1000个钱包，他们也会使用协议。

21881
29:56:04.520 --> 29:56:11.434
一个人意味着一票，这将是令人惊讶的，一个更公平的实现，选票实际上不能被收买。

21882
29:56:11.434 --> 29:56:18.159
然而，问题在于所谓的公民抵抗，我们如何才能确保一票等于一个参与者，

21883
29:56:18.159 --> 29:56:24.477
而不是一个参与者假装成1000个不同的人，从而获得更多的选票。

21884
29:56:24.477 --> 29:56:26.027
这个方法还没有被真正解决。

21885
29:56:26.027 --> 29:56:34.714
但我敢打赌，某个非常聪明的工程师会做一些惊人的链链集成，因为人格证明基本上只是链外数据，可以在链上传递。

21886
29:56:34.714 --> 29:56:36.916
这正是通灵的亮点所在。

21887
29:56:36.916 --> 29:56:42.503
你可以看到所有这些方法甚至更多你可能想到的方法都不是那么牵强。

21888
29:56:42.503 --> 29:56:46.457
我们在现实世界中也能看到完全相同的方法。

21889
29:56:46.457 --> 29:56:53.381
人格证明或参与证明可能与我们每天看到的常规政府投票完全相同。

21890
29:56:53.381 --> 29:57:00.726
在美国，至少有一个人可以投票给一个总统，你不能到处制造一堆假人来投票给总统。

21891
29:57:00.726 --> 29:57:08.503
但在公司中ERC 20投票标准是适用的，你拥有的公司股份越多你在公司的投票权就越大。

21892
29:57:08.503 --> 29:57:13.107
因此，我们可以将现实世界与智能合约中投票和治理的工作方式进行类比。

21893
29:57:13.107 --> 29:57:17.276
事实上，你应该做对比，从网络到太空中寻找灵感。

21894
29:57:17.276 --> 29:57:24.972
现在实施投票时,我把它们分为两类链投票,投票链链投票就是我们看到的化合物,

21895
29:57:24.972 --> 29:57:32.252
聪明的合同链,你的选民,你调用某些函数称为投票与元面具分类帐等等,发送

21896
29:57:32.252 --> 29:57:39.532
个事务和投票,投票恭喜,你可以穿你的小贴纸现在称之为函数发送一个事务,

21897
29:57:39.532 --> 29:57:46.812
送一个事务,哪些交易使用起来有点烦人，有点昂贵?哦，对了，我想象一下，

21898
29:57:46.812 --> 29:57:55.551
的社区有1万人，每个人投票要花费100美元，你现在要花费你的社区100万美元。

21899
29:57:55.551 --> 29:57:57.652
任何时候你想改变什么。

21900
29:57:57.652 --> 29:58:03.125
这显然是疯狂的，而且对您的社区来说不是很可持续的，因为架构真的很简单。

21901
29:58:03.125 --> 29:58:05.693
所有东西都是透明的，所有东西都在链上。

21902
29:58:05.693 --> 29:58:06.630
这真的很好。

21903
29:58:06.630 --> 29:58:10.460
但是，是的，缺点是你可能会打破很多人的银行账户。

21904
29:58:10.460 --> 29:58:15.345
现在有很多这样的变化来帮助解决这些问题，特别是气体问题。

21905
29:58:15.345 --> 29:58:20.151
其中一个让我非常兴奋的是这个叫做州长席位的地方，他们使用一

21906
29:58:20.151 --> 29:58:25.124
些随机抽样来做一些二次投票来帮助减少成本同时增加民众的反抗。

21907
29:58:25.124 --> 29:58:28.647
如果你想了解更多，一定要在描述中阅读。

21908
29:58:28.647 --> 29:58:30.810
链式投票是最简单的。

21909
29:58:30.810 --> 29:58:33.951
我们来谈谈非链式投票。

21910
29:58:33.951 --> 29:58:41.622
为了把投票投到去中心化的环境，放松，放松，你可以投到去中心化链，但仍然拥有100%的去中心

21911
29:58:41.622 --> 29:58:49.294
化，你实际上可以签署一个交易，签署一个投票，而不实际发送到区块链，因此不实际花费任何汽油。

21912
29:58:49.294 --> 29:58:57.360
相反，你能做的是将签名事务发送到去中心化数据库，比如IPFS，计算IPFS中的所有选票。

21913
29:58:57.360 --> 29:59:05.039
然后，当时间到来时，将数据的结果通过Oracle之类的链链接传递到区块链，所有这些都在单个事务中完成。

21914
29:59:05.039 --> 29:59:13.660
或者，你可以做的是在一个交易中重播所有相同的交易以节省汽油，这可以减少高达99%的投票成本。

21915
29:59:13.660 --> 29:59:19.203
现在，这是一个实现，最流行的实现方式之一是通过快照。

21916
29:59:19.203 --> 29:59:26.840
我非常渴望有人能做一个链式集成因为这样会更安全，更可靠，更好等等，等等，为它而死。

21917
29:59:26.840 --> 29:59:28.583
这是你们的行动号召去建造这个东西。

21918
29:59:28.583 --> 29:59:29.154
此选项。

21919
29:59:29.154 --> 29:59:33.759
显然，投票机制为社区节省了大量的资源，并且可以更

21920
29:59:33.759 --> 29:59:38.365
有效地存储这些事务，然而，它需要非常谨慎地实现。

21921
29:59:38.365 --> 29:59:45.881
如果您通过集中式Oracle运行整个Dow，那么您实际上是重新引入了一个集中式中介，并破坏了应用程序的良好质量。

21922
29:59:45.881 --> 29:59:46.703
所以不要这样做。

21923
29:59:46.703 --> 29:59:50.300
如果你做到了视频的这一点，给自己一点鼓励。

21924
29:59:50.300 --> 29:59:51.412
你做得很好。

21925
29:59:51.412 --> 29:59:51.895
太棒了。

21926
29:59:51.895 --> 29:59:57.040
就像我说的，在这之后我会有一个视频，它将从头到尾地向你展示如何从零开始构建

21927
29:59:57.040 --> 30:00:02.325
一个这样的东西，让我们来学习一些工具，你可以使用它们来帮助你更快地跟上进度。

21928
30:00:02.325 --> 30:00:09.464
现在有很多无代码的解决方案可以用来建造一个陶叠阿拉贡销子。

21929
30:00:09.464 --> 30:00:17.779
开个玩笑，这是阿拉贡，殖民地和道屋都是可以帮助你运行道和建立怀疑的替代方案。

21930
30:00:17.779 --> 30:00:24.336
但是，如果您想要更细粒度的控制，并且不想支付与这些协议相关的任何费用，那么您可能希望从头开始。

21931
30:00:24.336 --> 30:00:31.395
现在让我们讨论一些您可以使用的更多的Cody解决方案，快照是最流行的工具之一，用于获取Dao的情绪。

21932
30:00:31.395 --> 30:00:39.044
实际执行时，用户可以用他们实际的令牌投票通过这个协议，这些交易被存储在IPFS中。

21933
30:00:39.107 --> 30:00:41.125
但实际上没有一个会被执行。

21934
30:00:42.107 --> 30:00:47.074
选择，这是一个很好的方式来了解你的道琼斯想要做什么。

21935
30:00:47.074 --> 30:00:55.652
此外，你还可以发送交易并执行投票，强烈建议你使用Zodiac，这是一套数据库工具，你可以将其实现到

21936
30:00:55.652 --> 30:01:04.407
你的Dallas中，计数是另一种ui，它可以让人们看到并实际投票，并通过用户界面与这些智能合约交互。

21937
30:01:04.407 --> 30:01:09.526
所以那些不知道Gnosis安全的人，你绝对应该知道安全是一个多SIG钱包。

21938
30:01:09.526 --> 30:01:15.805
我把它列在列表上的原因是，尽管它增加了一些中心性的成分，大多数的销子在开始的时候，

21939
30:01:15.805 --> 30:01:21.779
可能会以某种类型的中心性开始，当你没有1000人等待投票的时候，更快会更容易。

21940
30:01:21.779 --> 30:01:27.798
在开始的时候，任何协议都在某种程度上是集中的，使用multisig，我们通过

21941
30:01:27.798 --> 30:01:33.977
一些关键成员进行投票，在开始的时候对你的拨号盘来说是很好的，通常也是紧急情况。

21942
30:01:33.977 --> 30:01:41.422
但请记住，当你增加其中一个时，你就增加了这种程度的中心性，当然，我们喜欢的开放和契约就会开放和契约。

21943
30:01:41.422 --> 30:01:44.522
我们的Dao代码将基于这些契约。

21944
30:01:44.522 --> 30:01:46.345
好了，这就是所有的工具。

21945
30:01:46.345 --> 30:01:47.488
这就是架构。

21946
30:01:47.488 --> 30:01:54.154
在我讲法律之前还有一件事，Dows的未来很有趣因为我们刚才讲过的这些原因，但

21947
30:01:54.154 --> 30:02:00.820
尤其是在法律方面，怀疑公司和其他公司遵守同样的规定有意义吗?为什么你要强迫它

21948
30:02:00.820 --> 30:02:07.486
去做什么呢，你必须强制他们以某种方式投票如果政府让你这么做的话，这有点灰色，

21949
30:02:07.486 --> 30:02:14.679
很难确定谁应该负责现在美国至少你可以建立自己的道琼斯指数并在怀俄明州得到法律认可。

21950
30:02:14.679 --> 30:02:16.172
这是我想做的事。

21951
30:02:16.172 --> 30:02:18.435
所以我们只需要看看会发生什么。

21952
30:02:18.435 --> 30:02:23.365
哦，在这一点上，你已经被注入了陶氏所需的所有知识，你需

21953
30:02:23.365 --> 30:02:28.478
要成功和发展这个令人惊叹的新技术和这些令人惊叹的新概念。

21954
30:02:28.478 --> 30:02:29.819
我发现他们杀了孩子。

21955
30:02:29.819 --> 30:02:32.446
好吧，你听到他说的了是时候开工了。

21956
30:02:32.446 --> 30:02:37.958
就像我们说的，所有的代码都位

21957
30:02:37.958 --> 30:02:43.865
于小于17的位置，让我们开始。

21958
30:02:44.108 --> 30:02:52.371
在这个视频中，我们将向你们展示如何通过合成来建立你自己的怀疑现在这将100%关于链式投票和链式治理。

21959
30:02:52.371 --> 30:02:59.017
我们将向你展示最简单的方法，旋转一个非ft或ERC 20投票类型，所有使用固体和硬帽。

21960
30:02:59.017 --> 30:03:07.091
如果你还没有看过我上一集关于Dows体系结构的视频，那么一定要先看那个视频，然后再看这个视频。

21961
30:03:07.091 --> 30:03:15.026
因为那个视频解释了我们在这里所做的一切背后的哲学我们将使用开放，契约和一个硬帽框架来建立这一切。

21962
30:03:15.026 --> 30:03:21.108
如果你想看一个全新的或python版本的操作，请查看描述中的链接，因为我们最近在chainlink黑客马拉松上做了一个视频。

21963
30:03:21.108 --> 30:03:28.253
另外，我们知道，因为我们是100%用链条煤气，所以费用会很贵。

21964
30:03:28.253 --> 30:03:34.822
所以我真的很期待有人做一个链连接加上IPFS加上快照集成这样我们就可以在链外完成所有这些。

21965
30:03:34.822 --> 30:03:37.694
一旦它存在，你们已经知道了，我会做一个关于它的教程。

21966
30:03:37.694 --> 30:03:43.941
如果你喜欢这种风格的内容，一定要点击喜欢按钮，订阅并在评论区留言，告诉我你想看什么。

21967
30:03:43.941 --> 30:03:47.624
接下来，让我知道您希望如何增强您的智能合约开发人员体验。

21968
30:03:47.624 --> 30:03:48.590
让我们开始吧。

21969
30:03:48.590 --> 30:03:54.578
这就是我们要建立的东西，我们会有一个非常基础的智能合

21970
30:03:54.578 --> 30:04:00.567
约，它叫box它能做的就是存储一个值然后检索一个值。

21971
30:04:00.567 --> 30:04:02.534
但问题是，它是可以拥有的。

21972
30:04:02.534 --> 30:04:09.642
只有契约的所有者才能调用store函数并猜出所有者是谁所有者是疑问。

21973
30:04:09.642 --> 30:04:14.534
所以只有通过治理的过程，任何人都可以在这里存储不同的功能。

21974
30:04:14.534 --> 30:04:19.528
一旦我们完成了，我们将经历提议投票排队的整个过程，

21975
30:04:19.528 --> 30:04:24.723
然后在Dao中执行一个事务来更新我们的Bach契约。

21976
30:04:24.723 --> 30:04:29.824
这就是这些Dao设置的美妙之处在于它们是完全模块化的。

21977
30:04:29.824 --> 30:04:35.490
所以当我经历整个过程时，我会在这里做Hardhead测试，我

21978
30:04:35.490 --> 30:04:41.157
现在的测试是用来做所有事情的，我们会看到道琼斯指数的每一步。

21979
30:04:41.157 --> 30:04:44.311
我们看到方框的起始值是0。

21980
30:04:44.311 --> 30:04:47.337
然后所有这些东西都将进入治理过程。

21981
30:04:47.337 --> 30:04:48.353
这些只是一些笔记。

21982
30:04:48.353 --> 30:04:51.012
人们基本上是在投票、排队和执行。

21983
30:04:51.012 --> 30:04:57.684
最后，我们通过一个投票过程来确定盒子合同的价值。

21984
30:04:57.684 --> 30:04:59.944
这正是我们今天要向你们展示的方法。

21985
30:04:59.944 --> 30:05:08.841
记住，我们这里要做的所有代码都在我的怀疑模板GitHub repo中，所以如果你迷路了，可以参考这个来开始。

21986
30:05:08.841 --> 30:05:15.018
另外，如果你想看这个的python版本，请回到downmix，主要的事情是，

21987
30:05:15.018 --> 30:05:21.358
尽管所有的契约都是一样的，无论什么布朗尼硬帽，dab工具，代工厂，这都没关系。

21988
30:05:21.358 --> 30:05:24.369
这部分的第一部分是完全一样的。

21989
30:05:24.369 --> 30:05:26.631
这是我们的议程。

21990
30:05:26.631 --> 30:05:28.726
首先，我们要写智能合约。

21991
30:05:28.726 --> 30:05:33.950
如果你不熟悉Hardhead，没关系，我们会先做智能合约，然后再写部署脚本。

21992
30:05:33.950 --> 30:05:36.822
这就是你的硬帽知识将发挥作用的地方。

21993
30:05:36.822 --> 30:05:41.049
我们将在TypeScript中编写部署脚本，因为TypeScript非常了不起。

21994
30:05:41.049 --> 30:05:45.955
如果你不熟悉TypeScript，我建议你用JavaScript重写它，然后做一个JavaScript版本。

21995
30:05:45.955 --> 30:05:52.089
最后，我们将编写一些脚本，用部署的契约与治理进行交互。

21996
30:05:52.089 --> 30:05:57.945
现在，快速说明一下，这不是我最初构建它的方式，我不只是阅读智能合约，编写部署脚本，

21997
30:05:57.945 --> 30:06:03.659
编写脚本，然后进行测试，然后我完成了，我在测试，智能合约，部署脚本之间来回切换。

21998
30:06:03.659 --> 30:06:06.962
如果你在想，哦，我的天，这对他来说太容易了。

21999
30:06:06.962 --> 30:06:07.591
所以无缝。

22000
30:06:07.591 --> 30:06:10.552
当我最初编写这段代码时，它有很多来回。

22001
30:06:10.552 --> 30:06:14.076
这就是你应该如何进行开发，你将在测试和智能合约之间转换。

22002
30:06:14.108 --> 30:06:18.108
此外，在本教程中，我们将向你展示一些恶心的硬头技能。

22003
30:06:18.108 --> 30:06:24.337
所以你们不仅要学习如何建立道琼斯指数，还要学习一些非常高级的硬头牌技能。

22004
30:06:24.337 --> 30:06:25.730
让我们开始吧。

22005
30:06:25.730 --> 30:06:26.877
让我们开始吧。

22006
30:06:26.877 --> 30:06:29.465
我使用的代码编辑器是Visual Studio代码。

22007
30:06:29.465 --> 30:06:32.457
因此，请确保您有一个代码编辑器，可以随时使用。

22008
30:06:32.457 --> 30:06:35.556
这里你需要一些先决条件。

22009
30:06:35.556 --> 30:06:40.575
前提条件在GitHub存储库中，我们需要Git，而不是J。

22010
30:06:40.575 --> 30:06:48.462
纱线，如果你只是想克隆这个回购，并按照这里的说明开始，你完全可以，然后你甚至不需要从头开始构建它。

22011
30:06:48.462 --> 30:06:50.338
但是我们想要学习从零开始建造它。

22012
30:06:50.338 --> 30:06:52.548
让我们开始gitusdash版本。

22013
30:06:52.548 --> 30:06:55.937
很好，我们没有破折号版本。

22014
30:06:56.108 --> 30:06:58.708
很好，我们有节点，然后纱线破折号版本。

22015
30:06:59.108 --> 30:07:00.338
我们有纱线，可以开始了。

22016
30:07:01.108 --> 30:07:04.882
我们将在这里为包安装它将是一个开发依赖。

22017
30:07:04.882 --> 30:07:11.308
所以我们要做的第一件事是做纱线，添加dash Dev，安全帽，如果你还没有的话。

22018
30:07:11.308 --> 30:07:16.822
在文件夹中，我们会有node modules package。JSON readme和一个锁。

22019
30:07:16.822 --> 30:07:21.318
当然，现在我们有了，我们可以运行纱线RDAP，我们将得到硬帽CLI。

22020
30:07:21.318 --> 30:07:27.862
我们会把所有这些东西都放在这里，我们会创建一个空hardhat。config。js，我们会把它变成TypeScript。

22021
30:07:27.862 --> 30:07:30.704
高级示例TypeScript项目有一堆我不喜欢的东西。

22022
30:07:30.704 --> 30:07:32.536
所以我们要创建一个空的硬磁头。

22023
30:07:32.536 --> 30:07:32.857
配置。

22024
30:07:32.857 --> 30:07:32.964
js。

22025
30:07:32.964 --> 30:07:35.318
太好了，我们有一个小安全帽。

22026
30:07:35.318 --> 30:07:35.739
配置。

22027
30:07:35.739 --> 30:07:35.879
js。

22028
30:07:35.879 --> 30:07:39.894
现在让我们继续创建一个文件夹，或者说是合同文件夹。

22029
30:07:39.894 --> 30:07:42.548
这就是我们要添加所有契约的地方。

22030
30:07:42.548 --> 30:07:50.353
我们需要的第一个契约是我们想要治理的契约，在我们的例子中是box。soul。

22031
30:07:50.353 --> 30:07:56.308
现在，我要复制粘贴我的方框，这里的灵魂，因为它不是特别有趣。

22032
30:07:56.308 --> 30:07:58.727
你可以在这里写任何你想写的东西。

22033
30:07:58.727 --> 30:08:05.786
请随意暂停视频，从我的GitHub回购中复制粘贴，创建你自己的治理合同，你想玩的，或在这里做任何你想做的。

22034
30:08:05.786 --> 30:08:13.574
但对我们来说，我们只有一个存储函数，一个检索函数，一个事件，还有一个私有值我们会存储和检索它。

22035
30:08:13.574 --> 30:08:14.507
就是这样。

22036
30:08:14.507 --> 30:08:16.697
当然，我们想解决这个问题。

22037
30:08:16.697 --> 30:08:20.295
我们从openzeppelin的合同中进口，这是惊人的。

22038
30:08:20.295 --> 30:08:25.974
我们要加上这个我们要做yarn，加上dash Dev, at打开合同。

22039
30:08:25.974 --> 30:08:28.633
这样就可以去掉盒子了。

22040
30:08:28.633 --> 30:08:29.565
这是所有。

22041
30:08:29.565 --> 30:08:31.005
让我们重新打开盒子。

22042
30:08:31.005 --> 30:08:33.755
看来我们绕了个弯子才达到那个完美的境界。

22043
30:08:33.755 --> 30:08:38.429
至于扩展，我用的是固体，一个Blonko，狭缝扩展。

22044
30:08:38.429 --> 30:08:40.676
这就是我们得到这些美妙的绒毛的原因。

22045
30:08:40.676 --> 30:08:40.986
太好了。

22046
30:08:40.986 --> 30:08:47.908
现在我们要检查这个是否编译如果使用remix，你可以用remix hard hat编译，你会看到我们是如何编译的。

22047
30:08:47.908 --> 30:08:52.060
或者如果你用Browning，我们只是想看看这个编译是否正确。

22048
30:08:52.108 --> 30:08:54.452
所以run yarn有了一个不小的打击Compile。

22049
30:08:56.108 --> 30:08:59.686
一些编译错误，因为我们需要更新这个，让我们用这8个。

22050
30:08:59.686 --> 30:09:01.791
我们会试着再编译一次。

22051
30:09:01.791 --> 30:09:04.768
完美看起来像是编译成功了。

22052
30:09:04.768 --> 30:09:08.041
看这里，我们的合同确实在这里。

22053
30:09:08.041 --> 30:09:10.371
好了，很好，简单的部分都搞定了。

22054
30:09:10.371 --> 30:09:10.792
了。

22055
30:09:10.792 --> 30:09:11.739
真快啊。

22056
30:09:11.739 --> 30:09:13.415
现在让我们开始创建下一部分。

22057
30:09:13.415 --> 30:09:14.883
让我们创建治理部分。

22058
30:09:14.883 --> 30:09:21.832
所以我们要做的就是建立这个治理平台我们要在ERC的基础上建立它。

22059
30:09:21.832 --> 30:09:24.353
20标准，所以你会得到一个ERC 20代币。

22060
30:09:24.353 --> 30:09:27.008
这将是你可以投票的代币。

22061
30:09:27.108 --> 30:09:31.418
让我们创建一个名为governance token的新文件。

22062
30:09:32.108 --> 30:09:34.006
所有治理令牌。Sol。

22063
30:09:36.108 --> 30:09:37.531
我们用来投票的代币。

22064
30:09:38.108 --> 30:09:40.076
创建一个正常的ERC 20令牌。

22065
30:09:42.108 --> 30:09:45.398
让它治理一个碗，你马上就会明白我的意思。

22066
30:09:45.398 --> 30:09:50.237
让我们继续设置这个spdx许可标识符。

22067
30:09:50.237 --> 30:09:56.701
这是MIT的pragma solidity我们用0。

22068
30:09:56.701 --> 30:09:56.785
8.

22069
30:09:56.785 --> 30:10:03.344
然后我们会做合约治理令牌，然后我们会说，是ERC 20，我将继续导入openzeppelin，

22070
30:10:03.344 --> 30:10:09.624
因为open Zeppelin有一个包，里面基本上有我们需要的ERC 20令牌的所有东西。

22071
30:10:09.624 --> 30:10:16.000
我们会说import at open Zeppelin /合约/令牌/ ERC

22072
30:10:16.000 --> 30:10:26.954
20x我们可以去他们的github openzeppelin合同令牌，你的C 20我们会做ERC 20 Dotto，我们现在这样做。

22073
30:10:27.108 --> 30:10:29.002
令牌，使用你的c20 ditzel。

22074
30:10:31.108 --> 30:10:32.901
不要担心这个。

22075
30:10:35.108 --> 30:10:39.610
公共存储最大供应，这是最好的做法，但没关系，我们会给这个最大

22076
30:10:39.610 --> 30:10:44.264
供应这么多将是1-234-567-8910 12345678。

22077
30:10:44.264 --> 30:10:49.026
这是100万，我们要发行100万枚代币。

22078
30:10:49.026 --> 30:10:53.885
然后我们会创建构造函数构造或者你的c20。

22079
30:10:53.885 --> 30:10:59.358
给它一个治理令牌作为名称，然后我们的符号将是GT。

22080
30:10:59.358 --> 30:11:07.463
对于那些不知道的人，当你在构造函数中继承另一个契约时，你也可以使用那个继承的契约构造函数。

22081
30:11:07.463 --> 30:11:14.829
事实上，我认为你必须，所以治理令牌G团队，然后我们甚至会调用其中一个ERC 20函数叫做mint。

22082
30:11:14.829 --> 30:11:22.179
我们会给发送者发信息，所以谁部署了ERC 20合同就意味着他们拥有一切，所有的最大供应。

22083
30:11:22.179 --> 30:11:26.076
通常情况下，如果这是一个正常的ERC 20代币，你就完成了。

22084
30:11:26.076 --> 30:11:28.358
但这不是一个普通的ERC 20代币。

22085
30:11:28.358 --> 30:11:33.836
看，当我们进行投票时，我们需要确保它是公平的，想象

22086
30:11:33.836 --> 30:11:39.314
一下，有人知道一个热门提案即将提出，他们想要投票。

22087
30:11:39.314 --> 30:11:42.591
所以他们买了很多代币。

22088
30:11:42.591 --> 30:11:46.058
投票结束后他们就把它扔了。

22089
30:11:46.058 --> 30:11:47.616
我们希望避免这种情况。

22090
30:11:47.616 --> 30:11:51.608
我们希望避免人们只是通过买卖代币来参与治理。

22091
30:11:51.608 --> 30:11:57.413
我们所做的就是创建一个快照，记录人们在某个区块

22092
30:11:57.413 --> 30:12:03.219
拥有多少代币，记录人们在某个区块拥有多少代币。

22093
30:12:03.219 --> 30:12:10.231
我们想要确保，一旦提案通过，我们实际上从过去的快照中选择一个我们想要使用的这种激

22094
30:12:10.231 --> 30:12:17.420
励人们不只是在提案通过时跳进去，然后跳出去因为一旦提案通过，它使用了过去的块快照。

22095
30:12:17.420 --> 30:12:20.233
所以我们需要做一点改变。

22096
30:12:20.233 --> 30:12:26.493
我们要把这个从ERC 20改成ERC 20投票，我们实际上可以

22097
30:12:26.493 --> 30:12:32.753
在打开的齐柏林飞艇和扩展中看到这个灵魂契约的ERC 20投票。

22098
30:12:32.753 --> 30:12:39.483
如果我们回到国税局的GitHub，我们可以看到ERC 20票，他们也有一个快照，非常相似。

22099
30:12:39.483 --> 30:12:42.954
一些主要的功能是它有这些检查点。

22100
30:12:42.954 --> 30:12:51.562
所以这些检查点基本上是，嘿，快照是什么?有很多检查点，你也可以把你的代币委托给不同的人。

22101
30:12:51.562 --> 30:12:53.688
所以你可能无法真正投票。

22102
30:12:53.688 --> 30:12:56.298
所以你说，嘿，我要把我的代币给别人。

22103
30:12:56.298 --> 30:13:01.410
你可以知道某人通过了多少票，通过了多少票，或者应

22104
30:13:01.410 --> 30:13:06.737
用它有所有这些功能，使这个令牌成为更好的投票工具。

22105
30:13:06.737 --> 30:13:08.285
对了就好多了。

22106
30:13:08.285 --> 30:13:13.722
我们会说，我们的合约治理令牌是erc20 votes我们只需要添加

22107
30:13:13.722 --> 30:13:19.160
额外的构造函数，这个erc20 permit，抱歉，我复制粘贴了。

22108
30:13:19.160 --> 30:13:21.123
ERC 20允许治理令牌。

22109
30:13:21.123 --> 30:13:27.930
现在我们有一个治理令牌它更有能力进行实际的投票，因为快照有这

22110
30:13:27.930 --> 30:13:34.737
个委派功能，它有这些检查点，它会更好地以公平的方式进行投票。

22111
30:13:34.737 --> 30:13:38.785
我们唯一需要做的是，我们需要添加一些重写。

22112
30:13:38.785 --> 30:13:46.980
我们说的是固体性所要求的覆盖函数下面的函数。

22113
30:13:47.108 --> 30:13:48.970
这部分有点无聊。

22114
30:13:50.108 --> 30:13:53.780
从我的GitHub复制粘贴它。

22115
30:13:54.108 --> 30:13:57.933
我们所做的是，每当我们在token转移之后做这个，

22116
30:13:57.933 --> 30:14:04.665
当我们转移一个token的时候，我们要确保我们调用ERC 20投票的token转移之后。

22117
30:14:04.665 --> 30:14:09.810
我们这样做的原因是因为我们想确保快照被更新了，

22118
30:14:09.810 --> 30:14:14.733
我们想确保我们知道每个块有多少人有多少令牌。

22119
30:14:14.733 --> 30:14:16.042
薄荷也是一样。

22120
30:14:16.042 --> 30:14:23.853
燃烧也是一样，我们想要确保我们总是知道人们在不同的街区或不同的检查点有多少代币。

22121
30:14:23.853 --> 30:14:27.462
这是最重要的一点你要在哪个检查点使用代币投票。

22122
30:14:27.462 --> 30:14:27.849
太酷了。

22123
30:14:27.849 --> 30:14:34.853
你可以从GitHub上复制它，如果你想的话，你甚至可以尝试教程的其余部分，看看你的表现如何。

22124
30:14:34.853 --> 30:14:35.348
但很酷。

22125
30:14:35.348 --> 30:14:40.145
所以现在我们有了一个治理令牌和ERC 20令牌，可以用于治理。

22126
30:14:40.145 --> 30:14:41.877
让我们试着编译它。

22127
30:14:41.877 --> 30:14:43.569
纱线硬头编译。

22128
30:14:43.569 --> 30:14:47.088
很好，看起来编译成功了。

22129
30:14:47.088 --> 30:14:47.568
完美的。

22130
30:14:47.568 --> 30:14:49.822
所以我们的治理令牌看起来不错。

22131
30:14:49.822 --> 30:14:51.028
我们的盒子看起来不错。

22132
30:14:51.028 --> 30:14:55.293
现在让我们实际开始创建治理契约。

22133
30:14:55.293 --> 30:15:02.822
现在我们要创建一个名为治理标准的文件夹因为这将是标准治理模型。

22134
30:15:02.822 --> 30:15:09.653
这将是ERC 20链上的这个，我计划在未来更新这个没有治理链或其他正确的东西。

22135
30:15:09.653 --> 30:15:18.033
现在，我们称之为治理标准因为这是治理的标准方式，但在空中，我们需要两个契约，我们

22136
30:15:18.033 --> 30:15:26.414
需要一个政府工作，契约那个灵魂然后我们还需要一个时间锁那个灵魂这马上就讲得通了。

22137
30:15:26.414 --> 30:15:33.320
我们的gov contract。soul是包含所有投票代码的合约，以及治理

22138
30:15:33.320 --> 30:15:40.226
令牌将要使用的所有投票逻辑，时间锁实际上是一个额外的合约它实际上是所有者。

22139
30:15:40.226 --> 30:15:48.447
Time Lock和调控器契约是一样的，不同之处在于Time Lock实际上是盒子契约的所有者。

22140
30:15:48.447 --> 30:15:54.842
这一点很重要，因为每当我们提出或暗示一个提议要通过

22141
30:15:54.842 --> 30:16:01.237
时，我们都想等待，对吧?我们希望等待执行新的投票。

22142
30:16:01.237 --> 30:16:06.730
现在，我们为什么要这么做，假设某个提案通过了，那是不好的。

22143
30:16:06.730 --> 30:16:08.582
比如说，我们有一个盒装合同。

22144
30:16:08.582 --> 30:16:15.376
然后通过了一个提议，每个持有治理代币的人都必须支付五个代币，或者类

22145
30:16:15.376 --> 30:16:22.377
似的东西，对吧，或者别的什么，谁知道呢?也许这是你并不想参与的事情。

22146
30:16:22.377 --> 30:16:27.838
因此，如果用户不喜欢治理更新，那么所

22147
30:16:27.838 --> 30:16:33.300
有这些治理契约都给了他们退出的时间。

22148
30:16:33.300 --> 30:16:36.659
所以我们总是需要一些时间轴。

22149
30:16:36.659 --> 30:16:43.338
因此，一旦提案通过，它不会立即生效，它必须等待一段时间，然后生效。

22150
30:16:43.338 --> 30:16:45.030
这就是时间线的作用。

22151
30:16:45.108 --> 30:16:47.866
调控器契约将包含我们所有的实际代码。

22152
30:16:48.108 --> 30:16:50.031
我们可以稍微作弊一下。

22153
30:16:50.108 --> 30:16:52.271
实际上，我们可以欺骗很多人。

22154
30:16:53.108 --> 30:16:57.866
有个叫做契约向导的东西，描述中也有链接。

22155
30:16:57.866 --> 30:17:04.832
当wizard是我们用来写基本样板代码的一种方式时，这就打开了。

22156
30:17:04.832 --> 30:17:11.646
好的，如果我们去向导合同这里，我们可以看到我们可以做ERC 20和NFT 1155。

22157
30:17:11.646 --> 30:17:14.308
最后，这里的政府。

22158
30:17:14.308 --> 30:17:18.108
我们可以给它起个名字，我们叫它Rs。

22159
30:17:18.108 --> 30:17:25.967
政府合同，解释这一切意味着什么，并给它一个投票延迟，这是从提案创建到投票开始的延迟。

22160
30:17:25.967 --> 30:17:31.023
所以一旦你创建了一个提案，你需要等待一段时间，投票期，投票应该持续多长时间。

22161
30:17:31.023 --> 30:17:37.792
这个音频很重要的原因是因为他们实际上是投票的，投票周期是以区块为单位的。

22162
30:17:37.792 --> 30:17:44.002
所以在智能合约中做基于时间的事情是一种反模式，做基于区块的事情要好得多。

22163
30:17:44.002 --> 30:17:48.921
我们说的是一周，但是这将是。如果如果平均区块时间是13。

22164
30:17:48.921 --> 30:17:55.862
2秒后，我们会算出弱提案的阈值是最小票数帐户必须创建一个提案。

22165
30:17:55.862 --> 30:18:00.429
也许你只想让拥有大量治理令牌的人投票法定人

22166
30:18:00.429 --> 30:18:04.996
数百分比，也就是需要全部投票的人的百分比。

22167
30:18:04.996 --> 30:18:12.072
所以我们说，4%的代币持有者需要投票，或者我们可以说，刚好100个代币需要投票，不管我们想做什么。

22168
30:18:12.072 --> 30:18:17.769
我们也有一些可更新的设置我们有Bravo兼容的Bravo是复合类型契约。

22169
30:18:17.769 --> 30:18:21.233
所以如果你想让它对化合物可积分，你可以这样做。

22170
30:18:21.233 --> 30:18:26.846
或者ERC 20投票，我们正在使用这个ERC 20投票，我们总是想做一个时间锁，

22171
30:18:26.846 --> 30:18:36.950
我们要做一个时间锁的开放式Zeplin实现，你也可以做一个复合实现，我们不打算在这里做可升级性，但是，我有很多很棒的资源关于如何真正做可升级性。

22172
30:18:36.950 --> 30:18:40.624
如果我们真的想要升级，它会添加所有其他的东西。

22173
30:18:40.624 --> 30:18:47.600
我们现在不打算这么做，因为这会使视频变得更长，然后你可以添加一些像这样的东西，但哦，差不多就是这样了。

22174
30:18:47.600 --> 30:18:56.193
我知道这听起来像是你在作弊，或者我们就直接抄一遍，对吧?复制我们放到剪贴板里的所有内容，然后粘贴进去。

22175
30:18:56.193 --> 30:18:58.759
别担心，我现在就解释这是怎么回事。

22176
30:18:58.759 --> 30:19:00.537
我们有政府合同。

22177
30:19:00.537 --> 30:19:06.797
这是州长设置州长计算简单的州长投票，州长投票，法定人数，等等。

22178
30:19:06.797 --> 30:19:15.781
所有这些都是为了让州长更容易成为州长，州长计数简单是一种计数选票的方式，州长投票是一种与当年20份合同整合的方式。

22179
30:19:15.781 --> 30:19:19.459
仲裁分数是一种理解仲裁时间锁定的方法。

22180
30:19:19.459 --> 30:19:20.759
显然，这是时间锁。

22181
30:19:20.759 --> 30:19:21.701
这是基础契约。

22182
30:19:21.701 --> 30:19:22.522
这需要一些设置。

22183
30:19:22.522 --> 30:19:24.797
我们马上会讲到这个。

22184
30:19:24.797 --> 30:19:27.367
我们来看看这里的函数是什么我们有投票延迟。

22185
30:19:27.367 --> 30:19:33.204
这就是投票延迟，我们将使用superdad voting gelei，我们将从这个州长

22186
30:19:33.204 --> 30:19:39.042
设置契约中得到我们将在一分钟后设置你的投票周期我们将在我们的政府设置中设置，就是这个。

22187
30:19:39.042 --> 30:19:47.019
如果你想看所有这些合同，你绝对可以，如果我们去看合同，管理，扩展，我们都在这里，对吧?因此，

22188
30:19:47.019 --> 30:19:54.997
如果我们查看治理设置，我们可以看到它有投票延迟、投票周期、提案阈值，这些都在它的构造函数中。

22189
30:19:54.997 --> 30:19:56.942
这就是我们要设置的。

22190
30:19:56.942 --> 30:20:02.996
我们会设置投票延迟投票周期，然后是提案阈值，然后我们会让这个也可以自定义。

22191
30:20:02.996 --> 30:20:07.092
剩下的就是通过超级投票来达到法定人数。

22192
30:20:07.092 --> 30:20:14.327
然后，超级是那些继承的契约，得到状态然后我们提出了一些有趣的函数。

22193
30:20:14.327 --> 30:20:19.072
这就是我们提出新治理要做的事情我们有提案

22194
30:20:19.072 --> 30:20:23.818
阈值，然后我们有执行，执行一个线索提案。

22195
30:20:23.818 --> 30:20:28.608
为了取消，我们有executor它可以实际执行一些

22196
30:20:28.608 --> 30:20:33.399
东西，我们将它设为任何人然后支持接口，你可以忽略。

22197
30:20:33.399 --> 30:20:35.866
但让我们让它更可定制一点。

22198
30:20:35.866 --> 30:20:43.383
我们有Iboats令牌，这是治理令牌，时间轴控制器时间轴，这是我们修改的时间轴控制器。

22199
30:20:43.383 --> 30:20:50.061
再说一次，我们需要这个，因为我们不想让任何提案一旦通过就被通过，我们想给人们时间退出。

22200
30:20:50.109 --> 30:20:56.544
但是让我们在这里添加un256投票延迟作为参数。

22201
30:20:57.109 --> 30:21:05.496
对于投票延迟，我们会这样做，我们会把它设为我们的调控器设置，我们会做一个unt256投票周期。

22202
30:21:05.496 --> 30:21:08.012
我们要把它加在这里。

22203
30:21:08.012 --> 30:21:12.305
这意味着45,000块积木大约是一周的时间。

22204
30:21:12.305 --> 30:21:19.505
这就意味着我们将把提案的门槛设置为零因为我们不想改变这一点我们想让任何人提出提案。

22205
30:21:19.505 --> 30:21:27.418
然后我们要在这里加上256下划线的核心百分比。

22206
30:21:27.418 --> 30:21:30.966
州长投票法定人数百分比的公司参议员。

22207
30:21:30.966 --> 30:21:36.728
这是完全可定制的，对于投票，延迟投票周期，核心百分比，你想要什么都行。

22208
30:21:36.728 --> 30:21:38.299
信不信由你，就是这样。

22209
30:21:38.299 --> 30:21:40.501
现在您有了一个简单的治理契约。

22210
30:21:40.501 --> 30:21:43.945
谢谢你，openzeppelin，为我们做了99%的工作。

22211
30:21:43.945 --> 30:21:44.797
就是这样。

22212
30:21:44.797 --> 30:21:52.823
这个契约，它会有所有这些我们会讲到的函数用于提议，执行和排队，不同的提议。

22213
30:21:52.823 --> 30:21:53.299
正确的。

22214
30:21:53.299 --> 30:21:56.870
现在我们得签个时间锁契约。

22215
30:21:57.109 --> 30:21:59.902
这个合同实际上会简单很多。

22216
30:22:00.109 --> 30:22:01.334
我们要从头开始。

22217
30:22:02.109 --> 30:22:08.755
许可我，然后开火，我的团队，做pragma solidity让我们这样

22218
30:22:08.755 --> 30:22:15.592
做你的点，点零，然后我们将从打开齐柏林，导入一个叫做时间锁控制器的合同。

22219
30:22:15.592 --> 30:22:22.842
看看这里的治理，如果这个time lock controller。soul contract，

22220
30:22:22.842 --> 30:22:30.092
这里有创建角色的所有功能，谁能提议谁能执行，谁是time lock管理员，这里也有执行的东西。

22221
30:22:30.092 --> 30:22:35.016
这将与我们的治理合同协同工作，对吧?这是一份合

22222
30:22:35.016 --> 30:22:40.156
同，它确保我们的治理合同不会随随便便地推进事情。

22223
30:22:40.156 --> 30:22:45.001
我们会说，我们首先导入那个导入在open

22224
30:22:45.001 --> 30:22:50.816
Zeppelin /合同/治理/时间锁控制器。

22225
30:22:50.816 --> 30:22:58.092
就这些然后我们会说合约，I'm lock is Time lock controller，像这样。

22226
30:22:58.092 --> 30:23:01.833
我们会在这里创建构造函数，和卡车门。

22227
30:23:01.833 --> 30:23:08.744
因为这需要几个不同的参数，我们会取un 256 Min delay，

22228
30:23:08.744 --> 30:23:15.859
也就是Min delay, Min delay是在执行之前需要等待的。

22229
30:23:15.859 --> 30:23:21.736
这是，提案通过后，很好，我们要等待这个最小延迟，

22230
30:23:21.736 --> 30:23:27.859
然后我们要做一个提案者列表，提案者的地址数组内存。

22231
30:23:27.859 --> 30:23:36.053
然后提议者是可以为我们求婚的地址列表，我们会说每个人都可以求婚。

22232
30:23:36.053 --> 30:23:42.656
最后，一个地址数组，可以执行所有操作的executor的内存，

22233
30:23:42.656 --> 30:23:48.833
我们说的是当探测pole通过时可以执行的executor。

22234
30:23:48.833 --> 30:23:53.536
再说一次，我们会说everyone，我们需要这些的原因是因为

22235
30:23:53.536 --> 30:23:58.240
我们需要把这些传递给时间锁控制器，这个构造函数需要三个参数。

22236
30:23:58.240 --> 30:24:04.918
所以我们只做Tama控制器，延时，pro posers, X EQ，巡演。

22237
30:24:04.918 --> 30:24:06.695
就是这样。

22238
30:24:06.695 --> 30:24:13.637
这就是拥有所有东西的时间日志，它将拥有我们的盒子。

22239
30:24:13.637 --> 30:24:18.399
不是政府合同，政府合同是我们发送选票的地方。

22240
30:24:18.399 --> 30:24:22.997
但是在这个时间锁中，为了让治理真正发生，所有事情都需要通过这个时间锁，

22241
30:24:22.997 --> 30:24:27.464
因为我们想要确保我们有这个最小的延迟，我们通过正确的过程和所有事情。

22242
30:24:27.464 --> 30:24:29.209
信不信由你，这就是一切。

22243
30:24:29.209 --> 30:24:35.895
就稳定性而言，这就是创建治理和创建Dao所需的所有代码。

22244
30:24:35.895 --> 30:24:40.421
你可以自己进行硬帽编译，确保所有东西都编译好了。

22245
30:24:40.421 --> 30:24:43.660
太好了，我们已经做到了，你做了大部分艰苦的工作。

22246
30:24:43.660 --> 30:24:49.176
现在我们要转到实际编写脚本来部署和使用TypeScript与所有东西交互。

22247
30:24:49.176 --> 30:24:55.156
在这一点上，如果你想，哦，我已经学会了我想要的一切，我不使用安全帽，我使用一些其他工具。

22248
30:24:55.156 --> 30:24:58.573
这就是我挑战你的地方，我挑战你去尝试一些别的东西。

22249
30:24:58.573 --> 30:25:05.956
如果你已经达到了这一点，我只想给你一个大大的祝贺，因为你已经采取了步骤来建立你自己的怀疑，建立你自己的治理模型。

22250
30:25:05.956 --> 30:25:07.649
这就是你真正需要的所有的固体。

22251
30:25:07.649 --> 30:25:10.207
你可以把它部署好就可以了。

22252
30:25:10.207 --> 30:25:15.318
当然，我们知道智能合约开发者要做的不仅仅是工具的可靠性让我们

22253
30:25:15.318 --> 30:25:20.600
继续，我们将开始编写TypeScript脚本来真正做到这一点。

22254
30:25:20.600 --> 30:25:25.601
再说一遍，如果你想看Python版的，请点击链接描述查看Python版的。

22255
30:25:25.601 --> 30:25:30.930
当然，别忘了点赞，订阅，给我们留言。

22256
30:25:30.930 --> 30:25:32.990
当然，也要鼓励一下自己。

22257
30:25:32.990 --> 30:25:33.328
伟大的工作。

22258
30:25:33.328 --> 30:25:35.632
你能走到这一步真是太棒了。

22259
30:25:35.632 --> 30:25:37.917
恭喜你，让我们开始吧。

22260
30:25:38.109 --> 30:25:45.190
好了，回到这里，我们已经写好了智能合约，检查并不容易，这比我想象的要简单得多。

22261
30:25:45.190 --> 30:25:49.329
现在我们将编写部署脚本，然后我们将编写与它们交互的脚本。

22262
30:25:49.329 --> 30:25:53.315
我的完整回购也有测试，但我们只会写一些脚本。

22263
30:25:53.315 --> 30:25:55.486
然后你可以自己查看测试。

22264
30:25:55.486 --> 30:26:02.050
让我们写这些部署脚本我们将使用一个叫做Hard Hat deploy的部署包。

22265
30:26:02.050 --> 30:26:06.458
它绝对是了不起的，让你的部署变得非常非常容易。

22266
30:26:06.458 --> 30:26:10.142
我们会向下滚动到安装，我们会继续安装这个。

22267
30:26:10.142 --> 30:26:11.990
通常，你可以这样安装它。

22268
30:26:11.990 --> 30:26:18.033
我们会用纱线，但我们会用一种更安全的方式看起来有点不靠谱，但我解释得对。

22269
30:26:18.033 --> 30:26:23.551
我们不使用NPM install，而是使用yarn，添加dash Dev，然后是这里的整个东西。

22270
30:26:23.551 --> 30:26:27.322
所以我们要做纱线，添加dash Dev，然后把它粘贴到这里。

22271
30:26:27.322 --> 30:26:33.930
这将是nomic，实验室斜杠，硬帽，连字符的醚在NPM，冒号，硬帽，部署醚。

22272
30:26:33.930 --> 30:26:40.928
它的作用是我们基本上说硬帽部署醚将覆盖这个硬醚。

22273
30:26:40.928 --> 30:26:42.560
我们还要加上醚。

22274
30:26:42.560 --> 30:26:47.886
一旦我们加入这个，检查我们的package json，我们可以看到我们有hard hats。

22275
30:26:47.886 --> 30:26:52.600
我们有硬帽醚，它被这个硬帽覆盖了，部署醚。

22276
30:26:52.600 --> 30:26:57.515
另外，我们要添加一个deploy。

22277
30:26:57.515 --> 30:27:02.246
所以做纱线，添加破折号Dev，硬帽子连字符，部署。

22278
30:27:02.246 --> 30:27:08.746
这样我们就不用写脚本了，不用做这些事情了，这样就很难保存部署了，我

22279
30:27:08.746 --> 30:27:15.246
们只需要创建一个deploy文件夹，把所有的部署脚本都添加到这里。

22280
30:27:15.246 --> 30:27:17.004
所以我非常喜欢这个套餐。

22281
30:27:17.109 --> 30:27:19.159
这使得部署非常非常简单。

22282
30:27:20.109 --> 30:27:24.473
创建一个新文件，它会做哦，首先，我们会一步一步地部署所有东西，

22283
30:27:24.473 --> 30:27:30.950
我们会叫它deploy，治理，或者token。TypeScript，这是我们要做的第一件事。

22284
30:27:30.950 --> 30:27:33.798
我们还会把这个改成TypeScript。

22285
30:27:33.798 --> 30:27:35.798
Tada，我们现在有TypeScript了。

22286
30:27:35.798 --> 30:27:36.073
耶。

22287
30:27:36.073 --> 30:27:40.849
做高级TypeScript的一个好处是它给了它一个开

22288
30:27:40.849 --> 30:27:45.625
始，你不需要自己安装所有TypeScript的东西。

22289
30:27:45.625 --> 30:27:46.270
但我们有。

22290
30:27:46.270 --> 30:27:54.412
我们要做yarn，添加TypeScript类型chain vs node在type chain / ethers V

22291
30:27:54.412 --> 30:28:02.977
5，这是很多东西，别担心type chain / hard hat，在type / Chai，在type / node。

22292
30:28:02.977 --> 30:28:10.028
然后我们会确保这些都是戴夫，戴夫，我知道有很多东西。

22293
30:28:10.109 --> 30:28:12.066
有很多东西可以让它变成TypeScript D。

22294
30:28:12.109 --> 30:28:14.625
如果你愿意，你完全可以在JavaScript中完成。

22295
30:28:15.109 --> 30:28:17.092
不得不处理JS文件，忽略输入。

22296
30:28:18.109 --> 30:28:18.990
做你想做的事。

22297
30:28:18.990 --> 30:28:19.464
好了,很酷。

22298
30:28:20.109 --> 30:28:20.719
好吧。

22299
30:28:20.719 --> 30:28:23.295
让我们进入总督令牌。

22300
30:28:24.109 --> 30:28:25.528
创建一个部署脚本。

22301
30:28:28.109 --> 30:28:31.448
这是一些演示样板代码，用于实际执行部署脚本。

22302
30:28:31.448 --> 30:28:34.484
所以，如果你迷路或困惑，请随时参考这里。

22303
30:28:34.484 --> 30:28:39.048
我们要做的是从增强的斜杠

22304
30:28:39.048 --> 30:28:43.994
类型，导入硬帽运行时环境。

22305
30:28:44.109 --> 30:28:45.609
你们马上就会明白为什么我们需要这个。

22306
30:28:46.109 --> 30:28:49.557
也将从Hardhead导入deploy函数。

22307
30:28:50.109 --> 30:28:50.677
削减类型。

22308
30:28:53.109 --> 30:28:58.077
用pothead deploy创建一个部署函数，我们会创建我们的函数，我们会

22309
30:28:58.077 --> 30:29:03.046
叫它const ploy治理令牌，它的类型是deploy function。

22310
30:29:03.046 --> 30:29:07.234
为了让这些实际工作，我们只需要创建一大堆部署函数我们用heart hub运行。

22311
30:29:07.234 --> 30:29:09.091
这将是一个async函数。

22312
30:29:09.091 --> 30:29:15.633
它将把硬帽运行时环境作为输入参数，我们将称之为HRV。

22313
30:29:15.633 --> 30:29:19.664
当我们运行hardhat deploy时，你马上就会看到，

22314
30:29:19.664 --> 30:29:27.172
我们实际上在传递假的hardhat链它会在后台为我们旋转，我们甚至可以写console。log Hello。

22315
30:29:27.172 --> 30:29:29.949
如果我们做纱线，戴上安全帽。

22316
30:29:30.109 --> 30:29:38.484
实际上，在我们这么做之前，如果我们做yarn，你会看到，因为我们导入了hard hat deploy不好意思，我们需要把这个添加到我们的配置中。

22317
30:29:38.484 --> 30:29:45.669
首先在我们的配置中，我们需要做top imports，部署top Roscoe需要import at nomic

22318
30:29:45.669 --> 30:29:53.496
labs / hard hat ethers，我们还需要import at type chain / hard hat。

22319
30:29:53.496 --> 30:29:55.334
然后我们先把它放在这里。

22320
30:29:55.334 --> 30:29:58.673
我们马上要导入更多的东西，就像这样。

22321
30:29:58.673 --> 30:30:03.296
现在，如果我们做纱线安全帽，应该有帮助，我们应该在这里看到一个新的任务。

22322
30:30:03.296 --> 30:30:09.270
我们确实看到了很多新任务，对吧?已填满任务，检查干净编译，部署控制台。

22323
30:30:09.270 --> 30:30:13.989
这是我们的新任务它会部署所有契约，deploy文件夹

22324
30:30:13.989 --> 30:30:18.709
下的所有契约，head会在deploy文件夹下运行。

22325
30:30:18.709 --> 30:30:21.338
我们只有这个console。log Hello。

22326
30:30:21.338 --> 30:30:25.383
如果我们运行yarn，或者点击Deploy，我们应该看到，它会打印出hello。

22327
30:30:25.383 --> 30:30:30.621
它会打开一个新的区块链后台，而我们所有的项目，会做一些类型类型链

22328
30:30:30.621 --> 30:30:35.859
之类的东西，它说你会经常看到这个部署脚本。func不是一个函数。

22329
30:30:35.859 --> 30:30:37.696
那是因为我们现在需要导出这个。

22330
30:30:37.696 --> 30:30:42.697
我们会导出default，部署治理令牌。

22331
30:30:42.697 --> 30:30:44.854
所以它才对我们发火。

22332
30:30:44.854 --> 30:30:46.496
现在我们要让纱尔德戴上安全帽。

22333
30:30:46.496 --> 30:30:47.979
砰的一声，我们打了个招呼。

22334
30:30:47.979 --> 30:30:51.318
这就是我们部署所有脚本的方式。

22335
30:30:51.318 --> 30:30:56.828
我们可以一次性运行deploy文件夹中的所有内容，这非常有用。

22336
30:30:56.828 --> 30:30:59.625
因此，让我们先部署治理令牌。

22337
30:30:59.625 --> 30:31:01.309
随着时间的推移，速度会越来越快。

22338
30:31:01.309 --> 30:31:02.309
别担心，删掉这条吧。

22339
30:31:02.309 --> 30:31:04.859
首先我们要做的是，我们要说const。

22340
30:31:04.859 --> 30:31:06.879
我们需要一个帐户来部署它。

22341
30:31:06.879 --> 30:31:12.093
我们写入const，获取命名帐户，部署，网络等于HRA。

22342
30:31:12.093 --> 30:31:14.397
这个会更高级一些。

22343
30:31:14.397 --> 30:31:15.041
这是很难的。

22344
30:31:15.109 --> 30:31:22.832
这是我们在这里做的灵巧的事情，我们从我们的硬帽运行时环境中得到这些，它是从硬帽部署中更新的。

22345
30:31:22.832 --> 30:31:29.675
get named accounts是将账户从硬帽配置导入到部署脚本的方法。

22346
30:31:29.675 --> 30:31:31.041
我们要进入硬帽配置。

22347
30:31:31.109 --> 30:31:34.530
我们要创建一个新的配置比这个稍微好一点。

22348
30:31:34.530 --> 30:31:37.014
因此，首先，我们需要导入硬帽配置类型。

22349
30:31:37.109 --> 30:31:41.729
因为我们使用的是类型脚本，所以我们将从硬帽斜杠配置导入硬帽用户配置。

22350
30:31:41.729 --> 30:31:43.859
我们会创建一个配置。

22351
30:31:43.859 --> 30:31:45.609
我把这个注释掉。

22352
30:31:45.609 --> 30:31:48.109
现在我们用const。

22353
30:31:48.109 --> 30:31:50.419
配置，输入hard hat user Config。

22354
30:31:50.419 --> 30:31:53.530
等于，在这里我们可以加上一大堆东西。

22355
30:31:53.530 --> 30:31:59.463
假设默认网络是hard hat，也就是本地伪区块链。

22356
30:31:59.463 --> 30:32:03.836
然后我们说固体度是0，点8。

22357
30:32:03.836 --> 30:32:09.736
8，然后我们要做命名账户，这是我们一开始来这里的目的。

22358
30:32:09.736 --> 30:32:12.270
这是我们可以使用的账户列表。

22359
30:32:12.270 --> 30:32:20.855
对于账户，我们会说Deployer，这是负责所有部署的账户名，我们会说，default是0。

22360
30:32:20.855 --> 30:32:27.061
运行任意链时，带account的0将命名为Deployer。

22361
30:32:27.061 --> 30:32:30.690
我们需要做的另一件事是我们需要在这里增加我们的网络。

22362
30:32:30.690 --> 30:32:36.058
实际上我们有两个网络，我们有一个硬帽子，它的链ID是313337。

22363
30:32:36.058 --> 30:32:41.566
还有本地主机链ID是31337。

22364
30:32:41.566 --> 30:32:45.537
现在，这些看起来几乎一样。

22365
30:32:45.537 --> 30:32:48.259
我能理解，但他们不是。

22366
30:32:48.259 --> 30:32:51.575
你马上就会明白为什么，但我们现在需要它们。

22367
30:32:51.575 --> 30:32:58.281
只是想告诉Hardhead，嘿，这是我们正在合作的开发伪区块链?好的。

22368
30:32:58.281 --> 30:33:00.486
这是我们的基本设置。

22369
30:33:00.486 --> 30:33:00.731
好的。

22370
30:33:00.731 --> 30:33:02.205
我知道这有点多。

22371
30:33:02.205 --> 30:33:07.424
但现在我们有了命名帐户，我们有了网络，对吧?因为任何时候你部署一个东西，它都会在网络上。

22372
30:33:07.424 --> 30:33:16.334
当我们部署一些东西时，如果你运行yarn, hard hat node, hard hat会做什么呢，它会在后台旋转一个假的区块链。

22373
30:33:16.334 --> 30:33:17.942
它会生我的气的。

22374
30:33:17.942 --> 30:33:22.798
哦，我忘了添加导出，默认配置，对，我们需要导出配置。

22375
30:33:22.798 --> 30:33:26.367
我们用的是这种吊索。

22376
30:33:26.367 --> 30:33:27.757
如果你在一个硬帽节点上，

22377
30:33:27.757 --> 30:33:36.680
你就会明白为什么我们要在这里添加这两个网络硬帽在localhost上，我们实际上旋转了我们自己的假区块链，我们得到了账户，我们得到了私钥，一切都是正确的。

22378
30:33:36.680 --> 30:33:44.464
这是一个在这个终端上运行的硬帽节点，对吧?奇怪的是，当你运行硬帽节点时，它实际上是本地主机网络。

22379
30:33:44.464 --> 30:33:45.989
这不是“硬帽网络”。

22380
30:33:45.989 --> 30:33:49.171
当使用硬帽部署时，它将是本地主机网络。

22381
30:33:49.171 --> 30:33:53.918
不好意思，当你使用硬帽节点时，它实际上是本地主机网络，而不是硬帽网络。

22382
30:33:53.918 --> 30:33:56.585
它在运行测试时使用的是Hard Hat网络。

22383
30:33:56.585 --> 30:34:02.770
Localhost是当你运行这个硬帽节点并在你的终端中运行这种假的区块链。

22384
30:34:02.770 --> 30:34:04.397
这就是localhost。

22385
30:34:04.397 --> 30:34:04.651
酷。

22386
30:34:04.651 --> 30:34:06.109
Ctrl C会扼杀它。

22387
30:34:06.109 --> 30:34:06.823
好了,好了。

22388
30:34:06.823 --> 30:34:08.471
现在一切都开始运转了。

22389
30:34:08.471 --> 30:34:13.849
所以让他们计算部署是一大堆来自部署的东西，你马上就会看到网络就是我们所在的网络。

22390
30:34:13.849 --> 30:34:14.571
好了,好了。

22391
30:34:14.571 --> 30:34:22.502
现在我们要获取const deploy log = deployment，这个deployment对象带有这个deploy函数。

22392
30:34:22.502 --> 30:34:26.801
这个log函数，这个log函数很适合做日志记录。

22393
30:34:26.801 --> 30:34:32.966
然后我们会抓取const, employer = await，获取命名账户。

22394
30:34:32.966 --> 30:34:37.354
我们从配置中抓取这个部署

22395
30:34:37.354 --> 30:34:42.109
者账户?它总是带下标的0。

22396
30:34:42.109 --> 30:34:46.047
它默认是0索引，不管账户是什么。

22397
30:34:46.047 --> 30:34:46.323
太好了。

22398
30:34:46.323 --> 30:34:51.573
现在我们有了一个帐户来部署我们有了一个部署功能，我们有了所有这些东西，我们看起来很好。

22399
30:34:51.573 --> 30:34:51.840
酷。

22400
30:34:51.840 --> 30:35:00.384
有时他们会写一个log，飞行治理令牌，点，我们会说const治理令牌= await,

22401
30:35:00.384 --> 30:35:08.928
deploy，然后是契约的名称也就是治理令牌，逗号，这些都是我们要传递给它的参数。

22402
30:35:08.928 --> 30:35:13.681
我们会说from deployer不接受任何参数。

22403
30:35:13.681 --> 30:35:15.839
args就是空的。

22404
30:35:15.839 --> 30:35:19.864
我们要让log为真所以我们要打印一些对数。

22405
30:35:19.864 --> 30:35:24.669
然后我在GitHub repo中设置了这个等待确认属性。

22406
30:35:24.669 --> 30:35:26.448
现在我们先忽略它。

22407
30:35:26.448 --> 30:35:30.834
但如果你跟着我的回购，你想要自动验证，这是你会想要使用的东西。

22408
30:35:30.834 --> 30:35:38.062
所以你需要等待一些block来部署这个契约然后你才能进行验证。

22409
30:35:38.110 --> 30:35:43.332
因为如果你用的是以太扫描之类的，你需要等一下，是的，你需要等几分钟。

22410
30:35:43.332 --> 30:35:47.110
所以请查看我的GitHub回购，看看这个等待确认的东西，我现在将忽略它。

22411
30:35:47.110 --> 30:35:52.585
此外，在我的GitHub回购中，我有这个验证功能，我们检查它是否在开发链上。

22412
30:35:52.585 --> 30:35:54.176
即使是，我们也不会去核实。

22413
30:35:54.176 --> 30:35:56.771
但如果是以太扫描之类的，我们就会去验证。

22414
30:35:56.771 --> 30:36:01.594
所以一定要查看GitHub回购，学习如何不做任何事情就自动验证。

22415
30:36:01.594 --> 30:36:03.526
如果我们只做这部分。

22416
30:36:03.526 --> 30:36:08.600
然后我们甚至可以用Floyd，治理

22417
30:36:08.600 --> 30:36:13.974
令牌来处理治理令牌。address。

22418
30:36:13.974 --> 30:36:17.710
我们会做纱硬帽。

22419
30:36:17.710 --> 30:36:18.643
部署。

22420
30:36:18.643 --> 30:36:19.309
繁荣。

22421
30:36:19.309 --> 30:36:26.641
所以我们在一个假的硬帽网络上旋转，我们部署治理令牌来解决繁荣。

22422
30:36:26.641 --> 30:36:30.937
这就是我们部署的方法一个冒牌的已经在我们的小网络上部署了这个。

22423
30:36:30.937 --> 30:36:31.350
太好了。

22424
30:36:31.350 --> 30:36:34.932
这个令牌被部署，我们有部署脚本。

22425
30:36:34.932 --> 30:36:36.286
是的，缩小一点。

22426
30:36:36.286 --> 30:36:37.490
让我们缩小一点。

22427
30:36:37.490 --> 30:36:37.680
太好了。

22428
30:36:37.680 --> 30:36:38.410
这就是全部。

22429
30:36:38.410 --> 30:36:41.919
现在我们还要添加一个东西，我们要添加一个叫做委托函数的东西。

22430
30:36:41.919 --> 30:36:45.416
现在，当你真正执行这份合同时，还没有人有投票权。

22431
30:36:45.416 --> 30:36:51.531
原因是，因为没有人将令牌委托给他们，所以我们希望将这个令牌委托给我们的部署者。

22432
30:36:51.531 --> 30:36:53.538
我们会调用这个委托函数。

22433
30:36:53.538 --> 30:36:56.519
我们要创建一个名为const的新函数。

22434
30:36:56.519 --> 30:36:57.256
委托。

22435
30:36:57.256 --> 30:37:00.452
这将是一个async函数。

22436
30:37:00.452 --> 30:37:06.414
它会将治理令牌地址作为字符串，它会将委托帐户作为字符串，所以

22437
30:37:06.414 --> 30:37:12.376
我们会争分夺秒，我们想要谁?委托吗?我们希望谁能够用我们的代

22438
30:37:12.376 --> 30:37:18.538
币投票?我们已经创建了这个叫delegate的async函数。

22439
30:37:18.538 --> 30:37:25.482
我们要怎么做呢?我们说康德在它的

22440
30:37:25.482 --> 30:37:32.860
令牌等于令牌等于等待醚点得到契约。

22441
30:37:33.110 --> 30:37:36.811
也许是精明的奥托为我们做了两个乙醚，这很好。

22442
30:37:36.811 --> 30:37:37.512
这就是我们想要的。

22443
30:37:37.512 --> 30:37:38.571
就像醚一样。

22444
30:37:38.571 --> 30:37:39.571
谢谢vs。

22445
30:37:39.571 --> 30:37:40.340
代码了。

22446
30:37:40.340 --> 30:37:42.493
以太就像一个合约。

22447
30:37:42.493 --> 30:37:50.041
我们想要我们的治理令牌，也就是契约，治理令牌地址。

22448
30:37:50.041 --> 30:37:54.899
我有自动格式未保存，这就是为什么它一直这样格式化。

22449
30:37:54.899 --> 30:37:56.667
这应该委托记账。

22450
30:37:56.667 --> 30:37:57.301
好的,很酷。

22451
30:37:57.301 --> 30:38:00.033
我们有治理令牌契约。

22452
30:38:00.033 --> 30:38:04.760
现在我们可以使用const TX或transaction = await,

22453
30:38:04.760 --> 30:38:09.360
governance token。delegate委派这个委派的帐户。

22454
30:38:09.360 --> 30:38:16.028
然后我们可以做一个等待，我们会等待这个事务被一个block确认。

22455
30:38:16.110 --> 30:38:22.846
然后我们会写console。log检查点，等等，治理令牌。

22456
30:38:22.846 --> 30:38:29.117
num检查点委派帐户?这是在做什么呢?我们有这个num

22457
30:38:29.117 --> 30:38:35.855
查点函数我们可以去检查ERC 20令牌上它到底在做什么。

22458
30:38:35.855 --> 30:38:40.206
但基本上这整个东西做的是，我们有这个委托函数，我们还没用过它。

22459
30:38:40.206 --> 30:38:44.710
但当有人打电话给我们时，我们会说，嘿，你可以用我的票，拿我的票，你想怎么投就怎么投。

22460
30:38:44.710 --> 30:38:46.536
这就是这个委托的作用。

22461
30:38:46.536 --> 30:38:55.267
现在，如果我们看这个令牌，这里有20个扩展，你看到20个投票，我们看数量检查点，我们可以

22462
30:38:55.267 --> 30:39:03.998
看到这个账户有多少个检查点这很重要，因为就像我说的，当人们投票时，他们会基于一些检查点。

22463
30:39:03.998 --> 30:39:10.566
当你转移一个令牌，或委派一个令牌时，基本上调用这个函数move投票权，

22464
30:39:10.566 --> 30:39:16.760
这发生在后端，它写检查点，说，嘿，在检查点x，这是每个人的投票权。

22465
30:39:16.760 --> 30:39:18.710
这就是为什么这些很重要。

22466
30:39:18.710 --> 30:39:23.655
我知道我之前说过，是每个街区，但实际上是每个检查点，每当这些检查

22467
30:39:23.655 --> 30:39:28.601
点更新时，这将比我们只更新每个街区要便宜得多，对吧?那太疯狂了。

22468
30:39:28.601 --> 30:39:34.125
这个治理检查点的检查点，我们马上就会看到它到底是什么。

22469
30:39:34.125 --> 30:39:40.667
我们甚至会做等待，委托，治理令牌。address和Deployer。

22470
30:39:40.667 --> 30:39:43.880
我们说log委派。

22471
30:39:44.110 --> 30:39:47.531
现在，当我们使用这个函数时，约翰·霍华德点击了部署。

22472
30:39:47.531 --> 30:39:54.703
我们有一个检查点，这说得通，对吧?因为这只是部署，只是委派。

22473
30:39:54.703 --> 30:39:56.528
这个地址有一个检查点。

22474
30:39:56.528 --> 30:39:57.073
就是这样。

22475
30:39:57.073 --> 30:40:02.077
我检查这个的原因是如果你在这里看到零检查点，这意味着你没有正确地委派。

22476
30:40:02.077 --> 30:40:03.824
所以一定要检查检查点。

22477
30:40:03.824 --> 30:40:04.490
但仅此而已。

22478
30:40:04.490 --> 30:40:07.420
我们已经完成了部署的治理令牌契约。

22479
30:40:07.420 --> 30:40:07.833
布拉沃。

22480
30:40:07.833 --> 30:40:09.901
让我们继续下一个。

22481
30:40:10.110 --> 30:40:15.860
那么，在部署治理令牌之后，我们想做什么呢?好吧，让我们使用那个时间锁或时间锁。

22482
30:40:15.860 --> 30:40:15.985
ts。

22483
30:40:15.985 --> 30:40:23.306
我们要从这里复制很多东西，所以我实际上要哦，有时你会在这里得到一些奇怪的linting错误。

22484
30:40:23.306 --> 30:40:24.781
我只需要忽略TS。

22485
30:40:24.781 --> 30:40:26.660
有时你在这里也会得到。

22486
30:40:26.660 --> 30:40:28.710
事实上，我们甚至不需要网络。

22487
30:40:28.710 --> 30:40:29.300
好的,很酷。

22488
30:40:29.300 --> 30:40:31.204
是的，你甚至不需要网络环路。

22489
30:40:31.204 --> 30:40:33.425
有时我们会得到一些奇怪的毛线错误。

22490
30:40:33.425 --> 30:40:38.516
有时候Vyas代码很难理解，比如我们做的覆盖。

22491
30:40:38.516 --> 30:40:46.943
所以只要运行那个TS ignore if如果它给你一些，一些工程师，不管怎样，我们有这个哦，要部署时间锁，我们要部署时间锁合同。

22492
30:40:46.943 --> 30:40:54.110
我们要从这里借用很多东西，所以我要回到这里实际上是复制粘贴上面的这两位。

22493
30:40:54.110 --> 30:41:00.715
同样，我们要做的是const deploytimelock将是一个部署函数，

22494
30:41:00.715 --> 30:41:07.494
它将是一个async函数在运行时环境中取心脏作为参数，很酷，几乎完全一样抱歉。

22495
30:41:07.494 --> 30:41:14.868
然后我们将得到前三行，或者前四行，比索，然后我们将得到这里完全相同的东西。

22496
30:41:14.868 --> 30:41:17.804
我们将要做几乎完全相同的事情。

22497
30:41:17.804 --> 30:41:20.007
我们将进行日志部署。

22498
30:41:20.007 --> 30:41:24.730
时间锁，点时间锁，会做const。

22499
30:41:24.730 --> 30:41:28.456
标记等于等待，部署，解锁。

22500
30:41:28.456 --> 30:41:32.360
我们在这里添加一些参数，我们说from Deployer。

22501
30:41:32.360 --> 30:41:36.860
这需要一些论证吗?确实如此。

22502
30:41:36.860 --> 30:41:41.600
好的，我们可以看看时间锁，最小延迟提议者和执行者。

22503
30:41:41.600 --> 30:41:46.980
我们希望最小延时是多少?这个值我们会经常用到。

22504
30:41:46.980 --> 30:41:51.479
我通常会创建一个名为helper的新文件。

22505
30:41:51.479 --> 30:41:53.202
安全帽配置。

22506
30:41:53.202 --> 30:41:53.417
ts。

22507
30:41:53.417 --> 30:41:58.265
在顶部，我写上Export const min。

22508
30:41:58.265 --> 30:42:02.375
延迟，我可以让这个延迟变成我想要的样子。

22509
30:42:02.375 --> 30:42:09.057
所以我们继续做3600，大概是一个小时，对吧，你要等这么多秒，我想是一个小时。

22510
30:42:09.110 --> 30:42:10.581
不用老的计算器。

22511
30:42:12.110 --> 30:42:12.569
分钟。

22512
30:42:12.569 --> 30:42:12.962
太好了。

22513
30:42:12.962 --> 30:42:14.601
要一个小时。

22514
30:42:16.110 --> 30:42:17.717
我们要把它导入这里。

22515
30:42:18.110 --> 30:42:19.713
导入，最小延时。

22516
30:42:23.110 --> 30:42:27.395
从helper，你知道，它是下目录，helper Hardhead config。

22517
30:42:27.395 --> 30:42:29.490
这是我们的第一个论点。

22518
30:42:29.490 --> 30:42:31.475
我们的第二个论点是一系列的建议。

22519
30:42:31.475 --> 30:42:33.125
现在我们先把它空着。

22520
30:42:33.125 --> 30:42:38.485
还有执行人列表我们暂时把它留空，我们一会儿会更新这个。

22521
30:42:38.485 --> 30:42:41.985
你就会明白为什么我们到这里，我们用log true。

22522
30:42:42.110 --> 30:42:46.310
这在我的GitHub中也有一个等待确认的东西，但我们现在先跳过这个。

22523
30:42:46.310 --> 30:42:49.421
它还有一个自动验证，我们先跳过这个。

22524
30:42:49.421 --> 30:42:53.205
然后我们只需要导出default，部署timelock。

22525
30:42:53.205 --> 30:42:55.376
砰，我们应该没问题。

22526
30:42:55.376 --> 30:42:58.509
让我们试着在安全帽部署时运行这个。

22527
30:42:58.509 --> 30:43:04.054
现在它应该运行这两个伟大的部署治理令牌部署时间锁。

22528
30:43:04.110 --> 30:43:08.946
很好，我们现在正在浏览我们想要部署治理契约的内容。

22529
30:43:08.946 --> 30:43:10.036
我们来做一下。

22530
30:43:10.110 --> 30:43:13.906
我们要做哦，三个LOI。

22531
30:43:13.906 --> 30:43:16.346
政府，也不是合同。

22532
30:43:16.346 --> 30:43:16.617
ts。

22533
30:43:18.110 --> 30:43:21.546
猜猜看，这和我们刚才做的很像。

22534
30:43:21.546 --> 30:43:21.873
正确的。

22535
30:43:21.873 --> 30:43:26.143
在部署时间锁中，我们抓取上面两个东西。

22536
30:43:26.143 --> 30:43:27.538
我们把它粘贴在这里。

22537
30:43:27.538 --> 30:43:34.289
我们会使用const deploy, governance或contract，这里会

22538
30:43:34.289 --> 30:43:41.041
有一个apply函数，它是一个async函数，在运行时环境中取一部分，保存并关闭它。

22539
30:43:41.041 --> 30:43:48.633
我们甚至可以返回，抓取这三行。哦，要部署时间锁，把它粘贴到这里，因为我们需要得到完全相同的东西。

22540
30:43:48.633 --> 30:43:54.297
此外，为此，我们需要获得治理令牌和Time Lock契约。

22541
30:43:54.297 --> 30:43:58.710
我们用const治理，token = await。

22542
30:43:58.710 --> 30:44:06.843
Get实际上，我们有这个，这个Get函数来自于这些部署，它实际上只是出去获取这些部署。

22543
30:44:06.843 --> 30:44:09.176
我们说get Gover Nance token。

22544
30:44:09.176 --> 30:44:13.610
然后我们还要拿到时间锁。

22545
30:44:13.610 --> 30:44:16.060
等待，获取m锁。

22546
30:44:16.060 --> 30:44:22.025
我们需要将这些作为调控器契约的参数传递。

22547
30:44:22.110 --> 30:44:28.086
对吧?因为如果我们打开该灵魂的管理器契约，我们查看构造函数，它将令

22548
30:44:28.086 --> 30:44:34.062
牌、Time Lock投票、延迟投票周期和仲裁百分比作为输入参数。

22549
30:44:34.062 --> 30:44:38.919
所以我们会做一个快速的日志部署go burn或ello。

22550
30:44:39.110 --> 30:44:45.051
他们会写const govern nor contract = await,

22551
30:44:45.051 --> 30:44:50.837
deploy，并将部署治理或契约我不确定我是否总是拼写正确，但这没关系。

22552
30:44:50.837 --> 30:44:52.899
我们再做一次参数。

22553
30:44:52.899 --> 30:44:54.643
它将来自Deployer。

22554
30:44:54.643 --> 30:44:57.243
参数将是这个参数列表。

22555
30:44:57.243 --> 30:45:02.802
它首先需要的是什么?它首先需要令牌和时间锁。

22556
30:45:02.802 --> 30:45:08.610
我们会写governance token。address，然后它需要Time Lock那个地址。

22557
30:45:08.610 --> 30:45:13.765
我们需要就投票延迟投票时间和法定人数百分比进行投票。

22558
30:45:13.765 --> 30:45:17.355
这些也是我们会经常用到的值。

22559
30:45:17.355 --> 30:45:21.903
让我们打开助手Hardhead配置，让我们也创建这些。

22560
30:45:21.903 --> 30:45:24.962
因此我们写入Export const just voting period。

22561
30:45:24.962 --> 30:45:29.798
我们会说这将是五个block，我们会做export const

22562
30:45:29.798 --> 30:45:34.946
voting delay，这将是一个block，我知道这非常快。

22563
30:45:34.946 --> 30:45:40.002
然后我们需要export const Orem

22564
30:45:40.002 --> 30:45:45.938
percentage，也就是4%的选民总是需要投票。

22565
30:45:45.938 --> 30:45:50.047
不好意思，需要4%的选民投赞成票才能通过。

22566
30:45:50.047 --> 30:45:50.422
太好了。

22567
30:45:50.422 --> 30:45:54.860
我们要做投票延迟投票百分比法定人数百分比。

22568
30:45:54.860 --> 30:46:01.073
所以我们会导入这些来导入投票延迟投票周期，或

22569
30:46:01.073 --> 30:46:07.287
从助手Hardhead配置的法定人数百分比。

22570
30:46:07.287 --> 30:46:12.579
现在我们有了这些延迟周期百分比，我们可以做投票延

22571
30:46:12.579 --> 30:46:17.872
迟，投票周期，农场百分比，然后我们说log为真。

22572
30:46:17.872 --> 30:46:19.499
同样，这个也是。

22573
30:46:19.499 --> 30:46:24.028
它有一个等待确认和自动验证我们会完全忽略它。

22574
30:46:24.028 --> 30:46:27.523
然后导出违约，血腥总督合同。

22575
30:46:27.523 --> 30:46:29.178
凯莉，我们开始辣了。

22576
30:46:29.178 --> 30:46:30.899
我们来确认一下。

22577
30:46:30.899 --> 30:46:31.951
纱线硬帽部署。

22578
30:46:31.951 --> 30:46:34.618
我们应该看到这里部署了三个契约。

22579
30:46:34.618 --> 30:46:40.056
我认为要编译治理，令牌部署时间锁部署治理契约部署。

22580
30:46:40.110 --> 30:46:40.776
我们走吧。

22581
30:46:40.776 --> 30:46:41.442
好吧。

22582
30:46:41.442 --> 30:46:43.442
现在，我们还没有做完。

22583
30:46:45.110 --> 30:46:45.755
部署脚本。

22584
30:46:47.110 --> 30:46:48.360
管理合同。

22585
30:46:48.360 --> 30:46:48.672
好的。

22586
30:46:48.672 --> 30:46:50.672
这一点非常重要。

22587
30:46:51.110 --> 30:46:55.720
现在我们的时间锁定合同没有申请人也没有执行人。

22588
30:46:55.720 --> 30:46:56.126
正确的。

22589
30:46:56.126 --> 30:47:01.655
所以我们想要改变我们想要只允许提议者成为管理者，管理者合同应该

22590
30:47:01.655 --> 30:47:07.364
是唯一提出事情的人时间锁，然后任何人都应该能够执行它的工作方式。

22591
30:47:07.364 --> 30:47:13.479
我们说，治理契约一旦进入时间锁，就会向时间锁提出一些建议，并在这段时间内等待。

22592
30:47:13.479 --> 30:47:15.694
任何人都可以去执行它。

22593
30:47:15.694 --> 30:47:18.610
所以州长让每个人都投票。

22594
30:47:18.610 --> 30:47:23.847
一旦投票通过，州长说，时间锁，你能提出这个吗?汤姆说，当然可以。

22595
30:47:23.847 --> 30:47:28.610
但我们需要等待，这个最小延迟，一旦它被延迟，任何人都可以执行它。

22596
30:47:28.610 --> 30:47:34.177
这将是一个很酷的集成，顺便说一下，这将是一个很酷的集成，为了让链链保持器自动执行。

22597
30:47:34.177 --> 30:47:36.007
反正我也要造下一个。

22598
30:47:36.110 --> 30:47:44.566
我们需要设置它，让它这样工作，我们会创建一个新的deploy叫做，哦，第四，setup，治理契约。TypeScript。

22599
30:47:44.566 --> 30:47:48.143
这段代码将完成所有的设置。

22600
30:47:48.143 --> 30:47:51.663
这看起来和其他的deploy函数非常相似。

22601
30:47:51.663 --> 30:47:57.961
我们会从3往回走，我们会把上面的两个粘贴到这里，当然，我们会做const

22602
30:47:57.961 --> 30:48:04.259
setup契约，它会是一个部署函数，还是一个async函数，它会把HRV

22603
30:48:04.259 --> 30:48:11.432
art at runtime environment作为参数，然后这就是赢家。

22604
30:48:11.432 --> 30:48:11.754
酷。

22605
30:48:11.754 --> 30:48:20.432
我们会从上面抓取同样的三个，你可以看到，这变得更容易了，因为它有点重复，对，我们会抓取这里的那一点。

22606
30:48:20.432 --> 30:48:23.125
现在我们要拿到这些合同这样我们就可以和他们互动了。

22607
30:48:23.125 --> 30:48:29.308
这也是为什么硬帽部署如此好用的另一个原因，因为我们可以用const

22608
30:48:29.308 --> 30:48:37.179
timelock = await ethers进入下一个我们继续从硬帽导入导入醚。

22609
30:48:37.179 --> 30:48:43.296
从红帽的醚甚至会下降一点TS忽略这里。

22610
30:48:43.296 --> 30:48:46.519
没有合同，我们要那个时间锁定合同。

22611
30:48:46.519 --> 30:48:48.940
我们说我们想把它附加到部署器。

22612
30:48:48.940 --> 30:48:51.699
无论何时我们在上面调用函数，

22613
30:48:51.699 --> 30:49:02.144
都是部署者调用那个函数我们要做const总督= await ethers。get总督，这都将附加到部署者。

22614
30:49:02.144 --> 30:49:02.557
正确的。

22615
30:49:02.557 --> 30:49:05.432
现在，我们要做log设置角色。

22616
30:49:05.432 --> 30:49:10.975
我们要设置好角色，再一次，我们要设置好只有调控器才能向这个

22617
30:49:10.975 --> 30:49:16.710
时间锁发送东西，因为时间锁将是你几乎可以把时间锁想象成总统。

22618
30:49:16.710 --> 30:49:16.928
正确的。

22619
30:49:16.928 --> 30:49:23.060
所以所有的事情都交给参议院，众议院代表，也就是州长，然后总统说，是的，当然。

22620
30:49:23.110 --> 30:49:29.736
我们只需要等待这个最小延迟，但总统将是真正执行所有事情的那个我不确定它在政治中是如

22621
30:49:29.736 --> 30:49:36.363
何工作的，但现在，这是我们保护总统的地方或者说时间like是唯一可以做任何事情的。

22622
30:49:36.363 --> 30:49:42.355
这个工作的方式是我们实际上会得到不同角色的字节码，

22623
30:49:42.355 --> 30:49:48.348
对吧?如果你看这里的时间锁，我们会在合同上做一些。

22624
30:49:48.348 --> 30:49:50.749
我们来看看治理。

22625
30:49:50.749 --> 30:49:57.300
Tama控制器有这些东西叫做提案滚动，执行者滚动时间，比如管理等。

22626
30:49:57.300 --> 30:50:00.347
这些就是这些字符串的散列。

22627
30:50:00.347 --> 30:50:08.381
但是这些是这些字节32说，嘿，任何有这个字节32的人是提议者，任何有这个字节32的人是执行者。

22628
30:50:08.381 --> 30:50:10.837
任何人都有这个字节，比如admin等等。

22629
30:50:10.837 --> 30:50:15.410
现在，我们的部署者帐户是管理员，这很糟糕。

22630
30:50:15.410 --> 30:50:22.077
我们不希望那样我们不希望任何人做时间管理员，对吧?我们不希望任何人拥有这个时间锁的权力。

22631
30:50:22.077 --> 30:50:24.437
我们不希望这里有任何集中力量。

22632
30:50:24.437 --> 30:50:28.077
我们要做的是我们要const我们要获取那些角色。

22633
30:50:28.077 --> 30:50:34.432
提议者，提议者角色，这将是一个权重，解锁那个行极，Sir角色。

22634
30:50:34.432 --> 30:50:41.922
如果你熟悉多呼叫，这将是一个很好的时间来做多呼叫复制粘贴整个线路xeq

22635
30:50:41.922 --> 30:50:49.626
tour角色在xeq tour roll，我们将复制整个线路管理角色。

22636
30:50:49.626 --> 30:50:52.730
这将是onlockadmin角色。

22637
30:50:52.730 --> 30:50:58.376
这就是我们需要修正的三个角色，让我们继续修正它们。

22638
30:50:58.376 --> 30:51:03.652
首先我们需要做的是const row poser dx = await

22639
30:51:03.652 --> 30:51:09.834
Time Lock。grant roll，向我们的总督。address发起滚动。

22640
30:51:09.834 --> 30:51:16.547
所以说，好吧，州长，你是唯一一个可以做任何事的人只要你让时间锁做某事。

22641
30:51:16.547 --> 30:51:18.860
我们会等待时间锁定期结束。

22642
30:51:18.860 --> 30:51:20.010
然后我们就做完了。

22643
30:51:20.110 --> 30:51:25.077
然后我们会做一个await posittx。wait一个block来确保。

22644
30:51:25.077 --> 30:51:33.234
现在我们要做const executor, TX = await Time Lock。grant roll

22645
30:51:33.234 --> 30:51:42.776
executor role给任何人，我们要执行这个我们不把这个给任何人，我们要写address 0这是我们要添加的东西如果我

22646
30:51:42.776 --> 30:51:52.011
西如果我们去helper或者head config会说Export const address 0 = 0你可以复制粘贴这个。

22647
30:51:52.011 --> 30:51:54.541
对醚也有几种其他的方法。

22648
30:51:54.541 --> 30:51:55.925
我们就这样做。

22649
30:51:55.925 --> 30:52:04.772
我喜欢有这样的冲突然后我们直接导入输入import at 0 from。

22650
30:52:04.772 --> 30:52:08.691
所以我们不把执行者的角色交给任何人，也就是所有人。

22651
30:52:08.691 --> 30:52:13.044
一旦提案通过，任何人都可以执行。

22652
30:52:13.044 --> 30:52:16.694
我们说executor, TX那个等一个等一个块。

22653
30:52:16.694 --> 30:52:21.222
这里还有一件事要做，我们现在需要撤销角

22654
30:52:21.222 --> 30:52:25.990
色我们的部署者计数拥有那个时间锁控制器。

22655
30:52:25.990 --> 30:52:33.852
这就是我们做这些事务的方式，我们可以授予角色因为我们的部署者账户拥有它现在我们给了每个人访问权限。

22656
30:52:33.852 --> 30:52:38.296
考虑到我们所需要的去中心化访问，我们想撤销这个角色。

22657
30:52:38.296 --> 30:52:40.666
const revoke TX = await。

22658
30:52:40.666 --> 30:52:47.630
我锁定了撤销角色，来自部署者的管理角色会做Rotex等待，现在

22659
30:52:47.630 --> 30:52:54.594
猜猜，任何想做的事都要经过治理，没有人拥有时间I控制器，目前在

22660
30:52:54.594 --> 30:53:01.559
运行后，任何人都不可能在没有治理发生的情况下用时间锁做任何事。

22661
30:53:01.559 --> 30:53:05.562
当然，当输出违约合约集时，很好。

22662
30:53:05.562 --> 30:53:10.311
最后一步，我们需要部署我们想要管理

22663
30:53:10.311 --> 30:53:15.061
的契约写方框契约，真正的基本契约。

22664
30:53:15.061 --> 30:53:17.307
所以我们要创建一个新的105，部署框。

22665
30:53:17.307 --> 30:53:17.438
ts。

22666
30:53:17.438 --> 30:53:23.563
我们会做一些和之前做的完全一样的事情，我们会抓取这两行，这里的这两行，粘贴进去，os

22667
30:53:23.563 --> 30:53:30.709
deploy box会是一个deployfunction = async function，抱歉，

22668
30:53:30.709 --> 30:53:38.731
是hard hat runtime environment，我们会抓取前三行，TS ignore，就像这样。

22669
30:53:38.731 --> 30:53:41.420
现在我们要展开这个盒子。

22670
30:53:41.420 --> 30:53:46.715
log，部署bucks，我们会写const box

22671
30:53:46.715 --> 30:53:52.011
= await，部署框，从部署器中给我们一些值。

22672
30:53:52.011 --> 30:53:56.643
这个有任何args所以打开一个box。soul，我没有看到一个构造函数。

22673
30:53:56.643 --> 30:54:04.197
虽然这是所有这些契约中最简单的，没有构造函数，然后我们说log，它是真的。

22674
30:54:04.197 --> 30:54:10.711
如果你想查看我的GitHub回购来获取确认，请随时点击这里。

22675
30:54:10.711 --> 30:54:15.385
现在，我们的部署者实际上部署了这个，而不是我们的时间锁。

22676
30:54:15.385 --> 30:54:20.476
因此，我们希望将这些盒子的所有权交给我们的治理过程。

22677
30:54:20.476 --> 30:54:26.216
现在我们要做的是const timelock，它将是一个weight ethers。get contract。

22678
30:54:26.216 --> 30:54:27.970
和之前一样。

22679
30:54:28.111 --> 30:54:28.825
timelock。

22680
30:54:33.111 --> 30:54:34.750
乙醚从安全帽。

22681
30:54:38.111 --> 30:54:39.396
这是过分挑剔。

22682
30:54:42.111 --> 30:54:48.274
盒子对这个时间锁的所有权，这就是所谓的盒子部署。

22683
30:54:48.274 --> 30:54:50.456
在此之前，我们必须得到盒子合约。

22684
30:54:50.456 --> 30:54:58.663
这是一个盒状部署对象，它没有契约函数我们想要得到这个盒状契约对象因此我们输入box或const box

22685
30:54:58.663 --> 30:55:07.998
contract = await ethers。get contract at box然后我们就把那个地址框起来。

22686
30:55:07.998 --> 30:55:09.511
你也可以得到合同。

22687
30:55:09.511 --> 30:55:14.161
实际上这两个都很如果你有地址，你可以把地址框起来。

22688
30:55:14.161 --> 30:55:15.677
你也可以在这里签合同。

22689
30:55:15.677 --> 30:55:21.745
现在我们有了盒子契约，我们做const transfer owner,

22690
30:55:21.745 --> 30:55:29.026
dx等于await by contract。transfer TX或者schema。

22691
30:55:29.026 --> 30:55:36.307
transfer所有权给我们的timelock。address time walk。

22692
30:55:36.307 --> 30:55:44.111
address，然后我们做一个权转移所有权TX。weight 1，做一个log，完成了。

22693
30:55:44.111 --> 30:55:47.682
这些是export default。

22694
30:55:47.682 --> 30:55:49.253
部署的盒子。

22695
30:55:49.253 --> 30:55:52.504
哦，让我们看看这是否有效。

22696
30:55:52.504 --> 30:55:54.635
所以我们做了所有的事情。

22697
30:55:54.635 --> 30:56:00.113
我们部署了GOV令牌，部署了时间锁，它拥有治理过程，我

22698
30:56:00.113 --> 30:56:05.795
们部署了治理过程，我们设置了治理过程，使其完全去中心化。

22699
30:56:05.795 --> 30:56:13.023
然后我们部署并设置了我们的盒子，以便它只能通过治理流程进行更新。

22700
30:56:13.111 --> 30:56:14.832
让我们看看它是否有效。

22701
30:56:14.832 --> 30:56:16.635
纱线，戴上安全帽。

22702
30:56:18.111 --> 30:56:18.549
的工作原理。

22703
30:56:18.549 --> 30:56:20.829
嘣，你成功了。

22704
30:56:23.111 --> 30:56:28.401
脚本来设置整个治理过程，这样您就可以建立自己的怀疑。

22705
30:56:28.401 --> 30:56:36.687
你还在吗?嗯，是的，你是，恭喜你走了这么远，我们还有一个作品要做，我们只需要写那些脚本。

22706
30:56:36.687 --> 30:56:42.304
我们可以与它交互，我们可以进行治理，我们可以确切地看到治理过程是什么样子的。

22707
30:56:42.304 --> 30:56:48.788
现在，如果你没有看过我上一个关于道斯的视频，一定要看那个视频，因为那会给你这部分的所有背景知识。

22708
30:56:48.788 --> 30:56:56.917
如果你仍然百分之百地观看，点击点赞按钮，点击订阅，在下方评论区留言，这对我们的频道很有帮助。

22709
30:56:56.917 --> 30:56:58.192
真为你骄傲，能走这么远。

22710
30:56:58.192 --> 30:57:00.479
就快完成了，还剩一个了。

22711
30:57:00.479 --> 30:57:03.838
然后你就可以自由地制造你的怀疑了。

22712
30:57:03.838 --> 30:57:05.928
我们继续吧。

22713
30:57:06.111 --> 30:57:13.261
好了，现在我们要做一些脚本来与提议Q交互，并对Dao中发生的任何事情进行投票。

22714
30:57:13.261 --> 30:57:19.356
这些是脚本，这些是你在构建这个的时候会做的事情当你在构建你的怀疑的时候。

22715
30:57:19.356 --> 30:57:23.059
你也可以用快照或计数做积分。

22716
30:57:23.111 --> 30:57:27.817
如果你想在GitHub上看到完整的功能，我有这个测试流程。

22717
30:57:27.817 --> 30:57:29.416
这不是这里最大的考验。

22718
30:57:29.416 --> 30:57:35.721
但你也可以看看这个，因为它也做了一个从汤到坚果的演示，通过这个确切的过程。

22719
30:57:35.721 --> 30:57:37.444
让我们继续，开始制作一些脚本。

22720
30:57:37.444 --> 30:57:39.824
我们要创建一个名为scripts的新文件夹。

22721
30:57:39.824 --> 30:57:42.661
这是我们要放所有脚本的地方。

22722
30:57:42.661 --> 30:57:49.530
这个过程是我们首先要提出一些建议，对吧?你知道，也许我们会建议我们的

22723
30:57:49.530 --> 30:57:56.603
盒子契约存储的值是77，对吧?因为当它第一次被初始化时，它会从0开始。

22724
30:57:56.603 --> 30:57:59.852
也许我们会提议从77岁开始。

22725
30:57:59.852 --> 30:58:02.644
求婚一旦完成，我们就会进行投票。

22726
30:58:02.644 --> 30:58:07.976
一旦提案提出，我们就会投票决定我们是否希望提案通过，是还是否。

22727
30:58:07.976 --> 30:58:13.388
如果它通过，我们会先排队执行。

22728
30:58:13.388 --> 30:58:17.904
然后我们执行，我把它们放在同一个脚本里，这样更简单。

22729
30:58:17.904 --> 30:58:22.303
我们从求婚开始，因为这是我们要做的第一件事。

22730
30:58:22.303 --> 30:58:23.703
我们来创建一个新函数。

22731
30:58:23.703 --> 30:58:29.843
我们称它为async function，然后我们将它导出为export async function proposal。

22732
30:58:29.843 --> 30:58:31.559
我们要在这里待一会儿。

22733
30:58:31.559 --> 30:58:32.777
我们把所有东西都清空。

22734
30:58:32.777 --> 30:58:33.491
好的，很酷。

22735
30:58:33.491 --> 30:58:39.370
这就是我们要在州长合同上提出的建议，对吧?所以我们要提出一份新的州长合同。

22736
30:58:39.370 --> 30:58:41.848
所以我们首先需要的，当然是州长。

22737
30:58:41.848 --> 30:58:48.497
所以你不能统治或等于等待他人得到契约，统治或契约，

22738
30:58:48.497 --> 30:58:55.146
对吧?因为我们在做醚，我们需要从心脏app导入醚。

22739
30:58:55.146 --> 30:58:59.046
然后我们仍然得到基本的东西。

22740
30:58:59.046 --> 30:59:01.253
我们会在这里做一个AT, t，忽略。

22741
30:59:01.253 --> 30:59:01.431
酷。

22742
30:59:01.431 --> 30:59:09.258
这里有总督契约，我们还需要盒子契约，我们要提议盒子契约改变存储值。

22743
30:59:09.258 --> 30:59:13.789
我们写入const box = await ethers。get这是一个礼

22744
30:59:13.789 --> 30:59:18.321
物契约，我们想要get contract, get contractat。

22745
30:59:18.321 --> 30:59:22.058
这是我们开始时需要的两个主要的。

22746
30:59:22.111 --> 30:59:29.061
现在，如果我们看看提议的功能，如果我们去治理，我们去总督，我们看看提议的功能。

22747
30:59:29.111 --> 30:59:30.007
这就是它的样子。

22748
30:59:31.111 --> 30:59:32.282
函数在上个视频中。

22749
30:59:34.111 --> 30:59:42.498
回去看一下因为它会给你所有你需要知道的东西基本上我们选择一个目标列表，我们的列表就是我们的盒子合同。

22750
30:59:42.498 --> 30:59:47.159
这些是我们想要调用函数的目标，我们做一些值，比如我们想要发送多少

22751
30:59:47.159 --> 30:59:51.820
以太，我们不会发送任何东西，我们有字节，一个叫做data的数组。

22752
30:59:51.820 --> 30:59:57.911
这就是我们要调用的函数的编码参数然后是描述。

22753
30:59:57.911 --> 31:00:00.079
这就是我们要做的。

22754
31:00:00.079 --> 31:00:02.175
首先，我们要弄清楚我们要做什么。

22755
31:00:02.175 --> 31:00:05.548
看看Box，我们将用这个新值调用这个store函数。

22756
31:00:05.548 --> 31:00:08.798
所以我们需要编码我们需要编码这只袜子。

22757
31:00:08.798 --> 31:00:14.825
我们还需要编码我们想要升级的东西所以我们必须编码所有的函数参数。

22758
31:00:14.825 --> 31:00:23.120
我们将使用const编码的函数调用= box我们得到这个box的方法就是编码函数数据的接口这就是

22759
31:00:23.120 --> 31:00:31.415
将它变成字节调用数据的方法，对吧?我们对所有东西进行编码，这个编码的函数，你可以在ethers文

22760
31:00:31.415 --> 31:00:39.711
档中找到这个，我们必须给它传递要调用的函数，然后是我们想传递的参数，这就是我们实际得到它的方式。

22761
31:00:39.711 --> 31:00:41.977
我们来看看这些论证。

22762
31:00:42.111 --> 31:00:45.491
我们会说args，我们会让我们提出的函数有点模块化。

22763
31:00:45.491 --> 31:00:51.072
我们会说args将是一个任何数组，然后我们会说函数要调用的将是

22764
31:00:51.072 --> 31:00:56.653
一个字符串，然后在底部，我们实际上会调用这个，这个提议的函数。

22765
31:00:56.653 --> 31:01:03.111
假设我们要给它77，函数将会是store store。

22766
31:01:03.111 --> 31:01:04.444
这是一个字符串。

22767
31:01:04.444 --> 31:01:06.301
这需要一个清单。

22768
31:01:06.301 --> 31:01:07.777
我们要这样做。

22769
31:01:07.777 --> 31:01:10.586
现在，我们要在所有地方都用到它。

22770
31:01:10.586 --> 31:01:16.544
因为我们要在所有地方使用这个，我们要把它们粘在这个部分headhelper配置中。

22771
31:01:16.544 --> 31:01:21.416
我们要做的是，输入export const, new store value = 77。

22772
31:01:21.416 --> 31:01:25.968
然后输出const funk = store。

22773
31:01:25.968 --> 31:01:30.163
我建议，我们把它们导入。

22774
31:01:30.163 --> 31:01:34.428
我们会导入，new store value，还有funk from

22775
31:01:34.428 --> 31:01:39.211
helper Hardhead。config，它为我们添加了它，这很好。

22776
31:01:39.211 --> 31:01:41.295
我们在这里写上新的存储值。

22777
31:01:41.295 --> 31:01:42.771
然后我们在这里放放克。

22778
31:01:42.771 --> 31:01:49.818
我知道这可能看起来有点混乱，但基本上，我们要做的第一件事是我们要调用这个提议的函数它调用上面的post函数。

22779
31:01:49.818 --> 31:01:54.277
现在我们要做一些有趣的事情然后处理出口0。

22780
31:01:54.277 --> 31:01:59.677
然后我们会做一个。catch error，如果有错误，

22781
31:01:59.677 --> 31:02:05.277
我们会做console。log error，然后处理它。

22782
31:02:05.277 --> 31:02:11.349
这是你使用的任何脚本的典型设置，还有硬帽。

22783
31:02:11.349 --> 31:02:11.777
太好了。

22784
31:02:11.777 --> 31:02:15.900
我们有一个常数编码函数调用，它有一个函数来调用弧。

22785
31:02:15.900 --> 31:02:18.717
我们基本上是把这些合并到这个字节里。

22786
31:02:18.717 --> 31:02:20.864
我们甚至可以把它打印出来，你可以看到它是什么样的。

22787
31:02:20.864 --> 31:02:25.111
你用console。log，看到了吧，这个疯狂的字节。

22788
31:02:25.111 --> 31:02:33.449
我们的测试方法是，我们用纱线硬帽节点，它会再次向上旋转，我们的假区块链。

22789
31:02:33.449 --> 31:02:38.716
另外，使用Hardhead deploy，它会在这里部署我们所有的契约，对

22790
31:02:38.716 --> 31:02:44.127
吧，我们可以看到时间日志治理，你知道，我们在本地测试所需的一切都已经完成了。

22791
31:02:44.127 --> 31:02:52.424
一旦我们有了那个，我们就能做yarn hardhat，运行脚本，建议TS dash network，

22792
31:02:52.424 --> 31:03:00.888
本地主机，这很重要，因为当你处理一个本地运行的节点时，你会处理本地主机，我们会看到它在这里打印出什么。

22793
31:03:01.111 --> 31:03:05.035
合同命名为总督合同，总督合同。

22794
31:03:05.111 --> 31:03:06.422
让我们再试一次。

22795
31:03:09.111 --> 31:03:14.223
编码的函数调用和参数看起来像一个很长的字节字符串。

22796
31:03:14.223 --> 31:03:20.890
但如果你要解码这个，使用盒子接口，你会得到函数调用和参数，这非常令人兴奋。

22797
31:03:20.890 --> 31:03:22.689
太酷了，我们把它编码成字节。

22798
31:03:22.689 --> 31:03:27.957
现在我们要做的是，我们鼓励字节，现在我们要创建提议事务。

22799
31:03:27.957 --> 31:03:36.291
所以我们写console。log会说pro。然后说，函数调用box那个地址，带args。

22800
31:03:36.291 --> 31:03:39.841
然后我们还需要通过提案描述。

22801
31:03:39.841 --> 31:03:45.044
我们会写pro pose，所有描述，我们会在换行，

22802
31:03:45.044 --> 31:03:50.039
为什么不呢?专业人士把所有这些选项，我们还没有。

22803
31:03:50.111 --> 31:03:50.968
好吧，我们会得到它的。

22804
31:03:52.111 --> 31:03:55.852
描述，对，因为我们在下面有描述。

22805
31:03:56.111 --> 31:03:58.422
让我们在这里为我们的提议添加另一个参数。

22806
31:03:59.111 --> 31:04:03.373
提案描述，这也是一个字符串。

22807
31:04:04.111 --> 31:04:07.063
下面，我们还需要提案描述。

22808
31:04:07.111 --> 31:04:12.666
我们会创建一个proposal或者export const proposal description，这里会有一些字符串。

22809
31:04:12.666 --> 31:04:20.957
所以我们写提案1,77号门，在方框里，这是描述，逗号，提案描述。

22810
31:04:20.957 --> 31:04:23.223
然后我们导入这个或者一个helper配置。

22811
31:04:23.223 --> 31:04:23.900
好的,完美的。

22812
31:04:23.900 --> 31:04:30.456
现在我们有了新的存储值，函数提案描述，我们现在可以调用我们刚才

22813
31:04:30.456 --> 31:04:37.225
看到的那个提案这是我们要做的const提案TX = await。

22814
31:04:37.225 --> 31:04:38.585
政府没有提议。

22815
31:04:38.585 --> 31:04:40.754
我们需要通过那些名单。

22816
31:04:40.754 --> 31:04:45.561
首先是一个目标列表，对我们来说就是一个只有一个目标的方框。

22817
31:04:45.561 --> 31:04:53.363
再说一次，这些小括号，让它成为一个值列表，它将是0，一个编码的函数调用列表

22818
31:04:53.363 --> 31:05:01.165
或者我们的字节数据，然后是提案描述，然后我们要做提案，TX。wait 1。

22819
31:05:01.165 --> 31:05:07.603
现在，如果你还记得，从复合，这将是完全一样的如果我们回到

22820
31:05:07.603 --> 31:05:14.042
复合回到治理，这个事务实际上将和这里创建的东西是一样的。

22821
31:05:14.111 --> 31:05:22.628
对吧?如果我们向下滚动，我们可以看到代码输入数据，这些东西在复合提案中完全相同，对吧?我们有目标

22822
31:05:22.628 --> 31:05:31.146
值签名，好的，这个CES有点，这个有点高级，使用签名，但它有相同的东西叫做数据，然后这里是描述。

22823
31:05:31.146 --> 31:05:36.438
现在由于我们有投票延迟，人们实际上不能投票，直到投票延迟通过。

22824
31:05:36.438 --> 31:05:43.444
现在，有了一个本地区块链，没有人会处理block，时间也不会像我们想的那么快。

22825
31:05:43.444 --> 31:05:46.924
为了我们自己的测试目的，我们要加快速度。

22826
31:05:46.924 --> 31:05:52.602
我通常的做法是创建这个这个变量，所有开发，

22827
31:05:52.602 --> 31:05:58.280
出口，在开发链上，我会添加硬帽和本地主机。

22828
31:05:58.280 --> 31:06:04.938
因为我们可以用我们自己的本地区块链做一些事情，我们可以加速时间，我们可以加速块，我们可以做所有这些疯狂的事情。

22829
31:06:04.938 --> 31:06:07.304
通常，我会把它导入这里。

22830
31:06:07.304 --> 31:06:08.658
然后我们做一个快速的F。

22831
31:06:08.658 --> 31:06:12.317
我会说，如果我们在开发链上，让我们继续前进，加快我们的速度。

22832
31:06:12.317 --> 31:06:12.937
正确的。

22833
31:06:12.937 --> 31:06:16.781
所以我会说if development chains，

22834
31:06:16.781 --> 31:06:22.619
其中包含network。name，然后我们也可以从ethers导入network。

22835
31:06:22.619 --> 31:06:25.539
这就是我所说的你要学习的六大技能。

22836
31:06:25.539 --> 31:06:32.852
如果它包含network。name，那么我们就会向前移动区块，因为如果我们不在开发链上，我们就不能移动区块。

22837
31:06:32.852 --> 31:06:38.611
这里我要做的是创建一个新文件夹，叫做utilities，你的文件夹，你就是utils。

22838
31:06:38.611 --> 31:06:42.495
在这里，我要创建一个名为Move blocks的脚本。

22839
31:06:42.495 --> 31:06:42.648
ts。

22840
31:06:42.648 --> 31:06:48.856
我们将创建这个叫move blocks的小函数，它为我们移动block。

22841
31:06:48.856 --> 31:06:49.958
你会看到我们是怎么做的。

22842
31:06:49.958 --> 31:06:57.788
我们会从heart app导入network，因为我们想加快投票延迟，我们会用export async function，我们称之为move blocks。

22843
31:06:57.788 --> 31:07:02.537
它需要一个量，这将是一个数字，所以我们实际上想移动多少块。

22844
31:07:02.537 --> 31:07:06.111
然后我们写console。log moving blocks。

22845
31:07:06.111 --> 31:07:12.064
我们说，for let index = 0, index小于amount。

22846
31:07:12.064 --> 31:07:19.861
index + +，或者我们要做的是我们要做一个权重网络DAP提供者。request request。

22847
31:07:19.861 --> 31:07:23.932
我们会请求方法EVM。

22848
31:07:23.932 --> 31:07:24.467
我的。

22849
31:07:24.467 --> 31:07:30.096
基本上，我们在挖掘我们本地的区块链，所以你可以在硬帽码

22850
31:07:30.096 --> 31:07:35.935
头找到这些码头在醚码头，有几个不同的地方你可以找到这些。

22851
31:07:35.935 --> 31:07:41.377
这是一种很酷的hack我们可以用它在本地链上向前移动块。

22852
31:07:41.377 --> 31:07:47.377
现在，很明显，这在一个实际的链上是行不通的，因为你实际上必须进行挖矿但在我们的本地链上，我们完全可以这样做。

22853
31:07:47.377 --> 31:07:52.379
我们导出了这个move blocks函数，我们会抓取Mark

22854
31:07:52.379 --> 31:07:57.548
的提议，我们会从utils blocks导入move box。

22855
31:07:57.548 --> 31:08:05.243
我们会在下面这里说，如果我们在这个开发链上，做一个权重移动块，然后我们会通过我们讨论过的投

22856
31:08:05.243 --> 31:08:13.111
票延迟移动块，对吧?因为我们需要等待投票延迟才能移动它看起来像是自动从助手硬件配置中导入它。

22857
31:08:13.111 --> 31:08:16.664
我告诉过你，我们会用几次，但我们会通过投票延迟来转移街区。

22858
31:08:16.664 --> 31:08:23.611
现在，这个提议的交易做了一些我们真正想要的东西，对吧?它想要的一件大事是，它有这个提案ID。

22859
31:08:23.611 --> 31:08:26.601
如果我们向下滚动到它发出的事件，

22860
31:08:26.601 --> 31:08:33.330
它最终会发出这个提案ID，当我们稍后进行投票时，我们实际上需要提案ID。

22861
31:08:33.330 --> 31:08:40.594
我们要做的是，我们实际上要做的是const proposal receipt = proposal text。weight。

22862
31:08:40.594 --> 31:08:43.918
我们将从这个提议的收据中得到那些事件。

22863
31:08:43.918 --> 31:08:45.727
我们会说const。

22864
31:08:45.727 --> 31:08:49.187
提案，id等于提议的收据，那个事件，

22865
31:08:49.187 --> 31:08:55.531
带event的0因为第一个事件是我们唯一关心的是你的停止提案id。

22866
31:08:55.531 --> 31:08:59.924
这就是我们如何从这个省略也创建的事件中获得这个提案ID。

22867
31:08:59.924 --> 31:09:03.327
有一些其他的方法来获得建议，以获得事件在硬帽。

22868
31:09:03.327 --> 31:09:05.800
我在我的YouTube上有一个视频，如果你想去看的话。

22869
31:09:05.800 --> 31:09:12.219
我们还想知道快照的截止日期是什么，你可以去我的GitHub看看快照是什么样子或者

22870
31:09:12.219 --> 31:09:18.799
截止日期，基本上，我们要投票多长时间，你知道你用的是什么快照，所有这些不同的东西。

22871
31:09:18.799 --> 31:09:22.080
但现在，我们将坚持这个提议。我一定会去GitHub看看更多的东西。

22872
31:09:22.112 --> 31:09:26.822
现在我们想要保存这个提案ID，我们想要保存它到某个地方以便我们的其他脚本

22873
31:09:26.822 --> 31:09:31.533
以便我们的投票，我们的队列和执行当我们运行这些时知道这个提案ID是什么。

22874
31:09:31.533 --> 31:09:35.535
我们要做的是创建这个文件，名为提案。JSON。

22875
31:09:35.535 --> 31:09:37.384
它会存储我们所有的建议。

22876
31:09:37.384 --> 31:09:42.921
我们写入pro poll, souls。JSON，这里会有我们所有的提案。

22877
31:09:42.921 --> 31:09:50.800
我们要做的是。我们要把这个添加到我们的助手Hardhead配置中，然后输出const，提案，file =提案。JSON。

22878
31:09:50.800 --> 31:09:55.159
我们将在顶部导入这个以及提案文件。

22879
31:09:55.159 --> 31:10:00.518
一旦我们得到这个提案ID，我们要做的是读取所有当前的提案。

22880
31:10:00.518 --> 31:10:07.263
我们会说，let建议书= JSON。parse，然后我们会做Fs。

22881
31:10:07.263 --> 31:10:13.804
read文件同步从这个探测建议书文件，我们会把它传递给utf8。

22882
31:10:13.804 --> 31:10:19.112
现在，这个f我们还没有得到，所以我们需要导入f。

22883
31:10:19.112 --> 31:10:22.695
我们要像这样把纱线加上f。

22884
31:10:22.695 --> 31:10:24.762
如果我们看的是package。JSON。

22885
31:10:24.762 --> 31:10:30.708
哦，我应该把它存成戴夫的，但我没有哦，那不重要。

22886
31:10:30.708 --> 31:10:33.918
现在我们有了这个，我们可以把它导入到TypeScript中。

22887
31:10:33.918 --> 31:10:38.243
我们只要说，从Fs导入*作为Fs。

22888
31:10:38.243 --> 31:10:42.580
现在我们可以用F F作为从文件中读取的一种方式。

22889
31:10:42.580 --> 31:10:44.361
现在我们可以拿到建议书的清单了。

22890
31:10:44.361 --> 31:10:48.062
我们有两个提议，现在我们只是做一个空白的JSON。

22891
31:10:48.112 --> 31:10:50.552
第一次运行时，它是空白的。

22892
31:10:51.112 --> 31:10:52.330
它会有东西在里面。

22893
31:10:54.112 --> 31:10:58.655
这些提案是我们会说pro提案network。config。

22894
31:10:58.655 --> 31:11:03.826
chain ID，这个小银行会说，是的，会有一个chain ID。

22895
31:11:03.826 --> 31:11:07.518
到字符串，我们会按链id存储它们。

22896
31:11:07.518 --> 31:11:11.033
所以对于每个我们有一个提议的网络我们会像这样开始。

22897
31:11:11.033 --> 31:11:13.440
然后是。push提案，id。

22898
31:11:13.440 --> 31:11:16.486
到字符串，然后再写回来。

22899
31:11:16.486 --> 31:11:21.312
Fs。right，文件同步，提案文件。

22900
31:11:21.312 --> 31:11:25.325
JSON处理字符串，提案，棒极了。

22901
31:11:25.325 --> 31:11:27.702
这就是我们要做的。

22902
31:11:27.702 --> 31:11:29.353
我们来运行一下这个。

22903
31:11:29.353 --> 31:11:35.259
然后这里有一些console。log说，嘿，这是提案的状态，它是打开的吗?是投票还是取消，等等。

22904
31:11:35.259 --> 31:11:39.049
提案快照是什么，你们知道的，再去我的GitHub看看。

22905
31:11:39.049 --> 31:11:45.273
但是我们能做的是，现在这个已经完成了，我们可以做纱线，Hardhead节点，旋转我们的小音符。

22906
31:11:45.273 --> 31:11:47.578
所有的合同都部署好了。

22907
31:11:47.578 --> 31:11:52.421
然后我们会做yarn，运行脚本，提出TS是

22908
31:11:52.421 --> 31:11:57.495
破折号网络，本地主机脚本提出TS是找不到的。

22909
31:11:57.495 --> 31:12:05.695
专业姿势，纱线，硬帽子，运行脚本，姿势id，哎呀，破折号网络，本地主机。

22910
31:12:05.695 --> 31:12:06.789
再试一次。

22911
31:12:06.789 --> 31:12:07.941
现在你找到了。

22912
31:12:07.941 --> 31:12:08.212
耶。

22913
31:12:08.212 --> 31:12:09.839
哦，我遇到了一个问题。

22914
31:12:10.112 --> 31:12:12.712
虽然描述无法读取未定义的属性0。

22915
31:12:12.712 --> 31:12:14.912
看看它在哪里生我的气。

22916
31:12:14.912 --> 31:12:16.439
Poser表单点事件。

22917
31:12:16.439 --> 31:12:19.979
它是本地主机上的事件，而不是事件拍摄。

22918
31:12:20.112 --> 31:12:22.322
好了，又碰到了一个问题。

22919
31:12:23.112 --> 31:12:23.505
的存在。

22920
31:12:23.505 --> 31:12:24.488
很好。

22921
31:12:27.112 --> 31:12:33.293
直接杀死节点，重启节点，所以你不可能有两个完全相同的提议。

22922
31:12:33.293 --> 31:12:35.954
所以我们不能那样做，我们需要改变描述之类的。

22923
31:12:35.954 --> 31:12:37.704
我们要杀死节点，然后重启。

22924
31:12:37.704 --> 31:12:39.515
现在我们再来运行一遍这个提案。

22925
31:12:39.515 --> 31:12:43.144
希望这次能成功。

22926
31:12:43.144 --> 31:12:47.207
共同财产零未定义欠收据。

22927
31:12:47.207 --> 31:12:53.997
这需要等待，因为它是一个承诺，再杀死它一次，我们运行它一旦所有这些部署。

22928
31:12:53.997 --> 31:12:56.238
我们将继续运行这个。

22929
31:12:56.238 --> 31:13:02.549
现在你可以看到这比你把它直接发送到一个测试网中要快得多要等很长时间，这一点都不好。

22930
31:13:02.549 --> 31:13:07.515
我们又碰到一个不能读取属性，push它们为undefined。

22931
31:13:07.515 --> 31:13:09.015
这也很有道理。

22932
31:13:09.112 --> 31:13:12.821
因为建议点JSON作为无链id。

22933
31:13:13.112 --> 31:13:13.595
231337.

22934
31:13:13.595 --> 31:13:16.498
我们会在这里列一个小列表。

22935
31:13:18.112 --> 31:13:18.612
空列表。

22936
31:13:21.112 --> 31:13:22.445
它。

22937
31:13:23.112 --> 31:13:25.378
一旦这个完成了，我们就继续做这个。

22938
31:13:25.378 --> 31:13:25.911
完美的。

22939
31:13:25.911 --> 31:13:33.234
现在我们要运行这个，现在它应该保存了，一切都很好。

22940
31:13:33.234 --> 31:13:33.935
太棒了。

22941
31:13:34.112 --> 31:13:37.612
提案一，把积木放在盒子里，我们把积木搬走。

22942
31:13:38.112 --> 31:13:41.577
我们看proposal。JSON，我们现在看到有一个提案列表。

22943
31:13:41.577 --> 31:13:44.474
这是我们刚创建的提案ID。

22944
31:13:44.474 --> 31:13:45.974
好吧，我们求婚了。

22945
31:13:45.974 --> 31:13:46.387
太棒了。

22946
31:13:46.387 --> 31:13:48.612
干得好，我们让Node继续运行。

22947
31:13:48.612 --> 31:13:51.882
希望我们能为投票做好准备。

22948
31:13:51.882 --> 31:13:54.315
现在让我们创建这个投票脚本。

22949
31:13:54.315 --> 31:13:58.531
好了，现在我们提议该投票了，让我们来投票吧。

22950
31:13:58.531 --> 31:14:01.962
这个看起来和那个脚本很像，我们刚刚创建的。

22951
31:14:01.962 --> 31:14:05.999
我们在New async function中，我们把这个叫做main

22952
31:14:05.999 --> 31:14:12.055
proposal index number，我们把这个叫做main因为我们要让vote函数有点不同。

22953
31:14:12.055 --> 31:14:12.621
你会看到原因的。

22954
31:14:12.621 --> 31:14:19.963
在底部，当然，我们会做main index。然后process。exit 0,

22955
31:14:19.963 --> 31:14:29.000
catch error箭头函数，console。error error，然后处理那个exit。

22956
31:14:29.000 --> 31:14:33.477
一个主指标，我们设指标0成本指标0。

22957
31:14:33.477 --> 31:14:35.456
这个成本指数就是邮政指数。

22958
31:14:35.456 --> 31:14:40.565
我们会得到。我们会得到第0位的index，对吧，提案。JSON中的第一个索引。

22959
31:14:40.565 --> 31:14:44.542
所以无论列表中的第一个是什么都是我们要用的，对吧?这就是我们现在想要的。

22960
31:14:44.542 --> 31:14:45.465
只有一个，所以很简单。

22961
31:14:45.465 --> 31:14:47.143
所以我们要把第一个放在这里。

22962
31:14:47.143 --> 31:14:51.576
所以我们要做的第一件事就是拿到提案的名单。

22963
31:14:51.576 --> 31:14:59.969
我们会写const proposal = JSON。parse FS。read文件同步建议书文件UTF 8。

22964
31:14:59.969 --> 31:15:03.901
当然，我们需要导入一些东西。

22965
31:15:03.901 --> 31:15:09.278
我们要导入提案文件，一个斜杠，一个Bernhard配置。

22966
31:15:09.278 --> 31:15:14.207
然后我们要import * as f。

22967
31:15:14.207 --> 31:15:14.778
太好了。

22968
31:15:14.778 --> 31:15:18.325
我们有f，我们可以读东西，我们可以得到那些船。

22969
31:15:18.325 --> 31:15:18.865
好的,很酷。

22970
31:15:18.865 --> 31:15:20.540
我们有一个提案id列表。

22971
31:15:20.540 --> 31:15:24.079
现在让我们得到提案的想法，我们将使用const probo。

22972
31:15:24.079 --> 31:15:28.505
ID也等于网络点配置的建议。

22973
31:15:28.505 --> 31:15:30.668
这不是我们想要的。

22974
31:15:30.668 --> 31:15:38.854
我们想要导入网络，从hard hat导入网络，网络点配置，那个链ID，

22975
31:15:38.854 --> 31:15:47.275
感叹号提案索引，对我们来说是零，对吧?我们收到了提案清单上的第一份提案。

22976
31:15:47.275 --> 31:15:49.816
现在我们要决定怎么投票了。

22977
31:15:49.816 --> 31:15:53.612
0等于1等于4,2等于弃权。

22978
31:15:53.612 --> 31:16:01.737
我不知道为什么你会弃权弃权会消耗汽油，你可以不投票，但我们会说const投票方式我们的投票方式等于1。

22979
31:16:01.737 --> 31:16:03.487
我们也可以给出一个理由。

22980
31:16:03.487 --> 31:16:09.038
所以如果我们回到我们的州长，有几个不同的功能来投票，有投票，我们只

22981
31:16:09.038 --> 31:16:14.758
是投了一票，投，有理由的投票，和有签名的投票，我们实际做了一个签名。

22982
31:16:14.758 --> 31:16:20.135
我问了这个问题，嘿，有病的人在论坛上投票是干什么的，我想，嘿，这是什么目

22983
31:16:20.135 --> 31:16:25.512
的是什么?我的直觉是，如果我不发送交易，任何人都可以代表我执行这个投票。

22984
31:16:25.512 --> 31:16:26.602
这就是事实。

22985
31:16:26.602 --> 31:16:35.285
该方法实现了一个元事务，并允许项目补贴投票费用，投票者可以免费生成签名，项目可以提交这些签名并支付汽油费用。

22986
31:16:35.285 --> 31:16:37.073
这是非常强大的。

22987
31:16:37.073 --> 31:16:43.366
这个函数允许这个，这个签名投票它允许快照链接集成，希望你们

22988
31:16:43.366 --> 31:16:49.659
中有人能构建，但对于我们来说，因为我们不实现这些元事务，这

22989
31:16:49.659 --> 31:16:55.954
些链外的东西，我们只会有理由地投票因为我们想给它一个理由。

22990
31:16:55.954 --> 31:16:56.848
真的是这样。

22991
31:16:56.848 --> 31:17:02.212
我们会说const boat TX response = await。

22992
31:17:02.212 --> 31:17:05.921
不好意思，我们需要得到政府合同。

22993
31:17:05.921 --> 31:17:07.259
我们用const。

22994
31:17:07.259 --> 31:17:10.947
政府也不平等等待别人得到合同。

22995
31:17:11.112 --> 31:17:11.702
政府合同。

22996
31:17:14.112 --> 31:17:14.492
醚。

22997
31:17:14.492 --> 31:17:14.872
太好了。

22998
31:17:14.872 --> 31:17:15.951
我们来看看醚。

22999
31:17:15.951 --> 31:17:17.347
我们忽略它。

23000
31:17:18.112 --> 31:17:19.112
我们有合同。

23001
31:17:21.112 --> 31:17:24.040
有道理的拼写对吗?与原因。

23002
31:17:25.112 --> 31:17:26.381
提案ID那样。

23003
31:17:29.112 --> 31:17:31.445
讲道理，我们来讲个道理。

23004
31:17:33.112 --> 31:17:40.732
我喜欢做恰恰，如果你知道这部电影，你一定要在描述中评论它。

23005
31:17:40.732 --> 31:17:47.210
我们投票是有原因的我们说我们想我们确实想让你们把方框改成77。

23006
31:17:47.210 --> 31:17:55.724
原因是，我喜欢做Cha Cha，如果你不去想，它很有意义，然后我们会做一个等待，Kotex响应那个等待。

23007
31:17:55.724 --> 31:18:02.969
所以我做了一些事情，再次检查提案的状态，不同的数字意味着，嘿，它在进行中，它在投票，等等，我们可以检查这些。

23008
31:18:02.969 --> 31:18:04.048
但我们现在先跳过这个。

23009
31:18:04.112 --> 31:18:07.645
我们现在要做的就是，既然我们已经投票了，我们就是投票的人。

23010
31:18:07.645 --> 31:18:09.925
所以我们要再一次移动方块。

23011
31:18:09.925 --> 31:18:14.059
为什么呢?因为我们想马上结束投票期。

23012
31:18:14.059 --> 31:18:18.770
我们会再做一次，如果veldevelopmentchains，它包括network。

23013
31:18:18.770 --> 31:18:23.818
name，然后我们会做一个权重move blocks, voting period，加1。

23014
31:18:23.818 --> 31:18:26.902
我们需要在这里导入一大堆东西。

23015
31:18:26.902 --> 31:18:32.269
姿势文件开发，看起来那些被自动导入了，我们需要导入这个移动块。

23016
31:18:32.269 --> 31:18:38.262
因此，import move blocks from utils blocks，网络在这里。

23017
31:18:38.262 --> 31:18:41.056
然后我们需要helper配置中的投票周期。

23018
31:18:41.056 --> 31:18:41.833
投票时间。

23019
31:18:41.833 --> 31:18:42.444
好的,很酷。

23020
31:18:42.444 --> 31:18:47.173
然后我们写console。log，投票，准备好了。

23021
31:18:47.173 --> 31:18:54.053
我检查提案状态的原因是在州长契约中有这个状态函数。

23022
31:18:54.053 --> 31:18:59.461
如果我们查看状态，它会告诉我们提案的状态如果它被执

23023
31:18:59.461 --> 31:19:04.870
行了，返回被执行了，如果它被取消了，返回被取消了。

23024
31:19:04.870 --> 31:19:12.052
你有截止日期，检查它是否有效，检查法定人数是否达到了所有这些，对吧?你通常寻找的是蠕虫到达和投票

23025
31:19:12.052 --> 31:19:19.235
成功，对吧?如果这两件事都发生了，交通部的提案成功了，对吧?否则，它就被打败了，或者还没到那里。

23026
31:19:19.235 --> 31:19:21.273
我相信这是1，这是0。

23027
31:19:21.273 --> 31:19:26.174
所以如果你调用这个函数并得到正确的状态，现在我们应该得到0。

23028
31:19:26.174 --> 31:19:28.489
不好意思，我们应该为过去的这段时间拿一个。

23029
31:19:28.489 --> 31:19:31.445
如果你想做这个作为额外的学分，请随意做。

23030
31:19:31.445 --> 31:19:32.839
看看我们做得对不对。

23031
31:19:32.839 --> 31:19:35.254
事实上，我想我们得改一下，就为了投票。

23032
31:19:35.254 --> 31:19:37.342
但我刚刚把所有东西都打包成main了。

23033
31:19:37.342 --> 31:19:38.899
我们来看看这是否可行。

23034
31:19:38.899 --> 31:19:42.281
纱线，硬帽运行脚本投票网络，本地主机。

23035
31:19:42.281 --> 31:19:47.849
我们应该在底部得到一个小小的console。log说，投票准备好了。

23036
31:19:47.849 --> 31:19:48.898
现在我们开始投票。

23037
31:19:48.898 --> 31:19:56.032
我们不只是去北极理事会，我们可以做纱线，硬帽主机，破折号网络，本地主机。

23038
31:19:56.112 --> 31:19:58.387
在这里，你可以在这里检查状态。

23039
31:19:58.387 --> 31:20:04.578
为什么不呢?我们将复制这一行作为总督因为我们要么得到总督契约。

23040
31:20:04.578 --> 31:20:09.329
现在我们可以做一个等待，总督，这是去提案。

23041
31:20:09.329 --> 31:20:13.629
JSON的状态，抓取这个，粘贴到这里。

23042
31:20:13.629 --> 31:20:18.064
现在的状态是，我忘了4是什么意思了。

23043
31:20:18.064 --> 31:20:19.362
就像求婚的状态。

23044
31:20:19.362 --> 31:20:24.953
提案状态实际上在眼调控器中，因此调控器的接口我们可以看到，0

23045
31:20:24.953 --> 31:20:30.732
个是未决的，1个是活动的，2个取消了，3个失败了，4个成功了。

23046
31:20:30.732 --> 31:20:34.243
所以我们处于成功的状态，这非常好。

23047
31:20:34.243 --> 31:20:35.161
这正是我们想要的。

23048
31:20:35.161 --> 31:20:36.370
我们现在就退出吧。

23049
31:20:36.370 --> 31:20:37.663
抱歉，Ctrl键。

23050
31:20:37.663 --> 31:20:41.366
C，我们的建议现在处于成功的状态。

23051
31:20:41.366 --> 31:20:44.402
我们实际上已经移动了投票期间的区块。

23052
31:20:44.402 --> 31:20:46.385
投票结束了，因为我们作弊了。

23053
31:20:46.385 --> 31:20:51.778
现在我们来排队并执行到最后一位。

23054
31:20:51.778 --> 31:20:53.095
这看起来和我们已经做过的很像。

23055
31:20:53.112 --> 31:20:59.705
对吧?让我们最小化它，导出async，函数，Q和执行。

23056
31:20:59.705 --> 31:21:04.456
然后在底部，我们会调用queue并执行。

23057
31:21:04.456 --> 31:21:10.722
复制粘贴，语法是一样的，然后process exec catch，等等等等，你就得到了练习。

23058
31:21:10.722 --> 31:21:16.518
为了排队和执行，回到调控器契约，而不是调控器，让我们回到调控器。

23059
31:21:16.518 --> 31:21:19.009
首先我们要做的是调用这个队列。

23060
31:21:19.112 --> 31:21:25.412
现在这个Q函数实际上在调控器时间锁中，在这个扩展中。

23061
31:21:25.412 --> 31:21:30.189
我们能在这里找到调控器Time Lock控制器，它做的

23062
31:21:30.189 --> 31:21:35.144
和建议完全一样我们取建议中做的所有东西，然后像这样排队。

23063
31:21:35.144 --> 31:21:37.012
我们在这里传递完全相同的值。

23064
31:21:37.112 --> 31:21:38.012
太可爱了。

23065
31:21:40.112 --> 31:21:43.563
首先需要得到完全相同的值，我告诉过你们，我们会用到几次。

23066
31:21:43.563 --> 31:21:51.454
我们要导入，新存储值，文章的建议描述，现在我们有了这些东西，我们会说const args

23067
31:21:51.454 --> 31:21:58.807
=一个新的存储值，我们会说const box = await ethers。get

23068
31:21:58.807 --> 31:22:07.596
contract，我们再次得到那个box contract，我们需要从hat导入ethers。

23069
31:22:07.596 --> 31:22:10.750
这将来自我们将做TS忽略，

23070
31:22:10.750 --> 31:22:21.912
然后我们再次将这个函数调用编码为const编码的函数调用等于Boxtop接口，编码函数数据。

23071
31:22:21.912 --> 31:22:29.375
再说一次，funk是我们要调用的函数和args这就像real和我们建议的位一样。

23072
31:22:29.375 --> 31:22:36.642
然后我们会做内容描述哈希= ethers。utils得到GAC 256

23073
31:22:36.642 --> 31:22:44.326
ethers。utils，这对你们来说是TF 8字节，这马上就说得通了。

23074
31:22:44.326 --> 31:22:45.968
我们也是描述性的。

23075
31:22:45.968 --> 31:22:53.865
我们的提案，我们所做的只是传递提案描述，然而，它实际上是在chain上哈希的，这就是我

23076
31:22:53.865 --> 31:23:01.762
们的视图和执行要找的，它会找描述哈希，而不仅仅是单纯的描述，这样会更节省时间，这很好。

23077
31:23:01.762 --> 31:23:08.695
现在我们有了描述哈希，现在我们有了所有相同的函数假设是时候对它们进行排队了。

23078
31:23:08.695 --> 31:23:13.061
所以做成本政府等于等待醚点得到合同。

23079
31:23:13.061 --> 31:23:17.920
政府合约，console。log会说我们正在

23080
31:23:17.920 --> 31:23:23.000
排队然后我们会写cos Q dx等于政府。Q。

23081
31:23:23.112 --> 31:23:28.839
我们会传递和姿势一样的参数除了哈希值而不是实际的

23082
31:23:28.839 --> 31:23:34.805
提议，所以把地址设为0，然后在函数调用时传递代码。

23083
31:23:34.805 --> 31:23:37.627
然后是描述哈希率。

23084
31:23:37.627 --> 31:23:41.789
然后我们要做，哦，是这里的一个权重。

23085
31:23:41.789 --> 31:23:43.737
然后我们要等待。

23086
31:23:43.737 --> 31:23:46.424
你发短信哦，等一下，等一个街区。

23087
31:23:46.424 --> 31:23:48.674
太好了，我们都排好队了。

23088
31:23:48.674 --> 31:23:54.332
现在我们还得等待最小延迟，对吧?记住，在时间轴上，它有最小延迟。

23089
31:23:54.332 --> 31:23:58.543
它说，嘿，一旦有东西排队了，你不能马上执行它。

23090
31:23:58.543 --> 31:24:00.462
你得给人们时间离开。

23091
31:24:00.462 --> 31:24:05.862
所以我们会再次加快时间，我们会说，如果开发链发

23092
31:24:05.862 --> 31:24:11.497
展，我指的是链，然后它看起来像自动导入的开发链。

23093
31:24:11.497 --> 31:24:12.339
是的，确实如此。

23094
31:24:12.339 --> 31:24:12.900
很神奇的。

23095
31:24:13.112 --> 31:24:14.563
这包括network。name。

23096
31:24:16.112 --> 31:24:17.639
网络从Hardhead。

23097
31:24:20.112 --> 31:24:21.933
当然，我们要移动街区。

23098
31:24:23.112 --> 31:24:26.849
必须把时间移到这里，因为最小延迟需要一段时间。

23099
31:24:26.849 --> 31:24:30.455
让我们创建一个名为Move time的新util。

23100
31:24:30.455 --> 31:24:32.690
好的，移动时间是的。

23101
31:24:32.690 --> 31:24:37.558
这个util将允许我们移动时间，所以你可以学到所有很酷的东西。

23102
31:24:37.558 --> 31:24:44.683
我们很快就会写一个脚本来完成这个重要的网络从硬帽导出异步函数移动时间，

23103
31:24:44.683 --> 31:24:50.993
移动时间是多少是Mount console。log，移动时间，

23104
31:24:50.993 --> 31:24:58.932
然后是await network。provider。send EVM增加时间然

23105
31:24:58.932 --> 31:25:06.466
加时间然后是数量，然后是console。log，向前移动，数量秒，它向前移动和秒。

23106
31:25:06.466 --> 31:25:06.788
酷。

23107
31:25:06.788 --> 31:25:08.891
现在我们有了这个移动时间函数。

23108
31:25:08.891 --> 31:25:15.773
挺快的，对吧?首先，我们要移动时间我们要先移动那个最小延时，为了安全起见，加1。

23109
31:25:15.773 --> 31:25:17.293
然后我们也要移动方块。

23110
31:25:17.293 --> 31:25:20.735
我们要做一个重量移动时间，然后一个重量移动块。

23111
31:25:20.735 --> 31:25:22.768
我们就按街区移动。

23112
31:25:22.768 --> 31:25:26.046
从utils导入move blocks。

23113
31:25:26.046 --> 31:25:30.561
它也从这些工具中导入移动时间，时间。

23114
31:25:30.561 --> 31:25:35.063
然后我们还需要导入这个最小延迟，这是我们从辅助函数得到的。

23115
31:25:35.113 --> 31:25:35.850
傻瓜配置。

23116
31:25:35.850 --> 31:25:36.145
太好了。

23117
31:25:36.145 --> 31:25:37.472
所以我们把所有的东西都搬走了。

23118
31:25:38.113 --> 31:25:40.290
这是真正的连锁店，你只需要等待。

23119
31:25:41.113 --> 31:25:42.713
不是真正的链条，我们想怎么做就怎么做。

23120
31:25:43.113 --> 31:25:44.163
做我想做的事。

23121
31:25:46.113 --> 31:25:48.768
过了，我们看起来很辣。

23122
31:25:48.768 --> 31:25:50.931
让我们把它开回家。

23123
31:25:52.113 --> 31:25:57.926
执行const execute TX = await。

23124
31:25:57.926 --> 31:25:59.010
政府执行。

23125
31:25:59.010 --> 31:26:05.838
我们要传递这个和我们对qtx做的一样的东西所以我要复制这个。

23126
31:26:05.838 --> 31:26:06.757
把它贴在这里。

23127
31:26:06.757 --> 31:26:10.573
然后我们要做一个权重sqtx。权重。

23128
31:26:10.573 --> 31:26:12.953
我们要等一个街区。

23129
31:26:13.113 --> 31:26:17.937
最后一小时，我们将看看治理是否更新了我们的box contract

23130
31:26:17.937 --> 31:26:24.078
const box new value = await box。retrieve。

23131
31:26:24.078 --> 31:26:28.060
它会做console。log。

23132
31:26:28.060 --> 31:26:29.749
新框值。

23133
31:26:30.113 --> 31:26:31.178
框新值。

23134
31:26:35.113 --> 31:26:36.573
要更新的框值。

23135
31:26:39.113 --> 31:26:43.713
帽子运行握Q和执行现在工作localhost。

23136
31:26:45.113 --> 31:26:49.019
对吧?我们成功地完成了治理吗?我们所做的。

23137
31:26:50.113 --> 31:26:51.446
我们会查出我们做错了什么。

23138
31:26:52.113 --> 31:26:54.899
我拼错了几个字。

23139
31:26:57.113 --> 31:26:57.435
没有CK。

23140
31:26:57.435 --> 31:26:58.209
只要k。

23141
31:26:58.209 --> 31:26:59.628
好吧，我们再试一次。

23142
31:27:01.113 --> 31:27:01.779
实际上做的。

23143
31:27:01.779 --> 31:27:02.890
我认为这很好。

23144
31:27:04.113 --> 31:27:07.774
提供EVM和crit，因为我拼写错误。

23145
31:27:08.113 --> 31:27:13.238
没有EVM增加时间，只是再次检查。

23146
31:27:15.113 --> 31:27:17.349
拼写正确，T是大写的。

23147
31:27:18.113 --> 31:27:18.578
搞砸了。

23148
31:27:18.578 --> 31:27:20.491
它实际上已经排队了。

23149
31:27:21.113 --> 31:27:24.653
现在在我们的小节点EVM增加团队排队。

23150
31:27:25.113 --> 31:27:32.563
可以删除并重新启动，或者我可以继续我将注释掉一些东西，我们将跳过这里的提示。

23151
31:27:32.563 --> 31:27:36.045
我们要再运行一遍，因为它已经排队了。

23152
31:27:36.045 --> 31:27:38.883
现在应该执行，我们将再次移动时间。

23153
31:27:38.883 --> 31:27:39.669
不过没关系。

23154
31:27:39.669 --> 31:27:41.003
天啊，我们成功了。

23155
31:27:41.003 --> 31:27:41.284
正确的。

23156
31:27:41.284 --> 31:27:43.940
通常情况下，你只需要在一个脚本中完成。

23157
31:27:43.940 --> 31:27:46.790
但是这个队列会失败，因为它已经排队了。

23158
31:27:46.790 --> 31:27:48.870
好吧，你不能排两次队，往前走。

23159
31:27:48.870 --> 31:27:55.836
随着时间的推移，我们移动了我们执行的区块我们得到了一个新的盒子

23160
31:27:55.836 --> 31:28:03.028
值完全使用我们的道指完全去中心化投票完全在链上，没有第三方信任。

23161
31:28:03.113 --> 31:28:11.028
这里没有投票站，也没有你知道的，在员工身上花费1000美元，我们刚刚投票的所有事情都发生在我们面前。

23162
31:28:11.028 --> 31:28:16.064
再一次，我强烈推荐大家去我的GitHub回购，你们可以看看这里发生了什么。

23163
31:28:16.113 --> 31:28:19.313
同样，如果您想了解JavaScript的内容，请随意做一些JavaScript的内容。

23164
31:28:19.313 --> 31:28:23.713
这节课讲的是如何开始克隆如果你想这么做的话。

23165
31:28:23.713 --> 31:28:32.138
但如果你和我一起走过这段路，如果你和我一起走过这段路，你就会学到绝对的可汗，非常感谢你来到这里。

23166
31:28:32.138 --> 31:28:34.907
我们下期见。

23167
31:28:35.113 --> 31:28:35.827
好吧。

23168
31:28:40.113 --> 31:28:46.473
安全和审计部分，这部分的编码会少一点，解释会多一点。

23169
31:28:46.473 --> 31:28:50.382
我们要学习的大部分内容都是在这个硬头安全FCC部分。

23170
31:28:50.382 --> 31:28:56.481
在本课程中，我们给了您一些关于不同安全特性的提示。

23171
31:28:56.481 --> 31:29:02.440
第一，我们讲了可重入性，我们讲了一点甲骨文税，我们还会继续讲。

23172
31:29:02.440 --> 31:29:09.867
还有一些工具可以让我们的代码更高效，找出错误，让我们的代码更安全。

23173
31:29:09.867 --> 31:29:17.387
我们将继续，我们将过一遍这个硬帽安全FCC代码库，我们将稍微过一遍。

23174
31:29:17.387 --> 31:29:22.234
我们首先要讲的是，什么是审计?审计将是一个

23175
31:29:22.234 --> 31:29:27.313
以安全为重点的代码审查，寻找您的代码的问题。

23176
31:29:27.313 --> 31:29:35.856
举个例子，假设我们有一些这样的代码，这应该有点熟悉，因为我们在之前的可重入部分讨论过

23177
31:29:35.856 --> 31:29:44.604
这个，我们的代码，提取，去发送以太币，然后更新余额，这段代码显然很容易受到可重入攻击。

23178
31:29:44.604 --> 31:29:47.294
这是审计员会发现的。

23179
31:29:47.294 --> 31:29:49.435
因为当我们部署代码时，代码是不可变的。

23180
31:29:49.435 --> 31:29:55.376
这些代码会一直在那里，在我们将代码部署到主网之前，在我们上线之前，进行这

23181
31:29:55.376 --> 31:30:01.317
些安全审查是非常重要的，所以如果你要部署一些疯狂的，大规模的对抗协议，你

23182
31:30:01.317 --> 31:30:07.589
将有数十亿美元的人们的钱锁定在你的协议中，你可能要确保这些钱去了正确的地方。

23183
31:30:07.589 --> 31:30:12.684
所以审计对于我们项目的生命周期是非常重要的。

23184
31:30:12.684 --> 31:30:18.738
我们希望人们进行同行评审，我们希望人们评审我们的代码，以确保一切看起来都很好。

23185
31:30:18.738 --> 31:30:23.096
现在，当我们将代码发送给审计时，我们不应该只是说，嘿，这是我们的代码。

23186
31:30:23.096 --> 31:30:25.014
你能检查一下吗确保它是好的。

23187
31:30:25.113 --> 31:30:32.892
这不会给审计员足够的信息，他们需要能够非常容易地知道你的代码是做什么的，如何使用它，以及你在寻找什么。

23188
31:30:32.892 --> 31:30:38.621
因为审计员不会是那种，这种故障保险，如果你的代码很糟糕，他们就会抓住一切。

23189
31:30:38.621 --> 31:30:40.096
审核员也是人。

23190
31:30:40.096 --> 31:30:42.014
审计员也会漏掉一些东西。

23191
31:30:42.113 --> 31:30:44.435
另外，不要确保你的代码没有bug。

23192
31:30:45.113 --> 31:30:48.795
审计是针对代码库的以安全性为重点的同行评审。

23193
31:30:49.113 --> 31:30:54.822
当您将代码发送给审核时，您希望确保尽可能多地帮助审核人员。

23194
31:30:54.822 --> 31:31:01.685
有一个惊人的推文线程来自Tinto，之前是Zeplin开放审查员，有大量的提示和技巧

23195
31:31:01.685 --> 31:31:08.713
与审查员合作，我强烈建议你暂停视频，你点击这个链接，你阅读他的推文，因为他们是神奇的。

23196
31:31:08.713 --> 31:31:16.285
Openzeppelin有一个准备指南，试图帮助您确保您已经为审计做好了准备。

23197
31:31:16.285 --> 31:31:19.227
我们在GitHub存储库中有一个准备指南的链接。

23198
31:31:19.227 --> 31:31:26.909
它们的总结是向代码中添加注释，使用natspec(我们学习过它来记录函数，

23199
31:31:26.909 --> 31:31:34.800
记录函数，记录函数)，测试，准备好与审计人员交谈，并准备好给他们充足的时间。

23200
31:31:34.800 --> 31:31:40.129
他们实际上是在你的代码上倾注了数周的时间，以确保没有任何错误。

23201
31:31:40.129 --> 31:31:44.629
如果你催促审计员，你就会得到一个匆忙的审计，他们就会错过一些东西。

23202
31:31:44.629 --> 31:31:46.566
让我们来谈谈审计过程。

23203
31:31:46.566 --> 31:31:48.790
在审计过程中是这样的。

23204
31:31:48.790 --> 31:31:50.677
首先，他们会给你做检查。

23205
31:31:50.677 --> 31:31:58.252
这是order总是要做的第一步在这里，他们会发现他们有足够的代码覆盖率吗?一切都过去了吗?

23206
31:31:58.252 --> 31:32:05.827
这些测试是做什么的?最优的功能是什么?在审核人员运行测试后，他们会阅读规范或运行你的文档。

23207
31:32:05.827 --> 31:32:11.371
然后他们会运行一些快速的工具，像Slither, linters和静态分析。

23208
31:32:11.371 --> 31:32:16.354
这将是我们将要讨论的关于滑动和静态分析的首要内容之一。

23209
31:32:16.354 --> 31:32:24.541
因此，静态分析就是运行一些程序来阅读所有代码并查找常见错误的过程。

23210
31:32:24.541 --> 31:32:28.790
最流行的静态分析工具之一是这个叫做Slither的工具。

23211
31:32:28.790 --> 31:32:32.128
这是我们要做的第一件事。

23212
31:32:32.128 --> 31:32:34.289
现在让我们打开VS代码。

23213
31:32:34.289 --> 31:32:38.738
我们将创建一个新的目录，叫做hardhats security, FCC。

23214
31:32:38.738 --> 31:32:40.863
我们会做的。

23215
31:32:40.863 --> 31:32:43.488
我们会讲代码期。

23216
31:32:43.488 --> 31:32:45.887
我们把它打开。

23217
31:32:45.887 --> 31:32:52.859
现在我想让你们做的是，不要新建一个文件夹，所有的东西都要克隆，我的心有安全FCC。

23218
31:32:52.859 --> 31:33:00.051
我们用gitclone，我们的net security FCC空间，然后加一个句点将它克隆到这个目录。

23219
31:33:00.113 --> 31:33:02.418
我们会得到像这样的东西。

23220
31:33:04.113 --> 31:33:11.401
我们已经有了几个不同的合同，每个合同都有不同的漏洞，其中一个将是糟糕的RNG。

23221
31:33:11.401 --> 31:33:18.488
这是一个使用块难度和消息点发送者从抽奖中随机挑选赢家的契约。

23222
31:33:18.488 --> 31:33:24.867
这并不是真正的随机，因为矿工可以影响块点难度，人们可以取消交易。

23223
31:33:24.867 --> 31:33:30.020
用这种方式创造随机性有许许多多不同的弱点。

23224
31:33:30.020 --> 31:33:35.629
我们也有这个液体池作为Oracle，两种最常见的攻击类型是可重入性，

23225
31:33:35.629 --> 31:33:44.703
我们已经学习过Oracle操作攻击，幸运的是，我们已经教过分散的Oracle和使用链链接，这应该会使您更安全。

23226
31:33:44.703 --> 31:33:50.658
尤其在这一部分，我要反复强调这些，请，请，请，如果你们上这门

23227
31:33:50.658 --> 31:33:56.613
课，请不要制定一个受这些影响的协议，我会觉得我让你们失望了。

23228
31:33:56.613 --> 31:34:03.389
如果你构建的协议中使用了一些被操纵的集中oracle，或者你构建的协议中存在重入攻击。

23229
31:34:03.389 --> 31:34:07.359
我要给你们展示的工具将会帮助你们实现可重入性。

23230
31:34:07.359 --> 31:34:12.822
我讲的链条应该能教会你们如何不被甲骨文操纵。

23231
31:34:12.822 --> 31:34:19.384
在这个合同中，我们使用流动性池作为Oracle这是一种高级的挑战。

23232
31:34:19.384 --> 31:34:26.779
这是一个极简的去中心化交易的例子，在这里人们可以买卖和交换不同的资产。

23233
31:34:26.779 --> 31:34:32.366
用这个单一交换，得到掉期价格是个糟糕的主意。

23234
31:34:32.366 --> 31:34:35.731
因为这是一个价格单一的单一协议。

23235
31:34:35.731 --> 31:34:42.513
这个协议的价格是一个集中的位置，我们不希望从一个集中的交易所获得我们的价格。

23236
31:34:42.513 --> 31:34:44.413
我们想从许多交易所得到它。

23237
31:34:44.413 --> 31:34:50.956
从一个去中心化的交易所获得任何资产的价格不是去中心化的，而是

23238
31:34:50.956 --> 31:34:57.500
有人在操纵市场做一些疯狂的高级违抗会毁掉你的资产价格的事情。

23239
31:34:57.500 --> 31:35:02.854
因此，从一个集中的地方获取资产价格是一个糟糕的想法。

23240
31:35:02.854 --> 31:35:04.983
我们这里有一个变质的代理人。

23241
31:35:05.113 --> 31:35:10.553
这里的问题是它是双初始化的，我们不能保证契约已经初始化了。

23242
31:35:10.553 --> 31:35:13.079
这里有一个经典的重入问题。

23243
31:35:13.079 --> 31:35:17.708
然后我们有然后我们有一个保险库在那里用链子存

23244
31:35:17.708 --> 31:35:22.548
储着一些密码我们祈祷没有人读这个密码来解锁它。

23245
31:35:22.548 --> 31:35:27.251
我们将对这些契约进行静态分析，看看静

23246
31:35:27.251 --> 31:35:31.955
态分析是否能发现其中的一些不好之处。

23247
31:35:32.113 --> 31:35:41.065
首先，我们将使用一种工具，就像我说的，叫做slither slither工具是由Crytek团队，也就是三叶虫团队发明的。

23248
31:35:41.065 --> 31:35:45.199
三叶虫绝对是我最喜欢的审计师之一。

23249
31:35:45.199 --> 31:35:51.822
我非常喜欢这个团队推出的所有工具，他们为我们提供了开源的安全工具，比如分割器。

23250
31:35:51.822 --> 31:35:56.596
现在要开始使用Slither，我们实际上需要首先安装Python。

23251
31:35:56.596 --> 31:35:58.774
你也可以用Docker运行它。

23252
31:35:58.774 --> 31:36:02.284
但我将首先向您展示如何使用Python。

23253
31:36:02.284 --> 31:36:05.988
如果你之前没有使用过Python，你可以来学习Python。

23254
31:36:05.988 --> 31:36:09.629
org/downloads和从网站下载Python，你就会知道你做对了。

23255
31:36:09.629 --> 31:36:13.313
你可以运行python的三个破折号版本，像这样。

23256
31:36:13.313 --> 31:36:17.293
或者如果你有一个较老版本的Python，你可以运行Python的破折号版本。

23257
31:36:17.293 --> 31:36:22.489
安装Python之后，还应该安装这个名为PIP 3的工具，可

23258
31:36:22.489 --> 31:36:27.686
以通过运行PIP 3的破折号版本或PIP破折号版本进行检查。

23259
31:36:27.686 --> 31:36:35.065
我们还需要安装这个sock select包以防我们使用奇怪的solidity版本来安装。

23260
31:36:35.113 --> 31:36:40.029
我们运行PIP 3，安装sock select，像这样。

23261
31:36:40.113 --> 31:36:42.925
然后我们可以做袜子，选择，使用。

23262
31:36:45.113 --> 31:36:48.078
结实度或滑动度的版本。

23263
31:36:49.113 --> 31:36:53.145
那些工具，你可以像这样运行PIP 3安装slither分析器。

23264
31:36:53.145 --> 31:36:56.467
你可以将slither安装到你的Python环境中。

23265
31:36:56.467 --> 31:36:57.918
我不打算播了，因为已经播过了。

23266
31:36:57.918 --> 31:37:03.145
你也可以学习如何用Docker来做这些我们稍后会学习如何用Docker来做这些。

23267
31:37:03.145 --> 31:37:07.467
在我们的包json中，我们在包中有命令脚本。

23268
31:37:07.467 --> 31:37:12.218
JSON来运行Slither，你就会知道你已经正确安装了Slither。

23269
31:37:12.218 --> 31:37:19.063
如果你能运行Slither，破折号可以帮助你得到这样的输出。

23270
31:37:19.063 --> 31:37:24.224
现在我们可以使用slither在合约文件夹上运行通过运行这个大命令。

23271
31:37:24.224 --> 31:37:25.564
我们用Slither。

23272
31:37:25.564 --> 31:37:32.732
我们想在。/契约上运行它，我们需要告诉它它有一些诗篇映射，每次它看到打开的Zeppelin，它应该使用Node

23273
31:37:32.732 --> 31:37:40.293
module / open Zeppelin每次它看到引入的chain link节点模块/ chain link。

23274
31:37:40.293 --> 31:37:42.985
我将从我们的包json中读取。

23275
31:37:42.985 --> 31:37:49.768
我们排除了一些它运行的函数排除了建设者忽略的函数，但不用太担心。

23276
31:37:49.768 --> 31:37:56.042
我们实际上只是通过首先运

23277
31:37:56.042 --> 31:38:02.840
行纱线来安装我们所有的包。

23278
31:38:03.113 --> 31:38:06.451
在我们安装好所有的包之后，我们就可以运行yarn Slither了。

23279
31:38:06.451 --> 31:38:09.790
或者您可以复制粘贴slither命令并直接运行它。

23280
31:38:09.790 --> 31:38:15.819
现在我们会得到这个大量的输出，看起来像这样，有些红，有些绿。

23281
31:38:15.819 --> 31:38:24.282
让我们来看看这里到底发生了什么，我们阅读Slither的方式，它会列出一些有问题的行，然后是对该问题的引用。

23282
31:38:24.282 --> 31:38:27.253
每一个都用一条新线隔开。

23283
31:38:27.253 --> 31:38:30.937
这是一个例外的部分，等等。

23284
31:38:31.113 --> 31:38:37.231
因此，如果我们在这里得到一个红色，这意味着有一个高影响的问题，我们一定要解决。

23285
31:38:37.231 --> 31:38:43.152
它甚至还附带了一个参考链接，我们可以复制粘贴到浏览器中，看

23286
31:38:43.152 --> 31:38:49.279
看是什么问题，还有滑动工具中关于问题的更多信息以及如何改正。

23287
31:38:49.279 --> 31:38:53.695
我们可以看到它抓住了我们变形契约的问题。

23288
31:38:53.695 --> 31:38:56.492
它表示变形契约从未初始化。

23289
31:38:56.492 --> 31:38:59.149
这是用在这里的变形网点扼杀。

23290
31:38:59.149 --> 31:39:06.223
这是一个大问题的原因，如果我们去我们的变形合同外底，如果我们部署这个合同，

23291
31:39:06.223 --> 31:39:13.490
其他人可能会初始化这个代码，成为所有者，然后在我们甚至有机会之前自动杀死它。

23292
31:39:13.490 --> 31:39:18.497
这实际上是过去发生过的事情，导致了大量的问题。

23293
31:39:18.497 --> 31:39:23.588
所以如果我们在终点站看到红色，这意味着嘿，大问题，我们绝对应该去看看。

23294
31:39:23.588 --> 31:39:25.809
现在这里将会有大量的绿色。

23295
31:39:25.809 --> 31:39:30.350
这些探测器可能是低冲击的，它们可能没问题。

23296
31:39:30.350 --> 31:39:36.959
事实上，我们可以看到，它甚至只是在这里调用一些打开，说，嘿，我们看到一些内联汇编。

23297
31:39:36.959 --> 31:39:39.806
内联汇编有点可怕，也许不要用它。

23298
31:39:39.806 --> 31:39:48.209
所以你可以把绿色看作是一种警告这对任何东西产生影响的可能性很低，但你可能想要检查一下，我们使用了不

23299
31:39:48.209 --> 31:39:56.613
同版本的固体，也就是说，嘿，有几个不同版本的固体可能是你需要记住的，也许你应该使用相同版本的固体。

23300
31:39:56.613 --> 31:39:58.398
我们允许旧版本。

23301
31:39:58.398 --> 31:40:03.096
这就是为什么在这门课中，我们一直用8。

23302
31:40:03.096 --> 31:40:04.870
因为0,8。

23303
31:40:04.870 --> 31:40:06.001
4和零点8。

23304
31:40:06.001 --> 31:40:08.834
7被认为是更稳定的固体版本。

23305
31:40:08.834 --> 31:40:14.557
如果你在外面使用版本，这里会说，嘿，也许你想使用不同的版本。

23306
31:40:14.557 --> 31:40:21.066
这里有一些标记，比如，你应该把变量设为常量因为它永远不会变，这很好。

23307
31:40:21.113 --> 31:40:28.246
使用有太多数字的文字，说，嘿，这个有点难读，也许你搞砸了一些0，响亮的旧版本。

23308
31:40:28.246 --> 31:40:32.050
ether store。withdraw的可重入性是什么。

23309
31:40:32.050 --> 31:40:39.703
所以只要运行这个滑动工具，我们就能在合同中发现一个可重入性漏洞，这太棒了。

23310
31:40:39.703 --> 31:40:46.313
所以运行静态分析至少发现了变形契约中的两个巨大漏洞。

23311
31:40:46.313 --> 31:40:53.967
在我们的可重入契约中，它没有捕捉到单一流动性池中涉及的问题，或者糟糕的RNG，这就是为

23312
31:40:53.967 --> 31:41:01.800
什么我们不想只依赖slither因为它不会捕捉到所有的问题，但它会捕捉到很多主要的漏洞。

23313
31:41:01.800 --> 31:41:06.413
这就是我们如何使用Slither，至少从中间堆栈点开始。

23314
31:41:06.413 --> 31:41:08.909
太好了，我们刚学会如何和斯利瑟合作。

23315
31:41:08.909 --> 31:41:12.779
这是我们审计过程中最重要的工具之一。

23316
31:41:12.779 --> 31:41:18.520
这将被认为是静态分析的快速工具，运行测试，

23317
31:41:18.520 --> 31:41:23.988
linters等等，也是静态分析的类型。

23318
31:41:24.113 --> 31:41:31.255
在我们运行一个这样的工具后，我们进入一些手动分析，我们自己手动遍历代码，也许我们

23319
31:41:31.255 --> 31:41:38.398
会运行一些较慢的工具，比如kitna Manta Corp，和其他符号执行工具。

23320
31:41:38.398 --> 31:41:43.630
符号执行是模拟在区块链上执行事务的地方。

23321
31:41:43.630 --> 31:41:48.269
我们将要使用的其中一个符号执行工具是这个kidmin工具。

23322
31:41:48.269 --> 31:41:52.062
再说一次，这是一个用于做模糊测试的工具。

23323
31:41:52.113 --> 31:41:57.376
在编程中，模糊测试是一种自动化软件测试技术，它涉及

23324
31:41:57.376 --> 31:42:02.851
提供无效的、意外的或随机的数据作为计算机程序的输入。

23325
31:42:02.851 --> 31:42:10.048
在我们的很多代码中，我们经常会让人们以我们从未想过的方式与它们进行交互。

23326
31:42:10.114 --> 31:42:17.469
所以我们希望能够为我们的测试提供随机数据和随机信息，看看是否发生了我们没有预料到的奇怪的事情。

23327
31:42:17.469 --> 31:42:24.541
所以我们实际上可以在我们的硬帽项目中建立我们自己的模糊测试并运行这些模糊测试，我实际上创

23328
31:42:24.541 --> 31:42:31.614
建了一个模糊测试的示例，我们用固体写我们的模糊测试，而不是用JavaScript写测试。

23329
31:42:31.614 --> 31:42:34.621
举个例子，我们建立了一个保险库合同。

23330
31:42:34.621 --> 31:42:43.180
我们认为，乍一看，没有人能够知道密码，也没有人能够解锁这份合同。

23331
31:42:43.180 --> 31:42:48.941
显然，我们知道这很荒谬，因为我们知道任何人都可以读取存储变量中的任何东西。

23332
31:42:48.941 --> 31:42:52.614
所以我们知道这应该失败，但是编写一个测试可能很难。

23333
31:42:52.614 --> 31:42:54.780
来发现这实际上会失败。

23334
31:42:54.780 --> 31:43:03.458
测试这个的一个好方法是向这个解锁函数发送大量随机字节32对象，看看我们是否可以解锁它。

23335
31:43:03.458 --> 31:43:06.002
我们可以写一个模糊测试来做到这一点。

23336
31:43:06.002 --> 31:43:10.574
所以在我的保险库，绒毛测试。索尔，我们要进口保险库的外底。

23337
31:43:10.574 --> 31:43:17.304
我们说保险库模糊测试是保险库密码是123 ASD 123。

23338
31:43:17.304 --> 31:43:23.388
现在我们有一个叫kid和test find password的函数，

23339
31:43:23.388 --> 31:43:29.294
它会向保险库发送大量随机数据试图使s locked等于false。

23340
31:43:29.294 --> 31:43:34.872
我们在这里说s locked = true，我们的第一个测试将尝试使s locked = false。

23341
31:43:34.872 --> 31:43:43.310
现在我们可以只安装kitna，但在这一点上，从trail of bits调出我们的安全工具箱是一个好主意。

23342
31:43:43.310 --> 31:43:50.680
踪迹比特有一个叫做eath安全工具箱的包，它把所有的安全工具都放在一个容器里kitna, Ethan o

23343
31:43:50.680 --> 31:43:58.050
Manta core, slither, rattle，还有不那么智能合约，所有这些都放在同一个包里。

23344
31:43:58.114 --> 31:43:59.725
现在来使用这个工具箱。

23345
31:44:01.114 --> 31:44:01.399
安装。

23346
31:44:03.114 --> 31:44:07.914
有时这可能是课程中最难的部分安装这些包。

23347
31:44:07.914 --> 31:44:10.447
我们留下了Doc的。docker的链接。

23348
31:44:10.447 --> 31:44:17.938
com，让Docker安装Docker，真正使用这些工具，你只需要点击其中一个适合你安装Docker

23349
31:44:17.938 --> 31:44:25.429
的，一旦我们安装了Docker，我们可以通过从Docker的GitHub中拉下它来运行E安全工具箱。

23350
31:44:25.429 --> 31:44:27.774
我们会用到一大堆Docker命令，

23351
31:44:27.774 --> 31:44:35.364
我在这里就不解释了因为这不是Docker课程，如果你想了解安全方面的东西，我绝对建议你在后面阅读所有这些命令。

23352
31:44:35.364 --> 31:44:38.535
我们会留下很多链接让你了解更多。

23353
31:44:38.535 --> 31:44:41.801
在JSON与这一课相关联的包中。

23354
31:44:41.801 --> 31:44:44.852
我们甚至可以在这里进行设置。

23355
31:44:44.852 --> 31:44:49.012
我们可以运行yarn toolbox，它会像这样运行Docker命令。

23356
31:44:49.012 --> 31:44:51.534
所以我要运行纱线工具箱。

23357
31:44:51.534 --> 31:44:59.780
如果你得到这样的东西说不能连接到Docker守护进程Docker守护进程在运行，因为我需要我的Docker守护进程在运行。

23358
31:44:59.780 --> 31:45:01.876
自从我安装了Docker桌面。

23359
31:45:01.876 --> 31:45:06.605
我需要有我的Docker引擎启动和运行，它实际上正在工作。

23360
31:45:06.605 --> 31:45:07.780
再来处理这个。

23361
31:45:07.780 --> 31:45:14.786
需要进行大量的Docker设置和配置，关于如何开始使用Docker，我将留下大量的说明。

23362
31:45:14.786 --> 31:45:16.286
一旦我们设置好Docker。

23363
31:45:16.286 --> 31:45:24.419
现在我们可以运行纱线工具箱，它将把我们插入一个新的外壳，以使用三叶虫自带的任何工具。

23364
31:45:24.419 --> 31:45:27.914
现在我们的保险库模糊测试也有一个配置。

23365
31:45:27.914 --> 31:45:32.419
这是亚莫的档案里面有我们实施绑架的所有理由。

23366
31:45:32.419 --> 31:45:37.637
它有一个测试限制，也就是有多少次不同的运行，我们应该做一个时间延迟，块延迟。

23367
31:45:37.637 --> 31:45:39.779
当然，这里还有一些重新映射。

23368
31:45:39.779 --> 31:45:46.395
这个较暗的shell已经安装了安全工具，比如Kidner测试。

23369
31:45:46.395 --> 31:45:54.969
所以我们要对SRC进行kinah测试斜杠合同斜杠测试斜杠模

23370
31:45:54.969 --> 31:46:03.543
糊斜杠故障模糊测试。Sol破折号合同将是保险库模糊测试，破

23371
31:46:03.543 --> 31:46:12.415
折号配置将是SRC斜杠合同斜杠测试斜杠嗡斜杠配置。Yamo。

23372
31:46:12.415 --> 31:46:20.724
我们继续，在这里按回车键，它会说，分析合约，它会给我们一个像这样的输出，它会给我们一个像这样的输出。

23373
31:46:20.724 --> 31:46:26.825
它说的是，它找到了一个用例，它可以使s locked = false。

23374
31:46:26.825 --> 31:46:29.717
用例是123 ASD 123。

23375
31:46:29.717 --> 31:46:36.133
几秒钟后，它就找到了解锁合同的密码。

23376
31:46:36.133 --> 31:46:41.511
这就是为什么运行一个模糊测试器可以如此强大，我们认为我们的合同

23377
31:46:41.511 --> 31:46:47.064
是安全的，但它立即找到了密码，这意味着任何人都可以立即找到密码。

23378
31:46:47.114 --> 31:46:50.163
这将是一个指标，表明我们正在做的不是一个好的设置。

23379
31:46:50.163 --> 31:46:52.130
按CTRL C退出。

23380
31:46:52.130 --> 31:46:55.562
为了结束Docker设置，我们写入exit。

23381
31:46:55.562 --> 31:47:00.962
现在，我将在与这节课相关的GitHub回购中留下大量与绑匪合

23382
31:47:00.962 --> 31:47:06.542
作和与这个模糊测试器合作的链接，这样你就可以继续学习更多内容。

23383
31:47:06.542 --> 31:47:12.796
现在，如果你从这一整部分中拿走任何东西，它应该是这里。

23384
31:47:12.796 --> 31:47:15.133
两个最常见的任务是可重入的。

23385
31:47:15.133 --> 31:47:16.694
看，和Oracle操作。

23386
31:47:16.694 --> 31:47:22.288
如果你不打算做审计员，你只想把东西部署到主网上，在你部署任

23387
31:47:22.288 --> 31:47:28.075
何东西之前，你应该做的绝对最小值就是一直运行Slither。

23388
31:47:28.075 --> 31:47:32.606
然后手动查找Oracle操作和可重入性攻击。

23389
31:47:32.606 --> 31:47:37.043
如果您在代码中看到您正在获取定价信息。

23390
31:47:37.114 --> 31:47:42.087
价格是我们人类分配给某个东西的数据如果你从一个集中的位置

23391
31:47:42.087 --> 31:47:47.061
获得定价信息，重新考虑一下场景，重新考虑你在那里做什么。

23392
31:47:47.061 --> 31:47:53.327
如果您得到的是一个随机数，如果您正在从一个集中的位置进行任何类型的自动化，请重新考虑并改变您的策略。

23393
31:47:53.327 --> 31:47:59.114
创建链链接Oracle网络是为了防止像这样的黑客攻击。

23394
31:47:59.114 --> 31:48:05.063
因此，在部署任何带有任何类型安全保证的主要内容之前，请记住这些。

23395
31:48:05.114 --> 31:48:05.692
好了,好了。

23396
31:48:08.114 --> 31:48:09.828
了解了一些慢速工具。

23397
31:48:11.114 --> 31:48:11.850
公司或Mythix。

23398
31:48:14.114 --> 31:48:17.372
蝠鲼公司将是三叶虫团队的另一个工具。

23399
31:48:17.372 --> 31:48:23.595
Mythix实际上是共识团队提供的一种智能合约安全服务，你把他们在云

23400
31:48:23.595 --> 31:48:29.818
端运行的机器人发送到你的合约上，它会执行一些自动流程来检查安全漏洞。

23401
31:48:29.818 --> 31:48:30.898
这是一项付费服务。

23402
31:48:30.898 --> 31:48:36.060
但如果你要部署一个价值数百万美元的协议，只花区区1000美元。

23403
31:48:36.114 --> 31:48:38.664
花1000美元来确保它真的有用。

23404
31:48:39.114 --> 31:48:42.442
你想要投资的东西肯定是正确的。

23405
31:48:42.442 --> 31:48:45.645
在你完成整个过程之后。

23406
31:48:45.645 --> 31:48:49.814
你们这些智能合约开发人员和审计员应该讨论他们的发现。

23407
31:48:49.814 --> 31:48:55.176
如果有任何问题，请重复这些步骤，在做出更改后再次重复所有步骤。

23408
31:48:55.176 --> 31:48:59.442
因此，审计过程和确保合同安全是一个漫长的过程。

23409
31:48:59.442 --> 31:49:07.017
之后，审计员会写一份报告，包括他们在你的合同中发现的所有安全漏洞。

23410
31:49:07.017 --> 31:49:13.830
通常情况下，你会将报告组织在一个像这样的图表中，你会将发生几率高、影

23411
31:49:13.830 --> 31:49:20.844
响大的问题标记为影响大的关键问题，而可能性低的问题则标记为中等，等等。

23412
31:49:20.844 --> 31:49:27.277
我还会留下一些例子两个过去做过的审计这样你们就可以看一看。

23413
31:49:27.277 --> 31:49:30.243
您可以看到对某些代码的全面审计是什么样的。

23414
31:49:30.243 --> 31:49:37.372
我们会研究openzeppelin sigma '和三叶虫，因为我认为这三种是这个领域中最好的审计师。

23415
31:49:37.372 --> 31:49:38.561
现在在GitHub回购。

23416
31:49:38.561 --> 31:49:45.377
我们还有很多其他工具可以使用Mythix、秘银醚play和共识安全工具。

23417
31:49:45.377 --> 31:49:53.581
如果您想了解更多关于安全和审计的知识，我强烈建议您在本课程结束后玩以太网游戏和该死的脆弱的Defy。

23418
31:49:53.581 --> 31:49:56.573
这两款游戏将教会你很多关于安全的知识。

23419
31:49:56.573 --> 31:50:00.780
我们会测试排骨我们会测试你在这门课上学到的所有东西。

23420
31:50:00.780 --> 31:50:04.014
还有一些我非常喜欢的关于安全的博客。

23421
31:50:04.014 --> 31:50:06.385
其中一个是失事点新闻。

23422
31:50:06.385 --> 31:50:15.045
他们列出了这个领域中曾经发生过的一些最大的黑客事件，然后回顾了这些事件发生的原因。

23423
31:50:15.045 --> 31:50:17.447
他们通常也会把它做得很有趣。

23424
31:50:17.447 --> 31:50:19.980
我们这里也有一些文章。

23425
31:50:20.114 --> 31:50:26.649
其中一个最好的地方是已知的攻击部分，他们讨论了可重入性、Oracle操作、前端运

23426
31:50:26.649 --> 31:50:33.184
行和其他大量的攻击，这些是你在编写智能合约时绝对应该注意的，我们不打算在这里详细

23427
31:50:33.184 --> 31:50:40.046
介绍，因为他们在这些资源中做了很好的解释，你也应该看看这篇文章，因为我帮助编写了它。

23428
31:50:40.046 --> 31:50:41.507
所以一定要去看看。

23429
31:50:41.507 --> 31:50:43.867
我们还有更多的章节列表。

23430
31:50:43.867 --> 31:50:46.991
这将是一个有生命的部分。

23431
31:50:46.991 --> 31:50:48.239
所以请随意。

23432
31:50:48.239 --> 31:50:54.909
如果您将来发现了更多的东西，请随意发出pull请求并更新这个存储库，以便其他人可以学习

23433
31:50:54.909 --> 31:51:01.736
和了解更多关于安全和审计的知识，并提供关于糟糕代码是什么样子以及如何捕获它们的契约示例。

23434
31:51:01.736 --> 31:51:03.584
尽管这是我们最快的环节之一。

23435
31:51:03.584 --> 31:51:10.041
从视频的角度来看，这将是你职业生涯中最长的一段。

23436
31:51:10.114 --> 31:51:13.065
安全是您始终要考虑的问题。

23437
31:51:13.114 --> 31:51:16.066
而且总是会有新的工具来帮助安全。

23438
31:51:16.114 --> 31:51:17.980
而且总是会有新的东西需要思考。

23439
31:51:18.114 --> 31:51:26.303
尽管我们讲得很快，我还是百分之百希望你们暂停这个视频，尝试一下我们在这里用过的一些工具。

23440
31:51:26.303 --> 31:51:31.004
然后甚至可以试着说出你自己的弱点。

23441
31:51:31.004 --> 31:51:37.945
话是这么说，你刚刚完成了这门关

23442
31:51:37.945 --> 31:51:44.886
于智能合约、实体、web 3和

23443
31:51:44.886 --> 31:51:51.827
区块链开发的大型硕士课程的最后

23444
31:51:51.827 --> 31:51:59.694
一部分，你应该为自己感到无比自豪。

23445
31:51:59.694 --> 31:52:06.208
恭喜你，我和网络三社区作为一个整体

23446
31:52:06.208 --> 31:52:12.722
想祝贺你完成了这个绝对怪物的教程，

23447
31:52:12.722 --> 31:52:19.622
你已经做了一个惊人的工作，走到今天。

23448
31:52:19.622 --> 31:52:22.221
看着我现在和你说话。

23449
31:52:22.221 --> 31:52:26.780
如果你还没有完成这门课程，在来这里之前回去完成它。

23450
31:52:26.780 --> 31:52:29.726
我们在这段旅程中学到了很多。

23451
31:52:29.726 --> 31:52:36.016
我可以从我的灵魂深处说，我很高兴有你在web三空间，智能

23452
31:52:36.016 --> 31:52:42.307
合约空间，区块链空间，加密货币空间，我们很高兴你在这里。

23453
31:52:42.307 --> 31:52:47.796
我真的很期待在区块链社区的webthree中见到你。

23454
31:52:47.796 --> 31:52:53.283
很多人会问，我该去哪里?我并没有这些新发现的知识。

23455
31:52:53.283 --> 31:52:57.047
我武装了智能的web三开发空间。

23456
31:52:57.047 --> 31:53:02.533
好吧，我在GitHub存储库中留下了一些链接，以引导您进入下一步。

23457
31:53:02.533 --> 31:53:09.482
但现在你能为自己做的最大的一件事就是把你学到的东西应用到其他地方。

23458
31:53:09.482 --> 31:53:15.130
这可能是你们在这方面学过的最全面的课程。

23459
31:53:15.130 --> 31:53:19.458
你可以去一个又一个教程，一个又一个训练营，随你便。

23460
31:53:19.458 --> 31:53:24.300
但在某些时候，你必须做出跳跃，你必须投入进去。

23461
31:53:24.300 --> 31:53:27.775
无论如何，这也是大部分增长的来源。

23462
31:53:27.775 --> 31:53:31.864
所以，如果你在这里，想知道下一步该去哪里，那就去参加黑客马拉松吧。

23463
31:53:31.864 --> 31:53:36.609
开始在GitHub上讨论问题，开始申请拨款，

23464
31:53:36.609 --> 31:53:41.355
开始申请工作，然后说，我上了帕特里克的大课。

23465
31:53:41.355 --> 31:53:46.677
这是我的GitHub回购，在个人项目上工作，在别人的项目上工作。

23466
31:53:46.677 --> 31:53:51.989
接受这些知识并应用它们，你将会遇到的挑战和你将面对的挑战。

23467
31:53:51.989 --> 31:54:00.047
在没有我的帮助下做一件事，你学到的东西会比在这里学到的多十倍。

23468
31:54:00.114 --> 31:54:03.355
我已经尽我所能把你带进这个兔子洞了。

23469
31:54:03.355 --> 31:54:07.709
现在就看你走出去用它做点什么了。

23470
31:54:07.709 --> 31:54:10.598
谢谢所有帮助我开设这门课的人。

23471
31:54:10.598 --> 31:54:12.580
谢谢你们上这门课。

23472
31:54:12.580 --> 31:54:20.114
我很高兴能在社区中看到你们，看到你们创造了什么，看到我们能用这项技术创造了什么。

