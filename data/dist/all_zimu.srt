1
00:00:00.000 --> 00:00:03.284
If you're interested in learning about blockchain, this is the course for you.

2
00:00:03.284 --> 00:00:08.948
Patrick Collins is a veteran software engineer and longtime finance industry developer.

3
00:00:08.948 --> 00:00:12.089
Be sure to leave a comment with something you learned from this course.

4
00:00:12.128 --> 00:00:28.984
Welcome to the ultimate solidity smart contract and blockchain Developer course, JavaScript addition, we recently did a version of this video in Python that has over 2 million views right now making it the most watched smart contract tutorial on the planet.

5
00:00:28.984 --> 00:00:31.623
We've learned a ton from doing that first course.

6
00:00:31.623 --> 00:00:35.263
And if you love the Python language, definitely be sure to check that one out.

7
00:00:35.263 --> 00:00:41.114
We've taken all the learnings we've got from making that first course, wrapped it up and put it into this JavaScript video for you.

8
00:00:41.114 --> 00:00:48.721
If you're looking to get started in web three blockchain smart contracts or any of these terms, this is the course for you.

9
00:00:48.721 --> 00:00:54.560
And it's for anybody and everybody, no matter your experience level in programming or in blockchain.

10
00:00:54.560 --> 00:00:58.520
Ideally, you know, a little bit of JavaScript before starting this.

11
00:00:58.520 --> 00:01:01.465
But if you don't, no worries, we will help you along the way.

12
00:01:01.465 --> 00:01:10.886
And in case you do want to learn a little bit of JavaScript before starting here, there are some fantastic courses on Free Code Camp to learn more, but you absolutely don't have to.

13
00:01:10.886 --> 00:01:15.401
And really, any experience with any object oriented programming language will work, right.

14
00:01:15.401 --> 00:01:21.998
So if you're brand new to coding, or if you're brand new to blockchain, this is exactly where you should be.

15
00:01:21.998 --> 00:01:29.809
And if you already know a lot about blockchain or coding, this course will give you even more deep fundamentals on the space.

16
00:01:29.891 --> 00:01:31.899
So welcome to the edge of the rabbit hole.

17
00:01:32.928 --> 00:01:35.238
who don't know, my name is Patrick Collins.

18
00:01:35.953 --> 00:01:39.551
contract engineer, developer advocate on the chain link protocol.

19
00:01:39.551 --> 00:01:42.108
And I live in breed smart contracts.

20
00:01:42.108 --> 00:01:46.481
I also make YouTube videos on my own channel, medium Twitter threads and more.

21
00:01:46.481 --> 00:01:50.805
teaching people about smart contracts about coding and about this new technology.

22
00:01:50.805 --> 00:01:54.945
I love helping developers learn, grow and learn about this new Advent.

23
00:01:54.945 --> 00:01:56.892
That's blockchain and smart contracts.

24
00:01:56.892 --> 00:02:03.981
And I'll be taking you on your journey to becoming a blockchain expert and Wizard of the smart contract developing world.

25
00:02:03.981 --> 00:02:15.445
And even if you don't want to become a developer, the first section our blockchain basics, will give you a lot of fundamental knowledge about how blockchain and smart contracts, even work.

26
00:02:15.445 --> 00:02:17.742
I am so excited for you to be here.

27
00:02:17.742 --> 00:02:19.587
And I hope you enjoy the journey.

28
00:02:19.587 --> 00:02:25.090
This is a data dump, passion educational project of everything I've learned working in this space.

29
00:02:25.090 --> 00:02:47.466
And I am 100% certain that if you follow along, you'll come out the other side of this, armed with the knowledge to be a positive force in this incredible industry, solidity and smart contract developers are massively in demand with an average salary of being around $145,000 a year, there is massive economic opportunity from learning this course.

30
00:02:47.466 --> 00:02:56.340
And this technology has the ability to revolutionize everything that we interact with, and you can be one of the pioneers ushering in this new age.

31
00:02:56.340 --> 00:02:57.324
In our courses.

32
00:02:57.324 --> 00:03:05.496
We already have a track record of giving people these educational needs and sending them into their careers in the blockchain and smart contract space.

33
00:03:05.496 --> 00:03:17.178
And we are going to give you all of the cutting edge tools and how to use them including working with things like D phi NF TS Dows, ERC 20s upgradable, smart contracts and more.

34
00:03:17.178 --> 00:03:31.017
We're going to teach you the skills necessary to build defy applications like Ave synthetics and compound, billion dollar decentralized applications, or massively successful NFT projects like crypto punks, or board apes.

35
00:03:31.017 --> 00:03:38.023
Dow is like maker Dow or developer, Dow and any of the amazing things you've seen in the cryptocurrency world.

36
00:03:38.023 --> 00:03:47.968
In learning these skills, you will have all these economic opportunities at your fingertips and the ability to be a pioneer in completely changing the way we interact with each other.

37
00:03:47.968 --> 00:03:49.138
In a fundamental way.

38
00:03:49.138 --> 00:04:04.910
Building decentralized smart contract applications is building a world that's more accountable a world with unbreakable promises, a faster, more efficient, financially free world, a collaborative community, combining the prowess of philosophy and technology into a new system.

39
00:04:04.910 --> 00:04:13.866
We'll learn more about the purpose and the value of smart contracts and decentralized applications in lesson one of this course, and why they're so exciting.

40
00:04:13.866 --> 00:04:14.823
Finish this course.

41
00:04:14.823 --> 00:04:15.858
And you'll be ready.

42
00:04:15.858 --> 00:04:22.974
So again, I want to give a major thank you and a major kudos to you because you've taken the first step to enter this realm.

43
00:04:22.974 --> 00:04:24.464
So welcome to Web three.

44
00:04:24.464 --> 00:04:25.505
Welcome to the blockchain.

45
00:04:25.505 --> 00:04:26.709
Welcome to smart contracts.

46
00:04:26.709 --> 00:04:29.170
And I'll see you at the bottom of the rabbit hole.

47
00:04:29.269 --> 00:04:40.105
So let's jump into some best practices for this course so that you can learn most effectively and learn with this course as best you can.

48
00:04:40.280 --> 00:04:41.724
You do not want to skip this part.

49
00:04:41.724 --> 00:04:43.643
It'll help you solve 80% of your issue.

50
00:04:43.643 --> 00:05:05.757
Now, while going through this course be 100% certain to follow along with a GitHub repository associated with this course we have a link in the description of this video for you to absolutely click on follow along have open in a tab as you're doing this because it has all the code Sam polls, timestamps a community to interact with and more, it is going to be your Bible for watching this course.

51
00:05:05.757 --> 00:05:07.473
And yes, we have a Discussions tab.

52
00:05:07.473 --> 00:05:14.602
This Discussions tab is a place where you can ask questions, engage with other developers who are going through this course as well.

53
00:05:14.602 --> 00:05:16.162
Get some help, and etc.

54
00:05:16.162 --> 00:05:20.269
Be sure to say hello and meet other like minded individuals like yourselves.

55
00:05:20.319 --> 00:05:22.286
Now, blockchain and smart contracts move really quickly.

56
00:05:22.322 --> 00:05:24.181
And things are constantly being updated.

57
00:05:25.325 --> 00:05:31.658
always up to date with the latest, when I open up some documentation, try to open up the documentation for yourself as well.

58
00:05:31.658 --> 00:05:33.911
And maybe even have the code sample next to you.

59
00:05:33.911 --> 00:05:45.296
And as you're writing code, be sure to refer back to make sure that you are keeping pace, and then you have the most up to date samples, sometimes technology might change, and there might be a way to do something a little bit better.

60
00:05:45.296 --> 00:05:54.692
So we have this file called chronological updates, be sure that this is the first place to check when you run into an issue to see if maybe something was updated that you missed, it'll be chronologically ordered.

61
00:05:54.692 --> 00:05:56.193
So it's easier to find updates.

62
00:05:56.193 --> 00:05:59.633
Basically, this is to say, always refer back to the GitHub repo first.

63
00:05:59.633 --> 00:06:19.695
And if you do to find a mistake, or something isn't working the way you expected, jump into the conversation, leave a discussion, leave an issue, ask questions here, take breaks, I cannot tell you how many people tried rushing through our entire first course in one setting and didn't retain as much information, your brain remembers information much better if you take breaks.

64
00:06:19.695 --> 00:06:23.104
So every 25 minutes or half an hour, maybe take a five minute walk.

65
00:06:23.104 --> 00:06:25.565
And then every two hours take a much longer break.

66
00:06:25.565 --> 00:06:32.357
And if you really want to make sure something drills in, try to go back and reflect on what you did for the lesson prior before continuing to the next lesson.

67
00:06:32.392 --> 00:06:35.928
And at the same time, though, learn at your own speed.

68
00:06:36.396 --> 00:06:39.194
is no right speed for this course.

69
00:06:41.400 --> 00:06:44.485
week, a month or even a year, it doesn't matter.

70
00:06:45.404 --> 00:06:52.134
pace that's right for you, you can change the speed at which I talked using the little gear icon in the YouTube video.

71
00:06:52.134 --> 00:06:55.160
If I'm talking way too fast for you, you can slow me down.

72
00:06:55.160 --> 00:07:01.307
And at the same time, if I'm talking too slow, you can speed me up, you also don't even have to go in order.

73
00:07:01.307 --> 00:07:06.443
You can bounce around topic to topic, if you don't want to learn full stack, you can skip the full stack stuff.

74
00:07:06.443 --> 00:07:09.142
If you don't want to learn coding, we can skip the coding stuff.

75
00:07:09.142 --> 00:07:12.631
If you only want to go to the advanced stuff, go to the advanced stuff.

76
00:07:12.631 --> 00:07:16.152
You are highly encouraged to pause, come back and ask questions.

77
00:07:16.152 --> 00:07:19.264
The blockchain and smart contract world is incredibly collaborative.

78
00:07:19.264 --> 00:07:39.858
So be sure to use tools like the discussions tab of our GitHub repository, asking questions on Stack Overflow and Aetherium Stack Exchange and tagging relative technologies, making issues on different GitHub repositories that you're working with jumping into discord, Reddit, Twitter, and any other place that these communities and technologies are congregating.

79
00:07:39.858 --> 00:07:47.677
And the reason I'm putting so much emphasis on these community aspects is that becoming a solidity and blockchain engineer is so much more than just the solidity part.

80
00:07:47.677 --> 00:07:56.784
Being comfortable with all the tools in this space, including the ones to get help and to give help are essential to being successful here.

81
00:07:56.784 --> 00:07:59.545
Networking is massive, and it makes it a ton of fun.

82
00:07:59.545 --> 00:08:04.150
As you continue your journey and you get more advanced and you're looking for places to meet other developers.

83
00:08:04.150 --> 00:08:14.759
Hackathons are one of the best places to connect with other engineers, the chainlink hackathons eath, global hackathons, and Dev folio hackathons are three great hackathon suites to connect.

84
00:08:14.759 --> 00:08:19.447
And no matter where you are in your journey, they're great places to flex what you've learned.

85
00:08:19.499 --> 00:08:22.882
Alright, so those are some of the best practices for this course.

86
00:08:22.882 --> 00:08:31.187
You're standing at the edge of the rabbit hole, looking down, peering into the world of web three and smart contracts and blockchain.

87
00:08:31.187 --> 00:08:34.693
If you're like me want to jump in, you want to keep going further.

88
00:08:34.693 --> 00:08:38.350
Let's begin our journey into the world of smart contracts.

89
00:08:38.350 --> 00:08:43.093
And it all starts with the blockchain basics.

90
00:08:43.523 --> 00:08:45.185
Now, I know you're excited to get coding.

91
00:08:45.185 --> 00:08:50.475
But before we jump in, we want to learn some of the fundamentals of blockchains and smart contracts.

92
00:08:50.530 --> 00:09:01.450
Understanding these ideologies and these basics are so important, because it'll dictate how you architect your decentralized applications, learning the basics of blockchain and solidity is critical.

93
00:09:01.450 --> 00:09:07.796
But if you already know the basics of a blockchain, feel free to jump into lesson two.

94
00:09:08.547 --> 00:09:11.407
Now, since you're here, you've probably heard of Bitcoin before.

95
00:09:11.407 --> 00:09:17.047
Bitcoin was one of the first protocols to use this revolutionary technology called blockchain.

96
00:09:17.047 --> 00:09:24.834
The Bitcoin white paper was created by the pseudo anonymous Satoshi Nakamoto, and outlined how Bitcoin can make peer to peer transactions.

97
00:09:24.834 --> 00:09:26.208
In a decentralized network.

98
00:09:26.208 --> 00:09:38.702
This network was powered by cryptography, decent Tality, and allowed people to engage in censorship resistant finance, in a decentralized manner due to its features, which we'll talk about in a little bit.

99
00:09:38.702 --> 00:09:51.525
People took to this as a superior digital store of value, a better store of value over something like gold, for example, and that's why you'll also hear people commonly refer to it as a digital gold similar to gold.

100
00:09:51.590 --> 00:09:57.138
There's a scarce amount or a set amount of bitcoin available on the planet, only so much that you can buy and sell.

101
00:09:57.138 --> 00:10:04.416
You can read more about the original vision in the white A paper we've linked to the white paper in the GitHub repo associated with this course.

102
00:10:04.416 --> 00:10:11.137
Now, this was an insane breakthrough in a little bit, we're going to learn exactly how this is all possible and how this actually works under the hood.

103
00:10:11.137 --> 00:10:18.375
Some people though, saw this technology and wanted to take it a little bit farther, and do even more with this blockchain technology.

104
00:10:18.375 --> 00:10:30.306
And a few years later, a man named Vitalik Buterin, released a white paper for a new protocol named Aetherium, which use this same blockchain infrastructure with an additional feature.

105
00:10:30.306 --> 00:10:48.542
And in 2015, him and a number of other co founders released the project Aetherium, where people could not only make decentralized transactions, but decentralized agreements, decentralized organizations, and all these other ways to interact with each other without a centralized intermediary or centralized governing force.

106
00:10:48.542 --> 00:10:57.562
Basically, their idea was to take this thing that made Bitcoin so great, and add decentralized agreements to it, or smart contracts.

107
00:10:57.562 --> 00:11:01.338
And in fact, technically, these smart contracts weren't even really a new idea.

108
00:11:01.338 --> 00:11:16.882
Back in 1994, a man named Nick Zabo, had actually originally come up with the idea smart contracts are a set of instructions executed in a decentralized autonomous way, without the need for a third party or centralized body to run them.

109
00:11:16.882 --> 00:11:21.680
And they come to life on these blockchains, or these smart contract platforms, like Aetherium.

110
00:11:21.680 --> 00:11:32.167
And it's the smart contracts that are going to be the core thing that we're going to be working on in this course, and that we're going to be developing, you can think of smart contracts in the same way you think of traditional contracts or traditional agreements.

111
00:11:32.167 --> 00:11:43.491
They're just a set of instructions between parties, except instead of written on pen and paper or typed up in Microsoft Word, they are written in code and embodied on these decentralized blockchain platforms.

112
00:11:43.491 --> 00:11:45.592
And that's also where they're executed.

113
00:11:45.592 --> 00:11:50.280
Instead of being executed by the two parties, or three parties, or however many parties that are involved.

114
00:11:50.280 --> 00:11:54.692
This removes this centralized issue that we'll talk about more in a bit.

115
00:11:54.692 --> 00:11:59.677
This is one of the main differentiators between the Etherium protocol and the Bitcoin protocol.

116
00:11:59.677 --> 00:12:01.298
It's these smart contracts.

117
00:12:01.298 --> 00:12:10.939
Now, technically, bitcoin does have smart contracts, but they're intentionally Turing incomplete, which means they don't have all the functionality that a programming language would give them.

118
00:12:10.939 --> 00:12:13.625
This was an intentional move by Bitcoin developers.

119
00:12:13.732 --> 00:12:26.270
Bitcoin developers viewed Bitcoin as a store of value versus Aetherium, developers viewed Aetherium as both a store of value and a utility to facilitate these decentralized agreements.

120
00:12:26.270 --> 00:12:30.112
Now, the smart contracts on blockchains alone are absolutely incredible.

121
00:12:30.112 --> 00:12:32.267
However, they do come with a huge issue.

122
00:12:32.267 --> 00:12:45.800
If we want these digital agreements to replace the agreements in our everyday lives, they probably are going to need data from the real world blockchains by themselves actually can't interact with and can't read or listen to data from the real world.

123
00:12:45.800 --> 00:12:48.141
This is what's known as the Oracle problem.

124
00:12:48.141 --> 00:12:51.933
These blockchains are deterministic systems and they're deterministic on purpose.

125
00:12:51.933 --> 00:12:55.070
And we'll learn about more about how that works in the sessions to come.

126
00:12:55.070 --> 00:12:58.376
So everything that happens with them happens in their little world.

127
00:12:58.376 --> 00:13:02.798
But if they're going to be these agreements, they need external data and they need external computation.

128
00:13:02.798 --> 00:13:05.085
And this is where Oracle's come into play.

129
00:13:05.085 --> 00:13:10.772
Oracle's are any device that delivers data to these decentralized blockchain or runs external computation.

130
00:13:10.772 --> 00:13:22.542
However, if we want our applications to stay truly decentralized, we can't work with a single Oracle or a single data provider or a single source that's running these external computations.

131
00:13:22.542 --> 00:13:25.095
So we need a decentralized Oracle network.

132
00:13:25.095 --> 00:13:36.439
Similar to our decentralized blockchain network, you're on chain logic will be decentralized, but you also need your off chain data and computation be decentralized, combining this on chain decentralized logic.

133
00:13:36.439 --> 00:13:43.340
With this off chain, decentralized data and decentralized computation gives rise to something called hybrid smart contracts.

134
00:13:43.340 --> 00:13:51.692
And most of the biggest protocols that we interact with today are some type of hybrid smart contract or interact with hybrid smart contracts.

135
00:13:51.692 --> 00:13:55.342
To some extent, this is where the protocol chaining comes into play.

136
00:13:55.342 --> 00:14:09.786
It is a modular, decentralized Oracle network that can both bring external data and external computation into our smart contracts to make sure they're decentralized end to end, while giving them the feature richness that we need for our agreements.

137
00:14:09.848 --> 00:14:17.307
chainlink allows for us to get data to upkeeps, get random numbers or really customize our smart contracts in any meaningful way.

138
00:14:17.307 --> 00:14:20.794
Now, throughout the course, we're going to use the terminology smart contract.

139
00:14:20.794 --> 00:14:35.349
However, whenever we say smart contract, we're often using it a little interchangeably with hybrid smart contracts, but just know that when we say hybrid smart contract, we're talking specifically about smart contracts that have some type of off chain component.

140
00:14:35.349 --> 00:14:44.148
Now since the theorems release, a number of different block chains or smart contract platforms have come to light such as avalanche polygon, Phantom harmony, and more.

141
00:14:44.148 --> 00:14:49.721
For the majority of this course, we're going to be assuming that we're going to be deploying to the Ethereum network.

142
00:14:49.721 --> 00:15:06.243
However, everything that we learned here is going to be applicable to the vast majority of the blockchains out there like polygon, avalanche, Phantom harmony, etc, and understanding everything from a theory and funding mentals will give you the skills that you need to switch chains very easily with literally one line of code.

143
00:15:06.243 --> 00:15:12.847
So don't worry about learning a specific tool or with a specific chain because most of them work together seamlessly.

144
00:15:12.911 --> 00:15:16.477
Now, there are a couple of smart contract platforms that don't use solidity.

145
00:15:16.477 --> 00:15:20.602
But still learning the fundamentals here will make you much better at those as well.

146
00:15:20.602 --> 00:15:26.082
And the Etherium by far has the most value locked and is the most used blockchain and smart contract platform out there.

147
00:15:26.082 --> 00:15:29.870
You'll also hear those two terms used a little bit interchangeably as well.

148
00:15:29.928 --> 00:15:34.880
Sometimes they'll say smart contract platform, sometimes they'll say blockchain, they kind of mean the same thing.

149
00:15:34.933 --> 00:15:40.495
Obviously, blockchains could mean store of value and smart contract platform, but you get the idea.

150
00:15:40.495 --> 00:15:47.237
Similarly, chainlink is the most popular and powerful decentralized Oracle network is the one that we're going to be focusing on for this course as well.

151
00:15:47.237 --> 00:15:50.002
chainlink is also blockchain agnostic.

152
00:15:50.002 --> 00:15:55.779
So to work on Aetherium, avalanche, Polygon Solana Terra, or really any other blockchain out there.

153
00:15:55.779 --> 00:16:03.673
Now, throughout this course, you'll hear the term DAP or decentralized Protocol, or smart contract Protocol, or decentralized application.

154
00:16:03.673 --> 00:16:06.001
And they all kind of mean the same thing.

155
00:16:06.001 --> 00:16:09.425
A decentralized application is usually the combination of many smart contracts.

156
00:16:09.425 --> 00:16:14.056
And when we get into solidity, you'll see what a singular smart contract really looks like.

157
00:16:14.056 --> 00:16:23.382
And like I said, learning all these core fundamentals will make you a better solidity and a better smart contract developer, you'll also hear the term web three a lot in this video.

158
00:16:23.382 --> 00:16:42.261
And in the industry, web three is the idea that blockchain and smart contracts are the next iteration of the web web one being this permissionless open source world with static content, web two being the permissioned web with dynamic content, but all the agreements and logic runs off of centralized servers where they control your information.

159
00:16:42.261 --> 00:16:45.280
And then web three comes back to the permissionless web.

160
00:16:45.280 --> 00:17:04.052
But once again, with dynamic content, and instead of centralized servers, running your logic, decentralized networks, run the logic creating these censorship resistant agreements, that the smart contracts enable is also generally accompanied by the idea that the users own the protocols that they work with, and it's an ownership economy.

161
00:17:04.102 --> 00:17:05.467
You'll see what I mean later in this course.

162
00:17:06.102 --> 00:17:12.051
lot about the history and about the high level of these protocols and of the smart contracts and what they can do.

163
00:17:12.103 --> 00:17:25.461
But what do these smart contracts really mean? What is it when I say trust, minimize agreements or unbreakable promises? What is the real value add of these smart contracts? Before we look under the hood, take a peek at how this all works.

164
00:17:25.461 --> 00:17:27.461
From a technical standpoint.

165
00:17:27.461 --> 00:17:30.104
Let's learn what all the value of this is.

166
00:17:30.104 --> 00:17:40.044
What is the purpose of us building all these technologies? Have you taken this course? What problem does this technology solve? In my mind, a technology is really only as good as the problem that it solves.

167
00:17:40.044 --> 00:17:52.507
If it doesn't solve a problem, then why bother Mark contracts, Blockchain web three cryptocurrencies, those are all just different words that encapsulate the idea of what we're doing in such a unique paradigm.

168
00:17:52.507 --> 00:17:58.794
I think the easiest way to sum up what these smart contracts do is that they create trust minimized agreements.

169
00:17:58.794 --> 00:18:01.202
And if you might be scratching your head to that.

170
00:18:01.202 --> 00:18:06.650
A much easier way to think about it is just that give rise to unbreakable promises.

171
00:18:06.650 --> 00:18:08.412
Yes, you heard that right.

172
00:18:08.412 --> 00:18:10.679
Unbreakable agreements and promises.

173
00:18:10.679 --> 00:18:16.076
Additionally, they give rise to speed, efficiency and transparency, and a number of other things.

174
00:18:16.076 --> 00:18:19.339
I made a video pretty recently about exactly this.

175
00:18:19.339 --> 00:18:33.053
So let's dive in and take a listen to the purpose the undeniable value of smart contracts cryptocurrencies, fundamentally re landscape markets and agreements as we know them.

176
00:18:33.111 --> 00:18:37.268
Unfortunately, you've probably only been bombarded with people screaming about empties and money.

177
00:18:37.268 --> 00:18:42.094
Now, some of the memes are fun, but let's forget the bullet and get down to the essence of the space.

178
00:18:42.094 --> 00:18:43.619
If you're already in web three.

179
00:18:43.619 --> 00:18:49.620
This is the video to send to your friends to explain why you're so excited about this space and explain why we're here.

180
00:18:49.620 --> 00:18:53.061
And then if you're not into crypto, you've come to the right place.

181
00:18:53.113 --> 00:18:56.663
And yes, there are fun memes and markets and there's some money stuff in there all these things.

182
00:18:56.663 --> 00:19:06.468
But outside of all that the purpose of blockchains relates to the age old elementary school unbreakable, promise the pinky swear, let's get Froggy.

183
00:19:06.468 --> 00:19:10.665
Nearly everything you do in life is the result of an agreement or a contract.

184
00:19:10.665 --> 00:19:16.580
Your chair was the result of an agreement to buy and sell lumber to assemble and sell the chair to a real tailor on Amazon.

185
00:19:16.580 --> 00:19:19.325
Then you made an agreement to buy the chair for $40.

186
00:19:19.325 --> 00:19:47.704
The lights in your house are powered by electricity, which is an agreement from you and the electric company you agree to pay them in return they'll keep the lights on the electricity they generate it's agreements between them and engineers who built turbines to generate the electricity with insurance you agree to pay some amount of money to them every month, and in return, they will do nothing or I mean, they'll cover your medical bills, almost everything you do and everything you interact with is the result of some form of agreement or contract in some aspect.

187
00:19:47.704 --> 00:19:56.032
Now, agreements and contracts can feel kind of abstract and boring to really grasp on to simplify, we can also refer to them as promises.

188
00:19:56.032 --> 00:19:57.309
When you get an oil change.

189
00:19:57.309 --> 00:20:07.289
They're promising that they will faithfully change your oil In exchange for money, when you put money in the bank, they promise to keep it safe in exchange for them to use your money to give out loans.

190
00:20:07.289 --> 00:20:14.201
When you buy a lottery ticket, the lottery promises to give you a fair chance at winning a ton of money in exchange for you buying the ticket.

191
00:20:14.201 --> 00:20:16.604
Whenever you make one of these agreements.

192
00:20:16.604 --> 00:20:21.630
In a way, you're asking them to pinky swear to not screw you over and to treat you fairly.

193
00:20:21.630 --> 00:20:23.172
But this doesn't always happen.

194
00:20:23.172 --> 00:20:32.075
Let's look at a real world example of someone breaking the Pinkie swear back in the 80s and 90s, McDonald's ran a promotion for people to win money by collecting McDonald's Monopoly game cards.

195
00:20:32.075 --> 00:20:33.027
The idea was simple.

196
00:20:33.123 --> 00:20:36.748
You buy McDonald's in return, you get a chance to win $1 million.

197
00:20:36.748 --> 00:20:54.999
You can imagine McDonald's literally going Hey, everybody, I promise you if you buy our MC food and McNuggets, we'll give you a fair chance of winning this money, we ended up breaking this promise, instead of having a fair chance of winning your chance was in fact, zero in the mid 90s.

198
00:20:54.999 --> 00:21:01.040
Between 13 and $24 million went into the pockets of not people playing the game, honestly.

199
00:21:01.040 --> 00:21:11.707
But a group of corrupt insiders who had rigged the game, meaning that when you played the McDonald's Monopoly game, you were buying into a set of lies and promises that were 100% always going to be broken.

200
00:21:11.707 --> 00:21:16.075
And the thing is, it doesn't really matter if this was McDonald's fault or not.

201
00:21:16.127 --> 00:21:19.593
They were the ones making the promises that they ultimately could not keep.

202
00:21:19.593 --> 00:21:40.555
Another way you could think about it is that that's $24 million that they essentially stole from you and I now if this system was deployed on a blockchain was something called a smart contract, it would have been impossible to defraud this $24 million due to smart contracts being immutable, decentralized and transparent.

203
00:21:40.555 --> 00:21:42.630
But I'll get back to that in a minute.

204
00:21:42.630 --> 00:21:51.951
In all the agreements and contracts we make, imagine making a pinky swear with a 10 year old and imagining how that agreement would hold up.

205
00:21:51.951 --> 00:21:57.199
Hey, buddy, Could you could you please keep my money safe? You can play with it if you like, but just please have it when I come back.

206
00:21:57.199 --> 00:21:57.819
Immediately.

207
00:21:57.819 --> 00:22:01.389
You might get that worrying feeling in your chest, something might go wrong.

208
00:22:01.389 --> 00:22:02.647
This 10 year old might lose your money.

209
00:22:02.647 --> 00:22:13.775
You might be thinking, how could I trust them? Will they break their promise and this feeling of I can't breathe because of untrustworthy situations happens? Once all the time.

210
00:22:13.775 --> 00:22:27.607
Can I trust this used car salesperson to give me a good car? Can I trust this tag that says machine washable? Or will it make my shirt shrink? Will my insurance provider break their promise of covering my medical bills want to get hit by a bus? I'm Patrick promises he'll go on a hike with me.

211
00:22:27.607 --> 00:22:29.848
Well, he actually I actually will.

212
00:22:29.848 --> 00:22:34.796
But the issue with our current agreements and contracts is we have to trust the people.

213
00:22:34.796 --> 00:22:36.902
We're making them to do the right thing.

214
00:22:36.902 --> 00:22:40.566
However often they're actually incentivized to not do the right thing.

215
00:22:40.566 --> 00:22:42.539
insurance doesn't want to pay out money.

216
00:22:42.539 --> 00:22:48.316
Sometimes salespeople just want to get the shit off the shelves and with my girlfriend, I promised to go on a hike.

217
00:22:48.316 --> 00:22:49.152
But I need hikes.

218
00:22:49.152 --> 00:22:50.427
Where else is has happened.

219
00:22:50.427 --> 00:22:52.771
Now you might be thinking okay, Patrick, this seems cool.

220
00:22:52.771 --> 00:23:06.105
But like Where has this actually affected me? Well, the McDonald's lottery that we just spoke about above during the Great Depression with the run of the banks banks promised to keep our money safe and that when we went back to go get it they would actually have the money there.

221
00:23:06.105 --> 00:23:13.863
And well and behold there were times that they didn't have the money they're just last year Robin Hood painted this amazing picture.

222
00:23:13.863 --> 00:23:26.663
On user application we will give you access to the markets we promise we will give you a retail investor a fair chance of interacting with the world the finance side, but not this asset.

223
00:23:26.663 --> 00:23:41.521
This asset, this asset or this asset, the 2008 financial crisis remember that shady deals behind closed doors combined with lies about financial product brought the world to its economic knees, how are you? hyperinflation in Zimbabwe hyperinflation in Brazil, fair enough.

224
00:23:41.521 --> 00:23:50.318
US history is a relentless lesson of trustworthy entities being notorious promised breakers and we finally have a way to fix it with smart contracts.

225
00:23:50.318 --> 00:24:02.318
Now, before I jump into smart contracts, a lot of people might be thinking, hey, cool in all, however, we have systems in place to protect against a lot of these things, which is true, and which is great.

226
00:24:02.318 --> 00:24:04.409
And that is a very helpful step forward.

227
00:24:04.409 --> 00:24:07.644
But these systems often breaks ones in 2008 Definitely didn't work.

228
00:24:07.644 --> 00:24:10.525
The ones with the Robin Hood crisis definitely didn't work.

229
00:24:10.525 --> 00:24:22.178
And even if these systems apply, and you go to court to try to work them out, maybe you're in court for years before you actually see a resolution and by that time, what you needed the money for is longer.

230
00:24:22.178 --> 00:24:33.294
So what is this technology? What is this tool that can fix this fundamental problem in our agreements today, this tool is smart contracts and this tool is what the blockchain was built for.

231
00:24:33.294 --> 00:24:36.794
Now, I'm gonna give you a quick overview of what a smart contract is.

232
00:24:36.794 --> 00:24:48.880
However, I'm leaving some links in the description for more in depth explanations, but the basics of them is a smart contract is an agreement contract or a set of instructions deployed on a decentralized blockchain.

233
00:24:48.880 --> 00:24:58.229
And once the contract or set of instructions is deployed, it cannot be altered, it automatically executes and everyone can see the terms of the agreement.

234
00:24:58.229 --> 00:25:05.537
Real basics of it is that the code is executed by decentralized collective like a group of people but a group of people running a certain software.

235
00:25:05.537 --> 00:25:13.265
This means that no one person or entity can actually alter any of these agreements or change the terms of the arrangement in these traditional agreements.

236
00:25:13.265 --> 00:25:19.954
Whoever owns the contract, whoever owns the execution of the contract can flip a switch and say, We're not going to do that anymore.

237
00:25:19.954 --> 00:25:24.283
In smart contracts and web three in blockchain, you no longer can do that.

238
00:25:24.283 --> 00:25:32.102
Typically, these smart contracts are on a decentralized blockchain, and used in combination with a decentralized Oracle network to get the real world assets and information.

239
00:25:32.153 --> 00:25:36.645
And if these words sound like I'm conjuring up a magic spell, well, again, check the links in the description.

240
00:25:36.645 --> 00:25:38.586
If you want to learn more about the technical implications.

241
00:25:38.586 --> 00:25:48.106
If you're not a technical person, then you're not interested in getting into the nitty gritty, you can kind of think of it like HTTPS, I bet the vast majority of you don't even know what HTTPS stands for.

242
00:25:48.154 --> 00:25:51.547
And yet you use it every single day whenever you log on to the internet.

243
00:25:51.547 --> 00:26:04.850
So how does this fix the McDonald's Monopoly issue? In its traditional form, the lottery was executed behind closed doors, somebody operated and owned the code and the contracts and the agreements that ran the lottery, and they had the power to alter it.

244
00:26:04.850 --> 00:26:10.106
And nobody other than the people internal on the lottery could audit this altering happening.

245
00:26:10.156 --> 00:26:18.532
Now if the code for this lottery was deployed onto a blockchain, every time a hacker attempted to alter it, everyone would be notified.

246
00:26:18.532 --> 00:26:22.931
Not only that, but you couldn't even alter it, because the terms of a smart contract cannot be altered.

247
00:26:22.931 --> 00:26:28.965
Once deployed, combine that smart contract with a chain link VRF Oracle to get a verifiably random number.

248
00:26:28.965 --> 00:26:44.004
And presto, you now have a perfectly decentralized, unalterable agreement that is impossible to hack commit fraud or manipulate we have just saved the public between 13,000,020 $4 million just by fixing the issue of trust.

249
00:26:44.004 --> 00:26:48.124
How does this fix Robin Hood? Well, the problem with Robin Hood is already fixed.

250
00:26:48.160 --> 00:26:56.193
Right? Again, the problem is that there's a centralized body that can flip a switch at any time and say you can't access these markets anymore.

251
00:26:56.193 --> 00:26:59.906
We're breaking our promise of actually giving you access to the markets.

252
00:26:59.906 --> 00:27:02.961
This is already fixed with something called decentralized exchanges.

253
00:27:02.961 --> 00:27:07.099
And these exist today, one of these exchanges is one called uniswap.

254
00:27:07.162 --> 00:27:13.012
You can swap ERC 20 tokens, which are kind of the equivalent of stocks, but some are some are, it's a little confusing.

255
00:27:13.012 --> 00:27:14.250
I won't get into that here either.

256
00:27:14.250 --> 00:27:19.538
But it doesn't have that centralized body that can flip a switch and ruin access to the markets.

257
00:27:19.538 --> 00:27:29.634
And had these investors been on a decentralized exchange, it would have saved them hundreds of millions of dollars, and it would have prevented fraudulent market manipulation.

258
00:27:29.634 --> 00:28:03.761
How does it fix run of the banks with transparency built in an automated solvency checks, you can build a bank like smart contract that has insolvency checks built in that make it impossible to get there and solve it means brokers any agreement or any history lesson, where there was a trust assumption that was broken, smart contracts can be applied to and should be applied to, especially in a time where big money runs, owns and controls everything, we desperately need to move to a world where some self interested centralized entity can't flip a switch and ruin people's access to the services that they need.

259
00:28:03.761 --> 00:28:08.652
We can move away from a world that is brand based to a world that is math based.

260
00:28:08.652 --> 00:28:19.620
Right now, if you interact with a service that you don't like, or that they break their promise, the only thing you can do is walk down the street to the next service that's going to make the same set of promises.

261
00:28:19.620 --> 00:28:28.170
And you have to hope and pray that they're actually going to keep it we can move from that to a world where we can just look at the map and say, oh, okay, one plus one equals two.

262
00:28:28.170 --> 00:28:40.949
This is what this agreement is going to do for me every single time guaranteed, because it's a decentralized autonomous agent has no incentive to be evil, and everything is transparent and out in the open of a big company.

263
00:28:40.949 --> 00:28:51.120
And if it was better for me for one plus one to equal three, maybe I would go behind some closed doors and flood some numbers and come back and be like, hey, one plus one equals three with smart contracts.

264
00:28:51.172 --> 00:28:52.324
That's impossible.

265
00:28:55.173 --> 00:29:08.124
now, given the choice between two agreements, one where you have to trust a single centralized entity that they're going to do the right thing for you, versus a decentralized untampered double collective, which one you're gonna choose.

266
00:29:08.124 --> 00:29:11.596
I'm picking the one that can't screw me over every single time.

267
00:29:11.596 --> 00:29:26.496
For every agreement I can apply it to now this technology is relatively new, but we have already seen it relandscaping entire markets and continue to do so the traditional financial world is already getting its lunch eaten by defy or decentralized finance.

268
00:29:26.496 --> 00:29:35.531
There's already over $200 billion of people's money in these protocols to help have a more fair, more accountable, more transparent financial system.

269
00:29:35.531 --> 00:29:43.034
This defy movement is one of the main reasons I got into this space because we desperately need to move away from where we are right now.

270
00:29:43.034 --> 00:29:51.146
And and people's chances for wealth being sucked up by some group that's bending the rules in their favor and smart contracts are our ticket to that better world.

271
00:29:51.146 --> 00:30:06.111
More and more industries are also coming over to smart contracts and blockchain because of all the innovations and because of all the advantages that it has as we grow and as we get better as we get closer to this vision of having this concept fulfilled, trust minimized agreements.

272
00:30:06.180 --> 00:30:12.581
These smart contracts are minimizing the trust that we need to give other people in order for these agreements to be executed.

273
00:30:12.581 --> 00:30:16.948
If trust minimized agreements is too confusing for you just say unbreakable promises.

274
00:30:16.948 --> 00:30:18.961
Now I gotta be honest with you guys.

275
00:30:18.961 --> 00:30:23.708
blockchains and smart contracts and cryptocurrencies can actually do more than just trust, minimize agreements.

276
00:30:23.708 --> 00:30:28.420
They have security benefits, uptime benefits, execution, speed benefits, and a whole lot more.

277
00:30:28.420 --> 00:30:31.445
But it's a lot easier to just learn about one and learn the other ones later, right.

278
00:30:31.445 --> 00:30:33.287
It's kind of like sprinkles on top.

279
00:30:33.287 --> 00:30:34.532
So this is why we are here.

280
00:30:34.532 --> 00:30:41.990
This is why we're building this future and this is why we are so excited about it.

281
00:30:42.184 --> 00:30:45.917
Even in just this introduction part, we've learned a ton.

282
00:30:46.184 --> 00:30:48.748
let's do a quick summary of what we've learned so far.

283
00:30:49.184 --> 00:31:02.501
was the first protocol to take this blockchain technology into the limelight and take these cryptocurrencies into the mainstream Bitcoin is a sort of digital gold or a store of value able to make transactions between users in a decentralized manner.

284
00:31:02.501 --> 00:31:20.224
Aetherium and other smart contract platforms take this blockchain technology one step further, enabling people to make smart contracts and decentralized trust minimized agreements, the smart contracts and decentralized applications can access and interact with the real world using something called decentralized Oracle networks.

285
00:31:20.224 --> 00:31:43.555
chain link is a decentralized network that allows us to build these hybrid smart contracts, which combines our on chain logic with our off chain, decentralized data, and decentralized computation, giving rise to our logic being completely decentralized, and our data and external computation being completely decentralized, giving us all the features that traditional agreements and traditional contracts have.

286
00:31:43.555 --> 00:31:46.567
Now these digital currencies like Aetherium, and Bitcoin have value.

287
00:31:46.567 --> 00:32:01.546
Even without the smart contract part, having a censorship resistant, decentralized store of value is naturally powerful in its own right, we have some links in the GitHub repository that will teach you how this decentralized store of value flips traditional finance on its head.

288
00:32:01.546 --> 00:32:04.159
And it's another one of the great reasons for building smart contracts.

289
00:32:04.192 --> 00:32:09.971
But again, the easiest way to boil it down is trust minimized agreements, or unbreakable promises.

290
00:32:09.971 --> 00:32:14.520
But let's also go into some of these other features that smart contracts have over our traditional environment.

291
00:32:14.520 --> 00:32:17.614
The first feature, of course, is that they are decentralized.

292
00:32:17.614 --> 00:32:23.481
And they have no centralized intermediary, the different individuals that run one of these blockchains are known as node operators.

293
00:32:23.481 --> 00:32:33.304
And it's the combination of all these 1000s of node operators running the same software running these algorithms running these smart contracts that make the network decentralized.

294
00:32:33.304 --> 00:32:35.782
We'll dive deeper into how that works later.

295
00:32:35.782 --> 00:32:40.775
The next feature is transparency and flexibility in these decentralized networks.

296
00:32:40.775 --> 00:32:49.786
Since all these individual node operators run the software, everybody can see everything that's happening on chain, meaning there's no shady deals, there's no weird things happening.

297
00:32:49.786 --> 00:32:59.797
Anything that's going to be unfair, people will be able to see and just not use, everybody has perfect information and has to play by the same rules.

298
00:32:59.797 --> 00:33:10.674
Now additionally, this doesn't mean that there's no privacy, the blockchain is pseudo anonymous, meaning that you aren't necessarily tied to an identity in real life, they also have the feature of speed and efficiency.

299
00:33:10.674 --> 00:33:21.708
For those of you who have ever tried to do a bank transfer or send money across seas, you know, it sometimes can take two to three weeks, when in fact, all these banks are really doing is basic math.

300
00:33:21.708 --> 00:33:26.819
They're subtracting money from your balance and adding it to some other balance.

301
00:33:26.819 --> 00:33:31.733
Why does it take so long, in the blockchain, all of these transactions happen instantly.

302
00:33:31.733 --> 00:33:37.867
Another instance for those in the financial world today know that clearing houses and settlement days can take a long time.

303
00:33:37.867 --> 00:33:42.154
In the blockchain, there's no need for any of that, because they happen instantly.

304
00:33:42.202 --> 00:33:48.155
This obviously is much quicker, but it also makes for much more efficient interactions with each other security and immutability.

305
00:33:48.202 --> 00:33:51.284
Again, immutable means that it can't be changed.

306
00:33:52.203 --> 00:33:59.940
contract is deployed, that's it, whatever is in the code is going to be in the code forever, they cannot be altered or tampered with in any way.

307
00:33:59.940 --> 00:34:02.104
This means that the security is much easier.

308
00:34:02.204 --> 00:34:07.865
Whereas in a centralized world, somebody can hack into the server, jump into the database and change some numbers.

309
00:34:07.865 --> 00:34:09.600
You can't do that in the blockchain world.

310
00:34:09.600 --> 00:34:20.439
And since it's decentralized, in order to hack the blockchain, you'd have to take over half of the nodes as opposed to in the centralized world, where you only have to take over one in the regular world.

311
00:34:20.439 --> 00:34:24.539
If your computer and your backup computer go down, all of your data is gone.

312
00:34:24.539 --> 00:34:34.557
In the blockchain world, if your computer and your backup computer go down, all your data is safe, because it's being run on all these other decentralized nodes.

313
00:34:34.557 --> 00:34:38.400
And even if a few 100 nodes or a few 1000 nodes go down.

314
00:34:38.400 --> 00:34:50.563
It doesn't matter because as long as one node has a copy of the blockchain, you're good to go hacking a blockchain is nearly impossible, and leaps and bounds more difficult than hacking a centralized server.

315
00:34:50.563 --> 00:34:54.099
Not only that, but this is safer in the asset sense as well.

316
00:34:54.099 --> 00:34:59.405
All you need to access your credentials and your information in your assets is your private key.

317
00:34:59.405 --> 00:35:02.618
Which is basically your password for all of this.

318
00:35:02.618 --> 00:35:12.600
And as we've discussed in the video, the smart contracts remove this counterparty risk, remove this centralized intermediary, remove these trust gateways that we have to do in web two.

319
00:35:12.600 --> 00:35:23.703
When we engage with users and individuals, they don't always have our best interests at heart smart contracts, remove this counterparty risk, because once one of these contracts is created, they can't go in and they can't alter it.

320
00:35:23.703 --> 00:35:28.899
And they can't let greed or ego or anything else, get the better of them and alter the terms of the deal.

321
00:35:28.899 --> 00:35:35.503
And as we said, this gives rise to these trust minimized agreements or these programmatic unbreakable promises.

322
00:35:35.503 --> 00:35:53.846
We move away from brand based agreements to math based agreements, where we can look at the cryptography we can look right at the code and see exactly what something is going to do and how it's going to execute, versus having to rely on a human being doing the right thing with smart contracts and decentralized hybrid smart contracts.

323
00:35:53.846 --> 00:36:11.904
Doing the right thing is infrastructural all these pieces boil down to us having the freedom to interact the way we want to interact without having to be afraid that interacting like that is going to screw us over this trust minimized piece, these unbreakable promises, make interactions so much better.

324
00:36:11.904 --> 00:36:21.694
In a purely web two world, we're constantly bombarded with messages of projects and protocols pushing us to move or act in the direction that makes them more profitable.

325
00:36:21.694 --> 00:36:25.237
Versus in the smart contract space, we can see everything transparently.

326
00:36:25.237 --> 00:36:33.589
And we can even engage in interact and be partially owners of the protocols and the interactions that we decide that we want to be a part of.

327
00:36:33.589 --> 00:36:39.695
So smart contracts have been around for a few years now.

328
00:36:39.695 --> 00:36:53.721
And what did they generate for what industries have come about due to these smart contract platforms being around? Well, you've probably heard of some of these and some of these we've already mentioned, but let's give you a quick refresher, d phi d phi stands for decentralized finance.

329
00:36:53.721 --> 00:36:59.484
And it gives users the ability to engage with finance and markets without having to go through a centralized intermediary.

330
00:36:59.484 --> 00:37:09.052
For example, like we said, with Robin Hood, you no longer have to trust that Robin Hood would continue to give you access to the markets, you instead would be able to see in the smart contract.

331
00:37:09.052 --> 00:37:12.409
Yes, I have access to the markets or in the 2008 financial crisis.

332
00:37:12.409 --> 00:37:17.889
You never have to trust that these groups and institutions are giving you the correct things on the back end.

333
00:37:17.889 --> 00:37:29.442
You can see everything transparently right on the blockchain, you can engage with things like money markets and sophisticated financial products easy effectively and securely at the time of recording.

334
00:37:29.442 --> 00:37:34.587
defi has around $200 billion in assets under management and is quickly growing.

335
00:37:34.587 --> 00:37:40.744
If you're really excited about defy we have a ton of defy examples showing you how to build and interact with these protocols.

336
00:37:40.744 --> 00:37:41.782
In coming lessons.

337
00:37:41.782 --> 00:37:43.051
Dows or decentralized.

338
00:37:43.226 --> 00:37:46.716
autonomous organizations are another group that we've already mentioned.

339
00:37:46.716 --> 00:37:52.734
Dows are groups that are governed completely decentralized by a set of instructions or smart contracts on chain.

340
00:37:52.734 --> 00:37:56.678
There are some massive benefits here where engagement is much easier.

341
00:37:56.678 --> 00:37:57.645
The rules are black and white.

342
00:37:57.645 --> 00:38:10.657
And you can see everything directly on chain voting and governance technologies completely decentralized in the blockchain space is one of the big ones pushing how we can evolve politics and how we can evolve governance to make it more efficient, fair and reasonable.

343
00:38:10.657 --> 00:38:15.990
And you better know it, we have some examples of how to build Dows and how to work with Dows incoming lessons.

344
00:38:15.990 --> 00:38:27.622
So be sure to watch those NF T's Stanford non fungible tokens and can really be kind of described as digital art or just a unique asset, they can do so much more, but we'll keep it high level for now.

345
00:38:27.622 --> 00:38:35.431
Projects like board apes and crypto punks have revolutionized the way that people get paid for their work, show off their creativity, status, and so much more.

346
00:38:35.431 --> 00:38:45.477
And yes, of course, we have lessons showing you how to create and interact with NF T's as well, so many other groups and so many other industries are being created as a result of this insane technology.

347
00:38:45.477 --> 00:38:55.648
And maybe after finishing the journey with us here, you go out and you'd be the one to pioneer the next industry or the next billion dollar idea you've learned so much already.

348
00:38:55.648 --> 00:39:06.934
But now that we've learned a lot of this high level information, let's finally jump in, and let's make your first transaction and let's get you set up to interact with this new world.

349
00:39:06.934 --> 00:39:15.409
In this next section, we're going to get you a wallet and we're going to show you exactly what a transaction looks like and feels like.

350
00:39:15.409 --> 00:39:17.186
Let's dive in.

351
00:39:17.186 --> 00:39:21.350
This is the Aetherium website aetherium.

352
00:39:21.350 --> 00:39:28.736
org We are going to make a transaction on a test Aetherium blockchain I'll explain what that means in a little bit.

353
00:39:28.736 --> 00:39:32.374
This is going to be our first transaction that's made on the blockchain.

354
00:39:32.374 --> 00:39:41.796
Now again, this process that we're going to follow is going to work the exact same with polygon, avalanche Phantom and all these other EVM compatible blockchains.

355
00:39:41.796 --> 00:39:43.932
I'll explain what that means in a bit too.

356
00:39:43.932 --> 00:39:49.327
For now, just follow along and have fun in order to make a transaction on any of these blockchains.

357
00:39:49.327 --> 00:39:53.931
The first thing that we need to do is we need to set up a wallet.

358
00:39:53.931 --> 00:40:01.419
So I'm gonna go ahead and go to meta mask because it's one of the most popular wallets and one of the easiest to Use, we're going to go ahead and download it.

359
00:40:01.419 --> 00:40:06.901
I'm using the brave browser, but it works for Chrome, Firefox or really any other browsers.

360
00:40:06.901 --> 00:40:12.016
And it's just going to be a little extension in the top right hand of your browser.

361
00:40:12.016 --> 00:40:19.346
This way, we can really easily see it any times what we have in our wallet, will still are all of our Aetherium based currencies.

362
00:40:19.346 --> 00:40:25.592
So I'm gonna go ahead and install meta mask for brave, add to brave, add extension.

363
00:40:25.592 --> 00:40:35.105
And now we can go ahead and get started with working with Brave, this is the first step you absolutely need to take when starting your journey and one of the easiest steps to take.

364
00:40:35.105 --> 00:40:36.734
So we're gonna go ahead and get started.

365
00:40:36.734 --> 00:40:39.891
And we're going to create a brand new wallet.

366
00:40:39.891 --> 00:40:41.692
So we're gonna go ahead and hit create wallet.

367
00:40:41.692 --> 00:40:50.044
If you already have a wallet, you can actually import it via I have a seed phrase, and we'll talk about the seed phrase or secret phrase in a little bit.

368
00:40:50.044 --> 00:40:52.844
So let's go ahead and create a new wallet.

369
00:40:52.844 --> 00:40:59.148
And sure, we'll agree to help out Metamask now we will create our password make sure that this is really secure.

370
00:40:59.148 --> 00:41:02.987
For the purpose of this demo, my passwords are just gonna be password.

371
00:41:02.987 --> 00:41:05.229
But please don't have that be your password.

372
00:41:05.229 --> 00:41:08.633
You may also get a video like this teaching you about your secret recovery phrase.

373
00:41:08.633 --> 00:41:11.278
This is the same thing as your pneumonic.

374
00:41:11.278 --> 00:41:14.983
But see your recovery phrase is a lot more clear as to what it is.

375
00:41:14.983 --> 00:41:19.591
And again, to give us a ton of different tips on how to actually store it and keep it safe.

376
00:41:19.591 --> 00:41:24.041
The main takeaway from this is never shared this absolutely never shared this.

377
00:41:24.041 --> 00:41:27.903
So we're going to go ahead and click reveal secret words.

378
00:41:27.903 --> 00:41:32.048
I'm showing you guys here because this is just a demo and I don't really care.

379
00:41:32.048 --> 00:41:38.827
However, if you show this secret phrase to anybody else, they will have access to all the funds in your application.

380
00:41:38.827 --> 00:41:46.020
So everything that we're going to do in this tutorial, we're going to use fake money, we're going to use not real money, so it doesn't matter.

381
00:41:46.020 --> 00:41:53.573
Now for the purposes of testing and developing, I always recommend using a completely separate meta mask, a completely separate Wallet.

382
00:41:53.573 --> 00:42:06.216
So for going throughout this entire course, if you already have a wallet, or if you already have a meta mask, please just set up a new one, create a new profile, create a new meta mask, and this will be your wallet that you use for the duration of this course.

383
00:42:06.252 --> 00:42:10.690
However, if you're going to actually put money in here, you absolutely need to have this written down.

384
00:42:10.690 --> 00:42:19.318
Because if you lose access to this, and all your private keys, which we'll talk about in a little bit, you will lose access to your wallet, and you will lose access to all your funds.

385
00:42:19.318 --> 00:42:40.058
So they give some tips like store this phrase and a password manager like one password, write this phrase down on a piece of paper, put it in a secure location, memorize it, whatever you want to do, just make sure you have this backed up somewhere, I'm just gonna go ahead and hit download this for now, it's not best practice to save to your computer, it is much better to use a password manager or write it down on a piece of paper or something.

386
00:42:40.058 --> 00:42:42.492
So we're gonna go ahead and hit next.

387
00:42:42.492 --> 00:42:47.927
And it's going to ask us to verify that we actually have it written down.

388
00:42:47.927 --> 00:42:52.725
And we're gonna go ahead and hit confirm, and great and gives us a couple other tips.

389
00:42:52.725 --> 00:42:57.843
Remember, definitely take these tips very seriously, especially if you're gonna use this for real money.

390
00:42:57.843 --> 00:43:00.835
Like I said, For this demo, we're just going to use test money.

391
00:43:00.835 --> 00:43:02.348
So it's not as big of a deal.

392
00:43:02.348 --> 00:43:10.758
But if you put real money in, you absolutely need to backup this seed phrase or secret phrase or we're going to refer to it as our pneumonic phrase.

393
00:43:10.758 --> 00:43:11.158
Awesome.

394
00:43:11.258 --> 00:43:15.868
Now we can see the interface of our wallet here full screen.

395
00:43:16.259 --> 00:43:36.209
depending on your browser, you can actually come up and pin it to your browser so that you can just click it up in the top right, and it'll drop down and you can see the same interface here our pneumonic phrase that secret phrase, those that secret 12 words that they gave us have given us access to a new account, the address of our account is located right here.

396
00:43:36.261 --> 00:43:49.612
In fact, if we click it and copy it to our clipboard, and go to a tool called a block explorer called ether scan, we can actually paste our address in here and see details about our account.

397
00:43:49.612 --> 00:43:52.631
Ether scan, like I said, is what's known as a block Explorer.

398
00:43:52.631 --> 00:43:58.339
And it's a way to view different addresses transactions and other happenings that happen with a blockchain.

399
00:43:58.339 --> 00:44:06.197
If we look at this address that we just created on ether scan for Etherium main net, we can see no transactions have happened.

400
00:44:06.264 --> 00:44:22.511
There's really no analytics, there's no comments, there's no balance, there's no value, because it's a brand new wallet, and this address that we just punched into ether scan represents our unique address our unique wallet only identifiable for us.

401
00:44:22.511 --> 00:44:33.097
We'll talk about ether scan a little bit more in a bit because it's a tool that we're going to use quite often in wallets like meta mask, you can actually even click right here and create even more accounts.

402
00:44:33.097 --> 00:44:36.608
So let's go ahead and create a new account.

403
00:44:36.608 --> 00:44:41.017
We'll call this account two.

404
00:44:41.267 --> 00:44:43.750
As you can see, this one has a different address.

405
00:44:44.268 --> 00:44:47.493
click this one, we go back to ether scan.

406
00:44:49.268 --> 00:44:49.719
in here.

407
00:44:49.719 --> 00:44:50.557
We hit Enter.

408
00:44:53.269 --> 00:44:55.869
uniquely identifiable to us, right here.

409
00:44:57.269 --> 00:45:05.746
no value, no transactions now If we go back to our Metamask, and we click the little button, we can see we have two different accounts in here, it's the same.

410
00:45:05.746 --> 00:45:11.879
If we hit the extension in the top right, click the button, we have two different accounts.

411
00:45:11.879 --> 00:45:19.660
The 12 word secret recovery phrase allows us to create multiple accounts, all with the same secret recovery phrase.

412
00:45:19.660 --> 00:45:33.415
So that secret recovery phrase will give us access to both account one and account two and any other accounts that we create by hitting this Create Account button, because it gives you access to all the accounts in your meta mask.

413
00:45:33.415 --> 00:45:44.416
Now, these addresses of both of our accounts are the public unique identifiers, but they also have a private unique identifier only identifiable to us.

414
00:45:44.416 --> 00:45:55.024
Similar to the pneumonic, these are private identifiers we never want to share and we never want to give out their private This is known as your accounts private key.

415
00:45:55.024 --> 00:46:10.534
So the mnemonic will give you access over many of these accounts, the private key will give you access to just one of these accounts, we can see it by hitting these little three dots, going to account details and export private key, you'll just have to punch in your password here.

416
00:46:10.534 --> 00:46:13.292
And you'll be able to see your private key.

417
00:46:13.292 --> 00:46:22.623
This is going to be your private key for your account, you can think of your private key as a password for your account that lets you create transactions.

418
00:46:22.623 --> 00:46:27.228
Now the reason that I'm showing mine on screen is because I'm not going to put any real money in here.

419
00:46:27.228 --> 00:46:30.563
And this is just going to be a burner account for this tutorial.

420
00:46:30.563 --> 00:46:36.985
And I highly recommend once again, you use a burner account, you use accounts that you never put any real money into.

421
00:46:36.985 --> 00:46:41.326
And along the way, I'll show you how to make sure that you don't do that.

422
00:46:41.326 --> 00:46:53.205
But normally, it's not a good idea to show or share your private keys or your secret recovery phrase, if somebody gets a hold of this private key, they will have access to my account one.

423
00:46:53.281 --> 00:47:01.789
However, they won't have access to my account to if they get a hold of my 12 word recovery phrase or pneumonic they'll have access to both accounts.

424
00:47:01.789 --> 00:47:13.088
And this is why when people say keep your private keys safe, your keys, your Bitcoin, your keys, your Aetherium, they're talking about both your mnemonics or your secret recovery phrases.

425
00:47:13.088 --> 00:47:18.444
And your private keys keep those private, your public addresses are totally public.

426
00:47:18.444 --> 00:47:23.133
And anybody can view your accounts on something like ether scan, or any other explore.

427
00:47:23.133 --> 00:47:26.348
And it's totally okay for people to share their public addresses.

428
00:47:26.348 --> 00:47:29.735
If you lose your private key, you lose access to one of your accounts.

429
00:47:29.735 --> 00:47:33.704
If you lose your mnemonic, you could potentially lose access to all your accounts.

430
00:47:33.704 --> 00:47:42.737
Basically, what I'm trying to say is back these up and keep them in safe places for this course it's okay if you lose one, since we're not putting any real money in them.

431
00:47:42.737 --> 00:47:44.630
But in the real world, be sure to do this.

432
00:47:44.630 --> 00:47:44.974
And great.

433
00:47:44.974 --> 00:47:47.176
Those are some of the main security considerations here.

434
00:47:47.176 --> 00:47:57.429
Now, if you look up in the top right, right next to that account button that we've been clicking, you also see this thing saying Etherium main net, this is our networks tab.

435
00:47:57.429 --> 00:48:07.158
And if we click it, we can see a list of all the different networks that we currently have access to a Etherium main net is the main network of Aetherium.

436
00:48:07.158 --> 00:48:11.196
And this is where real money is spent and used for transactions.

437
00:48:11.196 --> 00:48:17.592
For this course, we're not going to be working with the Etherium main net, we're instead going to be working with something called a test net.

438
00:48:17.592 --> 00:48:25.401
Since we're engineers, oftentimes, we're going to want to test and see what our code is actually going to do and how to interact with it.

439
00:48:25.401 --> 00:48:32.725
We're going to use a combination of local networks and test networks to actually do this to actually test our smart contracts.

440
00:48:32.725 --> 00:48:34.709
We're mainly going to use local networks.

441
00:48:34.709 --> 00:48:45.046
But we'll get to that in a little bit to see some of the test networks that come default with meta mask, we hit show slash hide test networks, this will bring us into the settings page.

442
00:48:45.046 --> 00:48:48.050
And we just hit select this to show test networks in the list.

443
00:48:48.050 --> 00:48:55.467
And we just hit on Now if we scroll back up, we'll close out of the settings, we hit the network's tab again.

444
00:48:55.467 --> 00:49:01.682
Now we can see all of these other networks here like ropsten, Koven, Rinkeby, and Garelli.

445
00:49:01.682 --> 00:49:09.372
These test networks or networks that resemble Aetherium, or polygon, or Avalanche or phantom or any of these other blockchains.

446
00:49:09.372 --> 00:49:13.169
And we can actually switch our accounts to one of these other test networks.

447
00:49:13.169 --> 00:49:18.095
Let's click rink B, for example, we can see that on the Rinkeby test network.

448
00:49:18.095 --> 00:49:24.224
We also have zero Aetherium we have no money or nothing in here, we have a blank Rinkeby wallet.

449
00:49:24.224 --> 00:49:30.542
These test nets work nearly identical to how Aetherium main networks except for they run with not real money.

450
00:49:30.542 --> 00:49:38.916
They run with fake money as a way for us to learn and interact and see how these different smart contracts actually work together at the time of filming.

451
00:49:38.916 --> 00:49:43.035
rink B is one of the most popular test networks along with COVID.

452
00:49:43.035 --> 00:50:00.594
So we're going to work a lot with Rigby In this tutorial, however, be absolutely sure to check our GitHub repository to make sure that you're always up to date with the best test network for following along with the tutorial here since their test networks people are running them out of the goodness of their hearts.

453
00:50:00.594 --> 00:50:05.574
And sometimes the best ones actually change so, so be sure to follow along with the GitHub repository.

454
00:50:05.574 --> 00:50:09.610
We might also use COVID From time to time or maybe even Grilli.

455
00:50:09.610 --> 00:50:12.490
So we're going to show you how to use a couple of these different test nets.

456
00:50:12.490 --> 00:50:19.651
In fact, if we go to the GitHub repo associated with this course, we can see recommended test net is indeed currently ranking.

457
00:50:19.651 --> 00:50:25.252
So that's what we're going to work with should this change, you should be able to follow along with another test.

458
00:50:25.302 --> 00:50:27.349
And we'll leave notes as to how to continue.

459
00:50:28.302 --> 00:50:40.793
actually is we can go to Rigby ether scan, we can go to, you can look up Rinku ether scan, and it looks like it's the first thing that shows up Rinkeby dot ether scan.

460
00:50:40.793 --> 00:50:46.123
io, we can punch in this same address, copy and paste it.

461
00:50:46.123 --> 00:50:50.526
And we can see some of the details of this address on the Rinkeby ether scan.

462
00:50:50.526 --> 00:50:52.915
Like I said, right now, it's totally blank.

463
00:50:52.915 --> 00:51:00.680
This networks interface later on is also how we're going to be able to work with polygon, avalanche, etc, we'll just have to add networks.

464
00:51:00.680 --> 00:51:02.133
But we'll get to that in a bit.

465
00:51:02.133 --> 00:51:10.368
And just to reiterate, test nets are free and for testing our smart contracts and main net networks cost money and are considered live.

466
00:51:10.368 --> 00:51:17.612
Now I also do want to put a caveat here that we do want to keep in mind that these test nets are being run at the goodness of people's hearts.

467
00:51:17.612 --> 00:51:21.671
So we don't want to abuse them, we want to use them to learn and then move on.

468
00:51:21.671 --> 00:51:25.240
So try not to send a billion transactions on one of these test nets.

469
00:51:25.240 --> 00:51:31.325
In fact, what we're going to do right now is we're going to send a transaction on the Rinkeby test net.

470
00:51:31.325 --> 00:51:35.176
And this will show us exactly what it would look like on a main network.

471
00:51:35.176 --> 00:51:40.697
In order for us to simulate one of these transactions, we're going to go to what's called a faucet.

472
00:51:40.697 --> 00:51:55.214
And if you go to the GitHub repository associated with this course, right underneath the recommended test net is going to be a test net faucets, which is going to show us where the most up to date faucet location is for us getting test net Aetherium.

473
00:51:55.214 --> 00:52:07.921
So here we are at faucets dot chain dot link, which again is the recommended faucet, and what we can do is we can actually put our wallet address in and get some test net link or test net Aetherium.

474
00:52:07.921 --> 00:52:13.278
Now what we are gonna have to do is we are gonna have to connect our wallet to the Rinkeby network.

475
00:52:13.278 --> 00:52:19.640
So we're going to come down, we're going to switch from COVID to Etherium.

476
00:52:19.640 --> 00:52:25.867
Rigby, and then we're going to make sure our meta mask is on the Rinkeby test network here.

477
00:52:25.867 --> 00:52:30.147
Once both of those are set up, we're gonna go ahead and hit Connect wallet.

478
00:52:30.147 --> 00:52:33.147
And we're going to choose meta mask.

479
00:52:33.315 --> 00:52:46.265
Once we do that, our meta mask is actually going to pop up and say would you like to connect to this website, connecting to a website is how we give these websites in interface to interact with our wallets and interact with our meta masks.

480
00:52:46.316 --> 00:52:50.594
Don't worry, we're not sending any transactions like this, we'll get to that in a bit.

481
00:52:50.594 --> 00:52:53.423
So we just we can pick an account we want to connect.

482
00:52:53.423 --> 00:52:56.192
Let's choose our account one, we'll hit Next.

483
00:52:57.317 --> 00:52:59.375
And then we'll go ahead and connect.

484
00:53:00.317 --> 00:53:04.252
connected, we can actually see our account connected up here.

485
00:53:04.318 --> 00:53:06.011
And that little warning is now gone.

486
00:53:07.318 --> 00:53:11.697
automatically placed into here, we're going to make our first test transaction.

487
00:53:11.697 --> 00:53:14.887
And for now, we don't need test link.

488
00:53:14.887 --> 00:53:16.302
So we're going to leave that off.

489
00:53:16.302 --> 00:53:18.974
But later on, we're going to come back and get that test link.

490
00:53:18.974 --> 00:53:21.652
For now we're just going to need 0.

491
00:53:21.652 --> 00:53:24.022
1 test Aetherium.

492
00:53:24.320 --> 00:53:28.223
So let's go ahead and complete the security by choosing the traffic lights.

493
00:53:28.223 --> 00:53:30.545
And we're going to hit Send Request.

494
00:53:30.545 --> 00:53:36.643
What this is going to do is we're asking this faucet to send us 0.

495
00:53:36.643 --> 00:53:42.660
1 test Aetherium test net faucets are ways for us to get money into our wallets on a test net.

496
00:53:42.660 --> 00:53:46.131
And this is why this test and Aetherium isn't worth any actual money.

497
00:53:46.131 --> 00:53:47.612
Since we can get it for free.

498
00:53:47.612 --> 00:53:54.497
These don't exist on Main net, you can't get real Aetherium or real money for free on a main network.

499
00:53:54.497 --> 00:53:57.723
So we're on Rinkeby we're getting fake Rinckey Aetherium.

500
00:53:57.723 --> 00:53:59.643
And we're gonna go ahead and hit send request.

501
00:53:59.643 --> 00:54:08.137
Once we hit Send Request, this transaction hash is going to pop up here, and it says transactions have been initiated waiting for confirmation.

502
00:54:08.137 --> 00:54:12.449
This means that some other wallet is actually going to send us 0.

503
00:54:12.449 --> 00:54:13.136
1 test eath.

504
00:54:13.136 --> 00:54:21.825
And this is the transaction that it's doing to do that now we just have to wait for our transaction to finish verifying and finish going through.

505
00:54:21.825 --> 00:54:25.584
Now if this doesn't work right away, I would recommend Wait a minute and then just try it again.

506
00:54:25.584 --> 00:54:28.680
But what we can do is we can click this transaction hash.

507
00:54:28.680 --> 00:54:32.850
If that transaction doesn't show up, we can also just close this.

508
00:54:32.850 --> 00:54:34.945
And we can copy our address here.

509
00:54:34.945 --> 00:54:36.889
And actually we already see 0.

510
00:54:36.889 --> 00:54:38.514
1 eath in our wallets here.

511
00:54:38.514 --> 00:54:46.629
But we can go back over to Rinkeby ether scan, paste our address and and we can see that we now have 0.

512
00:54:46.629 --> 00:54:48.216
1 ether as a balance.

513
00:54:48.216 --> 00:54:54.079
We can also see that we have a transaction with all this information going into our wallet.

514
00:54:54.079 --> 00:54:55.579
That's what this green is for.

515
00:54:55.579 --> 00:55:08.710
If you click that transaction link, you'd get something like this, but If you didn't, don't worry, because on the ether scan, if you click the transaction hash in the transaction list, you can also see all the details like that.

516
00:55:08.710 --> 00:55:10.422
So now in our meta mask, we have 0.

517
00:55:10.422 --> 00:55:10.977
1 eath.

518
00:55:10.977 --> 00:55:13.755
Again, this is fake Aetherium.

519
00:55:13.755 --> 00:55:18.281
And we have a transaction associated with our wallet now, which is awesome.

520
00:55:18.331 --> 00:55:26.568
Again, though, if we switch networks, if we switch networks back to Etherium main net, you can see that we have nothing on a theory main net.

521
00:55:26.568 --> 00:55:31.332
Or if we go to ropsten, we also have nothing, we only have this 0.

522
00:55:31.332 --> 00:55:31.760
1 eath.

523
00:55:31.760 --> 00:55:39.871
On the Rinkeby test network, if you want to practice working with another test net, and the faucet that we're using, has multiple test nets.

524
00:55:39.871 --> 00:55:45.851
Let's go ahead and try it during this section right now is completely optional, you can watch or you can follow along.

525
00:55:45.851 --> 00:55:51.873
But for example, I can see in my wallet that we already have COVID supported, so maybe I'll switch to COVID.

526
00:55:51.873 --> 00:55:53.691
Maybe we'll switch to COVID.

527
00:55:53.691 --> 00:55:59.270
In the drop down here, we'll remove test 10 Link, because we only need test eath.

528
00:55:59.270 --> 00:56:07.336
We'll hit I'm not a robot, and we'll send request and the same things will pop up this time, this is going to be for the COVID test net.

529
00:56:07.336 --> 00:56:10.224
And once our transaction finishes going through.

530
00:56:10.224 --> 00:56:11.630
Now, same thing on COVID.

531
00:56:11.630 --> 00:56:17.523
Here, like what we did with rink B, once our transaction finishes going through, we'll see 0.

532
00:56:17.523 --> 00:56:23.613
1 test eath on the COVID network, if you want to go ahead and try working with another one of the test nets.

533
00:56:23.613 --> 00:56:27.820
Like maybe, for example COVID recommend you go ahead and giving it a try.

534
00:56:27.820 --> 00:56:29.228
But it's completely optional.

535
00:56:29.228 --> 00:56:34.993
And I would always refer back to the GitHub repo to make sure you're working with the most up to date faucet and test net.

536
00:56:34.993 --> 00:56:41.271
And if we look back at ether scan, we can actually see more details on what actually just took place.

537
00:56:41.339 --> 00:56:45.540
What actually just happened, how did our Metamask get a balance of 0.

538
00:56:45.540 --> 00:56:45.840
1 eath.

539
00:56:45.840 --> 00:56:55.086
All of a sudden? Well, if we looked down in the transaction section, we can see that there's a transaction here, some address sent us 0.

540
00:56:55.086 --> 00:56:55.641
1 ether.

541
00:56:55.641 --> 00:57:03.409
And if we click the transaction hash, we can see more details about what actually went down with this transaction.

542
00:57:03.409 --> 00:57:12.135
Now understanding what's going on in this transaction is essential to learning and being a smart contract developer or just engaging with the ecosystem.

543
00:57:12.135 --> 00:57:16.278
So let's learn the first bit at the top is this transaction hash.

544
00:57:16.343 --> 00:57:23.379
This is a unique identifier for this blockchain or this test net that identifies this exact transaction.

545
00:57:23.379 --> 00:57:27.078
This transaction hash identifies sending 0.

546
00:57:27.078 --> 00:57:34.297
1 eath to our address, we can see that the status of this transaction was successful, it didn't break.

547
00:57:34.345 --> 00:57:56.474
In any case, we can see the block number that this transaction was included in and we'll get to blocks in a little bit, we can see the timestamp which of course is when this transaction occurred, we can see which account it was from which if we go ahead and open in a new tab, we can see that this is the account that this transaction came from.

548
00:57:56.474 --> 00:57:58.228
And it's got 3 million ether.

549
00:57:58.228 --> 00:58:00.804
Of course, this is fake Rinckey ether.

550
00:58:00.804 --> 00:58:06.048
So it doesn't really matter, we can all see who it was to, which again, is just us.

551
00:58:06.048 --> 00:58:17.478
This is our wallet address 0x 106 X blah, blah, blah, cero x 1066, blah, blah, blah, right, the value of this transaction, of course, is 0.

552
00:58:17.478 --> 00:58:17.929
1 ether.

553
00:58:17.929 --> 00:58:22.188
Now what's all this that we see as the value so obviously, the value is 0.

554
00:58:22.188 --> 00:58:23.695
1, because that's a mode which we sent.

555
00:58:23.695 --> 00:58:25.482
But we see this transaction fee.

556
00:58:25.482 --> 00:58:35.017
In this gas price, we hover over the tooltip, we can see if you zoom in on your ether scan, you see amount paid to the miner for processing the transaction.

557
00:58:35.017 --> 00:58:42.023
And we see a gas price which is cost per unit of gas specified for the transaction and ether and gray.

558
00:58:42.023 --> 00:58:45.844
The higher the gas price, the higher the chance of getting included in the block.

559
00:58:45.844 --> 00:58:51.902
Now if we scroll down even more, and we click See more, we can also see a ton of other information here.

560
00:58:51.902 --> 00:58:56.209
For now we're just going to click to see less and just focus on these two.

561
00:58:56.209 --> 00:59:01.210
I'll explain all of these in a later session.

562
00:59:01.353 --> 00:59:05.708
Let's talk about just the concept of transaction fees and gas for a second.

563
00:59:05.708 --> 00:59:34.291
Remember how I said the blockchain is run by all these different nodes will all those different nodes are running this blockchain because they actually get paid for all the transactions that happen on these blockchains whenever you make a transaction, there's a node or a miner or or a validator somebody running the blockchain software is gonna get paid a tiny bit of Aetherium or polygon or whatever blockchain that you're running on, they're gonna get paid a tiny bit of that native blockchain currency.

564
00:59:34.357 --> 00:59:43.641
This payment is obviously to incentivize people to continue to run nodes and they calculate how much you pay and how much the node operators get paid based off of how much gas you use.

565
00:59:43.641 --> 00:59:46.565
So there's this concept of gas.

566
00:59:46.565 --> 00:59:49.691
Gas is a unit of computational measure.

567
00:59:49.691 --> 00:59:54.703
The more computation a transaction uses, the more gas you'd have to pay for.

568
00:59:54.703 --> 00:59:58.326
For example, we do hit click More just really quickly.

569
00:59:58.326 --> 01:00:10.693
We can see this section say A gas limit and gas usage by transaction, there was a limit of 60,000 units of gas on this transaction, and 21,000 or actually use.

570
01:00:10.693 --> 01:00:15.138
So this transaction use 21 units of gas.

571
01:00:15.361 --> 01:00:20.581
Now for very simple things like sending ether, the units of gas are usually pretty cheap.

572
01:00:20.581 --> 01:00:31.813
But maybe for more complex things like like minting NFT, depositing to some defy contract, etc, maybe those will cost more gas because they'll be more computationally expensive.

573
01:00:31.813 --> 01:00:34.632
And this is a little confusing right now, don't worry too much about it.

574
01:00:34.632 --> 01:00:36.608
But just know that we use 21,000 gas here.

575
01:00:36.608 --> 01:00:49.697
And if we pull out the calculator 21,000 gas times this gas price right here, times the gas price, we get the exact same as we see for the transaction fee.

576
01:00:49.697 --> 01:00:55.042
So gas price, times how much gas you used, is the transaction fee.

577
01:00:55.042 --> 01:00:58.459
So whoever sent us this 0.

578
01:00:58.459 --> 01:01:01.271
1 ether, also paid 0.

579
01:01:01.271 --> 01:01:05.917
0000525, etc Rinkeby ether to make this transaction.

580
01:01:05.917 --> 01:01:11.604
Now, each blockchain has a different way of actually calculating how this gas stuff works.

581
01:01:11.604 --> 01:01:14.128
So that's basically going to be the high level of it.

582
01:01:14.128 --> 01:01:17.142
So we're going to focus just here for now there's a total transaction fee.

583
01:01:17.142 --> 01:01:19.262
And then there's obviously the gas price.

584
01:01:19.367 --> 01:01:24.899
After we cover how blockchain works, I'll explain what this burn stuff is these gas fees and all these other stuff.

585
01:01:24.899 --> 01:01:31.816
For now, just know that anytime you make a transaction on chain, you have to pay a little bit of what I call transaction gas.

586
01:01:31.816 --> 01:01:37.920
So for example, if we go to our Metamask, we have two accounts right here, we have account one was 0.

587
01:01:37.920 --> 01:01:41.742
1, Rinckey eath, and account two was zero.

588
01:01:41.742 --> 01:01:42.453
Rigby.

589
01:01:42.453 --> 01:01:44.826
If I were to send 0.

590
01:01:44.826 --> 01:01:46.641
05 Rinckey eath.

591
01:01:46.641 --> 01:01:59.518
From this account to my other account, how much rinky eath Do you think I'd have left? Well, let's go ahead and try it, this will be the first transaction that you're actually creating that you are going to spend the gas for.

592
01:01:59.518 --> 01:02:03.320
So if we go ahead and hit send, we'll hit transfer between my accounts.

593
01:02:03.371 --> 01:02:06.731
count two, we'll do 0.

594
01:02:07.372 --> 01:02:23.560
Next, we can see some information here about what's actually going on Metamask has some new advanced gas for UI and settings, we're also going to turn the song, so go ahead and click that enable enhanced gas UI, turn that on, and then go back.

595
01:02:23.560 --> 01:02:26.596
And again, this is going to be the experimental tab.

596
01:02:26.596 --> 01:02:28.729
But it could also just be in the General Settings tab.

597
01:02:28.729 --> 01:02:32.324
Depending on when you actually run this, we can see a little notification here.

598
01:02:32.374 --> 01:02:35.324
Again, this depends on what version of Metamask we're using.

599
01:02:35.375 --> 01:02:40.812
And we get this little drop down that says Here are some of the different type of gas fees that you can actually pay.

600
01:02:40.812 --> 01:02:47.991
The reason that gas fees might change, as you can see here is that depending on how busy the blockchain is, you have to pay more gas.

601
01:02:47.991 --> 01:02:56.043
If a lot of people are sending transactions, that means there's not going to be enough space for everyone's transaction to get through.

602
01:02:56.043 --> 01:02:58.672
That's a bit of an oversimplification of what's happening.

603
01:02:58.672 --> 01:03:00.049
But don't worry too much about it for now.

604
01:03:00.049 --> 01:03:01.777
Now, if we want to send the 0.

605
01:03:01.777 --> 01:03:10.711
05 ether to our second account, we can see this gas estimated section, which is saying it's estimating, we're going to pay 0.

606
01:03:10.711 --> 01:03:15.445
00004792 gas in addition to sending the 0.

607
01:03:15.445 --> 01:03:15.845
5 eath.

608
01:03:15.845 --> 01:03:18.911
So at the bottom, we have amount plus gas fee.

609
01:03:18.911 --> 01:03:24.379
And this is going to be the total amount that we're going to be spending on this transaction 0.

610
01:03:24.379 --> 01:03:25.979
05 is what we're sending.

611
01:03:25.979 --> 01:03:28.094
And we also have this gas piece.

612
01:03:28.094 --> 01:03:34.312
So we go ahead and confirm, we now see we have a transaction pending in our Rigby ether scan.

613
01:03:34.381 --> 01:03:39.300
And if we click on it, we can even hit View on block Explorer.

614
01:03:39.381 --> 01:03:49.818
And a Rigby transaction hash will pop up and depending on when you click it, it might say indexing, this means that ether scan has received your transaction and is trying to place it.

615
01:03:49.818 --> 01:03:53.858
If you don't see anything here, it means that maybe the transaction hasn't gone through yet.

616
01:03:53.858 --> 01:03:55.592
Maybe you need to wait a little bit more.

617
01:03:55.592 --> 01:04:00.683
Or maybe you need to go back to the GitHub repo and pick the recommended testament and faucet.

618
01:04:00.683 --> 01:04:04.544
So you might have to wait a minute or so for this to actually finish indexing.

619
01:04:04.544 --> 01:04:08.112
After a minute or so we can see that this transaction has indeed passed.

620
01:04:08.112 --> 01:04:13.465
And we can see a lot of the same information that we saw on our last one, this time with 0.

621
01:04:13.465 --> 01:04:14.120
05 ether.

622
01:04:14.120 --> 01:04:20.079
And now if we look in our meta mask, we'll see we can see account one has 0.

623
01:04:20.079 --> 01:04:24.489
05 It's rounding up a little bit, we click on the big button, we can see it actually has 0.

624
01:04:24.489 --> 01:04:25.626
049953, etc.

625
01:04:25.626 --> 01:04:31.089
And our other account account two does have exactly 0.

626
01:04:31.089 --> 01:04:31.245
05.

627
01:04:31.245 --> 01:04:37.387
This is because we spent a little bit of Aetherium on gas to send this transaction.

628
01:04:37.387 --> 01:04:48.120
And now with just this little bit of information, you know how to actually interact with applications that use the blockchain, how to send transactions and a lot of the non technical details.

629
01:04:48.120 --> 01:04:51.888
Now here's something that's incredibly exciting with just this little bit of information.

630
01:04:51.888 --> 01:04:56.188
You now know how to interact with blockchains and interact with the Etherion protocol.

631
01:04:56.188 --> 01:05:04.478
So if you don't want to learn how to code anything, you can go If you can start interacting with Aetherium and interact with protocols with just as much information.

632
01:05:04.478 --> 01:05:07.898
However, I know most of you guys are here to learn how to code.

633
01:05:07.898 --> 01:05:09.675
So let's look under the hood of Aetherium.

634
01:05:09.675 --> 01:05:14.123
And what is actually going on with these transactions, and what these gas and what these blockchains.

635
01:05:14.123 --> 01:05:18.373
And what's really going on, let's learn all the fundamentals of a blockchain.

636
01:05:18.373 --> 01:05:23.845
Now, if you want to just go ahead and jump into the coding, go ahead and grab a timestamp from the description.

637
01:05:23.845 --> 01:05:29.292
However, learning exactly how the blockchain works is going to make you an incredibly powerful developer.

638
01:05:29.392 --> 01:05:31.958
So let's take a look at that first.

639
01:05:33.393 --> 01:05:36.344
be going through this blockchain demo on this site right here.

640
01:05:36.393 --> 01:05:42.468
Now, the creator of the site has a fantastic video and a fantastic walk through blockchain one on one, it is right on their site.

641
01:05:42.468 --> 01:05:47.699
So if you're looking for another explanation, definitely check out his video, it is absolutely fantastic.

642
01:05:47.699 --> 01:06:00.733
But the first thing that we really need to do in order to understand blockchain or just on really anything, and everything that's going on here working first really need to understand this Sha 256, hash, or hashing just kind of in general, let's first understand what a hash is.

643
01:06:00.733 --> 01:06:10.486
A hash is a unique fixed length string, meant to identify any piece of data, they are created by putting some piece of data into a hash function.

644
01:06:10.486 --> 01:06:14.646
In this example, the hashing algorithm used is Sha 256.

645
01:06:14.646 --> 01:06:24.238
Now Etherium actually uses this, this right here for its hashing algorithm, which isn't quite Sha 256, but as in kind of this SHA family.

646
01:06:24.238 --> 01:06:27.259
But it's really just another way to hash things.

647
01:06:27.259 --> 01:06:30.669
And the specific hash algorithm doesn't matter so much.

648
01:06:30.669 --> 01:06:35.697
So this example, you just shot up to six, but you can imagine it's the same as the Etherium.

649
01:06:35.697 --> 01:06:38.657
Hash, they're just going to result in a different hash.

650
01:06:38.657 --> 01:06:50.931
So what's going to happen in this application here is whatever data or whatever information we put into this data section here, as you can see below this hash changes.

651
01:06:50.931 --> 01:06:57.682
So what's happening is this data is running through the Sha 256 hash algorithm.

652
01:06:57.682 --> 01:07:00.671
And it's outputting, this unique hash.

653
01:07:00.671 --> 01:07:07.214
So this hash is a unique fixed length string, that's going to identify like a blank data piece here, right.

654
01:07:07.214 --> 01:07:14.741
So if I put in, you know, my name like Patrick Collins, this is the hash that's going to represent Patrick Collins, right.

655
01:07:14.741 --> 01:07:24.807
And you can see, even when I put, you know, tons and tons of data in here, the length of the string doesn't change, right.

656
01:07:24.807 --> 01:07:33.081
So it's always gonna be the same, we can put almost any amount of data in here, there is an upper limit on the max size of the data.

657
01:07:33.081 --> 01:07:37.262
But for all intents purposes, we can pretty much put any length in here.

658
01:07:37.262 --> 01:07:54.567
And you'll see to that every time I type in Patrick Collins, this hash is always gonna be this seven e five D, right? I'm gonna delete I'm gonna do Patrick Collins, again, you're 75 B is always this, this unique hash is always going to be unique, right, it's always gonna be this fixed length string here.

659
01:07:54.567 --> 01:08:01.341
So now we can take this idea while putting this data in here, we can move on to this concept of a block.

660
01:08:01.407 --> 01:08:14.249
So with this block concept, we're going to take the exact same thing with this hash this this data section, right, but instead of having everything just being in this, this singular data area right here, we're going to split this data up into block, nuns, and data.

661
01:08:14.249 --> 01:08:23.331
So all so what we're going to do is we're actually going to hash all three of these to get to get this hash, right, we're gonna put all three of these, we're gonna say all three of these are combined.

662
01:08:23.331 --> 01:08:28.715
Together, we're gonna put every all three of them into this hashing algorithm to figure it out.

663
01:08:28.715 --> 01:08:37.568
So if I type a bunch of stuff here, we can see that block one with nonce, you know, this nonce, and this data, we're going to get this hash.

664
01:08:37.568 --> 01:08:42.773
And as you can see, actually, the screen turns red, this block turned red.

665
01:08:42.773 --> 01:08:50.037
Now, what happens when I hit this mind button? When I hit this mind button, it's actually gonna take some time, it's gonna think for a little bit.

666
01:08:50.037 --> 01:08:57.068
And we can see that the nonce here actually changed, right? The nonce is different from what it was before.

667
01:08:57.068 --> 01:09:00.363
And this hash now starts with four zeros.

668
01:09:00.363 --> 01:09:02.758
Okay, and then the back turn green.

669
01:09:02.758 --> 01:09:25.088
When we're talking about mining, we're talking about miners solving some type of very difficult problem that takes a lot of time to do now in this example, here, the problem that the miners had to solve was they had to find a nonce, or or a value in this nonce section that when hashed with at block number one with this data, it would start with four zeros.

670
01:09:25.088 --> 01:09:35.137
So the problem here the miners had to solve was to start with four zeros and the only way for them to really do that is kind of this brute force, you know, trying stuff so they tried one okay, one didn't work.

671
01:09:35.137 --> 01:09:37.842
Okay, two, nope, two didn't work.

672
01:09:37.842 --> 01:09:40.623
3456 Okay, five, well, that started with one zero, but it's not four.

673
01:09:40.623 --> 01:09:50.297
And they have to keep trying all these numbers until they get to this one where you know, let's hit mine again.

674
01:09:50.418 --> 01:09:53.660
Where it has four zeros at the top at the start.

675
01:09:54.419 --> 01:09:56.619
specific problem changes blockchain to blockchain right yet.

676
01:09:56.619 --> 01:10:04.274
Aetherium has a different problem for miners to solve A bitcoin is different problems from yourself, but this concept is going to be the same.

677
01:10:04.274 --> 01:10:12.338
So they have to take it, one block is going to be this, this, this concept is going to be all this data, it's going to be the block number.

678
01:10:12.338 --> 01:10:14.813
And it's going to be this nonce, right.

679
01:10:14.813 --> 01:10:27.866
And so this nonce is the solution is going to be the the number that they use to get like the solution to the problem, right? So if I go to one here, you know, I do this again, hit mine.

680
01:10:27.866 --> 01:10:31.453
And the nonces changed, right? And went from one to 33,128.

681
01:10:31.453 --> 01:10:37.358
Because this is the nonce that allowed this hash to start with four zeros.

682
01:10:37.358 --> 01:10:39.858
And so that's what's happening.

683
01:10:39.858 --> 01:10:50.127
When blockchain miners are mining they're going through this process is very computationally intensive process of trying to find a nonce that fulfills whatever the problem is.

684
01:10:50.127 --> 01:10:51.336
So that's really it, actually.

685
01:10:51.336 --> 01:10:51.967
So that's a block.

686
01:10:51.967 --> 01:10:53.958
And that's really what's happening when miners are mining.

687
01:10:53.958 --> 01:11:03.863
They're just looking, there's trial and error, brute force trying to find this nut so so now that we know what a block is, let's go to the next step and figure out okay, well, what's a block chain.

688
01:11:03.863 --> 01:11:09.296
So here we have an example of what a blockchain is going to look like.

689
01:11:09.296 --> 01:11:14.458
Right, we have a combination, you know, we have back here in the block section, we have one what one block looks like.

690
01:11:14.458 --> 01:11:24.077
Now here, we have multiple different blocks, right, each one of these represents a different block, but we have an additional column here, we have additional variable here.

691
01:11:24.077 --> 01:11:37.100
So like before, you know, we have block nonce and data, right, we have blocked nonce data, we also have this thing called previous right, and so this is actually gonna be pointing to the previous hash of the last block.

692
01:11:37.100 --> 01:11:42.203
So for example, if we go to the last block in this blockchain, it says previous 008.

693
01:11:42.203 --> 01:11:46.085
And if we look at the hash of block number four, is 00008.

694
01:11:46.085 --> 01:11:58.743
And then we look at its previous it's four zeros, B nine, we have four zeros, B, nine, and so on, all the way back to our first block, which has previous of just all zeros, right.

695
01:11:58.743 --> 01:12:03.535
And so the block with the previous of all zeros, is going to be known as the Genesis block.

696
01:12:03.535 --> 01:12:11.532
So you've probably heard that before the Genesis block, it's the first block in the blockchain were the previous hash points to a hash that doesn't actually exist.

697
01:12:11.532 --> 01:12:42.015
Now, as you can imagine, kind of the same as how this block worked, how the block nuts and dated all go through the hashing algorithm in the blockchain, the block nonce data, and previous hash all go through this hashing algorithm to figure out what the hashes okay? So if we go to over here, you know, for example, if I type in Patrick, obviously, this is now no longer valid, right? Because this nuns combined with the block the data in the previous hash, aren't going to solve our problem of having four zeros at the at the start, right.

698
01:12:42.015 --> 01:12:43.418
So I'm gonna go and fix that.

699
01:12:43.418 --> 01:12:46.608
And that's, that's kind of an easy way to see it being broken.

700
01:12:46.608 --> 01:13:18.455
But, but let's take a look, if I break this block, right here, what happens if I, if I break the data in here, if I do like Patrick in here, you can see that both of these are now read, both of these are now invalid, right? Because the block hash with the nonce hash with the new data, which is my name, Patrick has hashed with the previous block is now a brand new hash, right, and this block is still pointing to this previous hash right here, right is pointing to this previous block.

701
01:13:18.455 --> 01:13:26.209
And now it is wrong, and it is messed up and now, and now it's nuts with this previous hash is also wrong.

702
01:13:26.209 --> 01:13:40.844
Right? And this is where when we talk about blockchains, being immutable, this is exactly how it's immutable, right? Because I go back and I change anything, you know, if I've just typed a right here, the entire blockchain is now invalidated.

703
01:13:40.844 --> 01:13:46.171
Because none of these are going to have nonces that solve this equation anymore.

704
01:13:46.171 --> 01:14:07.927
So this is why blockchains are immutable is because anytime you change one thing, you ruin the rest of the blockchain, okay? So however, though, you know, if it was here, originally, we can go ahead and mine these, mine all these but as you can see, you know, this is going to start getting very computationally expensive, because I have to go redo basically the entire blockchain.

705
01:14:07.927 --> 01:14:15.206
And the farther and farther down the line you get, the harder and harder it becomes to, you know, rehash and redo all these different block chains here.

706
01:14:15.206 --> 01:14:20.462
Now, this makes a lot of sense, right? So we have this blockchain, it's really hard to change something in the past, but if we do, we can just go ahead and remind it.

707
01:14:20.462 --> 01:14:27.287
Now if I'm the one who controls the blockchain, right, if I'm the one who controls this, you know, and I want to change something, the past will, okay, great.

708
01:14:27.287 --> 01:14:29.429
All I got to do is change the state of here.

709
01:14:29.429 --> 01:14:39.362
And then you know, mine, each one of these, you know, obviously, it's going to be very computationally expensive, but it's something that I can do right if I'm the one who owns the blockchain.

710
01:14:39.447 --> 01:14:46.666
Now, here's where the decentralized nature or the distributed nature really makes it incredibly powerful.

711
01:14:46.666 --> 01:14:56.635
So we're gonna go to the distributed tab here, which is also referred to as the decentralized tab here, and it's going to show us what a blockchain looks like in a decentralized manner.

712
01:14:56.635 --> 01:15:04.285
So we have this exact same initial setup here we have to Shoot a blockchain, we have our first blockchain, which is kind of exactly as the one from here.

713
01:15:04.285 --> 01:15:16.093
But we also have more than once we have peer, a peer beam, and PRC and when people are talking about Peer to Peer, peer to peer transactions through the talking, this is kind of that concept that they're talking about, right.

714
01:15:16.093 --> 01:15:31.435
So we have a number of different peers who are running this blockchain technology, they're all weighted equally, right, each one of these peers or each one of these nodes, each one of these entities running a blockchain has the exact same power as anybody else, right.

715
01:15:31.435 --> 01:16:01.713
So the way that we can tell very easily which blockchain is correct, or which ones are correct, or by looking at this end, hash here, right, or by looking at where we are in the blockchain, because again, remember, because again, remember this, this hash that this this in this last block here, is going to encompass all of the blocks from before, right, because this last hash is going to have the previous hash here, which includes the previous hash here, which this hash includes the previous hash here.

716
01:16:01.713 --> 01:16:17.857
And so this last hash is encompasses everything in here, right? And we can look, we can look at the hash of Piercey, which is four zeros, and then E four B, we can look at the latest hash appear B, which is four zeros, E for B, and then pure A, which is four zeros, E for b.

717
01:16:17.857 --> 01:16:33.958
So all of these peers, all of these nodes, all of these decentralized, you know these independent, all these independent users running this blockchain software, they're all matched up, it's very easy for their nodes to look at each other and say, hey, great, we are all matched up.

718
01:16:33.958 --> 01:16:43.271
Now, what let's say that a decides that, you know, something happened on the blockchain that they didn't like, and they wanted to go back and change something, right.

719
01:16:43.271 --> 01:16:47.913
So let's say they change here, you know, obviously, the rest of their blockchain is invalidated.

720
01:16:47.913 --> 01:16:51.364
And they have to spend a lot of computational power to catch up to speed.

721
01:16:51.364 --> 01:16:52.853
So let's go ahead and humor it.

722
01:16:52.853 --> 01:16:55.362
Let's say that they did, they ended up catching up.

723
01:16:55.461 --> 01:16:58.138
They ended up catching up, you know, they ended up mining everything.

724
01:16:58.138 --> 01:17:00.646
And now they have a valid blockchain.

725
01:17:00.646 --> 01:17:03.018
Right? It solves the equation.

726
01:17:03.018 --> 01:17:03.673
Awesome.

727
01:17:03.673 --> 01:17:13.388
However, in block number three, there's something new, right? This is here, and it shouldn't have been here, this is some that Peer A put in by themselves.

728
01:17:13.388 --> 01:17:24.213
All that happens now is we look at all the blockchains that are running the software, and we're looking at all the hashes and hash at block number five.

729
01:17:24.213 --> 01:17:26.225
So pure A has this new hash.

730
01:17:26.225 --> 01:17:28.225
Now, there's a 09 BC.

731
01:17:28.225 --> 01:17:39.947
But pure B has a different hash 00, e for B, right? So who's right? Is it disappear a with their new stuff? Or is it pure B? Well, that's where the decentralized data comes in.

732
01:17:39.947 --> 01:17:43.542
Because then we can look at Piercey Piercey, also as E forby.

733
01:17:43.542 --> 01:17:50.385
So if you're being Piercey will say, Hey, you're a, you're wrong, get out, right.

734
01:17:50.466 --> 01:18:08.657
And pure A will stop being able to participate in the mining rewards because they have essentially forked the blockchain and started their own little blockchain right with their own history, because they're the only ones with this, this piece of data in block three, whereas pure B, and pure C have nothing in there.

735
01:18:08.657 --> 01:18:17.900
So that really shows why in these blockchain worlds in this decentralized world, there really is no centralized entity, you know, pure A, you know, might have been maliciously motivated to change.

736
01:18:17.900 --> 01:18:27.282
You know, there's this block number three, however, democracy rules, right, the majority rules in the blockchain, pure vmpfc will say, hey, you know, the, that's cute and all puree.

737
01:18:27.282 --> 01:18:29.531
But you're wrong, right? That's not right.

738
01:18:29.531 --> 01:18:40.962
Now, it might be a little abstract, that you just look at data and you know, as typing kind of random stuff in here and think, okay, yeah, that's, that's data, right? That makes sense, you know, just kind of random strings in here doesn't really do anything for us.

739
01:18:40.962 --> 01:18:46.709
So if we actually go over to the token section here, this is where everything really starts to make a lot of sense.

740
01:18:46.709 --> 01:18:51.222
So we have the exact same setup here with pure a pure B Piercey.

741
01:18:51.222 --> 01:19:12.067
Except and the difference is, instead of having kind of this, this data section, we have this TX This transaction section, right? And this represents all the transactions that are happening in this block, right? So we're sending $25, from Darcy to Bingle, or to Bingley force toward dollars and 27 cents here.

742
01:19:12.067 --> 01:19:13.004
1922, right.

743
01:19:13.004 --> 01:19:15.087
And it's the exact same thing.

744
01:19:15.087 --> 01:19:21.114
So this, all these transactions are gonna get hashed in the exact same way that the data is going to get hashed.

745
01:19:21.114 --> 01:19:33.426
And, and this is why it's so powerful, because again, you know, if I want to be malicious, right, if, if I want to say, hey, I really wanted to give Jane a lot more money from Elizabeth, so I'm puree and I go back and I change it to 100.

746
01:19:33.476 --> 01:19:42.784
Well, now, you know not only do I does my whole blockchain get invalidated because that was so so long ago, but I'm not going to match any of these other chains.

747
01:19:42.784 --> 01:19:47.123
Right? And so my blockchain is going to be excluded from the overall blockchain.

748
01:19:47.123 --> 01:19:49.768
So and let's let's go ahead and fix this.

749
01:19:49.768 --> 01:19:57.885
And it's the same thing if down here if I become malicious, and I want to send you know, I want Miss Audrey to have less money.

750
01:19:57.885 --> 01:20:10.896
Maybe I want to send $1 And they go had in mind it the same thing here, this hash now this two a one is not going to match the rubies rubies hash of BBA.

751
01:20:10.896 --> 01:20:13.917
And it's not going to match Pierce's hash of BBA as well.

752
01:20:13.917 --> 01:20:20.904
So the two of them are gonna say, hey, this, your blockchain is invalid, it's not matching the majority, you know, you're out, right.

753
01:20:20.904 --> 01:20:25.732
So that's really how these blockchains work at a low level.

754
01:20:25.732 --> 01:20:36.631
And it all goes back to this, this understanding this hash idea, and using it in this very sophisticated manner, to kind of cryptographically prove, you know, where, where stuff lies.

755
01:20:36.631 --> 01:20:51.516
Now, the way the blockchain works is, instead of random stuff, put in the Status section, it's actually going to be solidity code in here to finding ways to interact with different blocks and different protocols that are on chain, or, as we've said before, different smart contracts.

756
01:20:51.516 --> 01:21:06.243
Now, the next question that you might be asking is, okay, well, how do I know how can I be sure that I'm the one? You know, let's say this is, let's say, I'm Darcy right? How can I be sure that I was that Darcy was the one to actually send us money here.

757
01:21:06.243 --> 01:21:08.866
How do we know that Darcy sent $25.

758
01:21:08.866 --> 01:21:14.293
To Bingley? Well, this is where we get into private keys and public keys.

759
01:21:14.293 --> 01:21:16.605
And that's what we're going to go into.

760
01:21:16.605 --> 01:21:16.808
Now.

761
01:21:16.808 --> 01:21:19.701
Let's just do a quick recap of what we've learned in this section.

762
01:21:19.701 --> 01:21:25.091
So far, right? We've learned that Aetherium actually runs on this hit check 256.

763
01:21:25.091 --> 01:21:26.165
But we use Sha 256.

764
01:21:26.165 --> 01:21:28.100
For this demo, it doesn't really matter.

765
01:21:28.100 --> 01:21:31.677
We're just talking about hashing algorithms.

766
01:21:31.677 --> 01:21:38.258
So again, hash is a unique fixed length string meant to identify any piece of data.

767
01:21:38.258 --> 01:21:47.406
A hash algorithm or a hash function is a function or algorithm that computes any type of data into a unique hash.

768
01:21:47.490 --> 01:21:51.783
Mining is going to be the process of finding the solution to the blockchain problem.

769
01:21:51.783 --> 01:21:56.200
In our example, the problem was finding a hash that starts with four zeros.

770
01:21:56.200 --> 01:21:58.552
nodes get paid for mining different blocks.

771
01:21:58.552 --> 01:22:09.904
And the problem is going to be different blockchain to blockchain a block and a blockchain is basically a combination of a block, nonce transaction and previous hash to create this unique hash for this block.

772
01:22:09.904 --> 01:22:15.282
And again, depending on the blockchain implementation, this might have a couple other fields or might have different fields.

773
01:22:15.282 --> 01:22:22.893
But this is essentially what's going on blockchains are decentralized and distributed because many independent users are going to run this blockchain software.

774
01:22:22.893 --> 01:22:32.107
And they will check and then we'll compare against each other to see which blockchains are acting honestly, and which ones are acting maliciously, in the blockchain world majority rules.

775
01:22:32.107 --> 01:22:37.608
The nonce here is the answer used or the number used to get this hash.

776
01:22:37.608 --> 01:22:41.850
Now nonce is kind of an overloaded term, it's actually used for a number of different reasons.

777
01:22:41.850 --> 01:22:47.860
In this case, we're using it to solve this problem of getting four or five zeros at the stop or the hash.

778
01:22:47.860 --> 01:22:56.349
However, in Aetherium, it will also be often used as the number of transactions from a given address.

779
01:22:56.497 --> 01:23:16.212
So now we're going to talk a little bit about signing these transactions and private keys and some other cryptography pieces, right? Because in this blockchain demo here, we can see we have all these these fantastic transactions, right? All these things went through, but how do we know that it was Darcy? Who was the one to send $25? To bangli? Right? How do we know that actually happened.

780
01:23:16.212 --> 01:23:26.423
And this is where all those pieces that we just learned about in our test net, in our meta mask account are really going to start to, to come to life here a little bit here.

781
01:23:26.423 --> 01:23:35.270
So here we have an example of public and private keys, okay, at the top, we have this private key, right that was that was randomly generated.

782
01:23:35.270 --> 01:23:49.872
A private key is you know, as it kind of states is a key that you really want to keep secret, because you're going to be using this as kind of your your secret password for all your transactions where I can really pick, you know, any, any, any private key, anything that I want.

783
01:23:49.872 --> 01:23:55.519
And with it, this algorithm, or they're going to use an algorithm for Aetherium.

784
01:23:55.519 --> 01:24:02.957
Bitcoin, they both use this elliptic curve, digital signature algorithm, it's a variant of just a digital signature algorithm.

785
01:24:02.957 --> 01:24:09.186
And it's going to create this this public key, right, I'm really not going to go at all into kind of this digital signature algorithm.

786
01:24:09.186 --> 01:24:17.685
But just know it does use some of these, some of the hash knowledge that we just learned combined with some other pieces to kind of get this this public here.

787
01:24:17.685 --> 01:24:19.279
So I'm not gonna go too deep into it.

788
01:24:19.279 --> 01:24:22.117
But we have this private key that we create.

789
01:24:22.117 --> 01:24:23.880
And we get this public key.

790
01:24:23.880 --> 01:24:43.460
Now this public key we want everybody to have access to right this is yeah, whole world can see this, this private key, we really want it to be private, we don't want people to see this, we're going to use this private key as like a password to quote unquote, digitally sign transactions, and then people can verify them with this public key.

791
01:24:43.460 --> 01:24:45.589
So let's, let's see what this actually looks like.

792
01:24:45.589 --> 01:24:51.333
Let's pick a random key, a more secure key, right? Because the longer it is, the more secure it's going to be.

793
01:24:51.333 --> 01:25:14.447
And if we go to signatures now, right? Let's say we have this, this message that we want, right? We'll say hi world, right? We want this To be the message, what's gonna happen is this private key that we've created, we can use to sign this data, right? Remember how in the blockchain demo, you know, we were kind of we were hashing stuff, right? We were using this Shea 256 hash to get this hash.

794
01:25:14.510 --> 01:25:16.260
Well, we're doing something similar.

795
01:25:17.511 --> 01:25:21.953
we're, we're using this digital signature algorithm to create this message signature.

796
01:25:21.953 --> 01:25:35.858
Now, what's really powerful about how this this algorithm works, is that you can create this message signature with your private key, but somebody else can't derive your private key from the message signature.

797
01:25:35.858 --> 01:25:38.431
And that's what makes this really, really powerful.

798
01:25:38.431 --> 01:25:44.598
However, if we go to verify using this public key, right, and so this is the this is that, Oh, 403.

799
01:25:44.598 --> 01:26:01.243
This is that same public key, using this, using this public key, anybody can verify, let's go ahead and sign again, anybody can verify that the signature is yours, right? So you have a public a private key, just for you.

800
01:26:01.243 --> 01:26:05.328
So you can sign things and a public key that anybody can verify something, right.

801
01:26:05.328 --> 01:26:27.851
So anybody can verify this, and let's say somebody tries to fake a transaction from you, they say, Hey, you know, this is this is this is their transaction, all they have to do is verify that this signature against your public key and very easily, this whole thing turns red, because it isn't verified, right, that the algorithm says, hey, that's wrong.

802
01:26:27.851 --> 01:26:32.763
So we can go ahead and take that into transactions in this exact same way.

803
01:26:32.763 --> 01:26:45.123
So if I want to send money, you know, if I want to send $400, from, you know, my address to another address, using my private key, I can sign that transaction.

804
01:26:45.123 --> 01:26:49.770
And anybody else in the world can then verify this transaction, right.

805
01:26:49.770 --> 01:26:56.551
And this is why when people say Hydra keys, you know, protect your keys, this is what we're talking about in our accounts here.

806
01:26:56.551 --> 01:27:13.072
Right? If we go to settings, and again, the only reason that I'm showing you guys, my pneumonic, and my private key is because this is a, this is a dumpster account, I'm going to throw this away at the end of this video, or I'm just not gonna put any real money in it.

807
01:27:13.072 --> 01:27:30.097
But when we look at our Metamask, here, we have this pneumonic phrase, which allows us to easily get these different private keys, right? So pneumonic phrase combined with, you know, whatever account number will get us a private key.

808
01:27:30.097 --> 01:27:33.524
So mnemonic phrase combined with one, we're gonna get this private key.

809
01:27:33.524 --> 01:27:40.388
And this is when we look at account details, export private key.

810
01:27:40.525 --> 01:27:54.458
That's where it confirm, this is going to be the private key that we're going to use to sign our transactions, right, this, if anybody else gets access to this private key, they then can sign transactions for us, and they can send transactions for us.

811
01:27:54.526 --> 01:27:58.717
And that's why we want to keep these private, so that it works the exact same way, right.

812
01:27:58.717 --> 01:28:12.511
And so this is why it's so important to hide your private keys and hide your mnemonics now, your Aetherium address is actually a piece is actually a piece of your public key.

813
01:28:12.511 --> 01:28:22.977
Now, to get our address in Aetherium, all we have to do is take this public key that we've created with our private key, hash it using that same Aetherium hashing algorithm, and then take the last 20 bytes.

814
01:28:22.977 --> 01:28:27.400
And that's how we'll actually derive to our to our address here.

815
01:28:27.400 --> 01:28:35.453
Now, knowing the exact methodology of how to get the address doesn't really matter, because it could change blockchain to blockchain and could even change it too.

816
01:28:35.453 --> 01:28:44.170
But just know that that is essentially how kind of these addresses are derived or there's some derivative of the public key, right, because the public key is public.

817
01:28:44.170 --> 01:28:49.969
And you know, using the public key and kind of any public way is totally fine, but not the private key.

818
01:28:49.969 --> 01:28:52.008
So that is how we sign our transactions.

819
01:28:52.008 --> 01:28:54.549
Note though, this isn't how we send the transaction.

820
01:28:54.549 --> 01:29:01.495
So so this is just going to assign it create a transaction for us to send, we'll learn later on how to send these transactions.

821
01:29:01.495 --> 01:29:01.680
Cool.

822
01:29:01.680 --> 01:29:03.888
So that was a lot of information there too.

823
01:29:03.888 --> 01:29:17.727
Let's do a quick recap, your public key is derived by using a digital signature algorithm on your private key, right, and you want to keep your private key private at all times, because you're going to use your private key to sign transactions.

824
01:29:17.727 --> 01:29:26.869
Signing transactions with your private key, you are the only one who can actually do this because you can't get the private key from a message signature.

825
01:29:26.869 --> 01:29:36.418
However, using your public key, you can anybody can very easily verify that a signature that signed by you is in fact signed by you in our meta mask.

826
01:29:36.418 --> 01:29:44.198
Our private keys are located in this account details section you just hit show private keys and type in your password.

827
01:29:44.198 --> 01:29:46.334
And you'll get your your private key here.

828
01:29:46.334 --> 01:29:51.841
A quick note here is oftentimes when using your private keys somewhere, they want it in hexadecimal form.

829
01:29:51.841 --> 01:30:01.872
So if we're going to use our private key for something like brownie, which we'll go into later, we need to actually append a 0x to the front but We'll get into that later.

830
01:30:01.872 --> 01:30:05.289
And the address of your account is derived from this.

831
01:30:05.289 --> 01:30:12.123
So if you think about your private key creates your public key, which then can create your address.

832
01:30:12.123 --> 01:30:16.373
And there's a little barrier or a big barrier here.

833
01:30:16.541 --> 01:30:27.386
Because your private key, you want to keep private and your public key and your address can all be public information.

834
01:30:27.542 --> 01:30:41.067
Now that we know a little bit more about what's going on underneath the hood of these blockchains, let's go back at our transactions and look at this gas thing again, and we'll look to see what's actually happening here, gas in particular can be a little bit tricky to wrap your head around.

835
01:30:41.067 --> 01:30:43.393
So if you don't get it right away, don't worry.

836
01:30:43.393 --> 01:30:46.246
As we go through examples, it'll start to make more sense.

837
01:30:46.246 --> 01:30:52.705
So before I was saying, let's just look at this transaction fee bid, which is the costs associated with running this transaction.

838
01:30:52.705 --> 01:31:07.234
If I scroll over this on ether scan, I can see this thing that says block base fee per gas plus max party fee per gas times the gas use, which might be a little bit confusing here, let's actually break down what's going on on Aetherium with ERP 15, five nine in place.

839
01:31:07.234 --> 01:31:11.831
And again, this is going to be specific to Aetherium, as every blockchain might do it a little bit differently.

840
01:31:11.831 --> 01:31:17.415
But if we click to see more, we can see a number of useful values here, we can see gas limit is 21,000.

841
01:31:17.415 --> 01:31:19.382
And usage is 21,000.

842
01:31:19.382 --> 01:31:26.455
So this transaction used 21,000 gas, and we sent 21,000 gas along with it.

843
01:31:26.548 --> 01:31:29.976
Sometimes when sending a transaction, depending on when it's sent.

844
01:31:29.976 --> 01:31:35.695
And depending on what the specific instructions are, it might actually use way more gas than what you want it to use.

845
01:31:35.695 --> 01:31:44.909
So with your transactions, you can actually set a limit, hey, I don't want to use more than x amount of gas, I don't want to do more than x computational units.

846
01:31:44.909 --> 01:31:47.411
And in fact, we go to our Metamask.

847
01:31:47.411 --> 01:31:52.736
And we click Send to transfer between accounts again, and we pick you know, 0.

848
01:31:52.736 --> 01:32:15.776
01 eath, or something next can actually hit this little button here, go to Advanced, and we can actually edit some specifics of this transaction, one of them is going to be the gas limit, we can change this gas limit to maybe 2200 2300, or more or even less, since sending Aetherium takes exactly 21,000 Gas Metamask just defaults to setting into that.

849
01:32:15.776 --> 01:32:20.937
Well, we also see these other interesting things, we see a priority fee, and a max base fee.

850
01:32:20.937 --> 01:32:23.244
Let's reject this transaction.

851
01:32:23.244 --> 01:32:26.626
And let's look back at ether scan to talk about these.

852
01:32:26.626 --> 01:32:35.729
So currently in Aetherium, according to EE IP 1559, every transaction on Aetherium comes with something called the base fee.

853
01:32:35.729 --> 01:32:40.490
This is the minimum gas price you need to set to include your transaction.

854
01:32:40.555 --> 01:32:44.037
And you'll notice that these are priced in something called gateway.

855
01:32:44.037 --> 01:32:48.046
So what is a gateway? If we come to the site eath converter.

856
01:32:48.046 --> 01:32:48.209
com.

857
01:32:48.209 --> 01:33:02.033
And again, there's a link to this in the GitHub repository, we scroll down we can see way gateway and ether five put one ether in here, I can see how much one ether is in terms of way.

858
01:33:02.033 --> 01:33:06.786
And in terms of way, one ether is equal to 1-234-567-8990.

859
01:33:06.786 --> 01:33:13.891
So that's that's 1 billion way is going to be one ether.

860
01:33:13.891 --> 01:33:22.203
And then 1-234-567-8910 1112 1314 Did 16 Seven, eight team and then 18 zeros is away.

861
01:33:22.203 --> 01:33:28.140
These are just easier ways of referring to really, really small amounts of Aetherium.

862
01:33:28.140 --> 01:33:32.463
So if we look at our gas fees, we see that the base fee is 0.

863
01:33:32.463 --> 01:33:34.269
00000004 Go away.

864
01:33:34.269 --> 01:33:41.544
And this obviously would be an even smaller number if this was in units of weigh.

865
01:33:41.544 --> 01:33:49.148
So if we take this number, and we put it into our calculator, we can see that this is equal to 40 weigh or 0.

866
01:33:49.148 --> 01:33:52.193
0000 a whole bunch of zeros for ether.

867
01:33:52.193 --> 01:33:58.681
The max fee here refers to the maximum gas fee that we're willing to pay for this transaction.

868
01:33:58.681 --> 01:34:06.218
And you can actually see that our max fee is a little bit higher than what we actually ended up paying.

869
01:34:06.218 --> 01:34:07.459
Our maximum was 2.

870
01:34:07.459 --> 01:34:12.236
2132 something something and the gas price we actually paid was up here.

871
01:34:12.236 --> 01:34:17.617
Now your transaction might of course be a little bit different than Additionally we have a max priority fee.

872
01:34:17.617 --> 01:34:22.898
This is going to be the max gas fee that we're willing to pay plus the max tip that we're willing to give to miners.

873
01:34:22.898 --> 01:34:31.016
Now currently in Aetherium, this base fee ends up getting burnt and we can see on ether scan exactly how much is getting burnt here.

874
01:34:31.016 --> 01:34:44.107
And if we pull up our calculator again, we can grab this gas fee, multiply it by the amount of gas we used, and we can see that this is indeed how much Aetherium we actually ended up burning.

875
01:34:44.107 --> 01:34:49.873
We go back to Ethereum converter, paste it in we can see that these two numbers are indeed equal.

876
01:34:49.873 --> 01:34:58.568
This means whenever you send a transaction, a little bit of Aetherium is removed from circulation forever, or it's considered burnt.

877
01:34:58.568 --> 01:35:03.902
So currently, in theory As part of your Aetherium part of your transaction fee actually gets burnt.

878
01:35:03.902 --> 01:35:06.664
And then the other part goes directly to miners.

879
01:35:06.664 --> 01:35:14.466
So to figure out exactly how much went to miners, we could do this number minus the burnt amount.

880
01:35:14.570 --> 01:35:27.162
And this is how much Etherium was paid to Aetherium miner for this transaction, you'll see down here your transaction type to ERP 15, five, nine, this is the eip 15 five nine version of these transactions.

881
01:35:27.162 --> 01:35:31.772
Like I said, every blockchain is going to have a different fee burning and fee and gas process.

882
01:35:31.772 --> 01:35:56.284
And they're all going to be a little bit different, but the some of it is blockchains have limited block space for transactions, the gas price that costs for your transaction to be included in one of these blocks changes based off how much demand there is the base gas fee for Aetherium will go up and down depending on how many people are sending transactions and how many people want to be included in a block.

883
01:35:56.284 --> 01:35:59.643
If a ton of people want to be included in a block.

884
01:35:59.643 --> 01:36:02.952
That means a ton of gas is obviously going to get burnt.

885
01:36:02.952 --> 01:36:15.836
We've left a link to a video in the GitHub repository with this section from this YouTuber who does an amazing job breaking down this EIP 15, five, nine and more about how this gas model actually works.

886
01:36:15.836 --> 01:36:18.431
I highly recommend you pause this video and watch that video.

887
01:36:18.431 --> 01:36:27.349
To understand more, the base fee gets programmatically algorithmically adjusted to try to target for all the blocks to be 50% full.

888
01:36:27.349 --> 01:36:32.026
If they're more than 50% full, this base fee automatically goes up.

889
01:36:32.026 --> 01:36:35.721
If they're less than 50% full, this base fee goes down.

890
01:36:35.721 --> 01:36:39.110
Now this is a lot of the basics of how this transaction works.

891
01:36:39.110 --> 01:36:40.141
And it can be a little confusing.

892
01:36:40.141 --> 01:36:42.631
So let's do a quick refresher of everything in here.

893
01:36:42.631 --> 01:36:48.257
There's a unique transaction hash that uniquely identifies this transaction.

894
01:36:48.257 --> 01:36:54.451
On this blockchain, we can see the status, we can see the block number that it's confirmed on.

895
01:36:54.451 --> 01:36:56.661
One other thing we want to look at.

896
01:36:56.661 --> 01:36:59.646
If we scroll up, we see block number and block confirmations.

897
01:36:59.646 --> 01:37:02.924
This is how many blocks have been mined.

898
01:37:02.924 --> 01:37:05.065
Since this block was included.

899
01:37:05.065 --> 01:37:19.725
Like we saw with our blockchain demo, the longer the blockchain gets, the harder it is to tamper with and the more secure it is typically, you'll see some processes say they'll only do something after 20 Block confirmations, 30 Block confirmations or etc.

900
01:37:19.725 --> 01:37:26.044
The reason that they wait for these block confirmations is because they want to make sure that that transaction is actually included.

901
01:37:26.044 --> 01:37:36.229
And we can actually see the block that our transaction was included in and all the other transactions with it, different details about how much gas was used, the gas limit, etc.

902
01:37:36.229 --> 01:37:42.535
timestamp is when the transaction happened, we can see from and to we can see the value.

903
01:37:42.535 --> 01:37:51.520
And then we can see the transaction fee, which we see right here is blocked base fee per gas plus the max priority fee per gas times the gas used.

904
01:37:51.586 --> 01:38:09.397
And we see all the details of the gas down here gas price is the cost of one unit of gas gas limit is the max amount of units of gas that we're willing to pay in this transaction, the usage is how many actually got us the base fee is going to be the base network fee per gas.

905
01:38:09.397 --> 01:38:16.808
So 40 way per one gas used, the max gas is the max gas price we're willing to pay.

906
01:38:16.808 --> 01:38:22.959
And Max priority is gonna be the max gas price, plus the tip that we give to miners, and then we can see how much is burnt.

907
01:38:22.959 --> 01:38:31.056
And then we see transaction savings which which is the difference between how much was actually used or paid for and then returned.

908
01:38:31.056 --> 01:38:38.066
So for example, in this transaction, the gas price we ended up picking was a little less than our max gas price here.

909
01:38:38.066 --> 01:38:42.743
So the gas price we ended up using was a little less than our max priority fee here.

910
01:38:42.743 --> 01:38:55.942
So we had some savings compared to that, we can also see that this was an ERP 15 five nine transaction, we can see our nonce here, which was not zero because the transaction that I'm showing is our first nones.

911
01:38:55.942 --> 01:39:02.543
And then of course, we can see the input data for transactions that are just sending Aetherium, the input data is going to be blank.

912
01:39:02.593 --> 01:39:06.528
But you'll see that when we get to smart contracts, the input data is not going to be blank.

913
01:39:06.528 --> 01:39:10.363
And it's going to be one of the most important features of these transactions.

914
01:39:10.363 --> 01:39:13.117
You'll also notice that there's a state tab.

915
01:39:13.117 --> 01:39:19.184
This is an advanced tab, and it shows the different states that are changed based off of this transaction.

916
01:39:19.184 --> 01:39:21.273
We're going to ignore this one for now.

917
01:39:21.273 --> 01:39:27.498
Now that we know how the blockchain itself works under the hood, let's talk about some blockchain fundamentals.

918
01:39:27.498 --> 01:39:31.396
And we actually covered all these topics in a previous Freako camp video.

919
01:39:31.396 --> 01:39:34.419
So let's go to that.

920
01:39:34.596 --> 01:39:39.449
If the first time you listen to this, some of these concepts seem a little bit hard to grasp.

921
01:39:39.449 --> 01:39:40.826
Don't worry about it.

922
01:39:40.826 --> 01:39:47.580
As we continue and as we move on with this course, they'll start to make more sense when you see them used in real examples.

923
01:39:47.580 --> 01:39:57.534
I definitely would recommend going back and rewatching and re listening to the parts that you don't quite get an asking questions in the discussions tab of the GitHub repository.

924
01:39:57.534 --> 01:39:57.921
Awesome.

925
01:39:57.921 --> 01:40:06.560
So now that we know all the cryptography pieces and all the little nitty gritties of how the blockchain actually works, and how our signatures work and how everything sticks together.

926
01:40:06.600 --> 01:40:11.545
Let's talk a little bit about how this works, in actuality, and what's really going on.

927
01:40:11.545 --> 01:40:19.156
Now for a lot of this, each different blockchain has slightly different algorithms and slightly different metrics and criteria for doing a lot of this stuff.

928
01:40:19.156 --> 01:40:28.478
So when we're talking about these specific implementations, keep in mind, the exact algorithm might be a little bit different, but the concepts are all still going to be exactly the same.

929
01:40:28.478 --> 01:40:30.873
Hashing and hash function is going to be the same.

930
01:40:30.873 --> 01:40:39.553
No matter where you look at decentralized blockchain, it's going to be the same no matter where you look, how it's actually implemented, is going to be a little bit different.

931
01:40:39.603 --> 01:40:48.070
Now traditionally, when you run an application, you will be website or something that connects to some server, you are interacting with a centralized entity.

932
01:40:48.070 --> 01:40:55.604
And unlike how we saw with the blockchain with multiple different peers, it's going to be run by a single centralized group.

933
01:40:55.604 --> 01:41:07.873
Now, it still could be run on many different servers, but all those servers are still going to be controlled by the same centralized group blockchains, as we saw run on a network of different independent nodes.

934
01:41:07.873 --> 01:41:09.908
When we saw a peer, a peer, B Piercey.

935
01:41:09.908 --> 01:41:16.556
Those were different examples of different independent users running the blockchain technology on their own node.

936
01:41:16.556 --> 01:41:21.623
Now, when I use the term node, I'm usually referring to a single instance of a decentralized system.

937
01:41:21.623 --> 01:41:32.561
So when I say a single node, when I'm talking about a blockchain, I'm talking about one of those pure A's pure BS pure C's running that blockchain software, I'm talking about one server running this technology.

938
01:41:32.561 --> 01:41:34.088
And again, it's this network.

939
01:41:34.088 --> 01:41:39.085
It's this combination of these nodes interacting with each other, that creates this entire blockchain.

940
01:41:39.085 --> 01:41:42.436
What makes these so potent too, is that anybody can join the network.

941
01:41:42.436 --> 01:41:49.943
And that's why there's decentralized the barrier to entry is a little bit of hardware requirements for getting the correct materials to run the software.

942
01:41:49.943 --> 01:41:53.150
And then you running the software, anybody can join these networks and participate.

943
01:41:53.150 --> 01:41:55.363
And that's what makes it truly decentralized.

944
01:41:55.363 --> 01:42:00.226
In fact, you can go to GitHub right now, and run your own Aetherium node in a few seconds.

945
01:42:00.226 --> 01:42:05.149
Now in the traditional world, applications are run by centralized entities.

946
01:42:05.149 --> 01:42:14.448
And if that entity goes down, or is maliciously bribed, or decides that they want to shut off, they just can't, because they are the ones that control everything.

947
01:42:14.448 --> 01:42:17.709
blockchains, by contrast, don't have this problem.

948
01:42:17.709 --> 01:42:31.080
If one node or one entity that runs several nodes goes down, since there are so many other independent nodes running that it doesn't matter, the blockchain and the system will persist so long as there is at least one node always running.

949
01:42:31.080 --> 01:42:38.122
And luckily for us, most of the most popular chains like Bitcoin and Aetherium, have 1000s and 1000s of nodes.

950
01:42:38.122 --> 01:42:53.480
And as we showed in our demo, if one node acts maliciously, all the other nodes will ignore that node and kick that out or even punish it in some systems, because they can easily check everybody else's node and see, okay, this one is out of sync with the majority.

951
01:42:53.480 --> 01:42:56.340
And yes, majority rules when it comes to the blockchain.

952
01:42:56.340 --> 01:43:09.118
Each blockchain keeps a full list of every transaction and interaction that's happened on that blockchain and we saw if a node tries to act maliciously, then all their hashes are going to be way out of whack and they're not going to match everybody else.

953
01:43:09.118 --> 01:43:14.729
This gives blockchains this incredibly potent immutability trait where nothing can be changed or corrupted.

954
01:43:14.729 --> 01:43:19.070
So in essence, we can think of a blockchain as a decentralized database.

955
01:43:19.070 --> 01:43:25.848
And with Aetherium, it has an extra additional feature where it also can do computation in a decentralized manner.

956
01:43:25.848 --> 01:43:30.987
Now let's talk consensus, proof of work and proof of stake because you've probably heard these before.

957
01:43:30.987 --> 01:43:34.482
And they're really important to how these blockchains actually work.

958
01:43:34.482 --> 01:43:38.058
We went through that blockchain example, and we did that mining feature.

959
01:43:38.058 --> 01:43:40.446
This is what's known as proof of work.

960
01:43:40.446 --> 01:43:49.038
Proof of Work and proof of steak fall under this umbrella of consensus and consensus is a really important topic when it comes to blockchains.

961
01:43:49.038 --> 01:43:57.675
Consensus is defined as the mechanism used to reach an agreement on the state or a single value on the blockchain, especially in a decentralized system.

962
01:43:57.675 --> 01:44:08.100
I briefly alluded to this consensus mechanism in our blockchain example, when I said if one change is something and the other two, don't, then majority will rule and kick that one out.

963
01:44:08.100 --> 01:44:10.303
This is part of that consensus mechanism.

964
01:44:10.303 --> 01:44:26.970
Now very roughly a consensus protocol in a blockchain or decentralized system can be broken down into two pieces, a chain selection algorithm, and a civil resistance mechanism, that mining piece that we were doing, or where the proof of work algorithm is what's known as a civil resistance mechanism.

965
01:44:26.970 --> 01:44:29.731
And this is what Aetherium and Bitcoin currently use.

966
01:44:29.731 --> 01:44:35.362
Please note that depending on when you're watching this, if eath two is out, then it's no longer proof of work.

967
01:44:35.362 --> 01:45:01.306
Now, proof of work is known as a civil resistance mechanism, because it defines a way to figure out who is the block author, which node is going to be the node who did the work to find that mine and be the author of that block so all the other nodes can verify that it's accurate civil resistance is a blockchains ability to defend against users creating a large number of pseudo anonymous identities to gain a disproportionately advantageous influence is over set system.

968
01:45:01.306 --> 01:45:09.329
And in layman's terms, it's basically a way for a blockchain to defend against somebody making a bunch of fake blockchains so that they can get more and more rewards.

969
01:45:09.329 --> 01:45:13.257
Now, there are two types of civil resistance mechanisms that we're going to talk about here.

970
01:45:13.257 --> 01:45:15.864
Namely proof of work and proof of stake.

971
01:45:15.864 --> 01:45:19.800
Let's talk about proof of work a little bit more in depth first, in proof of work.

972
01:45:19.800 --> 01:45:33.615
This is civil resistant, because a single node has to go through a very computationally expensive process called mining, which we demonstrated earlier to figure out the answer to the blockchains Riddle of finding that correct nonce, or, or whatever the blockchain system has in place.

973
01:45:33.615 --> 01:45:34.205
And proof of work.

974
01:45:34.205 --> 01:45:51.683
This works because no matter how many pseudo anonymous accounts you make, each one still has to undergo this very computationally expensive activity of finding the answer to the proof of work problem, or the proof of work riddle, which again, in our demonstration, it was finding a nonce with that first four zeros.

975
01:45:51.683 --> 01:45:56.125
But again, each blockchain might change the riddle work or change the problem to be a little bit different.

976
01:45:56.125 --> 01:46:05.855
In fact, some of these blockchains make this riddle intentionally hard or intentionally easy to change what's called the block time, the block time is how long it takes between blocks being published.

977
01:46:05.855 --> 01:46:08.769
And it's proportional to how hard these algorithms are.

978
01:46:08.769 --> 01:46:11.127
So these problems actually can change.

979
01:46:11.127 --> 01:46:13.763
Depending on how long they want the blockchain to be.

980
01:46:13.763 --> 01:46:19.371
If a system wants to block time to be very, very long, they just make the problem very, very hard.

981
01:46:19.371 --> 01:46:22.721
If they wanted to be very short, they make the problem a lot easier.

982
01:46:22.721 --> 01:46:25.922
We'll talk about civil attacks in a little bit and how they can affect the system.

983
01:46:25.922 --> 01:46:31.971
But with proof of work, it's a verifiable way to figure out who the block author is and be civil resistant.

984
01:46:31.971 --> 01:46:35.948
Now, you need to combine this with a chain selection rule create this consensus.

985
01:46:35.948 --> 01:46:42.232
Now, there's some consensus protocols that have more features, but very, very roughly, these are the two pieces that we're going to look at.

986
01:46:42.232 --> 01:46:45.278
The second piece is going to be a chain selection rule.

987
01:46:45.278 --> 01:46:54.801
How do we know which blockchain is actually the real blockchain and the true blockchain now on Bitcoin and Aetherium, they both use a form of consensus called Nakamoto consensus.

988
01:46:54.801 --> 01:47:07.577
And this is a combination of proof of work and longest chain rule, the decentralized network side that whichever blockchain has the longest chain, or the most number of blocks on it is going to be the chain that they use.

989
01:47:07.642 --> 01:47:14.575
This makes a lot of sense, because every additional block that a chain is behind, it's going to take more and more computation for it to come up.

990
01:47:14.575 --> 01:47:18.853
That's why when we saw in our transaction, we actually saw confirmations.

991
01:47:18.853 --> 01:47:25.850
The number of confirmations is the number of additional blocks added on after our transaction went through in a block.

992
01:47:25.850 --> 01:47:33.263
So if we see confirmations as to it means that the block that our transaction was in has two blocks ahead of it in the longest chain.

993
01:47:33.263 --> 01:47:37.597
Now, I do want to point out that a lot of people use proof of work as a consensus protocol.

994
01:47:37.597 --> 01:47:43.041
And I do want to say that this is a little bit inaccurate, but sometimes people use it interchangeably.

995
01:47:43.041 --> 01:47:48.373
Proof of Work is a piece of the overall consensus protocol, which in Bitcoin and Aetherium.

996
01:47:48.373 --> 01:47:59.243
One current case is Nakamoto consensus, Nakamoto consensus is a combination of proof of work, and this longest chain rule, both equally and very, very important.

997
01:47:59.243 --> 01:48:10.035
Now, proof of work also tells us where these transaction fees and these block rewards go to remember how when we made this transaction, we had to talk about gas and a transaction fee.

998
01:48:10.035 --> 01:48:24.105
So who's getting paid who was getting this transaction, and this transaction fee is going to the miners or the validators in a proof of work network? They're called miners and in the proof of stake network, they're called validators there are a little bit different.

999
01:48:24.105 --> 01:48:27.665
And we'll get into that when we talk about proof of stake in this proof of work system.

1000
01:48:27.665 --> 01:48:32.486
All these nodes are competing against each other to find the answer to the blockchain riddle.

1001
01:48:32.486 --> 01:48:37.037
Remember, in our example, it was to find a hash that has four zeros at the start.

1002
01:48:37.037 --> 01:48:41.962
And again, depending on the blockchain implementation, that riddle is going to be a little bit different.

1003
01:48:41.962 --> 01:48:47.410
But all the nodes are trying as many as possible to try to get this answer first.

1004
01:48:47.410 --> 01:48:53.855
Why? Because the first node to figure out the answer to the blockchain real is gonna get that transaction fee, they're gonna get paid from that.

1005
01:48:53.855 --> 01:48:57.523
Now, when a node gets paid, they actually get paid in two different ways.

1006
01:48:57.523 --> 01:48:59.555
One is going to be with a transaction fee.

1007
01:48:59.653 --> 01:49:01.986
And another piece is going to be the block reward.

1008
01:49:02.653 --> 01:49:16.583
we talked about alternating the gas price or the gray on our transaction? Well, that's the transaction fee that we're going to pay to these blockchain nodes for including our transaction, the block reward is given to these nodes from the protocol from the blockchain itself.

1009
01:49:16.583 --> 01:49:27.036
You've probably heard of the Bitcoin halving before the halving is referring to this block reward getting cut in half and it's supposed to be cut in half, roughly every four years.

1010
01:49:27.036 --> 01:49:32.946
This block reward increases the circulating amount of whatever cryptocurrency that is being rewarded.

1011
01:49:32.946 --> 01:49:38.542
For example, on Aetherium the block reward is giving out Aetherium and a Bitcoin the block reward is giving out Bitcoin.

1012
01:49:38.542 --> 01:49:50.523
So these nodes are competing against each other to be the first one to find this transaction to be the first one to find the answer to this problem, so that they can be the ones to win both this block reward and your transaction fee.

1013
01:49:50.523 --> 01:49:59.970
Some block chains like Bitcoin, for example, have a set time when they're no longer going to give out block rewards and the miners or the nodes are only going to get paid from trends.

1014
01:49:59.970 --> 01:50:00.756
Action fees.

1015
01:50:00.756 --> 01:50:05.506
Now this gas fee, again is paid by whoever initialize the transaction.

1016
01:50:05.506 --> 01:50:12.126
When we got our funds from the faucet, there was some server and somebody else was paying the transaction fee for us.

1017
01:50:12.126 --> 01:50:20.026
However, when we sent ether from one account to another, our first account actually paid some transaction fee to send that ether.

1018
01:50:20.026 --> 01:50:21.105
In proof of steak.

1019
01:50:21.105 --> 01:50:25.061
There's also a gas fee, but it's paid out to validators instead of miners.

1020
01:50:25.061 --> 01:50:27.145
And we'll talk about that in a little bit.

1021
01:50:27.145 --> 01:50:30.862
Now let's talk about two types of attacks that can happen in these blockchain worlds.

1022
01:50:30.862 --> 01:50:33.317
Let's talk about the first one being the Sybil attack.

1023
01:50:33.317 --> 01:50:39.292
The Sybil attack is when a user creates a whole bunch of pseudo anonymous accounts to try to influence a network.

1024
01:50:39.292 --> 01:50:49.981
Now, obviously, on Bitcoin and Aetherium, this is really, really difficult because user needs to do all this work in proof of work or have a ton of collateral and proof of stake, which again, we'll talk about in a bit.

1025
01:50:49.981 --> 01:50:53.949
The other more prevalent attack is what's known as a 51% attack.

1026
01:50:53.949 --> 01:51:06.038
Now, as we saw as part of our consensus protocol, these block chains are going to agree that the longest chain is the one that they're going to go with, so long as it matches up with 51% of the rest of the network.

1027
01:51:06.038 --> 01:51:16.428
This means that if you have the longest chain, and you have more than 51% of the rest of the network, you can do what's called a fork in the network, and bring the network onto your now longest chain.

1028
01:51:16.428 --> 01:51:27.536
Now Sybil attacks, obviously, are when a single node or a single entity tries to affect the decent reality of the network by pretending to be multiple different people, although they're just the same person or entity.

1029
01:51:27.536 --> 01:51:31.474
And like I said, it's really difficult to do in proof of work and proof of steak.

1030
01:51:31.474 --> 01:51:40.378
So you can see now that blockchains are very democratic, whichever blockchain has the most buy in and is the longest is the blockchain that the whole system is going to corroborate.

1031
01:51:40.378 --> 01:51:49.354
When nodes produce a new block and add to the longest chain, the other nodes will follow this longest chain that the rest of the network is agreeing with, add those blocks to their chain and follow up.

1032
01:51:49.354 --> 01:52:01.202
So very small reorganizations are actually pretty common when a blockchain picks a block from a different longest chain puts it on and then has to swap it out for another block and continue with a different blockchain.

1033
01:52:01.202 --> 01:52:10.350
However, if a group of nodes had enough nodes or enough power, they could essentially be 51% of the network and influence the network in whatever direction that they want it.

1034
01:52:10.350 --> 01:52:12.478
This is what's known as a 51% attack.

1035
01:52:12.478 --> 01:52:16.850
And it's happened on blockchains like Ethereum classic, which is not Aetherium.

1036
01:52:16.850 --> 01:52:21.617
This is why the bigger a blockchain is, the more decentralized and the more secure it becomes.

1037
01:52:21.673 --> 01:52:31.568
So after you watch this video, and you become a blockchain engineering expert, I definitely recommend you run a node as well, because you are going to increase the security of the network as a whole by running a node.

1038
01:52:31.568 --> 01:52:39.068
So proof of work is fantastic because it allows us to very easily protect against the Sybil attacks and keep our blockchain is decentralized and secure.

1039
01:52:39.068 --> 01:52:41.625
However, it has some drawbacks as well.

1040
01:52:41.625 --> 01:52:49.135
Proof of Work costs a lot of electricity, because every single node is running as fast as they can to win this race to get the rewards.

1041
01:52:49.135 --> 01:52:52.282
This leads to obviously an environmental impact.

1042
01:52:52.282 --> 01:53:04.057
Now since proof of work and Nakamoto consensus, a lot of other protocols have taken this idea and gone in a different direction with a different civil resistance protocol, a lot of them with the intention to be a lot more environmentally friendly.

1043
01:53:04.057 --> 01:53:06.580
And the most popular one right now is proof of stake.

1044
01:53:06.677 --> 01:53:11.978
There are some chains that are already using this proof of stake protocol, and that are live and thriving.

1045
01:53:11.978 --> 01:53:20.265
Some of them are like avalanche, LaLana, Polygon, polka dot and Terra and additionally Aetherium is decided to upgrade to eath.

1046
01:53:20.265 --> 01:53:26.632
Two, which will have this proof of stake algorithm as well, it will also have some other features, which we'll talk about in a bit.

1047
01:53:26.680 --> 01:53:31.394
Now as a quick aside, all the tools that we're going to learn here are still going to work in eath.

1048
01:53:31.394 --> 01:53:34.188
Two, so depending on when you watch this, everything here is still valid.

1049
01:53:34.188 --> 01:53:35.697
So let's talk about proof of stake.

1050
01:53:35.697 --> 01:53:38.618
Now, again, this is a different civil resistance mechanism.

1051
01:53:38.618 --> 01:53:49.297
Instead of solving this difficult problem, proof of stake nodes put up some collateral that they're going to behave honestly, aka, they stake in the example of Aetherium.

1052
01:53:49.297 --> 01:53:58.913
two nodes put up some Aetherium as a stake that they're going to behave honestly in the network, if they misbehave to the network, they are going to be slashed or remove some of their steak.

1053
01:53:58.913 --> 01:54:01.589
Obviously, this is a very good civil resistance mechanism.

1054
01:54:01.683 --> 01:54:08.250
Because if you try to create a whole bunch of anonymous accounts, then each one of those accounts, you have to put up some stake.

1055
01:54:08.250 --> 01:54:13.636
And if you misbehave, you're going to run the risk of losing all the money that you put up as collateral.

1056
01:54:13.684 --> 01:54:20.547
In this system, miners are actually called validators because they're no longer binding anything, they're actually just validating other nodes.

1057
01:54:20.547 --> 01:54:34.720
Now, unlike proof of work, which every node is racing to be the first one to find the block, and proof of stake nodes are actually randomly chosen to propose the new block and then the rest of the validators will validate if that node has proposed the block.

1058
01:54:34.720 --> 01:54:43.014
Honestly, as we saw with our cryptography lesson, it's usually very easy for other nodes to verify if a proposal or a transaction is honest.

1059
01:54:43.014 --> 01:54:46.720
Now randomness is a really important topic when we're talking about blockchains.

1060
01:54:46.720 --> 01:54:50.114
Because keep in mind, these blockchains are deterministic systems.

1061
01:54:50.114 --> 01:54:52.988
They're walled gardens from the rest of the world.

1062
01:54:52.988 --> 01:54:57.755
And as you know, a deterministic system by definition can't have random numbers.

1063
01:54:57.755 --> 01:55:10.530
So how do we choose the random validators in the system? While it changes from blockchain to blockchain, and actually choosing the node will change blockchain to blockchain, but eath two, they're using what's called Rand doubt, at least for the original implementation.

1064
01:55:10.530 --> 01:55:17.893
This is a decentralized autonomous organization that collectively chooses the random number and collectively chooses which node is going to run.

1065
01:55:17.893 --> 01:55:22.585
Next, we aren't going to dive too deep into this because there's a good chance that this might change in the future.

1066
01:55:22.585 --> 01:55:25.991
But we will go into randomness solutions and blockchain later on in this course.

1067
01:55:25.991 --> 01:55:31.992
Now, proof of stake obviously has some pros and cons as well, pros are that again, it is a great civil resistance mechanism.

1068
01:55:31.992 --> 01:55:34.803
And a great way to figure out who the author of a block should be.

1069
01:55:34.803 --> 01:55:45.015
The other pros are that it's way less computationally expensive to figure out the new block, because instead of every single node on the network trying to do this, only one node needs to do this.

1070
01:55:45.015 --> 01:55:48.145
And then the rest of the nodes just need to validate it.

1071
01:55:48.145 --> 01:55:55.134
The cons are that it's usually considered a slightly less decentralized network, due to the upfront staking costs it cost to participate.

1072
01:55:55.134 --> 01:56:00.456
Now, this gets into a little bit of a philosophical battle on how decentralized is decentralized enough.

1073
01:56:00.456 --> 01:56:02.773
And I think that's up to the community to decide.

1074
01:56:02.773 --> 01:56:07.000
And as we progress, I think we'll learn more and more about how decentralized is decentralized enough.

1075
01:56:07.000 --> 01:56:14.264
The general consensus amongst blockchain engineers, though, is that proof of stake is very, very decentralized and very secure.

1076
01:56:14.264 --> 01:56:19.646
This massive environmental impact improvement is one of the two main reasons why eath is shifting to eath.

1077
01:56:19.697 --> 01:56:21.911
Two, it reduces the environmental impact by up to 99%.

1078
01:56:21.911 --> 01:56:26.397
Now, these are the main pieces of proof of work and proof of stake.

1079
01:56:26.397 --> 01:56:31.001
But I did want to talk about another concept that's really important in these ecosystems.

1080
01:56:31.001 --> 01:56:32.309
And that is scalability.

1081
01:56:32.309 --> 01:56:44.190
When we were talking about gas prices, we were saying that the gas prices can get really high if a lot of people want to send a transaction, because a block only has so much black space, and the nodes can only add so many notes.

1082
01:56:44.190 --> 01:56:48.604
So when a lot of people want to use a blockchain, the gas price skyrockets.

1083
01:56:48.604 --> 01:56:57.278
This is not very scalable, because if we want to add more and more people to these blockchains, it's going to cost more and more to use the blockchains.

1084
01:56:57.278 --> 01:57:00.401
Because more people are going to want to get into these blocks.

1085
01:57:00.401 --> 01:57:07.210
This means that there's kind of a ceiling to how many people can use the system because of the financial constraints that will get imposed as gas prices keep rising.

1086
01:57:07.210 --> 01:57:16.202
Aetherium too is not only attacking the environmental impact of proof of work by switching to proof of steak, but they're also implementing this new methodology called sharding.

1087
01:57:16.202 --> 01:57:31.780
And sharding is a solution to the scalability problem, a sharded blockchain really just means that it's going to be a blockchain of blockchains there's a main chain that's going to coordinate everything amongst several chains that hook into this main chain.

1088
01:57:31.780 --> 01:57:51.838
This means that there's more chains for people to make transactions on effectively increasing the amount of block space that there is sharding can greatly increase the number of transactions on a blockchain layer one now there's another term that might be the first time you heard it, a layer one, we're going to talk about layer one and layer twos in terms of scalability really quickly as well.

1089
01:57:51.838 --> 01:58:03.948
A layer one refers to any base layer blockchain implementation Bitcoins, a layer one Aetherium the layer one avalanches, a layer one, these are the base layer blockchain solutions.

1090
01:58:03.948 --> 01:58:10.199
A layer two is any application that is added on top of a layer one added on top of the blockchain.

1091
01:58:10.199 --> 01:58:14.508
Some examples of layer twos are going to be chain link arbitrage, or optimism.

1092
01:58:14.508 --> 01:58:21.209
Arbitrage and optimism are very interesting because they are layer twos that also look to solve this scalability issue.

1093
01:58:21.209 --> 01:58:32.219
Arbitrage and optimism are what's known as roll ups and they roll up their transactions into a layer one like Aetherium, we're not going to go too deep into roll ups and how they actually work.

1094
01:58:32.219 --> 01:58:40.578
But all you really need to know is that a roll up is kind of like a sharded chain, they derive their security from the base layer from the layer one like Aetherium.

1095
01:58:40.578 --> 01:58:51.966
And they bulk send their transactions onto the layer one, they solve some of the scalability issues by being another blockchain that people can make transactions on, still on kind of this base Aetherium layer.

1096
01:58:51.966 --> 01:58:53.949
Now they're different from side chains.

1097
01:58:53.949 --> 01:59:01.024
Because side chains derive their security from their own protocols, roll ups, derive their security from the base layers.

1098
01:59:01.024 --> 01:59:05.126
So arbitrage and optimism, for example, is going to be just about as secure as Aetherium.

1099
01:59:05.126 --> 01:59:10.604
There's some fantastic guys in there that go a little bit deeper into roll ups and I've left a link in the description for you.

1100
01:59:10.604 --> 01:59:13.026
All right, so we just talked about a lot of stuff.

1101
01:59:13.026 --> 01:59:15.713
So let's do a quick recap before moving on.

1102
01:59:15.713 --> 01:59:34.979
Aetherium and Bitcoin are currently both proof of work blockchains that follow Nakamoto consensus, however, Aetherium is moving to Aetherium two, which will be a proof of stake sharded blockchain Sybil attacks are prevented due to protocols like proof of work and proof of steak 51% attacks grow increasingly harder with the size of blockchain.

1103
01:59:34.979 --> 01:59:47.289
So you should run a node consensus is the mechanism that allows a blockchain to agree upon what the state of the blockchain is sharding and roll ups are solutions to scalability issues on layer ones.

1104
01:59:47.289 --> 01:59:51.568
Layer One is any based blockchain implementation like Bitcoin or Aetherium.

1105
01:59:51.568 --> 01:59:57.468
A blockchain scalability problem is that there's not always enough block space for the amount of transactions that want to get in them.

1106
01:59:57.468 --> 02:00:04.628
This leads to very high gas prices and a Again, gas prices or how much it costs to interact with the blockchain.

1107
02:00:04.719 --> 02:00:09.409
So that's it for the blockchain basics and the blockchain explainers.

1108
02:00:09.409 --> 02:00:16.769
With just this information, you now can go off into the world and start working with blockchains and interacting with blockchains.

1109
02:00:16.769 --> 02:00:24.524
With at least some level of knowledge as to what's going on, you should be incredibly proud of yourself for just making it this far.

1110
02:00:24.524 --> 02:00:29.221
Definitely be sure to give yourself a pat on the back and a round of applause.

1111
02:00:29.221 --> 02:00:34.932
Now that we've gotten a lot of the basics and the fundamentals of the way, let's start jumping into the coding aspect.

1112
02:00:34.932 --> 02:00:43.573
This is where you're going to learn how to actually build these smart contracts, how to build these trust minimized agreements, in these blockchains.

1113
02:00:43.573 --> 02:00:45.373
And in the smart contract platforms.

1114
02:00:45.373 --> 02:00:58.649
This next section, this solidity basics, the solidity fundamentals section will give you all the skills to start actually coding solidity and understanding how these smart contracts work underneath the hood.

1115
02:00:58.649 --> 02:01:12.797
So at this point, absolutely, give yourself a high five, maybe say hi, in the GitHub discussions, maybe say hi in the community, on Twitter, on Reddit, etc, and be proud of just making it this far, the journey has really only just begun, but you've already learned so much.

1116
02:01:12.797 --> 02:01:14.868
Let's begin the next section.

1117
02:01:14.868 --> 02:01:19.516
And let's jump into the code.

1118
02:01:19.727 --> 02:01:26.477
Now that we're getting to the coding sections, I need to stress to absolutely use the GitHub repository associated with this course.

1119
02:01:26.477 --> 02:01:32.540
If you come to the GitHub repo, and you scroll down, and you click the lesson that we're on right now, we're on lesson two.

1120
02:01:32.540 --> 02:01:34.602
Welcome to remix, simple storage.

1121
02:01:34.602 --> 02:01:41.462
If you click on it, it'll give you a ton of timestamps and, and other helpful links associated with this lesson.

1122
02:01:41.462 --> 02:01:47.499
Additionally, the biggest piece is that all the code will be available right underneath the lesson title.

1123
02:01:47.499 --> 02:01:54.697
This will have all the code that we're going to be working with, as well as some more additional information on how to work with the code.

1124
02:01:54.697 --> 02:02:02.108
Please, when asking questions and entering in discussions, though, please ask your questions and the full blockchain solidity course repository.

1125
02:02:02.108 --> 02:02:02.485
Thank you.

1126
02:02:02.485 --> 02:02:07.431
And if we're at the top of the repository, and we scroll down, we have the resources for this course section.

1127
02:02:07.431 --> 02:02:13.619
Which brings us to the GitHub discussions in which you can ask questions in the GitHub discussion section of this course.

1128
02:02:13.619 --> 02:02:18.698
Additionally, on Stack Exchange, Aetherium, or at Stack Overflow.

1129
02:02:18.698 --> 02:02:39.887
I'll talk a little bit about how to format questions and ask questions the best way so that you have the highest chance of getting a good answer in a later lesson, I highly recommend you pause and make accounts for Stack Exchange Aetherium, Stack Overflow, and GitHub right now, if you haven't already, links to them, of course, can be found in our GitHub repository.

1130
02:02:39.887 --> 02:02:50.529
Typically, for each coding section, I'll start it off by giving a quick overview of the code of what we're going to be working with and what we're going to be building towards, since everything that we're doing is going to be project based.

1131
02:02:50.529 --> 02:02:51.671
And that's how we're going to learn.

1132
02:02:51.736 --> 02:02:58.323
For our first one and remix though, we're going to skip over that because there's a lot of stuff to get used to.

1133
02:02:58.323 --> 02:03:00.805
Now, I highly recommend that as I'm coding this.

1134
02:03:00.805 --> 02:03:06.112
And as I'm doing all this in remix, you follow along with me and you code along with me.

1135
02:03:06.112 --> 02:03:09.885
Remember, you can change my speed if I'm coding too fast, or if I'm coding too slow.

1136
02:03:09.885 --> 02:03:12.238
To start, we're going to jump into a tool called remix.

1137
02:03:12.238 --> 02:03:17.345
If you're unsure how to get there, there's a link to remix in our GitHub repository.

1138
02:03:17.345 --> 02:03:20.771
This is where we're gonna be writing all of our code.

1139
02:03:20.771 --> 02:03:25.148
So welcome to the remix IDE, or integrated development environment.

1140
02:03:25.148 --> 02:03:29.707
This is where we're going to learn how to code and interact with our smart contracts.

1141
02:03:29.707 --> 02:03:33.182
If you want, you can go ahead and accept help out remix.

1142
02:03:33.182 --> 02:03:40.062
If you've never been here before, it'll give you a quick walkthrough of some of the tools that remix actually has, we're going to skip over them for now.

1143
02:03:40.062 --> 02:03:41.874
Because I'm gonna explain everything that's going up.

1144
02:03:41.874 --> 02:03:48.791
Remix is such a powerful tool because it has a lot of features that allow us to really see and interact with our smart contracts.

1145
02:03:48.791 --> 02:03:53.542
Eventually, we're going to move off of remix, actually to a local development environment.

1146
02:03:53.542 --> 02:03:57.955
However, remix is absolutely fantastic for learning the fundamentals of solidity.

1147
02:03:57.955 --> 02:04:01.447
And I highly recommend everybody start with remix when they're getting started.

1148
02:04:01.447 --> 02:04:06.366
When you come to the remix IDE, there's a whole lot of different things that are popping out to us.

1149
02:04:06.366 --> 02:04:08.310
There's a lot of different plugins as well.

1150
02:04:08.310 --> 02:04:14.029
Since we're going to be working with solidity, which is going to be the language that we're using to develop our smart contracts.

1151
02:04:14.029 --> 02:04:19.914
We can go ahead and get started by clicking the solidity plugin, and a couple of other tools will show up on the side.

1152
02:04:19.914 --> 02:04:28.697
Even if you don't click the solidity plugin, you'll still be able to code solidity smart contracts, the left hand side is where we're going to start to actually interact with things.

1153
02:04:28.697 --> 02:04:42.484
The button on the top most of the left is our files or explore directories, remix comes boilerplate with some different contracts, some different scripts, some different tests, and different dependencies.

1154
02:04:42.484 --> 02:04:44.665
We are going to minimize this a little bit.

1155
02:04:44.665 --> 02:04:50.640
So if you want to go ahead and right click and delete some of these folders other than the contracts folders, feel free to do so.

1156
02:04:50.640 --> 02:04:54.663
Or if you kind of like them there, feel free to leave them as well.

1157
02:04:54.663 --> 02:05:02.099
We're going to leave our contracts folder and we're going to delete the different files inside of it just so that we can start From a blank slate.

1158
02:05:02.099 --> 02:05:08.132
Most projects come with something known as a readme.

1159
02:05:08.132 --> 02:05:09.536
Usually it's a readme.

1160
02:05:09.536 --> 02:05:12.637
md, which usually explains how to actually work with code.

1161
02:05:12.637 --> 02:05:14.902
But for our purposes, we're going to delete this as well.

1162
02:05:14.902 --> 02:05:16.184
And you can just follow along with me.

1163
02:05:16.184 --> 02:05:29.571
Now we have a blank remix Setup, click on the contracts folder and click the little page icon to create a new file, a little box will pop up and you can start typing text into it.

1164
02:05:29.571 --> 02:05:44.203
We're going to type in simple storage dot Sol, dot Sol tells our compilers that this is going to be a solidity file, and that we're going to code solidity in this solidity is the primary coding language of smart contracts.

1165
02:05:44.203 --> 02:05:47.015
There are a few other smart contract languages as well.

1166
02:05:47.015 --> 02:05:51.944
But solidity by far is the most dominant smart contract coding language out there.

1167
02:05:51.944 --> 02:05:57.592
And now we have a simple storage dot soul contract on the right that we can actually start coding our solidity with.

1168
02:05:57.592 --> 02:05:59.915
So let's start coding some solidity.

1169
02:05:59.915 --> 02:06:08.691
Now if you click on this button right below the files button that looks like the solidity logo, you'll see a bunch of stuff pop up in here.

1170
02:06:08.756 --> 02:06:13.506
These are different parameters for us to actually compile our solidity code so that we can run it.

1171
02:06:13.506 --> 02:06:20.502
So the first thing that you're going to need in any solidity smart contract is going to be the version of solidity that you're going to use.

1172
02:06:20.502 --> 02:06:27.554
And this should always be at the top of your solidity code, solidity is a constantly changing language, and it constantly updating language.

1173
02:06:27.554 --> 02:06:36.681
Because it's relatively new compared to other languages, we need to tell our code, hey, this is the version that I want you to use, we can add the solidity version by doing pragma.

1174
02:06:36.681 --> 02:06:37.373
solidity.

1175
02:06:37.373 --> 02:06:44.127
And then the version that we want to use, if we want to choose a very specific version, we could say zero, point 8.

1176
02:06:44.127 --> 02:06:44.232
7.

1177
02:06:44.232 --> 02:06:48.232
The most current version to date is 0.

1178
02:06:48.232 --> 02:06:48.337
8.

1179
02:06:48.760 --> 02:06:49.160
Point 12.

1180
02:06:51.760 --> 02:06:56.460
is good practice, and different versions of solidity are considered more stable than others.

1181
02:06:56.460 --> 02:06:57.110
Zero point 8.

1182
02:06:57.110 --> 02:07:00.357
7 is one of those versions that is considered more stable.

1183
02:07:00.357 --> 02:07:10.079
These double slashes here are what's known as a comment, there are places where you can type stuff that won't actually get executed in won't get compiled and isn't really considered part of your code.

1184
02:07:10.079 --> 02:07:13.015
For example, I could write Hello all.

1185
02:07:13.015 --> 02:07:13.967
I'm Patrick.

1186
02:07:13.967 --> 02:07:18.709
And if we were going to run this code, this part of my code would get completely ignored.

1187
02:07:18.709 --> 02:07:21.920
So this double backslash is how we do what's called comments.

1188
02:07:21.920 --> 02:07:46.265
And as we're coding, and as we're building our projects, be sure to use this comments tool to your advantage every time you write a new function, or you learn something that you didn't understand, or you learned something new that you want to remember, put it in a comment in your code, you're going to be most effective at taking notes in this course, by making them comments in your code and then saving your code so you can refer back to it later.

1189
02:07:46.265 --> 02:07:49.239
So leave comments in your code, leave notes in your code.

1190
02:07:49.239 --> 02:07:54.104
And that will be one of the best ways for you to understand what you're coding when you want to refer back to it later.

1191
02:07:54.104 --> 02:08:01.488
Now when it comes to the versions of solidity, there's actually a few different ways we can actually write it, we can say we want to use only zero point 8.

1192
02:08:01.488 --> 02:08:01.569
7.

1193
02:08:01.569 --> 02:08:04.519
And this is how we would write that.

1194
02:08:04.767 --> 02:08:08.830
But maybe we're okay if we use a more new version of solidity than zero point 8.

1195
02:08:08.830 --> 02:08:14.498
7 to tell our code that we're okay with a more new version, we can put a little caret here.

1196
02:08:14.498 --> 02:08:16.816
And this is how we tell solidity.

1197
02:08:16.816 --> 02:08:19.477
Hey, any version of zero point 8.

1198
02:08:19.477 --> 02:08:22.235
7 And above is okay for this contract.

1199
02:08:22.235 --> 02:08:23.835
This means zero point 8.

1200
02:08:23.835 --> 02:08:25.821
8 would work zero point 8.

1201
02:08:25.821 --> 02:08:26.084
9 0.

1202
02:08:26.084 --> 02:08:27.400
8 point 10, etc.

1203
02:08:27.400 --> 02:08:30.145
But if we wanted to use just 0.

1204
02:08:30.145 --> 02:08:42.623
17, we would type in like that if we want to use solidity versions between a specific range, we could do something like this, we can say we want our solidity version greater than or equal to zero point 8.

1205
02:08:42.623 --> 02:08:45.377
7 But less than zero point 9.

1206
02:08:45.377 --> 02:08:45.475
0.

1207
02:08:45.771 --> 02:08:49.855
This means that any compiler between zero point 8.

1208
02:08:50.772 --> 02:08:51.318
point 9.

1209
02:08:51.318 --> 02:08:52.255
0 would work.

1210
02:08:52.255 --> 02:08:54.130
This means zero point 8.

1211
02:08:54.130 --> 02:08:55.067
8 would work.

1212
02:08:55.772 --> 02:08:56.355
point 8.

1213
02:08:56.355 --> 02:08:57.521
9 would work 0.

1214
02:08:57.521 --> 02:08:59.271
8 point 10 would work.

1215
02:09:00.773 --> 02:09:00.865
9.

1216
02:09:00.865 --> 02:09:05.941
0 would not work because it is not strictly less than 0.

1217
02:09:06.773 --> 02:09:07.281
00 point 9.

1218
02:09:07.281 --> 02:09:08.349
1 would also not work.

1219
02:09:09.774 --> 02:09:12.274
us, we're going to use zero point 8.

1220
02:09:12.274 --> 02:09:12.345
8.

1221
02:09:13.774 --> 02:09:21.936
solidity that's completed, every completed section needs to end with one of these semicolons this is how you tell solidity it's the end of the line.

1222
02:09:21.936 --> 02:09:27.464
Also at the top of your code, you're always going to want to put what's called an spdx license identifier.

1223
02:09:27.464 --> 02:09:32.490
This is optional, but some compilers will flag your warning that you don't have one.

1224
02:09:32.490 --> 02:09:35.617
This is to make licensing and sharing code a lot easier.

1225
02:09:35.617 --> 02:09:54.727
We have a link to more about how licenses work in the section of this lesson in our GitHub repository to do an spdx license identifier, we just say spdx license identifier, and we're gonna choose MIT, the MIT license is one of the least restrictive licenses out there.

1226
02:09:54.778 --> 02:10:08.429
So we use the MIT license for most of our code samples once you have a version and once you have Is this much written, we can actually go ahead and write to our compiler tab and scroll down and hit Compile, that little turn thing will go.

1227
02:10:08.429 --> 02:10:12.180
And in a minute, we'll see, this contract is attempted to be compiled.

1228
02:10:12.180 --> 02:10:19.408
Since we actually don't have a contract, we see no contract compiled yet, but we see the compiler automatically switched to zero point 8.

1229
02:10:19.408 --> 02:10:19.475
8.

1230
02:10:19.475 --> 02:10:31.443
compiling our code means taking our more human readable code like pragma, solidity and transforming it into computer code, or very specific instructions for the computer to use.

1231
02:10:31.443 --> 02:10:37.485
We'll go over what a lot of this machine level code or this computer level code is doing in a later section.

1232
02:10:37.485 --> 02:10:42.021
If you're using a Mac, you can also hit command S, and it will run the compiler for you as well.

1233
02:10:42.021 --> 02:10:47.449
On Windows, it might be Ctrl S, we can actually choose the compiler version that we want to use.

1234
02:10:47.449 --> 02:10:50.976
However, if we tell in our code to specifically use zero, point 8.

1235
02:10:50.976 --> 02:10:55.646
8, and we hit the compile button, it'll automatically switch to zero point 8.

1236
02:10:55.646 --> 02:10:55.697
8.

1237
02:10:55.697 --> 02:11:00.879
However, if we use the carrot thing, we get specifically say, hey, we want 0.

1238
02:11:00.879 --> 02:11:06.191
8 point 10, we can hit compile, and it will compile with 0.

1239
02:11:06.191 --> 02:11:06.869
8 point 10.

1240
02:11:06.869 --> 02:11:15.703
Because again, remember, the carrot says we want to use at least zero, point eight, all the way up to the latest version of 0.

1241
02:11:15.703 --> 02:11:15.786
8.

1242
02:11:15.786 --> 02:11:18.369
Now let's stay on zero point 8.

1243
02:11:18.369 --> 02:11:18.452
8.

1244
02:11:18.787 --> 02:11:21.208
The next thing that we're going to do in our code is define our contract.

1245
02:11:21.208 --> 02:11:25.453
And to get a full screen view, you can go ahead and hit the compiler button to get rid of it there.

1246
02:11:25.453 --> 02:11:28.684
To start defining our contract, we're gonna go ahead and write the word contract.

1247
02:11:28.684 --> 02:11:40.498
This tells solidity that the next pieces of code is going to be a contract contract is a key word in solidity, and it tells our compiler that the next section of this code is going to define a contract.

1248
02:11:40.498 --> 02:11:46.249
You can think of a contract similar to a class in any object oriented programming like Java or JavaScript.

1249
02:11:46.249 --> 02:11:52.724
Let's go ahead and give our contract a name here, we're going to call RS simple storage.

1250
02:11:52.724 --> 02:11:56.947
And then we add this little open and close curly brackets.

1251
02:11:56.947 --> 02:12:02.130
Everything inside this open and close curly brackets is going to be the contents of this contract.

1252
02:12:02.130 --> 02:12:02.933
Simple Storage.

1253
02:12:02.933 --> 02:12:07.613
Now, if we go ahead and hit command S or Ctrl S, we can see this little green checkmark show up.

1254
02:12:07.613 --> 02:12:14.949
And if you don't, you can always go back to the compiler tab, scroll down and hit Compile and see the little green checkmark.

1255
02:12:14.949 --> 02:12:18.809
That little green checkmark means that our code is compiling successfully.

1256
02:12:18.809 --> 02:12:23.078
And we don't have any errors, we could hypothetically deploy this contract right now.

1257
02:12:23.078 --> 02:12:25.435
And it would be a valid contract.

1258
02:12:25.435 --> 02:12:30.687
So congratulations on writing your first contract.

1259
02:12:30.794 --> 02:12:34.277
Now solidity has multiple different types or primitive data types.

1260
02:12:34.277 --> 02:12:42.080
And if you go to the solidity documentation, which again, is in our GitHub repository, you can read more and learn more about the different types that are in here.

1261
02:12:42.080 --> 02:12:53.609
The four most basic types are going to be Boolean, you int, int, and an address or bytes, which is a lower level type, which we'll talk about a little bit later.

1262
02:12:53.609 --> 02:13:01.750
A boolean define some type of true false, a you int is going to be an unsigned integer, which means it's going to be a whole number that isn't positive or negative.

1263
02:13:01.797 --> 02:13:07.630
It's just positive, we have an integer, which is going to be a positive or negative whole number.

1264
02:13:07.630 --> 02:13:13.475
And then we have an address, which is going to be an address, like what we see in our meta mask here.

1265
02:13:13.475 --> 02:13:16.486
There are some other types as well that you'll learn later on.

1266
02:13:16.486 --> 02:13:21.764
The reason that we have these types is we use them to define what different variables are.

1267
02:13:21.764 --> 02:13:24.667
Variables are basically holders for different values.

1268
02:13:24.667 --> 02:13:33.868
For example, we could create a variable called has favorite number to represent if somebody has a favorite number.

1269
02:13:33.868 --> 02:13:44.210
And we would put this bull keyword before has to renumber say, Okay, we have a variable called has favorite number, and it's of type boolean.

1270
02:13:44.210 --> 02:13:52.411
So this has favorite number is going to represent a true or a false to set its value, we could say has favorite number equals true.

1271
02:13:52.411 --> 02:13:55.318
Now has favorite number is going to be true.

1272
02:13:55.318 --> 02:13:58.525
We could also say has favorite number equals false.

1273
02:13:58.525 --> 02:14:02.524
So this Boolean has faded number is now going to be false.

1274
02:14:02.524 --> 02:14:09.703
For uns we could say you went favorite number equals and then set a number 123.

1275
02:14:09.703 --> 02:14:23.968
This means that our favorite number is going to be 123 You'll enter is special because we can actually specify how many bits want to allocate to this number bits and bytes are pretty fundamental pieces of information for computer science.

1276
02:14:23.968 --> 02:14:25.385
We're not going to go over it here.

1277
02:14:25.385 --> 02:14:29.460
However, there's a fantastic video in the GitHub repository that explains it more.

1278
02:14:29.460 --> 02:14:33.513
Basically, it's how much storage or memory to allocate to this number.

1279
02:14:33.513 --> 02:14:39.999
How big can it get, if we say a you int eight can have eight bits all the way up to you went to 56.

1280
02:14:39.999 --> 02:14:45.521
If you don't specify how big it is, it automatically defaults to you into 256.

1281
02:14:45.521 --> 02:14:49.207
Oftentimes, it's better when writing our code to be very explicit.

1282
02:14:49.207 --> 02:14:53.536
So usually you'll see me just do you int 256 to represent a un 256.

1283
02:14:53.536 --> 02:14:59.712
We could also do an int favorite number equals 123 or an int 256.

1284
02:14:59.809 --> 02:15:04.647
I'm just Going to go ahead and add this Boolean back here, we're going to change this back to UNT to 36.

1285
02:15:04.647 --> 02:15:31.713
And let's change our favorite number to five here, we could also do something called strings, string, favorite number in text equals five strings represent basically words, and you can represent them by putting them in these quotes, it's going to be some word or phrase, or really, really just kind of any combination of keystrokes in here, our ends can be positive or negative.

1286
02:15:31.713 --> 02:15:45.707
So we could say, negative five or positive five, both are going to be valid, since we can also do address my address equals and grab our address, right from Metamask.

1287
02:15:45.813 --> 02:15:50.980
And paste it in, you'll notice that we end all of these lines of code with the semicolon.

1288
02:15:50.980 --> 02:15:57.068
We also have bytes objects, or a bytes 32, again, representing how many bytes we want them to be.

1289
02:15:57.068 --> 02:16:06.266
And this says that we have called favorite bytes, and we're just gonna set it equal to cat.

1290
02:16:06.266 --> 02:16:21.160
So strings are actually really interesting, because strings are secretly just bytes objects, but only for text to a cat is actually a string, but can automatically get converted into one of these bytes object bytes, objects typically look like 0x.

1291
02:16:21.160 --> 02:16:28.709
And then some random letters and numbers that represent the bytes object, but cat can automatically get converted down to bytes.

1292
02:16:28.709 --> 02:16:42.475
We'll talk about bytes more in coming sessions, you can also do bytes, two bytes, three bytes, five bytes 22, you get the picture for our uns and our into the sixth lowest we can go is eight bits, because eight bits is a byte.

1293
02:16:42.475 --> 02:16:44.115
And we can go up by steps of eight.

1294
02:16:44.115 --> 02:16:48.157
So we can do 816 32, etc, all the way to 256.

1295
02:16:48.157 --> 02:16:53.042
For example, down here, we can't do bytes 64.

1296
02:16:53.042 --> 02:17:00.463
And if we go ahead and try to compile this, we get a little red thing here.

1297
02:17:00.463 --> 02:17:06.175
And if we scroll down, we get a declaration error identifier not found or not unique.

1298
02:17:06.175 --> 02:17:08.446
Bytes 64 favorite bytes equals cats.

1299
02:17:08.446 --> 02:17:12.000
And we even got a little red warning sign here in our remix.

1300
02:17:12.000 --> 02:17:15.297
This is remix telling us there's something wrong with this line.

1301
02:17:15.297 --> 02:17:16.951
So we can switch back to bite 32.

1302
02:17:16.951 --> 02:17:26.013
Since byte 32 is the maximum size that a bytes can be, you could also do just a bytes object, which means it can have any size, but we typically want to be explicit.

1303
02:17:26.013 --> 02:17:35.485
And we're going to stick with bytes 32 For now want to learn more about the different types and how to use them and all the different features with them, be sure to check out the solidity documentation.

1304
02:17:35.485 --> 02:17:39.217
For now for our simple storage, let's say we only want to store numbers.

1305
02:17:39.217 --> 02:17:45.725
So let's go ahead and delete everything except for the favorite number section.

1306
02:17:45.825 --> 02:17:59.969
Now in solidity, if I do this, and I remove the equals five, this favorite number actually does get set to a default value, the default value for solidity is going to be whatever the null value is, which in solidity is case zero.

1307
02:17:59.969 --> 02:18:09.038
So saying you Intuit six favorite number is going to be the same as saying you 256 favorite number equals zero since it gets initialized to zero.

1308
02:18:09.038 --> 02:18:11.564
So for now, let's not initialize it to anything.

1309
02:18:11.564 --> 02:18:15.759
So that favorite number will automatically start off as zero.

1310
02:18:15.828 --> 02:18:23.201
Now, if you get confused, as you're coding along, and you're following along with me, be sure to write comments in your code so you know what's going on.

1311
02:18:23.201 --> 02:18:30.338
So maybe, for example, a great comment here would be this gets initially alized to zero.

1312
02:18:30.338 --> 02:18:39.709
And then if that's even confusing, you could say, this means that this section is a comment.

1313
02:18:39.709 --> 02:19:08.433
Now let's go ahead and create a function functions or methods are self contained modules that will execute some specific set of instructions for us, when we call it if you're familiar with Java, or Python, or JavaScript or anything like that functions work the exact same way functions get identified by the keyword function, let's create a function called store that will change the value of favorite number to some new value.

1314
02:19:08.433 --> 02:19:14.889
And the number that we're going to change it to is going to be variables that are passed to our store function here.

1315
02:19:14.889 --> 02:19:20.965
So we're going to allow our store function to take a variable of type un 256.

1316
02:19:20.965 --> 02:19:29.116
And we'll call it underscore favorite number, we'll make this a public function, which we'll get to in a minute.

1317
02:19:29.116 --> 02:19:35.353
And all we're going to do is we're going to set favorite number equal to whatever variable that we just passed.

1318
02:19:35.353 --> 02:19:47.722
So now we have this function called store, that it takes some parameter that we're going to give it and it sets this favorite number variable equal to whatever number that we give this function.

1319
02:19:47.722 --> 02:19:52.786
Now to see this actually in action, let's deploy this to an even thicker blockchain than a test net.

1320
02:19:52.838 --> 02:19:56.663
We're going to actually deploy this to a local network or a JavaScript VM.

1321
02:19:56.663 --> 02:20:03.714
And first before we can even do that, let's just make sure that it's going compiling correctly looks like we have a green checkmark, which is good.

1322
02:20:03.714 --> 02:20:08.776
And we'll come down to this button here, which is our deploy and run Transactions tab.

1323
02:20:08.840 --> 02:20:15.332
Our deploy and run Transactions tab has a ton of different configuration pieces for actually deploying this contract.

1324
02:20:15.332 --> 02:20:25.203
First, we want to make sure we are on the JavaScript VM London piece here, JavaScript VM means we're going to be deploying to a fake local JavaScript VM.

1325
02:20:25.203 --> 02:20:40.859
The JavaScript VM is a fake local blockchain where we can simulate transactions really quickly without having to wait for them to go through on a test net, don't worry about the London versus Berlin piece here for now, injected web three and web three provider we'll talk about in a little bit.

1326
02:20:40.859 --> 02:20:42.746
We also have this account section here.

1327
02:20:42.843 --> 02:20:51.134
When we run on our fake JavaScript VM, we're given a whole bunch of fake accounts from where to deploy from, and we're given 100 eath.

1328
02:20:51.134 --> 02:21:04.293
For each one of these fake accounts, you can kind of think of it similar to our meta mask account in meta mask, except for the difference here is that this is this fake JavaScript VM Aetherium that we're given.

1329
02:21:04.293 --> 02:21:11.422
For our transactions, including deploying contracts, we're actually given a gas limit, there's also values we can send, and we can choose our contracts.

1330
02:21:11.422 --> 02:21:16.846
Right now we only have one contract, simple storage, so that's going to be the one that we're going to deploy.

1331
02:21:16.846 --> 02:21:23.259
So on the left hand side, to deploy this to our fake JavaScript VM, we're gonna go ahead and hit the Deploy button.

1332
02:21:23.259 --> 02:21:28.561
And if we scroll all the way down to the bottom, now, we can see a contract was deployed.

1333
02:21:28.561 --> 02:21:33.192
It says simple storage at x, blah, blah, blah, blah, blah.

1334
02:21:33.192 --> 02:21:51.235
And we see this orange button store with come this grade text you in 256, underscore favorite number on our fake local blockchain, we're actually given an address every single smart contract, it has an address, just like how our wallets have an address.

1335
02:21:51.235 --> 02:22:03.325
So if we hit this copy button here, and we put it into a comment, make this a little bit bigger, we can see that the address of this contract that we just deployed, is located at this address.

1336
02:22:03.325 --> 02:22:10.783
Additionally, if you pull up the slider over here, you'll be able to see this little green checkmark with all this information about this deployment.

1337
02:22:10.783 --> 02:22:14.805
And you can hit the little drop down and see a whole lot more information about this.

1338
02:22:14.852 --> 02:22:23.116
Something you might notice is you'll see some familiar keywords like status, transaction hash, from to gas, etc.

1339
02:22:23.116 --> 02:22:28.869
When we deploy a contract, it's actually the same as sending a transaction.

1340
02:22:28.869 --> 02:22:36.484
Remember, anytime we do anything on the blockchain, we modify any value, we are sending a transaction.

1341
02:22:36.484 --> 02:22:43.613
So deploying a contract is modifying the blockchain to have this contract, it's modifying the state of the blockchain.

1342
02:22:43.613 --> 02:22:50.708
And if we had sent this on a Rinkeby, or COVID, or main net network, we would have had to spend the gas to actually deploy this contract.

1343
02:22:50.708 --> 02:23:00.260
And this is the simulation of how much gas and the transaction hash and from and to and all this other stuff about our transaction had, we actually deployed it to a real network.

1344
02:23:00.260 --> 02:23:03.416
But since it's JavaScript VM, it's all fake information.

1345
02:23:03.416 --> 02:23:09.367
Now we have this big orange button store, this big orange button resembles the store function that we just created.

1346
02:23:09.367 --> 02:23:17.478
So if we add some number into this store, like 123, and we hit the Store button, we actually call this store button.

1347
02:23:17.478 --> 02:23:20.874
And we actually execute a transaction on our fake Jasika.

1348
02:23:20.874 --> 02:23:25.674
Blockchain to store the number 1234 favorite number.

1349
02:23:25.859 --> 02:23:32.569
And if we scroll all the way up to our account, now, you'll see that we have a little bit less ether in our fake account.

1350
02:23:32.569 --> 02:23:37.463
This is because we spent the gas to actually call this contract.

1351
02:23:37.463 --> 02:23:48.710
And if we pull up this bottom bit here, and I call this with five I call store, you'll see it flashed for a quick second, we sent another transaction to store the value five in our favorite number.

1352
02:23:48.710 --> 02:24:04.175
Now the question might be having is, that's really cool, Patrick, but I can't see what favorite number actually is, how do I know that those transactions are actually going through? Well, right now, the visibility of our favorite number is set to private, so we actually can't see it.

1353
02:24:04.175 --> 02:24:06.731
And we'll talk about visibility in just a second.

1354
02:24:06.731 --> 02:24:08.371
To make it so that we can see it.

1355
02:24:08.371 --> 02:24:11.244
We'll change our favorite numbers visibility to public.

1356
02:24:11.244 --> 02:24:15.553
So let's go ahead, we'll recompile we'll go back to the deploy tab.

1357
02:24:15.553 --> 02:24:20.293
We'll click the little x here, which is to say let's get rid of this contract.

1358
02:24:20.293 --> 02:24:22.373
And it just gets rid of it from our window here.

1359
02:24:22.373 --> 02:24:30.818
It doesn't actually get rid of it from the blockchain, because again, they're immutable, well, kind of immutable, since again, this is kind of a fake simulated chain.

1360
02:24:30.866 --> 02:24:34.366
But we go ahead and compile, and now we hit Deploy again.

1361
02:24:34.866 --> 02:24:38.375
we scroll down, our new contract, will now have two buttons.

1362
02:24:38.375 --> 02:24:40.921
One is the orange button for store.

1363
02:24:40.921 --> 02:24:43.544
But now we have a New Favorite button.

1364
02:24:43.544 --> 02:24:51.308
This button represents this public variable favorite number, and it resembles a function saying, Hey, show me what favorite number is.

1365
02:24:51.308 --> 02:24:59.642
So if I were to click this favorite number button, what do you think will show up? Well, do you remember what this gets initialized to? Well, let's click it now.

1366
02:24:59.642 --> 02:25:06.803
We do indeed See that zero shows up, we see that this is a YouTube ID six, and the value stored in it is zero.

1367
02:25:06.869 --> 02:25:24.905
Now, if I were to change that number to five by calling the store function, and now hitting favorite number, we do indeed see, favorite number gets updated to five functions and variables can have one for visibility specifiers, we have public, private, external, and internal.

1368
02:25:24.905 --> 02:25:35.014
Public is visible externally and internally, meaning anybody who interacts with this contract or sees this contract can see what's stored in this favorite number function.

1369
02:25:35.014 --> 02:25:40.813
You'll see here in the solidity documentation, it says it creates a getter function for the storage slash state variables.

1370
02:25:40.813 --> 02:25:55.585
When we add this keyword public to favorite number, what we're actually doing is we're creating what's called a getter function for favorite number, we're basically creating a function that says to return the value of favorite number, and that's why this blue button pops up.

1371
02:25:55.585 --> 02:26:05.417
Because this blue button is a function that says, hey, return the value of favorite number private means only this specific contract can call this function.

1372
02:26:05.417 --> 02:26:11.399
Now for storage, it doesn't mean only this contract can read what's stored here.

1373
02:26:11.399 --> 02:26:13.446
And we'll get into that a little bit later.

1374
02:26:13.446 --> 02:26:17.260
But by that means, this is the only contract that can call the favorite number function.

1375
02:26:17.260 --> 02:26:20.426
Private functions are only visible to the current contract.

1376
02:26:20.426 --> 02:26:27.296
External functions are only visible externally, meaning somebody outside this contract can call this function.

1377
02:26:27.296 --> 02:26:35.770
And then internal means that only this contract and it's children contracts can actually read it, but we'll get into that a little bit later, too.

1378
02:26:35.770 --> 02:26:38.585
So oddly enough, variables are just function calls.

1379
02:26:38.585 --> 02:26:45.413
Now, the reason that we didn't see favorite numbers show up on the left hand side, when we first deployed this without the public keyword.

1380
02:26:45.413 --> 02:26:51.363
When we don't give a visibility specifier to functions or variables, they automatically get deployed as internal.

1381
02:26:51.363 --> 02:26:59.213
And as we know, internal functions and variables can only be called by this specific contract or derived contracts, which again, we'll get into later.

1382
02:26:59.213 --> 02:27:01.146
So let's just keep it public.

1383
02:27:01.146 --> 02:27:14.830
For now, the reason that we're prefixing, our parameter here with an underscore is a way to tell us, hey, this variable here is different from the favorite number global, there are some different naming conventions that are used for parameters.

1384
02:27:14.882 --> 02:27:22.063
And as we get later into the course, will understand more and more of what good names are parameters are, every time we call this store function.

1385
02:27:22.063 --> 02:27:31.399
And we change the value here, we're actually sending a transaction because remember, every single time we change the state of the blockchain, we do it in a transaction.

1386
02:27:31.399 --> 02:27:33.086
And we can see all the details here.

1387
02:27:33.086 --> 02:27:44.836
If you go over to the transaction details in the logging area of your remix, you can actually scroll down and you can see the transaction cost in units of gas, you'll see a number of something around this.

1388
02:27:44.885 --> 02:27:49.231
And you'll notice it's more than that 21,000 number from sending Aetherium.

1389
02:27:49.231 --> 02:27:52.870
That's because we're doing something more computationally expensive.

1390
02:27:52.870 --> 02:27:56.140
We're actually storing a number over here.

1391
02:27:56.140 --> 02:28:00.768
Now what do you think will happen if we do more inside of the store function as well.

1392
02:28:00.768 --> 02:28:06.807
So instead of just storing this number, maybe what else we do is we will store the number here.

1393
02:28:06.887 --> 02:28:11.237
And then we'll update our favorite number will say favorite number equals favorite number plus one.

1394
02:28:11.237 --> 02:28:17.221
Since we're doing more stuff, now we should see this store function actually become more expensive.

1395
02:28:17.221 --> 02:28:22.044
So let's go ahead and recompile we'll do delete this will redeploy.

1396
02:28:22.044 --> 02:28:26.343
We now have a new contract will store five again.

1397
02:28:26.343 --> 02:28:36.235
Now if we look in the details of this transaction, and we scroll down to execution costs, we do indeed see the amount of gas has greatly increased.

1398
02:28:36.235 --> 02:28:42.478
And that's because we're doing more things, this store function is now more computationally expensive.

1399
02:28:42.478 --> 02:28:46.729
And like I said, each blockchain has a little different way of how they actually calculate gas.

1400
02:28:46.729 --> 02:28:54.606
But the easiest way to think about it is, the more stuff you do, the more expensive that transaction is going to cost.

1401
02:28:54.606 --> 02:28:57.842
So let's go ahead and delete this line to continue our example.

1402
02:28:57.892 --> 02:29:10.721
Now let's talk about scope for a second, our favorite number is basically in something called the global scope, meaning anything inside of these brackets can access this favorite number variable.

1403
02:29:10.721 --> 02:29:35.439
But what if I did something like this? What if I made a un 256 called Test var? And I set it equal to five? And then I created a new function called something will have it take no parameters and be public? Could I access the test var and then change it to something like six? Can we do that? Well, let's go ahead and see what happens when we try to compile this.

1404
02:29:35.439 --> 02:29:37.544
We actually run into an error.

1405
02:29:37.544 --> 02:29:40.696
We had expected primary expression right here.

1406
02:29:40.696 --> 02:29:43.914
Oh, well, that's because I have the double question mark.

1407
02:29:43.914 --> 02:29:44.638
Let's try now.

1408
02:29:44.638 --> 02:29:46.509
We get undeclared identifier.

1409
02:29:46.509 --> 02:29:54.398
Our something function doesn't know about this test var when you create variables, they only can be viewed in the scope of where they are.

1410
02:29:54.398 --> 02:29:57.331
Now if that's a little confusing, just look for the curly brackets.

1411
02:29:57.331 --> 02:30:04.543
These two curly brackets encompass this whole We'll section here write, the opening one is up here, the closing one is down here.

1412
02:30:04.543 --> 02:30:11.673
So if I create a variable directly inside of these curly brackets, that means everything in here can access it.

1413
02:30:11.673 --> 02:30:26.884
However, test var was created inside of these curly brackets, which means that only stuff inside of these curly brackets can access test var, since our functions something isn't inside of store, or something function won't know about test var.

1414
02:30:26.884 --> 02:30:32.794
So that's how scope works, you want to look to see if your variable that you created is inside of these curly brackets.

1415
02:30:32.794 --> 02:30:37.235
And that's how you can know if other functions can work with them.

1416
02:30:37.235 --> 02:30:39.144
So this is why this fails.

1417
02:30:39.144 --> 02:30:53.870
Now, like what we saw in the documentation, when we add this public variable to favorite number, we're secretly adding a function that just returns this favorite number, we can also add our own function that also returns the favorite number to resemble the function that's getting created in the backend.

1418
02:30:53.904 --> 02:31:00.255
So we can say function, we call it retrieve, and we make it a public view.

1419
02:31:00.255 --> 02:31:05.290
And we'll say it returns, you went to 56.

1420
02:31:05.290 --> 02:31:07.840
or explain what that means in just a second.

1421
02:31:07.840 --> 02:31:10.114
And we'll say return favorite number.

1422
02:31:10.114 --> 02:31:16.633
Now, I'm going to hit command S, which again, I'm going to do that a lot throughout this section.

1423
02:31:16.633 --> 02:31:21.360
But just remember that that's equivalent to me going to the compile tab and hitting compile.

1424
02:31:21.360 --> 02:31:32.095
Now if we go to the deploy tab, delete our last one, deploy a new one, we now have a retrieve function, which is going to return the exact same thing that our favorite number is going to return.

1425
02:31:32.095 --> 02:31:37.629
Again, if we update this to five, called favorite number and then retrieve they both now return five.

1426
02:31:37.629 --> 02:31:43.224
Now as you can see here, these two functions are blue, but this function is orange.

1427
02:31:43.224 --> 02:31:56.565
What's the difference? Why did these have these different colors? Well, the key lies in this view keyword here, there are actually two keywords in solidity that notate a function that doesn't actually have to spend gas to run.

1428
02:31:56.565 --> 02:31:59.168
And those keywords are view, and pure.

1429
02:31:59.168 --> 02:32:02.071
And let's also get rid of this variable here.

1430
02:32:02.071 --> 02:32:09.540
A function that is a view function means we're just going to read state from this contract, we're just going to read something off of this contract.

1431
02:32:09.540 --> 02:32:17.828
For example, our retrieve function right now is just reading what favorite number is, a view function disallows any modification of state.

1432
02:32:17.828 --> 02:32:21.844
So you can't update the blockchain at all with a view function.

1433
02:32:21.844 --> 02:32:25.142
Pure functions also disallow any modification of state.

1434
02:32:25.142 --> 02:32:27.639
So we couldn't update our favorite number.

1435
02:32:27.639 --> 02:32:30.931
Not only that, but they also disallow reading from the blockchain.

1436
02:32:30.931 --> 02:32:33.289
So we couldn't read favorite number either.

1437
02:32:33.289 --> 02:33:00.983
Instead, what you might do with a pure function is maybe something like function, add public here, one plus one, or return, one plus one, this would be turns you into 36, maybe something like this, maybe there's some math you want to use over and over again, maybe there's some specific algorithm that you want to implement that doesn't actually need to read any storage, etc.

1438
02:33:00.983 --> 02:33:07.850
Now, if we call a view function, or a pure function by itself, we actually don't need to spend any gas.

1439
02:33:07.917 --> 02:33:09.435
Since we're just reading from the blockchain.

1440
02:33:09.918 --> 02:33:15.060
only spend gas we only make a transaction if we modify the blockchain state.

1441
02:33:15.060 --> 02:33:22.020
So you'll notice in our little console down here, that if I call retrieve this call things comes up.

1442
02:33:22.020 --> 02:33:25.185
However, it looks different than when we call the store function.

1443
02:33:25.185 --> 02:33:30.851
And we call the store function, we get this little checkmark, we get a hash, we don't get a little checkmark.

1444
02:33:30.920 --> 02:33:32.729
And we don't get a hash with the calls.

1445
02:33:33.920 --> 02:33:36.823
these blue buttons doesn't make a transaction.

1446
02:33:37.920 --> 02:33:40.921
Hey, we're just going to read off chain, we're just going to read this value.

1447
02:33:40.921 --> 02:33:46.056
However, if you look in the details of this call, there's this execution cost bit here.

1448
02:33:46.056 --> 02:33:52.455
So what's going on? Well, we can read this part right here, cost only applies when called by contract.

1449
02:33:52.455 --> 02:34:02.133
If we do have a function that calls retrieve, if there's a function that is updating state that calls a view or a pure function, that's the only time it'll cost gas.

1450
02:34:02.133 --> 02:34:24.653
So for example, if our store function which is not a view function, were to call retrieve at some point, then we'd have to pay the cost of the Retrieve because reading from the blockchain cost this computation and cost gas calling view functions is free, unless you're calling it inside of a function that costs gas, in which case it will cost gas.

1451
02:34:24.653 --> 02:34:31.022
So if we leave it here, we delete this recompile redeploy.

1452
02:34:31.022 --> 02:34:34.545
We had favorite number retrieved, they both still cost nothing.

1453
02:34:34.545 --> 02:34:48.177
But if we add, restore eight in here, we can see, we can see our execution cost has gone up from what it was without retrieve, which we can go ahead, we can compile, I hit command us to compile here, we can deploy.

1454
02:34:48.177 --> 02:34:50.760
Let's go ahead and store again.

1455
02:34:50.928 --> 02:34:56.317
We'll click on that transaction, we can see that it's much cheaper without that retrieve function in there.

1456
02:34:56.317 --> 02:35:06.071
And again, our favorite number variable as long as it has this public visible solidity, it also is counted as a view function that returns a un 256.

1457
02:35:06.071 --> 02:35:16.555
The returns keyword means what is this function going to give us after we call it so we say this function is going to give us this function is going to return a un 256.

1458
02:35:16.555 --> 02:35:22.071
When we call retrieve, it's going to return or give us a utility six.

1459
02:35:22.071 --> 02:35:31.818
This is the result of calling the function this six is the result of calling arbitrary function.

1460
02:35:31.932 --> 02:35:35.883
Now our contract is good as it is, it allows us to store a single favorite number.

1461
02:35:35.932 --> 02:35:51.088
But what if we want to store a range of favorite numbers? Or maybe we want to store a whole bunch of different people who have different favorite numbers? Well, how do we do that there are several different ways that we can approach this, one of the ways we could start approaching this is by creating what's called a struct of people.

1462
02:35:51.088 --> 02:35:53.157
Or we create a new type.

1463
02:35:53.157 --> 02:36:00.606
In our solidity, we can create a people object that holds both someone's name, and their favorite number.

1464
02:36:00.606 --> 02:36:11.221
To do that, we say struct people, you went to 56, favorite number, and a string name.

1465
02:36:11.221 --> 02:36:17.641
Now we've created a new type called people kinda like you intuited six, or Boolean, or string.

1466
02:36:17.641 --> 02:36:20.381
Now we have a people type that we can use.

1467
02:36:20.381 --> 02:36:27.051
Now similar to how we created a un 256 public favorite number, we can do the exact same thing.

1468
02:36:27.051 --> 02:36:37.034
But with a people, we could say people public, we call this person, and we can create a new people and assign it to this variable person.

1469
02:36:37.034 --> 02:36:46.605
So we'll say equals people public person, equals, and we'll add parentheses here to signify we're creating a new person.

1470
02:36:46.605 --> 02:37:07.241
And since we made this a struct, we add little curly brackets here to let solidity know that we're going to be grabbing from these struct variables, we'll say favorite number is going to be two, and the name is going to be Patrick semicolon, and then we can hit Ctrl S, or we can go ahead and compile.

1471
02:37:07.241 --> 02:37:20.355
Now if we go ahead and deploy this we now have a new person, since this, again, is a public variable, it has a getter function called person.

1472
02:37:20.355 --> 02:37:25.385
And if we click person, we see our new object, the favorite number is two.

1473
02:37:25.385 --> 02:37:32.751
And then the name is Patrick, you see this zero and this one, because these are showing the index of the different variables.

1474
02:37:32.751 --> 02:37:37.485
But those of you new to computer science, typically in computer science, let's start with the number zero.

1475
02:37:37.485 --> 02:37:42.757
So what are zero with index, we have you in 256, called favorite number, which is saved at two.

1476
02:37:42.757 --> 02:37:53.407
And then at index one, we have a string, which stands for the name of Patrick, whenever you have a list of variables inside of an object in solidity, they get automatically indexed.

1477
02:37:53.407 --> 02:37:57.946
So favorite number gets indexed to zero, and name gets indexed to one.

1478
02:37:57.946 --> 02:38:10.509
Interestingly enough, if you have a whole bunch of variables inside your contract, like we have public favorite number, this favorite number, actually, technically is getting indexed at the zero with storage slot.

1479
02:38:10.509 --> 02:38:19.173
And if we were to make another one of these, maybe you want to get six public brother's favorite number, this would technically be indexed at the first slot.

1480
02:38:19.173 --> 02:38:25.182
And then if we were to make one more, maybe sister's favorite number, this would be the next add the second slot.

1481
02:38:25.182 --> 02:38:31.882
So favorite number at zero, this add one, and this a two, but we'll learn more about that much later in the course.

1482
02:38:31.882 --> 02:38:35.918
Similarly, favorite number is index zero name is index at one.

1483
02:38:35.918 --> 02:38:48.867
Now what we have is great, but if we want a whole lot of people are we gonna have to keep copy pasting and changing the people's name person to their favorite one, number one, number three, will name them ally.

1484
02:38:48.951 --> 02:38:52.968
Person three, their favorite number will be seven.

1485
02:38:53.952 --> 02:38:56.035
will be Chad or something.

1486
02:38:58.952 --> 02:39:02.828
create lists and large number of people's because we have to statically keep typing them in.

1487
02:39:02.828 --> 02:39:05.211
So a much better way to create a list.

1488
02:39:05.211 --> 02:39:13.025
And let's actually just go ahead and delete Patrick to a much better way to create a list is to use a data structure called an array.

1489
02:39:13.025 --> 02:39:22.136
An array is a way to store a list, or a sequence of objects, creating an array works the exact same we've seen to initialize other different types.

1490
02:39:22.136 --> 02:39:28.155
Typically, we do the type of the object, the visibility of the object, and then the variable name.

1491
02:39:28.155 --> 02:39:30.399
We do the exact same thing with arrays.

1492
02:39:30.399 --> 02:39:32.844
We'll say we want a people array.

1493
02:39:32.844 --> 02:39:37.181
These little brackets represent that we want an array of people.

1494
02:39:37.181 --> 02:39:57.010
We'll give it a visibility of public and we'll call it people you could do the same thing with you and 256 for example, you could say you went to 56 public favorite numbers list and just add this little array key here.

1495
02:39:57.010 --> 02:40:02.120
And now favorite numbers list is going to be an array or a list We're going to comment that out for now.

1496
02:40:02.120 --> 02:40:07.614
Now if I were to go ahead and deploy this contract, let's go ahead delete the last one, let's redeploy.

1497
02:40:07.614 --> 02:40:10.975
We now have this blue people button here.

1498
02:40:10.975 --> 02:40:18.893
Remember, since it's public, and it's a variable, it automatically is given a view function, it's given one of these blue buttons.

1499
02:40:18.960 --> 02:40:28.256
And instead of just having a single button where the value shows up, it's giving us a form to fill out, it wants to take a un 256 as an input parameter.

1500
02:40:28.256 --> 02:40:32.927
So if I put zero, I get nothing back, if I put one, I get nothing back.

1501
02:40:32.927 --> 02:40:36.909
No matter what you put in this box, right? Now we're gonna get nothing back.

1502
02:40:36.962 --> 02:40:41.217
This is because our people array or our people list is currently empty.

1503
02:40:41.217 --> 02:40:45.650
And the value that it wants is going to be the index of the object that you want.

1504
02:40:45.650 --> 02:40:56.846
So for example, if at index zero, I had Patrick, it would show Patrick for zero, if it didn't x one I had John, or actually better yet, to Patrick.

1505
02:40:57.964 --> 02:41:00.148
Seven, John, etc.

1506
02:41:00.148 --> 02:41:01.809
This is what it would show.

1507
02:41:01.809 --> 02:41:04.754
But since it's empty, it's going to show nothing.

1508
02:41:04.754 --> 02:41:15.688
And let's go ahead and remove the public variable from favorite numbers so that we don't get the duplicate functions at the moment, we'll just get the Retrieve function, we'll show you how to add to this array in just a second.

1509
02:41:15.688 --> 02:41:24.197
This type of array is what's known as a dynamic array, because the size of the array isn't given at the array initialization.

1510
02:41:24.197 --> 02:41:50.923
If we were to say, a people array and add a three in these brackets here, that means that this list, or this array of people could only be three people big, if we don't give it a size, it means it can be any size and the size of the array can grow and shrink as we add and subtract people, if I add three, it can only have a maximum of three in the array ever, we're going to work with a dynamic array, because we're going to want to add a arbitrary number of people to this array.

1511
02:41:50.970 --> 02:41:59.560
So let's go ahead and create a function that's going to add people who are people array, so we're gonna say function, add person.

1512
02:41:59.560 --> 02:42:08.005
And we're going to take string, memory, name as input parameter, and I'll explain that in a minute.

1513
02:42:08.005 --> 02:42:21.317
And a un 256 underscore favorite number, we're going to make this a public function, or we're going to do is we're going to call a push function that's available on our people object.

1514
02:42:21.317 --> 02:42:31.786
So we're gonna say people dot push, and we're going to create a new person, a new people object, which is going to take in the favorite number.

1515
02:42:31.974 --> 02:42:34.743
And the name.

1516
02:42:34.974 --> 02:42:36.449
Now, this might be a little bit tricky to you.

1517
02:42:36.974 --> 02:42:37.640
this down.

1518
02:42:37.640 --> 02:42:39.640
People here is capitalized.

1519
02:42:40.975 --> 02:42:49.725
since capitalize, it's referring to this struct people and not our variable people, the lowercase people here is referring to this lowercase array.

1520
02:42:49.725 --> 02:42:59.123
So we're saying our array dot push, or push is the equivalent of adding basically, a new people that grabs favorite number and name.

1521
02:42:59.123 --> 02:43:06.164
Another way that we could actually do this is we could create a variable of type people and then add it like so.

1522
02:43:06.164 --> 02:43:09.616
So we could say people, new person equals people.

1523
02:43:09.616 --> 02:43:14.469
And then we put those brackets the same way we did before.

1524
02:43:14.469 --> 02:43:24.849
You say favorite number is going to be this input value, this parameter, and we could say name is going to be this parameter.

1525
02:43:24.849 --> 02:43:32.725
Now if you hit save, you'll get this error set here, saying data location must be stored in memory, or called data for variable but no one's given.

1526
02:43:32.725 --> 02:43:37.087
For now, we're just going to add the memory keyword here, and I'll explain what it does in a little bit.

1527
02:43:37.087 --> 02:43:40.784
And then of course, we need to add the new person into our people dot push right here.

1528
02:43:40.784 --> 02:43:45.235
So this is how we're actually going to push people into our people array.

1529
02:43:45.235 --> 02:43:47.523
And I'll get to this memory keyword in a bit.

1530
02:43:47.523 --> 02:43:52.435
Now if we go back to our deploy tab, we delete our last contract.

1531
02:43:52.435 --> 02:43:54.227
Let's deploy this new one.

1532
02:43:54.227 --> 02:44:07.054
Right now, if we try to look at the zero with person in our people array, we get nothing but let's go ahead and add a person, we'll call it, Patrick will be the name, and seven will be the favorite number.

1533
02:44:07.054 --> 02:44:09.516
So we added Patrick, we added seven.

1534
02:44:09.516 --> 02:44:16.951
Now if we look at people's zero, we should see the zeroeth person has a name of Patrick, and a favorite number of seven, boom.

1535
02:44:16.951 --> 02:44:25.894
And that's exactly what we do see, we see a favorite number of seven, and we see a string name Patrick, we tried to add John and do his 16.

1536
02:44:25.894 --> 02:44:29.485
We hit Add Person, we can see our transaction go through.

1537
02:44:29.485 --> 02:44:34.923
And now if we go to people at zero, it's still Patrick with a favorite number of seven.

1538
02:44:34.923 --> 02:44:40.096
But if we look at the people at index one, it's going to be John with a favorite number of 16.

1539
02:44:40.096 --> 02:44:43.495
And if we look at two, this, of course, should be blank.

1540
02:44:43.495 --> 02:44:46.390
And we do indeed see nothing actually happens here.

1541
02:44:46.390 --> 02:44:46.777
Perfect.

1542
02:44:46.777 --> 02:44:59.730
Now there's actually a couple of different ways to create this new person here, like we showed before, we can use this bracket notation, or what we can do is we can actually just add the parameters in the order that they show.

1543
02:44:59.730 --> 02:45:03.540
So the first parameter for people is going to be favorite number.

1544
02:45:03.540 --> 02:45:10.924
So we can just do favorite number, comma, and the second one is going to be name, the second one is going to be name.

1545
02:45:10.924 --> 02:45:18.104
So if we save this, this, this line we just created is the exact same as the last line, we're being a little bit less explicit here.

1546
02:45:18.104 --> 02:45:34.974
So the other way is generally a little bit better because it's more explicit as to what variables are what or we don't even need to save to this variable here, we could take out this whole line, replace new person with exactly what we just saw, like so now we don't even need the memory keyword.

1547
02:45:34.974 --> 02:45:38.155
Now, you've probably seen this by now.

1548
02:45:38.155 --> 02:45:43.320
But if I go ahead and compile, and I see a little, little red one here, I roll over.

1549
02:45:43.320 --> 02:45:51.660
And it says something about error, expected semicolon, but got bracket, all these errors mean that your code isn't compiling.

1550
02:45:51.660 --> 02:45:53.518
It's not working as expected.

1551
02:45:53.518 --> 02:45:58.394
So now I can go over here and do a little semicolon recompile, and I get a green.

1552
02:45:58.394 --> 02:46:04.910
Now if I delete this top line, for example, and I compile it, actually get a yellow thing.

1553
02:46:04.995 --> 02:46:12.724
Yellow stands for warnings, the warning that I get is warning SPX license identifier, not provided, you should add it.

1554
02:46:12.724 --> 02:46:14.596
So let's go ahead and add that back.

1555
02:46:14.596 --> 02:46:15.096
recompile.

1556
02:46:15.096 --> 02:46:16.431
And the warning goes away.

1557
02:46:16.431 --> 02:46:18.608
Warnings Don't stop your code from compiling.

1558
02:46:18.608 --> 02:46:19.896
So if you get warnings, it's okay.

1559
02:46:19.896 --> 02:46:26.950
But it's usually a good idea to listen to the warnings, because often they'll give really insightful information about how to improve your smart contracts.

1560
02:46:26.997 --> 02:46:29.642
So to summarize, if it's red, it's broken.

1561
02:46:30.998 --> 02:46:31.960
might want to check it out.

1562
02:46:32.998 --> 02:46:36.935
continuing to code.

1563
02:46:39.998 --> 02:46:42.764
that you'll notice here is that we have this memory keyword.

1564
02:46:42.999 --> 02:46:51.051
you'll notice if you try to delete it from our function here, you try to compile, you actually run into an error data location must be memory or call data for parameter and function.

1565
02:46:51.100 --> 02:47:00.475
Now there are actually six places you can store data in solidity you have the stack, memory, storage, call data, code and logs.

1566
02:47:00.475 --> 02:47:02.490
We're not going to go over these right now.

1567
02:47:02.490 --> 02:47:10.515
But we are going to focus on three of the big ones, or three of the important ones for this section, which are called data, memory, and storage.

1568
02:47:10.515 --> 02:47:13.921
So for this section, we're going to talk about call data memory and storage.

1569
02:47:13.921 --> 02:47:15.680
And this is a little bit advanced.

1570
02:47:15.680 --> 02:47:19.155
So if you don't totally grasp it the first time, that's totally okay.

1571
02:47:19.155 --> 02:47:20.043
Please continue.

1572
02:47:20.043 --> 02:47:28.362
Even if it's not crystal clear what's going on here, call data and memory mean that the variable is only going to exist temporarily.

1573
02:47:28.362 --> 02:47:41.018
So this name variable only exists temporarily during the transaction that this Add Person function is called storage variables exist, even outside of just the function executing.

1574
02:47:41.100 --> 02:47:47.286
Even though we didn't specify it up above, our favorite number is automatically cast to be a storage variable.

1575
02:47:47.286 --> 02:47:51.033
Since it's not explicitly defined in one of these functions.

1576
02:47:51.033 --> 02:48:03.661
Since we don't need this name variable anymore after this function runs, we can keep it as memory, or we could keep it as called data, you can have a parameter as called data if you don't end up modifying the name.

1577
02:48:03.661 --> 02:48:10.134
For example, we couldn't reassign name to equal cat here, if we compile we run into an error.

1578
02:48:10.134 --> 02:48:15.261
Type literal string cat is not implicitly convertible to expect the type string called data.

1579
02:48:15.261 --> 02:48:23.911
However, if we have this as memory, and we compile and save it, that error goes away call data is temporary variables that can't be modified.

1580
02:48:23.911 --> 02:48:27.242
Memory is temporary variables that can be modified.

1581
02:48:27.242 --> 02:48:30.625
And storage is permanent variables that can be modified.

1582
02:48:30.625 --> 02:48:44.629
Now even though I just said there's actually six places where we can access and store information, we cannot say a variable is stack code or logs, we can only say memory storage are called data, you will learn why in a much later section.

1583
02:48:44.629 --> 02:48:47.339
Now, this is a bit of an oversimplification of this.

1584
02:48:47.339 --> 02:48:49.227
But that's essentially what's going on.

1585
02:48:49.227 --> 02:48:57.507
The next question you might have is, well, why do I need to say memory here, but I don't need to say memory here.

1586
02:48:57.507 --> 02:49:02.035
Well, let's go ahead and put memory here and hit CTRL S or compile.

1587
02:49:02.101 --> 02:49:08.051
And let's see what happens we get from solidity data location can only be specified for an array, struct or mapping types.

1588
02:49:08.101 --> 02:49:13.920
A memory was given arrays structs and mappings are considered special types and solidity.

1589
02:49:13.920 --> 02:49:24.017
solidity automatically knows where are you in 256 is going to be slowly knows that for this function, a un 256 is going to live just in memory.

1590
02:49:24.101 --> 02:49:26.651
However, it's not sure what a string is going to be.

1591
02:49:27.101 --> 02:49:28.947
are actually kind of complicated.

1592
02:49:30.101 --> 02:49:32.476
a string is actually an array of bytes.

1593
02:49:34.101 --> 02:49:44.048
array, we need to add this memory bit to it because we need to tell solidity, the data location of arrays structs, or mappings and a string is secretly an array.

1594
02:49:44.048 --> 02:49:46.837
So that's why we need to tell it it's in memory.

1595
02:49:46.837 --> 02:49:53.804
You'll notice we can't add the storage keyword here slowly also knows that since this is a function, this name variable isn't actually getting stored anywhere.

1596
02:49:53.804 --> 02:50:02.583
So it says Hey, you can't have that you need to have it beat memory or called data and those are the only two that it accepts So this is what we want our function to look like here.

1597
02:50:02.583 --> 02:50:11.757
So the summary of this is struct mappings and arrays need to be given this memory or called Data keyword when adding them as a parameter to different functions.

1598
02:50:11.757 --> 02:50:16.435
We'll learn more about storage memory and call data in later sessions.

1599
02:50:16.435 --> 02:50:28.051
Now, this list is great, but what if we know someone's name, but we don't know their favorite number? Well, what we could do is we could look through the whole array looking for that person.

1600
02:50:28.102 --> 02:50:32.368
For example, in our contract, we can say, Okay, I'm looking for John.

1601
02:50:32.368 --> 02:50:34.234
Okay, let's start with zero.

1602
02:50:34.234 --> 02:50:35.900
No, okay, that's Patrick.

1603
02:50:36.102 --> 02:50:37.227
Okay, let's go to one.

1604
02:50:37.227 --> 02:50:37.494
Okay.

1605
02:50:37.494 --> 02:50:38.136
That's John.

1606
02:50:38.136 --> 02:50:38.671
Oh, great.

1607
02:50:39.102 --> 02:50:42.790
favorite number 16? Well, this was really easy, because we only had two people.

1608
02:50:42.790 --> 02:50:51.652
But what if we had hundreds of people in this array? Well, we'd keep have to iterating all the way up to the index that that person was in, it's obviously really inefficient.

1609
02:50:51.652 --> 02:51:08.876
What's another way to store this information so that it's much easier and quicker to access? Well, another data structure that we can use is something called a mapping, you can think of a mapping as sort of like a dictionary, it's a set of keys, which each key returning a certain value associated with that key.

1610
02:51:08.876 --> 02:51:13.502
And we create a mapping variable the exact same way we create all of our other variables.

1611
02:51:13.502 --> 02:51:26.152
This is going to be a type mapping of string to you and tivity sex, this is going to be our type of visibility keyword is going to be public.

1612
02:51:26.152 --> 02:51:31.052
And we'll call it name to favorite number.

1613
02:51:31.052 --> 02:51:36.905
Now we have a dictionary where every single name is going to map to a specific number.

1614
02:51:36.905 --> 02:51:40.273
So let's add some capability to our Add Person function.

1615
02:51:40.273 --> 02:51:43.944
So we are going to add our people to our array.

1616
02:51:44.102 --> 02:51:50.899
But let's also add them to our mapping here, what we'll do is we'll say name to favorite number.

1617
02:51:50.899 --> 02:51:58.939
App key name is going to equal to favorite number.

1618
02:51:58.939 --> 02:52:02.857
So let's go ahead, compile this.

1619
02:52:03.103 --> 02:52:11.153
We'll go to our deploy screen, we'll deploy this click, we have a new button named a favorite number.

1620
02:52:11.153 --> 02:52:14.206
If I type in Patrick, nothing shows up.

1621
02:52:14.206 --> 02:52:17.610
By typing Patrick, you'll see I get zero response.

1622
02:52:17.610 --> 02:52:20.340
By typing John, I also get a zero response.

1623
02:52:20.340 --> 02:52:23.836
If I type in Becca, I also get a with zero response.

1624
02:52:23.836 --> 02:52:34.272
When you create a mapping, you initialize everything to its null value, every single possible string on the planet right now is initialized to having a favorite number of zero.

1625
02:52:34.272 --> 02:52:37.634
So if we want to change that, we'll have to go in and manually add that.

1626
02:52:37.634 --> 02:52:41.916
So let's go ahead and add a person to our mapping here.

1627
02:52:41.916 --> 02:52:43.612
So we'll add Patrick.

1628
02:52:43.612 --> 02:52:46.666
And we'll say my favorite number is seven.

1629
02:52:46.666 --> 02:52:53.880
And looks like that transaction did go through also add, Becca, and we'll say her favorite number is 13.

1630
02:52:53.880 --> 02:52:58.012
Let John and we'll say his favorite number is 16.

1631
02:52:58.012 --> 02:53:05.036
Now, if I look up, Patrick, I'll immediately get back what Patrick's favorite number is, I get seven back.

1632
02:53:05.036 --> 02:53:08.243
If we look up, John, we immediately get back 16.

1633
02:53:08.243 --> 02:53:10.558
Back up, we may only get back 13.

1634
02:53:10.558 --> 02:53:13.255
And we also can see them in our array.

1635
02:53:13.255 --> 02:53:19.357
Because we kept in this people that push bit zero, we see Patrick's there.

1636
02:53:19.357 --> 02:53:21.492
At one, we see Becca.

1637
02:53:21.492 --> 02:53:30.202
And at two, we see John, in our mapping, we're saying the string name is being mapped to the UN 256 favorite number.

1638
02:53:30.202 --> 02:53:34.057
And a lot of my variables, I like to make them explicitly named like that.

1639
02:53:34.104 --> 02:53:38.261
So this is name to favorite number.

1640
02:53:38.261 --> 02:53:44.199
So now we're in a space where let's say that we really like our simple storage contract.

1641
02:53:44.199 --> 02:54:04.578
Right now we have a favorite number, a global variable that we can save a favorite number to with our store function, we have a mapping of name to favorite numbers, and we have an array of a new type that we created called people, we can add to both the array and to the mapping.

1642
02:54:04.578 --> 02:54:13.722
Using this Add Person function that we've created, we're able to save multiple people's favorite numbers as well as kind of a global favorite number as well.

1643
02:54:13.722 --> 02:54:20.054
Let's say we really love this contract, and we're ready to send it to a test net to have other people interact with it.

1644
02:54:20.104 --> 02:54:26.484
Now in future sections, you'll hear me say that you shouldn't do this until you write tests until you do some really simple auditing.

1645
02:54:26.484 --> 02:54:32.874
But for now, let's go ahead and learn how to actually deploy this to a test net or to a real network.

1646
02:54:32.874 --> 02:54:35.970
Now remember, test nets are run out of the goodness of people's hearts.

1647
02:54:35.970 --> 02:54:40.500
So if it's a little bit funky, or maybe doesn't work exactly as we show here, that's okay.

1648
02:54:40.500 --> 02:54:48.041
As long as it works with the JavaScript VM, you'll be all set but it is good practice to learn how to deploy these to a real test net.

1649
02:54:48.041 --> 02:54:49.728
Let's go ahead and do that.

1650
02:54:49.728 --> 02:54:51.226
Our contract is here.

1651
02:54:51.226 --> 02:54:52.910
Simple Storage dot soul.

1652
02:54:52.910 --> 02:54:58.284
It's compiled, compiling is passing we get this little green checkmark here we go to the deploy section.

1653
02:54:58.284 --> 02:54:59.808
Let's go ahead and do Get this.

1654
02:54:59.808 --> 02:55:02.120
And now we're going to change the environment.

1655
02:55:02.120 --> 02:55:11.505
So we were working with a JavaScript VM or kind of this fake simulated environment, we want to now move to either injected web three, or web three provider.

1656
02:55:11.505 --> 02:55:16.040
If you hover over injected web three, there's this really, really small text here.

1657
02:55:16.040 --> 02:55:27.073
But this basically means we're going to inject our meta mask or our web three wallet into our browser to use similar to what we did with the faucet, we'll pick our account we want to use.

1658
02:55:27.073 --> 02:55:29.978
So I'm gonna go ahead and pick account one.

1659
02:55:29.978 --> 02:55:44.846
And now we actually see our account in the Account section of remix, injected web three means we're using our meta mask or whatever web three wallet, web three provider is, when we a little bit more manually choose an endpoint.

1660
02:55:44.846 --> 02:55:47.088
And we're not going to go over this right now.

1661
02:55:47.088 --> 02:55:49.956
But as we get later into the course, you'll understand what this means.

1662
02:55:49.956 --> 02:55:59.420
So we're picking injected web three, whatever network are injected web three, or in this case, our wallet is connected to is going to be the network that we deploy to.

1663
02:55:59.420 --> 02:56:02.494
So for this section, we're going to be deploying to Rinkeby.

1664
02:56:02.494 --> 02:56:10.334
But again, depending on whatever the recommended test net and the recommended faucet is, that will dictate which test net you should actually deploy to.

1665
02:56:10.334 --> 02:56:11.858
For us, it's going to be Rigby.

1666
02:56:11.858 --> 02:56:16.980
To deploy to a test that remember, we're going to need gas, so we're going to need some tested Etherium.

1667
02:56:16.980 --> 02:56:31.850
Or if you're deploying to a main net main Aetherium, which you shouldn't be come to the top of the GitHub repo to make sure you have the most updated faucet, the other place you can go is link token contracts page in the chain link documentation and scroll down the ranking.

1668
02:56:31.850 --> 02:56:36.531
And you can see test that link available here, test that eath available here.

1669
02:56:36.531 --> 02:56:43.334
So this is the other location, you can always look to find the most up to date faucets, and both of them point right back here.

1670
02:56:43.334 --> 02:56:53.012
So now that we're working with injected web three, we can just go through the exact same steps to deploy to a test net as to deploy to a virtual machine.

1671
02:56:53.106 --> 02:56:57.767
And remember, if you run out of gas to deploy this, be sure to check back to the faucets to actually deploy this.

1672
02:56:57.767 --> 02:57:00.582
So we're going to do the same thing, we're gonna go ahead and hit Deploy.

1673
02:57:00.582 --> 02:57:33.976
But this time Metamask is going to pop up and ask us if we want to actually deploy this, this is the exact same as what we saw with the blockchain example, where we sign transactions, we are signing and sending this transaction, the data of this transaction is this massive, massive data thing here, which represents the contract that we just created, we can see all the payment information for this transaction for deploying this contract, we see it's going to cost around this much Aetherium to deploy.

1674
02:57:33.976 --> 02:57:36.519
But again, we're on the Rinkeby test network.

1675
02:57:36.519 --> 02:57:37.829
So this is going to be fake Aetherium.

1676
02:57:37.829 --> 02:57:40.215
We're gonna go ahead, hit Confirm.

1677
02:57:40.215 --> 02:57:57.817
And if you pop up a little console, and remix, you'll see that after a slight delay, it'll actually say have this green checkmark that it's confirmed that it went actually went through, we can go ahead right click, open a new tab, and view this on ether scan.

1678
02:57:57.817 --> 02:58:17.058
And after a slight delay, we'll actually be able to see the transaction details here, exactly the same as our transaction details for sending Aetherium we have a hash, we have a status, we have blocked block confirmations, we have timestamp from which is going to be us two, which is going to be the average of the contract that we just created.

1679
02:58:17.058 --> 02:58:19.280
We didn't send any value with this.

1680
02:58:19.280 --> 02:58:20.920
So this is going to be zero ether.

1681
02:58:20.920 --> 02:58:25.056
And then of course, we see the transaction fee, and as well as the gas price.

1682
02:58:25.056 --> 02:58:30.219
Because again, deploying a contract to the blockchain is modifying the state of the blockchain.

1683
02:58:30.219 --> 02:58:33.948
So we have to pay gas, and we can see all the different pieces here.

1684
02:58:33.948 --> 02:58:44.027
As we can see, gas limit and gas usage is much higher than just sending Aetherium, since we are putting a lot of data on chain and adding a lot of computation.

1685
02:58:44.107 --> 02:58:49.017
So this number is much higher than the 21,000 number of just sending Aetherium.

1686
02:58:49.017 --> 02:58:55.934
Now, if we come back to our remix and scroll down, we're able to see our simple storage contract at this address.

1687
02:58:55.934 --> 02:59:04.896
If we hit this copy button, and we go to the rink be ether scan, we paste it in the search bar, we will get the contract that we just deployed.

1688
02:59:04.896 --> 02:59:10.041
And we see this first transaction is going to be the contract creation transaction.

1689
02:59:10.107 --> 02:59:15.011
So this contract that we just created one transaction, which is contract created.

1690
02:59:15.011 --> 02:59:24.172
So now that we have this contract created, we have all the exact same functions that we saw when working with the JavaScript virtual machine, or the our fake environment, or our super fake environment.

1691
02:59:24.172 --> 02:59:29.707
Now we can do all the exact same things that we did with the JavaScript VM, but on a real test network.

1692
02:59:29.707 --> 02:59:33.666
So you'll see if I hit retrieve Metamask doesn't pop up.

1693
02:59:33.666 --> 02:59:36.535
Because again, this is a blue view function.

1694
02:59:36.535 --> 02:59:42.528
If we look people at zero, this is also a view function and nothing pops up, named a favorite number should be blank.

1695
02:59:42.528 --> 02:59:54.639
So if I type in Patrick now, absolutely nothing happens, right? I get I get zero returned because mappings initialize every single key with a blank or a null value, which for you 256 is zero.

1696
02:59:54.639 --> 03:00:10.894
Now, we can go ahead and store a favorite number store When your favorite number is going to modify the blockchain, so our meta mask should pop up for us to confirm the transaction and sign that transaction to modify the blockchain state.

1697
03:00:10.894 --> 03:00:25.836
So I'm going to store my favorite number of 16, we'll hit store, meta mask will pop up, and we're going to go ahead and actually confirm this didn't confirm is equivalent to US signing this transaction and sending it to the blockchain to modify the state.

1698
03:00:25.836 --> 03:00:31.044
So we're gonna go ahead and confirm this, we should be able to view this on ether scan.

1699
03:00:31.108 --> 03:00:35.561
And again, it might take a little bit for it to actually index or actually start working.

1700
03:00:35.561 --> 03:00:37.627
So please be patient with these test nets.

1701
03:00:37.627 --> 03:00:47.044
And again, this is why when building your applications, you want the test net piece to absolutely try to be your last step, because you have to wait a really long time.

1702
03:00:47.108 --> 03:00:51.536
And it puts a burden on these people running these tests into running it out of the goodness of their heart.

1703
03:00:51.536 --> 03:00:55.600
So please try to make this the last step of your actual building process.

1704
03:00:55.600 --> 03:00:58.043
For us learning right here, it's okay.

1705
03:00:58.043 --> 03:01:09.465
And after a slight delay, once we hit refresh, it looks like it's indexing on ether scan, the ether scan website is still figuring out where the transaction is going to remix, it looks like on the blockchain, this has actually already gone through.

1706
03:01:09.465 --> 03:01:13.827
So now if we hit retrieve, we do indeed see, our favorite number is 16.

1707
03:01:13.827 --> 03:01:16.396
Of course, these two are still going to be blank.

1708
03:01:16.396 --> 03:01:20.483
And it looks like that transaction has gone through and ether scan has indexed.

1709
03:01:20.483 --> 03:01:26.430
So now let's go ahead and add a person will add Patrick, and my favorite number is going to be 16.

1710
03:01:26.430 --> 03:01:28.284
We'll go ahead and add person.

1711
03:01:28.284 --> 03:01:35.323
Again, since these are orange transactions gonna pop up because we're modifying the blockchain state, we'll go ahead and hit Confirm.

1712
03:01:35.323 --> 03:01:39.785
And we're going to be a little bit patient here and wait for this transaction to go through.

1713
03:01:39.785 --> 03:01:41.818
And we should see this update.

1714
03:01:41.818 --> 03:01:42.902
And this update.

1715
03:01:43.108 --> 03:01:46.785
Now if I hit named a favorite number of Patrick, I get 16.

1716
03:01:47.108 --> 03:01:49.441
if I hit people of zero, I get favorite number 16.

1717
03:01:50.108 --> 03:01:50.743
is Patrick.

1718
03:01:50.743 --> 03:01:51.251
Awesome.

1719
03:01:54.109 --> 03:02:06.786
contract to an actual test net, and actually seen on ether scan what these transactions look like, you should be incredibly proud of yourself, be sure to give yourself a high five pat on the back, send a tweet saying exactly how excited you are.

1720
03:02:06.786 --> 03:02:15.381
But make sure to celebrate these little wins, celebrating these little wins will give you the motivation to keep going and really excite you for learning each new thing.

1721
03:02:15.381 --> 03:02:15.962
So huge.

1722
03:02:16.109 --> 03:02:16.812
Congratulations.

1723
03:02:19.109 --> 03:02:21.198
contract to a test net, congratulations.

1724
03:02:22.109 --> 03:02:29.493
to see what it looks like to deploy to a different network, all you need to do in your Metamask is switch to a different test net.

1725
03:02:29.493 --> 03:02:36.505
See, if we switch to COVID remix automatically updates and says, ah, injected web three is now the COVID test network.

1726
03:02:36.505 --> 03:02:42.055
We could switch again maybe to Grilley, we say Ah, the injected web three is now at the Grilley.

1727
03:02:42.109 --> 03:02:49.216
This is the test net that we'd be deploying to of course, we need actual test net Aetherium to do any deploying, so we wouldn't be able to here.

1728
03:02:49.216 --> 03:02:52.420
And if we go ahead and hit Deploy right now Metamask pops up.

1729
03:02:52.420 --> 03:02:56.251
But we get this little red thing saying insufficient funds.

1730
03:02:56.251 --> 03:03:03.449
Of course, later on, we'll learn how to add new networks like polygon like avalanche like phantom into our Metamask.

1731
03:03:03.449 --> 03:03:07.734
So we can deploy from any one of them as well.

1732
03:03:08.109 --> 03:03:18.515
Now, I mentioned this term before, but all this code that we wrote, when we hit this compile button, it compiles it down to the EVM or the Ethereum virtual machine.

1733
03:03:18.515 --> 03:03:21.786
Don't worry too much about what this means.

1734
03:03:21.786 --> 03:03:27.442
EVM is a standard of how to deploy smart contracts to Aetherium like blockchains.

1735
03:03:27.442 --> 03:03:30.966
And any blockchain that implements a type of EVM.

1736
03:03:30.966 --> 03:03:40.461
You can deploy solidity code to some examples of EVM compatible blockchains are going to be avalanche, Phantom, and polygon.

1737
03:03:40.461 --> 03:03:50.485
Since these are EVM compatible, this means we can write our solidity code, and deploy to these blockchains, which again, I'll show you later on how to add these new networks into your Metamask.

1738
03:03:50.485 --> 03:03:51.797
And then how to deploy them.

1739
03:03:51.797 --> 03:03:54.290
Let's do a quick recap of our first smart contract.

1740
03:03:54.290 --> 03:04:00.427
And then you should actually take a break, maybe get some ice cream or coffee because you absolutely deserve it.

1741
03:04:00.427 --> 03:04:00.934
Congratulations.

1742
03:04:00.934 --> 03:04:07.978
The first thing you always need to do in your smart contracts is tell solidity, what version of solidity that you're going to be using.

1743
03:04:07.978 --> 03:04:15.453
And additionally, you want to add an spdx license identifier, then you have to create your contract object and name your contract.

1744
03:04:15.453 --> 03:04:23.848
The contract in solidity is similar to a class in other programming languages, and everything inside the squiggly brackets is a part of that contract.

1745
03:04:23.848 --> 03:04:31.410
There are many different types in solidity like unsigned integer, 256, Boolean string, bytes, 32, etc.

1746
03:04:31.410 --> 03:04:36.128
If we want to create a new type, we can create what's called a struct in solidity.

1747
03:04:36.128 --> 03:04:48.593
You can create arrays or lists in solidity, you can create dictionaries, or what's called mappings in solidity or hash tables, which when you give it a key, it'll spit out the value that that key represents.

1748
03:04:48.593 --> 03:04:52.586
We can create functions in solidity that modify the state of the blockchain.

1749
03:04:52.586 --> 03:05:11.637
We can also create functions in solidity that don't modify the state of the blockchain view in pure functions, don't modify by the state of a blockchain, we also can specify different data locations in our functions, called data and memory mean that that data is only temporary and will only exist for the duration of the function.

1750
03:05:11.637 --> 03:05:14.575
Storage variables are permanent and stay there forever.

1751
03:05:14.575 --> 03:05:19.628
function parameters can't be stored variables because they're only going to exist for the duration of the function.

1752
03:05:19.628 --> 03:05:28.031
All the solidity code that we work with, when we hit Compile, it actually compiles down to this Aetherium virtual machine specifications.

1753
03:05:28.111 --> 03:05:29.744
We'll learn more about those specifications later.

1754
03:05:30.111 --> 03:05:36.825
but not least, another huge congratulations on your first contract here.

1755
03:05:37.111 --> 03:05:37.111
Awesome.

1756
03:05:37.111 --> 03:05:42.444
All right, let's get started on our lesson three, remember, everything is in the GitHub repository.

1757
03:05:42.444 --> 03:05:46.207
And we can scroll down, hit Lesson three and see all the code here.

1758
03:05:46.207 --> 03:05:48.248
I'm building up this repo as I film.

1759
03:05:48.248 --> 03:05:58.282
So underneath this lesson three is going to be a lot more information than just the code here, all of our code samples end with dash f f, c, which means dash Free Code Camp.

1760
03:05:58.282 --> 03:06:10.062
So if you see a GitHub repo that ends with dash F, F, C, know that that repository is associated with this course, I'm going to do a quick high level walkthrough of what we're going to be building in this lesson.

1761
03:06:10.111 --> 03:06:14.289
So you don't need to code right now just sit back watch and enjoy.

1762
03:06:14.289 --> 03:06:17.888
In this lesson, we're actually going to expand to having three different contracts.

1763
03:06:17.888 --> 03:06:23.628
Let's say we want to be able to deploy simple storage contracts from a contract itself.

1764
03:06:23.628 --> 03:06:35.195
Yes, contracts can indeed deploy contracts, we are going to create a contract called storage factory dot sole, that's going to be able to deploy and interact with other contracts itself.

1765
03:06:35.195 --> 03:06:44.029
So what we could do is we could go deploy this to a JavaScript VM, we're going to choose storage factory, and we're gonna go ahead and hit Deploy.

1766
03:06:44.029 --> 03:06:47.620
In our contract down below, we have a number of different functions.

1767
03:06:47.620 --> 03:07:02.554
Our top function is this function called crate simple storage contract, which we can click and it'll actually create a simple storage contract for us, then we can go ahead and interact with it at an IG zero will save a favorite number of one.

1768
03:07:02.554 --> 03:07:08.362
Now, if we hit SF get zero, we get one back.

1769
03:07:08.362 --> 03:07:12.568
And we can see the address of the simple storage contract that we just deployed.

1770
03:07:12.568 --> 03:07:19.161
Additionally, we're going to learn about a number of solidity features, such as importing inheritance, and so much more.

1771
03:07:19.161 --> 03:07:21.128
So let's go ahead and jump in.

1772
03:07:21.128 --> 03:07:24.915
And remember all the code is available here from the GitHub repository.

1773
03:07:24.915 --> 03:07:31.006
So be sure to refer back to these contracts if you get lost.

1774
03:07:31.112 --> 03:07:34.724
So here we are back in remix, and we have our simple storage dot soul.

1775
03:07:34.724 --> 03:07:40.080
If you skipped over the last section, be sure to go to the full blockchain solidity course, Jas.

1776
03:07:40.080 --> 03:07:44.568
And scroll down to lesson two, welcome to remix and grab this code.

1777
03:07:44.568 --> 03:07:46.571
Go to simple storage outsole.

1778
03:07:46.571 --> 03:07:48.931
And copy paste this code into remix.

1779
03:07:48.931 --> 03:07:54.796
Because this is where we're going to be starting from, we have this simple storage contract, which is great.

1780
03:07:54.796 --> 03:07:56.874
It allows us to store a favorite number.

1781
03:07:56.874 --> 03:08:01.579
And it allows us to store favorite numbers across different people in both mappings and arrays.

1782
03:08:01.579 --> 03:08:10.027
But let's say we want to get even more advanced with this, we actually can have a contract actually deploy other contracts for us.

1783
03:08:10.112 --> 03:08:19.722
And then go ahead and interact with those contracts from other contracts, contracts interacting with each other is an essential part of working with solidity and working with smart contracts.

1784
03:08:19.722 --> 03:08:25.730
The ability for contracts to seamlessly interact with each other is what's known as composability.

1785
03:08:25.730 --> 03:08:28.901
smart contracts are composable, because they can easily interact with each other.

1786
03:08:28.901 --> 03:08:40.536
This is especially awesome when it comes to things like defy where you can have really complex financial products interact with each other incredibly easily, since all their code is available on chain.

1787
03:08:40.536 --> 03:08:42.033
So we're going to learn how to do that.

1788
03:08:42.033 --> 03:08:47.613
So let's keep our simple storage contract exactly the way it is, we're going to create a new contract called storage factory.

1789
03:08:47.613 --> 03:08:54.829
So we're going to hit the New File button and type in storage, factory dot salt.

1790
03:08:54.829 --> 03:08:57.160
And let's close this off for now.

1791
03:08:57.160 --> 03:09:00.250
So let's go ahead and get this contract setup from what we learned before.

1792
03:09:00.250 --> 03:09:08.838
First thing we're going to want to do is the spdx license identifier, which we're going to do MIT.

1793
03:09:08.838 --> 03:09:13.044
And then the next thing we're always going to need is our solidity version.

1794
03:09:13.113 --> 03:09:18.890
So we'll do pragma solidity and we could do zero point 8.

1795
03:09:18.890 --> 03:09:18.953
7.

1796
03:09:18.953 --> 03:09:21.564
But for this one, let's do zero point 8.

1797
03:09:21.564 --> 03:09:25.161
0 And then just add the carrot, meaning any version of 0.

1798
03:09:25.161 --> 03:09:26.467
8 point something will work.

1799
03:09:26.467 --> 03:09:31.672
And then let's add our contract name, which is going to be storage factory.

1800
03:09:31.672 --> 03:09:38.988
Now hit command S or ctrl S or go to the compile tab and hit compile, and boom, we have our regular setup here.

1801
03:09:38.988 --> 03:09:43.898
Now we want to create a function that can actually deploy our simple storage contract.

1802
03:09:43.898 --> 03:09:47.258
So we'll create a function called function.

1803
03:09:47.258 --> 03:09:57.935
create simple storage contract, we'll have it be public, so anybody can call it will have to deploy a simple storage contract and save it to a global variable.

1804
03:09:57.935 --> 03:10:11.964
But before we can do it How can our storage factory contract know what our simple storage contract looks like? In order to deploy it, if our storage factory contract is going to deploy simple storage, it's going to need to know code of simple storage.

1805
03:10:11.964 --> 03:10:27.043
One way we can do this is we can actually go to our simple storage dot soul and copy everything underneath pragma, solidity and down and paste it into our storage factory dot soul underneath our pragma, solidity.

1806
03:10:27.114 --> 03:10:33.876
If we go ahead and compile and save this, it actually works our storage factory, that soul contract actually now has two contracts in it.

1807
03:10:33.876 --> 03:10:55.232
It has the simple storage contract, and it has the storage factory contract in it, you actually go to the deploy tab and scroll down to deploy while you're on the storage factory dot soul, not the simple storage that's all on storage factory, you can see that you can actually choose which one of these contracts to deploy, a single file of solidity can hold multiple different contracts.

1808
03:10:55.232 --> 03:11:15.271
Now that we have our simple storage, that's all in our storage factory, we can actually go ahead and create this function to deploy a simple storage console, we're going to create a global variable the same way that we would create any other global variable, we'll do the type, which is going to be type simple storage contract, we'll give it a visibility of public.

1809
03:11:15.271 --> 03:11:17.823
And we'll give it a variable name.

1810
03:11:17.823 --> 03:11:24.050
Type simple storage contract going to be public, the name of the variable is going to be simple storage.

1811
03:11:24.114 --> 03:11:33.864
Now in our function, create simple storage contract, we're gonna say simple storage equals new, simple storage.

1812
03:11:34.114 --> 03:11:39.685
This new keyword is how solidity knows Ah, okay, we're going to deploy a new simple storage contract.

1813
03:11:39.685 --> 03:11:47.415
So we go ahead and compile this, we'll go to the deploy tab, make sure we're on the JavaScript VM, we'll scroll down to the contract.

1814
03:11:47.415 --> 03:11:49.336
And we'll choose storage factory.

1815
03:11:49.336 --> 03:11:52.915
And remember, you need to have storage factory dot soul selected.

1816
03:11:52.915 --> 03:11:59.257
In order for that to show up storage factory, we'll go ahead and hit Deploy.

1817
03:11:59.257 --> 03:12:03.572
And now we see our storage factory contract has two buttons.

1818
03:12:03.572 --> 03:12:09.050
One is create simple storage, and the other one is going to be a view of our simple storage contract.

1819
03:12:09.050 --> 03:12:15.180
If we click it right now, it's going to show us that it's currently at address zero, because it gets initialized to being blank.

1820
03:12:15.180 --> 03:12:18.555
It's saying there is no simple storage contract currently deployed.

1821
03:12:18.555 --> 03:12:28.193
Now if we pull up our console and click create simple storage, we see we created a new function call storage factory dot create simple storage contract.

1822
03:12:28.193 --> 03:12:39.985
And in doing so we called this function which created and deployed a new simple storage contract, we can now see what address the simple storage contract is out by clicking the simple storage button and we see the address associated with it.

1823
03:12:39.985 --> 03:12:43.598
So now we know how a contract can actually deploy another contract.

1824
03:12:43.598 --> 03:12:53.729
But the thing is, having this massive chunk of code above our storage factory is a little bit redundant, especially since we have our other file called Simple Storage dot soul.

1825
03:12:53.729 --> 03:12:58.418
And let's say we have a contract that has got a ton of other contracts in it.

1826
03:12:58.418 --> 03:13:01.915
Always copy pasting all these contracts is going to be a lot of work.

1827
03:13:01.915 --> 03:13:05.839
So instead, what we can do is use what's called an import.

1828
03:13:05.839 --> 03:13:08.860
So let's go ahead and delete our contracts simple storage.

1829
03:13:08.860 --> 03:13:15.622
And now we're just going to type import dot slash simple storage dot soul.

1830
03:13:15.622 --> 03:13:22.061
This import dot slash simple storage dot Seoul is the exact same as our copy pasted version of simple storage.

1831
03:13:22.115 --> 03:13:22.896
That's all.

1832
03:13:27.115 --> 03:13:47.191
package or GitHub, which we'll get to in a minute of another file and says, Okay, we're going to paste that contract into the top of this contract here, we actually see we go back to compile, we go to deploy, let's delete our old contract, we can actually see storage factory dot soul again, we can deploy it, click the drop down.

1833
03:13:47.191 --> 03:13:50.508
And once again, we can run those functions exactly the same.

1834
03:13:50.508 --> 03:13:55.417
importing our contracts like this is much nicer than always copy pasting the code.

1835
03:13:55.417 --> 03:14:02.303
This way, if we want to change something in simple storage, we have one canonical place to go ahead and change it instead of having to change it in multiple different places.

1836
03:14:02.303 --> 03:14:13.202
Now additionally, you'll notice the pragma, solidity if we have our contracts in two separate files, we actually can have different versions of solidity right now our storage factory has carrot zero point 8.

1837
03:14:13.202 --> 03:14:16.650
0 Which means that anything within the 0.

1838
03:14:16.650 --> 03:14:19.200
8 range of this contract is okay.

1839
03:14:19.200 --> 03:14:23.952
But for simple storage that sole, it says anything in the zero point 8.

1840
03:14:23.952 --> 03:14:25.591
8 And above range is okay.

1841
03:14:25.591 --> 03:14:30.197
So if we were to try to change the compiler version 8.

1842
03:14:30.197 --> 03:14:38.689
5 And then go ahead and compile, a remix is going to automatically bump it up to a better version that is compatible with both of them, in this case eight point 13.

1843
03:14:38.689 --> 03:14:45.589
But if we, for example, changed our solidity version of storage factory to zero point 7.

1844
03:14:45.589 --> 03:14:48.179
0 And then tried to compile them.

1845
03:14:48.179 --> 03:14:54.590
We actually end up getting an issue parser error source file requires a different compiler version.

1846
03:14:54.590 --> 03:14:59.181
This is because our storage factory is saying hey, anything in 0.

1847
03:14:59.181 --> 03:15:00.410
7 means is okay.

1848
03:15:00.410 --> 03:15:05.488
However, our simple storage is saying anything in the zero point 8.

1849
03:15:05.488 --> 03:15:06.776
8 And above is okay.

1850
03:15:06.776 --> 03:15:09.063
So those two versions are not compatible.

1851
03:15:09.063 --> 03:15:13.751
So what we need to do is we need to make sure our versions of solidity are indeed compatible.

1852
03:15:13.751 --> 03:15:16.481
So let's change the version back recompile.

1853
03:15:16.481 --> 03:15:18.278
And now we're looking good again.

1854
03:15:18.278 --> 03:15:26.878
Now since we have this create simple storage contract, every single time we call it right now, it'll just replace whatever is currently in our public simple storage variable.

1855
03:15:26.878 --> 03:15:33.027
Let's go ahead and update this so that we can actually keep a running list of all of our deployed simple storage contracts.

1856
03:15:33.027 --> 03:15:41.444
So instead of having this be a single variable, we'll make this a simple storage array or list public simple storage array.

1857
03:15:41.444 --> 03:15:56.591
Now, whenever we create a new simple storage contract, instead of saving it like this, what we're going to do is we're going to save it as a memory variable by saying simple storage, simple storage equals new simple storage.

1858
03:15:56.591 --> 03:16:00.942
And we're going to add this variable to our simple storage array.

1859
03:16:00.942 --> 03:16:09.548
So the same way we did it before, we're gonna do simple storage array dot push, simple storage.

1860
03:16:09.548 --> 03:16:14.450
So I should spell storage, right? Let's go ahead and compile this looks good.

1861
03:16:14.450 --> 03:16:17.783
We'll deploy the storage factory deploy.

1862
03:16:17.783 --> 03:16:24.828
Like here, we now have simple storage array View button, we'll do create simple storage.

1863
03:16:24.828 --> 03:16:27.367
Now we can view the simple storage contract zero.

1864
03:16:27.367 --> 03:16:29.429
Right now there's nothing at one.

1865
03:16:29.429 --> 03:16:37.950
But if we create another simple storage contract, we can see the new simple storage contract address at index one.

1866
03:16:38.117 --> 03:16:43.053
All right, so this is great, we can now keep track of all of our simple storage deployments.

1867
03:16:43.117 --> 03:16:55.868
But how do we actually interact with them, let's say we wanted to be able to call the store function on all of our simple storage dot souls from our storage factory, you can think of the storage factory as almost like a manager of all of our simple storages.

1868
03:16:55.868 --> 03:16:59.052
That's all let's create a new function that can do exactly that.

1869
03:16:59.052 --> 03:17:07.024
So we'll create function, and we'll call it S F store, which is going to stand for storage factory store.

1870
03:17:07.118 --> 03:17:20.760
And it's going to take you in 256, simple storage index, and a UNT 256, underscore simple storage number.

1871
03:17:20.760 --> 03:17:23.893
There'll be a public auction as well.

1872
03:17:23.893 --> 03:17:29.071
Now in order for you to interact with any contract, you're always going to need two things.

1873
03:17:29.071 --> 03:17:31.514
And we're going to refer to this a lot.

1874
03:17:31.514 --> 03:17:38.243
You're always going to need the address of the contract, and the ABI of the contract.

1875
03:17:38.243 --> 03:17:49.537
The API stands for Application binary interface, the API will tell our code exactly how it can interact with the contract, we'll go deeper into API as we move on.

1876
03:17:49.537 --> 03:17:53.790
But if you go to your compile tab, you hit compile, and things are actually compiling.

1877
03:17:53.790 --> 03:17:57.265
You can scroll down, and you can see compilation details.

1878
03:17:57.265 --> 03:18:01.810
And you can see a whole bunch of information on your different contracts.

1879
03:18:01.810 --> 03:18:13.569
You can see the name of your contract, which for our simple storage contract is simple storage, you can see a whole bunch of metadata, like the compiler, the language output settings, all this other stuff.

1880
03:18:13.569 --> 03:18:17.660
You can see the exact bytecode and the opcodes, which we'll talk about much later.

1881
03:18:17.660 --> 03:18:24.970
But you can also see this API, this API tells you all the different inputs and outputs and everything you could do with this contract.

1882
03:18:24.970 --> 03:18:32.506
For example, in our simple storage, if we look at the zero with index of our API, we have a function add person.

1883
03:18:32.506 --> 03:18:44.998
If we look at one, we see our name to favorite number, we looked at two we can see our people three retrieve for store, it tells us all these different ways we can actually interact with our contract.

1884
03:18:44.998 --> 03:19:00.086
And the different functions that we can call, we know where addresses are, because we're storing them in this array here, our simple storage array, we can also get the API because we're importing simple storage dot soul when you compile simple storage on soul.

1885
03:19:00.086 --> 03:19:09.584
As you saw on the compilation details, whenever you compile it, it comes prepackaged with the ABI, we automatically get the ABI just by importing it like this.

1886
03:19:09.584 --> 03:19:13.896
In the future, we'll see other ways that we can actually get API's really easily.

1887
03:19:13.896 --> 03:19:19.803
So to call the store function on one of our contracts, we're first going to need to get that contract object.

1888
03:19:19.803 --> 03:19:26.151
So what we can do is we can say simple storage variable named simple storage.

1889
03:19:26.151 --> 03:19:34.532
Variable Name simple storage of type simple storage is going to be equal to a simple storage object.

1890
03:19:34.532 --> 03:19:46.864
And instead of doing new simple storage, like we did last time, we're just going to put the address of this simple storage object in here, which again, we can get from our array.

1891
03:19:46.864 --> 03:19:50.085
And in this function, we're passing the array index.

1892
03:19:50.085 --> 03:19:57.031
So we can say simple storage contract at address simple storage array.

1893
03:19:57.031 --> 03:20:01.220
At index simple Storage index.

1894
03:20:01.220 --> 03:20:06.452
This bracket notation here is how you access different elements of arrays.

1895
03:20:06.452 --> 03:20:19.008
So if we want the zeroeth element of our list here, simple storage index would be zero, and we pass it into this bit here, then that'll give us the address of our simple storage contract, which we pass into simple storage here.

1896
03:20:19.008 --> 03:20:26.841
Since this is an array of simple storage contracts, we can just access that simple storage contract using the index.

1897
03:20:26.841 --> 03:20:37.136
So we would say, simple store, Edge array at index underscore simple storage index.

1898
03:20:37.136 --> 03:20:44.977
Now we're saving the contract object at index simple storage index to our simple storage variable.

1899
03:20:44.977 --> 03:20:48.523
Our array here is keeping track of the addresses for us.

1900
03:20:48.523 --> 03:20:52.638
And it automatically comes with the ABI is here.

1901
03:20:52.638 --> 03:21:02.370
If this was just an array of addresses of the contract objects, instead, we would have to wrap the address in a simple storage object like this.

1902
03:21:02.370 --> 03:21:04.361
But we'll get to that much later.

1903
03:21:04.361 --> 03:21:08.995
So for now, all we have to do is this and we now have a simple storage contract object.

1904
03:21:08.995 --> 03:21:14.182
Now that we have it, we can call our store function on the simple storage contract.

1905
03:21:14.182 --> 03:21:18.320
So we'll call simple storage dot store.

1906
03:21:18.320 --> 03:21:23.691
And we'll store the simple storage number to it.

1907
03:21:23.691 --> 03:21:24.453
So this is perfect.

1908
03:21:24.453 --> 03:21:28.310
And if we were to deploy this right now, though, we wouldn't be able to read the store function.

1909
03:21:28.310 --> 03:21:33.693
So let's create another function that can read from the simple storage contract from the storage factory.

1910
03:21:33.693 --> 03:21:44.747
So we'll create a function called S F get, which stands for storage factory get, it'll take a un 256 underscore simple storage index.

1911
03:21:44.747 --> 03:21:51.136
This will be a public view function, since we're just going to be reading from our simple storage contract.

1912
03:21:51.136 --> 03:21:53.358
And it's going to return a UNT 256.

1913
03:21:53.358 --> 03:21:56.963
And we'll say simple storage.

1914
03:21:57.121 --> 03:21:59.666
Simple Storage.

1915
03:22:01.121 --> 03:22:06.603
when you use this same syntax from up here to get the contract simple storage array at the simple storage index.

1916
03:22:06.603 --> 03:22:13.351
And then we're going to do return, simple storage.

1917
03:22:13.351 --> 03:22:19.187
re retrieve to get that number that we just stored up here.

1918
03:22:19.187 --> 03:22:23.041
And I should spell retrieved correctly, so we get no issues.

1919
03:22:23.041 --> 03:22:23.548
Perfect.

1920
03:22:23.548 --> 03:22:34.443
So now we'll compile, we'll deploy JAVA script, we're working on a fake account, we're going to use our storage factory, go ahead and delete all the contracts we have so far.

1921
03:22:34.443 --> 03:22:37.580
Let's go ahead and deploy the drop down rate.

1922
03:22:37.580 --> 03:22:42.465
Right now if we do SF get at zero, we're going to get nothing.

1923
03:22:42.465 --> 03:22:45.261
Simple Storage address zero is going to be nothing.

1924
03:22:45.261 --> 03:22:47.822
Let's create a simple storage contract.

1925
03:22:47.822 --> 03:22:52.667
Now it's simple storage list, we get an address at zero.

1926
03:22:52.667 --> 03:22:56.963
If we hit SF get right now it didn't zero, we get zero.

1927
03:22:57.121 --> 03:23:00.727
So let's store a value on this contract here.

1928
03:23:02.121 --> 03:23:03.137
that contract is zero.

1929
03:23:05.121 --> 03:23:06.002
storage index.

1930
03:23:06.002 --> 03:23:08.781
And we're going to save the number seven.

1931
03:23:09.121 --> 03:23:11.025
we'll go ahead and do SF store.

1932
03:23:13.121 --> 03:23:17.527
is going to store the value seven into this contract.

1933
03:23:18.121 --> 03:23:22.537
we do SF get of zero now, it does indeed return seven.

1934
03:23:23.121 --> 03:23:26.803
do SF get one we're going to get nothing's going to happen.

1935
03:23:27.121 --> 03:23:29.621
we're actually going to get this revert error here.

1936
03:23:30.121 --> 03:23:32.053
create another simple storage contract.

1937
03:23:33.122 --> 03:23:37.056
one, we get zero, because we're gonna get that default value.

1938
03:23:37.122 --> 03:23:43.681
Let's go ahead on the simple storage contract and index one will store the number 16 will hit SF store.

1939
03:23:43.681 --> 03:23:46.522
Now we'll do SF get one and we get 16.

1940
03:23:46.522 --> 03:23:50.755
Feel free to pause right now and play around with this so that you really understand it.

1941
03:23:50.755 --> 03:24:05.758
The quick recap is our storage factory contract allows us to create simple storage contracts, it then saves it to our simple storage array, which we can then call different functions on, we can store values from our storage factory contract.

1942
03:24:05.758 --> 03:24:12.511
And then we can read values from our storage factory contract for any of the simple storage contracts that we've created.

1943
03:24:12.511 --> 03:24:17.622
This is incredibly powerful, we can additionally make these two functions even easier.

1944
03:24:17.622 --> 03:24:23.455
We can call the Retrieve function directly on this when we call simple storage array.

1945
03:24:23.455 --> 03:24:27.728
And then we have these brackets and add the simple storage index.

1946
03:24:27.728 --> 03:24:29.575
This returns a simple storage object.

1947
03:24:29.575 --> 03:24:42.415
So what we could do is we could actually delete this whole part and just do dot retrieve right here, and then delete this line and say return and just have it be just like this.

1948
03:24:42.415 --> 03:24:46.372
If you go ahead and save or hit Compile, you'll get the green checkmark there.

1949
03:24:46.372 --> 03:24:50.103
We're calling the Retrieve function on whatever this is.

1950
03:24:50.103 --> 03:24:53.535
And whatever this is, is a simple storage object.

1951
03:24:53.535 --> 03:24:54.293
So perfect.

1952
03:24:54.293 --> 03:25:08.490
We can do the same thing up here by deleting this part and just doing dot store, underscore simple store edge number, we save it.

1953
03:25:08.490 --> 03:25:10.384
And this will work exactly the same.

1954
03:25:10.384 --> 03:25:20.649
Awesome, we now have a simple storage contract that can store variables in a storage factory contract that can be almost like a manager of these simple storage contracts and deploy and interact with them themselves.

1955
03:25:20.649 --> 03:25:22.623
This is fantastic.

1956
03:25:22.623 --> 03:25:30.418
Now, let's say that we really liked the simple storage contract, but it doesn't do everything that we want it to do.

1957
03:25:30.418 --> 03:25:43.384
Maybe we want it so that whenever we actually store value doesn't store the favorite number, it stores the favorite number plus five, for some reason you want a contract that that everyone's favorite number is five numbers bigger than what they think it is.

1958
03:25:43.384 --> 03:25:46.767
But you really like everything else that this contract has to offer.

1959
03:25:46.767 --> 03:25:48.778
Let's create this new contract.

1960
03:25:48.778 --> 03:25:50.984
And we'll call it extra storage.

1961
03:25:51.123 --> 03:25:55.984
So we'll say extra storage dot soul.

1962
03:25:56.123 --> 03:26:08.539
And we'll create this new contract, we're going to set it up the exact same way we normally would spdx license identifier, gonna be MIT, we'll give it pragma solidity.

1963
03:26:08.539 --> 03:26:12.748
And we'll just do zero point 8.

1964
03:26:12.748 --> 03:26:14.265
0 with the carrot.

1965
03:26:14.265 --> 03:26:22.694
And we'll say contract, extra storage, like so if you save or compile, you'll get the green checkmark.

1966
03:26:22.694 --> 03:26:31.759
So what can we do? Well, the first thing we could do is we could copy paste all this code back into here, and then modify our extra storage contract as we see fit.

1967
03:26:31.759 --> 03:26:33.565
This seems a little bit redundant.

1968
03:26:33.565 --> 03:26:34.794
And a lot of work though.

1969
03:26:34.794 --> 03:26:51.189
So what's another way we can actually get our extra storage contract to be like our simple storage contract? Well, this is where we can do something called inheritance, we can have our extra storage contract, do what's called a child contract of our simple storage contract.

1970
03:26:51.189 --> 03:26:59.039
And we can have extra storage, inherit all the functionality of simple storage with two lines of code.

1971
03:26:59.124 --> 03:27:05.435
So first, in order for our extra storage contract to know about simple storage, we once again need to import it.

1972
03:27:05.435 --> 03:27:10.224
So we'll say import dot slash, simple storage dot soul.

1973
03:27:10.224 --> 03:27:17.047
And we'll say our contract extra storage is simple storage.

1974
03:27:17.047 --> 03:27:19.877
And we save or compile.

1975
03:27:20.124 --> 03:27:25.801
Now our extra storage contract is going to be the exact same as simple storage.

1976
03:27:25.801 --> 03:27:29.374
And it's going to do what's called inherit all the functionality of simple storage.

1977
03:27:29.374 --> 03:27:34.058
And we can actually even see that, let's go ahead and make sure this is compiled.

1978
03:27:34.124 --> 03:27:35.708
And we'll go and deploy this.

1979
03:27:37.124 --> 03:27:53.073
contract, we can see we have extra storage deployed with all the functions that simple storage has, if you want a contract to inherit all the functionality of another contract, you can just import it and say your contract is that other contract.

1980
03:27:53.073 --> 03:27:57.470
Now, we can add additional functions to our extra storage contract.

1981
03:27:57.470 --> 03:28:00.600
That will include all the functionality of simple storage.

1982
03:28:00.600 --> 03:28:04.031
Now, let's say that we inherit simple storage to extra storage.

1983
03:28:04.031 --> 03:28:08.253
However, one of the functions in simple storage we don't really actually like.

1984
03:28:08.253 --> 03:28:19.398
So if we go back to our simple storage contract, our store function, all it does is take a favorite number, and then assigns the global favorite number to whatever new number that we give it in our extra storage.

1985
03:28:19.398 --> 03:28:21.861
We want the store function to do something different.

1986
03:28:21.861 --> 03:28:26.222
We want it to add five, to any number that we give it.

1987
03:28:26.222 --> 03:28:30.387
How can we achieve this? Well, we can do something called overriding the functions.

1988
03:28:30.387 --> 03:28:33.366
And there are two keywords that we're going to use.

1989
03:28:33.366 --> 03:28:35.572
Those are virtual, and override.

1990
03:28:35.572 --> 03:28:41.072
Right now, if I were to try to implement a store function for extra storage, let's see what happens.

1991
03:28:41.072 --> 03:28:46.546
We'll say function store, you went to the six favorite number.

1992
03:28:46.546 --> 03:28:49.315
There'll be a public function.

1993
03:28:49.315 --> 03:28:59.705
And let's say instead of just storing favorite number, we'll say favorite number equals favorite number, plus five.

1994
03:28:59.705 --> 03:29:05.196
If we try to compile this right now, we'll actually run into two different errors.

1995
03:29:05.196 --> 03:29:09.711
First one is going to say overriding function is missing, override specifier.

1996
03:29:09.711 --> 03:29:22.948
If the parent contract, which in our case is simple storage has that same function, we need to tell solidity that we're going to override this store function and instead we're going to use this store function.

1997
03:29:22.948 --> 03:29:27.682
But additionally, we get this other error saying trying to override non virtual function.

1998
03:29:27.682 --> 03:29:37.056
Did you forget to add virtual in order for a function to be overridable you need to add the virtual keyword to the store function.

1999
03:29:37.125 --> 03:29:38.819
Now it can be overridable.

2000
03:29:41.125 --> 03:29:45.232
we still have this issue overriding function is missing override specifier.

2001
03:29:45.232 --> 03:29:49.140
And then all we need to do is add override to restore function.

2002
03:29:49.140 --> 03:29:54.029
Now if we save everything compiles correctly, let's go ahead and deploy this.

2003
03:29:54.029 --> 03:29:55.997
Let's delete our old contracts.

2004
03:29:56.125 --> 03:29:57.571
JavaScript VM right account.

2005
03:29:59.125 --> 03:30:01.093
extra store Reg, let's go ahead and deploy.

2006
03:30:02.125 --> 03:30:03.267
storage contract.

2007
03:30:06.125 --> 03:30:09.075
Previously, our store function would store the exact number.

2008
03:30:09.125 --> 03:30:13.397
However, if I were to store five, it'll store five, plus five.

2009
03:30:13.397 --> 03:30:15.634
So we should have 10 stored here.

2010
03:30:15.634 --> 03:30:21.322
Let's go ahead call store looks like that one through, and we'll hit retrieved now.

2011
03:30:21.322 --> 03:30:23.617
And we do indeed see 10 is in here.

2012
03:30:23.617 --> 03:30:28.449
So this is how we do inheritance, and we override functions.

2013
03:30:28.449 --> 03:30:30.507
And that's it.

2014
03:30:30.507 --> 03:30:37.355
For this section, you've just learned a ton of incredibly powerful solidity for having multiple files.

2015
03:30:37.355 --> 03:30:52.862
Let's do a quick overview of what we learned, we learned that we can actually deploy contracts from other contracts using the new keyword, we learned that we can actually import other contracts into our contracts and into our code using the Import keyword.

2016
03:30:52.862 --> 03:31:00.376
And the import keyword is the same as copying pasting that file to the location of the import line, we learned that we can interact with other contracts.

2017
03:31:00.376 --> 03:31:02.813
As long as we have the ABI and address.

2018
03:31:02.813 --> 03:31:04.766
We didn't learn too much about the ABI.

2019
03:31:04.766 --> 03:31:13.741
But we'll learn more later, we learned that if we want to create a child contract and inherit the functionality of some other contract, we can do something called inheritance.

2020
03:31:13.741 --> 03:31:20.190
And the way to inherit functionality is using the is keyword and saying our contract is some other contract.

2021
03:31:20.190 --> 03:31:26.745
However, if we want to change from the functionality of the parent contract, we have to override that function.

2022
03:31:26.745 --> 03:31:34.538
And additionally, we have to set the function we want to override to virtual now we can have our own store function, do whatever we want it to do.

2023
03:31:34.538 --> 03:31:36.370
That is the end of this lesson.

2024
03:31:36.370 --> 03:31:40.660
Once again, give yourself a huge round of applause a pat on the back for making it this far.

2025
03:31:40.660 --> 03:31:42.207
And for finishing this section.

2026
03:31:42.207 --> 03:31:51.598
You're getting more and more advanced facility so quickly, so be sure to celebrate the little wins by getting some ice cream, maybe going for a walk or tweeting about or posting on Reddit.

2027
03:31:51.598 --> 03:31:56.953
Congratulations, you have completed this section.

2028
03:31:57.127 --> 03:31:58.161
All right, everybody.

2029
03:31:58.161 --> 03:31:58.833
Welcome back.

2030
03:32:00.127 --> 03:32:02.076
Lesson four remix Funmi.

2031
03:32:06.127 --> 03:32:09.076
found on the GitHub repository associated with this course.

2032
03:32:09.127 --> 03:32:13.110
We're going to be working with two contracts here, one of them is fundament outsole.

2033
03:32:13.110 --> 03:32:21.323
And then one of them is price converted outsole Funmi dot Sol is going to be a contract that allows people to actually fund a collective good.

2034
03:32:21.323 --> 03:32:34.280
So people can send Aetherium send Aetherium, or polygon or Avalanche or Phantom, or whatever blockchain native token into this contract, and some owner of the contract can then withdraw those funds and do whatever they want.

2035
03:32:34.280 --> 03:32:47.241
After deploying this to a test net, we can see the list of functions this contract has, this will have two red buttons, which are used to notate to payable functions in fund in our fund function.

2036
03:32:47.241 --> 03:33:01.506
And in our withdrawal function, withdraw allows users to withdraw the funding and fund allows users to send money to the contract, what we can do is we can send some value along with our transaction.

2037
03:33:01.506 --> 03:33:11.437
When we call this fund function, then what we can do is we can actually fund this contract with a certain amount of eath, or way by pasting some value into the way value section.

2038
03:33:11.437 --> 03:33:16.634
And then hitting fund, we will now have sent money into our deployed contract.

2039
03:33:16.634 --> 03:33:27.061
And we can see a list of the funders and a mapping of those addresses and how much they've actually sent into the contract, we can then withdraw the funds out of the contract.

2040
03:33:27.127 --> 03:33:33.073
With a special exception with only the person who deployed this contract can actually withdraw the funds back out.

2041
03:33:33.128 --> 03:33:36.075
Once the funds are withdrawn, the amount of all the funds is reset back to zero.

2042
03:33:36.075 --> 03:33:38.022
Are you excited? Well, you should be.

2043
03:33:38.128 --> 03:33:56.576
And if you've finished the section, you've completed most of the basics of solidity, and you'll be ready to start making even more powerful smart contracts, we'll be using channeling price feeds to actually set the value of how much these people should be able to fund in USD as opposed to just in terms of ether, we're gonna go over a lot of advanced sections here.

2044
03:33:56.576 --> 03:33:59.478
And I'll let you know what parts might be a little bit harder to digest.

2045
03:33:59.478 --> 03:34:02.851
So you don't have to spend your entire time trying to figure out exactly what's going on.

2046
03:34:02.851 --> 03:34:09.898
Be sure to use the GitHub repo to your advantage here and the discussions tab to stay connected with other people taking this lesson.

2047
03:34:09.898 --> 03:34:12.160
Alright, let's jump in.

2048
03:34:12.160 --> 03:34:21.581
So at this point, in remix, you'll have a couple of contracts here, simple storage, storage, factory extra storage, maybe you refreshed remix, and these have gone away.

2049
03:34:21.581 --> 03:34:28.628
And in the case, make sure that you just don't have any of those tabs open, we're going to create a new contract called funding.

2050
03:34:28.628 --> 03:34:32.998
So let's go ahead and start creating our funding contract.

2051
03:34:32.998 --> 03:34:42.531
Again, we want it to be able to get funds from users and withdraw funds and set a minimum funding value in USD.

2052
03:34:42.531 --> 03:34:46.440
This is what we're going to get our contract to do.

2053
03:34:46.440 --> 03:34:58.240
So first, let's set it up spdx license I tend to fire MIT do pragma solidity do caret zero point 8.

2054
03:34:58.240 --> 03:34:58.385
8.

2055
03:34:58.385 --> 03:35:01.603
And we'll do contract bunbee.

2056
03:35:01.603 --> 03:35:02.258
Awesome.

2057
03:35:02.258 --> 03:35:05.718
And we'll compile, see if things look good.

2058
03:35:05.718 --> 03:35:06.504
And they do.

2059
03:35:06.504 --> 03:35:06.897
Great.

2060
03:35:06.897 --> 03:35:08.011
Let's keep going.

2061
03:35:08.011 --> 03:35:14.081
So before we actually embark on creating all of our functions here, let's just add the different functions that we're going to implement.

2062
03:35:14.129 --> 03:35:25.255
So we want a function fund for people to actually send money to, we want a function withdraw, or the owner of this contract to actually withdraw the funds that different funders actually give us.

2063
03:35:25.255 --> 03:35:26.905
And that's pretty much it.

2064
03:35:26.905 --> 03:35:35.383
These are the two main functions that we want this contract to do, we will be implementing more functions to help facilitate these two functions.

2065
03:35:35.383 --> 03:35:37.535
But let's get started by looking at fund.

2066
03:35:37.535 --> 03:35:39.279
let's comment out withdrawal for now.

2067
03:35:39.279 --> 03:35:40.779
And let's just start with fun.

2068
03:35:40.779 --> 03:35:44.004
So we want anybody to be able to call this fun function.

2069
03:35:44.004 --> 03:35:45.629
So we'll make this public.

2070
03:35:45.629 --> 03:35:52.269
So as we mentioned, we want to be able to set a minimum font amount in USD.

2071
03:35:52.269 --> 03:35:54.472
So there's a lot of things to think about here.

2072
03:35:54.472 --> 03:36:09.970
First thing we probably want to think about is how do we send eath to this contract, whenever we create a transaction on the on any of these EVM blockchains, there's this value field that we can set value represents how much Aetherium we're going to be sending with our transactions.

2073
03:36:09.970 --> 03:36:12.586
For example, when we transferred Aetherium.

2074
03:36:12.586 --> 03:36:19.557
between our different accounts, we were actually populating this value parameter with different amounts of Aetherium.

2075
03:36:19.557 --> 03:36:37.387
In fact, every single transaction that we send, will have these fields, it'll have a nonce or the transaction count the account the gas price, the gas limit that we've seen on ether scan a to aka the address that the transaction is sent to a value which is going to be this amount that we're talking about.

2076
03:36:37.387 --> 03:36:46.049
They'll also have data which is going to be what we send if we make a function call or deploy contract, and then we'll have this v r s components.

2077
03:36:46.049 --> 03:37:03.812
We're not really going to go over these v r and s because this is that cryptographic magic that's happening when a transaction is signed, but just know that that's it Now, for sending value, we can populate some of these fields, the gas limit, for example, was populated to 21,000 data is going to be empty.

2078
03:37:03.812 --> 03:37:13.880
And then that two is going to be the address of the transaction we want to send to, for a function call, we can also still populate the way that we want to send.

2079
03:37:13.880 --> 03:37:23.458
So we can call a function and send a value at the same time in remix has a little drop down here for way way Feeny and ether, we're gonna ignore Feeny for now.

2080
03:37:23.458 --> 03:37:25.708
But of course, we have our way, great and ether.

2081
03:37:25.708 --> 03:37:28.581
Again, we're one ether is worth this much way.

2082
03:37:28.581 --> 03:37:38.093
And this much way, the first thing we need to do in order to make a function payable with Aetherium, or any other native blockchain currency is we need to mark the function as payable.

2083
03:37:38.093 --> 03:37:57.664
It's this payable keyword that makes our font function red, as opposed to having it normal orange, just like how our wallet can hold funds, contract addresses can hold funds as well, since every time you deploy a contract, they get a contract address, it's nearly the exact same as a wallet address.

2084
03:37:57.664 --> 03:38:04.049
So both wallets and contracts can hold native blockchain token like Aetherium.

2085
03:38:04.130 --> 03:38:10.505
And you'll see that when we deploy this later on in the lesson, that actually will gain a balance of Aetherium.

2086
03:38:10.505 --> 03:38:21.487
Now that we have it payable, we can access this value attribute by using one of the global keywords in solidity with message dot value to get how much value somebody is sending.

2087
03:38:21.487 --> 03:38:23.919
You use message dot value in your function.

2088
03:38:23.919 --> 03:38:29.064
Now let's say we want to set our message add value to a certain value of Aetherium.

2089
03:38:29.130 --> 03:38:36.791
Let's say we wanted it to be let's say we wanted people to send at least one whole ether with all the transactions.

2090
03:38:36.791 --> 03:38:41.416
Or put another way, if they sent Aetherium, they would need to send at least one Aetherium.

2091
03:38:41.416 --> 03:38:51.946
How would we implement that? Well, we could do something called require, we would say we want to require the message dot value is greater than one e 18.

2092
03:38:51.946 --> 03:38:56.037
There's a couple of things to unpack here.

2093
03:38:56.037 --> 03:39:07.499
One, e 18 is equal to one times 10 raised to the 18th, which is also equal to 112345 678-910-1234 5678.

2094
03:39:07.499 --> 03:39:14.631
This is the value in way of one Aetherium this much way is one eath.

2095
03:39:14.631 --> 03:39:25.115
So if we wanted the message dot value to be at least one eath, or one polygon or whatever ranch etc, we would set it like this require message on value is greater than one.

2096
03:39:25.115 --> 03:39:31.983
This require keyword is a checker it says hey, is message dot value greater than one.

2097
03:39:31.983 --> 03:39:36.196
If not, it's going to revert, it's going to do what's called revert with an error message.

2098
03:39:36.196 --> 03:39:47.365
And we can say didn't send enough, we're gonna try deploying this on a JavaScript VM, deploy Funmi, we'll hit Deploy, look at Funmi we see this fun button is now red.

2099
03:39:47.365 --> 03:40:00.900
If we call Funmi right now, and we look at the console, you can see we actually get an error here, call it again, we get an error, we get an error here, we know that the air is going to be this didn't send enough.

2100
03:40:00.900 --> 03:40:09.669
So what we need to do is we need to send at least one ether with this fun transaction, in order for this require statement to be fulfilled.

2101
03:40:09.669 --> 03:40:14.359
So back up in the value section, we can change this value to one.

2102
03:40:14.359 --> 03:40:19.208
So that's gonna be one ether, or this much way or this much way.

2103
03:40:19.208 --> 03:40:23.072
Now we can hit fund oh actually needs to be greater than one.

2104
03:40:23.132 --> 03:40:25.465
So let's send to for example.

2105
03:40:25.465 --> 03:40:27.298
Now we'll scroll down.

2106
03:40:28.132 --> 03:40:29.007
we'll hit fund.

2107
03:40:32.132 --> 03:40:37.390
statement says if our first section is false, then go ahead and revert with this error.

2108
03:40:37.390 --> 03:40:42.674
What is reverting? Revert can be a little bit confusing, so I wouldn't let this section hold you back.

2109
03:40:42.674 --> 03:40:44.775
If it's a little bit confusing.

2110
03:40:44.775 --> 03:40:49.674
Revert is when it undos any actions that happened before and send the remaining gas back.

2111
03:40:49.674 --> 03:40:56.386
So what does that actually look like? Well, let's say for example, we had a un 256.

2112
03:40:56.386 --> 03:40:57.809
Public number.

2113
03:40:57.809 --> 03:41:02.606
And in our fund function, we said number equals five.

2114
03:41:02.606 --> 03:41:07.075
If we were to go ahead and deploy this, let's delete our old contract.

2115
03:41:07.132 --> 03:41:10.615
deployed this new contract or number right now is zero.

2116
03:41:11.132 --> 03:41:14.439
we were to call our fund function number gets set to five.

2117
03:41:14.439 --> 03:41:22.865
However, if we call a fund and this require isn't met, this transaction would revert an undue setting number to five.

2118
03:41:22.865 --> 03:41:25.671
So let's go ahead and look at our logs here.

2119
03:41:25.671 --> 03:41:29.502
We'll keep value zero so that our fun function reverts.

2120
03:41:29.502 --> 03:41:36.953
We'll call fund will see that this transaction failed because this require end up reverting and number is still zero.

2121
03:41:36.953 --> 03:41:59.266
So then the question becomes, did we actually spend gas Yes, we spent gas to change number to five and then any remaining gas we would get returned by this require for example, if we had a ton of computation here, it On a computation here, we would have need to send a ton of gas with our fun function.

2122
03:41:59.266 --> 03:42:12.296
But all the extra gas that we send, after this require gets returned the original user after it gets reverted right here, if reverts are a little bit confusing for you here, don't worry too much about it, we'll go over it in future modules.

2123
03:42:12.296 --> 03:42:23.563
All you need to know right now is that when you do a require statement, if this first section isn't met, the transaction will be canceled, and any prior work will be undone, and it'll send an error message.

2124
03:42:23.563 --> 03:42:23.870
Cool.

2125
03:42:23.870 --> 03:42:25.900
Let's delete this number for now.

2126
03:42:25.900 --> 03:42:28.396
And we'll delete it from the global scope.

2127
03:42:28.396 --> 03:42:34.370
There's actually another way to do these reverts, which we'll go over later in this contract.

2128
03:42:34.370 --> 03:42:37.929
So what we've done so far is great.

2129
03:42:38.133 --> 03:42:53.116
However, we're checking message dot value in terms of Aetherium, we're looking for one whole Aetherium instead of $50, we want to check that message add value is greater than some number like $50.

2130
03:42:53.116 --> 03:43:08.976
Let's go ahead and first set the minimum USD value we want people to send along with the fund function, we can do that at the top of our contract, we can say you went to 56 public minimum USD equals 50.

2131
03:43:08.976 --> 03:43:20.098
Now we have some place to check for minimum USD, we're going to update this minimum USD to make it more gas efficient and a little bit.

2132
03:43:20.098 --> 03:43:29.180
Now that we've set our minimum USD, we want to be able to require the message that value is greater than or let's say greater than or equal to the minimum USD.

2133
03:43:29.180 --> 03:43:36.134
But minimum USD is in terms of USD and value is in terms of Aetherium.

2134
03:43:36.134 --> 03:43:43.899
So how do we convert Aetherium to USD, this is where Oracle's and chainlink are going to come into play.

2135
03:43:43.899 --> 03:43:54.540
The USD value of Aetherium is something that we've assigned outside of the blockchain to Aetherium, or any other layer one currency or any other native smart contract platform currency.

2136
03:43:54.540 --> 03:44:03.634
So in order to get this value that is outside the blockchain, we have to use a decentralized Oracle network to get the price of one ether in terms of USD.

2137
03:44:03.634 --> 03:44:12.426
So before we can continue on here, let's learn a little bit more about the architecture of these decentralized Oracle networks and the different solutions that they have.

2138
03:44:12.426 --> 03:44:24.201
So that we can create this Funmi contract in the most advanced way possible, as we've talked about blockchains are deterministic systems, which means that they themselves can't actually interact with real world data and events.

2139
03:44:24.201 --> 03:44:28.828
They don't know what the value of an Aetherium is, they don't know what random numbers are.

2140
03:44:28.828 --> 03:44:34.667
They don't know if it's sunny outside, they don't know the temperature, they don't know who's president, they don't know any of this information.

2141
03:44:34.667 --> 03:44:38.134
These blockchains also can't do any external computation.

2142
03:44:38.134 --> 03:44:43.555
Maybe you have some amazing artificial intelligence model that you want to integrate with a smart contract.

2143
03:44:43.555 --> 03:44:46.569
smart contracts by themselves can't do anything with that.

2144
03:44:46.569 --> 03:44:50.212
As we've mentioned, this is because blockchains are deterministic by design.

2145
03:44:50.212 --> 03:44:52.848
This is so that all the nodes can reach consensus.

2146
03:44:52.848 --> 03:45:03.591
If you start adding variable data or random data, or values that returned from an API call, different nodes could get different results, and they would never be able to reach a consensus.

2147
03:45:03.591 --> 03:45:08.009
This is known as the smart contract connectivity problem, or the Oracle problem.

2148
03:45:08.009 --> 03:45:13.661
And this is bad news, because we want our smart contracts to be able to replace traditional agreements.

2149
03:45:13.661 --> 03:45:18.135
And traditional agreements need data and they need to interact with the real world.

2150
03:45:18.135 --> 03:45:21.965
So this is where chainlink and blockchain, Oracle's come into place.

2151
03:45:21.965 --> 03:45:28.924
A blockchain Oracle is going to be any device that interacts with the often world to provide external data or computation to smart contracts.

2152
03:45:28.924 --> 03:45:31.544
However, the whole story doesn't even in there.

2153
03:45:31.544 --> 03:45:36.935
If we use a centralized Oracle, we are reintroducing a point of failure.

2154
03:45:36.935 --> 03:45:40.210
We've done all this work to make our logic layer decentralized.

2155
03:45:40.210 --> 03:45:47.977
But if we get our data through a centralized node or through a centralized API, we decide we want to make the API call ourselves.

2156
03:45:47.977 --> 03:45:56.023
We are reintroducing these trust assumptions that we've worked so hard to get rid of, we're essentially ruining the entire purpose of building a smart contract.

2157
03:45:56.023 --> 03:46:01.447
So we don't want to get our data or do external computation through centralized nodes.

2158
03:46:01.447 --> 03:46:02.634
Those are bad news.

2159
03:46:02.634 --> 03:46:04.325
chain link is the solution here.

2160
03:46:04.325 --> 03:46:10.827
chain link is a decentralized Oracle network for bringing data and external computation into our smart contracts.

2161
03:46:10.827 --> 03:46:19.790
As we mentioned before, this gives rise to these hybrid smart contracts, which combined on chain and off chain to make incredibly feature rich, powerful applications.

2162
03:46:19.790 --> 03:46:27.987
chain link is a modular, decentralized Oracle network that can be customized to deliver any data or do any external computation that you like.

2163
03:46:27.987 --> 03:46:36.053
So for example, a lot of people say, Oh, I can just make an HTTPS call to some API, and we'll be good to go.

2164
03:46:36.135 --> 03:46:41.407
The blockchain nodes can't make these HTTPS calls, because they wouldn't be able to reach consensus.

2165
03:46:41.407 --> 03:46:44.685
If they called the node at different times, or they did something else.

2166
03:46:44.685 --> 03:46:46.747
All the consensus would be broken.

2167
03:46:46.747 --> 03:46:57.504
So instead, we need a decentralized network of chain link Oracle's to do this, and then in the transaction, this network of nodes will work Turn the data to our smart contracts for us.

2168
03:46:57.504 --> 03:47:03.830
Now chainlink networks can be completely customized to bring any data or any external computation that you want.

2169
03:47:03.830 --> 03:47:15.086
However, doing the customization can be a little bit extra work, there are a ton of chainlink features that come out of the box completely decentralized, ready to plug and play into your smart contract applications.

2170
03:47:15.136 --> 03:47:20.656
What are those features, the first one is going to be channeling data feeds, and that's the one we're actually going to be using for application here.

2171
03:47:20.656 --> 03:47:25.023
Channeling data feeds currently at the time of recording are powering over $50 billion.

2172
03:47:25.023 --> 03:47:51.785
In the defy world, the way they work is a network of chain link nodes gets data from different exchanges and data providers and brings that data through a network of decentralized chain like notes, the chain link nodes use a median to figure out what the actual price of the asset is, and then deliver that in a single transaction to what's called a reference contract, a price feed contract or a data contract on chain that other smart contracts can use.

2173
03:47:51.785 --> 03:47:57.564
And then those smart contracts use that pricing information to power their defy application, we can see an example.

2174
03:47:57.564 --> 03:48:00.732
We can see an example at data dot chain dot link.

2175
03:48:00.732 --> 03:48:07.823
And you can change networks, you can change price feeds, you can change a whole bunch of different information to see some of those popular price feeds.

2176
03:48:07.823 --> 03:48:10.010
Let's look at eath USD for example.

2177
03:48:10.010 --> 03:48:24.071
On eath USD, we can see this whole network of independent chain link node operators that are each getting different answers for the price of eth USD, they're getting aggregated by the network and then delivered on chain, we can see how often they're updated.

2178
03:48:24.136 --> 03:48:25.881
These ones are updated 4.

2179
03:48:28.136 --> 03:48:29.781
hour heartbeat, whichever one hits.

2180
03:48:31.136 --> 03:48:46.550
last update was we can see the number of Oracle responses etc, we can see the contract address directly on chain, we can even look at the contract on ether scan, we can see some of the history, we can see all the responses of the different Oracle's.

2181
03:48:46.550 --> 03:48:53.046
And then at the bottom, we can see the different users and sponsors, keeping this network up.

2182
03:48:53.046 --> 03:49:03.257
Similar to transaction gas, whenever a node operator delivers data to a smart contract, the chain link node operators are paid a little bit of Oracle gas in the chain link token.

2183
03:49:03.257 --> 03:49:10.821
Right now these users of the protocol are sponsoring keeping these feeds up and are paying the Oracle gas associated with delivering this data on chain.

2184
03:49:10.821 --> 03:49:29.530
Here's an illustration of what the current model of these data feeds look like a network of these chain link nodes, each reaches out and gets the information about an asset and then signs the data with their own private key in a single transaction, then, one node will deliver all the data with all the different signatures to a reference contract.

2185
03:49:29.530 --> 03:49:33.120
If that node doesn't deliver the data, another node will send it instead.

2186
03:49:33.120 --> 03:49:43.298
Reputation is incredibly important when your chain link node operator if you miss data updates, if you forget to send transactions, you'll probably be quickly kicked off these networks and have no chance of making any more money in the future.

2187
03:49:43.298 --> 03:50:01.298
These data feeds are used by some of the largest protocols in the space, such as synthetics, sushi swap compound, and Avi, with several billion dollars each, we can take a look at an example over at Doc's dot chain dot link work with EVM contracts, we're going to hit EVM chains, scroll down to data feeds.

2188
03:50:01.298 --> 03:50:04.007
We'll scroll down to the solidity section.

2189
03:50:04.137 --> 03:50:10.975
And we can see an example of an entire contract that uses and reads from one of these trending price feeds.

2190
03:50:10.975 --> 03:50:15.575
We can even open this up and remix and work with it and remix.

2191
03:50:15.575 --> 03:50:19.280
It looks like this example is reading from a price feed on COVID.

2192
03:50:19.280 --> 03:50:25.100
The reason we're actually going to use a test net to see this work is that there's a set of chain link nodes monitoring the test network.

2193
03:50:25.138 --> 03:50:27.441
Just to show you exactly how this works out.

2194
03:50:28.138 --> 03:50:35.915
deeper into the course, we'll show you how to actually run tests and work with chain link nodes without actually being on a test net, which will make your development much faster.

2195
03:50:35.915 --> 03:50:43.312
But I highly recommend walking through this section along with me so that you can see firsthand how this actually works.

2196
03:50:43.312 --> 03:50:46.388
So let's go ahead and faucets dot chain dot link slash COVID.

2197
03:50:46.388 --> 03:50:51.400
We're going to switch to the COVID network, we're going to get some COVID eath.

2198
03:50:51.400 --> 03:50:57.204
But remember, look at the network flag and use whatever network is in the documentation.

2199
03:50:57.204 --> 03:51:07.471
So to get some COVID, we're going to come to the faucet, we're going to turn off test link, we'll just stay with eath I'm not a robot, and then send request.

2200
03:51:07.471 --> 03:51:16.695
Once our COVID Aetherium has reached our wallet, we can go ahead and close we can take a look in our wallet and see that we do indeed have 0.

2201
03:51:16.695 --> 03:51:17.744
1 eath on Kelvin.

2202
03:51:17.744 --> 03:51:23.988
Now let's go back to our remix, we'll compile this contract, go and deploy this on injected web three.

2203
03:51:23.988 --> 03:51:33.388
And again, the reason we're going to use injected web three instead of JavaScript VM is that there's no network of chain link nodes watching our little fake JavaScript VM.

2204
03:51:33.388 --> 03:51:36.852
There are a network of chain link nodes watching the test net.

2205
03:51:36.852 --> 03:51:38.185
So we'll scroll down.

2206
03:51:38.185 --> 03:51:56.839
We'll switch contract to the price consumer V three, and we'll hit Deploy and a mass will pop up and after a brief delay, we can see our price feed consumer down here and we can hit Get the latest price which shows us the latest price of Aetherium in terms of USD you may be wondering why the number looks so weird.

2207
03:51:56.839 --> 03:52:06.289
That seems like a really large number for the price of Aetherium in terms of USD, and this is because decimals don't actually work so well in solidity, and we'll get to that in a little bit.

2208
03:52:06.289 --> 03:52:13.416
There's a decimals flag associated with this price feed address, that tells us how many decimals to include with this price.

2209
03:52:13.416 --> 03:52:15.138
It's also in the documentation.

2210
03:52:15.138 --> 03:52:17.884
However, I know that this one has eight decimals.

2211
03:52:17.884 --> 03:52:22.359
So this is saying the value of Aetherium right now is $3,262.

2212
03:52:22.359 --> 03:52:26.074
It may of course be different when you go ahead and try this.

2213
03:52:26.074 --> 03:52:30.696
Now there's a number of things that happened in this contract that I'll explain in our Funmi example.

2214
03:52:30.696 --> 03:52:35.089
But if you want to take a look now and see if you can figure out what's going on, I recommend you do so.

2215
03:52:35.139 --> 03:52:43.549
Price feeds are one of the most powerful out of the box decentralized features, you can use your smart contract to level them up, especially for decentralized finance.

2216
03:52:43.549 --> 03:52:55.456
If you're looking for different addresses of different price feeds, you can check the contract addresses section of the documentation, choose the network that you want, and then scroll down and look some of the different addresses of the different price feeds.

2217
03:52:55.456 --> 03:53:01.021
For example, this address will give you the price of one inch token in terms of Aetherium.

2218
03:53:01.021 --> 03:53:07.805
This address will give you the price of the Apple stock in terms of USD, and so on and so forth.

2219
03:53:07.805 --> 03:53:14.980
The next decentralized application right out of the box is going to be channeling VRF or channeling verifiable random dysfunction.

2220
03:53:14.980 --> 03:53:21.031
Once we do our lottery example a little bit later, we'll talk about how randomness can be manipulated in blockchain.

2221
03:53:21.031 --> 03:53:25.622
blockchains are deterministic systems, which by definition means that they can't have randomness.

2222
03:53:25.622 --> 03:53:37.806
If you can determine what a random number is, it's not really random anymore, is it? So we need to wait to get a provably random number by looking outside of the blockchain and Oracle's are perfectly positioned to do exactly that.

2223
03:53:37.806 --> 03:53:46.953
chainlink verifiable randomness function is a way to get provably a random number into our smart contract to guarantee fairness and guarantee randomness of applications.

2224
03:53:46.953 --> 03:54:01.377
Many protocols like pool together x infinity, ether cards, avocado cheese and more use channeling VRF for lotteries, randomizing NF T's for gaming and for more, we're going to do an example of channeling VRF in a later section.

2225
03:54:01.377 --> 03:54:10.868
Once we get to the lottery section, if you want to see if you can play with the randomness yourself right now, I recommend you go into Doc's chain link EVM chains, and scroll down to get a random number.

2226
03:54:10.868 --> 03:54:15.089
And this will teach you how to get a provably random number into your applications.

2227
03:54:15.140 --> 03:54:22.597
The next decentralized out of the box feature of chain link is chain like keepers, which is decentralized event driven execution.

2228
03:54:22.597 --> 03:54:32.864
As we've seen, in order to kick off some type of transaction, somebody needs to spend the gas and somebody needs to sit down and hit the go button or hit the transact button or hit the sun.

2229
03:54:32.864 --> 03:54:34.486
But this is obviously a centralized vector.

2230
03:54:34.486 --> 03:54:40.473
If you have a decentralized application that needs to run at specific times, or after specific events are triggered.

2231
03:54:40.473 --> 03:54:49.092
Channeling keepers are the solution to this channeling keepers are chain link nodes that listen to a registration contract for different events that you specify to fire.

2232
03:54:49.092 --> 03:55:09.381
Maybe you say every 10 minutes, you want to do something or once a week do something or if the price of some acid hits some number, or maybe a liquidity pool is at a certain level, whatever event that you want to code, you absolutely can the chain link nodes constantly listen for these triggers to happen and check the different contracts for these triggers.

2233
03:55:09.381 --> 03:55:22.263
Once a trigger returns true, the chain link nodes will then perform whatever action that you tell the chain link nodes to do, we're also not going to go over the chain link keepers examples right now, because we're going to get to them in a later module.

2234
03:55:22.263 --> 03:55:26.761
However, if you want to try them out, go to Doc's touching that link slash Aetherium.

2235
03:55:26.761 --> 03:55:31.630
Going and go to making compatible contracts and feel free to read the documentation.

2236
03:55:31.630 --> 03:55:32.528
Try it out yourself.

2237
03:55:32.528 --> 03:55:41.093
The last out of the box feature of chain link is the most customizable, but also the hardest to get correct end to end reliability is the ultimate promise of our smart contracts.

2238
03:55:41.141 --> 03:55:54.665
And we want and need them to be able to do anything, we want to be able to take any input and get any output making HTTP GET HTTP POST request is an easy way to customize our chain link nodes to be able to do anything.

2239
03:55:54.665 --> 03:56:06.327
Remember how we talked about making API calls that blockchain nodes themselves can do that? Well, chain link nodes can do that chain link nodes can make direct requests to any API that you specify.

2240
03:56:06.327 --> 03:56:25.074
In order to do this, you both have to choose the chain link node and the URL slash data to send the request to this is a little bit trickier than chain link VRF keepers or price feeds because you then have to be responsible for creating the chain link network that gets data from many different chain link nodes and many different data providers.

2241
03:56:25.141 --> 03:56:27.953
But let's look at an example in remix anyways.

2242
03:56:29.141 --> 03:56:31.341
feel free to just watch it since we are working with a test net here.

2243
03:56:31.341 --> 03:56:34.272
And test nets, as we've seen, can take a little bit of time.

2244
03:56:34.272 --> 03:56:36.334
As long as you're familiar with what this process looks like.

2245
03:56:36.334 --> 03:56:37.253
That's good enough.

2246
03:56:37.253 --> 03:56:40.203
You don't actually have to try it if you don't want to.

2247
03:56:40.203 --> 03:56:43.015
So we'll open up and remix will read through.

2248
03:56:43.141 --> 03:56:45.521
It looks like this example is on the COVID network.

2249
03:56:46.141 --> 03:56:48.045
ahead and compile API consumer.

2250
03:56:50.141 --> 03:56:55.046
on the injected web three, we're going to make sure that we're back on the COVID test network.

2251
03:56:55.046 --> 03:56:56.760
We're going to scroll down.

2252
03:56:56.760 --> 03:56:59.105
And we're going to change the contract to the API consumer.

2253
03:56:59.142 --> 03:57:04.379
And we're going to go ahead and hit Deploy, we're going to deploy this contract to the COVID.

2254
03:57:04.379 --> 03:57:04.989
Test net.

2255
03:57:04.989 --> 03:57:09.955
And now we can call this function called Request volume data to actually make an API call.

2256
03:57:09.955 --> 03:57:24.122
Now, like I mentioned before, whenever we request data from a chain link node, we have to pay a little bit of Oracle gas, or link token, in order to pay some link token, we're going to need to have link token in our API consumer contract.

2257
03:57:24.122 --> 03:57:32.563
This is what's known as the basic request and receive model to get link token, we go back to our faucet, and this time, we'll select 10 test link for our contract.

2258
03:57:32.563 --> 03:57:34.826
Let's go ahead and verify that we're human.

2259
03:57:34.826 --> 03:57:36.320
And we'll hit Send Request.

2260
03:57:36.320 --> 03:57:38.695
This time, instead of sending us Aetherium.

2261
03:57:38.695 --> 03:57:43.642
They're sending us 10 test link, which is what's known as an ERC 20 token.

2262
03:57:43.642 --> 03:57:51.142
Or more accurately, in ERC 677 We'll get to understanding that a little bit later, we can see the asset in our Metamask.

2263
03:57:51.142 --> 03:57:56.618
By importing the token, in order to get the token, we're going to come back to the documentation.

2264
03:57:56.618 --> 03:58:06.411
And we're going to look up link token contracts like that, we're going to go to the network that we just got the tokens on, which for us was COVID.

2265
03:58:06.411 --> 03:58:17.808
We're going to copy this address, we're gonna go to Metamask, hit import tokens, paste that address, and hit add custom token, and then import tokens.

2266
03:58:17.808 --> 03:58:23.282
And now we can see in our account one, we both have Aetherium and 10.

2267
03:58:23.282 --> 03:58:39.971
Link, now that we have our link or Oracle gas, we're going to send it to our API consumer, we're going to copy the address of the API consumer, open up our meta mask, we're gonna hit send, paste the address of our contract, switch the asset to link.

2268
03:58:39.971 --> 03:58:42.143
For now we'll just send 0.

2269
03:58:42.143 --> 03:58:42.688
2 link.

2270
03:58:42.688 --> 03:58:44.597
We'll hit next, next.

2271
03:58:44.597 --> 03:58:46.487
And we'll hit Confirm.

2272
03:58:46.487 --> 03:58:48.946
And we'll wait for this transaction to go through.

2273
03:58:48.946 --> 03:58:49.779
I chose 0.

2274
03:58:49.779 --> 03:59:00.209
2 Link, because in this contract, there's a fee character, which tells us how much making an API call for this is going to cost.

2275
03:59:00.209 --> 03:59:01.742
This one is actually 0.

2276
03:59:01.742 --> 03:59:02.808
1 link, I send 0.

2277
03:59:02.808 --> 03:59:02.874
2.

2278
03:59:03.143 --> 03:59:04.749
Just in case, we want to make that API call twice.

2279
03:59:05.143 --> 03:59:08.583
that's going on in this function will explain in a little bit later section.

2280
03:59:08.583 --> 03:59:30.455
But for now, I just want to show you what it looks like to do is, once we send the link to our contract, we can first check to see what the volume is volume is zero, we want to get the volume of the last 24 hours of Aetherium asset, we're going to be calling this API which has a ton of raw data, including one in specific called volume over the last 24 hours, which can be this number right here.

2281
03:59:30.455 --> 03:59:36.412
Say we wanted to get this into our contract from this API, we're going to make an HTTP GET call to this API.

2282
03:59:36.412 --> 03:59:41.906
And what's going to happen is we're going to make the request in one transaction.

2283
03:59:41.906 --> 03:59:50.143
And in a second transaction, the chain link node is gonna return the value and store it in this volume variable in the global scope.

2284
03:59:50.143 --> 03:59:56.361
So let's go ahead and hit request volume data Metamask gonna pop up, we're going to go ahead and hit Confirm.

2285
03:59:56.361 --> 03:59:58.820
And you'll notice right away volume doesn't update.

2286
03:59:58.820 --> 04:00:05.732
This is again, because we actually need to wait two transactions, we're sending a transaction for the request.

2287
04:00:05.732 --> 04:00:10.108
And then in a second transaction, the chain link node is actually going to respond.

2288
04:00:10.108 --> 04:00:16.894
And after a slight delay, the chain link node has indeed responded with the result of making that API call back to our contract.

2289
04:00:16.894 --> 04:00:19.968
We'll go over this process a little bit more in depth in later sections.

2290
04:00:19.968 --> 04:00:32.059
The reason that I wanted to show you specifically the API calls, is because we're going to show you a real life example of how to use chain link VRF and chain the keepers in a later lesson.

2291
04:00:32.144 --> 04:00:34.111
Now I know we've already gone over a ton.

2292
04:00:35.144 --> 04:00:35.596
review.

2293
04:00:39.144 --> 04:00:42.890
blockchain token with a function need to mark it as payable.

2294
04:00:43.144 --> 04:00:47.547
you need something in your contract to happen, and you want the whole transaction to fail.

2295
04:00:47.547 --> 04:00:50.398
If that doesn't happen, you can use a require statement.

2296
04:00:50.398 --> 04:00:57.756
To get the Aetherium or native blockchain token value of a transaction, you can use the global keyword message dot value.

2297
04:00:57.756 --> 04:01:06.080
chain link is a technology for getting external data and doing external computation in a decentralized context for our smart contracts.

2298
04:01:06.144 --> 04:01:20.572
Channeling data feeds or price feeds are ways to read pricing information or other pieces of data from the real world that's already aggregated and decentralized for us, channeling VRF is a way to get provably random numbers from the real world into our smart contracts.

2299
04:01:20.572 --> 04:01:24.971
Channeling keepers are a way to do decentralized event driven computation.

2300
04:01:24.971 --> 04:01:39.465
We can set some trigger say if this trigger hits do something and we get to define what the trigger is and what to do something is channeling any API's is the ultimate customization of channeling nodes and allows us to connect to anything on the planet.

2301
04:01:39.465 --> 04:01:41.286
To make this one production ready.

2302
04:01:41.286 --> 04:01:47.684
We have to do the most work because it doesn't come already with a decentralized Oracle network, like chaining the keepers and price feeds.

2303
04:01:47.684 --> 04:01:53.044
We'll learn more about these channeling services as we continue in this course.

2304
04:01:53.044 --> 04:02:09.662
Now in order for us to figure out if our message dot value is actually greater than the minimum USD that we set, we actually have to convert our message dot value from its layer one slash Aetherium to the USD equivalent.

2305
04:02:09.662 --> 04:02:19.334
So how are we actually going to do that? Well, first, we're gonna need to get the price of Aetherium, or Phantom, or Avalanche or whatever layer, one blockchain that we're working with.

2306
04:02:19.334 --> 04:02:23.380
So let's create a function to get that price to get that conversion rate.

2307
04:02:23.380 --> 04:02:35.430
So we'll do function, get price, and this is going to be the function that we use to get the price of the room in terms of USD, so we can convert our message dot value to USD.

2308
04:02:35.430 --> 04:02:42.975
And then we're also going to do a function called Get conversion rate.

2309
04:02:42.975 --> 04:02:49.930
These are both going to be public functions, so that we can go ahead and call them and test them and do whatever we want with them.

2310
04:02:49.930 --> 04:02:55.827
So in order to get the price, we're going to have to use one of these chain link data feeds to get the pricing information.

2311
04:02:55.827 --> 04:03:02.145
And we can look right here at this contract to see what using one of these channeling price feeds looks like.

2312
04:03:02.145 --> 04:03:16.176
What we're actually doing when we're interacting with this channeling price feed is we're actually reading from one of these contracts, there's a contract out there called the aggregator contract that has a function called latest round data, which returns a whole bunch of data.

2313
04:03:16.176 --> 04:03:18.318
But namely, this int price.

2314
04:03:18.318 --> 04:03:21.732
And this in price is what we are interested in.

2315
04:03:21.732 --> 04:03:32.789
Let's look at our get price function and figure out how do we actually call this since this is an instance of us interacting with a contract outside of our project, we're going to need two things.

2316
04:03:32.789 --> 04:03:40.583
What are those two things, we're going to need the ABI of the contract, and also the address of the contract.

2317
04:03:40.583 --> 04:03:49.715
So the address of the contract is going to be easy, we can get the address of the contract from the contract address this section of the chain link data feeds.

2318
04:03:49.715 --> 04:03:52.361
Let's scroll on down to bank B.

2319
04:03:52.361 --> 04:03:59.379
And we can find the eath USD address on Rigby and we'll create this contract so that it works on Rinkeby.

2320
04:03:59.379 --> 04:04:01.597
So we're going to grab this address, we're going to copy it.

2321
04:04:01.597 --> 04:04:05.016
And we're going to move back to our to our code here.

2322
04:04:05.146 --> 04:04:07.196
And we're going to paste the address here.

2323
04:04:08.146 --> 04:04:08.525
the address.

2324
04:04:10.146 --> 04:04:11.671
that we don't want to interact.

2325
04:04:13.146 --> 04:04:18.014
Well, what we did before was simple storage was we imported the entire contract into our code here.

2326
04:04:18.014 --> 04:04:19.724
That's something that we could do.

2327
04:04:19.724 --> 04:04:21.513
But that's actually a lot of code.

2328
04:04:21.513 --> 04:04:36.521
So what's something that we could do instead, remember, if we're looking at remix, and we look at one of the contracts that we compiled before, the ABI is really just kind of this list of the different functions and interactions you can have with a contract.

2329
04:04:36.521 --> 04:04:55.583
The ABI itself doesn't actually need to include any of the logic, it just needs to include, hey, here are the different functions that you can call, for example, in this contract, we can call fund, we have get conversion rate, we have get price, they're not implemented yet, but they will be eventually now there technically is another way to interact with contracts without the API.

2330
04:04:55.583 --> 04:04:58.180
But for now, we're just going to ignore that.

2331
04:04:58.180 --> 04:05:02.064
So how can we get the API, there's a concept in solidity called an interface.

2332
04:05:02.064 --> 04:05:04.606
And let's look at an example of an interface.

2333
04:05:04.606 --> 04:05:05.812
If we go to github.

2334
04:05:05.812 --> 04:05:16.851
com/smart, contract kits, chainlink, we can see a number of different contracts in the chainlink repository, we can go to contracts, src, V 0.

2335
04:05:16.851 --> 04:05:22.353
8, interfaces, and we'll go to aggregator v3 interface, dot soul.

2336
04:05:22.353 --> 04:05:30.423
And if we look at the solidity in here, we can see a whole bunch of function declarations, but none of the logic is actually implemented in this.

2337
04:05:30.423 --> 04:05:32.727
This is what's known as an interface.

2338
04:05:32.727 --> 04:05:41.385
If we compile this, we'll actually get the ABI of a contract, because it defines all the different ways we can interact with the contract.

2339
04:05:41.385 --> 04:05:50.318
It doesn't actually say, what these functions do, which is fine, though, because we don't need to know what the functions actually do, those are going to be stored in the contract.

2340
04:05:50.318 --> 04:05:56.974
So what we can do is we can grab this interface from the code and paste it into our remix.

2341
04:05:56.974 --> 04:06:02.442
Now hold on, if you're following along, you don't have to copy paste this with me, because I'm going to show you an easier way in just a second.

2342
04:06:02.442 --> 04:06:04.851
So for now, feel free to go ahead and just watch.

2343
04:06:04.851 --> 04:06:11.527
But once we have this interface aggregator v3 interface, we can now use this to make API calls.

2344
04:06:11.527 --> 04:06:16.560
So now we could say, aggregator v3 interface at this address.

2345
04:06:16.560 --> 04:06:24.387
And the combination of these two, give us that aggregator v3 contract with whatever code is here.

2346
04:06:24.387 --> 04:06:31.074
If at this contract address is aggregator v3 interfaces valid, we can do something like dot version.

2347
04:06:31.147 --> 04:06:32.459
Let's look at this interface.

2348
04:06:34.147 --> 04:06:34.750
sure is.

2349
04:06:39.147 --> 04:06:39.776
this contract.

2350
04:06:42.147 --> 04:06:42.943
different section.

2351
04:06:45.147 --> 04:06:47.687
version just to illustrate this.

2352
04:06:47.687 --> 04:06:49.572
I'm going to be public.

2353
04:06:50.147 --> 04:06:57.298
going to be a view and it's going to return the UN 256 and We're gonna split it up into two steps here.

2354
04:06:57.298 --> 04:07:02.082
We're gonna say aggregate tour, v3 interface, price feed.

2355
04:07:02.082 --> 04:07:13.322
So we're creating a variable of type aggregator v3 interface equals aggregator v3 interface at this address.

2356
04:07:13.322 --> 04:07:19.281
And then we're going to return price feed that version.

2357
04:07:19.281 --> 04:07:25.862
Now I'm going to go ahead and deploy this contract to Rigby just to show you what this git version is going to return.

2358
04:07:25.862 --> 04:07:34.574
But you don't have to follow along here if you don't want because again, we're working with the test net, you can just watch if you'd like for this section, we're going to test a little bit more sparse.

2359
04:07:34.574 --> 04:07:50.535
Since we're going to be mainly using the test net, since we're going to be working with an actual chain link Oracle network, once you move over to hard hat, and with JavaScript, all this testing locally will be a lot easier and a lot faster, you're more than welcome to go ahead and fiddle and try and test a lot of this stuff as we go along.

2360
04:07:50.535 --> 04:08:05.068
But just know that it might take a little bit longer to do some of the testing on the test net, let's delete that last funding contract, we're going to deploy this one, we're going to scroll up, we're going to switch to injected web three, we're going to switch from COVID to rink B.

2361
04:08:05.148 --> 04:08:24.574
And the reason we want to make sure we're on rink beam is because this address is specific to rink B, the contract that we're looking to interact with might not be at this address on every single chain, we want to make sure we're on the rink B chain for this, because of some other contract is there on the different chain, this version function obviously won't exist, and this function could error.

2362
04:08:24.574 --> 04:08:30.513
So let's go ahead, we're gonna find me, we're going to deploy this to the rink V chain.

2363
04:08:30.513 --> 04:08:33.390
Again, you don't have to follow along with me here, you can just watch.

2364
04:08:33.390 --> 04:08:37.960
And once that contract has been deployed, we now have a view function called Get version.

2365
04:08:37.960 --> 04:08:44.492
And we can see it's returning the variable for showing us that this is the fourth version of a price feed.

2366
04:08:44.492 --> 04:08:49.291
So this is a really easy way for us to interact with contracts that exist.

2367
04:08:49.291 --> 04:08:58.449
Outside of our project, we use one of these interfaces, which can get compiled down to the API, and then combine that ABI with the address to call a function.

2368
04:08:58.449 --> 04:09:02.815
As we work with these interfaces more and more, they'll start to make more and more sense.

2369
04:09:02.815 --> 04:09:08.610
So if it's a little confusing to you right now, don't get discouraged, the more you work with it, the easier it will become.

2370
04:09:08.610 --> 04:09:16.310
Now, though, now that we know how to call these functions in here, we can start working with this interface.

2371
04:09:16.310 --> 04:09:22.990
However, as you know, if we have a whole bunch of interfaces, we're gonna have to stick a whole bunch of interfaces at the top of our code, which looks pretty ugly.

2372
04:09:22.990 --> 04:09:30.260
What's a better way for us to do this? Well, before we used import, right, we imported from simple storage.

2373
04:09:30.260 --> 04:09:37.296
That's all for this one, what we could do is we could import from an array gay Tore v3 interface.

2374
04:09:37.296 --> 04:09:42.711
That's all, we can go ahead and create a new contract with this aggregator v3 interface.

2375
04:09:42.711 --> 04:09:46.542
Or what we can do is we can import this directly from GitHub.

2376
04:09:46.542 --> 04:10:19.550
If we go back to the documentation of these chainlink data feeds go to using data feeds, we scroll down, we see at the top, we have this import statement, import at chain link slash contracts slash SFC visa right interfaces aggregator v3 interface, this, this import is has the same path setup as the GitHub repository for the chain link code, instead of us directly adding all the code right into our remix, what we can do instead is we can import directly from GitHub, or what's called an NPM package.

2377
04:10:19.550 --> 04:10:42.869
Remix is smart enough to know that at chain link slash contracts, is referring to the NPM package at chain link slash contracts, we'll talk about NPM, a little bit in the future, it's what's known as a package manager, and can keep versions of different contracts for us to directly import into our code bases at chain link slash contracts is created directly from the chainlink GitHub repository.

2378
04:10:42.869 --> 04:10:47.450
So remix downloads this code from NPM, which is created from this GitHub.

2379
04:10:47.450 --> 04:10:51.416
So now we know that if we import at chain link slash contracts, src, V 0.

2380
04:10:51.416 --> 04:11:03.379
8 interfaces aggregator v3 interface dot soul, this is the same as if we had just stuck this whole contract right at the top of our funding contract, which makes our code look a lot nicer.

2381
04:11:03.379 --> 04:11:08.011
And now we have this aggregator v3 interface that we can work with.

2382
04:11:08.011 --> 04:11:09.118
Okay, great.

2383
04:11:09.118 --> 04:11:20.035
So now that we have a minimalistic interface, which will give us the API, how do we actually go ahead and get the price here? Well, documentation has a good example, if you want to play with it and try to reverse engineer it as well.

2384
04:11:20.035 --> 04:11:21.084
Here's how we're going to do it.

2385
04:11:21.150 --> 04:11:22.012
In our code.

2386
04:11:25.150 --> 04:11:43.007
interface object called price feed an aggregator v3 variable called price feed, which is going to equal to aggregator v3 interface contract at address this address exactly the same as what we're doing down here.

2387
04:11:43.007 --> 04:11:54.900
We're assuming a contract at this address is going to have all the functionality of this aggregator v3 interface, which again, means it has this decimals function, this description function version, get round data.

2388
04:11:54.900 --> 04:12:05.401
And the important one latest round data, which has the latest price at this answer piece, what we can do now is we can call that latest round data function on the price feed.

2389
04:12:05.401 --> 04:12:09.369
So we'll say price feed dot latest round data.

2390
04:12:09.369 --> 04:12:19.293
Now if we look at the interface, we see that this latest round data actually doesn't return one variable, it returns a whole bunch of different variables.

2391
04:12:19.293 --> 04:12:21.528
And that's what we're going to return in our contract.

2392
04:12:21.528 --> 04:12:41.865
So we're going to put these parentheses, and we're going to say, you went at round ID, we can even look right at the documentation to see what else it returns int price, you went, you went started out, you went timestamp.

2393
04:12:41.865 --> 04:12:46.892
And then you went ad, answered and round.

2394
04:12:46.892 --> 04:12:49.892
Now there's a lot of code here.

2395
04:12:49.892 --> 04:12:55.751
Since this function returns so many different variables, we have to set something up to capture them.

2396
04:12:55.751 --> 04:12:57.667
However, all we care about is price.

2397
04:12:57.667 --> 04:13:01.717
We don't care about round Id started at timestamp or answered in round.

2398
04:13:01.717 --> 04:13:09.832
So what we can do is just remove them and just leave the commas.

2399
04:13:10.151 --> 04:13:15.409
Now we have int price equals price feed that latest round data.

2400
04:13:15.409 --> 04:13:17.731
The reason that price is an int 256.

2401
04:13:17.731 --> 04:13:24.103
And not a un 256 is because some prices or some data feeds could be negative here, so that it's an int 256.

2402
04:13:24.103 --> 04:13:25.245
So it can stay flexible.

2403
04:13:25.245 --> 04:13:32.052
Now that we have the price, this is going to be price of eath in terms of USD.

2404
04:13:32.151 --> 04:13:34.906
And we saw an example of this before, it was around 3000.

2405
04:13:35.152 --> 04:13:40.359
it returned this number because solidity doesn't work with decimals for a number of reasons.

2406
04:13:40.359 --> 04:13:44.877
But we just need to know that there are eight decimal places associated with this price feed.

2407
04:13:44.877 --> 04:13:54.119
If you want to double check how many decimals there are, this contract has a decimal function that you can call as well, that will tell you exactly how many decimals are in this price feed.

2408
04:13:54.119 --> 04:13:58.167
Now as we know, message dot value is going to have 18 decimal places.

2409
04:13:58.167 --> 04:14:12.285
Why does it have 18 decimal places? Well, because one ether is equal to 1-234-567-8910 12345678 Is this massive number in way which has 18 zeros, which is equivalent to 1.

2410
04:14:12.285 --> 04:14:15.351
12345 678-910-1234 5678.

2411
04:14:15.351 --> 04:14:22.490
So we want these to have the same decimal places, right? Because right now this has eight, this is 18.

2412
04:14:22.490 --> 04:14:24.795
They're different units right now.

2413
04:14:24.795 --> 04:14:40.050
So to get them to match up, all we need to do is return price times one, ie 10, or one raised to the 10th, which is equal to 1123456789 10.

2414
04:14:40.152 --> 04:14:44.264
Message dot value, though, is going to be a UNT 256.

2415
04:14:45.152 --> 04:14:47.285
now, price is an interval at six.

2416
04:14:49.152 --> 04:14:50.764
value from n into 56.

2417
04:14:54.152 --> 04:14:57.824
called typecasting, all we need to do is add you into 56.

2418
04:14:58.152 --> 04:15:02.459
wrap this whole thing up between these two parentheses, you can't typecast anything.

2419
04:15:02.459 --> 04:15:08.893
But there are some values like into 56 and you into 56, that can be easily converted between the two.

2420
04:15:08.893 --> 04:15:18.419
Now of course, since we're not modifying any state with this get price function, we can make this view and say it returns that you went to 36.

2421
04:15:18.419 --> 04:15:21.946
And if we save and compile, we go ahead and we get that checkmark.

2422
04:15:21.946 --> 04:15:23.088
Now math can be a little bit tricky.

2423
04:15:23.153 --> 04:15:25.183
The first couple times you do it in solidity.

2424
04:15:26.153 --> 04:15:27.000
it, the easier it becomes.

2425
04:15:28.153 --> 04:15:33.943
reference a function like this to figure out okay, here's the easiest way for me to get this number.

2426
04:15:33.943 --> 04:15:34.330
Awesome.

2427
04:15:34.330 --> 04:15:41.034
So now we have a get price function, which is going to return a un 256, which is going to be the price of Aetherium.

2428
04:15:41.034 --> 04:15:46.856
In terms of USD, all we need to do is convert the message dot value from Aetherium.

2429
04:15:46.856 --> 04:15:51.849
To terms of dollars, let's create this get conversion rate function.

2430
04:15:51.849 --> 04:16:00.088
So this one, we're going to take an input parameter of un 256 of eath amount, it's going to be a public view function.

2431
04:16:00.088 --> 04:16:06.629
And it's going to return you went to 56, we're going to pass it some eath amount.

2432
04:16:06.629 --> 04:16:11.105
And on the other side, we're going to get how much that eath is worth in terms of USD.

2433
04:16:11.153 --> 04:16:14.062
So we're going to do a u intuity.

2434
04:16:16.153 --> 04:16:16.867
get price.

2435
04:16:21.153 --> 04:16:23.572
that we just created to get the price of Aetherium.

2436
04:16:24.153 --> 04:16:37.069
going to do u and 256 eath amount in USD equals eath price times eath amount, and then we're going to divide it by 118.

2437
04:16:37.153 --> 04:16:56.090
When you're doing multiplication and division math in solidity, you always want to multiply and add first and then go ahead and divide since eath price and eath amount both have 18 additional decimal places if we were to just let them rock without this, they would have an additional 36 zeros tax tacked onto the end.

2438
04:16:56.154 --> 04:16:57.340
So we need to divide by one EA team.

2439
04:16:58.154 --> 04:17:02.118
hard hat sections of this course testing all this math is going to be a lot easier.

2440
04:17:02.118 --> 04:17:06.291
And if you're really struggling with some of the math bits right now, I wouldn't let that slow you down.

2441
04:17:06.291 --> 04:17:11.841
Because once we get to heart, it's going to become a lot easier to actually test this than working on a test net.

2442
04:17:11.841 --> 04:17:15.392
And this eath amount in terms of USD is the number that we're looking for.

2443
04:17:15.392 --> 04:17:25.677
So we can just go ahead and return eath amount in USD, CSB returns here, and boom, now we have a good conversion rate function to walk you through the math real quick.

2444
04:17:25.677 --> 04:17:27.965
Let's say the eath price is going to be $3,000.

2445
04:17:27.965 --> 04:17:29.416
So it's going to be 3000.

2446
04:17:29.416 --> 04:17:36.444
But it's going to have an additional 18 zeros tacked on the end, it matches the message dot value way units.

2447
04:17:36.444 --> 04:17:50.454
And let's say for example, we send one eath or 112345 678-910-1234 5678 eath into this contract, one eath should equal $3,000.

2448
04:17:50.454 --> 04:18:00.868
So to get the price, we're going to now do the eath price, which is 3000 times the eath amount, which is this one, and then divide by one raised to the 18th.

2449
04:18:00.868 --> 04:18:19.967
So method out we'll do 3123 1-234-567-8910 12345678 times we'd 1001 2345678 1-234-567-8910 times 112345678 1-234-567-8910.

2450
04:18:20.154 --> 04:18:27.799
And now we divide that by 112345678 1-234-567-8910, which equals 2.

2451
04:18:27.799 --> 04:18:27.879
9.

2452
04:18:27.879 --> 04:18:34.515
Mmm, II 21, which the calculator kind of messed up them a little bit, but 2.

2453
04:18:34.515 --> 04:18:35.302
9, not 2.

2454
04:18:35.302 --> 04:18:40.086
99, ie 21 means this has 21 decimal places.

2455
04:18:40.086 --> 04:18:41.879
So it'd be 2.

2456
04:18:41.879 --> 04:18:53.238
1 234-567-8910 1-234-567-8910 one, or 1-234-567-8910 12345678 2900 I 9.

2457
04:18:53.238 --> 04:18:54.321
99 and a nine.

2458
04:18:54.321 --> 04:19:03.805
And this is actually exactly the reason why we don't do decimal math in solidity, our calculator saw that massive number was having a hard time getting it.

2459
04:19:03.805 --> 04:19:05.800
So it ended up rounding that number to 2.

2460
04:19:05.800 --> 04:19:05.945
999.

2461
04:19:05.945 --> 04:19:12.631
And nine, when we work exclusively with whole numbers in solidity, we don't have a chance of losing that precision.

2462
04:19:12.631 --> 04:19:22.655
And in solidity, this is going to return exactly $3,000, which is correct one Aetherium at $3,000 per Aetherium is going to be $3,000.

2463
04:19:22.655 --> 04:19:32.983
And like I said, since we're building this contract, assuming we're going to be working on this test net, we're not going to test this function on the test net, because we're going to have to wait for that transaction to go through.

2464
04:19:32.983 --> 04:19:45.712
If you want to go ahead and deploy this and play around with it yourself, you're more than welcome to Okay, great, now we have a function called Get conversion rate that we can use on our fund function to make sure we've sent enough message dot value in our fund.

2465
04:19:45.712 --> 04:19:52.961
So what we can do now is all we need to do is to get conversion rate of message dot value needs to be greater than the minimum USD.

2466
04:19:52.961 --> 04:19:56.827
Of course, right now our minimum USD is just in terms of 50.

2467
04:19:56.827 --> 04:20:09.663
And we know that conversion rate is going to return it with 18 zeros to represent the decimal places, our minimum USD amount needs to be upgraded to 10 to 50 times one e 18.

2468
04:20:09.663 --> 04:20:17.006
Or again, one times 10, raise the 18th, I'm going to deploy this to a test net just to demonstrate it.

2469
04:20:17.006 --> 04:20:20.206
But again, you don't have to if you don't want to wait for this.

2470
04:20:20.206 --> 04:20:22.506
So I'm gonna go ahead and deploy this confirm.

2471
04:20:22.506 --> 04:20:24.306
And now we have this funny contract.

2472
04:20:24.306 --> 04:20:29.926
If I don't say anything in value, and hit the fun button, we're gonna get this gas estimation error failed.

2473
04:20:29.926 --> 04:20:36.852
This is kind of a blanket error, basically saying, Hey, you can go ahead and send this transaction if you want, it's highly likely that it's not going to work.

2474
04:20:36.852 --> 04:20:45.346
And the reason that remix knows that it's probably not going to work is because it can see this require and simulate the transaction and say, Hey, you didn't send enough money with this.

2475
04:20:45.346 --> 04:20:51.065
However, even if we send some money, like 5000 way, it'll still give us this error.

2476
04:20:51.065 --> 04:20:52.456
Because that's not enough.

2477
04:20:52.456 --> 04:20:56.278
Let's do the calculation right now based on what the price of eath is.

2478
04:20:56.278 --> 04:21:02.105
So we can actually go to data dot chain that link, we look and see approximately what the price is.

2479
04:21:02.156 --> 04:21:04.477
So it looks like the price of Aetherium right now is about $3,000.

2480
04:21:04.477 --> 04:21:07.998
And this might be different for you depending on when you do that.

2481
04:21:07.998 --> 04:21:12.787
So if the price of Aetherium is $3,000, and our minimum is at least 50.

2482
04:21:12.787 --> 04:21:15.798
We could do 50 divided by 3000 0.

2483
04:21:15.798 --> 04:21:19.976
016 eath should be approximately enough.

2484
04:21:19.976 --> 04:21:25.287
So if we go to our Aetherium converter, and we do 0.

2485
04:21:25.287 --> 04:21:30.419
016, we'll get how much that is in way, let's do 0.

2486
04:21:30.419 --> 04:21:34.862
02 Just to make sure that we're going to be over the amount.

2487
04:21:34.862 --> 04:21:36.051
So we'll paste that in.

2488
04:21:36.156 --> 04:21:37.811
We'll change this to way.

2489
04:21:40.156 --> 04:21:47.632
instead of us getting that error popping up, it's going to actually go ahead and let us do the fun function and we could confirm it and it wouldn't fail.

2490
04:21:47.632 --> 04:21:51.878
I'm going to reject it for now just because I don't really feel like waiting for the transaction to go through.

2491
04:21:51.878 --> 04:21:52.433
But great.

2492
04:21:52.433 --> 04:21:59.557
We've confirmed that our get conversion rate is one working as intended, awesome, great work.

2493
04:22:00.157 --> 04:22:08.950
So what's the next bit of this funding contract that we want to do? Well, when people actually send money to this contract, we want to keep track of all the people who send us money.

2494
04:22:08.950 --> 04:22:10.957
So let's create some data structures.

2495
04:22:10.957 --> 04:22:11.720
To keep track.

2496
04:22:11.720 --> 04:22:15.072
Let's create an array of addresses called funders.

2497
04:22:15.072 --> 04:22:19.023
And we'll keep adding all the funders who send money to us.

2498
04:22:19.023 --> 04:22:23.157
So we'll say an address array, or an address list.

2499
04:22:23.157 --> 04:22:25.675
We'll make it public funders.

2500
04:22:25.675 --> 04:22:32.490
And anytime somebody sends us money, and this actually does indeed go through, we'll add that funded server list.

2501
04:22:32.490 --> 04:22:38.290
So we'll say funders dot push message dot sender, like message dot value.

2502
04:22:38.290 --> 04:22:47.460
Message dot sender is an always available global keyword message dot value stands for how much Aetherium or how much native blockchain currency is sent.

2503
04:22:47.460 --> 04:22:52.601
Message dot sender is the address of whoever calls the font function.

2504
04:22:52.601 --> 04:22:58.760
So if we're on Rigby message dot sender is going to be equal to whatever address is calling that function.

2505
04:22:58.760 --> 04:23:04.747
Since our address is sending the ether, we're going to add our address to this funders list.

2506
04:23:04.747 --> 04:23:21.549
This way we can keep track of all the wonderful donators who are donating to our contract, then maybe we won't even make a mapping of addresses to you and 250 sixes of addresses to how much money each one of these people have actually sent.

2507
04:23:21.549 --> 04:23:28.092
So we'll do address to you and 256 public address to amount funded.

2508
04:23:28.092 --> 04:23:37.634
And when somebody funds our contract will say address to amount funded of message dot sender equals message dot value.

2509
04:23:37.634 --> 04:23:41.272
Now we have a function where people can fund our contract.

2510
04:23:41.272 --> 04:23:48.033
And we can set a value in terms of USD and we keep track of the different funders who actually fund our contract.

2511
04:23:48.033 --> 04:23:50.001
This is fantastic.

2512
04:23:50.001 --> 04:23:56.258
Now I know we've gone over a lot of really intense math and intense stuff here.

2513
04:23:56.258 --> 04:23:59.287
So so let's do a quick refresher of what we've learned so far.

2514
04:23:59.287 --> 04:24:11.033
Whenever we work with a contract, we always need the API and the address when compiled an interface gives us that minimalistic API to interact with contracts outside of our project.

2515
04:24:11.033 --> 04:24:17.996
When you combine these compiled interfaces with an address, we can call the functions on that interface on that contract.

2516
04:24:17.996 --> 04:24:18.705
chain link.

2517
04:24:18.705 --> 04:24:22.421
data feeds are a decentralized way to get information about the real world.

2518
04:24:22.421 --> 04:24:29.919
In this case, we're getting the price of Aetherium in terms of USD from a decentralized collective of chain link nodes.

2519
04:24:29.919 --> 04:24:31.633
When working with math and solidity.

2520
04:24:31.633 --> 04:24:32.634
Decimals don't work.

2521
04:24:32.634 --> 04:24:36.048
So we need to keep that in mind when doing any type of math in solidity.

2522
04:24:36.048 --> 04:24:40.888
And we need to make sure we always have the correct units, so that our math makes sense.

2523
04:24:40.888 --> 04:24:50.258
Message dot value, and message dot sender, our globally available variables were message dot sender represents the sender of the message or transaction.

2524
04:24:50.258 --> 04:24:53.988
And message dot value represents the number of ways sent with the message.

2525
04:24:53.988 --> 04:24:58.581
There's a whole bunch of different special variables and functions that we can access at any time.

2526
04:24:58.581 --> 04:25:01.458
And these are available in the solidity documentation.

2527
04:25:01.458 --> 04:25:08.076
Alright, great, we've got a great way that we can actually start funding our contract.

2528
04:25:08.076 --> 04:25:20.372
But our code looks a little bit messy, we've got a couple of different functions for getting the price and working with these prices, is there a way to make this math a lot easier to use, this is where we're going to introduce the concept of a library.

2529
04:25:20.372 --> 04:25:23.784
So what is a library, I definitely recommend checking out solidity by example.

2530
04:25:23.784 --> 04:25:28.938
org, as you're going along with this course, as well, they've got some fantastic examples.

2531
04:25:28.938 --> 04:25:33.459
One of such example is going to be about libraries, libraries are similar to contracts.

2532
04:25:33.459 --> 04:25:36.322
But you can't declare any state variables and you can't send ether.

2533
04:25:36.322 --> 04:25:41.434
We can also use libraries to add more functionality to different values.

2534
04:25:41.434 --> 04:25:49.539
What do I mean by that? Well, what we can do actually is we can have get conversion rate be a function of a un 256.

2535
04:25:49.539 --> 04:25:57.635
So we could do something like Messer dot value dot get convert John, conversion rate.

2536
04:25:57.635 --> 04:26:04.926
And we can add functions as if you went to 36 was an object or a struct or a contract that we actually created.

2537
04:26:04.926 --> 04:26:10.982
So how do we do this? Well, let's create a new contract in our contracts folder and create a new file.

2538
04:26:10.982 --> 04:26:13.716
We're going to call it price converter, dot salt.

2539
04:26:13.716 --> 04:26:20.482
And our price converted outsole is going to be a library that we're going to attach to a un 256.

2540
04:26:20.482 --> 04:26:28.108
So how do you actually create a library and what is a library? Well, a library is going to be really, really similar to a smart contract.

2541
04:26:28.108 --> 04:26:33.565
It's gonna start with spdx license identifier.

2542
04:26:33.565 --> 04:26:39.859
My team, we're gonna give it a pragma, solidity zero point 8.

2543
04:26:39.859 --> 04:26:39.959
0.

2544
04:26:40.159 --> 04:26:45.809
And instead of typing contract for the name of the contract, we're going to do library for the name of the library.

2545
04:26:45.809 --> 04:26:47.970
We're going to call it price converter.

2546
04:26:47.970 --> 04:26:55.105
Now libraries can't have any state variables and they also can't send ether and all the functions in a library are going to be in there.

2547
04:26:55.159 --> 04:26:55.534
kernel.

2548
04:26:59.160 --> 04:27:08.910
we can grab get price, get version and get conversion rate, copy them all, delete them from Funmi dot soul and paste them into our library.

2549
04:27:08.910 --> 04:27:16.676
And of course, since we're using aggregator v3 interface in here, we can also copy the import from Funmi.

2550
04:27:16.676 --> 04:27:25.107
And since we're not using the aggregate of three interface and our contract anymore, and we're using our price converter, we can paste it into our price converter.

2551
04:27:25.107 --> 04:27:29.597
Now, if we compile price converted at soul, we see that it actually passes.

2552
04:27:29.597 --> 04:27:32.910
Now all the functions inside of our library need to be internal.

2553
04:27:32.910 --> 04:27:50.805
And we're gonna make this library price converter different functions, we can call on you activity six, for example, we're going to be able to do message dot value dot get conversion rate, we're going to directly be able to get the conversion rate of a value of a U and 256 as if that was a function for it the whole time.

2554
04:27:50.805 --> 04:27:53.063
So first, let's make this internal.

2555
04:27:53.063 --> 04:27:55.518
Let's make get conversion rate internal.

2556
04:27:55.518 --> 04:27:57.540
And we'll make good version internal.

2557
04:27:57.540 --> 04:28:05.367
Now that we have this library price converter back in our Funmi, we can now import this price converter and attach it to you in 256.

2558
04:28:05.367 --> 04:28:11.010
So we'll do import that slash price converter, dot soul.

2559
04:28:11.160 --> 04:28:18.626
And in Funmi, we'll do using price converter for UNT 256.

2560
04:28:19.160 --> 04:28:21.192
course, if we compile our Funmi.

2561
04:28:23.160 --> 04:28:26.110
issue because saying hey, get conversion rate isn't defined.

2562
04:28:26.160 --> 04:28:33.560
Now in our library, the first variable that gets passed to the function is going to be the object that it's called on itself.

2563
04:28:33.560 --> 04:28:38.123
So in Funmi dot soul, let's go ahead and comment out this line for now.

2564
04:28:38.123 --> 04:28:55.684
If we do message dot value dot get conversion rate, this is secretly the same as we did get conversion rate or message dot value in our price converter library, the message dot value is going to be passed as the input parameter to get conversion rate, forget price and get version we don't really care about the number.

2565
04:28:55.684 --> 04:28:58.446
So we're just going to leave it blank for now.

2566
04:28:58.446 --> 04:29:07.922
So instead of require get conversion rate of message dot value, we can now do message dot value dot get conversion rate.

2567
04:29:07.922 --> 04:29:17.111
And compile that you'll see that here we're not passing a variable, even though our get conversion rate function says hey, I'm expecting a variable.

2568
04:29:17.161 --> 04:29:23.643
Again, the reason for this is, is this message add value is considered the first parameter for any of these library functions.

2569
04:29:23.643 --> 04:29:24.928
And that's how it works.

2570
04:29:24.928 --> 04:29:31.374
If we wanted another variable in here, like you went to 56, something else.

2571
04:29:31.374 --> 04:29:35.974
Now we would want to pass something else in here 123.

2572
04:29:35.974 --> 04:29:38.574
And this 123 would get assigned to this something else.

2573
04:29:38.574 --> 04:29:40.964
But we're going to delete that for now.

2574
04:29:40.964 --> 04:29:41.947
Okay, great.

2575
04:29:41.947 --> 04:29:52.415
And in doing that, we've minimized our Funmi contract a lot by moving a lot of that math and price conversion stuff into our price converter library dot Sol.

2576
04:29:52.415 --> 04:30:01.737
One of the most common libraries that was used for the longest time was this library called Safe math dot Sol.

2577
04:30:01.737 --> 04:30:08.364
And you'll probably see it a lot of different places, we're gonna go off on a quick little tangent here and teach you about safe math.

2578
04:30:08.364 --> 04:30:10.550
So let's close Funmi close price converter.

2579
04:30:10.550 --> 04:30:15.403
And let's create a new file called Safe math tester.

2580
04:30:15.403 --> 04:30:16.541
That's all.

2581
04:30:16.541 --> 04:30:19.212
And let's start with some basic stuff in here.

2582
04:30:19.212 --> 04:30:22.263
Safe math was all over the place before version 0.

2583
04:30:22.263 --> 04:30:23.144
8 of solidity.

2584
04:30:23.144 --> 04:30:25.679
And now it's almost in no contracts.

2585
04:30:25.679 --> 04:30:31.781
What happened, why is safe math no longer used as much? Well, let's create a sample contract.

2586
04:30:31.781 --> 04:30:35.866
This is a section that you don't have to follow along if you don't want to code along with me.

2587
04:30:35.866 --> 04:30:38.443
But if you want to you absolutely still can.

2588
04:30:38.443 --> 04:30:45.749
This is going to be a contract we are going to deploy on a JavaScript virtual machine, we can use any version of solidity before version 0.

2589
04:30:45.749 --> 04:30:46.574
8 of solidity.

2590
04:30:46.574 --> 04:30:50.923
So for example, we use pragma, carrot, zero, point 6.

2591
04:30:50.923 --> 04:30:51.018
0.

2592
04:30:51.018 --> 04:30:56.066
And we'll create contract safe math tester, dot Sol.

2593
04:30:56.066 --> 04:31:02.230
Now if I create a you int eight, I set it to public big number.

2594
04:31:02.230 --> 04:31:06.697
And I set this to 255 Oops safe math tester.

2595
04:31:06.697 --> 04:31:12.323
Let's go ahead and compile safe math tester with zero point 6.

2596
04:31:12.323 --> 04:31:18.846
7 pragma, solidity, the maximum size of a Yewande eight is going to be 255.

2597
04:31:18.846 --> 04:31:23.276
This is going to be the biggest number that we can fit in the new int eight.

2598
04:31:23.276 --> 04:31:32.328
And if I were to deploy this to a JavaScript VM or even a test network, safe math tester, let's go ahead to play up.

2599
04:31:32.328 --> 04:31:35.694
If I hit big number, we're gonna get 255.

2600
04:31:35.694 --> 04:31:47.114
Well, what happens if I create a function called ADD? That sets big number equal to big number plus one? Let's save that.

2601
04:31:47.114 --> 04:31:49.399
Delete that old contract and deploy.

2602
04:31:49.399 --> 04:31:56.069
All right now big numbers 255 What happens when we add one two? big number.

2603
04:31:56.162 --> 04:32:01.404
When 255 is the max size a, UNT eight can be? Well, let's hit add.

2604
04:32:01.404 --> 04:32:04.226
Now let's check what big number is.

2605
04:32:04.226 --> 04:32:06.637
Big number gets reset to zero.

2606
04:32:06.637 --> 04:32:09.687
So what's going on? Well, prior to version 0.

2607
04:32:09.687 --> 04:32:23.589
8, of solidity, unsigned integers and integers ran on this concept of being unchecked, which means that if you passed the upper limit of a number, it would just wrap around and start back from the lowest number it could be.

2608
04:32:23.589 --> 04:32:33.086
So if I call add a whole bunch more times, and hit big number, now let's say if I were to hit this add button a ton more times and get it back to two and a 55.

2609
04:32:33.163 --> 04:32:35.210
It would then continue to wrap over to zero.

2610
04:32:36.163 --> 04:32:52.956
popular libraries that was out there was this safe math library, which would basically check to make sure that you weren't wrapping around a un 256 or an intuitive six, basically, it was a way to say, hey, you've reached the max this number can be and now your transaction is going to fail.

2611
04:32:52.956 --> 04:32:54.543
If we switch this to 0.

2612
04:32:54.543 --> 04:33:00.244
8, of solidity, delete the old contract, go switch this to 0.

2613
04:33:00.244 --> 04:33:00.325
8.

2614
04:33:00.325 --> 04:33:02.784
We'll go ahead and compile it.

2615
04:33:02.784 --> 04:33:07.020
And now we deploy this to JavaScript VM.

2616
04:33:07.163 --> 04:33:09.679
If I hit big number, we get to under 55.

2617
04:33:11.163 --> 04:33:12.256
actually fails.

2618
04:33:12.256 --> 04:33:14.521
And we still get to under 55.

2619
04:33:14.521 --> 04:33:15.536
In version 0.

2620
04:33:16.163 --> 04:33:29.195
solidity, they added this bit, where it automatically checks to make sure if you're going to do what's called overflow or underflow on a variable, we can actually revert back to the unchecked version by using an unchecked keyword.

2621
04:33:29.195 --> 04:33:39.092
So if we wrap this big number equals big number plus one in this unchecked bracket, let's delete our old contract will compile will redeploy.

2622
04:33:39.092 --> 04:33:40.877
We had big numbers to 55.

2623
04:33:40.877 --> 04:33:46.247
Now we hit add, we hit big number again, it reverted back to zero.

2624
04:33:46.247 --> 04:33:49.964
So that's a little bit more about safe math, checked and unchecked.

2625
04:33:49.964 --> 04:33:50.950
So in version 0.

2626
04:33:50.950 --> 04:33:59.452
76, and below this code that you see in front of you, is going to be the exact same as this code in 0.

2627
04:33:59.452 --> 04:33:59.553
8.

2628
04:33:59.553 --> 04:34:01.458
And above with this unchecked keyword.

2629
04:34:01.458 --> 04:34:14.503
Now you might be thinking in newer versions of solidity, why would I use this unchecked keyword? Well, you'll find out later that this unchecked keyword makes your code a little bit more gas efficient.

2630
04:34:14.503 --> 04:34:22.594
So if you're absolutely positive that your math is never going to reach the top or bottom limits of a number, that it might make sense for you to use the unchecked keyword.

2631
04:34:22.594 --> 04:34:31.079
Let's head back over to our Funmi contract, where we are now using the price converter library that we just created.

2632
04:34:31.164 --> 04:34:31.830
Alright, great.

2633
04:34:34.164 --> 04:34:35.943
here for actually doing the funding.

2634
04:34:37.164 --> 04:34:45.113
math for getting conversion rates done in our library price converter, which we're going to import at the top of Funmi.

2635
04:34:45.164 --> 04:34:45.422
Cool.

2636
04:34:45.422 --> 04:34:48.196
So at this point, we've got our fun method.

2637
04:34:48.196 --> 04:34:48.712
Awesome.

2638
04:34:49.164 --> 04:34:58.902
so we can allow anybody to go ahead and fund this contract and send this contract Aetherium, or any native blockchain currency to this contract.

2639
04:34:58.902 --> 04:35:08.099
Well, now what do we want to do? Well, once all the funders have gone ahead and funded, we're going to want the project to be able to withdraw the funds out of this contract.

2640
04:35:08.164 --> 04:35:13.836
So they can actually go ahead and use those funds to buy things for this project.

2641
04:35:13.836 --> 04:35:17.410
So let's go ahead and create a withdrawal function.

2642
04:35:17.410 --> 04:35:19.771
So we'll create a function withdraw.

2643
04:35:19.771 --> 04:35:21.283
And we'll make this public.

2644
04:35:21.283 --> 04:35:31.083
Since we're going to be withdrawing all the funds out of this contract, we probably also want to reset our funders array, and our address to amount funded.

2645
04:35:31.165 --> 04:35:36.498
Since we'll be withdrawing all the funds, those amounts should go back down to zero.

2646
04:35:36.498 --> 04:35:49.418
So let's go ahead and loop through the funders array and update our mapping object so that each of these funders now has zero, because in just a second, we're going to withdraw all the money from them.

2647
04:35:49.418 --> 04:35:53.040
So to do this, we're going to use something called a for loop.

2648
04:35:53.040 --> 04:36:03.704
So what is a for loop? A for loop is a way to loop through some type of index object or loop through some range of numbers or just do a task a certain amount of times repeating.

2649
04:36:03.704 --> 04:36:08.378
So for example, let's say we have an array or list.

2650
04:36:08.378 --> 04:36:11.935
And on that list, we have 1234.

2651
04:36:12.165 --> 04:36:18.230
If we wanted to get all of the elements in this array, or in this list, okay, 1234.

2652
04:36:18.230 --> 04:36:29.213
How do we get all the elements in this list? Well, we would use a for loop to loop through each one of these objects.

2653
04:36:29.213 --> 04:36:38.613
So at zero with index would be one at the first index would be two, and at the second index would be three, at the last index would be four.

2654
04:36:38.613 --> 04:36:44.358
So we would loop through the indexes zero through three to get all these elements.

2655
04:36:44.358 --> 04:36:58.116
Or maybe another example is if this was A, B, C, D, A is at the zero with index B is at the first index sees the second Indy's at the third and we will loop zero through three.

2656
04:36:58.116 --> 04:37:02.116
To get to each one of these elements, we're gonna do that exact same thing.

2657
04:37:02.166 --> 04:37:03.959
But with the funders array.

2658
04:37:06.166 --> 04:37:13.116
Well, we first start with the for keyword, the for keyword says, Okay, we're about to start a loop.

2659
04:37:13.116 --> 04:37:17.759
And inside of these parentheses, we define how we want to loop through it.

2660
04:37:17.759 --> 04:37:22.859
Also backslash star, and star backslash is sort of like brackets for comments.

2661
04:37:22.859 --> 04:37:26.534
Anything in between these two will be a comment.

2662
04:37:26.534 --> 04:37:35.666
So in a for loop, first, we give it the starting index, then we give it the ending index, and then we give it the step amount.

2663
04:37:35.666 --> 04:37:40.860
For example, maybe we want to start with zero, we want to go to 10.

2664
04:37:40.860 --> 04:37:43.492
And we want to go up by one each time.

2665
04:37:43.492 --> 04:37:46.022
So we would go 01 234-567-8910.

2666
04:37:46.022 --> 04:37:49.461
Or maybe we start at zero, we want to end at 10.

2667
04:37:49.461 --> 04:37:51.553
And we go up by two each time.

2668
04:37:51.553 --> 04:37:53.488
So we'd go 02468 10.

2669
04:37:53.488 --> 04:38:03.308
Or maybe we want to go from zero to five, we want to go from two to five, with a step of one, we'd go 2345, etc.

2670
04:38:03.308 --> 04:38:08.690
So this is what's going to go inside of this four bit here.

2671
04:38:08.690 --> 04:38:13.558
So for our starting index, and let me even just put this above so that you can reference it.

2672
04:38:13.558 --> 04:38:18.869
So our starting index is going to be you in to VT six variable, and we're going to call it funder index.

2673
04:38:18.869 --> 04:38:23.481
And we're going to start with thunder index being equal to zero.

2674
04:38:23.481 --> 04:38:25.808
So we're starting with zero here.

2675
04:38:25.808 --> 04:38:33.119
And we're going to end with the length of our funders array, since we want to loop through all of the funders.

2676
04:38:33.166 --> 04:38:41.500
So we're going to say, funder index needs to be less than funders dot length.

2677
04:38:41.500 --> 04:38:49.658
So our ending index is going to be whenever funders index is no longer less than funders dot length.

2678
04:38:49.658 --> 04:39:03.928
And then finally, we're gonna say funder index equals funder index, plus one, which means that every time the code inside of this loop finishes, we're going to increase funder index by one.

2679
04:39:03.928 --> 04:39:08.522
That's how we go from zero to one to two to three to four to five, etc.

2680
04:39:08.522 --> 04:39:21.691
Another way you can type funder index equals funder index plus one is you can just do funder index plus plus, this plus plus syntax means funder index equals itself plus one.

2681
04:39:21.691 --> 04:39:31.747
So let's start looping through our funders array to access the the zero with element or the first element, we're going to say, funders of funder index.

2682
04:39:31.747 --> 04:39:37.532
So we're saying we want to access the zero with element of our funders object.

2683
04:39:37.532 --> 04:39:48.517
And this is going to return an address for us to use, we're gonna go ahead and say address under equals funders at the funder index.

2684
04:39:48.517 --> 04:39:50.973
So now we have this funder address.

2685
04:39:50.973 --> 04:39:55.019
And we want to use this to reset our mapping.

2686
04:39:55.019 --> 04:40:07.014
So we're going to say, address to amount funded at at the funder key is now equal to zero.

2687
04:40:07.167 --> 04:40:11.844
Because remember, in fund we update the amount.

2688
04:40:13.167 --> 04:40:20.135
fund the contract, when we withdraw the money from the contract, we're going to reset it back to zero.

2689
04:40:20.135 --> 04:40:23.752
Now let's walk through this funder index starts from zero.

2690
04:40:23.752 --> 04:40:45.929
So we're going to get the zero with funder, we're going to grab that funder at the zero with index and we're going to reset the address to male funded of that funder to zero, then this for loop is going to update by one, it's going to move from zero to one, it's going to check then if funder index is less than the length, let's say funders has 10 people in it.

2691
04:40:45.929 --> 04:40:48.930
If funders has 10 people in it, it'll still be less.

2692
04:40:48.930 --> 04:41:07.105
So now funder links will be one address funder will equal funders of one now instead of zero, and we'll grab that address, and we'll reset that addresses about funded to zero, then we'll continue to two to three to four all the way up to the length of our funders array.

2693
04:41:07.168 --> 04:41:09.599
And this is how we can loop through our objects.

2694
04:41:10.168 --> 04:41:19.739
this middle one is the ending index isn't exactly right, since we're really checking for a boolean to see if this is still true, but hopefully you get the idea.

2695
04:41:19.739 --> 04:41:22.422
So we've reset the balances of the mapping.

2696
04:41:22.422 --> 04:41:30.043
However, we still haven't done two things, we still need to reset the array to make the funders a blank array.

2697
04:41:30.043 --> 04:41:34.909
And then we also need to actually withdraw the funds.

2698
04:41:34.909 --> 04:41:43.868
Since when we funded this, we sent message dot value along with calling this fund function.

2699
04:41:43.868 --> 04:41:46.840
However, we didn't actually withdraw the funds.

2700
04:41:46.840 --> 04:41:54.075
So to reset the array, we could loop through it and delete objects from this address array.

2701
04:41:54.168 --> 04:41:58.513
Or we could Just totally refresh this variable.

2702
04:41:58.513 --> 04:42:42.187
So instead of looping through the array and deleting objects, we're just going to say funders equals a new address array, we're going to completely reset the array by saying this font is variable now equals a brand new address array with zero objects in it to start, if we were to put a one here, this would be there'll be one element to start in the array, two would be two, three would be three, etc, we're just going to start it as a completely blank new array.

2703
04:42:42.187 --> 04:42:45.393
So great, we've gone ahead and reset the array.

2704
04:42:45.393 --> 04:43:11.316
But how do we actually now with draw funds from this contract? How do we send the funds back to whomever is calling this now to actually send ether or send native blockchain currency, there are actually three different ways to do this, we're going to look at all three, and say what the differences between the three of them are, the three different ways are going to be transfer, send, and call.

2705
04:43:11.316 --> 04:43:14.512
Let's go ahead and start with transfer.

2706
04:43:14.512 --> 04:43:19.902
Since transfer is the simplest and at surface level makes the most sense to us.

2707
04:43:19.902 --> 04:43:30.219
So if we want to transfer the funds to whomever is calling this withdrawal function, we would do we would say message dot sender, dot transfer.

2708
04:43:30.219 --> 04:43:48.202
And then we'd get the balance of our contract here by saying address this, this keyword refers to this whole contract dot balance, and we can get the native blockchain currency or the Aetherium currency balance of this address like this.

2709
04:43:48.202 --> 04:44:01.915
And we can just do that only thing that we need to do is we need to cast we need to typecast message dot sender from an address type to a payable address type.

2710
04:44:01.915 --> 04:44:07.878
So message dot sender is of type address.

2711
04:44:08.170 --> 04:44:21.780
Whereas payable, message that sender is of type, payable address, and in solidity in order to send the native blockchain token like Aetherium, you can only work with payable addresses.

2712
04:44:21.780 --> 04:44:25.545
To do that, we just wrap it in this payable type caster.

2713
04:44:25.545 --> 04:44:41.721
So this is the first way that we actually send Aetherium or send tokens from different contracts to each other, we wrap the address that we want to send it in, in this payable keyword, we do dot transfer, and then we say exactly how much we want to transfer.

2714
04:44:41.721 --> 04:44:44.479
But there are some issues with transfer.

2715
04:44:44.479 --> 04:44:57.790
Here we are on solidity by example, for sending ether, which, again is a fantastic resource to refer to, if you get lost, the method that we just looked at was this transfer method.

2716
04:44:57.790 --> 04:45:08.301
Now we saw way earlier in the course, that if I sent Aetherium, from one address to another, it cost about 2100 gas or 2100.

2717
04:45:08.301 --> 04:45:13.220
Gas, our transfer function is capped at 2300 gas.

2718
04:45:13.220 --> 04:45:16.907
And if more gas is used, it throws an error.

2719
04:45:16.907 --> 04:45:22.203
The next one that we're using is going to be sent which is also capped at 2300 gas.

2720
04:45:22.203 --> 04:45:25.334
And if it fails, it'll return a Boolean.

2721
04:45:25.334 --> 04:45:37.154
So with transfer, if this line fails, it'll air and revert the transaction with send, it won't air, it'll return a boolean of whether or not it was successful.

2722
04:45:37.154 --> 04:45:45.980
So using send will do payable message that sender that send address this balance.

2723
04:45:45.980 --> 04:45:50.724
But we don't want to finish our call here.

2724
04:45:50.724 --> 04:45:57.409
If this were to fail, the contract wouldn't revert the transaction, and we just want to get our money sent.

2725
04:45:57.409 --> 04:46:04.567
So we want to do Boolean send success equals this whole bit here.

2726
04:46:04.567 --> 04:46:08.271
And then we want to require success.

2727
04:46:08.271 --> 04:46:15.049
And if this send fails will throw an error saying sin failed.

2728
04:46:15.171 --> 04:46:21.252
This way, if this fails, we will still revert by adding our require statement here.

2729
04:46:21.252 --> 04:46:29.858
Transfer automatically reverts if the transfer fails, send will only revert the transaction if we add this require statement here.

2730
04:46:29.858 --> 04:46:30.420
So great.

2731
04:46:30.420 --> 04:46:37.323
What's the third way that we can actually send Etherium or native currency wallets with this call command.

2732
04:46:37.323 --> 04:46:48.094
Now call is going to be one of the first lower level commands that we actually use in our solidity code, because this call function is actually incredibly powerful.

2733
04:46:48.171 --> 04:46:59.155
And we can use it to call virtually any function in all of Aetherium without even having to Have the API we'll learn the advanced ways to use this call much later.

2734
04:46:59.155 --> 04:47:14.059
For now, we're just going to learn how to use it to send Aetherium, or your native blockchain currency call is going to look very similar to send, we're going to do payable, message dot sender, dot call.

2735
04:47:14.172 --> 04:47:23.680
And this is where we will put any function information or any information about the function, we want to call on some other contract, we actually don't want to call a function.

2736
04:47:23.680 --> 04:47:32.047
So we're going to leave this blank, we can show that we're leaving it blank by just putting in these two quotes here, we instead want to use this like a transaction.

2737
04:47:32.047 --> 04:47:43.417
And as we saw in our deployment, there's always this message dot value bid, we're going to use this call function as if it's a regular transaction, and we can add stuff like message dot value.

2738
04:47:43.417 --> 04:47:48.614
So in here, we're going to add these squiggly brackets.

2739
04:47:48.614 --> 04:48:00.856
And we're going to say, value address this dot balance, this call function returns actually two variables.

2740
04:48:00.856 --> 04:48:14.137
And when a function returns two variables, we can show that by placing them into parentheses on the left hand side, the two variables, it returns are going to be a Boolean, that we're going to call call success.

2741
04:48:14.137 --> 04:48:22.172
And also a bytes object called data returned, since call allows us to actually call different functions.

2742
04:48:22.172 --> 04:48:30.105
If that function returns some data or returns value, we're going to save that in the data returned variable.

2743
04:48:30.105 --> 04:48:36.522
It also returns call success, where if the function was successfully called this will be true.

2744
04:48:36.522 --> 04:48:38.890
If not, this will be false.

2745
04:48:38.890 --> 04:48:45.071
And since bytes objects are arrays, data returns needs to be in memory.

2746
04:48:45.071 --> 04:48:51.141
Now for our code here, we're actually not calling a function, so we don't really care about data returned.

2747
04:48:51.141 --> 04:49:02.664
So similar to what we saw with the price contract, we can just go ahead and delete that and leave the comma to tell solidity Yeah, we know this function returns two variables, but we only care about one.

2748
04:49:02.664 --> 04:49:13.011
And then similar to the centerpiece above, we're going to do require cost access call failed, meaning that we're requiring cost accesses true.

2749
04:49:13.011 --> 04:49:16.696
Otherwise, we'll revert with an error that says call failed.

2750
04:49:16.696 --> 04:49:21.156
Now of learning the difference between these three is a little complicated for you right now.

2751
04:49:21.156 --> 04:49:22.697
Don't let that slow you down.

2752
04:49:22.697 --> 04:49:28.006
Feel free to come back to this after you've learned more about how some of these lower level functions work.

2753
04:49:28.006 --> 04:49:49.792
And a little bit more about how gasworks solidity by example, does a fantastic job though of saying what the difference is between all three, our transfer has a maximum of 2300 gas and throws an error if it fails, send has a maximum of 2300 gas returns a Boolean, if it fails, call forwards all gas so doesn't have a capped gas.

2754
04:49:49.792 --> 04:50:16.449
And similar to send returns a Boolean, if it is successful, or if it fails, As of recording right now using call is the recommended way to actually send and receive Aetherium or your blockchain native token for now, if this part's a little bit confusing for you, for now, just look at this and see ah, that's how we send and transfer Aetherium or native blockchain currency tokens.

2755
04:50:16.449 --> 04:50:25.951
And I'm going to delete this part for the video, but I'll keep those comments in the code repository associated with this course.

2756
04:50:25.951 --> 04:50:27.951
And okay, perfect.

2757
04:50:28.174 --> 04:50:33.951
If we hit compile a fun meat outsole, we do indeed see that it's passing compliation.

2758
04:50:33.951 --> 04:50:41.370
However, there's a bit of an issue here, right now, anybody can withdraw from this contract.

2759
04:50:41.370 --> 04:50:44.206
So anybody can fund, which is what we want.

2760
04:50:44.206 --> 04:50:46.766
But we don't want anyone to be able to withdraw.

2761
04:50:46.766 --> 04:50:52.485
We only want the person who's collecting the funds to be able to actually withdraw the funds.

2762
04:50:52.485 --> 04:51:02.404
So how do we set this up so that the withdraw function is only called by the owner of this contract? Well, to do that, we're going to set up a couple new functions.

2763
04:51:02.404 --> 04:51:11.190
So when we deploy this contract, we want to automatically set it up so that whomever deploys this contract is going to be the owner of this contract.

2764
04:51:11.190 --> 04:51:17.518
And then we can do some parameters to set it up so that only the owner of this contract can call the withdrawal function.

2765
04:51:17.518 --> 04:51:24.007
So how would we do that? Well, maybe we can create a function called like, call me right away.

2766
04:51:24.007 --> 04:51:31.974
And right after we deploy this contract, we call this call me right away function, which will set up us as the owner.

2767
04:51:31.974 --> 04:51:34.774
Now that's going to take two transactions.

2768
04:51:34.774 --> 04:51:37.554
And that would be really annoying if we had to do that.

2769
04:51:37.554 --> 04:51:42.622
So instead, solidity has something called a constructor.

2770
04:51:42.622 --> 04:51:50.090
And if you're familiar with other programming language, a constructor is exactly the same as other programming languages.

2771
04:51:50.174 --> 04:51:56.224
constructor is going to be the function that gets called when, immediately whenever or you deploy a contract.

2772
04:51:56.224 --> 04:52:10.550
So if I were to deploy Funmi, dot Sol, and I were to say, minimum USD equals to minimum USD would no longer be 50 times one e to the 18th, it would be immediately updated to two.

2773
04:52:10.550 --> 04:52:26.060
Because constructor is a function that gets immediately called in the same transaction, that we create this contract, this constructor function is going to be incredibly helpful for us, because it allows us to set up the contract the way we want it to be.

2774
04:52:26.060 --> 04:52:37.519
So for example, if we want the withdrawal function to only be able to be called by the owner of this contract, we can have the constructor set up who the owner of the contract is.

2775
04:52:37.519 --> 04:52:42.381
So let's create a global variable called address, public owner.

2776
04:52:42.381 --> 04:52:49.367
And then in our constructor, we'll say the owner is going to be equal to the message dot sender.

2777
04:52:49.367 --> 04:52:56.717
The message that sender of the constructor function is going to be whoever is deploying the contract.

2778
04:52:56.717 --> 04:53:00.667
So owner is now going to be whoever deployed this contract.

2779
04:53:00.667 --> 04:53:12.255
And don't worry, we're going to demo all this very soon and show you everything that's going on with ether scan everything, demoing this all right now might take a little bit of time, because we're using a test net.

2780
04:53:12.255 --> 04:53:20.126
So if you want to test it all right now, absolutely go for it, but just know, it'll take you a little bit longer to do so.

2781
04:53:20.126 --> 04:53:30.094
Now that we have the owner setup, we can modify our withdrawal function to make it so that only the owner can actually call this withdrawal function.

2782
04:53:30.094 --> 04:53:49.241
So at the top of the withdrawal function, maybe we want to add a section, maybe we want to say require message dot sender equals the owner, a note about double equals versus equals, you can think of this single equals as a set parameter.

2783
04:53:49.241 --> 04:53:59.890
So when I say owner, is now set to message dot sender, double equals is how you check to see if these two variables are equivalent.

2784
04:53:59.890 --> 04:54:04.062
So we're saying is message dot sender, the same as owner.

2785
04:54:04.062 --> 04:54:06.961
So this is checking to see equivalence.

2786
04:54:06.961 --> 04:54:10.667
This is setting checking to see equivalence setting.

2787
04:54:10.667 --> 04:54:19.733
So we're gonna say require message dot sender is equal to owner, otherwise, we're gonna throw an error, saying, sender is not owner.

2788
04:54:19.733 --> 04:54:20.388
Perfect.

2789
04:54:20.388 --> 04:54:28.569
Now we have a quick way to make sure the withdrawal function is only called by the owner of this contract.

2790
04:54:28.569 --> 04:54:43.633
Now, let's say that there's a lot of functions that we have in this contract that are going to be required to be the owner, maybe there's a lot of functions in this contract that need a whole lot of different requires, we don't want to have to copy paste this line to every single one of our functions.

2791
04:54:43.633 --> 04:54:47.724
So what can we do? Well, this is where something called modifiers come in.

2792
04:54:47.724 --> 04:54:51.242
So for now, we're gonna go ahead and delete this line.

2793
04:54:51.242 --> 04:55:02.159
And below, we're going to create something called a modifier, our modifier is going to be a key word that we can add right in the function declaration.

2794
04:55:02.159 --> 04:55:08.509
To modify the function with that functionality, we're going to create a modifier and call it only owner.

2795
04:55:08.509 --> 04:55:13.864
And we're going to paste that line that we just made in withdraw.

2796
04:55:13.864 --> 04:55:24.455
And underneath that, we're going to put a little underscore, what I can do now is I can take this only owner modifier, and stick it in the function declaration of my withdrawal function.

2797
04:55:24.455 --> 04:55:46.211
So what's happening with this modifier with only owner in this function declaration, we're saying, hey, for this withdrawal function, before you read all this code inside of it, look down at the only owner modifier and do whatever is in there first, and then do whatever's in the underscore, this underscore represents doing the rest of the code.

2798
04:55:46.211 --> 04:55:55.052
So now, when we go call the withdraw function, we actually do this require statement first, and then call the rest of the code.

2799
04:55:55.052 --> 04:56:03.881
If this require statement, we're below the underscore, this would tell our function to go ahead and do all this code first.

2800
04:56:03.881 --> 04:56:05.520
And then run the require.

2801
04:56:05.520 --> 04:56:13.015
Because again, we have this only only keyword, we're saying, Great, we've got a function, it's withdraw its public, oh, only odor modifier.

2802
04:56:13.015 --> 04:56:14.885
Let's look at how that works.

2803
04:56:14.885 --> 04:56:18.966
Okay, it tells us how to do all the code of the original function first.

2804
04:56:18.966 --> 04:56:20.499
So let's go ahead and do that.

2805
04:56:20.499 --> 04:56:21.566
Okay, now we're done.

2806
04:56:21.566 --> 04:56:27.596
Now, what do we do? Okay, now we'll run the require, we want to go ahead and put the require here first.

2807
04:56:27.596 --> 04:56:34.738
So this is how modifiers work, and how we can use them to improve our functionality.

2808
04:56:34.738 --> 04:56:36.142
All right, awesome.

2809
04:56:36.142 --> 04:56:40.415
We have all the basic functionality of our contract that we need here.

2810
04:56:40.415 --> 04:56:46.792
Now we're finally actually going to run everything on a test and see everything happened live before our eyes.

2811
04:56:46.792 --> 04:56:49.022
Are you ready? Let's do this.

2812
04:56:49.177 --> 04:56:50.849
So let's go over to the deploy tab.

2813
04:56:52.177 --> 04:56:53.808
of course to injected web three.

2814
04:56:55.177 --> 04:57:04.125
injected web three, because our price converter dot soul is using chainlink Oracle's that actually exist and are actually monitoring the Rinkeby network for us.

2815
04:57:04.125 --> 04:57:09.112
Now we're going to scroll down to, and we're going to choose the Funmi contract.

2816
04:57:09.178 --> 04:57:11.016
And we're going to go ahead and deploy.

2817
04:57:12.178 --> 04:57:14.735
make sure we're on the Rinkeby test net.

2818
04:57:16.178 --> 04:57:20.629
bit of rinky eath in our wallet, let's go ahead and deploy, confirm.

2819
04:57:20.629 --> 04:57:22.435
And we'll wait a little bit.

2820
04:57:22.435 --> 04:57:24.458
And I'll pull up our log here.

2821
04:57:24.458 --> 04:57:28.606
And we'll wait a little bit for our contract to get deployed.

2822
04:57:28.606 --> 04:57:29.409
Alright, great.

2823
04:57:29.409 --> 04:57:32.557
It looks like our contract has indeed been deployed.

2824
04:57:32.557 --> 04:57:39.754
If we scroll down, we can see all of our functionality, minimum USD is going to be that $50.

2825
04:57:39.754 --> 04:57:54.817
But with 18 zeros so that the units are the same as Aetherium, the owner of our contract was set to our address, the instant we deployed this contract, it was deployed by calling our constructor function.

2826
04:57:54.817 --> 04:58:10.716
So this address 0x 106 x is going to be the same as the address in our meta mask, your address here, of course, is going to be a little bit different than mine, we have our funders array, which, of course is going to be blank, we have our address array, which is also going to be blank.

2827
04:58:10.716 --> 04:58:34.278
And then we have two functions that we can use to modify the state of the blockchain withdraw is going to be orange, because we're not paying any Aetherium we're actually gaining Aetherium or whatever native blockchain currency fund is going to be read, because fun is a payable function that we are going to be sending Aetherium to or sending whatever native blockchain currency that you're working with.

2828
04:58:34.278 --> 04:58:36.419
So let's go ahead and see how this all works.

2829
04:58:36.419 --> 04:58:39.712
So first, let's go ahead and fund this contract.

2830
04:58:39.712 --> 04:58:46.469
Again, funding, we got to do a little bit of math, right now, since the price of eath is around $3,000.

2831
04:58:46.469 --> 04:58:48.654
And we're looking for $50.

2832
04:58:48.654 --> 04:58:51.998
Minimum, we do 50 divided by 3000.

2833
04:58:51.998 --> 04:58:56.871
We can do 3000 divided by 50, we can do 50 divided by 3000.

2834
04:58:56.871 --> 04:58:58.979
So we know that around 0.

2835
04:58:58.979 --> 04:59:04.721
02 Aetherium, should be enough for this contract to work.

2836
04:59:04.721 --> 04:59:05.398
So 0.

2837
04:59:05.398 --> 04:59:13.490
02 Aetherium is this much way, we can copy that, paste that into here.

2838
04:59:13.490 --> 04:59:16.429
So when we hit fund, it should actually pass.

2839
04:59:16.429 --> 04:59:18.866
And we do indeed see meta masks pop up.

2840
04:59:18.866 --> 04:59:20.790
And we'll go ahead and confirm.

2841
04:59:20.790 --> 04:59:28.100
Once this transaction goes through, we'll be able to see this contract on ether scan with the funds in it.

2842
04:59:28.179 --> 04:59:36.738
Now if we don't add way here, if we don't add a value, once again, we had fund will say gas estimation failed because we're not sending enough here.

2843
04:59:36.738 --> 04:59:44.655
And in fact, we even see execution reverted didn't send enough, we can absolutely send this transaction however, it's going to fail.

2844
04:59:44.655 --> 04:59:45.035
Great.

2845
04:59:45.035 --> 05:00:03.369
So now that our transaction has gone through, if we go on to the rink the ether scan, once we wait a little bit for it to finish indexing here on the Rinkeby ether scan, we can see that transaction actually went through for doing the funding, we can actually see a lot of different details going on with this transaction as well.

2846
05:00:03.369 --> 05:00:20.645
And if we scroll down, we once again, you can see all the information about us calling this fun function, gas limit gas, you should the gas fees, gas price, and we can see the input data as well, we can see that we called the fund function down here.

2847
05:00:20.645 --> 05:00:22.920
We'll learn more about the input data later.

2848
05:00:22.920 --> 05:00:32.093
If we go to the contract that we deployed, we can now see two transactions, we can see our contract created transaction.

2849
05:00:32.180 --> 05:00:34.954
And we can also see we called a font method.

2850
05:00:36.180 --> 05:00:38.805
the balance of our contract, and now has 0.

2851
05:00:40.180 --> 05:00:43.230
sense, since we just sent it 0.

2852
05:00:43.230 --> 05:00:43.433
02.

2853
05:00:43.433 --> 05:00:45.161
If we put that 0.

2854
05:00:46.180 --> 05:00:58.930
in terms of way back into the value section, and we call font again, after this transaction goes through, we should see this number go from 0.

2855
05:00:58.930 --> 05:00:59.695
02 to 0.

2856
05:00:59.695 --> 05:00:59.913
04.

2857
05:00:59.913 --> 05:01:07.998
Now after we wait a brief delay, we do indeed see the balance has gone up to 0.

2858
05:01:07.998 --> 05:01:10.649
04, which is exactly what we'd expect.

2859
05:01:10.649 --> 05:01:11.138
Awesome.

2860
05:01:11.138 --> 05:01:14.248
So our funding mechanism is working correctly.

2861
05:01:14.248 --> 05:01:26.656
And if we go down into our array, and our mapping to do address to array, and we paste our address, we should see the phone number show up.

2862
05:01:26.656 --> 05:01:29.913
And if we go to funders of zero, we see our address.

2863
05:01:29.913 --> 05:01:51.443
And if we go to funders of one, we also see our address and we see that and we see this call going through if we go to funders have to in our log over here, we actually see that we get an error an optimization that we could make to our contract in the future is to check to see if an address is already in the funders array and then not add it if it's already there.

2864
05:01:51.443 --> 05:01:54.680
Now let's go ahead and try to call this withdrawal function.

2865
05:01:54.680 --> 05:02:00.040
But let's try to call it with a different address than the address we originally deployed this contract with.

2866
05:02:00.040 --> 05:02:04.466
So to do that, scroll all the way to the top of this here.

2867
05:02:04.466 --> 05:02:07.657
And I'm going to go to my Metamask.

2868
05:02:07.657 --> 05:02:13.130
And I'm going to switch to a second account and hit connect.

2869
05:02:13.130 --> 05:02:32.388
Now, our remixes should be updated with the new account that's in here, you'll see that if I switch back to account one, it switches back to account one, so long as they're both connected, you can see which accounts are connected to applications by clicking this connected button and see which ones are connected.

2870
05:02:32.388 --> 05:02:37.768
If you ever want to disconnect that account, you can click the three little dots and it disconnect the account.

2871
05:02:37.768 --> 05:02:41.431
And now we can see that this account is not connected.

2872
05:02:41.431 --> 05:02:43.931
However, count two is connected.

2873
05:02:43.931 --> 05:02:50.373
Let's go back to account one and Connect account one so that both of them are now connected.

2874
05:02:50.373 --> 05:02:59.045
But we'll switch to account two, let's switch to account two, because again, account two isn't the owner of this contract.

2875
05:02:59.045 --> 05:03:07.602
We scroll down to owner, we can see owner's 0x 1066 Something something and account two is 0x 043.

2876
05:03:07.602 --> 05:03:09.566
Something something awesome.

2877
05:03:09.566 --> 05:03:16.536
So what do you think will happen when we hit withdraw here? Well, our modifier only owner should kick in.

2878
05:03:16.536 --> 05:03:23.117
And we should get notified that if we send the transaction, we'll get this error sender is not owner.

2879
05:03:23.181 --> 05:03:24.334
So let's try it.

2880
05:03:27.181 --> 05:03:27.870
this error.

2881
05:03:27.870 --> 05:03:30.490
Sender is not owner, which is perfect.

2882
05:03:31.181 --> 05:03:34.906
exactly what we want, we could absolutely send this transaction if we wanted to.

2883
05:03:34.906 --> 05:03:39.886
But that would just be a waste of gas because this transaction is going to fail.

2884
05:03:39.886 --> 05:03:54.248
However, if we switch back to account one, and we hit withdraw, meta mask will pop up, enabling us to confirm and withdraw the ether out of this contract address.

2885
05:03:54.248 --> 05:04:01.283
Now if we look at this contract address on ether scan, after a brief delay, we'll see the balance go from 0.

2886
05:04:01.283 --> 05:04:03.316
04 back down to zero.

2887
05:04:03.316 --> 05:04:09.018
And we'll see our wallet balance go up from what it is back to 0.

2888
05:04:09.018 --> 05:04:10.263
04 plus what it was.

2889
05:04:10.263 --> 05:04:16.821
And after a brief delay, you can see our balance is indeed back down to zero in our contract.

2890
05:04:16.821 --> 05:04:22.515
Now, if we do address to amount for our wallet address that was doing the funding, it's back down to zero.

2891
05:04:22.515 --> 05:04:39.070
And if we try to check the address of funders at index zero, we get called to funders that fund me errored execution reverted.

2892
05:04:40.182 --> 05:04:43.665
We've completed all the basics of this section that I wanted to go through.

2893
05:04:43.665 --> 05:05:00.165
And you should be incredibly proud of yourself for getting this far, you've just deployed a really advanced smart contract, we're using a library and chainlink contracts to build some of the most powerful applications in the planet, we've learned to use a library for any type we want in our smart contracts.

2894
05:05:00.165 --> 05:05:06.126
We've learned more about multiplication, and then units of measure in solidity and smart contracts.

2895
05:05:06.182 --> 05:05:17.603
We've learned about mappings more about arrays what the constructor does, we've learned how to send money we've learned about for loops, we've learned about the different ways we can actually send money, at least from a low level.

2896
05:05:17.603 --> 05:05:18.962
And we've learned about modifiers.

2897
05:05:18.962 --> 05:05:21.314
This section is one of the tougher sections in this course.

2898
05:05:21.314 --> 05:05:24.288
So if you completed this, you should be incredibly excited.

2899
05:05:24.288 --> 05:05:26.340
We're going to go through our code now.

2900
05:05:26.340 --> 05:05:28.603
And we're going to make a number of tweaks.

2901
05:05:28.603 --> 05:05:33.021
Now this section, we are going to do a little bit more advanced solidity here.

2902
05:05:33.021 --> 05:05:36.563
So if you get a little bit lost, don't sweat it too much.

2903
05:05:36.563 --> 05:05:40.115
And feel free to try some of this stuff in the future on your own.

2904
05:05:40.115 --> 05:05:45.611
We're going to modify this contract to make it a little bit more professional.

2905
05:05:45.611 --> 05:05:48.789
It's not going to be end to end amazing, but it's going to be a little bit better.

2906
05:05:48.789 --> 05:05:49.827
And you'll see why in a minute.

2907
05:05:49.827 --> 05:05:54.389
So the first thing that we're going to do is we're looking we're going to look at some of these variables here.

2908
05:05:54.389 --> 05:06:00.849
In particular owner and minimum USD, owner gets set one time in our contract here.

2909
05:06:00.849 --> 05:06:02.860
And then it never changes.

2910
05:06:02.860 --> 05:06:09.199
Again, minimum USD gets set one time, even outside of the constructor.

2911
05:06:09.199 --> 05:06:17.241
If we have variables that only get set one time, we can actually use some tools in solidity to make them more gas efficient.

2912
05:06:17.241 --> 05:06:22.133
For now let's compile our Funmi contract, and then deploy it to a JavaScript virtual machine.

2913
05:06:22.183 --> 05:06:25.505
Remember, we can go ahead and deploy it right now.

2914
05:06:26.183 --> 05:06:29.792
funding and withdrawing and doing in the money stuff isn't going to work.

2915
05:06:29.792 --> 05:06:34.183
Because again, we don't have a chain link network on our JavaScript VM.

2916
05:06:34.183 --> 05:06:36.083
So those aren't going to work so well.

2917
05:06:36.183 --> 05:06:38.649
But for what we're gonna do right now, we don't really care so much.

2918
05:06:38.649 --> 05:06:40.582
Here's what we do care about.

2919
05:06:40.582 --> 05:06:44.468
You do care about how much gas this costs to actually send.

2920
05:06:44.468 --> 05:06:56.083
We do care about how much gas is costs to create right now creating this contract costs about 859,000 gas and we're going to Add a couple of tricks.

2921
05:06:56.183 --> 05:07:01.748
Right now to bring this number down, we're going to add some stuff back in in the bid, which will bring it back up.

2922
05:07:01.748 --> 05:07:04.374
But for now, we're going to learn some tricks to bring this number down.

2923
05:07:04.374 --> 05:07:10.127
The two tricks that we're going to learn are the constant keyword and the immutable keyword, in their solidity.

2924
05:07:10.184 --> 05:07:14.829
There are two keywords that make it so that your variables can't be changed.

2925
05:07:14.829 --> 05:07:17.796
And those keywords are constant and immutable.

2926
05:07:17.796 --> 05:07:31.238
You can learn more about them in the solidity documentation, if you assign a variable once outside of a function, and then never change it, so if if it's assigned at compile time, you can go ahead and add this constant keyword.

2927
05:07:31.238 --> 05:07:33.103
We'll learn later about storage.

2928
05:07:33.103 --> 05:07:40.724
But when you add a constant keyword, this minimum USD no longer takes up a storage spot, and is much easier to read too.

2929
05:07:40.724 --> 05:07:43.911
So now we recompile this, and we deploy this new contract.

2930
05:07:43.911 --> 05:07:46.638
Let's see if we saved any gas.

2931
05:07:46.638 --> 05:07:55.701
We look in the transaction logs, now, we can grab the transaction cost of how much this cost to deploy, let's compare it to how much it was before.

2932
05:07:55.701 --> 05:08:02.078
Well, we saved almost 19,000 gas, that's almost as much gas as a cost to send Aetherium.

2933
05:08:02.078 --> 05:08:05.541
Typically, constant variables have a different naming convention.

2934
05:08:05.541 --> 05:08:09.834
Typically, you'll want to do them all caps like Min imaam.

2935
05:08:09.834 --> 05:08:13.802
Underscore, who is the CIO all caps with underscores.

2936
05:08:13.802 --> 05:08:17.902
So now let's just find minimum use D, and replace that with all caps as well.

2937
05:08:17.902 --> 05:08:27.684
With this interaction, we know that this variable is a constant variable, and it's much cheaper to read from now, if we go ahead and compile this and redeploy.

2938
05:08:27.684 --> 05:08:43.791
In our Funmi contract, even though this is a view function, remember, view functions do have gas costs when when called by contract as a constant variable, we can see the execution cost of this variable 21,415 gas.

2939
05:08:43.791 --> 05:08:47.106
So let's put a little note rather Nathan.

2940
05:08:47.185 --> 05:08:50.971
If we remove the constant variable, we delete this contract.

2941
05:08:50.971 --> 05:08:53.725
And we redeploy, like Funmi.

2942
05:08:53.725 --> 05:08:58.507
And we hit minimum ust again, we can now see how much gas this was cost.

2943
05:08:58.507 --> 05:09:03.136
If it wasn't a constant variable, we can see the gas cost did indeed go up.

2944
05:09:03.185 --> 05:09:07.736
Now on chains that are much cheaper, this gas difference probably won't make that much of a difference.

2945
05:09:07.736 --> 05:09:11.874
But on more expensive chains like Aetherium, this is going to make a big difference.

2946
05:09:11.874 --> 05:09:17.092
For example, on Aetherium, we can actually see current gas prices on Aetherium.

2947
05:09:17.092 --> 05:09:39.768
Here, we can see the current gas price of Aetherium is about 141 way, so we'll go to our converter, way to way we'll copy the way price times this will get the gas price of calling our minimum USD, which is this number here, which if we put back in our Aetherium uniconverter, we can see cost this much gas.

2948
05:09:39.768 --> 05:09:46.023
And if we times that by the approximate current price of Aetherium, which is around $3,000.

2949
05:09:46.023 --> 05:10:01.495
Calling minimum use D as a constant is going to cost $9 on the inside is at a nonconstant is going to cost almost an entire dollar more, you can see how all these little gas optimization tricks are going to make your life a lot better.

2950
05:10:01.495 --> 05:10:03.770
So let's keep this constant keyword in here.

2951
05:10:03.770 --> 05:10:07.753
We'll learn more about constant and storage in later sections of this course.

2952
05:10:07.753 --> 05:10:13.338
Now, as you're just getting started with this course, and with slip the Do not struggle.

2953
05:10:13.338 --> 05:10:20.879
And do not worry about making your contracts as gas efficient as possible in the beginning, and especially right now.

2954
05:10:20.879 --> 05:10:23.293
Just write your contracts as best as you can.

2955
05:10:23.293 --> 05:10:25.262
Once you get really good at gas.

2956
05:10:25.262 --> 05:10:34.024
And once you get much later on in the course, and much more advanced with solidity, then you can start going back and working on gas optimizations.

2957
05:10:34.024 --> 05:10:37.056
But do not let gas optimizations hold you back.

2958
05:10:37.186 --> 05:10:40.347
Or if you start stressing over it, just let it go.

2959
05:10:41.186 --> 05:10:43.720
about it and just write your code as best you can.

2960
05:10:44.186 --> 05:10:47.878
story short, Do not stress about gas optimizations right now.

2961
05:10:48.186 --> 05:10:51.820
another variable we only set one time is going to be our owner variable.

2962
05:10:51.820 --> 05:10:54.359
Owner equals message dot sender.

2963
05:10:54.359 --> 05:11:01.474
We set this one time in the constructor variables that we set one time but outside of the same line that they're declared.

2964
05:11:01.474 --> 05:11:17.028
And we set them for example, in the constructor, we can mark as a mutable typically a good convention for marking immutable variables is going to be doing I underscore so that we know that these are immutable variables, they have very similar gas savings to the constant keyword.

2965
05:11:17.028 --> 05:11:25.186
Owner, of course, is a variable that we can't set on the line here because inside the global scope, there's no function going on.

2966
05:11:25.186 --> 05:11:33.979
However, inside functions, because inside the global scope, there's going to be no message that sender, there's only going to be a message dot sender when we're inside of a function.

2967
05:11:33.979 --> 05:11:37.616
So inside here, we might say I owner equals message dot sender.

2968
05:11:37.616 --> 05:11:44.686
And then of course, we'll scroll down and we'll change this require only owner now equals i owner.

2969
05:11:44.686 --> 05:11:59.907
Now if we compile that deploy up, we can see how much gas we can see how much gas calling I owner is going to be by with immutable notice, we get 21,508, which we'll go ahead and copy for now.

2970
05:11:59.907 --> 05:12:03.044
And we'll put right here, we'll say, immutable.

2971
05:12:03.044 --> 05:12:09.218
Now, if we remove the immutable keyword, let's close this redeploy.

2972
05:12:09.218 --> 05:12:18.631
If we scroll down to I owner, screw up the logs, we go down to the call, scroll down, we see the execution cost was much more.

2973
05:12:18.631 --> 05:12:25.083
So we'll do the backslash, a seven here, yes, or non immutable.

2974
05:12:25.083 --> 05:12:30.726
So you want to keep some of these tricks in mind, when it comes to storing variables.

2975
05:12:30.726 --> 05:12:40.344
The reason that these two save gas is because instead of storing these variables inside of a storage slot, we actually store them directly into the bytecode of the contract.

2976
05:12:40.344 --> 05:12:49.237
And like I said, don't worry too much about that for now, later on in the course, we'll teach you more about storage and a lot of this low level stuff that comes to these contracts.

2977
05:12:49.237 --> 05:12:51.742
But for now, just know that these exist.

2978
05:12:51.742 --> 05:12:57.669
And they're nice gas savers, if you're only setting your variables once.

2979
05:12:57.669 --> 05:12:59.008
Alright, great.

2980
05:12:59.187 --> 05:13:06.219
So we've just made our contract a little bit more gas efficient, little gas efficiency improvements are going to be concept I sprinkled throughout this course.

2981
05:13:06.219 --> 05:13:16.237
And when we get to the more advanced section, I'm going to break down exactly what's going on and why all these gas efficiencies exist and what's going on behind the scenes for these gas efficiencies to occur.

2982
05:13:16.237 --> 05:13:20.141
It's a little bit in the weeds, which is why I'm going to gloss over it right now.

2983
05:13:20.187 --> 05:13:25.387
So if it's confusing, don't worry, I wouldn't let these gas efficiencies be the thing that slow you down.

2984
05:13:25.387 --> 05:13:25.787
Awesome.

2985
05:13:25.787 --> 05:13:53.394
So we have these two gas optimizations? How else can we make this contract a little bit more gas efficient? Well, one of the ways we can make this more gas efficient, is by updating our requires right now with our require statement, we actually have to store this sender is not an owner as a string array, every single one of these characters in this errorlog needs to get stored individually, this string may not seem very big, but it's a lot bigger than the alternative with what we can do.

2986
05:13:53.394 --> 05:13:54.663
As of zero, point 8.

2987
05:13:54.663 --> 05:13:58.489
4 of solidity, you can now actually do custom errors.

2988
05:13:58.489 --> 05:14:06.774
For our reverts, we declare them at the top and then use ifs, instead of require and then just add a revert statements.

2989
05:14:06.774 --> 05:14:15.323
This ends up saving a lot of gas, since we just call the error code, as opposed to calling the entire string associated with the air.

2990
05:14:15.323 --> 05:14:25.568
So for example, with our require down here, and with actually with all of our requires, well we could do is instead of having this require we could create a custom error.

2991
05:14:25.568 --> 05:14:32.188
So at the top, what we could do is we could say error, not owner.

2992
05:14:32.188 --> 05:14:38.091
And you'll notice that this is actually outside of the contract here.

2993
05:14:38.091 --> 05:15:00.067
Now what we can do is we can take this error not owner scroll down into our only owner, instead of doing a require we'll do an if statement, we'll say if message dot sender is not owner, then we're going to go ahead and revert with a non owner error.

2994
05:15:00.188 --> 05:15:05.670
This ends up saving us a lot of gas, since we don't have to store and emit this long string here.

2995
05:15:05.670 --> 05:15:12.413
Now in a lot of code today, you'll still see require a lot of places because these these custom errors are pretty new in solidity.

2996
05:15:12.413 --> 05:15:14.854
So you'll want to get used to writing in both ways.

2997
05:15:14.854 --> 05:15:20.619
I wouldn't be surprised if in the future, the syntax for some of these errors looks like this so that it's more readable.

2998
05:15:20.619 --> 05:15:28.654
But for now, if you want to do a more gas efficient way than required, you can use something like this, we could update all of our requires here for these customers.

2999
05:15:28.654 --> 05:15:32.389
But for now, I'm going to leave both in just to show you the differences.

3000
05:15:32.389 --> 05:15:37.734
This revert keyword does the exact same thing that required us without the conditional beforehand.

3001
05:15:37.734 --> 05:15:43.576
So you can actually go ahead and revert any transaction or any function call in the middle of the function call.

3002
05:15:43.576 --> 05:15:48.995
Now let's look at one more way to improve this contract.

3003
05:15:49.189 --> 05:15:58.141
Sometimes people will try to interact with the contract that takes Aetherium or the native blockchain token without actually going through the required function calls that that are needed.

3004
05:15:58.141 --> 05:16:05.322
For example, on a JavaScript EVM here, I could actually try to send this contract money without calling the fund function.

3005
05:16:05.322 --> 05:16:17.564
However, if I were to do that, what would happen with our fund function get triggered? No, it wouldn't get triggered, we wouldn't keep track of that funder, we wouldn't have that person's information updated in this contract.

3006
05:16:17.564 --> 05:16:21.989
So if later on we want to give rewards or something we wouldn't know about those funders.

3007
05:16:21.989 --> 05:16:28.722
And this wouldn't be great because people would send our contract money without us ever knowing and we wouldn't be able to give them any credit or anything.

3008
05:16:28.722 --> 05:16:34.680
Additionally, maybe they called the wrong function by accident, and they they weren't using Metamask.

3009
05:16:34.680 --> 05:16:39.223
And they weren't using a tool to tell them, hey, this transaction is likely going to fail.

3010
05:16:39.223 --> 05:16:57.911
So what can we do in this case? What happens if someone sends this contract, ether without calling the fun function? Right now, if we were to send this Funmi contract, ie it would just go to the contract Right, and this contract just wouldn't keep track of those people.

3011
05:16:57.911 --> 05:17:05.640
But there's actually a way for when people send money to this contract, or people call a function that doesn't exist for us to still trigger some code.

3012
05:17:05.640 --> 05:17:13.500
And now there are two special functions in solidity one is called receive, and one is called the fallback.

3013
05:17:13.500 --> 05:17:21.750
Now in solidity, there are actually a number of special functions and two of these special functions are the receive special function.

3014
05:17:21.750 --> 05:17:29.134
And the fallback special function, a contract can have at most one receive function declared using the received external payable.

3015
05:17:29.190 --> 05:17:30.717
Without the function keyword.

3016
05:17:32.190 --> 05:17:37.086
arguments cannot return anything and must have external visibility, and a payable state mutability.

3017
05:17:37.086 --> 05:17:43.534
What does that actually mean? And or look like? Well, let's create a separate contract to go ahead and play with this.

3018
05:17:43.534 --> 05:17:48.461
So in here, we're going to create a new file called fallback example, dot soul.

3019
05:17:48.461 --> 05:17:59.271
And in here, we're going to add our basic pieces, SPX license identifier, MIT pragma, solidity zero, point 8.

3020
05:17:59.271 --> 05:17:59.402
7.

3021
05:17:59.402 --> 05:18:17.577
And we'll do contract fallback example, like so, feel free to pause the video to catch up to this point, let's recreate our fallback contract, let's create a variable to go ahead and try to test this function, we'll create a un 256 public result variable.

3022
05:18:17.577 --> 05:18:19.464
And let's create this receive function.

3023
05:18:19.464 --> 05:18:25.081
So we'll say receive, it's going to be an external payable.

3024
05:18:25.190 --> 05:18:38.611
function, we don't add the function keyword for receive, since solidity knows that receive is a special function whenever we send Aetherium or make a transaction to this contract.

3025
05:18:38.611 --> 05:18:45.123
Now, as long as there's no data associated with that transaction, this receive function will get triggered.

3026
05:18:45.191 --> 05:18:49.868
What we can do in here now is we can say result equals one.

3027
05:18:50.191 --> 05:18:56.444
let's go ahead and test this out on the JavaScript virtual machine, we compile this, so we're gonna go ahead and compile this.

3028
05:18:56.444 --> 05:19:02.591
And we'll go deploy it on the Java Virtual Machine, we're going to deploy our fallback example.

3029
05:19:02.591 --> 05:19:11.159
And we're going to see what result is initialized to, since we haven't set anything for result, result, of course, is initialized zero.

3030
05:19:11.159 --> 05:19:22.771
But what if we were to send this contract some Aetherium? Well receive would go ahead and be triggered here, we can actually send this contract some material directly by working with this low level interactions.

3031
05:19:22.771 --> 05:19:31.005
But here, don't worry about what call data means for now, just know that this area down here is a way we can send and work with different functions.

3032
05:19:31.005 --> 05:19:36.568
And we can add parameters to this transaction, by going up here and adjusting the variables up here.

3033
05:19:36.568 --> 05:19:40.980
If we keep called Data blank, it'll be the same as if we were in Metamask.

3034
05:19:40.980 --> 05:19:44.246
And just hitting send in the choosing this contract address.

3035
05:19:44.246 --> 05:19:50.541
Again, we can't actually use Metamask, since this is a virtual machine, and not one of the networks that we're working with.

3036
05:19:50.541 --> 05:19:56.175
So if I do, for example, I change this value to one way, and I keep everything blank.

3037
05:19:56.175 --> 05:20:03.905
And I go ahead and hit this transaction button, which again, is going to be the same as hitting this Send button, but only sending one way.

3038
05:20:03.905 --> 05:20:07.287
What do you think will happen? Well, let's try it.

3039
05:20:07.287 --> 05:20:12.379
We can see in the log area that we did indeed send a transaction.

3040
05:20:12.379 --> 05:20:26.128
And if you look at the description here, you can even see it says from so and so to fall back example, dot receive, it looks like it called our received function, which should have updated our result to one.

3041
05:20:26.192 --> 05:20:31.542
So if we hit result, now we can indeed see that result has been updated to the value of one.

3042
05:20:31.542 --> 05:20:33.499
Well, let's go ahead and delete this.

3043
05:20:33.499 --> 05:20:36.037
Let's deploy this contract again.

3044
05:20:36.037 --> 05:20:41.925
And this time, let's have this value be zero, does receive get triggered this time.

3045
05:20:41.925 --> 05:20:43.159
So let's pull this down.

3046
05:20:43.159 --> 05:20:44.078
Let's hit transact.

3047
05:20:44.078 --> 05:20:48.128
Let's leave the call data blank, we'll leave value at zero.

3048
05:20:48.128 --> 05:20:54.275
So this will be the same as if we had sent zero Aetherium to this contract.

3049
05:20:54.275 --> 05:20:55.628
Let's hit transact.

3050
05:20:55.628 --> 05:21:09.699
It looks like that went through, do you think result is going to be one or zero? You thought one you were correct or receive function gets triggered anytime we send a transaction to this contract now, and we don't specify a function.

3051
05:21:09.699 --> 05:21:14.463
And we keep the call data blank when working with any other contract like Funmi.

3052
05:21:14.463 --> 05:21:22.730
For example, when we call one of these functions, we're actually just populating this call data bit with certain data that points to one of these functions up here.

3053
05:21:22.730 --> 05:21:28.642
If we send a transaction and we add data to it, we could actually call one of these functions.

3054
05:21:28.642 --> 05:21:29.869
Now let's try this again.

3055
05:21:29.869 --> 05:21:39.345
Let's delete the contract again we'll redeploy open this up result is currently zero receive like I said only is triggered if our call data to it is blank.

3056
05:21:39.345 --> 05:21:50.588
Now this time if I had some call data to this transaction, do you think receive will be triggered this time? If we hit transact and remix we actually get a pop up saying fallback function is not defined.

3057
05:21:50.588 --> 05:22:00.744
This is because whenever data is sent with a transaction solidity says, Oh, well, since you're sending data you're not looking for receive, you're looking for some function.

3058
05:22:00.744 --> 05:22:03.571
So let me look for that function for you.

3059
05:22:03.571 --> 05:22:07.243
Hmm, I don't see any function that matches the 0x 00.

3060
05:22:07.243 --> 05:22:09.982
So I'm going to look for your fallback function.

3061
05:22:09.982 --> 05:22:13.572
Remix is smart enough to know that we don't have a fallback function.

3062
05:22:13.572 --> 05:22:17.143
The second special function in solidity is called the fallback function.

3063
05:22:17.193 --> 05:22:24.761
This is very similar to the receive function, except for the fact that can work even when data is sent along with transaction.

3064
05:22:24.761 --> 05:22:31.553
So our fallback will look something like this callback, external payable.

3065
05:22:31.553 --> 05:22:48.783
result equals to Fallback is another one of these functions where we're not going to put the function selector because solidity is expecting this, actually, you're already familiar with one other special function, we go back to our Funmi.

3066
05:22:48.783 --> 05:22:53.242
Our constructor, for example, is a another type of special function.

3067
05:22:53.242 --> 05:22:55.078
There's no function keyword.

3068
05:22:55.078 --> 05:22:59.548
solidity knows that this constructor is immediately called when we deploy this contract.

3069
05:22:59.548 --> 05:23:02.056
So now we have our fallback function.

3070
05:23:02.193 --> 05:23:04.161
Let's go ahead and compile this.

3071
05:23:06.193 --> 05:23:09.660
Let's go ahead and deploy this new contract.

3072
05:23:11.193 --> 05:23:13.923
result, we do indeed, see, it's set to zero.

3073
05:23:15.193 --> 05:23:24.668
0x 00, and I send this, and I hit transact, this is equivalent to calling our contract here without a valid function.

3074
05:23:24.668 --> 05:23:29.630
So our contract goes, Huh, I don't recognize what you're trying to tell me here, I'm going to refer you to our fallback.

3075
05:23:29.630 --> 05:23:33.431
And now if we hit result, we see that it's been updated to two.

3076
05:23:33.431 --> 05:23:41.144
If we take this away, solidity will go, Hmm, it looks like you're trying to send some Aetherium, or call this contract without specifying what you want to do.

3077
05:23:41.144 --> 05:23:42.744
Well, I have a receipt function.

3078
05:23:42.744 --> 05:23:45.418
So I'm just gonna go ahead and forward you to that.

3079
05:23:45.418 --> 05:24:05.732
So if we call transact, we hit result, we see it updates back to one, add some data, hit transact, we see it updates to to no data, updates to one slowly by example, that org has a wonderful little chart that we can use to figure out whether or not receive is going to get triggered, or Fallback is going to get triggered.

3080
05:24:05.732 --> 05:24:09.755
If it is empty, and there's a receive function, it'll call the receive function.

3081
05:24:09.755 --> 05:24:15.194
If it is data, and there's no receive function, it'll just go to the fallback function.

3082
05:24:15.194 --> 05:24:18.527
And if there's no fallback function, it might just it might air out.

3083
05:24:18.527 --> 05:24:21.501
So this is a lot of really fantastic information here.

3084
05:24:21.501 --> 05:24:35.780
How can we apply this to our fund mi contract here, or what we can do now in our Funmi is we can add these fallback and receive functions, just in case somebody actually sends us contract money instead of calling the fund function correctly.

3085
05:24:35.780 --> 05:24:39.008
So what we can do is let's add a receive function.

3086
05:24:39.008 --> 05:24:48.095
So if somebody accidentally sends it money, we can still process the transaction will say receive is going to be external payable.

3087
05:24:48.194 --> 05:24:51.319
And we'll just have the receive function call fund.

3088
05:24:52.194 --> 05:24:59.030
the same thing with our fallback function will have fallback external payable.

3089
05:24:59.030 --> 05:25:03.964
We'll just have it automatically call fund.

3090
05:25:04.194 --> 05:25:13.240
Now, if somebody accidentally sends us money without calling our fund function, it'll still automatically route them over to the fund function.

3091
05:25:13.240 --> 05:25:19.581
This means to that if somebody doesn't send us enough funding, it'll, that transaction will still get reverted.

3092
05:25:19.581 --> 05:25:20.645
So let's go ahead now.

3093
05:25:20.645 --> 05:25:26.127
And let's switch to rink B to test this on a real test net, Amman rink B and my Metamask.

3094
05:25:26.195 --> 05:25:29.340
Let's switch over to injected web three.

3095
05:25:31.195 --> 05:25:32.695
we'll choose our Funmi contract.

3096
05:25:34.195 --> 05:25:38.928
this Metamask pops up, I'm gonna go ahead and confirm the transaction.

3097
05:25:38.928 --> 05:25:45.391
And we see our Funmi contract here right now we can see the owner we can see I'm the owner, we can see minimum USD.

3098
05:25:45.391 --> 05:25:50.623
And we can see of course that it's a blank contract, and there's nothing funded in here.

3099
05:25:50.623 --> 05:25:59.776
If we the copy the address, and then go to rink the ether scan, paste the address in, we can see that there's no ether in here.

3100
05:25:59.776 --> 05:26:02.923
And the only transaction associated with this has been the contract creation.

3101
05:26:02.923 --> 05:26:11.719
We saw what happened before when we hit the fun function, our contract was updated with a new balance, and that funder was added to our an array.

3102
05:26:11.719 --> 05:26:19.127
Let's see what happens now if we just directly send this contract money without calling the fund function here.

3103
05:26:19.195 --> 05:26:26.555
If we did this right, our receive function should pick it up and kick the transaction over the font.

3104
05:26:26.555 --> 05:26:28.768
So let's copy this address.

3105
05:26:28.768 --> 05:26:30.899
We'll go to our meta mask.

3106
05:26:30.899 --> 05:26:34.998
We'll hit send, paste the address in here with 0.

3107
05:26:34.998 --> 05:26:35.571
02 eath.

3108
05:26:35.571 --> 05:26:42.445
Again, because this should be more than the minimum amount in USD, we'll hit next.

3109
05:26:42.445 --> 05:26:44.661
I'll go ahead and confirm this.

3110
05:26:44.661 --> 05:27:01.283
After a slight delay, if we did this right, we should see the transaction having called the fund function here, now that our transaction has gone through After a brief delay in waiting for ethers can update, we do indeed see that our balance has updated to 0.

3111
05:27:01.283 --> 05:27:03.769
02, which of course, this makes sense.

3112
05:27:03.769 --> 05:27:11.179
And we see in the transactions list here, we see that this actually went through as a, as a transfer instead of us calling the fund function.

3113
05:27:11.179 --> 05:27:16.098
Let's go ahead and remix and see if our funders was updated.

3114
05:27:16.196 --> 05:27:20.996
It looks like it was at the zero with position of funders, we have our address.

3115
05:27:20.996 --> 05:27:27.481
And if we take our address and pop it into address to amount funded, we can see exactly how much we had funded.

3116
05:27:27.481 --> 05:27:34.129
This means that since we added this receive function in here, we automatically had to call our fun function up here.

3117
05:27:34.196 --> 05:27:45.862
So awesome work, we were able to add a receive function to help people who accidentally call the wrong function or accidentally send this contract money, instead of correctly calling the fun function.

3118
05:27:45.862 --> 05:27:59.114
Now, if they had directly called the fun function, it would have cost them a little bit less gas, but at least this time, they're gonna get credit and add it to our funders array for having sent our funding contract money.

3119
05:27:59.196 --> 05:28:02.561
We've even learned some advanced sections of solidity.

3120
05:28:03.196 --> 05:28:13.147
is going to be the last time that we start our projects in remix, we're going to be moving over to a code editor now, where we can get even more advanced with our solidity on our setups.

3121
05:28:13.196 --> 05:28:19.851
For the most part, you've gone over the vast majority of solidity basics, there are a number of things that we still haven't learned yet.

3122
05:28:19.851 --> 05:28:23.064
And the reason we haven't gotten into them is because they get more advanced.

3123
05:28:23.064 --> 05:28:27.434
And understanding the real use doesn't really make too much sense until a little bit later.

3124
05:28:27.434 --> 05:28:36.609
Some of the things that we're going to go over are itams events, try catch function selectors, abi encoding, hashing, and then you will slash and then you will slash assembly.

3125
05:28:36.609 --> 05:28:43.647
However, if you've gotten this far, you probably can read most solidity code and understand what's going on, which is absolutely fantastic.

3126
05:28:43.647 --> 05:28:47.585
So you should give yourself a huge round of applause for getting this far.

3127
05:28:47.585 --> 05:28:48.397
And doing this.

3128
05:28:48.397 --> 05:28:55.874
Let's do a quick summary of this more advanced section and make sure we understand what we learned in solidity there are a couple special functions.

3129
05:28:55.874 --> 05:28:59.368
Some of them are receive fallback, and Constructor.

3130
05:28:59.368 --> 05:29:03.641
These functions don't need to have the function keyword.

3131
05:29:03.641 --> 05:29:06.307
And instead it can just be called like so.

3132
05:29:06.307 --> 05:29:09.115
Receive and fallback are two very special functions.

3133
05:29:09.115 --> 05:29:18.000
If data is sent with a transaction, and no function was specified, the transaction will default to the fallback function if that fallback function exists.

3134
05:29:18.000 --> 05:29:22.759
If data is empty, and there's a receive function, it'll call the receive function.

3135
05:29:22.759 --> 05:29:27.586
There are a couple of keywords that can help us save gas in the long run.

3136
05:29:27.586 --> 05:29:30.720
Some of those keywords are going to be constant and immutable.

3137
05:29:30.720 --> 05:29:35.308
Constant and immutable are for variables that can only be declared and updated once.

3138
05:29:35.308 --> 05:29:39.011
Once we say minimum USD is 50 times 118.

3139
05:29:39.197 --> 05:29:41.971
This minimum USD can never be changed again.

3140
05:29:43.197 --> 05:29:43.748
save gas.

3141
05:29:47.197 --> 05:29:56.163
However, immutable variables can be declared one time in the constructor, once an immutable variable is declared, it can't be changed later on.

3142
05:29:56.163 --> 05:30:06.509
In fact, if we even tried to update an immutable variable or constant variable, and we compiled, a compiler would give us an error saying, Can't write to a mutable here.

3143
05:30:06.509 --> 05:30:10.024
Or if we tried to change a constant variable.

3144
05:30:10.024 --> 05:30:14.149
Our compiler would say, Hey, you can't assign to a constant variable, sorry.

3145
05:30:14.197 --> 05:30:20.885
In remix, if we want to send ether to a contract that's on the JavaScript virtual machine, we can deploy that contract.

3146
05:30:20.885 --> 05:30:27.798
And then in the contract, we can just hit the transact button without any call data and update the value that we send with the transaction.

3147
05:30:27.798 --> 05:30:32.039
If call data is blank, it will trigger the receive function if it exists.

3148
05:30:32.039 --> 05:30:50.139
But if there's data that doesn't specify any of the other functions, it'll trigger the fallback function Awesome, you've done fantastically to get this far.

3149
05:30:50.198 --> 05:30:54.713
And for this section before we get started actually moving over to Hardhead.

3150
05:30:54.713 --> 05:30:58.179
And moving over to JavaScript and understanding why we need to do that.

3151
05:30:58.179 --> 05:31:02.098
Let's understand a little bit about getting help and running into problems.

3152
05:31:02.098 --> 05:31:06.118
So let's say we have our Funmi contract here that we just worked on.

3153
05:31:06.118 --> 05:31:07.705
And we run into an error.

3154
05:31:07.705 --> 05:31:15.493
Let's say for example, we forgot the payable keyword, right, and we go ahead and compile this compile fund, we did so.

3155
05:31:15.493 --> 05:31:16.427
And we scroll down.

3156
05:31:16.427 --> 05:31:21.099
And we see obviously, we have two errors here, right, we're getting some errors, and we scroll down.

3157
05:31:21.099 --> 05:31:31.470
And we see type error message dot value and call value can only be used and payable public functions, make the function payable or using an internal function to avoid this error.

3158
05:31:31.470 --> 05:31:34.567
And then it goes ahead and gives the line that's airing.

3159
05:31:34.567 --> 05:31:38.439
Now this error is pretty clear, this error code is pretty clear.

3160
05:31:38.439 --> 05:31:48.443
It's saying Hey, make the function payable, or using an internal function to avoid this error, right? This should be pretty easy to to add payable, and then recompile and be good to go.

3161
05:31:48.443 --> 05:31:51.810
And this is actually a good example of what to do when you run into errors.

3162
05:31:51.810 --> 05:31:52.616
When you run into errors.

3163
05:31:52.616 --> 05:31:59.424
The first thing you want to do is you want to try to figure out exactly what's going on yourself based off of what the error says.

3164
05:31:59.424 --> 05:32:13.865
This one's pretty straightforward, but some of them can be a little bit more obscure step one when trying to get unblocked trying to tinker and figure out errors yourself, right? Because maybe you go okay, I'll make this payable, right? And you go to save.

3165
05:32:13.865 --> 05:32:18.182
And then it gives a different error saying, hey, you know, payable doesn't go here.

3166
05:32:18.182 --> 05:32:22.976
You resave you recompile it goes, Hey, we're still missing that payable thing.

3167
05:32:22.976 --> 05:32:26.737
First step is always going to be trying to tinker and figure it out yourself.

3168
05:32:26.737 --> 05:32:38.100
For this course, I want you to limit tinkering, slash triaging to 20 minutes, if you take more than 20 minutes to tinker and triage, then move on to the next step.

3169
05:32:38.100 --> 05:32:50.149
But I also want you to take at least 15 minutes yourself or be 100% Sure, you exhausted all options, you're completely out of ideas.

3170
05:32:50.149 --> 05:32:53.599
So typically try to tinker try some stuff for 15 minutes.

3171
05:32:53.599 --> 05:33:01.392
And if you're under 15 minutes, and you're saying, Hey, I'm 100% Certain I've tried everything that I can think of, then you can move on to the next step.

3172
05:33:01.392 --> 05:33:10.280
So step one, when you run into errors is always going to be tinker and try to pinpoint exactly what's going on.

3173
05:33:10.280 --> 05:33:12.949
Try to pinpoint exactly what's going wrong.

3174
05:33:12.949 --> 05:33:19.516
Step two, let's say you tinkered and you tried payable all over the place, and you couldn't figure out what this error was and how to debug this here.

3175
05:33:19.516 --> 05:33:25.650
Step two is always going to be Google the exact error and see if you can learn from that.

3176
05:33:25.650 --> 05:33:43.463
So zoom out a little bit, I'll roll my mouse over this, grab this, copy it, or quotes around it, and do exactly that, in Google search that exact error and take some time going through Google going through Stack Overflow going through Stack Exchange eath, and look to see if somebody has asked this question already.

3177
05:33:43.463 --> 05:33:49.820
And it looks like down here looks like somebody has type error missed a value and call though can only be used on PayPal public functions.

3178
05:33:49.820 --> 05:33:53.996
And if we scroll down, we see that somebody ran into exactly this.

3179
05:33:53.996 --> 05:33:55.589
And they went ahead and solved it.

3180
05:33:55.589 --> 05:33:59.911
They go, I realized my mistake, I needed to add the PayPal keyword to my own implementation.

3181
05:33:59.911 --> 05:34:02.996
And they go ahead in this question, they've added the payable.

3182
05:34:02.996 --> 05:34:06.350
And hopefully this would give you the insight to say, Ah, okay, great.

3183
05:34:06.350 --> 05:34:08.596
I do need to come back here and add payable.

3184
05:34:08.596 --> 05:34:11.555
Let's say this StackOverflow question didn't show up.

3185
05:34:11.555 --> 05:34:13.080
Right? This forum wasn't here.

3186
05:34:13.080 --> 05:34:15.837
What do we do next? So step one, tinker.

3187
05:34:15.837 --> 05:34:21.167
Step two, Google the exact error, I'm going to do a step 2.

3188
05:34:21.167 --> 05:34:36.450
5 That only is for this class, go to our GitHub, repo discussions, and or updates for this course, specifically, go to this GitHub repo, full blockchain solidity course, Jas, it'll look a little bit different when you all get to it.

3189
05:34:36.450 --> 05:34:43.771
But come to this repo, and look in this chronological update section to see if there's an update on that section that you're doing.

3190
05:34:43.771 --> 05:34:46.762
Obviously, since I'm recording right now, there's no update.

3191
05:34:46.762 --> 05:34:50.958
And if you don't get anything, feel free to jump into the discussion section.

3192
05:34:50.958 --> 05:34:57.717
And ask a question in here, right, there's going to be a community of people looking to help each other out and looking to make this a lot of fun.

3193
05:34:57.717 --> 05:34:59.088
And the reason I say 2.

3194
05:34:59.088 --> 05:35:08.215
5 is because in the real world, you're not going to have our GitHub repo, when working on stuff outside of this course, you're not going to have this GitHub repo.

3195
05:35:08.215 --> 05:35:15.707
So instead, in the real world, I'm still going to give you the keys, I'm going to give you what it takes to still unblock yourself on anything.

3196
05:35:15.707 --> 05:35:16.024
Okay.

3197
05:35:16.024 --> 05:35:26.312
So number three is going to be asked a question on a forum, like stack, exchange eath and Stack Overflow.

3198
05:35:26.312 --> 05:35:36.151
Stack Overflow is a question and answering tech forum like this, right? You can ask tech questions, and then you can answer them as well.

3199
05:35:36.151 --> 05:36:02.942
And as you can see, when you search for these issues, they'll show up so Stack Overflow is more for general Role programming questions and Stack Exchange Aetherium or Stack Exchange eath Aetherium Stack Exchange, this is for more Aetherium or EVM based question and all the solidity code that we're gonna be working with, whether it's polygon, whether it's avalanche, whether it's whatever, those questions are going to be valid here, and you can ask here.

3200
05:36:02.942 --> 05:36:14.915
So what you'd want to do is you'd want to sign up or log in, and ask and format your questions on these forms, you'll want to sign up for GitHub, you want to sign up for Stack Exchange, you'll want to sign up for Stack Overflow, so you can participate in these forums.

3201
05:36:14.915 --> 05:36:18.138
In fact, if you haven't already, let's sign up for GitHub right now.

3202
05:36:18.138 --> 05:36:25.431
And let me walk you through formatting one of these questions, because the better you format your questions, the better chance you have of actually getting the answer.

3203
05:36:25.431 --> 05:36:41.513
And remember, when asking questions on these forums, when asking questions, in these discussion communities, people answer these questions out of the goodness of their heart, right? So if you don't get a response, there's a chance that maybe nobody knows, maybe it's your question isn't formatted very well, and etc.

3204
05:36:41.513 --> 05:36:44.439
So we're going to learn how to ask really good questions here.

3205
05:36:44.439 --> 05:36:47.268
And if you're new to blockchain, do not skip this section.

3206
05:36:47.268 --> 05:36:53.089
Okay, this is going to be that piece that's going to give you the superpower to unblock yourself from any coding issue you run into.

3207
05:36:53.089 --> 05:36:54.582
So don't skip this powerup.

3208
05:36:54.582 --> 05:36:55.891
Be sure to follow along.

3209
05:36:55.891 --> 05:36:56.163
Okay.

3210
05:36:56.163 --> 05:37:00.007
So if you don't have a GitHub already, you do need an email to get started.

3211
05:37:00.007 --> 05:37:03.668
So I'm going to go ahead and sign in, I made a burner account just for this video.

3212
05:37:03.668 --> 05:37:18.371
So what we're gonna do, we're gonna go ahead and sign up GitHub, enter your email and we hit Create Account, they're going to send us an email.

3213
05:37:18.371 --> 05:37:23.096
So we're going to come back to our email, and we got our launch code here, paste it in.

3214
05:37:23.096 --> 05:37:26.577
And so a little bit of information.

3215
05:37:26.577 --> 05:37:31.452
We're going to choose the free version.

3216
05:37:31.452 --> 05:37:32.630
and fantastic.

3217
05:37:32.630 --> 05:37:34.296
We've now created a GitHub profile.

3218
05:37:34.296 --> 05:37:45.833
Now back over in the smart contract kid full blockchain solidity course, Jas, I'm going to create a new discussion, a new thread, and I want you all to comment on to make sure you understand how to format and how to ask questions.

3219
05:37:45.833 --> 05:37:48.125
Okay, general thread for practicing.

3220
05:37:48.125 --> 05:37:49.971
Question formatting.

3221
05:37:49.971 --> 05:37:50.432
Oops.

3222
05:37:50.432 --> 05:37:52.832
And so let's go back here.

3223
05:37:53.202 --> 05:37:59.788
So first, I'm going to format this question poorly, two ways, and then we're gonna format it really, really well.

3224
05:37:59.788 --> 05:38:04.443
So the first way we're going to format it poorly, is by not giving enough information.

3225
05:38:04.443 --> 05:38:17.468
So what we're going to do is I'm gonna just copy this issue we're going to do is we'll just say like, Hey, I'm having trouble with remix and an error.

3226
05:38:17.468 --> 05:38:29.540
Can someone help me? Why is this not a well formatted question? If this is my question, there's not nearly enough information here, I, as a helper, have no idea what this person's asking.

3227
05:38:29.540 --> 05:38:31.105
So let's do something else.

3228
05:38:31.105 --> 05:38:42.781
What I'm going to do is I'm going to copy this entire contract all the fun, read outsole, paste it in here, and go, Hi, I'm having issues here.

3229
05:38:42.781 --> 05:38:50.218
Can someone help? I'm gonna head start discussion here want to hit start discussion, it formats this all weird.

3230
05:38:50.218 --> 05:38:53.235
And once again, there's not really enough information here.

3231
05:38:53.235 --> 05:38:55.235
I don't know what the issue is.

3232
05:38:55.235 --> 05:38:58.703
But at least with this one, we have some code, we have some way to actually debug.

3233
05:38:58.703 --> 05:38:59.810
So this is a little bit better.

3234
05:38:59.810 --> 05:39:01.185
But it's still not that good.

3235
05:39:01.185 --> 05:39:02.685
Let's go ahead and edit this.

3236
05:39:02.685 --> 05:39:03.989
To make this even better.

3237
05:39:03.989 --> 05:39:16.515
We hit three dots, we can hit edit, what we can do is we can use something called Markdown syntax, and highly recommend learning a little bit of markdown, it's basically some syntax help make discussions on GitHub.

3238
05:39:16.515 --> 05:39:20.949
And also, questions on Stack Overflow and Stack Exchange a lot easier.

3239
05:39:20.949 --> 05:39:30.203
So we're going to format this code by adding these three backticks at the start, and then also at the end of our code.

3240
05:39:30.203 --> 05:39:41.703
And then additionally, next, the first three backticks, we're going to type so lid did T which tells the format or to to use solidity to format this code here.

3241
05:39:41.703 --> 05:39:46.944
Now if we update discussion, we notice we get some nice highlighting here.

3242
05:39:46.944 --> 05:39:50.091
So this becomes much, much easier to read.

3243
05:39:50.091 --> 05:39:54.055
Right? This is way easier to read now than than it was before.

3244
05:39:54.055 --> 05:39:56.677
However, it's still not specific enough.

3245
05:39:56.677 --> 05:40:00.530
We've given a ton of code here, and we haven't given the specific answer.

3246
05:40:00.530 --> 05:40:03.503
So this is gonna be really hard for somebody to answer.

3247
05:40:03.503 --> 05:40:05.153
So let's make this more specific.

3248
05:40:05.153 --> 05:40:07.240
So let's edit this question again.

3249
05:40:07.240 --> 05:40:13.423
And let's specify, so we see here, our issue is specifically on this function.

3250
05:40:13.423 --> 05:40:19.140
We're going to copy this function and we're going to delete everything else in here.

3251
05:40:19.203 --> 05:40:22.106
And now we have just this code inside of here.

3252
05:40:23.204 --> 05:40:24.677
to make this really specific.

3253
05:40:26.204 --> 05:40:29.026
function, I'm running into an error.

3254
05:40:31.204 --> 05:40:33.833
to do is we're going to come back here, we're going to roll the over this.

3255
05:40:33.833 --> 05:40:39.156
We're going to copy this we could have pull our code if we want but we're going to format this error like this.

3256
05:40:39.204 --> 05:40:48.588
And then we're gonna say Can someone tell me What's going on? Update? Now this is a much, much easier question to debug.

3257
05:40:48.588 --> 05:40:52.695
Right? We have some minimalistic code, we have the error that we're getting.

3258
05:40:52.695 --> 05:41:00.139
And we have Can someone tell me what's going on? Obviously, the answer to this would be to add payable to this.

3259
05:41:00.204 --> 05:41:09.089
And that's what somebody would say, hey, like, you need to add payable to this, I want you all to practice doing some formatting, go ahead and add a comment on this with your own formatted question.

3260
05:41:09.089 --> 05:41:12.027
So that you understand how to actually do the formatting.

3261
05:41:12.027 --> 05:41:13.497
And this markdown format.

3262
05:41:13.497 --> 05:41:26.113
It's this format here, that's gonna be the exact same for asking questions on Stack Overflow, or Stack Exchange for this course, go ahead and practice if you want to create more new discussions, feel free to create new discussions.

3263
05:41:26.113 --> 05:41:37.135
If you want to use Stack Overflow or Stack Exchange eath actually highly recommend you Stack Overflow or Stack Exchange eath as well, because those are gonna get indexed a lot better than GitHub here.

3264
05:41:37.204 --> 05:41:39.928
However, feel free to ask questions, obviously, in this GitHub as well.

3265
05:41:39.928 --> 05:41:48.937
Now that I've given you kind of the basics rundown, we're going to watch a video that I made that goes even deeper into why and how to format all these questions and what to use.

3266
05:41:48.937 --> 05:41:52.537
So let's go ahead and watch that.

3267
05:41:52.537 --> 05:41:58.203
Every developer has run into this.

3268
05:41:58.203 --> 05:42:02.505
Something breaks or maybe you don't know something, but you don't have time to let these stop you.

3269
05:42:02.505 --> 05:42:16.174
There are a series of steps that one should take to maximize one's chances of solving any coding problem, but you'd be surprised at how few developers currently use the superpower effectively, our first one we'll spend the least time on, because it's just tinker and experiment.

3270
05:42:16.205 --> 05:42:17.505
When you run into an issue.

3271
05:42:19.205 --> 05:42:25.825
think might work, maybe try doing print statements throughout the file, learn some debugging tips, but don't be so cocky that you only do this first step.

3272
05:42:25.825 --> 05:42:28.786
And this shouldn't just be random running around.

3273
05:42:28.786 --> 05:42:36.626
This should be trying to pinpoint exactly what's going wrong in your code, so that you can either ask an effective question, or figure it out yourself.

3274
05:42:36.626 --> 05:42:40.882
So pinpoint exactly what's going wrong, because you'll need it for the next steps.

3275
05:42:40.882 --> 05:42:43.117
Anyways, next, check the documentation.

3276
05:42:43.117 --> 05:42:45.783
Not all tools have good documentation.

3277
05:42:45.783 --> 05:42:53.677
But taking some time to explore documentation can be a quick way to find your answer, you'll want to learn how to search a webpage with Command F or Control F.

3278
05:42:53.677 --> 05:42:59.549
That way, you can look for specific keywords on a page, or hopefully they have a good search bar that works well.

3279
05:42:59.549 --> 05:43:01.598
Sometimes documentation can be really dense.

3280
05:43:01.598 --> 05:43:04.169
So maybe you'll move to the next step, which is doing a web search.

3281
05:43:04.169 --> 05:43:08.696
At the end of the day, good software engineers are secretly just professional Googlers.

3282
05:43:08.696 --> 05:43:16.756
And this is one of their most powerful tools, being able to search the web for somebody else who has already run into the problem that you've just run into, and then solved it.

3283
05:43:16.756 --> 05:43:22.170
Most search engines like Google have tools you can use to get even more specific about what you're looking for.

3284
05:43:22.170 --> 05:43:31.747
Often for specific errors, the best thing to do is actually just copy the exact error and paste it in the search bar with quotes or use the Asterix in spots, your error might be too specific.

3285
05:43:31.747 --> 05:43:39.057
Most of the results you'll get will be from forums and q&a sites, which leads us to our next step, asking questions in these forums and q&a sites.

3286
05:43:39.057 --> 05:43:45.831
Just make sure that before you ask a question, you've done some ample Googling around yourself beforehand.

3287
05:43:45.831 --> 05:43:48.784
This way you don't waste yours and anybody else's time.

3288
05:43:48.784 --> 05:43:56.529
And by asking questions that you swear you will promise me that at some point, you will go back and help other people learn as well got it good.

3289
05:43:56.529 --> 05:44:02.006
Before even asking your question though, we should learn where is going to be the best place to ask.

3290
05:44:02.006 --> 05:44:08.837
This is why I've categorized for different types of forums and QA sites, feel free to pause to read them over.

3291
05:44:08.837 --> 05:44:28.144
And here's some specific examples of each one of these index code base forms like Stack Overflow, index repositories like GitHub issues, index technology, specific forums, like our slash eat dev or unindexed discussion platforms like chainlink discord, one of the key differentiators in these categories is the index keyword.

3292
05:44:28.206 --> 05:44:35.140
We typically want to ask questions on forums that web crawlers have gone through and stuck them in their database or index them this way.

3293
05:44:35.140 --> 05:44:41.156
And three weeks when we look back at the code that we wrote, we can just Google what was going on when we forget what it does.

3294
05:44:41.156 --> 05:44:47.583
And this will help out other developers who run into the same problem, which in turn, they might go ahead and help you out later.

3295
05:44:47.583 --> 05:44:53.706
Ideally, most of your questions should be asked on one of these index forms for this reason for their searchability and discoverability.

3296
05:44:53.706 --> 05:45:07.175
However, at some questions are a better fit for DMS, Twitter or discord that aren't index and we made a little chart here to figure out where's the best place to post your questions, feel free to pause the video take a look or read our blog and the descriptions with the picture as well to take another look at it.

3297
05:45:07.206 --> 05:45:15.013
And of course, before actually posting that in one of these forums, be sure to read their rules as they might state that some kind of questions are specifically for Ben.

3298
05:45:15.013 --> 05:45:17.991
But basically the breakdown looks like this.

3299
05:45:17.991 --> 05:45:45.391
Theoretical big picture or opinionated questions can go great on general q&a forums like Quora or specific technical forums like specific subreddits or discord forums, specific coding questions can go on these forums as well, but will often get more eyes on coding forums like Stack Overflow or Stack Exchange communities often the question of Oh, should I post this on stack URL? flow or maybe a Stack Exchange community is incredibly blurry.

3300
05:45:45.391 --> 05:45:47.340
And sometimes it doesn't really matter which one you post on.

3301
05:45:47.340 --> 05:46:00.153
Now, if you run into a bug or an issue with a technology you're really familiar with, and you think it shouldn't be breaking, this is your chance to pop an issue into their open source code repository and potentially improve the tool.

3302
05:46:00.207 --> 05:46:08.514
They don't have an open source code repository, you throw that closed source piece of shit into the garbage, but just kidding closed source Tech has its place in our lives, too.

3303
05:46:08.514 --> 05:46:18.016
Additionally, if you're following a tutorial, and they have a Git repo associated with it, like all of my videos that do, that's gonna be the best place to leave your issues.

3304
05:46:18.016 --> 05:46:27.592
So as much as I hate to say it, putting your issues onto my GitHub repositories is going to be much more effective for us answering your questions than posting it in the YouTube comments.

3305
05:46:27.592 --> 05:46:37.239
Now finally, Discord, element, email, text message or any other these unindexed chats are still good places to ask questions, but please try to use them as a last resort.

3306
05:46:37.239 --> 05:46:53.457
And if they do end up answering one of your questions, maybe go back and add that question and answer to one of the other forums that we were talking about this way it will be indexed next time you or somebody else, Google's it now these quicker chat forums are places more for the community to congregate and have quick conversations with each other.

3307
05:46:53.457 --> 05:47:01.600
They're places to theory craft, talk about new things coming out new ideas, events, and other things that shouldn't be indexed by web crawlers.

3308
05:47:01.600 --> 05:47:10.333
They're also great places to meet and network with people that you might be able to bounce ideas off directly as you get to know each other, which leads into our last section.

3309
05:47:10.333 --> 05:47:17.558
But before we do that, Oh, do you hear that? Oh, that's the video inside another video alarm ringing.

3310
05:47:17.558 --> 05:47:24.096
When you ask a question in one of these forums, the better you format your questions, the better chance you'll have of getting an answered.

3311
05:47:24.096 --> 05:47:26.127
Now there's no bad questions out there.

3312
05:47:26.127 --> 05:47:28.110
But there are poorly formatted questions.

3313
05:47:28.208 --> 05:47:35.072
So let's teach you how to always ask questions as format as best as possible to give you the highest chance of making sure they get answered.

3314
05:47:35.072 --> 05:47:39.962
Number one, before asking your question, make sure you followed all the steps in the parent video.

3315
05:47:39.962 --> 05:47:44.908
And you've done some research on this already and make sure the question hasn't already been asked.

3316
05:47:44.908 --> 05:47:58.386
Number two, make a title that summarizes the specifics of the question three introduced the problem before you write any code, add minimalistic, reproducible code minimalistic code means it's not just a copy paste your entire file.

3317
05:47:58.386 --> 05:48:11.303
If you're having problems on one line, maybe just post that one line reproducible code means that others should be able to run to the exact same error that you're running into, or at least post the steps for them to do it.

3318
05:48:11.303 --> 05:48:18.949
This doesn't mean that you should put I was following along Patrick's video and on our five I ran into this problem, just watch his video and you'll get there.

3319
05:48:18.949 --> 05:48:27.953
As flattering as this is it's not reasonable that everyone is going to have watched my videos, even though they should you want to give the technical steps to reach the error that you've reached.

3320
05:48:27.953 --> 05:48:39.896
For those of you watching my Free Code Camp video, you're kind of exempt from this, but you can only say, Hey, I was on our Five on this part of your video inside of our discussions tab of the GitHub repo associated with this course.

3321
05:48:39.896 --> 05:48:41.083
So you can do that.

3322
05:48:41.209 --> 05:48:51.646
But only in that GitHub repo associated with this course, learning markdown to format your code, especially using these three backticks and labeling of the language.

3323
05:48:51.646 --> 05:48:58.471
This is a critical piece of formatting your code and will drastically improve on the number of people who answer your questions.

3324
05:48:58.471 --> 05:49:02.886
Any errors or code should be formatted with this three backticks syntax.

3325
05:49:02.886 --> 05:49:11.831
And finally, often people who care about certain technologies, monitor specific tags and monitor specific questions being asked about the technologies that they like.

3326
05:49:11.831 --> 05:49:19.612
And then finally, again, be sure to read the forum's guides before posting different forums have different rules about what they want and what they don't want.

3327
05:49:19.612 --> 05:49:22.945
So being familiar will increase your chances of getting an answer.

3328
05:49:22.945 --> 05:49:23.471
All right.

3329
05:49:23.471 --> 05:49:24.838
So now back to the main video.

3330
05:49:24.838 --> 05:49:34.780
Now a note about Stack Overflow, in particular, Stack Overflow can be a little aggressive, which is why sometimes posting on specific community forums might be better for your specific technology questions.

3331
05:49:34.780 --> 05:49:38.630
If you post on Stack Overflow, and you get a ton of down votes on your questions.

3332
05:49:38.630 --> 05:49:39.848
Don't let that bother you.

3333
05:49:39.848 --> 05:49:48.142
Just take it as a learning opportunity to learn about what Stack Overflow likes and doesn't like and just keep going but do not let that discourage you.

3334
05:49:48.209 --> 05:49:54.726
Okay, well, now that we know where things should go, where questions should go and how to actually format them.

3335
05:49:54.726 --> 05:49:57.342
Let's practice let's look at some sample questions that you might have.

3336
05:49:57.342 --> 05:49:58.908
And we'll figure out where we want to put them.

3337
05:49:58.908 --> 05:50:02.609
So the first one, where does this one go? Feel free to pause and guess yourself.

3338
05:50:02.609 --> 05:50:08.243
So a question like this is going to be great for a Reddit or a discord? Probably more a discord.

3339
05:50:08.243 --> 05:50:11.446
Now, this is definitely something that you can search for.

3340
05:50:11.446 --> 05:50:15.362
Right? So you probably could search for this, find an answer and go from there.

3341
05:50:15.362 --> 05:50:19.735
But maybe you want to ask a buddy or maybe you want to ask a very specific community like our slash eat Dev.

3342
05:50:19.735 --> 05:50:24.460
Now, of course, if you see this question, you obviously want to recommend Patrick Collins his YouTube channel.

3343
05:50:24.460 --> 05:50:25.906
Now how about this question.

3344
05:50:25.906 --> 05:50:29.151
Notice its formatting right? The title is nice and big.

3345
05:50:29.151 --> 05:50:32.820
They have a technical command that is formatted properly.

3346
05:50:32.820 --> 05:50:43.548
They have Git commit which is formatted properly, where would this go like this would definitely do very well on a Stack Overflow or an index code based forum to very clearly try had to do something technical.

3347
05:50:43.548 --> 05:50:45.410
The problem is laid out very clearly.

3348
05:50:45.410 --> 05:50:48.226
And they've given the command that they're looking to do.

3349
05:50:48.226 --> 05:50:51.531
Now, how about this one, something like this could go on either StackOverflow.

3350
05:50:51.531 --> 05:50:56.701
But it's probably more likely going to go on a GitHub issue for this brownie package.

3351
05:50:56.701 --> 05:51:08.064
A big difference between code forums and and Git repos like GitHub is that when you make an issue on a GitHub repository, especially when you think there's a problem, you do want to be as in depth as possible.

3352
05:51:08.064 --> 05:51:19.114
So oftentimes, when making an issue on these repos, they'll even ask, what version are you using? Can you post all your code? Can you post all your files and just be much, much more explicit? So how about something like this.

3353
05:51:19.114 --> 05:51:27.599
So this is going to be really good for the GitHub repo associated with this tutorial, it looks like this person is asking about a very specific tutorial.

3354
05:51:27.599 --> 05:51:30.242
So posting this, there is going to be best.

3355
05:51:30.242 --> 05:51:35.505
Now if your question is on a tutorial that doesn't have a GitHub repo, well, they probably should.

3356
05:51:35.505 --> 05:51:38.111
But then maybe this is better in the comment section.

3357
05:51:38.210 --> 05:51:50.262
Now, again, this is where this all becomes a little bit more art than science, because maybe the specific error that they're running into is a generic error that a ton of people run into, and maybe it is better on StackOverflow.

3358
05:51:50.262 --> 05:51:52.822
Or maybe there's an issue with the package.

3359
05:51:52.822 --> 05:51:54.886
So maybe it is better on GitHub.

3360
05:51:54.886 --> 05:51:57.260
Or maybe the solution to this is opinionated.

3361
05:51:57.260 --> 05:52:02.443
And finally, what about this? Yep, this is going to be much better for a discord or a DM with your buddy.

3362
05:52:02.443 --> 05:52:08.030
And away, it's our last step on blocking you from any question is going to be join and strengthen the community of your tool.

3363
05:52:08.030 --> 05:52:12.372
Now at the start, it's going to be hard for you to give back since you're not going to be very knowledgeable on these tools.

3364
05:52:12.372 --> 05:52:17.146
But as you get better at these technologies, you'll want to try to answer some of these new questions that do come in.

3365
05:52:17.146 --> 05:52:31.372
The reason is because this will give you a chance to actually learn more about the tools that you like, it'll strengthen the community of your favorite tools, meaning if you help answer questions on tool, it'll actually encourage other people to use the tool because there's a strong following there.

3366
05:52:31.372 --> 05:52:36.421
And likely, they might actually help you sometime in the future, you helping people will make you look like a good person.

3367
05:52:36.421 --> 05:52:38.822
And then you'll also feel like a good person.

3368
05:52:38.822 --> 05:53:01.192
Additionally, in many forums like Reddit, oftentimes, mods will actually look at how often you post versus how often you help others and comments on others people posts and some mods may actually start blocking your posts for abusing the forums and not giving back to the community and only trying to take knowledge you in the community will be more successful if you join in and help others and not just try to extract things from other people.

3369
05:53:01.192 --> 05:53:09.143
Additionally, by engaging with the community, I can't tell you how many people I've met and I've learned and been able to brainstorm with.

3370
05:53:09.211 --> 05:53:11.456
And then the final step is going to be iterate through these steps.

3371
05:53:11.456 --> 05:53:18.820
Maybe you get to the end of these and you say, Oh, I'm still blocked, but you'll likely be much, much more knowledgeable.

3372
05:53:18.820 --> 05:53:21.116
So you want to go back and try these steps again.

3373
05:53:21.211 --> 05:53:24.853
Now this is where this whole process is a little bit more art than science.

3374
05:53:24.853 --> 05:53:27.922
Because some questions might not have been discovered yet.

3375
05:53:27.922 --> 05:53:34.372
Only very few people know not enough people understand the importance of the questions, or maybe people don't understand your question.

3376
05:53:34.372 --> 05:53:37.761
And this is why it's important to go back and iterate on these steps.

3377
05:53:37.761 --> 05:53:48.012
Now that you have the basic building blocks of this incredible superpower, I encourage all of you to go out there and try this and then let me know how it went.

3378
05:53:48.212 --> 05:53:49.025
Alright, awesome.

3379
05:53:51.212 --> 05:53:52.505
unblocked, we can move on.

3380
05:53:54.212 --> 05:53:59.434
learn how to get unblocked is because blockchain and web three is more than just everybody on their own.

3381
05:53:59.434 --> 05:54:01.500
It is a very collaborative space.

3382
05:54:01.500 --> 05:54:13.605
So as you get better, and as you learn more a massive way to test how much you've learned and give back to the community is to going to Stack Overflow and going to stack exchange them and trying to answer some questions yourself.

3383
05:54:13.605 --> 05:54:26.832
So I highly recommend you all go to Stack Overflow, and then you go to the GitHub repo associated with the scores, you try to answer some discussions, try to answer some issues and help other people out because it's going to help you become a much better software engineer.

3384
05:54:26.832 --> 05:54:36.597
The other reason I want to do that part is because when we install some of the tools that I'm about to show you, sometimes the installation process is the hardest piece there.

3385
05:54:36.597 --> 05:54:40.962
Once you get past the install process, it generally becomes much, much easier.

3386
05:54:40.962 --> 05:54:47.162
But this can often be the hardest part of the course is just installing some of these tools that we're going to give you.

3387
05:54:47.212 --> 05:54:49.856
And that's what we're going to learn about right now.

3388
05:54:50.212 --> 05:54:55.381
have been working so far with remix, remix IDE, or integrated development environment.

3389
05:54:55.381 --> 05:55:02.862
As we've seen, it's this wonderful place where we can try out code we can try solidity out, we can compile we can deploy, we can pretty much do everything that we need to do.

3390
05:55:02.862 --> 05:55:03.612
It's web based.

3391
05:55:03.612 --> 05:55:11.022
It can do testing, debugging, deploying local JavaScript VM, it's very quick and easy to create and test our smart contracts.

3392
05:55:11.022 --> 05:55:12.986
However, it does have some limitations.

3393
05:55:12.986 --> 05:55:17.824
It can really only deal with smart contract, it can't really integrate with other parts of projects.

3394
05:55:17.824 --> 05:55:20.524
It has limited support for tests or custom deployments.

3395
05:55:20.524 --> 05:55:27.634
And you need an internet connection to even work with remix and it can be tricky to do a lot more advanced functionality.

3396
05:55:27.634 --> 05:55:39.213
So it's a phenomenal tool and absolutely if you're looking to do something very quickly, I absolutely recommend everybody just go to remix to go ahead and try something out how are now we're going to move over to a more professional smart contract developer setup.

3397
05:55:39.213 --> 05:55:40.946
And this is with hard hat.

3398
05:55:40.946 --> 05:55:48.900
This is known as a smart contract developer framework similar to brownie or foundry or, and likes, there's a number of these frameworks.

3399
05:55:48.900 --> 05:55:52.570
And the reason that we're going to do hard hat is because hard hat is JavaScript based.

3400
05:55:52.570 --> 05:55:55.728
It's a JavaScript based development environment.

3401
05:55:55.728 --> 05:56:00.114
It's got JavaScript based compilation, environment, deploying, testing, debugging.

3402
05:56:00.114 --> 05:56:08.340
Now, for those of you who love TypeScript, we will also have TypeScript editions of every single one of our code examples for you.

3403
05:56:08.340 --> 05:56:16.149
So if you love JavaScript, we got you, if you love TypeScript, we also got you we're not always going to walk through us doing the TypeScript.

3404
05:56:16.213 --> 05:56:22.141
But we will sometimes, and all of the code for the TypeScript will be available in the GitHub repo.

3405
05:56:22.141 --> 05:56:26.166
Now, before we can actually learn hard hat, we have to learn another package first.

3406
05:56:26.213 --> 05:56:29.825
So we're going to learn how to do everything with ethers.

3407
05:56:30.213 --> 05:56:33.655
which is a JavaScript based library for working with smart contracts.

3408
05:56:33.655 --> 05:56:39.498
And it's also what powers the next tool that we're going to be working with, which is hard hat under the hood of hard hat.

3409
05:56:39.498 --> 05:56:40.498
There's a lot of ethers Jas.

3410
05:56:40.498 --> 05:56:45.937
So it's important for us to learn ethers Jas so that we can understand what hard hat is actually doing.

3411
05:56:45.937 --> 05:56:50.832
Now for the rest of the course, I'm going to be using a code editor called Visual Studio code.

3412
05:56:50.832 --> 05:56:53.825
This is one of the most powerful code editors on the planet.

3413
05:56:53.825 --> 05:56:57.641
And if you've already got it set up, feel free to go ahead and skip this part.

3414
05:56:57.641 --> 05:57:05.158
If you already have a professional coding setup with no GS and VS code, and Git and everything, feel free to use the timestamps in the GitHub repository.

3415
05:57:05.158 --> 05:57:07.214
To skip over this setup section.

3416
05:57:07.214 --> 05:57:13.438
You'll often hear people refer to this as VS code, or Visual Studio code or just Visual Studio.

3417
05:57:13.438 --> 05:57:21.938
However, it's important to note that Visual Studio code this is different than Visual Studio, which you might see look like this.

3418
05:57:21.938 --> 05:57:30.414
So Visual Studio code is what you want, not Visual Studio, Visual Studio is a different application, make sure you're on Visual Studio code.

3419
05:57:30.414 --> 05:57:42.118
Now, if you choose so and you're a total Harto, you can absolutely work just with your terminal, or just with PowerShell, or just with whatever coding environment that you want, like atom or Sublime.

3420
05:57:42.118 --> 05:57:45.886
However, for us, we're going to be working with Visual Studio code.

3421
05:57:45.886 --> 05:57:54.935
And I'm going to be going through setting up Visual Studio code the way that I like to set it up, you can actually set it up whatever way that you feel comfortable.

3422
05:57:54.935 --> 05:57:59.642
And of course, in our lesson six here, we have a link to installation and setup.

3423
05:57:59.642 --> 05:58:02.464
And I'm going to be adding more links as we go about here.

3424
05:58:02.464 --> 05:58:09.117
And once again, all the code that we're going to be working with is in this GitHub repository down here where it says code.

3425
05:58:09.117 --> 05:58:14.459
Now we're gonna go through three different installation processes and pick the one that's most appropriate for you.

3426
05:58:14.459 --> 05:58:17.935
The first one is going to be for Mac and Linux users.

3427
05:58:17.935 --> 05:58:21.082
The second one is going to be for Windows users.

3428
05:58:21.214 --> 05:58:24.017
And then our third one is going to be a last ditch effort.

3429
05:58:24.214 --> 05:58:31.804
for whatever reason, you can't get Windows or Linux or the Mac instructions to work, we're going to use a Git pod installation.

3430
05:58:31.804 --> 05:58:37.568
Now, I highly, highly recommend that you try to get everything working locally without using Git pod.

3431
05:58:37.568 --> 05:58:47.133
However, if for whatever reason, you can't get those installation pieces to work, we will have Git pod instructions for all of the repos that we work with here.

3432
05:58:47.133 --> 05:58:54.092
But to get started, we'll start with the Mac and Linux installation instructions.

3433
05:58:54.215 --> 05:59:02.215
The first thing you're going to want to do is download the Mac or if you're working with Linux, download the Linux installation of Visual Studio code.

3434
05:59:02.215 --> 05:59:05.919
Once you have it installed, it'll look a little something like this.

3435
05:59:05.919 --> 05:59:11.548
And if it's a fresh installation, It'll even give you some tips and tools to actually get started.

3436
05:59:11.548 --> 05:59:21.148
If you've never worked with Visual Studio code before, I highly recommend going through any get started or getting instructions tips that come with opening Visual Studio Code.

3437
05:59:21.215 --> 05:59:27.133
Additionally, we have a Visual Studio Code crash course in the GitHub repo associated with this course.

3438
05:59:27.133 --> 05:59:32.834
Once you have Visual Studio code installed, the next thing that we're going to want to install is going to be node j s.

3439
05:59:32.834 --> 05:59:43.599
And again, we have links to all of these in the GitHub repo associated with this course, you can just go ahead and click download for Mac OS or download for Linux, I recommend using the LTS version.

3440
05:59:43.599 --> 05:59:50.040
lts stands for long term support, which means that they will be supporting this version for a long time.

3441
05:59:50.040 --> 05:59:52.659
So go ahead and download Node js.

3442
05:59:52.659 --> 06:00:14.147
I've already downloaded this, so I'm not gonna go ahead and redownload this now one of the awesome things about Visual Studio code is it has this thing called terminals, which are command line prompts that allow us to run scripts, basically, it's where we're going to be running all of our code where we can open up the terminal is we can go ahead and hit terminal and select new terminal and you'll get something like this.

3443
06:00:14.215 --> 06:00:33.153
Now you might have bash or Z ca or some other type of shell type that you have doesn't really matter because on Mac and Linux it's going to be Linux based we can now test our no Jess installation has been done correctly by running Node dash dash version, and you should see something that looks like this.

3444
06:00:33.216 --> 06:00:37.434
The exact version of node that you have doesn't really matter here.

3445
06:00:37.434 --> 06:00:40.516
But ideally you're at least on Node version 14 or higher.

3446
06:00:40.516 --> 06:00:49.787
And if something like this doesn't show up, remember to go ahead and start looking at Stack Overflow looking on the GitHub repo in the discussions tab, looking on the updated section, etc.

3447
06:00:49.787 --> 06:00:55.794
And like I said, sometimes installing this can be the hardest part of this entire course so, so don't get discouraged.

3448
06:00:55.794 --> 06:01:01.469
And please use Stack Overflow Stack Exchange Etherium, and the GitHub repo to move past any issues you run into.

3449
06:01:01.469 --> 06:01:14.166
Now, if you're on Mac or Linux, you can actually hit Ctrl back tick, to actually toggle your terminal mode, this will pull the terminal up and down for you getting familiar with keyboard shortcuts will actually make your life a lot easier.

3450
06:01:14.216 --> 06:01:21.154
Because you'll be able to move around Visual Studio code much more effectively, we have a link to a list of keyboard shortcuts.

3451
06:01:21.216 --> 06:01:36.675
Additionally, in the GitHub repository associated with this section, as we move along, I'll give tip on different keyboard shortcuts that you can optionally use otherwise, you can just go ahead and click as well, you can click the trash can to delete the terminal, go back up Terminal new terminal to pop it back up.

3452
06:01:36.675 --> 06:01:45.358
Now the next thing that we're going to need a little bit later, we're not going to need it for this section, but it's good to install it now is going to be git no jazz is known as a JavaScript runtime.

3453
06:01:45.358 --> 06:01:51.248
And it's a tool that we're going to use to help run JavaScript code in our Visual Studio Code slot exactly JavaScript.

3454
06:01:51.248 --> 06:01:56.882
And the difference between no Jas and JavaScript can be a little bit confusing, but don't let that stop you for now.

3455
06:01:56.882 --> 06:02:11.636
Next, we're actually going to go ahead and install Git, we will have links to the installation instructions in the GitHub repository, installing git on Linux, you're going to use one of these two commands and on macOS, if you just type git on the command line, it should go ahead and prompt you to install it.

3456
06:02:11.636 --> 06:02:16.378
So we're back in our command line, and we just type git, it should prompt you to go ahead and stall it.

3457
06:02:16.378 --> 06:02:20.505
And if you do get dash dash version, you should get something that looks like this.

3458
06:02:20.505 --> 06:02:25.486
You can also use a Mac OS get installer by clicking this link here and running through the installation process.

3459
06:02:25.486 --> 06:02:32.592
Alright, now that you have no JS yet in Visual Studio code installed, we can continue on to the next section.

3460
06:02:32.592 --> 06:02:33.092
Awesome.

3461
06:02:33.092 --> 06:02:41.117
If you're not planning on using Windows or get pod, feel free to skip the next two sections.

3462
06:02:41.217 --> 06:02:42.645
I'm running this on Windows 11.

3463
06:02:44.217 --> 06:02:45.183
editions of Windows.

3464
06:02:47.217 --> 06:02:54.717
want to install is Visual Studio Code, which looks something like this, it should auto detect it.

3465
06:02:54.717 --> 06:03:01.486
And we're gonna go ahead and download this for windows in a walk through all the installation process.

3466
06:03:01.486 --> 06:03:07.298
Go ahead and create a desktop item, we'll add this just in case we want to open with code.

3467
06:03:07.298 --> 06:03:09.369
And we'll go ahead and install.

3468
06:03:09.369 --> 06:03:11.741
And then we'll go ahead and finish.

3469
06:03:11.741 --> 06:03:23.389
Once you've installed Visual Studio code, you'll see something that looks a little like this, it'll go ahead and give you this get started with VS Code section where you can choose some themes, and you can choose kind of the way it looks feel free to customize it the way that you want.

3470
06:03:23.389 --> 06:03:32.911
If you want to learn a little bit more about Visual Studio code, I highly recommend you walk through this section to learn more about the shortcuts and making your development experience more efficient.

3471
06:03:32.911 --> 06:03:36.322
When you're done, you can just go ahead and close the tabs at the top.

3472
06:03:36.322 --> 06:03:37.865
And it'll look a little something like this.

3473
06:03:37.865 --> 06:03:40.050
Once we have Visual Studio code installed.

3474
06:03:40.050 --> 06:03:43.283
The next thing that we're going to want to install is node j s.

3475
06:03:43.283 --> 06:03:50.751
And of course, we have a link to installing this in the GitHub repository associated with this course, what we're going to do is we're going to go ahead and come to node j s.

3476
06:03:50.751 --> 06:03:50.951
org.

3477
06:03:50.951 --> 06:03:53.060
To download this for Windows node.

3478
06:03:53.060 --> 06:03:56.483
JS is a JavaScript runtime environment, it's not exactly JavaScript.

3479
06:03:56.483 --> 06:04:02.958
And the distinction can be a little bit confusing, but just know it's going to help us run our JavaScript code for our development environment.

3480
06:04:02.958 --> 06:04:08.791
Let's go ahead and download the LTS or the long term support edition of no GS.

3481
06:04:08.791 --> 06:04:14.987
We'll go ahead and we'll run through the setup wizard.

3482
06:04:15.218 --> 06:04:21.168
And we'll go ahead and make sure that this is clicked just in case we ever want to use some different tools with our setup.

3483
06:04:21.218 --> 06:04:26.983
And then we'll go ahead and click Install, you'll get a pop up asking if you really want to install this on your device.

3484
06:04:26.983 --> 06:04:28.436
And we'll go ahead and hit yes.

3485
06:04:28.436 --> 06:04:36.030
And then we'll hit finish, you might get a pop up that looks like this, go ahead and click any button to go ahead and install the tools, go ahead and press any key again.

3486
06:04:36.030 --> 06:04:43.551
And you'll likely get a Windows PowerShell screen pop up asking you to go ahead and install a whole bunch of different projects and files.

3487
06:04:43.551 --> 06:04:45.862
If you chose not to install this, that's totally okay.

3488
06:04:45.862 --> 06:04:54.154
But in the future, this will be really helpful since we are going to use a lot of tools that this package installs anyways, this might take some time to install.

3489
06:04:54.218 --> 06:04:55.043
So go ahead and be patient.

3490
06:04:56.218 --> 06:04:58.381
be waiting for you to go ahead and hit enter.

3491
06:04:59.218 --> 06:05:00.511
hit Enter for any prompts.

3492
06:05:02.218 --> 06:05:04.562
this, it can be a little bit slow to go ahead and install everything.

3493
06:05:04.562 --> 06:05:07.843
Once you have all that installed, you can come back to Visual Studio code.

3494
06:05:07.843 --> 06:05:10.818
And we're going to go ahead and open up a terminal.

3495
06:05:10.818 --> 06:05:19.489
To do that we hit terminal and we hit new terminal terminal is going to be our command line prompt where we're going to basically run all of our scripts to work with our code.

3496
06:05:19.489 --> 06:05:27.352
And if you run Node dash dash version, you should see something that looks like this to know that you've installed Node js correctly.

3497
06:05:27.352 --> 06:05:30.719
Now this command line is known as Windows PowerShell.

3498
06:05:30.719 --> 06:05:33.907
If you want to work with Windows PowerShell, you absolutely can.

3499
06:05:33.907 --> 06:05:39.164
In fact, if you want to be a total Harto, and write all your code through Windows PowerShell, you can absolutely do that as well.

3500
06:05:39.164 --> 06:05:46.400
However, we're actually not going to be working with PowerShell We're going to be using a tool that makes our Windows environments more like Linux.

3501
06:05:46.400 --> 06:05:50.552
The reason that we're doing this is Linux is the standard for most development environments.

3502
06:05:50.552 --> 06:06:00.444
And having everybody work on a very similar setup will make the rest of this course a lot easier for everyone to interact with each other, no matter what coding environment, they're working on.

3503
06:06:00.444 --> 06:06:07.790
WsL stands for Windows subsystem for Linux, and allows Linux programs to run natively on our Windows environments.

3504
06:06:07.790 --> 06:06:12.743
To get this setup, we're gonna go ahead, go to the WsL install.

3505
06:06:12.743 --> 06:06:17.989
And we'll have a link for this as well in our GitHub repository.

3506
06:06:17.989 --> 06:06:23.943
So what we're going to do, you must be running a Windows 10, version 2004 or higher, or Windows 11.

3507
06:06:23.943 --> 06:06:27.955
If you're using an older version of Windows, you can absolutely continue with PowerShell.

3508
06:06:27.955 --> 06:06:32.324
But you might run into some issues where all the commands don't work exactly the same.

3509
06:06:32.324 --> 06:06:36.579
So I highly recommend working on a newer version of Windows.

3510
06:06:36.579 --> 06:06:45.200
To install this back in your Visual Studio Code, PowerShell, or just the PowerShell app, or running WsL dash dash install.

3511
06:06:45.200 --> 06:06:56.924
Now if you get this error, the requested operation requires elevation, it means that we have to run our Visual Studio code or our PowerShell application as administrator.

3512
06:06:56.924 --> 06:07:01.645
We close out our Visual Studio code.

3513
06:07:01.645 --> 06:07:12.153
And right click it and say, Run as Administrator, we get a little pop up saying Do you want to allow this app to make changes to your device, we'll go ahead and click Yes.

3514
06:07:12.153 --> 06:07:14.803
And then we'll reopen the terminal.

3515
06:07:14.803 --> 06:07:18.803
And then we can run WsL space dash dash install.

3516
06:07:18.803 --> 06:07:21.719
And we'll go ahead and install WsL.

3517
06:07:21.719 --> 06:07:25.157
This may take a little bit so please be patient.

3518
06:07:25.220 --> 06:07:30.070
Once it's completed, you'll see something that looks like this, we're going to be working with Ubuntu.

3519
06:07:30.070 --> 06:07:33.820
And we have a list of different commands to change your Linux distribution.

3520
06:07:33.820 --> 06:07:34.720
If you choose to do so.

3521
06:07:34.720 --> 06:07:40.600
And you'll see the request set operation is successful changes will not be effective until the system is rebooted.

3522
06:07:40.600 --> 06:07:43.123
So you'll want to go ahead and restart your computer.

3523
06:07:43.220 --> 06:07:46.171
There's also a troubleshooting guide in the GitHub repository.

3524
06:07:46.220 --> 06:07:51.751
If you run into issues after you restart your computer, you'll be prompted for a name for your new system and a password.

3525
06:07:51.751 --> 06:07:56.448
This can be different from your Windows name and password, and then just follow through with all the prompts.

3526
06:07:56.448 --> 06:08:01.185
And then once you're done, you'll be dropped into a Ubuntu shell, and you can run Linux commands.

3527
06:08:01.185 --> 06:08:04.588
Now you'll have a Ubuntu instance, on your machine.

3528
06:08:04.588 --> 06:08:07.727
And you'll be able to run Linux commands in your terminal.

3529
06:08:07.727 --> 06:08:13.580
Now that we have WsL set up correctly, we're going to head back over to Visual Studio code.

3530
06:08:13.580 --> 06:08:17.304
Once we have WsL, we'll want to go ahead and install an extension.

3531
06:08:17.304 --> 06:08:38.827
So in our Visual Studio code, we'll go to Extensions, and we'll look up remote development you can install the whole thing or just remote WsL we're gonna install the whole thing you can follow along to get started with remote WsL if you like, or you can just follow along with me right now.

3532
06:08:38.827 --> 06:08:47.407
Right now if I go to the terminal and hit new terminal, I'm still gonna get PowerShell we actually want this to be our Linux shell.

3533
06:08:47.407 --> 06:08:52.268
So there are a couple ways to open Visual Studio code up in our Linux environment.

3534
06:08:52.268 --> 06:08:57.506
One way is you're gonna hit Ctrl, Shift P and type WsL.

3535
06:08:57.506 --> 06:09:09.033
And then click remote WsL new WsL window, and you'll get a new window that looks like this, you can also click the bottom left and choose New WsL window.

3536
06:09:09.033 --> 06:09:16.627
Now if we go to our terminal and hit new terminal, we'll be dropped into a bash shell and we can run Linux commands in here.

3537
06:09:16.627 --> 06:09:17.002
Awesome.

3538
06:09:17.002 --> 06:09:34.930
Another way we can open up Visual Studio code with WsL on is we can go into our your boon to application, we can make a folder by typing MK dir folder, we'll CD or change directory into folder and type code period.

3539
06:09:34.930 --> 06:09:37.833
We'll go ahead and trust the authors in here.

3540
06:09:37.833 --> 06:09:43.144
And this will open up Visual Studio code already connected to the folder that we're in.

3541
06:09:43.144 --> 06:09:50.368
And we can create files in this folder like hi dot txt, and those will get created inside the folder in our WsL.

3542
06:09:50.368 --> 06:09:55.792
Now that we're inside our WsL environment, you'll notice that node dash dash version doesn't work anymore.

3543
06:09:55.792 --> 06:10:02.158
That's because we installed it on our regular Windows machine and not on our WsL or Linux environment.

3544
06:10:02.158 --> 06:10:16.471
The reason we installed it on a Windows environment first is that just in case you wanted to go ahead and use PowerShell or user Windows environment to run everything you still can just remember if you use the Windows environment and PowerShell all the commands that we use might not work for you.

3545
06:10:16.471 --> 06:10:20.877
So we're gonna go ahead and install Node js on our Linux environment.

3546
06:10:20.877 --> 06:10:25.793
Now, all the commands that we're going to write are going to be in the GitHub repo associated with this course.

3547
06:10:25.793 --> 06:10:43.879
We're going to do a curl command to the nvm repository, which stands for node version manager.

3548
06:10:44.222 --> 06:10:46.958
And we're going to pipe the install script into bash.

3549
06:10:47.222 --> 06:10:50.254
this will go ahead and install and VM.

3550
06:10:52.222 --> 06:10:56.156
ahead and trash the terminal, and then reopen it.

3551
06:10:57.222 --> 06:11:02.643
can type MBM dash dash version to see if it actually installed correctly.

3552
06:11:02.643 --> 06:11:07.189
Once we've installed nvm, we can go ahead and install no GS using nvm.

3553
06:11:07.189 --> 06:11:13.323
Just type npm install, and we'll do 16 point 14.

3554
06:11:13.323 --> 06:11:17.510
2 Is that same long term support version we installed on our Windows machine.

3555
06:11:17.510 --> 06:11:21.641
Once we have it installed, we can type in Node dash S version.

3556
06:11:21.641 --> 06:11:23.705
And now we have no JS installed.

3557
06:11:23.705 --> 06:11:27.842
Now I know there was a lot here, but if you made it this far, this is fantastic.

3558
06:11:27.842 --> 06:11:34.923
You've done a great job to push through to this point and get everything set up so you can code in the best environment there is.

3559
06:11:34.923 --> 06:11:37.040
So if you've made it this far, huge congratulations.

3560
06:11:37.040 --> 06:11:39.933
Now the next thing that we're going to install is Git.

3561
06:11:39.933 --> 06:11:42.555
And now we're not going to use Git for this lesson.

3562
06:11:42.555 --> 06:11:45.643
However, we will definitely be using it in the future.

3563
06:11:45.643 --> 06:11:54.003
See if gets installed type git dash dash version, sometimes Linux will automatically come with Git installed and you'll see something output like this.

3564
06:11:54.003 --> 06:11:57.770
If you don't have Git, we can just look up the get install.

3565
06:11:57.770 --> 06:12:00.205
Which again, link to this is in the description.

3566
06:12:00.205 --> 06:12:03.399
And you'll actually run the installing on Linux.

3567
06:12:03.399 --> 06:12:23.256
Now again, now if you want to use PowerShell, and you want to do everything with Windows, you can absolutely follow the installing on Windows instructions here instead, when you're working in WsL, you'll want to use the Linux commands instead of the windows commands even though you're on a Windows because WsL makes it so that you're basically running in a Linux environment.

3568
06:12:23.256 --> 06:12:32.303
And now if you've made it this far, you should be able to follow along with the Mac and Linux instructions as if you're running on a Mac and Linux even though you're running on Windows.

3569
06:12:32.303 --> 06:12:38.699
Just be sure that whenever you're in your VS code, you take a look at the bottom left and make sure you're on WsL Ubuntu.

3570
06:12:38.699 --> 06:12:43.651
Like I said before, if you want to run in PowerShell, or in a Windows environment, you're more than free to do so.

3571
06:12:43.651 --> 06:12:49.348
But like I said, if you've made it this far, huge congratulations.

3572
06:12:49.348 --> 06:12:50.973
Awesome work.

3573
06:12:51.223 --> 06:12:56.328
And then finally, our last setup is going to be using a tool called Git pod starting from Lesson five.

3574
06:12:56.328 --> 06:13:07.623
The lesson that we're on right now, ethers, jazz, simple storage, all of our code repos are going to come with a button in the repo scroll down, they'll come with this open in get pod button.

3575
06:13:07.623 --> 06:13:24.129
Now git pod is a cloud development environment where you can actually run your code on a remote server, it's kind of similar to remix IDE, but it allows you to run Visual Studio code in the browser or connected to another server.

3576
06:13:24.129 --> 06:13:28.175
This is good because then you don't have to do any installation on anything.

3577
06:13:28.223 --> 06:13:32.626
Since all the tools that you can want to use are just going to be running on this remote server.

3578
06:13:32.626 --> 06:13:39.968
This has its downsides, though, obviously, since you'll only be able to code if git pod is up and working for you.

3579
06:13:39.968 --> 06:13:48.090
Additionally, when it comes to private keys, you absolutely do not want to run any code with a private key that has real money in good pop.

3580
06:13:48.090 --> 06:13:56.452
Why? Well, once again, since you're running your scripts on a remote server, those servers have access to your private keys.

3581
06:13:56.452 --> 06:14:04.601
But since you've Pinky promise that for this course, you're not going to be using a meta mask or a private key with actual money in it, it should be fine.

3582
06:14:04.601 --> 06:14:09.890
The other downside is that these often cost money to use and get pot isn't free.

3583
06:14:09.890 --> 06:14:14.974
But it's an option if you absolutely cannot get any of the installation working.

3584
06:14:14.974 --> 06:14:19.465
So if you go ahead and you hit this opening get pod button, you'll get a welcome to get pods showing up.

3585
06:14:19.465 --> 06:14:21.851
We're gonna go ahead and continue with GitHub.

3586
06:14:21.851 --> 06:14:28.094
Since you've signed up for GitHub here, you want to go ahead and authorize get pod.

3587
06:14:28.094 --> 06:14:31.613
And it'll go ahead and start creating this workspace for you.

3588
06:14:31.613 --> 06:14:35.581
And you'll notice it looks exactly like Visual Studio Code.

3589
06:14:35.581 --> 06:14:46.366
Since I opened the repo up in Git pod, it came with all the code, and you can even open this workspace up in VS code desktop.

3590
06:14:46.366 --> 06:14:49.112
So this is might be a little bit confusing.

3591
06:14:49.112 --> 06:14:54.156
But basically, you can run off of Git pod using your local Visual Studio code.

3592
06:14:54.224 --> 06:14:58.288
And if you see git pod here, that's how you know that you're running off of Git pod.

3593
06:14:58.288 --> 06:15:03.896
If you see this pop up, do you want to open this workspace in VS code desktop, you can hit Open.

3594
06:15:03.896 --> 06:15:09.351
And it'll ask you if you want to open up Visual Studio Code, which I'm going to go ahead and hit yes.

3595
06:15:09.351 --> 06:15:13.172
And you'll get something that looks like this on your Visual Studio Code.

3596
06:15:13.224 --> 06:15:18.128
It'll tell you that it wants to install the Git pod extension, and then open that Git pod URL.

3597
06:15:18.128 --> 06:15:20.382
So you can go ahead and install it.

3598
06:15:20.382 --> 06:15:27.782
Reload window and open and it's going to go ahead and start connecting to our the Git pod workspace.

3599
06:15:27.782 --> 06:15:33.257
And this is going to be the same as running git pod in the browser here.

3600
06:15:33.257 --> 06:15:45.431
Or you can also do it manually by hitting the Git pod in the bottom left, and then type in open in VS code And then you should be able to run it in your Visual Studio code.

3601
06:15:45.431 --> 06:15:54.172
For now, I'm going to recommend that if you're using Git pod, just stay in the browser, just so that you know, okay, I am running this on a remote server.

3602
06:15:54.172 --> 06:15:58.917
And just as a reminder for you that you're not actually locally developing.

3603
06:15:58.917 --> 06:16:04.325
And hopefully, this will be a trigger to not actually put any special private keys or anything like that.

3604
06:16:04.325 --> 06:16:12.356
But you can make workspaces, you can make new folders, and you should be able to run all the commands on here, as if you are running locally with Visual Studio code.

3605
06:16:12.356 --> 06:16:29.891
To open up the terminal, you can hit this little bar at the top left, go to terminal, new terminal, or use CTRL tilde exact same as Mac OS and Linux keyboard shortcuts to create a new folder, we can change directory, CD, dot.

3606
06:16:29.891 --> 06:16:36.510
mk, dir, new folder, MK dir makes make directory called New Folder.

3607
06:16:36.510 --> 06:16:40.275
And then we're going to change our directory into a new folder, and hit enter.

3608
06:16:40.275 --> 06:16:41.925
And now we're in that new folder.

3609
06:16:41.925 --> 06:16:52.015
For each section, you can either open up the entire source code right into GitHub, or you can create a new folder for each section yourself and start from blank.

3610
06:16:52.015 --> 06:16:55.470
And then you would just type code period.

3611
06:16:55.470 --> 06:17:00.382
And you'd be in a brand new folder.

3612
06:17:00.382 --> 06:17:02.405
All right, this is fantastic.

3613
06:17:02.405 --> 06:17:07.446
At this point, you should be set up with Visual Studio Code no Jas and get.

3614
06:17:07.446 --> 06:17:18.692
And I'm going to be working out of a folder called Hard Hat Free Code Camp at this point, you should have node, dash dash version, get dash dash version.

3615
06:17:18.692 --> 06:17:24.484
And if you're using Windows, this should say WsL or your boon to or something like that.

3616
06:17:24.484 --> 06:17:27.603
And if you have all that, that means we're ready to go.

3617
06:17:27.603 --> 06:17:30.601
Now a quick note something that you'll see me do a lot.

3618
06:17:30.601 --> 06:17:32.351
And you can do this as well.

3619
06:17:32.351 --> 06:17:38.838
Oftentimes, when my terminal gets really, really big, or there's a ton of commands in here gets a little bit overwhelming for me.

3620
06:17:38.838 --> 06:17:42.851
So one thing that you can do is you can type clear, and hit Enter to clear it.

3621
06:17:42.851 --> 06:17:54.506
Or what you can do is you can hit Command K, if you're on a Mac, or Ctrl K, if you're on a Linux or a Windows, and it's one of my favorite keyboard shortcuts that I use all the time.

3622
06:17:54.506 --> 06:17:58.816
Additionally, the trash can and the X here are very different.

3623
06:17:58.816 --> 06:18:12.419
If I go to a couple of enters here, and we're down here, if I hit the trashcan, and then pull my terminal back up, by doing the toggle, or by doing terminal new terminal, you'll see all those lines are still here.

3624
06:18:12.419 --> 06:18:21.444
But if I hit the trashcan, and then pull the terminal back up, you'll see it actually refreshes mine a special command that prints stuff out.

3625
06:18:21.444 --> 06:18:26.766
trashing your terminal is basically deleting whatever's running in it, and the x is just hiding it.

3626
06:18:26.766 --> 06:18:35.476
And as hitting Ctrl tilde or toggling our terminal or whatever command it is on your environment, that's equivalent to hitting the hide, not the trash.

3627
06:18:35.476 --> 06:18:41.129
So if we want to remove and start a terminal over, we hit the trashcan, and then we pull it back up.

3628
06:18:41.129 --> 06:18:43.401
Alright, so now we're gonna start working with ethers.

3629
06:18:43.401 --> 06:18:51.648
And we're going to start learning to code, our transactions and our contract deployments and everything programmatically at a relatively low level.

3630
06:18:51.648 --> 06:18:56.872
And we're gonna learn how to deploy and interact with the contracts using the ethers JS package.

3631
06:18:56.872 --> 06:19:04.805
Now to get started, I'm going to recommend you create a folder where you're going to put all of your projects in it, I'm going to create a new directory called H H.

3632
06:19:04.805 --> 06:19:08.735
hyphen, FCC, which stands for hard hat Free Code Camp.

3633
06:19:08.735 --> 06:19:12.209
And once we run that command, we can cd into hh FCC.

3634
06:19:12.209 --> 06:19:19.040
And this is where we'll create all of our projects for this course moving forward, so that we have them all in one place.

3635
06:19:19.040 --> 06:19:24.744
Now to get started, whenever you create a new project, you always want to create a new folder.

3636
06:19:24.744 --> 06:19:33.602
So to create a new folder, we're going to do MK dir, and we're going to call this ethers, simple storage, like that.

3637
06:19:33.602 --> 06:19:42.001
And now, if you type ls, you'll see that there is one folder named ethers, simple storage.

3638
06:19:42.001 --> 06:19:45.948
ls is how you list all the contents of your folder.

3639
06:19:45.948 --> 06:19:52.560
You might have a lot of other folders in here, I only have the one since I created this new folder for this.

3640
06:19:52.560 --> 06:19:57.060
Now what you can do, you can type code, ethers simple.

3641
06:19:57.227 --> 06:20:00.893
And then if you hit tab, it should autocomplete for you.

3642
06:20:01.227 --> 06:20:08.443
if you enter, Visual Studio code should open up a new Visual Studio code for you.

3643
06:20:08.443 --> 06:20:20.164
That is inside of either simple storage if you open up your terminal now, your home directory for this workspace is going to be through simple storage as this is what pops up.

3644
06:20:20.164 --> 06:20:32.978
If that doesn't work for you, we can also do is you can hit File, Open folder and then open the folder that you just created or that you want to open this again we'll open up VS code.

3645
06:20:32.978 --> 06:20:36.679
And if we open up our terminal we see we're inside of ether simple storage.

3646
06:20:36.679 --> 06:20:47.007
This is so powerful because as we create files we'll be able to See those files in our Explorer here, this button here stands for the Explorer.

3647
06:20:47.007 --> 06:20:49.728
If we click it, we can see the different files in here.

3648
06:20:49.728 --> 06:20:55.024
And I'm going to go ahead and actually delete this file dot txt, because we're not actually going to use that.

3649
06:20:55.024 --> 06:21:00.478
Now it's this part of the course, where we're actually going to start jumping into some JavaScript.

3650
06:21:00.478 --> 06:21:06.243
Since this course is in JavaScript course, if you're unfamiliar with JavaScript, it might be a little bit tricky.

3651
06:21:06.243 --> 06:21:15.024
If you want to come into this with a better understanding of JavaScript and Node js, there is a Free Code Camp YouTube video teaching No, Jas for beginners.

3652
06:21:15.024 --> 06:21:18.600
And a link to this will be in the GitHub repo associated with this course.

3653
06:21:18.600 --> 06:21:27.143
There's also a JavaScript Free Code Camp video that I'm also going to put in the description for this course, keep in mind that JavaScript and Node js are slightly different.

3654
06:21:27.143 --> 06:21:31.543
And we are going to go over some of the differences as we code along here.

3655
06:21:31.543 --> 06:21:35.482
But for the most part, learning one means you've learned the majority of the other.

3656
06:21:35.482 --> 06:21:45.389
So if you want to pause and go through these videos, before continuing here, please feel free to do so you don't have to, you can absolutely continue on with the course as is.

3657
06:21:45.389 --> 06:21:53.299
And if you get confused or stuck on some JavaScript piece, feel free to pause, Google it and come back.

3658
06:21:53.299 --> 06:21:56.634
But just to reiterate, you can check out the JavaScript programming full course.

3659
06:21:56.634 --> 06:22:01.123
And also the Node js full course, as those are both going to help you.

3660
06:22:01.123 --> 06:22:04.704
Like I was saying before, Node js is a JavaScript runtime.

3661
06:22:04.704 --> 06:22:07.244
So it's not exactly JavaScript.

3662
06:22:07.244 --> 06:22:09.652
But we're going to write our code in JavaScript.

3663
06:22:09.652 --> 06:22:13.295
And if that's confusing, just don't worry about it right now.

3664
06:22:13.295 --> 06:22:17.179
And as we go through this course, I'll show you where the differences are.

3665
06:22:17.229 --> 06:22:21.196
But basically, you can think of no Jas and JavaScript kind of being the same thing.

3666
06:22:21.196 --> 06:22:37.432
The big thing about Node js is it allows us to write JavaScript code in the back end, as opposed to running JavaScript on the front end, JavaScript is made to be a browser run language, like running inside of, you know, Chrome, brave Firefox, etc.

3667
06:22:37.432 --> 06:22:50.361
No, Jas allows it to become a a scripting language, a back end language, which is why the syntax between the front end JavaScript and the back end JavaScript or the no JS JavaScript are going to be a little bit different.

3668
06:22:50.361 --> 06:22:58.562
Additionally, as we go along in this code, if you're familiar with TypeScript, all of our code is going to come with a TypeScript edition.

3669
06:22:58.562 --> 06:23:02.916
TypeScript is what's known as a statically typed version of JavaScript.

3670
06:23:02.916 --> 06:23:04.229
And it'll be it'll be this one.

3671
06:23:04.229 --> 06:23:06.176
It'll be TypeScript, not TypeScript edition.

3672
06:23:06.176 --> 06:23:09.671
I'll go ahead and fix that and remove this one to make it clear.

3673
06:23:09.671 --> 06:23:15.284
TypeScript is a type safe version of JavaScript, which is that's confusing, don't worry too much about that.

3674
06:23:15.284 --> 06:23:18.479
But we are going to do all of our programming in JavaScript.

3675
06:23:18.479 --> 06:23:22.193
And then if the code is different enough, I'll show you how to do it in TypeScript as well.

3676
06:23:22.229 --> 06:23:27.179
However, for most of them, we're not going to show you the TypeScript editions, because it's going to be really similar.

3677
06:23:27.229 --> 06:23:31.210
But you can always refer back to the GitHub repository to see all the code for the TypeScript.

3678
06:23:31.210 --> 06:23:39.454
Now, if you're new to this space, I actually do recommend you go ahead and start with JavaScript and learn how to do TypeScript later on.

3679
06:23:39.454 --> 06:23:46.656
TypeScript actually catches bugs early on, making it a lot easier to code your projects in the long run.

3680
06:23:46.656 --> 06:23:49.016
However, it does take a lot of extra typing.

3681
06:23:49.016 --> 06:24:00.296
And it can be a little bit frustrating learning how types work for beginners, JavaScript is a little bit more loose as a language and lets us kind of do whatever we want, but it can cause a headache later on.

3682
06:24:00.296 --> 06:24:07.404
So if you do run into some issues, and you do run into some bugs, it might be a good idea to try TypeScript on for size, and see how that fares.

3683
06:24:07.404 --> 06:24:07.721
Well.

3684
06:24:07.721 --> 06:24:15.066
Let's go ahead and begin working on our local development environment and getting set up to do everything in ethers Jas and in JavaScript.

3685
06:24:15.066 --> 06:24:15.311
Oops.

3686
06:24:15.311 --> 06:24:20.508
And I actually went and renamed this folder to ether symbol storage dash, FCC.

3687
06:24:20.508 --> 06:24:33.176
Reason I added this dash FCC is all the GitHub repositories associated with this course, all the GitHub repos that have this dash FCC to know that it is part of this hard hat JavaScript course.

3688
06:24:33.230 --> 06:24:33.574
Awesome.

3689
06:24:33.574 --> 06:24:34.262
Let's jump in.

3690
06:24:36.230 --> 06:24:41.941
our smart contracts locally in Visual Studio code, as you can probably tell by the name of this folder.

3691
06:24:41.941 --> 06:24:51.145
And of course, if you looked at the code, this project is going to be our simple storage project, but developed locally using ethers.

3692
06:24:52.230 --> 06:24:55.134
So the first thing that we want to do is want to get in that smart contract code.

3693
06:24:55.134 --> 06:25:05.515
So what we can do is make sure we have the Explorer selected, we can go ahead and right click and select new file and do simple storage.

3694
06:25:05.515 --> 06:25:09.372
So just close this for now.

3695
06:25:09.372 --> 06:25:15.134
And we can copy paste our simple storage code from our last section into VS code.

3696
06:25:15.230 --> 06:25:31.357
If you closed remix or you forgot where it is, you can just go to the ethers simple storage FCC repo, it's simple storage dot Sol, and we can just copy all the code in here and then come back over select Symbol storage that Saul and paste it in.

3697
06:25:31.357 --> 06:25:36.955
Now an important note about Visual Studio code is that when you see this little white.

3698
06:25:36.955 --> 06:25:42.476
up here, it means that this file isn't saved to save your Git file.

3699
06:25:42.476 --> 06:25:46.061
To save, and it'll go away like that.

3700
06:25:46.061 --> 06:25:54.867
Or what you can do is you can hit command S or Ctrl S, depending on if you're on a Windows, Mac, or Linux.

3701
06:25:54.867 --> 06:26:02.967
Now you'll see here that this code is a little bit hard to read the simple storage dot salt, it doesn't have the syntax highlighting that we saw in remix.

3702
06:26:02.967 --> 06:26:08.821
So we want to go ahead and add a Visual Studio Code extension to give this syntax highlighting.

3703
06:26:08.821 --> 06:26:12.198
So what we can do is come over to this bar over here looks like this.

3704
06:26:12.198 --> 06:26:17.427
And if you don't see it on the left hand bar, you should click these three dots, and it should be in here.

3705
06:26:17.427 --> 06:26:19.394
But we'll go ahead and click Extensions.

3706
06:26:19.394 --> 06:26:27.118
And what we're going to do is we're going to look up, solidity plus hard hat.

3707
06:26:27.231 --> 06:26:30.923
And we're going to install this solidity plus hard hat extension.

3708
06:26:30.923 --> 06:26:31.846
For VS code.

3709
06:26:31.846 --> 06:26:39.972
Now that we have this installed, if we go back over to our simple storage dot sole, you'll see that all the highlighting is back in.

3710
06:26:39.972 --> 06:26:42.101
And now it's much easier to read.

3711
06:26:42.231 --> 06:26:43.331
Right? So this is good.

3712
06:26:45.231 --> 06:26:46.437
syntax highlighting.

3713
06:26:49.231 --> 06:26:53.378
format or right now our code is pretty good with the way that it's formatted.

3714
06:26:53.378 --> 06:27:07.982
But what if we, we accidentally do some stuff like this or like this, or maybe even like this, we add a ton of new lines, etc, our code can start to look pretty gross.

3715
06:27:07.982 --> 06:27:15.782
And even though the code itself is fine, and it'll run the exact same way, with all this extra whitespace, it doesn't look very good, right.

3716
06:27:15.782 --> 06:27:18.485
And due to that, it can be a little bit hard to read.

3717
06:27:18.485 --> 06:27:37.294
What we want to do, then, we want to open up our settings and adjust our vias code so that it auto formats whenever we save, so whenever we save, so that whenever it goes from the little white dot here to no white dot, this whole thing gets automatically formatted to some looks really nice.

3718
06:27:37.294 --> 06:27:37.606
Okay.

3719
06:27:37.606 --> 06:27:48.854
So what we can do is we can open up our command palette to open up our command palette, you can hit View command palette, and we'll get a little pop up that looks like this.

3720
06:27:48.854 --> 06:27:57.565
Another way to open up your command palette is you're gonna hit Command, Shift P, or Ctrl, Shift P, depending on your Mac, or Linux or Windows.

3721
06:27:57.565 --> 06:28:04.544
And what we want to do is we want to type in settings, and we're going to open Settings JSON, we don't want to open the default settings JSON.

3722
06:28:04.544 --> 06:28:06.356
We don't want to touch these.

3723
06:28:06.356 --> 06:28:08.595
But we want to open our JSON settings.

3724
06:28:08.595 --> 06:28:12.062
You'll also notice there are user settings and workspace settings.

3725
06:28:12.062 --> 06:28:14.216
These are pieces that we can adjust as well.

3726
06:28:14.216 --> 06:28:17.113
But we're going to just go right into the JSON settings.

3727
06:28:17.113 --> 06:28:21.215
So So I already have some stuff in here, but yours might be blank.

3728
06:28:21.215 --> 06:28:23.365
Or you might have some stuff in here as well.

3729
06:28:23.365 --> 06:28:31.306
So what we're going to do is if you have stuff in here already, we're going to add a comma, then we're going to do quotes, solidity.

3730
06:28:31.306 --> 06:28:38.062
Close the brackets, we're gonna do a little colon and something like this.

3731
06:28:38.062 --> 06:28:41.763
This means that we're going to apply some settings to our Visual Studio Code.

3732
06:28:41.763 --> 06:28:50.741
Whenever we're working with solidity, one of the things we're going to add in here is going to be an editor, Doc's default, for matter.

3733
06:28:50.741 --> 06:29:05.333
And you might even get a pop up that tells you some different things that we can use for a default format or our default format, or is going to be Nanak, foundation, dot hard hat, hyphens solidity.

3734
06:29:05.333 --> 06:29:23.299
This will mean that any time we go to format our code, it'll use the hard hat solidity plug in, as its default format, or the hard hat solidity plugin comes with some formatting, and a lot of other really useful tools for us writing our code.

3735
06:29:23.299 --> 06:29:28.483
So now that we have this part in, the next thing we're going to do is add format on Save.

3736
06:29:28.483 --> 06:29:36.483
If we haven't already, we could add it in here in our JSON, but I'm going to add it not in the JSON file, I'm going to add it in the overall file.

3737
06:29:36.483 --> 06:29:47.741
So if we open that command palette back up, and we type in settings, open user settings, this is another really good place where we can look in add settings with the UI.

3738
06:29:47.741 --> 06:29:49.939
So these two do essentially the same thing.

3739
06:29:49.939 --> 06:29:56.448
It's just that this one has dials and a little bit more context versus settings that JSON just says Okay, give me the raw code for it.

3740
06:29:56.448 --> 06:29:57.958
This tells us a little bit more.

3741
06:29:57.958 --> 06:29:59.216
So you can use either one.

3742
06:29:59.216 --> 06:30:02.414
But we're going to look for format, on save.

3743
06:30:02.414 --> 06:30:07.200
And you're going to want this checked if you haven't already.

3744
06:30:07.200 --> 06:30:13.587
This means that every time we save VS code is going to try to format our code for us.

3745
06:30:13.587 --> 06:30:16.200
So now that we have this checked, we have settings dot JSON added in.

3746
06:30:16.233 --> 06:30:17.905
And remember, we want to save this.

3747
06:30:19.233 --> 06:30:20.686
white dot, that means not saved.

3748
06:30:22.233 --> 06:30:22.995
and close it out.

3749
06:30:22.995 --> 06:30:24.233
Let me close this out too.

3750
06:30:25.234 --> 06:30:31.807
here and we add a bunch of random new spaces or whatever, you want to make it look a little bit ugly, and then we save it.

3751
06:30:31.807 --> 06:30:36.618
It should automatically reformat to look much nicer, right.

3752
06:30:36.618 --> 06:30:46.487
So if we do something like this, we'd save it reformats it to look much nicer this one make them more readable for you, and more readable for anybody else who looks at your code.

3753
06:30:46.487 --> 06:30:48.137
And it's just really nice.

3754
06:30:48.137 --> 06:30:54.524
And this line of code for your settings dot JSON is located in the full blockchain study course.

3755
06:30:54.524 --> 06:30:54.620
js.

3756
06:30:54.620 --> 06:31:03.141
So you can also just copy paste it, we are going to end up overriding that default format or with another format are called prettier pretty soon.

3757
06:31:03.141 --> 06:31:12.796
But it's great to have a default format or so that if you don't feel like adding the prettier code sometime in the future, you can just rely on your default formatter.

3758
06:31:12.796 --> 06:31:13.296
Awesome.

3759
06:31:13.296 --> 06:31:18.537
While we're doing formatting, let's also add a default format or for our JavaScript code.

3760
06:31:18.537 --> 06:31:24.055
And just to test it out, let's go ahead and create our new file, we'll call it deploy dot Jas.

3761
06:31:24.055 --> 06:31:39.602
And in here, we can do something like function Hi, console dot log, hi, and then just add and then just make it look kind of gross, maybe something like this.

3762
06:31:39.602 --> 06:31:50.027
If you hit save, and it does some auto formatting, that's great, you can actually turn that off by going back to your command palette, and saying, Save without formatting.

3763
06:31:50.027 --> 06:31:53.122
And that way it will be saved and not formatted.

3764
06:31:53.122 --> 06:32:00.332
The way we can add some other formatting here is we're gonna install another extension, this one is going to be called prettier.

3765
06:32:00.332 --> 06:32:03.355
So we can just look up prettier and extensions here.

3766
06:32:03.355 --> 06:32:06.924
And you'll want to install this prettier code formatter.

3767
06:32:06.924 --> 06:32:09.480
So we're gonna go ahead and install this.

3768
06:32:09.480 --> 06:32:18.178
And great, now it's installed prettier is a form is a code format, or that works for many languages like Python, JavaScript, and even solidity.

3769
06:32:19.235 --> 06:32:22.806
And pretty soon we're going to use prettier for both JavaScript and solidity.

3770
06:32:22.806 --> 06:32:31.850
But for now, we're just going to use prettier for JavaScript, we can enable this by opening back up our command palette, we'll go to preferences, open Settings.

3771
06:32:31.850 --> 06:32:37.735
And the same way we added a solidity section, we're going to add a JavaScript section.

3772
06:32:37.735 --> 06:32:47.328
So we're going to add a comma here, some quotes, brackets, we're going to type in JavaScript, close that colon brackets.

3773
06:32:47.328 --> 06:32:53.936
And we're going to do the same thing at the door dot default, or matter.

3774
06:32:53.936 --> 06:33:04.520
Net we're going to do and then in here, we're going to do e s BENP, that prettier, hyphen VS code.

3775
06:33:04.520 --> 06:33:08.718
And this will make prettier the default editor for JavaScript.

3776
06:33:08.718 --> 06:33:14.922
Now, like I said, pretty soon, we're going to have prettier override both of these for solidity and JavaScript.

3777
06:33:14.922 --> 06:33:21.703
And we're going to give prettier some parameters so that no matter who uses your code, they will always have the exact same formatting.

3778
06:33:21.703 --> 06:33:32.828
But now that we have prettier in here as the default editor, if we come back to deploy dot j s, and we hit save, it should format to look a little something like this.

3779
06:33:32.828 --> 06:33:35.156
Now, we go ahead and we do something like this.

3780
06:33:35.156 --> 06:33:39.510
If we go ahead and do something like this, it'll reformat to look like look like that.

3781
06:33:39.510 --> 06:33:57.586
And then additionally, if you want to go back to the command palette, open user settings, not in JSON mode, and we go to default format, or you can actually even select the default format or for all languages, if you want to use prettier for all formatters.

3782
06:33:57.586 --> 06:33:58.686
Feel free to go ahead.

3783
06:33:58.686 --> 06:34:07.093
Alright, great, got our JavaScript format, or in as well, let's start writing some JavaScript code.

3784
06:34:07.236 --> 06:34:07.569
Awesome.

3785
06:34:10.236 --> 06:34:15.155
to learn how to actually deploy our contract using JavaScript.

3786
06:34:15.236 --> 06:34:26.558
This is going to teach us a lot about transactions and what's going on under the hood, and even what's going on under the hood in remix, and remix, we usually just hit a compile button, and then hit a Deploy button.

3787
06:34:26.558 --> 06:34:27.912
And that's really it.

3788
06:34:27.912 --> 06:34:32.410
In JavaScript, we're actually going to create our own functions that are going to help us do both of those.

3789
06:34:32.410 --> 06:34:38.684
And as I mentioned, this is the part of the course we're going to start working with JavaScript, and optionally, TypeScript if you like.

3790
06:34:38.684 --> 06:34:42.628
Like I said, all of these sections come with a TypeScript edition as well.

3791
06:34:42.628 --> 06:34:49.460
So let's set up our deployed out js script to actually deploy our simple storage dot soul.

3792
06:34:49.460 --> 06:34:55.202
So how can we get started here? Well, let's first learn how to run a script using JavaScript and Node J S.

3793
06:34:55.202 --> 06:35:02.541
So if you want to do a print line, or just print something out to your terminal, we can do something called a console dot log.

3794
06:35:02.541 --> 06:35:06.104
And if I do console dot log, hi, I hit Save.

3795
06:35:06.104 --> 06:35:08.661
And I open up my terminal.

3796
06:35:08.661 --> 06:35:11.267
I can now run Node deploy.

3797
06:35:11.267 --> 06:35:11.454
js.

3798
06:35:11.454 --> 06:35:20.611
And it'll print out high node is how we say hey, we want to run this JavaScript code using Node js.

3799
06:35:20.611 --> 06:35:30.799
Other languages you might be familiar with, sometimes we'll do Python, you know, deployed up py, or Java, C deploy dot Java, you know, etc.

3800
06:35:30.799 --> 06:35:35.362
But with JavaScript, since the front end and back end JavaScript are different.

3801
06:35:35.362 --> 06:35:37.143
We run code on the back end with node.

3802
06:35:37.237 --> 06:35:43.665
And with JavaScript, you can do a lot of things that you'd see in something like solidity with a little bit looser have a structure.

3803
06:35:43.665 --> 06:35:54.537
If I wanted to create some variable, I could say let variable equals five, this kind of similar into solidity like you and 256, variable equals five.

3804
06:35:54.537 --> 06:35:58.503
But in JavaScript, we use let or var or const.

3805
06:35:58.503 --> 06:36:03.862
And then I can print this out, I can do console dot log variable.

3806
06:36:03.862 --> 06:36:10.808
And I had saved JavaScript is optional on whether or not you actually want to have semicolons.

3807
06:36:10.808 --> 06:36:13.658
Here, I think prettier, defaults to putting semicolons.

3808
06:36:13.658 --> 06:36:16.926
And we'll get rid of those in the near future in your terminal.

3809
06:36:16.926 --> 06:36:32.253
Once you start typing the name of a file, if you hit tab, it could autocomplete the rest of the file name for you node deploy hit Tab, it'll autocomplete and if we hit enter, now, we get Hi, and then we get five.

3810
06:36:32.253 --> 06:36:35.086
Since this prints out Hi, and then it prints out five.

3811
06:36:35.086 --> 06:36:39.605
JavaScript automatically starts with whatever code you have at the top of the file.

3812
06:36:39.605 --> 06:36:42.058
So it does console dot log first and variable.

3813
06:36:42.058 --> 06:36:43.499
And then this one as well.

3814
06:36:43.499 --> 06:36:51.753
However, a good practice is to actually wrap everything you want to do in a main function, and then run that main function.

3815
06:36:51.753 --> 06:37:04.786
But what we could do is up at the top here, we'd say function, mean, add parentheses and some brackets, a closing bracket at the bottom, and hit save for its auto format.

3816
06:37:04.786 --> 06:37:10.134
Right now, if we run this, nothing will happen, because we've wrapped all of our code in a main function.

3817
06:37:10.134 --> 06:37:17.830
So if I run it now node deployed to Jess, nothing happens, because I need something to call the main function.

3818
06:37:17.830 --> 06:37:29.134
So if I then take this, this main function down here, and I call main, our jobs from code is actually going to say, ah, the first line of the script is actually this main function here.

3819
06:37:29.134 --> 06:37:33.452
So now if I do node deploy dot j, s, it'll run high and five, which is what we want.

3820
06:37:33.452 --> 06:37:42.641
Now, this is going to be the setup for most of our scripts moving forward, including the scripts that we write, when we get to hard hat, however, there is going to be one major difference.

3821
06:37:42.641 --> 06:37:47.983
Instead of regular functions, we're actually going to use something called async functions.

3822
06:37:47.983 --> 06:37:50.872
And we're going to do something called asynchronous programming to do this.

3823
06:37:50.872 --> 06:37:59.303
Now, if what I say next is really confusing for you don't let it slow you down, feel free to go ahead and watch that JavaScript course to learn more about this.

3824
06:37:59.303 --> 06:38:02.113
But I'll also let you know, hey, this is an async function.

3825
06:38:02.113 --> 06:38:06.009
Here's what we need to be aware of when working with it, okay.

3826
06:38:06.009 --> 06:38:17.438
But I do want to give you a quick bit background on asynchronous programming.

3827
06:38:17.438 --> 06:38:20.531
So far, the programming that we've done has been synchronous.

3828
06:38:20.531 --> 06:38:27.017
And solidity is an example of a programming language, that synchronous, Synchronous means it just goes one line after another.

3829
06:38:27.017 --> 06:38:34.145
If our code looks like this, this is synchronous write, our main function is the first thing that actually gets called.

3830
06:38:34.145 --> 06:38:37.721
Then we do console dot log, that variable equals five, and then console dot log.

3831
06:38:37.721 --> 06:38:42.566
Again, this is synchronous programming in JavaScript, all of our solidity is synchronously programmed.

3832
06:38:42.566 --> 06:38:45.273
There will be some exceptions to this when working with oracles.

3833
06:38:45.273 --> 06:38:46.972
But for now, everything is synchronous.

3834
06:38:46.972 --> 06:38:53.223
JavaScript can be asynchronous, meaning that we can actually have code running at the same time.

3835
06:38:53.223 --> 06:38:57.980
A good example I like to use to understand the difference is with cooking.

3836
06:38:57.980 --> 06:39:06.239
In synchronous programming, for cooking, you might put popcorn in microwave, wait for popcorn to finish.

3837
06:39:06.239 --> 06:39:10.294
And then, and then maybe you'll pour drinks for everyone.

3838
06:39:10.294 --> 06:39:12.317
And now this is synchronous programming.

3839
06:39:12.317 --> 06:39:18.560
Now, it might be a little bit weird for you just to put the popcorn in the microwave, and then just stare at it, waiting for it to finish.

3840
06:39:18.560 --> 06:39:25.039
And then pour the drinks, you typically can pour the drinks while your popcorn is in the microwave.

3841
06:39:25.039 --> 06:39:27.608
And this is where asynchronous programming comes in.

3842
06:39:27.608 --> 06:39:33.905
If setting up for this movie night, we're asynchronous, what you would do is you'd put popcorn in the microwave.

3843
06:39:33.905 --> 06:39:52.690
And while the popcorn is in the microwave, or drinks for everyone, and then you'd wait for popcorn finish, since there's nothing left for you to do, but it doesn't make sense for you to wait for the popcorn to finish to pour your drinks, you can just go ahead and pour the drinks right away and then wait for the popcorn to finish.

3844
06:39:52.690 --> 06:39:57.560
So asynchronous programming is way for us to do stuff without waiting around for things to finish.

3845
06:39:57.560 --> 06:40:05.192
And this is really advantageous in JavaScript by default allows us to do this asynchronous programming, however, sometimes we do want to wait for our popcorn to finish.

3846
06:40:05.239 --> 06:40:13.916
For example, if instead of just pouring drinks, maybe the next thing instead of pouring drinks was placed salt on popcorn.

3847
06:40:13.916 --> 06:40:19.489
Of course, if we want to play salt on our popcorn, we do have to wait for the popcorn to get out of the microwave.

3848
06:40:19.489 --> 06:40:27.949
So even though placing popcorn in the microwave has this wait time we need to be able to tell our code I want you to actually wait for it or No, you're good.

3849
06:40:27.949 --> 06:40:30.142
You can go on and do another task.

3850
06:40:30.142 --> 06:40:32.287
So that's kind of the difference here.

3851
06:40:32.287 --> 06:40:42.336
And I'll leave some links in the GitHub repo associated with this course to understand this a little bit better functions that have functions that come with this waiting period return something called a problem.

3852
06:40:42.336 --> 06:40:48.453
This, if put popcorn in the microwave was a function in JavaScript, it would be a promise based function.

3853
06:40:48.453 --> 06:40:52.593
A promise can be either pending, fulfilled, or rejected.

3854
06:40:52.593 --> 06:40:55.450
And this is how we know if our popcorn is done.

3855
06:40:55.450 --> 06:41:03.699
If our popcorn was a method, putting popcorn in the microwave, were a function in JavaScript, when we're waiting for the popcorn to finish, it's in a pending state.

3856
06:41:03.699 --> 06:41:07.530
When it's when the popcorn is finished, it would be fulfilled.

3857
06:41:07.530 --> 06:41:11.646
And if we aborted halfway through, and we stopped waiting, it would be rejected.

3858
06:41:11.646 --> 06:41:14.699
So putting the popcorn in the microwave returns a promise.

3859
06:41:14.699 --> 06:41:23.418
With this promise, we have to tell our code, hey, we want you to wait for the popcorn to finish or you can go ahead and you can just keep doing stuff.

3860
06:41:23.418 --> 06:41:26.324
So let's put this all together with some JavaScript syntax here.

3861
06:41:26.324 --> 06:41:29.453
Let's say again, we're going to be setting up this movie night.

3862
06:41:29.453 --> 06:41:32.840
And we need to cook popcorn, pour drinks for everybody.

3863
06:41:32.840 --> 06:41:34.879
And then we need to start a movie.

3864
06:41:34.879 --> 06:41:40.043
So let's write some pseudocode to pretend what this code would look like if this was actually a function.

3865
06:41:40.043 --> 06:41:44.128
So we create some function called setup, Movie Night.

3866
06:41:44.128 --> 06:41:49.076
And in here, we would say okay, what's the first thing we need to do? Okay, we need to cook popcorn.

3867
06:41:49.076 --> 06:41:51.306
So let's say we have some cook popcorn function.

3868
06:41:51.306 --> 06:41:56.530
So we'll say, okay, cook popcorn, then the next thing we're gonna have to do is we're gonna have to pour drinks, or drink.

3869
06:41:56.530 --> 06:41:59.755
So we'll call some pour drinks function.

3870
06:41:59.755 --> 06:42:04.944
Now here's the thing, we only want to start the movie once our popcorn has been cooked.

3871
06:42:04.944 --> 06:42:25.178
And once our drinks have been poured, so if either one of these returned a promise, so if either one of these returns a promise, like cook popcorn, for example, we would need to tell our code here to actually wait for the popcorn to finish because cook popcorn is going to be a function where we could say let status equals cook popcorn.

3872
06:42:25.241 --> 06:42:29.812
And while the popcorn is being cooked, the status is going to be ending.

3873
06:42:29.812 --> 06:42:32.923
Once the popcorn gets cooked, it'll be fulfilled.

3874
06:42:32.923 --> 06:42:36.413
If the popcorn breaks, the microwave explodes, the status would be rejected.

3875
06:42:36.413 --> 06:42:40.105
But we don't want the status to be in a pending situation.

3876
06:42:40.105 --> 06:42:44.963
Before we move on, we only want to start our movie once these two functions have completed.

3877
06:42:44.963 --> 06:42:47.885
And let's say both of these return these promises things.

3878
06:42:47.885 --> 06:42:51.174
So we need to tell our code, hey, you have to wait.

3879
06:42:51.174 --> 06:42:55.641
Or you have to wait for cook popcorn and for poor drinks to finish.

3880
06:42:55.641 --> 06:43:06.641
So what we can do now without getting too deep into the weeds on how all this works, one of the easiest things that we can do and you'll see us use this syntax quite often is we'll turn this function into an async function.

3881
06:43:06.641 --> 06:43:19.150
When our functions are async, we get access to a keyword called await the await keyword tells any promise based function to wait for that promise to be fulfilled or rejected.

3882
06:43:19.150 --> 06:43:22.553
So we say okay, we want to await for our popcorn to cook.

3883
06:43:22.553 --> 06:43:24.952
And then we want to await to pour drinks.

3884
06:43:24.952 --> 06:43:27.579
And then we can just go ahead and start the movie.

3885
06:43:27.579 --> 06:43:31.952
And we only start the movie here once these two have been completed.

3886
06:43:31.952 --> 06:43:36.241
And this is why throughout all of our code, you'll see this await keyword used a lot.

3887
06:43:36.241 --> 06:43:38.391
But it can only be used in async functions.

3888
06:43:38.391 --> 06:43:45.257
So basically, whenever you see this await keyword just now Ah, okay, the function that's being called is promise based.

3889
06:43:45.257 --> 06:43:49.487
And we don't want to move on to the next step until that function has completed.

3890
06:43:49.487 --> 06:43:53.185
So that's a little bit more about promises and asynchronous programming.

3891
06:43:53.242 --> 06:43:54.320
Hopefully, that's clear.

3892
06:43:56.242 --> 06:43:59.195
in the description to learn more about asynchronous programming.

3893
06:43:59.242 --> 06:44:04.225
The reason I wanted to go through this is because most of the functions that we're going to be working with are going to be asynchronous.

3894
06:44:04.225 --> 06:44:14.129
For example, when we deploy a contract, what do we have to do? Well, we have to wait for it to be deployed.

3895
06:44:14.242 --> 06:44:25.511
If we don't use synchronous programming, and we just leave our function main like this, what would happen is we would write some code like contract dot deploy, and we wouldn't wait for it to finish.

3896
06:44:25.511 --> 06:44:33.956
Obviously, if we don't wait for it to finish, and we try to run some code on a contract that hasn't finished deploying it, it's not going to work.

3897
06:44:33.956 --> 06:44:50.136
So we want to do this, we want to have our main function be an async function, so that we can we can wait for our contracts to deploy, we can wait for things to happen, we can wait for our popcorn to finish, we can have the flexibility to tell our code to either wait for our popcorn to finish or continue on.

3898
06:44:50.136 --> 06:44:56.209
So now that we have our main function as an async function, we're going to add some code to our main function down here.

3899
06:44:56.209 --> 06:45:00.527
And the code that's added here is some syntax for working with asynchronous functions.

3900
06:45:00.527 --> 06:45:04.258
And if this part is confusing, I'm just going to say for now, absolute, don't worry about this.

3901
06:45:04.258 --> 06:45:06.042
If you want to try to understand that later.

3902
06:45:06.042 --> 06:45:06.442
That's fine.

3903
06:45:06.442 --> 06:45:28.187
But for those who are following along, we're just going to add an add then catch air air you can follow along typing this yourself or you can just copy paste it into your code.

3904
06:45:28.243 --> 06:45:32.874
Basically what this allows us to do is we have our main function, that's an asynchronous function.

3905
06:45:32.874 --> 06:45:40.984
So when we call the main function, this is some other syntax for waiting for it to basically finish and then printing any errors it gets.

3906
06:45:40.984 --> 06:45:48.093
And that's why we do this but Again, if this big lump of code, if you're like what is going on with this big clump of code, honestly, for now, just copy paste it.

3907
06:45:48.093 --> 06:45:48.543
So great.

3908
06:45:48.543 --> 06:45:51.385
We have our asynchronous function main, we have some code.

3909
06:45:51.385 --> 06:45:56.275
And then we have this lump of code, which basically just calls our main asynchronous function.

3910
06:45:56.275 --> 06:45:56.865
Okay, great.

3911
06:45:56.865 --> 06:45:58.581
I'm gonna delete all this for now.

3912
06:45:58.581 --> 06:46:02.639
But you can still find that common in the GitHub repo associated with this course.

3913
06:46:02.639 --> 06:46:03.052
Awesome.

3914
06:46:03.052 --> 06:46:07.925
Okay, so now that we have our real basic setup, let's go ahead and start coding.

3915
06:46:07.925 --> 06:46:13.147
And if this set apart is confusing, and the async await stuff is confusing, don't worry too much about it.

3916
06:46:13.147 --> 06:46:15.354
It'll make more sense as we progress.

3917
06:46:15.354 --> 06:46:35.461
All of our code basically is going to be inside of this async function main, which is going to be our main script for deploying our simple storage dot soul store deploy script is going to replicate exactly what goes on in remix, in remix, what was the first thing that we always did? Well, the first thing that we would do is actually compile all of our code.

3918
06:46:35.461 --> 06:46:40.036
So we're going to want to compile our code in our JavaScript project as well.

3919
06:46:40.036 --> 06:46:51.293
In order for us to compile our simple storage contract, we're going to use a tool called Silk Jas, and JavaScript actually has a way to install projects directly into our setups and into our folders.

3920
06:46:51.293 --> 06:46:54.800
If we scroll down this silk Jas is exactly what we're looking for.

3921
06:46:54.800 --> 06:47:07.177
Because it has a way to compile a contract that imports other contracts via relative paths, you can see a section in this readme and most documentation will have something like this, if it's JavaScript compatible.

3922
06:47:07.177 --> 06:47:15.444
For Node js usage, it says to use the latest stable version of the solidity compiler via Node js, you can install it via NPM npm install.

3923
06:47:15.444 --> 06:47:19.340
So NPM is what's known as a package manager.

3924
06:47:19.340 --> 06:47:29.325
And we actually installed NPM just by installing no Jess, right, if we do no dash dash version, you should also be able to do NPM dash dash version.

3925
06:47:29.325 --> 06:47:32.604
Another tool that it comes with is something called core pack.

3926
06:47:32.604 --> 06:47:41.958
And you can type core pack dash dash version, now we can install with NPM using npm install silk, however, I like the yarn package manager a little bit better.

3927
06:47:41.958 --> 06:47:47.899
So we're actually going to install the yarn package manager instead to do all of our package management.

3928
06:47:47.899 --> 06:47:53.976
If you go to the installation page, the newer way to install yarn is just by running core pack enable.

3929
06:47:53.976 --> 06:47:56.604
And the older way is to install with NPM.

3930
06:47:56.604 --> 06:48:03.888
If you go ahead and run core pack enable after that finishes, you should be able to run yarn dash dash version.

3931
06:48:03.888 --> 06:48:12.163
Alternatively, you can just run NPM i dash g core pack, and then you can run core pack enable.

3932
06:48:13.244 --> 06:48:17.519
The last option you have is you can run NPM i dash g yarn.

3933
06:48:17.519 --> 06:48:20.829
This will install yarn globally for your system.

3934
06:48:20.829 --> 06:48:24.431
But this is considered the outdated way to install yarn.

3935
06:48:24.431 --> 06:48:26.767
And ideally you run core pack enable.

3936
06:48:26.767 --> 06:48:33.211
But in any case, after you run those, if you run yarn dash dash version, you should get something that looks like this.

3937
06:48:33.211 --> 06:48:39.182
Now that we have yarn, we can actually use yarn to install all of our projects, instead of NPM.

3938
06:48:39.244 --> 06:48:55.754
Back in silk Jas where it says npm install soak, we can do the yarn equivalents of NPM install sock, which is going to be yarn, add sock, this will actually go ahead and install solc to our project.

3939
06:48:55.754 --> 06:49:09.198
If we open up our folders, you'll actually see that this added a couple of different folders, it first added a package dot JSON package dot JSON is a file that tells us a lot about our project and the dependencies that it works with.

3940
06:49:09.245 --> 06:49:14.083
For example, we've installed the soap package of 0.

3941
06:49:15.245 --> 06:49:20.520
Our yarn dot lock tells us the exact version of all the different packages of our project.

3942
06:49:20.520 --> 06:49:25.800
For example, the reason this is so important too, is solc has a ton of dependencies as well.

3943
06:49:25.800 --> 06:49:32.045
So yarn dot lock tells us exactly what version of solc and all the different dependencies of solchen.

3944
06:49:32.045 --> 06:49:33.911
Any other project that we add.

3945
06:49:33.911 --> 06:49:37.402
This is autogenerated file, don't edit the file directly.

3946
06:49:37.402 --> 06:49:40.517
The final bit is we got this node modules folder.

3947
06:49:40.517 --> 06:49:52.030
This node modules folder is going to be where all the installed code that we just downloaded is, for example, if we look at node modules, we can see there's a sock folder.

3948
06:49:52.030 --> 06:49:59.174
And inside this sock folder is all the code associated with this soap package that we just installed.

3949
06:49:59.245 --> 06:50:02.122
And since we're working with zero point 8.

3950
06:50:03.245 --> 06:50:05.470
actually want to install that specific version.

3951
06:50:06.245 --> 06:50:12.770
to do yarn add solc at zero point 8.

3952
06:50:17.245 --> 06:50:20.800
see in our package dot JSON you can now see zero point 8.

3953
06:50:21.245 --> 06:50:24.245
fixed in our dependencies section for sulk.

3954
06:50:25.246 --> 06:50:28.865
can just add your salt version like yarn add zero point 8.

3955
06:50:29.246 --> 06:50:31.686
there was an issue with zero point 8.

3956
06:50:33.246 --> 06:50:34.246
point 8.

3957
06:50:36.246 --> 06:50:42.934
You can find the different releases and the different versions if you go to sulk Jas releases and then to tags Alright, great.

3958
06:50:42.934 --> 06:50:59.432
Now that we have sold, we have the ability to actually compile our contracts, we could either compile them in our code and have it automatically run whenever we hit Deploy, or, or we could compile them separately.

3959
06:50:59.432 --> 06:51:07.877
If you want to go back after this section is an example in the sculpt Jas repository that shows you how to actually compile silk right in your code.

3960
06:51:07.877 --> 06:51:12.371
We are actually going to compile them separately using a soap Jas command.

3961
06:51:12.371 --> 06:51:18.164
The yarn command is both used to install dependencies and it can be used to run scripts.

3962
06:51:18.164 --> 06:51:25.150
If you go to sulk Jas and you scroll down, it says in order to use the command line, you actually need to install it globally.

3963
06:51:25.150 --> 06:51:31.035
If you want to install this globally using yarn Global Add solc at zero point 8.

3964
06:51:31.035 --> 06:51:34.263
7 Dash fixed you can absolutely go ahead.

3965
06:51:34.263 --> 06:51:46.659
However, since we're inside of this folder here, which has the yarn dot lock the package json and the node modules yarn will be smart enough to know i You're looking for the soak in this folder.

3966
06:51:46.659 --> 06:51:56.277
So we can actually go ahead and compile our contract using yarn and solc Jess if you want to see all the different commands soak Jas allows we can just run yarn.

3967
06:51:56.277 --> 06:52:05.763
So Jas dash dash help, and you'll see it'll spit out a list of all the different options that soft Jas has.

3968
06:52:05.763 --> 06:52:14.747
You can also run yarn, so Jas dash dash version to just make sure that we're on the correct version, which is indeed zero point 8.

3969
06:52:14.747 --> 06:52:14.818
7.

3970
06:52:14.818 --> 06:52:36.358
Now to actually compile our simple storage at soul, let's run the compliation command we will run yarn, so J S, dash dash bin since we want the binary dash dash ABI since we also want the ABI dash dash include path node modules.

3971
06:52:36.358 --> 06:53:00.715
Since we want to include any contracts or files in our node modules, we aren't using any for this project, but in the future, you will need to include this dash dash include path node modules do dash dash base path of period, this period means that the base path is going to be this folder dash O period, which means we're going to output the compiled binary and ABI to this folder.

3972
06:53:00.715 --> 06:53:03.996
And then finally, simple storage dot soul.

3973
06:53:03.996 --> 06:53:10.617
Since this is the contract that we want to compile, auto completed it from simple storage to simple storage.

3974
06:53:10.617 --> 06:53:18.908
So by typing simple, and then hitting Tab, but let's go ahead and hit enter, you'll see it's running this command to compile this contract.

3975
06:53:18.908 --> 06:53:21.707
And you'll see two files get output.

3976
06:53:21.707 --> 06:53:34.385
One called Simple Storage soul underscore simple storage that API in simple storage Sol underscore simple storage dot bin, the ABI is obviously the ABI of this contract, which will need in the future.

3977
06:53:34.385 --> 06:53:40.264
And then the bin is going to be the binary, or the really low level of this code back and remix.

3978
06:53:40.264 --> 06:53:59.112
If you compile simple storage, that soul, you can actually look at compliation details, like the ABI which we just got, or the bytecode, which if you look at this object 60806 That's the same as the binary here 60806.

3979
06:53:59.248 --> 06:53:59.984
Alright, great.

3980
06:54:02.248 --> 06:54:08.755
Now, obviously, now if you hit up on your keyboard, you can actually cycle through your most recent terminal commands.

3981
06:54:08.755 --> 06:54:18.828
And if you hit up enough, we can see this command that we just ran typing this out or hitting up a whole bunch every single time, it's going to be really annoying to do anytime we want to recompile.

3982
06:54:18.828 --> 06:54:25.981
So what we can do is we can add a script section in our package dot JSON to shorten some yarn scripts for us.

3983
06:54:25.981 --> 06:54:34.829
So what we'll do is back in our package, dot JSON, a lot of comma, and we'll add a section called scripts, add the colon and the brackets.

3984
06:54:34.829 --> 06:54:40.414
And in here, we'll say anytime we say compile, we will run this long command.

3985
06:54:40.414 --> 06:54:43.171
So I'd compile we'll put some quotes.

3986
06:54:43.171 --> 06:54:45.017
And we'll paste that in there.

3987
06:54:45.017 --> 06:54:53.441
So now instead of typing that whole thing out, as long as we're in the same folder that our package json is in, we can run yarn compile.

3988
06:54:53.441 --> 06:55:02.037
And this will run that whole script for us without us having to type the whole thing out scripts are a really useful way to make it easier for us to run long commands.

3989
06:55:02.037 --> 06:55:02.931
All right, great.

3990
06:55:02.931 --> 06:55:12.819
Now we have our code compiled, this is going to be equivalent to US hitting this compile button for us to actually go ahead and deploy.

3991
06:55:13.248 --> 06:55:15.048
So now we have our simple storage.

3992
06:55:16.248 --> 06:55:18.581
let's learn how we can actually deploy this thing.

3993
06:55:19.248 --> 06:55:29.715
remix, we actually deployed it to one of two different places, we deployed it to either a JavaScript VM, or with our injected web three, with our Metamask.

3994
06:55:29.715 --> 06:55:32.301
Let's learn first ad, do the JavaScript VM.

3995
06:55:32.301 --> 06:55:39.011
And then we'll learn how to use the injected web three, or a meta mask or some connection to an actual test net.

3996
06:55:39.011 --> 06:55:46.150
So in order to deploy this to a JavaScript virtual invite I'm in or kind of a fake blockchain, we're gonna need to get a fake blockchain.

3997
06:55:46.150 --> 06:55:54.249
Now in the future, we're going to be using the Hardhead runtime environment as our JavaScript virtual machine or aka our fake blockchain.

3998
06:55:54.249 --> 06:55:58.233
But for this section, I want us to use a tool called ganache.

3999
06:55:58.233 --> 06:56:01.095
There's a link to this in the GitHub repository.

4000
06:56:01.095 --> 06:56:04.150
Ganache is similar to a virtual machine in remix.

4001
06:56:04.150 --> 06:56:09.842
It's a fake blockchain that we can run locally to actually test, deploy and run code.

4002
06:56:09.842 --> 06:56:14.732
It's also a nice way to see things that are going on in a blockchain.

4003
06:56:14.732 --> 06:56:21.982
Let's go ahead and spin up the ganache application after you install it, the ganache application will look a little something like this.

4004
06:56:21.982 --> 06:56:27.874
And to spin up a fake blockchain really quickly, you can just go ahead and click Quickstart.

4005
06:56:27.874 --> 06:56:33.765
This will spin up a fake blockchain that's running locally on your computer right here, which is fantastic.

4006
06:56:33.765 --> 06:56:44.609
It comes with a whole bunch of fake accounts exactly like how remix comes with a ton of fake accounts with 100 ether each ganache comes with a bunch of fake accounts with 100 ether each.

4007
06:56:44.609 --> 06:56:52.749
They also come with the private keys that we can use in our applications to actually take control of these fake accounts.

4008
06:56:52.749 --> 06:56:55.767
Remember, don't use these private keys on a public blockchain.

4009
06:56:55.767 --> 06:57:00.749
They're for development purposes only because a lot of people know these private keys in our code.

4010
06:57:00.749 --> 06:57:13.964
One of the first things that we're going to need to do is actually connect to our blockchain remix does this a little bit behind the scenes, if we're choosing JavaScript virtual machine remix chooses its own fake blockchain that it runs.

4011
06:57:13.964 --> 06:57:23.627
If we choose injected web three, as we know, meta mask pops up, and it connects to our meta mask, this connection that remix does, is actually doing something really interesting.

4012
06:57:23.627 --> 06:57:27.456
It's not just connecting to our meta mask by some magical powers.

4013
06:57:27.456 --> 06:57:33.383
It's actually connecting to our meta mask, which has a connection to the blockchain behind the scenes.

4014
06:57:33.383 --> 06:57:42.758
If you open up your meta mask, and you go down to you select the networks and you select ad networks, you'll get popped up into a UI that looks like this.

4015
06:57:42.758 --> 06:57:49.583
If we go back and hit select networks over here, we can actually see information about these different networks.

4016
06:57:49.583 --> 06:57:55.500
One of the main things that we can see is that all these networks have something called an RPC URL.

4017
06:57:55.500 --> 06:57:58.650
RPC stands for remote procedure call.

4018
06:57:58.650 --> 06:58:02.750
And then URL is uniform resource locator.

4019
06:58:02.750 --> 06:58:13.853
This RPC URL stands for a connection to a blockchain node that somebody is running this this URL connects us to make API calls and to interact with a blockchain node.

4020
06:58:13.853 --> 06:58:18.353
Blockchain nodes run with software, and some of them expose an API call.

4021
06:58:18.353 --> 06:58:27.889
If you look at the NGO Aetherium website, there actually are instructions for you to run your own blockchain node for a real blockchain like Aetherium.

4022
06:58:27.889 --> 06:58:34.250
Most of these have flags like dash HTTP dot ADR to expose these RPC endpoints.

4023
06:58:34.250 --> 06:58:47.202
So if you ever want to run your own node, your own real blockchain node, instead of using meta masks or any other the providers that we're going to go through, you can use go Aetherium, or whatever blockchain you're working with software to run your own notes.

4024
06:58:47.251 --> 06:58:54.870
But it's this RPC URL that allows us to connect to Rinkeby, if on Rinkeby ropsten, if we're on ropsten main net if we're on Main net, etc.

4025
06:58:54.870 --> 06:59:02.529
And it's going to be the way that we're going to connect to our ganache blockchain that we're running inside of this application.

4026
06:59:02.529 --> 06:59:07.616
So if you look at the top of your ganache here, there's a section called the RPC server.

4027
06:59:07.616 --> 06:59:10.464
And this is the endpoint of our ganache node right now.

4028
06:59:10.464 --> 06:59:19.829
So what we can do is we can copy this and go back to our VS code, and paste it in here to see if we can connect instead of HTTP.

4029
06:59:19.829 --> 06:59:25.426
With these capitals, we're gonna have a B lowercase instead of the uppercase, because the lowercase is more correct, and it looks nicer.

4030
06:59:25.426 --> 06:59:26.443
But now we have the endpoint.

4031
06:59:26.443 --> 06:59:34.070
Hypothetically, with just this, we can start making calls and API calls to this endpoint, go to this JSON RPC specification.

4032
06:59:34.070 --> 06:59:41.876
Again, link will be in the GitHub repo, we can actually see different calls we can make directly to our node to get different information.

4033
06:59:41.876 --> 06:59:44.630
eath get blocked by hash eath get blocked by number.

4034
06:59:44.630 --> 06:59:47.155
And all of these wonderful pieces in here.

4035
06:59:47.155 --> 06:59:51.331
Making these API calls directly is is a little bit annoying to do ourselves.

4036
06:59:51.331 --> 06:59:56.631
If you want to do it yourself, you absolutely can using an API endpoint like Axios or fetch.

4037
06:59:56.631 --> 07:00:04.691
However, we're going to use a rapper to interact with our node and do things like deploy and interact and other such things with our blockchain node.

4038
07:00:04.691 --> 07:00:08.182
This is finally where ethers comes into play.

4039
07:00:08.182 --> 07:00:26.151
Ethers js is one of the most popular JavaScript based tooling kits, that allows us to interact with different blockchains and has all these rappers that make all these API calls and do all these things with Aetherium, and polygon and avalanche and any EVM compatible chain.

4040
07:00:26.151 --> 07:00:30.427
The other incredibly popular package that does the same thing is going to be web three.

4041
07:00:30.427 --> 07:00:30.497
js.

4042
07:00:30.497 --> 07:00:35.430
And you've probably heard about this and you'll probably see it a little bit more throughout this course and throughout your web three journey.

4043
07:00:35.430 --> 07:00:42.974
The reason that we're using ethers is that ethers is the main tool that powers the hard hat environment and I really enjoy it myself.

4044
07:00:42.974 --> 07:00:48.477
And remember, if you ever get lost with any of this, you can always come back to their documentation to install it.

4045
07:00:48.477 --> 07:00:56.078
As you can see here, you can just run npm install ethers, we're just going to do yarn, add ethers.

4046
07:00:56.252 --> 07:01:01.902
And now you should see in your package json, we now have ethers added in here.

4047
07:01:01.902 --> 07:01:02.302
Awesome.

4048
07:01:02.302 --> 07:01:06.040
Now back in our code, we're going to import ethers into our deployed.

4049
07:01:06.040 --> 07:01:13.355
js script so that we can use all the wonderful tools that comes with so we'll say const ethers equals require ethers.

4050
07:01:13.355 --> 07:01:24.284
For those of you doing the TypeScript edition of this course, this will be import instead of require now that we have ethers in here, we can create our provider object in our main function.

4051
07:01:24.284 --> 07:01:30.832
The reason we we pull ethers outside of the main function is because we do want to pull our package into our script.

4052
07:01:30.832 --> 07:01:34.514
Before we call main, we want to make sure all of this is done first.

4053
07:01:34.514 --> 07:01:37.845
So you'll see this is kind of the the normal setup of our scripts.

4054
07:01:37.845 --> 07:01:45.886
At the top, we import any dependencies or external packages, we'll have our main function, and then we'll call our main function at the bottom.

4055
07:01:45.886 --> 07:01:51.252
const is a keyword similar to let the const keyword makes it so that ethers can't be changed.

4056
07:01:51.252 --> 07:01:52.527
So we can't change this.

4057
07:01:52.527 --> 07:01:58.477
Our ethers variable, anytime we use const require is a function for us to import the ethers package.

4058
07:01:58.477 --> 07:02:00.490
Now remix does all this behind the scenes.

4059
07:02:00.490 --> 07:02:13.321
But the way we're going to do it in our code here is we're going to say const provider equals new ethers dot providers dot JSON RPC provider.

4060
07:02:13.321 --> 07:02:18.506
And then we're going to pass this string as our provider.

4061
07:02:18.506 --> 07:02:23.110
So we're saying hey, we're going to connect to this URL right here.

4062
07:02:23.110 --> 07:02:23.617
Awesome.

4063
07:02:23.617 --> 07:02:29.173
So this is the way that our script is going to connect to our blockchain, our local blockchain.

4064
07:02:29.173 --> 07:02:31.217
Now let's get an actual wallet here.

4065
07:02:31.217 --> 07:02:38.039
With a private key and a balance and everything, we can see all of our wallets and private keys in our ganache here.

4066
07:02:38.039 --> 07:02:40.846
So the way to get this set up is we can say const.

4067
07:02:40.846 --> 07:02:45.117
Wallet equals new ethers dot wallet.

4068
07:02:45.117 --> 07:02:56.356
And this wallet function takes in a couple of input parameters, like a private key, and a provider, the private key will go to Kenosha and just choose one of these private keys.

4069
07:02:56.356 --> 07:02:58.562
And we're going to paste this right into our code.

4070
07:02:58.562 --> 07:03:01.945
And then we're gonna do comma provider and save that.

4071
07:03:01.945 --> 07:03:06.873
Now pasting your private key directly into your code is a huge nono.

4072
07:03:06.873 --> 07:03:10.134
And we're going to learn how to avoid this in the future.

4073
07:03:10.134 --> 07:03:17.591
It's okay right now, since we're just using one of the ganache private keys, and you have no risk of having any money associated with this account.

4074
07:03:17.591 --> 07:03:29.586
These two lines alone give us everything that we need to interact with smart contract, they give us our connection to the blockchain, and they give us a wallet with a private key so we can sign different transactions.

4075
07:03:29.586 --> 07:03:32.640
If you remember back to our blockchain basics section.

4076
07:03:32.640 --> 07:03:37.815
This is the private key that we're using to sign all of our transactions to encrypt our transactions.

4077
07:03:37.815 --> 07:03:44.456
Now that we have a provider and a wallet, let's go ahead and grab our contract objects from these two files here.

4078
07:03:44.456 --> 07:03:52.629
In order to deploy our contract, we're gonna need the ABI and we're going to need the binary compiled code of the contract.

4079
07:03:52.629 --> 07:03:58.991
So we're going to need to read from these two files to read from these two files, we're going to need to use a package called Fs.

4080
07:03:58.991 --> 07:04:10.948
So back at the top, we're gonna do const Fs equals require Fs extra I autosave, all the time, you'll see like, I'll do something and then my white dot will go away a lot.

4081
07:04:10.948 --> 07:04:22.192
It's because my fingers have a habit of pretty much anytime I stop typing I save so so please remember to save early and often, this Fs extra should come directly with your node project.

4082
07:04:22.254 --> 07:04:29.407
But if not, you can always add it with yarn, add Fs extra, and you should see it in our package dot JSON.

4083
07:04:29.407 --> 07:04:45.111
Now we can get the ABI and the binary, we can say const, abi equals Fs dot read file sync, which means we're going to synchronously read from this file, we could do it asynchronously.

4084
07:04:45.111 --> 07:04:47.254
But we want to wait for this file to get done.

4085
07:04:47.254 --> 07:04:48.520
So we're gonna say read file sync.

4086
07:04:48.520 --> 07:05:00.044
And depending on your VS code, if you scroll over, you might even get some information about this function popup like this, which can be really helpful, we can see that we need the path for the file we want to read.

4087
07:05:00.044 --> 07:05:19.387
And then any options as well path the file that we want to read the at the ABI located at dot slash simple storage, underscore soul underscore simple storage dot AVI and then we're going to do a comma of U T, F eight is UTF.

4088
07:05:19.387 --> 07:05:22.544
Eight is the encoding that we do for this file here.

4089
07:05:22.544 --> 07:05:24.189
Don't worry too much about what that means for now.

4090
07:05:24.254 --> 07:05:25.754
So we need the ABI.

4091
07:05:29.255 --> 07:05:30.610
this second file.

4092
07:05:34.255 --> 07:05:35.608
simple storage dot bin.

4093
07:05:38.255 --> 07:05:39.683
dot read file sync.

4094
07:05:43.255 --> 07:05:56.032
going to be dot slash, simple storage soul, simple storage dot bin, and then the encoding option, which again is going to be, and it should look like this.

4095
07:05:56.032 --> 07:06:05.105
Now that we have the binary, we have the ABI, we can create something called a contract factory, which is not to be confused with the factory pattern in ethers.

4096
07:06:05.105 --> 07:06:09.392
A contract factory is just an object that you can use to deploy contracts.

4097
07:06:09.392 --> 07:06:21.079
So we're gonna say const, contract factory equals new ethers dot contract, factory.

4098
07:06:21.255 --> 07:06:25.996
And we're going to pass it, the API binary.

4099
07:06:28.255 --> 07:06:46.036
pass the ABI so that our code knows how to interact with the contract the binary, obviously, because this is the main compiled code in our wallet so that we have a private key we can use to sign deploying this contract, then I usually like to write a little console dot log, saying something like deploying these wait.

4100
07:06:46.036 --> 07:06:52.390
And we can actually deploy this contract with ethers by doing const.

4101
07:06:52.390 --> 07:06:59.570
Contract equals await, contract factory dot deploy.

4102
07:06:59.570 --> 07:07:06.780
Now, this is the first time we've seen this await keyword and you can only use the await keyword inside of an async function.

4103
07:07:06.780 --> 07:07:15.256
The reason we want this await keyword we're telling our code to stop here, wait for contract to deploy.

4104
07:07:15.256 --> 07:07:24.874
And this await keyword means that this will resolve the promise contract in this contract factory dot deploy with the await here returns a contract object.

4105
07:07:24.874 --> 07:07:28.732
So now I could do something like console dot log contract.

4106
07:07:28.732 --> 07:07:39.319
Let's see what happens when we run this code node deploy dot j s, we scroll up, we see deploying, please wait.

4107
07:07:39.319 --> 07:07:43.256
And then we see this massive object that gets printed out.

4108
07:07:43.256 --> 07:07:45.890
This is the contract object that we just deployed.

4109
07:07:45.890 --> 07:07:56.867
And in fact, if we go over to our ganache, we can see that the address that we're used for our wallet has a little bit less balance and has a transaction count of one.

4110
07:07:56.867 --> 07:08:03.306
If we were working with truffle, we'd be able to see the contracts here we're working with hard hat, so you won't be able to see the contracts in here.

4111
07:08:03.306 --> 07:08:08.193
But if you go to transactions, we can indeed see the transaction that we just created.

4112
07:08:08.193 --> 07:08:09.917
This is similar to ether scan.

4113
07:08:09.917 --> 07:08:18.385
But for our local blockchain, we can see the sender address, the creation address, the value, gas price, all this stuff associated with this contract.

4114
07:08:18.385 --> 07:08:20.272
You can also see the different blocks.

4115
07:08:20.272 --> 07:08:23.636
Since we've only made one transaction only one block has been mined.

4116
07:08:23.636 --> 07:08:24.588
And this is awesome.

4117
07:08:24.588 --> 07:08:27.948
We have all this other stuff associated with it.

4118
07:08:27.948 --> 07:08:28.717
Great job.

4119
07:08:28.717 --> 07:08:34.729
You just deployed a contract to your own local blockchain with ethers.

4120
07:08:34.729 --> 07:08:35.079
Jas.

4121
07:08:35.256 --> 07:08:38.117
This is fantastic, Awesome work.

4122
07:08:41.256 --> 07:08:43.922
if we don't use the await keyword here.

4123
07:08:45.256 --> 07:08:46.056
our code to stop.

4124
07:08:48.257 --> 07:08:49.257
then just keep going.

4125
07:08:51.257 --> 07:08:52.207
this deploy function finished.

4126
07:08:53.257 --> 07:08:54.444
we run this instead.

4127
07:08:57.257 --> 07:09:04.774
this promise in its pending state because our code actually finished before our contract could finish deploying.

4128
07:09:04.774 --> 07:09:10.426
So we see promise pending here instead, this is why the await keyword is so important.

4129
07:09:10.426 --> 07:09:16.394
We're saying hey, wait for this to finish the await keyword also resolves a promise.

4130
07:09:16.394 --> 07:09:20.555
So it'll wait for the promise to exit it's pending state.

4131
07:09:20.555 --> 07:09:24.030
And then it'll return whatever the pending promise returns.

4132
07:09:24.030 --> 07:09:29.663
So contract factory to deploy returns a promise that returns a contract.

4133
07:09:29.663 --> 07:09:33.190
In fact, if we go to the ethers documentation, we look up deploy.

4134
07:09:33.190 --> 07:09:37.944
And here we can see contract factory methods contract factory dot deploy.

4135
07:09:37.944 --> 07:09:52.866
If we look at the definition of the function, it says contract factory dot deploy takes a whole bunch of arguments and some overrides this arrow is saying this is what it returns, it returns a promise that resolves to a contract.

4136
07:09:52.866 --> 07:09:59.190
And that's why we need this await keyword because contract factory to deploy by itself just returns a promise.

4137
07:09:59.257 --> 07:10:05.973
But if we do await contract factory dot deploy, we're saying it returns a promise that resolves to a contract.

4138
07:10:05.973 --> 07:10:10.007
And we're waiting for it to finish deploying to resolve to a contract object.

4139
07:10:10.007 --> 07:10:12.157
So that's gonna be a major difference here.

4140
07:10:12.257 --> 07:10:12.847
Awesome work.

4141
07:10:15.257 --> 07:10:15.722
important.

4142
07:10:18.257 --> 07:10:18.707
functions.

4143
07:10:21.257 --> 07:10:22.764
function names.

4144
07:10:22.764 --> 07:10:24.164
Awesome work.

4145
07:10:28.258 --> 07:10:28.639
ganache.

4146
07:10:28.639 --> 07:10:30.002
Shane, this is fantastic.

4147
07:10:31.258 --> 07:10:32.054
a little bit more.

4148
07:10:34.258 --> 07:10:37.612
and in Metamask, we could add a whole bunch of stuff.

4149
07:10:38.258 --> 07:10:41.758
add a gas limit, we could add some value when we were doing our trends.

4150
07:10:41.758 --> 07:10:43.758
that we could press the transact button.

4151
07:10:43.758 --> 07:10:56.786
We know that when we're working with Metamask, and we want to send some money between our accounts, we can actually choose our gas price, our priority fee, all this other stuff, we can actually do all that in ethers as well.

4152
07:10:56.786 --> 07:11:05.369
So if we wanted to await contract factory to deploy, but with a certain gas price, we can add these overrides in this deploy function here.

4153
07:11:05.369 --> 07:11:19.258
Another really neat trick that your Visual Studio code might have is if you click Command or Control, depending on your setup, you can actually click into a function and see where it's defined and see everything about this function.

4154
07:11:19.258 --> 07:11:27.008
So if I command clicked, I could see that I'm now in Node modules ethers project contract source of Ts, all this stuff.

4155
07:11:27.008 --> 07:11:37.999
And I can see exactly the function definition of this deploy function on the contract factory object, which shows us the same code as what we saw in the documentation.

4156
07:11:37.999 --> 07:11:48.664
We see we have a deploy function, it takes some arguments, and then it returns this little semicolon means it returns a promise that resolves to a contract, which is really nice.

4157
07:11:48.664 --> 07:11:53.991
These are in here are actually a list of overrides that we can specify with some brackets.

4158
07:11:53.991 --> 07:12:05.086
So what we can do is we can put some brackets in our deploy function here and specify certain things like for example, we can specify the gas price to being some number.

4159
07:12:05.086 --> 07:12:17.592
And now if we were to run this, we would deploy this contract with a gas price of this, we could add a gas limit, we can add a whole bunch of different overrides in our deploy function here.

4160
07:12:17.592 --> 07:12:25.652
Well, what else can we do? Well, we can wait for a certain number of blocks for our contract finish with so we've deployed the contract.

4161
07:12:25.652 --> 07:12:31.329
But maybe we want to wait one block to make sure it actually gets attached to the chain.

4162
07:12:31.329 --> 07:12:33.083
So we can say const.

4163
07:12:33.259 --> 07:12:45.339
Deployment received equals await, contract dot deploy transaction dot Wait, and specify the number of confirmations that we want to actually wait.

4164
07:12:45.339 --> 07:12:49.433
So we'll wait one block confirmation to make sure that this happened.

4165
07:12:49.433 --> 07:12:54.685
And then we can do console dot log, this deployment receipt option.

4166
07:12:54.685 --> 07:13:34.153
So if we run the code now, we can see all this information about our transaction, and we can see exactly what our transaction looks like, we can see there's two is no because we're creating a contract from is going to be this ganache address that we got the private key for, we see the contract address that we created transaction index, we can see gas use gas use log bloom block hash transaction, and we can see all this information about our transaction, something I want you to take note of is the deployment receipt and the deployment transaction, I want you to separate these two because it's going to make your life a lot easier.

4167
07:13:34.153 --> 07:13:40.965
So we're going to do quick console dot log, here is the deployment transaction.

4168
07:13:40.965 --> 07:13:48.679
And then we'll do console dot log contract, dot deploy transaction.

4169
07:13:48.679 --> 07:13:54.075
And then I'm going to copy this whole line by just typing Command C or Ctrl.

4170
07:13:54.075 --> 07:13:55.224
C right there.

4171
07:13:55.224 --> 07:13:58.031
And then here is the deployment.

4172
07:13:58.031 --> 07:14:00.870
Here is the transaction receipt.

4173
07:14:00.870 --> 07:14:05.410
And then this deployment is receipt is the transaction receipt.

4174
07:14:05.410 --> 07:14:08.150
So I'm just going to rename this to transaction receipt.

4175
07:14:08.150 --> 07:14:13.805
To make it a little bit clearer, which ones which, and we'll run this one more time.

4176
07:14:13.805 --> 07:14:19.193
You only get a transaction receipt, when you wait for a block confirmation.

4177
07:14:19.260 --> 07:14:25.103
Otherwise, you're gonna get the contract object, which has the deploy transaction with it, this distinction will be more important later on.

4178
07:14:25.103 --> 07:14:40.417
But I wanted you to know what the difference between the two transaction receipt is what you get when you wait for a block confirmation, the deployment transaction or the transaction response, transaction response is what you get just when you create your transaction.

4179
07:14:40.417 --> 07:14:46.791
So transaction receipts transactional response, they're different receipt is what you get when you wait for a transaction to finish.

4180
07:14:46.791 --> 07:14:48.604
And then response is just what you initially get.

4181
07:14:48.604 --> 07:14:49.505
Make sense? Okay, great.

4182
07:14:49.505 --> 07:14:51.373
We're gonna go ahead and delete those.

4183
07:14:51.373 --> 07:14:56.937
But those lines will be in the code associated with the GitHub.

4184
07:14:56.937 --> 07:15:18.993
Now you saw when we actually printed out those receipts, we got all this stuff in here, because deploying a contract is actually just sending a transaction, as we've said before, so if we want to see what's really going on under the hood, we can actually create a transaction ourselves and create a contract ourselves just by specifying the transaction information.

4185
07:15:18.993 --> 07:15:25.593
So how will we do that? Let's deploy this contract again, but only purely using transaction data.

4186
07:15:25.593 --> 07:15:28.093
So we'll do a console dot log.

4187
07:15:28.261 --> 07:15:32.761
Let's deploy with only transaction data.

4188
07:15:34.261 --> 07:15:42.118
going to be the way you can actually deploy or send transactions purely with transaction data you can send any transaction this gives you unlimited flux.

4189
07:15:42.118 --> 07:15:54.584
ability with the transactions you want to send, what we can do is we can say const, or let TX which is going to stand for our transaction equals, and we can just add all of our transaction information in here.

4190
07:15:54.584 --> 07:16:04.386
So the first thing that we're going to need is our nuts, or the number that we only use once we go back to our transaction count, we're on four transactions here.

4191
07:16:04.386 --> 07:16:08.448
So we'll use the nonce five, because that's going to be a nonce that we haven't used before.

4192
07:16:08.448 --> 07:16:12.761
Every time you send a transaction, it comes with one of those nonces.

4193
07:16:12.761 --> 07:16:21.337
Right, so the nonce is a bit of a over overused term, we saw it back in our blockchain basics that we use the nonce to solve that hard problem.

4194
07:16:21.337 --> 07:16:29.053
nonces are also used in wallets and in signers, to send transactions and they use a different nones for every transaction.

4195
07:16:29.053 --> 07:16:34.554
So nonce, when we're talking about wallets talks about a number associated with a unique transaction.

4196
07:16:34.554 --> 07:16:41.244
nonce, when we're talking about blockchain mining is a value used to solve that hard problem, they both mean the same thing.

4197
07:16:41.244 --> 07:16:42.682
They both mean a number only used once.

4198
07:16:42.682 --> 07:16:45.025
But they're different in these different contexts.

4199
07:16:45.025 --> 07:17:14.745
So we're going to use this number only use once this unique number for a transaction to send this, so we're going to say nonce is going to be five, we're going to pick a gas price of, of this right here, we're just going to use the gas price of ganache like that, we're going to pick a gas limit of some big number, we'll use 1123456, we'll just use that we're gonna say two is going to be no, right, exactly like what we saw in our receipts and responses down here.

4200
07:17:14.745 --> 07:17:18.181
Since we're creating a contract value is going to be zero.

4201
07:17:18.181 --> 07:17:23.762
Since we're creating a contract, we don't want to send an ether polygon or avalanche.

4202
07:17:23.762 --> 07:17:29.706
And then data is going to be that massive binary object in our binary bit.

4203
07:17:29.706 --> 07:17:39.325
So in the binary section, we're gonna copy this massive binary piece, and we're going to put some quotes in here, we're gonna do 0x, and paste that in here.

4204
07:17:39.325 --> 07:17:43.469
So this massive, massive data piece is the binary that we're sending.

4205
07:17:43.469 --> 07:17:58.200
Whenever you send a transaction, you have this this data object that you can fill this stuff, we're filling our data object with the binary with the code that tells the theory that tells our blockchain to deploy our smart contract that's going to look exactly like this.

4206
07:17:58.262 --> 07:18:02.175
And then finally, we want to add the chain ID.

4207
07:18:02.262 --> 07:18:10.033
As we've seen before with Metamask, if we go back over to our networks, each one of these EVM chains has a different chain ID Etherium.

4208
07:18:10.033 --> 07:18:14.928
Main net is one ropsten is three Rinke, B is four COVID is 42, etc.

4209
07:18:14.928 --> 07:18:29.346
And other EVM chains like avalanche like polygon, are going to have their unique chain IDs as well, or ganache, we can see the network ID appear is 1337 in some people, so we can just paste that in here.

4210
07:18:29.346 --> 07:18:33.976
Some people have run into some issues where the chain ID and the network ID are different.

4211
07:18:33.976 --> 07:18:36.753
And the chain ID is actually 31337.

4212
07:18:36.753 --> 07:18:43.178
So if you have a problem with this, try 31337 instead, but it should be 1337.

4213
07:18:43.262 --> 07:18:47.329
Now this is a transaction with all this information propagated, which is awesome.

4214
07:18:47.329 --> 07:18:49.929
However, this transaction isn't signed.

4215
07:18:49.929 --> 07:19:01.635
So nobody's sending this transaction right now this is just the transaction details of what somebody wants to do, we actually need to sign this transaction, and then send it to our blockchain.

4216
07:19:01.635 --> 07:19:14.295
Cons sign, TX response equals await, wallet dot sign transaction, and we can pass that TX object.

4217
07:19:14.295 --> 07:19:21.032
And then we'll do a console dot log of the sign TX response in JavaScript.

4218
07:19:21.032 --> 07:19:22.339
Same as solidity.

4219
07:19:22.339 --> 07:19:27.463
If you type two backslashes, before some code, it won't run that code.

4220
07:19:27.463 --> 07:19:31.663
So I'm gonna go ahead and comment out the three lines above.

4221
07:19:31.663 --> 07:19:42.663
And the way that I'm doing it is by highlighting the sections and hitting Command backslash, or you might hit Ctrl backslash, but this is a keyboard shortcut you can use to quickly comment out entire sections.

4222
07:19:42.663 --> 07:19:54.572
And the reason I'm doing this is because I want to show you what happens when we just run scientex response wallet that signed transaction back in nosh, we see that we have four blocks in here.

4223
07:19:54.572 --> 07:20:03.739
Let me ask if we do this sign transaction and we get the signed transaction response, will we propagate another block? Well, let's find out run no deploy.

4224
07:20:03.739 --> 07:20:06.437
js, we get this massive thing here.

4225
07:20:06.437 --> 07:20:13.534
But if we go back to ganache refresh, we actually don't see another transaction sent.

4226
07:20:13.534 --> 07:20:18.816
That's because we're only signing a transaction here, we're not actually sending it.

4227
07:20:18.816 --> 07:20:20.908
So the signed transaction response.

4228
07:20:20.908 --> 07:20:27.772
This big number here represents a signed transaction but not a cent transaction, which is different.

4229
07:20:27.772 --> 07:20:32.326
You can actually send one of these transactions by changing this line a little bit.

4230
07:20:32.326 --> 07:20:56.108
So instead of scientex response, we'll change this to send TX response equals await wallet dot send transaction TX then once We send the transaction here, we can do a wait, send transaction response, that Wait, one, we're gonna wait one block confirmation to make sure this transaction actually goes through.

4231
07:20:56.108 --> 07:20:57.832
And we can run node.

4232
07:20:57.832 --> 07:20:58.004
js.

4233
07:20:58.264 --> 07:20:59.591
And it looks like it's done.

4234
07:21:01.264 --> 07:21:02.914
actually got an error here.

4235
07:21:05.264 --> 07:21:05.576
here.

4236
07:21:10.264 --> 07:21:18.451
the TX doesn't have the correct nuts, which just for some practice, let's go ahead, type this into Google and see what we get.

4237
07:21:18.451 --> 07:21:25.535
We actually get a web three Jas from four years ago, trying to call leaf picked, blah, blah, blah, blah, blah, blah, blah, blah.

4238
07:21:25.535 --> 07:21:29.448
It looks like this is a meta mask issue that they ran into.

4239
07:21:29.448 --> 07:21:33.174
And they said, you have to reset your account in meta mask, which we could do.

4240
07:21:33.174 --> 07:21:35.898
But let's make this a little bit more specific.

4241
07:21:35.898 --> 07:21:37.247
Let's say ethers.

4242
07:21:37.247 --> 07:21:48.538
JS looks like we don't get it looks like as of right now, from this recording, we don't get a Stack Exchange eath or a Stack Overflow question for this trolley, because this is pretty straightforward.

4243
07:21:48.538 --> 07:21:50.539
We don't have the correct nonce for our transaction.

4244
07:21:50.539 --> 07:21:57.895
But this would be a good time to actually make this a question on Stack Overflow or Stack Exchange Aetherium so that it shows up first.

4245
07:21:57.895 --> 07:22:05.199
So we actually don't get the correct nuts, we're going to want to make this a nonce of four you can see here account has a nonce of four TX has a nonce of five.

4246
07:22:05.199 --> 07:22:07.756
So we actually would want this to be four.

4247
07:22:07.756 --> 07:22:14.976
Now an easier way to always get the correct nonce here is going to be actually just calling the transaction count from the wallet.

4248
07:22:14.976 --> 07:22:22.989
So back in the ethers documentation, there's actually some good samples here on how to assigning a message and then how to actually send these messages.

4249
07:22:22.989 --> 07:22:26.693
So we can do a weight wallet dot get transaction count to get the nuts.

4250
07:22:26.693 --> 07:22:37.537
So back in our code, we could do const nuns equals await, oops, copy pasted, await wallet dot get transaction count.

4251
07:22:37.537 --> 07:22:40.155
And then we can just place the nonce right here.

4252
07:22:40.265 --> 07:22:42.580
Now, let's try running this again.

4253
07:22:44.265 --> 07:22:45.931
one did indeed go through.

4254
07:22:45.931 --> 07:22:47.931
We can verify on ganache here.

4255
07:22:48.265 --> 07:22:52.144
do indeed see we're currently on block five now and we have one extra transaction.

4256
07:22:52.144 --> 07:22:54.515
Now we could go ahead and just run this again.

4257
07:22:54.515 --> 07:22:58.317
And we'll never have to worry about actually updating this nonce ourselves.

4258
07:22:58.317 --> 07:23:07.098
Since we're just calling wallet dot get transaction count to keep updating it current block is six and the our additional transaction has indeed gone through awesome.

4259
07:23:07.098 --> 07:23:09.788
I showed you how to actually sign the transaction.

4260
07:23:09.788 --> 07:23:12.827
But we didn't sign the transaction for our central injection.

4261
07:23:12.827 --> 07:23:21.281
Well, why not? If you command click or control click, or you go to the documentation for ethers, we can see the code for send transaction.

4262
07:23:21.281 --> 07:23:23.428
So first, it does some check provider stuff.

4263
07:23:23.428 --> 07:23:24.968
There's some stuff to populate the transaction.

4264
07:23:24.968 --> 07:23:35.846
But we can actually see that before it sends the transaction even in ethers, it signs the transaction first, and then calls this dot provider dot send transaction.

4265
07:23:35.846 --> 07:23:44.717
So if you just call send transaction with the transaction details like we did here, it's the same as signing it first and then sending it with the provider.

4266
07:23:44.717 --> 07:23:45.396
Okay, great.

4267
07:23:45.396 --> 07:23:50.618
So we've learned how to send a transaction using pure JavaScript and using pure ethers.

4268
07:23:50.618 --> 07:24:17.837
One of the main takeaways from this is that every time we change the blockchain, every time we change state, every time we use gas, we're sending a transaction that looks pretty much exactly like this, the data is going to be the differentiator, the data for us here was data saying to create a new contract, when we make transactions, like adding people or storing the data that we're going to be passing in our transaction is going to be data associated with calling these functions.

4269
07:24:17.837 --> 07:24:21.646
And when we actually call functions in ethers, or in Hardhead.

4270
07:24:21.646 --> 07:24:32.250
We're not going to do this kind of raw const, TX, and list out all the stuff like here and list out the raw data, right? Because that's really, really hard ethers and hard hat are going to make this process a lot easier.

4271
07:24:32.250 --> 07:24:43.516
So for now, let's go ahead, comment out this whole section, which again, if we copy this whole thing, and then hit Command, slash, or control slash, or whatever the shortcut is on your environment, that'll actually comment this out.

4272
07:24:43.516 --> 07:24:51.556
Let's go ahead and uncomment this section so that we deploy our contract using kind of the ether is much easier to read way than this weird TX stuff.

4273
07:24:51.556 --> 07:24:52.136
Oh, cool.

4274
07:24:52.266 --> 07:24:55.604
So we've changed our script back to deploy our contracts like this.

4275
07:24:55.604 --> 07:25:08.141
Now that we've actually deployed our contract, we can learn how to interact with our contract through code as well, the same way that we click these buttons in remix, we're going to code it out for ourselves here.

4276
07:25:08.141 --> 07:25:13.045
So if we look at symbol storage, we have a button for add person for store.

4277
07:25:13.045 --> 07:25:15.199
And then we have these view functions as well.

4278
07:25:15.199 --> 07:25:21.551
The easiest one is going to be the Retrieve function, which grabs our favorite number, retrieve returns favorite number.

4279
07:25:21.551 --> 07:25:26.066
So we can call that in ethers by doing const.

4280
07:25:26.066 --> 07:25:30.999
current favorite number equals await.

4281
07:25:31.267 --> 07:25:32.109
contract.

4282
07:25:32.109 --> 07:25:33.266
we retrieve.

4283
07:25:37.267 --> 07:25:45.167
what's returned from our contract factory as long as we've awaited it the contract object is going to come with all the functionality described in our API.

4284
07:25:45.167 --> 07:25:49.317
That's why we had to pass the API to our contract factory.

4285
07:25:49.317 --> 07:26:00.067
If we look inside our API piece here, we can see it has a ton of information on the different functions that we can call and the types that it has and the return types and everything like that.

4286
07:26:00.067 --> 07:26:09.496
For example, if I look up retrieve, I can see down here, we have retrieve, we can see that the name of this function is going to be retrieved.

4287
07:26:09.496 --> 07:26:13.939
And the outputs are going to be a un 256, of type Nuun 256.

4288
07:26:13.939 --> 07:26:17.567
Now, this is a little bit difficult to read because it's not formatted.

4289
07:26:17.567 --> 07:26:20.974
Since we call this dot API, it's going to be a little bit hard to read.

4290
07:26:20.974 --> 07:26:22.912
But we could change it the dot JSON.

4291
07:26:22.912 --> 07:26:30.683
And then you'll see it's highlighted a little bit, I can even do format document with prettier.

4292
07:26:30.683 --> 07:26:36.183
And you'll see it actually formats to be a lot easier to read now and go back to retrieve.

4293
07:26:36.183 --> 07:26:42.530
And we can see, this block of code here defines what the Retrieve function can and can't do.

4294
07:26:42.530 --> 07:26:44.353
I'm going to change it back to abi.

4295
07:26:44.353 --> 07:26:47.314
And it looks like my formatting has stayed, which is great.

4296
07:26:47.314 --> 07:26:49.557
This is much easier to read than it was before.

4297
07:26:49.557 --> 07:26:55.060
As I said, the ABI or the application binary interface is incredibly important for working with our contracts.

4298
07:26:55.060 --> 07:27:05.233
If we give our code just this huge bytecode thing, it's gonna be really hard for any processor to decompile this or understand what exactly what the functions are that are going on here.

4299
07:27:05.267 --> 07:27:10.302
There are decompiler options out there, like ether VM, that IO slash decompile.

4300
07:27:10.302 --> 07:27:13.784
That can decompile some bytecode into the solidity.

4301
07:27:13.784 --> 07:27:17.138
But it can be really tricky to get it exactly right.

4302
07:27:17.268 --> 07:27:25.183
So it's much easier just to have the ABI to say, hey, this lump of code, this lump of numbers and garbled nonsense is this.

4303
07:27:25.268 --> 07:27:32.203
When we deploy this bytecode to the blockchain, and we call functions on it, the code will automatically allow those functions to get called if they do exist.

4304
07:27:32.203 --> 07:27:36.649
But in order for our code to know that they exist, it's much easier just to give it the API.

4305
07:27:36.649 --> 07:27:39.590
So we can get our current favorite number like this.

4306
07:27:39.590 --> 07:27:44.655
Let's go ahead and console dot log, the current favorite number.

4307
07:27:44.655 --> 07:27:49.300
Now that we've edited this code, we're going to let me zoom out a little bit.

4308
07:27:49.300 --> 07:28:07.583
Now that we've edited this code, we're going to connect organ nosh instance, we're going to connect a wallet with a private key that we got from the top of our ganache here, we're gonna grab the ABI and the binary of our contracts, and connect them to a new contract factory object, which is connected to that wallet.

4309
07:28:07.583 --> 07:28:18.486
So that wallet will be the one to actually deploy the contract, we'll deploy the contract with const contract equals await contract factory dot deploy, we will wait one block for that transaction to finish.

4310
07:28:18.486 --> 07:28:20.705
And in fact, we're not going to use transaction receipt.

4311
07:28:20.705 --> 07:28:23.767
So for now, we're just going to delete that part.

4312
07:28:23.767 --> 07:28:25.895
We're not going to do any of this here.

4313
07:28:25.895 --> 07:28:27.509
So I'm going to delete it for now.

4314
07:28:27.509 --> 07:28:30.220
However, I'll leave this section commented out in the GitHub repo.

4315
07:28:30.220 --> 07:28:35.471
And then we're going to call contract retrieve which should return our current favorite number.

4316
07:28:35.471 --> 07:28:39.996
Since this is a view function, this contract call won't cost us any gas.

4317
07:28:39.996 --> 07:28:45.106
If we look at simple storage, that soul we can see retrieve is a view function.

4318
07:28:45.106 --> 07:28:57.853
And remember view and pure functions, if called outside of a contract function call don't cost any gas, we're just reading up the blockchain, we're not changing any variables on chain, we're not changing the state of the blockchain.

4319
07:28:57.853 --> 07:28:59.430
So this won't cost any gas.

4320
07:28:59.430 --> 07:29:01.983
So let's go ahead and run this.

4321
07:29:01.983 --> 07:29:05.697
Perfect, we get deploying, please wait.

4322
07:29:05.697 --> 07:29:08.197
And then we get this big number response.

4323
07:29:08.197 --> 07:29:15.855
So what's this big number response here? Big number is a library that comes with the ethers application that helps us work with numbers.

4324
07:29:15.855 --> 07:29:28.062
If you actually scroll down, they even have a section saying why can I just use numbers, you'd expect current favorite number to just be zero, but it returns this weird hex thing that says his big number true this weird, big number thing.

4325
07:29:28.062 --> 07:29:32.935
So solidity can't use decimal places, and JavaScript has a hard time with decimal places.

4326
07:29:32.935 --> 07:29:46.336
And this is kind of the more specific rationale for why not to use numbers, what you'll see a lot of the time instead of numbers is you'll see strings like zero, you'll see JavaScript use strings like this, or big numbers.

4327
07:29:46.336 --> 07:29:53.031
Now, if I were to try to pass a number like this in JavaScript, this number would be too big for JavaScript to understand.

4328
07:29:53.031 --> 07:29:56.596
So we want to use big numbers or strings when working with ethers.

4329
07:29:56.596 --> 07:29:59.050
Now we can make this more readable by adding.

4330
07:29:59.050 --> 07:30:04.075
to string at the end and printing out the string version of this big number.

4331
07:30:04.075 --> 07:30:17.126
Now, if I rerun this code, we can see we get zero, which makes sense again, because our favorite number gets initialized to the zero value, if not specified, and we haven't called store yet.

4332
07:30:17.126 --> 07:30:17.715
So awesome.

4333
07:30:17.715 --> 07:30:19.734
So that is, that's working perfectly.

4334
07:30:19.734 --> 07:30:22.165
So this is what our current favorite number is.

4335
07:30:22.269 --> 07:30:25.220
Let's make this console dot log a little bit more syntactical.

4336
07:30:25.269 --> 07:30:28.069
We're going to use something called string interpolation.

4337
07:30:28.270 --> 07:30:31.536
we can interpolate our string here with variables.

4338
07:30:32.270 --> 07:30:34.236
in JavaScript when working with strings, use double quotes.

4339
07:30:34.270 --> 07:30:40.673
However, if you want to mix variables with actual strings, you can use backticks instead.

4340
07:30:40.673 --> 07:30:47.975
So we're going to use some that backticks here, and we're gonna say current favorite number to call in here.

4341
07:30:47.975 --> 07:30:56.650
And to tell JavaScript that this is a variable that we want to read, we put a little dollar sign and a bracket around it, like this.

4342
07:30:56.650 --> 07:31:15.320
Now, if we run this code again, it's saying deploying, please wait, and we get current favorite number is zero, because JavaScript goes, Okay, this is a string, ah, dollar sign, curly brace looks like this is going to be some variable or some JavaScript that you want me to interpret and close it off, and then backtick.

4343
07:31:15.320 --> 07:31:15.658
Cool.

4344
07:31:15.658 --> 07:31:17.703
So our current favorite number is going to be zero.

4345
07:31:17.703 --> 07:31:17.903
Great.

4346
07:31:17.903 --> 07:31:22.112
So let's update on the contract the number by calling the store function.

4347
07:31:22.112 --> 07:31:30.920
So we'll say const, transaction response equals await, contract dot store, and we'll add seven.

4348
07:31:30.920 --> 07:31:34.650
Now since seven is a small number, you can just pass it like seven.

4349
07:31:34.650 --> 07:31:37.555
But passing it like seven in a string also works.

4350
07:31:37.555 --> 07:31:44.056
Again, this is because if we want to pass some crazy massive number, JavaScript would get confused.

4351
07:31:44.056 --> 07:31:56.943
So it's usually best practice to pass variables to contract functions as strings, even though that might be a little bit confusing ethers is smart enough to know that this seventh string is actually seven the number then we can do const.

4352
07:31:56.943 --> 07:32:05.609
Transaction received equals await transaction response that Wait, one.

4353
07:32:05.609 --> 07:32:08.558
So we'll wait one block here.

4354
07:32:08.558 --> 07:32:16.406
This is similar to us doing contract dot deploy transaction dot Wait, the syntax here is a little bit different than what we saw up here.

4355
07:32:16.406 --> 07:32:17.795
Because this is using a contract factory.

4356
07:32:17.795 --> 07:32:20.686
And this is calling a function on a contract.

4357
07:32:20.686 --> 07:32:24.849
So when we call the function on the contract, we get a transaction response.

4358
07:32:24.849 --> 07:32:28.908
When we wait for the transaction response to finish, we get the transaction receipt.

4359
07:32:28.908 --> 07:32:37.271
Now I can do const, updated, favorite number two equals await on track dot retrieve.

4360
07:32:37.271 --> 07:32:40.886
And then console dot log updated.

4361
07:32:40.886 --> 07:32:52.202
favorite number is, and we'll do a little string interpolation, updated, favorite number like that? Now let's go ahead and run this.

4362
07:32:52.202 --> 07:33:02.561
So in this process, what are we doing, we're deploying the contract, we're getting the initial value, we're going to update our contract by calling store which is going to cost gas.

4363
07:33:02.561 --> 07:33:18.287
So this is a transaction, we're going to get the transaction response, then we're gonna get the transaction receipt, we're not going to do anything with the transaction receipt, I want to ingrain in you all that these two are different transaction response and transaction receipt, and you'll see why in the future.

4364
07:33:18.287 --> 07:33:21.754
And then we'll get the updated favorite number, and then we're just going to print it out.

4365
07:33:21.754 --> 07:33:23.124
So let's do this.

4366
07:33:23.124 --> 07:33:24.575
Boom, and perfect.

4367
07:33:24.575 --> 07:33:30.554
Deploying, please wait, current favorite number is zero, updated favorite number is seven.

4368
07:33:30.554 --> 07:33:45.969
And if we go to our ganache instance, we go to transactions, we can see, we now have a contract call at the top, we have the sender, the contract address, the gas price, all this stuff, and we see our transaction data right here.

4369
07:33:45.969 --> 07:33:50.714
So this transaction data is what gets sent in that data slot of our transaction object.

4370
07:33:50.714 --> 07:33:56.951
Ethers is just doing that on the back end for us so that we don't have to make that big transaction object there.

4371
07:33:56.951 --> 07:33:58.026
All right, awesome.

4372
07:33:58.026 --> 07:34:07.532
You've successfully deployed a contract to your own local ganache instance, or your own JavaScript virtual machine.

4373
07:34:07.532 --> 07:34:09.053
This is great.

4374
07:34:09.272 --> 07:34:10.933
Now let's clean this up a little bit.

4375
07:34:12.272 --> 07:34:25.562
we have both our connection to the blockchain and our private key stored directly in our code, we were to push this code up to a GitHub or some other code repository, if you will, will be able to see our code.

4376
07:34:25.562 --> 07:34:33.126
If we look into ploy dot j s of my code, ah, there's something else in here, we don't actually see the private key or the RPC URL in here.

4377
07:34:33.126 --> 07:34:38.644
So what's going on? Remember, if you give out your private key, whoever has your private key owns your funds.

4378
07:34:38.644 --> 07:34:49.061
So even though this is a fake, private key that doesn't have any real money in it, we still don't want to have to hard code our private keys into our code, just in case we accidentally share code with somebody.

4379
07:34:49.061 --> 07:34:55.647
So what can we do? Well, one of the most popular methods is actually creating something called a dot EMV file or an environment variable.

4380
07:34:55.647 --> 07:35:02.367
And if you're familiar with environment variables, you can actually set them right in your terminal, but we're gonna set them in our dot env.

4381
07:35:02.367 --> 07:35:05.698
So what you want to do is you're gonna want to create a dot env file.

4382
07:35:05.698 --> 07:35:09.322
And this is going to be a file where you store its sensitive information.

4383
07:35:09.322 --> 07:35:12.990
And this is going to be a file, we're never going to share this with anybody.

4384
07:35:12.990 --> 07:35:18.072
This dot env file will stick variables of our choosing into the environment of our code.

4385
07:35:18.072 --> 07:35:28.457
So for example, if I pull up my terminal here, and I do echo cat, this is going to reflect what the cat environment variable is for us.

4386
07:35:28.457 --> 07:35:31.273
Right now there is no cat environment variable.

4387
07:35:31.273 --> 07:35:41.950
However, if I do export, cat equals dog, and now I do echo dollar sign cat, I get dog output.

4388
07:35:41.950 --> 07:35:57.595
This is what an environment variable is, it's a variable in our terminal or in our scripting environment, since I don't want to have to type export, private key equals blah, blah, blah, every time, what we're going to do instead is we're going to stick them into this dot env file.

4389
07:35:57.595 --> 07:36:02.073
So when this dot env, we can put private key equals.

4390
07:36:02.073 --> 07:36:07.813
And we can grab this private key from our script, and paste it in like this.

4391
07:36:07.813 --> 07:36:20.580
And a note, some tools look for the 0x, at the beginning of the private key ethers, and hard hat is smart enough that either one works, but if you run into some issues, just know that sometimes you might have to put your 0x at the front of this.

4392
07:36:20.580 --> 07:36:20.856
Great.

4393
07:36:20.856 --> 07:36:22.873
So now we have a private key in an environment variable.

4394
07:36:22.873 --> 07:36:25.382
What do we do now? Well, in our deploy.

4395
07:36:25.382 --> 07:36:33.606
js, we want to grab this environment variable and stick it into our script here, so that our script can then stick it into our environment.

4396
07:36:33.606 --> 07:36:35.885
So we're going to add a tool called dot env.

4397
07:36:35.885 --> 07:36:40.148
To make this easier, so we're gonna do yarn, add dot env.

4398
07:36:40.148 --> 07:36:47.220
And if we look at the dot env package, can read more about it and read about how to add it with NPM.

4399
07:36:47.273 --> 07:36:49.442
Again, we're just using yarn add.

4400
07:36:51.273 --> 07:36:53.083
this require dot E and V dot config.

4401
07:36:54.273 --> 07:36:56.862
all our environment variables.

4402
07:36:59.273 --> 07:37:04.527
dot EMV config, we should see this on our package that JSON, we do.

4403
07:37:04.527 --> 07:37:05.035
Excellent.

4404
07:37:05.035 --> 07:37:14.636
Now that we pulled it in, we actually get access to our private key environment variable, you can access environment variables in JavaScript, are using process dot EMV.

4405
07:37:14.636 --> 07:37:35.086
So instead of putting our private key here, we're gonna delete that whole thing and substitute it with process dot EMV, that private key, and we'll save and it'll reformat for us to make sure this is actually working, we can just hit up after we save up, up up up up a bunch and go back to no deploy to Jas.

4406
07:37:35.086 --> 07:37:37.523
And we see we get the exact same setup.

4407
07:37:37.523 --> 07:37:41.515
And if we scroll back, you can see a transaction has indeed gone through.

4408
07:37:41.515 --> 07:37:54.601
If you want to double check that this is actually printing out your private key, we could do console dot log, press study and via private key we run, we see that that is indeed the private key coming from our environment variable here.

4409
07:37:54.601 --> 07:37:55.256
Awesome.

4410
07:37:55.256 --> 07:38:06.007
Now our RPC URL here is isn't really something that we need to secure however, maybe we're going to use a certain API key or maybe a certain endpoint that only we want to have access to.

4411
07:38:06.007 --> 07:38:08.627
And we don't want anybody else to be using our RPC endpoint.

4412
07:38:08.627 --> 07:38:12.197
So we're going to add this to our dot env file as well.

4413
07:38:12.197 --> 07:38:13.581
So in our dot env.

4414
07:38:13.581 --> 07:38:22.177
When I copy this here, I'm gonna say RPC URL equals, and I paste that in there, just like that.

4415
07:38:22.274 --> 07:38:23.580
And we're gonna delete here.

4416
07:38:25.274 --> 07:38:28.369
thing, say process dot e NV dot RPC URL.

4417
07:38:30.274 --> 07:38:30.940
run this again.

4418
07:38:33.274 --> 07:38:42.499
And we should get the exact same response because all we did was swap out our RPC URL with our environment variable, which is going to be exactly what it was before.

4419
07:38:42.499 --> 07:38:45.379
So we go ahead and run this, and we get the exact same response.

4420
07:38:45.379 --> 07:38:51.460
And if we go to ganache, we see that we do indeed get a transaction here, which is perfect.

4421
07:38:51.460 --> 07:38:52.052
Awesome.

4422
07:38:52.052 --> 07:38:56.878
So we've learned how to add environment variables to our dot env file.

4423
07:38:56.878 --> 07:39:05.791
So that so that just in case, we want to share our code, or we push our code up to GitHub, which we'll do in later sections, we don't accidentally expose our private keys or our RPC URLs.

4424
07:39:05.791 --> 07:39:15.597
Now all the code that we have in our project here, if we push it up to GitHub, or share it with somebody else, all this code will get pushed up, including our dot env file.

4425
07:39:15.597 --> 07:39:22.493
However, if you look at my code samples here for this course, we don't see a dot env file in here.

4426
07:39:22.493 --> 07:39:30.190
So how is that possible? Well, what we want to do whenever we have a project is create a dot Git ignore file.

4427
07:39:30.275 --> 07:39:32.408
And in here, we want to put in v.

4428
07:39:34.275 --> 07:39:35.147
Node modules.

4429
07:39:38.275 --> 07:39:43.758
working with version control, which we're going to do a little bit later, we won't push our dot env file up to GitHub.

4430
07:39:43.758 --> 07:39:45.989
And we also won't push up known modules.

4431
07:39:45.989 --> 07:39:56.978
So if we go back to my example here, we don't see, we don't see a dot env file, but we do see a dot env dot example, just to show you what one would look like.

4432
07:39:56.978 --> 07:40:01.118
So it doesn't really matter that I have them in here.

4433
07:40:01.275 --> 07:40:05.681
Now, if you're really paranoid, there's something else you can actually do when running your scripts and running your commands.

4434
07:40:05.681 --> 07:40:12.560
Let's say you didn't want to put your private key into a dot env file because you were nervous that you would accidentally push it up or something.

4435
07:40:12.560 --> 07:40:18.647
What you can do is you can add your private key in your RPC URL as environment variables right in the command line.

4436
07:40:18.647 --> 07:40:27.608
So before you run Node deploy, that's as well you can do, you can say RPC URL equals, paste your RPC around.

4437
07:40:27.608 --> 07:40:31.275
And then you can say private key.

4438
07:40:31.275 --> 07:40:36.937
equals and then paste your private key and then do node deploy.

4439
07:40:36.937 --> 07:40:37.106
js.

4440
07:40:37.276 --> 07:40:41.921
Setting these right before we run our script is the exact same as if we had set them into dot env.

4441
07:40:41.921 --> 07:40:48.294
Here If we hit run, we see the exact same output, which means that our RPC URL and our private key went through successfully.

4442
07:40:48.294 --> 07:40:50.176
This way for key management is fine.

4443
07:40:50.176 --> 07:40:52.964
But our rights doing this, it's going to be much better.

4444
07:40:52.964 --> 07:41:04.974
But it still makes me a little bit nervous in our development environments with our fake private keys, having our code in the dot env file like this is, is okay, right? Because we don't really care if this key gets hacked, like nobody's using it.

4445
07:41:04.974 --> 07:41:08.663
But when we move to a more professional setup, this can be a little bit scary.

4446
07:41:08.663 --> 07:41:17.226
So how can we make this even more secure? Well, what we can do is actually we can encrypt our private key and store our encrypted key locally.

4447
07:41:17.276 --> 07:41:24.259
That way, if for some reason somebody does get into our account, our private key isn't just sitting around in plain text, it's encrypted.

4448
07:41:24.259 --> 07:41:27.568
And you'll need to know a password that only you know to get into it.

4449
07:41:27.568 --> 07:41:34.854
So how do we add that? Well, first, we're going to create a new file called encrypt key.

4450
07:41:34.854 --> 07:41:35.072
js.

4451
07:41:35.072 --> 07:41:39.228
And this is some code that we're going to use to actually encrypt a key.

4452
07:41:39.276 --> 07:41:41.977
And we'll store that locally instead of our private key in plain text.

4453
07:41:41.977 --> 07:41:47.479
This will make us even more secure so that we don't have our private key just hanging around in plain text here.

4454
07:41:47.479 --> 07:41:50.636
So let's go ahead and build the script to encrypt our private key.

4455
07:41:50.636 --> 07:41:53.485
So we're going to use the exact same setup as we did for our deploy script.

4456
07:41:53.485 --> 07:41:56.876
We're going to do an async function main.

4457
07:41:57.276 --> 07:42:00.050
And then down here, I'm just gonna go ahead and copy from deployed J S.

4458
07:42:00.050 --> 07:42:03.405
We're gonna use this exact same setup, and paste it.

4459
07:42:03.405 --> 07:42:04.179
Okay, great.

4460
07:42:04.179 --> 07:42:07.799
We're gonna be using ethers J, s, and r dot E and V again.

4461
07:42:07.799 --> 07:42:18.552
So we're going to add these in const ethers equals require ethers const, FS equals require Fs extra.

4462
07:42:18.552 --> 07:42:22.221
And then require dot env.

4463
07:42:22.221 --> 07:42:23.128
Config.

4464
07:42:23.128 --> 07:42:29.047
Alright, so right now, in our dot env, we do have this private key.

4465
07:42:29.047 --> 07:42:37.324
And again, if you don't want to have the private key in their way you can just do is you can do private key equals and then you know, node, whatever script you want to run.

4466
07:42:37.324 --> 07:42:41.277
So we're going to set this script up to run our encrypt key one time.

4467
07:42:41.277 --> 07:42:46.975
And then we can remove our private key from anywhere in our workspace so that it's no longer in plain text anywhere.

4468
07:42:46.975 --> 07:42:54.358
So what we want to do is we want to say const wallet, and we're gonna create a new wallet, but a little bit differently.

4469
07:42:54.358 --> 07:43:01.131
We're gonna say equals new ethers dot wallet, process dot E and V dot private key.

4470
07:43:01.131 --> 07:43:04.725
So we do need our private key to stick in here.

4471
07:43:04.725 --> 07:43:10.018
But then once we create this wallet, we're gonna say const.

4472
07:43:10.018 --> 07:43:25.218
Encrypted JSON key equals await ethers dot encrypt, this encrypt function is going to return an encrypted JSON key that we can store locally and that we can only decrypt it with the password.

4473
07:43:25.218 --> 07:43:26.922
And it takes two parameters.

4474
07:43:26.922 --> 07:43:30.147
It takes a private key password and a private key.

4475
07:43:30.277 --> 07:43:35.023
So in our dot EMV, just for right, now we're going to create a private key password.

4476
07:43:35.023 --> 07:43:37.800
And I'm going to say it's password.

4477
07:43:37.800 --> 07:43:39.543
But obviously, this is a terrible password.

4478
07:43:39.543 --> 07:43:41.657
And you should never use password as your password.

4479
07:43:41.657 --> 07:43:46.229
But for now, we're just going to leave it as password since I'm encrypting this big key anyways.

4480
07:43:46.277 --> 07:43:51.760
So we're going to encrypt it by passing the password process study and v dot private key password.

4481
07:43:51.760 --> 07:43:57.851
And we're also going to pass the private key, it's going to be ethers, it's going to be wallet dot encrypt.

4482
07:43:57.851 --> 07:44:01.920
We're also going to pass it process dot EMV dot private key.

4483
07:44:01.920 --> 07:44:04.998
Now let's go ahead and run this right now.

4484
07:44:04.998 --> 07:44:11.833
And then we'll console dot log out this encrypted JSON key and see what happens when we run this.

4485
07:44:11.833 --> 07:44:15.435
So to run this, we're going to do node, encrypt key.

4486
07:44:15.435 --> 07:44:15.575
js.

4487
07:44:15.575 --> 07:44:16.545
And hit enter.

4488
07:44:16.545 --> 07:44:23.932
And we'll see what happens when we console log it out this JSON object here is what our key looks like, encrypted.

4489
07:44:23.932 --> 07:44:28.362
So it's got the address this ID version, all this other stuff.

4490
07:44:28.362 --> 07:44:32.182
And all this other stuff is the encrypted version of this key.

4491
07:44:32.182 --> 07:44:42.900
If somebody gets into our account and they see this, they'll have to know the password to decrypt this private key, they'll need to know the password to decrypt this JSON object back into a private key.

4492
07:44:42.900 --> 07:44:47.084
So what we're going to do, now that we've encrypted it, we're going to save it.

4493
07:44:47.084 --> 07:44:59.166
So we'll do Fs dot write, file sync, we're going to pass it to dot slash dot encrypted key dot JSON, comma encrypted JSON key.

4494
07:44:59.278 --> 07:45:02.528
So we're saving it to a new file called dot encrypted key dot JSON.

4495
07:45:02.528 --> 07:45:06.153
And we're passing it this encrypted key that we just made.

4496
07:45:06.278 --> 07:45:15.544
So if we open up our file explorer, and we run this command, you'll see we get a new file called dot encrypted key dot JSON.

4497
07:45:15.544 --> 07:45:18.944
And it's this encrypted key here, which is awesome.

4498
07:45:18.944 --> 07:45:28.850
So now what we want to do in our dot Git ignore is add dot encrypted key dot JSON, so that we don't accidentally push this up to GitHub.

4499
07:45:28.850 --> 07:45:34.754
And now we have an encrypted key and we can go to our private key and delete this from our dot env file.

4500
07:45:34.754 --> 07:45:41.244
We can also delete our private key password from our WMV file so that the password isn't just hanging around in plain text.

4501
07:45:41.279 --> 07:45:43.442
Now that We have an encrypted key.

4502
07:45:45.279 --> 07:45:48.569
we can change the way that we actually get a wallet.

4503
07:45:49.279 --> 07:45:56.691
top, we're getting our wallet just by passing in the private key like this, we're not going to do that, we're going to use our encrypted key that we just created.

4504
07:45:56.691 --> 07:46:05.379
So we're going to do is we're going to say const encrypted JSON equals Fs dot read file sync.

4505
07:46:05.379 --> 07:46:20.586
That slash dot encrypted key dot JSON, comma UTF eight, this Fs dot read file sync is just going to read from our encrypted key dot JSON into this encrypted JSON variable here.

4506
07:46:20.586 --> 07:46:25.517
Next, we're going to create a wallet from this encrypted key.

4507
07:46:25.517 --> 07:46:35.079
We're gonna say let wallet equals new ethers dot wallet, dot from encrypted JSON sync.

4508
07:46:35.079 --> 07:46:48.517
And all these commands that we're working with ethers, we can of course, find them in the documentation from encrypted JSON sync takes the encrypted JSON and a password and returns a Wallet Object.

4509
07:46:48.517 --> 07:46:52.589
So we're going to pass it that encrypted JSON that we just read.

4510
07:46:52.589 --> 07:47:00.769
And then we're going to pass it password which we're going to do process dot EMP dot private key password.

4511
07:47:00.769 --> 07:47:07.725
And then finally, the reason I use let here is because now we have to connect this wallet back to our provider.

4512
07:47:07.725 --> 07:47:10.625
If you look here, we're not connecting our wallet with a provider.

4513
07:47:10.625 --> 07:47:16.422
When we make our transactions with our contract factory, we need to make sure the wallet knows about the provider here.

4514
07:47:16.422 --> 07:47:22.946
So we can just say wallet equals await wallet dot connect provider.

4515
07:47:22.946 --> 07:47:30.555
Now, if we run our deploy dot j s with our private key password as an environment variable, it should still deploy.

4516
07:47:30.555 --> 07:47:34.787
So we can do private key password equals password, which yes, we know is terrible.

4517
07:47:34.787 --> 07:47:50.002
But that's what we're using for now node deploy dot j s, we should get the same output we've been seeing this whole time and we do we're able to no longer have our private key in our dot env file not in plaintext anymore, it's in this encrypted key.

4518
07:47:50.002 --> 07:47:56.683
So that just in case somebody hacks our computer, they still won't be able to send in new transactions unless they know the password.

4519
07:47:56.683 --> 07:47:57.457
This is awesome.

4520
07:47:57.457 --> 07:48:07.618
One more thing to know, if you type history, if somebody got into your computer, a hacker could actually see private key password equals password in your bash history.

4521
07:48:07.618 --> 07:48:12.565
If you run history, dash c, you actually will clear your history.

4522
07:48:12.565 --> 07:48:20.589
Now if I type history, I can just see that the most recent command I wrote was history, this is really just some of the bare minimum for encryption and keeping your key safe.

4523
07:48:20.589 --> 07:48:25.873
And it might seem ridiculous that somebody might be able to hack your computer and read your encrypted private keys and everything.

4524
07:48:25.873 --> 07:48:38.473
But as your projects get bigger and bigger, it is really important to know about private key security and private key safety and, and for this course really just giving you the bare minimum here and showing you how to encrypt keys and how to be a little bit safer here.

4525
07:48:38.473 --> 07:48:46.192
Now for the rest of this course, we are going to be just using this syntax with our private key in a dot env file.

4526
07:48:46.280 --> 07:48:55.346
The reason why we're doing like this for the rest of the course is it is a little bit easier, I'm really hoping Hardhead add some additional features to make private key encryption much safer and also easier to use in the future.

4527
07:48:55.346 --> 07:48:56.412
And they probably will.

4528
07:48:56.412 --> 07:49:09.055
And the other reason that we're okay to do this here is because you've solemnly sworn that you're not going to use an account that has any real money in it for the duration of this course, you're only going to use private keys that have tests on Aetherium or are fake private keys like this one that we got from ganache.

4529
07:49:09.055 --> 07:49:22.131
In fact just to really hone this in in the smart contract kit slash full blocked in solidity course, Jas GitHub repo in the discussions tab, you go to announcements, I've created one called the dot end pledge.

4530
07:49:22.131 --> 07:49:29.246
Because recently I've seen too many people follow a tutorial that doesn't tell them about the security risks of doing this.

4531
07:49:29.246 --> 07:49:33.229
And I've made this dot EMV pledge, I would love everyone to jump on and read.

4532
07:49:33.281 --> 07:49:42.412
And if you agree, at the bottom, leave a comment saying I will be safe, I will be safe, make sure you read and you understand what's going on in here.

4533
07:49:42.412 --> 07:49:44.182
And I'm not doing this to scare you.

4534
07:49:44.281 --> 07:49:52.979
Because again, at the end of the day, if you use a Metamask that only has tests that funds for the duration of this course, you will never have to be worried because of your key gets compromised.

4535
07:49:52.979 --> 07:49:54.121
It's just test it.

4536
07:49:54.121 --> 07:49:59.156
So who cares? This is if you're using a meta mask or you're working with a meta mask that has real funds.

4537
07:49:59.156 --> 07:50:03.055
So I'm going to read up the pledge because it is really important.

4538
07:50:03.055 --> 07:50:05.603
You understand this when you're working with real funds.

4539
07:50:05.603 --> 07:50:10.625
And if you're like, Hey, I'm not working with real funds, I don't care, great move past this, whatever.

4540
07:50:10.625 --> 07:50:16.471
But when you do work with real funds, when you do decide, hey, I actually want to deploy this to a real network.

4541
07:50:16.471 --> 07:50:18.330
Now I need real money to do that.

4542
07:50:18.330 --> 07:50:19.969
Come back to this pledge.

4543
07:50:19.969 --> 07:50:24.531
Scroll the bottom say I will be safe and make sure you read and you understand this.

4544
07:50:24.531 --> 07:50:35.197
Okay, so the pledge is, I solemnly swear that I will never place a private key or secret phrase or pneumonic in a dot env file that is associated with any real funds.

4545
07:50:35.197 --> 07:50:41.282
Basically, you basically never have your private key or your pneumonic phrase, in plain text, anywhere.

4546
07:50:41.282 --> 07:50:49.068
You'll all only place private keys in a web file that only have tested e FF link or other cryptocurrencies.

4547
07:50:49.068 --> 07:50:53.082
Because again, if your private key has only test net funds, then that's great.

4548
07:50:53.082 --> 07:51:07.832
I don't care, we are aware that if we forget a dot Git ignore, and we push our key phrase to GitHub, even for a split second, or even show our key slash phrase on the internet, wherever it may be for a split second, it should be considered compromised.

4549
07:51:07.832 --> 07:51:10.340
And you should remove all funds immediately.

4550
07:51:10.340 --> 07:51:21.427
So even if you deploy your private key to a website, and then immediately delete your website and think, Oh, nobody probably got to it, you should consider that private key compromised, and you should remove all your funds.

4551
07:51:21.427 --> 07:51:23.467
And again, this is just for real funds.

4552
07:51:23.467 --> 07:51:25.832
If your private key was only tested, funds gets compromised.

4553
07:51:25.832 --> 07:51:30.832
Well, who cares? I do that all the time, you've been seeing me do that all the time, because it only has tested funds in it.

4554
07:51:30.832 --> 07:51:37.413
If at the end of this course, you want to steal all of my tests that funds I mean, have a blast, it would be annoying to me at worst.

4555
07:51:37.413 --> 07:51:42.560
If I'm unsure if my account has real funds in it, I will assume it has real funds in it.

4556
07:51:42.560 --> 07:51:47.904
So if you don't know if it has real funds, assume it has real funds, and you will not use it for developing purposes.

4557
07:51:47.904 --> 07:52:02.710
And then finally, I am aware that even if I hit Add Account on my meta mask or other eath wallet, I will get a new private key, but it will share the same secret phrase slash pneumonic of all the other accounts generated in the meta mask or other eath Wallet.

4558
07:52:02.710 --> 07:52:09.734
So if I'm in my meta mask here, and I hit Create account, I will get a new private key with the new account.

4559
07:52:09.734 --> 07:52:17.267
However, all of these accounts that I've created with this Create Account button have the exact same pneumonic phrase or secret phrase.

4560
07:52:17.267 --> 07:52:21.731
If I import an account with a private key, it's going to have a different pneumonic phrase.

4561
07:52:21.731 --> 07:52:25.861
But all of the ones that I generate inside the wallet are all going to have the same phrase.

4562
07:52:25.861 --> 07:52:26.492
Okay, great.

4563
07:52:26.492 --> 07:52:28.018
Hopefully that'll make sense.

4564
07:52:28.018 --> 07:52:29.713
I have some pledge additions here.

4565
07:52:29.713 --> 07:52:35.266
For this course, I will only use funds associated with a brand new never before use meta mask or other eath wallet.

4566
07:52:35.266 --> 07:52:45.057
Again, this is not to scare you, if you just work with a brand new meta mask, you don't have to worry about any of this and just refer back to this when you start looking at real money and real private keys.

4567
07:52:45.057 --> 07:52:51.181
I'm aware that my account associated with my private key is the same on test nets that it is on Main nets.

4568
07:52:51.181 --> 07:53:15.546
So like I was showing you, my private key on Rinkeby is going to be the same as my private key I'm on a main net, if I must use a private key associated with real funds in the future, until I am 100% sure what I am doing, I will always either use one of the encrypted methods that Patrick showed you some better encryption stuff that I didn't show or use the command line way to pass private keys and then delete the command line history right after.

4569
07:53:15.546 --> 07:53:19.655
If I'm never actually deploying anything to make that myself or work with a private key with real funds.

4570
07:53:19.655 --> 07:53:21.180
I do not need to be concerned.

4571
07:53:21.283 --> 07:53:22.217
Take a look at this.

4572
07:53:24.283 --> 07:53:24.944
you confident.

4573
07:53:27.283 --> 07:53:32.473
I'm saying this to instill confidence in you that these are some of the things that we want to think about.

4574
07:53:32.473 --> 07:53:33.044
Okay, great.

4575
07:53:33.044 --> 07:53:37.092
In here, I will be safe.

4576
07:53:37.283 --> 07:53:38.638
Boom, I will be safe.

4577
07:53:41.283 --> 07:53:43.425
Twitter, put this in a huge tweet thread.

4578
07:53:43.425 --> 07:53:43.960
Go for it.

4579
07:53:44.283 --> 07:53:51.819
more people who know about this, the more people who understand the security risks of their WMV files and their private keys, the better.

4580
07:53:51.819 --> 07:53:53.694
So thank you for listening to this.

4581
07:53:53.694 --> 07:53:57.231
I know I definitely belabor the point, but it is really important.

4582
07:53:57.284 --> 07:53:59.784
Let's continue with the course.

4583
07:54:02.284 --> 07:54:02.705
done here.

4584
07:54:05.284 --> 07:54:10.431
just to clean this all up right now when we're auto saving reason, the VS code plugin for us to auto format.

4585
07:54:10.431 --> 07:54:17.801
However, in the future, if anybody else comes across our repository, they might not have the Vyas code auto format or on.

4586
07:54:17.801 --> 07:54:20.534
So we want to give users a way to format their code.

4587
07:54:20.534 --> 07:54:22.827
So it matches the styles that we use.

4588
07:54:22.827 --> 07:54:26.265
So we have prettier the extension installed.

4589
07:54:26.265 --> 07:54:38.227
We can also add prettier as a Node js module that can tell other users who don't have a Vyas code exactly how to format both their JavaScript and the solidity.

4590
07:54:38.284 --> 07:54:43.336
There is a prettier plugin solidity located here, there will be a link to it in our GitHub repo.

4591
07:54:43.336 --> 07:54:58.939
And if we scroll down, we can see how to install with npm install dash dash save Dev, which again, we're just going to use yarn, so we're going to do yarn, add prettier, and then prettier plugin solidity.

4592
07:54:58.939 --> 07:55:04.509
So we're installing both prettier, and the solidity plugin for prettier.

4593
07:55:04.509 --> 07:55:08.398
And if we check our package, JSON, we can see that these two have been added.

4594
07:55:08.398 --> 07:55:15.606
And what we can do now is we can create a new file called dot prettier, R C.

4595
07:55:15.606 --> 07:55:20.122
And in this file, we can define some little curly braces.

4596
07:55:20.122 --> 07:55:31.962
And here, we can define what we want for both our solidity and for a JavaScript, so for example, our simple storage has a tab width of 412344 spaces.

4597
07:55:31.962 --> 07:55:35.703
Maybe we want to change that.

4598
07:55:35.703 --> 07:55:38.742
We want tab width to be two.

4599
07:55:38.742 --> 07:55:46.983
So we would save it here and come back to simple storage To save it here, and it would get auto formatted to r dot prettier RC.

4600
07:55:46.983 --> 07:55:57.427
So in our settings here, we have the default editor for solidity, our hard hat, solidity plugin, and the default for meta for JavaScript being the prettier vs.

4601
07:55:57.427 --> 07:56:11.006
Code one, when we add prettier RC in here, this file will take precedent over the default configuration, so long as we have downloaded the module in our node modules, which we can see it right here.

4602
07:56:11.006 --> 07:56:14.120
And we have this dot prettier rc file.

4603
07:56:14.285 --> 07:56:16.006
I'm going to keep the tab with form.

4604
07:56:17.285 --> 07:56:34.538
it to that one thing that we currently do have that I do not like is these semicolons at the end, so we're going to do semi boss, and I'm going to save this, come back to deploy it save and you'll see the semicolon automatically goes away.

4605
07:56:34.538 --> 07:56:42.336
I'm also going to add use tabs false, since I want to use spaces or spacing, and then single quote, false.

4606
07:56:42.336 --> 07:56:55.234
This way, we'll always use a double quote, instead of a single quote, in JavaScript, you can actually use the single quote or double quote, to define strings, but we're going to make it so that no matter what quote you use, it'll always be double quote.

4607
07:56:55.285 --> 07:57:01.300
And then for all your open source repos, and for all your projects that you make, you want to make a readme.

4608
07:57:01.300 --> 07:57:07.285
md readme files are generally where people put instructions or information about your project or anything like that.

4609
07:57:07.285 --> 07:57:22.841
This way, whenever anybody comes across your project, they'll know what it's about your readme dot MDs, our Markdown syntax again, remember how when we made that trial discussion, we use some interesting tips to format our solidity in our code here.

4610
07:57:22.841 --> 07:57:26.389
Well, that formatting process is the exact same for.

4611
07:57:26.389 --> 07:57:27.786
md files for markdown.

4612
07:57:27.786 --> 07:57:29.973
They're both going to use markdown.

4613
07:57:29.973 --> 07:57:37.995
In fact, if we hit Ctrl, Shift V, you'll enter preview mode for the markdown you'll see pound sign here in my preview of the hard hat.

4614
07:57:37.995 --> 07:57:40.730
This ethers simple storage FCC is huge.

4615
07:57:40.730 --> 07:57:43.714
And it looks like a heading at the top.

4616
07:57:43.714 --> 07:57:46.253
So Command Shift V to view your.

4617
07:57:46.253 --> 07:57:53.163
md files or or MIP Ctrl, Shift V for Windows and Linux users.

4618
07:57:53.286 --> 07:58:01.882
The last thing that we're going to do is we're going to deploy this to a test net and interact with this on a test net, we're going to use the Rinkeby test net.

4619
07:58:01.882 --> 07:58:07.777
But be sure to use whatever recommended test net the GitHub repository for this coerce recommends.

4620
07:58:07.777 --> 07:58:14.692
Now looking at our code, you might already have a good idea of how to actually make this slight change.

4621
07:58:14.692 --> 07:58:22.105
Based off of our last section, we know that all we need is an RPC URL and a private key and we can begin making transactions on a blockchain.

4622
07:58:22.105 --> 07:58:27.436
So we're probably going to need a rink B RPC URL, and a rinky private key.

4623
07:58:27.436 --> 07:58:41.777
Where can we find both of those, if you want to do everything on your own, and in full decentralized context, we could run a rink B version of geth, we could run it locally, and then just connect to our guest node, we're not going to be showing how to do this here.

4624
07:58:41.777 --> 07:58:44.238
However, this is 100%, something that you could do.

4625
07:58:44.238 --> 07:58:49.897
Instead, we're gonna use a third party RPC URL in the GitHub repo associated with this course.

4626
07:58:49.897 --> 07:58:56.008
Go to Lesson five, we can scroll down to get a link for alchemy.

4627
07:58:56.008 --> 07:59:05.565
Alchemy has a node as a service and allows us to connect to any blockchain that they have support for two alternates might be quick node, Morales, or infura.

4628
07:59:05.565 --> 07:59:07.787
These all have node as a service options.

4629
07:59:07.787 --> 07:59:19.575
But we're going to work with Alchemy, because it's the one that I liked the best, we can go ahead and get started for free or login or create a new account, I'm going to go ahead and sign up with our hard hat Free Code Camp user.

4630
07:59:19.575 --> 07:59:23.254
And we're going to select the Ethereum blockchain ecosystem.

4631
07:59:23.254 --> 07:59:25.189
Let's go ahead and create our first app.

4632
07:59:25.287 --> 07:59:28.434
This is going to be we'll call it Free Code Camp.

4633
07:59:28.434 --> 07:59:28.893
RT hat.

4634
07:59:29.287 --> 07:59:38.445
app name will be ethers, simple storage, FCC, and the network is where we're going to choose rink B.

4635
07:59:38.445 --> 07:59:45.703
But you can see in here, we can actually choose more than just rink B, we can choose really Kovan, rink B, ropsten.

4636
07:59:45.703 --> 07:59:50.382
And layer twos like arbitrage and optimism, we're going to be using rink B.

4637
07:59:50.382 --> 07:59:52.474
So let's go ahead and create this app.

4638
07:59:52.474 --> 07:59:55.811
We're going to choose the free plan and hit Continue.

4639
07:59:55.811 --> 07:59:58.171
We're going to skip adding payments.

4640
07:59:58.171 --> 08:00:02.483
If you want to tweet your referral code, feel free to tweet your referral code.

4641
08:00:02.483 --> 08:00:03.860
We're going to skip for now.

4642
08:00:03.860 --> 08:00:06.172
And we're going to keep it at capped capacity.

4643
08:00:06.172 --> 08:00:08.631
Since we don't have a we don't have a key in here.

4644
08:00:08.631 --> 08:00:13.693
And then how did you hear about us go ahead and give me that shout out at Patrick and Free Code Camp and then hit Let's go.

4645
08:00:13.693 --> 08:00:22.524
Now we get to the alchemy dashboard, where we can see a ton of information about our node and different ways to connect to the nodes and and stuff like that.

4646
08:00:22.524 --> 08:00:33.838
This is going to be really similar to to this RPC server endpoint of ganache, except it's going to be a connection, except it's going to be a connection to a real test net or real main net.

4647
08:00:33.838 --> 08:00:38.884
What we can do now is we can select our our app that we just made.

4648
08:00:38.884 --> 08:00:40.494
And we can hit View key.

4649
08:00:40.494 --> 08:00:45.716
And we can see here we get an API key Key, we add an HTTP endpoint and we also get a WebSocket.

4650
08:00:45.716 --> 08:00:48.703
We're only concerned with the HTTP endpoint.

4651
08:00:48.703 --> 08:00:52.583
This is going to be our RPC URL that connects to rink B.

4652
08:00:52.583 --> 08:00:57.960
So what we can do now is we can copy this and come over to our Visual Studio code.

4653
08:00:57.960 --> 08:01:03.771
And in our dot env, we can substitute these out for their actual tests and values.

4654
08:01:03.771 --> 08:01:09.042
So for RPC URL, we're going to delete this and replace it with our Rigby RPC row.

4655
08:01:09.042 --> 08:01:17.697
And now how do we get a private key for an actual test set that has actual rank be on it? Well, here is where we can use our meta masks.

4656
08:01:17.697 --> 08:01:25.988
So back in your browser, go over to your meta mask, select the three dots, go to Account Details, export private key.

4657
08:01:25.988 --> 08:01:35.667
And this is where you can export your private key, type in your password and boom, you now have your private key for your account on meta mask.

4658
08:01:35.667 --> 08:01:43.046
Now remember, please, please, please don't continue with a meta mask that has actual money in it.

4659
08:01:43.046 --> 08:01:53.088
A quick way to check is by going to your networks tab and seeing if on any of the main nets or the networks with actual money in it, you see any money, I don't have any money in this.

4660
08:01:53.088 --> 08:01:53.999
So I know I'm good to go.

4661
08:01:53.999 --> 08:01:57.377
If you have tests that money, that's fine, because that's fake money anyways.

4662
08:01:57.377 --> 08:02:03.021
And again, most browsers have a profile mechanism where you can create a new profile for you to use.

4663
08:02:03.021 --> 08:02:09.271
But here now that I've copied my private key, we can come back to our Visual Studio code, paste the key in here.

4664
08:02:09.271 --> 08:02:13.185
And now I have a private key that has actual rink be in it.

4665
08:02:13.185 --> 08:02:13.736
Awesome.

4666
08:02:13.736 --> 08:02:24.495
And remember, if you ever get low, just come over to faucets dot chain dot link slash Rigby get some tests eath I'm not a robot will send the request.

4667
08:02:24.495 --> 08:02:31.130
Now that we have our private key in our rink being here, we can now try to run this on an actual test.

4668
08:02:31.130 --> 08:02:41.689
Net, we look at our code, we see we're grabbing an RPC URL, which is going to be from r dot end, we're grabbing a private key which is going to be from our daughter Yun V, which points to our rink D Metamask.

4669
08:02:41.689 --> 08:02:43.617
And our rink B blockchain.

4670
08:02:43.617 --> 08:02:50.089
So let's just add a console dot log under our contract deployment so that we know what address it's at.

4671
08:02:50.089 --> 08:03:00.901
So we'll do console dot log, we'll do some string interpolation, contract, address, contract dot address.

4672
08:03:00.901 --> 08:03:02.271
All right, great.

4673
08:03:02.271 --> 08:03:04.966
Now let's go ahead and run this.

4674
08:03:04.966 --> 08:03:07.508
So we'll do node deploy dot J.

4675
08:03:07.508 --> 08:03:11.513
S deploying Please wait, you'll notice this takes a lot longer.

4676
08:03:11.513 --> 08:03:24.082
Because we're deploying to a test net instead of our own fake local blockchain, test nets and real networks often will take a little bit longer because they need to wait for the blocks to propagate the transaction to go through, etc.

4677
08:03:24.082 --> 08:03:29.224
But after a brief delay, we will indeed see that we get a contract address here.

4678
08:03:29.289 --> 08:03:30.482
And we have a current favorite number.

4679
08:03:31.289 --> 08:03:38.715
slow again, because we're waiting for our next transaction to go through to update the number and boom, looks like we've successfully updated it.

4680
08:03:38.715 --> 08:03:47.616
Now something that's important to know if ever you run command, and you want to kill it, you can do Ctrl C, and that will stop it.

4681
08:03:47.616 --> 08:03:52.543
So any command in the terminal that you want to just abort Ctrl.

4682
08:03:52.543 --> 08:03:55.648
C is your Get Out of Jail Free card and that will kill it.

4683
08:03:55.648 --> 08:03:57.239
That'll stop it wherever it is.

4684
08:03:57.239 --> 08:03:59.950
So we'll use Ctrl C a lot in the future.

4685
08:03:59.950 --> 08:04:14.647
So now let's grab this contract address and go over to Frank V ether scan and paste it in, we can see our two transactions here, we can see we have a contract creation.

4686
08:04:14.647 --> 08:04:17.605
And we can also see we call a store function.

4687
08:04:17.605 --> 08:04:18.727
This is awesome.

4688
08:04:18.727 --> 08:04:25.193
We've successfully deployed a contract to the wrinkly chain using our own code.

4689
08:04:25.193 --> 08:04:28.918
Congratulations, this is massive.

4690
08:04:28.918 --> 08:04:33.979
Now on ether scan, we actually can verify and publish our contract code.

4691
08:04:33.979 --> 08:04:41.090
What is verifying and publishing your code? Well, right now, our code looks like a huge gerbil of bytecode.

4692
08:04:41.090 --> 08:04:50.838
And anybody looking at our contract directly on chain will just see this huge jumble of bytecode, we can use a decompiler to try to decompile the bytecode into what it looks like in solidity.

4693
08:04:50.838 --> 08:04:55.027
But this can often take a long time and, and a lot of processing power.

4694
08:04:55.027 --> 08:05:02.734
So instead, we can just make it much easier by verifying and publishing the code ourself, you go ahead and hit verify and publish.

4695
08:05:02.734 --> 08:05:08.994
We can scroll down and we can add compiler information to compile this on ether scan and other block explorers.

4696
08:05:08.994 --> 08:05:13.665
This is a single file compiler version is zero point 8.

4697
08:05:13.665 --> 08:05:13.754
7.

4698
08:05:13.754 --> 08:05:16.199
And it's open source is licensed is MIT.

4699
08:05:16.199 --> 08:05:17.991
Let's go ahead and continue.

4700
08:05:17.991 --> 08:05:23.798
And we're going to copy paste our solidity code into this large section.

4701
08:05:23.798 --> 08:05:24.191
Paste.

4702
08:05:24.191 --> 08:05:28.933
We don't have any constructor arguments so we can skip this section.

4703
08:05:28.933 --> 08:05:32.745
We don't have any libraries or any other miscellaneous settings.

4704
08:05:32.745 --> 08:05:37.874
So we'll select I'm not a robot and we'll hit verify and publish.

4705
08:05:37.874 --> 08:05:40.991
You might have to wait a few minutes, but awesome.

4706
08:05:40.991 --> 08:05:43.719
Our contract was successfully compiled.

4707
08:05:43.719 --> 08:05:49.431
Now if we go back to contract source code, we can see all the code in here.

4708
08:05:49.431 --> 08:05:58.224
And if we grab our contract address, place it into place into the search now, and we go to contract, we get a little green checkmark.

4709
08:05:58.291 --> 08:06:02.215
And we can see, anybody can now read our source code.

4710
08:06:02.291 --> 08:06:10.385
Additionally, those buttons that we saw and remix for reading from our contract, and writing to our contract, are in this read contract and this write contract.

4711
08:06:10.385 --> 08:06:17.613
If we read the contract, and we retrieve the most recent number, we do indeed see that we have seven here because we recently stored seven.

4712
08:06:17.613 --> 08:06:29.711
Awesome, quick note, this might already be verified for you, since ether scan might get smart enough to notice that a lot of people are deploying the same bytecode it's already verified for you just go ahead and walk through these steps anyways.

4713
08:06:29.711 --> 08:06:36.541
Now the code verification we just did was pretty simple and straightforward, because our code was pretty simple and straightforward.

4714
08:06:36.541 --> 08:06:42.087
Using larger and more complex code can make the verification process a little bit harder.

4715
08:06:42.087 --> 08:06:45.597
Additionally, we don't always want to have to click buttons on ether scan.

4716
08:06:45.597 --> 08:06:48.225
To verify our code, we want to do it programmatically.

4717
08:06:48.225 --> 08:07:02.629
So in later sections, we'll learn how to verify all of our code directly through our code editor, you can imagine the process is this easy for deploying to any EVM chain in our alchemy, we could easily create a new app and change our network.

4718
08:07:02.629 --> 08:07:09.325
And you could see how easy it would be to just switch out this RPC URL and your private key to work on a different chain.

4719
08:07:09.325 --> 08:07:13.775
This process is also the same for harmony Phantom, avalanche, etc.

4720
08:07:13.775 --> 08:07:24.818
And if we wanted to switch chains, we would just switch the RPC URL and switch the private key, and everything else would stay exactly the same.

4721
08:07:24.818 --> 08:07:34.207
Now, Alchemy also shows us and can teach us a lot about transactions and about things that are going on behind the scenes, including a concept called the mempool.

4722
08:07:34.207 --> 08:07:39.647
To help us understand a little bit more about those transactions that we just sent, and how to work with Alchemy.

4723
08:07:39.647 --> 08:07:45.238
To see more about our transactions, we have Albert from the alchemy team to give us a little demonstration.

4724
08:07:45.292 --> 08:07:54.895
Hello, Albert here from alchemy, I'm that guy in tech on Twitter, feel free to follow if you want to engage and ask any questions about this section of the video.

4725
08:07:54.895 --> 08:08:02.240
But super excited to join Patrick here to explain a little bit of what goes on behind the scenes when you are using alchemy to submit a transaction.

4726
08:08:02.292 --> 08:08:15.201
And we have a ton of tools to actually provide a window of visibility into what's going on so that you can actually debug in case there are usage errors on your website, or there are pending transactions that are stuck.

4727
08:08:15.201 --> 08:08:19.625
Whatever it is, we provide that window into the data that you control.

4728
08:08:19.625 --> 08:08:22.662
Remember that all the transactions that you submit are recorded on the blockchain.

4729
08:08:22.662 --> 08:08:26.529
They're not controlled by alchemy, they're not controlled by any other service provider.

4730
08:08:26.529 --> 08:08:32.212
We are just a window, we're just the plumbing the piping to be useful to you.

4731
08:08:32.292 --> 08:08:34.324
So let me show you exactly what that means.

4732
08:08:35.292 --> 08:08:36.525
bunch of applications in my dashboard.

4733
08:08:37.292 --> 08:08:39.986
there are different projects that I've used over time.

4734
08:08:40.292 --> 08:08:45.372
one is the most recently active, and it is the one that I have currently set up to connect to my meta mask.

4735
08:08:45.372 --> 08:08:47.533
So actually use a custom RPC provider here.

4736
08:08:47.533 --> 08:08:49.767
And let me make my face a little smaller.

4737
08:08:49.767 --> 08:08:52.885
And you can see here, I've misspelled Rinkeby.

4738
08:08:52.885 --> 08:08:58.708
But this right now, my my network is actually connected to the Rinkeby test network via alchemy.

4739
08:08:58.708 --> 08:09:00.800
So this is actually this application.

4740
08:09:00.800 --> 08:09:07.361
So if I click into here in the dashboard, you can see here, a bunch of really interesting statistics, this is the first thing that you'll probably use.

4741
08:09:07.361 --> 08:09:16.768
If you're trying to understand more about your application, you'll go here and you can see how many compute units per second your application is currently using.

4742
08:09:16.768 --> 08:09:21.072
And this is kind of great for specifically alchemy usage, understanding.

4743
08:09:21.072 --> 08:09:27.935
But then this is also really useful to see like, what's the median response time, and so 33 milliseconds is pretty good.

4744
08:09:27.935 --> 08:09:34.543
If that starts to increase, then you might want to figure out, you know, what's going on here, success rate, it has been kind of low.

4745
08:09:34.543 --> 08:09:39.714
So that is a clue for me to click on this tab to view recent invalid requests.

4746
08:09:39.714 --> 08:09:52.325
And that I can actually see oh, there's a bunch of failed transactions where the transaction has already been sent or the nonce is too low, or whatever it is, I can actually use this tab to debug.

4747
08:09:52.325 --> 08:09:54.193
So that success rate is pretty useful.

4748
08:09:54.293 --> 08:09:56.228
Throughput that's been limited.

4749
08:09:58.293 --> 08:10:02.631
requests or your website is getting spammed, you might start getting some requests blocked.

4750
08:10:02.631 --> 08:10:13.819
So that's what's useful to view their concurrent requests over here, success rate in the past 24 hours versus the past one hour, the total number of requests in the last 24 hours.

4751
08:10:13.819 --> 08:10:19.879
And this is different than compute units, because each request can have a different level of computing cost.

4752
08:10:19.879 --> 08:10:23.189
And computing cost as measured by compute units.

4753
08:10:23.189 --> 08:10:27.143
Total requests is just the actual number of absolute requests.

4754
08:10:27.143 --> 08:10:29.793
And then of course, the number of invalid request.

4755
08:10:29.793 --> 08:10:30.150
Cool.

4756
08:10:30.150 --> 08:10:44.055
So one thing I do want to show you that's interesting is when I do submit a transaction, and I actually have one right here, I want to send so let's transfer between my accounts, and I'm just gonna send it to tiny amount of Rinkeby eath.

4757
08:10:44.055 --> 08:10:56.228
But I'm going to purposefully edit my gas fees to be super, super low so that the node will actually not muck send the transaction to be mined, or there are no miners that will actually pick it up.

4758
08:10:56.228 --> 08:11:00.606
So you can see here I've divided the the priority fee and the max fee by a ton.

4759
08:11:00.606 --> 08:11:01.731
So it's super low.

4760
08:11:01.731 --> 08:11:07.047
And it might confirm that in the MME Max UI, you'll see that the transaction has been pending for a bit.

4761
08:11:07.047 --> 08:11:09.015
And we'll go over to this mempool tab.

4762
08:11:09.015 --> 08:11:11.900
This is another really useful visualization.

4763
08:11:11.900 --> 08:11:26.627
And what the mempool is, is a kind of a holding ground, I like to think of it as the waiting room of a restaurant, where if you're a transaction, and you're waiting to get mined, the mempool is kind of like the waiting room where you're waiting to get seated.

4764
08:11:26.627 --> 08:11:36.484
So there are different statuses for your each of your transactions, the ones that you always want to see are the mines transactions, because that says that your transaction is successful.

4765
08:11:36.484 --> 08:11:38.198
And it's now part of the blockchain.

4766
08:11:38.294 --> 08:11:42.494
Now, the mempool, every node has its own, you know, holding ground.

4767
08:11:42.494 --> 08:11:44.227
So I can actually show you this quick visualization.

4768
08:11:44.294 --> 08:11:47.638
Remember, blockchains are run by a network of nodes.

4769
08:11:48.294 --> 08:11:53.766
node or each computer that's running the theorem, software maintains a copy of the blockchain.

4770
08:11:53.766 --> 08:11:58.246
And as a developer, you have to use these nodes to make requests to the blockchain.

4771
08:11:58.294 --> 08:12:03.261
Now you can use alchemy, you can use another RPC provider, you can spin up your own node if you want to.

4772
08:12:03.261 --> 08:12:07.010
But regardless, you need to use a node to communicate with the chain.

4773
08:12:07.010 --> 08:12:14.711
Now each node beyond having a copy of the entire blockchain state, it also has a local memory of transaction.

4774
08:12:14.711 --> 08:12:16.618
And that's called mempool.

4775
08:12:16.618 --> 08:12:22.961
So if there are pending transactions that are waiting to be mined, you can consider them as being in the mempool.

4776
08:12:22.961 --> 08:12:24.617
Now that's what we're looking at right here.

4777
08:12:24.617 --> 08:12:36.465
If we click on the app that I am currently using for my Metamask RPC, then you can see here that there are, this is not the right one, this one is the right one for wrinkling.

4778
08:12:36.465 --> 08:12:47.600
For all the transactions here, you can see some more drop in placed somewhere mind and there's one that's pending, and this pending, one actually matches up with the one that is pending, here, it's being sent to 0x, C, BB.

4779
08:12:47.600 --> 08:12:52.622
And if we click on this transaction hash, you get all the information that you need to debug.

4780
08:12:52.622 --> 08:12:59.491
So you can see here that it's from my current address, 0x, five F, and then it's two 0x, C, BB.

4781
08:12:59.491 --> 08:13:02.778
And here's the value that I'm trying to send.

4782
08:13:02.778 --> 08:13:06.214
Here's the gas fee that I've attached to this transaction.

4783
08:13:06.214 --> 08:13:10.095
And you'll notice that that is super low, even for the Rinkeby test network.

4784
08:13:10.095 --> 08:13:18.617
So knowing this, and seeing, wow, this transaction has been pending for one minute and 46 seconds, it was sent at this time, I should probably fix that.

4785
08:13:18.617 --> 08:13:24.456
And so over here, you can actually use the metamath RPC, meta meta mask API.

4786
08:13:24.456 --> 08:13:25.423
And speeded up.

4787
08:13:25.423 --> 08:13:30.456
And then I'm just going to use the auto high speed up to update the gas fees.

4788
08:13:30.456 --> 08:13:38.645
And then if we go back to our dashboard back to our application, you can see that there are some new recent invalid requests.

4789
08:13:38.645 --> 08:13:46.723
And this is because we've resubmitted a transaction, and then in their recent requests we have, let's refresh that real quick.

4790
08:13:46.723 --> 08:13:50.618
You can see that we are sending a raw transaction, this one's already known.

4791
08:13:50.618 --> 08:13:56.646
And there's another one before, but it that's resulting in a get transaction receipt that is successful.

4792
08:13:56.646 --> 08:14:03.664
And then if we go back to the mempool, you can see boom, no more pending transactions only dropped and replaced and mined.

4793
08:14:03.664 --> 08:14:10.874
So this transaction nonce number five is now successful, and you're on your way to developing and maintaining the rest of your application.

4794
08:14:10.874 --> 08:14:12.821
So yeah, thanks hope that was useful.

4795
08:14:12.821 --> 08:14:19.102
Let me know if you have any questions.

4796
08:14:19.296 --> 08:14:25.594
Now, other than the TypeScript portion, which I'll do at the end, you've successfully completed this section.

4797
08:14:25.594 --> 08:14:27.233
And wow, you've learned a ton.

4798
08:14:27.233 --> 08:14:29.957
Let's do a quick review of everything that we've learned.

4799
08:14:29.957 --> 08:14:37.876
Well, first, we've learned how to create new projects with Node js, we've learned what the node keyword does and how we can use the node keyword.

4800
08:14:37.876 --> 08:14:47.635
To run JavaScript in our local development environment, we learned that we can add different dependencies of external packages into our local package using yarn or NPM.

4801
08:14:47.635 --> 08:15:04.740
And we can see those dependencies added in package dot JSON, we know that they've been installed because they get installed into the node modules folder, we can also create a script section where we can minimize long commands that we need to run into a single keyword, like compile for example, we can just run yarn compile.

4802
08:15:04.740 --> 08:15:14.787
To compile all of our code, we learned the basic setup of our JavaScript scripts, we import our packages at the top, we have some main executor function at the bottom.

4803
08:15:14.787 --> 08:15:29.881
And then we have our main function in the middle, we use the async keyword so that our function can use asynchronous programming, and we get access to the await keyword, which basically means Hey, wait for this promise to finish doing its thing.

4804
08:15:29.881 --> 08:15:41.139
We're able to connect to any blockchain we want using an RPC URL, and then we're able to connect our provider to a wallet or a private key in ethers by doing something like this.

4805
08:15:41.139 --> 08:15:58.055
Speaking of So we've learned about the ethers package, which is a tool that makes our life a lot easier to interact with the blockchain in JavaScript, if we decide to, we've also learned we can encrypt our private keys so that even if our computers get hacked, our private keys aren't lying around in plaintext.

4806
08:15:58.055 --> 08:16:01.852
And we've learned how to run scripts from our encrypted keys.

4807
08:16:01.852 --> 08:16:12.035
We've learned how to get the ABI or the application binary interface, and the binary of our code to deploy to a blockchain, we've learned how to deploy our contracts to a blockchain programmatically.

4808
08:16:12.035 --> 08:16:15.533
And then we've learned how to interact with our contracts programmatically as well.

4809
08:16:15.533 --> 08:16:21.230
Additionally, we've learned how to add a default editor in our settings dot JSON of our VS code.

4810
08:16:21.230 --> 08:16:32.649
But we've also learned how to override those settings by adding prettier using a dot prettier rc file this way, we can auto format our code to make it look a lot nicer and much easier to read.

4811
08:16:32.649 --> 08:16:38.756
Finally, we learned how to deploy one of these contracts to a real test net or a real network.

4812
08:16:38.756 --> 08:16:43.404
And then we finally learned the manual way to verify our contract source code.

4813
08:16:43.404 --> 08:16:45.690
Like I said, we're going to learn a lot of shortcuts.

4814
08:16:45.690 --> 08:16:48.909
And a lot of ways to make this all a little bit easier in coming sections.

4815
08:16:48.909 --> 08:16:59.619
Oh, you have done a phenomenally to reach this section, give yourself a pat on the back, take a break, go for a lap, and feel really proud about yourself that you made it this far, we've got a lot more to go.

4816
08:16:59.619 --> 08:17:02.195
But you have come a phenomenally long way.

4817
08:17:02.195 --> 08:17:03.279
Congratulations.

4818
08:17:03.279 --> 08:17:09.207
Or take that five to 10 minute break and come back when you're ready.

4819
08:17:09.297 --> 08:17:13.125
Now the one thing left I want to show you all is the TypeScript addition to this.

4820
08:17:13.125 --> 08:17:21.598
However, if you're not interested in the TypeScript edition, which you don't have to be, then you're done, there's only a couple of changes we need to make to make this TypeScript compatible.

4821
08:17:21.598 --> 08:17:24.647
First, of course, we're going to change our deploy.

4822
08:17:24.647 --> 08:17:31.765
ts and encrypt key, we're going to change our deploy and our encrypt key from dot j s two.

4823
08:17:31.765 --> 08:17:31.926
ts.

4824
08:17:31.926 --> 08:17:36.996
And then we're also going to swap these requires out for imports.

4825
08:17:36.996 --> 08:17:47.234
So we're going to import ethers from ethers, we're going to import star as Fs from Fs extra.

4826
08:17:47.234 --> 08:17:52.588
And then we're going to import dot TMP slash config.

4827
08:17:52.588 --> 08:18:02.072
And then we're just going to copy these, and we're gonna come over and paste them into here, deleting or commenting out the requires, okay, great.

4828
08:18:02.072 --> 08:18:04.388
Now, if we try to run Node deploy.

4829
08:18:04.388 --> 08:18:09.199
ts, we're going to get cannot use input statement outside of a module.

4830
08:18:09.199 --> 08:18:17.412
In JavaScript, if we'd want to use an import statement outside of a module, we'd come in here and do some like type module like that.

4831
08:18:17.412 --> 08:18:21.139
But in TypeScript, we actually don't even need that.

4832
08:18:21.139 --> 08:18:24.369
All we need to do is run this in TypeScript note.

4833
08:18:24.369 --> 08:18:28.937
So to add TypeScript, we're going to do yarn, add TypeScript.

4834
08:18:28.937 --> 08:18:31.887
And we're also going to add TS node.

4835
08:18:31.887 --> 08:18:34.710
TS node is the TypeScript edition of node.

4836
08:18:34.710 --> 08:18:38.504
So now that we've added that we can try a TS node deploy.

4837
08:18:38.504 --> 08:18:38.641
ts.

4838
08:18:38.641 --> 08:18:41.609
And we're still going to run into an error.

4839
08:18:41.609 --> 08:18:45.316
And if you scroll up, we're gonna get a couple errors here.

4840
08:18:45.316 --> 08:18:53.502
We're gonna say, could not find a declaration file for Module Fs extra, we need to add the TypeScript version of them.

4841
08:18:53.502 --> 08:18:57.392
So we're gonna do yarn at types slash Fs extra.

4842
08:18:57.392 --> 08:19:01.447
That, and if we run it again, it still shouldn't work.

4843
08:19:01.447 --> 08:19:02.447
But for a different reason.

4844
08:19:02.447 --> 08:19:04.584
Yes, we're gonna get something like this type.

4845
08:19:04.584 --> 08:19:06.944
Undefined is not assignable to type bytes.

4846
08:19:06.944 --> 08:19:16.061
Like the reason we get this is because process dot EMV private key in TypeScript technically, is type string, or undefined.

4847
08:19:16.061 --> 08:19:20.553
So we need to tell Typescript and and the Wallet Objects.

4848
08:19:20.553 --> 08:19:24.513
And the Encrypt function is looking for a type string, not string or undefined.

4849
08:19:24.513 --> 08:19:28.267
So we just need to tell TypeScript that this will not be undefined.

4850
08:19:28.267 --> 08:19:29.899
So we can just put a bang here.

4851
08:19:29.899 --> 08:19:37.095
And everywhere that we use process, study and be, oops, I got to do that on deploy, as well.

4852
08:19:37.095 --> 08:19:38.513
Bang, looks good.

4853
08:19:38.513 --> 08:19:41.997
Now that we've added everything in here, we run TS node deploy.

4854
08:19:41.997 --> 08:19:46.699
ts, we're gonna see the exact same output as we saw with just using regular node.

4855
08:19:46.699 --> 08:19:50.365
And as long as our private key password is in our dot env file.

4856
08:19:50.365 --> 08:19:52.502
If we run TS node and crypt key.

4857
08:19:52.502 --> 08:19:55.891
ts, we're gonna get the exact same setup as before.

4858
08:19:55.891 --> 08:19:58.361
And we're gonna get a new encrypted key dot JSON.

4859
08:19:58.361 --> 08:20:01.799
And that's all you need to do to make this TypeScript compatible.

4860
08:20:01.799 --> 08:20:07.971
And you should give yourself a huge round of applause for getting this far and learning what's going on underneath hardhat.

4861
08:20:07.971 --> 08:20:17.600
The next tool that we're going to learn and learning all about these transactions and how to interact with these blockchains this is absolutely massive, so huge.

4862
08:20:17.600 --> 08:20:19.109
Congratulations.

4863
08:20:19.299 --> 08:20:26.953
Alright, so now that we've learned about ethers js and how to do some more raw JavaScript coding, we're now going to move into hardhat.

4864
08:20:26.953 --> 08:20:31.523
We saw with our ether symbol storage that deploying a contract can take a lot of code.

4865
08:20:31.523 --> 08:20:34.300
And there's a number of things we didn't even do in here.

4866
08:20:34.300 --> 08:20:37.146
Like we didn't save where this contract was deployed.

4867
08:20:37.146 --> 08:20:40.252
So we'd have to go remember where it was deployed every time.

4868
08:20:40.252 --> 08:20:42.565
Instead of having it just added programmatically.

4869
08:20:42.565 --> 08:20:45.961
We didn't write any tests here, and we'd have to build our own testing infrastructure.

4870
08:20:45.961 --> 08:20:48.414
Maybe we want to make this a cross chain application.

4871
08:20:48.414 --> 08:20:56.987
And we want more than just one private key and RPC URL, you can absolutely work with your smart contracts in JavaScript purely through ethers and small scripts like this.

4872
08:20:56.987 --> 08:21:00.461
But we want a more robust framework for doing all this.

4873
08:21:00.461 --> 08:21:03.170
And that's where hard hat comes into play.

4874
08:21:03.300 --> 08:21:08.721
Hardhead is easily one of the most, if not the most popular smart contract development framework out there.

4875
08:21:08.721 --> 08:21:14.726
It's used by massive several billion dollar protocols like Ave uniswap, sushi swap, and more.

4876
08:21:14.726 --> 08:21:16.791
In fact, I recently did a poll on Twitter.

4877
08:21:16.791 --> 08:21:27.972
And even though a lot of my content has been more brownie and Pythonic, Hardhead was well and beyond the most popular framework, and Hardhead has quickly become one of the most advanced frameworks out there.

4878
08:21:27.972 --> 08:21:38.393
Hardhead is a development environment, which allows for JavaScript based development, kind of like what we saw with ethers, it gives us even more tools to integrate our code with common things that we want to do.

4879
08:21:38.393 --> 08:21:42.086
It's incredibly extensible, and it has really nice debugging features as well.

4880
08:21:42.086 --> 08:21:44.053
And it's just an overall fantastic tool.

4881
08:21:44.053 --> 08:21:45.873
So let's go ahead and let's jump in.

4882
08:21:45.873 --> 08:21:50.250
If you want to follow along with the code, come over to the GitHub repo and scroll down.

4883
08:21:50.300 --> 08:21:54.061
Lesson Six heart had simple storage, and all the code is located here.

4884
08:21:54.061 --> 08:22:06.900
And a quick note for the future ever, you want to just download all the code from one of these repositories, the way you can do that is by doing a git clone, what you do is you come to the folder that you want to put this code in, and you run git clone.

4885
08:22:06.900 --> 08:22:11.419
And then you grab the URL that you want to clone, paste it in.

4886
08:22:11.419 --> 08:22:23.059
Now, you can CD into your new folder here that has everything downloaded directly from GitHub, but only do that as a backup or to just download the code yourself.

4887
08:22:23.059 --> 08:22:25.001
But for now, just follow along with me.

4888
08:22:25.001 --> 08:22:26.201
Right, so let's do this.

4889
08:22:26.301 --> 08:22:29.139
Let's create our next project using hard hat.

4890
08:22:30.301 --> 08:22:34.926
we're going to be making is called Hard Hat, simple storage dash FCC or Free Code Camp.

4891
08:22:34.926 --> 08:22:39.037
This is going to be us working again with that simple storage contract.

4892
08:22:39.037 --> 08:22:47.701
But in hard hat, we're going to show you a ton of the fantastic tools that we can use to make our coding life way easier.

4893
08:22:47.701 --> 08:22:53.497
So I'm in a brand new VS code, and we're going to create a new folder for us to run all this.

4894
08:22:53.497 --> 08:23:04.169
Now what you can do to create a brand new folder is you once again you can do MK dir, hard hat, simple storage of CC.

4895
08:23:04.301 --> 08:23:09.301
Now we can cd into hard hat simple storage of CD, and type code, period.

4896
08:23:09.301 --> 08:23:14.916
And this will open up a new Visual Studio code inside of that folder.

4897
08:23:14.916 --> 08:23:20.650
Now if we open up our terminal, you'll see that we are indeed inside that folder.

4898
08:23:20.650 --> 08:23:27.775
Now if that doesn't work for you, you can still of course to File, Open folder and select the folder you'd like to open.

4899
08:23:27.775 --> 08:23:29.507
And you'll be inside of that folder.

4900
08:23:29.507 --> 08:23:44.846
Now that we have our folder setup for working with hard hat, we can begin setting up our environment to be incredibly professional using the hard hat framework got a link to the hard hat documentation inside our whole blockchain solidity course, yes, the hard hat documentation is phenomenal.

4901
08:23:44.846 --> 08:23:48.268
And I highly recommend everybody have it up as they go through the section.

4902
08:23:48.268 --> 08:23:55.646
Because it's going to give you pretty much everything that you need to know for working with hard hat, you can simply go ahead over to tutorial and get started.

4903
08:23:55.646 --> 08:24:03.474
If you want to pause the video here and read through the tutorial, I recommend doing so it'll give you a lot of information about how to work with hardhat.

4904
08:24:03.474 --> 08:24:04.531
And more about hardhat.

4905
08:24:04.531 --> 08:24:07.340
However, we're just going to jump right into setting up the environment.

4906
08:24:07.340 --> 08:24:10.571
We've already installed no Gs on Linux, or Mac OS.

4907
08:24:10.571 --> 08:24:15.492
And those of you who are using Windows, I set you up with WsL.

4908
08:24:15.492 --> 08:24:19.142
So you can just follow the Linux instructions.

4909
08:24:19.302 --> 08:24:23.391
Now to create a new hard hat project, you can actually just go ahead and run these steps right here.

4910
08:24:23.391 --> 08:24:37.159
Instead of NPM, we're going to be using yarn, but if you want to use NPM, you can absolutely do so the hard hat Doc's say run npm init dash dash, yes, we're just going to run yarn in it, which is going to create a new project for us in this folder.

4911
08:24:37.159 --> 08:24:44.682
So let's give it a name, which if we want it set to this hard hat symbol storage FF FCC, we just hit enter, we'll give it a version.

4912
08:24:44.682 --> 08:24:46.063
And when if we want it 1.

4913
08:24:46.063 --> 08:24:47.904
0 point oh, we just hit enter.

4914
08:24:47.904 --> 08:24:51.515
We're going to skip the description for now just by hitting enter.

4915
08:24:51.515 --> 08:24:53.968
And we're just going to hit Enter for this as well.

4916
08:24:53.968 --> 08:24:58.932
And for this as well enter for this as well and for this as well and over this as well.

4917
08:24:58.932 --> 08:25:00.762
Just to keep those as blanks.

4918
08:25:00.762 --> 08:25:11.452
And if we look in package json, we now see we have a name Hardhead symbol storage that FCC we have a version we have a main which we're actually going to delete the main and then we have a license as well.

4919
08:25:11.452 --> 08:25:13.875
yarn in it just sets up this package json for us.

4920
08:25:13.875 --> 08:25:18.592
Now we're going to do yarn, add dash dash dash of our app.

4921
08:25:18.592 --> 08:25:26.302
So far, we've just been running yarn add, and then whatever our package name is.

4922
08:25:26.302 --> 08:25:30.477
But for most of what we're doing, we really want to do yarn add dash dash Dev.

4923
08:25:30.477 --> 08:25:33.017
The reasons for this is a little bit nuanced.

4924
08:25:33.017 --> 08:25:36.124
But we can see some of the information on this StackOverflow question here.

4925
08:25:36.124 --> 08:25:39.945
The main difference is that dependencies are required to run your project.

4926
08:25:39.945 --> 08:25:43.641
Whereas dev dependencies are required only to develop.

4927
08:25:43.641 --> 08:25:51.771
For the most part, we're going to be doing just dash dash Dev, when we get to the front end portion of this course, we'll be installing more packages that we don't need just for development.

4928
08:25:51.771 --> 08:25:55.760
Now in the same directory where we install hard hat, you can run MPX hard hat.

4929
08:25:55.760 --> 08:26:01.795
So a quick note about MPX is that the yarn equivalent of NPM is just yarn.

4930
08:26:01.795 --> 08:26:06.139
So yarn goes NPM, the yarn equivalent of MPX is also yarn.

4931
08:26:06.139 --> 08:26:13.909
So pretty much anytime you see MPX, do something, you can just replace that MPX with yarn, and it'll do the exact same thing.

4932
08:26:13.909 --> 08:26:17.754
If you want to run this with NPM or MPX, you can absolutely do that as well.

4933
08:26:17.754 --> 08:26:20.528
So for us, we're going to run yarn hardhat.

4934
08:26:20.528 --> 08:26:25.793
And we'll see we'll get prompted to actually start creating a hardhat project, run yarn hardhat.

4935
08:26:25.793 --> 08:26:30.593
And we'll get this wonderfully cute prompt right here and saying welcome to Hardhead.

4936
08:26:30.593 --> 08:26:38.641
What do you want to do, create a basic sample project, create an advanced sample project can advance some project uses type script or create an empty hardhat.

4937
08:26:38.641 --> 08:26:38.931
config.

4938
08:26:38.931 --> 08:26:39.027
js.

4939
08:26:39.027 --> 08:26:42.337
For us, we're just going to select create a basic sample project.

4940
08:26:42.337 --> 08:26:47.384
And this is going to give us all the boilerplate for a really simple hardhat project.

4941
08:26:47.384 --> 08:26:50.472
The hard hat project route is going to be this folder that we're in right now.

4942
08:26:50.472 --> 08:26:53.942
Do you want to add a Git dot Git ignore? Yes, we absolutely do.

4943
08:26:53.942 --> 08:26:56.204
Because we're going to be using dot env files.

4944
08:26:56.303 --> 08:27:07.779
Do you want to install this sample projects dependencies with yarn at nomic labs hard hat at a theory and waffle at Chai? We're going to go ahead and say yes, and I'll explain what all these dependencies are in a bit.

4945
08:27:07.779 --> 08:27:09.588
Let's go ahead and say yes for now.

4946
08:27:09.588 --> 08:27:14.350
And we're going to install all these dependencies.

4947
08:27:14.350 --> 08:27:26.229
Now, if we look in our package, JSON, we can see we've added a number of dependencies like nomic labs, Hardhead ethers, not MacLeods, Hardhead, waffle, Chai, Aetherium, waffle, and ethers.

4948
08:27:26.304 --> 08:27:29.490
Obviously, we're already familiar with ethers, but the rest of these might be a little new.

4949
08:27:29.490 --> 08:27:30.735
We'll talk about those later.

4950
08:27:30.735 --> 08:27:35.654
And great, we now have a sample hardhat boilerplate project.

4951
08:27:35.654 --> 08:27:38.004
Let's walk through what we just installed here.

4952
08:27:38.004 --> 08:27:45.116
The first thing we have is a contracts folder, which comes pre populated with greeted outsole is really minimalistic contract here.

4953
08:27:45.116 --> 08:27:49.649
Next, you'll see node modules, which of course is our installed JavaScript dependencies.

4954
08:27:49.649 --> 08:27:57.890
Something I want to know because it was really confusing to me when I first started working with this is some of these node modules start with an add sign, and then a lot of them don't.

4955
08:27:57.890 --> 08:28:07.437
What's the difference between those two, these outside node modules are known as scoped packages, which effectively allow NPM packages to be namespace or yarn packages.

4956
08:28:07.437 --> 08:28:12.504
This allows organizations to make it clear what packages are official and which ones are not.

4957
08:28:12.504 --> 08:28:17.507
For example, if a package has a scope at Angular, you know, it's published by the Angular core team.

4958
08:28:17.507 --> 08:28:27.240
So it's the same thing with this anything with AP ens domains we know is by the ens domains team, anything with abnormal Labs is going to be by the team that created hard hat.

4959
08:28:27.304 --> 08:28:37.659
So that's why this at nomic labs, hard hat ethers and at nomic labs, hard at Waffle has this at sign, because we know it's published by the nomic labs team, then we have a scripts section.

4960
08:28:37.659 --> 08:28:44.757
This is going to be where we're adding any and all of our scripts that we want to write like deploying contracts, interacting with contracts, etc.

4961
08:28:44.757 --> 08:28:46.210
And then we have a test folder.

4962
08:28:46.304 --> 08:28:48.500
We haven't started building any tests yet.

4963
08:28:49.304 --> 08:28:51.828
incredibly important for working with smart contracts.

4964
08:28:52.305 --> 08:28:57.271
sample test folder gives us a minimalistic test for testing our smart contracts.

4965
08:28:57.271 --> 08:29:03.371
We of course have Git ignore, which of course comes pre populated with some important things to ignore like Dotty and V.

4966
08:29:03.371 --> 08:29:08.105
And also node modules because node modules might get too huge push up to GitHub.

4967
08:29:08.105 --> 08:29:12.494
And one of the biggest changes here is it adds this hard hat.

4968
08:29:12.494 --> 08:29:13.011
config.

4969
08:29:13.011 --> 08:29:13.183
js.

4970
08:29:13.183 --> 08:29:25.250
This file even though it's minimalistic, right now, you can think of as the entry point for all the scripts that we write, it's the configuration file that determines how the rest of our code is going to work and interact with the blockchain.

4971
08:29:25.305 --> 08:29:28.605
Then of course, we have package dot JSON, we get started with a readme.

4972
08:29:28.605 --> 08:29:34.305
Remember how the first time we ran yarn hard hat, we were prompted with this Getting Started piece.

4973
08:29:34.305 --> 08:29:42.337
Now if we run yarn Hardhead, we're actually going to get output of all the different options and commands we can use with running hard hat.

4974
08:29:42.337 --> 08:29:50.741
Now, if you run into an issue where you run yarn, hard hat, and this pops up, but you don't see a hard hat.

4975
08:29:50.741 --> 08:29:51.068
config.

4976
08:29:51.068 --> 08:30:01.662
js in your folder, it likely means that there's a hard hat dot config dot j s in a higher level folder, or there's a node modules with hard hat in a higher level folder.

4977
08:30:01.662 --> 08:30:07.535
So if that happens, maybe CD down a directory and do a little LS and look to see if you've got a hard hat.

4978
08:30:07.535 --> 08:30:07.996
config.

4979
08:30:07.996 --> 08:30:10.765
js or node modules in earlier folder.

4980
08:30:10.765 --> 08:30:15.474
And because I've actually seen a number of engineers have a couple of different problems here.

4981
08:30:15.474 --> 08:30:21.256
My friend CAMI is going to explain A couple of different troubleshooting tips you can take to try to avoid these common errors.

4982
08:30:21.305 --> 08:30:24.620
As a developer the most annoying thing to deal with our environment set of issues.

4983
08:30:24.620 --> 08:30:25.883
My name is Camila Ramos.

4984
08:30:25.883 --> 08:30:30.237
I'm a DevRel engineer at edge node supporting the Graph Protocol.

4985
08:30:30.305 --> 08:30:34.406
And I'm going to show you how to solve two common problems that you might see when working on this project.

4986
08:30:34.406 --> 08:30:35.656
After installing hardhat.

4987
08:30:35.656 --> 08:30:42.559
And running the command and px hard hat in your new project folder, you're going to expect to get back a menu of options like this, but sometimes you're not going to get that back.

4988
08:30:42.559 --> 08:30:46.409
And when you run into this error, there is a solution for you.

4989
08:30:46.409 --> 08:30:51.628
And it usually just means that you have a config file somewhere that it shouldn't be, and deleting it will get rid of that error.

4990
08:30:51.628 --> 08:30:58.337
What you're going to do in order to find this file that you need to delete is run the command MPX hardhats space, hyphen, hyphen verbose.

4991
08:30:58.337 --> 08:31:04.560
And this is going to spit out where this file is if you have one, and it's going to tell you exactly where it is so that you can delete it.

4992
08:31:04.560 --> 08:31:12.240
After you've deleted this config file, you should be able to run MPX hardhat in your project folder and get back that many that we were expecting.

4993
08:31:12.306 --> 08:31:14.067
Another problem that is pretty common.

4994
08:31:15.306 --> 08:31:21.256
the time is forgetting to npm install, whenever you're working with a repo that other people have been working on on GitHub.

4995
08:31:21.306 --> 08:31:29.629
So let's say you're pulling down some code that you and some collaborators were working on together, and then suddenly, it's not working for you, you probably just need to npm install.

4996
08:31:29.629 --> 08:31:36.034
So in your terminal, go ahead and navigate to where this project is located and then run the command npm install.

4997
08:31:36.034 --> 08:31:49.767
If there are any new packages that were installed in the time that you weren't working on the code, those will get installed locally for you so that when you run the code, it will be able to run successfully.

4998
08:31:50.306 --> 08:32:00.358
What are some of the main things we can do with hardhat in its raw state here, these are some of the main tasks that we can run with hardhat different tasks or just different commands, we can run with hardhat.

4999
08:32:00.358 --> 08:32:07.967
For example, we can do yarn hardhat counts, which will print out a list of fake accounts we can use with Hardhead.

5000
08:32:07.967 --> 08:32:15.597
Similar to the list of fake accounts that we used with ganache, we can compile our contracts by running yarn Hardhead compile.

5001
08:32:15.597 --> 08:32:29.996
Very similar to what we did with ethers Jas and soap Jas, you'll see when we run compile, we get a cache, which is just going to be a quick way to access solidity files, and we also get an artifacts section.

5002
08:32:29.996 --> 08:32:42.751
This artifacts folder contains all the information about our compiled code we look in here now we can, for example, look in the build info and see a ton of information about our compiled contract.

5003
08:32:42.751 --> 08:32:46.576
If you're looking contracts, we can see more compiled information.

5004
08:32:46.576 --> 08:32:49.662
And then if we look in the hardhat, slash console.

5005
08:32:49.662 --> 08:32:51.695
so, we can see more compiled information.

5006
08:32:51.695 --> 08:32:55.687
So all of our compliation information is going to be in this artifacts folder.

5007
08:32:55.687 --> 08:33:03.789
And whenever you want to look to see what's going on on the lower level when you compile this artifacts folder is what has everything.

5008
08:33:03.789 --> 08:33:07.645
There are a number of other hard hat tasks that we can run as well.

5009
08:33:07.645 --> 08:33:10.797
But we'll get to them as we go.

5010
08:33:10.797 --> 08:33:18.307
So now that we have some of the basics of hard head down, let's go ahead and try doing some of the same things we did with ethers before but with hard hat.

5011
08:33:18.307 --> 08:33:24.069
So one of the first things we want to do is we want to write and interact with our smart contracts.

5012
08:33:24.069 --> 08:33:34.275
So let's go ahead and rename greeter dot soul to simple storage dot soul, you can click on the file and hit enter and should be able to rename it.

5013
08:33:34.275 --> 08:33:40.815
Otherwise, you can go ahead and right click, delete it, and then create a new file and call it simple storage dot soul.

5014
08:33:40.815 --> 08:33:52.729
We're going to copy paste all of our code from our previous simple storage that saw into this file, we can make sure that our simple storage is compiling correctly by running yarn hardhat compile.

5015
08:33:52.729 --> 08:33:57.721
Whoa, it looks like we ran into an issue project cannot be compiled.

5016
08:33:57.721 --> 08:34:00.474
See reasons below the solidity pragma version of the file.

5017
08:34:00.474 --> 08:34:03.745
It doesn't match any of the configured compilers in your config.

5018
08:34:03.745 --> 08:34:09.373
Hmm, well, what's going on contracts slash symbol storage that's Sol zero point 8.

5019
08:34:09.373 --> 08:34:09.438
8.

5020
08:34:09.438 --> 08:34:11.929
Ah, okay, let's go ahead and fix them.

5021
08:34:11.929 --> 08:34:15.374
So we can open up our hard hat dot config dot j s.

5022
08:34:15.374 --> 08:34:17.625
Now a quick note on opening files.

5023
08:34:17.625 --> 08:34:24.863
If you're on Mac and you hit Command P, you can actually start typing in the names of files to get them to them quicker.

5024
08:34:24.863 --> 08:34:35.292
Or if you're on Linux or Windows, you can type Ctrl p, this will bring up and interestingly if you type man P or ctrl p and then you hit the greater than key.

5025
08:34:35.292 --> 08:34:44.242
This will drop you into the command palette, know command palette, command palette, search for files, search for commands in our Hardhead dot config.

5026
08:34:44.242 --> 08:34:50.082
Jas, I'm gonna scroll down to module dot exports and change this to zero point 8.

5027
08:34:50.082 --> 08:34:50.178
8.

5028
08:34:50.178 --> 08:34:57.574
So that the version that we're going to compile for simple storage, it's gonna be the same version and that hard hat is looking for.

5029
08:34:57.574 --> 08:35:04.082
Let's run that same command by just hitting up yarn Hardhead compile, and awesome we see compiled one solidity file successfully.

5030
08:35:04.082 --> 08:35:06.404
We should now see this in artifacts.

5031
08:35:06.404 --> 08:35:08.497
If we go to artifacts and contracts.

5032
08:35:08.497 --> 08:35:18.058
We now see two contracts in here, greater and simple storage and we can see a ton of the information about simple storage we can also see some more lower level in Information and build info.

5033
08:35:18.058 --> 08:35:23.808
Alright, so now that we have our simple storage contract in here, the next thing we probably want to do is learn how to deploy it.

5034
08:35:23.808 --> 08:35:26.759
This is where we're going to write our deploy script.

5035
08:35:26.759 --> 08:35:30.058
Now, for this section, I'm going to be showing you how to write a deploy script.

5036
08:35:30.058 --> 08:35:33.262
But in the next section, we're going to do it a little bit differently.

5037
08:35:33.309 --> 08:35:36.936
But this is still going to teach you how to write scripts and worked with scripts in heart app.

5038
08:35:36.936 --> 08:35:44.324
So we're going to come to our sample script dot j s, and we're gonna go ahead and hit enter and renamed it to deploy dot j s.

5039
08:35:44.324 --> 08:35:50.145
And if you want to read all the comments in here, you absolutely can, we're just gonna go ahead and delete them all.

5040
08:35:50.145 --> 08:35:59.809
A quick keyboard shortcut is if you hit Command A or Ctrl, a, you'll highlight all the text in your file, and we're going to go ahead and delete it all.

5041
08:35:59.809 --> 08:36:01.696
So now we're just going to start from scratch here.

5042
08:36:01.696 --> 08:36:05.715
Now the setup for our deploy script in here is going to look really similar to the setup of our deploy script.

5043
08:36:05.715 --> 08:36:13.260
From our previous section, we're going to do imports at the top, we're going to have our async main function, and then we're going to call the main function.

5044
08:36:13.309 --> 08:36:16.636
So let's go ahead and define our main function, we'll call it async.

5045
08:36:16.636 --> 08:36:20.722
function main, like that, and then we'll call our main function.

5046
08:36:20.722 --> 08:36:33.442
And if you want to just copy paste this from the last section, you absolutely can.

5047
08:36:33.442 --> 08:36:41.675
So we'll domain that then.

5048
08:36:42.309 --> 08:36:43.361
Boom, just like that.

5049
08:36:45.309 --> 08:36:47.059
going to drive me absolutely insane.

5050
08:36:48.309 --> 08:36:51.380
prettier, and our solidity prettier plugins.

5051
08:36:52.309 --> 08:37:03.212
yarn, add dash dash Dev, prettier and prettier, plug in solidity.

5052
08:37:03.212 --> 08:37:22.643
Then we can go ahead and create our dot prettier, rc file, we're going to add tab with four, use tabs, false, semi false, and then single quote, also false.

5053
08:37:22.643 --> 08:37:27.310
Now we're going to be using this prettier rc file setup a lot.

5054
08:37:27.310 --> 08:37:31.678
So in future sections, if you want to just copy paste it, you can absolutely do that as well.

5055
08:37:31.678 --> 08:37:43.960
We're also going to add a dot prettier, ignore, which tells prettier not to format some files, which we want, we don't want prettier to spend a ton of time formatting all of our files, I'm just going to copy paste from the GitHub repo.

5056
08:37:43.960 --> 08:37:51.276
So feel free to copy paste from the GitHub repo as well, you'd find all the code for this section, like I said, in the GitHub repo associated with this course.

5057
08:37:51.310 --> 08:38:00.278
Now, unlike in our last section, where we had to grab our contract code a little bit more manually, with hard hat, it's actually a number of different ways to grab compiled contracts.

5058
08:38:00.310 --> 08:38:03.631
The first way we're going to do it, we're actually going to use ethers.

5059
08:38:03.631 --> 08:38:08.465
And now this is where one of the first confusing changes actually comes in.

5060
08:38:08.465 --> 08:38:12.950
Previously, we did const ethers equals require ethers.

5061
08:38:12.950 --> 08:38:17.226
And that was how we went ahead and worked with ethers.

5062
08:38:17.226 --> 08:38:23.500
However, you'll notice in our dev dependencies, we have this dependency called Hard Hat ethers.

5063
08:38:23.500 --> 08:38:28.649
Hard Hat ethers is a package that actually wraps hard hat with its own built in ethers.

5064
08:38:28.649 --> 08:38:35.738
This is really advantageous because it allows hard hat to keep track of different deployments at different scripts and all these other things for us.

5065
08:38:35.738 --> 08:38:42.903
So instead of importing ethers directly from ethers, we're actually going to import ethers directly from hard hat instead.

5066
08:38:42.903 --> 08:38:53.884
This might seem a little confusing at first, but just know if we want to work with ethers and heart it, it's usually much better to pull it in from heart and you can still do this and ethers will still work the same.

5067
08:38:53.884 --> 08:38:59.953
But hard hat won't necessarily know about different contract factories in different pieces and, and you'll see that in action in a second.

5068
08:38:59.953 --> 08:39:07.117
Now that we're pulling in ethers, we can actually immediately grab a contract factory using ethers.

5069
08:39:07.117 --> 08:39:19.111
We can say const simple storage factory equals await ethers dot get contract.

5070
08:39:19.111 --> 08:39:22.829
Factory simple storage.

5071
08:39:22.829 --> 08:39:29.262
So in order to get a simple storage, contract factory, we can just do await ethers dot get contract factory.

5072
08:39:29.311 --> 08:39:38.573
Now if we pulled right from ethers, the package ethers doesn't know about this contracts folder and ethers doesn't know we've already compiled simple storage dot soul.

5073
08:39:38.573 --> 08:39:40.277
And it's in our artifacts.

5074
08:39:40.277 --> 08:39:49.311
Hard Hat, on the other hand, does know about the contracts folder and does know that it's already compiled, which is why this simple storage factory grabbing work so well.

5075
08:39:49.311 --> 08:39:55.574
Once we have our factory here, we can do the same thing that we did in our previous section and deploy the contract.

5076
08:39:55.574 --> 08:39:59.363
So we'll do a quick console dot log.

5077
08:39:59.363 --> 08:40:30.234
Deploy flooring, contract done, and then we'll do Kant's simple storage equals await simple store edge factory dot deploy And boom, with that little bit of code, we're already able to deploy our simple storage contract, then to wait to make sure it gets deployed, we can do await, simple storage, deployed.

5078
08:40:30.311 --> 08:40:30.983
And that's it.

5079
08:40:33.312 --> 08:40:35.016
and run this deploy script.

5080
08:40:37.312 --> 08:40:40.262
we had to put in a private key, and we had to put an RPC URL.

5081
08:40:40.312 --> 08:40:43.562
Right now, we don't have either one of those defined.

5082
08:40:44.312 --> 08:40:50.541
you think should the script actually work? Or do you think it'll break because we, we didn't define what blockchain we're going to deploy you.

5083
08:40:50.541 --> 08:40:52.213
We also didn't find a private key.

5084
08:40:52.312 --> 08:40:54.778
Well, let's go ahead and try this out.

5085
08:40:56.312 --> 08:41:05.026
in our terminal by running yarn, hard hat, run, scripts slash deploy dot j, s.

5086
08:41:05.026 --> 08:41:09.712
And again, I'm hitting tab here to do a little auto completion and see what happens.

5087
08:41:09.712 --> 08:41:14.245
Well, we got deploying contract, it says done, but that's really it.

5088
08:41:14.245 --> 08:41:18.249
So what really happened? Well, let's add one more line in here.

5089
08:41:18.312 --> 08:41:20.712
Let's do console dot log.

5090
08:41:24.312 --> 08:41:26.682
deployed, contract to.

5091
08:41:26.682 --> 08:41:30.520
And then we'll add simple storage.

5092
08:41:31.312 --> 08:41:31.867
address.

5093
08:41:31.867 --> 08:41:33.374
Let's run this now.

5094
08:41:36.312 --> 08:41:40.249
we get deployed contract to, and then we get a contract address.

5095
08:41:40.312 --> 08:41:43.278
Hmm, what's going on here.

5096
08:41:47.312 --> 08:42:00.279
built in called The Hard Hat Network hard hat comes built in with Hard Hat Network, a local Aetherium network node designed for development, akin to ganache, that allows you to deploy your contracts and run your tests and debug your code.

5097
08:42:00.312 --> 08:42:09.139
Whenever we run a command in hard hat, or a script and hard hat or a task and hard hat, we by default deploy to this fake Hard Hat Network.

5098
08:42:09.139 --> 08:42:16.681
This Hard Hat Network is very similar to ganache, except for instead of having this UI, it runs in the background for our scripts.

5099
08:42:16.681 --> 08:42:18.531
In fact, if we go to our hard hat.

5100
08:42:18.531 --> 08:42:18.967
config.

5101
08:42:18.967 --> 08:42:27.113
js, we can scroll down to the bottom to this module that exports section and add more information about our default networks.

5102
08:42:27.113 --> 08:42:35.872
So right now, if we don't have anything in this module that export, by default, it adds this piece called default network hardhat.

5103
08:42:35.872 --> 08:42:43.201
So anytime we run a script, without specifying a network, it automatically uses this fake Hard Hat Network.

5104
08:42:43.201 --> 08:42:49.041
And this fake Hard Hat Network comes automatically with an RPC URL and a private key for you.

5105
08:42:49.041 --> 08:42:50.990
So you don't even have to add one in.

5106
08:42:50.990 --> 08:42:54.726
This is one of the major advantages of working with Hardhead.

5107
08:42:54.726 --> 08:42:57.741
It just automatically gives you this fake blockchain.

5108
08:42:57.741 --> 08:43:01.205
And these fake private keys, if you want to be a little bit more explicit.

5109
08:43:01.205 --> 08:43:07.590
And I always recommend being more explicit, we can add the default network in to the module that are experts.

5110
08:43:07.590 --> 08:43:11.154
So now our default network is explicitly stated as hard hat.

5111
08:43:11.154 --> 08:43:15.877
However, in any script, you run, you can choose whatever network you want to work with.

5112
08:43:15.877 --> 08:43:34.872
So if I want to explicitly say I want to run our deploy script on our fake Hard Hat Network, I can do yarn, hard hat, run scripts, deploy dot j s, dash dash network, hard hat, this is us telling her that, hey, we want to run this script on the Hard Hat Network.

5113
08:43:34.872 --> 08:43:37.829
Hopefully, you might be able to see where this is going.

5114
08:43:37.829 --> 08:43:46.027
Having this network flag makes it incredibly easy to switch across different chains, different block chains, different private keys, etc.

5115
08:43:46.027 --> 08:43:51.264
So we have our default network set the hard hat here, we can add other networks in here as well.

5116
08:43:51.314 --> 08:43:56.230
The way we do that is we're going to add a networks section.

5117
08:43:56.314 --> 08:43:58.536
And we're going to define any of the network sections that we want.

5118
08:43:58.536 --> 08:44:03.434
And remember to put a comment there so that your Visual Studio code doesn't get mad at you.

5119
08:44:03.434 --> 08:44:08.823
So recently, we worked with Rigby so let's go ahead and add a Rinkeby network in here.

5120
08:44:08.823 --> 08:44:13.001
So we're gonna say another network is gonna be really cool.

5121
08:44:13.001 --> 08:44:21.035
So I should just be able to change the network flag to Rigby now, right? Well, not quite.

5122
08:44:21.035 --> 08:44:28.830
If you try to run that, you're gonna get invalid value undefined for hardhat config networks.

5123
08:44:28.830 --> 08:44:38.614
Rigby, that URL, it's expecting you to tell it, hey, what the URL is, since this isn't the hard hat network, we need to tell hard hat exactly how we're going to connect to rink B.

5124
08:44:38.614 --> 08:44:44.720
And this is where a lot of what we learned before is going to come in handy, again, exactly the same as what we did before.

5125
08:44:44.720 --> 08:44:51.861
We're going to create a new Dotty v file, and we're going to add our Rigby URL in this dot env file.

5126
08:44:51.861 --> 08:44:55.847
Just remember, dot env is an r dot get ignore just in case.

5127
08:44:55.847 --> 08:45:02.091
So in our Dotty env, we're going to add that RPC URL from alcmi back in here before we just said RPC URL.

5128
08:45:02.091 --> 08:45:10.647
But since we might want to work across multiple networks, it's usually good to specify exactly what network each URL stands for.

5129
08:45:10.647 --> 08:45:17.456
So we're gonna say Rynkeby RPC URL equals and then paste that URL in here.

5130
08:45:17.456 --> 08:45:22.914
Now, as you probably have guessed, we can add our URL to our Rinkeby network here.

5131
08:45:22.914 --> 08:45:28.126
for readability, I usually like to add them as variables right above the module that experts.

5132
08:45:28.126 --> 08:45:30.517
So I'll say const Rynkeby.

5133
08:45:30.517 --> 08:45:39.970
RPC URL equals process dot E and V dot Rynkeby RPC URL.

5134
08:45:40.315 --> 08:45:45.695
And once again, we're going to be pulling that Rinckey RPC URL from our environment variable.

5135
08:45:45.695 --> 08:45:51.429
Of course, in order to pull that environment variable in, we're going to need to use that dot env package again.

5136
08:45:51.429 --> 08:45:56.380
So to add that in, we're going to yarn add dash dash dev dot EMV.

5137
08:45:56.380 --> 08:46:09.179
And at the top of our Hardhead config, we're going to add require dot EMV, and then do dot config to enable the config.

5138
08:46:09.179 --> 08:46:13.781
Now this means we should be able to pull our rink the RPC URL from our dot env.

5139
08:46:13.781 --> 08:46:21.205
Now that we have that in our Rinkeby network, we can add URL Rinckey RPC URL.

5140
08:46:21.315 --> 08:46:21.653
Awesome.

5141
08:46:21.653 --> 08:46:23.782
So we have an RPC URL for different network.

5142
08:46:24.315 --> 08:46:37.625
else do we usually need? Well, we usually need a private key to work with an actual network, or that doesn't automatically give us a private key for rugby, because Hardhead can't just give us test and the Etherium, we need to have an actual account an actual test nets.

5143
08:46:37.625 --> 08:46:39.762
Hardhead doesn't control those.

5144
08:46:39.762 --> 08:46:43.121
So we have to actually give it a real URL and a real private key.

5145
08:46:43.121 --> 08:46:53.992
So to add private keys, you actually add something called accounts, you add a list of accounts that you want to give to hard hat for us, we're only going to add one, which is going to be our private key.

5146
08:46:53.992 --> 08:46:56.901
And for our private key, we're going to do the exact same thing.

5147
08:46:56.901 --> 08:47:03.569
We're gonna say const private key equals process dot e NV dot private key.

5148
08:47:03.569 --> 08:47:12.269
And since this private key is going to be a real private key for a real test net, again, we are going to have to grab this from our meta mask.

5149
08:47:12.316 --> 08:47:20.225
So it will go to our meta mask, three dots, account details, export private key, and we'll add our password in here.

5150
08:47:20.316 --> 08:47:26.008
And then in our dot env will add private key equals and then add our private key.

5151
08:47:26.008 --> 08:47:37.758
Now I know I've said this 100 times, but please, please, please, for learning this, do not use a real key that is connected to any real money just in case, please use a new meta mask.

5152
08:47:37.758 --> 08:47:39.282
I've know I've said it a bunch.

5153
08:47:39.282 --> 08:47:42.125
But some people go no, I'm going to be okay, I'll be safe.

5154
08:47:42.125 --> 08:47:46.231
Just to be super, super safe here, please use a brand new meta mask.

5155
08:47:46.231 --> 08:47:50.848
So now that we have a private key, we're going to add it in here account private key.

5156
08:47:50.848 --> 08:47:52.396
And now we have an account here.

5157
08:47:52.396 --> 08:48:07.037
One more thing I like to do is I like to give the chain ID of the network, which for Rigby is going to be for every single EVM base network as a new chain ID and EVM network basically just means solidity works on it.

5158
08:48:07.037 --> 08:48:11.066
This includes all test nets, there's a good site called chainless.

5159
08:48:11.066 --> 08:48:16.052
org, which may or may not be going down at some point, it has a list of all these different networks.

5160
08:48:16.052 --> 08:48:27.399
For example, you can see on here a theory main net has a chain ID of one byte and smart chain is 56, avalanches, 4311 for Phantom, opera 250, Polygon, 137, etc.

5161
08:48:27.399 --> 08:48:37.899
Each one of these EVM compatible chains has their own chain ID, rank V, the chain ID is for adding the chain ID is helpful here for later on.

5162
08:48:37.899 --> 08:48:39.300
And we'll get to that in the future.

5163
08:48:39.300 --> 08:48:41.792
But for now, just go ahead and make sure to add your chain IDs.

5164
08:48:41.792 --> 08:48:51.512
Okay, now that we have the RPC URL, we have the private key, we can go ahead and test deploying this to an actual test net, and actually did something incorrect here.

5165
08:48:51.512 --> 08:48:53.184
And we're gonna get an error here.

5166
08:48:53.184 --> 08:48:58.248
And I want you to go ahead and try to figure out and debug this error yourself.

5167
08:48:58.317 --> 08:48:59.254
You're ready.

5168
08:48:59.254 --> 08:49:00.894
Alright, let's do it.

5169
08:49:03.317 --> 08:49:09.768
scripts, deploy dot j s, dash dash network Rinkeby.

5170
08:49:11.317 --> 08:49:16.850
this wonderfully weird error, which we see we have deployed contract.

5171
08:49:16.850 --> 08:49:31.768
So we know that in our deploy script, we get to at least this line, but then we're getting an error, I highly likely hear what's going on saying cannot read properties have no reading send transaction, if you want, you can absolutely go to this spot.

5172
08:49:31.768 --> 08:49:38.546
But it basically it looks like it's having a hard time understanding what the private key or what the account of this is.

5173
08:49:38.546 --> 08:49:46.710
And what do you think I'm going to recommend we do? Well, if it's not clear, after doing a little bit of triaging and debugging, we're going to copy this air.

5174
08:49:46.710 --> 08:49:50.418
And we're going to come on over to Google and paste that right in.

5175
08:49:50.418 --> 08:49:55.398
It looks like we do get a question here from stackexchange Etherium.

5176
08:49:55.398 --> 08:49:58.523
And it looks like it's really similar to what we're doing.

5177
08:49:58.523 --> 08:49:59.475
We scroll down.

5178
08:49:59.475 --> 08:50:05.269
They're running nearly the exact same script that we're running, they're using MPX instead of yarn.

5179
08:50:05.269 --> 08:50:08.189
They've got a pretty minimalistic deploy file.

5180
08:50:08.317 --> 08:50:11.017
Let's scroll down and see what the answers have to say.

5181
08:50:11.317 --> 08:50:14.178
seen this error where my private key wasn't properly populated.

5182
08:50:14.317 --> 08:50:18.575
would also use an environment variable I'm pretty sure Are environment variables good.

5183
08:50:18.575 --> 08:50:30.442
But we have a second one saying in your heart head, I can think that Jas, it should be accounts instead of account, it works for me, let's go back to our head config and see if that's what's going on.

5184
08:50:30.442 --> 08:50:33.280
Uh huh, we put account in this should be accounts.

5185
08:50:33.280 --> 08:50:34.762
So let's swap that over to accounts.

5186
08:50:34.762 --> 08:50:36.150
We'll clear our terminal.

5187
08:50:36.150 --> 08:50:37.675
And we'll run this again.

5188
08:50:37.675 --> 08:50:38.175
Uh huh.

5189
08:50:38.175 --> 08:50:41.937
And now it's reading a little bit longer, which is good.

5190
08:50:41.937 --> 08:50:45.979
This means that we're probably deploying this to rink B, which is what we want to see.

5191
08:50:45.979 --> 08:50:46.348
Awesome.

5192
08:50:46.348 --> 08:50:51.055
And now we can see deployed contract to, and we have a contract address here.

5193
08:50:51.055 --> 08:50:52.518
So we'll grab this contract.

5194
08:50:52.518 --> 08:50:56.365
And we'll pop on over to bring the ether scan, that's numbering the ether scan.

5195
08:50:56.365 --> 08:50:58.528
And we'll go ahead and we'll paste this in.

5196
08:50:58.528 --> 08:50:58.949
Awesome.

5197
08:50:58.949 --> 08:51:02.416
And we see our contract was created about 26 seconds ago.

5198
08:51:02.416 --> 08:51:02.940
Perfect.

5199
08:51:02.940 --> 08:51:07.794
Now for this part, you don't have to deploy this to rink be with me, if you follow along here.

5200
08:51:07.794 --> 08:51:08.698
That's good enough.

5201
08:51:08.698 --> 08:51:11.603
So remember, the flying to test that's can take a long time.

5202
08:51:11.603 --> 08:51:14.718
So for this one, you don't have to deploy with me.

5203
08:51:14.718 --> 08:51:16.218
Alright, great.

5204
08:51:16.218 --> 08:51:20.068
So we've deployed to rink be using hard hat.

5205
08:51:20.068 --> 08:51:21.032
This is fantastic.

5206
08:51:21.032 --> 08:51:33.518
Now something that we notice, once again is oof, our contract isn't verified? Do we have to go back through and do this verify and publish and all that stuff again? Luckily for us, we actually don't need to do that.

5207
08:51:33.518 --> 08:51:40.753
So what can we do? Well, back in our deploy script, we can add some code to automatically verify right after we deploy.

5208
08:51:40.753 --> 08:51:42.204
So let's go ahead and do that.

5209
08:51:42.204 --> 08:51:50.484
Right below our main function, we're gonna create a new function called verify, we're gonna say async function, verify.

5210
08:51:50.484 --> 08:52:00.644
And we're gonna have this function get past some arguments, we're gonna have to get past a contract, address, and some arguments or the contract.

5211
08:52:00.644 --> 08:52:05.645
Since our simple storage doesn't have a constructor, the arguments for simple storage are just gonna be blank.

5212
08:52:05.645 --> 08:52:11.842
But in the future, when we have contracts that do have constructors, the arguments are going to be populated.

5213
08:52:11.842 --> 08:52:20.934
And when we get there, you'll see what I mean, we need at least the contract address, and we're going to add some code in here to automatically verify our contracts after they've been deployed.

5214
08:52:20.934 --> 08:52:30.247
This auto verification process works on block explorers like ether scan, it might not work on block explorers like eath, pler, or other block explorers.

5215
08:52:30.247 --> 08:52:35.652
But if you want to verify on these other block explorers, I'm sure they have an API to allow you to do that as well.

5216
08:52:35.652 --> 08:52:44.319
Now, ether scan in most other block explorers have a section on their website called API documentation, or something to do with API's.

5217
08:52:44.319 --> 08:52:49.022
These are ways for us to programmatically interact with ether scan, and do stuff with them.

5218
08:52:49.022 --> 08:52:55.284
One of the main things that we can do is we can actually verify our contracts through this API.

5219
08:52:55.284 --> 08:52:59.852
Ether scan even has a tutorial in here called verifying contracts programmatically.

5220
08:52:59.852 --> 08:53:07.207
And the link to this will be in the GitHub repo, they have an API endpoint that we can make some requests to to go ahead and verify our contracts.

5221
08:53:07.207 --> 08:53:11.533
Now, we could absolutely make the raw API calls and follow the tutorial here.

5222
08:53:11.533 --> 08:53:15.790
But there's actually an easier way than even going through this tutorial here.

5223
08:53:15.790 --> 08:53:21.254
Hardhead is an extensible framework, meaning you can add something called plugins to it.

5224
08:53:21.319 --> 08:53:25.105
There's even an advanced section in the documentation called Building plugins.

5225
08:53:25.105 --> 08:53:32.132
If we scroll down to the bottom, we can see some popular plugins that the nomic labs team or the Hardhead team has created.

5226
08:53:32.132 --> 08:53:34.456
And also a number of community plugins as well.

5227
08:53:34.456 --> 08:53:42.013
One of the most used Hardhead plugins is going to be this hard hat ether scan plugin that makes this verification process much, much easier.

5228
08:53:42.013 --> 08:53:50.384
Install it, you can just run npm install bash, just save dev at nomic labs harden ether scan, and then add it to our hard hat dot config.

5229
08:53:50.384 --> 08:53:53.709
Since we're using yarn, we're just going to go ahead and use yarn.

5230
08:53:53.709 --> 08:54:06.425
So back in our code, we'll do yarn, add dash dash Dev, at nomic, labs, slash hard hat slash hyphen, ether scan.

5231
08:54:06.425 --> 08:54:23.336
Now that we have this plugin, we can go to our hard hat dot config, scroll to the top and add this plugin do require at nomic labs slash hard hat, ether scan.

5232
08:54:23.336 --> 08:54:33.658
Now that we have this plugin, the hard hat documentation has some more information about the usage, how to actually use this plugin, and how to run different commands with it.

5233
08:54:33.658 --> 08:54:38.227
In order for us to use this verification, we actually need an API key from ether scan.

5234
08:54:38.227 --> 08:54:42.746
This is basically a password for allowing us to use the ether scan API.

5235
08:54:42.746 --> 08:54:44.981
So we're going to come to ether scan.

5236
08:54:44.981 --> 08:54:47.014
And we're going to go ahead and sign in.

5237
08:54:47.014 --> 08:54:51.256
And actually we're going to click to sign up and create an account.

5238
08:54:51.320 --> 08:54:53.320
And we'll go ahead and create an account.

5239
08:54:54.320 --> 08:54:57.268
verify our registration by clicking the verification link.

5240
08:54:57.320 --> 08:54:58.591
And we'll click the Login.

5241
08:54:58.591 --> 08:54:59.862
Now that we're logged in.

5242
08:55:00.320 --> 08:55:02.582
left hand side, we can scroll down to API keys.

5243
08:55:03.320 --> 08:55:06.320
ahead and create a new API key.

5244
08:55:09.320 --> 08:55:11.270
which stands for hardhat Free Code Camp.

5245
08:55:12.320 --> 08:55:18.695
key will copy this and we'll go back to our code and we'll add this somewhere since the API keys basically considered a password.

5246
08:55:18.695 --> 08:55:22.029
Where do you think we should add this? That's right in our dot env.

5247
08:55:22.029 --> 08:55:27.739
So in our dot env, we're going to add a new entry called ether scan API key.

5248
08:55:27.739 --> 08:55:32.133
And we're going to add that API key that we just got.

5249
08:55:32.133 --> 08:55:46.237
Now that we have our API key, back in our Hardhead, config, we're going to create a new section in a module dot exports, tell hardhat that we have this ether scan API key, or new section is going to be called ether scan.

5250
08:55:46.321 --> 08:55:56.880
And in here, we're gonna say API key is going to be ether scan API key that we're going to define up here the same way we define these other keys.

5251
08:55:56.880 --> 08:56:04.493
So we'll say const, ether scan API key equals process dot e NV dot ether scan API key.

5252
08:56:04.493 --> 08:56:11.633
And if something like this pops up, you can generally just hit enter, and it will autocomplete it for you, which is awesome.

5253
08:56:11.633 --> 08:56:12.008
Great.

5254
08:56:12.008 --> 08:56:19.921
So now we have an ether scan API key back in the heart had documentation, it tells us by adding this, we actually get a new task called verify.

5255
08:56:19.921 --> 08:56:21.302
Let's try that out.

5256
08:56:21.302 --> 08:56:23.676
So open our terminal back up.

5257
08:56:23.676 --> 08:56:25.879
And we'll do yarn, RT hat.

5258
08:56:25.879 --> 08:56:27.894
Let's see what pops up.

5259
08:56:27.894 --> 08:56:31.172
Wow, we did get a new verification here.

5260
08:56:31.172 --> 08:56:35.476
When we run yarn hard hat harder, it actually looks into our hard hat.

5261
08:56:35.476 --> 08:56:35.786
config.

5262
08:56:35.786 --> 08:56:37.286
js and checks for any plugins.

5263
08:56:37.286 --> 08:56:42.003
If there are new plugins there, it'll add them as a new task that we can do.

5264
08:56:42.003 --> 08:56:52.659
You can manually verify your contract by doing yarn or MPX Harnett verify dash dash network, the deployed contract address and any constructor arguments yourself.

5265
08:56:52.659 --> 08:56:55.830
But we want to be a little bit more programmatic than this.

5266
08:56:55.830 --> 08:57:07.626
So what we're going to do is we're going to go back and create this verification function, it is good to know how to do it via command line so that if you want to verify something in the future, manually, you can, let's build this verify function though.

5267
08:57:07.626 --> 08:57:11.033
So we're going to take the our contract address and some arguments.

5268
08:57:11.033 --> 08:57:20.655
And for our sake, we're going to do console dot log verifying contract that that just so that we know we might have to wait for a little bit.

5269
08:57:20.655 --> 08:57:27.644
And in our code, we can actually run any task from hard hat using a run package.

5270
08:57:27.644 --> 08:57:35.966
So up at the top, we're actually going to import run from hard hat as well run allows us to run any hard hat task.

5271
08:57:35.966 --> 08:57:40.845
So in our code here, we're going to do a wait to run.

5272
08:57:40.845 --> 08:57:43.857
And then we can do there it thought.

5273
08:57:43.857 --> 08:57:47.773
Now part of that allows you to add different parameters as well in this run.

5274
08:57:47.773 --> 08:57:53.870
And it's usually best that you go ahead and add them in here so that we're really specific with what we're doing.

5275
08:57:53.870 --> 08:58:00.795
If we do yarn hardhat verify dash dash help, we can see what parameters we can actually pass.

5276
08:58:00.795 --> 08:58:03.625
Well, it looks like we can pass the Verify parameter.

5277
08:58:03.625 --> 08:58:05.303
So we'll do colon, verify.

5278
08:58:05.303 --> 08:58:20.951
If you go to the actual GitHub for the verification tasks, you can actually see you can do more than just verify, you can do verify, get minimum build, verify, get constructor arguments, verify, verify, which is what we're going to be working with, and a couple of other subtasks as well.

5279
08:58:20.951 --> 08:58:26.016
The second parameter that goes inside run is going to be a list of actual parameters.

5280
08:58:26.016 --> 08:58:29.949
This second parameter here is just kind of the sub task, if you will, of our verify task.

5281
08:58:29.949 --> 08:58:33.550
And this is going to be an object that contains the actual parameters.

5282
08:58:33.550 --> 08:58:47.877
And this is where we pass in an address, which is going to be our contract address, and then our construct or arguments, which is going to be arcs.

5283
08:58:47.877 --> 08:58:58.273
Now normally just this right here should be enough for us to go ahead and use this verify contract in our main function, but we're going to add one additional thing to it.

5284
08:58:58.323 --> 08:59:00.667
Because in practice, sometimes there's some errors that can come up.

5285
08:59:00.667 --> 08:59:05.144
One of the errors that often comes up when running a wait is that the contract has already been verified.

5286
08:59:05.144 --> 08:59:16.823
And you'll actually likely run into this, because ether scan will get smart enough by seeing enough bytecode that is exactly simple storage that it will start to just automatically verify any bytecode that looks like simple storage.

5287
08:59:16.823 --> 08:59:20.751
And then this await will throw an error, which we want to avoid.

5288
08:59:20.751 --> 08:59:26.886
So what we can do is we can add a try catch onto this await.

5289
08:59:26.886 --> 08:59:29.385
So outside of the way, we're going to add a try.

5290
08:59:29.385 --> 08:59:33.688
And we're going to add these little brackets that wrap around our weight.

5291
08:59:33.688 --> 08:59:36.880
And then we're going to put a catch.

5292
08:59:36.880 --> 08:59:42.291
This is known as a try, catch and solidity also has tried catches.

5293
08:59:42.291 --> 08:59:46.465
But basically, this e is going to be any error that this section throws.

5294
08:59:46.465 --> 08:59:52.688
So we're going to do is we're going to say if this message is already verified, then we're just going to continue.

5295
08:59:52.688 --> 08:59:53.797
So we're gonna say if e.

5296
08:59:53.797 --> 08:59:54.627
message.

5297
08:59:54.627 --> 09:00:03.846
to lowercase, we're going to make sure it's to lowercase that includes already there.

5298
09:00:03.846 --> 09:00:12.026
If five, then we're just going to console dot log already verified like that.

5299
09:00:12.026 --> 09:00:15.854
Otherwise, we're just going to console dot log e.

5300
09:00:15.854 --> 09:00:22.909
The reason we do This is because of this errors, our verification function will break, and our whole script will end.

5301
09:00:22.909 --> 09:00:28.909
And we don't want our whole script to end, we want our script to keep continuing if the verification doesn't work, because it's not really a big deal.

5302
09:00:28.909 --> 09:00:35.291
So I know this might seem like a lot of code, feel free to copy and paste it from the GitHub repo to just move along.

5303
09:00:35.291 --> 09:00:36.065
But awesome.

5304
09:00:36.065 --> 09:00:40.609
So we now have a verify function using the Verify task in hardhat.

5305
09:00:40.609 --> 09:00:49.098
Let's go ahead and use this now in our main function, right below our deploy, we'll do console dot log deployed contract two, and then the contract address.

5306
09:00:49.098 --> 09:00:53.609
But before we call this main function, let's think for a quick second.

5307
09:00:53.609 --> 09:01:10.590
What happens when we deploy to our RT Hat Network? Well, remember, if we deploy to our Hard Hat Network, will our contract need to be verified I need to scan? Well, we know there's a we know there's a rink ether scan, we know there's a COVID ether scan, we know there's a main net easy scan.

5308
09:01:10.590 --> 09:01:14.190
But is there a Hardhead ether scan? No, of course not.

5309
09:01:14.324 --> 09:01:19.035
Right? The hard at runtime environment is a network local to our machine.

5310
09:01:19.035 --> 09:01:23.942
So it doesn't make sense for us to verify a hard hat network deployed contract on ether scan.

5311
09:01:23.942 --> 09:01:29.799
So we actually don't want to call this verify function, when we're working with our local network.

5312
09:01:29.799 --> 09:01:33.001
This is where these chain IDs are going to come in quite useful.

5313
09:01:33.001 --> 09:01:47.544
What we can do is we can check to see if the network that we're running on is a live network or it's a test net, or it's a network that actually can be verified, we can actually get network configuration information by importing a network like this.

5314
09:01:47.544 --> 09:01:55.040
And we can do something like console dot log network dot config.

5315
09:01:55.040 --> 09:01:59.569
Now, if I run yarn, art, hit run scripts deploy.

5316
09:01:59.569 --> 09:01:59.744
js.

5317
09:01:59.744 --> 09:02:07.696
On our Hard Hat Network, since I'm not passing a network flag, we get this massive output that looks like this.

5318
09:02:07.696 --> 09:02:25.712
Our network dot config contains a ton of information about the current network that we're on, you'll see here that the chain ID of the Hardhead network is actually 31337 gas price, which gets set to auto block gas limit the current fork of Aetherium that we're working with, and all these other pieces here.

5319
09:02:25.712 --> 09:02:27.798
This chain ID is really important.

5320
09:02:27.798 --> 09:02:33.158
Because we can use this chain ID to figure out which one is a test net, or which one is a live network.

5321
09:02:33.158 --> 09:02:43.234
And remember, running the script is going to be the same as doing dash dash network, hard hat, you'll see our channel ID is still 31337.

5322
09:02:43.234 --> 09:02:54.477
Again, that's because the default network in our heart had config, it's hard hat, which is the same as saying every single time we run a script, we're secretly running it with dash dash network hard hat.

5323
09:02:54.477 --> 09:02:56.815
So now we only want to verify on our test net.

5324
09:02:56.815 --> 09:03:08.228
So what we can do is we can say if network dot config, that chain ID equals equals equals four, which is going to be rank B, ad.

5325
09:03:08.325 --> 09:03:28.769
And a JavaScript equals equals equals is nearly the same as equals equals, except no type conversion is done, which just means in JavaScript, four equals four, and four equals equals the string of four, but four, but if you were to use four equals equals equals four, this is false.

5326
09:03:28.769 --> 09:03:40.734
This is true equals equals four equals equals would be true, four equals equals to the string of four would also be true, but four equals equals equals to the string of four is going to be false.

5327
09:03:40.734 --> 09:03:43.954
So you can kind of do whatever you want here equals equals or equals equals equals.

5328
09:03:43.954 --> 09:03:53.786
So we want to say if the network dot config dot Trinity is four, so if we're on Rinkeby, then we can go ahead and actually verify.

5329
09:03:53.786 --> 09:03:59.611
But we also want to make sure we only verify if our ether scan API key exists.

5330
09:03:59.611 --> 09:04:09.801
So we can also in here is site and this double ampersand means and we can say process dot e NV dot ether scan API key.

5331
09:04:09.801 --> 09:04:31.067
This is some Boolean tricks that we're doing here, basically, so our first conditional we're saying if network dot config chinati equals equals equals four, this section can be true or false, obviously, right? The chain ID that we're running on can be the hardest network, which would mean this doesn't equal four, or it would be Rinckey, which means this does equal four.

5332
09:04:31.067 --> 09:04:33.136
But there's no conditional on this side.

5333
09:04:33.136 --> 09:04:40.402
So how does this side work? In JavaScript, if an object exists, and you try to cast it as a Boolean, it will be converted to true.

5334
09:04:40.402 --> 09:04:43.289
If it doesn't exist, it will be converted to false.

5335
09:04:43.289 --> 09:04:51.563
So in JavaScript, basically, if either scan API key exists, if we have this in our data in VI, this will be true.

5336
09:04:51.563 --> 09:04:53.676
And if not, this will be false.

5337
09:04:53.676 --> 09:05:06.808
So another way to read this line here is saying if network dot config that Trinity is for AKA, if we're on rink B, and our ether scan API key exists, then do some stuff.

5338
09:05:06.808 --> 09:05:08.459
And that's what we're going to do here.

5339
09:05:08.459 --> 09:05:23.084
So in here, we'd want to run verify, or verify function and pass it the contract address which is going to be Simple Storage dot address and the constructor arguments which we know are going to be blank.

5340
09:05:23.084 --> 09:05:31.262
And since our verify function is an async function, and it deals with promises and stuff, we want to add the await keyword here.

5341
09:05:31.326 --> 09:05:31.664
Awesome.

5342
09:05:34.327 --> 09:05:35.850
But we're not quite done.

5343
09:05:38.327 --> 09:05:52.432
explorers the instant we deploy the contract and the instant we send the contract, ether scan might not know about the transaction yet, it might take a hot second for ether scan to be up to speed with where the blockchain is.

5344
09:05:52.432 --> 09:05:59.165
So it's usually best practice to wait for a few blocks to be mined, until you actually run your verification process.

5345
09:05:59.165 --> 09:06:02.670
We've actually learned how to do this already with the deploy transaction.

5346
09:06:02.670 --> 09:06:10.233
So before we actually verify we run, we want to run a weight, simple storage.

5347
09:06:10.327 --> 09:06:14.458
Deploy transaction Wait, six.

5348
09:06:19.327 --> 09:06:21.184
then we'll run our verification process.

5349
09:06:22.327 --> 09:06:24.638
and test this out right now, you absolutely can.

5350
09:06:25.327 --> 09:06:30.447
keep going, though, because again, testing all these on a test net takes a little bit of extra time.

5351
09:06:30.447 --> 09:06:36.654
So I'm going to finish the rest of our main function, and then I'm going to run everything all together.

5352
09:06:36.654 --> 09:06:37.602
Okay, cool.

5353
09:06:37.602 --> 09:06:43.704
So we've deployed our contract, we've automatically programmatically verified our contract.

5354
09:06:43.704 --> 09:06:49.445
What's next? Well, what did we do last time, we started interacting with the contract.

5355
09:06:49.445 --> 09:06:50.903
So let's do const.

5356
09:06:50.903 --> 09:06:57.016
Current Value equals await simple storage dot retrieve.

5357
09:06:57.016 --> 09:07:01.562
To get the current value, simple storage, that's all.

5358
09:07:01.562 --> 09:07:08.408
We have a retrieve function, which returns the favorite number, so let's get the current value.

5359
09:07:08.408 --> 09:07:20.784
And we'll do console dot log, the current value is and then some string interpolation, current value.

5360
09:07:20.784 --> 09:07:28.394
And then we'll go ahead and update the current value by doing cons.

5361
09:07:28.394 --> 09:07:48.994
Transaction response equals await simple storage, that store will store the number seven, and then we'll await transaction response dot Wait, we'll wait one block for that transaction to go through.

5362
09:07:48.994 --> 09:08:00.972
And we'll grab the updated value by saying const updated value equals await simple storage dot retrieve.

5363
09:08:00.972 --> 09:08:06.700
Then we'll do console log.

5364
09:08:06.700 --> 09:08:12.128
The added value is updated value.

5365
09:08:12.128 --> 09:08:12.620
Awesome.

5366
09:08:12.620 --> 09:08:15.143
And this is going to be our whole script.

5367
09:08:15.328 --> 09:08:24.972
So if I can zoom out for a little bit, I know it will be a little bit small here, we've got this huge main function, which does what? Well it deploys our contract.

5368
09:08:24.972 --> 09:08:28.182
If we're on a test net, it then verifies our contract.

5369
09:08:28.182 --> 09:08:30.489
And then it updates the value to seven.

5370
09:08:30.489 --> 09:08:33.198
And we have our verify function down here.

5371
09:08:33.328 --> 09:08:37.734
And we have a section of our code that calls our main function.

5372
09:08:37.734 --> 09:08:39.818
Now for run this on the hard hat network.

5373
09:08:39.818 --> 09:08:44.819
What do you think will happen? Well, let's try yarn, or net run scripts.

5374
09:08:44.819 --> 09:08:45.871
Deploy dot j s.

5375
09:08:45.871 --> 09:08:55.984
Alright, awesome, we get exactly what we saw before we get deploying contract deployed contract to current value is zero, update value seven.

5376
09:08:55.984 --> 09:08:57.777
And there's nothing in here about verification.

5377
09:08:57.777 --> 09:08:59.234
That's exactly what we want.

5378
09:08:59.234 --> 09:09:00.818
Now, moment of truth.

5379
09:09:00.818 --> 09:09:03.040
Let's try this on Rinkeby.

5380
09:09:03.040 --> 09:09:11.777
We'll do yarn, RT hat run scripts, deploy dot j s, dash dash network Rinkeby.

5381
09:09:11.777 --> 09:09:20.802
And it's gonna go a lot slower, because obviously now we're deploying to an actual test net, where the blocks actually need to be mined.

5382
09:09:20.802 --> 09:09:22.910
And we see we haven't deployed the contract.

5383
09:09:22.910 --> 09:09:24.757
Now that our contract is deployed.

5384
09:09:24.757 --> 09:09:29.515
We know that we're currently waiting six block confirmations for us to go ahead and verify.

5385
09:09:29.515 --> 09:09:39.672
And actually I should add console dot log, waiting for block the x's so that we don't get campus weird.

5386
09:09:39.672 --> 09:09:49.040
Oh, wait, what are we doing now? That it looks like we ran into this error, no such file or directory, it looks like our code might not have compiled correctly here.

5387
09:09:49.040 --> 09:09:50.463
So here's what I'm gonna do.

5388
09:09:50.463 --> 09:09:53.805
We're gonna go ahead and delete our artifacts to trash.

5389
09:09:53.805 --> 09:09:55.968
We're gonna delete our cache as well.

5390
09:09:55.968 --> 09:10:05.432
And we're going to try rerunning this whenever you run a script with the hard drive command Hardhead will automatically recompile it for you, especially if there's no artifacts folder.

5391
09:10:05.432 --> 09:10:12.391
So we're going to rerun this command and heartbeat, it's going to compile first and we can see that it does exactly that.

5392
09:10:12.391 --> 09:10:15.203
And then it's going to go ahead and redeploy.

5393
09:10:15.329 --> 09:10:30.507
Hopefully this time, it should be able to find the contract that had just compiled looks like this time after I deleted the artifacts folder, we actually did indeed get some successful compilation.

5394
09:10:30.507 --> 09:10:46.435
And we can see here successfully submitted source code for contract or verification on the block explore waiting for verification results, successfully verified contracts simple storage on ether scan, and even gives us a link that we can go ahead and Command click or control click into.

5395
09:10:46.435 --> 09:10:49.837
And we can see the contract indeed being verified.

5396
09:10:49.837 --> 09:10:51.560
This is awesome.

5397
09:10:51.560 --> 09:10:53.283
This is perfect.

5398
09:10:53.283 --> 09:11:02.100
We've now got a successful deploy dot j s script that can deploy, verify, and then interact with our code.

5399
09:11:02.100 --> 09:11:03.280
This is fantastic.

5400
09:11:03.280 --> 09:11:05.123
This hard hat thing seems pretty cool.

5401
09:11:05.123 --> 09:11:08.265
What else can we do with hard hat like I showed you before.

5402
09:11:08.265 --> 09:11:10.845
Hard Hat comes with these tasks.

5403
09:11:10.845 --> 09:11:18.472
And the number of tasks that Hardhead can come with can be extended by us writing plugins, we can actually write our own tasks in hardhat.

5404
09:11:18.472 --> 09:11:38.176
And in our Hardhead dot config, it can defaulted with this task account, we can see task accounts, prints the list of accounts, and just prints a list of accounts here actually go to the heart had documentation to learn more about creating our own tasks, one of the ways that you can define tasks is directly in our heart head.

5405
09:11:38.176 --> 09:11:38.637
config.

5406
09:11:38.637 --> 09:11:38.790
js.

5407
09:11:38.790 --> 09:11:45.652
But typically, what people do is they have a new folder called tasks where they put all their tasks.

5408
09:11:45.652 --> 09:11:48.444
So for now, I'm gonna go ahead and delete this section here.

5409
09:11:48.444 --> 09:11:49.930
And we're going to create our own task.

5410
09:11:49.930 --> 09:12:00.784
You'll notice that now that we've deleted that section, if we run yarn RDAP, we no longer see the accounts task in here, because we've just deleted that task.

5411
09:12:00.784 --> 09:12:03.969
So let's create our own new task.

5412
09:12:03.969 --> 09:12:07.296
We'll call this block number.

5413
09:12:07.296 --> 09:12:07.525
js.

5414
09:12:07.525 --> 09:12:12.524
And we'll use this to get the current block number or whatever blockchain that we're working with.

5415
09:12:12.524 --> 09:12:14.201
So let's create this task.

5416
09:12:14.331 --> 09:12:22.823
First, we need to import the task function, we can get it by saying const task equals require arhat slash config.

5417
09:12:22.823 --> 09:12:26.759
The hard hat slash config has the task function.

5418
09:12:26.759 --> 09:12:36.231
To define a task, we can now just say task, give it a name and a description, the name is going to be blocked number.

5419
09:12:36.331 --> 09:12:41.314
And then the description is going to be prints the current block number.

5420
09:12:41.314 --> 09:12:52.882
Now that we have this task, there's a couple of things we can actually do with it, we can add different parameters to it by using the dot add command, which allow us to pass parameters to the task.

5421
09:12:52.882 --> 09:13:01.314
And then we could also set actions which define what the task should actually do for us, we're just going to do dot set action.

5422
09:13:01.314 --> 09:13:04.664
And define what we want this function to do.

5423
09:13:04.664 --> 09:13:16.594
So we're going to make this an async function, that's going to take as an input, the task arguments, which are going to be blank for us, and the HR E, which I'll define in a second.

5424
09:13:16.594 --> 09:13:19.706
Now, let me explain the syntax really quickly.

5425
09:13:19.706 --> 09:13:25.246
This might look a little bit weird, but this is what's known as a JavaScript arrow function.

5426
09:13:25.246 --> 09:13:30.158
In JavaScript, you can actually define functions without even using the function keyword.

5427
09:13:30.158 --> 09:13:37.238
For example, if we go back to our deploy function, we have our async function verify down here.

5428
09:13:37.331 --> 09:13:58.332
However, another way we could have defined this is is without using the function word at all, and actually turning this whole thing into a variable, we could have said instead, we could say const verify is going to be an async function that takes contract addresses and arguments.

5429
09:13:58.332 --> 09:14:01.428
And here's the function definition.

5430
09:14:01.428 --> 09:14:04.009
These two lines are essentially equivalent.

5431
09:14:04.009 --> 09:14:10.776
There's some slight differences between between using the function keyword and having your function be a variable.

5432
09:14:10.776 --> 09:14:14.457
But for the purposes of this course, they're basically the same.

5433
09:14:14.457 --> 09:14:19.935
Which means though, that this by itself is a function, just not assigned to a variable.

5434
09:14:19.935 --> 09:14:23.019
But essentially, the two of these do are exactly the same.

5435
09:14:23.019 --> 09:14:25.174
And that's the syntax that we're doing here.

5436
09:14:25.174 --> 09:14:37.647
You can imagine this sort of being like const block task equals async function, which takes the params and then runs that arrow function.

5437
09:14:37.647 --> 09:14:40.204
Or you can think of it as async.

5438
09:14:40.204 --> 09:14:48.998
Function, block task parameters, and then the function definition, these are all essentially the same.

5439
09:14:48.998 --> 09:14:55.849
The major difference is that we're never giving our function a name, we never give it this block task variable.

5440
09:14:55.849 --> 09:15:00.251
This is known as an anonymous function in JavaScript, because it doesn't have a name.

5441
09:15:00.251 --> 09:15:05.610
Now that we have our function in here, we can now call some function to get the block number.

5442
09:15:05.610 --> 09:15:18.253
Well, how can we get the block number when we run tasks, we automatically pass our anonymous functions, the task arguments, which in this one, we don't have any, but we also pass this HR II object.

5443
09:15:18.332 --> 09:15:22.211
This HRV is the heart hat runtime environment.

5444
09:15:23.332 --> 09:15:28.264
deploy script, this is basically the same as this require hard hat in here.

5445
09:15:28.264 --> 09:15:38.078
So this HRV can access a lot of the same, this HRV can access a lot of the same packages that the hard hat package can.

5446
09:15:38.078 --> 09:15:43.434
So we can do Hae dot ethers, just like how you can import ethers from hard hat.

5447
09:15:43.434 --> 09:15:50.833
And in our ethers package, there's actually a number of functions we can use like dot Pro, biter dot get block number.

5448
09:15:50.833 --> 09:16:02.087
Let's save this to a variable const blocked number equals, and this is going to be a synchronous, so we're going to want to add a weight here.

5449
09:16:02.087 --> 09:16:05.953
And then let's do console dot log block number.

5450
09:16:05.953 --> 09:16:13.047
Or better yet, we'll string interpolate this and say current block number like this.

5451
09:16:13.047 --> 09:16:22.252
Now though, if I try to run this task, you'll notice it doesn't show up in the heart Atlas of tasks, let's do yarn.

5452
09:16:22.333 --> 09:16:22.792
Art app.

5453
09:16:22.792 --> 09:16:25.283
Hmm, I don't see block number in here.

5454
09:16:26.333 --> 09:16:39.146
because we need to add it to our config dot config will add require dot slash tasks slash block number.

5455
09:16:39.333 --> 09:16:46.761
And in order for us to import it, and let's add a module that exports I'll explain what this does a little bit later.

5456
09:16:46.761 --> 09:16:53.365
But now that we've required it, if I run yarn hard hat, and now see blocked over is one of the tasks that I can use.

5457
09:16:53.365 --> 09:16:59.618
Now for a run yarn, art hat block number, we get current block number is zero.

5458
09:16:59.618 --> 09:17:07.942
And this makes sense because this is defaulting to our Hard Hat Network, which gets reset every time we run it.

5459
09:17:07.942 --> 09:17:18.000
But if I run yarn, hard hat block number A dash dash network Rinkeby, what do you think I'm gonna get? Again, a much larger number, current block number is right here.

5460
09:17:18.000 --> 09:17:33.734
Because this is the actual block number of Rigby versus the block number of our heart ad network is going to be zero because it gets reset every single time, we run one of these scripts now scripts and tasks both can basically do the same thing.

5461
09:17:33.734 --> 09:17:39.885
They both can interact with contracts, they both can deploy smart contracts, they can both pretty much do everything.

5462
09:17:39.885 --> 09:17:47.684
I prefer scripts just as a general rule of thumb, because I don't always think adding a special thing from the command line makes sense.

5463
09:17:47.684 --> 09:17:51.587
So I prefer scripts, but you'll see a ton of tasks and examples out there as well.

5464
09:17:51.587 --> 09:17:54.952
I think tasks are really nice for specific use cases.

5465
09:17:54.952 --> 09:18:01.944
But for the most part, we're pretty much going to use exclusively scripts, but it is good to know what a task looks like and how to use it.

5466
09:18:01.944 --> 09:18:07.940
I think tasks are better for plugins and scripts are better for your own local development environment.

5467
09:18:07.940 --> 09:18:13.934
But if you want to do everything with tasks, you absolutely can.

5468
09:18:13.934 --> 09:18:18.268
As you're starting to see, this config piece is pretty powerful.

5469
09:18:18.334 --> 09:18:24.350
And we can use it to modify our entire code base and our entire project to give our project more functionality.

5470
09:18:24.350 --> 09:18:35.798
What else can this do? Well, right now, as you can see, every time we work with a hard hat network, every time we run a script, we run that script, and then the Hard Hat Network is deleted, right? We can't interact with our contracts anymore.

5471
09:18:35.798 --> 09:18:39.318
Well, there's actually a way for us to run a hard hat network.

5472
09:18:39.318 --> 09:18:43.301
Similar to how we ran a ganache network with a user interface.

5473
09:18:43.301 --> 09:18:48.398
What we can do in hard hat is run yarn, RT hat node.

5474
09:18:48.398 --> 09:18:57.548
And what this will do is it'll spin up a node on a local network, exactly the same as ganache but in our terminal.

5475
09:18:57.548 --> 09:19:00.966
So you see here started HTTP and WebSocket.

5476
09:19:00.966 --> 09:19:03.211
JSON RPC server at this address.

5477
09:19:03.211 --> 09:19:10.033
And just like nosh, it comes packed with all these different accounts and private keys, which is awesome.

5478
09:19:10.033 --> 09:19:24.811
You'll notice though, interestingly enough that this node that we're running isn't on the Hard Hat Network, well, we can actually create a new terminal to try to interact with this just by hitting this little plus button and creating a new terminal.

5479
09:19:24.811 --> 09:19:30.949
Again, I'm using bash, but based off of whatever your operating system is, you can be using a different shell.

5480
09:19:30.949 --> 09:19:39.236
And here, let's go ahead and run yarn arhat run scripts, deploy dot j s, and see what happens.

5481
09:19:39.335 --> 09:19:44.801
Well, our typical setup happens, we deploy a contract, we get a contract address, we update the value.

5482
09:19:44.801 --> 09:19:51.268
But if we look at our node, it doesn't look like any transactions went through what we don't see any locking here.

5483
09:19:51.268 --> 09:19:59.690
So what's going on? Well, our Hard Hat Network is actually different from this locally running network here.

5484
09:19:59.690 --> 09:20:03.980
This locally running network we often want to refer to as our local host.

5485
09:20:03.980 --> 09:20:06.506
So it's slightly different than the Hard Hat Network.

5486
09:20:06.506 --> 09:20:11.285
It's still using the hard hat runtime environment, but it's just not this default Hard Hat Network.

5487
09:20:11.335 --> 09:20:17.112
It's considered its own separate network when we're running a node that it's going to live.

5488
09:20:17.112 --> 09:20:19.207
of past the duration of a script.

5489
09:20:19.335 --> 09:20:24.109
So we can actually interact with this by adding a new network to our hardhead.

5490
09:20:24.109 --> 09:20:24.496
config.

5491
09:20:24.496 --> 09:20:30.062
js, we'll create a new network and call it local host.

5492
09:20:30.335 --> 09:20:36.198
And exactly as we did up here, we'll give it a URL accounts and a chain ID.

5493
09:20:36.198 --> 09:20:43.522
So for URL, we can get that URL right from our terminal, I'll put a running yarn hard hat node.

5494
09:20:43.522 --> 09:20:50.860
by copying that and pasting it in here, we can then do a comma, we'll give it a chain ID of 31337.

5495
09:20:50.860 --> 09:20:58.488
Because even though it's considered a different network, it actually has the same chain ID as hard hat.

5496
09:20:58.488 --> 09:21:03.887
Interestingly enough, I know I just said we were going to give it accounts, but we actually don't need to give it accounts.

5497
09:21:03.887 --> 09:21:10.836
Because when we run with this localhost hard hat will automatically give us these 10 fake accounts for us.

5498
09:21:10.836 --> 09:21:18.926
So you can kind of think of the accounts here for this localhost as, as hard had already placing them in thanks, hard hat.

5499
09:21:18.926 --> 09:21:23.271
But now, if we go back to our bash here, let's clear the terminal.

5500
09:21:23.336 --> 09:21:25.169
Let's rerun the script.

5501
09:21:28.336 --> 09:21:28.669
host.

5502
09:21:28.669 --> 09:21:31.919
Now we should be pointing to this node.

5503
09:21:33.336 --> 09:21:38.936
this script, we should see some logging output at the end of this node.

5504
09:21:38.936 --> 09:21:41.069
So let's go ahead and hit enter.

5505
09:21:41.069 --> 09:21:48.499
Well, we see our normal stuff on our deploy script, we flip back to our node Wow, we see a ton of logging here.

5506
09:21:48.499 --> 09:22:01.129
Similar to ganache, we can see a whole bunch of different logs on what just happened, we can see a contract was deployed, we can see the address the transaction hash from value, gas, and the block number and everything.

5507
09:22:01.129 --> 09:22:08.736
We can also see our contract call calling the store function to update the value of our favorite number.

5508
09:22:08.736 --> 09:22:19.727
This is incredibly powerful for quickly testing and working with things on a local JavaScript VM or hard hat network to be able to see how your contracts will interact on a real test net.

5509
09:22:19.727 --> 09:22:23.167
And this is much quicker than working with a real test net.

5510
09:22:23.167 --> 09:22:30.337
Now additionally, same as what we said before, any process that's running in the terminal, we can kill it with Ctrl C.

5511
09:22:30.337 --> 09:22:36.067
So if you want to stop your node and then restart it, you can hit Ctrl.

5512
09:22:36.067 --> 09:22:42.949
C, to stop it, and then just up and then rerun that same command to re spin up your node Ctrl C stops it.

5513
09:22:42.949 --> 09:22:45.207
And then you can up to start again.

5514
09:22:45.337 --> 09:22:53.227
Another way you can stop it, of course, is if you hit the trashcan, which deletes the whole terminal, we pulled a terminal back up, we can run it again.

5515
09:22:53.227 --> 09:22:58.898
And just remember, if you hit the X that actually doesn't delete the terminal, that just hides it.

5516
09:22:58.898 --> 09:23:02.983
So our hard hat node right now is still running because I just hit it.

5517
09:23:02.983 --> 09:23:05.320
So I pull it back up, I can see that it is indeed still running.

5518
09:23:05.320 --> 09:23:10.014
But if I trashed candidate, and then it pulled the terminal back up, I can see that it is no longer running.

5519
09:23:10.014 --> 09:23:12.723
So running scripts is great.

5520
09:23:12.723 --> 09:23:25.687
But what if I don't want to have to code an entire script to do some things? What if I want to just tinker around with the blockchain? Well, hard hat comes packed with this thing called the console.

5521
09:23:25.687 --> 09:23:27.583
The console is a JavaScript environment.

5522
09:23:27.583 --> 09:23:41.527
For us to run JavaScript commands to interact with any blockchain, we can jump to the console by running yarn, hardhat, console, and then whatever network flag if we want to work on rink B, main net polygon, avalanche, etc.

5523
09:23:41.527 --> 09:23:43.495
That's just network local host.

5524
09:23:43.495 --> 09:23:49.998
And now we're dropped into a shell him in the shell, we can do everything that we do in a deploy script.

5525
09:23:49.998 --> 09:23:56.123
And we don't even have to run these imports, because everything with hard hat is automatically imported into our console.

5526
09:23:56.123 --> 09:24:00.814
So for example, let's say I wanted to get a simple storage contract factory.

5527
09:24:00.814 --> 09:24:03.238
Well, I could run exactly this line here.

5528
09:24:03.238 --> 09:24:16.202
I could say const, simple storage, factory equals await ethers dot get contract factory, have simple storage.

5529
09:24:16.338 --> 09:24:18.385
And now I can go ahead and even deploy this.

5530
09:24:19.338 --> 09:24:21.588
copy this line, paste it.

5531
09:24:25.338 --> 09:24:27.872
see that we just deployed a nother simple storage.

5532
09:24:28.338 --> 09:24:35.671
we can do things like await simple storage dot retrieve.

5533
09:24:36.338 --> 09:24:40.250
I get the return value which is going to be a big number with a value of zero.

5534
09:24:40.250 --> 09:24:46.751
I can also make transactions so I can do a weight, simple storage.

5535
09:24:46.751 --> 09:24:55.284
That store let's do 55 If I hit up twice, I can go back to the simple storage dot retrieve.

5536
09:24:55.338 --> 09:24:59.276
call that function and I can see my big number has a value of 55.

5537
09:24:59.338 --> 09:25:02.450
Now, this is a great way to quickly interact with any blockchain that we want.

5538
09:25:02.450 --> 09:25:06.134
Now you can exit the shell by hitting Ctrl C twice to get out.

5539
09:25:06.134 --> 09:25:11.285
Or you can also just you can also Trash Can your terminal if you get confused.

5540
09:25:11.285 --> 09:25:19.588
This console works with any network we can even do yarn, hard hat console dash dash network hard hat.

5541
09:25:19.588 --> 09:25:23.181
And we'll get dropped into a hard hat network.

5542
09:25:23.338 --> 09:25:30.948
Now this is not going to be the same node that's running here, this is going to be one that only runs for the duration of this command.

5543
09:25:30.948 --> 09:25:34.989
So whenever we cancel this command, this hard hat network gets cancelled.

5544
09:25:34.989 --> 09:25:36.449
And close out that too.

5545
09:25:36.449 --> 09:25:47.767
We can also do yarn, hard hat, console, dash dash network Rinkeby Rigby, or polygon or test net or main net or whatever we want.

5546
09:25:47.767 --> 09:26:00.339
And we can do things like ethers dot provider that can do things like await ethers dot provider dot get block number, see the block number of Rigby.

5547
09:26:00.339 --> 09:26:11.787
We can also deploy contracts, we can update contracts, we can do anything that we want, you can do anything in these consoles, and they're great ways to quickly test and tinker in interact with contracts.

5548
09:26:11.787 --> 09:26:17.102
Now, there's a couple other tasks that are really helpful.

5549
09:26:17.102 --> 09:26:21.699
You'll see before I went ahead and just deleted artifacts and deleted the cache manually.

5550
09:26:21.699 --> 09:26:27.855
Well, to do that yourself, you can also just run yarn Hardhead, clean.

5551
09:26:27.855 --> 09:26:31.289
And that'll delete the artifacts folder and clear out your cache.

5552
09:26:31.339 --> 09:26:33.097
We already know what compiled does.

5553
09:26:34.339 --> 09:26:38.205
things that Hardhead is fantastic for especially is running tests.

5554
09:26:38.205 --> 09:26:40.605
Now we haven't run tests yet so far.

5555
09:26:40.605 --> 09:26:46.258
However, running tests is absolutely critical to your smart contract development journey.

5556
09:26:46.258 --> 09:26:50.109
And we're going to spend a lot of time in the future writing really good tests.

5557
09:26:50.109 --> 09:27:07.799
The reason that writing tests are so important is because we want to make sure our code does exactly what we want it to do, especially in the defy, and the decentralized, smart contract world, all of our code is going to be open source for anybody to interact with, and potentially exploit.

5558
09:27:07.799 --> 09:27:18.258
There's sites like req dot news, which go through a ton of previous hacks and how they actually got hacked and what happened in the smart contract to enable these hacks to occur.

5559
09:27:18.258 --> 09:27:24.427
So testing, so writing really strong tests is always going to be our first line of defense.

5560
09:27:24.427 --> 09:27:26.114
And we have this sample test.

5561
09:27:26.114 --> 09:27:28.840
js, that comes default with the basic package of hardhat.

5562
09:27:28.840 --> 09:27:32.611
But as you probably already know, we're going to rename this and change it.

5563
09:27:32.611 --> 09:27:35.923
So we're going to rename this to test deploy dot j s.

5564
09:27:35.923 --> 09:27:41.081
And we're going to delete everything in here and start from scratch.

5565
09:27:41.081 --> 09:27:46.710
We want to be able to test all of our solidity code locally, so that we know exactly what it's doing.

5566
09:27:46.710 --> 09:27:52.840
And we can have a programmatic way to make sure that our code does what we want it to do.

5567
09:27:52.840 --> 09:27:56.740
So let's write a basic test for our simple storage contract.

5568
09:27:56.740 --> 09:28:01.684
So that we can be sure that it's doing exactly what we want it to be doing.

5569
09:28:01.684 --> 09:28:19.076
Hard Hat testing works with the Mocha framework, which is a JavaScript based framework for running our tests, you actually can write tests directly in solidity, if you'd like to, there's a bit of back and forth on whether testing with pure solidity is better or testing with a modern programming language.

5570
09:28:19.076 --> 09:28:28.029
The argument goes that testing with a modern programming language, you have more flexibility to do more stuff to interact and test your smart contracts.

5571
09:28:28.029 --> 09:28:32.768
But the argument for testing with us with solidity is that we want to be as close to the code as possible.

5572
09:28:32.768 --> 09:28:40.043
At the time of recording, most projects do the vast majority of their testing in a modern programming language like JavaScript.

5573
09:28:40.043 --> 09:28:42.105
So that's what we're going to be using here.

5574
09:28:42.105 --> 09:28:47.698
So to get started with our mocha tests, we do, we're going to write a describe function.

5575
09:28:47.698 --> 09:28:59.550
Describe is a keyword that hardheaded mocha will recognize, and it takes two parameters, it takes a string, which we're going to just write simple storage for now.

5576
09:28:59.550 --> 09:29:12.091
And then also takes a function, we could make function, test func and then write some stuff in here, and then pass it to our describe here.

5577
09:29:12.091 --> 09:29:24.912
But the common convention is going to be to do is to make it as an anonymous function, which we can create by typing function, putting an empty parameter here, and then some brackets like that.

5578
09:29:24.912 --> 09:29:29.270
So our describe function takes a name, a string, and a function.

5579
09:29:29.341 --> 09:29:34.781
Another way that you'll often see functions in describe is using that anonymous function syntax.

5580
09:29:34.781 --> 09:29:44.864
So you might see just these parentheses, an arrow, and then some brackets, the two of these are going to be basically the same, there are some differences.

5581
09:29:44.864 --> 09:29:51.716
And this second one is actually best practice, but just know that you might see this arrow syntax in other tests as well.

5582
09:29:51.716 --> 09:29:56.308
We have described a sample storage and then our function here, which is going to have all of our tests in it.

5583
09:29:56.341 --> 09:29:58.376
Inside each one of our describe blocks.

5584
09:29:59.341 --> 09:30:07.472
something called a before each, and a bunch of It's Our before each function is going to tell us what to do before each of our hits.

5585
09:30:07.472 --> 09:30:10.695
So we're going to have a ton of it and then we're going to have a before each.

5586
09:30:10.695 --> 09:30:14.919
All of our IDs are going to be where we actually write the code for running our tests.

5587
09:30:14.919 --> 09:30:36.075
And before each is going to be some code that tells us what to do before each one of these hits, we can also actually have describes, inside of describes, which again have more before each and more before it's having these nested describes can be really helpful for separating and modularizing our tests.

5588
09:30:36.075 --> 09:30:40.761
But for this one, we're just going to have a setup that looks like this.

5589
09:30:40.761 --> 09:30:44.008
And for this demo, we're only going to have one it.

5590
09:30:44.008 --> 09:30:50.148
So in order to test our smart contracts, before we actually run our tests, we're probably going to need to deploy the smart contracts first.

5591
09:30:50.148 --> 09:30:57.859
So inside of our before each, we're going to pass the our before each a function, that's going to tell our testing framework what to do before each test.

5592
09:30:57.859 --> 09:31:01.817
So we're going to pass it an async function like this.

5593
09:31:01.817 --> 09:31:06.103
And in here, we want to deploy our simple storage contract.

5594
09:31:06.103 --> 09:31:12.748
So to do that, we're going to need to get the ethers framework and do exactly what we did in our deploy script.

5595
09:31:12.748 --> 09:31:16.205
So in here, we're at the top we're gonna say const.

5596
09:31:16.342 --> 09:31:23.230
Ethers, equals require art have an import ethers from hard hat.

5597
09:31:23.342 --> 09:31:34.942
Then in our before each function, we'll say await ethers dot get contract factory of simple storage.

5598
09:31:34.942 --> 09:31:39.630
And we'll assign this to a const.

5599
09:31:39.630 --> 09:31:43.138
Simple Storage factory.

5600
09:31:43.138 --> 09:31:50.178
And then we'll run away, simple storage factory dot deploy.

5601
09:31:50.178 --> 09:31:50.669
Cool.

5602
09:31:50.669 --> 09:31:56.042
And let's also assign this to a variable cost simple.

5603
09:31:56.042 --> 09:32:10.306
Now, since right now, our simple storage and simple storage factory are scoped just to inside the before each, we actually need to stick these variables outside of the before each, so all of our events can interact with them.

5604
09:32:10.306 --> 09:32:20.277
So instead of having simple storage, factory, and simple storage, be constant variables, we're going to define them outside of them for each with the let keyword.

5605
09:32:20.343 --> 09:32:27.205
And we're gonna say let simple storage factory and we're going to initialize it to nothing.

5606
09:32:27.205 --> 09:32:29.739
And then we'll say led simple storage.

5607
09:32:29.739 --> 09:32:40.390
Now, if you have a whole bunch of let's just initializing another way, you can write them in JavaScript, just let simple storage factory comma, simple storage.

5608
09:32:40.390 --> 09:32:42.064
And that works exactly the same.

5609
09:32:42.064 --> 09:32:43.817
And then we can get rid of this const keyword.

5610
09:32:43.817 --> 09:32:47.454
Because it's not a constant since we are assigning it.

5611
09:32:47.454 --> 09:32:52.936
And now we have simple storage, factory and simple storage that we can use inside of our init function.

5612
09:32:52.936 --> 09:32:54.643
Now we have a before each section.

5613
09:32:54.643 --> 09:32:57.898
So before each one of our tests, we're going to deploy our simple storage contract.

5614
09:32:57.898 --> 09:33:02.278
So we have a brand new contract to interact with for each one of our tests.

5615
09:33:02.343 --> 09:33:11.549
Now, inside of the ID, this is where we're going to say what we want this specific test to do, and then describe the code that's going to actually do that.

5616
09:33:11.549 --> 09:33:18.815
So we're going to say it should start with a favorite number of zero.

5617
09:33:18.815 --> 09:33:22.280
So this is saying what this test should do.

5618
09:33:22.280 --> 09:33:26.861
And then we're going to add our async function to actually do that.

5619
09:33:26.861 --> 09:33:29.129
So we'll say async function.

5620
09:33:29.129 --> 09:33:38.268
And in here, this is where we'll actually write the code to make sure that our contract does exactly this.

5621
09:33:38.343 --> 09:33:40.247
We're say const.

5622
09:33:40.247 --> 09:33:45.834
Current Value, equals await, simple storage.

5623
09:33:46.343 --> 09:33:46.859
retrieve.

5624
09:33:50.343 --> 09:33:53.246
to see that this current value is indeed zero.

5625
09:33:54.343 --> 09:33:59.666
that? Well, we can say const, expected value is going to equal zero.

5626
09:33:59.666 --> 09:34:12.077
And what we can do is we can do either we can use either the assert keyword, or the expect keyword, which we're going to import both of these from a package called Chai.

5627
09:34:12.077 --> 09:34:20.171
We actually installed Chai automatically when we downloaded the basic parameters when we downloaded the basic packages for hardhats.

5628
09:34:20.171 --> 09:34:22.722
So at the top, we're gonna say const.

5629
09:34:22.722 --> 09:34:33.616
Expect and assert equals require Chai, I'm a big fan of using assert as much as possible, because I think the syntax makes a little bit more sense.

5630
09:34:33.616 --> 09:34:37.055
But there will be scenarios where we need to use expect instead.

5631
09:34:37.055 --> 09:34:43.281
Now, assert has a ton of functions that are built in that help us make sure this is what we expect it to be.

5632
09:34:43.344 --> 09:34:46.786
So I can do assert dot equal current value.

5633
09:34:48.344 --> 09:34:52.277
remember, this is actually going to be a big number, comma, expected value.

5634
09:34:52.277 --> 09:34:58.810
So I'm saying I'm asserting this retrieve to return zero, which is going to be our expected value.

5635
09:34:58.810 --> 09:35:03.934
Now to actually run this, we're going to run yarn, art hat test.

5636
09:35:03.934 --> 09:35:09.950
And we see we get an output that looks like this should start with favorite number of zero, and it's indeed passing.

5637
09:35:09.950 --> 09:35:22.312
You'll notice that if I were to change this to one, and this wasn't correct, it would break and it would say art Pass or not passing assertion error expected zero to equal one.

5638
09:35:22.312 --> 09:35:27.671
It expected zero to equal one, which is not what we want.

5639
09:35:27.671 --> 09:35:30.021
We want zero to equal zero.

5640
09:35:30.021 --> 09:35:31.648
So let's run this again.

5641
09:35:31.648 --> 09:35:35.183
Tada should start with favorite number zero, and it's passing.

5642
09:35:35.183 --> 09:35:36.102
Alright, fantastic.

5643
09:35:36.102 --> 09:35:42.183
So that's how we wrote one of our tests, let's write one more test just to make sure that things are good.

5644
09:35:42.183 --> 09:35:50.583
So let's say it should update when we call store, because when we call the store function, we want our favorite number to update.

5645
09:35:50.583 --> 09:35:53.688
And we'll make this an async function as well.

5646
09:35:53.688 --> 09:35:56.188
And let's add our stuff in here.

5647
09:35:56.345 --> 09:35:58.011
So we'll say const.

5648
09:36:01.345 --> 09:36:05.000
expecting that when we call store it updates to seven.

5649
09:36:05.345 --> 09:36:07.000
we can say const.

5650
09:36:11.345 --> 09:36:12.761
storage dot store.

5651
09:36:16.345 --> 09:36:17.126
value here.

5652
09:36:21.345 --> 09:36:22.046
weight one.

5653
09:36:22.046 --> 09:36:24.291
Now let's get the current value.

5654
09:36:25.345 --> 09:36:26.031
const.

5655
09:36:32.345 --> 09:36:33.046
retrieve.

5656
09:36:37.345 --> 09:36:37.918
value.

5657
09:36:37.918 --> 09:36:41.475
to string, comma expected value.

5658
09:36:44.345 --> 09:36:46.395
these tests by running yarn Hardhead test.

5659
09:36:47.345 --> 09:36:48.782
ran both of these tests.

5660
09:36:51.345 --> 09:36:59.657
only finagling with one test, I can actually just run one test by running yarn, art app, test, dash dash grep.

5661
09:36:59.657 --> 09:37:04.570
And I can search for any keywords in any of the text here.

5662
09:37:04.570 --> 09:37:07.741
So I'm going to grep for the store function.

5663
09:37:07.741 --> 09:37:13.583
Because the store keyword isn't in this tax for this, it, it's only in the text for this it.

5664
09:37:13.583 --> 09:37:23.488
So if I do grep store, it should only run our second test, which does indeed, one other way we can run only specific tests is with the only keyword.

5665
09:37:23.488 --> 09:37:27.011
So we can type it dot only like that.

5666
09:37:27.011 --> 09:37:30.409
And then we can run yarn, art hat test.

5667
09:37:30.409 --> 09:37:34.596
And it should only run, this should update when we call store.

5668
09:37:34.596 --> 09:37:40.613
And it does indeed, then we'll go ahead and delete this save, run again, and it should run all too.

5669
09:37:40.613 --> 09:37:41.505
Fantastic.

5670
09:37:41.505 --> 09:37:49.749
Now the other way you'll see these tests written is with instead of assert, it'll use the expect keyword.

5671
09:37:49.749 --> 09:37:52.919
So you'll see something like expect current value.

5672
09:37:52.919 --> 09:37:53.951
to string.

5673
09:37:53.951 --> 09:38:01.346
to dot equal expected value, the two of these lines do exactly the same thing.

5674
09:38:01.346 --> 09:38:04.536
And it's sort of up to you on which one you want to use.

5675
09:38:04.536 --> 09:38:07.524
And that's all we're going to do for our testing.

5676
09:38:07.524 --> 09:38:07.952
Now.

5677
09:38:07.952 --> 09:38:11.059
This is fantastic, great job.

5678
09:38:11.059 --> 09:38:18.821
Now that we have some tests, we can actually start testing to see how much gas each one of our functions actually costs.

5679
09:38:18.821 --> 09:38:23.853
One of the most popular extensions for hard hat is the hard hat gas reporter.

5680
09:38:23.853 --> 09:38:33.958
This is an extension that gets attached to all of our tests, and automatically gives us an output that looks like this, that tells us approximately how much gas each one of our functions cost.

5681
09:38:33.958 --> 09:38:41.853
We scroll down in here, we can read the instructions on how to actually install this npm install Hardhead gas reporter which we're going to use with yarn.

5682
09:38:41.853 --> 09:38:52.012
So we're gonna say yarn, add hard hat, gas reporter, dash dash Dev.

5683
09:38:52.346 --> 09:39:01.918
And now that that package is installed, we can go over to our config and add some parameters in here so that we can work with this gas pit.

5684
09:39:01.918 --> 09:39:07.855
But our neath our ether scan section, we're going to add a new section called gas reporter.

5685
09:39:07.855 --> 09:39:13.003
To have it run, whenever we run our tests we're going to do enabled is going to be true.

5686
09:39:13.003 --> 09:39:20.013
And then up at the top, we can add it by adding require hardhat gas reporter.

5687
09:39:20.013 --> 09:39:30.313
Now that we have it in here, we can do yarn hardhat test, and after we run our tests, it'll automatically run this gas reporter.

5688
09:39:30.313 --> 09:39:32.966
So we see our tests go ahead and run.

5689
09:39:32.966 --> 09:39:40.001
And then we get this output that looks like this that tells us how approximately how much our contracts and methods cost.

5690
09:39:40.001 --> 09:39:47.177
So our store function looks like It costs approximately this much gas and our simple storage costs approximately this much gas.

5691
09:39:47.177 --> 09:39:52.902
This is incredibly helpful for figuring out how to optimize our gas as best as possible.

5692
09:39:52.902 --> 09:39:55.560
Now I usually like to take it a step further though.

5693
09:39:55.560 --> 09:40:00.153
Having the gas output it like that is nice, but we can make it even better.

5694
09:40:00.153 --> 09:40:04.281
I like to output it to a file by doing output file.

5695
09:40:04.281 --> 09:40:18.008
Yes, report dot txt and then my dot get ignore like to add it in here, but doing gas report dot txt sentence it's not really important for the gas report to get pushed up to GitHub.

5696
09:40:18.008 --> 09:40:19.329
Do no colors is true.

5697
09:40:19.329 --> 09:40:26.019
The reason we add this is because when we output to a file, the colors can get messed up basically.

5698
09:40:26.019 --> 09:40:30.578
And then the biggest addition we could do is we can add a currency in here.

5699
09:40:30.578 --> 09:40:36.761
So that we can get the cost of each function in USD for a blockchain like Aetherium.

5700
09:40:36.761 --> 09:40:56.248
Now in order to get a currency here, we actually need to get an API key from corn market cap, just like we did with ether scan, you can go to coin market cap, corn market cap API, get your API key now, and we'll go ahead and sign up.

5701
09:40:56.248 --> 09:40:59.248
Choose a basic plan.

5702
09:40:59.248 --> 09:41:04.671
We'll agree and create my account, we'll get an email verification.

5703
09:41:04.671 --> 09:41:06.905
And we'll go ahead and verify.

5704
09:41:06.905 --> 09:41:11.414
Now in the coin market cap dashboard, we can copy our key.

5705
09:41:11.414 --> 09:41:23.594
And yep, you guessed it exactly what we're going to do with this key, we're going to drop it into our dot env file, or say coin market cap, API key equals and then paste it in there like that.

5706
09:41:23.594 --> 09:41:32.276
Now that we have our corn market cap API key in here, we can go back to our header dot config and add it in this corn market cap parameter.

5707
09:41:32.276 --> 09:41:48.648
We're gonna do the exact same way we did above, we'll do const, coin, market cap, API key equals process dot EMV, that coin market cap API key, and then we'll take this sticking in here.

5708
09:41:48.648 --> 09:41:55.435
So what this is going to do is actually going to make an API call to corn market cap, whenever we run our gas reporter.

5709
09:41:55.435 --> 09:42:01.912
This is why sometimes you'll see me comment this out and uncomment it because I don't always want it to make this API calls.

5710
09:42:01.912 --> 09:42:10.708
But now what we can do now that it's enabled, we have an output file, we can see the currency and we have our API key, all we can do is run yarn hardhat test.

5711
09:42:10.708 --> 09:42:16.015
And after all our tests pass, we're going to see a gas report.

5712
09:42:16.015 --> 09:42:20.729
tx T that we can go ahead and read from which has that gas report.

5713
09:42:20.729 --> 09:42:33.738
And now it actually has the USD price of each one of these transactions, it looks like at current prices, with Aetherium being $3,000 per eath, and a gas price of 43 Gwei, the store function would cost $6.

5714
09:42:33.738 --> 09:42:37.112
And the simple storage function would cost $64.

5715
09:42:37.112 --> 09:42:46.590
The current the Hardhead gas reporter actually comes with some different options, though, if you're going to be deploying to different network, for example, with binance, Polygon, Avalanche or hecho.

5716
09:42:46.590 --> 09:43:00.693
For example, let's say we wanted to deploy the polygon, let's see how much deploying the polygon would cost well in our WMV UHD ad token, Matic And now we'd rerun this test.

5717
09:43:00.693 --> 09:43:09.806
And if we look at our gas report that takes T will now see the gas price of polygon right now is around 37 Gray per gas.

5718
09:43:09.806 --> 09:43:13.243
And the cost of Matic is 147 automatic and USD.

5719
09:43:13.243 --> 09:43:18.494
Now we can see the cost of calling the simple storage method is going to be $0.

5720
09:43:18.494 --> 09:43:18.655
00.

5721
09:43:18.655 --> 09:43:33.296
Now this of course is rounded down, but it's going to be really, really cheap to call store versus deploying the contract is going to cost three cents, I make it a habit to select false for my gas reporter whenever I don't want to actually work with the gas here.

5722
09:43:33.349 --> 09:43:33.704
Awesome.

5723
09:43:36.349 --> 09:43:41.709
we don't have these environment variables specified Hardhead might get a little bit upset with us.

5724
09:43:41.709 --> 09:43:44.411
So oftentimes, I'll add some code in here.

5725
09:43:44.411 --> 09:43:53.661
So that these variables are always populated, because we didn't specify our rink prpc URL, ring P RPC URL is going to be undefined.

5726
09:43:53.661 --> 09:43:56.036
And that might throw some errors blow.

5727
09:43:56.036 --> 09:44:14.725
So oftentimes, what we'll do is I'll add an or parameter here, these double pipes mean or, and in JavaScript, if we say some variable equals something or something else, what is really happening is we're gonna say, okay, rink, the RPC URL is going to be equal to process dot E and V dot rink, the RPC URL.

5728
09:44:14.725 --> 09:44:19.720
But if this rink, the RPC URL doesn't exist, it's going to be whatever else is over here.

5729
09:44:19.720 --> 09:44:23.914
And I might write something like HTTPS eath Rinkeby.

5730
09:44:23.914 --> 09:44:30.178
Example, or something like this, just so that I don't make hard hat mad if I don't use rank B.

5731
09:44:30.178 --> 09:44:33.604
And we can do something like that for all these.

5732
09:44:33.604 --> 09:44:39.807
So you'll see this syntax, oftentimes in a lot of code setups.

5733
09:44:39.807 --> 09:44:47.127
Now the last thing that I'm going to show you before going into the TypeScript edition of This is test coverage.

5734
09:44:47.127 --> 09:44:55.492
And as we progressed to this course, I'm going to show you more and more tools that you can use to make sure that our simple storage contract is safe and secure.

5735
09:44:55.492 --> 09:45:00.936
And we take all the steps we can to prevent any hacks from happening if we deploy in real life.

5736
09:45:00.936 --> 09:45:03.688
One of those tools is a tool called solidity coverage.

5737
09:45:03.688 --> 09:45:06.850
And this is also a hardhat plugin that we can use for our code.

5738
09:45:06.850 --> 09:45:16.366
solidity coverage is a project that goes through all of our tests and sees exactly how many lines of code in our sample store dot Sol are actually covered.

5739
09:45:16.366 --> 09:45:17.942
And this can be a Good tip off.

5740
09:45:17.942 --> 09:45:24.462
If we don't cover some line of code, solidity coverage will say, Hey, you don't have any tests for this line, maybe you should write some tests for it.

5741
09:45:24.462 --> 09:45:28.242
We can add solidity coverage the same way we've been adding all of our packages.

5742
09:45:28.242 --> 09:45:36.269
npm install dash, just save Dev, or since we're using yarn, yarn, add dash dash Dev, solidity coverage.

5743
09:45:36.269 --> 09:45:47.919
And we can then add this to our config, the same way we've been adding everything to our config, go to our config, and we'll write require solidity coverage.

5744
09:45:47.919 --> 09:45:56.421
And there's some configuration pieces we can add down here below for this, but we're just going to use the default now we can do is run yarn, RT hat coverage.

5745
09:45:56.421 --> 09:46:10.842
And this is going to go through our tests and print out a file that looks like this, we'll also get a file called coverage dot JSON, which is basically this chart broken down a little bit more often put my coverage dot JSON in my dot get ignore.

5746
09:46:10.842 --> 09:46:14.981
And I know we haven't actually seen dot Git ignore, do what it's supposed to do.

5747
09:46:14.981 --> 09:46:23.617
But we will soon we can see here that about 50% of the code 50% of our statements in simple storage dot soul are covered.

5748
09:46:23.617 --> 09:46:41.951
About two thirds of our functions are and 50% of the lines, It'll even give us exactly what lines aren't tested right now, which we can see exactly 31 and 32 of simple swords, outsole aren't covered, which makes a lot of sense, because 31 to 32 is this Add Person function, which we didn't call and we didn't add to our tests.

5749
09:46:41.951 --> 09:46:52.824
If you want to take this time to pause and try to make this solidity coverage be 100% across the board, by writing some more tests, I highly recommend you do so it'll be a great learning exercise.

5750
09:46:52.824 --> 09:46:54.661
We'll also add the coverage folder.

5751
09:46:54.661 --> 09:47:01.266
So covered adjacent and the coverage folder, which again, I'll explain what the dot get ignore folder does a little bit later.

5752
09:47:01.266 --> 09:47:09.304
Now the last thing that we didn't talk about and here was what is this nomic labs hard hat waffle.

5753
09:47:09.304 --> 09:47:13.629
We talked about Daddy and V heart and ether scan tasks gas reports.

5754
09:47:13.629 --> 09:47:24.399
So today, what is this? Well, we can actually Google search this and find out exactly what this is Hardhead waffle is actually a plugin to work with the waffle testing framework.

5755
09:47:24.399 --> 09:47:32.574
waffle is one of these frameworks that allow us to do some really advanced testing, we're going to be working with some syntax that looks really similar to this really soon.

5756
09:47:32.574 --> 09:47:36.775
And we'll be showing you more and more of this waffle tool as we continue.

5757
09:47:36.775 --> 09:47:43.188
Alright, the next part of this section, I'm actually going to go over the TypeScript edition of this.

5758
09:47:43.188 --> 09:47:50.098
But for all intents and purposes, you've successfully created your first Hardhead project, you've done a ton of amazing things.

5759
09:47:50.098 --> 09:47:57.285
In this lesson, let's do a quick refresher of what we've learned so far, we learned how to spin up our own hard hat projects.

5760
09:47:57.352 --> 09:48:05.565
And now we can run yarn, hard hat and see a list of the tasks and different things that we can do with hard hat.

5761
09:48:05.565 --> 09:48:08.818
We learned that hard hat looks for this hard hat.

5762
09:48:08.818 --> 09:48:09.218
config.

5763
09:48:09.218 --> 09:48:09.351
js.

5764
09:48:09.351 --> 09:48:17.401
And this is sort of the entry point for any task that we run that starts with hard hat, we learned we can add our contracts to this contracts folder.

5765
09:48:17.401 --> 09:48:26.813
And then we compile it by running yarn, art half compile, we learned that all the compliation goes into the artifacts and then the cache as well.

5766
09:48:26.813 --> 09:48:31.707
And if we want to clean reset, we can either delete these two files or just run yarn, hard hat clean.

5767
09:48:31.707 --> 09:48:38.860
So we learned that we can use scripts or tasks to actually deploy, interact and do things with our smart contracts.

5768
09:48:38.860 --> 09:48:42.194
We also learned that I'm going to be using scripts for the rest of this course.

5769
09:48:42.194 --> 09:48:44.997
But if you want, you could absolutely use tasks as well.

5770
09:48:44.997 --> 09:48:50.580
I've asked this question a million times what's the difference? Nobody really seems to know what the main difference is.

5771
09:48:50.580 --> 09:48:53.319
But I think the main difference is that tasks are for plugins.

5772
09:48:53.319 --> 09:49:12.210
And scripts are for your local development Mart, that is mind limiter, we learned that we can import a whole bunch of things, including tasks from hard hat in our scripts, and we can work with our async functions to grab our contracts and deploy them, we actually then can programmatically verify them using hard hat and using hard hat plugins.

5773
09:49:12.210 --> 09:49:17.165
And then additionally, we can interact with our contracts very similar to how we did it with ethers.

5774
09:49:17.165 --> 09:49:19.203
We wrote a wonderful verification script.

5775
09:49:19.203 --> 09:49:24.014
And we also wrote our own task, we wrote our first test for this whole space.

5776
09:49:24.014 --> 09:49:27.686
And we showed what our tests are going to look like moving forward.

5777
09:49:27.686 --> 09:49:30.066
And we talked a little bit about their importance.

5778
09:49:30.066 --> 09:49:37.393
And I really should stress that writing good tests is going to be the difference between a really professional environment and kind of a side project.

5779
09:49:37.393 --> 09:49:42.505
Whenever I audit smart contracts, or whenever I'm given a project for someone to tell me to take a look at.

5780
09:49:42.505 --> 09:49:45.788
The first thing I look at is the readme, of course.

5781
09:49:45.788 --> 09:49:47.917
And the second thing I look at is the tests.

5782
09:49:47.917 --> 09:49:54.305
And if tests aren't good, I usually tell them, hey, you need to go back to the drawing board, and you need to level up your tests.

5783
09:49:54.353 --> 09:50:00.708
So tests are really really important, especially for this space, we learned about a couple of more environment variables we can use.

5784
09:50:00.708 --> 09:50:05.892
We learned about a couple of tools to see how good our tests are one of them being coverage.

5785
09:50:05.892 --> 09:50:12.089
We also learn about a gas reporter to see how much it's going to cost us when we actually deploy to a real network.

5786
09:50:12.089 --> 09:50:26.304
We learned a ton about the hard hat config, and how there are multiple networks that we can add add to our hard heads, we can make our project our EVM code, work with any network out there, we started working with dev dependencies instead of regular dependencies.

5787
09:50:26.353 --> 09:50:30.553
Now, READMEs are something that I'm not really going to go over too deeply in here.

5788
09:50:30.553 --> 09:50:38.124
But READMEs are sort of like the welcome page of your GitHub repository, and really should give you an understanding of what your code does.

5789
09:50:38.124 --> 09:50:39.983
Being a part of the web through space.

5790
09:50:39.983 --> 09:50:44.892
And being a part of the blockchain ecosystem is really more than just you coding your stuff by yourself.

5791
09:50:44.892 --> 09:50:48.974
You want other people to interact and engage with your code and engage with your projects.

5792
09:50:48.974 --> 09:50:50.509
I haven't showed you how to use GitHub yet.

5793
09:50:50.509 --> 09:50:54.784
But don't worry, we're going to but if you look at my heart had simple storage readme.

5794
09:50:54.784 --> 09:51:10.020
If you scroll down, usually, you really want to have a Getting Started section where you define how to set up all the code and how to set everything up a Quickstart section, and maybe a usage section and some testing section, which teaches people how to actually use and interact with your code.

5795
09:51:10.020 --> 09:51:13.830
Since we're just learning more of the code part and not so much the readme part.

5796
09:51:13.830 --> 09:51:17.104
For now, we're not going to go over how to make a fantastic readme.

5797
09:51:17.104 --> 09:51:22.374
However, I will leave a link in the GitHub repository associated with this course, link to this best readme template.

5798
09:51:22.374 --> 09:51:35.654
It really is a fantastic readme template that you can copy to any of your projects to make them look really good and give them a really good setup, so that other developers can come to your project, and learn and participate with what you're coding.

5799
09:51:35.654 --> 09:51:42.754
But all right, you have learned an absolute ton, you should be incredibly proud of yourself, and incredibly excited that you've made it this far.

5800
09:51:42.754 --> 09:51:45.133
Now I'm going to jump into the TypeScript section here.

5801
09:51:45.133 --> 09:51:48.676
So for those of you who are coding along with TypeScript, feel free to follow along.

5802
09:51:48.676 --> 09:52:02.128
For those of you who are not, you just finished the Basic section on hard hit, but stick around the next to heart out sections are going to be the ones that really fine grain and hone your skills, and give you all the fundamentals for working with these frameworks.

5803
09:52:02.128 --> 09:52:10.934
So be sure to follow along with the next two sections, we've got a ton more fantastic content for you, we are just beginning to get deeper into the smart contract ecosystem.

5804
09:52:10.934 --> 09:52:14.741
So take that lap, get that coffee, and I'll see you soon.

5805
09:52:14.741 --> 09:52:19.386
Alright, also now let's do this with TypeScript.

5806
09:52:19.386 --> 09:52:22.710
So I am going to go ahead and just start this from our JavaScript section.

5807
09:52:22.710 --> 09:52:30.992
However, if in the future, you want to start a new Hardhead project, you can actually start a new project with yarn, hard hat.

5808
09:52:30.992 --> 09:52:38.032
And then do great and advanced sample project that uses TypeScript, you'll add a ton of plugins.

5809
09:52:38.032 --> 09:52:41.082
And you'll wait a while for everything to get uploaded.

5810
09:52:41.082 --> 09:52:43.699
And you wait, and you wait a little bit for everything to get downloaded.

5811
09:52:43.699 --> 09:52:54.600
We're not going to do that though, because I'm going to show you how to convert this to JavaScript Anyways, if in future hearted sections, as we're coding along with JavaScript, if you want to code along with TypeScript, you absolutely 100% can.

5812
09:52:54.600 --> 09:52:58.032
But let's go ahead and show you what the main differences are.

5813
09:52:58.032 --> 09:53:04.105
Now that advanced TypeScript thing is going to add a whole bunch of packages that you may or may not want, I will talk about some of them in our next lesson.

5814
09:53:04.105 --> 09:53:07.010
But there are going to be some that you absolutely do need.

5815
09:53:07.010 --> 09:53:30.079
Those are going to be at type chain slash ethers, dash v five, at type chain, slash hard hat, at TypeScript, at types, slash Chai, at types, slash node, at types slash moko, TS node, type chain and TypeScript.

5816
09:53:30.079 --> 09:53:40.064
And I have a link in the GitHub repo associated with this course, I've got this yarn ad that you can just copy paste, if you want to just copy paste that into your project to run it.

5817
09:53:40.064 --> 09:53:42.116
Oops, and I should have added those as dev dependencies.

5818
09:53:42.116 --> 09:53:48.580
So we're going to actually just make them dev dependencies real quick, just by deleting these two lines, and adding a comma here.

5819
09:53:48.580 --> 09:53:50.644
Awesome, that looks much better.

5820
09:53:50.644 --> 09:53:56.815
And then of course, what we're going to do is we're going to convert all of our JavaScript to TypeScript.

5821
09:53:56.815 --> 09:54:03.581
So anywhere where we have J S, we're going to put Ts, obviously, if you're coding this from scratch with TypeScript, you would do the.

5822
09:54:03.581 --> 09:54:04.482
ts From the get go.

5823
09:54:04.482 --> 09:54:08.974
This includes our hard hat dot config, that's also going to be TypeScript now.

5824
09:54:08.974 --> 09:54:11.784
And additionally, we're going to add a TS config dot JSON.

5825
09:54:11.784 --> 09:54:14.804
This is going to be our TypeScript configuration.

5826
09:54:14.804 --> 09:54:17.260
Typically, for a setup, we're gonna go with something like this.

5827
09:54:17.260 --> 09:54:20.414
And you can copy this from the GitHub repo associated with this course.

5828
09:54:20.414 --> 09:54:26.265
It's basically telling TypeScript, what versions of Typescript and what files to include for working with TypeScript.

5829
09:54:26.265 --> 09:54:29.356
Now let's go ahead and start with our deploy dot TypeScript.

5830
09:54:29.356 --> 09:54:35.782
For usual, instead of using require, we're gonna go ahead and use import, we're gonna do the exact same thing.

5831
09:54:35.782 --> 09:54:40.822
We're gonna have import ethers run network, from hard hat.

5832
09:54:40.822 --> 09:54:48.956
And then in our verify function, we're going to add that we're gonna add the types for these arguments.

5833
09:54:48.956 --> 09:54:51.956
So contract address, is going to be a string.

5834
09:54:51.956 --> 09:54:55.044
And args is going to be an array of arguments.

5835
09:54:55.044 --> 09:55:01.784
So we're gonna say it's gonna be any array, because it could be string, it could be numbers, it could be balloons, it could be anything.

5836
09:55:01.784 --> 09:55:08.990
We're also going to say for IE, it could be any, even though this is technically an error type, we're just going to put any for simplicity.

5837
09:55:08.990 --> 09:55:09.497
For now.

5838
09:55:09.497 --> 09:55:19.168
All of our TypeScript scripts are included in our TS config, or any TypeScript files are manually added here, which we have Our entire scripts folder here, which is good.

5839
09:55:19.168 --> 09:55:21.480
So now we need to add ethers in here.

5840
09:55:21.480 --> 09:55:23.943
Well, if we look at our hardhead.

5841
09:55:23.943 --> 09:55:24.419
config.

5842
09:55:24.419 --> 09:55:33.721
ts, we're using require here still, and we need to swap this out for import for Donnie V, you can use dot env slash config for it to grab your dot env file.

5843
09:55:33.721 --> 09:55:37.611
Now that we've imported everything, go back to our deploy.

5844
09:55:37.611 --> 09:55:40.136
ts, we can see that that linting has gone away.

5845
09:55:40.136 --> 09:55:47.734
If you want to be even more explicit, we can go ahead and add import at nomic labs slash hard hat ethers like so.

5846
09:55:47.734 --> 09:55:55.615
reason we don't need to import it here is because these two packages also work with Hardhead ethers, so they automatically import it.

5847
09:55:55.615 --> 09:55:59.595
But if you want to be super explicit, you can go ahead and add it like so.

5848
09:55:59.595 --> 09:56:01.166
Now, we're almost good to go.

5849
09:56:01.166 --> 09:56:04.357
But remember, our Harnett dot config is also importing our tasks.

5850
09:56:04.357 --> 09:56:10.063
So we're going to need to update our tasks or block number to be TypeScript fide.

5851
09:56:10.063 --> 09:56:17.221
So of course, instead of const require, we're going to import task from our that slash config.

5852
09:56:17.221 --> 09:56:21.839
And we're going to be sure to export our task from lock number as the default.

5853
09:56:21.839 --> 09:56:25.433
So we're going to do export default task like so.

5854
09:56:25.433 --> 09:56:29.134
And now we should be good to run our scripts.

5855
09:56:29.134 --> 09:56:34.918
So we can just do yarn, art hat, run scripts, employee.

5856
09:56:34.918 --> 09:56:35.058
ts.

5857
09:56:35.058 --> 09:56:37.865
We can do network hard hat if we choose.

5858
09:56:37.865 --> 09:56:38.808
And awesome.

5859
09:56:38.808 --> 09:56:43.663
Now, it's when we get to the testing, that things get a little bit different here.

5860
09:56:43.663 --> 09:56:46.741
So let's go ahead and change this required to import.

5861
09:56:46.741 --> 09:56:48.894
Just to make it happy there.

5862
09:56:48.894 --> 09:56:58.770
Let's try to run yarn, art head test, we get a whole bunch of errors, and in VS code will actually go ahead and get these errors right from the linter.

5863
09:56:58.770 --> 09:57:08.797
One of the trickiest things that you run into as a developer in this space is calling functions on contracts where those functions don't exist, or vice versa.

5864
09:57:08.797 --> 09:57:11.594
We're not calling functions on contracts that do exist.

5865
09:57:11.594 --> 09:57:22.035
Right now the typing for our contracts is just type contract, which isn't super helpful, because type contract doesn't necessarily have all the functions that we want it to have.

5866
09:57:22.035 --> 09:57:32.758
We want our contracts to be of type contract, but we want them to be of the type of our contract, because if they're the type of our contract, they can have all the functions that we want them to have.

5867
09:57:32.758 --> 09:57:49.938
So to give our contracts the correct typing here, we actually can use this tool called type chain, which gives our contracts correct typing type chain has a hardened plugin, which allows us to use type chain and TypeScript natively together, type chain slash hard hat was one of these things that we already installed.

5868
09:57:49.938 --> 09:57:59.675
And to add it to our hard hat, we got to just go to the hard hat config, and add it in import at type chain slash arhat.

5869
09:57:59.675 --> 09:58:16.358
Now once we import that in to our config, if we run yarn hardhat, we now get a new task here called type chain, you read the description, it says generate type chain typings for compiled contracts, this will enable all of our contracts to have their own typing.

5870
09:58:16.358 --> 09:58:25.989
So we can have a simple storage variable of type simple storage contract, which is much better, because we're always going to know exactly what we can do with each contract.

5871
09:58:25.989 --> 09:58:30.289
To create this, we run yarn, arhat type chain.

5872
09:58:30.289 --> 09:58:37.429
And this is going to create a new folder called type chain slash types.

5873
09:58:37.429 --> 09:58:52.273
With types for all of our contracts, you can even go into our simple storage sub Ts, which is going to have all the different functions and everything to do with our simple storage contract automatically coded into Typescript and JavaScript for us, which is incredibly helpful.

5874
09:58:52.273 --> 09:58:54.890
And again, no, I haven't shown you what this is yet.

5875
09:58:54.890 --> 09:59:02.909
But in our dot Git ignore, we usually want to add type chain and type chain dash types into our dot Git ignore so we don't push them up to GitHub.

5876
09:59:02.909 --> 09:59:09.046
Now back in our test, we're going to add the exact types of these different objects here.

5877
09:59:09.046 --> 09:59:12.973
So we're going to import them from that folder that we just created.

5878
09:59:12.973 --> 09:59:34.063
So we'll do import simple storage, comma, simple storage underscore underscore factory from dot dot slash types, ain slash types, the simple storage factory is going to be simple storage factory and then civil storage of course, is going to be simple storage.

5879
09:59:34.063 --> 09:59:49.662
So now when do let simple storage factory which is going to be of type, simple storage, underscore underscore factory, and then simple storage, which is going to be of type simple storage contract.

5880
09:59:49.662 --> 09:59:58.484
And if we command clicked into simple storage, once again, we can see all the contract functions that we know and love, are here.

5881
09:59:58.484 --> 10:00:02.796
In addition, we have all the functions of the actual contract itself.

5882
10:00:02.796 --> 10:00:07.971
Once we do that, we're pretty much good to go we just need to have a couple of new things here.

5883
10:00:07.971 --> 10:00:11.686
Get contract factory returns a type ethers dot contract factory.

5884
10:00:11.686 --> 10:00:16.692
So what we just need to do is we need to wrap this in a simple storage factory type.

5885
10:00:16.692 --> 10:00:19.534
So We'll just do a little wrap like this.

5886
10:00:19.534 --> 10:00:24.068
And we'll say, as simple storage, I'm just going to sort of factory.

5887
10:00:24.068 --> 10:00:25.459
And that's good to go.

5888
10:00:25.459 --> 10:00:28.676
Now that we've added all this, we can run yarn, Hardhead test.

5889
10:00:28.676 --> 10:00:37.975
And boom, our test run is normal, but with TypeScript and with this additional typing that makes our lives substantially substantially better.

5890
10:00:37.975 --> 10:00:50.905
And that's going to be all you need to know for TypeScript, reusable, all of the branches have an optional TypeScript branch that you can use to reference to work with TypeScript.

5891
10:00:51.360 --> 10:00:54.886
We've learned really just the basics of all the different things we can do with hardhat.

5892
10:00:54.886 --> 10:01:04.660
And these next few lessons Hardhead fun meme and hard hat smart contract lottery are really going to be the basics for all the fundamentals of all the tools that we're going to learn in hardhat.

5893
10:01:04.660 --> 10:01:10.478
Lesson Eight is going to be our introduction to full stack and working with front end and building full stack applications.

5894
10:01:10.478 --> 10:01:15.478
Getting all the way through this course will give you all the tools to start your web three journey.

5895
10:01:15.478 --> 10:01:21.069
But if you're looking to just learn just the basics, make sure you absolutely get all the way to Lesson Nine.

5896
10:01:21.069 --> 10:01:26.601
And if you get all the way through lesson 18, you are going to know all of the cutting edge tools for this space.

5897
10:01:26.601 --> 10:01:31.310
And you're going to have the knowledge to become easily one of the best developers in the space.

5898
10:01:31.310 --> 10:01:33.835
So hope you make it all the way through to the end.

5899
10:01:33.835 --> 10:01:47.160
Now one of the most important parts of this section of this lesson is going to be pushing our code up to GitHub, and then sending a tweet celebrating that we pushed our first smart contract our first web three GitHub repository to GitHub.

5900
10:01:47.160 --> 10:01:54.851
So before moving on to the next lesson, be absolutely sure to get to the end of this and push this code up to GitHub.

5901
10:01:54.851 --> 10:02:12.310
And then optionally, if you want to celebrate by sending a tweet, but be absolutely sure to get to the GitHub section, because as I've said, many times the web three space is this incredibly collaborative community and working with GitHub or GitLab, or any other version control tool is going to be essential for your success in the space.

5902
10:02:12.360 --> 10:02:14.265
So be sure to get to that part.

5903
10:02:14.265 --> 10:02:14.900
All right.

5904
10:02:16.361 --> 10:02:19.694
the hard hat Fund Me section of our course.

5905
10:02:21.361 --> 10:02:35.615
where we're actually going to upload our first code repository to GitHub if you've never done this before, this is going to be the section where we're going to learn even more about hardhat using a familiar contract base we've already worked with, which is the fund me contract.

5906
10:02:35.615 --> 10:02:42.075
And again, if you're using the GitHub repo associated with this course, you can scroll down to the Hardhead Funmi.

5907
10:02:42.075 --> 10:02:45.884
And all the code is located in our repo.

5908
10:02:45.884 --> 10:02:57.180
If you'd like to do a quickstart, you can go ahead and get clone it CVU into it, and then run yarn, and then just run yarn hardhat deploy this, I'm going to briefly show you what that looks like.

5909
10:02:57.180 --> 10:03:07.886
So in your in your VS code, you can do git clone, grab the package, cd into it, and then type code period.

5910
10:03:07.886 --> 10:03:10.161
To open it up in a new VS code.

5911
10:03:10.161 --> 10:03:13.570
Once you're in your folder, you can go ahead and run yarn.

5912
10:03:13.570 --> 10:03:26.619
To install all the dependencies for working with this project, you plan on working with the test net or working with ether scan or coin market cap, feel free to fill out your Dotty and V with a private key RPC URL, corn market cap key and ether scan key.

5913
10:03:26.619 --> 10:03:34.264
And then you can just follow along with the readme to use this repo to run yarn, hard hat deploy.

5914
10:03:34.361 --> 10:03:37.651
And it'll show you deploying some contracts and some mocks, etc.

5915
10:03:37.651 --> 10:03:42.199
So let's get to building this ourselves though.

5916
10:03:42.199 --> 10:03:49.094
Now we're gonna make a new directory for this project, it's gonna be the same setup we've seen before.

5917
10:03:49.094 --> 10:03:51.360
MK dir, hard hat.

5918
10:03:51.360 --> 10:03:56.683
And me, FCC, we're gonna cd into heart at Funmi, FCC, and then type code period.

5919
10:03:56.683 --> 10:04:05.299
And if code period doesn't work for you, you can absolutely open this up by hitting File, Open Folder, like we showed you before.

5920
10:04:05.299 --> 10:04:07.080
Now, we're in a brand new folder here.

5921
10:04:07.080 --> 10:04:09.497
And we're gonna go ahead and add hard hat here.

5922
10:04:09.497 --> 10:04:15.912
And we're gonna run yarn, add dash dash Dev, hard hat.

5923
10:04:15.912 --> 10:04:25.263
Now that we have hard hat, in our package, JSON, and in our node modules, we can go ahead and run yarn, start app.

5924
10:04:25.263 --> 10:04:32.200
And this will say, What do you want to do? I'm going to choose the advanced sample project here, just to show you what's going on.

5925
10:04:32.200 --> 10:04:35.395
And we're going to set this up in a way that I think works best.

5926
10:04:35.395 --> 10:04:37.598
So we'll go ahead and do the advanced sample project.

5927
10:04:37.598 --> 10:04:39.412
Yes, we're going to have that as the root.

5928
10:04:39.412 --> 10:04:41.062
Yes, we want to add a Git ignore.

5929
10:04:41.062 --> 10:04:45.112
And there are a lot of sample project dependencies that it wants us to add.

5930
10:04:45.112 --> 10:04:46.762
We're gonna go ahead and hit yes.

5931
10:04:46.762 --> 10:04:52.002
But we're going to end up not using all of these and I'll show you which ones we're not going to use and why.

5932
10:04:52.002 --> 10:05:01.612
But for now, let's go ahead and hit yes.

5933
10:05:02.362 --> 10:05:03.603
All right, awesome.

5934
10:05:06.362 --> 10:05:06.495
here.

5935
10:05:08.362 --> 10:05:08.808
in here.

5936
10:05:11.362 --> 10:05:16.674
modules, which is going to be the same scripts is going to be the same test is going to be the same.

5937
10:05:16.674 --> 10:05:20.599
But this comes with a dot E and V dot example already packed in for us.

5938
10:05:20.599 --> 10:05:21.806
It also comes with.

5939
10:05:21.806 --> 10:05:23.250
es lint files.

5940
10:05:23.250 --> 10:05:25.361
es lint, RC dot j s.

5941
10:05:25.361 --> 10:05:25.583
es.

5942
10:05:25.583 --> 10:05:35.136
Lint, ignore es Lint is known as a JavaScript linter, which helps you find and automatically fix problems in your code for the JavaScript that I work with.

5943
10:05:35.136 --> 10:05:37.963
I'm not a big fan of ES lint, so I typically don't use it.

5944
10:05:37.963 --> 10:05:40.608
So I'm going to go ahead and delete the two of these.

5945
10:05:40.608 --> 10:05:43.658
If you want to keep them in you absolutely can dot Git ignore.

5946
10:05:43.658 --> 10:05:53.922
We're going to finally understand what this file does in this lesson that NPM ignore helps Ignore files if you want to push your project up to be an NPM package, which we're not going to do.

5947
10:05:53.922 --> 10:05:57.459
So if you want to delete this, you can as well pretty or ignore it and pretty DRC.

5948
10:05:57.459 --> 10:05:59.072
We already know what these do small hint.

5949
10:05:59.072 --> 10:06:13.091
And so hint ignore, which we're going to talk about it in a minute, or Hardhead config, which just comes already with a ropsten network, a gas reporter and ether scan package dot JSON with all the additional packages, the readme is a little bit more robust.

5950
10:06:13.091 --> 10:06:14.982
And then of course, our yarn dot lock.

5951
10:06:14.982 --> 10:06:20.887
So this advanced project looks pretty similar to what we're going to be working with anyways.

5952
10:06:20.887 --> 10:06:24.230
Now I do want to talk about this soul hint, though.

5953
10:06:24.230 --> 10:06:35.130
So what is solvent solvent is known as a solidity linter that we can use to lint our code linting is the process of running a program that will analyze code for potential errors.

5954
10:06:35.130 --> 10:06:42.363
It also does a little bit of formatting, oftentimes, es Lint is a way to lint for JavaScript code.

5955
10:06:42.363 --> 10:06:55.363
So hint is a way to lint for solidity code, we use prettier to format our code, and we can use soul hint to lint, our code, they are often used a little bit interchangeably, even though that's not exactly correct, as they are a little bit different.

5956
10:06:55.363 --> 10:07:03.459
We can run this linter on our code by running yarn, sole hint, and then type the name of the files that we want to lint.

5957
10:07:03.459 --> 10:07:10.903
So we do contracts, slash and then you can just do start out so everything looks okay, nothing will happen.

5958
10:07:10.903 --> 10:07:16.583
Well, let's say we have a variable that we don't explicitly say the visibility of it is.

5959
10:07:16.583 --> 10:07:23.815
This isn't the best practice because ideally, we always say exactly what the visibility of some variable is.

5960
10:07:23.815 --> 10:07:25.266
This obviously gets defaulted.

5961
10:07:25.364 --> 10:07:27.478
But it's usually better to be more explicit.

5962
10:07:28.364 --> 10:07:42.739
yarn, so hint, contracts start up so it'll give us a warning, saying we should explicitly Mark visibility of state, this linter is a good way to check for some best practices for running our code.

5963
10:07:42.739 --> 10:07:47.801
So we're definitely going to keep a small hint around.

5964
10:07:47.801 --> 10:07:52.855
Now that we've got a repo here, let's add a couple of our common setup pieces here.

5965
10:07:52.855 --> 10:07:54.170
So in prettier.

5966
10:07:54.170 --> 10:07:59.073
rc, we're going to swap this out with what we've been using so far.

5967
10:07:59.073 --> 10:08:03.538
Tab of the form us tab is false, semi false, single quote, also false.

5968
10:08:03.538 --> 10:08:16.025
We're going to update our prettier dot ignore node modules, package dot JSON image artifacts, cache coverage ID v dot star, readme, and coverage and anything else you want to add in here.

5969
10:08:16.025 --> 10:08:18.804
And we're going to scroll up to our contracts folder.

5970
10:08:18.804 --> 10:08:22.610
And we're going to swap this greeter dot soul out with our fund me dot soul.

5971
10:08:22.610 --> 10:08:25.625
Now let's go ahead and add our contracts in here.

5972
10:08:25.625 --> 10:08:34.301
If you're following along with the repo, you go to the contracts folder, there's actually another folder in here and the contracts look a little bit different.

5973
10:08:34.301 --> 10:08:41.030
So if you have those contracts, steal from remix, let's actually grab them from remix because we're going to make a couple of changes to them.

5974
10:08:41.030 --> 10:08:52.301
If you don't have remix up anymore, which you probably shouldn't, because you should be taking breaks, you can jump back over to Lesson four remix Funmi jump into the repo here and grab the contracts from inside here.

5975
10:08:52.364 --> 10:08:56.140
Just go to the fun v dash Free Code Camp tutorial and grab the code from there.

5976
10:08:56.140 --> 10:08:59.490
So we're gonna grab just fun me and price converter dot soul.

5977
10:08:59.490 --> 10:09:05.429
So go ahead and delete that old file, create a new one and call it fund me dot song.

5978
10:09:05.429 --> 10:09:06.880
Paste it in there.

5979
10:09:06.880 --> 10:09:11.745
And then we're going to create the price converter.

5980
10:09:11.745 --> 10:09:12.792
That's all.

5981
10:09:12.792 --> 10:09:17.500
Now we have both our Funmi and our price converter contracts in here.

5982
10:09:17.500 --> 10:09:24.882
Now one of the first things that we want to do one of the first things that we did last time was we ran yarn compile to make sure that our code is actually working the way we want to.

5983
10:09:24.882 --> 10:09:32.380
And before we actually hit Compile, one of the things that we're going to need to do is come to our Hardhead dot config, we're going to make sure we're on the correct solidity version.

5984
10:09:32.380 --> 10:09:34.538
So we're going to do zero point 8.

5985
10:09:34.538 --> 10:09:34.918
8 here.

5986
10:09:34.918 --> 10:09:39.247
And let's go ahead and try to compile.

5987
10:09:39.365 --> 10:09:42.605
So we can run yarn Hardhead compile.

5988
10:09:44.365 --> 10:09:45.783
actually get an error here.

5989
10:09:47.365 --> 10:09:53.880
contracts imported from contracts slash fund me dot soul is not installed, try installing it using npm.

5990
10:09:53.880 --> 10:10:00.069
In remix, we went ahead and just imported at chainlink slash contracts, right from our NPM and or GitHub.

5991
10:10:00.069 --> 10:10:22.233
But in our local code, we have to tell Hardhead specifically, where to get this from, we want to download this specifically from the NPM package manager at chainlink slash contracts, we can download it simply by running yarn, add dash dash dev at chainlink slash contracts.

5992
10:10:23.365 --> 10:10:27.615
Now that we've downloaded it into our file, we'll be able to see it in Node modules here.

5993
10:10:27.615 --> 10:10:34.235
Hardhead is now smart enough to know that at chain link slash contracts is going to point to that node module that we have.

5994
10:10:34.235 --> 10:10:41.508
So we can now run yarn Hardhead compile boom, now we can see compiled three solidity files successfully.

5995
10:10:41.508 --> 10:10:48.575
So now we have our contracts in here and our code is compiling successfully.

5996
10:10:48.575 --> 10:10:53.348
We're probably going Want to deploy our code? Now in our last section, I know we use the scripts module.

5997
10:10:53.348 --> 10:10:56.225
And we made our own manual deploy script.

5998
10:10:56.366 --> 10:11:04.866
However, something that you'd notice, the more that you work with just raw ethers, or even just hard hat is that keeping track of all our deployments can get a little bit tricky.

5999
10:11:04.866 --> 10:11:08.753
If you just use a deploy script, it's not saving our deployments to any file.

6000
10:11:08.753 --> 10:11:16.769
Additionally, having everything in the deploy script for deploying can make the tests and the deploy scripts, maybe not work exactly hand in hand.

6001
10:11:16.769 --> 10:11:26.015
And there are a couple of other things that might be a little bit tricky to work on, we're actually going to work with a package that makes everything I just mentioned, and a couple other things way easier.

6002
10:11:26.015 --> 10:11:30.313
And this package that I'm talking about is going to be the hard hat deploy package.

6003
10:11:30.313 --> 10:11:34.579
There's a link to this package in the GitHub repository associated with this course.

6004
10:11:34.579 --> 10:11:38.307
It's a hardhat plugin for replicable deployments and easy testing.

6005
10:11:38.366 --> 10:11:42.738
And if we scroll down to installation, we can see we install it basically the normal way.

6006
10:11:42.738 --> 10:11:43.958
They're using npm.

6007
10:11:43.958 --> 10:11:46.529
And we're gonna go ahead and use yarn.

6008
10:11:46.529 --> 10:11:51.384
So for us to add it, we'll do yarn, add hardhat dash deploy.

6009
10:11:51.384 --> 10:11:56.075
And then of course, we're gonna do dash dash Dev.

6010
10:11:56.075 --> 10:12:01.970
Once done deploying this require statement to our hard hat.

6011
10:12:01.970 --> 10:12:02.595
config.

6012
10:12:02.595 --> 10:12:02.803
js.

6013
10:12:02.803 --> 10:12:06.316
Once again, basically the config is our entry point.

6014
10:12:06.316 --> 10:12:08.445
This is where we're gonna get started.

6015
10:12:08.445 --> 10:12:11.111
And we can go ahead and delete our deploy.

6016
10:12:11.111 --> 10:12:11.779
js script.

6017
10:12:11.779 --> 10:12:24.428
Now if we run yarn hardhat, you see that we have a bunch of new tasks in here, with one of them being this deploy task, this deploy task is going to be the main task that we use to deploy our contracts.

6018
10:12:24.428 --> 10:12:32.754
Instead of writing our deploy scripts in the Scripts folder, we're actually going to create a new folder, we can create a new folder by just doing MK dir deploy.

6019
10:12:32.754 --> 10:12:35.915
Or you can always right click and hit New Folder.

6020
10:12:35.915 --> 10:12:40.673
This deploy folder is going to be where a lot of hard hat Deploy Module looks to deploy code.

6021
10:12:40.673 --> 10:12:43.301
And it's going to be where we are writing our scripts.

6022
10:12:43.301 --> 10:12:46.735
To write our scripts, we usually need to add one more thing in here.

6023
10:12:46.735 --> 10:12:52.992
Since we're going to be using ethers JS in all of our scripts, we want to add Hardhead deploy ethers to our package here.

6024
10:12:52.992 --> 10:12:59.367
Now, instead of just doing yarn, add dash dev hard at deploy ethers, we're going to do something a little bit weird.

6025
10:12:59.367 --> 10:13:04.817
We're going to do yarn add or npm install dash dash Dev, and we're going to install it like this.

6026
10:13:04.817 --> 10:13:06.055
So let me just copy this.

6027
10:13:06.055 --> 10:13:08.071
And you can just copy that from the repo.

6028
10:13:08.071 --> 10:13:12.296
And we'll do yarn, add dash dash Dev, and paste that in here.

6029
10:13:12.367 --> 10:13:20.500
What we're doing is we're taking at nomic labs, hard hat ethers, which we've used before, and we're overriding it with hard hat deploy ethers.

6030
10:13:20.500 --> 10:13:24.334
Remember how in our last project, we used hard hat ethers.

6031
10:13:24.334 --> 10:13:28.070
So that hard hat could override ethers to use hard hat deploy.

6032
10:13:28.070 --> 10:13:35.167
We use hard hat deploy ethers, so that hard hat deploy can override Hardhead, which overrides ethers, which is kind of funny.

6033
10:13:35.167 --> 10:13:43.144
When you say like that, this will enable ethers to keep track of and remember all the different deployments that we actually make in our contract.

6034
10:13:43.144 --> 10:13:48.736
So if we look at our package, JSON, and now we can see our nomic labs dashboard had ethers.

6035
10:13:48.736 --> 10:13:51.259
Now the version of it is going to be MPM.

6036
10:13:51.259 --> 10:13:52.747
Hardhead deploy ethers.

6037
10:13:52.747 --> 10:14:02.118
This is our package dot JSON, basically saying the hard hat ethers package is now overwritten by the hard hat deploy ethers package, which is what we want.

6038
10:14:02.118 --> 10:14:03.055
Alright, great.

6039
10:14:03.055 --> 10:14:13.722
So now that we have that setup, we can start writing our deploy scripts, the way that Hart had to play works is all the scripts that get added to our deploy folder will get run when we run yarn, hard hat deploy.

6040
10:14:13.722 --> 10:14:18.499
So a good practice is usually to number them so that they run in the order that you want them to run in.

6041
10:14:18.499 --> 10:14:32.810
So since we only have one contract that we want to deploy the Funmi contract, we're going to do 01 Deploy Funmi Jas, and in this script, this is going to be where we define how to deploy the fundament contract.

6042
10:14:32.810 --> 10:14:35.819
Alright, so we're in our deploy Funmi scripts.

6043
10:14:35.819 --> 10:14:41.008
Now traditionally, what did we do, we did imports, we did the main function.

6044
10:14:41.008 --> 10:14:50.253
And then we did calling of main function, that Hardhead deploy is a little bit different, we're still going to import our libraries and packages, but we're not going to have main function.

6045
10:14:50.253 --> 10:14:59.141
And we're also not going to call the main function when we run Hardhead deploy Harnett deploy is actually going to call a function that we specify.

6046
10:14:59.141 --> 10:15:00.240
In this script here.

6047
10:15:00.240 --> 10:15:06.279
What we're going to do is we're gonna create a function, we'll call it deploy funk.

6048
10:15:06.368 --> 10:15:19.013
We're going to export this deploy function as the default function for Hardhead deploy to look for, so we could say, module that exports dot default equals deploy funk.

6049
10:15:19.013 --> 10:15:24.284
To test it out, we can go ahead and do console dot log, hi.

6050
10:15:24.284 --> 10:15:29.505
And then in our terminal, run yarn, hard hat, deploy.

6051
10:15:29.505 --> 10:15:33.214
Oops, get rid of the parentheses here.

6052
10:15:33.214 --> 10:15:33.767
Sorry.

6053
10:15:33.767 --> 10:15:34.967
Run it again.

6054
10:15:34.967 --> 10:15:39.175
And we can see it went and ran our deploy func here.

6055
10:15:39.175 --> 10:15:49.162
Now if this syntax is easier for you to understand, go ahead and use this syntax and we're going to be passing the heart at runtime environment as a parameter to this function.

6056
10:15:49.162 --> 10:15:57.758
However, if we go to the heart hat deploy documentation, and we scroll down to an example script, the syntax looks a little bit different.

6057
10:15:57.758 --> 10:16:01.969
And let me just explain what's going on here and how we're going to be writing ours.

6058
10:16:01.969 --> 10:16:16.143
So instead of kind of defining everything like this, and defining the function name, similar to what we were doing before, we're actually going to using a nameless, a synchronous function, we're going to make it an anonymous function, similar to what we've seen before.

6059
10:16:16.143 --> 10:16:23.877
So instead, we're going to say async parameters like this, I'm going to pass our parameters our heart at runtime environment in here.

6060
10:16:23.877 --> 10:16:26.335
And it's going to be an arrow function.

6061
10:16:26.335 --> 10:16:31.589
And then we're going to wrap this whole thing in module dot exports.

6062
10:16:31.589 --> 10:16:39.702
So we're gonna say, module, dot exports, equals this async function like this.

6063
10:16:39.702 --> 10:16:47.190
This syntax here is nearly identical to what's up here, we just don't have a name for our async function.

6064
10:16:47.190 --> 10:16:50.046
So this is how we're going to set it up instead.

6065
10:16:50.046 --> 10:16:56.797
But if this syntax is a little bit confusing for you feel free to use this above as the two of these are going to be the same.

6066
10:16:56.797 --> 10:17:04.569
Now the next thing that most of the documentation does is it pulls out the variables and functions out of the HRV that we're going to use.

6067
10:17:04.569 --> 10:17:07.210
HRV is the heart hat runtime environment.

6068
10:17:07.210 --> 10:17:17.894
Whenever we run a deploy script, heart hat deploy automatically calls this function and just passes the hard hat object into it similar to in back in hard hat simple storage.

6069
10:17:17.894 --> 10:17:19.674
In our deploy script.

6070
10:17:19.674 --> 10:17:24.322
We had ethers run in network come from hard hat, instead of coming from hard hat.

6071
10:17:24.370 --> 10:17:27.512
We're coming from HRV, which is basically the same thing as hard hat.

6072
10:17:27.512 --> 10:17:34.735
For our script, we're only going to use two variables from a jury when you use const.

6073
10:17:34.735 --> 10:17:38.052
Get named accounts.

6074
10:17:38.052 --> 10:17:40.845
And deployments.

6075
10:17:41.370 --> 10:17:43.666
This syntax might look a little bit weird for you.

6076
10:17:44.370 --> 10:17:47.042
a way to pull these exact variables out of a tree.

6077
10:17:47.370 --> 10:17:54.570
kind of the same thing as just doing a tree dot get named accounts and HRA dot deployments.

6078
10:17:54.570 --> 10:17:59.606
But pulling them out like this means we don't have to add a tree at the beginning anymore.

6079
10:17:59.606 --> 10:18:04.644
And then additionally, additionally, JavaScript has something called syntactic sugar.

6080
10:18:04.644 --> 10:18:11.314
So instead of doing this on two lines like this, we can actually do that whole bit on one line.

6081
10:18:11.314 --> 10:18:18.094
So instead, we just extrapolate those two variables, right in the function declaration.

6082
10:18:18.094 --> 10:18:21.956
So this line is the exact same thing as doing this line.

6083
10:18:21.956 --> 10:18:28.636
This is an asynchronous, nameless function using the arrow notation, or working with our deploy scripts here.

6084
10:18:28.636 --> 10:18:31.658
And we're default, exporting it with module dot exports.

6085
10:18:31.658 --> 10:18:33.036
I don't know that was a lot.

6086
10:18:33.036 --> 10:18:35.588
And another is kind of a lot of syntactic sugar here.

6087
10:18:35.588 --> 10:18:39.475
But if that's really confusing for you, just feel free to use the above.

6088
10:18:39.475 --> 10:18:50.423
And whenever we refer to get named accounts, you can also just do a three dot get named accounts, or a three dot deployments.

6089
10:18:50.423 --> 10:18:59.303
So hopefully, that's clear that this top part is gonna be the same as this bottom part right here, whichever one you feel more comfortable working with.

6090
10:18:59.371 --> 10:19:02.799
But alright, now that we've gotten all that out of the way, let's continue with the script.

6091
10:19:02.799 --> 10:19:12.002
So we're using this deployments object, reason this deployments object to get two functions, those two functions are going to be the deploy function, and the log function.

6092
10:19:12.002 --> 10:19:15.080
So we're gonna say const, deploy log equals deployments.

6093
10:19:15.080 --> 10:19:19.287
So we're going to pull these two functions out of deployments.

6094
10:19:19.287 --> 10:19:23.203
And then we're also going to do const Deployer.

6095
10:19:23.371 --> 10:19:26.447
Equals await, get named accounts.

6096
10:19:28.371 --> 10:19:35.523
this new deploy function, this new log function, and we're grabbing this deployer account from this weird get named accounts function.

6097
10:19:35.523 --> 10:19:42.306
What's this get named accounts function, this get named accounts is a way for us to get named accounts.

6098
10:19:42.371 --> 10:19:52.246
When working with ethers we saw when working with ethers, we can actually get our accounts based off of the number in the Account section of each network.

6099
10:19:52.246 --> 10:20:10.746
So for example, in this list of private keys, private keys zero private key one private key two, it might get a little confusing to remember which ones which so instead of working like that, we can add a section at the bottom called named accounts where we can name each one of those spots in the accounts array.

6100
10:20:10.746 --> 10:20:12.467
So we'll do named accounts.

6101
10:20:12.467 --> 10:20:17.129
And we'll say one of the accounts that will name is going to be named Deployer.

6102
10:20:17.129 --> 10:20:22.725
And we're gonna say by default, the zero with account is going to be Deployer.

6103
10:20:22.725 --> 10:20:28.904
We can also specify which number is going to be the deployer account across different chains.

6104
10:20:28.904 --> 10:20:36.819
For example, on Rigby we wanted the deployer account to be the first position, we could do something like this or on hard hat, we could do it like this.

6105
10:20:36.819 --> 10:20:38.404
We can create multiple users.

6106
10:20:38.404 --> 10:20:46.657
Like for example, if we wanted to do a user for some test or something, and we'll just say the default is one or whatever we wanted in here.

6107
10:20:46.657 --> 10:20:52.802
So back in our deploy fun me We're going to say we're going to grab that deployer account from our named accounts.

6108
10:20:52.802 --> 10:20:57.752
And then finally, we're going to grab our chain ID for reasons that will come clear pretty soon.

6109
10:20:57.752 --> 10:21:04.277
So we'll do const, chain ID equals network dot config dot chain ID.

6110
10:21:04.277 --> 10:21:12.318
Now, how do we actually deploy this fund me contract? Well, let's think about this for a little bit.

6111
10:21:12.372 --> 10:21:16.581
When working with remix, it was pretty easy, right? We just deployed it to a test net.

6112
10:21:16.581 --> 10:21:21.572
Ah, that's kind of the issue there, isn't it deploying to a rink, the test net is a little bit slow.

6113
10:21:21.572 --> 10:21:35.684
We don't always want to have to deploy to one of these slow test nets or even a main net when tinkering and fiddling with our contracts, do we know that's gonna be really bad, we really want to deploy to a test net as a last stop after we've done all our testing locally.

6114
10:21:35.684 --> 10:21:42.635
Or we can deploy it to a test that to see some very specific code work, like for example, with the chain link documentation.

6115
10:21:42.635 --> 10:21:45.597
So ideally, we deploy this to a local network first.

6116
10:21:45.597 --> 10:22:00.073
But can we just do that? Well, if we look in our price converter, dot Seoul, we have this hard coded address in here, this 0x address, if we go to Doc's dot chain that link EVM chains, contract addresses for Aetherium data feeds.

6117
10:22:00.073 --> 10:22:03.854
That address is the eth USD, specifically for Rinkeby.

6118
10:22:03.854 --> 10:22:10.759
What if we work on the Hard Hat Network? Example? default network? Hard Hat.

6119
10:22:10.759 --> 10:22:15.587
And then like I said before, if you don't write this in part, it is automatically the default network.

6120
10:22:15.587 --> 10:22:19.730
But if we're to point to the Hard Hat Network, harder network is a blank blockchain.

6121
10:22:19.730 --> 10:22:29.169
And it gets destroyed every time our scripts finish, or even if we're working with a local node, this price feed contract won't exist, one of the code there won't be updated with data.

6122
10:22:29.169 --> 10:22:40.147
So what do we do? How do we test and interact with our code locally? Is there a way we can do this? Well, one of the ways that we can do this that we'll learn a little bit later is actually forking a blockchain, where you can keep stuff hard coded.

6123
10:22:40.147 --> 10:22:45.741
But usually, it's still better to figure out how to do everything with something called mocks.

6124
10:22:45.741 --> 10:22:53.717
There's a great Stack Overflow question that just says, What is mocking and mocking is primarily used for unit testing, which we'll talk about in a little bit.

6125
10:22:53.717 --> 10:22:57.760
And object under test may have dependencies on other complex objects.

6126
10:22:57.760 --> 10:23:06.601
To isolate the behavior of the object, you want to replace other objects by mocks that simulate the behavior of the real objects.

6127
10:23:06.601 --> 10:23:10.891
In short, mocking is creating objects that simulate behavior of real objects.

6128
10:23:10.891 --> 10:23:13.928
Now, this might seem like a lot of words.

6129
10:23:13.928 --> 10:23:20.717
But basically, what we want to do is we want to make a fake price feed contract that we can use and we can control when working locally.

6130
10:23:20.717 --> 10:23:31.273
So back here, I'm just going to leave a note in here saying, When going for local host or Hard Hat Network, we want to use a mock.

6131
10:23:31.273 --> 10:23:36.017
Okay, great, well, we can use a mock and we'll learn how to make one of those in a little bit.

6132
10:23:36.017 --> 10:23:51.023
Well, what happens when we want to change chains, for example, back in dots dot chain to link EVM chains, contract addresses, there are a ton of different block chains that have price feeds on them.

6133
10:23:51.023 --> 10:23:56.109
And on each one of these blockchains, the eth USD price feed is going to be a little bit different.

6134
10:23:56.109 --> 10:24:08.814
For example, we're looking at ETH USD, the address of eth USD for Aetherium main net is different from the address of eth USD for Rigby, which makes sense, they're totally different contracts on different chains, they have very similar functionality.

6135
10:24:08.814 --> 10:24:10.169
And they do nearly the exact same thing.

6136
10:24:10.169 --> 10:24:12.115
But they're still different.

6137
10:24:12.115 --> 10:24:23.127
We're also going to need a way for us to modularize or parameterize, this address in here, so that no matter what chain we deploy to, we don't have to change any of our code, we can always have our code be exactly the same.

6138
10:24:23.127 --> 10:24:27.293
And we don't have to come in here and like flip values and flip variables and stuff.

6139
10:24:27.293 --> 10:24:30.986
So let's keep that all of that in mind as we write the rest of this.

6140
10:24:30.986 --> 10:24:32.856
Now in order to parameterize.

6141
10:24:32.856 --> 10:24:37.598
This, we actually want to prioritize and do a little refactoring of our fundamental soul.

6142
10:24:37.598 --> 10:24:42.675
Refactoring basically means going back and, and changing the way your code works.

6143
10:24:42.675 --> 10:24:50.804
Right now we have this constructor function, right the constructor function is the function that automatically gets called whenever we deploy our contract.

6144
10:24:50.804 --> 10:24:56.357
Right now it's not doing a whole lot right now it's just updating the owner variable to be whoever sent in the contract.

6145
10:24:56.357 --> 10:24:59.066
But we can actually have a do much more than that.

6146
10:24:59.066 --> 10:25:11.111
Since this constructor is a function just like every other function, we can actually have it take parameters, one of the parameters that we might like for it to have is going to be the address of a price feed.

6147
10:25:11.111 --> 10:25:14.077
So let's go ahead and add this and figure out how to refactor all this code.

6148
10:25:14.077 --> 10:25:19.701
So we're going to add constructor address, price feed for the constructor in here.

6149
10:25:19.701 --> 10:25:21.078
When we deploy our contract.

6150
10:25:21.078 --> 10:25:25.511
Now we're going to pass it the eth USD price feed address depending on what chain we're on.

6151
10:25:25.511 --> 10:25:34.098
If we're on rink B, we'll use this address if one polygon will use a different one b&b, different one, Gnosis hecho, avalanche, etc, you get the picture.

6152
10:25:34.098 --> 10:25:36.582
So we're going to marginalize this like so.

6153
10:25:36.582 --> 10:25:56.375
Now that our constructor takes a parameter for the price feed, we can actually save an aggregator v3 interface object as a global variable in our price converter, we just create a price feed variable of type aggregator v3 interface, which again, we're importing from the chainlink repo, which is an interface object which gets compiled down to the ABI.

6154
10:25:56.375 --> 10:26:00.510
If you match an ABI with up with an address, you get a contract that you can interact with.

6155
10:26:00.510 --> 10:26:01.899
So we're going to do the same thing here.

6156
10:26:01.899 --> 10:26:14.287
We're gonna say, aggregate Tor, v3 interface, public price feed, ration and call this price feed address so that these don't have the same name.

6157
10:26:14.287 --> 10:26:31.222
And in our constructor, we're going to say price feed equals, and we're going to do the exact same thing we did with our price converter equals aggregate tore the three interface of price feed address.

6158
10:26:31.222 --> 10:26:42.273
Like so now, we have this price feed address that's variable and modularized, depending on whatever chain that we're on.

6159
10:26:42.273 --> 10:26:47.937
Now, what we can do is we can grab this price feed address, and we can use it for our price converter.

6160
10:26:47.937 --> 10:26:55.585
So where are we using our price converter? Well, just a quick reminder, we're using using price converter for you at 256.

6161
10:26:55.585 --> 10:26:59.646
We're using this as a library on top of our unit 256 type.

6162
10:26:59.646 --> 10:27:03.568
So we're calling message dot value dot get conversion rate.

6163
10:27:03.568 --> 10:27:17.309
So we look at our price converter, we have this function get conversion rate, which takes an FML as its initial parameter, which again, since this is a library, it automatically passes the message dot value into this get conversion rate function.

6164
10:27:17.375 --> 10:27:24.907
But we could also pass in this price feed, and therefore we wouldn't need to hard code it in the get price anymore.

6165
10:27:24.907 --> 10:27:27.185
So let's go ahead and figure out how to do that.

6166
10:27:27.185 --> 10:27:32.323
Well, what we can do is we can do message dot value dot get conversion rate, we'll stick price feed in here.

6167
10:27:32.323 --> 10:27:42.876
And then we'll have to update our get conversion rate to do a comma so that it takes a second parameter, because remember, again, the initial parameter is going to be message dot value.

6168
10:27:42.876 --> 10:27:47.328
And the second parameter is going to be what we define here.

6169
10:27:47.328 --> 10:27:53.601
So we'll do s amount, comma ag reg gate Tor v3 interface.

6170
10:27:53.601 --> 10:27:57.601
And we'll call this price feed.

6171
10:27:57.601 --> 10:28:05.409
And now, when we call our get price function, we can pass the price feed to the get price function.

6172
10:28:05.409 --> 10:28:08.010
And up here we can have get price.

6173
10:28:08.010 --> 10:28:17.235
Take, you guessed it an aggregate or the three interface called price feed.

6174
10:28:17.235 --> 10:28:22.893
And now we no longer need to hard code in the price feed.

6175
10:28:22.893 --> 10:28:28.501
And we can just delete those lines and have it compile like this, which is awesome.

6176
10:28:28.501 --> 10:28:46.998
So quick refresher, we're parameterizing that price feed address and passing it in with a constructor that gets saved as a global variable to an aggregator v3 interface type, or passing it to a get conversion rate function, which passes it to the get price function, which then just calls latest round data.

6177
10:28:46.998 --> 10:28:54.511
And we probably could have made this even easier, probably could have just got rid of the get price function and stuck this code in the get conversion rate.

6178
10:28:54.511 --> 10:28:55.629
But we'll leave it there for now.

6179
10:28:55.629 --> 10:28:58.549
Now that we've done that refactoring, let's make sure it works.

6180
10:28:58.549 --> 10:29:03.910
Yarn Hardhead, compile, invalid value undefined for hardhat dot config dot networks.

6181
10:29:03.910 --> 10:29:07.243
Let's go to the let's go to the config real quick.

6182
10:29:07.377 --> 10:29:10.011
That's because the default network needs to be outside of networks.

6183
10:29:10.011 --> 10:29:10.884
My mistake.

6184
10:29:10.884 --> 10:29:12.550
Let's try that again.

6185
10:29:12.550 --> 10:29:15.803
I spelled interface wrong and the price converter.

6186
10:29:15.803 --> 10:29:26.770
And a quick note, if gives you an error like this, oftentimes, you can command click or control click and open that file up right in the editor, which saves you some time, we're going to have defined the line and find the file.

6187
10:29:26.770 --> 10:29:28.589
But yeah, let's spell that correctly.

6188
10:29:28.589 --> 10:29:30.131
And let's try this again.

6189
10:29:30.131 --> 10:29:31.036
And awesome.

6190
10:29:31.036 --> 10:29:33.812
It looks like it's compiling correctly.

6191
10:29:33.812 --> 10:29:46.304
And we just have some warnings, it looks like these warnings are just about this git version, which is because we're shadowing this, we're creating a new price variable down here, you've no we just created a global price free variable.

6192
10:29:46.377 --> 10:29:50.996
Let's just go ahead and delete the get version function altogether since we're not even going to really need it.

6193
10:29:50.996 --> 10:29:54.546
And we only use the Git version to show you how to actually start working with interfaces.

6194
10:29:54.546 --> 10:29:58.156
And then we'll compile it one more time for good measure.

6195
10:29:58.156 --> 10:30:00.444
Boom compiled successfully.

6196
10:30:00.444 --> 10:30:01.121
Awesome.

6197
10:30:01.377 --> 10:30:03.196
So now we've just refactored our code.

6198
10:30:04.377 --> 10:30:07.894
feed address depending on the network that we're on.

6199
10:30:08.377 --> 10:30:08.699
great.

6200
10:30:12.377 --> 10:30:15.611
Funmi script, and let's learn how to actually deploy the rest of it.

6201
10:30:15.611 --> 10:30:24.627
In order for us to deploy a contract we remember from our last sections that we use the contract factories, with heart hit Deploy, we can just use this deploy function.

6202
10:30:24.627 --> 10:30:30.849
And to use the deploy function, we'll say const Funmi, which is going to be the name of our contract, equals await.

6203
10:30:30.849 --> 10:30:39.584
And we'll call this deploy function, the name of the contract that we're deploying right now, and then a list of overrides that we want to add here.

6204
10:30:39.584 --> 10:30:45.015
So we're gonna say who is actually deploying this by saying from, we're gonna say it's from the Deployer.

6205
10:30:45.015 --> 10:30:53.344
We're gonna pass any arguments to the constructor In this args piece here, which we just added a single Argh.

6206
10:30:53.344 --> 10:31:01.878
So these brackets, we're going to make it a list of arguments, we're going to put the price feed address in here, which we'll show you how to do in a second, put price feed address.

6207
10:31:01.878 --> 10:31:08.674
And then we're also going to do some custom logging here so that we don't have to do all that console dot log stuff that we've been doing this whole time.

6208
10:31:08.674 --> 10:31:11.414
And we need to put something in here.

6209
10:31:11.414 --> 10:31:13.442
We need to put an address in here.

6210
10:31:13.442 --> 10:31:18.301
And you can use this backslash star to put like a common in between your code.

6211
10:31:18.378 --> 10:31:22.902
We can't just do const address equals, you know the address and stick it in here.

6212
10:31:22.902 --> 10:31:25.139
Well, I mean, we could but we're not really prioritizing now.

6213
10:31:25.139 --> 10:31:27.733
Right? We're kind of back to just hard coding it here.

6214
10:31:27.733 --> 10:31:44.700
So what can we do instead? Well, what we can do is we can actually use the chain ID to do something like if chain ID is x, use address, Y, or if chain ID is Z use address A.

6215
10:31:44.700 --> 10:31:47.378
So we can do something that looks like this.

6216
10:31:47.378 --> 10:31:51.190
And to enable this functionality, we actually take a page out of the Ave GitHub.

6217
10:31:51.190 --> 10:31:58.644
So Ave is another protocol that's on multiple chains and has to deploy their code to multiple chains and work with multiple different addresses.

6218
10:31:58.644 --> 10:32:02.473
So what they do is they use a number of different useful tricks.

6219
10:32:02.473 --> 10:32:05.503
But one of the main ones is using this helper hardhat config.

6220
10:32:05.503 --> 10:32:09.778
Now they're using TypeScript with JavaScript, but it's gonna be the same thing.

6221
10:32:09.778 --> 10:32:15.926
With this config, they have different variables, depending on what network that they're actually on.

6222
10:32:15.926 --> 10:32:19.706
And depending on the network that they're on, they use different variables.

6223
10:32:19.706 --> 10:32:24.632
So they use this network config almost to do exactly what we're trying to do here.

6224
10:32:24.632 --> 10:32:32.051
So what we want to do is we're going to create a new file at the root directory, so just click down here, new file.

6225
10:32:32.051 --> 10:32:38.795
And we're going to call it helper, hard hat config dot j, s.

6226
10:32:38.795 --> 10:32:41.212
And this is where we're going to define that network config.

6227
10:32:41.212 --> 10:32:48.056
And this is where we're going to say, hey, if you're on network, a, use this address network, be this use this address, etc.

6228
10:32:48.056 --> 10:32:51.264
So we're going to create an object called const.

6229
10:32:51.264 --> 10:32:52.247
Network config.

6230
10:32:53.379 --> 10:32:55.120
equals and we're going to add a bunch of stuff in here.

6231
10:32:55.379 --> 10:32:58.040
main network that we're working with right now is rinky.

6232
10:32:58.379 --> 10:33:00.409
has a chain ID of four.

6233
10:33:04.379 --> 10:33:06.083
named Rinkeby.

6234
10:33:12.379 --> 10:33:16.575
be the price feed address of rank B of the eth USD price feed.

6235
10:33:16.575 --> 10:33:22.009
So we're going to copied from the documentation or from the GitHub, whatever you want to do, and paste it in here.

6236
10:33:22.009 --> 10:33:29.772
Now we have a simple methodology of keeping track of different price feeds a different contract addresses across different chains.

6237
10:33:29.772 --> 10:33:33.729
Let's say for example, we wanted to deploy to Polygon as well.

6238
10:33:33.729 --> 10:33:38.361
Well, first, what are we going to need? Well, we're going to need the chain ID of polygon.

6239
10:33:38.361 --> 10:33:42.845
So a quick little Google Search brings us to the polygon documentation.

6240
10:33:42.845 --> 10:33:45.148
And we see the chain ID is 137.

6241
10:33:45.148 --> 10:33:46.301
So I'll do 137.

6242
10:33:46.301 --> 10:33:51.231
What's a little brackets here, we'll say name, polygon.

6243
10:33:51.231 --> 10:33:55.057
Then we'll do a comma eth USD, price feed.

6244
10:33:55.057 --> 10:33:59.036
And then we'll add the price feed of eth USD on polygon.

6245
10:33:59.036 --> 10:34:05.649
So docstoc, chain link, polygon or Matic and then we'll look up eth, USD.

6246
10:34:05.649 --> 10:34:08.109
And boom, we see it right here.

6247
10:34:08.109 --> 10:34:11.157
We've grabbed this address, and we paste it in.

6248
10:34:11.157 --> 10:34:15.625
Well, what about the Hardhead? Network? We'll get to that in just a second, don't you worry.

6249
10:34:15.625 --> 10:34:18.661
And then at the bottom, we need to export this network config.

6250
10:34:18.661 --> 10:34:20.864
So our other scripts can actually work with it.

6251
10:34:20.864 --> 10:34:26.396
So we'll do module dot exports equals network config.

6252
10:34:26.396 --> 10:34:35.270
And we're going to actually export a couple of things from this file, which is why we're doing it like this instead of that default way that I showed you before.

6253
10:34:35.270 --> 10:34:41.317
So back in our script, now, what can we do? Well, first, we want to go ahead and import that network config.

6254
10:34:41.380 --> 10:34:43.210
So we'll say const.

6255
10:34:47.380 --> 10:34:52.560
we'll import it, we'll go down and directory to help our Hardhead config and save.

6256
10:34:52.560 --> 10:34:57.058
And I just want to mention this one more time, just so that it doesn't confuse anybody.

6257
10:34:57.058 --> 10:35:07.960
This syntax here, constant network config with the little curly braces around it is the same is if I went const.

6258
10:35:07.960 --> 10:35:13.913
Helper config equals this thing, which helper config is now kind of this whole file.

6259
10:35:13.913 --> 10:35:22.080
And then const network config equals Hopper config dot network config.

6260
10:35:22.080 --> 10:35:28.822
So again, this index is just kind of an easy way to extrapolate or pull out just the network config from this file.

6261
10:35:28.822 --> 10:35:30.051
So that's how that works.

6262
10:35:30.051 --> 10:35:40.331
And that's why we export it at the bottom so that we can do this, please use the GitHub repository to ask questions and discussions especially about some of this JavaScript stuff.

6263
10:35:40.331 --> 10:35:40.822
Alright, great.

6264
10:35:40.822 --> 10:35:47.756
So now that we have this network configured here, we can now do this part of where we say if China d z use a if chain ID is x use y.

6265
10:35:47.756 --> 10:35:58.251
So Since our helper config is nicely in this kind of dictionary, key value pair style, what we can do is we can say const.

6266
10:35:58.251 --> 10:35:59.154
eth USD.

6267
10:35:59.381 --> 10:36:23.781
Price feed address equals network config at the chain ID, because if Francina D, or it'll be this object, French entity polygon, it'll be this object at the eth USD price feed, we're going to save this to eth USD price feed address.

6268
10:36:23.781 --> 10:36:33.800
And now no matter what chain we're on, whenever we run hard hat deploy, if I run yarn, hard hat deploy dash dash network Rinkeby.

6269
10:36:33.800 --> 10:36:35.804
This chain ID is going to be four.

6270
10:36:35.804 --> 10:36:38.881
And so it's going to use this price feed address.

6271
10:36:38.881 --> 10:36:47.181
If I do dash test network polygon, and I remember to add both ring P and polygon to my networks, like here, the channel is going to be 137.

6272
10:36:47.181 --> 10:36:49.523
It's going to use this price feed address.

6273
10:36:49.523 --> 10:36:50.729
So this is awesome.

6274
10:36:50.729 --> 10:36:52.574
This is exactly what we want.

6275
10:36:52.574 --> 10:37:00.653
But is it everything that we want? Those of you who have been questioning while I have been coding and talking, you might be thinking, Okay, well, you talked about this marking thing.

6276
10:37:00.653 --> 10:37:02.834
You talked about localhost and hard hat.

6277
10:37:02.834 --> 10:37:07.092
And how do we test this locally? Like this is how we go to a test net and a main net.

6278
10:37:07.092 --> 10:37:11.965
But what about a local network? And that is exactly what we're going to talk about now.

6279
10:37:11.965 --> 10:37:19.529
So we've modularized, our code and parameterize our code so that we're going to use the address based off of the chain that we're on.

6280
10:37:19.529 --> 10:37:28.610
But what if we use a chain that doesn't even have a price feed address on it? What do we do there? This is where we actually create those mock contracts.

6281
10:37:28.610 --> 10:37:41.088
The idea of mock contracts here is if the contract doesn't exist, we deploy a minimal version of it for our local testing, or our local testing.

6282
10:37:41.088 --> 10:37:45.982
And deploying mocks is technically a deploy script.

6283
10:37:45.982 --> 10:37:59.144
So what we do actually is back in our deploy folder is we're going to create a new file, and we're going to call it 00 Dash deploy mocks dot j s, we started with 00.

6284
10:37:59.144 --> 10:38:17.106
Because this is almost like the pre deploy stuff, we only do this, sometimes we don't always deploy mocks, right, we don't need to deploy mocks to Rinkeby, or polygon or or Aetherium main net, because those already have these price feeds, we're actually going to deploy our own mock price feed contracts.

6285
10:38:17.106 --> 10:38:24.736
And in our deploy Funmi script, we're going to use our own contracts, instead of already established contracts.

6286
10:38:24.736 --> 10:38:30.333
If we're on a network that doesn't have any price, few contracts, like hard hat or locos, for example.

6287
10:38:30.382 --> 10:38:32.769
So let's write our deploy mock script.

6288
10:38:34.382 --> 10:38:36.801
going to look nearly identical to our deploy Funmi.

6289
10:38:37.382 --> 10:38:41.043
if you want to set it up like this, you absolutely can.

6290
10:38:41.382 --> 10:38:46.335
I'm actually just going to copy this, this part, paste it in here, because that initial part is going to be exactly the same.

6291
10:38:47.382 --> 10:38:54.569
Oh, and over here, I just realized that we're calling this network thing without being defined, JavaScript will kind of be smart enough to know where this network thing is coming from.

6292
10:38:54.569 --> 10:38:56.303
But it can be a little bit confusing.

6293
10:38:56.303 --> 10:39:00.244
So it's better to be really explicit, and say, const.

6294
10:39:00.244 --> 10:39:06.230
Network equals require hard hat, this network thing is coming from hard hat.

6295
10:39:06.230 --> 10:39:08.262
And we're going to grab this line.

6296
10:39:08.262 --> 10:39:11.398
And we're also going to use this at the top of our script here.

6297
10:39:11.398 --> 10:39:22.462
And then our top section is going to look exactly the same as well, we're going to grab these three lines, and paste them in deploy deployer chain ID, boom, it's all going to be the same here, because we're setting up to deploy some stuff.

6298
10:39:22.462 --> 10:39:24.811
Now we want to deploy a new contract.

6299
10:39:24.811 --> 10:39:28.335
But if we look at our contracts folder, this is all we have right now.

6300
10:39:28.383 --> 10:39:33.383
So we're going to need to add this mock this fake contract to our contracts folder.

6301
10:39:33.383 --> 10:39:42.317
Now what we can do is in our contracts folder, we want to separate this file from the rest of our file so that we know okay, this isn't part of our project, but it is part of our testing.

6302
10:39:42.317 --> 10:39:44.859
So we're going to right click Create New Folder.

6303
10:39:44.859 --> 10:39:49.856
And we can either call it mocks, or test I like to call mine test.

6304
10:39:49.856 --> 10:39:59.814
And inside of this folder, we can go ahead and right click create a new file, I'm going to create a new file and call it mock, v3 aggregate tore that soul.

6305
10:39:59.814 --> 10:40:06.037
And this is where we're going to define our mock price feed aggregator ourselves.

6306
10:40:06.037 --> 10:40:26.261
So how can we create our own fake price feed contract, so we can test everything locally? Well, one thing we could do is we go to the chain link GitHub repo, and go through the contracts and find one of these price feed addresses, source eight, or maybe we'll go back to source we'll maybe we'll check in V six.

6307
10:40:26.383 --> 10:40:35.334
Looks like we could find some stuff and look around and we probably copy paste all this code, but it really seems like kind of a huge pain in the butt to have to copy all this code.

6308
10:40:35.383 --> 10:40:40.103
Now we absolutely could we copy paste the code in here, but we're gonna do something a little bit more clever.

6309
10:40:40.103 --> 10:40:43.487
So the chainlink repo actually comes with some mocks.

6310
10:40:43.487 --> 10:40:47.002
If we go to contracts, SRC V 0.

6311
10:40:47.002 --> 10:40:55.932
6 tests They actually have a mock v3 aggregator dot soul in here that we can use as our mock.

6312
10:40:55.932 --> 10:41:02.250
So we can copy paste everything, but we'd have to revamp a little bit of it because it's doing some dot dot stuff.

6313
10:41:02.250 --> 10:41:08.980
It's talking to other contracts that are locally in this file structure that are not going to be in our file structure.

6314
10:41:08.980 --> 10:41:19.746
So instead though, what we can do is we can use this node modules package to our advantage, we can just say pragma, solidity, carrot zero, point 6.

6315
10:41:19.746 --> 10:41:22.867
0, we'll use the same version that that package is doing.

6316
10:41:22.867 --> 10:41:30.600
And then just do import at a chain link slash contracts slash SRC slash v 0.

6317
10:41:30.600 --> 10:41:30.716
6.

6318
10:41:30.716 --> 10:41:37.437
Slash tests slash mock, B, three egg, Reg, gay tore that soul.

6319
10:41:37.437 --> 10:41:44.860
And then we'll add, and then of course, we'll add spdx, license identifier, MIT.

6320
10:41:44.860 --> 10:41:47.867
And boom, this is actually all we need.

6321
10:41:47.867 --> 10:42:02.203
If we just import the code like this, remember, this is exactly the same as copy pasting this contract into our project, of course, with this path resolve to where it actually is in our node modules.

6322
10:42:02.203 --> 10:42:08.018
Now, actually, I can run yarn hardhat compile, and it will also compile this contract.

6323
10:42:08.018 --> 10:42:13.384
Except for of course, we have an issue, hey, compiler versions don't match.

6324
10:42:13.384 --> 10:42:24.005
Right? What's What's up with that now, you're going to get into situations where you will be working with contracts that are not the same version of solidity as you why well because contracts keep being deployed all the time.

6325
10:42:24.005 --> 10:42:27.385
And there are a ton of contracts that are in version 0.

6326
10:42:27.385 --> 10:42:28.940
4, solidity, 0.

6327
10:42:28.940 --> 10:42:29.273
5 0.

6328
10:42:29.273 --> 10:42:35.488
678, and probably 910, or 15 billion, or however many solidity versions will come to be.

6329
10:42:35.488 --> 10:42:42.654
So in our config, in our hard hat dot config, when you scroll to the bottom, we can scroll to where we're defining our solidity version.

6330
10:42:42.654 --> 10:42:50.000
And we can actually add multiple solidity versions, so that our compiler can compile multiple versions of solidity.

6331
10:42:50.000 --> 10:42:52.846
To do that, we'll say, so Lyd, did T.

6332
10:42:52.846 --> 10:42:57.150
And we'll turn it into an object here, we'll make sure to put this comma here.

6333
10:42:57.150 --> 10:43:03.352
And inside our solidity object, we'll put compilers and we'll have a list of compilers.

6334
10:43:03.352 --> 10:43:07.035
Our first one we'll say is version, zero, point 8.

6335
10:43:07.035 --> 10:43:07.085
8.

6336
10:43:07.085 --> 10:43:10.255
And we'll say our second one is going to be version 0.

6337
10:43:10.255 --> 10:43:15.190
6, point six, and then we'll go ahead and save that.

6338
10:43:15.385 --> 10:43:17.723
And it looks like mine wanted to format it like this, which is fine.

6339
10:43:17.723 --> 10:43:25.623
Now, we can go ahead, rerun, yarn, Hardhead, compile, and boom, compiled five solidity files successfully.

6340
10:43:25.623 --> 10:43:29.333
This means that our Mark V aggregator should also have been compiled.

6341
10:43:29.385 --> 10:43:37.978
And if we look in artifacts, at chain link, do indeed see this at chain link slash contract slash SRC bid, and a v 0.

6342
10:43:37.978 --> 10:43:38.045
6.

6343
10:43:38.045 --> 10:43:42.237
In tests, we see this mock aggregator dot soul, which has been compiled.

6344
10:43:42.237 --> 10:43:42.761
Awesome.

6345
10:43:42.761 --> 10:43:51.729
So now that we have our mock contract compiled, we now have a contract that we can use to deploy a fake price feed to a blockchain.

6346
10:43:51.729 --> 10:43:57.051
So how do we actually do this? Well, it's going to be the exact same way that we deployed the Funmi contract.

6347
10:43:57.051 --> 10:44:15.652
But we're going to add a little if statement in here, we don't want to deploy this mock contract to a test net or a network that actually has a price feed on it, we could just do something like if chain ID does not equal, you know, some chain ID, then deploy marks, right.

6348
10:44:15.652 --> 10:44:17.736
And then this is kind of pseudocode.

6349
10:44:17.736 --> 10:44:19.174
Obviously, this code won't actually work.

6350
10:44:19.174 --> 10:44:31.756
But instead, what I like is I actually like to specify which chains are going to be my development chains, which chains are going to be the one that I can deploy these mocks to, in my helper, hard hat config, I'll define these chains.

6351
10:44:31.756 --> 10:44:41.233
So I'll say const, development chains, equals, and then I'll just say hard hat, and local host.

6352
10:44:41.233 --> 10:44:43.368
I'll export these.

6353
10:44:43.368 --> 10:44:49.450
And back in my deploy mocks, I'll import these with const.

6354
10:44:49.450 --> 10:44:57.336
Development chains equals require dot dot slash helper Hardhead config.

6355
10:44:57.336 --> 10:45:05.558
And now I'll say if development chains dot includes chain ID.

6356
10:45:05.558 --> 10:45:16.519
This includes keyword basically is a function that checks to see if some variable is inside an array, then we're gonna go ahead and deploy Max, and which is what we want to do.

6357
10:45:16.519 --> 10:45:21.052
So we'll do log, which we're getting from deployments, which is basically console dot log.

6358
10:45:21.052 --> 10:45:28.198
And we'll say local network detected, deploying mocks.

6359
10:45:28.386 --> 10:45:38.812
And we'll do a weight ploy, and we'll deploy our new mock v3 aggregator mock v3 aggregator will do a comma.

6360
10:45:38.812 --> 10:45:40.955
There a little colons here.

6361
10:45:40.955 --> 10:45:53.290
If we want to get really specific, we can say contract v3 aggregator which we're kind of already saying we'll say from deployer We'll say logging is going to be true.

6362
10:45:53.387 --> 10:46:04.111
And then we need to pass some arguments, we need to pass the constructor parameters for the mock v3 aggregator, which are what? Well, let's go to docs chain to link to find out.

6363
10:46:04.111 --> 10:46:13.340
Or you can also just go to Node modules chainlink, SRC V 06, tests, and then all the way down to mock V three, aggregated out.

6364
10:46:13.387 --> 10:46:24.587
So where you could also find the constructor in here, whatever one you like better, sometimes I find it easier just to read GitHub Ctrl plus F or Command plus F for constructor.

6365
10:46:24.587 --> 10:46:28.264
We see it takes a decimals and an initial answer.

6366
10:46:28.264 --> 10:46:40.323
And if we read through the code, we'll learn that the decimals object is going to be equivalent to the decimals parameter is going to be equivalent to this decimals function and the initial answer.

6367
10:46:40.387 --> 10:46:50.269
And the initial answer is basically just going to be what is the price feed starting at, we actually get to pick the price of the price feed, which works out really well, because that works out great for testing.

6368
10:46:50.269 --> 10:46:56.762
I usually like to define the decimals and the initial answers somewhere outside of this function so that I can access it later.

6369
10:46:56.762 --> 10:47:00.967
One good place you can add it is once again in our helper Hardhead config.

6370
10:47:00.967 --> 10:47:01.160
js.

6371
10:47:01.160 --> 10:47:05.224
So I might do const decimals equals eight.

6372
10:47:05.224 --> 10:47:09.490
And then const initial answer.

6373
10:47:09.490 --> 10:47:14.610
Answer equals, and we'll do 2000.

6374
10:47:14.610 --> 10:47:23.845
So since we have a decimals, we'll do 2000 And then 123456788 decimal places, and then we'll export these as well.

6375
10:47:23.845 --> 10:47:26.683
Export decimals, and export initial answer.

6376
10:47:26.683 --> 10:47:34.388
We could of course, just do you know, const decimals equals eight at the top and then initial answer and then use them down here.

6377
10:47:34.388 --> 10:47:35.998
But I like to do it like that.

6378
10:47:35.998 --> 10:47:36.608
So Conce.

6379
10:47:36.608 --> 10:47:39.184
So now we have to import them in here.

6380
10:47:39.388 --> 10:47:40.911
const development chains.

6381
10:47:40.911 --> 10:47:42.625
It's also grabbed decimals.

6382
10:47:43.388 --> 10:47:45.814
grabbed initial answer, we'll save it.

6383
10:47:47.388 --> 10:47:50.165
at the constructor looks like it's decimals first, initial answers second.

6384
10:47:50.165 --> 10:47:55.638
So in our arguments, we'll do decimals first, initial answers second, and tada.

6385
10:47:55.638 --> 10:48:00.574
And then we will be all done that we'll do a quick log box deployed.

6386
10:48:00.574 --> 10:48:09.084
And then I also like to do kind of like a big line at the end of all of my deploy scripts just to be like, hey, that's the end of this deploy script.

6387
10:48:09.084 --> 10:48:12.557
Anything else after this is going to be a different deploy script.

6388
10:48:12.557 --> 10:48:13.421
All right, great.

6389
10:48:13.421 --> 10:48:15.888
Now our deployed mocks script is actually done.

6390
10:48:15.888 --> 10:48:18.472
But our deploy Funmi script isn't quite done.

6391
10:48:18.472 --> 10:48:24.077
Is there a way that we could run only our deploy mock script? Well, yes, there is.

6392
10:48:24.077 --> 10:48:25.581
Great, thanks for asking.

6393
10:48:25.581 --> 10:48:37.441
What we can do at the bottom of our deploy mock script is we can add a module that exports dot tags, equals, and we'll say all and marks.

6394
10:48:37.441 --> 10:48:46.286
Now what we can do is if we run yarn, hard hat deploy, we can add this flag dash dash tags.

6395
10:48:46.388 --> 10:48:50.325
And it will only run the deploy scripts that have a special tag.

6396
10:48:50.388 --> 10:48:56.629
So we'll run our mocks tag, which means it'll only run our deploy mock script.

6397
10:48:56.629 --> 10:49:03.323
And, and oops, actually, in our helper config development chains is actually hard hat and localhost.

6398
10:49:03.389 --> 10:49:15.158
And I said, we're going to try to do with the chain ID, sorry, we're going to do this, we're gonna do development chains dot includes network dot name.

6399
10:49:15.389 --> 10:49:24.948
Because our helper config is using names and not chain IDs, so if development chains that includes that network the names, then we're gonna go ahead and deploy the mocks.

6400
10:49:24.948 --> 10:49:28.711
So let's go ahead and run this yarn here and hit Deploy dash dash tags, mocks.

6401
10:49:28.711 --> 10:49:32.660
And perfect we do indeed see our mocks getting deployed here.

6402
10:49:32.660 --> 10:49:36.839
This log true means that it's going to spit out stuff like this.

6403
10:49:36.839 --> 10:49:48.389
It'll say contract, it's deploying, it'll say the transaction it's doing and it'll say where it was deployed with how much gas and awesome This means our deployed Mach script is working perfectly.

6404
10:49:48.389 --> 10:49:51.503
So now we have our deploy mocks script working perfectly.

6405
10:49:51.503 --> 10:49:57.339
So how do we apply that back to our deploy Funmi script? Well, we're gonna do the exact same thing here.

6406
10:49:57.389 --> 10:50:05.889
Instead of making eth USD price feed address constant variable, we're gonna say let at USD price you'd variable so that we can actually update it.

6407
10:50:05.889 --> 10:50:21.353
And we'll say, if development chains dot includes network dot name, what we can do with hard hat deploy is we can just get the most recent deployment using a command called literally get.

6408
10:50:21.353 --> 10:50:22.686
So we'll say const.

6409
10:50:22.686 --> 10:50:29.068
eth USD aggregator equals await deployments dot get.

6410
10:50:29.068 --> 10:50:41.441
And then the name of the contract that we deployed Mach v3 aggregator, and if you wanted to just do get instead of deployments dot get, we absolutely could, just by doing it like this.

6411
10:50:41.441 --> 10:50:43.176
Those are exactly the same.

6412
10:50:43.176 --> 10:50:54.491
So we'll get the address like this and then we'll say eth USD price feed address equals that eth USD aggregator contract dot address.

6413
10:50:54.491 --> 10:51:02.675
And then if we're not on a development chain, if we didn't deploy a mock, we're just going to do exactly what we did before.

6414
10:51:02.675 --> 10:51:04.873
With using the network config.

6415
10:51:04.873 --> 10:51:06.163
Oh, my goodness.

6416
10:51:06.163 --> 10:51:15.159
Now, now that we've done all of these steps, let's add a little log thing at the bottom here with just a bunch of hyphens.

6417
10:51:15.159 --> 10:51:28.523
Now, we should have a very robust script to flip between a local development chain, a test net chain, a main net chain, and allow us to deploy literally everywhere without changing any of our solidity.

6418
10:51:28.523 --> 10:51:35.323
And then we just take this, this eth USD price feed address and stick it into logs here.

6419
10:51:35.323 --> 10:51:45.439
And then at the bottom, we can do module dot exports, dot tags equals and then we'll just do all and then we'll call this one Funmi.

6420
10:51:45.439 --> 10:51:47.406
Oh, now moment of truth.

6421
10:51:47.406 --> 10:51:52.898
If we did all this, right, we should just be able to run yarn, hard hat deploy.

6422
10:51:52.898 --> 10:51:57.644
And it should work on our local chain, our hard hat chain.

6423
10:51:57.644 --> 10:52:00.881
And then it should also work on any test net that we give it.

6424
10:52:00.881 --> 10:52:02.635
So let's give this a try.

6425
10:52:02.635 --> 10:52:04.178
Yarn, Hardhead deploy.

6426
10:52:04.390 --> 10:52:05.622
Let's see if this works.

6427
10:52:05.622 --> 10:52:06.050
Awesome.

6428
10:52:07.390 --> 10:52:15.325
deploy locally to our Hard Hat Network, we can see that we went ahead and we deployed mocks, we did our little underline here.

6429
10:52:15.390 --> 10:52:18.999
And then we deployed Funmi deployed at this address with this much gas.

6430
10:52:18.999 --> 10:52:32.669
Now, what are the other awesome things about hard hat deploy? When we run our local blockchain, our own blockchain node, hard hat deploy will automatically run through all of our deploy scripts and add them to our node.

6431
10:52:32.669 --> 10:52:43.046
So now if I run yarn, hard hat node, we're going to spin up a new blockchain node, but it's already going to have all of our deployed contracts on it.

6432
10:52:43.046 --> 10:52:51.100
So every time we spin up a local node, now it's going to come automatically packed with the contracts that we want on it.

6433
10:52:51.100 --> 10:52:55.817
So we are going to show us doing this on a test net on Rinkeby.

6434
10:52:55.817 --> 10:53:03.950
But before we actually test it on Rinkeby, I'm going to add a little bit of the auto verification piece in here as well, because we did that in the last lesson.

6435
10:53:03.950 --> 10:53:07.079
And we wanted to show how to do it in hard hat deploy as well.

6436
10:53:07.079 --> 10:53:21.132
So right after we deploy our Funmi, we can do something similar here, we'll say, if developer chains includes network dot name, we'll say if developer chains doesn't include network dot name, because we don't want to verify on a local network.

6437
10:53:21.132 --> 10:53:31.505
So we'll say if not development chains dot includes network dot name, the exclamation mark, aka the bang means not when we're talking about booleans.

6438
10:53:31.505 --> 10:53:39.644
So we're saying, if the name of the network isn't a development chain, we want to go ahead and verify and same as last time.

6439
10:53:39.644 --> 10:53:48.907
And if process dot e NV dot ether scan API key, then we're going to go ahead and verify.

6440
10:53:48.907 --> 10:53:54.754
Now before we had our verify code, right in our deploy code, we're gonna do something a little bit different here.

6441
10:53:54.754 --> 10:54:03.572
Instead of having our verify code in our deploy scripts here, we're actually going to create a new folder called utils, which stands for utilities.

6442
10:54:03.572 --> 10:54:08.646
And this is where we're going to add different scripts that we can use across different deployments.

6443
10:54:08.646 --> 10:54:23.582
Because let's say we have 50 Deploy scripts, we're not going to make 50 Deploy functions, we're just going to add them to our utils folder, and in our utils folder, or create a new file called verify dot j s, we're going to add that code from our last project in here.

6444
10:54:23.582 --> 10:54:31.002
So if you want, you can go ahead copy paste from our last project over to this one, or you can pause the video to type it out yourself.

6445
10:54:31.002 --> 10:54:36.900
Since we're using the run command here, we're gonna do const run equals require RT hat.

6446
10:54:36.900 --> 10:54:44.642
And then at the bottom, we're going to do module exports.

6447
10:54:44.642 --> 10:54:48.079
Exports equals verify.

6448
10:54:48.392 --> 10:54:56.860
Now that we have a verify script in our utils folder, back in our deploy Funmi we're going to say const.

6449
10:54:56.860 --> 10:55:00.642
Verify equals require dot dot slash utils.

6450
10:55:00.642 --> 10:55:01.725
Slash verify.

6451
10:55:01.725 --> 10:55:10.206
And since now in our verified Jas, we have a lot of this trycatch stuff in here, we can just do a wait.

6452
10:55:10.206 --> 10:55:17.497
Verify and a verify once again takes a contract address and a list of arguments.

6453
10:55:17.497 --> 10:55:24.004
We'll say await verify, fund me dot address and then the list of arguments.

6454
10:55:24.004 --> 10:55:26.737
To make the list of arguments easier to put in.

6455
10:55:26.737 --> 10:55:42.806
You can go const args, equals and then we'll just stick our eth USD price feed in here and then replace this with args and then take this args and pop it on down into the second parameter here.

6456
10:55:42.806 --> 10:55:44.564
All right, great.

6457
10:55:44.564 --> 10:55:54.496
Now let's go ahead and deploy this to With the Rinkeby test net, and what do we need to deploy this to the Rinkeby test net? Well, let's jump into our hard hat config first.

6458
10:55:54.496 --> 10:56:01.554
And let's clean this up, we don't really need this accounts task, so I'm just going to delete it, I don't really need this comment.

6459
10:56:01.554 --> 10:56:03.102
So I'm going to delete this too.

6460
10:56:03.102 --> 10:56:07.345
And let's jump into the network section, we're not going to be working with ropsten.

6461
10:56:07.345 --> 10:56:09.154
So we're gonna go ahead and dump that.

6462
10:56:09.154 --> 10:56:15.651
We are however, going to be working with rink B, the URL is going to be that same Rinkeby RPC URL.

6463
10:56:15.651 --> 10:56:19.500
So we're going to define that up here, like we did before.

6464
10:56:19.500 --> 10:56:37.309
And if you want to copy paste from your last project, feel free to do so you can also follow along with me or fastforward me the counts is going to be the same.

6465
10:56:37.309 --> 10:56:42.293
I'm going to go ahead and just copy paste the gas reporter with what we had from before.

6466
10:56:42.293 --> 10:56:50.151
So we're going to add this constant corn market cap API key equals process dot EMV dot corn market cap API key.

6467
10:56:50.151 --> 10:56:56.952
Do the same thing with the ether scan API key Licious add everything in here.

6468
10:56:56.952 --> 10:56:57.426
Now.

6469
10:56:57.426 --> 10:57:07.342
We have our ether scan section in here already, we're gonna have our gas reporter be false, because I don't really feel like using it right now.

6470
10:57:07.393 --> 10:57:10.343
And then finally, we're going to add one more thing in here.

6471
10:57:10.393 --> 10:57:15.308
Remember how in our last project, before we actually verified we waited some block confirmations.

6472
10:57:15.308 --> 10:57:18.020
That way ether scan could make sure to catch up.

6473
10:57:18.020 --> 10:57:32.073
Well, we can do the exact same thing in here in our hard hat dot config, we can add a section for each test net for how many blocks we want to wait, I'm going to add block confirmations of six.

6474
10:57:32.073 --> 10:57:34.827
Now back on our deploy Funmi.

6475
10:57:34.827 --> 10:57:43.875
In a new section, I can add wait confirmations of network dot config.

6476
10:57:43.875 --> 10:57:57.329
That block on for motions, or one is or one means if no block confirmations is given in our Hardhead dot config will just wait for one block.

6477
10:57:57.394 --> 10:58:04.092
And again, the reason we want to wait for approximately six block confirmations is we want to give ether scan a chance to index our transaction.

6478
10:58:04.092 --> 10:58:07.853
And I added a chain ID 42 when it should be for my mistake.

6479
10:58:07.853 --> 10:58:18.590
And of course, we're going to need our dot env file, where we add all of our stuff from the last session, the RIP ERP CRL private key ether scan API and then coin market cap API.

6480
10:58:18.590 --> 10:58:20.294
All right moment of truth.

6481
10:58:20.294 --> 10:58:21.539
Let's try this out.

6482
10:58:21.539 --> 10:58:28.672
If we run yarn Hardhead deploy dash dash network Rinkeby.

6483
10:58:28.672 --> 10:58:35.213
It should not deploy any marks because we have this if statement in our mock deployment.

6484
10:58:35.213 --> 10:58:41.071
But it should deploy our Funmi contract using the correct price feed address.

6485
10:58:41.071 --> 10:58:43.519
And then it'll go ahead and verify it.

6486
10:58:43.519 --> 10:58:52.139
Since we're waiting for six block confirmations, we can even be super secure by adding dash dash tags and just running the funding tag.

6487
10:58:52.139 --> 10:58:56.306
But we're just going to do yarn hearted deploy network Rigby.

6488
10:58:56.306 --> 10:58:58.201
And let's see what happens.

6489
10:58:58.201 --> 10:59:00.855
All right, and we're deploying funding.

6490
10:59:00.855 --> 10:59:09.895
And we can see the transaction that we have for fun me, this is that logging feature, we have log is true for deploying Funmi.

6491
10:59:09.895 --> 10:59:17.093
So it gives us the transaction once it has a transaction, and it will give us the address once we have the address.

6492
10:59:17.093 --> 10:59:22.463
So we're going to wait six block confirmations for this transaction to finish going through.

6493
10:59:22.463 --> 10:59:26.795
Now we see we've deployed this contract address with X amount of gas.

6494
10:59:26.795 --> 10:59:29.233
And now we're running the verification process.

6495
10:59:29.233 --> 10:59:39.775
While the verification process is running, we can pull up Rinkeby ether scan, paste our address in here and see that we have indeed created this contract.

6496
10:59:39.775 --> 10:59:43.791
And now it looks like we've successfully verified the contract on ether scan.

6497
10:59:43.791 --> 10:59:48.767
So if we hit refresh, we can indeed see that the contract has been verified.

6498
10:59:48.767 --> 10:59:49.309
Awesome.

6499
10:59:49.309 --> 10:59:49.986
All right.

6500
10:59:49.986 --> 10:59:51.245
So this is fantastic.

6501
10:59:51.245 --> 11:00:05.655
Our deploy script is looking great, we're able to deploy to a local chain, we're able to deploy to a test that and if we wanted to, we could deploy to any network that we wanted simply by updating our hard hat config, and then updating our helper config.

6502
11:00:05.655 --> 11:00:07.220
This is fantastic.

6503
11:00:07.395 --> 11:00:09.153
Great work so far.

6504
11:00:13.395 --> 11:00:13.868
our tests.

6505
11:00:16.395 --> 11:00:20.179
our Funmi contract a little bit to make it look a little bit more professional.

6506
11:00:20.179 --> 11:00:24.854
And I'm going to talk about some of the syntax and some of the reasons why some conventions exist.

6507
11:00:24.854 --> 11:00:29.331
We're not going to do this full force on all the projects moving forward.

6508
11:00:29.395 --> 11:00:34.569
But they are good to know and they are good to keep in mind when moving forward and working with our contracts.

6509
11:00:34.569 --> 11:00:41.084
While we go through this we're going to learn why some of these conventions exist including learning a little bit of low level solidity.

6510
11:00:41.084 --> 11:00:42.264
So don't skip this part.

6511
11:00:42.264 --> 11:00:43.789
When we get to later sections.

6512
11:00:43.789 --> 11:00:50.508
We're going to be a little bit looser and not be as strict with the code style guides but That's basically what we're gonna go over now.

6513
11:00:50.508 --> 11:00:57.953
And for now, you might see this event funded thing here, please just ignore that for now, in an earlier take, I'd introduced the events much earlier.

6514
11:00:57.953 --> 11:01:01.248
And now we're actually going to learn about events a little bit later in the course.

6515
11:01:01.248 --> 11:01:04.067
So please ignore that event funded for now.

6516
11:01:04.067 --> 11:01:06.525
So let's go ahead and tweak a little bit of our contracts here.

6517
11:01:06.525 --> 11:01:17.879
Now what I'm talking about tweaking this to make it look professional, a little bit more professional, I'm talking about the solidity style guide, there are some conventions for naming and ordering that we can follow to make our code look a little bit better.

6518
11:01:17.879 --> 11:01:23.002
Now, like I said, this is going to be a little bit more optional, because it can be a little bit verbose.

6519
11:01:23.002 --> 11:01:25.753
And it doesn't really make that big of a difference.

6520
11:01:25.753 --> 11:01:30.750
But it can increase readability of your contracts by a lot and make your code look a lot nicer.

6521
11:01:30.750 --> 11:01:38.157
So if you want, you can go through this style guide to learn more about what kind of makes solidity look nice, and what makes it not look nice.

6522
11:01:38.157 --> 11:01:42.819
But well, that's some of these style guides in here, we're not going to follow the style guide exactly to a tee.

6523
11:01:42.819 --> 11:01:52.707
But we are going to make some best efforts to make our code follow the style guide, we've got a link to the style guide in the GitHub repository for this section, we can read some more about the layout.

6524
11:01:52.707 --> 11:02:01.348
But the main thing we want to look at is this order of the layout, we want to start with our imports with our pragma statement, our imports, interfaces, libraries, and then contracts.

6525
11:02:01.348 --> 11:02:06.576
And then inside each contract type declarations, state variables, events, modifiers, and functions.

6526
11:02:06.576 --> 11:02:11.706
So let's go back here and make sure that we're up to speed, we want our pragma first.

6527
11:02:11.706 --> 11:02:15.936
Alright, awesome, we did exactly that, then we want our imports.

6528
11:02:15.936 --> 11:02:17.814
Okay, awesome, we have those too.

6529
11:02:17.814 --> 11:02:22.735
Something that's not in the style guide is going to be error codes, which we definitely want next.

6530
11:02:22.735 --> 11:02:25.701
So next is going to be error codes.

6531
11:02:25.701 --> 11:02:30.052
Now this is where we're going to bump into one of our first updates here.

6532
11:02:30.052 --> 11:02:37.350
As of recent, it's sort of becoming a best practice to add the name of your contract, some underscores, and then the name of your error.

6533
11:02:38.397 --> 11:02:39.672
Whenever you're running into an error.

6534
11:02:40.397 --> 11:02:44.328
easier to understand which contract is throwing the error.

6535
11:02:44.397 --> 11:02:53.708
So for this, we're going to say error Funmi, two underscores not owner, then we're going to scroll down to the our revert and set it like this.

6536
11:02:53.708 --> 11:03:03.724
This way, when if we ever run into this error, we know that the error is coming from the Funmi contract, not from the aggregator v3 interface, or the price converter or some other contract.

6537
11:03:03.724 --> 11:03:06.397
So that's how we want to write our error codes here.

6538
11:03:06.397 --> 11:03:10.227
If we had any interfaces or libraries not imported, we would add them here.

6539
11:03:10.227 --> 11:03:12.708
But then finally, we add our contracts.

6540
11:03:12.708 --> 11:03:15.593
In this file, we only have one contract here.

6541
11:03:15.593 --> 11:03:16.773
It's our Funmi contract.

6542
11:03:16.773 --> 11:03:17.166
Awesome.

6543
11:03:17.166 --> 11:03:22.563
Now the next thing we want to learn about as far as style guides go is this thing called natspec.

6544
11:03:22.563 --> 11:03:27.708
natspec stands for Etherium natural language specification format.

6545
11:03:27.708 --> 11:03:41.052
And it's basically a way of documenting our code inspired by Doxygen uses Doxygen style comments and tags to help document our code, you can click the link here in the solidity documentation to learn more about Doxygen.

6546
11:03:41.052 --> 11:03:45.167
If we scroll down in the documentation, here, we can see an example of using natspec.

6547
11:03:45.167 --> 11:03:51.968
Whenever we have a contract or a function that needs documentation, we can add some syntax that looks like this to it.

6548
11:03:51.968 --> 11:04:07.053
So for example, if we wanted to add this to our code, we could add a comment explaining this funding contract to start a piece of natspec, you can do three backslashes, or one backslash, two stars, and then another ending star here.

6549
11:04:07.053 --> 11:04:11.955
Everything we put inside of this comment section basically gets turned into a comment.

6550
11:04:11.955 --> 11:04:25.064
For the start of our contract, we'll do the Add sign title to explain basically, what this contract is, it's fun, we contract is going to be a contract for crowdfunding, we'll add another star.

6551
11:04:25.064 --> 11:04:42.898
And we can add the author of it, which is going to be your name, I'm going to put Patrick Collins, of course, then we'll add a notice, which is just kind of a note to people we can say this contract is is to demo a sample funding contract.

6552
11:04:42.898 --> 11:04:49.064
And we can also add apt Dev, which is a note specifically to developers.

6553
11:04:49.064 --> 11:04:52.785
And we can say this implements price feeds as our library.

6554
11:04:52.785 --> 11:05:11.017
The reason that we want to add these tags here is actually because we can use the natspec to automatically create documentation for us if we download so we can actually run solc dash s user doc dash dash dev doc, and the name of our file to automatically generate documentation.

6555
11:05:11.017 --> 11:05:17.512
So this is also really helpful for automatically creating documentation for other developers who interact with the protocol later on.

6556
11:05:17.512 --> 11:05:21.725
You can use this natspec For as many or as few functions as you'd like.

6557
11:05:21.725 --> 11:05:24.698
Most of us probably aren't going to be making documentation.

6558
11:05:24.698 --> 11:05:31.914
So we really just want to follow those guidelines if we think some function or some section of our code is a little bit tricky for other developers.

6559
11:05:31.914 --> 11:05:35.347
Now that we're inside of contract, we can follow the order of our contract.

6560
11:05:35.347 --> 11:05:47.212
We're first going to start with type declarations which we don't really have any except for the fact that we're using our price converter for the UN 256 type.

6561
11:05:47.212 --> 11:05:48.228
Okay, great.

6562
11:05:48.399 --> 11:05:52.136
You Next, after our type declarations, we're going to do state variables.

6563
11:05:52.136 --> 11:05:58.217
And in this state variables section, this is where we're actually going to change the name of some of our state variables.

6564
11:05:58.217 --> 11:06:00.989
So we'll do a little common here state variables.

6565
11:06:00.989 --> 11:06:09.711
Now in the solidity style guide, kind of adhere to the naming styles, we use upper and lowercase, we use total caps with underscores here.

6566
11:06:09.711 --> 11:06:13.617
However, these naming variables are going to change in the future in this section.

6567
11:06:13.617 --> 11:06:19.722
And if you're following along with the GitHub repo associated with this course, these are going to be actually a little bit different than what you see.

6568
11:06:19.722 --> 11:06:25.449
However, for now, we're going to leave them as they are, because the reason why we're going to change them isn't going to be quite clear yet.

6569
11:06:25.449 --> 11:06:26.049
Don't worry.

6570
11:06:26.049 --> 11:06:29.229
So these names are going to change soon, but not yet.

6571
11:06:29.229 --> 11:06:32.664
Alright, after state variables comes events, and modifiers.

6572
11:06:32.664 --> 11:06:35.589
We don't have any events, but we do have a modifier.

6573
11:06:35.589 --> 11:06:37.096
So we'll copy this.

6574
11:06:37.096 --> 11:06:41.349
And actually, we'll delete this comment here.

6575
11:06:41.349 --> 11:06:45.250
And we'll paste our modifier here.

6576
11:06:45.250 --> 11:06:50.127
Oh, and it looks like looks like we're not auto formatting here.

6577
11:06:50.127 --> 11:06:53.870
So we're going to uncomment immutable actually, so that it automatically auto formats.

6578
11:06:53.870 --> 11:06:54.549
Okay, great.

6579
11:06:54.549 --> 11:06:55.927
We're out of formatting now.

6580
11:06:55.927 --> 11:06:56.266
And Cool.

6581
11:06:56.266 --> 11:06:57.999
Alright, so now we have our modifiers.

6582
11:06:57.999 --> 11:07:02.418
Next, we have right here, and then we have all of our functions.

6583
11:07:02.418 --> 11:07:02.888
Great.

6584
11:07:02.888 --> 11:07:07.624
We actually want to group our functions in this order that I just print here.

6585
11:07:07.624 --> 11:07:12.721
So we want the constructor which we have received and fall back, we do have fall back and receive.

6586
11:07:12.721 --> 11:07:17.161
So we're going to actually copy those and delete this comment.

6587
11:07:17.161 --> 11:07:23.111
We're gonna stick those veterans Heath here looks like receive goes first.

6588
11:07:23.111 --> 11:07:24.722
So we'll put that here.

6589
11:07:24.722 --> 11:07:29.238
Then external functions, then public, internal, private.

6590
11:07:29.400 --> 11:07:30.685
So we have public public.

6591
11:07:30.685 --> 11:07:31.435
And that's it.

6592
11:07:32.400 --> 11:07:34.193
delete this part down here.

6593
11:07:34.193 --> 11:07:34.537
Okay.

6594
11:07:34.537 --> 11:07:34.881
Cool.

6595
11:07:36.400 --> 11:07:40.336
can do that syntax up here from the net spec for our functions.

6596
11:07:40.400 --> 11:07:53.976
For example, for fund it, we could even just copy paste, we would remove title, we would remove author, and we just say add, notice, this function, funds this contract.

6597
11:07:53.976 --> 11:07:57.867
And we can even leave a little dev thing here to talk about it.

6598
11:07:57.867 --> 11:08:00.866
Now if we have parameters, you can do apt puram.

6599
11:08:00.866 --> 11:08:03.305
And say like what the parameter is.

6600
11:08:03.305 --> 11:08:11.096
And then if we have returns, we can say returns, or returns and then what it returns for the documentation.

6601
11:08:11.096 --> 11:08:15.835
Since this doesn't have any parameters in here, and doesn't return anything, we can just leave it like this.

6602
11:08:15.835 --> 11:08:20.368
And great, we've just revamped our contract here to make it a little bit more nicely formatted.

6603
11:08:20.368 --> 11:08:20.836
Great job.

6604
11:08:20.836 --> 11:08:26.945
Now, like I said, we actually are going to change the names of our state variables, and we're going to add some functions in here and a little bit.

6605
11:08:26.945 --> 11:08:32.061
So if we're following with the GitHub repo, the state of the contract right now is going to look a little bit different.

6606
11:08:32.061 --> 11:08:37.127
But it'll make sense why change this up in a little bit.

6607
11:08:37.400 --> 11:08:41.700
Alright, so now that we've cleaned this up, we've got to deploy marks, deploy Funmi.

6608
11:08:41.700 --> 11:08:43.917
Let's go ahead and start writing some tests.

6609
11:08:43.917 --> 11:08:56.334
And after we write these tests, we're actually going to run that gas estimator and using that gas estimator, we're gonna go back, and we're going to update this contract one more time to make this even cheaper to use and work with.

6610
11:08:56.400 --> 11:09:13.043
And remember, that's going to be one of the advantages of writing these tests is how we can optimize our contracts to be even faster, more gas efficient, etc, we want to make sure that we write really good tests, and this is going to be one of our first jumps into these more professional test setups.

6611
11:09:13.043 --> 11:09:16.226
So we're going to jump into our test folder, we're going to delete this sample test.

6612
11:09:16.226 --> 11:09:16.384
js.

6613
11:09:16.384 --> 11:09:21.336
In our last section, we went over a really minimalistic test, which is great.

6614
11:09:21.336 --> 11:09:31.190
However, when we get bigger and bigger projects, we're going to want to start testing more and more different things, we're going to get more and more into at least two different types of testing.

6615
11:09:31.190 --> 11:09:34.949
So if we cd into our test folder, we're going to make one directory called staging.

6616
11:09:34.949 --> 11:09:38.778
And then we're going to make another directory called unit.

6617
11:09:38.778 --> 11:09:44.137
And now if we look in our test folder, we now have a staging folder, and a unit test folder.

6618
11:09:44.137 --> 11:09:47.146
Now we're going to talk about two different types of tests.

6619
11:09:47.146 --> 11:09:49.363
The first one is going to be something called a unit test.

6620
11:09:49.401 --> 11:09:56.350
Now what is a unit test? Unit testing is a software testing method by which individual units of source code are tested.

6621
11:09:56.401 --> 11:10:03.972
Basically, what we want to do is in our contracts, we want to test minimal portions of our code to make sure that they work correctly.

6622
11:10:03.972 --> 11:10:10.463
Then once our small pieces of the test work, we want to do a staging test or maybe an integration test.

6623
11:10:10.463 --> 11:10:15.083
This might be where we run our code on a test net or some actual network.

6624
11:10:15.083 --> 11:10:19.615
You can think of a staging test, it's kind of the last stop before you deploy to a main net.

6625
11:10:19.615 --> 11:10:24.341
They're not always 100% necessary, but they can be really, really helpful.

6626
11:10:24.401 --> 11:10:36.934
Remember, we do want to be conscientious of how much we use our test nets, but we absolutely would 100% want to make sure that everything works locally and that we unit test and we run all of our code locally.

6627
11:10:36.934 --> 11:10:45.205
Then we can use staging tests on an actual test net to make sure that our code will work with actual other contracts.

6628
11:10:45.205 --> 11:11:01.090
Now unit tests can be done with local Hard Hat Network or a forked Hard Hat Network, we'll talk about this for tar Hat Network very soon, right, now, let's build these unit tests, these unit tests are going to be basically what we saw in our last section.

6629
11:11:01.090 --> 11:11:04.057
So let's go in and let's jump in and write some of these unit tests.

6630
11:11:04.057 --> 11:11:09.910
So let's create a new test, we'll call it on me dot test dot j, s.

6631
11:11:09.910 --> 11:11:12.402
And we'll start making our tests in here.

6632
11:11:12.402 --> 11:11:23.635
Now, we did test previously in our last section, but our tests here are going to look a little bit differently, we're actually going to use hardhat deploy, to automatically set up our tests as if both of these deployed functions had been run.

6633
11:11:23.635 --> 11:11:25.140
So let's go ahead and get this started.

6634
11:11:25.140 --> 11:11:31.336
So we're still going to do that same setup that we're gonna do describe, we're gonna say fund me.

6635
11:11:31.336 --> 11:11:39.111
And this is going to have that async function like so.

6636
11:11:39.111 --> 11:11:48.386
And in here, we're going to have a before each, and we're going to have some hits and some describes and everything.

6637
11:11:48.386 --> 11:11:56.918
Now since we want to unit test this, we're gonna go a little bit heavier on the test here, and then with our last project, but in the future, we'll go a little bit lighter with some of the tests.

6638
11:11:56.918 --> 11:11:58.350
So let's get started.

6639
11:11:58.350 --> 11:12:04.565
If we run yarn Hardhead test right now, we're gonna get zero passing.

6640
11:12:04.565 --> 11:12:13.272
Now, if we run yarn hardhat coverage, we're gonna get something that looks like this, saying, Hey, you're missing a lot of stuff.

6641
11:12:13.272 --> 11:12:16.402
So let's try to cover some more lines with our tests.

6642
11:12:16.402 --> 11:12:21.787
And one way we can do that is actually we can group our tests based off of different functions.

6643
11:12:21.787 --> 11:12:25.936
So let's have our first set of tests be around our constructor.

6644
11:12:25.936 --> 11:12:37.130
To do that inside of our first describe, we can add another describe, have this describe the just the constructor, this larger scope will be for the entire Funmi contract.

6645
11:12:37.130 --> 11:12:41.149
And everything inside this one will just be for the constructor.

6646
11:12:41.149 --> 11:12:43.859
So this will also be an async function.

6647
11:12:43.859 --> 11:12:46.753
And these tasks will be just for the constructor.

6648
11:12:46.753 --> 11:12:51.199
But before we even work on this describe, we probably want to deploy our Funmi contract.

6649
11:12:51.199 --> 11:12:52.703
So let's learn how to do that.

6650
11:12:52.703 --> 11:12:56.822
So we'll do a before each, which will be an async function.

6651
11:12:56.822 --> 11:13:03.353
And we're going to deploy our Funmi contract using hard hat deploy.

6652
11:13:03.353 --> 11:13:09.943
Since we use hard hat deploy, our Funmi contract will come even with our mocks and everything.

6653
11:13:09.943 --> 11:13:13.816
So above the before each, let's do let me HDMI.

6654
11:13:13.816 --> 11:13:24.979
And then here, we're going to deploy Funmi, where we're going to deploy our Funmi contract is first by pulling in our deployments object from Harnett deploy.

6655
11:13:24.979 --> 11:13:29.903
So we'll do const deployments equals require hardhat.

6656
11:13:29.903 --> 11:13:41.009
And this deployments object has, has a function called fixture with fixture does is it allows us to basically run our entire deploy folder with as many tags as we want.

6657
11:13:41.009 --> 11:13:45.435
You'll notice I added this alt tag in both of our scripts.

6658
11:13:45.435 --> 11:13:50.822
This means that in this deployment stuff fixtures, it's gonna be a wait deployment of fixtures.

6659
11:13:50.822 --> 11:14:05.371
If I run away deployments dot fixture, I'll run through our deploy scripts on our local network and deploy all of the contracts that we can use them in our scripts and in our testing, and we can deploy everything in that deploy folder with just this one line.

6660
11:14:05.371 --> 11:14:06.616
isn't that helpful.

6661
11:14:06.616 --> 11:14:17.692
Now, once all of our contracts have been deployed, we can start getting them will say fund me equals await ethers, and we'll pull an ether some hard hat as well.

6662
11:14:17.692 --> 11:14:21.797
dot and this is where hard hat deploy is helpful.

6663
11:14:21.797 --> 11:14:33.081
Again, hard to deploy rapt ether is with a function called Get contract, this get contract function is going to get the most recent deployment of whatever contract we tell it.

6664
11:14:33.081 --> 11:14:35.725
So we'll say get contract of fun to me.

6665
11:14:35.725 --> 11:14:41.469
So this will give us the most recent Lee deployed Funmi contract in just this one line.

6666
11:14:41.469 --> 11:14:45.239
And now Funmi will be equal to this line here.

6667
11:14:45.404 --> 11:14:48.216
Now we're going to make a bunch of transactions on our Funmi.

6668
11:14:48.404 --> 11:14:48.870
test it.

6669
11:14:52.404 --> 11:14:54.453
want connected to fund me.

6670
11:14:57.404 --> 11:15:04.070
goes away get named accounts, exactly like we did in our deploy scripts.

6671
11:15:04.070 --> 11:15:14.331
And then we just need to import it from our tap in our deploy scripts we imported get named accounts inside of our input parameters for our deploy function.

6672
11:15:14.404 --> 11:15:24.748
Remember getting named accounts and deployments was abstracted from if we look up here, from the hard hat runtime environment, and like I said, the hard hat runtime environment is basically the same thing as hard hat.

6673
11:15:24.748 --> 11:15:28.617
So we can just go ahead and import it like this, actually like this.

6674
11:15:28.617 --> 11:15:32.911
Because we actually need to abstract just the deployer from getting named accounts.

6675
11:15:32.911 --> 11:15:37.522
And now what we can do is we can connect our Deployer to our Fund Me account.

6676
11:15:37.522 --> 11:15:44.129
So whenever we call a function with fund me, it'll automatically be from that the player account, which is great.

6677
11:15:44.129 --> 11:15:48.155
Another way you can get different accounts directly from your heart had config.

6678
11:15:48.155 --> 11:15:59.594
Is you could take const accounts equals await ethers dot get signers, ethers dot get signers is going to return whatever is in this account section of your network.

6679
11:15:59.594 --> 11:16:06.940
If you're on your default network hard hat, it's going to give you a list of 10 fake accounts that we can work with you then of course, can do something like const.

6680
11:16:06.940 --> 11:16:09.940
Account one equals accounts.

6681
11:16:09.940 --> 11:16:15.945
More correctly would be account zero equals account zero and work like that.

6682
11:16:15.945 --> 11:16:18.808
We'll leave that comment that out, just in case you need a reference to it in the future.

6683
11:16:18.808 --> 11:16:19.388
Okay, great.

6684
11:16:19.388 --> 11:16:21.071
So now we have our Funmi contract.

6685
11:16:21.071 --> 11:16:23.940
Let's go ahead and write some tests for testing the constructor.

6686
11:16:23.940 --> 11:16:27.785
And we're probably going to want to use this deployer object down here.

6687
11:16:27.785 --> 11:16:30.245
So we'll do let deployer above.

6688
11:16:30.405 --> 11:16:32.642
And we'll do something a little finicky here.

6689
11:16:33.405 --> 11:16:38.896
deployer equals Wait, get named accounts, dot Deployer.

6690
11:16:39.405 --> 11:16:44.388
we'll just wrap this up so that we can just grab this deployer object and assign it to declare like so.

6691
11:16:44.388 --> 11:16:52.947
Now in here, we'll create our first test, we'll say it will say it sets the Agra Gator addresses correctly.

6692
11:16:52.947 --> 11:16:57.354
Comma will have this be an async function.

6693
11:16:57.354 --> 11:17:08.321
And we'll say const response equals await fund me dot, let's get this price feed here, fund me dot price feed.

6694
11:17:08.405 --> 11:17:16.309
And then we'll want to make sure this price feed is going to be the same as our Mk V three aggregator since we're going to be running these tests locally.

6695
11:17:16.309 --> 11:17:21.139
So we should get our mark three V three aggregator up top.

6696
11:17:21.139 --> 11:17:25.186
Let's do let mock v3 aggregate store.

6697
11:17:25.406 --> 11:17:37.897
And we'll grab this address the same way mockbee Three aggregator equals await ethers dot get contract mockbee Three aggregator comma, we'll connect this one to the deployer as well.

6698
11:17:37.897 --> 11:17:48.651
So we'll want to say cert dot equals cert dot equal response comma lock v3 aggregator dot address.

6699
11:17:48.651 --> 11:17:54.156
And of course we'll want to say const.

6700
11:17:54.156 --> 11:17:57.281
Assert equals require gy.

6701
11:17:57.281 --> 11:17:59.406
Import that from DJI.

6702
11:17:59.406 --> 11:18:00.252
Okay, cool.

6703
11:18:00.406 --> 11:18:03.175
Now, let's go ahead and try this out.

6704
11:18:03.175 --> 11:18:04.175
Yarn hardhat.

6705
11:18:04.175 --> 11:18:04.559
Test.

6706
11:18:05.406 --> 11:18:07.180
spelled response wrong.

6707
11:18:07.180 --> 11:18:08.873
Let's try that again.

6708
11:18:08.873 --> 11:18:09.518
Awesome.

6709
11:18:10.406 --> 11:18:17.263
means that we are indeed assigning the price feed address correctly to the Mach v3 aggregator.

6710
11:18:17.263 --> 11:18:18.242
Okay, great.

6711
11:18:18.406 --> 11:18:18.729
Awesome.

6712
11:18:21.406 --> 11:18:21.929
constructor.

6713
11:18:24.406 --> 11:18:28.371
them more just to kind of demo what they look like, we're going to skip writing tests for them for now.

6714
11:18:28.371 --> 11:18:32.356
And we're actually going to go ahead and delete them directly from the contract.

6715
11:18:32.406 --> 11:18:35.889
If you want to go ahead and write some tests for them and leave them in your examples for your learnings.

6716
11:18:35.889 --> 11:18:41.033
You absolutely can pause the video and write some tests for it if you choose so, but we're going to skip them.

6717
11:18:41.033 --> 11:18:46.130
Next though, we are going to move on to fund and running some tests for fun here.

6718
11:18:46.130 --> 11:18:48.478
So let's go ahead and write describe fund.

6719
11:18:48.478 --> 11:18:50.854
This will be an async function.

6720
11:18:50.854 --> 11:18:55.656
And in here, we're going to do a number of tests.

6721
11:18:55.656 --> 11:19:08.529
So if we're going to go line by line here, what's the first thing that we should look at? Well, we should look at this require line we should write a test to see if this contract actually does fail? If not enough, eath is sent.

6722
11:19:08.529 --> 11:19:29.273
So let's go ahead and we'll say it fails, if you don't send enough eath have this be an async function? Now, how do we test to see if something fails? Right now we've done assert equals, but if something fails, we might run into an issue.

6723
11:19:29.273 --> 11:19:37.193
So for example, if I run await fund me dot fund, but I don't pass any value to this transaction.

6724
11:19:37.193 --> 11:19:38.324
Let's see what happens.

6725
11:19:38.324 --> 11:19:39.734
I run yarn Hardhead test.

6726
11:19:39.734 --> 11:19:44.242
Well, our test is actually going to break VM exception.

6727
11:19:44.407 --> 11:19:49.519
While processing transaction reverted with reason string, you need to spend more eath.

6728
11:19:49.519 --> 11:19:51.990
So our tests are going to break which is good.

6729
11:19:51.990 --> 11:19:53.823
We want this to break.

6730
11:19:53.823 --> 11:19:57.540
But we want to tell our test that this is okay.

6731
11:19:57.540 --> 11:20:00.073
Right? Want to tell that this is okay.

6732
11:20:00.073 --> 11:20:05.182
So the way we can do this, and this is where our waffle testing comes into play.

6733
11:20:05.182 --> 11:20:15.140
With waffle and with testing, what we can actually do is we can use the expect keyword and expect transactions to be reverted and for transactions to fail.

6734
11:20:15.140 --> 11:20:23.084
So instead of using assert here, we're actually going to run a wait expect fund me dot fun 2.

6735
11:20:23.084 --> 11:20:37.734
2 dot B, that reverted and we've actually even be more specific here by saying to be reverted with and then the exact reverted error, you need to spend more eath.

6736
11:20:37.734 --> 11:20:41.997
Now if we run our tests, oops expect is not defined.

6737
11:20:41.997 --> 11:20:45.426
So we need to import that from Chai.

6738
11:20:45.426 --> 11:20:53.177
Which chai is being overwritten by waffle, we see that it does indeed Pass, which is perfect.

6739
11:20:53.177 --> 11:20:58.311
So now we have a way to both assert things and expect things to fail.

6740
11:20:58.311 --> 11:21:01.278
Awesome, even with the specific failure codes.

6741
11:21:01.408 --> 11:21:01.758
Perfect.

6742
11:21:01.758 --> 11:21:03.408
Let's write some more tests here.

6743
11:21:04.408 --> 11:21:08.023
want it to correctly update this data structure.

6744
11:21:09.408 --> 11:21:17.541
it updates the amount funded data structure, it's going to be an async function.

6745
11:21:17.541 --> 11:21:21.214
In here, we're going to need to call fund v dot fund.

6746
11:21:21.214 --> 11:21:27.149
However, we're going to need to actually pass some value with this transaction.

6747
11:21:27.149 --> 11:21:33.158
And for now, we'll just hard code the value that we're going to send, say const.

6748
11:21:33.158 --> 11:21:41.469
Send value is going to be 112345 678-910-1234 5678, which is going to be one eath.

6749
11:21:41.469 --> 11:21:46.604
Another way we can write this though, is we can use the ethers utility to make this a little bit easier to read.

6750
11:21:46.604 --> 11:21:51.908
Because all those zeros are kind of confusing, and it's hard to tell at first glance what this actually is.

6751
11:21:51.908 --> 11:22:07.178
So we're gonna actually use ethers dot utils dot parse ether, one, this parse ethers utility converts this one into that one with 18 zeros, which makes life a lot easier.

6752
11:22:07.178 --> 11:22:15.534
If you go to the ethers documentation, there's also a parts units function where you can actually convert any unit, either ethers or Gwei.

6753
11:22:15.534 --> 11:22:20.588
Or really whatever you want to do, you could convert any number to any other Aetherium you type.

6754
11:22:20.588 --> 11:22:23.599
So this is the set value that we're going to use for our fund.

6755
11:22:23.599 --> 11:22:28.195
And, and this is definitely going to be more than our minimum USD of 50.

6756
11:22:28.195 --> 11:22:43.373
So after we call this fun function, we'll say const response is going to be equal to a weight, fund me dot address to Mt funded address to Mt funded for the deployer dot address.

6757
11:22:43.373 --> 11:22:49.159
Because remember, this is a mapping of each address and how much they've actually funded.

6758
11:22:49.159 --> 11:22:54.251
So if we use the deployer address, it should give us the amount that we actually sent.

6759
11:22:54.251 --> 11:22:57.830
So now we can run assert dot equal response.

6760
11:22:57.830 --> 11:23:04.900
to string, right, because this response is going to be the big number version of how much has been funded by that account.

6761
11:23:04.900 --> 11:23:08.128
And that should be the same as our send value.

6762
11:23:08.128 --> 11:23:08.999
to string.

6763
11:23:08.999 --> 11:23:21.857
Since send value, our one should be the exact same as the amount that we funded, we can run just this one test, or running yarn, art hat, test, dash dash grep.

6764
11:23:21.857 --> 11:23:27.774
And we'll put this in quotes allow funded for this amount funded line.

6765
11:23:27.774 --> 11:23:35.634
And it looks like we ran into an issue here, because we don't need to do deployed at address, we can just do deploy here.

6766
11:23:35.634 --> 11:23:38.742
And great, it looks like we are indeed passing.

6767
11:23:38.742 --> 11:23:45.309
Now if we even run yarn Hardhead coverage will now see we've got at least a little bit more coverage here.

6768
11:23:45.309 --> 11:23:46.959
It's still not going to be great.

6769
11:23:46.959 --> 11:23:48.748
But we have much better coverage.

6770
11:23:48.748 --> 11:23:52.777
We have some statements, some branches, and at least some functions covered.

6771
11:23:52.777 --> 11:23:53.771
So this is awesome.

6772
11:23:53.771 --> 11:23:54.650
Let's keep going.

6773
11:23:54.650 --> 11:23:58.215
Are we all done testing our fun function? Well, probably not.

6774
11:23:58.215 --> 11:24:03.901
What else can we do with our fun function? Well, we're also adding funders to a funders array.

6775
11:24:03.901 --> 11:24:07.441
So let's go ahead and test for that.

6776
11:24:07.441 --> 11:24:15.442
So it adds funder to array of funders has been an async function.

6777
11:24:15.442 --> 11:24:22.753
And we'll say await fund mean that fund value is going to be send value.

6778
11:24:22.753 --> 11:24:32.901
We'll say const response equals await fund me dot calling the funders array at index zero.

6779
11:24:32.901 --> 11:24:39.767
So this will be funder equals await fund me dot funders zero.

6780
11:24:39.767 --> 11:24:44.972
And then we'll say assert dot equal funder should be the same as the Deployer.

6781
11:24:44.972 --> 11:24:47.060
So let's go ahead and run this test.

6782
11:24:47.060 --> 11:24:48.460
We'll hit up a couple times.

6783
11:24:48.460 --> 11:24:55.845
And we'll change the GREP to under to array so that it looks for this line.

6784
11:24:55.845 --> 11:24:56.861
And perfect.

6785
11:24:56.861 --> 11:24:59.377
It looks like that one is also passing.

6786
11:24:59.377 --> 11:24:59.764
Great.

6787
11:24:59.764 --> 11:25:06.237
So the money's coming through, the minimum amount is coming through and our data structures are being updated.

6788
11:25:06.237 --> 11:25:06.788
Awesome.

6789
11:25:06.788 --> 11:25:11.143
Now we could be a little bit more verbose and do even more testing with this fun function.

6790
11:25:11.143 --> 11:25:13.743
But I think for the most part, we've got the gist, right.

6791
11:25:13.743 --> 11:25:17.246
So now let's go ahead and move on to the withdrawal function.

6792
11:25:17.246 --> 11:25:21.076
So we're going to create a new describe or withdraw.

6793
11:25:21.076 --> 11:25:26.142
This is going to be an async function.

6794
11:25:26.410 --> 11:25:29.070
And let's see what the withdrawal function does.

6795
11:25:29.410 --> 11:25:34.071
the owner of the contract is going to be able to get the balance, get the money back.

6796
11:25:34.071 --> 11:25:38.770
And we're also going to reset all of the amounts that each one of these users is done.

6797
11:25:38.770 --> 11:25:40.910
So let's go ahead and do some withdrawing.

6798
11:25:40.910 --> 11:25:57.875
Now in order for us to test withdraw, we probably first want the contract to actually have some money and so what we can do actually is we can add another before each in the describe to automatically fund the contract before we run any tests.

6799
11:25:57.875 --> 11:26:02.536
So we can say before each async function.

6800
11:26:02.536 --> 11:26:07.457
We can say await, fund me dot fund.

6801
11:26:07.457 --> 11:26:09.988
Value, send value.

6802
11:26:10.411 --> 11:26:16.818
Now for all of our tests in this withdrawal scope, we're first going to fund it with eath.

6803
11:26:16.818 --> 11:26:20.927
Let's say it can withdraw, withdraw eath.

6804
11:26:20.927 --> 11:26:27.185
From a single founder, this would be an async function.

6805
11:26:27.185 --> 11:26:31.926
And this is going to be a little bit longer test.

6806
11:26:31.926 --> 11:26:38.973
So I'm going to set it up to be an arrange, act and assert test.

6807
11:26:38.973 --> 11:26:45.169
So arrange act assert is just sort of a way to think about writing tests, you want to arrange the test, then you want to act.

6808
11:26:45.169 --> 11:26:48.478
And then you want to run the asserts, and you'll see what I mean in just a second.

6809
11:26:48.478 --> 11:26:56.220
So we're going to arrange this test, we're going to set this test up, we want to actually check that we're correctly withdrawing the ether from a single founder.

6810
11:26:56.220 --> 11:27:02.533
So first, we're going to get the starting balance of the fundraising contract and the starting balance of the Deployer.

6811
11:27:02.533 --> 11:27:05.199
So we'll say const.

6812
11:27:05.199 --> 11:27:17.344
Starting under me, balance, equals await, fund me dot provider, dot get balance, fund me dot address.

6813
11:27:17.344 --> 11:27:23.724
So we're gonna start with the balance of the fund V contract after it's been funded with some eath.

6814
11:27:23.724 --> 11:27:39.356
And we're also gonna get costs start starting, deploy your balance goes await, fund me dot provider, dot get balance of deployed employer.

6815
11:27:39.412 --> 11:27:50.089
So we're getting the starting balance of the Funmi, we're getting to the starting balance of the employer so that we can test later on how much these numbers have changed based off of what happens when we call the withdrawal function.

6816
11:27:50.089 --> 11:27:55.459
Now that we've done a little bit of setup, we can actually run this withdrawal function, we can do the act here.

6817
11:27:55.459 --> 11:28:03.697
So we're gonna say const, trans action response equals await, fund me dot withdraw.

6818
11:28:03.697 --> 11:28:16.300
And then we can say const, transaction receipt equals await transaction response.

6819
11:28:16.300 --> 11:28:25.459
That Wait, one, and now we should be able to check to see that the entire fund rebalance has been added to the deployer balance.

6820
11:28:25.459 --> 11:28:39.649
So now we can say const ending fund me balance equals a weight on me that provider dot get balance of Unreal dot address.

6821
11:28:39.649 --> 11:28:55.258
Then we can say const ending deployer balance equals await, fund me dot provider dot get balance of Deployer.

6822
11:28:55.258 --> 11:29:00.300
And now we can just check to see if the numbers work out here.

6823
11:29:00.412 --> 11:29:13.347
So we can say assert dot equal ending fund me balance is going to be zero, right, because we just withdrew all of the money.

6824
11:29:13.413 --> 11:29:15.993
So ending funding balance should be zero.

6825
11:29:17.413 --> 11:29:25.996
dot equal starting fund me balance plus starting deployer balance.

6826
11:29:25.996 --> 11:29:34.344
So the starting funds the balance plus the starting employer balance should equal the ending employer balance.

6827
11:29:34.413 --> 11:29:45.263
Since we're grabbing whatever the starting deployer balance started with plus the starting fund to be balanced, because we just withdrew all of the starting fund, we balance that should equal the ending deployer bots.

6828
11:29:45.263 --> 11:29:59.527
Now a couple of notes here, since starting Funmi balance is calling from the blockchain, it's going to be of type a big number, we want to use big number dot add actually, instead of the plus sign here, just because it'll it'll make working with our big numbers a little bit easier.

6829
11:29:59.527 --> 11:30:05.413
So instead of starting Funmi balance, plus we're gonna be starting from the balance dot add.

6830
11:30:05.413 --> 11:30:06.038
Like that.

6831
11:30:06.038 --> 11:30:07.379
And that should be good.

6832
11:30:07.379 --> 11:30:16.235
One other thing about this, though, is that when we called withdraw our Deployer did what our Deployer spent a little bit of gas.

6833
11:30:16.235 --> 11:30:19.847
So this actually isn't accurate.

6834
11:30:19.847 --> 11:30:26.701
We actually also need to calculate in the gas cost, so we wouldn't need to do dot add gas cost.

6835
11:30:26.701 --> 11:30:28.480
We'd also have to do.

6836
11:30:28.480 --> 11:30:34.671
to string because big numbers are objects and so identities a little bit weird.

6837
11:30:34.671 --> 11:30:39.302
So to test to see if they're equal, we'll just make them both strings.

6838
11:30:39.302 --> 11:30:42.413
Now we don't have gas costs.

6839
11:30:42.413 --> 11:30:47.476
So let's figure out how to get the gas cost from this transaction.

6840
11:30:47.476 --> 11:30:51.610
So we can add it to Are any deployer bounce, so we can run this assertion here.

6841
11:30:51.610 --> 11:30:55.887
So what we can do is we can actually find the gas costs from our transaction receipt.

6842
11:30:55.887 --> 11:31:00.880
And I'm going to show you a couple of phenomenal tricks you can use with VS code.

6843
11:31:00.880 --> 11:31:04.366
And if using a different editor, then don't worry too much about this.

6844
11:31:04.414 --> 11:31:08.299
What we can do in VS code actually is create something called breakpoints.

6845
11:31:08.299 --> 11:31:17.363
unverified breakpoint file is modified to please restart the bug session, or let's put it right here, put it right in this line after transaction receipt is created.

6846
11:31:17.414 --> 11:31:31.033
But before ending Funmi belts, what this breakpoint does is it stops the script at this line, and allows us to drop into something called a debug console and see all the variables that are happening.

6847
11:31:31.033 --> 11:31:36.525
At this time, we want to look at the transaction receipt and see if the total gas cost is in there.

6848
11:31:36.525 --> 11:31:44.142
This is also incredibly helpful for dropping into tests and dropping into scripts and seeing exactly what's going on that's wrong.

6849
11:31:44.142 --> 11:31:47.758
So what we can do is we can move down to this run into bug section.

6850
11:31:47.758 --> 11:31:50.315
And if it's not there, you can hit additional views.

6851
11:31:50.414 --> 11:31:57.628
And we can click this JavaScript Debug Terminal, which will create a new terminal in our terminal section.

6852
11:31:57.628 --> 11:32:04.461
Now, what happens here is if we run yarn, hard hat test, it'll run our testing and everything.

6853
11:32:04.461 --> 11:32:06.610
But when it hits this breakpoint, it'll stop.

6854
11:32:06.610 --> 11:32:08.183
Currently, there is no gas cost.

6855
11:32:08.183 --> 11:32:10.117
So we're just going to delete this for now.

6856
11:32:10.117 --> 11:32:12.233
So that we compile and we work in everything.

6857
11:32:12.233 --> 11:32:21.091
But if we run yarn Hardhead test, see, it's gonna say debugger has been attached to start running our tests.

6858
11:32:21.091 --> 11:32:23.814
And it's going to stop on this line here.

6859
11:32:23.814 --> 11:32:32.351
And if we look in this variable section on the left hand side, we can actually see a ton of the variables that are in here.

6860
11:32:32.351 --> 11:32:35.866
And we can read a little bit more about what's going on.

6861
11:32:35.866 --> 11:32:57.344
And if we go over to our debug console, we can type in things like transaction receipt, and we can see a ton of information about that transaction receipt object, what we're looking for is we're looking to see this transaction receipt, which we could look in the debug console or over here, if there's anything to do with gas in here.

6862
11:32:57.415 --> 11:33:01.344
And it looks like there is there's a gas used big number.

6863
11:33:01.415 --> 11:33:03.972
And there's also an effective gas price.

6864
11:33:05.415 --> 11:33:11.200
used times the gas price is going to give us all the money that we paid for gas here.

6865
11:33:11.200 --> 11:33:21.300
So now that we've figured out there's a gas used and effective gas price variables in this transaction receipt, which we could have also found in the documentation here.

6866
11:33:21.300 --> 11:33:30.248
However, sometimes it's even quicker just to find it out yourself what we can do, we can exit the debugger by clicking this little thing here.

6867
11:33:30.248 --> 11:33:36.526
Go back to terminal will trash can the JavaScript debugger, we'll remove the breakpoint.

6868
11:33:36.526 --> 11:33:48.316
And we'll grab those two variables we can pull them right out of that transaction receipt object by typing const.

6869
11:33:48.415 --> 11:33:55.874
Yes, used comma effective gas price equals transaction receipt.

6870
11:33:55.874 --> 11:34:02.336
So again, with this curly bracket syntax, we can use this to pull out objects out of another object.

6871
11:34:02.336 --> 11:34:14.016
And now that we have these two objects, we can create a const gas cost or total gas cost is going to be equal to the gas used times the effective gas price.

6872
11:34:14.016 --> 11:34:23.916
Which again, since these are both big numbers, we can use a big number function called dot mol to multiply them together.

6873
11:34:23.916 --> 11:34:33.349
Now that we have this total gas cost, we can come down and we can say the ending deployer balance plus that gas cost to string.

6874
11:34:33.349 --> 11:34:36.149
Now the two of these should be equivalent.

6875
11:34:36.149 --> 11:34:40.350
I know there's a lot of math that we're doing in this section and a lot of new things.

6876
11:34:40.350 --> 11:34:43.399
So I want to just quickly rego over what we just learned.

6877
11:34:43.399 --> 11:34:54.449
So first off, the font of the contract comes with a provider, we could have also done ethers dot provider dot get balance, but we're using fun v dot provider because we're using the provider of the Funmi contract.

6878
11:34:54.449 --> 11:34:56.494
It doesn't really matter what we use here.

6879
11:34:56.494 --> 11:35:02.940
We just wanted to use this get balanced function of the provider object which gets us the balance of any contract.

6880
11:35:02.940 --> 11:35:06.284
We do the same thing with starting deplore balance.

6881
11:35:06.416 --> 11:35:14.749
The reason that we needed the starting balances is because we wanted to compare it to the ending balances to see if all the money went to the right places, we then call the withdrawal function.

6882
11:35:14.749 --> 11:35:20.339
And from the transaction receipt, we grabbed the gas used and the gas price.

6883
11:35:20.339 --> 11:35:33.216
If you want to debug your JavaScript code, you can add a breakpoint like so go to run into bug, open your debug JavaScript terminal, which is different from your regular bash terminals.

6884
11:35:33.216 --> 11:35:38.899
And when you run JavaScript commands in here, they will stop where your breakpoints are.

6885
11:35:38.899 --> 11:35:41.845
Then you can read the different variables and see where different things are.

6886
11:35:41.845 --> 11:35:42.845
Using that knowledge.

6887
11:35:42.845 --> 11:35:58.332
We pulled out the gas use and effective gas price from the transaction receipt and used it to get the total gas cost of this transaction, we then got the ending fund, we balanced the ending deployer balance, and used all those variables to make sure all the money went to the right places.

6888
11:35:58.332 --> 11:36:12.298
And we, we can check this by running yarn Hardhead test dash dash grep withdraw eath in quotes, since there's a space here, and we can see that our test does indeed pass.

6889
11:36:12.298 --> 11:36:13.145
Great job.

6890
11:36:13.145 --> 11:36:17.481
If we didn't add the gas cost here, and we just did.

6891
11:36:17.481 --> 11:36:29.578
to string, we would see something like this, we would see that the numbers are ever so slightly off, because we're not anticipating we're not calculating the gas here.

6892
11:36:29.578 --> 11:36:35.970
So we always want to make sure we're using the gas if we're doing calculations like this.

6893
11:36:35.970 --> 11:36:40.320
Now another incredibly powerful debugging tool that we're not really going to go over here.

6894
11:36:40.320 --> 11:36:47.010
But it's important to know about because it can be really helpful is that you can actually use console dot log in your solidity with hard hat.

6895
11:36:47.010 --> 11:36:52.032
If you're inside of a heart hat project, you just import hard hat slash console dot soul.

6896
11:36:52.032 --> 11:36:58.899
And then right in your solidity, you can do console dot log, and then type pretty much whatever you want.

6897
11:36:58.899 --> 11:37:06.269
When you execute these functions, similar to how we do a console dot log in JavaScript, those will actually console dot log out to your terminal.

6898
11:37:06.269 --> 11:37:13.820
Here's an example of if you run yarn, hard hat test and you have those console dot logs, you'll see stuff like this get printed out.

6899
11:37:13.820 --> 11:37:24.351
So in addition to the Visual Studio Code debugger, importing hard hat slash console dot Sol, and using console dot logs in your solidity can also be an effective debugging strategy.

6900
11:37:24.351 --> 11:37:30.318
Feel free to give this video a pause, implement this in some of our contracts and try it out in our tests.

6901
11:37:30.318 --> 11:37:48.618
So we tested that withdrawing eath when there's a single funder works perfectly, let's test withdrawing eath if there are multiple funders, so we'll do it, let's say allows us to withdraw with multiple funders.

6902
11:37:48.618 --> 11:37:53.349
Why would this be an async function.

6903
11:37:53.349 --> 11:38:01.327
And let's do this await Funmi not fun, but with a number of different accounts.

6904
11:38:01.327 --> 11:38:11.314
So we can create a whole bunch of different accounts of course, by saying const accounts equals await ethers dot get signers.

6905
11:38:11.314 --> 11:38:16.871
And we can loop through these accounts and have each one of these accounts call the fund function.

6906
11:38:16.871 --> 11:38:19.547
And we're going to do this with a for loop.

6907
11:38:19.547 --> 11:38:30.285
So we're going to say for let i equals we'll start with the first index of the accounts because the zero with index is going to be the Deployer.

6908
11:38:30.285 --> 11:38:35.306
So we'll say let i equals one is going to be less than let's say six.

6909
11:38:35.306 --> 11:38:37.621
And we'll do i plus plus.

6910
11:38:37.621 --> 11:38:40.792
And in here, we'll say const.

6911
11:38:40.792 --> 11:38:47.233
And me contract Funmi connected contract equals await.

6912
11:38:47.233 --> 11:39:01.775
And me dot connect two accounts, I, so we need to call this connect function because right now if we scroll up back to the top, our Funmi contract is connected to our Deployer account.

6913
11:39:01.775 --> 11:39:13.034
And anytime we call a transaction with Funmi, the deployer is the account that is calling that transaction, we need to create new objects to connect to all of these different accounts.

6914
11:39:13.034 --> 11:39:19.490
So we're gonna say fund me connected contract, which is now connected to one of these different accounts dot fund.

6915
11:39:19.490 --> 11:39:23.276
And this is where we'll do value, send value.

6916
11:39:23.276 --> 11:39:25.736
Or excuse me, we'll do await.

6917
11:39:25.736 --> 11:39:26.116
Great.

6918
11:39:26.116 --> 11:39:28.973
So this is going to be our our range section.

6919
11:39:28.973 --> 11:39:33.812
And then same as we did above, we need to grab those starting balances.

6920
11:39:33.812 --> 11:39:37.096
So we can just copy that, those two lines and paste that down here.

6921
11:39:37.096 --> 11:39:41.919
Now we're going to move into act, I'm going to call that withdrawal function again.

6922
11:39:41.919 --> 11:39:50.935
So let's say const, transaction action response equals await and MI dot withdraw.

6923
11:39:50.935 --> 11:39:59.657
And we're going to do the exact same thing as we did above, getting the transaction receipt and the gas costs so we can get everything correct.

6924
11:39:59.657 --> 11:40:02.128
Once we've done the act, we move on into assert.

6925
11:40:02.128 --> 11:40:10.704
And we're going to do some very similar things to what we did above, like this, for example, this whole first part is going to be exactly the same.

6926
11:40:10.704 --> 11:40:15.419
We also want to make sure the funders are reset properly.

6927
11:40:15.419 --> 11:40:20.387
So we'll make sure that this funders array is reset properly.

6928
11:40:20.387 --> 11:40:35.180
So to do that, we can actually just check to see that if looking at the zero with position throws an error so we can run a wait expect fund me dot get on me dot funder on me dot funders of zero.

6929
11:40:35.180 --> 11:40:53.258
This should revert so we'll say await expect Funmi dot funders dot two dot b dot reverted and then we want to loop through all these accounts and make sure that it makes sure or that in our mapping here, all their amounts are zero.

6930
11:40:53.258 --> 11:41:08.816
So we'll say, for I equals one is less than six, i plus plus, we'll say assert dot equal.

6931
11:41:08.816 --> 11:41:22.003
Wait, fund me dot address to amount funded, of the accounts of I got address should be zero.

6932
11:41:22.003 --> 11:41:27.629
So we're making sure that all of these mappings are correctly updated to zero.

6933
11:41:27.629 --> 11:41:28.887
So let's go and test this.

6934
11:41:28.887 --> 11:41:38.520
So we're withdrawing with multiple founders, we're going to go back to our terminal, we're going to hit up, we're going to change this GREP or this one.

6935
11:41:38.520 --> 11:41:41.020
We'll see if this passes.

6936
11:41:41.020 --> 11:41:50.640
And it does indeed, so this means that our withdraw function works really well even when there's multiple funders and we can be happy and go to sleep knowing that.

6937
11:41:50.640 --> 11:42:00.182
Now the other thing we absolutely want 100% want to test is that our only owner modifier is working, we want only the owner to be able to withdraw the funds from here.

6938
11:42:00.182 --> 11:42:10.314
So we'll create a new session, we'll say it only allows the owner to withdraw only allows you to withdraw.

6939
11:42:10.420 --> 11:42:13.862
This will be an async function.

6940
11:42:17.420 --> 11:42:19.657
Accounts equals ethers dot get signers again.

6941
11:42:20.420 --> 11:42:24.666
const attacker equals accounts of one.

6942
11:42:27.421 --> 11:42:42.421
account will be some random attacker will connect this attacker to a new contract, we'll say const attacker connected contract equals await on DB dot Connect.

6943
11:42:42.421 --> 11:42:47.674
Attacker dot address, excuse me a dot connect attacker.

6944
11:42:47.674 --> 11:42:55.695
Since we're not just connecting the address, we're connecting the account which attacker is an account object.

6945
11:42:55.695 --> 11:43:14.524
And then we'll do a wait expect attacker connected contract dot withdraw dot two dot b dot reverted, they should not be able to withdraw.

6946
11:43:14.524 --> 11:43:22.813
So let's go ahead, we can even just copy this whole thing if we want to hit up, we'll delete this section here.

6947
11:43:22.813 --> 11:43:24.582
We'll paste that in.

6948
11:43:24.582 --> 11:43:25.307
And boom.

6949
11:43:25.307 --> 11:43:32.711
This means that when some other account tries to call withdraw, automatically gets reverted, which is what we want.

6950
11:43:32.711 --> 11:43:39.921
Now we can be more explicit to make sure that the correct error code is being thrown, not just that it's reverted.

6951
11:43:39.921 --> 11:43:47.155
Right, it can be very reverted because they sent ether did it they did something weird, we want to make sure it's reverted with our specific error code.

6952
11:43:47.155 --> 11:43:49.711
So right now we have this not owner error code.

6953
11:43:49.711 --> 11:43:56.959
But it's actually a best practice to put the contract name to underscores and then your custom error.

6954
11:43:56.959 --> 11:44:02.954
This makes it a lot easier in the future when you have a ton of different contracts, and you're not sure where an error is coming from.

6955
11:44:02.954 --> 11:44:18.470
So we're going to just update this really quickly to be fund me underscore underscore, not owner, now we can do is now that we have this custom error, we can say withdraw that to be reverted with, then we can add our custom error in here.

6956
11:44:18.470 --> 11:44:25.596
Now, if we rerun our test, with only allows the owner to withdraw, oops, we need to do a wait here.

6957
11:44:25.596 --> 11:44:28.320
My mistake, wait a Thursday, get signers.

6958
11:44:28.320 --> 11:44:30.286
And now let's try this again.

6959
11:44:30.422 --> 11:44:35.274
And we are indeed passing Perfect.

6960
11:44:35.422 --> 11:44:35.937
Okay, great.

6961
11:44:35.937 --> 11:44:37.577
We have some basic unit tests here.

6962
11:44:38.422 --> 11:44:40.588
to write some staging tests pretty soon.

6963
11:44:41.422 --> 11:44:46.025
actually do that, let's go ahead and add the gas estimator.

6964
11:44:46.422 --> 11:44:49.732
we'll see how much gas these contracts in these functions are taking.

6965
11:44:49.732 --> 11:44:52.760
It looks like the Hardhead gas reporter is already here.

6966
11:44:52.760 --> 11:44:54.539
So let's scroll down.

6967
11:44:54.539 --> 11:44:56.827
We'll do gas reporter true.

6968
11:44:56.827 --> 11:44:59.555
And we won't do coin market cap here.

6969
11:44:59.555 --> 11:45:01.772
And we'll just look purely at the GUI.

6970
11:45:01.772 --> 11:45:03.210
So you can just comment it out like that.

6971
11:45:03.210 --> 11:45:05.452
Now rerun all of our tests.

6972
11:45:05.452 --> 11:45:08.036
So we'll say yarn, our test.

6973
11:45:08.036 --> 11:45:13.993
And in doing so we're gonna get that that gas output in that gas report dash text here.

6974
11:45:13.993 --> 11:45:17.896
So looks like all of our tests are passing, which is perfect.

6975
11:45:17.896 --> 11:45:22.234
Now we can look into our gas report and see what's going on here.

6976
11:45:22.234 --> 11:45:32.155
i Well, it looks like the fundraising function is taking a decent chunk of gas, the withdrawal function, take it some guests to we'd see the min, the max and the average.

6977
11:45:32.155 --> 11:45:36.114
Of course, we can see how much each one of these contracts cost to actually output.

6978
11:45:36.114 --> 11:45:40.385
We don't really care about the MOQ aggregator of course, because we're never actually going to use that.

6979
11:45:40.422 --> 11:45:45.798
Let's say we look at the average gas for these and we go hmm, this looks like it's actually a lot more than what we originally expected.

6980
11:45:45.798 --> 11:45:48.329
Is there a way for us to make this a little bit cheap.

6981
11:45:48.423 --> 11:45:52.711
If we go back to our funding contract, we look at our withdrawal function.

6982
11:45:52.711 --> 11:45:57.507
And we noticed something, oh, there is actually a way to make this a lot cheaper.

6983
11:45:57.507 --> 11:46:05.368
And it has to do with something called storage variables, or these global variables that we've been working with this whole time.

6984
11:46:05.423 --> 11:46:12.009
Let me let me paint you a little picture here, we're gonna look at one of the first gas optimization techniques you can take to drop these down.

6985
11:46:12.009 --> 11:46:14.284
And it has to do with an R Funmi.

6986
11:46:14.423 --> 11:46:25.216
Contract these state variables and how they're actually stored and how this contract actually keeps track of all this stuff, this section is going to be a little bit more advanced.

6987
11:46:25.216 --> 11:46:34.298
So we'll have a note here saying that this is an advanced section, if you want to skip over it, you can, because now we're getting into gas optimizations here, this information still is really good to know.

6988
11:46:34.298 --> 11:46:38.177
So if you want to skip it for now, and then come back later, you absolutely can.

6989
11:46:38.177 --> 11:46:44.914
But let's talk about what happens when we actually save or store these global variables.

6990
11:46:44.914 --> 11:46:46.947
Okay, these storage variables.

6991
11:46:46.947 --> 11:46:50.372
Now, everything I'm about to go through is in the documentation.

6992
11:46:50.423 --> 11:47:07.580
And there is a link to this, of course, in the GitHub repo associated with this course, whenever we have one of these global variables, or these variables that stay permanently, they're stuck in something called storage, you can think of storage as a big giant array, or a giant list of all the variables that we actually create.

6993
11:47:07.580 --> 11:47:27.762
So when we say we have some contract called Son of storage, and we have a variable called favorite number, we're basically saying we want this favorite number variable to persist, right, we saw in a lot of our examples, we had a favorite number variable that we can always call to see what this contracts favorite number was, well, the way it persists, is it gets stored in this place called storage.

6994
11:47:27.762 --> 11:47:40.203
A storage box is this giant list associated with this contract where every single variable and every single value in the storage section is slotted into a 32 byte long slot in this storage array.

6995
11:47:40.203 --> 11:47:47.392
So for example, the number 25 in its bytes implementation is 000 with a ton of zeros 19.

6996
11:47:47.392 --> 11:47:49.820
This is the hex version of the yuan 256.

6997
11:47:49.820 --> 11:47:56.327
This is why we do so much hex translation, the bytes implementation of a yuan 256.

6998
11:47:56.424 --> 11:47:59.746
And each store saw increments just like an array starting from zero.

6999
11:47:59.746 --> 11:48:09.342
So for example, our next global variable or next storage variable just gets slotted at the next slot that's available.

7000
11:48:09.424 --> 11:48:21.281
So bullions, for example, get transformed from their bull version two, their hex and we modified our some bool variable to be true and X edition of the true Boolean 0x 001.

7001
11:48:21.281 --> 11:48:29.620
Every time you save an additional global variable, or more correctly, one of these storage variables, it takes up an additional storage slot.

7002
11:48:29.620 --> 11:48:44.714
And what about variables that are dynamic in length, or that can change length? What about something that's dynamic? Well, for dynamic values, like a dynamic array, or a mapping elements inside the array or inside the mapping are actually stored using some type of hashing function.

7003
11:48:44.714 --> 11:48:53.281
And you can see those specific functions in the documentation, the object itself does take up a storage slot, but it's not going to be the entire array.

7004
11:48:53.281 --> 11:49:06.282
For example, my array variable here at storage, slot two doesn't have the entire array in storage slot two, what has actually is just the array length, the length of the array is stored at storage slot two.

7005
11:49:06.282 --> 11:49:17.591
But for example, if we do my array dot push 222, we do some hashing function, which again, you can see in the documentation what that is, and we'll store the number 222.

7006
11:49:17.591 --> 11:49:26.328
At that location in storage, the hex of 222 is 0x 0000 D, so it gets stored in this crazy spot.

7007
11:49:26.425 --> 11:49:32.780
And this is good, this is intentional, because 32 Bytes may not be nearly big enough to store my array if our array gets massive.

7008
11:49:32.780 --> 11:49:42.691
And it wouldn't make sense for to put the elements inside the array at subsequent numbers because again, the size of the array can change and you're never going to be sure how many subsequence that you need.

7009
11:49:42.691 --> 11:49:46.942
So for my array, it does have a storage slot for the length for mappings.

7010
11:49:46.942 --> 11:49:50.809
It does have a storage spot as well similar to array, but it's just blank.

7011
11:49:50.809 --> 11:50:00.118
But it's blank intentionally so that solidity knows, okay, there is a mapping here, and it needs a storage slot for attaching functional work correctly.

7012
11:50:00.118 --> 11:50:06.070
Now interestingly, constant variables and immutable variables do not take up spots in storage.

7013
11:50:06.070 --> 11:50:14.358
The reason for this is because constant variables are actually part of the contracts byte code itself, which sounds a little bit weird.

7014
11:50:14.425 --> 11:50:23.065
But you can imagine what solidity does is anytime it sees constant variables name is it just automatically swaps it out with whatever number it actually is.

7015
11:50:23.065 --> 11:50:29.186
So you can kind of think of not in storage is just a pointer to 123 and it doesn't take up a storage slot.

7016
11:50:29.186 --> 11:50:36.358
Well when we have variables inside of a function, those variables only exist for the duration of the function.

7017
11:50:36.425 --> 11:50:38.334
They don't stay inside the contract.

7018
11:50:39.425 --> 11:50:40.511
they're not permanent.

7019
11:50:42.425 --> 11:50:46.025
like new var and other var do not get added to storage.

7020
11:50:46.426 --> 11:50:48.783
get added in their own memory data structure.

7021
11:50:49.426 --> 11:50:51.700
deleted after the function has finished running.

7022
11:50:52.426 --> 11:51:00.587
be asking, Okay, well, why do we need this memory keyword, especially when it comes to strings, we saw before that we had to say String memory.

7023
11:51:00.587 --> 11:51:06.360
The reason we need it for strings is because strings are technically this dynamically sized array.

7024
11:51:06.426 --> 11:51:13.019
And we need to tell solidity, hey, we're going to do this on the storage location, or we're going to do it into the memory location where we can just wipe it.

7025
11:51:13.019 --> 11:51:15.671
arrays and mappings can take up a lot more space.

7026
11:51:15.671 --> 11:51:26.171
So slowly, just wants to make sure Okay, where are we working with this is it storage is a memory, you have to tell me, I need to know if I need to allocate space for it in our storage data structure.

7027
11:51:26.171 --> 11:51:29.104
And again, everything here you can read in the solidity documentation.

7028
11:51:29.104 --> 11:51:40.273
Now, in the GitHub repo associated with this course, if you go to contracts, we've actually got an example contract section called Fun with storage, where you can play with and look at a lot of this stuff.

7029
11:51:40.273 --> 11:51:59.926
And we even wrote a little script called deploy storage fun, where it'll print out the storage location of some of the different variables, feel free to give it a run, if you want to try a challenge anybody to write some functions that find the storage slots of the elements of the arrays, and the mappings, and then find the data inside of those as well.

7030
11:51:59.926 --> 11:52:05.583
We use a function here called Get storage app, which allows us to get the storage at any one of these slots.

7031
11:52:05.583 --> 11:52:10.942
And this is to reinforce that even if you have a function as private or internal.

7032
11:52:10.942 --> 11:52:12.619
Anybody can still read it.

7033
11:52:12.619 --> 11:52:15.551
Anybody can read anything off the blockchain.

7034
11:52:15.551 --> 11:52:21.376
And you can test it exactly what this if you go ahead and get clone that or copy paste the code yourself.

7035
11:52:21.426 --> 11:52:27.328
You can then run yarn part at deploy dash test tags, storage.

7036
11:52:27.427 --> 11:52:30.367
And you'll run the deploy script for that storage.

7037
11:52:30.427 --> 11:52:39.880
And you'll see printing out the location of storage in each storage slot with a fun contract that we made as an example.

7038
11:52:39.880 --> 11:52:50.998
And you might of course be asking, Okay, Patrick, why are you telling me all this? We're just trying to get this gas price down? Why are you telling me all about this storage thing? Well, the reason I'm telling you all about the storage thing.

7039
11:52:50.998 --> 11:52:55.577
Anytime you read or you write to and from storage, you spend a ton of gas.

7040
11:52:55.577 --> 11:53:00.194
Remember I said when we compile our code, we compile it down to some crazy weird bytecode.

7041
11:53:00.194 --> 11:53:03.268
Well, let me show you on remix what this looks like.

7042
11:53:03.268 --> 11:53:06.668
We go to compliation details, we can go to bytecode.

7043
11:53:06.668 --> 11:53:10.284
And we see this weird hex object zero, blah, blah, blah.

7044
11:53:10.284 --> 11:53:12.749
But we also see these things called op codes.

7045
11:53:12.749 --> 11:53:15.974
Now, this bytecode here represents these op codes.

7046
11:53:15.974 --> 11:53:21.099
Each one of these op codes represents a small piece of everything in this bytecode.

7047
11:53:21.099 --> 11:53:32.991
And in fact, in our heart hat, we can go to artifacts, build info, and we can see, we can see these op codes in the build info, we can do a command F or Control F for opcodes.

7048
11:53:32.991 --> 11:53:36.539
We can see op codes for different contracts.

7049
11:53:36.539 --> 11:53:39.891
These op codes represent what the machine code is doing.

7050
11:53:39.891 --> 11:53:46.302
And they represent how much computational work it takes to actually run our code and do stuff with our code.

7051
11:53:46.302 --> 11:53:49.314
The way that gas is actually calculated is by these opcodes.

7052
11:53:49.314 --> 11:53:50.953
There are a couple of lists here.

7053
11:53:50.953 --> 11:53:53.656
But here's one that I'm going to use this EVM opcodes.

7054
11:53:53.656 --> 11:53:57.777
And again, there's a link to this in the GitHub repo associated with this lesson.

7055
11:53:57.777 --> 11:54:03.362
Well, if we scroll down, we can see exactly how much it costs for each one of these op codes.

7056
11:54:03.428 --> 11:54:20.412
So for example, anytime we add, it costs three gas, anytime we multiply, that's five gas, subtracting three gas, we have all of these op codes that cost different amounts of gas in in our functions, here's kind of a sample contract.

7057
11:54:20.412 --> 11:54:24.828
If we're doing adding, anytime we add it's going to cost three gas.

7058
11:54:24.828 --> 11:54:29.858
Anytime we save to memory, it's going to cost gas from some other opcodes.

7059
11:54:29.858 --> 11:54:33.566
These op codes combined show us how much gas we actually use.

7060
11:54:33.566 --> 11:54:41.561
Now, let's look at a lot of these op codes and how much they cost three 510, three, three, balance is 700.

7061
11:54:41.561 --> 11:54:45.252
So getting the balance is is a ton of gas.

7062
11:54:45.252 --> 11:54:46.444
Let's keep going.

7063
11:54:46.444 --> 11:54:52.028
Getting the sides of an Accounts code is a lot of gas copying and accounts code into memory.

7064
11:54:52.028 --> 11:55:06.250
But oh my goodness, what is this save word to storage costs a ton of gas that is 20,000 gas and s load load word from storage cost 800 gas.

7065
11:55:06.250 --> 11:55:14.261
These are two of the most important opcodes s load and s store which stands for storage load and storage store.

7066
11:55:14.261 --> 11:55:19.234
Anytime one of these op codes fires, we're spending 800 or 20,000.

7067
11:55:19.234 --> 11:55:23.615
You know, there's a big asterisk there because that can change a lot.

7068
11:55:23.615 --> 11:55:28.348
But we're spending a ton of gas anytime we work with storage as developers.

7069
11:55:28.348 --> 11:55:54.991
Anytime we work with some stuff in storage, we want to go boy, this is about to cost me a lot of gas and the best convention or making sure we know that we're working with a stored variable and we're about to spend a lot of gas is to append an S underscore right before them which stands for storage right So we're saying address to amount funded is going to be a storage variable wonders is going to be a storage variable.

7070
11:55:54.991 --> 11:55:57.479
Owner is not going to be a storage variable.

7071
11:55:57.479 --> 11:55:58.229
It's immutable.

7072
11:55:58.229 --> 11:56:01.515
The best practice for immutable variables is prefixing.

7073
11:56:01.515 --> 11:56:05.877
It with an I underscore constant values are also not in storage.

7074
11:56:05.877 --> 11:56:11.445
So for constant values, we want to keep them capslock, like that aggregator v3 interface public price feed.

7075
11:56:11.445 --> 11:56:14.329
Yep, you know what that is going to be a storage variable.

7076
11:56:14.329 --> 11:56:16.618
So we want to append an S underscore with it.

7077
11:56:16.618 --> 11:56:22.074
So we're going to do a little bit more refactor, we've appended these appropriately to update everything.

7078
11:56:22.074 --> 11:56:30.782
So instead of owner, it's going to be I underscore owner, and as a developer will read this, and we'll go ah, this is going to be much cheaper than a regular variable.

7079
11:56:30.782 --> 11:56:31.683
Okay, that's great.

7080
11:56:31.683 --> 11:56:33.106
I'm going to work with this.

7081
11:56:33.106 --> 11:56:35.481
This I underscore owner for my modifier.

7082
11:56:35.481 --> 11:56:36.042
Awesome.

7083
11:56:36.042 --> 11:56:40.534
Is owner anywhere else in here? Okay, right in the constructor.

7084
11:56:40.534 --> 11:56:43.286
I own underscore owner is message dot sender.

7085
11:56:43.286 --> 11:56:44.857
Price feed is a storage variable.

7086
11:56:44.857 --> 11:56:53.357
We should as developers, we should see the s underscore when reading this and go, Okay, we're spending a lot of gas to store this.

7087
11:56:53.429 --> 11:56:53.866
Perfect.

7088
11:56:53.866 --> 11:56:54.616
Okay, great.

7089
11:56:54.616 --> 11:56:55.678
Let's keep going.

7090
11:56:55.678 --> 11:56:56.053
Great.

7091
11:56:57.429 --> 11:56:58.095
the owners.

7092
11:57:01.429 --> 11:57:14.842
In VS code? If you do Command F, or Ctrl, F, and you hit this little down arrow, you can actually find and replace all of these address to amount funded with s underscore address to Mt funded.

7093
11:57:14.842 --> 11:57:16.014
Hit it like that.

7094
11:57:16.014 --> 11:57:19.806
And since I updated one, I got a backspace that one no.

7095
11:57:19.806 --> 11:57:21.707
So now these are all updated.

7096
11:57:21.707 --> 11:57:24.300
Let's do the same thing with s funders.

7097
11:57:24.300 --> 11:57:25.848
Let's update everywhere.

7098
11:57:25.848 --> 11:57:27.784
It has funders just to be s funders.

7099
11:57:27.784 --> 11:57:29.332
And we probably doubled up here.

7100
11:57:29.430 --> 11:57:30.180
Yep.

7101
11:57:30.430 --> 11:57:31.219
Let's undo that.

7102
11:57:31.219 --> 11:57:33.166
We already updated all the AI owners.

7103
11:57:33.430 --> 11:57:35.200
now it's updated all the price feeds.

7104
11:57:36.430 --> 11:57:38.365
feed, we'll update it with ES price feed.

7105
11:57:39.430 --> 11:57:40.414
doubled up right here.

7106
11:57:40.414 --> 11:57:41.304
So we'll undo that.

7107
11:57:41.304 --> 11:57:41.866
Okay, great.

7108
11:57:42.430 --> 11:57:47.938
we've updated everything in here, we can scroll down and we can oops, sorry, doubled up there too.

7109
11:57:47.938 --> 11:57:48.344
Sorry.

7110
11:57:48.344 --> 11:57:57.362
We can we can green through our code and go okay, where are we reading and writing to storage way more often than we probably need to.

7111
11:57:57.430 --> 11:58:05.085
And that's when we get to this withdrawal function, which seems rather suspect to reading and writing to storage a lot.

7112
11:58:05.085 --> 11:58:07.495
So let's take a look at what we're doing here.

7113
11:58:07.495 --> 11:58:12.160
Okay, so first of all, I can see that we're doing a for loop here.

7114
11:58:12.160 --> 11:58:17.230
And every time we do a for loop, we're just constantly looping through all of this code.

7115
11:58:17.230 --> 11:58:35.643
Every single time we're doing a little compare option here we're saying, okay, is our funder index less than s funders dot length? S funders dot length, this means the longer our funders array is, the more times we're going to be reading from storage, that's incredibly expensive.

7116
11:58:35.643 --> 11:58:44.591
We're also recalling this, oh my goodness, we're reading from storage a lot and saving it to this memory variable, and then updating our storage variable with it.

7117
11:58:44.591 --> 11:58:44.784
Wow.

7118
11:58:44.784 --> 11:58:52.912
So we're reading from storage a ton here, and we're reading from storage a ton here, okay, then we have to reset our funders array, there's really no way around it.

7119
11:58:52.912 --> 11:58:59.881
And that's pretty much it for our reading and writing to storage, we could probably create a withdrawal function, that's a lot cheaper.

7120
11:58:59.881 --> 11:59:06.065
So let's go ahead and create a function called cheaper withdraw, function, cheaper withdraw.

7121
11:59:06.065 --> 11:59:12.931
That's going to take what we've just learned and make a cheaper withdraw, that's much more gas efficient.

7122
11:59:12.931 --> 11:59:15.366
So we'll keep this public payable.

7123
11:59:15.366 --> 11:59:20.811
and have it be only owner, we're not going to change anything there.

7124
11:59:20.811 --> 11:59:26.384
But what can we do for at least this part here, we don't want to keep reading from storage here.

7125
11:59:26.431 --> 11:59:29.618
And we don't want to always have to keep reading from storage here.

7126
11:59:29.618 --> 11:59:32.641
We're like doubling up the amount of storage we're reading from.

7127
11:59:32.641 --> 11:59:42.447
So instead, what we can do, we can read this entire array into memory one time, and then read from memory instead of constantly reading from storage.

7128
11:59:42.447 --> 11:59:45.269
And that's going to make our lives a lot cheaper.

7129
11:59:45.269 --> 11:59:48.559
So we can create an address array.

7130
11:59:48.559 --> 11:59:52.481
Memory funders equals s underscore, funders.

7131
11:59:52.481 --> 12:00:06.511
And now it's going to start making sense why for arrays and strings in our functions, it makes us say, hey, is this memory is a storage? What is this? And we're telling it, we want it to be memory because memory is going to be a lot cheaper.

7132
12:00:06.511 --> 12:00:13.217
So now that we're saving it into our funders, oh, and a quick note mappings can't be in memory.

7133
12:00:13.217 --> 12:00:13.610
Sorry.

7134
12:00:13.610 --> 12:00:16.036
They're just too weird and too wacky.

7135
12:00:16.036 --> 12:00:18.742
So flooding just doesn't let you do that right now.

7136
12:00:18.742 --> 12:00:30.655
But now that we've saved our storage variable into a memory variable, we can read and write from this memory variable, much, much cheaper, and then update storage when we're all done.

7137
12:00:30.655 --> 12:00:42.075
So what we're going to do now is we're gonna say for you into V six, fund or index equals zero, and we're going to basically rewrite everything but just using this memory array.

7138
12:00:42.075 --> 12:00:42.752
instead.

7139
12:00:42.752 --> 12:00:54.522
We're gonna say funder index is less than funders dot length and instead of s funders dot length, and then we're gonna say funder index plus plus.

7140
12:00:54.522 --> 12:01:09.466
And then in here we're gonna do nearly exactly the same thing, except we're gonna say address funder equals funders, using our memory array and not s funders have funder index.

7141
12:01:09.466 --> 12:01:14.156
And then we're gonna say s address to amount funded.

7142
12:01:14.156 --> 12:01:16.449
funder equals zero.

7143
12:01:16.449 --> 12:01:30.153
So we're resetting our funders mapping here, we're using our memory variables instead, then we're going to do the same thing s underscore funders equals new address array of zero.

7144
12:01:30.153 --> 12:01:49.307
And then we're gonna do the same thing bool success, comma equals S owner, dot call value, address this balance, and we're going to send it nothing and then require success.

7145
12:01:49.307 --> 12:01:57.989
Like that actually, sorry, Iona on a sonar now that we have this function that we think is cheaper, let's go back to our test.

7146
12:01:57.989 --> 12:02:03.333
And let's run this same multi test here, but with our cheaper function.

7147
12:02:03.333 --> 12:02:08.776
So I know this can be a little bit tricky to copy, paste, but let's copy this entire massive test.

7148
12:02:08.776 --> 12:02:18.618
Let's come down here, paste it, and we'll change the name saying cheaper withdraw, testing dot that done.

7149
12:02:18.618 --> 12:02:29.718
And in here in in this giant it here, all we're going to change is we're going to change withdraw to cheaper withdraw, and the rest of the test is going to be exactly the same.

7150
12:02:29.718 --> 12:02:38.120
So with that, let's see if if we were successful in making our withdraw function cheaper with cheaper withdraw, we're gonna pull apart our terminal now.

7151
12:02:38.120 --> 12:02:43.718
And we do yarn, art hat test, which is going to run our gas estimator because it's enabled right now.

7152
12:02:43.718 --> 12:02:47.504
And of course, all of our functions have been broken because we renamed everything.

7153
12:02:47.504 --> 12:02:56.142
So we'll do a quick final replace of funders, to change funders to ask funders.

7154
12:02:56.142 --> 12:03:01.163
And then we're gonna change price feed to ask price feed.

7155
12:03:01.163 --> 12:03:05.842
And then do we have owner anywhere? We don't have owner or anywhere.

7156
12:03:05.842 --> 12:03:07.653
We need to change this one.

7157
12:03:07.653 --> 12:03:09.347
Address to amount funded.

7158
12:03:09.347 --> 12:03:10.750
Let's come in here.

7159
12:03:10.750 --> 12:03:12.734
Address to amount funded.

7160
12:03:12.734 --> 12:03:13.765
S adderstone.

7161
12:03:13.765 --> 12:03:14.717
well funded.

7162
12:03:14.717 --> 12:03:18.004
What else do we need to change price? We price feed funders.

7163
12:03:18.004 --> 12:03:19.348
Okay, I think we changed everything.

7164
12:03:19.348 --> 12:03:20.651
Alright, so let's try our test now.

7165
12:03:20.651 --> 12:03:22.032
Yarn Hardhead test.

7166
12:03:22.032 --> 12:03:23.268
All right, great.

7167
12:03:23.268 --> 12:03:25.099
Everything's passing.

7168
12:03:25.099 --> 12:03:28.908
And we ran our cheaper withdraw testing.

7169
12:03:28.908 --> 12:03:41.536
So now, if we go to our gas output here, our gas report, zoom out just a hair, we can see the difference between cheaper withdraw and withdraw, we see something really interesting.

7170
12:03:41.536 --> 12:03:47.504
Here we see our cheaper withdraw on average was actually more expensive than our regular withdraw.

7171
12:03:47.504 --> 12:03:55.183
And the reason for this is because actually, if we go to our tests are cheaper withdrawal, we only tested on the multi withdraw.

7172
12:03:55.183 --> 12:03:57.966
So we had to reset many, many more accounts.

7173
12:03:57.966 --> 12:04:01.299
But this was also technically its maximum as well.

7174
12:04:01.433 --> 12:04:08.814
And if we compare the maximum of the cheaper withdrawal, the maximum of the withdraw, it looks like the cheaper withdrawal was indeed cheaper.

7175
12:04:08.814 --> 12:04:35.100
And if we go to our hard hat dot config, and we add our API key back in, what we could even do is in our test, we could copy withdraw eath from a single funder, copy that, paste it in and just change withdraw to cheaper withdrawal, rerun it with the key and now do yarn Hardhead test, we can see exactly how many dollars we would save if we ran this on the Matic blockchain.

7176
12:04:35.100 --> 12:04:39.434
Now let's go back, we'll reopen up our gas report.

7177
12:04:39.434 --> 12:04:43.869
And we can see, in the minimum cheaper withdrawal was actually a little bit more expensive.

7178
12:04:43.869 --> 12:04:52.261
This actually does make sense because if we look at funding, if we only have to withdraw when there was one funder, well this loop only runs one time.

7179
12:04:52.261 --> 12:05:03.014
And our cheaper withdraw will do the exact same but it will have this this extra thing here of loading them all in, we see that the savings The more people our funders in our contracts.

7180
12:05:03.014 --> 12:05:06.991
So automatic, we can see we pretty much didn't save anything.

7181
12:05:06.991 --> 12:05:12.719
But if I change this one more time to eath run the test again.

7182
12:05:12.719 --> 12:05:16.671
Now we can see people withdraw saved a few cents.

7183
12:05:16.671 --> 12:05:20.950
This is how we can start optimizing our contracts will be cheaper and cheaper.

7184
12:05:20.950 --> 12:05:22.571
And this two cents was just in the average.

7185
12:05:22.571 --> 12:05:28.466
It's not even comparing the max to the max, which was a lot more gas than their averages.

7186
12:05:28.466 --> 12:05:33.885
We have just learned an absolute ton here.

7187
12:05:33.885 --> 12:05:45.967
Now, this next part is going to make some of you mad because we're going to refactor our code one more time if you don't want to refactor it and you want to leave all your tests as s underscores you absolutely can but to other users using our application.

7188
12:05:45.967 --> 12:05:53.339
Dealing with this s underscore is a little Little bit gross and actually can make our code a little bit more confusing for those who use it.

7189
12:05:53.339 --> 12:05:57.202
And additionally, right now all of our state variables are public.

7190
12:05:57.202 --> 12:06:01.193
And actually internal variables and private variables are also cheaper gas wise.

7191
12:06:01.193 --> 12:06:07.181
And we don't need to make every single one of our variables public, because anybody can read them off the chain anyways.

7192
12:06:07.181 --> 12:06:20.373
So one more refactoring that we're going to do is we're actually going to set the visibility of these to private or internal, based off of whether or not they need to be private or internal, and then we'll create getters at the bottom of our function here.

7193
12:06:20.435 --> 12:06:32.231
So minimum USD, we can keep this public because we want other people to know what the minimum USD of our contract is, without having to go right through storage, the owner of our contract isn't important for others to know or other contracts to know.

7194
12:06:32.231 --> 12:06:39.265
So we can go ahead and make this private, and then at the bottom at a function get owner.

7195
12:06:39.265 --> 12:06:54.735
That's a public view that returns I owner, turns address as funders, as funders can be private as well.

7196
12:06:54.735 --> 12:07:18.028
So at the bottom, we're gonna say function, get funder, and we're going to pass a un 236 index, public U, turns, address, return as funders of index, the address to Mt funded can also be private.

7197
12:07:18.028 --> 12:07:25.145
So the bottom, we're going to create function, get address to amount funded.

7198
12:07:25.145 --> 12:07:34.516
And this is going to take an address under the public view returns, you went to 56.

7199
12:07:34.516 --> 12:07:43.075
And we're going to return amount funded of the funder did this one we did this one, we did this one.

7200
12:07:43.075 --> 12:07:46.774
And then price feed, function get price feed.

7201
12:07:46.774 --> 12:07:56.813
This is going to be public view as well, that returns aggregate tour of the three interface that's going to return so I'm just gonna price feed.

7202
12:07:56.813 --> 12:07:57.255
Oh, okay.

7203
12:07:57.255 --> 12:08:07.736
The reason why we did that is because we want to have this s underscore so that we as developers can know, okay, this is a storage variable, I want to be very careful about how I interact with this.

7204
12:08:07.736 --> 12:08:12.078
But we don't want people who interact with our code to have to deal with this s stuff.

7205
12:08:12.078 --> 12:08:16.274
And we want to give them an API that makes sense, and that it's easy and readable.

7206
12:08:16.274 --> 12:08:19.225
So we add these getter functions at the bottom to do that.

7207
12:08:19.225 --> 12:08:30.388
And also changing the visibility can save us some gas in the long run as well, because we're gonna be calling from private variables or internal variables, which are cheaper gas wise, of course, we do need to upgrade our test one more time.

7208
12:08:30.388 --> 12:08:34.805
And like I said, if you want to just leave them with the S underscores, that's absolutely fine.

7209
12:08:34.805 --> 12:08:48.029
So s underscore price feed is now going to be replaced with get price feed, s underscore amount to fund it is going to be now replaced with get address to amount funded.

7210
12:08:48.029 --> 12:08:54.569
For now going to change SW, underscore funders, to get funder.

7211
12:08:54.569 --> 12:09:00.029
We're going to change Iona, there's nowhere else in their mind, we don't need to change them.

7212
12:09:00.029 --> 12:09:01.029
And I think that was everything.

7213
12:09:01.029 --> 12:09:06.151
Let's just look for s underscore, we don't see it, I underscore, we don't see that either.

7214
12:09:06.151 --> 12:09:11.156
Let's just run our tests one more time to make sure we refactor that correctly.

7215
12:09:11.156 --> 12:09:13.911
And it looks like we did awesome.

7216
12:09:13.911 --> 12:09:16.148
Okay, we have just learned a ton.

7217
12:09:16.148 --> 12:09:18.161
we've refactored our code a ton.

7218
12:09:18.161 --> 12:09:21.469
And everything is starting to look really, really good here.

7219
12:09:21.469 --> 12:09:24.049
One more gas optimization we could make.

7220
12:09:24.049 --> 12:09:32.647
And an optimization for errors as well is we could update all of our requires to instead be to instead be reverts.

7221
12:09:32.647 --> 12:09:42.898
Because without requires, we're actually storing this massive string, this massive array of text on chain, these error codes are much cheaper.

7222
12:09:42.898 --> 12:09:43.667
But that's optional.

7223
12:09:43.667 --> 12:09:44.643
If you want to do that.

7224
12:09:44.643 --> 12:09:49.826
The whole reason we were doing this is we were going through the style guide in updating things here.

7225
12:09:49.826 --> 12:10:00.288
So we have public internal private, and the bottom is going to be our view slash pure functions, which they are they're just all these getters that we just added.

7226
12:10:00.437 --> 12:10:02.130
So now our style in here looks good.

7227
12:10:03.437 --> 12:10:05.402
gas, we've learned a lot about storage.

7228
12:10:06.437 --> 12:10:12.216
Let's do a quick refresher on everything we just learned because we went through a lot right there.

7229
12:10:12.216 --> 12:10:15.737
And like I said, this is one of the harder parts of this course.

7230
12:10:15.737 --> 12:10:22.237
Any variable that is changeable that we want to persist across contract executions and transactions.

7231
12:10:22.237 --> 12:10:27.690
We save to a giant array called storage this array is sequentially indexed starting at zero.

7232
12:10:27.690 --> 12:10:34.211
So the first variable the first value that we have in our contract gets stored to the zero with index.

7233
12:10:34.211 --> 12:10:38.008
The next one gets stored to one and so on and so forth.

7234
12:10:38.008 --> 12:10:55.438
Dynamic arrays and mappings and other dynamically sized objects use specific hashing function that you can find in the documentation to determine where the elements of those dynamic Data Structures go memory variables, constant variables and immutable variables don't go in storage.

7235
12:10:55.438 --> 12:11:08.919
And one of the main reasons talking about storage is so important is because the op codes for loading from storage and for reading from storage and writing to storage are incredibly gas expensive.

7236
12:11:08.919 --> 12:11:13.771
So in everywhere we can we want to reduce the amount that we read and load from storage.

7237
12:11:13.771 --> 12:11:19.904
And it's one of the easiest ways to save gas and try to optimize our code to be gas efficient.

7238
12:11:19.904 --> 12:11:23.067
Like I said, some of this gas stuff can be a little tricky and a little bit confusing.

7239
12:11:23.067 --> 12:11:25.341
So if you don't get this right away, it's okay.

7240
12:11:25.438 --> 12:11:26.295
It is totally fine.

7241
12:11:28.438 --> 12:11:35.861
like, What is he talking about? Like I said, this is some of the more advanced stuff it'll come, the more you work with solidity, and the more you work with everything here.

7242
12:11:35.861 --> 12:11:37.126
So don't let it stress you out.

7243
12:11:37.126 --> 12:11:38.994
Don't let it stop you from continuing.

7244
12:11:38.994 --> 12:11:41.995
You're doing fantastic being here.

7245
12:11:41.995 --> 12:11:42.683
So far.

7246
12:11:42.683 --> 12:11:46.647
We've written some really good unit tests.

7247
12:11:46.647 --> 12:11:49.469
Let's now write some staging tests.

7248
12:11:49.469 --> 12:11:53.728
And these are the tests that we can use on an actual test net.

7249
12:11:53.728 --> 12:12:01.871
This is a test that we're basically going to run after we've deployed some code just to see if everything is working approximately the way we want it to.

7250
12:12:01.871 --> 12:12:03.882
So let's go ahead and we'll create a new file here.

7251
12:12:03.882 --> 12:12:06.326
We'll call it fund me.

7252
12:12:06.326 --> 12:12:09.659
Dot staging dot test, dot j s.

7253
12:12:09.659 --> 12:12:13.628
And it's going to look really similar to what we were just doing with our unit tests.

7254
12:12:13.628 --> 12:12:15.929
And we're going to assume this is on a test net.

7255
12:12:15.929 --> 12:12:27.930
So these are tests that we're going to run, right before we deploy this to a main net, this is the last step in your development journey, we want to just make sure that everything is working approximately correctly on an actual test net.

7256
12:12:27.930 --> 12:12:41.554
So what we're gonna do is we're gonna do the same thing describe, fund me, and I'm gonna go a little quick through these tests here, because we've basically written this type of test before, so we're gonna say before each, it's gonna be an async.

7257
12:12:41.554 --> 12:12:42.419
function.

7258
12:12:42.419 --> 12:12:46.403
We're gonna do the same thing as our unit tests.

7259
12:12:46.403 --> 12:12:56.989
So we're gonna have a Funmi variable, we're gonna have our let Deployer, we're gonna have our constant send value equals ethers.

7260
12:12:56.989 --> 12:12:57.739
utils.

7261
12:12:57.739 --> 12:13:03.596
rs ether of one, and in here, we're going to do const.

7262
12:13:03.596 --> 12:13:05.262
Get named accounts.

7263
12:13:05.439 --> 12:13:18.105
Equals require hardhats, we're going to say deployer equals weight, get named accounts, we're going to wrap this up, dot Deployer.

7264
12:13:18.105 --> 12:13:25.216
We're gonna say fun me equals await ethers dot get contract.

7265
12:13:25.439 --> 12:13:38.045
And me, comma, we're going to connect it to our Deployer, we're not going to deploy this, we're not going to do any fixtures like we did in our unit tests, because in our staging tests, we're assuming that it's already deployed here.

7266
12:13:38.045 --> 12:13:49.852
And we also don't need a mock because on a staging, we're assuming that we're on a test net, now we can actually wrap this whole thing to make sure that we're on a test net by using our helper config.

7267
12:13:49.852 --> 12:13:58.032
And looking for our development chains, we can say we only want to run our describe bit if we're on a development chain.

7268
12:13:58.032 --> 12:14:01.117
So first, we'll say const.

7269
12:14:01.117 --> 12:14:08.891
Development chains equals require, we'll pull that that helper config in.

7270
12:14:08.891 --> 12:14:14.507
And we'll say, development chains dot includes network dot name.

7271
12:14:14.507 --> 12:14:27.358
And we'll basically will say if developer chains that includes network dot name, we're going to skip and we can actually skip using this, we're going to use something called a ternary operator is basically like a one liner if statement.

7272
12:14:27.358 --> 12:14:29.790
And you can think of this as a special type of F.

7273
12:14:29.790 --> 12:14:32.832
I've got a link to this and the GitHub repo associated with this course.

7274
12:14:32.832 --> 12:14:36.725
And here's some JavaScript documentation, showing it in action.

7275
12:14:36.725 --> 12:14:39.797
You say, Okay, return is member.

7276
12:14:39.797 --> 12:14:43.225
And if it's true, have it be $2.

7277
12:14:43.440 --> 12:14:45.100
Otherwise have a B $10.

7278
12:14:45.100 --> 12:14:47.062
And that's pretty much it.

7279
12:14:47.440 --> 12:14:58.226
another way of thinking about is like, you say, let variable equals true, then we could say, let some var equals variable question.

7280
12:14:58.226 --> 12:15:02.455
Yes? Or no? Some var will end up being Yes.

7281
12:15:02.455 --> 12:15:04.472
Because variable is true.

7282
12:15:04.472 --> 12:15:07.593
If variable was false than some var would be no.

7283
12:15:07.593 --> 12:15:14.159
So it's literally saying, If variable, if variable, then some var equals yes.

7284
12:15:14.159 --> 12:15:14.773
Else.

7285
12:15:14.773 --> 12:15:20.423
Some var equals no, these lines are literally the exact same thing.

7286
12:15:20.423 --> 12:15:22.079
This one is just a little bit more succinct.

7287
12:15:22.079 --> 12:15:22.915
That's really it.

7288
12:15:22.915 --> 12:15:24.588
So that's what this operator does.

7289
12:15:24.588 --> 12:15:27.524
We're gonna say development chains that includes network dot name.

7290
12:15:27.524 --> 12:15:34.725
So if our network is a development chain, which we're going to import network as well from hard hat and ethers as well.

7291
12:15:34.725 --> 12:15:45.265
Then we're going to do describe that skipped and this tells our test to just skip this whole describe, and then we're going to put this little colon here thing and save and boom.

7292
12:15:45.265 --> 12:16:01.566
So now we're only going to run this if we're not On a development chain, and we want to take this exact same syntax, we'll go to our unit testing here, and we'll do the exact same thing, we'll paste it will have this be the opposite by putting a little knot here, sticking that colon in.

7293
12:16:01.566 --> 12:16:07.801
So now, our unit tests only run on development chains in our staging tests, only run on test nets.

7294
12:16:07.801 --> 12:16:08.325
Perfect.

7295
12:16:08.325 --> 12:16:14.012
That's what we want, allows people to fund and own and withdraw.

7296
12:16:14.012 --> 12:16:25.474
And this will be an async function, of course, and we probably can make this pretty robust, but we'll just say await, fund me dot fund is going to be send a value.

7297
12:16:25.474 --> 12:16:30.155
And then we'll say a weight on me dot withdraw.

7298
12:16:30.155 --> 12:16:33.583
CERT equals require try.

7299
12:16:33.583 --> 12:16:48.114
Now we'll do kind of a lame final one, we'll say const ending balance equals a weight on me dot provider dot get balance, fund me dot address.

7300
12:16:48.114 --> 12:16:53.118
And then we'll say assert dot equals ending balance.

7301
12:16:53.118 --> 12:17:02.405
to string, comma zero as a string, we're only going to run this on a test net, I'm just going to give you this one more run to show you it in action.

7302
12:17:02.405 --> 12:17:12.141
Feel free to skip this part again, because we are going to be working with a test net, I'm going to run yarn, hard hat deploy dash test network Rinkeby.

7303
12:17:12.141 --> 12:17:16.241
And it's going to run through our deploy.

7304
12:17:16.241 --> 12:17:33.942
And after it's all deployed, we're going to run our staging tests to make sure that everything works even with a price feed on a real test net, and I need to do const development chains equals require dot dot slash dot dot slash helper heart config.

7305
12:17:33.942 --> 12:17:40.924
Now for run yarn, hard hat test, we'll see just our unit tests get run.

7306
12:17:40.924 --> 12:17:49.312
But if we run yarn hard to test dash dash network Rinkeby, we're not going to run nine tests, we're only going to run our singular staging test.

7307
12:17:49.312 --> 12:17:55.526
And of course, this is going to be a lot slower, because we're on a test net.

7308
12:17:55.526 --> 12:18:03.651
Net will we write written all these tests, we can write a couple of scripts.

7309
12:18:03.651 --> 12:18:23.330
And then we're going to finish this out by pushing this up to GitHub making this our first smart contract GitHub repository, when it comes to the blockchain, when it comes to smart contracts, interacting with community interacting with open source being a part of GitHub, or git labs or whatever Git hosting service you're using is essential to being successful here.

7310
12:18:23.330 --> 12:18:24.775
So let's write our scripts.

7311
12:18:24.775 --> 12:18:28.114
And then we'll upload this to GitHub to start building our portfolio.

7312
12:18:28.114 --> 12:18:33.196
So first, we're going to create a script to interact with our code called fund dot j s.

7313
12:18:33.196 --> 12:18:36.242
And this is going to be really similar to our tests.

7314
12:18:36.242 --> 12:18:37.652
And this way, in the future.

7315
12:18:37.652 --> 12:18:46.323
If we want to just fund one of our contracts very quickly, we can just run this and we can do it, we're gonna do the same thing that we've been doing, we're gonna do an async function main.

7316
12:18:46.323 --> 12:18:51.204
And down below, I'm just going to copy paste this because we're going to be copy pasting in a lot.

7317
12:18:51.204 --> 12:18:54.156
We're going to paste this little syntax here.

7318
12:18:54.156 --> 12:18:58.308
So let's write a script that allows us to fund our contracts.

7319
12:18:58.308 --> 12:19:13.073
So first, we're going to need const get named accounts just like in our tests, equals require arhat we're gonna say const Deployer.

7320
12:19:13.073 --> 12:19:18.276
Equals await yet named accounts, just like that.

7321
12:19:18.276 --> 12:19:26.693
And then we're gonna say const fund me equals await ethers dot get contract.

7322
12:19:26.693 --> 12:19:29.146
From funding comm a Deployer.

7323
12:19:29.146 --> 12:19:46.443
Literally, almost exactly the same as our tests, then we'll do a little console dot log funding contract that that and we'll do const transaction response equals await funding dot fund.

7324
12:19:46.443 --> 12:19:55.849
And for the value, we'll do something like ethers dot utils, that parse ether of 0.

7325
12:19:55.849 --> 12:20:00.943
1 or something, whatever you want to do here, we of course, need to import ethers, which it looks like we already have.

7326
12:20:00.943 --> 12:20:06.026
We'll do await transaction response dot wait for one transaction.

7327
12:20:06.026 --> 12:20:19.376
And then we'll do console dot log funded, we can run this little script by running yarn, RT head node will run a local node with all of our contracts deployed.

7328
12:20:19.376 --> 12:20:29.246
We'll see if our script looks okay by running yarn, hard hat run scripts fund dot j s dash dash network localhost.

7329
12:20:29.246 --> 12:20:32.278
And it looks like it's funding Great.

7330
12:20:32.443 --> 12:20:36.765
Let's now write a withdraw script withdraw that J S.

7331
12:20:37.443 --> 12:20:43.120
can even leave our localhost Node running because we're going to withdraw the funds that we've just funded it with.

7332
12:20:43.120 --> 12:20:45.720
So we're going to do the exact same setup here.

7333
12:20:45.720 --> 12:21:03.395
We can even copy this main bit to our withdraw Ah, the top will do async function main will say const deployer equals await, get named accounts, which wow, I hit enter and my VS code auto imported it, that's pretty nice.

7334
12:21:03.444 --> 12:21:08.116
Maybe yours will too, maybe won't if it won't, you just gotta write it out or copy paste from the other one.

7335
12:21:08.116 --> 12:21:13.824
And then we'll do cars Funmi equals await ethers dot get contract on me, course.

7336
12:21:13.824 --> 12:21:16.300
And this is going to be the exact same.

7337
12:21:16.300 --> 12:21:35.027
Now we're going to do console dot log funding data dot, we'll say const transaction response equals await on v dot withdraw, await transaction response dot wait one, then console dot log.

7338
12:21:35.027 --> 12:21:36.377
Got it? Back.

7339
12:21:36.377 --> 12:21:47.321
And we can test this out by running yarn, hard hit run scripts, withdraw dash dash network localhost, we'll see if this works.

7340
12:21:47.321 --> 12:21:50.391
And cool and our script is working.

7341
12:21:50.391 --> 12:21:53.777
Fantastic crushed out two scripts incredibly quickly.

7342
12:21:53.777 --> 12:22:00.088
And now we have a way to easily interact with our code with our contracts if we want to via a script.

7343
12:22:00.088 --> 12:22:09.056
There's actually one more thing I want to show you before we actually work and we push all this wonderful code up to GitHub in our package dot JSON.

7344
12:22:09.056 --> 12:22:21.037
I've shown you a little bit of this before, but we can add this scripts section to make our lives a lot easier and condense all these long tests into a yarn script for us.

7345
12:22:21.037 --> 12:22:31.559
So usually, what you'll see in common package dot JSON is you'll see a list of these in here for people to look and just automatically run, one of the most common ones is going to be test.

7346
12:22:31.559 --> 12:22:35.335
And to run test, we're going to do yarn, hard hat test.

7347
12:22:35.335 --> 12:22:42.805
So now instead of running yarn, Hardhead test, someone can just come to your package once this is saved and just run yarn test.

7348
12:22:42.805 --> 12:22:49.953
And this will grab this test from your script section and it will run yarn heart at test and Bada bing, bada boom, okay, cool.

7349
12:22:49.953 --> 12:23:01.880
What else do we probably probably want to do in here? Well, we probably want to have a test staging section that'll run yarn Hardhead test dash dash, network Rinkeby.

7350
12:23:01.880 --> 12:23:03.208
I'm not going to run that.

7351
12:23:03.208 --> 12:23:07.945
But that's probably something we want to have in here, we're probably going to want some linting.

7352
12:23:07.945 --> 12:23:11.087
So we showed you briefly that linting thing.

7353
12:23:11.087 --> 12:23:16.361
So we'll have a yarn lint, which will just run yarn, sole hint.

7354
12:23:16.445 --> 12:23:20.122
And then we'll just have it so hence the contracts folder.

7355
12:23:20.445 --> 12:23:22.445
anything that starts out soul.

7356
12:23:24.445 --> 12:23:32.195
it'll run soul hint, and all of our code here and it'll give us some warnings here, which we can pretty much all ignore.

7357
12:23:32.195 --> 12:23:39.887
And Solon actually has an auto fix and auto fix that we can add, by doing yarn lint fix, we'll say yarn.

7358
12:23:39.887 --> 12:23:43.315
So hint, contracts slash start out.

7359
12:23:43.315 --> 12:23:45.831
So we'll do dash dash fix.

7360
12:23:45.831 --> 12:23:52.169
So now we run yarn, lint fix, it'll auto fix, which there's nothing to auto fix.

7361
12:23:52.169 --> 12:23:53.159
So nothing happens.

7362
12:23:53.159 --> 12:23:54.587
But it's good to have anyways.

7363
12:23:54.587 --> 12:24:05.430
And then we can do our formatter, we're just going to format our code format, that which will do yarn, prettier, dash dash write to, and we'll just do a period to do everything.

7364
12:24:05.430 --> 12:24:07.612
And then we can just do yarn format.

7365
12:24:07.612 --> 12:24:13.833
And it's gonna fix all of our, it's going to fix everything for us, which is great.

7366
12:24:13.833 --> 12:24:16.547
And then we finally can have coverage.

7367
12:24:16.547 --> 12:24:25.446
By running yarn hardhat coverage, now we can just run yarn coverage, will give us this wonderful little coverage report.

7368
12:24:25.446 --> 12:24:25.979
Awesome.

7369
12:24:25.979 --> 12:24:28.245
So our packages looking fantastic.

7370
12:24:28.446 --> 12:24:30.463
Maybe we'll even come into package json.

7371
12:24:31.446 --> 12:24:31.890
name.

7372
12:24:31.890 --> 12:24:34.667
We'll call this hard hat.

7373
12:24:38.446 --> 12:24:39.571
is going to be your name.

7374
12:24:41.446 --> 12:24:45.334
and we'll give it a version in here.

7375
12:24:45.334 --> 12:24:45.889
of 1.

7376
12:24:45.889 --> 12:24:47.666
0 Point Oh, oops.

7377
12:24:48.446 --> 12:24:51.253
let's do icons instead of spaces.

7378
12:24:53.446 --> 12:24:54.906
We're not using ES lint.

7379
12:24:57.446 --> 12:24:59.913
and we could delete the yarn dot lock and reinstall.

7380
12:25:00.446 --> 12:25:00.867
whatever.

7381
12:25:00.867 --> 12:25:02.972
We don't have a readme, but that's okay.

7382
12:25:03.446 --> 12:25:11.736
want to go back, like I said, go check out that best readme template and go update your READMEs to make them look as awesome as this, you can do that as well.

7383
12:25:11.736 --> 12:25:16.334
But other than that, we've got an awesome code repo here.

7384
12:25:16.334 --> 12:25:23.429
What do we want to do with it? Well, we've been playing around with GitHub so much, we've been looking at all these good hubs.

7385
12:25:23.429 --> 12:25:28.612
It's time for us to join GitHub with our own with our first repository.

7386
12:25:28.612 --> 12:25:39.981
Let's go ahead and let's make this happen in the lesson seven full blockchain solidity course, yes, there is a link to this GitHub Quickstart that we're going to follow to set up our first repository.

7387
12:25:39.981 --> 12:25:47.836
This is going to be the moment where you are starting to build your portfolio building and GitHub is borderline crucial for your development journey.

7388
12:25:47.836 --> 12:25:55.007
It's going to be your portal folio, it's going to be where you say, Hey, look at all the cool products that I'm engaging with, that I'm working with, that I'm participating in.

7389
12:25:55.007 --> 12:26:00.603
If you've already made GitHub before, I highly recommend you still push this up to GitHub as proof that you've done it.

7390
12:26:00.603 --> 12:26:04.161
And then you can also tweet it at me saying, hey, look how far I've gotten.

7391
12:26:04.161 --> 12:26:22.947
Look where I've done, look at how fantastic I'm learning smart contracts, and be incredibly excited about now, this quickstart will walk you through creating a repository, creating a branch and teaching all this stuff, we're going to follow the instructions from the GitHub documentation about adding locally hosted code to GitHub, we already have a project, and we're just pushing it up.

7392
12:26:22.947 --> 12:26:52.259
Since the Windows users are using WsL, you can just follow the Mac or Linux instructions here, the first thing that we're going to do is in your GitHub profile, or your GitHub login, we're gonna hit this little plus thing, and hit new repository, you can call this whatever you want, let's call it hard hat, fund me b code camp, you can put a description if you want, learning from recode camp, and Patrick, about smart contracts.

7393
12:26:52.447 --> 12:26:56.990
We'll make it public because we want other people to see you being fantastic and learning smart contracts.

7394
12:26:56.990 --> 12:27:00.266
We'll leave this blank, and we'll hit Create repository.

7395
12:27:00.266 --> 12:27:02.528
Now, this is our public code repository.

7396
12:27:02.528 --> 12:27:08.184
This is our first one, if you've done these already, this will be your first smart contract one.

7397
12:27:08.184 --> 12:27:23.056
It even has some instructions in here, too, that teaches us how to create a new repository from the command line, you can follow this if you want, or you can follow like so the first thing we're going to do is we're going to initialize a git branch.

7398
12:27:23.056 --> 12:27:26.395
And from way back when you should already have Git installed.

7399
12:27:26.448 --> 12:27:29.930
Remember, you can check by running git dash dash version like this.

7400
12:27:29.930 --> 12:27:33.555
Git is a little different from GitHub, Git is known as version control.

7401
12:27:33.555 --> 12:27:39.706
And it allows us to make changes to our code, but keep a history of all the code changes that we've made.

7402
12:27:39.706 --> 12:27:44.585
GitHub is a place where we can push all of these changes and keep track of all of our code.

7403
12:27:44.585 --> 12:27:48.026
So the first thing that we're going to do is we're going to create a new branch.

7404
12:27:48.026 --> 12:27:51.743
And I'm not going to explain Git and working with Git too, too deeply.

7405
12:27:51.743 --> 12:27:57.792
But if you want to learn about Git Free Code Camp, of course, has a video on Git and GitHub for beginners.

7406
12:27:57.792 --> 12:28:05.781
So we're going to create this new branch with git init dash b main, now your Visual Studio code might automatically start formatting some stuff.

7407
12:28:05.781 --> 12:28:06.747
And if it does, that's great.

7408
12:28:06.747 --> 12:28:08.431
And if it doesn't, don't worry about it.

7409
12:28:08.431 --> 12:28:22.605
But what you'll see here on the left is you'll see some stuff is green, and some stuff is gray, open back up that dot Git ignore, you'll see that all the gray stuff is the stuff that we have in this dot Git ignore this is intentional, this is what we want.

7410
12:28:22.605 --> 12:28:27.512
This is just some some highlighting saying, hey, this green stuff is what you're working with on GitHub.

7411
12:28:27.512 --> 12:28:30.227
And this gray stuff is what you're not working with and GitHub.

7412
12:28:30.227 --> 12:28:31.040
And that's what we want.

7413
12:28:31.040 --> 12:28:43.988
You don't need to push artifacts, or cash or coverage or node modules, people can install and compile on their own machines, we definitely don't want to push up our Dotty and V if we're using a Dotty and V.

7414
12:28:43.988 --> 12:28:48.601
And we don't really need to push up coverage dot JSON, either the rest of this we do.

7415
12:28:48.601 --> 12:29:13.913
So now what's next, after we initialize our main branch, you now should be able to run git status in your terminal and see this huge red output of all these things that are untracked, and we don't have any commits for, what we can do now is we can stage all of our code with git add period, and then commit it with Git commit, we're going to run these one at a time instead of together.

7416
12:29:13.913 --> 12:29:24.311
Before I run git add, I'm going to add deployments to this list too, because GitHub doesn't really need to know about all the different deployments I make, especially when I make a ton of deployments to my local hosts, they don't need to know.

7417
12:29:24.311 --> 12:29:29.370
So we're going to add that to, then we're going to run git add dot.

7418
12:29:29.449 --> 12:29:39.017
And if we do a git status, now, we can see all of our code has been staged for being committed for being a part of this history of our code.

7419
12:29:39.017 --> 12:29:46.367
And then take a quick look at all these files and make sure your dot E and V file is not and never in here.

7420
12:29:46.449 --> 12:30:05.234
So now we're going to run git commit dash m and then this message for our commit, okay, so we'll run git commit dash m, we can say, initial commit, or whatever you want in this message here, first commit, initial commit, who cares, and it's gonna say, create mode, blah, blah, blah, for all of these files.

7421
12:30:05.234 --> 12:30:09.855
And if we do git status, now, it's blank on branch main, nothing to commit.

7422
12:30:09.855 --> 12:30:11.754
And then you might get something like this.

7423
12:30:11.754 --> 12:30:15.489
If you've never worked with Git before your name and email were added automatically.

7424
12:30:15.489 --> 12:30:17.563
We're a little bit confused here.

7425
12:30:17.563 --> 12:30:20.120
We'll talk about this in just a second.

7426
12:30:20.120 --> 12:30:24.629
So next, what we can do is we're actually going to copy the URL of our GitHub repo.

7427
12:30:24.629 --> 12:30:29.606
So you can grab that just by copying here or right at the top, that URL right there.

7428
12:30:29.606 --> 12:30:33.110
And what we're going to do is we're going to add this as a remote repo.

7429
12:30:33.110 --> 12:30:33.836
To do that.

7430
12:30:33.836 --> 12:30:39.932
We'll do git remote add, and we'll give this remote repo a name.

7431
12:30:39.932 --> 12:30:40.496
For us.

7432
12:30:40.496 --> 12:30:44.788
We'll say origin and then we'll paste that URL there.

7433
12:30:44.788 --> 12:30:48.314
We're now saying the the origin remote repo is good.

7434
12:30:48.450 --> 12:30:57.417
Gonna be at this URL, we run git remote dash v, we can see that the origin repo for fetching is at this branch.

7435
12:30:57.417 --> 12:31:00.926
And the origin repo for pushing is also at this branch.

7436
12:31:00.926 --> 12:31:05.678
So when we want to get new code, a fetch code will fetch it from here.

7437
12:31:05.678 --> 12:31:09.116
And if we want to push code up, we want to give code to the GitHub.

7438
12:31:09.116 --> 12:31:10.873
We'll also get it from here.

7439
12:31:10.873 --> 12:31:14.387
So now we've set the new remote with that remote URL.

7440
12:31:14.387 --> 12:31:17.958
Now we're going to actually push the changes to github.

7441
12:31:17.958 --> 12:31:18.212
com.

7442
12:31:18.212 --> 12:31:26.139
And the way we do that is with Git push, and we pick which remote we want to push to, and we're going to push the origin.

7443
12:31:26.139 --> 12:31:34.842
And then which branch we want to push to which we're going to push to Maine, it'll probably prompt you for your username and your password, and maybe your email and everything.

7444
12:31:34.842 --> 12:31:38.917
Now, if authentication doesn't work for you, for some reason, you can come over to Settings.

7445
12:31:38.917 --> 12:31:52.387
Or if you scroll down to developer settings, Personal Access Tokens and create generate new token, some token, give yourself repo access, write access, and hit Generate token.

7446
12:31:52.450 --> 12:31:54.550
And try to use this token as your password.

7447
12:31:55.450 --> 12:32:03.111
to use the GitHub documentation and the GitHub discussion associated with this course, if you get lost or if something doesn't work, as shown here.

7448
12:32:03.111 --> 12:32:13.183
But once it's done, once you add all that information in correctly, you come back to your get up and you will have your first GitHub repo with all the code and everything in it like this.

7449
12:32:13.183 --> 12:32:18.028
And once you complete this step, once you do this, you should absolutely celebrate.

7450
12:32:18.028 --> 12:32:24.631
If you like, you can shoot a tweet web three community in the blockchain community is absolutely this collaborative space.

7451
12:32:24.631 --> 12:32:28.090
So Twitter crypto is where a lot of these people congregate to share ideas.

7452
12:32:28.090 --> 12:32:32.766
So definitely be sure to celebrate and share this and be really, really excited.

7453
12:32:32.766 --> 12:32:34.054
And shoot a tweet out like this.

7454
12:32:34.054 --> 12:32:41.029
Give your friends a high five, share it on Twitter, share it on Discord shared on Reddit, be excited for how far you've gotten, we've got a lot more to go.

7455
12:32:41.029 --> 12:32:46.608
But by completing this part, you have done fantastically, and I'm so excited for you to start the next section.

7456
12:32:46.608 --> 12:32:51.705
Now, we're not going to go over the TypeScript addition to this because there's nothing really new here.

7457
12:32:51.705 --> 12:33:00.308
However, again, if you want to see TypeScript, feel free to jump into the GitHub repository associated with this course.

7458
12:33:00.451 --> 12:33:01.293
Alright, awesome.

7459
12:33:03.451 --> 12:33:04.466
heart had fun me.

7460
12:33:07.451 --> 12:33:14.744
which is going to be our HTML slash JavaScript to fund me, you can find all the code for what we're about to go through, of course, on my GitHub repo.

7461
12:33:14.744 --> 12:33:24.723
And for this section, we're now going to start to see some of the differences between Node js between that back end JavaScript, and JavaScript in the browser or front end JavaScript.

7462
12:33:24.723 --> 12:33:32.143
And if you come to the GitHub repo associated with this lesson, our main version we'll be using what's considered better front end JavaScript.

7463
12:33:32.143 --> 12:33:41.140
But we'll also have a no JS addition, as well, if some of the front end JavaScript is really confusing, and you'll see what I mean with some of those differences very soon.

7464
12:33:41.140 --> 12:33:44.924
Now, people can programmatically interact with our smart contracts at any time.

7465
12:33:44.924 --> 12:33:48.031
However, most of our users are not compete developers.

7466
12:33:48.031 --> 12:33:54.403
So we need to create a website, we need to create a user interface for them to interact with our smart contracts and interact with our protocols.

7467
12:33:54.403 --> 12:33:58.778
And that's what this section is going to teach us, it's going to be an introduction to building these fullstack.

7468
12:33:58.778 --> 12:34:01.515
building these front ends on top of our smart contracts.

7469
12:34:01.515 --> 12:34:05.701
Now, I wanted to show you what this is actually going to look like when we finish it.

7470
12:34:05.701 --> 12:34:11.652
Because here, we're actually going to make our first front end our first website using the blockchain using web three.

7471
12:34:11.652 --> 12:34:14.387
And it's going to be an incredibly minimalistic website.

7472
12:34:14.387 --> 12:34:20.434
As you can see right here, we're not going to have any styling, we're just going to show you how to get the functionality.

7473
12:34:20.434 --> 12:34:26.665
And additionally, we're going to do a couple of things that aren't really recommended and are definitely not best practices.

7474
12:34:26.665 --> 12:34:33.092
The reason we're going to do it like this is the same reason that in math class, before you learn the tricks for derivatives, you learn what a derivative actually is.

7475
12:34:33.092 --> 12:34:38.807
We're teaching it like this first, so that you can understand what's going on on the websites when you interact with them.

7476
12:34:38.807 --> 12:34:39.887
And when you work with them.

7477
12:34:39.887 --> 12:34:45.402
We saw already with Foston, touching the link where we can connect our wallets and we can work with the faucets.

7478
12:34:45.452 --> 12:34:53.920
All decentralized applications have this website and have this setup where you connect your wallet and then you interact by clicking buttons, which make these function calls to the blockchain.

7479
12:34:53.920 --> 12:34:57.346
And here's going to be our minimalistic website that does exactly that.

7480
12:34:57.346 --> 12:35:00.735
So this section is just going to teach you what's going on under the hood.

7481
12:35:00.735 --> 12:35:04.706
So you can really understand how to build these applications at a professional level.

7482
12:35:04.706 --> 12:35:13.404
So for this section, if you don't want to code along with me, you definitely don't have to however, coding along with me will definitely ingrain everything in your memory here.

7483
12:35:13.452 --> 12:35:16.639
So here's what an application is going to look like.

7484
12:35:17.452 --> 12:35:29.102
website here, which is connected to our hard hat, our local blockchain, but it's gonna run exactly the same as if it was on a real test net, the first thing you'll notice is in our meta mask, we are not connected.

7485
12:35:29.102 --> 12:35:36.658
And we'll go ahead and hit Connect, and meta masks will pop up asking us if we want to connect, we'll go ahead and connect to it.

7486
12:35:36.658 --> 12:35:39.536
And now we'll be able to interact with our heart at Funmi.

7487
12:35:39.536 --> 12:35:46.833
You'll notice two buttons here are functions that we're familiar with, we have our withdrawal function, which is going to be our withdrawal function that we just created.

7488
12:35:46.833 --> 12:35:56.733
And then of course, we also have our fund function here where we push or we send Aetherium or Matic or whatever, native blockchain token to our smart contract.

7489
12:35:56.733 --> 12:35:58.276
So we can do it through this user interface.

7490
12:35:58.276 --> 12:36:04.927
So once we're connected, if we want to see the balance, we can actually right click, hit Inspect, come over to our console.

7491
12:36:04.927 --> 12:36:10.961
And we'll print out to the JavaScript console, the current balance of our smart contract.

7492
12:36:10.961 --> 12:36:15.703
So nobody has funded this yet, we can come down, we can choose an amount we want to fund.

7493
12:36:15.703 --> 12:36:17.203
So for example, maybe 0.

7494
12:36:17.203 --> 12:36:23.713
1, eath, we'll go ahead, we'll hit fund, meta masks will pop up, we'll get a little council saying funding with 0.

7495
12:36:23.713 --> 12:36:23.773
1.

7496
12:36:23.773 --> 12:36:28.786
And it'll give us all the transaction details that we need to send 0.

7497
12:36:28.786 --> 12:36:32.436
1 eath, to our smart contract, we can go ahead and hit Confirm.

7498
12:36:32.436 --> 12:36:39.523
And after it's been confirmed after it's been mined on our local blockchain, we had get balance, we now see that it's 0.

7499
12:36:39.523 --> 12:36:39.610
1.

7500
12:36:39.610 --> 12:36:46.065
We could call fund again, we could have multiple funders, we could switch between different accounts and fund with different amounts.

7501
12:36:46.065 --> 12:36:50.357
And we can see that funding amount increase, then we can call the withdrawal function.

7502
12:36:50.357 --> 12:36:54.846
As long as we're the owner, we can confirm and we can pull out all the money out of our funding contract.

7503
12:36:54.846 --> 12:36:55.927
And we'll get balance.

7504
12:36:55.927 --> 12:36:58.082
Now we'll see the balance is reset to zero.

7505
12:36:58.082 --> 12:37:00.162
So this is what we're going to be building.

7506
12:37:00.162 --> 12:37:01.405
Are you ready? I sure am.

7507
12:37:01.453 --> 12:37:02.380
Let's get into it.

7508
12:37:04.453 --> 12:37:05.514
websites with web three.

7509
12:37:07.453 --> 12:37:09.843
our GitHub repo, so feel free to follow along there.

7510
12:37:10.453 --> 12:37:17.185
if you're in your heart head Funmi dash Free Code Camp repo, we're still going to want to have this open as well.

7511
12:37:17.185 --> 12:37:22.323
But we're also going to want to create a new Visual Studio code for working with our new repo.

7512
12:37:22.323 --> 12:37:25.673
So let's go ahead and CD down a directory.

7513
12:37:25.673 --> 12:37:33.372
We'll type MK dir, we'll call this HTML, Fund Me Free Code Camp.

7514
12:37:33.372 --> 12:37:34.617
We'll cd into that.

7515
12:37:34.617 --> 12:37:37.561
And we'll open this up by typing code period.

7516
12:37:37.561 --> 12:37:44.388
You can also do File Open Folder, but we just want to open this up in a new Visual Studio Code.

7517
12:37:44.388 --> 12:37:56.335
New VS code will pop up but before we flip over to that, we do want to CD down CD back into hard hat fun we Free Code Camp because we are still going to use everything in here.

7518
12:37:56.335 --> 12:38:08.389
We're still going to deploy In a smart contract using this folder and using this repo, when you're building daps, or websites that are connected to the blockchain, you'll usually have two repositories or repos.

7519
12:38:08.454 --> 12:38:10.660
One is going to be for the smart contracts, like what we see here.

7520
12:38:10.660 --> 12:38:13.875
This is our repo that has all the code for our smart contracts.

7521
12:38:13.875 --> 12:38:16.695
And then you'll also have one for the front end slash website.

7522
12:38:16.695 --> 12:38:21.025
And it's going to be the combination of these two repos, which makes up the full stack.

7523
12:38:21.025 --> 12:38:37.267
So when people are talking about full stack, they're talking about the smart contracts, which is going to be our back end, plus, plus our HTML slash JavaScript slash website stuff, which is going to be our front end.

7524
12:38:37.267 --> 12:38:42.604
So smart contracts are the back end, HTML slash JavaScript slash website stuff is going to be our front end.

7525
12:38:42.604 --> 12:38:44.204
So we have our back end already.

7526
12:38:44.204 --> 12:38:51.628
And now we're going to build our front end, we want to keep this up because we're going to need it to test and interact with our front end.

7527
12:38:51.628 --> 12:38:52.135
Awesome.

7528
12:38:52.135 --> 12:38:56.120
So we have this new folder now, HTML Funmi, Free Code Camp.

7529
12:38:56.120 --> 12:39:01.863
Now this course is not a how to learn front end course, we are going to teach you a number of front end concepts.

7530
12:39:01.863 --> 12:39:18.821
But if you want to learn a full traditional front end course, once again, you can check out Free Code Camp, they've got a ton of fantastic tutorials, I'm teaching you front end, if you go ahead and follow along with me, though, you'll definitely get a basic understanding of front end as well as front ends and how it relates to our smart contracts.

7531
12:39:18.821 --> 12:39:22.405
Additionally, you don't have to do the front end parts or the full stack parts.

7532
12:39:22.455 --> 12:39:33.245
If you only want to take this course, to learn back end and to learn JavaScript, and to learn solidity and learn how to do these smart contracts programmatically, then you can absolutely skip these front end parts.

7533
12:39:33.245 --> 12:39:41.061
However, if you want to learn to build exciting websites, and you want to have other people other than developers interact with your protocols, you definitely want to watch this part.

7534
12:39:41.061 --> 12:39:44.005
Now before we actually jump in here and start writing our code.

7535
12:39:44.005 --> 12:39:50.355
We need to understand what exactly is going on when work with one of these websites that use the blockchain.

7536
12:39:50.355 --> 12:39:53.094
So I actually made a video about this recently.

7537
12:39:53.094 --> 12:40:04.190
So let's watch a segment from that really quick, just so that we can get up to speed with with exactly what's going on behind the scenes of these websites that interact with the blockchain.

7538
12:40:04.190 --> 12:40:05.322
All right.

7539
12:40:05.322 --> 12:40:13.008
So here we are, with a website or a front end on top of some smart contracts that we've deployed, doesn't really matter what it is right now.

7540
12:40:13.008 --> 12:40:19.582
This is typically the interface that you'll see boiled down to a really, really minimalistic level.

7541
12:40:19.582 --> 12:40:28.946
Typically, you'll see something like connect function, right, and Metamask, or some other wallet connector thing will pop up, we'll hit Next we'll connect here might even say something like connected.

7542
12:40:28.946 --> 12:40:33.418
And we can also execute functions, we can interact with our smart contracts, we can confirm, etc.

7543
12:40:33.455 --> 12:40:40.995
Right? This is something you might see something like Avi right, I'll hit Connect on the application, it'll say, hey, how would you like to connect? I'll choose Metamask.

7544
12:40:40.995 --> 12:40:47.901
I'm going to change my Metamask to main net, but you get the picture, right? This is a simple example of what that would look like.

7545
12:40:47.901 --> 12:40:57.170
So what is actually going on in the browser when we connect what is actually going on? And what do we actually need to do, we're going to right click, hit Inspect.

7546
12:40:57.170 --> 12:41:01.122
And on the right side, we're gonna see our debugger here.

7547
12:41:01.122 --> 12:41:07.601
Now if we go over to sources, on the top of our browser, you'll see a few things.

7548
12:41:07.601 --> 12:41:15.656
If you look down over here, right, we'll see this URL, right, which right now is going to be my localhost.

7549
12:41:15.656 --> 12:41:19.578
And we'll also see meta mask and Phantom and a whole bunch of other stuff.

7550
12:41:19.578 --> 12:41:24.973
These other things that we see here are going to be what's injected from our browser extensions.

7551
12:41:24.973 --> 12:41:33.406
The reason we see this meta mask thing here is because I've meta mask installed, right? The reason I see Phantom here is because I have the Phantom app installed.

7552
12:41:33.456 --> 12:41:38.813
Meta masks, of course, being an EVM, wallet and Phantom being a Solana based wallet.

7553
12:41:38.813 --> 12:41:57.520
Now what happens when we have these extensions installed is they automatically get injected into a window object in JavaScript, and in fact, we scroll down to here in the console, again, you can find console, you can click here and click anything up there.

7554
12:41:57.520 --> 12:41:59.294
And we type in window.

7555
12:41:59.456 --> 12:42:13.836
We'll see we have this big window object with all this stuff, right? This window object represents this our window basically right? Now if we scroll all the way to the bottom and we do window dot Aetherium.

7556
12:42:13.836 --> 12:42:15.978
We also see an object here.

7557
12:42:15.978 --> 12:42:29.579
Now this window dot Aetherium object only exists if you have a meta mask or meta mask like browser or if you want to look at some other web three wallet you do window dot Solana.

7558
12:42:29.579 --> 12:42:32.407
So Alana right and we see this window dot Solana.

7559
12:42:32.407 --> 12:42:36.403
Now let's look at a browser that doesn't have Metamask or phantom installed.

7560
12:42:36.457 --> 12:42:40.494
What do you think is going to happen in the window now let's go ahead and right click hit Inspect.

7561
12:42:40.494 --> 12:42:41.931
We'll go to the console.

7562
12:42:41.931 --> 12:42:44.507
Now let's see what's going on in here.

7563
12:42:44.507 --> 12:42:49.190
If we go to sources, we first off we don't see that Metamask or that Solana source here.

7564
12:42:49.190 --> 12:42:53.837
And if we go to console, we still see window if I let me zoom in a little bit.

7565
12:42:53.837 --> 12:42:55.027
We still see window here.

7566
12:42:55.027 --> 12:43:01.878
But if I do window dot Aetherium If we get nothing, or if I do window dot Solana, we also get nothing.

7567
12:43:01.878 --> 12:43:14.211
So in order for our browsers to know that there's a Metamask, or that there's a phantom, those extensions automatically add these to our window objects, and that's something that we can check for in our JavaScript.

7568
12:43:14.211 --> 12:43:21.653
The reason these wallets are so important is built into them underneath the hood, they have a blockchain node connected to them.

7569
12:43:21.653 --> 12:43:25.178
And in order to interact with the blockchain, we always need a note.

7570
12:43:25.178 --> 12:43:37.974
And you might have seen URLs from alchemy, or in FIRA because you need them to interact with the blockchain, Alchemy, and infura are examples of third party blockchains that you can interact with and basically rent, right.

7571
12:43:37.974 --> 12:43:43.149
But you need them to create a provider, or a node to send your transactions to.

7572
12:43:43.149 --> 12:43:53.769
So you could do it in JavaScript, like something like this is the alchemy documentation where you take that alchemy URL, you stick it into some object and use that to send your transaction.

7573
12:43:53.769 --> 12:43:56.832
This is a way that you could do it in the back end.

7574
12:43:56.832 --> 12:44:04.957
But on the front end, what you normally want to use is you just want to use the user's Metamask, or their Solana or their wallet as the main wallet.

7575
12:44:04.957 --> 12:44:11.362
Now, there are a ton of other different types of wallets to connect, like ledger, mu, Coinbase, wallet, connect, etc.

7576
12:44:11.362 --> 12:44:14.232
And there are different ways to set those up.

7577
12:44:14.232 --> 12:44:22.000
But they all do the same thing where they expose some URL, they expose some node under the hood, they give us that URL.

7578
12:44:22.000 --> 12:44:23.830
They give us that provider.

7579
12:44:23.830 --> 12:44:27.879
The way metamath Does it is with window dot Aetherium.

7580
12:44:27.879 --> 12:44:29.910
Boom, this is now our URL.

7581
12:44:29.910 --> 12:44:32.151
This is now our connection.

7582
12:44:32.151 --> 12:44:40.208
In fact, if you go up to your Metamask, hit the little three dots, expand view.

7583
12:44:40.208 --> 12:44:44.828
hit Add Network, and then just hit the X so we can get to networks.

7584
12:44:44.828 --> 12:44:55.569
You can see all of these blockchains that I have in here all have an RPC URL, this the HTTP RPC URL connection of the blockchain No, that's running.

7585
12:44:55.569 --> 12:44:59.299
I happen to have one running locally right now.

7586
12:44:59.458 --> 12:45:05.186
All of these also have a node RPC URL and you can actually see them right in your meta mask right.

7587
12:45:05.186 --> 12:45:08.919
This is connected to in Fira, these are all connected to in Fira.

7588
12:45:08.919 --> 12:45:10.716
It's all the exact same thing.

7589
12:45:10.716 --> 12:45:20.505
Meta mask just has a really nice way of taking that URL, sticking it in the browser for us in this window dot Aetherium or window dot Solana you know or whatever.

7590
12:45:20.505 --> 12:45:22.867
So this is the main thing that we need to know we need.

7591
12:45:22.867 --> 12:45:25.333
We always need a connection with the blockchain.

7592
12:45:25.333 --> 12:45:28.627
And these browser wallets are an easy way to do that.

7593
12:45:28.627 --> 12:45:29.734
Make sense? Great.

7594
12:45:29.734 --> 12:45:31.672
Let's take this knowledge now.

7595
12:45:31.672 --> 12:45:33.232
And let's apply it.

7596
12:45:33.232 --> 12:45:36.909
So in here, let's make a quick readme.

7597
12:45:36.909 --> 12:45:37.102
md.

7598
12:45:37.102 --> 12:45:40.064
Just so we can talk about what we're going to be making here.

7599
12:45:40.064 --> 12:45:47.408
So in this section, we're gonna be using raw HTML slash JavaScript in conjunction with our smart contracts to build this website.

7600
12:45:47.459 --> 12:45:48.001
Later on.

7601
12:45:52.459 --> 12:45:54.666
modern stack to build our websites here.

7602
12:45:55.459 --> 12:46:02.901
understanding how to do everything with HTML and JavaScript first, is going to make our lives a lot easier come later on down the road.

7603
12:46:02.901 --> 12:46:07.859
But as we know, all websites use HTML as kind of their scaffolding for what they look like.

7604
12:46:07.859 --> 12:46:13.104
So let's go ahead and create our HTML for our website, we'll call it index dot HTML.

7605
12:46:13.104 --> 12:46:20.878
And this is going to be the basic scaffolding or the basic bones of what our website is going to look like.

7606
12:46:20.878 --> 12:46:33.125
Now, in VS code, if you go ahead and just type exclamation mark index dot HTML, and you click the first thing that pops up, it'll automatically populate your code your file here with some basic HTML setup.

7607
12:46:33.125 --> 12:46:42.249
If it doesn't do this for you, feel free to copy paste the basic setup from the GitHub repository associated with this course, we have our doctype.

7608
12:46:42.249 --> 12:46:47.785
HTML, we have some HTML tags telling us that everything in between here is going to be an HTML, which is great.

7609
12:46:47.785 --> 12:46:50.310
However, for simplicity, we don't need most of this.

7610
12:46:50.310 --> 12:46:52.295
So we're going to make this a little bit easier.

7611
12:46:52.295 --> 12:46:55.131
We're going to delete this line, this line and this line.

7612
12:46:55.131 --> 12:46:58.180
And we're just going to change the title to fund me app.

7613
12:46:58.180 --> 12:47:02.371
And then inside of our body, we can do something like or Hello.

7614
12:47:02.371 --> 12:47:06.901
And now we have the bare bones to create a website just with this.

7615
12:47:06.901 --> 12:47:10.426
Now to show this on a website, we can do one of two things.

7616
12:47:10.426 --> 12:47:16.131
If you are using Visual Studio code, I'm going to recommend you install the extension live server.

7617
12:47:16.131 --> 12:47:17.069
And it looks like this.

7618
12:47:17.069 --> 12:47:23.910
And I'll have the extension ID for this extension in the GitHub repository associated with this course, this is going to allow us to easily spin up an HTML website.

7619
12:47:23.910 --> 12:47:26.168
So we'll go ahead and install this.

7620
12:47:26.168 --> 12:47:30.052
And if you're not using Visual Studio Code, I'll show you a different way in just a second.

7621
12:47:30.052 --> 12:47:35.270
Once this is installed, you should have this little go live button at the bottom.

7622
12:47:35.270 --> 12:47:48.227
And if you don't, you can always open up your command palette, which again, you can open up by hitting View command palette, and you can type in live server and just say open with live server but we're going to just click this go live button.

7623
12:47:48.227 --> 12:47:54.348
And it's going to say starting and it's actually going to open up your browser with our index dot HTML.

7624
12:47:54.348 --> 12:47:58.543
We can actually see our website is being called Save on 120 7.

7625
12:47:58.543 --> 12:47:59.293
0 point 0.

7626
12:47:59.293 --> 12:47:59.376
1.

7627
12:47:59.376 --> 12:48:05.348
This is known as the loopback, or local host endpoint, we're on port 5501.

7628
12:48:05.348 --> 12:48:11.015
If you're not familiar with the ports, don't worry about that for now, we have our index dot HTML here.

7629
12:48:11.015 --> 12:48:15.348
And if we change this to something like what's good, we hit save.

7630
12:48:15.348 --> 12:48:18.991
If it doesn't automatically refresh, we'd come over here and refresh.

7631
12:48:18.991 --> 12:48:20.495
And we'd see that being reflected here.

7632
12:48:20.495 --> 12:48:26.755
If you've never created a website before, you've essentially just done it, congratulations, you might get this.

7633
12:48:26.755 --> 12:48:27.673
vs code folder.

7634
12:48:27.673 --> 12:48:27.804
a.

7635
12:48:27.804 --> 12:48:37.994
vs code folder allows you to make settings specifically for the repo that you're working with, for your code editor for VS code, but we're going to mostly ignore it for now.

7636
12:48:37.994 --> 12:48:43.266
Now, if you're not using Visual Studio Code, what you can do is you can just run this in the browser.

7637
12:48:43.266 --> 12:48:47.443
So one thing you could do is you could right click it, and I'm using a Mac.

7638
12:48:47.443 --> 12:48:51.593
So I'm going to hit Reveal in Finder, aka reveal where it's located.

7639
12:48:51.593 --> 12:48:54.788
And you can just double click it, and boom, now it's running right in your browser.

7640
12:48:54.788 --> 12:49:00.022
Instead of pointing to your localhost, it's going to be pointing directly to your local file path.

7641
12:49:00.022 --> 12:49:03.558
Now one final version that we could do that I'm going to highly recommend you don't do.

7642
12:49:03.558 --> 12:49:10.601
But it's another option, we're actually going to download a package for you using no Jas, which allows us to serve up HTTP.

7643
12:49:10.601 --> 12:49:18.936
And we're gonna install it the exact same way we've installed our other packages, we can do yarn, add dash dash dev HTTP hyphen server.

7644
12:49:18.936 --> 12:49:22.296
And you may still want to add it anyways.

7645
12:49:22.461 --> 12:49:31.222
But now, we'll get some node modules for this HTTP server package, we'll get a package json, and of course, a yarn dot lock as well.

7646
12:49:31.222 --> 12:49:35.430
And what we can do is we can stop this down here, stop that live server.

7647
12:49:35.430 --> 12:49:38.936
And if we go back to our website, refresh, it'll now be blank.

7648
12:49:38.936 --> 12:49:41.558
And we can run yarn HTTP server.

7649
12:49:41.558 --> 12:49:43.815
And this will do the exact same thing.

7650
12:49:43.815 --> 12:49:47.810
And we get, and if we come over, and we refresh, we'll see what's good.

7651
12:49:47.810 --> 12:49:50.211
Now this one is a little bit more finicky.

7652
12:49:50.211 --> 12:49:56.898
And after you make a change, like, Hey, what's good, you might have to close it, and then reopen it and then refresh.

7653
12:49:56.898 --> 12:50:04.409
So I do recommend that if you're on Visual Studio code, you definitely just use this little go live button, because it'll reflect your changes a lot nicer.

7654
12:50:04.461 --> 12:50:05.880
So let's go ahead and hit the Go Live button.

7655
12:50:07.461 --> 12:50:08.147
pops up.

7656
12:50:08.147 --> 12:50:09.225
Okay, cool.

7657
12:50:12.461 --> 12:50:17.917
So the title, of course, is going to be the Funmi app, which we see up here in the title section.

7658
12:50:17.917 --> 12:50:25.788
So let's update this HTML, so that it has those buttons, and it can actually connect and work with our blockchain and work with any blockchain.

7659
12:50:25.788 --> 12:50:30.045
Something else that you can do in HTML is you can actually write JavaScript inside your HTML.

7660
12:50:30.045 --> 12:50:36.106
And the way we can do that is by doing this script tag, and then we'll do a closing script tag.

7661
12:50:36.106 --> 12:50:40.651
And anything inside here inside of our script tags is going to be JavaScript.

7662
12:50:40.651 --> 12:50:46.806
So I could do something like console dot log, hi, with a bunch of exclamation marks, I'm going to save it.

7663
12:50:46.806 --> 12:50:52.675
We'll go back to our front end, we're going to right click, we'll hit Inspect, we'll go to the console.

7664
12:50:52.675 --> 12:51:02.747
And we can see that Hi prints it out, we refresh, we can see the hi consistently printed out hi from script tag, we'll save it, we'll move back, we see hi from script tag printed out.

7665
12:51:02.747 --> 12:51:05.494
I know it's a little bit small.

7666
12:51:05.494 --> 12:51:06.655
So let me zoom in.

7667
12:51:06.655 --> 12:51:07.622
Alright, great.

7668
12:51:07.622 --> 12:51:17.033
So we can type our JavaScript in here, it's inside the script tag is where we're going to write our JavaScript to write the functions that our front end is going to interact with.

7669
12:51:17.033 --> 12:51:25.332
Now, as we saw before, in this little console, we can check for window dot Etherium, to see if Metamask or is installed.

7670
12:51:25.332 --> 12:51:29.526
And again, a lot of what we're working with is actually right in the Metamask documentation.

7671
12:51:29.526 --> 12:51:40.774
If you go to their basic section, they talk a little bit about the provider, which is this window dot Aetherium, you can read how to actually interact directly with meta mask in the meta mask documentation as well.

7672
12:51:40.774 --> 12:51:48.620
Now using window dot Aetherium is just one of the ways we're actually going to connect to the blockchain, there's actually multiple ways because there's multiple different kinds of wallets out there.

7673
12:51:48.620 --> 12:51:54.190
But for now, we're just going to pretend that window dot Aetherium and meta mask is the only extension out there.

7674
12:51:54.190 --> 12:51:57.494
So what we want to do is we want to check to see if this wind of that Aetherium exists.

7675
12:51:57.494 --> 12:51:59.890
This is the first thing that we should be doing.

7676
12:51:59.890 --> 12:52:08.203
Because if this doesn't exist, this means that they can't connect to the blockchain, one of the first things that we're going to want to do is we're going to want to check to see if that exists.

7677
12:52:08.203 --> 12:52:18.319
So we can do something like if we can say type of window that Aetherium does not equal, undefined.

7678
12:52:18.319 --> 12:52:22.985
Then we'll do console dot log, I see a meta mask.

7679
12:52:22.985 --> 12:52:28.005
So now if we save, we come back to our front end, we do see I see a Metamask.

7680
12:52:28.005 --> 12:52:37.708
I've got a Google Chrome up without Metamask that if we look in the console, and we hit refresh it the same URL where our live server is running.

7681
12:52:37.708 --> 12:52:42.383
We don't see that I see a meta mask because it doesn't see a meta mask.

7682
12:52:42.383 --> 12:52:43.335
We can do else.

7683
12:52:43.463 --> 12:52:50.479
console dot log, no Metamask refresh, we still see ICD a meta mask where we have a meta mask.

7684
12:52:50.479 --> 12:52:55.807
You don't have to open up a browser without one but we see no meta mask for Chrome because it doesn't see a meta mask.

7685
12:52:55.807 --> 12:53:19.025
Now what we could do is We can automatically try to connect to meta mask if we see that there is a meta mask, right? Remember how before, when we hit that connect button meta mask popped up and said, Are you sure you want to connect? So what we can do is, and you can, again, you can find this in the meta mask docs, we can run this eath request accounts method, which is basically going to be how we connect our Metamask.

7686
12:53:19.025 --> 12:53:23.479
Now, this is specified by a new EIP and an older documentations.

7687
12:53:23.479 --> 12:53:27.790
And in older tutorials, you might see Aetherium dot enable, which essentially does the exact same thing.

7688
12:53:27.790 --> 12:53:34.987
So what we could do here is we could say, a cerium, or excuse me, window dot Aetherium dot request.

7689
12:53:34.987 --> 12:53:39.379
And we could put method F request accounts.

7690
12:53:39.379 --> 12:53:41.712
And we'll save that.

7691
12:53:41.712 --> 12:53:51.775
Now if we go back to our browser, we'll actually see, you'll actually see Metamask, go ahead and pop up and say, let's connect so we can choose an account.

7692
12:53:51.775 --> 12:53:56.903
And we'll hit Connect, will automatically connect our meta mask to our website.

7693
12:53:56.903 --> 12:54:01.157
And now if we look at our meta mask, we can see this little connected thing.

7694
12:54:01.157 --> 12:54:04.413
It's saying that our account one is now connected to our website.

7695
12:54:04.463 --> 12:54:11.689
This means that the website can now make API calls to our meta mask, we still have to be the ones to approve them.

7696
12:54:11.689 --> 12:54:16.939
But it can go ahead and connect and try to run transactions, which is awesome, which is what we want.

7697
12:54:16.939 --> 12:54:21.026
If you want to disconnect, we can go ahead and click that little button and hit disconnect this account.

7698
12:54:21.026 --> 12:54:27.226
Well that we have our code currently is anytime we hit refresh, this is going to pop up which is going to be really annoying.

7699
12:54:27.226 --> 12:54:38.078
So what we're going to do instead is we're going to wrap this up into an asynchronous function, the exact same as we've been doing, we'll do we'll create an async function called Connect.

7700
12:54:38.078 --> 12:54:40.971
And we'll wrap it up these curly braces here.

7701
12:54:40.971 --> 12:54:44.316
And then we'll just format this a little bit to make it look nicer.

7702
12:54:44.316 --> 12:54:48.655
And now if we save, we go back to our website, and we refresh.

7703
12:54:48.655 --> 12:54:51.293
And we go ahead and disconnect.

7704
12:54:51.464 --> 12:55:00.928
If we refresh Metamask won't keep asking us Hey, do you want to connect Hey, do you want to connect here do you want to connect, because we need to call this connect function where we can do that is we can add a little button here.

7705
12:55:00.928 --> 12:55:06.141
So right underneath our script tag, we're going to add a button tag.

7706
12:55:06.141 --> 12:55:07.480
So this is the opening button tag.

7707
12:55:07.480 --> 12:55:09.153
And then here's the closing button tag.

7708
12:55:09.153 --> 12:55:15.526
And inside the opening button tag declaration, we'll give it an ID, which will be Connect button.

7709
12:55:15.526 --> 12:55:22.089
And we'll say on click equals the Connect connects function.

7710
12:55:22.089 --> 12:55:30.498
And we'll call this button connect in between these little button tags, we'll call it connect will say when we click it will call the Connect function.

7711
12:55:30.498 --> 12:55:35.412
So if we save, and we go back to our front end, we can now see we have a little Connect button.

7712
12:55:35.464 --> 12:55:41.946
And now if we press Connect, Metamask is going to pop up, we'll hit next and connect like that.

7713
12:55:41.946 --> 12:55:44.064
And boom, now we are connected.

7714
12:55:44.064 --> 12:55:49.498
And we can even do a little await here so that we wait for this to finish before moving on.

7715
12:55:49.498 --> 12:55:54.683
And then after we connect, we can say console dot log connected.

7716
12:55:54.683 --> 12:55:59.115
So let's actually go ahead and test this out, we'll go back to Metamask.

7717
12:55:59.115 --> 12:56:03.600
we'll disconnect here, try to never be on Main net if we don't have to be.

7718
12:56:03.600 --> 12:56:07.328
And let's go ahead run connect, we'll hit Next connect.

7719
12:56:07.465 --> 12:56:10.965
And now we see a little console dot log come out saying connected.

7720
12:56:10.965 --> 12:56:11.631
Okay, great.

7721
12:56:11.631 --> 12:56:14.152
We can also update our website accordingly.

7722
12:56:14.152 --> 12:56:17.339
So that we can let users know that we're connected.

7723
12:56:17.465 --> 12:56:22.947
So we can grab the connect button element ID and say that we're connected once we're connected.

7724
12:56:22.947 --> 12:56:33.368
So after we await to be connected, we can go ahead and do document dot get element by ID Connect button.

7725
12:56:33.368 --> 12:56:40.431
And then we'll say dot inner HTML equals connected like that.

7726
12:56:40.431 --> 12:56:44.412
And then instead of saying no minimize down here, we'll do just the opposite.

7727
12:56:44.412 --> 12:56:45.858
So we'll copy this line.

7728
12:56:45.858 --> 12:56:51.723
And instead of connected, we'll say please install meta mask.

7729
12:56:51.723 --> 12:56:55.846
And we'll save we'll go back to our front end, we'll hit connect.

7730
12:56:55.846 --> 12:56:59.915
And now if we're already connected, it'll just automatically go to connected.

7731
12:56:59.915 --> 12:57:02.350
If we're not connected, it'll pop up, we'll get connected.

7732
12:57:02.350 --> 12:57:04.990
And now we have this button that says connected, which is great.

7733
12:57:04.990 --> 12:57:08.101
So now we already know that we're connected.

7734
12:57:08.101 --> 12:57:12.955
So we've connected our Metamask to our front end.

7735
12:57:12.955 --> 12:57:16.215
Now we want to actually go ahead and do some functions here.

7736
12:57:16.215 --> 12:57:24.015
And this is where we want to create some more functions and some more buttons that are going to use ethers that package that we become so familiar with.

7737
12:57:24.015 --> 12:57:28.111
Now, as we code, our script section is going to get bigger and bigger and bigger.

7738
12:57:28.111 --> 12:57:32.666
So oftentimes, we actually want to put our code in a JavaScript file itself.

7739
12:57:32.666 --> 12:57:38.531
So we're gonna go ahead, come over here, we're going to create a new file, and we'll call it index dot j s.

7740
12:57:38.531 --> 12:57:47.869
And instead of putting our JavaScript in these script tags, we're going to put it in this index and then import this index file into our HTML.

7741
12:57:47.869 --> 12:57:52.415
And the way that we're going to do that is we're actually just going to grab this function.

7742
12:57:52.466 --> 12:57:54.836
We're going to copy it, delete everything for now.

7743
12:57:55.466 --> 12:58:06.014
to paste it into our end ext dot j s, and then in our index dot HTML, we're just going to tell our script tag to use index.

7744
12:58:06.014 --> 12:58:06.239
js.

7745
12:58:06.466 --> 12:58:12.887
So we're just going to say the source is going to be equal to dot slash index dot j s.

7746
12:58:12.887 --> 12:58:20.235
And then we're going to say, the type of this is going to be text slash JavaScript.

7747
12:58:20.235 --> 12:58:27.207
Now if we save that, and we save our index dot HTML, we come back to our front end, we do a little refresh.

7748
12:58:27.207 --> 12:58:30.672
And we make sure that we go ahead and disconnect.

7749
12:58:30.672 --> 12:58:35.799
And we do another refresh, we can see that even with our index.

7750
12:58:35.799 --> 12:58:39.983
js in a different file, because we're doing src equals index.

7751
12:58:39.983 --> 12:58:46.841
js, and we're importing it into our HTML, when we hit Connect, it still calls our Connect function.

7752
12:58:46.841 --> 12:58:52.415
That's how we can kind of separate our JavaScript into its own js file that we're a little bit more familiar with.

7753
12:58:52.466 --> 12:59:09.300
Now, if you look in the GitHub repo associated with this course, and you look in the index dot j s, you'll see our Connect function, we've added some quality of life stuff, we've added some try catches just to make handling errors a little bit better, you can go ahead and add those try catches in yourself if you'd like.

7754
12:59:09.300 --> 12:59:13.029
But I'm not going to demo them in this video here.

7755
12:59:13.029 --> 12:59:28.263
Now we want to create our fun function.

7756
12:59:28.263 --> 12:59:38.794
And then later on, we're going to create our withdrawal function.

7757
12:59:38.794 --> 12:59:42.094
And this is where front end JavaScript code.

7758
12:59:42.094 --> 12:59:45.057
And no Gs are a little bit different.

7759
12:59:45.057 --> 12:59:54.696
In no JS, we've been using this require keyword to import dependencies in front end JavaScript, you can't use require, and it won't exactly work.

7760
12:59:54.696 --> 12:59:59.677
Now later on, we're going to use the Import keyword, which is really the better way to do this.

7761
12:59:59.677 --> 13:00:10.534
And this is where our first differences going to be using the Import keyword for front end is much better than the require keyword, especially since the require keyword doesn't actually work.

7762
13:00:10.534 --> 13:00:14.376
And for those you who might struggle with this disconnect in this change.

7763
13:00:14.376 --> 13:00:32.139
Once again, in the GitHub repo associated with this, we do have a Node js edition of this, where you can use the require keyword, you just have to go through the readme and download some packages and run some scripts that basically transform your code that uses require into code that works with imports.

7764
13:00:32.139 --> 13:00:36.324
But we're going to teach you the way to work with your front end code here using imports.

7765
13:00:36.324 --> 13:00:45.237
Now you'll see when we get to next Jas that we will still download code from node modules and using a yarn lock and a package json etc.

7766
13:00:45.237 --> 13:00:49.372
So summary in future seconds, we are still going to do yarn add.

7767
13:00:49.372 --> 13:01:00.731
But outside of a framework when we're using this raw JavaScript, this raw HTML setup, like what we're working with here, we're not going to be doing yarn, add node modules will add node modules for framework like next react.

7768
13:01:00.731 --> 13:01:04.631
But for raw JavaScript, we'll be using a different syntax, which I'll show you soon.

7769
13:01:04.631 --> 13:01:07.175
So let's go ahead and start building our fund function here.

7770
13:01:07.175 --> 13:01:12.046
To make our fun functions, what would we normally do? Well, we'd create an async function called fund.

7771
13:01:12.046 --> 13:01:20.994
And in this function, we probably would want to take some ether mount as a parameter, because we're going to want to fund it with some amount of Aetherium.

7772
13:01:20.994 --> 13:01:29.991
When we call this function, we might want to run console dot log will do a little string interpolation here.

7773
13:01:29.991 --> 13:01:36.855
Funding with eth amount, dot dot dot, these semicolons are going to drive me absolutely insane.

7774
13:01:36.855 --> 13:01:43.419
So I'm going to add a our dot prettier dot our rc file into this, and I'm going to go ahead and add prettier in here.

7775
13:01:43.468 --> 13:01:45.155
Otherwise, I'm going to lose my mind.

7776
13:01:46.468 --> 13:01:52.123
dash dash Dev, prettier, just so we can format our JavaScript with prettier come back to index.

7777
13:01:52.123 --> 13:01:52.226
js.

7778
13:01:52.226 --> 13:02:02.894
I'm gonna hit command S, and it looks like it does indeed, auto format with prettier now yay, no matter semicolons, we can call this fun function the same way we call connect.

7779
13:02:02.894 --> 13:02:06.817
So in in our index dot HTML, maybe we'll create a new button.

7780
13:02:06.817 --> 13:02:07.261
Button.

7781
13:02:07.261 --> 13:02:15.025
We'll give it an ID of fund will say on click equals fund.

7782
13:02:15.025 --> 13:02:18.139
And we'll say fund.

7783
13:02:18.468 --> 13:02:21.517
And this will be our button here, we save it, we're looking at our front end.

7784
13:02:21.517 --> 13:02:27.740
Now the fund button that if we call, we say funding with undefined because we're not passing it an amount here.

7785
13:02:27.740 --> 13:02:34.418
So back in our index console dot log funding with and we'll just want to make sure that we can actually call that Funmi function.

7786
13:02:34.418 --> 13:02:40.119
So we'll copy this line again and we'll say type of window dot Aetherium does not equal undefined.

7787
13:02:40.119 --> 13:02:42.822
We'll go ahead and try to fund here to send a transaction.

7788
13:02:42.822 --> 13:02:50.115
What are the things that we absolutely 100% Always need? Well, we need a provider slash connection to the blockchain.

7789
13:02:50.115 --> 13:03:02.296
And we need a signer slash wallet, slash someone with some gas to actually send it and then And we're probably going to need the contract that we are interacting with.

7790
13:03:02.296 --> 13:03:05.759
And to get that contract, we're going to need ABI and address.

7791
13:03:05.759 --> 13:03:09.287
And with these all together, we can send any transaction.

7792
13:03:09.287 --> 13:03:13.598
So to get our provider, we're going to actually go ahead and work with ethers again.

7793
13:03:13.598 --> 13:03:24.294
Now, we're going to do it a little bit differently, though, before, the way we worked with ethers is we said const ethers equals require ethers, right.

7794
13:03:24.294 --> 13:03:26.389
And this is how we pulled ethers.

7795
13:03:26.389 --> 13:03:30.904
And now like I just said to you, though, require doesn't work in the front end.

7796
13:03:30.904 --> 13:03:34.699
And we actually don't want to install ethers with a node modules package.

7797
13:03:34.699 --> 13:03:39.344
So what we can actually do instead is let's go to the ethers documentation.

7798
13:03:39.344 --> 13:03:49.484
If you go to the Getting Started section, scroll down, they have a section about importing using Node js, which uses require or imports.

7799
13:03:49.484 --> 13:03:54.707
And then they also have some documentation for working with the web browser.

7800
13:03:54.707 --> 13:04:03.069
So instead of us doing a node module, what we'll do is we'll copy the ethers library to our own directories and serve it ourselves.

7801
13:04:03.069 --> 13:04:12.728
So what we do is we can come in here, we can copy this massive file, which is ethers, but in front end addition, and come back to our file.

7802
13:04:12.728 --> 13:04:16.220
And we'll make a new file in here.

7803
13:04:16.470 --> 13:04:18.360
Called ethers.

7804
13:04:18.360 --> 13:04:19.960
We'll do 5.

7805
13:04:19.960 --> 13:04:21.560
6 point esm.

7806
13:04:21.560 --> 13:04:21.996
min.

7807
13:04:21.996 --> 13:04:22.286
js.

7808
13:04:24.470 --> 13:04:26.603
paste that massive thing in here.

7809
13:04:28.470 --> 13:04:30.486
when I save it, it's going to auto format.

7810
13:04:31.470 --> 13:04:38.012
huge file, which has everything ethers, but front end defied if you will.

7811
13:04:38.012 --> 13:04:41.916
Now what we can do is we can import this into our index.

7812
13:04:41.916 --> 13:04:42.094
js.

7813
13:04:42.094 --> 13:04:55.755
So instead of using require in here, we'll say import ethers from and then we'll just refer to that file that we just got ethers dash 5.

7814
13:04:55.755 --> 13:04:57.326
6 point esm.

7815
13:04:57.326 --> 13:04:57.754
min.

7816
13:04:57.754 --> 13:04:58.039
js.

7817
13:04:58.039 --> 13:05:07.374
Now, we only need to do this weird copy pasting of the file import thing in this HTML JavaScript lesson.

7818
13:05:07.374 --> 13:05:13.142
In future lessons with Node js, we are going to do yarn, add ethers, kinda like we've normally seen.

7819
13:05:13.142 --> 13:05:22.859
The frameworks like React and next Jas that we're going to use are going to automatically convert those yarn added packages to their front end to five versions.

7820
13:05:22.859 --> 13:05:26.373
But for this section, this is how we're going to actually import the ethers package.

7821
13:05:26.373 --> 13:05:37.364
Now the other thing we'll have to do is on our front end, we'll have to change this from type text slash JavaScript to type module changes.

7822
13:05:37.364 --> 13:05:45.792
The type module allows us to import modules into our code, which we're going to be importing this, and we're going to import another module as well.

7823
13:05:45.792 --> 13:05:46.437
Awesome.

7824
13:05:46.437 --> 13:05:55.619
And now though, if we go back to our front end, do a little refresh with the connect button, we get Connect is not defined at HTML button.

7825
13:05:55.619 --> 13:05:55.767
on.

7826
13:05:55.767 --> 13:06:06.304
Click, so instead of calling our Connect button from the front end here, we're going to remove these on clicks from our index dot HTML, and go into our index.

7827
13:06:06.304 --> 13:06:10.007
js and add those connect buttons in here.

7828
13:06:10.007 --> 13:06:12.346
So we'll say const.

7829
13:06:12.346 --> 13:06:21.674
Connect button equals document, dot get element by ID, Connect button.

7830
13:06:21.674 --> 13:06:25.487
And then we'll say const.

7831
13:06:25.487 --> 13:06:33.204
One button equals Doc, you meant dot get element by ID.

7832
13:06:33.204 --> 13:06:36.890
One button, the idea of the connect button is Connect button.

7833
13:06:36.890 --> 13:06:39.539
The idea the fun button is fun button.

7834
13:06:39.539 --> 13:06:43.056
And then we'll say connect button.

7835
13:06:43.056 --> 13:06:46.749
on Click equals connect.

7836
13:06:46.749 --> 13:06:49.208
And one button.

7837
13:06:49.208 --> 13:06:52.486
on Click equals fond.

7838
13:06:52.486 --> 13:06:55.881
We go back to our front end, do a little refresh.

7839
13:06:55.881 --> 13:06:57.071
We'll hit connect now.

7840
13:06:57.071 --> 13:07:06.557
And it's actually working, we'll go to our Metamask will disconnect, refresh, hit Connect, and boom, it's popping up again.

7841
13:07:06.557 --> 13:07:16.793
This is just due to that type being module, if it was text slash JavaScript, that on click button adding in here, but since we're doing module, we're going to add those on clicks right in our JavaScript.

7842
13:07:16.793 --> 13:07:26.471
But now that we've got ethers in here, what we can do is we can even do like a little console dot log, just paste ethers in here, or actually better yet.

7843
13:07:26.471 --> 13:07:28.777
We'll add it right above the Connect button.

7844
13:07:28.777 --> 13:07:37.622
Go back to our front end, we'll do a refresh and we see the entire ethers object right in our front end which is perfect, which is exactly what we want here.

7845
13:07:37.622 --> 13:07:48.103
And since we've got these two variables here, we might as well update this to just say connect button dot innerHTML equals connected and here as well.

7846
13:07:48.103 --> 13:07:56.916
Connects button dot innerHTML equals please install meta mask because now connect button is going to be the same as running this document dot get element by ID right here.

7847
13:07:56.916 --> 13:07:58.027
and great.

7848
13:07:58.027 --> 13:08:03.138
Let's go back to continuing our font function.

7849
13:08:03.472 --> 13:08:13.472
So we'll say const provider equals new ethers dot providers dot web three provider, window dot Aetherium.

7850
13:08:13.472 --> 13:08:32.685
Web three provider is an object in ethers that allows us to basically wrap around stuff like Metamask is web three provider is really similar to that JSON RPC provider, which we use before, which is where we put in exactly that endpoint, our alchemy endpoint, or when we're working with Metamask.

7851
13:08:32.685 --> 13:08:42.265
Here, whatever endpoint that we have in our network section is web three provider takes that HTTP endpoint and automatically sticks it in ethers for us.

7852
13:08:42.265 --> 13:08:48.972
So this line of code basically looks at our Metamask and goes, Ah, okay, I found the HTTP endpoint inside there, Metamask.

7853
13:08:48.972 --> 13:08:52.239
That's going to be what we're going to use as our provider here.

7854
13:08:52.239 --> 13:08:55.084
Since our provider is connected to our Metamask.

7855
13:08:55.084 --> 13:09:14.015
Here, we can get a signer or we can get a wallet just by running const signer equals provider, dot get signer, this is going to return whichever wallet is connected from the provider, which again, our provider is our Metamask.

7856
13:09:14.015 --> 13:09:26.266
So if we're connected with with account one, it's going to return account one as the signer connected with account two, it'll return account two, etc.

7857
13:09:26.266 --> 13:09:34.873
Now, I'm going to add console dot log signer here, and then flip to the front end now and show you what happens when we hit the fund button.

7858
13:09:34.873 --> 13:09:43.123
You can see in here we have our JSON RPC signer, the signer is going to be the account that we've connected to our front end.

7859
13:09:43.123 --> 13:09:45.373
Now we have our provider, we have our signer.

7860
13:09:45.473 --> 13:09:50.182
Now, we're going to need our contract by getting the API and the address.

7861
13:09:50.182 --> 13:09:52.311
So we're gonna need to say const.

7862
13:09:52.311 --> 13:10:10.932
Contract equals what? How are we going to get our contract? Well, this is where we're going to need to know the ABI and the address of a working with typically, what you'll see a lot of projects do since once a contract is deployed, the addresses are going to change is they're going to have some type of constants file.

7863
13:10:10.932 --> 13:10:17.243
So they'll create a new file called constants, dot j s.

7864
13:10:17.473 --> 13:10:24.769
And in here, they'll add the addresses and any API's and anything like that for us to use in our fund piece here.

7865
13:10:24.769 --> 13:10:34.196
Now, as we're developing, and as we're building, this, the backend and the front end team are gonna have to interact a little bit, or if it's just you doing the full stack, you're gonna have to interact with their back end.

7866
13:10:34.196 --> 13:10:40.013
So this is why it's so important to have both your front end and your back end code nearby.

7867
13:10:40.013 --> 13:10:46.997
So if we go back to our Hardhead, fund me project that we just made, we can find the ABI in here.

7868
13:10:46.997 --> 13:10:59.260
Once again, if we go to artifacts, go to contracts, we can go to fund me dot soul, fund me dot JSON, we can find the ABI right here, it's going to be this massive thing right here.

7869
13:10:59.260 --> 13:11:07.349
So you can go ahead, you can even copy this whole thing in this little non squiggly bracket and this little bracket here, we can copy that.

7870
13:11:07.349 --> 13:11:09.880
And then we can come back to our constant.

7871
13:11:09.880 --> 13:11:09.981
js.

7872
13:11:09.981 --> 13:11:21.670
And we can just save it as variable, we'll say Export const, Avi, e equals and paste that in there.

7873
13:11:21.670 --> 13:11:31.286
And then back in our index dot j s, we can import it with import API from constants.

7874
13:11:31.286 --> 13:11:32.067
Oops.

7875
13:11:32.067 --> 13:11:33.942
Okay, great.

7876
13:11:33.942 --> 13:11:36.910
So we have the API.

7877
13:11:36.910 --> 13:11:47.424
Well, what about the address, since we're going to be running this locally, we want to get the contract address of this locally run contract, we can do that a couple of ways.

7878
13:11:47.424 --> 13:12:00.911
One way is you can just have two windows open one with your front end code, one with your back end code, and the one with your back end code, you can run yarn, hard hat node, which will spin up our blockchain node for us, and give us the address in here.

7879
13:12:00.911 --> 13:12:01.956
Or what we can do.

7880
13:12:01.956 --> 13:12:07.843
And this will probably be a little bit easier is in your window with your front end code and create a new terminal.

7881
13:12:07.843 --> 13:12:09.735
And now we'll have two terminals running.

7882
13:12:09.735 --> 13:12:18.344
And then this second one, we're going to CD down CD dot dot, and then CD, hard hat on Me Free Code Camp.

7883
13:12:18.344 --> 13:12:22.084
And in here, we're going to run yarn, art head node.

7884
13:12:22.084 --> 13:12:34.671
And this is going to spin up our local blockchain in this second terminal in here, where we have deploying fund me deploy that address, blah, blah, blah, right here.

7885
13:12:34.671 --> 13:12:38.046
And just a reminder, if I hit this x, it just hides the terminal.

7886
13:12:38.046 --> 13:12:46.491
I can always pull it back up with terminal new terminal, and I can always hide it, but this is still running inside of my terminal.

7887
13:12:46.491 --> 13:12:47.652
So I'm going to hide it.

7888
13:12:47.652 --> 13:12:57.441
And what I can do is I can come back over to our constants folder, and at the top, we can do export const contract address.

7889
13:12:57.441 --> 13:13:01.558
equals, we'll pull the terminal back up.

7890
13:13:01.558 --> 13:13:07.238
And we'll go grab, where it says, pulling fund me deployed at right here.

7891
13:13:07.238 --> 13:13:11.507
We'll copy that address, put some quotes, and we'll paste it in.

7892
13:13:11.507 --> 13:13:17.211
And now we're also exporting the contract address, then in our index.

7893
13:13:17.211 --> 13:13:23.378
js will import the contract address with comma, contract address.

7894
13:13:23.475 --> 13:13:27.551
And now we have both the ABI and the contract address.

7895
13:13:28.475 --> 13:13:39.875
can do, we can say const contract equals new ethers dot contract of, we'll pass the contract address, pass the API, and we'll pass it the signer.

7896
13:13:39.875 --> 13:14:02.966
Now we have an ethers contract object that's connected to our signer, and we have the contract address, and we have the contract abi, now that we have a contract object, we can go ahead and start making transactions the exact same way we've made transactions before we can just run const transaction response equals a weight contract dot fund.

7897
13:14:02.966 --> 13:14:11.544
And then we'll pass a value of ethers dot utils dot parse, ether ether mount.

7898
13:14:11.544 --> 13:14:17.361
So this is going to be how we're going to go ahead and create our transaction.

7899
13:14:17.361 --> 13:14:27.943
And if you take this right now, and we go to our front, we give it a little refresh, make sure we're connected and we hit fund, we're gonna get this error value must be a string.

7900
13:14:27.943 --> 13:14:33.105
That's because at the mount right now is being passed in as nothing.

7901
13:14:33.105 --> 13:14:36.234
Now normally, we'll pass parameters directly to our functions.

7902
13:14:36.234 --> 13:14:40.076
But what we're going to do is for now is we're just going to hard code this.

7903
13:14:40.076 --> 13:14:41.342
So we'll say const.

7904
13:14:41.342 --> 13:14:45.682
At the mount equals, we'll do like 77, or something we had fun.

7905
13:14:45.682 --> 13:14:57.062
Now, what do you think's gonna happen? Well, we get this other air, insufficient funds for intrinsic transaction cost, or you might get some other error, but you're gonna get a weird error here.

7906
13:14:57.062 --> 13:15:02.122
And that's because we're not actually connected to our local hard head node right now.

7907
13:15:02.122 --> 13:15:13.101
Well, if we look at our Metamask, we're currently not connected to the right blockchain, we're connected to rink B, or main net or whatever, we need to get connected to our local host.

7908
13:15:13.101 --> 13:15:18.112
If you look in your networks, you'll actually have a local host object here already.

7909
13:15:18.112 --> 13:15:19.992
But let's just be super specific.

7910
13:15:19.992 --> 13:15:26.209
And we'll add a new network here, we're going to add something called our hard hat, local host.

7911
13:15:26.209 --> 13:15:28.882
And we'll hit Add Network and we'll add Hardhead.

7912
13:15:28.882 --> 13:15:45.555
Local host in here, the RPC URL, we can find from our node area, which we scroll to where our node is running, we can copy this URL and paste it into new RPC URL, chain ID is going to be 31337 currency symbol is going to be go or ether.

7913
13:15:45.555 --> 13:15:51.677
Even though this pop up says it might have a different currency symbol go, we're just going to put eath in here.

7914
13:15:51.677 --> 13:15:57.427
And there is no block explorer, right? Because this is a local blockchain, we're not going to have a block Explorer.

7915
13:15:57.477 --> 13:15:58.444
So we'll go ahead and hit Save.

7916
13:15:58.477 --> 13:16:00.680
And now we have an account here, which is great.

7917
13:16:01.477 --> 13:16:02.572
to our local blockchain.

7918
13:16:04.477 --> 13:16:06.445
see we're on the local hard hat.

7919
13:16:06.445 --> 13:16:07.778
And we are connected.

7920
13:16:08.477 --> 13:16:09.560
Let's refresh.

7921
13:16:09.560 --> 13:16:11.976
Let's run fund one more time.

7922
13:16:13.477 --> 13:16:15.412
transaction does indeed pop up.

7923
13:16:15.412 --> 13:16:16.315
This is great.

7924
13:16:17.477 --> 13:16:22.789
here doesn't have any money we have, we're broke, we don't have any local Hardhead Aetherium.

7925
13:16:22.789 --> 13:16:36.227
So we're actually going to need to import one of our accounts from hard hat into our meta mask, which we can do so and you can actually do this for any account with a private key so hard that gives us these accounts.

7926
13:16:36.227 --> 13:16:40.910
And we're going to import the private key of Count zero into our meta mask.

7927
13:16:40.910 --> 13:16:49.430
So we're going to copy the private key, we're going to come back to our front end, click on our meta mask, we're gonna hit this big button, we're gonna hit import account.

7928
13:16:49.477 --> 13:16:53.132
It's like type private key, and we're gonna paste our private key here.

7929
13:16:53.132 --> 13:17:07.288
A quick note, if you choose json file, remember how back in that ether section, we encrypted our key into a JSON file with a password, you can actually import accounts with that JSON file with the password.

7930
13:17:07.288 --> 13:17:12.319
So if you encrypt a key and you want to add it to meta mask, you can go ahead and add it in just like this.

7931
13:17:12.319 --> 13:17:16.977
But for now, we're going to use private key, we'll paste the private key in and we'll hit import.

7932
13:17:16.977 --> 13:17:26.398
And we can see we now have an account, a new account and account three, with a ton of eath from our local blockchain.

7933
13:17:26.477 --> 13:17:32.665
So we'll refresh one more time, we'll go ahead and connect, we'll make sure that our account three is connected.

7934
13:17:32.665 --> 13:17:35.681
And if it's not, we'll go ahead and hit this Connect button.

7935
13:17:35.681 --> 13:17:38.670
So that now our account three is what's connected here.

7936
13:17:38.670 --> 13:17:40.763
And we'll go ahead and hit fund.

7937
13:17:40.763 --> 13:17:46.838
And we now see that we can fund this contract, we can go ahead and hit Confirm.

7938
13:17:46.838 --> 13:18:01.763
And if we look and nothing's going to happen on our front end, because we didn't tell our front end to do anything once we confirm, but if we go to our blockchain, we can see our fun function was called we've just made our first transaction on a blockchain from our own front end, this is awesome, great work.

7939
13:18:01.763 --> 13:18:04.461
But it's probably a little confusing to the user.

7940
13:18:04.461 --> 13:18:06.865
If nothing happens here, they're going to hit the fun function.

7941
13:18:06.865 --> 13:18:09.363
And it's going to be like, Oh, okay, cool.

7942
13:18:09.363 --> 13:18:14.858
What, what happens? Now, we probably want to make it a little bit more obvious that something just happened.

7943
13:18:14.858 --> 13:18:24.589
And one more thing I want to show you, you don't have to follow along here, if I hit fund, and then I hit reject, it's gonna freak out on us and be like, hey, like, you hit reject, I don't know what to do now.

7944
13:18:24.589 --> 13:18:27.986
So we're going to make our code a little bit more robust by adding a try catch.

7945
13:18:27.986 --> 13:18:34.446
So we'll tell JavaScript to try running this transaction.

7946
13:18:34.446 --> 13:18:41.127
And then if it catches an error, just to console dot log, that error.

7947
13:18:41.127 --> 13:18:51.528
So now, if I hit fund, and I hit reject, it's gonna, it'll still be a little bit mad, but at least we're catching it and it's not going to break and destroy everything.

7948
13:18:51.528 --> 13:18:52.078
Okay, cool.

7949
13:18:52.078 --> 13:18:53.931
We've got a transaction response here.

7950
13:18:53.931 --> 13:18:57.228
And when we hit fund, our front end goes great.

7951
13:18:57.228 --> 13:19:02.228
You've funded me I'm I'm super confused.

7952
13:19:02.228 --> 13:19:06.396
Oh, one other point, something that you'll probably run into multiple times.

7953
13:19:06.396 --> 13:19:07.707
As we're doing this.

7954
13:19:07.707 --> 13:19:10.812
If you get an error that looks like this eath.

7955
13:19:10.812 --> 13:19:18.932
JS query while formatting outputs from RPC, nonce to high expected not to be too but got form, you will definitely see this a whole lot.

7956
13:19:18.932 --> 13:19:20.385
Here's what you do to fix this.

7957
13:19:20.479 --> 13:19:30.429
The reason this happens is because you've closed your hardhat node and then restarted it, and your heart had node goes, Okay, well, I'm starting fresh, I'm starting from zero.

7958
13:19:30.479 --> 13:19:42.412
But Metamask isn't smart enough to know that, what we want to do is we want to come to our Metamask, we'll hit this big button, we'll go down to settings, we'll go to Advanced, and we'll go to reset account.

7959
13:19:42.412 --> 13:19:44.608
And yes, we're going to reset it.

7960
13:19:44.608 --> 13:19:51.750
This isn't something ideally that you'd like to do with an actual account with actual money on a local network, this is fine.

7961
13:19:51.750 --> 13:19:57.029
Now if you reset the account, and you reset the node, we can go ahead and hit Confirm.

7962
13:19:57.029 --> 13:19:59.079
And it doesn't give us that error anymore.

7963
13:19:59.079 --> 13:20:08.305
So that's kind of the tip there, you want to reset the nuts so that our Metamask and our blockchain are in sync with that nonce number.

7964
13:20:08.479 --> 13:20:09.720
So we have this transaction response.

7965
13:20:10.479 --> 13:20:15.659
our front end to give the user some indication, hey, the transaction went through.

7966
13:20:15.659 --> 13:20:19.593
So what we want to do is we want to listen to the blockchain for this to finish.

7967
13:20:19.593 --> 13:20:23.806
So we can either listen for the TX to be mined.

7968
13:20:23.806 --> 13:20:27.248
Or we can listen for an event.

7969
13:20:27.479 --> 13:20:28.626
We haven't learned about events yet.

7970
13:20:28.626 --> 13:20:29.019
But we will.

7971
13:20:29.479 --> 13:20:33.399
since we haven't learned about events yet, we're just going to listen for the TX to be mined.

7972
13:20:33.399 --> 13:20:50.004
Or to listen for the transaction to be mined, we're actually going to create a new function called function, listen, or transaction mine in this is going to take as input a transaction response, and a provider.

7973
13:20:50.004 --> 13:20:53.085
Now you'll notice this isn't an async function.

7974
13:20:53.085 --> 13:20:54.159
For this section.

7975
13:20:54.159 --> 13:20:57.301
This is intentional, we don't want this to be an async function.

7976
13:20:57.301 --> 13:20:58.408
And you'll see why in a second.

7977
13:20:58.480 --> 13:21:03.795
We're going to be using JavaScript promise JavaScript async functionality to its massive advantage.

7978
13:21:03.795 --> 13:21:08.352
And this is why JavaScript actually works so well on the front end is because of how it's asynchronous.

7979
13:21:08.352 --> 13:21:14.130
So we're going to create this function listen for transaction to be mined, we're going to await in our fund function.

7980
13:21:14.130 --> 13:21:16.922
And we're going to have this return a promise.

7981
13:21:16.922 --> 13:21:19.381
Let's go ahead, and let's learn how to build this.

7982
13:21:19.480 --> 13:21:23.299
So we're gonna say console dot log, string interpolation, we'll say mining.

7983
13:21:23.299 --> 13:21:28.125
And then in here, we'll say transaction, response dot hash.

7984
13:21:28.125 --> 13:21:34.447
All of our transaction response objects have a hash, which just represent that hash.

7985
13:21:34.447 --> 13:21:44.896
And we'll do a couple of data dot, we'll put in our console here, we're waiting for the transaction to be mined, then what we're going to do is we're going to return a new promise.

7986
13:21:44.896 --> 13:21:53.191
And the reason we're going to return a promise is because we need to create a listener for the blockchain.

7987
13:21:53.191 --> 13:21:55.377
We want to listen for this event to happen.

7988
13:21:55.480 --> 13:22:04.221
But we want to tell JavaScript, hey, wait for this thing to finish looking, wait for this thing to finish looking.

7989
13:22:04.221 --> 13:22:06.770
Now here's where this gets a little bit tricky.

7990
13:22:06.770 --> 13:22:07.880
In our fund function.

7991
13:22:07.880 --> 13:22:16.035
After we create the transaction, we basically want to tell JavaScript Hey, wait for this TX to finish.

7992
13:22:16.035 --> 13:22:22.962
So our code is going to look as simple as await listen for transaction mine.

7993
13:22:22.962 --> 13:22:30.369
And we're going to pass it the trans action response and our provider.

7994
13:22:30.369 --> 13:22:33.462
So we're saying hey, listen for this transaction finish.

7995
13:22:33.462 --> 13:22:38.873
And we're using this await keyword, because again, the await keyword says okay, we're gonna stop right here.

7996
13:22:38.873 --> 13:22:41.231
We're gonna stop until this function is completely done.

7997
13:22:41.231 --> 13:22:46.756
Now in this listen for transaction in mind, we have to define how we're actually going to listen for this.

7998
13:22:46.756 --> 13:22:50.874
So we're going to say listen for this transaction to finish.

7999
13:22:50.874 --> 13:22:59.658
Ethers actually comes with a way for us to listen for transactions and listen for events, which again, we haven't learned About, but don't worry about that yet.

8000
13:22:59.658 --> 13:23:01.481
So we can go to the ethers docs.

8001
13:23:01.481 --> 13:23:03.081
And we can look up once.

8002
13:23:03.081 --> 13:23:04.281
Contract dot once.

8003
13:23:04.481 --> 13:23:15.174
There's a whole bunch of listeners that we can use to listen for events and listen for different things to happen, we can do this thing called provider dot once where we listen for some event.

8004
13:23:15.174 --> 13:23:20.217
And once that event fires, we call some other function that we've defined.

8005
13:23:20.217 --> 13:23:22.323
Now, we haven't talked about events yet.

8006
13:23:22.323 --> 13:23:24.623
And again, don't worry about this quite yet.

8007
13:23:24.623 --> 13:23:35.057
One of the events that we can wait for is we can just wait for the transaction receipt to finish, right, because once we get a transaction receipt, that means that the transaction has actually finished going through.

8008
13:23:35.057 --> 13:23:44.333
So we're going to use this provider dot once syntax to wait for the transaction receipt, which is going to be our event, which isn't really an event, but don't worry about that yet.

8009
13:23:44.333 --> 13:23:49.052
And then we're going to call some listener function that we defined, you can also do provider.

8010
13:23:49.052 --> 13:23:58.302
on, which will trigger anytime your event fires provider once just triggers one time, we only care about this transaction going through one time.

8011
13:23:58.302 --> 13:24:00.671
So we're passing our provider object.

8012
13:24:00.671 --> 13:24:12.127
So we're gonna say provider dot once our event which is just going to be transaction response, hash, provided on transaction response dot hash.

8013
13:24:12.127 --> 13:24:17.882
So once we get this hash, which will pretty much get right away, we're going to call our listener function.

8014
13:24:17.882 --> 13:24:22.903
Now we can create a function listener like this, and then just pass listener in here.

8015
13:24:22.903 --> 13:24:28.075
But we're going to do an anonymous function here, because that's typically what we see as the syntax for these loops.

8016
13:24:28.075 --> 13:24:34.174
And so far, we're doing provider dot once to do this anonymous function, we're going to do just two little parentheses here.

8017
13:24:34.174 --> 13:24:36.014
And this arrow notation.

8018
13:24:36.014 --> 13:24:39.762
So this by itself represents an anonymous function.

8019
13:24:39.762 --> 13:24:48.926
So we're saying, hey, there's some function, it doesn't take any parameters, and it doesn't have any code, this arrow function, this whole thing is saying this is an anonymous function.

8020
13:24:48.926 --> 13:24:53.820
So we're saying provided at once transaction hash happens, here's the function that you want to execute.

8021
13:24:53.820 --> 13:24:55.416
It doesn't do anything right now.

8022
13:24:55.416 --> 13:24:56.857
But let's have a do something.

8023
13:24:56.857 --> 13:25:10.291
So once this transaction dot response finishes, we're going to take a trans transaction received as an input parameter, or our our callback function, or our listener function.

8024
13:25:10.291 --> 13:25:28.205
And all we're going to do is we're gonna say console dot log, completed with a little string interpolation, transaction receipt, that confirmations, confirmations, and then completed with transaction receipt, confirmations, confirmations.

8025
13:25:28.205 --> 13:25:44.482
So once this provider dot once sees that there's a transaction hash, it's going to give as an input rammer to our listener function, the transaction receipt, kind of that same syntax that we've been seeing this whole time, once a transaction response finishes, we get the transaction receipt, and we can do stuff with it.

8026
13:25:44.482 --> 13:25:46.482
And we see how many block confirmations it has.

8027
13:25:46.482 --> 13:25:48.876
For us, this pretty much should always be one.

8028
13:25:48.876 --> 13:25:58.783
Now if we save this, go back to our front end, and we hit fund, it's going to work, we're going to give the user some indication that it worked, which is great.

8029
13:25:58.783 --> 13:26:02.040
But it's not really going to work the way that we want it to work.

8030
13:26:02.040 --> 13:26:17.451
We have this console dot log done right after we do the await, listen for transaction mine, and we come back and we hit fund, we hit confirm, it actually doesn't go in the order that we want it to go, it goes mining this thing that it says Done.

8031
13:26:17.451 --> 13:26:27.889
And then it says completed with one trip confirmation what what's going on here, we should write completed before we write done, because that's the order that we have this in.

8032
13:26:27.889 --> 13:26:30.939
But it looks like it's words, it's going out of order.

8033
13:26:30.939 --> 13:26:46.500
What what's going on here, what's going to happen is when we call listen for transaction mine, or listen for transaction, mine function is going to kick off, but it's going to kick off provided on once as its own process.

8034
13:26:46.500 --> 13:26:56.045
So await listen for transaction, mine will kick off the listener, but it doesn't wait for this listener to find the transaction response.

8035
13:26:56.045 --> 13:27:03.015
So this function will actually finish before provider dot once finishes.

8036
13:27:03.015 --> 13:27:10.959
So after it kicks off the listener, it'll run to the next line of our code, which is console dot log and done.

8037
13:27:10.959 --> 13:27:14.640
Our front end we'll go oh, oh, you kicked off a listener earlier.

8038
13:27:14.640 --> 13:27:19.273
Let me go back down and let me recheck to see if it's finished.

8039
13:27:19.273 --> 13:27:22.548
And if it has finished, I'll go do what it told me to do.

8040
13:27:22.548 --> 13:27:25.433
And this is where what's known as the event loop kicks in.

8041
13:27:25.483 --> 13:27:32.730
We don't actually wait for this provider that wants to finish, we add this provided at once onto this queue called the event loop.

8042
13:27:32.730 --> 13:27:37.992
And our front end is going to periodically check back to it to see if it's finished.

8043
13:27:37.992 --> 13:27:39.959
So we want to adjust our code.

8044
13:27:39.959 --> 13:27:45.391
So we wait for the listener to finish listening, which is where we're going to get into promises here.

8045
13:27:45.391 --> 13:27:49.915
So what we want to do is we want to adjust this function to now return a promise.

8046
13:27:49.915 --> 13:27:53.431
And we're going to use this syntax a couple of times in the future.

8047
13:27:53.484 --> 13:28:01.284
So what we're going to do is we're going to say hey, we want to wait for the listener To finish listening, we're going to wrap this whole thing into a promise.

8048
13:28:01.284 --> 13:28:04.449
And we're going to say return, new promise.

8049
13:28:04.449 --> 13:28:09.776
And a promise takes a function itself as an input parameter.

8050
13:28:09.776 --> 13:28:13.394
So again, we'll use kind of this anonymous function notation.

8051
13:28:13.394 --> 13:28:17.198
And it will take two input parameters resolve and reject.

8052
13:28:17.198 --> 13:28:23.502
So resolve says, hey, if this promise works correctly, call this resolve function.

8053
13:28:23.502 --> 13:28:28.422
And for us, this promise is going to be done when the listener finishes listening.

8054
13:28:28.484 --> 13:28:33.841
And then we would reject if there was some type of timeout, we're not going to write the reject function.

8055
13:28:33.841 --> 13:28:38.960
But in the future, if you were to do this for production, you'd add some timeout as the reject parameter.

8056
13:28:38.960 --> 13:28:52.139
Basically, you're saying, hey, once the listener finishes listening, we're going to resolve and if it takes too long, we're gonna say ask for you, you took too long, and instead of closing it off, here, we're going to close it off around this provider thing.

8057
13:28:52.139 --> 13:28:55.216
So we're gonna say return new promise, resolve, reject.

8058
13:28:55.216 --> 13:29:02.294
And only once this transaction gets fired, are we going to resolve this promise, like so.

8059
13:29:02.294 --> 13:29:10.151
So what is happening here, so we're going to put the resolve inside of this provider at once.

8060
13:29:10.151 --> 13:29:24.726
So we're saying, once this transaction hash is found, then we're going to call this function, we're gonna say console dot log, and then we're going to resolve so this promise only returns once a resolve or reject is called.

8061
13:29:24.726 --> 13:29:31.375
And we're telling it only resolve only finish this function once.

8062
13:29:31.485 --> 13:29:43.016
Transaction response dot hash is found, because it's going to be inside of these little squiggly parentheses for provider dot once, the promise right now only resolves after it's fired.

8063
13:29:43.016 --> 13:29:44.130
It's event here.

8064
13:29:44.130 --> 13:29:51.162
If this was really confusing, just copy paste this and move on, we're getting a little bit deeper into front end stuff here.

8065
13:29:51.162 --> 13:29:57.517
So hopefully, this was clear, if not definitely jump in to the GitHub discussions to start asking about this stuff.

8066
13:29:57.517 --> 13:30:03.207
But now that we've updated this, we can come back to our front end, we can hit the fund button.

8067
13:30:03.207 --> 13:30:05.925
And hopefully this time, everything will go in order.

8068
13:30:05.925 --> 13:30:10.412
We'll hit confirm, we see mining completed, and then we see done.

8069
13:30:10.485 --> 13:30:20.985
And the reason for this is because again, our await keyword is now waiting, it says oh, you're returning a promise, I need to await I need to wait for it to resolve or reject.

8070
13:30:20.985 --> 13:30:29.618
And we only resolve the promise once our provider finds this transaction hash and this transaction receipt, this is this listen for transaction mine.

8071
13:30:29.618 --> 13:30:32.818
In future sections, all of this is going to be abstracted away for us.

8072
13:30:32.818 --> 13:30:37.549
So life is going to be much easier, but it is important to understand what's actually going on here.

8073
13:30:37.549 --> 13:30:37.936
Awesome.

8074
13:30:37.936 --> 13:30:44.637
So now we're giving the front end some indication of what's going on.

8075
13:30:44.637 --> 13:30:49.604
Our fun function is done well, no, not really.

8076
13:30:49.604 --> 13:30:54.451
Why not? Well, because right now we're hard coding the eath amount to 0.

8077
13:30:54.451 --> 13:30:54.502
1.

8078
13:30:54.502 --> 13:31:01.930
And on the front end, we probably don't want to hard code it, we probably want to allow users to fund as much or as little as they want.

8079
13:31:01.930 --> 13:31:05.739
So we actually need to change this from just a button to a input form.

8080
13:31:05.739 --> 13:31:09.167
So to do this, we're gonna go back over into our HTML.

8081
13:31:09.167 --> 13:31:11.454
So we'll go back to index dot HTML.

8082
13:31:11.454 --> 13:31:15.356
And we're going to change this fun section here, we're going to add some form information.

8083
13:31:15.356 --> 13:31:22.223
So we're going to keep this button as it is, or we're going to add like a little text box to input as much eath as they want.

8084
13:31:22.223 --> 13:31:33.216
So I'm going to create a label, we're gonna say it's for, it's going to be fund and this label we're gonna say, is eath amount, and then we're gonna close label, this is basically just going to create a label.

8085
13:31:33.216 --> 13:31:37.879
And if we go back to our front end, we now just have this Etham out label that isn't labeling anything.

8086
13:31:37.879 --> 13:31:43.026
Now we're going to create an input, and we're going to give it an ID of eath amount.

8087
13:31:43.026 --> 13:31:47.899
And we're going to give it a placeholder of 0.

8088
13:31:47.899 --> 13:31:48.002
1.

8089
13:31:48.002 --> 13:31:51.829
And then we're gonna close the input.

8090
13:31:51.829 --> 13:31:58.693
So now if we flip to our front end, we have eath amount, labeling this little text box with a placeholder of 0.

8091
13:31:58.693 --> 13:31:58.749
1.

8092
13:31:58.749 --> 13:32:02.020
And we can add stuff in here, you know, blah, blah, whatever.

8093
13:32:02.020 --> 13:32:11.236
And one more thing, if you have some tags, but you don't put anything in between them, you can actually shorten it by just putting the little closing thing at the back of it like this.

8094
13:32:11.236 --> 13:32:19.316
So if you don't have anything between your tags, you can just close them like this, these two are equivalent, boom, boom, boom, boom, those are the same thing.

8095
13:32:19.316 --> 13:32:19.621
Great.

8096
13:32:19.621 --> 13:32:23.319
When we called fund right now we're calling fund and we're not passing any parameters.

8097
13:32:23.319 --> 13:32:40.962
Let's update our fund to no longer be hardcoding eath amount in here, and we'll have and we'll have our fund function populated by whatever we put in this eath amount input box in our fund function, instead of saying const eath amount equals 0.

8098
13:32:40.962 --> 13:32:41.060
1.

8099
13:32:41.060 --> 13:32:53.970
We'll grab it from this eath amount ID and we'll say document dot get element by ID eath amount, dot value.

8100
13:32:53.970 --> 13:33:00.656
So we're going to grab whatever value In this input box here, now, in our index.

8101
13:33:00.656 --> 13:33:06.320
js, we have console dot log funding with eath amount, if in our front end, we do 1.

8102
13:33:06.320 --> 13:33:06.403
7.

8103
13:33:06.403 --> 13:33:11.567
And we hit fund, we now see in our console dot log, it says funding with 1.

8104
13:33:11.567 --> 13:33:11.647
7.

8105
13:33:11.647 --> 13:33:12.937
And we'll get 1.

8106
13:33:12.937 --> 13:33:13.017
7.

8107
13:33:13.017 --> 13:33:19.674
And our little fun section confirm, it will mine it, it'll complete it, and then say, done.

8108
13:33:19.674 --> 13:33:20.174
Awesome.

8109
13:33:20.174 --> 13:33:22.978
So now we've added a little text box here.

8110
13:33:22.978 --> 13:33:25.962
So people can fund as much or as little as they want.

8111
13:33:25.962 --> 13:33:29.418
Perfect, this whole thing can kind of be considered a form.

8112
13:33:29.418 --> 13:33:34.437
There's also a form tag, but we're going to just use this for now.

8113
13:33:34.437 --> 13:33:35.830
All right, great.

8114
13:33:35.830 --> 13:33:46.300
We're doing a lot of funding right, and we keep funding our contract with more and more Ethan, we keep adding more and more stuff, we probably want a button to keep track of how much is actually in here.

8115
13:33:46.300 --> 13:33:48.782
So let's just add a really simple balance button.

8116
13:33:48.782 --> 13:33:52.978
And let me actually just move this down to the bottom here, much better.

8117
13:33:52.978 --> 13:33:57.294
So we'll say button, id equals balance button.

8118
13:33:57.294 --> 13:34:00.794
We'll call it get balance.

8119
13:34:00.794 --> 13:34:03.978
Now we have a get balanced button.

8120
13:34:03.978 --> 13:34:06.723
And it's not going to do anything because we don't have a get balanced function.

8121
13:34:06.723 --> 13:34:08.402
So let's go back to our index.

8122
13:34:08.402 --> 13:34:08.605
js.

8123
13:34:08.605 --> 13:34:14.694
And we'll create a get bounced function async function get bounce.

8124
13:34:14.694 --> 13:34:17.834
And we'll just do what we've been doing so far.

8125
13:34:17.834 --> 13:35:07.453
If type of window dot Aetherium does not equal, undefined, then we're going to do const provider equals new ethers, ethers, dot providers dot web three provider of window, that Aetherium then will do const balance equals awaits provider dot get balance, contract address, which again, we're importing way up at the top, and then we'll just do console dot log ethers dot utils dot format, ether, bounce this format ether function ethers utils, which you can find in the documentation to make reading ethers, formatted numbers much easier to read.

8126
13:35:07.453 --> 13:35:23.049
Then same as what we've been doing before, we're going to go up, we're going to copy this fun button line, paste it will say balance button equals document dot get element by ID, balance button.

8127
13:35:23.049 --> 13:35:34.826
And then we'll say balance button on click equals get balance, we're gonna come back to our front end, we'll do a quick refresh, we'll do get balance.

8128
13:35:34.826 --> 13:35:39.154
And now we can see the balance in the console, we can fund with more like 1.

8129
13:35:39.154 --> 13:35:49.649
8, we'll hit fund metamath pops up, we'll go ahead and confirm mining completed done, we hit get balanced, and now we're at 3.

8130
13:35:49.649 --> 13:35:49.761
8.

8131
13:35:49.761 --> 13:35:50.890
Fantastic.

8132
13:35:50.890 --> 13:35:53.747
Alright, let's keep it going.

8133
13:35:53.747 --> 13:35:57.116
What do we need to do next, we're gonna go ahead and eat our withdrawal function here.

8134
13:35:57.116 --> 13:36:01.301
So let's create that this is gonna look really similar to everything we've done so far.

8135
13:36:01.301 --> 13:36:12.015
So on our index dot HTML, let's create a new button that we can do by copying this whole line, paste it underneath, call this withdraw button, we'll call withdraw.

8136
13:36:12.015 --> 13:36:14.134
And we'll call this withdraw.

8137
13:36:14.134 --> 13:36:20.902
And then in our index, do the same thing, we'll copy this, paste it below.

8138
13:36:20.902 --> 13:36:29.965
So with drop button was document get element by ID, withdraw button, withdraw button.

8139
13:36:29.965 --> 13:36:31.910
on Click equals withdraw.

8140
13:36:31.910 --> 13:36:35.168
So let's make a withdrawal function down at the bottom.

8141
13:36:35.168 --> 13:36:38.111
We'll go ahead, say async.

8142
13:36:38.111 --> 13:36:42.689
Function withdraw, will do the exact same that we've done above.

8143
13:36:42.689 --> 13:36:49.278
And I can even just copy everything from the get balance and just remove the balance section.

8144
13:36:49.278 --> 13:36:55.695
If type of window dot Aetherium does not equal to undefined, then we'll grab the provider here.

8145
13:36:55.695 --> 13:37:00.239
And same as the fund contract, we'll grab the signer and the contract.

8146
13:37:00.239 --> 13:37:02.039
So let's just grab those two lines.

8147
13:37:02.039 --> 13:37:06.040
Paste them down here called signer equals provider dot get signer.

8148
13:37:06.040 --> 13:37:08.385
Contract equals new contract, blah, blah, blah.

8149
13:37:08.385 --> 13:37:08.764
Okay, cool.

8150
13:37:08.764 --> 13:37:12.833
Now we're gonna do the exact same here as we did with the fun function.

8151
13:37:12.833 --> 13:37:19.735
So we're gonna do a little try, catch, and then we'll even add the catch here, catch error, console dot log error.

8152
13:37:19.735 --> 13:37:30.264
And inside of our try, we'll do const transaction response equals await, contracts dot withdraw.

8153
13:37:30.264 --> 13:37:33.102
We don't need to put any parameters in here.

8154
13:37:33.102 --> 13:37:41.119
Oh, then actually, let's do a little console dot log, withdrawing, and then we'll get this transaction response.

8155
13:37:41.119 --> 13:37:44.052
And then we'll listen for this transaction to get mined as well.

8156
13:37:44.052 --> 13:38:02.283
By running a Wait, listen for transaction mine transaction response comma, provider And that's it, since we can reuse the functionality from our listen for transaction mine.

8157
13:38:02.283 --> 13:38:08.061
So now we'll refresh, we'll make sure we're connected, check the current balance, which is 3.

8158
13:38:08.061 --> 13:38:08.156
8.

8159
13:38:08.156 --> 13:38:11.203
Now we'll go ahead and withdraw.

8160
13:38:11.490 --> 13:38:15.036
We see our little withdrawing console dot log, we'll hit Confirm.

8161
13:38:15.036 --> 13:38:24.677
And it looks like we've completed it, if we look in our Metamask, our bounced will have been increased by the amount that was added here.

8162
13:38:24.677 --> 13:38:32.290
And now if we hit balance, we do indeed see zero, we can even double check that this is actually working, we can see our balance is 9.

8163
13:38:32.290 --> 13:38:32.423
99.

8164
13:38:32.423 --> 13:38:35.839
Let's go ahead and even fund this with 99 eath.

8165
13:38:35.839 --> 13:38:39.013
Good confirm, looks like it's completed.

8166
13:38:39.013 --> 13:38:41.354
Our meta mask now shows 99.

8167
13:38:41.354 --> 13:38:41.523
00.

8168
13:38:41.523 --> 13:38:51.627
And if we go ahead and withdraw, confirm, that withdrawal has gone through, we can see our balance is back up to 9999.

8169
13:38:51.627 --> 13:38:55.973
And now let's just go back and change.

8170
13:38:55.973 --> 13:38:57.343
Hey, what's good.

8171
13:38:57.343 --> 13:38:59.601
We'll refresh our front end.

8172
13:38:59.601 --> 13:39:08.347
And now we can see you've done it, we've created a minimalistic website that allows us to connect to the blockchain and call functions from a front end.

8173
13:39:08.347 --> 13:39:14.523
And from a website, this is absolutely massive, you should be incredibly proud and incredibly excited with yourself.

8174
13:39:14.523 --> 13:39:16.841
Now, this is definitely a minimalistic version.

8175
13:39:16.841 --> 13:39:20.797
And we're going to work with more powerful and more modern front end frameworks.

8176
13:39:20.797 --> 13:39:28.441
But this will give you an idea of exactly what's going on behind the scenes when we're working with those more advanced front ends, and we'll style them up.

8177
13:39:28.491 --> 13:39:30.491
So they look a little bit better than this.

8178
13:39:31.491 --> 13:39:34.694
said, you've just learned the basics of how these front ends work.

8179
13:39:34.694 --> 13:39:45.007
And now that you know how to push things up to get, I highly recommend you start pushing all of these projects up to your GitHub, they will be a record that you've actually done the work and you've built these smart contracts.

8180
13:39:45.007 --> 13:39:58.216
And if you're looking to get an internship down the line, if you're looking to help other GitHub projects, this will be a record of hey, I can do this, what I can build look at what I know how to do so congratulations on your first full stack or your first front end application.

8181
13:39:58.216 --> 13:40:02.118
Before we move on, let's do a quick refresher of everything we've learned here.

8182
13:40:02.118 --> 13:40:06.053
So number one, typically, you want the repository or your code base.

8183
13:40:06.053 --> 13:40:13.473
For your back end for your smart contracts to be a different repository than your front end, your front end code is going to be a combination of HTML and JavaScript.

8184
13:40:13.473 --> 13:40:21.157
When we have a wallet like meta mask, we're injecting these browser based wallets into the window object of our browsers like window dot Aetherium.

8185
13:40:21.157 --> 13:40:28.991
Each browser will have a different extension here, reason we do this, we want to connect to the RPC URL that's built into our meta masks.

8186
13:40:28.991 --> 13:40:59.253
And in this way, we're making the same API calls to an RPC URL as we do in hard hat as we do in remix as we do in ethers, etc, we created our first promise based function where we had a listener kickoff, and we wrapped it in a promise to say, hey, we want to wait for our listener to finish since this is a promise based function, we set a weight listen for transaction mind and we waited for this transaction to finish so that on our front end, once our transaction finished going through, we can tell the user it's finished going through and we can continue doing other stuff.

8187
13:40:59.253 --> 13:41:04.412
Give yourself that round of applause and let's move on to the next section.

8188
13:41:04.492 --> 13:41:07.025
All right, welcome to the next section.

8189
13:41:08.492 --> 13:41:16.614
Nine, our hardhat smart contract lottery, which again, all the code for this section is going to be available in the GitHub repo associated with this course.

8190
13:41:16.614 --> 13:41:18.427
Alright, so let me show you what we're about to build.

8191
13:41:18.427 --> 13:41:22.692
I'm going to show you the front end login, you don't have to do the front end, if you don't want.

8192
13:41:22.692 --> 13:41:26.599
But the front end does give us a nice way to visualize the lottery that we're building.

8193
13:41:26.599 --> 13:41:35.015
Here, we're building an application that allows users completely decentralized to allow us to engage in a fair, a verifiably random lottery.

8194
13:41:35.015 --> 13:41:41.379
This is the application that would actually fix the McDonald's issue that we talked about much earlier.

8195
13:41:41.379 --> 13:41:45.965
So first, we got this Kinect Wallet button that we're going to click to connect to meta mask.

8196
13:41:45.965 --> 13:41:54.992
And here, we're actually going to show you how to connect to more than just Metamask wallet connect to trust wallet, math, wallet, any of these wallets, and we'll show you how to customize even more.

8197
13:41:54.992 --> 13:41:56.984
So we're going to connect to Metamask.

8198
13:41:56.984 --> 13:42:03.224
Here, we'll choose our account that we imported in from Hardhead, we choose Next we're gonna choose Connect.

8199
13:42:03.224 --> 13:42:10.158
And remember, for our front end bit, we're gonna go to Settings Advanced reset account, if we're working with a brand new hard hat blockchain.

8200
13:42:10.158 --> 13:42:13.943
Now, the front end doesn't look super nice, but we have an enter raffle button.

8201
13:42:13.943 --> 13:42:20.262
And we have a little bit of UI talking about the current number of players and then the most previous winner of a raffle.

8202
13:42:20.262 --> 13:42:25.242
So we can go ahead and enter the raffle and allow anybody to pay 0.

8203
13:42:25.242 --> 13:42:25.742
1 eath.

8204
13:42:25.742 --> 13:42:37.429
To enter our smart contract, we get a little transaction saying transaction complete, and we get the current number of players is one, we can continue to enter the raffle and anybody can enter this raffle.

8205
13:42:37.493 --> 13:42:46.071
And this, the smart contract will keep track of all the players in here, we're going to run this on a timer, the lottery is going to automatically trigger somebody to win.

8206
13:42:46.071 --> 13:42:53.880
And to do this, to get a pure verifiable random number, we're going to be using chain link VRF to get a pure verifiably random number.

8207
13:42:53.880 --> 13:43:04.001
And then we're gonna use chain link keepers to trigger the automation to automatically have one of these winners get picked every time one of those time intervals is up.

8208
13:43:04.001 --> 13:43:10.438
Once the keepers kick it off, they will pick a winner, our decentralized lottery will say the most previous winner is so and so.

8209
13:43:10.493 --> 13:43:21.393
And they will get all the money from this lottery making a perfectly fair decentralized lottery, we're going to call our contract, raffle dot soul but you can call it lottery dot soul or really whatever you want.

8210
13:43:21.393 --> 13:43:23.459
And we're going to make it look really, really nice.

8211
13:43:23.459 --> 13:43:25.689
So now we're back in our Visual Studio code.

8212
13:43:25.689 --> 13:43:27.262
This is going to be the project.

8213
13:43:27.262 --> 13:43:34.935
If you learn this, you have the skills to learn all the rest of the smart contract concepts, and you are going to be able to do great things in the space.

8214
13:43:34.935 --> 13:43:43.493
This is going to be your flagship project, this is going to be the one that you can be the most excited and the most proud about for this tutorial.

8215
13:43:43.493 --> 13:43:47.738
So let's go ahead and let's create a new folder.

8216
13:43:47.738 --> 13:44:00.283
So we're gonna do MK dir, hardhat, smart contract lottery, FCC or smart contract, raffle, whatever you want to call it, then we're going to cd into our hard hat, smart contract lottery Free Code Camp.

8217
13:44:00.283 --> 13:44:05.624
And we're going to type code period, or we're going to open this up in a new folder, however we choose to do.

8218
13:44:05.624 --> 13:44:10.461
So now that we're in our new folder, we're going to create our new hard hat project.

8219
13:44:10.461 --> 13:44:16.397
So we're going to do yarn, add dash dash dev hard hat.

8220
13:44:16.397 --> 13:44:22.619
And we'll get our node modules are package dot JSON and our yarn dot lock.

8221
13:44:22.619 --> 13:44:24.114
Now we'll do yarn hardhat.

8222
13:44:24.114 --> 13:44:32.127
To get started with a new project, and we're just going to select create an empty hard hat dot config dot j s because we know what a basic project looks like.

8223
13:44:32.127 --> 13:44:37.327
And we're gonna give this project the customizations that we want to see, we're going to create an empty hard hat dot config.

8224
13:44:37.327 --> 13:44:40.597
And now in here we have a blank hardhead.

8225
13:44:40.597 --> 13:44:41.114
config.

8226
13:44:41.114 --> 13:44:43.094
js with almost nothing in here.

8227
13:44:43.094 --> 13:44:44.822
So we're starting completely from scratch.

8228
13:44:44.822 --> 13:44:47.400
Now we're going to add all of our dependencies in here.

8229
13:44:47.494 --> 13:44:54.838
And oftentimes, you'll add these sequentially as you build but we're just going to add them all in one line, and there are a lot of them.

8230
13:44:54.838 --> 13:45:03.003
So we've left a copy, paste the whole section of the full blockchain solidity course, J S, for you to just copy, paste, so you can install everything in one go.

8231
13:45:03.003 --> 13:45:06.332
So grab that line, and it's going to have everything that we've been talking about.

8232
13:45:06.332 --> 13:45:10.382
And we'll just hit enter, and we'll install all of these.

8233
13:45:10.494 --> 13:45:17.528
And as you create more and more projects, you'll get the feel of what you like for your dependencies and what tools that you like to use.

8234
13:45:17.528 --> 13:45:24.178
Remember, at the end of the day, the tool that's best for you and best for the job is the tool that you like the most.

8235
13:45:24.178 --> 13:45:29.287
There never really is a one tool fits all, there's almost always going to be trade offs.

8236
13:45:29.287 --> 13:45:38.690
Alright, now that we have all those dependencies installed, if we look at our package, JSON will have this massive dev dependencies, we'll have everything in Node modules will have everything in yarn dot lock.

8237
13:45:38.690 --> 13:45:45.427
And of course, as we know, in order for any of these to actually work, we need to add them into our Hardhead config.

8238
13:45:45.494 --> 13:45:48.036
Now, there's a lot of stuff to add in here as well.

8239
13:45:48.494 --> 13:46:02.029
once again, if you want to come to the heart at smart contract, lottery, FCC, and go to the Hardhead config, you can just copy paste everything and place it into your project so that you don't have to always type everything out yourself.

8240
13:46:02.029 --> 13:46:09.850
Meclabs Hardhead waffle anomic labs started ether scan harder to deploy slitted coverage, or had gas reporter heart had contract sizer, which we haven't talked about yet.

8241
13:46:09.850 --> 13:46:10.807
But we will Don't worry.

8242
13:46:10.807 --> 13:46:13.057
And then require dot env dot config.

8243
13:46:13.057 --> 13:46:18.807
And as you all know, all these little semicolons are popping up and those are going to drive me absolutely crazy.

8244
13:46:18.807 --> 13:46:21.447
So once again, we can create a dot prettier, RC.

8245
13:46:21.447 --> 13:46:27.995
And if you want to copy this as well, from one of your previous projects are free to do so.

8246
13:46:27.995 --> 13:46:31.628
One thing that I added in here was a print width of 100.

8247
13:46:31.628 --> 13:46:35.672
This just changes how long a line can be before it goes on to a new line.

8248
13:46:35.672 --> 13:46:37.187
That's the only difference here.

8249
13:46:37.187 --> 13:46:40.806
Now if we go to our config and hit save, they go away, thank goodness.

8250
13:46:40.806 --> 13:46:45.114
Now if we look at our solidity version, we're currently using zero point 7.

8251
13:46:45.114 --> 13:46:45.161
3.

8252
13:46:45.161 --> 13:46:47.945
Let's go ahead and update that to 8.

8253
13:46:47.945 --> 13:46:48.245
8 or 8.

8254
13:46:48.245 --> 13:46:49.745
7, or whatever you want to use.

8255
13:46:49.745 --> 13:46:54.600
Now that we have all the basic setup, we can begin coding our smart contracts.

8256
13:46:54.600 --> 13:47:03.253
So we first need to create a new folder called contracts where we're going to store all of our contracts.

8257
13:47:03.253 --> 13:47:09.035
And let's go ahead and create a new file called lottery dot soul or raffle dot soul or whatever you want to call it.

8258
13:47:09.035 --> 13:47:11.219
I'm going to call mine raffle dot soul.

8259
13:47:11.219 --> 13:47:15.341
And you might see this indexing thing happened from time to time.

8260
13:47:15.341 --> 13:47:19.695
It's our hard hat, solidity extension, indexing all of our node modules.

8261
13:47:19.695 --> 13:47:24.209
So it knows how to highlight things and knows how to work with everything in our solidity files.

8262
13:47:24.209 --> 13:47:26.331
So that's what happens when that pops up.

8263
13:47:26.331 --> 13:47:30.066
Now before we jump in and create it, let's figure out what we're going to do.

8264
13:47:30.066 --> 13:47:32.199
So we're going to create our raffle contract.

8265
13:47:32.199 --> 13:47:42.649
And what do we want people able to do? Well, we probably want people be able to enter the lottery, you know, paying some amount, we're probably going to want to be able to pick a random winner.

8266
13:47:42.649 --> 13:47:47.446
But we want this to be verifiably random, we want this to be untampered with a bowl.

8267
13:47:47.496 --> 13:47:57.430
And we also want winner to be selected every X minutes or years or months, aka we want this to be completely automated.

8268
13:47:57.496 --> 13:48:03.257
So we want to deploy the smart contract and almost have no maintenance almost have nobody ever have to touch it again.

8269
13:48:03.257 --> 13:48:04.737
And it'll just automatically run forever.

8270
13:48:04.737 --> 13:48:06.285
This is the power of smart contracts.

8271
13:48:06.285 --> 13:48:18.185
As we know, since we're picking a random number, and we have some event driven execution, we know that we're going to need to use a chain link Oracle, since we're going to need to get the randomness from outside the blockchain.

8272
13:48:18.185 --> 13:48:22.116
And we're going to need to have that automated execution.

8273
13:48:22.116 --> 13:48:27.733
Because a smart contract can execute itself, we need somebody to automatically trigger these.

8274
13:48:27.733 --> 13:48:31.846
So to trigger selecting a winner, we're gonna have to use the chain link keepers.

8275
13:48:31.846 --> 13:48:34.396
And that's pretty much going to be our entire code.

8276
13:48:34.496 --> 13:48:37.254
Now, I usually like to do this before I start any project.

8277
13:48:37.496 --> 13:48:49.338
the reason that I do a little bit of brainstorming is because we don't want to just jump in and really do anything, we want to have a good idea of what we're trying to build so that we can write tests for it, so that we can know if we're going in the right direction, etc.

8278
13:48:49.338 --> 13:48:53.157
Now that we have a good idea of where we're going, let's build it.

8279
13:48:53.157 --> 13:48:57.237
So per usual, let's do spdx license identifier.

8280
13:48:57.237 --> 13:49:02.972
And my team will do pragma solidity little caret here, zero point 8.

8281
13:49:02.972 --> 13:49:18.297
7, even zoom out, just a hair will trash that and we'll say contract, raffle, we can even make sure that we're not going crazy by doing a little yarn Hardhead compile and compiled successfully, we want it to be able to enter the lottery want us to be able to enter it.

8282
13:49:18.297 --> 13:49:21.763
So maybe we'll create a function called enter raffle.

8283
13:49:21.763 --> 13:49:25.309
What else do we want to do, we want to be able to pick a random winner.

8284
13:49:25.309 --> 13:49:30.684
So maybe we'll create a function called pick a random winner, and boom.

8285
13:49:30.684 --> 13:49:32.934
So let's comment out pick random winner for now.

8286
13:49:32.934 --> 13:49:35.425
And let's just work on this enter raffle thing.

8287
13:49:35.425 --> 13:49:46.221
In the past, we've created projects like Funmi, where people can send ether to our contracts or send whatever native blockchain token to our smart contracts using the message dot value based off of some USD value.

8288
13:49:46.221 --> 13:49:52.063
For this one, we're just going to have the entrance fee instead be USD based, it's just going to be that native asset.

8289
13:49:52.063 --> 13:49:56.862
So for our enter raffle, we don't have to set a USD price, we can just set a minimum eath price.

8290
13:49:56.862 --> 13:50:00.005
So up at the top, let's pick our minimum price.

8291
13:50:00.005 --> 13:50:02.339
So we'll do a un 256 entrance fee.

8292
13:50:02.339 --> 13:50:12.446
And now some of our learnings from our last section should come in here, we now know that this entrance fee is going to be a what, it's going to be a storage variable.

8293
13:50:12.497 --> 13:50:17.981
So let's prepend it with s underscore let's make a private variable because we always want to set our visibility.

8294
13:50:17.981 --> 13:50:20.444
But let's have the entrance fee be configurable.

8295
13:50:20.444 --> 13:50:22.441
Well, let's create a constructor now.

8296
13:50:22.441 --> 13:50:34.087
And we'll have this entrance fee be settable in our constructor, so our constructor will take a UNT two to the sixth entrance fee, s underscore entrance fee equals entrance fee.

8297
13:50:34.087 --> 13:50:38.890
Well, if we're gonna only set this one time, we might as well make this a constant or an immutable variable.

8298
13:50:38.890 --> 13:50:51.078
So let's make this an immutable variable so that we save some gas we'll change this from S to I and now we're saying you interviewed six private immutable I entrance fee equals entrance fee.

8299
13:50:51.078 --> 13:50:54.514
Now we probably are going to want other users to see the entrance fee.

8300
13:50:54.514 --> 13:51:05.108
So down below, we can create function get entrance fee, and this will be a public view function which will returns a UN to the set Next, and we'll just say return entrance fee.

8301
13:51:05.108 --> 13:51:08.514
Now we have a function that users can call to get the entrance fee.

8302
13:51:08.514 --> 13:51:13.040
But we, as developers can use this AI entrance fee to know this is an immutable variable.

8303
13:51:13.040 --> 13:51:41.294
This is pretty cheap gas wise for us to read from in our enter raffle, we've done a ton of these before, all we need to do is we just need to require the message dot value is greater than that I underscore entrance fee, what we've learned before about those error codes, so we could use require message dot value, or we could do one of these customers, which is going to be a lot more gas efficient, because instead of storing this string, we're just going to store an error code in our smart contract.

8304
13:51:41.294 --> 13:51:42.137
So let's do that.

8305
13:51:42.137 --> 13:51:53.225
Instead, we'll say if the message dot value is less than our eye entrance fee, then we're just going to revert the whole transaction with some error code.

8306
13:51:53.225 --> 13:52:00.924
And we'll use a best practice naming raffle underscore underscore not enough eath entered.

8307
13:52:00.924 --> 13:52:03.450
And we'll grab this arrow code.

8308
13:52:03.450 --> 13:52:17.707
And we'll have if the user doesn't send enough value will revert with not enough eath entered now that we know they're calling into raffle with enough value, we're probably going to want to keep track of all the users who actually enter our raffle.

8309
13:52:17.707 --> 13:52:20.707
That way, when we pick a winner, we know who's in the running.

8310
13:52:20.707 --> 13:52:23.921
So let's create an array of players at the top error here.

8311
13:52:23.921 --> 13:52:28.411
And then just to make this look even nicer, we'll do a little comment here.

8312
13:52:28.411 --> 13:52:29.971
And we'll say state variables.

8313
13:52:29.971 --> 13:52:35.022
And we'll combine both our storage and are not storage variables just in this state variable section.

8314
13:52:35.022 --> 13:52:37.859
So we'll do address array players.

8315
13:52:37.859 --> 13:52:45.770
Now players, of course, is going to have to be in storage, because we're going to modify this a lot, we're going to be adding and subtracting players all the time.

8316
13:52:45.770 --> 13:52:49.958
So we're going to do s players will make this private as well.

8317
13:52:49.958 --> 13:52:56.514
And we're going to make this address payable players because one of these players wins, we're going to need to have to pay them.

8318
13:52:56.514 --> 13:52:59.728
So we'll make this address payable private as players.

8319
13:52:59.728 --> 13:53:06.114
And since we're going to make this private, and it's probably good that we know who's in the players array, we'll even do function it player.

8320
13:53:06.114 --> 13:53:12.405
This will be a public view that returns an address of one of these players.

8321
13:53:12.405 --> 13:53:22.879
And we'll just return s players of index will have this function, take a un 256 index as an input parameter, we know that players is going to be a storage variable.

8322
13:53:22.879 --> 13:53:29.981
And we're going to add it to our enter raffle Oh, and we definitely want our Inter raffle to be public and to be payable.

8323
13:53:29.981 --> 13:53:35.869
Since we're having people send message dot value, and we want anyone to be able to enter our raffle.

8324
13:53:35.869 --> 13:53:38.467
So it'll be public, it'll be payable, it'll be perfect.

8325
13:53:38.467 --> 13:53:45.963
Now that we have our array, and someone's entered the raffle, we'll do s players dot push message dot sender.

8326
13:53:45.963 --> 13:53:51.806
Now, this doesn't actually work because message dot sender isn't a payable address.

8327
13:53:51.806 --> 13:53:56.837
So we'll need to typecast it as a payable address just by wrapping it in payable.

8328
13:53:56.837 --> 13:54:01.239
So now we have a way to keep track of all the players that are entering a raffle.

8329
13:54:01.239 --> 13:54:07.386
Now one of the concepts that we haven't gone over yet is actually going to be events.

8330
13:54:07.386 --> 13:54:10.277
And events are really important to our smart contracts.

8331
13:54:10.277 --> 13:54:17.911
Whenever we update a dynamic object, like an array or a mapping, we always want to omit an event when we get to less than 10.

8332
13:54:17.911 --> 13:54:26.125
And then especially less than 15 with the next Jas and if T marketplace, these events will make a ton of sense, especially for front end developers.

8333
13:54:26.125 --> 13:54:30.951
So right now events might be a little bit of a weird thing for you as we explain it.

8334
13:54:30.951 --> 13:54:33.637
But as we continue on, they'll start to make more and more sense.

8335
13:54:33.637 --> 13:54:36.428
So we're going to start adding events to our smart contracts.

8336
13:54:36.428 --> 13:54:39.800
Whenever we update one of these dynamically sized data structures.

8337
13:54:39.800 --> 13:54:41.656
And to learn more about events and how to use them.

8338
13:54:41.656 --> 13:54:44.270
We're gonna watch another video that explains all about events.

8339
13:54:44.270 --> 13:54:47.450
You can actually follow along with this video as a side project.

8340
13:54:47.450 --> 13:54:48.921
But let's learn all about events.

8341
13:54:48.921 --> 13:54:55.833
Now, if you've worked with solidity, you've probably seen these things called events before or maybe you haven't seen something like events.

8342
13:54:55.833 --> 13:55:01.221
But you've always wondered how chain link or the graph or some of these other off chain protocols work under the hood.

8343
13:55:01.221 --> 13:55:08.714
And in this video, we're gonna learn about logging and events in solidity, viewing those events on ether scan, and then working with them in hard hat.

8344
13:55:08.714 --> 13:55:11.999
Now it's the Ethereum virtual machine, or EVM.

8345
13:55:11.999 --> 13:55:15.245
That makes a lot of these block chains tick, like Aetherium.

8346
13:55:15.245 --> 13:55:19.435
And the EVM has this functionality called a logging functionality.

8347
13:55:19.500 --> 13:55:28.696
When things happen on a blockchain, the EVM writes these things to a specific data structure called its log, we can actually read these logs from our blockchain nodes that we run.

8348
13:55:28.696 --> 13:55:36.000
In fact, if you run a node or you connect to a node, you can make a F get logs call to get the logs.

8349
13:55:36.000 --> 13:55:40.008
Now inside these logs is an important piece of logging called events.

8350
13:55:40.008 --> 13:55:43.448
And this is the main piece that we're gonna be talking about today.

8351
13:55:43.500 --> 13:55:52.567
events allow you to print information to this logging structure in a way that's more gas efficient than actually saving it to something like a storage variable.

8352
13:55:52.567 --> 13:55:58.371
These events and logs live in this special data structure that isn't accessible to smart contracts.

8353
13:55:58.371 --> 13:56:10.907
That's why it's cheaper because smart contracts can access them so that If the trade off here, we can still print some information that's important to us without having to save it in a storage variable, which is going to take up much more gas.

8354
13:56:10.907 --> 13:56:17.501
Each one of these events is tied to the smart contract or account address that emitted this event in these transactions.

8355
13:56:17.501 --> 13:56:19.839
listening for these events is incredibly helpful.

8356
13:56:19.839 --> 13:56:25.190
Let's say for example, you want to do something every time somebody calls a transfer function.

8357
13:56:25.190 --> 13:56:34.009
Instead of always reading all the variables and looking for something to flip and switch, all you have to do is say, listen for event.

8358
13:56:34.009 --> 13:56:36.551
So a transaction happened, an event is emitted.

8359
13:56:36.551 --> 13:56:38.262
And we can listen for these events.

8360
13:56:38.262 --> 13:56:40.813
This is how a lot of off chain infrastructure works.

8361
13:56:40.813 --> 13:56:53.286
When you're on a website, and that website reloads when a transaction completes, it actually was listening for that transaction to finish listening for that event to be emitted, so that it could reload or it could do something else.

8362
13:56:53.286 --> 13:56:55.957
It's incredibly important for front ends.

8363
13:56:55.957 --> 13:57:01.132
It's also incredibly important for things like chain link, and the graph in the chain link network.

8364
13:57:01.132 --> 13:57:07.876
A chain link node is actually listening for request data events for to get a random number, make an API call, or etc.

8365
13:57:07.876 --> 13:57:10.376
Sometimes there are way too many events.

8366
13:57:10.376 --> 13:57:17.534
And you need to index them in a way that makes sense that you can query all these events that happen at a later date.

8367
13:57:17.534 --> 13:57:23.018
The graph listens for these events and stores them in the graph so that they're easy to query later on.

8368
13:57:23.018 --> 13:57:25.362
So events are incredibly powerful.

8369
13:57:25.501 --> 13:57:26.693
And they have a wide range of uses.

8370
13:57:27.501 --> 13:57:30.066
testing and some other stuff, but you get the picture.

8371
13:57:30.502 --> 13:57:31.052
really sick.

8372
13:57:33.502 --> 13:57:38.859
what they look like how we can use them and how we might use them in our smart contract development suite.

8373
13:57:38.859 --> 13:57:41.312
Now here's what an event is going to look like.

8374
13:57:41.312 --> 13:57:43.792
We have an event here called stored number.

8375
13:57:43.792 --> 13:57:47.592
So we have basically a new type of event called stored number.

8376
13:57:47.592 --> 13:57:56.911
We're saying, hey, solidity, hey, smart contract, we have this new event thing, we're going to be omitting things of typed stored number in the future.

8377
13:57:56.911 --> 13:58:01.846
When we emit this event, it's going to have these four parameters, it's going to have a unique 256.

8378
13:58:01.846 --> 13:58:02.983
For called old number.

8379
13:58:02.983 --> 13:58:09.028
Are you interested? Is it called new number are you intimidated six called add a number and an address called center.

8380
13:58:09.028 --> 13:58:17.108
Now for the astute people here, you might have noticed that there was another keyword in here, the index to keyword and this is a really important keyword.

8381
13:58:17.108 --> 13:58:27.157
When we omit one of these events, there are two kinds of parameters, there are the index parameters and the non indexed parameters, you can have up to three index parameters.

8382
13:58:27.157 --> 13:58:28.879
And they're also known as topics.

8383
13:58:28.879 --> 13:58:33.090
So if you see a topic, you know that that's going to be an indexed parameter.

8384
13:58:33.090 --> 13:58:40.295
Index parameters are parameters that are much easier to search for, and much easier to query than the non index parameters.

8385
13:58:40.295 --> 13:58:46.036
In fact, we recommend F get logs function, it even has a parameter allows us to search for specific topics.

8386
13:58:46.036 --> 13:58:49.847
So it's much more searchable than the non indexed ones.

8387
13:58:49.847 --> 13:58:56.453
The non indexed ones are harder to search because they get ABI encoded, and you have to know the API in order to decode them.

8388
13:58:56.502 --> 13:59:08.928
Now, this is told our smart contract that there is a new type of stored number, a new kind of event here, we need to actually emit that event in order to store that data into the logging data structure of the EVM.

8389
13:59:08.928 --> 13:59:12.125
To do that, we need to do something that looks like this.

8390
13:59:12.125 --> 13:59:17.128
This is what it looks like when we emit an event, it looks very similar to calling a function.

8391
13:59:17.128 --> 13:59:21.034
So you call a mitt and then the name of the event.

8392
13:59:21.034 --> 13:59:24.115
And then you add all the parameters in there that you like.

8393
13:59:24.115 --> 13:59:30.454
Here's the full example of a smart contract that has an event and is going to be the example that we walked through in hard hat.

8394
13:59:30.503 --> 13:59:36.083
Now in this smart contract, whenever anybody calls the store function, we're going to omit this event.

8395
13:59:36.083 --> 13:59:56.434
Here's an example of a transaction where we call the store function with a value of one, let's look into the logs to see what this event actually is going to look like an event is going to be broken down like so the address of the contract or account, the event is emitted from the topics or the index parameters of the event data.

8396
13:59:56.503 --> 14:00:01.416
This is the ABI encoded non index parameters of the event.

8397
14:00:01.503 --> 14:00:13.608
What does this mean? This means that we took those parameters that were non indexed, we match them together with their API or application binary interface, pumped them through an encoding algorithm, and boom, this is what we got.

8398
14:00:13.608 --> 14:00:16.248
If you have the API, they're very easy to decode.

8399
14:00:16.248 --> 14:00:24.875
If you don't have the ABI they are very hard to decode these non indexed parameters cost less gas to pump into the logs.

8400
14:00:24.875 --> 14:00:35.206
Now in this particular contract, since we have verified the code, we verified the contract ether scan knows what the ABI is, and we can view this in Deke or decoded mode.

8401
14:00:35.206 --> 14:00:41.440
Hex mode is obviously the non decoded mode, or in its raw, hex or hexadecimal or encoded mode.

8402
14:00:41.503 --> 14:00:45.921
You can read more about the layout of these events in the solidity docs.

8403
14:00:45.921 --> 14:00:50.693
Now, so that's the basic introduction of events.

8404
14:00:50.693 --> 14:01:10.452
And for those of you who want to watch the rest of that video, and who wants to actually practice using events yourself, there's a link to these videos and the code repository associated with that video, if you want to play with it, and if you want to learn more, so feel free Ready to refer back to the full blockchain solidity course, Jas, if you want to go deeper into events now that we're back, and we've learned a little bit more about events, let's add some events to this contract.

8405
14:01:10.504 --> 14:01:15.004
Remember, these events get emitted to a data storage outside of this smart contract.

8406
14:01:15.004 --> 14:01:23.237
Let's create an event called raffle enter a good syntax for naming events, name events, with the function name reversed.

8407
14:01:23.237 --> 14:01:26.361
So for enter raffle, we're gonna say raffle entered.

8408
14:01:26.361 --> 14:01:33.004
So up at the top below our state variables, but above our constructor, we'll create a new section called events.

8409
14:01:33.004 --> 14:01:35.754
And we'll create our first event.

8410
14:01:35.754 --> 14:01:38.143
So we'll do event, raffle, Enter.

8411
14:01:38.143 --> 14:01:44.900
And we'll just have this raffle enter take one index parameter, it'll be an address indexed player.

8412
14:01:44.900 --> 14:01:48.827
So in our Inter raffle, we're going to say omit raffle enter.

8413
14:01:48.827 --> 14:01:51.471
And we're just going to pass it message dot sender.

8414
14:01:51.471 --> 14:01:53.585
I'm going to remove these comments for now.

8415
14:01:53.585 --> 14:01:56.149
But feel free to leave them in as you code along.

8416
14:01:56.149 --> 14:02:04.391
Now in this part of my raffle coding or my lottery coding process, I probably would start already writing some tests and already writing some deploy scripts.

8417
14:02:04.391 --> 14:02:08.453
The reason that we do this is it's good to test our functionality as we progress.

8418
14:02:08.504 --> 14:02:18.941
And oftentimes, when I'm writing smart contracts, I'm constantly flipping back and forth between my deploy scripts, my contracts and my tests to make sure everything is doing exactly what I want it to do for the purpose of this course.

8419
14:02:18.941 --> 14:02:22.722
And just to make it easy for you to learn and follow along, we're not going to do that.

8420
14:02:22.722 --> 14:02:30.412
And we're just going to keep writing our smart contract almost to complete and then move to our deploy scripts and tests.

8421
14:02:30.505 --> 14:02:35.130
So in its minimalistic sense, we essentially have a way for people to enter our raffle.

8422
14:02:35.130 --> 14:02:37.786
Now we need a way to pick the random winner.

8423
14:02:37.786 --> 14:02:41.436
And this is where we're going to need chain link VRF and chain link keepers.

8424
14:02:41.436 --> 14:02:45.226
So let's again, watch some sub lessons about learning about chain link VRF.

8425
14:02:45.226 --> 14:02:47.115
And learning about chain link keepers.

8426
14:02:47.115 --> 14:02:49.250
We've made some videos about these before.

8427
14:02:49.250 --> 14:02:50.718
So we're just going to play these videos.

8428
14:02:50.718 --> 14:02:58.387
So you can learn about how taling VRF version two works, and also how chain link keepers works, then we're going to come back and we're going to add them into our contracts here.

8429
14:02:58.387 --> 14:03:02.241
If you're already familiar, and you already played with them, feel free to skip those sections.

8430
14:03:02.241 --> 14:03:04.398
And we'll just get to building them here.

8431
14:03:04.505 --> 14:03:05.335
Hi, my name is Steven fluid.

8432
14:03:06.505 --> 14:03:08.064
look at chain links VRF.

8433
14:03:10.505 --> 14:03:12.117
different mental models that we should be aware of.

8434
14:03:12.505 --> 14:03:15.005
to show you what it feels like to be using it.

8435
14:03:15.505 --> 14:03:30.705
important thing to know about Vera version two is that instead of the Vera one model where you'd be funding your contract with Link, instead, you're going to be funding a subscription, which is basically an account that allows you to fund and maintain balance for multiple consumer contracts.

8436
14:03:30.705 --> 14:03:34.695
Let's dive into the docs and see what using Vera fie two looks and feels like.

8437
14:03:34.695 --> 14:03:36.552
In order to show this off a little bit.

8438
14:03:36.552 --> 14:03:41.201
I'm going to dive right into the get a random number guide in the chain link documentation.

8439
14:03:41.201 --> 14:03:44.739
And so it's going to go through a few the requirements of some of the technology we're going to use today.

8440
14:03:44.739 --> 14:03:49.409
And the first thing it's going to ask us to do is to make sure that we are on the Rinkeby test net.

8441
14:03:49.409 --> 14:03:51.795
So let's go ahead and jump over to Rinkeby.

8442
14:03:51.795 --> 14:03:54.375
Make sure my meta mask is unlocked here.

8443
14:03:54.505 --> 14:04:00.305
And now that I'm on Rinkeby, great, I should be able to use the VIP version to test net.

8444
14:04:00.305 --> 14:04:03.521
Now we're going to jump over to subscription manager.

8445
14:04:03.521 --> 14:04:07.091
And the subscription manager is where we're going to manage our subscription account.

8446
14:04:07.091 --> 14:04:12.663
Basically, this is the place that you put the funds in order to be able to use it across a bunch of different chains.

8447
14:04:12.663 --> 14:04:17.521
So we're going to go ahead and connect our wallet here in order to use the subscription app.

8448
14:04:17.521 --> 14:04:21.109
And then we're going to go ahead and create a new subscription.

8449
14:04:21.109 --> 14:04:24.589
So we'll just use my address as the subscription address here.

8450
14:04:24.589 --> 14:04:26.755
I'll approve the creation.

8451
14:04:26.755 --> 14:04:30.742
And as soon as that transaction is confirmed, our subscription should be created.

8452
14:04:30.742 --> 14:04:33.360
Alright, now we have a subscription.

8453
14:04:33.506 --> 14:04:35.472
Basically, this is the account where we're going to fund it.

8454
14:04:35.506 --> 14:04:39.030
And then we can use that account for all of our random Miss requests.

8455
14:04:39.030 --> 14:04:44.946
So I'm gonna go ahead and just put in 10 link here, you can put in however much you want.

8456
14:04:44.946 --> 14:04:55.349
The price and link of every random number you request, it's going to be based on the current gas rates on a given chain, as well as the gasoline that you've chosen.

8457
14:04:55.349 --> 14:04:58.878
On our funds have been added, let's go ahead and add a consumer contract.

8458
14:04:58.878 --> 14:05:02.193
So it's asking us for consumer address, we don't actually have a consumer address yet.

8459
14:05:02.193 --> 14:05:08.883
So let's go ahead and jump over to the documentation and create a contract that is going to request a number.

8460
14:05:08.883 --> 14:05:15.215
So if you scroll down, you're going to see this Vera fee to consumer that soul contract that we can open it in remix, let's just jump right there.

8461
14:05:15.215 --> 14:05:19.872
We're gonna notice a few different things in this contract at the top, we've got some input.

8462
14:05:19.872 --> 14:05:27.934
So now you've got VRF, consumer base version two, we've got an interface for the VRF coordinator, and then also a reference to the link token interface.

8463
14:05:27.934 --> 14:05:32.133
So all of those are specified for you on the Rinkeby network here in the example code.

8464
14:05:32.133 --> 14:05:36.306
And then you can refer to the documentation for whatever chain you're going to be deploying to.

8465
14:05:36.306 --> 14:05:39.768
And then you're going to see a few new options here.

8466
14:05:39.768 --> 14:05:45.828
So the key hash option is the way that you specify that gasoline that was described in the documentation.

8467
14:05:45.828 --> 14:05:54.210
So depending on the key hash you choose for the given chain you're on the gas limit will be set differently for your random number requests.

8468
14:05:54.210 --> 14:05:59.916
So for example, on a theory main net, we have a 200 way key hash 500 Wiki hash and 1000 graykey hash.

8469
14:05:59.916 --> 14:06:04.687
You can also see in our contract Hear that we have a callback estimate that you're in charge of.

8470
14:06:04.687 --> 14:06:11.055
So depending on how much gas you're willing to spend in the fulfill random number, you should set this value appropriately.

8471
14:06:11.055 --> 14:06:13.184
Next up is request confirmations.

8472
14:06:13.184 --> 14:06:15.882
So this was something in verify would be one that you could not control.

8473
14:06:15.882 --> 14:06:23.618
But here now, depending on the chain you're on, depending on the request and the type nature of the request you want to make, you can actually change this number.

8474
14:06:23.618 --> 14:06:33.664
And then one of the most important and useful features that gives you a lot more flexibility and control of your VRF is you can actually specify the number of random numbers you want.

8475
14:06:33.664 --> 14:06:41.491
And so you specify the number words, and then that will specify how many random you went to 56 as you get back from the network.

8476
14:06:41.491 --> 14:06:47.507
All right here in the constructor, we're gonna see a address for the coordinator and address for the link token.

8477
14:06:47.507 --> 14:06:51.268
And then you'll see that the subscription ID is going to be created as we deploy the contract.

8478
14:06:51.268 --> 14:06:53.744
And so I'm gonna go ahead and get that.

8479
14:06:53.744 --> 14:07:00.607
So if you remember when we created the subscription after we found it, and we see this subscription ID, and now when I deploy this, I'm going to use that subscription ID.

8480
14:07:00.607 --> 14:07:13.717
And we've got two methods that should look very familiar, we've got fulfill randomness method that takes in randomness is going to be fulfilled by the Bureau of Oracle, as well as you got request random words, which is how we're actually going to initiate the request to the Oracle.

8481
14:07:13.717 --> 14:07:16.861
So I think we're actually are already ready to go ahead and deploy this.

8482
14:07:16.861 --> 14:07:21.894
So let's jump to the deploy screen here and select the right contract, which in our case, is your FB to consumer.

8483
14:07:21.894 --> 14:07:27.457
And I'm going to make sure that I am on injected web three so that we can actually deploy to the Rinkeby network.

8484
14:07:27.507 --> 14:07:29.201
And I'm going to paste in the subscription ID here.

8485
14:07:29.507 --> 14:07:35.409
going to deploy, let's go ahead and pay for that transaction.

8486
14:07:35.508 --> 14:07:46.174
And as soon as that is confirmed by the network will show up here, and we'll be able to copy this address, and then add that as a consumer and authorize this contract to use my subscription account.

8487
14:07:46.174 --> 14:07:56.269
So let's go ahead and authorize this with them another Metamask transaction.

8488
14:07:56.508 --> 14:07:59.472
Alright, we can have your subscription, we can see how much link we funded it with.

8489
14:07:59.472 --> 14:08:01.032
And we can see our consumer contract.

8490
14:08:01.032 --> 14:08:07.219
So now by doing this, we've authorized our consumer contract to make requests for randomness.

8491
14:08:07.219 --> 14:08:09.915
So let's go ahead and make a request for randomness here.

8492
14:08:09.915 --> 14:08:12.721
So we're gonna go back to our contract that we deployed here.

8493
14:08:12.721 --> 14:08:16.344
And we're just gonna use the remix interface here to keep things simple.

8494
14:08:16.344 --> 14:08:18.436
And I'm going to request some randomness.

8495
14:08:18.436 --> 14:08:24.974
So obviously, this is going to use all of the configuration that I specified in my contract, just kind of hard coded here.

8496
14:08:24.974 --> 14:08:26.542
So we're gonna get to words of random is here.

8497
14:08:26.542 --> 14:08:30.814
So we're gonna hit request randomness, confirm the Rigby transaction.

8498
14:08:30.814 --> 14:08:36.258
And then as soon as that transaction comes back, we should notice that we actually have a request.

8499
14:08:36.258 --> 14:08:41.944
And then what we'll be doing is we'll be waiting for the Oracle to call fulfill random words on our contract.

8500
14:08:41.944 --> 14:08:47.475
And then we'll be storing all of those random words in this s random words, storage variable.

8501
14:08:47.475 --> 14:08:50.793
Let's go ahead and check to see if our random numbers come back from the Oracle.

8502
14:08:50.793 --> 14:08:52.554
So I'll go in here into random words.

8503
14:08:52.554 --> 14:08:56.901
And let's request the zeroeth item of the array looks like we've got a random number there.

8504
14:08:56.901 --> 14:09:01.697
And because we requested two random numbers, we should also have an item in index one.

8505
14:09:01.697 --> 14:09:04.650
All right, we we've got our randomness there.

8506
14:09:04.650 --> 14:09:34.460
And if we go back to the subscription manager app, you're going to see that there's actually an event history item here, we'll see that we spent about point three, three link to get those two random numbers, we've just taken a journey to see what it looks like and feels like to use Veera version two, now that we've learned a little bit more about chainlink VRF, I hope that you took some time to go to doxa chain link and play around with it a little bit so that you understand what's really going on, we're going to use this sample contract in here to create our function that's going to pick our random winner.

8507
14:09:34.509 --> 14:09:49.456
This is an on chain contract that coordinates with a verifiably random chain link node to give us a random number, you could look at the code directly on chain, or you can come right to the chain link GitHub and look at all the code for how this is actually happening provably and randomly.

8508
14:09:49.509 --> 14:09:52.396
And we'll have a link to this in the GitHub repo associated with this course.

8509
14:09:52.396 --> 14:10:04.259
So we're going to create our function here called pick a random winner, this function is going to be called by the chain link keepers network so that this can automatically run without us having to interact with it.

8510
14:10:04.259 --> 14:10:10.526
And actually, while we're updating this, I want to add some some stars here saying view slash pure functions.

8511
14:10:10.526 --> 14:10:18.609
Now our pick random winner function, we're actually not going to make public we're going to make external, external functions are a little bit cheaper than public functions.

8512
14:10:18.609 --> 14:10:26.807
Because solidity knows that our own contract can call this, we're actually going to change the name of this function, as well, very soon, but we'll get to that in a little bit.

8513
14:10:26.807 --> 14:10:33.309
So in order for us to pick a random winner, we actually have to do two things, we first have to request the random number.

8514
14:10:33.309 --> 14:10:36.545
And then once we get it, do something with it.

8515
14:10:36.545 --> 14:10:39.754
So chainlink VRF is a two transaction process.

8516
14:10:39.754 --> 14:10:41.917
And this is actually intentional.

8517
14:10:41.917 --> 14:10:47.450
Having random numbers in two transactions is actually also much better than having it in one.

8518
14:10:47.450 --> 14:10:59.716
If it's just one transaction, then people could just brute force tries simulating calling this transaction and we'll learn how to simulate calls soon simulate calling these transactions to see what they can manipulate to make sure that they are the winner.

8519
14:10:59.716 --> 14:11:01.440
We want to make sure that this is absolutely fair.

8520
14:11:01.510 --> 14:11:07.978
Nobody can manipulate our smart contract into having them be the winner of the lottery, this function is actually going to request it.

8521
14:11:07.978 --> 14:11:11.221
And then in a second func the random number is going to be returned.

8522
14:11:11.221 --> 14:11:18.700
And in the transaction that we actually get the random number from the chain link network, that's when we're going to actually send the money to the winner.

8523
14:11:18.700 --> 14:11:36.408
And if we go to the chain link documentation, the function that the chain link node calls is this function called fulfill random words, this is going to be the requesting one, which we could even change this to request random winner to make it more clear, and then we'll make a function fulfill random words.

8524
14:11:36.510 --> 14:11:44.748
And this is going to be an internal override, which we'll explain in a little bit, now fulfill fulfill random words basically means we're fulfilling random numbers.

8525
14:11:44.748 --> 14:11:52.331
The word comes from a computer science terminology, but you can basically just think of this as fulfill random numbers, because we can get multiple random numbers.

8526
14:11:52.331 --> 14:12:02.923
Now in order to make our raffle contract VRF a bowl, we have to import the chain link code, we can go back to the documentation, and we're just going to grab this bottom line and we'll grab the top line in a second.

8527
14:12:02.923 --> 14:12:06.667
So we're going to do import, I'm going to write it out.

8528
14:12:06.667 --> 14:12:13.069
But if you want to copy paste, you can at chain link slash contracts slash SRC slash V 0.

8529
14:12:13.069 --> 14:12:17.093
8, slash V RF, consumer base, b two dot Sol.

8530
14:12:17.093 --> 14:12:28.983
And since we're importing at chainlink, slash contracts, we're gonna need to add that in by running yarn, add dash dash dev at chainlink slash contracts.

8531
14:12:28.983 --> 14:12:32.646
And now that we have this in here, we should be able to import like so.

8532
14:12:32.646 --> 14:12:50.445
And we're going to need to make our raffle VRF consumer base double, we're gonna need to inherit VRF consumer base go into our node modules at chain link src, V 08 VRF, consumer base V two, it comes with this function fulfill random words.

8533
14:12:50.511 --> 14:13:05.511
And you can see it's an internal virtual function, virtual means it's expecting to be overwritten, the reason that it's in the sphere of consumer base V two is so that the VRF coordinator, which we'll use in a bit knows that it can call this fulfill random words function.

8534
14:13:05.511 --> 14:13:07.939
And this is the function that we're overriding.

8535
14:13:07.939 --> 14:13:13.752
So back in our raffle dot salt, we're going to inherit it by doing is VRF consumer base V two.

8536
14:13:13.752 --> 14:13:29.752
And now if we scroll down to fulfill random words, we can add in the input parameters fulfilled pill random words, which are going to be un 256, Request ID and un 256, a memory array random words.

8537
14:13:29.752 --> 14:13:39.461
And if we hit Save Our linter will now notice, okay, this is what I'm expecting, I'm expecting us to override the Fill random words, which takes these parameters.

8538
14:13:39.511 --> 14:13:47.070
Now if we look in our docs in our constructor, we need to pass the VRF consumer base V TOS constructor and pass that VRF coordinator.

8539
14:13:47.070 --> 14:13:52.300
Again, this V RF coordinator is the address of the contract that does the random number verification.

8540
14:13:52.300 --> 14:14:02.761
So right next to our constructor will add the VRF consumer base V to constructor and we need to pass the VRF coordinator v2 address.

8541
14:14:02.761 --> 14:14:06.254
So in our main constructor, we'll add that as a parameter as well.

8542
14:14:06.254 --> 14:14:20.248
So we'll say address VRF core to Nate Torre v two, and then we'll pass this as a parameter for the VRF consumer basically till now that we have that we shouldn't see that little underscore anymore.

8543
14:14:20.248 --> 14:14:24.664
And we should be able to run yarn aren't had compiled.

8544
14:14:24.664 --> 14:14:25.341
Awesome.

8545
14:14:25.512 --> 14:14:30.085
And we can see compiled two files successfully and our code is working great.

8546
14:14:30.085 --> 14:14:39.577
Now something that I often do is I actually hate running yarn hard hat all the time, because that's too many keys for my little brain to work with.

8547
14:14:39.577 --> 14:14:45.226
I would prefer to write as little keys as possible hard hat also would like us to write as little keys as possible.

8548
14:14:45.226 --> 14:14:57.465
So hard hat comes with a shorthand and autocomplete hard hat shorthand is an NPM package that installs a globally accessible binary called H H, that runs the project's locally installed hard hat and supports shell auto completion for tasks.

8549
14:14:57.465 --> 14:15:08.397
So what we can do is we're going to start with NPM, like this, but we're gonna install it with yarn, we're going to run yarn, global, add hardhat shorthand.

8550
14:15:08.512 --> 14:15:15.167
And what this is going to do, we can see here installed hard hat shorthand with binaries H, H, and Hardhead completion.

8551
14:15:15.167 --> 14:15:29.812
Now instead of running yarn, Hardhead compile, which we can still run, we can just run h h compile, running h h is going to be the same thing as if we had just run the Hardhead command for our local directory.

8552
14:15:29.812 --> 14:15:36.308
So now we need to actually have our request random winner function requests a random winner.

8553
14:15:36.308 --> 14:15:37.795
So let's go back to the documentation.

8554
14:15:37.795 --> 14:15:39.167
And we'll see how to do that.

8555
14:15:39.167 --> 14:15:43.804
We can look at this function request random words and see exactly how it works.

8556
14:15:43.804 --> 14:15:45.419
On the Vera of coordinator address.

8557
14:15:45.512 --> 14:15:53.388
We go ahead and call this request random words function, we're going to need to call this function on the coordinator contract to get the coordinator contract.

8558
14:15:53.388 --> 14:15:57.851
We're going to use the Vera v2 coordinator interface and the Vir of coordinator address.

8559
14:15:57.851 --> 14:16:00.076
So we're going to want to keep track of those.

8560
14:16:00.076 --> 14:16:02.038
We can do that once again in Arkansas.

8561
14:16:02.038 --> 14:16:05.663
factor, we have the address being passed to our Bureau of consumer base.

8562
14:16:05.663 --> 14:16:07.939
Let's also keep it as a state variable for us.

8563
14:16:07.939 --> 14:16:19.669
First, let's get the interface so we can interact with that contract, we can import that from chain link as well by doing import at chain link slash contracts, slash SRC slash fees 0.

8564
14:16:19.669 --> 14:16:28.152
8, slash inter faces slash VRF cord to mentor V to interface dot Sol.

8565
14:16:28.152 --> 14:16:38.754
And now that we import this interface, same as we did with price feeds, we can do VRF, coordinator v2, interface VRF coordinator.

8566
14:16:38.754 --> 14:16:48.442
And then we can save the sphere of coordinator using the address so we can say VRF coordinator equals this address VRF coordinator veto.

8567
14:16:48.513 --> 14:16:53.906
And we're just going to wrap that address around the interface so that now we can work with this VRF coordinator contract.

8568
14:16:53.906 --> 14:16:57.893
Now we're only going to set our VRF coordinator one time right in our constructor.

8569
14:16:57.893 --> 14:17:02.450
So what's the best thing that we can do here, private, immutable, you Gosh, darn.

8570
14:17:02.450 --> 14:17:12.873
Right, let's do private, immutable, you have coordinator and we'll change the name to I underscore the ref coordinator so that we know that your coordinator is indeed an immutable variable.

8571
14:17:12.873 --> 14:17:23.168
In order to request the random word, we need to give it a number of parameters, I'm gonna go ahead and copy this line into our contract just so that we can talk about exactly what's going on with it.

8572
14:17:23.168 --> 14:17:25.594
And we don't need the AES Request ID.

8573
14:17:25.594 --> 14:17:29.886
And instead of coordinator we're going to do I underscore fear of coordinator.

8574
14:17:29.886 --> 14:17:42.092
So we're going to call request random words on that VRF coordinator contract, and we need to pass it the key hash or the gasoline, I prefer calling it the gas lane, we go to the chain link, Doc's go to contract addresses.

8575
14:17:42.092 --> 14:18:03.080
And we scroll down we can see different gas lanes a different configuration parameters for different networks is key hash is going to be the gasoline of the key hash, which tells the chain link node the maximum price you're willing to pay for your guests and way if for example, gas prices skyrocket, and it's going to cost you a ton of money to get that random number setting a ceiling, we'll make it so that random number doesn't come back.

8576
14:18:03.080 --> 14:18:07.956
For us to pick a gas lane, we're probably going to want to have this gas lane or this key hash stored somewhere.

8577
14:18:07.956 --> 14:18:11.448
So let's go ahead and make that a parameter of our constructor as well.

8578
14:18:11.448 --> 14:18:13.415
And we'll save that as a state variable.

8579
14:18:13.514 --> 14:18:19.433
So we'll do comma bytes 32, gasoline or key hash or whatever you want to call it.

8580
14:18:19.433 --> 14:18:21.416
And then we'll make a new state variable.

8581
14:18:21.514 --> 14:18:23.395
And we're only going to set this once.

8582
14:18:24.514 --> 14:18:27.169
private, immutable.

8583
14:18:33.514 --> 14:18:38.314
gasoline equals gasoline.

8584
14:18:38.514 --> 14:18:42.447
So now, we can just swap this out, or I underscore gasoline.

8585
14:18:42.514 --> 14:18:48.799
Okay, what's next, we need a subscription ID, the subscription ID is going to be the subscription that we need for funding our requests.

8586
14:18:48.799 --> 14:18:55.874
There's actually a contract on chain, which we can use to fund any subscription for any of these external data or external computation bits.

8587
14:18:55.874 --> 14:19:00.418
And in this contract, there's a list of these subscriptions for people to make requests to.

8588
14:19:00.418 --> 14:19:12.324
So we need the ID of the subscription that we're using to request our random numbers and pay the link Oracle gas, the subscription ID is probably also going to be something we're going to pass as a parameter to our lottery.

8589
14:19:12.324 --> 14:19:15.936
So once again, let's scroll up to our constructor, we'll add a new parameter.

8590
14:19:15.936 --> 14:19:22.449
And our subscription ID actually doesn't need to be a un 256, it can actually be a little bit smaller with a un 64.

8591
14:19:22.515 --> 14:19:28.613
So we'll pass a un 64 sub scription ID, we'll make a UNT 64.

8592
14:19:28.613 --> 14:19:33.229
Since we're only going to set this once we'll make this a private, immutable.

8593
14:19:33.229 --> 14:19:43.405
I underscore sub scription ID down here and we'll say I subscription ID equals sub subscription ID.

8594
14:19:43.515 --> 14:19:44.276
Alright, awesome.

8595
14:19:46.515 --> 14:19:46.668
ID.

8596
14:19:50.515 --> 14:19:56.925
confirmations is a un 16, which says how many confirmations the chain link node should wait before responding.

8597
14:19:56.925 --> 14:20:07.115
So if you make a request, and there's only one block confirmation, maybe you don't actually send it because you don't you're afraid of some type of blockchain reorganization or something, we're not going to worry too much about this.

8598
14:20:07.115 --> 14:20:09.192
And we're actually just going to make this a constant of three.

8599
14:20:09.192 --> 14:20:14.444
So we're not even going to have this be per amortizable we're gonna have this one be a constant.

8600
14:20:14.444 --> 14:20:28.207
So we'll say a you int 16 Private constant request, confirmations equals three, and we're using the capslock and underscores for our constant variables here.

8601
14:20:28.207 --> 14:20:31.983
And now we'll grab request confirmations and stick it in right here.

8602
14:20:31.983 --> 14:20:47.915
What's next callback gas limit callback gas limit is going to be the limit for how much gas to use for the callback request your contracts fulfill random words, this sets a limit for how much computation are fulfilled random words can be this is a good way to protect ourselves from spending way too much gas.

8603
14:20:47.915 --> 14:20:53.989
If, for example, we accidentally code our contract in a way where fulfill random words is incredibly gas expensive.

8604
14:20:53.989 --> 14:20:56.410
It'll block the random number from responding.

8605
14:20:56.516 --> 14:21:01.791
We are going to make this parameter sizable because we want to change it depending on how we code our fulfill random word.

8606
14:21:01.791 --> 14:21:06.349
So in our constructor, let's add one more, we'll add you int 32.

8607
14:21:06.349 --> 14:21:20.816
Since the size of this is a un 32, callback, gas limit, and we'll save the sub top as a UNT 32, private, immutable, I underscore call back.

8608
14:21:20.816 --> 14:21:21.816
Yes limit.

8609
14:21:21.816 --> 14:21:23.982
And we'll save this.

8610
14:21:23.982 --> 14:21:29.815
I call back gas limit equals call back Yes, limit.

8611
14:21:29.815 --> 14:21:31.922
And then we'll take this, and we'll stick it here.

8612
14:21:31.922 --> 14:21:37.625
All right, we got one more number of words, this is going to be how many random numbers that we want to get, we only want one.

8613
14:21:37.625 --> 14:21:42.177
So we're gonna go back up to the top, we're going to create a you int 32.

8614
14:21:42.177 --> 14:21:45.661
And we'll make this also a private constant.

8615
14:21:45.661 --> 14:21:48.722
Num words equals one, because we only want one random number.

8616
14:21:48.722 --> 14:21:55.096
And then that'll be the last thing we need to add for our IVF coordinator dot request random words.

8617
14:21:55.096 --> 14:22:04.778
Now this request random words function returns a request ID a un 256 Request ID a unique ID that defines who's requesting this and all this other information.

8618
14:22:04.778 --> 14:22:08.016
If we want to save it, we can do u and 256.

8619
14:22:08.016 --> 14:22:11.583
Request ID IVF coordinator requests random words.

8620
14:22:11.583 --> 14:22:15.141
Now for now, we are going to emit an event with this request ID.

8621
14:22:15.141 --> 14:22:20.464
And we'll go over why we're going to do that a little bit later, create a new event at the top.

8622
14:22:20.516 --> 14:22:23.463
And we're not going to follow the naming convention here.

8623
14:22:23.516 --> 14:22:30.434
Because we're going to change the name of our functions a little bit, we're going to call this requested raffle winner.

8624
14:22:30.516 --> 14:22:36.183
And we're going to take a un 256 indexed Request ID.

8625
14:22:37.517 --> 14:22:42.093
we're gonna do omit requested raffle winner Request ID.

8626
14:22:42.517 --> 14:22:46.374
now we have a function that we can use to request a random winner using chain link VRF.

8627
14:22:46.374 --> 14:22:51.974
Now again, we're going to set this up so that the chain link keepers call this on an interval, but we'll do that in a little bit.

8628
14:22:51.974 --> 14:22:56.221
For now, let's figure out what to do once we get that random number.

8629
14:22:56.221 --> 14:23:06.775
Once we get that random number, we're going to want to pick a random winner from our array of players up here.

8630
14:23:06.775 --> 14:23:09.420
So what do we do? Well, let's go in here.

8631
14:23:09.420 --> 14:23:14.199
And let's pick a random winner using something called the module function.

8632
14:23:14.199 --> 14:23:24.978
Now we're gonna get an array back of random words, or random numbers, if you will, since we're only requesting one random word, this random words array is going to be of size one with one random word in it.

8633
14:23:24.978 --> 14:23:26.501
Now this random word is a un 256.

8634
14:23:26.501 --> 14:23:29.481
So this random word could be something like this.

8635
14:23:29.481 --> 14:23:37.129
Well, obviously without the hyphens, but it could be something absolutely massive like that our players array is only going to be so big.

8636
14:23:37.129 --> 14:23:51.665
So how do we get a random winner from this potentially massive random number, we can use something called the modulo function, the module operation, a mod N yields, the remainder are after the division of an operand a by the blah, blah, blah, blah, blah.

8637
14:23:51.665 --> 14:23:57.250
So what does this mean? Well, we can use the mod function to get a random number out of our players array.

8638
14:23:57.250 --> 14:24:01.600
So let's say our players array or excuse me, our s players array is of size 10.

8639
14:24:01.600 --> 14:24:03.850
And a random number is 200.

8640
14:24:03.850 --> 14:24:09.787
So how do we pick a random person out of this players array, or, let's say our random number is 202.

8641
14:24:09.787 --> 14:24:17.279
If we do 202, which is our random number, mod 10, we're gonna basically do 202 divided by 10.

8642
14:24:17.279 --> 14:24:23.354
But instead of having the decimals, we're just going to say, Okay, how many times is 10 evenly divide into 202.

8643
14:24:23.354 --> 14:24:37.184
And what's the remainder, what doesn't divide evenly into 202? Well, 20 times 10 equals 200, with two leftover, so two doesn't evenly divide, or multiply into 200.

8644
14:24:37.184 --> 14:24:41.255
So that means 202 mod 10 is going to equal to two.

8645
14:24:41.255 --> 14:24:43.222
So that's how the module function works.

8646
14:24:43.222 --> 14:24:46.469
And we can use that so we're always going to get a number between.

8647
14:24:46.518 --> 14:24:54.862
So we're always going to get a number here between zero and nine, which works out perfectly because that which works out perfectly, because those are the indexes of the 10 people in our array.

8648
14:24:54.862 --> 14:24:56.448
So let's use that here.

8649
14:24:56.448 --> 14:25:10.419
We'll say a un 256 index of winner is going to be equal to random words, at index zero, because we're only getting one random word module, the S underscore players dot length.

8650
14:25:10.419 --> 14:25:25.207
So this will give us the index of our random winner to get that address of the winner will do address payable, recent winner equals s players at this index of winner so awesome.

8651
14:25:25.207 --> 14:25:32.966
So now we'll have the address of the person that got this random number, the person's that's going to be our verifiably random winner.

8652
14:25:32.966 --> 14:25:37.468
Now, it might be kind of cool to brag to people that you're the recent winner.

8653
14:25:37.518 --> 14:25:46.934
So let's go ahead to the top and we'll create a new state variable for our most recent winner make this state variable in a new section called lottery variables.

8654
14:25:46.934 --> 14:26:11.311
We'll say address private s underscore recent winner and it'll start out as nobody but as we get winners update it with s recent winner equals recent winner and we'll probably want people to know who this is winter is so down below, we can do function get recent winner, it's going to be a public view that's going to return that address.

8655
14:26:11.311 --> 14:26:18.519
And then we'll just say return s underscore recent winner, since again, the recent winner is going to be a storage variable.

8656
14:26:18.519 --> 14:26:24.011
So now that we have a recent winner, what else are we gonna do? Well, we're probably going to want to send them the money in this contract.

8657
14:26:24.011 --> 14:26:47.876
So we're going to do exactly what we did before with sending the money, we're going to do that bull success, comma, blank equals recent winner, call, I'm gonna say value, it's going to be address of this dot balance, we're going to send all the money in this contract, and we're going to pass it no data.

8658
14:26:47.876 --> 14:26:53.967
And now we could say require, you know, success, whatever, we're going to be a little bit more gas efficient here.

8659
14:26:53.967 --> 14:27:00.219
And we're just gonna say, if not success, then we're going to revert a new transfer failed error.

8660
14:27:00.219 --> 14:27:13.185
So we're gonna go to the top, or say, error name of the contract is raffle, underscore, underscore, transfer failed, like that, then go back down, and we can now do revert, raffle transfer failed like that.

8661
14:27:13.185 --> 14:27:19.729
And now that we've picked a winner, right now, we don't have a way to actually keep track of the list of previous winners.

8662
14:27:19.729 --> 14:27:21.656
So we're just going to omit an event.

8663
14:27:21.656 --> 14:27:25.614
So there's always going to be that easily query double history of event winners.

8664
14:27:25.614 --> 14:27:31.196
So we're going to create a new event in the events section called the event winner picked.

8665
14:27:31.196 --> 14:27:36.841
And this is going to be an address indexed winner.

8666
14:27:36.841 --> 14:27:44.734
And we'll scroll down and we'll do MIT winner picked the address of the recent winner.

8667
14:27:44.734 --> 14:27:46.376
This looks pretty good.

8668
14:27:46.520 --> 14:27:47.785
This looks pretty good here.

8669
14:27:49.520 --> 14:28:00.060
this little underscore here and saying, hey, it's an unused function parameter, since we don't use this, but we still need fulfill random words to take a request ID and a random words array.

8670
14:28:00.060 --> 14:28:09.596
But we don't use Request ID, we can just comment out just the request ID part like this, this tells our function, hey, yes, we know that you need a un 256.

8671
14:28:09.596 --> 14:28:11.435
But we're not going to use the request ID.

8672
14:28:11.435 --> 14:28:12.316
So we'll leave it in here.

8673
14:28:12.316 --> 14:28:13.770
But we'll leave it blank.

8674
14:28:13.770 --> 14:28:16.020
Now let's run a little compile here.

8675
14:28:16.020 --> 14:28:22.651
We'll use yarn, hard hat, compile, or hh compile, we'll see if we're coding things correctly.

8676
14:28:22.651 --> 14:28:24.421
And indeed, we don't see any errors.

8677
14:28:24.520 --> 14:28:27.091
So perfect, we can continue.

8678
14:28:30.520 --> 14:28:34.445
where we have a way to verifiably get a random winner.

8679
14:28:34.520 --> 14:28:35.634
This is fantastic.

8680
14:28:38.520 --> 14:28:50.454
only can it pick a verifiable winner, but it can also do this all programmatically and automatically trigger picking a random winner based off of some time interval without us having to interact with it.

8681
14:28:50.454 --> 14:28:51.978
And in a decentralized context.

8682
14:28:51.978 --> 14:29:07.429
In order for us to automatically trigger smart contracts based off of some parameter be a time parameter, maybe the price of some asset is some number, maybe there's a certain amount of money in the liquidity pool or really whatever trigger that you want, we can use chain link keepers.

8683
14:29:07.429 --> 14:29:08.029
To do this.

8684
14:29:08.029 --> 14:29:12.070
Steven fluid has done once again, an amazing introduction to chain the keepers.

8685
14:29:12.070 --> 14:29:21.806
So we're going to follow along with another sub video section of Steven explaining chain link keeper sauce, he's going to be using the COVID test net, but be sure to use whatever test net is in the documentation.

8686
14:29:21.806 --> 14:29:23.483
When you play with this and you try this.

8687
14:29:23.521 --> 14:29:24.552
My name is Steven foon.

8688
14:29:26.521 --> 14:29:31.975
chain link keeper network in order to automate your contracts and give them access to off chain computation.

8689
14:29:31.975 --> 14:29:33.052
Let's go ahead and dive in.

8690
14:29:33.052 --> 14:29:37.133
So what we're going to look at today is we're going to start on the chain link documentation webpage.

8691
14:29:37.133 --> 14:29:40.682
And if you just scroll down a little bit, you're going to find using chain link keepers.

8692
14:29:40.682 --> 14:29:45.425
Now there's really two parts to building a chain link keeper up kept smart contract.

8693
14:29:45.425 --> 14:29:50.521
So the first thing is you need to write a smart contract that's compatible by implementing these two methods.

8694
14:29:50.521 --> 14:29:55.298
And then second, you want to register that smart contract for upkeep with the channeling keeper network.

8695
14:29:55.298 --> 14:29:57.816
So let's go ahead and do both of those things.

8696
14:29:57.816 --> 14:30:02.198
So let's start off just by copying and deploying this sample code that we've got.

8697
14:30:02.198 --> 14:30:07.078
With this one click to remix, what we're gonna see here is a very, very simple contract.

8698
14:30:07.078 --> 14:30:08.833
That is just a simple counter.

8699
14:30:08.833 --> 14:30:11.208
So we can see it's got a counter here.

8700
14:30:11.208 --> 14:30:13.859
So it's got just a simple number.

8701
14:30:13.859 --> 14:30:22.140
And then you're able to specify when you create the contract and update interval, and then the contract is going to verify Hey, has enough time passed.

8702
14:30:22.140 --> 14:30:23.728
And if it has, let's update the counter.

8703
14:30:23.728 --> 14:30:32.430
And you're going to notice that chinley compatible or timekeeper network compatible contracts use two really important methods that are part of this keeper compatible interface.

8704
14:30:32.430 --> 14:30:38.743
The first is check upkeep, and check upkeep is special because this is where the off chain computation happens.

8705
14:30:38.743 --> 14:30:41.727
So this is a method that's not actually run on chain.

8706
14:30:41.727 --> 14:30:46.449
This is run off chain by a node from the channeling keeper network.

8707
14:30:46.449 --> 14:30:51.487
And so what's really nice about this is that the gas used here isn't actually gas, it's on chains.

8708
14:30:51.487 --> 14:30:53.797
This is just being run by a chain link node.

8709
14:30:53.797 --> 14:30:58.925
And then what happens is if your check upkeep method returns, the upkeep is needed.

8710
14:30:58.925 --> 14:31:01.410
Then it's going to go ahead and perform upkeep.

8711
14:31:01.410 --> 14:31:05.945
On chain, so you can actually generate data off chain, and then pass that in.

8712
14:31:05.945 --> 14:31:07.419
That's called the check data.

8713
14:31:07.522 --> 14:31:11.747
And then that becomes the performed data that's passed into perform upkeep.

8714
14:31:11.747 --> 14:31:18.183
And so the PErforM upkeep method is where you're going to want to verify that things are correct.

8715
14:31:18.183 --> 14:31:24.332
And that things actually should be modified and run on chain, and then actually make the state change.

8716
14:31:24.332 --> 14:31:28.472
And so let's go ahead and compile this contract and deploy it to the COVID network.

8717
14:31:28.522 --> 14:31:32.231
So let's go ahead and within remix, we can do this compilation.

8718
14:31:32.231 --> 14:31:35.763
And we're going to compile and deploy directly to COVID.

8719
14:31:35.763 --> 14:31:42.662
So the zookeeper network is currently as of the filming of this, available on both COVID as well as the theory of main net.

8720
14:31:42.662 --> 14:31:44.958
And let's go ahead and play the counter contract.

8721
14:31:44.958 --> 14:31:48.970
And let's see what's not updating more than every 30 seconds.

8722
14:31:48.970 --> 14:31:50.751
And so let's go ahead and deploy.

8723
14:31:50.751 --> 14:31:55.360
So meta masks can ask for a little bit of payment, in order for me to deploy this contract to the COVID network.

8724
14:31:55.360 --> 14:31:57.360
And it looks like that is live.

8725
14:31:57.360 --> 14:32:02.426
So now what I'm going to do is I'm going to be able to take this keeper contract, and copy its address.

8726
14:32:02.426 --> 14:32:05.722
And now we're going to register that contract for upkeep.

8727
14:32:05.722 --> 14:32:13.890
So we're going to jump over to the application that powers the champion keeper network, there's a few different ways you can use, you can interact directly with the registry contract.

8728
14:32:13.890 --> 14:32:16.475
But there's a very, very nice interface that lets you do this.

8729
14:32:16.475 --> 14:32:21.115
So let's go ahead and register a new upkeep and it's giving me an error that says you need to connect your wallet.

8730
14:32:21.115 --> 14:32:22.052
So let's go ahead and do that.

8731
14:32:22.052 --> 14:32:25.877
So I'm going to just connect wallet here, and I'm gonna give it access to my account.

8732
14:32:25.877 --> 14:32:29.137
And then from there, we should actually be able to register.

8733
14:32:29.137 --> 14:32:32.368
So I'm going to use an email address here.

8734
14:32:32.368 --> 14:32:34.641
I'll give my contract a simple name.

8735
14:32:34.641 --> 14:32:39.877
I'll paste in that address from the deployed contract, and then I'll give it a gas limit.

8736
14:32:39.877 --> 14:32:50.989
And then check data is this special thing where you can actually register multiple upkeeps On the same contract in passing data to specify how you want checkup keep to be run of, we're just going to ignore that that is an optional one.

8737
14:32:50.989 --> 14:32:59.051
And then we'll give it a starting balance of around 10 link, it's gonna go ahead and use Metamask again to register that transaction on the network.

8738
14:32:59.051 --> 14:33:06.200
And once it's confirmed, my upkeep should be registered with the network and funded with 10 Link To kick things off.

8739
14:33:06.200 --> 14:33:11.785
Alright, if we go ahead and view the upkeep, we can see it's registered.

8740
14:33:11.785 --> 14:33:27.470
And as soon as the next round of the keeper nodes executes, which should be roughly about every block, we should see that the check upkeep method is going to return that hey, upkeep is actually needed because the timestamp is more than 30 seconds ago.

8741
14:33:27.470 --> 14:33:30.210
And then we should go ahead and perform upkeep.

8742
14:33:30.210 --> 14:33:40.323
So as soon as I take a look at this in remix, I can actually make this bigger here, we're going to be able to see from the methods of the contract, if we check the counter, it's going to start at zero.

8743
14:33:40.323 --> 14:33:48.539
And as soon as that 30 seconds has passed, we'll be able to hit the counter again, we'll see that the channeling keeper network has performed upkeep on my contract.

8744
14:33:48.539 --> 14:33:55.803
Alright, we just refresh and we see the balance of the upkeep has been decreased by about point 01 link.

8745
14:33:55.803 --> 14:34:02.835
And we should also see within our contract that our counter has now updated via proof that perform upkeep method call.

8746
14:34:02.835 --> 14:34:10.245
And now our counter is at one showing us that our contract is being approved by the chainlink keeper network.

8747
14:34:10.245 --> 14:34:12.462
And everything is working exactly as we expect.

8748
14:34:12.462 --> 14:34:17.505
So as you can see, it is very, very easy to create a contract that is compatible with the keeper network.

8749
14:34:17.505 --> 14:34:25.476
And it's very easy to register that upkeep and start seeing that your contract automation and option computation are working flawlessly.

8750
14:34:25.524 --> 14:34:33.805
Now that we've learned a little bit more about how chainlink keepers work if you want to take some time to go through the documentation and open up way down below this open and remix button.

8751
14:34:33.805 --> 14:34:46.151
So you can actually work with one of these and see these in action for yourself on a test net, feel free to do so we're gonna be using a setup very similar to this keepers counter setup in the chain link documentation.

8752
14:34:46.151 --> 14:34:52.945
So now let's update our code so that this request random numbers automatically happens using chain link keepers.

8753
14:34:52.945 --> 14:34:58.146
And if we look at the example contract can actually read more about what's really important for this to work.

8754
14:34:58.146 --> 14:35:02.086
And we need a check upkeep and a perform upkeep function in our code.

8755
14:35:02.086 --> 14:35:07.238
So instead of request random winner, this is going to be the PErforM upkeep that we're going to change.

8756
14:35:07.238 --> 14:35:16.345
But first let's make this check upkeep checkup keep function is basically going to be checking to see is it time for us to get a random number to update the recent winner and to send them all the funds.

8757
14:35:16.345 --> 14:35:17.917
So let's go ahead and make that function.

8758
14:35:17.917 --> 14:35:21.556
I'm going to add some notes here, just so that it's clear what's going on.

8759
14:35:21.556 --> 14:35:25.633
And maybe I'll even do natspec To tell developers what's going on with this function.

8760
14:35:25.633 --> 14:35:28.839
So we're going to create this function check upkeep.

8761
14:35:28.839 --> 14:35:35.945
And if we look at what this needs, it needs to be external override external override.

8762
14:35:35.945 --> 14:35:41.474
And if we see this override keyword, this means that okay, there's probably a perform upkeep somewhere else.

8763
14:35:41.524 --> 14:35:51.445
And if we scroll to the top, and we're going to import this keeper compatible interface, so that we make sure that we implement both check upkeep and perform upkeep in our code here.

8764
14:35:51.524 --> 14:35:56.270
If you want you can just import keeper compatible in here or just the keeper compatible interface in our code.

8765
14:35:56.270 --> 14:36:04.940
We're going to do import at chain link slash contracts slash SRC slash V 0.

8766
14:36:04.940 --> 14:36:26.287
8 point two interfaces slash keeper compatible interface that soul and now we're just gonna say contract raffle is Veera of consumer base V two and keeper compatible interface and this keeper compatible interface inheritance just make sure that we add checkup keep and perform upkeep, which we're going to add in a little bit.

8767
14:36:26.287 --> 14:36:33.754
And if we look back at the docs we can see checkup keep takes a bytes called Data check data as an input parameter.

8768
14:36:33.754 --> 14:36:36.213
So we'll do bytes called data.

8769
14:36:36.213 --> 14:36:38.075
Check data as a parameter.

8770
14:36:38.075 --> 14:36:45.328
Now this check upkeep bytes call data allows us to specify really anything that we want when we call this check upkeep function.

8771
14:36:45.328 --> 14:36:59.368
Having this check data be of type bytes means that we can even specify this to call other functions, there's a lot of advanced things you can do by just having an input parameter as type of bytes for us though, we're going to keep it a little bit simple.

8772
14:36:59.368 --> 14:37:01.650
And we're actually not going to use this check data piece.

8773
14:37:01.650 --> 14:37:05.840
So similar to how below we're not using Request ID, we can just comment it out.

8774
14:37:05.840 --> 14:37:10.040
However, we still need to make sure that this parameter is type of bytes called data.

8775
14:37:10.040 --> 14:37:24.639
Now anyways, let's go ahead and annotate this check upkeep function, we'll say this is the function that the chain link keeper nodes call they look for the to return true.

8776
14:37:24.639 --> 14:37:37.837
Look back at the documentation, we can see that this check upkeep returns both and upkeep needed and to perform data, which again, we're going to ignore this upkeep needed is going to be true or false.

8777
14:37:37.837 --> 14:37:47.235
If it's true, that means it's time to get a new random number following should be true in order to return true.

8778
14:37:47.235 --> 14:37:56.776
So in order for it to be time to request a random winner, what should happen, our time interval should have passed, which we haven't defined yet.

8779
14:37:56.776 --> 14:38:03.052
But we will lottery should have at least one player and have some eath.

8780
14:38:03.052 --> 14:38:17.542
And then our subscription is funded with Link similar to how with channeling Vir f your subscription needs to be funded with Link, the same thing needs to happen for check upkeep and keepers to run your subscription needs to be funded with link.

8781
14:38:17.542 --> 14:38:30.187
Now we're going to add one more additional piece here, we're going to say for the lottery should be in an open state, something that we want to avoid when we're waiting for a random number to return.

8782
14:38:30.187 --> 14:38:32.388
And when we've requested a random winner.

8783
14:38:32.388 --> 14:38:36.576
We're technically in this weird limbo state where we're waiting for a random number to be returned.

8784
14:38:36.576 --> 14:38:39.052
And we really shouldn't allow any new players to join.

8785
14:38:39.052 --> 14:38:43.668
So what we actually want to do is create some state variable telling us whether the lottery is open or not.

8786
14:38:43.668 --> 14:38:51.412
And while we're waiting for our random number to get back, we'll be in a closed or a calculating state.

8787
14:38:51.526 --> 14:38:57.746
Now what we could do at the top of our contract, we can just say Boolean, private, s underscore is open.

8788
14:38:57.746 --> 14:39:02.473
And we can just set this to true if we're open otherwise false.

8789
14:39:02.473 --> 14:39:14.714
Well, what if we have a ton of different states? What if we want it to be like pending, open, closed, calculating, etc? What do we have a ton of different states? Well, we could make this a U and 256.

8790
14:39:14.714 --> 14:39:16.401
Private s underscore state.

8791
14:39:16.401 --> 14:39:23.227
And we could just keep track of the state having like zero b pending a one reopen to be closed, three, be calculating, etc.

8792
14:39:23.227 --> 14:39:25.737
But this can be a little tricky to keep track of.

8793
14:39:25.737 --> 14:39:35.465
So a better way to actually keep track of all this in our code is to use an enum enums, can be used to create custom types with a finite set of constant values.

8794
14:39:35.527 --> 14:39:44.182
So we can create, for example, a state created locked inactive, and it's basically a new type for a smart contract for us, we're going to create a new type.

8795
14:39:44.182 --> 14:39:49.871
And if we go back to the layout of variables, and our smart contract types should actually be first thing in our contract.

8796
14:39:49.871 --> 14:39:52.899
So we're going to create an E new called raffle state.

8797
14:39:52.899 --> 14:39:58.713
And for now, and we're just going to have it be open, we're just gonna have to be open or calculating.

8798
14:39:58.713 --> 14:40:09.245
Now when we create an enum like this, we're kind of secretly creating a un 256, where zero equals open, and one equals calculating.

8799
14:40:09.245 --> 14:40:15.050
However, this is much more explicit that we know what each one of these numbers actually means.

8800
14:40:15.050 --> 14:40:22.456
Now that we've created this new type called raffle state, we can create a new lottery state variable of type raffle state.

8801
14:40:22.527 --> 14:40:27.607
So the exact same way we declare any other variable, we'll name its type, which is going to be raffle state.

8802
14:40:27.607 --> 14:40:29.727
And this is going to be a storage variable.

8803
14:40:29.727 --> 14:40:38.246
So we'll go ahead and do private s underscore raffle state in our constructor, right when we launched this contract, we should open up this raffle.

8804
14:40:38.246 --> 14:40:43.442
So we'll say s, raffle state equals and we could use a un 256.

8805
14:40:43.527 --> 14:40:46.799
Wrapped in type raffle state like so.

8806
14:40:48.527 --> 14:40:51.060
explicit and say raffle state DOT open.

8807
14:40:52.527 --> 14:40:58.264
raffle state is in an open state and we only want checkup keep to work is if the lottery is actually open.

8808
14:40:58.264 --> 14:41:02.291
Additionally, we probably only want people to be able to enter if the law battery's open.

8809
14:41:02.291 --> 14:41:06.949
So let's go ahead and create another if statement and revert if the lottery isn't open.

8810
14:41:06.949 --> 14:41:23.773
So we can say if s underscore raffle state does not equal raffle state DOT open, then we're going to revert with a new error, we're going to create raffle underscore underscore, not open.

8811
14:41:23.773 --> 14:41:29.096
And of course, at the top will create error, raffle not open.

8812
14:41:29.096 --> 14:41:34.449
Now additionally, let's go down when we're requesting a random word.

8813
14:41:34.528 --> 14:41:38.769
Let's update the state to be calculating so other people can't jump in here.

8814
14:41:38.769 --> 14:41:55.052
So right above our VRF coordinator dot request, random words will do s underscore raffle state equals raffle state DOT calculating so that nobody can enter our lottery and nobody can trigger a new update.

8815
14:41:55.052 --> 14:42:04.217
And then once we fulfill after we pick our winner, we'll say s raffle state equals raffle state DOT open again.

8816
14:42:04.217 --> 14:42:12.232
Something else that we forgot to do was after we pick a winner from s players, we need to reset our players array.

8817
14:42:12.232 --> 14:42:18.773
So let's add that in here as well as players equals new address payable.

8818
14:42:18.773 --> 14:42:20.953
array of size zero.

8819
14:42:20.953 --> 14:42:23.001
So we'll reset the raffle state.

8820
14:42:23.001 --> 14:42:24.778
And we'll reset our players array.

8821
14:42:24.778 --> 14:42:25.528
Alright, great.

8822
14:42:25.528 --> 14:42:31.087
So now that we've learned about enum, let's add it to our checkup keep here, we're going to check these four things.

8823
14:42:31.087 --> 14:42:36.997
And if they all pass checkup keys will be true and will trigger the chain the keepers to request a new random winner.

8824
14:42:36.997 --> 14:42:39.575
So first, we'll say bool is open.

8825
14:42:39.575 --> 14:42:43.793
It's going to be equal to raffle state.

8826
14:42:43.793 --> 14:42:50.303
That open equals equals s underscore raffle state.

8827
14:42:50.303 --> 14:43:01.021
So you can think of that as this boolean is open is going to be true if raffle state is in an open state, and it will be false if raffle state is in any other state.

8828
14:43:01.021 --> 14:43:01.436
So great.

8829
14:43:01.529 --> 14:43:04.013
We haven't is open Boolean that we can check later on.

8830
14:43:04.529 --> 14:43:10.329
do we need? Well, we need to check to make sure our time interval is past well, we don't have a time interval yet.

8831
14:43:10.329 --> 14:43:12.306
So let's create a time interval.

8832
14:43:12.306 --> 14:43:25.918
In order to check the time we can use another one a solidity is globally available variables with block dot timestamp block that timestamp returns the current timestamp of the blockchain to get the current timestamp, we're gonna need block dot timestamp.

8833
14:43:25.918 --> 14:43:33.988
But to get if enough time has passed, we're going to need to get the current block dot timestamp minus the last block timestamp, which we don't have yet.

8834
14:43:33.988 --> 14:43:38.195
Let's go ahead and create a state variable to keep track of the previous block timestamp.

8835
14:43:38.195 --> 14:43:41.156
So this is going to be a new state variable that we're going to make.

8836
14:43:41.156 --> 14:43:43.568
I'm gonna say u and 256.

8837
14:43:43.568 --> 14:43:49.215
Private s underscore last timestamp.

8838
14:43:49.529 --> 14:43:57.232
And right when we deploy this contract, we'll update this with the current timestamp s last timestamp equals block dot timestamp.

8839
14:43:57.232 --> 14:43:58.560
Alright, awesome.

8840
14:43:58.560 --> 14:44:01.294
Now we have a last block timestamp.

8841
14:44:01.529 --> 14:44:07.929
But we're going to need to check that the difference between the current timestamp and the last timestamp is greater than some interval.

8842
14:44:07.929 --> 14:44:09.829
So we also need to create an interval.

8843
14:44:09.829 --> 14:44:18.196
And this is going to be some interval, this is going to be some number in seconds of how long we want to wait between lottery runs.

8844
14:44:18.196 --> 14:44:21.142
So let's go ahead and add this to our constructor as well.

8845
14:44:21.142 --> 14:44:22.291
And do a comma here.

8846
14:44:22.291 --> 14:44:23.751
And we'll do u and 256.

8847
14:44:23.751 --> 14:44:24.322
Interval.

8848
14:44:24.322 --> 14:44:32.496
And we're going to create another global variable u and 256 Private s underscore interval.

8849
14:44:32.496 --> 14:44:36.130
And in our constructor and we'll say s interval equals interval.

8850
14:44:36.130 --> 14:44:39.482
Now interval isn't going to change after we set it.

8851
14:44:39.482 --> 14:44:45.497
So instead of making a storage variable, let's make it an immutable variable to save some gas.

8852
14:44:45.497 --> 14:44:46.400
Okay, perfect.

8853
14:44:46.530 --> 14:44:51.063
Now that we have all this, I'm actually create a boolean to check to see if enough time has passed.

8854
14:44:51.063 --> 14:45:01.910
So we'll say Boolean time passed equals the current block that timestamp minus s underscore last timestamp.

8855
14:45:01.910 --> 14:45:08.702
And we should check to see that this is actually greater than I underscore interval.

8856
14:45:08.702 --> 14:45:11.330
So we have a Boolean check to see if we're open.

8857
14:45:11.330 --> 14:45:15.482
It'll be true if we're open and we'll have a boolean to see if enough time has passed.

8858
14:45:15.530 --> 14:45:17.545
This will be true if enough time has passed.

8859
14:45:18.530 --> 14:45:21.481
check? While we should check to see if we have enough players.

8860
14:45:21.530 --> 14:45:31.909
So we'll do Boolean has players equals and we'll check to see if s underscore players dot length is greater than zero.

8861
14:45:31.909 --> 14:45:36.434
If s players dot length is greater than zero as players will be true, otherwise it'll be false.

8862
14:45:36.434 --> 14:45:43.592
And we'll also see if we have a balance so we'll do Boolean has balance equals address.

8863
14:45:43.592 --> 14:45:46.461
This dot balance is greater than zero.

8864
14:45:46.461 --> 14:45:53.330
Then finally, we're going to take all these booleans and turn them into the return variable that we're looking for.

8865
14:45:53.330 --> 14:45:55.711
We're gonna say Boolean up keep needed.

8866
14:45:55.711 --> 14:46:01.809
Equals is open and time passed.

8867
14:46:01.809 --> 14:46:12.908
And as players and as balance, like that, so all these combined is gonna be this Boolean upkeep needed.

8868
14:46:12.908 --> 14:46:18.343
And if this returns true, it's time to request a new random number and it's time to end the lottery.

8869
14:46:18.343 --> 14:46:22.007
If this is false, it's not time yet, it's not time to end the lottery up.

8870
14:46:22.007 --> 14:46:29.995
Now again, if we go to the chainlink, documentation upkeep needed, actually needs to return that Boolean upkeep needed and some bytes memory perform data.

8871
14:46:29.995 --> 14:46:34.090
So we need to update we need to update our function here.

8872
14:46:34.090 --> 14:46:44.392
And say returns full upkeep needed, comma, bytes memory, perform data star slash.

8873
14:46:44.531 --> 14:46:52.449
And since we've initialized Boolean up, keep needed up here, we don't need to say what type of upkeep needed is down here.

8874
14:46:52.531 --> 14:46:56.740
Since this will automatically get returned performed data is something that we can use.

8875
14:46:56.740 --> 14:46:59.580
If we want to have checkup, keep do some other stuff.

8876
14:46:59.580 --> 14:47:02.202
Depending on how this checkup keep went.

8877
14:47:02.202 --> 14:47:03.959
We don't really need it to do anything else.

8878
14:47:03.959 --> 14:47:05.292
So we can just leave it as such.

8879
14:47:05.292 --> 14:47:05.577
Right.

8880
14:47:05.577 --> 14:47:13.875
So now we have a check upkeep, we have a way to check to see if it's time to trigger picking our random winner of our lottery or our raffle.

8881
14:47:13.875 --> 14:47:22.991
Now that we learned how to actually do this trigger, let's write the function that gets executed after this returns true.

8882
14:47:22.991 --> 14:47:29.203
This is going to be our perform upkeep function, which we can see an example again in the chainlink documentation.

8883
14:47:29.203 --> 14:47:35.760
Now when it's time to pick a random winner, actually, what we're going to do is just we're just going to call this request random winner function.

8884
14:47:35.760 --> 14:47:43.290
So instead of having this extra function, let's just transform our request random winner function into this perform upkeep.

8885
14:47:43.290 --> 14:47:49.268
Since once check upkeep returns true, the chain link nodes will automatically call this perform upkeep function.

8886
14:47:49.268 --> 14:47:53.810
So in function request random winner, let's rename this to perform upkeep.

8887
14:47:53.810 --> 14:48:01.339
And we'll have it take the input parameter bytes called Data perform data bytes, called data, perform data.

8888
14:48:01.339 --> 14:48:11.193
In our checkup, keep we had to perform data, we would automatically pass it to our performance keep, we're not going to pass anything to perform upkeep, we can leave it commented out like this.

8889
14:48:11.193 --> 14:48:18.193
Since perform upkeep is actually identified in the keeper compatible interface, this is now going to have to override that function.

8890
14:48:18.193 --> 14:48:21.992
Now we want to do a little bit of validation before we continue here.

8891
14:48:21.992 --> 14:48:25.286
Because right now anybody can call our perform upkeep function.

8892
14:48:25.286 --> 14:48:28.881
So we want to make sure that it only gets called when checkup keep is true.

8893
14:48:28.881 --> 14:48:33.282
An easy way for us to do that is to actually call our own checkup, keep function.

8894
14:48:33.282 --> 14:48:35.467
Now right now, checkup keep it's an external.

8895
14:48:35.467 --> 14:48:38.321
So we actually can't call our own checkup keep function.

8896
14:48:38.321 --> 14:48:43.532
So let's change it to public so that even our own smart contracts can call this checkup keep function.

8897
14:48:43.532 --> 14:48:53.972
Now that we've made it public in perform upkeep, we can call checkup, keep passing nothing, and then return the upkeep needed and perform data which we don't really care about.

8898
14:48:53.972 --> 14:48:57.938
So we'll get we'll get that ball up keep needed.

8899
14:48:57.938 --> 14:49:00.785
And then we don't care about perform data.

8900
14:49:00.785 --> 14:49:04.422
So we'll leave that blank equals check up keep.

8901
14:49:04.422 --> 14:49:07.277
And we'll pass it a blank called data.

8902
14:49:07.277 --> 14:49:11.807
Now, we want to make sure that this is true in order to keep going with the function.

8903
14:49:11.807 --> 14:49:24.451
So we could write a require here, but we're going to do if not up keep needed, then we're going to revert with a new error that we create raffle.

8904
14:49:24.533 --> 14:49:25.949
upkeep not needed.

8905
14:49:29.533 --> 14:49:33.385
this error so that whoever was running into this bug can hopefully see why they're getting this error.

8906
14:49:33.385 --> 14:49:37.549
So we'll pass the balance of this contract just in case there's no ether in here.

8907
14:49:37.549 --> 14:49:41.000
We'll add the players dot length, just in case there's no players.

8908
14:49:41.000 --> 14:49:45.464
And we'll add a un 256 s underscore raffle state.

8909
14:49:45.464 --> 14:49:49.199
Make sure that the raffles actually open.

8910
14:49:49.199 --> 14:50:06.340
And then of course, we'll need to create this air at the top air, raffle upkeep not needed, which is going to take a un 256 current balance un 256 non players and you went to fit six raffle state.

8911
14:50:06.340 --> 14:50:09.713
Our code is starting to look really professional.

8912
14:50:09.713 --> 14:50:10.499
This is awesome.

8913
14:50:10.499 --> 14:50:17.926
Now something that we forgot to do back in the fulfill random words because we actually forgot to reset timestamp every time a winner is picked.

8914
14:50:17.926 --> 14:50:25.199
We want to reset the timestamp as well so that we can wait another interval and let people participate in the lottery for that interval.

8915
14:50:25.199 --> 14:50:28.307
So we'll scroll down into fulfill random words.

8916
14:50:28.307 --> 14:50:32.194
And right after we reset players will also reset the timestamp.

8917
14:50:32.194 --> 14:50:34.920
Okay great and I think we're just about done here.

8918
14:50:34.920 --> 14:50:45.876
Let's add a little bit of natspec to make this look even more professional and and give people who are reading our contract even more information.

8919
14:50:45.876 --> 14:50:57.913
So let's add title here at title and we'll say a sample raffle contract will say an author is going to be me Patrick Collins or you can put your own name there as well at notice.

8920
14:50:57.913 --> 14:51:04.518
This contract is for creating and untampered orrible decentralized smart contract.

8921
14:51:04.518 --> 14:51:13.284
And then we'll do add Dev, this implements chain link VRF v two, and chain link keepers.

8922
14:51:13.284 --> 14:51:14.346
Alright, awesome.

8923
14:51:14.346 --> 14:51:22.057
We've got our type declarations, we've got our state variables, we've got lottery variables, which are still state variables, we've got our events.

8924
14:51:22.057 --> 14:51:24.134
Now it's time for our functions.

8925
14:51:24.134 --> 14:51:28.596
Afterwards, we've done a little bit of natspec, at least on our check upkeep.

8926
14:51:28.596 --> 14:51:33.937
If you want to add some more natspec on things like enter, raffle, perform upkeep, etc, you can absolutely do so.

8927
14:51:33.937 --> 14:51:37.472
And then down at the bottom, we have our views slash pure getter functions.

8928
14:51:37.472 --> 14:51:43.034
Let's see, do we want any other getter functions here? Well, we probably want to give people the chance to get a raffle state.

8929
14:51:43.034 --> 14:51:51.934
So we'll do function, get raffle state, this will be a public, you returns a raffle state.

8930
14:51:51.934 --> 14:52:00.784
We'll say return s underscore raffle state, we probably want to give people the chance to get the number of words.

8931
14:52:00.784 --> 14:52:04.393
And this is going to be a little bit interesting here running.

8932
14:52:04.393 --> 14:52:17.867
So if we do function, get num words, public view returns, you went to the six return num words, you'll see something interesting happened here.

8933
14:52:17.867 --> 14:52:21.034
We pull up our compiler and run hh compile.

8934
14:52:21.034 --> 14:52:23.700
Hopefully everything works here.

8935
14:52:23.700 --> 14:52:28.470
Oh, and everything doesn't work because I didn't import this correctly.

8936
14:52:28.534 --> 14:52:29.846
Let's fix that.

8937
14:52:31.534 --> 14:52:33.975
Oh, there's a couple things I missed.

8938
14:52:35.535 --> 14:52:38.090
This is why it's good to compile as you code as players dot length.

8939
14:52:38.090 --> 14:52:39.571
Let's try again.

8940
14:52:39.571 --> 14:52:42.071
And I spelt interval wrong.

8941
14:52:42.071 --> 14:52:49.190
I underscore inter vol strike to compile again, see how many more spelling mistakes I made.

8942
14:52:49.190 --> 14:52:50.293
And there it is.

8943
14:52:50.293 --> 14:52:55.831
I underscore in error go to paste that and we do get another error here.

8944
14:52:55.831 --> 14:53:02.166
Invalid type for argument in a function call invalid implicit conversion from literal string to bytes called data requested.

8945
14:53:02.166 --> 14:53:04.857
Since we're passing this empty string here.

8946
14:53:04.857 --> 14:53:09.201
And checkup keep needs a call data called data actually doesn't work with strings.

8947
14:53:09.201 --> 14:53:11.344
So we need to make this bytes memory instead.

8948
14:53:11.344 --> 14:53:13.196
And our compiler is now happy with us.

8949
14:53:13.196 --> 14:53:14.975
And I spell it the timestamp wrong.

8950
14:53:14.975 --> 14:53:24.889
That's a lowercase s so and you might see some squiggles here on Check upkeep, we could make this a view function since we're not actually modifying any state.

8951
14:53:24.889 --> 14:53:28.535
But I want to keep it public for reasons I'll show you a little bit later.

8952
14:53:28.535 --> 14:53:32.002
But finally we get the the yellow squiggly that I was looking for here.

8953
14:53:32.002 --> 14:53:37.456
And if we run hh compile, we should see a warning in our compiler as well.

8954
14:53:37.535 --> 14:53:39.035
Okay, so we see all those yellow squigglies here.

8955
14:53:39.535 --> 14:53:41.535
variable can remain unassigned.

8956
14:53:43.535 --> 14:53:46.092
here because that's what the keepers are looking for.

8957
14:53:46.535 --> 14:53:50.502
function state mutability can be restricted to view for our function checkup key.

8958
14:53:50.502 --> 14:53:55.177
You can make a view if you want, but I'm going to keep it public for reasons I'll show you a little bit later.

8959
14:53:55.177 --> 14:54:11.724
And finally, function state mutability can be restricted to pure this is what I wanted to show you since num words is actually in the bytecode, since it's a constant variable technically isn't reading from storage, and therefore this can be a pure function.

8960
14:54:11.724 --> 14:54:18.095
Returning num words doesn't actually read in storage, it literally will go and read the number one.

8961
14:54:18.095 --> 14:54:30.260
So doing get num words in solidity with num words being a constant variable, it's going to literally be the exact same as saying get one and we would return one here, we might also want to get the number of players.

8962
14:54:30.260 --> 14:54:35.328
So we'll create a function get number of players.

8963
14:54:35.536 --> 14:54:41.536
And this will be a public view, returns a un 256.

8964
14:54:42.536 --> 14:54:44.993
underscore players dot length.

8965
14:54:47.536 --> 14:54:49.260
want the latest timestamp.

8966
14:54:51.536 --> 14:54:52.536
timestamp.

8967
14:54:52.536 --> 14:54:55.980
public view returns you in 256.

8968
14:54:58.536 --> 14:55:02.925
to return s underscore last timestamp.

8969
14:55:05.536 --> 14:55:07.269
to do request confirmation.

8970
14:55:09.536 --> 14:55:10.551
confirmations.

8971
14:55:14.536 --> 14:55:22.346
constant function returns you went to you went to 56 Turn request confirmations.

8972
14:55:22.346 --> 14:55:26.107
All right, we've got some wonderful getters here.

8973
14:55:26.107 --> 14:55:33.454
Some views slash pure functions, we have a way to get a random number we have a way in a decentralized context.

8974
14:55:33.536 --> 14:55:34.989
Automatic automatically execute.

8975
14:55:36.536 --> 14:55:40.468
a way for people to enter our raffle to enter this lottery.

8976
14:55:40.536 --> 14:55:48.036
And we have a bullet proof way to solve creating a truly fair decentralized lottery.

8977
14:55:48.036 --> 14:55:49.107
Oh my goodness.

8978
14:55:49.107 --> 14:55:53.108
Let's do one more compile for good measure H H compile.

8979
14:55:53.108 --> 14:55:54.958
And these are just warnings.

8980
14:55:54.958 --> 14:55:56.273
So we're good to go here.

8981
14:55:56.273 --> 14:55:58.800
Our code is compiling successfully.

8982
14:55:58.800 --> 14:56:10.778
Like I said Normally, this definitely isn't going to be the way that you're going to write your smart contracts, it's almost impossible to write a full smart contract without making any mistakes.

8983
14:56:10.778 --> 14:56:19.416
And without flipping back and forth between documentation, I have already written this contract many times myself, and I still made a whole bunch of mistakes.

8984
14:56:19.416 --> 14:56:26.216
So it is totally reasonable and totally rational for anybody and everybody to make mistakes going through this.

8985
14:56:26.216 --> 14:56:29.176
And to use resources and to write tests along the way.

8986
14:56:29.176 --> 14:56:33.251
Now that we have our raffle dot Seoul created, it's time to add everything else.

8987
14:56:33.251 --> 14:56:39.478
So we're going to come over here, we're gonna create a new folder, and add our deploy folder per usual.

8988
14:56:39.537 --> 14:56:45.072
And we're going to do exactly what we've already done a couple of times, we're going to create some scripts to deploy our raffle contract.

8989
14:56:45.072 --> 14:56:52.198
Now with our raffle contract, there's a couple of things in here that we want to make note of first thing is that our constructor right now is absolutely massive.

8990
14:56:52.198 --> 14:56:56.487
There are a ton of parameters in here that we need to account for.

8991
14:56:56.537 --> 14:57:00.946
Let's take a look at our constructors and see if there's any contracts that we're already interacting with.

8992
14:57:00.946 --> 14:57:02.519
Okay, VRF, coordinator v2.

8993
14:57:02.519 --> 14:57:10.070
This is a contract address, entrance fee, no gasline, no subscription ID no callback, guestimate No, and interval.

8994
14:57:10.070 --> 14:57:10.270
No.

8995
14:57:10.270 --> 14:57:16.214
So knowing that this is an address should be a tip that Ah, okay, we're probably going to need to deploy some mocks.

8996
14:57:16.214 --> 14:57:22.488
For this, since we're going to need to interact with a VRF coordinator contract that's outside of our project.

8997
14:57:22.537 --> 14:57:27.782
But let's go ahead and start working on our raffle deployment script first, and we know we're going to have to deploy some mocks.

8998
14:57:27.782 --> 14:57:29.355
So we'll just keep that in mind.

8999
14:57:29.355 --> 14:57:31.037
So let's create a new file.

9000
14:57:31.037 --> 14:57:33.912
Oh, one, deploy raffle.

9001
14:57:33.912 --> 14:57:34.162
js.

9002
14:57:34.162 --> 14:57:39.457
And let's get started deploying our raffle contract.

9003
14:57:39.457 --> 14:57:42.331
Now, this is going to look really similar to what we've done before.

9004
14:57:42.331 --> 14:57:43.473
And we're going to do it again here.

9005
14:57:43.538 --> 14:57:48.089
If you want to use your previous deploy scripts as a reference, I absolutely recommend you do so.

9006
14:57:48.089 --> 14:57:54.587
But let's get started with module that exports equals an async function.

9007
14:57:54.587 --> 14:58:02.905
That's going to take get named accounts and deployments.

9008
14:58:02.905 --> 14:58:08.605
As input parameters, then we're going to do const.

9009
14:58:08.605 --> 14:58:18.038
Deploy log equals deployments, then we're gonna say const, Deployer, equals await, get named accounts.

9010
14:58:18.038 --> 14:58:33.487
Let's go to our config and update module that exports to to have this I'm just going to copy paste, so that employer is going to be defaulted to account zero and player is going to be defaulted to account one, if you want to go ahead and write this out, feel free to pause and write out your name accounts.

9011
14:58:33.487 --> 14:58:36.796
Right now, there's gonna be a lot of boilerplate in our heart hat.

9012
14:58:36.796 --> 14:58:37.183
config.

9013
14:58:37.183 --> 14:58:37.312
js.

9014
14:58:37.312 --> 14:58:45.792
So feel free to have the GitHub repo for this lesson up with you or your previous scripts that you've already written as a reference named accounts Deployer.

9015
14:58:45.792 --> 14:58:53.502
And we're also going to have a player named account so that we can separate different users or different players who are interacting with our contracts.

9016
14:58:53.538 --> 14:58:54.961
But for now, we're gonna grab our Deployer.

9017
14:58:56.538 --> 14:58:57.070
get started.

9018
14:58:59.538 --> 14:59:10.454
raffle equals await ploy, raffle, comma, and then add all of our stuff in here, right? So this would be from Deployer.

9019
14:59:10.538 --> 14:59:13.014
args, we're going to have a ton of args.

9020
14:59:14.539 --> 14:59:15.506
back to this.

9021
14:59:15.506 --> 14:59:18.167
And then log is going to be true.

9022
14:59:19.539 --> 14:59:25.280
going to have wait confirmations, there's a little bit more boilerplate we need to work with here in our Hardhead config, we don't have a network here.

9023
14:59:25.280 --> 14:59:27.089
So let's add our network information.

9024
14:59:27.089 --> 14:59:31.233
So we can get those block confirmations will be specific in here, as well.

9025
14:59:31.233 --> 14:59:35.539
And we'll say default network is going to be hard hat.

9026
14:59:35.539 --> 14:59:48.329
And then we'll say networks, and we'll add our network information that's going to be working with heart hub, which has a chain ID of 31337 miles, we'll put that in here as well.

9027
14:59:48.329 --> 14:59:56.030
And block confirmations were just set to one lot this column here, we're also gonna be running some staging tests on the Rinkeby network.

9028
14:59:56.030 --> 15:00:08.153
So we'll add rink B in here with a chain ID of four, block confirmations of six, and we need to add a URL and then also some accounts for our URL.

9029
15:00:08.153 --> 15:00:10.433
We've done this 100 times.

9030
15:00:10.433 --> 15:00:11.748
We'll do const.

9031
15:00:11.748 --> 15:00:25.996
rinky dink could be RPC URL equals process study and v dot rake, the RPC URL, that's private key, blah, blah, blah, we're going to add all these same variables from our last projects.

9032
15:00:25.996 --> 15:00:30.605
So I'm going to ask you to pause here and just copy paste all those variables from our last project.

9033
15:00:30.605 --> 15:00:40.391
Boom, like so since running rink, prpc, URL, private key corn market cap and ether scan, we're also going to want to make sure you folder, excuse me, new file, dot env.

9034
15:00:40.391 --> 15:00:49.668
And we're going to drop all of our information in here our rink, prpc, URL, private key, ether scan API key, and then our coin market cap API key as well.

9035
15:00:49.668 --> 15:00:59.298
Now that we have our private key or ring prpc URL down in URL, B RPC URL, and for accounts, we're just going to add that single private key.

9036
15:00:59.298 --> 15:01:14.701
Now for weight confirmations is going to equal For network config dot block con formations, or one, we're gonna have to import network from Hardhead, which looks like my VS code automatically did for me.

9037
15:01:14.701 --> 15:01:15.426
Thanks VS code.

9038
15:01:15.426 --> 15:01:17.898
So this is how we're going to deploy a raffle.

9039
15:01:17.898 --> 15:01:21.453
Obviously, we have a ton of arguments that we need to account for.

9040
15:01:21.453 --> 15:01:22.435
So let's get to it.

9041
15:01:22.540 --> 15:01:24.830
Let's look at our raffle constructor to see what we need to get.

9042
15:01:24.830 --> 15:01:39.487
Okay, well, the first thing that we need to get via of coordinator v2, we're gonna use the same strategy we used in our Funmi project with using mocks, if we're on a development chain, and using the actual contract address if we're on a test net, or a live network, so let's get to it.

9043
15:01:39.487 --> 15:01:47.095
So let's go ahead, recreate that helper, hard hat config dot j s and create that const.

9044
15:01:47.095 --> 15:01:47.983
Network.

9045
15:01:47.983 --> 15:01:54.149
Config, say it equals for hard hat, we're going to use a mock.

9046
15:01:54.149 --> 15:01:56.258
So we don't need to put that in here for now.

9047
15:01:56.258 --> 15:02:02.444
But for rink B, let's go ahead, but a foreign here, so the name is going to be Rinkeby.

9048
15:02:02.444 --> 15:02:10.477
And we're going to need to go to the chain link documentation, the VRF contracts, and we're going to need to grab the RF coordinator for the Rinkeby.

9049
15:02:10.477 --> 15:02:19.572
Test net, we're going to grab this address here, plop it in here, we'll say V RF core did an eight tour v two, bam, right like that.

9050
15:02:19.572 --> 15:02:35.243
So back in our deploy raffle, we're gonna have to pick whether or not to use the V RF coordinator v two in the network config or some mock that we deployed, which of course, leads us to us having to deploy a mock, let's create the new file 00.

9051
15:02:35.243 --> 15:02:36.665
Deploy marks.

9052
15:02:36.665 --> 15:02:36.883
js.

9053
15:02:36.883 --> 15:02:56.616
So same thing module that exports equals async function where it's taking, get named accounts, and deployments, as its input variables from the heart at runtime environment, or do const deploy COMM A log equals deployments.

9054
15:02:56.616 --> 15:03:10.844
And then const, Deployer equals await, get named accounts, Excel, and then we're going to grab the chain ID as well as we're going to only wants to deploy this on a development chain.

9055
15:03:10.844 --> 15:03:17.023
So we'll do const chain ID equals network dot config dot chain ID.

9056
15:03:17.023 --> 15:03:20.420
Now we're going to only want to deploy mocks, if we're on a development chain.

9057
15:03:20.420 --> 15:03:25.069
So once again, we're going to go to our helper config, we're going to add those development chains in here.

9058
15:03:25.069 --> 15:03:32.741
We'll say const, development chains equals hard hat, and localhost.

9059
15:03:32.741 --> 15:03:36.541
And then we're gonna want to export both of these.

9060
15:03:36.541 --> 15:03:44.374
So module, dot exports, equals network config, and development chance.

9061
15:03:44.374 --> 15:04:00.713
Now in our deploy mocks, we're gonna want to grab those are saying const development chains, equals require dot dot slash helper helper hardhat config.

9062
15:04:00.713 --> 15:04:09.168
Now we can check to see if development chains dot includes the network dot name that we're currently on.

9063
15:04:09.168 --> 15:04:16.902
If we're in a development chain, we're gonna go ahead and log local network, the protected, deploying box.

9064
15:04:16.902 --> 15:04:29.439
And now we'll have to deploy a mock VRF coordinator, where do we get a mock VRF to coordinator Well, let's go ahead and create one of those.

9065
15:04:29.542 --> 15:04:30.961
We go to the chainlink.

9066
15:04:30.961 --> 15:04:33.090
GitHub again, we go to contracts.

9067
15:04:33.542 --> 15:04:33.649
0.

9068
15:04:39.542 --> 15:04:42.491
Mach dot Sol, and we're just going to use this as our mock.

9069
15:04:42.542 --> 15:04:57.727
So in our contracts folder, we're gonna create a new file called test new file called V RF core, in a core, the two mock dot Sol, and we're just going to import this mock and have it be our mock.

9070
15:04:57.727 --> 15:05:00.245
So we'll do spdx.

9071
15:05:00.245 --> 15:05:05.772
We'll do pragma, solidity, carrot zero, point 8.

9072
15:05:05.772 --> 15:05:15.197
0, or seven or whatever we want to do, we'll do import at chainlink slash contracts slash SRC slash v 0.

9073
15:05:15.197 --> 15:05:15.311
8.

9074
15:05:15.542 --> 15:05:18.558
Slash, mocks, slash VRF.

9075
15:05:23.542 --> 15:05:27.912
And we'll just check to see if it compiles with Hardhead compile, and it looks like it's compiling as well.

9076
15:05:27.912 --> 15:05:28.299
Awesome.

9077
15:05:28.299 --> 15:05:33.620
So now that we have our mock contract, we can actually go ahead and deploy it.

9078
15:05:33.620 --> 15:05:44.186
So we'll do a weight loi, the RF core de ne Tor V to Mach comma, and then we'll give it our parameters in here.

9079
15:05:44.186 --> 15:05:45.870
We'll say from Deployer.

9080
15:05:45.870 --> 15:05:50.808
Log is going to be true, and then we're going to do our arguments.

9081
15:05:50.808 --> 15:05:54.762
Now, what are the arguments of this VRF coordinator, v2 Mk.

9082
15:05:54.762 --> 15:06:06.011
Well, if we open the VRF coordinator v2 Mock, right in our VS code, or on GitHub, we can actually see We will roll over to the constructor that it takes two things.

9083
15:06:06.011 --> 15:06:09.214
It takes a base fee and a gas price link.

9084
15:06:09.214 --> 15:06:13.908
What are these first one? Well, the first one is this const base fee.

9085
15:06:13.908 --> 15:06:19.182
If we go back to the documentation, we can see that there's this premium section of 0.

9086
15:06:19.182 --> 15:06:25.123
25 Link rink B, this means that for each request, there's a base fee of 0.

9087
15:06:25.123 --> 15:06:27.139
25 link for every request.

9088
15:06:27.139 --> 15:06:32.068
So anytime we want to request a random number on Rinckey, it's going to cost us 0.

9089
15:06:32.068 --> 15:06:32.237
25.

9090
15:06:32.237 --> 15:06:35.118
Link, or you can think of it as 0.

9091
15:06:35.118 --> 15:06:37.480
25 Oracle gas to make this request.

9092
15:06:37.480 --> 15:06:49.936
So back in our deploy mocks, we can say base V equals, we could resemble Rinckey here and do 25, blah, blah, blah, or we could do ethers dot utils dot parse eath, of 0.

9093
15:06:49.936 --> 15:06:50.132
25.

9094
15:06:50.132 --> 15:06:54.754
And I'll even put a little comment here, say 0.

9095
15:06:54.754 --> 15:06:58.139
25 is the premium, it costs 0.

9096
15:06:58.139 --> 15:07:00.284
25 Link per request.

9097
15:07:00.284 --> 15:07:04.076
And remember, the reason that this cost 0.

9098
15:07:04.076 --> 15:07:09.193
25 Link per request versus the price feeds didn't cost anything is because the price feeds.

9099
15:07:09.193 --> 15:07:29.887
If we look back at a chain that link, each one of these price feeds is being sponsored by a group of protocols who are paying for all these requests already, since there isn't a sponsor for this, we are the only ones requesting the randomness, we get to be the ones to actually sponsor getting this random number, then the second thing here is going to be the gas price link.

9100
15:07:29.887 --> 15:07:33.376
So let's create another const here to const.

9101
15:07:33.376 --> 15:07:34.626
gas price link.

9102
15:07:34.626 --> 15:07:42.797
But what this is, is actually a calculated value is a calculated value based on the gas price of the chain.

9103
15:07:42.797 --> 15:07:54.998
Here's an example if we were to request a random number on Aetherium, and the eath price skyrocketed up to like to like a billion dollars, gas would be incredibly, incredibly expensive.

9104
15:07:54.998 --> 15:08:10.351
Now when chain link nodes respond chain link nodes pay the gas fees, who give us randomness, and do external execution, the chain link nodes are actually the ones that pay the gas when returning randomness or executing an upkeep or etc.

9105
15:08:10.351 --> 15:08:23.511
If we go to our raffle dot soul, and scroll down to perform upkeep, or fulfill random words, it's actually the chain link nodes that are calling these two functions and paying the gas for it, they get paid in Oracle gas to offset those costs.

9106
15:08:23.511 --> 15:08:29.859
But if the price of eath, or any native blockchain skyrocketed the chain that nodes itself to pay the gas fee.

9107
15:08:29.859 --> 15:08:40.486
So the chain link nodes have a calculated price have a calculated variable called the gas price per link, which fluctuates based off the price of the actual chain, so that they never go bankrupt.

9108
15:08:41.544 --> 15:08:51.431
Basically, the price of a request changes based off the price of gas for that blockchain, you can kind of think of this as the link per gas, if you will, for now we can kind of just set it to whatever we want.

9109
15:08:51.431 --> 15:08:58.169
And we'll just set it to one e nine, which is going to be equivalent to 1123456789.

9110
15:08:58.169 --> 15:09:18.889
So now that we have the base fee, and the gas price link, we'll grab this base fee, we'll have these be the arguments for our VR chord, enter V to mock, so we'll say and actually we can delete that will say const, args equals base fee, and gas price link, then we can take this args variable and just plop it in here.

9111
15:09:18.889 --> 15:09:32.223
Now we can do log mocks deployed, then we can do log that a little line like this to let people know that this deploy script is done, then we'll just do a module that exports dot tags equals all and mocks.

9112
15:09:32.223 --> 15:09:40.732
So now that we have a view of coordinator v2 Mock deployed, we'll come back over to our raffle and make some code around it.

9113
15:09:40.732 --> 15:09:43.945
Similar to what we just did with our deploy mocks.

9114
15:09:43.945 --> 15:09:50.254
We can say if development chains that includes network dot name, we'll do some stuff.

9115
15:09:50.254 --> 15:09:54.303
And we need to import development chains from our helper Hardhead config.

9116
15:09:54.303 --> 15:09:56.839
And we need to import network from hard hat.

9117
15:09:56.839 --> 15:09:59.708
My VS code automatically added them Wow, thanks VS code.

9118
15:09:59.708 --> 15:10:02.883
Let's even just do const args and make this variable down here.

9119
15:10:02.883 --> 15:10:03.811
Stick it in args.

9120
15:10:03.811 --> 15:10:20.165
Our first argument is going to need to be this Vera fi to coordinator so let's make a variable we'll say let VRF core need torby to address and if we're on a development chain, we're going to grab that mock contract.

9121
15:10:20.165 --> 15:10:44.375
So we'll say const PRF, Cor de ATAR V to mock equals await ethers dot get contract, the RF cord the cord to NATO Tor v two MK, and then we can set the RF coordinator v two address equals VRF core denater V two mach dot address.

9122
15:10:44.375 --> 15:10:44.968
Cool.

9123
15:10:44.968 --> 15:10:48.052
We have that address here.

9124
15:10:48.052 --> 15:10:57.412
Else if we're not on a local network, the VRF v2 coordinator address is simply going to be derived from our network config.

9125
15:10:57.412 --> 15:11:08.562
So let's import the network config as well from our helper Hardhead config and we'll say else VRF coordinator v2 address equals network config of our chain ID.

9126
15:11:08.562 --> 15:11:21.062
Let's which actually sorry, we do need the chain ID cons chain ID equals network dot config dot chain ID, chain ID of VR coordinator V to chain ID.

9127
15:11:21.062 --> 15:11:23.675
You're a coordinator v2.

9128
15:11:23.675 --> 15:11:24.771
Alright, perfect.

9129
15:11:24.771 --> 15:11:28.627
We've got the setup to work with our VRF coordinator v2 address.

9130
15:11:28.627 --> 15:11:38.498
What else do we need from our raffle? Well, we need an entrance fee, we probably want to change the entrance fee depending on what chain we're on, we're on a more expensive chain, we might want to make this higher than others.

9131
15:11:38.546 --> 15:11:48.962
So let's go ahead back to our helper Hardhead config and make an entrance fee based off of the blockchain, so for NP, maybe we want to make it 0.

9132
15:11:48.962 --> 15:11:49.545
01 eath.

9133
15:11:49.545 --> 15:11:54.201
So we could say ethers dot utils, parse ether of 0.

9134
15:11:54.201 --> 15:11:54.407
01.

9135
15:11:54.407 --> 15:12:00.336
And once again, thank you VS code for automatically dropping that in for me.

9136
15:12:00.336 --> 15:12:07.283
And we're also going to want an entrance fee for our heart app, we can also set a default in here, but let's just be a little more explicit.

9137
15:12:07.283 --> 15:12:08.817
So we'll say 31337.

9138
15:12:08.817 --> 15:12:15.923
The name of this is Art app, we don't need to give it a veneer of coordinator v2 address because we're going to deploy a mock.

9139
15:12:15.923 --> 15:12:17.447
But we do want an entrance fee.

9140
15:12:17.546 --> 15:12:20.084
And let's just give it the exact same entrance fee here.

9141
15:12:20.546 --> 15:12:22.958
say ethers dot utils dot parse ether 0.

9142
15:12:22.958 --> 15:12:23.211
01 E.

9143
15:12:23.211 --> 15:12:24.163
Alright, great.

9144
15:12:24.546 --> 15:12:33.659
on our deploy here, we can just say const entrance fee equals network config.

9145
15:12:33.659 --> 15:12:37.433
Chain ID of entrance fee.

9146
15:12:37.433 --> 15:12:40.654
Let's start populating our arcs here.

9147
15:12:40.654 --> 15:12:43.301
So the first one is going to be your Fe two coordinator address.

9148
15:12:43.301 --> 15:12:44.777
Next one is going to be our entrance fee.

9149
15:12:44.777 --> 15:12:45.930
Got it? Got it.

9150
15:12:45.930 --> 15:12:47.853
Now we need our gas lane.

9151
15:12:47.853 --> 15:13:07.030
On Rigby and other networks, there are different gas lanes that we can choose from, let's grab the only gas Lane from Rinckey, the 30, gray key hash, let's drop this, of course into our network config as gasoline, pop it in here, we're hard hat, our mock actually doesn't care what gas line we're working on, because we're going to be mocking the gasoline anyways.

9152
15:13:07.030 --> 15:13:12.772
So we can just say gas lane, we can just go ahead and use the same one or really anything here, it doesn't really matter.

9153
15:13:12.772 --> 15:13:18.427
Now here we'll say const, gasoline equals network config.

9154
15:13:18.547 --> 15:13:22.598
Chain ID, gasoline, and we'll grab the gas lane.

9155
15:13:23.547 --> 15:13:27.710
stick it into our argument array, we've got this one, we've got this one, we've got this one.

9156
15:13:27.710 --> 15:13:29.637
Now it's time for the subscription ID.

9157
15:13:29.637 --> 15:13:50.932
Now if you haven't run through docstoc chain link for the chain link VRF, I highly recommend you do so so that you can understand what this subscription ID is we know that we can actually make a subscription ID using that front end using that website VRF dot chain dot link, which is great and all but what if we're on all local chains, we can get a subscription ID no problem in here.

9158
15:13:50.932 --> 15:13:53.756
But it's a little bit harder on a local network.

9159
15:13:53.756 --> 15:13:58.333
Now I'm actually going to teach you how to create and fund subscription it is completely programmatically.

9160
15:13:58.333 --> 15:14:01.186
So you don't even need to use the UI if you don't want to.

9161
15:14:01.186 --> 15:14:08.297
However, for the purpose of this course, we're still going to use the user interface, we're still going to use that website for us to get our own subscription IDs.

9162
15:14:08.297 --> 15:14:13.835
But you could 100% automate the process of creating a subscription ID and funding a subscription ID.

9163
15:14:13.835 --> 15:14:20.984
Because when you create and fund subscription IDs, you're just calling create subscription and fund subscription on that smart contract.

9164
15:14:20.984 --> 15:14:29.354
So on our development chain, we have our V RF coordinator v2 Mock, and what we're going to do and on our development chain, we're going to create that subscription.

9165
15:14:29.354 --> 15:14:41.785
So we're gonna say const, transaction, response equals await VRF coordinator v2 Mock dot create sub scription.

9166
15:14:41.785 --> 15:14:54.039
And then we'll run const transaction receipt equals weight trends action response, dot Wait, wait one block confirmation.

9167
15:14:54.039 --> 15:15:03.709
And inside this transaction receipt, there's actually an event that's emitted with our subscription that we can get this is another place where emitting events is incredibly helpful.

9168
15:15:03.709 --> 15:15:18.902
So in fact, if we open back up a Vera v2 coordinator mark, and we look for create subscription, we see we emit subscription created with the subscription ID, we can actually get this event emitted from our transaction receipt.

9169
15:15:18.902 --> 15:15:23.214
Now to assign it, let's go ahead and create a sub subscription ID up here.

9170
15:15:23.214 --> 15:15:34.203
And then we'll say subscription ID equals transaction receipt that events of zero dot args dot sub ID.

9171
15:15:34.203 --> 15:15:40.698
And again, be sure to watch that events video if you want to learn more about how to work with events in hardware.

9172
15:15:40.698 --> 15:15:47.863
Now that we have a subscription, we need to fund the subscription on a real network, you'd need the link token to actually fund the subscription.

9173
15:15:47.863 --> 15:15:52.259
The current iteration of the mock allows you to fund a subscription without the link token.

9174
15:15:52.259 --> 15:16:24.082
So what we can do is we can just run a wait your F corps inator Mark, if coordinator B to Mach dot fund subscription, and we'll give it the subscription ID and we'll need to do some fundamental this, we can just create some variable, we'll say const VRF, subscription fund amount equals ethers dot utils, dot parse ether, of, we'll say 30 VRF subscription, fundament.

9175
15:16:24.082 --> 15:16:26.215
We'll just paste that down here.

9176
15:16:26.215 --> 15:16:29.310
We could do this as well for a real test net or live networks.

9177
15:16:29.310 --> 15:16:34.735
But just so that we become familiar with the user interface, we're not going to do a test net programmatically.

9178
15:16:34.735 --> 15:16:37.725
And for a test net, we're just going to use exactly what we've been doing so far.

9179
15:16:37.725 --> 15:16:41.059
Or we can put a subscription ID and our helper config.

9180
15:16:41.059 --> 15:16:47.303
So we'll say subscription ID, we'll put something in here right now, we'll just leave it as zero.

9181
15:16:47.303 --> 15:16:52.715
But later on, when we actually create a subscription, we'll update our subscription ID.

9182
15:16:52.715 --> 15:16:58.456
And so we'll say subscription ID equals network config.

9183
15:16:58.456 --> 15:17:02.471
Change ID of subscription ID.

9184
15:17:02.471 --> 15:17:03.578
Perfect.

9185
15:17:03.578 --> 15:17:07.715
Now we can add this to our arguments array.

9186
15:17:07.715 --> 15:17:15.049
What else do we need subscription ID, we need a callback gas limit or callback, gas limit is going to vary network to network.

9187
15:17:15.049 --> 15:17:18.972
So once again, we're gonna go into our helper configure callback gas limit.

9188
15:17:18.972 --> 15:17:23.844
And for us, we'll set a pretty high limit of 500,000 gas.

9189
15:17:23.844 --> 15:17:27.286
So we'll say call a gas limit of 5.

9190
15:17:27.286 --> 15:17:28.367
123 500,000.

9191
15:17:28.367 --> 15:17:28.760
Gas.

9192
15:17:28.760 --> 15:17:31.430
And for hard hat, we'll do the same thing.

9193
15:17:31.430 --> 15:17:44.470
So we can say const, callback, gas limit equals network config, chain ID, callback, gas limit, grab this, put it into our argument array.

9194
15:17:44.550 --> 15:17:47.200
What else do we need? All we need now is the interval.

9195
15:17:47.550 --> 15:17:50.397
can change this network to network as well.

9196
15:17:51.550 --> 15:17:57.050
interval will ever just be 30 seconds for both hard hat and for Rigby.

9197
15:17:57.050 --> 15:17:58.827
So we'll do the same thing here.

9198
15:17:58.827 --> 15:17:59.382
Say const.

9199
15:17:59.550 --> 15:18:03.484
Interval equals network config.

9200
15:18:07.550 --> 15:18:10.856
grab this, pop it in the end of our array.

9201
15:18:12.550 --> 15:18:15.946
Now we have an argument array and drop it right in here and perfect.

9202
15:18:15.946 --> 15:18:18.963
Everything in our constructor for our raffle contract.

9203
15:18:18.963 --> 15:18:19.273
Great.

9204
15:18:19.273 --> 15:18:20.617
This is looking fantastic.

9205
15:18:20.617 --> 15:18:24.683
We've got wait confirmations we got logging arguments Deployer.

9206
15:18:24.683 --> 15:18:29.487
Okay, well, what next? Well, let's go ahead and add that verification piece.

9207
15:18:29.550 --> 15:18:34.994
So once again, create a new folder utils, new file verify.

9208
15:18:34.994 --> 15:18:35.142
js.

9209
15:18:35.142 --> 15:18:48.009
We can either copy paste this from our last project, or we can grab this from the GitHub repo associated with this course, once we have our verify script in here, we're going to import it by saying const.

9210
15:18:48.009 --> 15:18:54.860
Verify equals require dot dot slash helper Hardhead config.

9211
15:18:54.860 --> 15:19:07.425
And then we can add that same bit of code down here to verify our contract, we'll say if we're not on a development chain.

9212
15:19:07.425 --> 15:19:23.075
And we have process studying v dot ether scan API key, then we're going to log verifying dot dot and then await verify raffle dot address and the arcs.

9213
15:19:23.075 --> 15:19:34.519
Now we'll just do a log of a whole bunch of hyphens say that this script is done module dot exports dot tags equals say this will be all and raffle.

9214
15:19:34.519 --> 15:19:37.228
All right, so let's test this out.

9215
15:19:37.228 --> 15:19:44.217
We'll do hardhat deploy, or yarn, hard hat deploy and see if this script works correctly.

9216
15:19:44.217 --> 15:19:48.173
Looks like we ran into an error network config not defined.

9217
15:19:48.173 --> 15:19:49.789
So let's spell this right.

9218
15:19:49.789 --> 15:19:50.503
Network config.

9219
15:19:50.503 --> 15:19:51.074
There we go.

9220
15:19:51.074 --> 15:19:52.359
And that looks much better.

9221
15:19:52.551 --> 15:19:53.585
Let's try this again.

9222
15:19:55.551 --> 15:19:56.205
working well.

9223
15:19:58.551 --> 15:20:05.451
deployed VRF coordinator v2 Mock mocks deployed and then we went ahead and deployed our raffle.

9224
15:20:05.451 --> 15:20:07.951
Awesome, this is massive.

9225
15:20:07.951 --> 15:20:14.499
Now we're not going to test the deploying this to a test net quite yet, because well, we don't have any unit tests yet.

9226
15:20:14.551 --> 15:20:18.851
We need to write unit tests before we want to ever test running this on a test net.

9227
15:20:18.851 --> 15:20:23.801
So we have our deploy script, we have our contracts, that means it's time for us to write some tests.

9228
15:20:23.801 --> 15:20:26.757
We'll come over here we'll create a new folder called test.

9229
15:20:26.757 --> 15:20:29.032
And for now, we'll just make our unit tests.

9230
15:20:29.032 --> 15:20:34.680
So unit tests, and in here we create a new file called raffle.

9231
15:20:34.680 --> 15:20:35.067
test.

9232
15:20:35.067 --> 15:20:35.260
js.

9233
15:20:35.551 --> 15:20:36.981
And let's write some unit tests.

9234
15:20:38.551 --> 15:20:42.173
going to be a little bit verbose here, we're going to make our coverage really, really good here.

9235
15:20:42.173 --> 15:20:45.389
It's not gonna be perfect, but this is going to be pretty verbose.

9236
15:20:45.389 --> 15:20:47.171
So I'm gonna go pretty quickly here.

9237
15:20:47.171 --> 15:20:52.689
So you can feel free to pause, slow me down, speed me up whatever you need to learn this section.

9238
15:20:52.689 --> 15:20:59.518
It is really good muscle memory to go through writing these tests and understand what you should be thinking about when you're writing these tests.

9239
15:20:59.518 --> 15:21:03.487
So feel free to speed up the parts You already know and slow down the new parts.

9240
15:21:03.487 --> 15:21:06.952
Because we are going to go over some new information here.

9241
15:21:06.952 --> 15:21:09.689
writing tests may seem like a tedious process.

9242
15:21:09.689 --> 15:21:16.896
But I promise as you get better at writing these tests, you'll realize that these are the things that you can rely on when stuff doesn't work.

9243
15:21:16.896 --> 15:21:23.823
And when you're not sure how to code, something, getting this muscle memory down, writing these tests is going to make you a fantastic engineer.

9244
15:21:23.823 --> 15:21:29.489
So let's go through and we'll write some of these verbose tests here to try to make this really good and have this have really good coverage.

9245
15:21:29.489 --> 15:21:35.409
And if you want to go back later on, and see if you can give it even more coverage, and even better tests, please feel free to do so.

9246
15:21:35.409 --> 15:21:36.456
But let's get started.

9247
15:21:36.552 --> 15:21:37.599
Let's write some tests.

9248
15:21:39.552 --> 15:21:46.355
the same way we've been starting everything out, we're going to grab our development chains, so that we only run our unit tests on a development chain.

9249
15:21:46.355 --> 15:22:06.174
So we'll do const development chains, equals require dot dot slash dot dot slash helper, RD, hard hat config, and then we'll say not development chains, that includes network dot name, and describe that skip.

9250
15:22:06.174 --> 15:22:12.197
Otherwise, we'll do describe, so this first describe is going to be our raffle unit tests.

9251
15:22:12.197 --> 15:22:15.390
And this is going to be an async.

9252
15:22:15.390 --> 15:22:16.260
function.

9253
15:22:16.552 --> 15:22:20.164
So raffle unit tests so that it comes on the next line, it looks a little bit better.

9254
15:22:20.164 --> 15:22:20.647
Alright, great.

9255
15:22:20.647 --> 15:22:37.001
Now, what are some of the main things that we're going to need to deploy? Well, we're gonna need to deploy a raffle, we're probably going to want a VRF core to a tour be to mock graded before each, that's going to be an async function, where we go ahead and we get these will say const.

9256
15:22:37.001 --> 15:22:41.345
Employer equals await, get named accounts.

9257
15:22:41.553 --> 15:22:49.460
So we're gonna need to import get named accounts or require get name accounts from hard hat, then we're going to want to deploy these using our fixtures.

9258
15:22:49.460 --> 15:22:51.429
So we can say await deployments.

9259
15:22:51.553 --> 15:23:01.053
And then we're going to import deployments as well from hardhat dot fixture, and we're going to call all, we're going to deploy everything.

9260
15:23:01.053 --> 15:23:08.654
And again, if we look at our one, our raffle has the alt tag, and our Oh, our mocks also have the alt tag, okay, perfect.

9261
15:23:08.654 --> 15:23:15.749
Once we deploy everything, we can say raffle equals await ethers dot get to contract.

9262
15:23:15.749 --> 15:23:19.486
And we got to import ethers from hard hat, like so.

9263
15:23:19.486 --> 15:23:27.026
And we'll say it will get the raffle contract and we'll connect it to our Deployer.

9264
15:23:27.026 --> 15:23:40.129
And then we're going to do the same thing with VRF coordinator v2 Mock equals await ethers dot get contract, the RF coordinator, B to MK connect this to deployer as well.

9265
15:23:40.129 --> 15:23:45.671
Alright, great, our first set of tests describe, they're going to be the constructor.

9266
15:23:45.671 --> 15:23:49.942
And this is going to be an async function.

9267
15:23:49.942 --> 15:23:51.693
And let's do this.

9268
15:23:51.693 --> 15:24:01.762
Let's create an IT initial initializes the raffle correctly, this is going to be an async function.

9269
15:24:01.762 --> 15:24:14.377
Now I just want to make a note, because ideally, we make our tests have just one assert, or it just keep that in mind is that ideally, we want to have just one assert for it.

9270
15:24:14.377 --> 15:24:18.295
But we're going to have a bunch because like I said, we're being a little bit loose here.

9271
15:24:18.295 --> 15:24:21.938
So we want to just make sure that our raffle is initialized correctly.

9272
15:24:21.938 --> 15:24:30.467
So we'll say const raffle state, and we'll get that raffle state because we want to make sure that we start in an open raffle state.

9273
15:24:30.467 --> 15:24:38.284
So we'll say const, raffle state equals await raffle dot get raffle state.

9274
15:24:38.284 --> 15:24:44.657
And then we want to say assert dot equal ope and then we need to import assert from Chai.

9275
15:24:44.657 --> 15:24:49.384
So assert equals require Chai assert dot equal raffle state.

9276
15:24:49.384 --> 15:24:55.102
to string because again, raffle state is going to be a big number.

9277
15:24:55.102 --> 15:25:02.844
And even though a raffle state is of type raffle state, it'll return a zero if it's open and a one if it's calculating.

9278
15:25:02.844 --> 15:25:06.392
So this gets transformed just into a un 256.

9279
15:25:06.554 --> 15:25:10.506
When we call it like this, a raffle state variable here will be a big number.

9280
15:25:10.506 --> 15:25:12.791
So we want to just to string a file.

9281
15:25:12.791 --> 15:25:15.689
So assert dot equal raffle state DOT two string zero.

9282
15:25:15.689 --> 15:25:19.172
We'll also make sure our interval gets set correctly.

9283
15:25:19.172 --> 15:25:26.268
So we'll do const interval equals await raffle dot get interval.

9284
15:25:26.268 --> 15:25:33.363
And I don't know if we have one of those it's actually C inter ball see if we have one of those.

9285
15:25:33.363 --> 15:25:41.472
We don't have a good interval let's go ahead and add again interval function so we'll do function get in trouble.

9286
15:25:41.472 --> 15:25:58.316
We have public view returns you went to six return I underscore interval will have good interval will say raffle dot get interval and will also say assert dot equal interval.

9287
15:25:58.316 --> 15:25:59.117
to string.

9288
15:25:59.117 --> 15:26:06.194
It should equal one Ever is in our helper config, right? Because we're using the interval and helper config.

9289
15:26:06.194 --> 15:26:07.200
So we say interval.

9290
15:26:07.200 --> 15:26:08.974
to string should equal.

9291
15:26:08.974 --> 15:26:11.312
So we'll import that as well.

9292
15:26:11.555 --> 15:26:12.827
Network config.

9293
15:26:16.555 --> 15:26:17.932
network config.

9294
15:26:22.555 --> 15:26:24.848
chain ID, say const.

9295
15:26:29.555 --> 15:26:34.587
chain ID, network config of the chain ID of interval.

9296
15:26:35.555 --> 15:26:35.930
cool.

9297
15:26:41.555 --> 15:26:43.081
And cool looks like it passed.

9298
15:26:44.555 --> 15:26:45.087
output here.

9299
15:26:45.087 --> 15:26:45.474
Awesome.

9300
15:26:47.555 --> 15:26:50.361
that it doesn't always print out at gas, but there for now.

9301
15:26:50.555 --> 15:26:55.412
I'm going to copy paste the gas reporter section from our last project, like so.

9302
15:26:55.412 --> 15:26:58.227
And we're going to have enabled gas be false for now.

9303
15:26:58.227 --> 15:27:04.538
So now if we run a Hardhead test, again, we shouldn't have that gas bid printed out, we should just see the tests and perfect, that's what we see.

9304
15:27:04.538 --> 15:27:06.313
And our constructor test passes.

9305
15:27:06.313 --> 15:27:08.933
Yay, what's next, got our constructor.

9306
15:27:08.933 --> 15:27:11.401
And we probably could have written more tests for the rest of these.

9307
15:27:11.401 --> 15:27:12.440
But let's just move on.

9308
15:27:12.440 --> 15:27:16.950
Alright, enter raffle, that's going to be our next describe block.

9309
15:27:16.950 --> 15:27:20.620
So it will do describe, enter, raffle.

9310
15:27:20.620 --> 15:27:24.062
And this is going to be an async function.

9311
15:27:24.062 --> 15:27:32.948
And we'll say it reverts when you don't pay enough, right, because one of the first things that we check is that they're paying enough.

9312
15:27:32.948 --> 15:27:37.889
So we want to make sure that this actually reverts if they don't pay enough.

9313
15:27:37.889 --> 15:27:40.047
So this will be an async function.

9314
15:27:40.047 --> 15:27:43.841
Where we're going to do that same expect await thing.

9315
15:27:43.841 --> 15:27:50.277
So we're going to import expect from Chai, which comes from those waffle matchers.

9316
15:27:50.277 --> 15:27:56.505
And we're gonna say await, expect raffle dot enter a raffle.

9317
15:27:56.505 --> 15:28:05.314
And we're not going to pass any value here, we're going to expect it to dot b dot reverted with.

9318
15:28:05.314 --> 15:28:10.822
And if we look here, we want it to be reverted with this raffle not enough eath entered.

9319
15:28:10.822 --> 15:28:15.460
So we can put that in quotes raffle not enough eath entered.

9320
15:28:15.460 --> 15:28:16.602
Now we can try this out.

9321
15:28:16.602 --> 15:28:18.703
Make sure that it actually works.

9322
15:28:18.703 --> 15:28:20.834
Ah ah test dash dash grep.

9323
15:28:20.834 --> 15:28:24.222
Put this in quotes that you don't pay enough.

9324
15:28:24.222 --> 15:28:25.022
And awesome.

9325
15:28:25.022 --> 15:28:26.355
We're passing there.

9326
15:28:26.556 --> 15:28:32.047
What else do we want to test? Well, we want to test that if the raffle isn't open, we also revert but we'll test that in a little bit.

9327
15:28:32.047 --> 15:28:34.456
As we kind of test the rest of the functionality.

9328
15:28:34.556 --> 15:28:39.698
We want to see that it records players when they enter.

9329
15:28:40.556 --> 15:28:42.280
will be an async function.

9330
15:28:44.556 --> 15:28:47.056
First we're going to need that raffle entrance fee.

9331
15:28:47.556 --> 15:28:49.081
ahead and save that at the top.

9332
15:28:50.556 --> 15:29:01.056
coordinator be to mock raffle entrance fee and then our before each will say raffle entrance fee equals a weight ethers dot get entrance fee.

9333
15:29:01.056 --> 15:29:05.087
This should be raffle dot get entrance fee.

9334
15:29:05.087 --> 15:29:17.041
So now we have this raffle entrance fee, you can use it to enter the raffle we'll say a weight raffle dot enter raffle with a value of raffle entrance fee.

9335
15:29:17.041 --> 15:29:21.842
And we can make sure that our Deployer here has been correctly recorded.

9336
15:29:21.842 --> 15:29:24.249
So since right now we're connected to the Deployer.

9337
15:29:24.249 --> 15:29:28.387
We'll just make sure that that deployer actually is in our contract.

9338
15:29:28.387 --> 15:29:44.490
So we'll say const player from contract equals await raffle dot get player of zero, because we record them in our players array and we have our get players function which pulls them out.

9339
15:29:44.490 --> 15:29:51.470
And then we'll say assert dot equal player, player from contract should be the Deployer.

9340
15:29:51.557 --> 15:29:54.007
So now we can grep for this in our hard head test.

9341
15:29:54.557 --> 15:29:55.557
this works.

9342
15:29:55.557 --> 15:29:57.857
HH test dash dash grep.

9343
15:30:00.557 --> 15:30:01.326
We've got it up here.

9344
15:30:02.557 --> 15:30:03.223
globally.

9345
15:30:03.223 --> 15:30:06.223
So we got to do let common Deployer.

9346
15:30:07.557 --> 15:30:10.057
deployer equals await get named accounts.

9347
15:30:11.557 --> 15:30:14.466
this to get the deployer Awesome.

9348
15:30:16.557 --> 15:30:17.779
And awesome.

9349
15:30:22.557 --> 15:30:23.341
emitting an event.

9350
15:30:23.341 --> 15:30:25.048
So let's make sure it emits an event.

9351
15:30:25.557 --> 15:30:28.302
say it emits event on enter.

9352
15:30:31.557 --> 15:30:31.895
as well.

9353
15:30:34.557 --> 15:30:43.346
make sure a function emits an event and the syntax is going to look really similar to what we test for when we check to see if an error is fired.

9354
15:30:43.346 --> 15:30:58.796
So we're gonna say await expect raffle dot enter raffle with value of raffle entrance fee dot two dot omit and this.

9355
15:30:58.796 --> 15:31:09.207
to dot emit we get from During woful, these chime matches for emitting events we can do a wait expect to emit, and then the event that we're expecting to emit.

9356
15:31:09.207 --> 15:31:15.885
So we're saying to omit the raffle contract to emit a raffle enter event.

9357
15:31:15.885 --> 15:31:19.229
We can copy this, try to test this in our terminal.

9358
15:31:19.229 --> 15:31:21.136
So we'll say hard hat.

9359
15:31:21.136 --> 15:31:22.890
Test dash dash grep.

9360
15:31:22.890 --> 15:31:25.332
Just put this in quotes.

9361
15:31:25.332 --> 15:31:28.428
And that passes as well.

9362
15:31:28.428 --> 15:31:29.202
Great.

9363
15:31:29.202 --> 15:31:38.321
Let's now go ahead and test to make sure that we can't enter the raffle whenever this raffle is not open or it's calculating.

9364
15:31:38.321 --> 15:31:45.954
So we'll say it doesn't allow entrance, when raffle is Cal cumulating.

9365
15:31:45.954 --> 15:31:48.977
And this will be an async function.

9366
15:31:48.977 --> 15:31:59.824
And first we'll enter will say await raffle dot enter raffle value is raffle entrance fee.

9367
15:31:59.824 --> 15:32:05.933
Now what we want to do we want to get this raffle into a closed state.

9368
15:32:05.933 --> 15:32:08.367
So we want to get it out of its open state.

9369
15:32:08.367 --> 15:32:22.824
Well, how do we move this raffle from raffle dot open to raffle dot closed in perform upkeep, remove the raffle from raffle that open to raffle dot calculating but perform upkeep can only be called if check upkeep returns true.

9370
15:32:22.824 --> 15:32:26.424
Otherwise, it'll revert with raffle upkeep not needed.

9371
15:32:26.558 --> 15:32:29.808
So what we need to do is we need to make check upkeep return true.

9372
15:32:29.808 --> 15:32:36.291
And we will pretend to be the channeling keeper network to keep calling checkup keep waiting for it to be true.

9373
15:32:36.291 --> 15:32:43.913
And once we make it true, then we'll pretend to be the channeling keepers and call perform upkeep to put this contract in a state of calculating.

9374
15:32:43.913 --> 15:32:52.809
Now how do we actually do that? Well, in order for checkup keep to be true, we first need to see that we are indeed open, which we are.

9375
15:32:52.809 --> 15:32:56.927
The next thing that we need to do though, is we need to do this time passed bit.

9376
15:32:56.927 --> 15:33:01.268
We need to actually wait that 30 seconds for time to pass.

9377
15:33:01.268 --> 15:33:03.296
Now, that kind of sounds awful.

9378
15:33:03.296 --> 15:33:12.474
Do we have to wait 30 seconds for all of our tests? What if our interval was 10 days when we have to wait 10 days to run our tests? It sounds ridiculous.

9379
15:33:12.474 --> 15:33:20.674
Well, hard hat actually comes built in with a ton of functions for us to manipulate our blockchain to do literally whatever we want it to do.

9380
15:33:20.674 --> 15:33:22.404
In the hard hat documentation.

9381
15:33:22.404 --> 15:33:27.334
There's a section called Hard Hat Network reference inside the Hard Hat Network section.

9382
15:33:27.334 --> 15:33:33.965
And in here, there's a ton of information about how the hard hat network actually works and different configs that we can do with it.

9383
15:33:33.965 --> 15:33:41.995
If we scroll down low enough, we can see the JSON RPC methods that we can use on this blockchain, we can do eath accounts block number call chinetti.

9384
15:33:41.995 --> 15:33:45.225
We can do all these RPC methods that a normal blockchain has.

9385
15:33:45.225 --> 15:33:50.809
Additionally, we can do even more than that, we can use these things called Hard Hat Network methods.

9386
15:33:50.809 --> 15:33:52.613
Since this is our local Hard Hat Network.

9387
15:33:52.613 --> 15:33:56.869
And we're using this for testing, we want to be able to test any scenario.

9388
15:33:56.869 --> 15:34:02.905
And it's these methods that give us the ability to do that, you can go through this and play around and see all the different things you can do.

9389
15:34:02.905 --> 15:34:08.125
One of them in particular is going to be set storage set where you can set storage at any place, which is really fun.

9390
15:34:08.125 --> 15:34:14.130
But some of the special testing debugging methods are going to be EVM increase time, and EVM.

9391
15:34:14.130 --> 15:34:20.147
Mine increased time allows us to automatically increase the time of our blockchain and EVM.

9392
15:34:20.147 --> 15:34:28.244
Mine allows us to mine or create new blocks, because if we increase the time, it doesn't do anything unless there's a new block mined.

9393
15:34:28.244 --> 15:34:53.330
So what we can do is we can run a wait network, and we'll import network from Hard Hat Network await network dot provider that send EVM in crease time, comma, we can send a list of parameters to send with it, which for us are just going to be our interval.

9394
15:34:53.330 --> 15:34:54.067
to number.

9395
15:34:54.067 --> 15:34:55.717
And then we'll do plus one.

9396
15:34:55.717 --> 15:34:59.813
Now right now, our interval isn't stored globally, so we're probably going to want to do that.

9397
15:34:59.813 --> 15:35:01.971
So let's go ahead and do interval.

9398
15:35:01.971 --> 15:35:12.527
And then in our before each, we'll do interval equals await, raffle dot raffle dot get interval, I'm just going to copy this and we're going to delete this whole line.

9399
15:35:12.527 --> 15:35:14.397
Wait raffle dot get interval.

9400
15:35:14.397 --> 15:35:19.271
Since now we're just going to call it interval at a global level, since we're going to use it a lot.

9401
15:35:19.271 --> 15:35:21.560
Now we're gonna say interval that to number plus one.

9402
15:35:21.560 --> 15:35:28.910
So we want to increase the time by whatever our interval is to make sure that we can actually get that checkup keep to return true.

9403
15:35:28.910 --> 15:35:36.185
So additionally, we're going to want to do a weight network dot provider.

9404
15:35:36.185 --> 15:35:42.887
Dot send EVM mine with an empty array just because we just want to mine it one extra block.

9405
15:35:42.887 --> 15:35:52.463
You can also do network dot provider that request with an await here, these two would be basically the same, but this one's a little quicker, right? So we've increased the time of our blockchain.

9406
15:35:52.463 --> 15:35:54.785
We've mined a block to move forward.

9407
15:35:54.785 --> 15:35:56.729
It should be open time has passed.

9408
15:35:56.729 --> 15:36:00.216
Do we have a player? We do indeed, because we've entered the raffle.

9409
15:36:00.216 --> 15:36:04.294
We should have a balance because we've entered the right Apple, check upkeep should now return true.

9410
15:36:04.294 --> 15:36:08.830
So we should be able to call perform upkeep and pretend to be a chain lock keeper.

9411
15:36:08.830 --> 15:36:14.727
So we're going to pretend to be a chain the keeper and call await raffle dot perform upkeep.

9412
15:36:14.727 --> 15:36:21.595
And we're going to pass this some empty call data just by passing a blank array like that.

9413
15:36:21.595 --> 15:36:24.888
And now this should be in a calculating state.

9414
15:36:24.888 --> 15:36:32.866
So now that it's in a calculating state, we can say our enter raffle reverts correctly if the raffle isn't open.

9415
15:36:32.866 --> 15:36:38.238
So now we'll say await, expect raffle dot enter, raffle.

9416
15:36:38.238 --> 15:36:43.672
And we'll send it value of raffle entrance fee.

9417
15:36:43.672 --> 15:36:46.005
We're expecting this.

9418
15:36:46.005 --> 15:36:56.116
to dot b dot reverted with that raffle underscore underscore not open error.

9419
15:36:56.116 --> 15:37:00.893
Okay, let's try just this in our tests now.

9420
15:37:00.893 --> 15:37:04.856
So we'll run Hardhead test dash dash grep.

9421
15:37:04.856 --> 15:37:06.413
Put this in quotes.

9422
15:37:06.413 --> 15:37:11.361
And perfect that passes as well.

9423
15:37:11.561 --> 15:37:14.870
Now if we run Hardhead test, let's just test everything together right now.

9424
15:37:14.870 --> 15:37:16.760
And everything is passing.

9425
15:37:16.760 --> 15:37:18.192
Oh, this is wonderful.

9426
15:37:18.192 --> 15:37:18.613
Awesome.

9427
15:37:18.613 --> 15:37:19.665
Let's keep it going.

9428
15:37:19.665 --> 15:37:26.998
And if we run Hardhead coverage, we'll see our coverage is bumping up, we are already drastically better than where we were before.

9429
15:37:26.998 --> 15:37:31.294
Let's keep going well, let's go ahead and test our check upkeep now.

9430
15:37:31.294 --> 15:37:33.164
So we'll do describe, check upkeep.

9431
15:37:33.164 --> 15:37:41.527
And this will be an async function, where we'll say it returns false.

9432
15:37:41.527 --> 15:37:49.447
If people have been sent an E, E, it's been a sync function.

9433
15:37:49.562 --> 15:37:54.831
So we'll have everything in here be true except for the fact that nobody's entered yet.

9434
15:37:54.831 --> 15:38:06.404
So we'll do a weight network dot provider dot send EVM increase time, comma interval.

9435
15:38:06.404 --> 15:38:17.021
to number plus one will do a weight network dot provider.

9436
15:38:17.021 --> 15:38:19.824
That send UVM mine.

9437
15:38:19.824 --> 15:38:21.728
No parameters.

9438
15:38:21.728 --> 15:38:26.044
Now we're going to call check upkeep.

9439
15:38:26.044 --> 15:38:28.953
Now here's the thing, check.

9440
15:38:28.953 --> 15:38:31.387
upkeep is a public function.

9441
15:38:31.562 --> 15:38:45.212
So if we just run await, raffle dot check upkeep, and we pass nothing in this is going to kick off a transaction, because hard had knows Oh, okay, it's a public function, they're clearly trying to send a transaction here.

9442
15:38:45.212 --> 15:38:48.847
If this was a public view function, it wouldn't, it would return that view.

9443
15:38:48.847 --> 15:38:51.812
But the thing is, I don't really want to send a transaction.

9444
15:38:51.812 --> 15:38:57.862
But I want to simulate sending this transaction and seeing what this upkeep needed would return.

9445
15:38:57.862 --> 15:39:05.847
Well, I can actually get that by using something called call static, I can simulate calling this transaction and seeing what it will respond.

9446
15:39:05.847 --> 15:39:12.514
So instead of raffle dot, check upkeep, I can do raffle dot cost static, that check upkeep.

9447
15:39:12.514 --> 15:39:37.644
And this will give me the return of upkeep needed and the bytes perform data, I can extrapolate just the upkeep needed out of this return or writing const upkeep needed equals this, and then I can do assert not upkeep needed, because right now upkeep needed to return false.

9448
15:39:37.644 --> 15:39:40.696
So we'll say assert, not false, which is true.

9449
15:39:40.696 --> 15:39:43.337
If upkeep needed was true, then this would be false.

9450
15:39:43.337 --> 15:39:44.014
And this would break.

9451
15:39:44.014 --> 15:39:45.444
So that's what we want to do.

9452
15:39:45.444 --> 15:39:49.143
So let's go ahead, we'll run this, see if it worked.

9453
15:39:49.143 --> 15:39:51.949
Our hat test, dash dash grep.

9454
15:39:51.949 --> 15:39:56.038
And we're in passing, we are in business.

9455
15:39:56.038 --> 15:39:56.824
Awesome.

9456
15:39:56.824 --> 15:39:59.676
So this is working perfectly.

9457
15:39:59.676 --> 15:40:05.511
Well, and let's also test that it returns false.

9458
15:40:05.511 --> 15:40:07.963
If raffle isn't open.

9459
15:40:07.963 --> 15:40:11.063
This will be an async function.

9460
15:40:11.063 --> 15:40:15.013
And we'll do everything except and we'll do everything in here.

9461
15:40:15.013 --> 15:40:18.828
But we'll make the raffle in the calculating state.

9462
15:40:18.828 --> 15:40:34.251
So do a weight, raffle dot enter, raffle value, raffle entrance fee await network dot provider that send and I'm just going to copy these two lines here.

9463
15:40:34.251 --> 15:40:36.464
Because we're going to go ahead and do those.

9464
15:40:36.563 --> 15:40:42.086
We're also going to do a weight, raffle dot perform upkeep.

9465
15:40:42.563 --> 15:40:52.841
another way to send a blank bytes object is to do a string like 0x hardhat is smart enough to know that this should be transformed into just kind of a blank bytes object.

9466
15:40:52.841 --> 15:40:54.804
So either one of these should work.

9467
15:40:54.804 --> 15:41:02.460
Now we're do const, raffle state equals await, raffle dot get raffle state and we'll Get upkeep needed.

9468
15:41:02.460 --> 15:41:03.770
So we'll say const.

9469
15:41:03.770 --> 15:41:12.055
upkeep needed, we'll do exactly what we did above raffle dot call static dot check upkeep.

9470
15:41:12.055 --> 15:41:16.399
Let's say excuse me a weight, raffle dot call static.

9471
15:41:16.564 --> 15:41:23.979
Now we can do assert dot equal, say raffle state is going to be, or excuse me raffle state.

9472
15:41:23.979 --> 15:41:31.960
to string, it's going to be calculating, and I started dot equal upkeep needed, it's going to be false.

9473
15:41:31.960 --> 15:41:35.134
Let's run a GREP on that.

9474
15:41:35.134 --> 15:41:36.657
And perfect.

9475
15:41:36.657 --> 15:41:39.443
That's also working correctly.

9476
15:41:39.443 --> 15:41:39.753
Great.

9477
15:41:39.753 --> 15:41:44.985
Now I'm going to skip over these next two tests, because we haven't really learned anything from them.

9478
15:41:44.985 --> 15:41:50.318
So I'm just going to copy paste them from the GitHub, we're going to return false if enough time hasn't passed.

9479
15:41:50.318 --> 15:41:52.241
And we're going to return true.

9480
15:41:52.241 --> 15:41:56.150
If enough time has passed, we have players Eve and is open.

9481
15:41:56.150 --> 15:41:58.697
So we're just asserting true down here.

9482
15:41:58.697 --> 15:42:14.286
And we're starting not true up here, you want to pause the video and copy paste these and write these out, you absolutely can copy paste them from the GitHub repo, you absolutely can't like I said, going through this and making yourself write these and making yourself understand these tests is going to make you a substantially better coder.

9483
15:42:14.286 --> 15:42:17.964
And let's just test that it all looks good with hh test.

9484
15:42:17.964 --> 15:42:29.827
Now, as I was recording this, I just realized that for all of our describe blocks, I've been making them async functions describe blocks actually don't realize and can't recognize and can't work with promises.

9485
15:42:29.827 --> 15:42:32.483
So having the be async actually doesn't do anything.

9486
15:42:32.483 --> 15:42:37.717
So in your describe block, we want to get rid of the async word because it's actually not helping us at all.

9487
15:42:37.717 --> 15:42:40.828
In fact, it's just an extra word, and it looks kind of gross.

9488
15:42:40.828 --> 15:42:46.371
So now all of our describe blocks, we're gonna get rid of that async keyword, and just have them be functions.

9489
15:42:46.371 --> 15:42:51.707
Of course, all of our it's, though, are going to be using asynchronous functions, which is what we want.

9490
15:42:51.707 --> 15:42:54.498
So we've written some tests for a checkup keep.

9491
15:42:54.498 --> 15:42:56.565
Now let's go ahead to perform upkeep.

9492
15:42:56.565 --> 15:43:01.965
Let's create a new describe, block, ascribe or perform upkeep.

9493
15:43:01.965 --> 15:43:04.565
This is going to be a regular function.

9494
15:43:04.565 --> 15:43:10.823
And in here, we're going to start and say it can only run if check upkeep is true.

9495
15:43:10.823 --> 15:43:13.081
And this will be an async function.

9496
15:43:13.081 --> 15:43:18.289
Because we only want to perform keep to work if checkup keep is indeed true.

9497
15:43:18.289 --> 15:43:20.734
So we'll say await raffle dot enter.

9498
15:43:20.734 --> 15:43:28.676
raffle we'll send it some value, raffle entrance fee, I'm sorry, there should be curly braces instead.

9499
15:43:28.676 --> 15:43:38.740
And we'll do a weight network dot provider that send EVM increase time inter vol.

9500
15:43:38.740 --> 15:43:57.790
to number plus one await network dot provider that send UVM mine an empty array there to the reason that we're moving time forward and moving our block forward, of course is gonna be the same thing as above, we want our check upkeep to return true.

9501
15:43:57.790 --> 15:44:05.211
And then we're gonna say const X or transaction equals await raffel dot perform upkeep.

9502
15:44:05.211 --> 15:44:11.940
We can either do a blank array, or we could do 0x Doesn't matter.

9503
15:44:11.940 --> 15:44:13.440
And we can assert the X.

9504
15:44:13.440 --> 15:44:18.168
Now if TX doesn't work, or this error is out or something, this will fail.

9505
15:44:18.168 --> 15:44:18.549
Right.

9506
15:44:18.549 --> 15:44:21.232
So that's how we know that this actually can work.

9507
15:44:21.232 --> 15:44:22.327
So let's test this out.

9508
15:44:22.327 --> 15:44:25.973
We want this only to work if checkup keep is true.

9509
15:44:25.973 --> 15:44:30.303
And we made checkup keep true by all the stuff that we did above.

9510
15:44:30.303 --> 15:44:35.923
So now we'll do yarn hardhat test dash dash grep with our IT block here.

9511
15:44:35.923 --> 15:44:40.387
And I spelled perform upkeep wrong perform upkeep.

9512
15:44:40.566 --> 15:44:42.475
Let's try spelling things correctly.

9513
15:44:43.566 --> 15:44:44.221
test again.

9514
15:44:44.221 --> 15:44:44.876
And great.

9515
15:44:44.876 --> 15:44:45.859
That's working.

9516
15:44:47.566 --> 15:44:51.058
want to do? We want it to revert with raffel.

9517
15:44:52.566 --> 15:44:54.441
if checkup keep is false.

9518
15:44:57.566 --> 15:45:00.266
When check up keep is false.

9519
15:45:03.566 --> 15:45:14.125
And we're going to do that same syntax await expect raffle dot perform upkeep empty bytes object that to.

9520
15:45:14.125 --> 15:45:16.294
be reverted with.

9521
15:45:16.566 --> 15:45:27.316
And what do we want it to be reverted with? Or hoping it's reverted with this with that, we can run this test here Hardhead test dash dash grep paste that in.

9522
15:45:27.316 --> 15:45:36.166
And we see that is indeed passing now something that you'll notice here is that our revert actually goes ahead and reverts with all this extra stuff as well.

9523
15:45:36.166 --> 15:45:43.652
Our test is smart enough to know that if all we do is put the name of the error that is getting reverted with then it's good enough.

9524
15:45:43.652 --> 15:45:51.193
If we want to be super specific, we can actually go ahead and make this a string interpolation and add all of these in here.

9525
15:45:51.193 --> 15:45:55.766
So we can add the balance that we expect we can add the players that we expect.

9526
15:45:55.766 --> 15:46:07.397
And we can add the raffle statement for now we're just going to keep it as we're expecting this but if you want to be super specific you can have your tests expect for exactly the specific values that you're looking for.

9527
15:46:07.397 --> 15:46:15.300
But alright, what is the last thing we should expect form? Well, we should check to see that this actually gets called the raffle state gets changed.

9528
15:46:15.300 --> 15:46:16.963
And we admit this event.

9529
15:46:16.963 --> 15:46:19.423
So let's go ahead and add that.

9530
15:46:19.423 --> 15:46:32.154
We'll say it updates the raffle state admits an event and calls the VRF coordinator to be an async function as well.

9531
15:46:32.154 --> 15:46:33.042
Let's do this.

9532
15:46:33.042 --> 15:46:40.698
So let's go ahead and let's make checkup keep true, I'm just going to copy paste these first three lines, since it's going to be exactly the same.

9533
15:46:40.698 --> 15:46:46.124
We're going to enter the raffle we're going to increase the time we're going to mind a new block, then we're going to call perform upkeep.

9534
15:46:46.124 --> 15:47:05.027
So we're going to say const, TX response equals await raffle dot perform upkeep with an empty bytes object, and we're going to do const TX receipt equals await TX response dot wait for one block.

9535
15:47:05.027 --> 15:47:14.400
From this receipt, we're gonna get the request ID, we're gonna say const Request ID equals, we can get the request ID.

9536
15:47:14.400 --> 15:47:16.400
From this omitted event.

9537
15:47:16.400 --> 15:47:31.685
However, we should look at our VRF coordinator mock again, when we call request random words, both in the mock and then in the actual contract, you'll notice that it also emits an event with random words requested.

9538
15:47:31.685 --> 15:47:37.277
And if you look in here, the second parameter that it has is indeed the request ID.

9539
15:47:37.277 --> 15:47:47.968
So in reality, US omitting the request ID is redundant, we can just use the admitted Request ID from the VRF coordinator for the purpose of this course and showing you what an event looks like.

9540
15:47:47.968 --> 15:47:49.223
We're going to leave it in there.

9541
15:47:49.223 --> 15:47:53.968
But if you want to go back and refactor this, you would definitely want to remove this omit.

9542
15:47:53.968 --> 15:47:57.171
But for this test, let's do TX receipt dot events.

9543
15:47:57.171 --> 15:48:06.955
And this is going to be the first event instead of the zero with event because before this event gets emitted, this function is going to emit an event.

9544
15:48:06.955 --> 15:48:11.500
So instead of the zero with event, this is the first event that gets emitted after this one.

9545
15:48:11.500 --> 15:48:20.027
So tax receipts dot events of one dot args dot request, ID, and then we're gonna say cert request id.

9546
15:48:20.027 --> 15:48:22.977
to number is greater than zero.

9547
15:48:22.977 --> 15:48:28.948
And then we'll also assert that the raffle state equals equals one.

9548
15:48:28.948 --> 15:48:36.515
So we're gonna do const, raffle state equals await, raffle dot get raffle state.

9549
15:48:36.515 --> 15:48:39.822
And this should actually be raffle state.

9550
15:48:39.822 --> 15:48:43.805
to Number, or to string and then you know, do whatever we want to do.

9551
15:48:43.805 --> 15:48:48.318
And this is a very big it, but we're going to copy the whole thing anyways.

9552
15:48:48.318 --> 15:48:52.786
HH test, dash dash grep, paste that in there, we run it, excuse me.

9553
15:48:52.786 --> 15:49:03.245
to string equals equals one, transformer time and perfect, we are passing Great, now it's time for fulfill random words.

9554
15:49:03.245 --> 15:49:06.771
And this is where we're going to learn a lot of fantastic stuff here.

9555
15:49:06.771 --> 15:49:11.093
So we're gonna make a new describe block zoomed out a little bit here.

9556
15:49:11.093 --> 15:49:16.039
And this is going to be our fulfill random words.

9557
15:49:16.039 --> 15:49:19.718
It's going to be a function, of course.

9558
15:49:19.718 --> 15:49:27.142
And in here, we're actually going to add another before each want to have somebody have entered the raffle before we run any tests in here.

9559
15:49:27.142 --> 15:49:32.045
So we're going to do a before each, which will be an async.

9560
15:49:32.045 --> 15:49:32.902
function.

9561
15:49:32.902 --> 15:49:43.362
And we're just going to run await, raffle that enter raffle with a value of raffle entrance fee.

9562
15:49:43.362 --> 15:50:04.500
And then we're going to do a wait network dot provider dot send EVM increase time of interval, that to number plus one, and then a wait network dot provider dot send EVM mine.

9563
15:50:04.500 --> 15:50:05.327
Comma.

9564
15:50:05.327 --> 15:50:10.762
Before we've tried to do any testing of or fulfilled random words, we're gonna have somebody enter the lottery.

9565
15:50:10.762 --> 15:50:14.235
And we're going to have increased the time and mined a new block.

9566
15:50:14.235 --> 15:50:14.968
Okay, cool.

9567
15:50:14.968 --> 15:50:27.095
So the first thing we want to do is want to see that fulfill random words can only be called so long as there's a request in flight, so long as there's a requested as long as request random words has been called.

9568
15:50:27.095 --> 15:50:32.189
So we can actually check that by running it can only be called after perform.

9569
15:50:32.189 --> 15:50:35.093
This will be an async function.

9570
15:50:35.093 --> 15:50:40.117
And in here, we're going to revert on some requests that don't exist.

9571
15:50:40.117 --> 15:50:49.388
So we'll do await, expect the RF core didn't a tour be to mock dot fulfill random words.

9572
15:50:49.388 --> 15:51:06.523
And if we look at our V RF, coordinator v2 Mark in here has the fulfill random words function, which is what the chain link node actually calls and inside Add this function in the actual contract calls another contract that does the random number verification.

9573
15:51:06.570 --> 15:51:08.820
So we're basically checking this part right here.

9574
15:51:09.570 --> 15:51:13.796
doesn't exist, we're going to get this non existent request here.

9575
15:51:13.796 --> 15:51:17.570
And as you can see, it needs a request ID and a consumer address.

9576
15:51:17.570 --> 15:51:19.382
So we're going to guess zero.

9577
15:51:19.382 --> 15:51:32.007
And the consumer addresses, of course, it's gonna be raffled out at address, we're going to expect this to be reverted, with non existent request.

9578
15:51:32.007 --> 15:51:38.103
And then we're going to do this exact same thing with a different Request ID or request ID one.

9579
15:51:38.103 --> 15:51:41.659
And hopefully, we're also going to get non existent requests.

9580
15:51:41.659 --> 15:51:46.021
Now ideally, no request here would ever allow this fulfill random words to go through.

9581
15:51:46.021 --> 15:51:57.553
Now, it obviously would be really hard for us to test every single possible Request ID, we're going to see a way in the future to actually test for a ton of these variables with something called fuzz testing.

9582
15:51:57.553 --> 15:51:58.880
But we'll get to that in the future.

9583
15:51:58.880 --> 15:52:07.370
And I spelt the scribe wrong, let's let's actually spelled the scribe correctly, go ahead and run this hh test dash dash grep.

9584
15:52:07.570 --> 15:52:09.438
And great it passed.

9585
15:52:13.570 --> 15:52:15.699
here, that's gonna be way too big.

9586
15:52:17.570 --> 15:52:19.784
we're about to write is going to be it's going to be a really big test.

9587
15:52:19.784 --> 15:52:26.383
And we probably want to split it up into different sections, but actually figured that this was actually the best way to show this section.

9588
15:52:26.383 --> 15:52:28.379
And it's going to be exactly what we're going to do.

9589
15:52:28.379 --> 15:52:33.355
When we get to our staging test, we're going to write this test literally almost exactly the same.

9590
15:52:33.355 --> 15:52:38.951
So let's write it, this is basically going to be the test that puts everything together.

9591
15:52:38.951 --> 15:52:52.248
So we're going to test that this indeed, so winner resets the lottery, and sends money, which is kind of a lot for a single it, we probably would want to split those into their own pieces.

9592
15:52:52.248 --> 15:52:56.122
But for this, we're just going to put them all into one, and it's going to be an async function.

9593
15:52:56.122 --> 15:52:59.764
Now we are going to learn a couple of new tricks here.

9594
15:52:59.764 --> 15:53:01.602
So definitely be sure to follow along.

9595
15:53:01.602 --> 15:53:07.465
Now for this one, we're also going to add in some additional entrances additional people who are entering this lottery.

9596
15:53:07.465 --> 15:53:12.191
So we'll say const, additional, and trance equals great.

9597
15:53:12.191 --> 15:53:17.523
We're gonna have some more of those fake accounts from ethers enter our lottery here.

9598
15:53:17.571 --> 15:53:20.142
So we're gonna say const.

9599
15:53:23.571 --> 15:53:31.333
to, since deployer equals zero, excuse me equals one, since the player is zero, so we're going to have new accounts start from index one.

9600
15:53:31.333 --> 15:53:52.461
And we're going to do a little for loop or let i equals starting count index, i is less than the starting count, index, plus additional and trend sees there's gonna be entrance.

9601
15:53:52.571 --> 15:53:58.452
i plus plus, we're gonna do a little loop and connect our raffle contract to these new accounts.

9602
15:53:58.452 --> 15:54:04.771
And then we're going to have these new accounts, enter our raffle contest.

9603
15:54:04.771 --> 15:54:15.834
Count, connected raffle equals raffle dot connect accounts of i and do we have accounts defined somewhere we don't.

9604
15:54:15.834 --> 15:54:18.334
So let's get accounts to find somewhere.

9605
15:54:18.334 --> 15:54:22.503
We'll say const accounts equals await ethers dot get signers.

9606
15:54:22.503 --> 15:54:29.201
And then we're going to do a weight account connected raffle dot enter.

9607
15:54:29.201 --> 15:54:37.965
raffle with a value of course of raffle entrance fee, we're going to connect three additional entrance to our raffle.

9608
15:54:37.965 --> 15:54:42.105
So we're going to have a total of four people connect into this raffle.

9609
15:54:42.105 --> 15:54:46.238
Now that we have them in here, we're going to keep note of our starting timestamp.

9610
15:54:46.238 --> 15:54:54.877
So we're gonna do const starting timestamp equals await, raffle dot get last timestamp.

9611
15:54:54.877 --> 15:54:56.959
And here's where we're going to get a little bit tricky.

9612
15:54:56.959 --> 15:55:11.944
What we want to do is a couple of things we want to we want to perform upkeep, which is going to mock being chainlink keepers, which will kick off the chain link, which will kick off calling fulfill random words.

9613
15:55:11.944 --> 15:55:15.555
And we're going to mock doing that as well.

9614
15:55:15.555 --> 15:55:18.014
Mock being the chain link VRF.

9615
15:55:18.014 --> 15:55:28.222
Once we do that, we can of course just check to see okay, did the recent winner get recorded the raffle get reset just play as we said as the timestamp is everything reset.

9616
15:55:28.222 --> 15:55:30.460
But we want to do this in a specific way.

9617
15:55:30.460 --> 15:55:38.887
If we're doing this on a test net after we call fulfill random words, we will have to wait for the fulfill random words to be called.

9618
15:55:38.887 --> 15:55:48.782
Now since we're working with a hardhat local chain, we don't really need to wait for anything, right because we can just say okay, boom, snap our fingers and adjust our blockchain to do whatever we want.

9619
15:55:48.782 --> 15:55:53.402
But we're going to simulate that we do need to wait for that event to be called.

9620
15:55:53.402 --> 15:55:59.510
So in order for us to simulate waiting for that event, we once again need to set up a listener.

9621
15:55:59.573 --> 15:56:08.233
Now if we set up a listener we don't want this to Just to finish before the listener has is done listening, so we need to once again create a new promise.

9622
15:56:08.233 --> 15:56:12.948
And this is going to be incredibly important, especially for our staging tests.

9623
15:56:12.948 --> 15:56:15.477
So we're going to do await, new promise.

9624
15:56:15.477 --> 15:56:25.081
And this is going to be exactly the same as we set it up before, it's going to be an async function that's going to take resolve and reject as parameters.

9625
15:56:25.081 --> 15:56:39.228
And we're going to use this little arrow syntax here saying, this is an async function, basically, and we're going to set up once again, that once syntax, we're gonna say raffle that once, what's the event name, winner picked.

9626
15:56:39.228 --> 15:56:46.508
So we're gonna say, Listen, for this winner picked event, we're gonna say raffle dot once winner picks happens, do some stuff.

9627
15:56:46.573 --> 15:56:49.027
And again, this is just an anonymous function.

9628
15:56:49.573 --> 15:56:53.376
gonna say raffle dot once the winner picked event gets emitted, do some stuff.

9629
15:56:53.376 --> 15:56:55.425
So we're setting this up.

9630
15:56:55.425 --> 15:57:01.523
Now it's in this function, we're going to add all of our certs and everything because we want to wait for winter to get picked.

9631
15:57:01.573 --> 15:57:08.001
Now before the event gets fired, though, we of course, need to actually call perform and call fulfill random words.

9632
15:57:08.001 --> 15:57:10.952
So this is going to seem like it's a little bit backwards.

9633
15:57:10.952 --> 15:57:21.003
But that's because we want to set up our listeners so that when we do fire, the methods that will fire the event, our listener is activated and is waiting for it.

9634
15:57:21.003 --> 15:57:24.861
So we're going to put all of our code inside of this promise.

9635
15:57:24.861 --> 15:57:32.823
Now, because we put it outside of the promise, we put all the code outside of the promise, this promise will never get resolved, because the listener will never fire into vent.

9636
15:57:32.823 --> 15:57:38.349
So if down here, you know we call fulfill random words with something, you know which the spelling is bad.

9637
15:57:38.349 --> 15:57:48.081
But let's say we call the down here, this piece of code will never reach this fulfill random words, because it's always going to be waiting for this wants to get resolved.

9638
15:57:48.081 --> 15:57:51.446
So we need to add all of our code inside the promise.

9639
15:57:51.574 --> 15:57:57.669
But outside this raffle dot once now we don't want to wait forever, right? Maybe there is an issue here.

9640
15:57:57.669 --> 15:58:01.113
And we want to be able to reject this, if there's an issue.

9641
15:58:01.113 --> 15:58:05.636
Now what we can do is in our heart hat dot config, we can add a timeout.

9642
15:58:05.636 --> 15:58:24.328
So we can add this mocha section, we can give ourselves a timeout of 200,000 milliseconds, which is going to be 200 seconds max, if this event doesn't get fired in 200 seconds, this will be considered a failure and this test will fail, which is what we want.

9643
15:58:24.328 --> 15:58:31.639
And I typically like to just wrap this in a try catch because if something fails, it'll cause you a whole bunch of headache catch E.

9644
15:58:31.639 --> 15:58:39.360
And if anything fails, we'll also reject, there's an issue with us calling some function, we'll just say, Hey, okay, that's a failure.

9645
15:58:39.360 --> 15:58:44.416
But you fail, that way, our promise can get resolved in a timely manner, we're going to add this code in a little bit.

9646
15:58:44.416 --> 15:58:45.889
But let's keep going.

9647
15:58:45.889 --> 15:58:47.081
Let's keep going.

9648
15:58:47.081 --> 15:58:53.875
And excuse me, the trycatch should be in the ones, the ones above the results, excuse me, because this is the listener.

9649
15:58:53.875 --> 15:58:59.518
So sorry, we want the trycatch to be inside the ones if this takes too long, we want to just go ahead and throw an error.

9650
15:58:59.574 --> 15:59:21.469
Otherwise, we're going to resolve now outside the listener, but inside of the promise, we're going to do this bit here, where we go const TX equals await raffle dot perform upkeep, and we'll pass it the empty bytes object, we'll get const TX receipt equals await TX dot weight of one block.

9651
15:59:21.575 --> 15:59:40.717
And then we're going to do a weight VRF core didn't a tour be to mock dot fulfill random words, CX receipt dot events of one dot args dot Request ID come a raffle that address.

9652
15:59:40.717 --> 15:59:51.325
So then the final thing that we're going to do is we're going to get this veer off coordinator be to mock we're going to have it call fulfill random words, which takes the request ID and the consumer address.

9653
15:59:51.325 --> 15:59:57.763
So we're going to mock it, give it the request ID which we get from the transaction receipt, and the consumer address here.

9654
15:59:57.763 --> 16:00:02.075
All inside this promise, we're setting up a listener for this winner picked event.

9655
16:00:02.075 --> 16:00:06.747
And then we're mocking the channeling keepers and then we're mocking the chainlink VRF.

9656
16:00:06.747 --> 16:00:13.195
And once this function gets called this function should emit a winner picked event.

9657
16:00:13.195 --> 16:00:23.800
So this raffle that was set up that was listening for this to get emitted will pick up and go Ah okay, I found it I found the winner picked event.

9658
16:00:23.800 --> 16:00:26.251
Now we can go ahead and do some stuff.

9659
16:00:26.251 --> 16:00:40.575
So once the winner picked event gets fired, we'll do a little console dot log found the event like this and we'll jump into our try catch and this trycatch is going to be basically us doing all these asserts in here.

9660
16:00:40.575 --> 16:00:58.196
So first we want to say const recent winner equals await raffle dot get recent winner and we're going to be checking just everything in this raffle right we're gonna be checking that the recent winners right that that the raffle state's been reset the players have reversed, you know, players has been reset, etc, etc.

9661
16:00:58.196 --> 16:01:08.242
So we'll say const raffle state equals awaits raffle dot get raffle state we'll say const.

9662
16:01:08.242 --> 16:01:14.440
Ending timestamp equals await, raffle dot get last timestamp.

9663
16:01:14.440 --> 16:01:17.406
And let's start doing some asserts.

9664
16:01:17.576 --> 16:01:22.401
So first we should assert that this es players array has been reset to zero.

9665
16:01:22.401 --> 16:01:26.042
So if we call get number of players it should be zero.

9666
16:01:26.042 --> 16:01:36.379
So we can do const num players equals await raffle dot get number of players like so.

9667
16:01:36.379 --> 16:01:41.576
And we can do assert dot equal nine players.

9668
16:01:41.576 --> 16:01:43.992
to string is going to be zero.

9669
16:01:43.992 --> 16:01:54.641
What else can we assert? Well, we can assert dot equal raffle state should be back to being open.

9670
16:01:54.641 --> 16:01:56.477
So raffle state.

9671
16:01:56.477 --> 16:02:06.350
to string should be zero, we should assert that the ending timestamp is now greater than the starting timestamp.

9672
16:02:06.350 --> 16:02:10.176
Because the last timestamp should have been updated.

9673
16:02:10.176 --> 16:02:13.050
We also want to make sure our recent winner is correct.

9674
16:02:13.050 --> 16:02:15.965
But we'll do console dot log recent winner.

9675
16:02:15.965 --> 16:02:18.769
Now we can go to the VRF coordinator mock.

9676
16:02:18.769 --> 16:02:23.805
And we could simulate this and try to figure out who the random winner is to console dot log accounts to.

9677
16:02:23.805 --> 16:02:37.524
And then just to show a bunch of them, we'll do 01 and three a raffle dot once this needs to be an async function, not just a regular function.

9678
16:02:37.524 --> 16:02:42.305
Let's try that one more time, get latest timestamp is the correct function.

9679
16:02:42.305 --> 16:02:44.661
So let's update this with the correct latest.

9680
16:02:44.661 --> 16:02:46.119
Let's put latest in there.

9681
16:02:46.119 --> 16:02:48.763
Because I'm spelling something's wrong.

9682
16:02:48.763 --> 16:02:53.842
I sure am looks like we're printing out recent winner here when we haven't even initialized it.

9683
16:02:53.842 --> 16:02:54.779
So let's move it up.

9684
16:02:54.779 --> 16:02:57.992
And then we'll do console dot log recent winner.

9685
16:02:57.992 --> 16:03:00.860
So I know this is a massive test here.

9686
16:03:00.860 --> 16:03:05.243
But let's give it a try and see if everything kind of does what we think it should do.

9687
16:03:05.243 --> 16:03:08.993
And it's slowing down here, which is good because we're doing a lot of stuff.

9688
16:03:08.993 --> 16:03:13.764
And uh huh, we finally get this passing thing to come out.

9689
16:03:13.764 --> 16:03:19.441
And we did a ton of console dot logging so so there's a lot of stuff in here of the signers are getting printed out.

9690
16:03:19.441 --> 16:03:21.814
So let's just make this a little easier to read.

9691
16:03:21.814 --> 16:03:26.545
We'll add dot address to all these, we can see who the winner is.

9692
16:03:26.545 --> 16:03:30.827
So it looks like the winner is going to be account number one, which is great.

9693
16:03:30.827 --> 16:03:40.249
So what we can do now that we know account number one is going to be the winner, we can get that winners starting balance way down here before we call fulfill random words.

9694
16:03:40.249 --> 16:03:52.139
So we'll say const winner, starting balance equals await accounts one dot get balance, yes, you can just call get balance right like that.

9695
16:03:52.139 --> 16:04:04.529
And now that we have the winner starting balance back in our tests, we can say const winner, ending balance equals await ounce one dot get balance.

9696
16:04:04.529 --> 16:04:09.512
And we can make sure that this winner got paid what they need.

9697
16:04:09.512 --> 16:04:15.105
So now we're going to do a big assert with some money stuff, just trust me, this is what the math is.

9698
16:04:15.105 --> 16:04:19.744
So we're going to do assert dot equal winner balance.

9699
16:04:19.744 --> 16:04:24.448
to string, excuse me winter ending balance.

9700
16:04:24.448 --> 16:04:43.501
to string should equal the winner starting balance dot add the raffle entrance fee that multiplied by the additional and trance that add the raffle entrance fee that we paid.

9701
16:04:43.501 --> 16:04:44.193
to string.

9702
16:04:44.193 --> 16:04:53.328
So this math is basically saying the winner should end with a balance of all of the money that everybody else added to this contract.

9703
16:04:53.328 --> 16:04:54.188
And that's it.

9704
16:04:54.188 --> 16:04:56.764
So we can run this test one more time.

9705
16:04:56.764 --> 16:04:58.509
And Gosh, darn it, it passed.

9706
16:04:58.509 --> 16:05:00.474
Okay, so there was a lot of code here.

9707
16:05:00.578 --> 16:05:06.028
And this might have been one of the hardest pieces of this entire course is going to be this part right here.

9708
16:05:06.028 --> 16:05:08.778
So if you struggled a little bit with this, don't let that bog you down.

9709
16:05:08.778 --> 16:05:16.110
This is probably one of the more difficult sections of this course, let's do a quick refresher of just this test that we're doing.

9710
16:05:16.110 --> 16:05:18.335
And then we'll see in an action when we do it.

9711
16:05:18.335 --> 16:05:19.316
In our staging test.

9712
16:05:19.316 --> 16:05:22.806
What we did is we're picking a winner resetting the lottery and we're sending money.

9713
16:05:22.806 --> 16:05:29.734
Basically what we're doing is we're testing that this fulfill random words thing does what we want it to do a random winner wins and they get the money.

9714
16:05:29.734 --> 16:05:34.178
So how do we actually do that? Well, we first started off by having a bunch of random people enter the lottery.

9715
16:05:34.178 --> 16:05:34.478
Great.

9716
16:05:34.578 --> 16:05:35.349
Sounds good.

9717
16:05:38.578 --> 16:05:44.205
perform upkeep and fulfill random words, we want to pretend that the random number was drawn.

9718
16:05:44.205 --> 16:05:52.807
And that's what this code down here does is it calls that random number but and what we could have done was we could have had all these assert and checked all the variables.

9719
16:05:52.807 --> 16:05:54.036
After we did this, right.

9720
16:05:54.036 --> 16:05:56.020
We could have totally done that.

9721
16:05:56.020 --> 16:06:01.527
However, on a test net where we don't always know exactly when a transaction is going to finish.

9722
16:06:01.579 --> 16:06:11.712
We have to wait If we have to listen for an event to be fired, before, we could call the transactions that would end this whole thing, we needed to set something up to listen for that event to be fired.

9723
16:06:11.712 --> 16:06:25.340
And we said, hey, only once this event is fired only once this transaction is called, can we do our testing now for our local network, we are mocking the VRF coordinators, we have control, we know exactly when this is going to run.

9724
16:06:25.340 --> 16:06:27.117
But on a test net, we don't.

9725
16:06:27.117 --> 16:06:30.688
So you'll see in our staging tests, we won't have any of this here.

9726
16:06:30.688 --> 16:06:39.507
And we'll have to rely on setting up a listener to listen for the channeling VRF and the keepers to fire their events.

9727
16:06:39.507 --> 16:06:44.579
And that's why the staging test is going to be so important to make sure that we're doing everything correct.

9728
16:06:44.579 --> 16:06:52.429
And that's why we set up our local tests like this, so that it mimics what we're going to be doing on our statement test what we're going to be doing on a real network here.

9729
16:06:52.429 --> 16:07:03.511
And again, we're setting up this listener and we're saying, Ah, once we do here, this event, then we're going to try to actually check all of the balances and check that everything is working as intended.

9730
16:07:03.511 --> 16:07:05.872
And if we don't see it, we're going to reject.

9731
16:07:05.872 --> 16:07:11.382
And if there's a timeout, if it takes more than 200 seconds, we're going to say okay, something went wrong, we're going to cancel it.

9732
16:07:11.382 --> 16:07:16.398
And actually, I'm going to bump this up to 300 seconds, because I think 200 seconds is not going to be enough.

9733
16:07:16.398 --> 16:07:21.445
And depending on how quick the rink B test that is, you might have to bump this up even bigger.

9734
16:07:21.445 --> 16:07:24.911
So just keep that in mind.

9735
16:07:24.911 --> 16:07:29.293
But who, okay, we have just built some fantastic tests.

9736
16:07:29.293 --> 16:07:36.483
Let's go ahead, and let's just run h h test to see if all of our tests are going to pass.

9737
16:07:36.579 --> 16:07:41.380
And well, 14 passing, everything is passing here we are looking good.

9738
16:07:41.580 --> 16:07:42.929
This is fantastic.

9739
16:07:46.580 --> 16:07:49.338
let's go ahead and create a staging test.

9740
16:07:50.580 --> 16:07:54.644
is going to look really similar to that massive test that we just created down here.

9741
16:07:54.644 --> 16:08:05.808
And the reason we set up our unit test to do this a weight promise thing with the raffle dot once was because this is actually how we're going to need to wait on a test net or main net for a winner to be picked.

9742
16:08:05.808 --> 16:08:11.225
We cannot on an actual test net, pretend to be the chain link V REF, we can pretend to be the chain link keepers if we want.

9743
16:08:11.225 --> 16:08:14.924
But we're not going to make sure that the 10 the keepers is actually working.

9744
16:08:14.924 --> 16:08:24.313
But we are going to be doing this because we want to listen for that event to be fired, we want to listen for the chain link VRF to respond with the winner.

9745
16:08:24.313 --> 16:08:26.354
So let's create a staging test.

9746
16:08:26.354 --> 16:08:30.849
And this is a test that we're going to run on an actual test net here.

9747
16:08:30.849 --> 16:08:40.301
Okay, so we're going to create a new test called raffle dot staging dot test dot Jas and this is where we're going to put our staging test.

9748
16:08:40.301 --> 16:08:46.630
Now we can actually code this pretty quickly because most of our staging tests is gonna look real similar to our raffle test here.

9749
16:08:46.630 --> 16:08:51.783
So for now, let's just grab this whole first part, and then we'll adjust it as we need.

9750
16:08:51.783 --> 16:08:53.206
And then we'll close it off.

9751
16:08:53.206 --> 16:09:00.235
Because we're definitely gonna need a raffle, we're not going to need a VRF coordinator mock because again, we're not going to be using a mock.

9752
16:09:00.235 --> 16:09:06.037
Since we're on an actual test net, we will need the raffle entrance fee, we will need Deployer, we will need a Deployer.

9753
16:09:06.037 --> 16:09:07.416
And we might need the interval.

9754
16:09:07.416 --> 16:09:10.264
But let's delete it for now we probably won't need the chain ID.

9755
16:09:10.264 --> 16:09:11.776
So let's delete that as well.

9756
16:09:11.776 --> 16:09:12.169
Awesome.

9757
16:09:12.169 --> 16:09:18.665
Something that we want to keep in mind is that when it comes to our staging tests, we only want our steam test to run when we're on a test.

9758
16:09:18.665 --> 16:09:27.023
Net, we don't need to run our unit tests because our unit tests aren't checking that compatibility with a test net, we want our unit tests to only run on a local network.

9759
16:09:27.023 --> 16:09:30.597
And we want our staging tests to only run on a test network.

9760
16:09:30.597 --> 16:09:35.331
This is where again, in our test, we're going to check to make sure what type of chain we're on.

9761
16:09:35.331 --> 16:09:38.781
And oops, it looks like I already imported the development changes here.

9762
16:09:38.781 --> 16:09:44.530
So we're actually in our staging tests, we're going to check before we run any test what kind of network we're on.

9763
16:09:44.581 --> 16:10:01.886
So we're gonna say, if our development chains that includes network dot name, we're gonna say if our development chains includes network to name, so if the chain we're on is in the development chains, and again, we're going to use this ternary operator where we say, if we're on a development chain, do something.

9764
16:10:01.886 --> 16:10:04.269
And then if we're not on a development chain, do something else.

9765
16:10:04.269 --> 16:10:12.269
If we are on a development chain, what are we going to do? Well want to skip this and we can actually skip this by putting in this describe dot skip.

9766
16:10:12.269 --> 16:10:14.750
And this will skip this whole section here.

9767
16:10:14.750 --> 16:10:19.744
And then we can say, if we are the development chain, go ahead and do our thing.

9768
16:10:19.744 --> 16:10:25.181
So this is some really nice syntax that allows us to skip our staging tests if we're on a local network.

9769
16:10:25.181 --> 16:10:34.981
And additionally, we can grab this syntax, go into our raffle dot test dot j s where we have our unit tests and add the bang operator, which is the knot and hit Save.

9770
16:10:34.981 --> 16:10:41.831
And now we're saying if we're not on a development chain, skip it and only run this if we aren't in development chain.

9771
16:10:41.831 --> 16:10:44.481
So this says run this only on a test net or main net.

9772
16:10:44.581 --> 16:10:46.924
And then this has run this only on a local network.

9773
16:10:46.924 --> 16:10:47.205
Great.

9774
16:10:47.581 --> 16:10:49.665
have a deployer which we're going to need.

9775
16:10:50.581 --> 16:10:57.387
to need to deploy any fixtures because we're going to run our deploy script and our contracts should already be deployed.

9776
16:10:57.387 --> 16:11:04.361
We will need a raffle we won't need a VRF coordinator mocks we can delete that We will need the entrance fee, and we probably won't need the interval.

9777
16:11:04.361 --> 16:11:05.734
So we can go ahead and delete that too.

9778
16:11:05.734 --> 16:11:06.598
Alright, awesome.

9779
16:11:06.598 --> 16:11:10.349
So we have our describe, we have our before each, let's make our tests.

9780
16:11:10.349 --> 16:11:15.259
And I'm just going to make one giant test to test kind of everything end to end.

9781
16:11:15.259 --> 16:11:23.828
And you can add more tests later on yourself, if you want to our staging test is going to be really similar to this massive test that we made down here.

9782
16:11:23.828 --> 16:11:26.891
And in fact, we're going to use most of this code here as our boilerplate.

9783
16:11:26.891 --> 16:11:28.133
So let's create a describe.

9784
16:11:28.133 --> 16:11:34.132
And we'll say, and we'll actually just copy this describe the four random words and paste it in here.

9785
16:11:34.132 --> 16:11:38.323
Because again, we're going to be using a lot of the same code in our staging tests here.

9786
16:11:38.323 --> 16:11:38.903
Great.

9787
16:11:38.903 --> 16:11:50.300
So now we'll say it works with live chain link keepers and chain link VRF, we get a random winner, acing function.

9788
16:11:50.300 --> 16:11:53.425
So this is going to be our test in here.

9789
16:11:53.582 --> 16:11:57.264
So in this test, we of course, we want to enter the raffle.

9790
16:11:57.582 --> 16:12:01.788
we shouldn't have to do anything else except for enter this raffle.

9791
16:12:01.788 --> 16:12:11.970
Because the chain the keepers and the only VRF are going to be the ones to actually kick off this lottery for us, we'll do a quick grabbing of the starting timestamp to have it before all this kicks off.

9792
16:12:11.970 --> 16:12:37.277
So we'll say const starting timestamp equals await raffle dot get last to me get latest timestamp, get latest timestamp, we're gonna grab this because later on, we're going to test to see if the timestamp has indeed moved forward, we want to enter the lottery, right, we want to run the command we've been running over here all the time, we want to do you know await raffle dot enter raffle, but we don't want to call it yet.

9793
16:12:37.277 --> 16:12:42.430
Because same as what we did over here, we want to set up our listener first.

9794
16:12:42.430 --> 16:12:46.963
Now in here, we probably should have set up our listener before we entered the raffle.

9795
16:12:46.963 --> 16:12:49.375
However, we controlled the blockchain.

9796
16:12:49.375 --> 16:12:52.260
So putting it in that order was is was okay.

9797
16:12:52.260 --> 16:12:59.123
But we want to set up the listener before we enter the raffle just in case the blockchain moves really fast.

9798
16:12:59.123 --> 16:13:03.549
And we're going to set up the listener the exact same way, we did it over here.

9799
16:13:03.549 --> 16:13:05.933
So we're gonna say await new promise.

9800
16:13:05.933 --> 16:13:09.599
And it's going to be an async function that takes a resolve and a reject.

9801
16:13:09.599 --> 16:13:12.318
And we're going to use a little arrow notation here.

9802
16:13:12.318 --> 16:13:24.310
And in here, we're going to set up the listener, we're gonna say raffle dot once, once that winner is picked, we're going to do another async function using that Arrow.

9803
16:13:24.583 --> 16:13:31.812
Arrow function syntax, we'll say console dot log winner picked the event fired.

9804
16:13:31.812 --> 16:13:43.916
And only once we get this winner picked, can we start doing our asserts in here, can we start making sure that there's a winner, there's a verifiably random winner, it's been picked, the money has been moved, etc.

9805
16:13:43.916 --> 16:13:45.852
This is where we'll do our try catch.

9806
16:13:45.852 --> 16:13:52.333
And if there's any error, we're just going to automatically reject, we're going to reject the promise.

9807
16:13:52.333 --> 16:13:56.828
And if all goes well, of course, we're going to resolve the promise.

9808
16:13:56.828 --> 16:13:58.126
So our listener has been set up here.

9809
16:13:58.126 --> 16:13:59.683
We haven't added our asserts here.

9810
16:13:59.683 --> 16:14:02.883
But we will, let's just go ahead and write the rest of the test.

9811
16:14:02.883 --> 16:14:08.244
And then we'll go back and we'll update this listener so so our listener has been added.

9812
16:14:08.244 --> 16:14:10.550
And inside here is actually where we're going to enter the raffle.

9813
16:14:10.583 --> 16:14:20.169
So inside here, await, raffle dot enter raffle value is going to be raffle entrance fee.

9814
16:14:20.169 --> 16:14:22.341
And really that's it.

9815
16:14:22.341 --> 16:14:28.838
Right? So we're setting up the listener, setting up the listener, then entering the raffle.

9816
16:14:28.838 --> 16:14:38.026
And this code won't complete until our listener has finished listening because again, this whole SEC is in a wait.

9817
16:14:38.026 --> 16:14:41.734
So we're gonna say okay, cool setup, the listener, wait for this to finish.

9818
16:14:41.734 --> 16:14:49.770
And then when it gets here, it goes out okay, this is the end of the code Are we all done executing Oh, no resolve or reject hasn't been called yet.

9819
16:14:49.770 --> 16:14:53.155
And that's because we're still waiting for the listener to finish listening.

9820
16:14:53.155 --> 16:15:08.890
Now, once we get this winner picked event emitted in here, we're going to get that recent winner so we'll say const recent winner equals await raffle dot get recent winner will get the raffle state we'll say const.

9821
16:15:08.890 --> 16:15:15.459
raffle state equals await raffle dot get raffle state, we'll get the winners balance.

9822
16:15:15.459 --> 16:15:17.834
So we'll say const.

9823
16:15:17.834 --> 16:15:22.422
Winner balance equals await recent winner.

9824
16:15:22.422 --> 16:15:31.092
And since we're only entering with our Deployer we should check to see the deployers balance at the end and we can't do it right with this deployer object here.

9825
16:15:31.092 --> 16:15:44.773
So we'll have to do the player account equals await ethers dot get signers, no wrap this actually actually will just say this is accounts here like that.

9826
16:15:44.773 --> 16:15:49.390
And then we'll just do a count of zero because it counts as zero is going to be our Deployer.

9827
16:15:49.390 --> 16:15:53.122
So our winner balance is going to be accounts a zero dot get balance.

9828
16:15:53.122 --> 16:16:06.158
And then we're going to do const ending timestamp equals a weight raffle dot get latest To timestamp, and we should also get the starting balance.

9829
16:16:06.158 --> 16:16:12.335
So we'll say winner ending balance, we should also get the starting balance right after we enter.

9830
16:16:12.335 --> 16:16:14.251
So we'll say const.

9831
16:16:14.251 --> 16:16:19.274
Winner, starting balance equals await accounts.

9832
16:16:19.274 --> 16:16:24.108
Zero dot get balance, so that now we can do some comparisons.

9833
16:16:24.108 --> 16:16:24.917
All right, great.

9834
16:16:24.917 --> 16:16:26.297
Let's do the comparisons now.

9835
16:16:26.297 --> 16:16:29.635
So we should first expect the raffle to be reset.

9836
16:16:29.635 --> 16:16:32.172
So we can do this a few different ways.

9837
16:16:32.172 --> 16:16:32.806
Down here.

9838
16:16:32.806 --> 16:16:34.393
We did number of players.

9839
16:16:34.585 --> 16:16:42.423
We can also say, await, expect raffle dot get player 0.

9840
16:16:43.585 --> 16:16:50.447
dot reverted, right because Get Player zero should get reverted because there's not even going to be an object at zero.

9841
16:16:50.447 --> 16:16:54.369
So that's another way we can check to see if our players array has been reset.

9842
16:16:54.369 --> 16:16:58.335
Next, we can do assert dot equal recent winner.

9843
16:16:58.335 --> 16:17:05.140
to string, this should equal our account zero dot address.

9844
16:17:05.140 --> 16:17:11.928
Okay, our Deployer What else can we do? We will assert dot equal raffle state to zero.

9845
16:17:11.928 --> 16:17:15.635
We want this email to go back to open after we're done.

9846
16:17:15.635 --> 16:17:19.221
And then we finally want to make sure that the money has been transferred correctly.

9847
16:17:19.221 --> 16:17:25.031
So we'll do assert dot equal, this should be a winner ending balance.

9848
16:17:25.031 --> 16:17:35.851
That to string should be equal to winner starting balance, add raffle entrance fee.

9849
16:17:35.851 --> 16:17:36.451
to string.

9850
16:17:36.451 --> 16:17:43.103
So if we look down here, they enter the raffle we check their starting balance right after they enter.

9851
16:17:43.103 --> 16:17:49.552
And they basically should just get that raffle entrance fee back right because they are the only ones who have entered this raffle.

9852
16:17:49.552 --> 16:17:57.176
And then we can do one more assert, do assert that the ending timestamp is greater than the starting timestamp.

9853
16:17:57.176 --> 16:17:59.667
And then we'll of course, say resolve.

9854
16:17:59.667 --> 16:18:02.141
So this all goes well, we resolve.

9855
16:18:02.141 --> 16:18:09.222
If there's an issue with any of these asserts, we're going to catch those errors and we're going to reject and this is going to be false.

9856
16:18:09.222 --> 16:18:14.938
And this whole test is gonna go ah, there was an issue, we now have a staging test that looks really good here.

9857
16:18:14.938 --> 16:18:16.489
Let's try this out.

9858
16:18:16.489 --> 16:18:22.359
Let's try our staging test out from start to finish.

9859
16:18:23.586 --> 16:18:37.392
So now in order for us to test this staging test, from end to end, you first going to need to get our sub ID for the channeling fear F then we're going to need to deploy our contract using the sub ID, we're going to need to register the contract with chain link VRF.

9860
16:18:37.392 --> 16:18:41.946
And it's somebody we're going to then need to register it with chain link keepers.

9861
16:18:41.946 --> 16:18:44.749
And then of course, we're going to run the staging tests.

9862
16:18:44.749 --> 16:18:45.486
So let's do it.

9863
16:18:45.586 --> 16:18:49.672
So first thing we're going to need to do is what? Get our sub ID for chain link VRF.

9864
16:18:49.672 --> 16:18:50.292
Okay, great.

9865
16:18:50.292 --> 16:18:53.137
So we're going to come over to VRF dot chain dot link.

9866
16:18:53.137 --> 16:18:56.173
And we're going to need to create a new subscription.

9867
16:18:56.173 --> 16:18:58.458
If we don't have enough rink B eath.

9868
16:18:58.586 --> 16:19:04.586
Let's we want to head over to the full blockchain solidity course, here, we're going to scroll down.

9869
16:19:04.586 --> 16:19:08.344
And we're going to look for the recommended test and here, which is ranked v.

9870
16:19:08.344 --> 16:19:15.881
And we're going to use the faucets link to get some Rigby link, run Fosses dot chain dot link, let's switch over from COVID to a cerium.

9871
16:19:15.881 --> 16:19:18.914
Rigby, we know we're going to need some link and some eath.

9872
16:19:18.914 --> 16:19:21.864
So let's just go ahead and get both.

9873
16:19:21.864 --> 16:19:27.570
Alright, great now that our transaction has gone through, let's just double check our wallet here.

9874
16:19:27.570 --> 16:19:30.780
And it looks like we do indeed have Ethereum here.

9875
16:19:30.780 --> 16:19:36.483
And if you don't see the link, you can head over to link token contracts, Link token contracts in the chain link documentation.

9876
16:19:36.483 --> 16:19:43.264
We'll scroll down to Rigby, we'll grab this contract address import tokens and we'll paste it in here.

9877
16:19:43.264 --> 16:19:45.845
Add Custom tokens, import tokens.

9878
16:19:45.845 --> 16:19:46.328
Great.

9879
16:19:46.328 --> 16:19:49.654
Now I can see my eath and my link here, perfect.

9880
16:19:49.654 --> 16:19:53.398
We have some eath we have some link, let's head over to V REF subscription management.

9881
16:19:53.398 --> 16:19:55.692
And we're going to create a new subscription.

9882
16:19:55.692 --> 16:20:06.515
Again, we could totally do this programmatically, because the user interface here is only helping us facilitate call contracts to the registration contract that's completely decentralized and on chain.

9883
16:20:06.515 --> 16:20:19.062
So let's go ahead and create subscription will create subscription will confirm the transaction and Metamask on the Rinkeby network will do a little bit of wading in great once it's gone through, you can go ahead and click the add funds button.

9884
16:20:19.062 --> 16:20:23.393
I'm going to show you what it looks like if you accidentally refresh and jump off though.

9885
16:20:23.393 --> 16:20:28.744
So if you refresh and you go back to veer off the chain dot link, you should have a new active subscription.

9886
16:20:28.744 --> 16:20:30.602
And you'll see this number here.

9887
16:20:30.602 --> 16:20:34.242
If you click on it, this is your subscription ID great.

9888
16:20:34.242 --> 16:20:40.341
So we can actually take this, come back to our code into our helper Hardhead config.

9889
16:20:40.341 --> 16:20:46.373
And we can paste our subscription ID under subscription ID for our Rinkeby network here.

9890
16:20:46.373 --> 16:20:46.897
Awesome.

9891
16:20:46.897 --> 16:20:51.387
Now that we have a subscription we can see it's not funded with any link.

9892
16:20:51.387 --> 16:20:53.349
So we don't have any Oracle gas here.

9893
16:20:53.349 --> 16:20:54.976
And we don't have any consumers.

9894
16:20:54.976 --> 16:20:58.962
Right our consumer is going to be a raffle or a lottery contract.

9895
16:20:58.962 --> 16:21:04.702
So let's add some funds first and we don't need to add A whole lot because we're only going to be testing once.

9896
16:21:04.702 --> 16:21:11.757
So let's go just go ahead and add to link here, this number might change depending on different costs of the test nets and how much link token there's available.

9897
16:21:11.757 --> 16:21:23.719
So if you're actually working on a main net, be sure to head over Doc's touching that link EVM chains contract addresses, you can read more about the costs some of these different chains, so you can figure out exactly how much to put in here.

9898
16:21:23.719 --> 16:21:34.254
And if you go to the full blockchain solidity course, Jas, we can scroll down to Lesson Nine, there's a recommended link amounts or rinky saving tests for chain link VRF.

9899
16:21:34.254 --> 16:21:39.398
For now we're going to put two for keepers, we're going to put eight, but feel free to refer to here so you know how much to put in.

9900
16:21:39.398 --> 16:21:44.054
So let's go ahead and confirm, we're going to approve adding funds here, go ahead and confirm.

9901
16:21:44.054 --> 16:21:49.765
And we're now funding our subscription to so we can pay that Oracle gas to get our random numbers.

9902
16:21:49.765 --> 16:21:50.055
Great.

9903
16:21:50.055 --> 16:21:53.342
And once we're funded, we can close it, we'll do a little refresh.

9904
16:21:53.342 --> 16:21:57.981
And we can see the balance is now to link when we don't have any consumers perfect.

9905
16:21:57.981 --> 16:22:01.095
So we've got our sub ID, we funded it.

9906
16:22:01.095 --> 16:22:04.164
Now let's go ahead and deploy our contract.

9907
16:22:04.164 --> 16:22:16.525
And we already know that we should be all good for deploying our contract, we go to our Dotty and V will need to add all of those same parameters from our previous projects, we'll need to shrink the RPC URL, we'll need our private key.

9908
16:22:16.525 --> 16:22:20.007
If we want to verify we'll need our ether scan API key.

9909
16:22:20.007 --> 16:22:24.188
And if we want to do gas output, we'll need our coin market cap API key.

9910
16:22:24.188 --> 16:22:25.968
So let's make sure we have all that.

9911
16:22:25.968 --> 16:22:27.682
And we'll look at our deploy script.

9912
16:22:27.682 --> 16:22:34.200
Once again, just real quick look at our helper hardcat config just real quick, and it looks like we do indeed have everything in here.

9913
16:22:34.200 --> 16:22:40.463
And we should just be able to deploy it in one command.

9914
16:22:40.589 --> 16:22:48.266
So we should be able to do yarn, hard hat or just h h again, ploy, dash dash network Rinkeby.

9915
16:22:48.266 --> 16:22:50.876
Let's go try this out.

9916
16:22:50.876 --> 16:22:55.189
All right, it looks like we've compiled successfully, we've deployed it successfully.

9917
16:22:55.189 --> 16:22:59.379
And we've even verified it, we can go and open it up on Rinku ether scan.

9918
16:22:59.379 --> 16:23:01.985
And we can see our code here has been verified.

9919
16:23:01.985 --> 16:23:03.699
And it's looking beautiful.

9920
16:23:03.699 --> 16:23:05.684
We can read from it, which is great.

9921
16:23:05.684 --> 16:23:08.169
We can see all these commands here now that it's verified.

9922
16:23:08.169 --> 16:23:18.802
And if we look at the Git raffle state, we should indeed see that it's open, right, and it's going to stay open until somebody ends the raffle and updates the amount of eath that the contract actually has.

9923
16:23:18.802 --> 16:23:24.017
Now that we've deployed a contract using that sub ID, we need to register the contract with chain link V REF.

9924
16:23:24.017 --> 16:23:25.350
And with chain link keepers.

9925
16:23:25.350 --> 16:23:28.867
So we need to add this consumer does tell chinley VRF.

9926
16:23:28.867 --> 16:23:31.046
Hey, this is the contract that you're looking for now.

9927
16:23:31.046 --> 16:23:41.504
So we're gonna go back to V REF dot chain dot link, and we're going to grab this contract address, and we're going to add it as a consumer, your subscription is ready, you can now add consumers we're gonna add consumer.

9928
16:23:41.504 --> 16:23:46.899
And again, this website is just here to help facilitate us interacting with the contract.

9929
16:23:46.899 --> 16:23:51.303
So we're going to approve that user, we'll go ahead and confirm and the transaction is going through.

9930
16:23:51.303 --> 16:24:00.072
While we wait for this to go through, we can go to keepers dot chain dot link, and do the same thing work with the user interface to register a new upkeep.

9931
16:24:00.072 --> 16:24:05.395
So we'll go ahead and add our email Hardhead free code camp@gmail.

9932
16:24:05.395 --> 16:24:05.636
com.

9933
16:24:05.636 --> 16:24:08.055
We'll call this raffle upkeep.

9934
16:24:08.055 --> 16:24:14.847
We'll paste our upkeep address in here we have our admin address, and you can ignore this bit right here.

9935
16:24:14.847 --> 16:24:18.827
For gas limit, this is going to be the gas limit of the PErforM upkeep function.

9936
16:24:18.827 --> 16:24:23.661
If we did our gas estimator, we could just check to see how much that perform upkeep costs.

9937
16:24:23.661 --> 16:24:29.090
But for now, I'm just going to put 500,000 That's probably overkill, but that's fine.

9938
16:24:29.090 --> 16:24:33.574
Check data, we're going to keep blank because again, our checkup keep doesn't take anything.

9939
16:24:33.574 --> 16:24:36.161
And then starting balance, we're going to put as eight.

9940
16:24:36.161 --> 16:24:40.426
And if you forget to put a starting balance here, you can always find it later.

9941
16:24:40.426 --> 16:24:46.145
So let's go ahead and register, we're gonna get a Metamask pop up, we're gonna go ahead and hit Confirm.

9942
16:24:46.145 --> 16:24:53.393
And we can go back to our VRF and see that it's indeed been added and awesome, we now have a consumer on our VRF.

9943
16:24:53.393 --> 16:25:05.056
So now let's just wait for our keepers to go through upkeep registration requests submitted successfully on domain net, you might actually have to wait a little bit for your request to go through, but I'll test that it should automatically go through.

9944
16:25:05.056 --> 16:25:21.540
Now if we go back to keepers dot chain dot link, we should now see we now if we scroll down to my upkeeps We have a raffle upkeep here and I have to because I accidentally use the same account that I tested on, you can ignore the two you'll have one but this is the one that we just created.

9945
16:25:21.590 --> 16:25:25.923
And we can actually see what our balances and then what the minimum balance for this actually is.

9946
16:25:25.923 --> 16:25:28.812
So it looks like eight Link was a little bit too low.

9947
16:25:28.812 --> 16:25:32.933
So let's go back to Fosses dot chain dot link slash rinky.

9948
16:25:32.933 --> 16:25:37.380
Now that we have some more link, we can come back to our raffle upkeep.

9949
16:25:37.380 --> 16:25:39.352
And we go ahead and hit add funds.

9950
16:25:39.352 --> 16:25:41.470
And we'll add just three.

9951
16:25:41.470 --> 16:25:46.751
And we'll go ahead and confirm we first need to give permission to spend.

9952
16:25:46.751 --> 16:25:52.923
We approved our link transfer now let's actually transfer the link to the contract and alright funds added successfully.

9953
16:25:52.923 --> 16:25:54.524
So now let's do a little refresh.

9954
16:25:54.524 --> 16:26:01.419
Now we no longer see that message saying that it's underfunded and we have our balance and we can see that it's more than the minimum balance.

9955
16:26:01.419 --> 16:26:04.066
We have See the history that we just funded this twice.

9956
16:26:04.066 --> 16:26:15.057
Once this actually kicks off, we'll see activity type will be like perform upkeep or something got our sub ID, we've deployed the contract, we've registered with chain link V REF, we've registered it with chain link keepers.

9957
16:26:15.057 --> 16:26:18.190
Now all we need to do is run the staging tests.

9958
16:26:18.190 --> 16:26:26.705
Now running our staging test is essentially going to be the same as us calling this enter script, right, because all we're doing in our staging test is entering the lottery.

9959
16:26:26.705 --> 16:26:40.280
And then we just have a whole bunch of validators that we're running to make sure that things are doing as we expect, since our contract is actually verified, what we could do on Rigby ether scan is we can actually go to this right contract section of the contract.

9960
16:26:40.280 --> 16:26:44.073
And we could even connect our wallets to it.

9961
16:26:44.073 --> 16:27:01.813
And once this turns from red to green, after a little refresh, we'll now see that it's green, it's connected, we can even call functions on this contract ourself, so we could enter the raffle ourself, we would add, you know, however much eath to enter the raffle, and that would kick off the keepers in the VRF, as well.

9962
16:27:01.813 --> 16:27:10.854
So we could call it via ether scan, we could obviously call it via our staging tests here, we could call it via our scripts, we could call it via the console, there's a ton of ways to actually do this.

9963
16:27:10.854 --> 16:27:21.268
But moment of truth here, we're gonna run our staging tests, which is going to have us enter the lottery, and set up a listener to make sure that everything works correctly.

9964
16:27:21.268 --> 16:27:30.273
And additionally, we'll see on our raffle upkeep history, we'll see a transaction go through, and then we'll see a transaction on our chain like VRF as well.

9965
16:27:30.273 --> 16:27:32.495
Are you ready? I sure am.

9966
16:27:32.591 --> 16:27:34.216
Let's do this.

9967
16:27:40.592 --> 16:27:42.362
And that should be all we need to do.

9968
16:27:43.592 --> 16:27:49.541
we probably should have added some console dot logs in here to tell us hey, to tell us what steps that we're on with each.

9969
16:27:49.592 --> 16:27:50.480
But we forgot to.

9970
16:27:52.592 --> 16:27:56.280
associated with this, we've added the console dot logs in the test there.

9971
16:27:56.280 --> 16:28:12.290
But all right, if we go to the ether scan for this contract, we go back to the rink the ether scan for this, we paste in that address, the first step that we're doing in this test, of course, while we're setting up this listener, the first transaction is going to be entering the raffle that's going to kick everything off.

9972
16:28:12.290 --> 16:28:12.480
Right.

9973
16:28:12.480 --> 16:28:17.247
So if we refresh a little bit on ether scan, we do indeed see we've entered the raffle.

9974
16:28:17.247 --> 16:28:20.592
And we've updated the balance of the raffle.

9975
16:28:20.592 --> 16:28:21.668
Okay, awesome.

9976
16:28:21.668 --> 16:28:23.592
So raffle has been entered.

9977
16:28:23.592 --> 16:28:37.269
Now then what happens? Well, if the raffle has been entered, if we go to raffle dot soul, if it's open, if enough time has passed, if there's players and it has a balance, which we just checked does, this will get kicked off by the keepers.

9978
16:28:37.269 --> 16:28:51.640
So if we go to the keepers, and we do a little refresh here, after a little bit, we do indeed see checkup key passed and we see a perform upkeep having gone through great, what does perform upkeep to well perform upkeep calls the chainlink VRF.

9979
16:28:51.640 --> 16:29:04.610
So now if we go over to chainlink, VRF, we do a refresh here, go down to history, we do indeed see one of the transactions has gone through we can see the transaction hash, the link spent, etc.

9980
16:29:04.610 --> 16:29:11.559
And now if we go back to our tests, we do indeed see raffle unit tests for friend fulfill random request winner pick event fired.

9981
16:29:11.559 --> 16:29:22.556
And this means that we just went through this entire process of having a perfectly truly decentralized raffle work on an actual Testament with our integration tests working correctly.

9982
16:29:22.593 --> 16:29:25.978
Absolutely massive, huge congratulations if you've made it this far.

9983
16:29:25.978 --> 16:29:34.524
And if you just walk through the integration test with me now bounce over contract has now been reset to zero because our wallet address just won the lottery right and got the money back.

9984
16:29:34.524 --> 16:29:38.270
Now you might be wondering, Hey, I see the Create raffle function.

9985
16:29:38.270 --> 16:29:48.270
And I see enter raffle but I don't see didn't the chain link nodes just call perform upkeep and fulfill random words, I'll come no matter how often I refresh, I don't see those transactions here.

9986
16:29:48.270 --> 16:29:59.526
Well, those are actually going to be considered internal transactions fulfill random words, it's actually called through the VRF coordinator and the VRF coordinator contract then calls for full randomness.

9987
16:29:59.593 --> 16:30:02.283
So we can go to internal transactions.

9988
16:30:03.593 --> 16:30:09.765
transactions is going to be the transaction to the VRF coordinator contract, which calls our contract.

9989
16:30:09.765 --> 16:30:11.593
Same thing with perform upkeep.

9990
16:30:11.593 --> 16:30:18.374
Perform upkeep, the chain link nodes actually call through the registry contract and then the registry contract calls perform upkeep.

9991
16:30:18.374 --> 16:30:19.499
That's what we see here.

9992
16:30:19.593 --> 16:30:23.050
And if we go through the internal transactions, we'll see him there.

9993
16:30:23.050 --> 16:30:25.287
Now let's look at this enter raffle as well.

9994
16:30:25.287 --> 16:30:30.287
And since we've learned about events and logs, we can actually go to the logs section now.

9995
16:30:30.287 --> 16:30:40.343
And we can see our log or event being emitted here we can see the name raffle, enter, we can see the topic zero which is going to identify this entire event.

9996
16:30:40.343 --> 16:30:55.779
And then we also see this number here which is what which is index topic, one address player and then there's no data associated with this right because we only have index parameters which again show up as topics so this is absolutely phenomenal.

9997
16:30:55.779 --> 16:31:06.507
Wow, absolutely massive and we can rerun a unit test Just by hh test in this will only run our unit tests.

9998
16:31:06.594 --> 16:31:09.990
And we can see that these are all passing as well, things are looking fantastic here.

9999
16:31:09.990 --> 16:31:22.430
And we have just successfully created a verifiably random, autonomous, decentralized, raffle and or lottery deployed on the blockchain, you should be so excited right now.

10000
16:31:22.430 --> 16:31:25.142
Now, I'm not going to show you how to push this up to GitHub.

10001
16:31:25.142 --> 16:31:34.948
However, if you want to push this up to get up, and again, tweet at me, tweet at chainlink tweet at Free Code Camp, please feel free to do so because you just did an amazing job getting this far.

10002
16:31:34.948 --> 16:31:39.260
And if you're gonna want to push this up to GitHub, remember, we're going to want to put a dot Git ignore.

10003
16:31:39.260 --> 16:31:45.780
In here, we add a ton of stuff like that VS code artifacts, cash deployments, known modules, etc.

10004
16:31:45.780 --> 16:31:58.529
Type chain types, all this stuff, you can find a sample dot Git ignore, of course, in the GitHub repo associated with this, this is an advanced project, we did a lot of really advanced things here.

10005
16:31:58.594 --> 16:32:05.868
And this is the section of the course, where I think at this point, you've got most of the fundamentals down.

10006
16:32:05.868 --> 16:32:07.731
And now we're going to move into more front end.

10007
16:32:07.731 --> 16:32:17.260
And we're going to move into more industry specific and more advanced topics that are really going to supercharge you and make you one of the masters of the blockchain in the smart contract realm.

10008
16:32:17.260 --> 16:32:38.986
So huge congratulations, one more time, definitely go celebrate, definitely go for that walk, take a quick break, let everything we just learned settling your brain and get ready for the next one.

10009
16:32:39.595 --> 16:32:49.404
Alright, now we're gonna go over the TypeScript edition of this lesson, we're gonna go a little bit quickly here, because we're not learning too much new stuff for this TypeScript edition.

10010
16:32:49.404 --> 16:32:53.939
So if you want to just follow along, you can open up the repo here and use the TypeScript branch.

10011
16:32:53.939 --> 16:33:04.152
One thing to note that is a little bit different is when we do our promise in our tests, we're doing a weight promise void, because we're not going to be returning anything with our promise here.

10012
16:33:04.152 --> 16:33:06.282
But the rest is going to be exactly the same.

10013
16:33:06.282 --> 16:33:10.542
We're going to have a hard hat dot config to TypeScript that's going to use imports.

10014
16:33:10.595 --> 16:33:13.232
Once again, everything else is pretty much the same.

10015
16:33:13.595 --> 16:33:16.595
going to export the config like we did last time.

10016
16:33:17.595 --> 16:33:17.982
dot JSON.

10017
16:33:20.595 --> 16:33:21.562
dependencies as well.

10018
16:33:23.595 --> 16:33:26.201
follow that same functionality that we've used before.

10019
16:33:26.595 --> 16:33:32.431
our deploy scripts use a type deploy function on our variables that we export at the bottom.

10020
16:33:32.431 --> 16:33:39.995
And we also import the hard hat runtime environment type, which where we pull the deployments get named account and networks from in our tests.

10021
16:33:39.995 --> 16:33:57.737
Of course, we're still importing the types of these contracts from type chain slash types, like you see here, like for example, raffle is going to be signed to raffle VRF coordinator V to mock is going to be signed to type VRF coordinator V to MK and if we wanted to deploy with these contract factories, we could as well.

10022
16:33:57.737 --> 16:34:00.063
So those are going to be the main differences with TypeScript.

10023
16:34:00.063 --> 16:34:01.844
There's not anything really new there.

10024
16:34:01.844 --> 16:34:11.805
But again, if you want to follow along with TypeScript, and you want to code everything in TypeScript, and example is here for you All right, welcome back.

10025
16:34:11.805 --> 16:34:20.428
I hope your break was absolutely fantastic because now we are getting into more advanced full stack slash front end development.

10026
16:34:20.428 --> 16:34:25.055
We've done the back end development, we've created smart contracts, we created our lottery.

10027
16:34:25.055 --> 16:34:32.971
In our last section, we have all this wonderful code that allows us to work with our own provably decentralized lottery.

10028
16:34:32.971 --> 16:34:39.225
In order for regular everyday people to use our lottery, we're going to need to build a front end.

10029
16:34:39.225 --> 16:34:51.299
Now previously, we learned to build a front end with raw HTML JavaScript, with our Funmi project, we created a front end with just pure HTML and JavaScript, just creating applications with HTML and JavaScript is great.

10030
16:34:51.299 --> 16:34:54.662
And if that's what you want to do, you absolutely can.

10031
16:34:54.662 --> 16:34:57.966
But doing it with those vanilla protocols has some limitations.

10032
16:34:57.966 --> 16:35:09.153
And working with a framework, like what we're going to be working with in this section is going to make our lives a lot easier, we're going to be able to develop quicker, have more functionality, and do more in less time.

10033
16:35:09.153 --> 16:35:15.442
As you remember back to the project wasn't really a fleshed out project, if you remember, it was just a bunch of buttons.

10034
16:35:15.442 --> 16:35:16.503
And that was really it.

10035
16:35:16.596 --> 16:35:24.329
So working with a framework is really going to enable us to put more features and add more styling to our applications really easy.

10036
16:35:24.329 --> 16:35:32.477
Once again, the code for this entire section is located in our lesson and is located in this GitHub repository associated with the course.

10037
16:35:32.477 --> 16:35:43.158
Now I have to put an asterisk here, as I've said many times, the front end sections of this course are not required, we're not going to learn anything new about the back end in this front end section.

10038
16:35:43.158 --> 16:35:50.047
So if you don't care about building websites, all you want to do is learn the smart contract aspect of this course, you can skip these sections.

10039
16:35:50.047 --> 16:35:59.471
But if you do want to learn how to build these front end applications, if you do want to give users and non developers the abilities to interact with our smart contracts, then please continue to watch.

10040
16:35:59.471 --> 16:36:07.018
Now I also have to put an asterix here, because if you haven't worked with some of these frameworks before, the learning curve can seem a little bit steep.

10041
16:36:07.018 --> 16:36:13.430
And as I've said many times, this isn't going to be a front end course that would take several more hours than what we want to do for this video.

10042
16:36:13.430 --> 16:36:22.734
So if you've never done front end before, this is one of the sections where I do recommend you follow along with one of these optional sub lessons, we're not going to play them here.

10043
16:36:22.734 --> 16:36:26.482
But if you follow along with one of these sub lessons, that will definitely be incredibly helpful.

10044
16:36:26.482 --> 16:36:33.212
One of the videos that I have for the sub lessons is this video right here, how to connect your smart contracts to Metamask.

10045
16:36:33.212 --> 16:36:38.212
And it shows a number of ways connecting your smart contracts and building kind of these these front ends.

10046
16:36:38.212 --> 16:36:41.473
It does start with a raw HTML and JavaScript edition.

10047
16:36:41.597 --> 16:36:45.065
So you can really get some more practice in here with HTML and JavaScript.

10048
16:36:45.065 --> 16:36:48.993
And then it moves to index js ethers and a few other next Jas based applications.

10049
16:36:48.993 --> 16:36:55.954
Doing it a few different ways will install a new some more insight on what you should be thinking about when you're approaching these.

10050
16:36:55.954 --> 16:36:59.946
So this is absolutely a video to watch if you're new to front end development.

10051
16:36:59.946 --> 16:37:02.547
Additionally, for this section, like I said, we're going to be using a framework.

10052
16:37:02.547 --> 16:37:06.069
And in particular, we're going to be using the next Jas framework.

10053
16:37:06.069 --> 16:37:06.359
Now.

10054
16:37:06.359 --> 16:37:08.951
Next, Jas is a react based framework.

10055
16:37:08.951 --> 16:37:13.050
React is a framework for building front end and full stack applications.

10056
16:37:13.050 --> 16:37:15.678
Next, Jas is a framework on top of the React framework.

10057
16:37:15.678 --> 16:37:28.032
So if you already know react, most of this is going to come very naturally to the reason that we're using React in next Jas is because React is easily as of right now one of the most popular frameworks and languages out there.

10058
16:37:28.032 --> 16:37:35.977
And it's no surprise why we've got a little article in the GitHub repo titled Why you should use React js for web development, which we'll go into a little bit more.

10059
16:37:35.977 --> 16:37:49.356
Some of the biggest applications like Facebook and Instagram use React js and a number of other Fortune 500 companies and React js especially in the blockchain space is easily the most popular with protocols like uniswap, and Avi also using React Jas.

10060
16:37:49.356 --> 16:37:58.024
Now the reason we're using this next Jas on top of React Jas is that next Jas, I think makes working with react much easier.

10061
16:37:58.024 --> 16:38:01.836
And I want us to work with the easiest and most powerful framework out there.

10062
16:38:01.836 --> 16:38:09.770
Next, Jas is also getting a ton of steam has some really advanced but in my mind easier to use features than just raw react.

10063
16:38:09.770 --> 16:38:18.379
Now, like I said, if you've never worked with React before, if you've never worked with next Jas before, and you want to do a little brush up, definitely watch my video six ways to connect your depth to a wallet.

10064
16:38:18.379 --> 16:38:23.598
And if you find yourself struggling with with this section, because the front end stuff doesn't really make sense.

10065
16:38:23.598 --> 16:38:28.542
We also have a next Jas crash course in the GitHub repo associated with this course.

10066
16:38:28.598 --> 16:38:30.401
It's about an hour long and it is absolutely phenomenal.

10067
16:38:30.598 --> 16:38:33.664
Code Camp also has some next Jas crash courses.

10068
16:38:34.598 --> 16:38:44.936
struggling with the front of it, go take it next Jas course, and then come back to this section or skip the front end sections all together, do the rest of the course of just the back end, and then come back and do these front end sections.

10069
16:38:44.936 --> 16:38:50.631
We're going to show you the cutting edge ways to interact and work with your front end and then also deploy them.

10070
16:38:50.631 --> 16:38:57.198
And if you follow along correctly, by the end of this, you'll have a website deployed that you can show off and you can send a link of it to your friends.

10071
16:38:57.198 --> 16:39:03.859
And now I know we already showed you what this looks like but I'm going to show you it one more time just so we can walk through and see exactly what we're doing.

10072
16:39:03.859 --> 16:39:10.198
So we're going to have this decentralized lottery where we can go ahead with can connect our wallet if not already connected.

10073
16:39:10.198 --> 16:39:12.968
And we can switch, we can switch around between networks.

10074
16:39:12.968 --> 16:39:23.030
And our app will actually recognize it and say, hey, the only supported chains that we're working with here are going to be 31337, which is localhost, or four, which is ring feed.

10075
16:39:23.030 --> 16:39:32.002
And we'll learn how to add this validation into our application so that our app only works when we're on a chain that we want, then we can go ahead and interact with it.

10076
16:39:32.002 --> 16:39:40.150
Normally, we can click a button Metamask will pop up, we can go ahead and confirm we'll get a little transaction notification saying that transaction is complete.

10077
16:39:40.150 --> 16:39:42.632
And we'll get our front end updated.

10078
16:39:42.632 --> 16:39:47.995
And then on the back end, we'll be able to see the chain link nodes and the Chinuch V REF do their work.

10079
16:39:47.995 --> 16:39:55.964
And once they actually pick a winner, after a refresh, we'll be able to see that the back end node was updated, we do indeed have a previous winner.

10080
16:39:55.964 --> 16:39:56.471
Awesome.

10081
16:39:56.599 --> 16:40:04.795
Now, not only that, we're going to show you how to build this, but also, we're going to show you how to host it on an actual site.

10082
16:40:04.795 --> 16:40:07.499
So you'll be able to push it up to your own blockchain.

10083
16:40:07.599 --> 16:40:11.954
And additionally, we're gonna host it in a decentralized context.

10084
16:40:11.954 --> 16:40:20.887
So this site that we have here is it's going to be hosted on a technology that allows us to host websites in decentralized contexts as well swore backends.

10085
16:40:20.887 --> 16:40:24.978
And even our front ends can be hosted in decentralized context.

10086
16:40:24.978 --> 16:40:33.937
So So I hope you're incredibly excited for this because we're going to be showing you the cutting edge tools that many of the top blockchain projects use.

10087
16:40:33.937 --> 16:40:37.394
And let's just jump right into it.

10088
16:40:37.599 --> 16:40:44.824
Now, I'm currently in the Hardhead smart contract lottery project, the project that we just did, we did this hard hat smart contract lottery, which is great.

10089
16:40:44.824 --> 16:40:52.277
What we're going to do now is we're going to create a new folder, although we are going to be coming back to this folder from time to time to make a couple of updates.

10090
16:40:52.277 --> 16:40:54.276
So if you want to keep it open, you absolutely can.

10091
16:40:54.276 --> 16:41:00.534
But for me, I'm gonna go ahead and CD download directory to kind of my main directory for this whole course.

10092
16:41:00.600 --> 16:41:05.053
And we're going to create a new directory called next Jas.

10093
16:41:05.600 --> 16:41:06.400
contract.

10094
16:41:11.600 --> 16:41:15.534
smart contract lottery FCC, and go ahead and hit code period.

10095
16:41:15.600 --> 16:41:19.729
And like I said, if you want to keep that one up and have this new folder up, you absolutely can.

10096
16:41:19.729 --> 16:41:25.300
But basically, again, we're just opening up our VS code in this next Jas smart contract lottery folder.

10097
16:41:25.300 --> 16:41:44.400
Now for this front end stuff, in particular, if you want to be absolutely sure you're using the same versions as I am, what you can do is you can git clone this repo, and then copy the yarn dot lock and package dot JSON, and then run yarn, this will make sure you're always using the exact same packages that I'm using, and you'll never run into any weird issues.

10098
16:41:44.400 --> 16:41:56.863
So if you do run into an issue, one of the first things to do, especially for these front end parts is to go back, make sure you have the exact same yarn dot lock and package that JSON that I do in my examples here, and go from there.

10099
16:41:56.863 --> 16:41:58.968
Now we're here in our front end project.

10100
16:41:58.968 --> 16:42:11.059
And we're going to create a website, we're gonna create a front end for application, like I said, we're gonna be using next Jas, if you want to follow along with the next Jas documentation here, they do have a great getting started and walking through this.

10101
16:42:11.059 --> 16:42:20.015
So for us, we're going to do yarn, create next app, and then put a little period saying we want our next app in this directory.

10102
16:42:20.015 --> 16:42:25.091
If you don't put this period, it'll create it in a new folder, and you'll have double folders.

10103
16:42:25.091 --> 16:42:26.009
Okay, awesome.

10104
16:42:26.009 --> 16:42:34.521
So and once we do this, in our little files explorer section, we now can see all the different files that come boilerplate with this.

10105
16:42:34.600 --> 16:42:36.790
Now, let me just do a quick walkthrough of what's going on here.

10106
16:42:36.790 --> 16:42:42.158
Again, we also go through this in those two videos that I recommended, but it doesn't hurt to go over it twice.

10107
16:42:42.158 --> 16:42:47.797
So node modules, of course, is going to be the package in the installations pages is going to be the different pages on our site.

10108
16:42:47.797 --> 16:42:49.911
Let me let me show you what I mean by this.

10109
16:42:49.911 --> 16:42:51.372
To run this whole thing.

10110
16:42:51.372 --> 16:43:01.366
Actually, we can just run yarn, run Dev, and we'll get started server on blah, blah, blah, blah, blah, you can command click it or copy paste it into your browser.

10111
16:43:01.366 --> 16:43:05.533
And now you'll see on localhost 3000, we have our page up here.

10112
16:43:05.601 --> 16:43:08.134
Now what we can do, actually, so index.

10113
16:43:09.601 --> 16:43:12.854
default page, which is, you know, considered this slash here.

10114
16:43:12.854 --> 16:43:15.774
But what we can do is we can create new pages.

10115
16:43:15.774 --> 16:43:19.482
So I could do new file, you know, dog dot Jas.

10116
16:43:19.482 --> 16:43:30.601
And then you know, just copy paste index into dog to Jas, paste it, delete everything inside the div, you don't have to follow along here and just go Hi, save this, go back here.

10117
16:43:30.601 --> 16:43:34.378
I can now put in dog and get this.

10118
16:43:34.601 --> 16:43:39.431
So pages is going to be all kind of these different routes to these different spots on our website.

10119
16:43:39.431 --> 16:43:43.124
And index is going to be our default, kind of like our homepage.

10120
16:43:43.124 --> 16:43:44.846
So I'm going to delete Dardo.

10121
16:43:44.846 --> 16:43:48.889
And inside these files is going to be something called react syntax or JSX.

10122
16:43:48.889 --> 16:43:52.289
They come as Jas but they're basically reacts in text.

10123
16:43:52.289 --> 16:43:59.288
Next, Jas is based on React, you'll see these pages are this weird combination of both JavaScript and HTML.

10124
16:43:59.288 --> 16:44:18.746
We see some import stuff at this at the top, which reminds us of JavaScript and again, you'll see some important stuff at the top and then down here, you'll See, like div head main h1 P, you'll see all these like HTML tags react index js allow us to do this combination of JavaScript and HTML.

10125
16:44:18.746 --> 16:44:21.698
And it actually makes life a lot easier.

10126
16:44:21.698 --> 16:44:24.952
Now, you'll also notice we're doing imports in here.

10127
16:44:24.952 --> 16:44:30.015
Remember, I told you all this earlier, imports work with our front end require does not.

10128
16:44:30.015 --> 16:44:37.570
So that's some of the difference between node does not equal JavaScript, right? This is where the differences can start getting a little bit confusing.

10129
16:44:37.602 --> 16:44:43.776
But the way that I usually like to think about it is I just say, no JS, excuse me, I'll just say back end.

10130
16:44:43.776 --> 16:44:47.175
I can J S is a little different from front end.

10131
16:44:47.175 --> 16:44:47.437
Yes.

10132
16:44:47.437 --> 16:44:50.539
So back end, Jas and front end Jas are a little bit different.

10133
16:44:50.539 --> 16:44:52.338
That's kind of the way I like to think about it.

10134
16:44:52.338 --> 16:44:52.548
app.

10135
16:44:52.548 --> 16:45:06.489
js is going to be our entry point for everything the way react and next Jas work is everything is what's called component based in all of our files here, you're gonna see this export default function home or something along those lines.

10136
16:45:06.489 --> 16:45:18.268
What react and next Jas do is they say, Hey, this huge clump of HTML stuff that has a hodgepodge of JavaScript inside of it is considered a component.

10137
16:45:18.268 --> 16:45:23.231
And so all of our pages get wrapped through this underscore app.

10138
16:45:23.231 --> 16:45:23.795
js page.

10139
16:45:23.795 --> 16:45:27.118
So this is a page but it's kind of like the main entry point.

10140
16:45:27.118 --> 16:45:33.412
And they get stuck into this component section of our app that Jas so you can think of this on this graph.

10141
16:45:33.412 --> 16:45:36.852
The GS is kind of the whole application or whole front end.

10142
16:45:36.852 --> 16:45:43.470
And on this homepage, this component, we're sticking index dot j s right in here, we're swapping out component for index dot J.

10143
16:45:43.470 --> 16:45:43.568
S.

10144
16:45:43.568 --> 16:45:52.094
Now API is what we wanted to do if we wanted to do like some HTTP, GET HTTP POST requests, but we're not going to do any of that.

10145
16:45:52.094 --> 16:46:04.291
So we're going to pretty much ignore API for now public is just going to be some public images like a favicon or Versaille, that SVG styles is going to be the CSS for our project.

10146
16:46:04.291 --> 16:46:06.667
CSS stands for Cascading Style Sheets.

10147
16:46:06.667 --> 16:46:18.389
And it's basically a way to style your HTML, we're going to change the way we do styling and a little bit, but that's basically what these both do the ESLint I'm dumping this right now we have our dot Git ignore which we know what it does.

10148
16:46:18.389 --> 16:46:20.618
We have our next dot config dot J.

10149
16:46:20.618 --> 16:46:20.749
S.

10150
16:46:20.749 --> 16:46:22.841
This is a configuration file or next.

10151
16:46:22.841 --> 16:46:28.022
Jas, of course, we have our package json, we have a readme, and we have our yarn dot lock.

10152
16:46:28.022 --> 16:46:32.213
So most of what we're going to do is actually going to be inside this Pages folder.

10153
16:46:32.213 --> 16:46:51.353
And we're also going to create a couple other folders that are going to be our main stuff now, because I'm me, and like I said, I love working with prettier, I'm going to automatically dump a prettier RC, and a prettier ignore in here, just so that I can format my code a little bit nicer, you can grab your prettier RC from our last projects, you can grab your prettier ignore as well.

10154
16:46:51.353 --> 16:47:06.924
Or you can just pause me right now copy, paste them from the GitHub repo associated with this lesson, paste them in, and then we'll do yarn, add dash dash Dev, prettier, so that we can auto format all of our code for come back over to here, we can save and boom, stuff gets auto formatted.

10155
16:47:06.924 --> 16:47:09.364
Now, again, we're going to be using the multi terminal feature.

10156
16:47:09.364 --> 16:47:11.506
So right now I have one running my front end.

10157
16:47:11.603 --> 16:47:14.012
So if I come back to the front end, I hit refresh.

10158
16:47:14.603 --> 16:47:14.840
running.

10159
16:47:16.603 --> 16:47:16.857
stuff.

10160
16:47:16.857 --> 16:47:18.840
We have yarn run dev running right now.

10161
16:47:19.603 --> 16:47:23.790
to our package, JSON, running yarn, run dev just runs next Dev.

10162
16:47:23.790 --> 16:47:31.484
And actually, let me cancel it and just do yarn dev yarn is actually smart enough that don't need to do run Dev, but it just runs next Dev.

10163
16:47:31.484 --> 16:47:37.758
And this next command comes built in once we installed next, which we did when we did yarn create next app.

10164
16:47:37.758 --> 16:47:50.030
So next Jas comes with these scripts already built in for us, we want to build our front end to enable people to interact with our lottery in a fair way, and connect with the smart contract that's running.

10165
16:47:50.030 --> 16:47:52.248
Let's create some simple front end pieces for this.

10166
16:47:52.248 --> 16:47:56.182
So first thing we're gonna do is we're gonna go to Pages, and we're going to go to index.

10167
16:47:56.182 --> 16:47:56.287
js.

10168
16:47:56.287 --> 16:47:58.899
All this stuff in here is cute and nice.

10169
16:47:58.899 --> 16:48:06.434
And thank you next, Jas, but we're going to delete it all and delete everything except for that headpiece, we're gonna leave that up, we're just going to change the name.

10170
16:48:06.434 --> 16:48:17.389
But this way down here, we're going to change the name from Crate next app to smart contract lottery or raffle or whatever we want to do.

10171
16:48:17.389 --> 16:48:20.840
description will be our smart contract, lottery.

10172
16:48:20.840 --> 16:48:26.654
And then right below the head, we're going to write hello, blue, and save.

10173
16:48:26.654 --> 16:48:38.175
And if we look at our front end, we now see that it says smart contract lottery and the top and I'm going to move this all the way over here, smart contract lottery and the top and we see Hello, so smart contract lottery.

10174
16:48:38.175 --> 16:48:45.450
Hello, the description here, we're not going to see this is going to be something that web scrapers and stuff we're going to find.

10175
16:48:45.604 --> 16:48:50.210
Now one of the first things that we're going to need to do is we're going to need to create that connect button.

10176
16:48:50.210 --> 16:48:55.541
We've done this in the past with raw JavaScript, but now we're going to do it with next js and react.

10177
16:48:55.541 --> 16:48:58.836
The one that we made previously was pretty minimalistic.

10178
16:48:58.836 --> 16:49:06.204
In fact, we bring it back up it checked to see if there was windows that Aetherium and then went and requested and connected and said okay, cool.

10179
16:49:06.204 --> 16:49:07.046
You're connected.

10180
16:49:07.046 --> 16:49:11.636
Now what did didn't do was a lot of things that we would want an application to do.

10181
16:49:11.636 --> 16:49:22.556
When we change networks, our application didn't detect that when we change users or application didn't detect that it was really stringent in the functionality that it actually had for connecting to a wallet.

10182
16:49:22.605 --> 16:49:35.080
So we're going to make our wallet connect button, incredibly powerful, so that you can connect with the button, you can switch networks, you can switch accounts, you can pretty much do anything in our application will know our application will be responsive.

10183
16:49:35.080 --> 16:49:45.401
So that's gonna be one of the first things that we're going to do, we're going to create a header and connect button nav bar one a little navbar here, saying, hey, you know, you can connect with this button.

10184
16:49:45.401 --> 16:49:47.346
So that's gonna be the first thing that we're going to do.

10185
16:49:47.346 --> 16:49:51.121
Now we can build our whole connect button in this index dot j s and stick it in here.

10186
16:49:51.121 --> 16:49:54.700
But instead, what we're going to do is we're going to make it a what's called a component.

10187
16:49:54.700 --> 16:49:58.201
So we're going to create a new folder called components.

10188
16:49:58.201 --> 16:50:02.121
And we're going to create a new file in here called header.

10189
16:50:02.121 --> 16:50:02.250
js.

10190
16:50:02.250 --> 16:50:06.564
And you might also see a lot of people do header.

10191
16:50:06.564 --> 16:50:06.972
js x.

10192
16:50:06.972 --> 16:50:07.584
js and.

10193
16:50:07.584 --> 16:50:17.105
js x do literally the exact same thing, you can do either one, I'm going to do dot JSX, just to remind me that this is a React file that we're creating.

10194
16:50:17.105 --> 16:50:18.533
This is a component that we're creating.

10195
16:50:18.605 --> 16:50:19.938
But yeah, you can do J S JSX.

10196
16:50:21.605 --> 16:50:25.088
more about components, we've got a link to learning about components.

10197
16:50:25.088 --> 16:50:27.811
They're basically independent and reusable bits of code.

10198
16:50:27.811 --> 16:50:32.339
They serve the same purpose as JavaScript functions, but work in isolation and return HTML.

10199
16:50:32.339 --> 16:50:44.552
So basically, we're going to create like a little chunk of HTML that we're going to export into our index such as like what we've done in the past, this just helps modularize and reuse this header component, you know, across our project.

10200
16:50:44.552 --> 16:50:47.536
Now, we're only going to be using our header in one area.

10201
16:50:47.536 --> 16:50:50.686
However, it's still nice to modularize the project regardless.

10202
16:50:50.686 --> 16:50:54.655
And to get start, this is going to be what's called a functional base component.

10203
16:50:54.655 --> 16:51:04.504
So we're going to create basically a function called home write really pretty much exactly like what we see in JavaScript, except it's going to return some HTML.

10204
16:51:04.504 --> 16:51:08.181
So we can do like a little div.

10205
16:51:08.181 --> 16:51:11.444
And my VS code auto created the closing div here.

10206
16:51:11.444 --> 16:51:14.021
And in here, I'm going to be like hi from header.

10207
16:51:14.021 --> 16:51:19.288
This is going to be a real minimalistic component like this is a valid component here.

10208
16:51:19.288 --> 16:51:22.295
Now we have this function that returns HTML.

10209
16:51:22.295 --> 16:51:29.299
And to give other applications, the ability to use this component will do export default function home.

10210
16:51:29.299 --> 16:51:31.073
And then in our index.

10211
16:51:31.073 --> 16:51:33.543
js, we can import it with imports.

10212
16:51:33.543 --> 16:51:48.458
Home actually, excuse me, I'm not going to call it home, we're going to call it header, header, excuse me, export default function header, and then import header from the down directory components slash header, like so.

10213
16:51:48.458 --> 16:51:59.551
So now we've imported our header in index such as if we go back to our front end, which is still running, we don't see it in here, right? Remember, everything goes through our app.

10214
16:51:59.606 --> 16:52:03.963
And when we're on the slash page, that's going to go to our index.

10215
16:52:03.963 --> 16:52:04.105
js.

10216
16:52:04.105 --> 16:52:10.481
index js is importing our header, but it's not returning our header, right, we see.

10217
16:52:10.481 --> 16:52:12.065
And here, we see it returns.

10218
16:52:12.065 --> 16:52:14.753
And this is the HTML that it's returning.

10219
16:52:14.753 --> 16:52:17.133
And as you can see, there's clearly no header in here.

10220
16:52:17.133 --> 16:52:21.043
So now that we've imported our header, we need to actually add our header in here.

10221
16:52:21.043 --> 16:52:24.812
So we'll do header, and then adds the closing tag right here.

10222
16:52:24.812 --> 16:52:34.896
If you don't add any stuff, you know, in between two tags, you can go ahead and just do this one liner here, with a backslash at the end saying, Hey, this is an open and closed tag here.

10223
16:52:34.896 --> 16:52:44.392
Now that we've imported it, what do you think we'll see on the front end, now that we've added it to our index js, you're right, we see hi from header, because we added our header here.

10224
16:52:44.392 --> 16:52:45.963
And then we see Hello.

10225
16:52:45.963 --> 16:52:48.352
So high from header, hello, boom.

10226
16:52:48.352 --> 16:52:51.987
Now, anything that we do, obviously now in our header.

10227
16:52:51.987 --> 16:52:54.463
js, will see reflected on our front end.

10228
16:52:54.463 --> 16:53:00.016
So we can do hi from header, blah, blah, blah, you know, just a bunch of dribbles, and we'll see it on our front end.

10229
16:53:00.016 --> 16:53:05.321
So this is going to be our section where we're going to make our header or a navbar or all the functionality for the Connect button.

10230
16:53:05.321 --> 16:53:08.940
Now I'm going to tell you something, and some of you are going to love this summer, you're going to hate this.

10231
16:53:08.940 --> 16:53:09.807
I'm going to show you.

10232
16:53:09.807 --> 16:53:13.764
I'm going to show you the hard way first, then the easy way.

10233
16:53:13.764 --> 16:53:26.933
Why am I going to show you the hard way first? Well, because I want you to become familiar with what's actually going on behind the scenes and what's actually going on with some of these components because it is really helpful when building these front ends to understand, Okay, here's what's going on.

10234
16:53:26.933 --> 16:53:34.770
If you don't understand what's going on behind the scenes, you're gonna go to try to build more advanced applications, and you're gonna have no idea what to do because you've just learned the shortcut.

10235
16:53:34.770 --> 16:53:43.251
I like to think of it as like calculus, like we're going to learn how to calculate a derivative first, and then we're going to learn the shortcut to quickly getting derivatives.

10236
16:53:43.251 --> 16:53:48.114
So don't skip this part, because this is going to help you well and beyond down the line.

10237
16:53:48.114 --> 16:53:53.575
Okay, we're going to learn this the harder way to set everything up in our HTML Funmi.

10238
16:53:53.575 --> 16:53:59.236
We just use raw ethers to kind of do everything and you absolutely can use raw ethers to do everything.

10239
16:53:59.236 --> 16:54:08.038
However, there are some packages especially for React that make life developing a front end substantially better and in our full blockchain solidity course, Jas.

10240
16:54:08.038 --> 16:54:12.591
We have a number of other packages that you can use will stack development and other libraries.

10241
16:54:12.591 --> 16:54:17.531
And if you watch this six ways to connect your depth to a wallet, you'll actually understand some of the differences.

10242
16:54:17.531 --> 16:54:20.857
So if you haven't watched that video, go back, watch that video.

10243
16:54:20.857 --> 16:54:25.689
But there's a whole bunch of libraries that we can use that are going to make our lives a lot easier.

10244
16:54:25.689 --> 16:54:27.213
We've listed some of them here.

10245
16:54:27.213 --> 16:54:35.642
React Morales is the one that we're going to be using today, they have some additional plugins, and they have probably my favorite thing on the planet, which I'm going to show you how to do very soon.

10246
16:54:35.642 --> 16:54:45.048
But these are also open source, Ross also comes with some optional functionality to hook into your own back end to give your app even more features and even more functionality.

10247
16:54:45.048 --> 16:54:46.706
And that's the other reason that we're doing it.

10248
16:54:46.706 --> 16:54:48.574
So and we're gonna go over that later.

10249
16:54:48.574 --> 16:54:51.765
And if you want to use pure ethers, you absolutely still can.

10250
16:54:51.765 --> 16:54:56.758
A lot of these packages that we're using do rely on ethers, but we're not going to use just ether.

10251
16:54:56.758 --> 16:54:58.508
So we go to the React Morales page.

10252
16:54:58.608 --> 16:55:01.139
And to get started, we can just do this bit right here.

10253
16:55:02.608 --> 16:55:05.369
literally going to copy this and bring it into our project.

10254
16:55:05.608 --> 16:55:10.165
if you go to our package that JSON, we actually already have react and react DOM.

10255
16:55:10.165 --> 16:55:14.849
So we can just do yarn, add Morales, and react oralis.

10256
16:55:14.849 --> 16:55:23.269
Now you'll notice I'm not doing these as dev dependencies, I didn't do yarn, add dash dash dev here.

10257
16:55:23.269 --> 16:55:37.170
The reason is, because for our production builds, when we actually create the website here, you will need Morales and you will need react Morales we don't need prettier to create a website prettier is a tool that we're using as developers.

10258
16:55:37.170 --> 16:55:41.239
So in all of our projects, so far, we've been using just dev dependencies.

10259
16:55:41.239 --> 16:55:54.117
That's because we've only been building our projects for developers, our GitHub repos, they haven't been made to build a website, they've only been to do things on the back end, for our website, we're actually going to be building a front end.

10260
16:55:54.117 --> 16:56:03.473
So we need to put this in the dependencies section, because we need to say, Hey, these are the ones that we need to bundle up together for the front end, and you can ignore these ones.

10261
16:56:03.473 --> 16:56:07.258
And if it's just like a tool to make our lives better, it's gonna go in dev dependencies.

10262
16:56:07.258 --> 16:56:09.854
So we're adding Morales and react Morales.

10263
16:56:09.854 --> 16:56:15.959
And a lot of the syntax that we're going to do for our header is actually going to be really similar to what we've been seeing so far.

10264
16:56:15.959 --> 16:56:16.740
So let's do this.

10265
16:56:16.740 --> 16:56:29.415
And then actually, we're just going to change this name to manual header, manual header update imports for manual header, you can go ahead and hit yes to man you all header here, we're gonna copy manual header, make sure it's in our index.

10266
16:56:29.415 --> 16:56:33.209
js it we're gonna change header to manual header, and we're gonna change how to manual header here.

10267
16:56:33.209 --> 16:56:40.270
And the reason we're doing this is because like I said, we're going to create a much simpler header after we create this kind of harder one.

10268
16:56:40.270 --> 16:56:44.386
And we're going to want to create that connect button, which again, we made in HTML Funmi.

10269
16:56:44.386 --> 16:56:51.542
By calling eath request accounts, what we can do actually with Morales is we can just do this thing called Enable Web three.

10270
16:56:51.542 --> 16:56:57.418
So at the top, we're going to import, use mirallas.

10271
16:56:57.609 --> 16:56:59.157
From react ralis.

10272
16:57:03.609 --> 16:57:07.892
or to their GitHub, you'll learn how to set all this up too and learn more about the documentation.

10273
16:57:07.892 --> 16:57:20.415
So we're going to import use Morales from react Morales, and inside our function here, but outside of our return, we're going to say const, Enable Web three equals use mirallas.

10274
16:57:20.415 --> 16:57:25.333
Now use Morales is what's known as a hook as a React hook.

10275
16:57:25.333 --> 16:57:28.809
And it's a way to keep track of state in our application.

10276
16:57:28.809 --> 16:57:37.547
Now, in order to use mirallas, our entire application needs to be wrapped around what's called a Morales provider, which is going to be a context provider for us.

10277
16:57:37.609 --> 16:57:38.962
And I'll explain what that means in a minute.

10278
16:57:39.609 --> 16:57:43.948
we need to do is we need to add this Morales provider to our app.

10279
16:57:43.948 --> 16:57:44.173
js.

10280
16:57:44.173 --> 16:57:51.547
So in here, we're going to import oralis provider from react oralis.

10281
16:57:51.547 --> 16:57:58.990
And we're going to wrap our entire app around this Morales provided so we're going to do some little parentheses here.

10282
16:57:58.990 --> 16:58:09.085
New Line, we're going to paste morass provider like this, it's going to give us the closing tag, copy it, paste it like this and save.

10283
16:58:09.085 --> 16:58:16.766
And then in here, we're going to write in the sheet allies on Mount equals false.

10284
16:58:16.766 --> 16:58:24.902
This initialize on Mount piece here is the optionality to hook into a server to add some more features to our website.

10285
16:58:24.902 --> 16:58:30.578
We don't want to hook into a server for this application, we want everything just to be open source, and we don't need any of this additional functionality.

10286
16:58:30.610 --> 16:58:33.782
So we're just going to do initialize on Mount equals false.

10287
16:58:33.782 --> 16:58:40.429
Now that the whole thing is wrapped in this Morales provider, we go to the front end we should be able to refresh everything looks pretty much the same.

10288
16:58:40.429 --> 16:58:42.832
And we can start using these hooks.

10289
16:58:42.832 --> 16:58:57.884
Now this use Morales is what's known as a hook and hooks can be a little bit confusing to understand at first glance, but they're incredibly powerful and they are the de facto way for us to build react projects.

10290
16:58:57.884 --> 16:59:23.564
And if you're familiar with class components, we're not gonna be using class components because hooks are much better hooks allow function components to have access to state and other react feature ers state being probably one of the biggest ones and the most popular ones, we want our application to be different if we're connected to Metamask, versus if we're not, right, if we go back, if we go back to our example website here, right, if we're not connected, we want to say, Please connect to a wallet.

10291
16:59:23.611 --> 16:59:26.026
And then when we are connected, we want to go ahead and be connected.

10292
16:59:26.026 --> 16:59:37.695
If I have, let's say, I have some variable like, and I don't have this hook here, I have like, let connected equals false, right, or enable Web three, or is web three enabled, let's say I've led connected equals false.

10293
16:59:37.695 --> 16:59:57.561
And then I have, you know, let's say have some button that connects us and changes connected to be true, changing connected to be true is great and all but it won't rerender our application, you see, when I disconnect and I reconnect here, our application actually changes based off of whether or not we're connected.

10294
16:59:57.611 --> 17:00:01.544
And this is what we want, we want our front end to rerender.

10295
17:00:01.611 --> 17:00:08.048
When we're connected, if I just use a variable like this inside of our component, our front end isn't going to rerender.

10296
17:00:08.048 --> 17:00:14.059
Or even worse, if I use it outside, our component doesn't even know anything about this changing.

10297
17:00:14.059 --> 17:00:25.837
So hooks are a way for us to actually work with state especially and automatically rerender when something changes and enable Web three is going to be a function that we get from this use Morales hook to do that.

10298
17:00:25.837 --> 17:00:36.143
So for a lot of our components, instead of just saying like, let web three enabled equals true, like we did in normal JavaScript, we're going to be doing a lot of this, these hooks.

10299
17:00:36.143 --> 17:00:53.046
For the most part, we usually want our website to change based off of if some variable has changed and enabled web three is a function that we get from this hook that says, Okay, go ahead and connect Enable Web three is basically the equivalent of saying try await Aetherium dot request, like this.

10300
17:00:53.046 --> 17:00:56.857
Now enable Web three, the way we're going to use it here only works on Metamask.

10301
17:00:56.857 --> 17:01:05.494
But we will show you how to get this kind of this cool little module up where we can choose between different ways to connect our app.

10302
17:01:05.612 --> 17:01:25.366
We have our enabled web three, let's go ahead and create a button, that's going to do the same as what we did in our HTML Funmi in our return, but here, instead of hi friend header, we're going to add a new component, or we're going to add a new tag, we're gonna add the button tag, and for me it automatically close to, and I'm just gonna call it connect, I'm gonna go ahead and save.

10303
17:01:25.366 --> 17:01:26.849
Now we see a little button that says connect.

10304
17:01:26.849 --> 17:01:35.715
And obviously, it doesn't do anything, we're gonna give this some functionality, we're gonna say on click now since again, this is a JSX component.

10305
17:01:35.715 --> 17:01:41.902
This isn't raw HTML, in raw HTML, we can't just kind of stick JavaScript wherever we want.

10306
17:01:41.902 --> 17:01:46.678
But in JSX files, we can stick JavaScript kind of wherever we want.

10307
17:01:46.678 --> 17:01:53.644
So inside of this, inside of this block of HTML, we can actually stick JavaScript in here by adding these little brackets.

10308
17:01:53.644 --> 17:01:56.349
So adding these little brackets in our jobs can return.

10309
17:01:56.349 --> 17:01:57.922
But here, we can add JavaScript.

10310
17:01:57.922 --> 17:02:16.808
And what we want to do is we want to have our On Click Call Enable Web three, we're going to call an async function, we're going to use the arrow syntax here, one click, we're gonna call this async function, which is just going to be await, Enable Web three, await Enable Web three, let's add the little parentheses here.

10311
17:02:16.808 --> 17:02:23.547
And essentially, with just this, we've done pretty much everything that we had back in this big connect function here.

10312
17:02:23.612 --> 17:02:29.992
Now if we go back to our front end, do a little refresh, we can see that right now, we can see that I'm actually connected, I'm gonna go ahead and disconnect.

10313
17:02:29.992 --> 17:02:38.870
I'm still connected from some of the last applications I was doing, we can hit Connect, and now we see metamath does indeed pop up, we'll hit Next connect, and boom.

10314
17:02:38.870 --> 17:02:39.805
And that's all we need to do.

10315
17:02:39.805 --> 17:02:42.033
Now, if we look at our Metamask, it says connected.

10316
17:02:42.033 --> 17:02:42.348
Great.

10317
17:02:42.348 --> 17:02:42.927
Okay, cool.

10318
17:02:42.927 --> 17:02:50.631
So now we have a way to actually connect here, let's add some functionality and make our application smart enough to have the connect button if we're connected.

10319
17:02:50.631 --> 17:02:53.163
And if we're not connected, not have that button.

10320
17:02:53.163 --> 17:03:03.580
So what we'll do now is use Morales comes with another hook called is web three, enabled, which is just a variable part of our hook that keeps track of whether or not our Metamask is connected.

10321
17:03:03.580 --> 17:03:10.888
But we can actually do one better, we can actually check to see if there's an account because maybe web three is connected.

10322
17:03:10.888 --> 17:03:13.679
But but they didn't connect it to an account.

10323
17:03:13.679 --> 17:03:16.924
So let's go ahead and we'll import count from us.

10324
17:03:16.924 --> 17:03:19.957
Morales will check to see if there's an account.

10325
17:03:19.957 --> 17:03:27.693
So what we'll do is inside of our div tags, we'll do a little JavaScript, we'll do that ternary operator again, we'll put a count here with a question mark.

10326
17:03:27.693 --> 17:03:33.763
And we'll do that that same syntax that we've seen before, we'll say account, if account exists, do this.

10327
17:03:33.763 --> 17:03:35.313
If there's no account, do this.

10328
17:03:35.313 --> 17:03:39.350
And if there's no account, we want to add this Connect button.

10329
17:03:39.350 --> 17:03:41.799
So we'll go ahead and we'll stick this in here.

10330
17:03:41.799 --> 17:03:44.776
If there is an account, we'll just show that account, right.

10331
17:03:44.776 --> 17:03:50.528
So we'll do div backslash div in here, we'll just say connected, like that.

10332
17:03:50.613 --> 17:03:53.129
Now if we go back to our front end, we see connected.

10333
17:03:53.613 --> 17:03:55.581
a little refresh, it'll go away.

10334
17:03:57.613 --> 17:03:59.596
and now we're connected, which is great.

10335
17:04:00.613 --> 17:04:01.050
smarter.

10336
17:04:01.050 --> 17:04:03.300
We'll have it show our account here.

10337
17:04:04.613 --> 17:04:11.279
saying connected, we'll say connected to I'll put some JavaScript, we'll put some JavaScript inside of our JavaScript.

10338
17:04:11.279 --> 17:04:16.422
But since this is that HTML stuff, we got to use these brackets to say JavaScript again.

10339
17:04:16.422 --> 17:04:21.145
So we'll put JavaScript inside of the JavaScript, we'll say connected to, we can just say account.

10340
17:04:21.145 --> 17:04:32.306
Now go back to our front end, we see connected to blah, blah, blah, blah, blah, you'll notice if you hit refresh, you'll have to reconnect, we'll get to that in a minute, what a lot of people do is they'll do a count dot slice, zero, comma six.

10341
17:04:32.306 --> 17:04:50.872
And then outside of the brackets, they'll do dot that dot, another set of brackets account, that slice, count dot length minus four, close that off like that, we have our account, when we hit Connect, now it says connected to blah, blah, blah, hello.

10342
17:04:50.872 --> 17:04:59.047
And because of these hooks, when I switch accounts, and I connect with these new accounts, it even automatically re renders switching accounts.

10343
17:04:59.047 --> 17:05:03.998
So these hooks are really good for re rendering our websites whenever some value changes.

10344
17:05:03.998 --> 17:05:16.130
For example, if I said like, let count number equals seven, and we had a button, that updated account number, our front end wouldn't rerender unless we told it specifically to rerender, which gets really annoying.

10345
17:05:16.130 --> 17:05:18.375
So hooks kind of help us a lot with doing that.

10346
17:05:18.375 --> 17:05:24.457
And it allows us to keep track of states between renders.

10347
17:05:24.614 --> 17:05:33.489
Now, here's something that right now it doesn't do, if I hit refresh, I have to re hit this connect button, even though my Metamask says, Hey, we're connected.

10348
17:05:33.489 --> 17:05:35.786
But if I refresh, I have to re hit this Connect button.

10349
17:05:35.786 --> 17:05:36.544
Why is this happening.

10350
17:05:36.614 --> 17:05:47.864
Or when I hit refresh, our website doesn't know that we've hit enable Web three already, right, because we basically go back to blank when I refresh, and then I have to hit Connect, which is really obnoxious and really annoying.

10351
17:05:47.864 --> 17:05:56.114
So we want to add some functionality, so that automatically the instant we render, we go ahead and we check to see if we're already connected.

10352
17:05:56.114 --> 17:05:58.114
And if we're connected to show this.

10353
17:05:58.114 --> 17:06:02.460
Now to do that, we can use another hook called use effect.

10354
17:06:02.460 --> 17:06:05.720
And this is a core react hook.

10355
17:06:05.720 --> 17:06:12.215
So we'll do import use effect from react like this.

10356
17:06:12.215 --> 17:06:14.881
This is a core hook directly from react.

10357
17:06:14.881 --> 17:06:18.360
And it's one of the most popular out there along with use state.

10358
17:06:18.360 --> 17:06:36.932
And we've left some links to learning more about the effect hook in the GitHub repo associated with this course, I'm gonna give you my summary of basically what this use effect does, we basically have this function called use effect, which takes two parameters, it takes a function as its first parameter, and then second, it optionally takes a dependency array.

10359
17:06:36.932 --> 17:06:44.053
And what this use effect is going to do is it's going to keep checking the values in this dependency array.

10360
17:06:44.053 --> 17:06:51.199
And if anything in this dependency rate changes, it's going to call some function, and then rerender, the front end.

10361
17:06:51.199 --> 17:06:58.680
So for example, using Morales comes with this function called is web three enabled or this variable called is what three enabled.

10362
17:06:58.680 --> 17:07:05.760
If we add this to our dependency array, what we can do in our use effect is do console dot log, hi.

10363
17:07:05.760 --> 17:07:16.886
And then we can do console dot log is web three enabled, what this use effect is going to be doing is it's going to constantly be running, this is running all the time.

10364
17:07:16.886 --> 17:07:25.815
And it's going to be listening to see if is web three enabled changes, right? And anytime we run Enable Web three is web three enabled becomes true.

10365
17:07:25.815 --> 17:07:31.860
So so now if we go to the front end, we do a little refresh, we see high false, high false.

10366
17:07:31.860 --> 17:07:47.706
Now why do we see this twice is web three enabled only changed once? Well, this is because of how use effect works, it will automatically run on load or right or the first time it does and then it'll run checking the value.

10367
17:07:47.706 --> 17:07:53.056
So we're basically seeing this run twice, it runs the first time we load it, and then it'll check the value and run again.

10368
17:07:53.056 --> 17:07:55.124
So we see go twice, even though it's really just once.

10369
17:07:55.124 --> 17:07:59.091
But if we go back here, sorry, let me just do a quick reload again.

10370
17:07:59.091 --> 17:08:09.386
We hit Connect, we now see Hi is now true, because it saw is what three enabled change to true because enabled web three made is what enabled return true.

10371
17:08:09.386 --> 17:08:11.287
And it ran this again, right.

10372
17:08:11.287 --> 17:08:13.252
So that's how that actually works.

10373
17:08:13.252 --> 17:08:16.405
And there's a couple of different ways to think about this.

10374
17:08:16.405 --> 17:08:18.829
Actually, we actually don't even need to give this an array.

10375
17:08:18.829 --> 17:08:22.830
And what happens if we don't give this an array? Well, let's refresh.

10376
17:08:22.830 --> 17:08:26.412
We'll hit Connect, and we'll see it's still ran a couple of times.

10377
17:08:26.412 --> 17:08:32.909
So if we don't give it array, no dependency array, it'll run any time something re renders.

10378
17:08:32.909 --> 17:08:34.882
And you need to be careful with this.

10379
17:08:34.882 --> 17:08:41.173
Because then you can get circular renders, if you have some use effect that changes some value.

10380
17:08:41.173 --> 17:08:47.282
And you have another use effect that re renders when that value changes while they're both just going to keep changing back and back and forth.

10381
17:08:47.282 --> 17:08:48.916
So no dependency array like this.

10382
17:08:48.916 --> 17:08:53.583
It will run anytime something re renders we'll give it a blank dependency array.

10383
17:08:53.583 --> 17:08:56.166
It'll just run once on load, just run one time.

10384
17:08:56.166 --> 17:09:00.029
So now like we have a blank dependency right in here, we reload.

10385
17:09:00.029 --> 17:09:02.171
Right? We see that it runs twice.

10386
17:09:02.171 --> 17:09:06.393
That's actually because we're basically re rendering once in the background.

10387
17:09:06.393 --> 17:09:09.960
So it really is just running Once but there's something else going on in the background.

10388
17:09:09.960 --> 17:09:11.201
So it looks like it's running twice.

10389
17:09:11.201 --> 17:09:19.879
Now if we just add is web three enabled, do a little refresh, it'll do the exact same thing, it'll run the same amount as if this was blank.

10390
17:09:19.879 --> 17:09:21.774
But when we connect, it'll add here.

10391
17:09:21.774 --> 17:09:28.068
If this was a blank array, when we refresh, we'll see kick out twice, which should be ones.

10392
17:09:28.068 --> 17:09:30.424
But like I said, there's something going on in the background.

10393
17:09:30.424 --> 17:09:31.462
If we hit connect.

10394
17:09:31.462 --> 17:09:38.289
Now, we don't see anything here, because the blank dependency array says, Hey, I'm only going to run one time on load.

10395
17:09:38.289 --> 17:09:44.807
Now, if there's our stuff in this array, like is web three enabled, it's going to run anytime something in this array changes, right.

10396
17:09:44.807 --> 17:09:51.569
So again, we'll refresh will connect, we see it ran again, after a hit Connect will refresh.

10397
17:09:51.569 --> 17:09:54.426
Hi, hi connected, ran one more time.

10398
17:09:54.426 --> 17:09:56.929
So so that's kind of the cheat sheet here.

10399
17:09:56.929 --> 17:10:07.855
If we give it no dependency array, it's going to run any time anything in this project re renders, if we give it a blank dependency array, it's just going to run one time, or like we saw, it ran twice.

10400
17:10:07.855 --> 17:10:10.458
But that's because there's something else we render in the background.

10401
17:10:10.458 --> 17:10:15.600
And if we give it dependencies in this array, it's going to run anytime something in this array changes.

10402
17:10:15.600 --> 17:10:30.499
And this is really helpful, because oftentimes, we're going to want our front ends to rerender, this use effect will say, oh, cool, some value changed, I'm going to run this function, and then I'm going to rerender, your front end.

10403
17:10:30.617 --> 17:10:36.038
And now we're going to use this use effect thing to make sure that when we refresh, it remembers that we're actually connected.

10404
17:10:36.038 --> 17:10:40.047
So how do we do that inside here, we are going to use this is web three enabled thing.

10405
17:10:40.047 --> 17:10:47.467
And the first thing that we want to just do is we want to say if is what three enabled, then we'll just return.

10406
17:10:47.467 --> 17:10:51.650
Because if we're already connected to web three, then we don't need to do anything.

10407
17:10:51.650 --> 17:11:00.522
Now, if we're not connected to web three, and we don't have an account, we'll want to go ahead and call Enable Web three, right want to automatically enable Web three.

10408
17:11:00.522 --> 17:11:07.392
So now if I go back, you'll see with just this code, I'm just always automatically calling Enable Web three.

10409
17:11:07.392 --> 17:11:08.988
But this can get really annoying.

10410
17:11:08.988 --> 17:11:13.260
Because if I disconnect, right, let's go disconnect everything.

10411
17:11:13.260 --> 17:11:23.424
Now refresh, it's going to always call Enable Web three, right, every time we refresh, it's going to automatically call enabled through without us even hitting the Connect button.

10412
17:11:23.424 --> 17:11:26.568
So that's no good to we want to actually see if we're connected.

10413
17:11:26.618 --> 17:11:41.635
So the way we do this, like I said, we want to use our local storage, again, application, or these little, this little thing here go to Application, we want our we want our application to remember that somebody hit this connect button, and they went and connected to us.

10414
17:11:41.635 --> 17:11:54.142
So what we're going to do is in our little onClick function down here, we're not just going to call await Enable Web three, we're also going to store a little remembrance here saying, Hey, we actually did connect recently.

10415
17:11:54.142 --> 17:12:06.674
So below this, we're going to run window, dot local storage, dot set item, connected, comma injected.

10416
17:12:06.674 --> 17:12:11.586
I'm actually going to comment this out for now, because my friend is just going to keep popping up like that.

10417
17:12:11.586 --> 17:12:26.821
So what this does is we're saying, okay, in our window, because again, if you go back to the window, you go to console, a type window, you're actually going to see this giant window thing here, right, which we showed you before, there's always this window object in here.

10418
17:12:26.821 --> 17:12:38.359
And we're going to do window dot local storage, which relates to if we go to this application section, this local storage section here, that set item connected to inject it.

10419
17:12:38.359 --> 17:12:53.325
So we're going to set a new key value in here, we're doing it like this because in the future, maybe you want to do you know connect it to Wallet connect or connected to Coinbase wallet or something, right, but we're just gonna say injected, meaning we're connected to that meta mask.

10420
17:12:53.325 --> 17:12:57.419
And in some versions of next, Jas next, Jas has a hard time knowing about this window variable.

10421
17:12:57.419 --> 17:13:06.369
So we can just do if type of window does not equal equal, undefined, then we're going to do this.

10422
17:13:06.369 --> 17:13:10.946
So we're just making sure that window doesn't equal undefined that there is a window.

10423
17:13:10.946 --> 17:13:28.333
So now if I go back to the front end, and I hit Connect, and we go ahead, and we connect here, we'll see now in our application, local storage, we'll see we've added this connected injected bit here, we're storing in the browser that we are indeed connected to this.

10424
17:13:28.333 --> 17:13:36.987
Now that we've added this into our browser, we can roll back up to our use effect here and say, Okay, if they're already connected, great, we'll be done.

10425
17:13:36.987 --> 17:13:40.241
But before we do anything, let's check to see if they have this here.

10426
17:13:40.241 --> 17:13:44.038
And if they already are connected, let's just run that connect bit.

10427
17:13:44.038 --> 17:13:53.306
So we'll say if type of window does not equal, undefined, right, because we want to check for that window object.

10428
17:13:53.306 --> 17:14:06.369
Again, we'll say if window dot local storage dot get item connected, connected, so if that connected key exists, then we'll just run Enable Web three.

10429
17:14:06.369 --> 17:14:13.832
So now We have some functionality in here, which even when we refresh, it will automatically run enable of three for us.

10430
17:14:13.832 --> 17:14:24.999
So now if I go ahead and refresh the front end, we don't have to press that connect button anymore, because it goes, Oh, I see that locally, we stored this connected key whenever you refresh.

10431
17:14:24.999 --> 17:14:28.573
Now, it checks for this first it sees it and then runs enabled web three.

10432
17:14:28.620 --> 17:14:34.170
Now on the other side, though, if we're in here, and now we disconnect, and then we refresh.

10433
17:14:34.170 --> 17:14:36.345
This will show up, which is really annoying.

10434
17:14:36.345 --> 17:14:39.471
And every time we refresh, it'll keep showing up, which we don't want.

10435
17:14:39.471 --> 17:14:45.812
We want it to be that when we disconnect, we tell it hey, we've we've gone ahead and disconnected here.

10436
17:14:45.812 --> 17:14:52.353
So back in our application, we can add another use effect to check to see if we've disconnected.

10437
17:14:52.353 --> 17:14:54.527
So let's create another use effect.

10438
17:14:54.527 --> 17:15:01.587
That's going to costly just look for us being connected, we'll say use effect, do a little arrow bracket thing here.

10439
17:15:01.587 --> 17:15:04.455
And we're going to do this anytime.

10440
17:15:04.620 --> 17:15:06.687
And oh my goodness, anytime I save, it's going to keep popping up.

10441
17:15:06.687 --> 17:15:08.777
So I'm just going to just going to comment that out for now.

10442
17:15:08.777 --> 17:15:14.794
So in here, we want to say okay, whatever, there's a rerender we want to run if any account has changed.

10443
17:15:14.794 --> 17:15:17.942
And Morales has some functionality for us to do this as well.

10444
17:15:17.942 --> 17:15:23.716
So from user morass, we're going to import more Alice, and then down here in our use effect.

10445
17:15:23.716 --> 17:15:28.048
Inside the little function, we're gonna say mirallas.

10446
17:15:28.048 --> 17:15:34.652
on account, changed of account, we're gonna do some stuff.

10447
17:15:34.652 --> 17:15:38.520
So on account changed, takes a function as an input parameter.

10448
17:15:38.520 --> 17:15:44.447
So we'll say console dot log, account, change to account.

10449
17:15:44.447 --> 17:15:49.792
And what we can do is we can check to see if this account is not.

10450
17:15:49.792 --> 17:15:57.588
And we can say if account equals equals no, then if the account is null, we can assume they've disconnected.

10451
17:15:57.588 --> 17:16:08.037
So we can say window dot local storage, dot remove item, connected, we'll also run a deactivate web three function.

10452
17:16:08.037 --> 17:16:19.001
So from Ross, deactivate, web three will also run, deactivate web three, which is going to set is web three enabled to false.

10453
17:16:19.001 --> 17:16:25.530
So we're going to disconnect the web three, and then we're going to say console dot log.

10454
17:16:25.621 --> 17:16:28.161
No count found.

10455
17:16:28.161 --> 17:16:29.242
So let's try this out.

10456
17:16:29.242 --> 17:16:29.438
Now.

10457
17:16:29.438 --> 17:16:32.741
Let's go back to our front end, we'll do a little refresh here.

10458
17:16:32.741 --> 17:16:34.692
So right now it says we're connected.

10459
17:16:34.692 --> 17:16:39.859
Even though in my meta mask, we're not connected, right? And to start from scratch here, you can go ahead and disconnect it.

10460
17:16:39.859 --> 17:16:43.489
But but my browser says, Hey, we're connected, right? So now we'll connect.

10461
17:16:43.489 --> 17:16:51.310
And we'll actually be connected right, next connect, and it and it just overrode connected, you know, with inject, let's, let's make this injected.

10462
17:16:51.310 --> 17:16:57.871
And then we'll remove Yep, okay, injected, we'll refresh, like, connect, and now it says injected.

10463
17:16:57.871 --> 17:16:58.386
Okay, cool.

10464
17:16:58.386 --> 17:17:00.496
So now we're connected here.

10465
17:17:00.496 --> 17:17:06.906
If in here, if I just switch accounts, right, let's go to Account three, I'll connect.

10466
17:17:06.906 --> 17:17:16.293
If we go back to our console real quick, we'll say account change to blah, blah, blah, I can change back, right, we'll go change account change to blah, blah, blah.

10467
17:17:16.293 --> 17:17:19.417
Now, if we go back to our application, go in here.

10468
17:17:19.417 --> 17:17:20.823
And we disconnect.

10469
17:17:20.823 --> 17:17:24.621
Now let's disconnect both of these disconnect.

10470
17:17:24.621 --> 17:17:25.871
And disconnect.

10471
17:17:25.871 --> 17:17:29.653
We'll see it's now been removed from local storage.

10472
17:17:29.653 --> 17:17:37.147
And if we go to our console, it'll say, no account, change the No, no account found and removed it.

10473
17:17:37.147 --> 17:17:41.621
Now if I hit refresh, nothing happens here, I can go ahead and connect.

10474
17:17:41.621 --> 17:17:44.454
Right next connect, I can refresh.

10475
17:17:44.622 --> 17:17:47.081
Oops, I need to go back in here and re enable this.

10476
17:17:47.622 --> 17:17:49.392
let's add this back in here.

10477
17:17:49.392 --> 17:17:50.900
But now it can refresh.

10478
17:17:51.622 --> 17:17:53.638
ahead and disconnect here.

10479
17:17:53.638 --> 17:17:54.767
Let's connect.

10480
17:17:56.622 --> 17:18:03.168
console, we can connect thing will pop up next connect, I can refresh.

10481
17:18:03.168 --> 17:18:12.543
It stays connected for me, I can switch accounts, I can go ahead and here, I can switch accounts, I can even disconnect.

10482
17:18:12.622 --> 17:18:15.574
And it will automatically update for me, which is what we want.

10483
17:18:15.622 --> 17:18:24.537
So now we've essentially made a way more robust connect button, where it goes back and forth with when we're connected now.

10484
17:18:24.622 --> 17:18:34.372
Now one more thing that we might want to do, or application is when we hit Connect, we want to maybe disable this button, right? We don't want it to allow it to be able to be pressed.

10485
17:18:34.372 --> 17:18:43.131
So I'm gonna hit Cancel, we're just gonna add one more bit of functionality here, we're going to add this is web three enable loading.

10486
17:18:43.131 --> 17:18:47.740
And what this does is it just checks to see if Metamask has popped up.

10487
17:18:47.740 --> 17:18:53.331
And so what our button after the on click section, we can add disabled.

10488
17:18:53.331 --> 17:18:58.571
Equals is web three enable loading, so it'll be disabled if we're loading here.

10489
17:18:58.622 --> 17:19:01.888
So let's go ahead and we'll disconnect disconnect.

10490
17:19:02.622 --> 17:19:05.186
hit Connect, and you'll see the button can be clicked.

10491
17:19:05.622 --> 17:19:07.622
just makes it a little bit nice.

10492
17:19:09.622 --> 17:19:17.571
bada boom, awesome, we have just made a way more robust front end than what we had before this connect button is super slick.

10493
17:19:17.622 --> 17:19:19.300
And it allows us to kind of flip back and forth.

10494
17:19:19.622 --> 17:19:25.732
application is incredibly powerful and knows how to handle all these different changes.

10495
17:19:25.732 --> 17:19:42.442
Now that we've learned how to do it the manual way, let me give you the Chiti way, in our components, we're gonna create a new file header dot j s, and what we're going to do is we're going to install this web three UI kit, it's a front end kit, and it has a whole bunch of these components already built for us.

10496
17:19:42.442 --> 17:19:47.823
So we can build like a header component and a connect button component just by using this.

10497
17:19:47.823 --> 17:19:52.148
So to install, install it, we're gonna come back here, we're gonna stop our front end.

10498
17:19:52.148 --> 17:19:56.559
And we're just going to run yarn, add web three UI kit, like that.

10499
17:19:56.559 --> 17:20:03.973
And again, we don't want this to be a dev dependency, because it is going to be a part of our website, and then we'll do in our header.

10500
17:20:03.973 --> 17:20:10.477
js, we'll do import connect button from web three UI kit.

10501
17:20:10.477 --> 17:20:15.956
And then we'll do export default function header.

10502
17:20:15.956 --> 17:20:20.671
And then all we'll do is return do like a div.

10503
17:20:20.671 --> 17:20:24.461
And then inside this div, we'll do next button.

10504
17:20:24.623 --> 17:20:28.023
With a little backslash here, we aren't going to need this for this project.

10505
17:20:28.023 --> 17:20:31.558
But if we want to be super explicit, we'll say Morales off equals false.

10506
17:20:31.558 --> 17:20:38.311
Just again, to reiterate, hey, we're not trying to connect to a server here just to make that super explicit.

10507
17:20:38.311 --> 17:20:43.590
But this connect button does everything, this manual header thing that we just created, does.

10508
17:20:43.590 --> 17:20:45.131
So back in our index.

10509
17:20:45.131 --> 17:20:56.067
js, we can comment or delete this line will do import header from dot dot slash components slash header.

10510
17:20:56.067 --> 17:21:00.803
And then instead of manual header, we'll just do header.

10511
17:21:00.803 --> 17:21:09.816
We start our app back up with yarn dev again, we go back to the page, we do a little refresh here, we now see we have this connect Wallet button.

10512
17:21:09.816 --> 17:21:11.081
And it's even looks a lot nicer.

10513
17:21:11.081 --> 17:21:14.887
It's got some nice styling to it as well, we can hit Connect wallet.

10514
17:21:14.887 --> 17:21:19.899
And it'll give us this little ngModel asking us which wallet we want to connect to.

10515
17:21:19.899 --> 17:21:35.385
So asking us which wall we want to connect to is kind of similar in our manual header to this or set item connected, injected, right or wallet connect, it would do connected wallet Connect for trust wallet, it would it would set item as connected wallet connect, etc.

10516
17:21:35.385 --> 17:21:38.242
So it allows us to connect in different ways.

10517
17:21:38.242 --> 17:21:45.899
And we if we hit Metamask, we go ahead and connect like so even had some nice styling here where it gives us our wallet address here.

10518
17:21:45.899 --> 17:21:49.209
But it also gives us our wallet balance as well.

10519
17:21:49.209 --> 17:21:52.804
And again, if we go ahead and disconnect, we'll see it automatically disconnect.

10520
17:21:52.804 --> 17:21:55.481
We connect like so we can reconnect like so boom, boom.

10521
17:21:55.481 --> 17:21:59.382
If we switch accounts, it's smart enough to know that we're switching accounts.

10522
17:21:59.382 --> 17:22:01.364
So I know I showed you kind of the hard way.

10523
17:22:01.364 --> 17:22:03.442
But I wanted to show you kind of what's going on.

10524
17:22:03.442 --> 17:22:09.089
It's setting this local storage in the background so that it knows which where it's actually connected.

10525
17:22:09.089 --> 17:22:11.827
But for headers moving forward, this is all you need.

10526
17:22:11.827 --> 17:22:14.521
And your life will be drastically drastically easier.

10527
17:22:14.624 --> 17:22:21.957
And let's just add a centralized lottery or decentralized raffle or whatever you want to our header as well.

10528
17:22:21.957 --> 17:22:26.558
So it says decentralized lottery, you know the button Hello.

10529
17:22:26.558 --> 17:22:34.474
Now that we have that, what else do we need? Well, well, the main thing that this app needs to do is just have a big button that says enter the lottery.

10530
17:22:34.474 --> 17:22:38.591
And then ideally, you know, show how many people are in the lottery and then the recent winner as well.

10531
17:22:38.624 --> 17:22:42.024
So let's go ahead, we'll create a new component called lottery entrance.

10532
17:22:42.024 --> 17:22:49.543
And we'll grab that component similar to like what we did with our header, we'll drop this component right here.

10533
17:22:49.625 --> 17:22:51.038
And then our app will pretty much be done.

10534
17:22:51.625 --> 17:23:12.142
this lottery entrance component, lottery entrance, that Jas, right and again, in the reason we're putting these in components, we could 100% Stick it all, you know all our code in here to make it more modular so that we in the future, if we want to have more pages or do other stuff, I'm going to zoom out a little bit just so that we can see all of our code a little bit easier.

10535
17:23:12.142 --> 17:23:13.590
This is our whole index j s.

10536
17:23:13.590 --> 17:23:15.053
This is our whole header.

10537
17:23:15.053 --> 17:23:41.815
Let's create a new lottery entrance app just for the boilerplate code here we're going to export default lottery entrance, excuse me, export default function, lottery entrance, and this is just going to be you know, another component where we're going to return some that JSX HTML stuff, right? So we're gonna do div and do like hi from lottery entrance, Excel.

10538
17:23:41.815 --> 17:23:46.160
And now that we do that, we can go back to our index.

10539
17:23:46.160 --> 17:23:46.374
js.

10540
17:23:46.374 --> 17:23:53.198
We can do import lottery entrance from dot dot slash components.

10541
17:23:53.198 --> 17:23:59.800
Slash lottery entrance, will stick it right underneath the header like that.

10542
17:23:59.800 --> 17:24:08.291
And if we go back to our website, we see high from lottery entrance so our lottery entrance is going to be right underneath the header would Here's what we want.

10543
17:24:08.291 --> 17:24:10.247
And then we'll delete this line that says, Hello.

10544
17:24:10.247 --> 17:24:21.969
So lottery entrance, what is the what is the first thing that we really need to do in here? Well, we're going to want to have a function to call the lottery to enter the lottery.

10545
17:24:21.969 --> 17:24:23.297
Let's go ahead and do this.

10546
17:24:23.297 --> 17:24:30.986
Now let's go back to how we did this with HTML fund me recall that old fun function like this, but doing it like this won't rerender.

10547
17:24:30.986 --> 17:24:41.047
And there's a whole lot of other functionality that doing it like this won't give us so we're going to use Morales to actually call some of these functions, because mirallas has in React mirallas.

10548
17:24:41.047 --> 17:24:45.001
Again, they have hooks for us to do pretty much anything we want to do.

10549
17:24:45.001 --> 17:24:48.314
And one of these hooks is called use web three contract.

10550
17:24:48.314 --> 17:24:59.564
And what this does is it gives us a hook that will give us the data returned from a function called an error returned, a little function that we can use to call any function.

10551
17:24:59.626 --> 17:25:03.077
And then we also have these really helpful is fetching in is loading.

10552
17:25:03.077 --> 17:25:12.371
So if we want everyone to have our UI or our website, do something while it's fetching or while it's loading the transaction, we can use these two variables to do that.

10553
17:25:12.371 --> 17:25:23.371
And then all we need to do is we just need to pass it the contract information, which similar to ethers is going to be the ABI contract address, we'll pass the function name, and then any parameters for that function.

10554
17:25:23.371 --> 17:25:28.559
So we're going to use this syntax here to make that transaction to the blockchain.

10555
17:25:28.626 --> 17:25:29.483
And to call these functions.

10556
17:25:30.626 --> 17:25:37.263
going to import us web three contract from react mirallas.

10557
17:25:37.263 --> 17:25:43.400
And inside our function, but before I return, of course, we're going to say const.

10558
17:25:43.400 --> 17:25:46.376
And then we'll do kind of exactly what we see in here.

10559
17:25:46.376 --> 17:25:55.359
For now, let's just get the function, let's just get this run contract function, because this is going to be the function that we can call to actually enter the lottery.

10560
17:25:55.359 --> 17:26:00.576
So we'll say const, run contract function, and we're actually going to call this enter raffle.

10561
17:26:00.626 --> 17:26:18.159
And we'll say equals, use web three contract, and we need to pass the ABI, we're gonna need to pass the contract address, we're gonna need to give it the function name, we'll need to give it the params, which actually we do know it's going to be blank.

10562
17:26:18.159 --> 17:26:20.529
But then finally, we will need the message value.

10563
17:26:20.627 --> 17:26:26.950
Because if we remember back into raffle doesn't take any parameters, all it takes is this message dot value bit.

10564
17:26:26.950 --> 17:26:30.488
So that's all we're going to need to pass.

10565
17:26:30.488 --> 17:26:34.738
So how do we get all this stuff, and I'm going to leave this in here.

10566
17:26:34.738 --> 17:26:38.801
But we're going to comment it out for now, because this is what we need to do.

10567
17:26:38.801 --> 17:26:41.890
But we need to get all of this stuff into our code here.

10568
17:26:41.890 --> 17:26:51.053
So how do we actually get all that stuff? Well, ABI is easy, right? Abi isn't going to change at all, no matter what network or on ABI is always going to stay the same.

10569
17:26:51.053 --> 17:27:00.246
Now if you've already deployed your smart contracts, and you know exactly what address it is, because you've deployed to a main net, or you've deployed to a test net, all this stuff isn't really going to change.

10570
17:27:00.246 --> 17:27:03.272
And we can just hard code it all right into here.

10571
17:27:03.272 --> 17:27:06.454
Or we can do what a lot of people do is they'll create a constants folder.

10572
17:27:06.454 --> 17:27:14.341
And in here, they'll add like an API dot JSON, maybe they'll add a contract addresses dot JSON.

10573
17:27:14.341 --> 17:27:27.679
And then they'll add maybe like an index dot j s or something, we're gonna build our application in a way we can actually test locally using our own Hard Hat Network, and then compare it to what it looks like on the actual test net as well.

10574
17:27:27.679 --> 17:27:29.427
So we're going to make it network agnostic.

10575
17:27:29.427 --> 17:27:33.198
So the front end works exactly the same no matter what network that we're on.

10576
17:27:33.198 --> 17:27:45.808
And we can go back, download a directory back into our CD, hard hat smart contract lottery Free Code Camp, and spin up our node here, right with hh node or yarn hard hat node.

10577
17:27:45.808 --> 17:27:49.818
And we'll use this as the blockchain that we're going to connect to.

10578
17:27:49.818 --> 17:27:55.289
The thing is, if I go back here, and I'm building the front end, and I go, ah, like this would be better if we did X, Y, or Z.

10579
17:27:55.289 --> 17:28:03.447
And maybe I changed the name of some functions, you know, blah, blah, blah, something else, I want that change to be reflected on my front end.

10580
17:28:03.447 --> 17:28:06.305
And I want to be able to code my front end as such.

10581
17:28:06.305 --> 17:28:12.981
So since we are the only developer right now, we kind of have the ability of where we both know, the back end code and the front end code.

10582
17:28:12.981 --> 17:28:19.775
So something that I like to do to make my life a little bit easier is I like to create an update front end deploy script.

10583
17:28:19.775 --> 17:28:33.940
So after we deploy stuff, we run a little script that will create this constants folder for us with a whole bunch of stuff, right? It'll give an ABI, it'll give contract addresses and anything else we might need in our front end from our back end.

10584
17:28:33.940 --> 17:28:40.351
So what I like to do is I like to come back to my original code and an update this for a new script.

10585
17:28:40.351 --> 17:28:51.503
So I'll come in here in this deploy script, I'll create a new file, and I'll call it oh two or even like 9999, up, date, front, and dot Jas.

10586
17:28:51.503 --> 17:28:58.471
And the reason I do 99, obviously, is because we want this to be always the last script in our deploy folder.

10587
17:28:58.471 --> 17:29:01.136
And then we can just write a little script that's connected.

10588
17:29:01.136 --> 17:29:10.817
We just write a little script that's connected to our front end here so that whenever we deploy contracts, no matter what chain, we can update that constants folder on our front end.

10589
17:29:10.817 --> 17:29:18.144
So let's go ahead and create that script right now we'll do module dot exports, equals async function.

10590
17:29:18.144 --> 17:29:24.939
And we'll add all our stuff in here, we don't really need to deploy any contracts, because we're just updating the front end.

10591
17:29:24.939 --> 17:29:26.962
So we can just leave the parameters of this one blank.

10592
17:29:26.962 --> 17:29:37.179
And the other thing I like to do, because sometimes I don't care about the front end, what I'll do is I'll only update the front end if we've specified a dot env variable.

10593
17:29:37.179 --> 17:29:42.809
So I'll create a dot env variable called up date, front end.

10594
17:29:42.809 --> 17:29:45.006
And then I'll set this to true.

10595
17:29:45.006 --> 17:29:52.343
And now in our script here, we can say if process dot E and V dot update, front end.

10596
17:29:52.343 --> 17:29:57.517
And we can just say like console dot log, updating front end.

10597
17:29:57.517 --> 17:30:07.200
And now back in here, right, if a mat if I'm in the correct directory in here, if our own hard hit Deploy, you know, get this little updating front end.

10598
17:30:07.200 --> 17:30:08.596
And now we can update front end.

10599
17:30:08.596 --> 17:30:09.321
So let's do it.

10600
17:30:09.321 --> 17:30:15.190
So I'm actually going to create one function called Update contract addresses.

10601
17:30:15.190 --> 17:30:25.488
And this is going to be our function that we're going to use to update contract addresses, then I'm going to make one called Update API, where we just update the API's and the front end so so we're going to call this update contract addresses.

10602
17:30:25.488 --> 17:30:31.399
So I'm going to create a new function async function, update contract addresses.

10603
17:30:31.399 --> 17:30:37.488
And first, we're going to get that raffle contract since we're going to need to get its address.

10604
17:30:37.488 --> 17:30:39.661
So we're gonna say const, raffle equals await.

10605
17:30:39.661 --> 17:30:50.547
And we're gonna do the same thing we've been doing ethers dot get contract, raffle, and then my VS code auto imported, it doesn't const ethers equals require Hardhead, like so.

10606
17:30:50.547 --> 17:30:51.891
So we have raffle in here.

10607
17:30:51.891 --> 17:31:20.968
And we're gonna want to pass this raffle address to our front end, since this is going to be a variable that we might use a lot of places, we can just add it like const, front end location, addresses file, equals, and we're going to give it the relative path to where we are now, which is going to be you know, if we see the download directory to next year's smart contract lottery, FCC, I can even just copy this, paste that in here.

10608
17:31:20.968 --> 17:31:26.576
And then it's in the constants folder, and it's going to be contract addresses dot JSON.

10609
17:31:26.576 --> 17:31:30.926
And let's get the ABI file, we'll say const.

10610
17:31:30.926 --> 17:31:37.613
Front and a bi file is going to equal and this is going to be nearly the same thing.

10611
17:31:37.613 --> 17:31:39.630
So we can just copy paste that.

10612
17:31:39.630 --> 17:31:43.330
And then we'll do slash API dot JSON.

10613
17:31:43.330 --> 17:31:57.106
And now in our update contract addresses function, we can say const, current addresses, equals and we can read again, in our front end, we can read from this file.

10614
17:31:57.106 --> 17:31:59.480
So I'll usually start out with just two brackets.

10615
17:31:59.480 --> 17:32:02.328
So that's like JSON compatible in both of these files.

10616
17:32:02.328 --> 17:32:11.531
And so to read it, we're gonna say JSON dot parse, FS dot read file sync, we're gonna have to import, say const.

10617
17:32:11.630 --> 17:32:28.148
FS equals require, I know we've used Fs extra in the past, but this one, we're just gonna use Fs, which is going to be our front and addresses file, we're going to read it in with UTF eight encoding.

10618
17:32:28.148 --> 17:32:30.112
So now this is going to be our current addresses.

10619
17:32:30.112 --> 17:32:34.430
And we're going to update the list of current addresses with some new addresses.

10620
17:32:34.430 --> 17:32:50.788
Because our contract addresses we want this to be chain agnostic, we would do something like for you know, and then the addresses on rink B, we could do 31337, and then the addresses on our local host, right, we want to be able to keep track of all the different addresses across all the different chains.

10621
17:32:50.788 --> 17:32:58.876
So back in our function here, then we'll say if if network, dot config dot chain id.

10622
17:32:58.876 --> 17:33:09.860
to string in contract addresses that were config ideas in there, then we're just gonna go ahead and add this new contract address in there.

10623
17:33:09.860 --> 17:33:14.320
But before we add this new address in there, let's just check to make sure it's not are already in there.

10624
17:33:14.320 --> 17:33:21.171
So we're just gonna say if contract addresses of network dot config dot chain id.

10625
17:33:21.171 --> 17:33:29.420
to string, this is so long, I don't want to keep writing that I'm gonna say const chain ID equals network, config that chain id.

10626
17:33:29.420 --> 17:33:33.648
to string, and we're just gonna use chain ID.

10627
17:33:33.648 --> 17:33:42.837
If chain ID and contract address then if we don't already have that includes raffle dot address.

10628
17:33:42.837 --> 17:34:08.122
We're gonna go ahead and add this new address and then if the chain ID doesn't even exist, we're gonna go ahead and do contract addresses current addresses, equals or assuming current addresses of chain ID equals and then we'll just create a new array, raffled that out address.

10629
17:34:08.122 --> 17:34:13.104
So we're saying if the chain ID doesn't exist in current addresses, we're just going to add this new array in there.

10630
17:34:13.104 --> 17:34:23.596
And then finally, now that we've updated its object, we're gonna write it back to this file, we'll say Fs dot write, file sync, front and addresses file.

10631
17:34:23.596 --> 17:34:26.854
And then we're gonna do JSON dot string of five.

10632
17:34:26.854 --> 17:34:31.782
So we're going to Stringify this JSON object, so we're just gonna go ahead and write it back.

10633
17:34:31.782 --> 17:34:39.293
And then bottom module that exports that tags equals all and then front end.

10634
17:34:39.293 --> 17:34:39.763
I cool.

10635
17:34:39.763 --> 17:34:43.737
So we have a function to update the contract addresses, but we also need the ABI.

10636
17:34:43.737 --> 17:34:50.822
So we're gonna do date API, and we're gonna create another function async function, update API.

10637
17:34:50.822 --> 17:35:06.438
And in here, we're gonna do the exact same thing on raffle equals await ethers that contract, raffle FX dot right file, sync, front and abi.

10638
17:35:06.438 --> 17:35:11.489
It's just going to copy paste it front end, AVI file.

10639
17:35:11.489 --> 17:35:28.032
And then to pass just the ABI, we can actually get it directly from this raffle object, we can actually just do raffle dot interface that format ethers dot utils, dot format types, dot JSON.

10640
17:35:28.032 --> 17:35:36.563
If you look in the ethers, Docs, ethers has this contract dot interface thing which returns an interface which is different from a solidity interface.

10641
17:35:36.563 --> 17:35:40.360
But it allows us basically just to get the API with this one line of code.

10642
17:35:40.360 --> 17:35:51.287
So in our back end code here, now if you run h h deploy or H H node, we should automatically update our contract addresses in our API dot JSON.

10643
17:35:51.287 --> 17:35:53.336
So let's go and try this.

10644
17:35:53.336 --> 17:35:55.139
So we'll run h h node.

10645
17:35:55.139 --> 17:36:00.763
So we'll start a node, right in this terminal over here, we'll flip back to the front end.

10646
17:36:00.763 --> 17:36:07.099
And if we open ABI to JSON, we do indeed, now see, we have the raffle API in this file.

10647
17:36:07.099 --> 17:36:13.570
And if we go to contract addresses, we see on network 31337, here's our first address, right.

10648
17:36:13.570 --> 17:36:20.568
And if we deploy to different chains, this will get populated with different network IDs, and then a list of addresses associated with them.

10649
17:36:20.568 --> 17:36:26.445
So it helps make our front ends a lot easier to maintain, and bounce around and kind of test and work with.

10650
17:36:26.445 --> 17:36:35.433
Now that we've done all this, we can actually close our hardhat smart contract lottery Free Code Camp, the hard hat project for this, and we're just going to have all of our terminals be in here.

10651
17:36:35.433 --> 17:36:46.747
So what we're gonna do is we're gonna go down and directory CD dot dot, and we're going to cd into Oh, sorry, we're actually we're already in their CDs, hard hat, smart contract, lottery Free Code Camp.

10652
17:36:46.747 --> 17:36:50.934
And then in this one, we're going to run hh node or yarn hardhat node.

10653
17:36:50.934 --> 17:36:57.823
Now we'll have a local blockchain running so we can test everything that we're doing in the front end, actually, I'm gonna move this up one.

10654
17:36:57.823 --> 17:37:04.720
So now in our first area, here, we have our front end code running, then we have our blockchain running.

10655
17:37:04.720 --> 17:37:07.836
And then in this one, we're just going to add, you know, whatever we want to add.

10656
17:37:07.836 --> 17:37:11.508
Now, we can actually go ahead and hit this little X button here to close the panel.

10657
17:37:11.508 --> 17:37:16.775
So that's just hiding the panel, these are all still out, they only get trashed when you actually hit the little trashcan.

10658
17:37:16.775 --> 17:37:18.370
So we're just going to close the panel.

10659
17:37:18.370 --> 17:37:21.383
But all those terminals are still running, I promise back.

10660
17:37:21.383 --> 17:37:24.508
So where were we? Okay, back to our function here.

10661
17:37:24.633 --> 17:37:30.039
So we just automated the process of updating our API's and then updating our contracts as well.

10662
17:37:30.039 --> 17:37:32.075
And now we can import these into our files.

10663
17:37:32.075 --> 17:37:45.575
Now we can import them one at a time, it'd be like import API, from dot dot slash constants, slash API, or we could do something a little bit clever is we could export these in the same file.

10664
17:37:45.575 --> 17:37:47.961
So if we create a new file, a new index.

10665
17:37:47.961 --> 17:37:52.500
js, in here, we can import them and then export them in this one file.

10666
17:37:52.500 --> 17:38:06.734
We can say const, contract editor says equals require dot slash contract editor dot JSON, and then const API equals require dot slash API dot JSON.

10667
17:38:06.734 --> 17:38:13.834
And then we'll do module dot exports equals API and contract addresses.

10668
17:38:13.834 --> 17:38:20.441
So now once we export them like this back in our lottery entrance, we can import them just in one line.

10669
17:38:20.441 --> 17:38:28.817
So we'll say import API comma contract addresses from dot dot slash constants.

10670
17:38:28.817 --> 17:38:38.602
So we can just specify the folder instead of each individual files, because we have this index dot j s here, which basically represents this whole folder.

10671
17:38:38.602 --> 17:38:42.900
Back in here, what do we have now? Let's uncomment this abi.

10672
17:38:42.900 --> 17:38:43.700
Okay, great.

10673
17:38:43.700 --> 17:38:50.650
We have the ABI we're importing it from our constants, folder, contract addresses, we have our contract addresses.

10674
17:38:50.650 --> 17:38:55.896
And we're going to need to specify the network ID in just a second here.

10675
17:38:55.896 --> 17:39:00.117
We have the function name here, which is going to be what enter the raffle.

10676
17:39:00.117 --> 17:39:01.729
There are no params.

10677
17:39:01.729 --> 17:39:17.795
So all we need to do so how do we get both the chain ID and then Also the message dot value will change, it is something that we can get really easily with Morales, let's comment this whole section out one more time, just so I can show you something we can do import.

10678
17:39:17.795 --> 17:39:25.518
Once again, we're going to get that use Morales book from react Morales.

10679
17:39:25.635 --> 17:39:29.532
And what we can do is we can say const.

10680
17:39:29.635 --> 17:39:32.809
Chain ID equals use ralis.

10681
17:39:37.635 --> 17:39:47.005
what chain we're on is because back in our header component, the header actually passes up all the information about the Metamask to the Morales provider.

10682
17:39:47.005 --> 17:39:56.560
And then the Morales provider passes it down to all the components inside those Morales provided tags concentrated equals use Morales.

10683
17:39:56.635 --> 17:40:01.477
And I'm just gonna do a little console log chain ID because I want to show you what it looks like.

10684
17:40:01.477 --> 17:40:22.687
So if we do a little refresh, and we're in the console here, we can ignore some of these warnings here, but we see the chain ID is actually 0x Five, well, because I'm on the rink B chain or the Grilley chain excuse me, if I switch back to hard hat localhost, which you should know how to do from a SEMA fun we bet if you don't have hard hat localhost and your Metamask go back to that HTML font we bit follow that along.

10685
17:40:22.687 --> 17:40:23.318
Okay, great.

10686
17:40:23.318 --> 17:40:26.169
Now it's going to print this Oh x bla bla bla bla bla.

10687
17:40:26.169 --> 17:40:28.603
So that might be a little bit confusing.

10688
17:40:28.603 --> 17:40:31.409
But this is the hex version of our chain ID.

10689
17:40:31.409 --> 17:40:31.796
Right.

10690
17:40:31.796 --> 17:40:34.183
So let's switch to Etherium main net.

10691
17:40:34.183 --> 17:40:38.801
Now we pronounce Oh x one, right? Oh, x one is the hex version of the number one.

10692
17:40:38.801 --> 17:40:43.028
So chain ID gives us the hex addition of the chain ID.

10693
17:40:43.028 --> 17:40:45.920
So I don't want the hex addition, I want the actual number.

10694
17:40:45.920 --> 17:40:51.860
So what I'm going to do is I'm going to say Okay, chain ID, your name is actually going to be chain ID hex.

10695
17:40:51.860 --> 17:40:55.206
And we can do console dot log chain ID hex, but I want the number.

10696
17:40:55.206 --> 17:41:03.235
So what we can do is parse a built in JavaScript parse int, CIN ID hex like that.

10697
17:41:03.235 --> 17:41:06.502
Now if I go back, we'll do a little refresh here.

10698
17:41:06.636 --> 17:41:09.120
Scroll away from the warning, we can see the one here.

10699
17:41:09.636 --> 17:41:11.974
switch to hard hat, localhost.

10700
17:41:14.636 --> 17:41:19.761
So use Morales chain ID returns the hex we parse it with Parson to get the actual number.

10701
17:41:19.761 --> 17:41:20.323
Okay, great.

10702
17:41:20.323 --> 17:41:22.226
So we can stick the chain ID into here.

10703
17:41:22.226 --> 17:41:30.861
Now this raffle address is something that we're actually going to use a lot, we might as well have it be at the top of our code here, we aren't going to be changing the raffle address.

10704
17:41:30.861 --> 17:41:32.054
So we don't need to put it in a hook.

10705
17:41:32.054 --> 17:41:35.586
We are going to technically be changing the address when we change networks.

10706
17:41:35.636 --> 17:41:39.898
But our header app takes care of re rendering and dealing with all that.

10707
17:41:39.898 --> 17:41:41.373
So we can just make this a constant variable.

10708
17:41:41.373 --> 17:41:52.055
So we can say const, raffle address equals, first let's check the chain ID hex and if there's a chain ID hex and if there's not a chain ID hex we're gonna do something else.

10709
17:41:52.055 --> 17:41:56.227
Excuse me, we're gonna say chain ID hex in contract addresses.

10710
17:41:56.227 --> 17:41:58.202
And actually, there's never gonna be a chain ID hex.

10711
17:41:58.202 --> 17:42:06.836
So we'll do const chain ID equals Gen ID hex parsed, Parsons, chinati hex, and you might be thinking, hey, this, these are both the same name.

10712
17:42:06.836 --> 17:42:18.175
Well, what we're doing up here in use Morales is we're saying hey, pull out the chin ID object, and then rename it to chain ID hex and down here, we're saying, Hey, we're going to create a new variable called Chain ID.

10713
17:42:18.175 --> 17:42:23.019
So we'll say contract addresses of chain ID at zero.

10714
17:42:23.019 --> 17:42:30.567
So in here, we're saying this network ID and this address, otherwise, we'll just say no.

10715
17:42:30.636 --> 17:42:32.198
Okay, we're getting there.

10716
17:42:34.636 --> 17:42:36.921
raffle address, and we can just stick it in here.

10717
17:42:37.636 --> 17:42:39.540
is the message dot value.

10718
17:42:42.636 --> 17:42:45.127
actually set that fee dynamically.

10719
17:42:46.637 --> 17:42:50.110
we do entrance fee equals entrance fee, which is the parameter in the constructor.

10720
17:42:50.110 --> 17:42:52.687
So we want to call this get entrance fee function.

10721
17:42:52.687 --> 17:42:55.187
This is one of the ways we can send a transaction.

10722
17:42:55.187 --> 17:43:05.390
And we can also send functions, one of the ways that we're going to do it right when our lottery entrance loads, we're going to run a function to read that entrance fee value.

10723
17:43:05.390 --> 17:43:16.119
So how do we do that? Well, we can use one of our hooks again, right use effect use effect can run right when something changes, we're only going to want to try to get that raffle entrance fee if web three is enabled.

10724
17:43:16.119 --> 17:43:22.096
So what we can do is back up in here and use Morales will pull in that is web three enabled.

10725
17:43:22.096 --> 17:43:32.524
And we'll have our use effect in our function, we'll just say if this is web three enabled, then we'll try to read.

10726
17:43:32.637 --> 17:43:36.572
So we can go ahead and use this use web three, contract Wagan.

10727
17:43:36.637 --> 17:43:37.981
Let's go ahead and just copy paste this.

10728
17:43:38.637 --> 17:43:40.162
same setup here.

10729
17:43:44.637 --> 17:43:47.348
we're going to be doing get entrance fee.

10730
17:43:48.637 --> 17:43:49.669
get entrance fee.

10731
17:43:52.637 --> 17:43:52.737
it.

10732
17:43:55.637 --> 17:43:59.565
entrance fee params nothing message that value, nothing.

10733
17:43:59.637 --> 17:44:02.391
We're going to be calling this get entrance fee function.

10734
17:44:02.637 --> 17:44:06.837
now I finally show you how to actually call one of these in our contracts here.

10735
17:44:06.837 --> 17:44:12.121
Use web three contract, download our use effect, we're actually going to call get entrance fee.

10736
17:44:12.121 --> 17:44:27.558
Now if we just call get entrance fee like this, and we say like, you know, const something equals get entrance fee and then console dot log something, what do you think's going to happen? And oops, I need to import, I need to import use effect from react.

10737
17:44:27.638 --> 17:44:28.775
There we go.

10738
17:44:33.638 --> 17:44:37.138
something won't get entrance fee is going to be an async function.

10739
17:44:37.138 --> 17:44:44.304
Once again, we need to wait we would need to do a wait get into T, right? There's an issue we can't call await in our use effect.

10740
17:44:44.304 --> 17:44:50.342
So what can we do? Well, we can actually make an async function, call it update UI.

10741
17:44:50.342 --> 17:44:55.388
And then we can stick this inside of the async function here.

10742
17:44:55.388 --> 17:44:59.064
And we can call update UI right outside of it like this.

10743
17:44:59.064 --> 17:45:01.944
So now we go back to our front end, we do a little refresh.

10744
17:45:01.944 --> 17:45:04.104
And if we scroll up, we still see nothing.

10745
17:45:04.104 --> 17:45:07.037
Well, is web three enabled actually changes.

10746
17:45:07.037 --> 17:45:11.976
So the first time that this runs, is web three enabled probably is false.

10747
17:45:11.976 --> 17:45:17.824
But when it turns to true, we want to we want to run this section in our little dependency array.

10748
17:45:17.824 --> 17:45:35.041
We're going to add this in here, right? And the reason that it's false to start with is because of exactly what we showed in that manual header, right? What does it do? Well, first, we check to see after we do a refresh, if window dot local storage get item is connected, then we call Enable Web three, which will make this enabled.

10749
17:45:35.041 --> 17:45:41.734
So in our lottery entrance, is what they're enabled starts off as false when we do a refresh.

10750
17:45:41.734 --> 17:45:47.722
And then the browser checks the local storage says, oh, web three should be enabled, let's enable it and turn to true.

10751
17:45:47.722 --> 17:45:54.532
So now if we hit save, and we do a little refresh in our console, we can now see the logged out entrance fee.

10752
17:45:54.532 --> 17:45:59.573
So then we'll switch this to entrance fee from contract.

10753
17:45:59.573 --> 17:46:10.115
Now, we also probably want to show this entrance fee on our UI, if we do let entrance fee, we'll say equals blank.

10754
17:46:10.115 --> 17:46:17.281
And we'll take this and we'll update, you know, and we'll update this just saying entrance fee equals await entrance fee.

10755
17:46:17.281 --> 17:46:17.548
Cool.

10756
17:46:17.548 --> 17:46:21.092
Now we have this as kind of a global variable, we can add it in here.

10757
17:46:21.092 --> 17:46:23.452
And then let's even do a weight entrance fee.

10758
17:46:23.452 --> 17:46:26.876
But this whole thing in parentheses, and then do.

10759
17:46:26.876 --> 17:46:33.401
to string, and we can even console dot log entrance fee.

10760
17:46:33.639 --> 17:46:35.439
Now we're adding in a new browser.

10761
17:46:36.639 --> 17:46:37.147
issue here.

10762
17:46:39.639 --> 17:46:41.389
refresh.

10763
17:46:41.639 --> 17:46:44.477
We don't see the entrance fee in the UI here.

10764
17:46:45.639 --> 17:46:46.623
good console dot log out, right.

10765
17:46:47.639 --> 17:47:07.400
in a way here, what is going on here will use effect is going to rerender our browser, right? And that's what we want is what three enable goes from false to true, our browser re renders watch, once we get our entrance fee, does our browser rerender? No, it does not because entrance fee is just one of these normal variables, right.

10766
17:47:07.400 --> 17:47:16.120
So we want to actually change this from being just a normal variable to being a hook because entrance fee does get updated, but it's not triggering a rerender.

10767
17:47:16.120 --> 17:47:19.832
So we actually want to change this to being what's called a use state hook.

10768
17:47:19.832 --> 17:47:28.951
So you can read some more on the documentation about the using the state hook, it's kind of the same as doing let entrance fee, you know, equals blah, blah, blah, and setting it below.

10769
17:47:28.951 --> 17:47:31.638
But it also will trigger a rerender for us.

10770
17:47:31.638 --> 17:47:44.246
And to do it, we actually do const entrance fee, comma, set entrance fee equals use state zero import use state from react as well.

10771
17:47:44.246 --> 17:48:01.282
So basically, entrance fee is going to be our value, right, so if we do console dot log entrance fee, it's going to print out the entrance fee entrance fee is going to be the variable we call to get the entrance fee, the entrance fee is going to be the function we call to update or set that entrance fee.

10772
17:48:01.282 --> 17:48:05.164
And whatever that this entrance fee variable is set, we trigger a rerender.

10773
17:48:05.164 --> 17:48:10.553
From the front end, we have the state or the actual variable in the function to update it.

10774
17:48:10.553 --> 17:48:17.306
And then in the use state here, we just give it its starting values we're saying entrance fee is going to start out as zero.

10775
17:48:17.306 --> 17:48:30.295
So now that we know that, let's go back down here, and instead of saying entrance fee equals this, we can say const entrance fee from call equals away entrance fee.

10776
17:48:30.295 --> 17:48:36.223
to string and then we can say set entrance fee to this entrance fee from call.

10777
17:48:36.223 --> 17:48:40.425
And now when we set the use state, we're going to trigger a rerender.

10778
17:48:40.425 --> 17:48:42.590
So entrance fee will actually be populated.

10779
17:48:42.590 --> 17:48:47.306
Now if we go to our browser, do a little refresh here.

10780
17:48:47.306 --> 17:48:52.623
We can see that the entrance fee has indeed been re rendered here and we can actually see it here.

10781
17:48:52.623 --> 17:49:00.122
We see the console dot log of zero here even though we're doing console dot log entrance fee because this set entrance to function hasn't finished running it basically.

10782
17:49:00.122 --> 17:49:06.990
So we're just gonna get rid of that line will refresh and Bada bing bada boom, this huge number is kind of gross.

10783
17:49:06.990 --> 17:49:12.213
We might even want to update it so that it looks a little bit nicer.

10784
17:49:12.213 --> 17:49:17.990
So once again, we can import ethers, ethers from ethers.

10785
17:49:17.990 --> 17:49:26.996
And down below, we'll do a little ethers dot utils dot format units.

10786
17:49:26.996 --> 17:49:34.847
And we'll do entrance fee from call and we'll do a comma and type in.

10787
17:49:34.847 --> 17:49:39.728
And if we refresh on the front end, now we can see, entrance fee is 0.

10788
17:49:39.728 --> 17:49:39.798
1.

10789
17:49:39.798 --> 17:49:45.553
So we can even label this we'll say entrance fee, blah, blah, blah.

10790
17:49:45.641 --> 17:49:49.516
Now if we do a little refresh on the front end, entrance fee 0.

10791
17:49:49.641 --> 17:49:51.141
E.

10792
17:49:52.641 --> 17:49:58.044
Finally, we have the entrance fee, and now uses finally on our function to enter the lottery.

10793
17:49:58.044 --> 17:49:59.793
So let's finally uncomment this out.

10794
17:49:59.793 --> 17:50:03.034
And for message value, we're going to want to use this entrance fee.

10795
17:50:03.034 --> 17:50:06.926
And I'm realizing it's actually better to store this in its raw to string format.

10796
17:50:06.926 --> 17:50:09.941
So we're going to undo this part that we just did.

10797
17:50:09.941 --> 17:50:11.541
We're going to add it down here.

10798
17:50:11.641 --> 17:50:17.149
So we're going to ethers, that format units, entrance fee, comma, ether, like that.

10799
17:50:17.149 --> 17:50:20.926
So that like that, and let's comment this back out real quick.

10800
17:50:20.926 --> 17:50:23.493
So that at least in the UI, it shows up at 0.

10801
17:50:23.493 --> 17:50:23.558
1.

10802
17:50:23.558 --> 17:50:29.053
But on the back end, we're actually going to save it as its raw, and have way value.

10803
17:50:29.053 --> 17:50:37.891
So we're saying that we have this entrance fee and what we can do uncomment, this, we can just grab this entrance fee, and plop it in here.

10804
17:50:37.891 --> 17:50:40.348
So we need to make a button that's gonna do that.

10805
17:50:40.348 --> 17:50:45.810
Now again, we want to make our code that all this works, even if we're connected to a supported chain, though.

10806
17:50:45.810 --> 17:50:51.391
So before we even add this, right, if we switch from hard hat to like, Aetherium main net, do a little refresh.

10807
17:50:51.391 --> 17:50:57.159
We're getting kind of get an error here, because we're calling get entrance fee.

10808
17:50:57.159 --> 17:51:08.048
to string on an address that doesn't exist, right? So it's gonna get really confused and be like, hey, what, what are you doing here? Let's add a little button here so that we can actually enter the raffle.

10809
17:51:08.048 --> 17:51:15.642
Before we actually do that, let's make sure that we can only call the function so long as there actually is a raffle address.

10810
17:51:15.642 --> 17:51:17.570
So we'll do raffle address.

10811
17:51:17.570 --> 17:51:21.012
And we'll do this ternary operator once again.

10812
17:51:21.012 --> 17:51:27.378
So that only if this raffle address is valid, right? And it's not, no, we'll add all this code here, right.

10813
17:51:27.378 --> 17:51:30.536
So we'll say if the raffle address exists, we're going to do some stuff.

10814
17:51:30.536 --> 17:51:35.835
And for now, we can actually just copy paste this line, stick it in here.

10815
17:51:35.835 --> 17:51:38.823
And then otherwise, we'll say div.

10816
17:51:38.823 --> 17:51:41.459
Excellence div, close it off.

10817
17:51:41.642 --> 17:51:43.963
We'll save reformat, great.

10818
17:51:46.642 --> 17:51:47.158
detected.

10819
17:51:50.642 --> 17:51:50.829
here.

10820
17:51:50.829 --> 17:51:53.079
So we have this little div here, which is great.

10821
17:51:53.642 --> 17:51:56.803
this div, let's add a button.

10822
17:52:00.642 --> 17:52:04.782
a little button here, we'll have it say, enter raffle.

10823
17:52:05.642 --> 17:52:09.007
say on click, well, we're going to do some JavaScript.

10824
17:52:09.642 --> 17:52:14.086
do some JavaScript, we want to call an async function async function.

10825
17:52:14.086 --> 17:52:17.583
So I know the double brackets is going to be confusing, right.

10826
17:52:17.583 --> 17:52:22.372
But these brackets allow us to do JavaScript in our HTML, or JSX, or whatever.

10827
17:52:22.372 --> 17:52:27.314
And these brackets represent this function, it's going to an async function.

10828
17:52:27.314 --> 17:52:31.182
And we're gonna say, await, enter raffle.

10829
17:52:31.182 --> 17:52:32.559
And that's it.

10830
17:52:32.559 --> 17:52:34.455
So let's go back to the front end.

10831
17:52:34.455 --> 17:52:36.308
Now we have a little enter raffle function.

10832
17:52:36.308 --> 17:52:41.508
If we do refresh, let's just make sure our account is reset here.

10833
17:52:41.508 --> 17:52:45.811
So we're gonna go down to settings, advanced, reset accounts, yes.

10834
17:52:45.811 --> 17:52:46.980
I hit ENTER raffle.

10835
17:52:46.980 --> 17:52:48.815
metamath does indeed pop up.

10836
17:52:48.815 --> 17:52:51.573
And we can go ahead and confirm.

10837
17:52:51.573 --> 17:52:55.643
Awesome, okay, we can now enter our raffle.

10838
17:52:55.643 --> 17:52:59.443
We're doing incredibly well with this.

10839
17:52:59.643 --> 17:53:01.258
As you saw, we just got that pop up.

10840
17:53:02.643 --> 17:53:21.159
right? It's not very helpful for the users who are following along with this to look at this and go, Okay, did it go through? Or we did it fail, like, what, what just happened? So what we want to do is create what's called notifications, right? We want a little pop up saying, Hey, you sent your transaction, great job, we're going to use a library.

10841
17:53:21.159 --> 17:53:26.708
Again, we're going to use the web through UI Kit, which comes with some notifications that we can go ahead and use.

10842
17:53:26.708 --> 17:53:33.543
So if you come to this little interactive thing, which is right in their GitHub, there's a whole bunch of stuff in here.

10843
17:53:33.543 --> 17:53:36.938
And you can actually click around and play with different buttons and different things.

10844
17:53:36.938 --> 17:53:40.857
And you can actually go ahead and even go to docs for each one of these.

10845
17:53:40.857 --> 17:53:42.642
And you can go show code.

10846
17:53:42.642 --> 17:53:48.785
And you can literally like copy paste code into your project, like whatever you want to do styling and everything for us.

10847
17:53:48.785 --> 17:54:07.861
So back in our app dot j s, we're going to add import, no to vacations provider from web three UI kit and inside of the Morales provider, but outside of the components, we're gonna do notification provider notification provide Add it like this.

10848
17:54:07.861 --> 17:54:11.108
So it goes Morales provider notification provider component.

10849
17:54:11.108 --> 17:54:18.239
So wrapping our component in this notifications thing, and that's notification provider not notifications.

10850
17:54:18.239 --> 17:54:23.410
And this is going to allow us to actually make notifications back in our lottery entrance.

10851
17:54:23.410 --> 17:54:35.660
Back in our lottery entrance, we're gonna scroll up to the top, we're going to import a hook those notifications called us know, to the occasion from web three UI kit.

10852
17:54:35.660 --> 17:54:41.187
And this use notification gives us this thing back called a dispatch.

10853
17:54:41.187 --> 17:54:45.258
So I'm gonna say const, dispatch, equals use notification.

10854
17:54:45.258 --> 17:55:05.234
So use notification returns this dispatch, and this dispatch is like a little pop up that will give us so down here, when we call this enter raffle, we're gonna give it a little some parameters in here, we're gonna say on success, these functions come with onsuccess, they come with onComplete, they come with an error, all this stuff.

10855
17:55:05.234 --> 17:55:14.177
And when this function is successful, we'll do handle success, we'll create a new handle success function that will handle the success.

10856
17:55:14.177 --> 17:55:18.244
And this is Patrick from the future coming back to show one additional point.

10857
17:55:18.244 --> 17:55:34.170
I know I mentioned it, but it is really good to add this on error, colon error console dot log error for any run contract functions, even the reads, If any of your run contract functions break, you won't know.

10858
17:55:34.170 --> 17:55:40.390
So definitely want to add this on error error console dot log error to all of your run contract functions.

10859
17:55:40.390 --> 17:55:46.355
So up here, before the return, we'll create a new const handle success.

10860
17:55:46.355 --> 17:55:54.660
We'll say this is an async function async function that takes the transaction as input parameters.

10861
17:55:54.660 --> 17:55:58.872
And remember, you can turn functions into constant variables.

10862
17:55:58.872 --> 17:56:06.295
And we'll say await TX dot Wait, one, so we'll wait for that transaction to go through.

10863
17:56:06.295 --> 17:56:10.721
And then we'll create another function called handle new notification, dx.

10864
17:56:10.721 --> 17:56:14.660
And you'll see why I'm doing it like this in a minute.

10865
17:56:14.660 --> 17:56:20.895
And we'll say const and Linoone notification, this is just going to be a synchronous function because we don't need it to be async.

10866
17:56:20.895 --> 17:56:25.454
And we're just going to call this dispatch, we're going to set up this notification basically.

10867
17:56:25.454 --> 17:56:29.502
So we'll say notify, or dispatch, and then we'll add the parameters in here.

10868
17:56:29.502 --> 17:56:33.395
So it takes an object as a parameter, we'll say type info.

10869
17:56:33.395 --> 17:56:48.020
Message, it's going to be transaction complete, the title is going to be TX notification.

10870
17:56:48.020 --> 17:56:58.395
Jose, Shawn, we're going to say, top are and then icon, we're going to say a little bell.

10871
17:56:58.645 --> 17:57:08.200
And you can find all this stuff right in here, type icon position, you can read all about the different parameters you can kind of set this up with so handle new notification handle success.

10872
17:57:08.200 --> 17:57:18.195
So we're saying, enter raffle once this transaction is successful, call this handle success function, which is going to call handle new notification.

10873
17:57:18.195 --> 17:57:18.445
Okay.

10874
17:57:18.445 --> 17:57:22.359
And you'll see why we split this into two instead of just having handle success.

10875
17:57:22.359 --> 17:57:23.628
Also do the dispatch.

10876
17:57:23.628 --> 17:57:30.119
When we press our enter raffle button, we're going to call enter raffle is successful, we're going to call handle success.

10877
17:57:30.119 --> 17:57:36.058
We're going to wait for that transaction to finish Yes, it passes a parameter to our handle success function.

10878
17:57:36.058 --> 17:57:40.118
And then all we're going to do is we're going to call handle new notification.

10879
17:57:40.118 --> 17:57:44.171
And we're going to dispatch we're going to launch one of these notifications.

10880
17:57:44.171 --> 17:57:46.978
So back here, let's hit enter raffle.

10881
17:57:46.978 --> 17:57:49.478
metamath pops up will confirm.

10882
17:57:49.646 --> 17:57:54.868
And after it completes, we get this wonderful transaction notification transaction complete, right.

10883
17:57:54.868 --> 17:57:59.201
So we've let the user know, great job, you've submitted a transaction.

10884
17:57:59.201 --> 17:57:59.917
Great work.

10885
17:57:59.917 --> 17:58:01.069
So this is great.

10886
17:58:01.069 --> 17:58:04.547
We're giving our users some helpful pieces here.

10887
17:58:04.547 --> 17:58:11.026
Now let's add a little bit more here so that the users know what else is going on with this lottery.

10888
17:58:11.026 --> 17:58:15.712
But we need to display a little bit more data, right, let's display how many people are in this lottery.

10889
17:58:15.712 --> 17:58:17.908
How many people are in this game.

10890
17:58:17.908 --> 17:58:19.153
And we can do that.

10891
17:58:19.153 --> 17:58:22.449
Of course, because we have a number players command.

10892
17:58:22.449 --> 17:58:24.951
We also probably want to get the recent winner.

10893
17:58:24.951 --> 17:58:26.323
And we can do that as well.

10894
17:58:26.323 --> 17:58:33.083
Up here, we're going to copy this get entrance fee, we're going to create another one called Get num players.

10895
17:58:33.083 --> 17:58:37.435
And this is going to call go back to raffle dot soul.

10896
17:58:37.435 --> 17:58:43.301
It's going to call get number of players actually so let's just call it call it the same thing.

10897
17:58:43.301 --> 17:58:47.120
Get number of players and we're going to call and get number of players.

10898
17:58:47.120 --> 17:58:48.747
And to store this value.

10899
17:58:48.747 --> 17:58:50.441
Once again up at the top.

10900
17:58:50.646 --> 17:58:56.201
We're going to copy this line, paste it right and we'll do non players.

10901
17:58:56.201 --> 17:58:58.899
And then we'll do set num players.

10902
17:58:58.899 --> 17:59:01.917
And then we'll copy this line again.

10903
17:59:01.917 --> 17:59:05.476
A recent winner so we'll do recent Winner.

10904
17:59:05.646 --> 17:59:17.046
Winner will do Set, recent winner, then we'll copy this again, instead of getting number players will do get get recent winner.

10905
17:59:17.046 --> 17:59:26.521
So we'll call it get recent winner get recent winner in our use effect, let's do more than just get the entrance fee, let's get everything.

10906
17:59:26.521 --> 17:59:35.980
So we can say const num players, from call equals, we'll do a weight, get number of players.

10907
17:59:35.980 --> 17:59:41.754
to string, and then we'll do set set num players do like that.

10908
17:59:41.754 --> 17:59:45.953
So we'll do set num players, num players from call.

10909
17:59:45.953 --> 17:59:55.286
And then we'll also do const recent winner from call this is going to be await get recent winner.

10910
17:59:55.286 --> 17:59:59.614
And we might need to wrap this to string but I think I don't think we need to.

10911
17:59:59.614 --> 18:00:02.504
So we'll do set recent winner paste that in here.

10912
18:00:02.504 --> 18:00:05.697
So now we've had a number of players, we've added a recent winner.

10913
18:00:05.697 --> 18:00:06.997
Let's come back down here.

10914
18:00:06.997 --> 18:00:08.959
We have an entrance fee.

10915
18:00:08.959 --> 18:00:13.334
Let's go ahead and do number of players.

10916
18:00:13.334 --> 18:00:30.432
And we'll add number of players or what did we call it? Oh my god, we called setting employers twice oops, it's called non players, scroll down players gonna be non players, and then we'll do recent winner.

10917
18:00:30.647 --> 18:00:33.693
And then we'll add in the recent winner.

10918
18:00:33.693 --> 18:00:34.318
Awesome.

10919
18:00:35.647 --> 18:00:36.115
fees 0.

10920
18:00:40.647 --> 18:00:45.563
And if we go ahead and we enter the raffle metamath pops up.

10921
18:00:45.647 --> 18:00:46.947
We'll go ahead and confirm.

10922
18:00:48.647 --> 18:00:51.066
we'll get transaction complete.

10923
18:00:53.647 --> 18:00:55.414
the number of players has updated.

10924
18:00:56.647 --> 18:01:02.721
which is kind of annoying, right, let's enter the raffle again, we'll go confirm transaction complete.

10925
18:01:02.721 --> 18:01:04.373
But this didn't rerender.

10926
18:01:04.373 --> 18:01:04.663
Right.

10927
18:01:04.663 --> 18:01:07.898
So we want to set something up so that we automatically rerender.

10928
18:01:07.898 --> 18:01:11.381
And guess what's going to do that the handle success that we were talking about before.

10929
18:01:11.381 --> 18:01:16.862
That's right, all of this update UI stuff, we can actually pull out of the use effect.

10930
18:01:16.862 --> 18:01:19.920
So we're going to copy it all deleted there.

10931
18:01:19.920 --> 18:01:23.848
And we're going to have it be its own standalone function like this.

10932
18:01:23.848 --> 18:01:35.555
And then in our handle success, whenever this successful transaction goes through, we're going to update the UI, right? So handle success handled new notification, and we're going to update the white.

10933
18:01:35.555 --> 18:01:38.862
So now if we go back here, let's enter the lottery.

10934
18:01:38.862 --> 18:01:43.020
Let's confirm, we see we get the five and we get transaction Notification.

10935
18:01:43.020 --> 18:01:46.138
Now we want to test getting a recent winner here.

10936
18:01:46.138 --> 18:01:52.203
So what we can do, actually back in our hard hat project is we want to create a new script.

10937
18:01:52.203 --> 18:01:56.016
And I actually already created it for you, that's going to mock the channeling VRF.

10938
18:01:56.016 --> 18:01:57.760
And that's going to mock being a keepers.

10939
18:01:57.760 --> 18:02:01.548
So all this is really doing is pretty much exactly what our tests were doing.

10940
18:02:01.548 --> 18:02:08.873
If you want to pause right now and look through this yourself, pause here and add this mock off chain, which is both keepers and VRF.

10941
18:02:08.873 --> 18:02:11.616
Or you can just go to the GitHub repo here.

10942
18:02:11.616 --> 18:02:14.448
Just go to the GitHub repo for Lesson Nine.

10943
18:02:14.448 --> 18:02:20.460
It's already in scripts go down to scripts Markov chain, you can just copy paste it here.

10944
18:02:20.460 --> 18:02:22.981
Because I want to test that that recent winner.

10945
18:02:22.981 --> 18:02:39.494
So in my hard hat, smart contract lottery, so we'll do yarn, hardhats run scripts, slash mock off chain dash test network local host, we're going to mock you know, basically picking a winner from an upkeep with Request ID one, we're on a local network.

10946
18:02:39.494 --> 18:02:41.954
Okay, let's pretend the recent winner was so and so.

10947
18:02:41.954 --> 18:02:48.093
And what we can do is we can do a little refresh here, we can see we have a winner updated.

10948
18:02:48.093 --> 18:02:48.489
Boom.

10949
18:02:48.649 --> 18:02:50.225
Now we're gonna clean up the UI.

10950
18:02:51.649 --> 18:02:52.165
couple of things.

10951
18:02:53.649 --> 18:02:55.470
with this section.

10952
18:02:59.649 --> 18:03:10.960
because it confused me a little bit is that this onsuccess isn't checking that the transaction has a block confirmation, it's just checking to see that the transaction was successfully sent to Metamask.

10953
18:03:10.960 --> 18:03:15.601
So onsuccess checks to see a transaction is successfully sent the Metamask.

10954
18:03:15.601 --> 18:03:25.550
And that's why up in that other function, we do TX dot wait one because that's the piece that actually waits for the transaction to be confirmed.

10955
18:03:25.649 --> 18:03:36.631
Right now we're using Morales to make once we call that mocking script, I had to refresh the browser to see the winner here, right and number of players obviously got reset to zero, which is great.

10956
18:03:36.631 --> 18:03:37.823
That's not ideal.

10957
18:03:37.823 --> 18:03:43.377
Ideally, we want our UI to just automatically update when some event gets fired.

10958
18:03:43.377 --> 18:03:46.479
In our raffle contract, we get this event emitted.

10959
18:03:46.479 --> 18:03:49.993
Instead of in our code doing this await success here.

10960
18:03:49.993 --> 18:03:59.460
What we could do is we could set up a portion to listen for that event being emitted and update the front end accordingly.

10961
18:03:59.460 --> 18:04:03.438
With that knowledge we can also listen for the winner event being emitted.

10962
18:04:03.438 --> 18:04:14.149
We could update our front end instead of having to refresh it's your cue Yes, and you want to see if you can add to this right now, I highly recommend you do.

10963
18:04:14.149 --> 18:04:17.131
So we've pretty much finished all the functionality.

10964
18:04:17.131 --> 18:04:28.486
And wow, you've learned a ton in this little bit, right? We've learned about use effects use Morales, all these hooks, all this stuff, and we've got a front end that very nicely handles interacting with our smart contract.

10965
18:04:28.486 --> 18:04:30.582
The only thing is, is it looks really ugly.

10966
18:04:30.582 --> 18:04:32.446
This is kind of gross.

10967
18:04:32.446 --> 18:04:36.096
So let's make this look at least a little bit nicer.

10968
18:04:36.096 --> 18:04:39.334
There's two things to think about when it comes to building these front ends.

10969
18:04:39.334 --> 18:04:49.857
There's component libraries, like web three UI Kit, which we're using, which gives us kind of like components that give us, you know, blocks of code, like this connect button that are already formatted for us.

10970
18:04:49.857 --> 18:04:55.188
And then there's CSS libraries that actually will help us format the rest of our stuff here.

10971
18:04:55.188 --> 18:04:57.582
So we're using one of these component libraries.

10972
18:04:57.582 --> 18:05:02.602
We're also going to use one of these formatting libraries, and the library that we're going to use is tailwind.

10973
18:05:02.602 --> 18:05:06.824
And the reason that we're going to use tailwind CSS is because it's really popular.

10974
18:05:06.824 --> 18:05:12.846
If you want to learn CSS, there's some wonderful resources that you can use to learn CSS web three schools is one that I've used a ton.

10975
18:05:12.846 --> 18:05:25.830
So there's going to be a link to that in the GitHub repo associated with this course so that you can make your websites look pretty when formatting stuff but we are actually going to work with tailwind because it's going to make us doing CSS stuff a lot easier.

10976
18:05:25.830 --> 18:05:28.518
Since we're using tailwind with next Jas.

10977
18:05:28.650 --> 18:05:32.850
There's actually a wonderful little guide here for installing tailwind with next Jas.

10978
18:05:32.850 --> 18:05:36.277
And we're gonna go basically go ahead and follow along with this.

10979
18:05:36.277 --> 18:05:40.462
This link is available in the GitHub repo associated with this course with this lesson.

10980
18:05:40.462 --> 18:05:43.132
So we've already created our project we've seeded into our project.

10981
18:05:43.132 --> 18:06:05.317
Now we're gonna go ahead and install tailwind npm install dash D instead, since we're using yarn, we're going to do yarn or pop this open, green new yarn, add dash dash Dev, paste those three in tailwind CSS, post CSS and then autoprefixer and it's the three of these that are going to basically make up tailwind with next Jas.

10982
18:06:05.317 --> 18:06:10.412
Once we have those we're going to basically init tailwind and make a config file for tailwind.

10983
18:06:10.412 --> 18:06:17.175
So we're gonna do yarn tailwind CSS and it does p yarn tailwind CSS init dash P will run that.

10984
18:06:17.175 --> 18:06:30.451
This is going to give us this post CSS dot config dot j s and this tailwind dot config dot j s and what we're going to want to do is literally just hit this copy button, and we're going to update our tailwind.

10985
18:06:30.451 --> 18:06:31.051
config.

10986
18:06:31.051 --> 18:06:39.234
js tailwind Jas so that it says okay, all of this stuff, anything in Pages anything with.

10987
18:06:39.234 --> 18:06:39.400
js.

10988
18:06:39.400 --> 18:06:40.811
ts dot JSX or TSX.

10989
18:06:40.811 --> 18:06:47.370
And anything in these components, anything in those two folders is going to be considered tailwind double.

10990
18:06:47.370 --> 18:06:48.973
We want to use tailwind on these two folders.

10991
18:06:48.973 --> 18:06:53.831
Then we're going to add the tailwind directives to our global CSS files.

10992
18:06:53.831 --> 18:07:02.952
So if we go back, we're going to styles Global's we're going to overwrite everything in here with ADD tailwind base and add tailwind components at tailwind utilities.

10993
18:07:02.952 --> 18:07:06.184
And this makes it so that our global CSS file uses tailwind.

10994
18:07:06.184 --> 18:07:19.576
Now, you'll see like unknown rule at tailwind, what we can do is we can go to components, what we can do is we can look up this post CSS language support extension, paste that in here, boom, let's go ahead and install this.

10995
18:07:19.576 --> 18:07:23.401
And now we get those little underscores to go away, which is really nice.

10996
18:07:23.401 --> 18:07:27.984
Now, per usual, we can just do NPM, run Dev and start adding tailwind to our divs.

10997
18:07:27.984 --> 18:07:37.635
Now what tailwind does is allows us in our divs to set everything as a class name, and then just set some real minimalistic text in these class names here.

10998
18:07:37.635 --> 18:07:40.023
So let's look at our smart contract lottery here.

10999
18:07:40.023 --> 18:07:41.395
We've just tailwind did it.

11000
18:07:41.395 --> 18:07:43.719
So it already has been updated a little bit.

11001
18:07:43.719 --> 18:07:44.989
Let's update our header here.

11002
18:07:44.989 --> 18:07:45.481
Well, let's see.

11003
18:07:45.481 --> 18:07:48.352
We want to give our header a border from the tailwind.

11004
18:07:48.352 --> 18:07:50.752
We'll do a quick search.

11005
18:07:50.752 --> 18:08:03.160
Look a border we can see all this border stuff like border width border this border that say we want a border on the bottom, we can see we can get a border on the bottom with something like this.

11006
18:08:03.160 --> 18:08:06.838
Let's do border on the bottom with a width of two pixels.

11007
18:08:06.838 --> 18:08:08.479
We just do border b two.

11008
18:08:08.479 --> 18:08:16.493
So I'm going to copy border B to do border b two, I'm going to save it and what we need to do for our CSS and everything to take effect.

11009
18:08:16.493 --> 18:08:18.524
Go ahead and kill the front end.

11010
18:08:18.652 --> 18:08:19.906
And then we'll rerun it with yarn Dev.

11011
18:08:20.652 --> 18:08:21.152
end now.

11012
18:08:21.152 --> 18:08:24.009
Give it a little refresh and Okay, cool.

11013
18:08:24.652 --> 18:08:25.861
have a little border here.

11014
18:08:27.652 --> 18:08:29.889
and it's just not a whole lot yet.

11015
18:08:31.652 --> 18:08:34.152
add tailwind to me go to Extensions.

11016
18:08:35.652 --> 18:08:36.080
tailwind.

11017
18:08:36.080 --> 18:08:37.901
There's a tailwind extension here.

11018
18:08:38.652 --> 18:08:40.109
going to add a whole bunch of stuff in here.

11019
18:08:40.652 --> 18:08:44.385
flex, flex row.

11020
18:08:44.652 --> 18:08:51.274
We're gonna make our decentralized lottery and h one which stands for like header one.

11021
18:08:51.274 --> 18:08:55.433
Do class name equals, we'll do the y dash force.

11022
18:08:55.433 --> 18:09:01.652
We'll give it padding the top of form the X padding on the x axis of four.

11023
18:09:01.652 --> 18:09:05.329
We'll make it bold font and we'll make the text three XL size.

11024
18:09:05.329 --> 18:09:07.152
So we'll make everything bigger.

11025
18:09:07.152 --> 18:09:07.568
Cool.

11026
18:09:07.568 --> 18:09:12.861
Then we'll do one more, we'll wrap our Connect button in a div.

11027
18:09:12.861 --> 18:09:19.485
So we'll say div class name equals, and we'll give it a an automatic left margin.

11028
18:09:19.485 --> 18:09:20.818
We'll do py too.

11029
18:09:20.818 --> 18:09:24.071
So some y padding, some x padding.

11030
18:09:24.071 --> 18:09:26.200
See what we have done.

11031
18:09:26.200 --> 18:09:26.683
Okay.

11032
18:09:26.683 --> 18:09:34.033
Now if we zoom out a little bit, we can see, if we close this too, we can see now our Connect button is on the side here.

11033
18:09:34.033 --> 18:09:35.553
And they're kind of separated like that.

11034
18:09:35.553 --> 18:09:36.486
And I think that looks nice.

11035
18:09:36.486 --> 18:09:45.846
So we're going to keep that now we're going to go back to our lottery entrance, we're going to change this up just a hair, we'll say div class name equals P.

11036
18:09:45.846 --> 18:09:50.081
Five, we'll make our button look really nice.

11037
18:09:50.081 --> 18:09:54.541
We'll say class name equals background blue 500.

11038
18:09:54.541 --> 18:10:00.429
When we hover over, it will say, background blue 700.

11039
18:10:00.653 --> 18:10:06.319
So now if I just say that, and when we hover over it, it looks a little different, that's really nice.

11040
18:10:06.319 --> 18:10:21.903
We'll say text is white, we'll say the font is bold, we'll give it some white padding, I'll give it some x padding, we'll have the bunbee rounded, and we'll give it a margin left auto, now looks a lot better, right? That's a lot prettier.

11041
18:10:21.903 --> 18:10:29.938
We're just going to be doing some basic CSS here just to make it look a little bit nicer, right, but just that by itself already made this lottery button look a lot cooler.

11042
18:10:29.938 --> 18:10:32.415
Now some functionality that we didn't add here.

11043
18:10:32.415 --> 18:10:36.153
So we need to add a disabled, kind of like what we did before.

11044
18:10:36.153 --> 18:10:42.707
And in our enter a raffle it comes with, like I said, is loading and it is fetching.

11045
18:10:42.707 --> 18:10:46.342
None of our transaction is loading or fetching, we'll just make this disabled.

11046
18:10:46.342 --> 18:10:51.025
So we'll say is loading or is fetching this will be disabled.

11047
18:10:51.025 --> 18:10:57.753
Right? Now, if we go back to the front, we hit enter raffle, go ahead and hit confirm, we can add a CSS for it.

11048
18:10:57.753 --> 18:11:06.161
But when a transaction is loading, they will not be able to click that button anymore, which that's something else pretty that we want to do speaking of is loading and is fetching.

11049
18:11:06.161 --> 18:11:11.838
When it's loading or fetching, we probably want it to have that like little spinny thing right when we hit it right now.

11050
18:11:11.838 --> 18:11:13.068
And mash is pops up.

11051
18:11:13.068 --> 18:11:18.054
And we can confirm but it would be cool if it had like a little spinny thing here, right.

11052
18:11:18.054 --> 18:11:24.082
So you can usually just Google like how to add spinny thing or stuff like that, and you'll get something.

11053
18:11:24.082 --> 18:11:29.654
But you can again, you can just copy paste this from my code, I'm going to show you what I ended up doing for this section.

11054
18:11:29.654 --> 18:11:33.145
And we're gonna say is, if is loading or is fetching.

11055
18:11:33.145 --> 18:11:39.864
And we're going to use that ternary operator all the time, then in here, we're going to do a little div.

11056
18:11:39.864 --> 18:11:47.879
And otherwise, we're going to do a different div for loading or for fetching, we're going to add like a little spinny thing in here.

11057
18:11:47.879 --> 18:11:54.330
So we're going to add class name equals.

11058
18:11:54.654 --> 18:11:59.240
If we're loading, we're going to add this little spinny thing, which I'll show you what it looks like in a second.

11059
18:11:59.240 --> 18:12:02.916
And if we're not loading, we're just gonna do enter, raffle like that.

11060
18:12:02.916 --> 18:12:07.412
So we'll come back to the front end, see answer raffle, we'll click the button.

11061
18:12:07.412 --> 18:12:11.130
Now we get this cute little spinny thing, confirm transaction goes through.

11062
18:12:11.130 --> 18:12:12.526
So anything goes away.

11063
18:12:12.654 --> 18:12:12.850
Nice.

11064
18:12:12.850 --> 18:12:14.866
Well, let's put these on different lines.

11065
18:12:15.654 --> 18:12:25.404
do so those will be on different lines.

11066
18:12:25.404 --> 18:12:35.992
Now boom, entrance fee, number players recent winner, once a lottery now will confirm transaction complete number of players has gone up and we have done it.

11067
18:12:35.992 --> 18:12:37.298
Now this looks a lot nicer.

11068
18:12:37.298 --> 18:12:42.011
It's clearly not perfect, but it's much easier to read than kind of that lump that we had before.

11069
18:12:42.011 --> 18:12:48.955
And the reason I wanted to show you this was really just kind of giving you your footholds for making these look a little bit nicer.

11070
18:12:48.955 --> 18:12:52.455
This definitely isn't a CSS course.

11071
18:12:52.655 --> 18:12:53.173
Oh, wow.

11072
18:12:53.173 --> 18:12:55.024
Okay, this is phenomenal.

11073
18:12:56.655 --> 18:12:57.311
we really like.

11074
18:12:59.655 --> 18:13:08.018
this bad, Larry, let's talk about how we can deploy this, this section is going to be optional, okay, because I'm going to deploy something to rank B and deploying to test sets can take a long time.

11075
18:13:08.018 --> 18:13:10.691
So we're going to deploy our contracts to rink B.

11076
18:13:10.691 --> 18:13:14.690
And then we're going to deploy our website to a hosting provider.

11077
18:13:14.690 --> 18:13:26.589
So first, let's talk about hosting providers for a quick second, if we want to host our beautiful website that we just created, there are ways to deploy it using things like for cell or Google Cloud, or AWS.

11078
18:13:26.655 --> 18:13:26.861
Nettle.

11079
18:13:28.655 --> 18:13:31.163
different places that we can deploy our application.

11080
18:13:31.655 --> 18:13:47.474
thing about these though, is that these are all centralized deployment places, having a centralized deployment application can still be incredibly important, right? If we look at ether scan for a second ether scan is a centralized application right at the end of the day, but it's still one that we've been using a lot.

11081
18:13:47.474 --> 18:13:50.051
However, if we want to have a front end that's decentralized.

11082
18:13:50.051 --> 18:13:51.534
Well, that's a little bit harder.

11083
18:13:51.534 --> 18:14:01.565
The more important thing for us is that our back end, our smart contracts are decentralized, right? That's the most important thing because that will give users the ability to interact with our logic in a decentralized way.

11084
18:14:01.565 --> 18:14:04.467
But maybe we also want our front ends decentralized.

11085
18:14:04.467 --> 18:14:18.058
Now at some point we will still use a centralized service Like VSL to deploy an application, and I'll show you why when we get there, there's some features that right now, they're really just hard to do without like a really solid centralized back end.

11086
18:14:18.058 --> 18:14:26.229
What's important to keep in mind is that our back end, the logic of our contract is on a decentralized blockchain.

11087
18:14:26.229 --> 18:14:38.714
So even if we host the front end on a centralized hosting provider, using some type of centralized database to make the front end easier to work with, the logic of the application is decentralized.

11088
18:14:38.714 --> 18:14:40.708
And that's the most important piece.

11089
18:14:40.708 --> 18:14:46.591
So I'm going to give you some tools later on, and how to introduce more of these feature richness.

11090
18:14:46.656 --> 18:14:51.600
If you choose to do so doing so will add a centralized component on your front end.

11091
18:14:51.600 --> 18:14:55.703
And it's something to keep in mind, depending on how you want your architecture.

11092
18:14:55.703 --> 18:15:04.588
So when doing that just be absolutely sure that the smart contracts on the back end are deployed are decentralized on one of these blockchains.

11093
18:15:04.656 --> 18:15:09.215
Now, we'll learn about some of those centralized ways to do that in a later section.

11094
18:15:09.215 --> 18:15:16.539
For now, let's learn how to deploy this front end in a more decentralized way.

11095
18:15:16.656 --> 18:15:20.281
And the tool that we're going to use is a tool called IPFS.

11096
18:15:20.656 --> 18:15:23.910
let me explain a little bit about how IPFS works.

11097
18:15:24.656 --> 18:15:27.881
distributed decentralized data structure.

11098
18:15:29.656 --> 18:15:30.124
blockchain.

11099
18:15:30.124 --> 18:15:31.670
But it's similar to a blockchain.

11100
18:15:32.656 --> 18:15:32.956
though.

11101
18:15:35.656 --> 18:15:37.740
So let me explain how this actually works.

11102
18:15:38.656 --> 18:15:42.480
how this works on the site, there's going to be a link to this and the GitHub repo associated with this course.

11103
18:15:42.480 --> 18:15:44.722
But we give you my basic take on it.

11104
18:15:44.722 --> 18:15:50.338
So we have our code, or our file, or whatever it is, right, we have some piece of data.

11105
18:15:50.338 --> 18:15:57.946
Now as we know, when you really have anything, you can hash that thing, you can hash that data, right, so you can get a unique output.

11106
18:15:57.946 --> 18:16:00.558
So and that's actually the first thing that IPFS does.

11107
18:16:00.656 --> 18:16:05.370
It hashes our data to get a unique hash, that only points to that data.

11108
18:16:05.370 --> 18:16:08.465
Yes, a massive code file a ton of text.

11109
18:16:08.465 --> 18:16:15.323
Yes, you can encode all of that into a single hash function, your IPFS node does this hashing for you.

11110
18:16:15.323 --> 18:16:26.538
And every single IPFS node on the planet has the exact same hashing function, kind of like a blockchain, right, they all kind of run this same spec, the same specification.

11111
18:16:26.538 --> 18:16:30.721
So we can hash our data on our IPFS node and get this unique output.

11112
18:16:30.721 --> 18:16:43.046
What we can do then is we can pin that data or pin that code, or pin that file or pin that whatever, to our node, we have some data, we get a unique hash of it, all it does is host this data and have these hashes.

11113
18:16:43.046 --> 18:16:48.312
That's it, our node is connected to a network of other IPFS nodes.

11114
18:16:48.312 --> 18:16:55.657
So there's a massive network of people running IPFS nodes, they're incredibly lightweight, way lighter weight than any other blockchain node.

11115
18:16:55.657 --> 18:16:57.180
And they all talk to each other.

11116
18:16:57.180 --> 18:17:00.088
So if I asked the network, hey, I want to get this hash.

11117
18:17:00.088 --> 18:17:02.108
All these nodes would talk to each other.

11118
18:17:02.108 --> 18:17:07.588
And eventually they'd reach up at our node saying, Oh, I found a node that has that hash.

11119
18:17:07.657 --> 18:17:08.736
Here's the file associated with it.

11120
18:17:09.657 --> 18:17:30.818
Okay, well, that's kind of centralized, because we have the data on one node here, right? Well, you're right, well, here's the thing, what other nodes can do is they can say, oh, that data looks really cool, I want to have that persist, what they can do is they can pin your hash, they can pin your data, and they'll get a copy of your data on their node.

11121
18:17:30.818 --> 18:17:32.950
And you can keep doing this.

11122
18:17:32.950 --> 18:17:40.829
And so you easily allow an entire network to easily replicate any code or any data in a decentralized sense.

11123
18:17:40.829 --> 18:17:42.173
And they're incredibly easy to spin up.

11124
18:17:42.173 --> 18:17:56.017
And they're incredibly easy to work with something about IPFS, that makes it drastically different than a blockchain is the can't do smart contract, there's no execution, it can really only store it's just decentralized storage that IPFS can do.

11125
18:17:56.017 --> 18:18:13.954
Now, the issue here is that in order for our data to really be decentralized, another node does need to pin our data, right? Because if we're the only IPFS node that's got this hash, it's kind of centralized on our node, if our node goes down, that data is gone, and the network won't be able to access that data anymore.

11126
18:18:13.954 --> 18:18:18.238
So we'll talk about strategies in the future about having other people pin your data.

11127
18:18:18.238 --> 18:18:24.948
But for now, this is a way we can host data, we can send code and have it be in a decentralized context.

11128
18:18:24.948 --> 18:18:38.229
So unlike a blockchain, where every single node in a blockchain is going to have a copy of the entire blockchain IPFS nodes get to optionally choose which data they want to pin, and they can't do any execution.

11129
18:18:38.229 --> 18:18:49.443
So you could have an IPFS node, half a megabyte, and you could have an IPFS node, that several terabytes, it's up to the node operators, how much data and what data they want to pin.

11130
18:18:49.443 --> 18:18:52.443
Now that we know about IPFS.

11131
18:18:52.658 --> 18:19:00.447
Let's actually deploy our wonderful application to IPFS so that anybody can use it and anybody can connect to it.

11132
18:19:00.447 --> 18:19:02.432
So long as our node is up.

11133
18:19:02.432 --> 18:19:05.496
Are you ready? Okay, get excited here.

11134
18:19:05.658 --> 18:19:10.122
We're first going to do this kind of the Manuel Wait, because I'm going to show you how to install IPFS.

11135
18:19:10.122 --> 18:19:10.916
And work with IPFS.

11136
18:19:10.916 --> 18:19:19.824
Hit get started, there's a number of ways to install and work with IPFS, you can get it with a desktop application, get a command line.

11137
18:19:19.824 --> 18:19:29.708
And then we can also add IPFS to our browser using something like brave or I think Firefox to some this IPFS router is automatically built it.

11138
18:19:29.708 --> 18:19:45.594
But if using something like Chrome, you might have to add a little companion, because what we want to do is we can actually use those little hashes as URLs for websites, right, and so we want to be able to put that URL in our browser and connect to that node or that piece of code.

11139
18:19:45.659 --> 18:19:50.309
So what we're gonna do is we're gonna have you install the IPFS desktop, so you're gonna hit that.

11140
18:19:50.309 --> 18:19:53.184
And when you do that, you should be able to open up IPFS.

11141
18:19:53.184 --> 18:19:59.003
Now, if you install it, you might get this little guy, this little box here in your upper section.

11142
18:19:59.003 --> 18:20:04.059
Otherwise, you might be able to open it up with with IPFS desktop and see it as a regular desktop app.

11143
18:20:04.059 --> 18:20:15.790
Well, once you install it, you might see IPFS is running, you can restart stop, you can do all this stuff, we're gonna go to the file section, and we're gonna get a little pop up that looks like this.

11144
18:20:15.790 --> 18:20:21.103
Now, I've got a ton of stuff in here, because I've been using IPFS for some time in here, right now, you might have no data.

11145
18:20:21.103 --> 18:20:23.896
So let's just go ahead and import some file.

11146
18:20:23.896 --> 18:20:30.201
And maybe for now we'll just import, you know, our next dot config dot j s, right? It doesn't matter, just import something.

11147
18:20:30.201 --> 18:20:35.298
And now in here, we have this next dot config dot j s or whatever file you import it.

11148
18:20:35.298 --> 18:20:38.820
So what we can do with this is we can actually copy the CID.

11149
18:20:38.820 --> 18:20:42.303
And we can view this in our browser.

11150
18:20:42.303 --> 18:20:53.278
So if we do IPFS dot dot slash slash, and we paste it in, we hit enter, we can give our browser access to actually rendering IPFS URLs.

11151
18:20:53.278 --> 18:20:59.709
If using brave, you can just do use a brave local IPFS node or let's go ahead and download this IPFS companion.

11152
18:20:59.709 --> 18:21:05.150
So we'll get IPFS companion, there's a Firefox install for Chrome brave, blah, blah, blah.

11153
18:21:05.150 --> 18:21:11.337
So I'm gonna go to the Chrome store to get it for brave, we're just going to hit Add to brave add extension.

11154
18:21:11.337 --> 18:21:13.628
But once you download it, you'll get something that looks like this.

11155
18:21:13.660 --> 18:21:21.315
Even on a little browser companion, we can see like import, we can see stuff about our node, if we click our node, we will see a very similar setup.

11156
18:21:21.315 --> 18:21:27.250
But now that we have the companion in our browser, we can copy that Cid that hash.

11157
18:21:27.250 --> 18:21:33.755
Now brave, we can just do use brave local IPFS node, and will automatically get dropped into the file.

11158
18:21:33.755 --> 18:21:45.392
Now, if IPFS companion doesn't work for you, and you can't see the URL inside of something like Google Chrome or some other browser, what you can do is you can use something called the IPFS gateway.

11159
18:21:45.392 --> 18:21:55.326
Now using a gateway, you're not actually directly requesting the data through IPFS requesting the data through another server, which is requesting it through IPFS.

11160
18:21:55.326 --> 18:22:00.088
But if you are having some trouble accessing these files, you can use the gateway.

11161
18:22:00.088 --> 18:22:10.535
So what you'll do is we'll do HTTPS, slash IPFS, slash and then paste the hash code there.

11162
18:22:10.535 --> 18:22:12.802
And you'll be able to see your file.

11163
18:22:12.802 --> 18:22:16.184
Now if you do it like this, you won't even need IPFS companion at all.

11164
18:22:16.184 --> 18:22:18.831
So we're going to deploy our website to IPFS.

11165
18:22:18.831 --> 18:22:28.860
So that anybody else who wants to pin this can, and we will now have the ability to have an incorruptible, in unputdownable website, which is just awesome.

11166
18:22:28.860 --> 18:22:34.625
We're going to learn how to do this the wrong way first, and then we're going to use a tool that's going to make it a lot easier for us.

11167
18:22:34.660 --> 18:22:38.266
Okay, so first, let's go to our website here.

11168
18:22:39.660 --> 18:22:41.437
want to deploy to rink B, go ahead and feel free.

11169
18:22:41.660 --> 18:22:47.406
remember to make sure that your contract addresses file updates accordingly.

11170
18:22:47.406 --> 18:22:47.744
Okay.

11171
18:22:47.744 --> 18:22:51.661
Now, next, Jas has the ability to create static websites.

11172
18:22:51.661 --> 18:22:56.818
And that's going to be an important term to know we're going to make a static website.

11173
18:22:56.818 --> 18:23:02.580
At the moment, we don't want our website to be tangled with any server stuff.

11174
18:23:02.661 --> 18:23:13.038
And the reason we we don't want it to be tangled with any server stuff is because if our website runs with server stuff, and we deploy it to IPFS, will IPFS doesn't have the ability to run any code, it just hosts code.

11175
18:23:13.038 --> 18:23:16.040
If our front end has any server stuff, it won't work.

11176
18:23:16.040 --> 18:23:23.582
Now, in its current state IPFS can't come to our project and know what to do, right, it doesn't know how to do yarn dev can't do yarn Dev.

11177
18:23:23.582 --> 18:23:27.497
So we need to put all of our code into its static equivalents.

11178
18:23:27.497 --> 18:23:30.385
So to do that, we're gonna do yarn build.

11179
18:23:30.385 --> 18:23:36.915
And if again, if we look at our package dot JSON, it comes with this build, which just runs next build.

11180
18:23:36.915 --> 18:23:44.693
And running this build command is going to build our code, what's called like a production build, creating an optimized production build here.

11181
18:23:44.693 --> 18:23:47.398
And we'll get something that looks like this.

11182
18:23:47.398 --> 18:23:49.168
And we can see this point down here.

11183
18:23:49.168 --> 18:23:53.594
Static, automatically rendered as static HTML uses no initial props.

11184
18:23:53.661 --> 18:23:58.902
There's some server based applications that next Jas comes with that if we use them.

11185
18:23:58.902 --> 18:24:00.350
Our static build won't work.

11186
18:24:00.350 --> 18:24:07.333
And actually, you'll see when we run yarn, next export, it'll fail if you have any that non static stuff.

11187
18:24:07.333 --> 18:24:09.422
So let's Go ahead and try yarn next export.

11188
18:24:09.422 --> 18:24:13.906
And let's see if it fails, it didn't fail, we now have a new folder called out.

11189
18:24:13.906 --> 18:24:19.273
And this is our folder, that's just pure static code and that we can use on IPFS.

11190
18:24:19.273 --> 18:24:24.511
In a later section, I'll show you what it looks like when you don't use some of those static things.

11191
18:24:24.511 --> 18:24:27.947
Both Morales and next Jas have the optionality to not have static code.

11192
18:24:27.947 --> 18:24:30.025
So we'll just want to keep that in mind.

11193
18:24:30.025 --> 18:24:33.695
So now that we have this out folder, we can go back to IPFS.

11194
18:24:33.695 --> 18:24:38.599
And we can import a folder, we're going to import that whole folder in here.

11195
18:24:38.599 --> 18:24:42.062
So hit that hit that import button and go to the folder.

11196
18:24:42.062 --> 18:24:46.102
Where that is mine is in next year smart contract lottery out.

11197
18:24:46.102 --> 18:24:49.062
So now we're going to upload this to our IPFS node.

11198
18:24:49.062 --> 18:24:51.694
Once it's done, we'll get this little checkmark.

11199
18:24:51.694 --> 18:24:55.407
And we can go through IPFS files and see our output here.

11200
18:24:55.407 --> 18:25:00.950
What we can do, let's go ahead and pin this to our node, we'll pin it to our local node here.

11201
18:25:00.950 --> 18:25:06.339
And now once it's up, we can copy the CID and go back to brave or chrome or whatever.

11202
18:25:06.339 --> 18:25:11.989
You type in IPFS colon slash slash, paste that in there.

11203
18:25:11.989 --> 18:25:17.017
And we immediately get dropped into our smart contract lottery in a browser.

11204
18:25:17.017 --> 18:25:32.328
And we see hi from lottery, no raffle address detected, because right now the way I set mine up Was it only works with, you know, our local hard hats, let's connect our Metamask we'll hit the connect button, connect, and voila, we are right back where we were.

11205
18:25:32.328 --> 18:25:38.758
But with our data stored in IPFS, we can enter raffle as long as our node is running a confirm.

11206
18:25:38.758 --> 18:25:42.912
And we see exactly what we get in our local browsers.

11207
18:25:42.912 --> 18:25:46.349
So this is phenomenal.

11208
18:25:46.662 --> 18:25:51.793
Now that I've shown you how to do this, this is the manual way of adding our code to IPFS.

11209
18:25:51.793 --> 18:25:58.412
Let me show you the easier way of adding your code to IPFS we're gonna go to this site called fleek HQ.

11210
18:25:58.412 --> 18:25:59.537
Go to fleek.

11211
18:25:59.537 --> 18:25:59.724
co.

11212
18:25:59.724 --> 18:26:09.876
And to get to it, I'm going to turn my my IPFS companion note off because of some of the oddities with working with brave but now we're here@flickr.

11213
18:26:09.876 --> 18:26:10.400
co fleek.

11214
18:26:10.400 --> 18:26:16.803
co makes it easy to to deploy websites and apps to the new open web permissionless, trustless, censorship resistant, etc.

11215
18:26:16.803 --> 18:26:20.663
I like to think about it as kind of like an auto deployment for our websites.

11216
18:26:20.663 --> 18:26:24.433
And additionally, it does some things to help out with that problem.

11217
18:26:24.433 --> 18:26:28.372
I was talking about how we want to get other nodes to pin our data.

11218
18:26:28.372 --> 18:26:30.098
So it helps us out with that.

11219
18:26:30.098 --> 18:26:31.646
So let me show you what it does.

11220
18:26:31.646 --> 18:26:33.324
So let's go ahead, we'll sign up.

11221
18:26:33.324 --> 18:26:35.968
And why don't you know, you can sign in with GitHub.

11222
18:26:35.968 --> 18:26:39.996
So if you have your GitHub, definitely want to sign in with GitHub here.

11223
18:26:39.996 --> 18:26:45.012
Because we're going to use GitHub to actually help us automatically deploy.

11224
18:26:45.012 --> 18:26:47.741
So we'll authorize fleet to work with our GitHub.

11225
18:26:47.741 --> 18:26:51.598
You've authorized your GitHub, let's go ahead and add a new site or add new site.

11226
18:26:51.598 --> 18:26:56.469
Now we can use fleet to just automatically deploy websites, once we push them to our GitHub.

11227
18:26:56.469 --> 18:26:59.694
So we can come to our GitHub once again.

11228
18:26:59.694 --> 18:27:03.072
And click the little plus button, we'll do a new repository.

11229
18:27:03.072 --> 18:27:08.951
We'll call this next Jas smart contract, lottery Free Code Camp.

11230
18:27:08.951 --> 18:27:13.452
We'll make it public create the repository.

11231
18:27:13.452 --> 18:27:16.329
Let's push all this code to GitHub.

11232
18:27:16.329 --> 18:27:18.281
We did it once before, let's do it again.

11233
18:27:18.281 --> 18:27:29.490
We'll do git add, we'll do a little dot, then we'll do git commit minus m, say like initial commit or whatever.

11234
18:27:29.490 --> 18:27:40.600
We'll do git remote, add origin, and then we'll grab that URL, paste it right here.

11235
18:27:40.600 --> 18:27:44.818
And then we'll just do git push origin, main.

11236
18:27:44.818 --> 18:27:49.464
Now we go back to our application we see it in here we can do is back in our fleek.

11237
18:27:49.464 --> 18:28:00.401
We can connect with GitHub, we're going to say only select repositories, we're only going to do this next js application, this next JS get we're going to install an Authorize.

11238
18:28:00.401 --> 18:28:01.712
Authorize Great.

11239
18:28:01.712 --> 18:28:08.351
So now we're going to pick a repo we've picked a repo, we're going to choose this application.

11240
18:28:08.351 --> 18:28:10.926
And we're going to use IPFS as our hosting service.

11241
18:28:10.926 --> 18:28:13.378
And now we're going to add our information in here.

11242
18:28:13.378 --> 18:28:15.397
So we're going to use the main branch.

11243
18:28:15.397 --> 18:28:16.463
Here's the repo.

11244
18:28:16.463 --> 18:28:20.276
There's gonna be our framework is gonna be next Jas.

11245
18:28:20.276 --> 18:28:22.130
So we're do fleek next.

11246
18:28:22.130 --> 18:28:24.008
Jas, we're using yarn.

11247
18:28:24.008 --> 18:28:30.264
So we're gonna do yarn install, and yarn, run build, and then yarn run export.

11248
18:28:30.264 --> 18:28:36.125
If you want you could also just do yarn, yarn build and yarn run export, those are gonna be the same thing.

11249
18:28:36.125 --> 18:28:44.760
Publish directory is going to be out and then we just hit Deploy site, yarn, next export as the last command, not yarn, run, export.

11250
18:28:44.760 --> 18:28:48.138
The accident did the wrong one, you go over deploys.

11251
18:28:48.138 --> 18:28:55.356
Click on this, go to deploy settings and then Edit Settings and then just change it to yarn.

11252
18:28:55.356 --> 18:28:57.017
Next, export save.

11253
18:28:57.017 --> 18:29:04.914
Then we'll go back to deploys and trigger deploy, if you did the wrong one that was just a learning opportunity for you to learn where the settings are after you deploy.

11254
18:29:04.914 --> 18:29:12.140
And what this is going to do is we're going to do to deploy, it's going to run those three commands yarn build, yarn export, it's going to run everything.

11255
18:29:12.140 --> 18:29:15.051
And then it's going to deploy a site for us both on IPFS.

11256
18:29:15.051 --> 18:29:21.975
And it's going to give a regular URL that we can use for normies, if you will.

11257
18:29:21.975 --> 18:29:29.772
And while this deploys, you'll actually see down here we have this thing called file coin di D in deal proposal, Cid IPFS.

11258
18:29:29.772 --> 18:29:32.936
Like I said, we need other people to host our node.

11259
18:29:32.936 --> 18:29:39.931
File coin is actually a blockchain that helps you pin your data and uses decentralized storage to do so.

11260
18:29:39.931 --> 18:29:47.321
And fleek helps you create those deals and helps you pin your data with this filecoin Blockchain filecoin is one definitely to take a look at.

11261
18:29:47.321 --> 18:29:50.310
And then after a while, you might have to wait a little bit.

11262
18:29:50.310 --> 18:30:00.315
And once it's done, get a little deployed website, we go back to hosting, we click on our thing we can see we have like a little website here.

11263
18:30:00.315 --> 18:30:10.488
And if we click it, we get a normal URL for connecting and interacting with our website, you might even see this little IPFS thing which will connect to your IPFS node.

11264
18:30:10.488 --> 18:30:22.566
And additionally, we scroll down in here we can see current IPFS hash, so we can just stick that in, um, and Bada bing, we have an IP Fs deployed application.

11265
18:30:22.665 --> 18:30:27.465
Now what's cool is let's say I make some changes, you know, I'll go to lottery entrance.

11266
18:30:27.465 --> 18:30:33.923
And I'll do, I'll scroll on the bottom to recent winner, I'll make a new div.

11267
18:30:33.923 --> 18:30:46.474
What a close the div off, we'll save git add dot Git commit minus m, add a dot git push origin mean.

11268
18:30:46.665 --> 18:30:49.798
In our GitHub, we'll do a little refresh, add a.

11269
18:30:50.665 --> 18:30:53.353
recently added one, go back over to fleek.

11270
18:30:54.665 --> 18:31:02.126
click on the section that we just made go to deploys, and you'll see there's a new deploy going through.

11271
18:31:02.126 --> 18:31:07.288
So it automatically deploys your new site, it'll automatically create a new IPFS hash for your new data.

11272
18:31:07.288 --> 18:31:12.327
However, it'll still be on this holy bird, you know, or whatever your URL is here.

11273
18:31:12.327 --> 18:31:15.117
And this is kind of just a router for IPSs.

11274
18:31:15.117 --> 18:31:19.569
So that people without IPFS connected can also connect to this still.

11275
18:31:19.569 --> 18:31:28.447
And now that my application is done, pushing automatically, with fleek, we can see what's up being post in my application here.

11276
18:31:28.447 --> 18:31:34.536
Now, like I said, filecoin isn't going to be a technology, we're gonna go too deep into introduce ourselves.

11277
18:31:34.536 --> 18:31:38.749
But like I was just saying IPFS does have this limitation.

11278
18:31:38.749 --> 18:31:47.411
It doesn't have data persistence, you have to have people pin your data, in order for it to stay distributed, and stay decentralized.

11279
18:31:47.411 --> 18:31:53.416
File coin is a blockchain dedicated to keeping this data, both decentralized and persistent.

11280
18:31:53.416 --> 18:31:56.072
And to give us a better understanding of filecoin.

11281
18:31:56.072 --> 18:31:58.563
We actually have Ali here to give us an overview.

11282
18:31:58.666 --> 18:31:59.838
Take it away, Ali.

11283
18:32:00.666 --> 18:32:07.599
Ali, and I'm a developer advocate here at the filecoin Foundation, which works closely with protocol labs and IPFS.

11284
18:32:07.666 --> 18:32:12.142
Just a quick note, protocol Labs is our r&d arm.

11285
18:32:13.666 --> 18:32:18.607
creating tooling and technology for a truly open and democratic internet and web.

11286
18:32:18.607 --> 18:32:25.993
And it's building out some of the foundational tooling like IPFS, and filecoin, which are two separate projects to enable that.

11287
18:32:25.993 --> 18:32:33.208
And hopefully, today, because you're here to build, I want to impart on you the knowledge and tools you need to get started with both of those projects.

11288
18:32:33.208 --> 18:32:42.156
So as anyone that's kind of played around in this ecosystem, or tech, in general would know, data is an absolutely essential part of our daily lives.

11289
18:32:42.156 --> 18:32:52.253
And not surprisingly, it's also a super fast growing field in web three, and one, that's fundamental one, and it's one of the fundamental necessities of the decentralized web stack as well.

11290
18:32:52.253 --> 18:33:05.158
So the current model of centralization that's grown up, and basically out of a lack of an identity layer on the internet, is one where only a few big companies offer storage, and only a few entities hold our data for authorization purposes.

11291
18:33:05.158 --> 18:33:18.899
And this is an obvious problem, both in terms of being an attack vector for data mining, so without data, getting leaked through insecure service to third parties, and also creating a data resilience problem.

11292
18:33:18.899 --> 18:33:24.070
So whole services go down every time one of these companies servers does and we've definitely seen that.

11293
18:33:24.070 --> 18:33:43.867
So it really leads to the question, why aren't we designing the web for the autonomy and resilience we need in the first place? And how do we store data in a way that aligns with both the original vision of the internet as an open place for knowledge sharing and collaboration, and, and, and in a way that agrees with the web three mission as well.

11294
18:33:43.867 --> 18:33:47.479
So these are the core problems we're solving with IPFS and file coin.

11295
18:33:47.479 --> 18:33:54.602
Firstly, IPFS is a distributed system for storing and accessing files, folders, websites, applications and data.

11296
18:33:54.667 --> 18:34:04.381
And it's designed to be able to work even when the networks between planets, so it's a distributed by design, it has no central authority servers, and it's designed to be offline first for resilience.

11297
18:34:04.381 --> 18:34:07.446
And it's not just a fancy name for another peer to peer network either.

11298
18:34:07.446 --> 18:34:14.042
Because the nice thing about the IPFS protocol is the standard it uses for addressing content on the network.

11299
18:34:14.042 --> 18:34:29.081
IPFS is unique because rather than using traditional methods we might be with familiar with from the web, like those are location parts that point to a particular HTTP address where your content may or may not be available and stored.

11300
18:34:29.081 --> 18:34:41.572
IPFS uses content addressing so content addressing means that each piece of data, each meme or even full file system has its own unique cryptographically verifiable fingerprint, you might call it.

11301
18:34:41.572 --> 18:34:50.340
So if you change even one pixel of your main image, for example, then the content ID or Cid associated with it also changes.

11302
18:34:50.340 --> 18:34:54.068
So importantly, this hash function is also upgradeable.

11303
18:34:54.068 --> 18:34:59.702
So let's say quantum computing breaks out current secure hash algorithms, we can upgrade the standard we use.

11304
18:34:59.702 --> 18:35:04.810
And it means you will always get the same content returned by an IPFS.

11305
18:35:04.810 --> 18:35:06.635
Cid as what you expect.

11306
18:35:06.635 --> 18:35:16.468
So this is fundamentally important, because when you don't have to care where the data comes from, you open up the web to massively distributed storage systems.

11307
18:35:16.468 --> 18:35:18.068
Hello, decentralization.

11308
18:35:18.068 --> 18:35:23.068
So now we have a really important and valuable protocol that enables distribution at scale.

11309
18:35:23.068 --> 18:35:27.603
And it provides verifiability of data to serve and retrieve content on the web.

11310
18:35:27.603 --> 18:35:33.244
And not just for web three, either, but also for all web, or tech use cases.

11311
18:35:33.244 --> 18:35:41.001
The problem is, and it's one that the early internet also faced, who's going to ensure the persistence and permanence of all this data on the network.

11312
18:35:41.001 --> 18:35:48.603
So unless you're running your own nodes 24/7, or your content is really popular or other nodes decide to altruistically store your data.

11313
18:35:48.603 --> 18:35:56.110
Because I think it's important, then this data can become unreliable because they're no longer actively hosted on any nodes on the network's.

11314
18:35:56.110 --> 18:36:02.600
So to avoid this, you could also turn to a pinning service that you pay to keep a copy of your content around.

11315
18:36:02.668 --> 18:36:07.356
Unfortunately, the problem with this though, is that we're heading back towards centralization of data.

11316
18:36:07.356 --> 18:36:13.630
And we're creating new data silos with this solution and losing the trust lessness and resilience we're looking for.

11317
18:36:13.669 --> 18:36:22.106
And these one a bad solution prior to file coin, and it's why they sprung up initially, but we want a better solution.

11318
18:36:22.106 --> 18:36:24.469
So this is where file coin comes in.

11319
18:36:24.469 --> 18:36:37.954
So far coins architecture, then designed to leverage a crypto economic incentive model together with cryptographic proofs in order to ensure data is stored persistently, highly reliably and verifiably.

11320
18:36:37.954 --> 18:36:42.294
It uses these cryptographic proofs to also enable smart contract based permanence.

11321
18:36:42.294 --> 18:36:47.439
And that means that it's designed to be as permanent as you, the data owner want it to be.

11322
18:36:47.439 --> 18:36:49.454
It's your data, so it's your choice.

11323
18:36:49.454 --> 18:36:53.097
It's also designed to enable internet scale capacity.

11324
18:36:53.097 --> 18:37:10.346
It's currently the largest distributed storage network in the world with over 18 million terabytes of capacity available, which is apparently about 135 copies of the European Union's nuclear program, CERN's data which, which is kind of a fun fact.

11325
18:37:10.346 --> 18:37:19.259
It's also file coins also designed to be and stay hyper competitive on pricing due to its market economics.

11326
18:37:19.259 --> 18:37:21.914
And this comes down to storage deals.

11327
18:37:21.914 --> 18:37:26.135
So to make this network feasible, filecoin uses storage deals.

11328
18:37:26.135 --> 18:37:33.446
And these include two main consensus mechanisms that ensure both rewards for good actors in the system, and penalties for bad actors.

11329
18:37:33.446 --> 18:37:40.356
So when you make a deal with one or more storage providers to store your important data, the provider generates a proof of replication.

11330
18:37:40.356 --> 18:37:50.566
So this proves that the storage provider is storing a unique copy of your original data over time to make sure that this data is persisted.

11331
18:37:50.566 --> 18:37:58.447
These storage providers must prove that they still have random subsets of this client data and they create proof of space times.

11332
18:37:58.447 --> 18:38:05.161
And these proof this proof of space time is something that is stored on the blockchain.

11333
18:38:05.161 --> 18:38:07.936
So anyone at any time can also check that this is true.

11334
18:38:07.936 --> 18:38:18.884
And it also makes up the mechanism by which miners are rewarded or penalized because you have to stake Phil on the network in order to become a storage provider.

11335
18:38:18.884 --> 18:38:25.911
So when a storage deal comes to an end, or user can you can opt to let it expire or renew the deal.

11336
18:38:25.911 --> 18:38:30.336
If you opt for renewal, then the providers again bid to host this content.

11337
18:38:30.336 --> 18:38:35.741
So this creates an efficient market for pricing a continual efficient market for pricing as well.

11338
18:38:35.741 --> 18:38:37.455
It can even go negative.

11339
18:38:37.455 --> 18:38:47.807
So the storage provider can even pay you to store your data if it's an important data set due to some of the block rewards that are being offered by the filecoin Foundation as well.

11340
18:38:47.807 --> 18:38:55.873
So these mechanisms are what built in not just data permanence, but data timeframes, sovereignty, too so it's your data, it's your choice.

11341
18:38:55.873 --> 18:38:59.073
You can decide you want to store your data for five minutes or 500 years.

11342
18:38:59.073 --> 18:39:08.479
It's also your choice over how much resilience you want to have that data so or how many copies of that data you want to have and with what store to providers.

11343
18:39:08.479 --> 18:39:13.231
So this allows you to comply with regulations like GDPR.

11344
18:39:13.231 --> 18:39:20.373
And there's a growing number of tools in the ecosystem like murmurations bit screen that are allowing for you to do this filtering.

11345
18:39:20.373 --> 18:39:29.961
But it also gives you some guarantees that your data, you know, if one storage provided goes down, you know, surely not 10 of them are going to go down.

11346
18:39:29.961 --> 18:39:34.580
So that's a guarantee for your resilience there as well.

11347
18:39:34.671 --> 18:39:37.583
And this is why IPFS and filecoin are great complements of each other.

11348
18:39:37.583 --> 18:39:48.785
So IPF s gives you that benefit of content addressing file coin gives you persistent guarantees that even if your computer or your favorite IPFS pinning service where to go away, the content persists.

11349
18:39:48.785 --> 18:39:55.355
Just as a quick final note on these concepts as well, IPFS and file coin is separate projects, as I mentioned.

11350
18:39:55.355 --> 18:40:01.153
So IPFS is a protocol much like HTTP, whereas file coin is a blockchain.

11351
18:40:01.153 --> 18:40:06.705
So IPFS is also storage layer agnostic, you can combine it with the storage layer of your choice.

11352
18:40:06.705 --> 18:40:16.750
And while file coin was specifically designed to complement it, and we think is a great choice, you can also store your IPFS data in the cloud or an other storage solutions as well.

11353
18:40:16.750 --> 18:40:21.852
So hopefully, you've got a good baseline for why you'd want to use IPFS, and filecoin.

11354
18:40:21.852 --> 18:40:40.889
And for those engineers out there that like a challenge, and are interested in working on the base protocols and code of IPFS, and file coin, which isn't always easy for the average user, I'd encourage you to go and take a look at the project docs and get hubs and some of the associated grants available for extensions to these open source projects.

11355
18:40:40.889 --> 18:40:48.380
And this is a great site here if you want to get more information into the nitty gritty and really dig into the code behind IPFS and filecoin.

11356
18:40:48.380 --> 18:40:49.867
And extend some of that.

11357
18:40:49.867 --> 18:40:52.956
For those of you that just want to build out of the box though.

11358
18:40:52.956 --> 18:40:55.479
And this is definitely a camp that I often fall into.

11359
18:40:55.479 --> 18:41:00.132
I want to talk about some of the dev tooling and storage helpers that make it easy for you to get started.

11360
18:41:00.132 --> 18:41:03.441
So firstly, Flake Flake is one of my favorite IPFS dev tools.

11361
18:41:03.441 --> 18:41:17.214
And projects Flake is a CI CD tool that you can use to deploy your apps for free as simply as easy as you would with some of the web tools you might web to tools you might be familiar with like Netlify oversell.

11362
18:41:17.214 --> 18:41:21.817
The big difference, though, is fleek uses IPFS to host your site or app.

11363
18:41:21.817 --> 18:41:24.901
And it even offers an AES domain routing on their platform.

11364
18:41:24.901 --> 18:41:33.606
So if you're deploying a front end app, I would encourage you to use fleek to make it more distributed instead of some of the traditional web two tools.

11365
18:41:33.672 --> 18:41:35.395
It's just as easy, I promise.

11366
18:41:37.672 --> 18:41:49.636
is NFT storage, storing your NFT metadata immutably and persistently, as you already probably know, is integral to keeping the main value proposition of NF Ts, then on fungibility.

11367
18:41:49.636 --> 18:42:00.783
So if you're not storing this data on chain, which obviously can become pretty financially unviable for large files, then this is exactly where NF T storage comes in.

11368
18:42:00.783 --> 18:42:05.542
So it was specifically created as a public good to archive and persist NF T data.

11369
18:42:05.542 --> 18:42:06.380
So it's free.

11370
18:42:06.380 --> 18:42:16.768
And it takes care of the complexity around firstly creating an IPFS Cid for this metadata, and then making automatic deals with filecoin storage providers.

11371
18:42:16.768 --> 18:42:19.982
So it does this with at least eight storage providers.

11372
18:42:19.982 --> 18:42:23.442
So eight times redundancy and it does it with a multigenerational timeframe.

11373
18:42:23.442 --> 18:42:25.917
So it automatically renews those deals.

11374
18:42:25.917 --> 18:42:28.376
Because it's a public good, it's all free as well.

11375
18:42:28.376 --> 18:42:33.688
And it's also super easy to use, because you just need because it's a JavaScript service.

11376
18:42:33.688 --> 18:42:43.672
So you just need to say import that as an NPM package or JavaScript library and then call the API and NFT dot storage takes care of the rest.

11377
18:42:43.672 --> 18:42:53.355
For data that isn't NF T metadata as well, we built web three dot storage, web three storage is designed to give you those same web two benefits.

11378
18:42:53.355 --> 18:42:57.012
So similar to NF T dot storage, make it super easy for you to use.

11379
18:42:57.012 --> 18:43:02.445
And it's got JavaScript and go client libraries.

11380
18:43:02.673 --> 18:43:12.869
While giving you you know the power of IPFS and filecoin of decentralized storage and IPFS content addressing so it's got one terabyte after terabyte, one terabyte of free storage with that.

11381
18:43:12.869 --> 18:43:16.983
So try that out if you're not just like trying to store and obtain metadata.

11382
18:43:16.983 --> 18:43:19.534
The next tool is a bit more advanced.

11383
18:43:20.673 --> 18:43:30.735
It's called textil Palghat gate, and it's for you know, more advanced developers or those looking for more flexibility to interact with IPFS live peer to peer and filecoin.

11384
18:43:30.735 --> 18:43:35.101
It's a Docker container wrapped around filecoin and IPFS nodes.

11385
18:43:35.101 --> 18:43:39.731
And it gives you a lot of options to configure it's a minor selections and extend functionality.

11386
18:43:39.731 --> 18:43:45.863
It also offers some bridges to several layer ones which might be of interest to developers out there.

11387
18:43:45.863 --> 18:43:52.043
Another one here and I'll preface this by saying you need an invite to this is ESRI tech.

11388
18:43:52.043 --> 18:43:56.266
So it's for people looking to store really meaningful public data.

11389
18:43:56.266 --> 18:44:05.535
It's currently in alpha mode and like I said, it requires an invite because it's been built as a public goods specifically to store important information.

11390
18:44:05.535 --> 18:44:12.266
If you are I do have Use case around this slide, please feel free to reach out to us on this project.

11391
18:44:12.266 --> 18:44:15.825
Other final tool I'll mention is orbit dB.

11392
18:44:15.825 --> 18:44:28.639
So many people coming to the web three space from web two are often looking for the same sort of relational databases that we're so used to in traditional computing except in a decentralized or distributed format.

11393
18:44:28.639 --> 18:44:31.042
And this isn't an easy problem.

11394
18:44:31.042 --> 18:44:33.568
So Oba to me is currently in active development.

11395
18:44:33.674 --> 18:44:41.351
And because this isn't an easy problem to solve, this isn't an ideal solution for those of you looking for an out of the box experience.

11396
18:44:41.351 --> 18:44:45.460
But if you are looking for something like that, try out orbit dB.

11397
18:44:45.460 --> 18:44:56.983
And there's also several other tools in the ecosystem leveraging IPFS and filecoin, including ceramic, which is similar to textil power gate, except it uses decentralized identities.

11398
18:44:56.983 --> 18:45:04.581
Lighthouse is file drive, and there's even Morales has an IPFS API, so check those out as well.

11399
18:45:04.674 --> 18:45:08.601
So storage is really a fundamental component on one technology system.

11400
18:45:08.601 --> 18:45:11.726
So and there's so many use cases you could dive into here.

11401
18:45:11.726 --> 18:45:17.377
And so hopefully, I've provided you with some of the knowledge and tools you need to get started with IPFS and file Goyt.

11402
18:45:17.377 --> 18:45:21.388
Coin and really make powerful distributed applications.

11403
18:45:21.388 --> 18:45:25.768
And there's just one more tool that's also in active development now.

11404
18:45:25.768 --> 18:45:31.424
So if you look closely at this diagram, you'll notice probably unfamiliar logo right at the end of the logic layer.

11405
18:45:31.424 --> 18:45:34.397
And that's the logo for the filecoin virtual machine.

11406
18:45:34.397 --> 18:45:37.448
So FBM will be launching at the end of this year.

11407
18:45:37.448 --> 18:45:39.577
And we're super excited about it.

11408
18:45:39.577 --> 18:45:51.480
And it's going to allow smart contracts, contract use combined with like colocation of storage data, loads, so computing capabilities with storage capabilities, and will also be EVM compatible.

11409
18:45:51.480 --> 18:45:58.074
So as I said, we're super excited for the kinds of use cases that we're going to see come out of this project as well.

11410
18:45:58.074 --> 18:46:02.372
And you can follow along here on the website here as well.

11411
18:46:02.372 --> 18:46:05.957
So hopefully, I've given you all the tools you need to get started with IPFS.

11412
18:46:05.957 --> 18:46:07.013
And file coin.

11413
18:46:07.013 --> 18:46:14.626
If you do need more resources or want to get involved, we have proto School, which is interactive tutorials on decentralized web protocols.

11414
18:46:14.675 --> 18:46:20.675
There's also NFT, school dot Dev, or join a hackathon, check out our hackathons.

11415
18:46:20.675 --> 18:46:21.119
filecoin.

11416
18:46:21.119 --> 18:46:24.029
io page for all the latest hackathons we're involved in.

11417
18:46:24.029 --> 18:46:42.515
And if you do really want to dig deep and build tooling in IPFS, and file coin or build a cool project, check out our grants options as well for that, in the meantime, all please learn long build and prosper.

11418
18:46:42.675 --> 18:46:45.295
So we've learned a ton in this section.

11419
18:46:45.295 --> 18:46:46.329
And that is it.

11420
18:46:46.675 --> 18:46:50.013
let's do a summary of all the amazing things that we've learned.

11421
18:46:50.013 --> 18:46:56.165
And then we'll go into the TypeScript edition of this because the TypeScript edition is definitely a little bit different.

11422
18:46:56.165 --> 18:46:56.928
So let's talk.

11423
18:46:56.928 --> 18:46:59.435
Alright, so first, we learned more about next Jas.

11424
18:46:59.435 --> 18:47:02.379
And we learned we can have an application using next Jas.

11425
18:47:02.379 --> 18:47:09.045
And it's a framework that's gonna allow us to build really powerful front ends and full stack applications really easily.

11426
18:47:09.045 --> 18:47:23.175
We learned about the layout of our next JS project, we add components in a components folder, which are basically minimalistic blocks of JavaScript and HTML that we can use to modularize and create our website out of these components.

11427
18:47:23.175 --> 18:47:28.982
Constants is a folder that we can put constant variables, Node modules is node modules.

11428
18:47:28.982 --> 18:47:30.043
And out folders.

11429
18:47:30.043 --> 18:47:38.933
What happens when we export all of our code to a static example, pages are going to be basically the routes or the different pages of our website, everything goes through app.

11430
18:47:38.933 --> 18:47:39.105
js.

11431
18:47:39.105 --> 18:47:46.263
Public is just some public stuff styles is for any CSS or styling of our application.

11432
18:47:46.263 --> 18:47:49.342
And then we have our basic files here.

11433
18:47:49.342 --> 18:48:02.342
In our pages section, we have our app, which is surrounded by both this notification provider and our Morales provider, all of our components run through this app on all of our pages run through this app.

11434
18:48:02.342 --> 18:48:07.151
So this is kind of considered the entry point for our entire application.

11435
18:48:07.151 --> 18:48:16.376
Having this Morales provider wrapped around our notifications in component means that we don't have to pass parameters between our components.

11436
18:48:16.376 --> 18:48:26.120
And our lottery will just know what chain ID that we're on, because our header is going to pass it up to Morales provider and the Morales provider is going to pass it back down to our lottery entrance.

11437
18:48:26.120 --> 18:48:30.971
And we saw with our manual header, the way that that connect button works behind the scenes.

11438
18:48:30.971 --> 18:48:44.390
So it's doing some local storage, where we're storing whether or not we're actually connected, we learned about use effect, and you state and these different hooks in our front ends were one of the main reasons we want hooks is we want we want our websites to rerender.

11439
18:48:44.390 --> 18:48:50.914
When stuff changes, we want our components to be able to talk about the state of the blockchain with each other.

11440
18:48:50.914 --> 18:48:54.176
And they're incredibly powerful for building our React applications.

11441
18:48:54.176 --> 18:49:07.743
Use effect is one of the most popular ones where if we don't have a dependency array, our function inside of our use effect will run anytime something re renders a blank dependency array means it'll just run once on load.

11442
18:49:07.743 --> 18:49:14.596
And if there are dependencies in the array, it'll run any time any of the variables in those change.

11443
18:49:14.676 --> 18:49:21.003
We also learned about the use state hook, which is really similar to saying like, let variable equals x.

11444
18:49:21.003 --> 18:49:23.455
But it also comes with the RE rendering ability.

11445
18:49:23.455 --> 18:49:30.238
And it comes with some other nice abilities that we didn't really discuss here, we learned how to call different contract functions with mirallas.

11446
18:49:30.238 --> 18:49:33.880
Not only sending transactions, but also calling data.

11447
18:49:33.880 --> 18:49:40.042
Morales is smart enough to know that when it sees get entrance fee that this is going to be a view function.

11448
18:49:40.042 --> 18:49:43.005
And this is going to be a transaction, it can tell the difference between the two.

11449
18:49:43.005 --> 18:49:45.395
So this one's going to populate Metamask to pop up.

11450
18:49:45.395 --> 18:50:09.333
And this one just going to return kind of normally like a view function, what we can actually use the same syntax between sending transactions and then calling view functions on our contract, we added a button, calling one of these Morales pieces and then had an onsuccess section where when our transaction completed, we update the UI and we add a little pop up for notifications, we learned how to deploy our code directly to IPFS.

11451
18:50:09.333 --> 18:50:18.927
And use that IPFS hash to interact and see our code, we also learned about fleek and how fleek automatically deploys to IPFS.

11452
18:50:18.927 --> 18:50:26.086
Whenever we do a git push to our GitHub repository, and it makes continuously updating our websites much easier.

11453
18:50:26.086 --> 18:50:29.257
It also gives us a regular canonical URL as well.

11454
18:50:29.257 --> 18:50:33.621
And then finally, we learned about IPFS and decentralized database storage.

11455
18:50:33.677 --> 18:50:51.581
Now you might be asking, Okay, well, why don't we just store all the data for this website on Aetherium, or polygon or avalanche, etc? And the answer to that is that can get incredibly expensive storing data, storing a ton of data on the blockchain costs a ton of gas, whereas this is a much cheaper alternative.

11456
18:50:51.581 --> 18:51:04.935
Aetherium avalanche and the smart contract platforms aren't really meant to be data storage layers, they're meant to be logic layers, right? Decentralized logic, decentralized smart contracts, oftentimes, yes, we're gonna have to store data in them.

11457
18:51:04.935 --> 18:51:07.355
But when it's a ton of data, there are better solutions.

11458
18:51:07.355 --> 18:51:19.267
And there are different solutions out there for storing our data, like IPFS and filecoin, you should be incredibly proud of yourself, if you've made it this far, because you've just made a really solid app, a really solid front end application.

11459
18:51:19.267 --> 18:51:24.474
And you've learned how to really easily add functionality for interacting with your smart contracts.

11460
18:51:24.474 --> 18:51:30.626
So give yourself a pat on the back, maybe even tweet this out, share this really cool application with your friends and family.

11461
18:51:30.678 --> 18:51:32.598
Take a break.

11462
18:51:38.678 --> 18:51:42.130
All right, welcome to one of the fastest lessons that we're going to have here.

11463
18:51:42.130 --> 18:51:45.152
And in this lesson, we're going to talk about the hardhat starter kit.

11464
18:51:45.152 --> 18:51:48.801
Really quickly, I'm going to walk you through it and show you how to use it.

11465
18:51:48.801 --> 18:51:54.066
Now we've learned a lot about projects, we've learned a lot about different repos, learnt the basics of smart contracts.

11466
18:51:54.066 --> 18:51:58.505
And we've learned a lot about front end as well and building front ends for applications.

11467
18:51:58.505 --> 18:52:07.898
So this smart contract kit repo comes packed with a ton of starter kits that you can use to start deploying your projects right away.

11468
18:52:07.898 --> 18:52:14.203
And as you can see, that hard hat starter kit is easily one of the most popular ones with the most stars the most forks out there.

11469
18:52:14.203 --> 18:52:34.290
The smart contract kit repo actually comes with a ton of frameworks, like if you want to work with SWANA, if you want to work with Python and Brownie, if you want to work with foundry, truffle, really any other framework out there, you can get started, clone one of these repos, work with one of these repos and build your project and get started right away, we're going to show you how to use the hard hat starter kit.

11470
18:52:34.290 --> 18:52:46.264
So you can just grab the repo and go and already have some boilerplate code and a boilerplate really good looking repo to start your projects with, we come to the smart contract kit, hard hat starter kit repo here.

11471
18:52:46.264 --> 18:52:53.679
And if you're working with GitHub, you can just go ahead and use this template and it will automatically generate you a new GitHub repo with the hardest starter kit.

11472
18:52:53.679 --> 18:53:03.306
So let's go ahead, we'll click use this template, we come up with our own name here, we'll call it make it public create repository from Template.

11473
18:53:03.306 --> 18:53:05.658
it'll generate our repository.

11474
18:53:05.658 --> 18:53:09.575
And now we automatically have it in our own repo here.

11475
18:53:09.575 --> 18:53:11.397
And we can get started working with it.

11476
18:53:11.397 --> 18:53:12.615
And we can get started working with it.

11477
18:53:12.679 --> 18:53:16.743
If you don't want to click the use that template button, we can also just copy the URL.

11478
18:53:16.743 --> 18:53:20.329
And in our code editor, we can just do git clone and paste that in there.

11479
18:53:20.329 --> 18:53:25.804
So for now, I am going to get clone, but I'm going to get clone with this repo that we just created.

11480
18:53:25.804 --> 18:53:32.187
Come back in with the git clone, hard hat play FCC or hard hat starter kit.

11481
18:53:32.187 --> 18:53:37.760
We're going to cd into our head play FCC, and then open that up in a new code editor.

11482
18:53:37.760 --> 18:53:38.546
And awesome.

11483
18:53:38.679 --> 18:53:48.488
Now you'll see in this repo, it comes packed with a ton of contracts, deployments, scripts, tasks, test, everything, you name it to really get started in a professional environment.

11484
18:53:48.488 --> 18:53:53.763
We look in the contract section, we can see we have a couple of sample contracts.

11485
18:53:53.763 --> 18:54:03.138
We have a contract for making an API call to a chain link node, working with keepers working with price feeds, and then working with chain link Vir Fe two.

11486
18:54:03.138 --> 18:54:18.279
We've got some test contracts and we additionally have this fuzzing folder, which we'll talk talk about in a much later section of this course, we have deployed scripts where we start with deploying mocks, then we deploy each one of those contracts, we have a sample script to read the price from one of these contracts.

11487
18:54:18.279 --> 18:54:21.079
And we have a whole bunch of sample tasks.

11488
18:54:21.079 --> 18:54:23.933
Now at the time of recording, instead of scripts, this repo uses tasks.

11489
18:54:23.933 --> 18:54:26.373
But again, they're a little bit interchangeable.

11490
18:54:26.373 --> 18:54:39.024
And of course, we have some unit tests and some staging tests as well, that you can go through and take a look at, once we're in this repo, we can run some familiar commands here, we'll do yarn, of course, to install our all of our packages.

11491
18:54:39.024 --> 18:54:44.130
And then everything that we're going to do, if you get lost, you can always come back to this repo.

11492
18:54:44.130 --> 18:54:46.939
And you can follow along with getting started and the Quickstart.

11493
18:54:46.939 --> 18:54:48.280
So we just did the git clone.

11494
18:54:48.280 --> 18:54:52.764
Now we're doing the yarn, and then we're gonna go ahead and run yarn hard hat test.

11495
18:54:52.764 --> 18:55:05.180
This hard hat starter kit repo is very consistently up to date, we did the last push being just a few days ago, and will constantly have some best practices for building our smart contracts and having a really professional coding environment.

11496
18:55:05.180 --> 18:55:06.883
And it's got this really cute logo.

11497
18:55:06.883 --> 18:55:19.470
Once we've installed all the dependencies, we can run yarn, art hath test, we can run all of the tests in the test folder, which also will show us how to interact and how to use all these different contracts in here.

11498
18:55:19.470 --> 18:55:26.346
And they each have some console dot log, so you can see more about what's actually going on when these tests actually run.

11499
18:55:26.346 --> 18:55:28.970
If we look in the Hardhead config.

11500
18:55:28.970 --> 18:55:44.608
js, it's got some really familiar code in here, we have all our imports at the top, we grab a whole bunch of environment variables, we've got the ether scan plugin, we've got the gas reporter, the contract sizer, which is a plugin that tells you how big your contracts are.

11501
18:55:44.608 --> 18:55:48.489
So named accounts, different solidity versions, and then mocha timeout as well.

11502
18:55:48.489 --> 18:56:14.146
We can of course, do yarn hard hat node, which will run through our deploy scripts, and then spin up a new note for us, which has mock chainlink tokens, mock Oracle's mock aggregators, and mock up VRF for us to go ahead and interact with once that's up, we can then of course, to hard hat, console, dash dash network localhost, and begin interacting with contracts on localhost.

11503
18:56:14.146 --> 18:56:29.538
So we can kind of follow along with price feed, for example, and do const price consumer B three equals await ethers dot get contract, price, consumer V three.

11504
18:56:29.681 --> 18:56:35.181
And then we can do await price consumer B three dot get latest price.

11505
18:56:35.181 --> 18:56:38.281
Let's wrap that in a to string.

11506
18:56:38.281 --> 18:56:43.926
And we can see a mock latest price from a contract that uses channeling price feeds.

11507
18:56:43.926 --> 18:56:49.415
And we can interact with any of our contracts and work with any of the mocks as well in here.

11508
18:56:49.415 --> 18:57:01.612
If we want to deploy this to an actual test net like Rinckey, or main net will just pop in our dot env file, we'll close our node terminal, and we can run yarn hardhat or just hh deploy.

11509
18:57:01.612 --> 18:57:04.784
And then we'll add whatever tags we want to do here.

11510
18:57:04.784 --> 18:57:06.557
So let's just deploy our price feed contract.

11511
18:57:06.557 --> 18:57:10.616
If we go to the price feed deploy, we scroll down, we'll get the tags.

11512
18:57:10.616 --> 18:57:18.600
Okay, great, we'll use the feed tag, dash tags feeds dash to or feed dash dash network brings beam.

11513
18:57:18.681 --> 18:57:22.270
And while we're waiting for this to deploy, we can go back to the actual repo.

11514
18:57:22.270 --> 18:57:30.759
And just make sure to follow along with the documentation here and the Quickstart in all the usage and everything so that you make sure that you're working with the most up to date version.

11515
18:57:30.759 --> 18:57:37.131
There's even documentation on running a local network using a test net or live network working with Aetherium.

11516
18:57:37.131 --> 18:57:53.927
Rigby adding your private keys and dotting envies all this stuff that you already know, forking, which we'll learn a little bit later, auto funding your contracts for working with chain link API running tests, you can additionally run your tests in parallel by adding the dash dash parallel flag to our tests.

11517
18:57:53.927 --> 18:58:02.632
We can interact with our deployed contracts with those different tasks that we've created linting code formatting, estimated gas code coverage fuzzing, we'll talk about later.

11518
18:58:02.682 --> 18:58:04.173
And then contributions.

11519
18:58:06.682 --> 18:58:16.313
And once it's outputted, and even verified, if you have verification turned on, you'll get a little task that we can run to just go ahead and read the price feed or interact with the contract.

11520
18:58:16.313 --> 18:58:17.839
So we can copy that task out.

11521
18:58:17.839 --> 18:58:18.523
Yarn hardhat.

11522
18:58:18.682 --> 18:58:24.878
Read price feed since it's a task here, contract the contract data which we just deployed network Rigby.

11523
18:58:24.878 --> 18:58:36.364
And we'll get reading data price feed from consumer contract on network, Rigby price is here, which of course, we're saying the price of Aetherium is $3,033, because it has eight decimal places.

11524
18:58:36.364 --> 18:58:43.391
So if you're ever looking to start a new project, and you want some boilerplate code, this hard hat Starter Kit is a great place to get started.

11525
18:58:43.391 --> 18:58:49.635
And of course, you can open it and get pod if you want to just test it out and try it and get pot in a Cloud Shell.

11526
18:58:49.682 --> 18:58:51.082
So that's it for this lesson.

11527
18:58:51.082 --> 18:58:51.932
Wasn't that fast.

11528
18:58:52.682 --> 18:58:53.699
fastest lesson ever.

11529
18:58:55.682 --> 18:59:08.475
learnings here, I would fork this I would clone this I would use this template, try to play around with the repo a little bit yourself and see what you recognize, see what you don't recognize and keep that prepped in your mind for later so Questions in the course.

11530
18:59:08.475 --> 18:59:15.488
And then for everyone here who is TypeScript, there is, of course, a TypeScript version of this as well that you can get cloned.

11531
18:59:15.488 --> 18:59:19.617
And it has a nice blue logo here to show that it's a little bit different.

11532
18:59:19.617 --> 18:59:24.895
So, that being said, use the repo, have fun.

11533
18:59:24.895 --> 18:59:29.299
Let's get to lesson 12.

11534
18:59:29.683 --> 18:59:32.830
Alright, now we're moving on to the hard hat ERC.

11535
18:59:33.683 --> 18:59:49.812
section where we're going to learn how to create our own ERC 20 or EIP 20 Or B E P 20 or AEP 20 any of these tokens on the blockchain before we can understand what an ERC 20 is, or even what one of these tokens are, we first need to understand what is an ERC.

11536
18:59:49.812 --> 18:59:55.450
And then also what is an EIP in Aetherium, and avalanche and finance and polygon.

11537
18:59:55.450 --> 18:59:58.683
All these blockchains have what's called improvement proposals.

11538
18:59:58.683 --> 19:00:03.612
And for Aetherium, they're called Aetherium improvement proposals, or E IPs.

11539
19:00:03.683 --> 19:00:13.016
And what people would do is they come up with these ideas to improve Aetherium or improve these layer ones like polygon, Matic avalanche, etc.

11540
19:00:13.016 --> 19:00:21.083
And on some GitHub or some open source repository, they'll add these new EIP is they'll add these new improvement ideas to make these protocols better.

11541
19:00:21.083 --> 19:00:31.269
Now, these improvements can really be anything, they can be anything from a core blockchain update to some standard, that is going to be a best practice for the entire community to adopt.

11542
19:00:31.269 --> 19:00:38.328
Once an EIP gets enough insight, they also create an E RC, which stands for Aetherium request for comments.

11543
19:00:38.328 --> 19:00:43.616
So EIP a theory and improvement proposals ERC a theory and request for comments.

11544
19:00:43.683 --> 19:00:47.933
And again, these can be like BP, Pep, you know, etc.

11545
19:00:48.683 --> 19:00:50.055
these different blockchains.

11546
19:00:51.683 --> 19:01:05.521
and the Request for Comments, all have these different tags, now they're numbered chronologically, so something like an ERC 20 is going to be the 20th ERC slash EIP, the ERC is and the EFPs share that same number.

11547
19:01:05.521 --> 19:01:08.360
And there are websites like EIP is that aetherium.

11548
19:01:08.360 --> 19:01:16.699
org That keep track of all of these new Aetherium improvement proposals, and you can actually see them real time go through the process of being adopted by the community.

11549
19:01:16.699 --> 19:01:23.934
Now, one of these e IPs or ERC is, is going to be the ERC 20 or the token standard for smart contracts.

11550
19:01:23.934 --> 19:01:30.897
This is an improvement proposal that talks about how to actually create tokens and create these smart contract tokens.

11551
19:01:30.897 --> 19:01:32.287
I made a video about this recently.

11552
19:01:32.287 --> 19:01:40.311
So in the GitHub repo associated with this course, we're going to have a sub lesson, and we're going to watch a quick video that explains more about these different tokens.

11553
19:01:40.311 --> 19:01:55.350
Now first, let's define even what are ERC 20s So ERC 20s are tokens that are deployed on a chain using what's called the ERC 20 token standard, you can read more about it in the year 20 token standard here link in the description as well.

11554
19:01:55.350 --> 19:01:59.054
But basically, it's a smart contract that actually represents a token.

11555
19:01:59.054 --> 19:02:01.395
So it's token or the smart contract.

11556
19:02:01.395 --> 19:02:09.160
It's both it's really cool tether chainlink unique token and dye are all examples of ERC 20s Technically, chain link is in the ERC.

11557
19:02:09.160 --> 19:02:15.836
677 as there are upgrades to the ERC 20 that some tokens take that are still backwards compatible with ERC.

11558
19:02:15.836 --> 19:02:20.756
20s And so basically, you can think of them as ERC 20s with a little additional functionality.

11559
19:02:20.756 --> 19:02:24.913
Now why would I even care to want to make an ERC 20 Well, you can do a lot of really cool stuff with it.

11560
19:02:24.913 --> 19:02:32.102
You can make governance token, you can secure an underlying network, you can create some type of synthetic acid, or really anything else.

11561
19:02:32.102 --> 19:02:48.406
In any case, how do we build one of these ERC? 20s How do we build one of these tokens? Well, all we have to do is build a smart contract that follows the token standard, all we have to do is build a smart contract that has these functions that has a name function, symbol function, decimals function, etc.

11562
19:02:48.406 --> 19:02:52.399
All these functions we need to be able to transfer it, we need to be able to get the balance of it etc.

11563
19:02:52.399 --> 19:03:00.455
And again, if you want to check out some of the improvements that are still ERC 20 compatible, like the ERC 677 or the ERC 777.

11564
19:03:00.455 --> 19:03:05.650
Definitely go check those out and build one of those instead.

11565
19:03:05.650 --> 19:03:07.136
All right, awesome.

11566
19:03:07.136 --> 19:03:15.600
Now that we know what one of these ERC 20s is, we can go ahead and create our own per usual in the GitHub repo associated with this course.

11567
19:03:15.600 --> 19:03:16.943
We have all the code available here.

11568
19:03:16.943 --> 19:03:18.878
If you want to just get clone.

11569
19:03:18.878 --> 19:03:22.077
This is going to be again another one of our quicker lessons here.

11570
19:03:22.077 --> 19:03:23.072
So we're in our terminal.

11571
19:03:23.072 --> 19:03:24.330
We're in our VS code here.

11572
19:03:24.330 --> 19:03:26.528
We're going to make a new directory.

11573
19:03:26.528 --> 19:03:33.193
I'm going to call it hard hat ERC 20 FCC will cd into hard hat, your C 20 sec.

11574
19:03:33.193 --> 19:03:40.409
And we're going to create a new hard hat project the exact same way we've been doing it yarn add dash dash dev or tab.

11575
19:03:40.409 --> 19:03:45.330
Let's actually open it in its own VS code will do code.

11576
19:03:45.330 --> 19:03:47.652
or file open this folder.

11577
19:03:47.652 --> 19:03:50.410
And okay, we're in our project now.

11578
19:03:50.410 --> 19:03:52.151
Let's create a new hard hat project.

11579
19:03:52.151 --> 19:03:55.485
We'll do yarn, art hats.

11580
19:03:55.685 --> 19:03:59.930
We'll do create an empty hard hat dot config dot j s here and great.

11581
19:03:59.930 --> 19:04:02.438
We've now got an empty hard hat dot config dot j s.

11582
19:04:02.438 --> 19:04:15.488
If you want to copy paste your hard hat dot config from a previous projects you want to copy paste your heart Have dot config or your dot EMV file, because you know we're going to need those feel free to do so now, I'm just going to update this to 8.

11583
19:04:15.488 --> 19:04:15.553
7.

11584
19:04:15.685 --> 19:04:18.057
I'll add the rest of my stuff later.

11585
19:04:19.685 --> 19:04:21.081
EIP 20, or this ERC 20.

11586
19:04:23.685 --> 19:04:33.419
in its token standard so that we can transfer tokens, we can do all the stuff in the ERC 20 contract itself, it really is just keeping track of how much of each token people have.

11587
19:04:33.419 --> 19:04:36.892
So the smart contract, kind of in a weird way it keeps track of itself.

11588
19:04:36.892 --> 19:04:39.341
To get started, we're going to do this kind of the manual way.

11589
19:04:39.341 --> 19:04:46.892
First, we're going to create our own manual token here, or a really minimalistic one anyways, so let's create a new folder.

11590
19:04:46.892 --> 19:04:53.574
contracts will create a new file called manual token dot soul.

11591
19:04:53.574 --> 19:04:59.876
Yes, I'm going to show you kind of the hard way to make it and then I'll show you a much easier way to make it.

11592
19:04:59.876 --> 19:05:07.876
So to get started here are usual we can do pragma, solidity to carrot zero, point 8.

11593
19:05:07.876 --> 19:05:07.971
7.

11594
19:05:07.971 --> 19:05:19.419
And then we'll even do spdx, license identifier, MIT do contract, manual token, and boom, let's get started.

11595
19:05:19.419 --> 19:05:26.266
The main reason this token smart contract works is that there's some balances mapping.

11596
19:05:26.266 --> 19:05:31.195
So we have a mapping of addresses to you in 256.

11597
19:05:31.195 --> 19:05:43.744
And it's usually public called balance of and all this does is this mapping is obviously the key is going to be every single address on the planet, and then how much they have.

11598
19:05:43.744 --> 19:05:55.156
And basically, when we transfer tokens, transfer tokens, we're basically just subtract from address, amount, and add to to address.

11599
19:05:55.156 --> 19:06:00.855
So a really minimalistic way to implement this would be to create this transfer function first.

11600
19:06:00.855 --> 19:06:10.936
So we'll create this function, I'm going to call it underscore transfer, we can do an address from address to you into fifth sixth mount.

11601
19:06:10.936 --> 19:06:16.801
And now we'd probably put some requirements, we probably omit some events, and let's make this public as well.

11602
19:06:16.801 --> 19:06:43.409
And really, at the end of the day, is we're gonna say balance of from minus equals value, which is the same as saying bounce of from equals bounce from minus value, or excuse me, amount, and then we're gonna say balance of two, excuse me, plus equals, which is the same as saying, you know, balance of two plus.

11603
19:06:43.409 --> 19:06:50.916
And technically, that's really all we need, right, we probably want to do some asserts ins here, some requires to make sure all of our numbers make sense.

11604
19:06:50.916 --> 19:06:55.287
But really, at the end of the day, this is all that this function is doing.

11605
19:06:55.287 --> 19:07:00.618
Transfer works when the caller is sending money directly into another address.

11606
19:07:00.687 --> 19:07:16.093
But what happens if we want to allow some smart contract to work with our token, or we want to allow somebody else to work with our token, you know, maybe to deposit it into a protocol, or do some more functionality with it, there will be some approved function that will approve that contract to do that.

11607
19:07:16.093 --> 19:07:26.428
And then we'll have a function transfer from and this function will, you know, it'll just implement taking funds from user and this will be public as well.

11608
19:07:26.428 --> 19:07:36.517
And then at the top will be some type of allowances mapping that will tell who's allowed which address to take how much token, which sounds a little confusing, but let me just add the mapping.

11609
19:07:36.517 --> 19:07:55.160
So it'll be a mapping of addresses to a mapping of addresses to an amount to a unit tivity sex and this will be public allowance, we're gonna say address, Patrick is going to allow address of Patrick's brother to use 25 tokens.

11610
19:07:55.160 --> 19:07:57.688
And that's how this allowance works.

11611
19:07:57.688 --> 19:08:03.291
And in our transfer from transfer from will check this allowance mapping and save Hmm.

11612
19:08:03.291 --> 19:08:08.228
Did Patrick give you authorization to borrow those tokens? Oh, yes, you did.

11613
19:08:08.228 --> 19:08:09.934
Okay, we'll let you transfer from.

11614
19:08:09.934 --> 19:08:14.259
And I'm just, I'm just going to copy paste an implementation of it, you can check out the GitHub repo as well.

11615
19:08:14.259 --> 19:08:20.881
And it would look something like this is we check the allowed amounts, update the allowance, and then transfer the tokens.

11616
19:08:20.881 --> 19:08:22.171
So those are some of the main functions.

11617
19:08:22.171 --> 19:08:26.375
So we need an approved function, obviously, to update the allowances here.

11618
19:08:26.375 --> 19:08:32.501
And usually, you'll have like a un 256 initial supply.

11619
19:08:32.501 --> 19:08:41.139
And this will be like how many tokens there are starting with how many tokens there are total, sometimes you'll add a mint function to add more functions.

11620
19:08:41.139 --> 19:08:44.161
But you can basically start to see this contract ramping up.

11621
19:08:44.161 --> 19:08:51.114
One thing we could do is we could go ahead go through this spec and just line by line, you know, build our token ourself.

11622
19:08:51.114 --> 19:08:54.211
And after we do that, it might look something like this.

11623
19:08:54.211 --> 19:08:57.425
So I'm just copy pasted the code from the GitHub repo.

11624
19:08:57.425 --> 19:09:01.524
If you go to contracts, manual token, I just copy paste this code in here.

11625
19:09:01.524 --> 19:09:04.830
This is what a contract a token contract might look like.

11626
19:09:04.830 --> 19:09:05.068
Okay.

11627
19:09:05.068 --> 19:09:07.868
So we have all these functions, we have all these arrays.

11628
19:09:07.868 --> 19:09:08.999
We have all this stuff.

11629
19:09:08.999 --> 19:09:14.720
And you can see in the constructor, we're taking initial supply, and then a token name and a token symbol.

11630
19:09:14.720 --> 19:09:17.555
The name, you know, might be something like dy token.

11631
19:09:17.555 --> 19:09:25.557
And then the symbol might be something like dy, just so that it's easily recognizable just by its name and its token.

11632
19:09:25.688 --> 19:09:29.480
coding it all from scratch, like that is definitely something that we can do.

11633
19:09:29.480 --> 19:09:32.439
But as engineers, we know that that's probably really annoying.

11634
19:09:32.439 --> 19:09:33.626
And we don't actually want to do that.

11635
19:09:33.689 --> 19:09:47.066
So what can we do instead? Well, we can use an open source library, like open Zeppelin, to actually get some boilerplate code work with open Zeppelin is almost considered kind of the standard library of solidity.

11636
19:09:47.066 --> 19:10:03.642
They have a list of open source contracts that anybody can use and import into their contracts that have a ton of boilerplate, so that you don't have to manually write everything out, we can see all their code in their GitHub repository, open Zeppelin slash open Zeppelin contracts, and we're going to be using them a lot moving forward.

11637
19:10:03.689 --> 19:10:12.705
So for example, you can see kind of on the left side of their documentation, they have this tokens section, and they have an ERC 20, which is one of those tokens standards.

11638
19:10:12.705 --> 19:10:19.089
If you scroll on here, they even have some minimalistic examples of how to create your own ERC 20 token.

11639
19:10:19.089 --> 19:10:22.016
And that's what we're going to be using to build our token.

11640
19:10:22.016 --> 19:10:25.914
Because you see how much smaller this is how much less code this is to maintain.

11641
19:10:25.914 --> 19:10:29.220
Let's go ahead and let's use open Zeppelin for us to create our token.

11642
19:10:29.220 --> 19:10:30.785
So let's create a new file.

11643
19:10:30.785 --> 19:10:32.720
We'll call our token dot soul.

11644
19:10:32.720 --> 19:10:36.092
I'm going to create our own token here.

11645
19:10:36.092 --> 19:10:37.726
So let's do spdx.

11646
19:10:37.726 --> 19:10:46.235
License identifier, MIT, we'll do pragma, solidity carrot zero, point 8.

11647
19:10:46.235 --> 19:10:48.578
7, we'll do contract our token.

11648
19:10:48.578 --> 19:10:54.516
Now, what we're going to do, we're going to import openzeppelin contracts into our hard hat project.

11649
19:10:54.516 --> 19:10:58.555
And we're going to do it the same way we did with chain link and any other packages in the future.

11650
19:10:58.555 --> 19:11:05.146
So we'll do yarn, add dash dash Dev, at open Zeppelin slash contracts.

11651
19:11:05.146 --> 19:11:09.584
And this is going to add the open Zeppelin slash contracts NPM package to our project.

11652
19:11:09.584 --> 19:11:17.471
And one of the code pieces that they have is this ERC 20 contract that we can use and we can have our token inherit all the functions.

11653
19:11:17.471 --> 19:11:22.602
So we'll go ahead and import it with import at openzeppelin.

11654
19:11:22.690 --> 19:11:28.065
Slash contracts slash tokens slash ERC 20 slash ERC 20 ditzel.

11655
19:11:28.065 --> 19:11:33.413
And just by importing it like this, all we have to do is have our token inherited now.

11656
19:11:33.413 --> 19:11:34.766
So we'll say contract.

11657
19:11:34.766 --> 19:11:36.077
Our token is ERC 20.

11658
19:11:36.077 --> 19:11:36.399
Boom.

11659
19:11:36.399 --> 19:11:39.237
And just like that our token is almost done.

11660
19:11:39.237 --> 19:11:44.500
Now you might get this little wiggle this little red line here saying our token should be marked abstract.

11661
19:11:44.500 --> 19:11:51.724
And that's because if we look into the ERC 20 dot soul of openzeppelin We'll see that it has a constructor.

11662
19:11:51.724 --> 19:12:00.540
So in order for us to inherit your C 20 token, we have to use the ERC 20 constructor and we just need to give our token a name and a symbol.

11663
19:12:00.540 --> 19:12:04.034
But we can say in our constructor, we can leave it blank.

11664
19:12:04.034 --> 19:12:10.769
And then right next to our constructor, we'll add the ERC 20 constructor and our name will be our token.

11665
19:12:10.769 --> 19:12:15.241
And then our symbol will just be OT and then this ERC.

11666
19:12:15.241 --> 19:12:27.050
20 token also comes with something called a mint functionality, which is essentially a function that allows us to create tokens, right because right now we actually get initialized with zero tokens, right.

11667
19:12:27.050 --> 19:12:30.062
So nobody's actually allowed to have any tokens.

11668
19:12:30.062 --> 19:12:36.109
So we want to mint the initial amount of tokens and then who owns all those tokens to start with.

11669
19:12:36.109 --> 19:12:45.113
So usually what you'll see is you'll see a mint function like this, it'll be passed in message that sender, so whoever deploys this contract will own all the tokens to start.

11670
19:12:45.113 --> 19:12:49.519
And then we'll give it like an in their soul supply.

11671
19:12:49.690 --> 19:12:54.277
And then we could do like, you went to 56 initial supply equals like seven, or whatever.

11672
19:12:54.277 --> 19:12:58.711
But instead, a common practice is just to add it to the constructor.

11673
19:12:58.711 --> 19:13:04.737
So you and 256 initial supply like that, as we know about solidity decimals don't work so great.

11674
19:13:04.737 --> 19:13:20.400
So if I say my initial supply is 50, that 50 is going to be like 50 way, and there's all these ERC 20s come with a decimals and decimals function, which tells us how many decimals we should expect with our ERC 20.

11675
19:13:20.400 --> 19:13:21.791
The default is 18.

11676
19:13:21.791 --> 19:13:25.891
And we can override this function if we want a different amount of decimals.

11677
19:13:25.891 --> 19:13:28.091
And if we know the default is 18.

11678
19:13:28.091 --> 19:13:32.894
And we want to deploy 50, we might want to do our initial supply of 50 e 18.

11679
19:13:32.894 --> 19:13:39.841
Or you can also say like 50 times 10, raise the 18th or whatever you want there.

11680
19:13:39.841 --> 19:13:44.035
And in our code when we deploy this now, this is actually where we're going to finish the project.

11681
19:13:44.035 --> 19:13:51.207
Because everything else that we would do here, we've already done, all we need to do is make a deploy script and write some tests.

11682
19:13:51.207 --> 19:13:51.755
That's really it.

11683
19:13:51.755 --> 19:13:58.778
Because right now you have all the skills that you need to write a deploy script and then optionally write some tests for this project.

11684
19:13:58.778 --> 19:14:02.557
So I highly encourage you to pause the video here and try to write your own deploy script.

11685
19:14:02.557 --> 19:14:17.429
And even if you want to write your own tests, you can always refer back To the GitHub repo associated with this lesson, as we do have a deploy script in here, we also have a TypeScript edition in here as well that we're additionally not going to go over.

11686
19:14:17.429 --> 19:14:27.548
And of course, if you get totally lost, there's a ton of instructions in here to help you learn more and help you work with this specific repository.

11687
19:14:27.691 --> 19:14:30.970
So let's do a quick review of what we just learned.

11688
19:14:31.692 --> 19:14:37.837
tokens, or EIP 20 tokens or or b p or p p, or any of these dash 20.

11689
19:14:37.837 --> 19:14:42.273
Improvement proposals are what's known as the token standard.

11690
19:14:42.273 --> 19:14:48.060
And the token standard, these tokens on chain actually just tokens that are smart contracts.

11691
19:14:48.060 --> 19:15:02.627
Now, these tokens are obviously different than the layer one tokens like Aetherium, or polygon or Avalanche or arbitration, those are not going to be smart contracts, those are going to be blockchain native tokens, and you'll hear me refer to it as blockchain native tokens a lot.

11692
19:15:02.627 --> 19:15:08.629
versus these tokens, these ERC 20, these smart contract tokens, which are just smart contracts.

11693
19:15:08.692 --> 19:15:18.743
And they're just kind of a combination of these functions that represent how many tokens each address has, we can create our own token with all the specifications added.

11694
19:15:18.743 --> 19:15:26.803
Or we can just use openzeppelin to import a token in now another popular repo like open Zeppelin is going to be this one from Rory capital called soulmate.

11695
19:15:26.803 --> 19:15:30.739
And they're both aimed to be standard libraries for solidity.

11696
19:15:30.739 --> 19:15:35.446
And one of the important things to keep in mind is that these tokens have this allowance mapping.

11697
19:15:35.446 --> 19:15:40.804
And you can allow other addresses to have access to your tokens and move your tokens around.

11698
19:15:40.804 --> 19:15:50.428
This is important, especially when we get to later on when working with defy when we want to give some smart contract access to our tokens so that they can input it into their defy protocol.

11699
19:15:50.428 --> 19:15:52.031
It's also a little bit tricky.

11700
19:15:52.031 --> 19:15:57.692
And you want to make sure you're not allowing malicious contracts to interact with your tokens.

11701
19:15:57.692 --> 19:16:06.692
And we'll also see that when we start to interact with these tokens more before any contract can interact with our tokens, we need to approve them to interact with our tokens.

11702
19:16:06.692 --> 19:16:07.392
And that's it.

11703
19:16:07.392 --> 19:16:10.407
Now you're a token wizard, and you can deploy your own tokens.

11704
19:16:10.407 --> 19:16:18.557
Take a break, get that coffee, and I'll see you in the next one.

11705
19:16:18.693 --> 19:16:29.811
All right, welcome to the next session, we are going to be learning about defy in this session and going to be programmatic, and going to be programmatically interacting with the defy protocol.

11706
19:16:29.811 --> 19:16:36.630
I am incredibly excited for you for this session, because defi is one of the best use cases for smart contracts.

11707
19:16:36.630 --> 19:16:49.559
And one of the use cases that I am specifically most excited for now, as I've mentioned, the past defy stands for decentralized finance, we've left some links in the GitHub repository for you to learn more about Defy.

11708
19:16:49.559 --> 19:16:54.951
One of the main reasons we're so excited about defy is because we move away from this area of traditional agreement.

11709
19:16:54.951 --> 19:16:57.771
And that's what smart contracts are all about.

11710
19:16:57.771 --> 19:17:06.271
They're about removing this centralized entity, from our financial world, and especially from these financial institutions that have a conflict of interest.

11711
19:17:06.271 --> 19:17:09.226
They're in business to make money not to keep our money safe not to make us money.

11712
19:17:09.226 --> 19:17:16.209
And we want to work with a system where everything is transparent, especially when it comes to our financial services.

11713
19:17:16.209 --> 19:17:21.483
So we want to move to this world of smart contracts, especially when it comes to our money.

11714
19:17:21.483 --> 19:17:32.065
And in my mind, defi is going to be the industry that affects the masses, the quickest because of how much fair how much better decentralized finance is than centralized finance.

11715
19:17:32.065 --> 19:17:54.744
And at the moment, the rates and the yields and the interest that you gain in defy is much better than centralized finance, because remember, will go away from these centralized protocols, saying, hey, trust us, we'll give you access to the markets or hate trust us put your money in us will keep your money safe to this cryptographic math base guarantees instead of having to trust these companies and these entities, which is what we want.

11716
19:17:54.744 --> 19:18:06.394
And additionally, the more our Oracle networks get better, and the more Oracle's networks work with these smart contract platforms like Aetherium, like polygon, like arbitrage them, the more data and the more complex financial products that we can do.

11717
19:18:06.394 --> 19:18:14.903
Now, one of the other reasons I'm so crazy excited about defy is if you look at this little chart right here, it shows the different markets by size.

11718
19:18:14.903 --> 19:18:27.439
Now this this image is a little bit outdated, but it still shows you the relative sizes of all these different industries defy right now is a $200 billion market, there's about $200 billion locked in the defy industry.

11719
19:18:27.439 --> 19:18:29.122
And I'll show you that in a minute.

11720
19:18:29.122 --> 19:18:33.660
Cryptocurrency actually, at the time of recording isn't 360 billion.

11721
19:18:33.660 --> 19:18:35.439
It's actually like 1.

11722
19:18:35.439 --> 19:18:36.115
8 trillion.

11723
19:18:36.115 --> 19:18:37.641
So it's a lot more than this.

11724
19:18:37.641 --> 19:18:43.746
But still, it's a massive subset of all these other areas like gold is a $10 trillion market.

11725
19:18:43.746 --> 19:18:52.277
The stock market is almost $100 trillion global real estate, almost $300 trillion derivatives as quadrillion dollars.

11726
19:18:52.277 --> 19:19:01.253
So the FBI is a super tiny, tiny, tiny, tiny subset right now and in my mind, all of these areas can be re landscaped with Defy.

11727
19:19:01.253 --> 19:19:03.928
So we're ramping up, we're getting there.

11728
19:19:03.928 --> 19:19:14.653
So it's gonna be up to us to make some of these protocols and make it Much easier for people to get into the space where their finances are going to be more fair, more accountable and more transparent.

11729
19:19:14.653 --> 19:19:22.953
And with better yield rates, we can actually see a pretty good summary of what's going on in defy this site called defy llama.

11730
19:19:22.953 --> 19:19:28.294
It shows total value locked in all these different decentralized protocols.

11731
19:19:28.294 --> 19:19:32.345
And we can see a lot of these are across multiple chains, right.

11732
19:19:32.345 --> 19:19:47.695
And a lot of these are EVM compatible chains, Aetherium, Biden, smart chain, avalanche, Fanta, drawn polygon, all these are EVM, compatible blockchains, where we can see exactly how much money independent users have put into these protocols.

11733
19:19:47.695 --> 19:19:52.602
The time of recording Ave is the number one protocol for total value locked.

11734
19:19:52.602 --> 19:20:00.195
So there's $22 billion locked in Ave, which is the protocol that we're going to be going over today.

11735
19:20:00.695 --> 19:20:07.135
So what is Ave So are they is a borrowing and lending protocol, it allows us to borrow and lend cryptocurrencies.

11736
19:20:07.135 --> 19:20:21.432
So we can actually put down a token as collateral, it's kind of similar to like putting money in a bank, and earn yields on other people borrowing that collateral from us almost exactly what a bank does, except for the fact it's what's called noncustodial.

11737
19:20:21.432 --> 19:20:23.465
To the Ave team never touches our money.

11738
19:20:23.465 --> 19:20:24.958
Nobody ever touches the money.

11739
19:20:24.958 --> 19:20:26.589
It's all just a smart contract.

11740
19:20:26.589 --> 19:20:28.504
It's all just this programmatic code.

11741
19:20:28.504 --> 19:20:33.325
So we can be rest assured, no one's going to run off with our money, no one's going to do anything bad.

11742
19:20:33.325 --> 19:20:34.712
And we also gain these higher yields.

11743
19:20:34.712 --> 19:20:40.326
borrowing and lending is a critical piece for creating really any interesting financial applications.

11744
19:20:40.326 --> 19:20:44.409
If you want to short sell something, if you want to leverage up on some asset if you want to.

11745
19:20:44.409 --> 19:20:49.781
If you want to do more complex financial products, you need borrowing and lending.

11746
19:20:49.781 --> 19:20:55.039
Now a lot of the typical FinTech or financial technology or finance terms do apply here.

11747
19:20:55.039 --> 19:20:59.516
And this course isn't going to be a deep dive into exactly how these financial products work.

11748
19:20:59.516 --> 19:21:01.559
And it's also not going to be a course on finance.

11749
19:21:01.559 --> 19:21:07.254
If you want to learn more about finance, we'll leave a number of links in our GitHub repo associated with this course.

11750
19:21:07.254 --> 19:21:13.083
So you can learn more about finance and become what I like to call a defy quant, quantitative defy engineer.

11751
19:21:13.083 --> 19:21:16.321
And I am so excited for more defi quants to get into this space.

11752
19:21:16.321 --> 19:21:19.258
Alright, so here we are in the Ave application.

11753
19:21:19.258 --> 19:21:28.083
It's at testament dot Ave dot markets, we are in the testament of Avi now, everything that we're going to do here is going to work on Main net as well, but we're going to use it on their test net.

11754
19:21:28.083 --> 19:21:33.117
Now this is actually obvious older UI, and they have a new website that looks even better than this.

11755
19:21:33.117 --> 19:21:43.789
But we're going to be going through a lot of the basic functionality depositing taking out a loan, potentially even shorting an asset, if we want, I don't recommend going to the site because it might not work and COVID the way you'd expect it to.

11756
19:21:43.789 --> 19:21:45.851
So for this, just sit back, relax and watch.

11757
19:21:45.851 --> 19:21:48.596
In order for us to actually short sell or margin trade.

11758
19:21:48.596 --> 19:21:55.433
The first thing that we're going to need to do is actually deposit some collateral, we need to deposit some collateral in order to borrow this way.

11759
19:21:55.433 --> 19:22:03.838
If we never repay back the loan that we took out or the the amount that we borrowed, Ave, we'll just go ahead and take the collateral that we put in here, we'll do what's called a liquidation call.

11760
19:22:03.838 --> 19:22:07.187
And that's why this is actually a little bit safer than short selling in traditional markets.

11761
19:22:07.187 --> 19:22:15.508
Because if your collateral is less than how much you have borrowed, you'll just immediately get liquidated, but you still lose a bunch of money so like don't get liquidated.

11762
19:22:15.508 --> 19:22:24.323
So what we want to do now is we're gonna scroll to Aetherium, we're going to connect our wallet here, we're going to move to COVID test network browser here.

11763
19:22:24.323 --> 19:22:27.357
And we're gonna go to this deposit piece.

11764
19:22:27.357 --> 19:22:32.196
So it already shows our balance here we have point two COVID eath.

11765
19:22:32.196 --> 19:22:34.196
Let's deposit 0.

11766
19:22:34.196 --> 19:22:34.321
1.

11767
19:22:34.696 --> 19:22:38.889
We're gonna hit deposit Metamask can pop up, confirm.

11768
19:22:39.696 --> 19:22:52.903
this goes through, this means that we've have it deposited and we go to our dashboard, we can see we have some eath here, point one eath got some API, this is kind of like that percentage return that we're gonna get back for, for depositing into Ave.

11769
19:22:52.903 --> 19:22:58.123
And yes, we can use it as collateral here, we have this, this marked as yes here.

11770
19:22:58.123 --> 19:23:00.506
So that's exactly what we're going to do.

11771
19:23:00.506 --> 19:23:01.886
And it says nothing borrowed.

11772
19:23:01.886 --> 19:23:03.960
Yep, we can go ahead and hit this borrow now button.

11773
19:23:03.960 --> 19:23:09.180
And we're gonna get brought to the borrower screen, and we're going to choose which asset we want to borrow.

11774
19:23:09.180 --> 19:23:18.915
Now, whenever we borrow one of these, there are these API's, right? This is the percentage that over the course of a year that we're gonna have to pay, in order to actually borrow this asset.

11775
19:23:18.915 --> 19:23:34.729
The stable one means it'll always be for or variable means it actually changes depending on kind of how much liquidity the protocol has, you can kind of pick which one you want to do stable is you're always gonna be a 4% variable is going to be a little bit riskier, but you might get a lower fee.

11776
19:23:34.729 --> 19:23:39.297
So we're actually going to borrow some dye right, because dye is a stable coin.

11777
19:23:39.297 --> 19:23:40.230
It's worth $1.

11778
19:23:40.230 --> 19:23:57.911
In a way, you could call this taking out on margin because we're taking out dye to borrow and another way we could say we're shorting dye which is kind of funny to think about, but you get to choose how much you want to borrow here and you'll see this this thing called Health factor I'm going to zoom in a little bit this thing called Health factor here as we as we scroll this thing.

11779
19:23:57.911 --> 19:24:07.268
So this health factor is how close to being liquidated you are remember how I said you can get liquidated this health factor represents how close we are to getting liquidated.

11780
19:24:07.268 --> 19:24:11.897
This means means how close we are to always saying, You know what fu we're taking your funds.

11781
19:24:11.897 --> 19:24:27.497
If it goes below one at any time, somebody can liquidate you and take a lot of that deposit that we put in, there's some math behind actually what the health factor actually is, you can head over to the Ave documentation, which I will leave a link in the description to kind of read more about the health factor.

11782
19:24:27.497 --> 19:24:31.698
So we're going to borrow 29 die we're buying, we're borrowing basically 30 bucks.

11783
19:24:31.698 --> 19:24:41.347
Gonna hit continue, I'm gonna do a variable, zoom back out, continue, we're gonna borrow metamath pops up, confirm transaction that's pending.

11784
19:24:41.347 --> 19:24:42.682
And we're gonna go to the dashboard.

11785
19:24:42.682 --> 19:24:49.967
And now we can see kind of our new balance here, right, we can see the point one eath, deposited and 29 die.

11786
19:24:49.967 --> 19:25:03.873
And we can see our health factor up here, you can even click this little button, saying, hey, it represents how close you are to being liquidated, we can see the value here, our eath is worth like $200, or die is worth 30 bucks.

11787
19:25:03.873 --> 19:25:04.364
So we're good.

11788
19:25:04.364 --> 19:25:05.276
We're pretty healthy here.

11789
19:25:05.276 --> 19:25:12.138
In order for Avi to understand and under to price the underlying collateral, so it knows how much it can lend out.

11790
19:25:12.138 --> 19:25:23.915
Obviously another one of these protocols that uses changing price feeds to price, the underlying collateral, many of these billion dollar defy protocols use chain link on the back end to do all their pricing mechanisms.

11791
19:25:23.915 --> 19:25:29.766
And that's essentially it, we could then repay our debts, we could borrow more assets, we could swap assets around.

11792
19:25:29.766 --> 19:25:34.649
And the interest return, we get onto pausing our assets is amazing.

11793
19:25:34.649 --> 19:25:50.525
So now that we learned a little bit about how to use their UI, which is hosted on IPFS, by the way, let's go ahead and let's learn how to do all this and do even more programmatically so we can become defy quanta engineers.

11794
19:25:50.698 --> 19:26:00.870
Now, like I said, we're going to be working with the Ave v two protocol, if you want to try out the v3, you absolutely can, if you can go there and play with it right now, it still has more money locked in it, which is great.

11795
19:26:00.870 --> 19:26:03.101
But the v3 protocol is obviously the latest addition.

11796
19:26:03.101 --> 19:26:06.660
So we're gonna be flipping back and forth between the documentation and our code base.

11797
19:26:06.698 --> 19:26:09.456
So I recommend that you have the documentation up as well.

11798
19:26:09.698 --> 19:26:15.032
per usual, all of the code that we're going to be working with is in this hard hat defi Free Code Camp repository.

11799
19:26:15.032 --> 19:26:16.150
So let's jump in.

11800
19:26:16.150 --> 19:26:25.387
I'm in by VS code, I'm in my folder with this course, we're going to make a new folder, we're going to call it hard hat, defy FCC, we're going to cd into it.

11801
19:26:25.387 --> 19:26:29.099
And then we're going to open it up with code period.

11802
19:26:29.099 --> 19:26:33.408
Or you can also do per usual, File Open and then open that folder.

11803
19:26:33.408 --> 19:26:38.635
Now we're in a new project, we're going to do yarn, add dash dash Dev, aren't hat.

11804
19:26:38.699 --> 19:26:42.339
And we're going to add hard hat and start up our minimalistic hard hat project.

11805
19:26:42.339 --> 19:26:50.664
Once again, for starting up your minimalistic hard hat projects, I usually just copy paste from another folder, or I just used that hard hat starter kit that we saw in the smart contract code repo.

11806
19:26:50.664 --> 19:26:57.215
But whatever works best for you to get your project started, you can use now that we've got this, we can run yarn hardhat.

11807
19:26:57.215 --> 19:26:59.512
And we'll just create an empty hardhat.

11808
19:26:59.512 --> 19:26:59.817
config.

11809
19:26:59.817 --> 19:26:59.918
js.

11810
19:26:59.918 --> 19:27:04.546
Now to save us some boilerplate time, I am going to copy paste my hard hat.

11811
19:27:04.546 --> 19:27:04.952
config.

11812
19:27:04.952 --> 19:27:09.682
js from a past project into this one, just to make it so we don't have to go through that boilerplate setup again.

11813
19:27:09.682 --> 19:27:13.652
And I'm also going to copy paste this line from our heart at smart contract lottery.

11814
19:27:13.699 --> 19:27:18.021
Again, if you want to use your package JSON or your yarn dot lock to install dependencies, you absolutely can.

11815
19:27:18.021 --> 19:27:21.190
But I'm just going to paste that in here and run it.

11816
19:27:21.190 --> 19:27:28.010
And then I'm going to copy paste over my prettier files, so that all my JavaScript can be formatted the way I want it to be.

11817
19:27:28.010 --> 19:27:28.403
Okay, great.

11818
19:27:28.403 --> 19:27:33.572
Now we have a minimalistic project spun up, let's go ahead and get started learning how to interact with the AVI protocol here.

11819
19:27:33.572 --> 19:27:37.062
So let's make a quick readme and talk about what we want to be able to do.

11820
19:27:37.062 --> 19:27:41.953
So first, we're going to want to be able to learn how to programmatically deposit collateral.

11821
19:27:41.953 --> 19:27:52.771
And if we stopped right there, that might be enough, we'd be able to programmatically deposit collateral, and in doing so we earn yield, we'd earn that percentage return just on our deposited collateral.

11822
19:27:52.771 --> 19:27:55.356
So accomplishing this by itself is already a feat.

11823
19:27:55.356 --> 19:28:00.649
But let's say we want to go one step further, we want to get into these more interesting financial products.

11824
19:28:00.700 --> 19:28:15.650
So after we deposit some collateral, we're going to learn how to programmatically borrow and other asset, the deposited collateral is going to be eath, slash wrapped eath, which we'll talk about in a little bit, we're going to borrow another asset, which for this demo is going to be dye.

11825
19:28:15.650 --> 19:28:19.896
And the reason that we're using dye is because dye is what's known as a stable coin.

11826
19:28:19.896 --> 19:28:27.527
So dye is actually a token on the blockchain created by this maker Dow where the price of the dye token is always pegged to $1.

11827
19:28:27.527 --> 19:28:43.458
So we're putting down eath as collateral and we're borrowing cryptocurrency, US dollars, sort of, we're borrowing this token, which represents a US dollar and then we'll just repay that I will repay almost everything back and you'll see why we don't repay everything back in a minute.

11828
19:28:43.458 --> 19:28:46.527
One other protocol that I want to talk about quickly is the uniswap protocol.

11829
19:28:46.527 --> 19:28:49.914
And the uniswap protocol has become this haven for trading.

11830
19:28:49.914 --> 19:28:59.454
It's a decentralized application that allows us to trade assets and tokens with each other on something called an automated market maker.

11831
19:28:59.454 --> 19:29:05.257
It ends basically a decentralized Stock Exchange, but with tokens and again, tokens aren't exactly stocks, they're very different.

11832
19:29:05.257 --> 19:29:10.768
So when looking to get some of these assets It's like wrapped Aetherium or dye or link token.

11833
19:29:10.768 --> 19:29:15.454
On a main net, oftentimes, you're going to use one of these decentralized exchanges.

11834
19:29:15.454 --> 19:29:25.436
And obviously, these decentralized exchanges are much fairer, because everything that happens on them is transparent, much fairer than centralized finance, everything that happens on them is transparent.

11835
19:29:25.436 --> 19:29:30.343
You can see everything that's going on on chain, which is absolutely phenomenal.

11836
19:29:30.343 --> 19:29:32.653
So let's go ahead and get started here.

11837
19:29:32.653 --> 19:29:34.605
And let's just create our scripts folder.

11838
19:29:34.701 --> 19:29:40.335
Because in this project, we're actually not going to create any contracts ourselves, we're just going to learn how to interact with these protocols.

11839
19:29:40.335 --> 19:29:46.601
If you do want to learn how to build some of these protocols, at the end of this session, we will give you a ton of links.

11840
19:29:46.601 --> 19:29:51.911
And we'll have a special guest explain a few different ways to learn how to build more of these decentralized protocols.

11841
19:29:51.911 --> 19:29:56.044
Although we've already built one with our decentralized lottery, which is fantastic.

11842
19:29:56.044 --> 19:29:57.628
Let's create some scripts here.

11843
19:29:57.628 --> 19:30:01.055
And for all of these things, deposit collateral, borrow and repay.

11844
19:30:01.055 --> 19:30:05.210
We'll just put this all in a new script called Ave borrow dot Jas.

11845
19:30:05.210 --> 19:30:07.586
So we're gonna do everything in here.

11846
19:30:07.586 --> 19:30:17.097
And since this is a script, it's going to have the same setup, as we've seen before, right, so we're gonna have this main thing around an async function.

11847
19:30:17.097 --> 19:30:20.442
Main, and then we'll have our imports, of course at the top.

11848
19:30:20.442 --> 19:30:32.995
Now something that's important to note, go to avi, we go to the protocol, we kind of read through the docs, and eventually we would find out the protocol treats everything as an ERC 20 token.

11849
19:30:32.995 --> 19:30:40.614
And but we know that Aetherium or the native blockchain token that you're using, isn't an ERC 20 token.

11850
19:30:40.701 --> 19:30:52.501
And the reason that treats everything like an ERC 20 token is that it's just much easier, right? If everything's using this ERC 20 token standard, it's much easier to send in and interact with stuff.

11851
19:30:52.701 --> 19:31:07.239
On a lot of these protocols, when we go to deposit Aetherium, or polygon, or arbitrary marks cetera, what actually happens is they send your Aetherium through like what's called a web gateway, and swaps it for weath, which stands for rapt ether.

11852
19:31:07.239 --> 19:31:09.668
And it's basically Aetherium.

11853
19:31:09.668 --> 19:31:17.074
But in an ERC 20 token contract, so what we want to do is going to do that same thing, we're gonna skip kind of using this web gateway.

11854
19:31:17.074 --> 19:31:21.352
And we'll just get the Web Token ourselves, and we'll use that as collateral.

11855
19:31:21.352 --> 19:31:26.035
So in our script tag, I'm going to make another file called Get weath.

11856
19:31:26.035 --> 19:31:26.168
js.

11857
19:31:26.168 --> 19:31:35.130
And in here, we're actually going to go ahead, and we're going to build a script that will deposit our token for web token.

11858
19:31:35.130 --> 19:31:36.701
Okay, so let's create the script.

11859
19:31:36.701 --> 19:31:40.960
And there's a link to the web token on ether scan, and on Main net in the GitHub repo.

11860
19:31:40.960 --> 19:31:44.572
And the way it works, is you actually deposit Aetherium.

11861
19:31:44.702 --> 19:31:49.321
And in return, it'll give you the web token on Rigby right now, by deposit 0.

11862
19:31:49.321 --> 19:31:49.511
05.

11863
19:31:49.511 --> 19:31:56.152
Go ahead and write I'm connected to ether scan, I'll go ahead and write this transaction, I'm gonna drink pee.

11864
19:31:56.152 --> 19:32:00.831
So I don't really care if it's if it's the actual contract or not, because it's not real money.

11865
19:32:00.831 --> 19:32:02.292
But I'm going to deposit 0.

11866
19:32:02.292 --> 19:32:02.751
05 eath.

11867
19:32:02.751 --> 19:32:20.035
And after our transaction goes through, we copy the contract address, we add this token to our Metamask the same way we added link will import tokens, paste the address in here, add custom token, import tokens will now see we have some wet token in here, I deposited 0.

11868
19:32:20.035 --> 19:32:21.066
1 before so 0.

11869
19:32:21.066 --> 19:32:21.782
1 plus 0.

11870
19:32:21.782 --> 19:32:23.959
05, which is why it shows 0.

11871
19:32:23.959 --> 19:32:27.809
15 Because I did it twice, well, while I wasn't recording.

11872
19:32:27.809 --> 19:32:31.102
So um, but this is how you can get this wet token into your contract.

11873
19:32:31.102 --> 19:32:34.502
And then anytime you want, you can call this withdrawal function.

11874
19:32:34.502 --> 19:32:39.029
And you can withdraw your Aetherium out of this and do what's called Burn your wet token.

11875
19:32:39.029 --> 19:32:49.638
So when you swap back from weath to Aetherium, you hit this withdraw and boom, you basically swap them back because this contract itself right now is holding your Aetherium token.

11876
19:32:49.702 --> 19:32:58.750
Pretty cool, right? So in our get wet function, we're not going to add this main thing here, we're going to create get West here just as kind of a module and we're going to import it into our Ave borrow.

11877
19:32:58.750 --> 19:33:01.957
So we're not going to do this this main thing that you see here.

11878
19:33:01.957 --> 19:33:06.325
Instead, we're going to create an async function called Get Wes.

11879
19:33:06.325 --> 19:33:09.864
And then below, we're going to export it.

11880
19:33:09.864 --> 19:33:14.509
So we'll do module dot exports equals get weath.

11881
19:33:14.703 --> 19:33:22.356
And we're going to export it so our Avi borrow can use this get West script that we're creating right now, let's add let's go ahead and do this.

11882
19:33:22.356 --> 19:33:26.369
Well, in order to interact with a contract, we're going to need an account.

11883
19:33:26.369 --> 19:33:33.555
So we can do const deployer equals await get named accounts, per usual.

11884
19:33:33.555 --> 19:33:37.082
We'll do const get name accounts equals require hardhat.

11885
19:33:37.082 --> 19:33:39.392
My VS code automatically imported that thank you VS code now.

11886
19:33:39.392 --> 19:33:46.582
And now we want to call the deposit function on the west contract.

11887
19:33:46.703 --> 19:33:56.638
How do we call this deposit function on the west contract? Well, how do you call any contract? Well, what do you need? You need the ABI and then you need the contract address.

11888
19:33:56.703 --> 19:33:57.399
Drill this in.

11889
19:33:59.703 --> 19:34:02.003
contract address to interact with the contract.

11890
19:34:02.703 --> 19:34:17.457
if we give we know that if we give our project the whole contract, it'll get the API but we also know If we just do the interface, that's just as good, it won't give us all the functionality, but it will tell it will give us the API, it will tell our ethers, what functions it can use.

11891
19:34:17.457 --> 19:34:21.799
So we're going to create a new folder, create our contracts folder.

11892
19:34:21.799 --> 19:34:25.211
And in here, we're going to create a new folder inside of that called interfaces.

11893
19:34:25.211 --> 19:34:28.274
And this is where we're going to create our web interface.

11894
19:34:28.274 --> 19:34:32.623
Now a web interface is going to be really similar to an ERC 20 interface.

11895
19:34:32.623 --> 19:34:36.672
So if you want to go ahead and try to add it yourself, feel free to do so.

11896
19:34:36.672 --> 19:34:55.481
Or what you can just do is you can come to the GitHub repo associated with this lesson, come to iOS and just copy paste, right, you'll see the functions in here are exactly the same as an ERC 20, allowance approved balance of decimals named blah, blah, with these additional deposit and withdrawal functions.

11897
19:34:55.481 --> 19:35:03.976
So I'm going to copy all this, move back over to my hard hat project, we'll create a new file, we'll call I left dot soul.

11898
19:35:03.976 --> 19:35:13.736
And just to note, oftentimes, a good best practice is to have interfaces, start with eyes so that you know what to interface and then we'll paste it in here.

11899
19:35:13.736 --> 19:35:17.359
Now in order for this to compile, we'll need to use 0.

11900
19:35:17.359 --> 19:35:19.818
4 point 19 version of solidity.

11901
19:35:19.818 --> 19:35:23.867
So what we can do is we can come over to our, our head.

11902
19:35:23.867 --> 19:35:24.260
config.

11903
19:35:24.260 --> 19:35:24.391
js.

11904
19:35:24.391 --> 19:35:27.059
We have solidity compilers, version 0.

11905
19:35:27.059 --> 19:35:31.514
07, or whatever versions that you have in here, we can add or just replace.

11906
19:35:31.514 --> 19:35:35.551
So I'm going to put a comma here, version 0.

11907
19:35:35.551 --> 19:35:36.906
4 point 19.

11908
19:35:36.906 --> 19:35:37.583
Save.

11909
19:35:37.583 --> 19:35:47.929
And now in order to make sure we can get that API, do yarn, hardhats compile, or hh compiled, and great, we compile this interface.

11910
19:35:47.929 --> 19:35:50.304
So now we have the ABI to interact with.

11911
19:35:50.304 --> 19:35:55.654
Now that we have the ABI, a little check mark here, let's go ahead and get the contract address.

11912
19:35:55.704 --> 19:36:07.754
But for reasons that we're going to learn about very soon, we're actually going to work just with main net set of getting the Rinkeby test and address, I'm going to look up with main net, we're going to find the web token on Main net.

11913
19:36:07.754 --> 19:36:10.229
So I'm going to copy the address of main net.

11914
19:36:10.229 --> 19:36:16.067
And again, you can just grab this address from the GitHub repo associated with this lesson as well.

11915
19:36:16.067 --> 19:36:21.043
And for now, we're gonna say check a little check mark here, and paste the address there.

11916
19:36:21.043 --> 19:36:26.080
So now we're have the ABI compiled from an interface, and we have the contract address for main net.

11917
19:36:26.080 --> 19:36:28.330
But let's go ahead and create this contract now.

11918
19:36:28.330 --> 19:36:37.117
So we can say const, iOS equals await ethers dot and then we'll need to import ethers from Hardhead as well.

11919
19:36:37.117 --> 19:36:52.816
Ethers dot get contract at this is another one of these functions on ethers, it allows us to get a contract at a specific address, we'll say get contract app, we use the iOS ABI for now, we'll just hard code this address in here.

11920
19:36:52.816 --> 19:36:55.092
And then we'll connect it to the Deployer.

11921
19:36:55.092 --> 19:37:02.068
So we're saying let's get this web contract with the ABI of iOS at this address connected to Deployer.

11922
19:37:02.068 --> 19:37:07.276
So we could go ahead and run await AI with dot deposit.

11923
19:37:07.276 --> 19:37:10.450
And we'll set value which will be some amounts.

11924
19:37:10.450 --> 19:37:21.882
Let's go ahead and at the top, we'll say const amount equals let's do ethers dot utils dot parse, ether, and then we'll do 0.

11925
19:37:21.882 --> 19:37:22.220
0 0.

11926
19:37:22.220 --> 19:37:22.445
02.

11927
19:37:22.445 --> 19:37:24.805
So we'll deposit 0.

11928
19:37:24.805 --> 19:37:32.475
02 will say const TX equals that will do await TX dot wait one wait for one block to go through.

11929
19:37:32.475 --> 19:37:36.505
And then we'll just get the balance will say const.

11930
19:37:36.505 --> 19:37:42.015
With balance equals await I with that balance of employer.

11931
19:37:42.015 --> 19:37:47.020
So we're going to call the balance of function on our iWeb ERC 20 token.

11932
19:37:47.020 --> 19:37:54.659
And then we'll just do console dot log got West balance.

11933
19:37:54.659 --> 19:37:56.333
to string.

11934
19:37:56.706 --> 19:37:58.856
So we're using the main net address in here.

11935
19:37:59.706 --> 19:38:01.899
say okay, we're going to deposit some amount, we're going to wait.

11936
19:38:01.899 --> 19:38:13.596
And then we're gonna go ahead and get the balance right, so we're just depositing our Aetherium so that we can get that ERC 20 version of Aetherium, that West token here.

11937
19:38:13.706 --> 19:38:19.170
Now, you might be thinking, Okay, why are you putting the main address in here? Let's Patrick, slow down.

11938
19:38:19.170 --> 19:38:23.635
Let's go ahead and let's create a mock Web Token contract address.

11939
19:38:23.706 --> 19:38:31.826
Let's deploy the mocks first, and then we'll go ahead and use that same setup that we've been doing this whole time, why you why you directly hard coding this in here.

11940
19:38:31.826 --> 19:38:34.610
Well, I've been alluding to this for some time.

11941
19:38:34.610 --> 19:38:38.706
But there's another way that we can run tests in our smart contracts.

11942
19:38:38.706 --> 19:38:47.028
And this is with something called main net forking, we can actually do something where we fork the main net, and run a local hard hat node.

11943
19:38:47.028 --> 19:38:50.253
That's pretending to be a main net node.

11944
19:38:50.253 --> 19:38:54.706
And all we have to do is update our hard head config to do so.

11945
19:38:54.706 --> 19:38:57.050
So let's talk about forking for a minute.

11946
19:38:57.050 --> 19:39:06.996
So on the left here, we have a blockchain an example of blockchain it's going to be something similar to a test net or main net like Rinkeby, eath, main net polygon etc.

11947
19:39:06.996 --> 19:39:10.127
This is going to be a blockchain that we deploy to.

11948
19:39:10.127 --> 19:39:14.994
Now there are a whole bunch of blocks in here, right? We have this huge chain that we can work with.

11949
19:39:14.994 --> 19:39:26.792
And all this information on the blockchain is public information, like this block is going to have transaction transaction transaction, each one of these blocks is going to have a whole bunch of transactions.

11950
19:39:26.792 --> 19:39:29.528
And all this information is on this public blockchain.

11951
19:39:29.528 --> 19:39:37.657
In addition to all these transactions, it's going to have things like price feed contracts, it's going to have things like Ave contract, the Web token, contract, etc.

11952
19:39:37.707 --> 19:39:40.852
All this contract information is public.

11953
19:39:42.707 --> 19:39:50.373
it's already there, we should be basically able to copy this to our local environment and do some simulations ourselves.

11954
19:39:50.373 --> 19:39:53.216
And that's exactly what forking does.

11955
19:39:53.216 --> 19:40:01.564
A fork blockchain literally takes a copy of an existing blockchain like on the left here and brings it on our local computer.

11956
19:40:01.564 --> 19:40:08.653
We actually have control over our blockchain that's running locally, because it's gonna run on a local computer, similar to hard hat.

11957
19:40:08.707 --> 19:40:16.168
Now, everything we do on this local forked blockchain is not going to affect main them, because it's a simulated blockchain.

11958
19:40:16.168 --> 19:40:18.152
It's just running in our local environment.

11959
19:40:18.152 --> 19:40:24.657
So we can actually interact with this forking this kind of local blockchain that resembles that mimics the actual blockchain.

11960
19:40:24.707 --> 19:40:29.516
And here's what forking doesn't do, it doesn't download the entire blockchain into our local setup.

11961
19:40:29.516 --> 19:40:31.069
Anytime we reference an address.

11962
19:40:31.069 --> 19:40:45.641
Anytime we reference, hey, there's something at a specific address, we make an API call to our Aetherium node, which again, we're using alchemy and say, hey, oh, what's at this address, and it'll return just that specific contract for us.

11963
19:40:45.707 --> 19:40:47.671
This way, we don't have to download the whole blockchain.

11964
19:40:47.707 --> 19:40:48.771
And it's a lot quicker.

11965
19:40:50.707 --> 19:40:52.816
our tests to run our scripts to do everything.

11966
19:40:53.707 --> 19:40:55.167
be thinking, wow, Patrick, this sounds awesome.

11967
19:40:55.707 --> 19:40:58.658
we just do this for everything? Well, there's some trade offs.

11968
19:40:58.707 --> 19:41:03.034
The pros are that it's quick, it's easy, and a test will resemble what's on Main net.

11969
19:41:03.034 --> 19:41:07.264
Now the cons are that we need an API, and we can't do everything locally.

11970
19:41:07.264 --> 19:41:12.023
Some contracts, some contracts are complex to work with, and mocks might just be better.

11971
19:41:12.023 --> 19:41:16.953
But using a forked network might be a good way to run your tests, it might be a good alternate to just using mocks.

11972
19:41:16.953 --> 19:41:20.774
So it really depends on what's right for you and right for your project.

11973
19:41:20.774 --> 19:41:26.129
But it is a fantastic tool, especially for something like Avi, where we want to quickly test some things.

11974
19:41:26.129 --> 19:41:30.347
Now the hard forking also will give us a bunch of fake accounts.

11975
19:41:30.347 --> 19:41:35.134
So we'll still get a bunch of fake accounts on Main net that will be given a theorem.

11976
19:41:35.134 --> 19:41:37.658
So we'll get fake main net accounts for this forking.

11977
19:41:37.658 --> 19:41:42.035
So for the rest of this, we're going to be using this forking to run our scripts and run our tests.

11978
19:41:42.035 --> 19:41:46.108
If you want to go back after this and try this all out on COVID.

11979
19:41:46.108 --> 19:41:51.095
We've got a whole bunch of different addresses for the COVID network so that you can run these scripts directly on COVID.

11980
19:41:51.095 --> 19:41:53.127
And you can see the transactions yourself.

11981
19:41:53.127 --> 19:42:02.535
Just note that when using COVID, you'll want to make sure that you're using the same addresses, as are in the AVI docs for the COVID network, because they do change sometimes.

11982
19:42:02.535 --> 19:42:06.242
Great, let's go ahead, we'll go to our RT head dot config dot j s.

11983
19:42:06.242 --> 19:42:12.514
And now we'll go to our networks, which right now, I don't have anything, I only have ranking.

11984
19:42:12.514 --> 19:42:17.408
And we'll add hard hat in here, we'll add a little comma down here.

11985
19:42:17.408 --> 19:42:21.623
And we'll say, you know, the chain ID of course is going to be 31337.

11986
19:42:21.623 --> 19:42:23.691
We'll add this forking keyword.

11987
19:42:23.691 --> 19:42:28.930
And in here, we'll say the URL for a Forking is going to be our main net RPC URL.

11988
19:42:28.930 --> 19:42:32.216
And this is another reason why we're using alchemy.

11989
19:42:32.216 --> 19:42:36.803
Alchemy is fantastic at these forked blockchains, and has really good pieces here.

11990
19:42:36.803 --> 19:42:41.298
So what we can do is we can come back to our alchemy dashboard, we'll create a new app.

11991
19:42:41.298 --> 19:42:46.408
This one will be for Aetherium main net, and we'll say forking chain.

11992
19:42:46.408 --> 19:42:52.539
We'll say for forking, we'll go ahead and create this on a theory and main net.

11993
19:42:52.539 --> 19:42:56.353
Now that we have this forking chain, we can do the same thing.

11994
19:42:56.353 --> 19:43:04.644
We'll grab our API key, we'll come back to our project, create this new file, we'll create our dot env.

11995
19:43:04.644 --> 19:43:08.878
And we'll do main net RPC URL equals and paste that in there.

11996
19:43:08.878 --> 19:43:16.146
In our Hardhead config, we are now going to be forking from mainnet RPC URL whenever we work with the heart at blockchain.

11997
19:43:16.146 --> 19:43:21.709
So now that we have this in here, let's go ahead and try to run this get wet function.

11998
19:43:21.709 --> 19:43:27.328
Because since we're forking the blockchain, we should be able to go ahead and simulate this.

11999
19:43:27.328 --> 19:43:40.173
So backing off a borrow, we'll go ahead we'll do const, get weath equals require and then we'll pull this script that dot dot scripts slash get weath.

12000
19:43:40.173 --> 19:43:45.676
And then, in our main function, we'll just run await yet.

12001
19:43:45.676 --> 19:43:53.116
So to run our script here, we'll do yarn hard hat, run scripts avevamo.

12002
19:43:53.116 --> 19:43:53.375
js.

12003
19:43:53.375 --> 19:43:56.293
And our default network is hard hat.

12004
19:43:56.293 --> 19:43:59.042
So we could either do dash dash network hard hat or just run it.

12005
19:43:59.042 --> 19:44:09.088
And remember, since in our config, we're saying, hey, when we run the hard hat chain, use this forking, we're going to be forking, so let's go ahead Run this ran to air main.

12006
19:44:09.088 --> 19:44:10.812
Net RPC URL is undefined.

12007
19:44:10.812 --> 19:44:12.442
Well, that makes sense.

12008
19:44:12.442 --> 19:44:20.160
Let's go ahead and add this consummated RPC rel equals process study and v dot made it RPC URL.

12009
19:44:20.160 --> 19:44:22.155
Let's try this again.

12010
19:44:22.155 --> 19:44:31.509
And we now see we got, you know, this much weath, which, again, that much wealth is gonna be 1-234-567-8910 1234567 0.

12011
19:44:31.509 --> 19:44:35.972
02 wealth, which is exactly what we want.

12012
19:44:35.972 --> 19:44:41.010
So now we have a way to interact with main net locally, which sounds kind of crazy.

12013
19:44:41.010 --> 19:44:44.431
But he's incredibly powerful for exactly what we're doing right here.

12014
19:44:44.431 --> 19:44:52.460
So we have a way to fork main that eath and run our scripts and kind of test to see and simulate what it would be like to actually run these transactions.

12015
19:44:52.460 --> 19:44:56.201
So we're gonna do like that, our get with function looks good.

12016
19:44:56.201 --> 19:45:02.553
And obviously, we would still modularize this, we put this in our helper Hardhead config, but we're going to skip doing that for now.

12017
19:45:02.553 --> 19:45:04.428
So let's go head back to the AVI borrow.

12018
19:45:04.428 --> 19:45:06.960
And let's go ahead and flesh the rest of this out.

12019
19:45:06.960 --> 19:45:09.290
Now, let's go ahead and set up the rest of the boilerplate here.

12020
19:45:09.290 --> 19:45:15.376
So we'll do const Deployer, because we need an account, obviously equals await, get named accounts.

12021
19:45:15.376 --> 19:45:20.306
And then we'll do const get named accounts equals require.

12022
19:45:20.306 --> 19:45:30.852
Now we want to start interacting with the ABI protocol, well, what do we need, we're gonna need the ABI and the address, nothing changes, we're gonna need these two.

12023
19:45:30.852 --> 19:45:33.090
So what we can do is we can go to the Ave docs.

12024
19:45:33.090 --> 19:45:35.443
And again, we're going to be on V two.

12025
19:45:35.443 --> 19:45:39.487
And we can go ahead and find the contract address in here.

12026
19:45:39.487 --> 19:45:44.981
Now the way it works is they actually have a contract, which will point us to the correct contract.

12027
19:45:44.981 --> 19:45:49.025
The contract that we're going to be doing all the lending with is this lending pool.

12028
19:45:49.025 --> 19:45:53.742
And there's actually a contract to get that contract address.

12029
19:45:53.742 --> 19:45:59.000
And to get the lending pool address, we have to go to the lending pool address provider.

12030
19:45:59.000 --> 19:46:02.235
It's this contract that will tell us what the address of the lending pullets.

12031
19:46:02.235 --> 19:46:06.972
And we can actually see the deployed contract section, we can see the address of this contract.

12032
19:46:06.972 --> 19:46:09.145
And we can see the address of all the main ones and the COVID.

12033
19:46:09.145 --> 19:46:11.613
Once again, if you want to play with this on COVID.

12034
19:46:11.711 --> 19:46:17.644
But we can see lending pool address provider is going to be located right here, we can copy this address.

12035
19:46:17.644 --> 19:46:21.553
And we'll just take notes of this.

12036
19:46:21.711 --> 19:46:25.863
And that lending pool, we're going to get from the lending pelagics provider.

12037
19:46:25.863 --> 19:46:31.961
So let's actually create a function that will get us the lending pool address from the lending pool address provider.

12038
19:46:31.961 --> 19:46:36.301
So down here, we'll create async function, get lending pool.

12039
19:46:36.301 --> 19:46:39.497
Now in order to interact with this lending pool address provider.

12040
19:46:39.497 --> 19:46:43.456
Same thing, we're going to need its address and its API, we have its address.

12041
19:46:43.456 --> 19:46:49.226
So let's go ahead and get its API, you can go ahead to the GitHub repo associated with this lesson.

12042
19:46:49.226 --> 19:46:51.616
And just copy paste it from the interfaces section.

12043
19:46:51.711 --> 19:46:58.011
You could also look directly on the blockchain to see what this contract looks I can create your own interface.

12044
19:46:58.011 --> 19:47:00.573
Or we can go ahead and use the interface right in the documentation.

12045
19:47:00.573 --> 19:47:01.952
So we have islanding Palach.

12046
19:47:01.952 --> 19:47:05.254
Provider, I'm just going to copy this from the ABI docs.

12047
19:47:05.254 --> 19:47:08.044
But again, you've got a number of options.

12048
19:47:08.044 --> 19:47:12.677
And so in our contracts in our interfaces, let's let's stick iwth in interfaces here.

12049
19:47:12.677 --> 19:47:14.304
Let's create a new file.

12050
19:47:14.304 --> 19:47:20.211
And we'll call it I lending pool address provider, dot soul.

12051
19:47:20.211 --> 19:47:23.773
And we'll paste it in here, we just see we're using 0.

12052
19:47:23.773 --> 19:47:24.398
6 point 12.

12053
19:47:24.398 --> 19:47:31.743
So be sure to in our Hardhead config to make sure we have that we don't so we're just create a new one 0.

12054
19:47:31.743 --> 19:47:38.627
6 point 12 And then we'll compile yarn Hardhead compile and compiles so awesome.

12055
19:47:38.711 --> 19:48:15.356
We now have the ABI here, we'll get this contract by saying const lending pool address provider equals await ethers dot get contract at will say I lending pool address oops address as I lending pool addresses excuse me, I'm going to update the name I Lenny pull addresses provider islanding pool addresses provider, we're going to pass in that contract address that we got from the Ovid docs here.

12056
19:48:15.356 --> 19:48:16.542
Paste that in.

12057
19:48:16.712 --> 19:48:19.212
And then we're going to connect it to our Deployer.

12058
19:48:19.712 --> 19:48:29.498
going to have our get lending pool, get past that account variable and then we'll just use the account here to connect it and the account that we're going to pass is of course going to be our Deployer.

12059
19:48:29.498 --> 19:48:31.924
In our lending pool address provider.

12060
19:48:31.924 --> 19:49:08.633
There's a function called Get lending pool which returns the address of the lining pool and this is going to be the function that we're going to call so we're gonna say const lending pool address equals a weight lending pool address says probes address any pool address says provider dot get lending pool and that's it we'll have the lending pool address and then we'll have this contract give us the lending pool contract by doing const lending pool equals await ethers dot get contract Add.

12061
19:49:08.633 --> 19:49:14.712
And we need to do the same thing, the interface, the interface, the address, and then the account.

12062
19:49:14.712 --> 19:49:20.131
So back in the docs, we can grab the I lending pool by copying this like this.

12063
19:49:20.131 --> 19:49:26.779
We'll go back to our contracts interfaces, new file, I lending pool, that's all.

12064
19:49:26.779 --> 19:49:28.271
And we'll paste it in.

12065
19:49:28.271 --> 19:49:43.729
Now with this one, if we scroll to the top, we noticed that we're importing from some local places that we actually don't have in our contracts area, we can once again go ahead and add the AVI protocol v2 from NPM.

12066
19:49:43.729 --> 19:49:46.629
And just use this as our imports.

12067
19:49:46.629 --> 19:49:53.923
So we'll do yarn, add dash dash dev apt have a slash proto call hyphen V two.

12068
19:49:53.923 --> 19:50:04.434
And now that we have the Add Ave protocol in our node modules, we can update these imports to point to our node modules instead of our local files.

12069
19:50:04.434 --> 19:50:15.838
So I'm just gonna go ahead and tell you that the islanding pledge provider is that Ave slash protocol hyphen V to slash contracts slash interfaces.

12070
19:50:15.838 --> 19:50:34.650
And then data types dot soul is gonna be at of a protocol hyphen v2 slash contracts slash, proto call slash libraries, slash types, data types, that's all again to make sure this is right, yarn, Hardhead compile or hh, compile.

12071
19:50:34.650 --> 19:50:35.212
And Cool.

12072
19:50:35.212 --> 19:50:48.874
Looks like I did that right? Lending pool equals await ethers dot get contract at, we're going to be using lending pool, I lend the pool here, we're going to use this lending pool address got from the addresses provider.

12073
19:50:48.874 --> 19:50:52.874
And then the account, which is going to be our Deployer.

12074
19:50:52.874 --> 19:50:56.551
And now we can do return lending pool.

12075
19:50:56.551 --> 19:51:12.058
And if we want, and now that we have this function get lending pool backup in our main function, we can say const lending pool equals a weight, get lending pool and then pass the Deployer.

12076
19:51:12.058 --> 19:51:22.149
And then we can even do a little console dot log, lending pool address and then do lending pool dot address.

12077
19:51:22.149 --> 19:51:25.714
And since we're making it forking, we can kind of just keep running this right.

12078
19:51:25.714 --> 19:51:29.414
So we'll do yarn hardhat run scripts.

12079
19:51:29.414 --> 19:51:35.651
Ave Baroda Jas, there are multiple artifacts for contract II lending pool addresses provider.

12080
19:51:35.651 --> 19:51:46.946
And this is because in our node modules, import all this stuff from contracts and in here, and there's already in islanding, pool addresses provider in those add ons slash contracts.

12081
19:51:46.946 --> 19:51:52.664
So actually, we don't even need this, I lending pool added service provider, we can go ahead and delete it.

12082
19:51:52.664 --> 19:51:54.614
Our time right now is getting confused.

12083
19:51:54.714 --> 19:52:02.599
It's saying Oh, are you referring to the one that you downloaded from NPM or the one that you made, which which one do you want to use.

12084
19:52:02.599 --> 19:52:04.615
So we'll just make it easier for hardhat.

12085
19:52:04.714 --> 19:52:09.285
And we'll say okay, well, we'll delete the one that we created, we'll use the one that we've downloaded here.

12086
19:52:09.285 --> 19:52:11.369
And now we should be good to run this again.

12087
19:52:11.369 --> 19:52:16.649
Because now there's only one for to pick from, which is the one we downloaded from NPM.

12088
19:52:16.714 --> 19:52:21.836
And perfect, we get our get weath printout here, and then we get lending pool address is here.

12089
19:52:21.836 --> 19:52:26.460
And this is going to be the actual lending pool address on ether Aetherium main net.

12090
19:52:26.460 --> 19:52:38.386
So if we go back to ether scan, copy that address and paste it and ether scan, we can see it's even labeled Ave v two, and we can see a ton of transactions going through all the time.

12091
19:52:38.386 --> 19:52:40.294
And ether scan is having a hard time keeping up with all the transactions.

12092
19:52:40.294 --> 19:53:09.115
So we've got the lending pool address, we've got some web token, what do we need to do? Now we want a deposit of what do we need in order to deposit the token? Well, if we look at the deposit function in the avec GitHub, we can scroll in here and we see it eventually we'll call this safe transfer from which is basically going to be this transfer from function, since we're calling transfer from it's going to be this contract, that's actually going to pull the money out of our wallet.

12093
19:53:09.115 --> 19:53:18.266
So in order to give the Ave contract, the ability to pull the money out of our wallet, we need to do what we're going to need to approve the contract.

12094
19:53:18.266 --> 19:53:25.508
So first, before we can even deposit we're gonna need to approve it to get our web token, we're gonna have to get the Web Token first.

12095
19:53:25.508 --> 19:53:35.436
So let's get the Web Token address we'll say const Web Token address, equals and this is where we marginalize it and get it from our hard head helper config.

12096
19:53:35.436 --> 19:53:43.197
But for now, we can just hard code it, the Web Token contract address is going to be the exact same thing as what's in get web and then want to approve.

12097
19:53:43.197 --> 19:53:47.857
So let's write an approved function because we're going to use this a couple times.

12098
19:53:47.857 --> 19:54:10.005
So we'll make an async function and approve ERC 20 And we'll take a contract address a spender address, which is going to be the contract that we're going to give the approval to to spend our token and amount to spend so exactly how much we want to prove it.

12099
19:54:10.005 --> 19:54:13.069
And then an account to do all this on.

12100
19:54:13.069 --> 19:54:20.924
So in here we'll say const ERC 20 token equals await ethers dot get contract at.

12101
19:54:20.924 --> 19:54:27.286
And we could say I WEF but maybe we just want like a simple ERC 20 token interface.

12102
19:54:27.286 --> 19:54:31.896
And we're going to grab that by cheating a little bit coin to our hard head defy FCC.

12103
19:54:31.896 --> 19:54:35.650
We're going to go to interfaces and grab this interface from here.

12104
19:54:35.650 --> 19:54:43.993
So we're going to copy this, paste it in here New File IO ERC 20 dot som paste and now we have an ABI for ERC.

12105
19:54:43.993 --> 19:54:50.096
20s So we'll do get contract that ERC 20 Actually let's change this name to ERC.

12106
19:54:50.096 --> 19:55:01.645
20 address so we're going to get the contract with the ABI of IRC ERC 20 at contract address ERC 20 address and then we'll connect it to our account here.

12107
19:55:01.716 --> 19:55:18.601
So and once we have the ERC 20 We can do const TX, we're going to do that approve transaction we'll do a weight ERC 20 token dot approve spender address, and then amount amount to spend.

12108
19:55:18.716 --> 19:55:21.841
We'll do we'll do a wait TX dot wait for one block.

12109
19:55:22.716 --> 19:55:25.941
a little console dot log saying approved.

12110
19:55:27.716 --> 19:55:33.516
this function before you try to deposit you'll just get an error saying hey, token is not approved, which is a pretty common error.

12111
19:55:33.516 --> 19:55:37.490
So if you ever see that just know, I forgot to approve my token.

12112
19:55:37.490 --> 19:55:41.409
So backup in our main script, we'll go ahead and run this function.

12113
19:55:41.409 --> 19:55:54.182
We'll say await approve ERC 20 with the Web Token address lending pool dot address because we want to give the len pool the approval to pull our web token from our account.

12114
19:55:54.182 --> 19:56:00.028
And then we'll give it some amount to actually will import a mount from get weath as well.

12115
19:56:00.028 --> 19:56:04.890
Mount we gotta go back to get with an export it so we can actually import it.

12116
19:56:04.890 --> 19:56:07.974
So get with exporting that amount that 0.

12117
19:56:07.974 --> 19:56:08.135
02.

12118
19:56:08.135 --> 19:56:14.372
So we'll prove the amount and then we'll connect we'll have our Deployer do it obviously because we're doing everything with the Deployer.

12119
19:56:14.372 --> 19:56:15.897
So we'll approve the ERC 20.

12120
19:56:15.897 --> 19:56:19.717
And then once we approve, we can go ahead and deposit it.

12121
19:56:19.717 --> 19:56:23.104
So we'll say console dot log, depositing that.

12122
19:56:23.104 --> 19:56:27.942
And then we'll run await lending pool dot deposit.

12123
19:56:27.942 --> 19:56:35.450
If we look at the deposit function, we can see all the parameters that the deposit function takes.

12124
19:56:35.450 --> 19:56:40.117
We can also see it in the Ave v2 documentation and we just look forward the posit.

12125
19:56:40.117 --> 19:56:55.190
And we can see it takes the address of the asset that we're going to deposit how much of that asset we're going to deposit address on behalf of we're going to do it on behalf of ourself and then a referral code, which right now is just always going to be zero because the referral code has been discontinued.

12126
19:56:55.190 --> 19:57:02.479
So we're going to deposit the wet token address, we're going to deposit our web token, we're going to posit 0.

12127
19:57:02.479 --> 19:57:04.512
02 of that web token.

12128
19:57:04.717 --> 19:57:08.517
And then we're going to use a deployer ash and then referral code is going to be zero.

12129
19:57:08.517 --> 19:57:11.304
And then we'll do a little console dot log the positive.

12130
19:57:11.304 --> 19:57:13.288
So let's try this script.

12131
19:57:13.288 --> 19:57:15.061
Let's see if it works.

12132
19:57:15.061 --> 19:57:23.029
I'm just going to hit up to go ahead and rerun this script to rerun this command I just ran into doing a little compiling that ERC 20.

12133
19:57:23.029 --> 19:57:29.436
That song was compiled one solidity file, got a bunch of wrapped Aetherium lending pool address.

12134
19:57:29.436 --> 19:57:33.828
We approved it, we deposit we were depositing it and then we deposited it.

12135
19:57:33.828 --> 19:57:42.560
So if we're looking at our little readme here, we get a little checkmark.

12136
19:57:42.717 --> 19:57:46.640
We've done step one, we've deposited our collateral.

12137
19:57:46.717 --> 19:57:47.092
Awesome.

12138
19:57:49.717 --> 19:57:50.544
other assets.

12139
19:57:50.544 --> 19:57:50.957
Great.

12140
19:57:53.718 --> 19:57:58.931
and learn how to borrow now through a couple of new lines, and we'll say borrowed time.

12141
19:57:58.931 --> 19:58:04.651
So in order for us to borrow, we probably want to know how much we can borrow.

12142
19:58:04.651 --> 19:58:15.646
And we want to know more about our account, right? We want to know how much we have borrowed, how much we have in collateral and how much we can borrow.

12143
19:58:15.646 --> 19:58:33.780
So there's a function that Avi comes with called Get User account data, which will return the user's account data across all reserves, how much collateral we have down the total value it in its eath price, we have the available borrows and eath current liquidation threshold, loan to value etc.

12144
19:58:33.780 --> 19:58:36.217
Now these are really important metrics.

12145
19:58:36.217 --> 19:58:40.843
If we have one, eath and collateral that doesn't mean we can borrow one eath of assets.

12146
19:58:40.843 --> 19:58:45.801
Each one of these tokens have some different values like loan to value.

12147
19:58:45.801 --> 19:59:00.984
For example, if you have one eath you can only borrow zero point 75 for the dye token, this is to reduce risk of the collateral and reduce risk of people not having enough collateral down as prices fluctuate.

12148
19:59:00.984 --> 19:59:11.472
There's a liquidation threshold of 80% if you have one eath as collateral and point 81 eath borrowed, you'll get what's called liquidated.

12149
19:59:11.472 --> 19:59:25.363
So what is liquidation? When you put down collateral and you borrow, if the amount that you have borrowed past this liquidation threshold is passed that 80% Or, or depending on different assets, it's different people can do what's called liquidate you.

12150
19:59:25.363 --> 19:59:29.586
This is when they pay back some of your loan that you took out.

12151
19:59:29.586 --> 19:59:33.891
And they also get to buy some of your collateral at a cheaper price.

12152
19:59:33.891 --> 19:59:45.929
This keeps the Ave platform solvent, and it makes it so that there's never more borrows than there are collateral in order to borrow assets, we still need that collateral down.

12153
19:59:45.929 --> 19:59:53.396
So basically, if you borrowed more money than you've put up, other users can can take the money that you've put up in return for them paying for your loans.

12154
19:59:53.396 --> 19:59:55.428
So we obviously don't want this to happen.

12155
19:59:55.428 --> 20:00:00.346
And the audit protocol programmatically doesn't want to have not enough money to do this.

12156
20:00:00.346 --> 20:00:15.922
So they incentivize users to liquidate, in case of these failures is the protocols come with this thing called a health factor, which if this health factor is below one, you go ahead and you get liquidated, the actual function to liquidate somebody is called liquidation call.

12157
20:00:15.922 --> 20:00:23.719
So you can actually build a bot and you can liquidate users who go insolvent and you can make a fee, you can make a reward for actually doing this.

12158
20:00:23.719 --> 20:00:28.451
These protocols need to stay solvent, they need to have enough money to lend out.

12159
20:00:28.451 --> 20:00:30.957
And they programmatically enforced this, which is why it's so great.

12160
20:00:30.957 --> 20:00:34.600
You can learn more about liquidations in the liquidation documentation.

12161
20:00:34.600 --> 20:00:43.915
So this get us account data will tell us how much we have collateral, how much we have in debt, and how much we have available to borrow based on how much collateral we have.

12162
20:00:43.915 --> 20:00:51.589
We can see the current liquidation threshold we can see the loan to value and then we can see our health factor, which is obviously really important.

12163
20:00:51.589 --> 20:00:55.052
If our health factor ever falls below one, we get liquidated.

12164
20:00:55.052 --> 20:00:59.173
So we never want this hell factor to fall below one when we're borrowing assets.

12165
20:00:59.173 --> 20:01:01.096
So let's create a function that can grab that first.

12166
20:01:01.096 --> 20:01:04.959
So let's create a new function called async.

12167
20:01:04.959 --> 20:01:16.862
Function get it borrow user data, and we'll pass in the lending pool contract, we'll pass in the lending pool contract and the account that we want to get the data for.

12168
20:01:16.862 --> 20:01:17.814
So we can say const.

12169
20:01:17.814 --> 20:01:25.386
And actually, we can pull out just the values that we want, we could pull out the total collateral eath total debt eath and the available to borrow.

12170
20:01:25.386 --> 20:01:37.684
Let's just pull out the total collateral eath the total debt if and the available, borrows.

12171
20:01:37.684 --> 20:01:48.478
So this equals await, lending pool dot get user account data of account.

12172
20:01:48.478 --> 20:02:06.360
And now we'll even just kind of logged us out we'll say console dot log you have total collateral eath worth of eath the positive console.

12173
20:02:06.360 --> 20:02:29.220
Log you have total debt eath worth of eath borrowed and then console dot log you can borrow available borrows eath worth of eath.

12174
20:02:29.220 --> 20:02:36.369
And then we'll just return available to borrow will turn available borrows eath.

12175
20:02:36.369 --> 20:02:43.136
And we'll return or total debt, we don't really need to return total collateral we could if we want we really just want to print it out here.

12176
20:02:43.136 --> 20:02:57.302
So now back in our function, we can do in our main function, we can run let, I'm going to do that because we're going to be calling this a few times available borrows eath.

12177
20:02:57.302 --> 20:03:06.157
And total debt eath equals await, get borrow user data of lending pool and Deployer.

12178
20:03:06.157 --> 20:03:15.302
And if we run this, we'll see how much we can actually borrow yarn hard hat or just h h run scripts on a borrowed.

12179
20:03:15.302 --> 20:03:18.283
js and work on our forked blockchain here.

12180
20:03:18.283 --> 20:03:20.287
And remember, it is going to be a little bit slower.

12181
20:03:20.287 --> 20:03:26.475
And this is kind of one of the disadvantages too because it does have to make API calls whenever we want to interact with these chains.

12182
20:03:26.475 --> 20:03:29.121
And then we got total collateral eath is not defined.

12183
20:03:29.121 --> 20:03:31.830
And that's because I spelt total wrong.

12184
20:03:31.830 --> 20:03:34.251
So let's spell total correctly.

12185
20:03:34.251 --> 20:03:35.990
And we'll run this again.

12186
20:03:35.990 --> 20:03:37.005
But okay, great.

12187
20:03:37.005 --> 20:03:45.931
So you have this month's worth of eath deposited, you have zero worth of eath borrowed because we haven't borrowed anything, and you can borrow this much worth of eath.

12188
20:03:45.931 --> 20:03:51.990
Remember, the amount that we can borrow is always going to be less than the total amount that we have as deposited.

12189
20:03:51.990 --> 20:03:54.593
That's why we see this lower number here.

12190
20:03:54.721 --> 20:03:55.054
So cool.

12191
20:03:55.054 --> 20:03:56.625
So that's how much we can borrow.

12192
20:03:57.721 --> 20:03:58.971
and borrow some time.

12193
20:04:01.721 --> 20:04:03.884
an eighth and we're gonna get to borrow time.

12194
20:04:04.721 --> 20:04:11.180
gonna get to borrow time, but we need to figure out What's the conversion rate of diets? We're gonna get how much we can borrow in eath.

12195
20:04:11.180 --> 20:04:12.884
But we want to borrow dye.

12196
20:04:12.884 --> 20:04:19.151
So how much of dye can we borrow based off of the value of eath? And to do that, we're gonna have to get the dye price.

12197
20:04:19.151 --> 20:04:22.984
And how are we going to do that? Well, you guessed it, we're going to use chain link price feeds.

12198
20:04:22.984 --> 20:04:30.382
If you look in the AVI documentation, you can find price Oracle, which is a contract that you could actually use right directly from Avi.

12199
20:04:30.382 --> 20:04:34.689
But the first thing it does is check from a chain link aggregator, which we already know how to do.

12200
20:04:34.722 --> 20:04:38.436
So we're gonna go ahead and just call directly from the chain link aggregator.

12201
20:04:38.436 --> 20:04:46.099
So let's create a new function function, we'll call it get dye price is first we're going to need to get that interface, same thing.

12202
20:04:46.099 --> 20:04:56.394
So you can either go right to Hardhead defy and just grab the interface right from here, we could swap this out with just an import from chainlink NPM, as well.

12203
20:04:56.394 --> 20:05:03.183
But I'm just going to go ahead and copy paste a new file, this is going to be the Ag reg gate, Tor v3 interface.

12204
20:05:03.183 --> 20:05:05.993
Dot saw that we've worked with so many times.

12205
20:05:05.993 --> 20:05:14.239
Now that we have this interface, this will compile, we're obviously looking for latest round data, which will give us this answer here, which is going to be the price.

12206
20:05:14.239 --> 20:05:15.342
So let's go ahead and grab that.

12207
20:05:15.342 --> 20:05:30.675
So we'll say const di eath price feed equals await ethers dot get contract at and we'll use the air, Greg a Tor v3 interface will get the dye eath price feed right from the chain link Docs.

12208
20:05:30.722 --> 20:05:38.106
So we go to docs dot chain dot link UVM chains will go to contract addresses on Aetherium.

12209
20:05:38.106 --> 20:05:40.567
Or look for di eath on Main net.

12210
20:05:40.722 --> 20:05:42.436
And we see di eath is right here.

12211
20:05:43.722 --> 20:05:47.152
again, we're just hard coding it in the GitHub repo associated with it.

12212
20:05:47.152 --> 20:05:52.175
With this, we put it in a little config file, but we can just go ahead and hard coded in.

12213
20:05:52.175 --> 20:05:55.609
And for this one, we don't need to connect this to the deployer account.

12214
20:05:55.609 --> 20:06:01.037
Since we're not going to be sending any transactions, we're just going to be reading from this contract, right.

12215
20:06:01.037 --> 20:06:04.597
So reading don't need a signer sending me to signer.

12216
20:06:04.597 --> 20:06:13.587
Now we can say const price equals a weight dye eath price feed dot latest round data.

12217
20:06:13.587 --> 20:06:19.384
Now latest round data, as we know is going to return us this huge thing.

12218
20:06:19.384 --> 20:06:22.477
And we only want the answer at the first index.

12219
20:06:22.477 --> 20:06:25.550
So another way we could do this, we could just wrap this whole thing up.

12220
20:06:25.550 --> 20:06:30.691
And then once this returns, we're gonna say okay, just grab that first index here, which will be that price.

12221
20:06:30.691 --> 20:06:36.846
And then we could do a little console dot log, the dy eath.

12222
20:06:36.846 --> 20:06:42.437
Price is in price dot two, like that, and then return price.

12223
20:06:42.437 --> 20:06:47.119
So we can go ahead and run this as well test this out, just by hitting up and then enter.

12224
20:06:47.119 --> 20:06:51.563
Depositing we deposited this is how much we can deposit.

12225
20:06:51.723 --> 20:06:54.675
Nothing Oh, and I forgot to call it oh, excuse me, let's go up.

12226
20:06:54.723 --> 20:07:01.167
This, let's say const dye price equals await get dye price.

12227
20:07:01.723 --> 20:07:01.985
tada.

12228
20:07:05.723 --> 20:07:12.182
we know is going to be $3,289 which is which of course is gonna be 3289 di per eath.

12229
20:07:12.182 --> 20:07:18.011
Now that we have the dye price, we can figure out how much dye we want to borrow.

12230
20:07:18.011 --> 20:07:19.434
So great, we have the price.

12231
20:07:19.434 --> 20:07:27.417
Now let's figure out the amount that we can borrow in dye, we have the amount we can borrow eath, we need to convert it to die.

12232
20:07:27.417 --> 20:07:36.373
So we'll say const amount die to borrow equals available, be the available borrows in eath.

12233
20:07:36.373 --> 20:07:37.223
to string.

12234
20:07:37.223 --> 20:07:40.473
And then in JavaScript, we can do this.

12235
20:07:40.473 --> 20:07:43.115
to string but still do math.

12236
20:07:43.115 --> 20:07:44.293
So times 0.

12237
20:07:44.293 --> 20:07:49.852
95 times and then we'll do the reciprocal of that die.

12238
20:07:49.852 --> 20:07:52.562
So one divided by die price.

12239
20:07:52.562 --> 20:07:53.433
to number.

12240
20:07:53.724 --> 20:07:58.320
So this will give us the amount of die that we can borrow.

12241
20:07:58.724 --> 20:08:00.452
then we'll want to get this in way.

12242
20:08:01.724 --> 20:08:08.561
right now, console dot log, you can borrow.

12243
20:08:08.724 --> 20:08:13.543
Run this now, you can borrow amount die to borrow.

12244
20:08:14.724 --> 20:08:20.771
units, which we need in way units, but you can borrow 48 Die, which based off the price looks about right.

12245
20:08:20.771 --> 20:08:26.962
So to get the correct units, we'll say const amount, di to borrow way.

12246
20:08:26.962 --> 20:08:34.137
That's going to equal ethers dot utils dot parse ether, MT di to borrow.

12247
20:08:34.137 --> 20:08:34.757
to string.

12248
20:08:34.757 --> 20:08:39.807
This is just purely the amount of dye to borrow right so we get 48.

12249
20:08:39.807 --> 20:08:40.307
79 die.

12250
20:08:40.307 --> 20:08:47.411
But again, we want that in way the die token has 18 decimal places similar to Aetherium.

12251
20:08:47.411 --> 20:08:51.805
So we need that amount in way and then we can go ahead and start actually borrowing now.

12252
20:08:51.805 --> 20:08:59.527
So we'll create a new function called borrow die async function, borrow die will take the die address.

12253
20:08:59.527 --> 20:09:09.124
Take the lending pool, take the amount die to borrow and weigh in Then of course, we'll take the account.

12254
20:09:09.124 --> 20:09:11.649
And all we'll do is we'll do const.

12255
20:09:11.649 --> 20:09:21.232
Borrow TX is going to be a weight, lending pool dot borrow, die address, amount die to borrow.

12256
20:09:21.232 --> 20:09:39.364
And again, we can go right to the documentation, if we want, it takes the address of the asset, the amount, we want to borrow the interest rate mode, which is going to be variable or stable, the referral code and then address on behalf of, we're going to say one for the interest rate mode, where one is going to be stable.

12257
20:09:39.364 --> 20:09:57.249
And then we're going to do zero or this referral code because that's debunked now, and then we'll do a count, then we'll do a wait, borrow TX dot Wait, wait one transaction, and then we'll do console dot log you've borrowed.

12258
20:09:57.249 --> 20:09:58.560
Well, and that's it.

12259
20:09:58.560 --> 20:10:01.249
So we now have this borrowed I function.

12260
20:10:01.249 --> 20:10:06.788
So back up in our main function, right, now, we can finally do the borrow time.

12261
20:10:06.788 --> 20:10:09.248
So we'll do a wait, borrow die.

12262
20:10:09.248 --> 20:10:11.567
And we'll pass those parameters in here.

12263
20:10:11.567 --> 20:10:18.610
So we're going to do const, die token address, equals and we're just going to hard code this from main net.

12264
20:10:18.610 --> 20:10:33.325
So we can look up die token address, main net, we'll grab this address here, this looks like this is indeed the DI token, we check right on the object get up, we could check right on the ABI of actual code, since we're just testing, we're just gonna go ahead and grab from ether scan here.

12265
20:10:33.325 --> 20:10:45.832
So for borrow dye, we're gonna need the dye token address, we're gonna need the lending pool contract the amount of dye to borrow in way, and then our Deployer.

12266
20:10:45.832 --> 20:10:48.499
And then we'll await borrow dye.

12267
20:10:48.499 --> 20:10:56.486
And then we will run this get bar user data again, just print out the information about where we are after we do that.

12268
20:10:56.486 --> 20:11:12.146
So when we can run this, again, we should see the amount that we have borrowed, updated, our first call to that function is gonna say, Hey, you have this much eat the positive Do you have nothing borrowed, you can borrow this much eath, we get the price, we get how much we borrowed, we borrow.

12269
20:11:12.146 --> 20:11:20.226
And now it says you have this much where the eath deposited and you have this much worth of eath borrowed and you can borrow this much eat.

12270
20:11:20.226 --> 20:11:25.106
So we actually now have bought a bunch of this dye actually borrowed.

12271
20:11:25.106 --> 20:11:31.365
And the reason we're doing times zero point 95, we don't want to hit that cap of the maximum amount that we can borrow.

12272
20:11:31.365 --> 20:11:35.070
So we're saying hey, let's get 95% of the amount that we actually can borrow.

12273
20:11:35.070 --> 20:11:38.887
So we're not going to borrow everything, we're just gonna borrow 95%.

12274
20:11:38.887 --> 20:11:42.226
And you can see that the amount of eath we have deposited is actually higher.

12275
20:11:42.226 --> 20:11:48.659
This is because we're actually gaining interest just by having this eath deposited.

12276
20:11:48.659 --> 20:11:55.036
And now that we have some dye borrowed, we borrowed 48 dye, which is equivalent to this much Aetherium.

12277
20:11:55.036 --> 20:12:03.591
And then we still have a little bit more we can borrow because we only borrowed 95%, which is great.

12278
20:12:03.726 --> 20:12:09.154
Awesome, we've taken out a borrow programmatically, let's repay at least some of it here.

12279
20:12:09.154 --> 20:12:16.277
So we're gonna have to create a new function that's going to use the repay function in the contract.

12280
20:12:16.277 --> 20:12:52.440
So we're gonna do async function repay, and this is going to take the amount that we want to repay the dye address that we're going to repay the lending pool and then the account now to repay once again, we're going to have to approve sending our dye back to Ave So in here, the first thing we need to do is we actually need to call wait prove ERC 20 with the dye address, lending pool dot address, mount and then accounts, right because approve ERC 20.

12281
20:12:52.440 --> 20:12:57.489
That's the input parameters it takes, and we need to approve sending the dye back to the contract.

12282
20:12:57.489 --> 20:12:59.927
So we borrowed it, and we're gonna send it back.

12283
20:12:59.927 --> 20:13:01.977
Now we're actually going to send it back.

12284
20:13:01.977 --> 20:13:11.527
So let's say const, repay TX equals await, lending, cool that repay the address, amount, one account.

12285
20:13:11.527 --> 20:13:29.227
And then we'll say await repay TX dot Wait, that will do console dot log repaid up in our main function, we're going to do a weight repay, and we're going to give it the amount dye to borrow in way.

12286
20:13:29.227 --> 20:13:40.615
We're gonna give it the dye token address, give it lending pool, and then we'll give it deployer get you borrow user data one more time just so we can print out the final amounts.

12287
20:13:40.615 --> 20:13:46.133
Now, you'll notice something though, we're going to give back all of the dye that we borrowed.

12288
20:13:46.133 --> 20:14:00.803
However, we're still going to have a dye balance, you'll see that when I run this that we're still have a little bit of Aetherium borrowed, basically, we'll still have a dye balance because we'll still have a little bit of die borrow and try to figure out why before I answer it actually.

12289
20:14:00.803 --> 20:14:16.289
So we have this tiny, tiny tiny amount of eath borrowed here and we have a much larger amount of eath deposited so Why do we still have this tiny, tiny amount of eath borrowed? Well, the reason is because as we borrow dye, we actually accrued interest.

12290
20:14:16.289 --> 20:14:17.907
So we still owe dye back.

12291
20:14:17.907 --> 20:14:26.574
Now what we can do is we can do something like uniswap, to actually swap our Aetherium, for dye to repay the rest of our debt here.

12292
20:14:26.574 --> 20:14:33.812
And that's how we could actually finish repaying all the debt is to get a little bit more dye to pay off that interest that we had accrued.

12293
20:14:33.812 --> 20:14:43.211
And if you want, you can go back and you can do the exact same thing we did here to grab the uniswap code, place it in here to programmatically repay your debt as well.

12294
20:14:43.211 --> 20:14:47.464
But at this point, you have just gone through the entire lifecycle here.

12295
20:14:47.464 --> 20:14:51.105
And that is absolutely massive, huge congratulations.

12296
20:14:51.105 --> 20:14:58.278
You've just deposited borrowed and repaid tokens from the AVI protocol.

12297
20:14:58.278 --> 20:15:24.728
Now I'm going to go briefly show you what some of these transactions are going to look like on an actual test net, on an ether scan, you'll see that when we deposit our collateral, we actually get back what's called an A token, or an interest bearing token, these tokens keep track of how much collateral or in our case how much web token we have deposited in the AVI protocol.

12298
20:15:24.728 --> 20:15:52.331
And when we want to withdraw our wealth back, we burn these eight tokens, we remove these eight tokens, you can see that our first transaction is going to be deposit and I wanted to show you what it looks like when you actually deposit one of these tokens, this transaction associated with this lending pool, that deposit right here, if you look at tokens transfer down here, you can see we actually we deposited, you can see that we actually sent rapt ether to the ARB a contract.

12299
20:15:52.331 --> 20:15:55.417
Now you'll also see this a weath stuff here.

12300
20:15:55.417 --> 20:15:57.442
So what is this a with stuff.

12301
20:15:57.442 --> 20:16:07.355
So to keep track of how much you've actually deposited into Ave, Ave will give you your own a wealth token or a token to keep track.

12302
20:16:07.355 --> 20:16:15.665
And this is this interest bearing token, you actually can see up here a little bit of interest already for actually depositing these tokens into the protocol.

12303
20:16:15.729 --> 20:16:21.292
And it's this token, that will keep going up, the more people borrow and the more people use the protocol.

12304
20:16:21.292 --> 20:16:28.519
So you can actually grab this token address, interest bearing token this a token, I can import it into my meta mask.

12305
20:16:28.519 --> 20:16:30.479
And I can see that I have 0.

12306
20:16:30.479 --> 20:16:44.014
1, which represents my initial deposit 00517 dot that dot A with and if you keep this up long enough, this number will slowly go up as you get more and more.

12307
20:16:44.014 --> 20:16:51.676
Because the interest keep out and you can see just went went up right there, the interest will keep changing and keep going up.

12308
20:16:51.729 --> 20:16:57.879
Obviously, we have so little deposited that the interest isn't gonna go up very quickly, but it will go up, the more people use the protocol.

12309
20:16:57.879 --> 20:17:06.354
And since I'm using a test net, the actual usage of the protocol isn't very high, but you get the picture.

12310
20:17:06.729 --> 20:17:09.118
Awesome, you've done phenomenal to get this far.

12311
20:17:09.729 --> 20:17:11.929
quick recap of everything that we've learned.

12312
20:17:12.729 --> 20:17:14.443
head on to the next section.

12313
20:17:16.729 --> 20:17:24.118
token or the wrapped Aetherium token, it's a way to tokenize our Aetherium or layer one blockchain native token.

12314
20:17:24.118 --> 20:17:30.118
Then we learned a little bit about the AVI protocol, and how it's this defy primitive for borrowing and lending assets.

12315
20:17:30.118 --> 20:17:58.516
And we can actually gain interest by depositing our tokens and our assets into Ave we learned a little bit of also about uniswap, which is another incredibly important defy protocol, which allows us to swap tokens between each other in the decentralized context, then we learned that we can actually deposit some of our tokens into the AVI protocol, which is a decentralized borrowing and lending platform and similar to a bank will actually gain interest on our deposited tokens.

12316
20:17:58.516 --> 20:18:00.237
But first, we have to approve them.

12317
20:18:00.237 --> 20:18:06.491
Because anytime you want a contract to interact with your tokens, you need to approve the contract to do so.

12318
20:18:06.491 --> 20:18:11.628
And then we go ahead and deposit once we deposited we got the dye price.

12319
20:18:11.628 --> 20:18:19.230
And then we learned that we can actually borrow dye we can borrow an asset based off of how much collateral we put down.

12320
20:18:19.230 --> 20:18:21.306
And then we learned how to repay it back.

12321
20:18:21.306 --> 20:18:26.158
We learned about forking a blockchain as opposed to using our own main blockchain.

12322
20:18:26.158 --> 20:18:37.285
Another thing to know if you are using an RPC URL like something from alchemy so awesome you've learned a ton about defy now defi is an absolutely massive powerhouse when it comes to the blockchain.

12323
20:18:37.285 --> 20:18:40.630
And it is one of the most important things blockchains can do.

12324
20:18:40.630 --> 20:18:43.776
If you want to learn more about defy and read more on Defy.

12325
20:18:43.776 --> 20:18:54.110
I've got some more links in the GitHub here so that you can learn more about defy and one of them in particular that I want to show you is this one called speed run Etherium.

12326
20:18:54.110 --> 20:18:59.246
Not only does it give you a ton of defy examples, but it gives you a whole bunch of other examples as well.

12327
20:18:59.246 --> 20:19:02.968
And this will be a good test of everything that you've learned after you pass this course.

12328
20:19:02.968 --> 20:19:16.301
Or even right now if you want to or whenever you want and to talk about it a little bit more, we actually have Austin Griffiths here to talk a little bit more about speed run Aetherium himself, I'll pass it over to Austin.

12329
20:19:16.730 --> 20:19:19.649
Hey, what's up, I'm Austin Griffith, I want to show you speed run Aetherium.

12330
20:19:19.649 --> 20:19:23.020
speed run Aetherium is a great way to get started in Aetherium.

12331
20:19:23.020 --> 20:19:29.110
If you are a developer, it's targeted at web two developers becoming web three developers speed run a theory.

12332
20:19:29.110 --> 20:19:29.236
m.

12333
20:19:29.236 --> 20:19:30.378
com is the website.

12334
20:19:30.378 --> 20:19:36.649
It takes you through both getting started and kind of getting getting an idea for the language and the syntax.

12335
20:19:36.649 --> 20:19:38.353
But that's just the start.

12336
20:19:38.353 --> 20:19:42.993
Just understanding the language is just the start, you feel like you're you can do anything.

12337
20:19:42.993 --> 20:19:47.911
And you're on the top of the world when you finally get the syntax of solidity together, and you can jam through a smart contract.

12338
20:19:47.911 --> 20:19:53.665
But really getting context with the space and figuring out what works and what doesn't, that's a whole nother battle.

12339
20:19:53.665 --> 20:19:55.484
And that's where speed run aetherium.

12340
20:19:55.484 --> 20:19:56.492
com comes in.

12341
20:19:56.492 --> 20:19:59.634
So let's speed run the speed run.

12342
20:19:59.634 --> 20:20:12.295
First, you will get scaffold e down speedrun Aetherium kind of revolves around scaffold eath and uses scaffold eath as a base, you'll want to tinker around with some ideas within solidity.

12343
20:20:12.295 --> 20:20:14.668
And let me show you what I mean by that.

12344
20:20:14.668 --> 20:20:19.569
So with scaffold eath, you have a front end and you have your smart contract.

12345
20:20:19.569 --> 20:20:23.159
So scaffold eath comes with hard hat out of the box.

12346
20:20:23.159 --> 20:20:32.397
And you will use the combination of hard hat and react to build a DAP where you'll deploy both the smart contract and the front end.

12347
20:20:32.397 --> 20:20:41.934
And this, this ability to edit your smart contract and have your front end auto adapt to it is kind of the key to scaffold ease.

12348
20:20:41.934 --> 20:20:44.425
I just added some extra extra exclamation points.

12349
20:20:44.425 --> 20:20:45.961
But we'll see that show up over here.

12350
20:20:45.961 --> 20:20:48.924
Once this contract deploys, there we go, there's that.

12351
20:20:48.924 --> 20:21:07.981
So just real quick, again, if I create like a un 256 public counter, and we set that equal to five, and then I build a function called increment, that's public that does counter public, there we go, that does counter plus, plus, you can imagine what's going to happen here.

12352
20:21:07.981 --> 20:21:14.338
So you, you edit a little bit of solidity, you deploy your contract, and then your front end auto adjust to that.

12353
20:21:14.338 --> 20:21:32.300
And it gives you the ability as a developer to call those functions tinker with your smart contract to play around, you can even have a console log in there, where it you know, sets says the count now is there we go something like this.

12354
20:21:32.300 --> 20:21:34.232
And let's go ahead and deploy that.

12355
20:21:34.232 --> 20:21:40.841
Notice I'm doing these quick iterations, I'm making small changes in solidity, and I'm seeing those changes show up in the front end.

12356
20:21:40.841 --> 20:21:45.107
And I'm tinkering with those in the front end and testing my assumptions.

12357
20:21:45.107 --> 20:21:58.028
Here, if we go look at our hard hat node, when I make this increment call, we should see that nice console log there, you know, this address, set the count to eight, right? Very, very cool.

12358
20:21:58.028 --> 20:21:59.506
So this is scaffold eath.

12359
20:21:59.506 --> 20:22:15.312
This is what speed run Aetherium is built on top of, you'll get in here, you'll edit your smart contract, then you'll edit your front end, you'll point your front end at some particular network, you'll deploy your smart contract, you'll deploy your app, it just gives you the ability to have a front end along with your smart contract.

12360
20:22:15.312 --> 20:22:18.909
And you'll have that as you're building your smart, smart contract.

12361
20:22:18.909 --> 20:22:40.460
So to have this front end, to tinker with your smart contract is going to help you kind of figure out how you want to write your solidity, like, is this going to be a mapping? Is this going to be an array? How am I going to track this struct, you can kind of do this in an iterative process by just throwing it in here into your smart contract and tinkering with it on the front end and trying it out and seeing what you need to build.

12362
20:22:40.460 --> 20:22:41.655
So that's scaffold eath.

12363
20:22:41.655 --> 20:22:45.669
And that's the base that you'll need to get started with speed run Ethereum.

12364
20:22:45.669 --> 20:22:55.194
Once you've you're able to have this all installed, you'll you'll have your kind of react front end here with yarn start, you'll have yarn chain, which will run your your hard hat node, then you'll do yarn deploy.

12365
20:22:55.194 --> 20:23:00.683
Once you have that setup locally, you're ready to go with speed run Aetherium.

12366
20:23:00.683 --> 20:23:03.751
And you can also do this right here and challenge zero.

12367
20:23:03.751 --> 20:23:15.634
So challenge zero, gotta go zero index, right, we got to be nerdy challenge zero sets you up with just getting the environment setup, you'll you'll quest on building a simple NFT example.

12368
20:23:15.634 --> 20:23:18.410
It's going to come with an NFT smart contract.

12369
20:23:18.410 --> 20:23:25.800
And it's going to come with an NFT front end a little kind of like minting view, it'll come with all of this stuff to do that.

12370
20:23:25.800 --> 20:23:39.478
And it'll walk you through basically challenge the row is going to hold your hand, it's going to take you through every step you'll have to get get you have to have a certain version of node E, L some some correct range of node and yarn installed.

12371
20:23:39.478 --> 20:23:45.184
Watch out yarn has an executable on Linux, make sure you have the yarn, the package manager.

12372
20:23:45.184 --> 20:23:51.750
But after you have get your node and yarn, you'll run through cloning down each challenge.

12373
20:23:51.750 --> 20:23:55.699
You'll do an install, you'll fire up the chain and you'll fire up your front end.

12374
20:23:55.733 --> 20:24:00.170
And you'll have a working app that lets you interface with your NFT smart contract.

12375
20:24:00.170 --> 20:24:03.571
You'll go through here and you'll learn about wallets.

12376
20:24:03.571 --> 20:24:07.833
Then you'll start minting NF Ts and you'll send those NF T's are Round.

12377
20:24:07.833 --> 20:24:11.240
And that's challenge zero, it's just getting you started.

12378
20:24:11.240 --> 20:24:15.999
Here even in challenge zero, you'll deploy this NFT to Rinkeby.

12379
20:24:15.999 --> 20:24:22.470
And you'll also deploy an app and allow your friends to go to your app and mint in FTS on Rinkeby.

12380
20:24:22.470 --> 20:24:28.682
So that's the first challenge, it looks like we even like dive into open see and play around with some of those mechanics.

12381
20:24:28.733 --> 20:24:36.333
The second challenge challenge number one challenge one of speed runner theory is like where it all really starts.

12382
20:24:36.333 --> 20:24:39.527
This really shows off the superpower of Aetherium.

12383
20:24:39.527 --> 20:24:40.415
It sets it up.

12384
20:24:40.415 --> 20:24:50.208
So you need to build an app where a bunch of people that don't necessarily trust each other, can coordinate and stake into a smart contract.

12385
20:24:50.208 --> 20:24:52.334
And this is like, this is the superpower of Aetherium.

12386
20:24:52.334 --> 20:25:09.499
The ability for you, the developer to write a few simple rules to allow jerks to coordinate financially, and not greet each other and steal each other's money, right? You're we're building these financial systems, there's, you know, game theory and economics and so many other things going on here.

12387
20:25:09.499 --> 20:25:15.511
But you as the developer, you're writing simple rules, and you're building a system that allows people to coordinate.

12388
20:25:15.511 --> 20:25:25.495
So challenge one, we'll take you through how to get set up with your steak or docile, smart contract, you'll install everything exactly the same way, you'll fire everything up.

12389
20:25:25.495 --> 20:25:29.019
And then it's just going to walk you through the kinds of things that you will need in your smart contract.

12390
20:25:29.019 --> 20:25:31.448
But you'll have to write the solidity yourself.

12391
20:25:31.448 --> 20:25:39.980
So this is this is not going to be a handheld tutorial, hell thing, you're going to have to write the smart contract yourself.

12392
20:25:39.980 --> 20:25:44.910
And there's some guidelines and some rails that kind of help you out, but it's not going to do it for you.

12393
20:25:44.910 --> 20:25:48.334
Okay, so that's, that's Quest One is or that's challenge.

12394
20:25:48.334 --> 20:25:51.267
One is building a decentralized staking app.

12395
20:25:51.267 --> 20:26:02.147
Then challenge two is building a token vendor this so in challenge one, you'll learn things like how to send money into a contract, how to have a contract, keep track of mappings.

12396
20:26:02.147 --> 20:26:29.670
In challenge two, you're going to learn contract to contract interaction, you're going to learn about ERC 20s, you're going to learn about specifically the approved pattern, which is kind of a jerk, it's, it's hard, it's a hard thing to deal with is the approved pattern, you need to go to your token contract and approve the vendor to take some money, then in a second transaction, you need to go to the vendor and have the vendor grab the money from the token contract and do something else.

12397
20:26:29.670 --> 20:26:42.319
So that's that's challenge two is learning about tokens and vendors, and is starting to really like get you kind of exposed to the idea of this like massive multiplayer game that is Aetherium.

12398
20:26:42.319 --> 20:26:48.062
And also kind of like how to build these vending machines that anybody can get to, then you'll build a Dex.

12399
20:26:48.062 --> 20:26:50.194
Now once you've once you're done with 01.

12400
20:26:50.194 --> 20:27:09.592
And two, you're really kind of you have a license to learn at this point, you're you're ready to really like go do some damage and build some cool things, maybe go build a couple other things, but come back and come come hit challenge three, challenge three is going to be a little bit more open ended, there's going to be a cohort of other people that are also building this.

12401
20:27:09.592 --> 20:27:15.412
And you have to get through the first three challenges to even get to challenge three to even get to this chat room.

12402
20:27:15.412 --> 20:27:23.480
But there's a chat room where other developers that are also building their own decks are all there together, and you can kind of learn with them and chat with them.

12403
20:27:23.480 --> 20:27:24.957
But you're going to build an exchange.

12404
20:27:24.957 --> 20:27:33.303
And you're going to build an exchange that works in a smart contract in a decentralized way with no centralized breaking points.

12405
20:27:33.303 --> 20:27:43.985
And what that's going to mean is you're going to have to have reserves of both eath and tokens and you're gonna have to have a pricing function and LP tokens and all sorts of other things that you'll have to learn about as you get to it.

12406
20:27:43.985 --> 20:27:46.831
Then challenge five is a multi SIG wallet.

12407
20:27:46.831 --> 20:28:00.968
Such a fundamental important thing about how to store your eath safely is going to be in a multi SIG wallet and how you can have multiple identities even even like the the base of like what a Dow is, is sort of like starting with a multi SIG wallet.

12408
20:28:00.968 --> 20:28:06.680
And you'll need to build one of those you'll need to understand call data call data is super weird and complex.

12409
20:28:06.680 --> 20:28:09.972
And everything's a transaction even when you're just poking a contract.

12410
20:28:09.972 --> 20:28:18.260
It's a transaction, and you have to craft that call data correctly to say, I would like to call this specific function on this specific contract.

12411
20:28:18.260 --> 20:28:32.464
So that's multisig wallets and then it kind of ends up we've got more challenges in the pipeline, but it kind of ends on build an SVG NFT so much fun to build an NF t that crafts the actual drawing in the smart contract and renders it.

12412
20:28:32.464 --> 20:28:39.683
So that's the speed run, go speed run Aetherium checkout scaffold, eat start building, build something awesome on Aetherium.

12413
20:28:39.736 --> 20:28:41.680
hearts, hearts, hearts, go get them.

12414
20:28:41.736 --> 20:28:56.593
Austin Griffith is one of the OGS when it comes to helping engineers get caught up and up to speed in the blockchain world so massive thank you to Austin for all he's done so far.

12415
20:28:56.736 --> 20:29:00.042
All right now we're gonna get into NF T's.

12416
20:29:00.042 --> 20:29:01.171
Let's do this.

12417
20:29:01.736 --> 20:29:05.820
I've already made a number of videos on what NF T's are and how to start working with NF T's.

12418
20:29:05.820 --> 20:29:16.316
So we're going to watch a portion of the previous Python edition of this course where I explain and a piece from a high level and then of course, we're gonna get into the ultimate NFT tutorial.

12419
20:29:16.316 --> 20:29:19.617
So let's learn about NF T's look, NF T's are hot right now.

12420
20:29:19.617 --> 20:29:25.908
Nf T's also known as ERC 720 ones are a token standard that was created on the Ethereum platform.

12421
20:29:25.908 --> 20:29:31.176
Nf T stands for non fungible token is a token standard similar to the ERC 20.

12422
20:29:31.176 --> 20:29:37.848
Again, ERC 20 is like link of a maker, all those goodies that are found on the Etherium chain.

12423
20:29:37.848 --> 20:29:45.382
An NF T or a non fungible token is a token that is non fungible, this means that they are starkly unique from each other.

12424
20:29:45.382 --> 20:29:49.684
And one token isn't interchangeable with any other token of its class.

12425
20:29:49.684 --> 20:29:56.091
A good way to think about it is $1 is interchangeable with any other dollar $1 is going to have the same value of another dollar.

12426
20:29:56.091 --> 20:30:16.227
Those are fungible tokens that's like ERC 20s one link is always going to be equivalent to one other link, by contrast is going to be NF T's those of you nerds out there, we know like a Pokemon would be a good example of an NFT you're one Pokemon is going to have different stats, different moves, sets, and isn't interchangeable with any other Pokemon, or maybe a more relatable one.

12427
20:30:16.227 --> 20:30:19.737
It's like a trading card, or unique piece of art or the like.

12428
20:30:19.737 --> 20:30:35.689
So that's what these NF T's are there non fungible, non interchangeable tokens that for the moment are best represented or thought about as digital pieces of art that are incorruptible and have a permanent history of whose own them who's deployed them, etc.

12429
20:30:35.737 --> 20:30:39.185
Now, like I said, NF T's are just a token standard.

12430
20:30:39.737 --> 20:30:41.441
can actually make them do much more than just be art.

12431
20:30:41.737 --> 20:30:48.037
give them stats, you can make them battle, you can do really unique things with them, you can do pretty much whatever you want with them.

12432
20:30:48.037 --> 20:31:01.874
But right now, the easiest way to think about it, and the most popular way to think about it is by calling them ah, ah, ah it's odd, or some type of collectible or just anything that's unique.

12433
20:31:01.874 --> 20:31:14.220
Now, they've been getting a ton of buzz recently, because we've been seeing more and more of these being sold at insane prices, like we saw x infinity sell nine plots of their land nine plots of their unique land for $1.

12434
20:31:14.220 --> 20:31:14.945
5 million.

12435
20:31:14.945 --> 20:31:24.281
We also saw the original creator of the Nyan Cat, you know, this cat sold for like 300 eath.

12436
20:31:24.281 --> 20:31:27.358
So apparently people really value these things.

12437
20:31:27.358 --> 20:31:35.214
So like I said, they're just tokens that are deployed on a smart contract platform, and you can view them on different NFT platforms like open sea or wearable.

12438
20:31:35.214 --> 20:31:38.687
And these are the NFT marketplaces that let people buy and sell them.

12439
20:31:38.738 --> 20:31:45.014
You obviously can do that without these marketplaces, because it's a decentralized but they're helping give a good user interface.

12440
20:31:45.014 --> 20:31:48.806
Now, like many of you out there, my initial thought to NF T's was okay, this sounds pretty dumb.

12441
20:31:48.806 --> 20:31:50.347
But I think that that was dumb.

12442
20:31:50.347 --> 20:31:52.081
I think art does have a lot of value.

12443
20:31:52.081 --> 20:31:55.492
And I think that artists are not always paid fairly for what they do.

12444
20:31:55.492 --> 20:32:05.466
And this is actually a huge issue right now in the modern day world where an artist can make some type of art people just copy paste it, you know, everywhere and, and they never get attribution for what they make.

12445
20:32:05.466 --> 20:32:14.996
So having a really easy decentralized royalty mechanism, or some type of mechanism where these artists can get accurately comped for what they're doing, I think, is really important.

12446
20:32:14.996 --> 20:32:15.625
I love music.

12447
20:32:15.625 --> 20:32:18.238
I love movies, those are pieces of art that I digest.

12448
20:32:18.238 --> 20:32:23.590
And I really like and I think it's fair for them to get comped appropriately because they are providing value to my life.

12449
20:32:23.590 --> 20:32:33.642
I think NF T's are a great way to solve this issue as kind of having these decentralized audit trails and, and royalty trails that we can set up and, and see really transparently without having to go through some centralized service.

12450
20:32:33.642 --> 20:32:35.118
So that's the basic gist of it.

12451
20:32:35.118 --> 20:32:41.118
Let's talk some more about the standards ERC 721 standard are the NFT standard.

12452
20:32:41.118 --> 20:32:48.338
This is the basis of it all there is another standard that's semi fungible tokens, the 1155 We're not going to talk about that here.

12453
20:32:48.338 --> 20:32:52.938
But you can check it out the main differences between a 721 and the ERC 20 and ERC.

12454
20:32:52.938 --> 20:32:58.024
20 is they have a really simple mapping between an address and how much that address holds.

12455
20:32:58.024 --> 20:33:02.045
720 ones have unique token IDs, each token ID has a unique owner.

12456
20:33:02.045 --> 20:33:06.439
And in addition, they have what's called a token URI, which we'll talk about in a minute.

12457
20:33:06.439 --> 20:33:07.989
Each token is unique.

12458
20:33:07.989 --> 20:33:11.322
Each token ID represents a unique asset.

12459
20:33:11.322 --> 20:33:17.739
So since these assets are unique, and we want to be able to visualize them and show what they actually look like we need to define those attributes of the object.

12460
20:33:17.739 --> 20:33:21.535
If it's a piece of art, we needed a way to define what that art looks like.

12461
20:33:21.535 --> 20:33:26.646
If it's some type of character in a game, we need to wait define that character stats in the NFT.

12462
20:33:26.646 --> 20:33:29.230
This is where metadata and token URI has come in.

12463
20:33:29.230 --> 20:33:37.246
So if you know anything about Aetherium, you know that sometimes gas prices getting pretty high, especially when it comes to storing a lot of space, it can get really, really expensive.

12464
20:33:37.246 --> 20:33:50.381
So one of your first questions might be Well, are they storing these images? And these are pieces on chain? And the answer is sometimes back when they were coming up with NF T's and artists were deploying stuff, the eath devs and the artists were like yeah, art, let's do that art.

12465
20:33:50.381 --> 20:33:54.673
I'm just gonna deploy This one megabyte image onto the Etherium chain.

12466
20:33:54.739 --> 20:34:00.627
And Oh god, it's so much gas expensive, delete button.

12467
20:34:00.739 --> 20:34:03.525
Otherwise, it's not, it's not good.

12468
20:34:05.739 --> 20:34:08.196
they put all this art on chain, it's going to be incredibly expensive.

12469
20:34:08.196 --> 20:34:12.339
So to get around this, what they did is they put in the standard, what's called the token URI.

12470
20:34:12.339 --> 20:34:23.437
This is a universally unique indicator of what that asset or what that token looks like and what the attributes of the token are, you can use something like a centralized API, or IPFS.

12471
20:34:23.437 --> 20:34:25.089
To actually get that token URI.

12472
20:34:25.089 --> 20:34:36.587
Typical token URI has to return something in this format like this, where it has the name, the image, location, the description, and then any attributes below, there is often this talk of on chain metadata versus off chain metadata.

12473
20:34:36.587 --> 20:34:49.213
Because it is so much easier and cheaper to store all your metadata off chain, a lot of people will use something like IPFS that is decentralized, but does take a little bit of centrality to keep persisting, but they can also use their own centralized API.

12474
20:34:49.213 --> 20:34:54.030
However, obviously, if that goes down, then you lose your image, you lose everything associated with your NFT.

12475
20:34:54.030 --> 20:35:02.055
Because of this most NFT marketplaces actually can't and won't read off on chain attributes or on chain metadata, because they're so used to looking for the token URI.

12476
20:35:02.055 --> 20:35:09.040
Obviously, if you do off chain metadata, you can't do anything really cool or really interesting or have any gains with your NF T's.

12477
20:35:09.040 --> 20:35:16.161
For example, if you wanted to create an on chain Pokemon game, all your attributes would need to be on chain in order for your Pokemon to interact with each other.

12478
20:35:16.161 --> 20:35:20.543
Because if it was off chain, then that becomes a lot harder to cryptographically prove.

12479
20:35:20.543 --> 20:35:24.379
So if you're new with NF T's and you're like wait, this is kind of a lot of information, I'll make it easy for you.

12480
20:35:24.379 --> 20:35:31.490
If you're looking to render an image, I'm an NFT, add your image to IPFS, add a metadata file pointing to that image file on IPFS.

12481
20:35:31.490 --> 20:35:35.422
And then grab that token URI and put it and set it as your NFT.

12482
20:35:35.422 --> 20:35:39.851
The chain link DND article does a great job of walking you through this and showing you how to do this.

12483
20:35:39.851 --> 20:35:46.865
So be sure to read that if you're looking to learn how to do that we're not going to cover that in this video, but we will be deploying our first NFT with some on chain attributes.

12484
20:35:46.865 --> 20:36:02.658
Again, having your attributes on chain is really going to allow you to build really creative NF T's that build games or have interesting properties and and really makes the authenticity of your NFT guaranteed because those attributes are always going to be on chain.

12485
20:36:02.740 --> 20:36:16.891
Alright, so now that we know the basics of approximately what an NF t is, and similar to the ERC 20 You can see the E IP 721 or the ERC 721 non fungible token standard on the Aetherium, ie IPs.

12486
20:36:16.891 --> 20:36:24.314
And once again, if you scroll down, you can see all the different events and the different functions that come with creating this token.

12487
20:36:24.314 --> 20:36:29.200
And now everything that we're going to do is going to be available at this GitHub repo.

12488
20:36:29.200 --> 20:36:38.788
This hard hat NFT FCC, we're going to actually go through all the code down to deploying and creating our own customized NFT.

12489
20:36:38.788 --> 20:36:51.812
And I've labeled this the ultimate NFT repo as part of this course, because we're going to go through a lot here, we're gonna go through a basic NFT, a real minimalistic NFT and then an IPFS hosted NFT.

12490
20:36:51.812 --> 20:36:52.954
That is dynamic.

12491
20:36:52.954 --> 20:37:05.445
And it uses randomness to generate unique NF T's so that we can have provably rare and appease or provably rare cards or provably rare tokens or stats or whatever you want.

12492
20:37:05.445 --> 20:37:08.991
And then we're going to do what's called an SVG NFT.

12493
20:37:08.991 --> 20:37:14.531
These are entities that are 100 percent hosted on chain, so you don't need an off chain.

12494
20:37:14.531 --> 20:37:17.635
So you don't need IPFS, you don't need an off chain database.

12495
20:37:17.635 --> 20:37:26.870
And this one's also going to be dynamic, where it's going to use price feeds in order to fluctuate what the image of the entity actually looks like based off the price of some asset.

12496
20:37:26.870 --> 20:37:29.551
And here are the images that we're going to be using.

12497
20:37:29.551 --> 20:37:32.508
And we obviously have these three adorable doggies here.

12498
20:37:32.508 --> 20:37:35.169
If you want to follow along with the Quickstart, you absolutely can.

12499
20:37:35.169 --> 20:37:41.257
And I'm going to do a quick overview of just running the code to show you what it's going to look like at the end.

12500
20:37:41.257 --> 20:37:50.947
Basically, what we're going to do is we're going to have our code, we're going to run hardhat deploy dash dash network, rink B, dash dash tags main.

12501
20:37:50.947 --> 20:37:54.510
And this is going to deploy all of our contracts and everything.

12502
20:37:54.510 --> 20:37:58.433
And then finally, if we go to test nets dot open c.

12503
20:37:58.433 --> 20:38:07.186
io And we grab the address of one of these NF T's we should be able to put it in here see our actual NFT as a collection with an item.

12504
20:38:07.186 --> 20:38:10.614
Or Additionally, we can just go right to the contract.

12505
20:38:10.742 --> 20:38:25.617
We can read the contract, we can get the token URI, and then we can copy this token here, I paste it into our browser or any IPFS is into our browser, and then grab the image attribute and see what this actually looks like on chain.

12506
20:38:25.617 --> 20:38:34.903
So with all that being said, let's learn how to build this ultimate NFT repo and build all of these different customizable NF T's let's jump in.

12507
20:38:34.903 --> 20:38:40.825
So once again, we're in our terminal I'm going to create a new directory.

12508
20:38:40.825 --> 20:38:44.575
We're gonna call it hard hat and a T for FCC.

12509
20:38:44.742 --> 20:38:45.903
We're gonna cd into that.

12510
20:38:47.742 --> 20:38:49.182
that up with code.

12511
20:38:52.742 --> 20:39:02.897
point, you'll have gotten pretty familiar with the setup of our code bases here, feel free to copy over or do whatever you want to do for our setup, we'll do yarn, add dash dash dev hard hat.

12512
20:39:02.897 --> 20:39:06.592
And then while that's loading, I'm going to copy over my prettier files.

12513
20:39:06.592 --> 20:39:10.742
Because I want to use prettier, I'm going to copy over my hard hat.

12514
20:39:10.742 --> 20:39:11.242
config.

12515
20:39:11.242 --> 20:39:11.408
js.

12516
20:39:11.408 --> 20:39:19.304
And I'm also going to grab my package that Jason copied over here, I'm going to delete this old package dot JSON.

12517
20:39:19.304 --> 20:39:25.096
And I'm just going to hit Enter on this and rename the one I just copied over from package copy to package json.

12518
20:39:25.096 --> 20:39:31.373
And the reason I'm doing this is so that I can just go ahead and run yarn and install all this stuff for me.

12519
20:39:31.373 --> 20:39:40.181
Or we can just come back over here and just grab this lesson nine hard hat, smart contract lottery, all that stuff, again, just run that massive piece as well.

12520
20:39:40.181 --> 20:39:44.361
Or you can copy over your package json, and then just run yarn that will do the same thing.

12521
20:39:44.361 --> 20:39:47.885
Now we don't have to keep doing this boilerplate over and over and over again.

12522
20:39:47.885 --> 20:39:54.043
And then while that's loading, I'm also going to grab my Dotty and v file that we've been using on a past couple of projects, the readme.

12523
20:39:54.043 --> 20:39:54.143
md.

12524
20:39:54.143 --> 20:39:56.593
And we'll just do what we're gonna be doing here.

12525
20:39:56.743 --> 20:39:58.457
So we're going to make three different contracts.

12526
20:39:58.743 --> 20:40:08.132
going to be a basic NFT, using that ERC 721 standard, then we're gonna do a random IPFS hosted NF t.

12527
20:40:08.132 --> 20:40:13.443
And then finally, we're going to do a dynamic S V G NFT.

12528
20:40:13.443 --> 20:40:22.076
So our random NF T is going to be random at creation time, this is going to give some true scarcity and some true randomness to our NF T.

12529
20:40:22.076 --> 20:40:24.692
And it's gonna be hosted on IPFS.

12530
20:40:24.692 --> 20:40:34.143
Our dynamic SVG NFT is going to be hosted 100 percent on chain, and the image of it's going to change based off of some parameters.

12531
20:40:34.143 --> 20:40:39.243
That's what makes it a dynamic SVG NFT.

12532
20:40:39.743 --> 20:40:47.437
Let's go ahead and we'll create a new folder, we'll create our contracts folder, and we will create our first NF t this is going to be our basic NFT.

12533
20:40:47.437 --> 20:40:55.225
And I'm going to go a little bit quick here, because most of what we're going to be doing is actually things that we're already familiar with.

12534
20:40:55.225 --> 20:40:58.143
So we'll do basic NF T dot soul in a new file.

12535
20:40:58.143 --> 20:41:00.780
And let's go ahead and let's do it.

12536
20:41:00.780 --> 20:41:07.795
Let's go ahead and we'll do spdx license identifier, it's gonna be MIT.

12537
20:41:07.795 --> 20:41:12.467
We'll do pragma, solidity, carrot zero, point 8.

12538
20:41:12.467 --> 20:41:17.849
7 pragma, solidity, and then we'll do contract, basic NF t.

12539
20:41:17.849 --> 20:41:20.691
Let me just basic, get a t.

12540
20:41:20.691 --> 20:41:22.010
so, like that.

12541
20:41:22.010 --> 20:41:24.276
And we'll say contract basic NF t.

12542
20:41:24.276 --> 20:41:30.340
And then we'll just run hard at compile or yarn hard, hit compile, and it looks like we're doing well here so far.

12543
20:41:30.340 --> 20:41:31.017
Okay, perfect.

12544
20:41:31.017 --> 20:41:44.494
Based off of that NFT token standard, we go back that EIP, we're going to need a whole bunch of different functions here, we're going to need transfer events, we're going to need owner events bounce up, we're going to all these different functions.

12545
20:41:44.494 --> 20:41:56.881
And we could 100 percent implement these and transfer them exactly like the ERC 20 did, or once again, so we can use, you guessed it, we're gonna be using open Zeppelin contracts for this as well.

12546
20:41:56.881 --> 20:41:59.201
So we come back over to open Zeppelin, we go over to contracts.

12547
20:41:59.201 --> 20:42:03.444
And we're gonna go ahead and add this with yarn, add dash dash Dev.

12548
20:42:03.444 --> 20:42:08.985
So yarn, add dash dash dev at opens up on contracts, like so.

12549
20:42:08.985 --> 20:42:18.355
And while that's going through, we can look at the ERC 721 of this and we can see what creating a minimalist ERC 721 looks like.

12550
20:42:18.355 --> 20:42:21.981
Now there's a number of extensions that come with its ERC.

12551
20:42:21.981 --> 20:42:24.744
721 In this example that they give us.

12552
20:42:24.744 --> 20:42:30.002
They're using ERC 721 Uri storage, which we'll talk about in a little bit.

12553
20:42:30.002 --> 20:42:31.260
So we've added it in here.

12554
20:42:31.260 --> 20:42:35.399
And now we can actually import that ERC 21 from opens up when in our contract.

12555
20:42:35.399 --> 20:42:44.177
So we'll do import at open Zeppelin slash contracts slash token slash your C 721 slash ERC.

12556
20:42:44.177 --> 20:42:49.282
721 does so they use a different one in the demo, but don't worry about that.

12557
20:42:49.282 --> 20:42:50.930
And same as the ERC.

12558
20:42:50.930 --> 20:42:56.151
20 we're gonna say our basic NFT is ERC 721.

12559
20:42:56.151 --> 20:43:04.151
So we're doing this inheritance, you find the constructor, we can see this has a constructor, where it takes a name and a symbol.

12560
20:43:04.151 --> 20:43:08.633
So we're gonna want to use this constructor and our contract.

12561
20:43:08.633 --> 20:43:12.521
So we're gonna say, construct door.

12562
20:43:12.745 --> 20:43:15.795
And our constructor is just going to be blank.

12563
20:43:16.745 --> 20:43:21.306
the ERC 721 constructor and we'll call this a doggie.

12564
20:43:21.745 --> 20:43:24.094
the symbol will be dog just like that.

12565
20:43:25.745 --> 20:43:30.278
going to have it be this doggy here, right so it's going to be an NF T of just a purely this dog here.

12566
20:43:30.278 --> 20:43:33.880
The name is going to be doggy and the symbol is going to be dog.

12567
20:43:33.880 --> 20:43:35.995
Now in order to create new dogs.

12568
20:43:35.995 --> 20:43:55.035
What we're going to do is openzeppelin code comes with something called a mint function exactly the same as the ERC 20 So we're going to create a function called mint NFT this will be a public file function that's going to return you activity six.

12569
20:43:55.035 --> 20:44:08.390
And we'll use the safe mint function of this ERC 20 or underscore safe mint message dot sender will mint the token to whoever calls this mint function.

12570
20:44:08.390 --> 20:44:14.697
And then we need to also give this a token ID, if we're looking back at the code for the ERC 721.

12571
20:44:14.697 --> 20:44:22.911
And again, you can see this on GitHub as well, we're gonna look at this safe mint function, it takes an address to who is going to own the NFT.

12572
20:44:22.911 --> 20:44:28.278
And then a token ID, what is the ID of the token based off of this address.

12573
20:44:28.278 --> 20:44:34.969
So if you have a collection of tokens on the same smart contract, each one of them needs their own unique token ID.

12574
20:44:34.969 --> 20:44:49.677
So what we're gonna do is we're gonna create a un 256, private variable called S underscore token counter, and it's gonna get initialized in our constructor to zero, but we'll just be explicit and say es token counter equals zero.

12575
20:44:49.677 --> 20:44:56.336
And then in here, we'll just have the token ID of this new NF t be that token counter.

12576
20:44:56.336 --> 20:45:01.795
And then of course, we'll say s token counter equals s token counter plus one.

12577
20:45:01.795 --> 20:45:09.665
So every time we meant a new NFT, we up the token counter, and then we'll just return, we'll just return the new tab counter.

12578
20:45:09.665 --> 20:45:09.955
Right.

12579
20:45:09.955 --> 20:45:17.126
And then obviously, at the bottom, we could do like function, get token counter, this would be a public view returns you in 256.

12580
20:45:17.126 --> 20:45:29.296
And I'm gonna go a little quick here, because you've seen this before, return s underscore token counter, right, since it's a private variable up here, the public function down here to get that token counter.

12581
20:45:29.296 --> 20:45:31.693
So this technically, is it.

12582
20:45:31.693 --> 20:45:33.166
This is technically an NF T.

12583
20:45:33.166 --> 20:45:41.090
But what does this look like? Well, right now, this NF T isn't going to look like anything at all, in this EIP token standard.

12584
20:45:41.090 --> 20:45:43.299
It has this thing called a token URI.

12585
20:45:43.299 --> 20:45:48.999
And this is the important function that tells us exactly what this token is going to look like.

12586
20:45:48.999 --> 20:45:51.665
Like what we said in the mini lesson here.

12587
20:45:51.665 --> 20:45:59.817
This token URI returns some type of URL or universal resource identifier that returns some JSON that looks like this.

12588
20:45:59.817 --> 20:46:02.796
And in this JSON, we're going to have this image part.

12589
20:46:02.796 --> 20:46:08.696
And this image is going to be a URL that's going to point to what this image actually looks like.

12590
20:46:08.696 --> 20:46:13.496
Now this URL can be hosted on chain, it can be hosted on IPFS, it can be hosted really wherever.

12591
20:46:13.496 --> 20:46:16.700
But ideally, we're not going to use a centralized server to host it.

12592
20:46:16.747 --> 20:46:22.126
If this is hosted on a Google Cloud or a centralized server or whatever, and our centralized server goes down.

12593
20:46:22.126 --> 20:46:25.254
Well guess what this MC is gonna look like, it's not gonna look like anything.

12594
20:46:25.254 --> 20:46:32.136
So we want to use some type of decentralized storage, to get a URL, or URI to store what this looks like.

12595
20:46:32.136 --> 20:46:38.811
To make this section a little bit easier for you, I've actually already gone ahead and hosted an image to IPFS.

12596
20:46:38.811 --> 20:46:48.271
For you, it's going to be at IPFS dot dot slash slash, it's going to look like this, this is going to be the image that we're going to use for our dog here.

12597
20:46:48.271 --> 20:46:58.074
If you create just this image, though, as the token URI, that's not going to work, we need a URI that returns this, with the image inside of it.

12598
20:46:58.074 --> 20:47:01.347
Now for this first section, have already gone ahead and done that for you as well.

12599
20:47:01.347 --> 20:47:03.320
And that's going to be located here.

12600
20:47:03.320 --> 20:47:06.323
This is what our token URI function needs to return.

12601
20:47:06.323 --> 20:47:14.366
So it's going to have the name, the description, the image URI, which then points to the dog, and then some attributes, etc, etc.

12602
20:47:14.366 --> 20:47:21.008
Now, you'll notice that the image here is pointing to HTTPS, dot dot slash slash ipfs.

12603
20:47:21.008 --> 20:47:21.192
io.

12604
20:47:21.192 --> 20:47:29.522
The reason I did this was again, just in case you didn't have the IPFS gateway, but this would be a lot better if this was in its IPFS form.

12605
20:47:29.522 --> 20:47:32.884
Because if the centralized server ipfs.

12606
20:47:32.884 --> 20:47:38.424
io, goes ever goes down, this NFT will show what it'll show nothing.

12607
20:47:38.424 --> 20:47:41.009
So it would be much better.

12608
20:47:41.009 --> 20:47:43.566
If it was instead of ipfs.

12609
20:47:43.566 --> 20:47:43.762
io.

12610
20:47:43.762 --> 20:47:49.069
It was IPFS, colon slash slash, like that, instead of ipfs.

12611
20:47:49.069 --> 20:47:49.238
io.

12612
20:47:49.238 --> 20:47:51.298
But for now, this is what we're going to be using.

12613
20:47:51.298 --> 20:47:57.248
And you can just go to the GitHub for this, just to grab this for this section.

12614
20:47:57.248 --> 20:48:04.494
Right? Just go to contracts, basic NFT, you can just grab this, this, this top part, just copy it like that.

12615
20:48:04.494 --> 20:48:10.384
So we're going to paste that the token URI up, up, up at the top, like so.

12616
20:48:10.384 --> 20:48:13.384
Oh, it should be returns, return.

12617
20:48:13.384 --> 20:48:14.474
There we go.

12618
20:48:14.748 --> 20:48:15.224
Okay, cool.

12619
20:48:17.748 --> 20:48:18.075
this.

12620
20:48:22.748 --> 20:48:24.655
directly to IPFS, which is good.

12621
20:48:26.748 --> 20:48:29.594
the file is actually pointing to http.

12622
20:48:29.594 --> 20:48:29.901
ipfs.

12623
20:48:29.901 --> 20:48:30.054
io.

12624
20:48:31.748 --> 20:48:33.715
T's don't do that for this NFT.

12625
20:48:35.748 --> 20:48:37.454
but for your NF T's don't do that.

12626
20:48:38.748 --> 20:48:40.748
this a public constant variable.

12627
20:48:42.748 --> 20:48:43.881
you write is never going to change.

12628
20:48:44.748 --> 20:48:50.442
NFT so that everybody who meets one will have this exact same adorable little puck here.

12629
20:48:50.442 --> 20:48:55.814
And the way we do That now is we need to identify the actual token URI function.

12630
20:48:55.814 --> 20:49:02.506
So I'm going to do it above get token counter, we're going to say function, token URI.

12631
20:49:02.506 --> 20:49:16.373
And these always take a UNT 256 token ID, we're going to make this a public view, override returns string memory.

12632
20:49:16.373 --> 20:49:21.248
And this needs to return the token URI.

12633
20:49:21.248 --> 20:49:26.414
Now, this is going to be the most basic way to create this, right.

12634
20:49:26.414 --> 20:49:33.510
And if we wanted to make this function a little nicer, we'd comment out token ID as well, since we're actually not using token ID.

12635
20:49:33.510 --> 20:49:39.415
But we're overriding in our in the ERC 721 that we're importing.

12636
20:49:39.415 --> 20:49:43.291
This has a token ID function or a token URI function.

12637
20:49:43.291 --> 20:49:49.076
And we're overriding this, right, we're not using this at all, we're saying, Hey, we're just going to use our own here.

12638
20:49:49.076 --> 20:49:52.354
And that's all we need for this to work.

12639
20:49:52.354 --> 20:50:03.114
And now if you were to deploy this to rink B, if you were to jump over to open C test net, and you would deploy this, this dog, this adorable little pop would be what shows up for all the minutes.

12640
20:50:03.114 --> 20:50:06.699
So let's go ahead, and let's create a little deploy function for this.

12641
20:50:06.749 --> 20:50:14.601
So we'll do a new folder, deploy a new file, we'll call this a one deploy basic NF T dot j s.

12642
20:50:14.601 --> 20:50:19.191
And this is going to look real similar to everything that we've done before.

12643
20:50:19.191 --> 20:50:22.749
So I'm going to move a little bit quicker here.

12644
20:50:22.749 --> 20:50:36.129
const network equals require hard hats, const development chains, equals require dot dot slash helper, hard hats config.

12645
20:50:36.129 --> 20:50:38.589
And I don't think I added that.

12646
20:50:38.749 --> 20:50:43.369
So I'm going to copy paste my helper Hardhead config from our last project.

12647
20:50:43.369 --> 20:50:59.165
And if you get confused, you can always just come to the GitHub here, and just go to the helper Hardhead config and grab it from here, we have that const development chains, or say const verify equals require dot dot slash utils.

12648
20:50:59.165 --> 20:51:00.248
Slash verify.

12649
20:51:00.248 --> 20:51:17.016
We're also going to grab our utils, I'm going to copy paste so utils folder from alas project, once again, you can copy paste from your last project, or you can just go straight to the repo, grab the verified dot j s, we're going to go over these two functions a little bit later, but at least grab the verified for now.

12650
20:51:17.016 --> 20:51:18.875
And then we're gonna start the function.

12651
20:51:18.875 --> 20:51:22.782
So we'll do module that exports equals async function.

12652
20:51:22.782 --> 20:51:29.491
We're gonna get get named accounts, and deployments.

12653
20:51:29.750 --> 20:51:31.942
And we're gonna say const.

12654
20:51:34.750 --> 20:51:40.282
against deployer equals await, get named accounts.

12655
20:51:41.750 --> 20:51:50.394
a little log here just to get started to do our basic NFT doesn't take any constructor parameters.

12656
20:51:50.394 --> 20:51:55.250
So we'll say const args equals a little blank here.

12657
20:51:55.250 --> 20:52:10.035
Then we'll do const basic NFT equals await, deploy basic NF T, exactly what we've seen before a number of times at this point, we'll say from Deployer.

12658
20:52:10.035 --> 20:52:11.765
args is going to be args.

12659
20:52:11.765 --> 20:52:14.050
And then log, it's going to be true.

12660
20:52:14.050 --> 20:52:16.057
And then we'll also do weight confirmations.

12661
20:52:16.057 --> 20:52:24.400
It's going to be network dot config dot block, confirmations, or one.

12662
20:52:24.400 --> 20:52:56.385
Then if we want to verify this, we're going to once again do if it's not development chains, dot includes network dot name, and process that EMV dot ether scan API key will say log verifying dot the dot await, verify basic NF T dot address arguments which are going to be blank, grab this little log here, stick it right underneath.

12663
20:52:56.385 --> 20:52:58.670
And then actually in our basic NF T.

12664
20:52:58.670 --> 20:53:00.912
This should be args not arguments.

12665
20:53:00.912 --> 20:53:02.718
Now we have a deploy script.

12666
20:53:02.718 --> 20:53:09.636
Now we have a basic NFT here in test data deploy script, or any hh deploy or yarn Hardhead deploy.

12667
20:53:09.636 --> 20:53:19.195
And oops, let's go back to the basic kind of tea or mint and have tea needs to return a UNT 256.

12668
20:53:19.195 --> 20:53:20.073
Try again.

12669
20:53:20.073 --> 20:53:24.651
Get token counter also needs to return a UNT forget you into anywhere else.

12670
20:53:24.651 --> 20:53:24.901
Nope.

12671
20:53:24.901 --> 20:53:25.851
Okay, looking good.

12672
20:53:25.851 --> 20:53:33.595
And looks like we're compiling well compiled, deploying Well, now if you want to deploy this to rink B, you can.

12673
20:53:33.595 --> 20:53:37.412
I recommend holding off though, because we're going to do that at the end.

12674
20:53:37.412 --> 20:53:39.154
Now that we've written a deploy script.

12675
20:53:39.154 --> 20:53:42.751
We've written the contract, you already know what's coming next.

12676
20:53:42.751 --> 20:53:43.396
Yes, neat.

12677
20:53:43.396 --> 20:53:47.944
What's next is the tests now because we're not actually learning too much more here.

12678
20:53:47.944 --> 20:53:50.460
I'm not going to walk you through writing this test.

12679
20:53:50.460 --> 20:53:51.969
I'm going to challenge you now.

12680
20:53:51.969 --> 20:53:58.322
How to pause the video and write the test out yourself and see how far in this test you can actually get.

12681
20:53:58.322 --> 20:54:12.735
Remember, to test it, you're going to want to run yarn, hard hat test, right, let's see if you can actually write the test yourself, then come back to the video, see if your tests were just as good or not as good as what we did here.

12682
20:54:12.735 --> 20:54:16.170
And of course, you can always go to the GitHub repo test sections.

12683
20:54:16.170 --> 20:54:20.172
And if you get lost, you can look at the basic nft.

12684
20:54:20.172 --> 20:54:20.522
test.

12685
20:54:20.522 --> 20:54:22.803
js To follow along.

12686
20:54:22.803 --> 20:54:27.855
All right, welcome back.

12687
20:54:27.855 --> 20:54:40.686
Hopefully, you wrote some awesome tests, taking the time to actually do some of those exercises is really going to make you a much better engineer.

12688
20:54:40.752 --> 20:54:42.571
Following along with me, it's awesome.

12689
20:54:43.752 --> 20:54:47.502
and trying to do everything yourself is really what's gonna make this stick.

12690
20:54:47.502 --> 20:54:49.202
So I hope you did pause the video.

12691
20:54:49.202 --> 20:54:55.693
And hope you did go ahead and try to write the test for this yourself, you've technically just created a really minimalistic NFT.

12692
20:54:55.752 --> 20:54:56.802
Great job.

12693
20:54:56.802 --> 20:55:00.185
Let's kick things up a notch.

12694
20:55:02.752 --> 20:55:09.475
random IPFS hosted NFT where we're going to do everything pretty much programmatically.

12695
20:55:09.475 --> 20:55:10.521
So let's jump in.

12696
20:55:10.521 --> 20:55:16.290
In our contracts, we're going to create a new file random IPFS, NFT, dot soul.

12697
20:55:16.290 --> 20:55:17.407
Same thing.

12698
20:55:17.407 --> 20:55:25.842
spdx license identifier, gonna be MIT pragma, solidity carrot zero, point 8.

12699
20:55:25.842 --> 20:55:34.152
7, or whatever version you want to use, will do contract random IPFS NF? T, like so.

12700
20:55:34.152 --> 20:55:48.872
So what is this one going to do? So instead of just minting any NFT, when we meant an NF t, we will trigger a chainlink VRF call to get us a random number.

12701
20:55:48.872 --> 20:55:54.945
Using that number, we will get get a random NF t that we're going to decide on.

12702
20:55:54.945 --> 20:56:00.863
And the random n of t that we're going to use, it's going to be either a pug a Shiva in you, or a St.

12703
20:56:00.863 --> 20:56:01.603
Bernard.

12704
20:56:01.603 --> 20:56:06.379
So whenever anybody mints NF T, they're gonna get one of these random three dogs.

12705
20:56:06.379 --> 20:56:19.681
And we're going to make this so that each one of these dogs have a different rarity, we're going to make these dogs rare by different amounts, say we want the pug to be super rare, the Shiva to be sort of rare, and then the St.

12706
20:56:19.681 --> 20:56:21.372
Bernard to be pretty common.

12707
20:56:21.372 --> 20:56:25.176
So probably it's gonna be super rare Shiva in us is gonna be sort of rare, St.

12708
20:56:25.176 --> 20:56:30.091
Bernard is going to be pretty common, right? Or the most common, if you will.

12709
20:56:30.091 --> 20:56:49.304
So let's go ahead and start building this, we're probably gonna have to make a function called like request NF t, because we're going to know that we're gonna need to kick off a channeling VRF request, we're probably gonna have to make a function fulfill random words, that's going to take a un 256 Request ID and a un 256.

12710
20:56:49.304 --> 20:56:57.395
Array, memory random words, as we've seen before, we've done fulfill random words in the past.

12711
20:56:57.395 --> 20:57:03.946
And let's let's even go one step further, we'll make it so that users have to pay to mint an NF t.

12712
20:57:03.946 --> 20:57:13.998
So this is going to be they have to pay a certain amount of eath to get the NFT and then the owner of the contract and withdraw the eath.

12713
20:57:13.998 --> 20:57:18.817
So we're basically paying the artists here, we're paying the artists to create these NF T's.

12714
20:57:18.817 --> 20:57:23.212
And then they can be the ones actually actually withdraw the payment for all these NF T's.

12715
20:57:23.212 --> 20:57:29.334
And we're also going to need, of course, a function, token URI, which takes a un 256.

12716
20:57:29.334 --> 20:57:35.068
And this is once again, same as our basic NFT gonna be what this token actually looks like.

12717
20:57:35.068 --> 20:57:36.939
So let's go ahead and get started creating this.

12718
20:57:36.939 --> 20:57:39.437
Now, because these red lines are going to draw me crazy.

12719
20:57:39.437 --> 20:57:51.511
We're going to add some visibility here, we'll make this request NFT public fulfill random words, we actually know from the past is going to be internal token URI is going to be public.

12720
20:57:51.511 --> 20:57:53.685
Let's build this request NFT.

12721
20:57:53.685 --> 20:57:58.141
And again, to request a random number, go back to EVM.

12722
20:57:58.141 --> 20:58:02.304
Chains, we go to using randomness, we can follow along with the Dr.

12723
20:58:02.304 --> 20:58:05.383
chain link again, to figure out how to get this random number.

12724
20:58:05.383 --> 20:58:11.487
So since we know we're going to be working with chain link, we want to add at chain link slash contracts.

12725
20:58:11.487 --> 20:58:22.220
So back in in our code base, we'll add that in yarn add dash dash dev at chain link slash contracts, like so which was perfect.

12726
20:58:22.220 --> 20:58:32.622
And we can go ahead, and we're going to import that VRF consumer base V two and the VRF coordinator interface into our code because we know we're going to use both of these.

12727
20:58:32.622 --> 20:58:37.393
If you want to just copy paste from the docs, you absolutely can go to pause here.

12728
20:58:37.393 --> 20:58:42.325
And since we're going to be using this view of consumer base, we want to inherit it.

12729
20:58:42.325 --> 20:58:52.465
We're going to say random IPFS and f t is V RF consumer base V two and this little, little wiggly line will show up here saying This seems to be override.

12730
20:58:52.465 --> 20:58:54.957
So I'm just gonna go ahead and add override here.

12731
20:58:54.957 --> 20:59:00.550
And this little wiggly line is gonna stay there for a little bit until we implement the rest of the functions.

12732
20:59:00.550 --> 20:59:03.338
So let's go ahead and implement the rest of those functions.

12733
20:59:03.338 --> 20:59:06.420
Request NFT, of course, is going to be public here.

12734
20:59:06.420 --> 20:59:14.683
And in order for us to request an NF T, we're going to need to call the coordinator dot request random words where we pass all this stuff in.

12735
20:59:14.754 --> 20:59:22.539
Right, so let's go ahead and get all this stuff for our V REF coordinator in our constructor, so let's create a new constructor.

12736
20:59:22.539 --> 20:59:23.396
struct door.

12737
20:59:23.396 --> 20:59:36.206
And we're going to use the VRF consumer base, the two constructor to use to create our constructor, the VRF consumer base V two needs an address in here for the VRF consumer base.

12738
20:59:36.206 --> 20:59:38.939
So we'll go ahead and we'll do address VRF.

12739
20:59:38.939 --> 20:59:41.523
Or did Nate Torre b two.

12740
20:59:41.523 --> 20:59:51.513
And then we'll pass this to the VRF consumer base constructor here, just by adding that that red squiggly line has gone away from me perfect.

12741
20:59:51.513 --> 20:59:55.021
And we want to save that address to a global variable.

12742
20:59:55.021 --> 20:59:58.139
So we can call request random words on it.

12743
20:59:58.139 --> 21:00:04.916
So we're gonna go ahead up here, we're going to say I underscore var F chord.

12744
21:00:04.916 --> 21:00:08.817
To me, Tor, we're going to make this immutable VRF coordinator.

12745
21:00:08.817 --> 21:00:28.817
And we're going to do it by saying VRF v2 interface, it's gonna be private, immutable, you have coordinator and then in our constructor here, we're gonna say IVF coordinator equals VRF, coordinator v2 interface wrapped around this like so.

12746
21:00:28.817 --> 21:00:32.355
So we know we're going to need this, we know we're actually gonna need a ton of these.

12747
21:00:32.355 --> 21:01:15.791
So let's just add all these variables in here, we're gonna need the coordinator, we're gonna need a UNT 64 private, immutable, I underscore subscription ID, we're gonna need a bytes 32, private, immutable, I underscore gas lane, we're gonna need a you int 32 private, mutable, I underscore callback gas limit, we're gonna need a UNT 16 Private constants, request confirmations, we're gonna say it's gonna be three, and then a un 32.

12748
21:01:15.791 --> 21:01:27.941
Private constant equals num words, which is going to be one, and we'll get this red squiggly line saying it's mad at our our constructor here.

12749
21:01:27.941 --> 21:01:32.791
So let's go ahead and add all of our immutable variables in our constructor.

12750
21:01:32.791 --> 21:01:48.893
So we'll get the VRF coordinator v2 from our constructor will get the UNT 64 subscription ID, we'll get the bytes 32 Gas lane, aka the key hash, we'll get the un 256.

12751
21:01:48.893 --> 21:02:11.620
We'll do a UNT 32 callback gas limit, then we'll go ahead and do I subscription ID equals subscription ID will do I gas Lane equals gas lane will do I call back gas limit equals call back.

12752
21:02:11.756 --> 21:02:13.556
Yes limit.

12753
21:02:13.756 --> 21:02:14.709
Okay, a lot of variables set up.

12754
21:02:15.756 --> 21:02:17.876
we're going to need for the chainlink VRF.

12755
21:02:18.756 --> 21:02:21.089
these variables down in our request.

12756
21:02:22.756 --> 21:02:31.992
a random number to get for our random n of t, we're going to say and our returns a yuan tivity six Request ID.

12757
21:02:31.992 --> 21:02:41.022
So in here, we'll say request, Id this request ID that we just initialized I underscore VRF.

12758
21:02:41.022 --> 21:02:44.522
Core didn't a Tor dot request.

12759
21:02:44.756 --> 21:02:45.542
random words.

12760
21:02:48.756 --> 21:02:50.526
did in our lottery.

12761
21:02:54.756 --> 21:03:01.724
subscription ID, comma, request, con for nations.

12762
21:03:03.757 --> 21:03:05.163
callback gas limit.

12763
21:03:08.757 --> 21:03:15.069
literally copy paste this from the documentation or from our last project, whatever you want to do.

12764
21:03:15.069 --> 21:03:19.176
So we are requesting this random NFT here.

12765
21:03:19.176 --> 21:03:30.694
Now here's the thing, though, we want whoever called this request function it to be there and have tea, right.

12766
21:03:30.757 --> 21:03:38.690
And if we saw in our basic NFT, when we minted the NFT, we call this safe mint which needed the owner and the token counter.

12767
21:03:38.757 --> 21:03:40.994
When we request a random number four are NFT.

12768
21:03:41.757 --> 21:03:51.101
happen in two transactions, right? We're going to request and then later on we're going to fulfill and it's going to be the chain link node that's calling fulfill random words.

12769
21:03:51.101 --> 21:04:02.231
So if it In the fulfill function, we just do this safe meant message that sender, the owner of this NFT is actually going to be the chain link node that fulfilled our random words.

12770
21:04:02.231 --> 21:04:08.721
So we don't want that, what we want to do is we want to create a mapping between request IDs.

12771
21:04:08.721 --> 21:04:32.002
And whoever called this so that when we call fulfill random words, which returns with that exact same request, ID, we can say, Ah, okay, your request ID X, you belong to the person who called this request and of team, we're going to create a mapping between people who call this and their request IDs so that when we fulfill random words, we can properly assign the dogs to them.

12772
21:04:32.002 --> 21:04:40.145
So up at the top, right underneath here, I'm going to call them VRF helpers, we're going to create a mapping of un 256.

12773
21:04:40.145 --> 21:04:48.987
To an address, we'll make this public which we should make it private, but we'll just make it public s underscore Request ID to sender.

12774
21:04:48.987 --> 21:05:00.958
And then when we call this request, and F T, will set the request ID to sender of Request ID equals to message dot sender.

12775
21:05:00.958 --> 21:05:17.921
Now, when the chain link node responds with fulfill random words, what we can do is we can say address dog owner or the NFT dog owner is going to be equal to s Request ID to sender of Request ID.

12776
21:05:17.921 --> 21:05:26.266
This way, it's not going to be the chain link nodes that are going to own the dog, but it's gonna be whoever actually called requests.

12777
21:05:26.266 --> 21:05:26.593
NFT.

12778
21:05:26.758 --> 21:05:27.234
Okay, cool.

12779
21:05:29.758 --> 21:05:30.631
random NF t.

12780
21:05:34.758 --> 21:05:38.215
random NF T for this for this user.

12781
21:05:40.758 --> 21:05:44.805
using this mapping, what else do we need? Well, we're gonna need the token counter here.

12782
21:05:44.805 --> 21:05:47.699
Let's go ahead and we'll create a token counter variable.

12783
21:05:47.699 --> 21:05:50.535
So we'll scroll up and make a new section.

12784
21:05:50.535 --> 21:05:52.979
And we'll say, un 256.

12785
21:05:52.979 --> 21:06:06.639
And then again, we'll just make a lot of these public just to make it easier, but you might want to make this private and use that same syntax we were doing before do s underscore since this is a stored variable, token counter.

12786
21:06:06.639 --> 21:06:08.944
And we'll grab this token counter.

12787
21:06:08.944 --> 21:06:11.528
And we'll say you went to 56.

12788
21:06:11.528 --> 21:06:21.417
New token ID equals as token counter, now that we have the dog owner, and the token ID, we can go ahead and mint this MFT.

12789
21:06:21.417 --> 21:06:23.563
So we'll do safe mint.

12790
21:06:23.759 --> 21:06:39.177
Owner, new token, ID and then safe man is going to be squiggly because our code is gonna say, what is this? What is the safe mint function? Where did you get this from? Well, we're gonna need to get it from open Zeppelin again.

12791
21:06:39.177 --> 21:06:47.909
So we're going to go ahead and do import at open Zeppelin slash contracts slash token slash ERC.

12792
21:06:47.909 --> 21:06:50.009
721 slash ERC.

12793
21:06:50.009 --> 21:06:51.209
720 one.

12794
21:06:51.209 --> 21:07:05.081
so We'll say a random IPFS empty is Vera of consumer base, and also ERC 721 In our constructor, right after our V RF consumer base, we're going to put the ERC 721.

12795
21:07:05.081 --> 21:07:10.678
And same thing, we need to give it a name and a symbol.

12796
21:07:10.678 --> 21:07:14.742
So we'll call this random IPFS NF T.

12797
21:07:14.742 --> 21:07:18.687
Comma, we'll just do Rin for random IPFS NF team.

12798
21:07:18.687 --> 21:07:22.559
Now safe mint actually works and then it's gonna be mad at me for this.

12799
21:07:22.559 --> 21:07:24.723
So I'm gonna do override just let it stop getting mad at me.

12800
21:07:24.759 --> 21:07:30.249
public view override turns string memory.

12801
21:07:31.759 --> 21:07:32.877
squiggly line goes way.

12802
21:07:32.877 --> 21:07:33.436
Okay, cool.

12803
21:07:33.436 --> 21:07:33.893
So great.

12804
21:07:34.759 --> 21:07:45.092
safe mint to the dog owner this new token ID Are we done with this? Absolutely not.

12805
21:07:45.092 --> 21:07:48.791
Why not? Well, we don't know what this token looks like.

12806
21:07:48.791 --> 21:07:53.548
And what we set above is we want to actually make these dogs different rarities.

12807
21:07:53.548 --> 21:08:05.099
So how do we actually create these dogs with different rarities, all we could do is we create a chance array an array to show the different chances of these different dogs here.

12808
21:08:05.099 --> 21:08:15.776
So down below, we're going to create a function and it's going to be a public pure function called get chance array.

12809
21:08:15.776 --> 21:08:23.612
And this is going to return you went to 46 of size three in memory.

12810
21:08:23.612 --> 21:08:29.707
And this chance array is going to represent the different chances of the different dogs.

12811
21:08:29.760 --> 21:08:38.529
So we're gonna say return 10 3100 Or we're gonna say Max chance value.

12812
21:08:38.760 --> 21:08:41.360
And up at the top under empty variables.

12813
21:08:42.760 --> 21:08:48.366
went to 56 internal constant, Max chance value equals 100.

12814
21:08:48.760 --> 21:08:55.343
by making this array, we're saying index Zero has a 10 percent chance of happening.

12815
21:08:55.343 --> 21:09:03.350
We're saying index one has a 20 percent chance of happening because it's going to be 30 minus 10.

12816
21:09:03.350 --> 21:09:11.410
And then we're saying index two is going to have a 60 percent chance of happening, because it's going to be 10 plus 30.

12817
21:09:11.410 --> 21:09:12.600
minus this 100.

12818
21:09:12.760 --> 21:09:16.072
This array that identified the percentages of the different dogs.

12819
21:09:16.072 --> 21:09:23.705
We're saying the pug is going to have a 10 percent chance, Shiva in you a 20 percent chance and the St.

12820
21:09:23.705 --> 21:09:30.794
Bernard a 70 percent chance, we're going to use it to give this token ID that we just minted its dog breed.

12821
21:09:30.794 --> 21:09:35.723
So we're gonna create a new function called Get breed from modded RNG.

12822
21:09:35.723 --> 21:09:41.507
And the reason we're calling a get breed from modded RNG is exactly the same way.

12823
21:09:41.507 --> 21:09:42.301
In our lottery.

12824
21:09:42.301 --> 21:09:57.094
We got a random number, we're gonna say you went to 56 modded RNG equals random words of zero mod Max chance value, we're going to mod any number we get by 100.

12825
21:09:57.094 --> 21:10:00.894
Doing it like this, we're always going to get a number between zero and 99.

12826
21:10:00.894 --> 21:10:05.099
If random words zero mod Max Chin's value is going to be seven.

12827
21:10:05.099 --> 21:10:07.336
That means we're gonna get a pug.

12828
21:10:07.336 --> 21:10:08.217
If we get 88.

12829
21:10:08.217 --> 21:10:11.450
That means we're gonna get a St.

12830
21:10:11.450 --> 21:10:13.932
Bernard, if we get a 45.

12831
21:10:13.932 --> 21:10:17.711
We're gonna get a what? That's right, a St.

12832
21:10:17.711 --> 21:10:21.914
Bernard, if we got a 12 We're getting a Shiva in you.

12833
21:10:21.914 --> 21:10:28.761
If the mod ID number that we get by modeling this random word is between zero and 10.

12834
21:10:28.761 --> 21:10:32.416
It's going to be pug between 10 and 30.

12835
21:10:32.416 --> 21:10:35.563
shiba inu between 30 and 100 St.

12836
21:10:36.761 --> 21:10:39.367
Bernard and that's how we get these randomness values.

12837
21:10:39.761 --> 21:10:44.729
that we have this modded RNG, we have this mod ID number that's going to be between zero and 99.

12838
21:10:44.729 --> 21:10:49.094
Okay, this function called Get breed from modded RNG.

12839
21:10:49.094 --> 21:10:59.837
And this is going to take the UN 256 mod ID RNG will make this a public pure function, and it's going to return the breed of the dog.

12840
21:10:59.837 --> 21:11:05.416
Now the breed of the dog is going to be an email similar to raffle state that we did before.

12841
21:11:05.416 --> 21:11:12.203
We're going to do this right at the top since this is going to be what a type declaration or say enum.

12842
21:11:12.203 --> 21:11:16.761
Read, we're going to say the zero with number is going to the pug.

12843
21:11:16.761 --> 21:11:20.568
The ones number is going to be the Shiva in you.

12844
21:11:20.568 --> 21:11:23.796
And then the second one is going to be the St.

12845
21:11:23.796 --> 21:11:24.485
Bernard.

12846
21:11:24.485 --> 21:11:27.962
So we have the pug which is zero to 10.

12847
21:11:27.962 --> 21:11:32.262
Shiva in you 10 to 30 St Bernard 30 to 100.

12848
21:11:32.262 --> 21:11:37.358
So get breed from modded RNG public pure returns breed.

12849
21:11:37.358 --> 21:11:46.912
So we're gonna loop through this we're gonna say you intuitive six cumulative sum equals zero, we'll say you went to 56.

12850
21:11:46.912 --> 21:11:55.253
size three memory chance array equals yet chance array.

12851
21:11:55.253 --> 21:11:59.149
So we're getting that chance array.

12852
21:11:59.149 --> 21:12:10.713
So we're going to create a little for loop we're gonna say for you went to 56 i It's gonna start with zero is going to be less than the chance array dot length.

12853
21:12:10.713 --> 21:12:14.574
i plus plus ran through that for loop here.

12854
21:12:14.574 --> 21:12:41.647
And we're going to say if modded RNG is greater than or equal to this cumulative sum and modded RNG is less than the cumulative sum plus chance array plus wherever we are on the chance array, then return breed of AI.

12855
21:12:41.762 --> 21:12:50.580
And then outside of this, we're gonna say cume cumulative sum plus equals chance array of I, let's say moderate orangey equals 25.

12856
21:12:50.580 --> 21:12:56.860
And if it's 25, it should be a Shiva in you, because that's between 10 and 30.

12857
21:12:56.860 --> 21:13:22.874
So we're saying if mod RNG, which is 25 is greater than or equal to cumulative sum, which right now is zero, and it's less than n, the Moto G is less than the cumulative sum plus the chance array of I which is going to be 10 Return breed of I cumulative sum is currently zero plus chance of I which is 10 is going to be 10.

12858
21:13:22.874 --> 21:13:26.496
And this is not true because Morarji is 25.

12859
21:13:26.496 --> 21:13:36.013
So since this is not true, we're going to move to the second step which is just cumulative sum, plus equals chance right? So cumulative sum will now be equal to 10.

12860
21:13:36.013 --> 21:13:38.213
And then we reached the end of the for loop.

12861
21:13:38.213 --> 21:13:48.631
So we'll restart i is now one, so let's try this again mod RNG is greater than or equal to cumulative sum Okay, that is true cumulative sum is 10.

12862
21:13:48.631 --> 21:13:50.237
Mod RNG is 25.

12863
21:13:50.237 --> 21:13:56.969
And mod RNG is less than cumulative sum plus chance re of AI, which is 30.

12864
21:13:56.969 --> 21:14:02.143
So we're saying 25 is less than 10 plus 30, which is 40.

12865
21:14:02.143 --> 21:14:05.096
Return breed of AI, this is true.

12866
21:14:05.096 --> 21:14:09.601
So breed of AI would be true and AI at the moment is one.

12867
21:14:09.601 --> 21:14:12.903
And if we scroll up, that's indeed the Shiva in you.

12868
21:14:12.903 --> 21:14:18.548
So that's how this function is going to work, it's going to get us the breed from that modeling bit.

12869
21:14:18.548 --> 21:14:26.613
And then if for some reason, some really wacky stuff happens here, we want to just go ahead and add a revert, right, because we should be returning a breed.

12870
21:14:26.613 --> 21:14:29.484
But if we don't return a breed, we should just revert.

12871
21:14:29.484 --> 21:14:39.643
So we're going to create a new error at the top, random IPFS NFT underscore underscore range out of bounds.

12872
21:14:39.764 --> 21:14:48.354
The down below, we're just going to say if for some reason you don't return anything, just do a revert random IPFS NFT range out of bounds.

12873
21:14:48.354 --> 21:14:50.321
And now we have this function.

12874
21:14:50.321 --> 21:14:53.264
Okay, so now we can get the brief from a modded RNG.

12875
21:14:53.264 --> 21:14:55.893
So pack in our fulfill random words function.

12876
21:14:55.893 --> 21:15:16.485
Let's go ahead, and we'll say, we'll uncomment this will say breed, dog breed, equals get breed for modded RNG pass the modded RNG here, and let's move this safe mint down below us getting the dog breeder so we can mint and add the dog breed at the same time.

12877
21:15:16.485 --> 21:15:22.564
So we're gonna go ahead and safe mint here.

12878
21:15:23.764 --> 21:15:34.002
Now we can do a few things to set this dog breed here, we create a mapping between the dog breed and the token URI, and then have that reflected in this token URI function.

12879
21:15:34.002 --> 21:15:42.674
Or what we could do is we could just call a function called Set token URI and the openzeppelin ERC 721 You have to set this token your eye function yourself.

12880
21:15:42.674 --> 21:15:47.525
However, there is an extension in the open Zeppelin code called ERC.

12881
21:15:47.525 --> 21:15:51.626
721 Uri storage and this version of the ERC.

12882
21:15:51.626 --> 21:15:57.979
721 comes with a function called Set token URI where we can just call set token URI.

12883
21:15:57.979 --> 21:16:03.982
And this will automatically update that tokens token URI to whatever you set it as.

12884
21:16:03.982 --> 21:16:09.684
So we're going to use this extension this set token URI in our contract.

12885
21:16:09.764 --> 21:16:25.385
And the way that we do this is instead of doing token ERC 721 Year C 721 that soul will do token ERC 721 slash extensions slash your C 721 Your arise storage.

12886
21:16:25.385 --> 21:16:26.522
That's all.

12887
21:16:26.522 --> 21:16:33.265
And we'll say random IPFS is ERC 721 your rice storage.

12888
21:16:33.265 --> 21:16:40.092
Now what's cool is that our constructor will still just use ERC.

12889
21:16:40.092 --> 21:16:45.641
721 Because ERC 721 Uri storage is extending ERC 721.

12890
21:16:45.641 --> 21:16:52.493
And then this contract just comes with some additional functions like set token URI.

12891
21:16:52.493 --> 21:16:59.542
So right after safe meant, we're actually going to call set token URI with this new item ID.

12892
21:16:59.542 --> 21:17:12.420
And then we're going to give it that breeds token URI, we're gonna give it a string here that relates to whatever breed that we just got based off the dog breed here.

12893
21:17:12.420 --> 21:17:30.490
Now, to do this, what we could do is right at the top and our NFT variables, we could create a string array, internal, Alt S dog token, your eyes, we're gonna make this constant where it would just be this array of all these strings that we created.

12894
21:17:30.490 --> 21:17:34.288
But maybe in our code, we want to make this a little bit more variable.

12895
21:17:34.288 --> 21:17:36.383
And we want to parameterize this.

12896
21:17:36.383 --> 21:17:37.939
And that's exactly what we're going to do.

12897
21:17:37.939 --> 21:17:58.249
So we're going to create this string array, internal s underscore dog token, your eyes, which is just going to be a list of these URLs are these URLs that point to stuff like this, we're going to do that in our code so that when we upload any image that we want to IPFS we can then upload this s dog token you arise accordingly.

12898
21:17:58.249 --> 21:18:15.143
In our constructor, we're actually going to take in another parameter called a a string of size three, memory dog token you our eyes, we're going to pass as a constructor parameter, these different dog token you arise.

12899
21:18:15.143 --> 21:18:19.352
So we're going to pass it this list of dog token arise.

12900
21:18:19.352 --> 21:18:22.749
Of course zero is going to be the token URI of the pug.

12901
21:18:22.749 --> 21:18:25.946
One is going to be the Shiva in you and two, of course is going to be the St.

12902
21:18:25.946 --> 21:18:26.208
Bernard.

12903
21:18:26.208 --> 21:18:37.119
So we're going to pass it this list of dog token your eyes, and then down in set token your eye from that, that list that we created.

12904
21:18:37.119 --> 21:18:52.314
We're going to set the token URI of this token based off of that array of the UN 256 version of that breed are casting this dog breed back into you and 256 to get its index.

12905
21:18:52.314 --> 21:19:02.536
With that we now have a way to actually, programmatically get a provably random NFT with different randomness for different one of these NF T's.

12906
21:19:02.536 --> 21:19:14.007
Now, let's go back up to our little, our little comments we made here, limited NFT, we trigger a chain link or a VRF.

12907
21:19:14.007 --> 21:19:17.750
To call random number, we got the rarities down, we got the minting down.

12908
21:19:17.750 --> 21:19:18.242
Awesome.

12909
21:19:18.242 --> 21:19:20.580
Okay, we don't have this part, though.

12910
21:19:20.766 --> 21:19:25.454
Users have to pay to Minton NF T and the owner of the contract can withdraw the eath.

12911
21:19:25.454 --> 21:19:28.952
Okay, this is stuff we've already done before, this should be pretty familiar here.

12912
21:19:28.952 --> 21:19:32.516
So back in our request NF t function, we'll make this a public payable.

12913
21:19:32.516 --> 21:19:48.648
And all we'll need to do is we'll just say if message dot value is less than some mint fee, and actually let's go back to our constructor, we'll create a mint fee, you int 256 Mint fee.

12914
21:19:48.767 --> 21:19:55.155
And then we'll do you in 256 internal I underscore mint fee, we'll make this immutable.

12915
21:19:55.155 --> 21:19:58.885
And then we'll just say I'm intervene equals mint fee.

12916
21:19:58.885 --> 21:20:22.619
If message of value is less than mint fee, you already know we're going to do a revert, need more eath sent, we'll create a new air called need more eath sent and actually we'll do air random IPFS and ft underscore underscore need more II sent like that, copy this, paste it here and boom.

12917
21:20:22.619 --> 21:20:26.889
So now just by adding this line, this is now a payable function.

12918
21:20:26.889 --> 21:20:32.444
And people have to pay some mint fee to mint their randomized NF t.

12919
21:20:32.444 --> 21:20:36.100
Now we're also going to want a way for owner to withdraw.

12920
21:20:36.100 --> 21:20:38.258
So we'll scroll down a little bit.

12921
21:20:38.258 --> 21:20:44.077
We'll scroll down to here, CREATE FUNCTION withdraw, this will be public.

12922
21:20:44.077 --> 21:20:46.042
And we only want the owner to do this.

12923
21:20:46.042 --> 21:20:53.403
So we could create our modifier, you know, a modifier again only owner, or what we could do is use openzeppelin.

12924
21:20:53.403 --> 21:21:07.947
Again, openzeppelin also comes with some access code, or one of them's this ownable code, and in here, it already has the only owner modifier for us, we're just gonna go ahead and import that as well.

12925
21:21:07.947 --> 21:21:18.905
We'll do import at openzeppelin slash contracts slash access slash ownable dot som, and we'll say contract random IPFS.

12926
21:21:18.905 --> 21:21:22.629
And if t is this, this come ownable.

12927
21:21:22.629 --> 21:21:26.315
And then we'll make our withdrawal function only owner.

12928
21:21:26.315 --> 21:21:31.241
And so whoever deployed this contract is going to be set to being the owner, which is what we want.

12929
21:21:31.241 --> 21:21:36.155
And when here, same as what we've done, we'll do u and 256.

12930
21:21:36.155 --> 21:21:40.686
amount equals address this dot balance.

12931
21:21:40.686 --> 21:21:55.452
And then we'll do bull success comma equals payable, message dot sender, but call value is going to be a mount and then we're going to call nothing.

12932
21:21:55.452 --> 21:21:59.208
And then we're going to say if not success.

12933
21:21:59.208 --> 21:22:09.383
And we're going to revert with transfer failed, then on top, we're going to do error transfer failed.

12934
21:22:09.383 --> 21:22:17.664
I'm just going to copy this a little quicker, like so and then come back down to transfer failed paste it here.

12935
21:22:17.664 --> 21:22:19.948
So we're gonna revert random IPFS.

12936
21:22:19.948 --> 21:22:26.393
And if T transfer failed, perfect, so now we have a withdrawal function and a way for people to pay for art here.

12937
21:22:26.393 --> 21:22:40.678
Now we don't need this token URI anymore, because when we call set token URI, this is going to set the token URI for us because in the back ERC 721 Uri storage already has that function laid out.

12938
21:22:40.678 --> 21:22:46.218
So our contract will already have the token URI function and we don't have to explicitly set it ourselves.

12939
21:22:46.218 --> 21:22:48.668
But we do have to explicitly set some other ones.

12940
21:22:48.768 --> 21:23:19.311
We are going to need function get meant fee will be a public view turns you went to 36 turn I meant fee will need function get dog token your eyes, you went to 36 index, this will be a public view which will returns the string memory return s underscore dog token your eyes index will need function get token counter.

12941
21:23:19.311 --> 21:23:27.824
This will be a public view turns you into 56 Return s underscore token counter.

12942
21:23:27.824 --> 21:23:30.894
Alright, so we just wrote a ton of code here.

12943
21:23:30.894 --> 21:23:35.118
And of course as we taught you before, we also are going to need some events.

12944
21:23:35.118 --> 21:23:40.107
So when we request an NF T, we're going to emit an event.

12945
21:23:40.107 --> 21:23:45.644
So we'll omit NF T requested and then we'll pass it the request.

12946
21:23:45.644 --> 21:23:47.456
ID in the message dot sender.

12947
21:23:47.456 --> 21:23:54.010
So up at the top will say event NF T requested.

12948
21:23:54.010 --> 21:24:01.785
So pet, take a un 256 index Request ID, and then an address requester.

12949
21:24:01.785 --> 21:24:07.126
And then we're also going to make an event for NF T minted for when it's finally minted.

12950
21:24:07.126 --> 21:24:13.096
And it's going to take a breed, dog breed, and an address, mentor.

12951
21:24:13.096 --> 21:24:19.644
So write down when we fulfill, we're going to emit NFT.

12952
21:24:19.644 --> 21:24:20.519
minted.

12953
21:24:20.769 --> 21:24:29.621
And it's going to take that dog breed and then the dog owner.

12954
21:24:29.769 --> 21:24:33.236
Okay, we've just written a lot of code here.

12955
21:24:34.769 --> 21:24:38.680
and see if we can compile this with H H compile, or yarn Hardhead, compile.

12956
21:24:38.680 --> 21:24:41.479
And Wow, looks like we went ahead and compiled it.

12957
21:24:41.479 --> 21:24:42.382
This is great.

12958
21:24:42.382 --> 21:24:44.575
So all of our code now looks good.

12959
21:24:44.770 --> 21:24:47.837
Now might be a good time to take a quick breather, we've just written a lot of code.

12960
21:24:47.837 --> 21:24:51.822
And it might be good to just go over all the stuff that we just went through.

12961
21:24:51.822 --> 21:25:04.820
A lot of this is familiar, but it's still really good to redo some of this stuff and really get that muscle memory and for these credit, an NFT contract that when you mint, one of these NF T's, you're gonna get a pug a Shiva in you or St.

12962
21:25:04.820 --> 21:25:08.820
Bernard, based off of some rarity, where the pug is really rare.

12963
21:25:08.820 --> 21:25:11.166
Ship it in you is sort of rare in the St.

12964
21:25:11.166 --> 21:25:12.753
Bernard is pretty common.

12965
21:25:12.753 --> 21:25:22.689
The way we do it is we have this request NF t function, which people have to pay to call and it makes a request to a chain link node to get a random number.

12966
21:25:22.689 --> 21:25:32.254
Once our contract gets that random number uses a chance array to figure out which one of the NF T's we're going to actually use for this for that minting.

12967
21:25:32.254 --> 21:25:34.735
And we're going to set the token URI accordingly.

12968
21:25:34.735 --> 21:25:40.693
And we're going to store the image data for this on IPFS, which we haven't done yet.

12969
21:25:40.770 --> 21:25:45.603
So our deploy function for this is going to be really the interesting part of this contract.

12970
21:25:45.603 --> 21:25:53.399
But because we just went over so much, if you want to take a quick break quick breather, and then come back, I encourage you to do so we just learned a lot.

12971
21:25:53.399 --> 21:25:55.140
And we wrote a lot of solidity code.

12972
21:25:55.140 --> 21:25:58.597
So go take a quick breather, and I'll see you in a minute.

12973
21:25:58.597 --> 21:26:11.208
So let's go ahead and get on in here, create a new deploy, go to ploy, random ipfs.

12974
21:26:11.208 --> 21:26:11.558
js.

12975
21:26:11.558 --> 21:26:19.512
And now this is going to look really similar once again, to the lottery contract that we've already done.

12976
21:26:19.512 --> 21:26:28.347
And we can copy some boilerplate from our code over here, we're gonna need all this, we'll just copy that, close it off with a little curly and boom, we've already got a boilerplate.

12977
21:26:28.347 --> 21:26:32.032
Now, since we're working with chainlink, here, we are going to be working with mocks again.

12978
21:26:32.032 --> 21:26:37.705
So we're gonna come back new file 00, deploy mocks dot j s.

12979
21:26:37.705 --> 21:26:43.908
And if you want, you can just copy paste from the earlier section that we did with the with the raffle slash lottery.

12980
21:26:43.908 --> 21:26:51.192
Since we're going to be doing the exact same thing here, I'm gonna go ahead and pause and you can copy paste from your previous projects.

12981
21:26:51.192 --> 21:26:57.371
Or if you want, once again, you can just come to the GitHub repo associated with this course, come over to the deploy.

12982
21:26:57.371 --> 21:27:00.121
And go ahead and grab the deploy mocks right from here.

12983
21:27:00.121 --> 21:27:08.658
If you grab from the GitHub repo, we also are going to be working with a mock v3 aggregator, but I'm not going to add that part in quite yet, because we don't need it quite yet.

12984
21:27:08.658 --> 21:27:10.721
So go ahead and pause the video right now.

12985
21:27:10.721 --> 21:27:16.703
Copy and paste the VRF coordinator mock or pause the video and try to write the mock code yourself.

12986
21:27:16.771 --> 21:27:17.278
Okay, great.

12987
21:27:19.771 --> 21:27:26.187
to concentrate ID network dot config dot chain ID, because we're gonna need to decide if we're actually on a development chain.

12988
21:27:26.187 --> 21:27:48.548
So same as what we did before then we're gonna say if development chains that includes network dot name, then we're gonna say const VRF coordinator, B to mock goes await ethers dot get contract VRF.

12989
21:27:48.548 --> 21:27:49.103
Core.

12990
21:27:49.103 --> 21:28:03.533
The name for the to mock similar to the raffle we're gonna say let VRF coordinate Tor v two address, same, the VRF coordinator v two address equals VRF.

12991
21:28:03.533 --> 21:28:12.535
coordinator v two mach mock that address and then we're going to want to create a subscription exactly the same as what we did with our lottery.

12992
21:28:12.535 --> 21:28:22.755
So we're gonna say const, TX equals weight VRF coordinate tore V to mock dot create subscription.

12993
21:28:22.755 --> 21:28:30.216
And then we'll do const TX receipt equals weight, TX dot weight one.

12994
21:28:30.216 --> 21:28:35.411
And we're gonna get the sub ID from this exactly the same way we did it in the lottery section.

12995
21:28:35.411 --> 21:28:49.272
So we'll say that we need that sub ID by saying sub subscription ID will say subscription ID equals TX receipt, dot events, zero.

12996
21:28:49.272 --> 21:28:52.147
That args got somebody.

12997
21:28:52.147 --> 21:29:15.837
So that's what we do if we're on a development chain, else said the VRF coordinate tore V to address equals network config of the chain ID dot VRF coordinate or B to that then the subscription ID equals network config.

12998
21:29:15.837 --> 21:29:18.689
Chain ID dot subscription ID.

12999
21:29:18.689 --> 21:29:19.475
Perfect.

13000
21:29:19.772 --> 21:29:23.518
And then we'll just double check our helper hard hat config.

13001
21:29:23.772 --> 21:29:27.392
that Rigby has both the VRF coordinator v2.

13002
21:29:28.772 --> 21:29:30.403
going to need a subscription ID.

13003
21:29:31.772 --> 21:29:35.209
subscription ID from our past project from our lottery project.

13004
21:29:35.209 --> 21:29:42.706
But we can go ahead to V or F dot chain link, we can go to V RF, that chain link can make sure we're on rink B here.

13005
21:29:42.773 --> 21:29:44.042
Let's see our other subscriptions.

13006
21:29:44.773 --> 21:29:46.042
we have one here.

13007
21:29:49.773 --> 21:29:50.106
Rigby.

13008
21:29:53.773 --> 21:30:01.789
chains, contract addresses for using reminisce to see more parameters in here, especially for Rigby and make sure these are all correct.

13009
21:30:01.789 --> 21:30:09.773
We have our subscription here, we'll add a new consumer very soon once we deploy this contract if we're actually going to use RankBrain.

13010
21:30:09.773 --> 21:30:14.740
So we'll do a little log here with a bunch of hyphens.

13011
21:30:14.740 --> 21:30:20.616
We'll now get args equals, we'll make our arguments here.

13012
21:30:20.616 --> 21:30:30.027
And what do we need, we need the coordinator subscription, gasoline callback, address, dog, your dog token, your eyes and admin fee.

13013
21:30:30.027 --> 21:30:37.966
So we're going to need VRF coordinator for the to address subscription ID.

13014
21:30:37.966 --> 21:30:41.805
And we'll need the network config.

13015
21:30:41.805 --> 21:30:44.288
Chain ID dot gas lane.

13016
21:30:44.288 --> 21:31:01.423
We need the network config chain ID dot meant fee, then we'll leave that work config chain ID dot callback gas limit the right order? Yes it is.

13017
21:31:01.423 --> 21:31:12.553
And then we need the dog token your eyes and the mint fee with the done here.

13018
21:31:12.773 --> 21:31:17.215
Now what do we not have, we don't have this array of token your eyes.

13019
21:31:17.215 --> 21:31:19.330
Now we can do this one of a couple of ways.

13020
21:31:19.330 --> 21:31:33.515
If you go to the GitHub repo associated with this, go to deploy, we actually did the randomness for oh three in the get here, there's one section where we just automatically say, okay, great token, you rise is just going to be these three.

13021
21:31:33.515 --> 21:31:42.015
And then if we can actually even copy paste these CDs on IPFS, these are the better ones that actually do have the IPFS as the image.

13022
21:31:42.015 --> 21:31:43.466
And we can see them like that.

13023
21:31:43.466 --> 21:31:45.937
So we could just use the stuff that I've already deployed.

13024
21:31:45.937 --> 21:31:56.248
And if you want to do that, you absolutely 100 percent Can, or what we could do is we get to actually learn to upload programmatically our own images to IPFS.

13025
21:31:56.248 --> 21:31:57.942
That sounds a lot cooler.

13026
21:31:57.942 --> 21:31:59.974
So let's go ahead and do that.

13027
21:31:59.974 --> 21:32:03.940
Now what I want you to do, if you want to use your own images for this, feel free to do so.

13028
21:32:03.940 --> 21:32:09.601
But if you want to just follow along with us, then we're going to go to the Hardhead NFT FCC repo.

13029
21:32:09.601 --> 21:32:14.921
And we're going to grab these random NF T's from him.

13030
21:32:14.921 --> 21:32:16.986
So all you can do is you can come to here.

13031
21:32:16.986 --> 21:32:24.329
And we can go ahead, we can right click Save Image, Jas, we'll save it to our downloads, let's actually create a new folder, we'll call it images.

13032
21:32:24.329 --> 21:32:34.621
And the images will create a new folder called random, then we can pull it just right into here, make the name random NFT.

13033
21:32:34.621 --> 21:32:38.349
And this is just going to be plugged up png.

13034
21:32:38.349 --> 21:32:41.174
So we can do that for all of our images.

13035
21:32:41.174 --> 21:32:45.574
Now in our images tag, we have the pug ship in you and St Bernard.

13036
21:32:45.574 --> 21:32:47.218
So we have these locally.

13037
21:32:47.218 --> 21:32:49.503
But we want to upload these to IPFS.

13038
21:32:49.503 --> 21:32:53.070
We want to upload them in a way that anybody can actually pin them and work with them.

13039
21:32:53.070 --> 21:33:02.619
So before we do all this stuff, where we get the arguments to deploy this contract, we're going to need to get the IPFS hashes of our images.

13040
21:33:02.619 --> 21:33:06.332
And there's a couple of ways we can do this.

13041
21:33:06.332 --> 21:33:14.282
We do with our own IPFS node, which I've already shown you how to do that manually, we can also do that programmatically.

13042
21:33:14.282 --> 21:33:16.041
Now, I'm not going to show you how to do this here.

13043
21:33:16.041 --> 21:33:24.068
However, if you go through the IPFS documentation, you actually can learn how to do through the command line and even through some scripts.

13044
21:33:24.068 --> 21:33:27.375
However, if we're the only node that's running this, again, it's kind of centralized.

13045
21:33:27.375 --> 21:33:36.694
So ideally, we'd want these images and these token your eyes and this and this token metadata on our own IPFS node and some other nodes.

13046
21:33:36.775 --> 21:33:44.842
So the second way that we can look at this is using something like Hinata Hinata is a service that basically you just pay to help pin NF T for you.

13047
21:33:44.842 --> 21:33:48.397
And this is going to be the one that we're going to be looking at here.

13048
21:33:48.397 --> 21:33:58.775
Now the issue with binotto of course, is that we're just paying once single centralized entity to go ahead and pin our data, we're kind of trusting that they're actually going to pin it and that they're not going to go down.

13049
21:33:58.775 --> 21:34:04.724
The final way that we could look into actually getting our data is was this thing called NF T dot storage.

13050
21:34:04.775 --> 21:34:15.709
And if T dot storage uses the file coin network on the back end to pin our data now filecoin is a blockchain dedicated to pinning IPFS data and storing decentralized data.

13051
21:34:15.709 --> 21:34:18.742
For us, the process is a little bit more complicated.

13052
21:34:18.742 --> 21:34:21.152
But NFT dot storage makes it really, really easy.

13053
21:34:21.152 --> 21:34:25.108
Now, we're not going to go over using NFT dot storage in this video.

13054
21:34:25.108 --> 21:34:37.759
However, if you want to look into NF T dot storage, for putting your data in the GitHub repo associated with this course, we do have a script that uploads your code to NFT to storage called in the utils folder, upload to NFT.

13055
21:34:37.759 --> 21:34:38.134
Storage.

13056
21:34:38.134 --> 21:34:45.877
And if you want to go and try it out, I recommend that you do so working with NF T dot storage will be one of the most persistent ways to keep our data up.

13057
21:34:45.877 --> 21:34:54.398
But it's still good to upload your own data to your own IPFS node, which we've learned how to do manually and at least get one other person also pinning your data.

13058
21:34:54.398 --> 21:35:01.309
And then ideally, an entire decentralized network, pinning your data, which is what NFS storage helps you do.

13059
21:35:01.309 --> 21:35:06.088
But for now, for us, we're just going to work with pinata to keep it nice and simple for this video.

13060
21:35:06.088 --> 21:35:14.534
And then uploading uploading our metadata and our token, your eyes up to IPFS will give us this list of token your eyes for our three dogs.

13061
21:35:14.534 --> 21:35:27.338
So up at the top here, we're going to do a little if we're gonna say if process dot e NV dot upload to pinata equals true, yes, we're going to use the string true like that.

13062
21:35:27.338 --> 21:35:29.650
Then we're going to upload to pinata.

13063
21:35:29.776 --> 21:35:33.066
Above here we're going to say let's token your eyes.

13064
21:35:33.776 --> 21:35:38.242
gonna say token your eyes equals await, handle token your eyes.

13065
21:35:38.242 --> 21:35:49.407
And we're going to create a function called handle token your eyes, which is going to upload our code to pinata down outside of this, we're going to create a new function called async.

13066
21:35:49.407 --> 21:35:50.354
function.

13067
21:35:50.354 --> 21:35:53.061
And we'll token your eyes.

13068
21:35:53.061 --> 21:36:08.582
And this is going to return an array of token your eyes for us to upload to our smart contract, we're gonna say token, your eyes equals this and then way at the bottom, we're gonna say return token your rise, right, so we're going to be returning this array here.

13069
21:36:08.582 --> 21:36:14.204
Now we need to do two things, we need to both store the image in IPFS.

13070
21:36:14.204 --> 21:36:18.087
And then we need to store the metadata in IPFS.

13071
21:36:18.087 --> 21:36:22.294
So first, we're going to create a store images function.

13072
21:36:22.294 --> 21:36:24.577
And this is where we're going to actually get to go to our utils.

13073
21:36:24.577 --> 21:36:37.099
And we're going to create a new folder in here, we're going to create a file called New File, Upload to pinata dot j s, we're going to add all of our code for actually uploading to pinata in here.

13074
21:36:37.099 --> 21:36:46.015
Because again, pinata is this service that we're going to be using to just pin data for us and work with pinata, we can go ahead, try for free.

13075
21:36:46.015 --> 21:36:56.406
And we can create our own application.

13076
21:36:56.777 --> 21:36:58.088
And we're good to go.

13077
21:37:00.777 --> 21:37:03.495
to an IPFS node, because that's essentially what pinata is.

13078
21:37:03.777 --> 21:37:06.562
just an IPFS node, run by somebody else.

13079
21:37:07.777 --> 21:37:10.443
Hey, can you please pin this data for us.

13080
21:37:11.777 --> 21:37:24.234
could do this is we could just hit Upload Cid just like an IPFS node and put the hash of some IPFS file, and pinata would pin it for us, we could also upload a file or a folder just like an IPFS node.

13081
21:37:24.234 --> 21:37:30.838
But for us, we're just going to leave this blank because we're going to want to do this programmatically, because we're engineers.

13082
21:37:30.838 --> 21:37:36.156
So what we can do is we come over to our profile, we'll open up API keys and documentation.

13083
21:37:36.156 --> 21:37:40.341
And the documentation pretty much has everything that we need to get started.

13084
21:37:40.341 --> 21:37:52.134
If you scroll down to the pinata Node js SDK, this is basically what we're going to be working with, they've already created an SDK for us that we can work with, we're gonna go ahead and install this pinata SDK.

13085
21:37:52.134 --> 21:38:13.199
So they're using NPM, install dash to save, we're just gonna go ahead and use yarn, add dash dash dev at pinata dash SDK, and they have all these different endpoints, we can call to actually pin data, we're going to be doing pin file to IPFS, because we're going to upload our files and also pin JSON to IPFS.

13086
21:38:13.199 --> 21:38:18.019
Since JSON is going to be the metadata, and file is going to be the actual image.

13087
21:38:18.019 --> 21:38:21.896
And if you click on it, it'll even give you kind of the output of the SDK here.

13088
21:38:21.896 --> 21:38:26.578
So back in our code, now that we've downloaded this, we can go ahead and start creating this.

13089
21:38:26.578 --> 21:38:40.444
So we'll say const pinata SDK equals require at pinata slash SDK, and then we'll create a function async function called store images, it'll take an images file path.

13090
21:38:40.444 --> 21:38:50.611
So we're going to use this function will pass it our images, random n of t file paths, and we're going to have it store everything in that folder to help us work with paths.

13091
21:38:50.611 --> 21:38:53.896
We're also going to Install this path package.

13092
21:38:53.896 --> 21:39:00.970
So we're gonna do yarn, add dash dash dev path, like, so, we're just going to work with Fs as well not Fs extra.

13093
21:39:00.970 --> 21:39:04.187
So now that that's up, we're gonna say const.

13094
21:39:04.187 --> 21:39:06.236
Path equals require path.

13095
21:39:06.236 --> 21:39:17.105
And in here, we're gonna say const, full images, path, equals path dot resolve, images file path.

13096
21:39:17.105 --> 21:39:26.988
So if we give that like dot slash images, slash random, you know, NF T or whatever, this will just give us give you the full output of the path.

13097
21:39:26.988 --> 21:39:34.049
So we're getting the full images path, and then we'll say, we'll get those files by doing const files equals Fs.

13098
21:39:34.049 --> 21:39:44.261
So we'll do we'll grab s will say const Fs equals require Fs just to read these files in here, that read DirSync.

13099
21:39:44.261 --> 21:39:52.965
We're just going to read the entire directory and get our files back to read DirSync full images path.

13100
21:39:52.965 --> 21:40:03.680
And to actually test that this is working, what we're going to do is we're going to do module dot exports, equals store images.

13101
21:40:03.779 --> 21:40:10.985
And then back in our deploy script here, we can just go ahead and comment out args.

13102
21:40:10.985 --> 21:40:22.677
And we can do import const, store images equals require dot dot slash utils, slash upload to pinata.

13103
21:40:22.779 --> 21:40:44.240
And in this script, we could just do a little, we just call this we could say await, or images, and then we'll pass pass our images location, maybe way at the top, even outside of the function, we'll say const images location equals dot slash images slash random and ft.

13104
21:40:44.240 --> 21:40:47.624
So we'll do a weight store images like that.

13105
21:40:47.779 --> 21:40:50.712
And we should be able to run Hardhead deploy.

13106
21:40:51.779 --> 21:41:01.379
some tags to this deploy thing, module, dot exports, dot tags equals, we'll say all random IPFS.

13107
21:41:01.379 --> 21:41:15.843
And then main, we do Hardhead deployed dash dash tags, random IPFS will also do mocks believe, and I need to create a test folder in here New Folder test.

13108
21:41:15.843 --> 21:41:20.980
And we need to add that VF coordinator v2 Mock in here.

13109
21:41:20.980 --> 21:41:26.075
So again, I'm just copy pasting the VRF coordinator v2 Mock from our raffle project.

13110
21:41:26.075 --> 21:41:31.576
Feel free to pause, copy, paste it over, or again, everything's available on the GitHub.

13111
21:41:31.576 --> 21:41:33.240
So we'll try one more time.

13112
21:41:33.240 --> 21:41:40.698
Tags, random IPFS, and mocks and boom, okay, mocks deployed and perfect pug dot png ship any png St.

13113
21:41:40.780 --> 21:41:41.565
Bernard PNG.

13114
21:41:41.565 --> 21:41:41.993
Great.

13115
21:41:44.780 --> 21:41:45.113
here.

13116
21:41:49.780 --> 21:41:50.430
pinata server.

13117
21:41:50.430 --> 21:41:52.180
So we'll say responses equals this.

13118
21:41:52.780 --> 21:42:18.435
say for each file index in files for each one of these files in here, we're gonna say const readable stream for file equals Fs dot create read stream of the full images path slash files of file index.

13119
21:42:18.435 --> 21:42:22.551
What does this line doing? Well, we're creating a read stream.

13120
21:42:22.551 --> 21:42:32.380
Since this is an image file, it doesn't work exactly the same as just like push this data, right? We have to create a stream where we stream all the data inside of these images.

13121
21:42:32.380 --> 21:42:47.541
Because these images, even though they're just like a cute little image here, they're really this kind of this big file with all this bytes and all this data in here, and then we're going to send it by doing try, we'll say const response equals await.

13122
21:42:47.541 --> 21:42:50.652
And this is where we're going to do pinata stuff.

13123
21:42:50.780 --> 21:42:55.360
If we go back to the pinata docks, there's some stuff about keys in here.

13124
21:42:55.360 --> 21:43:06.329
What we can do, if you go to your profile, go to API keys, we can create a new key, we'll say this is an admin key, why not? We'll give it all the pinning access here.

13125
21:43:06.329 --> 21:43:09.340
Maybe we'll give it this, maybe we'll just give it everything, whatever you want to do.

13126
21:43:09.340 --> 21:43:14.638
And then we'll call this hard hat, Free Code Camp key, create key.

13127
21:43:14.638 --> 21:43:20.076
Now we're going to want to grab these and drop these into a dot env.

13128
21:43:20.076 --> 21:43:24.158
So the API key, go ahead and copy, come back over here.

13129
21:43:24.158 --> 21:43:25.797
Open up our dot env.

13130
21:43:25.797 --> 21:43:29.628
And we're gonna call it our pinata.

13131
21:43:29.628 --> 21:43:33.543
And data API key equals that key.

13132
21:43:33.781 --> 21:43:40.495
We're going to grab the API secret and say pinata API secret equals that key.

13133
21:43:40.495 --> 21:43:43.329
We don't need this massive token here for what we're going to do.

13134
21:43:43.329 --> 21:43:44.881
But if you want it, you can absolutely have it.

13135
21:43:44.881 --> 21:44:00.727
And then outside of our store images, we're going to say const pinata API key equals price says, do you need that pinata API key? And then can't pinata.

13136
21:44:00.727 --> 21:44:07.813
API secret equals process dot E and V dot pinata API secret.

13137
21:44:07.813 --> 21:44:10.892
And then we'll say const.

13138
21:44:10.892 --> 21:44:16.447
pinata equals pin auta s.

13139
21:44:16.447 --> 21:44:22.053
DK of pinata API key comma, pinata API.

13140
21:44:22.053 --> 21:44:32.138
Secret in order to work with pinata, we need to pass it an API key and API secret so that pinata knows it's us who's working with them.

13141
21:44:32.138 --> 21:44:52.351
So once we initialize this pinata thing, we can now run pinata dot and then do some pinata stuff, right, we want to work with this pin file to IPFS, which takes this readable stream, which is why we created that readable string, so pinata that pin file to IPFS.

13142
21:44:52.351 --> 21:44:55.161
Of readable stream or file.

13143
21:44:55.161 --> 21:45:01.126
And then we're going to push this response on to our responses array.

13144
21:45:01.126 --> 21:45:03.915
So we'll say responses dot push response.

13145
21:45:03.915 --> 21:45:08.489
And then we're going to catch error, just in case there's some weird error here.

13146
21:45:08.489 --> 21:45:15.104
And we'll just say console dot log error, and then we're going to return responses and files.

13147
21:45:15.104 --> 21:45:21.848
So we're going to return all the responses from pushing all these files up, and then the files as well.

13148
21:45:21.848 --> 21:45:26.264
Now, at this current point, we can go ahead and actually test this out ourselves.

13149
21:45:26.264 --> 21:45:27.549
So we have this in here.

13150
21:45:27.549 --> 21:45:37.985
If we go back to our deploy, at the top, we have this if process dot E and V dot upload to Niada equals true, do this stuff here, uploading to IPFS.

13151
21:45:37.985 --> 21:45:49.988
And the final thing we need to do in here, of course, is going to be require dot env dot config, so that we can pull in our dot env file.

13152
21:45:49.988 --> 21:45:53.273
Down here, we're just doing a weight store images.

13153
21:45:53.273 --> 21:45:58.273
So if we run this as is, it should go ahead and store images.

13154
21:45:58.273 --> 21:46:05.232
So let's run that same command, or that deploy random IPFS and the MOX to run this store images command.

13155
21:46:05.232 --> 21:46:11.945
And if we come back to our pinata, after we run it, we'll be able to see the code uploaded here.

13156
21:46:11.945 --> 21:46:21.058
If we run now, the script loaded IPFS it'll give us a little bit of a delay, because it needs to upload these big picture files to IPFS.

13157
21:46:21.058 --> 21:46:22.610
or more correctly.

13158
21:46:22.783 --> 21:46:25.878
pinata, I'm gonna say uploading to nada.

13159
21:46:27.783 --> 21:46:34.340
console dot log, working on file index, done Excel.

13160
21:46:35.783 --> 21:46:36.021
great.

13161
21:46:36.021 --> 21:46:37.640
It looks like it finished running.

13162
21:46:38.783 --> 21:46:47.356
our project here, and we do a little refresh, we see our three files have been uploaded, and we see they each come with their own CID.

13163
21:46:47.356 --> 21:46:51.618
Now, if you want, you can go ahead and copy the CID.

13164
21:46:51.783 --> 21:46:58.928
And if you have your IPFS node, what you can do, what we can do is actually we can hit import from IPFS.

13165
21:46:58.928 --> 21:47:00.298
Paste it in here.

13166
21:47:00.298 --> 21:47:06.572
And we can say exactly what this is, which is IPFS dot dot slash last as the St.

13167
21:47:06.572 --> 21:47:08.150
Bernard called St.

13168
21:47:08.150 --> 21:47:08.851
Bernard.

13169
21:47:08.851 --> 21:47:09.728
Important.

13170
21:47:09.728 --> 21:47:12.989
And now we'll have it pinned on our IPFS.

13171
21:47:12.989 --> 21:47:15.765
I've got mine saved in a little puppies file.

13172
21:47:15.765 --> 21:47:21.110
Now that we've got them uploaded, and pinata do actually recommend you pin your own on your own node as well.

13173
21:47:21.110 --> 21:47:21.765
So cool.

13174
21:47:21.765 --> 21:47:26.090
So we've got a way to get those images up onto IPFS.

13175
21:47:26.090 --> 21:47:27.325
Awesome onto.

13176
21:47:27.325 --> 21:47:36.970
Now that we've done that, we're also going to need to store the token URI metadata.

13177
21:47:36.970 --> 21:47:40.583
So let's go ahead and we'll delete that for now.

13178
21:47:40.583 --> 21:47:51.408
What we can do back in here, is back up at the top again, we can say const meta data, template equals and we'll create a metadata template.

13179
21:47:51.408 --> 21:47:56.957
This is going to have all the basics of what we need for our metadata for our token URI.

13180
21:47:56.957 --> 21:48:11.258
So in here, we'll have a name, set, it's blank, we'll have a description, which will also set as blank will have the image which this is going to be replaced with the image URI that IPFS URI we just created.

13181
21:48:11.258 --> 21:48:21.461
And if you want to give your NFT like any types of stats, you can do some you can create this Attributes section like so.

13182
21:48:21.461 --> 21:48:27.274
And if you give it like traits type, cuteness, comma, value 100.

13183
21:48:27.274 --> 21:48:39.594
And this is how if you wanted to create like different cards or have different attack, defense, HP speed in different different stats for your NF T's, you would add them in this Attributes section.

13184
21:48:39.594 --> 21:48:46.732
Typically, you'd want these attributes also stored on chain so your contracts can obviously programmatically interact with these attributes.

13185
21:48:46.784 --> 21:48:49.084
But so now we have this metadata data template.

13186
21:48:49.784 --> 21:48:52.184
we're going to fill out for each one of our dogs.

13187
21:48:52.784 --> 21:48:59.646
going to create a new function in here called async, store token URI metadata.

13188
21:48:59.646 --> 21:49:04.672
And we'll pass in the meta data to the async function.

13189
21:49:04.672 --> 21:49:08.736
And we'll pass in the metadata that we get from our script over here.

13190
21:49:08.736 --> 21:49:10.497
So we have this little template here.

13191
21:49:10.497 --> 21:49:16.187
And we're going to populate this template based off of what we get from storing data in IPFS.

13192
21:49:16.187 --> 21:49:19.671
So now we're going to write the rest of this handle token your eyes bit.

13193
21:49:19.671 --> 21:49:29.521
And so we're going to want to do in our data and V, we're going to say, upload to pinata equals true, so that we can do everything and handle token your eyes.

13194
21:49:29.521 --> 21:49:33.214
So upload to pinata, it's true, we'll scroll down, we'll start creating this.

13195
21:49:33.214 --> 21:49:47.585
So the first thing we got to do, obviously, we're gonna want to get those responses and those files, right, because it's in the responses, pin file to IPFS is going to return the hash of the file, right, and we need that hash, to add to our metadata.

13196
21:49:47.585 --> 21:50:04.385
So we're going to do is down here, we're gonna say const, responses, which is going to be image upload, responses, comma files, equals await, store images, and then images, location.

13197
21:50:04.385 --> 21:50:11.375
And so this response is, is going to be a list of these responses from pinata.

13198
21:50:11.375 --> 21:50:15.768
And these responses are going to have the hash of each one of these uploaded files.

13199
21:50:15.768 --> 21:50:19.835
So now we're going to loop through that list and upload each of the metadata does.

13200
21:50:19.835 --> 21:50:31.585
So we're going to say for each image upload response index, in image upload responses.

13201
21:50:31.785 --> 21:50:38.531
For each one of these, we're going to create the metadata, we're going to create metadata and then upload the metadata.

13202
21:50:38.531 --> 21:50:47.260
So we're gonna say let token URI, metadata equals dot dot, dot meta data template.

13203
21:50:47.260 --> 21:50:53.385
So this is some fun JavaScript, syntactic sugar, which kind of means like, unpack.

13204
21:50:53.385 --> 21:50:57.735
So basically, we're saying token URI metadata is going to be equal to this stuff.

13205
21:50:57.785 --> 21:51:05.118
We're sticking all this stuff into this token, your metadata variable, now we're gonna say token, your metadata.

13206
21:51:05.118 --> 21:51:15.626
dot name is going to be equal to files of, of the index, dot replace, dot png, dot png with nothing.

13207
21:51:15.626 --> 21:51:26.428
So files is going to be each one of those files, right? It's going to be dot png can be St Bernard dot PNG, and it's going to be Shiva dot png.

13208
21:51:26.428 --> 21:51:31.933
And basically, all we're doing is we're saying, okay, cool, the name inside of our token, metadata is just going to be pug.

13209
21:51:31.933 --> 21:51:34.539
So we're just going to drop the extension, basically.

13210
21:51:34.539 --> 21:51:46.182
So that's how we're gonna get the name token, your AI metadata dot description, is going to be equal to and adore a bowl.

13211
21:51:46.182 --> 21:51:50.992
And then we're just going to get the name, token URI metadata dot name.

13212
21:51:50.992 --> 21:51:53.926
So it's going to be an adorable pug pup and adorable St.

13213
21:51:53.926 --> 21:52:09.595
Bernard pop or an adorable ship and you pup token URI metadata dot image, which is probably the most important one here, this is going to be, it's going to be that IPFS extension with the IPFS hash that we get from the response.

13214
21:52:09.595 --> 21:52:22.478
So we can get that by doing image, upload responses of the image upload response index dot i IPFS.

13215
21:52:22.478 --> 21:52:26.570
Hash, so we can go to the pinata docs.

13216
21:52:26.786 --> 21:52:36.389
And we can see pin file to IPFS returns in IPFS hash, the pin size and the timestamp, all we care about is the IPFS hash.

13217
21:52:36.389 --> 21:52:41.395
And we're going to use that to give the our metadata image here.

13218
21:52:41.395 --> 21:52:45.458
And then finally, I'll do a little console dot log uploading.

13219
21:52:45.458 --> 21:52:52.674
And then we'll say, token, your eye metadata dot name, dot dot dot.

13220
21:52:52.786 --> 21:52:59.919
And now we'll have to store the file or store store the JSON to pinata slash IPFS.

13221
21:52:59.919 --> 21:53:05.176
And this is where in our upload to pinata bit here, we're going to add this function here.

13222
21:53:05.176 --> 21:53:06.987
So we have store token URI metadata.

13223
21:53:06.987 --> 21:53:19.007
And all we're gonna do in here, so we're gonna say try const response equals await, and nada, that pin JSON to IPFS of the metadata, right.

13224
21:53:19.007 --> 21:53:26.238
And again, we have, we want pin JSON to IPFS, which is going to be really similar.

13225
21:53:26.238 --> 21:53:29.913
So we need to pass the body, which is going to be the JSON.

13226
21:53:29.913 --> 21:53:36.377
And we have some optional stuff here, but it's gonna give us the same return the IPFS hash pin, size and timestamp.

13227
21:53:36.377 --> 21:53:40.303
And then if this works, well, we're just going to do return response.

13228
21:53:40.303 --> 21:53:42.367
Otherwise, we'll do catch error.

13229
21:53:42.367 --> 21:53:52.916
And then we'll just do console dot log error, and then we'll just do return null and then we'll exports or token URI metadata.

13230
21:53:52.916 --> 21:53:59.537
And then back in our deploy, we'll go ahead and import this store token URI metadata.

13231
21:53:59.537 --> 21:54:01.599
And we'll scroll down.

13232
21:54:01.599 --> 21:54:13.749
And they'll do const, metadata, upload response equals await, store token URI metadata where we pass the token, Uri, metadata.

13233
21:54:13.749 --> 21:54:22.251
And now finally, and now with all of these metadata is being uploaded are finally going to have the token you arise that we need.

13234
21:54:22.251 --> 21:54:33.240
So we'll say, token, your eyes dot push, IPFS, slash slash, and then the metadata response here, metadata upload response dot IPFS.

13235
21:54:33.240 --> 21:54:33.630
Hash.

13236
21:54:33.787 --> 21:54:41.388
So we finally will have this array of IPFS hashes that points to the metadata, and each one of these metadata are pointing to the image.

13237
21:54:41.388 --> 21:54:44.654
And then we'll do a little console dot log token.

13238
21:54:44.788 --> 21:54:53.649
You arise, uploaded, they are and then we'll do another little console dot log token your eyes.

13239
21:54:53.649 --> 21:54:54.941
Oh, all right.

13240
21:54:54.941 --> 21:54:57.615
So let's go ahead and run this.

13241
21:54:57.615 --> 21:54:59.408
And let's see if it works.

13242
21:54:59.408 --> 21:55:04.507
In our pinata, we should see both the images and then also the metadata.

13243
21:55:04.507 --> 21:55:09.755
If process dot E and V dot upload to pinata equals true, looks like it is true.

13244
21:55:09.755 --> 21:55:19.076
And we should run this and handle token, your eyes will both upload our images with store images here and then upload our metadata.

13245
21:55:19.076 --> 21:55:30.480
We'll only see it in here once because again, it's gonna have the exact same Cid right, it's gonna have the same hash, so we won't get duplicates of the same file in pinata, or in our IPFS.

13246
21:55:30.480 --> 21:55:32.172
So let's open this up.

13247
21:55:32.172 --> 21:55:38.055
Let's run this one more time, or had deployed dash dash tags, random IPFS and mocks.

13248
21:55:38.055 --> 21:55:47.343
Okay, it looks like we almost worked uploading to banana working on zero working on one working on two metadata template is not defined.

13249
21:55:47.343 --> 21:55:55.703
Ha, because I spelt meta data template, meta data template, let's spell things correctly.

13250
21:55:55.788 --> 21:56:01.645
Now let's try this again, it working on zero is it working on two image upload response is not defined.

13251
21:56:01.645 --> 21:56:03.550
I should spell correctly.

13252
21:56:03.550 --> 21:56:04.566
There we go.

13253
21:56:04.566 --> 21:56:07.532
Let's, let's do our caps correctly.

13254
21:56:07.788 --> 21:56:09.862
Let's try this one more time.

13255
21:56:11.788 --> 21:56:13.538
uploading Shiva in you uploading St.

13256
21:56:14.788 --> 21:56:16.493
upload it and they're here.

13257
21:56:18.789 --> 21:56:23.047
into our browser, or your IPFS node, boom, we have them in here.

13258
21:56:23.047 --> 21:56:33.250
And what we can do is we can grab this hash, we can jump into our IPFS desktop, go to files, we import from IPFS paste it in here.

13259
21:56:33.250 --> 21:56:37.574
And you know give it the name etc, that we have it on our own IPFS node as well.

13260
21:56:37.574 --> 21:56:38.145
Awesome.

13261
21:56:38.145 --> 21:56:44.931
Now if we go over to pinata give this a little refresh, we can see we have everything in here.

13262
21:56:44.931 --> 21:56:51.723
So if I copy one of these, and I go to IPFS dot dot slash paste that in, we can see the metadata in here.

13263
21:56:51.789 --> 21:56:53.428
And everything looks good.

13264
21:56:55.789 --> 21:57:11.539
we've just done this because now we can store data both on our own IPFS node and at least one other nodes so that if our computer goes down or our server goes down, and there's at least somebody else who's done it.

13265
21:57:11.789 --> 21:57:17.149
Now we finally have this list of token your eyes, we can finally go back to our arguments.

13266
21:57:17.149 --> 21:57:19.903
And now we can do like this.

13267
21:57:19.903 --> 21:57:23.740
And we can upload all of those token your eyes to our smart contract.

13268
21:57:23.789 --> 21:57:26.455
And then we're going to need a mint fee as well for this.

13269
21:57:26.789 --> 21:57:38.289
we go to our upper heart at config will create like a little mint fee in here, say mint fee is going to be whatever we want 12345678123456789 What we'll do is 0.

13270
21:57:38.289 --> 21:57:39.164
01 eath.

13271
21:57:39.164 --> 21:57:45.122
So we'll even drop this down one, we'll do it for we'll do it for the Hard Hat Network.

13272
21:57:45.122 --> 21:57:47.312
And then we'll also do it for Rinckey as well.

13273
21:57:47.312 --> 21:57:48.950
We have the arguments here.

13274
21:57:48.950 --> 21:57:51.466
Now we can finally deploy our contract.

13275
21:57:51.466 --> 21:57:54.346
So we'll do const random IPFS.

13276
21:57:54.346 --> 21:58:03.451
And if t equals await, deploy, if the contract is random IPFS NF T from Deployer.

13277
21:58:03.451 --> 21:58:05.051
args is args.

13278
21:58:05.051 --> 21:58:06.613
Log is true.

13279
21:58:06.613 --> 21:58:24.886
And then wait confirmations is going to be network dot config dot block for confirm terminations, or one, and great they might do another little line here.

13280
21:58:24.886 --> 21:58:26.551
We'll do the verification bit.

13281
21:58:26.551 --> 21:58:29.273
I'm actually just going to copy that from our deploy.

13282
21:58:29.273 --> 21:58:43.671
Our basic I'm just going to copy this it's going to be code is going to be exactly the same, except for we're going to verify random IPFS instead of and then actually we use args instead of arguments, then that is it.

13283
21:58:43.671 --> 21:58:49.123
So we'll give this a quick deploy test, HH deploy or yarn Hardhead deploy.

13284
21:58:49.123 --> 21:58:52.740
And it looks like we almost worked we almost got Everything's done.

13285
21:58:52.790 --> 21:58:56.531
Network config is not defined, because we didn't import it.

13286
21:58:56.790 --> 21:59:00.341
let's go ahead and import network config from our helper Hardhead.

13287
21:59:00.341 --> 21:59:00.823
Config.

13288
21:59:00.823 --> 21:59:02.547
So import network config.

13289
21:59:02.547 --> 21:59:11.123
We'll try this one more time chain ID is not defined, it's going to be chain ID, that chain Id try one more time.

13290
21:59:11.123 --> 21:59:14.990
And awesome, it's at least working for our heart Hat Network.

13291
21:59:14.990 --> 21:59:18.066
And then we can copy this array, and just paste it in here.

13292
21:59:18.066 --> 21:59:18.373
Boom.

13293
21:59:18.373 --> 21:59:20.713
And now we have this token your eyes.

13294
21:59:20.713 --> 21:59:22.436
And now back in our dot env.

13295
21:59:22.436 --> 21:59:24.332
Now we can set this to false.

13296
21:59:24.332 --> 21:59:32.445
Since we have all those token neurons already, we just run hard hit Deploy, we'll just use the token heroes that we already have uploaded.

13297
21:59:32.445 --> 21:59:33.893
Yes, we have done it.

13298
21:59:33.893 --> 21:59:40.290
Now I know you're excited to see this on something like open See, you're excited to see this right away.

13299
21:59:40.290 --> 21:59:46.097
But let's save deploying all these to rink B for our last thing, because again, deploying to test nets is really slow.

13300
21:59:46.097 --> 21:59:51.483
So let's just wait until our last bit and then we'll go ahead, and we'll deploy this to rank B.

13301
21:59:51.483 --> 21:59:57.153
But before we write tests, something that I noticed when I was writing my test is that we forgot to update the token counter.

13302
21:59:57.153 --> 22:00:04.291
So in here, before we do, our safe, men will do s token counter plus equals s token counter, which is going to be esto.

13303
22:00:04.291 --> 22:00:07.362
Encounter equals es token counter plus one.

13304
22:00:07.362 --> 22:00:10.742
And that's a perfect example of why writing tests is so important.

13305
22:00:10.791 --> 22:00:16.052
Before you write any tests, you're definitely going to need to fund that subscription, which we didn't do in here.

13306
22:00:16.052 --> 22:00:26.877
So we need to do a wait VRF coordinate Tor V to mock dot fund, sub scription.

13307
22:00:26.877 --> 22:00:36.141
subscription ID, comma will do fund amount, and then just up at the top, actually, we can even pull this out too.

13308
22:00:36.141 --> 22:00:37.991
Since that's not gonna change at all.

13309
22:00:37.991 --> 22:00:44.924
We can do let token year I was like that looks like const fund amount equals cool.

13310
22:00:44.924 --> 22:00:47.902
Or you could do you know, you could also do ethers dot parse.

13311
22:00:47.902 --> 22:01:05.791
But as you know, before we can even deploy to rink beam, what should we do? Well, you got it right, we should absolutely 100 percent write some tests.

13312
22:01:05.791 --> 22:01:11.348
So we're create a new file called random IPFS NF t dot test dot j s.

13313
22:01:11.348 --> 22:01:14.593
And we can write some tests here.

13314
22:01:14.791 --> 22:01:22.592
Now, once again, there isn't anything new that you're going to learn in this test here, it's going to be very similar to the lottery tests that we've written before.

13315
22:01:22.592 --> 22:01:32.921
So here's what I'm going to say, I'm going to highly recommend once again, that you try to write at least two or three of your own tests, but definitely write a test fulfill random words.

13316
22:01:32.921 --> 22:01:40.945
But I'm going to encourage you to pause the video now, please pause the video and try to write some tests yourself struggling with some of these tests.

13317
22:01:40.945 --> 22:01:49.569
And writing some of these tests is going to be what really gives you those coding muscles, if you will, that's going to give you the skills to keep writing these tests and be really fast and really efficient.

13318
22:01:49.569 --> 22:01:51.824
When you're building these smart contracts.

13319
22:01:51.824 --> 22:01:56.014
These tests are the tests that protect you from writing bad immutable code.

13320
22:01:56.014 --> 22:01:59.234
So please pause the video, I'm going to copy paste from the GitHub repo.

13321
22:01:59.234 --> 22:02:08.600
But please take this time to write some of your own tests here.

13322
22:02:08.792 --> 22:02:09.695
Alright, great.

13323
22:02:09.695 --> 22:02:12.211
Did you write some tests? Hope you did.

13324
22:02:12.792 --> 22:02:15.022
didn't write some tests, pause this video and go write some tests.

13325
22:02:15.022 --> 22:02:37.622
I promise you doing these tests, writing exercises on your own will help you dramatically at this point, what have we done, we've done some some amazing stuff, we've deployed a basic NFT with pretty much nothing to it, then we've deployed a provably random NFT with random stats with random traits with different rarities, for each NF T's depending on when it was minted, or who minted it.

13326
22:02:37.622 --> 22:02:39.876
We've stored the data for this on IPFS.

13327
22:02:39.876 --> 22:02:47.073
And we've learned how to programmatically upload our files to pinata, which is another pinning service for us.

13328
22:02:47.073 --> 22:02:52.252
We learned a little bit about NFT debt storage, which is another way to pin data to IPFS.

13329
22:02:52.252 --> 22:02:59.809
And then of course, we learned that if we wanted to, we could programmatically pin data to IPFS on our own node.

13330
22:02:59.809 --> 22:03:03.268
But since a lot of us aren't gonna be running our own computers 24/7.

13331
22:03:03.268 --> 22:03:07.293
We went ahead and said, Okay, well, we'll stick with pinata for our default here.

13332
22:03:07.293 --> 22:03:13.694
Now that we've done all that, boom, got another little checkmark here.

13333
22:03:13.793 --> 22:03:22.465
Now I got something to say we don't need to host our data on IPFS can actually host our data, our metadata directly on chain if we want to.

13334
22:03:22.465 --> 22:03:27.529
However, there are some pros and cons to IT pros of hosting on IPFS, or that's going to be cheap.

13335
22:03:27.529 --> 22:03:44.543
And the cons are that someone needs to pin our data, right? There's at least one person always needs to have her data pinned, right? It's decentralized, but you at least need somebody to pin your data, right? And using something like file coin is a way to incentivize people to pin that data.

13336
22:03:44.543 --> 22:03:51.938
But if you're not using File coin, it's not necessarily guaranteed the pros of doing our SVG on chain NFT the data A is on chain.

13337
22:03:51.938 --> 22:03:56.093
And you never have to worry about somebody actually pinning the data.

13338
22:03:56.093 --> 22:04:00.348
The cons are that this is much more expensive.

13339
22:04:00.348 --> 22:04:07.285
These little images, right here are actually surprisingly large and storing them on chain can actually get pretty expensive.

13340
22:04:07.285 --> 22:04:12.507
So we're going to use some different images, so much smaller images, much cheaper images to work with here.

13341
22:04:12.507 --> 22:04:27.480
And if you want to see another version of this, I have another video, how to make NFT art with on chain metadata, it goes through pretty much what we're about to go through here as well if you want a second reference, and there's a link to this in the GitHub repo associated with this course.

13342
22:04:27.480 --> 22:04:37.371
So instead of these PNGs that we're using, we're going to use something called SVG s.

13343
22:04:37.371 --> 22:04:41.437
Now, an SVG stands for Scalable Vector Graphics.

13344
22:04:41.437 --> 22:04:47.810
And these are much much more minimalistic files that we can go ahead and upload to to the blockchain.

13345
22:04:47.810 --> 22:04:52.370
So that's why we're going to use them because since there's so much more minimalistic, they're a lot cheaper to upload.

13346
22:04:52.370 --> 22:04:56.380
Because remember, the more data that you upload to the blockchain, the more expensive it is.

13347
22:04:56.380 --> 22:04:59.714
Now in this video, I make randomize SVG data on chain.

13348
22:04:59.714 --> 22:05:01.919
And here's kind of an example of what one looks like.

13349
22:05:01.919 --> 22:05:03.682
It's just a whole bunch of random lines.

13350
22:05:03.682 --> 22:05:07.132
Not super thrilling, but random and kind of cool.

13351
22:05:07.132 --> 22:05:08.148
And it's 100 percent.

13352
22:05:08.148 --> 22:05:10.758
On chain, these SVG is actually work right in HTML.

13353
22:05:10.758 --> 22:05:20.217
So if you want to use these for your websites, you can as well now there's a link to this tutorial in the GitHub repo associated with this course, where we can go ahead and try it yourself.

13354
22:05:20.217 --> 22:05:27.455
And we can actually play with making an SVG, right, so they have all these different commands in this web through schools.

13355
22:05:27.455 --> 22:05:42.138
com/graphics/svg intro dot ASP, you can see some of the different commands, right, you can make a rectangle you can make a circle path is a big one where you can say exactly what the path or the line you want to draw is going to look like.

13356
22:05:42.138 --> 22:05:44.955
There's a whole bunch of stuff you can make in this SVG.

13357
22:05:44.955 --> 22:05:56.465
And the cool thing is, no matter how big you make an SVG, the quality is always going to be exactly the same, because SVG just explains exactly how to draw it no matter how big or how little, the image is going to be.

13358
22:05:56.465 --> 22:06:02.336
So if you want to learn more about SVG is you want to play with SVG is you know, you can come in here and try it yourself.

13359
22:06:02.336 --> 22:06:04.760
So with that being said, that's what we're going to store on chain.

13360
22:06:04.794 --> 22:06:07.743
So that's how we're going to store this SVG stuff on chain.

13361
22:06:07.794 --> 22:06:14.919
But we're gonna go one step further, we're gonna make this dynamic, we're gonna make this actually change based off of some data on chain.

13362
22:06:14.919 --> 22:06:25.122
If you go to the GitHub repo associated with this lesson, and you go to the images, and you go to dynamic NFT, you'll see two images, see happy dot SVG, which looks like this.

13363
22:06:25.122 --> 22:06:29.384
And you'll see frown dot SVG, which looks like this.

13364
22:06:29.384 --> 22:06:39.152
So we're going to make this NFT dynamic in the sense that we're going to say, if the price of eath is above some number, then we're going to have it be a happy face.

13365
22:06:39.152 --> 22:06:43.604
And then if it's below that, we're going to make it a frowny face.

13366
22:06:43.604 --> 22:06:47.545
So our NFT is going to change based off of some real world parameters.

13367
22:06:47.545 --> 22:07:01.595
And this is obviously really powerful and really cool, because we can have an NFT that changes based off stats, we can have an NF t that changes based off of really whatever, and we're going to store all the data 100 percent on chain, it's going to be a little bit more expensive.

13368
22:07:01.595 --> 22:07:08.564
So that's what we're going to be building here.

13369
22:07:08.795 --> 22:07:10.553
Let's go ahead, let's jump into it.

13370
22:07:11.795 --> 22:07:13.777
contract for our ultimate NFT section.

13371
22:07:14.795 --> 22:07:22.128
create a new contract in here, new contract, and this is going to be our dynamic, SVG and F T dot soul.

13372
22:07:22.128 --> 22:07:27.144
And it's going to look real similar to what we've been doing.

13373
22:07:27.144 --> 22:07:28.413
slash slash dynamic.

13374
22:07:28.413 --> 22:07:38.742
SVG and ft dot saw, slash lat spdx, license identifier, and my team pragma.

13375
22:07:38.742 --> 22:07:43.320
solidity, Eric zero, point 8.

13376
22:07:43.320 --> 22:07:43.477
7.

13377
22:07:43.477 --> 22:07:47.638
Contract, dynamic SVG, NF t.

13378
22:07:47.638 --> 22:07:53.695
Now let's talk about what the architecture of this is going to look like.

13379
22:07:53.695 --> 22:07:56.937
It's gonna look like pretty normal NF T, with a couple of caveats.

13380
22:07:56.937 --> 22:08:04.436
We're gonna give it a min function to mint, these NF T's are also going to store our SVG information somewhere.

13381
22:08:04.436 --> 22:08:13.490
And then we're going to need to have some logic to say show x image or show y image, right.

13382
22:08:13.490 --> 22:08:19.151
And as we know, that's really just going to be switching the token URI to say show X or show y.

13383
22:08:19.151 --> 22:08:22.054
So let's go into how we'd actually do this.

13384
22:08:22.054 --> 22:08:24.957
So first, we know this is going to be in ERC.

13385
22:08:24.957 --> 22:08:25.215
721.

13386
22:08:25.215 --> 22:08:27.445
So we can go ahead and import that from open Zeppelin.

13387
22:08:27.445 --> 22:08:35.517
So we're going to say import at open Zeppelin slash contracts, slash token slash ERC.

13388
22:08:35.517 --> 22:08:37.123
721 slash ERC.

13389
22:08:37.123 --> 22:08:38.844
721 That's all.

13390
22:08:38.844 --> 22:08:47.524
Now we're not going to call that set token URI function that we call before so we can just use the raw ERC 721 instead of an extension.

13391
22:08:47.524 --> 22:08:53.577
So we'll say our contract is ERC 721 and Now that we're making it an ERC 721.

13392
22:08:53.577 --> 22:08:59.446
We can say construct dorm like this, then we'll call the constructor of the ERC.

13393
22:08:59.446 --> 22:09:14.161
721, which we're going to call this dynamic SVG, and f t DSN, dynamic SVG and s, t and f t, like so then we're also going to need a mint function.

13394
22:09:14.161 --> 22:09:19.374
So let's just create that right now say function, mint and f t or request NFT.

13395
22:09:19.374 --> 22:09:24.934
And we'll be a little bit looser here, we'll say the user doesn't need to pay any money for this.

13396
22:09:24.934 --> 22:09:26.629
So this will just be a public function.

13397
22:09:26.629 --> 22:09:28.240
And we're just going to mint them and NFT.

13398
22:09:28.240 --> 22:09:32.462
Same thing, we're just going to call Safe mint message dot sender.

13399
22:09:32.462 --> 22:09:35.462
And of course, we need that token count term.

13400
22:09:35.462 --> 22:09:45.003
So let's go ahead and in our top will do you in 256, private s underscore token counter, we'll do token counter here.

13401
22:09:45.003 --> 22:09:50.135
And then after we meant we'll do tag counter plus, there's gonna be equals token counter plus one.

13402
22:09:50.135 --> 22:09:55.745
And then that's pretty much it, we have a way to meant we've done some of the basics here.

13403
22:09:55.797 --> 22:10:00.130
We'll even we'll be explicit will say s token counter equals zero to initialize it.

13404
22:10:00.130 --> 22:10:04.504
But now what is this token going to look like? We want these to look like SVGs.

13405
22:10:04.504 --> 22:10:12.693
And we want it to be based off the price of some asset in our constructor, all right, create a string memory.

13406
22:10:12.693 --> 22:10:19.051
We'll call it low SVG and a string memory, high SVG.

13407
22:10:19.051 --> 22:10:28.597
And in our code will save this low SVG in this highest V G.

13408
22:10:28.597 --> 22:10:35.181
So these will be the images, these will be like the frowny face and the smiley face that will just import as input parameters here.

13409
22:10:35.181 --> 22:10:39.659
So as we know, we can make these immutable since these are probably not going to change.

13410
22:10:39.659 --> 22:10:46.712
We can say String, private, I underscore low image URI.

13411
22:10:46.712 --> 22:10:51.441
And in string private, I underscore high image URI.

13412
22:10:51.441 --> 22:11:05.567
But if we just pass the SVG data, right, the SVG data is going to look like what in this GitHub, I can go to display the source blob here and I can see exactly what this code looks like this code here is definitely not an image URI.

13413
22:11:05.567 --> 22:11:16.734
What we need is the image URI to look something like this, right? Now, the way that we're going to pass it in is like with this SVG code, right? Because we want to just pass it the SVG code, and then have the contract handle everything else.

13414
22:11:16.797 --> 22:11:26.353
So how do we actually do this? Well, what we can do is we can create a function called SVG to image URI.

13415
22:11:26.353 --> 22:11:31.170
And on chain, we can convert these SVGs from SVGs.

13416
22:11:31.170 --> 22:11:32.441
To image arise.

13417
22:11:32.441 --> 22:11:45.147
So instead of having IPFS, as their start, we're gonna use something called base 64 encoding, you can actually encode any SVG to a base 64 image URL.

13418
22:11:45.147 --> 22:11:46.178
That's right.

13419
22:11:46.178 --> 22:11:49.012
It'll look something like this base.

13420
22:11:49.012 --> 22:11:53.572
64 is group a binary to text encoding schemes that represents binary data.

13421
22:11:53.572 --> 22:11:55.910
Or in our case, our SVG data.

13422
22:11:55.910 --> 22:11:56.313
Base.

13423
22:11:56.313 --> 22:12:20.410
64 is particularly prevalent in the world wide web, or one of its uses is the ability to embed image files or other binary assets inside textual assets, such as HTML, and CSS, what we can do, can actually convert all this SVG stuff to a URL or an image URI would be great, right? That's exactly what we want, we want to be able to convert this to a URL or an image URI.

13424
22:12:20.410 --> 22:12:33.076
Now, if you take one of these images, or these SVG images, like the happy to have SVG, what we can actually do in this happy dot SVG is we can actually copy the image address, which is going to be the URL of this address.

13425
22:12:33.076 --> 22:12:36.221
And if we paste it back in, we'll see justice file here.

13426
22:12:36.221 --> 22:12:41.943
And in this site, we can actually do data type, remote URL, paste it in here.

13427
22:12:41.943 --> 22:12:44.909
And we can say encode SVG to base 64.

13428
22:12:44.909 --> 22:12:51.099
And down here, we'll get this weird job role of numbers and letters and stuff.

13429
22:12:51.099 --> 22:13:12.195
This base 64 encoding represents the SVG that we just got and what we can do in our browser, we can type data, colon, image, slash SVG, plus XML, semicolon, base, 64, comma, and then paste that massive thing in here and Enter.

13430
22:13:12.195 --> 22:13:16.957
And wouldn't you know it, we get exactly that image back up.

13431
22:13:16.957 --> 22:13:22.275
So that huge, massive thing here is the base 64 encoding of this image.

13432
22:13:22.275 --> 22:13:28.153
So with this basic C four encoded image, we can use this on chain as the image you arrive for our images.

13433
22:13:28.153 --> 22:13:29.656
And then for our metadata.

13434
22:13:29.656 --> 22:13:32.256
We'll just bake that directly into our token URI.

13435
22:13:32.256 --> 22:13:34.035
You'll see what I mean in a second.

13436
22:13:34.035 --> 22:13:39.549
So we have a way where we can actually directly put our SVG code right into our smart contracts.

13437
22:13:39.549 --> 22:13:40.549
Let's figure out how to do that.

13438
22:13:40.549 --> 22:13:47.179
So we have function, SVG to image URI, so we know we're going to want to probably do that same base 64 encoding on chain.

13439
22:13:47.179 --> 22:13:55.681
We're gonna 100 percent do this off chain if you want to save some gas but it's kind of fun for To show how to do this all on chain, so we'll make this a public pure function.

13440
22:13:55.681 --> 22:13:59.452
And we'll have it returns a string memory.

13441
22:13:59.452 --> 22:14:06.322
So we're going to give this function an SVG, which we're going to pass in from our constructor.

13442
22:14:06.322 --> 22:14:27.218
And we're going to return a string, which is going to be that base 64 encoded URL that we just saw, while up at our top will do string, private constant, base S feed, base 64, encoded SVG prefix equals that right there.

13443
22:14:27.218 --> 22:14:33.024
And we'll use this to generate our SVG now, well, we can do.

13444
22:14:33.024 --> 22:14:43.735
And then we're going to do string memory SVG, we're going to encode this SVG in basically for ourself by adding the base 64 encoding on chain.

13445
22:14:43.800 --> 22:14:47.733
Now, we don't really want to have to rewrite that ourselves.

13446
22:14:47.800 --> 22:14:49.406
So luckily for us, somebody has already done this.

13447
22:14:49.800 --> 22:14:56.918
see the GitHub repo associated with this, this was created by one of the LoopRing devs really awesome project, if you want to check that out as well.

13448
22:14:56.918 --> 22:15:00.111
And we're going to borrow this code for our SVG on chain.

13449
22:15:00.111 --> 22:15:18.292
So what we can do is we can add this in here, add their GitHub code, where they have basically everything that we need in here to encode and decode basics before, we can do yarn, add dash dash Dev, base 64 Dash soul, this is going to add their code as a dependency.

13450
22:15:18.292 --> 22:15:28.729
And once we've added it, we can go ahead and import it with import, base 64, dash soul slash, base 64 dot Sol.

13451
22:15:28.729 --> 22:15:33.206
And this contract comes with an encoder.

13452
22:15:33.206 --> 22:15:41.956
So then we can just do string memory, SVG base, 64, encoded, equals base 64 dot ENCODE.

13453
22:15:41.956 --> 22:15:45.747
And here's where it gets a little bit weird.

13454
22:15:45.800 --> 22:16:19.107
We'll do bytes string, abi dot ENCODE, act, SVG, and then we'll return string API dot encode packed, base 64, encoded SVG prefix, comma SVG base 64 encoded, and just this function, this SVG to image URI will take in any SVG and spit us back out a URL or URI that looks exactly like this.

13455
22:16:19.107 --> 22:16:21.729
Now, I kind of sped through some stuff in here.

13456
22:16:21.729 --> 22:16:33.597
There's a whole bunch of new stuff like ABI dot encode packed that we did twice, what is this ABI dot encode packed doing? Well, let's learn about that.

13457
22:16:33.597 --> 22:16:41.001
So from a really, really high level, this is basically how you concatenate strings.

13458
22:16:41.001 --> 22:16:43.710
Right, this is how you combine strings together.

13459
22:16:43.710 --> 22:16:51.978
And we're going to jump over remix to actually explore this ABI dot encode pact and this ABI encoding stuff a little bit more.

13460
22:16:51.978 --> 22:16:56.456
Now the section that we're about to go through is definitely advanced.

13461
22:16:56.456 --> 22:17:05.227
And we're going to be going over some really low level stuff, and how solidity works behind the scenes, how the binary works, and this thing called opcodes.

13462
22:17:05.227 --> 22:17:08.733
And all this crazy, low level, tricky, difficult things to understand.

13463
22:17:08.733 --> 22:17:13.733
If you want to move past this section, there are timestamps in the GitHub repo.

13464
22:17:13.801 --> 22:17:15.145
To help you move past this.

13465
22:17:16.801 --> 22:17:22.448
at least try to absorb most of this material, if you don't understand it the first time.

13466
22:17:22.448 --> 22:17:23.565
That's 100 percent.

13467
22:17:23.565 --> 22:17:25.325
Okay, this is more advanced.

13468
22:17:25.325 --> 22:17:30.637
Anyways, for most of your basic projects, you won't really need this information.

13469
22:17:30.637 --> 22:17:37.377
It's only later on once you get more advanced that knowing all this is really going to make you a phenomenal solidity developer.

13470
22:17:37.377 --> 22:17:51.768
And when you approach this section, when you approach this sub lesson on EVM, opcodes, and coding and calling, just know that if you don't 100 percent understand it the first time that is okay, if you want to watch this section a couple of times fantastic.

13471
22:17:51.768 --> 22:17:55.229
So if you want to jump over to remix and follow along, let's do it.

13472
22:17:55.229 --> 22:17:59.995
Now in our contract section, let's go ahead and create a new file, we're going to call it encoding dot soul.

13473
22:17:59.995 --> 22:18:06.602
And remember, all the code that we're going to be going with in here is going to be in this sub Lesson folder of the Hardhead NFT.

13474
22:18:06.602 --> 22:18:06.868
FCC.

13475
22:18:06.868 --> 22:18:11.598
And all the code we're going to be working with is going to be in this encoding dot soul.

13476
22:18:11.598 --> 22:18:18.005
And then in a little bit, we're going to work on this call anything that soul so we're in this encoding dot soul.

13477
22:18:18.005 --> 22:18:20.038
And let's just make our basic code here.

13478
22:18:20.038 --> 22:18:33.373
So we'll say spdx, license identifier, MIT pragma, solidity, carrot, zero, point 8.

13479
22:18:33.373 --> 22:18:40.737
7, like that, do contract encoding, boom, compile, or Command S or ctrl S great things are looking good.

13480
22:18:40.802 --> 22:18:49.119
Now remember, the whole purpose for this is to first understand what's going on here, and more about this API dot encode packed stuff.

13481
22:18:49.119 --> 22:18:58.769
So let's first just write a function that should owes us wrapping API dot encode packed with some strings and wrapping it around a string is going to return a string.

13482
22:18:58.769 --> 22:19:03.837
So we could do function, bind strings, or concatenate strings.

13483
22:19:03.837 --> 22:19:12.140
This will be a public pure since we're not going to be reading any storage, we'll say returns string memory.

13484
22:19:12.140 --> 22:19:17.656
And we'll say return string, API dot encode packed.

13485
22:19:17.656 --> 22:19:22.602
I'm I'm comma, space in here, I miss you, like so.

13486
22:19:22.602 --> 22:19:24.802
We need another parenthesis here.

13487
22:19:24.802 --> 22:19:25.602
Okay, great.

13488
22:19:25.802 --> 22:19:32.016
Now let's go ahead and deploy this, we'll start a JavaScript VM will deploy encoding coding.

13489
22:19:32.016 --> 22:19:32.230
so.

13490
22:19:32.230 --> 22:19:37.755
We'll come down here, we'll click Combine strings, and we get that whole string output.

13491
22:19:37.802 --> 22:19:38.864
Hi, Mom, miss you.

13492
22:19:41.803 --> 22:19:53.544
mom misuse together into its bytes form, because API dot encode packed returns a bytes object, and we are typecasting it by wrapping it in this string thing to be a string.

13493
22:19:53.544 --> 22:19:57.615
And solidity says, okay, yeah, bytes to string, that's fine, that totally works.

13494
22:19:57.615 --> 22:20:02.464
And this API dot encode packed are these globally available methods and units.

13495
22:20:02.464 --> 22:20:14.975
And actually, in solidity, there's a whole bunch of these, there's this solidity cheat sheet, and there's gonna be a link to this in the GitHub repo as well, that has a whole bunch of operators and it has a whole bunch of these global variables and methods.

13496
22:20:14.975 --> 22:20:24.403
You can see if we look in here, we look for ABI dot encode pact, we see ABI dot encode pact right here, we scroll down, we'll see some more that we're familiar with as well.

13497
22:20:24.403 --> 22:20:29.727
Like, for example, message dot sender, sender of the message, message dot value.

13498
22:20:29.803 --> 22:20:36.409
There's a whole bunch of other globally available methods and variables that we can use when we're coding our stuff.

13499
22:20:36.409 --> 22:20:38.469
Now, I will say though, in 0.

13500
22:20:38.469 --> 22:20:57.065
8, point, well, plus, you can actually do string dot concat, you know, string a, comma string B, if you want to, instead of doing this API to encode packed, but I still wanted to show you the API dot encode pack, because it's a great segue into all this ABI stuff that we're about to go over.

13501
22:20:57.065 --> 22:20:59.950
But let's focus on this encode packed thing.

13502
22:20:59.950 --> 22:21:11.691
So what is actually going on here? Well, before we dive deeper into this encode pact, let's understand a little bit more about what happens when we send a transaction.

13503
22:21:11.691 --> 22:21:16.381
So when we compile our code, and again, all these pictures are going to be in the GitHub repo.

13504
22:21:16.381 --> 22:21:17.644
Remember back to ethers.

13505
22:21:17.644 --> 22:21:23.717
js, we had those two files, we got a dot ABI file, and a dot bin or dot binary.

13506
22:21:23.804 --> 22:21:27.234
Back in our ether symbol storage, when we ran yarn, compile.

13507
22:21:27.234 --> 22:21:36.183
The two main files that we got, were this symbol storage that abi, which was this, you know, this ABI thing that we've become familiar with.

13508
22:21:36.183 --> 22:21:42.704
And then the simple storage dot bin, which is the binary, which has a whole bunch of just numbers and letters and stuff we didn't understand.

13509
22:21:42.704 --> 22:22:02.581
And you can see that in remix to, like if we were to compile this, you get a compilation details, you get a whole bunch of stuff in here, right? You can see the ABI in here, which this is kind of like a different way of viewing that API, we also get this bytecode bit and it's this object that has the same stuff that has like those random numbers and letters.

13510
22:22:02.581 --> 22:22:06.459
But this is actually the binary this is actually what's getting put on the blockchain.

13511
22:22:06.459 --> 22:22:09.344
It's this binary, it's this low level stuff.

13512
22:22:09.344 --> 22:22:15.753
Now, when we actually send these contracts to the blockchain, we're sending like I said, we're sending this binary thing.

13513
22:22:15.804 --> 22:22:17.625
That's exactly what we're sending to the blockchain.

13514
22:22:17.804 --> 22:22:33.769
remember how, again, back in our ethers project, we saw what is a transaction, right, a transaction has a nonce, it has a gas price guess limit to value data, we kind of skipped over the VRS a little bit, because that's kind of that mathy component of the transaction signature.

13515
22:22:33.769 --> 22:22:42.677
But again, back in our ethos project, we did this as well, right in our deploy script, ended up sending a transaction ourselves, using just ethers.

13516
22:22:42.677 --> 22:22:51.698
We passed a nonce, a gas price, gas limit to value data was this massive thing to declare a contract, and then also the chain ID.

13517
22:22:51.698 --> 22:22:55.130
We didn't work with the VAR s, because ethers does that for us.

13518
22:22:55.130 --> 22:22:58.961
But there's also this VAR s component that we don't bother to look at.

13519
22:22:58.961 --> 22:23:05.412
When we send a transaction that actually creates a contract, the two is going to be empty.

13520
22:23:05.412 --> 22:23:08.499
We're not going to send this contract deployment to any address.

13521
22:23:08.499 --> 22:23:15.721
But the data of this is going to have the contract initialization code and contract bytecode.

13522
22:23:15.805 --> 22:23:16.043
Right.

13523
22:23:18.805 --> 22:23:22.313
you initialize the contract, and then what the contract actually looks like.

13524
22:23:22.313 --> 22:23:28.226
So if you look at any of the contracts that you deployed, for example, I'm going to look at our raffle that we deployed.

13525
22:23:28.226 --> 22:23:35.497
If you go to the transactions of your contract, we can see create raffle, right, let's go to that transaction.

13526
22:23:35.497 --> 22:23:40.805
If we go down and click to see more in the ether scan, we can see this input data thing.

13527
22:23:40.805 --> 22:23:45.055
And once again, it's got all this random garbled numbers and letters.

13528
22:23:45.055 --> 22:23:57.888
This is that binary data of the contract initialization code and the contract byte code right what we send in our trend In this action is this data thing, we send this this weird bunch of garbled nonsense.

13529
22:23:57.888 --> 22:23:59.648
Now we're going to head back to remix.

13530
22:23:59.648 --> 22:24:03.756
And I'm just going to leave this as comments in here in the encoding dot soul and the GitHub repo.

13531
22:24:03.805 --> 22:24:07.305
There's a ton of comments in here explaining exactly what I'm explaining.

13532
22:24:07.305 --> 22:24:09.998
So if you want to follow along there, you can as well.

13533
22:24:09.998 --> 22:24:27.242
But now in order for the blockchain to understand, okay, what do these numbers and letters even mean? You need a special reader cerium or the blockchain needs to be able to read all this stuff, it needs to be able to map all these random numbers and letters to what they actually do.

13534
22:24:27.242 --> 22:24:36.705
How does Aetherium or polygon or avalanche know that all this nonsense is basically telling it to make a contract, you kind of think of it as saying, like, take off your coat.

13535
22:24:36.705 --> 22:24:45.186
The only reason that we as human beings understand what take off your coat means is that we understand English, We're all reading English, for solidity.

13536
22:24:45.186 --> 22:24:46.138
And for blockchains.

13537
22:24:46.138 --> 22:24:55.113
Instead of English, I read these numbers and letters kind of like words, just instead of take off your coat, it's like deploy contract, and the contract does next XYZ and all this random stuff.

13538
22:24:55.113 --> 22:24:59.509
So this bytecode represents the low level computer instructions to make our contract happen.

13539
22:24:59.509 --> 22:25:05.494
And all these numbers and letters represent kind of an alphabet, just like how take off your coat is an alphabet.

13540
22:25:05.494 --> 22:25:13.117
And when you combine them like this, it makes something that to us makes sense, you can kind of think of the alphabet for these as what's called opcodes.

13541
22:25:13.117 --> 22:25:21.539
If you go to create a new tab, if you go to EVM dot codes, we'll get to this place where it just has a list of all these instructions.

13542
22:25:21.539 --> 22:25:25.150
On the left side, you can see this thing called opcode.

13543
22:25:25.150 --> 22:25:58.193
And then you can see name, so this opcode section is saying, Hey, if you see a 00 in this bytecode, that 00 represents this opcode stop, which does what which halts execution, if you see a 01 you're gonna do some addition stuff, a 02 is multiply, there are all these op codes that are kind of like the alphabet, or the language of this binary stuff, right, and they go all the way down to f f self destruct, these op codes also have, and that's what this is reading.

13544
22:25:58.193 --> 22:26:02.271
Right? So if we look at our transaction here, and your yours might be a little bit different.

13545
22:26:02.271 --> 22:26:06.627
Oh six, one says, Okay, the first thing we want you to do is the O six, one opcode.

13546
22:26:06.627 --> 22:26:13.733
And if we go to EVM, opcodes, we look for six one, it's saying push to place to buy item on the stack.

13547
22:26:13.733 --> 22:26:23.726
That's exactly how it's reading this any language that can compile down to this opcode stuff down to this specific set of Aetherium opcodes, or EVM.

13548
22:26:23.807 --> 22:26:28.169
opcodes, is what's known as the EVM, the Etherium virtual machine.

13549
22:26:28.169 --> 22:26:44.156
So being able to read these op codes is sometimes abstractly called the EVM, the Etherium virtual machine, the EVM basically represents all the instructions, a computer must be able to read for it to interact with Aetherium, or Aetherium, like applications.

13550
22:26:44.156 --> 22:27:02.072
And this is why so many blockchains all work with solidity because solidity compiles down to this bytecode here, and polygon, avalanche arbitrage Aetherium, they all compiled down to the exact same type of binary, and they all have the exact same readers.

13551
22:27:02.072 --> 22:27:12.726
Now why are we telling you all this stuff, you might be saying, hey, Patrick, this is cool and all but it looks like ABI dot encode packed, all that does is concatenate strings, abi encode pack can do actually way more.

13552
22:27:12.807 --> 22:27:31.842
And if we look at these global variables, API dot encode packed is like what the third one down the list because it's a non standard way to encode stuff to this binary stuff that we just talked about, we can actually encode pretty much anything we want to being in this binary format, basically.

13553
22:27:31.842 --> 22:27:34.116
And let's take a look at at encoding something.

13554
22:27:34.116 --> 22:27:36.708
So let's create a function called encode number.

13555
22:27:36.708 --> 22:27:43.736
And this will be a public pure function, since we're not going to read any state, and we'll say returns a bytes memory.

13556
22:27:43.736 --> 22:28:01.332
We're going to have this function return a bytes object, we're going to have it returned the what this number is going to look like but in binary, so we'll say bytes, memory number equals ABI dot encode one, and then return number.

13557
22:28:01.332 --> 22:28:06.715
So we're going to encode number down to it's a bi or it's binary format.

13558
22:28:06.715 --> 22:28:17.008
So I know a lot of times when we say oh, what's the ABI what's the ABI right? Previously, we say, Oh, the ABI is, is this thing, right? It's, it's all these inputs and outputs.

13559
22:28:17.008 --> 22:28:19.755
This is kind of the human readable version of the ABI.

13560
22:28:19.755 --> 22:28:34.214
But again, the ABI is the application binary interface we want to encode or numbers down to it's basically it's binary, this ABI dot ENCODE is going to be a little different than like the ABI that you see when you're looking at compilation details.

13561
22:28:34.214 --> 22:28:39.130
This is technically like the ABI technically is how to interact with this contract.

13562
22:28:39.130 --> 22:28:41.876
However, it's not the actual binary version of it.

13563
22:28:41.876 --> 22:28:50.299
So we're saying, okay, encode this number one down to its binary version, so that our contracts can interact with it in a way that they understand.

13564
22:28:50.299 --> 22:28:54.808
So we're just saying okay, Watch that number one, let's make you machine readable.

13565
22:28:54.808 --> 22:29:06.458
And if we go, we compile this and we deploy this right, let's delete that that old contract, we deploy this, we now have combined strings and encode number, we click it, we get this big hex thing.

13566
22:29:06.458 --> 22:29:10.980
This is how the computer is going to understand the number one.

13567
22:29:10.980 --> 22:29:15.665
Now we can encode pretty much anything actually, we could encode a string.

13568
22:29:15.665 --> 22:29:23.152
So we'll say, function, encode string, we'll make this a public key here as well.

13569
22:29:23.152 --> 22:29:29.775
It'll return a bytes memory, because we want to give it that binary stuff or that bites stuff.

13570
22:29:29.775 --> 22:29:39.071
And we'll say bytes memory, some string equals ABI dot encode some string, and then return some string.

13571
22:29:39.071 --> 22:29:46.843
Now let's compile that delete our old contract, deploy that code string, we get this big, big, big object here.

13572
22:29:46.843 --> 22:29:48.429
And this is the binary.

13573
22:29:48.429 --> 22:29:58.498
Now you'll notice something here, there's a ton of zeros, and those zeros take up space, right, that's a lot of space for the computer to take up, even though they're not really doing anything.

13574
22:29:58.498 --> 22:30:00.615
They're just kind of taking up space.

13575
22:30:00.615 --> 22:30:08.642
So solidity also comes with this ABI dot encode tact, which performs packed encoding of the given arguments.

13576
22:30:08.642 --> 22:30:12.047
And you can read more about it in the solidity docs, if you want.

13577
22:30:12.047 --> 22:30:14.443
And this is called the non standard packed mode.

13578
22:30:14.443 --> 22:30:24.609
And it does the same encoding with some stipulations type shorter than 32 bytes are concatenated directly without padding, or sign extension, dynamic types are encoded in place.

13579
22:30:24.609 --> 22:30:33.285
And without the length array elements are padded, but still encoded in place, you can kind of think of ENCODE packed as sort of like a compressor, right? It's the ENCODE function.

13580
22:30:33.285 --> 22:30:37.402
But it compresses stuff, if we wanted to encode some string but want to save space.

13581
22:30:37.402 --> 22:30:40.927
And we didn't need the perfect low level binary of it.

13582
22:30:40.927 --> 22:30:49.110
We could do function and code string packed, make this a public pure, and have it return a bytes memory.

13583
22:30:49.110 --> 22:30:57.709
We could say, bytes memory, some string equals ABI dot encode packed once again, some string.

13584
22:30:57.809 --> 22:31:00.209
So we're doing a code pack instead of a code.

13585
22:31:00.809 --> 22:31:08.055
return some string here, we'll compile this and we'll see the difference, right compile, we'll delete our old one, we'll deploy this.

13586
22:31:08.055 --> 22:31:18.885
Now we have ENCODE string, which again, that's what encoded string is gonna give us and we have encoded string packed, which returns us this much, much smaller bytes object.

13587
22:31:18.885 --> 22:31:27.013
So you see the size difference, if we're trying to save gas, in code, string packed is going to be a way for us to save a lot more gas.

13588
22:31:27.013 --> 22:32:08.081
Now, abi dot encode pact is actually really similar to something that we've done before, which is typecasting, if we didn't function and code string, bytes, public pure returns, bytes, memory, bytes, memories, some string equals bytes, some string, turn some string, these two are going to look nearly identical, right? So if we compile, we'll delete our old contract, deploy this code string bytes, which gives us this and encode string pack using the ABI to encode pack, they give us the exact same output, whereas encode strings to give us this big piece.

13589
22:32:08.081 --> 22:32:10.000
So the two of these get the same result.

13590
22:32:10.000 --> 22:32:12.410
But behind the scenes, they're doing something a little bit different.

13591
22:32:12.410 --> 22:32:14.717
And I'm not going to go over exactly what that is.

13592
22:32:14.810 --> 22:32:21.757
But I've left a link inside of the code here, if you want to learn more, which is exactly what we're doing in our NFT.

13593
22:32:21.810 --> 22:32:25.531
Right, we're doing ABR dot encode packed, we're combining two strings.

13594
22:32:25.531 --> 22:32:36.810
By putting them together, we're encoding them to their bytes implementation to their packed bytes implementation, and then we're just typecasting them back from bytes to string.

13595
22:32:36.810 --> 22:32:39.143
And that's how we concatenate them.

13596
22:32:39.143 --> 22:32:41.236
Now, at this point, you might be thinking, okay, cool.

13597
22:32:41.236 --> 22:32:41.973
Great, Patrick.

13598
22:32:41.973 --> 22:32:42.563
I'm all set.

13599
22:32:42.563 --> 22:32:43.524
I understand this.

13600
22:32:43.524 --> 22:32:45.190
I'm happy to go back to my project.

13601
22:32:45.190 --> 22:32:53.476
And if you want to do that, absolutely go for it and skip over this section, but some other viewers might be going okay, Patrick, this is seems pretty cool.

13602
22:32:53.476 --> 22:33:04.572
But I'm sure this encode pacts in this encode function aren't just here to concatenate strings, they probably have some other function, what do they actually do? Well, if that's what you're asking, I'm glad you asked.

13603
22:33:04.572 --> 22:33:06.534
And I'm glad you're curious, because we're going to find out.

13604
22:33:06.534 --> 22:33:15.268
Now not only can you encode stuff, like strings and numbers, and really anything, but you can decode stuff.

13605
22:33:15.268 --> 22:33:27.285
So I can say, function, decode string, public, your returns string memory, string memory, some string equals ABI dot decode.

13606
22:33:27.285 --> 22:33:30.359
This is going to take a couple parameters.

13607
22:33:30.359 --> 22:33:39.861
So if you look in the docs here, abi dot decode, it takes as a first argument, the encoded data, and then it takes a tuple.

13608
22:33:39.861 --> 22:33:48.181
You can kind of think of it as a list but not quite a list, a set of types to decode this into and it returns the number of parameters that you gave it.

13609
22:33:48.181 --> 22:33:59.442
So we might want to say this string memory some string Adding, let's give it as input this encode string function, the result of this encode string function, right, which again, is going to be this big thing.

13610
22:33:59.442 --> 22:34:06.303
So this is kind of equivalent to sticking this massive thing in here, but we're just not going to stick the massive thing in there, because it's really big.

13611
22:34:06.303 --> 22:34:12.525
So we're gonna say, Let's decode the result of ENCODE string, and let's decode it into a string.

13612
22:34:12.525 --> 22:34:20.161
Because we need to tell solidity, hey, we're going to decode this, but it doesn't know what to decode it into.

13613
22:34:20.161 --> 22:34:21.261
It's like, okay, cool.

13614
22:34:21.261 --> 22:34:28.739
I can decode this, but like, what, what do you want me to do with it, and we say, Oh, this is a string, so decode it into a string.

13615
22:34:28.739 --> 22:34:31.120
And then we can do return some string.

13616
22:34:31.120 --> 22:34:36.995
Now, once again, we deploy that old Cotters, we delete the last contract, we deploy this new one.

13617
22:34:36.995 --> 22:34:47.744
So in code string, and code string, whereas in code, string, and code string returns this massive thing, as a human being, we're like, God, I can't read that computers can read that.

13618
22:34:47.812 --> 22:34:49.262
But we can't really read that.

13619
22:34:50.812 --> 22:34:55.812
that back into its string form, we hit decode string, and we get back some string.

13620
22:34:55.812 --> 22:35:02.431
And now we can actually multi encode and multi and decode, right, we can encode as much stuff as we want.

13621
22:35:02.431 --> 22:35:19.133
So I can say function, multi ENCODE, public pure, returns bytes memory, we're going to encode a couple of things, we'll say bytes, memory, some string equals ABI dot encode some string, comma, it's bigger.

13622
22:35:19.133 --> 22:35:25.565
So we're going to encode two strings here, we're gonna encode some string, and it's bigger.

13623
22:35:25.565 --> 22:35:32.619
So we have two strings, we're going to encode and we'll return some string, even though it's you know, bytes.

13624
22:35:32.619 --> 22:35:35.452
And then we can actually multi decode.

13625
22:35:35.452 --> 22:35:45.689
So we'll say function, multi decode, this will be a public pure returns, we'll say it returns two strings, string memory, and string memory.

13626
22:35:45.689 --> 22:35:58.412
And instead of doing string memory, some string equals API decode, we'll say, string memory, some string, comma string memory, some other string.

13627
22:35:58.412 --> 22:36:03.612
So we're gonna get to returns equals Avi dot decode.

13628
22:36:03.812 --> 22:36:11.949
Let's decode this multi encode result, which is the doubly encoded strings into a string and another string.

13629
22:36:11.949 --> 22:36:17.395
And then we'll return both of these are some string, there we go.

13630
22:36:17.395 --> 22:36:22.249
Now we'll return some string, and then some other string, I need a semicolon here.

13631
22:36:22.249 --> 22:36:35.146
So now when we deploy this, let's close this out, deploy this new one, right, we now have this multi in code, which gives us this even bigger bites object, right? Because this is two strings encoded.

13632
22:36:35.146 --> 22:36:40.435
And now if we hit multi decode, take a second, what do you think it's going to put out output? Let's go ahead and hit it.

13633
22:36:40.435 --> 22:36:46.345
Now it's gonna give us two strings, right, it's gonna give you these two strings, some string, it's bigger.

13634
22:36:46.345 --> 22:36:50.337
So we can tell solidity to encode a bunch of stuff.

13635
22:36:50.337 --> 22:36:57.444
And then we can even decode it by telling it, okay, this big object here, it's two strings combined, and then we decode it.

13636
22:36:57.444 --> 22:37:25.729
Now you can even multi encode with that encode pack thing, right? We could do function, multi encode packed, public pure returns, bytes memory, and then bytes memory, some string equals ABI dot encode packed some string, comma, it's bigger than return some string, we could do this, right, but this is going to give us the packed version of these two strings.

13637
22:37:25.729 --> 22:37:32.253
So the decoding actually isn't going to work on this because this is packed encoding.

13638
22:37:32.253 --> 22:37:36.485
So if we tried to do, I'm gonna say this doesn't work.

13639
22:37:36.485 --> 22:38:03.759
Try to do function, multi decode, packed, public pure returns, string memory, string memory, some string equals Avi dot decode multi encode packed in a string and have exactly what we did above to, if we do return some string, what do you think's gonna happen? Let's, let's try to delete the old contract, deploy a new one.

13640
22:38:03.814 --> 22:38:10.502
We'll do multi decode, packed, multi encode multi decode, packed, and we actually just get an error.

13641
22:38:10.502 --> 22:38:14.414
solidity basically goes, Yeah, this looks like it's packed.

13642
22:38:14.414 --> 22:38:16.523
I don't know how to decode that.

13643
22:38:16.523 --> 22:38:37.256
But instead, what we can do is we can do function more to string cast packed like this a public pure returns string memory, string, memory, some string equals string, multi and code packed, return some string.

13644
22:38:37.256 --> 22:38:45.359
This one will work right because again, this pact encoding is kind of similar to just type casting.

13645
22:38:45.359 --> 22:38:53.666
So we'll compile will redeploy multi string cast pact, we get some Trying, it's bigger, right? And we don't have a space here.

13646
22:38:53.666 --> 22:38:55.617
But we should have put a space in there.

13647
22:38:55.617 --> 22:39:08.581
Now that we've learned more about this in ABI dot encode and decoding, and we know that okay, this is what the computer, this is, what Aetherium.

13648
22:39:08.581 --> 22:39:11.914
This is what the EVM, or any EVM compatible chain is looking for.

13649
22:39:11.914 --> 22:39:13.639
It's looking for this bytecode.

13650
22:39:13.639 --> 22:39:16.242
It's looking for this, this binary stuff.

13651
22:39:16.242 --> 22:39:22.402
And we just learned a little bit more about how to encode different variables into the binary into that data bit.

13652
22:39:22.402 --> 22:39:39.010
Well, what do we do now? Now since we know that our transactions are just going to be compiled down to this binary stuff, what we can do then is we can actually populate this data value of our transactions ourselves with the binary that code is going to use.

13653
22:39:39.010 --> 22:39:56.331
So here's our transaction for a contract deployment, the data field of the contract deployment is going to be all that binary code of the contract for a function call, the data piece is going to be what to send to the address what data what function to call on the to address.

13654
22:39:56.331 --> 22:40:04.252
Let's look at another one of our transactions on ether scan right on one of our contracts, you don't have to I'm going to look at enter raffle from a previous section.

13655
22:40:04.252 --> 22:40:07.011
And if we select down, we look at input data.

13656
22:40:07.011 --> 22:40:08.978
It says function enter raffle method ID.

13657
22:40:08.978 --> 22:40:14.735
But if we look at the original, this is what's getting sent in the data field.

13658
22:40:14.815 --> 22:40:19.142
It's this binary, it's this hex it's this weird, low level bytes thing.

13659
22:40:19.142 --> 22:40:27.847
This is how the Ethereum blockchain or the or whatever EVM chain you're working with knows which function to call, it translates this into a function.

13660
22:40:27.847 --> 22:40:33.386
And we can do the exact same thing and call these functions ourselves.

13661
22:40:33.386 --> 22:40:52.340
So what we can actually do with this crazy newfound data and coding stuff, what we can actually do is send the data field of a transaction ourself, in a transaction call back in this ether throwback where this data thing was the contract creation code.

13662
22:40:52.340 --> 22:41:02.190
Well, instead, we could populate this data thing with our function call code, the exact function that we want to call in the binary in hex addition.

13663
22:41:02.190 --> 22:41:15.589
Now you might be thinking, Oh, well, why would I do that, I can always just use the interface, the ABI, all that stuff, well, maybe you don't have that maybe all you have is the function name, maybe all you have is the parameters you want to send.

13664
22:41:15.589 --> 22:41:29.593
Or maybe you want to make your code, be able to send arbitrary functions, or make arbitrary calls or do random really advanced stuff, right, that's where sending our function calls directly by populating this data field is going to be incredibly important.

13665
22:41:29.593 --> 22:41:35.578
So remember, I said, you're always going to need the ABI, and the contract address, send a function.

13666
22:41:35.578 --> 22:41:37.713
Now, when I said, you always need the API.

13667
22:41:37.816 --> 22:41:45.170
Originally, we were kind of talking about this thing, this big, this big thing, which is cool, which is the API.

13668
22:41:45.170 --> 22:41:50.101
But this is like the human readable API, you can also do it with the non human readable API.

13669
22:41:50.101 --> 22:41:59.701
And additionally, you don't need all this stuff, you can really use just the name of a function, and then the input types to send a function call.

13670
22:41:59.701 --> 22:42:44.477
So the question is, then, okay, how do we send? How do we send transactions that call functions with just the data field populated? And then the next question is, how do we populate the data field? What do we populate the data field with to make one of these function calls? And then how do we send these transactions slowly, actually has some more low level keywords, namely, static call and call we actually we've used call in the past before, does this code look at all familiar to you? Well, it should, because this is, we use a similar setup in our fulfill random words for our lottery, right, we sent money doing this recent winner dot call, right? Recently, it was the address of the recent winner, and we did not call.

13671
22:42:44.477 --> 22:42:49.612
And then we have this weird stuff in this brackets here, and then nothing in the parentheses.

13672
22:42:49.612 --> 22:42:56.077
So we did actually, essentially, we use this call keyword previously, but we didn't really tell you what it did.

13673
22:42:56.077 --> 22:42:59.494
So call is how we can call functions to change the state of the blockchain.

13674
22:42:59.494 --> 22:43:10.613
Static call is basically how at a low level, we call our view, or pure functions, write static calls gonna be like, okay, don't change the state of the blockchain with this one, just give us the return value.

13675
22:43:10.613 --> 22:43:17.910
So this is kind of similar to like a view or a pure function at low level, there's also a Send word but like, basically forget about it.

13676
22:43:17.910 --> 22:43:20.488
We're just gonna be working with call, instead of call.

13677
22:43:20.488 --> 22:43:23.259
And, you know, later on, we'll learn about another one called delegate call.

13678
22:43:23.259 --> 22:43:25.080
But don't worry about that for now.

13679
22:43:25.080 --> 22:43:33.572
Recent winter duck call like this, in these little squiggly brackets, we said, Okay, we updated the value directly of our transaction in solidity.

13680
22:43:33.572 --> 22:43:45.663
So which again, if we have these transaction fields, and we just directly updated value in these little brackets, right, we can also directly update gas limited gas price in these little brackets if we wanted to as well.

13681
22:43:45.663 --> 22:43:49.160
And in here, these parentheses is where we're going to stick our data.

13682
22:43:49.160 --> 22:43:51.628
Since all we wanted to do with our withdrawal.

13683
22:43:51.628 --> 22:43:53.928
function previously was send money.

13684
22:43:53.928 --> 22:43:58.767
We said, Okay, send money change the value that we're going to send.

13685
22:43:58.767 --> 22:44:18.591
But don't pass any data, keep that data bit empty, which is why, again, remember how we hit this button before, right and we had called data be empty, that's essentially running this command with called data be empty with this section be empty, and then just updating the value that we set with the transaction.

13686
22:44:18.591 --> 22:44:23.372
And so it's this section that we can use to populate data to actually call specific functions.

13687
22:44:23.372 --> 22:44:25.368
We're going to put a whole bunch more comments here.

13688
22:44:25.368 --> 22:44:29.259
So when our squiggly brackets, we're able to pass specific fields of a transaction like value.

13689
22:44:29.259 --> 22:44:34.117
And in our parentheses, we're able to pass data in order to call a specific function.

13690
22:44:34.117 --> 22:44:43.105
But in here, there's no function to call since we were just sending them if we want to call a function or send any data, we can do this in the parentheses.

13691
22:44:43.105 --> 22:44:47.834
And I think I spelt that wrong.

13692
22:44:47.834 --> 22:44:50.718
Now, we've learned a ton here.

13693
22:44:50.718 --> 22:44:53.428
So let's do a quick refresher of what we just learned.

13694
22:44:53.428 --> 22:44:59.172
And then we're going to actually learn how we can call any function just by using this syntax here.

13695
22:44:59.172 --> 22:45:06.193
Well, we learned from really high level, if we want to combine strings, we can do ABI dot encode packed and then typecast that to a string.

13696
22:45:06.193 --> 22:45:15.741
And in newer versions of solidity you can do, you can do string dot concat, you know, Hi, Mom, come on, miss you.

13697
22:45:15.741 --> 22:45:17.507
In newer versions of solidity.

13698
22:45:17.507 --> 22:45:20.197
This works as well, but not in older versions of solidity.

13699
22:45:20.197 --> 22:45:37.751
Then we learned a lot about some low level stuff we learned, okay, when we compile our contracts, we get an ABI file, and this weird binary thing that numbers and letters stuff that gets when we deploy a contract that gets sent in the data field of our contract creation transaction.

13700
22:45:37.818 --> 22:45:47.979
So for contract creations, the data is populated with that binary code for function calls is going to define which functions to call in with what parameters and this is what we're gonna go over next.

13701
22:45:47.979 --> 22:45:54.394
Now, we learned that we can actually encode stuff into this binary into this low level code.

13702
22:45:54.394 --> 22:46:07.818
And any program any process that can read this low level stuff and execute accordingly, read this EVM stuff, read the specific binary that Aetherium has specified, or the EVM has specified is considered EVM.

13703
22:46:07.818 --> 22:46:08.632
compatible.

13704
22:46:08.632 --> 22:46:14.468
We can encode numbers, we can encode strings, we can encode pretty much anything we want to encode.

13705
22:46:14.468 --> 22:46:25.750
To save space, we do encode packed, we can decode stuff that we've encoded, but we can't decode stuff that we encode packed, we can multi encode stuff, and then multi decode stuff.

13706
22:46:25.750 --> 22:46:33.676
And then finally, we can use this call function and add data in here to make any call that we want to any smart contract.

13707
22:46:33.676 --> 22:46:35.723
And this is what we're going to learn next.

13708
22:46:35.819 --> 22:46:39.751
Alright, so now's a great time to take a break, because we just learned some really difficult concepts.

13709
22:46:39.751 --> 22:46:44.345
And like I said, if you don't get it the first time, that is okay.

13710
22:46:44.345 --> 22:46:47.432
Alright, welcome back.

13711
22:46:47.432 --> 22:47:07.996
Now that we've learned about this encoding stuff, let's learn how we can populate this parenthesis this data field, so we can call any function and we can do essentially, what the blockchain is going to do at the low level, we can work with just that binary, we can work with just that bytes, we can work with that hex to interact with our smart contracts.

13712
22:47:07.996 --> 22:47:09.474
So let's create a new file.

13713
22:47:09.474 --> 22:47:15.752
And we're gonna call it call anything, that's all start off with spdx, license identifier, MIT.

13714
22:47:15.752 --> 22:47:17.287
And let's talk about this.

13715
22:47:17.287 --> 22:47:28.115
Now in order to call now in order to call a function using only the data field of the call, we need to encode the function name, and the parameters that we want to add, right, because when we call a function, we call the function name.

13716
22:47:28.115 --> 22:47:30.115
And we call the parameters.

13717
22:47:30.115 --> 22:47:39.930
So we need to encode these down to the binary level so that the EVM, or these Aetherium based smart contracts and solidity stuff can understand what's actually going on.

13718
22:47:39.930 --> 22:47:51.369
In order to do this, we're going to need to work with two concepts to encode the function name so that the EVM or solidity can understand it, we actually have to grab something called the function selector.

13719
22:47:51.369 --> 22:47:56.019
Now the function selector is going to be the first four bytes of the function signature.

13720
22:47:56.019 --> 22:48:00.786
And the function signature is just going to be a string, which defines the function name of parameter.

13721
22:48:00.819 --> 22:48:07.270
Now, what does this actually mean? Well, if we have a transfer function, this right here is known as the function signature.

13722
22:48:07.270 --> 22:48:09.520
So the function name is going to be transfer.

13723
22:48:09.520 --> 22:48:22.992
And it's going to take an address and a un 256 as its inputs, if we encode this transfer function, and then we take the first four bytes of it, we get this, which refers to the function selector.

13724
22:48:22.992 --> 22:48:24.992
So that's how solidity knows.

13725
22:48:24.992 --> 22:48:35.328
So in the bytecode, in the binary code, this function selector is how slitting knows Oh, they're talking about the transfer function they want me to call the transfer function.

13726
22:48:35.328 --> 22:48:48.521
And this is one of the first things that we need to use call to call any function that we want, we need to get the function selector and we can get it a number of different ways but one of the ways is by encoding the function signature and grabbing the first four bytes.

13727
22:48:48.521 --> 22:48:54.070
So we'll create this contract we'll do pragma solidity zero point 8.

13728
22:48:54.070 --> 22:48:57.177
7 Say contract, call anything.

13729
22:48:57.177 --> 22:49:10.320
And we'll give this to stored variables, give the to stored variables and address public s, underscore some amount, or some address, and then you in 256, public s underscore mount.

13730
22:49:10.320 --> 22:49:13.241
And then we'll create a function called transfer function transfer.

13731
22:49:13.241 --> 22:49:27.336
Now normally in here, we would actually do like transfer for like an ERC 20 transfer, but we're just going to do address some address, and then you add 256 amount, amount here, we'll make this a public function.

13732
22:49:27.336 --> 22:49:34.070
And then all we'll do is we'll set S, some address equals some address, and then s amount equals amount.

13733
22:49:34.070 --> 22:49:37.820
So here's gonna be the function that we're going to work with.

13734
22:49:37.820 --> 22:49:42.968
And the function selector for that function is this, the function signature is this.

13735
22:49:42.968 --> 22:49:49.368
So it takes an address some address amount, that gets boiled down to the function selector, and the function signature.

13736
22:49:49.368 --> 22:49:55.476
And of course, in our bytecode, there's going to be some code saying, Okay, here's what this function does, blah, blah, blah.

13737
22:49:55.476 --> 22:49:58.402
So we can actually even write a function to get that function selector.

13738
22:49:58.402 --> 22:50:06.852
So we can say, function, get selector and I'm gonna say get selector one, because I'm gonna show you a few ways to get the function selector, we'll make this a public pure.

13739
22:50:06.852 --> 22:50:25.691
And we'll have this return a bytes for selector, we could say select or equals bytes for, and then we hash with a check to 56 of the bytes of that signature, which is transfer.

13740
22:50:25.821 --> 22:50:29.545
And it takes an address and a UNT 56.

13741
22:50:31.821 --> 22:50:38.227
this, and then we run it, let's get rid of our old contract, deploy, make sure we're on call anything, if you have the other one up.

13742
22:50:38.227 --> 22:50:47.725
In here, now we have a couple of things, we hit Get selector one, we get this Oh X, a 905, blah, blah, blah, right.

13743
22:50:47.821 --> 22:50:49.493
And that's the same as the example I just gave.

13744
22:50:49.821 --> 22:51:04.337
right here tells solidity tells our smart contract, okay, when we make a call to this contract, if you see this in the function data, this is referring to our transfer function with an address and a un 256 as input parameter.

13745
22:51:04.337 --> 22:51:06.280
So we see address you into 56.

13746
22:51:06.280 --> 22:51:09.230
Our function knows to execute this data here.

13747
22:51:09.230 --> 22:51:09.623
Great.

13748
22:51:09.821 --> 22:51:12.221
And then of course, sml, and S address are zeros.

13749
22:51:12.821 --> 22:51:21.288
we're here, we can also see, okay, what happens if we call the transfer function, right? It takes an address and an amount, so let's just give it its own address or an address.

13750
22:51:21.288 --> 22:51:23.132
And we'll do 777 for an amount.

13751
22:51:23.132 --> 22:51:28.768
If we hit transfer, we have the log up, right, we'll get a little checkmark here saying success.

13752
22:51:28.822 --> 22:51:31.355
Now, if we hit S amount, we'll get 777.

13753
22:51:32.822 --> 22:51:35.383
will be the same, right? So that's us directly calling transfer.

13754
22:51:35.383 --> 22:51:43.789
When we directly call transfer, we're basically saying, hey, grab this function selector, and then do some other stuff, which we'll we'll tell you the other stuff in a minute.

13755
22:51:43.822 --> 22:51:45.558
Now we have the function selector.

13756
22:51:45.558 --> 22:51:46.189
Okay, great.

13757
22:51:46.822 --> 22:51:49.628
do we need, we also now need the parameters we want to add.

13758
22:51:49.822 --> 22:51:55.388
we're going to need to encode those parameters with our function selector.

13759
22:51:55.388 --> 22:52:00.640
So what we're gonna do is we're gonna say function, get data to call transfer.

13760
22:52:00.640 --> 22:52:14.644
And in here, we're just going to have this get data to call transfer, we're going to have it take these input parameters, and we're going to encode these to work with our function selector, we're gonna say address, some address.

13761
22:52:14.644 --> 22:52:22.640
And if it is x, amount, public pure returns, bytes memory.

13762
22:52:22.822 --> 22:52:27.822
And then we can return and use one of those ABI and codings from the cheat sheet.

13763
22:52:27.822 --> 22:52:31.676
Now, so far, we've just been doing API and code for a lot of our encoding.

13764
22:52:31.676 --> 22:52:38.222
So it since we have the function selector, we can actually do ABI dot encode with selector.

13765
22:52:38.222 --> 22:52:43.516
This ABI encodes the given arguments starting from the second and prepends, the given four byte selector.

13766
22:52:43.516 --> 22:52:49.063
When we do in Cobra selector, we're just sticking our selector onto the data that we're going to give it.

13767
22:52:49.063 --> 22:52:54.408
So we're going to do return API dot encode with select door.

13768
22:52:54.408 --> 22:53:04.357
And we're going to pass it the result of get selector one, and then we're going to give it some address, and amount.

13769
22:53:04.357 --> 22:53:18.203
So what this is going to do, it's gonna give us all the data that we need to put in that data field of our transaction, to send to this contract to let this contract know, hey, go use the transfer function, pass in some address, and then an amount.

13770
22:53:18.203 --> 22:53:34.177
And then if we compile this, we run it, let's delete our old contract, we'll deploy up, we now got a new function called Get Data to call and transfer, we'll just pass you know, we'll just pass this contract address and then we'll also do 777 again.

13771
22:53:34.177 --> 22:53:42.661
And so this thing right here is what we're going to put into the data field of our transaction in order for us to call transfer from anywhere.

13772
22:53:42.661 --> 22:53:51.623
So this is the bytes This is the binary encoded data of Hey, call the transfer function with this address that we specified.

13773
22:53:51.623 --> 22:53:53.156
with, you know, 777 Mt.

13774
22:53:53.156 --> 22:54:00.823
So what we can do once we have all this, we can actually call our transfer function without even having to directly call it.

13775
22:54:00.823 --> 22:54:18.117
So what we can do is we can say function, call transfer function directly, or I guess with binary might be a better title, but you get the gist, we'll say address some address, you in 256 amount, we'll make this a public function.

13776
22:54:18.117 --> 22:54:21.244
And we'll have a returns a bytes four and a bool.

13777
22:54:21.244 --> 22:54:23.353
You'll see why in a minute.

13778
22:54:23.353 --> 22:54:28.161
And we'll do that same call thing that we did to send our raffle money.

13779
22:54:28.161 --> 22:54:33.937
So what we'll do is, before we did recent winner dot call, right, we're going to do some address.

13780
22:54:33.937 --> 22:54:37.073
And then for us, we're going to address this dot call.

13781
22:54:37.073 --> 22:54:49.774
And then we're saying this contracts address which we could put any address here address dot call, and we're going to call the encoded data that points us to the transfer function with some parameters.

13782
22:54:49.774 --> 22:54:52.004
So we're going to do address this.

13783
22:54:52.004 --> 22:54:52.200
com.

13784
22:54:52.200 --> 22:55:00.574
And we could just do get data to call transfer address amounts, right, we could do it like this.

13785
22:55:00.574 --> 22:55:03.044
Or we could do it kind of the wrong way.

13786
22:55:03.044 --> 22:55:11.193
We could do ABI dot and code with select dorm, get selector one, comma, some address, comma amount.

13787
22:55:11.193 --> 22:55:14.146
And actually, there's no semicolon there, sorry.

13788
22:55:14.146 --> 22:55:16.372
So those are going to be the same.

13789
22:55:16.372 --> 22:55:22.352
And this dot call thing, right, it's going to return exactly what we saw before, it's going to return a bool success.

13790
22:55:22.352 --> 22:55:32.098
So whether or not the transaction was successful, and then bytes, memory, returned data, which is going to be you know, whatever the call returns.

13791
22:55:32.098 --> 22:55:35.350
So right, and this is where we put like require success, right.

13792
22:55:35.350 --> 22:55:42.013
But for us, we're just going to return bytes, four bytes for a return datum, and then success.

13793
22:55:42.013 --> 22:55:47.146
So we're just going to return the first four bytes of whatever data we get returned.

13794
22:55:47.146 --> 22:55:49.690
And then we're going to return whether this was successful or not.

13795
22:55:49.690 --> 22:56:01.760
So this function is going to have us directly call the transfer function by passing these parameters without us having to do like contract dot transfer, or, or transfer whatever, right.

13796
22:56:01.824 --> 22:56:08.157
And you can do this across multiple contracts across different contracts, just by changing the address that you call on.

13797
22:56:08.157 --> 22:56:09.823
So let's go ahead and compile this.

13798
22:56:09.823 --> 22:56:13.582
We'll run this now we'll delete our old contract, we'll deploy call anything.

13799
22:56:13.582 --> 22:56:14.908
Now if we if we were.

13800
22:56:14.908 --> 22:56:18.109
So right now sml, and estimators are both zero.

13801
22:56:18.109 --> 22:56:26.735
Now, if we do call transfer function directly, and we'll pass in this one's address, and then we'll do 777.

13802
22:56:26.825 --> 22:56:33.491
Now, if we pull up the logs, we hit this, we're gonna get this transaction response here.

13803
22:56:33.491 --> 22:56:42.200
But if we scroll down, we'll ever see the decoded output, which is a bytes for of just a bunch of zeros, right? Because our transfer doesn't actually return anything.

13804
22:56:42.200 --> 22:56:47.028
So it's just gonna be a whole bunch of zeros, and then our Boolean true, which means it was successful.

13805
22:56:47.028 --> 22:56:51.758
So since it was successful, these two should have changed based off of that.

13806
22:56:51.825 --> 22:56:53.497
So let's go ahead and try them out.

13807
22:56:54.825 --> 22:56:55.792
they're changed.

13808
22:56:58.825 --> 22:57:05.750
function without having to call the transfer function itself, we can also do encode with signature instead of selector.

13809
22:57:05.825 --> 22:57:20.934
So if we go to our cheat sheet, there's also this encode with signature down here, which takes the string memory signature, and it's equivalent to doing ABI dot encode with selector bytes for CAC bytes, you know, signature, it's, it's equivalent to doing exactly what we did up here.

13810
22:57:20.934 --> 22:57:23.199
But it does this step for us.

13811
22:57:23.199 --> 22:57:39.753
So we could copy this whole thing, paste it down here, right, and we could do, instead of encoded with selector, we can do encode with SIG netshare, the function signature, and then we'll copy our function signature from up here, paste that in here.

13812
22:57:39.825 --> 22:57:51.857
Compile, we ran into a compilation error, up, these are the same call transfer function directly SIG, called that compile, leader, old contract, deploy.

13813
22:57:51.857 --> 22:57:54.375
Now these two are both zeros again.

13814
22:57:54.375 --> 22:57:58.954
Now if we copy the contract address, we do call contract call transfer function directly SIG.

13815
22:57:58.954 --> 22:58:05.761
We paste that in here, we do 777, we call it, let me check these we can see that that does the exact same thing.

13816
22:58:05.761 --> 22:58:08.316
So this is API dot encode with signature.

13817
22:58:08.316 --> 22:58:10.061
This is abi dot encode selector.

13818
22:58:10.061 --> 22:58:13.873
Encode with signature just turns us into the selector for us.

13819
22:58:13.873 --> 22:58:17.235
That's all up here, we just, we encoded this selector ourselves.

13820
22:58:17.235 --> 22:58:20.580
Now, there are a whole bunch of different ways to get the selectors.

13821
22:58:20.580 --> 22:58:22.283
And we're not going to code these out ourselves.

13822
22:58:22.283 --> 22:58:27.747
I'm just gonna say a bunch of different ways to get selector.

13823
22:58:27.747 --> 22:58:35.626
And who knows why why you might want to use one of these other reasons, right? There's there's a ton of reasons why you might want to get the selector a different way.

13824
22:58:35.626 --> 22:58:43.404
And here's some now in this video, we're not going to explain or go over all these different all these different function selector getting methods.

13825
22:58:43.404 --> 22:58:48.995
But if you go through them in the GitHub repo associated with this course, they all have a ton of comments to explain what they're doing.

13826
22:58:48.995 --> 22:58:55.645
Well, we are going to show you though, it's actually how to contracts can interact with each other without actually having all the code for each contract.

13827
22:58:55.645 --> 22:59:04.219
So we're going to make a second contract that has all this binary this byte information to call the transfer function on a different contract.

13828
22:59:04.219 --> 22:59:06.333
And we're gonna show you how that can work.

13829
22:59:06.333 --> 22:59:10.342
This is just another contract that I've made called call function without contract.

13830
22:59:10.342 --> 22:59:41.629
Actually, down here, we're going to call the transfer function, just by using the address and the function selector signature and stuff, we're going to update these storage variables in our call anything contract from another contract just by doing this binary calling, if you will, right, so let's compile, it's going to deploy, we can actually leave this up right, we can leave this up is let's deploy our call function without contract, we'll pass it as an input parameter, the call anything contract address, we'll deploy it.

13831
22:59:41.629 --> 22:59:54.679
Now in here, I can call the transfer function directly by you know, maybe I'll switch it to this, this contract address this new contract address, and we'll give it a new number of 123.

13832
22:59:54.679 --> 22:59:57.695
Right, and we'll click call transfer function.

13833
22:59:57.827 --> 23:00:01.093
And then when we go back up here, we see that this has indeed been updated.

13834
23:00:01.093 --> 23:00:04.284
Now doing this call stuff is considered low level.

13835
23:00:04.284 --> 23:00:07.160
And it's a best practice to try to avoid it when you can.

13836
23:00:07.160 --> 23:00:10.318
So if you can import an interface, it's much better to do it like that.

13837
23:00:10.318 --> 23:00:16.646
Because you're going to have the compiler on your side, you're going to be able to check to see if your types are matching and all this other stuff.

13838
23:00:16.646 --> 23:00:24.827
So usually doing these low level calls some security auditor checkers might say, hey, like this books been out a little bit, you doing this low level stuff.

13839
23:00:24.827 --> 23:00:29.810
But with that being said, You have just learned a ton about lower level solidity.

13840
23:00:29.810 --> 23:00:31.531
This is some really advanced stuff.

13841
23:00:31.531 --> 23:00:41.663
And like I said, if this was hard, if you're kind of confused here, don't worry, you can always come back to this section and try it again, when you're a little bit more advanced, if you want to try to understand it all now.

13842
23:00:41.663 --> 23:00:42.187
Awesome.

13843
23:00:42.187 --> 23:00:57.536
Absolutely, we've left some links in the GitHub repo associated with this lesson that I definitely recommend you check out one of the ones you should definitely check out, it's going to be this deconstructing solidity by openzeppelin, it really breaks down exactly what's going on behind the scenes of a contract.

13844
23:00:57.536 --> 23:01:05.730
If you want to learn more about opcodes, about low level stuff, definitely give this a read, it is a phenomenal read, essentially, it breaks down a little bit more than what we went over here.

13845
23:01:05.730 --> 23:01:07.665
A couple other videos as well.

13846
23:01:07.665 --> 23:01:10.303
And I've left a whole bunch of links in here too.

13847
23:01:10.303 --> 23:01:18.239
With that being said, here we are back in our NFT.

13848
23:01:18.239 --> 23:01:27.448
And now we know all about this ABI dot encoding stuff, right and what it does, and we know that ABI dot encode packed, the way we're using here is just a way to concatenate strings.

13849
23:01:27.448 --> 23:01:33.643
And we're not using ABI dot encode for really any of its crazy superpowers, but we might in the later section of this course.

13850
23:01:33.643 --> 23:01:47.177
In other case, so we do use this base 64 dot encode thing that we've imported, right, we imported this base 64 dot encode so that we can encode our SVG that we pass it in to its base 64 encoding.

13851
23:01:47.177 --> 23:01:49.565
I'm going to copy paste an example here, you don't have to do this.

13852
23:01:49.565 --> 23:02:06.387
But like, for example, we'll pass it in like SVG width equals blah, blah, blah, all this SVG stuff, kind of similar to what I was showing you before, we pass that in as an input parameter here, and output it, we're gonna get the base 64 encoding of it, we're gonna get this massive kind of string here.

13853
23:02:06.387 --> 23:02:09.150
We will test this later to make sure that this works.

13854
23:02:09.150 --> 23:02:13.957
Normally, if I added a function in like this right now, I probably would test it right away.

13855
23:02:13.957 --> 23:02:15.336
For now we can just leave it in here.

13856
23:02:15.336 --> 23:02:18.086
That's going to be great for getting this image here.

13857
23:02:18.086 --> 23:02:22.935
But we don't want just an image, right? We were going to need that metadata.

13858
23:02:22.935 --> 23:02:34.680
We need this to be a JSON object, not just an image URL like this, we need stick this image, this base 64 encoded image into this image field of our JSON.

13859
23:02:34.680 --> 23:02:49.090
So how do we actually do this? Well, what we can do is we know that our ERC 721 code comes with a token URI, and it's that token URI that points to this, which tells us what our code is going to look like.

13860
23:02:49.090 --> 23:02:57.128
So what we can do is we can actually base 64 encode our JSON as well, to turn into a JSON token URI.

13861
23:02:57.128 --> 23:03:03.021
So we basically four encoded this image to get this, we're going to stick this URL into our JSON.

13862
23:03:03.021 --> 23:03:09.579
And then we're going to base 64 encode our JSON, and that's going to be the URI that our token uses.

13863
23:03:09.579 --> 23:03:12.844
So we have our function, token URI, right.

13864
23:03:12.844 --> 23:03:23.540
And this takes a un 256 token ID, we'll say it's going to be a public view, public view override, and it returns a string memory.

13865
23:03:23.540 --> 23:03:30.695
So we're going to override the token URI function of the ERC 721 to whatever we want it to be.

13866
23:03:30.695 --> 23:03:45.162
And here we're going to encode some JSON text that we give our contract into a base 64 based JSON token URI just to get started we'll do a require underscore exists.

13867
23:03:45.162 --> 23:03:52.283
Token ID, and then I'm just gonna say your I query for non existent token.

13868
23:03:52.283 --> 23:03:57.863
And yeah, this price should be an if not exists, Revert with an error.

13869
23:03:57.863 --> 23:04:00.216
However, we're just going to go like this.

13870
23:04:00.216 --> 23:04:04.764
And this exists function comes in my ear C 721.

13871
23:04:04.764 --> 23:04:06.729
So we're going to do same thing here.

13872
23:04:06.729 --> 23:04:08.568
So we're gonna say require this token, a D exists.

13873
23:04:08.568 --> 23:04:09.872
And again, we can 100 percent.

13874
23:04:09.872 --> 23:04:22.047
And probably should make this an IF EXISTS token, ID, you know, now what we want to do is we want to figure out how to make this token URI return a base 64 encoded version of this JSON.

13875
23:04:22.047 --> 23:04:28.151
So first, we know how to how to concatenate a string, right, so that's gonna be the first thing that we're going to do.

13876
23:04:28.151 --> 23:04:30.000
So we'll do API dot and code packed.

13877
23:04:30.000 --> 23:04:42.392
And we're going to encode ourselves the JSON on chain, we're going to use single quotes here, because inside of this API and code packed, we're going to use double quotes in here is where we're going to add our JSON.

13878
23:04:42.392 --> 23:04:47.563
So we'll give a name, right, so the first piece of metadata needs to be a name.

13879
23:04:47.563 --> 23:04:49.417
So we'll give it a name.

13880
23:04:49.417 --> 23:04:51.559
And we'll put a comma here.

13881
23:04:51.559 --> 23:05:00.030
And we'll say the name of this NF T is going to be the name we get from, we have a name function, which returns the name.

13882
23:05:00.030 --> 23:05:02.071
So we're gonna say the name is going to be the name.

13883
23:05:02.071 --> 23:05:05.145
And we're gonna just concatenate all this stuff, name right there.

13884
23:05:05.145 --> 23:05:07.417
We're gonna continue on with the JSON.

13885
23:05:07.417 --> 23:05:11.022
So we put a little quote here, and a little quote here.

13886
23:05:11.022 --> 23:05:22.088
So we encapsulate this name in quotes, right? Because remember, we're, we're concatenating, this big string that we're making here, we'll do a comma, we'll say, description, we'll do another quote.

13887
23:05:22.088 --> 23:05:42.655
And this time, we're just going to put the description ourselves, and we'll say, and NFT, that changes, based on the chain link feed, we'll put an end quote here and a comma, and we'll put a comma outside the quote, down here, we'll say, attributes.

13888
23:05:42.830 --> 23:05:52.387
We'll just say, trait type, it's going to be coolness.

13889
23:05:53.830 --> 23:05:55.480
value, me 100.

13890
23:05:55.480 --> 23:05:58.781
Boom, to a comma to image.

13891
23:06:01.830 --> 23:06:02.110
here.

13892
23:06:05.830 --> 23:06:08.636
image URI, which we're going to have to get from somewhere.

13893
23:06:08.830 --> 23:06:12.718
for now, I'm just gonna say, string.

13894
23:06:12.830 --> 23:06:17.263
Memory image URI equals i, right, which clearly isn't an image arrived.

13895
23:06:17.263 --> 23:06:19.846
But just to make this format and stuff, we'll we'll put this there.

13896
23:06:19.846 --> 23:06:25.414
This is where we're going to put that image URI that we get from SVG to image URI.

13897
23:06:25.414 --> 23:06:26.989
And then that's it.

13898
23:06:26.989 --> 23:06:29.766
I mean, close off our JSON, though.

13899
23:06:29.766 --> 23:06:34.210
So doing ABI dot encode pack is going to concatenate this all together.

13900
23:06:34.210 --> 23:06:37.259
So this is basically going to be a string that looks like this.

13901
23:06:37.259 --> 23:06:37.544
Great.

13902
23:06:37.544 --> 23:06:46.798
But how do we turn this into a base 64 encoded token you arrive so that other people can read it is we're going to typecast this whole thing to bytes.

13903
23:06:46.798 --> 23:06:54.363
And then now that this whole thing is in bytes, we can do exactly what we did with the SVG above is now we can base 64 encoded.

13904
23:06:54.363 --> 23:06:56.943
So we'll do base 64, dot ENCODE.

13905
23:06:56.943 --> 23:07:01.749
And then we'll just put another pair of parentheses around this save and auto formatted.

13906
23:07:01.749 --> 23:07:10.584
And this here is going to give us this second line, right, it's going to give us all of this bit, but it's not going to give us this first bit, right.

13907
23:07:10.584 --> 23:07:12.847
So we just need to append to this first bit now.

13908
23:07:12.847 --> 23:07:14.201
And we should be good to go.

13909
23:07:14.201 --> 23:07:26.798
For basics before data image SVG plus XML basics, the form, this is the prefix for images for SVG images, right? We use that above because that's the prefix for SVG images.

13910
23:07:26.798 --> 23:07:28.003
The prefix for base 64.

13911
23:07:28.003 --> 23:07:33.581
Jason is going to be it's going to be data application JSON base 64.

13912
23:07:33.581 --> 23:07:36.206
So we're going to do it like this instead.

13913
23:07:36.206 --> 23:07:42.492
Now the ERC 721 has something called a base URI that we're going to override and that we're going to use.

13914
23:07:42.492 --> 23:07:45.468
So we're gonna say function underscore base URI.

13915
23:07:45.468 --> 23:07:47.795
This will be internal pure.

13916
23:07:47.795 --> 23:07:50.896
And we're going to override the one that ERC 721 has.

13917
23:07:50.896 --> 23:07:54.307
And this is going to returns a string memory.

13918
23:07:54.307 --> 23:07:58.997
And we're just going to return this bit right here.

13919
23:07:58.997 --> 23:08:01.747
And now we can use this base URI.

13920
23:08:01.747 --> 23:08:07.848
to append, right, we're going to append this first part to our base 64 encoded JSON.

13921
23:08:07.848 --> 23:08:15.110
So in order to append them, once again, we'll do ABI dot ENCODE, packed.

13922
23:08:15.110 --> 23:08:19.569
And then we'll put this down here.

13923
23:08:19.832 --> 23:08:25.170
And we'll say, we're going to, we're going to concatenate base URI to this massive thing that we just created.

13924
23:08:25.170 --> 23:08:31.181
And then we save and we ought to format the now this is obviously a bytes object, and we want it to be a string.

13925
23:08:31.181 --> 23:08:48.139
So then all we got to do is typecast it as a string, but another prints see down here, and then we can actually just return this, but basically what we're doing is we're creating a JSON string, we encode it in bytes, that way we can encode it in base 64.

13926
23:08:48.139 --> 23:08:58.225
Once we have encoded in base 64, which is going to look like this second string, it's gonna look like here out, we then just append this initial part.

13927
23:08:58.225 --> 23:09:03.044
But for JSON objects, it's data application JSON.

13928
23:09:03.044 --> 23:09:09.882
We we append that we do API dot encode packed, and then cast it to string and then boom, we now have a token URI.

13929
23:09:09.882 --> 23:09:11.454
That'll look something like this.

13930
23:09:11.454 --> 23:09:19.635
And then all we have to do is update our image URI with what we get from our function appear, and then we'll be good to go.

13931
23:09:19.635 --> 23:09:23.323
So let's finish this out.

13932
23:09:23.323 --> 23:09:25.388
Let's do this.

13933
23:09:25.832 --> 23:09:29.979
So in our constructor, we're passing a low SVG and a high SVG.

13934
23:09:29.979 --> 23:09:39.159
And what are these low SVG is in these high SVG as well, basically saying, when the price of this asset is too low, show a frown.

13935
23:09:39.159 --> 23:09:43.098
And when the price of the asset is high, show a smiley face.

13936
23:09:43.098 --> 23:09:51.483
So we're gonna give it this frown, SVG, and this happy SVG as input parameters, low CG and high SVG, we probably want to save those.

13937
23:09:51.483 --> 23:09:55.306
But we don't necessarily want to save them in like their SVG format.

13938
23:09:55.306 --> 23:10:02.445
So we just want to store the image URI, right, we will just want to store this string up here instead of the actual SVG.

13939
23:10:02.445 --> 23:10:17.409
So right in our constructor, we can do I underscore low image URI equals, and we have this SVG to image your eye function, where we can pass the low SVG.

13940
23:10:17.409 --> 23:10:22.095
And then we can do the same thing for the high image URI.

13941
23:10:22.095 --> 23:10:26.770
So now, SVG image URI is going to return something that looks like this.

13942
23:10:26.833 --> 23:10:31.155
And we're going to store just this string this image URI on chain.

13943
23:10:31.155 --> 23:10:35.110
Now that we have the two of those, we can use that down below.

13944
23:10:35.110 --> 23:10:46.751
In our token, Uri function, when somebody calls token, your I have token ID zero, we're going to stick into our JSON, either the low image or I or the high image arrive.

13945
23:10:46.833 --> 23:10:49.196
And we're actually going to base that off of the channeling price feed.

13946
23:10:49.196 --> 23:10:55.062
So how do we do that? Well, we've already worked with channeling price feeds before so let's go ahead and add it.

13947
23:10:55.062 --> 23:10:58.236
So yarn add dash dash dev at chain link slash contracts.

13948
23:10:58.236 --> 23:11:07.942
Once that's done at the top, we can do import at chain link slash contracts, slash SRC slash V 0.

13949
23:11:07.942 --> 23:11:16.478
8, slash interfaces, slash ag reg gate, Tor V three interface, that soul like so.

13950
23:11:16.478 --> 23:11:20.639
And then down here, let's comment this out.

13951
23:11:20.833 --> 23:11:27.352
For now, we're going to want to call a price feed to figure out what the price is and then show the high image or the low image based off that.

13952
23:11:27.352 --> 23:11:32.963
So in order to get a price feed in our constructor, let's just add another price feed address, street address.

13953
23:11:32.963 --> 23:11:35.946
And then we'll make another variable.

13954
23:11:35.946 --> 23:11:40.994
We'll do aggregate Tor v3 interface.

13955
23:11:40.994 --> 23:11:46.146
Internal, immutable, I underscore price feed.

13956
23:11:46.146 --> 23:11:57.300
And we'll say in our constructor, I price feed equals aggregate Tor v3 interface at price feed, address.

13957
23:11:57.300 --> 23:12:09.749
And then what we can do down here, the old bunch of commas in here into 256 Price comma, comma comma equals i price feed that latest round data.

13958
23:12:09.749 --> 23:12:22.096
And what we can do is we can say if price is greater than or equal to some value, then show one image dry otherwise, show another one.

13959
23:12:22.096 --> 23:12:30.199
So we can say String memory, image URI equals s underscore low image URI.

13960
23:12:30.199 --> 23:12:39.255
And then if the price is higher than some value, well greater than the image URI we're going to use is going to be there's gonna be AI is going to equal the high image URI.

13961
23:12:39.255 --> 23:12:41.884
And then we have image right down here.

13962
23:12:41.884 --> 23:12:44.161
So all we got to do is figure out the price.

13963
23:12:44.161 --> 23:12:51.990
So we can make, and in our mind, we'll let the mentors choose the value that they want to use.

13964
23:12:51.990 --> 23:12:58.562
So we can say, into 256, I value and we'll assign each NFT, their own high value.

13965
23:12:58.562 --> 23:13:06.047
So we'll need to create like a little mapping up top, we'll say, mapping, you went to 56.

13966
23:13:06.047 --> 23:13:08.342
Two, you went to 56.

13967
23:13:08.342 --> 23:13:17.431
Let's just make this public for the heck of it public s underscore token ID to high value.

13968
23:13:17.431 --> 23:13:27.390
And we'll say that when they meant an NF T will do s token ID to high value, s underscore token counter.

13969
23:13:27.390 --> 23:13:30.167
We'll set that equal to high value.

13970
23:13:30.167 --> 23:13:33.851
So when they meant they choose the high value that they want.

13971
23:13:33.851 --> 23:13:42.763
And then down here we'll say if the price is greater than or equal to the high value of the token ID, then we'll use the high one.

13972
23:13:42.835 --> 23:13:44.028
Otherwise, we'll just use the low one.

13973
23:13:44.835 --> 23:13:47.496
be you into videos x two into 256.

13974
23:13:49.835 --> 23:13:52.286
be able to compare them pretty equally.

13975
23:13:53.835 --> 23:13:54.657
looks really good.

13976
23:13:56.835 --> 23:13:57.869
is probably an event.

13977
23:13:59.835 --> 23:14:03.597
in time we met to one of these NF T's.

13978
23:14:05.835 --> 23:14:12.235
created NF T, will say you went to 56 indexed token ID comma int 256.

13979
23:14:12.235 --> 23:14:14.368
I value like so.

13980
23:14:14.368 --> 23:14:25.735
And then when we met this NFT, will do emit create n t, s underscore token counter, comma, I value.

13981
23:14:25.835 --> 23:14:31.157
And then it's best practice to to have to update our token counter before we actually do the minting.

13982
23:14:31.157 --> 23:14:32.106
So we'll do that as well.

13983
23:14:32.106 --> 23:14:34.343
Okay, there's a ton of code here.

13984
23:14:34.343 --> 23:14:44.569
And like I said, we definitely would not have written all that code without having compiled to run some tests first, but we decided we want to just write it all right off first.

13985
23:14:44.569 --> 23:14:46.436
So and I did some misspellings.

13986
23:14:46.436 --> 23:14:48.736
Let's just make sure everything compiles here.

13987
23:14:48.836 --> 23:14:49.073
Awesome.

13988
23:14:49.073 --> 23:14:49.988
Everything's compiled here.

13989
23:14:50.836 --> 23:14:53.787
couple things that we're going to need to do to test this out.

13990
23:14:53.836 --> 23:15:03.398
First thing we're gonna need to do is write our deploy function, we've got our basic NFT, we've got our random and f t, both of these hosted on IPFS.

13991
23:15:03.398 --> 23:15:13.767
Now we're going to do a dynamic NFT that's hosted 100 percent on chain, and it changes based off the price of an asset.

13992
23:15:13.767 --> 23:15:17.870
So let's do this.

13993
23:15:17.870 --> 23:15:26.012
Oh, three, deploy dynamic, SVG nft.

13994
23:15:26.012 --> 23:15:26.129
js.

13995
23:15:26.129 --> 23:15:29.545
We are no, we're gonna need a little bit of boilerplate.

13996
23:15:29.545 --> 23:15:31.415
So let's go to our basic NFT.

13997
23:15:31.415 --> 23:15:35.196
And we'll just grab all this the first seven lines or so.

13998
23:15:35.196 --> 23:15:37.224
And we'll just paste it in here.

13999
23:15:37.224 --> 23:15:44.042
What do we need for our constructor? Well, we need a price feed address, a low SVG and a highest CG.

14000
23:15:44.042 --> 23:15:45.867
Okay, so let's get all of those.

14001
23:15:45.867 --> 23:15:48.853
So price feed address is something we've already done before.

14002
23:15:48.853 --> 23:15:51.836
And we can add that into our helper Hardhead config.

14003
23:15:51.836 --> 23:15:56.986
And we'll do one and a foreign local, we're going to use what we're going to use a mock.

14004
23:15:56.986 --> 23:16:00.302
And if we're on Rinkeby, or an actual network, we're going to use an actual address.

14005
23:16:00.302 --> 23:16:07.066
So let's go ahead to dark side chain that link will grab a price feed address, the M Aetherium.

14006
23:16:07.066 --> 23:16:19.463
data feeds will go to rank B, rank B and let's just use eath USD copy that will make a new entry eath USD price feed like so.

14007
23:16:19.463 --> 23:16:22.153
And for localhost, we're good.

14008
23:16:22.153 --> 23:16:24.649
So since we know for localhost, we're going to need to do a mock.

14009
23:16:24.649 --> 23:16:27.293
Let's see if we have a price feed mock.

14010
23:16:27.293 --> 23:16:31.646
Okay, now we don't, we're gonna need a mock v3 aggregator dot soul.

14011
23:16:31.646 --> 23:16:32.949
I just copied pasted mine.

14012
23:16:32.949 --> 23:16:36.037
If you want, you can just go right to the to a repo here.

14013
23:16:36.037 --> 23:16:47.989
Or you can copy from a previous section, just a reminder heart at f and f t FCC contracts asked moc v3 aggregator and this is using point 06 of solidity.

14014
23:16:47.989 --> 23:16:53.043
So we're going to want to make sure that in our hard hat dot config, we have at least one 0.

14015
23:16:53.043 --> 23:16:55.709
6 version, which we do so we're good there.

14016
23:16:55.837 --> 23:17:21.423
That means in our deploy mocks, we're going to want to add So initial price will be 2000 decimals will be a team.

14017
23:17:21.423 --> 23:17:24.087
So now we've waited to deploy mocks for that price feed.

14018
23:17:24.087 --> 23:18:12.599
So we're gonna say const chain ID equals network dot config dot chain Id do if development chains dot includes network dot name, and the more we need to import development chains looks like where did say const eth USD akregator equals we'll get that price feed equals awaits ethers dot get contract Mark v3 Air gate tour, and then we'll up here we'll do let eath USD price feed address eath USD price feed address equals eath USD aggregate tore that address else will say the eath USD price feed address is going to be equal to what we find in the network config.

14019
23:18:12.599 --> 23:18:14.503
Network config.

14020
23:18:14.503 --> 23:18:17.931
Chain ID dot eth USD price.

14021
23:18:17.931 --> 23:18:22.549
Okay, so we have the eth USD price feed rate.

14022
23:18:22.549 --> 23:18:25.870
Now we need the lowest VG and the high SVG.

14023
23:18:25.870 --> 23:18:30.380
So we're going to create a new folder in our images folder.

14024
23:18:30.380 --> 23:18:35.125
So we go CD images, MK dir dynamic NF t.

14025
23:18:35.125 --> 23:18:40.647
And now we'll have two folders in here dynamic which is empty and random, which has all the random stuff.

14026
23:18:40.647 --> 23:18:43.893
If you want to use your own SVGs for this, you absolutely can.

14027
23:18:43.893 --> 23:18:50.991
But if you want to just come to my images file and then save these images as so just come right click Save image as.

14028
23:18:50.991 --> 23:18:51.606
Save them.

14029
23:18:51.606 --> 23:18:55.231
and then drag and drop them into your images files here, you can absolutely do that.

14030
23:18:55.231 --> 23:19:03.041
So now that we have those, we want to go ahead and read those into our script here.

14031
23:19:03.041 --> 23:19:06.504
We'll say const, low SVG equals a weight.

14032
23:19:06.504 --> 23:19:09.170
And we're going to use Fs again.

14033
23:19:09.170 --> 23:19:28.596
So we're gonna do const Fs equals require Fs, or do await Fs dot read file sync, we're going to read in this file, which for me, it's at dot slash images slash dynamic NF T slash brown dot SVG.

14034
23:19:28.596 --> 23:19:32.450
And we're using encoding of UTF eight.

14035
23:19:32.450 --> 23:19:34.869
And then we'll say const.

14036
23:19:34.869 --> 23:19:39.355
Hi, SVG equals await Fs dot read file sync.

14037
23:19:39.355 --> 23:19:43.597
Copy this whole thing, because we're using the same stuff.

14038
23:19:43.597 --> 23:19:46.089
This one's going to be happy about SVG.

14039
23:19:46.089 --> 23:19:47.255
And that's it.

14040
23:19:47.255 --> 23:19:53.275
So when price is good, we're gonna do happiness, SVG, when price is bad, we're gonna do frown at SVG.

14041
23:19:53.275 --> 23:19:55.484
Now, let's go ahead and let's deploy this contract.

14042
23:19:55.484 --> 23:20:04.454
So we'll say arguments or args equals, it's gonna be the price feed address, low SVG, and then high SVG.

14043
23:20:04.454 --> 23:20:21.699
And we'll say const, dynamic S, G and F T equals await, deploy dynamic SVG and f t, comma little bracket here, from Deployer.

14044
23:20:21.839 --> 23:20:24.553
args, args log true.

14045
23:20:29.839 --> 23:20:44.117
going to be network dot config, that block confirmations, or one will do some logging, I will do log to do that.

14046
23:20:44.117 --> 23:20:52.068
But Larry, do some verification, I'm actually just going to copy paste that from our last script, because it's going to be exactly the same copy paste.

14047
23:20:52.068 --> 23:20:57.008
But instead of random IPFS, it's going to be dynamic SVG and f t.

14048
23:20:57.008 --> 23:20:58.731
The rest of this looks good.

14049
23:20:58.731 --> 23:21:00.666
And that's just about it.

14050
23:21:00.666 --> 23:21:09.461
So we'll do module, exports dot tags, equals and we'll do all dynamic.

14051
23:21:09.461 --> 23:21:09.985
SVG.

14052
23:21:09.985 --> 23:21:12.345
And we'll do main.

14053
23:21:12.345 --> 23:21:13.525
Oh, okay.

14054
23:21:13.525 --> 23:21:19.516
Let's try to see if our deploy script that we just created works.

14055
23:21:19.516 --> 23:21:28.697
To do h h, or yarn hardhat deployed dash dash tags, die Namic SVG, that makes sense, because we didn't deploy the mocks.

14056
23:21:28.697 --> 23:21:31.128
So we'll do tags, dynamic SVGs.

14057
23:21:31.128 --> 23:21:33.161
And then also the mocks.

14058
23:21:33.161 --> 23:21:39.743
Local network detected play marks, we deploy the marks, deploying dynamic SVG, awesome.

14059
23:21:39.743 --> 23:21:48.340
You know what comes next? You Gosh, darn right, it's time for some tests.

14060
23:21:48.340 --> 23:21:58.323
Now, once again, I'm going to encourage you to pause the video now and try to write your own test for this test for this section actually can be a little bit tricky.

14061
23:21:58.323 --> 23:22:05.373
Since we are going to be manipulating the price of our mock aggregator, we are checking for these long strings, and such.

14062
23:22:05.373 --> 23:22:10.772
So be sure to use the GitHub repository associated with this lesson, in case you get lost.

14063
23:22:10.772 --> 23:22:18.036
Now, I want to show you what this looks like on a marketplace, like OpenCL.

14064
23:22:18.036 --> 23:22:21.033
So we are going to deploy this to rink B.

14065
23:22:21.033 --> 23:22:23.219
Now keep in mind test that can be slow.

14066
23:22:23.219 --> 23:22:24.494
So you might want to be patient here.

14067
23:22:24.494 --> 23:22:26.949
And you don't even have to do it if you don't want to.

14068
23:22:26.949 --> 23:22:28.390
But it is kind of nice to see.

14069
23:22:28.390 --> 23:22:30.340
Okay, that's what it really looks like.

14070
23:22:30.340 --> 23:22:33.220
And you can go to the contract on chain once it's verified.

14071
23:22:33.220 --> 23:22:35.040
And you can read the token URI and everything.

14072
23:22:35.040 --> 23:22:35.767
And it's pretty fun.

14073
23:22:35.840 --> 23:22:39.952
So let's just add one more bit to our deploy folder.

14074
23:22:40.840 --> 23:22:44.430
a mint script that just emits an NF T for each one of these contracts.

14075
23:22:44.430 --> 23:22:46.856
So we're going to create no for mint.

14076
23:22:46.856 --> 23:22:46.987
js.

14077
23:22:46.987 --> 23:22:52.275
And we're just going to have each one of these contracts mint NFT.

14078
23:22:52.275 --> 23:22:54.658
Let's go ahead and do this.

14079
23:22:54.658 --> 23:23:00.840
So in here, we'll do const ethers network equals require arhat.

14080
23:23:00.840 --> 23:23:04.808
And then I'm going to do a little copy paste in.

14081
23:23:04.808 --> 23:23:08.774
I'm just going to copy this part because I know I'm going to need that.

14082
23:23:08.774 --> 23:23:12.660
We are going to need a deploy but we're not going to need to deploy.

14083
23:23:12.660 --> 23:23:17.095
So I'll grab get named accounts, get named accounts, it's going to come right from there.

14084
23:23:17.095 --> 23:23:18.213
So we have a Deployer.

14085
23:23:18.213 --> 23:23:20.691
Our deployer is just gonna be used to mint them.

14086
23:23:20.691 --> 23:23:22.291
First we'll mint the basic NF t.

14087
23:23:22.291 --> 23:23:31.983
So we'll say const basic NF t equals wait ethers dot get contract, basic N ft, and we'll connect the deployer to it.

14088
23:23:31.983 --> 23:23:41.737
And then we'll say const basic mint and if T or basic mint, TX equals await basic NF T dot mint NF t.

14089
23:23:41.737 --> 23:24:00.856
And then we'll do a weight basic mint, TX dot weight one and then we'll do a little console dot log base Again, T index zero has token URI, we'll put in a little await basic NF T dot token URI of zero.

14090
23:24:00.856 --> 23:24:03.541
That's it for the basic entity.

14091
23:24:03.541 --> 23:24:08.091
Now we'll do our random IPFS and empty.

14092
23:24:08.091 --> 23:24:21.441
So we'll say const, random IPFS NF t equals await ethers dot get contract, random IPFS and f t, connected to the Deployer.

14093
23:24:21.441 --> 23:24:23.912
This one, we need a mint fee.

14094
23:24:23.912 --> 23:24:29.502
So we'll say const, mint V equals await random IPFS NF T dot get mint fee.

14095
23:24:29.502 --> 23:24:31.679
And then we'll do the mint.

14096
23:24:31.841 --> 23:24:42.779
So we'll say const, random IPFS and ft mint, TX equals await, random IPFS and F T dot request and F team.

14097
23:24:42.779 --> 23:24:47.681
And for this one, we need to pass a value, which is going to be the mint v.

14098
23:24:47.681 --> 23:24:48.432
to string.

14099
23:24:48.432 --> 23:25:04.648
Now for this one, just like what we saw in our tests, we're going to have to do this await new promise again, right, because we need to wait for it to return need to listen for those events, we probably should set up the listener first.

14100
23:25:04.648 --> 23:25:06.270
So let's actually set up the listener first.

14101
23:25:06.270 --> 23:25:11.757
So we're going to do await new promise, and we're gonna do async function.

14102
23:25:11.842 --> 23:25:14.745
And we're going to do resolve reject.

14103
23:25:16.842 --> 23:25:19.772
that, that fun little arrow syntax in here.

14104
23:25:19.842 --> 23:25:36.175
And now since we're in this function here, we actually set the timeout resolve like this, which means we have five minutes to time this out, you might want to bump this up even more five minutes might not be enough, this is gonna be 300 milliseconds here, we're gonna do that once again.

14105
23:25:36.175 --> 23:25:39.252
So we'll say random IPFS and ft dot once.

14106
23:25:39.252 --> 23:25:46.719
Once we get that NFT minted event, we're going to run an async function, we're just gonna do resolve.

14107
23:25:46.719 --> 23:25:53.334
And inside here is where we can actually put, actually requesting the NFT.

14108
23:25:53.334 --> 23:26:04.925
But below our listener, right, so in there, and then we can say if developments chains, that includes network dot name.

14109
23:26:04.925 --> 23:26:13.632
So let's just make sure we import those development chains and network or affect them and chains that includes network dot name.

14110
23:26:13.632 --> 23:26:17.648
So we're on a test net, this is where we go ahead and we pretend to be those mocks.

14111
23:26:17.648 --> 23:26:21.442
So we'll say const Request ID equals random IPFS.

14112
23:26:21.442 --> 23:26:33.053
Oh, actually, we're going to need to do const random IPFS and ft min TX receipt equals await on IPFS and empty minted TX dot weight one.

14113
23:26:33.053 --> 23:26:35.789
So we're gonna need to get the receipt.

14114
23:26:35.789 --> 23:26:39.499
And from the receipt, we can get the request ID.

14115
23:26:39.499 --> 23:26:43.112
That events one dot args dot request id.

14116
23:26:43.112 --> 23:26:44.254
to string.

14117
23:26:44.254 --> 23:26:47.936
And then we can do const VRF.

14118
23:26:47.936 --> 23:27:00.770
coordinator V to mock equals await ethers dot get contract, the RF coordinate for V to mock, connect this to the Deployer.

14119
23:27:00.843 --> 23:27:12.000
And then we'll do a wait the RF corded and a Tor V to mock that fulfill random words with Request ID, random IPFS.

14120
23:27:12.000 --> 23:27:26.504
And if T dot address, we can do console dot log random IPFS and have T index zero token URI to await random IP.

14121
23:27:26.504 --> 23:27:31.218
That's NF T dot token URI of zero.

14122
23:27:31.218 --> 23:27:36.343
Finally, we can do our dynamic SVG, NF t.

14123
23:27:36.343 --> 23:27:42.206
So we can say const, high high value equals ethers.

14124
23:27:42.206 --> 23:27:42.751
utils.

14125
23:27:42.751 --> 23:27:44.786
do parse ether here.

14126
23:27:44.786 --> 23:27:49.398
So we'll say 4000 $4,000 will be the high value.

14127
23:27:49.398 --> 23:27:51.175
We'll say const.

14128
23:27:51.175 --> 23:27:57.892
Dynamic SVG and f t equals await ethers dot get contract, dynamic.

14129
23:27:57.892 --> 23:28:20.719
SVG and a T will connect it to the deployer say const by Namic, s, B, G, and f t mint, TX equals await dynamic SVG and F T dot mint and f t i value to string then we'll just do wait.

14130
23:28:20.719 --> 23:28:23.094
This stat wait one.

14131
23:28:23.094 --> 23:28:27.674
And finally console dot log dynamic.

14132
23:28:27.674 --> 23:28:36.602
SVG NFT index zero token URI is going to be a weight dynamic.

14133
23:28:36.602 --> 23:28:41.392
SVG and ft dot token URI of zero.

14134
23:28:41.392 --> 23:28:43.544
Okay, I think that looks good.

14135
23:28:43.544 --> 23:28:44.677
Let's try this on a local network.

14136
23:28:44.677 --> 23:28:48.118
So we'll do yarn hard hat deploy.

14137
23:28:48.118 --> 23:28:53.876
And we'll run all those scripts It looks like everything worked.

14138
23:28:53.876 --> 23:29:01.360
So we have random, basic NFT index zero has a token year, I have this IPFS thing, random IPFS NFT.

14139
23:29:01.360 --> 23:29:03.037
index zero has this thing.

14140
23:29:03.037 --> 23:29:06.621
And then our SVG has this giant monstrosity, okay, perfect.

14141
23:29:06.621 --> 23:29:20.212
And then we can even check, right, we can even grab this IPFS hash, we go to our IPFS node, or if you installed IPFS in your browser, or you're working with Brave, we can just pop it right into our browsers and see what it looks like.

14142
23:29:20.212 --> 23:29:20.527
Right.

14143
23:29:20.527 --> 23:29:22.844
And then if I zoom in, and adorable St.

14144
23:29:22.844 --> 23:29:25.110
Bernard, with the image of the St.

14145
23:29:25.110 --> 23:29:27.377
Bernard, looking like that, this one's also gonna be St.

14146
23:29:27.377 --> 23:29:27.643
Bernard.

14147
23:29:27.643 --> 23:29:33.219
And then of course, are SVG, which we can also copy, paste, and boom, that looks great.

14148
23:29:33.219 --> 23:29:35.156
And then we can copy the image.

14149
23:29:35.156 --> 23:29:37.317
And it's a frowny face or shad.

14150
23:29:37.317 --> 23:29:38.159
But Awesome.

14151
23:29:38.159 --> 23:29:40.762
Okay, so it's working locally for us.

14152
23:29:40.762 --> 23:29:45.344
Now, let's go ahead and try to make this work on an actual test net.

14153
23:29:45.344 --> 23:29:49.145
So hopefully, our helper hard hat config is set up correctly.

14154
23:29:49.145 --> 23:29:56.980
And there's enough stuff in here where we need to make sure that we have a subscription ID, right, we're going to need to make sure we have a subscription ID.

14155
23:29:56.980 --> 23:30:03.304
And we shouldn't call the mint function, right, because we're going to need to add our consumer to the VRF.

14156
23:30:03.304 --> 23:30:08.120
Before we can actually meant so let me let's add some tags to our meant here.

14157
23:30:08.120 --> 23:30:18.921
So we'll do module dot exports, dot tags equals, and we'll say all comma meant a while ago, I said okay, let's add a main tag.

14158
23:30:18.921 --> 23:30:23.232
Now we're coming around to why we added this main tag here.

14159
23:30:23.232 --> 23:30:26.688
So what we want to do is want to deploy all of these contracts.

14160
23:30:26.688 --> 23:30:42.796
But before we finally meant for our IPFS one, we need to add that contract to our consumer, here's what we're gonna do, we're gonna run yarn, Hardhead, deploy dash dash network Rinkeby dash dash tags main.

14161
23:30:42.796 --> 23:30:53.673
Now, this won't meant any of our NF T's, okay, won't mean to any of our NF T's, it'll just deploy those contracts might just sit around and wait a little bit for these to actually deploy.

14162
23:30:53.673 --> 23:30:59.202
So this is a great time to go take a break, maybe go take a walk, get a sip of water, get a cup of coffee, whatever you want to do.

14163
23:30:59.202 --> 23:31:06.779
Yeah, once everything is deployed, then we can go to V or F dot chain dot link, we're already connected here, we used our subscription.

14164
23:31:06.845 --> 23:31:11.038
And then we would just add our IPFS consumer in here.

14165
23:31:11.845 --> 23:31:12.285
be good to go.

14166
23:31:13.845 --> 23:31:34.797
and we have all three of our transactions on the blockchain, we can go ahead, we can grab our random IPFS NF T, we'll grab that address, we'll come back over to V or F dot chain dot link slash rink D, we'll go to our subscription ID, and we'll add a new consumer will add that contract address.

14167
23:31:34.797 --> 23:31:37.297
So we'll go ahead and approve and Metamask.

14168
23:31:37.297 --> 23:31:42.158
And once this goes through, we can finish running the mint part of our deploy folder.

14169
23:31:42.158 --> 23:31:49.384
Once it's confirmed, we can close maybe we can do a little refresh, we should see our new address added as a subscription here.

14170
23:31:49.384 --> 23:32:00.157
Now that we've added that we can mint one NF T from each one of these contracts are in hard hats, deploy dash dash tags meant dash dash network Rinkeby.

14171
23:32:00.157 --> 23:32:03.338
And we'll have to wait a little bit for this too.

14172
23:32:03.338 --> 23:32:08.354
Okay, now that we have them all minted, we should get a little output like this.

14173
23:32:08.354 --> 23:32:11.168
Right? Basic NF t zero has token URI here.

14174
23:32:11.168 --> 23:32:14.958
Basic random IPFS NF T has token your eye here.

14175
23:32:14.958 --> 23:32:18.535
And then our SVG has this as a token year, right.

14176
23:32:18.535 --> 23:32:26.670
So what can we do now? Well, let me go grab, I'll grab my wallet address and stick it into Rinkeby ether scan.

14177
23:32:26.670 --> 23:32:30.620
And we can see we called mint request and mint again.

14178
23:32:30.620 --> 23:32:38.439
And we created three contracts, right, we created our basic NFT, our random IPFS NFT and our dynamic SVG NFT.

14179
23:32:38.439 --> 23:32:44.354
What we can do now is we can grab, we can copy the address of our contract.

14180
23:32:44.354 --> 23:32:54.136
And we can go to test nets that open see that i Oh, and we can put that address in the bar here in the search bar here.

14181
23:32:54.136 --> 23:32:57.699
Now this part is incredibly, incredibly variable.

14182
23:32:57.846 --> 23:32:59.753
Okay, open C can be really slow.

14183
23:33:01.846 --> 23:33:06.373
couple of hours to register that a contract has been deployed to a test net.

14184
23:33:06.373 --> 23:33:09.397
So if it doesn't show up right away, don't be discouraged.

14185
23:33:09.397 --> 23:33:10.747
Don't let it drag you down.

14186
23:33:10.747 --> 23:33:16.659
But if it does, you should be able to click on your collection and see the NFT is actually here.

14187
23:33:16.659 --> 23:33:19.034
I'm going to grab our random IPFS NFT.

14188
23:33:19.034 --> 23:33:21.159
Let's grab that contract address.

14189
23:33:21.159 --> 23:33:23.915
I'm going to grab that test net site open c.

14190
23:33:23.915 --> 23:33:24.052
io.

14191
23:33:24.052 --> 23:33:25.983
Paste that address in there.

14192
23:33:25.983 --> 23:33:33.535
And what do you know we do indeed see, random IPFS and f t, right and I've deployed a couple of them.

14193
23:33:33.535 --> 23:33:36.925
So this one's v two, and we have our adorable Shiva in you right here.

14194
23:33:36.925 --> 23:33:44.597
So this is what it looks like an open C now we can 100 percent verify that our code is good even if it doesn't show up on Open.

14195
23:33:44.597 --> 23:33:44.797
See.

14196
23:33:44.797 --> 23:33:47.513
If we go to the contract we go to read contract.

14197
23:33:47.513 --> 23:33:51.513
And then we go to token URI punch and zero here.

14198
23:33:51.513 --> 23:33:57.492
A query, grabbed this, stick it into our browsers, the JSON looks good.

14199
23:33:57.492 --> 23:33:59.298
So let's grab the image URI.

14200
23:33:59.298 --> 23:34:00.201
Paste that in.

14201
23:34:00.201 --> 23:34:04.275
And if we can see this here, that means that our code is good.

14202
23:34:04.275 --> 23:34:10.013
And you have successfully deployed a number of FFTs to the blockchain.

14203
23:34:10.013 --> 23:34:17.508
We have learned a massive amount in this course, this is definitely one of the most jam packed one.

14204
23:34:17.508 --> 23:34:18.543
And it's all about art.

14205
23:34:18.543 --> 23:34:23.750
Right? Isn't that crazy? Let's do a quick refresher of this entire course here.

14206
23:34:23.750 --> 23:34:33.513
So first off, we learned the basics of an NF T with our basic NF T dot Sol, we learn that these NF T's are based off of the ERC 721 standard.

14207
23:34:33.513 --> 23:34:38.137
And that just means they have functions like name, token, Uri, etc.

14208
23:34:38.137 --> 23:34:56.005
We learned that NF T's use this token URI to tell us what the token actually looks like a token, your eye will look something like this, it's going to be a name a description, it's going to have an image URL, which points to a different location for what the NFT actually looks like.

14209
23:34:56.005 --> 23:35:00.863
It'll have stuff like attributes, it can have stuff like attributes, and a few other tags.

14210
23:35:00.863 --> 23:35:03.466
This is known as the metadata of the NFT.

14211
23:35:03.466 --> 23:35:05.562
And this tells us about the NFT.

14212
23:35:05.562 --> 23:35:19.028
We can also have all that metadata on chain, of course, to customize it on chain, and make it look and grow and change and be interactive on chain, we learned more about IPFS, we actually wrote a script called upload to pinjarra.

14213
23:35:19.028 --> 23:35:31.768
js, where we can actually programmatically upload images and files to another IPFS pinning service for us, we can of course, always use our own IPFS nodes if we want.

14214
23:35:31.848 --> 23:35:34.493
Now this token URI can really be anything.

14215
23:35:35.848 --> 23:35:39.727
IPFS for our basic NFT and for our random NFT.

14216
23:35:40.848 --> 23:35:47.714
dynamic NFT, we actually hosted the token, you're right 100 percent On chain, so we didn't use IPFS.

14217
23:35:47.714 --> 23:36:08.562
And we made this dynamic where the token URI actually changes based off of the price of a changeling price feed in our random IPFS NFT, we gave our NFT a chance we gave different rarities to the different dogs so that we could create programmatically rare NF TS where our pug is super rare.

14218
23:36:08.562 --> 23:36:10.941
Our Shiva is sort of rare, and our St.

14219
23:36:10.941 --> 23:36:12.112
Bernard is pretty common.

14220
23:36:12.112 --> 23:36:14.733
So the fact that we got to ship it in you was awesome.

14221
23:36:14.733 --> 23:36:17.414
We did some amazing deployments, we wrote some tests.

14222
23:36:17.414 --> 23:36:25.038
Not only that, but we learned a lot about transactions, and how we can actually add whatever data we want to this data section.

14223
23:36:25.038 --> 23:36:40.776
And a little bit more about what our transactions look like, and how we can actually use functions, selectors and function signatures to be able to call anything, right and we learn more about ABI dot encoding, and encoding packed and all this binary stuff if you want it to go deep into that.

14224
23:36:40.776 --> 23:36:43.224
So this was an absolutely JAM PACKED session.

14225
23:36:43.224 --> 23:36:55.510
And you should be incredibly proud of yourself, especially with your little puppy that you can see on open sea or you can see directly on ether scan, or you can just look at it and IPFS and be really proud of what you've done.

14226
23:36:55.510 --> 23:36:59.009
But with that being said, huge congratulations on making this far.

14227
23:36:59.009 --> 23:37:12.525
Definitely definitely definitely take a break here, and we'll see you in the next one.

14228
23:37:12.849 --> 23:37:18.991
Okay, now we have less than fifth team, which is going to be our next JS NFT marketplace.

14229
23:37:18.991 --> 23:37:33.642
And if you finish this lesson, you are a web three full stack monster, this is going to be our most complicated front end using the web three stack and using a lot of really advanced web three, and blockchain tools.

14230
23:37:33.642 --> 23:37:38.134
So get really excited because we are going to learn a ton in this lesson.

14231
23:37:38.134 --> 23:37:41.610
Now there are actually three different repos associated with this lesson.

14232
23:37:41.610 --> 23:37:44.389
The first one is going to be our typical hard hat project.

14233
23:37:44.389 --> 23:37:52.949
For the back end, after the hard hat project, we actually have two repos both are going to be our front end repos, and they're going to be slightly different.

14234
23:37:52.949 --> 23:38:00.107
In this project, we're going to learn more about how events are so important and why events are so important, especially for off chain services.

14235
23:38:00.107 --> 23:38:07.392
And so we're actually going to look at two different ways to work with them, one using the mirallas, or a centralized database, and then one using the graph.

14236
23:38:07.392 --> 23:38:22.210
And the reason that I want to show both of these is that oftentimes, when people are looking to scale the projects, when people are looking to get things done really quickly, taking a more centralized approach can often be a little quicker, and you can sometimes add more functionality to your website.

14237
23:38:22.210 --> 23:38:24.688
And there's still a lot of protocols that have decentralized backends.

14238
23:38:24.688 --> 23:38:26.568
And centralized front ends.

14239
23:38:26.568 --> 23:38:33.787
One such example, is open sea, open sea, for example, has the ability to actually like different and fts.

14240
23:38:33.850 --> 23:38:37.172
Now, this isn't something that we would actually want to spend any gas on.

14241
23:38:37.172 --> 23:38:42.968
But it is something that we're gonna have to store in some type of database somewhere, so that people have the ability to do that.

14242
23:38:42.968 --> 23:38:49.209
So I want to show you this optional first way to build these front ends, since all of our logic is still going to be 100 percent.

14243
23:38:49.209 --> 23:38:55.627
On chain, the front end matters a little bit less, because anybody can still interact with the contracts that we build on chain.

14244
23:38:55.627 --> 23:38:58.183
Now in web three, we don't want to stay there.

14245
23:38:58.183 --> 23:39:03.241
However, getting an MVP done getting a minimal viable project done is really, really important.

14246
23:39:03.241 --> 23:39:07.650
So using a centralized server, like Morales, or centralized project can make us much quicker.

14247
23:39:07.650 --> 23:39:13.006
In fact, we have been using centralized services, like alchemy, kind of throughout this whole project.

14248
23:39:13.006 --> 23:39:17.145
But of course, I also want to show you the decentralized way to make your front end.

14249
23:39:17.145 --> 23:39:22.357
So after we work with Morales, we're also going to show you how to use the graph then for to do all this event indexing.

14250
23:39:22.357 --> 23:39:28.146
Now the graph is going to be the decentralized way we can make our front end and work with these events.

14251
23:39:28.146 --> 23:39:30.550
And the graph also comes with its own graph repo.

14252
23:39:30.550 --> 23:39:33.833
So we'll learn all about that once we get to the front end section.

14253
23:39:33.833 --> 23:39:37.582
But let me show you what we're going to build because it is really cool.

14254
23:39:37.582 --> 23:39:42.250
Now that we've learned a ton about how to make NF T's what they are, we're going to make our own NFT marketplace.

14255
23:39:42.250 --> 23:39:47.083
And like I said, this is really going to be our deep dive into all these amazing front end tools.

14256
23:39:47.083 --> 23:39:49.576
So here's what our front end is gonna look like.

14257
23:39:49.576 --> 23:39:56.818
But what we can do is we can connect with our little connect button, we hit Metamask Metamask pops up, we'll go ahead and connect.

14258
23:39:56.818 --> 23:40:00.402
And now that we're connected, we can see the different entities in here.

14259
23:40:00.402 --> 23:40:04.689
And if we're on an address that's owned by us, it will say owned by you.

14260
23:40:04.689 --> 23:40:10.441
And if we switch addresses, or UI will go ahead and update, connect there.

14261
23:40:10.441 --> 23:40:12.719
And now we're owned by a different address.

14262
23:40:12.719 --> 23:40:15.678
Now, if it's owned by us, we get this little hover that says Update listing.

14263
23:40:15.678 --> 23:40:17.394
And right now it's worth 0.

14264
23:40:17.394 --> 23:40:17.534
18.

14265
23:40:17.534 --> 23:40:20.588
That's what it's listed for on our marketplace.

14266
23:40:20.588 --> 23:40:24.786
If it's owned by us, and we click it, we can update it to a different price.

14267
23:40:24.786 --> 23:40:32.251
Let's update it to 50 eath, or whatever your layer one currency is, we'll just say new listing price, we'll go ahead and confirm.

14268
23:40:32.251 --> 23:40:36.291
And I'll say listing updated, please refresh, and what we can do them.

14269
23:40:36.291 --> 23:40:42.051
And we'll mine some blocks on the back end, and boom, now we see that it's worth 50 here.

14270
23:40:42.051 --> 23:40:54.146
Now if we switch to a different account, now we can see owned by blah, blah, blah, and the hovered now says by me, if his selected as a different user, I'm gonna get this transaction to actually buy it.

14271
23:40:54.146 --> 23:40:57.368
Now go ahead and confirm that I'm gonna buy it, I get a little pop up.

14272
23:40:57.368 --> 23:40:58.741
This is item bought successfully.

14273
23:40:58.741 --> 23:41:06.883
Now if I do a little refresh, we'll now see that that NFT is gone from the marketplace, since we bought it right, it's no longer available to be sold.

14274
23:41:06.883 --> 23:41:14.800
Now what we can do then is we can come over to sell NF Ts and at the bottom, we'll see a withdraw proceeds.

14275
23:41:14.800 --> 23:41:22.574
So whenever somebody buys an NF T, the NFT marketplace actually keeps the proceeds that actually keeps the result of the sale.

14276
23:41:22.574 --> 23:41:31.816
So if we switch back to our address that had the NF T listed, we can now see Withdraw 50 proceeds because we know that we have 50 eath, because we just bought that for 50.

14277
23:41:31.816 --> 23:41:44.561
So if we hit withdraw, Metamask is gonna pop up, we can go ahead and confirm, wait a little bit as transaction populates, and boom once it goes through, we'll see now we have zero proceeds.

14278
23:41:44.561 --> 23:41:46.742
Right, we withdrew everything from here.

14279
23:41:46.852 --> 23:41:49.899
So what we can do now, is we can relist that NFT.

14280
23:41:50.852 --> 23:41:55.296
back, let's go back to the one who just bought that NF t.

14281
23:41:55.852 --> 23:42:13.400
know the address and the token ID of the NF t and we own it, we can go ahead and relist it, because we can place the address in here with the token ID Give us some sort of price, we'll submit, we'll approve giving the NFT marketplace access to our NFT to our little doggie.

14282
23:42:13.400 --> 23:42:23.544
And then we'll go ahead and actually send the transaction to actually list the NFT on a marketplace that we get NFT listed successfully.

14283
23:42:23.544 --> 23:42:27.802
After we remove some blocks in the back end, we can go back to the front end.

14284
23:42:27.852 --> 23:42:34.342
And we now see, it's owned by us, instead of the original owner, right and set for 10 ether.

14285
23:42:34.342 --> 23:42:40.004
And then we can of course, switch back to a different user, and we can have them actually buy.

14286
23:42:40.004 --> 23:42:51.452
So this is going to be a NFT marketplace that's completely decentralized, we are going to learn a ton about front end a ton about indexing a ton about events, and why they are so powerful.

14287
23:42:51.452 --> 23:42:54.118
And I'm really excited for you for this one.

14288
23:42:54.118 --> 23:43:01.759
Because if you get through this one, you will have so many tools at your fingertips for working with the blockchain.

14289
23:43:01.852 --> 23:43:03.658
Are you ready, let's jump in.

14290
23:43:05.852 --> 23:43:07.005
and then we'll build the front end.

14291
23:43:07.005 --> 23:43:07.479
Let's do this.

14292
23:43:07.853 --> 23:43:28.611
project is going to be based off the Arteon project, which is a completely open source decentralized smart contract NFT marketplace, I'll leave a link to it in the GitHub repo associated with this course, ours of course, is going to be a minimalistic version of this.

14293
23:43:28.853 --> 23:43:30.112
So we're in our VS code pre normal.

14294
23:43:30.853 --> 23:43:35.297
create a new folder here called hard hat.

14295
23:43:37.853 --> 23:43:42.885
FCC, oops, MK dir, like them, we're gonna cd into it.

14296
23:43:43.853 --> 23:43:46.098
open this up and its own VS code.

14297
23:43:47.853 --> 23:43:51.780
code period, or file open folder, and open this folder.

14298
23:43:52.853 --> 23:43:55.900
Once we get in here, we're going to do all of our normal stuff that we've been doing throughout the course.

14299
23:43:55.900 --> 23:44:10.567
And once again, if you want to copy paste over your package, JSON, if you want to copy paste in the modules, whatever you want to do, feel free to do so I'm gonna go ahead actually, this repo here, we're gonna scroll up and just grab once again, this line from less than nine.

14300
23:44:10.567 --> 23:44:21.984
And just run that I know I'm gonna be using prettier so I'm just gonna go ahead and copy paste those two prettier files over prettier ignore and prettier RC going to be using them again, for linting.

14301
23:44:21.984 --> 23:44:24.286
With solidity we're going to use Sol hint dot JSON.

14302
23:44:24.286 --> 23:44:26.170
So we're going to grab that dot soul hint dot JSON.

14303
23:44:26.170 --> 23:44:28.868
And the dots will hint dot ignore.

14304
23:44:28.868 --> 23:44:35.259
I'm also going to grab the hard hat dot config dot j s because we're going to be using a really, really similar setup.

14305
23:44:35.259 --> 23:44:37.071
And this hard hat dot config dot j s.

14306
23:44:37.071 --> 23:44:46.695
It's got waffle in it, ether scan, hard hat deploy coverage gas reporter sizer and Dottie and v dot config, we're going to bring over our Dotty and V.

14307
23:44:46.695 --> 23:44:49.604
And we're also gonna bring over our utils folder as well.

14308
23:44:49.604 --> 23:44:52.644
Right, so a lot of that boilerplate we're gonna bring on over.

14309
23:44:52.644 --> 23:45:03.624
And now just like that, since we have the hard hat dot config dot j s in here, if we run yarn, hard hat, right now, yarn hard hat will actually see we get the output like this.

14310
23:45:03.624 --> 23:45:04.804
So let's go ahead.

14311
23:45:04.804 --> 23:45:17.820
And before we actually write our contracts, let's go ahead and write a little doc saying what our contract is even going to do, what do we want this to do? We're going to create a decentralized NFT marketplace.

14312
23:45:17.820 --> 23:45:33.582
So what does that mean? What will we probably need? Well, we'll probably need some type of list item function, because we'll want to list NF T's and this will be to list NF t's on the marketplace, we'll need some type of buy item to buy the NF T's.

14313
23:45:33.582 --> 23:45:43.916
And then we'll probably need maybe like a cancel listing or cancel item, if you no longer want to sell it, maybe an update listing, update price.

14314
23:45:43.916 --> 23:45:51.001
And then maybe a withdraw proceeds to withdraw payment or my bot and fts.

14315
23:45:51.001 --> 23:45:57.803
So when somebody buys an NFT, I'm gonna have to withdraw it from the contract since the contract is going to be the one to actually hold those funds.

14316
23:45:57.803 --> 23:45:58.786
That looks pretty good to me.

14317
23:45:58.854 --> 23:46:00.854
Let's go ahead and start building this.

14318
23:46:01.854 --> 23:46:03.494
new folder, contracts.

14319
23:46:03.494 --> 23:46:05.447
And let's jump into this.

14320
23:46:06.854 --> 23:46:09.742
a new file NFT marketplace.

14321
23:46:09.854 --> 23:46:11.520
That's all.

14322
23:46:11.520 --> 23:46:16.353
So let's get our boilerplate.

14323
23:46:18.854 --> 23:46:22.501
solidity, carrot zero, point, 8.

14324
23:46:24.854 --> 23:46:26.319
Marketplace, boom.

14325
23:46:29.855 --> 23:46:35.315
or yarn Hardhead to compile or MPX, art, hit, compile, boom, things are looking good.

14326
23:46:35.315 --> 23:46:44.403
So if we go back to our readme, we can grab these here, even stick them in as like a little comment for us to kind of reference later on.

14327
23:46:44.403 --> 23:46:46.089
Let's start with listing the items.

14328
23:46:46.089 --> 23:46:48.760
How are we going to keep track of listing people's items.

14329
23:46:48.855 --> 23:46:55.387
And once again, remember, when I'm usually coding this, I'm going back and forth between writing tests and writing the actual code.

14330
23:46:55.387 --> 23:46:59.613
We're just going to write all the solidity in one chunk, and then go write the tests.

14331
23:46:59.613 --> 23:47:04.188
So we're going to say, these are going to be our main functions.

14332
23:47:04.188 --> 23:47:07.315
I'm going to start with function list item.

14333
23:47:07.315 --> 23:47:10.910
And we are going to make this one look really, really good.

14334
23:47:10.910 --> 23:47:12.521
So we're going to do natspec.

14335
23:47:12.521 --> 23:47:33.977
And everything, this is going to need to be an external function, right, we're probably not going to want any of our internal functions calling list item, it's going to be called by external projects or external accounts are probably going to need an address and ft address, write the address of the NFT, contract a un 256 token ID, the ID of the token ID of the contract that we're going to use.

14336
23:47:33.977 --> 23:47:36.113
And then we're going to want to set a un 256 price.

14337
23:47:36.113 --> 23:47:40.417
So first off, we're probably going to want the price to be greater than zero.

14338
23:47:40.417 --> 23:47:56.258
So maybe we'll put in like a little if or require statement here, we'll say if price is less than or equal to zero, then we'll go ahead and revert with a price must be above zero error.

14339
23:47:56.258 --> 23:48:02.820
And then of course, we'll prepend it with the name of the contract into underscores.

14340
23:48:02.820 --> 23:48:07.324
And then at the top, the error price must be above zero.

14341
23:48:07.324 --> 23:48:20.439
Now in order for us to list it, we could actually do this one of two ways we could one, we could send the NFT to the contract, this would require us doing like a transfer, right, we could have got the contract hold the NFT.

14342
23:48:20.439 --> 23:48:27.763
Now we could do this, but this is going to be kind of gas expensive for someone to actually list on f t.

14343
23:48:27.763 --> 23:48:32.363
And we can have the owner of the NFT be our NFT marketplace, we could 100 percent do that.

14344
23:48:32.363 --> 23:48:36.006
The issue with this, though is that the marketplace will then own the NFT.

14345
23:48:36.006 --> 23:48:54.669
And the user won't be able to say like, Hey, I own this NFT, it's in the marketplace, they technically would be able to but they would have to withdraw it, we might do this a slightly different way where we can say owners can still hold their NFT and give the marketplace approval to sell the NFT for them.

14346
23:48:54.669 --> 23:49:02.133
Now, of course the owners of the entity could withdraw approval at any time and the marketplace wouldn't be able to sell it anymore.

14347
23:49:02.133 --> 23:49:09.498
However, this would be really easy for people to actually read, they would all they would have to do is read like is approved for marketplace.

14348
23:49:09.498 --> 23:49:11.822
And they can actually see if the item was really listed or not.

14349
23:49:11.856 --> 23:49:16.793
So we're gonna go ahead and write it this second way, because that's what Ardian does.

14350
23:49:16.793 --> 23:49:30.218
And this is the least intrusive way to have this marketplace, right? People still will have ownership of their NF Ts, and the marketplace will just have approval to actually swap and sell their NF T once the prices are met.

14351
23:49:30.218 --> 23:49:36.396
So since we want to make sure the marketplace has approval, let's make sure the marketplace has approval.

14352
23:49:36.396 --> 23:49:45.856
So we can call we can call this get approved function on that token ID to make sure that the marketplace is approved to work with the NFT.

14353
23:49:45.856 --> 23:49:53.789
To do this, we're going to need the AI ERC 720 interface and we can actually grab that from open Zeppelin.

14354
23:49:53.857 --> 23:50:00.031
Right and this interface will wrap around an address and then we can call get approved on that address.

14355
23:50:00.031 --> 23:50:10.273
So we'll do import at open Zeppelin slash contracts slash token slash ERC 721 slash I ERC 721 dot Sol.

14356
23:50:10.273 --> 23:50:35.790
And since we're doing an import from open Zeppelin, we'll do yarn add dash dash Dev, add open Zeppelin now that we have this interface in here, what we can do is we'll say I ERC 721 NF t equals IRC 721 wrapped around this NF T address that we're passing in.

14357
23:50:35.790 --> 23:50:45.544
And we'll say if NF T dot get approved of the token ID that we're trying to list does not equal address this.

14358
23:50:45.544 --> 23:50:53.123
So if we are not approved, then we'll revert not approved or market place.

14359
23:50:53.123 --> 23:51:01.539
And then we'll of course we'll want to do prepend it with NFT marketplace into underscores.

14360
23:51:01.539 --> 23:51:13.020
So error like this, Bada bing bada boom, now that we've gotten a little bit of that out of the way, we're probably going to want to have some type of data structure to list all these NF T's.

14361
23:51:13.020 --> 23:51:36.876
And typically we get to Okay, do we want to use an array? Or do we want to use a mapping? What do you think? Before we continue? Let's pause for a second, do you think it makes more sense to put these NF T's and an array or an A mapping? And when you're thinking about this, try to think about, okay, well, people are gonna have to buy these and sell these, what makes more sense, think about this for a second, maybe pause it and write in a comment here, what you think an array or a mapping is better.

14362
23:51:36.876 --> 23:51:39.288
Now, if you said mapping, I would agree with you.

14363
23:51:39.288 --> 23:51:45.513
You couldn't do an array and you wouldn't necessarily be wrong, but it's not the way that I would go about that for an array.

14364
23:51:45.513 --> 23:51:53.202
Anytime someone wants to buy an item, we're gonna have to traverse through the array, we're gonna have to make this massive dynamic array.

14365
23:51:53.202 --> 23:51:56.996
And that might get a little bit dicey as that array gets really, really big.

14366
23:51:56.996 --> 23:51:59.211
So we're gonna go ahead and make this a mapping.

14367
23:51:59.211 --> 23:52:03.599
And this is probably going to be a global variable or a state variable.

14368
23:52:03.599 --> 23:52:09.781
So up at the top, let's go ahead and create this mapping, it's going to be a mapping of addresses of NFT addresses.

14369
23:52:09.858 --> 23:52:18.288
Right? So it's going to be the NFT contract address mapped to the NFT, token ID mapped to some type of listing.

14370
23:52:18.288 --> 23:52:24.451
So we'll say, a mapping of address to a mapping of UNT 256.

14371
23:52:24.451 --> 23:52:30.562
to, well, what do we want here? Well, we want we want the price, right? So is that another you went up to six.

14372
23:52:30.562 --> 23:52:36.406
But we also want, we also want to keep track of the sellers, we know who to send money to.

14373
23:52:36.406 --> 23:52:41.524
So we could make two mappings or we just create a new type of type listing, let's go ahead and do that.

14374
23:52:41.524 --> 23:52:43.072
We'll comment this out for now.

14375
23:52:43.072 --> 23:52:56.558
And so at the top, since this is going to be a type where, say, struct listing, and in here, we're going to do a utility six, the price of the NF t, and then address the seller of the NF team.

14376
23:52:56.558 --> 23:53:11.367
And now that we have that new typing, we can uncomment this, we can say NFT, contract address map to the NFT token ID mapped to the listing, and we'll make this a private variable called S underscore listings.

14377
23:53:11.367 --> 23:53:18.318
Now back down in our list item function, we're going to update that s listing mapping.

14378
23:53:18.318 --> 23:53:28.231
So we're gonna say s listing of NF T address, right, the address of the NF T at the token ID is going to equal we're gonna create a listing of the price.

14379
23:53:28.231 --> 23:53:36.792
And then who, well the seller is going to be message that sender, right? So message dot sender, they're the one who's actually listing the item.

14380
23:53:36.859 --> 23:53:50.303
And since we're updating a mapping here, what's the best practice for update mappings, you guessed it, we need to emit an event and especially for this project, you're gonna see why emitting events, for at least this project, this is so helpful.

14381
23:53:50.303 --> 23:53:56.059
So we're gonna go ahead and emit an item listed event, which we're going to create in just a second.

14382
23:53:56.059 --> 23:54:03.208
And we'll give the message that sender, the NFT address, the token ID, and the price item listed.

14383
23:54:03.208 --> 23:54:28.366
And then up at the top, of course, but below our structure, we're gonna say event item listed will do an address indexed seller address indexed NFT, address, address indexed token ID, and then a un 256 price.

14384
23:54:28.366 --> 23:54:32.826
Sorry, this needs to be a un 256 token ID, you int 56.

14385
23:54:32.826 --> 23:54:35.632
This looks pretty good to us.

14386
23:54:35.632 --> 23:54:41.732
However, we probably want to make sure we only list and FTEs that haven't already been listed.

14387
23:54:41.732 --> 23:54:44.747
So we can add like an if then in here.

14388
23:54:44.747 --> 23:54:47.532
And this is kind of where preference comes in a little bit.

14389
23:54:47.532 --> 23:54:51.579
But I'm actually going to create a modifier called not listed.

14390
23:54:51.579 --> 23:55:02.860
So we make sure we don't relist, and if T's that are already listed above our main functions, or do like a little indicator modifier not listed.

14391
23:55:02.860 --> 23:55:12.082
This is gonna take an an address NFT address, a un 256 token ID and an address owner.

14392
23:55:12.082 --> 23:55:25.066
And what we're going to say is we're going to check, we're going to make a new listing memory listing equals s underscore listings of NFT address token ID.

14393
23:55:25.066 --> 23:55:39.053
Now we're gonna say if listing dot price is greater than zero, we're gonna go ahead and revert with already passing the NFT address and a token ID.

14394
23:55:39.053 --> 23:55:46.029
And of course, we're going to prepend this with NFT marketplace.

14395
23:55:46.029 --> 23:55:52.405
And at the top, we do error ft marketplace already listed, like so.

14396
23:55:52.405 --> 23:56:02.026
And then we're going to put a little underscore right underneath and then up here, we'll do address and if the address you went to 56.

14397
23:56:02.026 --> 23:56:02.776
Okay, ID.

14398
23:56:02.776 --> 23:56:05.692
So this modifier looks pretty good.

14399
23:56:05.692 --> 23:56:11.237
Let's just make sure it's actually going to compile we'll do yarn Hardhead compile or hh compile.

14400
23:56:11.237 --> 23:56:11.630
Great.

14401
23:56:11.630 --> 23:56:12.679
That looks good.

14402
23:56:12.679 --> 23:56:21.110
We'll add this modifier to our list item function will do NFT address, token ID message dot sender.

14403
23:56:21.110 --> 23:56:21.526
Cool.

14404
23:56:21.526 --> 23:56:31.210
What else should we check for here? Well, we should also check that the NF T that's being listed is owned by message dot sender.

14405
23:56:31.210 --> 23:57:05.244
This way only the owners of the NF T can actually listed here so let's go ahead and we'll add a is owner modifier modifier is owner NFT address token ID spender you into 256 here and an address spender I ERC 721 NF t equals IRC 721 And if the address address owner equals NF T dot owner a Have a token ID.

14406
23:57:05.244 --> 23:57:10.500
And then we'll say if spender does not equal owner.

14407
23:57:10.500 --> 23:57:16.161
And we'll revert with a not owner error that we're going to go ahead and create up top.

14408
23:57:16.161 --> 23:57:18.488
So we'll say error, not owner.

14409
23:57:18.488 --> 23:57:40.344
And we'll prepend it with NFT marketplace with two underscores revert revert not owner, then will do underscore for the rest of the code, and boom, now underneath are not listed will do is owner NFT address, token ID message dot center.

14410
23:57:40.344 --> 23:57:49.572
So now our list item checks to see if it's already listed, make sure that only the owner of the NFT of that token, Id can list it.

14411
23:57:49.572 --> 23:57:52.254
And then it goes ahead and lists it looking nicely.

14412
23:57:52.254 --> 23:57:52.975
Okay, cool.

14413
23:57:52.975 --> 23:57:55.401
So that is our list item method here.

14414
23:57:55.401 --> 23:57:58.368
Now let's go ahead and do a little bit of natspec on this.

14415
23:57:58.368 --> 23:58:06.635
And now we have a little natspec here, which looks really professional.

14416
23:58:06.635 --> 23:58:07.602
Alright, great.

14417
23:58:07.602 --> 23:58:09.667
So we have a list item function.

14418
23:58:09.862 --> 23:58:16.433
All right, what's next? Well, maybe let's make a buy item function for people to buy their NF T's after they've been listed.

14419
23:58:16.433 --> 23:58:20.337
So let's create them do function by item.

14420
23:58:20.337 --> 23:58:30.747
So we'll take an address, and if the address un 256 token ID, and this will be an external function.

14421
23:58:30.747 --> 23:58:57.112
And that will also make this payable an external function because we know only people or contracts outside of this contract are going to call by item and payable so that people can spend eath to spend eath, or whatever layer one currency to actually buy these prices, we could want 100 percent at channeling prices in now for listing, we could of course, add price and then do like, you know address token price.

14422
23:58:57.112 --> 23:59:02.603
And do what we did before with chain link price feeds to convert the price of these tokens into how much they actually cost.

14423
23:59:02.603 --> 23:59:05.695
And we could 100 percent do that with chaining price feeds.

14424
23:59:05.695 --> 23:59:07.700
But for simplicity, we're gonna leave that off.

14425
23:59:07.700 --> 23:59:30.590
But I will put that as a challenge to you through challenge is going to be have this contract accept payment in a subset of tokens as well, of course, we would need to give a little hint here is channeling price feeds to convert the price of the tokens between each other, we're gonna choose which NFT in which token ID we want to buy.

14426
23:59:30.590 --> 23:59:36.671
So what's the first thing that we probably want to do? Well, we probably want to check that this by item is actually listed.

14427
23:59:36.671 --> 23:59:44.298
So we're actually going to make a new modifier instead of not listed we'll make it is listed up and modifiers modifier is listed.

14428
23:59:44.298 --> 23:59:50.418
And this is going to take an address and up the address un 256 token ID.

14429
23:59:50.418 --> 24:00:08.113
And to check to see if this is listed, we'll say listing memory listing equals s underscore listings of the NFT address of the token, Id sort of go into the mapping here.

14430
24:00:08.113 --> 24:00:10.738
And then we're just gonna check the price.

14431
24:00:10.738 --> 24:00:26.744
So we'll say if the listing that price is less than or equal to zero, so basically, if there's no price, if it's defaulted to zero, if the price is zero, then we're gonna say revert, not listed.

14432
24:00:26.863 --> 24:00:33.314
And after the address, token ID, and of course, we're going to prepend.

14433
24:00:33.314 --> 24:00:55.251
And if the marketplace and the marketplace underscore underscore, not listed, and then we're gonna copy this up here, we're gonna say air listed, and this is going to take address, NFT address, and au int 256 token Id like so, the down in our modifier, then we're going to add the underscore and to add the rest of our code here.

14434
24:00:55.251 --> 24:01:09.121
So now we have an is listed modifier, we're going to check to make sure that that NFT is actually listed down here now we're gonna say is listed address and ft address or excuse me, and if the address and token ID.

14435
24:01:09.121 --> 24:01:20.659
Now once again, we're gonna say listing memory listed item equals s underscore listings.

14436
24:01:20.659 --> 24:01:34.931
And if T address token ID, or say if message dot value is less than listed item dot price, then we're going to revert with price not met.

14437
24:01:34.931 --> 24:01:46.224
Then we'll do NFT address, Open ID listed item dot price Excel so we're going to create a new air price not met error.

14438
24:01:46.224 --> 24:01:52.654
Price not met of course we're going to prepend this with NFT marketplace to take an address.

14439
24:01:52.654 --> 24:02:00.355
And if the address you went to 56 token ID and then a UNT 256 price.

14440
24:02:00.355 --> 24:02:09.404
So we can see exe exactly how the price wasn't met, and then back down here, we'll get the full error.

14441
24:02:09.404 --> 24:02:12.489
So we want to make sure they're sending us enough money.

14442
24:02:12.489 --> 24:02:18.412
First of all, when they send this money, it needs to belong to whomever listed the item.

14443
24:02:18.412 --> 24:02:23.109
So we actually need to keep track of how much money these people have.

14444
24:02:23.109 --> 24:02:31.676
So let's create another data structure called proceeds where we keep track of how much money people have earned selling their NF T's.

14445
24:02:31.676 --> 24:02:37.264
So we'll create a mapping of address to you and 256.

14446
24:02:37.264 --> 24:02:45.208
And this is going to be a mapping of seller address to amount earned.

14447
24:02:45.208 --> 24:02:51.419
And we'll make this private called S underscore proceeds.

14448
24:02:51.419 --> 24:02:58.777
And what we'll do is when somebody buys an item, is will update their proceeds.

14449
24:02:58.864 --> 24:03:13.164
So we'll say as proceeds of listed item, that seller equals s proceeds of illicit IO dot seller plus MSG dot value.

14450
24:03:13.164 --> 24:03:18.324
Now, once we buy this item, we're going to want to delete the listing.

14451
24:03:18.324 --> 24:03:29.341
So to delete a mapping from a wreck, so to delete an entry and a mapping, we just use delete s underscore listings and ft address of the token ID.

14452
24:03:29.341 --> 24:03:31.817
So we remove that mapping.

14453
24:03:31.817 --> 24:03:35.115
And then finally, we're going to go ahead and transfer it.

14454
24:03:35.115 --> 24:03:50.566
So we'll say I ERC 721 and ft address, we're going to call dot transfer from the listed item dot seller to the message dot sender with the token ID.

14455
24:03:50.566 --> 24:03:56.477
Now you'll notice something here, we don't just send the seller the money.

14456
24:03:56.477 --> 24:04:01.058
Now why is that? Well, solidity has this concept called pull over push.

14457
24:04:01.058 --> 24:04:08.807
And it's considered a best practice when working with solidity, you want to shift the risk associated with transferring ether to the user.

14458
24:04:08.865 --> 24:04:24.541
So instead of sending the money to the user, this is what we don't want to do want to have them withdraw the money, we always want to shift the risk of working with money and working with eath or whatever layer one you're working with, to the actual user.

14459
24:04:24.541 --> 24:04:33.316
So we don't want to send them the money directly, we want to create this s proceeds data structure and we can have them withdraw from it later on.

14460
24:04:33.316 --> 24:04:35.896
Now, we could probably do some checking here.

14461
24:04:35.896 --> 24:04:41.316
Or we could say okay, check to make sure the NFT was transferred.

14462
24:04:41.316 --> 24:04:52.127
And if we look at I ERC 721 though, and we're looking at the transfer from function, we don't see it actually has a return.

14463
24:04:52.127 --> 24:05:01.167
And if we go to the IP 721 We can see that none of these have a return type though, transfer from doesn't have a return type here.

14464
24:05:01.167 --> 24:05:18.243
However, we do see this safe transfer from bit safe transfer from it's going to be a little bit better, right because if we look at transfer from transfers ownership of an entity, the caller is responsible to confirm that underscore two is capable of receiving entities or else they may be permanently lost.

14465
24:05:18.243 --> 24:05:27.421
So maybe instead we want to use safe transfer from which throws an error unless message sender is the current owner and authorize operator, or blah, blah, blah.

14466
24:05:27.421 --> 24:05:32.817
So instead of transfer from we're going to actually use safe transfer from just to be a little bit safer.

14467
24:05:32.866 --> 24:05:37.449
So we'll do safe transfer from instead of transfer from.

14468
24:05:37.866 --> 24:05:45.456
then since we're updating a mapping, we're going to do what, you guessed it, let's omit an event, we'll call item bot.

14469
24:05:45.456 --> 24:05:52.962
Lab will be a message that sender, an empty address, token ID and for listed item that price.

14470
24:05:52.962 --> 24:05:56.728
So off the top, let's create a new event.

14471
24:05:56.728 --> 24:06:00.348
To event item bought.

14472
24:06:00.348 --> 24:06:20.942
And this will be a an address indexed fire an address indexed NFT address an address indexed token ID and then a un 236 price.

14473
24:06:20.942 --> 24:06:23.966
Just kidding, that doesn't look fantastic.

14474
24:06:23.966 --> 24:06:25.416
This should be intuitive six.

14475
24:06:25.416 --> 24:06:27.481
Now it looks fantastic.

14476
24:06:27.481 --> 24:06:36.528
Now in this buy item, we've set this up in a way that is safe from something called a reentrancy attack.

14477
24:06:36.528 --> 24:06:41.104
And we've been coding these contracts in a way where we kind of do all this state change first.

14478
24:06:41.104 --> 24:06:44.588
And then we transfer the NFT that token or etc.

14479
24:06:44.588 --> 24:06:49.315
But why are we doing that? Cognitively we think it might make sense.

14480
24:06:49.315 --> 24:06:57.367
Okay, first, maybe we should actually send the NFT right, we'd want to send the entity first.

14481
24:06:57.867 --> 24:07:00.697
This is actually a huge security vulnerability.

14482
24:07:01.867 --> 24:07:06.496
why let's learn about one The most common hacks in blockchain, the reentrant.

14483
24:07:06.496 --> 24:07:07.028
See attack.

14484
24:07:07.028 --> 24:07:09.998
Now in this sub lesson, we're going to talk about reentrant.

14485
24:07:09.998 --> 24:07:16.033
C, and in the GitHub repo associated with this lesson, we're going to have the code for everything that we're going to go through here.

14486
24:07:16.033 --> 24:07:20.914
And the code that we're looking at is based off of this solidity by example.

14487
24:07:20.914 --> 24:07:21.707
reentrant.

14488
24:07:21.867 --> 24:07:22.467
See example.

14489
24:07:24.867 --> 24:07:25.798
associated with this course.

14490
24:07:26.867 --> 24:07:30.804
here, it's a place where you can deposit and withdraw your eath.

14491
24:07:30.867 --> 24:07:40.731
So what it does is it has a mapping called balances, where you can call deposit, and it'll update how much you've deposited into the protocol.

14492
24:07:40.731 --> 24:07:43.217
And then it has a withdrawal function as well.

14493
24:07:43.217 --> 24:07:50.818
So what it does is it first grabs your balance from this balances mapping, make sure that you have more than zero.

14494
24:07:50.867 --> 24:08:01.516
And then the way that we've been sending eath, this whole time, we do message that sender dot call, we send the balance, and then we update bounces of message sender equals zero.

14495
24:08:01.516 --> 24:08:05.375
Now this is the line that actually makes this contract incredibly vulnerable.

14496
24:08:05.375 --> 24:08:35.626
And if we run this right now, though, we'll say hey, no, it looks like it's working as expected, we can go to deploy a copy the accounts that I'm working with, like that in a bounce zero, we can deposit, you know, it's going away, let's go to ether, will deposit to ether, come down, what deposit now had to balance bounces up, we'll hit withdraw, now have bounces goes back to zero.

14497
24:08:35.626 --> 24:08:37.904
And it seems like it's working as intended.

14498
24:08:37.904 --> 24:08:44.786
Now, there's actually a way we can attack this function to drain all the money in this contract.

14499
24:08:44.868 --> 24:08:47.949
And this is what's known as a reentrancy attack.

14500
24:08:48.868 --> 24:08:55.257
common kinds of attacks in this space are going to be reentrancy attacks, which is what we're talking about here.

14501
24:08:55.257 --> 24:09:05.468
And Oracle attacks, which usually only happen when a protocol doesn't use the decentralized Oracle, lucky for you, we're teaching you right from the get go how to use chain link so that you can be protected.

14502
24:09:05.468 --> 24:09:18.461
And it's these two types of attacks that often result in the most amount of money last, there's a leaderboard called rec dot news, which keeps track of many of the top attacks that have ever happened in the defi space.

14503
24:09:18.461 --> 24:09:24.190
With many of them if you go into the retrospectives are either an Oracle attack or a reentrancy attack.

14504
24:09:24.190 --> 24:09:31.680
And you might be saying, Hey, where are we just talking about NF T's this, this doesn't have anything to do with NF T's we'll get there, don't worry.

14505
24:09:31.680 --> 24:09:37.037
In a new contract below, we're going to create a new contract called attack down here.

14506
24:09:37.037 --> 24:09:48.328
And what we'll do with this attack contract is we'll grab this reentrant vulnerable contract, we'll say reentrant, vulnerable, public reentrant vulnerable, like so.

14507
24:09:48.328 --> 24:09:53.386
And we'll save that reentrant vulnerable contract as a global variable.

14508
24:09:53.386 --> 24:10:00.835
And we'll say construct door address, underscore ranch and vulnerable address.

14509
24:10:00.835 --> 24:10:12.767
And then we'll say reentrant vulnerable equals rancher and vulnerable at reentrant vulnerable address.

14510
24:10:12.767 --> 24:10:17.885
Now what we're going to do is we're going to create a function called attack.

14511
24:10:17.885 --> 24:10:24.475
And it's this function that's going to call withdraw in a malicious way.

14512
24:10:24.475 --> 24:10:27.935
So we're going to say attack, this is going to be an external payable contract.

14513
24:10:27.935 --> 24:10:30.735
And we're going to call the posit on this.

14514
24:10:30.869 --> 24:10:32.636
So we'll deposit some money first.

14515
24:10:33.869 --> 24:10:40.369
vulnerable dot the posit will send a value of one ether.

14516
24:10:40.369 --> 24:10:47.344
And then immediately we will call re N Trent vulnerable dot withdraw.

14517
24:10:47.344 --> 24:10:51.794
Now at first glance, this seems pretty harmless.

14518
24:10:51.869 --> 24:11:01.223
But remember, when we call message dot call like this to send we're calling back to this this attack contract.

14519
24:11:01.223 --> 24:11:11.606
Now when we call this attack contract, is there a way to execute any other code? Well, there is remember how we learned about fallback functions.

14520
24:11:11.606 --> 24:11:16.546
If we put a fallback function in here or a receive function.

14521
24:11:16.546 --> 24:11:27.097
When this code runs call and seconds our contract ether we can have it trigger our fallback function to call withdraw again.

14522
24:11:27.097 --> 24:11:33.603
So that will send our contract more ether than it's do before we update the balance.

14523
24:11:33.603 --> 24:11:36.163
So let's see what this looks like.

14524
24:11:36.163 --> 24:11:57.209
So in our fallback here, we'll say if the address of reentrant vulnerable balance is greater than or equal to one ether aka we're saying if there's money left in the contract, then rancher invulnerable dot withdraw.

14525
24:11:57.209 --> 24:12:03.377
And then we'll put to get balanced function in our attacking contract.

14526
24:12:03.377 --> 24:12:07.394
We're going to attack reentrant vulnerable by calling withdraw.

14527
24:12:07.394 --> 24:12:15.588
When we get to this send section, what are we going to do, we're going to have our fallback function trigger calling withdraw again.

14528
24:12:15.588 --> 24:12:22.298
Now when we call withdraw again, bounces a message that sender hasn't been zeroed out yet.

14529
24:12:22.298 --> 24:12:26.801
So the contract code will go, oh, you still have some money here.

14530
24:12:26.870 --> 24:12:31.785
Let's go ahead and let's send you that, which will then again, trigger us to call withdraw.

14531
24:12:31.785 --> 24:12:34.509
And so we'll just keep calling withdraw until we're done.

14532
24:12:34.509 --> 24:12:36.738
So let's see what this looks like.

14533
24:12:36.870 --> 24:12:44.148
So we compile this, and then let's go to deploy, first, let's deploy the reentrant vulnerable contract.

14534
24:12:44.148 --> 24:12:55.484
Alright, and we can have any contract address, you know, like the one that deployed it, we can have a deposit, let's do, we have a deposit one ether deposit.

14535
24:12:55.484 --> 24:12:58.641
Now we can check the balances of it.

14536
24:12:58.641 --> 24:12:59.079
Copy.

14537
24:12:59.079 --> 24:13:01.547
Paste great, is one.

14538
24:13:01.547 --> 24:13:04.902
So now let's have a do 10.

14539
24:13:04.902 --> 24:13:08.226
Deposit, it took the balance.

14540
24:13:08.226 --> 24:13:09.954
And now we have this much in here.

14541
24:13:09.954 --> 24:13:11.513
So we have this much in here.

14542
24:13:11.513 --> 24:13:13.763
And if we withdrew, we withdraw all of it.

14543
24:13:13.871 --> 24:13:19.775
And if we switched accounts, to somebody else, we hit withdrew.

14544
24:13:19.871 --> 24:13:23.585
Nothing would happen because that other account doesn't have anything, which makes sense.

14545
24:13:23.585 --> 24:13:26.193
So there's a lot of money in here, right.

14546
24:13:26.193 --> 24:13:33.553
And if we do get balanced with the contract, we can see how much money it has, right? It has this much money total.

14547
24:13:33.553 --> 24:13:41.395
Now what we can do on a different account, let's choose this, this brand new account, let's go ahead and deploy the attack contract.

14548
24:13:41.395 --> 24:13:46.299
And we'll pass it the reentrant value address as an input parameter.

14549
24:13:46.299 --> 24:13:48.299
So we'll deploy that.

14550
24:13:48.299 --> 24:13:52.023
And now what we'll do is we'll call attack.

14551
24:13:52.023 --> 24:14:04.228
And you'll see even though this contract doesn't have anything deposited in the reentrant vulnerable contract, we will still steal all the funds in here or just about all the funds.

14552
24:14:04.228 --> 24:14:19.478
So right now hit get balance, and a reentrant vulnerable, here's what it is, get balance a here zero, you know, there's the address, we had attack now, now that get bounce, oh, excuse me in public, and withdrawal should be payable as well.

14553
24:14:19.478 --> 24:14:25.952
Now we'll pass one ether as an input parameter to our attack function, and we're going to deposit just one ether.

14554
24:14:25.952 --> 24:14:27.574
And then we're going to withdraw.

14555
24:14:27.574 --> 24:14:32.746
And we're going to keep withdrawing, because our fallback function is going to keep calling withdraw.

14556
24:14:32.746 --> 24:14:39.746
And all we had to do was deposit one ether, and we're gonna be able to pull out all 11 that are in here.

14557
24:14:39.871 --> 24:14:42.000
So we'll hit attack now.

14558
24:14:44.871 --> 24:14:54.226
new balance of our contract is 12, because the one that we deposited and then the 11 that we stole, and the new balance of our old contract is now zero.

14559
24:14:54.226 --> 24:14:55.774
So this is known as a reentrant.

14560
24:14:55.872 --> 24:14:56.561
See attack.

14561
24:14:59.872 --> 24:15:05.041
contract in the middle of our withdraw, we allow code to run on a different contract.

14562
24:15:05.041 --> 24:15:22.440
And the code that ran runs on this contract, recalls withdraw before balances is set to zero, we get to here we call the fallback function of our other code, and it calls withdraw, and we need to reread withdraw before we get to setting balances a message that sender equals zero.

14563
24:15:22.440 --> 24:15:24.043
So this is an issue, obviously.

14564
24:15:24.043 --> 24:15:26.216
And there are two ways we can prevent it.

14565
24:15:26.216 --> 24:15:27.302
There's the easy way.

14566
24:15:27.302 --> 24:15:31.568
And then the mutex way, I don't wanna say the hard way, it's just a different way.

14567
24:15:31.568 --> 24:15:41.760
So one of the things you'll always see in security tools is you always want to call any external contract as the last step in your function, or the last step in transaction.

14568
24:15:41.760 --> 24:16:00.581
And we want to update bounces to zero before we call that external contract, because of balances of message sender is reset to zero before we call external code, then if it were to try to re enter this, it would hit this require step and just cancel out right here and wouldn't be able to send any ether again.

14569
24:16:00.581 --> 24:16:03.161
So that's the first step that we can do.

14570
24:16:03.161 --> 24:16:06.821
The next step that we can do is using something called a mutex lock.

14571
24:16:06.872 --> 24:16:22.855
And this is what open Zeppelin does with one of the modifiers that they have, we can have some type of a Boolean called locked or something and just right at the top, we can just say require not locked.

14572
24:16:22.855 --> 24:16:24.625
Otherwise, revert.

14573
24:16:24.625 --> 24:16:30.983
And then the first thing we do in this contract is we can say locked equals true.

14574
24:16:30.983 --> 24:16:34.618
And then the last thing we do in here is we say locked equals false.

14575
24:16:34.618 --> 24:16:45.373
And using this lock in here, we only allow one piece of code to ever execute in here at a time and we only unlock it once the code finishes.

14576
24:16:45.373 --> 24:16:50.405
Now open Zeplin comes with a reentrancy guard which we can use on our code.

14577
24:16:50.405 --> 24:17:03.587
And it has a modifier non reentrant which does essentially what we were talking about with our locks it creates a variable called status and changes it to enter whenever a function has been entered.

14578
24:17:03.587 --> 24:17:07.794
It runs out code, and then changes it back to not entered when it's finishes.

14579
24:17:07.794 --> 24:17:11.050
And whenever any code runs, it just requires that it is not entered.

14580
24:17:11.050 --> 24:17:27.808
So if we wanted to use this on our code, we can import at open Zeppelin, slash, contracts, slash security, slash reentrancy.

14581
24:17:27.808 --> 24:17:35.922
Guard about so we can inherit the functions by saying NFT marketplace is reentrancy guard.

14582
24:17:35.922 --> 24:17:48.364
And then any function that we're nervous is going to have this reentrant see issue, like maybe by item, for example, we would just add the modifier non reentrant.

14583
24:17:48.364 --> 24:17:49.315
Just like that.

14584
24:17:49.315 --> 24:17:52.856
And that'll add that mutex, that locking mechanism that we talked about.

14585
24:17:52.856 --> 24:17:58.098
Now, the mutex way is a little bit more explicit with our security, right? Because we're saying, Hey, this is locked.

14586
24:17:58.098 --> 24:18:00.227
This is a non reentrant function.

14587
24:18:00.227 --> 24:18:09.440
Still a best practice, whenever you call external code, like what we see here is you do all of your state changes before you call an external contract.

14588
24:18:09.440 --> 24:18:11.159
Now, you might be saying, Oh, that's cool at all.

14589
24:18:11.159 --> 24:18:25.249
But what about how does this relate to our NF Ts? Well, imagine for a second, instead of message that sender dot call, this is, you know, all success equals, you know, some NF T dot transfer from, and then we do some transfers from stuff in here.

14590
24:18:25.249 --> 24:18:36.696
And instead of doing some fallback stuff, our NF T has our NF T's function transfer from the similis code to re enter into our withdraw.

14591
24:18:36.696 --> 24:18:41.670
If we have our withdrawal set up like this, since we're still calling an external contract with NFT.

14592
24:18:41.670 --> 24:18:48.284
To transfer from that transfer from in that external contract could be malicious and try to re enter our contract.

14593
24:18:48.284 --> 24:19:01.120
As a best practice, you always want to change your state, before you call any external contracts that you might not have control of, I highly recommend playing around with this a little bit just because seeing is believing.

14594
24:19:01.120 --> 24:19:09.606
And with that being said, again, all the code for this is going to be available in the GitHub sociated with this lesson for this reentrant vulnerable code.

14595
24:19:09.606 --> 24:19:15.737
And with that, let's go back to our NFT project.

14596
24:19:15.874 --> 24:19:34.749
Okay, so now we know why we're doing this safe transfer from at the bottom of our function here at the bottom of our bio, because if our safe transfer function from was a little bit higher, maybe what ends up happening is we send multiple NF T's to the wrong address before we update them.

14597
24:19:34.749 --> 24:19:36.207
So that's why we do that.

14598
24:19:36.207 --> 24:19:37.540
And we favor push over Paul.

14599
24:19:37.540 --> 24:19:43.818
As we said, Here, there's a whole lot of these security tips that you'll learn going on through this course and in solidity.

14600
24:19:43.818 --> 24:19:47.187
But this is still fantastic, right, we have our by item.

14601
24:19:47.187 --> 24:19:49.625
And we have our list item functions.

14602
24:19:49.625 --> 24:19:53.708
Let's do a cancel item now, or cancelled listing.

14603
24:19:53.875 --> 24:19:57.701
So we'll do a function.

14604
24:19:57.875 --> 24:20:02.350
Cancel listing we'll do the NFT address.

14605
24:20:04.875 --> 24:20:05.108
ID.

14606
24:20:05.108 --> 24:20:09.074
This will be an external function.

14607
24:20:11.875 --> 24:20:14.357
sure only the owner of this entity can cancel it.

14608
24:20:14.875 --> 24:20:17.644
say is owner.

14609
24:20:17.875 --> 24:20:23.125
And if T address, token ID message dot Sen.

14610
24:20:24.875 --> 24:20:27.925
sure that the NFT is actually listed.

14611
24:20:29.875 --> 24:20:32.675
and ft address, token ID.

14612
24:20:32.675 --> 24:20:33.841
And great.

14613
24:20:36.875 --> 24:20:46.366
we're going to do is we're going to delete s listings NFT address token ID, we're just going to delete that mapping.

14614
24:20:46.366 --> 24:20:56.255
And then we'll emit an event item cancelled message dot sender and if T address and token ID.

14615
24:20:56.255 --> 24:21:01.475
And of course, we're going to create a new event here.

14616
24:21:01.475 --> 24:21:04.475
We'll say event item canceled.

14617
24:21:04.475 --> 24:21:11.875
And it will be an address indexed seller address.

14618
24:21:11.875 --> 24:21:14.875
Index NFT address.

14619
24:21:14.875 --> 24:21:17.616
You want to 56 indexed token ID.

14620
24:21:17.616 --> 24:21:18.261
All right.

14621
24:21:18.261 --> 24:21:18.648
Great.

14622
24:21:18.648 --> 24:21:20.284
That was pretty quick.

14623
24:21:20.284 --> 24:21:21.677
Cancel listening.

14624
24:21:21.677 --> 24:21:22.086
Boom.

14625
24:21:22.086 --> 24:21:22.495
Jack.

14626
24:21:22.495 --> 24:21:22.904
Done.

14627
24:21:22.904 --> 24:21:27.294
What's next? Okay, let's update our listings.

14628
24:21:27.294 --> 24:22:00.476
So we'll do function update listing address and if the address you went to for the sixth token ID you went to the six new price will update the price of this of this external we'll make sure it's listed with is listed say is owner do a token ID and then we'll do message dot sender.

14629
24:22:00.476 --> 24:22:09.703
Now to update our listing We'll just say s underscore listings of NF T address.

14630
24:22:09.703 --> 24:22:15.438
At token ID dot price equals the new price that we're giving it.

14631
24:22:15.438 --> 24:22:18.842
And then we'll admit, we can omit like item updated.

14632
24:22:18.842 --> 24:22:28.203
But we can also just omit an item listed with MSG dot sender NFT address, token ID, new price.

14633
24:22:28.203 --> 24:22:33.548
Because essentially, by updating it, we're essentially just relisting it with a new price.

14634
24:22:33.548 --> 24:22:41.256
So we're just going to do an item listed event, we only have one more function to do, we need to do a withdraw proceeds.

14635
24:22:41.256 --> 24:22:49.476
So we'll say function, withdraw proceeds to get all the payments for all of our entities.

14636
24:22:49.476 --> 24:23:11.152
So we'll get the the proceeds by doing new activity six proceeds equals s underscore proceeds of MSG dot sender, right, we're getting all the payments that were collected in by item, and we're saying if proceeds is less than or equal to zero, then we're going to revert with no proceeds.

14637
24:23:11.152 --> 24:23:14.009
And we're going to make this a NFT.

14638
24:23:14.009 --> 24:23:17.810
Marketplace underscore underscore no proceeds.

14639
24:23:17.810 --> 24:23:32.623
Excel create at the top error empty marketplace no proceeds being otherwise, we'll say s underscore proceeds of MSG dot sender equals zero.

14640
24:23:32.623 --> 24:23:38.283
So we're going to reset the proceeds to zero, right, we're going to do this before we send any proceeds.

14641
24:23:38.283 --> 24:23:57.652
And then we're going to do our traditional way we send payments, so bool success equals payable, message dot sender call value is going to be proceeds all blank here.

14642
24:23:57.652 --> 24:24:16.877
And then we could do require, you know, we could do require success, or we could say if not success, reverts revert with Aleksey marketplace, transfer failed.

14643
24:24:16.877 --> 24:24:22.127
And then we'll make this a new air, air NFT marketplace transfer failed.

14644
24:24:22.127 --> 24:24:23.877
Put a semicolon here.

14645
24:24:23.877 --> 24:24:26.409
And we're looking pretty good.

14646
24:24:26.409 --> 24:24:29.231
Now we even have a way to withdraw.

14647
24:24:29.231 --> 24:24:31.808
So we have our five functions here.

14648
24:24:31.808 --> 24:24:32.359
Awesome.

14649
24:24:32.359 --> 24:24:35.422
Let's just create a couple of getters.

14650
24:24:35.422 --> 24:24:38.694
So maybe we'll do we even copy this.

14651
24:24:38.877 --> 24:24:42.747
Paste it here we'll say getter functions like so.

14652
24:24:43.877 --> 24:24:46.290
function maybe we'll do get listing.

14653
24:24:47.877 --> 24:24:58.687
address, the utilities X token ID, external view, which returns a listing in memory.

14654
24:24:58.687 --> 24:25:08.592
And we'll say return s underscore listings of NF T address token Id like so.

14655
24:25:08.592 --> 24:25:25.801
And also function, get proceeds of address seller, external view returns, you went to the desex return s underscore proceeds of the seller.

14656
24:25:25.801 --> 24:25:29.136
So we'll get how much money somebody is owed.

14657
24:25:29.136 --> 24:25:36.746
And then any listings and let's run a little compile here, yarn, or hit Compile or hh compile just to see where we messed up.

14658
24:25:36.746 --> 24:25:37.778
Oh, we did a mess up.

14659
24:25:37.878 --> 24:25:39.648
Wow, that's great.

14660
24:25:42.878 --> 24:25:50.262
successfully created a minimalistic NFT marketplace that's completely decentralized.

14661
24:25:50.262 --> 24:25:51.800
That is pretty wild.

14662
24:25:51.800 --> 24:25:53.844
And that is incredibly powerful.

14663
24:25:53.844 --> 24:25:56.420
And you should feel really excited for yourself.

14664
24:25:56.420 --> 24:25:58.114
Very cool, very good job.

14665
24:25:58.114 --> 24:26:02.369
But you know, we're not done, we got to write some deploys and some tests.

14666
24:26:02.369 --> 24:26:03.555
So let's jump into that.

14667
24:26:03.555 --> 24:26:11.462
Now since we've done this a couple of times, I actually encourage you to pause the video here and try writing your own deploy scripts and your own tests.

14668
24:26:11.462 --> 24:26:21.497
And then go ahead and come back and follow along with us and see if you did it correctly, we're going to create a new folder called deploy.

14669
24:26:21.497 --> 24:26:27.163
Of course, we already have the hard hat deploy in our hard hat config.

14670
24:26:27.163 --> 24:26:28.734
So we know we're good to go here.

14671
24:26:28.734 --> 24:26:31.164
So let's go ahead and create a one.

14672
24:26:31.164 --> 24:26:33.628
Deploy NFT marketplace.

14673
24:26:33.628 --> 24:26:33.842
js.

14674
24:26:33.842 --> 24:27:00.800
Now once again, you've seen a lot of this before, so we're going to spare the details do const network equals require hard hat to constant development chains, equal equals require dot dot slash help our hard hats config, which we should have let's see.

14675
24:27:00.879 --> 24:27:01.828
Do we copy paste it over? No.

14676
24:27:02.879 --> 24:27:06.729
over Are helper Hardhead config from the last project, let's go ahead and grab it.

14677
24:27:06.729 --> 24:27:10.879
Or we can grab it from the smart contract lottery and paste that in here.

14678
24:27:10.879 --> 24:27:15.279
And we really only need this file for the development chains here.

14679
24:27:15.279 --> 24:27:19.338
Right for hard hat and localhost, we're going to grab the development chains from that.

14680
24:27:19.338 --> 24:27:22.895
And then we'll also grab const.

14681
24:27:22.895 --> 24:27:27.124
Verify, equals require, get this from utils.

14682
24:27:27.124 --> 24:27:30.499
Verify, right? Do we have utils, we have verify.

14683
24:27:30.499 --> 24:27:31.533
Fantastic.

14684
24:27:31.533 --> 24:27:36.414
Now we'll do module that exports equals async.

14685
24:27:36.414 --> 24:27:45.079
an async function where it's gonna take get named accounts and deployments.

14686
24:27:45.079 --> 24:27:52.027
From the hard hat input parameter, and then we're gonna do const.

14687
24:27:52.027 --> 24:27:55.141
Deploy comma log equals deployments.

14688
24:27:55.141 --> 24:28:01.450
And then const, Deployer equals await, get named accounts.

14689
24:28:01.450 --> 24:28:05.879
Which, of course, we're getting from our heart head dot config.

14690
24:28:05.879 --> 24:28:08.746
We have named accounts, we have a Deployer.

14691
24:28:08.880 --> 24:28:12.208
And we have a player or whatever you have in here from our last project.

14692
24:28:12.208 --> 24:28:16.848
And now does our entity marketplace have a constructor? Construct? Nope, no constructor.

14693
24:28:16.848 --> 24:28:19.435
So we know args is going to be blank.

14694
24:28:19.435 --> 24:28:22.768
And then we can say const NFT.

14695
24:28:22.768 --> 24:28:26.750
Marketplace equals await, deploy.

14696
24:28:26.750 --> 24:28:36.170
And if T marketplace, say from Deployer, args is going to be args.

14697
24:28:36.170 --> 24:28:38.363
Log will be true.

14698
24:28:38.363 --> 24:28:56.930
And then wait confirmations will be network dot config dot wait confirmations or one, two, this is going to be block on for patients, we'll go to the config, just make sure that those are in here.

14699
24:28:56.930 --> 24:28:59.439
I'm sorry, I didn't add them in here.

14700
24:28:59.439 --> 24:29:06.563
So we'll do block confirmations is going to be six for all of our networks.

14701
24:29:06.563 --> 24:29:14.229
So I actually grabbed this not from the last project, it looks like I grabbed this from the hard hat starter kit.

14702
24:29:14.229 --> 24:29:16.255
So I'm just going to add those block confirmations in there.

14703
24:29:16.255 --> 24:29:17.426
And now we're good to go.

14704
24:29:17.426 --> 24:29:38.786
Now we're gonna say if we're not on a development chain, not development chains that includes network dot name, and process study and be done ether scan API key, then we're gonna go ahead, we'll do log verifying.

14705
24:29:38.786 --> 24:29:42.202
And then we'll do a weight verify.

14706
24:29:42.202 --> 24:29:52.081
And if the markets place dot address with arcs, and then we'll do like log a whole bunch of hyphens here.

14707
24:29:52.081 --> 24:30:01.947
And then finally, module that exports dot tags equals all and then NFT Mar good place.

14708
24:30:01.947 --> 24:30:08.608
And we can test this deploy function with yarn Hardhead deploy.

14709
24:30:08.608 --> 24:30:09.981
Tada, we did it.

14710
24:30:09.981 --> 24:30:10.281
Great.

14711
24:30:10.281 --> 24:30:15.996
So now we have the deploy function, we can verify we have our contract, what else are we probably gonna need to do.

14712
24:30:15.996 --> 24:30:20.692
Since this is an NFT marketplace, we're probably going to need some NF Ts.

14713
24:30:20.692 --> 24:30:30.781
So what we can do is in our contracts, and we'll create a new folder for tests got a new file in here called Basic NF T dot soul.

14714
24:30:30.781 --> 24:30:35.569
And in here, we can add that basic NF T from our last project.

14715
24:30:35.569 --> 24:30:45.372
Or you can just go to my or you can just go to the GitHub repo associated with this course, go to contracts, test, basic NF t, and then just copy paste.

14716
24:30:45.372 --> 24:30:46.847
That works too.

14717
24:30:46.847 --> 24:30:56.777
So this basic NF t that we're using is just pointing to the pug as the basic NF T for us to use just to test this out.

14718
24:30:56.777 --> 24:31:08.666
So now that we have a basic NFT we're gonna need to create new file, oh to deploy basic NF T dot j s, and we'll borrow a lot of the boilerplate from over here.

14719
24:31:08.666 --> 24:31:13.181
So we'll copy all of this actually paste it in.

14720
24:31:13.181 --> 24:31:24.088
We'll say const args equals blank, and we'll say const basic NF t equals await deploy basic NF T.

14721
24:31:24.088 --> 24:31:26.729
From Deployer.

14722
24:31:26.729 --> 24:31:31.303
args is going to be args.

14723
24:31:31.303 --> 24:32:16.931
Log is going to be true weight con confirmations is going to be network dot config dot block confirmations or one and then we'll verify this with if not develop meant chains dot includes network dot name and process dot EMV that ether scan API key that will say log or To find dot A dot await there if I basic NFT dot address, and arcs, module dot exports dot tags equals all, and basic NFT.

14724
24:32:16.931 --> 24:32:22.063
And we can test both of these with yarn, art had deploy.

14725
24:32:22.063 --> 24:32:23.590
And fantastic.

14726
24:32:23.590 --> 24:32:26.501
Both of these have been deployed.

14727
24:32:26.501 --> 24:32:27.977
Again, you don't have to pause.

14728
24:32:27.977 --> 24:32:33.463
But it is a good way to really hone in to really sharpen those skills on doing all this.

14729
24:32:33.463 --> 24:32:36.517
And repetition is the mother of all skill.

14730
24:32:36.517 --> 24:32:46.914
So repeating this stuff yourself and thinking through these problems yourself and trying to code these things yourself, are really what's going to make you successful at this.

14731
24:32:46.914 --> 24:32:48.373
All right, awesome.

14732
24:32:48.373 --> 24:32:52.656
Now that we have our deploy Betson, it's time to write some tests.

14733
24:32:52.656 --> 24:33:03.566
Now, if you go to the GitHub repo associated with this course, and you go to the test folder, the tests and here are some of the robust, we've actually written out of all of our projects, there's a lot of tests in here.

14734
24:33:03.566 --> 24:33:09.682
Now, pretty much everything in here, we've already learned about and you already know how to do you have the ability to do it.

14735
24:33:09.682 --> 24:33:13.765
So I'm just going to go ahead and get you started off, and we're going to write one test together.

14736
24:33:13.765 --> 24:33:22.435
And then I highly recommend you going back in, you tried to write some tests yourself, to get that code coverage to get that test coverage to be 100 percent.

14737
24:33:22.435 --> 24:33:28.583
So let's go ahead, we'll write one test together, then you should pause this video and try to write some tests yourself.

14738
24:33:28.583 --> 24:33:35.476
When you're done writing tests and you think you've hit 100 percent, feel free to compare back to the test that we wrote.

14739
24:33:35.476 --> 24:33:40.459
So let's create a new folder called tests.

14740
24:33:40.459 --> 24:33:41.052
Test.

14741
24:33:41.052 --> 24:33:43.866
And in here, we'll do a new one called unit.

14742
24:33:43.866 --> 24:33:48.817
And if you want to write staging tests later on, you absolutely can we will not.

14743
24:33:48.883 --> 24:33:54.883
We'll create a new file in here called NFT marketplace.

14744
24:33:54.883 --> 24:33:55.327
test.

14745
24:33:55.883 --> 24:33:58.709
And we'll start some tests.

14746
24:34:00.883 --> 24:34:07.849
cert, expect equals require Chai const.

14747
24:34:11.883 --> 24:34:26.798
ethers, equals require hard hat const development chains equals require dot dot slash dot dot slash helper, hothead config.

14748
24:34:26.883 --> 24:34:29.514
And we're gonna do the same setup we've been doing.

14749
24:34:29.883 --> 24:34:44.216
say bang development chains dot includes network dot name, question mark, describe dot skip.

14750
24:34:44.216 --> 24:34:46.549
Else describe.

14751
24:34:46.549 --> 24:34:57.843
And if NF T marketplace tests, comma async function, excuse me, this is just gonna be a function.

14752
24:34:57.843 --> 24:35:02.464
Scrabble oval is just a function, not an async function, like so.

14753
24:35:02.464 --> 24:35:02.851
Great.

14754
24:35:02.851 --> 24:35:07.124
Now let's get some variables and do a before each.

14755
24:35:07.124 --> 24:35:14.470
So we'll say NF T marketplace, basic NF T, we'll create a constant price.

14756
24:35:14.470 --> 24:35:18.427
So we're just always set the price of all of our NF T's to the same thing.

14757
24:35:18.427 --> 24:35:23.868
This will be ethers dot utils dot parse ether 0.

14758
24:35:23.868 --> 24:35:24.008
1.

14759
24:35:24.008 --> 24:35:31.461
We'll say const token ID for now will always be zero.

14760
24:35:31.884 --> 24:35:38.759
And then we'll do before each will be an async function.

14761
24:35:38.884 --> 24:35:44.222
And we'll get out and we'll also get Deployer.

14762
24:35:45.884 --> 24:35:48.902
equals await, get named accounts.

14763
24:35:50.884 --> 24:35:59.074
grab getting into accounts from hard hat as well wrap this all up dot deployer Excel and then we'll also in our heart hat.

14764
24:35:59.074 --> 24:35:59.454
config.

14765
24:35:59.454 --> 24:35:59.580
js.

14766
24:35:59.580 --> 24:36:03.503
Under get named accounts, we also have something called player.

14767
24:36:03.503 --> 24:36:05.312
Now I didn't talk about this too much.

14768
24:36:05.312 --> 24:36:15.384
But we're going to have a second account which is defaulted to the first index, right? So we can do at the top to come up player.

14769
24:36:15.384 --> 24:36:23.752
And we can say player equals await get named accounts dot player.

14770
24:36:23.884 --> 24:36:29.384
Now we have a player and a deployer account will do await deployments, that fixture.

14771
24:36:29.384 --> 24:36:37.800
All will just deploy all of those contracts will run through everything in our deploy folder.

14772
24:36:37.885 --> 24:36:39.726
We'll get our NFT marketplace.

14773
24:36:41.885 --> 24:36:46.766
await ethers dot get contract and ft.

14774
24:36:46.766 --> 24:36:48.393
marketplace.

14775
24:36:49.885 --> 24:36:56.996
we'll do basic NF t equals await ethers dot get contract.

14776
24:36:57.885 --> 24:36:58.212
NF T.

14777
24:37:02.885 --> 24:37:07.885
grab thing, whatever account is that account zero, which right now is our Deployer.

14778
24:37:07.885 --> 24:37:25.248
If we want to call a function on NFT marketplace, with the player being the one calling the function, we would have to say, entity marketplace equals await and empty marketplace dot connect player like this.

14779
24:37:25.248 --> 24:37:31.588
And now whenever we call a function, we would use the player instead of the Deployer.

14780
24:37:31.588 --> 24:37:38.901
Sometimes what I like to do and you'll see this in my code, is I'll do let NFT marketplace contract.

14781
24:37:38.901 --> 24:37:48.212
And then let NFT marketplace, and then I'll do NFT marketplace contract equals await ethers dot contract.

14782
24:37:48.212 --> 24:37:52.456
And then I'll connect and set that to the NF T marketplace.

14783
24:37:52.456 --> 24:37:59.813
Yes, we can do, we can automatically choose who to connect by placing whoever want to connect to write and get contract.

14784
24:37:59.813 --> 24:38:02.099
But sometimes it's really nice to be kind of explicit.

14785
24:38:02.099 --> 24:38:03.072
So it's really up to you.

14786
24:38:03.072 --> 24:38:11.120
I'm going to undo all that, I just want to re show you that to make sure that you knew that's how you kind of switch around with the different accounts and the different users.

14787
24:38:11.120 --> 24:38:16.836
Now that we have an NF T, we're probably going to need to mint the NFT so that we can actually place it on the market.

14788
24:38:16.886 --> 24:38:23.508
So we'll do await basic NF T dot meant NF t, and then we'll approve to send it on to the marketplace.

14789
24:38:23.508 --> 24:38:24.753
So we'll do a wait.

14790
24:38:24.886 --> 24:38:36.386
Basic NF T dot approve and T market place dot address token ID, which is going to be zero.

14791
24:38:36.386 --> 24:38:42.886
And just like that, the NOC marketplace remember, it can't call approve, because it doesn't own that NF t.

14792
24:38:42.886 --> 24:38:45.347
So we need to have the Deployer.

14793
24:38:45.347 --> 24:38:46.869
Call approved, right.

14794
24:38:46.869 --> 24:38:51.219
And remember, since we're not we need to put basic NF T in here.

14795
24:38:51.219 --> 24:38:58.580
Since we didn't tell ethers who to connect this to it just automatically connected it to our Deployer because that's what's at account zero.

14796
24:38:58.580 --> 24:39:05.467
So it's the deployer calling minting it and then the deployer approving to send it to the marketplace.

14797
24:39:05.467 --> 24:39:12.821
Only after this approved function has been called canned the NFT marketplace called transfer from all those NF T's.

14798
24:39:12.821 --> 24:39:15.771
Now we're just going to do one test here.

14799
24:39:15.771 --> 24:39:20.000
We're gonna say it lists and can be bought.

14800
24:39:20.000 --> 24:39:23.419
That's it, and this will be an async function.

14801
24:39:23.419 --> 24:39:30.486
And we're just gonna list the NFT and buy a weight entity marketplace.

14802
24:39:30.486 --> 24:39:38.066
if We go to our energy marketplace, what are we doing, we're listing it right, we want to list the item or with the address token ID and the price.

14803
24:39:38.066 --> 24:39:41.475
So we'll do dot list item.

14804
24:39:41.475 --> 24:39:47.368
Basic NF T dot address, token ID is zero, which we've defined right here.

14805
24:39:47.368 --> 24:39:50.299
And then price we've hard coded up here as well.

14806
24:39:50.299 --> 24:39:51.569
So we're listing it.

14807
24:39:51.569 --> 24:39:59.628
So the deployer owns the NF T, the player is now listing it, now we want to buy it, let's have the player be the one to buy it.

14808
24:39:59.628 --> 24:40:05.430
So what we're going to do is we're going to have to connect the player to the NFT marketplace.

14809
24:40:05.430 --> 24:40:14.543
So we can say const player connected NF T, marketplace equals and ft marketplace dot Connect.

14810
24:40:14.543 --> 24:40:15.199
Player.

14811
24:40:15.199 --> 24:40:23.188
And then we can buy the item by saying a weight player connected and ft marketplace.

14812
24:40:23.188 --> 24:40:23.848
by item.

14813
24:40:23.848 --> 24:40:31.628
It'll be the basic and if we look back at the end of the marketplace, what does buy item need, needs the NFT address and the token ID.

14814
24:40:31.628 --> 24:40:43.420
So basic NF t that address and then the token ID and after this bot, we should check to see that the player actually does indeed own that NF team.

14815
24:40:43.420 --> 24:40:48.980
So we can say const new owner and we check to see if that owner is indeed updated.

14816
24:40:48.980 --> 24:41:04.161
We can say basic NFT dot owner of because NF T's have an owner of function, token ID and then we also want to see that the deployer actually is going to get paid.

14817
24:41:04.161 --> 24:41:11.744
So we can say await and if T marketplace dot get proceeds of Deployer.

14818
24:41:11.744 --> 24:41:29.277
So now we can do assert new owner dot two string equals player and we can assert deployer proceeds.

14819
24:41:29.277 --> 24:41:31.820
to string equals price.

14820
24:41:31.820 --> 24:41:36.677
to string because they should have been paid that price.

14821
24:41:36.677 --> 24:41:39.405
And that's right, it's actually a little bit easier.

14822
24:41:39.405 --> 24:41:42.173
instead of grabbing players from getting named accounts.

14823
24:41:42.173 --> 24:41:45.157
It's a little bit easier just to grab it right from ethers.

14824
24:41:45.157 --> 24:41:51.129
So we'll do const accounts equals await get signers.

14825
24:41:51.129 --> 24:42:03.017
And then we'll save player equals accounts of one just because when we connect it's expecting it type of account and then the the get named account is a different type.

14826
24:42:03.017 --> 24:42:05.316
So Oh, it's just a little bit easier to actually connect like this.

14827
24:42:05.316 --> 24:42:10.841
So now we'll connect to the player like so just know that player and deployer are now different types.

14828
24:42:10.841 --> 24:42:13.724
So you'll see a little bit differences there.

14829
24:42:13.724 --> 24:42:16.232
To me, this is ethers that gets signers.

14830
24:42:16.232 --> 24:42:25.609
And then when we buy the item, we're of course gonna have to pass a value, it's gonna be price, of course, we're going to need to pay the price of the NFT.

14831
24:42:25.609 --> 24:42:28.316
And then of course, this needs to be player dot address.

14832
24:42:28.316 --> 24:42:33.870
And that's the difference right now we got to do player that address whenever we want the address of one of the ethers accounts.

14833
24:42:33.870 --> 24:42:36.678
And then this new owner, of course, should be in a wait.

14834
24:42:36.678 --> 24:42:38.396
And now we can run this all.

14835
24:42:38.396 --> 24:42:43.141
In Tada, we see things pass.

14836
24:42:43.141 --> 24:42:54.051
So our NFT marketplace is able to facilitate the buying and selling of an NF T with arbitrary humans.

14837
24:42:54.051 --> 24:42:55.360
This is fantastic.

14838
24:42:55.360 --> 24:43:01.755
So we just ran the single test to show a little bit of the oddities when working with NF T's and some different accounts.

14839
24:43:01.755 --> 24:43:09.838
But 100 percent If you feel up for the challenge, take this time, pause this video and try to write some tests.

14840
24:43:09.838 --> 24:43:19.800
Remember, the goal here is for us to do yarn hardhat coverage, and see what our coverage is and try to get it to be 100 percent coverage.

14841
24:43:19.800 --> 24:43:25.951
If we run it right now, we'll see Oh, my goodness, we are missing a lot of coverage.

14842
24:43:25.951 --> 24:43:31.098
Here, we have a ton of uncovered lines, on top of uncovered functions, branches, statements, etc.

14843
24:43:31.098 --> 24:43:37.529
Try to write some tests to get this to 100 percent and then come back.

14844
24:43:37.529 --> 24:43:40.200
Okay, welcome back.

14845
24:43:40.200 --> 24:43:43.269
Hopefully now you've written some tests.

14846
24:43:43.269 --> 24:43:47.139
And when you run your tests, you can get some of them, I look like this, right.

14847
24:43:47.139 --> 24:43:50.475
And these are my tests, these are the tests that I wrote, you could do more you could do last.

14848
24:43:50.475 --> 24:43:54.155
And let's see, when I run yarn Hardhead coverage, I even missed some lines.

14849
24:43:54.155 --> 24:43:56.698
And I could I could test a little bit more.

14850
24:43:56.698 --> 24:43:59.281
So make your tests even better than the ones that I made.

14851
24:43:59.281 --> 24:44:01.872
So these are the tests from the GitHub repo associated with this.

14852
24:44:01.872 --> 24:44:05.751
Now that we've written some tests here, let's just write a couple of scripts.

14853
24:44:05.751 --> 24:44:09.973
And the reason we're gonna write a couple of scripts is we're gonna need these a little bit later.

14854
24:44:09.973 --> 24:44:14.668
So we'll write some scripts to mint, some amount of teased by some NF T's etc.

14855
24:44:14.668 --> 24:44:19.630
And we'll need this to fiddle around and play on the front end a little bit later.

14856
24:44:19.630 --> 24:44:27.212
So to create a script, again, we've done this perform, let's do a script called mint, and list dot j s.

14857
24:44:27.212 --> 24:44:30.134
And this will be to mint at NFT.

14858
24:44:30.134 --> 24:44:33.986
And then immediately listed on the marketplace.

14859
24:44:33.986 --> 24:44:39.269
So let's create an async function called mint, and list.

14860
24:44:39.269 --> 24:44:45.298
And down below, we're going to call mint and list I'm going to copy paste with that same script thing that we've been doing.

14861
24:44:45.298 --> 24:44:48.650
Obviously, instead of Maine, though, we're calling this mountain list.

14862
24:44:48.650 --> 24:45:01.734
Now in this mountain list, where it's a constant, NFT mark, and of tea market, place equals await ethers dot get contract.

14863
24:45:01.890 --> 24:45:03.441
And ft marketplace.

14864
24:45:06.890 --> 24:45:07.499
from hard hat.

14865
24:45:07.499 --> 24:45:09.374
And then we'll do we'll grab basic NF t.

14866
24:45:09.890 --> 24:45:10.890
say const.

14867
24:45:15.890 --> 24:45:16.676
contract.

14868
24:45:16.676 --> 24:45:17.757
Basic NF t.

14869
24:45:22.890 --> 24:45:26.988
So we'll do console dot log, maintained at the top.

14870
24:45:27.890 --> 24:45:30.973
do a weight or actual we'll say const.

14871
24:45:32.890 --> 24:45:35.690
basic NF T dot mint NF t.

14872
24:45:39.890 --> 24:45:41.675
Wait, wait one block.

14873
24:45:41.675 --> 24:45:44.264
And actually we'll say const.

14874
24:45:44.890 --> 24:45:45.890
TX receipt.

14875
24:45:45.890 --> 24:45:47.890
So that equals that.

14876
24:45:50.890 --> 24:45:52.740
another reason why events are so good.

14877
24:45:53.890 --> 24:45:59.723
We're omitting the token ID in an event in this document ID event.

14878
24:45:59.723 --> 24:46:10.660
So we could say const token ID equals mint TX receipt dot events of zero.

14879
24:46:10.660 --> 24:46:13.905
That args dot token Id like that.

14880
24:46:13.905 --> 24:46:15.906
And now we have the token ID.

14881
24:46:15.906 --> 24:46:18.690
And now that we have the token ID and the basic NFT.

14882
24:46:18.690 --> 24:46:22.290
minted we can now call on our NFT marketplace list item.

14883
24:46:22.290 --> 24:46:25.590
So now we'll say console dot log.

14884
24:46:25.590 --> 24:46:29.382
Approving NFT right, it's gonna be real similar to our tests here.

14885
24:46:29.382 --> 24:46:50.891
I'm gonna say const approval TX equals await basic NFT data prove NFT marketplace dot address token ID and then we'll do a weight approved TX dot wait one and we'll do console dot log listing NF t.

14886
24:46:50.891 --> 24:47:11.568
at that and then we'll do const TX equals await and if T market market place that list item and we'll do NFT marketplace that address So can Id do await TX dot wait one, console dot log listed and cool.

14887
24:47:11.568 --> 24:47:20.652
And we can try this out by running yarn hardhat node, which is going to run through our deploy scripts, right, it's going to run to these deployed scripts here.

14888
24:47:20.652 --> 24:47:31.491
And then in a new terminal, we'll run our script, yarn hard hat, run scripts meant and list dash dash network localhost.

14889
24:47:31.491 --> 24:47:36.908
And we missed an argument, oh, we need a price as well to list our entity.

14890
24:47:36.908 --> 24:47:48.779
So we'll create a constant price equals and we'll say ethers dot utils dot parse, ether 0.

14891
24:47:48.779 --> 24:47:48.937
1.

14892
24:47:48.937 --> 24:47:53.197
And we'll pass the price and to the list item.

14893
24:47:53.197 --> 24:48:02.201
So oops, and sorry, it's not the marketplace that we're listing, the basic NF t that we're listing, of course, so run that again.

14894
24:48:02.201 --> 24:48:05.448
And Bada bing, bada boom, got some listed events.

14895
24:48:05.448 --> 24:48:08.891
And we can see here, we're doing some listing and awesome.

14896
24:48:08.891 --> 24:48:10.181
So now we have a script.

14897
24:48:10.181 --> 24:48:31.746
Alright, so now that we have a script, and we're going to be writing a couple other scripts a little bit later, we essentially have a really solid repo here are our totally decentralized, NFT marketplace, this is absolutely massive, and you should be incredibly, incredibly proud of yourself.

14898
24:48:31.892 --> 24:48:33.576
Now, of course, this is all code.

14899
24:48:34.892 --> 24:48:38.569
with this, if they're software developers, which is great.

14900
24:48:38.892 --> 24:48:45.825
we're going to want to allow anybody to be able to interact and list their own NF t's on our marketplace.

14901
24:48:45.825 --> 24:48:51.098
So what are we going to do? Well, we're going to want to build a front end for this.

14902
24:48:51.098 --> 24:48:54.360
And now we're gonna get into the second part of this lesson.

14903
24:48:54.360 --> 24:48:57.953
So on lesson 15, we just finished the backend.

14904
24:48:57.953 --> 24:49:01.793
Now we're gonna move on to the front end, we're gonna start with this morass code.

14905
24:49:01.793 --> 24:49:06.197
The code for both of these is pretty much nearly identical.

14906
24:49:06.197 --> 24:49:09.315
But we're going to start with Morales, and we're going to teach you how to do both of these.

14907
24:49:09.315 --> 24:49:12.247
And we're going to teach you the difference between the Morales and the MoGraph.

14908
24:49:12.247 --> 24:49:16.925
And kind of why we're even using them in the first place, we're going to start with Morales.

14909
24:49:16.925 --> 24:49:23.463
So if you want to follow along with this next section, all the code we're going to be working with, is going to be in here.

14910
24:49:23.463 --> 24:49:34.130
So you excited, I hope you are because this is going to be a phenomenal session, we are about to build one of the most sophisticated front ends that we can using the tools that we have.

14911
24:49:34.130 --> 24:49:37.334
And like I said, we showed you a little bit earlier what this is going to look like.

14912
24:49:37.334 --> 24:49:39.055
So let's do a quick refresher here.

14913
24:49:39.055 --> 24:49:41.613
So here's what our front end is going to look like.

14914
24:49:41.613 --> 24:49:47.954
But what we can do is we can connect with our little connect button, we hit Metamask Metamask pops up, we'll go ahead and connect.

14915
24:49:47.954 --> 24:49:53.203
And now that we're connected, we can see the different NF T's in here.

14916
24:49:53.203 --> 24:49:57.831
And if we're on an address that's owned by us, it will say owned by you.

14917
24:49:57.893 --> 24:50:02.565
And if we switch addresses, are you I will go ahead and update, connect there.

14918
24:50:02.565 --> 24:50:04.789
And now we're owned by a different address.

14919
24:50:04.893 --> 24:50:07.617
Now if it's owned by us, we get this little hover that says Update listing.

14920
24:50:07.617 --> 24:50:09.013
And right now it's worth 0.

14921
24:50:09.013 --> 24:50:09.116
18.

14922
24:50:09.116 --> 24:50:12.854
That's what it's listed for on our marketplace.

14923
24:50:12.854 --> 24:50:16.842
If it's owned by us, and we click it, we can update it to a different price.

14924
24:50:16.893 --> 24:50:22.840
Let's update it to 50 eath, or whatever your layer one currency is, we'll just save new listing price.

14925
24:50:22.840 --> 24:50:24.375
We'll go ahead and confirm.

14926
24:50:24.375 --> 24:50:28.859
And I'll say the listing updated, please refresh, what we can do them.

14927
24:50:28.859 --> 24:50:33.343
And we'll mine some blocks on the back end, and boom, now we see that it's worth 50 here.

14928
24:50:33.343 --> 24:50:45.993
Now if we switch to a different account, now we can see owned by Baba blah, and the hovered now says by me enough is selected as a different user, I'm going to get this transaction to actually buy it.

14929
24:50:45.993 --> 24:50:49.618
Now go ahead and confirm that I'm going to buy it, I get a little pop up.

14930
24:50:49.618 --> 24:50:51.214
This is item bought successfully.

14931
24:50:51.214 --> 24:50:58.893
Now if I do a little refresh, we'll now see that that NFT is gone from the marketplace since we bought it right and it's no longer available to be sold.

14932
24:50:58.893 --> 24:51:02.532
Now what we can do then is we can come over to sell NF tees.

14933
24:51:02.532 --> 24:51:06.508
And at the bottom, we'll see a withdraw proceeds.

14934
24:51:06.508 --> 24:51:14.793
So whenever somebody buys an NF T, the NFT marketplace actually keeps the proceeds that actually keeps the result of the sale.

14935
24:51:14.793 --> 24:51:24.030
So if we switch back to our address that had the NFT listed, we can now see Withdraw 50 proceeds because we know that we have 50 eath, because we just bought that for 50.

14936
24:51:24.030 --> 24:51:37.094
So if we hit withdraw, Metamask is going to pop up, we can go ahead and confirm, wait a little bit as transaction populates, and boom once it goes through, and we'll see now we have zero proceeds.

14937
24:51:37.094 --> 24:51:39.760
Right? We withdrew everything from here.

14938
24:51:39.894 --> 24:51:42.168
So what we can do now is we can relist that NFT.

14939
24:51:42.894 --> 24:51:58.687
back, go back to the one who just bought that at a T if we know the address and the token ID of the NF t and we own it, we can go ahead and relisted you're gonna place the address in here with the token Id give it some sort of price.

14940
24:51:58.687 --> 24:52:05.481
We'll submit we'll approve giving the NFT marketplace access to our or NFT, to our little doggie.

14941
24:52:05.481 --> 24:52:15.465
And then we'll go ahead and actually send the transaction to actually list the NFT on a marketplace that we get NF T listed successfully.

14942
24:52:15.465 --> 24:52:19.506
After we move some blocks in the backend, we can go back to the front end.

14943
24:52:19.506 --> 24:52:25.598
And we now see, it's owned by us, instead of the original owner, right and set for 10 ether.

14944
24:52:25.598 --> 24:52:32.539
And then we can of course, switch back to a different user, and we can have them actually buy.

14945
24:52:32.539 --> 24:52:39.227
Alright, so now that we have the contracts, we know what this looks like on the contract side.

14946
24:52:39.227 --> 24:52:42.168
So now let's figure out how to do this on the front end side.

14947
24:52:42.168 --> 24:52:44.163
So let's jump into our code editor.

14948
24:52:44.163 --> 24:52:49.281
And begin if we're on our hard hat and my NFT marketplace Free Code Camp folder.

14949
24:52:49.281 --> 24:52:50.119
That's great.

14950
24:52:50.119 --> 24:52:53.336
But we're going to create another folder, we're going to CD down and directory.

14951
24:52:53.336 --> 24:52:55.303
And we're going to make a new directory.

14952
24:52:55.303 --> 24:53:00.962
I'm going to call it next Jas and if T marketplace dash FCC.

14953
24:53:00.962 --> 24:53:05.401
Now you can do next Jas marketplace dash mirallas FCC if you want.

14954
24:53:05.401 --> 24:53:10.582
Again, we're starting with mirallas CD next Jas NFT marketplace FCC.

14955
24:53:10.582 --> 24:53:19.270
So now that we have this folder, will do code dot will open up a new VS code, or you can do File Open folder and open this new folder.

14956
24:53:19.270 --> 24:53:22.520
And we can begin working in this new folder in here.

14957
24:53:22.520 --> 24:53:29.040
Now that we're in our new project, we're in our new folder, we're gonna do exactly what we've done before.

14958
24:53:29.040 --> 24:53:31.485
Yarn create next app, period.

14959
24:53:31.485 --> 24:53:34.632
Okay, we've done our setup here.

14960
24:53:34.632 --> 24:53:36.963
Now, I don't like es lint.

14961
24:53:36.963 --> 24:53:38.228
So once again, I'm just going to go ahead and delete that.

14962
24:53:38.228 --> 24:53:43.153
And what we're going to add in instead is our prettier stuff.

14963
24:53:43.153 --> 24:53:44.808
So prettier, ignore prettier RC.

14964
24:53:44.808 --> 24:53:49.927
Again, some people may strongly disagree with me on that, but to each their own right, this is what I like to do.

14965
24:53:49.927 --> 24:53:51.024
So this is what I'm going to do.

14966
24:53:51.024 --> 24:54:01.957
Now we have a minimalistic react project, right? If we run yarn Dev, we open up our UI on that site, copy this, or Command, click it.

14967
24:54:01.957 --> 24:54:02.269
Tada.

14968
24:54:02.269 --> 24:54:03.269
Welcome to next.

14969
24:54:03.269 --> 24:54:06.145
Jas Yeah, we've got an x js application.

14970
24:54:06.145 --> 24:54:09.504
As we know, we go to pages, we go to index.

14971
24:54:09.504 --> 24:54:09.660
js.

14972
24:54:09.895 --> 24:54:13.452
Let's delete everything in here.

14973
24:54:16.895 --> 24:54:20.109
head if it comes with stuff and head will write Hi, exclamation mark.

14974
24:54:20.109 --> 24:54:21.555
We'll save we'll come back.

14975
24:54:21.555 --> 24:54:22.519
And now we see Hi.

14976
24:54:22.519 --> 24:54:24.366
And I'll zoom in a whole bunch.

14977
24:54:24.366 --> 24:54:24.649
Boom.

14978
24:54:24.649 --> 24:54:28.791
So now we have some minimalistic reacts minimalistic next, Jas.

14979
24:54:28.791 --> 24:54:31.640
Now, I know we already started the project here.

14980
24:54:31.640 --> 24:54:34.104
But let's jump to the readme that's given to us.

14981
24:54:34.104 --> 24:54:39.028
And let's talk about how we want to do this what we want this to actually look like.

14982
24:54:39.028 --> 24:54:41.640
Well, we're going to want to make a homepage.

14983
24:54:41.640 --> 24:54:53.942
And in this homepage, we'll say we'll have it show recently listed, NF T's homepage will show recently listed entities that will say if you own the NFT, you can update the listing.

14984
24:54:53.942 --> 24:54:56.219
If not, you can buy the listing.

14985
24:54:56.219 --> 24:54:57.095
So we'll have that.

14986
24:54:57.095 --> 24:54:58.571
And then we'll have a sell page.

14987
24:54:58.571 --> 24:55:03.114
And in this page, you can list your NFT on the marketplace.

14988
24:55:03.114 --> 24:55:07.137
So these are going to be our two main pages, we're gonna have a homepage and a sell page.

14989
24:55:07.137 --> 24:55:11.292
Now we're going to have a ton of components, but we're really only going to have two main pages.

14990
24:55:11.292 --> 24:55:20.650
So if we go back over to Pages, right, right now we have our apps dot j s, which serves our app, which is cool, which everything runs through.

14991
24:55:20.650 --> 24:55:21.633
And then we have our homepage.

14992
24:55:21.633 --> 24:55:27.797
Let's also create right now, our sell page or selling of T dot j s.

14993
24:55:27.896 --> 24:55:35.831
And then in here, we'll just make this really minimal, that we can copy most of what's in here, we can actually just copy paste this whole thing, paste it in here.

14994
24:55:35.831 --> 24:55:38.896
And instead of high, we'll say sell page.

14995
24:55:38.896 --> 24:55:40.580
We'll save that.

14996
24:55:40.580 --> 24:55:45.605
Now if we go to our localhost do debt slash sell.

14997
24:55:45.605 --> 24:55:48.314
And if T oops, we gotta run.

14998
24:55:48.314 --> 24:55:49.830
Run the front end again.

14999
24:55:49.830 --> 24:55:50.518
With yarn Dev.

15000
24:55:50.518 --> 24:55:52.229
Sorry, we'll run yarn dev again.

15001
24:55:52.229 --> 24:55:53.229
Now we refresh.

15002
24:55:53.229 --> 24:55:55.162
And now we can see sell page.

15003
24:55:55.162 --> 24:55:59.149
So sell pages that slash sell page, and then home is just going to be high.

15004
24:55:59.149 --> 24:55:59.847
Okay, cool.

15005
24:55:59.847 --> 24:56:01.434
So we have our two pages.

15006
24:56:01.434 --> 24:56:06.626
Which one should we work on first? Well, let's work on our homepage.

15007
24:56:06.626 --> 24:56:08.811
So we're going to be in our index.

15008
24:56:08.811 --> 24:56:08.912
js.

15009
24:56:08.912 --> 24:56:16.654
I'm going to keep this front end bit running, we're going to hide it oops, that's the opposite of hiding it, push it down, we're going to hide it like that.

15010
24:56:16.654 --> 24:56:19.025
And let's go ahead and let's start building this.

15011
24:56:19.025 --> 24:56:24.053
So we see in our index js, we have some head stuff here, I'm going to change this to NFT.

15012
24:56:24.053 --> 24:56:25.316
Marketplace.

15013
24:56:25.316 --> 24:56:32.706
Description is going to be just an empty marketplace.

15014
24:56:32.897 --> 24:56:34.574
Like so Fabcon looks great.

15015
24:56:36.897 --> 24:56:39.845
it says NFT marketplace up at the top here, which is good.

15016
24:56:40.897 --> 24:56:41.509
That's what we want.

15017
24:56:42.897 --> 24:56:53.547
first things that we're always going to need to do? You guessed it, we're going to need a little connect button right? We're going to need our users to be able to connect to to web three to connect to a blockchain.

15018
24:56:53.547 --> 24:56:55.388
So same as we've done before.

15019
24:56:55.388 --> 24:56:57.473
Let's go ahead let's create a components folder.

15020
24:56:57.473 --> 24:57:05.054
And we'll create a header component component Nance folder and we'll create a new file The header digests.

15021
24:57:05.054 --> 24:57:13.542
Now remember, since we've done this before, with our front end lottery code, we can always refer back to the lottery code as well when we're building this, okay.

15022
24:57:13.542 --> 24:57:17.634
And of course, we have all of the code for this on the GitHub repo.

15023
24:57:17.634 --> 24:57:28.039
So you can use that to what I'm not going to have you all do is last time, we did that manual header thing, right, where we had to do all the local storage and do all that crazy stuff, we're not going to do that.

15024
24:57:28.039 --> 24:57:32.445
This time, we're going to just do it the easy way, we're going to just use the web three UI kit.

15025
24:57:32.445 --> 24:57:36.230
So to use this connect button, we're going to do yarn, add.

15026
24:57:36.230 --> 24:57:45.388
And we're not going to do dash dash Dev, because this connect button is a necessary component for the front end, yarn add web through UI Kit.

15027
24:57:45.388 --> 24:57:50.117
This also means we're going to do Morales and react mirallas.

15028
24:57:50.117 --> 24:57:53.727
I said, and this is where it might be a little confusing.

15029
24:57:53.727 --> 24:57:59.077
I know I said in here that we have both a Morales and other graph edition.

15030
24:57:59.077 --> 24:58:02.642
So we're still going to use the Morales package in both of them.

15031
24:58:02.642 --> 24:58:07.015
The only difference is we're going to use a Morales server as well in our Morales edition.

15032
24:58:07.015 --> 24:58:18.648
And we're not going to use a morale server on our the graph edition, they're both can use the Morales package because all the open source hooks and tools are still incredibly powerful, even if we don't use the Morales server.

15033
24:58:18.648 --> 24:58:22.270
So we're still going to use the Morales package even when we're going to be using the graph.

15034
24:58:22.270 --> 24:58:22.575
Great.

15035
24:58:22.575 --> 24:58:28.460
So now that we've added those all, we're going to do exactly what we did before on our last next Jas process.

15036
24:58:28.460 --> 24:58:47.139
So in order to use our web through UI component in our app, dot j, s, and do import mirallas provider quotes and without sorry, and curly brace, it's from react mirallas like that.

15037
24:58:47.139 --> 24:58:52.516
And then we're going to wrap our whole component thing in a morass provider.

15038
24:58:52.516 --> 24:59:00.107
So we're gonna do return, little open parentheses, close parentheses here.

15039
24:59:00.107 --> 24:59:03.338
We're gonna do rounds provider.

15040
24:59:03.338 --> 24:59:15.075
And then we're gonna do in if she allies on Mount is going to equal false, because we're not going to use the server yet, or else provider.

15041
24:59:15.075 --> 24:59:15.607
Okay, cool.

15042
24:59:15.607 --> 24:59:30.598
Now that we've wrapped our app in a Morales provider, and go back to our header, we're gonna say Export default function header, we're going to grab our Connect button from what through your eye kit.

15043
24:59:30.598 --> 24:59:36.357
So we'll do import connect button from web three UI kits.

15044
24:59:36.357 --> 24:59:41.635
And then in here, we're just gonna say return.

15045
24:59:41.635 --> 24:59:43.285
The next button.

15046
24:59:43.285 --> 24:59:45.736
Now what we can do back in our app, J.

15047
24:59:45.736 --> 24:59:58.737
S, is we can do import, import, do header from dot dot slash components header, and we have our header, we'll just put our header right above the component.

15048
24:59:58.737 --> 25:00:02.157
And we're going to add some stuff to the header in a bit.

15049
25:00:02.157 --> 25:00:04.320
Let's just make sure that we're importing the header correctly.

15050
25:00:04.320 --> 25:00:05.679
Let's go back to our UI here.

15051
25:00:05.679 --> 25:00:07.833
And okay, boom, we have our connects button.

15052
25:00:07.833 --> 25:00:10.560
If we click it, you know, we'll get this little pop up.

15053
25:00:10.560 --> 25:00:11.678
And I'm way zoomed in.

15054
25:00:11.678 --> 25:00:14.649
So I'm going to anway zoom in.

15055
25:00:14.899 --> 25:00:25.356
Now, what else do we want to put in our header? Well, we're probably going to want to like give this like a name and make this look a little bit nicer, probably going to want to a link as well to our cell NF T page.

15056
25:00:25.356 --> 25:00:27.474
So let's create a navbar.

15057
25:00:27.474 --> 25:00:33.632
So instead of just returning the connect button, put this in parenthesis and we'll have a return some other stuff too.

15058
25:00:33.632 --> 25:00:37.834
So we can use this nav tag, which usually defines like a nav bar.

15059
25:00:37.899 --> 25:00:41.222
So it's really similar to a div, it's just another tag.

15060
25:00:41.899 --> 25:00:43.999
now we'll put everything into this nav tag.

15061
25:00:44.899 --> 25:00:50.899
we can actually make links using the next Jas link tag.

15062
25:00:51.899 --> 25:01:00.011
we can do in this is link allows us to basically connect to different links or URLs in our application, like so.

15063
25:01:00.011 --> 25:01:04.850
So we can do import link from next slash link.

15064
25:01:04.850 --> 25:01:11.823
And in here, let's say if we want it to go to the homepage, we can make a link.

15065
25:01:11.899 --> 25:01:17.149
And we'll say h ref equals slash equals slash.

15066
25:01:18.899 --> 25:01:23.495
this, we would wrap this in an a tag to make it clickable.

15067
25:01:23.899 --> 25:01:28.039
then we could just say something like NFT marketplace.

15068
25:01:28.899 --> 25:01:37.794
save that, we go to our front end, we now we see have a NFT marketplace button that we can click and since we're already at home, we're not going to go anywhere.

15069
25:01:37.794 --> 25:01:43.566
But if we copy this link section, paste it below, and we make another one for cell and f t.

15070
25:01:43.566 --> 25:01:46.232
And we title this cell NF t.

15071
25:01:46.232 --> 25:02:00.900
Now we save we go back to our front end, we now have NFT marketplace and sell NFT if I click sell NF t we now get to the sell page right we'll go back to the homepage sell page flip back and forth.

15072
25:02:00.900 --> 25:02:02.752
Awesome, very exciting.

15073
25:02:02.752 --> 25:02:07.807
So now we have have an incredibly minimalistic header obviously looks terrible.

15074
25:02:07.807 --> 25:02:10.426
So let's do just a little bit of formatting.

15075
25:02:10.426 --> 25:02:12.794
And oftentimes you'll do the formatting last.

15076
25:02:12.900 --> 25:02:20.838
But while we're here, we might as well do our formatting we're going to use what if you guessed tailwind? You guessed correctly.

15077
25:02:20.900 --> 25:02:23.141
So remember, tailwind with.

15078
25:02:23.141 --> 25:02:23.572
Next.

15079
25:02:25.900 --> 25:02:26.779
follow along here.

15080
25:02:28.900 --> 25:02:34.114
thing we did before we'll do yarn, add dash dash Dev, that stuff right there.

15081
25:02:34.114 --> 25:02:37.952
And then we'll run a knit after these finished installing.

15082
25:02:37.952 --> 25:02:42.267
So we'll do yarn, and then paste that in.

15083
25:02:42.267 --> 25:02:43.633
And there we go.

15084
25:02:43.633 --> 25:02:48.166
So now we've got our post CSS config, we've got our tailwind config.

15085
25:02:48.166 --> 25:02:50.099
We're going to grab tailwind.

15086
25:02:50.099 --> 25:02:50.499
config.

15087
25:02:50.499 --> 25:02:50.632
js.

15088
25:02:50.900 --> 25:02:51.915
Paste it in here.

15089
25:02:54.900 --> 25:02:58.833
and open up Global's dot css, paste that in there, and cool.

15090
25:02:58.900 --> 25:03:00.323
Now we have tailwind in here.

15091
25:03:01.900 --> 25:03:05.003
can do some tailwind stuff to our header here.

15092
25:03:05.900 --> 25:03:24.933
create a div for all of these for everything here, we'll create a little div for all the stuff here, we'll make like a big section for almost like a big sign saying, Hey, you're at the NFC marketplace, h1, which stands for header one, and we'll give it a class name of padding y of form.

15093
25:03:24.933 --> 25:03:34.805
Padding x of four, we'll do font bold text will be three XL, and then it'll just say NFT marketplace.

15094
25:03:34.805 --> 25:03:37.454
Now we have this NFT marketplace, which is nice bolt.

15095
25:03:37.454 --> 25:03:37.946
Awesome.

15096
25:03:37.946 --> 25:03:44.377
If you're on your server you're going to kill it's going to kill it with Ctrl C, and then we're going to restart it.

15097
25:03:44.377 --> 25:03:46.805
And that's going to pull in all the tailwind stuff.

15098
25:03:46.901 --> 25:03:58.722
And now if we refresh our local main, we should now see okay, and if T and F c, r gets place, right, we now see this and big and bold, which looks a lot better.

15099
25:03:58.722 --> 25:03:59.793
So let's keep going.

15100
25:03:59.901 --> 25:04:02.409
Let's give our whole nav a class name.

15101
25:04:03.901 --> 25:04:16.064
padding of five, border bottom to flex flex row justify just if between n items center.

15102
25:04:16.064 --> 25:04:18.523
We'll see how that looks.

15103
25:04:18.523 --> 25:04:20.511
Haha, looks a lot better.

15104
25:04:20.511 --> 25:04:27.460
We're now kind of like setting this up with a bottom border kind of stick and some stuff like this, that looks much much nicer already.

15105
25:04:27.460 --> 25:04:28.748
Let's go down here.

15106
25:04:28.748 --> 25:04:36.336
Let's make our buttons have a class name equals lax lax row items center.

15107
25:04:36.336 --> 25:04:39.863
And like I said, this is not a styling class.

15108
25:04:39.863 --> 25:04:43.432
So we're not really going to go over exactly how we're styling this.

15109
25:04:43.432 --> 25:04:44.251
And that is okay.

15110
25:04:44.251 --> 25:04:47.918
But that's going to move that over make that look a little nicer.

15111
25:04:47.918 --> 25:04:52.074
We'll give our link here, a class name equals Mr.

15112
25:04:52.074 --> 25:04:52.936
For P six.

15113
25:04:52.936 --> 25:05:03.764
And we'll give both of these the same class name both these links, give them some padding, so they moved away from each other some margin to the right, so they're away from each other.

15114
25:05:03.764 --> 25:05:08.252
And oh, I forgot to do this Morales off equals false.

15115
25:05:08.252 --> 25:05:17.687
We need Morales auth equals false so that we don't automatically connect to a Morales database or try to connect to Morales database, when we connect, we want to just connect with our Metamask.

15116
25:05:17.687 --> 25:05:20.768
And we'll change this to home instead of the marketplace.

15117
25:05:20.768 --> 25:05:24.368
But otherwise, that looks pretty good home selling of T Connect button.

15118
25:05:24.368 --> 25:05:28.552
And we can adjust the formatting of this to make it look a little different.

15119
25:05:28.552 --> 25:05:34.964
But I think for the most part, this looks much better, right? Alright, cool, much, much better looking header.

15120
25:05:34.964 --> 25:05:36.581
Here, we have our app.

15121
25:05:36.581 --> 25:05:39.683
js setup with the mouse provider headers components.

15122
25:05:39.683 --> 25:05:42.104
Let's now move on to our index.

15123
25:05:42.104 --> 25:05:47.838
Let's now move on to showing these NF T's showing all the NF T's in our marketplace.

15124
25:05:47.902 --> 25:05:52.473
And here's where it's going to already start to heat up and get really interesting.

15125
25:05:52.473 --> 25:05:56.886
And actually one more thing, we're going to grab this headpiece in the index if you haven't.

15126
25:05:56.886 --> 25:06:00.783
And we're just going to have it be in the app JSX.

15127
25:06:00.783 --> 25:06:02.562
So yeah, and our app.

15128
25:06:02.562 --> 25:06:08.281
js we're going to put that header up at the top, and just put a little, little div, Div.

15129
25:06:08.281 --> 25:06:12.789
div, like so wrapping around this whole thing.

15130
25:06:12.789 --> 25:06:13.998
This goes here.

15131
25:06:13.998 --> 25:06:19.521
And this way, no matter what page we're on, we're always going to have this as our header.

15132
25:06:19.521 --> 25:06:21.870
And we don't have to define it each one of our little our things here.

15133
25:06:21.902 --> 25:06:23.256
So we'll do a refresh.

15134
25:06:23.256 --> 25:06:25.320
And it says head is not defined.

15135
25:06:25.902 --> 25:06:29.919
that's because we're going to need to copy import head from next slash head.

15136
25:06:29.919 --> 25:06:33.666
Paste it into our app that Jas import head from next head.

15137
25:06:33.666 --> 25:06:38.837
And now we can see we're going to empty marketplace no matter what page we're on, because we're defining it at our app level.

15138
25:06:38.837 --> 25:06:44.225
We have the header in here, we have this stuff in here, index almost has nothing in it now.

15139
25:06:44.225 --> 25:06:45.169
Let's do this.

15140
25:06:45.169 --> 25:06:51.066
So what do we want to do? We want the homepage aka our index to show recently listed NFT.

15141
25:06:51.066 --> 25:06:55.699
So the question is, how do we show the recently listed NF Ts.

15142
25:06:55.699 --> 25:07:00.804
How do we do that? Well, let's go back to our contract.

15143
25:07:00.804 --> 25:07:11.379
We go back to our hard hat NFT marketplace So we're looking at at the marketplace, what do we have in here? How do we actually see where NFT is stored? Well, they're stored in this listings mapping.

15144
25:07:11.379 --> 25:07:30.103
However, how do we see all of the listings that are in here? Well, this is a mapping, which means we have every single address on the planet in here, we can't loop through the mapping, we'd have to loop through every single address on the planet, which is some insanely large number that you and I could never fathom how many addresses there are.

15145
25:07:30.103 --> 25:07:36.785
So what are some solutions that we can take to this problem, right? Because we're obviously not going to loop through everything.

15146
25:07:36.785 --> 25:07:48.639
So what do we do? What's what's kind of the first approach, one of the first approaches would be like, alright, Patrick, well, why don't we just create an array, an array of listings instead, and this might be a good approach.

15147
25:07:48.639 --> 25:07:59.745
But what if then later on, we also want to get some other weird data, maybe we want to get all the NF t's a user owns NF t's a user owns, there's no array of NF T's that a user owns.

15148
25:07:59.745 --> 25:08:02.236
Again, that's just a mapping.

15149
25:08:02.236 --> 25:08:15.904
But what if we want to query some other weird data, or query some other weird data, or what if an array will be very gas expensive, which it is, if we make this an array to loop through, it'll be incredibly gas expensive.

15150
25:08:15.904 --> 25:08:18.182
So we don't want to have to go back and change.

15151
25:08:18.182 --> 25:08:20.356
So I'm going to I'm going to type this out.

15152
25:08:20.356 --> 25:08:21.827
Because this is important.

15153
25:08:21.827 --> 25:08:33.808
We don't want to change our protocol for just the website, we don't want to change our protocol for just the website, or we don't want to much change our protocol for the website.

15154
25:08:33.808 --> 25:08:38.454
Because if we were to make this an array, it would become incredibly gas inefficient.

15155
25:08:38.454 --> 25:08:43.516
And it would become much harder to use this NFT marketplace because it would be so much more expensive.

15156
25:08:43.516 --> 25:08:51.822
And as you build more and more complex protocols, you're going to realize that having an array for every single mapping you have isn't feasible.

15157
25:08:51.822 --> 25:08:56.281
This is one of the reasons where these events come into play.

15158
25:08:56.281 --> 25:09:02.463
So every single time we list an NF t, we call this list item function.

15159
25:09:02.463 --> 25:09:11.836
And we omit item listed, this item listed event is stored in a data structure that's still on chain, but just smart contracts can access it.

15160
25:09:11.836 --> 25:09:17.395
However, guess what can't access it off chain services can access these events.

15161
25:09:17.395 --> 25:09:28.348
So what we do in this case, is what we're going to do is we will index the events off chain and then read from our database.

15162
25:09:28.348 --> 25:09:35.887
So what we're literally going to do is we're going to set up a server to listen for those events to be fired, fired.

15163
25:09:35.887 --> 25:09:39.493
And we will add them to a database to query.

15164
25:09:39.493 --> 25:09:47.838
So yes, we're literally going to take every single time an item is listed, we're going to index it in a database for ourself.

15165
25:09:47.904 --> 25:09:53.589
And then we're going to call our centralized database to start and we're going to call that database to do that.

15166
25:09:53.589 --> 25:10:04.840
Now the question then becomes Whoa, isn't that centralized? Hey, Patrick, we're talking isn't that centralized? What the Hickety heck, and the answer to that is, it's not necessarily.

15167
25:10:04.905 --> 25:10:08.343
So the graph is a protocol that does exactly this.

15168
25:10:08.905 --> 25:10:15.146
protocol that indexes events off chain, and sticks them into this the Graph Protocol.

15169
25:10:15.146 --> 25:10:35.476
And it does it in a decentralized way, Morales, the way we're going to show you first does it in a centralized way, Morales is going to do it in a centralized way, which might be the route that you want to go for speed for extra bells and whistles, so that you can do local development, which is what we're going to be focusing on here, or any of the other functionality that Morales comes with.

15170
25:10:35.476 --> 25:10:37.837
Because Morales does a lot more than just that.

15171
25:10:37.837 --> 25:10:47.869
That's something to keep in mind too, is even though we are adding a centralized component, or logic, our smart contracts, the real bulk of this application is decentralized.

15172
25:10:47.869 --> 25:11:01.857
And you can verify all your interactions are working with this decentralized smart contract, we've actually been using a lot of protocols that are centralized, like ether scan, like open see, and some of these centralized protocols are really important to this space.

15173
25:11:01.905 --> 25:11:10.842
So we're showing you Morales to get you familiar with working with one of these centralized servers, in case you optionally want to make an application that provides a centralized service.

15174
25:11:10.905 --> 25:11:19.114
And there's a ton of tools in the space like opens up and defender tenderly and more, that are centralized, but give us massive, massive benefits.

15175
25:11:19.114 --> 25:11:22.262
We as a community are bringing more and more things to being decentralized.

15176
25:11:22.262 --> 25:11:24.773
And sometimes we need some training wheels to get there.

15177
25:11:24.773 --> 25:11:31.387
And then the graph is going to be the decentralized way, which is a bit of a longer process to go main net, but we'll explain all that when we get there.

15178
25:11:31.387 --> 25:11:36.397
Let's learn how we can list the most recently listed NF T's and Morales in the graph.

15179
25:11:36.397 --> 25:11:41.551
Both have some really solid videos, I'm going to leave some links in the GitHub repo associated with this.

15180
25:11:41.551 --> 25:11:49.206
So if you want to learn more, you should definitely watch both of those because they are absolutely fantastic and will help you understand this event stuff better.

15181
25:11:49.206 --> 25:11:58.772
So normally, when we read from the blockchain, we do something like contract dot get, get listing, you know, and then we put it whatever our input parameters are.

15182
25:11:58.772 --> 25:12:05.856
Contract double blah, so instead, so we're going to read from a database that houses All the mappings and an easier to read data structure.

15183
25:12:05.906 --> 25:12:11.734
Both Morales and the graph do this.

15184
25:12:11.906 --> 25:12:13.872
We've been using the morass, open source packages and tools.

15185
25:12:13.906 --> 25:12:20.855
However, Morales also comes optionally with a server back end to give your web three applications more functionality.

15186
25:12:20.906 --> 25:12:26.560
However, there's a ton of stuff that we're not going to cover that Morales can do to help build your web three applications.

15187
25:12:26.560 --> 25:12:37.112
So instead of me continuing to talk about Morales, and what it can do, we have Ivan here to give a brief overview of some of the other things that Morales can do take it away, and my name is Ivan, I'm from rallis.

15188
25:12:37.112 --> 25:12:51.561
And I'm here to tell you how you can speed up your development by 10 times and I'm not over exaggerating, when you're building something, you want to ensure that is scalable, because your DAP may go global, it may get viral, it may go mainstream, it can happen.

15189
25:12:51.561 --> 25:13:00.388
And if it happens, you don't want to start from scratch, you want to use tools and services that allow you to go fast, and also to go big.

15190
25:13:00.388 --> 25:13:02.638
And that's exactly what mirallas provides.

15191
25:13:02.638 --> 25:13:03.487
At mirallas.

15192
25:13:03.487 --> 25:13:14.117
We create tools, we create infrastructure for developers in a way that you have a single workflow, and they will soon explain what it means because this is what saves you time.

15193
25:13:14.117 --> 25:13:16.590
If you have a single workflow for doing things.

15194
25:13:16.590 --> 25:13:30.841
And workflow in web three really means that you have to have a smart contract, whether it's a token, the game, some kind of staking some kind of marketplace, some kind of defy, it will be on chain, but at the same time, you have to connect it to your back end.

15195
25:13:30.841 --> 25:13:34.068
Because when something happens on chain, you need to monitor that.

15196
25:13:34.068 --> 25:13:48.446
So you can create web hooks, you can create email, you can create a push notification, you can run some custom code, you can run some calculation, you can save something to the database, everything on chain at the end of the day needs to go into our back end.

15197
25:13:48.446 --> 25:13:51.626
And when something is in your back end, it needs to go to the front end.

15198
25:13:51.626 --> 25:13:56.757
So for example, you change the UI when something happens on chain or you change the UI.

15199
25:13:56.757 --> 25:14:00.611
If your user receives a transfer there is above a specific threshold.

15200
25:14:00.611 --> 25:14:08.165
Or if your user has this NFC, you can allow them access into some kind of chat or some kind of exclusive piece of content.

15201
25:14:08.165 --> 25:14:19.152
So at Morales, we provide you with a full stack suite of tools that is used by over 100,000 developers, it's really becoming one of the most adopted tech stacks in web three.

15202
25:14:19.152 --> 25:14:29.347
And it all starts with Morales identity, which ensures that you get one piece of code, you write one piece of code and you can log in your users across different blockchains across different wallets.

15203
25:14:29.347 --> 25:14:34.245
And in your morale is dashboard, you will get the user profile, and you will get a web session.

15204
25:14:34.245 --> 25:14:41.480
So mirallas allows you to manage identities because a user profile can have many different wallets from many different chains connected to it.

15205
25:14:41.480 --> 25:14:48.326
And all of the transactions will be synced from that user, all the real time transactions will be synced about that user.

15206
25:14:48.326 --> 25:15:02.376
And also, you have established web session between your front end whether it is a game, whether it is a web website, we ensure that you have secure authenticated web sessions, and we provide you with session management.

15207
25:15:02.376 --> 25:15:12.783
So in case you have your own bike, and then you have mirallas session identity management, you can invalidate sessions, you can log in users and do all of that great, all of these great things with one line of code.

15208
25:15:12.783 --> 25:15:13.814
That's very important.

15209
25:15:13.908 --> 25:15:17.845
Number two is Morales real time I already mentioned a bit of it.

15210
25:15:17.908 --> 25:15:20.908
But basically when you have a user, you know exactly what's going on in real time.

15211
25:15:20.908 --> 25:15:33.844
You can run custom code, whenever a user does a transaction, you can run custom code or do a web hook or email or push notification whenever a user interacts with a smart contracts or when a smart contract simply emits an event.

15212
25:15:33.908 --> 25:15:42.627
This can be an trade in an NFC marketplace, this can be ERC 20 transfer, you can be very flexible by setting filters.

15213
25:15:42.627 --> 25:15:49.369
So you can say only give me alerts only give me web hooks when the user transfers more than 10 NFCs.

15214
25:15:49.369 --> 25:15:53.701
Or when this token transfer is above $1,000, and so on so forth.

15215
25:15:53.701 --> 25:15:57.858
This is morale is real time very, very powerful things.

15216
25:15:57.858 --> 25:15:59.743
Next are mirallas SDKs.

15217
25:15:59.908 --> 25:16:16.527
So whether you're building a website, whether you're building a game where full integration with game engines, whether you're building for some other platform, we have extensive SDKs that are easy to use that allow you to do all of this that allow you to connect to Morales and do this very, very easily.

15218
25:16:16.527 --> 25:16:22.447
And if you go to our documentation, which I highly recommend you to do, you go to Morales, Doc's dot morales.

15219
25:16:22.447 --> 25:16:27.609
io, if you go to Doc's dot, Marisa Yo, you will first and foremost understand what mirallas is in depth.

15220
25:16:27.609 --> 25:16:34.892
So you can think of it kind of like Firebase, but for crypto, basically, it's a managed backend, that you can connect your front end.

15221
25:16:34.892 --> 25:16:39.102
Also, you can connect it to your own back end using no GS SDK, it's very, very easy.

15222
25:16:39.102 --> 25:16:41.666
But what I wanted to show you here is cross platform.

15223
25:16:41.666 --> 25:16:52.477
So for each thing we have, let's say you want to get nfts for your user, we'll show you how to do it in simple JavaScript, vanilla JavaScript, how to do it and react, how to do it using a web request.

15224
25:16:52.477 --> 25:16:55.253
Let's say that you just want to use a raw web request.

15225
25:16:55.253 --> 25:17:02.775
Let's say you're using some kind of language that we don't have SDK for you still can use Morales just that you have to call the raw HTTP request.

15226
25:17:02.775 --> 25:17:07.400
And we'll also show you how to do it in Unity using C sharp in Unity game engine.

15227
25:17:07.400 --> 25:17:10.330
So we're very, very clear cross platform.

15228
25:17:10.330 --> 25:17:12.126
And we are cross chain.

15229
25:17:12.126 --> 25:17:29.271
So this means for example, when you log in the user, you can create the user profile where you have the lambda address, let's say your user uses Solana then they can easily connect Aetherium, they can easily connect Binus chain, the end, we're gonna add more chain soon, they can easily connect L Ron, to one user profile.

15230
25:17:29.271 --> 25:17:35.597
And then you have all kinds of different wallets, different chains, and you have one single user profile one single user ID.

15231
25:17:35.597 --> 25:17:38.940
This is, by the way, how it will look like in your database.

15232
25:17:38.940 --> 25:17:45.859
As you can see, you're going to have a user user table right here, you're going to have all of their accounts.

15233
25:17:45.909 --> 25:17:47.531
So in this case, I only have eath.

15234
25:17:48.909 --> 25:17:52.591
have other types of blockchains, it will all be right here.

15235
25:17:52.909 --> 25:17:56.210
this is a database that also has all my transactions.

15236
25:17:56.909 --> 25:18:01.489
database where I can set up different listen events or smart contracts.

15237
25:18:01.489 --> 25:18:05.840
So for example, open see I can watch open see smart contracts or something else.

15238
25:18:05.840 --> 25:18:08.417
And it's very, very variable, because this is MongoDB.

15239
25:18:08.417 --> 25:18:12.813
This is MongoDB, you can run MongoDB queries, it's very, very variable.

15240
25:18:12.813 --> 25:18:20.624
So in that sense, mirallas gives gives you a nice, nice dashboard with everything you need to know about your users, their sessions, their permissions, and so on, so forth.

15241
25:18:20.624 --> 25:18:25.299
And of course, you can connect to your own back end using the Node js SDK.

15242
25:18:25.299 --> 25:18:26.926
So this is Morales SDKs.

15243
25:18:26.926 --> 25:18:39.410
And finally, when we're speaking about the workflow, the final thing is the API's, which I also already showed you, but the API is that you can do RAW requests from any programming language from any kind of architecture.

15244
25:18:39.410 --> 25:18:43.648
So using this workflow, you can easily achieve anything you want very, very quickly.

15245
25:18:43.648 --> 25:18:47.345
You really have to try Morales it is it will change your life.

15246
25:18:47.345 --> 25:18:49.812
I can explain here all I want, I have limited time.

15247
25:18:49.910 --> 25:19:01.435
But as you can already see, by this presentation, you're very curious, as you already can see, by this presentation, you want to try this as you already feel by watching me here, you are very, very excited.

15248
25:19:01.435 --> 25:19:04.146
We have to get your hands dirty.

15249
25:19:04.146 --> 25:19:13.073
So go, number one, two dogs, authorize the sale, and go here getting started connector SDK in vanilla or react and go through all of this.

15250
25:19:13.073 --> 25:19:14.175
See the magic for yourself.

15251
25:19:14.175 --> 25:19:20.877
And if you want practicalities, go to youtube channel and go to morality Oh, slash projects, guys, you all in the community.

15252
25:19:20.877 --> 25:19:25.592
Using Morales, you will succeed using rallies, you will achieve your goal.

15253
25:19:25.592 --> 25:19:28.496
And you're going to do sooner than you expect yourself.

15254
25:19:28.496 --> 25:19:30.469
You're gonna surprise yourself.

15255
25:19:30.469 --> 25:19:32.367
But don't let yourself down.

15256
25:19:32.367 --> 25:19:33.347
Go to morales.

15257
25:19:33.347 --> 25:19:35.910
io sign up, get started, you guys.

15258
25:19:35.910 --> 25:19:46.176
Now that I've explained all of that, what does this look like? Well, this is where we're actually going to start using mirallas with its server capabilities.

15259
25:19:46.176 --> 25:19:48.082
And we're going to sign up for a server here.

15260
25:19:48.082 --> 25:19:51.730
And we're going to use Morales as our back end for our application.

15261
25:19:51.730 --> 25:19:54.577
So to get set up with Morales, we go to morales.

15262
25:19:54.577 --> 25:19:54.688
io.

15263
25:19:54.688 --> 25:19:56.995
We can go ahead and sign up for free.

15264
25:19:56.995 --> 25:20:00.462
We'll put our email in, we'll create some password.

15265
25:20:00.462 --> 25:20:06.339
Why are you here? Other please specify Patrick's amazing hardhat video, you don't have to write that.

15266
25:20:06.339 --> 25:20:08.149
But if you want to write that you can.

15267
25:20:08.149 --> 25:20:17.376
What did you hear about Morales for the first time? Well, you all heard about it on YouTube, because you heard it from me, and then pick your roll, I'm going to be a developer, we'll hit next, I don't want to subscribe.

15268
25:20:17.376 --> 25:20:20.249
But I'm going to not be a robot and create your account.

15269
25:20:20.249 --> 25:20:23.661
And it even gives us a little property or create your first server.

15270
25:20:23.661 --> 25:20:28.063
So our back end is going to use a server to do any stuff on the back.

15271
25:20:28.063 --> 25:20:29.757
So we'll create a server.

15272
25:20:29.757 --> 25:20:33.152
And if we were going to do a main net or a testament, we choose one of those.

15273
25:20:33.152 --> 25:20:35.813
But for now we're going to do a local dev chain server.

15274
25:20:35.911 --> 25:20:41.536
And again, this is one of the advantages of Morales is it allows us to work with our local dev chain.

15275
25:20:41.536 --> 25:20:53.720
For indexing events, we can actually index our events from our local hard hat node, which is incredibly, incredibly powerful here, so check your email, and we'll have an activate my account thing, email, we'll hit activate your account.

15276
25:20:53.720 --> 25:20:56.873
And it'll bring us back here and we'll recreate and we'll do local dev chain.

15277
25:20:56.911 --> 25:21:00.428
Alright, so now we're going to create a new local dev chain server.

15278
25:21:00.428 --> 25:21:07.758
So we're going to call this NFT marketplace, we're going to select the region, whatever region you want, I'm in the eastern United States.

15279
25:21:07.758 --> 25:21:08.842
So I'm going to choose New York.

15280
25:21:08.911 --> 25:21:13.729
But whatever location works for you, we're gonna do local dev chain, and we're going to do eath, local dev chain.

15281
25:21:13.729 --> 25:21:23.394
And again, if you're building for polygon, if you're building for avalanche, if you're building for Phantom, if you're building for any of these EVM compatible chains, again, your eath local dev chain, it's going to work exactly the same.

15282
25:21:23.394 --> 25:21:25.007
So we're going to add instance now.

15283
25:21:25.007 --> 25:21:27.911
And we're going to create a new application here.

15284
25:21:27.911 --> 25:21:32.670
So we're going to close now we have the server here, and it says ganache, but it's really hard hat.

15285
25:21:32.670 --> 25:21:33.428
Don't worry about that.

15286
25:21:33.428 --> 25:21:40.745
Now that we have our server up, we can go to the Morales documentation, what we're looking for is events, we're looking to sync with events.

15287
25:21:40.745 --> 25:21:44.472
So we can even do a little search in here for events.

15288
25:21:44.472 --> 25:21:52.123
And we see smart contract events platform Automatic Sync, and even tells us a little bit more about why do we need to sync and watch smart contract events.

15289
25:21:52.123 --> 25:21:56.864
So basically, this server our database is going to be looking for these events to be emitted.

15290
25:21:56.912 --> 25:22:10.234
But before we can do that, we need to hook up our application to our server and if you go to the React Morales GitHub right at the top And you'll probably see saw this before, when you have this Morales provider in their docks, they actually pass an app ID and a server URL.

15291
25:22:10.234 --> 25:22:15.271
And this is how we can actually connect directly to our servers on mirallas.

15292
25:22:15.271 --> 25:22:23.153
So what we're gonna do is right, now we're gonna go back to our app that Jas and originally we've been saying initialize on Mount equals false.

15293
25:22:23.153 --> 25:22:30.365
When we say this, we're saying, Hey, we're not going to use a morale server, we're just going to use the open source morass tools that y'all provide.

15294
25:22:30.365 --> 25:22:35.404
Now, we actually do want to use their server, right, we do want to use all these bells and whistles that Morales comes with out of the box.

15295
25:22:35.404 --> 25:22:36.662
So we're going to change that.

15296
25:22:36.662 --> 25:22:41.420
So instead of saying initialize on Mount equals false, we're just getting ready with the app ID and the server URL.

15297
25:22:41.420 --> 25:22:42.945
So we're going to delete this.

15298
25:22:42.945 --> 25:22:47.673
And just like it says, in the documentation, we're gonna give it an app ID and a server URL.

15299
25:22:47.673 --> 25:22:51.740
So we're gonna say app ID equals, and this is where as a string, we'll put our app ID.

15300
25:22:51.740 --> 25:22:55.827
So if we go back to our Morales database, we can go to view details.

15301
25:22:55.827 --> 25:22:58.412
And we see all this information in here.

15302
25:22:58.412 --> 25:23:02.782
And we can grab our application ID, we can copy it, paste it in here.

15303
25:23:02.782 --> 25:23:07.296
And then we'll want to grab our server URL, which is at the top.

15304
25:23:07.296 --> 25:23:11.525
So this is the URL of our unique custom morale server.

15305
25:23:11.525 --> 25:23:15.879
So we'll say server, URL equals and then paste that in there like that.

15306
25:23:15.879 --> 25:23:24.257
Now, if you've been following along with these tutorials, you might be thinking oh, we're we're kind of just hard coding that stuff right in there like that, how that seems kind of that seems kind of bad.

15307
25:23:24.257 --> 25:23:26.946
Well, if that's your intuition, that is fantastic.

15308
25:23:26.946 --> 25:23:29.600
So instead, we're actually going to put these into environment variables.

15309
25:23:29.600 --> 25:23:33.355
So we're going to create a new file, a dot env file.

15310
25:23:33.355 --> 25:23:36.558
And this is where we're going to put all of our environment variables.

15311
25:23:36.558 --> 25:23:46.984
Now next, Jas comes with built in support for environment variables, which allow you to do the following use dot env, dot local to load environment variables or those environment variables to the browser by prefixing.

15312
25:23:46.984 --> 25:23:48.644
It with next underscore public.

15313
25:23:48.644 --> 25:23:51.257
So there's a couple of different environment variable paths we can use.

15314
25:23:51.257 --> 25:23:57.343
We can do dot env, dot local, we can do dot env, dot this dot that that the other thing, we're just going to do dot env, to keep it simple here.

15315
25:23:57.343 --> 25:24:13.850
But in order for our front ends, to read environment variables from our dot env file, we have to do next underscore public underscore, and next Jas will look into our dot env file for variables that start with this and only stick these environment variables into our application.

15316
25:24:13.913 --> 25:24:23.403
If we were to just do like Morales server equals blah, blah, blah, it has no idea what this is because we need to do next underscore public underscore.

15317
25:24:23.403 --> 25:24:28.538
And if we do that, and we'll do a console dot log, look here, process dot env.

15318
25:24:28.538 --> 25:24:32.404
Next public morale server and we actually need to kill it and restart it.

15319
25:24:32.404 --> 25:24:40.646
And then we go back, we do a little refresh here, it'll say Look here as a do bla bla bla, because that's what is in the dot env file with that next public.

15320
25:24:40.646 --> 25:24:44.246
So we'll grab our app ID, we'll copy it.

15321
25:24:44.246 --> 25:24:51.828
And then our dot env will do next public app ID equals and we'll paste that in there.

15322
25:24:51.828 --> 25:24:55.914
We'll grab our server URL, we'll go back to here.

15323
25:24:55.914 --> 25:25:01.602
We'll do next public server URL equals, we'll paste that like that.

15324
25:25:01.602 --> 25:25:05.625
And now at the top, we'll say const.

15325
25:25:05.625 --> 25:25:12.914
App ID equals process dot E and V dot next, public app ID.

15326
25:25:12.914 --> 25:25:15.545
And then we'll say const.

15327
25:25:15.545 --> 25:25:22.802
Server URL equals process dot E and V dot next public server URL.

15328
25:25:22.802 --> 25:25:28.826
Now that we've had these variables, we'll stick them in like this.

15329
25:25:28.914 --> 25:25:33.229
So this is how we can connect our application to our morale server.

15330
25:25:33.229 --> 25:25:35.597
Now, of course, we haven't done anything yet.

15331
25:25:35.597 --> 25:25:38.543
But we're getting started, right? This is how we're going to connect to it.

15332
25:25:38.543 --> 25:25:43.520
Now that we've signed in, well, I told you that our morale server was going to be indexing our events.

15333
25:25:43.520 --> 25:25:46.864
And if you go to this Dashboard button, this is our entire database.

15334
25:25:46.914 --> 25:25:50.010
Everything in this browser tab is what's in our database right now.

15335
25:25:50.010 --> 25:25:56.117
And as you can see, right now, there's not a whole lot of anything, if we had any events data in here, it would be in here.

15336
25:25:56.117 --> 25:25:59.897
So we need to tell our server, hey, you need to start listening for events.

15337
25:25:59.897 --> 25:26:02.314
So we can show the most recently listed entities.

15338
25:26:02.314 --> 25:26:09.075
So morale server, you need to start listening, you need to create a database entry for every single one of these item listed events.

15339
25:26:09.075 --> 25:26:16.986
And whenever somebody buys an item, right, whenever somebody buys that item, or cancels an item, you need to remove that from your database.

15340
25:26:16.986 --> 25:26:24.553
How do we start telling Morales to start listening to our events? Well, first off, well, first off, we're gonna need to connect it back to to our blockchain.

15341
25:26:24.553 --> 25:26:31.098
And then we're going to say, which contract which events and what to do when it hears those events.

15342
25:26:31.098 --> 25:26:34.570
So we need to connect it and then we need to tell it what to do when it hears those events.

15343
25:26:34.570 --> 25:26:39.690
So how do we connect our mirallas server to our hard hat blockchain? And right now, we're not running one.

15344
25:26:39.690 --> 25:26:44.415
But let's go ahead and we'll start up our hard hat, our local host blockchain.

15345
25:26:44.415 --> 25:26:50.355
So in one terminal, we're running the front end and another terminal will see the download directory.

15346
25:26:50.355 --> 25:26:58.022
We'll cd into our hard hat NFT marketplace dot Free Code Camp or Free Code Camp, and we'll do yarn hard hat node.

15347
25:26:58.022 --> 25:27:02.259
And if we've done everything correctly, it'll deploy our NFT marketplace.

15348
25:27:02.259 --> 25:27:07.656
It'll deploy our Basic NFT and then it'll start local HTTP web socket at blah, blah, blah.

15349
25:27:07.656 --> 25:27:08.264
So that's good.

15350
25:27:08.264 --> 25:27:15.315
So now that we have that Node running, what we can do is we can go to view details, and go to dev chain proxy server.

15351
25:27:15.315 --> 25:27:23.125
So this dev chain proxy server is going to be how we actually tell Morales to listen to our locally running hard hat node.

15352
25:27:23.125 --> 25:27:29.222
Now, to do this, what you're going to need to do is we're going to need to download this what's called a reverse proxy.

15353
25:27:29.222 --> 25:27:37.107
And I have a link to this in the GitHub as well, depending on what computer you're running on will tell you which one of these we actually need to download.

15354
25:27:37.107 --> 25:27:49.406
And then there's some troubleshooting tips down here if you ever get lost, and if you're really, really confused, what we can do what Morales FRP to download, do a quick search on this.

15355
25:27:49.406 --> 25:27:59.515
We even come right to the documentation, connecting ganache to Morales note for Mac users download FRP dot Darwin dot bla bla bla for the nosh proxy server.

15356
25:27:59.515 --> 25:28:00.315
So I'm on a Mac.

15357
25:28:00.315 --> 25:28:02.767
So I'm going to download this Darwin AMD 64.

15358
25:28:02.767 --> 25:28:07.415
And for look at the releases, that's the first one at the top, Darwin AMD 64.

15359
25:28:07.415 --> 25:28:10.850
So this is the one that I'm going to go ahead and download.

15360
25:28:10.915 --> 25:28:13.115
I'm gonna click it, I'm going to download it.

15361
25:28:13.916 --> 25:28:18.752
downloaded, we're going to open it up, and we're gonna get a folder and we're gonna get a folder that looks like this.

15362
25:28:18.752 --> 25:28:24.109
The main things that we need are going to be f RP and FRP C dot ini.

15363
25:28:24.109 --> 25:28:35.169
F RPC is going to be the executable it's going to be what we're going to run to connect our blockchain node to Morales, and F RPC dot ini is going to be basically the config file to do this.

15364
25:28:35.169 --> 25:28:40.549
Now, again, this is one of the sections where downloading this is going to be one of the hardest steps here.

15365
25:28:40.549 --> 25:28:48.541
So if you get lost, please ask questions in the GitHub, please ask questions in the Morales forum, there is a Morales forum as well, where you can ask a ton of different questions.

15366
25:28:48.541 --> 25:28:50.677
And please check out the troubleshooting as well.

15367
25:28:50.677 --> 25:28:56.150
But what I'm going to do is I'm going to create a new folder in here new folder called F R P.

15368
25:28:56.150 --> 25:28:58.821
And I'm doing it in here just to make it a little easier.

15369
25:28:58.916 --> 25:29:02.737
But you could really put this wherever you want, and then always refer back to it.

15370
25:29:02.737 --> 25:29:09.555
And what I'm going to do is I'm going to take I'm going to copy these two files, and place it into this FRP folder.

15371
25:29:09.555 --> 25:29:23.968
So now I have FRP C, and F RPC that ini if you click on the F RPC, it's going to be like, hey, it's binary, you can't really look at this, don't click that, it'll just be a whole bunch of nonsense, but the F RPC dot ini looks like a pretty typical config file.

15372
25:29:23.968 --> 25:29:26.443
And this is what we're going to adjust.

15373
25:29:26.443 --> 25:29:31.836
If we even go back to our morale server, it'll give you what you need down here.

15374
25:29:31.836 --> 25:29:33.416
And we're using hard hat.

15375
25:29:33.416 --> 25:29:35.853
So we're going to copy everything here.

15376
25:29:35.853 --> 25:29:41.566
We're gonna go back to our F RPC dot ini, and then just paste whatever is in there in here.

15377
25:29:41.566 --> 25:29:45.254
And that's how we're going to tell this F RPC thing that we need to connect.

15378
25:29:45.254 --> 25:29:47.536
I haven't tried this out for users using WsL.

15379
25:29:47.536 --> 25:29:57.057
So if you're using WsL, let us know in the full blockchain solidity course, Jas, make a new discussion, if you haven't seen it already, saying, Hey, I'm using WsL for the F RPC.

15380
25:29:57.057 --> 25:29:58.557
And here's what you need to use.

15381
25:29:58.557 --> 25:30:01.142
And then at the bottom, it says, run and enjoy.

15382
25:30:01.142 --> 25:30:07.297
I'm running on a Mac OS, which runs Linux commands, so I can just copy this, I'll create a new terminal.

15383
25:30:07.297 --> 25:30:10.794
And what I'm going to do is I'm going to cd into that FRP folder.

15384
25:30:10.794 --> 25:30:16.390
And I'm going to paste that thing that I just that I just copied from Ross.

15385
25:30:16.390 --> 25:30:22.135
So we're running that F RPC executable dash c, which is dash config, F RPC dot ini.

15386
25:30:22.135 --> 25:30:31.158
If I hit Enter, it's gonna say log into server success, get run ID, blah, blah, server, UDP port, and then a whole bunch of other stuff.

15387
25:30:31.158 --> 25:30:34.450
If you're seeing success stuff here, that means you did it right.

15388
25:30:34.450 --> 25:30:39.117
And you can hit CTRL C to cancel because we're not going to keep running it.

15389
25:30:39.117 --> 25:30:41.817
Now, if you want to just run this, you absolutely can.

15390
25:30:41.817 --> 25:30:44.472
But I'm going to show you another way to do this.

15391
25:30:44.472 --> 25:30:47.646
And this is using the Morales admin CLI.

15392
25:30:47.646 --> 25:30:56.317
So everything that we're doing here, all these buttons that we're pressing, Morales actually comes with this thing called the Morales admin CLI or the command line interface.

15393
25:30:56.317 --> 25:31:02.547
So this is a way for us to connect and run all these buttons and stuff that we're pressing right from our terminal and right from our shell.

15394
25:31:02.547 --> 25:31:06.338
So I'm going to show you a couple of commands on how to work with the admin CLI.

15395
25:31:06.338 --> 25:31:09.338
And we're going to be working with a lot of admin CLI commands.

15396
25:31:09.338 --> 25:31:14.850
But all we're going to do is npm install dash g Morales, admin CLI or for us yarn Global Add.

15397
25:31:14.850 --> 25:31:21.802
So we're going to grab that will do yarn, Global Add routes, admin CLI like that.

15398
25:31:21.802 --> 25:31:28.345
And now we should be able to run Morales admin CLI and see a whole bunch of stuff like that.

15399
25:31:28.345 --> 25:31:31.606
And if you ran routes, admin CLI, we have all this stuff.

15400
25:31:31.606 --> 25:31:37.968
And one of the big ones, one of the important ones that we're going to be working with is this connect local dev chain.

15401
25:31:37.968 --> 25:31:41.295
So running this F RPC dash c dash f RPC ini.

15402
25:31:41.295 --> 25:31:45.816
That's going to be the same as running this connect local dev chain.

15403
25:31:45.816 --> 25:31:49.672
Now what I like to do is jump into our package dot JSON.

15404
25:31:49.672 --> 25:32:05.473
And we'll create an additional script in here for us to just run yarn, whatever the name is that we want, and just to do that, and just to make it a lot easier for us to connect our local dev chain so underneath lint, I'm going to do a calm Ma'am, I'm going to create a new command.

15405
25:32:05.473 --> 25:32:07.615
I'm gonna say Morales sync.

15406
25:32:07.615 --> 25:32:14.180
And we're going to run the Morales admin CLI version of this f RPC dash c thing.

15407
25:32:14.180 --> 25:32:31.054
So what we're going to do in here is we're going to say mirallas admin CLI, connect local dev chain, dash dash chain, hard hat, dash dash mirallas.

15408
25:32:31.054 --> 25:32:33.644
Capital sub domain.

15409
25:32:33.918 --> 25:32:43.697
This is where we're going to put the subdomain of a morale server, which if we go to, we go back to our routes, admin data servers, we can go back to server details.

15410
25:32:43.697 --> 25:32:48.563
So it's going to be not the HTTPS, it's just going to be from here all the way to the.

15411
25:32:48.563 --> 25:32:48.756
com.

15412
25:32:48.756 --> 25:32:53.348
So not even the port, we're going to grab that we're going to paste that there.

15413
25:32:53.348 --> 25:33:05.496
And then we're going to do space dash dash f RPC path is going to be dot slash F RPC, slash FRP slash F RPC.

15414
25:33:05.496 --> 25:33:09.273
Now if we save this, and we run it, it's not going to work though.

15415
25:33:09.273 --> 25:33:16.817
So if I run yarn with our new script, Morales sync, it's gonna say specify Morales API key, it's going to give us this prompt.

15416
25:33:16.817 --> 25:33:23.866
And in our dashboard, we have our API key, which we can copy, we can paste it, and then API secret, we can copy and then paste it.

15417
25:33:23.866 --> 25:33:27.308
And then we'll say starting connection to hard hat, which is great.

15418
25:33:27.308 --> 25:33:28.454
But that's really annoying.

15419
25:33:28.454 --> 25:33:29.739
And I don't want to have to do that.

15420
25:33:29.739 --> 25:33:31.485
So we're going to Ctrl C, we're going to kill that.

15421
25:33:31.485 --> 25:33:34.869
And what we can do is we can go into our dot env.

15422
25:33:34.869 --> 25:33:40.652
And we can actually add those as environment variables that Morales is expecting.

15423
25:33:40.652 --> 25:33:49.981
So when we run this Morales admin CLI, it'll check our dot env file for Morales API key, which we can copy right here.

15424
25:33:49.981 --> 25:33:57.272
And then Morales API secret, which we can copy, and paste right here.

15425
25:33:57.272 --> 25:34:03.452
Now, the reason that these aren't capital and doing next public, these are not going to be part of our front end piece.

15426
25:34:03.452 --> 25:34:08.569
These are keys that we're using on the back end to test and for our local dev chain connection.

15427
25:34:08.569 --> 25:34:12.207
So we don't need to do next public, we're just going to leave it like this.

15428
25:34:12.207 --> 25:34:19.064
But now if I hit up and run yarn Morales sync, again, it's not going to prompt me this time, it's just gonna say starting connection to hard hat.

15429
25:34:19.064 --> 25:34:29.838
And if you see this, this starting connection to hard hat bit, we can come back to our servers, we'll go to dev chain proxy servers, we'll hit this disconnected button and refresh.

15430
25:34:29.919 --> 25:34:38.252
And if you see connected, you've successfully connected our heart add node, which is running here to our Morales server, which is awesome.

15431
25:34:38.252 --> 25:34:45.495
And in fact, if you sit on your heart had no terminal, you'll see the actual RPC calls to our blockchain here.

15432
25:34:45.495 --> 25:34:54.872
And you'll see Morales is consistently calling f block number to make sure it's up to date with what it has.

15433
25:34:54.872 --> 25:35:01.570
So how do we tell a morale server to start listening for events? Well, there are two ways we can do this.

15434
25:35:01.570 --> 25:35:03.808
The first way is with the user interface.

15435
25:35:03.808 --> 25:35:06.792
So we can go to view details, we'll go to sync.

15436
25:35:06.920 --> 25:35:09.242
And right now it says no sync services installed.

15437
25:35:09.920 --> 25:35:11.049
Add a new sync.

15438
25:35:14.920 --> 25:35:20.592
and watch contract events, we can watch the address for transactions or we can watch some address for any events.

15439
25:35:20.592 --> 25:35:33.051
And we can manually add all our information here, you can select the chain description, decide if we want to optionally sync historical, we could put the topic of the event, the ABI of the event, the address of the event filter, and then a table name.

15440
25:35:33.051 --> 25:35:40.216
Or we could do all this programmatically, which is what we're going to do, we'll create a little script that we can run, tell our morale server to watch for those scripts.

15441
25:35:40.216 --> 25:35:44.329
And we'll see our database get upgraded to listen for those events.

15442
25:35:44.329 --> 25:35:58.446
So back in our code, we're going to create a new file called add events that Jas now we have one terminal that's running our front end one terminal that's running our blockchain one terminal that syncing our blockchain with morass.

15443
25:35:58.446 --> 25:36:00.134
And now we're going to do another terminal.

15444
25:36:00.134 --> 25:36:11.402
For anything else we want to do like run little scripts become the Morales docks, and you click connect with SDK, there's a ton of different ways we can actually connect with the SDK, we've already learned how to connect with react by using React Morales.

15445
25:36:11.402 --> 25:36:16.661
Now we're going to connect with no JS since we're going to run a little Morales script.

15446
25:36:16.661 --> 25:36:20.227
And here's like a little example of what it looks like in the documentation.

15447
25:36:20.227 --> 25:36:26.554
But I'm gonna go ahead, so I'm gonna say const Morales, equals require oralis slash node.

15448
25:36:26.554 --> 25:36:42.463
And we're going to import the node extension of the Morales package into our script here, we're going to require dot env dot config, which means we're going to need to install dot env yarn add dash dash dev dot env.

15449
25:36:42.463 --> 25:36:49.128
And now we have to tell our morale server all the same information that we would need to tell it on the user interface.

15450
25:36:49.128 --> 25:36:51.889
So one of the first things that we're going to need is the address of our contract.

15451
25:36:51.921 --> 25:37:06.619
We're gonna need to say const contract address equals and this is where we go oh, well, how do we how do we get that contract address? The easy way to do this is we just go back where we're running the blockchain And we'd grab where that NFC marketplace is deployed.

15452
25:37:06.619 --> 25:37:12.873
And similar to our smart contract lottery where we created an update front end script, we're gonna do the exact same thing here.

15453
25:37:12.873 --> 25:37:30.854
So back in our heart hat, NFT marketplace, and if T code, we go to our deploy script or deploy folder, we're gonna create a new file called 99 Dash update, front end dot j s, and we're gonna create a little bit of our deploy process that will automatically update our front end.

15454
25:37:30.854 --> 25:37:35.403
So we can just grab the network address from a file that is programmatically created.

15455
25:37:35.403 --> 25:37:39.748
So we're gonna do module dot exports equals async function.

15456
25:37:39.748 --> 25:37:57.243
And now we'll say if process dot EMV that update front end, then console dot log, updating front end so that in our dot EMV, we have update front end equals true.

15457
25:37:57.243 --> 25:38:01.550
And that will be how we decide whether or not we actually want to update the front end.

15458
25:38:01.550 --> 25:38:06.478
And then we'll create a function called up date contract addresses, which we will await.

15459
25:38:06.478 --> 25:38:09.904
And this will update the contract addresses of our front end.

15460
25:38:09.904 --> 25:38:11.734
So let's make that function.

15461
25:38:11.734 --> 25:38:19.382
Do async function update contract addresses, make sure those are spelled the same.

15462
25:38:19.382 --> 25:38:26.122
So we'll say const NFT, market place equals await ethers dot get contract.

15463
25:38:26.122 --> 25:38:32.646
And then yes, we need to import const ethers equals require hardhat, we'll grab the NFT market place.

15464
25:38:32.646 --> 25:38:43.212
And then we're going to want to write our files in here to someplace in our front end code for us, we're going to do in a new folder constants.

15465
25:38:43.212 --> 25:38:49.193
And we're going to create a new file in here called network mapping dot JSON.

15466
25:38:49.193 --> 25:38:54.954
And we'll have this just be a JSON object which keeps track of all of our deployments.

15467
25:38:54.954 --> 25:39:11.196
So if we deploy something to rink V chain will keep a list will keep a list of it will say NFT marketplace will keep a list of all the addresses of the IoT marketplace, comma basic NF T, right, and then I list of all those right now we don't have anything deployed.

15468
25:39:11.196 --> 25:39:13.829
So we'll just have it be an empty JSON object.

15469
25:39:13.829 --> 25:39:21.022
Now back in our deploy script in the hard hat NFT marketplace project, we're going to keep track of that location.

15470
25:39:21.022 --> 25:39:23.460
So right at the top, we're gonna say const.

15471
25:39:23.460 --> 25:39:32.971
Front, and contracts file equals, and we'll place where it is according to your file setup.

15472
25:39:32.971 --> 25:39:41.750
So if I do cd dot dot slash, next JS NFT, marketplace, free code, Camp constants, network mapping dot JSON, this is where mine is.

15473
25:39:41.750 --> 25:39:50.822
So you're going to want to put it wherever your location is in relation to your heart at Mt marketplace Free Code Camp, it's my front end contract file, it's going to be right here.

15474
25:39:50.822 --> 25:39:53.561
Now that we have all that we're going to get the chain ID.

15475
25:39:53.561 --> 25:39:59.823
So we're gonna say const, chain ID equals network dot config dot chain, id.

15476
25:39:59.823 --> 25:40:00.723
to string.

15477
25:40:00.723 --> 25:40:05.288
And we're going to need to import network from hard hat as well.

15478
25:40:05.288 --> 25:40:11.195
And then we're going to want to read from this network mapping file to see what's currently in there.

15479
25:40:11.195 --> 25:40:12.922
So we'll say const.

15480
25:40:12.922 --> 25:40:26.285
Contract addresses equals and we're gonna do a JSON dot parse Fs dot read file sync, front, and front and contracts.

15481
25:40:26.285 --> 25:40:29.361
File comma UTF, eight.

15482
25:40:29.361 --> 25:40:34.650
Now here's what we're gonna say, if chain ID is in contract.

15483
25:40:34.650 --> 25:40:47.423
addresses, let's say if this list of contract addresses doesn't include the marketplace, then added on, we're gonna say if contract addresses of chain ID of the NFT.

15484
25:40:47.423 --> 25:41:24.605
Marketplace will say dot includes NF T, market, Mar get place dot address, then so we'll say contract address says chain ID NFT marketplace, dot push NFT marketplace dot address else we're gonna say contract address says of chain ID of NFT marketplace, which is going to be a new entry now equals NFT.

15485
25:41:24.605 --> 25:41:28.668
Market market place dot address.

15486
25:41:28.923 --> 25:41:34.502
So now we've updated our contract addresses object and we just need to write it back to the network mapping.

15487
25:41:34.502 --> 25:41:54.090
So now we're gonna say Fs dot right file sync front and contracts file comma JSON dot string five contract addresses and then at the bottom we'll do module dot exports dot tags equals and we'll say all or front end.

15488
25:41:54.090 --> 25:42:05.466
Now what we can do is we can run just this update front end script with yarn hardhat deploy dashed dash, network localhost.

15489
25:42:05.466 --> 25:42:09.457
And we only want to do this update front end script.

15490
25:42:09.457 --> 25:42:25.743
So we say dash dash tags front end, and we run this, and I ran into an error FS is not defined, oh, I forgot to do const Fs equals require Fs stride again, cannot set properties of undefined NFT marketplace.

15491
25:42:25.743 --> 25:42:26.070
Oops.

15492
25:42:26.070 --> 25:42:30.174
And that's because this line is off instead of this line, sorry.

15493
25:42:30.174 --> 25:42:34.831
Basically, right now, what it's saying is, it's saying, hey, this NFT marketplace thing doesn't exist.

15494
25:42:34.831 --> 25:42:36.615
So we need to make it exists.

15495
25:42:36.615 --> 25:42:51.524
So now we'll say contract addresses of chain ID equals a new entry of NFT marketplace and adds its first parameter, it's going to be NF T, Mark gets placed dot address, like that.

15496
25:42:51.524 --> 25:42:56.268
Now we can run it, and updating front end looks like it's done.

15497
25:42:56.268 --> 25:43:04.440
So if we go back to our front end, we now see we have an entry for localhost with NFC marketplace with the address in our network mapping dot JSON.

15498
25:43:04.440 --> 25:43:06.111
So if you did that correctly, you should get this.

15499
25:43:06.111 --> 25:43:14.088
If not, if you're having a hard time with that you can, of course, just go ahead and hard coded in but I do highly recommend you do it programmatically, because your life is going to be a lot better.

15500
25:43:14.088 --> 25:43:14.378
So cool.

15501
25:43:14.378 --> 25:43:19.194
We have this update front end script that works now, so we can put this back off to the side.

15502
25:43:19.194 --> 25:43:20.527
And let's keep going.

15503
25:43:20.527 --> 25:43:25.686
So we now have this network mapping file with contract addresses based off of the chain ID.

15504
25:43:25.686 --> 25:43:40.401
So what we can do is we can pull that in as well, we'll say const contract, address says equals require dot slash constants, slash network mapping dot JSON.

15505
25:43:40.401 --> 25:43:44.236
And now we can get the contract address based off the chain ID.

15506
25:43:44.236 --> 25:43:54.279
So we'll say chain ID equals process dot E and V dot chain ID, or 31337.

15507
25:43:54.279 --> 25:43:59.521
So in our data and V, we'll make a new entry called Chain ID.

15508
25:43:59.521 --> 25:44:01.362
And for now, we'll do 31337.

15509
25:44:01.362 --> 25:44:13.433
And now we can get the contract address by saying contract address equals contract addresses at the chain ID of n, f t, Mark get place of zero.

15510
25:44:13.433 --> 25:44:22.699
So we're going to go into that network mapping, go to the chain, Id go to the NFT marketplace and get the most recently deployed NFT marketplace boom.

15511
25:44:22.699 --> 25:44:26.367
So now we have the contract address contract address says Excuse me.

15512
25:44:26.367 --> 25:44:32.763
Now in our add events, we'll create a new function kind of similar to what we're doing, we'll do async function main.

15513
25:44:32.763 --> 25:44:35.021
And this will be our main function.

15514
25:44:35.021 --> 25:44:51.498
And then of course, we're going to copy paste that main script thing we've been doing this whole time domain dot then catch blah, blah, blah, we go back to the morass documentation, though, we can see we're going to need to grab our server URL, app ID master key, and then start it up.

15515
25:44:51.498 --> 25:44:53.451
So we're gonna do the exact same thing.

15516
25:44:53.451 --> 25:44:57.892
So once again, sorry, before we even get into our main, you can do it in your main function, if you want.

15517
25:44:57.926 --> 25:45:05.383
We'll say const server URL equals, and we can just grab this once again, from our web.

15518
25:45:05.383 --> 25:45:27.560
So we'll say process web dot next public Morales server URL, we'll get the app ID equals process Studien v dot next public Morales app ID, and then we'll say const, master key equals process study v dot master key.

15519
25:45:27.560 --> 25:45:30.226
So we don't have a master key in here yet.

15520
25:45:30.226 --> 25:45:33.354
So we'll create a new one called master key.

15521
25:45:33.354 --> 25:45:39.392
We'll go back to our Morales front end, we'll close out of this, we'll hit View Details.

15522
25:45:39.392 --> 25:45:41.458
And we'll grab that master key.

15523
25:45:41.458 --> 25:45:44.991
So we'll copy that, go back to our code editor and paste it in.

15524
25:45:44.991 --> 25:45:47.796
And now we have a master key in our web as well.

15525
25:45:47.796 --> 25:45:50.610
We don't want our master key on our front end.

15526
25:45:50.610 --> 25:45:53.110
So we're not going to put next public like that.

15527
25:45:53.110 --> 25:46:12.992
Now, the first thing we're going to do in our main function is we're going to do await Morales dot start server URL, app ID and master key as the input parameters for this will do a little console dot log, working with contract address, contract address.

15528
25:46:12.992 --> 25:46:17.576
Now we're gonna go ahead and add all those same pieces that we see on the UI.

15529
25:46:17.576 --> 25:46:29.926
So what are the events we want to listen for? Well, if we go back to our code here, so we have our NFT marketplace, where just type in event we have item listed item bought an item cancelled.

15530
25:46:29.926 --> 25:46:36.392
So we have three events we want to listen and a Morales, they have this add new events synced from code, which we're basically going to be following.

15531
25:46:36.392 --> 25:46:41.096
To do this, we need to obviously start and then create our options for the event.

15532
25:46:41.096 --> 25:46:52.663
We have the chain address topic, abi elimite, table name and sync historical and then we just do Morales dot Cloud dot run, watch cloud event options use master key.

15533
25:46:52.663 --> 25:46:54.031
And that's pretty much it.

15534
25:46:54.031 --> 25:46:57.140
So we're going to follow these documents here to do our code.

15535
25:46:57.140 --> 25:46:58.688
So let's start with item listed.

15536
25:46:58.688 --> 25:47:01.350
Let's create some options for our IDed listed event.

15537
25:47:01.350 --> 25:47:09.830
So we'll say let item listed options, or we could do const if we want to, but I'm just gonna do let item listed options equals.

15538
25:47:09.830 --> 25:47:15.943
And first we're gonna need the chain ID, which we have, because we're getting it from Morales.

15539
25:47:15.943 --> 25:47:22.411
Now the first thing to point out about chain ID is that ralis understands a local chain is 1337.

15540
25:47:22.411 --> 25:47:29.249
So even if you're on 31337, if you're doing a local development, you got to switch it to 1337.

15541
25:47:29.249 --> 25:47:33.588
So we're going to make another variable called Morales chain ID.

15542
25:47:33.588 --> 25:47:44.164
And we're just going to say, let Morales chain ID equals chain ID equals 31337.

15543
25:47:44.164 --> 25:47:48.079
Question mark 311337.

15544
25:47:48.079 --> 25:48:01.834
Otherwise, chain ID but we're saying since Morales understands that any local Dev is going to be 1337, we're going to say if chain ID equals 31337.

15545
25:48:01.927 --> 25:48:04.910
Then have Morales chain ID equal 1337.

15546
25:48:06.927 --> 25:48:14.863
whatever whatever our chain ideas and in our dot env we can decide okay, if we want to do rink B, localhost main net, etc.

15547
25:48:14.928 --> 25:48:24.859
We're gonna say Okay, chain ID morass will do your Morales chain ID, comma, we'll say what else do we need? We did the chain ID, we're gonna skip description, a sync historical.

15548
25:48:24.928 --> 25:48:31.435
So hit sync historical allows the node to go back throughout the blockchain, grab all the events ever emitted by that contract.

15549
25:48:31.435 --> 25:48:37.583
Since this is a very small local blockchain will just say sync historical is true.

15550
25:48:37.583 --> 25:48:38.566
Like that.

15551
25:48:38.566 --> 25:48:45.061
Okay, what else do we need? Okay, we need the topic, the topic is going to be your event information.

15552
25:48:45.061 --> 25:48:51.428
So to get the topic, go back to our event code, and the topic is just gonna be the name of the event, plus the type of the parameters.

15553
25:48:51.428 --> 25:49:09.134
So we're gonna go back to our code, we're gonna go back to here, we're gonna say, topic is going to be item listed, and it takes an address, an address, an address, you went to 56, and a UNT 256, address address, you interviewed six, YouTube and six.

15554
25:49:09.134 --> 25:49:20.237
Those problems seem like that, we also need the API of just the event, which again, we can find we go back to our hard hat project, we go to artifacts, we go to contracts.

15555
25:49:20.237 --> 25:49:28.673
And if the marketplace dot soul NFT marketplace dot JSON, our ABI starting from here is going to be the ABI of the whole contract.

15556
25:49:28.673 --> 25:49:31.100
And we just want that item listed event.

15557
25:49:31.100 --> 25:49:33.789
So we did Ctrl F, and we found it here.

15558
25:49:33.928 --> 25:49:44.261
And we're going to grab from right after it says type event, we're going to copy we're going to scroll up to write up to anonymous false, right, so this bit describes the ABI of the event.

15559
25:49:44.261 --> 25:49:59.535
So we have internal type, address, name, seller type, address, and if T address token ID price item listed, right, so this is going to be the ABI of our just our item listed event, we can take that and we just stick it in here, hit save, and mine auto format it to get rid of the parentheses.

15560
25:49:59.535 --> 25:50:05.765
Okay, what else do we need, we have the topic, we have the ABI, we already have the address, we're not going to do a filter.

15561
25:50:05.765 --> 25:50:07.200
And then we need a table name.

15562
25:50:07.200 --> 25:50:12.103
So we're going to do a new line, we'll say table name, it's going to be item listed.

15563
25:50:12.103 --> 25:50:16.329
And this is going to be the name of the table that we update in our database.

15564
25:50:16.329 --> 25:50:22.640
So we're gonna get a new table in here called item listed, and it's just gonna be filled with information about the item listed event.

15565
25:50:22.640 --> 25:50:25.816
And that's it right and we would hit confirm if we were doing this on the UI.

15566
25:50:25.816 --> 25:50:31.309
And since we're doing here, we'll just hit save, this is one of our events, we want to do this for all of our events.

15567
25:50:31.309 --> 25:50:32.832
Let's do it now for item bought.

15568
25:50:32.929 --> 25:50:42.322
So we'll say let's, item bought options, equals and we'll repeat the process, some of the stuff at the top is gonna be the same, the chain it is gonna be the same sync historical is gonna be the same.

15569
25:50:42.322 --> 25:50:48.025
So we can just grab those two, paste them down here for item, but the topic is going to be different.

15570
25:50:48.025 --> 25:50:57.643
The topic is going to be item bot is the name of the event, it's going to take an address, an address, a un 256 and a un 256.

15571
25:50:57.643 --> 25:51:00.691
The ABI is going to be different.

15572
25:51:00.691 --> 25:51:07.187
Once again, we're gonna go to our Hardhead NFT marketplace, we'll look for a bot, you'd find this event here.

15573
25:51:07.187 --> 25:51:15.976
We'll copy this, go back, we'll paste it in here, we now have item bot, we'll give it a table name of item bot.

15574
25:51:15.976 --> 25:51:33.404
And then one more then we have let item cancelled options equals and we'll do chain ID that's going to be rouse chain ID gonna be the same boilerplate from the top address.

15575
25:51:33.404 --> 25:51:36.381
Contract address topic is going to be different.

15576
25:51:36.381 --> 25:51:44.719
The topic for this it's called item cancelled, and it takes an address, an address and a UNT 256 will say sync.

15577
25:51:44.719 --> 25:51:49.180
Historical will be true, historical is true.

15578
25:51:49.180 --> 25:51:50.742
And then we need the ABI.

15579
25:51:50.742 --> 25:52:00.822
Once again we can go back to our hard hat, compile information we can look for item cancelled, grab that ABI of that event.

15580
25:52:00.822 --> 25:52:01.893
Copy that.

15581
25:52:01.893 --> 25:52:05.011
Come back to our running code pasted in.

15582
25:52:05.011 --> 25:52:06.830
Oops and I didn't give item canceled.

15583
25:52:06.930 --> 25:52:12.766
Let's give item canceled the table name, which will be item canceled.

15584
25:52:12.766 --> 25:52:18.360
So now if I zoom out just a hair, I now have item cancelled options, item bought options.

15585
25:52:18.360 --> 25:52:27.336
And item listed options are telling Ross Hey, listen for these events, whenever you hear an item canceled event, stick all this stuff into a database.

15586
25:52:27.336 --> 25:52:35.336
Whenever you hear an item bought event, stick all this in a database, whenever it emits an item listed, stick all this in in a database so that we can read from it.

15587
25:52:35.336 --> 25:52:38.372
So we're indexing these events so that we can query them much easier.

15588
25:52:38.372 --> 25:52:57.768
Now to send them up to our our server will say const listed response equals await or Alice or Alice dot Cloud dot run, watch contract event will pass the item listed options.

15589
25:52:57.768 --> 25:53:06.716
And then one more comma, and then we pass an object in here where we're just gonna say use master key is going to be true.

15590
25:53:06.716 --> 25:53:12.479
And we'll do the same thing we'll say const bot response or passing the bot item options.

15591
25:53:12.479 --> 25:53:26.967
So we'll say bot response equals await or else dot Cloud dot run, watch contract, event, comma, item bought options.

15592
25:53:26.967 --> 25:53:32.388
Comma, use master key that's going to be true.

15593
25:53:32.388 --> 25:53:52.866
And then finally Kant's canceled response equals await oralis dot Cloud dot run, watch contract event, comma, item canceled options, comma use master key is going to be true.

15594
25:53:52.866 --> 25:53:59.269
Now this Morales dot Cloud dot run API call to our server that we're making is going to return a response.

15595
25:53:59.269 --> 25:54:03.167
And let's look at the docs to actually see what that response looks like if it worked out.

15596
25:54:03.167 --> 25:54:03.439
Well.

15597
25:54:03.439 --> 25:54:06.877
In the terminal, you'll see success true.

15598
25:54:06.877 --> 25:54:10.253
So this is the return we're getting from the API.

15599
25:54:10.253 --> 25:54:15.031
So just to make sure everything goes well, I'll do an if listed.

15600
25:54:15.031 --> 25:54:30.502
response dot success, we're getting that success object from the rails server, we'll just do a console dot log success database updated with watching events.

15601
25:54:30.502 --> 25:54:37.145
And then else we'll say console dot log, something went wrong with a duck.

15602
25:54:37.145 --> 25:54:43.744
And of course, we're not just looking for let's say response dot success to be true.

15603
25:54:43.744 --> 25:54:52.032
We also want canceled response that success and bots response is successful.

15604
25:54:52.032 --> 25:54:54.151
Then say hey, you did it.

15605
25:54:54.151 --> 25:54:56.716
Otherwise say hey, something went wrong.

15606
25:54:56.716 --> 25:55:02.265
So this is how we're going to programmatically tell our server our database to listen for events.

15607
25:55:02.265 --> 25:55:08.832
So we just do await Murata Clodagh, run, watch contract events, we pass it this object with all these parameters and flags in there.

15608
25:55:08.832 --> 25:55:09.782
And then that's it.

15609
25:55:09.782 --> 25:55:14.581
And then we can send them is because I put next public Morales server URL.

15610
25:55:14.581 --> 25:55:17.386
And in my DMV, I just have next public server URL.

15611
25:55:17.386 --> 25:55:18.899
So let's change the name here.

15612
25:55:18.899 --> 25:55:20.640
Looks like our server URL was wrong.

15613
25:55:20.640 --> 25:55:22.865
And our app ID name is also wrong.

15614
25:55:22.865 --> 25:55:26.839
So let's fix that next public app ID master key looks correct.

15615
25:55:26.839 --> 25:55:27.515
Okay, cool.

15616
25:55:27.515 --> 25:55:38.867
So let's know things right? More Alice, like cada run, Rasta cloud run, when we run this in our database, if we hit refresh, right now, we don't see those tables in here.

15617
25:55:38.867 --> 25:55:41.528
But once we run this, add events.

15618
25:55:41.528 --> 25:55:45.474
js, we should call our server and we should tell it hey, you need to add these tables.

15619
25:55:45.474 --> 25:55:47.247
And you need to start listening for those events.

15620
25:55:47.247 --> 25:55:53.614
So in a new terminal, we're going to run this add events such as, so I'm going to make the terminal nice big.

15621
25:55:53.614 --> 25:55:57.994
And this is where if something goes wrong, it can be a little frustrating to figure it out how to fix this.

15622
25:55:57.994 --> 25:56:04.243
So if you run into an issue here, if something's not working as expected, please use the GitHub repo associated with this course.

15623
25:56:04.243 --> 25:56:08.673
And also the Morales forum is here for you, and Stack Exchange Etherium.

15624
25:56:08.673 --> 25:56:14.270
So we're going to run Node, add events, dot j s, and we'll hit enter.

15625
25:56:14.270 --> 25:56:18.624
Okay, boom, now we see success database updated with watching events.

15626
25:56:18.624 --> 25:56:27.728
Now, if you ran into an issue, and you rerun it, and it gets something went wrong, there's a chance that it could still be correct, right, because it returns false.

15627
25:56:27.728 --> 25:56:31.793
It returns that there's an issue if any of these already have the table in there.

15628
25:56:31.793 --> 25:56:39.725
So if we go back to our database here, and we hit refresh, I can now see item bought, item canceled and item listed in my database.

15629
25:56:39.725 --> 25:56:44.674
And again, you can see them by hitting the drop down on your server and hitting dashboard.

15630
25:56:44.674 --> 25:56:46.610
We also see event Sync Status.

15631
25:56:46.610 --> 25:56:55.869
And this is how our database knows that it needs to be listening for some events, and it's got all the information about how to listen for our events in here.

15632
25:56:55.933 --> 25:56:56.266
So cool.

15633
25:56:56.266 --> 25:56:57.932
So now we are listening for events.

15634
25:56:58.933 --> 25:57:10.719
So now what this means is our database is now listening To our blockchain node, and it's listening for events in here it's listening for these item listed item bought item, cancelled events.

15635
25:57:10.719 --> 25:57:15.983
So let's go ahead and test this back in our hardhat NFT marketplace Free Code Camp window.

15636
25:57:15.983 --> 25:57:17.870
We have some scripts in here.

15637
25:57:17.870 --> 25:57:19.682
One of them is mint and list.

15638
25:57:19.682 --> 25:57:21.147
So we went to New NFT.

15639
25:57:21.147 --> 25:57:33.266
And we listed on the marketplace when we list an NF T, well, our mirallas database should hear that item listed event and go ahead and stick it into this item listed table that it made.

15640
25:57:33.266 --> 25:57:38.218
So for us to test this out, let's open up our terminal in our Hardhead NFT marketplace repo.

15641
25:57:38.218 --> 25:57:51.617
And we'll run Minton list for our localhost before we actually run it, just be sure that our hard hat node is synced up with our Morales server in order for your database to actually grab that event.

15642
25:57:51.617 --> 25:57:54.666
Your local hard hat node needs to be connected.

15643
25:57:54.666 --> 25:57:59.617
So we'll do yarn, hard hat run scripts, mint and list.

15644
25:57:59.617 --> 25:58:02.575
js dash dash, network localhost.

15645
25:58:02.575 --> 25:58:03.432
Let's enter.

15646
25:58:03.432 --> 25:58:30.362
Okay, minting, approving listing listed now if we flip back to our database, after a quick refresh, what do you know, we see that there's an indeed an item listed events in our database, we can see information about a tool we can see there's a block hash, a timestamp, we see the token ID that was listed, we see the price of the listing the transaction hash, we see all this information about our event.

15647
25:58:30.362 --> 25:58:32.552
And now it's in this database for us to query.

15648
25:58:32.552 --> 25:58:37.837
So if you have reached this point, you have successfully set up an indexer with the Morales database.

15649
25:58:37.837 --> 25:58:40.425
And you should be super pumped because this is really powerful.

15650
25:58:40.425 --> 25:58:43.610
And now we're getting advanced, we're starting to do some advanced stuff.

15651
25:58:43.610 --> 25:58:45.772
So if you've made it this far, huge congrats.

15652
25:58:45.772 --> 25:58:47.318
This is already really cool.

15653
25:58:47.318 --> 25:58:58.770
Now, some other troubleshooting help here that I've run into many times myself, let's say I've left this project, and I've killed my heart hit note, I'm going to kill it right now.

15654
25:58:58.770 --> 25:59:06.217
If I stopped, my heart had node and I come back to my Morales admin, I'm going to view details dev chain proxy server, I'm now disconnected.

15655
25:59:06.217 --> 25:59:12.291
And if I hit this little refresh, I'm disconnected of course, because I'm not running my heart headnote anymore.

15656
25:59:12.291 --> 25:59:15.114
If I restart my node, my note is now restarted.

15657
25:59:15.114 --> 25:59:18.000
My connects local dev chain command is still running.

15658
25:59:18.000 --> 25:59:21.822
If I re fresh it, it'll now say connected, which is great.

15659
25:59:21.822 --> 25:59:37.267
However, if I go back to my blockchain, or if I go back to my hard hat, NFC marketplace script, I run yarn, hard hat script, mint and list again, network localhost, I go back to my database now, and I do a refresh, we don't see that item listed in here.

15660
25:59:37.267 --> 25:59:43.684
So our mirallas server is looking to make sure that that the blockchain we're working with is the same one.

15661
25:59:43.684 --> 25:59:51.327
So if we reset our blockchain, like we did, right, we canceled it and we reset it, our database is gonna get really confused.

15662
25:59:51.327 --> 26:00:01.458
So what we have to do is we have to hit reset local chain, reset local chain, we want to make sure that our new local chain is running, and that we're connected here.

15663
26:00:01.458 --> 26:00:07.671
So we'll hit reset local chain, and this will tell them Ross, hey, we reset the chain, it's okay, please continue doing so.

15664
26:00:07.671 --> 26:00:12.312
And once we hit reset local chain, we're not going to see that item listed in here.

15665
26:00:12.312 --> 26:00:21.197
However, if we go back, and we rerun mint and list network, local host with this reset local chain.

15666
26:00:21.197 --> 26:00:35.649
Now, if we go back to our Morales database, we hit refresh, we now see that new one has gotten in anytime you stopped your hard hat note, anytime you reset your hard hat node, the takeaway is you're going to need to go to View Details dev chain proxy server and reset local chain.

15667
26:00:35.649 --> 26:00:39.709
Now you can do that programmatically as well, we're not going to go over how to programmatically do that.

15668
26:00:39.709 --> 26:00:42.839
But that might be something you want to add to your hard hat deploy.

15669
26:00:42.839 --> 26:00:47.883
The other thing to note is that it didn't clear out our last event, right, the last event.

15670
26:00:47.935 --> 26:00:56.786
And if I go one minute and list again, after completes, we'll have another event in here.

15671
26:00:56.935 --> 26:00:58.180
Okay, this is great.

15672
26:01:00.935 --> 26:01:04.176
we're doing all this in the first place is so that in our index.

15673
26:01:04.176 --> 26:01:05.917
js we can start listening for events.

15674
26:01:05.917 --> 26:01:08.338
How do we show the recent listen entity.

15675
26:01:08.338 --> 26:01:11.335
So now we have a database of listed entities.

15676
26:01:11.335 --> 26:01:16.273
So what we could do, we could just query this item listed table right and grab everything in here.

15677
26:01:16.273 --> 26:01:23.535
However, we have an issue here, what happens if someone buys an NFT, if someone buys an NF T, the item listed event will still be in our database.

15678
26:01:23.535 --> 26:01:26.386
But technically it won't be on the marketplace anymore.

15679
26:01:26.386 --> 26:01:28.579
It'll be gone, it won't be listed.

15680
26:01:28.579 --> 26:01:33.499
So what can we do, there's a number of architectural choices we can make to get around this problem to solve this problem.

15681
26:01:33.499 --> 26:01:37.936
But one of the things we can do is actually we can use mirallas Cloud Functions.

15682
26:01:37.936 --> 26:01:45.120
So Morales cloud functions allow us to just really add anything we want our front end to do from the morale server.

15683
26:01:45.120 --> 26:01:45.858
And these are functions.

15684
26:01:45.858 --> 26:01:49.567
These are scripts that are going to run on a morale server whenever we want them to.

15685
26:01:49.567 --> 26:01:53.516
So we go to our server hit the little drop down and we hit Cloud Functions.

15686
26:01:53.516 --> 26:01:59.212
Now this is where we can write somewhere else stuff to run on our server whenever we want.

15687
26:01:59.212 --> 26:02:14.689
And we are going to set up our Cloud Functions in our IDE by hitting this little drop done to actually sync up our Visual Studio code with our Cloud Functions, we can just run this command here, and it will add whatever cloud functions we have in some cloud folder to here.

15688
26:02:14.689 --> 26:02:21.426
So what we can do back in our VS code, let's make a new folder, new folder called Cloud Functions.

15689
26:02:21.426 --> 26:02:27.857
And in here, we'll create a new file called Update, active items.

15690
26:02:27.857 --> 26:02:28.075
js.

15691
26:02:28.075 --> 26:02:36.613
So in here, if we were to write something like console dot log, hi, we can actually have this automatically saved on a morale server.

15692
26:02:36.613 --> 26:02:39.478
And the way that we do this is by running this command.

15693
26:02:39.478 --> 26:02:45.739
Now, we want to make it so that it's a lot easier for us to run this command than just always having to run this massive thing.

15694
26:02:45.739 --> 26:02:59.840
So what we're going to do is we're going to open up our package json, and we're going to make another Morales script here, right below here, we're going to make another Morales script, we're gonna say Morales Morales cloud, and we're going to have it, run this command.

15695
26:02:59.840 --> 26:03:05.461
So we're going to copy this command here, paste it into our package json.

15696
26:03:05.461 --> 26:03:13.903
So it's going to be Morales admin CLI, watch cloud folder, we don't need the Morales API key, because it'll grab that from our environment variables.

15697
26:03:13.937 --> 26:03:21.750
We don't need them rouse secret, because it'll grab that from our environment variables, we do need the morale subdomain autosave one.

15698
26:03:21.750 --> 26:03:32.937
And then the Morales cloud folder is going to be that new Cloud Functions bid that we made that slash cloud functions, functions.

15699
26:03:32.937 --> 26:03:48.517
Now, in a new terminal, if I run yarn, more Alice cloud, which is going to be same as running this huge function here, I hit enter, it'll say compile, you know, version, blah, blah, compiling, blah, blah, changes uploaded correctly.

15700
26:03:48.517 --> 26:03:54.396
And if we go back to our front end, we can see this console dot log ky and our front end being updated.

15701
26:03:54.396 --> 26:04:01.871
And if we continue to run this in our update active items at Jas, we could also write console dot log, you'll save it.

15702
26:04:01.871 --> 26:04:05.454
And if this is still running, it'll automatically upload it.

15703
26:04:05.454 --> 26:04:11.264
And now we can see if we do a little refresh on our front end Cloud Functions, we can see it's been uploaded here.

15704
26:04:11.264 --> 26:04:23.784
Now at this point, if you have a ton of this stuff running, you might see CPU 100 percent, you might see this little thing pop up and the server might start going a little bit slower, we're starting to use a lot of network activity here.

15705
26:04:23.784 --> 26:04:28.004
So I'm going to close my yarn Morales cloud for now.

15706
26:04:28.004 --> 26:04:30.625
And I'm just going to upload it once when I need to.

15707
26:04:30.625 --> 26:04:35.567
Because we're connected, we have it listening to events, we're having it doing more and more stuff here.

15708
26:04:35.567 --> 26:04:38.199
And it can start to put a lot of load onto the server.

15709
26:04:38.199 --> 26:04:41.307
So we're just gonna go ahead and we're going to cancel that out.

15710
26:04:41.307 --> 26:04:42.780
And now the CPU is a lot lower.

15711
26:04:42.780 --> 26:04:46.537
But if we go back to Cloud Functions, we can see it's still in here.

15712
26:04:46.537 --> 26:04:51.410
And anytime we update our Cloud Functions, it'll update our server with those cloud functions.

15713
26:04:51.410 --> 26:04:54.814
And we'll just run that darn morass cloud once we're all done here.

15714
26:04:54.814 --> 26:05:03.188
Anyways, so right now we're trying to figure out, Okay, we have item listed, but if someone buys an item, technically, it won't be listed anymore.

15715
26:05:03.188 --> 26:05:05.971
But our item listed table will still have it listed.

15716
26:05:05.971 --> 26:05:09.438
So what we can do is we can create a Cloud Function that runs whenever we want.

15717
26:05:09.438 --> 26:05:12.276
And like I said, we can have these run whenever we want.

15718
26:05:12.276 --> 26:05:13.709
We can call these whenever we want.

15719
26:05:13.709 --> 26:05:16.148
But we're going to create a Cloud Function that only runs.

15720
26:05:16.148 --> 26:05:31.905
Whenever one of these events are synced item listed item cancelled or item bought, we're going to create a new table called active item, an active item is going to say, okay, anytime it's listed, it will be active, but when it's bought or cancelled will remove it from the active item list.

15721
26:05:31.905 --> 26:05:33.695
So we're going to create a new table.

15722
26:05:33.695 --> 26:05:35.282
So let's go ahead and do that.

15723
26:05:35.282 --> 26:05:37.412
We started off with more Alice thought.

15724
26:05:37.412 --> 26:05:45.776
And then if you're IT auditors that you don't need this, we don't need to import Morales here, because we're going to upload it as a Cloud Function.

15725
26:05:45.776 --> 26:05:49.723
And our server already just automatically injects mirallas into our scripts.

15726
26:05:49.723 --> 26:05:58.179
So we're gonna say Morales dot cloud, that after save, and there's a whole bunch of stuff you can do with your Morales cloud.

15727
26:05:58.179 --> 26:06:00.840
And again, you can find these all in the documentation.

15728
26:06:00.938 --> 26:06:06.674
The after save keyword means that anytime something gets saved on a table that we specify, we'll do something.

15729
26:06:06.674 --> 26:06:08.398
And it takes two parameters.

15730
26:06:08.398 --> 26:06:12.318
So it takes what table that we want to do something after it's saved.

15731
26:06:12.318 --> 26:06:13.841
And we're gonna say item listed.

15732
26:06:13.938 --> 26:06:20.824
So we're saying anytime something is saved to the item listed table, we'll run some async function.

15733
26:06:20.938 --> 26:06:22.364
And we'll put request in here.

15734
26:06:23.938 --> 26:06:26.043
saved, it comes with a request.

15735
26:06:27.938 --> 26:06:31.338
happens, we want to add it to our active items list.

15736
26:06:31.938 --> 26:06:35.648
requests come with this is flagged called confirmed.

15737
26:06:35.939 --> 26:06:40.749
we'll say const confirmed because every request, every event actually gets triggered twice.

15738
26:06:40.749 --> 26:06:52.404
So once a transaction goes through, it triggers a save and then once again, once that transaction is actually confirmed, we actually only want to update our active item when the transaction is actually confirmed.

15739
26:06:52.404 --> 26:06:57.605
So we'll say const confirmed equals request dot object dot get confirmed.

15740
26:06:57.605 --> 26:07:02.204
Screening, get the confirmed attribute from that request.

15741
26:07:02.204 --> 26:07:10.234
And then we're also going to make A logger will say const logger equals oralis dot Cloud dot get logger.

15742
26:07:10.234 --> 26:07:17.237
And you'll see why in a second, we can actually write logs to our Morales database with this logs thing.

15743
26:07:17.237 --> 26:07:20.890
So any logs we can add into here, and I'll show you that in a minute.

15744
26:07:20.939 --> 26:07:23.412
So console logger Morales dot cloud, get logger.

15745
26:07:23.939 --> 26:07:26.839
we'll just do logger dot info.

15746
26:07:26.939 --> 26:07:32.126
Looking for confirmed x, and we can actually test this right now.

15747
26:07:32.126 --> 26:07:34.813
Right, we can actually test this right now.

15748
26:07:34.813 --> 26:07:35.563
In our logs.

15749
26:07:35.563 --> 26:07:43.532
We should see looking for confirmed TX Once an item listed and saved now to test this out just to test that our logger is actually working.

15750
26:07:43.532 --> 26:07:51.549
Let's run yarn, yarn Ross cloud just update active items to our to our morale server changes uploaded correctly.

15751
26:07:51.549 --> 26:07:53.176
Okay, we'll kill it now.

15752
26:07:53.176 --> 26:07:57.355
And now in our where we have our Minton, lists script.

15753
26:07:57.355 --> 26:07:59.188
Let's run Minton list.

15754
26:07:59.188 --> 26:08:02.389
And we should see on our server we should get those logs.

15755
26:08:02.389 --> 26:08:05.048
Now if we go to our server, we do a little refresh here.

15756
26:08:05.048 --> 26:08:11.507
And if we look at our logs now we can now see looking for confirmed TX in our server logs.

15757
26:08:11.507 --> 26:08:12.334
Now in our logs.

15758
26:08:12.334 --> 26:08:21.685
Here we see we only see that looking for confirmed TX once and I just told you, it actually triggers twice once when the transaction is first sent.

15759
26:08:21.685 --> 26:08:26.569
And then once when the transaction is confirmed, aka has block confirmations.

15760
26:08:26.569 --> 26:08:34.617
And additionally, if we look in our database at the item listed, and we scroll all the way to the right, we can see confirmed equals false.

15761
26:08:34.617 --> 26:08:41.214
So we only want to count this item listed event interactive items when confirmed is true.

15762
26:08:41.214 --> 26:08:52.661
So what we want to do actually is we want to update our scripts to add one block confirmation on top of our local Hardhead blockchain so that these can be changed to confirmed now to get around this.

15763
26:08:52.661 --> 26:08:57.058
What I usually will do in my mentalist script is I'll add a new utility.

15764
26:08:57.058 --> 26:09:02.560
So I'll go to my utils, I'll do new file, and I'll create a move blocks.

15765
26:09:02.560 --> 26:09:02.766
js.

15766
26:09:02.766 --> 26:09:08.649
And this will be a utility that I use to actually move the blocks.

15767
26:09:08.649 --> 26:09:13.908
So when we run our own heart hat node, we actually have complete control over what we want our heart hat node to do.

15768
26:09:13.908 --> 26:09:23.627
So what we can do is we can actually manually mine nodes and actually move blocks ahead so that Morales knows Oh, okay, this transaction is confirmed, right, because we're mining the block with the transaction.

15769
26:09:23.627 --> 26:09:28.500
And that's it, and Ross is just going to forever be waiting for the next block.

15770
26:09:28.500 --> 26:09:33.430
So we want to add some functionality to our scripts, where we just mine a block after it's done.

15771
26:09:33.430 --> 26:09:40.035
Now, keep in mind that if we mined like 1000 blocks or a ton of blocks really quickly, Moorehouse might have a hard time indexing that.

15772
26:09:40.035 --> 26:09:45.181
So we really want to just mined one at a time and give me enough time to index each block that we mined.

15773
26:09:45.181 --> 26:09:54.190
So we're actually going to build a little script, we're going to manually mine using this EVM mine RPC method that comes with our heart hat blockchain.

15774
26:09:54.190 --> 26:09:55.784
So we have this new move blocks script.

15775
26:09:55.784 --> 26:09:57.330
And let's go ahead and make this.

15776
26:09:57.330 --> 26:10:05.730
So instead of this being our script, we're going to have like a main function at the bottom, we're just gonna have this be a utility that we're going to import into other scripts.

15777
26:10:05.730 --> 26:10:10.392
So we're not going to need a main function here, we're just going to need to make this an async function.

15778
26:10:10.392 --> 26:10:12.246
And we'll call it move blocks.

15779
26:10:12.246 --> 26:10:24.389
And then we'll say amount, which is going to be the number of blocks, we want to move, we'll also put a sleep amount and default it to zero, this sleep amount is going to be an optional parameter.

15780
26:10:24.389 --> 26:10:32.607
If we want to move blocks and sleep maybe a second between blocks to resemble a real blockchain, we can have that in here too.

15781
26:10:32.607 --> 26:10:40.141
So we can have it resemble a real blockchain by sleeping every time a block is moved or just kind of waiting every time a block has moved.

15782
26:10:40.141 --> 26:10:53.115
So in our move block scripts, we'll do console dot log, moving blocks, dot that dot, and we'll say for let index equals zero, and we'll do a for loop around the amount and call that EVM.

15783
26:10:53.115 --> 26:10:59.544
Mine in this for loop index is less than amount index plus plus a weight network.

15784
26:10:59.544 --> 26:11:07.731
And then we got to import network oops, we got to import network from hard hat here, await network dot provider dot request.

15785
26:11:07.731 --> 26:11:16.207
And then we're going to request the method e v, mime, comma params are going to be empty.

15786
26:11:16.207 --> 26:11:20.734
And this is actually the same way we can make raw calls to our blockchain nodes.

15787
26:11:20.734 --> 26:11:26.891
We don't do a lot of this because ethers abstract this under the hood, but we're making a raw call to EVM mine.

15788
26:11:26.891 --> 26:11:34.166
Obviously, you can't call EVM mine on a real blockchain because you can't just tell a blockchain node to mine the next block.

15789
26:11:34.166 --> 26:11:48.433
Since this is our local hard hat node, we can call the VM now we're gonna say if sleep amount is greater than zero, or just if sleep mount, then we're also going to have this script sleep or wait a short duration.

15790
26:11:48.433 --> 26:11:55.760
So up at the top, we're actually going to create a new function called sleep, which is going to input a time in milliseconds.

15791
26:11:55.760 --> 26:12:05.257
And this is going to return a new promise, right? Because remember, in order for us to wait for some time we got to use promises, which we've learned before.

15792
26:12:05.257 --> 26:12:10.243
And this promise is going to take a function with resolve as an input parameter.

15793
26:12:10.243 --> 26:12:17.535
And we're just going to say, set timeout is going to be resolve, comma, time in Ms.

15794
26:12:17.535 --> 26:12:21.528
So the way we can sleep in JavaScript is we return a new promise.

15795
26:12:21.528 --> 26:12:25.595
And we just call this set timeout function, which basically just weights the time in milliseconds.

15796
26:12:25.595 --> 26:12:26.525
Now to actually sleep.

15797
26:12:26.525 --> 26:12:32.708
We'll say console dot log, sleeping for sleep amount.

15798
26:12:32.942 --> 26:12:39.275
And then we'll do await, sleep, sleep amount, and this is going to be in milliseconds.

15799
26:12:39.275 --> 26:12:45.322
So since sleep returns a promise, we can call it with await to say, okay, wait for this sleep function to finish.

15800
26:12:45.322 --> 26:12:52.127
And the sleep function is only going to finish when the time in MS in time in milliseconds finishes.

15801
26:12:52.127 --> 26:13:10.666
So now we have a function called move blocks, which will actually mined blocks on our local blockchain, so that Morales can get that block confirmation that it's looking for now at the bottom, we'll just do module dot exports, move blocks, move blocks, and then we'll also export sleep as well, because why not? Equals like that.

15802
26:13:10.666 --> 26:13:24.328
Now, what we can do back in our Minton list, up at the top, we'll say const, move blocks equals require dot dot slash utils slash move blocks.

15803
26:13:24.328 --> 26:13:28.332
And then we'll also import network from ethers network.

15804
26:13:28.332 --> 26:13:30.085
And the down in our script.

15805
26:13:30.085 --> 26:13:46.076
Just right at the bottom, we'll just say if network dot config, that chain ID equals equals 31337 await, move blocks, we'll say we'll move to blocks and then we'll also do sleep amount equals 1000.

15806
26:13:46.076 --> 26:13:49.688
We'll wait one millisecond between each block that we mined.

15807
26:13:49.688 --> 26:13:52.943
So sleep mount equals 1000, which is going to be one millisecond.

15808
26:13:52.943 --> 26:13:56.387
Now let's even just comment all this out for a second.

15809
26:13:56.387 --> 26:13:59.800
We'll just run this script with only this live.

15810
26:13:59.800 --> 26:14:15.561
Right we'll pull this up the yarn hard hat, run scripts, mentalist dash dash network, local host, we'll just move the blocks move back to our front end, we'll refresh, we'll go look at item listed.

15811
26:14:15.561 --> 26:14:19.133
We'll scroll all the way to the right, and now we see confirmed is true.

15812
26:14:19.133 --> 26:14:23.713
And now if we were to look in our logs, we would see that logging item happened twice.

15813
26:14:23.713 --> 26:14:26.756
Alright, so Let's uncomment this and continue.

15814
26:14:26.756 --> 26:14:34.943
Now that we have this now that we're learning about logging, now that we're doing all this stuff, we can say If confirmed, we're going to do some stuff.

15815
26:14:34.943 --> 26:14:38.807
If confirmed, we're going to create a table called active item and add this to the active item table.

15816
26:14:38.807 --> 26:14:42.306
So we're going to do a little logger dot info bound item.

15817
26:14:42.306 --> 26:14:47.580
And we'll create a new table and a new entry in this table.

15818
26:14:47.580 --> 26:14:57.343
So we'll say const active item equals more Alice dot object dot extend ACC active item.

15819
26:14:57.343 --> 26:15:02.878
This we're saying if active item exists, great grab it if not create it.

15820
26:15:02.944 --> 26:15:07.801
So we're going to create this active item table if it doesn't exist, if it does exist, great, grab it.

15821
26:15:07.801 --> 26:15:12.360
And we're going to say const active item equals new, active item.

15822
26:15:12.360 --> 26:15:17.705
So we're going to create a new entry in this active item table that we're creating.

15823
26:15:17.705 --> 26:15:20.943
And we'll say active item dot set.

15824
26:15:20.943 --> 26:15:25.895
And we can set any of the columns we want for this new table that we're creating.

15825
26:15:25.944 --> 26:15:28.232
So let's give it a marketplace address column.

15826
26:15:28.944 --> 26:15:31.239
market place address.

15827
26:15:35.944 --> 26:15:55.157
object dot get address all of these requests from events come with the address that they're coming from, which for us is going to be the marketplace address, we'll do active item that set and if T address which these events saved come with all the parameters of our event.

15828
26:15:55.157 --> 26:16:31.194
So we'll say request that object dot get NFT address will get the price will say active item dot set price is going to be request dot object dot get price will get the token IDs will say active item dot set token ID request dot object dot get token ID and then we'll get the seller will say active item dot set seller is going to be request that object dot get seller.

15829
26:16:31.194 --> 26:16:37.147
So we're getting all of this information from our event.

15830
26:16:37.147 --> 26:16:42.366
And this event update from Ross automatically always comes with the address that the event was omitted from.

15831
26:16:42.366 --> 26:16:45.419
So we're gonna grab all that we're going to create this active item table.

15832
26:16:45.419 --> 26:16:47.145
We're going to add all these rows.

15833
26:16:47.145 --> 26:16:50.267
We're going to add this one row with all these columns in it.

15834
26:16:50.267 --> 26:16:50.783
Awesome.

15835
26:16:50.783 --> 26:16:54.833
Now we'll just do logger dot info just to do a little print out.

15836
26:16:54.833 --> 26:16:56.221
We'll say adding address.

15837
26:16:56.221 --> 26:17:11.714
We'll do a little string interpolation we'll say request dot object dot get address period token ID with request dot object dot get token ID.

15838
26:17:11.714 --> 26:17:15.745
And I need to close this off here, better.

15839
26:17:15.745 --> 26:17:22.500
And then outside of the logger dot info, we'll just say logger dot info, saving.

15840
26:17:22.500 --> 26:17:27.634
And then we just run await active item dot save.

15841
26:17:27.634 --> 26:17:37.991
And now we have cloud function that's going to create a new entry in a new table called active item anytime item listed happens.

15842
26:17:37.991 --> 26:17:44.897
So after item is called the trigger for our cloud function, and there are a whole bunch of different triggers for different Ross Cloud Functions.

15843
26:17:44.945 --> 26:17:53.599
If you go to the Morales docs, we look for trigger, we can find a list of all these different triggers in here, like after save for Save.

15844
26:17:53.599 --> 26:18:03.006
After save, before delete, after delete, before save file, there's all these different triggers to trigger this cloud code.

15845
26:18:03.006 --> 26:18:09.178
Now, if we upload this new script to our morale server with yarn morass, cloud changes uploaded correctly, okay, great, we'll kill it.

15846
26:18:09.178 --> 26:18:15.064
Let's go to our cloud server, do a little refresh just to make sure that it's not still processing that update.

15847
26:18:15.064 --> 26:18:16.183
Okay, CPUs low enough.

15848
26:18:16.183 --> 26:18:16.793
Okay, great.

15849
26:18:16.946 --> 26:18:20.284
Now in our database, we don't see an active item table in here.

15850
26:18:20.284 --> 26:18:36.422
But if we go back to our Hardhead script, and we call mint and list, since now we have a Cloud Function that says okay, anytime an item listed event happens, update that active item table, we should see active item update.

15851
26:18:36.422 --> 26:18:37.564
So let's run this.

15852
26:18:37.564 --> 26:18:42.300
And remember for all of this, we need to have our heart head node running connected to Hardhat.

15853
26:18:42.300 --> 26:18:46.325
And if we reset our local chain, we need to click that reset local chain button.

15854
26:18:46.325 --> 26:18:48.053
So we went ahead, we ran this.

15855
26:18:48.053 --> 26:18:51.720
Now if we go back to our database, we give it a little refresh.

15856
26:18:51.720 --> 26:18:53.849
And right now I actually don't see anything.

15857
26:18:53.946 --> 26:18:59.657
So if I go to my logs go to info, I can see any errors or issues in here.

15858
26:18:59.657 --> 26:19:07.673
So it looks like after save failed for item listed for user bla bla bla, looks like there is an issue cannot read properties of undefined reading extend.

15859
26:19:07.673 --> 26:19:10.526
And that's also in the info, I made an issue.

15860
26:19:10.526 --> 26:19:13.071
I didn't quite write all my code, right.

15861
26:19:13.071 --> 26:19:17.296
And if we go back to our update active item, I can see where I messed up.

15862
26:19:17.296 --> 26:19:21.252
It should be Morales dot object with a capital O dot extent.

15863
26:19:21.252 --> 26:19:31.914
So what I'm going to do, then run yarn morass cloud again, now that I have this correct, we're going to cancel that, we're gonna run our mminton list again, now that we've fixed our script.

15864
26:19:31.914 --> 26:19:41.208
And now that we've fixed our script, go back to our database, we'll give it a little refresh, I can now see we have an active item entry in here.

15865
26:19:41.208 --> 26:19:48.300
Now at this point, there are going to be times when you don't want to leave and go get a coffee, right, or go to the bathroom or go get some food.

15866
26:19:48.300 --> 26:19:51.418
And you're going to want to stop your terminals from running.

15867
26:19:51.418 --> 26:19:56.677
So let's actually practice restarting everything and re getting into this local development environment.

15868
26:19:56.677 --> 26:19:58.759
Because it can be a little weird and a little tricky.

15869
26:19:58.759 --> 26:20:00.196
So let's practice this.

15870
26:20:00.196 --> 26:20:02.375
So once again, let's come over here.

15871
26:20:02.375 --> 26:20:11.222
And what do we need to do? Well, we're going to Ctrl C, we're going to kill our blockchain Ctrl C, we're going to kill our connection to our Morales server.

15872
26:20:11.222 --> 26:20:16.587
And if we're running a front end Ctrl C, that too, now if we go to our server, we go to view details.

15873
26:20:16.587 --> 26:20:23.087
Dev chain proxy server, if we hit status, this reset button here will still we will be disconnected now.

15874
26:20:23.087 --> 26:20:25.008
And now everything has been disconnected.

15875
26:20:25.008 --> 26:20:42.982
Now if we want to restart everything, if we're on our heart hat NFT marketplace will run yarn Hardhead node, and that will spin everything up again, we'll run yarn Morales sync to sync back with our routes connection, we can go back to our server will do view details and we should be connected now.

15876
26:20:42.982 --> 26:20:43.517
Connected.

15877
26:20:43.517 --> 26:20:50.232
Since we restarted our local blockchain, we now need to remember to do reset local chain, we'll go ahead and run that.

15878
26:20:50.232 --> 26:20:50.660
Great.

15879
26:20:50.660 --> 26:21:02.913
If we want to restart our front end, we can restart our front end like so now the thing is, our database will still have even when we refresh it even though we reset the local blockchain, it'll still have all this stuff in it.

15880
26:21:02.947 --> 26:21:08.013
Now these entries in here are entries from a blockchain that no longer exists.

15881
26:21:08.013 --> 26:21:14.881
So what I often will do is I'll click this button up here, and we'll just delete all rows in this class.

15882
26:21:14.947 --> 26:21:18.619
To confirm we do active item, read the name of the table.

15883
26:21:18.947 --> 26:21:20.423
let's do it for item listed too.

15884
26:21:21.947 --> 26:21:23.928
all rows, item listed.

15885
26:21:23.928 --> 26:21:25.060
Yes, delete.

15886
26:21:26.947 --> 26:21:27.309
refresh.

15887
26:21:27.309 --> 26:21:29.067
Now everything is zeroed out here.

15888
26:21:29.947 --> 26:21:32.518
empty database for these events in our after save here.

15889
26:21:32.947 --> 26:21:49.328
that we've added that little weight in our script, let's go back to our hard hat NFT marketplace, we'll run yarn, RT hat, run scripts, mint and list dot j s dash dash network, local host.

15890
26:21:49.328 --> 26:21:58.800
This will mint it approve it listed and then we mined two blocks to give Morales time to index our event and then on a morale server.

15891
26:21:58.800 --> 26:22:05.173
We go ahead and refresh we now see item listed as one and active item is One all at the same time.

15892
26:22:05.173 --> 26:22:16.672
So that is how we're going to make sure that Morales always indexes whenever we call a function, we're just going to mind one additional block to tell Morales Hey, that transaction has indeed been confirmed.

15893
26:22:16.672 --> 26:22:17.654
So really exciting.

15894
26:22:17.654 --> 26:22:21.578
And we got to practice closing and restarting and doing all that good stuff, too.

15895
26:22:21.578 --> 26:22:23.614
So now this is fantastic.

15896
26:22:23.614 --> 26:22:31.340
Now that we have this additional functionality to make it a lot easier for someone else over okay, awesome, we can check active item.

15897
26:22:31.340 --> 26:22:41.684
Well, we're not quite done yet, right? Because what if somebody buys an NFT, or sells an entity we should have active item be removed? Right, right now there's one item listed in one active item.

15898
26:22:41.684 --> 26:22:46.510
But if we buy an item, active item will still show that that item is active.

15899
26:22:46.510 --> 26:22:55.301
So let's go ahead and let's update our cloud function to also say, okay, anytime an item is bought, we remove that item from being active.

15900
26:22:55.301 --> 26:22:57.454
So let's create another after save.

15901
26:22:57.454 --> 26:22:59.226
Let's first built this for canceling the item.

15902
26:22:59.226 --> 26:23:01.431
And then we'll build one for buying the item.

15903
26:23:01.431 --> 26:23:10.053
So to make another after save to make another trigger, we'll say mirallas dot Cloud dot after save, we'll say item cancelled.

15904
26:23:10.053 --> 26:23:16.530
And this will be an async function that takes the request as an input parameter again, and we're going to do the same thing.

15905
26:23:16.530 --> 26:23:25.674
We're gonna say const confirmed equals request that object dot get confirmed, we'll say const.

15906
26:23:25.674 --> 26:23:30.124
Logger equals routes dot Cloud dot get logger, like so.

15907
26:23:30.124 --> 26:23:32.316
And then we'll do logger.

15908
26:23:32.316 --> 26:23:33.894
Oops, lowercase L.

15909
26:23:33.894 --> 26:23:44.094
And then we'll do logger dot info, marketplace, the little pipe object and then just request dot object.

15910
26:23:44.094 --> 26:23:47.466
And then we'll do the same thing.

15911
26:23:47.466 --> 26:23:48.138
If confirmed.

15912
26:23:48.138 --> 26:23:53.631
If this transaction is confirmed after one block, we're going to remove it from active item.

15913
26:23:53.631 --> 26:23:57.749
And we're going to be using a query to first find that active item that's getting cancelled.

15914
26:23:57.749 --> 26:24:00.556
And you can learn more about basic queries in the Morales documentation here.

15915
26:24:00.556 --> 26:24:11.499
So we're going to get that table by saying const active item equals more outlets that object for the capital O object dot extend active item.

15916
26:24:11.499 --> 26:24:13.399
And we're going to create a new query.

15917
26:24:13.399 --> 26:24:17.626
So we're going to query our table before we actually set or save anything.

15918
26:24:17.626 --> 26:24:24.756
So we're gonna say const, query, query equals new Morales dot query of active item.

15919
26:24:24.756 --> 26:24:34.120
So we're going to query our Morales database to find an active item that's in there, that's going to match the request here, so we can cancel it.

15920
26:24:34.120 --> 26:24:52.981
So we'll say query dot equal to marketplace address, comma request that object dot get address, we're looking for an active item where the marketplace address is going to be the same as the address of the item cancelled.

15921
26:24:52.981 --> 26:25:15.085
We'll say query dot equal to NF T address, comma request dot object dot get an F T address will say query dot equal to token ID, comma request dot object dot get token ID.

15922
26:25:15.085 --> 26:25:19.802
And that should be it right? So let's look again at our contract here.

15923
26:25:19.802 --> 26:25:26.686
And what is the item canceled give us it gives us a seller NFC address and a token ID seller and ft address and a token ID.

15924
26:25:26.686 --> 26:25:32.512
And we're looking for NFT address and the token ID, we don't need to look for the seller, we just need to look for these two.

15925
26:25:32.512 --> 26:25:33.887
And then of course, the marketplace address.

15926
26:25:33.950 --> 26:25:34.337
So great.

15927
26:25:36.950 --> 26:25:42.473
info, and then we'll just print out marketplace type query.

15928
26:25:42.950 --> 26:25:45.700
then we'll just print out this query that we're running.

15929
26:25:45.950 --> 26:26:00.045
then we can say const, cancelled item equals await query dot first, we're going to find the first active item in the database that has the same marketplace address and a T address and token ID that just got cancelled.

15930
26:26:00.045 --> 26:26:01.984
So we're going to find that first cancelled item.

15931
26:26:01.984 --> 26:26:10.021
We'll do a little bit more logger information, we'll say logger dot info, marketplace, pipe, cancelled item.

15932
26:26:10.021 --> 26:26:12.672
And then we'll just do some string interpolation.

15933
26:26:12.672 --> 26:26:14.838
And we'll print out that canceled item.

15934
26:26:14.950 --> 26:26:19.330
Cancelled item and we'll say if cancelled item.

15935
26:26:20.950 --> 26:26:23.404
doesn't find anything, it'll return undefined.

15936
26:26:23.950 --> 26:26:27.653
saying if cancelled item which will return true if it found something.

15937
26:26:27.653 --> 26:26:32.380
So if cancelled item, then we're gonna say logger dot info.

15938
26:26:32.380 --> 26:26:53.196
Deleting and then we'll do request dot object dot get token ID at address, request dot object dot get address address space since it was canceled, so we're going to do a little print little logging here.

15939
26:26:53.196 --> 26:27:03.899
Take the leading that thing since it was canceled and then we're going to run a wait canceled item dot destroy and that's when we remove it from the active item.

15940
26:27:03.951 --> 26:27:06.751
And then we'll just say else.

15941
26:27:09.951 --> 26:27:23.165
with address, request dot object dot get address, and token, Id request dot object, dot get token ID.

15942
26:27:23.165 --> 26:27:23.879
So cool.

15943
26:27:23.879 --> 26:27:31.704
So now we have this after save here, it looks like my terminal automatically added this require in here, which we don't want.

15944
26:27:31.704 --> 26:27:33.644
So I'm just gonna go ahead delete that.

15945
26:27:33.644 --> 26:27:39.882
We can upload this to our Morales server by running yarn, Morales cloud and great changes uploaded correctly.

15946
26:27:39.882 --> 26:27:47.826
And now to test this test that this is working, let's create a new script in our hard hat NFT marketplace called cancel item.

15947
26:27:47.826 --> 26:27:54.628
So we'll go to scripts right now we have mentioned list, we'll do new file, we'll call it cancel dot Jas.

15948
26:27:54.628 --> 26:27:57.144
We'll do cancel item, Jas.

15949
26:27:57.144 --> 26:27:59.660
And this will be a script.

15950
26:27:59.951 --> 26:28:05.522
So we're going to use that that main thing here, but we're going to call our function cancel.

15951
26:28:05.522 --> 26:28:15.014
So we'll do async function cancel, and then at the top, we'll say const token ID equals Now let's go to our active item list.

15952
26:28:15.014 --> 26:28:18.214
And let's find a token ID that's in here.

15953
26:28:18.214 --> 26:28:19.525
Okay, token ID zero.

15954
26:28:19.525 --> 26:28:24.035
And so we'll use this as the token ID that we want to delete.

15955
26:28:24.035 --> 26:28:26.285
So we'll use token ID zero.

15956
26:28:26.285 --> 26:28:27.904
So in our cancel item.

15957
26:28:27.904 --> 26:28:32.309
js script, we'll say const token ID equals zero and let's cancel it.

15958
26:28:32.309 --> 26:28:33.951
So we'll say const NFT.

15959
26:28:33.951 --> 26:28:38.002
Marketplace equals await ethers dot get contract.

15960
26:28:38.002 --> 26:28:42.047
And yes, const ethers equals require hardhat.

15961
26:28:42.047 --> 26:28:52.420
And ft marketplace will say const basic NF t equals await ethers dot get gets contract.

15962
26:28:52.420 --> 26:29:06.888
Basic NF team do const TX equals await NF T marketplace dot cancel listing basic NF T dot address token ID.

15963
26:29:06.888 --> 26:29:14.698
And we're going to call cancel item should be cancelled listing we call the cancel listing.

15964
26:29:14.698 --> 26:29:17.710
So cancelled listing Yep, like that.

15965
26:29:17.710 --> 26:29:21.693
And it takes the address of the NFT and the token ID.

15966
26:29:21.693 --> 26:29:25.141
So the basic NF T dot address and the token D Okay, great.

15967
26:29:25.141 --> 26:29:27.952
And then we'll do a weight TX dot weight one.

15968
26:29:27.952 --> 26:29:32.752
And then we'll do console dot log NFT cancelled.

15969
26:29:32.952 --> 26:29:41.475
And then we'll say if network dot config dot chain ID equals equals 31337.

15970
26:29:41.475 --> 26:29:49.916
We'll go ahead and we'll do a wait move blocks to two and then we'll say sleep.

15971
26:29:49.916 --> 26:29:51.179
Mount equals 1000.

15972
26:29:51.179 --> 26:29:54.738
And then we'll just say const.

15973
26:29:54.738 --> 26:29:59.403
Move blocks equals require dot dot slash utils slash move blocks.

15974
26:29:59.403 --> 26:29:59.953
Okay, cool.

15975
26:29:59.953 --> 26:30:01.215
That looks really good.

15976
26:30:01.215 --> 26:30:06.247
So let's go ahead and run this yarn hardhat run scripts cancel item.

15977
26:30:06.247 --> 26:30:13.280
js dash dash network, local host and ft cancelled moving blocks sleeping.

15978
26:30:13.280 --> 26:30:14.152
Okay, great.

15979
26:30:14.152 --> 26:30:15.470
Our node is running.

15980
26:30:15.470 --> 26:30:15.883
Awesome.

15981
26:30:15.883 --> 26:30:21.091
We're connected to our mirallas we've uploaded our cloud function with yarn Morales cloud.

15982
26:30:21.091 --> 26:30:26.425
Now if we go back to our database, do a little refresh.

15983
26:30:26.425 --> 26:30:29.133
Looks like I have an issue here.

15984
26:30:29.133 --> 26:30:34.021
I go to my info it says after save failed for item Cancel for user blah blah, blah.

15985
26:30:34.021 --> 26:30:35.651
Here's the login information.

15986
26:30:35.651 --> 26:30:38.825
Morales dot cloud apt get latar is not a function.

15987
26:30:38.953 --> 26:30:39.553
Uh huh.

15988
26:30:39.553 --> 26:30:42.753
Well, that makes a lot of sense.

15989
26:30:42.753 --> 26:30:43.753
Get water.

15990
26:30:44.953 --> 26:30:46.715
let's make this get logger.

15991
26:30:48.953 --> 26:30:49.674
upload them.

15992
26:30:49.674 --> 26:30:51.444
Changes uploaded correctly.

15993
26:30:52.953 --> 26:30:58.103
have to manually go to active item I'm gonna have to manually delete this one will have a delete this row.

15994
26:30:58.103 --> 26:30:59.410
Yes, delete, do a refresh.

15995
26:30:59.410 --> 26:31:03.133
And the reason I have to do that is because it's already been saved.

15996
26:31:03.133 --> 26:31:05.100
And we're doing an after save.

15997
26:31:05.100 --> 26:31:06.485
So because I messed up.

15998
26:31:06.485 --> 26:31:08.855
If you spelt that right, you probably did, right.

15999
26:31:08.953 --> 26:31:10.921
But because I messed up, we're gonna have to rebuild a new one.

16000
26:31:10.953 --> 26:31:12.789
And then delete that new one.

16001
26:31:14.953 --> 26:31:17.268
run scripts, mint and list network localhost.

16002
26:31:17.953 --> 26:31:19.090
meant to add a new one.

16003
26:31:20.953 --> 26:31:22.114
we'll do a refresh.

16004
26:31:24.953 --> 26:31:25.171
listed.

16005
26:31:25.171 --> 26:31:26.080
It has a token ID of one.

16006
26:31:26.953 --> 26:31:27.920
cancel that now.

16007
26:31:30.953 --> 26:31:31.698
item to one.

16008
26:31:34.953 --> 26:31:40.085
scripts cancel item, network, local host run this NFT cancelled moving blocks.

16009
26:31:40.085 --> 26:31:42.574
Now we'll go to the front end, we'll do a refresh.

16010
26:31:42.574 --> 26:31:46.773
And we can see it's been removed from active item programmatically, which is great.

16011
26:31:46.773 --> 26:31:49.212
So this is where these logs can be really helpful.

16012
26:31:49.212 --> 26:32:00.906
Now it can be a little scary to do things wrong on purpose, but learning how to use information like the logging and learning how to debug effectively is going to make you a lot faster of a coder because guess what, you're not going to be perfect.

16013
26:32:00.906 --> 26:32:07.215
You're going to run into issues understanding how to use The Log Understanding how to read the errors is going to make you much faster developer.

16014
26:32:07.215 --> 26:32:12.904
So now we have something for cancelled item, we're also going to need something for what? Well, you guessed it for buying the item.

16015
26:32:12.954 --> 26:32:16.588
So let's make another one of these murales to cloud that after save.

16016
26:32:16.588 --> 26:32:25.237
And we're going to be using most of this same exact code for item bought that we use for item cancelled, we probably should turn it all into a function.

16017
26:32:25.237 --> 26:32:30.068
But for practice, we're just going to go ahead and do it one more time, we'll do Morales dot cloud.

16018
26:32:30.068 --> 26:32:34.183
And then my VS code keeps sticking this in for some reason.

16019
26:32:34.183 --> 26:32:38.863
I'm going to undo that Morales dot Cloud dot after save.

16020
26:32:38.863 --> 26:32:40.863
Item bot is the event.

16021
26:32:40.863 --> 26:32:57.079
There'll be an async request little arrow function here, say const confirmed equals request that object dot get confirmed will get whether this transaction is confirmed.

16022
26:32:57.079 --> 26:33:00.854
We'll get the logger I'm just going to copy paste so I get it right this time.

16023
26:33:00.854 --> 26:33:09.235
So I'm going to copy and paste those two lines const logger equals Morales dot Cloud dot get logger logger dot info.

16024
26:33:09.235 --> 26:33:26.919
And we'll say If confirmed const active item equals Morales dot object dot extend active item const query and for this query, I'm actually just going to copy these lines because this is going to be exactly the same.

16025
26:33:26.955 --> 26:33:31.180
We're going to look for the NFT address and the token ID and the marketplace address.

16026
26:33:31.180 --> 26:33:37.429
And if we look in our NFT dot soul and up to marketplace dot som alright and bot event as the NFT address.

16027
26:33:37.429 --> 26:33:42.080
And the token ID which is what we want to find are listed and of team.

16028
26:33:42.080 --> 26:33:43.580
So we'll run that query.

16029
26:33:43.580 --> 26:33:52.523
We'll do const bots item equals await query dot first, and we'll do exactly what we did before.

16030
26:33:52.523 --> 26:34:27.429
If bots item then logger dot info, deleting request dot object dot get object ID await bought item dot destroy logger dot info deleted item with Open ID request dot object dot get open ID at address request dot object dot get address.

16031
26:34:27.429 --> 26:34:30.344
And then if we don't find it will say else.

16032
26:34:30.344 --> 26:34:47.479
Logger dot info, no item found with address request that object dot get address and token, Id request that object dot get token ID.

16033
26:34:47.479 --> 26:34:47.806
Cool.

16034
26:34:47.806 --> 26:34:49.051
So that looks good.

16035
26:34:49.051 --> 26:34:52.684
Let's go ahead and upload this to the cloud.

16036
26:34:52.684 --> 26:34:57.398
So do yarn oralis Cloud changes uploaded correctly.

16037
26:34:57.398 --> 26:34:59.709
Let's go make sure it looks good on our server.

16038
26:34:59.709 --> 26:35:03.027
So we'll give a morale server a little refresh.

16039
26:35:03.027 --> 26:35:04.905
Go to Cloud Functions here.

16040
26:35:04.905 --> 26:35:07.820
I can see the item cancelled in here still.

16041
26:35:07.956 --> 26:35:11.481
And now I can see the item bought after save perfect.

16042
26:35:11.956 --> 26:35:13.432
like I'm at 100 percent capacity.

16043
26:35:14.956 --> 26:35:20.489
just to cool down thinking give it a little refresh and looks like we're back down after our cloud function has been uploaded.

16044
26:35:20.489 --> 26:35:21.222
Okay, cool.

16045
26:35:21.222 --> 26:35:23.755
To test out that this part is working.

16046
26:35:23.956 --> 26:35:26.294
Let's go ahead we'll write another script here.

16047
26:35:26.956 --> 26:35:28.165
by item dot j s.

16048
26:35:28.165 --> 26:35:31.229
And we'll do the same thing right now.

16049
26:35:31.956 --> 26:35:32.498
database.

16050
26:35:32.498 --> 26:35:34.599
We don't have any active items.

16051
26:35:35.956 --> 26:35:36.789
real quick.

16052
26:35:36.789 --> 26:35:38.705
We're on mint and list.

16053
26:35:38.705 --> 26:35:39.955
Mint a new one.

16054
26:35:40.956 --> 26:35:43.313
check our database we'll do a little refresh.

16055
26:35:43.956 --> 26:35:47.130
active vitamins in here with a token ID of two now.

16056
26:35:47.956 --> 26:37:10.094
is we'll buy that token ID so we'll say const ethers network equals require arhats const move blocks equals require dot slash utils slash move blocks const token ID equals to async function by item const NFT marketplace equals await ethers dot get contract NF T marketplace const basic NF t equals await ethers dot get contract basic NFT coms listing equals await and ft market place dot get listing basic NF T dot address and the token ID will say const price equals listing that price that to string and we'll say const Tx and this is us going to actually buy it equals await and ft marketplace dot buy item basic n f t dot address, token ID, comma.

16057
26:37:10.094 --> 26:37:13.448
And then the value of course is going to be the price.

16058
26:37:13.448 --> 26:37:19.290
Do await TX dot wait one, console dot log bots NF t.

16059
26:37:19.290 --> 26:37:35.006
And then if network dot config dot chain ID equals 31337, then await move blocks to comma, sleep amount equals 1000.

16060
26:37:35.006 --> 26:37:40.317
And then this is a script of course, so we're going to use the same stuff we're using for cancel.

16061
26:37:40.317 --> 26:37:44.086
But instead of cancelled, it's going to be called by item.

16062
26:37:44.086 --> 26:37:52.284
So we have the item inactive item here, we run yarn, art hat run scripts by item.

16063
26:37:52.284 --> 26:37:55.693
js Dash network, localhost.

16064
26:37:55.957 --> 26:37:58.090
Now we can test buying this item.

16065
26:37:59.957 --> 26:38:05.579
blocks, we'll do a little refresh on our database, and boom, we can see the active item is gone.

16066
26:38:05.579 --> 26:38:08.803
And we can see, the item has now been bought.

16067
26:38:08.803 --> 26:38:09.418
Awesome.

16068
26:38:09.418 --> 26:38:14.612
We're almost done keeping our active item, just a table of active items.

16069
26:38:14.612 --> 26:38:16.034
But there's one more thing we should do.

16070
26:38:16.034 --> 26:38:17.161
We're not going to test this here.

16071
26:38:17.161 --> 26:38:28.845
But if you want to test it, we can we actually in our NFT marketplace, go to marketplace dot Sol, we actually have an update listing function as well, that also admits an item listed.

16072
26:38:28.845 --> 26:38:35.216
So we also want to check to see if item listed is coming from update listening.

16073
26:38:35.216 --> 26:38:44.315
So back in our item listed Cloud Function, before we actually start saving stuff, we want to check to see if it already exists.

16074
26:38:44.315 --> 26:38:51.450
So we're gonna say so we'll say const query equals new mirallas dot query.

16075
26:38:51.450 --> 26:38:55.398
And sorry, I keep sticking the sin of active item.

16076
26:38:55.398 --> 26:38:58.361
And we're going to do exactly what we've been doing.

16077
26:38:58.361 --> 26:39:00.351
We're gonna say query dot equal to NFT.

16078
26:39:00.351 --> 26:39:44.208
Address, we're gonna look for the NFT address request dot object dot get and ft address, query dot equal to token ID, request that object dot get token ID, query dot equal to marketplace, address, comma request dot object dot get address query dot equal to seller requests dot object dot get seller will say const already listed item equals await query dot first.

16079
26:39:44.208 --> 26:39:48.922
And then we'll say if this item has already been listed.

16080
26:39:48.922 --> 26:39:52.781
Then we'll go ahead and say logger dot info.

16081
26:39:52.958 --> 26:40:00.827
Deleting already listed request dot object dot get object ID.

16082
26:40:00.959 --> 26:40:06.441
And we'll do a weight already listed item dot destroy.

16083
26:40:06.959 --> 26:40:35.518
then do logger dot info, deleted item with token ID request dot object dot get token ID at address request dot object dot get address since it's already been listed, if the object has already been listed, we know that it's coming from this update listing function.

16084
26:40:35.518 --> 26:40:40.039
So we're going to delete it first, and then we'll resave it with its new price.

16085
26:40:40.039 --> 26:40:46.865
So and let's just go ahead, and let's upload this to the cloud yarn Morales cloud.

16086
26:40:46.959 --> 26:40:50.883
upload this to our server changes uploaded correctly.

16087
26:40:50.959 --> 26:40:54.303
Let's go check our server, give it a little refresh.

16088
26:40:54.959 --> 26:40:56.991
check Cloud Functions.

16089
26:41:00.959 --> 26:41:02.620
for deleting is now in here.

16090
26:41:04.959 --> 26:41:15.039
to constantly have this active item table only be the items that are actively on our marketplace without having to spend any additional gas in our application.

16091
26:41:15.039 --> 26:41:24.039
And this is going to be way better for user experience because they're not going to have to pay extra gas to keep all these entities and maybe an array or some more data structures.

16092
26:41:24.039 --> 26:41:25.520
If you've made it this far.

16093
26:41:25.520 --> 26:41:31.906
This is easily one of the hardest parts of this course, because we're working with a ton of technologies.

16094
26:41:31.959 --> 26:41:37.451
We're working with a smart contract, we're working with Cloud Functions, we're working with a back end database.

16095
26:41:37.451 --> 26:41:41.391
Now if you've made it this far, you should be incredibly incredibly proud.

16096
26:41:41.391 --> 26:41:46.594
So now let's just go ahead, let's mint and list one more NFT.

16097
26:41:46.594 --> 26:41:54.353
So we'll do we'll run yarn heart at run scripts, mint and list network local hosts will meant it will list it or sleeping.

16098
26:41:54.353 --> 26:41:55.730
Let's go check our database.

16099
26:41:55.730 --> 26:41:56.664
We'll do a refresh.

16100
26:41:56.664 --> 26:41:59.069
We see the active item in here.

16101
26:41:59.069 --> 26:42:06.881
And now let's learn how to call all of the objects in In our active item database here, let's do it.

16102
26:42:06.960 --> 26:42:16.693
And remember, if you ever reset your local blockchain, you're gonna have to come in here and delete all the rows in the support tables.

16103
26:42:16.960 --> 26:42:24.427
With all that being said, it's time to finally come back to our front end, and come back to our index dot J.

16104
26:42:24.427 --> 26:42:26.637
S and answer this question.

16105
26:42:26.637 --> 26:42:33.369
How do we show the recently listed NF Ts, we only want to show the active NF t's on the marketplace.

16106
26:42:33.369 --> 26:42:42.531
And now we have a system for getting only the active ones, only the ones that are currently on the market, because we're indexing these events.

16107
26:42:42.531 --> 26:42:44.864
Now, I'm going to delete all these comments here.

16108
26:42:44.960 --> 26:42:45.744
And let's do this.

16109
26:42:47.960 --> 26:42:49.681
this thing called use Morales query.

16110
26:42:50.960 --> 26:42:55.543
Morales docks, there is a hook called use Morales query.

16111
26:42:55.960 --> 26:43:00.826
this allows us to fetch and make queries to our database in a React context.

16112
26:43:00.826 --> 26:43:07.626
Back in here, we're going to say, import, use Morales query from react mirallas.

16113
26:43:07.626 --> 26:43:14.878
Now, if you look in the docs here, use mouse query returns data error is loading.

16114
26:43:14.960 --> 26:43:19.427
And this will automatically run this query the instant our index pops up.

16115
26:43:19.427 --> 26:43:29.262
So to get the data from the query to get all of our active items from our database, we'll say const data, and we'll rename data to listed and fts.

16116
26:43:29.262 --> 26:43:33.993
And then we'll also check to see if this query is still fetching.

16117
26:43:33.993 --> 26:43:44.175
So we'll say is fetching and then we'll rename that to fetching listed NF t is equals use Morales query.

16118
26:43:44.175 --> 26:43:53.403
And inside here, this takes two input parameters, it takes the table name to do the search on and then it also takes a function or the query.

16119
26:43:53.403 --> 26:43:57.912
So the table name that we're going to be looking for is going to be active item.

16120
26:43:57.961 --> 26:44:05.428
And then the function for the query is going to be we're going to say query dot, we'll limit it just to 10.

16121
26:44:05.428 --> 26:44:13.468
So we'll say only the first 10, we'll do it in dot descending order, based off the token ID.

16122
26:44:13.468 --> 26:44:21.896
And then if we wanted to do different pages, we could do this thing called dot skip with page numbers, we're not going to do page numbers here.

16123
26:44:21.896 --> 26:44:23.568
So we're just going to leave it like this for now.

16124
26:44:23.568 --> 26:44:24.068
And that's it.

16125
26:44:24.068 --> 26:44:32.961
So we're saying, okay, great, grab from our database on the active item table, grab just the first 10 in descending order of the token ID.

16126
26:44:32.961 --> 26:44:38.544
Now it's going to save the result of this to this listed NF TS section.

16127
26:44:38.544 --> 26:44:40.884
Now to see if this is working.

16128
26:44:40.884 --> 26:44:48.697
Let's just do a little console dot log listed NF t's just to see what this using Ross query actually returns for us.

16129
26:44:48.697 --> 26:44:56.199
And now we have our local blockchain Node running, we have our connection to our Morales server, and we have our front end running.

16130
26:44:56.199 --> 26:45:02.495
So let's go to our front end, we'll do a little refresh here, we'll right click and hit Inspect, we'll go to the console.

16131
26:45:02.495 --> 26:45:05.843
And we see we have this array being spit out here.

16132
26:45:05.843 --> 26:45:09.378
Now the first time it console dot logs, it's empty.

16133
26:45:09.378 --> 26:45:14.716
This is because when it initially loads listed out of T's hasn't returned yet.

16134
26:45:14.716 --> 26:45:16.914
And it's so it's actually just going to be an empty array.

16135
26:45:16.914 --> 26:45:24.212
But when it finishes loading, we're going to get an array of size one, we get an array of size one, because active item only has one enter right now.

16136
26:45:24.212 --> 26:45:36.295
So we get this array of size one, and we can see it index zero, we have class name active item, we have the item ID, we have all these attributes, which are going to be created at the marketplace address.

16137
26:45:36.295 --> 26:45:43.598
And if the address the price, the seller and the token ID this is exactly what we see in our database here.

16138
26:45:43.598 --> 26:45:44.290
So Perfect.

16139
26:45:44.290 --> 26:45:48.273
That's exactly what we want to be able to show these NF t's on the front end.

16140
26:45:48.273 --> 26:45:51.673
So how do we actually show this NFT and list this NF T.

16141
26:45:51.673 --> 26:46:01.502
For people who aren't developers and aren't going to go into the console dot log? Well, what we're going to be doing is in this return here, we'll put some parentheses around this.

16142
26:46:01.502 --> 26:46:05.131
First, we should check to see if we are fetching those listed NF T's.

16143
26:46:05.131 --> 26:46:07.223
So we'll do some JavaScript stuff.

16144
26:46:07.223 --> 26:46:11.703
And we'll say fetching listed NF T's and we'll do a ternary operator.

16145
26:46:11.703 --> 26:46:21.342
So we're gonna say if we are fetching those NF T's, let's add like a little div div that just says loading that that done, we'll put a little colon here.

16146
26:46:21.342 --> 26:46:26.748
And if we're not fetching, we'll do we'll say listed NF TS dot map.

16147
26:46:26.748 --> 26:46:37.349
So dot map basically loops through and does some function on all of the listed entities in the function we're going to want ours to do.

16148
26:46:37.349 --> 26:46:40.629
And it's going to take each NF t as input parameters.

16149
26:46:40.629 --> 26:46:43.979
So we say we're going to basically loop through each NF T.

16150
26:46:43.979 --> 26:46:50.869
And we're going to say, console dot log and F T dot attribute attributes with an S.

16151
26:46:50.963 --> 26:46:55.963
And then inside of these inside of this attributes are the different pieces that we want.

16152
26:46:55.963 --> 26:47:01.173
So we're going to get those pieces we'll say const we want to show the price.

16153
26:47:01.173 --> 26:47:15.129
The NFT address, the token ID in the marketplace address, which of course is just gonna be this one, and then the seller, that's all this information that we're going to want to show on the front end will say that equals NF T dot attributes.

16154
26:47:15.129 --> 26:47:20.108
So we're going to pull these out, and we can see price seller token ID, etc.

16155
26:47:20.108 --> 26:47:22.672
We're going to pull those out of NF T dot attributes.

16156
26:47:22.672 --> 26:47:26.897
And we can show those by in this function here, we'll say return.

16157
26:47:26.963 --> 26:47:30.338
And then we'll return some HTML, we'll do like div div.

16158
26:47:30.963 --> 26:47:47.439
we can say like price, price, price, period, and f t address and ft address, token ID, token ID seller, then added this for some reason.

16159
26:47:47.439 --> 26:47:53.748
So I'm going to delete that add $1 signs before all these for some reason, delete those, save.

16160
26:47:53.748 --> 26:48:01.878
Now if I go to the front end, I can now see information about our NFT from our database is listed here.

16161
26:48:01.963 --> 26:48:02.749
That's fantastic.

16162
26:48:04.963 --> 26:48:06.963
the token ID we see the seller.

16163
26:48:08.963 --> 26:48:13.454
marketplace, our little our little hard hat MC marketplace, let's mint another one.

16164
26:48:13.454 --> 26:48:20.816
Yarn hard hat run scripts mentalist Dash network localhost, we're going to run that it's going to mint one more.

16165
26:48:20.816 --> 26:48:28.725
If we go back to our Morales database, we do a little refresh on that active item table, we now have a new item in here.

16166
26:48:28.725 --> 26:48:32.839
So if we go back to our front end, we give this a little refresh.

16167
26:48:32.839 --> 26:48:35.339
And boom, now we have two items in here.

16168
26:48:35.339 --> 26:48:44.821
So this is awesome, we now have a way to actually show the most recently listed NF t's on our marketplace, plus ah.

16169
26:48:44.964 --> 26:48:49.259
Now, of course, you might be saying to yourself, hey, Patrick, that's cool and all.

16170
26:48:49.259 --> 26:48:51.472
But that looks really ugly.

16171
26:48:51.472 --> 26:48:53.258
And I would agree with you.

16172
26:48:53.258 --> 26:48:55.081
But 100 percent agree with you.

16173
26:48:55.081 --> 26:49:00.406
So we should come up with a component to show our listed entities that looks a lot nicer.

16174
26:49:00.406 --> 26:49:09.285
So when instead of returning and just printing out the raw information, we probably want to show the image, right, we want to show the image, we want to make everything look a lot nicer.

16175
26:49:09.285 --> 26:49:14.830
So we're going to create a new component that we're going to return in here to format all of our NF T's appropriately.

16176
26:49:14.830 --> 26:49:20.794
So we're gonna go to components, we'll do new file, and we're going to call NF T box dot j s.

16177
26:49:20.794 --> 26:49:26.229
And this is where we're going to grab all the information on how to show what our NFT actually looks like.

16178
26:49:26.229 --> 26:49:35.877
So let's get started working on our entity box, we're gonna set this up, the way we've been setting all these up would do export default function, and ft box.

16179
26:49:35.964 --> 26:49:42.705
Now something that's a little bit different for this one, though, is that in our index, we have all this information.

16180
26:49:42.705 --> 26:49:48.385
So we're gonna need to pass all these variables to our NFT Box component.

16181
26:49:48.385 --> 26:49:52.071
So to do that, we'll add them as input parameters for our component here.

16182
26:49:52.071 --> 26:49:58.754
So we'll say price, and if the address, token ID, marketplace, address, and seller.

16183
26:49:58.754 --> 26:50:04.610
So right now on our front end, we just have a whole bunch of text, and we even have this gross warning, we're gonna get rid of that tip.

16184
26:50:04.610 --> 26:50:13.261
And as we know, tokens have their token URI, which points to an image URI or an image URL of what the actual token looks like.

16185
26:50:13.261 --> 26:50:20.698
So what we're going to want to do is we're going to want to call that token URI, and then call the image URI to show the image.

16186
26:50:20.698 --> 26:50:26.276
So we're going to actually have to wait those two API requests to get the actual image.

16187
26:50:26.276 --> 26:50:31.352
And we're going to save that image as a state variable on this component here.

16188
26:50:31.352 --> 26:50:35.981
So as you already know, we're going to work with use state to keep track of that image URI.

16189
26:50:35.981 --> 26:50:41.739
So we'll do import, use state from react like this.

16190
26:50:41.965 --> 26:50:50.320
And in here, we'll say const, image, Uri, comma set image, URI equals use state.

16191
26:50:50.320 --> 26:50:53.794
And we'll start it off as a blank string.

16192
26:50:53.965 --> 26:51:01.706
Now let's create a function, we're going to call it update UI to update our UI and grab this token URI and the image URI.

16193
26:51:01.706 --> 26:51:05.817
So we'll create an async function called Update UI.

16194
26:51:05.817 --> 26:51:17.534
And in order to get the image first, we're gonna need to get the token URI, and then using the image ag from the token URI gets the image.

16195
26:51:17.534 --> 26:51:20.626
So first thing we're gonna have to do is get the token URI.

16196
26:51:20.626 --> 26:51:24.098
So we know how to do this with use web three contract.

16197
26:51:24.098 --> 26:51:29.048
So we'll do import, use web three contract from react Morales.

16198
26:51:29.048 --> 26:51:33.076
And as we know, use web through contracts is going to need some parameters.

16199
26:51:33.076 --> 26:51:42.605
So we'll say const run contract function, get token URI, equals, use web through contract.

16200
26:51:42.605 --> 26:51:48.499
First, we need the ABI of the NFT because we're gonna need to call token URI.

16201
26:51:48.499 --> 26:51:51.919
So to get the ABI we're gonna need to once again update our front end.

16202
26:51:51.966 --> 26:51:53.441
So let's comment this part out.

16203
26:51:54.966 --> 26:51:55.316
piece.

16204
26:51:55.316 --> 26:51:57.912
And let's look in our deploy scripts.

16205
26:51:58.966 --> 26:52:01.062
update front end right now.

16206
26:52:03.966 --> 26:52:04.490
object addresses.

16207
26:52:04.490 --> 26:52:05.080
Well, that's good.

16208
26:52:05.966 --> 26:52:08.353
to add API's to our front end as well.

16209
26:52:09.966 --> 26:52:11.585
function in here called Update API.

16210
26:52:12.966 --> 26:52:13.288
well.

16211
26:52:13.288 --> 26:52:16.352
So we'll do async function update API.

16212
26:52:17.966 --> 26:52:24.621
both the basic NFT API and the NFT marketplace API, because we're going to need both of them.

16213
26:52:24.621 --> 26:52:31.860
So we'll say const NF T, marketplace equals await ethers dot get contract.

16214
26:52:31.860 --> 26:52:39.299
And f t marketplace, we're going to write the ABI to the front end API location, we have the front end contracts file.

16215
26:52:39.299 --> 26:52:41.716
So let's also do a const.

16216
26:52:41.716 --> 26:53:00.320
Front and ABI location equals, and we'll do dot dot slash next, Jas, and if T marketplace dash FCC slash constants, and instead of actually just giving the file name, we can just give it the front end API location.

16217
26:53:00.320 --> 26:53:06.778
And then we'll actually have it generate that file for us because we're just going to overwrite the ABI file anytime we work with it.

16218
26:53:06.778 --> 26:53:20.717
So now that we have the marketplace, we'll just do Fs dot right file sync, and we'll do front and ABI location, and ft marketplace, dot JSON.

16219
26:53:20.717 --> 26:53:32.780
And ft marketplace, dot interface that format ethers dot utils dot format types dot JSON.

16220
26:53:32.780 --> 26:53:35.515
So we're also going to want to do that for the basic NF t.

16221
26:53:35.515 --> 26:53:48.809
So we'll say const basic NF t equals await ethers dot get contract basic NF T Fs dot right? file sync, it's going to be that exact same place right here.

16222
26:53:48.809 --> 26:53:54.655
Except for it's going to be a different location, it's going to be basic NFT dot JSON.

16223
26:53:54.655 --> 26:54:09.747
And of course, we're gonna do a comma basic NF T, that interface dot format ethers dot utils, dot format, types dot JSON, you can find this NFT marketplace that interface in the Hardhead documentation.

16224
26:54:09.747 --> 26:54:12.819
And you can find this in the ethers documentation.

16225
26:54:12.819 --> 26:54:15.441
So now we have this update ABI function.

16226
26:54:15.441 --> 26:54:23.744
Let's also add this to our module that exports so we'll do a weight up the ABI like that.

16227
26:54:23.967 --> 26:54:25.458
There's a hyphen here that shouldn't be here.

16228
26:54:25.967 --> 26:54:37.105
just this part of our hardhat front end, run yarn, hard hat, deploy dash, dash dash tags, the tag here is front end, front end.

16229
26:54:37.105 --> 26:54:40.173
And now it's had nothing to compile updating front end, it's done.

16230
26:54:40.173 --> 26:54:49.483
So if we go back to our front end, now, we go to our constants, we now see two objects in here, which are going to be API's, the basic NFT, and the NFT.

16231
26:54:49.483 --> 26:54:50.257
Marketplace.

16232
26:54:50.257 --> 26:54:50.773
Awesome.

16233
26:54:50.967 --> 26:54:54.905
So now that we have that, we can import those into our front end.

16234
26:54:54.967 --> 26:55:06.568
So we can say import, and if T marketplace, abi from dot dot slash constants slash NF T, marketplace dot JSON.

16235
26:55:06.568 --> 26:55:09.689
And we can also get the NF T API.

16236
26:55:09.689 --> 26:55:17.394
So we'll do import NF T, abi from that the slash constants slash basic NF T dot JSON.

16237
26:55:17.394 --> 26:55:23.891
Now in our run contract function, our token URI function is part of the NFT API.

16238
26:55:23.968 --> 26:55:33.843
So the API will be the NFT, abi, the contract address is going to be the address of the NFT, which we're passing in as a parameter.

16239
26:55:33.843 --> 26:55:47.905
So we'll pass an NF T address, the function name is going to be token URI, and the params are going to be the token ID, which is getting passed as an input parameter to this function to this component.

16240
26:55:47.905 --> 26:55:48.280
Right.

16241
26:55:48.280 --> 26:55:49.780
And we can double check.

16242
26:55:49.968 --> 26:55:55.381
We're good to our basic NF T dot soul, right? We scroll down, we have this token URI that we're overriding.

16243
26:55:55.381 --> 26:55:59.039
And this is the function we want to call takes the token ID.

16244
26:55:59.039 --> 26:56:02.015
So this the function we want to call takes the token ID.

16245
26:56:02.015 --> 26:56:02.586
Okay, great.

16246
26:56:02.586 --> 26:56:09.671
So in our update UI, first, we'll say const, token URI equals await token URI.

16247
26:56:09.671 --> 26:56:20.900
Now let's do a little console dot log token your eye, just to see what this returns to make sure that update UI is called, we'll add it to a use effect, we'll say use effect.

16248
26:56:20.968 --> 26:56:26.001
And this takes an input parameter of a function to do, we'll just say Update UI.

16249
26:56:26.001 --> 26:56:32.240
And then we'll only have this run anytime is web three enabled changes.

16250
26:56:32.240 --> 26:56:37.561
So we want to run update UI, but we want it to be dependent on is web three enabled.

16251
26:56:37.561 --> 26:56:42.397
And then we'll say if it's web three enabled, then update UI.

16252
26:56:42.397 --> 26:56:44.158
So we need to add use effect as well.

16253
26:56:44.158 --> 26:56:48.104
So we're using use state, we'll do comma, use effect.

16254
26:56:48.104 --> 26:56:52.419
And now we should at least be reading our token URI off the blockchain.

16255
26:56:52.419 --> 26:56:57.445
We're not going to set the image yet, right, because we're going to get the image URI from the token neuron.

16256
26:56:57.445 --> 26:57:12.746
Let's add this NFT box to our index to see if it's working well so far back in our index Next, up at the top, we will import NF T box from dot dot slash components slash NF T box.

16257
26:57:12.746 --> 26:57:20.690
And down here, while we're returning this will add our NF T box component will make sure to pass in all the parameters it takes.

16258
26:57:20.690 --> 26:57:24.461
So the price is going to equal that JavaScript price.

16259
26:57:24.461 --> 26:57:29.608
And ft address is going to equal the JavaScript entity address.

16260
26:57:29.608 --> 26:57:42.175
The token ID is going to equal the token ID, marketplace address is going to be marketplace address seller is going to be the seller.

16261
26:57:42.175 --> 26:57:49.313
And you saw that warning where it's saying, hey, all the components need to all the things in the mapping need to have their unique key.

16262
26:57:49.313 --> 26:57:52.193
So we'll say key, we'll give these all a key as well.

16263
26:57:52.193 --> 26:58:00.169
We'll say key equals this, we'll do some string interpolation, we'll just say the NFT address, combined with the token ID can be the key.

16264
26:58:00.169 --> 26:58:09.665
So if we save that, go back to our front end here, do a little refresh marketplace address is not defined market place address.

16265
26:58:09.665 --> 26:58:16.346
So let's make sure we spell things right, let's go back to the front end, we'll give it a refresh is what three enabled is not defined.

16266
26:58:16.346 --> 26:58:21.773
Oops, excuse me in the NFT box, we need to grab that from us Morales, so we'll import use Morales.

16267
26:58:21.773 --> 26:58:30.570
And in our ponents here we'll say const is web three enabled equals use Morales.

16268
26:58:30.570 --> 26:58:32.170
We'll save that.

16269
26:58:32.170 --> 26:58:36.919
And one thing I noticed actually is this needs to be wrapped in squigglies.

16270
26:58:36.970 --> 26:58:38.208
Sorry, I forgot to do that.

16271
26:58:39.970 --> 26:58:41.418
props, props input parameter.

16272
26:58:42.970 --> 26:58:45.123
props that token ID to get token ID.

16273
26:58:46.970 --> 26:58:50.901
it out by doing putting the little squiggly brackets here.

16274
26:58:50.970 --> 26:58:52.103
So put the squiggly brackets there.

16275
26:58:52.970 --> 26:58:55.749
console dot log token, your eye, or index.

16276
26:58:56.970 --> 26:58:57.407
updated.

16277
26:58:57.407 --> 26:58:57.719
Here.

16278
26:58:57.719 --> 26:58:59.156
Let's do a little save.

16279
26:59:00.970 --> 26:59:03.183
web three enabled up the UI.

16280
26:59:05.970 --> 26:59:07.451
the front end, we'll do a little refresh.

16281
26:59:07.970 --> 26:59:09.747
everything's working as expected.

16282
26:59:10.970 --> 26:59:13.170
on that hard had localhost and our meta mask.

16283
26:59:13.970 --> 26:59:16.919
can ignore this error, this warning that's up here for now.

16284
26:59:16.970 --> 26:59:25.731
And if you click this, and you have your IPFS and brave or your IPFS companion, we can now see we're getting our token URI, which is perfect.

16285
26:59:25.731 --> 26:59:27.873
The piece that we want now is this image bid.

16286
26:59:27.970 --> 26:59:42.303
And for this one that I'm using it is an HTTPS, which technically isn't decentralized, right, we would need it to come from instead of HTTPS, we would need to come from IPFS colon slash slash but but actually having it as HTTPS ipfs.

16287
26:59:42.303 --> 26:59:42.469
io.

16288
26:59:42.469 --> 26:59:45.330
For now was good, we'll explain why in just a second.

16289
26:59:45.330 --> 26:59:55.188
Now that we are getting the token URI, we can call this URL, and we can get back the image that we want to actually show on the front end.

16290
26:59:55.188 --> 27:00:11.704
So in here, we'll do a little console dot log, the token, URI is string interpolation, like this, and then we'll say if token URI, we're going to need to now grab this token URI, and get the image from it.

16291
27:00:11.704 --> 27:00:14.145
And this is where we're going to get a little bit funky.

16292
27:00:14.145 --> 27:00:15.625
And we're going to cheat a little bit.

16293
27:00:15.625 --> 27:00:23.616
Now for our application, not everybody is going to have IPFS companion, not every browser is IPFS compatible.

16294
27:00:23.616 --> 27:00:33.006
So we're gonna have to actually cheat a little bit here, we're actually going to change the token Uriah from its IPFS edition to an H HTTPS edition.

16295
27:00:33.006 --> 27:00:45.100
And this is known as using an IPFS gateway, which is a server that will return IPFS files from a normal URL.

16296
27:00:45.100 --> 27:00:54.304
So we're going to use an IPFS gateway, which we can just make regular HTTPS calls to, and it will return those IPFS files.

16297
27:00:54.304 --> 27:00:57.771
So technically, are we making the centralized doing this? Yes.

16298
27:00:57.771 --> 27:00:59.237
And is that ideal? No.

16299
27:00:59.237 --> 27:01:05.528
However, until the world adopt IPFS, and until the world adopts the standards, it's kind of what we have to do right now.

16300
27:01:05.528 --> 27:01:07.937
Because otherwise, the front end will just show up as blank to them.

16301
27:01:07.971 --> 27:01:09.987
And we can't have that we don't want that.

16302
27:01:10.971 --> 27:01:25.691
const request URL equals token URI dot replace IPFS, slash slash with HTTP s, HTTPS.

16303
27:01:25.971 --> 27:01:26.828
slash slash ipfs.

16304
27:01:26.828 --> 27:01:27.363
io/ipfs/so.

16305
27:01:28.971 --> 27:01:31.740
token URI that starts with IPFS, that's great.

16306
27:01:32.971 --> 27:01:34.825
switch it to using an IPFS gateway.

16307
27:01:35.971 --> 27:01:40.889
IPFS gateway provided by the team that builds IPFS.

16308
27:01:41.972 --> 27:01:43.972
reliable gateway is is kind of a cop out.

16309
27:01:43.972 --> 27:01:44.172
Yes.

16310
27:01:44.972 --> 27:01:46.178
still on? IPFS? Yes.

16311
27:01:46.178 --> 27:01:48.273
So it's not the end of the world.

16312
27:01:48.972 --> 27:01:52.907
is just going to make calling these API's a lot easier for us.

16313
27:01:52.972 --> 27:01:57.808
And we're going to say const token URI.

16314
27:01:59.972 --> 27:02:00.206
await.

16315
27:02:00.206 --> 27:02:02.034
And this is going to be a little weird.

16316
27:02:02.972 --> 27:02:04.222
two awaits.

16317
27:02:04.222 --> 27:02:09.597
await a weight fetch request, URL dot JSON.

16318
27:02:10.972 --> 27:02:20.876
is a keyword you can use in JavaScript to fetch or get a URL fetch keyword is essentially doing the same thing as pasting this into the browser, like so.

16319
27:02:20.876 --> 27:02:22.844
And getting this JSON response.

16320
27:02:22.972 --> 27:02:24.402
So we await to get the response.

16321
27:02:25.972 --> 27:02:26.987
response to JSON.

16322
27:02:26.987 --> 27:02:29.653
And that's how we get the toggle response.

16323
27:02:29.972 --> 27:02:37.709
we now have this object in our JavaScript, which is perfect because this object has this image attribute that we want.

16324
27:02:37.709 --> 27:02:44.125
So we're gonna do the same thing we did here, we're gonna use the IPFS gateway, this one's already using HTTPS that ipfs.

16325
27:02:44.125 --> 27:02:44.278
io.

16326
27:02:44.278 --> 27:02:46.489
But if it wasn't, we would still want to convert it.

16327
27:02:46.489 --> 27:02:48.782
So now we're gonna say const.

16328
27:02:48.782 --> 27:02:54.722
Image URI equals token you are i response dot image.

16329
27:02:54.722 --> 27:02:59.385
So we're gonna get the image tag of this response here.

16330
27:02:59.385 --> 27:03:02.902
And then we're going to say const.

16331
27:03:02.902 --> 27:03:18.022
Image URI URL, is going to equal to, and we're gonna do the exact same thing that we did up here, we're going to use the gateway image URI dot replace IPFS, colon slash slash with HTTPS ipfs.

16332
27:03:18.022 --> 27:03:19.072
io/ipfs.

16333
27:03:19.072 --> 27:03:23.743
And now, and that's how we get this URL right here.

16334
27:03:23.743 --> 27:03:30.706
And so we can finally do set image URI, to that image URL.

16335
27:03:30.706 --> 27:03:35.515
And now we have our image URI is going to be that image right here.

16336
27:03:35.515 --> 27:03:37.396
Now, is this a little bit wonky? Yes.

16337
27:03:37.396 --> 27:04:05.343
Are there better ways that we can do this? Yes, there's actually a number of better ways that we could do some of this, we could actually, since we're using Morales, we could render image on our server and just call our server, what else could we do well, or test nets and maintenance routes actually comes with a bunch of hooks like us NFT balance that will show us an F TS show us how many NF T's shows all this information about NF T's but it only works on test nets and main net, we'd have the world adopt IPFS.

16338
27:04:05.343 --> 27:04:07.214
So we don't have to do this wrapping.

16339
27:04:07.214 --> 27:04:09.544
Unfortunately, it doesn't yet so such as life.

16340
27:04:09.544 --> 27:04:20.179
But now that we're setting the image, alright, we have this image URI, we have what this actually looks like, we're going to have this and if we click on this, we use this in our browser, it returns this dog.

16341
27:04:20.179 --> 27:04:27.446
So now we have the image URI in our website, we can finally use it to show what this is going to look like.

16342
27:04:27.446 --> 27:04:30.403
So finally, we can create a return in here.

16343
27:04:30.403 --> 27:04:33.295
So down below, we'll do return to a little div.

16344
27:04:33.295 --> 27:04:36.197
And then we'll do another div just because I want to.

16345
27:04:36.197 --> 27:04:41.160
And we can do some JavaScript, we can say if if that image array exists, we'll do some stuff.

16346
27:04:41.160 --> 27:04:43.472
Otherwise, we'll do some other stuff.

16347
27:04:43.472 --> 27:04:46.989
So if it doesn't exist, maybe we'll do a div for now.

16348
27:04:46.989 --> 27:04:49.908
div that just says loading dot the dot.

16349
27:04:49.908 --> 27:04:56.661
And if it does exist, for now, we'll just say, just do a little div, close the div.

16350
27:04:56.661 --> 27:04:58.747
And we'll just say found it.

16351
27:04:58.747 --> 27:05:03.849
Now if we go back to our front end, let's see if we're good here.

16352
27:05:03.974 --> 27:05:04.374
Uh huh.

16353
27:05:07.974 --> 27:05:08.450
NF T's.

16354
27:05:08.450 --> 27:05:09.323
Okay, cool.

16355
27:05:12.974 --> 27:05:15.593
finally have the URL that we can use to show the NF T's.

16356
27:05:15.974 --> 27:05:17.552
want to actually use them next.

16357
27:05:18.974 --> 27:05:25.826
component called the image component that we can use to render images really easily just by using a URI.

16358
27:05:25.826 --> 27:05:37.240
Now, because we're going to use this image tag, and because it does some optimizations on the back end, that means that this website won't be able to be deployed to a static to a static site, like IPFS.

16359
27:05:37.240 --> 27:05:43.236
Because now our website requires a server technically, requires a server just because we have Morales.

16360
27:05:43.236 --> 27:05:56.640
So that might be another reason, we might not want to, since we're using this image tag, we can't deploy this statically to something like IPFS is we're going to up at the top, we're going to import image from next slash image.

16361
27:05:56.640 --> 27:06:12.107
And we're gonna down here we're going to say, instead of founded, we're gonna go Image, we're gonna close it off here, too, we're gonna give a loader of just a blank function that just gives us the image URI.

16362
27:06:12.107 --> 27:06:14.006
Don't worry too much about loader.

16363
27:06:14.006 --> 27:06:17.906
For now, we're gonna say the source of the image is going to be the image URI.

16364
27:06:17.906 --> 27:06:21.007
And then we'll give it a height of maybe 200.

16365
27:06:21.007 --> 27:06:24.923
And then we'll give it a width of also maybe 200.

16366
27:06:24.923 --> 27:06:29.380
And if we did this right, after we save, we should see the image on our UI.

16367
27:06:29.380 --> 27:06:35.198
So we'll go back to our website, and oh, my goodness, we can see the dogs holy cow.

16368
27:06:35.198 --> 27:06:36.704
This is getting really exciting.

16369
27:06:36.704 --> 27:06:41.700
We can see the puppies, we can see the images, we're definitely doing something right here, which is really exciting.

16370
27:06:41.700 --> 27:06:44.338
Now I know I said this before that this isn't a CSS.

16371
27:06:44.338 --> 27:06:49.325
This isn't a formatting tutorial, because that's definitely not my expertise.

16372
27:06:49.325 --> 27:06:51.775
However, let's make this look a little bit nicer.

16373
27:06:51.775 --> 27:06:59.506
And we're going to use once again, the web three UI kit, because the web three UI kit has a whole bunch of tools that are really, really helpful for us to use.

16374
27:06:59.506 --> 27:07:08.991
So if we go to the web three UI kit, we can go to that live storybook Another interactive bit, and we can scroll down to the section that has called card.

16375
27:07:08.991 --> 27:07:14.708
Or we can make these little clickable cards and we can display some information about our nfts.

16376
27:07:14.708 --> 27:07:22.182
So let's go ahead and at the top, we'll do import import card from web three UI kit.

16377
27:07:22.182 --> 27:07:28.590
And now instead of just showing the image, we'll wrap the image in a card like this.

16378
27:07:28.590 --> 27:07:29.820
We'll save that.

16379
27:07:29.975 --> 27:07:34.087
Now back on our front end, give it a little refresh.

16380
27:07:34.975 --> 27:07:38.229
got this kind of clickable section that looks a little bit nicer.

16381
27:07:38.229 --> 27:07:39.245
We'll even label it.

16382
27:07:39.245 --> 27:07:42.100
And we can even label it with a title and description.

16383
27:07:42.100 --> 27:07:47.337
Now we can grab the title and the description from the token URI response.

16384
27:07:47.337 --> 27:07:54.128
So up at the top, let's go ahead, let's grab the title and the description of the token UI as a state variable.

16385
27:07:54.128 --> 27:08:10.841
So we'll say const, token name, set token name, equals use state, start off as blank, the const token description, that token description, equals use state.

16386
27:08:10.975 --> 27:08:17.120
Start off as blank to download, we do this update UI bit, we'll call set token name.

16387
27:08:17.120 --> 27:08:29.547
So we'll say name is token, your response dot name, we'll say set token description, which will be token, your response dot description.

16388
27:08:29.547 --> 27:08:33.642
And then we'll use those descriptions and title in the cart.

16389
27:08:33.642 --> 27:08:43.090
So we'll say title equals token name, description equals token description.

16390
27:08:43.090 --> 27:08:44.190
Save that.

16391
27:08:44.190 --> 27:08:45.957
We'll look at our front end here.

16392
27:08:45.957 --> 27:08:47.467
Give it a little refresh.

16393
27:08:47.467 --> 27:08:50.274
Oh, and now we have the name of the NFT.

16394
27:08:50.274 --> 27:08:51.925
And its description on our front end.

16395
27:08:51.925 --> 27:08:52.297
Okay, cool.

16396
27:08:52.297 --> 27:08:52.873
Let's keep going.

16397
27:08:52.976 --> 27:08:56.500
What else do we want on this? Well, we probably want who it's owned by.

16398
27:08:56.500 --> 27:09:02.925
So we'll put a little div inside the card, say div, maybe we'll even put the token ID we'll do a little number.

16399
27:09:02.976 --> 27:09:05.809
With the token ID.

16400
27:09:05.976 --> 27:09:08.926
We'll do another little div, and then we'll make this italic.

16401
27:09:08.976 --> 27:09:11.320
We'll say class name equals italic.

16402
27:09:13.976 --> 27:09:14.652
to be small.

16403
27:09:17.976 --> 27:09:20.507
the seller that we're passing in as an input parameter.

16404
27:09:20.976 --> 27:09:23.492
maybe underneath the image, we want to put the price.

16405
27:09:23.976 --> 27:09:25.235
a little div here.

16406
27:09:27.976 --> 27:09:32.588
However, we're probably don't want it in way we want it in human readable units.

16407
27:09:32.588 --> 27:09:37.583
So we'll import ethers, we'll say import ethers from ethers.

16408
27:09:37.583 --> 27:09:50.874
And then instead of just showing the price, we'll do a little, little JavaScript and here we'll do ethers dot utils dot format, units, price, price and ether.

16409
27:09:50.976 --> 27:09:52.449
And then we'll do space eath.

16410
27:09:53.976 --> 27:10:01.330
class name equals font bold, so we can read how much it's listed for on our marketplace.

16411
27:10:01.330 --> 27:10:05.460
Let's go back a high we can now see, this is token ID number four.

16412
27:10:05.460 --> 27:10:10.681
We can see who it's owned by we'd see the price of it and then more information about the dog.

16413
27:10:10.681 --> 27:10:10.877
Yay.

16414
27:10:10.977 --> 27:10:13.783
Now let's format all this stuff in here a little bit nicer.

16415
27:10:13.977 --> 27:10:16.993
let's wrap everything in a div in one more div.

16416
27:10:17.977 --> 27:10:19.649
say class name is going to be flex.

16417
27:10:20.977 --> 27:10:26.262
format everything, we'll put everything in a column items and get to.

16418
27:10:26.262 --> 27:10:36.614
And now if we look back there, kind of like in a column now, wrapping one more div, give them some padding, last name equals P to say a little bit padding has been added.

16419
27:10:36.614 --> 27:10:37.239
Okay, nice.

16420
27:10:37.239 --> 27:10:42.813
And then we'll go back to our index, and we'll add some formatting to our index here.

16421
27:10:42.813 --> 27:10:48.910
So our main one, we're going to remove styles dot container, we're just gonna say container.

16422
27:10:48.977 --> 27:11:02.944
MX auto, we're going to make an h1 in here, class name, equals, I form E X for font bold text to XML.

16423
27:11:02.944 --> 27:11:13.215
This is we're just gonna say recently listed, then we're going to do another div.

16424
27:11:13.215 --> 27:11:17.352
Class, name equals flex, flex wrap.

16425
27:11:17.352 --> 27:11:22.215
We're going to end this div around our JavaScript here.

16426
27:11:22.215 --> 27:11:23.405
And let's look at our UI.

16427
27:11:23.405 --> 27:11:24.892
And let's see what that does.

16428
27:11:24.892 --> 27:11:25.451
Okay, cool.

16429
27:11:25.451 --> 27:11:26.823
Let's go back to our index.

16430
27:11:26.977 --> 27:11:27.892
Let's remove all this stuff.

16431
27:11:28.977 --> 27:11:29.738
the card.

16432
27:11:29.738 --> 27:11:30.785
Let's save.

16433
27:11:34.977 --> 27:11:40.147
able to start listening our NF Ts and then have them show up on our marketplace like we see here.

16434
27:11:40.147 --> 27:11:40.825
Fantastic.

16435
27:11:40.825 --> 27:11:44.723
Okay, if we go to the readme homepage show recently listen to empties.

16436
27:11:44.723 --> 27:11:47.863
Oh, my goodness, this is a check we're done here.

16437
27:11:47.863 --> 27:11:52.332
Now, and I know what seemed like a lot of work, but a lot of it was setting up that morale server correctly.

16438
27:11:52.332 --> 27:11:57.299
And because we have our own back end, now, we have some back end services that we needed to configure.

16439
27:11:57.299 --> 27:12:00.692
But now that everything's set up, the rest of this is going to be easy St.

16440
27:12:00.692 --> 27:12:04.995
Now we are only going to want this to show if we're connected to web three.

16441
27:12:04.995 --> 27:12:07.885
Right? Now, if we click this, this still shows up.

16442
27:12:07.885 --> 27:12:11.523
So we're going to have to update this a little bit.

16443
27:12:11.523 --> 27:12:13.068
And in our index.

16444
27:12:13.068 --> 27:12:16.789
js, we're now we're checking to see fetching.

16445
27:12:16.789 --> 27:12:23.617
Listen, NF T's right before that, right? Before we do that we actually want to see is web three enabled.

16446
27:12:23.617 --> 27:12:26.995
And this is going to be a little bit of nested tertiary operations.

16447
27:12:26.995 --> 27:12:31.639
If web three is enabled, then we're going to do all this fetching, listed NF T's stuff here.

16448
27:12:31.639 --> 27:12:33.748
We're gonna do everything in here.

16449
27:12:33.748 --> 27:12:42.863
So if it's not enabled, let's do like a little div that says web three, currently not enabled.

16450
27:12:42.978 --> 27:12:46.437
And of course, we're going to need to grab is web three enabled.

16451
27:12:46.437 --> 27:12:59.774
So we're going to say, for the top we'll do const is what three enabled equals use oralis as we've been doing, and we're going to grab use Morales from react Morales, we'll save that go back to our front end, give it a little refresh.

16452
27:12:59.774 --> 27:13:02.043
If we're connected, we'll see the marketplace.

16453
27:13:02.043 --> 27:13:06.913
If we disconnect, we see web three currently not enabled, which is what we want.

16454
27:13:06.978 --> 27:13:07.415
Perfect.

16455
27:13:07.415 --> 27:13:09.290
So what is next in our readme.

16456
27:13:10.978 --> 27:13:11.878
update the listing.

16457
27:13:13.978 --> 27:13:15.896
actually is the owner of these entities.

16458
27:13:16.978 --> 27:13:18.758
easy for the people on this website.

16459
27:13:19.979 --> 27:13:26.364
the person's Metamask by grabbing the account from us mouse, so we'll do a comma account.

16460
27:13:26.364 --> 27:13:35.882
So then we can easily just do const is owned by user equals seller equals equals equals account.

16461
27:13:35.882 --> 27:13:47.269
So the seller we're getting from the contract, the account we're getting from whoever's connected here, if the seller equals the account, there is no seller equals equals equals undefined.

16462
27:13:47.269 --> 27:13:50.172
We'll just say they're owned by you.

16463
27:13:50.172 --> 27:14:06.093
And now instead of saying owned by seller, we can say const, formatted seller address equals, and we'll do the ternary operator will say if it's on by you, then we'll just say you instead of seller.

16464
27:14:06.093 --> 27:14:07.929
Otherwise, we'll say seller.

16465
27:14:07.929 --> 27:14:11.282
Now we'll say owned by formatted seller address like this.

16466
27:14:11.282 --> 27:14:15.792
So if we go back to our front end, we do a little refresh.

16467
27:14:15.792 --> 27:14:19.733
depending on who's connected, you might see owned by blah, blah, blah.

16468
27:14:19.733 --> 27:14:29.979
Now if I go to my Metamask, let me go ahead and switch account to account three, let's go ahead and connect our account three, we now see owned by you instead.

16469
27:14:29.979 --> 27:14:43.432
Right, and we can even switch again, we'll switch accounts again, we'll switch to account one, we now see owned by blah, blah, blah, like so since when we switch back and forth, the diameters of this actually change which is really annoying.

16470
27:14:43.432 --> 27:14:45.317
So maybe we want to go one step further.

16471
27:14:45.317 --> 27:14:49.179
And we want to truncate this seller address make it a little bit smaller.

16472
27:14:49.179 --> 27:14:52.312
So we want to make a seller a little bit smaller.

16473
27:14:52.312 --> 27:14:53.788
So let's create a new function.

16474
27:14:53.788 --> 27:15:03.081
And we can create this outside of the export default function because this is going to be a function that doesn't depend on anything inside our app.

16475
27:15:03.081 --> 27:15:04.606
It's just going to be kind of a raw function.

16476
27:15:04.606 --> 27:15:15.750
So we're going to create we'll call it const truncate string, and this is going to be a function that takes a full string, and a string length as parameters.

16477
27:15:15.750 --> 27:15:20.776
And we're just going to pass the seller address and how long we want to make this string.

16478
27:15:20.776 --> 27:15:31.115
So this is going to be an arrow function we're going to do here, and we're gonna say, if all string dot length is less than or equal to str Lang, return full str.

16479
27:15:31.115 --> 27:15:37.265
Otherwise, we'll say concept ra torx equals three little dots.

16480
27:15:37.265 --> 27:15:43.480
And we'll say, Let's separate Tor length equals Sep.

16481
27:15:43.480 --> 27:15:45.730
Ra Tor dot length.

16482
27:15:45.730 --> 27:15:59.426
To make con separator length, we'll say const chars to show is going to be the the string length minus the separator length, we'll say const.

16483
27:15:59.426 --> 27:16:16.130
Front chars or front characters is going to equal math dot ceiling chars to show divided by two const back chars is going to equal math dot floor, chars to show divided by two.

16484
27:16:16.130 --> 27:16:19.583
And if you don't understand this math here, don't worry about it.

16485
27:16:19.583 --> 27:16:33.963
And then we're gonna say return full string substring of zero to front chars plus the SEP IRA tour plus full STR dot substring.

16486
27:16:33.963 --> 27:16:38.747
of full STR dot length, minus back chars.

16487
27:16:38.981 --> 27:16:55.896
And now what we can do is we can grab this truncate STR this truncate string and for is formatted seller will say if it's you will still do you but otherwise we'll do truncate string of seller or blank if there's no seller, and we'll have it be size 15.

16488
27:16:55.896 --> 27:17:01.918
And now if we save that, go back to our front end, if it's owned by you, it's still gonna say on by you.

16489
27:17:01.981 --> 27:17:08.925
But if we switch accounts, and now says owned by, you know, blah, blah, blah, dot the dot blah, blah, blah with a truncated address.

16490
27:17:08.925 --> 27:17:14.425
And then these sizes don't actually change, which is a lot nicer than them getting bigger and smaller.

16491
27:17:14.425 --> 27:17:15.123
So awesome.

16492
27:17:15.123 --> 27:17:17.789
So now we have this formatted even better.

16493
27:17:17.981 --> 27:17:29.997
Okay, now what do we want to do? Well, now that we know who owns the NFT, NF T, and it's formatted pretty nicely, we need to figure out a way to update the listing.

16494
27:17:29.997 --> 27:17:41.581
So what we want to do is, once again, if it's owned by us, and we can switch back to the account, it's owned by if it's owned by us, when we click on it, we want to be able to update the listing on the marketplace.

16495
27:17:41.581 --> 27:17:47.027
So to do this, we're going to create a new component called Update listing ngModel.

16496
27:17:47.027 --> 27:17:54.888
So we're gonna create a new component, new file, update, listing ngmodel.

16497
27:17:54.888 --> 27:17:55.134
js.

16498
27:17:55.134 --> 27:17:58.821
A ngModel is something that like pops up.

16499
27:17:58.821 --> 27:18:02.996
So for example, this little pop up here is known as a modal.

16500
27:18:02.996 --> 27:18:04.600
And this is what we want to build.

16501
27:18:04.600 --> 27:18:08.384
If it's owned by us, when we click this, we want it to pop up this modal thing.

16502
27:18:08.384 --> 27:18:20.084
So to get started, we'll do the same thing we've been doing for all of our components here, we'll do export default, function, update, listing ngModel, like so.

16503
27:18:20.084 --> 27:18:27.505
And we're probably going to want to pass it these parameters from the entity box, probably gonna want to pass these parameters.

16504
27:18:27.505 --> 27:18:31.876
So the ngModel knows what function it needs to call in our NFT marketplace.

16505
27:18:31.876 --> 27:18:39.403
The way we're going to update listing is we're going to call this update listing function where we need the address token ID and then some new price.

16506
27:18:39.403 --> 27:18:41.184
So we're going to at least need those.

16507
27:18:41.184 --> 27:18:56.809
So we're going to need the NFT address, and at least the token ID to make this little pop up, we're not going to code it ourselves, we're going to once again, use the web three UI kit, web three UI Kit has this nice pop up section, where it has some code to work with a modal.

16508
27:18:56.809 --> 27:19:09.870
So we're going to import that will do import ngModel from web three UI kit, like so here's what it looks like we have modal and then we have all this stuff on working with the modal.

16509
27:19:09.870 --> 27:19:13.178
So we'll do our return, do a little modal, like this.

16510
27:19:13.178 --> 27:19:17.134
One of the key things in a ngModel is whether or not it should be visible.

16511
27:19:17.134 --> 27:19:24.151
So it has an is visible tag, which we're actually gonna have to grab, we're actually gonna have to grab from the empty box.

16512
27:19:24.151 --> 27:19:31.548
So we're going to pass a little is visible here as well, in our NFT box, we need to tell our ngModel when it's visible.

16513
27:19:31.548 --> 27:19:34.093
So we'll we'll make that code in a little bit.

16514
27:19:34.093 --> 27:19:35.241
Right now, it'll just be blank.

16515
27:19:35.241 --> 27:19:39.439
And inside of our ngModel, we're going to want to give an input field for how to update it.

16516
27:19:39.439 --> 27:19:46.604
So I know we've done some regular inputs before, since we've been working with web through UI kit, let's just use the input that it has as well.

16517
27:19:46.604 --> 27:19:48.696
So we'll do a little comma input here.

16518
27:19:48.696 --> 27:19:52.304
And inside of the ngModel we'll create a new input.

16519
27:19:52.304 --> 27:19:59.261
So on our input field, we'll give this a label which is going to be update listing price in L one currency.

16520
27:19:59.261 --> 27:20:00.733
And we'll just do eath.

16521
27:20:00.733 --> 27:20:14.935
For now we'll just hard coded as eath name will be new listing price, and type is going to equal a number we'll do Little backslash here, oops, we'll do a little backslash instead of like that.

16522
27:20:14.935 --> 27:20:15.315
So cool.

16523
27:20:15.315 --> 27:20:18.386
So when this modal pops up, it's gonna have this input in here.

16524
27:20:18.386 --> 27:20:21.590
And we can actually test to see if this is working.

16525
27:20:21.590 --> 27:20:29.120
We can import this into our NFT box, we'll do import, update, listing ngModel.

16526
27:20:29.120 --> 27:20:38.260
From that slash, update, listing ngModel oops, and sorry, this doesn't need parentheses, and at the top of our return here, right before our card will add it in.

16527
27:20:38.260 --> 27:20:40.352
So we'll just add another div though.

16528
27:20:40.352 --> 27:20:42.998
So that these two can be in the same react.

16529
27:20:42.998 --> 27:20:49.383
But we'll add another div, we'll say Update listing ngModel, like so with a little backslash here.

16530
27:20:49.383 --> 27:20:52.427
And right now we just have to pass is visible.

16531
27:20:52.427 --> 27:20:55.411
And then for now, we're just going to say true.

16532
27:20:55.411 --> 27:20:59.333
So now with this listing ngModel on our front end, we do a little refresh.

16533
27:20:59.333 --> 27:21:03.140
And we get this little box like this update listing price and one currency.

16534
27:21:03.140 --> 27:21:04.876
And we have to close two of them.

16535
27:21:04.983 --> 27:21:08.921
Because technically we right now both modalities are true, right.

16536
27:21:08.983 --> 27:21:18.554
So if we do a refresh, we get this little input pop up this little modal and we close it twice, because we have two NF T's if you have a ton of NF T's here, you will have to close a ton of those.

16537
27:21:18.554 --> 27:21:25.189
So we change it to false, we go back to the front end, we do a little refresh, and boom, now it's false.

16538
27:21:25.189 --> 27:21:28.661
So true, save, run, and it's there.

16539
27:21:28.661 --> 27:21:33.883
Gross, delete, delete, false, save front end, it's not there anymore.

16540
27:21:33.883 --> 27:21:34.433
Okay, cool.

16541
27:21:34.433 --> 27:21:40.852
So we're gonna have to tell this ngModel only to pop up when somebody clicks this and have tea that they own.

16542
27:21:40.852 --> 27:21:45.250
So to actually toggle this and actually make this work, we're going to update our card.

16543
27:21:45.250 --> 27:21:55.951
So whenever we click our card, we're going to create a function called handle card click that handle card click is going to update a variable for whether or not we should show this ngModel.

16544
27:21:55.951 --> 27:22:04.896
So we're going to do is we're gonna say on click of the card, aka, once we click our dog, we're going to call some function.

16545
27:22:04.896 --> 27:22:18.629
So we're gonna say on click, equals handle card, click, animal card, click, and we're going to make this a function, we're gonna say const, handle card click equals a function, we'll use some Arrow stuff here.

16546
27:22:18.629 --> 27:22:26.871
And then we'll just say, if it's is owned by user, if it's on by user, we'll show the ngModel.

16547
27:22:26.871 --> 27:22:33.361
Else, we will call the by item function, since we want our whole UI to rerender.

16548
27:22:33.361 --> 27:22:39.284
Once we change, once we change the variable to show the ngModel, we're going to do this as a US state.

16549
27:22:39.284 --> 27:22:42.584
So we'll say const, show ngModel.

16550
27:22:42.584 --> 27:22:45.825
Come a set, show ngModel equals use state.

16551
27:22:45.825 --> 27:22:49.734
And then we're going to start it off being defaulted to false.

16552
27:22:49.734 --> 27:22:53.262
So by default, we are not going to show them on down which is what we want.

16553
27:22:53.262 --> 27:22:59.466
But if it's owned by the user, we're gonna say Set Show ngModel to be true.

16554
27:22:59.466 --> 27:23:07.301
And then else right now we'll just put console dot log, let's buy will actually update this to bind the item a little bit later.

16555
27:23:07.301 --> 27:23:12.904
So now instead of having is visible be false, we'll have is visible equal to show ngModel.

16556
27:23:12.904 --> 27:23:13.864
Or show ngModel.

16557
27:23:13.984 --> 27:23:14.359
Variable.

16558
27:23:14.359 --> 27:23:14.921
Okay, great.

16559
27:23:16.984 --> 27:23:28.554
UI, we right click, we hit Inspect, if we own it, and we click it, the ngModel will pop up, and we can click it out, click another one, but that will pop up if we don't own it.

16560
27:23:28.554 --> 27:23:31.542
So if we switch accounts, Connect will switch.

16561
27:23:31.542 --> 27:23:33.494
We click it, nothing happens.

16562
27:23:33.494 --> 27:23:43.207
And if we go to inspect, we go to the console, we click it, we should see let's buy pop up, which is what we do see, we'll do a little refresh here.

16563
27:23:43.207 --> 27:23:49.178
Click we see let's buy pop up, click again, let's buy click let's pilots pilots, why? Great, cool.

16564
27:23:49.178 --> 27:23:51.065
So now we have a word for that ngModel.

16565
27:23:51.065 --> 27:24:11.509
To actually show up correctly, let's switch back to the person who actually owns this NFT we click it, we want to be able to when we hit OK, or submit, we want to send a transaction to update the price of our NFT here, so what we can do is in our input will have a label called on change equals and this is the function that will call whenever this updates.

16566
27:24:11.509 --> 27:24:15.568
So we're gonna say on change event is going to be a function.

16567
27:24:15.568 --> 27:24:25.348
And we're going to create a function called set price to update listing listing with event dot target dot value.

16568
27:24:25.348 --> 27:24:29.307
So we want to keep track of whatever we've put in here.

16569
27:24:29.307 --> 27:24:32.951
So when we call the function to update the price, it'll just already automatically have it.

16570
27:24:32.985 --> 27:24:39.467
So we'll create this function and event dot target dot value is going to be whatever's in this input box here.

16571
27:24:39.467 --> 27:25:01.902
So we'll create this set price to update listing with will have this be a use date because we are going to want to change the UI based off this so we'll say const price to up date listing with comma set price to update listing with equals use state and then we'll have this be zero to start or blank.

16572
27:25:01.902 --> 27:25:05.938
And so now, whatever is in here is going to get updated with this.

16573
27:25:05.938 --> 27:25:18.297
So now I can do like our console dot log price update listing with Get back to the front end, oops, we need to import use state import, use state from react.

16574
27:25:18.297 --> 27:25:23.886
Go back to the front end, we click this, we right click Inspect.

16575
27:25:23.986 --> 27:25:26.562
By type one, we can see 114, we see 14.

16576
27:25:27.986 --> 27:25:29.173
console dot log now.

16577
27:25:31.986 --> 27:25:36.936
field called on okay, this is going to be the function that we call when we hit this, okay here, so on.

16578
27:25:36.936 --> 27:25:49.401
Okay, it's going to be equal to a function, we're going to use a little arrow notation, and we're going to call that update listing function on the blockchain, we're going to need to grab that function so we can use it.

16579
27:25:49.401 --> 27:25:57.282
So once again, to use that function, we're going to import use web three contract from react mirallas.

16580
27:25:57.282 --> 27:26:07.379
And as a new hook, we'll say const run contract function called Update listing, equals use web three contract.

16581
27:26:07.379 --> 27:26:12.936
And this is going to be a function that we're going to call on our NFT marketplace.

16582
27:26:12.936 --> 27:26:22.534
So ABI is going to be the NFT marketplace API, which we can get by doing an import, similar to what we did over here.

16583
27:26:22.534 --> 27:26:26.017
And we actually just copy paste from our NFT box.

16584
27:26:26.017 --> 27:26:40.760
So we'll do import NFT marketplace API from dot dot constant send it to marketplace that JSON, we're gonna need the contract address, which is going to be an input parameter to our update listing ngModel.

16585
27:26:40.760 --> 27:26:53.987
So we can even do a comma market place address, copy this place that here, that means in our NFT box, pretty soon, we're going to have to pass all these variables to it, but we'll save that in just a second.

16586
27:26:53.987 --> 27:27:03.602
So NFT marketplace address marketplace address function name, is going to be what it's called Update, listing in our smart contract, and then the params.

16587
27:27:03.602 --> 27:27:25.642
So if we go to this, we have update listing takes the NFT address token ID and new price do NFT address, which will be NFT address, we'll say token ID is going to be token ID and the new price your price will get from price to update listing with but will convert it from human readable to ethers.

16588
27:27:25.642 --> 27:27:29.802
So we'll import ethers from ethers.

16589
27:27:29.802 --> 27:27:44.422
And the new price will be ethers dot utils dot parse ethers or ether price to update listing with or just in case it's blank, we'll just say or zero.

16590
27:27:44.422 --> 27:27:51.936
So we have the NFT address the token ID marketplace address in our NFT box, we're gonna have to pass those parameters in here.

16591
27:27:51.987 --> 27:28:03.415
So we have is visible, we're also going to have token ID, which is going to equal token ID, marketplace address is going to equal the marketplace address.

16592
27:28:03.415 --> 27:28:08.487
And the NFT address is going to equal the NFT address.

16593
27:28:08.487 --> 27:28:15.748
And as we code and test this something that's going to be really annoying, because it's really annoying for me right now let's refresh our website.

16594
27:28:15.748 --> 27:28:17.715
And if we click it, this thing pops up.

16595
27:28:17.715 --> 27:28:21.209
But when I hit X, and I click this, again, nothing shows up.

16596
27:28:21.209 --> 27:28:26.246
That's because technically show ngModel is still true right now, even though we've exited out.

16597
27:28:26.246 --> 27:28:45.083
So what we want to do in the NFT box is in our update listing ngModel we're also going to pass it in on close, and we're going to pass it a hide ngModel variable that we're going to create, and right under Show ngModel Set Show ngModel we're going to create const Eid ngModel.

16598
27:28:45.083 --> 27:28:51.665
And this is just going to be a function, that's just going to say set, show modal.

16599
27:28:51.665 --> 27:28:57.552
to false, we're going to pass this function to our update modal listing.

16600
27:28:57.552 --> 27:29:00.455
So we're going to do comma on Close.

16601
27:29:00.455 --> 27:29:05.445
And in our modal here, we're going to say, on Close.

16602
27:29:05.445 --> 27:29:17.925
On, cancel, we're going to do, we're going to call that on close function, or on Close button pressed, we're also going to call that on close function.

16603
27:29:17.988 --> 27:29:29.670
Now if we refresh our website, click this modal pops up, we click X, click it again, it'll pop back up, because now we're properly setting it to false and then resetting it to true.

16604
27:29:29.670 --> 27:29:40.428
Now to actually send this update listing function, we're going to pass this another thing, another variable, we're going to pass it on Okay, which is going to be a function as well.

16605
27:29:40.428 --> 27:29:44.254
It's just going to call update listing that we just created.

16606
27:29:44.254 --> 27:29:47.375
Now, it's always a good idea to add an On error.

16607
27:29:47.375 --> 27:29:54.854
We'd say on error, take that error as a function and console dot log.

16608
27:29:54.988 --> 27:30:01.750
The error and this needs to be in squiggly brackets like that, but contract address is wrong.

16609
27:30:01.750 --> 27:30:09.575
So we'll make this contract, con tract address and spell that correctly.

16610
27:30:09.575 --> 27:30:11.747
Spelled correctly.

16611
27:30:11.989 --> 27:30:14.939
Now let's go back to the UI, we'll give it a little refresh.

16612
27:30:14.989 --> 27:30:16.864
Click, this will add one.

16613
27:30:16.864 --> 27:30:18.973
And we see Metamask pop up.

16614
27:30:19.989 --> 27:30:20.989
working out perfectly.

16615
27:30:22.989 --> 27:30:23.881
gonna freak out and stuff.

16616
27:30:24.989 --> 27:30:28.726
fantastically okay app popped up like that, which is good.

16617
27:30:28.989 --> 27:30:33.284
have this little error handling, which I like to add for all of these run contract functions.

16618
27:30:33.284 --> 27:30:35.579
Let's also do an on success.

16619
27:30:35.579 --> 27:30:42.560
So let's say when this does go through successfully, we'll call a function called handle update, listing success.

16620
27:30:42.560 --> 27:30:46.284
And this will be a function that we'd call when this goes through correctly.

16621
27:30:46.284 --> 27:30:48.609
So at the top, let's make this new function, we'll say const.

16622
27:30:48.609 --> 27:30:54.655
Handle update, listening success is going to be a new function using the arrow syntax here.

16623
27:30:54.655 --> 27:30:59.639
And we'll have this setup a new notification for a web application.

16624
27:30:59.639 --> 27:31:09.389
So for us to do notifications, we're going to use web three UI Kits use notification, this is going to be that same notification service that we used in our last one.

16625
27:31:09.389 --> 27:31:13.682
So up at the top here, we'll import it, use notification.

16626
27:31:13.682 --> 27:31:20.368
And then we'll say, right in our component, we'll say const, dispatch equals use notification.

16627
27:31:20.368 --> 27:31:24.623
And since we're using notifications back on our app.

16628
27:31:24.623 --> 27:31:26.654
js, we have to import it in here.

16629
27:31:26.654 --> 27:31:32.150
So we'll do import notification provider from web three UI kit.

16630
27:31:32.150 --> 27:31:44.871
And inside of our Morales provider, we'll add the notification provider around our header and our component, so that we have context for this.

16631
27:31:44.990 --> 27:31:54.227
Now in our handle update listing success, inside this function will say dispatch, say type is going to be success.

16632
27:31:54.227 --> 27:32:07.561
message will be listing updated, title will be listing updated, please refresh, please refresh and move blocks.

16633
27:32:07.561 --> 27:32:10.132
And then position.

16634
27:32:10.132 --> 27:32:11.615
Top right.

16635
27:32:11.615 --> 27:32:17.240
And then we'll do on clothes, and on clothes.

16636
27:32:17.240 --> 27:32:23.679
And we'll say set price to update listing with back to zero.

16637
27:32:23.679 --> 27:32:25.735
I also I'm editing this a little bit in the future.

16638
27:32:25.735 --> 27:32:31.056
And I realized that I actually forgot to add the TX to a lot of these handle functions.

16639
27:32:31.056 --> 27:32:38.723
So on these, whenever we call one of these run contract functions, like we've been saying they have this on error in this onsuccess.

16640
27:32:38.723 --> 27:32:46.406
Now this onsuccess automatically passes the result of the call to whatever callback function is there.

16641
27:32:46.406 --> 27:32:55.610
So for example, up the listing returns a transaction, and we'll pass that transaction to whatever you add to the onsuccess.

16642
27:32:55.610 --> 27:33:00.168
So now in here, you can actually have it have a transaction as an input parameter.

16643
27:33:00.168 --> 27:33:04.974
And this would be the transaction that's going to go on the blockchain to you know, update the price.

16644
27:33:04.974 --> 27:33:09.891
So we actually want to change it from a regular function to an async function.

16645
27:33:09.891 --> 27:33:18.580
So we can actually do await TX dot Wait, one, because we don't want to say, hey, success, you know, listing has been updated before the transaction actually goes through.

16646
27:33:18.580 --> 27:33:20.892
So we want the transaction to go through first.

16647
27:33:20.991 --> 27:33:34.635
And then we want to pop the dispatch up saying, hey, it's gone through so and then additionally, when we actually call these modells on the on, okay, on the onsuccess, we pass them in just by referencing the name of the function.

16648
27:33:34.635 --> 27:33:45.829
So we don't do this arrow syntax, anymore like this, we just say, hey, the onsuccess is going to be this, go ahead and pass your results to it.

16649
27:33:45.829 --> 27:33:48.667
So that's how we actually call it down here.

16650
27:33:48.667 --> 27:33:53.406
If you look at the GitHub repo associated with this, you go to components, and we go into these.

16651
27:33:53.406 --> 27:33:57.680
So in this video, I forgot to add the await TX dot wait one.

16652
27:33:57.680 --> 27:33:59.925
But in the GitHub repo, we have these.

16653
27:33:59.925 --> 27:34:06.991
And when I'm demoing things in the video here, the dispatch, it's gonna pop up before the transaction actually finishes going through.

16654
27:34:06.991 --> 27:34:09.391
So just want to let you know, and back to the video.

16655
27:34:09.391 --> 27:34:13.885
So now we have a little success thing that'll pop up when we're successful.

16656
27:34:13.885 --> 27:34:27.313
And the other thing is, when we call this, we are going to omit an item listed inside of our Morales dashboard, the price should actually update in our active item because of our Cloud Functions.

16657
27:34:27.313 --> 27:34:30.184
So we're going to put this all together now.

16658
27:34:30.184 --> 27:34:31.861
So we're on the front end.

16659
27:34:31.991 --> 27:34:35.429
And if the marketplace owned by you will click it.

16660
27:34:35.991 --> 27:34:37.249
listing to 25.

16661
27:34:41.991 --> 27:34:49.591
We're gonna go ahead and confirm and ran through an error because we need to click Metamask I need to reset my account.

16662
27:34:49.591 --> 27:34:54.879
So I'm going to do settings, advanced reset account.

16663
27:34:54.991 --> 27:35:05.955
Okay, now let's go ahead Metamask has popped up again, we're gonna go ahead and confirm it closed, the pop up modal, and we got our little notification there.

16664
27:35:05.955 --> 27:35:14.942
And we can see an activity we have that transaction has indeed completed So now if we go to active item, we give it a little refresh.

16665
27:35:14.992 --> 27:35:18.106
Right now we see our item listed event.

16666
27:35:19.992 --> 27:35:21.458
it's not confirmed yet.

16667
27:35:23.992 --> 27:35:26.242
we're going to need to move our blocks by one.

16668
27:35:26.992 --> 27:36:09.942
marketplace, we're just going to create a new script, a new file called Mind dot Jas, just to move our blocks once, and we're going to say const, move blocks, equals require dot slash utils, slash move blocks, we'll say const blocks equals to const sleep amount equals 1000 async function mine, do await move blocks will do blocks as the parameter and then sleep sleep amount will equal sleep amount.

16669
27:36:09.942 --> 27:36:12.499
And this will be a script.

16670
27:36:12.499 --> 27:36:18.280
So we'll add our copy paste our that same syntax we're doing here just with mine.

16671
27:36:18.280 --> 27:36:21.680
And now we want to just mine these two blocks.

16672
27:36:21.680 --> 27:36:26.155
So we'll run yarn, art hat run scripts.

16673
27:36:26.155 --> 27:36:30.753
Mind that Jas dash dash network, local host.

16674
27:36:30.753 --> 27:36:34.468
So we're going to mine those two blocks.

16675
27:36:34.468 --> 27:36:53.135
Now if we go back to our database, we go back to active items, we can see it's been updated because now in our item listed, that 2500 event is now a confirmed transaction, and we get to confirm their excellent.

16676
27:36:53.135 --> 27:36:58.796
So that means since it's confirmed back in our front end, we'll give this a little refresh.

16677
27:36:58.796 --> 27:37:03.386
We can see the pup is now worth 25 eath.

16678
27:37:03.386 --> 27:37:04.304
Awesome.

16679
27:37:04.304 --> 27:37:07.381
So we're updating ngModel is working perfectly.

16680
27:37:07.381 --> 27:37:08.145
Excellent job.

16681
27:37:08.145 --> 27:37:09.670
So now let's go to the readme.

16682
27:37:09.670 --> 27:37:13.362
If you own the NFT, you can update the listing.

16683
27:37:13.362 --> 27:37:15.408
That's a checkmark.

16684
27:37:15.408 --> 27:37:16.484
Excellent.

16685
27:37:16.484 --> 27:37:21.459
Next, what do we want it to do? If you don't own it, you can buy the listing.

16686
27:37:21.459 --> 27:37:30.343
Okay, so let's go back to our website, let's switch users to a different account, we're probably going to want an account that own some money.

16687
27:37:30.343 --> 27:37:39.484
So let's go ahead and send this other account some money transfer between my accounts, we'll send 100 eath to account one, confirm on our hard hat chain here.

16688
27:37:39.484 --> 27:37:40.221
Alright, great.

16689
27:37:40.221 --> 27:37:43.760
Now we can go ahead and switch to account one, and we have 100 eath.

16690
27:37:43.760 --> 27:37:44.402
Okay, great.

16691
27:37:44.402 --> 27:37:46.721
As these pops, each cost less than 100 eath.

16692
27:37:46.721 --> 27:37:49.659
So that's gonna be more than plenty for us to test this out.

16693
27:37:49.659 --> 27:37:50.897
Let's go back to this box.

16694
27:37:50.993 --> 27:37:58.680
Because I think somewhere we said, we did a little handle card click, if it's owned by the user, have the modal pop up.

16695
27:37:58.680 --> 27:38:01.659
If not, let's do the by functionality.

16696
27:38:01.659 --> 27:38:07.009
So to do the by functionality, we're gonna go ahead and do another run contract function.

16697
27:38:07.009 --> 27:38:14.605
So we'll do const run contract function, we'll call this one by item.

16698
27:38:14.605 --> 27:38:18.596
And this will equal use web three contract.

16699
27:38:18.596 --> 27:38:23.151
And this is going to be the ABI for the NFT marketplace.

16700
27:38:23.151 --> 27:38:30.450
API, the contract address is going to be the market place address.

16701
27:38:30.450 --> 27:38:41.877
The function name is going to be by item, the message value is going to be the price of the NFT.

16702
27:38:41.994 --> 27:38:44.502
Because we need to send that amount to buy the item.

16703
27:38:44.994 --> 27:38:51.265
params are going to be NFT address, which is going to be the NFT address.

16704
27:38:51.265 --> 27:39:02.089
And the token ID, which is going to be the token ID now that we have this by item on handle card click, we can say okay, said show ngModel is true.

16705
27:39:02.089 --> 27:39:05.119
Otherwise, we're gonna call by item.

16706
27:39:05.119 --> 27:39:07.837
And we're going to do on air.

16707
27:39:07.837 --> 27:39:14.061
Air is going to be a function where we're just going to console dot log the air and onsuccess.

16708
27:39:14.061 --> 27:39:20.522
It'll be a function where we call handle by item success.

16709
27:39:20.522 --> 27:39:29.633
So we'll create a new handler for this right underneath handled cart click the const handled by item success equals a function.

16710
27:39:29.633 --> 27:39:33.739
And for this, we'll also have this do a little notification.

16711
27:39:33.739 --> 27:39:41.354
So once again, we're going to import we're going to import use notification from web through UI kit.

16712
27:39:41.354 --> 27:39:44.354
We're going to say const.

16713
27:39:44.354 --> 27:39:47.851
Dispatch equals use notification.

16714
27:39:47.851 --> 27:39:50.422
And then in handled by item success.

16715
27:39:50.422 --> 27:39:56.377
We're gonna say dispatch type, success.

16716
27:39:56.377 --> 27:39:57.843
Message.

16717
27:39:57.843 --> 27:40:00.043
Item bought.

16718
27:40:00.043 --> 27:40:05.822
Title will also be item bought.

16719
27:40:05.822 --> 27:40:12.304
Then pole position will be top right That's it.

16720
27:40:12.304 --> 27:40:18.042
So handle card click, if they own it, we're going to show that update listing ngModel.

16721
27:40:18.042 --> 27:40:20.595
If they don't already own it, someone's gonna buy it.

16722
27:40:20.595 --> 27:40:21.695
So let's go back here.

16723
27:40:21.695 --> 27:40:24.776
And I'm currently on an account that does not own these NF T's.

16724
27:40:24.776 --> 27:40:26.137
Let's go ahead and click it.

16725
27:40:26.137 --> 27:40:29.351
Our Metamask does indeed show up for 25 eath.

16726
27:40:29.351 --> 27:40:32.047
That's crazy expensive.

16727
27:40:32.047 --> 27:40:40.280
Let's go ahead and confirm item has been bought, we'll go ahead and click that little x, we go to our meta mask, the transaction is pending.

16728
27:40:40.280 --> 27:40:41.851
And it's gone through.

16729
27:40:41.995 --> 27:40:43.167
This is fantastic.

16730
27:40:45.995 --> 27:40:49.732
recently listed NF T's if not, you can update the listing.

16731
27:40:49.995 --> 27:40:51.395
not, you can buy the listing.

16732
27:40:52.995 --> 27:40:53.461
page.

16733
27:40:59.995 --> 27:41:07.677
let's get this cell page, let's get this done pages, we have our cell NFT page, which right now does a whole lot of nothing.

16734
27:41:07.677 --> 27:41:11.927
And on our front end, we go here, there's not a whole lot here.

16735
27:41:11.995 --> 27:41:16.902
And actually, you can list your NFT in the marketplace, we also needed to add withdraw proceeds.

16736
27:41:16.902 --> 27:41:18.194
So I didn't add that.

16737
27:41:18.194 --> 27:41:22.029
But that's probably going to be something we're going to want to allow people to do as well.

16738
27:41:22.029 --> 27:41:23.373
So let's get started here.

16739
27:41:23.373 --> 27:41:27.302
So we can remove this head stuff now that we're adding that in our main page.

16740
27:41:27.302 --> 27:41:36.822
And for us to submit a new NFT, we're probably gonna need a space to add the address of the entity that token ID of the NFT and all this other stuff.

16741
27:41:36.822 --> 27:41:43.392
So we're gonna need a form to do this, which guess what, we can also grab a form from the web through UI kit as well.

16742
27:41:43.392 --> 27:41:52.642
So we're gonna go ahead in our cell NMC page, we're going to import form from web three UI kit.

16743
27:41:52.642 --> 27:41:57.241
And we're going to create a new form in our cell page.

16744
27:41:57.241 --> 27:42:12.962
Now, the parameters we can add to our form, again, you can find them in documentation here, or we're going to add with one of the main pieces is going to be this data piece, which is going to be an object that has a list in it, of all the different fields, we can put in our form.

16745
27:42:12.962 --> 27:42:17.329
So maybe we'll do our first one have a name of NFT address.

16746
27:42:17.329 --> 27:42:28.168
That's gonna be of type text, excuse me, and these are all going to be this is a list of list of objects like that.

16747
27:42:28.168 --> 27:42:35.635
Now, if we save that, we go back to our cell page, we can now see an empty address and a little Submit button.

16748
27:42:35.635 --> 27:42:37.749
That right now does a whole lot of nothing.

16749
27:42:37.749 --> 27:42:48.496
So we have an NFT address, it'll take a text, maybe we'll also do in foot width of 50 percent will have the starting value be blank.

16750
27:42:48.496 --> 27:43:06.307
And the key of this will be NFT address, what else do we need, we're going to need to give it the token ID so we'll say name, token ID, type is going to be a number value, we'll start off it's blank.

16751
27:43:06.307 --> 27:43:11.946
And then the key for this will be token ID.

16752
27:43:11.946 --> 27:43:15.757
Next, we're going to need the price.

16753
27:43:15.757 --> 27:43:18.804
So we'll say name will be price.

16754
27:43:18.996 --> 27:43:19.773
In eath.

16755
27:43:19.773 --> 27:43:24.440
type will be a number value will be blank.

16756
27:43:25.997 --> 27:43:26.797
will be price.

16757
27:43:29.997 --> 27:43:33.679
delete that second one and have it auto close with one tag.

16758
27:43:33.997 --> 27:43:41.617
then in here, we'll do title equals sell your NF T ID equals main form.

16759
27:43:41.617 --> 27:43:42.168
So cool.

16760
27:43:42.168 --> 27:43:48.925
So now we can take an empty address, a token ID and a new price with the title of cellular NFT.

16761
27:43:48.997 --> 27:43:50.447
Great, that looks really nice.

16762
27:43:51.997 --> 27:43:56.130
anything, we probably want to give it the functionality to actually do stuff.

16763
27:43:56.130 --> 27:44:01.770
So we'll say on Submit, and we'll have to create a new function to actually list our NF T's.

16764
27:44:01.770 --> 27:44:10.913
So we're going to create a function called approve and list we have to approve our marketplace to pull the NFT from our wallets.

16765
27:44:10.997 --> 27:44:26.013
So we're going to create a new function, a sync function approven list, which is going to take a data input parameter on our form, when we hit on submit, it's automatically going to pass this data object to our approved list function.

16766
27:44:26.013 --> 27:44:32.292
So that's how we're going to get the value of the address the value of the token ID and the value of the price.

16767
27:44:32.292 --> 27:44:44.234
So in our async function approven list, do console dot log, approving the contract, the NFT address is going to come from this data object.

16768
27:44:44.234 --> 27:44:56.877
So it's going to be data dot data at index zero, or zero with object here is going to be our address that input result.

16769
27:44:56.997 --> 27:45:00.857
Our token ID is going to equal data dot data.

16770
27:45:01.998 --> 27:45:07.901
again, this one is going to be our token ID that input result.

16771
27:45:07.998 --> 27:45:23.498
And then the price is going to equal that ethers dot utils dot parse units of data dot data have to the input result, comma ether.

16772
27:45:23.498 --> 27:45:24.398
to string.

16773
27:45:24.398 --> 27:45:28.398
So we're going to get the price in eath.

16774
27:45:28.398 --> 27:45:33.670
In human readable form, we're going to convert it to Aetherium readable form.

16775
27:45:33.670 --> 27:45:39.722
And then we're going to pass it as a string because this returns a big number, which we don't want.

16776
27:45:39.722 --> 27:45:58.283
So we have the NFT address, the token ID and the price of the new listing, what we can do now is we can say const approve options equals a little function here, the ABI which is going to be our NFT abi, which we need to import, we need to import both ethers from ethers.

16777
27:45:58.283 --> 27:46:32.696
And we also need to import the NFT abi, for its NFT ABI from dot dot constants slash basic at A T dot JSON, I just copied and pasted from the NFT box, the contract address is going to be the NFT address, the function name is going to be approve params are going to be two, the marketplace address, which we're going to define in just a second, and then the token ID will be token ID.

16778
27:46:32.696 --> 27:46:41.424
Now the marketplace address in our NFT box, we're getting this directly from index, an index is getting it from our database.

16779
27:46:41.424 --> 27:46:48.507
Now we want our app to be smart enough to be able to grab the NFT marketplace itself, the marketplace address.

16780
27:46:48.507 --> 27:46:53.249
And if we go to our constants, right now, we actually have it in this network mapping.

16781
27:46:53.249 --> 27:47:09.224
So we're going to want to grab it right up at the top by saying const marketplace address equals network mapping, network mapping of what of the chain ID of the entity marketplace address at the zero with index.

16782
27:47:09.224 --> 27:47:16.951
So network mapping of the chain ID, which we're going to get honest chain ID equals us Morales.

16783
27:47:16.951 --> 27:47:22.919
Now chain Id actually comes like we said it's a wax hex form for Morales.

16784
27:47:22.999 --> 27:47:27.522
So we're gonna have to convert the chain ID to its string readable version.

16785
27:47:27.522 --> 27:47:32.149
So we'll say const, chain string equals chain ID.

16786
27:47:32.149 --> 27:47:40.585
And we'll do a tertiary operator, if the chain ID exists, will parse int of the chain id.

16787
27:47:40.585 --> 27:47:41.671
to string.

16788
27:47:41.671 --> 27:47:46.811
So we'll parse it from its hex to a more readable version, and then do.

16789
27:47:46.811 --> 27:47:47.516
to string.

16790
27:47:47.516 --> 27:47:51.826
And then otherwise, we'll just say we're on 31337.

16791
27:47:51.999 --> 27:47:53.179
So chain ID string.

16792
27:47:55.999 --> 27:48:04.558
string, dot NFT marketplace at index zero, that's going to be our marketplace address.

16793
27:48:04.558 --> 27:48:13.499
So we got the marketplace address, this is all we need to call the approved function on our NFT we can now call running contract function for a proof.

16794
27:48:13.499 --> 27:48:15.753
So we're actually going to do this a little bit differently.

16795
27:48:15.753 --> 27:48:18.676
We're just going to say const.

16796
27:48:18.676 --> 27:48:30.375
Run contract function equals use web three contract, you could import just run contract function, and then pass all those options to it like what we're gonna do here.

16797
27:48:30.375 --> 27:48:33.961
Now we're just gonna say await on contract function.

16798
27:48:34.100 --> 27:48:43.007
Because this is an async function await run contract function, we're gonna say params are going to be approve options.

16799
27:48:43.100 --> 27:48:57.149
And we're gonna say onsuccess, we're going to do something, I'm going to say on error, we're also going to just do error, little arrow function, console dot log error.

16800
27:48:57.149 --> 27:49:09.600
Now on success, once we send this transaction, after the Approve goes through, we're going to want to call the list function right underneath this will call async async.

16801
27:49:09.600 --> 27:49:13.673
Function, handle approve success.

16802
27:49:13.673 --> 27:49:20.879
And this is going to take the NFT address, the token ID, and the price is it put in parameters.

16803
27:49:20.879 --> 27:49:27.310
So once this run contract function goes through, we're going to call of handle proof success.

16804
27:49:27.310 --> 27:49:35.990
And we'll pass it the end of the address, token ID and the price, which will say console dot log.

16805
27:49:36.100 --> 27:49:39.433
Okay, now time to list and we'll do the same thing.

16806
27:49:40.100 --> 27:49:50.731
const list options, equals and this is going to be all the options for calling the list function API is going to be on the marketplace this time.

16807
27:49:50.731 --> 27:49:56.766
So NFT market place abi, which again, we're going to have to import so I'm going to go back to NFT box.

16808
27:49:56.766 --> 27:50:00.290
We're gonna copy that line here, paste it in the top.

16809
27:50:00.290 --> 27:50:03.655
That's going to be the API for that contract address.

16810
27:50:03.655 --> 27:50:09.015
It's going to be the marketplace address, which we already have.

16811
27:50:09.100 --> 27:50:12.375
function name is going to be list item.

16812
27:50:14.100 --> 27:50:23.900
going to be NF T address of the NFT address, token ID of token ID, price of price.

16813
27:50:23.900 --> 27:50:32.927
And now we have those options, we can do await, run contract function with params.

16814
27:50:32.927 --> 27:50:45.405
Of list options, will say onsuccess arrow function, handle list success, which is a function we haven't made yet.

16815
27:50:45.405 --> 27:50:47.714
It will say on air error.

16816
27:50:47.714 --> 27:50:52.749
And we'll just say console dot log error.

16817
27:50:52.749 --> 27:51:03.018
Okay, so let's make this handle list success handle one spell handle correctly handle the success, this will be an async function.

16818
27:51:03.100 --> 27:51:06.037
And this is also going to call dispatch and make a little notification.

16819
27:51:06.037 --> 27:51:11.911
So we're going to grab that from web three UI kit, use notification.

16820
27:51:11.911 --> 27:51:17.261
We'll say const dispatch equals use notification.

16821
27:51:17.261 --> 27:51:24.688
And now down in handle the success say dispatch, type success.

16822
27:51:24.688 --> 27:51:33.838
Message NFT listing, title NFT listed position.

16823
27:51:33.838 --> 27:51:35.499
top bar, and cool.

16824
27:51:35.499 --> 27:51:42.035
And we're also gonna have to grab us Morales from react Morales.

16825
27:51:42.035 --> 27:51:46.673
So do import us Morales from react or else.

16826
27:51:46.673 --> 27:51:49.705
So let's import this network mapping.

16827
27:51:49.705 --> 27:51:57.521
Import network mapping from dot dot slash constants slash network mapping dot JSON.

16828
27:51:57.521 --> 27:52:03.981
Because I spelled contract address wrong again, good our front end we'll give it a refresh us web three contract isn't defined.

16829
27:52:03.981 --> 27:52:06.286
Let's get that from react moralss.

16830
27:52:06.286 --> 27:52:08.833
Well save that refresh our front end.

16831
27:52:08.833 --> 27:52:10.966
And tada, we're good to go here.

16832
27:52:11.100 --> 27:52:15.761
Alright, now to test this out, we're going to want to do is we're going to want to create another script here.

16833
27:52:15.761 --> 27:52:19.640
So we're back in our heart at NFT marketplace, we're looking at our scripts.

16834
27:52:19.640 --> 27:52:22.417
And we're going to create a new file just called mint.

16835
27:52:22.417 --> 27:52:22.575
js.

16836
27:52:22.575 --> 27:52:31.521
So we're not going to list this time, we're just going to mint it just going to mint an NF t so we can list it ourselves on the UI.

16837
27:52:31.521 --> 27:52:40.067
And actually, we can just copy our mminton list code, paste it into here, and just remove the approval and the listing code.

16838
27:52:40.067 --> 27:52:43.615
Boom, remove that, remove this, remove this.

16839
27:52:43.615 --> 27:52:45.047
And that's all we need.

16840
27:52:45.047 --> 27:52:47.293
And now we'll just change the name to mint.

16841
27:52:47.293 --> 27:52:48.938
Well, we can remove price as well.

16842
27:52:48.938 --> 27:52:50.664
And we'll change this to mint.

16843
27:52:50.664 --> 27:52:51.793
And that's it.

16844
27:52:51.793 --> 27:52:58.623
Now we have a script that we can call, well, we'll just mint an NFT, we can also get rid of the NFT marketplace.

16845
27:52:58.623 --> 27:53:02.881
Actually, we will probably want the token ID so we can know what it is.

16846
27:53:02.881 --> 27:53:06.068
So let's do const token ID equals.

16847
27:53:06.068 --> 27:53:13.350
So let's actually get the receipt we'll do const mint TX receipt, but the receipt, I can there equals that.

16848
27:53:13.350 --> 27:53:17.528
And then I'm just going to copy this from the mminton receipt.

16849
27:53:17.528 --> 27:53:22.211
Cons token ID equals this, paste it into our mint.

16850
27:53:22.211 --> 27:53:25.433
js and then a console dot log.

16851
27:53:25.433 --> 27:53:36.487
Got token ID, string interpolates token ID, hard hat, run scripts, mins dot j s dash dash network, local host.

16852
27:53:36.487 --> 27:53:39.623
And we're going to mint an NF T.

16853
27:53:39.623 --> 27:53:47.134
Got token ID six means we know m token ID six, we can list this entity.

16854
27:53:47.134 --> 27:53:48.530
Let's also add the address.

16855
27:53:48.530 --> 27:53:51.287
Let's do console dot log NFTL.

16856
27:53:51.287 --> 27:53:58.957
And if the address is going to be we'll do string interpolation.

16857
27:53:59.100 --> 27:54:01.811
And you know what? Let's make this again.

16858
27:54:03.100 --> 27:54:03.353
cool.

16859
27:54:07.100 --> 27:54:09.528
do now we'll grab this NFT address.

16860
27:54:11.100 --> 27:54:21.100
let's go to Account three because that's the account that I've done my imports on now when you switch accounts, we're going to want to refresh the page as the address seven 0.

16861
27:54:21.100 --> 27:54:21.200
6.

16862
27:54:21.200 --> 27:54:23.307
Submit Metamask pops up.

16863
27:54:23.307 --> 27:54:24.816
Give permission Yes.

16864
27:54:24.816 --> 27:54:29.245
Okay, now it's time to list you now have one pen, okay.

16865
27:54:29.245 --> 27:54:30.938
Local host list item.

16866
27:54:31.100 --> 27:54:32.366
We can see all the data and everything.

16867
27:54:33.100 --> 27:54:35.994
and confirm NFT listed Okay, okay.

16868
27:54:35.994 --> 27:54:36.432
Okay.

16869
27:54:36.432 --> 27:54:36.870
Okay.

16870
27:54:38.100 --> 27:54:38.310
good.

16871
27:54:41.100 --> 27:54:41.438
node.

16872
27:54:46.100 --> 27:54:49.433
mine dot j s dash dash network, local host.

16873
27:54:51.100 --> 27:54:52.166
those two blocks.

16874
27:54:55.100 --> 27:54:57.836
give this a little refresh.

16875
27:54:57.836 --> 27:54:59.730
Go to active item.

16876
27:55:01.100 --> 27:55:03.132
there's a new item listed for 0.

16877
27:55:03.132 --> 27:55:03.525
6 eath.

16878
27:55:03.525 --> 27:55:04.574
In our database.

16879
27:55:05.100 --> 27:55:05.927
is fantastic.

16880
27:55:09.100 --> 27:55:12.033
now let's make And let's move on to one more.

16881
27:55:13.100 --> 27:55:14.854
second one, just to see that it's actually working.

16882
27:55:15.100 --> 27:55:16.306
token ID eight.

16883
27:55:16.306 --> 27:55:18.374
Let's grab this address.

16884
27:55:20.100 --> 27:55:20.800
refresh.

16885
27:55:20.800 --> 27:55:23.700
paste this in token ID eight.

16886
27:55:23.700 --> 27:55:24.800
We'll do 0.

16887
27:55:24.800 --> 27:55:25.100
999.

16888
27:55:26.100 --> 27:55:26.861
submit.

16889
27:55:26.861 --> 27:55:29.273
we'll approve this.

16890
27:55:29.273 --> 27:55:29.780
Yes.

16891
27:55:29.780 --> 27:55:32.192
Then we'll send it.

16892
27:55:32.192 --> 27:55:32.699
Yes.

16893
27:55:34.100 --> 27:55:35.287
now let's go ahead and mine two blocks.

16894
27:55:36.100 --> 27:55:40.553
up and go back to mine will run the mining, moving blocks.

16895
27:55:41.100 --> 27:55:41.568
great.

16896
27:55:47.100 --> 27:55:53.990
now listed, we have the original one, that we have those two that we just listed eight, and seven for 0.

16897
27:55:53.990 --> 27:55:54.536
6 and 0.

16898
27:55:54.536 --> 27:55:54.770
999.

16899
27:55:54.770 --> 27:55:57.100
Listed on our NFT marketplace.

16900
27:55:57.100 --> 27:55:58.433
This is so exciting.

16901
27:55:58.433 --> 27:56:00.792
Our listing is working correctly, okay.

16902
27:56:00.792 --> 27:56:09.680
Now, due to the fact that this lesson is already incredibly long, actually decided to cut the part of that and then withdraw a bit, because we don't really learn anything new there.

16903
27:56:09.680 --> 27:56:19.313
However, feel free to jump back in to get every bit associated with scores, where we will have that withdrawal functionality for you if you want to implement it.

16904
27:56:19.313 --> 27:56:21.372
Otherwise, feel free to skip and move on ahead.

16905
27:56:21.372 --> 27:56:22.561
This is incredibly powerful.

16906
27:56:22.561 --> 27:56:25.734
And you should be incredibly excited about yourself.

16907
27:56:25.734 --> 27:56:27.876
If you've made it this far.

16908
27:56:27.876 --> 27:56:29.145
This is awesome.

16909
27:56:29.145 --> 27:56:37.034
You just made a decentralized marketplace and then built a front end on top of it to allow anybody to interact with your marketplace.

16910
27:56:37.100 --> 27:56:37.700
Easily.

16911
27:56:37.700 --> 27:56:38.800
Huge, huge.

16912
27:56:38.800 --> 27:56:40.900
Congratulations here.

16913
27:56:42.100 --> 27:56:44.480
is a perfect time to go take a break and celebrate.

16914
27:56:45.100 --> 27:56:51.048
a great time to ping me on Twitter to ping me on Twitter saying hey, Patrick, I just completed the NFT marketplace.

16915
27:56:51.100 --> 27:57:00.084
Full Stack front end part of your Free Code Camp course, I now know how to build full stack front end on top of my smart contract applications.

16916
27:57:00.084 --> 27:57:03.300
And be so so pumped with yourself because this is so awesome.

16917
27:57:03.300 --> 27:57:14.693
I can't understate how excited I am that you've made it this far, you are learning and working with a ton of technologies, solidity smart contracts, and front end you are doing full stack you were doing a lot of stuff here.

16918
27:57:14.693 --> 27:57:16.889
So you should be really proud of yourself.

16919
27:57:16.889 --> 27:57:21.755
huge congratulations, be sure to absolutely give yourself a pat on the back.

16920
27:57:21.755 --> 27:57:26.993
And then get ready to continue to our next section.

16921
27:57:27.100 --> 27:57:35.755
Now that we've done all of this using our Morales back end, I'm about to switch it up on you, instead of indexing all of our events with a centralized server.

16922
27:57:35.755 --> 27:57:47.700
Now we're going to learn how to build this using the graph, which is a decentralized event indexer that we can use, a lot of the code is going to be exactly the same.

16923
27:57:47.700 --> 27:58:02.274
So instead of us starting from a new, what we're going to do, first of all we can we can close all our local stuff, we can close all of these things, we can close all of our terminals finally, which is really exciting.

16924
27:58:02.274 --> 27:58:08.944
And in this folder, what we're going to do is we're actually just going to copy everything into a new folder.

16925
27:58:08.944 --> 27:58:14.782
So I'm going to CD down a directory, we're going to make a new one called next Jas.

16926
27:58:14.782 --> 27:58:30.561
And if T marketplace, the graph, dash FCC, and all the code for this section is going to be here for front end the graph indexer we're gonna have to make another repo and we'll get to that in a little bit.

16927
27:58:30.561 --> 27:58:33.290
For all the changes, it's going to be in this section here.

16928
27:58:33.290 --> 27:58:40.269
So what we're going to do is we're going to make this new folder, and we're going to do copy dash R.

16929
27:58:40.269 --> 27:58:46.890
Next, Jas and ft marketplace FCC into next Jas NFT.

16930
27:58:46.890 --> 27:58:50.809
Marketplace, the graph FCC.

16931
27:58:51.100 --> 27:58:59.286
So we're going to copy recursively, everything that's inside that folder we just created into this new one that we're going to make a lot of adjustments to.

16932
27:58:59.286 --> 27:59:04.800
And this might take a little bit of time to run because we've got a lot of stuff in this folder.

16933
27:59:04.800 --> 27:59:16.625
And Alright, once we've done that, we can cd into this next Jas and ft marketplace, the graph FCC and do code period and open this up in a new code editor.

16934
27:59:16.625 --> 27:59:20.772
Or as always, you can do File Open folder to open it like that.

16935
27:59:20.772 --> 27:59:26.657
Now that we're in here, we're going to learn how to do this exact same project, instead of using mirallas.

16936
27:59:26.657 --> 27:59:32.410
But using the graph, one of the things that we're first going to do is we're actually going to deploy our contracts to rink B.

16937
27:59:32.410 --> 27:59:40.690
So we're going to grab our marketplace, that soul, pull this over, we're going to grab our hard hat marketplace dot soul project, pull it over.

16938
27:59:40.690 --> 27:59:43.521
And first, we're going to run our deploy script on rink v.

16939
27:59:43.521 --> 27:59:50.477
So hopefully, you've got all your deploy stuff set up correctly, so that all the arguments can go through correctly for rink v as well.

16940
27:59:50.477 --> 27:59:57.300
So we're gonna go ahead and run this yarn, hard hat deploy dash dash network Rinkeby.

16941
27:59:57.300 --> 28:00:00.427
And to make sure that it's going to work for Rinkeby.

16942
28:00:00.427 --> 28:00:02.366
Let's check our hard hat config.

16943
28:00:02.366 --> 28:00:06.845
Okay for networks, looks like I have my Rigby stuff in here for networks.

16944
28:00:06.845 --> 28:00:10.576
Okay, I've got my RPC URL, which I'm getting from my environment variables.

16945
28:00:10.576 --> 28:00:17.913
If I have a private key, I have a private key, which I'm also getting from environment variables, I have a chain ID block confirmations and save deployments.

16946
28:00:17.913 --> 28:00:19.489
So let's go ahead and run this.

16947
28:00:19.489 --> 28:00:24.336
Now we're going to go ahead and be deploying the NFT marketplace to the Rigby network.

16948
28:00:24.336 --> 28:00:27.964
And our deploy script also has an ID some verification.

16949
28:00:27.964 --> 28:00:34.427
So we can verify this as well, you can't really follow along with this section without deploying a marketplace to rink be here.

16950
28:00:34.427 --> 28:00:40.358
So deploy to rank B, or whatever test net is recommended in this lesson 15 section, and go from there.

16951
28:00:40.358 --> 28:00:42.995
Alright, great, we've deployed our NFC marketplace.

16952
28:00:43.100 --> 28:00:45.591
Now we're gonna go ahead and deploy our basic NFT.

16953
28:00:46.100 --> 28:00:50.450
these are done deploying, we can start updating our front end code to work with the graph instead of mirallas.

16954
28:00:50.450 --> 28:00:53.100
Okay, we've verified everything to which looks great.

16955
28:00:53.100 --> 28:00:55.411
Now we're going to verify our basic NFT.

16956
28:00:55.411 --> 28:00:57.181
And we've have it verified.

16957
28:00:57.181 --> 28:00:57.705
Awesome.

16958
28:00:57.705 --> 28:01:03.453
So now we have an NFT marketplace deployed to ring P, and a basic NFT deployed to rink B.

16959
28:01:03.453 --> 28:01:05.299
And both of them are verified.

16960
28:01:05.299 --> 28:01:11.854
So be sure to take note of those, because we're going to need them when we're moving over to our the graph section.

16961
28:01:11.854 --> 28:01:17.035
So now let's grab our code editor titled next Jas and ft marketplace, the graph.

16962
28:01:17.100 --> 28:01:18.410
And let's get going.

16963
28:01:21.100 --> 28:01:24.683
But we forgot to add some code in here to update our network mapping.

16964
28:01:24.683 --> 28:01:50.043
However, if we go back and we open back up code dot dot, next Jas NFT marketplace, FCC, in the network mapping in here will now have a new entry for rink B, if we did it correctly, let's copy this network mapping and paste it over in our network, our next GS and ft marketplace, the graph section, or you can just manually add your new entry.

16965
28:01:50.100 --> 28:01:50.412
Right.

16966
28:01:53.100 --> 28:01:53.640
marketplace.

16967
28:01:56.100 --> 28:01:59.709
you just deployed, is we're going to delete this Cloud Functions bit.

16968
28:01:59.709 --> 28:02:06.155
Goodbye, because since we're not working with the server anymore, there's not gonna be any cloud functions or any back end to run.

16969
28:02:06.155 --> 28:02:08.423
So we're gonna move that to trash goodbye.

16970
28:02:08.423 --> 28:02:15.666
Next, we don't need FRP anymore, because we're not going to be connecting our local blockchain to the graph, we're only going to be working with the test net here.

16971
28:02:15.666 --> 28:02:17.821
So let's go ahead and delete that.

16972
28:02:17.821 --> 28:02:22.253
Goodbye, what's next in our pages, and our app dot j s.

16973
28:02:22.253 --> 28:02:39.548
Right now we're connecting to a Morales provider like this, we're going to switch this back to initiate allies on Mount, this is going to go back to being false, we're no longer going to connect to our Morales database like this, we're just going to use the hooks again.

16974
28:02:39.548 --> 28:02:42.942
Now with that the only thing that's going to change is our index.

16975
28:02:42.942 --> 28:02:43.047
js.

16976
28:02:43.047 --> 28:02:44.638
Right now, in our index.

16977
28:02:44.638 --> 28:02:50.884
js, we're getting our list of NF TS from our Morales query.

16978
28:02:51.100 --> 28:02:53.893
So we're going to change this, let's update our readme.

16979
28:02:54.100 --> 28:03:01.782
we're gonna say instead of reading the events from ralis, we will first off we're going to index them with the graph.

16980
28:03:01.782 --> 28:03:04.050
And then we're going to read from the graph.

16981
28:03:04.050 --> 28:03:08.877
So the question is, what is the graph.

16982
28:03:09.100 --> 28:03:13.600
So the graph is going to be a decentralized layer for storing event data.

16983
28:03:13.600 --> 28:03:17.338
So there are all these blockchains and all these different storage networks.

16984
28:03:17.338 --> 28:03:27.242
And the graph is and the graph is a network of different nodes that read from blockchains and index this data, and it exposes an API for us to call we can read that data.

16985
28:03:27.242 --> 28:03:28.099
Rather than just myself.

16986
28:03:28.099 --> 28:03:32.053
We actually have nattered Abbott, who can explain it a lot better than I can take it away.

16987
28:03:32.100 --> 28:03:32.957
And at.

16988
28:03:33.100 --> 28:03:39.046
First, I'd like to thank Patrick for creating such a wonderful educational resource and inviting me to be a part of it.

16989
28:03:39.100 --> 28:03:40.237
My name is Nadia dabit.

16990
28:03:42.100 --> 28:03:42.946
working with the graph.

16991
28:03:44.100 --> 28:03:52.510
querying protocol for decentralized networks like Aetherium IPFS, dozens of other EVM compatible networks, as well as near and then the future cosmos and Solana.

16992
28:03:52.510 --> 28:04:06.962
Using the graph developers can build and publish open API's called subgraphs that they can then use in their applications to enable better querying capabilities of data stored on these networks, including features like filtering, sorting, relational data, and full stack search.

16993
28:04:06.962 --> 28:04:28.503
subgraphs live in between the blockchain and the UI providing an important piece of software infrastructure, a flexible performant and decentralized API layer, and the traditional tech stack databases, servers and API's query filter, sort paginate group and join data before it's returned to an application, usually via some type of HTTP request.

16994
28:04:28.503 --> 28:04:34.950
These types of data transformations are not possible when reading data directly from Aetherium or other blockchains.

16995
28:04:34.950 --> 28:04:39.217
Before the graph teams had to develop and operate proprietary indexing servers.

16996
28:04:39.217 --> 28:04:51.363
This required significant engineering and hardware resources and broke the important security principles required for decentralization, how we interact with and build on top of blockchains it's much different than what we are used to in the traditional tech stack.

16997
28:04:51.363 --> 28:04:59.890
In a blockchain data isn't stored in a format that can be easily or efficiently consumed, or retrieved directly from other applications or front ends.

16998
28:04:59.890 --> 28:05:03.663
The problem is that you need to have the data indexed and organized for efficient retrieval.

16999
28:05:03.663 --> 28:05:09.053
Traditionally, that's the work that databases and web servers do in this centralized tech stack.

17000
28:05:09.053 --> 28:05:12.134
But that in indexing layer was missing in the web three stack.

17001
28:05:12.134 --> 28:05:16.051
Let's take a look at a couple of other examples of indexing in the real world.

17002
28:05:16.101 --> 28:05:23.464
Search engines like Google crawl the internet indexing relevant data making it available for users to search via their web interface and other API's.

17003
28:05:23.464 --> 28:05:29.493
Without this indexing layer, it'd be hard for us to know where and how to find relevant information across the web.

17004
28:05:29.493 --> 28:05:31.601
Another similar analogy is a library.

17005
28:05:31.601 --> 28:05:42.016
Using an indexing system like the Dewey Decimal System, we know where to find the book that we're looking for without having to go through book by book looking throughout the entire library.

17006
28:05:42.016 --> 28:05:49.522
The graph serves over 2 billion queries per day to many different types of web three applications, including apps in the defy gaming and FC space.

17007
28:05:49.522 --> 28:05:53.331
Before we dig into any code, let's take a look at how to build a sub graph.

17008
28:05:53.331 --> 28:05:55.269
To get started, you would go to the graph.

17009
28:05:55.269 --> 28:05:58.810
com and create a new sub graph and the graph user interface.

17010
28:05:58.810 --> 28:06:06.825
You would then use the graph CLI to scaffold out an empty sub graph boilerplate that you can then update with your own contract information.

17011
28:06:06.825 --> 28:06:15.726
In your subgraph configuration, you would define things like your data model, the network, the contract addresses and other configurations that are specific to the data that you would like to index.

17012
28:06:15.726 --> 28:06:23.624
For our data model, we use Graph QL, schema definition language defining top level types as well as fields within those types.

17013
28:06:23.624 --> 28:06:32.360
When we're ready to deploy our subgraph, so we can begin testing it out and using it in our application, we can use the graph CLI running the deploy command.

17014
28:06:32.360 --> 28:06:40.592
Once the subgraph is deployed and the data begins to be indexed, we can start testing it out using the graphical interface directly in the graph dashboard.

17015
28:06:40.592 --> 28:06:48.726
When we're ready to start queering, our sub graph from our application, we can use the API URL that's been given to us by the graph along with any Graph QL query.

17016
28:06:48.726 --> 28:06:53.691
If you'd like to learn more about the graph, check out the graph.

17017
28:06:53.691 --> 28:06:57.863
com as well as Graph Protocol, Twitter, the docs at the graph.

17018
28:06:57.863 --> 28:07:00.998
com/docs, or our Discord at the graph.

17019
28:07:00.998 --> 28:07:02.527
com/discord Thanks matter.

17020
28:07:02.527 --> 28:07:07.851
And now that we have a better idea of what the graph is, we can actually start building with it.

17021
28:07:07.851 --> 28:07:14.132
Now if we were to try to run this app as it is, it obviously would fail, right, because index.

17022
28:07:14.132 --> 28:07:18.757
js, right now is reading from mirallas instead of from the graph.

17023
28:07:18.757 --> 28:07:28.038
So like it says in our readme, first thing we're going to need to do is we're gonna need to index from the graph, and then we can just this project to read from the graph.

17024
28:07:28.101 --> 28:07:30.632
So let's go ahead and learn how to build our sub graph.

17025
28:07:31.101 --> 28:07:37.810
for us to tell the graph network to start indexing the events from our contract, we're gonna go to graph.

17026
28:07:37.810 --> 28:07:39.810
com, we're gonna go to products.

17027
28:07:39.810 --> 28:07:47.951
And we're going to go to sub graph studio, if you go to products, the first thing you see is the Graph Explorer, these are already existing sub graphs.

17028
28:07:47.951 --> 28:07:56.258
And if you go through here, you'll see a lot of incredibly popular decentralized protocols all have different sub graphs, hosted service is going to get discontinued at some point.

17029
28:07:56.258 --> 28:07:57.346
So we're going to skip there.

17030
28:07:57.346 --> 28:08:04.051
So let's go to sub graph studio, this is going to help enable us to create a sub graph for other nodes to start indexing our events.

17031
28:08:04.051 --> 28:08:07.549
So we're gonna go ahead and connect our wallet with meta mask.

17032
28:08:07.549 --> 28:08:15.914
And I'm going to choose account one here, next connect, and we're going to want to switch off of Hardhead.

17033
28:08:15.914 --> 28:08:19.981
Local, over to the Rinkeby test network.

17034
28:08:19.981 --> 28:08:21.859
And I'll go to Account one here.

17035
28:08:21.859 --> 28:08:27.413
And we're going to get a signature request from the graph summary to the website that we just built.

17036
28:08:27.413 --> 28:08:32.469
The subgraph website has some signings functionality with a database on the back end.

17037
28:08:32.469 --> 28:08:36.377
So we're seeing in real life, exactly the methods that we just used.

17038
28:08:36.377 --> 28:08:40.901
So instead of signing with Morales, they're just have their own custom sign in here.

17039
28:08:40.901 --> 28:08:45.050
So we're gonna go ahead and sign in so that the graph website knows that it can interact with us.

17040
28:08:45.050 --> 28:08:47.412
And we can go ahead and enter our email if we want.

17041
28:08:47.412 --> 28:08:49.248
I'm gonna go ahead and skip.

17042
28:08:49.248 --> 28:08:57.101
And you'll even get a little notification here saying only subgraphs indexing Aetherium or main net or Rigby can be created in subgraph studio.

17043
28:08:57.101 --> 28:08:59.767
So let's go ahead and create a subgraph.

17044
28:08:59.767 --> 28:09:05.871
So we're going to pick a cerium Rigby and the subgraph name is going to be NFT marketplace.

17045
28:09:05.871 --> 28:09:07.969
We'll go ahead and hit Continue.

17046
28:09:08.101 --> 28:09:11.378
Now, this is going to be our dashboard for creating our sub graph.

17047
28:09:11.378 --> 28:09:20.488
And there's a ton of instructions over here and documentation that we can view to get started, I'm going to add this documentation to the GitHub repo associated with this course.

17048
28:09:20.488 --> 28:09:25.351
So this NFT marketplace sub graph is going to need its own git repository itself.

17049
28:09:25.351 --> 28:09:34.157
So what we're going to do back in here is we're going to CD down, we're going to make a new directory, and we're going to call it graph.

17050
28:09:34.157 --> 28:09:39.375
And if T marketplace, FCC, we're going to open that up as well.

17051
28:09:39.375 --> 28:09:50.033
So code graph NFT, marketplace, FCC, or file open graft code marketplace FCC, and in this window, we're going to build our subgraph.

17052
28:09:50.101 --> 28:09:54.083
Locally, we're going to build our subgraph and push it up to the subgraph studio.

17053
28:09:54.083 --> 28:09:59.429
And in here, there's a whole bunch of instructions that we can follow along with to go ahead and install.

17054
28:09:59.429 --> 28:10:03.543
The first thing that we need to do is install the graph command line interface.

17055
28:10:03.543 --> 28:10:05.969
And we want to install this globally.

17056
28:10:06.101 --> 28:10:08.396
So I'm going to copy this part here.

17057
28:10:10.101 --> 28:10:13.133
Oh, yarn, global ad and paste that in.

17058
28:10:15.101 --> 28:10:21.574
that's going to help us build a graph and build instructions for the graph to actually start indexing our events.

17059
28:10:21.574 --> 28:10:26.037
Now that we've installed the globally, we can initialize our graph code.

17060
28:10:26.101 --> 28:10:28.036
So we can copy this line.

17061
28:10:31.101 --> 28:10:33.423
studio NFT marketplace and hit enter.

17062
28:10:35.101 --> 28:10:37.184
be Aetherium, or subgraph.

17063
28:10:37.184 --> 28:10:38.600
Slug will be NFT.

17064
28:10:38.600 --> 28:10:39.600
marketplace.

17065
28:10:40.101 --> 28:10:43.825
want the directory to be here, but it's saying directory already exists.

17066
28:10:43.825 --> 28:10:45.790
So we'll just give it NFT marketplace.

17067
28:10:45.790 --> 28:10:47.481
And then we'll move it after this.

17068
28:10:47.481 --> 28:10:48.766
And this is on the Rinkeby.

17069
28:10:48.766 --> 28:10:49.288
Test net.

17070
28:10:49.288 --> 28:10:52.288
And now we want to give it the contract address.

17071
28:10:52.288 --> 28:10:55.201
So we want to grab that address that we just deployed.

17072
28:10:55.201 --> 28:10:57.519
And it should be now in our network mapping.

17073
28:10:57.519 --> 28:11:04.019
So we're going to grab that contract address that we just deployed, and paste it in here.

17074
28:11:04.101 --> 28:11:04.694
Like so.

17075
28:11:09.101 --> 28:11:15.434
automatically grabs the ABI for us from ether scan, we'll give it the contract name, which is the NFT marketplace.

17076
28:11:15.434 --> 28:11:21.101
And it's going to give us a whole bunch of boilerplate code in this NFT marketplace directory.

17077
28:11:21.101 --> 28:11:23.005
And this might take a couple of minutes.

17078
28:11:23.101 --> 28:11:23.901
Alright, awesome.

17079
28:11:26.101 --> 28:11:28.767
marketplace created in NFT marketplace.

17080
28:11:30.101 --> 28:11:31.051
it to be in the seller folder.

17081
28:11:32.101 --> 28:11:42.473
going to move it down a directory, but you can leave it where it is, if you want, I'm going to say move, I'm going to say move NFT marketplace, star to dot slash.

17082
28:11:42.473 --> 28:11:47.051
Now everything inside of NFT marketplace will be in this current directory.

17083
28:11:47.101 --> 28:11:49.151
And then if the marketplace will be empty.

17084
28:11:50.101 --> 28:11:51.372
gonna go ahead and delete.

17085
28:11:51.372 --> 28:11:52.541
And if the marketplace.

17086
28:11:53.101 --> 28:11:53.445
great.

17087
28:11:57.101 --> 28:11:59.687
here and what these files are that we just created.

17088
28:12:00.101 --> 28:12:01.751
first folder is going to be API's.

17089
28:12:03.101 --> 28:12:08.197
index and read our contract index our events, it's going to need the ABI of our events.

17090
28:12:08.197 --> 28:12:19.577
So we've got the ABI of our entire marketplace, from ether scan, if we didn't verify an ether scan, we can just create this API folder ourself and add the NFT marketplace JSON in here.

17091
28:12:19.577 --> 28:12:21.669
Now we have this generated folder.

17092
28:12:21.669 --> 28:12:23.394
This is an auto generated file.

17093
28:12:23.394 --> 28:12:26.609
He even says at the top, do not edit this file directly.

17094
28:12:26.609 --> 28:12:32.621
You can kind of think of this as the build folder, or where we compile graph code.

17095
28:12:32.621 --> 28:12:36.038
Node modules, of course, is going to be node modules and dependencies.

17096
28:12:36.038 --> 28:12:43.593
SRC is going to be where we define and we tell the graph, how to actually map and how to actually work with our contract.

17097
28:12:43.593 --> 28:12:45.316
And it is a TypeScript file.

17098
28:12:45.316 --> 28:12:53.051
So for all of you who have been just doing this in JavaScript, I will have to teach you a little bit of TypeScript just to get through this part.

17099
28:12:53.101 --> 28:13:06.005
Then we have networks dot JSON, which gives us all of our network information about which networks, what are the addresses, and what are the different contracts that we're going to be indexing, package dot JSON, which of course is just a normal package dot JSON.

17100
28:13:06.005 --> 28:13:10.458
And it's got some graph scripts already built in schema dot graph.

17101
28:13:10.458 --> 28:13:13.101
QL is going to be our Graph QL schema.

17102
28:13:13.101 --> 28:13:19.054
So this is also going to be how we tell the graph how to actually work with our events and index our events.

17103
28:13:19.101 --> 28:13:22.501
And if you're familiar, the schema follows the Graph QL syntax.

17104
28:13:22.501 --> 28:13:28.527
So if you've ever worked with Graph QL, before, it's going to be the exact same way, graph.

17105
28:13:28.527 --> 28:13:30.755
QL is a query language for your API.

17106
28:13:30.755 --> 28:13:39.726
And instead of being kind of a relational database, it can query in a more graph type way, I'm not going to go too deep into how it actually works behind the scenes.

17107
28:13:39.726 --> 28:13:48.545
But if you want to learn more, I'm going to leave some docs in the GitHub repository associated with this course, the sub graph dot Yamo tells our subgraph how to combine all the files together.

17108
28:13:48.545 --> 28:14:00.196
So we have data sources, data sources, where they're coming from different addresses, different entities or events, the API's where to grab our files from different event handlers, which we'll talk about in a minute.

17109
28:14:00.196 --> 28:14:02.910
And then the main file, which is going to be our mapping.

17110
28:14:02.910 --> 28:14:07.455
ts, we have a TS config, which is a configuration file specific to TypeScript.

17111
28:14:07.455 --> 28:14:09.815
And then of course, we have our yarn dot lock.

17112
28:14:09.815 --> 28:14:18.513
With all this information with all this code, we are now going to update all this code to tell the graph to start indexing our events.

17113
28:14:18.513 --> 28:14:24.721
So we can read our events from the graph in a decentralized context, as opposed to from a centralized database.

17114
28:14:24.721 --> 28:14:34.646
And after we build everything, we're going to run through this off and deploy code, which is to authenticate ourselves, and then deploy our code to the graph to start indexing.

17115
28:14:34.646 --> 28:14:37.208
So without further ado, let's jump in.

17116
28:14:37.208 --> 28:14:38.315
And let's do this.

17117
28:14:38.315 --> 28:14:43.837
So one of the first things I'm going to do, I'm going to add a highlighter for these dot Graph QL files.

17118
28:14:43.837 --> 28:14:46.767
So in our extensions, we're gonna look at Graph QL.

17119
28:14:46.767 --> 28:14:50.600
And we're gonna stall this Graph QL extension.

17120
28:14:50.600 --> 28:14:56.658
Now that we've installed it, if we go back to schema dot graph, QL, we've got it with some colors now, which is exciting.

17121
28:14:56.658 --> 28:15:05.391
So this schema dot Graph QL is going to define what entities we have in our contract if we were to be analogous to mirallas.

17122
28:15:05.391 --> 28:15:08.529
These are going to be how we're going to define what our tables are going to look like.

17123
28:15:08.529 --> 28:15:09.850
And these are going to be our events.

17124
28:15:09.850 --> 28:15:12.592
plus that active item table that we created.

17125
28:15:12.592 --> 28:15:18.834
So we're not going to have an example entity though, we're going to have a type active item.

17126
28:15:18.834 --> 28:15:21.367
And this is going to be an add entity.

17127
28:15:21.367 --> 28:15:31.273
So these are the different types we have in our graph that we can actually query on, our main thing that we're going to want to query on is same as before, it's going to be our active items.

17128
28:15:31.273 --> 28:15:41.434
And then inside of our active items, we're going to tell the graph, what parameters each one of these active item types has, well, it's going to have an ID of type ID.

17129
28:15:41.434 --> 28:15:43.394
So the variable is ID of type ID.

17130
28:15:43.394 --> 28:15:47.524
And you can read more about the different types in the graph documentation.

17131
28:15:47.524 --> 28:15:51.354
And this exclamation mark means it must have an ID.

17132
28:15:51.354 --> 28:16:08.790
So every active item needs to have and will have an ID, we'll say there's going to be a buyer, which is going to be an address, so that's going to be a byte and the buyer could be blank, right? It could be the 0x 000, we're going to have all of our active items have a 0000 dot.

17133
28:16:08.790 --> 28:16:08.962
if.

17134
28:16:08.962 --> 28:16:19.445
If no one has bought yet, we're going to have a seller, which of course is also going to be a bytes because it's going to be an address, we're going to have an NFT address.

17135
28:16:19.445 --> 28:16:31.367
So the address of the NFT, which will also be bytes, we're going to have a token ID which isn't going to be bytes, this is going to be of type big int, and then we're going to have a price, which is also going to be a big int.

17136
28:16:31.367 --> 28:16:37.008
Now price we're going to leave as not required for price, we're just going to have price be nullable.

17137
28:16:37.008 --> 28:16:38.300
So price can be null.

17138
28:16:38.300 --> 28:16:39.789
So we have an active item.

17139
28:16:39.789 --> 28:16:40.182
Awesome.

17140
28:16:40.182 --> 28:16:46.236
What else are we going to need? What what other tables do we have in Morales? Well, we're going to need type item listed.

17141
28:16:46.236 --> 28:16:52.640
And this is going to be at entity is going to need an ID, it'll have a seller.

17142
28:16:52.640 --> 28:16:57.901
Whenever an item gets listed, it's going to have a seller right, which is going to be a bytes again.

17143
28:16:57.901 --> 28:17:23.835
And if the address the address of the NFT, which will also be bytes, the token ID, which is going to be a big int, and then the price, which will also be a big end, we're gonna need a type item cancelled at entity which will have an ID seller an NFT address.

17144
28:17:23.835 --> 28:17:29.301
And a token ID will be a big end.

17145
28:17:29.301 --> 28:17:37.963
And then last type item bought will be in that entity is going to have an ID ID.

17146
28:17:37.963 --> 28:17:42.767
It's going to be a buyer bytes.

17147
28:17:43.101 --> 28:17:54.006
And then of T address a bytes and a token ID again, and then a price of beginnt.

17148
28:17:54.006 --> 28:18:04.364
And with Justice Information, we've defined what we want our subgraph to keep track of wants to keep track of item bought events, item, cancelled events, item listed events.

17149
28:18:04.364 --> 28:18:09.846
And then we're going to make this new active item table similar to what we did with mirallas.

17150
28:18:09.846 --> 28:18:13.522
And it's going to be some function of these these other three events.

17151
28:18:13.522 --> 28:18:16.679
And now we're done with our schema dot graph.

17152
28:18:16.679 --> 28:18:16.889
QL.

17153
28:18:17.101 --> 28:18:17.445
Awesome.

17154
28:18:20.101 --> 28:18:22.870
sub graph to actually listen for these events.

17155
28:18:24.101 --> 28:18:30.601
So what we want to do to tell it how to listen for these events, is we're going to go to src mapping.

17156
28:18:30.601 --> 28:18:30.801
ts.

17157
28:18:30.801 --> 28:18:32.601
It's this mapping.

17158
28:18:32.601 --> 28:18:40.051
ts file that's going to tell our subgraph how to actually map and how to actually store all the event information that we have.

17159
28:18:40.101 --> 28:18:43.901
If you look in it right now, it might even give you kind of a sample event.

17160
28:18:43.901 --> 28:18:46.967
So it says Export function, handle item event.

17161
28:18:47.101 --> 28:18:51.101
This is what Maya says right now, it takes as an input parameter event item bot.

17162
28:18:51.101 --> 28:18:58.133
So this is saying whenever an item bot event occurs, do this handle item bot function.

17163
28:18:58.133 --> 28:19:01.101
So anytime item bot happens do this handle item bot.

17164
28:19:01.101 --> 28:19:08.684
And we're actually getting this item bot from our generated NFT marketplace from some generated code.

17165
28:19:08.684 --> 28:19:09.767
In the graph.

17166
28:19:09.767 --> 28:19:11.850
If we run graph code Gen.

17167
28:19:12.101 --> 28:19:19.783
This graph code Gen command grabs all the stuff we have in the schema dot Graph QL and puts it in this generated file.

17168
28:19:19.783 --> 28:19:25.862
Now that I've run graph code Gen, you'll see in here there's an item bot class, you see there's a schema, that type script.

17169
28:19:25.862 --> 28:19:32.628
And actually we can even find that new active item class that we created in our schema.

17170
28:19:32.628 --> 28:19:40.379
So anytime you update schema dot Graph QL, you're always going to want to run graph code Gen, so you can update those types.

17171
28:19:40.379 --> 28:19:43.720
And if this failed, it means that you messed up something in your schema dot Graph QL.

17172
28:19:43.720 --> 28:19:45.497
Now in our mapping.

17173
28:19:45.497 --> 28:19:55.291
ts, we're actually importing item bought item cancelled item listed from generated and if the marketplace and if the marketplace from our generated code.

17174
28:19:55.291 --> 28:19:56.901
These are going to be our events.

17175
28:19:56.901 --> 28:19:59.901
And we're not going to need to do anything with the NFT marketplace.

17176
28:19:59.901 --> 28:20:01.624
We're just going to need our event information.

17177
28:20:01.624 --> 28:20:02.004
For now.

17178
28:20:02.004 --> 28:20:09.020
Let's go ahead and just delete everything inside our handle item bot or whatever sample is given to you.

17179
28:20:09.101 --> 28:20:12.762
So we're importing a or events from our generated code.

17180
28:20:13.101 --> 28:20:16.406
then we have this line here, which we're going to change in a second.

17181
28:20:16.406 --> 28:20:21.491
So again, we have these three functions handle item bought, handle item canceled and handle item listed.

17182
28:20:21.491 --> 28:20:25.049
Whenever we get an item bought event, we're going to do this function.

17183
28:20:25.101 --> 28:20:27.778
Whenever we get an item canceled event, we're going to do this function.

17184
28:20:27.778 --> 28:20:32.304
And all this code is defined in our sub graph dot Yamo.

17185
28:20:32.304 --> 28:20:38.204
You can see the different entities here in a bot item cancelled item listed, and the event handlers.

17186
28:20:38.204 --> 28:20:52.846
So it says, okay, anytime this specific event gets fired with an index address, an index address index, YouTube 36 in YouTube had six call handle item bought, which again, we're getting in here handle item.

17187
28:20:52.846 --> 28:20:55.354
But so that's exactly how this works.

17188
28:20:55.354 --> 28:20:59.773
So let's figure out what to do when an item bought event triggers.

17189
28:20:59.773 --> 28:21:04.434
And I think that item bought item cancelled item lists it is a little confusing.

17190
28:21:04.434 --> 28:21:18.713
So I like to change this to item bought as item bought event item cancelled as item cancelled event item listed as item listed event.

17191
28:21:18.713 --> 28:21:25.490
So I'm just changing the names of these three that are imported from NFT marketplace.

17192
28:21:25.490 --> 28:21:29.649
And now I'm going to change event item bot to item bought event.

17193
28:21:29.649 --> 28:21:34.197
Event item cancelled to item cancelled event and event item listed to item listed event.

17194
28:21:34.197 --> 28:21:34.971
Okay, great.

17195
28:21:34.971 --> 28:21:37.649
And we're just going to remove this line for now.

17196
28:21:37.649 --> 28:21:42.295
And we also don't need this line at the top at the beginning, we will in a minute, but we'll delete it for now.

17197
28:21:42.295 --> 28:21:44.682
So here's our minimalistic code here.

17198
28:21:44.682 --> 28:21:51.308
So whenever we list an item, what do we need to do? Well, we need to save that event in our in our graph.

17199
28:21:51.308 --> 28:21:56.628
And then we also need to update our active item, exactly as we did with Morales.

17200
28:21:56.628 --> 28:22:01.786
So first thing that we're going to need to do is either get or create an item listed object.

17201
28:22:01.786 --> 28:22:06.211
And something that we need to know is that each item needs a unique ID.

17202
28:22:06.211 --> 28:22:09.205
And we actually need to create that ID.

17203
28:22:09.205 --> 28:22:17.085
So one of the first things I'm going to do is going to create a function called Get ID from event params.

17204
28:22:17.085 --> 28:22:21.239
And it's going to take a token ID and here's where TypeScript comes into play a little bit.

17205
28:22:21.239 --> 28:22:25.546
In TypeScript, we actually need to define the types of our different parameters.

17206
28:22:25.546 --> 28:22:28.211
So token ID is going to be a big int.

17207
28:22:28.211 --> 28:22:33.462
And we'll also take an NFT address, which will take in a type of address.

17208
28:22:33.462 --> 28:22:42.387
And we also need to say what return type or function is going to give, which we're going to return a string, we're going to create an ID from event params.

17209
28:22:42.387 --> 28:22:46.157
And it's just going to be a combination of the token ID and the NFT address.

17210
28:22:46.157 --> 28:22:51.467
The combination of these two will give a unique ID for each one of these types of event.

17211
28:22:51.467 --> 28:23:02.528
So we're just gonna say return token ID, and token ID has a function called to x string, I'm gonna say plus, and if T address.

17212
28:23:02.528 --> 28:23:04.292
to X string, like so.

17213
28:23:04.292 --> 28:23:09.786
And big int an address, we need to import from at Graph Protocol slash graph TX.

17214
28:23:09.786 --> 28:23:11.731
It already imported big enough for me.

17215
28:23:11.731 --> 28:23:16.456
So I'm just going to add address in here is the two special types that come from the graph.

17216
28:23:16.456 --> 28:23:18.118
And then string is built into TypeScript.

17217
28:23:18.118 --> 28:23:27.244
Now that we have a way to get a special ID for each item in our function here, we have to now either get or create a new item listed.

17218
28:23:27.244 --> 28:23:29.624
Now right now we have an item.

17219
28:23:29.624 --> 28:23:33.139
But event we don't have an item bought object.

17220
28:23:33.139 --> 28:23:39.789
So the item bought object is going to be what we save, the item bought event is just the raw event.

17221
28:23:39.789 --> 28:23:44.339
So we have to create an item bought object from our item bought event.

17222
28:23:44.339 --> 28:23:47.944
And in TypeScript, these are going to be two different types.

17223
28:23:47.944 --> 28:23:50.456
So we have to import these item by objects.

17224
28:23:50.456 --> 28:23:54.168
So those actually get auto created from generated schema.

17225
28:23:54.168 --> 28:24:01.789
In here we have active item, we have item, we have an item bought class, we have an item cancelled, etc.

17226
28:24:01.789 --> 28:24:04.363
So we're gonna have to import those types from there.

17227
28:24:04.363 --> 28:24:17.067
So we can say, import, item listed, comma, active item, item bought an item cancelled from dot slash, generated slash schema.

17228
28:24:17.067 --> 28:24:21.602
Let's go ahead and get or create an item bot object.

17229
28:24:21.602 --> 28:24:26.888
So we'll say let item bot equals item bot dot load.

17230
28:24:26.888 --> 28:24:39.050
And this is how we load an item we load its unique ID by calling this get ID from event params dot load, get ID from event params.

17231
28:24:39.050 --> 28:24:44.166
And we can pass event dot params.

17232
28:24:44.166 --> 28:24:51.495
That token ID because an item bot event is going to have a token ID and event that params.

17233
28:24:51.495 --> 28:24:52.478
nf T address.

17234
28:24:52.478 --> 28:24:58.429
Now I know we probably should have done handle item listed first but we're doing item bot first.

17235
28:24:58.429 --> 28:25:05.305
Since we're buying an item, we probably will also have an active item as well, right? We haven't made yet an item listed.

17236
28:25:05.305 --> 28:25:07.553
But this is going to be similar to what we did with Morales.

17237
28:25:07.553 --> 28:25:13.462
So we know that every time we live Certain items will also list an active item.

17238
28:25:13.462 --> 28:25:18.502
So we'll say let active item equals active item that load.

17239
28:25:18.502 --> 28:25:21.429
And we're going to do this exact same thing.

17240
28:25:21.429 --> 28:25:24.379
So I'm just going to copy paste it into here.

17241
28:25:24.379 --> 28:25:31.779
And even though these are going to have the exact same ID, it doesn't matter because they're the same ID across different types.

17242
28:25:31.779 --> 28:25:41.368
Now we're gonna say, if there is no item bot, we'll say item bot equals a new item bot object.

17243
28:25:41.368 --> 28:25:50.757
And we'll give it an ID, which is going to be exactly our ID giving parameter here, get ID from events, and pass that there.

17244
28:25:50.757 --> 28:25:53.183
So we're going to create a new item bought here.

17245
28:25:53.183 --> 28:25:55.816
And now we're going to update all its parameters.

17246
28:25:55.816 --> 28:25:58.387
So back in our schema dot graph, QL.

17247
28:25:58.387 --> 28:26:02.446
An item bought has an ID, buyer address, token ID and price.

17248
28:26:02.446 --> 28:26:13.035
So we're gonna say, item bought, that buyer equals event dot params dot buyer, item bought.

17249
28:26:13.035 --> 28:26:16.368
nf T address equals event.

17250
28:26:16.368 --> 28:26:17.168
params.

17251
28:26:17.168 --> 28:26:25.482
nf T address, item bot, dot token ID equals event dot params dot token ID.

17252
28:26:25.482 --> 28:26:26.434
And that looks good.

17253
28:26:26.434 --> 28:26:34.164
And our active item will be from item listed, and item listed should give it all these parameters, except for it won't have a buyer.

17254
28:26:34.164 --> 28:26:37.924
So we just need to update the buyer on our active item.

17255
28:26:37.924 --> 28:26:42.390
So we'll say active item, dot buyer, we'll do a little exclamation mark.

17256
28:26:42.390 --> 28:26:45.502
This is some TypeScript stuff, saying we will have an active item.

17257
28:26:45.502 --> 28:26:47.932
Don't worry too much about it if you're unfamiliar with TypeScript.

17258
28:26:47.932 --> 28:26:52.312
And we'll say that equals event dot params dot buyer.

17259
28:26:52.312 --> 28:27:06.972
And now similar to Morales, we're gonna do item bot dot save and active item with an exclamation mark again, that save and this is how we're going to save this item bought event as an object in our the Graph Protocol.

17260
28:27:06.972 --> 28:27:09.382
And also, we're going to update our active item.

17261
28:27:09.382 --> 28:27:12.960
So this is our full function of handle item bought.

17262
28:27:13.102 --> 28:27:25.823
Whenever somebody buys an item, we update a new item bought object, and we update our active item to be a new buyer, we're not going to delete it from our active items list, we're just going to update it with a new buyer.

17263
28:27:25.823 --> 28:27:29.102
And we'll just say if it has a buyer, that means it's been bought.

17264
28:27:29.102 --> 28:27:32.987
If it doesn't have a buyer, that means it's still on the market.

17265
28:27:32.987 --> 28:27:33.511
Awesome.

17266
28:27:33.511 --> 28:27:41.049
So now that we've done our handle item bot, let's now do our handle item listed, which will hopefully make our handle item bot a little bit easier to understand.

17267
28:27:41.049 --> 28:27:44.315
So for handle item listed, we're going to do the same piece here.

17268
28:27:44.315 --> 28:27:50.020
So we're going to say let item listed equals item listed dot load.

17269
28:27:50.020 --> 28:27:56.932
And we're gonna do the exact same thing as what we did for all these will do get ID from event params.

17270
28:27:56.932 --> 28:27:59.495
Like so, get a different event params.

17271
28:27:59.495 --> 28:28:01.855
And we're gonna say let active item.

17272
28:28:01.855 --> 28:28:05.659
And this line is going to be exactly the same as up here.

17273
28:28:05.659 --> 28:28:07.829
So I'm just going to copy paste.

17274
28:28:07.829 --> 28:28:14.983
So we're saying, okay, great, grab our item listed, and grab our active item, see if those objects already exist.

17275
28:28:14.983 --> 28:28:24.966
I will say if there is no item listed, which there shouldn't be, we'll go ahead and create a new one, we'll say item listed equals new item listed.

17276
28:28:24.966 --> 28:28:30.702
And its ID is going to be from this function that we created are unique IDs.

17277
28:28:30.702 --> 28:28:41.843
Now, unlike what we did above, we're also going to say, if there is no active item, then we're going to create a new active item, right? Because we're listing an item, it shouldn't be an active item.

17278
28:28:41.843 --> 28:28:48.610
Now this functionality is going to make a lot more sense here, right? Because if we're updating the price of an item, active item will already exist.

17279
28:28:48.610 --> 28:28:52.835
If it's a brand new listing, though, active item will not exist.

17280
28:28:52.835 --> 28:29:03.548
So we'll say okay, if it doesn't exist, okay, that means it's a brand new listing, we'll say item listed equals new item listed, and then we'll give it an ID.

17281
28:29:03.548 --> 28:29:07.655
That's the same ID methodology, paste that in.

17282
28:29:07.655 --> 28:29:11.911
So now all we got to do is update these new objects.

17283
28:29:11.911 --> 28:29:18.625
So I will say item listed that seller equals event dot params dot seller.

17284
28:29:18.625 --> 28:29:21.002
And I'm just going to copy paste this line.

17285
28:29:21.002 --> 28:29:24.836
Because this is just gonna be active item dot seller now.

17286
28:29:24.836 --> 28:29:28.456
Oops, see me and then it'll make this active item.

17287
28:29:28.456 --> 28:29:30.714
active item instead of item listed.

17288
28:29:30.714 --> 28:29:38.018
And what else comes with item listed? Well, let's go to the schema item listed has an NFT address, token ID and a price.

17289
28:29:38.102 --> 28:29:41.477
So okay, so let's add those.

17290
28:29:45.102 --> 28:29:46.213
equals event.

17291
28:29:46.213 --> 28:29:46.768
params.

17292
28:29:46.768 --> 28:29:47.879
nf T address.

17293
28:29:50.102 --> 28:29:54.711
because it's gonna be the be the exact same for active item.

17294
28:29:55.102 --> 28:30:01.990
item listed that token ID equals event dot params dot token ID.

17295
28:30:02.102 --> 28:30:03.640
Copy paste this line.

17296
28:30:03.640 --> 28:30:05.716
Same thing for active item.

17297
28:30:07.102 --> 28:30:13.741
price equals event dot params dot At price, copy, paste this line for active item.

17298
28:30:13.741 --> 28:30:16.281
And then we just say those two.

17299
28:30:16.281 --> 28:30:20.835
So item listed that save active item.

17300
28:30:20.835 --> 28:30:21.501
Save.

17301
28:30:21.501 --> 28:30:30.132
So in our protocol here, if it's already been, if there already is an active item, then we just go ahead and we get that active item.

17302
28:30:30.132 --> 28:30:32.964
This would be for a listing that we're updating.

17303
28:30:32.964 --> 28:30:34.757
If not, we make a new one.

17304
28:30:34.757 --> 28:30:37.472
We update it with whatever came in through the event.

17305
28:30:37.472 --> 28:30:39.972
And then we save it to our graph protocol.

17306
28:30:39.972 --> 28:30:40.875
Okay, perfect.

17307
28:30:40.875 --> 28:30:43.302
Now we only have one left, item cancelled.

17308
28:30:43.302 --> 28:30:48.052
So let's figure out how to do item cancelled, it's going to look really similar to item bought.

17309
28:30:48.102 --> 28:30:54.992
So we'll say let item cancelled equals item cancelled that load.

17310
28:30:55.102 --> 28:31:09.340
Again, we're going to do this exact same Id get our that we're doing for everything, we'll say let active item equals, and I'm going to zoom out a little bit less active item equals active item dot load.

17311
28:31:09.340 --> 28:31:12.482
Or do this exact same thing here.

17312
28:31:12.482 --> 28:31:12.958
Boom.

17313
28:31:12.958 --> 28:31:23.052
And then we're gonna say, if not item cancelled, which there shouldn't be because this should be the only item canceled event here.

17314
28:31:23.102 --> 28:31:28.860
We'll say item cancelled, equals new item cancelled.

17315
28:31:30.102 --> 28:31:33.343
gonna give it an ID using the same ID methodology we've been using.

17316
28:31:33.343 --> 28:31:35.713
Now this is going to look a little bit different.

17317
28:31:35.713 --> 28:31:42.136
We're gonna say item canceled, that seller equals event dot params dot seller.

17318
28:31:42.136 --> 28:31:43.791
So far, so good.

17319
28:31:43.791 --> 28:31:55.938
Item canceled dot NFT address equals event dot params dot NFT Address item canceled dot token ID equals event dot params dot token ID.

17320
28:31:55.938 --> 28:32:01.118
And then finally, we are going to change the active item a little bit different than what we've seen.

17321
28:32:01.118 --> 28:32:06.387
active item exclamation mark again, ignore if you're confused by that dot buyer.

17322
28:32:06.387 --> 28:32:12.985
And we're going to update the buyer to equal address dot from string.

17323
28:32:13.102 --> 28:32:15.843
We're going to give it what's called the Dead address.

17324
28:32:16.102 --> 28:32:18.690
that's this right here.

17325
28:32:22.102 --> 28:32:37.784
producing 718 1920 21 to two to three to 45 to 67 to 8930 3130 230-334-3536 zeros lowercase d, uppercase E, lowercase A uppercase D, this is known as the dead address.

17326
28:32:37.784 --> 28:32:42.477
And this is how we're going to decide if an item is still on the marketplace or not.

17327
28:32:42.477 --> 28:32:44.789
Or if an item has been bought or not.

17328
28:32:44.789 --> 28:32:49.972
If we have the dead address as its buyer, that's going to mean that the item has been cancelled.

17329
28:32:49.972 --> 28:32:56.640
And that's how we are going to be able to tell that an item is on the marketplace or not dead address means it's been cancelled.

17330
28:32:56.640 --> 28:33:01.736
An empty address, which is what will happen for handle item listed means it's on the market.

17331
28:33:01.736 --> 28:33:05.843
And an actual real address means that it's actually been bought by somebody.

17332
28:33:05.843 --> 28:33:09.416
So the way we can tell if it's on the market is it's 0x 0000000.

17333
28:33:09.416 --> 28:33:14.610
Because the data address is obviously going to be different than than all zeros.

17334
28:33:14.610 --> 28:33:30.151
The data address is a commonly used address kind of as a burner address that nobody owns, then we can just say, item cancelled that save an active item that say active item, exclamation mark dot save and perfect.

17335
28:33:30.151 --> 28:33:32.937
Our mapping file is now completed.

17336
28:33:33.102 --> 28:33:42.049
We now have three different functions to define how to handle when items are bought events, how to handle when items are cancelled event and item listed events.

17337
28:33:42.049 --> 28:33:47.602
And if you're confused, remember all the code for this is available on this the graph section of my GitHub.

17338
28:33:47.602 --> 28:33:51.625
So you can just follow along with the code here, if you ever get lost or need help.

17339
28:33:51.625 --> 28:33:58.964
And with that, we're almost ready to tell our subgraph to start listening to our contracts, there's just at least one more thing that we want to do.

17340
28:33:58.964 --> 28:34:08.702
So in our sub graph dot Yamo, we'll see source address blah, blah, blah, this is telling us to start indexing events since the beginning of Aetherium.

17341
28:34:08.702 --> 28:34:20.152
Now we don't really want it to do that, because it will take a really long time, we want to tell our subgraph Hey, you don't just start from beginning of time, you just need to start from right before our contract was deployed.

17342
28:34:20.152 --> 28:34:25.757
So we can add what's called our start block to tell it what block number to start deploying.

17343
28:34:25.757 --> 28:34:40.635
Now if we have our address, which we do right here, we can copy it, we can paste it on to the rink fee, ether scan, paste it in here, or really any block Explorer, and we'll see what block number our contract was deployed.

17344
28:34:40.635 --> 28:34:42.977
And it looks like it was this block.

17345
28:34:42.977 --> 28:34:50.031
So I'm going to copy that address, go back to my code and say starting block, it's going to be right here.

17346
28:34:50.102 --> 28:34:55.021
Starting block is going to be when it was deployed, minus one.

17347
28:34:55.102 --> 28:35:01.602
So we're gonna go right before we deployed our contract, we're going to start reading any event that is indexed from it.

17348
28:35:01.602 --> 28:35:18.237
Now if you just deployed this, it might not have any events in it at all, which we're going to fix in just a minute so don't worry, but with that all the instructions for how to build Our sub graphs are ready to be deployed to the graph, start our indexing and start working with our instructions in a decentralized context.

17349
28:35:18.237 --> 28:35:33.452
So what we can do now is back in the graph, we actually have the auth and deploy code right here, we can copy this, this graph auth dash dash studio, which is our deploy key on how to deploy.

17350
28:35:33.452 --> 28:35:35.502
And we can run this in our code editor.

17351
28:35:35.502 --> 28:35:40.216
So we're going to paste that in here, graph off dash studio, hit enter.

17352
28:35:40.216 --> 28:35:43.347
And we're gonna say deploy key set for the graph.

17353
28:35:43.347 --> 28:35:52.053
So this is just setting us up so that whenever we push our code, it's going to push it to this sub graph configuration that we've made on their site to help us deploy automatically.

17354
28:35:52.102 --> 28:36:07.983
Now we can do, we don't need to enter the subgraph, because we've already moved stuff down, is we'll build the sub graph, we'll run graph code Gen, we can just run graph kojem, which again, is just going to make sure our schema dot Graph QL looks good.

17355
28:36:07.983 --> 28:36:10.966
And then we're going to run our graph build.

17356
28:36:11.102 --> 28:36:18.802
And this graph build command is going to compile and run all of our sub graph stuff, everything in mapping that JSON all our generated code.

17357
28:36:18.802 --> 28:36:24.392
And it's going to put this into a real build folder, the generated folder has kind of like a pseudo build folder.

17358
28:36:24.392 --> 28:36:26.182
And then we have a real build folder.

17359
28:36:26.182 --> 28:36:29.584
So the generated is just to build some typings for our TypeScript.

17360
28:36:29.584 --> 28:36:35.721
And it's this build folder, this real build folder, is what we're going to actually be deploying and sending to the graph.

17361
28:36:35.721 --> 28:36:38.387
And we can actually deploy our subgraph.

17362
28:36:38.387 --> 28:36:40.798
Now, with graph deploy dash s studio.

17363
28:36:40.798 --> 28:36:48.856
And if the marketplace, which we're going to run right now, now is going to give us a version label option, which we're going to give it the 0.

17364
28:36:48.856 --> 28:36:58.568
0 point one, since this is our first version, and it goes ahead and starts deploying it to the graph, we also get to upload our sub graph to IPFS.

17365
28:36:58.568 --> 28:37:03.508
And we have a little hash right here for IPFS for a subgraph that we could look at.

17366
28:37:03.508 --> 28:37:07.515
But now if you're successful, we now have this build completed thing.

17367
28:37:07.515 --> 28:37:11.512
And we have these sub graph endpoints for queries and subscriptions.

17368
28:37:11.512 --> 28:37:16.031
So we can actually start querying and subscribing to our sub graph.

17369
28:37:16.102 --> 28:37:23.784
But if we go back to our site here now and we hit refresh, we can now see status deployed, we can see that we're sinking.

17370
28:37:23.784 --> 28:37:30.479
And now we have some nodes that are listening for our events to be emitted here, which is incredibly exciting.

17371
28:37:30.479 --> 28:37:32.892
We can go to logs to see if anything went wrong.

17372
28:37:32.892 --> 28:37:35.263
And right now it's just indexing, it's listening.

17373
28:37:35.263 --> 28:37:39.829
It's going through all the different blocks in the blockchain, listening for our events.

17374
28:37:39.829 --> 28:37:51.373
And then we have a playground here where we can run some queries to see different events and the different responses from our Graph QL, which right now, it's totally blank, because we haven't done anything yet.

17375
28:37:51.373 --> 28:37:58.808
So once again, let's pull up our hard hat and ft marketplace code, or open it up in a new terminal, whatever you want to do.

17376
28:37:58.808 --> 28:38:02.898
And let's go ahead, and let's run our mminton list script.

17377
28:38:02.898 --> 28:38:12.292
But for rink B, so we'll do yarn, hard hat, run scripts, mint, and list item dash dash network Rinkeby.

17378
28:38:12.292 --> 28:38:19.610
So we're going to mint an NF T, right, this is going to be to transaction, so we're gonna have to wait a little bit, and then we're going to approve the NFT.

17379
28:38:19.610 --> 28:38:21.566
And then we're going to list it on our marketplace.

17380
28:38:21.566 --> 28:38:25.135
And once it's listed, it's going to emit an item listed event.

17381
28:38:25.135 --> 28:38:30.610
And we should see now we have an active item and an item listed data in our Graph QL.

17382
28:38:30.610 --> 28:38:36.803
Now you can learn more about now what you see here on the left hand side is what's known as a Graph QL query.

17383
28:38:36.803 --> 28:38:41.055
Now, we're not going to go over how to do these, but I'm going to leave some links in the GitHub repository.

17384
28:38:41.055 --> 28:38:45.323
If you want to learn how to do more of these queries, these are going to be similar to what we saw with Morales.

17385
28:38:45.323 --> 28:38:48.189
But instead of them being kind of regular table lookups.

17386
28:38:48.189 --> 28:38:56.056
They're in Graph QL syntax, and the results of our query, end up being over here, we can see more information about our schema all the way to the right over here.

17387
28:38:56.103 --> 28:39:02.769
But if we look at our code, now, we've made the NFT approved it we've listed it on our marketplace.

17388
28:39:02.769 --> 28:39:14.492
So now if we go back to the graph, and we run this query, and we do a little refresh on our NFT marketplace, we might have to wait a few minutes for the graph to index these new blocks.

17389
28:39:14.492 --> 28:39:18.199
But in our playground, we should see the show up as a query.

17390
28:39:18.199 --> 28:39:30.916
If you don't automatically get these you can pause the video to write these into your Graph QL playground, right? So after a few minutes, refresh on ether scan, I can see that list item transaction has gone through.

17391
28:39:30.916 --> 28:39:33.424
This means we've emitted a new event.

17392
28:39:33.424 --> 28:39:40.040
So if I come back to my playground, and I hit play here, oh my goodness, we can see we have active items.

17393
28:39:40.040 --> 28:39:41.977
And we see we have item listed.

17394
28:39:42.103 --> 28:39:43.149
This is fantastic.

17395
28:39:46.103 --> 28:39:56.083
a off chain service that is indexing our events for our contract so that we can update our front end and we can update people in a decentralized way.

17396
28:39:56.083 --> 28:39:58.828
This is so exciting.

17397
28:39:59.103 --> 28:40:07.656
Awesome, so now that we have this all set up, we can finally go back to our next JS project or next Jas NFT marketplace the graph FCC.

17398
28:40:07.656 --> 28:40:18.431
The reason we did all this is because right Now in our code base for our next Jas NFT Marketplace application, we're reading from a Morales database, which we're not going to do anymore.

17399
28:40:18.431 --> 28:40:28.780
Instead of reading from a Morales database, we're going to read from the graph, let's go ahead and learn how to update our code our index dot j, s to read from the graph instead.

17400
28:40:28.780 --> 28:40:36.275
So to highlight this, to show this, we're actually going to create a new page, a new file, and we're just going to call it graph, example, dot j, s.

17401
28:40:36.275 --> 28:40:42.822
And we're just gonna make this a really minimalistic page to show you how to do a graph query.

17402
28:40:42.822 --> 28:40:49.585
So similar to index dot j, s, we're gonna do export default graph example.

17403
28:40:49.585 --> 28:40:54.551
It's going to be a function, or default function, graph example.

17404
28:40:54.551 --> 28:40:58.349
And we're gonna use this tool called Apollo client, copy, paste it over.

17405
28:40:58.349 --> 28:41:10.053
And we're going to add it with yarn, add dash dash dev at a P O ll O, slash, client, or excuse me, not Dev, because we do need this on the front end.

17406
28:41:10.053 --> 28:41:12.686
So yarn add at Apollo slash client.

17407
28:41:12.686 --> 28:41:18.636
Oh, sorry, we also need to do yarn, add Graph QL, we need to add both of those.

17408
28:41:18.636 --> 28:41:24.740
And it's this Apollo slash client, which is how we're going to make queries to our newly created graph.

17409
28:41:24.740 --> 28:41:24.998
QL.

17410
28:41:24.998 --> 28:41:35.496
So we're gonna say import the use query hook, from this package we just installed from at a P, O, ll o slash client.

17411
28:41:35.496 --> 28:41:37.709
And we'll also import G QL.

17412
28:41:37.709 --> 28:41:46.436
So to create a new query, we'll say const, get active item equals g QL.

17413
28:41:46.436 --> 28:41:48.969
And we'll add this backtick here.

17414
28:41:48.969 --> 28:41:54.516
And we'll add all of our Graph QL stuff in here, this is gonna be equivalent to this, this is Graph QL.

17415
28:41:54.516 --> 28:41:54.878
Syntax.

17416
28:41:54.878 --> 28:41:59.136
And we're gonna be putting this Graph QL syntax into our code base here.

17417
28:41:59.136 --> 28:42:01.723
But we only want to get the active items.

17418
28:42:01.723 --> 28:42:10.660
So how are we going to get the active items? Well, we can actually build it over here on our playground first, and then add it to our code base.

17419
28:42:10.660 --> 28:42:27.035
So we'll say we want to grab the active items, we'll grab the first five, and then we'll say where the buyer is going to be 0x 12345678.

17420
28:42:27.035 --> 28:42:29.627
We're saying where the buyer is empty.

17421
28:42:29.627 --> 28:42:47.918
So we're grabbing the active items where there is no buyer, and then we're going to do and then we're going to get the ID, the buyer, the seller, the NFT address, token, ID and the price from that.

17422
28:42:47.918 --> 28:42:52.730
And if we hit run, we get our active item here.

17423
28:42:52.730 --> 28:43:02.997
So we see here, the buyer is this exact 0x 12345678 Because it gets defaulted to zero when there is no buyer.

17424
28:43:02.997 --> 28:43:07.119
And this is why for item cancelled, we updated the buyer to be that dead address.

17425
28:43:07.119 --> 28:43:09.321
So if it's bought, it won't be active anymore.

17426
28:43:09.321 --> 28:43:12.568
And if it's cancelled, it also won't be active anymore.

17427
28:43:12.568 --> 28:43:17.134
Now we can copy this query and paste it into our code.

17428
28:43:17.134 --> 28:43:22.189
And now we have a Graph QL query that we can use for our graph example.

17429
28:43:22.189 --> 28:43:25.945
Now in our graph example, we'll use this query with this use query hook.

17430
28:43:25.945 --> 28:43:29.748
So in export default function, graph example, we can say const.

17431
28:43:29.748 --> 28:43:37.540
And it comes with a whole bunch of stuff like loading error, and then the data returned equals, use query.

17432
28:43:37.540 --> 28:43:46.264
And then we'll just pass it this Get active item, or get active items, let's put an S on it, get active items.

17433
28:43:46.264 --> 28:43:50.909
And then we can just return return a little div.

17434
28:43:51.103 --> 28:43:54.737
And we'll say hi in the div, and then we'll just do console dot log data.

17435
28:43:54.737 --> 28:43:57.752
And then now we'll go back to our app.

17436
28:43:57.752 --> 28:44:04.103
js, where we're wrapping everything in a Morales provider, we also need to wrap everything in an Apollo provider.

17437
28:44:04.103 --> 28:44:12.769
And we need to initialize it kind of similar to how we initialize connecting to our morale server, but we're going to initialize connecting to our Graph QL.

17438
28:44:12.769 --> 28:44:34.971
So we're gonna say import a P O ll o provider, a P O ll o client, and in mem ory, cache from at a P O ll o slash client, like that, and then we'll have to initialize this so we can delete the morale stuff.

17439
28:44:34.971 --> 28:44:41.819
We'll initialize this client by saying const client equals new a P O LL.

17440
28:44:41.819 --> 28:44:44.837
O client, and we'll give it the parameters here.

17441
28:44:44.837 --> 28:45:01.790
And you can find this all in the Apollo client documentation will say there's going to be a cache to help when we do refreshes and stuff we'll say new in memory cache, and we'll say comma URI, a que where we're going to be connecting.

17442
28:45:01.790 --> 28:45:04.796
And this is where we're going to add the API for our sub graph.

17443
28:45:04.796 --> 28:45:15.619
So if we go back to details, we can see temporary query URL and this is a rate limited temporary query, because this is just a test net, and we're going to copy this, go back to our code.

17444
28:45:15.619 --> 28:45:16.941
And we're just going to paste it in here.

17445
28:45:16.941 --> 28:45:23.534
So whatever you have for temporary query URL, and your sub graph studio, that's where you're gonna paste in here.

17446
28:45:23.534 --> 28:45:28.436
Now, this client tells our Graph QL, where it should be making those queries.

17447
28:45:28.436 --> 28:45:29.959
And we're gonna make it to here.

17448
28:45:29.959 --> 28:45:31.441
Now, this starts with HTTPS.

17449
28:45:31.441 --> 28:45:37.295
So is this centralized? Yes, because we are directly calling the graph website.

17450
28:45:37.295 --> 28:45:42.835
However, all the data is still gonna be stored in this decentralized graph indexer.

17451
28:45:42.835 --> 28:45:51.436
And kind of similar to what we did with IPFS, we're doing this kind of as a gateway to make it a lot easier for us to connect and read the data from the graph studio.

17452
28:45:51.436 --> 28:46:10.971
However, in the future, as more protocols and more browsers adopt the graph, and IPFS, this will become a lot easier inside of our Morales provider, but outside of our notifications provider, we're gonna say a P O ll o provider, and then client equals client.

17453
28:46:11.103 --> 28:46:17.103
And then we're going to copy the closing tag, and put it around the notification provider and press Save.

17454
28:46:17.103 --> 28:46:19.944
Now I'm gonna save our front end, now we're going to try to run our front end.

17455
28:46:19.944 --> 28:46:23.040
And we're gonna have to change some stuff in here because it's going to freak out.

17456
28:46:23.040 --> 28:46:26.711
So we're gonna run yarn Dev, for new front end.

17457
28:46:26.711 --> 28:46:28.817
So we're gonna go to our localhost 3000.

17458
28:46:28.817 --> 28:46:32.864
And it's going to totally freak out, because we still have some morale stuff in here.

17459
28:46:32.864 --> 28:46:34.053
And that's totally okay.

17460
28:46:34.053 --> 28:46:36.490
We, of course, we don't need a hard hat Node running.

17461
28:46:36.490 --> 28:46:41.348
Because we're on a test net, we don't need to be synched with Morales, we don't need to be doing any of that stuff.

17462
28:46:41.348 --> 28:46:45.995
Because we're working with a test net, right now, it's actually not freaking out, which is great.

17463
28:46:45.995 --> 28:46:48.430
But it shows obviously nothing for recently listed.

17464
28:46:48.430 --> 28:46:55.275
So what we're going to do now is we're gonna do slash, graph example, and hit enter.

17465
28:46:55.275 --> 28:46:57.740
And we can see Hi, show up.

17466
28:46:57.740 --> 28:47:14.150
But if we go to inspect, and we go to console, a console here, we can see an object here of active items, which is returned from the graph with buyer ID, NFT, address price and all this stuff in the air.

17467
28:47:14.150 --> 28:47:15.007
This is fantastic.

17468
28:47:15.103 --> 28:47:15.955
So okay, okay.

17469
28:47:15.955 --> 28:47:16.282
Okay.

17470
28:47:19.103 --> 28:47:19.545
to update.

17471
28:47:19.545 --> 28:47:21.561
So let's go ahead, we'll kill our server.

17472
28:47:22.103 --> 28:47:27.941
all we have to do is update, instead of use mirallas query, we're going to delete this.

17473
28:47:27.941 --> 28:47:31.070
And we're just going to query from Apollo query from our Graph QL.

17474
28:47:31.070 --> 28:47:39.909
And everything else stays the same, right? Because our NFT box, and all the rest of the code that we worked with, will still work exactly the same.

17475
28:47:39.909 --> 28:47:41.401
So first, we just got to get our address.

17476
28:47:41.401 --> 28:47:47.803
So we're gonna say import, same as Sell, sell NFT, import the network mapping, so I'm actually just going to copy it.

17477
28:47:47.803 --> 28:47:51.857
So we're going to import network mapping from constants, network mapping dot JSON.

17478
28:47:51.857 --> 28:47:54.695
And now we can say const.

17479
28:47:54.695 --> 28:48:10.636
Marketplace, address equals, and we're going to get the exact same way we did this and sell NFT to, so we're going to grab this line getting the chain string, we'll paste that in here, which means we're going to need to get chain ID from user Morales.

17480
28:48:10.636 --> 28:48:13.922
And then we're gonna get the marketplace address like this.

17481
28:48:13.922 --> 28:48:16.524
So we're going to copy that line, paste it in here.

17482
28:48:16.524 --> 28:48:17.155
Okay, great.

17483
28:48:17.155 --> 28:48:19.769
Now we have the marketplace address.

17484
28:48:19.769 --> 28:48:22.926
So now we're just going to do const.

17485
28:48:23.103 --> 28:48:27.167
Loading error data, which we can do listed.

17486
28:48:29.103 --> 28:48:34.245
equals, use query, and we can do that get active items.

17487
28:48:35.103 --> 28:48:47.022
I'm going to do is I'm going to create a new file and constants, we're going to pass that get active items thing in their new file, we're just going to call it sub graph queries, dot j, s.

17488
28:48:47.103 --> 28:48:51.303
And then here, we're gonna say import G QL.

17489
28:48:53.103 --> 28:48:54.526
slash client.

17490
28:49:00.103 --> 28:49:01.151
g QL backtick.

17491
28:49:05.103 --> 28:49:09.699
back to the graph example, we'll just copy that whole line actually pasted in here.

17492
28:49:09.699 --> 28:49:15.703
And now we'll just do export default, get active items.

17493
28:49:15.703 --> 28:49:22.960
And we'll import this query from sub graph queries into our index dot j s.

17494
28:49:22.960 --> 28:49:34.838
So we'll say import, get active queries are skimming apt get active items from dot dot slash constants slash sub graph queries.

17495
28:49:34.838 --> 28:49:42.103
And now in our use query will pass Get active items, which should return are listed NF Ts.

17496
28:49:42.103 --> 28:49:53.214
So now, we'll change this from fetching listed NF Ts to loading, loading, or we don't have listed NF Ts.

17497
28:49:53.214 --> 28:50:05.364
So if it's loading or we don't have listen if TS then do loading, otherwise, we're going to do another mapping, but the return of the Graph QL is going to be a little bit different.

17498
28:50:05.364 --> 28:50:15.447
So instead of listing MTS dot map, it's going to be listed NF T's dot AQ two have items, dot map and f t, and then we're going to get price.

17499
28:50:15.447 --> 28:50:21.603
And if the address token ID, we're not going to get marketplace address, but we'll get seller from NFT.

17500
28:50:21.603 --> 28:50:24.136
And it's not going to be returned with attributes.

17501
28:50:24.136 --> 28:50:26.764
So we can just do console dot log NFT instead.

17502
28:50:26.764 --> 28:50:32.413
And then we just pass all that stuff normally to, to that NFT box exactly the way that we did before.

17503
28:50:32.413 --> 28:50:51.918
So really, we're all we're doing is we're swapping out the query methodology here, price is going to be from price price is going to be from the query, and ft address is going to be from the query token ID from the query marketplace address, that's also gonna be slightly different, we're going to get that from our own config seller is going to be from the query, and then the key is going to be from the query as well.

17504
28:50:51.918 --> 28:51:08.038
So now if we save that, if we restart our website, with yarn Dev, and we go back to our homepage, we should see everything exactly the same, except for the images being pulled from the graph, instead of being pulled from her Alice.

17505
28:51:08.103 --> 28:51:12.395
Let's go back to our front end, we'll give it a nice refresh, close out the console.

17506
28:51:12.395 --> 28:51:14.179
And we'll go to our homepage.

17507
28:51:14.179 --> 28:51:16.824
And I forgot to do use query.

17508
28:51:16.824 --> 28:51:24.361
So let's import use query, import, use query from at a Paulo slash client.

17509
28:51:24.361 --> 28:51:28.884
Let's save and let's go back and give that a refresh.

17510
28:51:28.884 --> 28:51:38.004
And oh, my goodness, we now have updated to get our events from a decentralized data structure.

17511
28:51:38.103 --> 28:51:40.085
That's freaking awesome.

17512
28:51:43.103 --> 28:51:52.531
real quickly, we are using the image tag in here in our NFT box, we are using the image tag in here from next Jas, which comes with some pre processing.

17513
28:51:52.531 --> 28:51:54.287
So it's a little hard to use on IPFS.

17514
28:51:54.287 --> 28:51:58.182
So we would need to update the way we do images in order to host this on IPFS.

17515
28:51:58.182 --> 28:51:59.769
But we still can do that.

17516
28:51:59.769 --> 28:52:05.499
Some other options we have actually are Morales, we can actually even host our apps on Morales, if we want.

17517
28:52:05.499 --> 28:52:11.906
We can also use things like for cell or Netlify, or etc, or really any other traditional centralized hosting service.

17518
28:52:11.906 --> 28:52:17.836
Now, if you want to, I challenge you to update this code to make it be able to be hosted on IPFS.

17519
28:52:17.836 --> 28:52:20.460
So that you'll have an end to end decentralized.

17520
28:52:20.460 --> 28:52:29.119
And if the marketplace first wanted to make a PR to this code, so that it can be successfully hosted completely end to end on IPFS wins and empty for me.

17521
28:52:29.119 --> 28:52:29.506
But wow.

17522
28:52:29.506 --> 28:52:32.169
And with that we are done with less than 15.

17523
28:52:32.169 --> 28:52:35.960
This is an absolutely monstrous accomplishment.

17524
28:52:35.960 --> 28:52:42.436
And if you finish this, if you've understood everything, if you've gotten through everything so far, you should feel incredibly proud of yourself.

17525
28:52:42.436 --> 28:52:48.332
Because this is our last full stack section, our front end section and you're a full stack monster at this point.

17526
28:52:48.332 --> 28:52:52.516
huge congratulations, you should be super, super, super proud.

17527
28:52:52.516 --> 28:52:59.139
And definitely take a break, go get a coffee, and get ready for the final stretch of lessons 1617 and 18.

17528
28:52:59.139 --> 28:53:01.453
Those are gonna go by a little bit quicker.

17529
28:53:01.453 --> 28:53:12.203
I'm very excited for you take a break, and I'll see you there.

17530
28:53:13.103 --> 28:53:21.277
Right, welcome to Lesson Six tene, where we're going to be going into even more low level code here.

17531
28:53:21.277 --> 28:53:27.296
The hard hat upgrades of course, per usual, our entire GitHub repository is located here.

17532
28:53:27.296 --> 28:53:30.366
And additionally, we have an optional video that you can watch.

17533
28:53:30.366 --> 28:53:36.553
If you want to learn more, we're actually going to watch a slice of that video that explains upgradable smart contracts.

17534
28:53:36.553 --> 28:53:37.403
So let's jump in.

17535
28:53:37.403 --> 28:53:45.052
Now I'm editing this video much later after I filmed that, hence why I have a beard so I'll be jumping in from time to time updating some of the sections.

17536
28:53:45.103 --> 28:53:47.418
When deploying your smart contracts on chain.

17537
28:53:48.103 --> 28:53:50.857
that those smart contracts are immutable or unchangeable.

17538
28:53:51.103 --> 28:53:57.289
what if I told you that they were immutable? Well, technically, that wouldn't be correct.

17539
28:53:57.289 --> 28:54:00.393
However, smart contracts actually can change all the time.

17540
28:54:00.393 --> 28:54:05.293
When people transfer tokens when people stake in a contract or really do any type of functionality.

17541
28:54:05.293 --> 28:54:10.293
Those smart contracts have to update their balances and update their mappings and update their variables to reflect this.

17542
28:54:10.293 --> 28:54:16.065
The reason that they're immutable is that the logic itself never changes and will be on chain like that forever.

17543
28:54:16.065 --> 28:54:19.021
So technically, yes, once they are deployed, they are immutable.

17544
28:54:19.021 --> 28:54:25.758
And this is actually one of the major benefits of smart contracts in the first place that nobody can tamper with or screw with our smart contracts once we deploy them.

17545
28:54:25.758 --> 28:54:34.296
However, this can be an issue if, for example, we want to upgrade our smart contract or protocol to do more things, or want to fix some glaring bug or issue that we have.

17546
28:54:34.296 --> 28:54:39.424
Now even though we can't change the specific code that's been deployed to an address, we can actually do a lot more than you think.

17547
28:54:39.424 --> 28:54:44.054
And in this video, we're going to explain the different methodologies behind upgrading your smart contracts.

17548
28:54:44.103 --> 28:54:54.903
And then we're going to show you how to do it with hard hat and open Zeppelin huge shout out to a lot of open Zeppelin and trilobites articles that helped me put this video together and a number of other sources as well links in the description.

17549
28:54:54.903 --> 28:54:56.103
So let's get to it.

17550
28:54:56.103 --> 28:55:06.103
Now at first glance, you might be thinking, if you can upgrade your smart contracts, then they're not really immutable that in a way you'd be right.

17551
28:55:06.103 --> 28:55:17.916
So when explaining kind of the different philosophies and patterns that we can use here, we do need to keep Behind the philosophies and decentralization implications that each one of these patterns have, as they do all have different advantages and disadvantages.

17552
28:55:17.916 --> 28:55:21.878
And yes, some of the disadvantages here are going to affect the centrality.

17553
28:55:21.878 --> 28:55:22.910
So we need to keep that in mind.

17554
28:55:22.910 --> 28:55:29.923
And this is why it's so important that before you go ahead and jump in and start deploying upgradable smart contracts, you understand the trade offs.

17555
28:55:29.923 --> 28:55:33.366
So we're going to talk about three different ways to upgrade your smart contracts.

17556
28:55:33.366 --> 28:55:51.416
The first one being the not really slash Paramor ties way to upgrade your smart contracts, the social migration method, and then the method that you probably have heard about, which is proxies, which have a ton of subcategories, like metamorphic contracts, transparent upgradable, proxies, and universal upgradable proxies.

17557
28:55:51.416 --> 28:55:56.577
So let's talk about the not really upgrading method, or the parameterization method, or whatever you want to call it.

17558
28:55:56.577 --> 28:56:00.104
This is the simplest way to think about upgrading your smart contracts.

17559
28:56:00.104 --> 28:56:02.530
And it really isn't upgrading our smart contracts.

17560
28:56:02.530 --> 28:56:09.554
Because we can't really change the logic of the smart contract, whatever logic that we've written, is there, we also can add new storage or state variables.

17561
28:56:09.554 --> 28:56:11.504
So this is really not really upgrading.

17562
28:56:11.504 --> 28:56:22.437
But it is something to think about upgrades is just parameterizing, everything, whatever logic that we've deployed is there, and that's what we're interacting with this function means we just have a whole bunch of setter functions.

17563
28:56:22.437 --> 28:56:23.974
And we can update certain parameters.

17564
28:56:23.974 --> 28:56:30.043
Like maybe we have a reward parameter that gives out a token at 1 percent, every year or something like that.

17565
28:56:30.104 --> 28:56:34.687
Maybe we have a setter function that says, hey, update that to 2 percent, or update that to 4 percent.

17566
28:56:34.687 --> 28:56:37.416
It's just a setter function that changes some variable.

17567
28:56:37.416 --> 28:56:41.507
Now, the advantages here, obviously, this is really simple to implement.

17568
28:56:41.507 --> 28:56:55.530
The disadvantage is that if you didn't think of some logic or some functionality, the first time you deployed their smart contract, that's too bad, you're stuck with it, you can't update the logic or really update anything with the parameterization, aka, not really method.

17569
28:56:55.530 --> 28:57:02.476
And the other thing you have to think about is who the admins are, who has access to these setter functions to these updating functions.

17570
28:57:02.476 --> 28:57:06.290
If it's a single person, guess what, you have a centralized smart contract.

17571
28:57:06.290 --> 28:57:10.354
Now of course, you can add a governance contract to be the admin contract of your protocol.

17572
28:57:10.354 --> 28:57:12.661
And that would be a decentralized way of doing this.

17573
28:57:12.661 --> 28:57:19.419
So just keep that in mind, you can do this method just need a governance protocol to do so another example of this might be a contract registry.

17574
28:57:19.419 --> 28:57:30.151
And this is something actually that early versions of ABA used before you call a function, you actually check some contract registry that is updated as a parameter by somebody and you get routed to the contract, and you do your call there.

17575
28:57:30.151 --> 28:57:36.881
Again, this really doesn't allow us to have the full functionality of upgrades here, you can argue that this registry is a mix of one of the later versions.

17576
28:57:36.881 --> 28:57:41.491
But for all intents and purposes, this doesn't really give us that flexibility that we want for upgrades.

17577
28:57:41.491 --> 28:57:46.304
But some people might even think that upgrading your smart contract is ruining the decent reality.

17578
28:57:46.304 --> 28:57:51.294
And one of the things that makes smart contracts so potent is that they are immutable, and that this is one of the benefits that they have.

17579
28:57:51.294 --> 28:57:57.776
So there are some people who think that you shouldn't add any customization or any upgradability, you should deploy your contract.

17580
28:57:57.776 --> 28:57:58.758
And then that's it.

17581
28:57:58.758 --> 28:58:08.158
trilobites has actually argued that if you deploy your contract, knowing that it can't be changed later, you take a little bit extra time, making sure you get everything right.

17582
28:58:08.158 --> 28:58:14.087
And there are often less security vulnerabilities because you're just setting it forgetting it and not looking at it again.

17583
28:58:14.087 --> 28:58:26.039
Now, if I wanted to upgrade a smart contract with this philosophy in mind, the philosophy that I do want to keep my smart contracts immutable, we can instead use the social migration method, which I previously called the Eat method.

17584
28:58:26.039 --> 28:58:27.572
And now I think it's less funny.

17585
28:58:27.572 --> 28:58:37.140
So we're just gonna stick with social migration, the social eating method, or the migration method is just when you deploy your new contract, not connected to the old contract in any way.

17586
28:58:37.140 --> 28:58:44.246
And by social convention, you tell everybody, hey, hey, this new contract, this new one that we just deployed? Yeah, this is the real one now.

17587
28:58:44.246 --> 28:58:51.071
And it's just by convention of people migrating over into using this new one, that the upgrade is done, hence my slang name of social yeet.

17588
28:58:51.104 --> 28:58:57.831
Because you use the first one out of the way and move to the second one.

17589
28:58:58.104 --> 28:58:59.014
I think I'm funny.

17590
28:59:01.104 --> 28:59:03.858
always saying, Hey, this is our immutable smart contract.

17591
28:59:04.104 --> 28:59:05.054
this is our new one.

17592
28:59:07.104 --> 28:59:17.379
immutable, because since you give it no way of being upgraded in place, than if somebody calls that contract in 50,000 years in the future, it will respond exactly the same.

17593
28:59:17.379 --> 28:59:22.170
Another huge disadvantage here is that you have to have a totally new contract address.

17594
28:59:22.170 --> 28:59:29.942
So if you're an ERC 20 token, for example, you have to go convince all the exchanges to list your new contract address as the actual address.

17595
28:59:29.942 --> 28:59:34.998
Keep in mind that when we do this, we do have to move the state of the first one over to the second one.

17596
28:59:34.998 --> 28:59:45.039
So for example, if you're an ERC token moving to a new version of that ERC token, you do, you have to have a way to take all those mappings from the first contract and move it to the second one.

17597
28:59:45.039 --> 28:59:47.776
Obviously, there are ways to do this, since everything is on chain.

17598
28:59:47.776 --> 28:59:56.504
But if you have a million transfer calls, I don't want to have to write the script that updates everyone's balance and figures out what everyone's balance is just so I can migrate to my new version of the contract.

17599
28:59:56.504 --> 28:59:59.213
So there's a ton of social convention work here to do.

17600
28:59:59.213 --> 29:00:04.815
trilobites has actually written a fantastic blog on upgrading from a v1 to v2 or etc.

17601
29:00:04.815 --> 29:00:11.246
With this eat methodology and they give a lot of steps for moving your storage and your state variables over To the new contract.

17602
29:00:11.246 --> 29:00:13.265
So link in the description if you want to read that.

17603
29:00:13.265 --> 29:00:14.483
Now let's get to our big ticket item.

17604
29:00:14.483 --> 29:00:31.270
So in order to have a really robust upgrading mentality or philosophy, we need to have some type of methodology or framework that can update our state, keep our contract address and allow us to update any type of logic in our smart contracts in a easy way, which leads us to our big ticket item is the proxies.

17605
29:00:31.270 --> 29:00:37.483
What's our big ticket item? proxies, proxies.

17606
29:00:37.483 --> 29:00:47.476
Proxies are the truest form of upgrades, since a user can keep interacting with the protocols through these proxies, and not even notice that anything changed or even got updated.

17607
29:00:47.476 --> 29:00:50.925
Now, these are also the places where you can screw up the easiest.

17608
29:00:50.925 --> 29:00:53.519
Proxies use a lot of low level functionality.

17609
29:00:53.519 --> 29:00:56.733
And the main one being the delegate call functionality.

17610
29:00:56.733 --> 29:01:04.878
Delegate call is a low level function where the code in the target contract is executed in the context of the calling contract.

17611
29:01:04.878 --> 29:01:07.722
And message dot sender and message dot value also don't change.

17612
29:01:07.722 --> 29:01:09.367
So you understand what delegate call means.

17613
29:01:09.367 --> 29:01:10.314
Now, right? Great.

17614
29:01:10.314 --> 29:01:20.357
And in English, this means if I delegate call a function in contract B from contract a, I will do contracts B's logic in contract a.

17615
29:01:20.357 --> 29:01:30.639
So if contract B has a function that says hey, store this value in a variable up top, I'm going to store that variable in contract a, this is the powerhouse.

17616
29:01:30.639 --> 29:01:44.104
And this combined with the fallback function allows us to delegate all calls through a proxy contract address to some other contract, this means that I can have one proxy contract that will have the same address forever.

17617
29:01:44.104 --> 29:01:57.804
And I can just point and route people to the correct implementation contract that has the logic, whenever I want to upgrade, I just deploy a new implementation contract and point my proxy to that new implementation.

17618
29:01:57.804 --> 29:02:11.069
Now, whenever a user calls a function on the proxy contract, I'm going to delegate call it to the new contract, I can just call an admin only function on my proxy contract, let's call it upgrade or something and I make all the contract calls go to this new contract.

17619
29:02:11.069 --> 29:02:15.056
When we're talking about proxies, there are four pieces of terminology that we want to keep in mind.

17620
29:02:15.056 --> 29:02:16.817
First is the implementation contract.

17621
29:02:16.817 --> 29:02:20.879
The implementation contract has all of our logic and all the pieces of our protocol.

17622
29:02:20.879 --> 29:02:29.297
Whenever we upgrade, we actually launch a brand new implementation contract, the proxy contract proxy points to which implementation is the correct one.

17623
29:02:29.297 --> 29:02:42.765
And routes everyone's calls to the correct implementation contract, you can think the proxy contracts sits on top of the implementations the user, the user is going to be making contract and function calls through the proxy contract.

17624
29:02:42.765 --> 29:02:49.523
And then some type of admin, the admin is the one who's going to decide when to upgrade and which contract to point to.

17625
29:02:49.523 --> 29:03:00.038
In this scenario, the other cool thing about the proxy and delegate call is that all my storage variables are going to be stored in the proxy contract and not in the implementation contract.

17626
29:03:00.104 --> 29:03:05.934
This way, when I upgrade to a new logic contract, all of my data will stay on the proxy contract.

17627
29:03:05.934 --> 29:03:17.304
So whenever I want to update my logic, just point to a new implementation contract, if I want to add a new storage variable or a new type of storage, I just add it in my logic contract and the proxy contract will pick it up.

17628
29:03:17.304 --> 29:03:19.349
Now, using proxies has a couple of gotchas.

17629
29:03:19.349 --> 29:03:20.717
And we're gonna talk about the gotchas.

17630
29:03:20.717 --> 29:03:27.088
And then we're going to talk about the different proxy contract methodologies, because yes, there are many proxy contract methodologies as well.

17631
29:03:27.088 --> 29:03:31.604
And this is why trilobites doesn't really recommend using upgradable proxies for your smart contracts.

17632
29:03:31.604 --> 29:03:35.009
Because they're fraught with a lot of these potential issues.

17633
29:03:35.009 --> 29:03:40.546
Not to mention, again, you do still have some type of admin who's going to be upgrading your smart contracts.

17634
29:03:40.546 --> 29:03:43.844
Now, if this is a governance protocol, then great, you're decentralized.

17635
29:03:43.844 --> 29:03:47.646
But if this is a single group or entity, then we have a problem.

17636
29:03:47.646 --> 29:03:53.834
The two biggest gotchas are storage, clashes, and function selector clashes.

17637
29:03:53.834 --> 29:04:00.488
Now, what does this mean? When we use delegate call, remember, we do the logic of contract B inside contract a.

17638
29:04:00.488 --> 29:04:15.222
So if contract B says we need to set value to two, we go ahead and set value to what these smart contracts are actually kind of dumb, we actually set the value of whatever is in the same storage location on contract as contract B.

17639
29:04:15.222 --> 29:04:24.037
So if our contract looks like this, and we have two variables and contract a, we're still going to set the first storage spot on a contract a to the new value.

17640
29:04:24.104 --> 29:04:30.039
This is really important to know because this means we can only append new storage variables and new implementation contracts.

17641
29:04:30.104 --> 29:04:31.961
And we can't reorder or change old ones.

17642
29:04:33.104 --> 29:04:33.574
clashing.

17643
29:04:36.104 --> 29:04:38.193
talk about, they all address this issue.

17644
29:04:39.104 --> 29:04:41.045
called function select or clashes.

17645
29:04:42.104 --> 29:04:47.954
proxies to delegate call to one of these implementations, it uses what's called a function selector to find a function.

17646
29:04:47.954 --> 29:04:52.918
A function selector is a four byte hash of the function name and the function signature.

17647
29:04:52.918 --> 29:04:55.237
Don't worry about the function signature for now.

17648
29:04:55.237 --> 29:05:07.267
Now, it's possible that a function in the implementation contract has the same function selector as an admin function in the proxy contract, which may cause you to do accidentally a whole bunch of weird stuff.

17649
29:05:07.267 --> 29:05:13.707
For example, in this sample code in front of you even though All these functions are totally different, they actually have the same function selector.

17650
29:05:13.707 --> 29:05:25.033
So yes, we can run into an issue where some harmless function like get price has the same function selector as upgrade proxy or destroy proxy or something like that.

17651
29:05:25.104 --> 29:05:29.071
This leads to our first of the three implementations of the proxy contracts.

17652
29:05:29.071 --> 29:05:31.974
This is called the transparent proxy pattern.

17653
29:05:32.104 --> 29:05:35.138
And it's actually going to be the pattern that we're gonna be demoing to you today.

17654
29:05:35.138 --> 29:05:38.764
In this methodology, admins are only allowed to call admin functions.

17655
29:05:38.764 --> 29:05:42.770
And they can't call any functions in the implementation contract.

17656
29:05:42.770 --> 29:05:47.310
And users can only call functions in the implementation contract and not any admin contracts.

17657
29:05:47.310 --> 29:05:57.866
This way, you can't ever accidentally have one of the two swapping, and having a function selector clash and you running into a big issue where you call a function, you probably shouldn't have, if you're an admin, you're calling admin functions.

17658
29:05:57.866 --> 29:06:00.409
If your user you're calling implementation functions.

17659
29:06:00.409 --> 29:06:06.402
So if you're an admin, and you build some crazy, awesome defi protocol, you better come up with a new wallet address because you can't participate.

17660
29:06:06.402 --> 29:06:12.011
The second type of proxy we're going to talk about is the universal upgradeable proxy, or the op amps.

17661
29:06:12.011 --> 29:06:29.394
This version of upgradable contracts actually puts all the logic of upgrading in the implementation itself this way, the solidity compiler will actually kick out and say, Hey, we got two functions in here that have the same function selector.

17662
29:06:29.394 --> 29:06:37.854
This is also advantageous because we have one less read that we have to do, we no longer have to check in the proxy contract if someone is an admin or not.

17663
29:06:37.854 --> 29:06:40.734
This saves on gas, of course, and the proxy is also a little bit smaller.

17664
29:06:40.734 --> 29:06:47.865
Because of this, the issue is that if you deploy an implementation contract, without any upgradeable functionality, you're stuck.

17665
29:06:47.865 --> 29:06:50.468
And it's back to the Eat method with you.

17666
29:06:50.468 --> 29:06:55.329
And the last pattern or methodology that we're going to talk about is the diamond pattern, which does a number of things.

17667
29:06:55.329 --> 29:07:00.265
But one of the biggest things that it does, it actually allows for multiple implementation contracts.

17668
29:07:00.265 --> 29:07:02.431
This addresses a couple of different issues.

17669
29:07:02.431 --> 29:07:12.104
For example, if your contract is so big, and it doesn't fit into the one contract maximum size, you can just have multiple contracts through this multi implementation method.

17670
29:07:12.104 --> 29:07:20.168
It also allows you to make more granular upgrades, like you don't have to always deploy and upgrade your entire smart contract, you can just upgrade little pieces of it.

17671
29:07:20.168 --> 29:07:21.038
If you've chunked them out.

17672
29:07:21.038 --> 29:07:26.215
All the proxies mentioned here have some type of Aetherium improvement proposal, and most of them are in the draft phase.

17673
29:07:26.215 --> 29:07:31.661
And at the end of this explainer, we will do a demo of showing you how the delegate call function works.

17674
29:07:31.661 --> 29:07:34.693
And the end of the demo is right now.

17675
29:07:34.693 --> 29:07:38.961
So let's look at delegate call.

17676
29:07:39.104 --> 29:07:44.845
Now, we're going to learn about how to actually build these proxies how to build these upgradable smart contracts.

17677
29:07:44.845 --> 29:07:48.525
And to do this, we first need to learn about this delegate call function.

17678
29:07:48.525 --> 29:07:52.404
And it's going to be really similar to the call function, which we learned much earlier.

17679
29:07:52.404 --> 29:07:55.022
If you haven't seen that, be sure to go back to our Harnett.

17680
29:07:55.022 --> 29:08:02.793
And if T's we have a sub lesson in there, about EVM, opcodes, and coding and calling and we'll give you all the context for delegate call.

17681
29:08:02.793 --> 29:08:12.554
Like I said, in the explainer, it's very similar to call however, the way that I think about it is one contract says Oh, I really like your function, I'm going to borrow it myself.

17682
29:08:12.554 --> 29:08:14.604
And we're going to be looking at solidity by example.

17683
29:08:14.604 --> 29:08:16.691
I'll leave a description in the GitHub.

17684
29:08:16.691 --> 29:08:21.294
And all the code for this will be in the GitHub associated with this lesson as well.

17685
29:08:21.294 --> 29:08:28.659
Now we have two contracts, we have this contract B that we're going to be deploying on remix and it looks like a real minimalistic real simple contract.

17686
29:08:28.659 --> 29:08:30.344
We have a couple of storage variables here.

17687
29:08:30.344 --> 29:08:55.038
And then we have a function that updates our values, we have a function called Set VARs and updates are you into public num? Now as we learned before, whenever we have some type of contract with storage variables they get stored in, in this storage data structure that's index starting from zero, right now are you into public num is that index zero, or sender's at index one, our values and index two etc.

17688
29:08:55.104 --> 29:09:02.748
Now we're going to deploy a contract a and now this contract is actually going to use the delegates call function.

17689
29:09:02.748 --> 29:09:12.039
Now a contract a this is going to look a little bit different, but it's still going to have this set bars functions, except it's going to make a delegate call function call to our contract B.

17690
29:09:12.104 --> 29:09:18.326
Now in our lesson 14 with NF TS we learned about call API dot encode with signature API dot encode etc.

17691
29:09:18.326 --> 29:09:29.387
So if you're unfamiliar with function selectors, if you're unfamiliar with if you're unfamiliar with this syntax, be sure to go back to lesson 14 To understand ABI dot encode with signature and contract dot call.

17692
29:09:29.387 --> 29:09:33.704
The difference here is we're doing contract dot delegate call.

17693
29:09:33.704 --> 29:09:37.071
What this call does is something very similar to call.

17694
29:09:37.071 --> 29:10:00.612
Normally, if we did contract dot call on this contract, we would just call this, we would just be calling this function set VARs, which would update contracts B's storage, but instead we're saying Hey, call that set VARs function, and then pass this as an input parameter, but call it in our contract, call it on contract a, we're kind of borrowing a function for our contract.

17695
29:10:00.612 --> 29:10:06.991
And so instead, what we're going to do, is we're going to borrow this set bars and run the set bars function over here.

17696
29:10:06.991 --> 29:10:13.858
Now the difference is instead of num equals num The variables could be named different than the variables on contract a.

17697
29:10:13.858 --> 29:10:23.414
So instead of num equals num, our contract is going to say, hey, whatever that storage of zero have that equal to whatever we pass as an input parameter.

17698
29:10:23.414 --> 29:10:25.459
And if that's a little bit confusing, just stay with me.

17699
29:10:25.459 --> 29:10:27.645
Let's go ahead and let's see this in remix.

17700
29:10:27.645 --> 29:10:30.317
So I'm going to copy paste this code into remix here.

17701
29:10:30.317 --> 29:10:32.845
So we can kind of test and see what this looks like.

17702
29:10:32.845 --> 29:10:39.329
Again, there's a link to this in the GitHub repo associated with this course, feel free to pause the video to grab this link.

17703
29:10:39.329 --> 29:10:42.270
It's solidity, hyphen, by hyphen, example.

17704
29:10:42.270 --> 29:10:47.354
org/delegate call, or you can just grab the code directly from lesson 16 Hardhead upgrades.

17705
29:10:47.354 --> 29:10:48.197
So let's compile this code.

17706
29:10:48.197 --> 29:10:49.362
And let me show you what I mean.

17707
29:10:49.362 --> 29:10:52.974
So I'm going to compile it, and we'll go to the Run tab.

17708
29:10:53.104 --> 29:11:03.865
And first let's deploy this contract beam, we'll hit Deploy, we now have a contract, num, center and value are all blank, we'll update the number to something like 777, we'll hit Set VARS.

17709
29:11:03.865 --> 29:11:08.912
Set VARs will change the storage variable num to 777.

17710
29:11:09.104 --> 29:11:13.318
And then we're changing the sender and the value, sender, and value is zero.

17711
29:11:13.318 --> 29:11:15.318
Now let's deploy contract a.

17712
29:11:15.318 --> 29:11:19.970
So we'll scroll back up contract a deploy, of course, we're on the JavaScript VM.

17713
29:11:19.970 --> 29:11:24.828
Now we have this contract a with num value in Cinder are also all blank.

17714
29:11:24.828 --> 29:11:45.734
But when we call set VARs, it's going to borrow this set VARs function from contract B and run it in contract a, you can almost think of it as if we're copying, set VARs and pasting it into our contract a just for one run, and then immediately deleting ADM, that's what this delegate call function does.

17715
29:11:45.734 --> 29:11:50.291
So when I call set VARs, we're going to pass it this contract address as an input parameter.

17716
29:11:50.291 --> 29:11:53.725
So it knows to call this contract said virus function.

17717
29:11:53.725 --> 29:11:57.021
When I pass it the address, and I pass 987.

17718
29:11:57.021 --> 29:12:01.750
Since we're borrowing the function, we're not going to update this num.

17719
29:12:01.750 --> 29:12:05.565
On contract B, we're going to update the num on contract a.

17720
29:12:05.565 --> 29:12:09.038
So when I hit Set VARs, we see num now has 19.

17721
29:12:09.038 --> 29:12:15.292
Seven, we see Senator and we see value still being zero here, because again, we're borrowing this function and running it here.

17722
29:12:15.292 --> 29:12:23.319
Now the way that this works, is it actually doesn't look at the names of our stored variables, it looks at the storage slots.

17723
29:12:23.319 --> 29:12:34.015
So when we borrow this function using delegate call, so we could have this these variables we named anything instead of num, we could call this first value.

17724
29:12:34.105 --> 29:12:36.492
Senator, we could call something else.

17725
29:12:38.105 --> 29:12:41.021
call foo, or whatever you want here.

17726
29:12:43.105 --> 29:12:51.355
function using delegate call, instead of grabbing the actual names of the variables, our contract will swap out these variable names with the storage slot.

17727
29:12:51.355 --> 29:12:59.006
So it says oh, okay, well, in contract B, you're accessing the num variable, which is, which is at storage slot zero.

17728
29:12:59.006 --> 29:13:12.449
So when we borrow set bars and contract a with Delegate call, we'll say storage slot zero is going to equal that underscore num.

17729
29:13:12.449 --> 29:13:16.793
Which are this contract storage slot zero is first value.

17730
29:13:16.793 --> 29:13:30.054
So we'll say first value equals underscore Now, something else is going to be stored slot two, so it's gonna say okay, storage slot two, we're gonna update storage slot two to message that sender.

17731
29:13:30.105 --> 29:13:33.028
Okay? value here is storage slot three.

17732
29:13:35.105 --> 29:13:38.838
slot three, will update with message dot value like this.

17733
29:13:39.105 --> 29:13:41.621
that's essentially what's going on behind the scenes.

17734
29:13:42.105 --> 29:13:44.898
go ahead and let's delete those and redeploy.

17735
29:13:44.898 --> 29:13:45.786
redeploy them.

17736
29:13:46.105 --> 29:13:54.323
we'll deploy contract be deployed contract a, right now in B, once again, if we do 1234, set VARs, we have 123.

17737
29:13:54.323 --> 29:13:55.794
And then contract a.

17738
29:13:55.794 --> 29:14:05.894
Now even though these variables have different names, we could grab contract B's address, paste it in, do 654, hit Set VARS.

17739
29:14:05.894 --> 29:14:09.578
And first value is now six by four.

17740
29:14:09.578 --> 29:14:17.637
So delegate call allows us to borrow functions, and then just transposes whatever is in here to the storage location equivalents.

17741
29:14:17.637 --> 29:14:23.851
And the other thing that's interesting is even if you don't have variables, it'll still save to storage slots.

17742
29:14:23.851 --> 29:14:29.514
So in contract a, if we didn't have any of those variable names, storage slot, 01, and two would still get updated.

17743
29:14:29.514 --> 29:14:32.157
Now here's where things can get really interesting.

17744
29:14:32.157 --> 29:14:34.252
Let's delete our contract again.

17745
29:14:34.252 --> 29:14:41.271
And let's change the type of our contract A's first value to from a UNT to a Boolean.

17746
29:14:41.271 --> 29:14:42.604
Let's save that.

17747
29:14:42.604 --> 29:14:45.282
And now let's deploy contract a.

17748
29:14:45.282 --> 29:15:05.524
Now when we call set VARs, on our contract a, it's still going to use the Set VARs function of contract B, which takes a Yewande and assigns the first storage slot that number we pass it, but our first storage slot is now a Boolean was so what do you think's going to happen now? Well, let's try it out.

17749
29:15:05.524 --> 29:15:08.845
Let's copy contract B's address, paste it in here.

17750
29:15:08.845 --> 29:15:14.406
We'll pass we'll do tu tu, tu as our input parameter, we'll hit Set VARS.

17751
29:15:14.406 --> 29:15:17.651
Our transaction actually does go through.

17752
29:15:17.651 --> 29:15:21.557
And now when we look at first value, it says true.

17753
29:15:21.557 --> 29:15:23.292
Hmm, that's really weird.

17754
29:15:23.292 --> 29:15:26.750
What if we change set VARs to zero, and hit Set VARS.

17755
29:15:26.750 --> 29:15:29.169
And now, first value is false.

17756
29:15:29.169 --> 29:15:38.695
In storage here, when we add a number with set VARs, it's going through because it's just setting the storage slot of the boolean to a number.

17757
29:15:38.695 --> 29:15:43.460
And when solidity reads it, it goes, Oh, well, first value is a Boolean.

17758
29:15:43.460 --> 29:15:46.443
So if it's anything other than zero, it's going to be true.

17759
29:15:46.443 --> 29:15:49.473
So this is how you can actually get some really weird results.

17760
29:15:49.473 --> 29:15:53.136
If your typings are different, or if your stored variants are different.

17761
29:15:53.136 --> 29:15:54.636
What if we made this an address.

17762
29:15:54.636 --> 29:16:04.845
So this is where working with Delegate call can get really weird and really tricky, really fast.

17763
29:16:05.105 --> 29:16:05.715
All right.

17764
29:16:09.105 --> 29:16:09.319
heat.

17765
29:16:12.105 --> 29:16:20.415
example, that shows how a contract can be used as a singular address, but the underlying code can actually change.

17766
29:16:20.415 --> 29:16:31.830
And all the code we're gonna be working with, once again, in the hardhat upgrades, FCC sub lesson, small proxy dot Sol, and you can go ahead and copy paste this code if you want to follow along.

17767
29:16:31.830 --> 29:16:34.007
So you don't have to code along with me here.

17768
29:16:34.105 --> 29:16:35.811
But you absolutely can if we want.

17769
29:16:37.105 --> 29:16:41.927
going to be one of the most, if not the most advanced section of the entire course.

17770
29:16:41.927 --> 29:16:44.622
So feel free to go ahead and skip over this sub lesson.

17771
29:16:44.622 --> 29:16:51.305
If you want to just move on to learning how to actually build these proxies, without really understanding what's going on behind the scenes.

17772
29:16:51.305 --> 29:16:55.032
However, it is still really powerful if you do understand what's going on behind the scenes.

17773
29:16:55.032 --> 29:16:58.438
So I have this minimalistic starting position right here.

17774
29:16:58.438 --> 29:17:00.402
I have small proxy is proxy.

17775
29:17:00.402 --> 29:17:05.030
And I'm importing this proxy dot sole thing from up in Zeplin.

17776
29:17:05.105 --> 29:17:11.055
openzeppelin has this minimalistic proxy contract that we can use to actually start working with this delegate call.

17777
29:17:11.105 --> 29:17:14.789
Now this contract uses a lot of assembly or what's something called you'll.

17778
29:17:14.789 --> 29:17:19.443
And it's an intermediate language that can be compiled to bytecode for different backends.

17779
29:17:19.443 --> 29:17:27.383
It's a sort of inline assembly inside solidity and allows you to write really, really low level code close to the opcodes.

17780
29:17:27.383 --> 29:17:32.261
Now we're not going to go over you'll but I'll leave some links to the you'll documentation if you want to learn more.

17781
29:17:32.261 --> 29:17:38.105
Even if you're a really advanced user, you really want to try to use as little EULA as possible.

17782
29:17:38.105 --> 29:17:43.556
Because since it is so much lower level, it is much easier to screw things up.

17783
29:17:43.556 --> 29:17:58.524
However, like I said, for this example, we are going to be using a little bit of you'll now in this proxy that we're going to be doing, we have this delegate function, which inside this inline assembly, which is you'll, it does a whole lot of really low level stuff.

17784
29:17:58.524 --> 29:18:02.875
But the main thing that it does is it goes ahead and it does this delegate call functionality.

17785
29:18:02.875 --> 29:18:08.105
If we look here, we can see it's using a fallback function and a receive function.

17786
29:18:08.105 --> 29:18:17.438
So whenever it receives a function that doesn't recognize it'll call fallback, and fallback calls our delegate function.

17787
29:18:17.438 --> 29:18:30.043
So anytime a proxy contract receives data for a function it doesn't recognize it sends it over to some implementation to some implementation contract where it will call it with Delegate call.

17788
29:18:30.105 --> 29:18:38.531
In our minimalistic example here, we have a function called Set implementation, which will change where those delegate calls are going to be sending.

17789
29:18:38.531 --> 29:18:41.975
This can be equivalent to like upgrading your smart contract.

17790
29:18:41.975 --> 29:18:47.741
And then we have implementation here to read where that implementation contract is.

17791
29:18:47.741 --> 29:18:57.089
Now to work with proxies, we really don't want to have anything in storage, because if we do delegate call, and that delegate call changes, some storage, we're going to screw up our contract storage.

17792
29:18:57.089 --> 29:19:04.566
The one caveat though to this, we do still need to store that implementations address somewhere, so we can call it so ERP 1976.

17793
29:19:04.566 --> 29:19:15.028
It's called the standard proxy storage slot, which is an Aetherium improvement proposal for having certain storage slots specifically used for proxies.

17794
29:19:15.105 --> 29:19:23.695
And in our minimalistic example here, we set bytes 32, private constant implementation slot to that location in storage.

17795
29:19:23.695 --> 29:19:31.533
And we'll say, okay, whatever is that this storage slot is going to be the location of the implementation address.

17796
29:19:31.533 --> 29:19:36.793
So the way our proxy is going to work is any contract that calls this proxy contract.

17797
29:19:36.793 --> 29:19:42.990
If it's not this set implementation function, it's going to pass it over to whatever is inside the implementation slot address.

17798
29:19:42.990 --> 29:19:44.432
That's what we're going to build here.

17799
29:19:44.432 --> 29:19:47.382
So we have the small proxy is proxy.

17800
29:19:47.382 --> 29:19:51.308
And we'll create a real minimalistic contract.

17801
29:19:51.308 --> 29:19:58.443
So we'll say contract employee, mentation A, and we'll just give it a U and 256.

17802
29:19:58.443 --> 29:20:13.023
public value and then function set value, you add 256 new value, public will say value equals new value So this is going to be our implementation.

17803
29:20:13.023 --> 29:20:26.542
So now anytime somebody calls small proxy, or small proxy contract, it's going to delegate, call it over to our implementation, a, and then save the storage in our small proxy address.

17804
29:20:26.542 --> 29:20:32.676
So we're going to call our small proxy with the data to use this set value function selector.

17805
29:20:32.676 --> 29:20:44.964
So let's make it a little easier just to figure out how to get that data by creating a new helper function, do function, get data to transact.

17806
29:20:45.105 --> 29:20:51.025
And we can get the data using the API dot encode with signature that we learned in an earlier lesson.

17807
29:20:51.025 --> 29:20:57.711
So function get data to transact, we'll pass it a un 256 number to update.

17808
29:20:57.711 --> 29:21:01.645
So we'll give this the number we want to call a new value.

17809
29:21:01.645 --> 29:21:07.999
We'll have this be public pure, that's going to return a bytes.

17810
29:21:08.105 --> 29:21:08.771
Memory.

17811
29:21:08.771 --> 29:21:13.326
And we'll just say return ABI dot ENCODE.

17812
29:21:14.105 --> 29:21:23.941
signature set value, you went to 56, comma, number to update.

17813
29:21:24.105 --> 29:21:27.588
So you'll remember this from our call anything section.

17814
29:21:28.105 --> 29:21:41.252
you don't remember how to do that, remember to refer back to our NFT section to learn how to call anything and use ABI dot encode ABI dot encode with a signature and call anything with its raw bytes bring and get the data to transact.

17815
29:21:41.252 --> 29:21:48.225
And we know that when we call implementation a, from our small proxy, we're going to update our small proxies storage.

17816
29:21:48.225 --> 29:21:53.006
So we'll create a little function in solidity just to read our storage in small proxy.

17817
29:21:53.006 --> 29:21:56.202
We're gonna say function, read storage.

17818
29:21:56.202 --> 29:22:07.901
And this will just be a public view, will do returns, returns you into 256, value at storage slot, zero.

17819
29:22:07.901 --> 29:22:13.978
And we are going to use a little bit of assembly here since we are doing all this low level stuff.

17820
29:22:13.978 --> 29:22:32.846
And we're going to call the s load up code to read the value at storage slot zero, we'll say value at storage slot zero, and we're going to set it and then in assembly, this is how we set things, we're going to set it equal to s load of storage slot zero, and then it will return this value here.

17821
29:22:32.846 --> 29:22:34.884
So we're reading directly from storage.

17822
29:22:34.884 --> 29:22:37.732
Oops, and then we need a little parenthese here.

17823
29:22:37.732 --> 29:22:38.138
Sorry.

17824
29:22:38.138 --> 29:22:41.223
So now, let's go ahead and deploy our small proxy.

17825
29:22:41.223 --> 29:22:43.188
And let's deploy our implementation A.

17826
29:22:43.188 --> 29:22:47.966
Now our small proxy has a function called Set implementation.

17827
29:22:47.966 --> 29:22:55.460
So we're saying, okay, anytime we call this proxy contract, we're going to delegate call the functions over to here.

17828
29:22:55.460 --> 29:23:02.819
So we're going to grab current implementations A's address, paste it into set implementation 77.

17829
29:23:02.819 --> 29:23:09.105
So this is the data of set value you in 256, with that number to update encoded in it.

17830
29:23:09.105 --> 29:23:17.850
So if we call our small proxy, with this data, our proxy contract is gonna go, oh, okay, this is a function.

17831
29:23:17.850 --> 29:23:19.875
I don't I don't see that function here.

17832
29:23:19.875 --> 29:23:24.551
We're going to call our fallback, right, which again, is coming from open Zeplin.

17833
29:23:24.551 --> 29:23:40.695
And our Fallback is going to do this delegate, which is this low level stuff, but it's basically just doing a delegate call, we're gonna call our fallback function, and then we're gonna get the function in the implementation A, we're gonna borrow this function, and we're gonna use it on our on ourselves.

17834
29:23:40.695 --> 29:23:45.558
So if I copy this, the implementation has been set to being this address down here.

17835
29:23:45.558 --> 29:23:47.533
So all the logic is going to be done here.

17836
29:23:47.533 --> 29:23:54.717
So when I go ahead, and I grabbed this, and paste it into call data, and I hit transact looks like it went successfully went through.

17837
29:23:54.717 --> 29:24:00.333
If I read storage, now, we see that it is indeed 777, which is incredibly exciting.

17838
29:24:00.333 --> 29:24:08.305
Now, this is incredibly beneficial, because now let's say we want to go and update our code, right? We don't like contract implementation anymore.

17839
29:24:08.305 --> 29:24:11.105
So let's go ahead copy contract implementation A.

17840
29:24:11.105 --> 29:24:14.191
And we'll make a new one called implementation B.

17841
29:24:14.191 --> 29:24:23.195
Now, let's say whenever somebody calls set value, we do value equals new value, plus one, or plus two.

17842
29:24:23.195 --> 29:24:25.938
Let's go ahead, let's save this.

17843
29:24:25.938 --> 29:24:27.521
Let's compile this.

17844
29:24:27.521 --> 29:24:36.777
And let's deploy implementation B, we'll grab implementation B's contract address, we'll call it onset implementation in our proxy.

17845
29:24:36.777 --> 29:24:42.637
And essentially, we have now upgraded from implementation a to implementation B.

17846
29:24:42.637 --> 29:24:49.137
Now, if we use this same data here, we're still going to call set value was 777.

17847
29:24:49.137 --> 29:24:55.395
But instead, we're now delegate calling to implementation B, instead of implementation A.

17848
29:24:55.395 --> 29:25:02.688
So if I call if I put this data into the low level call data, and I hit transact, it looks like it went through.

17849
29:25:02.688 --> 29:25:13.765
Now I read storage and now is 779 since doing value equals new value plus two so this is a minimalistic example of how upgrading actually works.

17850
29:25:13.765 --> 29:25:22.377
Now, this is incredibly beneficial, because we can always just tell people, Hey, make all your function calls to small proxy, and you'll be good to go.

17851
29:25:22.377 --> 29:25:30.505
But like I said before, this also means that the developers of this protocol can essentially change the underlying logic at any time.

17852
29:25:30.505 --> 29:25:36.882
This is why it is so important to be sure to read contracts and check to see who has the developer keys.

17853
29:25:36.882 --> 29:25:44.396
And if a contract can be updated, if a contract can be updated, and a single person can update it, well guess what, you have a single centralized point of failure.

17854
29:25:44.396 --> 29:25:46.744
And technically the contract isn't even decentralized.

17855
29:25:46.744 --> 29:25:53.501
Now, something else I was talking about in the video is function clashes function selector clashes.

17856
29:25:53.501 --> 29:26:01.782
Right now, whenever we call set implementation, the proxy function sedimentation gets called because we don't trigger the fallback because we can see the function is here.

17857
29:26:01.782 --> 29:26:14.029
However, if I have a function called Set implementation, in our implementation, this one can never be called, whenever we send a function signature of set implementation, it's always going to call the one on the proxy.

17858
29:26:14.029 --> 29:26:22.311
This is where the transparent proxy that we're going to be working with can help us out here and the universal upgradable proxy can help us to, and I'm not going to go too much deeper into these now.

17859
29:26:22.311 --> 29:26:28.329
But we've left some links in the GitHub repository to teach you more about these selector clashes.

17860
29:26:28.329 --> 29:26:54.416
And how those two proxy patterns that I just mentioned, the transparent and universal upgradable can get around these, if you're confused by anything in here, go into this discussion thread and make a new discussion about proxies make a new discussion about the Assembly about the you'll set implementation, this is a great time to connect with other people taking the course and ask questions here, because I know that this is a really advanced section, and requires you haven't gone through a lot of those sub lessons that we've gone before.

17861
29:26:54.416 --> 29:27:03.460
And if it takes you a couple times of playing around with solidity and playing around with remix, I definitely recommend you do so this is the section we're seeing really is believing.

17862
29:27:03.460 --> 29:27:04.819
And I want you to jump into remix.

17863
29:27:04.819 --> 29:27:06.152
And I want you to test this.

17864
29:27:06.152 --> 29:27:10.308
And I want you to play around with this and see what you can break and fiddle with.

17865
29:27:10.308 --> 29:27:17.665
But with all that being said, we finally have all the knowledge that we need to build our hardhat project that deals with upgrades.

17866
29:27:17.665 --> 29:27:21.865
So let's go ahead and jump into it.

17867
29:27:22.105 --> 29:27:44.072
Your new terminal, we're going to do MK dir, hard hat, upgrades, FCC, CD, hard hat, upgrades, FCC, and then code period, or file, open folder, this folder here, now I'm going to grab that same yarn add we've been grabbing from less than nine, we're gonna paste it in, we're going to add all of these different parameters.

17868
29:27:44.072 --> 29:27:49.155
And once again, we're going to copy over our hard hat config from previous sections, we're going to copy over prettier.

17869
29:27:49.155 --> 29:27:51.789
And we're just going to get our basic default setup.

17870
29:27:51.789 --> 29:27:56.219
At this point, you might have a setup that works best for you and that you like better.

17871
29:27:56.219 --> 29:27:57.969
And feel free to grab that as well.

17872
29:27:57.969 --> 29:28:00.298
So I'm going to paste the prettier is in here.

17873
29:28:00.298 --> 29:28:02.039
And I'm going to paste the hard hat.

17874
29:28:02.039 --> 29:28:02.329
config.

17875
29:28:02.329 --> 29:28:05.200
js that we've been using, instead of running yarn hard hat.

17876
29:28:05.200 --> 29:28:07.105
And now we should be good to go.

17877
29:28:07.105 --> 29:28:10.643
So let's create a new folder called contracts.

17878
29:28:10.643 --> 29:28:15.040
And in here, we're going to create a new file called Box dot soul.

17879
29:28:15.105 --> 29:28:19.505
And then it's this contract, that's going to be our implementation or our logic contract.

17880
29:28:19.505 --> 29:28:24.318
So it will say pragma, solidity carrot zero point 8.

17881
29:28:24.318 --> 29:28:46.896
7 contract box will say you into 256 internal value will do event value changed you into 256 new value, do function store, you went to 36 value, this will be a public function will say value equals new value.

17882
29:28:46.896 --> 29:29:00.623
So this store function is going to update our variable at storage slot zero, internal, and then we'll just omit value changed that new value.

17883
29:29:00.623 --> 29:29:11.529
And then we'll just create function retrieve, which will be a public view returns a UNT 256 We'll just do return value.

17884
29:29:11.529 --> 29:29:16.699
And then we're going to create a new function called version.

17885
29:29:16.699 --> 29:29:19.326
And this will be a public door.

17886
29:29:19.326 --> 29:29:21.574
And that returns a un 256.

17887
29:29:21.574 --> 29:29:25.089
And we're just going to have this return one.

17888
29:29:25.089 --> 29:29:28.106
So our box contract here is going to be version one.

17889
29:29:28.106 --> 29:29:38.456
Now we're going to copy all this code, paste it into a box v two dot soul and rename it to contract box v two, we're going to update the version to version two here.

17890
29:29:38.456 --> 29:29:42.525
And we're going to create a new function called increment.

17891
29:29:42.525 --> 29:29:45.912
And this will be a public function.

17892
29:29:46.106 --> 29:29:49.949
And we'll say value equals value plus one.

17893
29:29:52.106 --> 29:29:54.913
a value changed event with value.

17894
29:29:57.106 --> 29:30:03.875
contract address originally use the logic in box and then we're going to upgrade it to the logic in box V two.

17895
29:30:03.875 --> 29:30:16.992
And we're going to learn how to use all the tools that we've been working with here to add this logic and create this logic And let's just make sure this works, we'll do yarn, or that compile.

17896
29:30:17.106 --> 29:30:18.798
So let's make a readme.

17897
29:30:22.106 --> 29:30:23.582
box to box V two.

17898
29:30:28.106 --> 29:30:29.306
gonna point to box.

17899
29:30:32.106 --> 29:30:34.041
it to point to box V two.

17900
29:30:37.106 --> 29:30:40.201
pointing to box, then we're going to have it point to box V two.

17901
29:30:40.201 --> 29:30:50.231
And that's how we're going to upgrade it, one of the first things we're going to need to do is deploy a proxy, we can deploy a proxy manually ourselves, and we can build the proxy contracts and do all that stuff.

17902
29:30:50.231 --> 29:30:51.516
That's our first option.

17903
29:30:51.516 --> 29:31:00.351
Hardhead deploy also comes built in with deploying and upgrading proxies itself, where we can just specify that we want to use a proxy.

17904
29:31:00.351 --> 29:31:03.316
And we could specify the type of proxy that we want to use.

17905
29:31:03.316 --> 29:31:08.248
So number two is just saying using hard hat deploys, built in proxies.

17906
29:31:08.248 --> 29:31:21.213
And then number three is open Zeppelin actually has an upgrades plugin, which allows you to write some really simple scripts that allows you to have a really simple API like upgrades dot deploy proxy, and then upgrades that upgrade proxy.

17907
29:31:21.213 --> 29:31:26.532
Now for this section, we're going to be doing the hard hat deploys built in proxies.

17908
29:31:26.532 --> 29:31:34.895
However, in the GitHub repo associated with this, if you go to scripts, there's other upgrade examples that will show you how to use the opens up and upgrades plugin.

17909
29:31:34.895 --> 29:31:41.912
And we're not going to do deploy a proxy manually manually, because we essentially just showed you how to do that in our sub lesson.

17910
29:31:41.912 --> 29:31:51.306
So we're going to show you this, we're going to show you the Hardhead deploys built in proxies, and if you want to use the openzeppelin upgrades plugin, that is available in the GitHub repo as well.

17911
29:31:51.306 --> 29:31:53.033
So let's go ahead and do this.

17912
29:31:53.033 --> 29:31:57.235
So we're going to go ahead and we're going to make a new folder, or deploy folder.

17913
29:31:57.235 --> 29:32:02.702
And first, we're going to make a new file called a one, deploy box dot j s.

17914
29:32:02.702 --> 29:32:06.326
And this is going to look really similar to everything we've been doing so far.

17915
29:32:06.326 --> 29:32:14.735
So module dot exports, equals async function, we're going to get named accounts and deployments.

17916
29:32:14.735 --> 29:32:28.929
The arrow function will say const deploy COMM A log equals deployments const deployer equals await, get named.

17917
29:32:29.106 --> 29:32:57.106
Accounts, do a little logging, like this, and then we'll say const, box equals await, loi, box, comma, we'll say from Deployer, comma, args like this, we'll say weight con formations is going to be network dot config dot block confirmations for Masons.

17918
29:32:57.106 --> 29:33:01.506
And yep, we got to grab const from hard hat.

17919
29:33:01.506 --> 29:33:05.267
And then we can add the parameter in here for proxies.

17920
29:33:05.267 --> 29:33:08.846
And this is where we can add a ton of information.

17921
29:33:08.846 --> 29:33:17.525
So like I said, we're going to use the transparent upgradable proxy from open Zeppelin, which if we want to use it, we're going to have to add open Zeppelin.

17922
29:33:17.525 --> 29:33:24.124
So we'll do yarn, add dash dash dev at open Zeppelin slash contracts.

17923
29:33:24.124 --> 29:33:39.623
And we can tell our hard hat to deploy this box contract behind a proxy will say the proxy contract is going to be the open Zeppelin transparent proxy.

17924
29:33:39.623 --> 29:33:44.588
And we're also going to do a via admin contract.

17925
29:33:44.588 --> 29:33:52.499
So instead of having an admin address, for the proxy contract, we're going to have the proxy contract owned by an admin contract.

17926
29:33:52.499 --> 29:33:56.639
And doing it this way is considered a best practice for a number of reasons.

17927
29:33:56.639 --> 29:34:07.515
But we'll name this admin contract, box proxy admin and the artifact for this box proxy admin.

17928
29:34:07.515 --> 29:34:12.953
So we'll need to create a box proxy admin contract to be the admin of our box.

17929
29:34:12.953 --> 29:34:18.213
So in our contracts folder, create a new folder called proxy.

17930
29:34:18.213 --> 29:34:35.895
And in here, a new file called Box proxy admin that saw and this is going to be the admin contract we're going to have for controlling the proxy of our box so inbox proxy admin dot Saul will do SP DX license.

17931
29:34:35.895 --> 29:34:44.742
I then to fire MIT pragma solidity, carrot zero, point 8.

17932
29:34:44.742 --> 29:34:56.267
7, say contract, box proxy admin, like this, right? And once again, we're going to use one of the open Zetland tools in the transparent folder.

17933
29:34:56.267 --> 29:35:02.059
They have a proxy admin dot Saul, which is going to be essentially what our box proxy admin is going to be.

17934
29:35:02.106 --> 29:35:09.706
It has some functionality, it has some functions in here like change, proxy admin, upgrade, upgrade and call for dealing with upgrades.

17935
29:35:09.706 --> 29:35:10.352
All contracts.

17936
29:35:10.352 --> 29:35:22.173
So we're going to import it will do import at open Zeppelin slash contracts slash proxy slash transparent, slash proxy admin, dot soul.

17937
29:35:22.173 --> 29:35:28.847
And we'll say our Brock's box proxy admin is proxy admin, like this.

17938
29:35:28.847 --> 29:35:39.573
And to have this box proxy admin work with the heart at deploy plugin, our constructor needs to take an address owner as an input parameter, but we're just going to leave that blank.

17939
29:35:39.573 --> 29:35:42.735
And then, and then we need to do the proxy admin, which is just going to be blank as well.

17940
29:35:42.735 --> 29:35:43.412
And that's it.

17941
29:35:43.412 --> 29:35:51.772
That's all we're going to do box proxy admin contract, which just has all of the functionalities to do upgrades and change proxy admin and all this stuff.

17942
29:35:51.772 --> 29:36:03.193
We're going to deploy our box contract behind a proxy and opens up and transparent proxy that is owned by our Brock's proxy admin contract in the template Aetherium contracts.

17943
29:36:03.193 --> 29:36:11.783
GitHub repo is actually an examples slash opens up on proxies branch that will show you how to work with different types of proxies.

17944
29:36:11.783 --> 29:36:15.206
And there will be a link to this in the GitHub repo associated with this course.

17945
29:36:15.206 --> 29:36:20.948
And then we'll do our verification, say, chains dot includes.

17946
29:36:20.948 --> 29:36:32.932
And we'll go ahead, I'm going to copy paste our hard hat helper config from our last project, which has development chains, hard hat and local host that we export, will import this as well.

17947
29:36:32.932 --> 29:36:40.391
const development chains equals require dot slash helper hard hat config.

17948
29:36:40.391 --> 29:36:59.512
If development chains dot includes network dot name, and process dot env dot ether scan API key log, verifying that the same as we've done a way to verify last, we're going to copy over our utils folder.

17949
29:36:59.512 --> 29:37:05.299
So just copy, paste, we now have verify, which will import it in here.

17950
29:37:05.299 --> 29:37:17.006
So we'll do const verify equals require dot dot slash utils, slash verify, await verify box dot address.

17951
29:37:17.106 --> 29:37:18.864
And then args is going to be blank.

17952
29:37:20.106 --> 29:37:21.182
here, and boom.

17953
29:37:25.106 --> 29:37:30.942
So we can test this out by running yarn Hardhead deploy, see if everything works here.

17954
29:37:30.942 --> 29:37:32.187
And that's it done.

17955
29:37:32.187 --> 29:37:38.018
And then we should do actually, we should add log beach true as well.

17956
29:37:38.106 --> 29:37:40.009
Let's run this again, much better.

17957
29:37:41.106 --> 29:37:42.987
actually deploy a couple of contracts.

17958
29:37:44.106 --> 29:37:50.155
proxy admin, which is going to be our admin contract, then we deploy box implementation.

17959
29:37:50.155 --> 29:38:01.778
So hard hat deploy, went ahead and took our box contract and renamed it to box implementation and then deployed it, then it deployed our box proxy here.

17960
29:38:01.778 --> 29:38:05.912
So anytime we call this address, it actually will point to the logic of our box.

17961
29:38:05.912 --> 29:38:23.728
Now what we can do is we can write a deploy script to deploy box, the box v2 implementation, and then upgrade our box to box V to create a new deploy script called Zero to deploy box v2 dot j s or deploy box two dot j s.

17962
29:38:23.728 --> 29:38:26.486
And we'll do something really similar here.

17963
29:38:26.486 --> 29:38:31.806
Right, so I'm just going to copy pretty much of this, paste it in here.

17964
29:38:31.806 --> 29:38:40.106
Now we're going to do const box v two equals await, deploy.

17965
29:38:40.106 --> 29:38:45.369
Box v two, comma, from Deployer.

17966
29:38:45.369 --> 29:38:58.956
Log True RMS blank, weights confirmations, it's going to be network dot config dot lock.

17967
29:38:59.106 --> 29:39:08.699
Or masons, then I'm going to copy the verification code, copy this, paste it here, server, this is going to be box v2 dot address.

17968
29:39:08.699 --> 29:39:09.715
Okay, great.

17969
29:39:09.715 --> 29:39:14.439
So we now have some code where we can deploy box and box v2.

17970
29:39:14.439 --> 29:39:19.235
Now let's go ahead and write a script to actually upgrade these.

17971
29:39:19.235 --> 29:39:22.525
So we'll do a new folder, scripts.

17972
29:39:22.525 --> 29:39:26.518
New File, and we'll call it upgrade box dot j s.

17973
29:39:26.518 --> 29:39:28.912
Now we're going to do it the manual way here.

17974
29:39:28.912 --> 29:39:36.052
And the reason we're going to do it the manual way is because I want to show you exactly the functions that we're calling to do this upgrade process.

17975
29:39:36.106 --> 29:39:42.810
However, hard hat deploy also comes with an API to make it really easy to actually just upgrade your box contracts.

17976
29:39:42.810 --> 29:39:44.347
This is gonna be script.

17977
29:39:44.347 --> 29:39:47.418
So we'll start off with async function main.

17978
29:39:47.418 --> 29:39:53.868
And then we'll copy paste our traditional script, main dot then process exit blah, blah, blah, that whole thing.

17979
29:39:53.868 --> 29:39:57.834
We're first gonna get the box proxy admin contract.

17980
29:39:57.834 --> 29:39:59.761
We'll say box const.

17981
29:39:59.761 --> 29:40:15.751
Box, proxy admin equals await ethers dot get contract, box proxy admin and we got to import you Here's from Hardhead, then we're going to get the actual proxy, which is our transparent proxy.

17982
29:40:15.751 --> 29:40:24.963
So we'll say const transparent proxy equals await ethers dot get contract, box underscore proxy.

17983
29:40:24.963 --> 29:40:30.043
Since hard hat deploy, we'll just name the proxy the name of the implementation underscore proxy.

17984
29:40:30.043 --> 29:40:34.483
And then of course, we're going to need our box V to contract.

17985
29:40:34.483 --> 29:40:35.548
So say const.

17986
29:40:35.548 --> 29:40:41.550
Box v two equals await ethers dot get contract, box V two.

17987
29:40:41.550 --> 29:40:49.614
Now we can say const, upgrade TX equals a weight box proxy admin, that upgrade.

17988
29:40:49.614 --> 29:40:59.994
And we're going to call the upgrade function on our box proxy admin, which calls it on our transparent proxy, which will change the implementation from box one to box two.

17989
29:40:59.994 --> 29:41:23.784
So box proxy admin, that upgrade, we're going to upgrade the transparent proxy dot address to our box B to that address, it will look in our box proxy, a box proxy has an upgrade function which calls upgrade to on our transparent upgradeable proxy will do a weight upgrade TX dot wait one.

17990
29:41:23.784 --> 29:41:35.527
And now to work with the functions on our box v two, we're gonna say const proxy box equals await ethers dot get contract.

17991
29:41:35.527 --> 29:41:45.596
At box v two, we're going to get the box v two ABI however, we're going to load it at the transparent proxy address.

17992
29:41:45.596 --> 29:41:51.958
This way ethers knows okay, we're going to call all of our functions on the transparent proxy address.

17993
29:41:51.958 --> 29:41:57.563
But this proxy box is going to have the ABI of box v2, which is what we want.

17994
29:41:57.563 --> 29:42:03.088
Now we can say const version equals await proxy box dot version.

17995
29:42:03.088 --> 29:42:06.296
And we'll say console dot log version.

17996
29:42:06.296 --> 29:42:14.428
And if we want to compare this to its original implementation, before we upgrade, we can do the same thing.

17997
29:42:14.428 --> 29:42:29.439
We can say const proxy box v1, let's actually call this proxy box V to say cost proxy box v one is going to be this exact same thing equals this call box here.

17998
29:42:29.439 --> 29:42:44.450
And we'll do const version equals weight, right proxy box v1 dot version, console dot log version, or version v1, version v1.

17999
29:42:44.450 --> 29:42:51.211
We'll call this version v two, version v two, and proxy box V two.

18000
29:42:51.211 --> 29:42:54.868
So we'll get our version v one will upgrade.

18001
29:42:54.868 --> 29:43:00.378
And then we'll see at that same address what the version function now returns.

18002
29:43:00.378 --> 29:43:02.806
So let's open our terminal.

18003
29:43:02.806 --> 29:43:15.689
If I run yarn, our head node will spin up a node will have deployed our admin our implementation, our proxy, and then our box V to implementation.

18004
29:43:15.689 --> 29:43:17.892
I'll make a new terminal.

18005
29:43:17.892 --> 29:43:26.439
And I'll run yarn, hard hat run scripts upgrade box that J S dash dash network, local host.

18006
29:43:26.439 --> 29:43:29.286
And we should see that box actually update.

18007
29:43:29.286 --> 29:43:30.810
And that's exactly what we see.

18008
29:43:30.810 --> 29:43:33.123
And then let's do well, it's I forgot to do.

18009
29:43:33.123 --> 29:43:34.002
to string in here.

18010
29:43:34.106 --> 29:43:38.481
But it goes from version one to version two on that exact same address.

18011
29:43:38.481 --> 29:43:44.829
And with that little code, we have successfully learned how to upgrade our smart contracts programmatically.

18012
29:43:44.829 --> 29:43:52.668
Now, like I said, in the GitHub repo associated with this lesson, you can also check out the upgrades plugin from open Zeppelin.

18013
29:43:52.668 --> 29:44:03.391
So to work with that, you would just do upgrades dot deploy proxy proxy to call the Prepare upgrade function, and then upgrade upgrade proxy just like that.

18014
29:44:03.391 --> 29:44:08.006
They also have an upgrade tutorial, step by step for hardhat that you can follow along with as well.

18015
29:44:08.006 --> 29:44:10.006
Now I know this was an advanced section.

18016
29:44:10.106 --> 29:44:12.731
And I know we went a little bit quick here.

18017
29:44:14.106 --> 29:44:20.021
just finish this section, not only have you completed all these other sections that make you a really powerful smart contract developer.

18018
29:44:20.021 --> 29:44:22.751
But you've learned some really advanced stuff here.

18019
29:44:22.751 --> 29:44:36.090
We've gone into low level code like delegate call, we've gotten to assembly we've gotten to you'll we've gotten to these proxy patterns, which can really make you a an incredible stand out developer in the smart contract space.

18020
29:44:36.090 --> 29:44:43.753
So if you just finished this section, you should be so so proud of yourself because we went really fast and because there's a lot of advanced information here.

18021
29:44:43.753 --> 29:44:51.820
Now, like I said, 100 percent, be sure to go into the discussions tab and ask questions and connect and talk to other people in the area.

18022
29:44:51.820 --> 29:45:00.991
Maybe look at the already running discussions and jump in and start asking other students and start asking other people about what they've learned and how their proxies are going.

18023
29:45:00.991 --> 29:45:02.296
And if they made anything really cool.

18024
29:45:02.296 --> 29:45:10.003
If you're just excited and you want to go to the show and tell section, make a show and tell me like hey, here's my GitHub repo for doing this upgrade section.

18025
29:45:10.003 --> 29:45:29.535
going here and be excited with that being said go and take that coffee break go take that walk go to the gym go get excited Go tell your friends we are almost done we have two lessons left and then you're home free All right, welcome back to lesson 17 For hardhat.

18026
29:45:29.535 --> 29:45:31.249
Douse, you're almost done.

18027
29:45:31.249 --> 29:45:38.460
Now for this section, I've actually already made a video on how to code a dowel with TypeScript and solidity in JavaScript.

18028
29:45:38.460 --> 29:45:41.878
So we're actually just going to play this video for this section.

18029
29:45:41.878 --> 29:45:45.865
The reason we're going to display this one is because I did a lot of work to make this one look really good.

18030
29:45:45.865 --> 29:45:48.416
And it's still incredibly up to date.

18031
29:45:48.416 --> 29:45:51.059
So this is going to be in TypeScript and solidity.

18032
29:45:51.059 --> 29:45:56.805
However, we're going to have the JavaScript edition of the code base in this code from the video section.

18033
29:45:56.805 --> 29:46:04.664
If you want the most up to date version of this delta template code, you can use, you can select this up to date code, which goes to this doubt template repo.

18034
29:46:04.664 --> 29:46:11.768
I'll be updating this repo periodically with new Dao examples and new ways to create doubts or decentralized autonomous organizations.

18035
29:46:11.768 --> 29:46:15.507
Now, before we learn how to code a doubt, we should learn what the DAO is.

18036
29:46:15.507 --> 29:46:18.440
And again, I've already made a video that I've put a lot of work into.

18037
29:46:18.440 --> 29:46:23.276
So we're going to watch what a Dow is from a high level first, then we're going to learn how to code a Dow.

18038
29:46:23.276 --> 29:46:25.950
And then our last section is going to be security and auditing.

18039
29:46:25.950 --> 29:46:27.043
And we're going to finish this out.

18040
29:46:27.107 --> 29:46:30.090
So Bucklin, let's learn what a Dow is.

18041
29:46:32.107 --> 29:46:35.545
and build a Dow, let's do it.

18042
29:46:39.107 --> 29:46:42.773
autonomous organizations is a bit of an overloaded term.

18043
29:46:43.107 --> 29:46:49.623
it typically describes any group that is governed by a transparent set of rules found on a blockchain or smart contract.

18044
29:46:49.623 --> 29:46:55.899
And I say overloaded because some people say bitcoin is down because the miners can choose whether or not to upgrade their software.

18045
29:46:55.899 --> 29:47:01.624
Other people think that Dows must use transparent smart contracts, which have the rules ingrained right into them.

18046
29:47:01.624 --> 29:47:07.573
And then other people think Tao is just a buzzword, so they just slap the name relay on to any organization so that they can get some clout.

18047
29:47:07.573 --> 29:47:09.734
And this makes for sad, Patrick.

18048
29:47:09.734 --> 29:47:19.074
And it's not to be confused with the Dow, which was an implementation of a Dow back in 2016, which set the record for the largest hack at that time.

18049
29:47:19.074 --> 29:47:23.807
So there's a lot of different ways to think about and the Dow term is used in a lot of different ways.

18050
29:47:23.807 --> 29:47:29.831
But in essence, imagine if all of the users of Google were given voting power into what Google should do next.

18051
29:47:29.831 --> 29:47:34.526
And the rules of the voting was immutable, transparent, and decentralized.

18052
29:47:34.526 --> 29:47:45.615
This solves an age old problem of trust, centrality and transparency, and giving the power to the users of different protocols and applications instead of everything happening behind closed doors.

18053
29:47:45.615 --> 29:47:56.240
And this voting piece is a cornerstone of how these operate this Decentralized Governance, if you will, and it can be summarized by company or organization operated exclusively through code.

18054
29:47:56.240 --> 29:48:11.294
And to really understand all this, we're going to look under the hood of the protocol that's setting the precedent for all other doubts and compound, then once we look at compound, we'll understand what goes into building one of these and all the trade offs, all the different architectural choices mean for your group.

18055
29:48:11.294 --> 29:48:17.785
And then in my next video, I'm gonna have a full coat along tutorial for developers looking to build one of these themselves.

18056
29:48:17.785 --> 29:48:22.525
But be absolutely sure to watch the rest of this video because it's going to give you all the architectural fundamentals.

18057
29:48:22.525 --> 29:48:26.007
So you can make intelligent decisions when you get to that section.

18058
29:48:26.007 --> 29:48:28.884
And be sure that you and your Dow friends smash the like and subscribe button.

18059
29:48:28.884 --> 29:48:35.503
So we can keep giving you the best engineer first content on the planet when it comes to smart contracts.

18060
29:48:35.503 --> 29:48:36.434
Let's get into it.

18061
29:48:36.434 --> 29:48:38.499
So here we have the compound protocol.

18062
29:48:38.499 --> 29:48:44.042
It's a borrowing and lending application that allows users to borrow and lend their assets.

18063
29:48:44.107 --> 29:48:46.572
And everything about this application is built in smart contracts.

18064
29:48:46.572 --> 29:49:00.123
Now, oftentimes, they're gonna want to do a lot of new things, maybe they want to add a new token to allow borrowing and lending, maybe they're gonna want to change some of the API parameters, maybe they're gonna want to block certain coins, there's a lot of different things that they might want to do.

18065
29:49:00.123 --> 29:49:10.575
So that's where we're gonna go ahead to governance, this is where you can find a user interface for list of all the proposals and all the different ballots that came to be.

18066
29:49:10.575 --> 29:49:15.852
So here's a list of some of the governance proposals that this protocol has actually been making to improve.

18067
29:49:15.852 --> 29:49:19.143
And let's look at one of these proposals that's currently actually in process.

18068
29:49:19.143 --> 29:49:27.293
So if we click on the proposal, we actually see everything about this proposal, who voted for who voted against and the proposal history here.

18069
29:49:27.293 --> 29:49:32.654
Now, the first thing to one of these proposals is somebody has to actually create the proposal in a proposed transaction.

18070
29:49:32.654 --> 29:49:36.607
And we actually see that proposed transaction right here.

18071
29:49:36.607 --> 29:49:42.589
If we click on this, and we scroll down, we can actually see the exact parameters they used to make this proposal.

18072
29:49:42.589 --> 29:49:45.583
Let's go ahead and decode the input data.

18073
29:49:45.583 --> 29:49:48.057
And we can see this is exactly what this proposal looks like.

18074
29:49:48.057 --> 29:49:54.370
The way that they're typically divided is they have a list of addresses and the list of functions to call on those addresses.

18075
29:49:54.370 --> 29:49:57.683
And then obviously, the parameters to pass those addresses.

18076
29:49:57.683 --> 29:50:06.124
So this proposal is saying, Hey, I would like to call Support Market on this address, set reserve factor on this address.

18077
29:50:06.124 --> 29:50:08.558
Here are the parameters we're going to pass.

18078
29:50:08.558 --> 29:50:10.365
They're obviously encoded with bytes.

18079
29:50:10.365 --> 29:50:15.139
And then here's the description string of what this is doing and why we're actually doing this.

18080
29:50:15.139 --> 29:50:28.907
The reason we have to do this proposal governance process is that these contracts likely have access controls where only the owner of these contracts can actually call these Do functions, and the owner of these two contracts is likely going to be this governance style.

18081
29:50:28.907 --> 29:50:29.457
And values.

18082
29:50:29.457 --> 29:50:48.813
Zero just means that we're not going to send any eath along with these transactions, once a proposal has been created, after a short delay to becomes active, and this is when people can actually start voting on them, this delay between a proposal and an act of vote can be changed or modified, depending on your doubt, then people have some time to start voting on them.

18083
29:50:48.813 --> 29:50:57.732
And if it passes, which this one overwhelmingly did, it reaches succeeded, we click on this transaction again, and we go to the compound governance contract.

18084
29:50:57.732 --> 29:51:12.412
And we scroll down to contract, right as proxy, we can actually see the exact function that the people call to vote, namely cast by vote, cast, vote by signature and cast vote with reason.

18085
29:51:12.412 --> 29:51:16.537
We'll talk a little bit about the exact differences between these in our next video.

18086
29:51:16.537 --> 29:51:19.607
But these are the functions that they're actually calling.

18087
29:51:19.607 --> 29:51:28.848
And if you go to the compound app, and we go over to vote, this is a user interface you can actually vote through to make it easier if you're not as tech savvy.

18088
29:51:28.848 --> 29:51:31.916
So you can vote right through this app dot compound at finance.

18089
29:51:31.916 --> 29:51:34.530
Or you can just send the transaction yourself.

18090
29:51:34.530 --> 29:51:36.287
Once all those votes happen.

18091
29:51:36.287 --> 29:51:38.188
It reaches this queued stage.

18092
29:51:38.188 --> 29:51:48.693
Now what is queued mean? Well, before a proposal actually becomes active, there's a minimum delay between a proposal passing and a proposal being executed.

18093
29:51:48.693 --> 29:51:51.640
So somebody has to call this cute function.

18094
29:51:51.640 --> 29:51:54.506
And it only can be called if a vote passes.

18095
29:51:54.506 --> 29:51:59.357
And it says, OK, that postal ID has been cued, and we're going to execute it soon.

18096
29:51:59.357 --> 29:52:09.145
Now, if we go to a different proposal, like this one, for example, we can see it has been executed, we can see somebody called this executed function.

18097
29:52:09.145 --> 29:52:11.475
And they executed Proposal A detail.

18098
29:52:11.475 --> 29:52:17.551
So this is going to be a full example of the lifecycle of a proposal going through this process.

18099
29:52:17.551 --> 29:52:22.025
Now there are a couple that even failed, a whole bunch of people voted against this.

18100
29:52:22.025 --> 29:52:27.376
And if you scroll down, you can see it was created, it was active, and the majority of people voted against.

18101
29:52:27.376 --> 29:52:28.963
So that's where it stops.

18102
29:52:28.963 --> 29:52:41.571
Now oftentimes, just putting one of these proposals through isn't enough to really garner some votes for it, you generally want a forum or some type of discussion place to talk about these proposals and why you liked them or don't like them.

18103
29:52:41.571 --> 29:52:47.907
Oftentimes, a discourse is one of the main places that people are going to argue for why something is good, or why something is bad.

18104
29:52:47.907 --> 29:52:50.522
So people can vote on these changes.

18105
29:52:50.522 --> 29:53:08.445
And again, snapshot might be one of these tools that you use to figure out if your community even wants something before it even goes to vote, you can join one of these, and with your tokens actually vote on things without them being executed just to get the sentiment or like I said before, you could build your protocol in a way that snapshot actually helps you with the voting process.

18106
29:53:08.445 --> 29:53:13.589
All right, now you've seen the protocol that has been influencing all the other details on how to vote.

18107
29:53:13.589 --> 29:53:21.549
Now, you know, now that we know what a doubt looks like, let's talk about the architecture and tools that go into building one of these and additionally the trade offs that they have.

18108
29:53:21.549 --> 29:53:25.433
And the first thing to talk about here is going to be the voting mechanism.

18109
29:53:25.433 --> 29:53:33.657
Now voting in Decentralized Governance is critical to these days, because sometimes they do need to update and change to keep up with the times.

18110
29:53:33.657 --> 29:53:39.624
Not all protocols need to have a Dow, but those that do need to have a doubt need a way for the participants to engage.

18111
29:53:39.624 --> 29:53:44.210
This is one of the most important questions to ask him to tell your communities.

18112
29:53:44.210 --> 29:53:53.456
How do I participate? How do I engage in this doubt? How do I help make decisions and you'll find this is a bit of a tricky problem to solve.

18113
29:53:53.456 --> 29:53:59.844
Now, an easy approach to this problem is going to be using an ERC 20 or an NFT token as voting power.

18114
29:53:59.844 --> 29:54:07.762
Similar to what we saw with compound use the comp token to vote for different proposals seems simple enough, right? Boom, problem solved gray.

18115
29:54:07.762 --> 29:54:11.175
Now, this actually might be the right approach for certain doubts.

18116
29:54:11.175 --> 29:54:13.821
But it also runs the risk of actually being less fair.

18117
29:54:13.821 --> 29:54:23.707
Because when you tokenize the voting power, you're essentially auctioning off this voting power to whoever's got the deepest pockets, whoever has the most money gets to pick the changes.

18118
29:54:23.707 --> 29:54:34.757
So if it's only the rich people who get to vote, then it's highly likely that all the changes in the protocol are going to benefit the rich, which doesn't really seem like that great of an improvement over our current world.

18119
29:54:34.757 --> 29:54:41.419
And if T's are interesting, because they have this non fungible component, but yet, even they still run into this issue.

18120
29:54:41.419 --> 29:54:45.547
Additionally, if you buy a whole bunch of votes, you make a bad decision and then sell all your votes.

18121
29:54:45.547 --> 29:54:49.857
You as an individual don't really get punished, you just punish the group as a whole.

18122
29:54:49.857 --> 29:54:59.773
But you being malicious, you can get away with pretty scot free now again, this voting mechanism is going to be correct for some groups, but for other groups, maybe not.

18123
29:54:59.773 --> 29:55:02.428
It really just depends on what your down community setup is going to look like.

18124
29:55:02.428 --> 29:55:04.868
Now the next one we're going to talk about is skin in the game.

18125
29:55:04.868 --> 29:55:15.700
Now metallic has actually written a lot about this and I highly recommend you read his article, link in the description to see that the skin in the game method means that whenever you make a decision, your vote is recorded.

18126
29:55:15.700 --> 29:55:21.022
And if that decision leads to a bad outcome, your tokens are axed.

18127
29:55:21.107 --> 29:55:25.673
You get punished for making evil or bad decisions for your Dao and your protocol.

18128
29:55:25.673 --> 29:55:31.994
I like this mentality because even if you buy a ton of tokens and decide to be ill with it, you can be held accountable for your bad decisions.

18129
29:55:31.994 --> 29:55:44.589
Now, the hardest part about this, though, is gonna be how do we decide as a community? What is bad outcome? How do we actually punish these people? And that's easy, because the answer is, I'm not sure.

18130
29:55:44.589 --> 29:55:51.058
Now, the third method of this voting mechanism is probably one of the most interesting ones, but also the hardest ones to implement.

18131
29:55:51.107 --> 29:55:54.218
And this is proof of personhood, or participation.

18132
29:55:55.107 --> 29:56:00.710
all users of the compound protocol were given a single vote simply because they use the protocol.

18133
29:56:00.710 --> 29:56:04.520
And even if they had 1000 wallets, they use the protocol.

18134
29:56:04.520 --> 29:56:11.434
One human being means one vote, this would be amazing, and a far more fair implementation where votes couldn't actually just be bought.

18135
29:56:11.434 --> 29:56:24.477
The issue, however, comes in something known as civil resistance, how can we be sure that it's one vote equals one participant and not one participant pretending to be 1000s of different people, so they get more votes.

18136
29:56:24.477 --> 29:56:26.027
This method hasn't really been solved yet.

18137
29:56:26.027 --> 29:56:34.714
But I'm willing to bet some very clever engineer will do some amazing chainlink integration, because proof of personhood is basically just off chain data that can be delivered on chain.

18138
29:56:34.714 --> 29:56:36.916
And that's exactly where channeling shines.

18139
29:56:36.916 --> 29:56:42.503
Now, as you can see all of these methods and even more that you probably think of aren't that far fetched.

18140
29:56:42.503 --> 29:56:46.457
And we actually see these exact same methods happening in the real world.

18141
29:56:46.457 --> 29:56:53.381
Proof of personhood or proof of participation might just be the exact same as kind of the regular government voting that we see every day.

18142
29:56:53.381 --> 29:57:00.726
In the United States, at least one person gets to vote for one president, you can't go around making a whole bunch of fake people and voting for president.

18143
29:57:00.726 --> 29:57:08.503
But in companies the ERC 20 voting standard kind of applies, the more shares of a company you have maybe the more voting power you have in that company.

18144
29:57:08.503 --> 29:57:13.107
So we can draw parallels between the real world and how voting and governance is going to work in our smart contracts.

18145
29:57:13.107 --> 29:57:17.276
And in fact, you should draw parallels and look for inspiration from the web to space.

18146
29:57:17.276 --> 29:57:55.551
Now when it comes to implementation of the voting, I put them into two categories on chain voting and off chain voting on chain voting is exactly what we saw with compound, the smart contract on chain, your voter, you call some function called vote with your meta mask your ledger or whatever, send a transaction and vote, you voted Congrats, you can wear your little sticker now call that function and you send a transaction, you send a transaction, what are the transactions use that are kind of annoying and kind of costly? Oh, that's right gas, I imagine you have 10,000 people in your community and it costs $100 To vote per person, you're now costing your community $1 million.

18147
29:57:55.551 --> 29:57:57.652
Anytime you want to change anything.

18148
29:57:57.652 --> 29:58:03.125
This is obviously insane, and not very sustainable for your community pro here is that the architecture is really easy.

18149
29:58:03.125 --> 29:58:05.693
Everything's going to be transparent, everything's going to be on chain.

18150
29:58:05.693 --> 29:58:06.630
And that's really good.

18151
29:58:06.630 --> 29:58:10.460
But yes, the con is that you're going to break the bank account for a lot of people potentially.

18152
29:58:10.460 --> 29:58:15.345
Now there are a lot of variations of this to help solve some of these problems, especially the gas problem.

18153
29:58:15.345 --> 29:58:25.124
One of the ones that I'm incredibly excited for is this one called governor's seat, where they use some random sampling to do some quadratic voting to help reduce costs while increasing civil resistance.

18154
29:58:25.124 --> 29:58:28.647
You want to learn more about that one to be sure to read about it in the description.

18155
29:58:28.647 --> 29:58:30.810
So on chain voting is the simplest one here.

18156
29:58:30.810 --> 29:58:33.951
But let's talk about off chain voting.

18157
29:58:33.951 --> 29:58:49.294
To cast the vote off to decentralized context, relax, relax, you can vote off chain and still have the 100% decentralized, you can actually sign a transaction and sign a vote without actually sending to a blockchain and therefore without actually spending any gas.

18158
29:58:49.294 --> 29:58:57.360
Instead, what you can do is send that signed transaction to a decentralized database like IPFS, count up all the votes in IPFS.

18159
29:58:57.360 --> 29:59:05.039
And then when time comes, deliver the result of that data through something like an Oracle like chain link to the blockchain all in a single transaction.

18160
29:59:05.039 --> 29:59:13.660
Alternatively, what you could do is you could replay all the same transactions in a single transaction to save gas, this can reduce the voting cost by up to 99%.

18161
29:59:13.660 --> 29:59:19.203
Right now, this is an implementation and one of the most popular ways to do this is through snapshot.

18162
29:59:19.203 --> 29:59:26.840
And I'm just dying for someone to make a chain link integration because it's going to be so much safer, more secure and better and blah, blah, blah, die for it.

18163
29:59:26.840 --> 29:59:28.583
This is your call to action go build this thing.

18164
29:59:28.583 --> 29:59:29.154
This option.

18165
29:59:29.154 --> 29:59:38.365
voting mechanism obviously saves a ton of gas to the community and can be a more efficient way to store these transactions anyways, however, it needs to be implemented very carefully.

18166
29:59:38.365 --> 29:59:45.881
If you run your entire Dow through a centralized Oracle, you are essentially reintroducing a centralized intermediary and ruining the decent quality of your application.

18167
29:59:45.881 --> 29:59:46.703
So don't do that.

18168
29:59:46.703 --> 29:59:50.300
And if you made it to this point of the video, give yourself a little pat on the back.

18169
29:59:50.300 --> 29:59:51.412
You're doing fantastic.

18170
29:59:51.412 --> 29:59:51.895
Fantastic.

18171
29:59:51.895 --> 30:00:02.325
Like I said, I have a video coming out after this one it's going to show you end to end how to build one of these from scratch let's learn about some of the tools that you can use to help get you up to speed quicker.

18172
30:00:02.325 --> 30:00:09.464
Now there are a number of no code solutions that can go into building one of these dowels Tao stack Aragon.

18173
30:00:09.464 --> 30:00:17.779
Just kidding, this is Aragon, colony and Tao house are all alternatives that can actually help you with the upside of running a Dao and building a doubt.

18174
30:00:17.779 --> 30:00:24.336
However, if you want more granular control and you don't want to have to pay any the fees associated with these protocols, you might want to Do it from scratch.

18175
30:00:24.336 --> 30:00:31.395
Now let's talk about some of the more Cody solutions that you can use snapshot is one of the most popular tools out there for both getting the sentiment of a Dao.

18176
30:00:31.395 --> 30:00:39.044
And actually performing that execution, users can vote through this protocol with their actual tokens, those transaction gets stored in IPFS.

18177
30:00:39.107 --> 30:00:41.125
But none of it actually gets executed.

18178
30:00:42.107 --> 30:00:47.074
chooses to, this can be a great way to get a feel for what your Dow wants to do.

18179
30:00:47.074 --> 30:01:04.407
And Optionally, you can send the transactions and execute the votes as well highly recommend checking out Zodiac which is a suite of database tools for you to implement into your Dallas as well tally is another one of these UIs that allows people to see and actually vote and interact with these smart contracts through user interface.

18180
30:01:04.407 --> 30:01:09.526
So those of you who don't know about Gnosis safe, you absolutely should know Safe is a multi SIG wallet.

18181
30:01:09.526 --> 30:01:21.779
And the reason I put this on the list, even though it's adds kind of this centrality component is that most dowels in the beginning, are probably going to start with some type of centrality, it's much easier to be fast when you don't have 1000s of people to wait for a vote.

18182
30:01:21.779 --> 30:01:33.977
And in the beginning, any protocol is going to be centralized to some degree anyways, using a multisig, we're voting happens through only a few key members can be good in the beginning for your dials, and often emergencies as well.

18183
30:01:33.977 --> 30:01:41.422
But just keep in mind, when you add one of these, you are adding this level of centrality, and then of course opens up and contracts we love opens up and contracts.

18184
30:01:41.422 --> 30:01:44.522
These are the contracts that we're going to be basing our Dao code along.

18185
30:01:44.522 --> 30:01:46.345
Alright, so that's all the tools.

18186
30:01:46.345 --> 30:01:47.488
That's the architecture.

18187
30:01:47.488 --> 30:02:14.679
One more thing before I let you go legality, the future of Dows is interesting for all these reasons we just talked about, but especially on a legal front, does it make sense for a doubt to live by the same regulation as another company? Why would you even force it down to do something, you'd have to enforce them to all vote a certain way if the government tells you to, it's a little gray, it's hard to nail down who to even keep accountable for these days and the United States at least you can actually form your own Dow and have it legally recognized in the state of Wyoming.

18188
30:02:14.679 --> 30:02:16.172
This is something I want to do.

18189
30:02:16.172 --> 30:02:18.435
So we'll just have to see what happens there.

18190
30:02:18.435 --> 30:02:28.478
Oh, at this point, you have been injected with all the Dow knowledge you need to succeed and thrive with this new amazing technology and these new amazing concepts.

18191
30:02:28.478 --> 30:02:29.819
And I found them kill baby.

18192
30:02:29.819 --> 30:02:32.446
All right, well, you heard him it's time to build.

18193
30:02:32.446 --> 30:02:43.865
Like we said, All the code is going to be located in less than 17 Here, let's jump in.

18194
30:02:44.108 --> 30:02:52.371
In this video, we're going to show you how to build your own doubt inspired by compound now this is going to be 100% on chain voting and on chain governance.

18195
30:02:52.371 --> 30:02:59.017
We're going to show you the easiest way to spin up an NFT or ERC 20 voting type down all using solidity and hardhat.

18196
30:02:59.017 --> 30:03:07.091
Now if you haven't watched my last video going over the architecture of Dows, what goes into one of these be absolutely sure to watch that video first and then come to this video.

18197
30:03:07.091 --> 30:03:15.026
Because that video explains all the philosophy behind what we're doing here we're going to be using opens up and contracts and a hard hat framework to build this all in solidity.

18198
30:03:15.026 --> 30:03:21.108
If you want to see a brand new or Pythonic version of doing this, check the link in the description because we did a video over at the chainlink hackathon recently.

18199
30:03:21.108 --> 30:03:28.253
And additionally, additionally, we know that because we're doing this 100% on chain gas fees are going to be expensive.

18200
30:03:28.253 --> 30:03:34.822
So I'm really looking forward to somebody doing a chain link plus IPFS plus snapshot integration so that we can do all this off chain.

18201
30:03:34.822 --> 30:03:37.694
And once that exists, you already know I'm gonna make a tutorial on that.

18202
30:03:37.694 --> 30:03:43.941
And if you like this style of content, be sure to smash that like button, subscribe and leave a comment in the comment section to let me know what you want to see.

18203
30:03:43.941 --> 30:03:47.624
Next, let me know how you want to supercharge your smart contract developer experience.

18204
30:03:47.624 --> 30:03:48.590
So let's jump in.

18205
30:03:48.590 --> 30:04:00.567
Right, so here's what we're going to be building, we're gonna have a very basic smart contract here, right, it's called box and all it can do is store a value and then retrieve a value.

18206
30:04:00.567 --> 30:04:02.534
But the thing is, its ownable.

18207
30:04:02.534 --> 30:04:09.642
And only the owner of this contract can call the store function and guess who the owner is going to be the owner is going to be the doubt.

18208
30:04:09.642 --> 30:04:14.534
So only through a process of governance, can anyone store a different function here.

18209
30:04:14.534 --> 30:04:24.723
And once we're done, we're going to go through the entire process of proposing voting queueing and then executing a transaction in a Dao to update our Bach contract.

18210
30:04:24.723 --> 30:04:29.824
And that's one of the beautiful things about these these Dao setups is that they're completely modular, right.

18211
30:04:29.824 --> 30:04:41.157
And so when I go through the whole process, I'll do Hardhead tests here, which my tests right now are set up to just do everything, we're going to see every single step that this Dow is going to take.

18212
30:04:41.157 --> 30:04:44.311
So we see box starting value is going to be zero.

18213
30:04:44.311 --> 30:04:47.337
And then all of this stuff is going to the governance process.

18214
30:04:47.337 --> 30:04:48.353
These are just some some notes.

18215
30:04:48.353 --> 30:04:51.012
Basically people are voting, queueing and executing.

18216
30:04:51.012 --> 30:04:57.684
And then at the end, we chained the value of the box contract through a voting process.

18217
30:04:57.684 --> 30:04:59.944
And that's exactly what we're gonna show you how to do today.

18218
30:04:59.944 --> 30:05:08.841
Now remember all the code for what we're going to be doing here is in my doubt template GitHub repo so if you ever get lost, feel free to refer back to this to get started.

18219
30:05:08.841 --> 30:05:21.358
And additionally, if you want to see the Pythonic version of this, feel free to go back to the downmix The main thing is though that all the contracts are going to be the same no matter what brownie hard hat, dab tools, foundry, it doesn't matter.

18220
30:05:21.358 --> 30:05:24.369
So the first part of this section is gonna be exactly the same.

18221
30:05:24.369 --> 30:05:26.631
And here's our agenda here.

18222
30:05:26.631 --> 30:05:28.726
First, we're gonna write the smart contract.

18223
30:05:28.726 --> 30:05:33.950
So if you're not familiar with Hardhead, who cares, we're gonna be doing the smart contracts first, then we are going to write deployment scripts.

18224
30:05:33.950 --> 30:05:36.822
And this is where your hard hat knowledge is going to come into play.

18225
30:05:36.822 --> 30:05:41.049
We're going to be writing our deployment scripts in TypeScript here, because TypeScript is phenomenal.

18226
30:05:41.049 --> 30:05:45.955
If you're unfamiliar with TypeScript, I challenge you to rewrite this in JavaScript and make a JavaScript version.

18227
30:05:45.955 --> 30:05:52.089
And then finally, we're going to write some scripts to interact with our governance with our deployed contracts.

18228
30:05:52.089 --> 30:06:03.659
Now, a quick note, this isn't how I originally built this, I didn't just read smart contracts, write deployment scripts, write the scripts, and then the tests and boom, I was done, I had a back and forth between tests, smart contracts, deploy scripts, etc.

18229
30:06:03.659 --> 30:06:06.962
If you're thinking, Oh, my goodness, that's so easy for him to go through this.

18230
30:06:06.962 --> 30:06:07.591
So seamlessly.

18231
30:06:07.591 --> 30:06:10.552
When I originally wrote this code, it was a lot of back and forth.

18232
30:06:10.552 --> 30:06:14.076
And that's how you should be developing, you're going to be moving between tests and smart contracts and stuff.

18233
30:06:14.108 --> 30:06:18.108
Additionally, in this tutorial, we are going to show you some sick Hardhead skills.

18234
30:06:18.108 --> 30:06:24.337
So you are not only gonna learn how to build a Dow, but you're gonna learn some really advanced Hardhead skills.

18235
30:06:24.337 --> 30:06:25.730
So let's jump in.

18236
30:06:25.730 --> 30:06:26.877
Let's do this.

18237
30:06:26.877 --> 30:06:29.465
So the code editor I'm using is Visual Studio code.

18238
30:06:29.465 --> 30:06:32.457
So make sure you have a code editor up and ready to go.

18239
30:06:32.457 --> 30:06:35.556
And you'll need a couple of prerequisites here.

18240
30:06:35.556 --> 30:06:40.575
Again, the prerequisites are in the GitHub repository, we're going to need Git, no J, s.

18241
30:06:40.575 --> 30:06:48.462
And yarn, if you want to just clone this repo and follow the instructions here to get started, you absolutely 100% can and then you don't even need to build this from scratch.

18242
30:06:48.462 --> 30:06:50.338
But we're going to want to learn to build this from scratch.

18243
30:06:50.338 --> 30:06:52.548
So let's just start git dash dash version.

18244
30:06:52.548 --> 30:06:55.937
Great, we have Git no dash dash version.

18245
30:06:56.108 --> 30:06:58.708
Great, we have node, and then yarn dash dash version.

18246
30:06:59.108 --> 30:07:00.338
we have yarn, we can get started.

18247
30:07:01.108 --> 30:07:04.882
we're going to be installing here for packages is going to be a dev dependency.

18248
30:07:04.882 --> 30:07:11.308
So the first thing we need to do is do yarn, add dash dash Dev, hard hat, if you'd haven't already.

18249
30:07:11.308 --> 30:07:16.822
And now in our folder, we're gonna have node modules package dot JSON readme and a lock.

18250
30:07:16.822 --> 30:07:21.318
Of course, now that we have that we can run yarn RDAP, we're gonna get the hard hat CLI up.

18251
30:07:21.318 --> 30:07:27.862
And we're going to have all this stuff in here, we're just going to create an empty hardhat dot config dot j s, and we're going to turn it to TypeScript.

18252
30:07:27.862 --> 30:07:30.704
The advanced sample TypeScript project has a bunch of stuff that I don't like.

18253
30:07:30.704 --> 30:07:32.536
So we're just going to create an empty hardhead.

18254
30:07:32.536 --> 30:07:32.857
config.

18255
30:07:32.857 --> 30:07:32.964
js.

18256
30:07:32.964 --> 30:07:35.318
And perfect, we've got a little hard hat.

18257
30:07:35.318 --> 30:07:35.739
config.

18258
30:07:35.739 --> 30:07:35.879
js.

18259
30:07:35.879 --> 30:07:39.894
Now let's go ahead and create a folder, or contracts folder.

18260
30:07:39.894 --> 30:07:42.548
And this is where we're going to add all of our contracts.

18261
30:07:42.548 --> 30:07:50.353
So the first thing contract that we're going to need is the contracts we want to have govern, which in our case is going to be box dot soul.

18262
30:07:50.353 --> 30:07:56.308
Now, I am actually just going to copy paste my box, that soul here, because it's not particularly interesting.

18263
30:07:56.308 --> 30:07:58.727
But you could really code whatever you want here.

18264
30:07:58.727 --> 30:08:05.786
So feel free to pause the video, copy paste from my GitHub repo, create your own governance contract that you want to play with, or do whatever you want here.

18265
30:08:05.786 --> 30:08:13.574
But for us, we just have a store function, and retrieve function, and an event, and then a private value that we're going to be storing and retrieving.

18266
30:08:13.574 --> 30:08:14.507
And that's it.

18267
30:08:14.507 --> 30:08:16.697
So of course, we want to fix this.

18268
30:08:16.697 --> 30:08:20.295
We're importing from openzeppelin contracts opens up is amazing.

18269
30:08:20.295 --> 30:08:25.974
We're gonna want to add this we'll do yarn, add dash dash Dev, at opens up on contracts.

18270
30:08:25.974 --> 30:08:28.633
And that should get rid of the box.

18271
30:08:28.633 --> 30:08:29.565
That's all.

18272
30:08:29.565 --> 30:08:31.005
let's reopen box.

18273
30:08:31.005 --> 30:08:33.755
And boom, looks like we did a detour to that perfect.

18274
30:08:33.755 --> 30:08:38.429
And for extensions, I'm using the solidity, the one Blonko, slit extension.

18275
30:08:38.429 --> 30:08:40.676
And that's what we get this wonderful linting things here.

18276
30:08:40.676 --> 30:08:40.986
Great.

18277
30:08:40.986 --> 30:08:47.908
So now we want to check to see if this compiles if using remix, you can compile with remix hard hat, you're gonna see how we compile here.

18278
30:08:47.908 --> 30:08:52.060
Or if you're using you know, Browning, we just want to see if this compiles correctly.

18279
30:08:52.108 --> 30:08:54.452
So run yarn had a hard hit Compile.

18280
30:08:56.108 --> 30:08:59.686
some compilation errors, because we need to update this, let's use these 8.

18281
30:08:59.686 --> 30:09:01.791
8 of solidity we'll try to compile again.

18282
30:09:01.791 --> 30:09:04.768
And perfect looks like we're compiling successfully.

18283
30:09:04.768 --> 30:09:08.041
Look here, we do indeed have our contract in here.

18284
30:09:08.041 --> 30:09:10.371
Okay, perfect, easy part out of the way.

18285
30:09:10.371 --> 30:09:10.792
Already.

18286
30:09:10.792 --> 30:09:11.739
That was so quick.

18287
30:09:11.739 --> 30:09:13.415
Now let's start creating the next part.

18288
30:09:13.415 --> 30:09:14.883
Let's create the governance part.

18289
30:09:14.883 --> 30:09:21.832
So what we're going to be working with to build this governance platform is we're gonna be building it off of the ERC.

18290
30:09:21.832 --> 30:09:24.353
20 standard, so you're gonna get an ERC 20 token.

18291
30:09:24.353 --> 30:09:27.008
And that's going to be the token that you get to vote.

18292
30:09:27.108 --> 30:09:31.418
So let's create a new file called governance token.

18293
30:09:32.108 --> 30:09:34.006
all governance token dot Sol.

18294
30:09:36.108 --> 30:09:37.531
for the token that we use to actually vote.

18295
30:09:38.108 --> 30:09:40.076
to create a normal ERC 20 token.

18296
30:09:42.108 --> 30:09:45.398
it to make it governance a bowl and you'll understand what I mean in a second.

18297
30:09:45.398 --> 30:09:50.237
So let's go ahead and make this spdx license identifier.

18298
30:09:50.237 --> 30:09:56.701
It's going to be MIT pragma solidity we'll do zero point 8.

18299
30:09:56.701 --> 30:09:56.785
8.

18300
30:09:56.785 --> 30:10:09.624
And then we'll do contract governance token, and then we'll say is ERC 20 I'm just gonna go ahead and import openzeppelin Because open Zeppelin has a package where basically has everything we need for an ERC 20 token.

18301
30:10:09.624 --> 30:10:26.954
So we're gonna say import at open Zeppelin slash contracts slash token slash ERC 20x We can go to their github openzeppelin contracts token, your C 20 And we'll do ERC 20 Dotto, we'll do this for now.

18302
30:10:27.108 --> 30:10:29.002
token, use your C 20 ditzel.

18303
30:10:31.108 --> 30:10:32.901
don't worry about that yet.

18304
30:10:35.108 --> 30:10:44.264
Public Storage Max supply, it's the best practice, but it's fine, we'll give this a max supply this much was going to be 1-234-567-8910 12345678.

18305
30:10:44.264 --> 30:10:49.026
So it's gonna be 1 million, we're gonna do 1 million of these tokens.

18306
30:10:49.026 --> 30:10:53.885
And then we're gonna create the constructor construct or your C 20.

18307
30:10:53.885 --> 30:10:59.358
Give it governance token as a name, and then our symbol is going to be GT.

18308
30:10:59.358 --> 30:11:07.463
And for those who who don't know, when you inherit another contract in your constructor, you can use that inherited contracts constructor as well.

18309
30:11:07.463 --> 30:11:14.829
In fact, I think you have to So governance token G team, and then we'll even call one of these ERC 20 functions called mint.

18310
30:11:14.829 --> 30:11:22.179
And we'll mint to message dot sender, so whoever deploys this ERC 20 contract will just meant them everything, the whole Max supply.

18311
30:11:22.179 --> 30:11:26.076
Now normally, if this was a normal ERC 20 token, you'd be all done.

18312
30:11:26.076 --> 30:11:28.358
But this isn't a normal ERC 20 token.

18313
30:11:28.358 --> 30:11:39.314
See, when we do votes, we need to make sure that it's fair, imagine this for a second, someone knows a hot proposal is coming up, they want to vote on.

18314
30:11:39.314 --> 30:11:42.591
So they just buy a ton of tokens.

18315
30:11:42.591 --> 30:11:46.058
And then they dump it after the votes over.

18316
30:11:46.058 --> 30:11:47.616
We want to avoid this.

18317
30:11:47.616 --> 30:11:51.608
We want to avoid people just buying and selling tokens to get in on governance.

18318
30:11:51.608 --> 30:12:03.219
So what we do is we actually create a snapshot of how many tokens people have at a certain block snapshot of tokens people have at a certain block.

18319
30:12:03.219 --> 30:12:17.420
And we want to make sure once a proposal goes through, we actually pick a snapshot from the past that we want to use this kind of incentivizes people to not just jump in when it's a proposal and jump out because once a proposal hits, it uses a block snapshot from the past.

18320
30:12:17.420 --> 30:12:20.233
So we're actually going to need to change this a little bit.

18321
30:12:20.233 --> 30:12:32.753
We're gonna change this from ERC 20 to an ERC 20 votes, and we can actually see this in open Zeppelin and the extensions slash ERC 20 votes that soul contract.

18322
30:12:32.753 --> 30:12:39.483
If we go back to IRS to their GitHub, we can see ERC 20 votes, they also have a snapshot, which is pretty similar.

18323
30:12:39.483 --> 30:12:42.954
And some of the main functions are it has these checkpoints.

18324
30:12:42.954 --> 30:12:51.562
So these checkpoints are basically Hey, what is the snapshot? There's a number of checkpoints, you can also delegate your tokens to different people.

18325
30:12:51.562 --> 30:12:53.688
So maybe you're not going to be available to actually vote.

18326
30:12:53.688 --> 30:12:56.298
So you say, Hey, I'm gonna give my tokens to somebody else.

18327
30:12:56.298 --> 30:13:06.737
You can get how many votes somebody has passed, votes get passed, or was apply it has all these functions that make this token, much better as a voting tool.

18328
30:13:06.737 --> 30:13:08.285
Right makes it much much better.

18329
30:13:08.285 --> 30:13:19.160
So we're gonna say our contracts governance token is ERC 20 votes and we just have to add additional constructor, this ERC 20 permit, I'm sorry, I kind of copied pasted that.

18330
30:13:19.160 --> 30:13:21.123
So ERC 20 permit governance token.

18331
30:13:21.123 --> 30:13:34.737
And right now we have a governance token that is a little bit more capable of doing actual voting, right, because as the snapshot has this delegating functionality, it has these checkpoints, it's going to be much better for doing votes in a fair way.

18332
30:13:34.737 --> 30:13:38.785
The only thing that we need to do though, is we need to add some overrides, right.

18333
30:13:38.785 --> 30:13:46.980
And we're just gonna say the functions below our overrides required by solidity.

18334
30:13:47.108 --> 30:13:48.970
And this part is a little bit boring.

18335
30:13:50.108 --> 30:13:53.780
copy paste it, feel free to copy paste it from my GitHub.

18336
30:13:54.108 --> 30:14:04.665
what we're doing is anytime we do this after token transfer, and the time we transfer a token, we want to make sure that we call the after token transfer of the ERC 20 votes.

18337
30:14:04.665 --> 30:14:14.733
And the reason that we do this is because we want to make sure that the snapshots are updated, right, we want to make sure that we know how many people have how many tokens at each block.

18338
30:14:14.733 --> 30:14:16.042
Same thing with the mint.

18339
30:14:16.042 --> 30:14:23.853
Same thing with burning, we want to make sure we always know how many tokens people have at different blocks or can be at different checkpoints I should say.

18340
30:14:23.853 --> 30:14:27.462
And that's the most important bit at which checkpoint Are you going to use for your token voting.

18341
30:14:27.462 --> 30:14:27.849
So cool.

18342
30:14:27.849 --> 30:14:34.853
Feel free to copy that, again, from a GitHub or if you want you can even just try the rest of the tutorial without this and see how you fare.

18343
30:14:34.853 --> 30:14:35.348
But cool.

18344
30:14:35.348 --> 30:14:40.145
So now we have a governance token and ERC 20 token that we can use for governance.

18345
30:14:40.145 --> 30:14:41.877
So let's try to compile it.

18346
30:14:41.877 --> 30:14:43.569
Yarn Hardhead compile.

18347
30:14:43.569 --> 30:14:47.088
Great, looks like things are compiling successfully.

18348
30:14:47.088 --> 30:14:47.568
Perfect.

18349
30:14:47.568 --> 30:14:49.822
So our governance token looks good.

18350
30:14:49.822 --> 30:14:51.028
Our box looks good.

18351
30:14:51.028 --> 30:14:55.293
Let's actually now start creating our governance contracts.

18352
30:14:55.293 --> 30:15:02.822
Now we're actually going to make a folder called governance standard because this is going to be the standard governance model.

18353
30:15:02.822 --> 30:15:09.653
This is going to be this on chain ERC 20 and I plan on updating this in the future with no a governance off chain or something right.

18354
30:15:09.653 --> 30:15:26.414
So for now, we're calling a governance standard because this is the quote unquote standard way to do governance, but in the air, we're going to need two contracts actually, we're gonna need a government work, contract that soul and then we're also going to need a time lock that soul and this will make sense in a second.

18355
30:15:26.414 --> 30:15:40.226
So our gov contract dot soul, this is going to be the contract that has all the voting code, all the voting logic that our governance token is going to use, the Time Lock is actually going to be an additional contract that is actually the owner.

18356
30:15:40.226 --> 30:15:48.447
So the Time Lock and the governor contract are sort of one in the same, but the difference is the Time Lock is actually going to be the owner of the box contract.

18357
30:15:48.447 --> 30:16:01.237
And this is important because whenever we propose or cue something to a proposal to go through, we want to wait, right? We want to wait for a new vote to be executed.

18358
30:16:01.237 --> 30:16:06.730
Now, why do we want to do that, let's say some proposal goes through, that's bad.

18359
30:16:06.730 --> 30:16:08.582
So like, let's say we have a box contract.

18360
30:16:08.582 --> 30:16:22.377
And then a proposal goes through that says, Everyone who holds the governance token has to pay five tokens, or something like that, right, or whatever, or who knows, right? Maybe that's something that you don't really want to be a part of.

18361
30:16:22.377 --> 30:16:33.300
So all of these governance contracts give time to give time to users to get out, if they don't like a governance update.

18362
30:16:33.300 --> 30:16:36.659
So we always want to have some type of timeline.

18363
30:16:36.659 --> 30:16:43.338
So once a proposal passes, it won't go in effect right away, it'll have to wait some duration, and then go in effect.

18364
30:16:43.338 --> 30:16:45.030
So that's what the timeline is gonna be for.

18365
30:16:45.108 --> 30:16:47.866
Governor contract is going to have all of our actual code.

18366
30:16:48.108 --> 30:16:50.031
we can cheat a little bit.

18367
30:16:50.108 --> 30:16:52.271
Actually, we can cheat a lot of a little bit.

18368
30:16:53.108 --> 30:16:57.866
has a thing called the contracts wizard, and there'll be a link to this in the description as well.

18369
30:16:57.866 --> 30:17:04.832
And this opens up when wizard is a way for us to write really basic boilerplate code right in there wizard.

18370
30:17:04.832 --> 30:17:11.646
So right, so if we go to the wizard contract here, we can see we can make an ERC 20 and NFT 1155.

18371
30:17:11.646 --> 30:17:14.308
And then finally, this gov thing here.

18372
30:17:14.308 --> 30:17:18.108
So we can call it give it a name, we're going to call Rs.

18373
30:17:18.108 --> 30:17:25.967
Gov contract, during explain what all this means, and give it a voting delay, which is the delay since a proposal is created until voting starts.

18374
30:17:25.967 --> 30:17:31.023
So once you create a proposal, you gotta wait a little bit, the voting period, how long votes should go for.

18375
30:17:31.023 --> 30:17:37.792
And the reason that this audio is important is because they actually do votes, voting period in terms of blocks.

18376
30:17:37.792 --> 30:17:44.002
So it's an anti pattern to actually do timed based things in smart contracts, it's much better to do block based things.

18377
30:17:44.002 --> 30:17:48.921
So we're saying one week, but it's that's going to be you know, if if the average block time is 13.

18378
30:17:48.921 --> 30:17:55.862
2 seconds, we're gonna figure out the weak proposal threshold is going to be the minimum number of votes and account must have to create a proposal.

18379
30:17:55.862 --> 30:18:04.996
So maybe you only want people who have a lot of your governance token to make votes quorum percentage, it's what percentage of people need to vote it all.

18380
30:18:04.996 --> 30:18:12.072
So we're saying 4% of all token holders need to vote or we could say you know, exactly 100 tokens need to vote whatever we want to do here.

18381
30:18:12.072 --> 30:18:17.769
We also have some updatable settings we have Bravo compatible Bravo is the compound type contract.

18382
30:18:17.769 --> 30:18:21.233
So if you want to make it integratable, with compound you can do that.

18383
30:18:21.233 --> 30:18:36.950
Votes comp like or ERC 20 votes, we're working with this ERC 20 votes, we always want to do a time lock, we're gonna do the open Zeplin implementation of a time lock, you could also do a compound implementation, we aren't going to do upgradability here, however, I have a number of fantastic resources on how to actually do upgradability.

18384
30:18:36.950 --> 30:18:40.624
And if we did want to do upgradability, it adds all this other stuff.

18385
30:18:40.624 --> 30:18:47.600
We're not going to do that for now because it makes it so much longer video, and then you can add some stuff like this, but Oh, so that's pretty much it.

18386
30:18:47.600 --> 30:18:56.193
And I know this feels like you're cheating, or we're just going to copy this whole thing, right? Copy all that stuff that we put in copy to clipboard, and we're going to paste it in.

18387
30:18:56.193 --> 30:18:58.759
Don't worry, I'm gonna explain what's going on now.

18388
30:18:58.759 --> 30:19:00.537
So we have our government contract.

18389
30:19:00.537 --> 30:19:06.797
And this is governor Governor setting Governor counting simple Governor votes, Governor votes, quorum Franco, all this stuff.

18390
30:19:06.797 --> 30:19:15.781
All these are just implementations to make it easier to be governor, Governor counting simple is a way of counting votes, Governor votes is a way of integrating with that year's 20 contract.

18391
30:19:15.781 --> 30:19:19.459
Quorum fraction is is a way to understand quorum time lock.

18392
30:19:19.459 --> 30:19:20.759
Obviously, it's time lock.

18393
30:19:20.759 --> 30:19:21.701
This is going to be the base contract.

18394
30:19:21.701 --> 30:19:22.522
That's gonna be some settings.

18395
30:19:22.522 --> 30:19:24.797
And we're gonna talk about this in a minute.

18396
30:19:24.797 --> 30:19:27.367
But let's go over what are the functions here so we have voting delay.

18397
30:19:27.367 --> 30:19:39.042
This is exactly the voting delay, which we're gonna do superdad voting gelei, we're gonna get from this governor settings contract that we're going to set in a minute your voting period that we're going to set in our gov settings, which is this one right here.

18398
30:19:39.042 --> 30:19:54.997
And again, if you want to like look at all these contracts, you absolutely can, right, if we go to contracts, governance, extensions, we have all these in here, right? So if we look at governance settings, we can see it has voting delay voting period, proposal threshold, and those are right in its constructor.

18399
30:19:54.997 --> 30:19:56.942
And that's exactly what we're setting, right.

18400
30:19:56.942 --> 30:20:02.996
We're setting voting delay voting period, and then the proposal threshold, and then we're also going to make this customizable as well.

18401
30:20:02.996 --> 30:20:07.092
And the rest of these that's exactly what doing calling the quorum from the super get votes.

18402
30:20:07.092 --> 30:20:14.327
And then again, the super is those inherited contracts, get the state and then we have some interesting functions we have proposed.

18403
30:20:14.327 --> 30:20:23.818
This is what we're actually going to do to propose new governance we have proposal threshold, and then we have execute which executes a cued proposal.

18404
30:20:23.818 --> 30:20:33.399
To cancel, we have executor which we're is going to be who can actually execute stuff, we're actually going to make it anybody and then supports interface, you can basically ignore.

18405
30:20:33.399 --> 30:20:35.866
But let's make this a little bit more customizable.

18406
30:20:35.866 --> 30:20:43.383
So we have Iboats token, this is going to be our governance token, the timeline controller timeline, this is going to be the timeline controller that we make an amended.

18407
30:20:43.383 --> 30:20:50.061
And again, we need this because we don't want to let any proposal just go through once it passes, we want to give people time to get out.

18408
30:20:50.109 --> 30:20:56.544
But let's add the UN 256 voting delay as a parameter here.

18409
30:20:57.109 --> 30:21:05.496
for voting delay, we're going to do this, we're going to set it as our governor settings, we're going to do a UNT 256 voting period.

18410
30:21:05.496 --> 30:21:08.012
And we're going to add that right here.

18411
30:21:08.012 --> 30:21:12.305
And this means 45,000 blocks is approximately one week.

18412
30:21:12.305 --> 30:21:19.505
And that's what that means we're going to leave proposal threshold to zero because we don't really want to change that we want to let anyone make a proposal.

18413
30:21:19.505 --> 30:21:27.418
And then we're just going to add you in 256 underscore core percentage to this.

18414
30:21:27.418 --> 30:21:30.966
So Governor votes quorum percentage corporate senators.

18415
30:21:30.966 --> 30:21:36.728
So now this is completely customizable, for voting, delay voting period, core percentage for whatever you want it to be.

18416
30:21:36.728 --> 30:21:38.299
And believe it or not, that's it.

18417
30:21:38.299 --> 30:21:40.501
Now you have a simple governance contract.

18418
30:21:40.501 --> 30:21:43.945
Thank you, openzeppelin, for doing 99% of the work for us.

18419
30:21:43.945 --> 30:21:44.797
So that's it.

18420
30:21:44.797 --> 30:21:52.823
So this contract, it's going to have all these functions that we're going to go over for proposing for executing and for queuing, different proposals.

18421
30:21:52.823 --> 30:21:53.299
Right.

18422
30:21:53.299 --> 30:21:56.870
Now we got to make a time lock contract here.

18423
30:21:57.109 --> 30:21:59.902
And this contract is actually going to be a lot easier.

18424
30:22:00.109 --> 30:22:01.334
we're just going to do it from scratch.

18425
30:22:02.109 --> 30:22:15.592
license I then to fire, my team, do pragma solidity and let's just do this your point a point zero, and then we're going to import from open Zeppelin, a contract called the Time Lock controller.

18426
30:22:15.592 --> 30:22:30.092
So if we look at the governance here, if this time lock controller dot soul contract, and this has all this functionality in here for creating roles, who can actually propose who can execute, who's the Time Lock admin, but it also has these execute stuff in here as well.

18427
30:22:30.092 --> 30:22:40.156
It's gonna work in tandem with our governance contract, right? This is the contract that says that makes sure our governance contract doesn't just push stuff through willy nilly.

18428
30:22:40.156 --> 30:22:50.816
So we're gonna say we're gonna first import that import at open Zeppelin slash contracts slash governance slash Time Lock controller.

18429
30:22:50.816 --> 30:22:58.092
That's all and then we're gonna say contract, I'm lock is Time Lock controller like that.

18430
30:22:58.092 --> 30:23:01.833
And we'll create our little constructor here, and truck door.

18431
30:23:01.833 --> 30:23:15.859
And this because this takes a couple different parameters, we're gonna take a un 256 Min delay, which are min delay, Min delay is going to be along you have to wait before executing.

18432
30:23:15.859 --> 30:23:27.859
So this is Hey, once proposal passes, great, we gotta wait this minimum delay, then we're going to do a list of proposers, an address array memory of proposers.

18433
30:23:27.859 --> 30:23:36.053
And then the proposers is the list of addresses that can propose for us, we're just gonna say everyone's gonna be able to propose.

18434
30:23:36.053 --> 30:23:48.833
And then last, an address array, memory of executors who can execute everything, and we're just gonna say executors who can execute when a probe posle passes.

18435
30:23:48.833 --> 30:23:58.240
And again, we're just gonna say everybody, and the reason we need these is because we need to pass these to our time lock controller, this constructor is expecting three parameters.

18436
30:23:58.240 --> 30:24:04.918
So we'll just do Tama controller, delay, pro posers, X EQ, tours.

18437
30:24:04.918 --> 30:24:06.695
And that's it.

18438
30:24:06.695 --> 30:24:13.637
So this is going to be what owns everything, it's the timelog, that's going to be owning our box.

18439
30:24:13.637 --> 30:24:18.399
It's not the government contract, the government contracts is where we're going to send our votes and stuff.

18440
30:24:18.399 --> 30:24:27.464
But at the time lock that actually everything needs to flow through in order for governance to actually happen, because we want to make sure we have this min delay, we go through the right process and everything.

18441
30:24:27.464 --> 30:24:29.209
And believe it or not, that's everything.

18442
30:24:29.209 --> 30:24:35.895
That is all the code you're going to need as far as the solidity goes, to create a governance to create a Dao.

18443
30:24:35.895 --> 30:24:40.421
So even do your own hard hat compile, make sure everything's compiled.

18444
30:24:40.421 --> 30:24:43.660
And tada, we've done it, you've done most of the hard work.

18445
30:24:43.660 --> 30:24:49.176
Now we're going to flip over to actually writing the scripts to deploy and to interact with everything using TypeScript here.

18446
30:24:49.176 --> 30:24:55.156
At this point, if you're like, Oh, I already learned everything that I wanted, I don't use hard hat, I use some other tools.

18447
30:24:55.156 --> 30:24:58.573
This is where I challenge you to go out and I challenge you to try something else.

18448
30:24:58.573 --> 30:25:05.956
Now if you've reached this point, I just want to give you a huge congrats, because you have taken the steps to build your own doubt build your own governance model.

18449
30:25:05.956 --> 30:25:07.649
That's all the solidity that you really need.

18450
30:25:07.649 --> 30:25:10.207
You can take that deploy that and you're good to go.

18451
30:25:10.207 --> 30:25:20.600
But of course, we know that there's more to being a smart contract developer than just the solidity you got to do the tooling right to let's go ahead and we'll jump into writing those TypeScript scripts to actually do this.

18452
30:25:20.600 --> 30:25:25.601
And again, if you want to see a Python version of this, go check out a link up description to see the Pythonic version of this.

18453
30:25:25.601 --> 30:25:30.930
And of course, don't forget to smash that like button, subscribe, leave a comment on how you're doing so far.

18454
30:25:30.930 --> 30:25:32.990
And, of course, give yourself a pat in the back.

18455
30:25:32.990 --> 30:25:33.328
Great job.

18456
30:25:33.328 --> 30:25:35.632
You're doing amazing getting this far.

18457
30:25:35.632 --> 30:25:37.917
Congrats, let's jump in.

18458
30:25:38.109 --> 30:25:45.190
Alright, so we're back here, we've written our smart contracts already, check wasn't that easy, right, this was way easier than I thought it would be.

18459
30:25:45.190 --> 30:25:49.329
Now we're just gonna write our deployment scripts, and then we're gonna write our scripts to interact with them.

18460
30:25:49.329 --> 30:25:53.315
Again, my full repo also has tests, but we're just gonna write some scripts.

18461
30:25:53.315 --> 30:25:55.486
And then feel free to check out the tests yourself.

18462
30:25:55.486 --> 30:26:02.050
So let's write those deployment scripts to we're actually going to be using a package for deployment called Hard Hat deploy.

18463
30:26:02.050 --> 30:26:06.458
It is absolutely phenomenal for hard hat for making your deployments much, much easier.

18464
30:26:06.458 --> 30:26:10.142
We're gonna scroll down to installation, and we're actually gonna go ahead and install this.

18465
30:26:10.142 --> 30:26:11.990
So typically, you could install it like this.

18466
30:26:11.990 --> 30:26:18.033
Well, we're gonna use yarn, but we're gonna do kind of the more safe way which looks a little wonky, but I'm explaining it right.

18467
30:26:18.033 --> 30:26:23.551
So instead of NPM install, we're gonna do yarn, add dash dash Dev, and then this whole thing right here.

18468
30:26:23.551 --> 30:26:27.322
So we're gonna do yarn, add dash dash Dev, and then just paste that in here.

18469
30:26:27.322 --> 30:26:33.930
So this is gonna be at nomic, labs slash hard hat, hyphen ethers at NPM, colon, hard hat, deploy ethers.

18470
30:26:33.930 --> 30:26:40.928
And what this is doing is we're basically saying hard hat deploy ethers is going to be overriding this hardened ether thing.

18471
30:26:40.928 --> 30:26:42.560
And we're also going to add ethers as well.

18472
30:26:42.560 --> 30:26:47.886
And then once we add this in, check our package json, we can see we have hard hats.

18473
30:26:47.886 --> 30:26:52.600
We have hard hat ethers, which is being overwritten by this hard hat, deploy ethers.

18474
30:26:52.600 --> 30:26:57.515
And then additionally, we're going to want to add on a deploy.

18475
30:26:57.515 --> 30:27:02.246
So do yarn, add dash dash Dev, hard hat hyphen, deploy.

18476
30:27:02.246 --> 30:27:15.246
And what this is going to allow us to do is instead of having to write scripts, and do all this stuff, that kind of makes it hard to save your deployments and everything, we're going to just create a deploy folder, where we're going to add all of our deploy scripts in here.

18477
30:27:15.246 --> 30:27:17.004
So I absolutely love this package.

18478
30:27:17.109 --> 30:27:19.159
It's makes deployment really, really easy.

18479
30:27:20.109 --> 30:27:30.950
gonna create new file, it's going to do oh one, we're gonna go step by step deploying everything, we're gonna call this deploy, govern or token dot TypeScript, that's gonna be the first thing we're going to do.

18480
30:27:30.950 --> 30:27:33.798
Also, we're gonna change this to TypeScript.

18481
30:27:33.798 --> 30:27:35.798
Tada, we now have TypeScript.

18482
30:27:35.798 --> 30:27:36.073
Yay.

18483
30:27:36.073 --> 30:27:45.625
Now the one thing that is kind of nice about doing kind of that advanced TypeScript thing at the heart had kind of gives it the beginning, is you don't have to install all the TypeScript stuff yourself.

18484
30:27:45.625 --> 30:27:46.270
But we do.

18485
30:27:46.270 --> 30:28:02.977
So we're going to do yarn, add TypeScript type chain, vs node at type chain slash ethers, V five, this is a lot of stuff, don't worry type chain slash hard hat, at type slash Chai, at type slash node.

18486
30:28:02.977 --> 30:28:10.028
And then we'll make sure this is all Dev, dash dash Dev, I know there's a lot of stuff.

18487
30:28:10.109 --> 30:28:12.066
There's all this stuff to make it TypeScript D.

18488
30:28:12.109 --> 30:28:14.625
You can absolutely do this in JavaScript if you want.

18489
30:28:15.109 --> 30:28:17.092
have to do JS files and ignore the typing.

18490
30:28:18.109 --> 30:28:18.990
do whatever you want to do.

18491
30:28:18.990 --> 30:28:19.464
Alright, cool.

18492
30:28:20.109 --> 30:28:20.719
okay here.

18493
30:28:20.719 --> 30:28:23.295
Let's go into our governor token here.

18494
30:28:24.109 --> 30:28:25.528
create a deploy script.

18495
30:28:28.109 --> 30:28:31.448
a little demo boilerplate code for you actually do your deploy script.

18496
30:28:31.448 --> 30:28:34.484
So feel free to reference here if you lost or confused.

18497
30:28:34.484 --> 30:28:43.994
So what we're going to do is we're going to import the hard hat runtime environments, from our enhanced slash types.

18498
30:28:44.109 --> 30:28:45.609
And you'll see why we need this in just a second.

18499
30:28:46.109 --> 30:28:49.557
also going to import deploy function from Hardhead.

18500
30:28:50.109 --> 30:28:50.677
slash types.

18501
30:28:53.109 --> 30:29:03.046
create a deploy function with pothead deploy, we're going to create our function, we're going to call it const ploy governance token, it's going to be of type deploy function.

18502
30:29:03.046 --> 30:29:07.234
So in order for these to actually work, we just create a whole bunch of deploy functions that we run with heart hub.

18503
30:29:07.234 --> 30:29:09.091
And this is going to be an async function.

18504
30:29:09.091 --> 30:29:15.633
That's going to take the hard hat runtime environment as an input parameter that we're going to call HRV.

18505
30:29:15.633 --> 30:29:27.172
So when we run hard hat deploy, which you'll see in a second, we're actually passing our fake hard hat chain that gets spun up in the background for us, right, we can even do like console dot log Hello.

18506
30:29:27.172 --> 30:29:29.949
And if we do yarn, hard hat deploy.

18507
30:29:30.109 --> 30:29:38.484
Actually, before we even do that, if we do yarn, hard hat dash dash help, you'll see, since we imported hard hat deploy up excuse me, we need to add this to our config.

18508
30:29:38.484 --> 30:29:53.496
First in our config, we're gonna need to do top imports, hard hat deploy top Roscoe need to import at nomic labs slash hard hat ethers, we're also going to need to import at type chain slash hard hat.

18509
30:29:53.496 --> 30:29:55.334
And then we'll leave it there for now.

18510
30:29:55.334 --> 30:29:58.673
We'll have to import more stuff in a second but literally like that.

18511
30:29:58.673 --> 30:30:03.296
Now, if we do yarn hard hat that should help we should see a new task in here.

18512
30:30:03.296 --> 30:30:09.270
And we do we actually see a ton of new tasks right? Filled with tasks, check clean compile, console deployed.

18513
30:30:09.270 --> 30:30:18.709
And this is the new task that we have that actually deploys all of our contracts, anything that's in this deploy folder, our head will go ahead and run right now in our deploy folder.

18514
30:30:18.709 --> 30:30:21.338
All we have is this console dot log Hello.

18515
30:30:21.338 --> 30:30:25.383
So if we run yarn, or hit Deploy, we should See, it just prints out hello.

18516
30:30:25.383 --> 30:30:35.859
It'll spin up a new blockchain background, while all of our projects and everything, do some type type chain stuff, and it says you'll see this a lot deploy script dot func is not a function.

18517
30:30:35.859 --> 30:30:37.696
And that's because we actually need to export this now.

18518
30:30:37.696 --> 30:30:42.697
So we'll do export default, deploy governance token.

18519
30:30:42.697 --> 30:30:44.854
That's why it's getting mad at us.

18520
30:30:44.854 --> 30:30:46.496
Now we'll run yarn had her hard hat deploy.

18521
30:30:46.496 --> 30:30:47.979
And boom, we say hello.

18522
30:30:47.979 --> 30:30:51.318
So this is how we can actually deploy all of our scripts.

18523
30:30:51.318 --> 30:30:56.828
And we can run everything that's in this deploy folder in one go, which is really helpful.

18524
30:30:56.828 --> 30:30:59.625
So let's go ahead and deploy our governance token first.

18525
30:30:59.625 --> 30:31:01.309
And this will get a lot faster as we go along.

18526
30:31:01.309 --> 30:31:02.309
Don't worry, so delete this.

18527
30:31:02.309 --> 30:31:04.859
And first we're gonna do it, we're gonna say const.

18528
30:31:04.859 --> 30:31:06.879
We need an account to deploy this first.

18529
30:31:06.879 --> 30:31:12.093
So we'll say const, get named accounts, deployments, and network equals HRA.

18530
30:31:12.093 --> 30:31:14.397
And this is going to be a little bit more advanced.

18531
30:31:14.397 --> 30:31:15.041
This is hard stuff.

18532
30:31:15.109 --> 30:31:22.832
This is this is the slick stuff we're doing here, we're getting these from our hard hat runtime environment, which is being updated from hard hat deploy.

18533
30:31:22.832 --> 30:31:29.675
So get named accounts is way for us to actually import accounts from our hard hat config, right into our deploy script.

18534
30:31:29.675 --> 30:31:31.041
So we're gonna go to our hard hat config.

18535
30:31:31.109 --> 30:31:34.530
And we're gonna create a new config that's a little bit nicer than this.

18536
30:31:34.530 --> 30:31:37.014
So first, we need to import the hard hat config type.

18537
30:31:37.109 --> 30:31:41.729
Since we're using type scripts, we're going to import hard hat user config from hard hat slash config.

18538
30:31:41.729 --> 30:31:43.859
And we're going to create a config.

18539
30:31:43.859 --> 30:31:45.609
So I'm just gonna comment this out.

18540
30:31:45.609 --> 30:31:48.109
For now we're gonna say const.

18541
30:31:48.109 --> 30:31:50.419
Config, it's gonna be type hard hat user config.

18542
30:31:50.419 --> 30:31:53.530
Equals, and this is where we can add a whole bunch of stuff.

18543
30:31:53.530 --> 30:31:59.463
So let's say our default network is going to be hard hat, which is kind of our local fake blockchain.

18544
30:31:59.463 --> 30:32:03.836
And then we're gonna say solidity is zero, point 8.

18545
30:32:03.836 --> 30:32:09.736
8, then we're going to do this thing called named accounts, which is what we came here in the first place for.

18546
30:32:09.736 --> 30:32:12.270
So this is just a list of accounts that we can use.

18547
30:32:12.270 --> 30:32:20.855
So for accounts, we'll say Deployer, this will be the name of our account that does all the deploying, and we'll just say, default, is going to be zero.

18548
30:32:20.855 --> 30:32:27.061
So whenever we run an any chain, our zero with account is going to be named Deployer.

18549
30:32:27.061 --> 30:32:30.690
What other thing that we need to do is we need to add our networks here.

18550
30:32:30.690 --> 30:32:36.058
And there's actually two networks that we're going to have, we're gonna have a hard hat with a chain ID of 313337.

18551
30:32:36.058 --> 30:32:41.566
And we're also going to have local hosts of chain ID 31337.

18552
30:32:41.566 --> 30:32:45.537
Now, these look like they're pretty much the same.

18553
30:32:45.537 --> 30:32:48.259
And I understand that, but they're not.

18554
30:32:48.259 --> 30:32:51.575
And you'll understand why in a second, but we need them for now.

18555
30:32:51.575 --> 30:32:58.281
Just to tell Hardhead hey, here are the development fake blockchains that we're working with? Okay.

18556
30:32:58.281 --> 30:33:00.486
So this is kind of our basic setup here.

18557
30:33:00.486 --> 30:33:00.731
Okay.

18558
30:33:00.731 --> 30:33:02.205
I know that was kind of a lot.

18559
30:33:02.205 --> 30:33:07.424
But now that we have get named accounts, we have network, right? Because anytime you deploy something, it's going to be on a network.

18560
30:33:07.424 --> 30:33:16.334
And when we deploy something, if you run yarn, hard hat node, what hard hat is going to do, it's going to spin up a fake blockchain in the background.

18561
30:33:16.334 --> 30:33:17.942
Oh, it's gonna be mad at me for a second.

18562
30:33:17.942 --> 30:33:22.798
Oh, I forgot to add export, default config, right, we need to export the config.

18563
30:33:22.798 --> 30:33:26.367
Hell hard hat that we're using this version of sling.

18564
30:33:26.367 --> 30:33:36.680
Now if you're on a hard hat node, you'll see why we added these two networks up here hard hat on localhost, we actually get spun up our own fake blockchain, we get accounts, we get private keys, we get everything right.

18565
30:33:36.680 --> 30:33:44.464
This is a hard hat Node running in this terminal, right? When you run hard hat node, oddly enough, it's actually the local host network.

18566
30:33:44.464 --> 30:33:45.989
It's not the Hard Hat Network.

18567
30:33:45.989 --> 30:33:49.171
When using hard hat deploy, it's gonna be the local host network.

18568
30:33:49.171 --> 30:33:53.918
Or excuse me, when you use hard hat node, it's actually going to be the local host network, not the Hard Hat Network.

18569
30:33:53.918 --> 30:33:56.585
The Hard Hat Network is what it uses when it runs tests.

18570
30:33:56.585 --> 30:34:02.770
localhost is when you run this hard hat node and have this kind of fake blockchain running in your terminal.

18571
30:34:02.770 --> 30:34:04.397
So that's what the localhost is.

18572
30:34:04.397 --> 30:34:04.651
Cool.

18573
30:34:04.651 --> 30:34:06.109
Well, Ctrl C will kill that.

18574
30:34:06.109 --> 30:34:06.823
Alright, great.

18575
30:34:06.823 --> 30:34:08.471
So now stuff is actually working.

18576
30:34:08.471 --> 30:34:13.849
So get them to count deployments is going to be a whole bunch of stuff from deployments, you'll see in a second and network is the network that we're on.

18577
30:34:13.849 --> 30:34:14.571
Okay, great.

18578
30:34:14.571 --> 30:34:22.502
So now we're gonna grab const deploy log equals deployments, this deployments object comes with this deploy function.

18579
30:34:22.502 --> 30:34:26.801
And this log function, this log function is kind of nice for doing logging.

18580
30:34:26.801 --> 30:34:32.966
And then we're gonna grab const, employer equals await, get named accounts.

18581
30:34:32.966 --> 30:34:42.109
So we're grabbing from our config, this deployer account, right? And it's always going to be the zero with index.

18582
30:34:42.109 --> 30:34:46.047
So it's defaulted to the zero index for whatever accounts that were with.

18583
30:34:46.047 --> 30:34:46.323
Great.

18584
30:34:46.323 --> 30:34:51.573
So we now have an account to deploy stuff from we have a deploy function, we have all this stuff, we're looking pretty good.

18585
30:34:51.573 --> 30:34:51.840
Cool.

18586
30:34:51.840 --> 30:35:08.928
So sometimes they'll do like a log, flying governance token, dot, and we'll say const governance token equals await, deploy, and then the name of the contract which is governance token, comma, and these are all the parameters that we're going to pass to it.

18587
30:35:08.928 --> 30:35:13.681
So we're gonna say from deployer doesn't take any arguments.

18588
30:35:13.681 --> 30:35:15.839
So args is just going to be blank.

18589
30:35:15.839 --> 30:35:19.864
We're going to do log to be true so we'll get some logs printed out for us.

18590
30:35:19.864 --> 30:35:24.669
And then I have this wait confirmations attribute set in GitHub repo.

18591
30:35:24.669 --> 30:35:26.448
For now we're going to ignore this.

18592
30:35:26.448 --> 30:35:30.834
But if you follow along with my repo and you want to auto verify stuff, this is something that you're going to want to use.

18593
30:35:30.834 --> 30:35:38.062
So you need to wait some amount of blocks for this contract to be deployed before you can actually go ahead and verify it, right.

18594
30:35:38.110 --> 30:35:43.332
Because if you're using ether scan or something, you're gonna need to wait like, yeah, you're gonna need to wait a few minutes.

18595
30:35:43.332 --> 30:35:47.110
So check out my GitHub repo for this wait confirmation stuff, I'm just going to ignore it for now.

18596
30:35:47.110 --> 30:35:52.585
Additionally, in my GitHub repo, I have this verify function, where we check to see if it's on a development chain.

18597
30:35:52.585 --> 30:35:54.176
And if it is, we don't verify it.

18598
30:35:54.176 --> 30:35:56.771
But if it's on like ether scan or something, we go ahead and verify it.

18599
30:35:56.771 --> 30:36:01.594
So be sure to check the GitHub repo to learn how to just auto verify without having to do anything.

18600
30:36:01.594 --> 30:36:03.526
Now if we just do this part.

18601
30:36:03.526 --> 30:36:13.974
And then we can even do Floyd, governance token to address governance token dot address.

18602
30:36:13.974 --> 30:36:17.710
And we'll do yarn hardhat.

18603
30:36:17.710 --> 30:36:18.643
Deploy.

18604
30:36:18.643 --> 30:36:19.309
Boom.

18605
30:36:19.309 --> 30:36:26.641
So we spin up on a fake Hard Hat Network, we do deploy governance token to address boom.

18606
30:36:26.641 --> 30:36:30.937
And this is how we deploy a fake has deployed this to our own little network here.

18607
30:36:30.937 --> 30:36:31.350
Great.

18608
30:36:31.350 --> 30:36:34.932
So this tokens been deployed, we have our deploy script.

18609
30:36:34.932 --> 30:36:36.286
Yeah, zoom out a little bit.

18610
30:36:36.286 --> 30:36:37.490
Let's zoom out a little bit.

18611
30:36:37.490 --> 30:36:37.680
Great.

18612
30:36:37.680 --> 30:36:38.410
That's the whole thing.

18613
30:36:38.410 --> 30:36:41.919
Now we're going to add one more thing here, we're going to add something called delegate function.

18614
30:36:41.919 --> 30:36:45.416
Now, when you actually deploy this contract, nobody has voting power yet.

18615
30:36:45.416 --> 30:36:51.531
The reason is, because nobody has the token delegated to them, we want to delegate this token to our Deployer.

18616
30:36:51.531 --> 30:36:53.538
Right, so we're going to call this delegate function.

18617
30:36:53.538 --> 30:36:56.519
So we're going to create a new function called const.

18618
30:36:56.519 --> 30:36:57.256
delegate.

18619
30:36:57.256 --> 30:37:00.452
And it's going to be an async function.

18620
30:37:00.452 --> 30:37:18.538
It's going to take a governance token address as a string, it's going to take a delegated account, also as a string, so we're racing and say, who do we want? Delegate? Who do we want to be able to vote with our token? Okay, so we have created this async function called delegate.

18621
30:37:18.538 --> 30:37:32.860
And how do we do this? Well, we say Kant's over its token equals token equals await ethers dot get contract at.

18622
30:37:33.110 --> 30:37:36.811
And probably for two ethers for us from hardheaded Otto did that, which is great.

18623
30:37:36.811 --> 30:37:37.512
That's what we want.

18624
30:37:37.512 --> 30:37:38.571
Once it's like ethers.

18625
30:37:38.571 --> 30:37:39.571
Thank you vs.

18626
30:37:39.571 --> 30:37:40.340
Code away.

18627
30:37:40.340 --> 30:37:42.493
Ether is like a contract at.

18628
30:37:42.493 --> 30:37:50.041
And we're going to say we want our governance token, which is at contract, governance token address.

18629
30:37:50.041 --> 30:37:54.899
And I have auto format unsaved, which is why it keeps formatting like that.

18630
30:37:54.899 --> 30:37:56.667
This should be delegated account.

18631
30:37:56.667 --> 30:37:57.301
Okay, cool.

18632
30:37:57.301 --> 30:38:00.033
We have our governance token contract.

18633
30:38:00.033 --> 30:38:09.360
Now we can do const TX or transaction equals await, governance token dot delegate delegate this delegated account here.

18634
30:38:09.360 --> 30:38:16.028
And then we can do a wait, we'll wait for this transaction to be confirmed by one block.

18635
30:38:16.110 --> 30:38:35.855
And then we'll just do console dot log checkpoints, wait, governance token dot num checkpoints delegated account? So what is this doing? So we have this num checkpoints function which we can go check to see on that ERC 20 token what this is actually doing.

18636
30:38:35.855 --> 30:38:40.206
But basically what this whole thing is doing, we have this delegate function that we haven't used it.

18637
30:38:40.206 --> 30:38:44.710
But when somebody calls us, we're saying, Hey, you can use my vote, take my votes and vote however you want.

18638
30:38:44.710 --> 30:38:46.536
And that's what these this delegate does.

18639
30:38:46.536 --> 30:39:03.998
Now, if we look at this token, here, see 20 extensions, your see 20 votes, we look at number checkpoints, we can see how many checkpoints that account actually has reason this is so important is because once again, like I was saying when people do a vote, they do it based off some checkpoints.

18640
30:39:03.998 --> 30:39:16.760
And anytime you transfer a token, or delegate a token, basically call this function move voting power, which happens with the back end, which writes the checkpoint and says, Hey, at checkpoint x, here's what everybody has for voting powers.

18641
30:39:16.760 --> 30:39:18.710
And that's what these are so important.

18642
30:39:18.710 --> 30:39:28.601
And I know I said before, it's every block, but it's actually just every checkpoint, whenever these checkpoints are updated, that's gonna be a lot cheaper on gas than if we just did every single block, right? That'd be kind of insane.

18643
30:39:28.601 --> 30:39:34.125
So the checkpoint for this governance checkpoint, and we'll see what that actually is in just a second.

18644
30:39:34.125 --> 30:39:40.667
So we'll even do a wait, delegate, governance token dot address, and Deployer.

18645
30:39:40.667 --> 30:39:43.880
And we'll say log delegated.

18646
30:39:44.110 --> 30:39:47.531
Now, when we're on this function, John Howard hit Deploy.

18647
30:39:47.531 --> 30:39:54.703
We have one checkpoint, which makes sense, right? Because this was just deployed, it was just delegated.

18648
30:39:54.703 --> 30:39:56.528
This address has one checkpoint.

18649
30:39:56.528 --> 30:39:57.073
That's it.

18650
30:39:57.073 --> 30:40:02.077
And the reason I checked for this is because if you see zero checkpoints here, it means you haven't delegated correctly.

18651
30:40:02.077 --> 30:40:03.824
So be sure to check for checkpoints.

18652
30:40:03.824 --> 30:40:04.490
But that's it.

18653
30:40:04.490 --> 30:40:07.420
We have our deployed governance token contract done.

18654
30:40:07.420 --> 30:40:07.833
Bravo.

18655
30:40:07.833 --> 30:40:09.901
Let's move on to the next one.

18656
30:40:10.110 --> 30:40:15.860
So what do we want to do after we deploy our governance token? Well, let's deploy that timelock or timelock.

18657
30:40:15.860 --> 30:40:15.985
ts.

18658
30:40:15.985 --> 30:40:23.306
And we're going to copy a lot of this stuff over from here, so I'm actually going to Oh, and then sometimes you'll get some weird linting errors here.

18659
30:40:23.306 --> 30:40:24.781
I just do det TS ignore there.

18660
30:40:24.781 --> 30:40:26.660
And sometimes you'll get it here too.

18661
30:40:26.660 --> 30:40:28.710
Oh, actually, we don't even need network.

18662
30:40:28.710 --> 30:40:29.300
Okay, cool.

18663
30:40:29.300 --> 30:40:31.204
Yeah, you don't even need network loops.

18664
30:40:31.204 --> 30:40:33.425
Sometimes we get some weird linting errors.

18665
30:40:33.425 --> 30:40:38.516
Sometimes Vyas code has a hard time telling understanding like this, this overwrite thing that we did.

18666
30:40:38.516 --> 30:40:46.943
So just run that TS ignore if if it gives you some, some engineers, anyways, yes, we have this Oh, to deploy time lock here, we're going to deploy our time lock contract.

18667
30:40:46.943 --> 30:40:54.110
And we're going to borrow a lot of the things that we did from here, so I'm just going to come back here are actually going to copy paste these two top bits.

18668
30:40:54.110 --> 30:41:07.494
Again, we're gonna do const deploy timelock is going to be a deploy function, it's going to be an async function that takes the heart at runtime environment as a parameter, and cool, nearly exactly the same sorry.

18669
30:41:07.494 --> 30:41:14.868
And then we're going to grab these first three lines, or first four lines, I guess, pesos, then we're going to be getting those exact same things here.

18670
30:41:14.868 --> 30:41:17.804
And we're going to be doing nearly the exact same thing.

18671
30:41:17.804 --> 30:41:20.007
So we'll do log deploying.

18672
30:41:20.007 --> 30:41:24.730
Time Lock, point time lock, will do const.

18673
30:41:24.730 --> 30:41:28.456
Mark equals await, deploy, unlock.

18674
30:41:28.456 --> 30:41:32.360
We'll add some parameters in here, we'll say from Deployer.

18675
30:41:32.360 --> 30:41:36.860
Now does this take some arguments? It absolutely does.

18676
30:41:36.860 --> 30:41:41.600
Right, we can take a look at the Time Lock, Min delay proposers and executors.

18677
30:41:41.600 --> 30:41:46.980
So what do we want our min delay to be? Well, this is a value that we're actually going to use a lot.

18678
30:41:46.980 --> 30:41:51.479
So what I usually like to do is I create a new file called helper.

18679
30:41:51.479 --> 30:41:53.202
hardhats config.

18680
30:41:53.202 --> 30:41:53.417
ts.

18681
30:41:53.417 --> 30:41:58.265
And right at the top, I'll say Export const min.

18682
30:41:58.265 --> 30:42:02.375
Delay, and I'll have this delay be whatever I want it to be.

18683
30:42:02.375 --> 30:42:09.057
So let's just go ahead and do 3600, which is going to be approximately an hour, right, you gotta wait this many seconds, I think that's an hour.

18684
30:42:09.110 --> 30:42:10.581
Without the old calculator.

18685
30:42:12.110 --> 30:42:12.569
minutes.

18686
30:42:12.569 --> 30:42:12.962
Great.

18687
30:42:12.962 --> 30:42:14.601
That's gonna be one hour.

18688
30:42:16.110 --> 30:42:17.717
And we're gonna go ahead and import that here.

18689
30:42:18.110 --> 30:42:19.713
import, Min delay.

18690
30:42:23.110 --> 30:42:27.395
From helper from, you know, it's down directory, helper Hardhead config.

18691
30:42:27.395 --> 30:42:29.490
And that's gonna be our first argument here.

18692
30:42:29.490 --> 30:42:31.475
Our second argument is going to be a list of proposals.

18693
30:42:31.475 --> 30:42:33.125
Now we're going to leave it blank for now.

18694
30:42:33.125 --> 30:42:38.485
And also the list of executors we're also going to leave it blank for now, we're going to update this in a minute.

18695
30:42:38.485 --> 30:42:41.985
And you'll see why once we get there, we'll do log true.

18696
30:42:42.110 --> 30:42:46.310
This also has a wait confirmations thing in my GitHub, but we're going to skip that for now.

18697
30:42:46.310 --> 30:42:49.421
It also has an auto verify, we're also gonna skip that for now.

18698
30:42:49.421 --> 30:42:53.205
Then we just need to export default, deploy timelock.

18699
30:42:53.205 --> 30:42:55.376
And boom, we should be good.

18700
30:42:55.376 --> 30:42:58.509
So let's try to run this on hard hat deploying.

18701
30:42:58.509 --> 30:43:04.054
So now this should run both of these great deployed governance token deployed timelock.

18702
30:43:04.110 --> 30:43:08.946
Perfect, we are cruising now what we want to deploy that governance contract now.

18703
30:43:08.946 --> 30:43:10.036
So let's go ahead and do that.

18704
30:43:10.110 --> 30:43:13.906
We're gonna do Oh, three LOI.

18705
30:43:13.906 --> 30:43:16.346
Gov, nor contract.

18706
30:43:16.346 --> 30:43:16.617
ts.

18707
30:43:18.110 --> 30:43:21.546
guessed it, this is going to look pretty similar to what we just did.

18708
30:43:21.546 --> 30:43:21.873
Right.

18709
30:43:21.873 --> 30:43:26.143
So in our deployed time lock, let's go ahead and just grab those top two things.

18710
30:43:26.143 --> 30:43:27.538
We'll paste it in here.

18711
30:43:27.538 --> 30:43:41.041
We'll do const deploy, govern or contract, there's going to be an apply function, it's going to be an async function, taking a part at runtime environment, save and close this for now.

18712
30:43:41.041 --> 30:43:48.633
And we can even go back and grab these three lines from our Oh, to deploy time lock, paste that right in here, because we're going to need to get the exact same things.

18713
30:43:48.633 --> 30:43:54.297
And additionally, for this, we're going to need to get the governance token and the Time Lock contract.

18714
30:43:54.297 --> 30:43:58.710
So we'll do const governance, token equals await.

18715
30:43:58.710 --> 30:44:06.843
Get which actually, we have this, this get function that comes from these deployments, which literally just goes out and gets these deployments.

18716
30:44:06.843 --> 30:44:09.176
So we'll say get Gover Nance token.

18717
30:44:09.176 --> 30:44:13.610
And then we also need to get the Time Lock.

18718
30:44:13.610 --> 30:44:16.060
So await, get m lock.

18719
30:44:16.060 --> 30:44:22.025
And we need these to pass as parameters for our governor contract.

18720
30:44:22.110 --> 30:44:34.062
Right? Because if we open up the governor contract that soul, we look at the constructor, it takes the token, the Time Lock voting, delay voting period and quorum percentage as input parameters.

18721
30:44:34.062 --> 30:44:38.919
So we'll do a quick log deploying go burn nor ello.

18722
30:44:39.110 --> 30:44:50.837
And they will do const govern nor contract equals await, deploy, and will deploy the govern nor contract I'm not sure if I'm spelling this right always, but that's fine.

18723
30:44:50.837 --> 30:44:52.899
And we'll do the parameters once again.

18724
30:44:52.899 --> 30:44:54.643
So it's gonna be from Deployer.

18725
30:44:54.643 --> 30:44:57.243
args are going to be this list of args.

18726
30:44:57.243 --> 30:45:02.802
What's the first thing that it needs? It needs the token first and the Time Lock.

18727
30:45:02.802 --> 30:45:08.610
So we'll do governance token dot address, then it's going to need the Time Lock that address.

18728
30:45:08.610 --> 30:45:13.765
And it's going to need a vote on voting delay voting period and quorum percentage.

18729
30:45:13.765 --> 30:45:17.355
So these are also values that we're going to make a lot.

18730
30:45:17.355 --> 30:45:21.903
So let's open back up that helper Hardhead config, and let's create those as well.

18731
30:45:21.903 --> 30:45:24.962
So we'll say Export const just voting period.

18732
30:45:24.962 --> 30:45:34.946
And we'll say this is going to be five blocks, we'll do export const voting delay, this is going to be just one block, which I know is really quick.

18733
30:45:34.946 --> 30:45:45.938
And then we're gonna need export const Orem percentage, which we're gonna say is four 4% of voters always need to be voting.

18734
30:45:45.938 --> 30:45:50.047
Excuse me, 4% of voters need to have voted for a vote to pass.

18735
30:45:50.047 --> 30:45:50.422
Great.

18736
30:45:50.422 --> 30:45:54.860
So we're going to do voting delay voting percentage quorum percentage.

18737
30:45:54.860 --> 30:46:07.287
So we'll import those so to import voting delay voting period, or quorum percentage from helper Hardhead config.

18738
30:46:07.287 --> 30:46:17.872
And now that we have those delay period percentage, we can just do kind of a voting delay, voting period, farm percentage, and then we'll say log is true.

18739
30:46:17.872 --> 30:46:19.499
Again, this one as well.

18740
30:46:19.499 --> 30:46:24.028
It has a wait confirmations and auto verification that we're going to totally ignore.

18741
30:46:24.028 --> 30:46:27.523
And then we'll export default, blood Governor contract.

18742
30:46:27.523 --> 30:46:29.178
Oh, Carrie, we're getting spicy.

18743
30:46:29.178 --> 30:46:30.899
Let's just make sure this works.

18744
30:46:30.899 --> 30:46:31.951
Yarn hardhat deploy.

18745
30:46:31.951 --> 30:46:34.618
We should see three contracts deployed here.

18746
30:46:34.618 --> 30:46:40.056
I think to compile governance, token deployed timelock deployed governance contract deployed.

18747
30:46:40.110 --> 30:46:40.776
Let's go.

18748
30:46:40.776 --> 30:46:41.442
Alright.

18749
30:46:41.442 --> 30:46:43.442
Now, we're not done yet.

18750
30:46:45.110 --> 30:46:45.755
deploy scripts to do.

18751
30:46:47.110 --> 30:46:48.360
governance contracts.

18752
30:46:48.360 --> 30:46:48.672
Okay.

18753
30:46:48.672 --> 30:46:50.672
And this one's really important.

18754
30:46:51.110 --> 30:46:55.720
right now our time lock contract has no proposers and no executors.

18755
30:46:55.720 --> 30:46:56.126
Right.

18756
30:46:56.126 --> 30:47:07.364
So we want to change that we want to only allow for the proposer to be the governor, the governor contract should be the only one that proposes things the Time Lock, and then anybody should be able to execute the way that this works.

18757
30:47:07.364 --> 30:47:13.479
We say the governance contract proposes something to the Time Lock once it's in the Time Lock, and it waits that period.

18758
30:47:13.479 --> 30:47:15.694
Anybody can go ahead and execute it.

18759
30:47:15.694 --> 30:47:18.610
So Governor contract everybody votes and everything.

18760
30:47:18.610 --> 30:47:23.847
Once a vote passes, Governor says hey, Time Lock, can you please propose this? Tom like goes yeah, sure.

18761
30:47:23.847 --> 30:47:28.610
But we got to wait, this minimum delay, once it's been in delay happens, anybody can execute it.

18762
30:47:28.610 --> 30:47:34.177
Now this would be really cool to do an integration with chain link keepers, by the way, for the chain link keepers to automatically execute.

18763
30:47:34.177 --> 30:47:36.007
And I should build the next anyways.

18764
30:47:36.110 --> 30:47:44.566
So we have to set this up so that these work as such, so we're gonna create a new deploy thing called Oh, four, setup, governance contracts dot TypeScript.

18765
30:47:44.566 --> 30:47:48.143
And this is going to be the code that does all the setting up.

18766
30:47:48.143 --> 30:47:51.663
And this is gonna look really similar once again, to all of our other deploy functions.

18767
30:47:51.663 --> 30:48:11.432
So we'll go head back from oh three, we'll paste these two top ones in here, of course, we're gonna do const setup contracts, is it going to be a deploy function, going to be an async function, it's going to take HRV art at runtime environment as parameters, and then that's the winner right there.

18768
30:48:11.432 --> 30:48:11.754
Cool.

18769
30:48:11.754 --> 30:48:20.432
And we're gonna be grabbing those same three from the top, as you can see, that gets a little bit easier, because it's kind of repetitive, right, we're gonna grab that bit right here.

18770
30:48:20.432 --> 30:48:23.125
And now we're gonna get those contracts so that we can interact with them.

18771
30:48:23.125 --> 30:48:37.179
And this is another reason why a hard hat deploy is so nice, because we can just do const timelock equals await ethers that get in the next let's go ahead and import ethers from hard hat imports.

18772
30:48:37.179 --> 30:48:43.296
Ethers from Red Hat will even drop a little TS ignore here.

18773
30:48:43.296 --> 30:48:46.519
Ethers dot get contract, we want that time lock contract.

18774
30:48:46.519 --> 30:48:48.940
And we say we want to attach it to the Deployer.

18775
30:48:48.940 --> 30:49:02.144
So whenever we call a function on it, it'll be the deployer calling that function and we want to do const Governor equals await ethers dot get contract, Governor contract, this is all going to be attached to the Deployer.

18776
30:49:02.144 --> 30:49:02.557
Right.

18777
30:49:02.557 --> 30:49:05.432
Now, we're gonna do log setting up roles.

18778
30:49:05.432 --> 30:49:16.710
And we're going to set up the roles right, again, we're setting it up so that only the governor can send things to this time lock, because the Time Lock is going to be you can almost think of the Time Lock as like the president.

18779
30:49:16.710 --> 30:49:16.928
Right.

18780
30:49:16.928 --> 30:49:23.060
So everything goes to the Senate, the House representative, which is the governor and then the President just says yeah, sure.

18781
30:49:23.110 --> 30:49:36.363
We just got to wait this minimum delay, but the President will be the one to actually execute everything which I'm not actually sure that's how it really works in in politics, but for for now, that's that's where we're protecting the president or the time like is the only one that can actually do anything here.

18782
30:49:36.363 --> 30:49:48.348
So the way that this works is we're actually going to get the byte codes of different roles, right? So if you look at these time locks here, so we'll do ones up on contracts.

18783
30:49:48.348 --> 30:49:50.749
And we go to the governance here.

18784
30:49:50.749 --> 30:49:57.300
We go to Tama controller has these things called proposal roll, executor roll time, like admin, etc.

18785
30:49:57.300 --> 30:50:00.347
And these are just hashes of these strings here.

18786
30:50:00.347 --> 30:50:08.381
But these are these are bytes 32 saying, Hey, anybody who has this this byte 32 is a proposer, anybody who has this byte 32 is an executor.

18787
30:50:08.381 --> 30:50:10.837
Anybody has this byte there and soon as time like admin, etc.

18788
30:50:10.837 --> 30:50:15.410
Right now, our Deployer account is the time like admin, and that's bad.

18789
30:50:15.410 --> 30:50:22.077
We don't want that we don't want anyone to be a time like admin, right? We don't want anyone to have power over this time lock.

18790
30:50:22.077 --> 30:50:24.437
We don't want any centralized force here.

18791
30:50:24.437 --> 30:50:28.077
So what we're going to do is we're going to const we're going to get those roles.

18792
30:50:28.077 --> 30:50:34.432
proposer, proposer role, it's going to be a weight, unlock that row pole sir role.

18793
30:50:34.432 --> 30:50:49.626
And if you're familiar with multi call, this would be a great time to do multi call and copy paste that whole line x EQ tour role at x EQ tour roll, we're gonna copy this whole line admin role.

18794
30:50:49.626 --> 30:50:52.730
And this is going to be on lock admin role.

18795
30:50:52.730 --> 30:50:58.376
So these are these three roles that we need to fix, right, and let's go ahead and fix them.

18796
30:50:58.376 --> 30:51:09.834
So the first thing we're gonna need to do is we're gonna need to do const row poser dx equals await Time Lock dot grant roll, propose a roll to our governor dot address.

18797
30:51:09.834 --> 30:51:16.547
So saying, okay, Governor, you're the only one who can actually do anything once you tell the Time Lock to do something.

18798
30:51:16.547 --> 30:51:18.860
We'll wait for the Time Lock period to be over.

18799
30:51:18.860 --> 30:51:20.010
And then we'll be done.

18800
30:51:20.110 --> 30:51:25.077
And then we'll just do an await posit TX dot wait one block just to make sure.

18801
30:51:25.077 --> 30:51:52.011
Now we're gonna do the const executor, TX equals await Time Lock dot grant roll executor role to nobody, we're going to execute this we're gonna give this to nobody, we're going to say address zero which is going to be something that we're going to want to add if we go to our helper or head config will say Export const address zero equals zero by you can just copy paste this if you want.

18802
30:51:52.011 --> 30:51:54.541
There's a couple other ways you can do this with ethers as well.

18803
30:51:54.541 --> 30:51:55.925
We're just gonna do like this.

18804
30:51:55.925 --> 30:52:04.772
I like having my conflict this and then we just import it say import at zero from dot dot slash helper Harnett config.

18805
30:52:04.772 --> 30:52:08.691
So we're giving the executor role to nobody, which means everybody.

18806
30:52:08.691 --> 30:52:13.044
So once a proposers thing has gone through, anybody can execute it.

18807
30:52:13.044 --> 30:52:16.694
So we'll say executor, TX That wait one wait a block.

18808
30:52:16.694 --> 30:52:25.990
And then got one more to do here, we need to revoke role right now our Deployer count owns that time lock controller, right.

18809
30:52:25.990 --> 30:52:33.852
And that's how we can actually do these transactions, we can actually grant role because our Deployer account owns it now that we've given everybody access.

18810
30:52:33.852 --> 30:52:38.296
And given all the decentralized access we need, we want to revoke that role.

18811
30:52:38.296 --> 30:52:40.666
So const revoke TX equals await.

18812
30:52:40.666 --> 30:53:01.559
I'm locked up revoke role, admin role from Deployer will do Rotex that wait, now guess what anything that's um, like, wants to do has to go through governance, and nobody owns the time I controller, it's currently after this runs, it's impossible for anyone to do anything with the Time Lock without governance happening.

18813
30:53:01.559 --> 30:53:05.562
And then of course, when the export default set of contracts, great.

18814
30:53:05.562 --> 30:53:15.061
And then the last step that we need to do here is we need to deploy the contract that we actually want to govern over write that box contract, that real basic contract.

18815
30:53:15.061 --> 30:53:17.307
So we're gonna create a new 105, deploy box.

18816
30:53:17.307 --> 30:53:17.438
ts.

18817
30:53:17.438 --> 30:53:38.731
And we're gonna do some of the same exact stuff we've done right, so we're gonna grab these two, these two here, paste it in, os deploy box is going to be a deploy function equals async function, Ah, sorry, hard hat runtime environment, we're gonna grab those first three lines, the TS ignore, just like that.

18818
30:53:38.731 --> 30:53:41.420
And now we're going to deploy this box.

18819
30:53:41.420 --> 30:53:52.011
So log, deploying bucks, and we're going to do const box equals await, deploy box, give us some values from our Deployer.

18820
30:53:52.011 --> 30:53:56.643
args does this have any args so open a box dot soul, I don't see a constructor.

18821
30:53:56.643 --> 30:54:04.197
And while this is the easiest contract out of all these though, no constructor, and then we'll just say log, it's going to be true.

18822
30:54:04.197 --> 30:54:10.711
And again, if you want to check out my GitHub repo for that confirmations, but feel free to do so it's coming here.

18823
30:54:10.711 --> 30:54:15.385
And right now, our deployer has actually deployed this right, not our time lock.

18824
30:54:15.385 --> 30:54:20.476
So we want to give the boxes ownership over to our governance process.

18825
30:54:20.476 --> 30:54:26.216
So now we're going to do say const timelock, is going to be a weight ethers dot get contract.

18826
30:54:26.216 --> 30:54:27.970
The same thing as before.

18827
30:54:28.111 --> 30:54:28.825
timelock.

18828
30:54:33.111 --> 30:54:34.750
ethers from hard hat.

18829
30:54:38.111 --> 30:54:39.396
it's being finicky.

18830
30:54:42.111 --> 30:54:48.274
ownership of our box to this time lock, okay, and now so this is actually what's known as a box deployment.

18831
30:54:48.274 --> 30:54:50.456
So before we do that, we have to get the box contract.

18832
30:54:50.456 --> 30:55:07.998
So this is a box deployment object, which doesn't have contract functions we want to get the box contract object so we to box or const box contract equals await ethers dot get contract at box and then we'll just do you know box that address.

18833
30:55:07.998 --> 30:55:09.511
You could also do get contract.

18834
30:55:09.511 --> 30:55:14.161
Actually both of these pretty much if you have the address, you can just do box that address.

18835
30:55:14.161 --> 30:55:15.677
You could also do get contract here.

18836
30:55:15.677 --> 30:55:44.111
Either one works now that we have the box contract, we do const transfer owner, dx equals await by contract dot transfer TX or schema dot transfer ownership to our timelock dot address, time walk dot address, then we just do a weight transfer ownership TX dot weight one, do a log, you done it.

18837
30:55:44.111 --> 30:55:47.682
Those are export default.

18838
30:55:47.682 --> 30:55:49.253
Deploy box.

18839
30:55:49.253 --> 30:55:52.504
Oh, let's see if this works.

18840
30:55:52.504 --> 30:55:54.635
So we just did everything.

18841
30:55:54.635 --> 30:56:05.795
We're deploying the GOV token, deploying the timelock, which owns the governance process, we're deployed the governance process, we're setting up the governance process so that it's totally decentralized.

18842
30:56:05.795 --> 30:56:13.023
And then we deployed and set up our box so that it only can be updated through a governance process.

18843
30:56:13.111 --> 30:56:14.832
Let's see if it works.

18844
30:56:14.832 --> 30:56:16.635
Yarn, hard hat deploy.

18845
30:56:18.111 --> 30:56:18.549
works.

18846
30:56:18.549 --> 30:56:20.829
Bada boom, you've done it.

18847
30:56:23.111 --> 30:56:28.401
script to set this entire governance process up so you can build your own doubt.

18848
30:56:28.401 --> 30:56:36.687
Are you still here? Well, hell yeah, you are, congratulations on getting this far, we have one more piece to go, we just got to write those scripts.

18849
30:56:36.687 --> 30:56:42.304
So we can actually interact with this, we can actually do a governance, we can actually see exactly what the governance process looks like.

18850
30:56:42.304 --> 30:56:48.788
Now again, if you didn't watch my last video on Dows, be sure to watch that, because that's going to give you all the context for this part here.

18851
30:56:48.788 --> 30:56:56.917
And if you're still watching 100%, smash the like button, hit the subscribe, leave a comment in the comment section below, it really helps the channel out.

18852
30:56:56.917 --> 30:56:58.192
So proud of you for getting this far.

18853
30:56:58.192 --> 30:57:00.479
We're almost there, you're getting now one more to go.

18854
30:57:00.479 --> 30:57:03.838
And then you are home free on building your doubt.

18855
30:57:03.838 --> 30:57:05.928
Let's get back into it.

18856
30:57:06.111 --> 30:57:13.261
Alright, so now we're going to make some scripts to actually interact with propose Q and vote on anything that happens in our Dao.

18857
30:57:13.261 --> 30:57:19.356
And these are the scripts, these are kind of the things that you would do on your front end when you build this when you build your doubt on the front end.

18858
30:57:19.356 --> 30:57:23.059
Or you could do an integration with snapshot or tally or something like that.

18859
30:57:23.111 --> 30:57:27.817
And again, if you want to see come to full functionality on the GitHub, I have this test flow.

18860
30:57:27.817 --> 30:57:29.416
ts It's not the greatest test here.

18861
30:57:29.416 --> 30:57:35.721
But you can also check this out, because it also does a soup to nuts demonstration of going through this exact process.

18862
30:57:35.721 --> 30:57:37.444
So let's go ahead and start making some scripts.

18863
30:57:37.444 --> 30:57:39.824
So we're gonna create a new folder called scripts.

18864
30:57:39.824 --> 30:57:42.661
And this is where we're going to put all of our scripts.

18865
30:57:42.661 --> 30:57:56.603
Now the process for this is going to be we're first going to propose something right? You know, maybe we're going to propose that our box contract stores the value 77, right? Because when it first gets initialized, it's going to start with zero.

18866
30:57:56.603 --> 30:57:59.852
So maybe we'll we'll propose it could start at 77.

18867
30:57:59.852 --> 30:58:02.644
Once proposing is done, we are voting on it.

18868
30:58:02.644 --> 30:58:07.976
Right once proposals it and we're going to vote on whether or not we want the proposal to go through right yes or no.

18869
30:58:07.976 --> 30:58:13.388
And then if it passes, we go to queue and execute, we queue first.

18870
30:58:13.388 --> 30:58:17.904
And then we execute, I'm just putting them both in the same script to make it easier.

18871
30:58:17.904 --> 30:58:22.303
So let's start with propose here, because it's going to be the first thing that we're going to do.

18872
30:58:22.303 --> 30:58:23.703
So let's create a new function.

18873
30:58:23.703 --> 30:58:29.843
We'll call it async function, and then we'll actually export it to export async function propose.

18874
30:58:29.843 --> 30:58:31.559
And we're going to be in here for a little bit.

18875
30:58:31.559 --> 30:58:32.777
So let's clear everything out.

18876
30:58:32.777 --> 30:58:33.491
And okay, cool.

18877
30:58:33.491 --> 30:58:39.370
So this is where we're actually going to propose on our governor contract, right? So we're going to propose a new governor contract.

18878
30:58:39.370 --> 30:58:41.848
So the first thing we're gonna need, of course, is gonna be the governor.

18879
30:58:41.848 --> 30:58:55.146
So you can't govern nor equals await ethers dot get contract, govern or contract, right? Since we're doing ethers, we're gonna have to do import ethers from heart app.

18880
30:58:55.146 --> 30:58:59.046
And then we're still getting that fundamental thing.

18881
30:58:59.046 --> 30:59:01.253
We'll do a little AT Ts ignore here.

18882
30:59:01.253 --> 30:59:01.431
Cool.

18883
30:59:01.431 --> 30:59:09.258
So we have the governor contract here, we're going to need the box contract, we're gonna say hey, we want to propose the box contract changes the store value.

18884
30:59:09.258 --> 30:59:18.321
So we'll do const box equals await ethers dot get this is a gift contract, we want get contract, get contracts at box.

18885
30:59:18.321 --> 30:59:22.058
And those are the two main ones that we're going to need just to start.

18886
30:59:22.111 --> 30:59:29.061
Now, if we look at the proposed function, right, if we go to governance, we go to Governor, and we look at that proposed.

18887
30:59:29.111 --> 30:59:30.007
This is what it looks like.

18888
30:59:31.111 --> 30:59:32.282
function in my last video.

18889
30:59:34.111 --> 30:59:42.498
go back and watch it right because it'll give you everything that you need to know here are basically we pick a list of targets, which our list is just going to be just our box contract.

18890
30:59:42.498 --> 30:59:51.820
These are the targets that we want to call functions on, we do values like how much needed ether we want to send, which we're not going to send anything, we have bytes, a array called data.

18891
30:59:51.820 --> 30:59:57.911
So this is going to be our encoded parameters for the function that we want to call and then a description.

18892
30:59:57.911 --> 31:00:00.079
So that's exactly what we're going to do here.

18893
31:00:00.079 --> 31:00:02.175
So first, we need to figure out what we're going to do.

18894
31:00:02.175 --> 31:00:05.548
So look at Box, we're going to call this store function with this new value here.

18895
31:00:05.548 --> 31:00:08.798
So we need to encode we need to encode this socks here.

18896
31:00:08.798 --> 31:00:14.825
And we also need to encode what we want to upgrade it to right so we have to code all the function parameters.

18897
31:00:14.825 --> 31:00:39.711
So we'll do const encoded function call equals box and the way we can get this box that interface that encode function data and This is what actually turns it to being this bytes call data, right? So we're encoding everything and this encoded function, you can find this in the ethers documentation, we have to pass it the function to call, and then the arguments we want to pass, right, and this is how we actually get that.

18898
31:00:39.711 --> 31:00:41.977
So let's get these arguments here.

18899
31:00:42.111 --> 31:00:45.491
So we're gonna say args, we're going to make our proposed function a little bit modular.

18900
31:00:45.491 --> 31:00:56.653
So we're gonna say args is going to be an array of anything, and then we're gonna say function to call is just going to be a string, right, and then right at the bottom, we're actually gonna call this, this proposed function.

18901
31:00:56.653 --> 31:01:03.111
So we're gonna say propose, and let's say we want to give it 77, the function is going to be what it's going to be store, store.

18902
31:01:03.111 --> 31:01:04.444
And that's a string.

18903
31:01:04.444 --> 31:01:06.301
And this needs to be a list.

18904
31:01:06.301 --> 31:01:07.777
So we're going to do like this.

18905
31:01:07.777 --> 31:01:10.586
Now, we're actually going to use this all over the place.

18906
31:01:10.586 --> 31:01:16.544
So since we're gonna be using this all over the place, we want to stick them in this part head helper config.

18907
31:01:16.544 --> 31:01:21.416
So what we're going to do is we're gonna say, export const, new store value equals 77.

18908
31:01:21.416 --> 31:01:25.968
And we're gonna do export const funk equals store.

18909
31:01:25.968 --> 31:01:30.163
And I propose, we're just going to import those.

18910
31:01:30.163 --> 31:01:39.211
So we'll do import, new store value, and also funk from helper Hardhead dot config, and it added it in for us, which is great.

18911
31:01:39.211 --> 31:01:41.295
So we'll just put new store value in here.

18912
31:01:41.295 --> 31:01:42.771
And then we'll put funk in here.

18913
31:01:42.771 --> 31:01:49.818
And I know this might look a little confusing, but basically, the first thing we're gonna do is we're gonna call this proposed function which calls you know, post function up here.

18914
31:01:49.818 --> 31:01:54.277
Now we're going to do some fun little then process that exit zero.

18915
31:01:54.277 --> 31:02:05.277
And then we're going to do a dot catch error, which if there's an error, basically, we'll just do console dot log error, then process that makes it.

18916
31:02:05.277 --> 31:02:11.349
And this is pretty typical setup for a really any script you work with, and hardhat.

18917
31:02:11.349 --> 31:02:11.777
So great.

18918
31:02:11.777 --> 31:02:15.900
So we have constant coded function call, which has this function to call an arc.

18919
31:02:15.900 --> 31:02:18.717
So we're basically combining these into this bytes thing.

18920
31:02:18.717 --> 31:02:20.864
And we can even print this out, you can see what this looks like.

18921
31:02:20.864 --> 31:02:25.111
So you do console dot log, you see that this is like this, this crazy bytes thing here.

18922
31:02:25.111 --> 31:02:33.449
And the way we can kind of test this, we'll do yarn hardhat node, which will spin up again, our fake blockchain.

18923
31:02:33.449 --> 31:02:44.127
But additionally, with Hardhead deploy, it will deploy all of our contracts here, right, we can see timelog governance, you know, everything that we need for testing locally has already been done.

18924
31:02:44.127 --> 31:03:00.888
So once we have that up, we can then do yarn hardhat, run scripts, propose that TS dash dash network, local host, this is important to do, again, because when you're working with a node that's running locally, you're going to be working with local host, we'll see what it prints out here.

18925
31:03:01.111 --> 31:03:05.035
Contract named Governor contracts, Governor contract.

18926
31:03:05.111 --> 31:03:06.422
Let's try that again.

18927
31:03:09.111 --> 31:03:14.223
encoded function call and arguments looks like is this really long byte string.

18928
31:03:14.223 --> 31:03:20.890
But if you were to decode this, using the box interface, you would get the function call and the arguments, which is really exciting.

18929
31:03:20.890 --> 31:03:22.689
So cool, we've encoded it to bytes.

18930
31:03:22.689 --> 31:03:27.957
And now what we want to do, we encourage the bytes, and now we're going to create that proposal transaction.

18931
31:03:27.957 --> 31:03:36.291
So we'll do console dot log will say pro posing, and say, function to call on box that address with args.

18932
31:03:36.291 --> 31:03:39.841
And then we also need to pass a proposal description.

18933
31:03:39.841 --> 31:03:50.039
So we're gonna say pro pose, all description, we would do it on new line, why not? Pro pulls all this option, which we don't have yet.

18934
31:03:50.111 --> 31:03:50.968
Alright, we're gonna get it.

18935
31:03:52.111 --> 31:03:55.852
description, right, because we have down here, description.

18936
31:03:56.111 --> 31:03:58.422
let's add another parameter to our propose here.

18937
31:03:59.111 --> 31:04:03.373
proposal description, and this will be also a string.

18938
31:04:04.111 --> 31:04:07.063
the bottom, we're going to need a proposal description as well.

18939
31:04:07.111 --> 31:04:12.666
So we'll create a proposal or export const proposal description, there's just going to be some string.

18940
31:04:12.666 --> 31:04:20.957
So we'll say proposal number one, door 77 In the box, that's the description here, comma proposal description.

18941
31:04:20.957 --> 31:04:23.223
And then we import this or a helper config.

18942
31:04:23.223 --> 31:04:23.900
Okay, perfect.

18943
31:04:23.900 --> 31:04:37.225
So now we have the new store value, the function the proposal description, and we can now call that propose that we were just looking at so here's what we're going to do const propose TX equals await.

18944
31:04:37.225 --> 31:04:38.585
gov dot propose.

18945
31:04:38.585 --> 31:04:40.754
And we need to pass those lists.

18946
31:04:40.754 --> 31:04:45.561
So first is going to be a list of targets, which for us is just a box that address right only one target.

18947
31:04:45.561 --> 31:05:01.165
And again, these these little brackets, make it a list of values, which is just going to be zero, a list of encoded function calls or our bytes data, basically, and then the proposal description, and then we're going to do propose, TX dot wait one.

18948
31:05:01.165 --> 31:05:14.042
Now, if you remember, from compound, this is going to be the exact same if we go back to compound back to governance, this transaction is literally going to be the same as this created thing here.

18949
31:05:14.111 --> 31:05:31.146
Right? And if we scroll down, like more, we can see the code input data, those exact same things on a compound proposal, right? We have targets values signatures, well okay, this CES is a little bit more, this a little bit more advanced here, using signatures, but it's got the same thing called data and then a description here, okay.

18950
31:05:31.146 --> 31:05:36.438
Now since we have a voting delay, people actually can't vote until the voting delay passes.

18951
31:05:36.438 --> 31:05:43.444
Now, with a local blockchain, nobody's actually processing blocks and time doesn't really pass as quick as we want.

18952
31:05:43.444 --> 31:05:46.924
And so we're just going to speed things up for our own testing purposes.

18953
31:05:46.924 --> 31:05:58.280
So the way I normally do this is I create this this variable, all development, exports, on development chains, and I'll add hard hat and local host.

18954
31:05:58.280 --> 31:06:04.938
Because we can actually do things with our own local blockchain, we can actually speed up time, we can speed up blocks, we can do all this crazy stuff.

18955
31:06:04.938 --> 31:06:07.304
So usually, I'll actually import this in here.

18956
31:06:07.304 --> 31:06:08.658
And then we'll do a quick F.

18957
31:06:08.658 --> 31:06:12.317
And I'll say, if we're on a development chain, let's just go ahead and speed things up for us.

18958
31:06:12.317 --> 31:06:12.937
Right.

18959
31:06:12.937 --> 31:06:22.619
So I'll say if development chains that includes network dot name, and then we can import network from from ethers, as well.

18960
31:06:22.619 --> 31:06:25.539
And this is what I was talking about those super six skills that you're gonna learn.

18961
31:06:25.539 --> 31:06:32.852
If it includes network dot name, then we're gonna go ahead and move the blocks forward, right, because if we're not on development chain, we can't actually move blocks.

18962
31:06:32.852 --> 31:06:38.611
So what we'll do here is actually I'll create a new folder called utilities, you folder, you are utils.

18963
31:06:38.611 --> 31:06:42.495
And in here, I'll create a script called Move blocks.

18964
31:06:42.495 --> 31:06:42.648
ts.

18965
31:06:42.648 --> 31:06:48.856
And we're just going to create this little function called move blocks, which moves blocks for us.

18966
31:06:48.856 --> 31:06:49.958
And you'll see how we do this.

18967
31:06:49.958 --> 31:06:57.788
So we're going to import network from heart app, because we want to speed up that voting delay, we'll do export async function, we'll call it move blocks.

18968
31:06:57.788 --> 31:07:02.537
And it'll take an amount, which will be a number, so how many blocks that we actually want to move.

18969
31:07:02.537 --> 31:07:06.111
And then we'll just do console dot log moving blocks.

18970
31:07:06.111 --> 31:07:12.064
And we'll say for let index equals zero, index is less than amount.

18971
31:07:12.064 --> 31:07:19.861
index plus plus, or we're going to do is we're going to do a weight network DAP provider dot request request.

18972
31:07:19.861 --> 31:07:23.932
And we're going to request method EVM.

18973
31:07:23.932 --> 31:07:24.467
Mine.

18974
31:07:24.467 --> 31:07:35.935
So basically, we're mining for our local blockchain, right, so you can find these docks in the hard hat docks in the ethers docks, there's a couple different places you can find these.

18975
31:07:35.935 --> 31:07:41.377
But this is kind of this really cool hack that we can use to actually move blocks forward on our local chain.

18976
31:07:41.377 --> 31:07:47.377
Now, obviously, this won't work on an actual chain, because you'd actually have to do the mining but on our local chains, we can absolutely do this.

18977
31:07:47.377 --> 31:07:57.548
So we've exported this move blocks function, and we're actually gonna grab that Mark propose, we're going to import move box from utils blocks.

18978
31:07:57.548 --> 31:08:13.111
And we're going to say down here, if we're on this development chain, and do a weight move blocks, and then we'll move blocks by that voting delay that we were talking about, right? Because we need to wait that voting delay in order to move and it looks like an auto import it for us from our helper hardware config.

18979
31:08:13.111 --> 31:08:16.664
I told you, we were gonna use that a couple of times, but we're gonna move blocks by that voting delay.

18980
31:08:16.664 --> 31:08:23.611
Now, this proposed transaction does some stuff that we actually want, right? So one of the big things that it wants is, is it has this proposal ID.

18981
31:08:23.611 --> 31:08:33.330
And if we scroll down to the event that it emits, it ends up emitting this proposal ID, we actually need the proposal ID for later on when we actually go to vote.

18982
31:08:33.330 --> 31:08:40.594
So what we're going to do is we're actually going to do const propose receipt equals proposed text dot weight.

18983
31:08:40.594 --> 31:08:43.918
And we're going to get those events from this proposed receipt.

18984
31:08:43.918 --> 31:08:45.727
So we're gonna say const.

18985
31:08:45.727 --> 31:08:55.531
Proposal, id equals proposed receipt, that events, the zero with event because that first event is the only one we care about that are your stop proposal ID.

18986
31:08:55.531 --> 31:08:59.924
This is how we get this proposal ID from this omit also created event.

18987
31:08:59.924 --> 31:09:03.327
A couple other ways to get proposals to get events in hardhat.

18988
31:09:03.327 --> 31:09:05.800
And I got a video on it on my YouTube, if you want to go check that out.

18989
31:09:05.800 --> 31:09:18.799
Something else that we want to do is maybe we want to see what the deadline is with a snapshot, you can go ahead and check my GitHub to kind of see what the snapshot looks like or the deadline, basically, how long we have to vote, you know what snapshot you're working with, and all these different things.

18990
31:09:18.799 --> 31:09:22.080
But for now, we're just gonna stick with the proposal Id be sure to check out the GitHub for more stuff.

18991
31:09:22.112 --> 31:09:31.533
Now we want to save this proposal ID, we want to save it somewhere so that our other scripts so that our vote and our queue and execute know what this proposal ID is going to be when we run those.

18992
31:09:31.533 --> 31:09:35.535
So what we're going to do is we're going to create this file called proposals dot JSON.

18993
31:09:35.535 --> 31:09:37.384
And it's going to store all of our proposals.

18994
31:09:37.384 --> 31:09:42.921
So we're gonna say pro poll, souls dot JSON, it's going to have all of our proposals in here.

18995
31:09:42.921 --> 31:09:50.800
So what we're going to do and we're going to add this to our helper Hardhead config, and do export const, proposals, file equals proposals dot JSON.

18996
31:09:50.800 --> 31:09:55.159
And we're going to import this at the top as well as proposals file.

18997
31:09:55.159 --> 31:10:00.518
And then once we get this proposal ID, we're going to do is we're going to read all the current proposals.

18998
31:10:00.518 --> 31:10:13.804
So we're gonna say let proposals equals JSON dot parse, and we're gonna do Fs dot read file sync from this probe proposals file, and we're going to pass it to UTF eight.

18999
31:10:13.804 --> 31:10:19.112
Now, this Fs we don't have yet, so we're going to need to import Fs.

19000
31:10:19.112 --> 31:10:22.695
So we're going to do yarn add Fs like that.

19001
31:10:22.695 --> 31:10:24.762
If we're looking at package dot JSON.

19002
31:10:24.762 --> 31:10:30.708
Oops, I should have saved that as Dev, but I didn't Oh, well, doesn't really matter.

19003
31:10:30.708 --> 31:10:33.918
Now that we have that we can actually import this into our TypeScript.

19004
31:10:33.918 --> 31:10:38.243
So we're just going to say, import star as Fs from Fs.

19005
31:10:38.243 --> 31:10:42.580
And now we can actually use Fs F as a way to kind of read from files.

19006
31:10:42.580 --> 31:10:44.361
Now we can get this list of proposals.

19007
31:10:44.361 --> 31:10:48.062
So we got two proposals that JSON right now we're just making a blank JSON.

19008
31:10:48.112 --> 31:10:50.552
So the first time we run it, it'll just be blank.

19009
31:10:51.112 --> 31:10:52.330
on, it'll have stuff in it.

19010
31:10:54.112 --> 31:11:03.826
these proposals is we're going to say pro proposals of network dot config dot chain ID, and this little bank to say, yes, there will be a chain id.

19011
31:11:03.826 --> 31:11:07.518
to string, we're going to store them by their chain IDs, right.

19012
31:11:07.518 --> 31:11:11.033
So for each network that we have a proposal to we'll we'll start like that.

19013
31:11:11.033 --> 31:11:13.440
And then we'll do dot push proposal, id.

19014
31:11:13.440 --> 31:11:16.486
to string, and then we'll write it back.

19015
31:11:16.486 --> 31:11:21.312
We'll do Fs dot right, file sync, proposals file.

19016
31:11:21.312 --> 31:11:25.325
JSON does string phi, proposals, and awesome.

19017
31:11:25.325 --> 31:11:27.702
And that's all we need to do.

19018
31:11:27.702 --> 31:11:29.353
So let's go ahead and actually run this.

19019
31:11:29.353 --> 31:11:35.259
And then I have some console dot logs in here saying, Hey, here's what the proposal state is, is it open? Is it voting is it canceled, you know, etc.

19020
31:11:35.259 --> 31:11:39.049
What the proposal snapshot is, you know, again, check my GitHub for that.

19021
31:11:39.049 --> 31:11:45.273
But what we can do, now this is done, we can do yarn, Hardhead node, spin up our little note here.

19022
31:11:45.273 --> 31:11:47.578
And all the contracts are deployed.

19023
31:11:47.578 --> 31:11:57.495
And then we'll do yarn, run scripts, proposed that TS dash dash network, local host scripts proposed that TS is not found.

19024
31:11:57.495 --> 31:12:05.695
Pro pose, yarn, hard hat, run scripts, pose IDs, oops, dash dash network, local hosts.

19025
31:12:05.695 --> 31:12:06.789
Try this again.

19026
31:12:06.789 --> 31:12:07.941
Now you found it.

19027
31:12:07.941 --> 31:12:08.212
Yay.

19028
31:12:08.212 --> 31:12:09.839
Oh, I ran into an issue.

19029
31:12:10.112 --> 31:12:12.712
Although description Moviebox Cannot read property zero of undefined.

19030
31:12:12.712 --> 31:12:14.912
Let's see where it got mad at me.

19031
31:12:14.912 --> 31:12:16.439
Poser sheet dot event.

19032
31:12:16.439 --> 31:12:19.979
It is events, not event shots again, on the localhost.

19033
31:12:20.112 --> 31:12:22.322
There we go running ran into another issue.

19034
31:12:23.112 --> 31:12:23.505
exists.

19035
31:12:23.505 --> 31:12:24.488
Okay, so great.

19036
31:12:27.112 --> 31:12:33.293
go ahead and just like kill the node, restart the node, so you can't have two proposals that are exactly the same, basically, right.

19037
31:12:33.293 --> 31:12:35.954
So we can't do that, we would need to change the description or something.

19038
31:12:35.954 --> 31:12:37.704
So we're just going to kill the node and restart.

19039
31:12:37.704 --> 31:12:39.515
Now we're going to run this proposal again.

19040
31:12:39.515 --> 31:12:43.144
And hopefully this one should work this time.

19041
31:12:43.144 --> 31:12:47.207
Community Property zero of undefined owes receipt.

19042
31:12:47.207 --> 31:12:53.997
This needs to be await because it is a promise, kill this one more time we run it once all these get deployed.

19043
31:12:53.997 --> 31:12:56.238
And we're gonna go ahead and run this.

19044
31:12:56.238 --> 31:13:02.549
Now you can see how much quicker this is than if you were to actually send this to a test net right to an event a lot of waiting, which is no bueno.

19045
31:13:02.549 --> 31:13:07.515
And we run into one more Cannot read property, push them undefined.

19046
31:13:07.515 --> 31:13:09.015
That makes a lot of sense, too.

19047
31:13:09.112 --> 31:13:12.821
Because proposals dot JSON as nothing for chain IDs.

19048
31:13:13.112 --> 31:13:13.595
231337.

19049
31:13:13.595 --> 31:13:16.498
And we'll put a little list in here.

19050
31:13:18.112 --> 31:13:18.612
empty list.

19051
31:13:21.112 --> 31:13:22.445
it.

19052
31:13:23.112 --> 31:13:25.378
And then once this goes, then we're gonna go ahead and do this.

19053
31:13:25.378 --> 31:13:25.911
Perfect.

19054
31:13:25.911 --> 31:13:33.234
Now we're going to run this and now it should save and everything should be peachy hunky dory.

19055
31:13:33.234 --> 31:13:33.935
Awesome.

19056
31:13:34.112 --> 31:13:37.612
proposal number one store in the box, we move the blocks.

19057
31:13:38.112 --> 31:13:41.577
we look at proposal dot JSON, we now see there's a list of proposals.

19058
31:13:41.577 --> 31:13:44.474
And this is the proposal ID of that one we just created.

19059
31:13:44.474 --> 31:13:45.974
Oh, okay, we made a proposal.

19060
31:13:45.974 --> 31:13:46.387
Awesome.

19061
31:13:46.387 --> 31:13:48.612
Nice work, we'll leave that Node running.

19062
31:13:48.612 --> 31:13:51.882
And hopefully we'll just do things right for the voting.

19063
31:13:51.882 --> 31:13:54.315
So let's create this vote script now.

19064
31:13:54.315 --> 31:13:58.531
Okay, so now we proposed it's time to vote, let's do a little voting.

19065
31:13:58.531 --> 31:14:01.962
So this is going to look pretty similar to that script, we just we just created right.

19066
31:14:01.962 --> 31:14:12.055
So we're in New async function, we'll call this main proposal index number, and we're calling this main because we're going to have the vote function be a little bit different.

19067
31:14:12.055 --> 31:14:12.621
You'll see why.

19068
31:14:12.621 --> 31:14:29.000
And at the bottom, of course, we're going to do main index dot then process dot exit zero, catch error arrow function, console dot error, error, and then process that exit.

19069
31:14:29.000 --> 31:14:33.477
One main index, we're gonna say our index zero cost index zero.

19070
31:14:33.477 --> 31:14:35.456
We'll do like this cost index is your postal index.

19071
31:14:35.456 --> 31:14:40.565
So we're gonna get we're gonna get that bit zero with index, right, the first index in our proposals dot JSON.

19072
31:14:40.565 --> 31:14:44.542
So whatever is the first one in this list is what we're gonna use, right? And that's what we want right now.

19073
31:14:44.542 --> 31:14:45.465
There's only one so it's easy.

19074
31:14:45.465 --> 31:14:47.143
So we're gonna get that first one in here.

19075
31:14:47.143 --> 31:14:51.576
So first thing we're gonna need to do is we're gonna need to grab the list of proposals.

19076
31:14:51.576 --> 31:14:59.969
So we're gonna do const proposals equals JSON dot parse, FS dot read, file sync proposals file, UTF, eight.

19077
31:14:59.969 --> 31:15:03.901
So of course, we're going to need to import a bunch of stuff.

19078
31:15:03.901 --> 31:15:09.278
We're going to import proposals file from that a slash a Bernhard config.

19079
31:15:09.278 --> 31:15:14.207
And then we're going to do import star as Fs from us.

19080
31:15:14.207 --> 31:15:14.778
Great.

19081
31:15:14.778 --> 31:15:18.325
We have Fs, we can read stuff, and we can get those boats.

19082
31:15:18.325 --> 31:15:18.865
Okay, cool.

19083
31:15:18.865 --> 31:15:20.540
So we have a list of proposal IDs.

19084
31:15:20.540 --> 31:15:24.079
Now let's get our proposal idea we'll do const probo.

19085
31:15:24.079 --> 31:15:28.505
also ID equals proposals of network dot config.

19086
31:15:28.505 --> 31:15:30.668
And then that's not what we want.

19087
31:15:30.668 --> 31:15:47.275
We want to actually import network, import network from hard hat, network dot config, that chain ID, exclamation mark of proposal index, which for us is going to be zero, right? We're getting that first proposal in the list of proposals.

19088
31:15:47.275 --> 31:15:49.816
Now we're gonna choose how we want to vote.

19089
31:15:49.816 --> 31:15:53.612
So zero equals against one equals four, and then two is abstain.

19090
31:15:53.612 --> 31:16:01.737
I don't know why you'd ever abstain abstaining costs gas, you could just not vote, but we're gonna say const vote way and the way we're gonna vote equals one.

19091
31:16:01.737 --> 31:16:03.487
And we can also do a reason.

19092
31:16:03.487 --> 31:16:14.758
So if we go back to our governor, there's a couple different functions we get to do to vote, there's cast vote, where we just cast a vote, cast, vote with reason, and cast vote with signature where we actually do a signature.

19093
31:16:14.758 --> 31:16:25.512
And I asked this question, Hey, what is cast vote by sick do on the opens up on forum, I was like, hey, what's the what is the purpose of this? My hunch was that anyone could then execute this vote on behalf of me if I didn't send the transaction.

19094
31:16:25.512 --> 31:16:26.602
And that's exactly what it is.

19095
31:16:26.602 --> 31:16:35.285
This method implements a meta transaction and allows a project to subsidize voting fees, the voters can generate a signature for free, and the project can submit those and pay for the gas.

19096
31:16:35.285 --> 31:16:37.073
So this is incredibly powerful.

19097
31:16:37.073 --> 31:16:55.954
And this is the function that allows this, this, this cast vote by signature is what allows that snapshot chain link integration that you know, hopefully one of you build, but for us for this, since we're not implementing these meta transactions, these off chain stuff, we're just going to do cast a vote with reason why because we want to give it a reason.

19098
31:16:55.954 --> 31:16:56.848
That's really it.

19099
31:16:56.848 --> 31:17:02.212
So we're gonna say const boat TX response equals await.

19100
31:17:02.212 --> 31:17:05.921
Gov nor dot cast, excuse me, we need to get the government contract.

19101
31:17:05.921 --> 31:17:07.259
So we'll do const.

19102
31:17:07.259 --> 31:17:10.947
Gov nor equals await ethers dot get contract.

19103
31:17:11.112 --> 31:17:11.702
Gov contract.

19104
31:17:14.112 --> 31:17:14.492
ethers.

19105
31:17:14.492 --> 31:17:14.872
Great.

19106
31:17:14.872 --> 31:17:15.951
Let's get ethers.

19107
31:17:15.951 --> 31:17:17.347
And we'll ignore that.

19108
31:17:18.112 --> 31:17:19.112
we have the contract.

19109
31:17:21.112 --> 31:17:24.040
with reason spell this right? With reason.

19110
31:17:25.112 --> 31:17:26.381
proposal ID that way.

19111
31:17:29.112 --> 31:17:31.445
reason here, so let's make a reason.

19112
31:17:33.112 --> 31:17:40.732
reason, equals I like do cha cha, if you know that film, you should definitely comment it in the description.

19113
31:17:40.732 --> 31:17:47.210
We have a reason so we're voting for we're saying yes, we want we do indeed want you to change the box to 77.

19114
31:17:47.210 --> 31:17:55.724
And the reason is because I like a do the Cha Cha makes perfect sense if you don't think about and then we'll do a wait, Kotex response that wait.

19115
31:17:55.724 --> 31:18:02.969
So I do some stuff, again, checking the state of the proposal where different numbers mean, hey, it's in process, it's voting, etc, we could check on that.

19116
31:18:02.969 --> 31:18:04.048
But we're gonna skip that for now.

19117
31:18:04.112 --> 31:18:07.645
All we're going to do now, now that we voted, we're going to be the ones to vote.

19118
31:18:07.645 --> 31:18:09.925
So we're just going to once again move the blocks along.

19119
31:18:09.925 --> 31:18:14.059
Why because we want to just get to the end of that voting period.

19120
31:18:14.059 --> 31:18:23.818
So we're gonna do again, if velopment chains, that includes network dot name, then we're gonna do a weight move blocks, voting period, plus one.

19121
31:18:23.818 --> 31:18:26.902
So we need to import a whole bunch of stuff in here.

19122
31:18:26.902 --> 31:18:32.269
poses file development, looks like those got auto imported, we need to import this move blocks.

19123
31:18:32.269 --> 31:18:38.262
So import move blocks from utils blocks, and that network is in here.

19124
31:18:38.262 --> 31:18:41.056
And then we need voting period from our helper config.

19125
31:18:41.056 --> 31:18:41.833
voting period.

19126
31:18:41.833 --> 31:18:42.444
Okay, cool.

19127
31:18:42.444 --> 31:18:47.173
And then we'll do console dot log, voted, ready to go.

19128
31:18:47.173 --> 31:18:54.053
Now the reason that I checked the proposal state is because there's this state function in the governor contract.

19129
31:18:54.053 --> 31:19:04.870
So if we look up state, what this does is it tells us what the state of the proposals in right if it's been executed, return that's been executed, if it's been canceled, return has been canceled.

19130
31:19:04.870 --> 31:19:19.235
You have the deadline, check to see if it's active, check to see if quorum reached all this stuff, right? And what you're usually looking for is worm reached and vote succeeded, right? If both of these happen, the proposal state DOT succeeded, right? Otherwise, it's defeated or it's not there yet.

19131
31:19:19.235 --> 31:19:21.273
I believe this is a one and this is a zero.

19132
31:19:21.273 --> 31:19:26.174
So if you were to call that function and get the state right, now we should get a zero.

19133
31:19:26.174 --> 31:19:28.489
Or excuse me, we should get a one for this having passed.

19134
31:19:28.489 --> 31:19:31.445
If you want to do that as a little extra credit, feel free to do so.

19135
31:19:31.445 --> 31:19:32.839
So let's see if we did this right.

19136
31:19:32.839 --> 31:19:35.254
Well, actually, I guess we got to change this just to vote.

19137
31:19:35.254 --> 31:19:37.342
But I just wrapped everything up into main.

19138
31:19:37.342 --> 31:19:38.899
So let's see if this works.

19139
31:19:38.899 --> 31:19:42.281
Yarn, hard hat run scripts vote network, local host.

19140
31:19:42.281 --> 31:19:47.849
So we should get a little console dot log at the bottom that says voted ready to go.

19141
31:19:47.849 --> 31:19:48.898
So now we're voting.

19142
31:19:48.898 --> 31:19:56.032
We didn't just go to the Arctic Council, we could do yarn, hard hat console, dash dash network, local host.

19143
31:19:56.112 --> 31:19:58.387
And in here, you can actually just check the state right in here.

19144
31:19:58.387 --> 31:20:04.578
Why not? We'll copy this line as governor because we either get contract Governor contract.

19145
31:20:04.578 --> 31:20:13.629
Now we can do a wait, Governor, that's state of go to the proposals dot JSON, grab this, paste it in here.

19146
31:20:13.629 --> 31:20:18.064
And we get a for the state of this right now is for I forget what four means.

19147
31:20:18.064 --> 31:20:19.362
It's like a proposal state.

19148
31:20:19.362 --> 31:20:30.732
The proposal state is actually in the eye governor so the interface of the governor We can see, zero is pending, one is active, two cancelled, three defeated, and four have succeeded.

19149
31:20:30.732 --> 31:20:34.243
So we are in a succeeded state, which is really good.

19150
31:20:34.243 --> 31:20:35.161
That's exactly what we want.

19151
31:20:35.161 --> 31:20:36.370
So let's go ahead and quit now.

19152
31:20:36.370 --> 31:20:37.663
Excuse me Ctrl.

19153
31:20:37.663 --> 31:20:41.366
C, our proposal is now in a succeeded state.

19154
31:20:41.366 --> 31:20:44.402
And we've actually moved the blocks along the voting period.

19155
31:20:44.402 --> 31:20:46.385
So voting is now over because we cheated.

19156
31:20:46.385 --> 31:20:51.778
So now let's go ahead and queue and execute this to the last bit here.

19157
31:20:51.778 --> 31:20:53.095
So this is gonna look real similar to what we've done already.

19158
31:20:53.112 --> 31:20:59.705
Right? Let's minimize this, export async, function, Q, and execute.

19159
31:20:59.705 --> 31:21:04.456
And then at the bottom, we'll just call queue, and execute.

19160
31:21:04.456 --> 31:21:10.722
And I'm just going to copy paste, but it's that same syntax here, then process exec catch, blah, blah, blah, you get the drill.

19161
31:21:10.722 --> 31:21:16.518
So in order to queue and execute, go back to the governor contract, not the governor, let's go to the governor.

19162
31:21:16.518 --> 31:21:19.009
First thing we're going to do is call this queue.

19163
31:21:19.112 --> 31:21:25.412
Now this Q function is actually in the governor time lock, which is in this extensions here.

19164
31:21:25.412 --> 31:21:35.144
So we can find the governor Time Lock controller here, and it does exactly the same as propose we take everything that we did in the proposal, and then we just queue it like so.

19165
31:21:35.144 --> 31:21:37.012
So we pass the exact same values here.

19166
31:21:37.112 --> 31:21:38.012
And that's so cute.

19167
31:21:40.112 --> 31:21:43.563
need to first get those exact same values, which I told you we're going to use a few times.

19168
31:21:43.563 --> 31:22:07.596
So we're going to import bunk, new store value, proposal description of our article thing, right now that we have all that stuff, we'll say const args equals a new store value, we'll do const box equals await ethers dot get contract, let's get that box contract again, we're gonna have to import ethers from our hat.

19169
31:22:07.596 --> 31:22:21.912
And this is going to be from we're gonna do TS ignore, then we're once again code this function call to const encoded function call equals Boxtop interface, encode function data.

19170
31:22:21.912 --> 31:22:29.375
Once again, we're gonna do funk is the function we want to call and args this is like real similar to the our proposed bit that we did.

19171
31:22:29.375 --> 31:22:44.326
And then we're gonna do content description hash equals ethers dot utils that get GAC 256 ethers dot utils, that to you, TF eight bytes, this will make sense in a second.

19172
31:22:44.326 --> 31:22:45.968
We're also description.

19173
31:22:45.968 --> 31:23:01.762
So what's our propose, all we did was pass our proposal description, however, it actually gets hashed on chain, and that's what our view and execute is gonna be looking for, it's gonna be looking for the description hash, instead of just the pure description, right, and it's gonna be a little bit cheaper gas wise, which is good.

19174
31:23:01.762 --> 31:23:08.695
So now that we have the description hash, now that we have all the same functions that we did for the suppose it's time to queue them.

19175
31:23:08.695 --> 31:23:13.061
So do cost gov equals await ethers dot get contract.

19176
31:23:13.061 --> 31:23:23.000
Gov contract, console dot log will say we're queuing and then we'll do cos Q, dx equals gov dot q.

19177
31:23:23.112 --> 31:23:34.805
And we're going to pass the exact same parameters we did with the pose except for what the hash instead of the actual proposal, so box that address zero for eath, and pass that code at function call.

19178
31:23:34.805 --> 31:23:37.627
And then the description hash rate.

19179
31:23:37.627 --> 31:23:41.789
And then we're going to do oops, is going to be a weight here.

19180
31:23:41.789 --> 31:23:43.737
And then we're gonna do a wait.

19181
31:23:43.737 --> 31:23:46.424
You text Oh, wait, one, wait a block there.

19182
31:23:46.424 --> 31:23:48.674
And great, then we're all queued up.

19183
31:23:48.674 --> 31:23:54.332
Now we still have to wait that minimum delay, right? Remember, on our timeline, it's got this min delay thing.

19184
31:23:54.332 --> 31:23:58.543
It says, Hey, once something gets queued up, you can't just execute it right away.

19185
31:23:58.543 --> 31:24:00.462
You gotta give people time to get out.

19186
31:24:00.462 --> 31:24:11.497
So we're going to speed up time again, we're going to say if development chains develop l meant chains that includes and then it looks like it auto imported for me development chains.

19187
31:24:11.497 --> 31:24:12.339
Yes, it did.

19188
31:24:12.339 --> 31:24:12.900
Amazing.

19189
31:24:13.112 --> 31:24:14.563
That includes network dot name.

19190
31:24:16.112 --> 31:24:17.639
network from Hardhead.

19191
31:24:20.112 --> 31:24:21.933
course, we're going to move blocks.

19192
31:24:23.112 --> 31:24:26.849
have to move time here as the minimum delay is looking for some time.

19193
31:24:26.849 --> 31:24:30.455
So let's create a new util called Move time.

19194
31:24:30.455 --> 31:24:32.690
Okay, move time that Yes.

19195
31:24:32.690 --> 31:24:37.558
And this util is going to allow us to move time so you're learning all the cool stuff.

19196
31:24:37.558 --> 31:25:06.466
So we'll quickly write a script to do this important network from hard hat export async function move time, how much time will be a number of Mount console dot log, moving time, and let's say await network dot provider dot send EVM increase time and then just by the amount, then we'll just say console dot log, move forward, amount seconds, it goes forward and seconds.

19197
31:25:06.466 --> 31:25:06.788
Cool.

19198
31:25:06.788 --> 31:25:08.891
So now we have this move time function.

19199
31:25:08.891 --> 31:25:15.773
That was pretty quick, right? So first, we're going to move time and we're gonna move time by that min delay first, plus one just to be safe.

19200
31:25:15.773 --> 31:25:17.293
And then we're also going to move blocks.

19201
31:25:17.293 --> 31:25:20.735
We're gonna do a weight move time, and then a weight move blocks.

19202
31:25:20.735 --> 31:25:22.768
And we'll just move on block.

19203
31:25:22.768 --> 31:25:26.046
So got it Import move blocks from utils.

19204
31:25:26.046 --> 31:25:30.561
It imports move time from those utils as well, time.

19205
31:25:30.561 --> 31:25:35.063
And then we also have to import this min delay, which we get from our helper.

19206
31:25:35.113 --> 31:25:35.850
Hardhead config.

19207
31:25:35.850 --> 31:25:36.145
Great.

19208
31:25:36.145 --> 31:25:37.472
So we moved all that stuff.

19209
31:25:38.113 --> 31:25:40.290
this were a real chain, you just have to wait.

19210
31:25:41.113 --> 31:25:42.713
not a real chain, we can do whatever we want.

19211
31:25:43.113 --> 31:25:44.163
doing whatever I want.

19212
31:25:46.113 --> 31:25:48.768
passed, we're looking spicy.

19213
31:25:48.768 --> 31:25:50.931
Let's drive this home.

19214
31:25:52.113 --> 31:25:57.926
do a little console dot log executing the const execute TX equals await.

19215
31:25:57.926 --> 31:25:59.010
gov dot execute.

19216
31:25:59.010 --> 31:26:05.838
We're going to pass this the exact same set of things we did for the Q TX so I'm literally gonna copy this.

19217
31:26:05.838 --> 31:26:06.757
paste it down here.

19218
31:26:06.757 --> 31:26:10.573
And then we're just going to do a weight SQ TX dot weight.

19219
31:26:10.573 --> 31:26:12.953
We're going to wait one block.

19220
31:26:13.113 --> 31:26:24.078
And then the final hour we'll see if the governance updated our box contract const box new value equals await box dot retrieve.

19221
31:26:24.078 --> 31:26:28.060
And that will do console dot log.

19222
31:26:28.060 --> 31:26:29.749
New box value.

19223
31:26:30.113 --> 31:26:31.178
Box new value.

19224
31:26:35.113 --> 31:26:36.573
box value to be updated.

19225
31:26:39.113 --> 31:26:43.713
hat run grips Q and execute now work localhost.

19226
31:26:45.113 --> 31:26:49.019
right? Are we successfully done governance? We did.

19227
31:26:50.113 --> 31:26:51.446
We're gonna figure out what we did wrong.

19228
31:26:52.113 --> 31:26:54.899
check 256 I spelt some stuff wrong.

19229
31:26:57.113 --> 31:26:57.435
no CK.

19230
31:26:57.435 --> 31:26:58.209
Just just k.

19231
31:26:58.209 --> 31:26:59.628
Okay, let's try again.

19232
31:27:01.113 --> 31:27:01.779
actually did.

19233
31:27:01.779 --> 31:27:02.890
I think that's good.

19234
31:27:04.113 --> 31:27:07.774
provider EVM and crit cuz I spelt increased time wrong.

19235
31:27:08.113 --> 31:27:13.238
no EVM increase time to just double check.

19236
31:27:15.113 --> 31:27:17.349
spelling this right T is actually capital.

19237
31:27:18.113 --> 31:27:18.578
messed up.

19238
31:27:18.578 --> 31:27:20.491
So it's actually already been queued.

19239
31:27:21.113 --> 31:27:24.653
queued right now on our little node EVM increased team.

19240
31:27:25.113 --> 31:27:32.563
can either delete and kind of restart, or I can just go ahead and I'm just going to comment out a bunch of stuff, we're just going to skip the cueing here.

19241
31:27:32.563 --> 31:27:36.045
We're gonna run this one more time, because it's already been queued.

19242
31:27:36.045 --> 31:27:38.883
And now should just execute, we're gonna move time again.

19243
31:27:38.883 --> 31:27:39.669
But that's fine.

19244
31:27:39.669 --> 31:27:41.003
Oh, my goodness, we did it.

19245
31:27:41.003 --> 31:27:41.284
Right.

19246
31:27:41.284 --> 31:27:43.940
And then normally, you would just do it in one script.

19247
31:27:43.940 --> 31:27:46.790
But this queue would fail because it was already queued.

19248
31:27:46.790 --> 31:27:48.870
Right, you can't queue twice, move forward.

19249
31:27:48.870 --> 31:28:03.028
In time, we move blocks we executed and we got a new box value completely using our Dow completely decentralized voting completely on chain, no third party trust going in on here.

19250
31:28:03.113 --> 31:28:11.028
There's no voting booth, there's no you know, spending 1000s of dollars on staff, everything we just voted on happened right in front of our faces.

19251
31:28:11.028 --> 31:28:16.064
Now, again, I highly recommend go to my GitHub repo, you take a look and you see what's going on here.

19252
31:28:16.113 --> 31:28:19.313
Again, if you want to see JavaScript stuff, feel free to do some JavaScript stuff.

19253
31:28:19.313 --> 31:28:23.713
But this goes over how to just get clone and get started if you want to do that as well.

19254
31:28:23.713 --> 31:28:32.138
But if you walked with me here, if you walked through this with me, you have learned in the absolute Khan, thank you so much for being here.

19255
31:28:32.138 --> 31:28:34.907
And I'll see you next time.

19256
31:28:35.113 --> 31:28:35.827
All right.

19257
31:28:40.113 --> 31:28:46.473
security and auditing section, this one is going to be a little bit less coding and a little bit more explaining.

19258
31:28:46.473 --> 31:28:50.382
And most of what we're going to be learning about here is in this Hardhead security FCC section.

19259
31:28:50.382 --> 31:28:56.481
Throughout this course, we've given you a couple of tips about different security features.

19260
31:28:56.481 --> 31:29:02.440
One, we talked about reentrancy, we talked a little bit about Oracle Tax, and we're going to talk about those more.

19261
31:29:02.440 --> 31:29:09.867
And some of the tools we can use to make our code more efficient, to look out for bugs, and to make our code more secure.

19262
31:29:09.867 --> 31:29:17.387
So we're gonna go ahead, we're gonna go over this hard hat security FCC code base, and we're going to walk through it a little bit.

19263
31:29:17.387 --> 31:29:27.313
So one of the first things that we're going to talk about is, what is an audit? Well, an audit is going to be a security focused code review, looking for issues with your code.

19264
31:29:27.313 --> 31:29:44.604
So for example, let's say we have some code that looks like this, this should be a little bit familiar, because we talked about this in one of our earlier sections with reentrancy, our code, withdraw, goes and sends ether and then updates the balances, this code is clearly vulnerable to a reentrancy attack here.

19265
31:29:44.604 --> 31:29:47.294
And this is something that an auditor would catch.

19266
31:29:47.294 --> 31:29:49.435
Since when we deploy our code, that code is immutable.

19267
31:29:49.435 --> 31:30:07.589
And that code will always be there, it's really important to have these security reviews done before we deploy our code to a main net, and before we go live, so if you're going to deploy some crazy, massive defy protocol, and you're gonna have billions of dollars of people's money locked into your protocol, you probably want to make sure that the money is going to go to the correct places.

19268
31:30:07.589 --> 31:30:12.684
So audits are incredibly important for the lifecycle of our projects.

19269
31:30:12.684 --> 31:30:18.738
And we want people to peer review, we want people to review our code to make sure that everything looks good.

19270
31:30:18.738 --> 31:30:23.096
Now, when we send our code to audit, though, we shouldn't just say hey, here's our code.

19271
31:30:23.096 --> 31:30:25.014
Can you check them Make sure it's good.

19272
31:30:25.113 --> 31:30:32.892
That's not going to give an auditor enough information, they need to be able to very easily know what your code does, how to work with it, and what you're looking for.

19273
31:30:32.892 --> 31:30:38.621
Because auditors aren't going to be kind of this, this failsafe, where if your code is terrible, they're going to catch everything.

19274
31:30:38.621 --> 31:30:40.096
Auditors are human beings too.

19275
31:30:40.096 --> 31:30:42.014
They can miss things as well, auditors.

19276
31:30:42.113 --> 31:30:44.435
Also, don't make sure that your code is bug free.

19277
31:30:45.113 --> 31:30:48.795
audits are security focused peer reviews for your codebase.

19278
31:30:49.113 --> 31:30:54.822
when you do send your code to audit, you want to make sure you help out your auditors as much as possible.

19279
31:30:54.822 --> 31:31:08.713
There's an amazing tweet thread from Tinto and previously was an open Zeplin auditor with a ton of tips and tricks for working with auditors, I highly recommend you pause the video, you click this link and you read through his tweets because they are fantastic.

19280
31:31:08.713 --> 31:31:16.285
openzeppelin has a readiness guide to try to help you make sure that you're even ready for an audit in the first place.

19281
31:31:16.285 --> 31:31:19.227
And we've got a link to this readiness guide in the GitHub repository.

19282
31:31:19.227 --> 31:31:34.800
The summary of them are to add comments to your code, use natspec, which we learned about to document your functions, document your functions, document your functions, test, be ready to talk to your auditors, and be prepared to give them plenty of time.

19283
31:31:34.800 --> 31:31:40.129
They are literally pouring themselves over your code for weeks on end to make sure there's nothing wrong.

19284
31:31:40.129 --> 31:31:44.629
If you rush your auditors, you're gonna get a rushed audit, and they're going to miss things.

19285
31:31:44.629 --> 31:31:46.566
So let's talk about the auditing process.

19286
31:31:46.566 --> 31:31:48.790
In auditing process is going to look like this.

19287
31:31:48.790 --> 31:31:50.677
First, they're going to run your tests.

19288
31:31:50.677 --> 31:32:05.827
That's the first step in order is always going to take and right there, they're gonna find okay, do they have enough code coverage? Is everything passing? What do the tests do? What is the optimal functionality, after an auditor runs tests, they're going to read specs or run your docs.

19289
31:32:05.827 --> 31:32:11.371
And then they're going to run some fast tools like Slither, linters and static analysis.

19290
31:32:11.371 --> 31:32:16.354
And that's going to be one of the first things we're going to talk about slither and static analysis.

19291
31:32:16.354 --> 31:32:24.541
So static analysis is the process of just running some program to read over all your code and look for commonly known bugs.

19292
31:32:24.541 --> 31:32:28.790
One of the most popular static analysis tools is going to be this tool called Slither.

19293
31:32:28.790 --> 31:32:32.128
And that's going to be one of the first things we're going to do here.

19294
31:32:32.128 --> 31:32:34.289
So let's go ahead and open up our VS code now.

19295
31:32:34.289 --> 31:32:38.738
And we'll make a new directory called hardhats security, FCC.

19296
31:32:38.738 --> 31:32:40.863
We'll cd into it.

19297
31:32:40.863 --> 31:32:43.488
We'll do code period.

19298
31:32:43.488 --> 31:32:45.887
And we'll open this up.

19299
31:32:45.887 --> 31:32:52.859
Now what I want you to do, instead of starting a new folder, and everything is we're going to get clone, my heart had security FCC.

19300
31:32:52.859 --> 31:33:00.051
So we'll do git clone, our net security FCC space, and then put a period to clone it into this directory.

19301
31:33:00.113 --> 31:33:02.418
And we'll get everything like this.

19302
31:33:04.113 --> 31:33:11.401
with a couple of different contracts for us already, that each have a different vulnerability, one of them is going to be bad RNG.

19303
31:33:11.401 --> 31:33:18.488
This is a contract that picks a random winner of a raffle using block difficulty and message dot sender.

19304
31:33:18.488 --> 31:33:24.867
This isn't truly random, as the miners can influence the block dot difficulty, and people can cancel transactions.

19305
31:33:24.867 --> 31:33:30.020
And there's a ton of ton of different vulnerabilities with creating randomness in this way.

19306
31:33:30.020 --> 31:33:44.703
We also have this liquid pool as an Oracle, the two most common types of attacks are reentrancy, which we've learned about an Oracle manipulation attacks, which luckily for you, we've taught you about decentralized Oracle's and working with chain link, which should make you a lot safer.

19307
31:33:44.703 --> 31:33:56.613
And especially for this section, I'm going to harp on these, please, please, please, if you taking this course, please do not make a protocol that falls victim to one of these, I will feel like I have failed you.

19308
31:33:56.613 --> 31:34:03.389
If you build a protocol where you use some centralized oracle that gets manipulated, or you build a protocol that has a reentrancy attack.

19309
31:34:03.389 --> 31:34:07.359
The tools that I'm going to show you right here are going to help you with reentrancy.

19310
31:34:07.359 --> 31:34:12.822
And everything I've taught you about chain link should hopefully teach you how to not get Oracle manipulated.

19311
31:34:12.822 --> 31:34:19.384
So in this contract here, we're using a liquidity pool as an Oracle and this is kind of some advanced defy stuff here.

19312
31:34:19.384 --> 31:34:26.779
This is a minimalistic decentralized exchange example where people can buy and sell and swap different assets.

19313
31:34:26.779 --> 31:34:32.366
Now using this singular exchange, to get the swap price is a terrible idea.

19314
31:34:32.366 --> 31:34:35.731
Because this is a single protocol for a single price.

19315
31:34:35.731 --> 31:34:42.513
The price from this protocol is a single centralized location, and we don't want to get our price from a single centralized exchange.

19316
31:34:42.513 --> 31:34:44.413
We want to get it from many exchanges.

19317
31:34:44.413 --> 31:34:57.500
Getting the price of any asset from a single decentralized exchange is not decentralized, is somebody manipulates the market doing some crazy advanced defy things that will ruin the price of your assets.

19318
31:34:57.500 --> 31:35:02.854
So getting the price of your assets from a centralized location is a terrible idea.

19319
31:35:02.854 --> 31:35:04.983
We have a metamorphic proxy here.

19320
31:35:05.113 --> 31:35:10.553
The issue here is that it's initialized double, and we don't guarantee that the contract has been initialized.

19321
31:35:10.553 --> 31:35:13.079
We have a classic reentrancy issue here.

19322
31:35:13.079 --> 31:35:22.548
And then we have and then we have a vault here where some password is stored on chain and we're crossing our fingers that nobody reads this password to unlock it.

19323
31:35:22.548 --> 31:35:31.955
So we're going to run some static analysis on these contracts, see if that static analysis can spot some of the bad things in here.

19324
31:35:32.113 --> 31:35:41.065
To get started, we're going to use a tool like I said called slither slither tool was created by this Crytek team, aka the trilobites team.

19325
31:35:41.065 --> 31:35:45.199
Now, trilobites is one of my absolute favorite auditors in the space.

19326
31:35:45.199 --> 31:35:51.822
And I absolutely love all the tools that this team puts out, they put up open source security tools for any of us to use such as slitter.

19327
31:35:51.822 --> 31:35:56.596
Now to get started with Slither, we actually need to install Python first.

19328
31:35:56.596 --> 31:35:58.774
So you can also run it with Docker.

19329
31:35:58.774 --> 31:36:02.284
But I'm going to show you how to how to work with Python first.

19330
31:36:02.284 --> 31:36:05.988
So if you haven't worked with Python, before, you can come to python.

19331
31:36:05.988 --> 31:36:09.629
org/downloads and download Python right from the website, you'll know you've done it right.

19332
31:36:09.629 --> 31:36:13.313
And you can run python three dash dash version, like this.

19333
31:36:13.313 --> 31:36:17.293
Or if you have an older version of Python, you can run Python dash dash version.

19334
31:36:17.293 --> 31:36:27.686
Once you install Python, you should also have this tool called PIP three installed and you can check by running PIP three dash dash version, or PIP dash dash version.

19335
31:36:27.686 --> 31:36:35.065
And we also want to install this sock select package just in case we're using weird versions of solidity to install.

19336
31:36:35.113 --> 31:36:40.029
So select, we run PIP three, install sock select, like that.

19337
31:36:40.113 --> 31:36:42.925
And then we can do sock, select, use.

19338
31:36:45.113 --> 31:36:48.078
version of solidity or slither to work with.

19339
31:36:49.113 --> 31:36:53.145
those tools, you can just run PIP three install slither analyzer like so.

19340
31:36:53.145 --> 31:36:56.467
And you can install slither into your Python environment.

19341
31:36:56.467 --> 31:36:57.918
I'm not going to run it because already have.

19342
31:36:57.918 --> 31:37:03.145
You can also learn how to do this all with Docker and we'll learn how to do this with Docker in a little bit.

19343
31:37:03.145 --> 31:37:07.467
Now in our package json, we actually have command script in our package.

19344
31:37:07.467 --> 31:37:12.218
JSON for running Slither, you'll know you've installed slither correctly.

19345
31:37:12.218 --> 31:37:19.063
If you can run Slither, dash dash help you get an output like this.

19346
31:37:19.063 --> 31:37:24.224
Now we can use slither to run it on our contracts folder by running this big command here.

19347
31:37:24.224 --> 31:37:25.564
So we'll say Slither.

19348
31:37:25.564 --> 31:37:40.293
And we want to run it on dot slash contracts, we need to tell it that it has some psaltery mappings, and every time it sees open Zeppelin, it should use Node module slash open Zeppelin and every time it sees chain link introduced node modules slash chain link.

19349
31:37:40.293 --> 31:37:42.985
And I'm just going to read from our package json.

19350
31:37:42.985 --> 31:37:49.768
And we're excluding a couple of functions that it runs and excluding builder ignore, but don't worry too much about that.

19351
31:37:49.768 --> 31:38:02.840
We've actually just run that by first running yarn to install all of our packages.

19352
31:38:03.113 --> 31:38:06.451
And after we've installed all of our packages, we can run yarn Slither.

19353
31:38:06.451 --> 31:38:09.790
Or you can copy paste that slither command and run it directly.

19354
31:38:09.790 --> 31:38:15.819
Now we'll get this massive output that looks like this with some red and some green.

19355
31:38:15.819 --> 31:38:24.282
Let's go through what's actually happening here, the way that we can read Slither, it'll list out a number of lines that have an issue and then a reference to that issue.

19356
31:38:24.282 --> 31:38:27.253
And each one of these is separated by a new line.

19357
31:38:27.253 --> 31:38:30.937
So that's a section that's exception, etc.

19358
31:38:31.113 --> 31:38:37.231
So if we get a red here, that means that there is a high impact issue that we definitely should address.

19359
31:38:37.231 --> 31:38:49.279
And it even comes with a reference link that we can copy paste and put into our browser and see what the issue is and more information from the slither tool about what that issue is and how to correct it.

19360
31:38:49.279 --> 31:38:53.695
We can see it catches our metamorphic contract issue.

19361
31:38:53.695 --> 31:38:56.492
It says metamorphic contract is never initialized.

19362
31:38:56.492 --> 31:38:59.149
It is used here in metamorphic dot kill.

19363
31:38:59.149 --> 31:39:13.490
The reason that this is a massive issue, if we go to our metamorphic contract outsole is that if we deploy this contract, somebody else could initialize this code, become the owner, and then automatically kill it before we even have a chance.

19364
31:39:13.490 --> 31:39:18.497
This is actually something that has happened in the past and has caused a ton of issues.

19365
31:39:18.497 --> 31:39:23.588
So if we see red in the terminal, this means Hey, massive issue, we should absolutely check it out.

19366
31:39:23.588 --> 31:39:25.809
Now there's gonna be a ton of green in here.

19367
31:39:25.809 --> 31:39:30.350
These are detectors that are probably low impact, and they're probably okay.

19368
31:39:30.350 --> 31:39:36.959
And in fact, we can see, it's even just calling out some opens up on stuff here, saying, Hey, we see some inline assembly.

19369
31:39:36.959 --> 31:39:39.806
Inline assembly is kind of scary, maybe don't use that.

19370
31:39:39.806 --> 31:39:56.613
So you can think of green as kind of a warning that there's a low likelihood that this will impact anything, but you might want to check it out, we get this different versions of solidity used, which is just saying, hey, there's a couple different versions of solidity that might be something you want to keep in mind, maybe you should use the same versions of solidity.

19371
31:39:56.613 --> 31:39:58.398
We have this allow old versions.

19372
31:39:58.398 --> 31:40:03.096
And this is actually why throughout this whole course, we've been using zero point 8.

19373
31:40:03.096 --> 31:40:04.870
7 Because zero point 8.

19374
31:40:04.870 --> 31:40:06.001
4 and zero point 8.

19375
31:40:06.001 --> 31:40:08.834
7 are considered more stable versions of solidity.

19376
31:40:08.834 --> 31:40:14.557
So if you're using versions outside of there, so there will say hey, maybe you want to work with a different version.

19377
31:40:14.557 --> 31:40:21.066
We have some flags in here about maybe Hey, you should make a variable constant because it never changes which is great.

19378
31:40:21.113 --> 31:40:28.246
Uses literal with too many digits saying hey, this Just kind of hard to read, maybe you screwed up some of the zeros, loud old versions.

19379
31:40:28.246 --> 31:40:32.050
And what's this reentrancy in ether store dot withdraw.

19380
31:40:32.050 --> 31:40:39.703
So just by running this slither tool, we can catch a reentrancy vulnerability in one of our contracts, which is fantastic.

19381
31:40:39.703 --> 31:40:46.313
So running the static analysis caught at least two huge vulnerabilities in our metamorphic contract.

19382
31:40:46.313 --> 31:41:01.800
And in our reentrancy contract, it didn't catch the issues involved at sole liquidity pool, or bad RNG, though, which is why we don't only want to rely on slither because it's not going to catch everything, but it will catch a lot of major vulnerabilities.

19383
31:41:01.800 --> 31:41:06.413
So that's how we can use Slither, at least from a middle middle stack point to get started.

19384
31:41:06.413 --> 31:41:08.909
So great, we just learned how to work with Slither.

19385
31:41:08.909 --> 31:41:12.779
That's one of the first tools that are really fantastic in our audit process.

19386
31:41:12.779 --> 31:41:23.988
And that's going to be considered a fast tool for static analysis, running tests, linters, etc, are also types of static analysis.

19387
31:41:24.113 --> 31:41:38.398
After we run a tool like that, we enter some manual analysis where we walk through the code ourselves manually, and maybe we do it in tangent with running some slower tools, like a kitna Manta Corp, and other symbolic execution tools.

19388
31:41:38.398 --> 31:41:43.630
Symbolic Execution is where we simulate executing transactions on the blockchain.

19389
31:41:43.630 --> 31:41:48.269
And one of these symbolic execution tools that we're going to work with is this a kidmin tool.

19390
31:41:48.269 --> 31:41:52.062
Again, this is a trail of bits tool for doing something called fuzz testing.

19391
31:41:52.113 --> 31:42:02.851
Now in programming, fuzzing or fuzz testing is an automated software testing technique that involves providing invalid unexpected or random data as inputs to a computer program.

19392
31:42:02.851 --> 31:42:10.048
In a lot of our code, oftentimes, we're going to get people interacting with them in ways that we will never think about.

19393
31:42:10.114 --> 31:42:17.469
So we want to be able to provide random data and random information to our test to see if something weird happens that we weren't expecting.

19394
31:42:17.469 --> 31:42:31.614
So we can actually build our own fuzz tests in our hard hat projects and run these fuzz tests, I've actually created a sample of fuzz tests, we write our fuzz tests in solidity, actually, as opposed to writing our tests in JavaScript.

19395
31:42:31.614 --> 31:42:34.621
So let's say for example, we've built this vault contract.

19396
31:42:34.621 --> 31:42:43.180
And we think that at first glance, hey, nobody should ever be able to know the password, and no one should ever be able to unlock this contract.

19397
31:42:43.180 --> 31:42:48.941
Which obviously, we know is ridiculous, because we know that anybody can read anything in a storage variable.

19398
31:42:48.941 --> 31:42:52.614
So we know that this should fail, but it might be hard to write a test.

19399
31:42:52.614 --> 31:42:54.780
To catch that this actually would fail.

19400
31:42:54.780 --> 31:43:03.458
A good approach to testing this would be to just send a ton of random bytes 32 objects to this unlock function to see if we can unlock it.

19401
31:43:03.458 --> 31:43:06.002
We can write a fuzz test to do exactly that.

19402
31:43:06.002 --> 31:43:10.574
So in my vault, fuzz test dot Sol, we're importing vault outsole.

19403
31:43:10.574 --> 31:43:17.304
And so we're saying vault fuzz test is vault and we have a password of 123, ASD 123.

19404
31:43:17.304 --> 31:43:29.294
And now we have a function called a kid and a test find password, where it's going to send a ton of random data into vault to try to make s locked equal false.

19405
31:43:29.294 --> 31:43:34.872
So we just say s locked equals true here, and our first test will try to make s locked equals false.

19406
31:43:34.872 --> 31:43:43.310
Now we could install just the kitna, but at this point, it's a good idea to bring up our the security toolbox from trail of bits.

19407
31:43:43.310 --> 31:43:58.050
So trail of bits has a package called the eath security toolbox, which has all their security tools in one single container kitna, Ethan o Manta core, slither, rattle, and not so smart contracts, it has all these in the same exact package.

19408
31:43:58.114 --> 31:43:59.725
Now to work with this toolbox.

19409
31:44:01.114 --> 31:44:01.399
installed.

19410
31:44:03.114 --> 31:44:07.914
And again, sometimes this can be the hardest part of the course is just installing these packages.

19411
31:44:07.914 --> 31:44:10.447
So we've left a link to Doc's dot docker.

19412
31:44:10.447 --> 31:44:25.429
com, get Docker to install Docker, to actually work with these tools, you're just going to come you're going to click whichever one of these is appropriate for you to install Docker, once we have Docker installed, we can run the E security toolbox by pulling it down from the Docker equivalent of GitHub.

19413
31:44:25.429 --> 31:44:35.364
And we're going to use a whole bunch of Docker commands that I'm not going to explain here because this isn't a Docker course, if you're looking to get into the security stuff, I would definitely recommend reading up on all these commands afterwards.

19414
31:44:35.364 --> 31:44:38.535
And we're going to leave a ton of links for you to learn more.

19415
31:44:38.535 --> 31:44:41.801
And in the package that JSON associated with this lesson.

19416
31:44:41.801 --> 31:44:44.852
We even have the command to get set up right in here.

19417
31:44:44.852 --> 31:44:49.012
So we can just run yarn toolbox, which will run our Docker command like this.

19418
31:44:49.012 --> 31:44:51.534
So I'm just going to run yarn toolbox.

19419
31:44:51.534 --> 31:44:59.780
And if you get something like this saying cannot connect to the Docker daemon is the Docker daemon running, because I need to have my Docker daemon running.

19420
31:44:59.780 --> 31:45:01.876
Since I installed Docker desktop.

19421
31:45:01.876 --> 31:45:06.605
I need to have my Docker engine started and running for it to actually be working.

19422
31:45:06.605 --> 31:45:07.780
Again to work with this.

19423
31:45:07.780 --> 31:45:14.786
There's a lot of Docker setup and configuration that needs to happen, which I'm going to leave a ton of instructions on how to get started with Docker.

19424
31:45:14.786 --> 31:45:16.286
Once we have Docker setup.

19425
31:45:16.286 --> 31:45:24.419
Now we can run yarn toolbox, which will stick us into a new shell to work with any of these tools that trilobites has Out of the box.

19426
31:45:24.419 --> 31:45:27.914
Now our vault fuzz test comes with a config as well.

19427
31:45:27.914 --> 31:45:32.419
This is in a Yamo file with all our arguments for running a kidnap.

19428
31:45:32.419 --> 31:45:37.637
So it has a test limit, which is how many different runs, we should do a time delay, block delay.

19429
31:45:37.637 --> 31:45:39.779
And then of course, some re mappings in here.

19430
31:45:39.779 --> 31:45:46.395
This darker shell will already have the security tools already installed like the Kidner test.

19431
31:45:46.395 --> 31:46:12.415
So we'll run a kinah test on SRC slash contracts slash test slash fuzzing slash fault fuzz test dot Sol dash dash contract will be vault fuzz test, dash dash config will be SRC slash contracts slash test slash buzzing slash config dot Yamo.

19432
31:46:12.415 --> 31:46:20.724
And we'll go ahead and we'll hit enter here, and it'll say analyzing contract, it'll give us an output like this, it will give us an output that looks like this.

19433
31:46:20.724 --> 31:46:26.825
What it's saying is it found a use case where it could make s locked equals false.

19434
31:46:26.825 --> 31:46:29.717
And the use case was 123, ASD 123.

19435
31:46:29.717 --> 31:46:36.133
So when what seemed like almost seconds, it found the password to unlock our contract.

19436
31:46:36.133 --> 31:46:47.064
And this is why running a fuzz tester can be so powerful, we thought our contract was secure, but it immediately found the password, which means anybody else could immediately find the password.

19437
31:46:47.114 --> 31:46:50.163
And this would be an indicator that what we're doing there is not a good setup.

19438
31:46:50.163 --> 31:46:52.130
So we'll hit CTRL C to escape.

19439
31:46:52.130 --> 31:46:55.562
And to leave our Docker setup here, we'll just write exit.

19440
31:46:55.562 --> 31:47:06.542
Now again, I'm going to leave a ton of links to work with a kidnapper and work with this fuzz tester in the GitHub repo associated with this lesson, so that you can go ahead and learn more.

19441
31:47:06.542 --> 31:47:12.796
Now, if you take anything away from this whole section, it should be this right here.

19442
31:47:12.796 --> 31:47:15.133
The two most common tasks are reentrant.

19443
31:47:15.133 --> 31:47:16.694
See, and Oracle manipulation.

19444
31:47:16.694 --> 31:47:28.075
So if you're not going to be an auditor, and you just want to deploy things to main net, always, always before you deploy anything, the absolute minimum that you should be doing is always running Slither.

19445
31:47:28.075 --> 31:47:32.606
And then looking manually for Oracle manipulation and reentrancy attacks.

19446
31:47:32.606 --> 31:47:37.043
If you see in your code that you're getting pricing information.

19447
31:47:37.114 --> 31:47:47.061
Price is a piece of data that we as humans have assigned to something if you're getting pricing information from a centralized location, rethink that scenario, rethink what you're doing there.

19448
31:47:47.061 --> 31:47:53.327
If you're getting a random number, if you're doing any type of automation from a centralized location, rethink it and change your strategy.

19449
31:47:53.327 --> 31:47:59.114
The chain link Oracle network has been created for a reason to prevent getting hacked like this.

19450
31:47:59.114 --> 31:48:05.063
So please keep these in mind before you deploy anything to main that with any type of security guarantees.

19451
31:48:05.114 --> 31:48:05.692
Okay, great.

19452
31:48:08.114 --> 31:48:09.828
learned about some of the slow tools.

19453
31:48:11.114 --> 31:48:11.850
Corp or Mythix.

19454
31:48:14.114 --> 31:48:17.372
Manta Corp is going to be another tool from the trilobites team.

19455
31:48:17.372 --> 31:48:29.818
And Mythix is actually a smart contract security service from the consensus team, you basically send a bot that they have running in the cloud your contracts and will do some automated process to check for security vulnerabilities.

19456
31:48:29.818 --> 31:48:30.898
This is a paid service.

19457
31:48:30.898 --> 31:48:36.060
But if you're going to be deploying a protocol that's worth millions of dollars, spending a few $1,000.

19458
31:48:36.114 --> 31:48:38.664
Spending a few $1,000 to make sure it actually does.

19459
31:48:39.114 --> 31:48:42.442
says is going to do correctly is definitely something that you want to invest in.

19460
31:48:42.442 --> 31:48:45.645
After you run through this whole process.

19461
31:48:45.645 --> 31:48:49.814
You the smart contract developers and the auditors should discuss their findings.

19462
31:48:49.814 --> 31:48:55.176
And if there's any issues, repeat the steps, repeat all the steps again after changes are made.

19463
31:48:55.176 --> 31:48:59.442
So this audit process and making sure your contracts are secure is a long process.

19464
31:48:59.442 --> 31:49:07.017
And then afterwards, an auditor will finally write your report with all security vulnerabilities and everything that they found in your contracts.

19465
31:49:07.017 --> 31:49:20.844
Typically, you'll organize reports in a chart that'll look something like this, you'll label issues that have a high chance of happening and have a high impact as critical things that have a high impact, but a low likelihood as medium, and etc.

19466
31:49:20.844 --> 31:49:27.277
I'm also going to leave some examples two audits that have been done in the past so that you can take a look at them.

19467
31:49:27.277 --> 31:49:30.243
And you can see what a full audit looks like on certain code.

19468
31:49:30.243 --> 31:49:37.372
We'll be looking at openzeppelin sigma prime, and trilobites, because these are three of what I think are some of the best auditors in the space.

19469
31:49:37.372 --> 31:49:38.561
Now in the GitHub repo.

19470
31:49:38.561 --> 31:49:45.377
We also have a ton of other tools that you can use Mythix, mithril ethers play and consensus security tools.

19471
31:49:45.377 --> 31:49:53.581
If you want to learn more about security and auditing, I highly recommend that after this course you play the Ethernet game and damn vulnerable Defy.

19472
31:49:53.581 --> 31:49:56.573
These are two games that will teach you a ton about security.

19473
31:49:56.573 --> 31:50:00.780
And we'll test the chops and we'll test everything that you've learned in this course.

19474
31:50:00.780 --> 31:50:04.014
There's also a couple of security focused blogs that I really like.

19475
31:50:04.014 --> 31:50:06.385
One of them in particular is wrecked dot news.

19476
31:50:06.385 --> 31:50:15.045
They keep a running list of some of the largest hacks that have ever happened in the space and then retrospectives on why those actually happened.

19477
31:50:15.045 --> 31:50:17.447
And they usually make it very entertaining as well.

19478
31:50:17.447 --> 31:50:19.980
We have some articles in here as well.

19479
31:50:20.114 --> 31:50:40.046
One of the best places to look at is this known attacks section where they talk Talk about reentrancy, Oracle manipulation, front running and a ton of other attacks that you should absolutely be aware of when writing your smart contracts, we're not going to go over them here because they do a great job in these resources explaining them, you should also check out this article because I helped write it.

19480
31:50:40.046 --> 31:50:41.507
So definitely check that out.

19481
31:50:41.507 --> 31:50:43.867
And then we've got a list to even more sections.

19482
31:50:43.867 --> 31:50:46.991
So this is going to be a living section here.

19483
31:50:46.991 --> 31:50:48.239
So please feel free.

19484
31:50:48.239 --> 31:51:01.736
If you find more things in the future, please feel free to make pull requests and update this repository so that other people can learn and know more about security and auditing and have contract examples on what bad code looks like and how to actually catch them.

19485
31:51:01.736 --> 31:51:03.584
Even though this was one of our quickest sections.

19486
31:51:03.584 --> 31:51:10.041
From a video standpoint, this actually is going to be one of the longest sections of your career.

19487
31:51:10.114 --> 31:51:13.065
Security is something that is always going to be on your mind.

19488
31:51:13.114 --> 31:51:16.066
And there's always going to be new tools to help with security.

19489
31:51:16.114 --> 31:51:17.980
And there's always going to be new things to think about.

19490
31:51:18.114 --> 31:51:26.303
even though we went through this very quickly, I would 100% want you to pause this video, and work with and try out some of the tools we tried here.

19491
31:51:26.303 --> 31:51:31.004
And then maybe even try coming up with your own vulnerabilities as well.

19492
31:51:31.004 --> 31:51:59.694
And with that being said, you have just finished the last section of this massive master course on learning smart contracts, solidity, web three and blockchain development, you should be incredibly proud of yourself.

19493
31:51:59.694 --> 31:52:19.622
Congratulations, I and the web three community as a whole want to congratulate you for completing this absolutely monstrosity of a tutorial, you have done an amazing job to get this far.

19494
31:52:19.622 --> 31:52:22.221
And to watch me talking to you right now.

19495
31:52:22.221 --> 31:52:26.780
And if you haven't finished the course, go back and finish it before coming here.

19496
31:52:26.780 --> 31:52:29.726
We have learned so much on this journey.

19497
31:52:29.726 --> 31:52:42.307
And I can say from the bottom of my soul that I am so glad to have you in the web three space, smart contract space, the blockchain space, the cryptocurrency space, we are so excited that you're here.

19498
31:52:42.307 --> 31:52:47.796
I'm really looking forward to seeing you in the web three in the blockchain community.

19499
31:52:47.796 --> 31:52:53.283
Now a lot of people ask, Well, where do I go? Now, I didn't have all this newfound knowledge.

19500
31:52:53.283 --> 31:52:57.047
I'm armed with the intelligence of the web three developer space.

19501
31:52:57.047 --> 31:53:02.533
Well, I've left some links in the GitHub repository to lead you to those next steps.

19502
31:53:02.533 --> 31:53:09.482
But the biggest thing that you can do for yourself right now is go take what you've learned, and apply it somewhere.

19503
31:53:09.482 --> 31:53:15.130
This is going to be probably the most thorough course you will ever go through in this space.

19504
31:53:15.130 --> 31:53:19.458
And you can go tutorial to tutorial and boot camp to bootcamp all you want.

19505
31:53:19.458 --> 31:53:24.300
But at some point, you have to make that leap, and you have to dive in.

19506
31:53:24.300 --> 31:53:27.775
And that's where the majority of the growth is going to be anyways.

19507
31:53:27.775 --> 31:53:31.864
So if you're here, wondering where to go next, go join a hackathon.

19508
31:53:31.864 --> 31:53:41.355
Go start jumping into issues on GitHub repos, go start applying for grants, go start applying for jobs and say, I took Patrick's massive course.

19509
31:53:41.355 --> 31:53:46.677
Here's my GitHub repo, work on a personal project, work on somebody else's project.

19510
31:53:46.677 --> 31:53:51.989
Take this knowledge and apply it, the challenges that you'll run into and the challenges that you'll face.

19511
31:53:51.989 --> 31:54:00.047
Really trying to do something without me hand holding you is where you're going to learn 10 times as much as what you've learned here.

19512
31:54:00.114 --> 31:54:03.355
I've walked through as deep down this rabbit hole as I can take you.

19513
31:54:03.355 --> 31:54:07.709
Now it's up to you to go out and do something with it.

19514
31:54:07.709 --> 31:54:10.598
So thank you, everybody who helped me create this course.

19515
31:54:10.598 --> 31:54:12.580
Thank you for taking this course.

19516
31:54:12.580 --> 31:54:20.114
And I'm so excited to see you in the community and see what you build and see what we can create with this technology.

